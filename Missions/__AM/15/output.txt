// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33924 0 0
// InitNature ;
  19: CALL 33748 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10891 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14798 0 0
// MC_Start ( ) ;
  60: CALL 36036 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58417 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58510 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57860 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57675 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58417 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58510 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57675 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57860 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 58290 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57357 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58417 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58510 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57675 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58417 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58510 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57567 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58828 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57999 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 58290 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 58290 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58622 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57675 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 58241 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 64067 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 71182 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 71182 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 71182 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 71182 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 71182 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 64067 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64067 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64067 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 64067 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 64067 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 64067 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 64067 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 64067 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 64067 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 64067 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 64067 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 64067 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 64067 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 64067 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 64067 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 64067 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 64067 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 64067 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 64067 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 64067 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 64067 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 64067 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 64067 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 64067 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 64067 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 64067 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 64067 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 64067 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 71182 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 64067 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 64067 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 64067 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 74591 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 71182 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57860 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57723 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 59141 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57723 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57723 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 59141 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 59141 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 71182 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 74591 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106927 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106927 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106975 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106975 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 71182 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 5
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 71182 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 5
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 71182 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 6
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 71182 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 71182 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 71182 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 71182 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 71182 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9901
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 9100
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: PUSH
9334: LD_OWVAR 67
9338: PUSH
9339: LD_INT 1
9341: GREATER
9342: AND
9343: IFFALSE 9371
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9345: LD_INT 53
9347: PPUSH
9348: LD_INT 6
9350: PPUSH
9351: LD_INT 2
9353: PPUSH
9354: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9358: LD_INT 59
9360: PPUSH
9361: LD_INT 6
9363: PPUSH
9364: LD_INT 2
9366: PPUSH
9367: CALL_OW 322
// end ; if activeAttacks then
9371: LD_EXP 16
9375: IFFALSE 9895
// begin if missionStage = 2 then
9377: LD_EXP 15
9381: PUSH
9382: LD_INT 2
9384: EQUAL
9385: IFFALSE 9395
// strength := 1 ;
9387: LD_ADDR_VAR 0 5
9391: PUSH
9392: LD_INT 1
9394: ST_TO_ADDR
// if missionStage > 2 then
9395: LD_EXP 15
9399: PUSH
9400: LD_INT 2
9402: GREATER
9403: IFFALSE 9413
// strength := 2 ;
9405: LD_ADDR_VAR 0 5
9409: PUSH
9410: LD_INT 2
9412: ST_TO_ADDR
// if missionStage > 6 then
9413: LD_EXP 15
9417: PUSH
9418: LD_INT 6
9420: GREATER
9421: IFFALSE 9431
// strength := 3 ;
9423: LD_ADDR_VAR 0 5
9427: PUSH
9428: LD_INT 3
9430: ST_TO_ADDR
// if missionStage > 10 then
9431: LD_EXP 15
9435: PUSH
9436: LD_INT 10
9438: GREATER
9439: IFFALSE 9449
// strength := 4 ;
9441: LD_ADDR_VAR 0 5
9445: PUSH
9446: LD_INT 4
9448: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9449: LD_ADDR_VAR 0 2
9453: PUSH
9454: LD_VAR 0 5
9458: PPUSH
9459: CALL 8011 0 1
9463: ST_TO_ADDR
// for i in tmp do
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: FOR_IN
9475: IFFALSE 9575
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9477: LD_VAR 0 1
9481: PPUSH
9482: LD_VAR 0 4
9486: PUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 2
9492: PPUSH
9493: CALL_OW 12
9497: ARRAY
9498: PPUSH
9499: LD_INT 0
9501: PPUSH
9502: CALL_OW 49
// if i = sewiVeh then
9506: LD_VAR 0 1
9510: PUSH
9511: LD_EXP 68
9515: EQUAL
9516: IFFALSE 9551
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9518: LD_ADDR_EXP 67
9522: PUSH
9523: LD_STRING Vsevolod
9525: PPUSH
9526: LD_INT 0
9528: PPUSH
9529: LD_STRING 
9531: PPUSH
9532: CALL 64067 0 3
9536: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9537: LD_EXP 67
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9551: LD_VAR 0 1
9555: PPUSH
9556: LD_INT 111
9558: PPUSH
9559: LD_INT 197
9561: PPUSH
9562: CALL_OW 111
// wait ( 0 0$2 ) ;
9566: LD_INT 70
9568: PPUSH
9569: CALL_OW 67
// end ;
9573: GO 9474
9575: POP
9576: POP
// repeat wait ( 0 0$1 ) ;
9577: LD_INT 35
9579: PPUSH
9580: CALL_OW 67
// for i in tmp do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_VAR 0 2
9593: PUSH
9594: FOR_IN
9595: IFFALSE 9876
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9597: LD_INT 81
9599: PUSH
9600: LD_INT 6
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_VAR 0 1
9614: PUSH
9615: LD_INT 12
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PPUSH
9627: CALL_OW 69
9631: IFFALSE 9689
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9633: LD_VAR 0 1
9637: PPUSH
9638: LD_INT 81
9640: PUSH
9641: LD_INT 6
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 91
9650: PUSH
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 12
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: PPUSH
9673: LD_VAR 0 1
9677: PPUSH
9678: CALL_OW 74
9682: PPUSH
9683: CALL_OW 115
9687: GO 9874
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9689: LD_INT 9
9691: PPUSH
9692: LD_INT 81
9694: PUSH
9695: LD_INT 6
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 70
9706: IFFALSE 9840
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9708: LD_VAR 0 1
9712: PPUSH
9713: LD_VAR 0 6
9717: PUSH
9718: LD_INT 1
9720: ARRAY
9721: PUSH
9722: LD_INT 1
9724: ARRAY
9725: PPUSH
9726: LD_VAR 0 6
9730: PUSH
9731: LD_INT 1
9733: ARRAY
9734: PUSH
9735: LD_INT 2
9737: ARRAY
9738: PPUSH
9739: CALL_OW 297
9743: PUSH
9744: LD_INT 10
9746: GREATER
9747: PUSH
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_INT 9
9755: PPUSH
9756: CALL_OW 308
9760: NOT
9761: AND
9762: IFFALSE 9801
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9764: LD_VAR 0 1
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 1
9780: ARRAY
9781: PPUSH
9782: LD_VAR 0 6
9786: PUSH
9787: LD_INT 1
9789: ARRAY
9790: PUSH
9791: LD_INT 2
9793: ARRAY
9794: PPUSH
9795: CALL_OW 114
9799: GO 9838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9801: LD_VAR 0 1
9805: PPUSH
9806: LD_INT 9
9808: PPUSH
9809: LD_INT 81
9811: PUSH
9812: LD_INT 6
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PPUSH
9819: CALL_OW 70
9823: PPUSH
9824: LD_VAR 0 1
9828: PPUSH
9829: CALL_OW 74
9833: PPUSH
9834: CALL_OW 115
// end else
9838: GO 9874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9840: LD_VAR 0 1
9844: PPUSH
9845: LD_INT 81
9847: PUSH
9848: LD_INT 6
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PPUSH
9855: CALL_OW 69
9859: PPUSH
9860: LD_VAR 0 1
9864: PPUSH
9865: CALL_OW 74
9869: PPUSH
9870: CALL_OW 115
// end ;
9874: GO 9594
9876: POP
9877: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9878: LD_INT 22
9880: PUSH
9881: LD_INT 6
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PPUSH
9888: CALL_OW 69
9892: NOT
9893: IFFALSE 9577
// end ; until russianDestroyed ;
9895: LD_EXP 21
9899: IFFALSE 9225
// end ;
9901: PPOPN 6
9903: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9904: LD_EXP 21
9908: NOT
9909: PUSH
9910: LD_EXP 15
9914: PUSH
9915: LD_INT 6
9917: GREATEREQUAL
9918: AND
9919: PUSH
9920: LD_INT 2
9922: PPUSH
9923: LD_INT 1
9925: PPUSH
9926: CALL 59141 0 2
9930: NOT
9931: AND
9932: IFFALSE 10888
9934: GO 9936
9936: DISABLE
9937: LD_INT 0
9939: PPUSH
9940: PPUSH
9941: PPUSH
9942: PPUSH
// begin enable ;
9943: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9944: LD_INT 22
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: LD_INT 30
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 69
9972: NOT
9973: IFFALSE 9977
// exit ;
9975: GO 10888
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9977: LD_ADDR_VAR 0 4
9981: PUSH
9982: LD_INT 22
9984: PUSH
9985: LD_INT 3
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: LD_INT 30
9994: PUSH
9995: LD_INT 34
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: ST_TO_ADDR
// if Prob ( 40 ) then
10011: LD_INT 40
10013: PPUSH
10014: CALL_OW 13
10018: IFFALSE 10145
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10020: LD_INT 2
10022: PPUSH
10023: LD_INT 22
10025: PUSH
10026: LD_INT 3
10028: PUSH
10029: LD_INT 3
10031: PUSH
10032: LD_INT 49
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 22
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: LD_INT 3
10049: PUSH
10050: LD_INT 49
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: PUSH
10059: LD_INT 22
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 49
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 24
10079: PUSH
10080: LD_INT 3
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 46
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: PUSH
10095: LD_INT 24
10097: PUSH
10098: LD_INT 3
10100: PUSH
10101: LD_INT 3
10103: PUSH
10104: LD_INT 46
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 46
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PPUSH
10139: CALL 57723 0 2
// end else
10143: GO 10268
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10145: LD_INT 2
10147: PPUSH
10148: LD_INT 24
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: LD_INT 3
10156: PUSH
10157: LD_INT 47
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 24
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 47
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: PUSH
10184: LD_INT 24
10186: PUSH
10187: LD_INT 3
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: LD_INT 47
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 24
10204: PUSH
10205: LD_INT 3
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: LD_INT 46
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 24
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: LD_INT 46
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 24
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 46
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PPUSH
10264: CALL 57723 0 2
// end ; if Difficulty > 1 then
10268: LD_OWVAR 67
10272: PUSH
10273: LD_INT 1
10275: GREATER
10276: IFFALSE 10306
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 47
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: PPUSH
10302: CALL 57723 0 2
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10313: LD_INT 2
10315: PPUSH
10316: LD_INT 1
10318: PPUSH
10319: CALL 59141 0 2
10323: PUSH
10324: LD_INT 6
10326: PUSH
10327: LD_INT 7
10329: PUSH
10330: LD_INT 7
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: PUSH
10338: LD_OWVAR 67
10342: ARRAY
10343: GREATEREQUAL
10344: IFFALSE 10306
// wait ( 0 0$30 ) ;
10346: LD_INT 1050
10348: PPUSH
10349: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10353: LD_ADDR_VAR 0 2
10357: PUSH
10358: LD_INT 2
10360: PPUSH
10361: LD_INT 1
10363: PPUSH
10364: CALL 59141 0 2
10368: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10369: LD_ADDR_EXP 118
10373: PUSH
10374: LD_EXP 118
10378: PPUSH
10379: LD_INT 2
10381: PPUSH
10382: LD_EXP 118
10386: PUSH
10387: LD_INT 2
10389: ARRAY
10390: PUSH
10391: LD_VAR 0 2
10395: DIFF
10396: PPUSH
10397: CALL_OW 1
10401: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10402: LD_ADDR_VAR 0 3
10406: PUSH
10407: LD_INT 0
10409: PPUSH
10410: LD_INT 1
10412: PPUSH
10413: CALL_OW 12
10417: ST_TO_ADDR
// if target then
10418: LD_VAR 0 3
10422: IFFALSE 10550
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 250
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PPUSH
10444: CALL_OW 72
10448: ST_TO_ADDR
// for i in tmp do
10449: LD_ADDR_VAR 0 1
10453: PUSH
10454: LD_VAR 0 2
10458: PUSH
10459: FOR_IN
10460: IFFALSE 10500
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10462: LD_VAR 0 1
10466: PPUSH
10467: LD_INT 139
10469: PPUSH
10470: LD_INT 89
10472: PPUSH
10473: CALL_OW 297
10477: PUSH
10478: LD_INT 9
10480: GREATER
10481: IFFALSE 10498
// ComMoveXY ( i , 139 , 89 ) ;
10483: LD_VAR 0 1
10487: PPUSH
10488: LD_INT 139
10490: PPUSH
10491: LD_INT 89
10493: PPUSH
10494: CALL_OW 111
10498: GO 10459
10500: POP
10501: POP
// wait ( 0 0$1 ) ;
10502: LD_INT 35
10504: PPUSH
10505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10509: LD_VAR 0 2
10513: PPUSH
10514: LD_INT 92
10516: PUSH
10517: LD_INT 139
10519: PUSH
10520: LD_INT 89
10522: PUSH
10523: LD_INT 9
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: PPUSH
10532: CALL_OW 72
10536: PUSH
10537: LD_VAR 0 2
10541: PUSH
10542: LD_INT 1
10544: MINUS
10545: GREATEREQUAL
10546: IFFALSE 10424
// end else
10548: GO 10692
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ARRAY
10563: PPUSH
10564: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10568: LD_ADDR_VAR 0 2
10572: PUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 250
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 72
10592: ST_TO_ADDR
// for i in tmp do
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_VAR 0 2
10602: PUSH
10603: FOR_IN
10604: IFFALSE 10644
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_INT 124
10613: PPUSH
10614: LD_INT 139
10616: PPUSH
10617: CALL_OW 297
10621: PUSH
10622: LD_INT 9
10624: GREATER
10625: IFFALSE 10642
// ComMoveXY ( i , 124 , 139 ) ;
10627: LD_VAR 0 1
10631: PPUSH
10632: LD_INT 124
10634: PPUSH
10635: LD_INT 139
10637: PPUSH
10638: CALL_OW 111
10642: GO 10603
10644: POP
10645: POP
// wait ( 0 0$1 ) ;
10646: LD_INT 35
10648: PPUSH
10649: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10653: LD_VAR 0 2
10657: PPUSH
10658: LD_INT 92
10660: PUSH
10661: LD_INT 124
10663: PUSH
10664: LD_INT 139
10666: PUSH
10667: LD_INT 9
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 72
10680: PUSH
10681: LD_VAR 0 2
10685: PUSH
10686: LD_INT 1
10688: MINUS
10689: GREATEREQUAL
10690: IFFALSE 10568
// end ; repeat wait ( 0 0$1 ) ;
10692: LD_INT 35
10694: PPUSH
10695: CALL_OW 67
// for i in tmp do
10699: LD_ADDR_VAR 0 1
10703: PUSH
10704: LD_VAR 0 2
10708: PUSH
10709: FOR_IN
10710: IFFALSE 10879
// begin if GetLives ( i ) > 251 then
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL_OW 256
10721: PUSH
10722: LD_INT 251
10724: GREATER
10725: IFFALSE 10850
// begin if GetWeapon ( i ) = ru_time_lapser then
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 264
10736: PUSH
10737: LD_INT 49
10739: EQUAL
10740: IFFALSE 10796
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10742: LD_VAR 0 1
10746: PPUSH
10747: LD_INT 2
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 1
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: LD_INT 22
10762: PUSH
10763: LD_INT 8
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: LIST
10774: PPUSH
10775: CALL_OW 69
10779: PPUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 74
10789: PPUSH
10790: CALL_OW 112
10794: GO 10848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10796: LD_VAR 0 1
10800: PPUSH
10801: LD_INT 2
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 1
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 22
10816: PUSH
10817: LD_INT 8
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: LIST
10828: PPUSH
10829: CALL_OW 69
10833: PPUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 74
10843: PPUSH
10844: CALL_OW 115
// end else
10848: GO 10877
// if IsDead ( i ) then
10850: LD_VAR 0 1
10854: PPUSH
10855: CALL_OW 301
10859: IFFALSE 10877
// tmp := tmp diff i ;
10861: LD_ADDR_VAR 0 2
10865: PUSH
10866: LD_VAR 0 2
10870: PUSH
10871: LD_VAR 0 1
10875: DIFF
10876: ST_TO_ADDR
// end ;
10877: GO 10709
10879: POP
10880: POP
// until not tmp ;
10881: LD_VAR 0 2
10885: NOT
10886: IFFALSE 10692
// end ; end_of_file
10888: PPOPN 4
10890: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10891: LD_INT 0
10893: PPUSH
10894: PPUSH
10895: PPUSH
10896: PPUSH
10897: PPUSH
10898: PPUSH
// side := 7 ;
10899: LD_ADDR_VAR 0 5
10903: PUSH
10904: LD_INT 7
10906: ST_TO_ADDR
// uc_side := side ;
10907: LD_ADDR_OWVAR 20
10911: PUSH
10912: LD_VAR 0 5
10916: ST_TO_ADDR
// uc_nation := 1 ;
10917: LD_ADDR_OWVAR 21
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10925: LD_ADDR_VAR 0 2
10929: PUSH
10930: LD_INT 22
10932: PUSH
10933: LD_VAR 0 5
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: LD_INT 21
10944: PUSH
10945: LD_INT 3
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PUSH
10961: FOR_IN
10962: IFFALSE 10978
// SetBLevel ( i , 10 ) ;
10964: LD_VAR 0 2
10968: PPUSH
10969: LD_INT 10
10971: PPUSH
10972: CALL_OW 241
10976: GO 10961
10978: POP
10979: POP
// base := GetBase ( al_depot ) ;
10980: LD_ADDR_VAR 0 4
10984: PUSH
10985: LD_INT 2
10987: PPUSH
10988: CALL_OW 274
10992: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10993: LD_ADDR_VAR 0 6
10997: PUSH
10998: LD_INT 22
11000: PUSH
11001: LD_VAR 0 5
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 30
11012: PUSH
11013: LD_INT 34
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PPUSH
11024: CALL_OW 69
11028: ST_TO_ADDR
// if teleport then
11029: LD_VAR 0 6
11033: IFFALSE 11054
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11035: LD_VAR 0 6
11039: PUSH
11040: LD_INT 1
11042: ARRAY
11043: PPUSH
11044: LD_INT 262
11046: PPUSH
11047: LD_INT 119
11049: PPUSH
11050: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11054: LD_VAR 0 4
11058: PPUSH
11059: LD_INT 1
11061: PPUSH
11062: LD_INT 19500
11064: PPUSH
11065: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11069: LD_VAR 0 4
11073: PPUSH
11074: LD_INT 2
11076: PPUSH
11077: LD_INT 200
11079: PPUSH
11080: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11084: LD_VAR 0 4
11088: PPUSH
11089: LD_INT 3
11091: PPUSH
11092: LD_INT 650
11094: PPUSH
11095: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11099: LD_ADDR_EXP 71
11103: PUSH
11104: LD_STRING Roth
11106: PPUSH
11107: CALL_OW 25
11111: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11112: LD_ADDR_EXP 72
11116: PUSH
11117: LD_STRING Simms
11119: PPUSH
11120: LD_EXP 1
11124: NOT
11125: PPUSH
11126: LD_STRING 10c_
11128: PPUSH
11129: CALL 64067 0 3
11133: ST_TO_ADDR
// if not Simms then
11134: LD_EXP 72
11138: NOT
11139: IFFALSE 11169
// begin uc_nation := 1 ;
11141: LD_ADDR_OWVAR 21
11145: PUSH
11146: LD_INT 1
11148: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11149: LD_INT 2
11151: PPUSH
11152: LD_INT 10
11154: PPUSH
11155: CALL_OW 384
// Simms := CreateHuman ;
11159: LD_ADDR_EXP 72
11163: PUSH
11164: CALL_OW 44
11168: ST_TO_ADDR
// end ; uc_nation := 3 ;
11169: LD_ADDR_OWVAR 21
11173: PUSH
11174: LD_INT 3
11176: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11177: LD_ADDR_EXP 73
11181: PUSH
11182: LD_STRING Kirilenkova
11184: PPUSH
11185: CALL_OW 25
11189: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11190: LD_ADDR_EXP 87
11194: PUSH
11195: LD_STRING Oblukov
11197: PPUSH
11198: CALL_OW 25
11202: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11203: LD_ADDR_EXP 74
11207: PUSH
11208: LD_STRING Dolgov
11210: PPUSH
11211: CALL_OW 25
11215: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11216: LD_ADDR_EXP 75
11220: PUSH
11221: LD_STRING Petrosyan
11223: PPUSH
11224: CALL_OW 25
11228: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11229: LD_ADDR_EXP 86
11233: PUSH
11234: LD_STRING Scholtze
11236: PPUSH
11237: CALL_OW 25
11241: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11242: LD_ADDR_EXP 85
11246: PUSH
11247: LD_STRING Kapitsova
11249: PPUSH
11250: CALL_OW 25
11254: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11255: LD_ADDR_EXP 76
11259: PUSH
11260: LD_STRING Petrovova
11262: PPUSH
11263: CALL_OW 25
11267: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11268: LD_ADDR_EXP 77
11272: PUSH
11273: LD_STRING Kuzmov
11275: PPUSH
11276: CALL_OW 25
11280: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11281: LD_ADDR_EXP 84
11285: PUSH
11286: LD_STRING Karamazov
11288: PPUSH
11289: CALL_OW 25
11293: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11294: LD_STRING 13_Lipshchin_1
11296: PPUSH
11297: LD_INT 0
11299: PPUSH
11300: CALL_OW 30
11304: IFFALSE 11319
// Lipshchin := NewCharacter ( Lipshchin ) ;
11306: LD_ADDR_EXP 78
11310: PUSH
11311: LD_STRING Lipshchin
11313: PPUSH
11314: CALL_OW 25
11318: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11319: LD_STRING 13_Titov_1
11321: PPUSH
11322: LD_INT 0
11324: PPUSH
11325: CALL_OW 30
11329: IFFALSE 11344
// Titov := NewCharacter ( Titov ) ;
11331: LD_ADDR_EXP 80
11335: PUSH
11336: LD_STRING Titov
11338: PPUSH
11339: CALL_OW 25
11343: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11344: LD_STRING 13_Gnyevko_1
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 30
11354: IFFALSE 11369
// Gnyevko := NewCharacter ( Gnyevko ) ;
11356: LD_ADDR_EXP 79
11360: PUSH
11361: LD_STRING Gnyevko
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11369: LD_STRING 13_Xavier_1
11371: PPUSH
11372: LD_INT 0
11374: PPUSH
11375: CALL_OW 30
11379: IFFALSE 11394
// Xavier := NewCharacter ( Xavier2 ) ;
11381: LD_ADDR_EXP 81
11385: PUSH
11386: LD_STRING Xavier2
11388: PPUSH
11389: CALL_OW 25
11393: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11394: LD_STRING 13_Belkov_1
11396: PPUSH
11397: LD_INT 0
11399: PPUSH
11400: CALL_OW 30
11404: IFFALSE 11419
// Belkov := NewCharacter ( Belkov ) ;
11406: LD_ADDR_EXP 82
11410: PUSH
11411: LD_STRING Belkov
11413: PPUSH
11414: CALL_OW 25
11418: ST_TO_ADDR
// if not BurlakStatus then
11419: LD_EXP 9
11423: NOT
11424: IFFALSE 11439
// Burlak = NewCharacter ( Burlak ) ;
11426: LD_ADDR_EXP 83
11430: PUSH
11431: LD_STRING Burlak
11433: PPUSH
11434: CALL_OW 25
11438: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11439: LD_ADDR_VAR 0 3
11443: PUSH
11444: LD_EXP 71
11448: PUSH
11449: LD_EXP 73
11453: PUSH
11454: LD_EXP 87
11458: PUSH
11459: LD_EXP 74
11463: PUSH
11464: LD_EXP 75
11468: PUSH
11469: LD_EXP 86
11473: PUSH
11474: LD_EXP 85
11478: PUSH
11479: LD_EXP 76
11483: PUSH
11484: LD_EXP 77
11488: PUSH
11489: LD_EXP 84
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: ST_TO_ADDR
// if Simms then
11506: LD_EXP 72
11510: IFFALSE 11528
// tmp := tmp ^ Simms ;
11512: LD_ADDR_VAR 0 3
11516: PUSH
11517: LD_VAR 0 3
11521: PUSH
11522: LD_EXP 72
11526: ADD
11527: ST_TO_ADDR
// if Titov then
11528: LD_EXP 80
11532: IFFALSE 11550
// tmp := tmp ^ Titov ;
11534: LD_ADDR_VAR 0 3
11538: PUSH
11539: LD_VAR 0 3
11543: PUSH
11544: LD_EXP 80
11548: ADD
11549: ST_TO_ADDR
// if Lipshchin then
11550: LD_EXP 78
11554: IFFALSE 11572
// tmp := tmp ^ Lipshchin ;
11556: LD_ADDR_VAR 0 3
11560: PUSH
11561: LD_VAR 0 3
11565: PUSH
11566: LD_EXP 78
11570: ADD
11571: ST_TO_ADDR
// if Gnyevko then
11572: LD_EXP 79
11576: IFFALSE 11594
// tmp := tmp ^ Gnyevko ;
11578: LD_ADDR_VAR 0 3
11582: PUSH
11583: LD_VAR 0 3
11587: PUSH
11588: LD_EXP 79
11592: ADD
11593: ST_TO_ADDR
// if Xavier then
11594: LD_EXP 81
11598: IFFALSE 11616
// tmp := tmp ^ Xavier ;
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: LD_VAR 0 3
11609: PUSH
11610: LD_EXP 81
11614: ADD
11615: ST_TO_ADDR
// if Belkov then
11616: LD_EXP 82
11620: IFFALSE 11638
// tmp := tmp ^ Belkov ;
11622: LD_ADDR_VAR 0 3
11626: PUSH
11627: LD_VAR 0 3
11631: PUSH
11632: LD_EXP 82
11636: ADD
11637: ST_TO_ADDR
// if Burlak then
11638: LD_EXP 83
11642: IFFALSE 11660
// tmp := tmp ^ Burlak ;
11644: LD_ADDR_VAR 0 3
11648: PUSH
11649: LD_VAR 0 3
11653: PUSH
11654: LD_EXP 83
11658: ADD
11659: ST_TO_ADDR
// for i = 1 to 8 do
11660: LD_ADDR_VAR 0 2
11664: PUSH
11665: DOUBLE
11666: LD_INT 1
11668: DEC
11669: ST_TO_ADDR
11670: LD_INT 8
11672: PUSH
11673: FOR_TO
11674: IFFALSE 11740
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11676: LD_ADDR_OWVAR 21
11680: PUSH
11681: LD_INT 1
11683: PUSH
11684: LD_INT 3
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 2
11696: PPUSH
11697: CALL_OW 12
11701: ARRAY
11702: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11703: LD_INT 0
11705: PPUSH
11706: LD_VAR 0 2
11710: PUSH
11711: LD_INT 2
11713: DIV
11714: PPUSH
11715: LD_INT 10
11717: PPUSH
11718: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: CALL_OW 44
11736: ADD
11737: ST_TO_ADDR
// end ;
11738: GO 11673
11740: POP
11741: POP
// for i in tmp do
11742: LD_ADDR_VAR 0 2
11746: PUSH
11747: LD_VAR 0 3
11751: PUSH
11752: FOR_IN
11753: IFFALSE 11778
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11755: LD_VAR 0 2
11759: PPUSH
11760: LD_INT 260
11762: PPUSH
11763: LD_INT 235
11765: PPUSH
11766: LD_INT 8
11768: PPUSH
11769: LD_INT 0
11771: PPUSH
11772: CALL_OW 50
11776: GO 11752
11778: POP
11779: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11780: LD_ADDR_EXP 99
11784: PUSH
11785: LD_EXP 99
11789: PPUSH
11790: LD_INT 1
11792: PPUSH
11793: LD_INT 22
11795: PUSH
11796: LD_VAR 0 5
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 3
11807: PUSH
11808: LD_INT 21
11810: PUSH
11811: LD_INT 2
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: PPUSH
11826: CALL_OW 69
11830: PUSH
11831: LD_EXP 71
11835: PUSH
11836: LD_EXP 72
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: DIFF
11845: PPUSH
11846: CALL_OW 1
11850: ST_TO_ADDR
// uc_side := 0 ;
11851: LD_ADDR_OWVAR 20
11855: PUSH
11856: LD_INT 0
11858: ST_TO_ADDR
// uc_nation := 0 ;
11859: LD_ADDR_OWVAR 21
11863: PUSH
11864: LD_INT 0
11866: ST_TO_ADDR
// for i = 1 to 5 do
11867: LD_ADDR_VAR 0 2
11871: PUSH
11872: DOUBLE
11873: LD_INT 1
11875: DEC
11876: ST_TO_ADDR
11877: LD_INT 5
11879: PUSH
11880: FOR_TO
11881: IFFALSE 11918
// begin InitHc ;
11883: CALL_OW 19
// hc_class := class_apeman ;
11887: LD_ADDR_OWVAR 28
11891: PUSH
11892: LD_INT 12
11894: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11895: CALL_OW 44
11899: PPUSH
11900: LD_INT 299
11902: PPUSH
11903: LD_INT 229
11905: PPUSH
11906: LD_INT 10
11908: PPUSH
11909: LD_INT 0
11911: PPUSH
11912: CALL_OW 50
// end ;
11916: GO 11880
11918: POP
11919: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11920: LD_EXP 71
11924: PPUSH
11925: LD_INT 259
11927: PPUSH
11928: LD_INT 235
11930: PPUSH
11931: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11935: LD_EXP 71
11939: PPUSH
11940: LD_INT 262
11942: PPUSH
11943: LD_INT 235
11945: PPUSH
11946: CALL_OW 178
// if Simms then
11950: LD_EXP 72
11954: IFFALSE 11985
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11956: LD_EXP 72
11960: PPUSH
11961: LD_INT 262
11963: PPUSH
11964: LD_INT 235
11966: PPUSH
11967: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11971: LD_EXP 72
11975: PPUSH
11976: LD_EXP 71
11980: PPUSH
11981: CALL_OW 179
// end ; end ;
11985: LD_VAR 0 1
11989: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11990: LD_EXP 31
11994: PUSH
11995: LD_EXP 23
11999: NOT
12000: AND
12001: IFFALSE 12177
12003: GO 12005
12005: DISABLE
12006: LD_INT 0
12008: PPUSH
12009: PPUSH
12010: PPUSH
// begin enable ;
12011: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_INT 81
12019: PUSH
12020: LD_INT 7
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 32
12032: PUSH
12033: LD_INT 3
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 30
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 30
12052: PUSH
12053: LD_INT 28
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 49
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 10
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: LD_INT 34
12082: PUSH
12083: LD_INT 8
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PPUSH
12103: CALL_OW 69
12107: ST_TO_ADDR
// if not tmp then
12108: LD_VAR 0 2
12112: NOT
12113: IFFALSE 12117
// exit ;
12115: GO 12177
// target := tmp [ rand ( 1 , tmp ) ] ;
12117: LD_ADDR_VAR 0 3
12121: PUSH
12122: LD_VAR 0 2
12126: PUSH
12127: LD_INT 1
12129: PPUSH
12130: LD_VAR 0 2
12134: PPUSH
12135: CALL_OW 12
12139: ARRAY
12140: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12141: LD_VAR 0 3
12145: PPUSH
12146: CALL_OW 255
12150: PUSH
12151: LD_INT 1
12153: EQUAL
12154: IFFALSE 12165
// CenterNowOnUnits ( target ) ;
12156: LD_VAR 0 3
12160: PPUSH
12161: CALL_OW 87
// SetLives ( target , 0 ) ;
12165: LD_VAR 0 3
12169: PPUSH
12170: LD_INT 0
12172: PPUSH
12173: CALL_OW 234
// end ;
12177: PPOPN 3
12179: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12180: LD_EXP 23
12184: NOT
12185: PUSH
12186: LD_EXP 31
12190: AND
12191: IFFALSE 12713
12193: GO 12195
12195: DISABLE
12196: LD_INT 0
12198: PPUSH
12199: PPUSH
12200: PPUSH
// begin uc_side := 7 ;
12201: LD_ADDR_OWVAR 20
12205: PUSH
12206: LD_INT 7
12208: ST_TO_ADDR
// uc_nation := 1 ;
12209: LD_ADDR_OWVAR 21
12213: PUSH
12214: LD_INT 1
12216: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_INT 125
12224: PUSH
12225: LD_INT 163
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 185
12234: PUSH
12235: LD_INT 168
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 111
12244: PUSH
12245: LD_INT 97
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: PPUSH
12257: CALL 107019 0 1
12261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12262: LD_ADDR_EXP 88
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// for i = 1 to Difficulty do
12269: LD_ADDR_VAR 0 1
12273: PUSH
12274: DOUBLE
12275: LD_INT 1
12277: DEC
12278: ST_TO_ADDR
12279: LD_OWVAR 67
12283: PUSH
12284: FOR_TO
12285: IFFALSE 12443
// begin InitHc ;
12287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12291: LD_INT 0
12293: PPUSH
12294: LD_INT 8
12296: PPUSH
12297: CALL_OW 381
// un := CreateHuman ;
12301: LD_ADDR_VAR 0 2
12305: PUSH
12306: CALL_OW 44
12310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12311: LD_VAR 0 2
12315: PPUSH
12316: LD_INT 258
12318: PPUSH
12319: LD_INT 267
12321: PPUSH
12322: LD_INT 4
12324: PPUSH
12325: LD_INT 0
12327: PPUSH
12328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12332: LD_ADDR_EXP 88
12336: PUSH
12337: LD_EXP 88
12341: PUSH
12342: LD_VAR 0 2
12346: UNION
12347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_VAR 0 3
12357: PUSH
12358: LD_VAR 0 1
12362: ARRAY
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 3
12372: PUSH
12373: LD_VAR 0 1
12377: ARRAY
12378: PUSH
12379: LD_INT 2
12381: ARRAY
12382: PPUSH
12383: LD_INT 4
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12393: LD_VAR 0 2
12397: PPUSH
12398: LD_VAR 0 3
12402: PUSH
12403: LD_VAR 0 1
12407: ARRAY
12408: PUSH
12409: LD_INT 1
12411: ARRAY
12412: PPUSH
12413: LD_VAR 0 3
12417: PUSH
12418: LD_VAR 0 1
12422: ARRAY
12423: PUSH
12424: LD_INT 2
12426: ARRAY
12427: PPUSH
12428: CALL_OW 171
// AddComInvisible ( un ) ;
12432: LD_VAR 0 2
12436: PPUSH
12437: CALL_OW 212
// end ;
12441: GO 12284
12443: POP
12444: POP
// repeat wait ( 0 0$20 ) ;
12445: LD_INT 700
12447: PPUSH
12448: CALL_OW 67
// for i in allianceSpecialForce do
12452: LD_ADDR_VAR 0 1
12456: PUSH
12457: LD_EXP 88
12461: PUSH
12462: FOR_IN
12463: IFFALSE 12698
// begin if IsInvisible ( i ) then
12465: LD_VAR 0 1
12469: PPUSH
12470: CALL_OW 571
12474: IFFALSE 12667
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_INT 22
12483: PUSH
12484: LD_INT 1
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: PUSH
12491: LD_INT 50
12493: PUSH
12494: EMPTY
12495: LIST
12496: PUSH
12497: LD_INT 56
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 91
12505: PUSH
12506: LD_VAR 0 1
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 30
12516: PUSH
12517: LD_INT 35
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: PUSH
12525: LD_OWVAR 67
12529: ARRAY
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 2
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 1
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 2
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 3
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 4
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 5
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: LD_INT 25
12591: PUSH
12592: LD_INT 8
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: PPUSH
12615: CALL_OW 69
12619: ST_TO_ADDR
// if not tmp then
12620: LD_VAR 0 3
12624: NOT
12625: IFFALSE 12629
// continue ;
12627: GO 12462
// if Prob ( 30 * Difficulty ) then
12629: LD_INT 30
12631: PUSH
12632: LD_OWVAR 67
12636: MUL
12637: PPUSH
12638: CALL_OW 13
12642: IFFALSE 12667
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12644: LD_VAR 0 3
12648: PUSH
12649: LD_INT 1
12651: PPUSH
12652: LD_VAR 0 3
12656: PPUSH
12657: CALL_OW 12
12661: ARRAY
12662: PPUSH
12663: CALL 30130 0 1
// end ; if IsDead ( i ) then
12667: LD_VAR 0 1
12671: PPUSH
12672: CALL_OW 301
12676: IFFALSE 12696
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12678: LD_ADDR_EXP 88
12682: PUSH
12683: LD_EXP 88
12687: PUSH
12688: LD_VAR 0 1
12692: DIFF
12693: ST_TO_ADDR
// continue ;
12694: GO 12462
// end ; end ;
12696: GO 12462
12698: POP
12699: POP
// until allianceDestroyed or not allianceSpecialForce ;
12700: LD_EXP 23
12704: PUSH
12705: LD_EXP 88
12709: NOT
12710: OR
12711: IFFALSE 12445
// end ;
12713: PPOPN 3
12715: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12716: LD_EXP 23
12720: NOT
12721: PUSH
12722: LD_EXP 31
12726: AND
12727: PUSH
12728: LD_INT 1
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: CALL 59141 0 2
12738: NOT
12739: AND
12740: IFFALSE 13707
12742: GO 12744
12744: DISABLE
12745: LD_INT 0
12747: PPUSH
12748: PPUSH
12749: PPUSH
12750: PPUSH
// begin enable ;
12751: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12752: LD_INT 22
12754: PUSH
12755: LD_INT 7
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 30
12764: PUSH
12765: LD_INT 3
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PPUSH
12776: CALL_OW 69
12780: NOT
12781: IFFALSE 12785
// exit ;
12783: GO 13707
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12785: LD_ADDR_VAR 0 4
12789: PUSH
12790: LD_INT 22
12792: PUSH
12793: LD_INT 7
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: LD_INT 34
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PPUSH
12814: CALL_OW 69
12818: ST_TO_ADDR
// if Prob ( 40 ) then
12819: LD_INT 40
12821: PPUSH
12822: CALL_OW 13
12826: IFFALSE 12953
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12828: LD_INT 1
12830: PPUSH
12831: LD_INT 5
12833: PUSH
12834: LD_INT 3
12836: PUSH
12837: LD_INT 2
12839: PUSH
12840: LD_INT 6
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: PUSH
12849: LD_INT 5
12851: PUSH
12852: LD_INT 3
12854: PUSH
12855: LD_INT 2
12857: PUSH
12858: LD_INT 6
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 5
12869: PUSH
12870: LD_INT 3
12872: PUSH
12873: LD_INT 2
12875: PUSH
12876: LD_INT 6
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 24
12887: PUSH
12888: LD_INT 3
12890: PUSH
12891: LD_INT 3
12893: PUSH
12894: LD_INT 45
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 24
12905: PUSH
12906: LD_INT 3
12908: PUSH
12909: LD_INT 3
12911: PUSH
12912: LD_INT 47
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 24
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: LD_INT 45
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: LIST
12937: LIST
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PPUSH
12947: CALL 57723 0 2
// end else
12951: GO 13076
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12953: LD_INT 1
12955: PPUSH
12956: LD_INT 24
12958: PUSH
12959: LD_INT 3
12961: PUSH
12962: LD_INT 3
12964: PUSH
12965: LD_INT 47
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 24
12976: PUSH
12977: LD_INT 3
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: LD_INT 47
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 5
12994: PUSH
12995: LD_INT 3
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 9
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: PUSH
13010: LD_INT 5
13012: PUSH
13013: LD_INT 3
13015: PUSH
13016: LD_INT 2
13018: PUSH
13019: LD_INT 9
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 24
13030: PUSH
13031: LD_INT 1
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: LD_INT 45
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PUSH
13046: LD_INT 24
13048: PUSH
13049: LD_INT 1
13051: PUSH
13052: LD_INT 3
13054: PUSH
13055: LD_INT 45
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: LIST
13071: PPUSH
13072: CALL 57723 0 2
// end ; if Difficulty > 1 then
13076: LD_OWVAR 67
13080: PUSH
13081: LD_INT 1
13083: GREATER
13084: IFFALSE 13114
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13086: LD_INT 1
13088: PPUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 47
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: PPUSH
13110: CALL 57723 0 2
// repeat wait ( 0 0$1 ) ;
13114: LD_INT 35
13116: PPUSH
13117: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 1
13126: PPUSH
13127: CALL 59141 0 2
13131: PUSH
13132: LD_INT 6
13134: PUSH
13135: LD_INT 7
13137: PUSH
13138: LD_INT 7
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: PUSH
13146: LD_OWVAR 67
13150: ARRAY
13151: GREATEREQUAL
13152: IFFALSE 13114
// wait ( 0 0$40 ) ;
13154: LD_INT 1400
13156: PPUSH
13157: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13161: LD_ADDR_VAR 0 2
13165: PUSH
13166: LD_INT 1
13168: PPUSH
13169: LD_INT 1
13171: PPUSH
13172: CALL 59141 0 2
13176: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13177: LD_ADDR_EXP 118
13181: PUSH
13182: LD_EXP 118
13186: PPUSH
13187: LD_INT 1
13189: PPUSH
13190: LD_EXP 118
13194: PUSH
13195: LD_INT 1
13197: ARRAY
13198: PUSH
13199: LD_VAR 0 2
13203: DIFF
13204: PPUSH
13205: CALL_OW 1
13209: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: PPUSH
13218: LD_INT 1
13220: PPUSH
13221: CALL_OW 12
13225: ST_TO_ADDR
// if target then
13226: LD_VAR 0 3
13230: IFFALSE 13396
// begin for i in tmp do
13232: LD_ADDR_VAR 0 1
13236: PUSH
13237: LD_VAR 0 2
13241: PUSH
13242: FOR_IN
13243: IFFALSE 13268
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13245: LD_VAR 0 1
13249: PPUSH
13250: LD_INT 179
13252: PPUSH
13253: LD_INT 209
13255: PPUSH
13256: LD_INT 8
13258: PPUSH
13259: LD_INT 1
13261: PPUSH
13262: CALL_OW 483
13266: GO 13242
13268: POP
13269: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13270: LD_ADDR_VAR 0 2
13274: PUSH
13275: LD_VAR 0 2
13279: PPUSH
13280: LD_INT 24
13282: PUSH
13283: LD_INT 250
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PPUSH
13290: CALL_OW 72
13294: ST_TO_ADDR
// for i in tmp do
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: FOR_IN
13306: IFFALSE 13346
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13308: LD_VAR 0 1
13312: PPUSH
13313: LD_INT 179
13315: PPUSH
13316: LD_INT 209
13318: PPUSH
13319: CALL_OW 297
13323: PUSH
13324: LD_INT 9
13326: GREATER
13327: IFFALSE 13344
// ComMoveXY ( i , 179 , 209 ) ;
13329: LD_VAR 0 1
13333: PPUSH
13334: LD_INT 179
13336: PPUSH
13337: LD_INT 209
13339: PPUSH
13340: CALL_OW 111
13344: GO 13305
13346: POP
13347: POP
// wait ( 0 0$1 ) ;
13348: LD_INT 35
13350: PPUSH
13351: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13355: LD_VAR 0 2
13359: PPUSH
13360: LD_INT 92
13362: PUSH
13363: LD_INT 179
13365: PUSH
13366: LD_INT 209
13368: PUSH
13369: LD_INT 9
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: PPUSH
13378: CALL_OW 72
13382: PUSH
13383: LD_VAR 0 2
13387: PUSH
13388: LD_INT 1
13390: MINUS
13391: GREATEREQUAL
13392: IFFALSE 13270
// end else
13394: GO 13558
// begin for i in tmp do
13396: LD_ADDR_VAR 0 1
13400: PUSH
13401: LD_VAR 0 2
13405: PUSH
13406: FOR_IN
13407: IFFALSE 13432
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13409: LD_VAR 0 1
13413: PPUSH
13414: LD_INT 285
13416: PPUSH
13417: LD_INT 163
13419: PPUSH
13420: LD_INT 8
13422: PPUSH
13423: LD_INT 1
13425: PPUSH
13426: CALL_OW 483
13430: GO 13406
13432: POP
13433: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_VAR 0 2
13443: PPUSH
13444: LD_INT 24
13446: PUSH
13447: LD_INT 250
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 72
13458: ST_TO_ADDR
// for i in tmp do
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_VAR 0 2
13468: PUSH
13469: FOR_IN
13470: IFFALSE 13510
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13472: LD_VAR 0 1
13476: PPUSH
13477: LD_INT 285
13479: PPUSH
13480: LD_INT 163
13482: PPUSH
13483: CALL_OW 297
13487: PUSH
13488: LD_INT 9
13490: GREATER
13491: IFFALSE 13508
// ComMoveXY ( i , 285 , 163 ) ;
13493: LD_VAR 0 1
13497: PPUSH
13498: LD_INT 285
13500: PPUSH
13501: LD_INT 163
13503: PPUSH
13504: CALL_OW 111
13508: GO 13469
13510: POP
13511: POP
// wait ( 0 0$1 ) ;
13512: LD_INT 35
13514: PPUSH
13515: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13519: LD_VAR 0 2
13523: PPUSH
13524: LD_INT 92
13526: PUSH
13527: LD_INT 285
13529: PUSH
13530: LD_INT 163
13532: PUSH
13533: LD_INT 9
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 72
13546: PUSH
13547: LD_VAR 0 2
13551: PUSH
13552: LD_INT 1
13554: MINUS
13555: GREATEREQUAL
13556: IFFALSE 13434
// end ; repeat wait ( 0 0$1 ) ;
13558: LD_INT 35
13560: PPUSH
13561: CALL_OW 67
// for i in tmp do
13565: LD_ADDR_VAR 0 1
13569: PUSH
13570: LD_VAR 0 2
13574: PUSH
13575: FOR_IN
13576: IFFALSE 13698
// if GetLives ( i ) > 251 then
13578: LD_VAR 0 1
13582: PPUSH
13583: CALL_OW 256
13587: PUSH
13588: LD_INT 251
13590: GREATER
13591: IFFALSE 13680
// begin if GetWeapon ( i ) = ru_time_lapser then
13593: LD_VAR 0 1
13597: PPUSH
13598: CALL_OW 264
13602: PUSH
13603: LD_INT 49
13605: EQUAL
13606: IFFALSE 13644
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13608: LD_VAR 0 1
13612: PPUSH
13613: LD_INT 81
13615: PUSH
13616: LD_INT 7
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PPUSH
13623: CALL_OW 69
13627: PPUSH
13628: LD_VAR 0 1
13632: PPUSH
13633: CALL_OW 74
13637: PPUSH
13638: CALL_OW 112
13642: GO 13678
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13644: LD_VAR 0 1
13648: PPUSH
13649: LD_INT 81
13651: PUSH
13652: LD_INT 7
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: PPUSH
13659: CALL_OW 69
13663: PPUSH
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL_OW 74
13673: PPUSH
13674: CALL_OW 115
// end else
13678: GO 13696
// tmp := tmp diff i ;
13680: LD_ADDR_VAR 0 2
13684: PUSH
13685: LD_VAR 0 2
13689: PUSH
13690: LD_VAR 0 1
13694: DIFF
13695: ST_TO_ADDR
13696: GO 13575
13698: POP
13699: POP
// until not tmp ;
13700: LD_VAR 0 2
13704: NOT
13705: IFFALSE 13558
// end ; end_of_file
13707: PPOPN 4
13709: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13710: LD_INT 0
13712: PPUSH
13713: PPUSH
13714: PPUSH
13715: PPUSH
// missionStage := 13 ;
13716: LD_ADDR_EXP 15
13720: PUSH
13721: LD_INT 13
13723: ST_TO_ADDR
// uc_side := 2 ;
13724: LD_ADDR_OWVAR 20
13728: PUSH
13729: LD_INT 2
13731: ST_TO_ADDR
// uc_nation := 2 ;
13732: LD_ADDR_OWVAR 21
13736: PUSH
13737: LD_INT 2
13739: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13740: LD_ADDR_EXP 89
13744: PUSH
13745: LD_STRING Omar
13747: PPUSH
13748: CALL_OW 25
13752: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13753: LD_EXP 89
13757: PPUSH
13758: LD_INT 4
13760: PPUSH
13761: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13765: LD_EXP 89
13769: PPUSH
13770: LD_INT 242
13772: PPUSH
13773: LD_INT 75
13775: PPUSH
13776: LD_INT 0
13778: PPUSH
13779: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13783: LD_ADDR_EXP 90
13787: PUSH
13788: LD_STRING Heike
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13796: LD_INT 14
13798: PPUSH
13799: LD_INT 3
13801: PPUSH
13802: LD_INT 1
13804: PPUSH
13805: LD_INT 27
13807: PPUSH
13808: LD_INT 100
13810: PPUSH
13811: CALL 71182 0 5
// veh := CreateVehicle ;
13815: LD_ADDR_VAR 0 3
13819: PUSH
13820: CALL_OW 45
13824: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13825: LD_VAR 0 3
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL_OW 242
// SetDir ( veh , 4 ) ;
13837: LD_VAR 0 3
13841: PPUSH
13842: LD_INT 4
13844: PPUSH
13845: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13849: LD_VAR 0 3
13853: PPUSH
13854: LD_INT 241
13856: PPUSH
13857: LD_INT 72
13859: PPUSH
13860: LD_INT 0
13862: PPUSH
13863: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13867: LD_EXP 90
13871: PPUSH
13872: LD_VAR 0 3
13876: PPUSH
13877: CALL_OW 52
// if KhatamStatus then
13881: LD_EXP 8
13885: IFFALSE 13936
// begin Khatam := NewCharacter ( Khatam ) ;
13887: LD_ADDR_EXP 91
13891: PUSH
13892: LD_STRING Khatam
13894: PPUSH
13895: CALL_OW 25
13899: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13900: LD_EXP 91
13904: PPUSH
13905: LD_INT 245
13907: PPUSH
13908: LD_INT 78
13910: PPUSH
13911: LD_INT 3
13913: PPUSH
13914: LD_INT 0
13916: PPUSH
13917: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13921: LD_EXP 91
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: LD_INT 10
13931: PPUSH
13932: CALL_OW 237
// end ; for i = 1 to Difficulty do
13936: LD_ADDR_VAR 0 2
13940: PUSH
13941: DOUBLE
13942: LD_INT 1
13944: DEC
13945: ST_TO_ADDR
13946: LD_OWVAR 67
13950: PUSH
13951: FOR_TO
13952: IFFALSE 14018
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13954: LD_INT 0
13956: PPUSH
13957: LD_INT 7
13959: PUSH
13960: LD_OWVAR 67
13964: PLUS
13965: PPUSH
13966: CALL_OW 384
// un := CreateHuman ;
13970: LD_ADDR_VAR 0 4
13974: PUSH
13975: CALL_OW 44
13979: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13980: LD_VAR 0 4
13984: PPUSH
13985: LD_INT 28
13987: PUSH
13988: LD_INT 29
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PUSH
13995: LD_VAR 0 2
13999: PUSH
14000: LD_INT 2
14002: MOD
14003: PUSH
14004: LD_INT 1
14006: PLUS
14007: ARRAY
14008: PPUSH
14009: LD_INT 0
14011: PPUSH
14012: CALL_OW 49
// end ;
14016: GO 13951
14018: POP
14019: POP
// for i = 1 to 6 do
14020: LD_ADDR_VAR 0 2
14024: PUSH
14025: DOUBLE
14026: LD_INT 1
14028: DEC
14029: ST_TO_ADDR
14030: LD_INT 6
14032: PUSH
14033: FOR_TO
14034: IFFALSE 14079
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14036: LD_INT 0
14038: PPUSH
14039: LD_INT 7
14041: PUSH
14042: LD_OWVAR 67
14046: PLUS
14047: PPUSH
14048: CALL_OW 381
// un := CreateHuman ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: CALL_OW 44
14061: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14062: LD_VAR 0 4
14066: PPUSH
14067: LD_INT 28
14069: PPUSH
14070: LD_INT 0
14072: PPUSH
14073: CALL_OW 49
// end ;
14077: GO 14033
14079: POP
14080: POP
// for i = 1 to 3 do
14081: LD_ADDR_VAR 0 2
14085: PUSH
14086: DOUBLE
14087: LD_INT 1
14089: DEC
14090: ST_TO_ADDR
14091: LD_INT 3
14093: PUSH
14094: FOR_TO
14095: IFFALSE 14143
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14097: LD_INT 0
14099: PPUSH
14100: LD_INT 8
14102: PPUSH
14103: LD_INT 7
14105: PUSH
14106: LD_OWVAR 67
14110: PLUS
14111: PPUSH
14112: CALL_OW 380
// un := CreateHuman ;
14116: LD_ADDR_VAR 0 4
14120: PUSH
14121: CALL_OW 44
14125: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14126: LD_VAR 0 4
14130: PPUSH
14131: LD_INT 28
14133: PPUSH
14134: LD_INT 0
14136: PPUSH
14137: CALL_OW 49
// end ;
14141: GO 14094
14143: POP
14144: POP
// for i = 1 to 3 do
14145: LD_ADDR_VAR 0 2
14149: PUSH
14150: DOUBLE
14151: LD_INT 1
14153: DEC
14154: ST_TO_ADDR
14155: LD_INT 3
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14249
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14161: LD_INT 14
14163: PPUSH
14164: LD_INT 2
14166: PPUSH
14167: LD_INT 1
14169: PPUSH
14170: LD_INT 28
14172: PPUSH
14173: LD_INT 80
14175: PPUSH
14176: CALL 71182 0 5
// veh := CreateVehicle ;
14180: LD_ADDR_VAR 0 3
14184: PUSH
14185: CALL_OW 45
14189: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14190: LD_VAR 0 3
14194: PPUSH
14195: LD_INT 3
14197: PPUSH
14198: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14202: LD_VAR 0 3
14206: PPUSH
14207: LD_INT 29
14209: PPUSH
14210: LD_INT 0
14212: PPUSH
14213: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14217: LD_INT 0
14219: PPUSH
14220: LD_INT 7
14222: PUSH
14223: LD_OWVAR 67
14227: PLUS
14228: PPUSH
14229: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14233: CALL_OW 44
14237: PPUSH
14238: LD_VAR 0 3
14242: PPUSH
14243: CALL_OW 52
// end ;
14247: GO 14158
14249: POP
14250: POP
// for i = 1 to 5 + Difficulty do
14251: LD_ADDR_VAR 0 2
14255: PUSH
14256: DOUBLE
14257: LD_INT 1
14259: DEC
14260: ST_TO_ADDR
14261: LD_INT 5
14263: PUSH
14264: LD_OWVAR 67
14268: PLUS
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14398
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14273: LD_INT 14
14275: PPUSH
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 3
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: LD_INT 28
14292: PUSH
14293: LD_INT 26
14295: PUSH
14296: LD_INT 27
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: EMPTY
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: PUSH
14308: LD_VAR 0 2
14312: PUSH
14313: LD_INT 4
14315: MOD
14316: PUSH
14317: LD_INT 1
14319: PLUS
14320: ARRAY
14321: PPUSH
14322: LD_INT 80
14324: PPUSH
14325: CALL 71182 0 5
// veh := CreateVehicle ;
14329: LD_ADDR_VAR 0 3
14333: PUSH
14334: CALL_OW 45
14338: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14339: LD_VAR 0 3
14343: PPUSH
14344: LD_INT 4
14346: PPUSH
14347: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14351: LD_VAR 0 3
14355: PPUSH
14356: LD_INT 28
14358: PPUSH
14359: LD_INT 0
14361: PPUSH
14362: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14366: LD_INT 0
14368: PPUSH
14369: LD_INT 7
14371: PUSH
14372: LD_OWVAR 67
14376: PLUS
14377: PPUSH
14378: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14382: CALL_OW 44
14386: PPUSH
14387: LD_VAR 0 3
14391: PPUSH
14392: CALL_OW 52
// end ;
14396: GO 14270
14398: POP
14399: POP
// for i = 1 to 3 do
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: DOUBLE
14406: LD_INT 1
14408: DEC
14409: ST_TO_ADDR
14410: LD_INT 3
14412: PUSH
14413: FOR_TO
14414: IFFALSE 14474
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14416: LD_INT 14
14418: PPUSH
14419: LD_INT 3
14421: PPUSH
14422: LD_INT 5
14424: PPUSH
14425: LD_INT 29
14427: PPUSH
14428: LD_INT 80
14430: PPUSH
14431: CALL 71182 0 5
// veh := CreateVehicle ;
14435: LD_ADDR_VAR 0 3
14439: PUSH
14440: CALL_OW 45
14444: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14445: LD_VAR 0 3
14449: PPUSH
14450: LD_INT 4
14452: PPUSH
14453: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14457: LD_VAR 0 3
14461: PPUSH
14462: LD_INT 28
14464: PPUSH
14465: LD_INT 0
14467: PPUSH
14468: CALL_OW 49
// end ;
14472: GO 14413
14474: POP
14475: POP
// end ;
14476: LD_VAR 0 1
14480: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14481: LD_INT 22
14483: PUSH
14484: LD_INT 2
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PPUSH
14491: CALL_OW 69
14495: IFFALSE 14795
14497: GO 14499
14499: DISABLE
14500: LD_INT 0
14502: PPUSH
14503: PPUSH
14504: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14505: LD_ADDR_VAR 0 3
14509: PUSH
14510: LD_INT 22
14512: PUSH
14513: LD_INT 2
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: LD_INT 25
14522: PUSH
14523: LD_INT 4
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: PUSH
14539: LD_EXP 91
14543: DIFF
14544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14545: LD_ADDR_VAR 0 2
14549: PUSH
14550: LD_INT 22
14552: PUSH
14553: LD_INT 2
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: PPUSH
14560: CALL_OW 69
14564: PUSH
14565: LD_EXP 91
14569: PUSH
14570: LD_VAR 0 3
14574: UNION
14575: DIFF
14576: ST_TO_ADDR
// if Khatam then
14577: LD_EXP 91
14581: IFFALSE 14598
// ComMoveXY ( Khatam , 211 , 92 ) ;
14583: LD_EXP 91
14587: PPUSH
14588: LD_INT 211
14590: PPUSH
14591: LD_INT 92
14593: PPUSH
14594: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14598: LD_INT 197
14600: PPUSH
14601: LD_INT 80
14603: PPUSH
14604: LD_INT 2
14606: PPUSH
14607: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14611: LD_INT 213
14613: PPUSH
14614: LD_INT 90
14616: PPUSH
14617: LD_INT 2
14619: PPUSH
14620: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14624: LD_INT 215
14626: PPUSH
14627: LD_INT 129
14629: PPUSH
14630: LD_INT 2
14632: PPUSH
14633: CALL_OW 441
// if sci then
14637: LD_VAR 0 3
14641: IFFALSE 14662
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14643: LD_VAR 0 3
14647: PUSH
14648: LD_INT 1
14650: ARRAY
14651: PPUSH
14652: LD_INT 197
14654: PPUSH
14655: LD_INT 80
14657: PPUSH
14658: CALL_OW 158
// if sci > 1 then
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 1
14669: GREATER
14670: IFFALSE 14691
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14672: LD_VAR 0 3
14676: PUSH
14677: LD_INT 2
14679: ARRAY
14680: PPUSH
14681: LD_INT 213
14683: PPUSH
14684: LD_INT 90
14686: PPUSH
14687: CALL_OW 158
// if sci > 2 then
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 2
14698: GREATER
14699: IFFALSE 14720
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14701: LD_VAR 0 3
14705: PUSH
14706: LD_INT 3
14708: ARRAY
14709: PPUSH
14710: LD_INT 215
14712: PPUSH
14713: LD_INT 129
14715: PPUSH
14716: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14720: LD_INT 35
14722: PPUSH
14723: CALL_OW 67
// for i in tmp do
14727: LD_ADDR_VAR 0 1
14731: PUSH
14732: LD_VAR 0 2
14736: PUSH
14737: FOR_IN
14738: IFFALSE 14776
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_INT 81
14747: PUSH
14748: LD_INT 2
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 69
14759: PPUSH
14760: LD_VAR 0 1
14764: PPUSH
14765: CALL_OW 74
14769: PPUSH
14770: CALL_OW 115
14774: GO 14737
14776: POP
14777: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14778: LD_INT 22
14780: PUSH
14781: LD_INT 2
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 69
14792: NOT
14793: IFFALSE 14720
// end ; end_of_file
14795: PPOPN 3
14797: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14798: LD_INT 0
14800: PPUSH
14801: PPUSH
14802: PPUSH
14803: PPUSH
14804: PPUSH
14805: PPUSH
14806: PPUSH
14807: PPUSH
14808: PPUSH
// Video ( true ) ;
14809: LD_INT 1
14811: PPUSH
14812: CALL 106899 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14816: LD_ADDR_VAR 0 5
14820: PUSH
14821: LD_INT 7
14823: PPUSH
14824: LD_INT 0
14826: PPUSH
14827: CALL_OW 517
14831: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14832: LD_ADDR_VAR 0 2
14836: PUSH
14837: DOUBLE
14838: LD_INT 1
14840: DEC
14841: ST_TO_ADDR
14842: LD_VAR 0 5
14846: PUSH
14847: LD_INT 1
14849: ARRAY
14850: PUSH
14851: FOR_TO
14852: IFFALSE 14897
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14854: LD_VAR 0 5
14858: PUSH
14859: LD_INT 1
14861: ARRAY
14862: PUSH
14863: LD_VAR 0 2
14867: ARRAY
14868: PPUSH
14869: LD_VAR 0 5
14873: PUSH
14874: LD_INT 2
14876: ARRAY
14877: PUSH
14878: LD_VAR 0 2
14882: ARRAY
14883: PPUSH
14884: LD_INT 1
14886: PPUSH
14887: LD_INT 15
14889: NEG
14890: PPUSH
14891: CALL 106813 0 4
14895: GO 14851
14897: POP
14898: POP
// CenterNowOnUnits ( Powell ) ;
14899: LD_EXP 55
14903: PPUSH
14904: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14908: LD_ADDR_VAR 0 5
14912: PUSH
14913: LD_EXP 53
14917: PUSH
14918: EMPTY
14919: LIST
14920: ST_TO_ADDR
// if GirlNewVeh then
14921: LD_EXP 54
14925: IFFALSE 14943
// tmp := tmp ^ GirlNewVeh ;
14927: LD_ADDR_VAR 0 5
14931: PUSH
14932: LD_VAR 0 5
14936: PUSH
14937: LD_EXP 54
14941: ADD
14942: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14943: LD_VAR 0 5
14947: PPUSH
14948: LD_INT 60
14950: PPUSH
14951: LD_INT 109
14953: PPUSH
14954: CALL_OW 111
// if KappaStatus then
14958: LD_EXP 2
14962: IFFALSE 15014
// begin Say ( JMM , D1nT-JMM-1 ) ;
14964: LD_EXP 36
14968: PPUSH
14969: LD_STRING D1nT-JMM-1
14971: PPUSH
14972: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14976: LD_EXP 55
14980: PPUSH
14981: LD_STRING D1T-Pow-1
14983: PPUSH
14984: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14988: LD_EXP 36
14992: PPUSH
14993: LD_STRING D1T-JMM-2
14995: PPUSH
14996: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15000: LD_EXP 55
15004: PPUSH
15005: LD_STRING D1T-Pow-2
15007: PPUSH
15008: CALL_OW 88
// end else
15012: GO 15220
// if JMMGirlStatus then
15014: LD_EXP 6
15018: IFFALSE 15163
// begin Say ( JMM , D1T-JMM-1 ) ;
15020: LD_EXP 36
15024: PPUSH
15025: LD_STRING D1T-JMM-1
15027: PPUSH
15028: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15032: LD_EXP 55
15036: PPUSH
15037: LD_STRING D1T-Pow-1
15039: PPUSH
15040: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15044: LD_EXP 36
15048: PPUSH
15049: LD_STRING D1T-JMM-3
15051: PPUSH
15052: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15056: LD_EXP 55
15060: PPUSH
15061: LD_STRING D1T-Pow-3
15063: PPUSH
15064: CALL_OW 88
// if JMMGirl then
15068: LD_EXP 7
15072: IFFALSE 15161
// begin case JMMGirl of 1 :
15074: LD_EXP 7
15078: PUSH
15079: LD_INT 1
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15102
15087: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15088: LD_EXP 37
15092: PPUSH
15093: LD_STRING D1T-Joan-3
15095: PPUSH
15096: CALL_OW 88
15100: GO 15149
15102: LD_INT 2
15104: DOUBLE
15105: EQUAL
15106: IFTRUE 15110
15108: GO 15125
15110: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15111: LD_EXP 39
15115: PPUSH
15116: LD_STRING D1T-Lisa-3
15118: PPUSH
15119: CALL_OW 88
15123: GO 15149
15125: LD_INT 3
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15148
15133: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15134: LD_EXP 51
15138: PPUSH
15139: LD_STRING D1T-Con-3
15141: PPUSH
15142: CALL_OW 88
15146: GO 15149
15148: POP
// Say ( Powell , D1T-Pow-4 ) ;
15149: LD_EXP 55
15153: PPUSH
15154: LD_STRING D1T-Pow-4
15156: PPUSH
15157: CALL_OW 88
// end ; end else
15161: GO 15220
// if not FastEnd then
15163: LD_EXP 11
15167: NOT
15168: IFFALSE 15196
// begin Say ( JMM , D1T-JMM-4 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_STRING D1T-JMM-4
15177: PPUSH
15178: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15182: LD_EXP 55
15186: PPUSH
15187: LD_STRING D1T-Pow-5
15189: PPUSH
15190: CALL_OW 88
// end else
15194: GO 15220
// begin Say ( JMM , D1nT-JMM-1 ) ;
15196: LD_EXP 36
15200: PPUSH
15201: LD_STRING D1nT-JMM-1
15203: PPUSH
15204: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15208: LD_EXP 55
15212: PPUSH
15213: LD_STRING D1nT-Pow-1
15215: PPUSH
15216: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15220: LD_INT 35
15222: PPUSH
15223: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15227: LD_EXP 53
15231: PPUSH
15232: CALL_OW 314
15236: NOT
15237: IFFALSE 15220
// ComExitVehicle ( JMM ) ;
15239: LD_EXP 36
15243: PPUSH
15244: CALL_OW 121
// wait ( 3 ) ;
15248: LD_INT 3
15250: PPUSH
15251: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15255: LD_EXP 36
15259: PPUSH
15260: LD_INT 60
15262: PPUSH
15263: LD_INT 94
15265: PPUSH
15266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15270: LD_EXP 36
15274: PPUSH
15275: LD_EXP 55
15279: PPUSH
15280: CALL_OW 179
// if Joan then
15284: LD_EXP 37
15288: IFFALSE 15342
// begin ComExitVehicle ( Joan ) ;
15290: LD_EXP 37
15294: PPUSH
15295: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15299: LD_EXP 37
15303: PPUSH
15304: LD_INT 35
15306: PPUSH
15307: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15311: LD_EXP 37
15315: PPUSH
15316: LD_INT 65
15318: PPUSH
15319: LD_INT 104
15321: PPUSH
15322: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15326: LD_EXP 37
15330: PPUSH
15331: LD_EXP 36
15335: PPUSH
15336: CALL_OW 179
// end else
15340: GO 15476
// if Lisa and JMMGirl = 2 then
15342: LD_EXP 39
15346: PUSH
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 2
15354: EQUAL
15355: AND
15356: IFFALSE 15410
// begin ComExitVehicle ( Lisa ) ;
15358: LD_EXP 39
15362: PPUSH
15363: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15367: LD_EXP 39
15371: PPUSH
15372: LD_INT 35
15374: PPUSH
15375: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15379: LD_EXP 39
15383: PPUSH
15384: LD_INT 65
15386: PPUSH
15387: LD_INT 104
15389: PPUSH
15390: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15394: LD_EXP 39
15398: PPUSH
15399: LD_EXP 36
15403: PPUSH
15404: CALL_OW 179
// end else
15408: GO 15476
// if Connie and JMMGirl = 3 then
15410: LD_EXP 51
15414: PUSH
15415: LD_EXP 7
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15476
// begin ComExitVehicle ( Connie ) ;
15426: LD_EXP 51
15430: PPUSH
15431: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15435: LD_EXP 51
15439: PPUSH
15440: LD_INT 35
15442: PPUSH
15443: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15447: LD_EXP 51
15451: PPUSH
15452: LD_INT 65
15454: PPUSH
15455: LD_INT 104
15457: PPUSH
15458: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15462: LD_EXP 51
15466: PPUSH
15467: LD_EXP 36
15471: PPUSH
15472: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15476: LD_INT 35
15478: PPUSH
15479: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15483: LD_EXP 36
15487: PPUSH
15488: LD_EXP 55
15492: PPUSH
15493: CALL_OW 296
15497: PUSH
15498: LD_INT 6
15500: LESS
15501: IFFALSE 15476
// wait ( 0 0$0.5 ) ;
15503: LD_INT 18
15505: PPUSH
15506: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15510: LD_EXP 36
15514: PPUSH
15515: LD_STRING D1-JMM-1
15517: PPUSH
15518: CALL_OW 88
// async ;
15522: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15523: LD_EXP 55
15527: PPUSH
15528: LD_STRING D1-Pow-1
15530: PPUSH
15531: CALL_OW 88
// if not dialogue_skipped then
15535: LD_OWVAR 59
15539: NOT
15540: IFFALSE 15549
// wait ( 0 0$2 ) ;
15542: LD_INT 70
15544: PPUSH
15545: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15549: LD_INT 170
15551: PPUSH
15552: LD_INT 99
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 6
15560: NEG
15561: PPUSH
15562: CALL 106813 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15566: LD_INT 174
15568: PPUSH
15569: LD_INT 115
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: LD_INT 6
15577: NEG
15578: PPUSH
15579: CALL 106813 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15583: LD_INT 169
15585: PPUSH
15586: LD_INT 71
15588: PPUSH
15589: LD_INT 1
15591: PPUSH
15592: LD_INT 6
15594: NEG
15595: PPUSH
15596: CALL 106813 0 4
// if not dialogue_skipped then
15600: LD_OWVAR 59
15604: NOT
15605: IFFALSE 15624
// begin CenterOnXY ( 170 , 99 ) ;
15607: LD_INT 170
15609: PPUSH
15610: LD_INT 99
15612: PPUSH
15613: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15617: LD_INT 80
15619: PPUSH
15620: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15624: LD_INT 75
15626: PPUSH
15627: LD_INT 53
15629: PPUSH
15630: LD_INT 1
15632: PPUSH
15633: LD_INT 9
15635: NEG
15636: PPUSH
15637: CALL 106813 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15641: LD_INT 54
15643: PPUSH
15644: LD_INT 42
15646: PPUSH
15647: LD_INT 1
15649: PPUSH
15650: LD_INT 9
15652: NEG
15653: PPUSH
15654: CALL 106813 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15658: LD_INT 62
15660: PPUSH
15661: LD_INT 51
15663: PPUSH
15664: LD_INT 1
15666: PPUSH
15667: LD_INT 9
15669: NEG
15670: PPUSH
15671: CALL 106813 0 4
// if not dialogue_skipped then
15675: LD_OWVAR 59
15679: NOT
15680: IFFALSE 15699
// begin CenterOnXY ( 75 , 53 ) ;
15682: LD_INT 75
15684: PPUSH
15685: LD_INT 53
15687: PPUSH
15688: CALL_OW 84
// wait ( 0 0$4 ) ;
15692: LD_INT 140
15694: PPUSH
15695: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15699: LD_EXP 55
15703: PPUSH
15704: CALL_OW 87
// if not dialogue_skipped then
15708: LD_OWVAR 59
15712: NOT
15713: IFFALSE 15722
// wait ( 0 0$2 ) ;
15715: LD_INT 70
15717: PPUSH
15718: CALL_OW 67
// sync ;
15722: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15723: LD_EXP 36
15727: PPUSH
15728: LD_STRING D1-JMM-2
15730: PPUSH
15731: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15735: LD_EXP 55
15739: PPUSH
15740: LD_STRING D1-Pow-2
15742: PPUSH
15743: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15747: LD_EXP 36
15751: PPUSH
15752: LD_STRING D1-JMM-3
15754: PPUSH
15755: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15759: LD_EXP 55
15763: PPUSH
15764: LD_STRING D1-Pow-3
15766: PPUSH
15767: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15771: LD_EXP 36
15775: PPUSH
15776: LD_STRING D1-JMM-4
15778: PPUSH
15779: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15783: LD_EXP 55
15787: PPUSH
15788: LD_STRING D1-Pow-4
15790: PPUSH
15791: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15795: LD_EXP 36
15799: PPUSH
15800: LD_STRING D1-JMM-5
15802: PPUSH
15803: CALL_OW 88
// async ;
15807: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15808: LD_EXP 55
15812: PPUSH
15813: LD_STRING D1-Pow-5
15815: PPUSH
15816: CALL_OW 88
// if not dialogue_skipped then
15820: LD_OWVAR 59
15824: NOT
15825: IFFALSE 15834
// wait ( 0 0$3.6 ) ;
15827: LD_INT 126
15829: PPUSH
15830: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15834: LD_INT 134
15836: PPUSH
15837: LD_INT 210
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 11
15845: NEG
15846: PPUSH
15847: CALL 106813 0 4
// if not dialogue_skipped then
15851: LD_OWVAR 59
15855: NOT
15856: IFFALSE 15875
// begin CenterOnXY ( 134 , 210 ) ;
15858: LD_INT 134
15860: PPUSH
15861: LD_INT 210
15863: PPUSH
15864: CALL_OW 84
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15875: LD_INT 101
15877: PPUSH
15878: LD_INT 159
15880: PPUSH
15881: LD_INT 1
15883: PPUSH
15884: LD_INT 10
15886: NEG
15887: PPUSH
15888: CALL 106813 0 4
// if not dialogue_skipped then
15892: LD_OWVAR 59
15896: NOT
15897: IFFALSE 15916
// begin CenterOnXY ( 101 , 159 ) ;
15899: LD_INT 101
15901: PPUSH
15902: LD_INT 159
15904: PPUSH
15905: CALL_OW 84
// wait ( 0 0$2 ) ;
15909: LD_INT 70
15911: PPUSH
15912: CALL_OW 67
// end ; sync ;
15916: SYNC
// CenterNowOnUnits ( Powell ) ;
15917: LD_EXP 55
15921: PPUSH
15922: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15926: LD_ADDR_VAR 0 6
15930: PUSH
15931: LD_INT 1
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: LD_INT 5
15945: PUSH
15946: LD_INT 6
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: LIST
15956: ST_TO_ADDR
// if not dialogue_skipped then
15957: LD_OWVAR 59
15961: NOT
15962: IFFALSE 16131
// begin game_speed := 4 ;
15964: LD_ADDR_OWVAR 65
15968: PUSH
15969: LD_INT 4
15971: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15972: LD_INT 210
15974: PPUSH
15975: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15979: LD_ADDR_VAR 0 7
15983: PUSH
15984: LD_STRING Q1
15986: PPUSH
15987: LD_VAR 0 6
15991: PPUSH
15992: CALL_OW 98
15996: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15997: LD_ADDR_VAR 0 7
16001: PUSH
16002: LD_STRING Q1
16004: PPUSH
16005: LD_VAR 0 6
16009: PPUSH
16010: CALL_OW 98
16014: ST_TO_ADDR
// options = options diff dec ;
16015: LD_ADDR_VAR 0 6
16019: PUSH
16020: LD_VAR 0 6
16024: PUSH
16025: LD_VAR 0 7
16029: DIFF
16030: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16031: LD_VAR 0 7
16035: PPUSH
16036: LD_VAR 0 6
16040: PPUSH
16041: CALL 17434 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16045: LD_VAR 0 7
16049: PUSH
16050: LD_INT 5
16052: PUSH
16053: LD_INT 6
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: IN
16060: PUSH
16061: LD_VAR 0 6
16065: PUSH
16066: LD_INT 2
16068: EQUAL
16069: OR
16070: IFFALSE 15997
// if not ( dec in [ 5 , 6 ] ) then
16072: LD_VAR 0 7
16076: PUSH
16077: LD_INT 5
16079: PUSH
16080: LD_INT 6
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: IN
16087: NOT
16088: IFFALSE 16131
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16090: LD_ADDR_VAR 0 7
16094: PUSH
16095: LD_STRING Q1a
16097: PPUSH
16098: LD_INT 1
16100: PUSH
16101: LD_INT 2
16103: PUSH
16104: EMPTY
16105: LIST
16106: LIST
16107: PPUSH
16108: CALL_OW 98
16112: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16113: LD_VAR 0 7
16117: PUSH
16118: LD_INT 4
16120: PLUS
16121: PPUSH
16122: LD_VAR 0 6
16126: PPUSH
16127: CALL 17434 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16131: LD_INT 81
16133: PPUSH
16134: LD_INT 127
16136: PPUSH
16137: CALL_OW 84
// amount := 5 ;
16141: LD_ADDR_VAR 0 8
16145: PUSH
16146: LD_INT 5
16148: ST_TO_ADDR
// macmilan_squad := [ ] ;
16149: LD_ADDR_VAR 0 9
16153: PUSH
16154: EMPTY
16155: ST_TO_ADDR
// if vip < amount then
16156: LD_EXP 56
16160: PUSH
16161: LD_VAR 0 8
16165: LESS
16166: IFFALSE 16210
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16168: LD_ADDR_VAR 0 5
16172: PUSH
16173: LD_EXP 56
16177: PUSH
16178: LD_INT 22
16180: PUSH
16181: LD_INT 4
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: LD_INT 21
16190: PUSH
16191: LD_INT 1
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: PUSH
16198: EMPTY
16199: LIST
16200: LIST
16201: PPUSH
16202: CALL_OW 69
16206: UNION
16207: ST_TO_ADDR
16208: GO 16220
// tmp := vip ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_EXP 56
16219: ST_TO_ADDR
// tmp := tmp diff Powell ;
16220: LD_ADDR_VAR 0 5
16224: PUSH
16225: LD_VAR 0 5
16229: PUSH
16230: LD_EXP 55
16234: DIFF
16235: ST_TO_ADDR
// if tmp < amount then
16236: LD_VAR 0 5
16240: PUSH
16241: LD_VAR 0 8
16245: LESS
16246: IFFALSE 16258
// amount := tmp ;
16248: LD_ADDR_VAR 0 8
16252: PUSH
16253: LD_VAR 0 5
16257: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16258: LD_VAR 0 5
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: CALL_OW 257
16271: PUSH
16272: LD_INT 2
16274: NONEQUAL
16275: IFFALSE 16337
// begin if IsInUnit ( tmp [ 1 ] ) then
16277: LD_VAR 0 5
16281: PUSH
16282: LD_INT 1
16284: ARRAY
16285: PPUSH
16286: CALL_OW 310
16290: IFFALSE 16305
// ComExitBuilding ( tmp [ 1 ] ) ;
16292: LD_VAR 0 5
16296: PUSH
16297: LD_INT 1
16299: ARRAY
16300: PPUSH
16301: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16305: LD_VAR 0 5
16309: PUSH
16310: LD_INT 1
16312: ARRAY
16313: PPUSH
16314: LD_INT 387
16316: PPUSH
16317: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16321: LD_VAR 0 5
16325: PUSH
16326: LD_INT 1
16328: ARRAY
16329: PPUSH
16330: LD_INT 2
16332: PPUSH
16333: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16337: LD_EXP 36
16341: PPUSH
16342: LD_INT 82
16344: PPUSH
16345: LD_INT 129
16347: PPUSH
16348: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16352: LD_EXP 36
16356: PPUSH
16357: LD_EXP 55
16361: PPUSH
16362: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16366: LD_INT 22
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: PUSH
16381: LD_EXP 36
16385: DIFF
16386: PPUSH
16387: LD_INT 84
16389: PPUSH
16390: LD_INT 128
16392: PPUSH
16393: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16397: LD_INT 22
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: PUSH
16412: LD_EXP 36
16416: DIFF
16417: PPUSH
16418: LD_EXP 36
16422: PPUSH
16423: CALL_OW 179
// for i = 1 to amount do
16427: LD_ADDR_VAR 0 2
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 8
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16611
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 9
16454: PUSH
16455: LD_VAR 0 5
16459: PUSH
16460: LD_VAR 0 2
16464: ARRAY
16465: ADD
16466: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16467: LD_VAR 0 5
16471: PUSH
16472: LD_VAR 0 2
16476: ARRAY
16477: PPUSH
16478: CALL_OW 310
16482: IFFALSE 16499
// AddComExitBuilding ( tmp [ i ] ) ;
16484: LD_VAR 0 5
16488: PUSH
16489: LD_VAR 0 2
16493: ARRAY
16494: PPUSH
16495: CALL_OW 182
// if i = 2 and JMMNewVeh then
16499: LD_VAR 0 2
16503: PUSH
16504: LD_INT 2
16506: EQUAL
16507: PUSH
16508: LD_EXP 53
16512: AND
16513: IFFALSE 16571
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16515: LD_VAR 0 5
16519: PUSH
16520: LD_VAR 0 2
16524: ARRAY
16525: PPUSH
16526: LD_EXP 53
16530: PPUSH
16531: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16535: LD_VAR 0 5
16539: PUSH
16540: LD_VAR 0 2
16544: ARRAY
16545: PPUSH
16546: LD_INT 86
16548: PPUSH
16549: LD_INT 133
16551: PPUSH
16552: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16556: LD_VAR 0 5
16560: PUSH
16561: LD_VAR 0 2
16565: ARRAY
16566: PPUSH
16567: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16571: LD_VAR 0 5
16575: PUSH
16576: LD_VAR 0 2
16580: ARRAY
16581: PPUSH
16582: LD_INT 8
16584: PPUSH
16585: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16589: LD_VAR 0 5
16593: PUSH
16594: LD_VAR 0 2
16598: ARRAY
16599: PPUSH
16600: LD_EXP 36
16604: PPUSH
16605: CALL_OW 179
// end ;
16609: GO 16442
16611: POP
16612: POP
// if GirlNewVeh then
16613: LD_EXP 54
16617: IFFALSE 16631
// SetSide ( GirlNewVeh , 4 ) ;
16619: LD_EXP 54
16623: PPUSH
16624: LD_INT 4
16626: PPUSH
16627: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16631: LD_INT 35
16633: PPUSH
16634: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16638: LD_VAR 0 9
16642: PPUSH
16643: LD_INT 95
16645: PUSH
16646: LD_INT 9
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PPUSH
16653: CALL_OW 72
16657: PUSH
16658: LD_INT 0
16660: EQUAL
16661: PUSH
16662: LD_EXP 36
16666: PPUSH
16667: LD_INT 9
16669: PPUSH
16670: CALL_OW 308
16674: NOT
16675: AND
16676: IFFALSE 16631
// wait ( 0 0$2 ) ;
16678: LD_INT 70
16680: PPUSH
16681: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16685: LD_VAR 0 9
16689: PPUSH
16690: LD_INT 1
16692: PPUSH
16693: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16697: LD_INT 21
16699: PUSH
16700: LD_INT 2
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PUSH
16707: LD_INT 92
16709: PUSH
16710: LD_INT 83
16712: PUSH
16713: LD_INT 130
16715: PUSH
16716: LD_INT 10
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PPUSH
16729: CALL_OW 69
16733: PPUSH
16734: LD_INT 1
16736: PPUSH
16737: CALL_OW 235
// Video ( false ) ;
16741: LD_INT 0
16743: PPUSH
16744: CALL 106899 0 1
// ChangeMissionObjectives ( M1 ) ;
16748: LD_STRING M1
16750: PPUSH
16751: CALL_OW 337
// SaveForQuickRestart ;
16755: CALL_OW 22
// missionStart := true ;
16759: LD_ADDR_EXP 13
16763: PUSH
16764: LD_INT 1
16766: ST_TO_ADDR
// missionStage := 2 ;
16767: LD_ADDR_EXP 15
16771: PUSH
16772: LD_INT 2
16774: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16775: LD_INT 105
16777: PPUSH
16778: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16782: LD_ADDR_VAR 0 5
16786: PUSH
16787: LD_INT 22
16789: PUSH
16790: LD_INT 4
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 21
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 69
16815: PUSH
16816: LD_EXP 55
16820: DIFF
16821: ST_TO_ADDR
// if not tmp then
16822: LD_VAR 0 5
16826: NOT
16827: IFFALSE 16842
// tmp := [ Powell ] ;
16829: LD_ADDR_VAR 0 5
16833: PUSH
16834: LD_EXP 55
16838: PUSH
16839: EMPTY
16840: LIST
16841: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16842: LD_ADDR_EXP 99
16846: PUSH
16847: LD_EXP 99
16851: PPUSH
16852: LD_INT 4
16854: PPUSH
16855: LD_INT 22
16857: PUSH
16858: LD_INT 4
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 23
16867: PUSH
16868: LD_INT 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: LD_INT 21
16880: PUSH
16881: LD_INT 2
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PUSH
16902: LD_EXP 55
16906: DIFF
16907: PPUSH
16908: CALL_OW 1
16912: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16913: LD_ADDR_VAR 0 4
16917: PUSH
16918: LD_INT 22
16920: PUSH
16921: LD_INT 4
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 34
16930: PUSH
16931: LD_INT 12
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PPUSH
16942: CALL_OW 69
16946: PUSH
16947: LD_INT 1
16949: ARRAY
16950: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16951: LD_VAR 0 5
16955: PUSH
16956: LD_INT 1
16958: ARRAY
16959: PPUSH
16960: CALL_OW 310
16964: IFFALSE 16979
// ComExitBuilding ( tmp [ 1 ] ) ;
16966: LD_VAR 0 5
16970: PUSH
16971: LD_INT 1
16973: ARRAY
16974: PPUSH
16975: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16979: LD_VAR 0 5
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: PPUSH
16988: LD_VAR 0 4
16992: PPUSH
16993: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16997: LD_VAR 0 5
17001: PUSH
17002: LD_INT 1
17004: ARRAY
17005: PPUSH
17006: LD_INT 80
17008: PPUSH
17009: LD_INT 136
17011: PPUSH
17012: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17016: LD_VAR 0 5
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17029: LD_VAR 0 5
17033: PUSH
17034: LD_INT 1
17036: ARRAY
17037: PPUSH
17038: LD_INT 59
17040: PPUSH
17041: LD_INT 112
17043: PPUSH
17044: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17048: LD_VAR 0 5
17052: PUSH
17053: LD_INT 1
17055: ARRAY
17056: PPUSH
17057: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17061: LD_EXP 39
17065: PUSH
17066: LD_EXP 56
17070: IN
17071: PUSH
17072: LD_EXP 39
17076: PPUSH
17077: CALL_OW 255
17081: PUSH
17082: LD_INT 1
17084: EQUAL
17085: AND
17086: IFFALSE 17102
// Say ( Lisa , D3nW-Lisa-1 ) else
17088: LD_EXP 39
17092: PPUSH
17093: LD_STRING D3nW-Lisa-1
17095: PPUSH
17096: CALL_OW 88
17100: GO 17346
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17102: LD_EXP 42
17106: PUSH
17107: LD_EXP 56
17111: IN
17112: PUSH
17113: LD_EXP 42
17117: PPUSH
17118: CALL_OW 255
17122: PUSH
17123: LD_INT 1
17125: EQUAL
17126: AND
17127: IFFALSE 17143
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17129: LD_EXP 42
17133: PPUSH
17134: LD_STRING D3nW-Cyrus-1
17136: PPUSH
17137: CALL_OW 88
17141: GO 17346
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17143: LD_EXP 41
17147: PUSH
17148: LD_EXP 56
17152: IN
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: IFFALSE 17184
// Say ( Bobby , D3nW-Bobby-1 ) else
17170: LD_EXP 41
17174: PPUSH
17175: LD_STRING D3nW-Bobby-1
17177: PPUSH
17178: CALL_OW 88
17182: GO 17346
// if Gary in vip and GetSide ( Gary ) = 1 then
17184: LD_EXP 48
17188: PUSH
17189: LD_EXP 56
17193: IN
17194: PUSH
17195: LD_EXP 48
17199: PPUSH
17200: CALL_OW 255
17204: PUSH
17205: LD_INT 1
17207: EQUAL
17208: AND
17209: IFFALSE 17225
// Say ( Gary , D3nW-Gary-1 ) else
17211: LD_EXP 48
17215: PPUSH
17216: LD_STRING D3nW-Gary-1
17218: PPUSH
17219: CALL_OW 88
17223: GO 17346
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17225: LD_EXP 40
17229: PUSH
17230: LD_EXP 56
17234: IN
17235: PUSH
17236: LD_EXP 40
17240: PPUSH
17241: CALL_OW 255
17245: PUSH
17246: LD_INT 1
17248: EQUAL
17249: AND
17250: IFFALSE 17266
// Say ( Donaldson , D3nW-Don-1 ) else
17252: LD_EXP 40
17256: PPUSH
17257: LD_STRING D3nW-Don-1
17259: PPUSH
17260: CALL_OW 88
17264: GO 17346
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17266: LD_EXP 47
17270: PUSH
17271: LD_EXP 56
17275: IN
17276: PUSH
17277: LD_EXP 47
17281: PPUSH
17282: CALL_OW 255
17286: PUSH
17287: LD_INT 1
17289: EQUAL
17290: AND
17291: IFFALSE 17307
// Say ( Cornel , D3nW-Corn-1 ) else
17293: LD_EXP 47
17297: PPUSH
17298: LD_STRING D3nW-Corn-1
17300: PPUSH
17301: CALL_OW 88
17305: GO 17346
// if Frank in vip and GetSide ( Frank ) = 1 then
17307: LD_EXP 49
17311: PUSH
17312: LD_EXP 56
17316: IN
17317: PUSH
17318: LD_EXP 49
17322: PPUSH
17323: CALL_OW 255
17327: PUSH
17328: LD_INT 1
17330: EQUAL
17331: AND
17332: IFFALSE 17346
// Say ( Frank , D3nW-Frank-1 ) ;
17334: LD_EXP 49
17338: PPUSH
17339: LD_STRING D3nW-Frank-1
17341: PPUSH
17342: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17346: LD_EXP 36
17350: PPUSH
17351: LD_STRING D3nW-JMM-1
17353: PPUSH
17354: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17358: LD_EXP 36
17362: PPUSH
17363: LD_STRING D3nW-JMM-1a
17365: PPUSH
17366: CALL_OW 88
// t := 0 0$00 ;
17370: LD_ADDR_VAR 0 3
17374: PUSH
17375: LD_INT 0
17377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17378: LD_INT 35
17380: PPUSH
17381: CALL_OW 67
// t := t + 0 0$1 ;
17385: LD_ADDR_VAR 0 3
17389: PUSH
17390: LD_VAR 0 3
17394: PUSH
17395: LD_INT 35
17397: PLUS
17398: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17399: LD_INT 59
17401: PPUSH
17402: LD_INT 112
17404: PPUSH
17405: CALL_OW 428
17409: PUSH
17410: LD_VAR 0 3
17414: PUSH
17415: LD_INT 2100
17417: GREATER
17418: OR
17419: IFFALSE 17378
// activeAttacks := true ;
17421: LD_ADDR_EXP 16
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// end ;
17429: LD_VAR 0 1
17433: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17434: LD_INT 0
17436: PPUSH
// case question of 1 :
17437: LD_VAR 0 1
17441: PUSH
17442: LD_INT 1
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17501
17450: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17451: LD_EXP 36
17455: PPUSH
17456: LD_STRING D2Mot-JMM-1
17458: PPUSH
17459: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17463: LD_EXP 55
17467: PPUSH
17468: LD_STRING D2Mot-Pow-1
17470: PPUSH
17471: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17475: LD_EXP 36
17479: PPUSH
17480: LD_STRING D2Mot-JMM-2
17482: PPUSH
17483: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17487: LD_EXP 55
17491: PPUSH
17492: LD_STRING D2Mot-Pow-2
17494: PPUSH
17495: CALL_OW 88
// end ; 2 :
17499: GO 17844
17501: LD_INT 2
17503: DOUBLE
17504: EQUAL
17505: IFTRUE 17509
17507: GO 17585
17509: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17510: LD_EXP 36
17514: PPUSH
17515: LD_STRING D2Rus-JMM-1
17517: PPUSH
17518: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17522: LD_EXP 55
17526: PPUSH
17527: LD_STRING D2Rus-Pow-1
17529: PPUSH
17530: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17534: LD_EXP 36
17538: PPUSH
17539: LD_STRING D2Rus-JMM-2
17541: PPUSH
17542: CALL_OW 88
// if not ( 3 in list_of_q ) then
17546: LD_INT 3
17548: PUSH
17549: LD_VAR 0 2
17553: IN
17554: NOT
17555: IFFALSE 17571
// Say ( Powell , D2Rus-Pow-2 ) else
17557: LD_EXP 55
17561: PPUSH
17562: LD_STRING D2Rus-Pow-2
17564: PPUSH
17565: CALL_OW 88
17569: GO 17583
// Say ( Powell , D2Rus-Pow-2a ) ;
17571: LD_EXP 55
17575: PPUSH
17576: LD_STRING D2Rus-Pow-2a
17578: PPUSH
17579: CALL_OW 88
// end ; 3 :
17583: GO 17844
17585: LD_INT 3
17587: DOUBLE
17588: EQUAL
17589: IFTRUE 17593
17591: GO 17678
17593: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17594: LD_EXP 36
17598: PPUSH
17599: LD_STRING D2Leg-JMM-1
17601: PPUSH
17602: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17606: LD_EXP 55
17610: PPUSH
17611: LD_STRING D2Leg-Pow-1
17613: PPUSH
17614: CALL_OW 88
// if 2 in list_of_q then
17618: LD_INT 2
17620: PUSH
17621: LD_VAR 0 2
17625: IN
17626: IFFALSE 17652
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17628: LD_EXP 36
17632: PPUSH
17633: LD_STRING D2Leg-JMM-2
17635: PPUSH
17636: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17640: LD_EXP 55
17644: PPUSH
17645: LD_STRING D2Leg-Pow-2
17647: PPUSH
17648: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17652: LD_EXP 36
17656: PPUSH
17657: LD_STRING D2Leg-JMM-3
17659: PPUSH
17660: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17664: LD_EXP 55
17668: PPUSH
17669: LD_STRING D2Leg-Pow-3
17671: PPUSH
17672: CALL_OW 88
// end ; 4 :
17676: GO 17844
17678: LD_INT 4
17680: DOUBLE
17681: EQUAL
17682: IFTRUE 17686
17684: GO 17761
17686: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17687: LD_EXP 36
17691: PPUSH
17692: LD_STRING D2Ar-JMM-1
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17699: LD_EXP 55
17703: PPUSH
17704: LD_STRING D2Ar-Pow-1
17706: PPUSH
17707: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17711: LD_EXP 36
17715: PPUSH
17716: LD_STRING D2Ar-JMM-2
17718: PPUSH
17719: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17723: LD_EXP 55
17727: PPUSH
17728: LD_STRING D2Ar-Pow-2
17730: PPUSH
17731: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17735: LD_EXP 36
17739: PPUSH
17740: LD_STRING D2Ar-JMM-3
17742: PPUSH
17743: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17747: LD_EXP 55
17751: PPUSH
17752: LD_STRING D2Ar-Pow-3
17754: PPUSH
17755: CALL_OW 88
// end ; 5 :
17759: GO 17844
17761: LD_INT 5
17763: DOUBLE
17764: EQUAL
17765: IFTRUE 17769
17767: GO 17784
17769: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17770: LD_EXP 36
17774: PPUSH
17775: LD_STRING D2Conf-JMM-1
17777: PPUSH
17778: CALL_OW 88
17782: GO 17844
17784: LD_INT 6
17786: DOUBLE
17787: EQUAL
17788: IFTRUE 17792
17790: GO 17843
17792: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17793: LD_EXP 36
17797: PPUSH
17798: LD_STRING D2Com-JMM-1
17800: PPUSH
17801: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17805: LD_EXP 55
17809: PPUSH
17810: LD_STRING D2Com-Pow-1
17812: PPUSH
17813: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17817: LD_EXP 36
17821: PPUSH
17822: LD_STRING D2Com-JMM-2
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17829: LD_EXP 55
17833: PPUSH
17834: LD_STRING D2Com-Pow-2
17836: PPUSH
17837: CALL_OW 88
// end ; end ;
17841: GO 17844
17843: POP
// end ;
17844: LD_VAR 0 3
17848: RET
// every 0 0$5 trigger missionStart do var tmp ;
17849: LD_EXP 13
17853: IFFALSE 18136
17855: GO 17857
17857: DISABLE
17858: LD_INT 0
17860: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17861: LD_INT 35
17863: PPUSH
17864: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17868: LD_INT 14
17870: PPUSH
17871: LD_INT 22
17873: PUSH
17874: LD_INT 1
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PPUSH
17881: CALL_OW 70
17885: PUSH
17886: LD_EXP 15
17890: PUSH
17891: LD_INT 2
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: LD_INT 4
17899: PUSH
17900: LD_INT 5
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: IN
17909: AND
17910: IFFALSE 18126
// begin powellAnger := powellAnger + 1 ;
17912: LD_ADDR_EXP 17
17916: PUSH
17917: LD_EXP 17
17921: PUSH
17922: LD_INT 1
17924: PLUS
17925: ST_TO_ADDR
// Video ( true ) ;
17926: LD_INT 1
17928: PPUSH
17929: CALL 106899 0 1
// CenterNowOnUnits ( tmp ) ;
17933: LD_VAR 0 1
17937: PPUSH
17938: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17942: LD_INT 14
17944: PPUSH
17945: LD_INT 22
17947: PUSH
17948: LD_INT 1
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PPUSH
17955: CALL_OW 70
17959: PPUSH
17960: LD_INT 86
17962: PPUSH
17963: LD_INT 133
17965: PPUSH
17966: CALL_OW 111
// async ;
17970: ASYNC
// case powellAnger of 1 :
17971: LD_EXP 17
17975: PUSH
17976: LD_INT 1
17978: DOUBLE
17979: EQUAL
17980: IFTRUE 17984
17982: GO 17999
17984: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17985: LD_EXP 55
17989: PPUSH
17990: LD_STRING DBack1-Pow-1
17992: PPUSH
17993: CALL_OW 88
17997: GO 18046
17999: LD_INT 2
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18022
18007: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18008: LD_EXP 55
18012: PPUSH
18013: LD_STRING DBack2-Pow-1
18015: PPUSH
18016: CALL_OW 88
18020: GO 18046
18022: LD_INT 3
18024: DOUBLE
18025: EQUAL
18026: IFTRUE 18030
18028: GO 18045
18030: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18031: LD_EXP 55
18035: PPUSH
18036: LD_STRING DBack3-Pow-1
18038: PPUSH
18039: CALL_OW 88
18043: GO 18046
18045: POP
// sync ;
18046: SYNC
// repeat wait ( 0 0$1 ) ;
18047: LD_INT 35
18049: PPUSH
18050: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18054: LD_INT 14
18056: PPUSH
18057: LD_INT 22
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: PPUSH
18067: CALL_OW 70
18071: PPUSH
18072: LD_INT 86
18074: PPUSH
18075: LD_INT 133
18077: PPUSH
18078: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18082: LD_INT 14
18084: PPUSH
18085: LD_INT 22
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 70
18099: NOT
18100: IFFALSE 18047
// if powellAnger >= 3 then
18102: LD_EXP 17
18106: PUSH
18107: LD_INT 3
18109: GREATEREQUAL
18110: IFFALSE 18119
// YouLost ( Dismissed ) ;
18112: LD_STRING Dismissed
18114: PPUSH
18115: CALL_OW 104
// Video ( false ) ;
18119: LD_INT 0
18121: PPUSH
18122: CALL 106899 0 1
// end ; until missionStage > 5 ;
18126: LD_EXP 15
18130: PUSH
18131: LD_INT 5
18133: GREATER
18134: IFFALSE 17861
// end ;
18136: PPOPN 1
18138: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18139: LD_EXP 13
18143: PUSH
18144: LD_INT 22
18146: PUSH
18147: LD_INT 4
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: LD_INT 21
18156: PUSH
18157: LD_INT 2
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PPUSH
18168: CALL_OW 69
18172: PUSH
18173: LD_INT 4
18175: GREATEREQUAL
18176: AND
18177: PUSH
18178: LD_EXP 15
18182: PUSH
18183: LD_INT 2
18185: EQUAL
18186: AND
18187: IFFALSE 20010
18189: GO 18191
18191: DISABLE
18192: LD_INT 0
18194: PPUSH
18195: PPUSH
18196: PPUSH
18197: PPUSH
18198: PPUSH
18199: PPUSH
18200: PPUSH
18201: PPUSH
// begin missionStage := 3 ;
18202: LD_ADDR_EXP 15
18206: PUSH
18207: LD_INT 3
18209: ST_TO_ADDR
// retreat := false ;
18210: LD_ADDR_VAR 0 4
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18218: LD_ADDR_VAR 0 5
18222: PUSH
18223: LD_INT 22
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: LD_INT 30
18235: PUSH
18236: LD_INT 4
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PPUSH
18247: CALL_OW 69
18251: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18252: LD_ADDR_VAR 0 6
18256: PUSH
18257: LD_INT 22
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 69
18285: ST_TO_ADDR
// if not bar then
18286: LD_VAR 0 6
18290: NOT
18291: IFFALSE 18344
// begin repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18300: LD_INT 22
18302: PUSH
18303: LD_INT 4
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PUSH
18310: LD_INT 3
18312: PUSH
18313: LD_INT 57
18315: PUSH
18316: EMPTY
18317: LIST
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 5
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: PPUSH
18338: CALL_OW 69
18342: IFFALSE 18293
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18344: LD_ADDR_VAR 0 6
18348: PUSH
18349: LD_INT 22
18351: PUSH
18352: LD_INT 4
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 30
18361: PUSH
18362: LD_INT 5
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PPUSH
18373: CALL_OW 69
18377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18378: LD_INT 35
18380: PPUSH
18381: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18385: LD_EXP 118
18389: PUSH
18390: LD_INT 4
18392: ARRAY
18393: PUSH
18394: LD_INT 4
18396: GREATEREQUAL
18397: IFFALSE 18378
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18399: LD_ADDR_VAR 0 2
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 4
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: LD_INT 2
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 1
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 2
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 3
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 25
18459: PUSH
18460: LD_INT 5
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PPUSH
18479: CALL_OW 69
18483: PUSH
18484: LD_EXP 55
18488: PUSH
18489: LD_EXP 56
18493: ADD
18494: DIFF
18495: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 2
18505: PPUSH
18506: LD_INT 26
18508: PUSH
18509: LD_INT 1
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: PPUSH
18516: CALL_OW 72
18520: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18521: LD_ADDR_VAR 0 2
18525: PUSH
18526: LD_VAR 0 2
18530: PUSH
18531: LD_VAR 0 3
18535: DIFF
18536: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 2
18546: PPUSH
18547: LD_INT 1
18549: PPUSH
18550: CALL 105552 0 2
18554: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18555: LD_ADDR_VAR 0 3
18559: PUSH
18560: LD_VAR 0 3
18564: PPUSH
18565: LD_INT 1
18567: PPUSH
18568: CALL 105552 0 2
18572: ST_TO_ADDR
// for i = 1 to 4 do
18573: LD_ADDR_VAR 0 1
18577: PUSH
18578: DOUBLE
18579: LD_INT 1
18581: DEC
18582: ST_TO_ADDR
18583: LD_INT 4
18585: PUSH
18586: FOR_TO
18587: IFFALSE 18753
// begin if tmp2 then
18589: LD_VAR 0 3
18593: IFFALSE 18674
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18595: LD_ADDR_EXP 18
18599: PUSH
18600: LD_EXP 18
18604: PPUSH
18605: LD_INT 1
18607: PPUSH
18608: LD_EXP 18
18612: PUSH
18613: LD_INT 1
18615: ARRAY
18616: PUSH
18617: LD_VAR 0 3
18621: PUSH
18622: LD_VAR 0 3
18626: ARRAY
18627: ADD
18628: PPUSH
18629: CALL_OW 1
18633: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18634: LD_VAR 0 3
18638: PUSH
18639: LD_VAR 0 3
18643: ARRAY
18644: PPUSH
18645: LD_INT 1
18647: PPUSH
18648: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18652: LD_ADDR_VAR 0 3
18656: PUSH
18657: LD_VAR 0 3
18661: PPUSH
18662: LD_VAR 0 3
18666: PPUSH
18667: CALL_OW 3
18671: ST_TO_ADDR
// end else
18672: GO 18751
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18674: LD_ADDR_EXP 18
18678: PUSH
18679: LD_EXP 18
18683: PPUSH
18684: LD_INT 1
18686: PPUSH
18687: LD_EXP 18
18691: PUSH
18692: LD_INT 1
18694: ARRAY
18695: PUSH
18696: LD_VAR 0 2
18700: PUSH
18701: LD_VAR 0 2
18705: ARRAY
18706: ADD
18707: PPUSH
18708: CALL_OW 1
18712: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18713: LD_VAR 0 2
18717: PUSH
18718: LD_VAR 0 2
18722: ARRAY
18723: PPUSH
18724: LD_INT 1
18726: PPUSH
18727: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18731: LD_ADDR_VAR 0 2
18735: PUSH
18736: LD_VAR 0 2
18740: PPUSH
18741: LD_VAR 0 2
18745: PPUSH
18746: CALL_OW 3
18750: ST_TO_ADDR
// end ; end ;
18751: GO 18586
18753: POP
18754: POP
// if tmp2 then
18755: LD_VAR 0 3
18759: IFFALSE 18777
// tmp := tmp union tmp2 ;
18761: LD_ADDR_VAR 0 2
18765: PUSH
18766: LD_VAR 0 2
18770: PUSH
18771: LD_VAR 0 3
18775: UNION
18776: ST_TO_ADDR
// for i = 1 to 4 do
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: DOUBLE
18783: LD_INT 1
18785: DEC
18786: ST_TO_ADDR
18787: LD_INT 4
18789: PUSH
18790: FOR_TO
18791: IFFALSE 18840
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18793: LD_ADDR_EXP 18
18797: PUSH
18798: LD_EXP 18
18802: PPUSH
18803: LD_INT 2
18805: PPUSH
18806: LD_EXP 18
18810: PUSH
18811: LD_INT 2
18813: ARRAY
18814: PUSH
18815: LD_VAR 0 2
18819: PUSH
18820: LD_VAR 0 2
18824: PUSH
18825: LD_VAR 0 1
18829: MINUS
18830: ARRAY
18831: ADD
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
18838: GO 18790
18840: POP
18841: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18842: LD_ADDR_EXP 99
18846: PUSH
18847: LD_EXP 99
18851: PPUSH
18852: LD_INT 4
18854: PPUSH
18855: LD_EXP 99
18859: PUSH
18860: LD_INT 4
18862: ARRAY
18863: PUSH
18864: LD_EXP 18
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: DIFF
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18879: LD_VAR 0 5
18883: PUSH
18884: LD_INT 1
18886: ARRAY
18887: PPUSH
18888: CALL_OW 313
18892: IFFALSE 18947
// begin for i in UnitsInside ( arm [ 1 ] ) do
18894: LD_ADDR_VAR 0 1
18898: PUSH
18899: LD_VAR 0 5
18903: PUSH
18904: LD_INT 1
18906: ARRAY
18907: PPUSH
18908: CALL_OW 313
18912: PUSH
18913: FOR_IN
18914: IFFALSE 18945
// begin ComExitBuilding ( i ) ;
18916: LD_VAR 0 1
18920: PPUSH
18921: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18925: LD_VAR 0 1
18929: PPUSH
18930: LD_VAR 0 6
18934: PUSH
18935: LD_INT 1
18937: ARRAY
18938: PPUSH
18939: CALL_OW 180
// end ;
18943: GO 18913
18945: POP
18946: POP
// end ; wait ( 0 0$3 ) ;
18947: LD_INT 105
18949: PPUSH
18950: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18954: LD_ADDR_VAR 0 1
18958: PUSH
18959: LD_EXP 18
18963: PUSH
18964: LD_INT 1
18966: ARRAY
18967: PUSH
18968: FOR_IN
18969: IFFALSE 19076
// begin if IsInUnit ( i ) then
18971: LD_VAR 0 1
18975: PPUSH
18976: CALL_OW 310
18980: IFFALSE 18991
// ComExitBuilding ( i ) ;
18982: LD_VAR 0 1
18986: PPUSH
18987: CALL_OW 122
// if GetClass ( i ) <> 1 then
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 257
19000: PUSH
19001: LD_INT 1
19003: NONEQUAL
19004: IFFALSE 19045
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19006: LD_VAR 0 1
19010: PPUSH
19011: LD_VAR 0 5
19015: PUSH
19016: LD_INT 1
19018: ARRAY
19019: PPUSH
19020: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19024: LD_VAR 0 1
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: CALL_OW 183
// AddComExitBuilding ( i ) ;
19036: LD_VAR 0 1
19040: PPUSH
19041: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19045: LD_VAR 0 1
19049: PPUSH
19050: LD_INT 60
19052: PPUSH
19053: LD_INT 94
19055: PPUSH
19056: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19060: LD_VAR 0 1
19064: PPUSH
19065: LD_EXP 55
19069: PPUSH
19070: CALL_OW 179
// end ;
19074: GO 18968
19076: POP
19077: POP
// wait ( 0 0$15 ) ;
19078: LD_INT 525
19080: PPUSH
19081: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19085: LD_EXP 55
19089: PPUSH
19090: LD_STRING D4-Pow-1
19092: PPUSH
19093: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19097: LD_ADDR_VAR 0 2
19101: PUSH
19102: LD_EXP 18
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_INT 26
19113: PUSH
19114: LD_INT 1
19116: PUSH
19117: EMPTY
19118: LIST
19119: LIST
19120: PPUSH
19121: CALL_OW 72
19125: ST_TO_ADDR
// if tmp then
19126: LD_VAR 0 2
19130: IFFALSE 19148
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19132: LD_VAR 0 2
19136: PUSH
19137: LD_INT 1
19139: ARRAY
19140: PPUSH
19141: LD_STRING D4-Sol1-1
19143: PPUSH
19144: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19148: LD_EXP 55
19152: PPUSH
19153: LD_STRING D4-Pow-2
19155: PPUSH
19156: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19160: LD_ADDR_VAR 0 1
19164: PUSH
19165: DOUBLE
19166: LD_INT 1
19168: DEC
19169: ST_TO_ADDR
19170: LD_EXP 18
19174: PUSH
19175: LD_INT 1
19177: ARRAY
19178: PUSH
19179: FOR_TO
19180: IFFALSE 19273
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19182: LD_EXP 18
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: PUSH
19191: LD_VAR 0 1
19195: ARRAY
19196: PPUSH
19197: LD_EXP 118
19201: PUSH
19202: LD_INT 4
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19214: LD_ADDR_EXP 118
19218: PUSH
19219: LD_EXP 118
19223: PPUSH
19224: LD_INT 4
19226: PPUSH
19227: LD_EXP 118
19231: PUSH
19232: LD_INT 4
19234: ARRAY
19235: PPUSH
19236: LD_INT 1
19238: PPUSH
19239: CALL_OW 3
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19249: LD_INT 8
19251: PPUSH
19252: LD_EXP 18
19256: PUSH
19257: LD_INT 1
19259: ARRAY
19260: PUSH
19261: LD_VAR 0 1
19265: ARRAY
19266: PPUSH
19267: CALL_OW 471
// end ;
19271: GO 19179
19273: POP
19274: POP
// repeat wait ( 0 0$1 ) ;
19275: LD_INT 35
19277: PPUSH
19278: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19282: LD_EXP 18
19286: PUSH
19287: LD_INT 1
19289: ARRAY
19290: PPUSH
19291: LD_INT 55
19293: PUSH
19294: EMPTY
19295: LIST
19296: PPUSH
19297: CALL_OW 72
19301: PUSH
19302: LD_INT 4
19304: GREATEREQUAL
19305: IFFALSE 19275
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19307: LD_EXP 18
19311: PUSH
19312: LD_INT 1
19314: ARRAY
19315: PPUSH
19316: LD_INT 69
19318: PPUSH
19319: LD_INT 94
19321: PPUSH
19322: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19326: LD_EXP 18
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: PPUSH
19335: LD_INT 82
19337: PPUSH
19338: LD_INT 83
19340: PPUSH
19341: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19345: LD_EXP 18
19349: PUSH
19350: LD_INT 1
19352: ARRAY
19353: PPUSH
19354: LD_INT 77
19356: PPUSH
19357: LD_INT 69
19359: PPUSH
19360: CALL_OW 174
// repeat wait ( 3 ) ;
19364: LD_INT 3
19366: PPUSH
19367: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19371: LD_ADDR_VAR 0 1
19375: PUSH
19376: LD_EXP 18
19380: PUSH
19381: LD_INT 1
19383: ARRAY
19384: PUSH
19385: FOR_IN
19386: IFFALSE 19522
// begin if GetLives ( i ) < 990 then
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL_OW 256
19397: PUSH
19398: LD_INT 990
19400: LESS
19401: IFFALSE 19415
// SetLives ( i , 1000 ) ;
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 1000
19410: PPUSH
19411: CALL_OW 234
// if not IsInUnit ( i ) then
19415: LD_VAR 0 1
19419: PPUSH
19420: CALL_OW 310
19424: NOT
19425: IFFALSE 19520
// begin if not HasTask ( i ) then
19427: LD_VAR 0 1
19431: PPUSH
19432: CALL_OW 314
19436: NOT
19437: IFFALSE 19454
// ComMoveXY ( i , 64 , 93 ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: LD_INT 64
19446: PPUSH
19447: LD_INT 93
19449: PPUSH
19450: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19454: LD_VAR 0 4
19458: NOT
19459: PUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: CALL_OW 258
19469: PUSH
19470: LD_INT 1
19472: EQUAL
19473: AND
19474: IFFALSE 19520
// begin retreat := true ;
19476: LD_ADDR_VAR 0 4
19480: PUSH
19481: LD_INT 1
19483: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19484: LD_VAR 0 1
19488: PPUSH
19489: LD_INT 2
19491: PPUSH
19492: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19496: LD_VAR 0 1
19500: PPUSH
19501: LD_STRING D4a-Sol1-1
19503: PPUSH
19504: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19508: LD_EXP 55
19512: PPUSH
19513: LD_STRING D4a-Pow-1
19515: PPUSH
19516: CALL_OW 88
// end ; end ; end ;
19520: GO 19385
19522: POP
19523: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19524: LD_EXP 18
19528: PUSH
19529: LD_INT 1
19531: ARRAY
19532: PPUSH
19533: LD_INT 95
19535: PUSH
19536: LD_INT 9
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 3
19545: PUSH
19546: LD_INT 55
19548: PUSH
19549: EMPTY
19550: LIST
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: PUSH
19556: EMPTY
19557: LIST
19558: LIST
19559: PPUSH
19560: CALL_OW 72
19564: PUSH
19565: LD_INT 4
19567: GREATEREQUAL
19568: IFFALSE 19364
// for i in powellSquadAttack [ 1 ] do
19570: LD_ADDR_VAR 0 1
19574: PUSH
19575: LD_EXP 18
19579: PUSH
19580: LD_INT 1
19582: ARRAY
19583: PUSH
19584: FOR_IN
19585: IFFALSE 19721
// begin if GetTag ( i ) = 2 then
19587: LD_VAR 0 1
19591: PPUSH
19592: CALL_OW 110
19596: PUSH
19597: LD_INT 2
19599: EQUAL
19600: IFFALSE 19662
// begin ComMoveXY ( i , 60 , 94 ) ;
19602: LD_VAR 0 1
19606: PPUSH
19607: LD_INT 60
19609: PPUSH
19610: LD_INT 94
19612: PPUSH
19613: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19617: LD_VAR 0 1
19621: PPUSH
19622: LD_EXP 55
19626: PPUSH
19627: CALL_OW 179
// wait ( 0 0$3 ) ;
19631: LD_INT 105
19633: PPUSH
19634: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_STRING D4a-Sol1-2
19645: PPUSH
19646: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19650: LD_EXP 55
19654: PPUSH
19655: LD_STRING D4a-Pow-2
19657: PPUSH
19658: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19662: LD_VAR 0 1
19666: PPUSH
19667: LD_INT 0
19669: PPUSH
19670: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19674: LD_ADDR_EXP 99
19678: PUSH
19679: LD_EXP 99
19683: PPUSH
19684: LD_INT 4
19686: PPUSH
19687: LD_EXP 99
19691: PUSH
19692: LD_INT 4
19694: ARRAY
19695: PUSH
19696: LD_VAR 0 1
19700: UNION
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19707: LD_INT 8
19709: PPUSH
19710: LD_VAR 0 1
19714: PPUSH
19715: CALL_OW 472
// end ;
19719: GO 19584
19721: POP
19722: POP
// wait ( 4 4$00 ) ;
19723: LD_INT 8400
19725: PPUSH
19726: CALL_OW 67
// uc_side := 6 ;
19730: LD_ADDR_OWVAR 20
19734: PUSH
19735: LD_INT 6
19737: ST_TO_ADDR
// uc_nation := 3 ;
19738: LD_ADDR_OWVAR 21
19742: PUSH
19743: LD_INT 3
19745: ST_TO_ADDR
// ru := [ ] ;
19746: LD_ADDR_VAR 0 7
19750: PUSH
19751: EMPTY
19752: ST_TO_ADDR
// for i = 1 to 4 do
19753: LD_ADDR_VAR 0 1
19757: PUSH
19758: DOUBLE
19759: LD_INT 1
19761: DEC
19762: ST_TO_ADDR
19763: LD_INT 4
19765: PUSH
19766: FOR_TO
19767: IFFALSE 19868
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19769: LD_INT 22
19771: PPUSH
19772: LD_INT 1
19774: PPUSH
19775: LD_INT 3
19777: PPUSH
19778: LD_INT 43
19780: PUSH
19781: LD_INT 44
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: PUSH
19788: LD_INT 1
19790: PPUSH
19791: LD_INT 2
19793: PPUSH
19794: CALL_OW 12
19798: ARRAY
19799: PPUSH
19800: LD_INT 89
19802: PPUSH
19803: CALL 71182 0 5
// un := CreateVehicle ;
19807: LD_ADDR_VAR 0 8
19811: PUSH
19812: CALL_OW 45
19816: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19817: LD_VAR 0 8
19821: PPUSH
19822: LD_INT 4
19824: PPUSH
19825: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19829: LD_VAR 0 8
19833: PPUSH
19834: LD_INT 136
19836: PPUSH
19837: LD_INT 90
19839: PPUSH
19840: LD_INT 8
19842: PPUSH
19843: LD_INT 0
19845: PPUSH
19846: CALL_OW 50
// ru := ru ^ un ;
19850: LD_ADDR_VAR 0 7
19854: PUSH
19855: LD_VAR 0 7
19859: PUSH
19860: LD_VAR 0 8
19864: ADD
19865: ST_TO_ADDR
// end ;
19866: GO 19766
19868: POP
19869: POP
// if ru then
19870: LD_VAR 0 7
19874: IFFALSE 19891
// ComAgressiveMove ( ru , 80 , 92 ) ;
19876: LD_VAR 0 7
19880: PPUSH
19881: LD_INT 80
19883: PPUSH
19884: LD_INT 92
19886: PPUSH
19887: CALL_OW 114
// wait ( 8 8$00 ) ;
19891: LD_INT 16800
19893: PPUSH
19894: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19898: LD_INT 4
19900: PPUSH
19901: LD_INT 3
19903: PUSH
19904: LD_INT 1
19906: PUSH
19907: LD_INT 1
19909: PUSH
19910: LD_INT 5
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: PUSH
19919: LD_INT 4
19921: PUSH
19922: LD_INT 1
19924: PUSH
19925: LD_INT 1
19927: PUSH
19928: LD_INT 6
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: LIST
19936: PUSH
19937: LD_INT 4
19939: PUSH
19940: LD_INT 1
19942: PUSH
19943: LD_INT 1
19945: PUSH
19946: LD_INT 7
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: PUSH
19955: LD_INT 3
19957: PUSH
19958: LD_INT 1
19960: PUSH
19961: LD_INT 1
19963: PUSH
19964: LD_INT 7
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: PUSH
19973: LD_INT 3
19975: PUSH
19976: LD_INT 1
19978: PUSH
19979: LD_INT 1
19981: PUSH
19982: LD_INT 5
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: PPUSH
19998: CALL 57675 0 2
// missionStage := 4 ;
20002: LD_ADDR_EXP 15
20006: PUSH
20007: LD_INT 4
20009: ST_TO_ADDR
// end ;
20010: PPOPN 8
20012: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20013: LD_EXP 15
20017: PUSH
20018: LD_INT 4
20020: EQUAL
20021: PUSH
20022: LD_INT 22
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 21
20034: PUSH
20035: LD_INT 2
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: PPUSH
20046: CALL_OW 69
20050: PUSH
20051: LD_INT 5
20053: GREATEREQUAL
20054: AND
20055: IFFALSE 24160
20057: GO 20059
20059: DISABLE
20060: LD_INT 0
20062: PPUSH
20063: PPUSH
20064: PPUSH
20065: PPUSH
20066: PPUSH
20067: PPUSH
20068: PPUSH
20069: PPUSH
20070: PPUSH
20071: PPUSH
20072: PPUSH
20073: PPUSH
20074: PPUSH
// begin missionStage := 5 ;
20075: LD_ADDR_EXP 15
20079: PUSH
20080: LD_INT 5
20082: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20083: LD_ADDR_VAR 0 10
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 2
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 4
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: LD_INT 30
20113: PUSH
20114: LD_INT 5
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: PUSH
20126: EMPTY
20127: LIST
20128: LIST
20129: PPUSH
20130: CALL_OW 69
20134: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20135: LD_ADDR_VAR 0 6
20139: PUSH
20140: LD_INT 22
20142: PUSH
20143: LD_INT 4
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 21
20152: PUSH
20153: LD_INT 1
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 3
20162: PUSH
20163: LD_INT 25
20165: PUSH
20166: LD_INT 16
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PUSH
20177: LD_INT 3
20179: PUSH
20180: LD_INT 25
20182: PUSH
20183: LD_INT 12
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: PPUSH
20200: CALL_OW 69
20204: PUSH
20205: LD_EXP 55
20209: DIFF
20210: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20211: LD_ADDR_VAR 0 9
20215: PUSH
20216: LD_INT 22
20218: PUSH
20219: LD_INT 4
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: LD_INT 30
20228: PUSH
20229: LD_INT 3
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 69
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20249: LD_INT 35
20251: PPUSH
20252: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20256: LD_EXP 118
20260: PUSH
20261: LD_INT 4
20263: ARRAY
20264: PUSH
20265: LD_INT 5
20267: GREATEREQUAL
20268: PUSH
20269: LD_EXP 118
20273: PUSH
20274: LD_INT 4
20276: ARRAY
20277: PPUSH
20278: LD_INT 58
20280: PUSH
20281: EMPTY
20282: LIST
20283: PPUSH
20284: CALL_OW 72
20288: PUSH
20289: LD_INT 5
20291: GREATEREQUAL
20292: AND
20293: IFFALSE 20249
// powellAllowRetreat := false ;
20295: LD_ADDR_EXP 19
20299: PUSH
20300: LD_INT 0
20302: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20303: LD_INT 700
20305: PPUSH
20306: CALL_OW 67
// activeAttacks := false ;
20310: LD_ADDR_EXP 16
20314: PUSH
20315: LD_INT 0
20317: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20318: LD_INT 35
20320: PPUSH
20321: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20325: LD_INT 22
20327: PUSH
20328: LD_INT 6
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PPUSH
20335: CALL_OW 69
20339: PUSH
20340: LD_INT 0
20342: EQUAL
20343: IFFALSE 20318
// tmp := mc_vehicles [ 4 ] ;
20345: LD_ADDR_VAR 0 3
20349: PUSH
20350: LD_EXP 118
20354: PUSH
20355: LD_INT 4
20357: ARRAY
20358: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20359: LD_ADDR_VAR 0 1
20363: PUSH
20364: DOUBLE
20365: LD_INT 1
20367: DEC
20368: ST_TO_ADDR
20369: LD_EXP 18
20373: PUSH
20374: FOR_TO
20375: IFFALSE 20636
// begin for j in powellSquadAttack [ i ] do
20377: LD_ADDR_VAR 0 2
20381: PUSH
20382: LD_EXP 18
20386: PUSH
20387: LD_VAR 0 1
20391: ARRAY
20392: PUSH
20393: FOR_IN
20394: IFFALSE 20632
// begin forces := forces diff j ;
20396: LD_ADDR_VAR 0 6
20400: PUSH
20401: LD_VAR 0 6
20405: PUSH
20406: LD_VAR 0 2
20410: DIFF
20411: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20412: LD_VAR 0 2
20416: PPUSH
20417: LD_INT 1
20419: PPUSH
20420: CALL_OW 109
// wait ( 0 0$2 ) ;
20424: LD_INT 70
20426: PPUSH
20427: CALL_OW 67
// if IsInUnit ( j ) then
20431: LD_VAR 0 2
20435: PPUSH
20436: CALL_OW 310
20440: IFFALSE 20451
// ComExitBuilding ( j ) ;
20442: LD_VAR 0 2
20446: PPUSH
20447: CALL_OW 122
// if GetClass ( j ) <> 1 then
20451: LD_VAR 0 2
20455: PPUSH
20456: CALL_OW 257
20460: PUSH
20461: LD_INT 1
20463: NONEQUAL
20464: IFFALSE 20544
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20466: LD_VAR 0 10
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: CALL_OW 313
20479: PUSH
20480: LD_INT 5
20482: GREATEREQUAL
20483: IFFALSE 20505
// AddComEnterUnit ( j , arm [ 2 ] ) else
20485: LD_VAR 0 2
20489: PPUSH
20490: LD_VAR 0 10
20494: PUSH
20495: LD_INT 2
20497: ARRAY
20498: PPUSH
20499: CALL_OW 180
20503: GO 20523
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20505: LD_VAR 0 2
20509: PPUSH
20510: LD_VAR 0 10
20514: PUSH
20515: LD_INT 1
20517: ARRAY
20518: PPUSH
20519: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20523: LD_VAR 0 2
20527: PPUSH
20528: LD_INT 1
20530: PPUSH
20531: CALL_OW 183
// AddComExitBuilding ( j ) ;
20535: LD_VAR 0 2
20539: PPUSH
20540: CALL_OW 182
// end ; if i = 2 then
20544: LD_VAR 0 1
20548: PUSH
20549: LD_INT 2
20551: EQUAL
20552: IFFALSE 20569
// AddComMoveXY ( j , 61 , 93 ) ;
20554: LD_VAR 0 2
20558: PPUSH
20559: LD_INT 61
20561: PPUSH
20562: LD_INT 93
20564: PPUSH
20565: CALL_OW 171
// if i = 1 then
20569: LD_VAR 0 1
20573: PUSH
20574: LD_INT 1
20576: EQUAL
20577: IFFALSE 20630
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20579: LD_VAR 0 2
20583: PPUSH
20584: LD_VAR 0 3
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: PPUSH
20593: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20597: LD_ADDR_VAR 0 3
20601: PUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: LD_INT 1
20609: PPUSH
20610: CALL_OW 3
20614: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20615: LD_VAR 0 2
20619: PPUSH
20620: LD_INT 69
20622: PPUSH
20623: LD_INT 94
20625: PPUSH
20626: CALL_OW 171
// end ; end ;
20630: GO 20393
20632: POP
20633: POP
// end ;
20634: GO 20374
20636: POP
20637: POP
// wait ( 0 0$55 ) ;
20638: LD_INT 1925
20640: PPUSH
20641: CALL_OW 67
// MC_Kill ( 4 ) ;
20645: LD_INT 4
20647: PPUSH
20648: CALL 34159 0 1
// tmp := UnitsInside ( fac ) ;
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_VAR 0 9
20661: PPUSH
20662: CALL_OW 313
20666: ST_TO_ADDR
// if tmp then
20667: LD_VAR 0 3
20671: IFFALSE 20792
// for i in tmp do
20673: LD_ADDR_VAR 0 1
20677: PUSH
20678: LD_VAR 0 3
20682: PUSH
20683: FOR_IN
20684: IFFALSE 20790
// begin ComExitBuilding ( i ) ;
20686: LD_VAR 0 1
20690: PPUSH
20691: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20695: LD_VAR 0 10
20699: PUSH
20700: LD_INT 2
20702: ARRAY
20703: PPUSH
20704: CALL_OW 313
20708: PUSH
20709: LD_INT 6
20711: LESS
20712: IFFALSE 20734
// AddComEnterUnit ( i , arm [ 2 ] ) else
20714: LD_VAR 0 1
20718: PPUSH
20719: LD_VAR 0 10
20723: PUSH
20724: LD_INT 2
20726: ARRAY
20727: PPUSH
20728: CALL_OW 180
20732: GO 20788
// if UnitsInside ( arm [ 1 ] ) < 6 then
20734: LD_VAR 0 10
20738: PUSH
20739: LD_INT 1
20741: ARRAY
20742: PPUSH
20743: CALL_OW 313
20747: PUSH
20748: LD_INT 6
20750: LESS
20751: IFFALSE 20773
// AddComEnterUnit ( i , arm [ 1 ] ) else
20753: LD_VAR 0 1
20757: PPUSH
20758: LD_VAR 0 10
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: PPUSH
20767: CALL_OW 180
20771: GO 20788
// AddComMoveXY ( i , 37 , 68 ) ;
20773: LD_VAR 0 1
20777: PPUSH
20778: LD_INT 37
20780: PPUSH
20781: LD_INT 68
20783: PPUSH
20784: CALL_OW 171
// end ;
20788: GO 20683
20790: POP
20791: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20792: LD_ADDR_VAR 0 11
20796: PUSH
20797: LD_VAR 0 6
20801: PPUSH
20802: LD_INT 26
20804: PUSH
20805: LD_INT 1
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PPUSH
20812: CALL_OW 72
20816: PUSH
20817: LD_EXP 56
20821: DIFF
20822: ST_TO_ADDR
// if not speaker then
20823: LD_VAR 0 11
20827: NOT
20828: IFFALSE 20855
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20830: LD_ADDR_VAR 0 11
20834: PUSH
20835: LD_VAR 0 6
20839: PPUSH
20840: LD_INT 26
20842: PUSH
20843: LD_INT 1
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PPUSH
20850: CALL_OW 72
20854: ST_TO_ADDR
// if speaker then
20855: LD_VAR 0 11
20859: IFFALSE 20875
// speaker := speaker [ 1 ] ;
20861: LD_ADDR_VAR 0 11
20865: PUSH
20866: LD_VAR 0 11
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: ST_TO_ADDR
// Video ( true ) ;
20875: LD_INT 1
20877: PPUSH
20878: CALL 106899 0 1
// CenterNowOnUnits ( Powell ) ;
20882: LD_EXP 55
20886: PPUSH
20887: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20891: LD_ADDR_VAR 0 3
20895: PUSH
20896: LD_VAR 0 6
20900: PPUSH
20901: LD_INT 3
20903: PUSH
20904: LD_INT 25
20906: PUSH
20907: LD_INT 1
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: PPUSH
20918: CALL_OW 72
20922: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20923: LD_ADDR_VAR 0 12
20927: PUSH
20928: LD_INT 22
20930: PUSH
20931: LD_INT 4
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 30
20940: PUSH
20941: LD_INT 32
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PUSH
20948: LD_INT 58
20950: PUSH
20951: EMPTY
20952: LIST
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: LIST
20958: PPUSH
20959: CALL_OW 69
20963: ST_TO_ADDR
// for i = 1 to 6 do
20964: LD_ADDR_VAR 0 1
20968: PUSH
20969: DOUBLE
20970: LD_INT 1
20972: DEC
20973: ST_TO_ADDR
20974: LD_INT 6
20976: PUSH
20977: FOR_TO
20978: IFFALSE 21119
// begin if IsInUnit ( tmp [ i ] ) then
20980: LD_VAR 0 3
20984: PUSH
20985: LD_VAR 0 1
20989: ARRAY
20990: PPUSH
20991: CALL_OW 310
20995: IFFALSE 21012
// ComExitBuilding ( tmp [ i ] ) ;
20997: LD_VAR 0 3
21001: PUSH
21002: LD_VAR 0 1
21006: ARRAY
21007: PPUSH
21008: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21012: LD_VAR 0 3
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: PPUSH
21023: LD_VAR 0 10
21027: PUSH
21028: LD_INT 1
21030: ARRAY
21031: PPUSH
21032: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21036: LD_VAR 0 3
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: PPUSH
21047: LD_INT 1
21049: PPUSH
21050: CALL_OW 183
// if emp_towers then
21054: LD_VAR 0 12
21058: IFFALSE 21117
// begin AddComExitBuilding ( tmp [ i ] ) ;
21060: LD_VAR 0 3
21064: PUSH
21065: LD_VAR 0 1
21069: ARRAY
21070: PPUSH
21071: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21075: LD_VAR 0 3
21079: PUSH
21080: LD_VAR 0 1
21084: ARRAY
21085: PPUSH
21086: LD_VAR 0 12
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: PPUSH
21095: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21099: LD_ADDR_VAR 0 12
21103: PUSH
21104: LD_VAR 0 12
21108: PPUSH
21109: LD_INT 1
21111: PPUSH
21112: CALL_OW 3
21116: ST_TO_ADDR
// end ; end ;
21117: GO 20977
21119: POP
21120: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21121: LD_ADDR_VAR 0 3
21125: PUSH
21126: LD_EXP 18
21130: PUSH
21131: LD_INT 1
21133: ARRAY
21134: PUSH
21135: LD_EXP 18
21139: PUSH
21140: LD_INT 2
21142: ARRAY
21143: ADD
21144: PPUSH
21145: LD_INT 26
21147: PUSH
21148: LD_INT 1
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: PPUSH
21155: CALL_OW 72
21159: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21160: LD_ADDR_VAR 0 1
21164: PUSH
21165: LD_EXP 18
21169: PUSH
21170: LD_INT 2
21172: ARRAY
21173: PUSH
21174: FOR_IN
21175: IFFALSE 21193
// ComTurnUnit ( i , Powell ) ;
21177: LD_VAR 0 1
21181: PPUSH
21182: LD_EXP 55
21186: PPUSH
21187: CALL_OW 119
21191: GO 21174
21193: POP
21194: POP
// Say ( Powell , D5-Pow-1 ) ;
21195: LD_EXP 55
21199: PPUSH
21200: LD_STRING D5-Pow-1
21202: PPUSH
21203: CALL_OW 88
// if tmp then
21207: LD_VAR 0 3
21211: IFFALSE 21229
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21213: LD_VAR 0 3
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: LD_STRING D5-Sol2-1
21224: PPUSH
21225: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21229: LD_EXP 55
21233: PPUSH
21234: LD_STRING D5-Pow-2
21236: PPUSH
21237: CALL_OW 88
// if tmp > 1 then
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 1
21248: GREATER
21249: IFFALSE 21267
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21251: LD_VAR 0 3
21255: PUSH
21256: LD_INT 2
21258: ARRAY
21259: PPUSH
21260: LD_STRING D5-Sol2-2
21262: PPUSH
21263: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21267: LD_EXP 55
21271: PPUSH
21272: LD_STRING D5-Pow-3
21274: PPUSH
21275: CALL_OW 88
// wait ( 0 0$1 ) ;
21279: LD_INT 35
21281: PPUSH
21282: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21286: LD_ADDR_VAR 0 3
21290: PUSH
21291: LD_EXP 18
21295: PUSH
21296: LD_INT 1
21298: ARRAY
21299: PUSH
21300: LD_EXP 18
21304: PUSH
21305: LD_INT 2
21307: ARRAY
21308: UNION
21309: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21310: LD_VAR 0 3
21314: PPUSH
21315: LD_INT 80
21317: PPUSH
21318: LD_INT 67
21320: PPUSH
21321: CALL_OW 114
// wait ( 0 0$2 ) ;
21325: LD_INT 70
21327: PPUSH
21328: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21332: LD_INT 79
21334: PPUSH
21335: LD_INT 72
21337: PPUSH
21338: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21342: LD_INT 35
21344: PPUSH
21345: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21349: LD_VAR 0 3
21353: PPUSH
21354: LD_INT 3
21356: PUSH
21357: LD_INT 24
21359: PUSH
21360: LD_INT 1000
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PPUSH
21371: CALL_OW 72
21375: IFFALSE 21342
// Say ( Powell , D5a-Pow-1 ) ;
21377: LD_EXP 55
21381: PPUSH
21382: LD_STRING D5a-Pow-1
21384: PPUSH
21385: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21389: LD_EXP 55
21393: PPUSH
21394: LD_STRING D5a-Pow-1a
21396: PPUSH
21397: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21401: LD_INT 10
21403: PPUSH
21404: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21408: LD_EXP 55
21412: PPUSH
21413: LD_STRING D5a-Pow-1b
21415: PPUSH
21416: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21420: LD_EXP 55
21424: PPUSH
21425: LD_STRING D5a-Pow-1c
21427: PPUSH
21428: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21432: LD_EXP 55
21436: PPUSH
21437: LD_STRING D5a-Pow-1d
21439: PPUSH
21440: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21444: LD_INT 35
21446: PPUSH
21447: CALL_OW 67
// if not HasTask ( tmp ) then
21451: LD_VAR 0 3
21455: PPUSH
21456: CALL_OW 314
21460: NOT
21461: IFFALSE 21478
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21463: LD_VAR 0 3
21467: PPUSH
21468: LD_INT 80
21470: PPUSH
21471: LD_INT 67
21473: PPUSH
21474: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21478: LD_VAR 0 3
21482: PPUSH
21483: LD_INT 24
21485: PUSH
21486: LD_INT 1
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: PPUSH
21493: CALL_OW 72
21497: NOT
21498: IFFALSE 21444
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21500: LD_ADDR_VAR 0 3
21504: PUSH
21505: LD_INT 22
21507: PUSH
21508: LD_INT 4
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 92
21517: PUSH
21518: LD_INT 60
21520: PUSH
21521: LD_INT 93
21523: PUSH
21524: LD_INT 10
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: PUSH
21533: LD_INT 3
21535: PUSH
21536: LD_INT 54
21538: PUSH
21539: EMPTY
21540: LIST
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: PPUSH
21551: CALL_OW 69
21555: PUSH
21556: LD_EXP 55
21560: DIFF
21561: ST_TO_ADDR
// if tmp then
21562: LD_VAR 0 3
21566: IFFALSE 21600
// for i in tmp do
21568: LD_ADDR_VAR 0 1
21572: PUSH
21573: LD_VAR 0 3
21577: PUSH
21578: FOR_IN
21579: IFFALSE 21598
// ComMoveXY ( i , 36 , 67 ) ;
21581: LD_VAR 0 1
21585: PPUSH
21586: LD_INT 36
21588: PPUSH
21589: LD_INT 67
21591: PPUSH
21592: CALL_OW 111
21596: GO 21578
21598: POP
21599: POP
// wait ( 0 0$3 ) ;
21600: LD_INT 105
21602: PPUSH
21603: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21607: LD_VAR 0 11
21611: PPUSH
21612: LD_STRING D6-Sol3-1
21614: PPUSH
21615: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21619: LD_EXP 55
21623: PPUSH
21624: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21628: LD_EXP 55
21632: PPUSH
21633: LD_STRING D6-Pow-1
21635: PPUSH
21636: CALL_OW 88
// tmp := [ ] ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: EMPTY
21646: ST_TO_ADDR
// for i = 1 to 2 do
21647: LD_ADDR_VAR 0 1
21651: PUSH
21652: DOUBLE
21653: LD_INT 1
21655: DEC
21656: ST_TO_ADDR
21657: LD_INT 2
21659: PUSH
21660: FOR_TO
21661: IFFALSE 21775
// begin uc_side := 8 ;
21663: LD_ADDR_OWVAR 20
21667: PUSH
21668: LD_INT 8
21670: ST_TO_ADDR
// uc_nation := 2 ;
21671: LD_ADDR_OWVAR 21
21675: PUSH
21676: LD_INT 2
21678: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21679: LD_INT 14
21681: PPUSH
21682: LD_INT 3
21684: PPUSH
21685: LD_INT 2
21687: PPUSH
21688: LD_INT 29
21690: PPUSH
21691: LD_INT 100
21693: PPUSH
21694: CALL 71182 0 5
// veh := CreateVehicle ;
21698: LD_ADDR_VAR 0 13
21702: PUSH
21703: CALL_OW 45
21707: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21708: LD_VAR 0 13
21712: PPUSH
21713: LD_INT 4
21715: PPUSH
21716: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21720: LD_VAR 0 13
21724: PPUSH
21725: LD_INT 99
21727: PPUSH
21728: LD_INT 83
21730: PPUSH
21731: LD_INT 6
21733: PPUSH
21734: LD_INT 0
21736: PPUSH
21737: CALL_OW 50
// wait ( 3 ) ;
21741: LD_INT 3
21743: PPUSH
21744: CALL_OW 67
// Connect ( veh ) ;
21748: LD_VAR 0 13
21752: PPUSH
21753: CALL 74237 0 1
// tmp := tmp ^ veh ;
21757: LD_ADDR_VAR 0 3
21761: PUSH
21762: LD_VAR 0 3
21766: PUSH
21767: LD_VAR 0 13
21771: ADD
21772: ST_TO_ADDR
// end ;
21773: GO 21660
21775: POP
21776: POP
// wait ( 0 0$1 ) ;
21777: LD_INT 35
21779: PPUSH
21780: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21784: LD_INT 99
21786: PPUSH
21787: LD_INT 83
21789: PPUSH
21790: LD_INT 1
21792: PPUSH
21793: LD_INT 10
21795: PPUSH
21796: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21800: LD_INT 99
21802: PPUSH
21803: LD_INT 83
21805: PPUSH
21806: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21810: LD_VAR 0 11
21814: PPUSH
21815: LD_STRING D6-Sol3-2
21817: PPUSH
21818: CALL_OW 88
// async ;
21822: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21823: LD_EXP 55
21827: PPUSH
21828: LD_STRING D6-Pow-2
21830: PPUSH
21831: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21835: LD_VAR 0 3
21839: PUSH
21840: LD_INT 1
21842: ARRAY
21843: PPUSH
21844: LD_VAR 0 9
21848: PPUSH
21849: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21853: LD_VAR 0 3
21857: PUSH
21858: LD_INT 2
21860: ARRAY
21861: PPUSH
21862: LD_INT 22
21864: PUSH
21865: LD_INT 4
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 21
21874: PUSH
21875: LD_INT 3
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PPUSH
21886: CALL_OW 69
21890: PPUSH
21891: LD_VAR 0 3
21895: PUSH
21896: LD_INT 2
21898: ARRAY
21899: PPUSH
21900: CALL_OW 74
21904: PPUSH
21905: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21909: LD_EXP 55
21913: PPUSH
21914: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21918: LD_INT 99
21920: PPUSH
21921: LD_INT 83
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 331
// repeat wait ( 4 ) ;
21931: LD_INT 4
21933: PPUSH
21934: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21938: LD_VAR 0 3
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: CALL_OW 256
21951: PUSH
21952: LD_INT 1000
21954: LESS
21955: IFFALSE 21973
// SetLives ( tmp [ 1 ] , 1000 ) ;
21957: LD_VAR 0 3
21961: PUSH
21962: LD_INT 1
21964: ARRAY
21965: PPUSH
21966: LD_INT 1000
21968: PPUSH
21969: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21973: LD_INT 22
21975: PUSH
21976: LD_INT 4
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 30
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: PPUSH
21997: CALL_OW 69
22001: PUSH
22002: LD_INT 0
22004: EQUAL
22005: IFFALSE 21931
// sync ;
22007: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22008: LD_EXP 55
22012: PPUSH
22013: LD_STRING D6a-Pow-1
22015: PPUSH
22016: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22020: LD_VAR 0 11
22024: PPUSH
22025: LD_STRING D6a-Sol3-1
22027: PPUSH
22028: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22032: LD_EXP 55
22036: PPUSH
22037: LD_STRING D6a-Pow-2
22039: PPUSH
22040: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22044: LD_VAR 0 11
22048: PPUSH
22049: LD_STRING D6a-Sol3-2
22051: PPUSH
22052: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22056: LD_EXP 55
22060: PPUSH
22061: LD_STRING D6a-Pow-3
22063: PPUSH
22064: CALL_OW 88
// powellCenterCameraMode := true ;
22068: LD_ADDR_EXP 20
22072: PUSH
22073: LD_INT 1
22075: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22076: LD_ADDR_VAR 0 1
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 8
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 25
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PPUSH
22105: CALL_OW 69
22109: PUSH
22110: FOR_IN
22111: IFFALSE 22166
// begin SetTag ( i , 1 ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_INT 1
22120: PPUSH
22121: CALL_OW 109
// ComExitBuilding ( i ) ;
22125: LD_VAR 0 1
22129: PPUSH
22130: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22134: LD_VAR 0 1
22138: PPUSH
22139: LD_INT 35
22141: PPUSH
22142: LD_INT 6
22144: PPUSH
22145: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22149: LD_VAR 0 1
22153: PPUSH
22154: LD_INT 53
22156: PPUSH
22157: LD_INT 4
22159: PPUSH
22160: CALL_OW 171
// end ;
22164: GO 22110
22166: POP
22167: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22168: LD_ADDR_VAR 0 3
22172: PUSH
22173: LD_INT 22
22175: PUSH
22176: LD_INT 4
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 21
22185: PUSH
22186: LD_INT 2
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 3
22195: PUSH
22196: LD_INT 34
22198: PUSH
22199: LD_INT 12
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: PPUSH
22215: CALL_OW 69
22219: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22220: LD_EXP 55
22224: PPUSH
22225: LD_VAR 0 3
22229: PPUSH
22230: LD_EXP 55
22234: PPUSH
22235: CALL_OW 74
22239: PPUSH
22240: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22244: LD_EXP 55
22248: PPUSH
22249: LD_INT 100
22251: PPUSH
22252: LD_INT 88
22254: PPUSH
22255: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22259: LD_EXP 55
22263: PPUSH
22264: LD_INT 100
22266: PPUSH
22267: LD_INT 75
22269: PPUSH
22270: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22274: LD_EXP 55
22278: PPUSH
22279: LD_INT 88
22281: PPUSH
22282: LD_INT 53
22284: PPUSH
22285: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22289: LD_INT 8
22291: PPUSH
22292: LD_EXP 55
22296: PPUSH
22297: CALL_OW 471
// repeat wait ( 3 ) ;
22301: LD_INT 3
22303: PPUSH
22304: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22308: LD_INT 22
22310: PUSH
22311: LD_INT 4
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PUSH
22318: LD_INT 92
22320: PUSH
22321: LD_INT 100
22323: PUSH
22324: LD_INT 75
22326: PUSH
22327: LD_INT 6
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: LIST
22334: LIST
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PPUSH
22340: CALL_OW 69
22344: IFFALSE 22301
// async ;
22346: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22347: LD_EXP 55
22351: PPUSH
22352: LD_STRING D6b-Pow-1
22354: PPUSH
22355: CALL_OW 88
// repeat wait ( 3 ) ;
22359: LD_INT 3
22361: PPUSH
22362: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22366: LD_EXP 55
22370: PPUSH
22371: CALL_OW 310
22375: PPUSH
22376: CALL_OW 256
22380: PUSH
22381: LD_INT 1000
22383: LESS
22384: IFFALSE 22403
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22386: LD_EXP 55
22390: PPUSH
22391: CALL_OW 310
22395: PPUSH
22396: LD_INT 1000
22398: PPUSH
22399: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22403: LD_EXP 55
22407: PPUSH
22408: CALL_OW 256
22412: PUSH
22413: LD_INT 1000
22415: LESS
22416: IFFALSE 22430
// SetLives ( Powell , 1000 ) ;
22418: LD_EXP 55
22422: PPUSH
22423: LD_INT 1000
22425: PPUSH
22426: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22430: LD_EXP 55
22434: PPUSH
22435: LD_EXP 60
22439: PPUSH
22440: CALL_OW 296
22444: PUSH
22445: LD_INT 5
22447: LESS
22448: PUSH
22449: LD_EXP 55
22453: PPUSH
22454: CALL_OW 310
22458: PPUSH
22459: LD_EXP 60
22463: PPUSH
22464: CALL_OW 296
22468: PUSH
22469: LD_INT 5
22471: LESS
22472: OR
22473: IFFALSE 22492
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22475: LD_EXP 55
22479: PPUSH
22480: CALL_OW 310
22484: PPUSH
22485: LD_INT 100
22487: PPUSH
22488: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22492: LD_EXP 55
22496: PPUSH
22497: CALL_OW 310
22501: NOT
22502: IFFALSE 22359
// DoNotAttack ( 8 , powellBomb ) ;
22504: LD_INT 8
22506: PPUSH
22507: LD_EXP 60
22511: PPUSH
22512: CALL_OW 471
// game_speed := 4 ;
22516: LD_ADDR_OWVAR 65
22520: PUSH
22521: LD_INT 4
22523: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22524: LD_EXP 55
22528: PPUSH
22529: LD_STRING D6b-Pow-1a
22531: PPUSH
22532: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22536: LD_EXP 55
22540: PPUSH
22541: LD_EXP 60
22545: PPUSH
22546: CALL_OW 180
// sync ;
22550: SYNC
// repeat wait ( 0 0$1 ) ;
22551: LD_INT 35
22553: PPUSH
22554: CALL_OW 67
// until IsInUnit ( Powell ) ;
22558: LD_EXP 55
22562: PPUSH
22563: CALL_OW 310
22567: IFFALSE 22551
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22569: LD_INT 8
22571: PPUSH
22572: LD_EXP 55
22576: PPUSH
22577: CALL_OW 310
22581: PPUSH
22582: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22586: LD_EXP 55
22590: PPUSH
22591: LD_INT 91
22593: PPUSH
22594: LD_INT 44
22596: PPUSH
22597: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22601: LD_EXP 55
22605: PPUSH
22606: LD_INT 96
22608: PPUSH
22609: LD_INT 44
22611: PPUSH
22612: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22616: LD_EXP 55
22620: PPUSH
22621: LD_INT 96
22623: PPUSH
22624: LD_INT 41
22626: PPUSH
22627: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22631: LD_EXP 55
22635: PPUSH
22636: LD_INT 92
22638: PPUSH
22639: LD_INT 39
22641: PPUSH
22642: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22646: LD_EXP 55
22650: PPUSH
22651: LD_INT 88
22653: PPUSH
22654: LD_INT 41
22656: PPUSH
22657: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22661: LD_EXP 55
22665: PPUSH
22666: LD_INT 91
22668: PPUSH
22669: LD_INT 44
22671: PPUSH
22672: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22676: LD_EXP 55
22680: PPUSH
22681: LD_INT 96
22683: PPUSH
22684: LD_INT 44
22686: PPUSH
22687: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22691: LD_EXP 55
22695: PPUSH
22696: LD_INT 96
22698: PPUSH
22699: LD_INT 41
22701: PPUSH
22702: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22706: LD_EXP 55
22710: PPUSH
22711: LD_INT 92
22713: PPUSH
22714: LD_INT 39
22716: PPUSH
22717: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22721: LD_EXP 55
22725: PPUSH
22726: LD_INT 88
22728: PPUSH
22729: LD_INT 41
22731: PPUSH
22732: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22736: LD_EXP 55
22740: PPUSH
22741: LD_INT 91
22743: PPUSH
22744: LD_INT 44
22746: PPUSH
22747: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22751: LD_EXP 55
22755: PPUSH
22756: LD_INT 93
22758: PPUSH
22759: LD_INT 39
22761: PPUSH
22762: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22766: LD_EXP 55
22770: PPUSH
22771: LD_INT 93
22773: PPUSH
22774: LD_INT 36
22776: PPUSH
22777: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22781: LD_INT 122
22783: PPUSH
22784: CALL_OW 67
// game_speed := 4 ;
22788: LD_ADDR_OWVAR 65
22792: PUSH
22793: LD_INT 4
22795: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22796: LD_EXP 55
22800: PPUSH
22801: LD_STRING D6b-Pow-1b
22803: PPUSH
22804: CALL_OW 88
// tmp := [ ] ;
22808: LD_ADDR_VAR 0 3
22812: PUSH
22813: EMPTY
22814: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22815: LD_ADDR_VAR 0 5
22819: PUSH
22820: LD_INT 78
22822: PUSH
22823: LD_INT 47
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: PUSH
22830: LD_INT 106
22832: PUSH
22833: LD_INT 53
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22844: LD_ADDR_VAR 0 1
22848: PUSH
22849: LD_INT 22
22851: PUSH
22852: LD_INT 8
22854: PUSH
22855: EMPTY
22856: LIST
22857: LIST
22858: PUSH
22859: LD_INT 21
22861: PUSH
22862: LD_INT 3
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PUSH
22869: LD_INT 92
22871: PUSH
22872: LD_INT 90
22874: PUSH
22875: LD_INT 52
22877: PUSH
22878: LD_INT 12
22880: PUSH
22881: EMPTY
22882: LIST
22883: LIST
22884: LIST
22885: LIST
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: PPUSH
22892: CALL_OW 69
22896: PUSH
22897: FOR_IN
22898: IFFALSE 22923
// tmp := tmp ^ UnitsInside ( i ) ;
22900: LD_ADDR_VAR 0 3
22904: PUSH
22905: LD_VAR 0 3
22909: PUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 313
22919: ADD
22920: ST_TO_ADDR
22921: GO 22897
22923: POP
22924: POP
// for i in tmp do
22925: LD_ADDR_VAR 0 1
22929: PUSH
22930: LD_VAR 0 3
22934: PUSH
22935: FOR_IN
22936: IFFALSE 23098
// begin dist := 9999 ;
22938: LD_ADDR_VAR 0 8
22942: PUSH
22943: LD_INT 9999
22945: ST_TO_ADDR
// _xy := [ ] ;
22946: LD_ADDR_VAR 0 7
22950: PUSH
22951: EMPTY
22952: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22953: LD_VAR 0 1
22957: PPUSH
22958: LD_INT 1
22960: PPUSH
22961: CALL_OW 109
// ComExitBuilding ( i ) ;
22965: LD_VAR 0 1
22969: PPUSH
22970: CALL_OW 122
// for j in xy do
22974: LD_ADDR_VAR 0 2
22978: PUSH
22979: LD_VAR 0 5
22983: PUSH
22984: FOR_IN
22985: IFFALSE 23067
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22987: LD_VAR 0 1
22991: PPUSH
22992: LD_VAR 0 2
22996: PUSH
22997: LD_INT 1
22999: ARRAY
23000: PPUSH
23001: LD_VAR 0 2
23005: PUSH
23006: LD_INT 2
23008: ARRAY
23009: PPUSH
23010: CALL_OW 297
23014: PUSH
23015: LD_VAR 0 8
23019: LESS
23020: IFFALSE 23065
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23022: LD_ADDR_VAR 0 8
23026: PUSH
23027: LD_VAR 0 1
23031: PPUSH
23032: LD_VAR 0 2
23036: PUSH
23037: LD_INT 1
23039: ARRAY
23040: PPUSH
23041: LD_VAR 0 2
23045: PUSH
23046: LD_INT 2
23048: ARRAY
23049: PPUSH
23050: CALL_OW 297
23054: ST_TO_ADDR
// _xy := j ;
23055: LD_ADDR_VAR 0 7
23059: PUSH
23060: LD_VAR 0 2
23064: ST_TO_ADDR
// end ;
23065: GO 22984
23067: POP
23068: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23069: LD_VAR 0 1
23073: PPUSH
23074: LD_VAR 0 7
23078: PUSH
23079: LD_INT 1
23081: ARRAY
23082: PPUSH
23083: LD_VAR 0 7
23087: PUSH
23088: LD_INT 2
23090: ARRAY
23091: PPUSH
23092: CALL_OW 171
// end ;
23096: GO 22935
23098: POP
23099: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23100: LD_ADDR_VAR 0 4
23104: PUSH
23105: LD_VAR 0 3
23109: PPUSH
23110: LD_INT 26
23112: PUSH
23113: LD_INT 1
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: PUSH
23120: LD_INT 25
23122: PUSH
23123: LD_INT 1
23125: PUSH
23126: EMPTY
23127: LIST
23128: LIST
23129: PUSH
23130: EMPTY
23131: LIST
23132: LIST
23133: PPUSH
23134: CALL_OW 72
23138: ST_TO_ADDR
// if tmp2 < 2 then
23139: LD_VAR 0 4
23143: PUSH
23144: LD_INT 2
23146: LESS
23147: IFFALSE 23216
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23149: LD_ADDR_VAR 0 4
23153: PUSH
23154: LD_INT 22
23156: PUSH
23157: LD_INT 8
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: PUSH
23164: LD_INT 26
23166: PUSH
23167: LD_INT 1
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: PUSH
23174: LD_INT 3
23176: PUSH
23177: LD_INT 25
23179: PUSH
23180: LD_INT 15
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: EMPTY
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: LIST
23194: LIST
23195: PPUSH
23196: CALL_OW 69
23200: PUSH
23201: LD_EXP 57
23205: PUSH
23206: LD_EXP 58
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: DIFF
23215: ST_TO_ADDR
// if tmp2 then
23216: LD_VAR 0 4
23220: IFFALSE 23238
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23222: LD_VAR 0 4
23226: PUSH
23227: LD_INT 1
23229: ARRAY
23230: PPUSH
23231: LD_STRING D6b-ArSol1-1
23233: PPUSH
23234: CALL_OW 88
// async ;
23238: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23239: LD_EXP 55
23243: PPUSH
23244: LD_STRING D6b-Pow-2
23246: PPUSH
23247: CALL_OW 88
// wait ( 0 0$1 ) ;
23251: LD_INT 35
23253: PPUSH
23254: CALL_OW 67
// if tmp2 > 1 then
23258: LD_VAR 0 4
23262: PUSH
23263: LD_INT 1
23265: GREATER
23266: IFFALSE 23284
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23268: LD_VAR 0 4
23272: PUSH
23273: LD_INT 2
23275: ARRAY
23276: PPUSH
23277: LD_STRING D6b-ArSol2-1
23279: PPUSH
23280: CALL_OW 88
// sync ;
23284: SYNC
// repeat wait ( 5 ) ;
23285: LD_INT 5
23287: PPUSH
23288: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23292: LD_INT 93
23294: PPUSH
23295: LD_INT 36
23297: PPUSH
23298: CALL_OW 428
23302: PPUSH
23303: CALL_OW 255
23307: PUSH
23308: LD_INT 4
23310: EQUAL
23311: IFFALSE 23285
// DialogueOn ;
23313: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23317: LD_INT 10
23319: PPUSH
23320: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23324: LD_EXP 55
23328: PPUSH
23329: LD_STRING D6b-Pow-2a
23331: PPUSH
23332: CALL_OW 88
// DialogueOff ;
23336: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23340: LD_EXP 55
23344: PPUSH
23345: CALL_OW 310
23349: PPUSH
23350: LD_INT 332
23352: PPUSH
23353: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23357: LD_INT 93
23359: PPUSH
23360: LD_INT 35
23362: PPUSH
23363: LD_INT 1
23365: PPUSH
23366: LD_INT 6
23368: NEG
23369: PPUSH
23370: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23374: LD_INT 35
23376: PPUSH
23377: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23381: LD_INT 332
23383: PPUSH
23384: CALL_OW 256
23388: PUSH
23389: LD_INT 1000
23391: LESS
23392: PUSH
23393: LD_INT 332
23395: PPUSH
23396: CALL_OW 300
23400: AND
23401: IFFALSE 23413
// SetLives ( kozlov_fac , 0 ) ;
23403: LD_INT 332
23405: PPUSH
23406: LD_INT 0
23408: PPUSH
23409: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23413: LD_INT 332
23415: PPUSH
23416: CALL_OW 301
23420: PUSH
23421: LD_EXP 55
23425: PPUSH
23426: CALL_OW 301
23430: OR
23431: IFFALSE 23374
// game_speed := 4 ;
23433: LD_ADDR_OWVAR 65
23437: PUSH
23438: LD_INT 4
23440: ST_TO_ADDR
// powellCenterCameraMode := false ;
23441: LD_ADDR_EXP 20
23445: PUSH
23446: LD_INT 0
23448: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23449: LD_ADDR_VAR 0 1
23453: PUSH
23454: LD_VAR 0 3
23458: PUSH
23459: LD_INT 22
23461: PUSH
23462: LD_INT 8
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PUSH
23469: LD_INT 25
23471: PUSH
23472: LD_INT 2
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PPUSH
23483: CALL_OW 69
23487: UNION
23488: PUSH
23489: FOR_IN
23490: IFFALSE 23506
// SetTag ( i , 0 ) ;
23492: LD_VAR 0 1
23496: PPUSH
23497: LD_INT 0
23499: PPUSH
23500: CALL_OW 109
23504: GO 23489
23506: POP
23507: POP
// wait ( 0 0$3 ) ;
23508: LD_INT 105
23510: PPUSH
23511: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23515: LD_INT 93
23517: PPUSH
23518: LD_INT 35
23520: PPUSH
23521: LD_INT 1
23523: PPUSH
23524: CALL_OW 331
// DialogueOn ;
23528: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23532: LD_VAR 0 11
23536: PPUSH
23537: LD_STRING D6c-Sol3-1
23539: PPUSH
23540: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23544: LD_INT 10
23546: PPUSH
23547: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23551: LD_EXP 36
23555: PPUSH
23556: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23560: LD_EXP 36
23564: PPUSH
23565: LD_STRING D6c-JMM-1
23567: PPUSH
23568: CALL_OW 88
// if Cyrus then
23572: LD_EXP 42
23576: IFFALSE 23590
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23578: LD_EXP 42
23582: PPUSH
23583: LD_STRING D6c-Cyrus-1
23585: PPUSH
23586: CALL_OW 88
// if Bobby then
23590: LD_EXP 41
23594: IFFALSE 23608
// Say ( Bobby , D6c-Bobby-1 ) ;
23596: LD_EXP 41
23600: PPUSH
23601: LD_STRING D6c-Bobby-1
23603: PPUSH
23604: CALL_OW 88
// if Cornel then
23608: LD_EXP 47
23612: IFFALSE 23626
// Say ( Cornel , D6c-Corn-1 ) ;
23614: LD_EXP 47
23618: PPUSH
23619: LD_STRING D6c-Corn-1
23621: PPUSH
23622: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23626: LD_ADDR_VAR 0 4
23630: PUSH
23631: LD_INT 2
23633: PUSH
23634: LD_INT 22
23636: PUSH
23637: LD_INT 1
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: PUSH
23644: LD_INT 22
23646: PUSH
23647: LD_INT 4
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: LIST
23658: PUSH
23659: LD_INT 26
23661: PUSH
23662: LD_INT 1
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: PUSH
23669: LD_INT 3
23671: PUSH
23672: LD_INT 25
23674: PUSH
23675: LD_INT 16
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 25
23684: PUSH
23685: LD_INT 12
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: LIST
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: LIST
23701: PPUSH
23702: CALL_OW 69
23706: PUSH
23707: LD_VAR 0 11
23711: PUSH
23712: LD_EXP 36
23716: UNION
23717: PUSH
23718: LD_EXP 56
23722: UNION
23723: PUSH
23724: EMPTY
23725: LIST
23726: DIFF
23727: ST_TO_ADDR
// if tmp2 then
23728: LD_VAR 0 4
23732: IFFALSE 23750
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23734: LD_VAR 0 4
23738: PUSH
23739: LD_INT 1
23741: ARRAY
23742: PPUSH
23743: LD_STRING D6c-Sol1-1
23745: PPUSH
23746: CALL_OW 88
// if Lisa then
23750: LD_EXP 39
23754: IFFALSE 23768
// Say ( Lisa , D6c-Lisa-1 ) ;
23756: LD_EXP 39
23760: PPUSH
23761: LD_STRING D6c-Lisa-1
23763: PPUSH
23764: CALL_OW 88
// if Gary then
23768: LD_EXP 48
23772: IFFALSE 23786
// Say ( Gary , D6c-Gary-1 ) ;
23774: LD_EXP 48
23778: PPUSH
23779: LD_STRING D6c-Gary-1
23781: PPUSH
23782: CALL_OW 88
// if Donaldson then
23786: LD_EXP 40
23790: IFFALSE 23804
// Say ( Donaldson , D6c-Don-1 ) ;
23792: LD_EXP 40
23796: PPUSH
23797: LD_STRING D6c-Don-1
23799: PPUSH
23800: CALL_OW 88
// if tmp2 > 1 then
23804: LD_VAR 0 4
23808: PUSH
23809: LD_INT 1
23811: GREATER
23812: IFFALSE 23830
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23814: LD_VAR 0 4
23818: PUSH
23819: LD_INT 2
23821: ARRAY
23822: PPUSH
23823: LD_STRING D6c-Sol2-1
23825: PPUSH
23826: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23830: LD_VAR 0 11
23834: PPUSH
23835: LD_STRING D6c-Sol3-2
23837: PPUSH
23838: CALL_OW 88
// dwait ( 0 0$1 ) ;
23842: LD_INT 35
23844: PPUSH
23845: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23849: LD_EXP 36
23853: PPUSH
23854: LD_STRING D6c-JMM-2
23856: PPUSH
23857: CALL_OW 88
// DialogueOff ;
23861: CALL_OW 7
// Video ( false ) ;
23865: LD_INT 0
23867: PPUSH
23868: CALL 106899 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23872: LD_INT 22
23874: PUSH
23875: LD_INT 4
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PPUSH
23882: CALL_OW 69
23886: PPUSH
23887: LD_INT 1
23889: PPUSH
23890: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23894: LD_INT 4
23896: PPUSH
23897: LD_INT 4
23899: PPUSH
23900: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23904: LD_ADDR_VAR 0 1
23908: PUSH
23909: LD_INT 4
23911: PPUSH
23912: LD_INT 1
23914: PPUSH
23915: LD_INT 2
23917: PPUSH
23918: CALL 64130 0 3
23922: PUSH
23923: FOR_IN
23924: IFFALSE 23961
// if GetTech ( i , 1 ) <> state_researched then
23926: LD_VAR 0 1
23930: PPUSH
23931: LD_INT 1
23933: PPUSH
23934: CALL_OW 321
23938: PUSH
23939: LD_INT 2
23941: NONEQUAL
23942: IFFALSE 23959
// SetTech ( i , 1 , state_researched ) ;
23944: LD_VAR 0 1
23948: PPUSH
23949: LD_INT 1
23951: PPUSH
23952: LD_INT 2
23954: PPUSH
23955: CALL_OW 322
23959: GO 23923
23961: POP
23962: POP
// missionStage := 6 ;
23963: LD_ADDR_EXP 15
23967: PUSH
23968: LD_INT 6
23970: ST_TO_ADDR
// activeAttacks := true ;
23971: LD_ADDR_EXP 16
23975: PUSH
23976: LD_INT 1
23978: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23979: LD_STRING M2
23981: PPUSH
23982: CALL_OW 337
// SaveForQuickRestart ;
23986: CALL_OW 22
// wait ( 0 0$40 ) ;
23990: LD_INT 1400
23992: PPUSH
23993: CALL_OW 67
// DialogueOn ;
23997: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24001: LD_EXP 59
24005: PPUSH
24006: LD_STRING D7-Friend-1
24008: PPUSH
24009: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24013: LD_EXP 36
24017: PPUSH
24018: LD_STRING D7-JMM-1
24020: PPUSH
24021: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24025: LD_EXP 59
24029: PPUSH
24030: LD_STRING D7-Friend-2
24032: PPUSH
24033: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24037: LD_EXP 36
24041: PPUSH
24042: LD_STRING D7-JMM-2
24044: PPUSH
24045: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24049: LD_EXP 59
24053: PPUSH
24054: LD_STRING D7-Friend-3
24056: PPUSH
24057: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24061: LD_EXP 36
24065: PPUSH
24066: LD_STRING D7-JMM-3
24068: PPUSH
24069: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24073: LD_EXP 59
24077: PPUSH
24078: LD_STRING D7-Friend-4
24080: PPUSH
24081: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24085: LD_EXP 36
24089: PPUSH
24090: LD_STRING D7-JMM-4
24092: PPUSH
24093: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24097: LD_EXP 59
24101: PPUSH
24102: LD_STRING D7-Friend-5
24104: PPUSH
24105: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24109: LD_EXP 36
24113: PPUSH
24114: LD_STRING D7-JMM-5
24116: PPUSH
24117: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24121: LD_EXP 59
24125: PPUSH
24126: LD_STRING D7-Friend-6
24128: PPUSH
24129: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24133: LD_EXP 36
24137: PPUSH
24138: LD_STRING D7-JMM-6
24140: PPUSH
24141: CALL_OW 88
// DialogueOff ;
24145: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24149: LD_STRING Mlegion
24151: PPUSH
24152: CALL_OW 337
// RebuildKozlovFactory ;
24156: CALL 4773 0 0
// end ;
24160: PPOPN 13
24162: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24163: LD_EXP 20
24167: PUSH
24168: LD_EXP 55
24172: PPUSH
24173: CALL_OW 300
24177: AND
24178: IFFALSE 24220
24180: GO 24182
24182: DISABLE
// begin enable ;
24183: ENABLE
// if IsInUnit ( Powell ) then
24184: LD_EXP 55
24188: PPUSH
24189: CALL_OW 310
24193: IFFALSE 24211
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24195: LD_EXP 55
24199: PPUSH
24200: CALL_OW 310
24204: PPUSH
24205: CALL_OW 85
24209: GO 24220
// CenterOnUnits ( Powell ) ;
24211: LD_EXP 55
24215: PPUSH
24216: CALL_OW 85
// end ;
24220: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24221: LD_INT 22
24223: PUSH
24224: LD_INT 8
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 34
24233: PUSH
24234: LD_INT 48
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: PPUSH
24245: CALL_OW 69
24249: IFFALSE 24512
24251: GO 24253
24253: DISABLE
24254: LD_INT 0
24256: PPUSH
24257: PPUSH
// begin if missionStage < 9 then
24258: LD_EXP 15
24262: PUSH
24263: LD_INT 9
24265: LESS
24266: IFFALSE 24276
// missionStage := 9 ;
24268: LD_ADDR_EXP 15
24272: PUSH
24273: LD_INT 9
24275: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24276: LD_ADDR_VAR 0 1
24280: PUSH
24281: LD_INT 22
24283: PUSH
24284: LD_INT 8
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: LD_INT 34
24293: PUSH
24294: LD_INT 48
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PPUSH
24305: CALL_OW 69
24309: PUSH
24310: LD_INT 1
24312: ARRAY
24313: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24314: LD_INT 175
24316: PPUSH
24317: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24321: LD_EXP 12
24325: PUSH
24326: LD_EXP 3
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: LD_INT 2
24336: PUSH
24337: EMPTY
24338: LIST
24339: LIST
24340: IN
24341: OR
24342: IFFALSE 24365
// target := [ 68 , 108 , 1 ] else
24344: LD_ADDR_VAR 0 2
24348: PUSH
24349: LD_INT 68
24351: PUSH
24352: LD_INT 108
24354: PUSH
24355: LD_INT 1
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: LIST
24362: ST_TO_ADDR
24363: GO 24384
// target := [ 181 , 88 , 2 ] ;
24365: LD_ADDR_VAR 0 2
24369: PUSH
24370: LD_INT 181
24372: PUSH
24373: LD_INT 88
24375: PUSH
24376: LD_INT 2
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: LIST
24383: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24384: LD_VAR 0 1
24388: PPUSH
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 1
24396: ARRAY
24397: PPUSH
24398: LD_VAR 0 2
24402: PUSH
24403: LD_INT 2
24405: ARRAY
24406: PPUSH
24407: CALL_OW 176
// if target [ 3 ] = 1 then
24411: LD_VAR 0 2
24415: PUSH
24416: LD_INT 3
24418: ARRAY
24419: PUSH
24420: LD_INT 1
24422: EQUAL
24423: IFFALSE 24439
// SayRadio ( Kurt , D12-Kurt-1 ) else
24425: LD_EXP 57
24429: PPUSH
24430: LD_STRING D12-Kurt-1
24432: PPUSH
24433: CALL_OW 94
24437: GO 24463
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24439: LD_EXP 57
24443: PPUSH
24444: LD_STRING D12a-Kurt-1
24446: PPUSH
24447: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24451: LD_EXP 71
24455: PPUSH
24456: LD_STRING D12a-Roth-1
24458: PPUSH
24459: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24463: LD_INT 350
24465: PPUSH
24466: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24470: LD_VAR 0 1
24474: PPUSH
24475: LD_INT 22
24477: PUSH
24478: LD_INT 8
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 30
24487: PUSH
24488: LD_INT 3
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: PPUSH
24499: CALL_OW 69
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 228
// end ;
24512: PPOPN 2
24514: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24515: LD_INT 22
24517: PUSH
24518: LD_INT 8
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 21
24527: PUSH
24528: LD_INT 1
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 23
24537: PUSH
24538: LD_INT 2
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: PPUSH
24550: CALL_OW 69
24554: PUSH
24555: LD_INT 9
24557: PUSH
24558: LD_INT 8
24560: PUSH
24561: LD_INT 7
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: LIST
24568: PUSH
24569: LD_OWVAR 67
24573: ARRAY
24574: LESSEQUAL
24575: PUSH
24576: LD_INT 22
24578: PUSH
24579: LD_INT 8
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 34
24588: PUSH
24589: LD_INT 48
24591: PUSH
24592: EMPTY
24593: LIST
24594: LIST
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PPUSH
24600: CALL_OW 69
24604: NOT
24605: AND
24606: PUSH
24607: LD_EXP 57
24611: PPUSH
24612: CALL_OW 302
24616: AND
24617: IFFALSE 24922
24619: GO 24621
24621: DISABLE
// begin DialogueOn ;
24622: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24626: LD_EXP 36
24630: PPUSH
24631: LD_STRING D13-JMM-1
24633: PPUSH
24634: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24638: LD_EXP 57
24642: PPUSH
24643: LD_STRING D13-Kurt-1
24645: PPUSH
24646: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24650: LD_EXP 36
24654: PPUSH
24655: LD_STRING D13-JMM-2
24657: PPUSH
24658: CALL_OW 88
// if FakeInfo then
24662: LD_EXP 12
24666: IFFALSE 24686
// begin Say ( Kurt , D13-Kurt-2 ) ;
24668: LD_EXP 57
24672: PPUSH
24673: LD_STRING D13-Kurt-2
24675: PPUSH
24676: CALL_OW 88
// DialogueOff ;
24680: CALL_OW 7
// exit ;
24684: GO 24922
// end ; if not KurtStatus then
24686: LD_EXP 3
24690: NOT
24691: IFFALSE 24707
// Say ( Kurt , D13-Kurt-2b ) else
24693: LD_EXP 57
24697: PPUSH
24698: LD_STRING D13-Kurt-2b
24700: PPUSH
24701: CALL_OW 88
24705: GO 24719
// Say ( Kurt , D13-Kurt-2a ) ;
24707: LD_EXP 57
24711: PPUSH
24712: LD_STRING D13-Kurt-2a
24714: PPUSH
24715: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24719: LD_EXP 36
24723: PPUSH
24724: LD_STRING D13-JMM-3
24726: PPUSH
24727: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24731: LD_EXP 57
24735: PPUSH
24736: LD_STRING D13-Kurt-3
24738: PPUSH
24739: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24743: LD_EXP 36
24747: PPUSH
24748: LD_STRING D13-JMM-4
24750: PPUSH
24751: CALL_OW 88
// DialogueOff ;
24755: CALL_OW 7
// MC_Kill ( 3 ) ;
24759: LD_INT 3
24761: PPUSH
24762: CALL 34159 0 1
// KillUnit ( Kozlov ) ;
24766: LD_EXP 58
24770: PPUSH
24771: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24775: LD_INT 22
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 21
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 23
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 30
24807: PUSH
24808: LD_INT 3
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: LIST
24819: LIST
24820: PPUSH
24821: CALL_OW 69
24825: PUSH
24826: LD_INT 1
24828: ARRAY
24829: PPUSH
24830: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24834: LD_INT 8
24836: PPUSH
24837: LD_INT 1
24839: PPUSH
24840: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24844: LD_INT 22
24846: PUSH
24847: LD_INT 8
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: PPUSH
24854: CALL_OW 69
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24866: LD_INT 8
24868: PPUSH
24869: LD_INT 1
24871: PPUSH
24872: LD_INT 1
24874: PPUSH
24875: LD_INT 1
24877: PPUSH
24878: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24882: LD_EXP 59
24886: PPUSH
24887: LD_INT 37
24889: PPUSH
24890: LD_INT 1
24892: PPUSH
24893: LD_INT 0
24895: PPUSH
24896: CALL_OW 48
// wait ( 0 0$1 ) ;
24900: LD_INT 35
24902: PPUSH
24903: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24907: LD_EXP 59
24911: PPUSH
24912: LD_INT 60
24914: PPUSH
24915: LD_INT 95
24917: PPUSH
24918: CALL_OW 111
// end ;
24922: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24923: LD_INT 22
24925: PUSH
24926: LD_INT 8
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: LD_INT 21
24935: PUSH
24936: LD_INT 1
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PPUSH
24947: CALL_OW 69
24951: PUSH
24952: LD_INT 0
24954: EQUAL
24955: IFFALSE 24975
24957: GO 24959
24959: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24960: LD_STRING MlegionOut
24962: PPUSH
24963: CALL_OW 337
// legionDestroyed := true ;
24967: LD_ADDR_EXP 22
24971: PUSH
24972: LD_INT 1
24974: ST_TO_ADDR
// end ;
24975: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
24976: LD_INT 1
24978: PPUSH
24979: LD_EXP 59
24983: PPUSH
24984: CALL_OW 292
24988: IFFALSE 25288
24990: GO 24992
24992: DISABLE
24993: LD_INT 0
24995: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24996: LD_EXP 59
25000: PPUSH
25001: CALL_OW 87
// DialogueOn ;
25005: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25009: LD_EXP 36
25013: PPUSH
25014: LD_STRING D14-JMM-1
25016: PPUSH
25017: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25021: LD_EXP 59
25025: PPUSH
25026: LD_STRING D14-Friend-1
25028: PPUSH
25029: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25033: LD_EXP 36
25037: PPUSH
25038: LD_STRING D14-JMM-2
25040: PPUSH
25041: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25045: LD_EXP 59
25049: PPUSH
25050: LD_STRING D14-Friend-2
25052: PPUSH
25053: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25057: LD_EXP 36
25061: PPUSH
25062: LD_STRING D14-JMM-3
25064: PPUSH
25065: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25069: LD_EXP 59
25073: PPUSH
25074: LD_STRING D14-Friend-3
25076: PPUSH
25077: CALL_OW 88
// DialogueOff ;
25081: CALL_OW 7
// dec = Query ( Q14 ) ;
25085: LD_ADDR_VAR 0 1
25089: PUSH
25090: LD_STRING Q14
25092: PPUSH
25093: CALL_OW 97
25097: ST_TO_ADDR
// if dec = 1 then
25098: LD_VAR 0 1
25102: PUSH
25103: LD_INT 1
25105: EQUAL
25106: IFFALSE 25140
// begin DialogueOn ;
25108: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25112: LD_EXP 36
25116: PPUSH
25117: LD_STRING D14a-JMM-1
25119: PPUSH
25120: CALL_OW 88
// DialogueOff ;
25124: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25128: LD_EXP 59
25132: PPUSH
25133: LD_INT 1
25135: PPUSH
25136: CALL_OW 235
// end ; if dec = 2 then
25140: LD_VAR 0 1
25144: PUSH
25145: LD_INT 2
25147: EQUAL
25148: IFFALSE 25194
// begin DialogueOn ;
25150: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25154: LD_EXP 36
25158: PPUSH
25159: LD_STRING D14b-JMM-1
25161: PPUSH
25162: CALL_OW 88
// DialogueOff ;
25166: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25170: LD_EXP 59
25174: PPUSH
25175: LD_INT 9
25177: PPUSH
25178: LD_INT 2
25180: PPUSH
25181: CALL_OW 111
// AddComHold ( Friend ) ;
25185: LD_EXP 59
25189: PPUSH
25190: CALL_OW 200
// end ; if dec = 3 then
25194: LD_VAR 0 1
25198: PUSH
25199: LD_INT 3
25201: EQUAL
25202: IFFALSE 25288
// begin DialogueOn ;
25204: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25208: LD_EXP 36
25212: PPUSH
25213: LD_STRING D14c-JMM-1
25215: PPUSH
25216: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25220: LD_EXP 59
25224: PPUSH
25225: LD_STRING D14c-Friend-1
25227: PPUSH
25228: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25232: LD_EXP 36
25236: PPUSH
25237: LD_STRING D14c-JMM-2
25239: PPUSH
25240: CALL_OW 88
// DialogueOff ;
25244: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25248: LD_INT 8
25250: PPUSH
25251: LD_INT 1
25253: PPUSH
25254: LD_INT 2
25256: PPUSH
25257: LD_INT 1
25259: PPUSH
25260: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25264: LD_EXP 59
25268: PPUSH
25269: LD_INT 9
25271: PPUSH
25272: LD_INT 2
25274: PPUSH
25275: CALL_OW 111
// AddComHold ( Friend ) ;
25279: LD_EXP 59
25283: PPUSH
25284: CALL_OW 200
// end ; end ;
25288: PPOPN 1
25290: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25291: LD_INT 9
25293: PPUSH
25294: LD_INT 2
25296: PPUSH
25297: CALL_OW 428
25301: PUSH
25302: LD_EXP 59
25306: EQUAL
25307: PUSH
25308: LD_EXP 59
25312: PPUSH
25313: CALL_OW 255
25317: PUSH
25318: LD_INT 8
25320: EQUAL
25321: AND
25322: IFFALSE 25336
25324: GO 25326
25326: DISABLE
// RemoveUnit ( Friend ) ;
25327: LD_EXP 59
25331: PPUSH
25332: CALL_OW 64
25336: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25337: LD_EXP 14
25341: PUSH
25342: LD_INT 31500
25344: GREATEREQUAL
25345: PUSH
25346: LD_EXP 7
25350: AND
25351: PUSH
25352: LD_EXP 2
25356: AND
25357: IFFALSE 25787
25359: GO 25361
25361: DISABLE
25362: LD_INT 0
25364: PPUSH
25365: PPUSH
25366: PPUSH
// begin missionStage := 7 ;
25367: LD_ADDR_EXP 15
25371: PUSH
25372: LD_INT 7
25374: ST_TO_ADDR
// uc_side = 1 ;
25375: LD_ADDR_OWVAR 20
25379: PUSH
25380: LD_INT 1
25382: ST_TO_ADDR
// uc_nation = 1 ;
25383: LD_ADDR_OWVAR 21
25387: PUSH
25388: LD_INT 1
25390: ST_TO_ADDR
// for i = 1 to 5 do
25391: LD_ADDR_VAR 0 1
25395: PUSH
25396: DOUBLE
25397: LD_INT 1
25399: DEC
25400: ST_TO_ADDR
25401: LD_INT 5
25403: PUSH
25404: FOR_TO
25405: IFFALSE 25501
// begin vc_engine = 3 ;
25407: LD_ADDR_OWVAR 39
25411: PUSH
25412: LD_INT 3
25414: ST_TO_ADDR
// vc_control = 3 ;
25415: LD_ADDR_OWVAR 38
25419: PUSH
25420: LD_INT 3
25422: ST_TO_ADDR
// vc_chassis = 3 ;
25423: LD_ADDR_OWVAR 37
25427: PUSH
25428: LD_INT 3
25430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25431: LD_ADDR_OWVAR 40
25435: PUSH
25436: LD_INT 5
25438: PUSH
25439: LD_INT 9
25441: PUSH
25442: LD_INT 7
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: PUSH
25450: LD_INT 1
25452: PPUSH
25453: LD_INT 3
25455: PPUSH
25456: CALL_OW 12
25460: ARRAY
25461: ST_TO_ADDR
// veh = CreateVehicle ;
25462: LD_ADDR_VAR 0 2
25466: PUSH
25467: CALL_OW 45
25471: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25472: LD_VAR 0 2
25476: PPUSH
25477: LD_INT 1
25479: PPUSH
25480: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_INT 19
25491: PPUSH
25492: LD_INT 0
25494: PPUSH
25495: CALL_OW 49
// end ;
25499: GO 25404
25501: POP
25502: POP
// vc_engine = 3 ;
25503: LD_ADDR_OWVAR 39
25507: PUSH
25508: LD_INT 3
25510: ST_TO_ADDR
// vc_control = 1 ;
25511: LD_ADDR_OWVAR 38
25515: PUSH
25516: LD_INT 1
25518: ST_TO_ADDR
// vc_chassis = 3 ;
25519: LD_ADDR_OWVAR 37
25523: PUSH
25524: LD_INT 3
25526: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25527: LD_ADDR_OWVAR 40
25531: PUSH
25532: LD_INT 5
25534: PUSH
25535: LD_INT 9
25537: PUSH
25538: LD_INT 7
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: PPUSH
25549: LD_INT 3
25551: PPUSH
25552: CALL_OW 12
25556: ARRAY
25557: ST_TO_ADDR
// vehG = CreateVehicle ;
25558: LD_ADDR_VAR 0 3
25562: PUSH
25563: CALL_OW 45
25567: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25568: LD_VAR 0 3
25572: PPUSH
25573: LD_INT 1
25575: PPUSH
25576: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25580: LD_VAR 0 3
25584: PPUSH
25585: LD_INT 19
25587: PPUSH
25588: LD_INT 0
25590: PPUSH
25591: CALL_OW 49
// if JMMGirl = 1 then
25595: LD_EXP 7
25599: PUSH
25600: LD_INT 1
25602: EQUAL
25603: IFFALSE 25659
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25605: LD_ADDR_EXP 37
25609: PUSH
25610: LD_STRING Joan
25612: PPUSH
25613: LD_INT 1
25615: PPUSH
25616: LD_STRING 14_
25618: PPUSH
25619: CALL 64067 0 3
25623: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25624: LD_EXP 37
25628: PPUSH
25629: LD_VAR 0 3
25633: PPUSH
25634: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25638: LD_VAR 0 3
25642: PPUSH
25643: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25647: LD_EXP 37
25651: PPUSH
25652: LD_STRING D10BW-Joan-1
25654: PPUSH
25655: CALL_OW 94
// end ; if JMMGirl = 2 then
25659: LD_EXP 7
25663: PUSH
25664: LD_INT 2
25666: EQUAL
25667: IFFALSE 25723
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25669: LD_ADDR_EXP 39
25673: PUSH
25674: LD_STRING Lisa
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_STRING 14_
25682: PPUSH
25683: CALL 64067 0 3
25687: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25688: LD_EXP 39
25692: PPUSH
25693: LD_VAR 0 3
25697: PPUSH
25698: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25702: LD_VAR 0 3
25706: PPUSH
25707: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25711: LD_EXP 39
25715: PPUSH
25716: LD_STRING D10BW-Lisa-1
25718: PPUSH
25719: CALL_OW 94
// end ; if JMMGirl = 3 then
25723: LD_EXP 7
25727: PUSH
25728: LD_INT 3
25730: EQUAL
25731: IFFALSE 25787
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25733: LD_ADDR_EXP 51
25737: PUSH
25738: LD_STRING Connie
25740: PPUSH
25741: LD_INT 1
25743: PPUSH
25744: LD_STRING 14_
25746: PPUSH
25747: CALL 64067 0 3
25751: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25752: LD_EXP 51
25756: PPUSH
25757: LD_VAR 0 3
25761: PPUSH
25762: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25766: LD_VAR 0 3
25770: PPUSH
25771: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
25775: LD_EXP 51
25779: PPUSH
25780: LD_STRING D10BW-Con-1
25782: PPUSH
25783: CALL_OW 94
// end ; end ;
25787: PPOPN 3
25789: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25790: LD_EXP 14
25794: PUSH
25795: LD_INT 94500
25797: GREATEREQUAL
25798: IFFALSE 26210
25800: GO 25802
25802: DISABLE
25803: LD_INT 0
25805: PPUSH
25806: PPUSH
25807: PPUSH
// begin tmp := PrepareStevensSquad ;
25808: LD_ADDR_VAR 0 3
25812: PUSH
25813: CALL 2147 0 0
25817: ST_TO_ADDR
// if not tmp then
25818: LD_VAR 0 3
25822: NOT
25823: IFFALSE 25827
// exit ;
25825: GO 26210
// uc_side := 1 ;
25827: LD_ADDR_OWVAR 20
25831: PUSH
25832: LD_INT 1
25834: ST_TO_ADDR
// uc_nation := 1 ;
25835: LD_ADDR_OWVAR 21
25839: PUSH
25840: LD_INT 1
25842: ST_TO_ADDR
// for i in tmp do
25843: LD_ADDR_VAR 0 1
25847: PUSH
25848: LD_VAR 0 3
25852: PUSH
25853: FOR_IN
25854: IFFALSE 25951
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25856: LD_INT 3
25858: PPUSH
25859: LD_INT 3
25861: PPUSH
25862: LD_INT 1
25864: PPUSH
25865: LD_INT 5
25867: PUSH
25868: LD_INT 9
25870: PUSH
25871: LD_INT 7
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: LIST
25878: PUSH
25879: LD_INT 1
25881: PPUSH
25882: LD_INT 3
25884: PPUSH
25885: CALL_OW 12
25889: ARRAY
25890: PPUSH
25891: LD_INT 40
25893: PPUSH
25894: CALL 71182 0 5
// veh := CreateVehicle ;
25898: LD_ADDR_VAR 0 2
25902: PUSH
25903: CALL_OW 45
25907: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25908: LD_VAR 0 2
25912: PPUSH
25913: LD_INT 1
25915: PPUSH
25916: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25920: LD_VAR 0 2
25924: PPUSH
25925: LD_INT 19
25927: PPUSH
25928: LD_INT 0
25930: PPUSH
25931: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25935: LD_VAR 0 1
25939: PPUSH
25940: LD_VAR 0 2
25944: PPUSH
25945: CALL_OW 52
// end ;
25949: GO 25853
25951: POP
25952: POP
// missionStage := 8 ;
25953: LD_ADDR_EXP 15
25957: PUSH
25958: LD_INT 8
25960: ST_TO_ADDR
// DialogueOn ;
25961: CALL_OW 6
// if Stevens then
25965: LD_EXP 38
25969: IFFALSE 26083
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25971: LD_EXP 38
25975: PPUSH
25976: CALL_OW 310
25980: PPUSH
25981: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25985: LD_EXP 38
25989: PPUSH
25990: LD_STRING D8-Huck-1
25992: PPUSH
25993: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25997: LD_EXP 36
26001: PPUSH
26002: LD_STRING D8-JMM-1
26004: PPUSH
26005: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26009: LD_EXP 38
26013: PPUSH
26014: LD_STRING D8-Huck-2
26016: PPUSH
26017: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26021: LD_EXP 36
26025: PPUSH
26026: LD_STRING D8-JMM-2
26028: PPUSH
26029: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26033: LD_EXP 38
26037: PPUSH
26038: LD_STRING D8-Huck-3
26040: PPUSH
26041: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26045: LD_EXP 36
26049: PPUSH
26050: LD_STRING D8-JMM-3
26052: PPUSH
26053: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26057: LD_EXP 38
26061: PPUSH
26062: LD_STRING D8-Huck-4
26064: PPUSH
26065: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26069: LD_EXP 36
26073: PPUSH
26074: LD_STRING D8-JMM-4
26076: PPUSH
26077: CALL_OW 88
// end else
26081: GO 26193
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26083: LD_EXP 52
26087: PPUSH
26088: CALL_OW 310
26092: PPUSH
26093: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26097: LD_EXP 52
26101: PPUSH
26102: LD_STRING D8-Huck-1
26104: PPUSH
26105: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26109: LD_EXP 36
26113: PPUSH
26114: LD_STRING D8-JMM-1a
26116: PPUSH
26117: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26121: LD_EXP 52
26125: PPUSH
26126: LD_STRING D8-Huck-2
26128: PPUSH
26129: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26133: LD_EXP 36
26137: PPUSH
26138: LD_STRING D8-JMM-2
26140: PPUSH
26141: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26145: LD_EXP 52
26149: PPUSH
26150: LD_STRING D8-Huck-3
26152: PPUSH
26153: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26157: LD_EXP 36
26161: PPUSH
26162: LD_STRING D8-JMM-3
26164: PPUSH
26165: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26169: LD_EXP 52
26173: PPUSH
26174: LD_STRING D8-Huck-4
26176: PPUSH
26177: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26181: LD_EXP 36
26185: PPUSH
26186: LD_STRING D8-JMM-4
26188: PPUSH
26189: CALL_OW 88
// end ; DialogueOff ;
26193: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26197: LD_INT 25
26199: PPUSH
26200: LD_INT 1
26202: PPUSH
26203: LD_INT 1
26205: PPUSH
26206: CALL_OW 322
// end ;
26210: PPOPN 3
26212: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26213: LD_INT 1
26215: PPUSH
26216: LD_EXP 68
26220: PPUSH
26221: CALL_OW 292
26225: IFFALSE 26476
26227: GO 26229
26229: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26230: LD_EXP 68
26234: PPUSH
26235: CALL_OW 87
// DialogueOn ;
26239: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26243: LD_EXP 36
26247: PPUSH
26248: LD_STRING D10nB-JMM-1
26250: PPUSH
26251: CALL_OW 88
// if BurlakStatus = 1 then
26255: LD_EXP 9
26259: PUSH
26260: LD_INT 1
26262: EQUAL
26263: IFFALSE 26277
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26265: LD_EXP 67
26269: PPUSH
26270: LD_STRING D10nB-Vse-1a
26272: PPUSH
26273: CALL_OW 94
// end ; if BurlakStatus = 0 then
26277: LD_EXP 9
26281: PUSH
26282: LD_INT 0
26284: EQUAL
26285: IFFALSE 26299
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26287: LD_EXP 67
26291: PPUSH
26292: LD_STRING D10nB-Vse-1
26294: PPUSH
26295: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26299: LD_EXP 36
26303: PPUSH
26304: LD_STRING D10nB-JMM-2
26306: PPUSH
26307: CALL_OW 88
// if KappaStatus then
26311: LD_EXP 2
26315: IFFALSE 26329
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26317: LD_EXP 67
26321: PPUSH
26322: LD_STRING D10nB-Vse-5a
26324: PPUSH
26325: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26329: LD_EXP 2
26333: NOT
26334: PUSH
26335: LD_EXP 6
26339: PUSH
26340: LD_INT 0
26342: EQUAL
26343: AND
26344: IFFALSE 26472
// begin if JMMGirl = 1 then
26346: LD_EXP 7
26350: PUSH
26351: LD_INT 1
26353: EQUAL
26354: IFFALSE 26404
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26356: LD_EXP 67
26360: PPUSH
26361: LD_STRING D10nB-Vse-2
26363: PPUSH
26364: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26368: LD_EXP 36
26372: PPUSH
26373: LD_STRING D10nB-JMM-3
26375: PPUSH
26376: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26380: LD_EXP 67
26384: PPUSH
26385: LD_STRING D10nB-Vse-3
26387: PPUSH
26388: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26392: LD_EXP 36
26396: PPUSH
26397: LD_STRING D10nB-JMM-4
26399: PPUSH
26400: CALL_OW 88
// end ; if JMMGirl = 2 then
26404: LD_EXP 7
26408: PUSH
26409: LD_INT 2
26411: EQUAL
26412: IFFALSE 26438
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26414: LD_EXP 67
26418: PPUSH
26419: LD_STRING D10nB-Vse-4
26421: PPUSH
26422: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26426: LD_EXP 36
26430: PPUSH
26431: LD_STRING D10nB-JMM-5
26433: PPUSH
26434: CALL_OW 88
// end ; if JMMGirl = 3 then
26438: LD_EXP 7
26442: PUSH
26443: LD_INT 3
26445: EQUAL
26446: IFFALSE 26472
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26448: LD_EXP 67
26452: PPUSH
26453: LD_STRING D10nB-Vse-5
26455: PPUSH
26456: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26460: LD_EXP 36
26464: PPUSH
26465: LD_STRING D10nB-JMM-6
26467: PPUSH
26468: CALL_OW 88
// end ; end ; DialogueOff ;
26472: CALL_OW 7
// end ;
26476: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26477: LD_EXP 14
26481: PUSH
26482: LD_INT 115500
26484: GREATEREQUAL
26485: IFFALSE 26850
26487: GO 26489
26489: DISABLE
26490: LD_INT 0
26492: PPUSH
// begin missionStage := 10 ;
26493: LD_ADDR_EXP 15
26497: PUSH
26498: LD_INT 10
26500: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26501: LD_ADDR_VAR 0 1
26505: PUSH
26506: LD_INT 22
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 26
26518: PUSH
26519: LD_INT 1
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 3
26528: PUSH
26529: LD_INT 25
26531: PUSH
26532: LD_INT 12
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 3
26545: PUSH
26546: LD_INT 25
26548: PUSH
26549: LD_INT 16
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: PPUSH
26566: CALL_OW 69
26570: PUSH
26571: LD_EXP 36
26575: PUSH
26576: LD_EXP 57
26580: PUSH
26581: LD_EXP 38
26585: PUSH
26586: LD_EXP 52
26590: PUSH
26591: LD_EXP 39
26595: PUSH
26596: LD_EXP 40
26600: PUSH
26601: LD_EXP 41
26605: PUSH
26606: LD_EXP 42
26610: PUSH
26611: LD_EXP 43
26615: PUSH
26616: LD_EXP 44
26620: PUSH
26621: LD_EXP 45
26625: PUSH
26626: LD_EXP 46
26630: PUSH
26631: LD_EXP 47
26635: PUSH
26636: LD_EXP 48
26640: PUSH
26641: LD_EXP 49
26645: PUSH
26646: LD_EXP 50
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: DIFF
26669: ST_TO_ADDR
// if not tmp and Brown then
26670: LD_VAR 0 1
26674: NOT
26675: PUSH
26676: LD_EXP 44
26680: AND
26681: IFFALSE 26696
// tmp := [ Brown ] ;
26683: LD_ADDR_VAR 0 1
26687: PUSH
26688: LD_EXP 44
26692: PUSH
26693: EMPTY
26694: LIST
26695: ST_TO_ADDR
// DialogueOn ;
26696: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26700: LD_VAR 0 1
26704: PUSH
26705: LD_INT 1
26707: ARRAY
26708: PPUSH
26709: LD_STRING D11-Sol1-1
26711: PPUSH
26712: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26716: LD_EXP 61
26720: PPUSH
26721: LD_STRING D11-Pla-1
26723: PPUSH
26724: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26728: LD_EXP 62
26732: PPUSH
26733: LD_STRING D11-Kov-1
26735: PPUSH
26736: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26740: LD_EXP 61
26744: PPUSH
26745: LD_STRING D11-Pla-2
26747: PPUSH
26748: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26752: LD_VAR 0 1
26756: PUSH
26757: LD_INT 1
26759: ARRAY
26760: PPUSH
26761: LD_STRING D11-Sol1-2
26763: PPUSH
26764: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26768: LD_EXP 36
26772: PPUSH
26773: LD_STRING D11-JMM-2
26775: PPUSH
26776: CALL_OW 88
// DialogueOff ;
26780: CALL_OW 7
// allowBehemothConstruct := true ;
26784: LD_ADDR_EXP 25
26788: PUSH
26789: LD_INT 1
26791: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26792: LD_STRING M4
26794: PPUSH
26795: CALL_OW 337
// BuildBehemoths ;
26799: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26803: LD_INT 31500
26805: PPUSH
26806: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26810: LD_EXP 27
26814: IFFALSE 26818
// break ;
26816: GO 26850
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26818: LD_INT 267
26820: PPUSH
26821: CALL_OW 274
26825: PPUSH
26826: LD_INT 1
26828: PPUSH
26829: CALL_OW 275
26833: PUSH
26834: LD_INT 1000
26836: GREATEREQUAL
26837: IFFALSE 26843
// BuildBehemoths ;
26839: CALL 7577 0 0
// until not behemothBuilders ;
26843: LD_EXP 70
26847: NOT
26848: IFFALSE 26803
// end ;
26850: PPOPN 1
26852: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26853: LD_EXP 70
26857: NOT
26858: PUSH
26859: LD_EXP 28
26863: NOT
26864: AND
26865: PUSH
26866: LD_EXP 25
26870: AND
26871: IFFALSE 26891
26873: GO 26875
26875: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26876: LD_STRING M4a
26878: PPUSH
26879: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26883: LD_ADDR_EXP 27
26887: PUSH
26888: LD_INT 1
26890: ST_TO_ADDR
// end ;
26891: END
// every 0 0$1 trigger behemothDone do
26892: LD_EXP 28
26896: IFFALSE 26908
26898: GO 26900
26900: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26901: LD_STRING M4b
26903: PPUSH
26904: CALL_OW 337
26908: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26909: LD_EXP 29
26913: NOT
26914: IFFALSE 27110
26916: GO 26918
26918: DISABLE
26919: LD_INT 0
26921: PPUSH
26922: PPUSH
// begin enable ;
26923: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26924: LD_ADDR_VAR 0 1
26928: PUSH
26929: LD_INT 3
26931: PPUSH
26932: CALL 106975 0 1
26936: ST_TO_ADDR
// if not tmp and not behemothDone then
26937: LD_VAR 0 1
26941: NOT
26942: PUSH
26943: LD_EXP 28
26947: NOT
26948: AND
26949: IFFALSE 26985
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26951: LD_ADDR_VAR 0 1
26955: PUSH
26956: LD_INT 22
26958: PUSH
26959: LD_INT 3
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 30
26968: PUSH
26969: LD_INT 37
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PPUSH
26980: CALL_OW 69
26984: ST_TO_ADDR
// if not tmp then
26985: LD_VAR 0 1
26989: NOT
26990: IFFALSE 26994
// exit ;
26992: GO 27110
// for i in tmp do
26994: LD_ADDR_VAR 0 2
26998: PUSH
26999: LD_VAR 0 1
27003: PUSH
27004: FOR_IN
27005: IFFALSE 27108
// if See ( 1 , i ) then
27007: LD_INT 1
27009: PPUSH
27010: LD_VAR 0 2
27014: PPUSH
27015: CALL_OW 292
27019: IFFALSE 27106
// begin if GetType ( i ) = unit_building then
27021: LD_VAR 0 2
27025: PPUSH
27026: CALL_OW 247
27030: PUSH
27031: LD_INT 3
27033: EQUAL
27034: IFFALSE 27072
// begin CenterNowOnUnits ( i ) ;
27036: LD_VAR 0 2
27040: PPUSH
27041: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27045: LD_EXP 36
27049: PPUSH
27050: LD_STRING D17a-JMM-1
27052: PPUSH
27053: CALL_OW 88
// seeBehemoth := true ;
27057: LD_ADDR_EXP 29
27061: PUSH
27062: LD_INT 1
27064: ST_TO_ADDR
// disable ;
27065: DISABLE
// exit ;
27066: POP
27067: POP
27068: GO 27110
// end else
27070: GO 27106
// begin CenterNowOnUnits ( i ) ;
27072: LD_VAR 0 2
27076: PPUSH
27077: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27081: LD_EXP 36
27085: PPUSH
27086: LD_STRING D17b-JMM-1
27088: PPUSH
27089: CALL_OW 88
// seeBehemoth := true ;
27093: LD_ADDR_EXP 29
27097: PUSH
27098: LD_INT 1
27100: ST_TO_ADDR
// disable ;
27101: DISABLE
// exit ;
27102: POP
27103: POP
27104: GO 27110
// end ; end ;
27106: GO 27004
27108: POP
27109: POP
// end ;
27110: PPOPN 2
27112: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27113: LD_EXP 14
27117: PUSH
27118: LD_INT 116550
27120: GREATEREQUAL
27121: IFFALSE 28297
27123: GO 27125
27125: DISABLE
27126: LD_INT 0
27128: PPUSH
27129: PPUSH
27130: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27131: LD_INT 2
27133: PPUSH
27134: LD_INT 23
27136: PUSH
27137: LD_INT 3
27139: PUSH
27140: LD_INT 3
27142: PUSH
27143: LD_INT 48
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: PUSH
27152: EMPTY
27153: LIST
27154: PPUSH
27155: CALL 57723 0 2
// repeat wait ( 0 0$1 ) ;
27159: LD_INT 35
27161: PPUSH
27162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27166: LD_INT 22
27168: PUSH
27169: LD_INT 3
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 34
27178: PUSH
27179: LD_INT 48
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PPUSH
27190: CALL_OW 69
27194: IFFALSE 27159
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27196: LD_ADDR_VAR 0 1
27200: PUSH
27201: LD_INT 22
27203: PUSH
27204: LD_INT 3
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 34
27213: PUSH
27214: LD_INT 48
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PPUSH
27225: CALL_OW 69
27229: PUSH
27230: LD_INT 1
27232: ARRAY
27233: ST_TO_ADDR
// missionStage := 12 ;
27234: LD_ADDR_EXP 15
27238: PUSH
27239: LD_INT 12
27241: ST_TO_ADDR
// platonovHasBomb := true ;
27242: LD_ADDR_EXP 30
27246: PUSH
27247: LD_INT 1
27249: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27250: LD_VAR 0 1
27254: PPUSH
27255: LD_INT 181
27257: PPUSH
27258: LD_INT 86
27260: PPUSH
27261: CALL_OW 171
// AddComHold ( bomb ) ;
27265: LD_VAR 0 1
27269: PPUSH
27270: CALL_OW 200
// wait ( 0 0$10 ) ;
27274: LD_INT 350
27276: PPUSH
27277: CALL_OW 67
// DialogueOn ;
27281: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27285: LD_EXP 61
27289: PPUSH
27290: LD_STRING D15-Pla-1
27292: PPUSH
27293: CALL_OW 94
// dec = Query ( Q15a ) ;
27297: LD_ADDR_VAR 0 2
27301: PUSH
27302: LD_STRING Q15a
27304: PPUSH
27305: CALL_OW 97
27309: ST_TO_ADDR
// if dec = 1 then
27310: LD_VAR 0 2
27314: PUSH
27315: LD_INT 1
27317: EQUAL
27318: IFFALSE 27341
// begin Say ( JMM , D15a-JMM-1 ) ;
27320: LD_EXP 36
27324: PPUSH
27325: LD_STRING D15a-JMM-1
27327: PPUSH
27328: CALL_OW 88
// YouLost ( Surrender ) ;
27332: LD_STRING Surrender
27334: PPUSH
27335: CALL_OW 104
// exit ;
27339: GO 28297
// end ; if dec = 2 then
27341: LD_VAR 0 2
27345: PUSH
27346: LD_INT 2
27348: EQUAL
27349: IFFALSE 27418
// begin Say ( JMM , D15b-JMM-1 ) ;
27351: LD_EXP 36
27355: PPUSH
27356: LD_STRING D15b-JMM-1
27358: PPUSH
27359: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27363: LD_EXP 61
27367: PPUSH
27368: LD_STRING D15b-Pla-1
27370: PPUSH
27371: CALL_OW 94
// DialogueOff ;
27375: CALL_OW 7
// wait ( 3 3$00 ) ;
27379: LD_INT 6300
27381: PPUSH
27382: CALL_OW 67
// DialogueOn ;
27386: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27390: LD_EXP 36
27394: PPUSH
27395: LD_STRING D15d-JMM-1a
27397: PPUSH
27398: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27402: LD_EXP 61
27406: PPUSH
27407: LD_STRING D15d-Pla-1
27409: PPUSH
27410: CALL_OW 94
// DialogueOff ;
27414: CALL_OW 7
// end ; if dec = 3 then
27418: LD_VAR 0 2
27422: PUSH
27423: LD_INT 3
27425: EQUAL
27426: IFFALSE 27480
// begin Say ( JMM , D15c-JMM-1 ) ;
27428: LD_EXP 36
27432: PPUSH
27433: LD_STRING D15c-JMM-1
27435: PPUSH
27436: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27440: LD_EXP 61
27444: PPUSH
27445: LD_STRING D15c-Pla-1
27447: PPUSH
27448: CALL_OW 94
// DialogueOff ;
27452: CALL_OW 7
// wait ( 0 0$15 ) ;
27456: LD_INT 525
27458: PPUSH
27459: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27463: LD_VAR 0 1
27467: PPUSH
27468: LD_INT 60
27470: PPUSH
27471: LD_INT 95
27473: PPUSH
27474: CALL_OW 116
// exit ;
27478: GO 28297
// end ; if dec = 4 then
27480: LD_VAR 0 2
27484: PUSH
27485: LD_INT 4
27487: EQUAL
27488: IFFALSE 27518
// begin Say ( JMM , D15d-JMM-1 ) ;
27490: LD_EXP 36
27494: PPUSH
27495: LD_STRING D15d-JMM-1
27497: PPUSH
27498: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27502: LD_EXP 61
27506: PPUSH
27507: LD_STRING D15d-Pla-1
27509: PPUSH
27510: CALL_OW 94
// DialogueOff ;
27514: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27518: LD_EXP 59
27522: PPUSH
27523: CALL_OW 302
27527: PUSH
27528: LD_EXP 59
27532: PPUSH
27533: CALL_OW 255
27537: PUSH
27538: LD_INT 1
27540: EQUAL
27541: AND
27542: PUSH
27543: LD_INT 22
27545: PUSH
27546: LD_INT 1
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: LD_INT 34
27555: PUSH
27556: LD_INT 8
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: PPUSH
27567: CALL_OW 69
27571: NOT
27572: AND
27573: IFFALSE 28198
// begin SetSide ( Friend , 8 ) ;
27575: LD_EXP 59
27579: PPUSH
27580: LD_INT 8
27582: PPUSH
27583: CALL_OW 235
// if IsInUnit ( Friend ) then
27587: LD_EXP 59
27591: PPUSH
27592: CALL_OW 310
27596: IFFALSE 27607
// ComExitBuilding ( Friend ) ;
27598: LD_EXP 59
27602: PPUSH
27603: CALL_OW 122
// if IsDriver ( Friend ) then
27607: LD_EXP 59
27611: PPUSH
27612: CALL 104652 0 1
27616: IFFALSE 27627
// ComExitVehicle ( Friend ) ;
27618: LD_EXP 59
27622: PPUSH
27623: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27627: LD_EXP 59
27631: PPUSH
27632: LD_INT 9
27634: PPUSH
27635: LD_INT 2
27637: PPUSH
27638: CALL_OW 171
// wait ( 0 0$05 ) ;
27642: LD_INT 175
27644: PPUSH
27645: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27649: LD_EXP 59
27653: PPUSH
27654: CALL_OW 87
// DialogueOn ;
27658: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27662: LD_EXP 36
27666: PPUSH
27667: LD_STRING D16-JMM-1
27669: PPUSH
27670: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27674: LD_EXP 59
27678: PPUSH
27679: LD_STRING D16-Friend-1
27681: PPUSH
27682: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27686: LD_EXP 36
27690: PPUSH
27691: LD_STRING D16-JMM-2
27693: PPUSH
27694: CALL_OW 88
// DialogueOff ;
27698: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27702: LD_EXP 59
27706: PPUSH
27707: LD_INT 1
27709: PPUSH
27710: CALL_OW 235
// ComHold ( Friend ) ;
27714: LD_EXP 59
27718: PPUSH
27719: CALL_OW 140
// wait ( 0 0$20 ) ;
27723: LD_INT 700
27725: PPUSH
27726: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27730: LD_EXP 59
27734: PPUSH
27735: LD_INT 9
27737: PPUSH
27738: LD_INT 2
27740: PPUSH
27741: CALL_OW 297
27745: PUSH
27746: LD_INT 30
27748: LESS
27749: IFFALSE 27818
// begin SetSide ( Friend , 8 ) ;
27751: LD_EXP 59
27755: PPUSH
27756: LD_INT 8
27758: PPUSH
27759: CALL_OW 235
// if IsInUnit ( Friend ) then
27763: LD_EXP 59
27767: PPUSH
27768: CALL_OW 310
27772: IFFALSE 27783
// ComExitBuilding ( Friend ) ;
27774: LD_EXP 59
27778: PPUSH
27779: CALL_OW 122
// if IsDriver ( Friend ) then
27783: LD_EXP 59
27787: PPUSH
27788: CALL 104652 0 1
27792: IFFALSE 27803
// ComExitVehicle ( Friend ) ;
27794: LD_EXP 59
27798: PPUSH
27799: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27803: LD_EXP 59
27807: PPUSH
27808: LD_INT 9
27810: PPUSH
27811: LD_INT 2
27813: PPUSH
27814: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27818: LD_INT 1050
27820: PPUSH
27821: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27825: LD_INT 22
27827: PUSH
27828: LD_INT 1
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 34
27837: PUSH
27838: LD_INT 8
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PPUSH
27849: CALL_OW 69
27853: NOT
27854: IFFALSE 28176
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27856: LD_ADDR_VAR 0 3
27860: PUSH
27861: LD_INT 22
27863: PUSH
27864: LD_INT 1
27866: PUSH
27867: EMPTY
27868: LIST
27869: LIST
27870: PUSH
27871: LD_INT 26
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 3
27883: PUSH
27884: LD_INT 25
27886: PUSH
27887: LD_INT 12
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 25
27896: PUSH
27897: LD_INT 16
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: LIST
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: LIST
27913: PPUSH
27914: CALL_OW 69
27918: PUSH
27919: LD_EXP 36
27923: PUSH
27924: LD_EXP 38
27928: PUSH
27929: LD_EXP 52
27933: PUSH
27934: LD_EXP 39
27938: PUSH
27939: LD_EXP 40
27943: PUSH
27944: LD_EXP 41
27948: PUSH
27949: LD_EXP 42
27953: PUSH
27954: LD_EXP 43
27958: PUSH
27959: LD_EXP 44
27963: PUSH
27964: LD_EXP 45
27968: PUSH
27969: LD_EXP 46
27973: PUSH
27974: LD_EXP 47
27978: PUSH
27979: LD_EXP 48
27983: PUSH
27984: LD_EXP 49
27988: PUSH
27989: LD_EXP 50
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: DIFF
28011: ST_TO_ADDR
// DialogueOn ;
28012: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28016: LD_EXP 61
28020: PPUSH
28021: LD_STRING D16a-Pla-1
28023: PPUSH
28024: CALL_OW 94
// if Stevens then
28028: LD_EXP 38
28032: IFFALSE 28048
// Say ( Stevens , D16a-Huck-1 ) else
28034: LD_EXP 38
28038: PPUSH
28039: LD_STRING D16a-Huck-1
28041: PPUSH
28042: CALL_OW 88
28046: GO 28090
// if Baker then
28048: LD_EXP 52
28052: IFFALSE 28068
// Say ( Baker , D16a-Huck-1 ) else
28054: LD_EXP 52
28058: PPUSH
28059: LD_STRING D16a-Huck-1
28061: PPUSH
28062: CALL_OW 88
28066: GO 28090
// if tmp then
28068: LD_VAR 0 3
28072: IFFALSE 28090
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28074: LD_VAR 0 3
28078: PUSH
28079: LD_INT 1
28081: ARRAY
28082: PPUSH
28083: LD_STRING D16a-Sol1-1
28085: PPUSH
28086: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28090: LD_EXP 59
28094: PPUSH
28095: CALL_OW 255
28099: PUSH
28100: LD_INT 8
28102: EQUAL
28103: IFFALSE 28119
// Say ( JMM , D16a-JMM-1 ) else
28105: LD_EXP 36
28109: PPUSH
28110: LD_STRING D16a-JMM-1
28112: PPUSH
28113: CALL_OW 88
28117: GO 28155
// begin Say ( JMM , D16a-JMM-1a ) ;
28119: LD_EXP 36
28123: PPUSH
28124: LD_STRING D16a-JMM-1a
28126: PPUSH
28127: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28131: LD_EXP 59
28135: PPUSH
28136: LD_STRING D16a-Friend-1
28138: PPUSH
28139: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28143: LD_EXP 59
28147: PPUSH
28148: LD_INT 3
28150: PPUSH
28151: CALL_OW 235
// end ; DialogueOff ;
28155: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28159: LD_VAR 0 1
28163: PPUSH
28164: LD_INT 60
28166: PPUSH
28167: LD_INT 95
28169: PPUSH
28170: CALL_OW 116
// end else
28174: GO 28196
// begin DialogueOn ;
28176: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28180: LD_EXP 61
28184: PPUSH
28185: LD_STRING D16c-Pla-
28187: PPUSH
28188: CALL_OW 94
// DialogueOff ;
28192: CALL_OW 7
// end ; end else
28196: GO 28297
// begin wait ( 3 3$00 ) ;
28198: LD_INT 6300
28200: PPUSH
28201: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28205: LD_INT 22
28207: PUSH
28208: LD_INT 1
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 34
28217: PUSH
28218: LD_INT 8
28220: PUSH
28221: EMPTY
28222: LIST
28223: LIST
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PPUSH
28229: CALL_OW 69
28233: NOT
28234: IFFALSE 28277
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28236: LD_EXP 61
28240: PPUSH
28241: LD_STRING D16b-Pla-1
28243: PPUSH
28244: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28248: LD_EXP 36
28252: PPUSH
28253: LD_STRING D16b-JMM-
28255: PPUSH
28256: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28260: LD_VAR 0 1
28264: PPUSH
28265: LD_INT 60
28267: PPUSH
28268: LD_INT 95
28270: PPUSH
28271: CALL_OW 116
// end else
28275: GO 28297
// begin DialogueOn ;
28277: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28281: LD_EXP 61
28285: PPUSH
28286: LD_STRING D16c-Pla-
28288: PPUSH
28289: CALL_OW 94
// DialogueOff ;
28293: CALL_OW 7
// end ; end ; end ;
28297: PPOPN 3
28299: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28300: LD_EXP 14
28304: PUSH
28305: LD_INT 126000
28307: GREATEREQUAL
28308: PUSH
28309: LD_EXP 23
28313: NOT
28314: AND
28315: PUSH
28316: LD_EXP 71
28320: PPUSH
28321: CALL_OW 302
28325: AND
28326: IFFALSE 28684
28328: GO 28330
28330: DISABLE
28331: LD_INT 0
28333: PPUSH
// begin missionStage = 11 ;
28334: LD_ADDR_EXP 15
28338: PUSH
28339: LD_INT 11
28341: ST_TO_ADDR
// DialogueOn ;
28342: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28346: LD_EXP 71
28350: PPUSH
28351: LD_STRING D9-Roth-1
28353: PPUSH
28354: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28358: LD_EXP 36
28362: PPUSH
28363: LD_STRING D9-JMM-1
28365: PPUSH
28366: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28370: LD_EXP 71
28374: PPUSH
28375: LD_STRING D9-Roth-2
28377: PPUSH
28378: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28382: LD_EXP 71
28386: PPUSH
28387: LD_STRING D9-Roth-2a
28389: PPUSH
28390: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28394: LD_EXP 61
28398: PPUSH
28399: LD_STRING D9-Pla-2
28401: PPUSH
28402: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28406: LD_EXP 71
28410: PPUSH
28411: LD_STRING D9-Roth-3
28413: PPUSH
28414: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28418: LD_EXP 61
28422: PPUSH
28423: LD_STRING D9-Pla-3
28425: PPUSH
28426: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28430: LD_EXP 71
28434: PPUSH
28435: LD_STRING D9-Roth-4
28437: PPUSH
28438: CALL_OW 94
// dec = Query ( Q9 ) ;
28442: LD_ADDR_VAR 0 1
28446: PUSH
28447: LD_STRING Q9
28449: PPUSH
28450: CALL_OW 97
28454: ST_TO_ADDR
// if dec = 1 then
28455: LD_VAR 0 1
28459: PUSH
28460: LD_INT 1
28462: EQUAL
28463: IFFALSE 28477
// SayRadio ( Roth , D9a-Roth-1 ) ;
28465: LD_EXP 71
28469: PPUSH
28470: LD_STRING D9a-Roth-1
28472: PPUSH
28473: CALL_OW 94
// if dec = 2 then
28477: LD_VAR 0 1
28481: PUSH
28482: LD_INT 2
28484: EQUAL
28485: IFFALSE 28511
// begin Say ( JMM , D9b-JMM-1 ) ;
28487: LD_EXP 36
28491: PPUSH
28492: LD_STRING D9b-JMM-1
28494: PPUSH
28495: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28499: LD_EXP 71
28503: PPUSH
28504: LD_STRING D9b-Roth-1
28506: PPUSH
28507: CALL_OW 94
// end ; if dec = 3 then
28511: LD_VAR 0 1
28515: PUSH
28516: LD_INT 3
28518: EQUAL
28519: IFFALSE 28581
// begin Say ( JMM , D9c-JMM-1 ) ;
28521: LD_EXP 36
28525: PPUSH
28526: LD_STRING D9c-JMM-1
28528: PPUSH
28529: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28533: LD_EXP 71
28537: PPUSH
28538: LD_STRING D9c-Roth-1
28540: PPUSH
28541: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28545: LD_EXP 36
28549: PPUSH
28550: LD_STRING D9c-JMM-2
28552: PPUSH
28553: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28557: LD_EXP 71
28561: PPUSH
28562: LD_STRING D9c-Roth-2
28564: PPUSH
28565: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28569: LD_EXP 36
28573: PPUSH
28574: LD_STRING D9c-JMM-3
28576: PPUSH
28577: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28581: LD_EXP 71
28585: PPUSH
28586: LD_STRING D9c-Roth-3
28588: PPUSH
28589: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28593: LD_EXP 71
28597: PPUSH
28598: LD_STRING D9cont-Roth-1
28600: PPUSH
28601: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28605: LD_EXP 36
28609: PPUSH
28610: LD_STRING D9cont-JMM-1
28612: PPUSH
28613: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28617: LD_EXP 71
28621: PPUSH
28622: LD_STRING D9cont-Roth-2
28624: PPUSH
28625: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28629: LD_EXP 36
28633: PPUSH
28634: LD_STRING D9cont-JMM-2
28636: PPUSH
28637: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28641: LD_EXP 71
28645: PPUSH
28646: LD_STRING D9cont-Roth-3
28648: PPUSH
28649: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28653: LD_EXP 36
28657: PPUSH
28658: LD_STRING D9cont-JMM-3
28660: PPUSH
28661: CALL_OW 88
// DialogueOff ;
28665: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28669: LD_STRING M3
28671: PPUSH
28672: CALL_OW 337
// allianceActive := true ;
28676: LD_ADDR_EXP 31
28680: PUSH
28681: LD_INT 1
28683: ST_TO_ADDR
// end ;
28684: PPOPN 1
28686: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28687: LD_EXP 61
28691: PPUSH
28692: CALL_OW 301
28696: PUSH
28697: LD_EXP 64
28701: PPUSH
28702: CALL_OW 301
28706: AND
28707: PUSH
28708: LD_INT 22
28710: PUSH
28711: LD_INT 3
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 21
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 50
28730: PUSH
28731: EMPTY
28732: LIST
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: PUSH
28744: LD_INT 7
28746: PUSH
28747: LD_INT 8
28749: PUSH
28750: LD_INT 9
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: LIST
28757: PUSH
28758: LD_OWVAR 67
28762: ARRAY
28763: LESS
28764: AND
28765: IFFALSE 29536
28767: GO 28769
28769: DISABLE
28770: LD_INT 0
28772: PPUSH
28773: PPUSH
28774: PPUSH
28775: PPUSH
// begin MC_Kill ( 1 ) ;
28776: LD_INT 1
28778: PPUSH
28779: CALL 34159 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28783: LD_INT 1
28785: PPUSH
28786: LD_INT 3
28788: PPUSH
28789: LD_INT 1
28791: PPUSH
28792: LD_INT 1
28794: PPUSH
28795: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28799: LD_ADDR_VAR 0 1
28803: PUSH
28804: LD_INT 22
28806: PUSH
28807: LD_INT 3
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 21
28816: PUSH
28817: LD_INT 1
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 24
28826: PUSH
28827: LD_INT 900
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: LIST
28838: PPUSH
28839: CALL_OW 69
28843: PUSH
28844: FOR_IN
28845: IFFALSE 28876
// if GetSex ( i ) = sex_male then
28847: LD_VAR 0 1
28851: PPUSH
28852: CALL_OW 258
28856: PUSH
28857: LD_INT 1
28859: EQUAL
28860: IFFALSE 28874
// begin tmp = i ;
28862: LD_ADDR_VAR 0 2
28866: PUSH
28867: LD_VAR 0 1
28871: ST_TO_ADDR
// break ;
28872: GO 28876
// end ;
28874: GO 28844
28876: POP
28877: POP
// if tmp = 0 then
28878: LD_VAR 0 2
28882: PUSH
28883: LD_INT 0
28885: EQUAL
28886: IFFALSE 28940
// begin uc_side = 3 ;
28888: LD_ADDR_OWVAR 20
28892: PUSH
28893: LD_INT 3
28895: ST_TO_ADDR
// uc_nation = 3 ;
28896: LD_ADDR_OWVAR 21
28900: PUSH
28901: LD_INT 3
28903: ST_TO_ADDR
// hc_name =  ;
28904: LD_ADDR_OWVAR 26
28908: PUSH
28909: LD_STRING 
28911: ST_TO_ADDR
// hc_gallery =  ;
28912: LD_ADDR_OWVAR 33
28916: PUSH
28917: LD_STRING 
28919: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28920: LD_INT 1
28922: PPUSH
28923: LD_INT 10
28925: PPUSH
28926: CALL_OW 381
// tmp = CreateHuman ;
28930: LD_ADDR_VAR 0 2
28934: PUSH
28935: CALL_OW 44
28939: ST_TO_ADDR
// end ; DialogueOn ;
28940: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28944: LD_VAR 0 2
28948: PPUSH
28949: LD_STRING DSurrenderRussians-RSol1-1a
28951: PPUSH
28952: CALL_OW 88
// DialogueOff ;
28956: CALL_OW 7
// russianDestroyed := true ;
28960: LD_ADDR_EXP 21
28964: PUSH
28965: LD_INT 1
28967: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28968: LD_INT 22
28970: PUSH
28971: LD_INT 3
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 21
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PPUSH
28992: CALL_OW 69
28996: PPUSH
28997: CALL_OW 122
// wait ( 0 0$1 ) ;
29001: LD_INT 35
29003: PPUSH
29004: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29008: LD_INT 22
29010: PUSH
29011: LD_INT 3
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 21
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: PPUSH
29032: CALL_OW 69
29036: PPUSH
29037: LD_INT 25
29039: PPUSH
29040: CALL_OW 173
// wait ( 0 0$10 ) ;
29044: LD_INT 350
29046: PPUSH
29047: CALL_OW 67
// PrepareOmarInvasion ;
29051: CALL 13710 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29055: LD_ADDR_VAR 0 2
29059: PUSH
29060: LD_EXP 89
29064: PPUSH
29065: CALL_OW 250
29069: PUSH
29070: LD_EXP 89
29074: PPUSH
29075: CALL_OW 251
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29084: LD_VAR 0 2
29088: PUSH
29089: LD_INT 1
29091: ARRAY
29092: PPUSH
29093: LD_VAR 0 2
29097: PUSH
29098: LD_INT 2
29100: ARRAY
29101: PPUSH
29102: LD_INT 1
29104: PPUSH
29105: LD_INT 8
29107: NEG
29108: PPUSH
29109: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29113: LD_EXP 89
29117: PPUSH
29118: CALL_OW 87
// DialogueOn ;
29122: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29126: LD_EXP 36
29130: PPUSH
29131: LD_STRING D19-JMM-1
29133: PPUSH
29134: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29138: LD_ADDR_VAR 0 3
29142: PUSH
29143: LD_INT 22
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 26
29155: PUSH
29156: LD_INT 1
29158: PUSH
29159: EMPTY
29160: LIST
29161: LIST
29162: PUSH
29163: LD_INT 2
29165: PUSH
29166: LD_INT 25
29168: PUSH
29169: LD_INT 1
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 25
29178: PUSH
29179: LD_INT 2
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 25
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 25
29198: PUSH
29199: LD_INT 4
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 25
29208: PUSH
29209: LD_INT 5
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 25
29218: PUSH
29219: LD_INT 8
29221: PUSH
29222: EMPTY
29223: LIST
29224: LIST
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: LIST
29239: PPUSH
29240: CALL_OW 69
29244: PUSH
29245: LD_EXP 36
29249: PUSH
29250: LD_EXP 37
29254: PUSH
29255: LD_EXP 38
29259: PUSH
29260: LD_EXP 39
29264: PUSH
29265: LD_EXP 40
29269: PUSH
29270: LD_EXP 41
29274: PUSH
29275: LD_EXP 42
29279: PUSH
29280: LD_EXP 43
29284: PUSH
29285: LD_EXP 44
29289: PUSH
29290: LD_EXP 45
29294: PUSH
29295: LD_EXP 46
29299: PUSH
29300: LD_EXP 47
29304: PUSH
29305: LD_EXP 48
29309: PUSH
29310: LD_EXP 49
29314: PUSH
29315: LD_EXP 50
29319: PUSH
29320: LD_EXP 51
29324: PUSH
29325: LD_EXP 52
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: LIST
29336: LIST
29337: LIST
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: LIST
29345: LIST
29346: LIST
29347: LIST
29348: DIFF
29349: ST_TO_ADDR
// if tmp2 then
29350: LD_VAR 0 3
29354: IFFALSE 29372
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29356: LD_VAR 0 3
29360: PUSH
29361: LD_INT 1
29363: ARRAY
29364: PPUSH
29365: LD_STRING D19-Sol1-1
29367: PPUSH
29368: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29372: LD_EXP 36
29376: PPUSH
29377: LD_STRING D19-JMM-2
29379: PPUSH
29380: CALL_OW 88
// DialogueOff ;
29384: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29388: LD_VAR 0 2
29392: PUSH
29393: LD_INT 1
29395: ARRAY
29396: PPUSH
29397: LD_VAR 0 2
29401: PUSH
29402: LD_INT 2
29404: ARRAY
29405: PPUSH
29406: LD_INT 1
29408: PPUSH
29409: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29413: LD_STRING M5
29415: PPUSH
29416: CALL_OW 337
// omarOnMotherLode := false ;
29420: LD_ADDR_VAR 0 4
29424: PUSH
29425: LD_INT 0
29427: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29428: LD_INT 35
29430: PPUSH
29431: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29435: LD_EXP 89
29439: PPUSH
29440: LD_INT 215
29442: PPUSH
29443: LD_INT 100
29445: PPUSH
29446: CALL_OW 297
29450: PUSH
29451: LD_INT 10
29453: LESS
29454: PUSH
29455: LD_VAR 0 4
29459: NOT
29460: AND
29461: IFFALSE 29495
// begin omarOnMotherLode := true ;
29463: LD_ADDR_VAR 0 4
29467: PUSH
29468: LD_INT 1
29470: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29471: LD_EXP 36
29475: PPUSH
29476: LD_STRING D19b-JMM-1
29478: PPUSH
29479: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29483: LD_EXP 89
29487: PPUSH
29488: LD_STRING DOmarContam-Omar-1
29490: PPUSH
29491: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29495: LD_EXP 89
29499: PPUSH
29500: CALL_OW 301
29504: IFFALSE 29428
// Say ( JMM , D19a-JMM-1 ) ;
29506: LD_EXP 36
29510: PPUSH
29511: LD_STRING D19a-JMM-1
29513: PPUSH
29514: CALL_OW 88
// if Heike then
29518: LD_EXP 90
29522: IFFALSE 29536
// Say ( Heike , D19a-Hke-1 ) ;
29524: LD_EXP 90
29528: PPUSH
29529: LD_STRING D19a-Hke-1
29531: PPUSH
29532: CALL_OW 88
// end ;
29536: PPOPN 4
29538: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29539: LD_INT 22
29541: PUSH
29542: LD_INT 3
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 21
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PPUSH
29563: CALL_OW 69
29567: PUSH
29568: LD_EXP 21
29572: AND
29573: IFFALSE 29641
29575: GO 29577
29577: DISABLE
29578: LD_INT 0
29580: PPUSH
29581: PPUSH
// begin enable ;
29582: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29583: LD_ADDR_VAR 0 2
29587: PUSH
29588: LD_INT 25
29590: PPUSH
29591: LD_INT 22
29593: PUSH
29594: LD_INT 3
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PPUSH
29601: CALL_OW 70
29605: ST_TO_ADDR
// if not tmp then
29606: LD_VAR 0 2
29610: NOT
29611: IFFALSE 29615
// exit ;
29613: GO 29641
// for i in tmp do
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_VAR 0 2
29624: PUSH
29625: FOR_IN
29626: IFFALSE 29639
// RemoveUnit ( i ) ;
29628: LD_VAR 0 1
29632: PPUSH
29633: CALL_OW 64
29637: GO 29625
29639: POP
29640: POP
// end ;
29641: PPOPN 2
29643: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29644: LD_INT 22
29646: PUSH
29647: LD_INT 7
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 21
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: PPUSH
29668: CALL_OW 69
29672: PUSH
29673: LD_INT 6
29675: LESS
29676: IFFALSE 30127
29678: GO 29680
29680: DISABLE
29681: LD_INT 0
29683: PPUSH
29684: PPUSH
// begin MC_Kill ( 1 ) ;
29685: LD_INT 1
29687: PPUSH
29688: CALL 34159 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29692: LD_INT 7
29694: PPUSH
29695: LD_INT 1
29697: PPUSH
29698: LD_INT 1
29700: PPUSH
29701: LD_INT 1
29703: PPUSH
29704: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29708: LD_ADDR_VAR 0 1
29712: PUSH
29713: LD_INT 22
29715: PUSH
29716: LD_INT 7
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 26
29725: PUSH
29726: LD_INT 1
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: EMPTY
29734: LIST
29735: LIST
29736: PPUSH
29737: CALL_OW 69
29741: PUSH
29742: LD_EXP 71
29746: DIFF
29747: ST_TO_ADDR
// if tmp then
29748: LD_VAR 0 1
29752: IFFALSE 29770
// tmp := tmp [ 1 ] else
29754: LD_ADDR_VAR 0 1
29758: PUSH
29759: LD_VAR 0 1
29763: PUSH
29764: LD_INT 1
29766: ARRAY
29767: ST_TO_ADDR
29768: GO 29806
// begin uc_side := 7 ;
29770: LD_ADDR_OWVAR 20
29774: PUSH
29775: LD_INT 7
29777: ST_TO_ADDR
// uc_nation := 1 ;
29778: LD_ADDR_OWVAR 21
29782: PUSH
29783: LD_INT 1
29785: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29786: LD_INT 1
29788: PPUSH
29789: LD_INT 8
29791: PPUSH
29792: CALL_OW 384
// tmp := CreateHuman ;
29796: LD_ADDR_VAR 0 1
29800: PUSH
29801: CALL_OW 44
29805: ST_TO_ADDR
// end ; DialogueOn ;
29806: CALL_OW 6
// if IsOK ( Roth ) then
29810: LD_EXP 71
29814: PPUSH
29815: CALL_OW 302
29819: IFFALSE 29833
// Say ( JMM , DAb-JMM-1 ) ;
29821: LD_EXP 36
29825: PPUSH
29826: LD_STRING DAb-JMM-1
29828: PPUSH
29829: CALL_OW 88
// if IsOK ( Roth ) then
29833: LD_EXP 71
29837: PPUSH
29838: CALL_OW 302
29842: IFFALSE 29866
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29844: LD_EXP 71
29848: PPUSH
29849: LD_STRING DSurrenderAlliance-Roth-1
29851: PPUSH
29852: CALL_OW 88
// RothCaptured := true ;
29856: LD_ADDR_EXP 33
29860: PUSH
29861: LD_INT 1
29863: ST_TO_ADDR
// end else
29864: GO 29878
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29866: LD_VAR 0 1
29870: PPUSH
29871: LD_STRING DSurrenderAlliance-Sci1-1
29873: PPUSH
29874: CALL_OW 88
// DialogueOff ;
29878: CALL_OW 7
// allianceDestroyed := true ;
29882: LD_ADDR_EXP 23
29886: PUSH
29887: LD_INT 1
29889: ST_TO_ADDR
// if trueAmericans then
29890: LD_EXP 35
29894: IFFALSE 29970
// begin if trueAmericans = 1 then
29896: LD_EXP 35
29900: PUSH
29901: LD_INT 1
29903: EQUAL
29904: IFFALSE 29920
// Say ( JMM , DAb-JMM-1a ) else
29906: LD_EXP 36
29910: PPUSH
29911: LD_STRING DAb-JMM-1a
29913: PPUSH
29914: CALL_OW 88
29918: GO 29932
// Say ( JMM , DAb-JMM-1b ) ;
29920: LD_EXP 36
29924: PPUSH
29925: LD_STRING DAb-JMM-1b
29927: PPUSH
29928: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29932: LD_EXP 35
29936: PPUSH
29937: CALL_OW 87
// for i in trueAmericans do
29941: LD_ADDR_VAR 0 2
29945: PUSH
29946: LD_EXP 35
29950: PUSH
29951: FOR_IN
29952: IFFALSE 29968
// SetSide ( i , 1 ) ;
29954: LD_VAR 0 2
29958: PPUSH
29959: LD_INT 1
29961: PPUSH
29962: CALL_OW 235
29966: GO 29951
29968: POP
29969: POP
// end ; repeat wait ( 0 0$1 ) ;
29970: LD_INT 35
29972: PPUSH
29973: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29977: LD_ADDR_VAR 0 2
29981: PUSH
29982: LD_INT 22
29984: PUSH
29985: LD_INT 7
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 21
29994: PUSH
29995: LD_INT 1
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PPUSH
30006: CALL_OW 69
30010: PUSH
30011: FOR_IN
30012: IFFALSE 30094
// begin if IsInUnit ( i ) then
30014: LD_VAR 0 2
30018: PPUSH
30019: CALL_OW 310
30023: IFFALSE 30034
// ComExitBuilding ( i ) ;
30025: LD_VAR 0 2
30029: PPUSH
30030: CALL_OW 122
// if IsDriver ( i ) then
30034: LD_VAR 0 2
30038: PPUSH
30039: CALL 104652 0 1
30043: IFFALSE 30054
// ComExitVehicle ( i ) ;
30045: LD_VAR 0 2
30049: PPUSH
30050: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30054: LD_VAR 0 2
30058: PPUSH
30059: LD_INT 26
30061: PPUSH
30062: CALL_OW 308
30066: NOT
30067: IFFALSE 30083
// AddComMoveToArea ( i , allianceEscapeArea ) else
30069: LD_VAR 0 2
30073: PPUSH
30074: LD_INT 26
30076: PPUSH
30077: CALL_OW 173
30081: GO 30092
// RemoveUnit ( i ) ;
30083: LD_VAR 0 2
30087: PPUSH
30088: CALL_OW 64
// end ;
30092: GO 30011
30094: POP
30095: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30096: LD_INT 22
30098: PUSH
30099: LD_INT 7
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 21
30108: PUSH
30109: LD_INT 1
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PPUSH
30120: CALL_OW 69
30124: NOT
30125: IFFALSE 29970
// end ;
30127: PPOPN 2
30129: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30130: LD_INT 0
30132: PPUSH
30133: PPUSH
// if not unit then
30134: LD_VAR 0 1
30138: NOT
30139: IFFALSE 30143
// exit ;
30141: GO 31641
// DoNotAttack ( 7 , unit ) ;
30143: LD_INT 7
30145: PPUSH
30146: LD_VAR 0 1
30150: PPUSH
30151: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30155: LD_VAR 0 1
30159: PPUSH
30160: LD_INT 260
30162: PPUSH
30163: LD_INT 235
30165: PPUSH
30166: LD_INT 3
30168: PPUSH
30169: LD_INT 1
30171: PPUSH
30172: CALL_OW 483
// SetSide ( unit , 4 ) ;
30176: LD_VAR 0 1
30180: PPUSH
30181: LD_INT 4
30183: PPUSH
30184: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30188: LD_ADDR_EXP 34
30192: PUSH
30193: LD_EXP 34
30197: PUSH
30198: LD_INT 1
30200: PLUS
30201: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30202: LD_INT 70
30204: PPUSH
30205: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30209: LD_INT 260
30211: PPUSH
30212: LD_INT 235
30214: PPUSH
30215: LD_INT 1
30217: PPUSH
30218: LD_INT 8
30220: NEG
30221: PPUSH
30222: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30226: LD_VAR 0 1
30230: PPUSH
30231: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30235: LD_VAR 0 1
30239: PPUSH
30240: LD_EXP 71
30244: PPUSH
30245: CALL_OW 119
// DialogueOn ;
30249: CALL_OW 6
// case unit of JMM :
30253: LD_VAR 0 1
30257: PUSH
30258: LD_EXP 36
30262: DOUBLE
30263: EQUAL
30264: IFTRUE 30268
30266: GO 30283
30268: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30269: LD_EXP 36
30273: PPUSH
30274: LD_STRING DA1-JMM-1
30276: PPUSH
30277: CALL_OW 91
30281: GO 30725
30283: LD_EXP 37
30287: DOUBLE
30288: EQUAL
30289: IFTRUE 30293
30291: GO 30308
30293: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30294: LD_EXP 37
30298: PPUSH
30299: LD_STRING DA1-Joan-1
30301: PPUSH
30302: CALL_OW 91
30306: GO 30725
30308: LD_EXP 39
30312: DOUBLE
30313: EQUAL
30314: IFTRUE 30318
30316: GO 30333
30318: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30319: LD_EXP 39
30323: PPUSH
30324: LD_STRING DA1-Lisa-1
30326: PPUSH
30327: CALL_OW 91
30331: GO 30725
30333: LD_EXP 40
30337: DOUBLE
30338: EQUAL
30339: IFTRUE 30343
30341: GO 30358
30343: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30344: LD_EXP 40
30348: PPUSH
30349: LD_STRING DA1-Don-1
30351: PPUSH
30352: CALL_OW 91
30356: GO 30725
30358: LD_EXP 47
30362: DOUBLE
30363: EQUAL
30364: IFTRUE 30368
30366: GO 30383
30368: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30369: LD_EXP 47
30373: PPUSH
30374: LD_STRING DA1-Corn-1
30376: PPUSH
30377: CALL_OW 91
30381: GO 30725
30383: LD_EXP 43
30387: DOUBLE
30388: EQUAL
30389: IFTRUE 30393
30391: GO 30408
30393: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30394: LD_EXP 43
30398: PPUSH
30399: LD_STRING DA1-Den-1
30401: PPUSH
30402: CALL_OW 91
30406: GO 30725
30408: LD_EXP 41
30412: DOUBLE
30413: EQUAL
30414: IFTRUE 30418
30416: GO 30433
30418: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30419: LD_EXP 41
30423: PPUSH
30424: LD_STRING DA1-Bobby-1
30426: PPUSH
30427: CALL_OW 91
30431: GO 30725
30433: LD_EXP 45
30437: DOUBLE
30438: EQUAL
30439: IFTRUE 30443
30441: GO 30458
30443: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30444: LD_EXP 45
30448: PPUSH
30449: LD_STRING DA1-Glad-1
30451: PPUSH
30452: CALL_OW 91
30456: GO 30725
30458: LD_EXP 42
30462: DOUBLE
30463: EQUAL
30464: IFTRUE 30468
30466: GO 30483
30468: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30469: LD_EXP 42
30473: PPUSH
30474: LD_STRING DA1-Cyrus-1
30476: PPUSH
30477: CALL_OW 91
30481: GO 30725
30483: LD_EXP 38
30487: DOUBLE
30488: EQUAL
30489: IFTRUE 30493
30491: GO 30508
30493: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30494: LD_EXP 38
30498: PPUSH
30499: LD_STRING DA1-Huck-1
30501: PPUSH
30502: CALL_OW 91
30506: GO 30725
30508: LD_EXP 52
30512: DOUBLE
30513: EQUAL
30514: IFTRUE 30518
30516: GO 30533
30518: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30519: LD_EXP 52
30523: PPUSH
30524: LD_STRING DA1-Huck-1
30526: PPUSH
30527: CALL_OW 91
30531: GO 30725
30533: LD_EXP 44
30537: DOUBLE
30538: EQUAL
30539: IFTRUE 30543
30541: GO 30558
30543: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30544: LD_EXP 44
30548: PPUSH
30549: LD_STRING DA1-Brown-1
30551: PPUSH
30552: CALL_OW 91
30556: GO 30725
30558: LD_EXP 48
30562: DOUBLE
30563: EQUAL
30564: IFTRUE 30568
30566: GO 30583
30568: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30569: LD_EXP 48
30573: PPUSH
30574: LD_STRING DA1-Gary-1
30576: PPUSH
30577: CALL_OW 91
30581: GO 30725
30583: LD_EXP 51
30587: DOUBLE
30588: EQUAL
30589: IFTRUE 30593
30591: GO 30608
30593: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30594: LD_EXP 51
30598: PPUSH
30599: LD_STRING DA1-Con-1
30601: PPUSH
30602: CALL_OW 91
30606: GO 30725
30608: LD_EXP 57
30612: DOUBLE
30613: EQUAL
30614: IFTRUE 30618
30616: GO 30633
30618: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30619: LD_EXP 57
30623: PPUSH
30624: LD_STRING DA1-Kurt-1
30626: PPUSH
30627: CALL_OW 91
30631: GO 30725
30633: LD_EXP 50
30637: DOUBLE
30638: EQUAL
30639: IFTRUE 30643
30641: GO 30658
30643: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30644: LD_EXP 50
30648: PPUSH
30649: LD_STRING DA1-Yam-1
30651: PPUSH
30652: CALL_OW 91
30656: GO 30725
30658: LD_EXP 49
30662: DOUBLE
30663: EQUAL
30664: IFTRUE 30668
30666: GO 30683
30668: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30669: LD_EXP 49
30673: PPUSH
30674: LD_STRING DA1-Frank-1
30676: PPUSH
30677: CALL_OW 91
30681: GO 30725
30683: POP
// begin if GetSex ( unit ) = sex_male then
30684: LD_VAR 0 1
30688: PPUSH
30689: CALL_OW 258
30693: PUSH
30694: LD_INT 1
30696: EQUAL
30697: IFFALSE 30713
// ForceSay ( unit , DA1-Sol1-1 ) else
30699: LD_VAR 0 1
30703: PPUSH
30704: LD_STRING DA1-Sol1-1
30706: PPUSH
30707: CALL_OW 91
30711: GO 30725
// ForceSay ( unit , DA1-FSol1-1 ) ;
30713: LD_VAR 0 1
30717: PPUSH
30718: LD_STRING DA1-FSol1-1
30720: PPUSH
30721: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30725: LD_EXP 71
30729: PPUSH
30730: LD_STRING DA-Roth-1
30732: PPUSH
30733: CALL_OW 88
// if capturedUnit = 1 then
30737: LD_EXP 34
30741: PUSH
30742: LD_INT 1
30744: EQUAL
30745: IFFALSE 30773
// begin Say ( Simms , DA-Sim-1 ) ;
30747: LD_EXP 72
30751: PPUSH
30752: LD_STRING DA-Sim-1
30754: PPUSH
30755: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30759: LD_EXP 71
30763: PPUSH
30764: LD_STRING DA-Roth-2
30766: PPUSH
30767: CALL_OW 88
// end else
30771: GO 30785
// Say ( Simms , DA-Sim-2 ) ;
30773: LD_EXP 72
30777: PPUSH
30778: LD_STRING DA-Sim-2
30780: PPUSH
30781: CALL_OW 88
// case unit of JMM :
30785: LD_VAR 0 1
30789: PUSH
30790: LD_EXP 36
30794: DOUBLE
30795: EQUAL
30796: IFTRUE 30800
30798: GO 30815
30800: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30801: LD_EXP 36
30805: PPUSH
30806: LD_STRING DA1-JMM-1a
30808: PPUSH
30809: CALL_OW 91
30813: GO 31322
30815: LD_EXP 37
30819: DOUBLE
30820: EQUAL
30821: IFTRUE 30825
30823: GO 30840
30825: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30826: LD_EXP 37
30830: PPUSH
30831: LD_STRING DA1-Joan-1a
30833: PPUSH
30834: CALL_OW 91
30838: GO 31322
30840: LD_EXP 39
30844: DOUBLE
30845: EQUAL
30846: IFTRUE 30850
30848: GO 30865
30850: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30851: LD_EXP 39
30855: PPUSH
30856: LD_STRING DA1-Lisa-1a
30858: PPUSH
30859: CALL_OW 91
30863: GO 31322
30865: LD_EXP 40
30869: DOUBLE
30870: EQUAL
30871: IFTRUE 30875
30873: GO 30890
30875: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30876: LD_EXP 40
30880: PPUSH
30881: LD_STRING DA1-Don-1a
30883: PPUSH
30884: CALL_OW 91
30888: GO 31322
30890: LD_EXP 47
30894: DOUBLE
30895: EQUAL
30896: IFTRUE 30900
30898: GO 30915
30900: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30901: LD_EXP 47
30905: PPUSH
30906: LD_STRING DA1-Corn-1a
30908: PPUSH
30909: CALL_OW 91
30913: GO 31322
30915: LD_EXP 43
30919: DOUBLE
30920: EQUAL
30921: IFTRUE 30925
30923: GO 30940
30925: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30926: LD_EXP 43
30930: PPUSH
30931: LD_STRING DA1-Den-1a
30933: PPUSH
30934: CALL_OW 91
30938: GO 31322
30940: LD_EXP 41
30944: DOUBLE
30945: EQUAL
30946: IFTRUE 30950
30948: GO 30965
30950: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30951: LD_EXP 41
30955: PPUSH
30956: LD_STRING DA1-Bobby-1a
30958: PPUSH
30959: CALL_OW 91
30963: GO 31322
30965: LD_EXP 45
30969: DOUBLE
30970: EQUAL
30971: IFTRUE 30975
30973: GO 30990
30975: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30976: LD_EXP 45
30980: PPUSH
30981: LD_STRING DA1-Glad-1a
30983: PPUSH
30984: CALL_OW 91
30988: GO 31322
30990: LD_EXP 42
30994: DOUBLE
30995: EQUAL
30996: IFTRUE 31000
30998: GO 31015
31000: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31001: LD_EXP 42
31005: PPUSH
31006: LD_STRING DA1-Cyrus-1a
31008: PPUSH
31009: CALL_OW 91
31013: GO 31322
31015: LD_EXP 38
31019: DOUBLE
31020: EQUAL
31021: IFTRUE 31025
31023: GO 31040
31025: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31026: LD_EXP 38
31030: PPUSH
31031: LD_STRING DA1-Huck-1a
31033: PPUSH
31034: CALL_OW 91
31038: GO 31322
31040: LD_EXP 52
31044: DOUBLE
31045: EQUAL
31046: IFTRUE 31050
31048: GO 31065
31050: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31051: LD_EXP 52
31055: PPUSH
31056: LD_STRING DA1-Huck-1a
31058: PPUSH
31059: CALL_OW 91
31063: GO 31322
31065: LD_EXP 44
31069: DOUBLE
31070: EQUAL
31071: IFTRUE 31075
31073: GO 31090
31075: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31076: LD_EXP 44
31080: PPUSH
31081: LD_STRING DA1-Brown-1a
31083: PPUSH
31084: CALL_OW 91
31088: GO 31322
31090: LD_EXP 48
31094: DOUBLE
31095: EQUAL
31096: IFTRUE 31100
31098: GO 31115
31100: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31101: LD_EXP 48
31105: PPUSH
31106: LD_STRING DA1-Gary-1a
31108: PPUSH
31109: CALL_OW 91
31113: GO 31322
31115: LD_EXP 51
31119: DOUBLE
31120: EQUAL
31121: IFTRUE 31125
31123: GO 31140
31125: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31126: LD_EXP 51
31130: PPUSH
31131: LD_STRING DA1-Con-1a
31133: PPUSH
31134: CALL_OW 91
31138: GO 31322
31140: LD_EXP 57
31144: DOUBLE
31145: EQUAL
31146: IFTRUE 31150
31148: GO 31165
31150: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31151: LD_EXP 57
31155: PPUSH
31156: LD_STRING DA1-Kurt-1a
31158: PPUSH
31159: CALL_OW 91
31163: GO 31322
31165: LD_EXP 50
31169: DOUBLE
31170: EQUAL
31171: IFTRUE 31175
31173: GO 31190
31175: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31176: LD_EXP 50
31180: PPUSH
31181: LD_STRING DA1-Yam-1a
31183: PPUSH
31184: CALL_OW 91
31188: GO 31322
31190: LD_EXP 49
31194: DOUBLE
31195: EQUAL
31196: IFTRUE 31200
31198: GO 31215
31200: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31201: LD_EXP 49
31205: PPUSH
31206: LD_STRING DA1-Frank-1a
31208: PPUSH
31209: CALL_OW 91
31213: GO 31322
31215: POP
// begin join := rand ( 0 , 1 ) ;
31216: LD_ADDR_VAR 0 3
31220: PUSH
31221: LD_INT 0
31223: PPUSH
31224: LD_INT 1
31226: PPUSH
31227: CALL_OW 12
31231: ST_TO_ADDR
// if join then
31232: LD_VAR 0 3
31236: IFFALSE 31281
// begin if GetSex ( unit ) = sex_male then
31238: LD_VAR 0 1
31242: PPUSH
31243: CALL_OW 258
31247: PUSH
31248: LD_INT 1
31250: EQUAL
31251: IFFALSE 31267
// ForceSay ( unit , DA1-Sol1-1b ) else
31253: LD_VAR 0 1
31257: PPUSH
31258: LD_STRING DA1-Sol1-1b
31260: PPUSH
31261: CALL_OW 91
31265: GO 31279
// ForceSay ( unit , DA1-FSol1-1b ) ;
31267: LD_VAR 0 1
31271: PPUSH
31272: LD_STRING DA1-FSol1-1b
31274: PPUSH
31275: CALL_OW 91
// end else
31279: GO 31322
// begin if GetSex ( unit ) = sex_male then
31281: LD_VAR 0 1
31285: PPUSH
31286: CALL_OW 258
31290: PUSH
31291: LD_INT 1
31293: EQUAL
31294: IFFALSE 31310
// ForceSay ( unit , DA1-Sol1-1a ) else
31296: LD_VAR 0 1
31300: PPUSH
31301: LD_STRING DA1-Sol1-1a
31303: PPUSH
31304: CALL_OW 91
31308: GO 31322
// ForceSay ( unit , DA1-FSol1-1a ) ;
31310: LD_VAR 0 1
31314: PPUSH
31315: LD_STRING DA1-FSol1-1a
31317: PPUSH
31318: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31322: LD_VAR 0 1
31326: PUSH
31327: LD_EXP 36
31331: EQUAL
31332: IFFALSE 31343
// begin YouLost ( JMMCaptured ) ;
31334: LD_STRING JMMCaptured
31336: PPUSH
31337: CALL_OW 104
// exit ;
31341: GO 31641
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31343: LD_VAR 0 1
31347: PUSH
31348: LD_EXP 40
31352: PUSH
31353: LD_EXP 43
31357: PUSH
31358: LD_EXP 41
31362: PUSH
31363: LD_EXP 38
31367: PUSH
31368: LD_EXP 52
31372: PUSH
31373: LD_EXP 44
31377: PUSH
31378: LD_EXP 50
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: IN
31392: PUSH
31393: LD_VAR 0 3
31397: OR
31398: IFFALSE 31497
// begin Say ( Roth , DA-Roth-3 ) ;
31400: LD_EXP 71
31404: PPUSH
31405: LD_STRING DA-Roth-3
31407: PPUSH
31408: CALL_OW 88
// SetSide ( unit , 7 ) ;
31412: LD_VAR 0 1
31416: PPUSH
31417: LD_INT 7
31419: PPUSH
31420: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31424: LD_ADDR_EXP 99
31428: PUSH
31429: LD_EXP 99
31433: PPUSH
31434: LD_INT 1
31436: PPUSH
31437: LD_EXP 99
31441: PUSH
31442: LD_INT 1
31444: ARRAY
31445: PUSH
31446: LD_VAR 0 1
31450: ADD
31451: PPUSH
31452: CALL_OW 1
31456: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31457: LD_INT 260
31459: PPUSH
31460: LD_INT 235
31462: PPUSH
31463: LD_INT 1
31465: PPUSH
31466: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31470: LD_VAR 0 1
31474: PPUSH
31475: LD_INT 1000
31477: PPUSH
31478: CALL_OW 234
// DialogueOff ;
31482: CALL_OW 7
// ComFree ( unit ) ;
31486: LD_VAR 0 1
31490: PPUSH
31491: CALL_OW 139
// end else
31495: GO 31578
// begin Say ( Roth , DA-Roth-3a ) ;
31497: LD_EXP 71
31501: PPUSH
31502: LD_STRING DA-Roth-3a
31504: PPUSH
31505: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31509: LD_ADDR_EXP 35
31513: PUSH
31514: LD_EXP 35
31518: PUSH
31519: LD_VAR 0 1
31523: ADD
31524: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31525: LD_INT 260
31527: PPUSH
31528: LD_INT 235
31530: PPUSH
31531: LD_INT 1
31533: PPUSH
31534: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31538: LD_VAR 0 1
31542: PPUSH
31543: LD_INT 1000
31545: PPUSH
31546: CALL_OW 234
// DialogueOff ;
31550: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31554: LD_VAR 0 1
31558: PPUSH
31559: LD_INT 272
31561: PPUSH
31562: LD_INT 254
31564: PPUSH
31565: CALL_OW 111
// AddComHold ( unit ) ;
31569: LD_VAR 0 1
31573: PPUSH
31574: CALL_OW 200
// end ; if capturedUnit = 1 then
31578: LD_EXP 34
31582: PUSH
31583: LD_INT 1
31585: EQUAL
31586: IFFALSE 31641
// begin DialogueOn ;
31588: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31592: LD_EXP 36
31596: PPUSH
31597: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31601: LD_EXP 36
31605: PPUSH
31606: LD_STRING DAa-JMM-1
31608: PPUSH
31609: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31613: LD_EXP 36
31617: PPUSH
31618: LD_STRING DAa-JMM-1a
31620: PPUSH
31621: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31625: LD_EXP 36
31629: PPUSH
31630: LD_STRING DAa-JMM-1b
31632: PPUSH
31633: CALL_OW 88
// DialogueOff ;
31637: CALL_OW 7
// end ; end ;
31641: LD_VAR 0 2
31645: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31646: LD_EXP 15
31650: PUSH
31651: LD_INT 13
31653: GREATEREQUAL
31654: PUSH
31655: LD_INT 22
31657: PUSH
31658: LD_INT 2
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 21
31667: PUSH
31668: LD_INT 1
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PPUSH
31679: CALL_OW 69
31683: PUSH
31684: LD_INT 0
31686: EQUAL
31687: AND
31688: PUSH
31689: LD_INT 22
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 21
31701: PUSH
31702: LD_INT 2
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 50
31711: PUSH
31712: EMPTY
31713: LIST
31714: PUSH
31715: EMPTY
31716: LIST
31717: LIST
31718: LIST
31719: PPUSH
31720: CALL_OW 69
31724: PUSH
31725: LD_INT 0
31727: EQUAL
31728: AND
31729: PUSH
31730: LD_EXP 21
31734: AND
31735: PUSH
31736: LD_EXP 22
31740: AND
31741: PUSH
31742: LD_EXP 23
31746: AND
31747: IFFALSE 32351
31749: GO 31751
31751: DISABLE
31752: LD_INT 0
31754: PPUSH
31755: PPUSH
31756: PPUSH
// begin m1 := false ;
31757: LD_ADDR_VAR 0 1
31761: PUSH
31762: LD_INT 0
31764: ST_TO_ADDR
// m2 := false ;
31765: LD_ADDR_VAR 0 2
31769: PUSH
31770: LD_INT 0
31772: ST_TO_ADDR
// m3 := false ;
31773: LD_ADDR_VAR 0 3
31777: PUSH
31778: LD_INT 0
31780: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
31781: LD_EXP 36
31785: PPUSH
31786: CALL_OW 87
// music_class := 5 ;
31790: LD_ADDR_OWVAR 72
31794: PUSH
31795: LD_INT 5
31797: ST_TO_ADDR
// music_nat := 5 ;
31798: LD_ADDR_OWVAR 71
31802: PUSH
31803: LD_INT 5
31805: ST_TO_ADDR
// DialogueOn ;
31806: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31810: LD_EXP 36
31814: PPUSH
31815: LD_STRING D20-JMM-1
31817: PPUSH
31818: CALL_OW 88
// if IsOK ( Joan ) then
31822: LD_EXP 37
31826: PPUSH
31827: CALL_OW 302
31831: IFFALSE 31845
// Say ( Joan , D20-Joan-1 ) ;
31833: LD_EXP 37
31837: PPUSH
31838: LD_STRING D20-Joan-1
31840: PPUSH
31841: CALL_OW 88
// if IsOk ( Lisa ) then
31845: LD_EXP 39
31849: PPUSH
31850: CALL_OW 302
31854: IFFALSE 31868
// Say ( Lisa , D20-Lisa-1 ) ;
31856: LD_EXP 39
31860: PPUSH
31861: LD_STRING D20-Lisa-1
31863: PPUSH
31864: CALL_OW 88
// if IsOk ( Donaldson ) then
31868: LD_EXP 40
31872: PPUSH
31873: CALL_OW 302
31877: IFFALSE 31891
// Say ( Donaldson , D20-Don-1 ) ;
31879: LD_EXP 40
31883: PPUSH
31884: LD_STRING D20-Don-1
31886: PPUSH
31887: CALL_OW 88
// if IsOK ( Cornel ) then
31891: LD_EXP 47
31895: PPUSH
31896: CALL_OW 302
31900: IFFALSE 31914
// Say ( Cornel , D20-Corn-1 ) ;
31902: LD_EXP 47
31906: PPUSH
31907: LD_STRING D20-Corn-1
31909: PPUSH
31910: CALL_OW 88
// if IsOk ( Denis ) then
31914: LD_EXP 43
31918: PPUSH
31919: CALL_OW 302
31923: IFFALSE 31937
// Say ( Denis , D20-Den-1 ) ;
31925: LD_EXP 43
31929: PPUSH
31930: LD_STRING D20-Den-1
31932: PPUSH
31933: CALL_OW 88
// if IsOk ( Bobby ) then
31937: LD_EXP 41
31941: PPUSH
31942: CALL_OW 302
31946: IFFALSE 31960
// Say ( Bobby , D20-Bobby-1 ) ;
31948: LD_EXP 41
31952: PPUSH
31953: LD_STRING D20-Bobby-1
31955: PPUSH
31956: CALL_OW 88
// if IsOk ( Gladstone ) then
31960: LD_EXP 45
31964: PPUSH
31965: CALL_OW 302
31969: IFFALSE 31983
// Say ( Gladstone , D20-Glad-1 ) ;
31971: LD_EXP 45
31975: PPUSH
31976: LD_STRING D20-Glad-1
31978: PPUSH
31979: CALL_OW 88
// if IsOk ( Cyrus ) then
31983: LD_EXP 42
31987: PPUSH
31988: CALL_OW 302
31992: IFFALSE 32006
// Say ( Cyrus , D20-Cyrus-1 ) ;
31994: LD_EXP 42
31998: PPUSH
31999: LD_STRING D20-Cyrus-1
32001: PPUSH
32002: CALL_OW 88
// if IsOk ( Stevens ) then
32006: LD_EXP 38
32010: PPUSH
32011: CALL_OW 302
32015: IFFALSE 32029
// Say ( Stevens , D20-Huck-1 ) ;
32017: LD_EXP 38
32021: PPUSH
32022: LD_STRING D20-Huck-1
32024: PPUSH
32025: CALL_OW 88
// if IsOk ( Brown ) then
32029: LD_EXP 44
32033: PPUSH
32034: CALL_OW 302
32038: IFFALSE 32052
// Say ( Brown , D20-Brown-1 ) ;
32040: LD_EXP 44
32044: PPUSH
32045: LD_STRING D20-Brown-1
32047: PPUSH
32048: CALL_OW 88
// if IsOk ( Gary ) then
32052: LD_EXP 48
32056: PPUSH
32057: CALL_OW 302
32061: IFFALSE 32075
// Say ( Gary , D20-Gary-1 ) ;
32063: LD_EXP 48
32067: PPUSH
32068: LD_STRING D20-Gary-1
32070: PPUSH
32071: CALL_OW 88
// if IsOk ( Connie ) then
32075: LD_EXP 51
32079: PPUSH
32080: CALL_OW 302
32084: IFFALSE 32098
// Say ( Connie , D20-Con-1 ) ;
32086: LD_EXP 51
32090: PPUSH
32091: LD_STRING D20-Con-1
32093: PPUSH
32094: CALL_OW 88
// if IsOk ( Kurt ) then
32098: LD_EXP 57
32102: PPUSH
32103: CALL_OW 302
32107: IFFALSE 32121
// Say ( Kurt , D20-Kurt-1 ) ;
32109: LD_EXP 57
32113: PPUSH
32114: LD_STRING D20-Kurt-1
32116: PPUSH
32117: CALL_OW 88
// if IsOk ( Kikuchi ) then
32121: LD_EXP 50
32125: PPUSH
32126: CALL_OW 302
32130: IFFALSE 32144
// Say ( Kikuchi , D20-Yam-1 ) ;
32132: LD_EXP 50
32136: PPUSH
32137: LD_STRING D20-Yam-1
32139: PPUSH
32140: CALL_OW 88
// if IsOk ( Frank ) then
32144: LD_EXP 49
32148: PPUSH
32149: CALL_OW 302
32153: IFFALSE 32167
// Say ( Frank , D20-Frank-1 ) ;
32155: LD_EXP 49
32159: PPUSH
32160: LD_STRING D20-Frank-1
32162: PPUSH
32163: CALL_OW 88
// DialogueOff ;
32167: CALL_OW 7
// if RothCaptured then
32171: LD_EXP 33
32175: IFFALSE 32197
// begin m1 := true ;
32177: LD_ADDR_VAR 0 1
32181: PUSH
32182: LD_INT 1
32184: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32185: LD_STRING Roth
32187: PPUSH
32188: LD_INT 1
32190: PPUSH
32191: CALL_OW 101
// end else
32195: GO 32208
// AddMedal ( Roth , - 1 ) ;
32197: LD_STRING Roth
32199: PPUSH
32200: LD_INT 1
32202: NEG
32203: PPUSH
32204: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32208: LD_EXP 27
32212: IFFALSE 32234
// begin m2 := true ;
32214: LD_ADDR_VAR 0 2
32218: PUSH
32219: LD_INT 1
32221: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32222: LD_STRING Project
32224: PPUSH
32225: LD_INT 1
32227: PPUSH
32228: CALL_OW 101
// end else
32232: GO 32245
// AddMedal ( Project , - 1 ) ;
32234: LD_STRING Project
32236: PPUSH
32237: LD_INT 1
32239: NEG
32240: PPUSH
32241: CALL_OW 101
// if lostCounter = 0 then
32245: LD_EXP 32
32249: PUSH
32250: LD_INT 0
32252: EQUAL
32253: IFFALSE 32275
// begin m3 := true ;
32255: LD_ADDR_VAR 0 3
32259: PUSH
32260: LD_INT 1
32262: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32263: LD_STRING NoLosses
32265: PPUSH
32266: LD_INT 1
32268: PPUSH
32269: CALL_OW 101
// end else
32273: GO 32286
// AddMedal ( NoLosses , - 1 ) ;
32275: LD_STRING NoLosses
32277: PPUSH
32278: LD_INT 1
32280: NEG
32281: PPUSH
32282: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32286: LD_VAR 0 1
32290: PUSH
32291: LD_VAR 0 2
32295: AND
32296: PUSH
32297: LD_VAR 0 3
32301: AND
32302: PUSH
32303: LD_OWVAR 67
32307: PUSH
32308: LD_INT 3
32310: EQUAL
32311: AND
32312: IFFALSE 32324
// SetAchievementEX ( ACH_AMER , 15 ) ;
32314: LD_STRING ACH_AMER
32316: PPUSH
32317: LD_INT 15
32319: PPUSH
32320: CALL_OW 564
// GiveMedals ( MAIN ) ;
32324: LD_STRING MAIN
32326: PPUSH
32327: CALL_OW 102
// music_class := 4 ;
32331: LD_ADDR_OWVAR 72
32335: PUSH
32336: LD_INT 4
32338: ST_TO_ADDR
// music_nat := 1 ;
32339: LD_ADDR_OWVAR 71
32343: PUSH
32344: LD_INT 1
32346: ST_TO_ADDR
// YouWin ;
32347: CALL_OW 103
// end ; end_of_file
32351: PPOPN 3
32353: END
// export function CustomEvent ( event ) ; begin
32354: LD_INT 0
32356: PPUSH
// end ;
32357: LD_VAR 0 2
32361: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32362: LD_VAR 0 1
32366: PUSH
32367: LD_INT 1
32369: EQUAL
32370: PUSH
32371: LD_VAR 0 2
32375: PUSH
32376: LD_INT 4
32378: EQUAL
32379: AND
32380: PUSH
32381: LD_EXP 55
32385: PPUSH
32386: CALL_OW 300
32390: AND
32391: IFFALSE 32407
// begin wait ( 0 0$2 ) ;
32393: LD_INT 70
32395: PPUSH
32396: CALL_OW 67
// YouLost ( Dismissed ) ;
32400: LD_STRING Dismissed
32402: PPUSH
32403: CALL_OW 104
// end ; end ;
32407: PPOPN 2
32409: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32410: LD_VAR 0 2
32414: PPUSH
32415: LD_VAR 0 3
32419: PPUSH
32420: LD_INT 18
32422: PPUSH
32423: CALL_OW 309
32427: IFFALSE 32436
// YouLost ( Motherlode3 ) ;
32429: LD_STRING Motherlode3
32431: PPUSH
32432: CALL_OW 104
// end ;
32436: PPOPN 3
32438: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32439: LD_EXP 27
32443: NOT
32444: IFFALSE 32454
// behemothDone := true ;
32446: LD_ADDR_EXP 28
32450: PUSH
32451: LD_INT 1
32453: ST_TO_ADDR
// end ;
32454: PPOPN 1
32456: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32457: LD_VAR 0 1
32461: PPUSH
32462: CALL_OW 255
32466: PUSH
32467: LD_INT 1
32469: EQUAL
32470: PUSH
32471: LD_EXP 30
32475: AND
32476: PUSH
32477: LD_INT 22
32479: PUSH
32480: LD_INT 3
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 34
32489: PUSH
32490: LD_INT 48
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PPUSH
32501: CALL_OW 69
32505: AND
32506: PUSH
32507: LD_INT 22
32509: PUSH
32510: LD_INT 1
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 34
32519: PUSH
32520: LD_INT 8
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PPUSH
32531: CALL_OW 69
32535: NOT
32536: AND
32537: IFFALSE 32589
// begin wait ( 0 0$5 ) ;
32539: LD_INT 175
32541: PPUSH
32542: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32546: LD_INT 22
32548: PUSH
32549: LD_INT 3
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 34
32558: PUSH
32559: LD_INT 48
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PPUSH
32570: CALL_OW 69
32574: PUSH
32575: LD_INT 1
32577: ARRAY
32578: PPUSH
32579: LD_INT 60
32581: PPUSH
32582: LD_INT 95
32584: PPUSH
32585: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32589: LD_VAR 0 2
32593: PPUSH
32594: LD_VAR 0 3
32598: PPUSH
32599: LD_INT 18
32601: PPUSH
32602: CALL_OW 309
32606: IFFALSE 32666
// begin if GetSide ( unit ) = 1 then
32608: LD_VAR 0 1
32612: PPUSH
32613: CALL_OW 255
32617: PUSH
32618: LD_INT 1
32620: EQUAL
32621: IFFALSE 32637
// begin wait ( 0 0$6 ) ;
32623: LD_INT 210
32625: PPUSH
32626: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32630: LD_STRING Motherlode2
32632: PPUSH
32633: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32637: LD_VAR 0 1
32641: PPUSH
32642: CALL_OW 255
32646: PUSH
32647: LD_INT 8
32649: EQUAL
32650: IFFALSE 32666
// begin wait ( 0 0$6 ) ;
32652: LD_INT 210
32654: PPUSH
32655: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32659: LD_STRING Motherlode1
32661: PPUSH
32662: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32666: LD_VAR 0 1
32670: PPUSH
32671: CALL_OW 255
32675: PUSH
32676: LD_INT 3
32678: EQUAL
32679: IFFALSE 32700
// begin wait ( 0 0$5 ) ;
32681: LD_INT 175
32683: PPUSH
32684: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32688: LD_EXP 61
32692: PPUSH
32693: LD_STRING D18-Pla-1
32695: PPUSH
32696: CALL_OW 94
// end ; end ;
32700: PPOPN 3
32702: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32703: LD_VAR 0 1
32707: PUSH
32708: LD_EXP 70
32712: IN
32713: IFFALSE 32733
// begin behemothBuilders := behemothBuilders diff un ;
32715: LD_ADDR_EXP 70
32719: PUSH
32720: LD_EXP 70
32724: PUSH
32725: LD_VAR 0 1
32729: DIFF
32730: ST_TO_ADDR
// exit ;
32731: GO 32831
// end ; if un = JMM then
32733: LD_VAR 0 1
32737: PUSH
32738: LD_EXP 36
32742: EQUAL
32743: IFFALSE 32754
// begin YouLost ( JMM ) ;
32745: LD_STRING JMM
32747: PPUSH
32748: CALL_OW 104
// exit ;
32752: GO 32831
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32754: LD_VAR 0 1
32758: PUSH
32759: LD_INT 22
32761: PUSH
32762: LD_INT 1
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 3
32771: PUSH
32772: LD_INT 25
32774: PUSH
32775: LD_INT 16
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 25
32784: PUSH
32785: LD_INT 12
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: LIST
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PPUSH
32801: CALL_OW 69
32805: IN
32806: IFFALSE 32822
// lostCounter := lostCounter + 1 ;
32808: LD_ADDR_EXP 32
32812: PUSH
32813: LD_EXP 32
32817: PUSH
32818: LD_INT 1
32820: PLUS
32821: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32822: LD_VAR 0 1
32826: PPUSH
32827: CALL 61115 0 1
// end ;
32831: PPOPN 1
32833: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32834: LD_VAR 0 1
32838: PPUSH
32839: LD_VAR 0 2
32843: PPUSH
32844: CALL 63449 0 2
// end ;
32848: PPOPN 2
32850: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32851: LD_VAR 0 1
32855: PPUSH
32856: CALL 62517 0 1
// end ;
32860: PPOPN 1
32862: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32863: LD_VAR 0 1
32867: PUSH
32868: LD_INT 22
32870: PUSH
32871: LD_INT 8
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 30
32880: PUSH
32881: LD_INT 2
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 23
32890: PUSH
32891: LD_INT 3
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: LIST
32902: PPUSH
32903: CALL_OW 69
32907: IN
32908: IFFALSE 32935
// begin ComUpgrade ( building ) ;
32910: LD_VAR 0 1
32914: PPUSH
32915: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32919: LD_EXP 58
32923: PPUSH
32924: LD_VAR 0 1
32928: PPUSH
32929: CALL 74155 0 2
// exit ;
32933: GO 32944
// end ; MCE_BuildingComplete ( building ) ;
32935: LD_VAR 0 1
32939: PPUSH
32940: CALL 62758 0 1
// end ;
32944: PPOPN 1
32946: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32947: LD_VAR 0 1
32951: PPUSH
32952: LD_VAR 0 2
32956: PPUSH
32957: CALL 60811 0 2
// end ;
32961: PPOPN 2
32963: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32964: LD_VAR 0 1
32968: PPUSH
32969: LD_VAR 0 2
32973: PPUSH
32974: LD_VAR 0 3
32978: PPUSH
32979: LD_VAR 0 4
32983: PPUSH
32984: LD_VAR 0 5
32988: PPUSH
32989: CALL 60431 0 5
// end ;
32993: PPOPN 5
32995: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32996: LD_VAR 0 1
33000: PPUSH
33001: LD_VAR 0 2
33005: PPUSH
33006: CALL 60027 0 2
// end ;
33010: PPOPN 2
33012: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33013: LD_VAR 0 1
33017: PPUSH
33018: LD_VAR 0 2
33022: PPUSH
33023: LD_VAR 0 3
33027: PPUSH
33028: LD_VAR 0 4
33032: PPUSH
33033: CALL 59865 0 4
// end ;
33037: PPOPN 4
33039: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33040: LD_VAR 0 1
33044: PPUSH
33045: LD_VAR 0 2
33049: PPUSH
33050: LD_VAR 0 3
33054: PPUSH
33055: CALL 59640 0 3
// end ;
33059: PPOPN 3
33061: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33062: LD_VAR 0 1
33066: PPUSH
33067: LD_VAR 0 2
33071: PPUSH
33072: CALL 59525 0 2
// end ;
33076: PPOPN 2
33078: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33079: LD_VAR 0 1
33083: PPUSH
33084: LD_VAR 0 2
33088: PPUSH
33089: CALL 63710 0 2
// end ;
33093: PPOPN 2
33095: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33096: LD_VAR 0 1
33100: PPUSH
33101: CALL_OW 255
33105: PUSH
33106: LD_INT 4
33108: EQUAL
33109: PUSH
33110: LD_VAR 0 1
33114: PUSH
33115: LD_EXP 18
33119: PUSH
33120: LD_INT 1
33122: ARRAY
33123: IN
33124: AND
33125: PUSH
33126: LD_EXP 19
33130: AND
33131: IFFALSE 33150
// begin ComMoveXY ( driver , 61 , 93 ) ;
33133: LD_VAR 0 1
33137: PPUSH
33138: LD_INT 61
33140: PPUSH
33141: LD_INT 93
33143: PPUSH
33144: CALL_OW 111
// exit ;
33148: GO 33174
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33150: LD_VAR 0 1
33154: PPUSH
33155: LD_VAR 0 2
33159: PPUSH
33160: LD_VAR 0 3
33164: PPUSH
33165: LD_VAR 0 4
33169: PPUSH
33170: CALL 63926 0 4
// end ;
33174: PPOPN 4
33176: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33177: LD_VAR 0 1
33181: PPUSH
33182: LD_VAR 0 2
33186: PPUSH
33187: CALL 59334 0 2
// end ;
33191: PPOPN 2
33193: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33194: LD_VAR 0 1
33198: PPUSH
33199: CALL 107327 0 1
// end ; end_of_file
33203: PPOPN 1
33205: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33206: LD_EXP 15
33210: PUSH
33211: LD_INT 2
33213: EQUAL
33214: IFFALSE 33693
33216: GO 33218
33218: DISABLE
33219: LD_INT 0
33221: PPUSH
// begin time := 0 0$40 ;
33222: LD_ADDR_VAR 0 1
33226: PUSH
33227: LD_INT 1400
33229: ST_TO_ADDR
// repeat wait ( time ) ;
33230: LD_VAR 0 1
33234: PPUSH
33235: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33239: LD_INT 1
33241: PPUSH
33242: LD_INT 5
33244: PPUSH
33245: CALL_OW 12
33249: PPUSH
33250: LD_INT 106
33252: PPUSH
33253: LD_INT 150
33255: PPUSH
33256: LD_INT 19
33258: PPUSH
33259: LD_INT 1
33261: PPUSH
33262: CALL_OW 56
// time := time + 0 0$9 ;
33266: LD_ADDR_VAR 0 1
33270: PUSH
33271: LD_VAR 0 1
33275: PUSH
33276: LD_INT 315
33278: PLUS
33279: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33280: LD_INT 455
33282: PPUSH
33283: LD_INT 840
33285: PPUSH
33286: CALL_OW 12
33290: PPUSH
33291: CALL_OW 67
// if Prob ( 50 ) then
33295: LD_INT 50
33297: PPUSH
33298: CALL_OW 13
33302: IFFALSE 33331
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33304: LD_INT 1
33306: PPUSH
33307: LD_INT 5
33309: PPUSH
33310: CALL_OW 12
33314: PPUSH
33315: LD_INT 62
33317: PPUSH
33318: LD_INT 108
33320: PPUSH
33321: LD_INT 10
33323: PPUSH
33324: LD_INT 1
33326: PPUSH
33327: CALL_OW 56
// until missionStage > 4 ;
33331: LD_EXP 15
33335: PUSH
33336: LD_INT 4
33338: GREATER
33339: IFFALSE 33230
// repeat wait ( 0 0$1 ) ;
33341: LD_INT 35
33343: PPUSH
33344: CALL_OW 67
// until missionStage = 6 ;
33348: LD_EXP 15
33352: PUSH
33353: LD_INT 6
33355: EQUAL
33356: IFFALSE 33341
// time := 0 0$50 ;
33358: LD_ADDR_VAR 0 1
33362: PUSH
33363: LD_INT 1750
33365: ST_TO_ADDR
// repeat wait ( time ) ;
33366: LD_VAR 0 1
33370: PPUSH
33371: CALL_OW 67
// if Prob ( 50 ) then
33375: LD_INT 50
33377: PPUSH
33378: CALL_OW 13
33382: IFFALSE 33411
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33384: LD_INT 1
33386: PPUSH
33387: LD_INT 5
33389: PPUSH
33390: CALL_OW 12
33394: PPUSH
33395: LD_INT 106
33397: PPUSH
33398: LD_INT 89
33400: PPUSH
33401: LD_INT 45
33403: PPUSH
33404: LD_INT 1
33406: PPUSH
33407: CALL_OW 56
// time := time + 0 0$3 ;
33411: LD_ADDR_VAR 0 1
33415: PUSH
33416: LD_VAR 0 1
33420: PUSH
33421: LD_INT 105
33423: PLUS
33424: ST_TO_ADDR
// if Prob ( 30 ) then
33425: LD_INT 30
33427: PPUSH
33428: CALL_OW 13
33432: IFFALSE 33478
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33434: LD_INT 525
33436: PPUSH
33437: LD_INT 735
33439: PPUSH
33440: CALL_OW 12
33444: PPUSH
33445: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33449: LD_INT 1
33451: PPUSH
33452: LD_INT 5
33454: PPUSH
33455: CALL_OW 12
33459: PPUSH
33460: LD_INT 21
33462: PPUSH
33463: LD_INT 26
33465: PPUSH
33466: LD_INT 12
33468: PPUSH
33469: LD_INT 1
33471: PPUSH
33472: CALL_OW 56
// end else
33476: GO 33514
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33478: LD_INT 700
33480: PPUSH
33481: LD_INT 1225
33483: PPUSH
33484: CALL_OW 12
33488: PPUSH
33489: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33493: LD_INT 1
33495: PPUSH
33496: LD_INT 5
33498: PPUSH
33499: CALL_OW 12
33503: PPUSH
33504: LD_INT 16
33506: PPUSH
33507: LD_INT 1
33509: PPUSH
33510: CALL_OW 55
// end ; if Prob ( 50 ) then
33514: LD_INT 50
33516: PPUSH
33517: CALL_OW 13
33521: IFFALSE 33567
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33523: LD_INT 700
33525: PPUSH
33526: LD_INT 1050
33528: PPUSH
33529: CALL_OW 12
33533: PPUSH
33534: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33538: LD_INT 1
33540: PPUSH
33541: LD_INT 5
33543: PPUSH
33544: CALL_OW 12
33548: PPUSH
33549: LD_INT 181
33551: PPUSH
33552: LD_INT 218
33554: PPUSH
33555: LD_INT 16
33557: PPUSH
33558: LD_INT 1
33560: PPUSH
33561: CALL_OW 56
// end else
33565: GO 33603
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33567: LD_INT 350
33569: PPUSH
33570: LD_INT 525
33572: PPUSH
33573: CALL_OW 12
33577: PPUSH
33578: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33582: LD_INT 1
33584: PPUSH
33585: LD_INT 5
33587: PPUSH
33588: CALL_OW 12
33592: PPUSH
33593: LD_INT 15
33595: PPUSH
33596: LD_INT 1
33598: PPUSH
33599: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33603: LD_INT 45
33605: PUSH
33606: LD_INT 32
33608: PUSH
33609: LD_INT 25
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: LIST
33616: PUSH
33617: LD_OWVAR 67
33621: ARRAY
33622: PPUSH
33623: CALL_OW 13
33627: IFFALSE 33671
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33629: LD_INT 525
33631: PPUSH
33632: LD_INT 875
33634: PPUSH
33635: CALL_OW 12
33639: PPUSH
33640: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33644: LD_INT 1
33646: PPUSH
33647: LD_INT 5
33649: PPUSH
33650: CALL_OW 12
33654: PPUSH
33655: LD_INT 103
33657: PPUSH
33658: LD_INT 140
33660: PPUSH
33661: LD_INT 20
33663: PPUSH
33664: LD_INT 1
33666: PPUSH
33667: CALL_OW 56
// end ; if time > 2 2$20 then
33671: LD_VAR 0 1
33675: PUSH
33676: LD_INT 4900
33678: GREATER
33679: IFFALSE 33689
// time := 0 0$50 ;
33681: LD_ADDR_VAR 0 1
33685: PUSH
33686: LD_INT 1750
33688: ST_TO_ADDR
// until false ;
33689: LD_INT 0
33691: IFFALSE 33366
// end ; end_of_file
33693: PPOPN 1
33695: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33696: LD_EXP 13
33700: PUSH
33701: LD_EXP 15
33705: PUSH
33706: LD_INT 6
33708: GREATEREQUAL
33709: AND
33710: IFFALSE 33747
33712: GO 33714
33714: DISABLE
// begin enable ;
33715: ENABLE
// missionTime := missionTime + 0 0$1 ;
33716: LD_ADDR_EXP 14
33720: PUSH
33721: LD_EXP 14
33725: PUSH
33726: LD_INT 35
33728: PLUS
33729: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33730: LD_ADDR_OWVAR 47
33734: PUSH
33735: LD_STRING #Am15-1
33737: PUSH
33738: LD_EXP 14
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: ST_TO_ADDR
// end ; end_of_file
33747: END
// export function InitNature ; begin
33748: LD_INT 0
33750: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33751: LD_INT 3
33753: PPUSH
33754: LD_INT 3
33756: PPUSH
33757: LD_INT 2
33759: PPUSH
33760: LD_INT 1
33762: PPUSH
33763: LD_INT 1
33765: PPUSH
33766: LD_INT 0
33768: PPUSH
33769: LD_INT 0
33771: PPUSH
33772: LD_INT 20
33774: PPUSH
33775: LD_INT 0
33777: PPUSH
33778: CALL 98996 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33782: LD_INT 2
33784: PPUSH
33785: LD_INT 1
33787: PPUSH
33788: LD_INT 1
33790: PPUSH
33791: LD_INT 1
33793: PPUSH
33794: LD_INT 1
33796: PPUSH
33797: LD_INT 0
33799: PPUSH
33800: LD_INT 0
33802: PPUSH
33803: LD_INT 21
33805: PPUSH
33806: LD_INT 0
33808: PPUSH
33809: CALL 98996 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33813: LD_INT 4
33815: PPUSH
33816: LD_INT 1
33818: PPUSH
33819: LD_INT 2
33821: PPUSH
33822: LD_INT 4
33824: PPUSH
33825: LD_INT 2
33827: PPUSH
33828: LD_INT 1
33830: PPUSH
33831: LD_INT 0
33833: PPUSH
33834: LD_INT 22
33836: PPUSH
33837: LD_INT 0
33839: PPUSH
33840: CALL 98996 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33844: LD_INT 0
33846: PPUSH
33847: LD_INT 0
33849: PPUSH
33850: LD_INT 0
33852: PPUSH
33853: LD_INT 0
33855: PPUSH
33856: LD_INT 0
33858: PPUSH
33859: LD_INT 0
33861: PPUSH
33862: LD_INT 9
33864: PPUSH
33865: LD_INT 0
33867: PPUSH
33868: LD_INT 23
33870: PPUSH
33871: CALL 98996 0 9
// end ; end_of_file
33875: LD_VAR 0 1
33879: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33880: GO 33882
33882: DISABLE
// begin ru_radar := 98 ;
33883: LD_ADDR_EXP 92
33887: PUSH
33888: LD_INT 98
33890: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33891: LD_ADDR_EXP 93
33895: PUSH
33896: LD_INT 89
33898: ST_TO_ADDR
// us_hack := 99 ;
33899: LD_ADDR_EXP 94
33903: PUSH
33904: LD_INT 99
33906: ST_TO_ADDR
// us_artillery := 97 ;
33907: LD_ADDR_EXP 95
33911: PUSH
33912: LD_INT 97
33914: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33915: LD_ADDR_EXP 96
33919: PUSH
33920: LD_INT 91
33922: ST_TO_ADDR
// end ; end_of_file
33923: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33924: LD_INT 0
33926: PPUSH
33927: PPUSH
// skirmish := false ;
33928: LD_ADDR_EXP 97
33932: PUSH
33933: LD_INT 0
33935: ST_TO_ADDR
// debug_mc := false ;
33936: LD_ADDR_EXP 98
33940: PUSH
33941: LD_INT 0
33943: ST_TO_ADDR
// mc_bases := [ ] ;
33944: LD_ADDR_EXP 99
33948: PUSH
33949: EMPTY
33950: ST_TO_ADDR
// mc_sides := [ ] ;
33951: LD_ADDR_EXP 125
33955: PUSH
33956: EMPTY
33957: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33958: LD_ADDR_EXP 100
33962: PUSH
33963: EMPTY
33964: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33965: LD_ADDR_EXP 101
33969: PUSH
33970: EMPTY
33971: ST_TO_ADDR
// mc_need_heal := [ ] ;
33972: LD_ADDR_EXP 102
33976: PUSH
33977: EMPTY
33978: ST_TO_ADDR
// mc_healers := [ ] ;
33979: LD_ADDR_EXP 103
33983: PUSH
33984: EMPTY
33985: ST_TO_ADDR
// mc_build_list := [ ] ;
33986: LD_ADDR_EXP 104
33990: PUSH
33991: EMPTY
33992: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33993: LD_ADDR_EXP 131
33997: PUSH
33998: EMPTY
33999: ST_TO_ADDR
// mc_builders := [ ] ;
34000: LD_ADDR_EXP 105
34004: PUSH
34005: EMPTY
34006: ST_TO_ADDR
// mc_construct_list := [ ] ;
34007: LD_ADDR_EXP 106
34011: PUSH
34012: EMPTY
34013: ST_TO_ADDR
// mc_turret_list := [ ] ;
34014: LD_ADDR_EXP 107
34018: PUSH
34019: EMPTY
34020: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34021: LD_ADDR_EXP 108
34025: PUSH
34026: EMPTY
34027: ST_TO_ADDR
// mc_miners := [ ] ;
34028: LD_ADDR_EXP 113
34032: PUSH
34033: EMPTY
34034: ST_TO_ADDR
// mc_mines := [ ] ;
34035: LD_ADDR_EXP 112
34039: PUSH
34040: EMPTY
34041: ST_TO_ADDR
// mc_minefields := [ ] ;
34042: LD_ADDR_EXP 114
34046: PUSH
34047: EMPTY
34048: ST_TO_ADDR
// mc_crates := [ ] ;
34049: LD_ADDR_EXP 115
34053: PUSH
34054: EMPTY
34055: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34056: LD_ADDR_EXP 116
34060: PUSH
34061: EMPTY
34062: ST_TO_ADDR
// mc_crates_area := [ ] ;
34063: LD_ADDR_EXP 117
34067: PUSH
34068: EMPTY
34069: ST_TO_ADDR
// mc_vehicles := [ ] ;
34070: LD_ADDR_EXP 118
34074: PUSH
34075: EMPTY
34076: ST_TO_ADDR
// mc_attack := [ ] ;
34077: LD_ADDR_EXP 119
34081: PUSH
34082: EMPTY
34083: ST_TO_ADDR
// mc_produce := [ ] ;
34084: LD_ADDR_EXP 120
34088: PUSH
34089: EMPTY
34090: ST_TO_ADDR
// mc_defender := [ ] ;
34091: LD_ADDR_EXP 121
34095: PUSH
34096: EMPTY
34097: ST_TO_ADDR
// mc_parking := [ ] ;
34098: LD_ADDR_EXP 123
34102: PUSH
34103: EMPTY
34104: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34105: LD_ADDR_EXP 109
34109: PUSH
34110: EMPTY
34111: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34112: LD_ADDR_EXP 111
34116: PUSH
34117: EMPTY
34118: ST_TO_ADDR
// mc_scan := [ ] ;
34119: LD_ADDR_EXP 122
34123: PUSH
34124: EMPTY
34125: ST_TO_ADDR
// mc_scan_area := [ ] ;
34126: LD_ADDR_EXP 124
34130: PUSH
34131: EMPTY
34132: ST_TO_ADDR
// mc_tech := [ ] ;
34133: LD_ADDR_EXP 126
34137: PUSH
34138: EMPTY
34139: ST_TO_ADDR
// mc_class := [ ] ;
34140: LD_ADDR_EXP 140
34144: PUSH
34145: EMPTY
34146: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34147: LD_ADDR_EXP 141
34151: PUSH
34152: EMPTY
34153: ST_TO_ADDR
// end ;
34154: LD_VAR 0 1
34158: RET
// export function MC_Kill ( base ) ; begin
34159: LD_INT 0
34161: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34162: LD_ADDR_EXP 99
34166: PUSH
34167: LD_EXP 99
34171: PPUSH
34172: LD_VAR 0 1
34176: PPUSH
34177: EMPTY
34178: PPUSH
34179: CALL_OW 1
34183: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34184: LD_ADDR_EXP 100
34188: PUSH
34189: LD_EXP 100
34193: PPUSH
34194: LD_VAR 0 1
34198: PPUSH
34199: EMPTY
34200: PPUSH
34201: CALL_OW 1
34205: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34206: LD_ADDR_EXP 101
34210: PUSH
34211: LD_EXP 101
34215: PPUSH
34216: LD_VAR 0 1
34220: PPUSH
34221: EMPTY
34222: PPUSH
34223: CALL_OW 1
34227: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34228: LD_ADDR_EXP 102
34232: PUSH
34233: LD_EXP 102
34237: PPUSH
34238: LD_VAR 0 1
34242: PPUSH
34243: EMPTY
34244: PPUSH
34245: CALL_OW 1
34249: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34250: LD_ADDR_EXP 103
34254: PUSH
34255: LD_EXP 103
34259: PPUSH
34260: LD_VAR 0 1
34264: PPUSH
34265: EMPTY
34266: PPUSH
34267: CALL_OW 1
34271: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34272: LD_ADDR_EXP 104
34276: PUSH
34277: LD_EXP 104
34281: PPUSH
34282: LD_VAR 0 1
34286: PPUSH
34287: EMPTY
34288: PPUSH
34289: CALL_OW 1
34293: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34294: LD_ADDR_EXP 105
34298: PUSH
34299: LD_EXP 105
34303: PPUSH
34304: LD_VAR 0 1
34308: PPUSH
34309: EMPTY
34310: PPUSH
34311: CALL_OW 1
34315: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34316: LD_ADDR_EXP 106
34320: PUSH
34321: LD_EXP 106
34325: PPUSH
34326: LD_VAR 0 1
34330: PPUSH
34331: EMPTY
34332: PPUSH
34333: CALL_OW 1
34337: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34338: LD_ADDR_EXP 107
34342: PUSH
34343: LD_EXP 107
34347: PPUSH
34348: LD_VAR 0 1
34352: PPUSH
34353: EMPTY
34354: PPUSH
34355: CALL_OW 1
34359: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34360: LD_ADDR_EXP 108
34364: PUSH
34365: LD_EXP 108
34369: PPUSH
34370: LD_VAR 0 1
34374: PPUSH
34375: EMPTY
34376: PPUSH
34377: CALL_OW 1
34381: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34382: LD_ADDR_EXP 109
34386: PUSH
34387: LD_EXP 109
34391: PPUSH
34392: LD_VAR 0 1
34396: PPUSH
34397: EMPTY
34398: PPUSH
34399: CALL_OW 1
34403: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34404: LD_ADDR_EXP 110
34408: PUSH
34409: LD_EXP 110
34413: PPUSH
34414: LD_VAR 0 1
34418: PPUSH
34419: LD_INT 0
34421: PPUSH
34422: CALL_OW 1
34426: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34427: LD_ADDR_EXP 111
34431: PUSH
34432: LD_EXP 111
34436: PPUSH
34437: LD_VAR 0 1
34441: PPUSH
34442: EMPTY
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34449: LD_ADDR_EXP 112
34453: PUSH
34454: LD_EXP 112
34458: PPUSH
34459: LD_VAR 0 1
34463: PPUSH
34464: EMPTY
34465: PPUSH
34466: CALL_OW 1
34470: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34471: LD_ADDR_EXP 113
34475: PUSH
34476: LD_EXP 113
34480: PPUSH
34481: LD_VAR 0 1
34485: PPUSH
34486: EMPTY
34487: PPUSH
34488: CALL_OW 1
34492: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34493: LD_ADDR_EXP 114
34497: PUSH
34498: LD_EXP 114
34502: PPUSH
34503: LD_VAR 0 1
34507: PPUSH
34508: EMPTY
34509: PPUSH
34510: CALL_OW 1
34514: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34515: LD_ADDR_EXP 115
34519: PUSH
34520: LD_EXP 115
34524: PPUSH
34525: LD_VAR 0 1
34529: PPUSH
34530: EMPTY
34531: PPUSH
34532: CALL_OW 1
34536: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34537: LD_ADDR_EXP 116
34541: PUSH
34542: LD_EXP 116
34546: PPUSH
34547: LD_VAR 0 1
34551: PPUSH
34552: EMPTY
34553: PPUSH
34554: CALL_OW 1
34558: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34559: LD_ADDR_EXP 117
34563: PUSH
34564: LD_EXP 117
34568: PPUSH
34569: LD_VAR 0 1
34573: PPUSH
34574: EMPTY
34575: PPUSH
34576: CALL_OW 1
34580: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34581: LD_ADDR_EXP 118
34585: PUSH
34586: LD_EXP 118
34590: PPUSH
34591: LD_VAR 0 1
34595: PPUSH
34596: EMPTY
34597: PPUSH
34598: CALL_OW 1
34602: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34603: LD_ADDR_EXP 119
34607: PUSH
34608: LD_EXP 119
34612: PPUSH
34613: LD_VAR 0 1
34617: PPUSH
34618: EMPTY
34619: PPUSH
34620: CALL_OW 1
34624: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34625: LD_ADDR_EXP 120
34629: PUSH
34630: LD_EXP 120
34634: PPUSH
34635: LD_VAR 0 1
34639: PPUSH
34640: EMPTY
34641: PPUSH
34642: CALL_OW 1
34646: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34647: LD_ADDR_EXP 121
34651: PUSH
34652: LD_EXP 121
34656: PPUSH
34657: LD_VAR 0 1
34661: PPUSH
34662: EMPTY
34663: PPUSH
34664: CALL_OW 1
34668: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34669: LD_ADDR_EXP 122
34673: PUSH
34674: LD_EXP 122
34678: PPUSH
34679: LD_VAR 0 1
34683: PPUSH
34684: EMPTY
34685: PPUSH
34686: CALL_OW 1
34690: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34691: LD_ADDR_EXP 123
34695: PUSH
34696: LD_EXP 123
34700: PPUSH
34701: LD_VAR 0 1
34705: PPUSH
34706: EMPTY
34707: PPUSH
34708: CALL_OW 1
34712: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34713: LD_ADDR_EXP 124
34717: PUSH
34718: LD_EXP 124
34722: PPUSH
34723: LD_VAR 0 1
34727: PPUSH
34728: EMPTY
34729: PPUSH
34730: CALL_OW 1
34734: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34735: LD_ADDR_EXP 126
34739: PUSH
34740: LD_EXP 126
34744: PPUSH
34745: LD_VAR 0 1
34749: PPUSH
34750: EMPTY
34751: PPUSH
34752: CALL_OW 1
34756: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34757: LD_ADDR_EXP 128
34761: PUSH
34762: LD_EXP 128
34766: PPUSH
34767: LD_VAR 0 1
34771: PPUSH
34772: EMPTY
34773: PPUSH
34774: CALL_OW 1
34778: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34779: LD_ADDR_EXP 129
34783: PUSH
34784: LD_EXP 129
34788: PPUSH
34789: LD_VAR 0 1
34793: PPUSH
34794: EMPTY
34795: PPUSH
34796: CALL_OW 1
34800: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34801: LD_ADDR_EXP 130
34805: PUSH
34806: LD_EXP 130
34810: PPUSH
34811: LD_VAR 0 1
34815: PPUSH
34816: EMPTY
34817: PPUSH
34818: CALL_OW 1
34822: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34823: LD_ADDR_EXP 131
34827: PUSH
34828: LD_EXP 131
34832: PPUSH
34833: LD_VAR 0 1
34837: PPUSH
34838: EMPTY
34839: PPUSH
34840: CALL_OW 1
34844: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34845: LD_ADDR_EXP 132
34849: PUSH
34850: LD_EXP 132
34854: PPUSH
34855: LD_VAR 0 1
34859: PPUSH
34860: EMPTY
34861: PPUSH
34862: CALL_OW 1
34866: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34867: LD_ADDR_EXP 133
34871: PUSH
34872: LD_EXP 133
34876: PPUSH
34877: LD_VAR 0 1
34881: PPUSH
34882: EMPTY
34883: PPUSH
34884: CALL_OW 1
34888: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34889: LD_ADDR_EXP 134
34893: PUSH
34894: LD_EXP 134
34898: PPUSH
34899: LD_VAR 0 1
34903: PPUSH
34904: EMPTY
34905: PPUSH
34906: CALL_OW 1
34910: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34911: LD_ADDR_EXP 135
34915: PUSH
34916: LD_EXP 135
34920: PPUSH
34921: LD_VAR 0 1
34925: PPUSH
34926: EMPTY
34927: PPUSH
34928: CALL_OW 1
34932: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34933: LD_ADDR_EXP 136
34937: PUSH
34938: LD_EXP 136
34942: PPUSH
34943: LD_VAR 0 1
34947: PPUSH
34948: EMPTY
34949: PPUSH
34950: CALL_OW 1
34954: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34955: LD_ADDR_EXP 137
34959: PUSH
34960: LD_EXP 137
34964: PPUSH
34965: LD_VAR 0 1
34969: PPUSH
34970: EMPTY
34971: PPUSH
34972: CALL_OW 1
34976: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34977: LD_ADDR_EXP 138
34981: PUSH
34982: LD_EXP 138
34986: PPUSH
34987: LD_VAR 0 1
34991: PPUSH
34992: EMPTY
34993: PPUSH
34994: CALL_OW 1
34998: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34999: LD_ADDR_EXP 139
35003: PUSH
35004: LD_EXP 139
35008: PPUSH
35009: LD_VAR 0 1
35013: PPUSH
35014: EMPTY
35015: PPUSH
35016: CALL_OW 1
35020: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35021: LD_ADDR_EXP 140
35025: PUSH
35026: LD_EXP 140
35030: PPUSH
35031: LD_VAR 0 1
35035: PPUSH
35036: EMPTY
35037: PPUSH
35038: CALL_OW 1
35042: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35043: LD_ADDR_EXP 141
35047: PUSH
35048: LD_EXP 141
35052: PPUSH
35053: LD_VAR 0 1
35057: PPUSH
35058: LD_INT 0
35060: PPUSH
35061: CALL_OW 1
35065: ST_TO_ADDR
// end ;
35066: LD_VAR 0 2
35070: RET
// export function MC_Add ( side , units ) ; var base ; begin
35071: LD_INT 0
35073: PPUSH
35074: PPUSH
// base := mc_bases + 1 ;
35075: LD_ADDR_VAR 0 4
35079: PUSH
35080: LD_EXP 99
35084: PUSH
35085: LD_INT 1
35087: PLUS
35088: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35089: LD_ADDR_EXP 125
35093: PUSH
35094: LD_EXP 125
35098: PPUSH
35099: LD_VAR 0 4
35103: PPUSH
35104: LD_VAR 0 1
35108: PPUSH
35109: CALL_OW 1
35113: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35114: LD_ADDR_EXP 99
35118: PUSH
35119: LD_EXP 99
35123: PPUSH
35124: LD_VAR 0 4
35128: PPUSH
35129: LD_VAR 0 2
35133: PPUSH
35134: CALL_OW 1
35138: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35139: LD_ADDR_EXP 100
35143: PUSH
35144: LD_EXP 100
35148: PPUSH
35149: LD_VAR 0 4
35153: PPUSH
35154: EMPTY
35155: PPUSH
35156: CALL_OW 1
35160: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35161: LD_ADDR_EXP 101
35165: PUSH
35166: LD_EXP 101
35170: PPUSH
35171: LD_VAR 0 4
35175: PPUSH
35176: EMPTY
35177: PPUSH
35178: CALL_OW 1
35182: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35183: LD_ADDR_EXP 102
35187: PUSH
35188: LD_EXP 102
35192: PPUSH
35193: LD_VAR 0 4
35197: PPUSH
35198: EMPTY
35199: PPUSH
35200: CALL_OW 1
35204: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35205: LD_ADDR_EXP 103
35209: PUSH
35210: LD_EXP 103
35214: PPUSH
35215: LD_VAR 0 4
35219: PPUSH
35220: EMPTY
35221: PPUSH
35222: CALL_OW 1
35226: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35227: LD_ADDR_EXP 104
35231: PUSH
35232: LD_EXP 104
35236: PPUSH
35237: LD_VAR 0 4
35241: PPUSH
35242: EMPTY
35243: PPUSH
35244: CALL_OW 1
35248: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35249: LD_ADDR_EXP 105
35253: PUSH
35254: LD_EXP 105
35258: PPUSH
35259: LD_VAR 0 4
35263: PPUSH
35264: EMPTY
35265: PPUSH
35266: CALL_OW 1
35270: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35271: LD_ADDR_EXP 106
35275: PUSH
35276: LD_EXP 106
35280: PPUSH
35281: LD_VAR 0 4
35285: PPUSH
35286: EMPTY
35287: PPUSH
35288: CALL_OW 1
35292: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35293: LD_ADDR_EXP 107
35297: PUSH
35298: LD_EXP 107
35302: PPUSH
35303: LD_VAR 0 4
35307: PPUSH
35308: EMPTY
35309: PPUSH
35310: CALL_OW 1
35314: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35315: LD_ADDR_EXP 108
35319: PUSH
35320: LD_EXP 108
35324: PPUSH
35325: LD_VAR 0 4
35329: PPUSH
35330: EMPTY
35331: PPUSH
35332: CALL_OW 1
35336: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35337: LD_ADDR_EXP 109
35341: PUSH
35342: LD_EXP 109
35346: PPUSH
35347: LD_VAR 0 4
35351: PPUSH
35352: EMPTY
35353: PPUSH
35354: CALL_OW 1
35358: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35359: LD_ADDR_EXP 110
35363: PUSH
35364: LD_EXP 110
35368: PPUSH
35369: LD_VAR 0 4
35373: PPUSH
35374: LD_INT 0
35376: PPUSH
35377: CALL_OW 1
35381: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35382: LD_ADDR_EXP 111
35386: PUSH
35387: LD_EXP 111
35391: PPUSH
35392: LD_VAR 0 4
35396: PPUSH
35397: EMPTY
35398: PPUSH
35399: CALL_OW 1
35403: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35404: LD_ADDR_EXP 112
35408: PUSH
35409: LD_EXP 112
35413: PPUSH
35414: LD_VAR 0 4
35418: PPUSH
35419: EMPTY
35420: PPUSH
35421: CALL_OW 1
35425: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35426: LD_ADDR_EXP 113
35430: PUSH
35431: LD_EXP 113
35435: PPUSH
35436: LD_VAR 0 4
35440: PPUSH
35441: EMPTY
35442: PPUSH
35443: CALL_OW 1
35447: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35448: LD_ADDR_EXP 114
35452: PUSH
35453: LD_EXP 114
35457: PPUSH
35458: LD_VAR 0 4
35462: PPUSH
35463: EMPTY
35464: PPUSH
35465: CALL_OW 1
35469: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35470: LD_ADDR_EXP 115
35474: PUSH
35475: LD_EXP 115
35479: PPUSH
35480: LD_VAR 0 4
35484: PPUSH
35485: EMPTY
35486: PPUSH
35487: CALL_OW 1
35491: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35492: LD_ADDR_EXP 116
35496: PUSH
35497: LD_EXP 116
35501: PPUSH
35502: LD_VAR 0 4
35506: PPUSH
35507: EMPTY
35508: PPUSH
35509: CALL_OW 1
35513: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35514: LD_ADDR_EXP 117
35518: PUSH
35519: LD_EXP 117
35523: PPUSH
35524: LD_VAR 0 4
35528: PPUSH
35529: EMPTY
35530: PPUSH
35531: CALL_OW 1
35535: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35536: LD_ADDR_EXP 118
35540: PUSH
35541: LD_EXP 118
35545: PPUSH
35546: LD_VAR 0 4
35550: PPUSH
35551: EMPTY
35552: PPUSH
35553: CALL_OW 1
35557: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35558: LD_ADDR_EXP 119
35562: PUSH
35563: LD_EXP 119
35567: PPUSH
35568: LD_VAR 0 4
35572: PPUSH
35573: EMPTY
35574: PPUSH
35575: CALL_OW 1
35579: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35580: LD_ADDR_EXP 120
35584: PUSH
35585: LD_EXP 120
35589: PPUSH
35590: LD_VAR 0 4
35594: PPUSH
35595: EMPTY
35596: PPUSH
35597: CALL_OW 1
35601: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35602: LD_ADDR_EXP 121
35606: PUSH
35607: LD_EXP 121
35611: PPUSH
35612: LD_VAR 0 4
35616: PPUSH
35617: EMPTY
35618: PPUSH
35619: CALL_OW 1
35623: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35624: LD_ADDR_EXP 122
35628: PUSH
35629: LD_EXP 122
35633: PPUSH
35634: LD_VAR 0 4
35638: PPUSH
35639: EMPTY
35640: PPUSH
35641: CALL_OW 1
35645: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35646: LD_ADDR_EXP 123
35650: PUSH
35651: LD_EXP 123
35655: PPUSH
35656: LD_VAR 0 4
35660: PPUSH
35661: EMPTY
35662: PPUSH
35663: CALL_OW 1
35667: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35668: LD_ADDR_EXP 124
35672: PUSH
35673: LD_EXP 124
35677: PPUSH
35678: LD_VAR 0 4
35682: PPUSH
35683: EMPTY
35684: PPUSH
35685: CALL_OW 1
35689: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35690: LD_ADDR_EXP 126
35694: PUSH
35695: LD_EXP 126
35699: PPUSH
35700: LD_VAR 0 4
35704: PPUSH
35705: EMPTY
35706: PPUSH
35707: CALL_OW 1
35711: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35712: LD_ADDR_EXP 128
35716: PUSH
35717: LD_EXP 128
35721: PPUSH
35722: LD_VAR 0 4
35726: PPUSH
35727: EMPTY
35728: PPUSH
35729: CALL_OW 1
35733: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35734: LD_ADDR_EXP 129
35738: PUSH
35739: LD_EXP 129
35743: PPUSH
35744: LD_VAR 0 4
35748: PPUSH
35749: EMPTY
35750: PPUSH
35751: CALL_OW 1
35755: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35756: LD_ADDR_EXP 130
35760: PUSH
35761: LD_EXP 130
35765: PPUSH
35766: LD_VAR 0 4
35770: PPUSH
35771: EMPTY
35772: PPUSH
35773: CALL_OW 1
35777: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35778: LD_ADDR_EXP 131
35782: PUSH
35783: LD_EXP 131
35787: PPUSH
35788: LD_VAR 0 4
35792: PPUSH
35793: EMPTY
35794: PPUSH
35795: CALL_OW 1
35799: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35800: LD_ADDR_EXP 132
35804: PUSH
35805: LD_EXP 132
35809: PPUSH
35810: LD_VAR 0 4
35814: PPUSH
35815: EMPTY
35816: PPUSH
35817: CALL_OW 1
35821: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35822: LD_ADDR_EXP 133
35826: PUSH
35827: LD_EXP 133
35831: PPUSH
35832: LD_VAR 0 4
35836: PPUSH
35837: EMPTY
35838: PPUSH
35839: CALL_OW 1
35843: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35844: LD_ADDR_EXP 134
35848: PUSH
35849: LD_EXP 134
35853: PPUSH
35854: LD_VAR 0 4
35858: PPUSH
35859: EMPTY
35860: PPUSH
35861: CALL_OW 1
35865: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35866: LD_ADDR_EXP 135
35870: PUSH
35871: LD_EXP 135
35875: PPUSH
35876: LD_VAR 0 4
35880: PPUSH
35881: EMPTY
35882: PPUSH
35883: CALL_OW 1
35887: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35888: LD_ADDR_EXP 136
35892: PUSH
35893: LD_EXP 136
35897: PPUSH
35898: LD_VAR 0 4
35902: PPUSH
35903: EMPTY
35904: PPUSH
35905: CALL_OW 1
35909: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35910: LD_ADDR_EXP 137
35914: PUSH
35915: LD_EXP 137
35919: PPUSH
35920: LD_VAR 0 4
35924: PPUSH
35925: EMPTY
35926: PPUSH
35927: CALL_OW 1
35931: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35932: LD_ADDR_EXP 138
35936: PUSH
35937: LD_EXP 138
35941: PPUSH
35942: LD_VAR 0 4
35946: PPUSH
35947: EMPTY
35948: PPUSH
35949: CALL_OW 1
35953: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35954: LD_ADDR_EXP 139
35958: PUSH
35959: LD_EXP 139
35963: PPUSH
35964: LD_VAR 0 4
35968: PPUSH
35969: EMPTY
35970: PPUSH
35971: CALL_OW 1
35975: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35976: LD_ADDR_EXP 140
35980: PUSH
35981: LD_EXP 140
35985: PPUSH
35986: LD_VAR 0 4
35990: PPUSH
35991: EMPTY
35992: PPUSH
35993: CALL_OW 1
35997: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35998: LD_ADDR_EXP 141
36002: PUSH
36003: LD_EXP 141
36007: PPUSH
36008: LD_VAR 0 4
36012: PPUSH
36013: LD_INT 0
36015: PPUSH
36016: CALL_OW 1
36020: ST_TO_ADDR
// result := base ;
36021: LD_ADDR_VAR 0 3
36025: PUSH
36026: LD_VAR 0 4
36030: ST_TO_ADDR
// end ;
36031: LD_VAR 0 3
36035: RET
// export function MC_Start ( ) ; var i ; begin
36036: LD_INT 0
36038: PPUSH
36039: PPUSH
// for i = 1 to mc_bases do
36040: LD_ADDR_VAR 0 2
36044: PUSH
36045: DOUBLE
36046: LD_INT 1
36048: DEC
36049: ST_TO_ADDR
36050: LD_EXP 99
36054: PUSH
36055: FOR_TO
36056: IFFALSE 37133
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36058: LD_ADDR_EXP 99
36062: PUSH
36063: LD_EXP 99
36067: PPUSH
36068: LD_VAR 0 2
36072: PPUSH
36073: LD_EXP 99
36077: PUSH
36078: LD_VAR 0 2
36082: ARRAY
36083: PUSH
36084: LD_INT 0
36086: DIFF
36087: PPUSH
36088: CALL_OW 1
36092: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36093: LD_ADDR_EXP 100
36097: PUSH
36098: LD_EXP 100
36102: PPUSH
36103: LD_VAR 0 2
36107: PPUSH
36108: EMPTY
36109: PPUSH
36110: CALL_OW 1
36114: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36115: LD_ADDR_EXP 101
36119: PUSH
36120: LD_EXP 101
36124: PPUSH
36125: LD_VAR 0 2
36129: PPUSH
36130: EMPTY
36131: PPUSH
36132: CALL_OW 1
36136: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36137: LD_ADDR_EXP 102
36141: PUSH
36142: LD_EXP 102
36146: PPUSH
36147: LD_VAR 0 2
36151: PPUSH
36152: EMPTY
36153: PPUSH
36154: CALL_OW 1
36158: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36159: LD_ADDR_EXP 103
36163: PUSH
36164: LD_EXP 103
36168: PPUSH
36169: LD_VAR 0 2
36173: PPUSH
36174: EMPTY
36175: PUSH
36176: EMPTY
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PPUSH
36182: CALL_OW 1
36186: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36187: LD_ADDR_EXP 104
36191: PUSH
36192: LD_EXP 104
36196: PPUSH
36197: LD_VAR 0 2
36201: PPUSH
36202: EMPTY
36203: PPUSH
36204: CALL_OW 1
36208: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36209: LD_ADDR_EXP 131
36213: PUSH
36214: LD_EXP 131
36218: PPUSH
36219: LD_VAR 0 2
36223: PPUSH
36224: EMPTY
36225: PPUSH
36226: CALL_OW 1
36230: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36231: LD_ADDR_EXP 105
36235: PUSH
36236: LD_EXP 105
36240: PPUSH
36241: LD_VAR 0 2
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL_OW 1
36252: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36253: LD_ADDR_EXP 106
36257: PUSH
36258: LD_EXP 106
36262: PPUSH
36263: LD_VAR 0 2
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL_OW 1
36274: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36275: LD_ADDR_EXP 107
36279: PUSH
36280: LD_EXP 107
36284: PPUSH
36285: LD_VAR 0 2
36289: PPUSH
36290: LD_EXP 99
36294: PUSH
36295: LD_VAR 0 2
36299: ARRAY
36300: PPUSH
36301: LD_INT 2
36303: PUSH
36304: LD_INT 30
36306: PUSH
36307: LD_INT 32
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 30
36316: PUSH
36317: LD_INT 33
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: LIST
36328: PPUSH
36329: CALL_OW 72
36333: PPUSH
36334: CALL_OW 1
36338: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36339: LD_ADDR_EXP 108
36343: PUSH
36344: LD_EXP 108
36348: PPUSH
36349: LD_VAR 0 2
36353: PPUSH
36354: LD_EXP 99
36358: PUSH
36359: LD_VAR 0 2
36363: ARRAY
36364: PPUSH
36365: LD_INT 2
36367: PUSH
36368: LD_INT 30
36370: PUSH
36371: LD_INT 32
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 30
36380: PUSH
36381: LD_INT 31
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 58
36395: PUSH
36396: EMPTY
36397: LIST
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PPUSH
36403: CALL_OW 72
36407: PPUSH
36408: CALL_OW 1
36412: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36413: LD_ADDR_EXP 109
36417: PUSH
36418: LD_EXP 109
36422: PPUSH
36423: LD_VAR 0 2
36427: PPUSH
36428: EMPTY
36429: PPUSH
36430: CALL_OW 1
36434: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36435: LD_ADDR_EXP 113
36439: PUSH
36440: LD_EXP 113
36444: PPUSH
36445: LD_VAR 0 2
36449: PPUSH
36450: EMPTY
36451: PPUSH
36452: CALL_OW 1
36456: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36457: LD_ADDR_EXP 112
36461: PUSH
36462: LD_EXP 112
36466: PPUSH
36467: LD_VAR 0 2
36471: PPUSH
36472: EMPTY
36473: PPUSH
36474: CALL_OW 1
36478: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36479: LD_ADDR_EXP 114
36483: PUSH
36484: LD_EXP 114
36488: PPUSH
36489: LD_VAR 0 2
36493: PPUSH
36494: EMPTY
36495: PPUSH
36496: CALL_OW 1
36500: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36501: LD_ADDR_EXP 115
36505: PUSH
36506: LD_EXP 115
36510: PPUSH
36511: LD_VAR 0 2
36515: PPUSH
36516: EMPTY
36517: PPUSH
36518: CALL_OW 1
36522: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36523: LD_ADDR_EXP 116
36527: PUSH
36528: LD_EXP 116
36532: PPUSH
36533: LD_VAR 0 2
36537: PPUSH
36538: EMPTY
36539: PPUSH
36540: CALL_OW 1
36544: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36545: LD_ADDR_EXP 117
36549: PUSH
36550: LD_EXP 117
36554: PPUSH
36555: LD_VAR 0 2
36559: PPUSH
36560: EMPTY
36561: PPUSH
36562: CALL_OW 1
36566: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36567: LD_ADDR_EXP 118
36571: PUSH
36572: LD_EXP 118
36576: PPUSH
36577: LD_VAR 0 2
36581: PPUSH
36582: EMPTY
36583: PPUSH
36584: CALL_OW 1
36588: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36589: LD_ADDR_EXP 119
36593: PUSH
36594: LD_EXP 119
36598: PPUSH
36599: LD_VAR 0 2
36603: PPUSH
36604: EMPTY
36605: PPUSH
36606: CALL_OW 1
36610: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36611: LD_ADDR_EXP 120
36615: PUSH
36616: LD_EXP 120
36620: PPUSH
36621: LD_VAR 0 2
36625: PPUSH
36626: EMPTY
36627: PPUSH
36628: CALL_OW 1
36632: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36633: LD_ADDR_EXP 121
36637: PUSH
36638: LD_EXP 121
36642: PPUSH
36643: LD_VAR 0 2
36647: PPUSH
36648: EMPTY
36649: PPUSH
36650: CALL_OW 1
36654: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36655: LD_ADDR_EXP 110
36659: PUSH
36660: LD_EXP 110
36664: PPUSH
36665: LD_VAR 0 2
36669: PPUSH
36670: LD_INT 0
36672: PPUSH
36673: CALL_OW 1
36677: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36678: LD_ADDR_EXP 123
36682: PUSH
36683: LD_EXP 123
36687: PPUSH
36688: LD_VAR 0 2
36692: PPUSH
36693: LD_INT 0
36695: PPUSH
36696: CALL_OW 1
36700: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36701: LD_ADDR_EXP 111
36705: PUSH
36706: LD_EXP 111
36710: PPUSH
36711: LD_VAR 0 2
36715: PPUSH
36716: EMPTY
36717: PPUSH
36718: CALL_OW 1
36722: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36723: LD_ADDR_EXP 122
36727: PUSH
36728: LD_EXP 122
36732: PPUSH
36733: LD_VAR 0 2
36737: PPUSH
36738: LD_INT 0
36740: PPUSH
36741: CALL_OW 1
36745: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36746: LD_ADDR_EXP 124
36750: PUSH
36751: LD_EXP 124
36755: PPUSH
36756: LD_VAR 0 2
36760: PPUSH
36761: EMPTY
36762: PPUSH
36763: CALL_OW 1
36767: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36768: LD_ADDR_EXP 127
36772: PUSH
36773: LD_EXP 127
36777: PPUSH
36778: LD_VAR 0 2
36782: PPUSH
36783: LD_INT 0
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36791: LD_ADDR_EXP 128
36795: PUSH
36796: LD_EXP 128
36800: PPUSH
36801: LD_VAR 0 2
36805: PPUSH
36806: EMPTY
36807: PPUSH
36808: CALL_OW 1
36812: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36813: LD_ADDR_EXP 129
36817: PUSH
36818: LD_EXP 129
36822: PPUSH
36823: LD_VAR 0 2
36827: PPUSH
36828: EMPTY
36829: PPUSH
36830: CALL_OW 1
36834: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36835: LD_ADDR_EXP 130
36839: PUSH
36840: LD_EXP 130
36844: PPUSH
36845: LD_VAR 0 2
36849: PPUSH
36850: EMPTY
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36857: LD_ADDR_EXP 132
36861: PUSH
36862: LD_EXP 132
36866: PPUSH
36867: LD_VAR 0 2
36871: PPUSH
36872: LD_EXP 99
36876: PUSH
36877: LD_VAR 0 2
36881: ARRAY
36882: PPUSH
36883: LD_INT 2
36885: PUSH
36886: LD_INT 30
36888: PUSH
36889: LD_INT 6
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 30
36898: PUSH
36899: LD_INT 7
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 30
36908: PUSH
36909: LD_INT 8
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: PPUSH
36922: CALL_OW 72
36926: PPUSH
36927: CALL_OW 1
36931: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36932: LD_ADDR_EXP 133
36936: PUSH
36937: LD_EXP 133
36941: PPUSH
36942: LD_VAR 0 2
36946: PPUSH
36947: EMPTY
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36954: LD_ADDR_EXP 134
36958: PUSH
36959: LD_EXP 134
36963: PPUSH
36964: LD_VAR 0 2
36968: PPUSH
36969: EMPTY
36970: PPUSH
36971: CALL_OW 1
36975: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36976: LD_ADDR_EXP 135
36980: PUSH
36981: LD_EXP 135
36985: PPUSH
36986: LD_VAR 0 2
36990: PPUSH
36991: EMPTY
36992: PPUSH
36993: CALL_OW 1
36997: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36998: LD_ADDR_EXP 136
37002: PUSH
37003: LD_EXP 136
37007: PPUSH
37008: LD_VAR 0 2
37012: PPUSH
37013: EMPTY
37014: PPUSH
37015: CALL_OW 1
37019: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37020: LD_ADDR_EXP 137
37024: PUSH
37025: LD_EXP 137
37029: PPUSH
37030: LD_VAR 0 2
37034: PPUSH
37035: EMPTY
37036: PPUSH
37037: CALL_OW 1
37041: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37042: LD_ADDR_EXP 138
37046: PUSH
37047: LD_EXP 138
37051: PPUSH
37052: LD_VAR 0 2
37056: PPUSH
37057: EMPTY
37058: PPUSH
37059: CALL_OW 1
37063: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37064: LD_ADDR_EXP 139
37068: PUSH
37069: LD_EXP 139
37073: PPUSH
37074: LD_VAR 0 2
37078: PPUSH
37079: EMPTY
37080: PPUSH
37081: CALL_OW 1
37085: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37086: LD_ADDR_EXP 140
37090: PUSH
37091: LD_EXP 140
37095: PPUSH
37096: LD_VAR 0 2
37100: PPUSH
37101: EMPTY
37102: PPUSH
37103: CALL_OW 1
37107: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37108: LD_ADDR_EXP 141
37112: PUSH
37113: LD_EXP 141
37117: PPUSH
37118: LD_VAR 0 2
37122: PPUSH
37123: LD_INT 0
37125: PPUSH
37126: CALL_OW 1
37130: ST_TO_ADDR
// end ;
37131: GO 36055
37133: POP
37134: POP
// MC_InitSides ( ) ;
37135: CALL 37421 0 0
// MC_InitResearch ( ) ;
37139: CALL 37160 0 0
// CustomInitMacro ( ) ;
37143: CALL 444 0 0
// skirmish := true ;
37147: LD_ADDR_EXP 97
37151: PUSH
37152: LD_INT 1
37154: ST_TO_ADDR
// end ;
37155: LD_VAR 0 1
37159: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37160: LD_INT 0
37162: PPUSH
37163: PPUSH
37164: PPUSH
37165: PPUSH
37166: PPUSH
37167: PPUSH
// if not mc_bases then
37168: LD_EXP 99
37172: NOT
37173: IFFALSE 37177
// exit ;
37175: GO 37416
// for i = 1 to 8 do
37177: LD_ADDR_VAR 0 2
37181: PUSH
37182: DOUBLE
37183: LD_INT 1
37185: DEC
37186: ST_TO_ADDR
37187: LD_INT 8
37189: PUSH
37190: FOR_TO
37191: IFFALSE 37217
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37193: LD_ADDR_EXP 126
37197: PUSH
37198: LD_EXP 126
37202: PPUSH
37203: LD_VAR 0 2
37207: PPUSH
37208: EMPTY
37209: PPUSH
37210: CALL_OW 1
37214: ST_TO_ADDR
37215: GO 37190
37217: POP
37218: POP
// tmp := [ ] ;
37219: LD_ADDR_VAR 0 5
37223: PUSH
37224: EMPTY
37225: ST_TO_ADDR
// for i = 1 to mc_sides do
37226: LD_ADDR_VAR 0 2
37230: PUSH
37231: DOUBLE
37232: LD_INT 1
37234: DEC
37235: ST_TO_ADDR
37236: LD_EXP 125
37240: PUSH
37241: FOR_TO
37242: IFFALSE 37300
// if not mc_sides [ i ] in tmp then
37244: LD_EXP 125
37248: PUSH
37249: LD_VAR 0 2
37253: ARRAY
37254: PUSH
37255: LD_VAR 0 5
37259: IN
37260: NOT
37261: IFFALSE 37298
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37263: LD_ADDR_VAR 0 5
37267: PUSH
37268: LD_VAR 0 5
37272: PPUSH
37273: LD_VAR 0 5
37277: PUSH
37278: LD_INT 1
37280: PLUS
37281: PPUSH
37282: LD_EXP 125
37286: PUSH
37287: LD_VAR 0 2
37291: ARRAY
37292: PPUSH
37293: CALL_OW 2
37297: ST_TO_ADDR
37298: GO 37241
37300: POP
37301: POP
// if not tmp then
37302: LD_VAR 0 5
37306: NOT
37307: IFFALSE 37311
// exit ;
37309: GO 37416
// for j in tmp do
37311: LD_ADDR_VAR 0 3
37315: PUSH
37316: LD_VAR 0 5
37320: PUSH
37321: FOR_IN
37322: IFFALSE 37414
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37324: LD_ADDR_VAR 0 6
37328: PUSH
37329: LD_INT 22
37331: PUSH
37332: LD_VAR 0 3
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PPUSH
37341: CALL_OW 69
37345: ST_TO_ADDR
// if not un then
37346: LD_VAR 0 6
37350: NOT
37351: IFFALSE 37355
// continue ;
37353: GO 37321
// nation := GetNation ( un [ 1 ] ) ;
37355: LD_ADDR_VAR 0 4
37359: PUSH
37360: LD_VAR 0 6
37364: PUSH
37365: LD_INT 1
37367: ARRAY
37368: PPUSH
37369: CALL_OW 248
37373: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37374: LD_ADDR_EXP 126
37378: PUSH
37379: LD_EXP 126
37383: PPUSH
37384: LD_VAR 0 3
37388: PPUSH
37389: LD_VAR 0 3
37393: PPUSH
37394: LD_VAR 0 4
37398: PPUSH
37399: LD_INT 1
37401: PPUSH
37402: CALL 64130 0 3
37406: PPUSH
37407: CALL_OW 1
37411: ST_TO_ADDR
// end ;
37412: GO 37321
37414: POP
37415: POP
// end ;
37416: LD_VAR 0 1
37420: RET
// export function MC_InitSides ( ) ; var i ; begin
37421: LD_INT 0
37423: PPUSH
37424: PPUSH
// if not mc_bases then
37425: LD_EXP 99
37429: NOT
37430: IFFALSE 37434
// exit ;
37432: GO 37508
// for i = 1 to mc_bases do
37434: LD_ADDR_VAR 0 2
37438: PUSH
37439: DOUBLE
37440: LD_INT 1
37442: DEC
37443: ST_TO_ADDR
37444: LD_EXP 99
37448: PUSH
37449: FOR_TO
37450: IFFALSE 37506
// if mc_bases [ i ] then
37452: LD_EXP 99
37456: PUSH
37457: LD_VAR 0 2
37461: ARRAY
37462: IFFALSE 37504
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37464: LD_ADDR_EXP 125
37468: PUSH
37469: LD_EXP 125
37473: PPUSH
37474: LD_VAR 0 2
37478: PPUSH
37479: LD_EXP 99
37483: PUSH
37484: LD_VAR 0 2
37488: ARRAY
37489: PUSH
37490: LD_INT 1
37492: ARRAY
37493: PPUSH
37494: CALL_OW 255
37498: PPUSH
37499: CALL_OW 1
37503: ST_TO_ADDR
37504: GO 37449
37506: POP
37507: POP
// end ;
37508: LD_VAR 0 1
37512: RET
// every 0 0$01 trigger skirmish do
37513: LD_EXP 97
37517: IFFALSE 37671
37519: GO 37521
37521: DISABLE
// begin enable ;
37522: ENABLE
// MC_CheckBuildings ( ) ;
37523: CALL 42169 0 0
// MC_CheckPeopleLife ( ) ;
37527: CALL 42294 0 0
// RaiseSailEvent ( 100 ) ;
37531: LD_INT 100
37533: PPUSH
37534: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37538: LD_INT 103
37540: PPUSH
37541: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37545: LD_INT 104
37547: PPUSH
37548: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37552: LD_INT 105
37554: PPUSH
37555: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37559: LD_INT 106
37561: PPUSH
37562: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37566: LD_INT 107
37568: PPUSH
37569: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37573: LD_INT 108
37575: PPUSH
37576: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37580: LD_INT 109
37582: PPUSH
37583: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37587: LD_INT 110
37589: PPUSH
37590: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37594: LD_INT 111
37596: PPUSH
37597: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37601: LD_INT 112
37603: PPUSH
37604: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37608: LD_INT 113
37610: PPUSH
37611: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37615: LD_INT 120
37617: PPUSH
37618: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37622: LD_INT 121
37624: PPUSH
37625: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37629: LD_INT 122
37631: PPUSH
37632: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37636: LD_INT 123
37638: PPUSH
37639: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37643: LD_INT 124
37645: PPUSH
37646: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37650: LD_INT 125
37652: PPUSH
37653: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37657: LD_INT 126
37659: PPUSH
37660: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37664: LD_INT 200
37666: PPUSH
37667: CALL_OW 427
// end ;
37671: END
// on SailEvent ( event ) do begin if event < 100 then
37672: LD_VAR 0 1
37676: PUSH
37677: LD_INT 100
37679: LESS
37680: IFFALSE 37691
// CustomEvent ( event ) ;
37682: LD_VAR 0 1
37686: PPUSH
37687: CALL 32354 0 1
// if event = 100 then
37691: LD_VAR 0 1
37695: PUSH
37696: LD_INT 100
37698: EQUAL
37699: IFFALSE 37705
// MC_ClassManager ( ) ;
37701: CALL 38097 0 0
// if event = 101 then
37705: LD_VAR 0 1
37709: PUSH
37710: LD_INT 101
37712: EQUAL
37713: IFFALSE 37719
// MC_RepairBuildings ( ) ;
37715: CALL 42890 0 0
// if event = 102 then
37719: LD_VAR 0 1
37723: PUSH
37724: LD_INT 102
37726: EQUAL
37727: IFFALSE 37733
// MC_Heal ( ) ;
37729: CALL 43622 0 0
// if event = 103 then
37733: LD_VAR 0 1
37737: PUSH
37738: LD_INT 103
37740: EQUAL
37741: IFFALSE 37747
// MC_Build ( ) ;
37743: CALL 44044 0 0
// if event = 104 then
37747: LD_VAR 0 1
37751: PUSH
37752: LD_INT 104
37754: EQUAL
37755: IFFALSE 37761
// MC_TurretWeapon ( ) ;
37757: CALL 45657 0 0
// if event = 105 then
37761: LD_VAR 0 1
37765: PUSH
37766: LD_INT 105
37768: EQUAL
37769: IFFALSE 37775
// MC_BuildUpgrade ( ) ;
37771: CALL 45208 0 0
// if event = 106 then
37775: LD_VAR 0 1
37779: PUSH
37780: LD_INT 106
37782: EQUAL
37783: IFFALSE 37789
// MC_PlantMines ( ) ;
37785: CALL 46087 0 0
// if event = 107 then
37789: LD_VAR 0 1
37793: PUSH
37794: LD_INT 107
37796: EQUAL
37797: IFFALSE 37803
// MC_CollectCrates ( ) ;
37799: CALL 47121 0 0
// if event = 108 then
37803: LD_VAR 0 1
37807: PUSH
37808: LD_INT 108
37810: EQUAL
37811: IFFALSE 37817
// MC_LinkRemoteControl ( ) ;
37813: CALL 48897 0 0
// if event = 109 then
37817: LD_VAR 0 1
37821: PUSH
37822: LD_INT 109
37824: EQUAL
37825: IFFALSE 37831
// MC_ProduceVehicle ( ) ;
37827: CALL 49078 0 0
// if event = 110 then
37831: LD_VAR 0 1
37835: PUSH
37836: LD_INT 110
37838: EQUAL
37839: IFFALSE 37845
// MC_SendAttack ( ) ;
37841: CALL 49544 0 0
// if event = 111 then
37845: LD_VAR 0 1
37849: PUSH
37850: LD_INT 111
37852: EQUAL
37853: IFFALSE 37859
// MC_Defend ( ) ;
37855: CALL 49652 0 0
// if event = 112 then
37859: LD_VAR 0 1
37863: PUSH
37864: LD_INT 112
37866: EQUAL
37867: IFFALSE 37873
// MC_Research ( ) ;
37869: CALL 50257 0 0
// if event = 113 then
37873: LD_VAR 0 1
37877: PUSH
37878: LD_INT 113
37880: EQUAL
37881: IFFALSE 37887
// MC_MinesTrigger ( ) ;
37883: CALL 51371 0 0
// if event = 120 then
37887: LD_VAR 0 1
37891: PUSH
37892: LD_INT 120
37894: EQUAL
37895: IFFALSE 37901
// MC_RepairVehicle ( ) ;
37897: CALL 51470 0 0
// if event = 121 then
37901: LD_VAR 0 1
37905: PUSH
37906: LD_INT 121
37908: EQUAL
37909: IFFALSE 37915
// MC_TameApe ( ) ;
37911: CALL 52200 0 0
// if event = 122 then
37915: LD_VAR 0 1
37919: PUSH
37920: LD_INT 122
37922: EQUAL
37923: IFFALSE 37929
// MC_ChangeApeClass ( ) ;
37925: CALL 53029 0 0
// if event = 123 then
37929: LD_VAR 0 1
37933: PUSH
37934: LD_INT 123
37936: EQUAL
37937: IFFALSE 37943
// MC_Bazooka ( ) ;
37939: CALL 53679 0 0
// if event = 124 then
37943: LD_VAR 0 1
37947: PUSH
37948: LD_INT 124
37950: EQUAL
37951: IFFALSE 37957
// MC_TeleportExit ( ) ;
37953: CALL 53877 0 0
// if event = 125 then
37957: LD_VAR 0 1
37961: PUSH
37962: LD_INT 125
37964: EQUAL
37965: IFFALSE 37971
// MC_Deposits ( ) ;
37967: CALL 54524 0 0
// if event = 126 then
37971: LD_VAR 0 1
37975: PUSH
37976: LD_INT 126
37978: EQUAL
37979: IFFALSE 37985
// MC_RemoteDriver ( ) ;
37981: CALL 55149 0 0
// if event = 200 then
37985: LD_VAR 0 1
37989: PUSH
37990: LD_INT 200
37992: EQUAL
37993: IFFALSE 37999
// MC_Idle ( ) ;
37995: CALL 57098 0 0
// end ;
37999: PPOPN 1
38001: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38002: LD_INT 0
38004: PPUSH
38005: PPUSH
// if not mc_bases [ base ] or not tag then
38006: LD_EXP 99
38010: PUSH
38011: LD_VAR 0 1
38015: ARRAY
38016: NOT
38017: PUSH
38018: LD_VAR 0 2
38022: NOT
38023: OR
38024: IFFALSE 38028
// exit ;
38026: GO 38092
// for i in mc_bases [ base ] union mc_ape [ base ] do
38028: LD_ADDR_VAR 0 4
38032: PUSH
38033: LD_EXP 99
38037: PUSH
38038: LD_VAR 0 1
38042: ARRAY
38043: PUSH
38044: LD_EXP 128
38048: PUSH
38049: LD_VAR 0 1
38053: ARRAY
38054: UNION
38055: PUSH
38056: FOR_IN
38057: IFFALSE 38090
// if GetTag ( i ) = tag then
38059: LD_VAR 0 4
38063: PPUSH
38064: CALL_OW 110
38068: PUSH
38069: LD_VAR 0 2
38073: EQUAL
38074: IFFALSE 38088
// SetTag ( i , 0 ) ;
38076: LD_VAR 0 4
38080: PPUSH
38081: LD_INT 0
38083: PPUSH
38084: CALL_OW 109
38088: GO 38056
38090: POP
38091: POP
// end ;
38092: LD_VAR 0 3
38096: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38097: LD_INT 0
38099: PPUSH
38100: PPUSH
38101: PPUSH
38102: PPUSH
38103: PPUSH
38104: PPUSH
38105: PPUSH
38106: PPUSH
// if not mc_bases then
38107: LD_EXP 99
38111: NOT
38112: IFFALSE 38116
// exit ;
38114: GO 38574
// for i = 1 to mc_bases do
38116: LD_ADDR_VAR 0 2
38120: PUSH
38121: DOUBLE
38122: LD_INT 1
38124: DEC
38125: ST_TO_ADDR
38126: LD_EXP 99
38130: PUSH
38131: FOR_TO
38132: IFFALSE 38572
// begin tmp := MC_ClassCheckReq ( i ) ;
38134: LD_ADDR_VAR 0 4
38138: PUSH
38139: LD_VAR 0 2
38143: PPUSH
38144: CALL 38579 0 1
38148: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38149: LD_ADDR_EXP 140
38153: PUSH
38154: LD_EXP 140
38158: PPUSH
38159: LD_VAR 0 2
38163: PPUSH
38164: LD_VAR 0 4
38168: PPUSH
38169: CALL_OW 1
38173: ST_TO_ADDR
// if not tmp then
38174: LD_VAR 0 4
38178: NOT
38179: IFFALSE 38183
// continue ;
38181: GO 38131
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38183: LD_ADDR_VAR 0 6
38187: PUSH
38188: LD_EXP 99
38192: PUSH
38193: LD_VAR 0 2
38197: ARRAY
38198: PPUSH
38199: LD_INT 2
38201: PUSH
38202: LD_INT 30
38204: PUSH
38205: LD_INT 4
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 30
38214: PUSH
38215: LD_INT 5
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: PPUSH
38227: CALL_OW 72
38231: PUSH
38232: LD_EXP 99
38236: PUSH
38237: LD_VAR 0 2
38241: ARRAY
38242: PPUSH
38243: LD_INT 2
38245: PUSH
38246: LD_INT 30
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 30
38258: PUSH
38259: LD_INT 1
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: PPUSH
38271: CALL_OW 72
38275: PUSH
38276: LD_EXP 99
38280: PUSH
38281: LD_VAR 0 2
38285: ARRAY
38286: PPUSH
38287: LD_INT 30
38289: PUSH
38290: LD_INT 3
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PPUSH
38297: CALL_OW 72
38301: PUSH
38302: LD_EXP 99
38306: PUSH
38307: LD_VAR 0 2
38311: ARRAY
38312: PPUSH
38313: LD_INT 2
38315: PUSH
38316: LD_INT 30
38318: PUSH
38319: LD_INT 6
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 30
38328: PUSH
38329: LD_INT 7
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 30
38338: PUSH
38339: LD_INT 8
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: LIST
38350: LIST
38351: PPUSH
38352: CALL_OW 72
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: ST_TO_ADDR
// for j = 1 to 4 do
38363: LD_ADDR_VAR 0 3
38367: PUSH
38368: DOUBLE
38369: LD_INT 1
38371: DEC
38372: ST_TO_ADDR
38373: LD_INT 4
38375: PUSH
38376: FOR_TO
38377: IFFALSE 38568
// begin if not tmp [ j ] then
38379: LD_VAR 0 4
38383: PUSH
38384: LD_VAR 0 3
38388: ARRAY
38389: NOT
38390: IFFALSE 38394
// continue ;
38392: GO 38376
// for p in tmp [ j ] do
38394: LD_ADDR_VAR 0 5
38398: PUSH
38399: LD_VAR 0 4
38403: PUSH
38404: LD_VAR 0 3
38408: ARRAY
38409: PUSH
38410: FOR_IN
38411: IFFALSE 38564
// begin if not b [ j ] then
38413: LD_VAR 0 6
38417: PUSH
38418: LD_VAR 0 3
38422: ARRAY
38423: NOT
38424: IFFALSE 38428
// break ;
38426: GO 38564
// e := 0 ;
38428: LD_ADDR_VAR 0 7
38432: PUSH
38433: LD_INT 0
38435: ST_TO_ADDR
// for k in b [ j ] do
38436: LD_ADDR_VAR 0 8
38440: PUSH
38441: LD_VAR 0 6
38445: PUSH
38446: LD_VAR 0 3
38450: ARRAY
38451: PUSH
38452: FOR_IN
38453: IFFALSE 38480
// if IsNotFull ( k ) then
38455: LD_VAR 0 8
38459: PPUSH
38460: CALL 68570 0 1
38464: IFFALSE 38478
// begin e := k ;
38466: LD_ADDR_VAR 0 7
38470: PUSH
38471: LD_VAR 0 8
38475: ST_TO_ADDR
// break ;
38476: GO 38480
// end ;
38478: GO 38452
38480: POP
38481: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38482: LD_VAR 0 7
38486: PUSH
38487: LD_VAR 0 5
38491: PPUSH
38492: LD_VAR 0 7
38496: PPUSH
38497: CALL 105689 0 2
38501: NOT
38502: AND
38503: IFFALSE 38562
// begin if IsInUnit ( p ) then
38505: LD_VAR 0 5
38509: PPUSH
38510: CALL_OW 310
38514: IFFALSE 38525
// ComExitBuilding ( p ) ;
38516: LD_VAR 0 5
38520: PPUSH
38521: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38525: LD_VAR 0 5
38529: PPUSH
38530: LD_VAR 0 7
38534: PPUSH
38535: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38539: LD_VAR 0 5
38543: PPUSH
38544: LD_VAR 0 3
38548: PPUSH
38549: CALL_OW 183
// AddComExitBuilding ( p ) ;
38553: LD_VAR 0 5
38557: PPUSH
38558: CALL_OW 182
// end ; end ;
38562: GO 38410
38564: POP
38565: POP
// end ;
38566: GO 38376
38568: POP
38569: POP
// end ;
38570: GO 38131
38572: POP
38573: POP
// end ;
38574: LD_VAR 0 1
38578: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38579: LD_INT 0
38581: PPUSH
38582: PPUSH
38583: PPUSH
38584: PPUSH
38585: PPUSH
38586: PPUSH
38587: PPUSH
38588: PPUSH
38589: PPUSH
38590: PPUSH
38591: PPUSH
38592: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38593: LD_VAR 0 1
38597: NOT
38598: PUSH
38599: LD_EXP 99
38603: PUSH
38604: LD_VAR 0 1
38608: ARRAY
38609: NOT
38610: OR
38611: PUSH
38612: LD_EXP 99
38616: PUSH
38617: LD_VAR 0 1
38621: ARRAY
38622: PPUSH
38623: LD_INT 2
38625: PUSH
38626: LD_INT 30
38628: PUSH
38629: LD_INT 0
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 30
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: LIST
38650: PPUSH
38651: CALL_OW 72
38655: NOT
38656: OR
38657: IFFALSE 38661
// exit ;
38659: GO 42164
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38661: LD_ADDR_VAR 0 4
38665: PUSH
38666: LD_EXP 99
38670: PUSH
38671: LD_VAR 0 1
38675: ARRAY
38676: PPUSH
38677: LD_INT 2
38679: PUSH
38680: LD_INT 25
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 25
38692: PUSH
38693: LD_INT 2
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 25
38702: PUSH
38703: LD_INT 3
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 25
38712: PUSH
38713: LD_INT 4
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 25
38722: PUSH
38723: LD_INT 5
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 25
38732: PUSH
38733: LD_INT 8
38735: PUSH
38736: EMPTY
38737: LIST
38738: LIST
38739: PUSH
38740: LD_INT 25
38742: PUSH
38743: LD_INT 9
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: PPUSH
38760: CALL_OW 72
38764: ST_TO_ADDR
// if not tmp then
38765: LD_VAR 0 4
38769: NOT
38770: IFFALSE 38774
// exit ;
38772: GO 42164
// for i in tmp do
38774: LD_ADDR_VAR 0 3
38778: PUSH
38779: LD_VAR 0 4
38783: PUSH
38784: FOR_IN
38785: IFFALSE 38816
// if GetTag ( i ) then
38787: LD_VAR 0 3
38791: PPUSH
38792: CALL_OW 110
38796: IFFALSE 38814
// tmp := tmp diff i ;
38798: LD_ADDR_VAR 0 4
38802: PUSH
38803: LD_VAR 0 4
38807: PUSH
38808: LD_VAR 0 3
38812: DIFF
38813: ST_TO_ADDR
38814: GO 38784
38816: POP
38817: POP
// if not tmp then
38818: LD_VAR 0 4
38822: NOT
38823: IFFALSE 38827
// exit ;
38825: GO 42164
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38827: LD_ADDR_VAR 0 5
38831: PUSH
38832: LD_EXP 99
38836: PUSH
38837: LD_VAR 0 1
38841: ARRAY
38842: PPUSH
38843: LD_INT 2
38845: PUSH
38846: LD_INT 25
38848: PUSH
38849: LD_INT 1
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 25
38858: PUSH
38859: LD_INT 5
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 25
38868: PUSH
38869: LD_INT 8
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 25
38878: PUSH
38879: LD_INT 9
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: PPUSH
38893: CALL_OW 72
38897: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38898: LD_ADDR_VAR 0 6
38902: PUSH
38903: LD_EXP 99
38907: PUSH
38908: LD_VAR 0 1
38912: ARRAY
38913: PPUSH
38914: LD_INT 25
38916: PUSH
38917: LD_INT 2
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PPUSH
38924: CALL_OW 72
38928: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38929: LD_ADDR_VAR 0 7
38933: PUSH
38934: LD_EXP 99
38938: PUSH
38939: LD_VAR 0 1
38943: ARRAY
38944: PPUSH
38945: LD_INT 25
38947: PUSH
38948: LD_INT 3
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PPUSH
38955: CALL_OW 72
38959: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38960: LD_ADDR_VAR 0 8
38964: PUSH
38965: LD_EXP 99
38969: PUSH
38970: LD_VAR 0 1
38974: ARRAY
38975: PPUSH
38976: LD_INT 25
38978: PUSH
38979: LD_INT 4
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 24
38988: PUSH
38989: LD_INT 251
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PPUSH
39000: CALL_OW 72
39004: ST_TO_ADDR
// if mc_scan [ base ] then
39005: LD_EXP 122
39009: PUSH
39010: LD_VAR 0 1
39014: ARRAY
39015: IFFALSE 39476
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39017: LD_ADDR_EXP 141
39021: PUSH
39022: LD_EXP 141
39026: PPUSH
39027: LD_VAR 0 1
39031: PPUSH
39032: LD_INT 4
39034: PPUSH
39035: CALL_OW 1
39039: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39040: LD_ADDR_VAR 0 12
39044: PUSH
39045: LD_EXP 99
39049: PUSH
39050: LD_VAR 0 1
39054: ARRAY
39055: PPUSH
39056: LD_INT 2
39058: PUSH
39059: LD_INT 30
39061: PUSH
39062: LD_INT 4
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 30
39071: PUSH
39072: LD_INT 5
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: LIST
39083: PPUSH
39084: CALL_OW 72
39088: ST_TO_ADDR
// if not b then
39089: LD_VAR 0 12
39093: NOT
39094: IFFALSE 39098
// exit ;
39096: GO 42164
// p := [ ] ;
39098: LD_ADDR_VAR 0 11
39102: PUSH
39103: EMPTY
39104: ST_TO_ADDR
// if sci >= 2 then
39105: LD_VAR 0 8
39109: PUSH
39110: LD_INT 2
39112: GREATEREQUAL
39113: IFFALSE 39144
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39115: LD_ADDR_VAR 0 8
39119: PUSH
39120: LD_VAR 0 8
39124: PUSH
39125: LD_INT 1
39127: ARRAY
39128: PUSH
39129: LD_VAR 0 8
39133: PUSH
39134: LD_INT 2
39136: ARRAY
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: ST_TO_ADDR
39142: GO 39205
// if sci = 1 then
39144: LD_VAR 0 8
39148: PUSH
39149: LD_INT 1
39151: EQUAL
39152: IFFALSE 39173
// sci := [ sci [ 1 ] ] else
39154: LD_ADDR_VAR 0 8
39158: PUSH
39159: LD_VAR 0 8
39163: PUSH
39164: LD_INT 1
39166: ARRAY
39167: PUSH
39168: EMPTY
39169: LIST
39170: ST_TO_ADDR
39171: GO 39205
// if sci = 0 then
39173: LD_VAR 0 8
39177: PUSH
39178: LD_INT 0
39180: EQUAL
39181: IFFALSE 39205
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39183: LD_ADDR_VAR 0 11
39187: PUSH
39188: LD_VAR 0 4
39192: PPUSH
39193: LD_INT 4
39195: PPUSH
39196: CALL 105552 0 2
39200: PUSH
39201: LD_INT 1
39203: ARRAY
39204: ST_TO_ADDR
// if eng > 4 then
39205: LD_VAR 0 6
39209: PUSH
39210: LD_INT 4
39212: GREATER
39213: IFFALSE 39259
// for i = eng downto 4 do
39215: LD_ADDR_VAR 0 3
39219: PUSH
39220: DOUBLE
39221: LD_VAR 0 6
39225: INC
39226: ST_TO_ADDR
39227: LD_INT 4
39229: PUSH
39230: FOR_DOWNTO
39231: IFFALSE 39257
// eng := eng diff eng [ i ] ;
39233: LD_ADDR_VAR 0 6
39237: PUSH
39238: LD_VAR 0 6
39242: PUSH
39243: LD_VAR 0 6
39247: PUSH
39248: LD_VAR 0 3
39252: ARRAY
39253: DIFF
39254: ST_TO_ADDR
39255: GO 39230
39257: POP
39258: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39259: LD_ADDR_VAR 0 4
39263: PUSH
39264: LD_VAR 0 4
39268: PUSH
39269: LD_VAR 0 5
39273: PUSH
39274: LD_VAR 0 6
39278: UNION
39279: PUSH
39280: LD_VAR 0 7
39284: UNION
39285: PUSH
39286: LD_VAR 0 8
39290: UNION
39291: DIFF
39292: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39293: LD_ADDR_VAR 0 13
39297: PUSH
39298: LD_EXP 99
39302: PUSH
39303: LD_VAR 0 1
39307: ARRAY
39308: PPUSH
39309: LD_INT 2
39311: PUSH
39312: LD_INT 30
39314: PUSH
39315: LD_INT 32
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 30
39324: PUSH
39325: LD_INT 31
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: LIST
39336: PPUSH
39337: CALL_OW 72
39341: PUSH
39342: LD_EXP 99
39346: PUSH
39347: LD_VAR 0 1
39351: ARRAY
39352: PPUSH
39353: LD_INT 2
39355: PUSH
39356: LD_INT 30
39358: PUSH
39359: LD_INT 4
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 30
39368: PUSH
39369: LD_INT 5
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: LIST
39380: PPUSH
39381: CALL_OW 72
39385: PUSH
39386: LD_INT 6
39388: MUL
39389: PLUS
39390: ST_TO_ADDR
// if bcount < tmp then
39391: LD_VAR 0 13
39395: PUSH
39396: LD_VAR 0 4
39400: LESS
39401: IFFALSE 39447
// for i = tmp downto bcount do
39403: LD_ADDR_VAR 0 3
39407: PUSH
39408: DOUBLE
39409: LD_VAR 0 4
39413: INC
39414: ST_TO_ADDR
39415: LD_VAR 0 13
39419: PUSH
39420: FOR_DOWNTO
39421: IFFALSE 39445
// tmp := Delete ( tmp , tmp ) ;
39423: LD_ADDR_VAR 0 4
39427: PUSH
39428: LD_VAR 0 4
39432: PPUSH
39433: LD_VAR 0 4
39437: PPUSH
39438: CALL_OW 3
39442: ST_TO_ADDR
39443: GO 39420
39445: POP
39446: POP
// result := [ tmp , 0 , 0 , p ] ;
39447: LD_ADDR_VAR 0 2
39451: PUSH
39452: LD_VAR 0 4
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 0
39462: PUSH
39463: LD_VAR 0 11
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: LIST
39472: LIST
39473: ST_TO_ADDR
// exit ;
39474: GO 42164
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39476: LD_EXP 99
39480: PUSH
39481: LD_VAR 0 1
39485: ARRAY
39486: PPUSH
39487: LD_INT 2
39489: PUSH
39490: LD_INT 30
39492: PUSH
39493: LD_INT 6
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 30
39502: PUSH
39503: LD_INT 7
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 30
39512: PUSH
39513: LD_INT 8
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: PPUSH
39526: CALL_OW 72
39530: NOT
39531: PUSH
39532: LD_EXP 99
39536: PUSH
39537: LD_VAR 0 1
39541: ARRAY
39542: PPUSH
39543: LD_INT 30
39545: PUSH
39546: LD_INT 3
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PPUSH
39553: CALL_OW 72
39557: NOT
39558: AND
39559: IFFALSE 39631
// begin if eng = tmp then
39561: LD_VAR 0 6
39565: PUSH
39566: LD_VAR 0 4
39570: EQUAL
39571: IFFALSE 39575
// exit ;
39573: GO 42164
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39575: LD_ADDR_EXP 141
39579: PUSH
39580: LD_EXP 141
39584: PPUSH
39585: LD_VAR 0 1
39589: PPUSH
39590: LD_INT 1
39592: PPUSH
39593: CALL_OW 1
39597: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39598: LD_ADDR_VAR 0 2
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_VAR 0 4
39610: PUSH
39611: LD_VAR 0 6
39615: DIFF
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: LD_INT 0
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: ST_TO_ADDR
// exit ;
39629: GO 42164
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39631: LD_EXP 126
39635: PUSH
39636: LD_EXP 125
39640: PUSH
39641: LD_VAR 0 1
39645: ARRAY
39646: ARRAY
39647: PUSH
39648: LD_EXP 99
39652: PUSH
39653: LD_VAR 0 1
39657: ARRAY
39658: PPUSH
39659: LD_INT 2
39661: PUSH
39662: LD_INT 30
39664: PUSH
39665: LD_INT 6
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 30
39674: PUSH
39675: LD_INT 7
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 30
39684: PUSH
39685: LD_INT 8
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: PPUSH
39698: CALL_OW 72
39702: AND
39703: PUSH
39704: LD_EXP 99
39708: PUSH
39709: LD_VAR 0 1
39713: ARRAY
39714: PPUSH
39715: LD_INT 30
39717: PUSH
39718: LD_INT 3
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PPUSH
39725: CALL_OW 72
39729: NOT
39730: AND
39731: IFFALSE 39945
// begin if sci >= 6 then
39733: LD_VAR 0 8
39737: PUSH
39738: LD_INT 6
39740: GREATEREQUAL
39741: IFFALSE 39745
// exit ;
39743: GO 42164
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39745: LD_ADDR_EXP 141
39749: PUSH
39750: LD_EXP 141
39754: PPUSH
39755: LD_VAR 0 1
39759: PPUSH
39760: LD_INT 2
39762: PPUSH
39763: CALL_OW 1
39767: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39768: LD_ADDR_VAR 0 9
39772: PUSH
39773: LD_VAR 0 4
39777: PUSH
39778: LD_VAR 0 8
39782: DIFF
39783: PPUSH
39784: LD_INT 4
39786: PPUSH
39787: CALL 105552 0 2
39791: ST_TO_ADDR
// p := [ ] ;
39792: LD_ADDR_VAR 0 11
39796: PUSH
39797: EMPTY
39798: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39799: LD_VAR 0 8
39803: PUSH
39804: LD_INT 6
39806: LESS
39807: PUSH
39808: LD_VAR 0 9
39812: PUSH
39813: LD_INT 6
39815: GREATER
39816: AND
39817: IFFALSE 39898
// begin for i = 1 to 6 - sci do
39819: LD_ADDR_VAR 0 3
39823: PUSH
39824: DOUBLE
39825: LD_INT 1
39827: DEC
39828: ST_TO_ADDR
39829: LD_INT 6
39831: PUSH
39832: LD_VAR 0 8
39836: MINUS
39837: PUSH
39838: FOR_TO
39839: IFFALSE 39894
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39841: LD_ADDR_VAR 0 11
39845: PUSH
39846: LD_VAR 0 11
39850: PPUSH
39851: LD_VAR 0 11
39855: PUSH
39856: LD_INT 1
39858: PLUS
39859: PPUSH
39860: LD_VAR 0 9
39864: PUSH
39865: LD_INT 1
39867: ARRAY
39868: PPUSH
39869: CALL_OW 2
39873: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39874: LD_ADDR_VAR 0 9
39878: PUSH
39879: LD_VAR 0 9
39883: PPUSH
39884: LD_INT 1
39886: PPUSH
39887: CALL_OW 3
39891: ST_TO_ADDR
// end ;
39892: GO 39838
39894: POP
39895: POP
// end else
39896: GO 39918
// if sort then
39898: LD_VAR 0 9
39902: IFFALSE 39918
// p := sort [ 1 ] ;
39904: LD_ADDR_VAR 0 11
39908: PUSH
39909: LD_VAR 0 9
39913: PUSH
39914: LD_INT 1
39916: ARRAY
39917: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39918: LD_ADDR_VAR 0 2
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_VAR 0 11
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: ST_TO_ADDR
// exit ;
39943: GO 42164
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39945: LD_EXP 126
39949: PUSH
39950: LD_EXP 125
39954: PUSH
39955: LD_VAR 0 1
39959: ARRAY
39960: ARRAY
39961: PUSH
39962: LD_EXP 99
39966: PUSH
39967: LD_VAR 0 1
39971: ARRAY
39972: PPUSH
39973: LD_INT 2
39975: PUSH
39976: LD_INT 30
39978: PUSH
39979: LD_INT 6
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 30
39988: PUSH
39989: LD_INT 7
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 30
39998: PUSH
39999: LD_INT 8
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: PPUSH
40012: CALL_OW 72
40016: AND
40017: PUSH
40018: LD_EXP 99
40022: PUSH
40023: LD_VAR 0 1
40027: ARRAY
40028: PPUSH
40029: LD_INT 30
40031: PUSH
40032: LD_INT 3
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PPUSH
40039: CALL_OW 72
40043: AND
40044: IFFALSE 40778
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40046: LD_ADDR_EXP 141
40050: PUSH
40051: LD_EXP 141
40055: PPUSH
40056: LD_VAR 0 1
40060: PPUSH
40061: LD_INT 3
40063: PPUSH
40064: CALL_OW 1
40068: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40069: LD_ADDR_VAR 0 2
40073: PUSH
40074: LD_INT 0
40076: PUSH
40077: LD_INT 0
40079: PUSH
40080: LD_INT 0
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: ST_TO_ADDR
// if not eng then
40092: LD_VAR 0 6
40096: NOT
40097: IFFALSE 40160
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40099: LD_ADDR_VAR 0 11
40103: PUSH
40104: LD_VAR 0 4
40108: PPUSH
40109: LD_INT 2
40111: PPUSH
40112: CALL 105552 0 2
40116: PUSH
40117: LD_INT 1
40119: ARRAY
40120: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40121: LD_ADDR_VAR 0 2
40125: PUSH
40126: LD_VAR 0 2
40130: PPUSH
40131: LD_INT 2
40133: PPUSH
40134: LD_VAR 0 11
40138: PPUSH
40139: CALL_OW 1
40143: ST_TO_ADDR
// tmp := tmp diff p ;
40144: LD_ADDR_VAR 0 4
40148: PUSH
40149: LD_VAR 0 4
40153: PUSH
40154: LD_VAR 0 11
40158: DIFF
40159: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40160: LD_VAR 0 4
40164: PUSH
40165: LD_VAR 0 8
40169: PUSH
40170: LD_INT 6
40172: LESS
40173: AND
40174: IFFALSE 40362
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40176: LD_ADDR_VAR 0 9
40180: PUSH
40181: LD_VAR 0 4
40185: PUSH
40186: LD_VAR 0 8
40190: PUSH
40191: LD_VAR 0 7
40195: UNION
40196: DIFF
40197: PPUSH
40198: LD_INT 4
40200: PPUSH
40201: CALL 105552 0 2
40205: ST_TO_ADDR
// p := [ ] ;
40206: LD_ADDR_VAR 0 11
40210: PUSH
40211: EMPTY
40212: ST_TO_ADDR
// if sort then
40213: LD_VAR 0 9
40217: IFFALSE 40333
// for i = 1 to 6 - sci do
40219: LD_ADDR_VAR 0 3
40223: PUSH
40224: DOUBLE
40225: LD_INT 1
40227: DEC
40228: ST_TO_ADDR
40229: LD_INT 6
40231: PUSH
40232: LD_VAR 0 8
40236: MINUS
40237: PUSH
40238: FOR_TO
40239: IFFALSE 40331
// begin if i = sort then
40241: LD_VAR 0 3
40245: PUSH
40246: LD_VAR 0 9
40250: EQUAL
40251: IFFALSE 40255
// break ;
40253: GO 40331
// if GetClass ( i ) = 4 then
40255: LD_VAR 0 3
40259: PPUSH
40260: CALL_OW 257
40264: PUSH
40265: LD_INT 4
40267: EQUAL
40268: IFFALSE 40272
// continue ;
40270: GO 40238
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40272: LD_ADDR_VAR 0 11
40276: PUSH
40277: LD_VAR 0 11
40281: PPUSH
40282: LD_VAR 0 11
40286: PUSH
40287: LD_INT 1
40289: PLUS
40290: PPUSH
40291: LD_VAR 0 9
40295: PUSH
40296: LD_VAR 0 3
40300: ARRAY
40301: PPUSH
40302: CALL_OW 2
40306: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40307: LD_ADDR_VAR 0 4
40311: PUSH
40312: LD_VAR 0 4
40316: PUSH
40317: LD_VAR 0 9
40321: PUSH
40322: LD_VAR 0 3
40326: ARRAY
40327: DIFF
40328: ST_TO_ADDR
// end ;
40329: GO 40238
40331: POP
40332: POP
// if p then
40333: LD_VAR 0 11
40337: IFFALSE 40362
// result := Replace ( result , 4 , p ) ;
40339: LD_ADDR_VAR 0 2
40343: PUSH
40344: LD_VAR 0 2
40348: PPUSH
40349: LD_INT 4
40351: PPUSH
40352: LD_VAR 0 11
40356: PPUSH
40357: CALL_OW 1
40361: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40362: LD_VAR 0 4
40366: PUSH
40367: LD_VAR 0 7
40371: PUSH
40372: LD_INT 6
40374: LESS
40375: AND
40376: IFFALSE 40564
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40378: LD_ADDR_VAR 0 9
40382: PUSH
40383: LD_VAR 0 4
40387: PUSH
40388: LD_VAR 0 8
40392: PUSH
40393: LD_VAR 0 7
40397: UNION
40398: DIFF
40399: PPUSH
40400: LD_INT 3
40402: PPUSH
40403: CALL 105552 0 2
40407: ST_TO_ADDR
// p := [ ] ;
40408: LD_ADDR_VAR 0 11
40412: PUSH
40413: EMPTY
40414: ST_TO_ADDR
// if sort then
40415: LD_VAR 0 9
40419: IFFALSE 40535
// for i = 1 to 6 - mech do
40421: LD_ADDR_VAR 0 3
40425: PUSH
40426: DOUBLE
40427: LD_INT 1
40429: DEC
40430: ST_TO_ADDR
40431: LD_INT 6
40433: PUSH
40434: LD_VAR 0 7
40438: MINUS
40439: PUSH
40440: FOR_TO
40441: IFFALSE 40533
// begin if i = sort then
40443: LD_VAR 0 3
40447: PUSH
40448: LD_VAR 0 9
40452: EQUAL
40453: IFFALSE 40457
// break ;
40455: GO 40533
// if GetClass ( i ) = 3 then
40457: LD_VAR 0 3
40461: PPUSH
40462: CALL_OW 257
40466: PUSH
40467: LD_INT 3
40469: EQUAL
40470: IFFALSE 40474
// continue ;
40472: GO 40440
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40474: LD_ADDR_VAR 0 11
40478: PUSH
40479: LD_VAR 0 11
40483: PPUSH
40484: LD_VAR 0 11
40488: PUSH
40489: LD_INT 1
40491: PLUS
40492: PPUSH
40493: LD_VAR 0 9
40497: PUSH
40498: LD_VAR 0 3
40502: ARRAY
40503: PPUSH
40504: CALL_OW 2
40508: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40509: LD_ADDR_VAR 0 4
40513: PUSH
40514: LD_VAR 0 4
40518: PUSH
40519: LD_VAR 0 9
40523: PUSH
40524: LD_VAR 0 3
40528: ARRAY
40529: DIFF
40530: ST_TO_ADDR
// end ;
40531: GO 40440
40533: POP
40534: POP
// if p then
40535: LD_VAR 0 11
40539: IFFALSE 40564
// result := Replace ( result , 3 , p ) ;
40541: LD_ADDR_VAR 0 2
40545: PUSH
40546: LD_VAR 0 2
40550: PPUSH
40551: LD_INT 3
40553: PPUSH
40554: LD_VAR 0 11
40558: PPUSH
40559: CALL_OW 1
40563: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40564: LD_VAR 0 4
40568: PUSH
40569: LD_INT 6
40571: GREATER
40572: PUSH
40573: LD_VAR 0 6
40577: PUSH
40578: LD_INT 6
40580: LESS
40581: AND
40582: IFFALSE 40776
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40584: LD_ADDR_VAR 0 9
40588: PUSH
40589: LD_VAR 0 4
40593: PUSH
40594: LD_VAR 0 8
40598: PUSH
40599: LD_VAR 0 7
40603: UNION
40604: PUSH
40605: LD_VAR 0 6
40609: UNION
40610: DIFF
40611: PPUSH
40612: LD_INT 2
40614: PPUSH
40615: CALL 105552 0 2
40619: ST_TO_ADDR
// p := [ ] ;
40620: LD_ADDR_VAR 0 11
40624: PUSH
40625: EMPTY
40626: ST_TO_ADDR
// if sort then
40627: LD_VAR 0 9
40631: IFFALSE 40747
// for i = 1 to 6 - eng do
40633: LD_ADDR_VAR 0 3
40637: PUSH
40638: DOUBLE
40639: LD_INT 1
40641: DEC
40642: ST_TO_ADDR
40643: LD_INT 6
40645: PUSH
40646: LD_VAR 0 6
40650: MINUS
40651: PUSH
40652: FOR_TO
40653: IFFALSE 40745
// begin if i = sort then
40655: LD_VAR 0 3
40659: PUSH
40660: LD_VAR 0 9
40664: EQUAL
40665: IFFALSE 40669
// break ;
40667: GO 40745
// if GetClass ( i ) = 2 then
40669: LD_VAR 0 3
40673: PPUSH
40674: CALL_OW 257
40678: PUSH
40679: LD_INT 2
40681: EQUAL
40682: IFFALSE 40686
// continue ;
40684: GO 40652
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40686: LD_ADDR_VAR 0 11
40690: PUSH
40691: LD_VAR 0 11
40695: PPUSH
40696: LD_VAR 0 11
40700: PUSH
40701: LD_INT 1
40703: PLUS
40704: PPUSH
40705: LD_VAR 0 9
40709: PUSH
40710: LD_VAR 0 3
40714: ARRAY
40715: PPUSH
40716: CALL_OW 2
40720: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40721: LD_ADDR_VAR 0 4
40725: PUSH
40726: LD_VAR 0 4
40730: PUSH
40731: LD_VAR 0 9
40735: PUSH
40736: LD_VAR 0 3
40740: ARRAY
40741: DIFF
40742: ST_TO_ADDR
// end ;
40743: GO 40652
40745: POP
40746: POP
// if p then
40747: LD_VAR 0 11
40751: IFFALSE 40776
// result := Replace ( result , 2 , p ) ;
40753: LD_ADDR_VAR 0 2
40757: PUSH
40758: LD_VAR 0 2
40762: PPUSH
40763: LD_INT 2
40765: PPUSH
40766: LD_VAR 0 11
40770: PPUSH
40771: CALL_OW 1
40775: ST_TO_ADDR
// end ; exit ;
40776: GO 42164
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40778: LD_EXP 126
40782: PUSH
40783: LD_EXP 125
40787: PUSH
40788: LD_VAR 0 1
40792: ARRAY
40793: ARRAY
40794: NOT
40795: PUSH
40796: LD_EXP 99
40800: PUSH
40801: LD_VAR 0 1
40805: ARRAY
40806: PPUSH
40807: LD_INT 30
40809: PUSH
40810: LD_INT 3
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PPUSH
40817: CALL_OW 72
40821: AND
40822: PUSH
40823: LD_EXP 104
40827: PUSH
40828: LD_VAR 0 1
40832: ARRAY
40833: AND
40834: IFFALSE 41442
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40836: LD_ADDR_EXP 141
40840: PUSH
40841: LD_EXP 141
40845: PPUSH
40846: LD_VAR 0 1
40850: PPUSH
40851: LD_INT 5
40853: PPUSH
40854: CALL_OW 1
40858: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40859: LD_ADDR_VAR 0 2
40863: PUSH
40864: LD_INT 0
40866: PUSH
40867: LD_INT 0
40869: PUSH
40870: LD_INT 0
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: ST_TO_ADDR
// if sci > 1 then
40882: LD_VAR 0 8
40886: PUSH
40887: LD_INT 1
40889: GREATER
40890: IFFALSE 40918
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40892: LD_ADDR_VAR 0 4
40896: PUSH
40897: LD_VAR 0 4
40901: PUSH
40902: LD_VAR 0 8
40906: PUSH
40907: LD_VAR 0 8
40911: PUSH
40912: LD_INT 1
40914: ARRAY
40915: DIFF
40916: DIFF
40917: ST_TO_ADDR
// if tmp and not sci then
40918: LD_VAR 0 4
40922: PUSH
40923: LD_VAR 0 8
40927: NOT
40928: AND
40929: IFFALSE 40998
// begin sort := SortBySkill ( tmp , 4 ) ;
40931: LD_ADDR_VAR 0 9
40935: PUSH
40936: LD_VAR 0 4
40940: PPUSH
40941: LD_INT 4
40943: PPUSH
40944: CALL 105552 0 2
40948: ST_TO_ADDR
// if sort then
40949: LD_VAR 0 9
40953: IFFALSE 40969
// p := sort [ 1 ] ;
40955: LD_ADDR_VAR 0 11
40959: PUSH
40960: LD_VAR 0 9
40964: PUSH
40965: LD_INT 1
40967: ARRAY
40968: ST_TO_ADDR
// if p then
40969: LD_VAR 0 11
40973: IFFALSE 40998
// result := Replace ( result , 4 , p ) ;
40975: LD_ADDR_VAR 0 2
40979: PUSH
40980: LD_VAR 0 2
40984: PPUSH
40985: LD_INT 4
40987: PPUSH
40988: LD_VAR 0 11
40992: PPUSH
40993: CALL_OW 1
40997: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40998: LD_ADDR_VAR 0 4
41002: PUSH
41003: LD_VAR 0 4
41007: PUSH
41008: LD_VAR 0 7
41012: DIFF
41013: ST_TO_ADDR
// if tmp and mech < 6 then
41014: LD_VAR 0 4
41018: PUSH
41019: LD_VAR 0 7
41023: PUSH
41024: LD_INT 6
41026: LESS
41027: AND
41028: IFFALSE 41216
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41030: LD_ADDR_VAR 0 9
41034: PUSH
41035: LD_VAR 0 4
41039: PUSH
41040: LD_VAR 0 8
41044: PUSH
41045: LD_VAR 0 7
41049: UNION
41050: DIFF
41051: PPUSH
41052: LD_INT 3
41054: PPUSH
41055: CALL 105552 0 2
41059: ST_TO_ADDR
// p := [ ] ;
41060: LD_ADDR_VAR 0 11
41064: PUSH
41065: EMPTY
41066: ST_TO_ADDR
// if sort then
41067: LD_VAR 0 9
41071: IFFALSE 41187
// for i = 1 to 6 - mech do
41073: LD_ADDR_VAR 0 3
41077: PUSH
41078: DOUBLE
41079: LD_INT 1
41081: DEC
41082: ST_TO_ADDR
41083: LD_INT 6
41085: PUSH
41086: LD_VAR 0 7
41090: MINUS
41091: PUSH
41092: FOR_TO
41093: IFFALSE 41185
// begin if i = sort then
41095: LD_VAR 0 3
41099: PUSH
41100: LD_VAR 0 9
41104: EQUAL
41105: IFFALSE 41109
// break ;
41107: GO 41185
// if GetClass ( i ) = 3 then
41109: LD_VAR 0 3
41113: PPUSH
41114: CALL_OW 257
41118: PUSH
41119: LD_INT 3
41121: EQUAL
41122: IFFALSE 41126
// continue ;
41124: GO 41092
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41126: LD_ADDR_VAR 0 11
41130: PUSH
41131: LD_VAR 0 11
41135: PPUSH
41136: LD_VAR 0 11
41140: PUSH
41141: LD_INT 1
41143: PLUS
41144: PPUSH
41145: LD_VAR 0 9
41149: PUSH
41150: LD_VAR 0 3
41154: ARRAY
41155: PPUSH
41156: CALL_OW 2
41160: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41161: LD_ADDR_VAR 0 4
41165: PUSH
41166: LD_VAR 0 4
41170: PUSH
41171: LD_VAR 0 9
41175: PUSH
41176: LD_VAR 0 3
41180: ARRAY
41181: DIFF
41182: ST_TO_ADDR
// end ;
41183: GO 41092
41185: POP
41186: POP
// if p then
41187: LD_VAR 0 11
41191: IFFALSE 41216
// result := Replace ( result , 3 , p ) ;
41193: LD_ADDR_VAR 0 2
41197: PUSH
41198: LD_VAR 0 2
41202: PPUSH
41203: LD_INT 3
41205: PPUSH
41206: LD_VAR 0 11
41210: PPUSH
41211: CALL_OW 1
41215: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41216: LD_ADDR_VAR 0 4
41220: PUSH
41221: LD_VAR 0 4
41225: PUSH
41226: LD_VAR 0 6
41230: DIFF
41231: ST_TO_ADDR
// if tmp and eng < 6 then
41232: LD_VAR 0 4
41236: PUSH
41237: LD_VAR 0 6
41241: PUSH
41242: LD_INT 6
41244: LESS
41245: AND
41246: IFFALSE 41440
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41248: LD_ADDR_VAR 0 9
41252: PUSH
41253: LD_VAR 0 4
41257: PUSH
41258: LD_VAR 0 8
41262: PUSH
41263: LD_VAR 0 7
41267: UNION
41268: PUSH
41269: LD_VAR 0 6
41273: UNION
41274: DIFF
41275: PPUSH
41276: LD_INT 2
41278: PPUSH
41279: CALL 105552 0 2
41283: ST_TO_ADDR
// p := [ ] ;
41284: LD_ADDR_VAR 0 11
41288: PUSH
41289: EMPTY
41290: ST_TO_ADDR
// if sort then
41291: LD_VAR 0 9
41295: IFFALSE 41411
// for i = 1 to 6 - eng do
41297: LD_ADDR_VAR 0 3
41301: PUSH
41302: DOUBLE
41303: LD_INT 1
41305: DEC
41306: ST_TO_ADDR
41307: LD_INT 6
41309: PUSH
41310: LD_VAR 0 6
41314: MINUS
41315: PUSH
41316: FOR_TO
41317: IFFALSE 41409
// begin if i = sort then
41319: LD_VAR 0 3
41323: PUSH
41324: LD_VAR 0 9
41328: EQUAL
41329: IFFALSE 41333
// break ;
41331: GO 41409
// if GetClass ( i ) = 2 then
41333: LD_VAR 0 3
41337: PPUSH
41338: CALL_OW 257
41342: PUSH
41343: LD_INT 2
41345: EQUAL
41346: IFFALSE 41350
// continue ;
41348: GO 41316
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41350: LD_ADDR_VAR 0 11
41354: PUSH
41355: LD_VAR 0 11
41359: PPUSH
41360: LD_VAR 0 11
41364: PUSH
41365: LD_INT 1
41367: PLUS
41368: PPUSH
41369: LD_VAR 0 9
41373: PUSH
41374: LD_VAR 0 3
41378: ARRAY
41379: PPUSH
41380: CALL_OW 2
41384: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41385: LD_ADDR_VAR 0 4
41389: PUSH
41390: LD_VAR 0 4
41394: PUSH
41395: LD_VAR 0 9
41399: PUSH
41400: LD_VAR 0 3
41404: ARRAY
41405: DIFF
41406: ST_TO_ADDR
// end ;
41407: GO 41316
41409: POP
41410: POP
// if p then
41411: LD_VAR 0 11
41415: IFFALSE 41440
// result := Replace ( result , 2 , p ) ;
41417: LD_ADDR_VAR 0 2
41421: PUSH
41422: LD_VAR 0 2
41426: PPUSH
41427: LD_INT 2
41429: PPUSH
41430: LD_VAR 0 11
41434: PPUSH
41435: CALL_OW 1
41439: ST_TO_ADDR
// end ; exit ;
41440: GO 42164
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41442: LD_EXP 126
41446: PUSH
41447: LD_EXP 125
41451: PUSH
41452: LD_VAR 0 1
41456: ARRAY
41457: ARRAY
41458: NOT
41459: PUSH
41460: LD_EXP 99
41464: PUSH
41465: LD_VAR 0 1
41469: ARRAY
41470: PPUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 3
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PPUSH
41481: CALL_OW 72
41485: AND
41486: PUSH
41487: LD_EXP 104
41491: PUSH
41492: LD_VAR 0 1
41496: ARRAY
41497: NOT
41498: AND
41499: IFFALSE 42164
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41501: LD_ADDR_EXP 141
41505: PUSH
41506: LD_EXP 141
41510: PPUSH
41511: LD_VAR 0 1
41515: PPUSH
41516: LD_INT 6
41518: PPUSH
41519: CALL_OW 1
41523: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41524: LD_ADDR_VAR 0 2
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: LD_INT 0
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: ST_TO_ADDR
// if sci >= 1 then
41547: LD_VAR 0 8
41551: PUSH
41552: LD_INT 1
41554: GREATEREQUAL
41555: IFFALSE 41577
// tmp := tmp diff sci [ 1 ] ;
41557: LD_ADDR_VAR 0 4
41561: PUSH
41562: LD_VAR 0 4
41566: PUSH
41567: LD_VAR 0 8
41571: PUSH
41572: LD_INT 1
41574: ARRAY
41575: DIFF
41576: ST_TO_ADDR
// if tmp and not sci then
41577: LD_VAR 0 4
41581: PUSH
41582: LD_VAR 0 8
41586: NOT
41587: AND
41588: IFFALSE 41657
// begin sort := SortBySkill ( tmp , 4 ) ;
41590: LD_ADDR_VAR 0 9
41594: PUSH
41595: LD_VAR 0 4
41599: PPUSH
41600: LD_INT 4
41602: PPUSH
41603: CALL 105552 0 2
41607: ST_TO_ADDR
// if sort then
41608: LD_VAR 0 9
41612: IFFALSE 41628
// p := sort [ 1 ] ;
41614: LD_ADDR_VAR 0 11
41618: PUSH
41619: LD_VAR 0 9
41623: PUSH
41624: LD_INT 1
41626: ARRAY
41627: ST_TO_ADDR
// if p then
41628: LD_VAR 0 11
41632: IFFALSE 41657
// result := Replace ( result , 4 , p ) ;
41634: LD_ADDR_VAR 0 2
41638: PUSH
41639: LD_VAR 0 2
41643: PPUSH
41644: LD_INT 4
41646: PPUSH
41647: LD_VAR 0 11
41651: PPUSH
41652: CALL_OW 1
41656: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41657: LD_ADDR_VAR 0 4
41661: PUSH
41662: LD_VAR 0 4
41666: PUSH
41667: LD_VAR 0 7
41671: DIFF
41672: ST_TO_ADDR
// if tmp and mech < 6 then
41673: LD_VAR 0 4
41677: PUSH
41678: LD_VAR 0 7
41682: PUSH
41683: LD_INT 6
41685: LESS
41686: AND
41687: IFFALSE 41869
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41689: LD_ADDR_VAR 0 9
41693: PUSH
41694: LD_VAR 0 4
41698: PUSH
41699: LD_VAR 0 7
41703: DIFF
41704: PPUSH
41705: LD_INT 3
41707: PPUSH
41708: CALL 105552 0 2
41712: ST_TO_ADDR
// p := [ ] ;
41713: LD_ADDR_VAR 0 11
41717: PUSH
41718: EMPTY
41719: ST_TO_ADDR
// if sort then
41720: LD_VAR 0 9
41724: IFFALSE 41840
// for i = 1 to 6 - mech do
41726: LD_ADDR_VAR 0 3
41730: PUSH
41731: DOUBLE
41732: LD_INT 1
41734: DEC
41735: ST_TO_ADDR
41736: LD_INT 6
41738: PUSH
41739: LD_VAR 0 7
41743: MINUS
41744: PUSH
41745: FOR_TO
41746: IFFALSE 41838
// begin if i = sort then
41748: LD_VAR 0 3
41752: PUSH
41753: LD_VAR 0 9
41757: EQUAL
41758: IFFALSE 41762
// break ;
41760: GO 41838
// if GetClass ( i ) = 3 then
41762: LD_VAR 0 3
41766: PPUSH
41767: CALL_OW 257
41771: PUSH
41772: LD_INT 3
41774: EQUAL
41775: IFFALSE 41779
// continue ;
41777: GO 41745
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41779: LD_ADDR_VAR 0 11
41783: PUSH
41784: LD_VAR 0 11
41788: PPUSH
41789: LD_VAR 0 11
41793: PUSH
41794: LD_INT 1
41796: PLUS
41797: PPUSH
41798: LD_VAR 0 9
41802: PUSH
41803: LD_VAR 0 3
41807: ARRAY
41808: PPUSH
41809: CALL_OW 2
41813: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41814: LD_ADDR_VAR 0 4
41818: PUSH
41819: LD_VAR 0 4
41823: PUSH
41824: LD_VAR 0 9
41828: PUSH
41829: LD_VAR 0 3
41833: ARRAY
41834: DIFF
41835: ST_TO_ADDR
// end ;
41836: GO 41745
41838: POP
41839: POP
// if p then
41840: LD_VAR 0 11
41844: IFFALSE 41869
// result := Replace ( result , 3 , p ) ;
41846: LD_ADDR_VAR 0 2
41850: PUSH
41851: LD_VAR 0 2
41855: PPUSH
41856: LD_INT 3
41858: PPUSH
41859: LD_VAR 0 11
41863: PPUSH
41864: CALL_OW 1
41868: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41869: LD_ADDR_VAR 0 4
41873: PUSH
41874: LD_VAR 0 4
41878: PUSH
41879: LD_VAR 0 6
41883: DIFF
41884: ST_TO_ADDR
// if tmp and eng < 4 then
41885: LD_VAR 0 4
41889: PUSH
41890: LD_VAR 0 6
41894: PUSH
41895: LD_INT 4
41897: LESS
41898: AND
41899: IFFALSE 42089
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41901: LD_ADDR_VAR 0 9
41905: PUSH
41906: LD_VAR 0 4
41910: PUSH
41911: LD_VAR 0 7
41915: PUSH
41916: LD_VAR 0 6
41920: UNION
41921: DIFF
41922: PPUSH
41923: LD_INT 2
41925: PPUSH
41926: CALL 105552 0 2
41930: ST_TO_ADDR
// p := [ ] ;
41931: LD_ADDR_VAR 0 11
41935: PUSH
41936: EMPTY
41937: ST_TO_ADDR
// if sort then
41938: LD_VAR 0 9
41942: IFFALSE 42058
// for i = 1 to 4 - eng do
41944: LD_ADDR_VAR 0 3
41948: PUSH
41949: DOUBLE
41950: LD_INT 1
41952: DEC
41953: ST_TO_ADDR
41954: LD_INT 4
41956: PUSH
41957: LD_VAR 0 6
41961: MINUS
41962: PUSH
41963: FOR_TO
41964: IFFALSE 42056
// begin if i = sort then
41966: LD_VAR 0 3
41970: PUSH
41971: LD_VAR 0 9
41975: EQUAL
41976: IFFALSE 41980
// break ;
41978: GO 42056
// if GetClass ( i ) = 2 then
41980: LD_VAR 0 3
41984: PPUSH
41985: CALL_OW 257
41989: PUSH
41990: LD_INT 2
41992: EQUAL
41993: IFFALSE 41997
// continue ;
41995: GO 41963
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41997: LD_ADDR_VAR 0 11
42001: PUSH
42002: LD_VAR 0 11
42006: PPUSH
42007: LD_VAR 0 11
42011: PUSH
42012: LD_INT 1
42014: PLUS
42015: PPUSH
42016: LD_VAR 0 9
42020: PUSH
42021: LD_VAR 0 3
42025: ARRAY
42026: PPUSH
42027: CALL_OW 2
42031: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42032: LD_ADDR_VAR 0 4
42036: PUSH
42037: LD_VAR 0 4
42041: PUSH
42042: LD_VAR 0 9
42046: PUSH
42047: LD_VAR 0 3
42051: ARRAY
42052: DIFF
42053: ST_TO_ADDR
// end ;
42054: GO 41963
42056: POP
42057: POP
// if p then
42058: LD_VAR 0 11
42062: IFFALSE 42087
// result := Replace ( result , 2 , p ) ;
42064: LD_ADDR_VAR 0 2
42068: PUSH
42069: LD_VAR 0 2
42073: PPUSH
42074: LD_INT 2
42076: PPUSH
42077: LD_VAR 0 11
42081: PPUSH
42082: CALL_OW 1
42086: ST_TO_ADDR
// end else
42087: GO 42133
// for i = eng downto 5 do
42089: LD_ADDR_VAR 0 3
42093: PUSH
42094: DOUBLE
42095: LD_VAR 0 6
42099: INC
42100: ST_TO_ADDR
42101: LD_INT 5
42103: PUSH
42104: FOR_DOWNTO
42105: IFFALSE 42131
// tmp := tmp union eng [ i ] ;
42107: LD_ADDR_VAR 0 4
42111: PUSH
42112: LD_VAR 0 4
42116: PUSH
42117: LD_VAR 0 6
42121: PUSH
42122: LD_VAR 0 3
42126: ARRAY
42127: UNION
42128: ST_TO_ADDR
42129: GO 42104
42131: POP
42132: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42133: LD_ADDR_VAR 0 2
42137: PUSH
42138: LD_VAR 0 2
42142: PPUSH
42143: LD_INT 1
42145: PPUSH
42146: LD_VAR 0 4
42150: PUSH
42151: LD_VAR 0 5
42155: DIFF
42156: PPUSH
42157: CALL_OW 1
42161: ST_TO_ADDR
// exit ;
42162: GO 42164
// end ; end ;
42164: LD_VAR 0 2
42168: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42169: LD_INT 0
42171: PPUSH
42172: PPUSH
42173: PPUSH
// if not mc_bases then
42174: LD_EXP 99
42178: NOT
42179: IFFALSE 42183
// exit ;
42181: GO 42289
// for i = 1 to mc_bases do
42183: LD_ADDR_VAR 0 2
42187: PUSH
42188: DOUBLE
42189: LD_INT 1
42191: DEC
42192: ST_TO_ADDR
42193: LD_EXP 99
42197: PUSH
42198: FOR_TO
42199: IFFALSE 42280
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42201: LD_ADDR_VAR 0 3
42205: PUSH
42206: LD_EXP 99
42210: PUSH
42211: LD_VAR 0 2
42215: ARRAY
42216: PPUSH
42217: LD_INT 21
42219: PUSH
42220: LD_INT 3
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 3
42229: PUSH
42230: LD_INT 24
42232: PUSH
42233: LD_INT 1000
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PPUSH
42248: CALL_OW 72
42252: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42253: LD_ADDR_EXP 100
42257: PUSH
42258: LD_EXP 100
42262: PPUSH
42263: LD_VAR 0 2
42267: PPUSH
42268: LD_VAR 0 3
42272: PPUSH
42273: CALL_OW 1
42277: ST_TO_ADDR
// end ;
42278: GO 42198
42280: POP
42281: POP
// RaiseSailEvent ( 101 ) ;
42282: LD_INT 101
42284: PPUSH
42285: CALL_OW 427
// end ;
42289: LD_VAR 0 1
42293: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
42298: PPUSH
42299: PPUSH
42300: PPUSH
42301: PPUSH
42302: PPUSH
// if not mc_bases then
42303: LD_EXP 99
42307: NOT
42308: IFFALSE 42312
// exit ;
42310: GO 42885
// for i = 1 to mc_bases do
42312: LD_ADDR_VAR 0 2
42316: PUSH
42317: DOUBLE
42318: LD_INT 1
42320: DEC
42321: ST_TO_ADDR
42322: LD_EXP 99
42326: PUSH
42327: FOR_TO
42328: IFFALSE 42876
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42330: LD_ADDR_VAR 0 5
42334: PUSH
42335: LD_EXP 99
42339: PUSH
42340: LD_VAR 0 2
42344: ARRAY
42345: PUSH
42346: LD_EXP 128
42350: PUSH
42351: LD_VAR 0 2
42355: ARRAY
42356: UNION
42357: PPUSH
42358: LD_INT 21
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 1
42370: PUSH
42371: LD_INT 3
42373: PUSH
42374: LD_INT 54
42376: PUSH
42377: EMPTY
42378: LIST
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 3
42386: PUSH
42387: LD_INT 24
42389: PUSH
42390: LD_INT 800
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PPUSH
42410: CALL_OW 72
42414: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42415: LD_ADDR_VAR 0 6
42419: PUSH
42420: LD_EXP 99
42424: PUSH
42425: LD_VAR 0 2
42429: ARRAY
42430: PPUSH
42431: LD_INT 21
42433: PUSH
42434: LD_INT 1
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 1
42443: PUSH
42444: LD_INT 3
42446: PUSH
42447: LD_INT 54
42449: PUSH
42450: EMPTY
42451: LIST
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 3
42459: PUSH
42460: LD_INT 24
42462: PUSH
42463: LD_INT 250
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PPUSH
42483: CALL_OW 72
42487: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42488: LD_ADDR_VAR 0 7
42492: PUSH
42493: LD_VAR 0 5
42497: PUSH
42498: LD_VAR 0 6
42502: DIFF
42503: ST_TO_ADDR
// if not need_heal_1 then
42504: LD_VAR 0 6
42508: NOT
42509: IFFALSE 42542
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42511: LD_ADDR_EXP 102
42515: PUSH
42516: LD_EXP 102
42520: PPUSH
42521: LD_VAR 0 2
42525: PUSH
42526: LD_INT 1
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PPUSH
42533: EMPTY
42534: PPUSH
42535: CALL 71304 0 3
42539: ST_TO_ADDR
42540: GO 42612
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42542: LD_ADDR_EXP 102
42546: PUSH
42547: LD_EXP 102
42551: PPUSH
42552: LD_VAR 0 2
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PPUSH
42564: LD_EXP 102
42568: PUSH
42569: LD_VAR 0 2
42573: ARRAY
42574: PUSH
42575: LD_INT 1
42577: ARRAY
42578: PPUSH
42579: LD_INT 3
42581: PUSH
42582: LD_INT 24
42584: PUSH
42585: LD_INT 1000
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PPUSH
42596: CALL_OW 72
42600: PUSH
42601: LD_VAR 0 6
42605: UNION
42606: PPUSH
42607: CALL 71304 0 3
42611: ST_TO_ADDR
// if not need_heal_2 then
42612: LD_VAR 0 7
42616: NOT
42617: IFFALSE 42650
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42619: LD_ADDR_EXP 102
42623: PUSH
42624: LD_EXP 102
42628: PPUSH
42629: LD_VAR 0 2
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PPUSH
42641: EMPTY
42642: PPUSH
42643: CALL 71304 0 3
42647: ST_TO_ADDR
42648: GO 42682
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42650: LD_ADDR_EXP 102
42654: PUSH
42655: LD_EXP 102
42659: PPUSH
42660: LD_VAR 0 2
42664: PUSH
42665: LD_INT 2
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PPUSH
42672: LD_VAR 0 7
42676: PPUSH
42677: CALL 71304 0 3
42681: ST_TO_ADDR
// if need_heal_2 then
42682: LD_VAR 0 7
42686: IFFALSE 42858
// for j in need_heal_2 do
42688: LD_ADDR_VAR 0 3
42692: PUSH
42693: LD_VAR 0 7
42697: PUSH
42698: FOR_IN
42699: IFFALSE 42856
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42701: LD_ADDR_VAR 0 5
42705: PUSH
42706: LD_EXP 99
42710: PUSH
42711: LD_VAR 0 2
42715: ARRAY
42716: PPUSH
42717: LD_INT 2
42719: PUSH
42720: LD_INT 30
42722: PUSH
42723: LD_INT 6
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 30
42732: PUSH
42733: LD_INT 7
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 30
42742: PUSH
42743: LD_INT 8
42745: PUSH
42746: EMPTY
42747: LIST
42748: LIST
42749: PUSH
42750: LD_INT 30
42752: PUSH
42753: LD_INT 0
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 30
42762: PUSH
42763: LD_INT 1
42765: PUSH
42766: EMPTY
42767: LIST
42768: LIST
42769: PUSH
42770: LD_INT 25
42772: PUSH
42773: LD_INT 4
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: PPUSH
42789: CALL_OW 72
42793: ST_TO_ADDR
// if tmp then
42794: LD_VAR 0 5
42798: IFFALSE 42854
// begin k := NearestUnitToUnit ( tmp , j ) ;
42800: LD_ADDR_VAR 0 4
42804: PUSH
42805: LD_VAR 0 5
42809: PPUSH
42810: LD_VAR 0 3
42814: PPUSH
42815: CALL_OW 74
42819: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42820: LD_VAR 0 3
42824: PPUSH
42825: LD_VAR 0 4
42829: PPUSH
42830: CALL_OW 296
42834: PUSH
42835: LD_INT 7
42837: GREATER
42838: IFFALSE 42854
// ComMoveUnit ( j , k ) ;
42840: LD_VAR 0 3
42844: PPUSH
42845: LD_VAR 0 4
42849: PPUSH
42850: CALL_OW 112
// end ; end ;
42854: GO 42698
42856: POP
42857: POP
// if not need_heal_1 and not need_heal_2 then
42858: LD_VAR 0 6
42862: NOT
42863: PUSH
42864: LD_VAR 0 7
42868: NOT
42869: AND
42870: IFFALSE 42874
// continue ;
42872: GO 42327
// end ;
42874: GO 42327
42876: POP
42877: POP
// RaiseSailEvent ( 102 ) ;
42878: LD_INT 102
42880: PPUSH
42881: CALL_OW 427
// end ;
42885: LD_VAR 0 1
42889: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42890: LD_INT 0
42892: PPUSH
42893: PPUSH
42894: PPUSH
42895: PPUSH
42896: PPUSH
42897: PPUSH
// if not mc_bases then
42898: LD_EXP 99
42902: NOT
42903: IFFALSE 42907
// exit ;
42905: GO 43617
// for i = 1 to mc_bases do
42907: LD_ADDR_VAR 0 2
42911: PUSH
42912: DOUBLE
42913: LD_INT 1
42915: DEC
42916: ST_TO_ADDR
42917: LD_EXP 99
42921: PUSH
42922: FOR_TO
42923: IFFALSE 43615
// begin if not mc_building_need_repair [ i ] then
42925: LD_EXP 100
42929: PUSH
42930: LD_VAR 0 2
42934: ARRAY
42935: NOT
42936: IFFALSE 43110
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42938: LD_ADDR_VAR 0 6
42942: PUSH
42943: LD_EXP 118
42947: PUSH
42948: LD_VAR 0 2
42952: ARRAY
42953: PPUSH
42954: LD_INT 3
42956: PUSH
42957: LD_INT 24
42959: PUSH
42960: LD_INT 1000
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 2
42973: PUSH
42974: LD_INT 34
42976: PUSH
42977: LD_INT 13
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 34
42986: PUSH
42987: LD_INT 52
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: LIST
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: PPUSH
43003: CALL_OW 72
43007: ST_TO_ADDR
// if cranes then
43008: LD_VAR 0 6
43012: IFFALSE 43074
// for j in cranes do
43014: LD_ADDR_VAR 0 3
43018: PUSH
43019: LD_VAR 0 6
43023: PUSH
43024: FOR_IN
43025: IFFALSE 43072
// if not IsInArea ( j , mc_parking [ i ] ) then
43027: LD_VAR 0 3
43031: PPUSH
43032: LD_EXP 123
43036: PUSH
43037: LD_VAR 0 2
43041: ARRAY
43042: PPUSH
43043: CALL_OW 308
43047: NOT
43048: IFFALSE 43070
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43050: LD_VAR 0 3
43054: PPUSH
43055: LD_EXP 123
43059: PUSH
43060: LD_VAR 0 2
43064: ARRAY
43065: PPUSH
43066: CALL_OW 113
43070: GO 43024
43072: POP
43073: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43074: LD_ADDR_EXP 101
43078: PUSH
43079: LD_EXP 101
43083: PPUSH
43084: LD_VAR 0 2
43088: PPUSH
43089: EMPTY
43090: PPUSH
43091: CALL_OW 1
43095: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43096: LD_VAR 0 2
43100: PPUSH
43101: LD_INT 101
43103: PPUSH
43104: CALL 38002 0 2
// continue ;
43108: GO 42922
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43110: LD_ADDR_EXP 105
43114: PUSH
43115: LD_EXP 105
43119: PPUSH
43120: LD_VAR 0 2
43124: PPUSH
43125: EMPTY
43126: PPUSH
43127: CALL_OW 1
43131: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43132: LD_VAR 0 2
43136: PPUSH
43137: LD_INT 103
43139: PPUSH
43140: CALL 38002 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43144: LD_ADDR_VAR 0 5
43148: PUSH
43149: LD_EXP 99
43153: PUSH
43154: LD_VAR 0 2
43158: ARRAY
43159: PUSH
43160: LD_EXP 128
43164: PUSH
43165: LD_VAR 0 2
43169: ARRAY
43170: UNION
43171: PPUSH
43172: LD_INT 2
43174: PUSH
43175: LD_INT 25
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 25
43187: PUSH
43188: LD_INT 16
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: LIST
43199: PUSH
43200: EMPTY
43201: LIST
43202: PPUSH
43203: CALL_OW 72
43207: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43208: LD_ADDR_VAR 0 6
43212: PUSH
43213: LD_EXP 118
43217: PUSH
43218: LD_VAR 0 2
43222: ARRAY
43223: PPUSH
43224: LD_INT 2
43226: PUSH
43227: LD_INT 34
43229: PUSH
43230: LD_INT 13
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 34
43239: PUSH
43240: LD_INT 52
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: LIST
43251: PPUSH
43252: CALL_OW 72
43256: ST_TO_ADDR
// if cranes then
43257: LD_VAR 0 6
43261: IFFALSE 43397
// begin for j in cranes do
43263: LD_ADDR_VAR 0 3
43267: PUSH
43268: LD_VAR 0 6
43272: PUSH
43273: FOR_IN
43274: IFFALSE 43395
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43276: LD_VAR 0 3
43280: PPUSH
43281: CALL_OW 256
43285: PUSH
43286: LD_INT 500
43288: GREATEREQUAL
43289: PUSH
43290: LD_VAR 0 3
43294: PPUSH
43295: CALL_OW 314
43299: NOT
43300: AND
43301: IFFALSE 43335
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43303: LD_VAR 0 3
43307: PPUSH
43308: LD_EXP 100
43312: PUSH
43313: LD_VAR 0 2
43317: ARRAY
43318: PPUSH
43319: LD_VAR 0 3
43323: PPUSH
43324: CALL_OW 74
43328: PPUSH
43329: CALL_OW 130
43333: GO 43393
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43335: LD_VAR 0 3
43339: PPUSH
43340: CALL_OW 256
43344: PUSH
43345: LD_INT 500
43347: LESS
43348: PUSH
43349: LD_VAR 0 3
43353: PPUSH
43354: LD_EXP 123
43358: PUSH
43359: LD_VAR 0 2
43363: ARRAY
43364: PPUSH
43365: CALL_OW 308
43369: NOT
43370: AND
43371: IFFALSE 43393
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43373: LD_VAR 0 3
43377: PPUSH
43378: LD_EXP 123
43382: PUSH
43383: LD_VAR 0 2
43387: ARRAY
43388: PPUSH
43389: CALL_OW 113
43393: GO 43273
43395: POP
43396: POP
// end ; if not tmp then
43397: LD_VAR 0 5
43401: NOT
43402: IFFALSE 43406
// continue ;
43404: GO 42922
// for j in tmp do
43406: LD_ADDR_VAR 0 3
43410: PUSH
43411: LD_VAR 0 5
43415: PUSH
43416: FOR_IN
43417: IFFALSE 43611
// begin if mc_need_heal [ i ] then
43419: LD_EXP 102
43423: PUSH
43424: LD_VAR 0 2
43428: ARRAY
43429: IFFALSE 43477
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43431: LD_VAR 0 3
43435: PUSH
43436: LD_EXP 102
43440: PUSH
43441: LD_VAR 0 2
43445: ARRAY
43446: PUSH
43447: LD_INT 1
43449: ARRAY
43450: IN
43451: PUSH
43452: LD_VAR 0 3
43456: PUSH
43457: LD_EXP 102
43461: PUSH
43462: LD_VAR 0 2
43466: ARRAY
43467: PUSH
43468: LD_INT 2
43470: ARRAY
43471: IN
43472: OR
43473: IFFALSE 43477
// continue ;
43475: GO 43416
// if IsInUnit ( j ) then
43477: LD_VAR 0 3
43481: PPUSH
43482: CALL_OW 310
43486: IFFALSE 43497
// ComExitBuilding ( j ) ;
43488: LD_VAR 0 3
43492: PPUSH
43493: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43497: LD_VAR 0 3
43501: PUSH
43502: LD_EXP 101
43506: PUSH
43507: LD_VAR 0 2
43511: ARRAY
43512: IN
43513: NOT
43514: IFFALSE 43572
// begin SetTag ( j , 101 ) ;
43516: LD_VAR 0 3
43520: PPUSH
43521: LD_INT 101
43523: PPUSH
43524: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43528: LD_ADDR_EXP 101
43532: PUSH
43533: LD_EXP 101
43537: PPUSH
43538: LD_VAR 0 2
43542: PUSH
43543: LD_EXP 101
43547: PUSH
43548: LD_VAR 0 2
43552: ARRAY
43553: PUSH
43554: LD_INT 1
43556: PLUS
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PPUSH
43562: LD_VAR 0 3
43566: PPUSH
43567: CALL 71304 0 3
43571: ST_TO_ADDR
// end ; wait ( 1 ) ;
43572: LD_INT 1
43574: PPUSH
43575: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43579: LD_VAR 0 3
43583: PPUSH
43584: LD_EXP 100
43588: PUSH
43589: LD_VAR 0 2
43593: ARRAY
43594: PPUSH
43595: LD_VAR 0 3
43599: PPUSH
43600: CALL_OW 74
43604: PPUSH
43605: CALL_OW 130
// end ;
43609: GO 43416
43611: POP
43612: POP
// end ;
43613: GO 42922
43615: POP
43616: POP
// end ;
43617: LD_VAR 0 1
43621: RET
// export function MC_Heal ; var i , j , tmp ; begin
43622: LD_INT 0
43624: PPUSH
43625: PPUSH
43626: PPUSH
43627: PPUSH
// if not mc_bases then
43628: LD_EXP 99
43632: NOT
43633: IFFALSE 43637
// exit ;
43635: GO 44039
// for i = 1 to mc_bases do
43637: LD_ADDR_VAR 0 2
43641: PUSH
43642: DOUBLE
43643: LD_INT 1
43645: DEC
43646: ST_TO_ADDR
43647: LD_EXP 99
43651: PUSH
43652: FOR_TO
43653: IFFALSE 44037
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43655: LD_EXP 102
43659: PUSH
43660: LD_VAR 0 2
43664: ARRAY
43665: PUSH
43666: LD_INT 1
43668: ARRAY
43669: NOT
43670: PUSH
43671: LD_EXP 102
43675: PUSH
43676: LD_VAR 0 2
43680: ARRAY
43681: PUSH
43682: LD_INT 2
43684: ARRAY
43685: NOT
43686: AND
43687: IFFALSE 43725
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43689: LD_ADDR_EXP 103
43693: PUSH
43694: LD_EXP 103
43698: PPUSH
43699: LD_VAR 0 2
43703: PPUSH
43704: EMPTY
43705: PPUSH
43706: CALL_OW 1
43710: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43711: LD_VAR 0 2
43715: PPUSH
43716: LD_INT 102
43718: PPUSH
43719: CALL 38002 0 2
// continue ;
43723: GO 43652
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43725: LD_ADDR_VAR 0 4
43729: PUSH
43730: LD_EXP 99
43734: PUSH
43735: LD_VAR 0 2
43739: ARRAY
43740: PPUSH
43741: LD_INT 25
43743: PUSH
43744: LD_INT 4
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PPUSH
43751: CALL_OW 72
43755: ST_TO_ADDR
// if not tmp then
43756: LD_VAR 0 4
43760: NOT
43761: IFFALSE 43765
// continue ;
43763: GO 43652
// if mc_taming [ i ] then
43765: LD_EXP 130
43769: PUSH
43770: LD_VAR 0 2
43774: ARRAY
43775: IFFALSE 43799
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43777: LD_ADDR_EXP 130
43781: PUSH
43782: LD_EXP 130
43786: PPUSH
43787: LD_VAR 0 2
43791: PPUSH
43792: EMPTY
43793: PPUSH
43794: CALL_OW 1
43798: ST_TO_ADDR
// for j in tmp do
43799: LD_ADDR_VAR 0 3
43803: PUSH
43804: LD_VAR 0 4
43808: PUSH
43809: FOR_IN
43810: IFFALSE 44033
// begin if IsInUnit ( j ) then
43812: LD_VAR 0 3
43816: PPUSH
43817: CALL_OW 310
43821: IFFALSE 43832
// ComExitBuilding ( j ) ;
43823: LD_VAR 0 3
43827: PPUSH
43828: CALL_OW 122
// if not j in mc_healers [ i ] then
43832: LD_VAR 0 3
43836: PUSH
43837: LD_EXP 103
43841: PUSH
43842: LD_VAR 0 2
43846: ARRAY
43847: IN
43848: NOT
43849: IFFALSE 43895
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43851: LD_ADDR_EXP 103
43855: PUSH
43856: LD_EXP 103
43860: PPUSH
43861: LD_VAR 0 2
43865: PUSH
43866: LD_EXP 103
43870: PUSH
43871: LD_VAR 0 2
43875: ARRAY
43876: PUSH
43877: LD_INT 1
43879: PLUS
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: PPUSH
43885: LD_VAR 0 3
43889: PPUSH
43890: CALL 71304 0 3
43894: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43895: LD_VAR 0 3
43899: PPUSH
43900: CALL_OW 110
43904: PUSH
43905: LD_INT 102
43907: NONEQUAL
43908: IFFALSE 43922
// SetTag ( j , 102 ) ;
43910: LD_VAR 0 3
43914: PPUSH
43915: LD_INT 102
43917: PPUSH
43918: CALL_OW 109
// Wait ( 3 ) ;
43922: LD_INT 3
43924: PPUSH
43925: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43929: LD_EXP 102
43933: PUSH
43934: LD_VAR 0 2
43938: ARRAY
43939: PUSH
43940: LD_INT 1
43942: ARRAY
43943: IFFALSE 43975
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43945: LD_VAR 0 3
43949: PPUSH
43950: LD_EXP 102
43954: PUSH
43955: LD_VAR 0 2
43959: ARRAY
43960: PUSH
43961: LD_INT 1
43963: ARRAY
43964: PUSH
43965: LD_INT 1
43967: ARRAY
43968: PPUSH
43969: CALL_OW 128
43973: GO 44031
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43975: LD_VAR 0 3
43979: PPUSH
43980: CALL_OW 314
43984: NOT
43985: PUSH
43986: LD_EXP 102
43990: PUSH
43991: LD_VAR 0 2
43995: ARRAY
43996: PUSH
43997: LD_INT 2
43999: ARRAY
44000: AND
44001: IFFALSE 44031
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44003: LD_VAR 0 3
44007: PPUSH
44008: LD_EXP 102
44012: PUSH
44013: LD_VAR 0 2
44017: ARRAY
44018: PUSH
44019: LD_INT 2
44021: ARRAY
44022: PUSH
44023: LD_INT 1
44025: ARRAY
44026: PPUSH
44027: CALL_OW 128
// end ;
44031: GO 43809
44033: POP
44034: POP
// end ;
44035: GO 43652
44037: POP
44038: POP
// end ;
44039: LD_VAR 0 1
44043: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44044: LD_INT 0
44046: PPUSH
44047: PPUSH
44048: PPUSH
44049: PPUSH
44050: PPUSH
// if not mc_bases then
44051: LD_EXP 99
44055: NOT
44056: IFFALSE 44060
// exit ;
44058: GO 45203
// for i = 1 to mc_bases do
44060: LD_ADDR_VAR 0 2
44064: PUSH
44065: DOUBLE
44066: LD_INT 1
44068: DEC
44069: ST_TO_ADDR
44070: LD_EXP 99
44074: PUSH
44075: FOR_TO
44076: IFFALSE 45201
// begin if mc_scan [ i ] then
44078: LD_EXP 122
44082: PUSH
44083: LD_VAR 0 2
44087: ARRAY
44088: IFFALSE 44092
// continue ;
44090: GO 44075
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44092: LD_EXP 104
44096: PUSH
44097: LD_VAR 0 2
44101: ARRAY
44102: NOT
44103: PUSH
44104: LD_EXP 106
44108: PUSH
44109: LD_VAR 0 2
44113: ARRAY
44114: NOT
44115: AND
44116: PUSH
44117: LD_EXP 105
44121: PUSH
44122: LD_VAR 0 2
44126: ARRAY
44127: AND
44128: IFFALSE 44166
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44130: LD_ADDR_EXP 105
44134: PUSH
44135: LD_EXP 105
44139: PPUSH
44140: LD_VAR 0 2
44144: PPUSH
44145: EMPTY
44146: PPUSH
44147: CALL_OW 1
44151: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44152: LD_VAR 0 2
44156: PPUSH
44157: LD_INT 103
44159: PPUSH
44160: CALL 38002 0 2
// continue ;
44164: GO 44075
// end ; if mc_construct_list [ i ] then
44166: LD_EXP 106
44170: PUSH
44171: LD_VAR 0 2
44175: ARRAY
44176: IFFALSE 44396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44178: LD_ADDR_VAR 0 4
44182: PUSH
44183: LD_EXP 99
44187: PUSH
44188: LD_VAR 0 2
44192: ARRAY
44193: PPUSH
44194: LD_INT 25
44196: PUSH
44197: LD_INT 2
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PPUSH
44204: CALL_OW 72
44208: PUSH
44209: LD_EXP 101
44213: PUSH
44214: LD_VAR 0 2
44218: ARRAY
44219: DIFF
44220: ST_TO_ADDR
// if not tmp then
44221: LD_VAR 0 4
44225: NOT
44226: IFFALSE 44230
// continue ;
44228: GO 44075
// for j in tmp do
44230: LD_ADDR_VAR 0 3
44234: PUSH
44235: LD_VAR 0 4
44239: PUSH
44240: FOR_IN
44241: IFFALSE 44392
// begin if not mc_builders [ i ] then
44243: LD_EXP 105
44247: PUSH
44248: LD_VAR 0 2
44252: ARRAY
44253: NOT
44254: IFFALSE 44312
// begin SetTag ( j , 103 ) ;
44256: LD_VAR 0 3
44260: PPUSH
44261: LD_INT 103
44263: PPUSH
44264: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44268: LD_ADDR_EXP 105
44272: PUSH
44273: LD_EXP 105
44277: PPUSH
44278: LD_VAR 0 2
44282: PUSH
44283: LD_EXP 105
44287: PUSH
44288: LD_VAR 0 2
44292: ARRAY
44293: PUSH
44294: LD_INT 1
44296: PLUS
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PPUSH
44302: LD_VAR 0 3
44306: PPUSH
44307: CALL 71304 0 3
44311: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44312: LD_VAR 0 3
44316: PPUSH
44317: CALL_OW 310
44321: IFFALSE 44332
// ComExitBuilding ( j ) ;
44323: LD_VAR 0 3
44327: PPUSH
44328: CALL_OW 122
// wait ( 3 ) ;
44332: LD_INT 3
44334: PPUSH
44335: CALL_OW 67
// if not mc_construct_list [ i ] then
44339: LD_EXP 106
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: NOT
44350: IFFALSE 44354
// break ;
44352: GO 44392
// if not HasTask ( j ) then
44354: LD_VAR 0 3
44358: PPUSH
44359: CALL_OW 314
44363: NOT
44364: IFFALSE 44390
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44366: LD_VAR 0 3
44370: PPUSH
44371: LD_EXP 106
44375: PUSH
44376: LD_VAR 0 2
44380: ARRAY
44381: PUSH
44382: LD_INT 1
44384: ARRAY
44385: PPUSH
44386: CALL 74155 0 2
// end ;
44390: GO 44240
44392: POP
44393: POP
// end else
44394: GO 45199
// if mc_build_list [ i ] then
44396: LD_EXP 104
44400: PUSH
44401: LD_VAR 0 2
44405: ARRAY
44406: IFFALSE 45199
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44408: LD_ADDR_VAR 0 5
44412: PUSH
44413: LD_EXP 99
44417: PUSH
44418: LD_VAR 0 2
44422: ARRAY
44423: PPUSH
44424: LD_INT 2
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 0
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 30
44439: PUSH
44440: LD_INT 1
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: LIST
44451: PPUSH
44452: CALL_OW 72
44456: ST_TO_ADDR
// if depot then
44457: LD_VAR 0 5
44461: IFFALSE 44479
// depot := depot [ 1 ] else
44463: LD_ADDR_VAR 0 5
44467: PUSH
44468: LD_VAR 0 5
44472: PUSH
44473: LD_INT 1
44475: ARRAY
44476: ST_TO_ADDR
44477: GO 44487
// depot := 0 ;
44479: LD_ADDR_VAR 0 5
44483: PUSH
44484: LD_INT 0
44486: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44487: LD_EXP 104
44491: PUSH
44492: LD_VAR 0 2
44496: ARRAY
44497: PUSH
44498: LD_INT 1
44500: ARRAY
44501: PUSH
44502: LD_INT 1
44504: ARRAY
44505: PPUSH
44506: CALL 73985 0 1
44510: PUSH
44511: LD_EXP 99
44515: PUSH
44516: LD_VAR 0 2
44520: ARRAY
44521: PPUSH
44522: LD_INT 2
44524: PUSH
44525: LD_INT 30
44527: PUSH
44528: LD_INT 2
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 30
44537: PUSH
44538: LD_INT 3
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: LIST
44549: PPUSH
44550: CALL_OW 72
44554: NOT
44555: AND
44556: IFFALSE 44661
// begin for j = 1 to mc_build_list [ i ] do
44558: LD_ADDR_VAR 0 3
44562: PUSH
44563: DOUBLE
44564: LD_INT 1
44566: DEC
44567: ST_TO_ADDR
44568: LD_EXP 104
44572: PUSH
44573: LD_VAR 0 2
44577: ARRAY
44578: PUSH
44579: FOR_TO
44580: IFFALSE 44659
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44582: LD_EXP 104
44586: PUSH
44587: LD_VAR 0 2
44591: ARRAY
44592: PUSH
44593: LD_VAR 0 3
44597: ARRAY
44598: PUSH
44599: LD_INT 1
44601: ARRAY
44602: PUSH
44603: LD_INT 2
44605: EQUAL
44606: IFFALSE 44657
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44608: LD_ADDR_EXP 104
44612: PUSH
44613: LD_EXP 104
44617: PPUSH
44618: LD_VAR 0 2
44622: PPUSH
44623: LD_EXP 104
44627: PUSH
44628: LD_VAR 0 2
44632: ARRAY
44633: PPUSH
44634: LD_VAR 0 3
44638: PPUSH
44639: LD_INT 1
44641: PPUSH
44642: LD_INT 0
44644: PPUSH
44645: CALL 70722 0 4
44649: PPUSH
44650: CALL_OW 1
44654: ST_TO_ADDR
// break ;
44655: GO 44659
// end ;
44657: GO 44579
44659: POP
44660: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44661: LD_EXP 104
44665: PUSH
44666: LD_VAR 0 2
44670: ARRAY
44671: PUSH
44672: LD_INT 1
44674: ARRAY
44675: PUSH
44676: LD_INT 1
44678: ARRAY
44679: PUSH
44680: LD_INT 0
44682: EQUAL
44683: PUSH
44684: LD_VAR 0 5
44688: PUSH
44689: LD_VAR 0 5
44693: PPUSH
44694: LD_EXP 104
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: PUSH
44705: LD_INT 1
44707: ARRAY
44708: PUSH
44709: LD_INT 1
44711: ARRAY
44712: PPUSH
44713: LD_EXP 104
44717: PUSH
44718: LD_VAR 0 2
44722: ARRAY
44723: PUSH
44724: LD_INT 1
44726: ARRAY
44727: PUSH
44728: LD_INT 2
44730: ARRAY
44731: PPUSH
44732: LD_EXP 104
44736: PUSH
44737: LD_VAR 0 2
44741: ARRAY
44742: PUSH
44743: LD_INT 1
44745: ARRAY
44746: PUSH
44747: LD_INT 3
44749: ARRAY
44750: PPUSH
44751: LD_EXP 104
44755: PUSH
44756: LD_VAR 0 2
44760: ARRAY
44761: PUSH
44762: LD_INT 1
44764: ARRAY
44765: PUSH
44766: LD_INT 4
44768: ARRAY
44769: PPUSH
44770: CALL 78719 0 5
44774: AND
44775: OR
44776: IFFALSE 45057
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44778: LD_ADDR_VAR 0 4
44782: PUSH
44783: LD_EXP 99
44787: PUSH
44788: LD_VAR 0 2
44792: ARRAY
44793: PPUSH
44794: LD_INT 25
44796: PUSH
44797: LD_INT 2
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PPUSH
44804: CALL_OW 72
44808: PUSH
44809: LD_EXP 101
44813: PUSH
44814: LD_VAR 0 2
44818: ARRAY
44819: DIFF
44820: ST_TO_ADDR
// if not tmp then
44821: LD_VAR 0 4
44825: NOT
44826: IFFALSE 44830
// continue ;
44828: GO 44075
// for j in tmp do
44830: LD_ADDR_VAR 0 3
44834: PUSH
44835: LD_VAR 0 4
44839: PUSH
44840: FOR_IN
44841: IFFALSE 45053
// begin if not mc_builders [ i ] then
44843: LD_EXP 105
44847: PUSH
44848: LD_VAR 0 2
44852: ARRAY
44853: NOT
44854: IFFALSE 44912
// begin SetTag ( j , 103 ) ;
44856: LD_VAR 0 3
44860: PPUSH
44861: LD_INT 103
44863: PPUSH
44864: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44868: LD_ADDR_EXP 105
44872: PUSH
44873: LD_EXP 105
44877: PPUSH
44878: LD_VAR 0 2
44882: PUSH
44883: LD_EXP 105
44887: PUSH
44888: LD_VAR 0 2
44892: ARRAY
44893: PUSH
44894: LD_INT 1
44896: PLUS
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PPUSH
44902: LD_VAR 0 3
44906: PPUSH
44907: CALL 71304 0 3
44911: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44912: LD_VAR 0 3
44916: PPUSH
44917: CALL_OW 310
44921: IFFALSE 44932
// ComExitBuilding ( j ) ;
44923: LD_VAR 0 3
44927: PPUSH
44928: CALL_OW 122
// wait ( 3 ) ;
44932: LD_INT 3
44934: PPUSH
44935: CALL_OW 67
// if not mc_build_list [ i ] then
44939: LD_EXP 104
44943: PUSH
44944: LD_VAR 0 2
44948: ARRAY
44949: NOT
44950: IFFALSE 44954
// break ;
44952: GO 45053
// if not HasTask ( j ) then
44954: LD_VAR 0 3
44958: PPUSH
44959: CALL_OW 314
44963: NOT
44964: IFFALSE 45051
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44966: LD_VAR 0 3
44970: PPUSH
44971: LD_EXP 104
44975: PUSH
44976: LD_VAR 0 2
44980: ARRAY
44981: PUSH
44982: LD_INT 1
44984: ARRAY
44985: PUSH
44986: LD_INT 1
44988: ARRAY
44989: PPUSH
44990: LD_EXP 104
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: PUSH
45001: LD_INT 1
45003: ARRAY
45004: PUSH
45005: LD_INT 2
45007: ARRAY
45008: PPUSH
45009: LD_EXP 104
45013: PUSH
45014: LD_VAR 0 2
45018: ARRAY
45019: PUSH
45020: LD_INT 1
45022: ARRAY
45023: PUSH
45024: LD_INT 3
45026: ARRAY
45027: PPUSH
45028: LD_EXP 104
45032: PUSH
45033: LD_VAR 0 2
45037: ARRAY
45038: PUSH
45039: LD_INT 1
45041: ARRAY
45042: PUSH
45043: LD_INT 4
45045: ARRAY
45046: PPUSH
45047: CALL_OW 145
// end ;
45051: GO 44840
45053: POP
45054: POP
// end else
45055: GO 45199
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45057: LD_EXP 99
45061: PUSH
45062: LD_VAR 0 2
45066: ARRAY
45067: PPUSH
45068: LD_EXP 104
45072: PUSH
45073: LD_VAR 0 2
45077: ARRAY
45078: PUSH
45079: LD_INT 1
45081: ARRAY
45082: PUSH
45083: LD_INT 1
45085: ARRAY
45086: PPUSH
45087: LD_EXP 104
45091: PUSH
45092: LD_VAR 0 2
45096: ARRAY
45097: PUSH
45098: LD_INT 1
45100: ARRAY
45101: PUSH
45102: LD_INT 2
45104: ARRAY
45105: PPUSH
45106: LD_EXP 104
45110: PUSH
45111: LD_VAR 0 2
45115: ARRAY
45116: PUSH
45117: LD_INT 1
45119: ARRAY
45120: PUSH
45121: LD_INT 3
45123: ARRAY
45124: PPUSH
45125: LD_EXP 104
45129: PUSH
45130: LD_VAR 0 2
45134: ARRAY
45135: PUSH
45136: LD_INT 1
45138: ARRAY
45139: PUSH
45140: LD_INT 4
45142: ARRAY
45143: PPUSH
45144: CALL 78055 0 5
45148: NOT
45149: IFFALSE 45199
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45151: LD_ADDR_EXP 104
45155: PUSH
45156: LD_EXP 104
45160: PPUSH
45161: LD_VAR 0 2
45165: PPUSH
45166: LD_EXP 104
45170: PUSH
45171: LD_VAR 0 2
45175: ARRAY
45176: PPUSH
45177: LD_INT 1
45179: PPUSH
45180: LD_INT 1
45182: NEG
45183: PPUSH
45184: LD_INT 0
45186: PPUSH
45187: CALL 70722 0 4
45191: PPUSH
45192: CALL_OW 1
45196: ST_TO_ADDR
// continue ;
45197: GO 44075
// end ; end ; end ;
45199: GO 44075
45201: POP
45202: POP
// end ;
45203: LD_VAR 0 1
45207: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45208: LD_INT 0
45210: PPUSH
45211: PPUSH
45212: PPUSH
45213: PPUSH
45214: PPUSH
45215: PPUSH
// if not mc_bases then
45216: LD_EXP 99
45220: NOT
45221: IFFALSE 45225
// exit ;
45223: GO 45652
// for i = 1 to mc_bases do
45225: LD_ADDR_VAR 0 2
45229: PUSH
45230: DOUBLE
45231: LD_INT 1
45233: DEC
45234: ST_TO_ADDR
45235: LD_EXP 99
45239: PUSH
45240: FOR_TO
45241: IFFALSE 45650
// begin tmp := mc_build_upgrade [ i ] ;
45243: LD_ADDR_VAR 0 4
45247: PUSH
45248: LD_EXP 131
45252: PUSH
45253: LD_VAR 0 2
45257: ARRAY
45258: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45259: LD_ADDR_VAR 0 6
45263: PUSH
45264: LD_EXP 132
45268: PUSH
45269: LD_VAR 0 2
45273: ARRAY
45274: PPUSH
45275: LD_INT 2
45277: PUSH
45278: LD_INT 30
45280: PUSH
45281: LD_INT 6
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 30
45290: PUSH
45291: LD_INT 7
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: LIST
45302: PPUSH
45303: CALL_OW 72
45307: ST_TO_ADDR
// if not tmp and not lab then
45308: LD_VAR 0 4
45312: NOT
45313: PUSH
45314: LD_VAR 0 6
45318: NOT
45319: AND
45320: IFFALSE 45324
// continue ;
45322: GO 45240
// if tmp then
45324: LD_VAR 0 4
45328: IFFALSE 45448
// for j in tmp do
45330: LD_ADDR_VAR 0 3
45334: PUSH
45335: LD_VAR 0 4
45339: PUSH
45340: FOR_IN
45341: IFFALSE 45446
// begin if UpgradeCost ( j ) then
45343: LD_VAR 0 3
45347: PPUSH
45348: CALL 77715 0 1
45352: IFFALSE 45444
// begin ComUpgrade ( j ) ;
45354: LD_VAR 0 3
45358: PPUSH
45359: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45363: LD_ADDR_EXP 131
45367: PUSH
45368: LD_EXP 131
45372: PPUSH
45373: LD_VAR 0 2
45377: PPUSH
45378: LD_EXP 131
45382: PUSH
45383: LD_VAR 0 2
45387: ARRAY
45388: PUSH
45389: LD_VAR 0 3
45393: DIFF
45394: PPUSH
45395: CALL_OW 1
45399: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45400: LD_ADDR_EXP 106
45404: PUSH
45405: LD_EXP 106
45409: PPUSH
45410: LD_VAR 0 2
45414: PUSH
45415: LD_EXP 106
45419: PUSH
45420: LD_VAR 0 2
45424: ARRAY
45425: PUSH
45426: LD_INT 1
45428: PLUS
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PPUSH
45434: LD_VAR 0 3
45438: PPUSH
45439: CALL 71304 0 3
45443: ST_TO_ADDR
// end ; end ;
45444: GO 45340
45446: POP
45447: POP
// if not lab or not mc_lab_upgrade [ i ] then
45448: LD_VAR 0 6
45452: NOT
45453: PUSH
45454: LD_EXP 133
45458: PUSH
45459: LD_VAR 0 2
45463: ARRAY
45464: NOT
45465: OR
45466: IFFALSE 45470
// continue ;
45468: GO 45240
// for j in lab do
45470: LD_ADDR_VAR 0 3
45474: PUSH
45475: LD_VAR 0 6
45479: PUSH
45480: FOR_IN
45481: IFFALSE 45646
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45483: LD_VAR 0 3
45487: PPUSH
45488: CALL_OW 266
45492: PUSH
45493: LD_INT 6
45495: PUSH
45496: LD_INT 7
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: IN
45503: PUSH
45504: LD_VAR 0 3
45508: PPUSH
45509: CALL_OW 461
45513: PUSH
45514: LD_INT 1
45516: NONEQUAL
45517: AND
45518: IFFALSE 45644
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45520: LD_VAR 0 3
45524: PPUSH
45525: LD_EXP 133
45529: PUSH
45530: LD_VAR 0 2
45534: ARRAY
45535: PUSH
45536: LD_INT 1
45538: ARRAY
45539: PPUSH
45540: CALL 77920 0 2
45544: IFFALSE 45644
// begin ComCancel ( j ) ;
45546: LD_VAR 0 3
45550: PPUSH
45551: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45555: LD_VAR 0 3
45559: PPUSH
45560: LD_EXP 133
45564: PUSH
45565: LD_VAR 0 2
45569: ARRAY
45570: PUSH
45571: LD_INT 1
45573: ARRAY
45574: PPUSH
45575: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45579: LD_VAR 0 3
45583: PUSH
45584: LD_EXP 106
45588: PUSH
45589: LD_VAR 0 2
45593: ARRAY
45594: IN
45595: NOT
45596: IFFALSE 45642
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45598: LD_ADDR_EXP 106
45602: PUSH
45603: LD_EXP 106
45607: PPUSH
45608: LD_VAR 0 2
45612: PUSH
45613: LD_EXP 106
45617: PUSH
45618: LD_VAR 0 2
45622: ARRAY
45623: PUSH
45624: LD_INT 1
45626: PLUS
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PPUSH
45632: LD_VAR 0 3
45636: PPUSH
45637: CALL 71304 0 3
45641: ST_TO_ADDR
// break ;
45642: GO 45646
// end ; end ; end ;
45644: GO 45480
45646: POP
45647: POP
// end ;
45648: GO 45240
45650: POP
45651: POP
// end ;
45652: LD_VAR 0 1
45656: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45657: LD_INT 0
45659: PPUSH
45660: PPUSH
45661: PPUSH
45662: PPUSH
45663: PPUSH
45664: PPUSH
45665: PPUSH
45666: PPUSH
45667: PPUSH
// if not mc_bases then
45668: LD_EXP 99
45672: NOT
45673: IFFALSE 45677
// exit ;
45675: GO 46082
// for i = 1 to mc_bases do
45677: LD_ADDR_VAR 0 2
45681: PUSH
45682: DOUBLE
45683: LD_INT 1
45685: DEC
45686: ST_TO_ADDR
45687: LD_EXP 99
45691: PUSH
45692: FOR_TO
45693: IFFALSE 46080
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45695: LD_EXP 107
45699: PUSH
45700: LD_VAR 0 2
45704: ARRAY
45705: NOT
45706: PUSH
45707: LD_EXP 99
45711: PUSH
45712: LD_VAR 0 2
45716: ARRAY
45717: PPUSH
45718: LD_INT 30
45720: PUSH
45721: LD_INT 3
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PPUSH
45728: CALL_OW 72
45732: NOT
45733: OR
45734: IFFALSE 45738
// continue ;
45736: GO 45692
// busy := false ;
45738: LD_ADDR_VAR 0 8
45742: PUSH
45743: LD_INT 0
45745: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45746: LD_ADDR_VAR 0 4
45750: PUSH
45751: LD_EXP 99
45755: PUSH
45756: LD_VAR 0 2
45760: ARRAY
45761: PPUSH
45762: LD_INT 30
45764: PUSH
45765: LD_INT 3
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PPUSH
45772: CALL_OW 72
45776: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45777: LD_ADDR_VAR 0 6
45781: PUSH
45782: LD_EXP 107
45786: PUSH
45787: LD_VAR 0 2
45791: ARRAY
45792: PPUSH
45793: LD_INT 2
45795: PUSH
45796: LD_INT 30
45798: PUSH
45799: LD_INT 32
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 30
45808: PUSH
45809: LD_INT 33
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: LIST
45820: PPUSH
45821: CALL_OW 72
45825: ST_TO_ADDR
// if not t then
45826: LD_VAR 0 6
45830: NOT
45831: IFFALSE 45835
// continue ;
45833: GO 45692
// for j in tmp do
45835: LD_ADDR_VAR 0 3
45839: PUSH
45840: LD_VAR 0 4
45844: PUSH
45845: FOR_IN
45846: IFFALSE 45876
// if not BuildingStatus ( j ) = bs_idle then
45848: LD_VAR 0 3
45852: PPUSH
45853: CALL_OW 461
45857: PUSH
45858: LD_INT 2
45860: EQUAL
45861: NOT
45862: IFFALSE 45874
// begin busy := true ;
45864: LD_ADDR_VAR 0 8
45868: PUSH
45869: LD_INT 1
45871: ST_TO_ADDR
// break ;
45872: GO 45876
// end ;
45874: GO 45845
45876: POP
45877: POP
// if busy then
45878: LD_VAR 0 8
45882: IFFALSE 45886
// continue ;
45884: GO 45692
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45886: LD_ADDR_VAR 0 7
45890: PUSH
45891: LD_VAR 0 6
45895: PPUSH
45896: LD_INT 35
45898: PUSH
45899: LD_INT 0
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: PPUSH
45906: CALL_OW 72
45910: ST_TO_ADDR
// if tw then
45911: LD_VAR 0 7
45915: IFFALSE 45992
// begin tw := tw [ 1 ] ;
45917: LD_ADDR_VAR 0 7
45921: PUSH
45922: LD_VAR 0 7
45926: PUSH
45927: LD_INT 1
45929: ARRAY
45930: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45931: LD_ADDR_VAR 0 9
45935: PUSH
45936: LD_VAR 0 7
45940: PPUSH
45941: LD_EXP 124
45945: PUSH
45946: LD_VAR 0 2
45950: ARRAY
45951: PPUSH
45952: CALL 76274 0 2
45956: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45957: LD_EXP 138
45961: PUSH
45962: LD_VAR 0 2
45966: ARRAY
45967: IFFALSE 45990
// if not weapon in mc_allowed_tower_weapons [ i ] then
45969: LD_VAR 0 9
45973: PUSH
45974: LD_EXP 138
45978: PUSH
45979: LD_VAR 0 2
45983: ARRAY
45984: IN
45985: NOT
45986: IFFALSE 45990
// continue ;
45988: GO 45692
// end else
45990: GO 46055
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45992: LD_ADDR_VAR 0 5
45996: PUSH
45997: LD_EXP 107
46001: PUSH
46002: LD_VAR 0 2
46006: ARRAY
46007: PPUSH
46008: LD_VAR 0 4
46012: PPUSH
46013: CALL 106475 0 2
46017: ST_TO_ADDR
// if not tmp2 then
46018: LD_VAR 0 5
46022: NOT
46023: IFFALSE 46027
// continue ;
46025: GO 45692
// tw := tmp2 [ 1 ] ;
46027: LD_ADDR_VAR 0 7
46031: PUSH
46032: LD_VAR 0 5
46036: PUSH
46037: LD_INT 1
46039: ARRAY
46040: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46041: LD_ADDR_VAR 0 9
46045: PUSH
46046: LD_VAR 0 5
46050: PUSH
46051: LD_INT 2
46053: ARRAY
46054: ST_TO_ADDR
// end ; if not weapon then
46055: LD_VAR 0 9
46059: NOT
46060: IFFALSE 46064
// continue ;
46062: GO 45692
// ComPlaceWeapon ( tw , weapon ) ;
46064: LD_VAR 0 7
46068: PPUSH
46069: LD_VAR 0 9
46073: PPUSH
46074: CALL_OW 148
// end ;
46078: GO 45692
46080: POP
46081: POP
// end ;
46082: LD_VAR 0 1
46086: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46087: LD_INT 0
46089: PPUSH
46090: PPUSH
46091: PPUSH
46092: PPUSH
46093: PPUSH
46094: PPUSH
// if not mc_bases then
46095: LD_EXP 99
46099: NOT
46100: IFFALSE 46104
// exit ;
46102: GO 47116
// for i = 1 to mc_bases do
46104: LD_ADDR_VAR 0 2
46108: PUSH
46109: DOUBLE
46110: LD_INT 1
46112: DEC
46113: ST_TO_ADDR
46114: LD_EXP 99
46118: PUSH
46119: FOR_TO
46120: IFFALSE 47114
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46122: LD_EXP 112
46126: PUSH
46127: LD_VAR 0 2
46131: ARRAY
46132: NOT
46133: PUSH
46134: LD_EXP 112
46138: PUSH
46139: LD_VAR 0 2
46143: ARRAY
46144: PUSH
46145: LD_EXP 113
46149: PUSH
46150: LD_VAR 0 2
46154: ARRAY
46155: EQUAL
46156: OR
46157: IFFALSE 46161
// continue ;
46159: GO 46119
// if mc_miners [ i ] then
46161: LD_EXP 113
46165: PUSH
46166: LD_VAR 0 2
46170: ARRAY
46171: IFFALSE 46801
// begin k := 1 ;
46173: LD_ADDR_VAR 0 4
46177: PUSH
46178: LD_INT 1
46180: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46181: LD_ADDR_VAR 0 3
46185: PUSH
46186: DOUBLE
46187: LD_EXP 113
46191: PUSH
46192: LD_VAR 0 2
46196: ARRAY
46197: INC
46198: ST_TO_ADDR
46199: LD_INT 1
46201: PUSH
46202: FOR_DOWNTO
46203: IFFALSE 46799
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46205: LD_EXP 113
46209: PUSH
46210: LD_VAR 0 2
46214: ARRAY
46215: PUSH
46216: LD_VAR 0 3
46220: ARRAY
46221: PPUSH
46222: CALL_OW 301
46226: PUSH
46227: LD_EXP 113
46231: PUSH
46232: LD_VAR 0 2
46236: ARRAY
46237: PUSH
46238: LD_VAR 0 3
46242: ARRAY
46243: PPUSH
46244: CALL_OW 257
46248: PUSH
46249: LD_INT 1
46251: NONEQUAL
46252: OR
46253: IFFALSE 46316
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46255: LD_ADDR_VAR 0 5
46259: PUSH
46260: LD_EXP 113
46264: PUSH
46265: LD_VAR 0 2
46269: ARRAY
46270: PUSH
46271: LD_EXP 113
46275: PUSH
46276: LD_VAR 0 2
46280: ARRAY
46281: PUSH
46282: LD_VAR 0 3
46286: ARRAY
46287: DIFF
46288: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46289: LD_ADDR_EXP 113
46293: PUSH
46294: LD_EXP 113
46298: PPUSH
46299: LD_VAR 0 2
46303: PPUSH
46304: LD_VAR 0 5
46308: PPUSH
46309: CALL_OW 1
46313: ST_TO_ADDR
// continue ;
46314: GO 46202
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46316: LD_EXP 113
46320: PUSH
46321: LD_VAR 0 2
46325: ARRAY
46326: PUSH
46327: LD_VAR 0 3
46331: ARRAY
46332: PPUSH
46333: CALL 71240 0 1
46337: PUSH
46338: LD_EXP 113
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: PUSH
46349: LD_VAR 0 3
46353: ARRAY
46354: PPUSH
46355: CALL_OW 255
46359: PPUSH
46360: LD_EXP 112
46364: PUSH
46365: LD_VAR 0 2
46369: ARRAY
46370: PUSH
46371: LD_VAR 0 4
46375: ARRAY
46376: PUSH
46377: LD_INT 1
46379: ARRAY
46380: PPUSH
46381: LD_EXP 112
46385: PUSH
46386: LD_VAR 0 2
46390: ARRAY
46391: PUSH
46392: LD_VAR 0 4
46396: ARRAY
46397: PUSH
46398: LD_INT 2
46400: ARRAY
46401: PPUSH
46402: LD_INT 15
46404: PPUSH
46405: CALL 72200 0 4
46409: PUSH
46410: LD_INT 4
46412: ARRAY
46413: PUSH
46414: LD_EXP 113
46418: PUSH
46419: LD_VAR 0 2
46423: ARRAY
46424: PUSH
46425: LD_VAR 0 3
46429: ARRAY
46430: PPUSH
46431: LD_INT 10
46433: PPUSH
46434: CALL 73897 0 2
46438: PUSH
46439: LD_INT 4
46441: ARRAY
46442: OR
46443: AND
46444: IFFALSE 46467
// ComStop ( mc_miners [ i ] [ j ] ) ;
46446: LD_EXP 113
46450: PUSH
46451: LD_VAR 0 2
46455: ARRAY
46456: PUSH
46457: LD_VAR 0 3
46461: ARRAY
46462: PPUSH
46463: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46467: LD_EXP 113
46471: PUSH
46472: LD_VAR 0 2
46476: ARRAY
46477: PUSH
46478: LD_VAR 0 3
46482: ARRAY
46483: PPUSH
46484: CALL_OW 257
46488: PUSH
46489: LD_INT 1
46491: EQUAL
46492: PUSH
46493: LD_EXP 113
46497: PUSH
46498: LD_VAR 0 2
46502: ARRAY
46503: PUSH
46504: LD_VAR 0 3
46508: ARRAY
46509: PPUSH
46510: CALL_OW 459
46514: NOT
46515: AND
46516: PUSH
46517: LD_EXP 113
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: PUSH
46528: LD_VAR 0 3
46532: ARRAY
46533: PPUSH
46534: CALL_OW 255
46538: PPUSH
46539: LD_EXP 112
46543: PUSH
46544: LD_VAR 0 2
46548: ARRAY
46549: PUSH
46550: LD_VAR 0 4
46554: ARRAY
46555: PUSH
46556: LD_INT 1
46558: ARRAY
46559: PPUSH
46560: LD_EXP 112
46564: PUSH
46565: LD_VAR 0 2
46569: ARRAY
46570: PUSH
46571: LD_VAR 0 4
46575: ARRAY
46576: PUSH
46577: LD_INT 2
46579: ARRAY
46580: PPUSH
46581: LD_INT 15
46583: PPUSH
46584: CALL 72200 0 4
46588: PUSH
46589: LD_INT 4
46591: ARRAY
46592: PUSH
46593: LD_INT 0
46595: EQUAL
46596: AND
46597: PUSH
46598: LD_EXP 113
46602: PUSH
46603: LD_VAR 0 2
46607: ARRAY
46608: PUSH
46609: LD_VAR 0 3
46613: ARRAY
46614: PPUSH
46615: CALL_OW 314
46619: NOT
46620: AND
46621: IFFALSE 46797
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46623: LD_EXP 113
46627: PUSH
46628: LD_VAR 0 2
46632: ARRAY
46633: PUSH
46634: LD_VAR 0 3
46638: ARRAY
46639: PPUSH
46640: CALL_OW 310
46644: IFFALSE 46667
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46646: LD_EXP 113
46650: PUSH
46651: LD_VAR 0 2
46655: ARRAY
46656: PUSH
46657: LD_VAR 0 3
46661: ARRAY
46662: PPUSH
46663: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46667: LD_EXP 113
46671: PUSH
46672: LD_VAR 0 2
46676: ARRAY
46677: PUSH
46678: LD_VAR 0 3
46682: ARRAY
46683: PPUSH
46684: CALL_OW 314
46688: NOT
46689: IFFALSE 46757
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46691: LD_EXP 113
46695: PUSH
46696: LD_VAR 0 2
46700: ARRAY
46701: PUSH
46702: LD_VAR 0 3
46706: ARRAY
46707: PPUSH
46708: LD_EXP 112
46712: PUSH
46713: LD_VAR 0 2
46717: ARRAY
46718: PUSH
46719: LD_VAR 0 4
46723: ARRAY
46724: PUSH
46725: LD_INT 1
46727: ARRAY
46728: PPUSH
46729: LD_EXP 112
46733: PUSH
46734: LD_VAR 0 2
46738: ARRAY
46739: PUSH
46740: LD_VAR 0 4
46744: ARRAY
46745: PUSH
46746: LD_INT 2
46748: ARRAY
46749: PPUSH
46750: LD_INT 0
46752: PPUSH
46753: CALL_OW 193
// k := k + 1 ;
46757: LD_ADDR_VAR 0 4
46761: PUSH
46762: LD_VAR 0 4
46766: PUSH
46767: LD_INT 1
46769: PLUS
46770: ST_TO_ADDR
// if k > mc_mines [ i ] then
46771: LD_VAR 0 4
46775: PUSH
46776: LD_EXP 112
46780: PUSH
46781: LD_VAR 0 2
46785: ARRAY
46786: GREATER
46787: IFFALSE 46797
// k := 1 ;
46789: LD_ADDR_VAR 0 4
46793: PUSH
46794: LD_INT 1
46796: ST_TO_ADDR
// end ; end ;
46797: GO 46202
46799: POP
46800: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46801: LD_ADDR_VAR 0 5
46805: PUSH
46806: LD_EXP 99
46810: PUSH
46811: LD_VAR 0 2
46815: ARRAY
46816: PPUSH
46817: LD_INT 2
46819: PUSH
46820: LD_INT 30
46822: PUSH
46823: LD_INT 4
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PUSH
46830: LD_INT 30
46832: PUSH
46833: LD_INT 5
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: PUSH
46840: LD_INT 30
46842: PUSH
46843: LD_INT 32
46845: PUSH
46846: EMPTY
46847: LIST
46848: LIST
46849: PUSH
46850: EMPTY
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: PPUSH
46856: CALL_OW 72
46860: ST_TO_ADDR
// if not tmp then
46861: LD_VAR 0 5
46865: NOT
46866: IFFALSE 46870
// continue ;
46868: GO 46119
// list := [ ] ;
46870: LD_ADDR_VAR 0 6
46874: PUSH
46875: EMPTY
46876: ST_TO_ADDR
// for j in tmp do
46877: LD_ADDR_VAR 0 3
46881: PUSH
46882: LD_VAR 0 5
46886: PUSH
46887: FOR_IN
46888: IFFALSE 46957
// begin for k in UnitsInside ( j ) do
46890: LD_ADDR_VAR 0 4
46894: PUSH
46895: LD_VAR 0 3
46899: PPUSH
46900: CALL_OW 313
46904: PUSH
46905: FOR_IN
46906: IFFALSE 46953
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46908: LD_VAR 0 4
46912: PPUSH
46913: CALL_OW 257
46917: PUSH
46918: LD_INT 1
46920: EQUAL
46921: PUSH
46922: LD_VAR 0 4
46926: PPUSH
46927: CALL_OW 459
46931: NOT
46932: AND
46933: IFFALSE 46951
// list := list ^ k ;
46935: LD_ADDR_VAR 0 6
46939: PUSH
46940: LD_VAR 0 6
46944: PUSH
46945: LD_VAR 0 4
46949: ADD
46950: ST_TO_ADDR
46951: GO 46905
46953: POP
46954: POP
// end ;
46955: GO 46887
46957: POP
46958: POP
// list := list diff mc_miners [ i ] ;
46959: LD_ADDR_VAR 0 6
46963: PUSH
46964: LD_VAR 0 6
46968: PUSH
46969: LD_EXP 113
46973: PUSH
46974: LD_VAR 0 2
46978: ARRAY
46979: DIFF
46980: ST_TO_ADDR
// if not list then
46981: LD_VAR 0 6
46985: NOT
46986: IFFALSE 46990
// continue ;
46988: GO 46119
// k := mc_mines [ i ] - mc_miners [ i ] ;
46990: LD_ADDR_VAR 0 4
46994: PUSH
46995: LD_EXP 112
46999: PUSH
47000: LD_VAR 0 2
47004: ARRAY
47005: PUSH
47006: LD_EXP 113
47010: PUSH
47011: LD_VAR 0 2
47015: ARRAY
47016: MINUS
47017: ST_TO_ADDR
// if k > list then
47018: LD_VAR 0 4
47022: PUSH
47023: LD_VAR 0 6
47027: GREATER
47028: IFFALSE 47040
// k := list ;
47030: LD_ADDR_VAR 0 4
47034: PUSH
47035: LD_VAR 0 6
47039: ST_TO_ADDR
// for j = 1 to k do
47040: LD_ADDR_VAR 0 3
47044: PUSH
47045: DOUBLE
47046: LD_INT 1
47048: DEC
47049: ST_TO_ADDR
47050: LD_VAR 0 4
47054: PUSH
47055: FOR_TO
47056: IFFALSE 47110
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47058: LD_ADDR_EXP 113
47062: PUSH
47063: LD_EXP 113
47067: PPUSH
47068: LD_VAR 0 2
47072: PUSH
47073: LD_EXP 113
47077: PUSH
47078: LD_VAR 0 2
47082: ARRAY
47083: PUSH
47084: LD_INT 1
47086: PLUS
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: PPUSH
47092: LD_VAR 0 6
47096: PUSH
47097: LD_VAR 0 3
47101: ARRAY
47102: PPUSH
47103: CALL 71304 0 3
47107: ST_TO_ADDR
47108: GO 47055
47110: POP
47111: POP
// end ;
47112: GO 46119
47114: POP
47115: POP
// end ;
47116: LD_VAR 0 1
47120: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47121: LD_INT 0
47123: PPUSH
47124: PPUSH
47125: PPUSH
47126: PPUSH
47127: PPUSH
47128: PPUSH
47129: PPUSH
47130: PPUSH
47131: PPUSH
47132: PPUSH
// if not mc_bases then
47133: LD_EXP 99
47137: NOT
47138: IFFALSE 47142
// exit ;
47140: GO 48892
// for i = 1 to mc_bases do
47142: LD_ADDR_VAR 0 2
47146: PUSH
47147: DOUBLE
47148: LD_INT 1
47150: DEC
47151: ST_TO_ADDR
47152: LD_EXP 99
47156: PUSH
47157: FOR_TO
47158: IFFALSE 48890
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47160: LD_EXP 99
47164: PUSH
47165: LD_VAR 0 2
47169: ARRAY
47170: NOT
47171: PUSH
47172: LD_EXP 106
47176: PUSH
47177: LD_VAR 0 2
47181: ARRAY
47182: OR
47183: IFFALSE 47187
// continue ;
47185: GO 47157
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47187: LD_EXP 115
47191: PUSH
47192: LD_VAR 0 2
47196: ARRAY
47197: NOT
47198: PUSH
47199: LD_EXP 116
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: AND
47210: IFFALSE 47248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47212: LD_ADDR_EXP 116
47216: PUSH
47217: LD_EXP 116
47221: PPUSH
47222: LD_VAR 0 2
47226: PPUSH
47227: EMPTY
47228: PPUSH
47229: CALL_OW 1
47233: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47234: LD_VAR 0 2
47238: PPUSH
47239: LD_INT 107
47241: PPUSH
47242: CALL 38002 0 2
// continue ;
47246: GO 47157
// end ; target := [ ] ;
47248: LD_ADDR_VAR 0 6
47252: PUSH
47253: EMPTY
47254: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47255: LD_ADDR_VAR 0 3
47259: PUSH
47260: DOUBLE
47261: LD_EXP 115
47265: PUSH
47266: LD_VAR 0 2
47270: ARRAY
47271: INC
47272: ST_TO_ADDR
47273: LD_INT 1
47275: PUSH
47276: FOR_DOWNTO
47277: IFFALSE 47537
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47279: LD_EXP 115
47283: PUSH
47284: LD_VAR 0 2
47288: ARRAY
47289: PUSH
47290: LD_VAR 0 3
47294: ARRAY
47295: PUSH
47296: LD_INT 2
47298: ARRAY
47299: PPUSH
47300: LD_EXP 115
47304: PUSH
47305: LD_VAR 0 2
47309: ARRAY
47310: PUSH
47311: LD_VAR 0 3
47315: ARRAY
47316: PUSH
47317: LD_INT 3
47319: ARRAY
47320: PPUSH
47321: CALL_OW 488
47325: PUSH
47326: LD_EXP 115
47330: PUSH
47331: LD_VAR 0 2
47335: ARRAY
47336: PUSH
47337: LD_VAR 0 3
47341: ARRAY
47342: PUSH
47343: LD_INT 2
47345: ARRAY
47346: PPUSH
47347: LD_EXP 115
47351: PUSH
47352: LD_VAR 0 2
47356: ARRAY
47357: PUSH
47358: LD_VAR 0 3
47362: ARRAY
47363: PUSH
47364: LD_INT 3
47366: ARRAY
47367: PPUSH
47368: CALL_OW 284
47372: PUSH
47373: LD_INT 0
47375: EQUAL
47376: AND
47377: IFFALSE 47432
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47379: LD_ADDR_VAR 0 5
47383: PUSH
47384: LD_EXP 115
47388: PUSH
47389: LD_VAR 0 2
47393: ARRAY
47394: PPUSH
47395: LD_VAR 0 3
47399: PPUSH
47400: CALL_OW 3
47404: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47405: LD_ADDR_EXP 115
47409: PUSH
47410: LD_EXP 115
47414: PPUSH
47415: LD_VAR 0 2
47419: PPUSH
47420: LD_VAR 0 5
47424: PPUSH
47425: CALL_OW 1
47429: ST_TO_ADDR
// continue ;
47430: GO 47276
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47432: LD_EXP 99
47436: PUSH
47437: LD_VAR 0 2
47441: ARRAY
47442: PUSH
47443: LD_INT 1
47445: ARRAY
47446: PPUSH
47447: CALL_OW 255
47451: PPUSH
47452: LD_EXP 115
47456: PUSH
47457: LD_VAR 0 2
47461: ARRAY
47462: PUSH
47463: LD_VAR 0 3
47467: ARRAY
47468: PUSH
47469: LD_INT 2
47471: ARRAY
47472: PPUSH
47473: LD_EXP 115
47477: PUSH
47478: LD_VAR 0 2
47482: ARRAY
47483: PUSH
47484: LD_VAR 0 3
47488: ARRAY
47489: PUSH
47490: LD_INT 3
47492: ARRAY
47493: PPUSH
47494: LD_INT 30
47496: PPUSH
47497: CALL 72200 0 4
47501: PUSH
47502: LD_INT 4
47504: ARRAY
47505: PUSH
47506: LD_INT 0
47508: EQUAL
47509: IFFALSE 47535
// begin target := mc_crates [ i ] [ j ] ;
47511: LD_ADDR_VAR 0 6
47515: PUSH
47516: LD_EXP 115
47520: PUSH
47521: LD_VAR 0 2
47525: ARRAY
47526: PUSH
47527: LD_VAR 0 3
47531: ARRAY
47532: ST_TO_ADDR
// break ;
47533: GO 47537
// end ; end ;
47535: GO 47276
47537: POP
47538: POP
// if not target then
47539: LD_VAR 0 6
47543: NOT
47544: IFFALSE 47548
// continue ;
47546: GO 47157
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47548: LD_ADDR_VAR 0 7
47552: PUSH
47553: LD_EXP 118
47557: PUSH
47558: LD_VAR 0 2
47562: ARRAY
47563: PPUSH
47564: LD_INT 2
47566: PUSH
47567: LD_INT 3
47569: PUSH
47570: LD_INT 58
47572: PUSH
47573: EMPTY
47574: LIST
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 61
47582: PUSH
47583: EMPTY
47584: LIST
47585: PUSH
47586: LD_INT 33
47588: PUSH
47589: LD_INT 5
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: LD_INT 33
47598: PUSH
47599: LD_INT 3
47601: PUSH
47602: EMPTY
47603: LIST
47604: LIST
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: LD_INT 34
47618: PUSH
47619: LD_INT 32
47621: PUSH
47622: EMPTY
47623: LIST
47624: LIST
47625: PUSH
47626: LD_INT 34
47628: PUSH
47629: LD_INT 51
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: PUSH
47636: LD_INT 34
47638: PUSH
47639: LD_INT 12
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: LIST
47650: LIST
47651: PUSH
47652: EMPTY
47653: LIST
47654: LIST
47655: PPUSH
47656: CALL_OW 72
47660: ST_TO_ADDR
// if not cargo then
47661: LD_VAR 0 7
47665: NOT
47666: IFFALSE 48309
// begin if mc_crates_collector [ i ] < 5 then
47668: LD_EXP 116
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: PUSH
47679: LD_INT 5
47681: LESS
47682: IFFALSE 48048
// begin if mc_ape [ i ] then
47684: LD_EXP 128
47688: PUSH
47689: LD_VAR 0 2
47693: ARRAY
47694: IFFALSE 47741
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47696: LD_ADDR_VAR 0 5
47700: PUSH
47701: LD_EXP 128
47705: PUSH
47706: LD_VAR 0 2
47710: ARRAY
47711: PPUSH
47712: LD_INT 25
47714: PUSH
47715: LD_INT 16
47717: PUSH
47718: EMPTY
47719: LIST
47720: LIST
47721: PUSH
47722: LD_INT 24
47724: PUSH
47725: LD_INT 750
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: EMPTY
47733: LIST
47734: LIST
47735: PPUSH
47736: CALL_OW 72
47740: ST_TO_ADDR
// if not tmp then
47741: LD_VAR 0 5
47745: NOT
47746: IFFALSE 47793
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47748: LD_ADDR_VAR 0 5
47752: PUSH
47753: LD_EXP 99
47757: PUSH
47758: LD_VAR 0 2
47762: ARRAY
47763: PPUSH
47764: LD_INT 25
47766: PUSH
47767: LD_INT 2
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 24
47776: PUSH
47777: LD_INT 750
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PUSH
47784: EMPTY
47785: LIST
47786: LIST
47787: PPUSH
47788: CALL_OW 72
47792: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47793: LD_EXP 128
47797: PUSH
47798: LD_VAR 0 2
47802: ARRAY
47803: PUSH
47804: LD_EXP 99
47808: PUSH
47809: LD_VAR 0 2
47813: ARRAY
47814: PPUSH
47815: LD_INT 25
47817: PUSH
47818: LD_INT 2
47820: PUSH
47821: EMPTY
47822: LIST
47823: LIST
47824: PUSH
47825: LD_INT 24
47827: PUSH
47828: LD_INT 750
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: EMPTY
47836: LIST
47837: LIST
47838: PPUSH
47839: CALL_OW 72
47843: AND
47844: PUSH
47845: LD_VAR 0 5
47849: PUSH
47850: LD_INT 5
47852: LESS
47853: AND
47854: IFFALSE 47936
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47856: LD_ADDR_VAR 0 3
47860: PUSH
47861: LD_EXP 99
47865: PUSH
47866: LD_VAR 0 2
47870: ARRAY
47871: PPUSH
47872: LD_INT 25
47874: PUSH
47875: LD_INT 2
47877: PUSH
47878: EMPTY
47879: LIST
47880: LIST
47881: PUSH
47882: LD_INT 24
47884: PUSH
47885: LD_INT 750
47887: PUSH
47888: EMPTY
47889: LIST
47890: LIST
47891: PUSH
47892: EMPTY
47893: LIST
47894: LIST
47895: PPUSH
47896: CALL_OW 72
47900: PUSH
47901: FOR_IN
47902: IFFALSE 47934
// begin tmp := tmp union j ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_VAR 0 5
47913: PUSH
47914: LD_VAR 0 3
47918: UNION
47919: ST_TO_ADDR
// if tmp >= 5 then
47920: LD_VAR 0 5
47924: PUSH
47925: LD_INT 5
47927: GREATEREQUAL
47928: IFFALSE 47932
// break ;
47930: GO 47934
// end ;
47932: GO 47901
47934: POP
47935: POP
// end ; if not tmp then
47936: LD_VAR 0 5
47940: NOT
47941: IFFALSE 47945
// continue ;
47943: GO 47157
// for j in tmp do
47945: LD_ADDR_VAR 0 3
47949: PUSH
47950: LD_VAR 0 5
47954: PUSH
47955: FOR_IN
47956: IFFALSE 48046
// if not GetTag ( j ) then
47958: LD_VAR 0 3
47962: PPUSH
47963: CALL_OW 110
47967: NOT
47968: IFFALSE 48044
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47970: LD_ADDR_EXP 116
47974: PUSH
47975: LD_EXP 116
47979: PPUSH
47980: LD_VAR 0 2
47984: PUSH
47985: LD_EXP 116
47989: PUSH
47990: LD_VAR 0 2
47994: ARRAY
47995: PUSH
47996: LD_INT 1
47998: PLUS
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: PPUSH
48004: LD_VAR 0 3
48008: PPUSH
48009: CALL 71304 0 3
48013: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48014: LD_VAR 0 3
48018: PPUSH
48019: LD_INT 107
48021: PPUSH
48022: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48026: LD_EXP 116
48030: PUSH
48031: LD_VAR 0 2
48035: ARRAY
48036: PUSH
48037: LD_INT 5
48039: GREATEREQUAL
48040: IFFALSE 48044
// break ;
48042: GO 48046
// end ;
48044: GO 47955
48046: POP
48047: POP
// end ; if mc_crates_collector [ i ] and target then
48048: LD_EXP 116
48052: PUSH
48053: LD_VAR 0 2
48057: ARRAY
48058: PUSH
48059: LD_VAR 0 6
48063: AND
48064: IFFALSE 48307
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48066: LD_EXP 116
48070: PUSH
48071: LD_VAR 0 2
48075: ARRAY
48076: PUSH
48077: LD_VAR 0 6
48081: PUSH
48082: LD_INT 1
48084: ARRAY
48085: LESS
48086: IFFALSE 48106
// tmp := mc_crates_collector [ i ] else
48088: LD_ADDR_VAR 0 5
48092: PUSH
48093: LD_EXP 116
48097: PUSH
48098: LD_VAR 0 2
48102: ARRAY
48103: ST_TO_ADDR
48104: GO 48120
// tmp := target [ 1 ] ;
48106: LD_ADDR_VAR 0 5
48110: PUSH
48111: LD_VAR 0 6
48115: PUSH
48116: LD_INT 1
48118: ARRAY
48119: ST_TO_ADDR
// k := 0 ;
48120: LD_ADDR_VAR 0 4
48124: PUSH
48125: LD_INT 0
48127: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48128: LD_ADDR_VAR 0 3
48132: PUSH
48133: LD_EXP 116
48137: PUSH
48138: LD_VAR 0 2
48142: ARRAY
48143: PUSH
48144: FOR_IN
48145: IFFALSE 48305
// begin k := k + 1 ;
48147: LD_ADDR_VAR 0 4
48151: PUSH
48152: LD_VAR 0 4
48156: PUSH
48157: LD_INT 1
48159: PLUS
48160: ST_TO_ADDR
// if k > tmp then
48161: LD_VAR 0 4
48165: PUSH
48166: LD_VAR 0 5
48170: GREATER
48171: IFFALSE 48175
// break ;
48173: GO 48305
// if not GetClass ( j ) in [ 2 , 16 ] then
48175: LD_VAR 0 3
48179: PPUSH
48180: CALL_OW 257
48184: PUSH
48185: LD_INT 2
48187: PUSH
48188: LD_INT 16
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: IN
48195: NOT
48196: IFFALSE 48249
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48198: LD_ADDR_EXP 116
48202: PUSH
48203: LD_EXP 116
48207: PPUSH
48208: LD_VAR 0 2
48212: PPUSH
48213: LD_EXP 116
48217: PUSH
48218: LD_VAR 0 2
48222: ARRAY
48223: PUSH
48224: LD_VAR 0 3
48228: DIFF
48229: PPUSH
48230: CALL_OW 1
48234: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48235: LD_VAR 0 3
48239: PPUSH
48240: LD_INT 0
48242: PPUSH
48243: CALL_OW 109
// continue ;
48247: GO 48144
// end ; if IsInUnit ( j ) then
48249: LD_VAR 0 3
48253: PPUSH
48254: CALL_OW 310
48258: IFFALSE 48269
// ComExitBuilding ( j ) ;
48260: LD_VAR 0 3
48264: PPUSH
48265: CALL_OW 122
// wait ( 3 ) ;
48269: LD_INT 3
48271: PPUSH
48272: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48276: LD_VAR 0 3
48280: PPUSH
48281: LD_VAR 0 6
48285: PUSH
48286: LD_INT 2
48288: ARRAY
48289: PPUSH
48290: LD_VAR 0 6
48294: PUSH
48295: LD_INT 3
48297: ARRAY
48298: PPUSH
48299: CALL_OW 117
// end ;
48303: GO 48144
48305: POP
48306: POP
// end ; end else
48307: GO 48888
// begin for j in cargo do
48309: LD_ADDR_VAR 0 3
48313: PUSH
48314: LD_VAR 0 7
48318: PUSH
48319: FOR_IN
48320: IFFALSE 48886
// begin if GetTag ( j ) <> 0 then
48322: LD_VAR 0 3
48326: PPUSH
48327: CALL_OW 110
48331: PUSH
48332: LD_INT 0
48334: NONEQUAL
48335: IFFALSE 48339
// continue ;
48337: GO 48319
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48339: LD_VAR 0 3
48343: PPUSH
48344: CALL_OW 256
48348: PUSH
48349: LD_INT 1000
48351: LESS
48352: PUSH
48353: LD_VAR 0 3
48357: PPUSH
48358: LD_EXP 123
48362: PUSH
48363: LD_VAR 0 2
48367: ARRAY
48368: PPUSH
48369: CALL_OW 308
48373: NOT
48374: AND
48375: IFFALSE 48397
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48377: LD_VAR 0 3
48381: PPUSH
48382: LD_EXP 123
48386: PUSH
48387: LD_VAR 0 2
48391: ARRAY
48392: PPUSH
48393: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48397: LD_VAR 0 3
48401: PPUSH
48402: CALL_OW 256
48406: PUSH
48407: LD_INT 1000
48409: LESS
48410: PUSH
48411: LD_VAR 0 3
48415: PPUSH
48416: LD_EXP 123
48420: PUSH
48421: LD_VAR 0 2
48425: ARRAY
48426: PPUSH
48427: CALL_OW 308
48431: AND
48432: IFFALSE 48436
// continue ;
48434: GO 48319
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48436: LD_VAR 0 3
48440: PPUSH
48441: CALL_OW 262
48445: PUSH
48446: LD_INT 2
48448: EQUAL
48449: PUSH
48450: LD_VAR 0 3
48454: PPUSH
48455: CALL_OW 261
48459: PUSH
48460: LD_INT 15
48462: LESS
48463: AND
48464: IFFALSE 48468
// continue ;
48466: GO 48319
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48468: LD_VAR 0 3
48472: PPUSH
48473: CALL_OW 262
48477: PUSH
48478: LD_INT 1
48480: EQUAL
48481: PUSH
48482: LD_VAR 0 3
48486: PPUSH
48487: CALL_OW 261
48491: PUSH
48492: LD_INT 10
48494: LESS
48495: AND
48496: IFFALSE 48825
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48498: LD_ADDR_VAR 0 8
48502: PUSH
48503: LD_EXP 99
48507: PUSH
48508: LD_VAR 0 2
48512: ARRAY
48513: PPUSH
48514: LD_INT 2
48516: PUSH
48517: LD_INT 30
48519: PUSH
48520: LD_INT 0
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PUSH
48527: LD_INT 30
48529: PUSH
48530: LD_INT 1
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: LIST
48541: PPUSH
48542: CALL_OW 72
48546: ST_TO_ADDR
// if not depot then
48547: LD_VAR 0 8
48551: NOT
48552: IFFALSE 48556
// continue ;
48554: GO 48319
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48556: LD_VAR 0 3
48560: PPUSH
48561: LD_VAR 0 8
48565: PPUSH
48566: LD_VAR 0 3
48570: PPUSH
48571: CALL_OW 74
48575: PPUSH
48576: CALL_OW 296
48580: PUSH
48581: LD_INT 6
48583: LESS
48584: IFFALSE 48600
// SetFuel ( j , 100 ) else
48586: LD_VAR 0 3
48590: PPUSH
48591: LD_INT 100
48593: PPUSH
48594: CALL_OW 240
48598: GO 48825
// if GetFuel ( j ) = 0 then
48600: LD_VAR 0 3
48604: PPUSH
48605: CALL_OW 261
48609: PUSH
48610: LD_INT 0
48612: EQUAL
48613: IFFALSE 48825
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48615: LD_ADDR_EXP 118
48619: PUSH
48620: LD_EXP 118
48624: PPUSH
48625: LD_VAR 0 2
48629: PPUSH
48630: LD_EXP 118
48634: PUSH
48635: LD_VAR 0 2
48639: ARRAY
48640: PUSH
48641: LD_VAR 0 3
48645: DIFF
48646: PPUSH
48647: CALL_OW 1
48651: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48652: LD_VAR 0 3
48656: PPUSH
48657: CALL_OW 263
48661: PUSH
48662: LD_INT 1
48664: EQUAL
48665: IFFALSE 48681
// ComExitVehicle ( IsInUnit ( j ) ) ;
48667: LD_VAR 0 3
48671: PPUSH
48672: CALL_OW 310
48676: PPUSH
48677: CALL_OW 121
// if GetControl ( j ) = control_remote then
48681: LD_VAR 0 3
48685: PPUSH
48686: CALL_OW 263
48690: PUSH
48691: LD_INT 2
48693: EQUAL
48694: IFFALSE 48705
// ComUnlink ( j ) ;
48696: LD_VAR 0 3
48700: PPUSH
48701: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48705: LD_ADDR_VAR 0 9
48709: PUSH
48710: LD_VAR 0 2
48714: PPUSH
48715: LD_INT 3
48717: PPUSH
48718: CALL 58178 0 2
48722: ST_TO_ADDR
// if fac then
48723: LD_VAR 0 9
48727: IFFALSE 48823
// begin for k in fac do
48729: LD_ADDR_VAR 0 4
48733: PUSH
48734: LD_VAR 0 9
48738: PUSH
48739: FOR_IN
48740: IFFALSE 48821
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48742: LD_ADDR_VAR 0 10
48746: PUSH
48747: LD_VAR 0 9
48751: PPUSH
48752: LD_VAR 0 3
48756: PPUSH
48757: CALL_OW 265
48761: PPUSH
48762: LD_VAR 0 3
48766: PPUSH
48767: CALL_OW 262
48771: PPUSH
48772: LD_VAR 0 3
48776: PPUSH
48777: CALL_OW 263
48781: PPUSH
48782: LD_VAR 0 3
48786: PPUSH
48787: CALL_OW 264
48791: PPUSH
48792: CALL 68836 0 5
48796: ST_TO_ADDR
// if components then
48797: LD_VAR 0 10
48801: IFFALSE 48819
// begin MC_InsertProduceList ( i , components ) ;
48803: LD_VAR 0 2
48807: PPUSH
48808: LD_VAR 0 10
48812: PPUSH
48813: CALL 57723 0 2
// break ;
48817: GO 48821
// end ; end ;
48819: GO 48739
48821: POP
48822: POP
// end ; continue ;
48823: GO 48319
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48825: LD_VAR 0 3
48829: PPUSH
48830: LD_INT 1
48832: PPUSH
48833: CALL_OW 289
48837: PUSH
48838: LD_INT 100
48840: LESS
48841: PUSH
48842: LD_VAR 0 3
48846: PPUSH
48847: CALL_OW 314
48851: NOT
48852: AND
48853: IFFALSE 48882
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48855: LD_VAR 0 3
48859: PPUSH
48860: LD_VAR 0 6
48864: PUSH
48865: LD_INT 2
48867: ARRAY
48868: PPUSH
48869: LD_VAR 0 6
48873: PUSH
48874: LD_INT 3
48876: ARRAY
48877: PPUSH
48878: CALL_OW 117
// break ;
48882: GO 48886
// end ;
48884: GO 48319
48886: POP
48887: POP
// end ; end ;
48888: GO 47157
48890: POP
48891: POP
// end ;
48892: LD_VAR 0 1
48896: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48897: LD_INT 0
48899: PPUSH
48900: PPUSH
48901: PPUSH
48902: PPUSH
// if not mc_bases then
48903: LD_EXP 99
48907: NOT
48908: IFFALSE 48912
// exit ;
48910: GO 49073
// for i = 1 to mc_bases do
48912: LD_ADDR_VAR 0 2
48916: PUSH
48917: DOUBLE
48918: LD_INT 1
48920: DEC
48921: ST_TO_ADDR
48922: LD_EXP 99
48926: PUSH
48927: FOR_TO
48928: IFFALSE 49071
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48930: LD_ADDR_VAR 0 4
48934: PUSH
48935: LD_EXP 118
48939: PUSH
48940: LD_VAR 0 2
48944: ARRAY
48945: PUSH
48946: LD_EXP 121
48950: PUSH
48951: LD_VAR 0 2
48955: ARRAY
48956: UNION
48957: PPUSH
48958: LD_INT 33
48960: PUSH
48961: LD_INT 2
48963: PUSH
48964: EMPTY
48965: LIST
48966: LIST
48967: PPUSH
48968: CALL_OW 72
48972: ST_TO_ADDR
// if tmp then
48973: LD_VAR 0 4
48977: IFFALSE 49069
// for j in tmp do
48979: LD_ADDR_VAR 0 3
48983: PUSH
48984: LD_VAR 0 4
48988: PUSH
48989: FOR_IN
48990: IFFALSE 49067
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48992: LD_VAR 0 3
48996: PPUSH
48997: CALL_OW 312
49001: NOT
49002: PUSH
49003: LD_VAR 0 3
49007: PPUSH
49008: CALL_OW 256
49012: PUSH
49013: LD_INT 250
49015: GREATEREQUAL
49016: AND
49017: IFFALSE 49030
// Connect ( j ) else
49019: LD_VAR 0 3
49023: PPUSH
49024: CALL 74237 0 1
49028: GO 49065
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49030: LD_VAR 0 3
49034: PPUSH
49035: CALL_OW 256
49039: PUSH
49040: LD_INT 250
49042: LESS
49043: PUSH
49044: LD_VAR 0 3
49048: PPUSH
49049: CALL_OW 312
49053: AND
49054: IFFALSE 49065
// ComUnlink ( j ) ;
49056: LD_VAR 0 3
49060: PPUSH
49061: CALL_OW 136
49065: GO 48989
49067: POP
49068: POP
// end ;
49069: GO 48927
49071: POP
49072: POP
// end ;
49073: LD_VAR 0 1
49077: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49078: LD_INT 0
49080: PPUSH
49081: PPUSH
49082: PPUSH
49083: PPUSH
49084: PPUSH
// if not mc_bases then
49085: LD_EXP 99
49089: NOT
49090: IFFALSE 49094
// exit ;
49092: GO 49539
// for i = 1 to mc_bases do
49094: LD_ADDR_VAR 0 2
49098: PUSH
49099: DOUBLE
49100: LD_INT 1
49102: DEC
49103: ST_TO_ADDR
49104: LD_EXP 99
49108: PUSH
49109: FOR_TO
49110: IFFALSE 49537
// begin if not mc_produce [ i ] then
49112: LD_EXP 120
49116: PUSH
49117: LD_VAR 0 2
49121: ARRAY
49122: NOT
49123: IFFALSE 49127
// continue ;
49125: GO 49109
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49127: LD_ADDR_VAR 0 5
49131: PUSH
49132: LD_EXP 99
49136: PUSH
49137: LD_VAR 0 2
49141: ARRAY
49142: PPUSH
49143: LD_INT 30
49145: PUSH
49146: LD_INT 3
49148: PUSH
49149: EMPTY
49150: LIST
49151: LIST
49152: PPUSH
49153: CALL_OW 72
49157: ST_TO_ADDR
// if not fac then
49158: LD_VAR 0 5
49162: NOT
49163: IFFALSE 49167
// continue ;
49165: GO 49109
// for j in fac do
49167: LD_ADDR_VAR 0 3
49171: PUSH
49172: LD_VAR 0 5
49176: PUSH
49177: FOR_IN
49178: IFFALSE 49533
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49180: LD_VAR 0 3
49184: PPUSH
49185: CALL_OW 461
49189: PUSH
49190: LD_INT 2
49192: NONEQUAL
49193: PUSH
49194: LD_VAR 0 3
49198: PPUSH
49199: LD_INT 15
49201: PPUSH
49202: CALL 73897 0 2
49206: PUSH
49207: LD_INT 4
49209: ARRAY
49210: OR
49211: IFFALSE 49215
// continue ;
49213: GO 49177
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49215: LD_VAR 0 3
49219: PPUSH
49220: LD_EXP 120
49224: PUSH
49225: LD_VAR 0 2
49229: ARRAY
49230: PUSH
49231: LD_INT 1
49233: ARRAY
49234: PUSH
49235: LD_INT 1
49237: ARRAY
49238: PPUSH
49239: LD_EXP 120
49243: PUSH
49244: LD_VAR 0 2
49248: ARRAY
49249: PUSH
49250: LD_INT 1
49252: ARRAY
49253: PUSH
49254: LD_INT 2
49256: ARRAY
49257: PPUSH
49258: LD_EXP 120
49262: PUSH
49263: LD_VAR 0 2
49267: ARRAY
49268: PUSH
49269: LD_INT 1
49271: ARRAY
49272: PUSH
49273: LD_INT 3
49275: ARRAY
49276: PPUSH
49277: LD_EXP 120
49281: PUSH
49282: LD_VAR 0 2
49286: ARRAY
49287: PUSH
49288: LD_INT 1
49290: ARRAY
49291: PUSH
49292: LD_INT 4
49294: ARRAY
49295: PPUSH
49296: CALL_OW 448
49300: PUSH
49301: LD_VAR 0 3
49305: PPUSH
49306: LD_EXP 120
49310: PUSH
49311: LD_VAR 0 2
49315: ARRAY
49316: PUSH
49317: LD_INT 1
49319: ARRAY
49320: PUSH
49321: LD_INT 1
49323: ARRAY
49324: PUSH
49325: LD_EXP 120
49329: PUSH
49330: LD_VAR 0 2
49334: ARRAY
49335: PUSH
49336: LD_INT 1
49338: ARRAY
49339: PUSH
49340: LD_INT 2
49342: ARRAY
49343: PUSH
49344: LD_EXP 120
49348: PUSH
49349: LD_VAR 0 2
49353: ARRAY
49354: PUSH
49355: LD_INT 1
49357: ARRAY
49358: PUSH
49359: LD_INT 3
49361: ARRAY
49362: PUSH
49363: LD_EXP 120
49367: PUSH
49368: LD_VAR 0 2
49372: ARRAY
49373: PUSH
49374: LD_INT 1
49376: ARRAY
49377: PUSH
49378: LD_INT 4
49380: ARRAY
49381: PUSH
49382: EMPTY
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: PPUSH
49388: CALL 77568 0 2
49392: AND
49393: IFFALSE 49531
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49395: LD_VAR 0 3
49399: PPUSH
49400: LD_EXP 120
49404: PUSH
49405: LD_VAR 0 2
49409: ARRAY
49410: PUSH
49411: LD_INT 1
49413: ARRAY
49414: PUSH
49415: LD_INT 1
49417: ARRAY
49418: PPUSH
49419: LD_EXP 120
49423: PUSH
49424: LD_VAR 0 2
49428: ARRAY
49429: PUSH
49430: LD_INT 1
49432: ARRAY
49433: PUSH
49434: LD_INT 2
49436: ARRAY
49437: PPUSH
49438: LD_EXP 120
49442: PUSH
49443: LD_VAR 0 2
49447: ARRAY
49448: PUSH
49449: LD_INT 1
49451: ARRAY
49452: PUSH
49453: LD_INT 3
49455: ARRAY
49456: PPUSH
49457: LD_EXP 120
49461: PUSH
49462: LD_VAR 0 2
49466: ARRAY
49467: PUSH
49468: LD_INT 1
49470: ARRAY
49471: PUSH
49472: LD_INT 4
49474: ARRAY
49475: PPUSH
49476: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49480: LD_ADDR_VAR 0 4
49484: PUSH
49485: LD_EXP 120
49489: PUSH
49490: LD_VAR 0 2
49494: ARRAY
49495: PPUSH
49496: LD_INT 1
49498: PPUSH
49499: CALL_OW 3
49503: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49504: LD_ADDR_EXP 120
49508: PUSH
49509: LD_EXP 120
49513: PPUSH
49514: LD_VAR 0 2
49518: PPUSH
49519: LD_VAR 0 4
49523: PPUSH
49524: CALL_OW 1
49528: ST_TO_ADDR
// break ;
49529: GO 49533
// end ; end ;
49531: GO 49177
49533: POP
49534: POP
// end ;
49535: GO 49109
49537: POP
49538: POP
// end ;
49539: LD_VAR 0 1
49543: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49544: LD_INT 0
49546: PPUSH
49547: PPUSH
49548: PPUSH
// if not mc_bases then
49549: LD_EXP 99
49553: NOT
49554: IFFALSE 49558
// exit ;
49556: GO 49647
// for i = 1 to mc_bases do
49558: LD_ADDR_VAR 0 2
49562: PUSH
49563: DOUBLE
49564: LD_INT 1
49566: DEC
49567: ST_TO_ADDR
49568: LD_EXP 99
49572: PUSH
49573: FOR_TO
49574: IFFALSE 49645
// begin if mc_attack [ i ] then
49576: LD_EXP 119
49580: PUSH
49581: LD_VAR 0 2
49585: ARRAY
49586: IFFALSE 49643
// begin tmp := mc_attack [ i ] [ 1 ] ;
49588: LD_ADDR_VAR 0 3
49592: PUSH
49593: LD_EXP 119
49597: PUSH
49598: LD_VAR 0 2
49602: ARRAY
49603: PUSH
49604: LD_INT 1
49606: ARRAY
49607: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49608: LD_ADDR_EXP 119
49612: PUSH
49613: LD_EXP 119
49617: PPUSH
49618: LD_VAR 0 2
49622: PPUSH
49623: EMPTY
49624: PPUSH
49625: CALL_OW 1
49629: ST_TO_ADDR
// Attack ( tmp ) ;
49630: LD_VAR 0 3
49634: PPUSH
49635: CALL 99781 0 1
// exit ;
49639: POP
49640: POP
49641: GO 49647
// end ; end ;
49643: GO 49573
49645: POP
49646: POP
// end ;
49647: LD_VAR 0 1
49651: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49652: LD_INT 0
49654: PPUSH
49655: PPUSH
49656: PPUSH
49657: PPUSH
49658: PPUSH
49659: PPUSH
49660: PPUSH
// if not mc_bases then
49661: LD_EXP 99
49665: NOT
49666: IFFALSE 49670
// exit ;
49668: GO 50252
// for i = 1 to mc_bases do
49670: LD_ADDR_VAR 0 2
49674: PUSH
49675: DOUBLE
49676: LD_INT 1
49678: DEC
49679: ST_TO_ADDR
49680: LD_EXP 99
49684: PUSH
49685: FOR_TO
49686: IFFALSE 50250
// begin if not mc_bases [ i ] then
49688: LD_EXP 99
49692: PUSH
49693: LD_VAR 0 2
49697: ARRAY
49698: NOT
49699: IFFALSE 49703
// continue ;
49701: GO 49685
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49703: LD_ADDR_VAR 0 7
49707: PUSH
49708: LD_EXP 99
49712: PUSH
49713: LD_VAR 0 2
49717: ARRAY
49718: PUSH
49719: LD_INT 1
49721: ARRAY
49722: PPUSH
49723: CALL 68140 0 1
49727: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49728: LD_ADDR_EXP 122
49732: PUSH
49733: LD_EXP 122
49737: PPUSH
49738: LD_VAR 0 2
49742: PPUSH
49743: LD_EXP 99
49747: PUSH
49748: LD_VAR 0 2
49752: ARRAY
49753: PUSH
49754: LD_INT 1
49756: ARRAY
49757: PPUSH
49758: CALL_OW 255
49762: PPUSH
49763: LD_EXP 124
49767: PUSH
49768: LD_VAR 0 2
49772: ARRAY
49773: PPUSH
49774: CALL 65694 0 2
49778: PPUSH
49779: CALL_OW 1
49783: ST_TO_ADDR
// if not mc_scan [ i ] then
49784: LD_EXP 122
49788: PUSH
49789: LD_VAR 0 2
49793: ARRAY
49794: NOT
49795: IFFALSE 49950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49797: LD_ADDR_VAR 0 4
49801: PUSH
49802: LD_EXP 99
49806: PUSH
49807: LD_VAR 0 2
49811: ARRAY
49812: PPUSH
49813: LD_INT 2
49815: PUSH
49816: LD_INT 25
49818: PUSH
49819: LD_INT 5
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 25
49828: PUSH
49829: LD_INT 8
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: PUSH
49836: LD_INT 25
49838: PUSH
49839: LD_INT 9
49841: PUSH
49842: EMPTY
49843: LIST
49844: LIST
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: PPUSH
49852: CALL_OW 72
49856: ST_TO_ADDR
// if not tmp then
49857: LD_VAR 0 4
49861: NOT
49862: IFFALSE 49866
// continue ;
49864: GO 49685
// for j in tmp do
49866: LD_ADDR_VAR 0 3
49870: PUSH
49871: LD_VAR 0 4
49875: PUSH
49876: FOR_IN
49877: IFFALSE 49948
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49879: LD_VAR 0 3
49883: PPUSH
49884: CALL_OW 310
49888: PPUSH
49889: CALL_OW 266
49893: PUSH
49894: LD_INT 5
49896: EQUAL
49897: PUSH
49898: LD_VAR 0 3
49902: PPUSH
49903: CALL_OW 257
49907: PUSH
49908: LD_INT 1
49910: EQUAL
49911: AND
49912: PUSH
49913: LD_VAR 0 3
49917: PPUSH
49918: CALL_OW 459
49922: NOT
49923: AND
49924: PUSH
49925: LD_VAR 0 7
49929: AND
49930: IFFALSE 49946
// ComChangeProfession ( j , class ) ;
49932: LD_VAR 0 3
49936: PPUSH
49937: LD_VAR 0 7
49941: PPUSH
49942: CALL_OW 123
49946: GO 49876
49948: POP
49949: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49950: LD_EXP 122
49954: PUSH
49955: LD_VAR 0 2
49959: ARRAY
49960: PUSH
49961: LD_EXP 121
49965: PUSH
49966: LD_VAR 0 2
49970: ARRAY
49971: NOT
49972: AND
49973: PUSH
49974: LD_EXP 99
49978: PUSH
49979: LD_VAR 0 2
49983: ARRAY
49984: PPUSH
49985: LD_INT 30
49987: PUSH
49988: LD_INT 32
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PPUSH
49995: CALL_OW 72
49999: NOT
50000: AND
50001: PUSH
50002: LD_EXP 99
50006: PUSH
50007: LD_VAR 0 2
50011: ARRAY
50012: PPUSH
50013: LD_INT 2
50015: PUSH
50016: LD_INT 30
50018: PUSH
50019: LD_INT 4
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: PUSH
50026: LD_INT 30
50028: PUSH
50029: LD_INT 5
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: PUSH
50036: EMPTY
50037: LIST
50038: LIST
50039: LIST
50040: PPUSH
50041: CALL_OW 72
50045: NOT
50046: AND
50047: IFFALSE 50179
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50049: LD_ADDR_VAR 0 4
50053: PUSH
50054: LD_EXP 99
50058: PUSH
50059: LD_VAR 0 2
50063: ARRAY
50064: PPUSH
50065: LD_INT 2
50067: PUSH
50068: LD_INT 25
50070: PUSH
50071: LD_INT 1
50073: PUSH
50074: EMPTY
50075: LIST
50076: LIST
50077: PUSH
50078: LD_INT 25
50080: PUSH
50081: LD_INT 5
50083: PUSH
50084: EMPTY
50085: LIST
50086: LIST
50087: PUSH
50088: LD_INT 25
50090: PUSH
50091: LD_INT 8
50093: PUSH
50094: EMPTY
50095: LIST
50096: LIST
50097: PUSH
50098: LD_INT 25
50100: PUSH
50101: LD_INT 9
50103: PUSH
50104: EMPTY
50105: LIST
50106: LIST
50107: PUSH
50108: EMPTY
50109: LIST
50110: LIST
50111: LIST
50112: LIST
50113: LIST
50114: PPUSH
50115: CALL_OW 72
50119: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50120: LD_ADDR_VAR 0 4
50124: PUSH
50125: LD_VAR 0 4
50129: PUSH
50130: LD_VAR 0 4
50134: PPUSH
50135: LD_INT 18
50137: PPUSH
50138: CALL 104564 0 2
50142: DIFF
50143: ST_TO_ADDR
// if tmp then
50144: LD_VAR 0 4
50148: IFFALSE 50179
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50150: LD_VAR 0 2
50154: PPUSH
50155: LD_VAR 0 4
50159: PPUSH
50160: LD_EXP 124
50164: PUSH
50165: LD_VAR 0 2
50169: ARRAY
50170: PPUSH
50171: CALL 65729 0 3
// exit ;
50175: POP
50176: POP
50177: GO 50252
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50179: LD_EXP 122
50183: PUSH
50184: LD_VAR 0 2
50188: ARRAY
50189: PUSH
50190: LD_EXP 121
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: AND
50201: IFFALSE 50248
// begin tmp := mc_defender [ i ] ;
50203: LD_ADDR_VAR 0 4
50207: PUSH
50208: LD_EXP 121
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50219: LD_VAR 0 2
50223: PPUSH
50224: LD_VAR 0 4
50228: PPUSH
50229: LD_EXP 122
50233: PUSH
50234: LD_VAR 0 2
50238: ARRAY
50239: PPUSH
50240: CALL 66290 0 3
// exit ;
50244: POP
50245: POP
50246: GO 50252
// end ; end ;
50248: GO 49685
50250: POP
50251: POP
// end ;
50252: LD_VAR 0 1
50256: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50257: LD_INT 0
50259: PPUSH
50260: PPUSH
50261: PPUSH
50262: PPUSH
50263: PPUSH
50264: PPUSH
50265: PPUSH
50266: PPUSH
50267: PPUSH
50268: PPUSH
50269: PPUSH
// if not mc_bases then
50270: LD_EXP 99
50274: NOT
50275: IFFALSE 50279
// exit ;
50277: GO 51366
// for i = 1 to mc_bases do
50279: LD_ADDR_VAR 0 2
50283: PUSH
50284: DOUBLE
50285: LD_INT 1
50287: DEC
50288: ST_TO_ADDR
50289: LD_EXP 99
50293: PUSH
50294: FOR_TO
50295: IFFALSE 51364
// begin tmp := mc_lab [ i ] ;
50297: LD_ADDR_VAR 0 6
50301: PUSH
50302: LD_EXP 132
50306: PUSH
50307: LD_VAR 0 2
50311: ARRAY
50312: ST_TO_ADDR
// if not tmp then
50313: LD_VAR 0 6
50317: NOT
50318: IFFALSE 50322
// continue ;
50320: GO 50294
// idle_lab := 0 ;
50322: LD_ADDR_VAR 0 11
50326: PUSH
50327: LD_INT 0
50329: ST_TO_ADDR
// for j in tmp do
50330: LD_ADDR_VAR 0 3
50334: PUSH
50335: LD_VAR 0 6
50339: PUSH
50340: FOR_IN
50341: IFFALSE 51360
// begin researching := false ;
50343: LD_ADDR_VAR 0 10
50347: PUSH
50348: LD_INT 0
50350: ST_TO_ADDR
// side := GetSide ( j ) ;
50351: LD_ADDR_VAR 0 4
50355: PUSH
50356: LD_VAR 0 3
50360: PPUSH
50361: CALL_OW 255
50365: ST_TO_ADDR
// if not mc_tech [ side ] then
50366: LD_EXP 126
50370: PUSH
50371: LD_VAR 0 4
50375: ARRAY
50376: NOT
50377: IFFALSE 50381
// continue ;
50379: GO 50340
// if BuildingStatus ( j ) = bs_idle then
50381: LD_VAR 0 3
50385: PPUSH
50386: CALL_OW 461
50390: PUSH
50391: LD_INT 2
50393: EQUAL
50394: IFFALSE 50582
// begin if idle_lab and UnitsInside ( j ) < 6 then
50396: LD_VAR 0 11
50400: PUSH
50401: LD_VAR 0 3
50405: PPUSH
50406: CALL_OW 313
50410: PUSH
50411: LD_INT 6
50413: LESS
50414: AND
50415: IFFALSE 50486
// begin tmp2 := UnitsInside ( idle_lab ) ;
50417: LD_ADDR_VAR 0 9
50421: PUSH
50422: LD_VAR 0 11
50426: PPUSH
50427: CALL_OW 313
50431: ST_TO_ADDR
// if tmp2 then
50432: LD_VAR 0 9
50436: IFFALSE 50478
// for x in tmp2 do
50438: LD_ADDR_VAR 0 7
50442: PUSH
50443: LD_VAR 0 9
50447: PUSH
50448: FOR_IN
50449: IFFALSE 50476
// begin ComExitBuilding ( x ) ;
50451: LD_VAR 0 7
50455: PPUSH
50456: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50460: LD_VAR 0 7
50464: PPUSH
50465: LD_VAR 0 3
50469: PPUSH
50470: CALL_OW 180
// end ;
50474: GO 50448
50476: POP
50477: POP
// idle_lab := 0 ;
50478: LD_ADDR_VAR 0 11
50482: PUSH
50483: LD_INT 0
50485: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50486: LD_ADDR_VAR 0 5
50490: PUSH
50491: LD_EXP 126
50495: PUSH
50496: LD_VAR 0 4
50500: ARRAY
50501: PUSH
50502: FOR_IN
50503: IFFALSE 50563
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50505: LD_VAR 0 3
50509: PPUSH
50510: LD_VAR 0 5
50514: PPUSH
50515: CALL_OW 430
50519: PUSH
50520: LD_VAR 0 4
50524: PPUSH
50525: LD_VAR 0 5
50529: PPUSH
50530: CALL 64799 0 2
50534: AND
50535: IFFALSE 50561
// begin researching := true ;
50537: LD_ADDR_VAR 0 10
50541: PUSH
50542: LD_INT 1
50544: ST_TO_ADDR
// ComResearch ( j , t ) ;
50545: LD_VAR 0 3
50549: PPUSH
50550: LD_VAR 0 5
50554: PPUSH
50555: CALL_OW 124
// break ;
50559: GO 50563
// end ;
50561: GO 50502
50563: POP
50564: POP
// if not researching then
50565: LD_VAR 0 10
50569: NOT
50570: IFFALSE 50582
// idle_lab := j ;
50572: LD_ADDR_VAR 0 11
50576: PUSH
50577: LD_VAR 0 3
50581: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50582: LD_VAR 0 3
50586: PPUSH
50587: CALL_OW 461
50591: PUSH
50592: LD_INT 10
50594: EQUAL
50595: IFFALSE 51183
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50597: LD_EXP 128
50601: PUSH
50602: LD_VAR 0 2
50606: ARRAY
50607: NOT
50608: PUSH
50609: LD_EXP 129
50613: PUSH
50614: LD_VAR 0 2
50618: ARRAY
50619: NOT
50620: AND
50621: PUSH
50622: LD_EXP 126
50626: PUSH
50627: LD_VAR 0 4
50631: ARRAY
50632: PUSH
50633: LD_INT 1
50635: GREATER
50636: AND
50637: IFFALSE 50768
// begin ComCancel ( j ) ;
50639: LD_VAR 0 3
50643: PPUSH
50644: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50648: LD_ADDR_EXP 126
50652: PUSH
50653: LD_EXP 126
50657: PPUSH
50658: LD_VAR 0 4
50662: PPUSH
50663: LD_EXP 126
50667: PUSH
50668: LD_VAR 0 4
50672: ARRAY
50673: PPUSH
50674: LD_EXP 126
50678: PUSH
50679: LD_VAR 0 4
50683: ARRAY
50684: PUSH
50685: LD_INT 1
50687: MINUS
50688: PPUSH
50689: LD_EXP 126
50693: PUSH
50694: LD_VAR 0 4
50698: ARRAY
50699: PPUSH
50700: LD_INT 0
50702: PPUSH
50703: CALL 70722 0 4
50707: PPUSH
50708: CALL_OW 1
50712: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50713: LD_ADDR_EXP 126
50717: PUSH
50718: LD_EXP 126
50722: PPUSH
50723: LD_VAR 0 4
50727: PPUSH
50728: LD_EXP 126
50732: PUSH
50733: LD_VAR 0 4
50737: ARRAY
50738: PPUSH
50739: LD_EXP 126
50743: PUSH
50744: LD_VAR 0 4
50748: ARRAY
50749: PPUSH
50750: LD_INT 1
50752: PPUSH
50753: LD_INT 0
50755: PPUSH
50756: CALL 70722 0 4
50760: PPUSH
50761: CALL_OW 1
50765: ST_TO_ADDR
// continue ;
50766: GO 50340
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50768: LD_EXP 128
50772: PUSH
50773: LD_VAR 0 2
50777: ARRAY
50778: PUSH
50779: LD_EXP 129
50783: PUSH
50784: LD_VAR 0 2
50788: ARRAY
50789: NOT
50790: AND
50791: IFFALSE 50918
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50793: LD_ADDR_EXP 129
50797: PUSH
50798: LD_EXP 129
50802: PPUSH
50803: LD_VAR 0 2
50807: PUSH
50808: LD_EXP 129
50812: PUSH
50813: LD_VAR 0 2
50817: ARRAY
50818: PUSH
50819: LD_INT 1
50821: PLUS
50822: PUSH
50823: EMPTY
50824: LIST
50825: LIST
50826: PPUSH
50827: LD_EXP 128
50831: PUSH
50832: LD_VAR 0 2
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: PPUSH
50842: CALL 71304 0 3
50846: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50847: LD_EXP 128
50851: PUSH
50852: LD_VAR 0 2
50856: ARRAY
50857: PUSH
50858: LD_INT 1
50860: ARRAY
50861: PPUSH
50862: LD_INT 112
50864: PPUSH
50865: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50869: LD_ADDR_VAR 0 9
50873: PUSH
50874: LD_EXP 128
50878: PUSH
50879: LD_VAR 0 2
50883: ARRAY
50884: PPUSH
50885: LD_INT 1
50887: PPUSH
50888: CALL_OW 3
50892: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50893: LD_ADDR_EXP 128
50897: PUSH
50898: LD_EXP 128
50902: PPUSH
50903: LD_VAR 0 2
50907: PPUSH
50908: LD_VAR 0 9
50912: PPUSH
50913: CALL_OW 1
50917: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50918: LD_EXP 128
50922: PUSH
50923: LD_VAR 0 2
50927: ARRAY
50928: PUSH
50929: LD_EXP 129
50933: PUSH
50934: LD_VAR 0 2
50938: ARRAY
50939: AND
50940: PUSH
50941: LD_EXP 129
50945: PUSH
50946: LD_VAR 0 2
50950: ARRAY
50951: PUSH
50952: LD_INT 1
50954: ARRAY
50955: PPUSH
50956: CALL_OW 310
50960: NOT
50961: AND
50962: PUSH
50963: LD_VAR 0 3
50967: PPUSH
50968: CALL_OW 313
50972: PUSH
50973: LD_INT 6
50975: EQUAL
50976: AND
50977: IFFALSE 51033
// begin tmp2 := UnitsInside ( j ) ;
50979: LD_ADDR_VAR 0 9
50983: PUSH
50984: LD_VAR 0 3
50988: PPUSH
50989: CALL_OW 313
50993: ST_TO_ADDR
// if tmp2 = 6 then
50994: LD_VAR 0 9
50998: PUSH
50999: LD_INT 6
51001: EQUAL
51002: IFFALSE 51033
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51004: LD_VAR 0 9
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PPUSH
51013: LD_INT 112
51015: PPUSH
51016: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51020: LD_VAR 0 9
51024: PUSH
51025: LD_INT 1
51027: ARRAY
51028: PPUSH
51029: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51033: LD_EXP 129
51037: PUSH
51038: LD_VAR 0 2
51042: ARRAY
51043: PUSH
51044: LD_EXP 129
51048: PUSH
51049: LD_VAR 0 2
51053: ARRAY
51054: PUSH
51055: LD_INT 1
51057: ARRAY
51058: PPUSH
51059: CALL_OW 314
51063: NOT
51064: AND
51065: PUSH
51066: LD_EXP 129
51070: PUSH
51071: LD_VAR 0 2
51075: ARRAY
51076: PUSH
51077: LD_INT 1
51079: ARRAY
51080: PPUSH
51081: CALL_OW 310
51085: NOT
51086: AND
51087: IFFALSE 51113
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51089: LD_EXP 129
51093: PUSH
51094: LD_VAR 0 2
51098: ARRAY
51099: PUSH
51100: LD_INT 1
51102: ARRAY
51103: PPUSH
51104: LD_VAR 0 3
51108: PPUSH
51109: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51113: LD_EXP 129
51117: PUSH
51118: LD_VAR 0 2
51122: ARRAY
51123: PUSH
51124: LD_INT 1
51126: ARRAY
51127: PPUSH
51128: CALL_OW 310
51132: PUSH
51133: LD_EXP 129
51137: PUSH
51138: LD_VAR 0 2
51142: ARRAY
51143: PUSH
51144: LD_INT 1
51146: ARRAY
51147: PPUSH
51148: CALL_OW 310
51152: PPUSH
51153: CALL_OW 461
51157: PUSH
51158: LD_INT 3
51160: NONEQUAL
51161: AND
51162: IFFALSE 51183
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51164: LD_EXP 129
51168: PUSH
51169: LD_VAR 0 2
51173: ARRAY
51174: PUSH
51175: LD_INT 1
51177: ARRAY
51178: PPUSH
51179: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51183: LD_VAR 0 3
51187: PPUSH
51188: CALL_OW 461
51192: PUSH
51193: LD_INT 6
51195: EQUAL
51196: PUSH
51197: LD_VAR 0 6
51201: PUSH
51202: LD_INT 1
51204: GREATER
51205: AND
51206: IFFALSE 51358
// begin sci := [ ] ;
51208: LD_ADDR_VAR 0 8
51212: PUSH
51213: EMPTY
51214: ST_TO_ADDR
// for x in ( tmp diff j ) do
51215: LD_ADDR_VAR 0 7
51219: PUSH
51220: LD_VAR 0 6
51224: PUSH
51225: LD_VAR 0 3
51229: DIFF
51230: PUSH
51231: FOR_IN
51232: IFFALSE 51284
// begin if sci = 6 then
51234: LD_VAR 0 8
51238: PUSH
51239: LD_INT 6
51241: EQUAL
51242: IFFALSE 51246
// break ;
51244: GO 51284
// if BuildingStatus ( x ) = bs_idle then
51246: LD_VAR 0 7
51250: PPUSH
51251: CALL_OW 461
51255: PUSH
51256: LD_INT 2
51258: EQUAL
51259: IFFALSE 51282
// sci := sci ^ UnitsInside ( x ) ;
51261: LD_ADDR_VAR 0 8
51265: PUSH
51266: LD_VAR 0 8
51270: PUSH
51271: LD_VAR 0 7
51275: PPUSH
51276: CALL_OW 313
51280: ADD
51281: ST_TO_ADDR
// end ;
51282: GO 51231
51284: POP
51285: POP
// if not sci then
51286: LD_VAR 0 8
51290: NOT
51291: IFFALSE 51295
// continue ;
51293: GO 50340
// for x in sci do
51295: LD_ADDR_VAR 0 7
51299: PUSH
51300: LD_VAR 0 8
51304: PUSH
51305: FOR_IN
51306: IFFALSE 51356
// if IsInUnit ( x ) and not HasTask ( x ) then
51308: LD_VAR 0 7
51312: PPUSH
51313: CALL_OW 310
51317: PUSH
51318: LD_VAR 0 7
51322: PPUSH
51323: CALL_OW 314
51327: NOT
51328: AND
51329: IFFALSE 51354
// begin ComExitBuilding ( x ) ;
51331: LD_VAR 0 7
51335: PPUSH
51336: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51340: LD_VAR 0 7
51344: PPUSH
51345: LD_VAR 0 3
51349: PPUSH
51350: CALL_OW 180
// end ;
51354: GO 51305
51356: POP
51357: POP
// end ; end ;
51358: GO 50340
51360: POP
51361: POP
// end ;
51362: GO 50294
51364: POP
51365: POP
// end ;
51366: LD_VAR 0 1
51370: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51371: LD_INT 0
51373: PPUSH
51374: PPUSH
// if not mc_bases then
51375: LD_EXP 99
51379: NOT
51380: IFFALSE 51384
// exit ;
51382: GO 51465
// for i = 1 to mc_bases do
51384: LD_ADDR_VAR 0 2
51388: PUSH
51389: DOUBLE
51390: LD_INT 1
51392: DEC
51393: ST_TO_ADDR
51394: LD_EXP 99
51398: PUSH
51399: FOR_TO
51400: IFFALSE 51463
// if mc_mines [ i ] and mc_miners [ i ] then
51402: LD_EXP 112
51406: PUSH
51407: LD_VAR 0 2
51411: ARRAY
51412: PUSH
51413: LD_EXP 113
51417: PUSH
51418: LD_VAR 0 2
51422: ARRAY
51423: AND
51424: IFFALSE 51461
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51426: LD_EXP 113
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: PUSH
51437: LD_INT 1
51439: ARRAY
51440: PPUSH
51441: CALL_OW 255
51445: PPUSH
51446: LD_EXP 112
51450: PUSH
51451: LD_VAR 0 2
51455: ARRAY
51456: PPUSH
51457: CALL 68293 0 2
51461: GO 51399
51463: POP
51464: POP
// end ;
51465: LD_VAR 0 1
51469: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51470: LD_INT 0
51472: PPUSH
51473: PPUSH
51474: PPUSH
51475: PPUSH
51476: PPUSH
51477: PPUSH
51478: PPUSH
51479: PPUSH
// if not mc_bases or not mc_parking then
51480: LD_EXP 99
51484: NOT
51485: PUSH
51486: LD_EXP 123
51490: NOT
51491: OR
51492: IFFALSE 51496
// exit ;
51494: GO 52195
// for i = 1 to mc_bases do
51496: LD_ADDR_VAR 0 2
51500: PUSH
51501: DOUBLE
51502: LD_INT 1
51504: DEC
51505: ST_TO_ADDR
51506: LD_EXP 99
51510: PUSH
51511: FOR_TO
51512: IFFALSE 52193
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51514: LD_EXP 99
51518: PUSH
51519: LD_VAR 0 2
51523: ARRAY
51524: NOT
51525: PUSH
51526: LD_EXP 123
51530: PUSH
51531: LD_VAR 0 2
51535: ARRAY
51536: NOT
51537: OR
51538: IFFALSE 51542
// continue ;
51540: GO 51511
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51542: LD_ADDR_VAR 0 5
51546: PUSH
51547: LD_EXP 99
51551: PUSH
51552: LD_VAR 0 2
51556: ARRAY
51557: PUSH
51558: LD_INT 1
51560: ARRAY
51561: PPUSH
51562: CALL_OW 255
51566: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51567: LD_ADDR_VAR 0 6
51571: PUSH
51572: LD_EXP 99
51576: PUSH
51577: LD_VAR 0 2
51581: ARRAY
51582: PPUSH
51583: LD_INT 30
51585: PUSH
51586: LD_INT 3
51588: PUSH
51589: EMPTY
51590: LIST
51591: LIST
51592: PPUSH
51593: CALL_OW 72
51597: ST_TO_ADDR
// if not fac then
51598: LD_VAR 0 6
51602: NOT
51603: IFFALSE 51654
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51605: LD_ADDR_VAR 0 6
51609: PUSH
51610: LD_EXP 99
51614: PUSH
51615: LD_VAR 0 2
51619: ARRAY
51620: PPUSH
51621: LD_INT 2
51623: PUSH
51624: LD_INT 30
51626: PUSH
51627: LD_INT 0
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: PUSH
51634: LD_INT 30
51636: PUSH
51637: LD_INT 1
51639: PUSH
51640: EMPTY
51641: LIST
51642: LIST
51643: PUSH
51644: EMPTY
51645: LIST
51646: LIST
51647: LIST
51648: PPUSH
51649: CALL_OW 72
51653: ST_TO_ADDR
// if not fac then
51654: LD_VAR 0 6
51658: NOT
51659: IFFALSE 51663
// continue ;
51661: GO 51511
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51663: LD_ADDR_VAR 0 7
51667: PUSH
51668: LD_EXP 123
51672: PUSH
51673: LD_VAR 0 2
51677: ARRAY
51678: PPUSH
51679: LD_INT 22
51681: PUSH
51682: LD_VAR 0 5
51686: PUSH
51687: EMPTY
51688: LIST
51689: LIST
51690: PUSH
51691: LD_INT 21
51693: PUSH
51694: LD_INT 2
51696: PUSH
51697: EMPTY
51698: LIST
51699: LIST
51700: PUSH
51701: LD_INT 3
51703: PUSH
51704: LD_INT 24
51706: PUSH
51707: LD_INT 1000
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: PUSH
51714: EMPTY
51715: LIST
51716: LIST
51717: PUSH
51718: EMPTY
51719: LIST
51720: LIST
51721: LIST
51722: PPUSH
51723: CALL_OW 70
51727: ST_TO_ADDR
// for j in fac do
51728: LD_ADDR_VAR 0 3
51732: PUSH
51733: LD_VAR 0 6
51737: PUSH
51738: FOR_IN
51739: IFFALSE 51820
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51741: LD_ADDR_VAR 0 7
51745: PUSH
51746: LD_VAR 0 7
51750: PUSH
51751: LD_INT 22
51753: PUSH
51754: LD_VAR 0 5
51758: PUSH
51759: EMPTY
51760: LIST
51761: LIST
51762: PUSH
51763: LD_INT 91
51765: PUSH
51766: LD_VAR 0 3
51770: PUSH
51771: LD_INT 15
51773: PUSH
51774: EMPTY
51775: LIST
51776: LIST
51777: LIST
51778: PUSH
51779: LD_INT 21
51781: PUSH
51782: LD_INT 2
51784: PUSH
51785: EMPTY
51786: LIST
51787: LIST
51788: PUSH
51789: LD_INT 3
51791: PUSH
51792: LD_INT 24
51794: PUSH
51795: LD_INT 1000
51797: PUSH
51798: EMPTY
51799: LIST
51800: LIST
51801: PUSH
51802: EMPTY
51803: LIST
51804: LIST
51805: PUSH
51806: EMPTY
51807: LIST
51808: LIST
51809: LIST
51810: LIST
51811: PPUSH
51812: CALL_OW 69
51816: UNION
51817: ST_TO_ADDR
51818: GO 51738
51820: POP
51821: POP
// if not vehs then
51822: LD_VAR 0 7
51826: NOT
51827: IFFALSE 51853
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51829: LD_ADDR_EXP 111
51833: PUSH
51834: LD_EXP 111
51838: PPUSH
51839: LD_VAR 0 2
51843: PPUSH
51844: EMPTY
51845: PPUSH
51846: CALL_OW 1
51850: ST_TO_ADDR
// continue ;
51851: GO 51511
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51853: LD_ADDR_VAR 0 8
51857: PUSH
51858: LD_EXP 99
51862: PUSH
51863: LD_VAR 0 2
51867: ARRAY
51868: PPUSH
51869: LD_INT 30
51871: PUSH
51872: LD_INT 3
51874: PUSH
51875: EMPTY
51876: LIST
51877: LIST
51878: PPUSH
51879: CALL_OW 72
51883: ST_TO_ADDR
// if tmp then
51884: LD_VAR 0 8
51888: IFFALSE 51991
// begin for j in tmp do
51890: LD_ADDR_VAR 0 3
51894: PUSH
51895: LD_VAR 0 8
51899: PUSH
51900: FOR_IN
51901: IFFALSE 51989
// for k in UnitsInside ( j ) do
51903: LD_ADDR_VAR 0 4
51907: PUSH
51908: LD_VAR 0 3
51912: PPUSH
51913: CALL_OW 313
51917: PUSH
51918: FOR_IN
51919: IFFALSE 51985
// if k then
51921: LD_VAR 0 4
51925: IFFALSE 51983
// if not k in mc_repair_vehicle [ i ] then
51927: LD_VAR 0 4
51931: PUSH
51932: LD_EXP 111
51936: PUSH
51937: LD_VAR 0 2
51941: ARRAY
51942: IN
51943: NOT
51944: IFFALSE 51983
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51946: LD_ADDR_EXP 111
51950: PUSH
51951: LD_EXP 111
51955: PPUSH
51956: LD_VAR 0 2
51960: PPUSH
51961: LD_EXP 111
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: PUSH
51972: LD_VAR 0 4
51976: UNION
51977: PPUSH
51978: CALL_OW 1
51982: ST_TO_ADDR
51983: GO 51918
51985: POP
51986: POP
51987: GO 51900
51989: POP
51990: POP
// end ; if not mc_repair_vehicle [ i ] then
51991: LD_EXP 111
51995: PUSH
51996: LD_VAR 0 2
52000: ARRAY
52001: NOT
52002: IFFALSE 52006
// continue ;
52004: GO 51511
// for j in mc_repair_vehicle [ i ] do
52006: LD_ADDR_VAR 0 3
52010: PUSH
52011: LD_EXP 111
52015: PUSH
52016: LD_VAR 0 2
52020: ARRAY
52021: PUSH
52022: FOR_IN
52023: IFFALSE 52189
// begin if GetClass ( j ) <> 3 then
52025: LD_VAR 0 3
52029: PPUSH
52030: CALL_OW 257
52034: PUSH
52035: LD_INT 3
52037: NONEQUAL
52038: IFFALSE 52079
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52040: LD_ADDR_EXP 111
52044: PUSH
52045: LD_EXP 111
52049: PPUSH
52050: LD_VAR 0 2
52054: PPUSH
52055: LD_EXP 111
52059: PUSH
52060: LD_VAR 0 2
52064: ARRAY
52065: PUSH
52066: LD_VAR 0 3
52070: DIFF
52071: PPUSH
52072: CALL_OW 1
52076: ST_TO_ADDR
// continue ;
52077: GO 52022
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52079: LD_VAR 0 3
52083: PPUSH
52084: CALL_OW 311
52088: NOT
52089: PUSH
52090: LD_VAR 0 3
52094: PUSH
52095: LD_EXP 102
52099: PUSH
52100: LD_VAR 0 2
52104: ARRAY
52105: PUSH
52106: LD_INT 1
52108: ARRAY
52109: IN
52110: NOT
52111: AND
52112: PUSH
52113: LD_VAR 0 3
52117: PUSH
52118: LD_EXP 102
52122: PUSH
52123: LD_VAR 0 2
52127: ARRAY
52128: PUSH
52129: LD_INT 2
52131: ARRAY
52132: IN
52133: NOT
52134: AND
52135: IFFALSE 52187
// begin if IsInUnit ( j ) then
52137: LD_VAR 0 3
52141: PPUSH
52142: CALL_OW 310
52146: IFFALSE 52157
// ComExitBuilding ( j ) ;
52148: LD_VAR 0 3
52152: PPUSH
52153: CALL_OW 122
// if not HasTask ( j ) then
52157: LD_VAR 0 3
52161: PPUSH
52162: CALL_OW 314
52166: NOT
52167: IFFALSE 52187
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52169: LD_VAR 0 3
52173: PPUSH
52174: LD_VAR 0 7
52178: PUSH
52179: LD_INT 1
52181: ARRAY
52182: PPUSH
52183: CALL_OW 189
// end ; end ;
52187: GO 52022
52189: POP
52190: POP
// end ;
52191: GO 51511
52193: POP
52194: POP
// end ;
52195: LD_VAR 0 1
52199: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52200: LD_INT 0
52202: PPUSH
52203: PPUSH
52204: PPUSH
52205: PPUSH
52206: PPUSH
52207: PPUSH
52208: PPUSH
52209: PPUSH
52210: PPUSH
52211: PPUSH
52212: PPUSH
// if not mc_bases then
52213: LD_EXP 99
52217: NOT
52218: IFFALSE 52222
// exit ;
52220: GO 53024
// for i = 1 to mc_bases do
52222: LD_ADDR_VAR 0 2
52226: PUSH
52227: DOUBLE
52228: LD_INT 1
52230: DEC
52231: ST_TO_ADDR
52232: LD_EXP 99
52236: PUSH
52237: FOR_TO
52238: IFFALSE 53022
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52240: LD_EXP 127
52244: PUSH
52245: LD_VAR 0 2
52249: ARRAY
52250: NOT
52251: PUSH
52252: LD_EXP 102
52256: PUSH
52257: LD_VAR 0 2
52261: ARRAY
52262: PUSH
52263: LD_INT 1
52265: ARRAY
52266: OR
52267: PUSH
52268: LD_EXP 102
52272: PUSH
52273: LD_VAR 0 2
52277: ARRAY
52278: PUSH
52279: LD_INT 2
52281: ARRAY
52282: OR
52283: PUSH
52284: LD_EXP 125
52288: PUSH
52289: LD_VAR 0 2
52293: ARRAY
52294: PPUSH
52295: LD_INT 1
52297: PPUSH
52298: CALL_OW 325
52302: NOT
52303: OR
52304: PUSH
52305: LD_EXP 122
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: OR
52316: IFFALSE 52320
// continue ;
52318: GO 52237
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52320: LD_ADDR_VAR 0 8
52324: PUSH
52325: LD_EXP 99
52329: PUSH
52330: LD_VAR 0 2
52334: ARRAY
52335: PPUSH
52336: LD_INT 25
52338: PUSH
52339: LD_INT 4
52341: PUSH
52342: EMPTY
52343: LIST
52344: LIST
52345: PUSH
52346: LD_INT 50
52348: PUSH
52349: EMPTY
52350: LIST
52351: PUSH
52352: LD_INT 3
52354: PUSH
52355: LD_INT 60
52357: PUSH
52358: EMPTY
52359: LIST
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: PPUSH
52370: CALL_OW 72
52374: PUSH
52375: LD_EXP 103
52379: PUSH
52380: LD_VAR 0 2
52384: ARRAY
52385: DIFF
52386: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52387: LD_ADDR_VAR 0 9
52391: PUSH
52392: LD_EXP 99
52396: PUSH
52397: LD_VAR 0 2
52401: ARRAY
52402: PPUSH
52403: LD_INT 2
52405: PUSH
52406: LD_INT 30
52408: PUSH
52409: LD_INT 0
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: PUSH
52416: LD_INT 30
52418: PUSH
52419: LD_INT 1
52421: PUSH
52422: EMPTY
52423: LIST
52424: LIST
52425: PUSH
52426: EMPTY
52427: LIST
52428: LIST
52429: LIST
52430: PPUSH
52431: CALL_OW 72
52435: ST_TO_ADDR
// if not tmp or not dep then
52436: LD_VAR 0 8
52440: NOT
52441: PUSH
52442: LD_VAR 0 9
52446: NOT
52447: OR
52448: IFFALSE 52452
// continue ;
52450: GO 52237
// side := GetSide ( tmp [ 1 ] ) ;
52452: LD_ADDR_VAR 0 11
52456: PUSH
52457: LD_VAR 0 8
52461: PUSH
52462: LD_INT 1
52464: ARRAY
52465: PPUSH
52466: CALL_OW 255
52470: ST_TO_ADDR
// dep := dep [ 1 ] ;
52471: LD_ADDR_VAR 0 9
52475: PUSH
52476: LD_VAR 0 9
52480: PUSH
52481: LD_INT 1
52483: ARRAY
52484: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52485: LD_ADDR_VAR 0 7
52489: PUSH
52490: LD_EXP 127
52494: PUSH
52495: LD_VAR 0 2
52499: ARRAY
52500: PPUSH
52501: LD_INT 22
52503: PUSH
52504: LD_INT 0
52506: PUSH
52507: EMPTY
52508: LIST
52509: LIST
52510: PUSH
52511: LD_INT 25
52513: PUSH
52514: LD_INT 12
52516: PUSH
52517: EMPTY
52518: LIST
52519: LIST
52520: PUSH
52521: EMPTY
52522: LIST
52523: LIST
52524: PPUSH
52525: CALL_OW 70
52529: PUSH
52530: LD_INT 22
52532: PUSH
52533: LD_INT 0
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 25
52542: PUSH
52543: LD_INT 12
52545: PUSH
52546: EMPTY
52547: LIST
52548: LIST
52549: PUSH
52550: LD_INT 91
52552: PUSH
52553: LD_VAR 0 9
52557: PUSH
52558: LD_INT 20
52560: PUSH
52561: EMPTY
52562: LIST
52563: LIST
52564: LIST
52565: PUSH
52566: EMPTY
52567: LIST
52568: LIST
52569: LIST
52570: PPUSH
52571: CALL_OW 69
52575: UNION
52576: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52577: LD_ADDR_VAR 0 10
52581: PUSH
52582: LD_EXP 127
52586: PUSH
52587: LD_VAR 0 2
52591: ARRAY
52592: PPUSH
52593: LD_INT 81
52595: PUSH
52596: LD_VAR 0 11
52600: PUSH
52601: EMPTY
52602: LIST
52603: LIST
52604: PPUSH
52605: CALL_OW 70
52609: ST_TO_ADDR
// if not apes or danger_at_area then
52610: LD_VAR 0 7
52614: NOT
52615: PUSH
52616: LD_VAR 0 10
52620: OR
52621: IFFALSE 52671
// begin if mc_taming [ i ] then
52623: LD_EXP 130
52627: PUSH
52628: LD_VAR 0 2
52632: ARRAY
52633: IFFALSE 52669
// begin MC_Reset ( i , 121 ) ;
52635: LD_VAR 0 2
52639: PPUSH
52640: LD_INT 121
52642: PPUSH
52643: CALL 38002 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52647: LD_ADDR_EXP 130
52651: PUSH
52652: LD_EXP 130
52656: PPUSH
52657: LD_VAR 0 2
52661: PPUSH
52662: EMPTY
52663: PPUSH
52664: CALL_OW 1
52668: ST_TO_ADDR
// end ; continue ;
52669: GO 52237
// end ; for j in tmp do
52671: LD_ADDR_VAR 0 3
52675: PUSH
52676: LD_VAR 0 8
52680: PUSH
52681: FOR_IN
52682: IFFALSE 53018
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52684: LD_VAR 0 3
52688: PUSH
52689: LD_EXP 130
52693: PUSH
52694: LD_VAR 0 2
52698: ARRAY
52699: IN
52700: NOT
52701: PUSH
52702: LD_EXP 130
52706: PUSH
52707: LD_VAR 0 2
52711: ARRAY
52712: PUSH
52713: LD_INT 3
52715: LESS
52716: AND
52717: IFFALSE 52775
// begin SetTag ( j , 121 ) ;
52719: LD_VAR 0 3
52723: PPUSH
52724: LD_INT 121
52726: PPUSH
52727: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52731: LD_ADDR_EXP 130
52735: PUSH
52736: LD_EXP 130
52740: PPUSH
52741: LD_VAR 0 2
52745: PUSH
52746: LD_EXP 130
52750: PUSH
52751: LD_VAR 0 2
52755: ARRAY
52756: PUSH
52757: LD_INT 1
52759: PLUS
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: PPUSH
52765: LD_VAR 0 3
52769: PPUSH
52770: CALL 71304 0 3
52774: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52775: LD_VAR 0 3
52779: PUSH
52780: LD_EXP 130
52784: PUSH
52785: LD_VAR 0 2
52789: ARRAY
52790: IN
52791: IFFALSE 53016
// begin if GetClass ( j ) <> 4 then
52793: LD_VAR 0 3
52797: PPUSH
52798: CALL_OW 257
52802: PUSH
52803: LD_INT 4
52805: NONEQUAL
52806: IFFALSE 52859
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52808: LD_ADDR_EXP 130
52812: PUSH
52813: LD_EXP 130
52817: PPUSH
52818: LD_VAR 0 2
52822: PPUSH
52823: LD_EXP 130
52827: PUSH
52828: LD_VAR 0 2
52832: ARRAY
52833: PUSH
52834: LD_VAR 0 3
52838: DIFF
52839: PPUSH
52840: CALL_OW 1
52844: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52845: LD_VAR 0 3
52849: PPUSH
52850: LD_INT 0
52852: PPUSH
52853: CALL_OW 109
// continue ;
52857: GO 52681
// end ; if IsInUnit ( j ) then
52859: LD_VAR 0 3
52863: PPUSH
52864: CALL_OW 310
52868: IFFALSE 52879
// ComExitBuilding ( j ) ;
52870: LD_VAR 0 3
52874: PPUSH
52875: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52879: LD_ADDR_VAR 0 6
52883: PUSH
52884: LD_VAR 0 7
52888: PPUSH
52889: LD_VAR 0 3
52893: PPUSH
52894: CALL_OW 74
52898: ST_TO_ADDR
// if not ape then
52899: LD_VAR 0 6
52903: NOT
52904: IFFALSE 52908
// break ;
52906: GO 53018
// x := GetX ( ape ) ;
52908: LD_ADDR_VAR 0 4
52912: PUSH
52913: LD_VAR 0 6
52917: PPUSH
52918: CALL_OW 250
52922: ST_TO_ADDR
// y := GetY ( ape ) ;
52923: LD_ADDR_VAR 0 5
52927: PUSH
52928: LD_VAR 0 6
52932: PPUSH
52933: CALL_OW 251
52937: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52938: LD_VAR 0 4
52942: PPUSH
52943: LD_VAR 0 5
52947: PPUSH
52948: CALL_OW 488
52952: NOT
52953: PUSH
52954: LD_VAR 0 11
52958: PPUSH
52959: LD_VAR 0 4
52963: PPUSH
52964: LD_VAR 0 5
52968: PPUSH
52969: LD_INT 20
52971: PPUSH
52972: CALL 72200 0 4
52976: PUSH
52977: LD_INT 4
52979: ARRAY
52980: OR
52981: IFFALSE 52985
// break ;
52983: GO 53018
// if not HasTask ( j ) then
52985: LD_VAR 0 3
52989: PPUSH
52990: CALL_OW 314
52994: NOT
52995: IFFALSE 53016
// ComTameXY ( j , x , y ) ;
52997: LD_VAR 0 3
53001: PPUSH
53002: LD_VAR 0 4
53006: PPUSH
53007: LD_VAR 0 5
53011: PPUSH
53012: CALL_OW 131
// end ; end ;
53016: GO 52681
53018: POP
53019: POP
// end ;
53020: GO 52237
53022: POP
53023: POP
// end ;
53024: LD_VAR 0 1
53028: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53029: LD_INT 0
53031: PPUSH
53032: PPUSH
53033: PPUSH
53034: PPUSH
53035: PPUSH
53036: PPUSH
53037: PPUSH
53038: PPUSH
// if not mc_bases then
53039: LD_EXP 99
53043: NOT
53044: IFFALSE 53048
// exit ;
53046: GO 53674
// for i = 1 to mc_bases do
53048: LD_ADDR_VAR 0 2
53052: PUSH
53053: DOUBLE
53054: LD_INT 1
53056: DEC
53057: ST_TO_ADDR
53058: LD_EXP 99
53062: PUSH
53063: FOR_TO
53064: IFFALSE 53672
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53066: LD_EXP 128
53070: PUSH
53071: LD_VAR 0 2
53075: ARRAY
53076: NOT
53077: PUSH
53078: LD_EXP 128
53082: PUSH
53083: LD_VAR 0 2
53087: ARRAY
53088: PPUSH
53089: LD_INT 25
53091: PUSH
53092: LD_INT 12
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: PPUSH
53099: CALL_OW 72
53103: NOT
53104: OR
53105: IFFALSE 53109
// continue ;
53107: GO 53063
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53109: LD_ADDR_VAR 0 5
53113: PUSH
53114: LD_EXP 128
53118: PUSH
53119: LD_VAR 0 2
53123: ARRAY
53124: PUSH
53125: LD_INT 1
53127: ARRAY
53128: PPUSH
53129: CALL_OW 255
53133: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53134: LD_VAR 0 5
53138: PPUSH
53139: LD_INT 2
53141: PPUSH
53142: CALL_OW 325
53146: IFFALSE 53399
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53148: LD_ADDR_VAR 0 4
53152: PUSH
53153: LD_EXP 128
53157: PUSH
53158: LD_VAR 0 2
53162: ARRAY
53163: PPUSH
53164: LD_INT 25
53166: PUSH
53167: LD_INT 16
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: PPUSH
53174: CALL_OW 72
53178: ST_TO_ADDR
// if tmp < 6 then
53179: LD_VAR 0 4
53183: PUSH
53184: LD_INT 6
53186: LESS
53187: IFFALSE 53399
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53189: LD_ADDR_VAR 0 6
53193: PUSH
53194: LD_EXP 99
53198: PUSH
53199: LD_VAR 0 2
53203: ARRAY
53204: PPUSH
53205: LD_INT 2
53207: PUSH
53208: LD_INT 30
53210: PUSH
53211: LD_INT 0
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: PUSH
53218: LD_INT 30
53220: PUSH
53221: LD_INT 1
53223: PUSH
53224: EMPTY
53225: LIST
53226: LIST
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: LIST
53232: PPUSH
53233: CALL_OW 72
53237: ST_TO_ADDR
// if depot then
53238: LD_VAR 0 6
53242: IFFALSE 53399
// begin selected := 0 ;
53244: LD_ADDR_VAR 0 7
53248: PUSH
53249: LD_INT 0
53251: ST_TO_ADDR
// for j in depot do
53252: LD_ADDR_VAR 0 3
53256: PUSH
53257: LD_VAR 0 6
53261: PUSH
53262: FOR_IN
53263: IFFALSE 53294
// begin if UnitsInside ( j ) < 6 then
53265: LD_VAR 0 3
53269: PPUSH
53270: CALL_OW 313
53274: PUSH
53275: LD_INT 6
53277: LESS
53278: IFFALSE 53292
// begin selected := j ;
53280: LD_ADDR_VAR 0 7
53284: PUSH
53285: LD_VAR 0 3
53289: ST_TO_ADDR
// break ;
53290: GO 53294
// end ; end ;
53292: GO 53262
53294: POP
53295: POP
// if selected then
53296: LD_VAR 0 7
53300: IFFALSE 53399
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53302: LD_ADDR_VAR 0 3
53306: PUSH
53307: LD_EXP 128
53311: PUSH
53312: LD_VAR 0 2
53316: ARRAY
53317: PPUSH
53318: LD_INT 25
53320: PUSH
53321: LD_INT 12
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PPUSH
53328: CALL_OW 72
53332: PUSH
53333: FOR_IN
53334: IFFALSE 53397
// if not HasTask ( j ) then
53336: LD_VAR 0 3
53340: PPUSH
53341: CALL_OW 314
53345: NOT
53346: IFFALSE 53395
// begin if not IsInUnit ( j ) then
53348: LD_VAR 0 3
53352: PPUSH
53353: CALL_OW 310
53357: NOT
53358: IFFALSE 53374
// ComEnterUnit ( j , selected ) ;
53360: LD_VAR 0 3
53364: PPUSH
53365: LD_VAR 0 7
53369: PPUSH
53370: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53374: LD_VAR 0 3
53378: PPUSH
53379: LD_INT 16
53381: PPUSH
53382: CALL_OW 183
// AddComExitBuilding ( j ) ;
53386: LD_VAR 0 3
53390: PPUSH
53391: CALL_OW 182
// end ;
53395: GO 53333
53397: POP
53398: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53399: LD_VAR 0 5
53403: PPUSH
53404: LD_INT 11
53406: PPUSH
53407: CALL_OW 325
53411: IFFALSE 53670
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53413: LD_ADDR_VAR 0 4
53417: PUSH
53418: LD_EXP 128
53422: PUSH
53423: LD_VAR 0 2
53427: ARRAY
53428: PPUSH
53429: LD_INT 25
53431: PUSH
53432: LD_INT 16
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: PPUSH
53439: CALL_OW 72
53443: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53444: LD_VAR 0 4
53448: PUSH
53449: LD_INT 6
53451: GREATEREQUAL
53452: PUSH
53453: LD_VAR 0 5
53457: PPUSH
53458: LD_INT 2
53460: PPUSH
53461: CALL_OW 325
53465: NOT
53466: OR
53467: IFFALSE 53670
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53469: LD_ADDR_VAR 0 8
53473: PUSH
53474: LD_EXP 99
53478: PUSH
53479: LD_VAR 0 2
53483: ARRAY
53484: PPUSH
53485: LD_INT 2
53487: PUSH
53488: LD_INT 30
53490: PUSH
53491: LD_INT 4
53493: PUSH
53494: EMPTY
53495: LIST
53496: LIST
53497: PUSH
53498: LD_INT 30
53500: PUSH
53501: LD_INT 5
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: PUSH
53508: EMPTY
53509: LIST
53510: LIST
53511: LIST
53512: PPUSH
53513: CALL_OW 72
53517: ST_TO_ADDR
// if barracks then
53518: LD_VAR 0 8
53522: IFFALSE 53670
// begin selected := 0 ;
53524: LD_ADDR_VAR 0 7
53528: PUSH
53529: LD_INT 0
53531: ST_TO_ADDR
// for j in barracks do
53532: LD_ADDR_VAR 0 3
53536: PUSH
53537: LD_VAR 0 8
53541: PUSH
53542: FOR_IN
53543: IFFALSE 53574
// begin if UnitsInside ( j ) < 6 then
53545: LD_VAR 0 3
53549: PPUSH
53550: CALL_OW 313
53554: PUSH
53555: LD_INT 6
53557: LESS
53558: IFFALSE 53572
// begin selected := j ;
53560: LD_ADDR_VAR 0 7
53564: PUSH
53565: LD_VAR 0 3
53569: ST_TO_ADDR
// break ;
53570: GO 53574
// end ; end ;
53572: GO 53542
53574: POP
53575: POP
// if selected then
53576: LD_VAR 0 7
53580: IFFALSE 53670
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53582: LD_ADDR_VAR 0 3
53586: PUSH
53587: LD_EXP 128
53591: PUSH
53592: LD_VAR 0 2
53596: ARRAY
53597: PPUSH
53598: LD_INT 25
53600: PUSH
53601: LD_INT 12
53603: PUSH
53604: EMPTY
53605: LIST
53606: LIST
53607: PPUSH
53608: CALL_OW 72
53612: PUSH
53613: FOR_IN
53614: IFFALSE 53668
// if not IsInUnit ( j ) and not HasTask ( j ) then
53616: LD_VAR 0 3
53620: PPUSH
53621: CALL_OW 310
53625: NOT
53626: PUSH
53627: LD_VAR 0 3
53631: PPUSH
53632: CALL_OW 314
53636: NOT
53637: AND
53638: IFFALSE 53666
// begin ComEnterUnit ( j , selected ) ;
53640: LD_VAR 0 3
53644: PPUSH
53645: LD_VAR 0 7
53649: PPUSH
53650: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53654: LD_VAR 0 3
53658: PPUSH
53659: LD_INT 15
53661: PPUSH
53662: CALL_OW 183
// end ;
53666: GO 53613
53668: POP
53669: POP
// end ; end ; end ; end ; end ;
53670: GO 53063
53672: POP
53673: POP
// end ;
53674: LD_VAR 0 1
53678: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53679: LD_INT 0
53681: PPUSH
53682: PPUSH
53683: PPUSH
53684: PPUSH
// if not mc_bases then
53685: LD_EXP 99
53689: NOT
53690: IFFALSE 53694
// exit ;
53692: GO 53872
// for i = 1 to mc_bases do
53694: LD_ADDR_VAR 0 2
53698: PUSH
53699: DOUBLE
53700: LD_INT 1
53702: DEC
53703: ST_TO_ADDR
53704: LD_EXP 99
53708: PUSH
53709: FOR_TO
53710: IFFALSE 53870
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53712: LD_ADDR_VAR 0 4
53716: PUSH
53717: LD_EXP 99
53721: PUSH
53722: LD_VAR 0 2
53726: ARRAY
53727: PPUSH
53728: LD_INT 25
53730: PUSH
53731: LD_INT 9
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: PPUSH
53738: CALL_OW 72
53742: ST_TO_ADDR
// if not tmp then
53743: LD_VAR 0 4
53747: NOT
53748: IFFALSE 53752
// continue ;
53750: GO 53709
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53752: LD_EXP 125
53756: PUSH
53757: LD_VAR 0 2
53761: ARRAY
53762: PPUSH
53763: LD_INT 29
53765: PPUSH
53766: CALL_OW 325
53770: NOT
53771: PUSH
53772: LD_EXP 125
53776: PUSH
53777: LD_VAR 0 2
53781: ARRAY
53782: PPUSH
53783: LD_INT 28
53785: PPUSH
53786: CALL_OW 325
53790: NOT
53791: AND
53792: IFFALSE 53796
// continue ;
53794: GO 53709
// for j in tmp do
53796: LD_ADDR_VAR 0 3
53800: PUSH
53801: LD_VAR 0 4
53805: PUSH
53806: FOR_IN
53807: IFFALSE 53866
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53809: LD_VAR 0 3
53813: PUSH
53814: LD_EXP 102
53818: PUSH
53819: LD_VAR 0 2
53823: ARRAY
53824: PUSH
53825: LD_INT 1
53827: ARRAY
53828: IN
53829: NOT
53830: PUSH
53831: LD_VAR 0 3
53835: PUSH
53836: LD_EXP 102
53840: PUSH
53841: LD_VAR 0 2
53845: ARRAY
53846: PUSH
53847: LD_INT 2
53849: ARRAY
53850: IN
53851: NOT
53852: AND
53853: IFFALSE 53864
// ComSpaceTimeShoot ( j ) ;
53855: LD_VAR 0 3
53859: PPUSH
53860: CALL 64890 0 1
53864: GO 53806
53866: POP
53867: POP
// end ;
53868: GO 53709
53870: POP
53871: POP
// end ;
53872: LD_VAR 0 1
53876: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53877: LD_INT 0
53879: PPUSH
53880: PPUSH
53881: PPUSH
53882: PPUSH
53883: PPUSH
53884: PPUSH
53885: PPUSH
53886: PPUSH
53887: PPUSH
// if not mc_bases then
53888: LD_EXP 99
53892: NOT
53893: IFFALSE 53897
// exit ;
53895: GO 54519
// for i = 1 to mc_bases do
53897: LD_ADDR_VAR 0 2
53901: PUSH
53902: DOUBLE
53903: LD_INT 1
53905: DEC
53906: ST_TO_ADDR
53907: LD_EXP 99
53911: PUSH
53912: FOR_TO
53913: IFFALSE 54517
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53915: LD_EXP 134
53919: PUSH
53920: LD_VAR 0 2
53924: ARRAY
53925: NOT
53926: PUSH
53927: LD_INT 38
53929: PPUSH
53930: LD_EXP 125
53934: PUSH
53935: LD_VAR 0 2
53939: ARRAY
53940: PPUSH
53941: CALL_OW 321
53945: PUSH
53946: LD_INT 2
53948: NONEQUAL
53949: OR
53950: IFFALSE 53954
// continue ;
53952: GO 53912
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53954: LD_ADDR_VAR 0 8
53958: PUSH
53959: LD_EXP 99
53963: PUSH
53964: LD_VAR 0 2
53968: ARRAY
53969: PPUSH
53970: LD_INT 30
53972: PUSH
53973: LD_INT 34
53975: PUSH
53976: EMPTY
53977: LIST
53978: LIST
53979: PPUSH
53980: CALL_OW 72
53984: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53985: LD_ADDR_VAR 0 9
53989: PUSH
53990: LD_EXP 99
53994: PUSH
53995: LD_VAR 0 2
53999: ARRAY
54000: PPUSH
54001: LD_INT 25
54003: PUSH
54004: LD_INT 4
54006: PUSH
54007: EMPTY
54008: LIST
54009: LIST
54010: PPUSH
54011: CALL_OW 72
54015: PPUSH
54016: LD_INT 0
54018: PPUSH
54019: CALL 104564 0 2
54023: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54024: LD_VAR 0 9
54028: NOT
54029: PUSH
54030: LD_VAR 0 8
54034: NOT
54035: OR
54036: PUSH
54037: LD_EXP 99
54041: PUSH
54042: LD_VAR 0 2
54046: ARRAY
54047: PPUSH
54048: LD_INT 124
54050: PPUSH
54051: CALL 104564 0 2
54055: OR
54056: IFFALSE 54060
// continue ;
54058: GO 53912
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54060: LD_EXP 135
54064: PUSH
54065: LD_VAR 0 2
54069: ARRAY
54070: PUSH
54071: LD_EXP 134
54075: PUSH
54076: LD_VAR 0 2
54080: ARRAY
54081: LESS
54082: PUSH
54083: LD_EXP 135
54087: PUSH
54088: LD_VAR 0 2
54092: ARRAY
54093: PUSH
54094: LD_VAR 0 8
54098: LESS
54099: AND
54100: IFFALSE 54515
// begin tmp := sci [ 1 ] ;
54102: LD_ADDR_VAR 0 7
54106: PUSH
54107: LD_VAR 0 9
54111: PUSH
54112: LD_INT 1
54114: ARRAY
54115: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54116: LD_VAR 0 7
54120: PPUSH
54121: LD_INT 124
54123: PPUSH
54124: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54128: LD_ADDR_VAR 0 3
54132: PUSH
54133: DOUBLE
54134: LD_EXP 134
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: INC
54145: ST_TO_ADDR
54146: LD_EXP 134
54150: PUSH
54151: LD_VAR 0 2
54155: ARRAY
54156: PUSH
54157: FOR_DOWNTO
54158: IFFALSE 54501
// begin if IsInUnit ( tmp ) then
54160: LD_VAR 0 7
54164: PPUSH
54165: CALL_OW 310
54169: IFFALSE 54180
// ComExitBuilding ( tmp ) ;
54171: LD_VAR 0 7
54175: PPUSH
54176: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54180: LD_INT 35
54182: PPUSH
54183: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54187: LD_VAR 0 7
54191: PPUSH
54192: CALL_OW 310
54196: NOT
54197: PUSH
54198: LD_VAR 0 7
54202: PPUSH
54203: CALL_OW 314
54207: NOT
54208: AND
54209: IFFALSE 54180
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54211: LD_ADDR_VAR 0 6
54215: PUSH
54216: LD_VAR 0 7
54220: PPUSH
54221: CALL_OW 250
54225: PUSH
54226: LD_VAR 0 7
54230: PPUSH
54231: CALL_OW 251
54235: PUSH
54236: EMPTY
54237: LIST
54238: LIST
54239: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54240: LD_INT 35
54242: PPUSH
54243: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54247: LD_ADDR_VAR 0 4
54251: PUSH
54252: LD_EXP 134
54256: PUSH
54257: LD_VAR 0 2
54261: ARRAY
54262: PUSH
54263: LD_VAR 0 3
54267: ARRAY
54268: PUSH
54269: LD_INT 1
54271: ARRAY
54272: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54273: LD_ADDR_VAR 0 5
54277: PUSH
54278: LD_EXP 134
54282: PUSH
54283: LD_VAR 0 2
54287: ARRAY
54288: PUSH
54289: LD_VAR 0 3
54293: ARRAY
54294: PUSH
54295: LD_INT 2
54297: ARRAY
54298: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54299: LD_VAR 0 7
54303: PPUSH
54304: LD_INT 10
54306: PPUSH
54307: CALL 73897 0 2
54311: PUSH
54312: LD_INT 4
54314: ARRAY
54315: IFFALSE 54353
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54317: LD_VAR 0 7
54321: PPUSH
54322: LD_VAR 0 6
54326: PUSH
54327: LD_INT 1
54329: ARRAY
54330: PPUSH
54331: LD_VAR 0 6
54335: PUSH
54336: LD_INT 2
54338: ARRAY
54339: PPUSH
54340: CALL_OW 111
// wait ( 0 0$10 ) ;
54344: LD_INT 350
54346: PPUSH
54347: CALL_OW 67
// end else
54351: GO 54379
// begin ComMoveXY ( tmp , x , y ) ;
54353: LD_VAR 0 7
54357: PPUSH
54358: LD_VAR 0 4
54362: PPUSH
54363: LD_VAR 0 5
54367: PPUSH
54368: CALL_OW 111
// wait ( 0 0$3 ) ;
54372: LD_INT 105
54374: PPUSH
54375: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54379: LD_VAR 0 7
54383: PPUSH
54384: LD_VAR 0 4
54388: PPUSH
54389: LD_VAR 0 5
54393: PPUSH
54394: CALL_OW 307
54398: IFFALSE 54240
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54400: LD_VAR 0 7
54404: PPUSH
54405: LD_VAR 0 4
54409: PPUSH
54410: LD_VAR 0 5
54414: PPUSH
54415: LD_VAR 0 8
54419: PUSH
54420: LD_VAR 0 3
54424: ARRAY
54425: PPUSH
54426: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54430: LD_INT 35
54432: PPUSH
54433: CALL_OW 67
// until not HasTask ( tmp ) ;
54437: LD_VAR 0 7
54441: PPUSH
54442: CALL_OW 314
54446: NOT
54447: IFFALSE 54430
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54449: LD_ADDR_EXP 135
54453: PUSH
54454: LD_EXP 135
54458: PPUSH
54459: LD_VAR 0 2
54463: PUSH
54464: LD_EXP 135
54468: PUSH
54469: LD_VAR 0 2
54473: ARRAY
54474: PUSH
54475: LD_INT 1
54477: PLUS
54478: PUSH
54479: EMPTY
54480: LIST
54481: LIST
54482: PPUSH
54483: LD_VAR 0 8
54487: PUSH
54488: LD_VAR 0 3
54492: ARRAY
54493: PPUSH
54494: CALL 71304 0 3
54498: ST_TO_ADDR
// end ;
54499: GO 54157
54501: POP
54502: POP
// MC_Reset ( i , 124 ) ;
54503: LD_VAR 0 2
54507: PPUSH
54508: LD_INT 124
54510: PPUSH
54511: CALL 38002 0 2
// end ; end ;
54515: GO 53912
54517: POP
54518: POP
// end ;
54519: LD_VAR 0 1
54523: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54524: LD_INT 0
54526: PPUSH
54527: PPUSH
54528: PPUSH
// if not mc_bases then
54529: LD_EXP 99
54533: NOT
54534: IFFALSE 54538
// exit ;
54536: GO 55144
// for i = 1 to mc_bases do
54538: LD_ADDR_VAR 0 2
54542: PUSH
54543: DOUBLE
54544: LD_INT 1
54546: DEC
54547: ST_TO_ADDR
54548: LD_EXP 99
54552: PUSH
54553: FOR_TO
54554: IFFALSE 55142
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54556: LD_ADDR_VAR 0 3
54560: PUSH
54561: LD_EXP 99
54565: PUSH
54566: LD_VAR 0 2
54570: ARRAY
54571: PPUSH
54572: LD_INT 25
54574: PUSH
54575: LD_INT 4
54577: PUSH
54578: EMPTY
54579: LIST
54580: LIST
54581: PPUSH
54582: CALL_OW 72
54586: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54587: LD_VAR 0 3
54591: NOT
54592: PUSH
54593: LD_EXP 136
54597: PUSH
54598: LD_VAR 0 2
54602: ARRAY
54603: NOT
54604: OR
54605: PUSH
54606: LD_EXP 99
54610: PUSH
54611: LD_VAR 0 2
54615: ARRAY
54616: PPUSH
54617: LD_INT 2
54619: PUSH
54620: LD_INT 30
54622: PUSH
54623: LD_INT 0
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: PUSH
54630: LD_INT 30
54632: PUSH
54633: LD_INT 1
54635: PUSH
54636: EMPTY
54637: LIST
54638: LIST
54639: PUSH
54640: EMPTY
54641: LIST
54642: LIST
54643: LIST
54644: PPUSH
54645: CALL_OW 72
54649: NOT
54650: OR
54651: IFFALSE 54701
// begin if mc_deposits_finder [ i ] then
54653: LD_EXP 137
54657: PUSH
54658: LD_VAR 0 2
54662: ARRAY
54663: IFFALSE 54699
// begin MC_Reset ( i , 125 ) ;
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_INT 125
54672: PPUSH
54673: CALL 38002 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54677: LD_ADDR_EXP 137
54681: PUSH
54682: LD_EXP 137
54686: PPUSH
54687: LD_VAR 0 2
54691: PPUSH
54692: EMPTY
54693: PPUSH
54694: CALL_OW 1
54698: ST_TO_ADDR
// end ; continue ;
54699: GO 54553
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54701: LD_EXP 136
54705: PUSH
54706: LD_VAR 0 2
54710: ARRAY
54711: PUSH
54712: LD_INT 1
54714: ARRAY
54715: PUSH
54716: LD_INT 3
54718: ARRAY
54719: PUSH
54720: LD_INT 1
54722: EQUAL
54723: PUSH
54724: LD_INT 20
54726: PPUSH
54727: LD_EXP 125
54731: PUSH
54732: LD_VAR 0 2
54736: ARRAY
54737: PPUSH
54738: CALL_OW 321
54742: PUSH
54743: LD_INT 2
54745: NONEQUAL
54746: AND
54747: IFFALSE 54797
// begin if mc_deposits_finder [ i ] then
54749: LD_EXP 137
54753: PUSH
54754: LD_VAR 0 2
54758: ARRAY
54759: IFFALSE 54795
// begin MC_Reset ( i , 125 ) ;
54761: LD_VAR 0 2
54765: PPUSH
54766: LD_INT 125
54768: PPUSH
54769: CALL 38002 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54773: LD_ADDR_EXP 137
54777: PUSH
54778: LD_EXP 137
54782: PPUSH
54783: LD_VAR 0 2
54787: PPUSH
54788: EMPTY
54789: PPUSH
54790: CALL_OW 1
54794: ST_TO_ADDR
// end ; continue ;
54795: GO 54553
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54797: LD_EXP 136
54801: PUSH
54802: LD_VAR 0 2
54806: ARRAY
54807: PUSH
54808: LD_INT 1
54810: ARRAY
54811: PUSH
54812: LD_INT 1
54814: ARRAY
54815: PPUSH
54816: LD_EXP 136
54820: PUSH
54821: LD_VAR 0 2
54825: ARRAY
54826: PUSH
54827: LD_INT 1
54829: ARRAY
54830: PUSH
54831: LD_INT 2
54833: ARRAY
54834: PPUSH
54835: LD_EXP 125
54839: PUSH
54840: LD_VAR 0 2
54844: ARRAY
54845: PPUSH
54846: CALL_OW 440
54850: IFFALSE 54893
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54852: LD_ADDR_EXP 136
54856: PUSH
54857: LD_EXP 136
54861: PPUSH
54862: LD_VAR 0 2
54866: PPUSH
54867: LD_EXP 136
54871: PUSH
54872: LD_VAR 0 2
54876: ARRAY
54877: PPUSH
54878: LD_INT 1
54880: PPUSH
54881: CALL_OW 3
54885: PPUSH
54886: CALL_OW 1
54890: ST_TO_ADDR
54891: GO 55140
// begin if not mc_deposits_finder [ i ] then
54893: LD_EXP 137
54897: PUSH
54898: LD_VAR 0 2
54902: ARRAY
54903: NOT
54904: IFFALSE 54956
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54906: LD_ADDR_EXP 137
54910: PUSH
54911: LD_EXP 137
54915: PPUSH
54916: LD_VAR 0 2
54920: PPUSH
54921: LD_VAR 0 3
54925: PUSH
54926: LD_INT 1
54928: ARRAY
54929: PUSH
54930: EMPTY
54931: LIST
54932: PPUSH
54933: CALL_OW 1
54937: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54938: LD_VAR 0 3
54942: PUSH
54943: LD_INT 1
54945: ARRAY
54946: PPUSH
54947: LD_INT 125
54949: PPUSH
54950: CALL_OW 109
// end else
54954: GO 55140
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54956: LD_EXP 137
54960: PUSH
54961: LD_VAR 0 2
54965: ARRAY
54966: PUSH
54967: LD_INT 1
54969: ARRAY
54970: PPUSH
54971: CALL_OW 310
54975: IFFALSE 54998
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54977: LD_EXP 137
54981: PUSH
54982: LD_VAR 0 2
54986: ARRAY
54987: PUSH
54988: LD_INT 1
54990: ARRAY
54991: PPUSH
54992: CALL_OW 122
54996: GO 55140
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54998: LD_EXP 137
55002: PUSH
55003: LD_VAR 0 2
55007: ARRAY
55008: PUSH
55009: LD_INT 1
55011: ARRAY
55012: PPUSH
55013: CALL_OW 314
55017: NOT
55018: PUSH
55019: LD_EXP 137
55023: PUSH
55024: LD_VAR 0 2
55028: ARRAY
55029: PUSH
55030: LD_INT 1
55032: ARRAY
55033: PPUSH
55034: LD_EXP 136
55038: PUSH
55039: LD_VAR 0 2
55043: ARRAY
55044: PUSH
55045: LD_INT 1
55047: ARRAY
55048: PUSH
55049: LD_INT 1
55051: ARRAY
55052: PPUSH
55053: LD_EXP 136
55057: PUSH
55058: LD_VAR 0 2
55062: ARRAY
55063: PUSH
55064: LD_INT 1
55066: ARRAY
55067: PUSH
55068: LD_INT 2
55070: ARRAY
55071: PPUSH
55072: CALL_OW 297
55076: PUSH
55077: LD_INT 6
55079: GREATER
55080: AND
55081: IFFALSE 55140
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55083: LD_EXP 137
55087: PUSH
55088: LD_VAR 0 2
55092: ARRAY
55093: PUSH
55094: LD_INT 1
55096: ARRAY
55097: PPUSH
55098: LD_EXP 136
55102: PUSH
55103: LD_VAR 0 2
55107: ARRAY
55108: PUSH
55109: LD_INT 1
55111: ARRAY
55112: PUSH
55113: LD_INT 1
55115: ARRAY
55116: PPUSH
55117: LD_EXP 136
55121: PUSH
55122: LD_VAR 0 2
55126: ARRAY
55127: PUSH
55128: LD_INT 1
55130: ARRAY
55131: PUSH
55132: LD_INT 2
55134: ARRAY
55135: PPUSH
55136: CALL_OW 111
// end ; end ; end ;
55140: GO 54553
55142: POP
55143: POP
// end ;
55144: LD_VAR 0 1
55148: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55149: LD_INT 0
55151: PPUSH
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
55156: PPUSH
55157: PPUSH
55158: PPUSH
55159: PPUSH
55160: PPUSH
55161: PPUSH
// if not mc_bases then
55162: LD_EXP 99
55166: NOT
55167: IFFALSE 55171
// exit ;
55169: GO 56111
// for i = 1 to mc_bases do
55171: LD_ADDR_VAR 0 2
55175: PUSH
55176: DOUBLE
55177: LD_INT 1
55179: DEC
55180: ST_TO_ADDR
55181: LD_EXP 99
55185: PUSH
55186: FOR_TO
55187: IFFALSE 56109
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55189: LD_EXP 99
55193: PUSH
55194: LD_VAR 0 2
55198: ARRAY
55199: NOT
55200: PUSH
55201: LD_EXP 122
55205: PUSH
55206: LD_VAR 0 2
55210: ARRAY
55211: OR
55212: IFFALSE 55216
// continue ;
55214: GO 55186
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55216: LD_ADDR_VAR 0 7
55220: PUSH
55221: LD_EXP 99
55225: PUSH
55226: LD_VAR 0 2
55230: ARRAY
55231: PUSH
55232: LD_INT 1
55234: ARRAY
55235: PPUSH
55236: CALL_OW 248
55240: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55241: LD_VAR 0 7
55245: PUSH
55246: LD_INT 3
55248: EQUAL
55249: PUSH
55250: LD_EXP 118
55254: PUSH
55255: LD_VAR 0 2
55259: ARRAY
55260: PUSH
55261: LD_EXP 121
55265: PUSH
55266: LD_VAR 0 2
55270: ARRAY
55271: UNION
55272: PPUSH
55273: LD_INT 33
55275: PUSH
55276: LD_INT 2
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: PPUSH
55283: CALL_OW 72
55287: NOT
55288: OR
55289: IFFALSE 55293
// continue ;
55291: GO 55186
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55293: LD_ADDR_VAR 0 9
55297: PUSH
55298: LD_EXP 99
55302: PUSH
55303: LD_VAR 0 2
55307: ARRAY
55308: PPUSH
55309: LD_INT 30
55311: PUSH
55312: LD_INT 36
55314: PUSH
55315: EMPTY
55316: LIST
55317: LIST
55318: PPUSH
55319: CALL_OW 72
55323: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55324: LD_ADDR_VAR 0 10
55328: PUSH
55329: LD_EXP 118
55333: PUSH
55334: LD_VAR 0 2
55338: ARRAY
55339: PPUSH
55340: LD_INT 34
55342: PUSH
55343: LD_INT 31
55345: PUSH
55346: EMPTY
55347: LIST
55348: LIST
55349: PPUSH
55350: CALL_OW 72
55354: ST_TO_ADDR
// if not cts and not mcts then
55355: LD_VAR 0 9
55359: NOT
55360: PUSH
55361: LD_VAR 0 10
55365: NOT
55366: AND
55367: IFFALSE 55371
// continue ;
55369: GO 55186
// x := cts ;
55371: LD_ADDR_VAR 0 11
55375: PUSH
55376: LD_VAR 0 9
55380: ST_TO_ADDR
// if not x then
55381: LD_VAR 0 11
55385: NOT
55386: IFFALSE 55398
// x := mcts ;
55388: LD_ADDR_VAR 0 11
55392: PUSH
55393: LD_VAR 0 10
55397: ST_TO_ADDR
// if not x then
55398: LD_VAR 0 11
55402: NOT
55403: IFFALSE 55407
// continue ;
55405: GO 55186
// if mc_remote_driver [ i ] then
55407: LD_EXP 139
55411: PUSH
55412: LD_VAR 0 2
55416: ARRAY
55417: IFFALSE 55804
// for j in mc_remote_driver [ i ] do
55419: LD_ADDR_VAR 0 3
55423: PUSH
55424: LD_EXP 139
55428: PUSH
55429: LD_VAR 0 2
55433: ARRAY
55434: PUSH
55435: FOR_IN
55436: IFFALSE 55802
// begin if GetClass ( j ) <> 3 then
55438: LD_VAR 0 3
55442: PPUSH
55443: CALL_OW 257
55447: PUSH
55448: LD_INT 3
55450: NONEQUAL
55451: IFFALSE 55504
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55453: LD_ADDR_EXP 139
55457: PUSH
55458: LD_EXP 139
55462: PPUSH
55463: LD_VAR 0 2
55467: PPUSH
55468: LD_EXP 139
55472: PUSH
55473: LD_VAR 0 2
55477: ARRAY
55478: PUSH
55479: LD_VAR 0 3
55483: DIFF
55484: PPUSH
55485: CALL_OW 1
55489: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55490: LD_VAR 0 3
55494: PPUSH
55495: LD_INT 0
55497: PPUSH
55498: CALL_OW 109
// continue ;
55502: GO 55435
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55504: LD_EXP 118
55508: PUSH
55509: LD_VAR 0 2
55513: ARRAY
55514: PPUSH
55515: LD_INT 34
55517: PUSH
55518: LD_INT 31
55520: PUSH
55521: EMPTY
55522: LIST
55523: LIST
55524: PUSH
55525: LD_INT 58
55527: PUSH
55528: EMPTY
55529: LIST
55530: PUSH
55531: EMPTY
55532: LIST
55533: LIST
55534: PPUSH
55535: CALL_OW 72
55539: PUSH
55540: LD_VAR 0 3
55544: PPUSH
55545: CALL 104652 0 1
55549: NOT
55550: AND
55551: IFFALSE 55622
// begin if IsInUnit ( j ) then
55553: LD_VAR 0 3
55557: PPUSH
55558: CALL_OW 310
55562: IFFALSE 55573
// ComExitBuilding ( j ) ;
55564: LD_VAR 0 3
55568: PPUSH
55569: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55573: LD_VAR 0 3
55577: PPUSH
55578: LD_EXP 118
55582: PUSH
55583: LD_VAR 0 2
55587: ARRAY
55588: PPUSH
55589: LD_INT 34
55591: PUSH
55592: LD_INT 31
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 58
55601: PUSH
55602: EMPTY
55603: LIST
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PPUSH
55609: CALL_OW 72
55613: PUSH
55614: LD_INT 1
55616: ARRAY
55617: PPUSH
55618: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55622: LD_VAR 0 3
55626: PPUSH
55627: CALL_OW 310
55631: NOT
55632: PUSH
55633: LD_VAR 0 3
55637: PPUSH
55638: CALL_OW 310
55642: PPUSH
55643: CALL_OW 266
55647: PUSH
55648: LD_INT 36
55650: NONEQUAL
55651: PUSH
55652: LD_VAR 0 3
55656: PPUSH
55657: CALL 104652 0 1
55661: NOT
55662: AND
55663: OR
55664: IFFALSE 55800
// begin if IsInUnit ( j ) then
55666: LD_VAR 0 3
55670: PPUSH
55671: CALL_OW 310
55675: IFFALSE 55686
// ComExitBuilding ( j ) ;
55677: LD_VAR 0 3
55681: PPUSH
55682: CALL_OW 122
// ct := 0 ;
55686: LD_ADDR_VAR 0 8
55690: PUSH
55691: LD_INT 0
55693: ST_TO_ADDR
// for k in x do
55694: LD_ADDR_VAR 0 4
55698: PUSH
55699: LD_VAR 0 11
55703: PUSH
55704: FOR_IN
55705: IFFALSE 55778
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55707: LD_VAR 0 4
55711: PPUSH
55712: CALL_OW 264
55716: PUSH
55717: LD_INT 31
55719: EQUAL
55720: PUSH
55721: LD_VAR 0 4
55725: PPUSH
55726: CALL_OW 311
55730: NOT
55731: AND
55732: PUSH
55733: LD_VAR 0 4
55737: PPUSH
55738: CALL_OW 266
55742: PUSH
55743: LD_INT 36
55745: EQUAL
55746: PUSH
55747: LD_VAR 0 4
55751: PPUSH
55752: CALL_OW 313
55756: PUSH
55757: LD_INT 3
55759: LESS
55760: AND
55761: OR
55762: IFFALSE 55776
// begin ct := k ;
55764: LD_ADDR_VAR 0 8
55768: PUSH
55769: LD_VAR 0 4
55773: ST_TO_ADDR
// break ;
55774: GO 55778
// end ;
55776: GO 55704
55778: POP
55779: POP
// if ct then
55780: LD_VAR 0 8
55784: IFFALSE 55800
// ComEnterUnit ( j , ct ) ;
55786: LD_VAR 0 3
55790: PPUSH
55791: LD_VAR 0 8
55795: PPUSH
55796: CALL_OW 120
// end ; end ;
55800: GO 55435
55802: POP
55803: POP
// places := 0 ;
55804: LD_ADDR_VAR 0 5
55808: PUSH
55809: LD_INT 0
55811: ST_TO_ADDR
// for j = 1 to x do
55812: LD_ADDR_VAR 0 3
55816: PUSH
55817: DOUBLE
55818: LD_INT 1
55820: DEC
55821: ST_TO_ADDR
55822: LD_VAR 0 11
55826: PUSH
55827: FOR_TO
55828: IFFALSE 55904
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55830: LD_VAR 0 11
55834: PUSH
55835: LD_VAR 0 3
55839: ARRAY
55840: PPUSH
55841: CALL_OW 264
55845: PUSH
55846: LD_INT 31
55848: EQUAL
55849: IFFALSE 55867
// places := places + 1 else
55851: LD_ADDR_VAR 0 5
55855: PUSH
55856: LD_VAR 0 5
55860: PUSH
55861: LD_INT 1
55863: PLUS
55864: ST_TO_ADDR
55865: GO 55902
// if GetBType ( x [ j ] ) = b_control_tower then
55867: LD_VAR 0 11
55871: PUSH
55872: LD_VAR 0 3
55876: ARRAY
55877: PPUSH
55878: CALL_OW 266
55882: PUSH
55883: LD_INT 36
55885: EQUAL
55886: IFFALSE 55902
// places := places + 3 ;
55888: LD_ADDR_VAR 0 5
55892: PUSH
55893: LD_VAR 0 5
55897: PUSH
55898: LD_INT 3
55900: PLUS
55901: ST_TO_ADDR
55902: GO 55827
55904: POP
55905: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
55906: LD_VAR 0 5
55910: PUSH
55911: LD_INT 0
55913: EQUAL
55914: PUSH
55915: LD_VAR 0 5
55919: PUSH
55920: LD_EXP 139
55924: PUSH
55925: LD_VAR 0 2
55929: ARRAY
55930: LESSEQUAL
55931: OR
55932: IFFALSE 55936
// continue ;
55934: GO 55186
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55936: LD_ADDR_VAR 0 6
55940: PUSH
55941: LD_EXP 99
55945: PUSH
55946: LD_VAR 0 2
55950: ARRAY
55951: PPUSH
55952: LD_INT 25
55954: PUSH
55955: LD_INT 3
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: PPUSH
55962: CALL_OW 72
55966: PUSH
55967: LD_EXP 139
55971: PUSH
55972: LD_VAR 0 2
55976: ARRAY
55977: DIFF
55978: PPUSH
55979: LD_INT 3
55981: PPUSH
55982: CALL 105552 0 2
55986: ST_TO_ADDR
// for j in tmp do
55987: LD_ADDR_VAR 0 3
55991: PUSH
55992: LD_VAR 0 6
55996: PUSH
55997: FOR_IN
55998: IFFALSE 56033
// if GetTag ( j ) > 0 then
56000: LD_VAR 0 3
56004: PPUSH
56005: CALL_OW 110
56009: PUSH
56010: LD_INT 0
56012: GREATER
56013: IFFALSE 56031
// tmp := tmp diff j ;
56015: LD_ADDR_VAR 0 6
56019: PUSH
56020: LD_VAR 0 6
56024: PUSH
56025: LD_VAR 0 3
56029: DIFF
56030: ST_TO_ADDR
56031: GO 55997
56033: POP
56034: POP
// if not tmp then
56035: LD_VAR 0 6
56039: NOT
56040: IFFALSE 56044
// continue ;
56042: GO 55186
// if places then
56044: LD_VAR 0 5
56048: IFFALSE 56107
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56050: LD_ADDR_EXP 139
56054: PUSH
56055: LD_EXP 139
56059: PPUSH
56060: LD_VAR 0 2
56064: PPUSH
56065: LD_EXP 139
56069: PUSH
56070: LD_VAR 0 2
56074: ARRAY
56075: PUSH
56076: LD_VAR 0 6
56080: PUSH
56081: LD_INT 1
56083: ARRAY
56084: UNION
56085: PPUSH
56086: CALL_OW 1
56090: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56091: LD_VAR 0 6
56095: PUSH
56096: LD_INT 1
56098: ARRAY
56099: PPUSH
56100: LD_INT 126
56102: PPUSH
56103: CALL_OW 109
// end ; end ;
56107: GO 55186
56109: POP
56110: POP
// end ;
56111: LD_VAR 0 1
56115: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56116: LD_INT 0
56118: PPUSH
56119: PPUSH
56120: PPUSH
56121: PPUSH
56122: PPUSH
56123: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56124: LD_VAR 0 1
56128: NOT
56129: PUSH
56130: LD_VAR 0 2
56134: NOT
56135: OR
56136: PUSH
56137: LD_VAR 0 3
56141: NOT
56142: OR
56143: PUSH
56144: LD_VAR 0 4
56148: PUSH
56149: LD_INT 1
56151: PUSH
56152: LD_INT 2
56154: PUSH
56155: LD_INT 3
56157: PUSH
56158: LD_INT 4
56160: PUSH
56161: LD_INT 5
56163: PUSH
56164: LD_INT 8
56166: PUSH
56167: LD_INT 9
56169: PUSH
56170: LD_INT 15
56172: PUSH
56173: LD_INT 16
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: LIST
56180: LIST
56181: LIST
56182: LIST
56183: LIST
56184: LIST
56185: LIST
56186: IN
56187: NOT
56188: OR
56189: IFFALSE 56193
// exit ;
56191: GO 57093
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56193: LD_ADDR_VAR 0 2
56197: PUSH
56198: LD_VAR 0 2
56202: PPUSH
56203: LD_INT 21
56205: PUSH
56206: LD_INT 3
56208: PUSH
56209: EMPTY
56210: LIST
56211: LIST
56212: PUSH
56213: LD_INT 24
56215: PUSH
56216: LD_INT 250
56218: PUSH
56219: EMPTY
56220: LIST
56221: LIST
56222: PUSH
56223: EMPTY
56224: LIST
56225: LIST
56226: PPUSH
56227: CALL_OW 72
56231: ST_TO_ADDR
// case class of 1 , 15 :
56232: LD_VAR 0 4
56236: PUSH
56237: LD_INT 1
56239: DOUBLE
56240: EQUAL
56241: IFTRUE 56251
56243: LD_INT 15
56245: DOUBLE
56246: EQUAL
56247: IFTRUE 56251
56249: GO 56336
56251: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56252: LD_ADDR_VAR 0 8
56256: PUSH
56257: LD_VAR 0 2
56261: PPUSH
56262: LD_INT 2
56264: PUSH
56265: LD_INT 30
56267: PUSH
56268: LD_INT 32
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: PUSH
56275: LD_INT 30
56277: PUSH
56278: LD_INT 31
56280: PUSH
56281: EMPTY
56282: LIST
56283: LIST
56284: PUSH
56285: EMPTY
56286: LIST
56287: LIST
56288: LIST
56289: PPUSH
56290: CALL_OW 72
56294: PUSH
56295: LD_VAR 0 2
56299: PPUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 30
56305: PUSH
56306: LD_INT 4
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 30
56315: PUSH
56316: LD_INT 5
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: LIST
56327: PPUSH
56328: CALL_OW 72
56332: ADD
56333: ST_TO_ADDR
56334: GO 56582
56336: LD_INT 2
56338: DOUBLE
56339: EQUAL
56340: IFTRUE 56350
56342: LD_INT 16
56344: DOUBLE
56345: EQUAL
56346: IFTRUE 56350
56348: GO 56396
56350: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56351: LD_ADDR_VAR 0 8
56355: PUSH
56356: LD_VAR 0 2
56360: PPUSH
56361: LD_INT 2
56363: PUSH
56364: LD_INT 30
56366: PUSH
56367: LD_INT 0
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: PUSH
56374: LD_INT 30
56376: PUSH
56377: LD_INT 1
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: LIST
56388: PPUSH
56389: CALL_OW 72
56393: ST_TO_ADDR
56394: GO 56582
56396: LD_INT 3
56398: DOUBLE
56399: EQUAL
56400: IFTRUE 56404
56402: GO 56450
56404: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56405: LD_ADDR_VAR 0 8
56409: PUSH
56410: LD_VAR 0 2
56414: PPUSH
56415: LD_INT 2
56417: PUSH
56418: LD_INT 30
56420: PUSH
56421: LD_INT 2
56423: PUSH
56424: EMPTY
56425: LIST
56426: LIST
56427: PUSH
56428: LD_INT 30
56430: PUSH
56431: LD_INT 3
56433: PUSH
56434: EMPTY
56435: LIST
56436: LIST
56437: PUSH
56438: EMPTY
56439: LIST
56440: LIST
56441: LIST
56442: PPUSH
56443: CALL_OW 72
56447: ST_TO_ADDR
56448: GO 56582
56450: LD_INT 4
56452: DOUBLE
56453: EQUAL
56454: IFTRUE 56458
56456: GO 56515
56458: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56459: LD_ADDR_VAR 0 8
56463: PUSH
56464: LD_VAR 0 2
56468: PPUSH
56469: LD_INT 2
56471: PUSH
56472: LD_INT 30
56474: PUSH
56475: LD_INT 6
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: LD_INT 30
56484: PUSH
56485: LD_INT 7
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: PUSH
56492: LD_INT 30
56494: PUSH
56495: LD_INT 8
56497: PUSH
56498: EMPTY
56499: LIST
56500: LIST
56501: PUSH
56502: EMPTY
56503: LIST
56504: LIST
56505: LIST
56506: LIST
56507: PPUSH
56508: CALL_OW 72
56512: ST_TO_ADDR
56513: GO 56582
56515: LD_INT 5
56517: DOUBLE
56518: EQUAL
56519: IFTRUE 56535
56521: LD_INT 8
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56535
56527: LD_INT 9
56529: DOUBLE
56530: EQUAL
56531: IFTRUE 56535
56533: GO 56581
56535: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56536: LD_ADDR_VAR 0 8
56540: PUSH
56541: LD_VAR 0 2
56545: PPUSH
56546: LD_INT 2
56548: PUSH
56549: LD_INT 30
56551: PUSH
56552: LD_INT 4
56554: PUSH
56555: EMPTY
56556: LIST
56557: LIST
56558: PUSH
56559: LD_INT 30
56561: PUSH
56562: LD_INT 5
56564: PUSH
56565: EMPTY
56566: LIST
56567: LIST
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: LIST
56573: PPUSH
56574: CALL_OW 72
56578: ST_TO_ADDR
56579: GO 56582
56581: POP
// if not tmp then
56582: LD_VAR 0 8
56586: NOT
56587: IFFALSE 56591
// exit ;
56589: GO 57093
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56591: LD_VAR 0 4
56595: PUSH
56596: LD_INT 1
56598: PUSH
56599: LD_INT 15
56601: PUSH
56602: EMPTY
56603: LIST
56604: LIST
56605: IN
56606: PUSH
56607: LD_EXP 108
56611: PUSH
56612: LD_VAR 0 1
56616: ARRAY
56617: AND
56618: IFFALSE 56774
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56620: LD_ADDR_VAR 0 9
56624: PUSH
56625: LD_EXP 108
56629: PUSH
56630: LD_VAR 0 1
56634: ARRAY
56635: PUSH
56636: LD_INT 1
56638: ARRAY
56639: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56640: LD_VAR 0 9
56644: PUSH
56645: LD_EXP 109
56649: PUSH
56650: LD_VAR 0 1
56654: ARRAY
56655: IN
56656: NOT
56657: IFFALSE 56772
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56659: LD_ADDR_EXP 109
56663: PUSH
56664: LD_EXP 109
56668: PPUSH
56669: LD_VAR 0 1
56673: PUSH
56674: LD_EXP 109
56678: PUSH
56679: LD_VAR 0 1
56683: ARRAY
56684: PUSH
56685: LD_INT 1
56687: PLUS
56688: PUSH
56689: EMPTY
56690: LIST
56691: LIST
56692: PPUSH
56693: LD_VAR 0 9
56697: PPUSH
56698: CALL 71304 0 3
56702: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56703: LD_ADDR_EXP 108
56707: PUSH
56708: LD_EXP 108
56712: PPUSH
56713: LD_VAR 0 1
56717: PPUSH
56718: LD_EXP 108
56722: PUSH
56723: LD_VAR 0 1
56727: ARRAY
56728: PUSH
56729: LD_VAR 0 9
56733: DIFF
56734: PPUSH
56735: CALL_OW 1
56739: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56740: LD_VAR 0 3
56744: PPUSH
56745: LD_EXP 109
56749: PUSH
56750: LD_VAR 0 1
56754: ARRAY
56755: PUSH
56756: LD_EXP 109
56760: PUSH
56761: LD_VAR 0 1
56765: ARRAY
56766: ARRAY
56767: PPUSH
56768: CALL_OW 120
// end ; exit ;
56772: GO 57093
// end ; if tmp > 1 then
56774: LD_VAR 0 8
56778: PUSH
56779: LD_INT 1
56781: GREATER
56782: IFFALSE 56886
// for i = 2 to tmp do
56784: LD_ADDR_VAR 0 6
56788: PUSH
56789: DOUBLE
56790: LD_INT 2
56792: DEC
56793: ST_TO_ADDR
56794: LD_VAR 0 8
56798: PUSH
56799: FOR_TO
56800: IFFALSE 56884
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56802: LD_VAR 0 8
56806: PUSH
56807: LD_VAR 0 6
56811: ARRAY
56812: PPUSH
56813: CALL_OW 461
56817: PUSH
56818: LD_INT 6
56820: EQUAL
56821: IFFALSE 56882
// begin x := tmp [ i ] ;
56823: LD_ADDR_VAR 0 9
56827: PUSH
56828: LD_VAR 0 8
56832: PUSH
56833: LD_VAR 0 6
56837: ARRAY
56838: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56839: LD_ADDR_VAR 0 8
56843: PUSH
56844: LD_VAR 0 8
56848: PPUSH
56849: LD_VAR 0 6
56853: PPUSH
56854: CALL_OW 3
56858: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56859: LD_ADDR_VAR 0 8
56863: PUSH
56864: LD_VAR 0 8
56868: PPUSH
56869: LD_INT 1
56871: PPUSH
56872: LD_VAR 0 9
56876: PPUSH
56877: CALL_OW 2
56881: ST_TO_ADDR
// end ;
56882: GO 56799
56884: POP
56885: POP
// for i in tmp do
56886: LD_ADDR_VAR 0 6
56890: PUSH
56891: LD_VAR 0 8
56895: PUSH
56896: FOR_IN
56897: IFFALSE 56966
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56899: LD_VAR 0 6
56903: PPUSH
56904: CALL_OW 313
56908: PUSH
56909: LD_INT 6
56911: LESS
56912: PUSH
56913: LD_VAR 0 6
56917: PPUSH
56918: CALL_OW 266
56922: PUSH
56923: LD_INT 31
56925: PUSH
56926: LD_INT 32
56928: PUSH
56929: EMPTY
56930: LIST
56931: LIST
56932: IN
56933: NOT
56934: AND
56935: PUSH
56936: LD_VAR 0 6
56940: PPUSH
56941: CALL_OW 313
56945: PUSH
56946: LD_INT 0
56948: EQUAL
56949: OR
56950: IFFALSE 56964
// begin j := i ;
56952: LD_ADDR_VAR 0 7
56956: PUSH
56957: LD_VAR 0 6
56961: ST_TO_ADDR
// break ;
56962: GO 56966
// end ; end ;
56964: GO 56896
56966: POP
56967: POP
// if j then
56968: LD_VAR 0 7
56972: IFFALSE 56990
// ComEnterUnit ( unit , j ) else
56974: LD_VAR 0 3
56978: PPUSH
56979: LD_VAR 0 7
56983: PPUSH
56984: CALL_OW 120
56988: GO 57093
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56990: LD_ADDR_VAR 0 10
56994: PUSH
56995: LD_VAR 0 2
56999: PPUSH
57000: LD_INT 2
57002: PUSH
57003: LD_INT 30
57005: PUSH
57006: LD_INT 0
57008: PUSH
57009: EMPTY
57010: LIST
57011: LIST
57012: PUSH
57013: LD_INT 30
57015: PUSH
57016: LD_INT 1
57018: PUSH
57019: EMPTY
57020: LIST
57021: LIST
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: LIST
57027: PPUSH
57028: CALL_OW 72
57032: ST_TO_ADDR
// if depot then
57033: LD_VAR 0 10
57037: IFFALSE 57093
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57039: LD_ADDR_VAR 0 10
57043: PUSH
57044: LD_VAR 0 10
57048: PPUSH
57049: LD_VAR 0 3
57053: PPUSH
57054: CALL_OW 74
57058: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57059: LD_VAR 0 3
57063: PPUSH
57064: LD_VAR 0 10
57068: PPUSH
57069: CALL_OW 296
57073: PUSH
57074: LD_INT 10
57076: GREATER
57077: IFFALSE 57093
// ComStandNearbyBuilding ( unit , depot ) ;
57079: LD_VAR 0 3
57083: PPUSH
57084: LD_VAR 0 10
57088: PPUSH
57089: CALL 65507 0 2
// end ; end ; end ;
57093: LD_VAR 0 5
57097: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57098: LD_INT 0
57100: PPUSH
57101: PPUSH
57102: PPUSH
57103: PPUSH
// if not mc_bases then
57104: LD_EXP 99
57108: NOT
57109: IFFALSE 57113
// exit ;
57111: GO 57352
// for i = 1 to mc_bases do
57113: LD_ADDR_VAR 0 2
57117: PUSH
57118: DOUBLE
57119: LD_INT 1
57121: DEC
57122: ST_TO_ADDR
57123: LD_EXP 99
57127: PUSH
57128: FOR_TO
57129: IFFALSE 57350
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57131: LD_ADDR_VAR 0 4
57135: PUSH
57136: LD_EXP 99
57140: PUSH
57141: LD_VAR 0 2
57145: ARRAY
57146: PPUSH
57147: LD_INT 21
57149: PUSH
57150: LD_INT 1
57152: PUSH
57153: EMPTY
57154: LIST
57155: LIST
57156: PPUSH
57157: CALL_OW 72
57161: PUSH
57162: LD_EXP 128
57166: PUSH
57167: LD_VAR 0 2
57171: ARRAY
57172: UNION
57173: ST_TO_ADDR
// if not tmp then
57174: LD_VAR 0 4
57178: NOT
57179: IFFALSE 57183
// continue ;
57181: GO 57128
// for j in tmp do
57183: LD_ADDR_VAR 0 3
57187: PUSH
57188: LD_VAR 0 4
57192: PUSH
57193: FOR_IN
57194: IFFALSE 57346
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57196: LD_VAR 0 3
57200: PPUSH
57201: CALL_OW 110
57205: NOT
57206: PUSH
57207: LD_VAR 0 3
57211: PPUSH
57212: CALL_OW 314
57216: NOT
57217: AND
57218: PUSH
57219: LD_VAR 0 3
57223: PPUSH
57224: CALL_OW 311
57228: NOT
57229: AND
57230: PUSH
57231: LD_VAR 0 3
57235: PPUSH
57236: CALL_OW 310
57240: NOT
57241: AND
57242: PUSH
57243: LD_VAR 0 3
57247: PUSH
57248: LD_EXP 102
57252: PUSH
57253: LD_VAR 0 2
57257: ARRAY
57258: PUSH
57259: LD_INT 1
57261: ARRAY
57262: IN
57263: NOT
57264: AND
57265: PUSH
57266: LD_VAR 0 3
57270: PUSH
57271: LD_EXP 102
57275: PUSH
57276: LD_VAR 0 2
57280: ARRAY
57281: PUSH
57282: LD_INT 2
57284: ARRAY
57285: IN
57286: NOT
57287: AND
57288: PUSH
57289: LD_VAR 0 3
57293: PUSH
57294: LD_EXP 111
57298: PUSH
57299: LD_VAR 0 2
57303: ARRAY
57304: IN
57305: NOT
57306: AND
57307: IFFALSE 57344
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57309: LD_VAR 0 2
57313: PPUSH
57314: LD_EXP 99
57318: PUSH
57319: LD_VAR 0 2
57323: ARRAY
57324: PPUSH
57325: LD_VAR 0 3
57329: PPUSH
57330: LD_VAR 0 3
57334: PPUSH
57335: CALL_OW 257
57339: PPUSH
57340: CALL 56116 0 4
// end ;
57344: GO 57193
57346: POP
57347: POP
// end ;
57348: GO 57128
57350: POP
57351: POP
// end ;
57352: LD_VAR 0 1
57356: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57357: LD_INT 0
57359: PPUSH
57360: PPUSH
57361: PPUSH
57362: PPUSH
57363: PPUSH
57364: PPUSH
// if not mc_bases [ base ] then
57365: LD_EXP 99
57369: PUSH
57370: LD_VAR 0 1
57374: ARRAY
57375: NOT
57376: IFFALSE 57380
// exit ;
57378: GO 57562
// tmp := [ ] ;
57380: LD_ADDR_VAR 0 6
57384: PUSH
57385: EMPTY
57386: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57387: LD_ADDR_VAR 0 7
57391: PUSH
57392: LD_VAR 0 3
57396: PPUSH
57397: LD_INT 0
57399: PPUSH
57400: CALL_OW 517
57404: ST_TO_ADDR
// if not list then
57405: LD_VAR 0 7
57409: NOT
57410: IFFALSE 57414
// exit ;
57412: GO 57562
// for i = 1 to amount do
57414: LD_ADDR_VAR 0 5
57418: PUSH
57419: DOUBLE
57420: LD_INT 1
57422: DEC
57423: ST_TO_ADDR
57424: LD_VAR 0 2
57428: PUSH
57429: FOR_TO
57430: IFFALSE 57510
// begin x := rand ( 1 , list [ 1 ] ) ;
57432: LD_ADDR_VAR 0 8
57436: PUSH
57437: LD_INT 1
57439: PPUSH
57440: LD_VAR 0 7
57444: PUSH
57445: LD_INT 1
57447: ARRAY
57448: PPUSH
57449: CALL_OW 12
57453: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57454: LD_ADDR_VAR 0 6
57458: PUSH
57459: LD_VAR 0 6
57463: PPUSH
57464: LD_VAR 0 5
57468: PPUSH
57469: LD_VAR 0 7
57473: PUSH
57474: LD_INT 1
57476: ARRAY
57477: PUSH
57478: LD_VAR 0 8
57482: ARRAY
57483: PUSH
57484: LD_VAR 0 7
57488: PUSH
57489: LD_INT 2
57491: ARRAY
57492: PUSH
57493: LD_VAR 0 8
57497: ARRAY
57498: PUSH
57499: EMPTY
57500: LIST
57501: LIST
57502: PPUSH
57503: CALL_OW 1
57507: ST_TO_ADDR
// end ;
57508: GO 57429
57510: POP
57511: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57512: LD_ADDR_EXP 112
57516: PUSH
57517: LD_EXP 112
57521: PPUSH
57522: LD_VAR 0 1
57526: PPUSH
57527: LD_VAR 0 6
57531: PPUSH
57532: CALL_OW 1
57536: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57537: LD_ADDR_EXP 114
57541: PUSH
57542: LD_EXP 114
57546: PPUSH
57547: LD_VAR 0 1
57551: PPUSH
57552: LD_VAR 0 3
57556: PPUSH
57557: CALL_OW 1
57561: ST_TO_ADDR
// end ;
57562: LD_VAR 0 4
57566: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57567: LD_INT 0
57569: PPUSH
// if not mc_bases [ base ] then
57570: LD_EXP 99
57574: PUSH
57575: LD_VAR 0 1
57579: ARRAY
57580: NOT
57581: IFFALSE 57585
// exit ;
57583: GO 57610
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57585: LD_ADDR_EXP 104
57589: PUSH
57590: LD_EXP 104
57594: PPUSH
57595: LD_VAR 0 1
57599: PPUSH
57600: LD_VAR 0 2
57604: PPUSH
57605: CALL_OW 1
57609: ST_TO_ADDR
// end ;
57610: LD_VAR 0 3
57614: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57615: LD_INT 0
57617: PPUSH
// if not mc_bases [ base ] then
57618: LD_EXP 99
57622: PUSH
57623: LD_VAR 0 1
57627: ARRAY
57628: NOT
57629: IFFALSE 57633
// exit ;
57631: GO 57670
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57633: LD_ADDR_EXP 104
57637: PUSH
57638: LD_EXP 104
57642: PPUSH
57643: LD_VAR 0 1
57647: PPUSH
57648: LD_EXP 104
57652: PUSH
57653: LD_VAR 0 1
57657: ARRAY
57658: PUSH
57659: LD_VAR 0 2
57663: UNION
57664: PPUSH
57665: CALL_OW 1
57669: ST_TO_ADDR
// end ;
57670: LD_VAR 0 3
57674: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57675: LD_INT 0
57677: PPUSH
// if not mc_bases [ base ] then
57678: LD_EXP 99
57682: PUSH
57683: LD_VAR 0 1
57687: ARRAY
57688: NOT
57689: IFFALSE 57693
// exit ;
57691: GO 57718
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57693: LD_ADDR_EXP 120
57697: PUSH
57698: LD_EXP 120
57702: PPUSH
57703: LD_VAR 0 1
57707: PPUSH
57708: LD_VAR 0 2
57712: PPUSH
57713: CALL_OW 1
57717: ST_TO_ADDR
// end ;
57718: LD_VAR 0 3
57722: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57723: LD_INT 0
57725: PPUSH
// if not mc_bases [ base ] then
57726: LD_EXP 99
57730: PUSH
57731: LD_VAR 0 1
57735: ARRAY
57736: NOT
57737: IFFALSE 57741
// exit ;
57739: GO 57778
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57741: LD_ADDR_EXP 120
57745: PUSH
57746: LD_EXP 120
57750: PPUSH
57751: LD_VAR 0 1
57755: PPUSH
57756: LD_EXP 120
57760: PUSH
57761: LD_VAR 0 1
57765: ARRAY
57766: PUSH
57767: LD_VAR 0 2
57771: ADD
57772: PPUSH
57773: CALL_OW 1
57777: ST_TO_ADDR
// end ;
57778: LD_VAR 0 3
57782: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57783: LD_INT 0
57785: PPUSH
// if not mc_bases [ base ] then
57786: LD_EXP 99
57790: PUSH
57791: LD_VAR 0 1
57795: ARRAY
57796: NOT
57797: IFFALSE 57801
// exit ;
57799: GO 57855
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57801: LD_ADDR_EXP 121
57805: PUSH
57806: LD_EXP 121
57810: PPUSH
57811: LD_VAR 0 1
57815: PPUSH
57816: LD_VAR 0 2
57820: PPUSH
57821: CALL_OW 1
57825: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57826: LD_ADDR_EXP 110
57830: PUSH
57831: LD_EXP 110
57835: PPUSH
57836: LD_VAR 0 1
57840: PPUSH
57841: LD_VAR 0 2
57845: PUSH
57846: LD_INT 0
57848: PLUS
57849: PPUSH
57850: CALL_OW 1
57854: ST_TO_ADDR
// end ;
57855: LD_VAR 0 3
57859: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57860: LD_INT 0
57862: PPUSH
// if not mc_bases [ base ] then
57863: LD_EXP 99
57867: PUSH
57868: LD_VAR 0 1
57872: ARRAY
57873: NOT
57874: IFFALSE 57878
// exit ;
57876: GO 57903
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57878: LD_ADDR_EXP 110
57882: PUSH
57883: LD_EXP 110
57887: PPUSH
57888: LD_VAR 0 1
57892: PPUSH
57893: LD_VAR 0 2
57897: PPUSH
57898: CALL_OW 1
57902: ST_TO_ADDR
// end ;
57903: LD_VAR 0 3
57907: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57908: LD_INT 0
57910: PPUSH
57911: PPUSH
57912: PPUSH
57913: PPUSH
// if not mc_bases [ base ] then
57914: LD_EXP 99
57918: PUSH
57919: LD_VAR 0 1
57923: ARRAY
57924: NOT
57925: IFFALSE 57929
// exit ;
57927: GO 57994
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57929: LD_ADDR_EXP 119
57933: PUSH
57934: LD_EXP 119
57938: PPUSH
57939: LD_VAR 0 1
57943: PUSH
57944: LD_EXP 119
57948: PUSH
57949: LD_VAR 0 1
57953: ARRAY
57954: PUSH
57955: LD_INT 1
57957: PLUS
57958: PUSH
57959: EMPTY
57960: LIST
57961: LIST
57962: PPUSH
57963: LD_VAR 0 1
57967: PUSH
57968: LD_VAR 0 2
57972: PUSH
57973: LD_VAR 0 3
57977: PUSH
57978: LD_VAR 0 4
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: LIST
57987: LIST
57988: PPUSH
57989: CALL 71304 0 3
57993: ST_TO_ADDR
// end ;
57994: LD_VAR 0 5
57998: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57999: LD_INT 0
58001: PPUSH
// if not mc_bases [ base ] then
58002: LD_EXP 99
58006: PUSH
58007: LD_VAR 0 1
58011: ARRAY
58012: NOT
58013: IFFALSE 58017
// exit ;
58015: GO 58042
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58017: LD_ADDR_EXP 136
58021: PUSH
58022: LD_EXP 136
58026: PPUSH
58027: LD_VAR 0 1
58031: PPUSH
58032: LD_VAR 0 2
58036: PPUSH
58037: CALL_OW 1
58041: ST_TO_ADDR
// end ;
58042: LD_VAR 0 3
58046: RET
// export function MC_GetMinesField ( base ) ; begin
58047: LD_INT 0
58049: PPUSH
// result := mc_mines [ base ] ;
58050: LD_ADDR_VAR 0 2
58054: PUSH
58055: LD_EXP 112
58059: PUSH
58060: LD_VAR 0 1
58064: ARRAY
58065: ST_TO_ADDR
// end ;
58066: LD_VAR 0 2
58070: RET
// export function MC_GetProduceList ( base ) ; begin
58071: LD_INT 0
58073: PPUSH
// result := mc_produce [ base ] ;
58074: LD_ADDR_VAR 0 2
58078: PUSH
58079: LD_EXP 120
58083: PUSH
58084: LD_VAR 0 1
58088: ARRAY
58089: ST_TO_ADDR
// end ;
58090: LD_VAR 0 2
58094: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58095: LD_INT 0
58097: PPUSH
58098: PPUSH
// if not mc_bases then
58099: LD_EXP 99
58103: NOT
58104: IFFALSE 58108
// exit ;
58106: GO 58173
// if mc_bases [ base ] then
58108: LD_EXP 99
58112: PUSH
58113: LD_VAR 0 1
58117: ARRAY
58118: IFFALSE 58173
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58120: LD_ADDR_VAR 0 3
58124: PUSH
58125: LD_EXP 99
58129: PUSH
58130: LD_VAR 0 1
58134: ARRAY
58135: PPUSH
58136: LD_INT 30
58138: PUSH
58139: LD_VAR 0 2
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PPUSH
58148: CALL_OW 72
58152: ST_TO_ADDR
// if result then
58153: LD_VAR 0 3
58157: IFFALSE 58173
// result := result [ 1 ] ;
58159: LD_ADDR_VAR 0 3
58163: PUSH
58164: LD_VAR 0 3
58168: PUSH
58169: LD_INT 1
58171: ARRAY
58172: ST_TO_ADDR
// end ; end ;
58173: LD_VAR 0 3
58177: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58178: LD_INT 0
58180: PPUSH
58181: PPUSH
// if not mc_bases then
58182: LD_EXP 99
58186: NOT
58187: IFFALSE 58191
// exit ;
58189: GO 58236
// if mc_bases [ base ] then
58191: LD_EXP 99
58195: PUSH
58196: LD_VAR 0 1
58200: ARRAY
58201: IFFALSE 58236
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58203: LD_ADDR_VAR 0 3
58207: PUSH
58208: LD_EXP 99
58212: PUSH
58213: LD_VAR 0 1
58217: ARRAY
58218: PPUSH
58219: LD_INT 30
58221: PUSH
58222: LD_VAR 0 2
58226: PUSH
58227: EMPTY
58228: LIST
58229: LIST
58230: PPUSH
58231: CALL_OW 72
58235: ST_TO_ADDR
// end ;
58236: LD_VAR 0 3
58240: RET
// export function MC_SetTame ( base , area ) ; begin
58241: LD_INT 0
58243: PPUSH
// if not mc_bases or not base then
58244: LD_EXP 99
58248: NOT
58249: PUSH
58250: LD_VAR 0 1
58254: NOT
58255: OR
58256: IFFALSE 58260
// exit ;
58258: GO 58285
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58260: LD_ADDR_EXP 127
58264: PUSH
58265: LD_EXP 127
58269: PPUSH
58270: LD_VAR 0 1
58274: PPUSH
58275: LD_VAR 0 2
58279: PPUSH
58280: CALL_OW 1
58284: ST_TO_ADDR
// end ;
58285: LD_VAR 0 3
58289: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58290: LD_INT 0
58292: PPUSH
58293: PPUSH
// if not mc_bases or not base then
58294: LD_EXP 99
58298: NOT
58299: PUSH
58300: LD_VAR 0 1
58304: NOT
58305: OR
58306: IFFALSE 58310
// exit ;
58308: GO 58412
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58310: LD_ADDR_VAR 0 4
58314: PUSH
58315: LD_EXP 99
58319: PUSH
58320: LD_VAR 0 1
58324: ARRAY
58325: PPUSH
58326: LD_INT 30
58328: PUSH
58329: LD_VAR 0 2
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: PPUSH
58338: CALL_OW 72
58342: ST_TO_ADDR
// if not tmp then
58343: LD_VAR 0 4
58347: NOT
58348: IFFALSE 58352
// exit ;
58350: GO 58412
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58352: LD_ADDR_EXP 131
58356: PUSH
58357: LD_EXP 131
58361: PPUSH
58362: LD_VAR 0 1
58366: PPUSH
58367: LD_EXP 131
58371: PUSH
58372: LD_VAR 0 1
58376: ARRAY
58377: PPUSH
58378: LD_EXP 131
58382: PUSH
58383: LD_VAR 0 1
58387: ARRAY
58388: PUSH
58389: LD_INT 1
58391: PLUS
58392: PPUSH
58393: LD_VAR 0 4
58397: PUSH
58398: LD_INT 1
58400: ARRAY
58401: PPUSH
58402: CALL_OW 2
58406: PPUSH
58407: CALL_OW 1
58411: ST_TO_ADDR
// end ;
58412: LD_VAR 0 3
58416: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58417: LD_INT 0
58419: PPUSH
58420: PPUSH
// if not mc_bases or not base or not kinds then
58421: LD_EXP 99
58425: NOT
58426: PUSH
58427: LD_VAR 0 1
58431: NOT
58432: OR
58433: PUSH
58434: LD_VAR 0 2
58438: NOT
58439: OR
58440: IFFALSE 58444
// exit ;
58442: GO 58505
// for i in kinds do
58444: LD_ADDR_VAR 0 4
58448: PUSH
58449: LD_VAR 0 2
58453: PUSH
58454: FOR_IN
58455: IFFALSE 58503
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58457: LD_ADDR_EXP 133
58461: PUSH
58462: LD_EXP 133
58466: PPUSH
58467: LD_VAR 0 1
58471: PUSH
58472: LD_EXP 133
58476: PUSH
58477: LD_VAR 0 1
58481: ARRAY
58482: PUSH
58483: LD_INT 1
58485: PLUS
58486: PUSH
58487: EMPTY
58488: LIST
58489: LIST
58490: PPUSH
58491: LD_VAR 0 4
58495: PPUSH
58496: CALL 71304 0 3
58500: ST_TO_ADDR
58501: GO 58454
58503: POP
58504: POP
// end ;
58505: LD_VAR 0 3
58509: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58510: LD_INT 0
58512: PPUSH
// if not mc_bases or not base or not areas then
58513: LD_EXP 99
58517: NOT
58518: PUSH
58519: LD_VAR 0 1
58523: NOT
58524: OR
58525: PUSH
58526: LD_VAR 0 2
58530: NOT
58531: OR
58532: IFFALSE 58536
// exit ;
58534: GO 58561
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58536: LD_ADDR_EXP 117
58540: PUSH
58541: LD_EXP 117
58545: PPUSH
58546: LD_VAR 0 1
58550: PPUSH
58551: LD_VAR 0 2
58555: PPUSH
58556: CALL_OW 1
58560: ST_TO_ADDR
// end ;
58561: LD_VAR 0 3
58565: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58566: LD_INT 0
58568: PPUSH
// if not mc_bases or not base or not teleports_exit then
58569: LD_EXP 99
58573: NOT
58574: PUSH
58575: LD_VAR 0 1
58579: NOT
58580: OR
58581: PUSH
58582: LD_VAR 0 2
58586: NOT
58587: OR
58588: IFFALSE 58592
// exit ;
58590: GO 58617
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58592: LD_ADDR_EXP 134
58596: PUSH
58597: LD_EXP 134
58601: PPUSH
58602: LD_VAR 0 1
58606: PPUSH
58607: LD_VAR 0 2
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
// end ;
58617: LD_VAR 0 3
58621: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58622: LD_INT 0
58624: PPUSH
58625: PPUSH
58626: PPUSH
// if not mc_bases or not base or not ext_list then
58627: LD_EXP 99
58631: NOT
58632: PUSH
58633: LD_VAR 0 1
58637: NOT
58638: OR
58639: PUSH
58640: LD_VAR 0 5
58644: NOT
58645: OR
58646: IFFALSE 58650
// exit ;
58648: GO 58823
// tmp := GetFacExtXYD ( x , y , d ) ;
58650: LD_ADDR_VAR 0 8
58654: PUSH
58655: LD_VAR 0 2
58659: PPUSH
58660: LD_VAR 0 3
58664: PPUSH
58665: LD_VAR 0 4
58669: PPUSH
58670: CALL 104682 0 3
58674: ST_TO_ADDR
// if not tmp then
58675: LD_VAR 0 8
58679: NOT
58680: IFFALSE 58684
// exit ;
58682: GO 58823
// for i in tmp do
58684: LD_ADDR_VAR 0 7
58688: PUSH
58689: LD_VAR 0 8
58693: PUSH
58694: FOR_IN
58695: IFFALSE 58821
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58697: LD_ADDR_EXP 104
58701: PUSH
58702: LD_EXP 104
58706: PPUSH
58707: LD_VAR 0 1
58711: PPUSH
58712: LD_EXP 104
58716: PUSH
58717: LD_VAR 0 1
58721: ARRAY
58722: PPUSH
58723: LD_EXP 104
58727: PUSH
58728: LD_VAR 0 1
58732: ARRAY
58733: PUSH
58734: LD_INT 1
58736: PLUS
58737: PPUSH
58738: LD_VAR 0 5
58742: PUSH
58743: LD_INT 1
58745: ARRAY
58746: PUSH
58747: LD_VAR 0 7
58751: PUSH
58752: LD_INT 1
58754: ARRAY
58755: PUSH
58756: LD_VAR 0 7
58760: PUSH
58761: LD_INT 2
58763: ARRAY
58764: PUSH
58765: LD_VAR 0 7
58769: PUSH
58770: LD_INT 3
58772: ARRAY
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: LIST
58778: LIST
58779: PPUSH
58780: CALL_OW 2
58784: PPUSH
58785: CALL_OW 1
58789: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58790: LD_ADDR_VAR 0 5
58794: PUSH
58795: LD_VAR 0 5
58799: PPUSH
58800: LD_INT 1
58802: PPUSH
58803: CALL_OW 3
58807: ST_TO_ADDR
// if not ext_list then
58808: LD_VAR 0 5
58812: NOT
58813: IFFALSE 58819
// exit ;
58815: POP
58816: POP
58817: GO 58823
// end ;
58819: GO 58694
58821: POP
58822: POP
// end ;
58823: LD_VAR 0 6
58827: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58828: LD_INT 0
58830: PPUSH
// if not mc_bases or not base or not weapon_list then
58831: LD_EXP 99
58835: NOT
58836: PUSH
58837: LD_VAR 0 1
58841: NOT
58842: OR
58843: PUSH
58844: LD_VAR 0 2
58848: NOT
58849: OR
58850: IFFALSE 58854
// exit ;
58852: GO 58879
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58854: LD_ADDR_EXP 138
58858: PUSH
58859: LD_EXP 138
58863: PPUSH
58864: LD_VAR 0 1
58868: PPUSH
58869: LD_VAR 0 2
58873: PPUSH
58874: CALL_OW 1
58878: ST_TO_ADDR
// end ;
58879: LD_VAR 0 3
58883: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58884: LD_INT 0
58886: PPUSH
// if not mc_bases or not base or not tech_list then
58887: LD_EXP 99
58891: NOT
58892: PUSH
58893: LD_VAR 0 1
58897: NOT
58898: OR
58899: PUSH
58900: LD_VAR 0 2
58904: NOT
58905: OR
58906: IFFALSE 58910
// exit ;
58908: GO 58935
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58910: LD_ADDR_EXP 126
58914: PUSH
58915: LD_EXP 126
58919: PPUSH
58920: LD_VAR 0 1
58924: PPUSH
58925: LD_VAR 0 2
58929: PPUSH
58930: CALL_OW 1
58934: ST_TO_ADDR
// end ;
58935: LD_VAR 0 3
58939: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58940: LD_INT 0
58942: PPUSH
// if not mc_bases or not parking_area or not base then
58943: LD_EXP 99
58947: NOT
58948: PUSH
58949: LD_VAR 0 2
58953: NOT
58954: OR
58955: PUSH
58956: LD_VAR 0 1
58960: NOT
58961: OR
58962: IFFALSE 58966
// exit ;
58964: GO 58991
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58966: LD_ADDR_EXP 123
58970: PUSH
58971: LD_EXP 123
58975: PPUSH
58976: LD_VAR 0 1
58980: PPUSH
58981: LD_VAR 0 2
58985: PPUSH
58986: CALL_OW 1
58990: ST_TO_ADDR
// end ;
58991: LD_VAR 0 3
58995: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58996: LD_INT 0
58998: PPUSH
// if not mc_bases or not base or not scan_area then
58999: LD_EXP 99
59003: NOT
59004: PUSH
59005: LD_VAR 0 1
59009: NOT
59010: OR
59011: PUSH
59012: LD_VAR 0 2
59016: NOT
59017: OR
59018: IFFALSE 59022
// exit ;
59020: GO 59047
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59022: LD_ADDR_EXP 124
59026: PUSH
59027: LD_EXP 124
59031: PPUSH
59032: LD_VAR 0 1
59036: PPUSH
59037: LD_VAR 0 2
59041: PPUSH
59042: CALL_OW 1
59046: ST_TO_ADDR
// end ;
59047: LD_VAR 0 3
59051: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59052: LD_INT 0
59054: PPUSH
59055: PPUSH
// if not mc_bases or not base then
59056: LD_EXP 99
59060: NOT
59061: PUSH
59062: LD_VAR 0 1
59066: NOT
59067: OR
59068: IFFALSE 59072
// exit ;
59070: GO 59136
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59072: LD_ADDR_VAR 0 3
59076: PUSH
59077: LD_INT 1
59079: PUSH
59080: LD_INT 2
59082: PUSH
59083: LD_INT 3
59085: PUSH
59086: LD_INT 4
59088: PUSH
59089: LD_INT 11
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: LIST
59097: LIST
59098: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59099: LD_ADDR_EXP 126
59103: PUSH
59104: LD_EXP 126
59108: PPUSH
59109: LD_VAR 0 1
59113: PPUSH
59114: LD_EXP 126
59118: PUSH
59119: LD_VAR 0 1
59123: ARRAY
59124: PUSH
59125: LD_VAR 0 3
59129: DIFF
59130: PPUSH
59131: CALL_OW 1
59135: ST_TO_ADDR
// end ;
59136: LD_VAR 0 2
59140: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59141: LD_INT 0
59143: PPUSH
// result := mc_vehicles [ base ] ;
59144: LD_ADDR_VAR 0 3
59148: PUSH
59149: LD_EXP 118
59153: PUSH
59154: LD_VAR 0 1
59158: ARRAY
59159: ST_TO_ADDR
// if onlyCombat then
59160: LD_VAR 0 2
59164: IFFALSE 59329
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59166: LD_ADDR_VAR 0 3
59170: PUSH
59171: LD_VAR 0 3
59175: PUSH
59176: LD_VAR 0 3
59180: PPUSH
59181: LD_INT 2
59183: PUSH
59184: LD_INT 34
59186: PUSH
59187: LD_INT 12
59189: PUSH
59190: EMPTY
59191: LIST
59192: LIST
59193: PUSH
59194: LD_INT 34
59196: PUSH
59197: LD_INT 51
59199: PUSH
59200: EMPTY
59201: LIST
59202: LIST
59203: PUSH
59204: LD_INT 34
59206: PUSH
59207: LD_EXP 93
59211: PUSH
59212: EMPTY
59213: LIST
59214: LIST
59215: PUSH
59216: LD_INT 34
59218: PUSH
59219: LD_INT 32
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: PUSH
59226: LD_INT 34
59228: PUSH
59229: LD_INT 13
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: PUSH
59236: LD_INT 34
59238: PUSH
59239: LD_INT 52
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PUSH
59246: LD_INT 34
59248: PUSH
59249: LD_INT 14
59251: PUSH
59252: EMPTY
59253: LIST
59254: LIST
59255: PUSH
59256: LD_INT 34
59258: PUSH
59259: LD_INT 53
59261: PUSH
59262: EMPTY
59263: LIST
59264: LIST
59265: PUSH
59266: LD_INT 34
59268: PUSH
59269: LD_EXP 92
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: PUSH
59278: LD_INT 34
59280: PUSH
59281: LD_INT 31
59283: PUSH
59284: EMPTY
59285: LIST
59286: LIST
59287: PUSH
59288: LD_INT 34
59290: PUSH
59291: LD_INT 48
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: PUSH
59298: LD_INT 34
59300: PUSH
59301: LD_INT 8
59303: PUSH
59304: EMPTY
59305: LIST
59306: LIST
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: LIST
59312: LIST
59313: LIST
59314: LIST
59315: LIST
59316: LIST
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: LIST
59322: PPUSH
59323: CALL_OW 72
59327: DIFF
59328: ST_TO_ADDR
// end ; end_of_file
59329: LD_VAR 0 3
59333: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59334: LD_INT 0
59336: PPUSH
59337: PPUSH
59338: PPUSH
// if not mc_bases or not skirmish then
59339: LD_EXP 99
59343: NOT
59344: PUSH
59345: LD_EXP 97
59349: NOT
59350: OR
59351: IFFALSE 59355
// exit ;
59353: GO 59520
// for i = 1 to mc_bases do
59355: LD_ADDR_VAR 0 4
59359: PUSH
59360: DOUBLE
59361: LD_INT 1
59363: DEC
59364: ST_TO_ADDR
59365: LD_EXP 99
59369: PUSH
59370: FOR_TO
59371: IFFALSE 59518
// begin if sci in mc_bases [ i ] then
59373: LD_VAR 0 2
59377: PUSH
59378: LD_EXP 99
59382: PUSH
59383: LD_VAR 0 4
59387: ARRAY
59388: IN
59389: IFFALSE 59516
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59391: LD_ADDR_EXP 128
59395: PUSH
59396: LD_EXP 128
59400: PPUSH
59401: LD_VAR 0 4
59405: PUSH
59406: LD_EXP 128
59410: PUSH
59411: LD_VAR 0 4
59415: ARRAY
59416: PUSH
59417: LD_INT 1
59419: PLUS
59420: PUSH
59421: EMPTY
59422: LIST
59423: LIST
59424: PPUSH
59425: LD_VAR 0 1
59429: PPUSH
59430: CALL 71304 0 3
59434: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59435: LD_ADDR_VAR 0 5
59439: PUSH
59440: LD_EXP 99
59444: PUSH
59445: LD_VAR 0 4
59449: ARRAY
59450: PPUSH
59451: LD_INT 2
59453: PUSH
59454: LD_INT 30
59456: PUSH
59457: LD_INT 0
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: PUSH
59464: LD_INT 30
59466: PUSH
59467: LD_INT 1
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: LIST
59478: PPUSH
59479: CALL_OW 72
59483: PPUSH
59484: LD_VAR 0 1
59488: PPUSH
59489: CALL_OW 74
59493: ST_TO_ADDR
// if tmp then
59494: LD_VAR 0 5
59498: IFFALSE 59514
// ComStandNearbyBuilding ( ape , tmp ) ;
59500: LD_VAR 0 1
59504: PPUSH
59505: LD_VAR 0 5
59509: PPUSH
59510: CALL 65507 0 2
// break ;
59514: GO 59518
// end ; end ;
59516: GO 59370
59518: POP
59519: POP
// end ;
59520: LD_VAR 0 3
59524: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59525: LD_INT 0
59527: PPUSH
59528: PPUSH
59529: PPUSH
// if not mc_bases or not skirmish then
59530: LD_EXP 99
59534: NOT
59535: PUSH
59536: LD_EXP 97
59540: NOT
59541: OR
59542: IFFALSE 59546
// exit ;
59544: GO 59635
// for i = 1 to mc_bases do
59546: LD_ADDR_VAR 0 4
59550: PUSH
59551: DOUBLE
59552: LD_INT 1
59554: DEC
59555: ST_TO_ADDR
59556: LD_EXP 99
59560: PUSH
59561: FOR_TO
59562: IFFALSE 59633
// begin if building in mc_busy_turret_list [ i ] then
59564: LD_VAR 0 1
59568: PUSH
59569: LD_EXP 109
59573: PUSH
59574: LD_VAR 0 4
59578: ARRAY
59579: IN
59580: IFFALSE 59631
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59582: LD_ADDR_VAR 0 5
59586: PUSH
59587: LD_EXP 109
59591: PUSH
59592: LD_VAR 0 4
59596: ARRAY
59597: PUSH
59598: LD_VAR 0 1
59602: DIFF
59603: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59604: LD_ADDR_EXP 109
59608: PUSH
59609: LD_EXP 109
59613: PPUSH
59614: LD_VAR 0 4
59618: PPUSH
59619: LD_VAR 0 5
59623: PPUSH
59624: CALL_OW 1
59628: ST_TO_ADDR
// break ;
59629: GO 59633
// end ; end ;
59631: GO 59561
59633: POP
59634: POP
// end ;
59635: LD_VAR 0 3
59639: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59640: LD_INT 0
59642: PPUSH
59643: PPUSH
59644: PPUSH
// if not mc_bases or not skirmish then
59645: LD_EXP 99
59649: NOT
59650: PUSH
59651: LD_EXP 97
59655: NOT
59656: OR
59657: IFFALSE 59661
// exit ;
59659: GO 59860
// for i = 1 to mc_bases do
59661: LD_ADDR_VAR 0 5
59665: PUSH
59666: DOUBLE
59667: LD_INT 1
59669: DEC
59670: ST_TO_ADDR
59671: LD_EXP 99
59675: PUSH
59676: FOR_TO
59677: IFFALSE 59858
// if building in mc_bases [ i ] then
59679: LD_VAR 0 1
59683: PUSH
59684: LD_EXP 99
59688: PUSH
59689: LD_VAR 0 5
59693: ARRAY
59694: IN
59695: IFFALSE 59856
// begin tmp := mc_bases [ i ] diff building ;
59697: LD_ADDR_VAR 0 6
59701: PUSH
59702: LD_EXP 99
59706: PUSH
59707: LD_VAR 0 5
59711: ARRAY
59712: PUSH
59713: LD_VAR 0 1
59717: DIFF
59718: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59719: LD_ADDR_EXP 99
59723: PUSH
59724: LD_EXP 99
59728: PPUSH
59729: LD_VAR 0 5
59733: PPUSH
59734: LD_VAR 0 6
59738: PPUSH
59739: CALL_OW 1
59743: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59744: LD_VAR 0 1
59748: PUSH
59749: LD_EXP 107
59753: PUSH
59754: LD_VAR 0 5
59758: ARRAY
59759: IN
59760: IFFALSE 59799
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59762: LD_ADDR_EXP 107
59766: PUSH
59767: LD_EXP 107
59771: PPUSH
59772: LD_VAR 0 5
59776: PPUSH
59777: LD_EXP 107
59781: PUSH
59782: LD_VAR 0 5
59786: ARRAY
59787: PUSH
59788: LD_VAR 0 1
59792: DIFF
59793: PPUSH
59794: CALL_OW 1
59798: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59799: LD_VAR 0 1
59803: PUSH
59804: LD_EXP 108
59808: PUSH
59809: LD_VAR 0 5
59813: ARRAY
59814: IN
59815: IFFALSE 59854
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59817: LD_ADDR_EXP 108
59821: PUSH
59822: LD_EXP 108
59826: PPUSH
59827: LD_VAR 0 5
59831: PPUSH
59832: LD_EXP 108
59836: PUSH
59837: LD_VAR 0 5
59841: ARRAY
59842: PUSH
59843: LD_VAR 0 1
59847: DIFF
59848: PPUSH
59849: CALL_OW 1
59853: ST_TO_ADDR
// break ;
59854: GO 59858
// end ;
59856: GO 59676
59858: POP
59859: POP
// end ;
59860: LD_VAR 0 4
59864: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59865: LD_INT 0
59867: PPUSH
59868: PPUSH
59869: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59870: LD_EXP 99
59874: NOT
59875: PUSH
59876: LD_EXP 97
59880: NOT
59881: OR
59882: PUSH
59883: LD_VAR 0 3
59887: PUSH
59888: LD_EXP 125
59892: IN
59893: NOT
59894: OR
59895: IFFALSE 59899
// exit ;
59897: GO 60022
// for i = 1 to mc_vehicles do
59899: LD_ADDR_VAR 0 6
59903: PUSH
59904: DOUBLE
59905: LD_INT 1
59907: DEC
59908: ST_TO_ADDR
59909: LD_EXP 118
59913: PUSH
59914: FOR_TO
59915: IFFALSE 60020
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59917: LD_VAR 0 2
59921: PUSH
59922: LD_EXP 118
59926: PUSH
59927: LD_VAR 0 6
59931: ARRAY
59932: IN
59933: PUSH
59934: LD_VAR 0 1
59938: PUSH
59939: LD_EXP 118
59943: PUSH
59944: LD_VAR 0 6
59948: ARRAY
59949: IN
59950: OR
59951: IFFALSE 60018
// begin tmp := mc_vehicles [ i ] diff old ;
59953: LD_ADDR_VAR 0 7
59957: PUSH
59958: LD_EXP 118
59962: PUSH
59963: LD_VAR 0 6
59967: ARRAY
59968: PUSH
59969: LD_VAR 0 2
59973: DIFF
59974: ST_TO_ADDR
// tmp := tmp diff new ;
59975: LD_ADDR_VAR 0 7
59979: PUSH
59980: LD_VAR 0 7
59984: PUSH
59985: LD_VAR 0 1
59989: DIFF
59990: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59991: LD_ADDR_EXP 118
59995: PUSH
59996: LD_EXP 118
60000: PPUSH
60001: LD_VAR 0 6
60005: PPUSH
60006: LD_VAR 0 7
60010: PPUSH
60011: CALL_OW 1
60015: ST_TO_ADDR
// break ;
60016: GO 60020
// end ;
60018: GO 59914
60020: POP
60021: POP
// end ;
60022: LD_VAR 0 5
60026: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60027: LD_INT 0
60029: PPUSH
60030: PPUSH
60031: PPUSH
60032: PPUSH
// if not mc_bases or not skirmish then
60033: LD_EXP 99
60037: NOT
60038: PUSH
60039: LD_EXP 97
60043: NOT
60044: OR
60045: IFFALSE 60049
// exit ;
60047: GO 60426
// side := GetSide ( vehicle ) ;
60049: LD_ADDR_VAR 0 5
60053: PUSH
60054: LD_VAR 0 1
60058: PPUSH
60059: CALL_OW 255
60063: ST_TO_ADDR
// for i = 1 to mc_bases do
60064: LD_ADDR_VAR 0 4
60068: PUSH
60069: DOUBLE
60070: LD_INT 1
60072: DEC
60073: ST_TO_ADDR
60074: LD_EXP 99
60078: PUSH
60079: FOR_TO
60080: IFFALSE 60424
// begin if factory in mc_bases [ i ] then
60082: LD_VAR 0 2
60086: PUSH
60087: LD_EXP 99
60091: PUSH
60092: LD_VAR 0 4
60096: ARRAY
60097: IN
60098: IFFALSE 60422
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60100: LD_EXP 121
60104: PUSH
60105: LD_VAR 0 4
60109: ARRAY
60110: PUSH
60111: LD_EXP 110
60115: PUSH
60116: LD_VAR 0 4
60120: ARRAY
60121: LESS
60122: PUSH
60123: LD_VAR 0 1
60127: PPUSH
60128: CALL_OW 264
60132: PUSH
60133: LD_INT 31
60135: PUSH
60136: LD_INT 32
60138: PUSH
60139: LD_INT 51
60141: PUSH
60142: LD_EXP 93
60146: PUSH
60147: LD_INT 12
60149: PUSH
60150: LD_INT 30
60152: PUSH
60153: LD_EXP 92
60157: PUSH
60158: LD_INT 11
60160: PUSH
60161: LD_INT 53
60163: PUSH
60164: LD_INT 14
60166: PUSH
60167: LD_EXP 96
60171: PUSH
60172: LD_INT 29
60174: PUSH
60175: LD_EXP 94
60179: PUSH
60180: LD_INT 13
60182: PUSH
60183: LD_INT 52
60185: PUSH
60186: LD_INT 48
60188: PUSH
60189: LD_INT 8
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: LIST
60202: LIST
60203: LIST
60204: LIST
60205: LIST
60206: LIST
60207: LIST
60208: LIST
60209: LIST
60210: IN
60211: NOT
60212: AND
60213: IFFALSE 60261
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60215: LD_ADDR_EXP 121
60219: PUSH
60220: LD_EXP 121
60224: PPUSH
60225: LD_VAR 0 4
60229: PUSH
60230: LD_EXP 121
60234: PUSH
60235: LD_VAR 0 4
60239: ARRAY
60240: PUSH
60241: LD_INT 1
60243: PLUS
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: PPUSH
60249: LD_VAR 0 1
60253: PPUSH
60254: CALL 71304 0 3
60258: ST_TO_ADDR
60259: GO 60305
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60261: LD_ADDR_EXP 118
60265: PUSH
60266: LD_EXP 118
60270: PPUSH
60271: LD_VAR 0 4
60275: PUSH
60276: LD_EXP 118
60280: PUSH
60281: LD_VAR 0 4
60285: ARRAY
60286: PUSH
60287: LD_INT 1
60289: PLUS
60290: PUSH
60291: EMPTY
60292: LIST
60293: LIST
60294: PPUSH
60295: LD_VAR 0 1
60299: PPUSH
60300: CALL 71304 0 3
60304: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60305: LD_VAR 0 1
60309: PPUSH
60310: CALL_OW 263
60314: PUSH
60315: LD_INT 2
60317: EQUAL
60318: IFFALSE 60338
// begin repeat wait ( 0 0$1 ) ;
60320: LD_INT 35
60322: PPUSH
60323: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60327: LD_VAR 0 1
60331: PPUSH
60332: CALL_OW 312
60336: IFFALSE 60320
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60338: LD_VAR 0 1
60342: PPUSH
60343: LD_EXP 123
60347: PUSH
60348: LD_VAR 0 4
60352: ARRAY
60353: PPUSH
60354: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60358: LD_VAR 0 1
60362: PPUSH
60363: CALL_OW 263
60367: PUSH
60368: LD_INT 1
60370: NONEQUAL
60371: IFFALSE 60375
// break ;
60373: GO 60424
// repeat wait ( 0 0$1 ) ;
60375: LD_INT 35
60377: PPUSH
60378: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60382: LD_VAR 0 1
60386: PPUSH
60387: LD_EXP 123
60391: PUSH
60392: LD_VAR 0 4
60396: ARRAY
60397: PPUSH
60398: CALL_OW 308
60402: IFFALSE 60375
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60404: LD_VAR 0 1
60408: PPUSH
60409: CALL_OW 311
60413: PPUSH
60414: CALL_OW 121
// exit ;
60418: POP
60419: POP
60420: GO 60426
// end ; end ;
60422: GO 60079
60424: POP
60425: POP
// end ;
60426: LD_VAR 0 3
60430: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60431: LD_INT 0
60433: PPUSH
60434: PPUSH
60435: PPUSH
60436: PPUSH
// if not mc_bases or not skirmish then
60437: LD_EXP 99
60441: NOT
60442: PUSH
60443: LD_EXP 97
60447: NOT
60448: OR
60449: IFFALSE 60453
// exit ;
60451: GO 60806
// repeat wait ( 0 0$1 ) ;
60453: LD_INT 35
60455: PPUSH
60456: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60460: LD_VAR 0 2
60464: PPUSH
60465: LD_VAR 0 3
60469: PPUSH
60470: CALL_OW 284
60474: IFFALSE 60453
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60476: LD_VAR 0 2
60480: PPUSH
60481: LD_VAR 0 3
60485: PPUSH
60486: CALL_OW 283
60490: PUSH
60491: LD_INT 4
60493: EQUAL
60494: IFFALSE 60498
// exit ;
60496: GO 60806
// for i = 1 to mc_bases do
60498: LD_ADDR_VAR 0 7
60502: PUSH
60503: DOUBLE
60504: LD_INT 1
60506: DEC
60507: ST_TO_ADDR
60508: LD_EXP 99
60512: PUSH
60513: FOR_TO
60514: IFFALSE 60804
// begin if mc_crates_area [ i ] then
60516: LD_EXP 117
60520: PUSH
60521: LD_VAR 0 7
60525: ARRAY
60526: IFFALSE 60637
// for j in mc_crates_area [ i ] do
60528: LD_ADDR_VAR 0 8
60532: PUSH
60533: LD_EXP 117
60537: PUSH
60538: LD_VAR 0 7
60542: ARRAY
60543: PUSH
60544: FOR_IN
60545: IFFALSE 60635
// if InArea ( x , y , j ) then
60547: LD_VAR 0 2
60551: PPUSH
60552: LD_VAR 0 3
60556: PPUSH
60557: LD_VAR 0 8
60561: PPUSH
60562: CALL_OW 309
60566: IFFALSE 60633
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60568: LD_ADDR_EXP 115
60572: PUSH
60573: LD_EXP 115
60577: PPUSH
60578: LD_VAR 0 7
60582: PUSH
60583: LD_EXP 115
60587: PUSH
60588: LD_VAR 0 7
60592: ARRAY
60593: PUSH
60594: LD_INT 1
60596: PLUS
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PPUSH
60602: LD_VAR 0 4
60606: PUSH
60607: LD_VAR 0 2
60611: PUSH
60612: LD_VAR 0 3
60616: PUSH
60617: EMPTY
60618: LIST
60619: LIST
60620: LIST
60621: PPUSH
60622: CALL 71304 0 3
60626: ST_TO_ADDR
// exit ;
60627: POP
60628: POP
60629: POP
60630: POP
60631: GO 60806
// end ;
60633: GO 60544
60635: POP
60636: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60637: LD_ADDR_VAR 0 9
60641: PUSH
60642: LD_EXP 99
60646: PUSH
60647: LD_VAR 0 7
60651: ARRAY
60652: PPUSH
60653: LD_INT 2
60655: PUSH
60656: LD_INT 30
60658: PUSH
60659: LD_INT 0
60661: PUSH
60662: EMPTY
60663: LIST
60664: LIST
60665: PUSH
60666: LD_INT 30
60668: PUSH
60669: LD_INT 1
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: PUSH
60676: EMPTY
60677: LIST
60678: LIST
60679: LIST
60680: PPUSH
60681: CALL_OW 72
60685: ST_TO_ADDR
// if not depot then
60686: LD_VAR 0 9
60690: NOT
60691: IFFALSE 60695
// continue ;
60693: GO 60513
// for j in depot do
60695: LD_ADDR_VAR 0 8
60699: PUSH
60700: LD_VAR 0 9
60704: PUSH
60705: FOR_IN
60706: IFFALSE 60800
// if GetDistUnitXY ( j , x , y ) < 30 then
60708: LD_VAR 0 8
60712: PPUSH
60713: LD_VAR 0 2
60717: PPUSH
60718: LD_VAR 0 3
60722: PPUSH
60723: CALL_OW 297
60727: PUSH
60728: LD_INT 30
60730: LESS
60731: IFFALSE 60798
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60733: LD_ADDR_EXP 115
60737: PUSH
60738: LD_EXP 115
60742: PPUSH
60743: LD_VAR 0 7
60747: PUSH
60748: LD_EXP 115
60752: PUSH
60753: LD_VAR 0 7
60757: ARRAY
60758: PUSH
60759: LD_INT 1
60761: PLUS
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: PPUSH
60767: LD_VAR 0 4
60771: PUSH
60772: LD_VAR 0 2
60776: PUSH
60777: LD_VAR 0 3
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: LIST
60786: PPUSH
60787: CALL 71304 0 3
60791: ST_TO_ADDR
// exit ;
60792: POP
60793: POP
60794: POP
60795: POP
60796: GO 60806
// end ;
60798: GO 60705
60800: POP
60801: POP
// end ;
60802: GO 60513
60804: POP
60805: POP
// end ;
60806: LD_VAR 0 6
60810: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60811: LD_INT 0
60813: PPUSH
60814: PPUSH
60815: PPUSH
60816: PPUSH
// if not mc_bases or not skirmish then
60817: LD_EXP 99
60821: NOT
60822: PUSH
60823: LD_EXP 97
60827: NOT
60828: OR
60829: IFFALSE 60833
// exit ;
60831: GO 61110
// side := GetSide ( lab ) ;
60833: LD_ADDR_VAR 0 4
60837: PUSH
60838: LD_VAR 0 2
60842: PPUSH
60843: CALL_OW 255
60847: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60848: LD_VAR 0 4
60852: PUSH
60853: LD_EXP 125
60857: IN
60858: NOT
60859: PUSH
60860: LD_EXP 126
60864: NOT
60865: OR
60866: PUSH
60867: LD_EXP 99
60871: NOT
60872: OR
60873: IFFALSE 60877
// exit ;
60875: GO 61110
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60877: LD_ADDR_EXP 126
60881: PUSH
60882: LD_EXP 126
60886: PPUSH
60887: LD_VAR 0 4
60891: PPUSH
60892: LD_EXP 126
60896: PUSH
60897: LD_VAR 0 4
60901: ARRAY
60902: PUSH
60903: LD_VAR 0 1
60907: DIFF
60908: PPUSH
60909: CALL_OW 1
60913: ST_TO_ADDR
// for i = 1 to mc_bases do
60914: LD_ADDR_VAR 0 5
60918: PUSH
60919: DOUBLE
60920: LD_INT 1
60922: DEC
60923: ST_TO_ADDR
60924: LD_EXP 99
60928: PUSH
60929: FOR_TO
60930: IFFALSE 61108
// begin if lab in mc_bases [ i ] then
60932: LD_VAR 0 2
60936: PUSH
60937: LD_EXP 99
60941: PUSH
60942: LD_VAR 0 5
60946: ARRAY
60947: IN
60948: IFFALSE 61106
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60950: LD_VAR 0 1
60954: PUSH
60955: LD_INT 11
60957: PUSH
60958: LD_INT 4
60960: PUSH
60961: LD_INT 3
60963: PUSH
60964: LD_INT 2
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: LIST
60971: LIST
60972: IN
60973: PUSH
60974: LD_EXP 129
60978: PUSH
60979: LD_VAR 0 5
60983: ARRAY
60984: AND
60985: IFFALSE 61106
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60987: LD_ADDR_VAR 0 6
60991: PUSH
60992: LD_EXP 129
60996: PUSH
60997: LD_VAR 0 5
61001: ARRAY
61002: PUSH
61003: LD_INT 1
61005: ARRAY
61006: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61007: LD_ADDR_EXP 129
61011: PUSH
61012: LD_EXP 129
61016: PPUSH
61017: LD_VAR 0 5
61021: PPUSH
61022: EMPTY
61023: PPUSH
61024: CALL_OW 1
61028: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61029: LD_VAR 0 6
61033: PPUSH
61034: LD_INT 0
61036: PPUSH
61037: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61041: LD_VAR 0 6
61045: PPUSH
61046: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61050: LD_ADDR_EXP 128
61054: PUSH
61055: LD_EXP 128
61059: PPUSH
61060: LD_VAR 0 5
61064: PPUSH
61065: LD_EXP 128
61069: PUSH
61070: LD_VAR 0 5
61074: ARRAY
61075: PPUSH
61076: LD_INT 1
61078: PPUSH
61079: LD_VAR 0 6
61083: PPUSH
61084: CALL_OW 2
61088: PPUSH
61089: CALL_OW 1
61093: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61094: LD_VAR 0 5
61098: PPUSH
61099: LD_INT 112
61101: PPUSH
61102: CALL 38002 0 2
// end ; end ; end ;
61106: GO 60929
61108: POP
61109: POP
// end ;
61110: LD_VAR 0 3
61114: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61115: LD_INT 0
61117: PPUSH
61118: PPUSH
61119: PPUSH
61120: PPUSH
61121: PPUSH
61122: PPUSH
61123: PPUSH
61124: PPUSH
// if not mc_bases or not skirmish then
61125: LD_EXP 99
61129: NOT
61130: PUSH
61131: LD_EXP 97
61135: NOT
61136: OR
61137: IFFALSE 61141
// exit ;
61139: GO 62512
// for i = 1 to mc_bases do
61141: LD_ADDR_VAR 0 3
61145: PUSH
61146: DOUBLE
61147: LD_INT 1
61149: DEC
61150: ST_TO_ADDR
61151: LD_EXP 99
61155: PUSH
61156: FOR_TO
61157: IFFALSE 62510
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61159: LD_VAR 0 1
61163: PUSH
61164: LD_EXP 99
61168: PUSH
61169: LD_VAR 0 3
61173: ARRAY
61174: IN
61175: PUSH
61176: LD_VAR 0 1
61180: PUSH
61181: LD_EXP 106
61185: PUSH
61186: LD_VAR 0 3
61190: ARRAY
61191: IN
61192: OR
61193: PUSH
61194: LD_VAR 0 1
61198: PUSH
61199: LD_EXP 121
61203: PUSH
61204: LD_VAR 0 3
61208: ARRAY
61209: IN
61210: OR
61211: PUSH
61212: LD_VAR 0 1
61216: PUSH
61217: LD_EXP 118
61221: PUSH
61222: LD_VAR 0 3
61226: ARRAY
61227: IN
61228: OR
61229: PUSH
61230: LD_VAR 0 1
61234: PUSH
61235: LD_EXP 128
61239: PUSH
61240: LD_VAR 0 3
61244: ARRAY
61245: IN
61246: OR
61247: PUSH
61248: LD_VAR 0 1
61252: PUSH
61253: LD_EXP 129
61257: PUSH
61258: LD_VAR 0 3
61262: ARRAY
61263: IN
61264: OR
61265: IFFALSE 62508
// begin if un in mc_ape [ i ] then
61267: LD_VAR 0 1
61271: PUSH
61272: LD_EXP 128
61276: PUSH
61277: LD_VAR 0 3
61281: ARRAY
61282: IN
61283: IFFALSE 61322
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61285: LD_ADDR_EXP 128
61289: PUSH
61290: LD_EXP 128
61294: PPUSH
61295: LD_VAR 0 3
61299: PPUSH
61300: LD_EXP 128
61304: PUSH
61305: LD_VAR 0 3
61309: ARRAY
61310: PUSH
61311: LD_VAR 0 1
61315: DIFF
61316: PPUSH
61317: CALL_OW 1
61321: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61322: LD_VAR 0 1
61326: PUSH
61327: LD_EXP 129
61331: PUSH
61332: LD_VAR 0 3
61336: ARRAY
61337: IN
61338: IFFALSE 61362
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61340: LD_ADDR_EXP 129
61344: PUSH
61345: LD_EXP 129
61349: PPUSH
61350: LD_VAR 0 3
61354: PPUSH
61355: EMPTY
61356: PPUSH
61357: CALL_OW 1
61361: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61362: LD_VAR 0 1
61366: PPUSH
61367: CALL_OW 247
61371: PUSH
61372: LD_INT 2
61374: EQUAL
61375: PUSH
61376: LD_VAR 0 1
61380: PPUSH
61381: CALL_OW 110
61385: PUSH
61386: LD_INT 20
61388: EQUAL
61389: PUSH
61390: LD_VAR 0 1
61394: PUSH
61395: LD_EXP 121
61399: PUSH
61400: LD_VAR 0 3
61404: ARRAY
61405: IN
61406: OR
61407: PUSH
61408: LD_VAR 0 1
61412: PPUSH
61413: CALL_OW 264
61417: PUSH
61418: LD_INT 12
61420: PUSH
61421: LD_INT 51
61423: PUSH
61424: LD_EXP 93
61428: PUSH
61429: LD_INT 32
61431: PUSH
61432: LD_INT 13
61434: PUSH
61435: LD_INT 52
61437: PUSH
61438: LD_INT 31
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: LIST
61445: LIST
61446: LIST
61447: LIST
61448: LIST
61449: IN
61450: OR
61451: AND
61452: IFFALSE 61760
// begin if un in mc_defender [ i ] then
61454: LD_VAR 0 1
61458: PUSH
61459: LD_EXP 121
61463: PUSH
61464: LD_VAR 0 3
61468: ARRAY
61469: IN
61470: IFFALSE 61509
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61472: LD_ADDR_EXP 121
61476: PUSH
61477: LD_EXP 121
61481: PPUSH
61482: LD_VAR 0 3
61486: PPUSH
61487: LD_EXP 121
61491: PUSH
61492: LD_VAR 0 3
61496: ARRAY
61497: PUSH
61498: LD_VAR 0 1
61502: DIFF
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61509: LD_ADDR_VAR 0 8
61513: PUSH
61514: LD_VAR 0 3
61518: PPUSH
61519: LD_INT 3
61521: PPUSH
61522: CALL 58178 0 2
61526: ST_TO_ADDR
// if fac then
61527: LD_VAR 0 8
61531: IFFALSE 61760
// begin for j in fac do
61533: LD_ADDR_VAR 0 4
61537: PUSH
61538: LD_VAR 0 8
61542: PUSH
61543: FOR_IN
61544: IFFALSE 61758
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61546: LD_ADDR_VAR 0 9
61550: PUSH
61551: LD_VAR 0 8
61555: PPUSH
61556: LD_VAR 0 1
61560: PPUSH
61561: CALL_OW 265
61565: PPUSH
61566: LD_VAR 0 1
61570: PPUSH
61571: CALL_OW 262
61575: PPUSH
61576: LD_VAR 0 1
61580: PPUSH
61581: CALL_OW 263
61585: PPUSH
61586: LD_VAR 0 1
61590: PPUSH
61591: CALL_OW 264
61595: PPUSH
61596: CALL 68836 0 5
61600: ST_TO_ADDR
// if components then
61601: LD_VAR 0 9
61605: IFFALSE 61756
// begin if GetWeapon ( un ) = ar_control_tower then
61607: LD_VAR 0 1
61611: PPUSH
61612: CALL_OW 264
61616: PUSH
61617: LD_INT 31
61619: EQUAL
61620: IFFALSE 61737
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61622: LD_VAR 0 1
61626: PPUSH
61627: CALL_OW 311
61631: PPUSH
61632: LD_INT 0
61634: PPUSH
61635: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61639: LD_ADDR_EXP 139
61643: PUSH
61644: LD_EXP 139
61648: PPUSH
61649: LD_VAR 0 3
61653: PPUSH
61654: LD_EXP 139
61658: PUSH
61659: LD_VAR 0 3
61663: ARRAY
61664: PUSH
61665: LD_VAR 0 1
61669: PPUSH
61670: CALL_OW 311
61674: DIFF
61675: PPUSH
61676: CALL_OW 1
61680: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61681: LD_ADDR_VAR 0 7
61685: PUSH
61686: LD_EXP 120
61690: PUSH
61691: LD_VAR 0 3
61695: ARRAY
61696: PPUSH
61697: LD_INT 1
61699: PPUSH
61700: LD_VAR 0 9
61704: PPUSH
61705: CALL_OW 2
61709: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61710: LD_ADDR_EXP 120
61714: PUSH
61715: LD_EXP 120
61719: PPUSH
61720: LD_VAR 0 3
61724: PPUSH
61725: LD_VAR 0 7
61729: PPUSH
61730: CALL_OW 1
61734: ST_TO_ADDR
// end else
61735: GO 61754
// MC_InsertProduceList ( i , [ components ] ) ;
61737: LD_VAR 0 3
61741: PPUSH
61742: LD_VAR 0 9
61746: PUSH
61747: EMPTY
61748: LIST
61749: PPUSH
61750: CALL 57723 0 2
// break ;
61754: GO 61758
// end ; end ;
61756: GO 61543
61758: POP
61759: POP
// end ; end ; if GetType ( un ) = unit_building then
61760: LD_VAR 0 1
61764: PPUSH
61765: CALL_OW 247
61769: PUSH
61770: LD_INT 3
61772: EQUAL
61773: IFFALSE 62176
// begin btype := GetBType ( un ) ;
61775: LD_ADDR_VAR 0 5
61779: PUSH
61780: LD_VAR 0 1
61784: PPUSH
61785: CALL_OW 266
61789: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61790: LD_VAR 0 5
61794: PUSH
61795: LD_INT 29
61797: PUSH
61798: LD_INT 30
61800: PUSH
61801: EMPTY
61802: LIST
61803: LIST
61804: IN
61805: IFFALSE 61878
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61807: LD_VAR 0 1
61811: PPUSH
61812: CALL_OW 250
61816: PPUSH
61817: LD_VAR 0 1
61821: PPUSH
61822: CALL_OW 251
61826: PPUSH
61827: LD_VAR 0 1
61831: PPUSH
61832: CALL_OW 255
61836: PPUSH
61837: CALL_OW 440
61841: NOT
61842: IFFALSE 61878
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61844: LD_VAR 0 1
61848: PPUSH
61849: CALL_OW 250
61853: PPUSH
61854: LD_VAR 0 1
61858: PPUSH
61859: CALL_OW 251
61863: PPUSH
61864: LD_VAR 0 1
61868: PPUSH
61869: CALL_OW 255
61873: PPUSH
61874: CALL_OW 441
// end ; if btype = b_warehouse then
61878: LD_VAR 0 5
61882: PUSH
61883: LD_INT 1
61885: EQUAL
61886: IFFALSE 61904
// begin btype := b_depot ;
61888: LD_ADDR_VAR 0 5
61892: PUSH
61893: LD_INT 0
61895: ST_TO_ADDR
// pos := 1 ;
61896: LD_ADDR_VAR 0 6
61900: PUSH
61901: LD_INT 1
61903: ST_TO_ADDR
// end ; if btype = b_factory then
61904: LD_VAR 0 5
61908: PUSH
61909: LD_INT 3
61911: EQUAL
61912: IFFALSE 61930
// begin btype := b_workshop ;
61914: LD_ADDR_VAR 0 5
61918: PUSH
61919: LD_INT 2
61921: ST_TO_ADDR
// pos := 1 ;
61922: LD_ADDR_VAR 0 6
61926: PUSH
61927: LD_INT 1
61929: ST_TO_ADDR
// end ; if btype = b_barracks then
61930: LD_VAR 0 5
61934: PUSH
61935: LD_INT 5
61937: EQUAL
61938: IFFALSE 61948
// btype := b_armoury ;
61940: LD_ADDR_VAR 0 5
61944: PUSH
61945: LD_INT 4
61947: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61948: LD_VAR 0 5
61952: PUSH
61953: LD_INT 7
61955: PUSH
61956: LD_INT 8
61958: PUSH
61959: EMPTY
61960: LIST
61961: LIST
61962: IN
61963: IFFALSE 61973
// btype := b_lab ;
61965: LD_ADDR_VAR 0 5
61969: PUSH
61970: LD_INT 6
61972: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61973: LD_ADDR_EXP 104
61977: PUSH
61978: LD_EXP 104
61982: PPUSH
61983: LD_VAR 0 3
61987: PUSH
61988: LD_EXP 104
61992: PUSH
61993: LD_VAR 0 3
61997: ARRAY
61998: PUSH
61999: LD_INT 1
62001: PLUS
62002: PUSH
62003: EMPTY
62004: LIST
62005: LIST
62006: PPUSH
62007: LD_VAR 0 5
62011: PUSH
62012: LD_VAR 0 1
62016: PPUSH
62017: CALL_OW 250
62021: PUSH
62022: LD_VAR 0 1
62026: PPUSH
62027: CALL_OW 251
62031: PUSH
62032: LD_VAR 0 1
62036: PPUSH
62037: CALL_OW 254
62041: PUSH
62042: EMPTY
62043: LIST
62044: LIST
62045: LIST
62046: LIST
62047: PPUSH
62048: CALL 71304 0 3
62052: ST_TO_ADDR
// if pos = 1 then
62053: LD_VAR 0 6
62057: PUSH
62058: LD_INT 1
62060: EQUAL
62061: IFFALSE 62176
// begin tmp := mc_build_list [ i ] ;
62063: LD_ADDR_VAR 0 7
62067: PUSH
62068: LD_EXP 104
62072: PUSH
62073: LD_VAR 0 3
62077: ARRAY
62078: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62079: LD_VAR 0 7
62083: PPUSH
62084: LD_INT 2
62086: PUSH
62087: LD_INT 30
62089: PUSH
62090: LD_INT 0
62092: PUSH
62093: EMPTY
62094: LIST
62095: LIST
62096: PUSH
62097: LD_INT 30
62099: PUSH
62100: LD_INT 1
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: LIST
62111: PPUSH
62112: CALL_OW 72
62116: IFFALSE 62126
// pos := 2 ;
62118: LD_ADDR_VAR 0 6
62122: PUSH
62123: LD_INT 2
62125: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62126: LD_ADDR_VAR 0 7
62130: PUSH
62131: LD_VAR 0 7
62135: PPUSH
62136: LD_VAR 0 6
62140: PPUSH
62141: LD_VAR 0 7
62145: PPUSH
62146: CALL 71630 0 3
62150: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62151: LD_ADDR_EXP 104
62155: PUSH
62156: LD_EXP 104
62160: PPUSH
62161: LD_VAR 0 3
62165: PPUSH
62166: LD_VAR 0 7
62170: PPUSH
62171: CALL_OW 1
62175: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62176: LD_VAR 0 1
62180: PUSH
62181: LD_EXP 99
62185: PUSH
62186: LD_VAR 0 3
62190: ARRAY
62191: IN
62192: IFFALSE 62231
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62194: LD_ADDR_EXP 99
62198: PUSH
62199: LD_EXP 99
62203: PPUSH
62204: LD_VAR 0 3
62208: PPUSH
62209: LD_EXP 99
62213: PUSH
62214: LD_VAR 0 3
62218: ARRAY
62219: PUSH
62220: LD_VAR 0 1
62224: DIFF
62225: PPUSH
62226: CALL_OW 1
62230: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62231: LD_VAR 0 1
62235: PUSH
62236: LD_EXP 106
62240: PUSH
62241: LD_VAR 0 3
62245: ARRAY
62246: IN
62247: IFFALSE 62286
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62249: LD_ADDR_EXP 106
62253: PUSH
62254: LD_EXP 106
62258: PPUSH
62259: LD_VAR 0 3
62263: PPUSH
62264: LD_EXP 106
62268: PUSH
62269: LD_VAR 0 3
62273: ARRAY
62274: PUSH
62275: LD_VAR 0 1
62279: DIFF
62280: PPUSH
62281: CALL_OW 1
62285: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62286: LD_VAR 0 1
62290: PUSH
62291: LD_EXP 118
62295: PUSH
62296: LD_VAR 0 3
62300: ARRAY
62301: IN
62302: IFFALSE 62341
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62304: LD_ADDR_EXP 118
62308: PUSH
62309: LD_EXP 118
62313: PPUSH
62314: LD_VAR 0 3
62318: PPUSH
62319: LD_EXP 118
62323: PUSH
62324: LD_VAR 0 3
62328: ARRAY
62329: PUSH
62330: LD_VAR 0 1
62334: DIFF
62335: PPUSH
62336: CALL_OW 1
62340: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62341: LD_VAR 0 1
62345: PUSH
62346: LD_EXP 121
62350: PUSH
62351: LD_VAR 0 3
62355: ARRAY
62356: IN
62357: IFFALSE 62396
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62359: LD_ADDR_EXP 121
62363: PUSH
62364: LD_EXP 121
62368: PPUSH
62369: LD_VAR 0 3
62373: PPUSH
62374: LD_EXP 121
62378: PUSH
62379: LD_VAR 0 3
62383: ARRAY
62384: PUSH
62385: LD_VAR 0 1
62389: DIFF
62390: PPUSH
62391: CALL_OW 1
62395: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62396: LD_VAR 0 1
62400: PUSH
62401: LD_EXP 108
62405: PUSH
62406: LD_VAR 0 3
62410: ARRAY
62411: IN
62412: IFFALSE 62451
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62414: LD_ADDR_EXP 108
62418: PUSH
62419: LD_EXP 108
62423: PPUSH
62424: LD_VAR 0 3
62428: PPUSH
62429: LD_EXP 108
62433: PUSH
62434: LD_VAR 0 3
62438: ARRAY
62439: PUSH
62440: LD_VAR 0 1
62444: DIFF
62445: PPUSH
62446: CALL_OW 1
62450: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62451: LD_VAR 0 1
62455: PUSH
62456: LD_EXP 107
62460: PUSH
62461: LD_VAR 0 3
62465: ARRAY
62466: IN
62467: IFFALSE 62506
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62469: LD_ADDR_EXP 107
62473: PUSH
62474: LD_EXP 107
62478: PPUSH
62479: LD_VAR 0 3
62483: PPUSH
62484: LD_EXP 107
62488: PUSH
62489: LD_VAR 0 3
62493: ARRAY
62494: PUSH
62495: LD_VAR 0 1
62499: DIFF
62500: PPUSH
62501: CALL_OW 1
62505: ST_TO_ADDR
// end ; break ;
62506: GO 62510
// end ;
62508: GO 61156
62510: POP
62511: POP
// end ;
62512: LD_VAR 0 2
62516: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62517: LD_INT 0
62519: PPUSH
62520: PPUSH
62521: PPUSH
// if not mc_bases or not skirmish then
62522: LD_EXP 99
62526: NOT
62527: PUSH
62528: LD_EXP 97
62532: NOT
62533: OR
62534: IFFALSE 62538
// exit ;
62536: GO 62753
// for i = 1 to mc_bases do
62538: LD_ADDR_VAR 0 3
62542: PUSH
62543: DOUBLE
62544: LD_INT 1
62546: DEC
62547: ST_TO_ADDR
62548: LD_EXP 99
62552: PUSH
62553: FOR_TO
62554: IFFALSE 62751
// begin if building in mc_construct_list [ i ] then
62556: LD_VAR 0 1
62560: PUSH
62561: LD_EXP 106
62565: PUSH
62566: LD_VAR 0 3
62570: ARRAY
62571: IN
62572: IFFALSE 62749
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62574: LD_ADDR_EXP 106
62578: PUSH
62579: LD_EXP 106
62583: PPUSH
62584: LD_VAR 0 3
62588: PPUSH
62589: LD_EXP 106
62593: PUSH
62594: LD_VAR 0 3
62598: ARRAY
62599: PUSH
62600: LD_VAR 0 1
62604: DIFF
62605: PPUSH
62606: CALL_OW 1
62610: ST_TO_ADDR
// if building in mc_lab [ i ] then
62611: LD_VAR 0 1
62615: PUSH
62616: LD_EXP 132
62620: PUSH
62621: LD_VAR 0 3
62625: ARRAY
62626: IN
62627: IFFALSE 62682
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62629: LD_ADDR_EXP 133
62633: PUSH
62634: LD_EXP 133
62638: PPUSH
62639: LD_VAR 0 3
62643: PPUSH
62644: LD_EXP 133
62648: PUSH
62649: LD_VAR 0 3
62653: ARRAY
62654: PPUSH
62655: LD_INT 1
62657: PPUSH
62658: LD_EXP 133
62662: PUSH
62663: LD_VAR 0 3
62667: ARRAY
62668: PPUSH
62669: LD_INT 0
62671: PPUSH
62672: CALL 70722 0 4
62676: PPUSH
62677: CALL_OW 1
62681: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62682: LD_VAR 0 1
62686: PUSH
62687: LD_EXP 99
62691: PUSH
62692: LD_VAR 0 3
62696: ARRAY
62697: IN
62698: NOT
62699: IFFALSE 62745
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62701: LD_ADDR_EXP 99
62705: PUSH
62706: LD_EXP 99
62710: PPUSH
62711: LD_VAR 0 3
62715: PUSH
62716: LD_EXP 99
62720: PUSH
62721: LD_VAR 0 3
62725: ARRAY
62726: PUSH
62727: LD_INT 1
62729: PLUS
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PPUSH
62735: LD_VAR 0 1
62739: PPUSH
62740: CALL 71304 0 3
62744: ST_TO_ADDR
// exit ;
62745: POP
62746: POP
62747: GO 62753
// end ; end ;
62749: GO 62553
62751: POP
62752: POP
// end ;
62753: LD_VAR 0 2
62757: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62758: LD_INT 0
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
// if not mc_bases or not skirmish then
62767: LD_EXP 99
62771: NOT
62772: PUSH
62773: LD_EXP 97
62777: NOT
62778: OR
62779: IFFALSE 62783
// exit ;
62781: GO 63444
// for i = 1 to mc_bases do
62783: LD_ADDR_VAR 0 3
62787: PUSH
62788: DOUBLE
62789: LD_INT 1
62791: DEC
62792: ST_TO_ADDR
62793: LD_EXP 99
62797: PUSH
62798: FOR_TO
62799: IFFALSE 63442
// begin if building in mc_construct_list [ i ] then
62801: LD_VAR 0 1
62805: PUSH
62806: LD_EXP 106
62810: PUSH
62811: LD_VAR 0 3
62815: ARRAY
62816: IN
62817: IFFALSE 63440
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62819: LD_ADDR_EXP 106
62823: PUSH
62824: LD_EXP 106
62828: PPUSH
62829: LD_VAR 0 3
62833: PPUSH
62834: LD_EXP 106
62838: PUSH
62839: LD_VAR 0 3
62843: ARRAY
62844: PUSH
62845: LD_VAR 0 1
62849: DIFF
62850: PPUSH
62851: CALL_OW 1
62855: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62856: LD_ADDR_EXP 99
62860: PUSH
62861: LD_EXP 99
62865: PPUSH
62866: LD_VAR 0 3
62870: PUSH
62871: LD_EXP 99
62875: PUSH
62876: LD_VAR 0 3
62880: ARRAY
62881: PUSH
62882: LD_INT 1
62884: PLUS
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PPUSH
62890: LD_VAR 0 1
62894: PPUSH
62895: CALL 71304 0 3
62899: ST_TO_ADDR
// btype := GetBType ( building ) ;
62900: LD_ADDR_VAR 0 5
62904: PUSH
62905: LD_VAR 0 1
62909: PPUSH
62910: CALL_OW 266
62914: ST_TO_ADDR
// side := GetSide ( building ) ;
62915: LD_ADDR_VAR 0 8
62919: PUSH
62920: LD_VAR 0 1
62924: PPUSH
62925: CALL_OW 255
62929: ST_TO_ADDR
// if btype = b_lab then
62930: LD_VAR 0 5
62934: PUSH
62935: LD_INT 6
62937: EQUAL
62938: IFFALSE 62988
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62940: LD_ADDR_EXP 132
62944: PUSH
62945: LD_EXP 132
62949: PPUSH
62950: LD_VAR 0 3
62954: PUSH
62955: LD_EXP 132
62959: PUSH
62960: LD_VAR 0 3
62964: ARRAY
62965: PUSH
62966: LD_INT 1
62968: PLUS
62969: PUSH
62970: EMPTY
62971: LIST
62972: LIST
62973: PPUSH
62974: LD_VAR 0 1
62978: PPUSH
62979: CALL 71304 0 3
62983: ST_TO_ADDR
// exit ;
62984: POP
62985: POP
62986: GO 63444
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62988: LD_VAR 0 5
62992: PUSH
62993: LD_INT 0
62995: PUSH
62996: LD_INT 2
62998: PUSH
62999: LD_INT 4
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: LIST
63006: IN
63007: IFFALSE 63131
// begin if btype = b_armoury then
63009: LD_VAR 0 5
63013: PUSH
63014: LD_INT 4
63016: EQUAL
63017: IFFALSE 63027
// btype := b_barracks ;
63019: LD_ADDR_VAR 0 5
63023: PUSH
63024: LD_INT 5
63026: ST_TO_ADDR
// if btype = b_depot then
63027: LD_VAR 0 5
63031: PUSH
63032: LD_INT 0
63034: EQUAL
63035: IFFALSE 63045
// btype := b_warehouse ;
63037: LD_ADDR_VAR 0 5
63041: PUSH
63042: LD_INT 1
63044: ST_TO_ADDR
// if btype = b_workshop then
63045: LD_VAR 0 5
63049: PUSH
63050: LD_INT 2
63052: EQUAL
63053: IFFALSE 63063
// btype := b_factory ;
63055: LD_ADDR_VAR 0 5
63059: PUSH
63060: LD_INT 3
63062: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63063: LD_VAR 0 5
63067: PPUSH
63068: LD_VAR 0 8
63072: PPUSH
63073: CALL_OW 323
63077: PUSH
63078: LD_INT 1
63080: EQUAL
63081: IFFALSE 63127
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63083: LD_ADDR_EXP 131
63087: PUSH
63088: LD_EXP 131
63092: PPUSH
63093: LD_VAR 0 3
63097: PUSH
63098: LD_EXP 131
63102: PUSH
63103: LD_VAR 0 3
63107: ARRAY
63108: PUSH
63109: LD_INT 1
63111: PLUS
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PPUSH
63117: LD_VAR 0 1
63121: PPUSH
63122: CALL 71304 0 3
63126: ST_TO_ADDR
// exit ;
63127: POP
63128: POP
63129: GO 63444
// end ; if btype in [ b_bunker , b_turret ] then
63131: LD_VAR 0 5
63135: PUSH
63136: LD_INT 32
63138: PUSH
63139: LD_INT 33
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: IN
63146: IFFALSE 63436
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63148: LD_ADDR_EXP 107
63152: PUSH
63153: LD_EXP 107
63157: PPUSH
63158: LD_VAR 0 3
63162: PUSH
63163: LD_EXP 107
63167: PUSH
63168: LD_VAR 0 3
63172: ARRAY
63173: PUSH
63174: LD_INT 1
63176: PLUS
63177: PUSH
63178: EMPTY
63179: LIST
63180: LIST
63181: PPUSH
63182: LD_VAR 0 1
63186: PPUSH
63187: CALL 71304 0 3
63191: ST_TO_ADDR
// if btype = b_bunker then
63192: LD_VAR 0 5
63196: PUSH
63197: LD_INT 32
63199: EQUAL
63200: IFFALSE 63436
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63202: LD_ADDR_EXP 108
63206: PUSH
63207: LD_EXP 108
63211: PPUSH
63212: LD_VAR 0 3
63216: PUSH
63217: LD_EXP 108
63221: PUSH
63222: LD_VAR 0 3
63226: ARRAY
63227: PUSH
63228: LD_INT 1
63230: PLUS
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PPUSH
63236: LD_VAR 0 1
63240: PPUSH
63241: CALL 71304 0 3
63245: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63246: LD_ADDR_VAR 0 6
63250: PUSH
63251: LD_EXP 99
63255: PUSH
63256: LD_VAR 0 3
63260: ARRAY
63261: PPUSH
63262: LD_INT 25
63264: PUSH
63265: LD_INT 1
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 3
63274: PUSH
63275: LD_INT 54
63277: PUSH
63278: EMPTY
63279: LIST
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: EMPTY
63286: LIST
63287: LIST
63288: PPUSH
63289: CALL_OW 72
63293: ST_TO_ADDR
// if tmp then
63294: LD_VAR 0 6
63298: IFFALSE 63304
// exit ;
63300: POP
63301: POP
63302: GO 63444
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63304: LD_ADDR_VAR 0 6
63308: PUSH
63309: LD_EXP 99
63313: PUSH
63314: LD_VAR 0 3
63318: ARRAY
63319: PPUSH
63320: LD_INT 2
63322: PUSH
63323: LD_INT 30
63325: PUSH
63326: LD_INT 4
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 30
63335: PUSH
63336: LD_INT 5
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: LIST
63347: PPUSH
63348: CALL_OW 72
63352: ST_TO_ADDR
// if not tmp then
63353: LD_VAR 0 6
63357: NOT
63358: IFFALSE 63364
// exit ;
63360: POP
63361: POP
63362: GO 63444
// for j in tmp do
63364: LD_ADDR_VAR 0 4
63368: PUSH
63369: LD_VAR 0 6
63373: PUSH
63374: FOR_IN
63375: IFFALSE 63434
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63377: LD_ADDR_VAR 0 7
63381: PUSH
63382: LD_VAR 0 4
63386: PPUSH
63387: CALL_OW 313
63391: PPUSH
63392: LD_INT 25
63394: PUSH
63395: LD_INT 1
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: PPUSH
63402: CALL_OW 72
63406: ST_TO_ADDR
// if units then
63407: LD_VAR 0 7
63411: IFFALSE 63432
// begin ComExitBuilding ( units [ 1 ] ) ;
63413: LD_VAR 0 7
63417: PUSH
63418: LD_INT 1
63420: ARRAY
63421: PPUSH
63422: CALL_OW 122
// exit ;
63426: POP
63427: POP
63428: POP
63429: POP
63430: GO 63444
// end ; end ;
63432: GO 63374
63434: POP
63435: POP
// end ; end ; exit ;
63436: POP
63437: POP
63438: GO 63444
// end ; end ;
63440: GO 62798
63442: POP
63443: POP
// end ;
63444: LD_VAR 0 2
63448: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63449: LD_INT 0
63451: PPUSH
63452: PPUSH
63453: PPUSH
63454: PPUSH
63455: PPUSH
63456: PPUSH
63457: PPUSH
// if not mc_bases or not skirmish then
63458: LD_EXP 99
63462: NOT
63463: PUSH
63464: LD_EXP 97
63468: NOT
63469: OR
63470: IFFALSE 63474
// exit ;
63472: GO 63705
// btype := GetBType ( building ) ;
63474: LD_ADDR_VAR 0 6
63478: PUSH
63479: LD_VAR 0 1
63483: PPUSH
63484: CALL_OW 266
63488: ST_TO_ADDR
// x := GetX ( building ) ;
63489: LD_ADDR_VAR 0 7
63493: PUSH
63494: LD_VAR 0 1
63498: PPUSH
63499: CALL_OW 250
63503: ST_TO_ADDR
// y := GetY ( building ) ;
63504: LD_ADDR_VAR 0 8
63508: PUSH
63509: LD_VAR 0 1
63513: PPUSH
63514: CALL_OW 251
63518: ST_TO_ADDR
// d := GetDir ( building ) ;
63519: LD_ADDR_VAR 0 9
63523: PUSH
63524: LD_VAR 0 1
63528: PPUSH
63529: CALL_OW 254
63533: ST_TO_ADDR
// for i = 1 to mc_bases do
63534: LD_ADDR_VAR 0 4
63538: PUSH
63539: DOUBLE
63540: LD_INT 1
63542: DEC
63543: ST_TO_ADDR
63544: LD_EXP 99
63548: PUSH
63549: FOR_TO
63550: IFFALSE 63703
// begin if not mc_build_list [ i ] then
63552: LD_EXP 104
63556: PUSH
63557: LD_VAR 0 4
63561: ARRAY
63562: NOT
63563: IFFALSE 63567
// continue ;
63565: GO 63549
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63567: LD_VAR 0 6
63571: PUSH
63572: LD_VAR 0 7
63576: PUSH
63577: LD_VAR 0 8
63581: PUSH
63582: LD_VAR 0 9
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: LIST
63591: LIST
63592: PPUSH
63593: LD_EXP 104
63597: PUSH
63598: LD_VAR 0 4
63602: ARRAY
63603: PUSH
63604: LD_INT 1
63606: ARRAY
63607: PPUSH
63608: CALL 77473 0 2
63612: IFFALSE 63701
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63614: LD_ADDR_EXP 104
63618: PUSH
63619: LD_EXP 104
63623: PPUSH
63624: LD_VAR 0 4
63628: PPUSH
63629: LD_EXP 104
63633: PUSH
63634: LD_VAR 0 4
63638: ARRAY
63639: PPUSH
63640: LD_INT 1
63642: PPUSH
63643: CALL_OW 3
63647: PPUSH
63648: CALL_OW 1
63652: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63653: LD_ADDR_EXP 106
63657: PUSH
63658: LD_EXP 106
63662: PPUSH
63663: LD_VAR 0 4
63667: PUSH
63668: LD_EXP 106
63672: PUSH
63673: LD_VAR 0 4
63677: ARRAY
63678: PUSH
63679: LD_INT 1
63681: PLUS
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PPUSH
63687: LD_VAR 0 1
63691: PPUSH
63692: CALL 71304 0 3
63696: ST_TO_ADDR
// exit ;
63697: POP
63698: POP
63699: GO 63705
// end ; end ;
63701: GO 63549
63703: POP
63704: POP
// end ;
63705: LD_VAR 0 3
63709: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63710: LD_INT 0
63712: PPUSH
63713: PPUSH
63714: PPUSH
// if not mc_bases or not skirmish then
63715: LD_EXP 99
63719: NOT
63720: PUSH
63721: LD_EXP 97
63725: NOT
63726: OR
63727: IFFALSE 63731
// exit ;
63729: GO 63921
// for i = 1 to mc_bases do
63731: LD_ADDR_VAR 0 4
63735: PUSH
63736: DOUBLE
63737: LD_INT 1
63739: DEC
63740: ST_TO_ADDR
63741: LD_EXP 99
63745: PUSH
63746: FOR_TO
63747: IFFALSE 63834
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63749: LD_VAR 0 1
63753: PUSH
63754: LD_EXP 107
63758: PUSH
63759: LD_VAR 0 4
63763: ARRAY
63764: IN
63765: PUSH
63766: LD_VAR 0 1
63770: PUSH
63771: LD_EXP 108
63775: PUSH
63776: LD_VAR 0 4
63780: ARRAY
63781: IN
63782: NOT
63783: AND
63784: IFFALSE 63832
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63786: LD_ADDR_EXP 108
63790: PUSH
63791: LD_EXP 108
63795: PPUSH
63796: LD_VAR 0 4
63800: PUSH
63801: LD_EXP 108
63805: PUSH
63806: LD_VAR 0 4
63810: ARRAY
63811: PUSH
63812: LD_INT 1
63814: PLUS
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: PPUSH
63820: LD_VAR 0 1
63824: PPUSH
63825: CALL 71304 0 3
63829: ST_TO_ADDR
// break ;
63830: GO 63834
// end ; end ;
63832: GO 63746
63834: POP
63835: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63836: LD_VAR 0 1
63840: PPUSH
63841: CALL_OW 257
63845: PUSH
63846: LD_EXP 125
63850: IN
63851: PUSH
63852: LD_VAR 0 1
63856: PPUSH
63857: CALL_OW 266
63861: PUSH
63862: LD_INT 5
63864: EQUAL
63865: AND
63866: PUSH
63867: LD_VAR 0 2
63871: PPUSH
63872: CALL_OW 110
63876: PUSH
63877: LD_INT 18
63879: NONEQUAL
63880: AND
63881: IFFALSE 63921
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63883: LD_VAR 0 2
63887: PPUSH
63888: CALL_OW 257
63892: PUSH
63893: LD_INT 5
63895: PUSH
63896: LD_INT 8
63898: PUSH
63899: LD_INT 9
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: LIST
63906: IN
63907: IFFALSE 63921
// SetClass ( unit , 1 ) ;
63909: LD_VAR 0 2
63913: PPUSH
63914: LD_INT 1
63916: PPUSH
63917: CALL_OW 336
// end ;
63921: LD_VAR 0 3
63925: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63926: LD_INT 0
63928: PPUSH
63929: PPUSH
// if not mc_bases or not skirmish then
63930: LD_EXP 99
63934: NOT
63935: PUSH
63936: LD_EXP 97
63940: NOT
63941: OR
63942: IFFALSE 63946
// exit ;
63944: GO 64062
// if GetLives ( abandoned_vehicle ) > 250 then
63946: LD_VAR 0 2
63950: PPUSH
63951: CALL_OW 256
63955: PUSH
63956: LD_INT 250
63958: GREATER
63959: IFFALSE 63963
// exit ;
63961: GO 64062
// for i = 1 to mc_bases do
63963: LD_ADDR_VAR 0 6
63967: PUSH
63968: DOUBLE
63969: LD_INT 1
63971: DEC
63972: ST_TO_ADDR
63973: LD_EXP 99
63977: PUSH
63978: FOR_TO
63979: IFFALSE 64060
// begin if driver in mc_bases [ i ] then
63981: LD_VAR 0 1
63985: PUSH
63986: LD_EXP 99
63990: PUSH
63991: LD_VAR 0 6
63995: ARRAY
63996: IN
63997: IFFALSE 64058
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63999: LD_VAR 0 1
64003: PPUSH
64004: LD_EXP 99
64008: PUSH
64009: LD_VAR 0 6
64013: ARRAY
64014: PPUSH
64015: LD_INT 2
64017: PUSH
64018: LD_INT 30
64020: PUSH
64021: LD_INT 0
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PUSH
64028: LD_INT 30
64030: PUSH
64031: LD_INT 1
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: LIST
64042: PPUSH
64043: CALL_OW 72
64047: PUSH
64048: LD_INT 1
64050: ARRAY
64051: PPUSH
64052: CALL_OW 112
// break ;
64056: GO 64060
// end ; end ;
64058: GO 63978
64060: POP
64061: POP
// end ; end_of_file
64062: LD_VAR 0 5
64066: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64067: LD_INT 0
64069: PPUSH
64070: PPUSH
// if exist_mode then
64071: LD_VAR 0 2
64075: IFFALSE 64100
// unit := CreateCharacter ( prefix & ident ) else
64077: LD_ADDR_VAR 0 5
64081: PUSH
64082: LD_VAR 0 3
64086: PUSH
64087: LD_VAR 0 1
64091: STR
64092: PPUSH
64093: CALL_OW 34
64097: ST_TO_ADDR
64098: GO 64115
// unit := NewCharacter ( ident ) ;
64100: LD_ADDR_VAR 0 5
64104: PUSH
64105: LD_VAR 0 1
64109: PPUSH
64110: CALL_OW 25
64114: ST_TO_ADDR
// result := unit ;
64115: LD_ADDR_VAR 0 4
64119: PUSH
64120: LD_VAR 0 5
64124: ST_TO_ADDR
// end ;
64125: LD_VAR 0 4
64129: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64130: LD_INT 0
64132: PPUSH
64133: PPUSH
// if not side or not nation then
64134: LD_VAR 0 1
64138: NOT
64139: PUSH
64140: LD_VAR 0 2
64144: NOT
64145: OR
64146: IFFALSE 64150
// exit ;
64148: GO 64794
// case nation of nation_american :
64150: LD_VAR 0 2
64154: PUSH
64155: LD_INT 1
64157: DOUBLE
64158: EQUAL
64159: IFTRUE 64163
64161: GO 64337
64163: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64164: LD_ADDR_VAR 0 4
64168: PUSH
64169: LD_INT 35
64171: PUSH
64172: LD_INT 45
64174: PUSH
64175: LD_INT 46
64177: PUSH
64178: LD_INT 47
64180: PUSH
64181: LD_INT 1
64183: PUSH
64184: LD_INT 2
64186: PUSH
64187: LD_INT 6
64189: PUSH
64190: LD_INT 15
64192: PUSH
64193: LD_INT 16
64195: PUSH
64196: LD_INT 7
64198: PUSH
64199: LD_INT 12
64201: PUSH
64202: LD_INT 13
64204: PUSH
64205: LD_INT 10
64207: PUSH
64208: LD_INT 14
64210: PUSH
64211: LD_INT 20
64213: PUSH
64214: LD_INT 21
64216: PUSH
64217: LD_INT 22
64219: PUSH
64220: LD_INT 25
64222: PUSH
64223: LD_INT 32
64225: PUSH
64226: LD_INT 27
64228: PUSH
64229: LD_INT 36
64231: PUSH
64232: LD_INT 69
64234: PUSH
64235: LD_INT 39
64237: PUSH
64238: LD_INT 34
64240: PUSH
64241: LD_INT 40
64243: PUSH
64244: LD_INT 48
64246: PUSH
64247: LD_INT 49
64249: PUSH
64250: LD_INT 50
64252: PUSH
64253: LD_INT 51
64255: PUSH
64256: LD_INT 52
64258: PUSH
64259: LD_INT 53
64261: PUSH
64262: LD_INT 54
64264: PUSH
64265: LD_INT 55
64267: PUSH
64268: LD_INT 56
64270: PUSH
64271: LD_INT 57
64273: PUSH
64274: LD_INT 58
64276: PUSH
64277: LD_INT 59
64279: PUSH
64280: LD_INT 60
64282: PUSH
64283: LD_INT 61
64285: PUSH
64286: LD_INT 62
64288: PUSH
64289: LD_INT 80
64291: PUSH
64292: EMPTY
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: ST_TO_ADDR
64335: GO 64718
64337: LD_INT 2
64339: DOUBLE
64340: EQUAL
64341: IFTRUE 64345
64343: GO 64527
64345: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64346: LD_ADDR_VAR 0 4
64350: PUSH
64351: LD_INT 35
64353: PUSH
64354: LD_INT 45
64356: PUSH
64357: LD_INT 46
64359: PUSH
64360: LD_INT 47
64362: PUSH
64363: LD_INT 70
64365: PUSH
64366: LD_INT 1
64368: PUSH
64369: LD_INT 11
64371: PUSH
64372: LD_INT 3
64374: PUSH
64375: LD_INT 4
64377: PUSH
64378: LD_INT 5
64380: PUSH
64381: LD_INT 6
64383: PUSH
64384: LD_INT 15
64386: PUSH
64387: LD_INT 18
64389: PUSH
64390: LD_INT 7
64392: PUSH
64393: LD_INT 17
64395: PUSH
64396: LD_INT 8
64398: PUSH
64399: LD_INT 20
64401: PUSH
64402: LD_INT 21
64404: PUSH
64405: LD_INT 22
64407: PUSH
64408: LD_INT 72
64410: PUSH
64411: LD_INT 26
64413: PUSH
64414: LD_INT 69
64416: PUSH
64417: LD_INT 39
64419: PUSH
64420: LD_INT 40
64422: PUSH
64423: LD_INT 41
64425: PUSH
64426: LD_INT 42
64428: PUSH
64429: LD_INT 43
64431: PUSH
64432: LD_INT 48
64434: PUSH
64435: LD_INT 49
64437: PUSH
64438: LD_INT 50
64440: PUSH
64441: LD_INT 51
64443: PUSH
64444: LD_INT 52
64446: PUSH
64447: LD_INT 53
64449: PUSH
64450: LD_INT 54
64452: PUSH
64453: LD_INT 55
64455: PUSH
64456: LD_INT 56
64458: PUSH
64459: LD_INT 60
64461: PUSH
64462: LD_INT 61
64464: PUSH
64465: LD_INT 62
64467: PUSH
64468: LD_INT 66
64470: PUSH
64471: LD_INT 67
64473: PUSH
64474: LD_INT 68
64476: PUSH
64477: LD_INT 81
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: ST_TO_ADDR
64525: GO 64718
64527: LD_INT 3
64529: DOUBLE
64530: EQUAL
64531: IFTRUE 64535
64533: GO 64717
64535: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64536: LD_ADDR_VAR 0 4
64540: PUSH
64541: LD_INT 46
64543: PUSH
64544: LD_INT 47
64546: PUSH
64547: LD_INT 1
64549: PUSH
64550: LD_INT 2
64552: PUSH
64553: LD_INT 11
64555: PUSH
64556: LD_INT 9
64558: PUSH
64559: LD_INT 20
64561: PUSH
64562: LD_INT 19
64564: PUSH
64565: LD_INT 21
64567: PUSH
64568: LD_INT 24
64570: PUSH
64571: LD_INT 22
64573: PUSH
64574: LD_INT 25
64576: PUSH
64577: LD_INT 28
64579: PUSH
64580: LD_INT 29
64582: PUSH
64583: LD_INT 30
64585: PUSH
64586: LD_INT 31
64588: PUSH
64589: LD_INT 37
64591: PUSH
64592: LD_INT 38
64594: PUSH
64595: LD_INT 32
64597: PUSH
64598: LD_INT 27
64600: PUSH
64601: LD_INT 33
64603: PUSH
64604: LD_INT 69
64606: PUSH
64607: LD_INT 39
64609: PUSH
64610: LD_INT 34
64612: PUSH
64613: LD_INT 40
64615: PUSH
64616: LD_INT 71
64618: PUSH
64619: LD_INT 23
64621: PUSH
64622: LD_INT 44
64624: PUSH
64625: LD_INT 48
64627: PUSH
64628: LD_INT 49
64630: PUSH
64631: LD_INT 50
64633: PUSH
64634: LD_INT 51
64636: PUSH
64637: LD_INT 52
64639: PUSH
64640: LD_INT 53
64642: PUSH
64643: LD_INT 54
64645: PUSH
64646: LD_INT 55
64648: PUSH
64649: LD_INT 56
64651: PUSH
64652: LD_INT 57
64654: PUSH
64655: LD_INT 58
64657: PUSH
64658: LD_INT 59
64660: PUSH
64661: LD_INT 63
64663: PUSH
64664: LD_INT 64
64666: PUSH
64667: LD_INT 65
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: LIST
64712: LIST
64713: LIST
64714: ST_TO_ADDR
64715: GO 64718
64717: POP
// if state > - 1 and state < 3 then
64718: LD_VAR 0 3
64722: PUSH
64723: LD_INT 1
64725: NEG
64726: GREATER
64727: PUSH
64728: LD_VAR 0 3
64732: PUSH
64733: LD_INT 3
64735: LESS
64736: AND
64737: IFFALSE 64794
// for i in result do
64739: LD_ADDR_VAR 0 5
64743: PUSH
64744: LD_VAR 0 4
64748: PUSH
64749: FOR_IN
64750: IFFALSE 64792
// if GetTech ( i , side ) <> state then
64752: LD_VAR 0 5
64756: PPUSH
64757: LD_VAR 0 1
64761: PPUSH
64762: CALL_OW 321
64766: PUSH
64767: LD_VAR 0 3
64771: NONEQUAL
64772: IFFALSE 64790
// result := result diff i ;
64774: LD_ADDR_VAR 0 4
64778: PUSH
64779: LD_VAR 0 4
64783: PUSH
64784: LD_VAR 0 5
64788: DIFF
64789: ST_TO_ADDR
64790: GO 64749
64792: POP
64793: POP
// end ;
64794: LD_VAR 0 4
64798: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64799: LD_INT 0
64801: PPUSH
64802: PPUSH
64803: PPUSH
// result := true ;
64804: LD_ADDR_VAR 0 3
64808: PUSH
64809: LD_INT 1
64811: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64812: LD_ADDR_VAR 0 5
64816: PUSH
64817: LD_VAR 0 2
64821: PPUSH
64822: CALL_OW 480
64826: ST_TO_ADDR
// if not tmp then
64827: LD_VAR 0 5
64831: NOT
64832: IFFALSE 64836
// exit ;
64834: GO 64885
// for i in tmp do
64836: LD_ADDR_VAR 0 4
64840: PUSH
64841: LD_VAR 0 5
64845: PUSH
64846: FOR_IN
64847: IFFALSE 64883
// if GetTech ( i , side ) <> state_researched then
64849: LD_VAR 0 4
64853: PPUSH
64854: LD_VAR 0 1
64858: PPUSH
64859: CALL_OW 321
64863: PUSH
64864: LD_INT 2
64866: NONEQUAL
64867: IFFALSE 64881
// begin result := false ;
64869: LD_ADDR_VAR 0 3
64873: PUSH
64874: LD_INT 0
64876: ST_TO_ADDR
// exit ;
64877: POP
64878: POP
64879: GO 64885
// end ;
64881: GO 64846
64883: POP
64884: POP
// end ;
64885: LD_VAR 0 3
64889: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64890: LD_INT 0
64892: PPUSH
64893: PPUSH
64894: PPUSH
64895: PPUSH
64896: PPUSH
64897: PPUSH
64898: PPUSH
64899: PPUSH
64900: PPUSH
64901: PPUSH
64902: PPUSH
64903: PPUSH
64904: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64905: LD_VAR 0 1
64909: NOT
64910: PUSH
64911: LD_VAR 0 1
64915: PPUSH
64916: CALL_OW 257
64920: PUSH
64921: LD_INT 9
64923: NONEQUAL
64924: OR
64925: IFFALSE 64929
// exit ;
64927: GO 65502
// side := GetSide ( unit ) ;
64929: LD_ADDR_VAR 0 9
64933: PUSH
64934: LD_VAR 0 1
64938: PPUSH
64939: CALL_OW 255
64943: ST_TO_ADDR
// tech_space := tech_spacanom ;
64944: LD_ADDR_VAR 0 12
64948: PUSH
64949: LD_INT 29
64951: ST_TO_ADDR
// tech_time := tech_taurad ;
64952: LD_ADDR_VAR 0 13
64956: PUSH
64957: LD_INT 28
64959: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64960: LD_ADDR_VAR 0 11
64964: PUSH
64965: LD_VAR 0 1
64969: PPUSH
64970: CALL_OW 310
64974: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64975: LD_VAR 0 11
64979: PPUSH
64980: CALL_OW 247
64984: PUSH
64985: LD_INT 2
64987: EQUAL
64988: IFFALSE 64992
// exit ;
64990: GO 65502
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64992: LD_ADDR_VAR 0 8
64996: PUSH
64997: LD_INT 81
64999: PUSH
65000: LD_VAR 0 9
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PUSH
65009: LD_INT 3
65011: PUSH
65012: LD_INT 21
65014: PUSH
65015: LD_INT 3
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PUSH
65022: EMPTY
65023: LIST
65024: LIST
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PPUSH
65030: CALL_OW 69
65034: ST_TO_ADDR
// if not tmp then
65035: LD_VAR 0 8
65039: NOT
65040: IFFALSE 65044
// exit ;
65042: GO 65502
// if in_unit then
65044: LD_VAR 0 11
65048: IFFALSE 65072
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65050: LD_ADDR_VAR 0 10
65054: PUSH
65055: LD_VAR 0 8
65059: PPUSH
65060: LD_VAR 0 11
65064: PPUSH
65065: CALL_OW 74
65069: ST_TO_ADDR
65070: GO 65092
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65072: LD_ADDR_VAR 0 10
65076: PUSH
65077: LD_VAR 0 8
65081: PPUSH
65082: LD_VAR 0 1
65086: PPUSH
65087: CALL_OW 74
65091: ST_TO_ADDR
// if not enemy then
65092: LD_VAR 0 10
65096: NOT
65097: IFFALSE 65101
// exit ;
65099: GO 65502
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65101: LD_VAR 0 11
65105: PUSH
65106: LD_VAR 0 11
65110: PPUSH
65111: LD_VAR 0 10
65115: PPUSH
65116: CALL_OW 296
65120: PUSH
65121: LD_INT 13
65123: GREATER
65124: AND
65125: PUSH
65126: LD_VAR 0 1
65130: PPUSH
65131: LD_VAR 0 10
65135: PPUSH
65136: CALL_OW 296
65140: PUSH
65141: LD_INT 12
65143: GREATER
65144: OR
65145: IFFALSE 65149
// exit ;
65147: GO 65502
// missile := [ 1 ] ;
65149: LD_ADDR_VAR 0 14
65153: PUSH
65154: LD_INT 1
65156: PUSH
65157: EMPTY
65158: LIST
65159: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65160: LD_VAR 0 9
65164: PPUSH
65165: LD_VAR 0 12
65169: PPUSH
65170: CALL_OW 325
65174: IFFALSE 65203
// missile := Insert ( missile , missile + 1 , 2 ) ;
65176: LD_ADDR_VAR 0 14
65180: PUSH
65181: LD_VAR 0 14
65185: PPUSH
65186: LD_VAR 0 14
65190: PUSH
65191: LD_INT 1
65193: PLUS
65194: PPUSH
65195: LD_INT 2
65197: PPUSH
65198: CALL_OW 2
65202: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65203: LD_VAR 0 9
65207: PPUSH
65208: LD_VAR 0 13
65212: PPUSH
65213: CALL_OW 325
65217: PUSH
65218: LD_VAR 0 10
65222: PPUSH
65223: CALL_OW 255
65227: PPUSH
65228: LD_VAR 0 13
65232: PPUSH
65233: CALL_OW 325
65237: NOT
65238: AND
65239: IFFALSE 65268
// missile := Insert ( missile , missile + 1 , 3 ) ;
65241: LD_ADDR_VAR 0 14
65245: PUSH
65246: LD_VAR 0 14
65250: PPUSH
65251: LD_VAR 0 14
65255: PUSH
65256: LD_INT 1
65258: PLUS
65259: PPUSH
65260: LD_INT 3
65262: PPUSH
65263: CALL_OW 2
65267: ST_TO_ADDR
// if missile < 2 then
65268: LD_VAR 0 14
65272: PUSH
65273: LD_INT 2
65275: LESS
65276: IFFALSE 65280
// exit ;
65278: GO 65502
// x := GetX ( enemy ) ;
65280: LD_ADDR_VAR 0 4
65284: PUSH
65285: LD_VAR 0 10
65289: PPUSH
65290: CALL_OW 250
65294: ST_TO_ADDR
// y := GetY ( enemy ) ;
65295: LD_ADDR_VAR 0 5
65299: PUSH
65300: LD_VAR 0 10
65304: PPUSH
65305: CALL_OW 251
65309: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65310: LD_ADDR_VAR 0 6
65314: PUSH
65315: LD_VAR 0 4
65319: PUSH
65320: LD_INT 1
65322: NEG
65323: PPUSH
65324: LD_INT 1
65326: PPUSH
65327: CALL_OW 12
65331: PLUS
65332: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65333: LD_ADDR_VAR 0 7
65337: PUSH
65338: LD_VAR 0 5
65342: PUSH
65343: LD_INT 1
65345: NEG
65346: PPUSH
65347: LD_INT 1
65349: PPUSH
65350: CALL_OW 12
65354: PLUS
65355: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65356: LD_VAR 0 6
65360: PPUSH
65361: LD_VAR 0 7
65365: PPUSH
65366: CALL_OW 488
65370: NOT
65371: IFFALSE 65393
// begin _x := x ;
65373: LD_ADDR_VAR 0 6
65377: PUSH
65378: LD_VAR 0 4
65382: ST_TO_ADDR
// _y := y ;
65383: LD_ADDR_VAR 0 7
65387: PUSH
65388: LD_VAR 0 5
65392: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65393: LD_ADDR_VAR 0 3
65397: PUSH
65398: LD_INT 1
65400: PPUSH
65401: LD_VAR 0 14
65405: PPUSH
65406: CALL_OW 12
65410: ST_TO_ADDR
// case i of 1 :
65411: LD_VAR 0 3
65415: PUSH
65416: LD_INT 1
65418: DOUBLE
65419: EQUAL
65420: IFTRUE 65424
65422: GO 65441
65424: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65425: LD_VAR 0 1
65429: PPUSH
65430: LD_VAR 0 10
65434: PPUSH
65435: CALL_OW 115
65439: GO 65502
65441: LD_INT 2
65443: DOUBLE
65444: EQUAL
65445: IFTRUE 65449
65447: GO 65471
65449: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65450: LD_VAR 0 1
65454: PPUSH
65455: LD_VAR 0 6
65459: PPUSH
65460: LD_VAR 0 7
65464: PPUSH
65465: CALL_OW 153
65469: GO 65502
65471: LD_INT 3
65473: DOUBLE
65474: EQUAL
65475: IFTRUE 65479
65477: GO 65501
65479: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65480: LD_VAR 0 1
65484: PPUSH
65485: LD_VAR 0 6
65489: PPUSH
65490: LD_VAR 0 7
65494: PPUSH
65495: CALL_OW 154
65499: GO 65502
65501: POP
// end ;
65502: LD_VAR 0 2
65506: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65507: LD_INT 0
65509: PPUSH
65510: PPUSH
65511: PPUSH
65512: PPUSH
65513: PPUSH
65514: PPUSH
// if not unit or not building then
65515: LD_VAR 0 1
65519: NOT
65520: PUSH
65521: LD_VAR 0 2
65525: NOT
65526: OR
65527: IFFALSE 65531
// exit ;
65529: GO 65689
// x := GetX ( building ) ;
65531: LD_ADDR_VAR 0 5
65535: PUSH
65536: LD_VAR 0 2
65540: PPUSH
65541: CALL_OW 250
65545: ST_TO_ADDR
// y := GetY ( building ) ;
65546: LD_ADDR_VAR 0 6
65550: PUSH
65551: LD_VAR 0 2
65555: PPUSH
65556: CALL_OW 251
65560: ST_TO_ADDR
// for i = 0 to 5 do
65561: LD_ADDR_VAR 0 4
65565: PUSH
65566: DOUBLE
65567: LD_INT 0
65569: DEC
65570: ST_TO_ADDR
65571: LD_INT 5
65573: PUSH
65574: FOR_TO
65575: IFFALSE 65687
// begin _x := ShiftX ( x , i , 3 ) ;
65577: LD_ADDR_VAR 0 7
65581: PUSH
65582: LD_VAR 0 5
65586: PPUSH
65587: LD_VAR 0 4
65591: PPUSH
65592: LD_INT 3
65594: PPUSH
65595: CALL_OW 272
65599: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65600: LD_ADDR_VAR 0 8
65604: PUSH
65605: LD_VAR 0 6
65609: PPUSH
65610: LD_VAR 0 4
65614: PPUSH
65615: LD_INT 3
65617: PPUSH
65618: CALL_OW 273
65622: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65623: LD_VAR 0 7
65627: PPUSH
65628: LD_VAR 0 8
65632: PPUSH
65633: CALL_OW 488
65637: NOT
65638: IFFALSE 65642
// continue ;
65640: GO 65574
// if HexInfo ( _x , _y ) = 0 then
65642: LD_VAR 0 7
65646: PPUSH
65647: LD_VAR 0 8
65651: PPUSH
65652: CALL_OW 428
65656: PUSH
65657: LD_INT 0
65659: EQUAL
65660: IFFALSE 65685
// begin ComMoveXY ( unit , _x , _y ) ;
65662: LD_VAR 0 1
65666: PPUSH
65667: LD_VAR 0 7
65671: PPUSH
65672: LD_VAR 0 8
65676: PPUSH
65677: CALL_OW 111
// exit ;
65681: POP
65682: POP
65683: GO 65689
// end ; end ;
65685: GO 65574
65687: POP
65688: POP
// end ;
65689: LD_VAR 0 3
65693: RET
// export function ScanBase ( side , base_area ) ; begin
65694: LD_INT 0
65696: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65697: LD_ADDR_VAR 0 3
65701: PUSH
65702: LD_VAR 0 2
65706: PPUSH
65707: LD_INT 81
65709: PUSH
65710: LD_VAR 0 1
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PPUSH
65719: CALL_OW 70
65723: ST_TO_ADDR
// end ;
65724: LD_VAR 0 3
65728: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65729: LD_INT 0
65731: PPUSH
65732: PPUSH
65733: PPUSH
65734: PPUSH
65735: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65736: LD_VAR 0 1
65740: NOT
65741: PUSH
65742: LD_EXP 99
65746: PUSH
65747: LD_VAR 0 1
65751: ARRAY
65752: NOT
65753: OR
65754: PUSH
65755: LD_VAR 0 2
65759: NOT
65760: OR
65761: PUSH
65762: LD_VAR 0 3
65766: NOT
65767: OR
65768: IFFALSE 65772
// exit ;
65770: GO 66285
// side := mc_sides [ base ] ;
65772: LD_ADDR_VAR 0 6
65776: PUSH
65777: LD_EXP 125
65781: PUSH
65782: LD_VAR 0 1
65786: ARRAY
65787: ST_TO_ADDR
// if not side then
65788: LD_VAR 0 6
65792: NOT
65793: IFFALSE 65797
// exit ;
65795: GO 66285
// for i in solds do
65797: LD_ADDR_VAR 0 7
65801: PUSH
65802: LD_VAR 0 2
65806: PUSH
65807: FOR_IN
65808: IFFALSE 65869
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65810: LD_VAR 0 7
65814: PPUSH
65815: CALL_OW 310
65819: PPUSH
65820: CALL_OW 266
65824: PUSH
65825: LD_INT 32
65827: PUSH
65828: LD_INT 31
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: IN
65835: IFFALSE 65855
// solds := solds diff i else
65837: LD_ADDR_VAR 0 2
65841: PUSH
65842: LD_VAR 0 2
65846: PUSH
65847: LD_VAR 0 7
65851: DIFF
65852: ST_TO_ADDR
65853: GO 65867
// SetTag ( i , 18 ) ;
65855: LD_VAR 0 7
65859: PPUSH
65860: LD_INT 18
65862: PPUSH
65863: CALL_OW 109
65867: GO 65807
65869: POP
65870: POP
// if not solds then
65871: LD_VAR 0 2
65875: NOT
65876: IFFALSE 65880
// exit ;
65878: GO 66285
// repeat wait ( 0 0$1 ) ;
65880: LD_INT 35
65882: PPUSH
65883: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65887: LD_ADDR_VAR 0 5
65891: PUSH
65892: LD_VAR 0 6
65896: PPUSH
65897: LD_VAR 0 3
65901: PPUSH
65902: CALL 65694 0 2
65906: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
65907: LD_EXP 99
65911: PUSH
65912: LD_VAR 0 1
65916: ARRAY
65917: NOT
65918: PUSH
65919: LD_EXP 99
65923: PUSH
65924: LD_VAR 0 1
65928: ARRAY
65929: PUSH
65930: EMPTY
65931: EQUAL
65932: OR
65933: IFFALSE 65970
// begin for i in solds do
65935: LD_ADDR_VAR 0 7
65939: PUSH
65940: LD_VAR 0 2
65944: PUSH
65945: FOR_IN
65946: IFFALSE 65959
// ComStop ( i ) ;
65948: LD_VAR 0 7
65952: PPUSH
65953: CALL_OW 141
65957: GO 65945
65959: POP
65960: POP
// solds := [ ] ;
65961: LD_ADDR_VAR 0 2
65965: PUSH
65966: EMPTY
65967: ST_TO_ADDR
// exit ;
65968: GO 66285
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
65970: LD_VAR 0 5
65974: NOT
65975: PUSH
65976: LD_VAR 0 5
65980: PUSH
65981: LD_INT 3
65983: GREATER
65984: OR
65985: PUSH
65986: LD_EXP 121
65990: PUSH
65991: LD_VAR 0 1
65995: ARRAY
65996: OR
65997: IFFALSE 66038
// begin for i in solds do
65999: LD_ADDR_VAR 0 7
66003: PUSH
66004: LD_VAR 0 2
66008: PUSH
66009: FOR_IN
66010: IFFALSE 66034
// if HasTask ( i ) then
66012: LD_VAR 0 7
66016: PPUSH
66017: CALL_OW 314
66021: IFFALSE 66032
// ComStop ( i ) ;
66023: LD_VAR 0 7
66027: PPUSH
66028: CALL_OW 141
66032: GO 66009
66034: POP
66035: POP
// break ;
66036: GO 66273
// end ; for i in solds do
66038: LD_ADDR_VAR 0 7
66042: PUSH
66043: LD_VAR 0 2
66047: PUSH
66048: FOR_IN
66049: IFFALSE 66265
// begin if IsInUnit ( i ) then
66051: LD_VAR 0 7
66055: PPUSH
66056: CALL_OW 310
66060: IFFALSE 66071
// ComExitBuilding ( i ) ;
66062: LD_VAR 0 7
66066: PPUSH
66067: CALL_OW 122
// if GetLives ( i ) > 333 then
66071: LD_VAR 0 7
66075: PPUSH
66076: CALL_OW 256
66080: PUSH
66081: LD_INT 333
66083: GREATER
66084: IFFALSE 66112
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66086: LD_VAR 0 7
66090: PPUSH
66091: LD_VAR 0 5
66095: PPUSH
66096: LD_VAR 0 7
66100: PPUSH
66101: CALL_OW 74
66105: PPUSH
66106: CALL_OW 115
66110: GO 66263
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66112: LD_ADDR_VAR 0 8
66116: PUSH
66117: LD_EXP 99
66121: PUSH
66122: LD_VAR 0 1
66126: ARRAY
66127: PPUSH
66128: LD_INT 2
66130: PUSH
66131: LD_INT 30
66133: PUSH
66134: LD_INT 0
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 30
66143: PUSH
66144: LD_INT 1
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: LD_INT 30
66153: PUSH
66154: LD_INT 6
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: PPUSH
66167: CALL_OW 72
66171: PPUSH
66172: LD_VAR 0 7
66176: PPUSH
66177: CALL_OW 74
66181: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66182: LD_VAR 0 7
66186: PPUSH
66187: LD_VAR 0 8
66191: PPUSH
66192: CALL_OW 250
66196: PPUSH
66197: LD_INT 3
66199: PPUSH
66200: LD_INT 5
66202: PPUSH
66203: CALL_OW 272
66207: PPUSH
66208: LD_VAR 0 8
66212: PPUSH
66213: CALL_OW 251
66217: PPUSH
66218: LD_INT 3
66220: PPUSH
66221: LD_INT 5
66223: PPUSH
66224: CALL_OW 273
66228: PPUSH
66229: CALL_OW 111
// SetTag ( i , 0 ) ;
66233: LD_VAR 0 7
66237: PPUSH
66238: LD_INT 0
66240: PPUSH
66241: CALL_OW 109
// solds := solds diff i ;
66245: LD_ADDR_VAR 0 2
66249: PUSH
66250: LD_VAR 0 2
66254: PUSH
66255: LD_VAR 0 7
66259: DIFF
66260: ST_TO_ADDR
// continue ;
66261: GO 66048
// end ; end ;
66263: GO 66048
66265: POP
66266: POP
// until solds ;
66267: LD_VAR 0 2
66271: IFFALSE 65880
// MC_Reset ( base , 18 ) ;
66273: LD_VAR 0 1
66277: PPUSH
66278: LD_INT 18
66280: PPUSH
66281: CALL 38002 0 2
// end ;
66285: LD_VAR 0 4
66289: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66290: LD_INT 0
66292: PPUSH
66293: PPUSH
66294: PPUSH
66295: PPUSH
66296: PPUSH
66297: PPUSH
66298: PPUSH
66299: PPUSH
66300: PPUSH
66301: PPUSH
66302: PPUSH
66303: PPUSH
66304: PPUSH
66305: PPUSH
66306: PPUSH
66307: PPUSH
66308: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66309: LD_ADDR_VAR 0 13
66313: PUSH
66314: LD_EXP 99
66318: PUSH
66319: LD_VAR 0 1
66323: ARRAY
66324: PPUSH
66325: LD_INT 25
66327: PUSH
66328: LD_INT 3
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PPUSH
66335: CALL_OW 72
66339: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66340: LD_EXP 139
66344: PUSH
66345: LD_VAR 0 1
66349: ARRAY
66350: IFFALSE 66374
// mechs := mechs diff mc_remote_driver [ base ] ;
66352: LD_ADDR_VAR 0 13
66356: PUSH
66357: LD_VAR 0 13
66361: PUSH
66362: LD_EXP 139
66366: PUSH
66367: LD_VAR 0 1
66371: ARRAY
66372: DIFF
66373: ST_TO_ADDR
// for i in mechs do
66374: LD_ADDR_VAR 0 5
66378: PUSH
66379: LD_VAR 0 13
66383: PUSH
66384: FOR_IN
66385: IFFALSE 66420
// if GetTag ( i ) > 0 then
66387: LD_VAR 0 5
66391: PPUSH
66392: CALL_OW 110
66396: PUSH
66397: LD_INT 0
66399: GREATER
66400: IFFALSE 66418
// mechs := mechs diff i ;
66402: LD_ADDR_VAR 0 13
66406: PUSH
66407: LD_VAR 0 13
66411: PUSH
66412: LD_VAR 0 5
66416: DIFF
66417: ST_TO_ADDR
66418: GO 66384
66420: POP
66421: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66422: LD_ADDR_VAR 0 9
66426: PUSH
66427: LD_EXP 99
66431: PUSH
66432: LD_VAR 0 1
66436: ARRAY
66437: PPUSH
66438: LD_INT 2
66440: PUSH
66441: LD_INT 25
66443: PUSH
66444: LD_INT 1
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PUSH
66451: LD_INT 25
66453: PUSH
66454: LD_INT 5
66456: PUSH
66457: EMPTY
66458: LIST
66459: LIST
66460: PUSH
66461: LD_INT 25
66463: PUSH
66464: LD_INT 8
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 25
66473: PUSH
66474: LD_INT 9
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: PPUSH
66488: CALL_OW 72
66492: ST_TO_ADDR
// if not defenders and not solds then
66493: LD_VAR 0 2
66497: NOT
66498: PUSH
66499: LD_VAR 0 9
66503: NOT
66504: AND
66505: IFFALSE 66509
// exit ;
66507: GO 68135
// depot_under_attack := false ;
66509: LD_ADDR_VAR 0 17
66513: PUSH
66514: LD_INT 0
66516: ST_TO_ADDR
// sold_defenders := [ ] ;
66517: LD_ADDR_VAR 0 18
66521: PUSH
66522: EMPTY
66523: ST_TO_ADDR
// if mechs then
66524: LD_VAR 0 13
66528: IFFALSE 66657
// for i in defenders do
66530: LD_ADDR_VAR 0 5
66534: PUSH
66535: LD_VAR 0 2
66539: PUSH
66540: FOR_IN
66541: IFFALSE 66655
// begin SetTag ( i , 20 ) ;
66543: LD_VAR 0 5
66547: PPUSH
66548: LD_INT 20
66550: PPUSH
66551: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66555: LD_VAR 0 5
66559: PPUSH
66560: CALL_OW 263
66564: PUSH
66565: LD_INT 1
66567: EQUAL
66568: PUSH
66569: LD_VAR 0 5
66573: PPUSH
66574: CALL_OW 311
66578: NOT
66579: AND
66580: PUSH
66581: LD_VAR 0 13
66585: AND
66586: IFFALSE 66653
// begin un := mechs [ 1 ] ;
66588: LD_ADDR_VAR 0 11
66592: PUSH
66593: LD_VAR 0 13
66597: PUSH
66598: LD_INT 1
66600: ARRAY
66601: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66602: LD_VAR 0 11
66606: PPUSH
66607: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66611: LD_VAR 0 11
66615: PPUSH
66616: LD_VAR 0 5
66620: PPUSH
66621: CALL_OW 180
// SetTag ( un , 19 ) ;
66625: LD_VAR 0 11
66629: PPUSH
66630: LD_INT 19
66632: PPUSH
66633: CALL_OW 109
// mechs := mechs diff un ;
66637: LD_ADDR_VAR 0 13
66641: PUSH
66642: LD_VAR 0 13
66646: PUSH
66647: LD_VAR 0 11
66651: DIFF
66652: ST_TO_ADDR
// end ; end ;
66653: GO 66540
66655: POP
66656: POP
// if solds then
66657: LD_VAR 0 9
66661: IFFALSE 66720
// for i in solds do
66663: LD_ADDR_VAR 0 5
66667: PUSH
66668: LD_VAR 0 9
66672: PUSH
66673: FOR_IN
66674: IFFALSE 66718
// if not GetTag ( i ) then
66676: LD_VAR 0 5
66680: PPUSH
66681: CALL_OW 110
66685: NOT
66686: IFFALSE 66716
// begin defenders := defenders union i ;
66688: LD_ADDR_VAR 0 2
66692: PUSH
66693: LD_VAR 0 2
66697: PUSH
66698: LD_VAR 0 5
66702: UNION
66703: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66704: LD_VAR 0 5
66708: PPUSH
66709: LD_INT 18
66711: PPUSH
66712: CALL_OW 109
// end ;
66716: GO 66673
66718: POP
66719: POP
// repeat wait ( 0 0$1 ) ;
66720: LD_INT 35
66722: PPUSH
66723: CALL_OW 67
// enemy := mc_scan [ base ] ;
66727: LD_ADDR_VAR 0 3
66731: PUSH
66732: LD_EXP 122
66736: PUSH
66737: LD_VAR 0 1
66741: ARRAY
66742: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66743: LD_EXP 99
66747: PUSH
66748: LD_VAR 0 1
66752: ARRAY
66753: NOT
66754: PUSH
66755: LD_EXP 99
66759: PUSH
66760: LD_VAR 0 1
66764: ARRAY
66765: PUSH
66766: EMPTY
66767: EQUAL
66768: OR
66769: IFFALSE 66806
// begin for i in defenders do
66771: LD_ADDR_VAR 0 5
66775: PUSH
66776: LD_VAR 0 2
66780: PUSH
66781: FOR_IN
66782: IFFALSE 66795
// ComStop ( i ) ;
66784: LD_VAR 0 5
66788: PPUSH
66789: CALL_OW 141
66793: GO 66781
66795: POP
66796: POP
// defenders := [ ] ;
66797: LD_ADDR_VAR 0 2
66801: PUSH
66802: EMPTY
66803: ST_TO_ADDR
// exit ;
66804: GO 68135
// end ; for i in defenders do
66806: LD_ADDR_VAR 0 5
66810: PUSH
66811: LD_VAR 0 2
66815: PUSH
66816: FOR_IN
66817: IFFALSE 67635
// begin e := NearestUnitToUnit ( enemy , i ) ;
66819: LD_ADDR_VAR 0 14
66823: PUSH
66824: LD_VAR 0 3
66828: PPUSH
66829: LD_VAR 0 5
66833: PPUSH
66834: CALL_OW 74
66838: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66839: LD_ADDR_VAR 0 8
66843: PUSH
66844: LD_EXP 99
66848: PUSH
66849: LD_VAR 0 1
66853: ARRAY
66854: PPUSH
66855: LD_INT 2
66857: PUSH
66858: LD_INT 30
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 30
66870: PUSH
66871: LD_INT 1
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: LIST
66882: PPUSH
66883: CALL_OW 72
66887: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
66888: LD_ADDR_VAR 0 17
66892: PUSH
66893: LD_VAR 0 8
66897: NOT
66898: PUSH
66899: LD_VAR 0 8
66903: PPUSH
66904: LD_INT 3
66906: PUSH
66907: LD_INT 24
66909: PUSH
66910: LD_INT 600
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: PPUSH
66921: CALL_OW 72
66925: OR
66926: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66927: LD_VAR 0 5
66931: PPUSH
66932: CALL_OW 247
66936: PUSH
66937: LD_INT 2
66939: DOUBLE
66940: EQUAL
66941: IFTRUE 66945
66943: GO 67341
66945: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66946: LD_VAR 0 5
66950: PPUSH
66951: CALL_OW 256
66955: PUSH
66956: LD_INT 650
66958: GREATER
66959: PUSH
66960: LD_VAR 0 5
66964: PPUSH
66965: LD_VAR 0 14
66969: PPUSH
66970: CALL_OW 296
66974: PUSH
66975: LD_INT 40
66977: LESS
66978: PUSH
66979: LD_VAR 0 14
66983: PPUSH
66984: LD_EXP 124
66988: PUSH
66989: LD_VAR 0 1
66993: ARRAY
66994: PPUSH
66995: CALL_OW 308
66999: OR
67000: AND
67001: IFFALSE 67123
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67003: LD_VAR 0 5
67007: PPUSH
67008: CALL_OW 262
67012: PUSH
67013: LD_INT 1
67015: EQUAL
67016: PUSH
67017: LD_VAR 0 5
67021: PPUSH
67022: CALL_OW 261
67026: PUSH
67027: LD_INT 30
67029: LESS
67030: AND
67031: PUSH
67032: LD_VAR 0 8
67036: AND
67037: IFFALSE 67107
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67039: LD_VAR 0 5
67043: PPUSH
67044: LD_VAR 0 8
67048: PPUSH
67049: LD_VAR 0 5
67053: PPUSH
67054: CALL_OW 74
67058: PPUSH
67059: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67063: LD_VAR 0 5
67067: PPUSH
67068: LD_VAR 0 8
67072: PPUSH
67073: LD_VAR 0 5
67077: PPUSH
67078: CALL_OW 74
67082: PPUSH
67083: CALL_OW 296
67087: PUSH
67088: LD_INT 6
67090: LESS
67091: IFFALSE 67105
// SetFuel ( i , 100 ) ;
67093: LD_VAR 0 5
67097: PPUSH
67098: LD_INT 100
67100: PPUSH
67101: CALL_OW 240
// end else
67105: GO 67121
// ComAttackUnit ( i , e ) ;
67107: LD_VAR 0 5
67111: PPUSH
67112: LD_VAR 0 14
67116: PPUSH
67117: CALL_OW 115
// end else
67121: GO 67224
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67123: LD_VAR 0 14
67127: PPUSH
67128: LD_EXP 124
67132: PUSH
67133: LD_VAR 0 1
67137: ARRAY
67138: PPUSH
67139: CALL_OW 308
67143: NOT
67144: PUSH
67145: LD_VAR 0 5
67149: PPUSH
67150: LD_VAR 0 14
67154: PPUSH
67155: CALL_OW 296
67159: PUSH
67160: LD_INT 40
67162: GREATEREQUAL
67163: AND
67164: PUSH
67165: LD_VAR 0 5
67169: PPUSH
67170: CALL_OW 256
67174: PUSH
67175: LD_INT 650
67177: LESSEQUAL
67178: OR
67179: PUSH
67180: LD_VAR 0 5
67184: PPUSH
67185: LD_EXP 123
67189: PUSH
67190: LD_VAR 0 1
67194: ARRAY
67195: PPUSH
67196: CALL_OW 308
67200: NOT
67201: AND
67202: IFFALSE 67224
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67204: LD_VAR 0 5
67208: PPUSH
67209: LD_EXP 123
67213: PUSH
67214: LD_VAR 0 1
67218: ARRAY
67219: PPUSH
67220: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67224: LD_VAR 0 5
67228: PPUSH
67229: CALL_OW 256
67233: PUSH
67234: LD_INT 998
67236: LESS
67237: PUSH
67238: LD_VAR 0 5
67242: PPUSH
67243: CALL_OW 263
67247: PUSH
67248: LD_INT 1
67250: EQUAL
67251: AND
67252: PUSH
67253: LD_VAR 0 5
67257: PPUSH
67258: CALL_OW 311
67262: AND
67263: PUSH
67264: LD_VAR 0 5
67268: PPUSH
67269: LD_EXP 123
67273: PUSH
67274: LD_VAR 0 1
67278: ARRAY
67279: PPUSH
67280: CALL_OW 308
67284: AND
67285: IFFALSE 67339
// begin mech := IsDrivenBy ( i ) ;
67287: LD_ADDR_VAR 0 10
67291: PUSH
67292: LD_VAR 0 5
67296: PPUSH
67297: CALL_OW 311
67301: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67302: LD_VAR 0 10
67306: PPUSH
67307: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67311: LD_VAR 0 10
67315: PPUSH
67316: LD_VAR 0 5
67320: PPUSH
67321: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67325: LD_VAR 0 10
67329: PPUSH
67330: LD_VAR 0 5
67334: PPUSH
67335: CALL_OW 180
// end ; end ; unit_human :
67339: GO 67606
67341: LD_INT 1
67343: DOUBLE
67344: EQUAL
67345: IFTRUE 67349
67347: GO 67605
67349: POP
// begin b := IsInUnit ( i ) ;
67350: LD_ADDR_VAR 0 19
67354: PUSH
67355: LD_VAR 0 5
67359: PPUSH
67360: CALL_OW 310
67364: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67365: LD_ADDR_VAR 0 20
67369: PUSH
67370: LD_VAR 0 19
67374: NOT
67375: PUSH
67376: LD_VAR 0 19
67380: PPUSH
67381: CALL_OW 266
67385: PUSH
67386: LD_INT 32
67388: PUSH
67389: LD_INT 31
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: IN
67396: OR
67397: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67398: LD_VAR 0 17
67402: PUSH
67403: LD_VAR 0 2
67407: PPUSH
67408: LD_INT 21
67410: PUSH
67411: LD_INT 2
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PPUSH
67418: CALL_OW 72
67422: PUSH
67423: LD_INT 1
67425: LESSEQUAL
67426: OR
67427: PUSH
67428: LD_VAR 0 20
67432: AND
67433: PUSH
67434: LD_VAR 0 5
67438: PUSH
67439: LD_VAR 0 18
67443: IN
67444: NOT
67445: AND
67446: IFFALSE 67539
// begin if b then
67448: LD_VAR 0 19
67452: IFFALSE 67501
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67454: LD_VAR 0 19
67458: PPUSH
67459: LD_VAR 0 3
67463: PPUSH
67464: LD_VAR 0 19
67468: PPUSH
67469: CALL_OW 74
67473: PPUSH
67474: CALL_OW 296
67478: PUSH
67479: LD_INT 10
67481: LESS
67482: PUSH
67483: LD_VAR 0 19
67487: PPUSH
67488: CALL_OW 461
67492: PUSH
67493: LD_INT 7
67495: NONEQUAL
67496: AND
67497: IFFALSE 67501
// continue ;
67499: GO 66816
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67501: LD_ADDR_VAR 0 18
67505: PUSH
67506: LD_VAR 0 18
67510: PPUSH
67511: LD_VAR 0 18
67515: PUSH
67516: LD_INT 1
67518: PLUS
67519: PPUSH
67520: LD_VAR 0 5
67524: PPUSH
67525: CALL_OW 1
67529: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67530: LD_VAR 0 5
67534: PPUSH
67535: CALL_OW 122
// end ; if sold_defenders then
67539: LD_VAR 0 18
67543: IFFALSE 67603
// if i in sold_defenders then
67545: LD_VAR 0 5
67549: PUSH
67550: LD_VAR 0 18
67554: IN
67555: IFFALSE 67603
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67557: LD_VAR 0 5
67561: PPUSH
67562: CALL_OW 314
67566: NOT
67567: PUSH
67568: LD_VAR 0 5
67572: PPUSH
67573: LD_VAR 0 14
67577: PPUSH
67578: CALL_OW 296
67582: PUSH
67583: LD_INT 30
67585: LESS
67586: AND
67587: IFFALSE 67603
// ComAttackUnit ( i , e ) ;
67589: LD_VAR 0 5
67593: PPUSH
67594: LD_VAR 0 14
67598: PPUSH
67599: CALL_OW 115
// end ; end ; end ;
67603: GO 67606
67605: POP
// if IsDead ( i ) then
67606: LD_VAR 0 5
67610: PPUSH
67611: CALL_OW 301
67615: IFFALSE 67633
// defenders := defenders diff i ;
67617: LD_ADDR_VAR 0 2
67621: PUSH
67622: LD_VAR 0 2
67626: PUSH
67627: LD_VAR 0 5
67631: DIFF
67632: ST_TO_ADDR
// end ;
67633: GO 66816
67635: POP
67636: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67637: LD_VAR 0 3
67641: NOT
67642: PUSH
67643: LD_VAR 0 2
67647: NOT
67648: OR
67649: PUSH
67650: LD_EXP 99
67654: PUSH
67655: LD_VAR 0 1
67659: ARRAY
67660: NOT
67661: OR
67662: IFFALSE 66720
// MC_Reset ( base , 18 ) ;
67664: LD_VAR 0 1
67668: PPUSH
67669: LD_INT 18
67671: PPUSH
67672: CALL 38002 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67676: LD_ADDR_VAR 0 2
67680: PUSH
67681: LD_VAR 0 2
67685: PUSH
67686: LD_VAR 0 2
67690: PPUSH
67691: LD_INT 2
67693: PUSH
67694: LD_INT 25
67696: PUSH
67697: LD_INT 1
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PUSH
67704: LD_INT 25
67706: PUSH
67707: LD_INT 5
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 25
67716: PUSH
67717: LD_INT 8
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 25
67726: PUSH
67727: LD_INT 9
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: EMPTY
67735: LIST
67736: LIST
67737: LIST
67738: LIST
67739: LIST
67740: PPUSH
67741: CALL_OW 72
67745: DIFF
67746: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67747: LD_VAR 0 3
67751: NOT
67752: PUSH
67753: LD_VAR 0 2
67757: PPUSH
67758: LD_INT 21
67760: PUSH
67761: LD_INT 2
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PPUSH
67768: CALL_OW 72
67772: AND
67773: IFFALSE 68111
// begin tmp := FilterByTag ( defenders , 19 ) ;
67775: LD_ADDR_VAR 0 12
67779: PUSH
67780: LD_VAR 0 2
67784: PPUSH
67785: LD_INT 19
67787: PPUSH
67788: CALL 104564 0 2
67792: ST_TO_ADDR
// if tmp then
67793: LD_VAR 0 12
67797: IFFALSE 67867
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67799: LD_ADDR_VAR 0 12
67803: PUSH
67804: LD_VAR 0 12
67808: PPUSH
67809: LD_INT 25
67811: PUSH
67812: LD_INT 3
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PPUSH
67819: CALL_OW 72
67823: ST_TO_ADDR
// if tmp then
67824: LD_VAR 0 12
67828: IFFALSE 67867
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67830: LD_ADDR_EXP 111
67834: PUSH
67835: LD_EXP 111
67839: PPUSH
67840: LD_VAR 0 1
67844: PPUSH
67845: LD_EXP 111
67849: PUSH
67850: LD_VAR 0 1
67854: ARRAY
67855: PUSH
67856: LD_VAR 0 12
67860: UNION
67861: PPUSH
67862: CALL_OW 1
67866: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67867: LD_VAR 0 1
67871: PPUSH
67872: LD_INT 19
67874: PPUSH
67875: CALL 38002 0 2
// repeat wait ( 0 0$1 ) ;
67879: LD_INT 35
67881: PPUSH
67882: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67886: LD_EXP 99
67890: PUSH
67891: LD_VAR 0 1
67895: ARRAY
67896: NOT
67897: PUSH
67898: LD_EXP 99
67902: PUSH
67903: LD_VAR 0 1
67907: ARRAY
67908: PUSH
67909: EMPTY
67910: EQUAL
67911: OR
67912: IFFALSE 67949
// begin for i in defenders do
67914: LD_ADDR_VAR 0 5
67918: PUSH
67919: LD_VAR 0 2
67923: PUSH
67924: FOR_IN
67925: IFFALSE 67938
// ComStop ( i ) ;
67927: LD_VAR 0 5
67931: PPUSH
67932: CALL_OW 141
67936: GO 67924
67938: POP
67939: POP
// defenders := [ ] ;
67940: LD_ADDR_VAR 0 2
67944: PUSH
67945: EMPTY
67946: ST_TO_ADDR
// exit ;
67947: GO 68135
// end ; for i in defenders do
67949: LD_ADDR_VAR 0 5
67953: PUSH
67954: LD_VAR 0 2
67958: PUSH
67959: FOR_IN
67960: IFFALSE 68049
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67962: LD_VAR 0 5
67966: PPUSH
67967: LD_EXP 123
67971: PUSH
67972: LD_VAR 0 1
67976: ARRAY
67977: PPUSH
67978: CALL_OW 308
67982: NOT
67983: IFFALSE 68007
// ComMoveToArea ( i , mc_parking [ base ] ) else
67985: LD_VAR 0 5
67989: PPUSH
67990: LD_EXP 123
67994: PUSH
67995: LD_VAR 0 1
67999: ARRAY
68000: PPUSH
68001: CALL_OW 113
68005: GO 68047
// if GetControl ( i ) = control_manual then
68007: LD_VAR 0 5
68011: PPUSH
68012: CALL_OW 263
68016: PUSH
68017: LD_INT 1
68019: EQUAL
68020: IFFALSE 68047
// if IsDrivenBy ( i ) then
68022: LD_VAR 0 5
68026: PPUSH
68027: CALL_OW 311
68031: IFFALSE 68047
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68033: LD_VAR 0 5
68037: PPUSH
68038: CALL_OW 311
68042: PPUSH
68043: CALL_OW 121
// end ;
68047: GO 67959
68049: POP
68050: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68051: LD_VAR 0 2
68055: PPUSH
68056: LD_INT 95
68058: PUSH
68059: LD_EXP 123
68063: PUSH
68064: LD_VAR 0 1
68068: ARRAY
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PPUSH
68074: CALL_OW 72
68078: PUSH
68079: LD_VAR 0 2
68083: EQUAL
68084: PUSH
68085: LD_EXP 122
68089: PUSH
68090: LD_VAR 0 1
68094: ARRAY
68095: OR
68096: PUSH
68097: LD_EXP 99
68101: PUSH
68102: LD_VAR 0 1
68106: ARRAY
68107: NOT
68108: OR
68109: IFFALSE 67879
// end ; MC_Reset ( base , 19 ) ;
68111: LD_VAR 0 1
68115: PPUSH
68116: LD_INT 19
68118: PPUSH
68119: CALL 38002 0 2
// MC_Reset ( base , 20 ) ;
68123: LD_VAR 0 1
68127: PPUSH
68128: LD_INT 20
68130: PPUSH
68131: CALL 38002 0 2
// end ;
68135: LD_VAR 0 4
68139: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68140: LD_INT 0
68142: PPUSH
68143: PPUSH
68144: PPUSH
68145: PPUSH
// result := false ;
68146: LD_ADDR_VAR 0 2
68150: PUSH
68151: LD_INT 0
68153: ST_TO_ADDR
// side := GetSide ( unit ) ;
68154: LD_ADDR_VAR 0 3
68158: PUSH
68159: LD_VAR 0 1
68163: PPUSH
68164: CALL_OW 255
68168: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68169: LD_ADDR_VAR 0 4
68173: PUSH
68174: LD_VAR 0 1
68178: PPUSH
68179: CALL_OW 248
68183: ST_TO_ADDR
// case nat of 1 :
68184: LD_VAR 0 4
68188: PUSH
68189: LD_INT 1
68191: DOUBLE
68192: EQUAL
68193: IFTRUE 68197
68195: GO 68208
68197: POP
// tech := tech_lassight ; 2 :
68198: LD_ADDR_VAR 0 5
68202: PUSH
68203: LD_INT 12
68205: ST_TO_ADDR
68206: GO 68247
68208: LD_INT 2
68210: DOUBLE
68211: EQUAL
68212: IFTRUE 68216
68214: GO 68227
68216: POP
// tech := tech_mortar ; 3 :
68217: LD_ADDR_VAR 0 5
68221: PUSH
68222: LD_INT 41
68224: ST_TO_ADDR
68225: GO 68247
68227: LD_INT 3
68229: DOUBLE
68230: EQUAL
68231: IFTRUE 68235
68233: GO 68246
68235: POP
// tech := tech_bazooka ; end ;
68236: LD_ADDR_VAR 0 5
68240: PUSH
68241: LD_INT 44
68243: ST_TO_ADDR
68244: GO 68247
68246: POP
// if Researched ( side , tech ) then
68247: LD_VAR 0 3
68251: PPUSH
68252: LD_VAR 0 5
68256: PPUSH
68257: CALL_OW 325
68261: IFFALSE 68288
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68263: LD_ADDR_VAR 0 2
68267: PUSH
68268: LD_INT 5
68270: PUSH
68271: LD_INT 8
68273: PUSH
68274: LD_INT 9
68276: PUSH
68277: EMPTY
68278: LIST
68279: LIST
68280: LIST
68281: PUSH
68282: LD_VAR 0 4
68286: ARRAY
68287: ST_TO_ADDR
// end ;
68288: LD_VAR 0 2
68292: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68293: LD_INT 0
68295: PPUSH
68296: PPUSH
68297: PPUSH
// if not mines then
68298: LD_VAR 0 2
68302: NOT
68303: IFFALSE 68307
// exit ;
68305: GO 68451
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68307: LD_ADDR_VAR 0 5
68311: PUSH
68312: LD_INT 81
68314: PUSH
68315: LD_VAR 0 1
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: PUSH
68324: LD_INT 3
68326: PUSH
68327: LD_INT 21
68329: PUSH
68330: LD_INT 3
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PPUSH
68345: CALL_OW 69
68349: ST_TO_ADDR
// for i in mines do
68350: LD_ADDR_VAR 0 4
68354: PUSH
68355: LD_VAR 0 2
68359: PUSH
68360: FOR_IN
68361: IFFALSE 68449
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68363: LD_VAR 0 4
68367: PUSH
68368: LD_INT 1
68370: ARRAY
68371: PPUSH
68372: LD_VAR 0 4
68376: PUSH
68377: LD_INT 2
68379: ARRAY
68380: PPUSH
68381: CALL_OW 458
68385: NOT
68386: IFFALSE 68390
// continue ;
68388: GO 68360
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68390: LD_VAR 0 4
68394: PUSH
68395: LD_INT 1
68397: ARRAY
68398: PPUSH
68399: LD_VAR 0 4
68403: PUSH
68404: LD_INT 2
68406: ARRAY
68407: PPUSH
68408: CALL_OW 428
68412: PUSH
68413: LD_VAR 0 5
68417: IN
68418: IFFALSE 68447
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68420: LD_VAR 0 4
68424: PUSH
68425: LD_INT 1
68427: ARRAY
68428: PPUSH
68429: LD_VAR 0 4
68433: PUSH
68434: LD_INT 2
68436: ARRAY
68437: PPUSH
68438: LD_VAR 0 1
68442: PPUSH
68443: CALL_OW 456
// end ;
68447: GO 68360
68449: POP
68450: POP
// end ;
68451: LD_VAR 0 3
68455: RET
// export function Count ( array ) ; var i ; begin
68456: LD_INT 0
68458: PPUSH
68459: PPUSH
// result := 0 ;
68460: LD_ADDR_VAR 0 2
68464: PUSH
68465: LD_INT 0
68467: ST_TO_ADDR
// for i in array do
68468: LD_ADDR_VAR 0 3
68472: PUSH
68473: LD_VAR 0 1
68477: PUSH
68478: FOR_IN
68479: IFFALSE 68503
// if i then
68481: LD_VAR 0 3
68485: IFFALSE 68501
// result := result + 1 ;
68487: LD_ADDR_VAR 0 2
68491: PUSH
68492: LD_VAR 0 2
68496: PUSH
68497: LD_INT 1
68499: PLUS
68500: ST_TO_ADDR
68501: GO 68478
68503: POP
68504: POP
// end ;
68505: LD_VAR 0 2
68509: RET
// export function IsEmpty ( building ) ; begin
68510: LD_INT 0
68512: PPUSH
// if not building then
68513: LD_VAR 0 1
68517: NOT
68518: IFFALSE 68522
// exit ;
68520: GO 68565
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68522: LD_ADDR_VAR 0 2
68526: PUSH
68527: LD_VAR 0 1
68531: PUSH
68532: LD_INT 22
68534: PUSH
68535: LD_VAR 0 1
68539: PPUSH
68540: CALL_OW 255
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 58
68551: PUSH
68552: EMPTY
68553: LIST
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PPUSH
68559: CALL_OW 69
68563: IN
68564: ST_TO_ADDR
// end ;
68565: LD_VAR 0 2
68569: RET
// export function IsNotFull ( building ) ; begin
68570: LD_INT 0
68572: PPUSH
// if not building then
68573: LD_VAR 0 1
68577: NOT
68578: IFFALSE 68582
// exit ;
68580: GO 68601
// result := UnitsInside ( building ) < 6 ;
68582: LD_ADDR_VAR 0 2
68586: PUSH
68587: LD_VAR 0 1
68591: PPUSH
68592: CALL_OW 313
68596: PUSH
68597: LD_INT 6
68599: LESS
68600: ST_TO_ADDR
// end ;
68601: LD_VAR 0 2
68605: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68606: LD_INT 0
68608: PPUSH
68609: PPUSH
68610: PPUSH
68611: PPUSH
// tmp := [ ] ;
68612: LD_ADDR_VAR 0 3
68616: PUSH
68617: EMPTY
68618: ST_TO_ADDR
// list := [ ] ;
68619: LD_ADDR_VAR 0 5
68623: PUSH
68624: EMPTY
68625: ST_TO_ADDR
// for i = 16 to 25 do
68626: LD_ADDR_VAR 0 4
68630: PUSH
68631: DOUBLE
68632: LD_INT 16
68634: DEC
68635: ST_TO_ADDR
68636: LD_INT 25
68638: PUSH
68639: FOR_TO
68640: IFFALSE 68713
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68642: LD_ADDR_VAR 0 3
68646: PUSH
68647: LD_VAR 0 3
68651: PUSH
68652: LD_INT 22
68654: PUSH
68655: LD_VAR 0 1
68659: PPUSH
68660: CALL_OW 255
68664: PUSH
68665: EMPTY
68666: LIST
68667: LIST
68668: PUSH
68669: LD_INT 91
68671: PUSH
68672: LD_VAR 0 1
68676: PUSH
68677: LD_INT 6
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 30
68687: PUSH
68688: LD_VAR 0 4
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: LIST
68701: PUSH
68702: EMPTY
68703: LIST
68704: PPUSH
68705: CALL_OW 69
68709: ADD
68710: ST_TO_ADDR
68711: GO 68639
68713: POP
68714: POP
// for i = 1 to tmp do
68715: LD_ADDR_VAR 0 4
68719: PUSH
68720: DOUBLE
68721: LD_INT 1
68723: DEC
68724: ST_TO_ADDR
68725: LD_VAR 0 3
68729: PUSH
68730: FOR_TO
68731: IFFALSE 68819
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68733: LD_ADDR_VAR 0 5
68737: PUSH
68738: LD_VAR 0 5
68742: PUSH
68743: LD_VAR 0 3
68747: PUSH
68748: LD_VAR 0 4
68752: ARRAY
68753: PPUSH
68754: CALL_OW 266
68758: PUSH
68759: LD_VAR 0 3
68763: PUSH
68764: LD_VAR 0 4
68768: ARRAY
68769: PPUSH
68770: CALL_OW 250
68774: PUSH
68775: LD_VAR 0 3
68779: PUSH
68780: LD_VAR 0 4
68784: ARRAY
68785: PPUSH
68786: CALL_OW 251
68790: PUSH
68791: LD_VAR 0 3
68795: PUSH
68796: LD_VAR 0 4
68800: ARRAY
68801: PPUSH
68802: CALL_OW 254
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: PUSH
68813: EMPTY
68814: LIST
68815: ADD
68816: ST_TO_ADDR
68817: GO 68730
68819: POP
68820: POP
// result := list ;
68821: LD_ADDR_VAR 0 2
68825: PUSH
68826: LD_VAR 0 5
68830: ST_TO_ADDR
// end ;
68831: LD_VAR 0 2
68835: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68836: LD_INT 0
68838: PPUSH
68839: PPUSH
68840: PPUSH
68841: PPUSH
68842: PPUSH
68843: PPUSH
68844: PPUSH
// if not factory then
68845: LD_VAR 0 1
68849: NOT
68850: IFFALSE 68854
// exit ;
68852: GO 69447
// if control = control_apeman then
68854: LD_VAR 0 4
68858: PUSH
68859: LD_INT 5
68861: EQUAL
68862: IFFALSE 68971
// begin tmp := UnitsInside ( factory ) ;
68864: LD_ADDR_VAR 0 8
68868: PUSH
68869: LD_VAR 0 1
68873: PPUSH
68874: CALL_OW 313
68878: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68879: LD_VAR 0 8
68883: PPUSH
68884: LD_INT 25
68886: PUSH
68887: LD_INT 12
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: PPUSH
68894: CALL_OW 72
68898: NOT
68899: IFFALSE 68909
// control := control_manual ;
68901: LD_ADDR_VAR 0 4
68905: PUSH
68906: LD_INT 1
68908: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68909: LD_ADDR_VAR 0 8
68913: PUSH
68914: LD_VAR 0 1
68918: PPUSH
68919: CALL 68606 0 1
68923: ST_TO_ADDR
// if tmp then
68924: LD_VAR 0 8
68928: IFFALSE 68971
// begin for i in tmp do
68930: LD_ADDR_VAR 0 7
68934: PUSH
68935: LD_VAR 0 8
68939: PUSH
68940: FOR_IN
68941: IFFALSE 68969
// if i [ 1 ] = b_ext_radio then
68943: LD_VAR 0 7
68947: PUSH
68948: LD_INT 1
68950: ARRAY
68951: PUSH
68952: LD_INT 22
68954: EQUAL
68955: IFFALSE 68967
// begin control := control_remote ;
68957: LD_ADDR_VAR 0 4
68961: PUSH
68962: LD_INT 2
68964: ST_TO_ADDR
// break ;
68965: GO 68969
// end ;
68967: GO 68940
68969: POP
68970: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68971: LD_VAR 0 1
68975: PPUSH
68976: LD_VAR 0 2
68980: PPUSH
68981: LD_VAR 0 3
68985: PPUSH
68986: LD_VAR 0 4
68990: PPUSH
68991: LD_VAR 0 5
68995: PPUSH
68996: CALL_OW 448
69000: IFFALSE 69035
// begin result := [ chassis , engine , control , weapon ] ;
69002: LD_ADDR_VAR 0 6
69006: PUSH
69007: LD_VAR 0 2
69011: PUSH
69012: LD_VAR 0 3
69016: PUSH
69017: LD_VAR 0 4
69021: PUSH
69022: LD_VAR 0 5
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: LIST
69031: LIST
69032: ST_TO_ADDR
// exit ;
69033: GO 69447
// end ; _chassis := AvailableChassisList ( factory ) ;
69035: LD_ADDR_VAR 0 9
69039: PUSH
69040: LD_VAR 0 1
69044: PPUSH
69045: CALL_OW 475
69049: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69050: LD_ADDR_VAR 0 11
69054: PUSH
69055: LD_VAR 0 1
69059: PPUSH
69060: CALL_OW 476
69064: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69065: LD_ADDR_VAR 0 12
69069: PUSH
69070: LD_VAR 0 1
69074: PPUSH
69075: CALL_OW 477
69079: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69080: LD_ADDR_VAR 0 10
69084: PUSH
69085: LD_VAR 0 1
69089: PPUSH
69090: CALL_OW 478
69094: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69095: LD_VAR 0 9
69099: NOT
69100: PUSH
69101: LD_VAR 0 11
69105: NOT
69106: OR
69107: PUSH
69108: LD_VAR 0 12
69112: NOT
69113: OR
69114: PUSH
69115: LD_VAR 0 10
69119: NOT
69120: OR
69121: IFFALSE 69156
// begin result := [ chassis , engine , control , weapon ] ;
69123: LD_ADDR_VAR 0 6
69127: PUSH
69128: LD_VAR 0 2
69132: PUSH
69133: LD_VAR 0 3
69137: PUSH
69138: LD_VAR 0 4
69142: PUSH
69143: LD_VAR 0 5
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: ST_TO_ADDR
// exit ;
69154: GO 69447
// end ; if not chassis in _chassis then
69156: LD_VAR 0 2
69160: PUSH
69161: LD_VAR 0 9
69165: IN
69166: NOT
69167: IFFALSE 69193
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69169: LD_ADDR_VAR 0 2
69173: PUSH
69174: LD_VAR 0 9
69178: PUSH
69179: LD_INT 1
69181: PPUSH
69182: LD_VAR 0 9
69186: PPUSH
69187: CALL_OW 12
69191: ARRAY
69192: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69193: LD_VAR 0 2
69197: PPUSH
69198: LD_VAR 0 3
69202: PPUSH
69203: CALL 69452 0 2
69207: NOT
69208: IFFALSE 69267
// repeat engine := _engine [ 1 ] ;
69210: LD_ADDR_VAR 0 3
69214: PUSH
69215: LD_VAR 0 11
69219: PUSH
69220: LD_INT 1
69222: ARRAY
69223: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69224: LD_ADDR_VAR 0 11
69228: PUSH
69229: LD_VAR 0 11
69233: PPUSH
69234: LD_INT 1
69236: PPUSH
69237: CALL_OW 3
69241: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69242: LD_VAR 0 2
69246: PPUSH
69247: LD_VAR 0 3
69251: PPUSH
69252: CALL 69452 0 2
69256: PUSH
69257: LD_VAR 0 11
69261: PUSH
69262: EMPTY
69263: EQUAL
69264: OR
69265: IFFALSE 69210
// if not control in _control then
69267: LD_VAR 0 4
69271: PUSH
69272: LD_VAR 0 12
69276: IN
69277: NOT
69278: IFFALSE 69304
// control := _control [ rand ( 1 , _control ) ] ;
69280: LD_ADDR_VAR 0 4
69284: PUSH
69285: LD_VAR 0 12
69289: PUSH
69290: LD_INT 1
69292: PPUSH
69293: LD_VAR 0 12
69297: PPUSH
69298: CALL_OW 12
69302: ARRAY
69303: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69304: LD_VAR 0 2
69308: PPUSH
69309: LD_VAR 0 5
69313: PPUSH
69314: CALL 69672 0 2
69318: NOT
69319: IFFALSE 69378
// repeat weapon := _weapon [ 1 ] ;
69321: LD_ADDR_VAR 0 5
69325: PUSH
69326: LD_VAR 0 10
69330: PUSH
69331: LD_INT 1
69333: ARRAY
69334: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69335: LD_ADDR_VAR 0 10
69339: PUSH
69340: LD_VAR 0 10
69344: PPUSH
69345: LD_INT 1
69347: PPUSH
69348: CALL_OW 3
69352: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69353: LD_VAR 0 2
69357: PPUSH
69358: LD_VAR 0 5
69362: PPUSH
69363: CALL 69672 0 2
69367: PUSH
69368: LD_VAR 0 10
69372: PUSH
69373: EMPTY
69374: EQUAL
69375: OR
69376: IFFALSE 69321
// result := [ ] ;
69378: LD_ADDR_VAR 0 6
69382: PUSH
69383: EMPTY
69384: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69385: LD_VAR 0 1
69389: PPUSH
69390: LD_VAR 0 2
69394: PPUSH
69395: LD_VAR 0 3
69399: PPUSH
69400: LD_VAR 0 4
69404: PPUSH
69405: LD_VAR 0 5
69409: PPUSH
69410: CALL_OW 448
69414: IFFALSE 69447
// result := [ chassis , engine , control , weapon ] ;
69416: LD_ADDR_VAR 0 6
69420: PUSH
69421: LD_VAR 0 2
69425: PUSH
69426: LD_VAR 0 3
69430: PUSH
69431: LD_VAR 0 4
69435: PUSH
69436: LD_VAR 0 5
69440: PUSH
69441: EMPTY
69442: LIST
69443: LIST
69444: LIST
69445: LIST
69446: ST_TO_ADDR
// end ;
69447: LD_VAR 0 6
69451: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69452: LD_INT 0
69454: PPUSH
// if not chassis or not engine then
69455: LD_VAR 0 1
69459: NOT
69460: PUSH
69461: LD_VAR 0 2
69465: NOT
69466: OR
69467: IFFALSE 69471
// exit ;
69469: GO 69667
// case engine of engine_solar :
69471: LD_VAR 0 2
69475: PUSH
69476: LD_INT 2
69478: DOUBLE
69479: EQUAL
69480: IFTRUE 69484
69482: GO 69522
69484: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69485: LD_ADDR_VAR 0 3
69489: PUSH
69490: LD_INT 11
69492: PUSH
69493: LD_INT 12
69495: PUSH
69496: LD_INT 13
69498: PUSH
69499: LD_INT 14
69501: PUSH
69502: LD_INT 1
69504: PUSH
69505: LD_INT 2
69507: PUSH
69508: LD_INT 3
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: ST_TO_ADDR
69520: GO 69651
69522: LD_INT 1
69524: DOUBLE
69525: EQUAL
69526: IFTRUE 69530
69528: GO 69592
69530: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69531: LD_ADDR_VAR 0 3
69535: PUSH
69536: LD_INT 11
69538: PUSH
69539: LD_INT 12
69541: PUSH
69542: LD_INT 13
69544: PUSH
69545: LD_INT 14
69547: PUSH
69548: LD_INT 1
69550: PUSH
69551: LD_INT 2
69553: PUSH
69554: LD_INT 3
69556: PUSH
69557: LD_INT 4
69559: PUSH
69560: LD_INT 5
69562: PUSH
69563: LD_INT 21
69565: PUSH
69566: LD_INT 23
69568: PUSH
69569: LD_INT 22
69571: PUSH
69572: LD_INT 24
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: LIST
69579: LIST
69580: LIST
69581: LIST
69582: LIST
69583: LIST
69584: LIST
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: ST_TO_ADDR
69590: GO 69651
69592: LD_INT 3
69594: DOUBLE
69595: EQUAL
69596: IFTRUE 69600
69598: GO 69650
69600: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69601: LD_ADDR_VAR 0 3
69605: PUSH
69606: LD_INT 13
69608: PUSH
69609: LD_INT 14
69611: PUSH
69612: LD_INT 2
69614: PUSH
69615: LD_INT 3
69617: PUSH
69618: LD_INT 4
69620: PUSH
69621: LD_INT 5
69623: PUSH
69624: LD_INT 21
69626: PUSH
69627: LD_INT 22
69629: PUSH
69630: LD_INT 23
69632: PUSH
69633: LD_INT 24
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: ST_TO_ADDR
69648: GO 69651
69650: POP
// result := ( chassis in result ) ;
69651: LD_ADDR_VAR 0 3
69655: PUSH
69656: LD_VAR 0 1
69660: PUSH
69661: LD_VAR 0 3
69665: IN
69666: ST_TO_ADDR
// end ;
69667: LD_VAR 0 3
69671: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69672: LD_INT 0
69674: PPUSH
// if not chassis or not weapon then
69675: LD_VAR 0 1
69679: NOT
69680: PUSH
69681: LD_VAR 0 2
69685: NOT
69686: OR
69687: IFFALSE 69691
// exit ;
69689: GO 70717
// case weapon of us_machine_gun :
69691: LD_VAR 0 2
69695: PUSH
69696: LD_INT 2
69698: DOUBLE
69699: EQUAL
69700: IFTRUE 69704
69702: GO 69734
69704: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69705: LD_ADDR_VAR 0 3
69709: PUSH
69710: LD_INT 1
69712: PUSH
69713: LD_INT 2
69715: PUSH
69716: LD_INT 3
69718: PUSH
69719: LD_INT 4
69721: PUSH
69722: LD_INT 5
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: ST_TO_ADDR
69732: GO 70701
69734: LD_INT 3
69736: DOUBLE
69737: EQUAL
69738: IFTRUE 69742
69740: GO 69772
69742: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69743: LD_ADDR_VAR 0 3
69747: PUSH
69748: LD_INT 1
69750: PUSH
69751: LD_INT 2
69753: PUSH
69754: LD_INT 3
69756: PUSH
69757: LD_INT 4
69759: PUSH
69760: LD_INT 5
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: LIST
69767: LIST
69768: LIST
69769: ST_TO_ADDR
69770: GO 70701
69772: LD_INT 11
69774: DOUBLE
69775: EQUAL
69776: IFTRUE 69780
69778: GO 69810
69780: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69781: LD_ADDR_VAR 0 3
69785: PUSH
69786: LD_INT 1
69788: PUSH
69789: LD_INT 2
69791: PUSH
69792: LD_INT 3
69794: PUSH
69795: LD_INT 4
69797: PUSH
69798: LD_INT 5
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: LIST
69807: ST_TO_ADDR
69808: GO 70701
69810: LD_INT 4
69812: DOUBLE
69813: EQUAL
69814: IFTRUE 69818
69816: GO 69844
69818: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69819: LD_ADDR_VAR 0 3
69823: PUSH
69824: LD_INT 2
69826: PUSH
69827: LD_INT 3
69829: PUSH
69830: LD_INT 4
69832: PUSH
69833: LD_INT 5
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: ST_TO_ADDR
69842: GO 70701
69844: LD_INT 5
69846: DOUBLE
69847: EQUAL
69848: IFTRUE 69852
69850: GO 69878
69852: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69853: LD_ADDR_VAR 0 3
69857: PUSH
69858: LD_INT 2
69860: PUSH
69861: LD_INT 3
69863: PUSH
69864: LD_INT 4
69866: PUSH
69867: LD_INT 5
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: ST_TO_ADDR
69876: GO 70701
69878: LD_INT 9
69880: DOUBLE
69881: EQUAL
69882: IFTRUE 69886
69884: GO 69912
69886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69887: LD_ADDR_VAR 0 3
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: LD_INT 3
69897: PUSH
69898: LD_INT 4
69900: PUSH
69901: LD_INT 5
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: ST_TO_ADDR
69910: GO 70701
69912: LD_INT 7
69914: DOUBLE
69915: EQUAL
69916: IFTRUE 69920
69918: GO 69946
69920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69921: LD_ADDR_VAR 0 3
69925: PUSH
69926: LD_INT 2
69928: PUSH
69929: LD_INT 3
69931: PUSH
69932: LD_INT 4
69934: PUSH
69935: LD_INT 5
69937: PUSH
69938: EMPTY
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: ST_TO_ADDR
69944: GO 70701
69946: LD_INT 12
69948: DOUBLE
69949: EQUAL
69950: IFTRUE 69954
69952: GO 69980
69954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69955: LD_ADDR_VAR 0 3
69959: PUSH
69960: LD_INT 2
69962: PUSH
69963: LD_INT 3
69965: PUSH
69966: LD_INT 4
69968: PUSH
69969: LD_INT 5
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: ST_TO_ADDR
69978: GO 70701
69980: LD_INT 13
69982: DOUBLE
69983: EQUAL
69984: IFTRUE 69988
69986: GO 70014
69988: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69989: LD_ADDR_VAR 0 3
69993: PUSH
69994: LD_INT 2
69996: PUSH
69997: LD_INT 3
69999: PUSH
70000: LD_INT 4
70002: PUSH
70003: LD_INT 5
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: ST_TO_ADDR
70012: GO 70701
70014: LD_INT 14
70016: DOUBLE
70017: EQUAL
70018: IFTRUE 70022
70020: GO 70040
70022: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70023: LD_ADDR_VAR 0 3
70027: PUSH
70028: LD_INT 4
70030: PUSH
70031: LD_INT 5
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: ST_TO_ADDR
70038: GO 70701
70040: LD_INT 6
70042: DOUBLE
70043: EQUAL
70044: IFTRUE 70048
70046: GO 70066
70048: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70049: LD_ADDR_VAR 0 3
70053: PUSH
70054: LD_INT 4
70056: PUSH
70057: LD_INT 5
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: ST_TO_ADDR
70064: GO 70701
70066: LD_INT 10
70068: DOUBLE
70069: EQUAL
70070: IFTRUE 70074
70072: GO 70092
70074: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70075: LD_ADDR_VAR 0 3
70079: PUSH
70080: LD_INT 4
70082: PUSH
70083: LD_INT 5
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: ST_TO_ADDR
70090: GO 70701
70092: LD_INT 22
70094: DOUBLE
70095: EQUAL
70096: IFTRUE 70100
70098: GO 70126
70100: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70101: LD_ADDR_VAR 0 3
70105: PUSH
70106: LD_INT 11
70108: PUSH
70109: LD_INT 12
70111: PUSH
70112: LD_INT 13
70114: PUSH
70115: LD_INT 14
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: LIST
70122: LIST
70123: ST_TO_ADDR
70124: GO 70701
70126: LD_INT 23
70128: DOUBLE
70129: EQUAL
70130: IFTRUE 70134
70132: GO 70160
70134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70135: LD_ADDR_VAR 0 3
70139: PUSH
70140: LD_INT 11
70142: PUSH
70143: LD_INT 12
70145: PUSH
70146: LD_INT 13
70148: PUSH
70149: LD_INT 14
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: ST_TO_ADDR
70158: GO 70701
70160: LD_INT 24
70162: DOUBLE
70163: EQUAL
70164: IFTRUE 70168
70166: GO 70194
70168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70169: LD_ADDR_VAR 0 3
70173: PUSH
70174: LD_INT 11
70176: PUSH
70177: LD_INT 12
70179: PUSH
70180: LD_INT 13
70182: PUSH
70183: LD_INT 14
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: ST_TO_ADDR
70192: GO 70701
70194: LD_INT 30
70196: DOUBLE
70197: EQUAL
70198: IFTRUE 70202
70200: GO 70228
70202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70203: LD_ADDR_VAR 0 3
70207: PUSH
70208: LD_INT 11
70210: PUSH
70211: LD_INT 12
70213: PUSH
70214: LD_INT 13
70216: PUSH
70217: LD_INT 14
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: ST_TO_ADDR
70226: GO 70701
70228: LD_INT 25
70230: DOUBLE
70231: EQUAL
70232: IFTRUE 70236
70234: GO 70254
70236: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70237: LD_ADDR_VAR 0 3
70241: PUSH
70242: LD_INT 13
70244: PUSH
70245: LD_INT 14
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: ST_TO_ADDR
70252: GO 70701
70254: LD_INT 27
70256: DOUBLE
70257: EQUAL
70258: IFTRUE 70262
70260: GO 70280
70262: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70263: LD_ADDR_VAR 0 3
70267: PUSH
70268: LD_INT 13
70270: PUSH
70271: LD_INT 14
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: ST_TO_ADDR
70278: GO 70701
70280: LD_INT 28
70282: DOUBLE
70283: EQUAL
70284: IFTRUE 70288
70286: GO 70306
70288: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70289: LD_ADDR_VAR 0 3
70293: PUSH
70294: LD_INT 13
70296: PUSH
70297: LD_INT 14
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: ST_TO_ADDR
70304: GO 70701
70306: LD_INT 29
70308: DOUBLE
70309: EQUAL
70310: IFTRUE 70314
70312: GO 70332
70314: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70315: LD_ADDR_VAR 0 3
70319: PUSH
70320: LD_INT 13
70322: PUSH
70323: LD_INT 14
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: ST_TO_ADDR
70330: GO 70701
70332: LD_INT 31
70334: DOUBLE
70335: EQUAL
70336: IFTRUE 70340
70338: GO 70358
70340: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70341: LD_ADDR_VAR 0 3
70345: PUSH
70346: LD_INT 13
70348: PUSH
70349: LD_INT 14
70351: PUSH
70352: EMPTY
70353: LIST
70354: LIST
70355: ST_TO_ADDR
70356: GO 70701
70358: LD_INT 26
70360: DOUBLE
70361: EQUAL
70362: IFTRUE 70366
70364: GO 70384
70366: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70367: LD_ADDR_VAR 0 3
70371: PUSH
70372: LD_INT 13
70374: PUSH
70375: LD_INT 14
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: ST_TO_ADDR
70382: GO 70701
70384: LD_INT 42
70386: DOUBLE
70387: EQUAL
70388: IFTRUE 70392
70390: GO 70418
70392: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70393: LD_ADDR_VAR 0 3
70397: PUSH
70398: LD_INT 21
70400: PUSH
70401: LD_INT 22
70403: PUSH
70404: LD_INT 23
70406: PUSH
70407: LD_INT 24
70409: PUSH
70410: EMPTY
70411: LIST
70412: LIST
70413: LIST
70414: LIST
70415: ST_TO_ADDR
70416: GO 70701
70418: LD_INT 43
70420: DOUBLE
70421: EQUAL
70422: IFTRUE 70426
70424: GO 70452
70426: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70427: LD_ADDR_VAR 0 3
70431: PUSH
70432: LD_INT 21
70434: PUSH
70435: LD_INT 22
70437: PUSH
70438: LD_INT 23
70440: PUSH
70441: LD_INT 24
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: LIST
70448: LIST
70449: ST_TO_ADDR
70450: GO 70701
70452: LD_INT 44
70454: DOUBLE
70455: EQUAL
70456: IFTRUE 70460
70458: GO 70486
70460: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70461: LD_ADDR_VAR 0 3
70465: PUSH
70466: LD_INT 21
70468: PUSH
70469: LD_INT 22
70471: PUSH
70472: LD_INT 23
70474: PUSH
70475: LD_INT 24
70477: PUSH
70478: EMPTY
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: ST_TO_ADDR
70484: GO 70701
70486: LD_INT 45
70488: DOUBLE
70489: EQUAL
70490: IFTRUE 70494
70492: GO 70520
70494: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70495: LD_ADDR_VAR 0 3
70499: PUSH
70500: LD_INT 21
70502: PUSH
70503: LD_INT 22
70505: PUSH
70506: LD_INT 23
70508: PUSH
70509: LD_INT 24
70511: PUSH
70512: EMPTY
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: ST_TO_ADDR
70518: GO 70701
70520: LD_INT 49
70522: DOUBLE
70523: EQUAL
70524: IFTRUE 70528
70526: GO 70554
70528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70529: LD_ADDR_VAR 0 3
70533: PUSH
70534: LD_INT 21
70536: PUSH
70537: LD_INT 22
70539: PUSH
70540: LD_INT 23
70542: PUSH
70543: LD_INT 24
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: ST_TO_ADDR
70552: GO 70701
70554: LD_INT 51
70556: DOUBLE
70557: EQUAL
70558: IFTRUE 70562
70560: GO 70588
70562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70563: LD_ADDR_VAR 0 3
70567: PUSH
70568: LD_INT 21
70570: PUSH
70571: LD_INT 22
70573: PUSH
70574: LD_INT 23
70576: PUSH
70577: LD_INT 24
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: ST_TO_ADDR
70586: GO 70701
70588: LD_INT 52
70590: DOUBLE
70591: EQUAL
70592: IFTRUE 70596
70594: GO 70622
70596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70597: LD_ADDR_VAR 0 3
70601: PUSH
70602: LD_INT 21
70604: PUSH
70605: LD_INT 22
70607: PUSH
70608: LD_INT 23
70610: PUSH
70611: LD_INT 24
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: ST_TO_ADDR
70620: GO 70701
70622: LD_INT 53
70624: DOUBLE
70625: EQUAL
70626: IFTRUE 70630
70628: GO 70648
70630: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70631: LD_ADDR_VAR 0 3
70635: PUSH
70636: LD_INT 23
70638: PUSH
70639: LD_INT 24
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: ST_TO_ADDR
70646: GO 70701
70648: LD_INT 46
70650: DOUBLE
70651: EQUAL
70652: IFTRUE 70656
70654: GO 70674
70656: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70657: LD_ADDR_VAR 0 3
70661: PUSH
70662: LD_INT 23
70664: PUSH
70665: LD_INT 24
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: ST_TO_ADDR
70672: GO 70701
70674: LD_INT 47
70676: DOUBLE
70677: EQUAL
70678: IFTRUE 70682
70680: GO 70700
70682: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70683: LD_ADDR_VAR 0 3
70687: PUSH
70688: LD_INT 23
70690: PUSH
70691: LD_INT 24
70693: PUSH
70694: EMPTY
70695: LIST
70696: LIST
70697: ST_TO_ADDR
70698: GO 70701
70700: POP
// result := ( chassis in result ) ;
70701: LD_ADDR_VAR 0 3
70705: PUSH
70706: LD_VAR 0 1
70710: PUSH
70711: LD_VAR 0 3
70715: IN
70716: ST_TO_ADDR
// end ;
70717: LD_VAR 0 3
70721: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70722: LD_INT 0
70724: PPUSH
70725: PPUSH
70726: PPUSH
70727: PPUSH
70728: PPUSH
70729: PPUSH
70730: PPUSH
// result := array ;
70731: LD_ADDR_VAR 0 5
70735: PUSH
70736: LD_VAR 0 1
70740: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70741: LD_VAR 0 1
70745: NOT
70746: PUSH
70747: LD_VAR 0 2
70751: NOT
70752: OR
70753: PUSH
70754: LD_VAR 0 3
70758: NOT
70759: OR
70760: PUSH
70761: LD_VAR 0 2
70765: PUSH
70766: LD_VAR 0 1
70770: GREATER
70771: OR
70772: PUSH
70773: LD_VAR 0 3
70777: PUSH
70778: LD_VAR 0 1
70782: GREATER
70783: OR
70784: IFFALSE 70788
// exit ;
70786: GO 71084
// if direction then
70788: LD_VAR 0 4
70792: IFFALSE 70856
// begin d := 1 ;
70794: LD_ADDR_VAR 0 9
70798: PUSH
70799: LD_INT 1
70801: ST_TO_ADDR
// if i_from > i_to then
70802: LD_VAR 0 2
70806: PUSH
70807: LD_VAR 0 3
70811: GREATER
70812: IFFALSE 70838
// length := ( array - i_from ) + i_to else
70814: LD_ADDR_VAR 0 11
70818: PUSH
70819: LD_VAR 0 1
70823: PUSH
70824: LD_VAR 0 2
70828: MINUS
70829: PUSH
70830: LD_VAR 0 3
70834: PLUS
70835: ST_TO_ADDR
70836: GO 70854
// length := i_to - i_from ;
70838: LD_ADDR_VAR 0 11
70842: PUSH
70843: LD_VAR 0 3
70847: PUSH
70848: LD_VAR 0 2
70852: MINUS
70853: ST_TO_ADDR
// end else
70854: GO 70917
// begin d := - 1 ;
70856: LD_ADDR_VAR 0 9
70860: PUSH
70861: LD_INT 1
70863: NEG
70864: ST_TO_ADDR
// if i_from > i_to then
70865: LD_VAR 0 2
70869: PUSH
70870: LD_VAR 0 3
70874: GREATER
70875: IFFALSE 70895
// length := i_from - i_to else
70877: LD_ADDR_VAR 0 11
70881: PUSH
70882: LD_VAR 0 2
70886: PUSH
70887: LD_VAR 0 3
70891: MINUS
70892: ST_TO_ADDR
70893: GO 70917
// length := ( array - i_to ) + i_from ;
70895: LD_ADDR_VAR 0 11
70899: PUSH
70900: LD_VAR 0 1
70904: PUSH
70905: LD_VAR 0 3
70909: MINUS
70910: PUSH
70911: LD_VAR 0 2
70915: PLUS
70916: ST_TO_ADDR
// end ; if not length then
70917: LD_VAR 0 11
70921: NOT
70922: IFFALSE 70926
// exit ;
70924: GO 71084
// tmp := array ;
70926: LD_ADDR_VAR 0 10
70930: PUSH
70931: LD_VAR 0 1
70935: ST_TO_ADDR
// for i = 1 to length do
70936: LD_ADDR_VAR 0 6
70940: PUSH
70941: DOUBLE
70942: LD_INT 1
70944: DEC
70945: ST_TO_ADDR
70946: LD_VAR 0 11
70950: PUSH
70951: FOR_TO
70952: IFFALSE 71072
// begin for j = 1 to array do
70954: LD_ADDR_VAR 0 7
70958: PUSH
70959: DOUBLE
70960: LD_INT 1
70962: DEC
70963: ST_TO_ADDR
70964: LD_VAR 0 1
70968: PUSH
70969: FOR_TO
70970: IFFALSE 71058
// begin k := j + d ;
70972: LD_ADDR_VAR 0 8
70976: PUSH
70977: LD_VAR 0 7
70981: PUSH
70982: LD_VAR 0 9
70986: PLUS
70987: ST_TO_ADDR
// if k > array then
70988: LD_VAR 0 8
70992: PUSH
70993: LD_VAR 0 1
70997: GREATER
70998: IFFALSE 71008
// k := 1 ;
71000: LD_ADDR_VAR 0 8
71004: PUSH
71005: LD_INT 1
71007: ST_TO_ADDR
// if not k then
71008: LD_VAR 0 8
71012: NOT
71013: IFFALSE 71025
// k := array ;
71015: LD_ADDR_VAR 0 8
71019: PUSH
71020: LD_VAR 0 1
71024: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71025: LD_ADDR_VAR 0 10
71029: PUSH
71030: LD_VAR 0 10
71034: PPUSH
71035: LD_VAR 0 8
71039: PPUSH
71040: LD_VAR 0 1
71044: PUSH
71045: LD_VAR 0 7
71049: ARRAY
71050: PPUSH
71051: CALL_OW 1
71055: ST_TO_ADDR
// end ;
71056: GO 70969
71058: POP
71059: POP
// array := tmp ;
71060: LD_ADDR_VAR 0 1
71064: PUSH
71065: LD_VAR 0 10
71069: ST_TO_ADDR
// end ;
71070: GO 70951
71072: POP
71073: POP
// result := array ;
71074: LD_ADDR_VAR 0 5
71078: PUSH
71079: LD_VAR 0 1
71083: ST_TO_ADDR
// end ;
71084: LD_VAR 0 5
71088: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71089: LD_INT 0
71091: PPUSH
71092: PPUSH
// result := 0 ;
71093: LD_ADDR_VAR 0 3
71097: PUSH
71098: LD_INT 0
71100: ST_TO_ADDR
// if not array or not value in array then
71101: LD_VAR 0 1
71105: NOT
71106: PUSH
71107: LD_VAR 0 2
71111: PUSH
71112: LD_VAR 0 1
71116: IN
71117: NOT
71118: OR
71119: IFFALSE 71123
// exit ;
71121: GO 71177
// for i = 1 to array do
71123: LD_ADDR_VAR 0 4
71127: PUSH
71128: DOUBLE
71129: LD_INT 1
71131: DEC
71132: ST_TO_ADDR
71133: LD_VAR 0 1
71137: PUSH
71138: FOR_TO
71139: IFFALSE 71175
// if value = array [ i ] then
71141: LD_VAR 0 2
71145: PUSH
71146: LD_VAR 0 1
71150: PUSH
71151: LD_VAR 0 4
71155: ARRAY
71156: EQUAL
71157: IFFALSE 71173
// begin result := i ;
71159: LD_ADDR_VAR 0 3
71163: PUSH
71164: LD_VAR 0 4
71168: ST_TO_ADDR
// exit ;
71169: POP
71170: POP
71171: GO 71177
// end ;
71173: GO 71138
71175: POP
71176: POP
// end ;
71177: LD_VAR 0 3
71181: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71182: LD_INT 0
71184: PPUSH
// vc_chassis := chassis ;
71185: LD_ADDR_OWVAR 37
71189: PUSH
71190: LD_VAR 0 1
71194: ST_TO_ADDR
// vc_engine := engine ;
71195: LD_ADDR_OWVAR 39
71199: PUSH
71200: LD_VAR 0 2
71204: ST_TO_ADDR
// vc_control := control ;
71205: LD_ADDR_OWVAR 38
71209: PUSH
71210: LD_VAR 0 3
71214: ST_TO_ADDR
// vc_weapon := weapon ;
71215: LD_ADDR_OWVAR 40
71219: PUSH
71220: LD_VAR 0 4
71224: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71225: LD_ADDR_OWVAR 41
71229: PUSH
71230: LD_VAR 0 5
71234: ST_TO_ADDR
// end ;
71235: LD_VAR 0 6
71239: RET
// export function WantPlant ( unit ) ; var task ; begin
71240: LD_INT 0
71242: PPUSH
71243: PPUSH
// result := false ;
71244: LD_ADDR_VAR 0 2
71248: PUSH
71249: LD_INT 0
71251: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71252: LD_ADDR_VAR 0 3
71256: PUSH
71257: LD_VAR 0 1
71261: PPUSH
71262: CALL_OW 437
71266: ST_TO_ADDR
// if task then
71267: LD_VAR 0 3
71271: IFFALSE 71299
// if task [ 1 ] [ 1 ] = p then
71273: LD_VAR 0 3
71277: PUSH
71278: LD_INT 1
71280: ARRAY
71281: PUSH
71282: LD_INT 1
71284: ARRAY
71285: PUSH
71286: LD_STRING p
71288: EQUAL
71289: IFFALSE 71299
// result := true ;
71291: LD_ADDR_VAR 0 2
71295: PUSH
71296: LD_INT 1
71298: ST_TO_ADDR
// end ;
71299: LD_VAR 0 2
71303: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71304: LD_INT 0
71306: PPUSH
71307: PPUSH
71308: PPUSH
71309: PPUSH
// if pos < 1 then
71310: LD_VAR 0 2
71314: PUSH
71315: LD_INT 1
71317: LESS
71318: IFFALSE 71322
// exit ;
71320: GO 71625
// if pos = 1 then
71322: LD_VAR 0 2
71326: PUSH
71327: LD_INT 1
71329: EQUAL
71330: IFFALSE 71363
// result := Replace ( arr , pos [ 1 ] , value ) else
71332: LD_ADDR_VAR 0 4
71336: PUSH
71337: LD_VAR 0 1
71341: PPUSH
71342: LD_VAR 0 2
71346: PUSH
71347: LD_INT 1
71349: ARRAY
71350: PPUSH
71351: LD_VAR 0 3
71355: PPUSH
71356: CALL_OW 1
71360: ST_TO_ADDR
71361: GO 71625
// begin tmp := arr ;
71363: LD_ADDR_VAR 0 6
71367: PUSH
71368: LD_VAR 0 1
71372: ST_TO_ADDR
// s_arr := [ tmp ] ;
71373: LD_ADDR_VAR 0 7
71377: PUSH
71378: LD_VAR 0 6
71382: PUSH
71383: EMPTY
71384: LIST
71385: ST_TO_ADDR
// for i = 1 to pos - 1 do
71386: LD_ADDR_VAR 0 5
71390: PUSH
71391: DOUBLE
71392: LD_INT 1
71394: DEC
71395: ST_TO_ADDR
71396: LD_VAR 0 2
71400: PUSH
71401: LD_INT 1
71403: MINUS
71404: PUSH
71405: FOR_TO
71406: IFFALSE 71451
// begin tmp := tmp [ pos [ i ] ] ;
71408: LD_ADDR_VAR 0 6
71412: PUSH
71413: LD_VAR 0 6
71417: PUSH
71418: LD_VAR 0 2
71422: PUSH
71423: LD_VAR 0 5
71427: ARRAY
71428: ARRAY
71429: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71430: LD_ADDR_VAR 0 7
71434: PUSH
71435: LD_VAR 0 7
71439: PUSH
71440: LD_VAR 0 6
71444: PUSH
71445: EMPTY
71446: LIST
71447: ADD
71448: ST_TO_ADDR
// end ;
71449: GO 71405
71451: POP
71452: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71453: LD_ADDR_VAR 0 6
71457: PUSH
71458: LD_VAR 0 6
71462: PPUSH
71463: LD_VAR 0 2
71467: PUSH
71468: LD_VAR 0 2
71472: ARRAY
71473: PPUSH
71474: LD_VAR 0 3
71478: PPUSH
71479: CALL_OW 1
71483: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71484: LD_ADDR_VAR 0 7
71488: PUSH
71489: LD_VAR 0 7
71493: PPUSH
71494: LD_VAR 0 7
71498: PPUSH
71499: LD_VAR 0 6
71503: PPUSH
71504: CALL_OW 1
71508: ST_TO_ADDR
// for i = s_arr downto 2 do
71509: LD_ADDR_VAR 0 5
71513: PUSH
71514: DOUBLE
71515: LD_VAR 0 7
71519: INC
71520: ST_TO_ADDR
71521: LD_INT 2
71523: PUSH
71524: FOR_DOWNTO
71525: IFFALSE 71609
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71527: LD_ADDR_VAR 0 6
71531: PUSH
71532: LD_VAR 0 7
71536: PUSH
71537: LD_VAR 0 5
71541: PUSH
71542: LD_INT 1
71544: MINUS
71545: ARRAY
71546: PPUSH
71547: LD_VAR 0 2
71551: PUSH
71552: LD_VAR 0 5
71556: PUSH
71557: LD_INT 1
71559: MINUS
71560: ARRAY
71561: PPUSH
71562: LD_VAR 0 7
71566: PUSH
71567: LD_VAR 0 5
71571: ARRAY
71572: PPUSH
71573: CALL_OW 1
71577: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71578: LD_ADDR_VAR 0 7
71582: PUSH
71583: LD_VAR 0 7
71587: PPUSH
71588: LD_VAR 0 5
71592: PUSH
71593: LD_INT 1
71595: MINUS
71596: PPUSH
71597: LD_VAR 0 6
71601: PPUSH
71602: CALL_OW 1
71606: ST_TO_ADDR
// end ;
71607: GO 71524
71609: POP
71610: POP
// result := s_arr [ 1 ] ;
71611: LD_ADDR_VAR 0 4
71615: PUSH
71616: LD_VAR 0 7
71620: PUSH
71621: LD_INT 1
71623: ARRAY
71624: ST_TO_ADDR
// end ; end ;
71625: LD_VAR 0 4
71629: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71630: LD_INT 0
71632: PPUSH
71633: PPUSH
// if not list then
71634: LD_VAR 0 1
71638: NOT
71639: IFFALSE 71643
// exit ;
71641: GO 71734
// i := list [ pos1 ] ;
71643: LD_ADDR_VAR 0 5
71647: PUSH
71648: LD_VAR 0 1
71652: PUSH
71653: LD_VAR 0 2
71657: ARRAY
71658: ST_TO_ADDR
// if not i then
71659: LD_VAR 0 5
71663: NOT
71664: IFFALSE 71668
// exit ;
71666: GO 71734
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71668: LD_ADDR_VAR 0 1
71672: PUSH
71673: LD_VAR 0 1
71677: PPUSH
71678: LD_VAR 0 2
71682: PPUSH
71683: LD_VAR 0 1
71687: PUSH
71688: LD_VAR 0 3
71692: ARRAY
71693: PPUSH
71694: CALL_OW 1
71698: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71699: LD_ADDR_VAR 0 1
71703: PUSH
71704: LD_VAR 0 1
71708: PPUSH
71709: LD_VAR 0 3
71713: PPUSH
71714: LD_VAR 0 5
71718: PPUSH
71719: CALL_OW 1
71723: ST_TO_ADDR
// result := list ;
71724: LD_ADDR_VAR 0 4
71728: PUSH
71729: LD_VAR 0 1
71733: ST_TO_ADDR
// end ;
71734: LD_VAR 0 4
71738: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71739: LD_INT 0
71741: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71742: LD_ADDR_VAR 0 5
71746: PUSH
71747: LD_VAR 0 1
71751: PPUSH
71752: CALL_OW 250
71756: PPUSH
71757: LD_VAR 0 1
71761: PPUSH
71762: CALL_OW 251
71766: PPUSH
71767: LD_VAR 0 2
71771: PPUSH
71772: LD_VAR 0 3
71776: PPUSH
71777: LD_VAR 0 4
71781: PPUSH
71782: CALL 71792 0 5
71786: ST_TO_ADDR
// end ;
71787: LD_VAR 0 5
71791: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71792: LD_INT 0
71794: PPUSH
71795: PPUSH
71796: PPUSH
71797: PPUSH
// if not list then
71798: LD_VAR 0 3
71802: NOT
71803: IFFALSE 71807
// exit ;
71805: GO 72195
// result := [ ] ;
71807: LD_ADDR_VAR 0 6
71811: PUSH
71812: EMPTY
71813: ST_TO_ADDR
// for i in list do
71814: LD_ADDR_VAR 0 7
71818: PUSH
71819: LD_VAR 0 3
71823: PUSH
71824: FOR_IN
71825: IFFALSE 72027
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71827: LD_ADDR_VAR 0 9
71831: PUSH
71832: LD_VAR 0 7
71836: PPUSH
71837: LD_VAR 0 1
71841: PPUSH
71842: LD_VAR 0 2
71846: PPUSH
71847: CALL_OW 297
71851: ST_TO_ADDR
// if not result then
71852: LD_VAR 0 6
71856: NOT
71857: IFFALSE 71883
// result := [ [ i , tmp ] ] else
71859: LD_ADDR_VAR 0 6
71863: PUSH
71864: LD_VAR 0 7
71868: PUSH
71869: LD_VAR 0 9
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: EMPTY
71879: LIST
71880: ST_TO_ADDR
71881: GO 72025
// begin if result [ result ] [ 2 ] < tmp then
71883: LD_VAR 0 6
71887: PUSH
71888: LD_VAR 0 6
71892: ARRAY
71893: PUSH
71894: LD_INT 2
71896: ARRAY
71897: PUSH
71898: LD_VAR 0 9
71902: LESS
71903: IFFALSE 71945
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71905: LD_ADDR_VAR 0 6
71909: PUSH
71910: LD_VAR 0 6
71914: PPUSH
71915: LD_VAR 0 6
71919: PUSH
71920: LD_INT 1
71922: PLUS
71923: PPUSH
71924: LD_VAR 0 7
71928: PUSH
71929: LD_VAR 0 9
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PPUSH
71938: CALL_OW 2
71942: ST_TO_ADDR
71943: GO 72025
// for j = 1 to result do
71945: LD_ADDR_VAR 0 8
71949: PUSH
71950: DOUBLE
71951: LD_INT 1
71953: DEC
71954: ST_TO_ADDR
71955: LD_VAR 0 6
71959: PUSH
71960: FOR_TO
71961: IFFALSE 72023
// begin if tmp < result [ j ] [ 2 ] then
71963: LD_VAR 0 9
71967: PUSH
71968: LD_VAR 0 6
71972: PUSH
71973: LD_VAR 0 8
71977: ARRAY
71978: PUSH
71979: LD_INT 2
71981: ARRAY
71982: LESS
71983: IFFALSE 72021
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71985: LD_ADDR_VAR 0 6
71989: PUSH
71990: LD_VAR 0 6
71994: PPUSH
71995: LD_VAR 0 8
71999: PPUSH
72000: LD_VAR 0 7
72004: PUSH
72005: LD_VAR 0 9
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PPUSH
72014: CALL_OW 2
72018: ST_TO_ADDR
// break ;
72019: GO 72023
// end ; end ;
72021: GO 71960
72023: POP
72024: POP
// end ; end ;
72025: GO 71824
72027: POP
72028: POP
// if result and not asc then
72029: LD_VAR 0 6
72033: PUSH
72034: LD_VAR 0 4
72038: NOT
72039: AND
72040: IFFALSE 72115
// begin tmp := result ;
72042: LD_ADDR_VAR 0 9
72046: PUSH
72047: LD_VAR 0 6
72051: ST_TO_ADDR
// for i = tmp downto 1 do
72052: LD_ADDR_VAR 0 7
72056: PUSH
72057: DOUBLE
72058: LD_VAR 0 9
72062: INC
72063: ST_TO_ADDR
72064: LD_INT 1
72066: PUSH
72067: FOR_DOWNTO
72068: IFFALSE 72113
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72070: LD_ADDR_VAR 0 6
72074: PUSH
72075: LD_VAR 0 6
72079: PPUSH
72080: LD_VAR 0 9
72084: PUSH
72085: LD_VAR 0 7
72089: MINUS
72090: PUSH
72091: LD_INT 1
72093: PLUS
72094: PPUSH
72095: LD_VAR 0 9
72099: PUSH
72100: LD_VAR 0 7
72104: ARRAY
72105: PPUSH
72106: CALL_OW 1
72110: ST_TO_ADDR
72111: GO 72067
72113: POP
72114: POP
// end ; tmp := [ ] ;
72115: LD_ADDR_VAR 0 9
72119: PUSH
72120: EMPTY
72121: ST_TO_ADDR
// if mode then
72122: LD_VAR 0 5
72126: IFFALSE 72195
// begin for i = 1 to result do
72128: LD_ADDR_VAR 0 7
72132: PUSH
72133: DOUBLE
72134: LD_INT 1
72136: DEC
72137: ST_TO_ADDR
72138: LD_VAR 0 6
72142: PUSH
72143: FOR_TO
72144: IFFALSE 72183
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72146: LD_ADDR_VAR 0 9
72150: PUSH
72151: LD_VAR 0 9
72155: PPUSH
72156: LD_VAR 0 7
72160: PPUSH
72161: LD_VAR 0 6
72165: PUSH
72166: LD_VAR 0 7
72170: ARRAY
72171: PUSH
72172: LD_INT 1
72174: ARRAY
72175: PPUSH
72176: CALL_OW 1
72180: ST_TO_ADDR
72181: GO 72143
72183: POP
72184: POP
// result := tmp ;
72185: LD_ADDR_VAR 0 6
72189: PUSH
72190: LD_VAR 0 9
72194: ST_TO_ADDR
// end ; end ;
72195: LD_VAR 0 6
72199: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72200: LD_INT 0
72202: PPUSH
72203: PPUSH
72204: PPUSH
72205: PPUSH
72206: PPUSH
72207: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72208: LD_ADDR_VAR 0 5
72212: PUSH
72213: LD_INT 0
72215: PUSH
72216: LD_INT 0
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: EMPTY
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: ST_TO_ADDR
// if not x or not y then
72230: LD_VAR 0 2
72234: NOT
72235: PUSH
72236: LD_VAR 0 3
72240: NOT
72241: OR
72242: IFFALSE 72246
// exit ;
72244: GO 73892
// if not range then
72246: LD_VAR 0 4
72250: NOT
72251: IFFALSE 72261
// range := 10 ;
72253: LD_ADDR_VAR 0 4
72257: PUSH
72258: LD_INT 10
72260: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72261: LD_ADDR_VAR 0 8
72265: PUSH
72266: LD_INT 81
72268: PUSH
72269: LD_VAR 0 1
72273: PUSH
72274: EMPTY
72275: LIST
72276: LIST
72277: PUSH
72278: LD_INT 92
72280: PUSH
72281: LD_VAR 0 2
72285: PUSH
72286: LD_VAR 0 3
72290: PUSH
72291: LD_VAR 0 4
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 3
72304: PUSH
72305: LD_INT 21
72307: PUSH
72308: LD_INT 3
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: LIST
72323: PPUSH
72324: CALL_OW 69
72328: ST_TO_ADDR
// if not tmp then
72329: LD_VAR 0 8
72333: NOT
72334: IFFALSE 72338
// exit ;
72336: GO 73892
// for i in tmp do
72338: LD_ADDR_VAR 0 6
72342: PUSH
72343: LD_VAR 0 8
72347: PUSH
72348: FOR_IN
72349: IFFALSE 73867
// begin points := [ 0 , 0 , 0 ] ;
72351: LD_ADDR_VAR 0 9
72355: PUSH
72356: LD_INT 0
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: LD_INT 0
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: LIST
72369: ST_TO_ADDR
// bpoints := 1 ;
72370: LD_ADDR_VAR 0 10
72374: PUSH
72375: LD_INT 1
72377: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72378: LD_VAR 0 6
72382: PPUSH
72383: CALL_OW 247
72387: PUSH
72388: LD_INT 1
72390: DOUBLE
72391: EQUAL
72392: IFTRUE 72396
72394: GO 72974
72396: POP
// begin if GetClass ( i ) = 1 then
72397: LD_VAR 0 6
72401: PPUSH
72402: CALL_OW 257
72406: PUSH
72407: LD_INT 1
72409: EQUAL
72410: IFFALSE 72431
// points := [ 10 , 5 , 3 ] ;
72412: LD_ADDR_VAR 0 9
72416: PUSH
72417: LD_INT 10
72419: PUSH
72420: LD_INT 5
72422: PUSH
72423: LD_INT 3
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: LIST
72430: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72431: LD_VAR 0 6
72435: PPUSH
72436: CALL_OW 257
72440: PUSH
72441: LD_INT 2
72443: PUSH
72444: LD_INT 3
72446: PUSH
72447: LD_INT 4
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: LIST
72454: IN
72455: IFFALSE 72476
// points := [ 3 , 2 , 1 ] ;
72457: LD_ADDR_VAR 0 9
72461: PUSH
72462: LD_INT 3
72464: PUSH
72465: LD_INT 2
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: LIST
72475: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72476: LD_VAR 0 6
72480: PPUSH
72481: CALL_OW 257
72485: PUSH
72486: LD_INT 5
72488: EQUAL
72489: IFFALSE 72510
// points := [ 130 , 5 , 2 ] ;
72491: LD_ADDR_VAR 0 9
72495: PUSH
72496: LD_INT 130
72498: PUSH
72499: LD_INT 5
72501: PUSH
72502: LD_INT 2
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: LIST
72509: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72510: LD_VAR 0 6
72514: PPUSH
72515: CALL_OW 257
72519: PUSH
72520: LD_INT 8
72522: EQUAL
72523: IFFALSE 72544
// points := [ 35 , 35 , 30 ] ;
72525: LD_ADDR_VAR 0 9
72529: PUSH
72530: LD_INT 35
72532: PUSH
72533: LD_INT 35
72535: PUSH
72536: LD_INT 30
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: LIST
72543: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72544: LD_VAR 0 6
72548: PPUSH
72549: CALL_OW 257
72553: PUSH
72554: LD_INT 9
72556: EQUAL
72557: IFFALSE 72578
// points := [ 20 , 55 , 40 ] ;
72559: LD_ADDR_VAR 0 9
72563: PUSH
72564: LD_INT 20
72566: PUSH
72567: LD_INT 55
72569: PUSH
72570: LD_INT 40
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: LIST
72577: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72578: LD_VAR 0 6
72582: PPUSH
72583: CALL_OW 257
72587: PUSH
72588: LD_INT 12
72590: PUSH
72591: LD_INT 16
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: IN
72598: IFFALSE 72619
// points := [ 5 , 3 , 2 ] ;
72600: LD_ADDR_VAR 0 9
72604: PUSH
72605: LD_INT 5
72607: PUSH
72608: LD_INT 3
72610: PUSH
72611: LD_INT 2
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: LIST
72618: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72619: LD_VAR 0 6
72623: PPUSH
72624: CALL_OW 257
72628: PUSH
72629: LD_INT 17
72631: EQUAL
72632: IFFALSE 72653
// points := [ 100 , 50 , 75 ] ;
72634: LD_ADDR_VAR 0 9
72638: PUSH
72639: LD_INT 100
72641: PUSH
72642: LD_INT 50
72644: PUSH
72645: LD_INT 75
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: LIST
72652: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72653: LD_VAR 0 6
72657: PPUSH
72658: CALL_OW 257
72662: PUSH
72663: LD_INT 15
72665: EQUAL
72666: IFFALSE 72687
// points := [ 10 , 5 , 3 ] ;
72668: LD_ADDR_VAR 0 9
72672: PUSH
72673: LD_INT 10
72675: PUSH
72676: LD_INT 5
72678: PUSH
72679: LD_INT 3
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: LIST
72686: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72687: LD_VAR 0 6
72691: PPUSH
72692: CALL_OW 257
72696: PUSH
72697: LD_INT 14
72699: EQUAL
72700: IFFALSE 72721
// points := [ 10 , 0 , 0 ] ;
72702: LD_ADDR_VAR 0 9
72706: PUSH
72707: LD_INT 10
72709: PUSH
72710: LD_INT 0
72712: PUSH
72713: LD_INT 0
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: LIST
72720: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72721: LD_VAR 0 6
72725: PPUSH
72726: CALL_OW 257
72730: PUSH
72731: LD_INT 11
72733: EQUAL
72734: IFFALSE 72755
// points := [ 30 , 10 , 5 ] ;
72736: LD_ADDR_VAR 0 9
72740: PUSH
72741: LD_INT 30
72743: PUSH
72744: LD_INT 10
72746: PUSH
72747: LD_INT 5
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: LIST
72754: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72755: LD_VAR 0 1
72759: PPUSH
72760: LD_INT 5
72762: PPUSH
72763: CALL_OW 321
72767: PUSH
72768: LD_INT 2
72770: EQUAL
72771: IFFALSE 72788
// bpoints := bpoints * 1.8 ;
72773: LD_ADDR_VAR 0 10
72777: PUSH
72778: LD_VAR 0 10
72782: PUSH
72783: LD_REAL  1.80000000000000E+0000
72786: MUL
72787: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72788: LD_VAR 0 6
72792: PPUSH
72793: CALL_OW 257
72797: PUSH
72798: LD_INT 1
72800: PUSH
72801: LD_INT 2
72803: PUSH
72804: LD_INT 3
72806: PUSH
72807: LD_INT 4
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: IN
72816: PUSH
72817: LD_VAR 0 1
72821: PPUSH
72822: LD_INT 51
72824: PPUSH
72825: CALL_OW 321
72829: PUSH
72830: LD_INT 2
72832: EQUAL
72833: AND
72834: IFFALSE 72851
// bpoints := bpoints * 1.2 ;
72836: LD_ADDR_VAR 0 10
72840: PUSH
72841: LD_VAR 0 10
72845: PUSH
72846: LD_REAL  1.20000000000000E+0000
72849: MUL
72850: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72851: LD_VAR 0 6
72855: PPUSH
72856: CALL_OW 257
72860: PUSH
72861: LD_INT 5
72863: PUSH
72864: LD_INT 7
72866: PUSH
72867: LD_INT 9
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: LIST
72874: IN
72875: PUSH
72876: LD_VAR 0 1
72880: PPUSH
72881: LD_INT 52
72883: PPUSH
72884: CALL_OW 321
72888: PUSH
72889: LD_INT 2
72891: EQUAL
72892: AND
72893: IFFALSE 72910
// bpoints := bpoints * 1.5 ;
72895: LD_ADDR_VAR 0 10
72899: PUSH
72900: LD_VAR 0 10
72904: PUSH
72905: LD_REAL  1.50000000000000E+0000
72908: MUL
72909: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72910: LD_VAR 0 1
72914: PPUSH
72915: LD_INT 66
72917: PPUSH
72918: CALL_OW 321
72922: PUSH
72923: LD_INT 2
72925: EQUAL
72926: IFFALSE 72943
// bpoints := bpoints * 1.1 ;
72928: LD_ADDR_VAR 0 10
72932: PUSH
72933: LD_VAR 0 10
72937: PUSH
72938: LD_REAL  1.10000000000000E+0000
72941: MUL
72942: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72943: LD_ADDR_VAR 0 10
72947: PUSH
72948: LD_VAR 0 10
72952: PUSH
72953: LD_VAR 0 6
72957: PPUSH
72958: LD_INT 1
72960: PPUSH
72961: CALL_OW 259
72965: PUSH
72966: LD_REAL  1.15000000000000E+0000
72969: MUL
72970: MUL
72971: ST_TO_ADDR
// end ; unit_vehicle :
72972: GO 73796
72974: LD_INT 2
72976: DOUBLE
72977: EQUAL
72978: IFTRUE 72982
72980: GO 73784
72982: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72983: LD_VAR 0 6
72987: PPUSH
72988: CALL_OW 264
72992: PUSH
72993: LD_INT 2
72995: PUSH
72996: LD_INT 42
72998: PUSH
72999: LD_INT 24
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: LIST
73006: IN
73007: IFFALSE 73028
// points := [ 25 , 5 , 3 ] ;
73009: LD_ADDR_VAR 0 9
73013: PUSH
73014: LD_INT 25
73016: PUSH
73017: LD_INT 5
73019: PUSH
73020: LD_INT 3
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: LIST
73027: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73028: LD_VAR 0 6
73032: PPUSH
73033: CALL_OW 264
73037: PUSH
73038: LD_INT 4
73040: PUSH
73041: LD_INT 43
73043: PUSH
73044: LD_INT 25
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: LIST
73051: IN
73052: IFFALSE 73073
// points := [ 40 , 15 , 5 ] ;
73054: LD_ADDR_VAR 0 9
73058: PUSH
73059: LD_INT 40
73061: PUSH
73062: LD_INT 15
73064: PUSH
73065: LD_INT 5
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: LIST
73072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73073: LD_VAR 0 6
73077: PPUSH
73078: CALL_OW 264
73082: PUSH
73083: LD_INT 3
73085: PUSH
73086: LD_INT 23
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: IN
73093: IFFALSE 73114
// points := [ 7 , 25 , 8 ] ;
73095: LD_ADDR_VAR 0 9
73099: PUSH
73100: LD_INT 7
73102: PUSH
73103: LD_INT 25
73105: PUSH
73106: LD_INT 8
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: LIST
73113: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73114: LD_VAR 0 6
73118: PPUSH
73119: CALL_OW 264
73123: PUSH
73124: LD_INT 5
73126: PUSH
73127: LD_INT 27
73129: PUSH
73130: LD_INT 44
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: LIST
73137: IN
73138: IFFALSE 73159
// points := [ 14 , 50 , 16 ] ;
73140: LD_ADDR_VAR 0 9
73144: PUSH
73145: LD_INT 14
73147: PUSH
73148: LD_INT 50
73150: PUSH
73151: LD_INT 16
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: LIST
73158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73159: LD_VAR 0 6
73163: PPUSH
73164: CALL_OW 264
73168: PUSH
73169: LD_INT 6
73171: PUSH
73172: LD_INT 46
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: IN
73179: IFFALSE 73200
// points := [ 32 , 120 , 70 ] ;
73181: LD_ADDR_VAR 0 9
73185: PUSH
73186: LD_INT 32
73188: PUSH
73189: LD_INT 120
73191: PUSH
73192: LD_INT 70
73194: PUSH
73195: EMPTY
73196: LIST
73197: LIST
73198: LIST
73199: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73200: LD_VAR 0 6
73204: PPUSH
73205: CALL_OW 264
73209: PUSH
73210: LD_INT 7
73212: PUSH
73213: LD_INT 28
73215: PUSH
73216: LD_INT 45
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: LIST
73223: IN
73224: IFFALSE 73245
// points := [ 35 , 20 , 45 ] ;
73226: LD_ADDR_VAR 0 9
73230: PUSH
73231: LD_INT 35
73233: PUSH
73234: LD_INT 20
73236: PUSH
73237: LD_INT 45
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: LIST
73244: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73245: LD_VAR 0 6
73249: PPUSH
73250: CALL_OW 264
73254: PUSH
73255: LD_INT 47
73257: PUSH
73258: EMPTY
73259: LIST
73260: IN
73261: IFFALSE 73282
// points := [ 67 , 45 , 75 ] ;
73263: LD_ADDR_VAR 0 9
73267: PUSH
73268: LD_INT 67
73270: PUSH
73271: LD_INT 45
73273: PUSH
73274: LD_INT 75
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: LIST
73281: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73282: LD_VAR 0 6
73286: PPUSH
73287: CALL_OW 264
73291: PUSH
73292: LD_INT 26
73294: PUSH
73295: EMPTY
73296: LIST
73297: IN
73298: IFFALSE 73319
// points := [ 120 , 30 , 80 ] ;
73300: LD_ADDR_VAR 0 9
73304: PUSH
73305: LD_INT 120
73307: PUSH
73308: LD_INT 30
73310: PUSH
73311: LD_INT 80
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: LIST
73318: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73319: LD_VAR 0 6
73323: PPUSH
73324: CALL_OW 264
73328: PUSH
73329: LD_INT 22
73331: PUSH
73332: EMPTY
73333: LIST
73334: IN
73335: IFFALSE 73356
// points := [ 40 , 1 , 1 ] ;
73337: LD_ADDR_VAR 0 9
73341: PUSH
73342: LD_INT 40
73344: PUSH
73345: LD_INT 1
73347: PUSH
73348: LD_INT 1
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: LIST
73355: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73356: LD_VAR 0 6
73360: PPUSH
73361: CALL_OW 264
73365: PUSH
73366: LD_INT 29
73368: PUSH
73369: EMPTY
73370: LIST
73371: IN
73372: IFFALSE 73393
// points := [ 70 , 200 , 400 ] ;
73374: LD_ADDR_VAR 0 9
73378: PUSH
73379: LD_INT 70
73381: PUSH
73382: LD_INT 200
73384: PUSH
73385: LD_INT 400
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: LIST
73392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73393: LD_VAR 0 6
73397: PPUSH
73398: CALL_OW 264
73402: PUSH
73403: LD_INT 14
73405: PUSH
73406: LD_INT 53
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: IN
73413: IFFALSE 73434
// points := [ 40 , 10 , 20 ] ;
73415: LD_ADDR_VAR 0 9
73419: PUSH
73420: LD_INT 40
73422: PUSH
73423: LD_INT 10
73425: PUSH
73426: LD_INT 20
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: LIST
73433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73434: LD_VAR 0 6
73438: PPUSH
73439: CALL_OW 264
73443: PUSH
73444: LD_INT 9
73446: PUSH
73447: EMPTY
73448: LIST
73449: IN
73450: IFFALSE 73471
// points := [ 5 , 70 , 20 ] ;
73452: LD_ADDR_VAR 0 9
73456: PUSH
73457: LD_INT 5
73459: PUSH
73460: LD_INT 70
73462: PUSH
73463: LD_INT 20
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: LIST
73470: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73471: LD_VAR 0 6
73475: PPUSH
73476: CALL_OW 264
73480: PUSH
73481: LD_INT 10
73483: PUSH
73484: EMPTY
73485: LIST
73486: IN
73487: IFFALSE 73508
// points := [ 35 , 110 , 70 ] ;
73489: LD_ADDR_VAR 0 9
73493: PUSH
73494: LD_INT 35
73496: PUSH
73497: LD_INT 110
73499: PUSH
73500: LD_INT 70
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: LIST
73507: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73508: LD_VAR 0 6
73512: PPUSH
73513: CALL_OW 265
73517: PUSH
73518: LD_INT 25
73520: EQUAL
73521: IFFALSE 73542
// points := [ 80 , 65 , 100 ] ;
73523: LD_ADDR_VAR 0 9
73527: PUSH
73528: LD_INT 80
73530: PUSH
73531: LD_INT 65
73533: PUSH
73534: LD_INT 100
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: LIST
73541: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73542: LD_VAR 0 6
73546: PPUSH
73547: CALL_OW 263
73551: PUSH
73552: LD_INT 1
73554: EQUAL
73555: IFFALSE 73590
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73557: LD_ADDR_VAR 0 10
73561: PUSH
73562: LD_VAR 0 10
73566: PUSH
73567: LD_VAR 0 6
73571: PPUSH
73572: CALL_OW 311
73576: PPUSH
73577: LD_INT 3
73579: PPUSH
73580: CALL_OW 259
73584: PUSH
73585: LD_INT 4
73587: MUL
73588: MUL
73589: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73590: LD_VAR 0 6
73594: PPUSH
73595: CALL_OW 263
73599: PUSH
73600: LD_INT 2
73602: EQUAL
73603: IFFALSE 73654
// begin j := IsControledBy ( i ) ;
73605: LD_ADDR_VAR 0 7
73609: PUSH
73610: LD_VAR 0 6
73614: PPUSH
73615: CALL_OW 312
73619: ST_TO_ADDR
// if j then
73620: LD_VAR 0 7
73624: IFFALSE 73654
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73626: LD_ADDR_VAR 0 10
73630: PUSH
73631: LD_VAR 0 10
73635: PUSH
73636: LD_VAR 0 7
73640: PPUSH
73641: LD_INT 3
73643: PPUSH
73644: CALL_OW 259
73648: PUSH
73649: LD_INT 3
73651: MUL
73652: MUL
73653: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73654: LD_VAR 0 6
73658: PPUSH
73659: CALL_OW 264
73663: PUSH
73664: LD_INT 5
73666: PUSH
73667: LD_INT 6
73669: PUSH
73670: LD_INT 46
73672: PUSH
73673: LD_INT 44
73675: PUSH
73676: LD_INT 47
73678: PUSH
73679: LD_INT 45
73681: PUSH
73682: LD_INT 28
73684: PUSH
73685: LD_INT 7
73687: PUSH
73688: LD_INT 27
73690: PUSH
73691: LD_INT 29
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: IN
73706: PUSH
73707: LD_VAR 0 1
73711: PPUSH
73712: LD_INT 52
73714: PPUSH
73715: CALL_OW 321
73719: PUSH
73720: LD_INT 2
73722: EQUAL
73723: AND
73724: IFFALSE 73741
// bpoints := bpoints * 1.2 ;
73726: LD_ADDR_VAR 0 10
73730: PUSH
73731: LD_VAR 0 10
73735: PUSH
73736: LD_REAL  1.20000000000000E+0000
73739: MUL
73740: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73741: LD_VAR 0 6
73745: PPUSH
73746: CALL_OW 264
73750: PUSH
73751: LD_INT 6
73753: PUSH
73754: LD_INT 46
73756: PUSH
73757: LD_INT 47
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: LIST
73764: IN
73765: IFFALSE 73782
// bpoints := bpoints * 1.2 ;
73767: LD_ADDR_VAR 0 10
73771: PUSH
73772: LD_VAR 0 10
73776: PUSH
73777: LD_REAL  1.20000000000000E+0000
73780: MUL
73781: ST_TO_ADDR
// end ; unit_building :
73782: GO 73796
73784: LD_INT 3
73786: DOUBLE
73787: EQUAL
73788: IFTRUE 73792
73790: GO 73795
73792: POP
// ; end ;
73793: GO 73796
73795: POP
// for j = 1 to 3 do
73796: LD_ADDR_VAR 0 7
73800: PUSH
73801: DOUBLE
73802: LD_INT 1
73804: DEC
73805: ST_TO_ADDR
73806: LD_INT 3
73808: PUSH
73809: FOR_TO
73810: IFFALSE 73863
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73812: LD_ADDR_VAR 0 5
73816: PUSH
73817: LD_VAR 0 5
73821: PPUSH
73822: LD_VAR 0 7
73826: PPUSH
73827: LD_VAR 0 5
73831: PUSH
73832: LD_VAR 0 7
73836: ARRAY
73837: PUSH
73838: LD_VAR 0 9
73842: PUSH
73843: LD_VAR 0 7
73847: ARRAY
73848: PUSH
73849: LD_VAR 0 10
73853: MUL
73854: PLUS
73855: PPUSH
73856: CALL_OW 1
73860: ST_TO_ADDR
73861: GO 73809
73863: POP
73864: POP
// end ;
73865: GO 72348
73867: POP
73868: POP
// result := Replace ( result , 4 , tmp ) ;
73869: LD_ADDR_VAR 0 5
73873: PUSH
73874: LD_VAR 0 5
73878: PPUSH
73879: LD_INT 4
73881: PPUSH
73882: LD_VAR 0 8
73886: PPUSH
73887: CALL_OW 1
73891: ST_TO_ADDR
// end ;
73892: LD_VAR 0 5
73896: RET
// export function DangerAtRange ( unit , range ) ; begin
73897: LD_INT 0
73899: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73900: LD_ADDR_VAR 0 3
73904: PUSH
73905: LD_VAR 0 1
73909: PPUSH
73910: CALL_OW 255
73914: PPUSH
73915: LD_VAR 0 1
73919: PPUSH
73920: CALL_OW 250
73924: PPUSH
73925: LD_VAR 0 1
73929: PPUSH
73930: CALL_OW 251
73934: PPUSH
73935: LD_VAR 0 2
73939: PPUSH
73940: CALL 72200 0 4
73944: ST_TO_ADDR
// end ;
73945: LD_VAR 0 3
73949: RET
// export function DangerInArea ( side , area ) ; begin
73950: LD_INT 0
73952: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73953: LD_ADDR_VAR 0 3
73957: PUSH
73958: LD_VAR 0 2
73962: PPUSH
73963: LD_INT 81
73965: PUSH
73966: LD_VAR 0 1
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PPUSH
73975: CALL_OW 70
73979: ST_TO_ADDR
// end ;
73980: LD_VAR 0 3
73984: RET
// export function IsExtension ( b ) ; begin
73985: LD_INT 0
73987: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73988: LD_ADDR_VAR 0 2
73992: PUSH
73993: LD_VAR 0 1
73997: PUSH
73998: LD_INT 23
74000: PUSH
74001: LD_INT 20
74003: PUSH
74004: LD_INT 22
74006: PUSH
74007: LD_INT 17
74009: PUSH
74010: LD_INT 24
74012: PUSH
74013: LD_INT 21
74015: PUSH
74016: LD_INT 19
74018: PUSH
74019: LD_INT 16
74021: PUSH
74022: LD_INT 25
74024: PUSH
74025: LD_INT 18
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: LIST
74032: LIST
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: IN
74040: ST_TO_ADDR
// end ;
74041: LD_VAR 0 2
74045: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74046: LD_INT 0
74048: PPUSH
74049: PPUSH
74050: PPUSH
// result := [ ] ;
74051: LD_ADDR_VAR 0 3
74055: PUSH
74056: EMPTY
74057: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74058: LD_ADDR_VAR 0 4
74062: PUSH
74063: LD_VAR 0 2
74067: PPUSH
74068: LD_INT 21
74070: PUSH
74071: LD_INT 3
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PPUSH
74078: CALL_OW 70
74082: ST_TO_ADDR
// if not tmp then
74083: LD_VAR 0 4
74087: NOT
74088: IFFALSE 74092
// exit ;
74090: GO 74150
// for i in tmp do
74092: LD_ADDR_VAR 0 5
74096: PUSH
74097: LD_VAR 0 4
74101: PUSH
74102: FOR_IN
74103: IFFALSE 74138
// if GetBase ( i ) <> base then
74105: LD_VAR 0 5
74109: PPUSH
74110: CALL_OW 274
74114: PUSH
74115: LD_VAR 0 1
74119: NONEQUAL
74120: IFFALSE 74136
// ComLinkToBase ( base , i ) ;
74122: LD_VAR 0 1
74126: PPUSH
74127: LD_VAR 0 5
74131: PPUSH
74132: CALL_OW 169
74136: GO 74102
74138: POP
74139: POP
// result := tmp ;
74140: LD_ADDR_VAR 0 3
74144: PUSH
74145: LD_VAR 0 4
74149: ST_TO_ADDR
// end ;
74150: LD_VAR 0 3
74154: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74155: LD_INT 0
74157: PPUSH
74158: PPUSH
// if BuildingStatus ( b ) = bs_build then
74159: LD_VAR 0 2
74163: PPUSH
74164: CALL_OW 461
74168: PUSH
74169: LD_INT 1
74171: EQUAL
74172: IFFALSE 74232
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74174: LD_VAR 0 1
74178: PPUSH
74179: LD_STRING h
74181: PUSH
74182: LD_VAR 0 2
74186: PPUSH
74187: CALL_OW 250
74191: PUSH
74192: LD_VAR 0 2
74196: PPUSH
74197: CALL_OW 251
74201: PUSH
74202: LD_VAR 0 2
74206: PUSH
74207: LD_INT 0
74209: PUSH
74210: LD_INT 0
74212: PUSH
74213: LD_INT 0
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: LIST
74220: LIST
74221: LIST
74222: LIST
74223: LIST
74224: PUSH
74225: EMPTY
74226: LIST
74227: PPUSH
74228: CALL_OW 446
// end ;
74232: LD_VAR 0 3
74236: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74237: LD_INT 0
74239: PPUSH
74240: PPUSH
74241: PPUSH
74242: PPUSH
74243: PPUSH
74244: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74245: LD_VAR 0 1
74249: NOT
74250: PUSH
74251: LD_VAR 0 1
74255: PPUSH
74256: CALL_OW 263
74260: PUSH
74261: LD_INT 2
74263: EQUAL
74264: NOT
74265: OR
74266: IFFALSE 74270
// exit ;
74268: GO 74586
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74270: LD_ADDR_VAR 0 6
74274: PUSH
74275: LD_INT 22
74277: PUSH
74278: LD_VAR 0 1
74282: PPUSH
74283: CALL_OW 255
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 2
74294: PUSH
74295: LD_INT 30
74297: PUSH
74298: LD_INT 36
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: LD_INT 34
74307: PUSH
74308: LD_INT 31
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: LIST
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PPUSH
74324: CALL_OW 69
74328: ST_TO_ADDR
// if not tmp then
74329: LD_VAR 0 6
74333: NOT
74334: IFFALSE 74338
// exit ;
74336: GO 74586
// result := [ ] ;
74338: LD_ADDR_VAR 0 2
74342: PUSH
74343: EMPTY
74344: ST_TO_ADDR
// for i in tmp do
74345: LD_ADDR_VAR 0 3
74349: PUSH
74350: LD_VAR 0 6
74354: PUSH
74355: FOR_IN
74356: IFFALSE 74427
// begin t := UnitsInside ( i ) ;
74358: LD_ADDR_VAR 0 4
74362: PUSH
74363: LD_VAR 0 3
74367: PPUSH
74368: CALL_OW 313
74372: ST_TO_ADDR
// if t then
74373: LD_VAR 0 4
74377: IFFALSE 74425
// for j in t do
74379: LD_ADDR_VAR 0 7
74383: PUSH
74384: LD_VAR 0 4
74388: PUSH
74389: FOR_IN
74390: IFFALSE 74423
// result := Insert ( result , result + 1 , j ) ;
74392: LD_ADDR_VAR 0 2
74396: PUSH
74397: LD_VAR 0 2
74401: PPUSH
74402: LD_VAR 0 2
74406: PUSH
74407: LD_INT 1
74409: PLUS
74410: PPUSH
74411: LD_VAR 0 7
74415: PPUSH
74416: CALL_OW 2
74420: ST_TO_ADDR
74421: GO 74389
74423: POP
74424: POP
// end ;
74425: GO 74355
74427: POP
74428: POP
// if not result then
74429: LD_VAR 0 2
74433: NOT
74434: IFFALSE 74438
// exit ;
74436: GO 74586
// mech := result [ 1 ] ;
74438: LD_ADDR_VAR 0 5
74442: PUSH
74443: LD_VAR 0 2
74447: PUSH
74448: LD_INT 1
74450: ARRAY
74451: ST_TO_ADDR
// if result > 1 then
74452: LD_VAR 0 2
74456: PUSH
74457: LD_INT 1
74459: GREATER
74460: IFFALSE 74572
// for i = 2 to result do
74462: LD_ADDR_VAR 0 3
74466: PUSH
74467: DOUBLE
74468: LD_INT 2
74470: DEC
74471: ST_TO_ADDR
74472: LD_VAR 0 2
74476: PUSH
74477: FOR_TO
74478: IFFALSE 74570
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74480: LD_ADDR_VAR 0 4
74484: PUSH
74485: LD_VAR 0 2
74489: PUSH
74490: LD_VAR 0 3
74494: ARRAY
74495: PPUSH
74496: LD_INT 3
74498: PPUSH
74499: CALL_OW 259
74503: PUSH
74504: LD_VAR 0 2
74508: PUSH
74509: LD_VAR 0 3
74513: ARRAY
74514: PPUSH
74515: CALL_OW 432
74519: MINUS
74520: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74521: LD_VAR 0 4
74525: PUSH
74526: LD_VAR 0 5
74530: PPUSH
74531: LD_INT 3
74533: PPUSH
74534: CALL_OW 259
74538: PUSH
74539: LD_VAR 0 5
74543: PPUSH
74544: CALL_OW 432
74548: MINUS
74549: GREATEREQUAL
74550: IFFALSE 74568
// mech := result [ i ] ;
74552: LD_ADDR_VAR 0 5
74556: PUSH
74557: LD_VAR 0 2
74561: PUSH
74562: LD_VAR 0 3
74566: ARRAY
74567: ST_TO_ADDR
// end ;
74568: GO 74477
74570: POP
74571: POP
// ComLinkTo ( vehicle , mech ) ;
74572: LD_VAR 0 1
74576: PPUSH
74577: LD_VAR 0 5
74581: PPUSH
74582: CALL_OW 135
// end ;
74586: LD_VAR 0 2
74590: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74591: LD_INT 0
74593: PPUSH
74594: PPUSH
74595: PPUSH
74596: PPUSH
74597: PPUSH
74598: PPUSH
74599: PPUSH
74600: PPUSH
74601: PPUSH
74602: PPUSH
74603: PPUSH
74604: PPUSH
74605: PPUSH
// result := [ ] ;
74606: LD_ADDR_VAR 0 7
74610: PUSH
74611: EMPTY
74612: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74613: LD_VAR 0 1
74617: PPUSH
74618: CALL_OW 266
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: LD_INT 1
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: IN
74633: NOT
74634: IFFALSE 74638
// exit ;
74636: GO 76269
// if name then
74638: LD_VAR 0 3
74642: IFFALSE 74658
// SetBName ( base_dep , name ) ;
74644: LD_VAR 0 1
74648: PPUSH
74649: LD_VAR 0 3
74653: PPUSH
74654: CALL_OW 500
// base := GetBase ( base_dep ) ;
74658: LD_ADDR_VAR 0 15
74662: PUSH
74663: LD_VAR 0 1
74667: PPUSH
74668: CALL_OW 274
74672: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74673: LD_ADDR_VAR 0 16
74677: PUSH
74678: LD_VAR 0 1
74682: PPUSH
74683: CALL_OW 255
74687: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74688: LD_ADDR_VAR 0 17
74692: PUSH
74693: LD_VAR 0 1
74697: PPUSH
74698: CALL_OW 248
74702: ST_TO_ADDR
// if sources then
74703: LD_VAR 0 5
74707: IFFALSE 74754
// for i = 1 to 3 do
74709: LD_ADDR_VAR 0 8
74713: PUSH
74714: DOUBLE
74715: LD_INT 1
74717: DEC
74718: ST_TO_ADDR
74719: LD_INT 3
74721: PUSH
74722: FOR_TO
74723: IFFALSE 74752
// AddResourceType ( base , i , sources [ i ] ) ;
74725: LD_VAR 0 15
74729: PPUSH
74730: LD_VAR 0 8
74734: PPUSH
74735: LD_VAR 0 5
74739: PUSH
74740: LD_VAR 0 8
74744: ARRAY
74745: PPUSH
74746: CALL_OW 276
74750: GO 74722
74752: POP
74753: POP
// buildings := GetBaseBuildings ( base , area ) ;
74754: LD_ADDR_VAR 0 18
74758: PUSH
74759: LD_VAR 0 15
74763: PPUSH
74764: LD_VAR 0 2
74768: PPUSH
74769: CALL 74046 0 2
74773: ST_TO_ADDR
// InitHc ;
74774: CALL_OW 19
// InitUc ;
74778: CALL_OW 18
// uc_side := side ;
74782: LD_ADDR_OWVAR 20
74786: PUSH
74787: LD_VAR 0 16
74791: ST_TO_ADDR
// uc_nation := nation ;
74792: LD_ADDR_OWVAR 21
74796: PUSH
74797: LD_VAR 0 17
74801: ST_TO_ADDR
// if buildings then
74802: LD_VAR 0 18
74806: IFFALSE 76128
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74808: LD_ADDR_VAR 0 19
74812: PUSH
74813: LD_VAR 0 18
74817: PPUSH
74818: LD_INT 2
74820: PUSH
74821: LD_INT 30
74823: PUSH
74824: LD_INT 29
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 30
74833: PUSH
74834: LD_INT 30
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: LIST
74845: PPUSH
74846: CALL_OW 72
74850: ST_TO_ADDR
// if tmp then
74851: LD_VAR 0 19
74855: IFFALSE 74903
// for i in tmp do
74857: LD_ADDR_VAR 0 8
74861: PUSH
74862: LD_VAR 0 19
74866: PUSH
74867: FOR_IN
74868: IFFALSE 74901
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74870: LD_VAR 0 8
74874: PPUSH
74875: CALL_OW 250
74879: PPUSH
74880: LD_VAR 0 8
74884: PPUSH
74885: CALL_OW 251
74889: PPUSH
74890: LD_VAR 0 16
74894: PPUSH
74895: CALL_OW 441
74899: GO 74867
74901: POP
74902: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74903: LD_VAR 0 18
74907: PPUSH
74908: LD_INT 2
74910: PUSH
74911: LD_INT 30
74913: PUSH
74914: LD_INT 32
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 30
74923: PUSH
74924: LD_INT 33
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: LIST
74935: PPUSH
74936: CALL_OW 72
74940: IFFALSE 75028
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74942: LD_ADDR_VAR 0 8
74946: PUSH
74947: LD_VAR 0 18
74951: PPUSH
74952: LD_INT 2
74954: PUSH
74955: LD_INT 30
74957: PUSH
74958: LD_INT 32
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 30
74967: PUSH
74968: LD_INT 33
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: LIST
74979: PPUSH
74980: CALL_OW 72
74984: PUSH
74985: FOR_IN
74986: IFFALSE 75026
// begin if not GetBWeapon ( i ) then
74988: LD_VAR 0 8
74992: PPUSH
74993: CALL_OW 269
74997: NOT
74998: IFFALSE 75024
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75000: LD_VAR 0 8
75004: PPUSH
75005: LD_VAR 0 8
75009: PPUSH
75010: LD_VAR 0 2
75014: PPUSH
75015: CALL 76274 0 2
75019: PPUSH
75020: CALL_OW 431
// end ;
75024: GO 74985
75026: POP
75027: POP
// end ; for i = 1 to personel do
75028: LD_ADDR_VAR 0 8
75032: PUSH
75033: DOUBLE
75034: LD_INT 1
75036: DEC
75037: ST_TO_ADDR
75038: LD_VAR 0 6
75042: PUSH
75043: FOR_TO
75044: IFFALSE 76108
// begin if i > 4 then
75046: LD_VAR 0 8
75050: PUSH
75051: LD_INT 4
75053: GREATER
75054: IFFALSE 75058
// break ;
75056: GO 76108
// case i of 1 :
75058: LD_VAR 0 8
75062: PUSH
75063: LD_INT 1
75065: DOUBLE
75066: EQUAL
75067: IFTRUE 75071
75069: GO 75151
75071: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75072: LD_ADDR_VAR 0 12
75076: PUSH
75077: LD_VAR 0 18
75081: PPUSH
75082: LD_INT 22
75084: PUSH
75085: LD_VAR 0 16
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 58
75096: PUSH
75097: EMPTY
75098: LIST
75099: PUSH
75100: LD_INT 2
75102: PUSH
75103: LD_INT 30
75105: PUSH
75106: LD_INT 32
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 30
75115: PUSH
75116: LD_INT 4
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: LD_INT 30
75125: PUSH
75126: LD_INT 5
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: PPUSH
75144: CALL_OW 72
75148: ST_TO_ADDR
75149: GO 75373
75151: LD_INT 2
75153: DOUBLE
75154: EQUAL
75155: IFTRUE 75159
75157: GO 75221
75159: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75160: LD_ADDR_VAR 0 12
75164: PUSH
75165: LD_VAR 0 18
75169: PPUSH
75170: LD_INT 22
75172: PUSH
75173: LD_VAR 0 16
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 2
75184: PUSH
75185: LD_INT 30
75187: PUSH
75188: LD_INT 0
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: LD_INT 30
75197: PUSH
75198: LD_INT 1
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: LIST
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PPUSH
75214: CALL_OW 72
75218: ST_TO_ADDR
75219: GO 75373
75221: LD_INT 3
75223: DOUBLE
75224: EQUAL
75225: IFTRUE 75229
75227: GO 75291
75229: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75230: LD_ADDR_VAR 0 12
75234: PUSH
75235: LD_VAR 0 18
75239: PPUSH
75240: LD_INT 22
75242: PUSH
75243: LD_VAR 0 16
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 2
75254: PUSH
75255: LD_INT 30
75257: PUSH
75258: LD_INT 2
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 30
75267: PUSH
75268: LD_INT 3
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: LIST
75279: PUSH
75280: EMPTY
75281: LIST
75282: LIST
75283: PPUSH
75284: CALL_OW 72
75288: ST_TO_ADDR
75289: GO 75373
75291: LD_INT 4
75293: DOUBLE
75294: EQUAL
75295: IFTRUE 75299
75297: GO 75372
75299: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75300: LD_ADDR_VAR 0 12
75304: PUSH
75305: LD_VAR 0 18
75309: PPUSH
75310: LD_INT 22
75312: PUSH
75313: LD_VAR 0 16
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 2
75324: PUSH
75325: LD_INT 30
75327: PUSH
75328: LD_INT 6
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: PUSH
75335: LD_INT 30
75337: PUSH
75338: LD_INT 7
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 30
75347: PUSH
75348: LD_INT 8
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PPUSH
75365: CALL_OW 72
75369: ST_TO_ADDR
75370: GO 75373
75372: POP
// if i = 1 then
75373: LD_VAR 0 8
75377: PUSH
75378: LD_INT 1
75380: EQUAL
75381: IFFALSE 75492
// begin tmp := [ ] ;
75383: LD_ADDR_VAR 0 19
75387: PUSH
75388: EMPTY
75389: ST_TO_ADDR
// for j in f do
75390: LD_ADDR_VAR 0 9
75394: PUSH
75395: LD_VAR 0 12
75399: PUSH
75400: FOR_IN
75401: IFFALSE 75474
// if GetBType ( j ) = b_bunker then
75403: LD_VAR 0 9
75407: PPUSH
75408: CALL_OW 266
75412: PUSH
75413: LD_INT 32
75415: EQUAL
75416: IFFALSE 75443
// tmp := Insert ( tmp , 1 , j ) else
75418: LD_ADDR_VAR 0 19
75422: PUSH
75423: LD_VAR 0 19
75427: PPUSH
75428: LD_INT 1
75430: PPUSH
75431: LD_VAR 0 9
75435: PPUSH
75436: CALL_OW 2
75440: ST_TO_ADDR
75441: GO 75472
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75443: LD_ADDR_VAR 0 19
75447: PUSH
75448: LD_VAR 0 19
75452: PPUSH
75453: LD_VAR 0 19
75457: PUSH
75458: LD_INT 1
75460: PLUS
75461: PPUSH
75462: LD_VAR 0 9
75466: PPUSH
75467: CALL_OW 2
75471: ST_TO_ADDR
75472: GO 75400
75474: POP
75475: POP
// if tmp then
75476: LD_VAR 0 19
75480: IFFALSE 75492
// f := tmp ;
75482: LD_ADDR_VAR 0 12
75486: PUSH
75487: LD_VAR 0 19
75491: ST_TO_ADDR
// end ; x := personel [ i ] ;
75492: LD_ADDR_VAR 0 13
75496: PUSH
75497: LD_VAR 0 6
75501: PUSH
75502: LD_VAR 0 8
75506: ARRAY
75507: ST_TO_ADDR
// if x = - 1 then
75508: LD_VAR 0 13
75512: PUSH
75513: LD_INT 1
75515: NEG
75516: EQUAL
75517: IFFALSE 75726
// begin for j in f do
75519: LD_ADDR_VAR 0 9
75523: PUSH
75524: LD_VAR 0 12
75528: PUSH
75529: FOR_IN
75530: IFFALSE 75722
// repeat InitHc ;
75532: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75536: LD_VAR 0 9
75540: PPUSH
75541: CALL_OW 266
75545: PUSH
75546: LD_INT 5
75548: EQUAL
75549: IFFALSE 75619
// begin if UnitsInside ( j ) < 3 then
75551: LD_VAR 0 9
75555: PPUSH
75556: CALL_OW 313
75560: PUSH
75561: LD_INT 3
75563: LESS
75564: IFFALSE 75600
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75566: LD_INT 0
75568: PPUSH
75569: LD_INT 5
75571: PUSH
75572: LD_INT 8
75574: PUSH
75575: LD_INT 9
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: LIST
75582: PUSH
75583: LD_VAR 0 17
75587: ARRAY
75588: PPUSH
75589: LD_VAR 0 4
75593: PPUSH
75594: CALL_OW 380
75598: GO 75617
// PrepareHuman ( false , i , skill ) ;
75600: LD_INT 0
75602: PPUSH
75603: LD_VAR 0 8
75607: PPUSH
75608: LD_VAR 0 4
75612: PPUSH
75613: CALL_OW 380
// end else
75617: GO 75636
// PrepareHuman ( false , i , skill ) ;
75619: LD_INT 0
75621: PPUSH
75622: LD_VAR 0 8
75626: PPUSH
75627: LD_VAR 0 4
75631: PPUSH
75632: CALL_OW 380
// un := CreateHuman ;
75636: LD_ADDR_VAR 0 14
75640: PUSH
75641: CALL_OW 44
75645: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75646: LD_ADDR_VAR 0 7
75650: PUSH
75651: LD_VAR 0 7
75655: PPUSH
75656: LD_INT 1
75658: PPUSH
75659: LD_VAR 0 14
75663: PPUSH
75664: CALL_OW 2
75668: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75669: LD_VAR 0 14
75673: PPUSH
75674: LD_VAR 0 9
75678: PPUSH
75679: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75683: LD_VAR 0 9
75687: PPUSH
75688: CALL_OW 313
75692: PUSH
75693: LD_INT 6
75695: EQUAL
75696: PUSH
75697: LD_VAR 0 9
75701: PPUSH
75702: CALL_OW 266
75706: PUSH
75707: LD_INT 32
75709: PUSH
75710: LD_INT 31
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: IN
75717: OR
75718: IFFALSE 75532
75720: GO 75529
75722: POP
75723: POP
// end else
75724: GO 76106
// for j = 1 to x do
75726: LD_ADDR_VAR 0 9
75730: PUSH
75731: DOUBLE
75732: LD_INT 1
75734: DEC
75735: ST_TO_ADDR
75736: LD_VAR 0 13
75740: PUSH
75741: FOR_TO
75742: IFFALSE 76104
// begin InitHc ;
75744: CALL_OW 19
// if not f then
75748: LD_VAR 0 12
75752: NOT
75753: IFFALSE 75842
// begin PrepareHuman ( false , i , skill ) ;
75755: LD_INT 0
75757: PPUSH
75758: LD_VAR 0 8
75762: PPUSH
75763: LD_VAR 0 4
75767: PPUSH
75768: CALL_OW 380
// un := CreateHuman ;
75772: LD_ADDR_VAR 0 14
75776: PUSH
75777: CALL_OW 44
75781: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75782: LD_ADDR_VAR 0 7
75786: PUSH
75787: LD_VAR 0 7
75791: PPUSH
75792: LD_INT 1
75794: PPUSH
75795: LD_VAR 0 14
75799: PPUSH
75800: CALL_OW 2
75804: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75805: LD_VAR 0 14
75809: PPUSH
75810: LD_VAR 0 1
75814: PPUSH
75815: CALL_OW 250
75819: PPUSH
75820: LD_VAR 0 1
75824: PPUSH
75825: CALL_OW 251
75829: PPUSH
75830: LD_INT 10
75832: PPUSH
75833: LD_INT 0
75835: PPUSH
75836: CALL_OW 50
// continue ;
75840: GO 75741
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75842: LD_VAR 0 12
75846: PUSH
75847: LD_INT 1
75849: ARRAY
75850: PPUSH
75851: CALL_OW 313
75855: PUSH
75856: LD_VAR 0 12
75860: PUSH
75861: LD_INT 1
75863: ARRAY
75864: PPUSH
75865: CALL_OW 266
75869: PUSH
75870: LD_INT 32
75872: PUSH
75873: LD_INT 31
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: IN
75880: AND
75881: PUSH
75882: LD_VAR 0 12
75886: PUSH
75887: LD_INT 1
75889: ARRAY
75890: PPUSH
75891: CALL_OW 313
75895: PUSH
75896: LD_INT 6
75898: EQUAL
75899: OR
75900: IFFALSE 75920
// f := Delete ( f , 1 ) ;
75902: LD_ADDR_VAR 0 12
75906: PUSH
75907: LD_VAR 0 12
75911: PPUSH
75912: LD_INT 1
75914: PPUSH
75915: CALL_OW 3
75919: ST_TO_ADDR
// if not f then
75920: LD_VAR 0 12
75924: NOT
75925: IFFALSE 75943
// begin x := x + 2 ;
75927: LD_ADDR_VAR 0 13
75931: PUSH
75932: LD_VAR 0 13
75936: PUSH
75937: LD_INT 2
75939: PLUS
75940: ST_TO_ADDR
// continue ;
75941: GO 75741
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75943: LD_VAR 0 12
75947: PUSH
75948: LD_INT 1
75950: ARRAY
75951: PPUSH
75952: CALL_OW 266
75956: PUSH
75957: LD_INT 5
75959: EQUAL
75960: IFFALSE 76034
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75962: LD_VAR 0 12
75966: PUSH
75967: LD_INT 1
75969: ARRAY
75970: PPUSH
75971: CALL_OW 313
75975: PUSH
75976: LD_INT 3
75978: LESS
75979: IFFALSE 76015
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75981: LD_INT 0
75983: PPUSH
75984: LD_INT 5
75986: PUSH
75987: LD_INT 8
75989: PUSH
75990: LD_INT 9
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: LIST
75997: PUSH
75998: LD_VAR 0 17
76002: ARRAY
76003: PPUSH
76004: LD_VAR 0 4
76008: PPUSH
76009: CALL_OW 380
76013: GO 76032
// PrepareHuman ( false , i , skill ) ;
76015: LD_INT 0
76017: PPUSH
76018: LD_VAR 0 8
76022: PPUSH
76023: LD_VAR 0 4
76027: PPUSH
76028: CALL_OW 380
// end else
76032: GO 76051
// PrepareHuman ( false , i , skill ) ;
76034: LD_INT 0
76036: PPUSH
76037: LD_VAR 0 8
76041: PPUSH
76042: LD_VAR 0 4
76046: PPUSH
76047: CALL_OW 380
// un := CreateHuman ;
76051: LD_ADDR_VAR 0 14
76055: PUSH
76056: CALL_OW 44
76060: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76061: LD_ADDR_VAR 0 7
76065: PUSH
76066: LD_VAR 0 7
76070: PPUSH
76071: LD_INT 1
76073: PPUSH
76074: LD_VAR 0 14
76078: PPUSH
76079: CALL_OW 2
76083: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76084: LD_VAR 0 14
76088: PPUSH
76089: LD_VAR 0 12
76093: PUSH
76094: LD_INT 1
76096: ARRAY
76097: PPUSH
76098: CALL_OW 52
// end ;
76102: GO 75741
76104: POP
76105: POP
// end ;
76106: GO 75043
76108: POP
76109: POP
// result := result ^ buildings ;
76110: LD_ADDR_VAR 0 7
76114: PUSH
76115: LD_VAR 0 7
76119: PUSH
76120: LD_VAR 0 18
76124: ADD
76125: ST_TO_ADDR
// end else
76126: GO 76269
// begin for i = 1 to personel do
76128: LD_ADDR_VAR 0 8
76132: PUSH
76133: DOUBLE
76134: LD_INT 1
76136: DEC
76137: ST_TO_ADDR
76138: LD_VAR 0 6
76142: PUSH
76143: FOR_TO
76144: IFFALSE 76267
// begin if i > 4 then
76146: LD_VAR 0 8
76150: PUSH
76151: LD_INT 4
76153: GREATER
76154: IFFALSE 76158
// break ;
76156: GO 76267
// x := personel [ i ] ;
76158: LD_ADDR_VAR 0 13
76162: PUSH
76163: LD_VAR 0 6
76167: PUSH
76168: LD_VAR 0 8
76172: ARRAY
76173: ST_TO_ADDR
// if x = - 1 then
76174: LD_VAR 0 13
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: EQUAL
76183: IFFALSE 76187
// continue ;
76185: GO 76143
// PrepareHuman ( false , i , skill ) ;
76187: LD_INT 0
76189: PPUSH
76190: LD_VAR 0 8
76194: PPUSH
76195: LD_VAR 0 4
76199: PPUSH
76200: CALL_OW 380
// un := CreateHuman ;
76204: LD_ADDR_VAR 0 14
76208: PUSH
76209: CALL_OW 44
76213: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76214: LD_VAR 0 14
76218: PPUSH
76219: LD_VAR 0 1
76223: PPUSH
76224: CALL_OW 250
76228: PPUSH
76229: LD_VAR 0 1
76233: PPUSH
76234: CALL_OW 251
76238: PPUSH
76239: LD_INT 10
76241: PPUSH
76242: LD_INT 0
76244: PPUSH
76245: CALL_OW 50
// result := result ^ un ;
76249: LD_ADDR_VAR 0 7
76253: PUSH
76254: LD_VAR 0 7
76258: PUSH
76259: LD_VAR 0 14
76263: ADD
76264: ST_TO_ADDR
// end ;
76265: GO 76143
76267: POP
76268: POP
// end ; end ;
76269: LD_VAR 0 7
76273: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76274: LD_INT 0
76276: PPUSH
76277: PPUSH
76278: PPUSH
76279: PPUSH
76280: PPUSH
76281: PPUSH
76282: PPUSH
76283: PPUSH
76284: PPUSH
76285: PPUSH
76286: PPUSH
76287: PPUSH
76288: PPUSH
76289: PPUSH
76290: PPUSH
76291: PPUSH
// result := false ;
76292: LD_ADDR_VAR 0 3
76296: PUSH
76297: LD_INT 0
76299: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76300: LD_VAR 0 1
76304: NOT
76305: PUSH
76306: LD_VAR 0 1
76310: PPUSH
76311: CALL_OW 266
76315: PUSH
76316: LD_INT 32
76318: PUSH
76319: LD_INT 33
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: IN
76326: NOT
76327: OR
76328: IFFALSE 76332
// exit ;
76330: GO 77468
// nat := GetNation ( tower ) ;
76332: LD_ADDR_VAR 0 12
76336: PUSH
76337: LD_VAR 0 1
76341: PPUSH
76342: CALL_OW 248
76346: ST_TO_ADDR
// side := GetSide ( tower ) ;
76347: LD_ADDR_VAR 0 16
76351: PUSH
76352: LD_VAR 0 1
76356: PPUSH
76357: CALL_OW 255
76361: ST_TO_ADDR
// x := GetX ( tower ) ;
76362: LD_ADDR_VAR 0 10
76366: PUSH
76367: LD_VAR 0 1
76371: PPUSH
76372: CALL_OW 250
76376: ST_TO_ADDR
// y := GetY ( tower ) ;
76377: LD_ADDR_VAR 0 11
76381: PUSH
76382: LD_VAR 0 1
76386: PPUSH
76387: CALL_OW 251
76391: ST_TO_ADDR
// if not x or not y then
76392: LD_VAR 0 10
76396: NOT
76397: PUSH
76398: LD_VAR 0 11
76402: NOT
76403: OR
76404: IFFALSE 76408
// exit ;
76406: GO 77468
// weapon := 0 ;
76408: LD_ADDR_VAR 0 18
76412: PUSH
76413: LD_INT 0
76415: ST_TO_ADDR
// fac_list := [ ] ;
76416: LD_ADDR_VAR 0 17
76420: PUSH
76421: EMPTY
76422: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76423: LD_ADDR_VAR 0 6
76427: PUSH
76428: LD_VAR 0 1
76432: PPUSH
76433: CALL_OW 274
76437: PPUSH
76438: LD_VAR 0 2
76442: PPUSH
76443: CALL 74046 0 2
76447: PPUSH
76448: LD_INT 30
76450: PUSH
76451: LD_INT 3
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: PPUSH
76458: CALL_OW 72
76462: ST_TO_ADDR
// if not factories then
76463: LD_VAR 0 6
76467: NOT
76468: IFFALSE 76472
// exit ;
76470: GO 77468
// for i in factories do
76472: LD_ADDR_VAR 0 8
76476: PUSH
76477: LD_VAR 0 6
76481: PUSH
76482: FOR_IN
76483: IFFALSE 76508
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76485: LD_ADDR_VAR 0 17
76489: PUSH
76490: LD_VAR 0 17
76494: PUSH
76495: LD_VAR 0 8
76499: PPUSH
76500: CALL_OW 478
76504: UNION
76505: ST_TO_ADDR
76506: GO 76482
76508: POP
76509: POP
// if not fac_list then
76510: LD_VAR 0 17
76514: NOT
76515: IFFALSE 76519
// exit ;
76517: GO 77468
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76519: LD_ADDR_VAR 0 5
76523: PUSH
76524: LD_INT 4
76526: PUSH
76527: LD_INT 5
76529: PUSH
76530: LD_INT 9
76532: PUSH
76533: LD_INT 10
76535: PUSH
76536: LD_INT 6
76538: PUSH
76539: LD_INT 7
76541: PUSH
76542: LD_INT 11
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 27
76556: PUSH
76557: LD_INT 28
76559: PUSH
76560: LD_INT 26
76562: PUSH
76563: LD_INT 30
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 43
76574: PUSH
76575: LD_INT 44
76577: PUSH
76578: LD_INT 46
76580: PUSH
76581: LD_INT 45
76583: PUSH
76584: LD_INT 47
76586: PUSH
76587: LD_INT 49
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: PUSH
76598: EMPTY
76599: LIST
76600: LIST
76601: LIST
76602: PUSH
76603: LD_VAR 0 12
76607: ARRAY
76608: ST_TO_ADDR
// for i in list do
76609: LD_ADDR_VAR 0 8
76613: PUSH
76614: LD_VAR 0 5
76618: PUSH
76619: FOR_IN
76620: IFFALSE 76653
// if not i in fac_list then
76622: LD_VAR 0 8
76626: PUSH
76627: LD_VAR 0 17
76631: IN
76632: NOT
76633: IFFALSE 76651
// list := list diff i ;
76635: LD_ADDR_VAR 0 5
76639: PUSH
76640: LD_VAR 0 5
76644: PUSH
76645: LD_VAR 0 8
76649: DIFF
76650: ST_TO_ADDR
76651: GO 76619
76653: POP
76654: POP
// if not list then
76655: LD_VAR 0 5
76659: NOT
76660: IFFALSE 76664
// exit ;
76662: GO 77468
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76664: LD_VAR 0 12
76668: PUSH
76669: LD_INT 3
76671: EQUAL
76672: PUSH
76673: LD_INT 49
76675: PUSH
76676: LD_VAR 0 5
76680: IN
76681: AND
76682: PUSH
76683: LD_INT 31
76685: PPUSH
76686: LD_VAR 0 16
76690: PPUSH
76691: CALL_OW 321
76695: PUSH
76696: LD_INT 2
76698: EQUAL
76699: AND
76700: IFFALSE 76760
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76702: LD_INT 22
76704: PUSH
76705: LD_VAR 0 16
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 35
76716: PUSH
76717: LD_INT 49
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 91
76726: PUSH
76727: LD_VAR 0 1
76731: PUSH
76732: LD_INT 10
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: LIST
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: LIST
76744: PPUSH
76745: CALL_OW 69
76749: NOT
76750: IFFALSE 76760
// weapon := ru_time_lapser ;
76752: LD_ADDR_VAR 0 18
76756: PUSH
76757: LD_INT 49
76759: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76760: LD_VAR 0 12
76764: PUSH
76765: LD_INT 1
76767: PUSH
76768: LD_INT 2
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: IN
76775: PUSH
76776: LD_INT 11
76778: PUSH
76779: LD_VAR 0 5
76783: IN
76784: PUSH
76785: LD_INT 30
76787: PUSH
76788: LD_VAR 0 5
76792: IN
76793: OR
76794: AND
76795: PUSH
76796: LD_INT 6
76798: PPUSH
76799: LD_VAR 0 16
76803: PPUSH
76804: CALL_OW 321
76808: PUSH
76809: LD_INT 2
76811: EQUAL
76812: AND
76813: IFFALSE 76978
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76815: LD_INT 22
76817: PUSH
76818: LD_VAR 0 16
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 2
76829: PUSH
76830: LD_INT 35
76832: PUSH
76833: LD_INT 11
76835: PUSH
76836: EMPTY
76837: LIST
76838: LIST
76839: PUSH
76840: LD_INT 35
76842: PUSH
76843: LD_INT 30
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: PUSH
76855: LD_INT 91
76857: PUSH
76858: LD_VAR 0 1
76862: PUSH
76863: LD_INT 18
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: LIST
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: LIST
76875: PPUSH
76876: CALL_OW 69
76880: NOT
76881: PUSH
76882: LD_INT 22
76884: PUSH
76885: LD_VAR 0 16
76889: PUSH
76890: EMPTY
76891: LIST
76892: LIST
76893: PUSH
76894: LD_INT 2
76896: PUSH
76897: LD_INT 30
76899: PUSH
76900: LD_INT 32
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 30
76909: PUSH
76910: LD_INT 33
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 91
76924: PUSH
76925: LD_VAR 0 1
76929: PUSH
76930: LD_INT 12
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: PUSH
76943: EMPTY
76944: LIST
76945: PPUSH
76946: CALL_OW 69
76950: PUSH
76951: LD_INT 2
76953: GREATER
76954: AND
76955: IFFALSE 76978
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76957: LD_ADDR_VAR 0 18
76961: PUSH
76962: LD_INT 11
76964: PUSH
76965: LD_INT 30
76967: PUSH
76968: EMPTY
76969: LIST
76970: LIST
76971: PUSH
76972: LD_VAR 0 12
76976: ARRAY
76977: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76978: LD_VAR 0 18
76982: NOT
76983: PUSH
76984: LD_INT 40
76986: PPUSH
76987: LD_VAR 0 16
76991: PPUSH
76992: CALL_OW 321
76996: PUSH
76997: LD_INT 2
76999: EQUAL
77000: AND
77001: PUSH
77002: LD_INT 7
77004: PUSH
77005: LD_VAR 0 5
77009: IN
77010: PUSH
77011: LD_INT 28
77013: PUSH
77014: LD_VAR 0 5
77018: IN
77019: OR
77020: PUSH
77021: LD_INT 45
77023: PUSH
77024: LD_VAR 0 5
77028: IN
77029: OR
77030: AND
77031: IFFALSE 77285
// begin hex := GetHexInfo ( x , y ) ;
77033: LD_ADDR_VAR 0 4
77037: PUSH
77038: LD_VAR 0 10
77042: PPUSH
77043: LD_VAR 0 11
77047: PPUSH
77048: CALL_OW 546
77052: ST_TO_ADDR
// if hex [ 1 ] then
77053: LD_VAR 0 4
77057: PUSH
77058: LD_INT 1
77060: ARRAY
77061: IFFALSE 77065
// exit ;
77063: GO 77468
// height := hex [ 2 ] ;
77065: LD_ADDR_VAR 0 15
77069: PUSH
77070: LD_VAR 0 4
77074: PUSH
77075: LD_INT 2
77077: ARRAY
77078: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77079: LD_ADDR_VAR 0 14
77083: PUSH
77084: LD_INT 0
77086: PUSH
77087: LD_INT 2
77089: PUSH
77090: LD_INT 3
77092: PUSH
77093: LD_INT 5
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: ST_TO_ADDR
// for i in tmp do
77102: LD_ADDR_VAR 0 8
77106: PUSH
77107: LD_VAR 0 14
77111: PUSH
77112: FOR_IN
77113: IFFALSE 77283
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77115: LD_ADDR_VAR 0 9
77119: PUSH
77120: LD_VAR 0 10
77124: PPUSH
77125: LD_VAR 0 8
77129: PPUSH
77130: LD_INT 5
77132: PPUSH
77133: CALL_OW 272
77137: PUSH
77138: LD_VAR 0 11
77142: PPUSH
77143: LD_VAR 0 8
77147: PPUSH
77148: LD_INT 5
77150: PPUSH
77151: CALL_OW 273
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77160: LD_VAR 0 9
77164: PUSH
77165: LD_INT 1
77167: ARRAY
77168: PPUSH
77169: LD_VAR 0 9
77173: PUSH
77174: LD_INT 2
77176: ARRAY
77177: PPUSH
77178: CALL_OW 488
77182: IFFALSE 77281
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77184: LD_ADDR_VAR 0 4
77188: PUSH
77189: LD_VAR 0 9
77193: PUSH
77194: LD_INT 1
77196: ARRAY
77197: PPUSH
77198: LD_VAR 0 9
77202: PUSH
77203: LD_INT 2
77205: ARRAY
77206: PPUSH
77207: CALL_OW 546
77211: ST_TO_ADDR
// if hex [ 1 ] then
77212: LD_VAR 0 4
77216: PUSH
77217: LD_INT 1
77219: ARRAY
77220: IFFALSE 77224
// continue ;
77222: GO 77112
// h := hex [ 2 ] ;
77224: LD_ADDR_VAR 0 13
77228: PUSH
77229: LD_VAR 0 4
77233: PUSH
77234: LD_INT 2
77236: ARRAY
77237: ST_TO_ADDR
// if h + 7 < height then
77238: LD_VAR 0 13
77242: PUSH
77243: LD_INT 7
77245: PLUS
77246: PUSH
77247: LD_VAR 0 15
77251: LESS
77252: IFFALSE 77281
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77254: LD_ADDR_VAR 0 18
77258: PUSH
77259: LD_INT 7
77261: PUSH
77262: LD_INT 28
77264: PUSH
77265: LD_INT 45
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: LIST
77272: PUSH
77273: LD_VAR 0 12
77277: ARRAY
77278: ST_TO_ADDR
// break ;
77279: GO 77283
// end ; end ; end ;
77281: GO 77112
77283: POP
77284: POP
// end ; if not weapon then
77285: LD_VAR 0 18
77289: NOT
77290: IFFALSE 77350
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77292: LD_ADDR_VAR 0 5
77296: PUSH
77297: LD_VAR 0 5
77301: PUSH
77302: LD_INT 11
77304: PUSH
77305: LD_INT 30
77307: PUSH
77308: LD_INT 49
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: LIST
77315: DIFF
77316: ST_TO_ADDR
// if not list then
77317: LD_VAR 0 5
77321: NOT
77322: IFFALSE 77326
// exit ;
77324: GO 77468
// weapon := list [ rand ( 1 , list ) ] ;
77326: LD_ADDR_VAR 0 18
77330: PUSH
77331: LD_VAR 0 5
77335: PUSH
77336: LD_INT 1
77338: PPUSH
77339: LD_VAR 0 5
77343: PPUSH
77344: CALL_OW 12
77348: ARRAY
77349: ST_TO_ADDR
// end ; if weapon then
77350: LD_VAR 0 18
77354: IFFALSE 77468
// begin tmp := CostOfWeapon ( weapon ) ;
77356: LD_ADDR_VAR 0 14
77360: PUSH
77361: LD_VAR 0 18
77365: PPUSH
77366: CALL_OW 451
77370: ST_TO_ADDR
// j := GetBase ( tower ) ;
77371: LD_ADDR_VAR 0 9
77375: PUSH
77376: LD_VAR 0 1
77380: PPUSH
77381: CALL_OW 274
77385: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77386: LD_VAR 0 9
77390: PPUSH
77391: LD_INT 1
77393: PPUSH
77394: CALL_OW 275
77398: PUSH
77399: LD_VAR 0 14
77403: PUSH
77404: LD_INT 1
77406: ARRAY
77407: GREATEREQUAL
77408: PUSH
77409: LD_VAR 0 9
77413: PPUSH
77414: LD_INT 2
77416: PPUSH
77417: CALL_OW 275
77421: PUSH
77422: LD_VAR 0 14
77426: PUSH
77427: LD_INT 2
77429: ARRAY
77430: GREATEREQUAL
77431: AND
77432: PUSH
77433: LD_VAR 0 9
77437: PPUSH
77438: LD_INT 3
77440: PPUSH
77441: CALL_OW 275
77445: PUSH
77446: LD_VAR 0 14
77450: PUSH
77451: LD_INT 3
77453: ARRAY
77454: GREATEREQUAL
77455: AND
77456: IFFALSE 77468
// result := weapon ;
77458: LD_ADDR_VAR 0 3
77462: PUSH
77463: LD_VAR 0 18
77467: ST_TO_ADDR
// end ; end ;
77468: LD_VAR 0 3
77472: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77473: LD_INT 0
77475: PPUSH
77476: PPUSH
// result := true ;
77477: LD_ADDR_VAR 0 3
77481: PUSH
77482: LD_INT 1
77484: ST_TO_ADDR
// if array1 = array2 then
77485: LD_VAR 0 1
77489: PUSH
77490: LD_VAR 0 2
77494: EQUAL
77495: IFFALSE 77555
// begin for i = 1 to array1 do
77497: LD_ADDR_VAR 0 4
77501: PUSH
77502: DOUBLE
77503: LD_INT 1
77505: DEC
77506: ST_TO_ADDR
77507: LD_VAR 0 1
77511: PUSH
77512: FOR_TO
77513: IFFALSE 77551
// if array1 [ i ] <> array2 [ i ] then
77515: LD_VAR 0 1
77519: PUSH
77520: LD_VAR 0 4
77524: ARRAY
77525: PUSH
77526: LD_VAR 0 2
77530: PUSH
77531: LD_VAR 0 4
77535: ARRAY
77536: NONEQUAL
77537: IFFALSE 77549
// begin result := false ;
77539: LD_ADDR_VAR 0 3
77543: PUSH
77544: LD_INT 0
77546: ST_TO_ADDR
// break ;
77547: GO 77551
// end ;
77549: GO 77512
77551: POP
77552: POP
// end else
77553: GO 77563
// result := false ;
77555: LD_ADDR_VAR 0 3
77559: PUSH
77560: LD_INT 0
77562: ST_TO_ADDR
// end ;
77563: LD_VAR 0 3
77567: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77568: LD_INT 0
77570: PPUSH
77571: PPUSH
77572: PPUSH
// pom := GetBase ( fac ) ;
77573: LD_ADDR_VAR 0 5
77577: PUSH
77578: LD_VAR 0 1
77582: PPUSH
77583: CALL_OW 274
77587: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77588: LD_ADDR_VAR 0 4
77592: PUSH
77593: LD_VAR 0 2
77597: PUSH
77598: LD_INT 1
77600: ARRAY
77601: PPUSH
77602: LD_VAR 0 2
77606: PUSH
77607: LD_INT 2
77609: ARRAY
77610: PPUSH
77611: LD_VAR 0 2
77615: PUSH
77616: LD_INT 3
77618: ARRAY
77619: PPUSH
77620: LD_VAR 0 2
77624: PUSH
77625: LD_INT 4
77627: ARRAY
77628: PPUSH
77629: CALL_OW 449
77633: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77634: LD_ADDR_VAR 0 3
77638: PUSH
77639: LD_VAR 0 5
77643: PPUSH
77644: LD_INT 1
77646: PPUSH
77647: CALL_OW 275
77651: PUSH
77652: LD_VAR 0 4
77656: PUSH
77657: LD_INT 1
77659: ARRAY
77660: GREATEREQUAL
77661: PUSH
77662: LD_VAR 0 5
77666: PPUSH
77667: LD_INT 2
77669: PPUSH
77670: CALL_OW 275
77674: PUSH
77675: LD_VAR 0 4
77679: PUSH
77680: LD_INT 2
77682: ARRAY
77683: GREATEREQUAL
77684: AND
77685: PUSH
77686: LD_VAR 0 5
77690: PPUSH
77691: LD_INT 3
77693: PPUSH
77694: CALL_OW 275
77698: PUSH
77699: LD_VAR 0 4
77703: PUSH
77704: LD_INT 3
77706: ARRAY
77707: GREATEREQUAL
77708: AND
77709: ST_TO_ADDR
// end ;
77710: LD_VAR 0 3
77714: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77715: LD_INT 0
77717: PPUSH
77718: PPUSH
77719: PPUSH
77720: PPUSH
// pom := GetBase ( building ) ;
77721: LD_ADDR_VAR 0 3
77725: PUSH
77726: LD_VAR 0 1
77730: PPUSH
77731: CALL_OW 274
77735: ST_TO_ADDR
// if not pom then
77736: LD_VAR 0 3
77740: NOT
77741: IFFALSE 77745
// exit ;
77743: GO 77915
// btype := GetBType ( building ) ;
77745: LD_ADDR_VAR 0 5
77749: PUSH
77750: LD_VAR 0 1
77754: PPUSH
77755: CALL_OW 266
77759: ST_TO_ADDR
// if btype = b_armoury then
77760: LD_VAR 0 5
77764: PUSH
77765: LD_INT 4
77767: EQUAL
77768: IFFALSE 77778
// btype := b_barracks ;
77770: LD_ADDR_VAR 0 5
77774: PUSH
77775: LD_INT 5
77777: ST_TO_ADDR
// if btype = b_depot then
77778: LD_VAR 0 5
77782: PUSH
77783: LD_INT 0
77785: EQUAL
77786: IFFALSE 77796
// btype := b_warehouse ;
77788: LD_ADDR_VAR 0 5
77792: PUSH
77793: LD_INT 1
77795: ST_TO_ADDR
// if btype = b_workshop then
77796: LD_VAR 0 5
77800: PUSH
77801: LD_INT 2
77803: EQUAL
77804: IFFALSE 77814
// btype := b_factory ;
77806: LD_ADDR_VAR 0 5
77810: PUSH
77811: LD_INT 3
77813: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77814: LD_ADDR_VAR 0 4
77818: PUSH
77819: LD_VAR 0 5
77823: PPUSH
77824: LD_VAR 0 1
77828: PPUSH
77829: CALL_OW 248
77833: PPUSH
77834: CALL_OW 450
77838: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77839: LD_ADDR_VAR 0 2
77843: PUSH
77844: LD_VAR 0 3
77848: PPUSH
77849: LD_INT 1
77851: PPUSH
77852: CALL_OW 275
77856: PUSH
77857: LD_VAR 0 4
77861: PUSH
77862: LD_INT 1
77864: ARRAY
77865: GREATEREQUAL
77866: PUSH
77867: LD_VAR 0 3
77871: PPUSH
77872: LD_INT 2
77874: PPUSH
77875: CALL_OW 275
77879: PUSH
77880: LD_VAR 0 4
77884: PUSH
77885: LD_INT 2
77887: ARRAY
77888: GREATEREQUAL
77889: AND
77890: PUSH
77891: LD_VAR 0 3
77895: PPUSH
77896: LD_INT 3
77898: PPUSH
77899: CALL_OW 275
77903: PUSH
77904: LD_VAR 0 4
77908: PUSH
77909: LD_INT 3
77911: ARRAY
77912: GREATEREQUAL
77913: AND
77914: ST_TO_ADDR
// end ;
77915: LD_VAR 0 2
77919: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77920: LD_INT 0
77922: PPUSH
77923: PPUSH
77924: PPUSH
// pom := GetBase ( building ) ;
77925: LD_ADDR_VAR 0 4
77929: PUSH
77930: LD_VAR 0 1
77934: PPUSH
77935: CALL_OW 274
77939: ST_TO_ADDR
// if not pom then
77940: LD_VAR 0 4
77944: NOT
77945: IFFALSE 77949
// exit ;
77947: GO 78050
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77949: LD_ADDR_VAR 0 5
77953: PUSH
77954: LD_VAR 0 2
77958: PPUSH
77959: LD_VAR 0 1
77963: PPUSH
77964: CALL_OW 248
77968: PPUSH
77969: CALL_OW 450
77973: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77974: LD_ADDR_VAR 0 3
77978: PUSH
77979: LD_VAR 0 4
77983: PPUSH
77984: LD_INT 1
77986: PPUSH
77987: CALL_OW 275
77991: PUSH
77992: LD_VAR 0 5
77996: PUSH
77997: LD_INT 1
77999: ARRAY
78000: GREATEREQUAL
78001: PUSH
78002: LD_VAR 0 4
78006: PPUSH
78007: LD_INT 2
78009: PPUSH
78010: CALL_OW 275
78014: PUSH
78015: LD_VAR 0 5
78019: PUSH
78020: LD_INT 2
78022: ARRAY
78023: GREATEREQUAL
78024: AND
78025: PUSH
78026: LD_VAR 0 4
78030: PPUSH
78031: LD_INT 3
78033: PPUSH
78034: CALL_OW 275
78038: PUSH
78039: LD_VAR 0 5
78043: PUSH
78044: LD_INT 3
78046: ARRAY
78047: GREATEREQUAL
78048: AND
78049: ST_TO_ADDR
// end ;
78050: LD_VAR 0 3
78054: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78055: LD_INT 0
78057: PPUSH
78058: PPUSH
78059: PPUSH
78060: PPUSH
78061: PPUSH
78062: PPUSH
78063: PPUSH
78064: PPUSH
78065: PPUSH
78066: PPUSH
// result := false ;
78067: LD_ADDR_VAR 0 6
78071: PUSH
78072: LD_INT 0
78074: ST_TO_ADDR
// if not base or not btype or not x or not y then
78075: LD_VAR 0 1
78079: NOT
78080: PUSH
78081: LD_VAR 0 2
78085: NOT
78086: OR
78087: PUSH
78088: LD_VAR 0 3
78092: NOT
78093: OR
78094: PUSH
78095: LD_VAR 0 4
78099: NOT
78100: OR
78101: IFFALSE 78105
// exit ;
78103: GO 78714
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78105: LD_ADDR_VAR 0 12
78109: PUSH
78110: LD_VAR 0 2
78114: PPUSH
78115: LD_VAR 0 3
78119: PPUSH
78120: LD_VAR 0 4
78124: PPUSH
78125: LD_VAR 0 5
78129: PPUSH
78130: LD_VAR 0 1
78134: PUSH
78135: LD_INT 1
78137: ARRAY
78138: PPUSH
78139: CALL_OW 248
78143: PPUSH
78144: LD_INT 0
78146: PPUSH
78147: CALL 79551 0 6
78151: ST_TO_ADDR
// if not hexes then
78152: LD_VAR 0 12
78156: NOT
78157: IFFALSE 78161
// exit ;
78159: GO 78714
// for i = 1 to hexes do
78161: LD_ADDR_VAR 0 7
78165: PUSH
78166: DOUBLE
78167: LD_INT 1
78169: DEC
78170: ST_TO_ADDR
78171: LD_VAR 0 12
78175: PUSH
78176: FOR_TO
78177: IFFALSE 78712
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78179: LD_ADDR_VAR 0 11
78183: PUSH
78184: LD_VAR 0 12
78188: PUSH
78189: LD_VAR 0 7
78193: ARRAY
78194: PUSH
78195: LD_INT 1
78197: ARRAY
78198: PPUSH
78199: LD_VAR 0 12
78203: PUSH
78204: LD_VAR 0 7
78208: ARRAY
78209: PUSH
78210: LD_INT 2
78212: ARRAY
78213: PPUSH
78214: CALL_OW 428
78218: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78219: LD_VAR 0 12
78223: PUSH
78224: LD_VAR 0 7
78228: ARRAY
78229: PUSH
78230: LD_INT 1
78232: ARRAY
78233: PPUSH
78234: LD_VAR 0 12
78238: PUSH
78239: LD_VAR 0 7
78243: ARRAY
78244: PUSH
78245: LD_INT 2
78247: ARRAY
78248: PPUSH
78249: CALL_OW 351
78253: PUSH
78254: LD_VAR 0 12
78258: PUSH
78259: LD_VAR 0 7
78263: ARRAY
78264: PUSH
78265: LD_INT 1
78267: ARRAY
78268: PPUSH
78269: LD_VAR 0 12
78273: PUSH
78274: LD_VAR 0 7
78278: ARRAY
78279: PUSH
78280: LD_INT 2
78282: ARRAY
78283: PPUSH
78284: CALL_OW 488
78288: NOT
78289: OR
78290: PUSH
78291: LD_VAR 0 11
78295: PPUSH
78296: CALL_OW 247
78300: PUSH
78301: LD_INT 3
78303: EQUAL
78304: OR
78305: IFFALSE 78311
// exit ;
78307: POP
78308: POP
78309: GO 78714
// if not tmp or not tmp in base then
78311: LD_VAR 0 11
78315: NOT
78316: PUSH
78317: LD_VAR 0 11
78321: PUSH
78322: LD_VAR 0 1
78326: IN
78327: NOT
78328: OR
78329: IFFALSE 78333
// continue ;
78331: GO 78176
// result := true ;
78333: LD_ADDR_VAR 0 6
78337: PUSH
78338: LD_INT 1
78340: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78341: LD_ADDR_VAR 0 15
78345: PUSH
78346: LD_VAR 0 1
78350: PPUSH
78351: LD_INT 22
78353: PUSH
78354: LD_VAR 0 11
78358: PPUSH
78359: CALL_OW 255
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 2
78370: PUSH
78371: LD_INT 30
78373: PUSH
78374: LD_INT 0
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 30
78383: PUSH
78384: LD_INT 1
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: LIST
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PPUSH
78400: CALL_OW 72
78404: ST_TO_ADDR
// if dep then
78405: LD_VAR 0 15
78409: IFFALSE 78545
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78411: LD_ADDR_VAR 0 14
78415: PUSH
78416: LD_VAR 0 15
78420: PUSH
78421: LD_INT 1
78423: ARRAY
78424: PPUSH
78425: CALL_OW 250
78429: PPUSH
78430: LD_VAR 0 15
78434: PUSH
78435: LD_INT 1
78437: ARRAY
78438: PPUSH
78439: CALL_OW 254
78443: PPUSH
78444: LD_INT 5
78446: PPUSH
78447: CALL_OW 272
78451: PUSH
78452: LD_VAR 0 15
78456: PUSH
78457: LD_INT 1
78459: ARRAY
78460: PPUSH
78461: CALL_OW 251
78465: PPUSH
78466: LD_VAR 0 15
78470: PUSH
78471: LD_INT 1
78473: ARRAY
78474: PPUSH
78475: CALL_OW 254
78479: PPUSH
78480: LD_INT 5
78482: PPUSH
78483: CALL_OW 273
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78492: LD_VAR 0 14
78496: PUSH
78497: LD_INT 1
78499: ARRAY
78500: PPUSH
78501: LD_VAR 0 14
78505: PUSH
78506: LD_INT 2
78508: ARRAY
78509: PPUSH
78510: CALL_OW 488
78514: IFFALSE 78545
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78516: LD_VAR 0 11
78520: PPUSH
78521: LD_VAR 0 14
78525: PUSH
78526: LD_INT 1
78528: ARRAY
78529: PPUSH
78530: LD_VAR 0 14
78534: PUSH
78535: LD_INT 2
78537: ARRAY
78538: PPUSH
78539: CALL_OW 111
// continue ;
78543: GO 78176
// end ; end ; r := GetDir ( tmp ) ;
78545: LD_ADDR_VAR 0 13
78549: PUSH
78550: LD_VAR 0 11
78554: PPUSH
78555: CALL_OW 254
78559: ST_TO_ADDR
// if r = 5 then
78560: LD_VAR 0 13
78564: PUSH
78565: LD_INT 5
78567: EQUAL
78568: IFFALSE 78578
// r := 0 ;
78570: LD_ADDR_VAR 0 13
78574: PUSH
78575: LD_INT 0
78577: ST_TO_ADDR
// for j = r to 5 do
78578: LD_ADDR_VAR 0 8
78582: PUSH
78583: DOUBLE
78584: LD_VAR 0 13
78588: DEC
78589: ST_TO_ADDR
78590: LD_INT 5
78592: PUSH
78593: FOR_TO
78594: IFFALSE 78708
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78596: LD_ADDR_VAR 0 9
78600: PUSH
78601: LD_VAR 0 11
78605: PPUSH
78606: CALL_OW 250
78610: PPUSH
78611: LD_VAR 0 8
78615: PPUSH
78616: LD_INT 2
78618: PPUSH
78619: CALL_OW 272
78623: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78624: LD_ADDR_VAR 0 10
78628: PUSH
78629: LD_VAR 0 11
78633: PPUSH
78634: CALL_OW 251
78638: PPUSH
78639: LD_VAR 0 8
78643: PPUSH
78644: LD_INT 2
78646: PPUSH
78647: CALL_OW 273
78651: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78652: LD_VAR 0 9
78656: PPUSH
78657: LD_VAR 0 10
78661: PPUSH
78662: CALL_OW 488
78666: PUSH
78667: LD_VAR 0 9
78671: PPUSH
78672: LD_VAR 0 10
78676: PPUSH
78677: CALL_OW 428
78681: NOT
78682: AND
78683: IFFALSE 78706
// begin ComMoveXY ( tmp , _x , _y ) ;
78685: LD_VAR 0 11
78689: PPUSH
78690: LD_VAR 0 9
78694: PPUSH
78695: LD_VAR 0 10
78699: PPUSH
78700: CALL_OW 111
// break ;
78704: GO 78708
// end ; end ;
78706: GO 78593
78708: POP
78709: POP
// end ;
78710: GO 78176
78712: POP
78713: POP
// end ;
78714: LD_VAR 0 6
78718: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78719: LD_INT 0
78721: PPUSH
78722: PPUSH
78723: PPUSH
78724: PPUSH
78725: PPUSH
78726: PPUSH
78727: PPUSH
78728: PPUSH
78729: PPUSH
78730: PPUSH
// result := false ;
78731: LD_ADDR_VAR 0 6
78735: PUSH
78736: LD_INT 0
78738: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78739: LD_VAR 0 1
78743: NOT
78744: PUSH
78745: LD_VAR 0 1
78749: PPUSH
78750: CALL_OW 266
78754: PUSH
78755: LD_INT 0
78757: PUSH
78758: LD_INT 1
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: IN
78765: NOT
78766: OR
78767: PUSH
78768: LD_VAR 0 2
78772: NOT
78773: OR
78774: PUSH
78775: LD_VAR 0 5
78779: PUSH
78780: LD_INT 0
78782: PUSH
78783: LD_INT 1
78785: PUSH
78786: LD_INT 2
78788: PUSH
78789: LD_INT 3
78791: PUSH
78792: LD_INT 4
78794: PUSH
78795: LD_INT 5
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: IN
78806: NOT
78807: OR
78808: PUSH
78809: LD_VAR 0 3
78813: PPUSH
78814: LD_VAR 0 4
78818: PPUSH
78819: CALL_OW 488
78823: NOT
78824: OR
78825: IFFALSE 78829
// exit ;
78827: GO 79546
// pom := GetBase ( depot ) ;
78829: LD_ADDR_VAR 0 10
78833: PUSH
78834: LD_VAR 0 1
78838: PPUSH
78839: CALL_OW 274
78843: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78844: LD_ADDR_VAR 0 11
78848: PUSH
78849: LD_VAR 0 2
78853: PPUSH
78854: LD_VAR 0 1
78858: PPUSH
78859: CALL_OW 248
78863: PPUSH
78864: CALL_OW 450
78868: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78869: LD_VAR 0 10
78873: PPUSH
78874: LD_INT 1
78876: PPUSH
78877: CALL_OW 275
78881: PUSH
78882: LD_VAR 0 11
78886: PUSH
78887: LD_INT 1
78889: ARRAY
78890: GREATEREQUAL
78891: PUSH
78892: LD_VAR 0 10
78896: PPUSH
78897: LD_INT 2
78899: PPUSH
78900: CALL_OW 275
78904: PUSH
78905: LD_VAR 0 11
78909: PUSH
78910: LD_INT 2
78912: ARRAY
78913: GREATEREQUAL
78914: AND
78915: PUSH
78916: LD_VAR 0 10
78920: PPUSH
78921: LD_INT 3
78923: PPUSH
78924: CALL_OW 275
78928: PUSH
78929: LD_VAR 0 11
78933: PUSH
78934: LD_INT 3
78936: ARRAY
78937: GREATEREQUAL
78938: AND
78939: NOT
78940: IFFALSE 78944
// exit ;
78942: GO 79546
// if GetBType ( depot ) = b_depot then
78944: LD_VAR 0 1
78948: PPUSH
78949: CALL_OW 266
78953: PUSH
78954: LD_INT 0
78956: EQUAL
78957: IFFALSE 78969
// dist := 28 else
78959: LD_ADDR_VAR 0 14
78963: PUSH
78964: LD_INT 28
78966: ST_TO_ADDR
78967: GO 78977
// dist := 36 ;
78969: LD_ADDR_VAR 0 14
78973: PUSH
78974: LD_INT 36
78976: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78977: LD_VAR 0 1
78981: PPUSH
78982: LD_VAR 0 3
78986: PPUSH
78987: LD_VAR 0 4
78991: PPUSH
78992: CALL_OW 297
78996: PUSH
78997: LD_VAR 0 14
79001: GREATER
79002: IFFALSE 79006
// exit ;
79004: GO 79546
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79006: LD_ADDR_VAR 0 12
79010: PUSH
79011: LD_VAR 0 2
79015: PPUSH
79016: LD_VAR 0 3
79020: PPUSH
79021: LD_VAR 0 4
79025: PPUSH
79026: LD_VAR 0 5
79030: PPUSH
79031: LD_VAR 0 1
79035: PPUSH
79036: CALL_OW 248
79040: PPUSH
79041: LD_INT 0
79043: PPUSH
79044: CALL 79551 0 6
79048: ST_TO_ADDR
// if not hexes then
79049: LD_VAR 0 12
79053: NOT
79054: IFFALSE 79058
// exit ;
79056: GO 79546
// hex := GetHexInfo ( x , y ) ;
79058: LD_ADDR_VAR 0 15
79062: PUSH
79063: LD_VAR 0 3
79067: PPUSH
79068: LD_VAR 0 4
79072: PPUSH
79073: CALL_OW 546
79077: ST_TO_ADDR
// if hex [ 1 ] then
79078: LD_VAR 0 15
79082: PUSH
79083: LD_INT 1
79085: ARRAY
79086: IFFALSE 79090
// exit ;
79088: GO 79546
// height := hex [ 2 ] ;
79090: LD_ADDR_VAR 0 13
79094: PUSH
79095: LD_VAR 0 15
79099: PUSH
79100: LD_INT 2
79102: ARRAY
79103: ST_TO_ADDR
// for i = 1 to hexes do
79104: LD_ADDR_VAR 0 7
79108: PUSH
79109: DOUBLE
79110: LD_INT 1
79112: DEC
79113: ST_TO_ADDR
79114: LD_VAR 0 12
79118: PUSH
79119: FOR_TO
79120: IFFALSE 79450
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79122: LD_VAR 0 12
79126: PUSH
79127: LD_VAR 0 7
79131: ARRAY
79132: PUSH
79133: LD_INT 1
79135: ARRAY
79136: PPUSH
79137: LD_VAR 0 12
79141: PUSH
79142: LD_VAR 0 7
79146: ARRAY
79147: PUSH
79148: LD_INT 2
79150: ARRAY
79151: PPUSH
79152: CALL_OW 488
79156: NOT
79157: PUSH
79158: LD_VAR 0 12
79162: PUSH
79163: LD_VAR 0 7
79167: ARRAY
79168: PUSH
79169: LD_INT 1
79171: ARRAY
79172: PPUSH
79173: LD_VAR 0 12
79177: PUSH
79178: LD_VAR 0 7
79182: ARRAY
79183: PUSH
79184: LD_INT 2
79186: ARRAY
79187: PPUSH
79188: CALL_OW 428
79192: PUSH
79193: LD_INT 0
79195: GREATER
79196: OR
79197: PUSH
79198: LD_VAR 0 12
79202: PUSH
79203: LD_VAR 0 7
79207: ARRAY
79208: PUSH
79209: LD_INT 1
79211: ARRAY
79212: PPUSH
79213: LD_VAR 0 12
79217: PUSH
79218: LD_VAR 0 7
79222: ARRAY
79223: PUSH
79224: LD_INT 2
79226: ARRAY
79227: PPUSH
79228: CALL_OW 351
79232: OR
79233: IFFALSE 79239
// exit ;
79235: POP
79236: POP
79237: GO 79546
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79239: LD_ADDR_VAR 0 8
79243: PUSH
79244: LD_VAR 0 12
79248: PUSH
79249: LD_VAR 0 7
79253: ARRAY
79254: PUSH
79255: LD_INT 1
79257: ARRAY
79258: PPUSH
79259: LD_VAR 0 12
79263: PUSH
79264: LD_VAR 0 7
79268: ARRAY
79269: PUSH
79270: LD_INT 2
79272: ARRAY
79273: PPUSH
79274: CALL_OW 546
79278: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79279: LD_VAR 0 8
79283: PUSH
79284: LD_INT 1
79286: ARRAY
79287: PUSH
79288: LD_VAR 0 8
79292: PUSH
79293: LD_INT 2
79295: ARRAY
79296: PUSH
79297: LD_VAR 0 13
79301: PUSH
79302: LD_INT 2
79304: PLUS
79305: GREATER
79306: OR
79307: PUSH
79308: LD_VAR 0 8
79312: PUSH
79313: LD_INT 2
79315: ARRAY
79316: PUSH
79317: LD_VAR 0 13
79321: PUSH
79322: LD_INT 2
79324: MINUS
79325: LESS
79326: OR
79327: PUSH
79328: LD_VAR 0 8
79332: PUSH
79333: LD_INT 3
79335: ARRAY
79336: PUSH
79337: LD_INT 0
79339: PUSH
79340: LD_INT 8
79342: PUSH
79343: LD_INT 9
79345: PUSH
79346: LD_INT 10
79348: PUSH
79349: LD_INT 11
79351: PUSH
79352: LD_INT 12
79354: PUSH
79355: LD_INT 13
79357: PUSH
79358: LD_INT 16
79360: PUSH
79361: LD_INT 17
79363: PUSH
79364: LD_INT 18
79366: PUSH
79367: LD_INT 19
79369: PUSH
79370: LD_INT 20
79372: PUSH
79373: LD_INT 21
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: IN
79391: NOT
79392: OR
79393: PUSH
79394: LD_VAR 0 8
79398: PUSH
79399: LD_INT 5
79401: ARRAY
79402: NOT
79403: OR
79404: PUSH
79405: LD_VAR 0 8
79409: PUSH
79410: LD_INT 6
79412: ARRAY
79413: PUSH
79414: LD_INT 1
79416: PUSH
79417: LD_INT 2
79419: PUSH
79420: LD_INT 7
79422: PUSH
79423: LD_INT 9
79425: PUSH
79426: LD_INT 10
79428: PUSH
79429: LD_INT 11
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: IN
79440: NOT
79441: OR
79442: IFFALSE 79448
// exit ;
79444: POP
79445: POP
79446: GO 79546
// end ;
79448: GO 79119
79450: POP
79451: POP
// side := GetSide ( depot ) ;
79452: LD_ADDR_VAR 0 9
79456: PUSH
79457: LD_VAR 0 1
79461: PPUSH
79462: CALL_OW 255
79466: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79467: LD_VAR 0 9
79471: PPUSH
79472: LD_VAR 0 3
79476: PPUSH
79477: LD_VAR 0 4
79481: PPUSH
79482: LD_INT 20
79484: PPUSH
79485: CALL 72200 0 4
79489: PUSH
79490: LD_INT 4
79492: ARRAY
79493: IFFALSE 79497
// exit ;
79495: GO 79546
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79497: LD_VAR 0 2
79501: PUSH
79502: LD_INT 29
79504: PUSH
79505: LD_INT 30
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: IN
79512: PUSH
79513: LD_VAR 0 3
79517: PPUSH
79518: LD_VAR 0 4
79522: PPUSH
79523: LD_VAR 0 9
79527: PPUSH
79528: CALL_OW 440
79532: NOT
79533: AND
79534: IFFALSE 79538
// exit ;
79536: GO 79546
// result := true ;
79538: LD_ADDR_VAR 0 6
79542: PUSH
79543: LD_INT 1
79545: ST_TO_ADDR
// end ;
79546: LD_VAR 0 6
79550: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79551: LD_INT 0
79553: PPUSH
79554: PPUSH
79555: PPUSH
79556: PPUSH
79557: PPUSH
79558: PPUSH
79559: PPUSH
79560: PPUSH
79561: PPUSH
79562: PPUSH
79563: PPUSH
79564: PPUSH
79565: PPUSH
79566: PPUSH
79567: PPUSH
79568: PPUSH
79569: PPUSH
79570: PPUSH
79571: PPUSH
79572: PPUSH
79573: PPUSH
79574: PPUSH
79575: PPUSH
79576: PPUSH
79577: PPUSH
79578: PPUSH
79579: PPUSH
79580: PPUSH
79581: PPUSH
79582: PPUSH
79583: PPUSH
79584: PPUSH
79585: PPUSH
79586: PPUSH
79587: PPUSH
79588: PPUSH
79589: PPUSH
79590: PPUSH
79591: PPUSH
79592: PPUSH
79593: PPUSH
79594: PPUSH
79595: PPUSH
79596: PPUSH
79597: PPUSH
79598: PPUSH
79599: PPUSH
79600: PPUSH
79601: PPUSH
79602: PPUSH
79603: PPUSH
79604: PPUSH
79605: PPUSH
79606: PPUSH
79607: PPUSH
79608: PPUSH
79609: PPUSH
79610: PPUSH
// result = [ ] ;
79611: LD_ADDR_VAR 0 7
79615: PUSH
79616: EMPTY
79617: ST_TO_ADDR
// temp_list = [ ] ;
79618: LD_ADDR_VAR 0 9
79622: PUSH
79623: EMPTY
79624: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79625: LD_VAR 0 4
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: LD_INT 1
79635: PUSH
79636: LD_INT 2
79638: PUSH
79639: LD_INT 3
79641: PUSH
79642: LD_INT 4
79644: PUSH
79645: LD_INT 5
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: IN
79656: NOT
79657: PUSH
79658: LD_VAR 0 1
79662: PUSH
79663: LD_INT 0
79665: PUSH
79666: LD_INT 1
79668: PUSH
79669: EMPTY
79670: LIST
79671: LIST
79672: IN
79673: PUSH
79674: LD_VAR 0 5
79678: PUSH
79679: LD_INT 1
79681: PUSH
79682: LD_INT 2
79684: PUSH
79685: LD_INT 3
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: LIST
79692: IN
79693: NOT
79694: AND
79695: OR
79696: IFFALSE 79700
// exit ;
79698: GO 98091
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79700: LD_VAR 0 1
79704: PUSH
79705: LD_INT 6
79707: PUSH
79708: LD_INT 7
79710: PUSH
79711: LD_INT 8
79713: PUSH
79714: LD_INT 13
79716: PUSH
79717: LD_INT 12
79719: PUSH
79720: LD_INT 15
79722: PUSH
79723: LD_INT 11
79725: PUSH
79726: LD_INT 14
79728: PUSH
79729: LD_INT 10
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: LIST
79741: LIST
79742: IN
79743: IFFALSE 79753
// btype = b_lab ;
79745: LD_ADDR_VAR 0 1
79749: PUSH
79750: LD_INT 6
79752: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79753: LD_VAR 0 6
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 1
79763: PUSH
79764: LD_INT 2
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: LIST
79771: IN
79772: NOT
79773: PUSH
79774: LD_VAR 0 1
79778: PUSH
79779: LD_INT 0
79781: PUSH
79782: LD_INT 1
79784: PUSH
79785: LD_INT 2
79787: PUSH
79788: LD_INT 3
79790: PUSH
79791: LD_INT 6
79793: PUSH
79794: LD_INT 36
79796: PUSH
79797: LD_INT 4
79799: PUSH
79800: LD_INT 5
79802: PUSH
79803: LD_INT 31
79805: PUSH
79806: LD_INT 32
79808: PUSH
79809: LD_INT 33
79811: PUSH
79812: EMPTY
79813: LIST
79814: LIST
79815: LIST
79816: LIST
79817: LIST
79818: LIST
79819: LIST
79820: LIST
79821: LIST
79822: LIST
79823: LIST
79824: IN
79825: NOT
79826: PUSH
79827: LD_VAR 0 6
79831: PUSH
79832: LD_INT 1
79834: EQUAL
79835: AND
79836: OR
79837: PUSH
79838: LD_VAR 0 1
79842: PUSH
79843: LD_INT 2
79845: PUSH
79846: LD_INT 3
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: IN
79853: NOT
79854: PUSH
79855: LD_VAR 0 6
79859: PUSH
79860: LD_INT 2
79862: EQUAL
79863: AND
79864: OR
79865: IFFALSE 79875
// mode = 0 ;
79867: LD_ADDR_VAR 0 6
79871: PUSH
79872: LD_INT 0
79874: ST_TO_ADDR
// case mode of 0 :
79875: LD_VAR 0 6
79879: PUSH
79880: LD_INT 0
79882: DOUBLE
79883: EQUAL
79884: IFTRUE 79888
79886: GO 91341
79888: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79889: LD_ADDR_VAR 0 11
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: LD_INT 0
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: LD_INT 1
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: LD_INT 0
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 0
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 1
79947: NEG
79948: PUSH
79949: LD_INT 0
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 1
79958: NEG
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: NEG
79971: PUSH
79972: LD_INT 2
79974: NEG
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 0
79982: PUSH
79983: LD_INT 2
79985: NEG
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 1
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 1
80004: PUSH
80005: LD_INT 2
80007: PUSH
80008: EMPTY
80009: LIST
80010: LIST
80011: PUSH
80012: LD_INT 0
80014: PUSH
80015: LD_INT 2
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: PUSH
80022: LD_INT 1
80024: NEG
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 1
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 0
80045: PUSH
80046: LD_INT 3
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 1
80055: NEG
80056: PUSH
80057: LD_INT 2
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80082: LD_ADDR_VAR 0 12
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 0
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 1
80110: PUSH
80111: LD_INT 0
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 1
80120: PUSH
80121: LD_INT 1
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 1
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 1
80140: NEG
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: PUSH
80164: LD_INT 1
80166: NEG
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: PUSH
80172: LD_INT 2
80174: PUSH
80175: LD_INT 0
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 2
80184: PUSH
80185: LD_INT 1
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: LD_INT 1
80194: NEG
80195: PUSH
80196: LD_INT 1
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 2
80205: NEG
80206: PUSH
80207: LD_INT 0
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 2
80216: NEG
80217: PUSH
80218: LD_INT 1
80220: NEG
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 2
80228: NEG
80229: PUSH
80230: LD_INT 1
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 3
80239: NEG
80240: PUSH
80241: LD_INT 0
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 3
80250: NEG
80251: PUSH
80252: LD_INT 1
80254: NEG
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: EMPTY
80261: LIST
80262: LIST
80263: LIST
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80278: LD_ADDR_VAR 0 13
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: LD_INT 0
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 0
80295: PUSH
80296: LD_INT 1
80298: NEG
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 1
80306: PUSH
80307: LD_INT 0
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: LD_INT 1
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 0
80326: PUSH
80327: LD_INT 1
80329: PUSH
80330: EMPTY
80331: LIST
80332: LIST
80333: PUSH
80334: LD_INT 1
80336: NEG
80337: PUSH
80338: LD_INT 0
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: LD_INT 1
80351: NEG
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 1
80359: NEG
80360: PUSH
80361: LD_INT 2
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 2
80371: PUSH
80372: LD_INT 1
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 2
80381: PUSH
80382: LD_INT 2
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: PUSH
80389: LD_INT 1
80391: PUSH
80392: LD_INT 2
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: PUSH
80399: LD_INT 2
80401: NEG
80402: PUSH
80403: LD_INT 1
80405: NEG
80406: PUSH
80407: EMPTY
80408: LIST
80409: LIST
80410: PUSH
80411: LD_INT 2
80413: NEG
80414: PUSH
80415: LD_INT 2
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 2
80425: NEG
80426: PUSH
80427: LD_INT 3
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 3
80437: NEG
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 3
80449: NEG
80450: PUSH
80451: LD_INT 3
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: LIST
80463: LIST
80464: LIST
80465: LIST
80466: LIST
80467: LIST
80468: LIST
80469: LIST
80470: LIST
80471: LIST
80472: LIST
80473: LIST
80474: LIST
80475: LIST
80476: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80477: LD_ADDR_VAR 0 14
80481: PUSH
80482: LD_INT 0
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PUSH
80492: LD_INT 0
80494: PUSH
80495: LD_INT 1
80497: NEG
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 1
80505: PUSH
80506: LD_INT 0
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 1
80515: PUSH
80516: LD_INT 1
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 0
80525: PUSH
80526: LD_INT 1
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 1
80535: NEG
80536: PUSH
80537: LD_INT 0
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 1
80546: NEG
80547: PUSH
80548: LD_INT 1
80550: NEG
80551: PUSH
80552: EMPTY
80553: LIST
80554: LIST
80555: PUSH
80556: LD_INT 1
80558: NEG
80559: PUSH
80560: LD_INT 2
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 2
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 1
80581: PUSH
80582: LD_INT 1
80584: NEG
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: PUSH
80593: LD_INT 2
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 2
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: NEG
80613: PUSH
80614: LD_INT 1
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 3
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 3
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 2
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: LIST
80659: LIST
80660: LIST
80661: LIST
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80673: LD_ADDR_VAR 0 15
80677: PUSH
80678: LD_INT 0
80680: PUSH
80681: LD_INT 0
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 0
80690: PUSH
80691: LD_INT 1
80693: NEG
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 1
80701: PUSH
80702: LD_INT 0
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: LD_INT 1
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PUSH
80719: LD_INT 0
80721: PUSH
80722: LD_INT 1
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 1
80731: NEG
80732: PUSH
80733: LD_INT 0
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 1
80742: NEG
80743: PUSH
80744: LD_INT 1
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 1
80754: PUSH
80755: LD_INT 1
80757: NEG
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 2
80765: PUSH
80766: LD_INT 0
80768: PUSH
80769: EMPTY
80770: LIST
80771: LIST
80772: PUSH
80773: LD_INT 2
80775: PUSH
80776: LD_INT 1
80778: PUSH
80779: EMPTY
80780: LIST
80781: LIST
80782: PUSH
80783: LD_INT 1
80785: NEG
80786: PUSH
80787: LD_INT 1
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 2
80796: NEG
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 2
80807: NEG
80808: PUSH
80809: LD_INT 1
80811: NEG
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 2
80819: PUSH
80820: LD_INT 1
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 3
80830: PUSH
80831: LD_INT 0
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 3
80840: PUSH
80841: LD_INT 1
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80866: LD_ADDR_VAR 0 16
80870: PUSH
80871: LD_INT 0
80873: PUSH
80874: LD_INT 0
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 0
80883: PUSH
80884: LD_INT 1
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: LD_INT 0
80897: PUSH
80898: EMPTY
80899: LIST
80900: LIST
80901: PUSH
80902: LD_INT 1
80904: PUSH
80905: LD_INT 1
80907: PUSH
80908: EMPTY
80909: LIST
80910: LIST
80911: PUSH
80912: LD_INT 0
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 1
80924: NEG
80925: PUSH
80926: LD_INT 0
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 1
80935: NEG
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: EMPTY
80942: LIST
80943: LIST
80944: PUSH
80945: LD_INT 1
80947: NEG
80948: PUSH
80949: LD_INT 2
80951: NEG
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: PUSH
80960: LD_INT 1
80962: PUSH
80963: EMPTY
80964: LIST
80965: LIST
80966: PUSH
80967: LD_INT 2
80969: PUSH
80970: LD_INT 2
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PUSH
80977: LD_INT 1
80979: PUSH
80980: LD_INT 2
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 2
80989: NEG
80990: PUSH
80991: LD_INT 1
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 2
81001: NEG
81002: PUSH
81003: LD_INT 2
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 3
81013: PUSH
81014: LD_INT 2
81016: PUSH
81017: EMPTY
81018: LIST
81019: LIST
81020: PUSH
81021: LD_INT 3
81023: PUSH
81024: LD_INT 3
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 2
81033: PUSH
81034: LD_INT 3
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81059: LD_ADDR_VAR 0 17
81063: PUSH
81064: LD_INT 0
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: LD_INT 0
81076: PUSH
81077: LD_INT 1
81079: NEG
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: LD_INT 0
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 1
81097: PUSH
81098: LD_INT 1
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 0
81107: PUSH
81108: LD_INT 1
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 1
81117: NEG
81118: PUSH
81119: LD_INT 0
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 1
81128: NEG
81129: PUSH
81130: LD_INT 1
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: LD_INT 2
81144: NEG
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: LD_INT 2
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 1
81163: PUSH
81164: LD_INT 1
81166: NEG
81167: PUSH
81168: EMPTY
81169: LIST
81170: LIST
81171: PUSH
81172: LD_INT 2
81174: PUSH
81175: LD_INT 0
81177: PUSH
81178: EMPTY
81179: LIST
81180: LIST
81181: PUSH
81182: LD_INT 2
81184: PUSH
81185: LD_INT 1
81187: PUSH
81188: EMPTY
81189: LIST
81190: LIST
81191: PUSH
81192: LD_INT 2
81194: PUSH
81195: LD_INT 2
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 1
81204: PUSH
81205: LD_INT 2
81207: PUSH
81208: EMPTY
81209: LIST
81210: LIST
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: LD_INT 2
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: LD_INT 1
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 2
81235: NEG
81236: PUSH
81237: LD_INT 0
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 2
81246: NEG
81247: PUSH
81248: LD_INT 1
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: NEG
81259: PUSH
81260: LD_INT 2
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: LIST
81280: LIST
81281: LIST
81282: LIST
81283: LIST
81284: LIST
81285: LIST
81286: LIST
81287: LIST
81288: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81289: LD_ADDR_VAR 0 18
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 0
81306: PUSH
81307: LD_INT 1
81309: NEG
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 1
81317: PUSH
81318: LD_INT 0
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 1
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: PUSH
81335: LD_INT 0
81337: PUSH
81338: LD_INT 1
81340: PUSH
81341: EMPTY
81342: LIST
81343: LIST
81344: PUSH
81345: LD_INT 1
81347: NEG
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 1
81358: NEG
81359: PUSH
81360: LD_INT 1
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 1
81370: NEG
81371: PUSH
81372: LD_INT 2
81374: NEG
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 2
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 1
81396: NEG
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: PUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 0
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 1
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 2
81424: PUSH
81425: LD_INT 2
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 1
81434: PUSH
81435: LD_INT 2
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 0
81444: PUSH
81445: LD_INT 2
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: PUSH
81452: LD_INT 1
81454: NEG
81455: PUSH
81456: LD_INT 1
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 2
81465: NEG
81466: PUSH
81467: LD_INT 0
81469: PUSH
81470: EMPTY
81471: LIST
81472: LIST
81473: PUSH
81474: LD_INT 2
81476: NEG
81477: PUSH
81478: LD_INT 1
81480: NEG
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: LD_INT 2
81492: NEG
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81519: LD_ADDR_VAR 0 19
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: EMPTY
81531: LIST
81532: LIST
81533: PUSH
81534: LD_INT 0
81536: PUSH
81537: LD_INT 1
81539: NEG
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: PUSH
81545: LD_INT 1
81547: PUSH
81548: LD_INT 0
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 1
81557: PUSH
81558: LD_INT 1
81560: PUSH
81561: EMPTY
81562: LIST
81563: LIST
81564: PUSH
81565: LD_INT 0
81567: PUSH
81568: LD_INT 1
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: LD_INT 0
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 1
81588: NEG
81589: PUSH
81590: LD_INT 1
81592: NEG
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 1
81600: NEG
81601: PUSH
81602: LD_INT 2
81604: NEG
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: LD_INT 2
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: LD_INT 1
81626: NEG
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: PUSH
81635: LD_INT 0
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 2
81644: PUSH
81645: LD_INT 1
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 2
81654: PUSH
81655: LD_INT 2
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 1
81664: PUSH
81665: LD_INT 2
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 0
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 1
81684: NEG
81685: PUSH
81686: LD_INT 1
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 2
81695: NEG
81696: PUSH
81697: LD_INT 0
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 2
81706: NEG
81707: PUSH
81708: LD_INT 1
81710: NEG
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: LD_INT 2
81718: NEG
81719: PUSH
81720: LD_INT 2
81722: NEG
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81749: LD_ADDR_VAR 0 20
81753: PUSH
81754: LD_INT 0
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: EMPTY
81761: LIST
81762: LIST
81763: PUSH
81764: LD_INT 0
81766: PUSH
81767: LD_INT 1
81769: NEG
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 1
81777: PUSH
81778: LD_INT 0
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 1
81787: PUSH
81788: LD_INT 1
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: LD_INT 1
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 1
81807: NEG
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 1
81818: NEG
81819: PUSH
81820: LD_INT 1
81822: NEG
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 1
81830: NEG
81831: PUSH
81832: LD_INT 2
81834: NEG
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: LD_INT 2
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: LD_INT 1
81856: NEG
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 2
81864: PUSH
81865: LD_INT 0
81867: PUSH
81868: EMPTY
81869: LIST
81870: LIST
81871: PUSH
81872: LD_INT 2
81874: PUSH
81875: LD_INT 1
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 2
81884: PUSH
81885: LD_INT 2
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 1
81894: PUSH
81895: LD_INT 2
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 0
81904: PUSH
81905: LD_INT 2
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 1
81914: NEG
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 2
81925: NEG
81926: PUSH
81927: LD_INT 0
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 2
81936: NEG
81937: PUSH
81938: LD_INT 1
81940: NEG
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 2
81948: NEG
81949: PUSH
81950: LD_INT 2
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: LIST
81971: LIST
81972: LIST
81973: LIST
81974: LIST
81975: LIST
81976: LIST
81977: LIST
81978: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81979: LD_ADDR_VAR 0 21
81983: PUSH
81984: LD_INT 0
81986: PUSH
81987: LD_INT 0
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 1
81999: NEG
82000: PUSH
82001: EMPTY
82002: LIST
82003: LIST
82004: PUSH
82005: LD_INT 1
82007: PUSH
82008: LD_INT 0
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 1
82017: PUSH
82018: LD_INT 1
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 0
82027: PUSH
82028: LD_INT 1
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 1
82037: NEG
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: PUSH
82046: LD_INT 1
82048: NEG
82049: PUSH
82050: LD_INT 1
82052: NEG
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 1
82060: NEG
82061: PUSH
82062: LD_INT 2
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 2
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 1
82083: PUSH
82084: LD_INT 1
82086: NEG
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 2
82094: PUSH
82095: LD_INT 0
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 2
82104: PUSH
82105: LD_INT 1
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: LD_INT 2
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 1
82124: PUSH
82125: LD_INT 2
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: LD_INT 2
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 1
82144: NEG
82145: PUSH
82146: LD_INT 1
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 0
82159: PUSH
82160: EMPTY
82161: LIST
82162: LIST
82163: PUSH
82164: LD_INT 2
82166: NEG
82167: PUSH
82168: LD_INT 1
82170: NEG
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 2
82178: NEG
82179: PUSH
82180: LD_INT 2
82182: NEG
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82209: LD_ADDR_VAR 0 22
82213: PUSH
82214: LD_INT 0
82216: PUSH
82217: LD_INT 0
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 0
82226: PUSH
82227: LD_INT 1
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 1
82237: PUSH
82238: LD_INT 0
82240: PUSH
82241: EMPTY
82242: LIST
82243: LIST
82244: PUSH
82245: LD_INT 1
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 0
82257: PUSH
82258: LD_INT 1
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: NEG
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PUSH
82276: LD_INT 1
82278: NEG
82279: PUSH
82280: LD_INT 1
82282: NEG
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 1
82290: NEG
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 2
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 1
82313: PUSH
82314: LD_INT 1
82316: NEG
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: PUSH
82322: LD_INT 2
82324: PUSH
82325: LD_INT 0
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: PUSH
82335: LD_INT 1
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 2
82344: PUSH
82345: LD_INT 2
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: LD_INT 2
82357: PUSH
82358: EMPTY
82359: LIST
82360: LIST
82361: PUSH
82362: LD_INT 0
82364: PUSH
82365: LD_INT 2
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 1
82374: NEG
82375: PUSH
82376: LD_INT 1
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: NEG
82386: PUSH
82387: LD_INT 0
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 2
82396: NEG
82397: PUSH
82398: LD_INT 1
82400: NEG
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 2
82408: NEG
82409: PUSH
82410: LD_INT 2
82412: NEG
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82439: LD_ADDR_VAR 0 23
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: LD_INT 0
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 0
82456: PUSH
82457: LD_INT 1
82459: NEG
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 1
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 1
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 0
82487: PUSH
82488: LD_INT 1
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 1
82508: NEG
82509: PUSH
82510: LD_INT 1
82512: NEG
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 1
82520: NEG
82521: PUSH
82522: LD_INT 2
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: LD_INT 2
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 1
82543: PUSH
82544: LD_INT 1
82546: NEG
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 2
82554: PUSH
82555: LD_INT 0
82557: PUSH
82558: EMPTY
82559: LIST
82560: LIST
82561: PUSH
82562: LD_INT 2
82564: PUSH
82565: LD_INT 1
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: PUSH
82572: LD_INT 2
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: LD_INT 2
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 0
82594: PUSH
82595: LD_INT 2
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 1
82604: NEG
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: NEG
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: PUSH
82624: LD_INT 2
82626: NEG
82627: PUSH
82628: LD_INT 1
82630: NEG
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 2
82638: NEG
82639: PUSH
82640: LD_INT 2
82642: NEG
82643: PUSH
82644: EMPTY
82645: LIST
82646: LIST
82647: PUSH
82648: LD_INT 2
82650: NEG
82651: PUSH
82652: LD_INT 3
82654: NEG
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 1
82662: NEG
82663: PUSH
82664: LD_INT 3
82666: NEG
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: LD_INT 2
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 2
82685: PUSH
82686: LD_INT 1
82688: NEG
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82719: LD_ADDR_VAR 0 24
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 0
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 0
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: LD_INT 1
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: LD_INT 1
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 1
82777: NEG
82778: PUSH
82779: LD_INT 0
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 1
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: LD_INT 2
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: LD_INT 2
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: LD_INT 2
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: LD_INT 2
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 0
82874: PUSH
82875: LD_INT 2
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: LD_INT 1
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: PUSH
82893: LD_INT 2
82895: NEG
82896: PUSH
82897: LD_INT 0
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 2
82906: NEG
82907: PUSH
82908: LD_INT 1
82910: NEG
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: PUSH
82916: LD_INT 2
82918: NEG
82919: PUSH
82920: LD_INT 2
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 1
82930: PUSH
82931: LD_INT 2
82933: NEG
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 1
82944: NEG
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 3
82952: PUSH
82953: LD_INT 1
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 3
82962: PUSH
82963: LD_INT 2
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82995: LD_ADDR_VAR 0 25
82999: PUSH
83000: LD_INT 0
83002: PUSH
83003: LD_INT 0
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 0
83012: PUSH
83013: LD_INT 1
83015: NEG
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 1
83023: PUSH
83024: LD_INT 0
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: LD_INT 1
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: LD_INT 1
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 1
83053: NEG
83054: PUSH
83055: LD_INT 0
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 1
83064: NEG
83065: PUSH
83066: LD_INT 1
83068: NEG
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 1
83076: NEG
83077: PUSH
83078: LD_INT 2
83080: NEG
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 0
83088: PUSH
83089: LD_INT 2
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 1
83099: PUSH
83100: LD_INT 1
83102: NEG
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 2
83110: PUSH
83111: LD_INT 0
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PUSH
83118: LD_INT 2
83120: PUSH
83121: LD_INT 1
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 1
83140: PUSH
83141: LD_INT 2
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 0
83150: PUSH
83151: LD_INT 2
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 1
83160: NEG
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 2
83171: NEG
83172: PUSH
83173: LD_INT 0
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 2
83182: NEG
83183: PUSH
83184: LD_INT 1
83186: NEG
83187: PUSH
83188: EMPTY
83189: LIST
83190: LIST
83191: PUSH
83192: LD_INT 2
83194: NEG
83195: PUSH
83196: LD_INT 2
83198: NEG
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 3
83206: PUSH
83207: LD_INT 1
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 3
83216: PUSH
83217: LD_INT 2
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 2
83226: PUSH
83227: LD_INT 3
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: LD_INT 3
83239: PUSH
83240: EMPTY
83241: LIST
83242: LIST
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83269: LD_ADDR_VAR 0 26
83273: PUSH
83274: LD_INT 0
83276: PUSH
83277: LD_INT 0
83279: PUSH
83280: EMPTY
83281: LIST
83282: LIST
83283: PUSH
83284: LD_INT 0
83286: PUSH
83287: LD_INT 1
83289: NEG
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 1
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 1
83307: PUSH
83308: LD_INT 1
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: LD_INT 1
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 1
83327: NEG
83328: PUSH
83329: LD_INT 0
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: NEG
83339: PUSH
83340: LD_INT 1
83342: NEG
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 1
83350: NEG
83351: PUSH
83352: LD_INT 2
83354: NEG
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 0
83362: PUSH
83363: LD_INT 2
83365: NEG
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 1
83373: PUSH
83374: LD_INT 1
83376: NEG
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 0
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 2
83394: PUSH
83395: LD_INT 1
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 2
83404: PUSH
83405: LD_INT 2
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 1
83414: PUSH
83415: LD_INT 2
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 0
83424: PUSH
83425: LD_INT 2
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: NEG
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 2
83445: NEG
83446: PUSH
83447: LD_INT 0
83449: PUSH
83450: EMPTY
83451: LIST
83452: LIST
83453: PUSH
83454: LD_INT 2
83456: NEG
83457: PUSH
83458: LD_INT 1
83460: NEG
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 2
83468: NEG
83469: PUSH
83470: LD_INT 2
83472: NEG
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 2
83480: PUSH
83481: LD_INT 3
83483: PUSH
83484: EMPTY
83485: LIST
83486: LIST
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: LD_INT 3
83493: PUSH
83494: EMPTY
83495: LIST
83496: LIST
83497: PUSH
83498: LD_INT 1
83500: NEG
83501: PUSH
83502: LD_INT 2
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 2
83511: NEG
83512: PUSH
83513: LD_INT 1
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: EMPTY
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83545: LD_ADDR_VAR 0 27
83549: PUSH
83550: LD_INT 0
83552: PUSH
83553: LD_INT 0
83555: PUSH
83556: EMPTY
83557: LIST
83558: LIST
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: LD_INT 1
83565: NEG
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PUSH
83571: LD_INT 1
83573: PUSH
83574: LD_INT 0
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 1
83583: PUSH
83584: LD_INT 1
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 0
83593: PUSH
83594: LD_INT 1
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: NEG
83604: PUSH
83605: LD_INT 0
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 1
83614: NEG
83615: PUSH
83616: LD_INT 1
83618: NEG
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: LD_INT 2
83630: NEG
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: LD_INT 2
83641: NEG
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 1
83649: PUSH
83650: LD_INT 1
83652: NEG
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 2
83660: PUSH
83661: LD_INT 0
83663: PUSH
83664: EMPTY
83665: LIST
83666: LIST
83667: PUSH
83668: LD_INT 2
83670: PUSH
83671: LD_INT 1
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PUSH
83678: LD_INT 2
83680: PUSH
83681: LD_INT 2
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 1
83690: PUSH
83691: LD_INT 2
83693: PUSH
83694: EMPTY
83695: LIST
83696: LIST
83697: PUSH
83698: LD_INT 0
83700: PUSH
83701: LD_INT 2
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: NEG
83711: PUSH
83712: LD_INT 1
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 2
83721: NEG
83722: PUSH
83723: LD_INT 0
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 2
83732: NEG
83733: PUSH
83734: LD_INT 1
83736: NEG
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 2
83744: NEG
83745: PUSH
83746: LD_INT 2
83748: NEG
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: PUSH
83754: LD_INT 1
83756: NEG
83757: PUSH
83758: LD_INT 2
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 2
83767: NEG
83768: PUSH
83769: LD_INT 1
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 3
83778: NEG
83779: PUSH
83780: LD_INT 1
83782: NEG
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 3
83790: NEG
83791: PUSH
83792: LD_INT 2
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83825: LD_ADDR_VAR 0 28
83829: PUSH
83830: LD_INT 0
83832: PUSH
83833: LD_INT 0
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: LD_INT 1
83845: NEG
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: LD_INT 0
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: PUSH
83861: LD_INT 1
83863: PUSH
83864: LD_INT 1
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: PUSH
83871: LD_INT 0
83873: PUSH
83874: LD_INT 1
83876: PUSH
83877: EMPTY
83878: LIST
83879: LIST
83880: PUSH
83881: LD_INT 1
83883: NEG
83884: PUSH
83885: LD_INT 0
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: PUSH
83892: LD_INT 1
83894: NEG
83895: PUSH
83896: LD_INT 1
83898: NEG
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 1
83906: NEG
83907: PUSH
83908: LD_INT 2
83910: NEG
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: PUSH
83916: LD_INT 0
83918: PUSH
83919: LD_INT 2
83921: NEG
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 1
83929: PUSH
83930: LD_INT 1
83932: NEG
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 2
83940: PUSH
83941: LD_INT 0
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: PUSH
83948: LD_INT 2
83950: PUSH
83951: LD_INT 1
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: LD_INT 2
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: PUSH
83968: LD_INT 1
83970: PUSH
83971: LD_INT 2
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: PUSH
83978: LD_INT 0
83980: PUSH
83981: LD_INT 2
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: PUSH
83988: LD_INT 1
83990: NEG
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: EMPTY
83996: LIST
83997: LIST
83998: PUSH
83999: LD_INT 2
84001: NEG
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 2
84012: NEG
84013: PUSH
84014: LD_INT 1
84016: NEG
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 2
84024: NEG
84025: PUSH
84026: LD_INT 2
84028: NEG
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 2
84036: NEG
84037: PUSH
84038: LD_INT 3
84040: NEG
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 1
84048: NEG
84049: PUSH
84050: LD_INT 3
84052: NEG
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 3
84060: NEG
84061: PUSH
84062: LD_INT 1
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 3
84072: NEG
84073: PUSH
84074: LD_INT 2
84076: NEG
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84107: LD_ADDR_VAR 0 29
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: LD_INT 0
84117: PUSH
84118: EMPTY
84119: LIST
84120: LIST
84121: PUSH
84122: LD_INT 0
84124: PUSH
84125: LD_INT 1
84127: NEG
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 1
84135: PUSH
84136: LD_INT 0
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 1
84145: PUSH
84146: LD_INT 1
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: LD_INT 1
84158: PUSH
84159: EMPTY
84160: LIST
84161: LIST
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: LD_INT 0
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: LD_INT 1
84176: NEG
84177: PUSH
84178: LD_INT 1
84180: NEG
84181: PUSH
84182: EMPTY
84183: LIST
84184: LIST
84185: PUSH
84186: LD_INT 1
84188: NEG
84189: PUSH
84190: LD_INT 2
84192: NEG
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: LD_INT 2
84203: NEG
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 1
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: LD_INT 2
84222: PUSH
84223: LD_INT 0
84225: PUSH
84226: EMPTY
84227: LIST
84228: LIST
84229: PUSH
84230: LD_INT 2
84232: PUSH
84233: LD_INT 1
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: LD_INT 2
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 0
84252: PUSH
84253: LD_INT 2
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: NEG
84263: PUSH
84264: LD_INT 1
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 2
84273: NEG
84274: PUSH
84275: LD_INT 1
84277: NEG
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 2
84285: NEG
84286: PUSH
84287: LD_INT 2
84289: NEG
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: PUSH
84295: LD_INT 2
84297: NEG
84298: PUSH
84299: LD_INT 3
84301: NEG
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: PUSH
84307: LD_INT 2
84309: PUSH
84310: LD_INT 1
84312: NEG
84313: PUSH
84314: EMPTY
84315: LIST
84316: LIST
84317: PUSH
84318: LD_INT 3
84320: PUSH
84321: LD_INT 1
84323: PUSH
84324: EMPTY
84325: LIST
84326: LIST
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 3
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: PUSH
84338: LD_INT 1
84340: NEG
84341: PUSH
84342: LD_INT 2
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 3
84351: NEG
84352: PUSH
84353: LD_INT 2
84355: NEG
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84386: LD_ADDR_VAR 0 30
84390: PUSH
84391: LD_INT 0
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: EMPTY
84398: LIST
84399: LIST
84400: PUSH
84401: LD_INT 0
84403: PUSH
84404: LD_INT 1
84406: NEG
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: PUSH
84412: LD_INT 1
84414: PUSH
84415: LD_INT 0
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: LD_INT 1
84427: PUSH
84428: EMPTY
84429: LIST
84430: LIST
84431: PUSH
84432: LD_INT 0
84434: PUSH
84435: LD_INT 1
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 1
84444: NEG
84445: PUSH
84446: LD_INT 0
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: LD_INT 1
84459: NEG
84460: PUSH
84461: EMPTY
84462: LIST
84463: LIST
84464: PUSH
84465: LD_INT 1
84467: NEG
84468: PUSH
84469: LD_INT 2
84471: NEG
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 0
84479: PUSH
84480: LD_INT 2
84482: NEG
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 1
84490: PUSH
84491: LD_INT 1
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 2
84501: PUSH
84502: LD_INT 0
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: PUSH
84509: LD_INT 2
84511: PUSH
84512: LD_INT 1
84514: PUSH
84515: EMPTY
84516: LIST
84517: LIST
84518: PUSH
84519: LD_INT 2
84521: PUSH
84522: LD_INT 2
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: PUSH
84529: LD_INT 1
84531: PUSH
84532: LD_INT 2
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 1
84541: NEG
84542: PUSH
84543: LD_INT 1
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 2
84552: NEG
84553: PUSH
84554: LD_INT 0
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 2
84563: NEG
84564: PUSH
84565: LD_INT 1
84567: NEG
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: LD_INT 1
84575: NEG
84576: PUSH
84577: LD_INT 3
84579: NEG
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 1
84587: PUSH
84588: LD_INT 2
84590: NEG
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 3
84598: PUSH
84599: LD_INT 2
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 2
84608: PUSH
84609: LD_INT 3
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 2
84618: NEG
84619: PUSH
84620: LD_INT 1
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 3
84629: NEG
84630: PUSH
84631: LD_INT 1
84633: NEG
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: EMPTY
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84664: LD_ADDR_VAR 0 31
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: LD_INT 0
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 0
84681: PUSH
84682: LD_INT 1
84684: NEG
84685: PUSH
84686: EMPTY
84687: LIST
84688: LIST
84689: PUSH
84690: LD_INT 1
84692: PUSH
84693: LD_INT 0
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: LD_INT 1
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: LD_INT 1
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: NEG
84723: PUSH
84724: LD_INT 0
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: NEG
84734: PUSH
84735: LD_INT 1
84737: NEG
84738: PUSH
84739: EMPTY
84740: LIST
84741: LIST
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: LD_INT 2
84749: NEG
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 1
84757: PUSH
84758: LD_INT 1
84760: NEG
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 2
84768: PUSH
84769: LD_INT 0
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 2
84778: PUSH
84779: LD_INT 1
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 2
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: LD_INT 2
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 2
84829: NEG
84830: PUSH
84831: LD_INT 1
84833: NEG
84834: PUSH
84835: EMPTY
84836: LIST
84837: LIST
84838: PUSH
84839: LD_INT 2
84841: NEG
84842: PUSH
84843: LD_INT 2
84845: NEG
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 2
84853: NEG
84854: PUSH
84855: LD_INT 3
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 2
84865: PUSH
84866: LD_INT 1
84868: NEG
84869: PUSH
84870: EMPTY
84871: LIST
84872: LIST
84873: PUSH
84874: LD_INT 3
84876: PUSH
84877: LD_INT 1
84879: PUSH
84880: EMPTY
84881: LIST
84882: LIST
84883: PUSH
84884: LD_INT 1
84886: PUSH
84887: LD_INT 3
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 1
84896: NEG
84897: PUSH
84898: LD_INT 2
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 3
84907: NEG
84908: PUSH
84909: LD_INT 2
84911: NEG
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84942: LD_ADDR_VAR 0 32
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 0
84959: PUSH
84960: LD_INT 1
84962: NEG
84963: PUSH
84964: EMPTY
84965: LIST
84966: LIST
84967: PUSH
84968: LD_INT 1
84970: PUSH
84971: LD_INT 0
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: LD_INT 1
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 0
84990: PUSH
84991: LD_INT 1
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: NEG
85001: PUSH
85002: LD_INT 0
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 1
85011: NEG
85012: PUSH
85013: LD_INT 1
85015: NEG
85016: PUSH
85017: EMPTY
85018: LIST
85019: LIST
85020: PUSH
85021: LD_INT 1
85023: NEG
85024: PUSH
85025: LD_INT 2
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 0
85035: PUSH
85036: LD_INT 2
85038: NEG
85039: PUSH
85040: EMPTY
85041: LIST
85042: LIST
85043: PUSH
85044: LD_INT 1
85046: PUSH
85047: LD_INT 1
85049: NEG
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PUSH
85055: LD_INT 2
85057: PUSH
85058: LD_INT 1
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: LD_INT 2
85067: PUSH
85068: LD_INT 2
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 1
85077: PUSH
85078: LD_INT 2
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 0
85087: PUSH
85088: LD_INT 2
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 1
85097: NEG
85098: PUSH
85099: LD_INT 1
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: PUSH
85106: LD_INT 2
85108: NEG
85109: PUSH
85110: LD_INT 0
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 2
85119: NEG
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: LD_INT 3
85135: NEG
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: PUSH
85144: LD_INT 2
85146: NEG
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 3
85154: PUSH
85155: LD_INT 2
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 2
85164: PUSH
85165: LD_INT 3
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 2
85174: NEG
85175: PUSH
85176: LD_INT 1
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 3
85185: NEG
85186: PUSH
85187: LD_INT 1
85189: NEG
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: LIST
85218: LIST
85219: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85220: LD_ADDR_VAR 0 33
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: LD_INT 0
85230: PUSH
85231: EMPTY
85232: LIST
85233: LIST
85234: PUSH
85235: LD_INT 0
85237: PUSH
85238: LD_INT 1
85240: NEG
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 1
85248: PUSH
85249: LD_INT 0
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: LD_INT 1
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: LD_INT 1
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: LD_INT 2
85305: NEG
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: PUSH
85325: LD_INT 0
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: LD_INT 1
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: LD_INT 2
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 0
85354: PUSH
85355: LD_INT 2
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: LD_INT 1
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 0
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: PUSH
85384: LD_INT 2
85386: NEG
85387: PUSH
85388: LD_INT 1
85390: NEG
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 2
85398: NEG
85399: PUSH
85400: LD_INT 2
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: NEG
85411: PUSH
85412: LD_INT 3
85414: NEG
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: LD_INT 1
85425: NEG
85426: PUSH
85427: EMPTY
85428: LIST
85429: LIST
85430: PUSH
85431: LD_INT 3
85433: PUSH
85434: LD_INT 1
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 1
85443: PUSH
85444: LD_INT 3
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: PUSH
85451: LD_INT 1
85453: NEG
85454: PUSH
85455: LD_INT 2
85457: PUSH
85458: EMPTY
85459: LIST
85460: LIST
85461: PUSH
85462: LD_INT 3
85464: NEG
85465: PUSH
85466: LD_INT 2
85468: NEG
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85499: LD_ADDR_VAR 0 34
85503: PUSH
85504: LD_INT 0
85506: PUSH
85507: LD_INT 0
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 0
85516: PUSH
85517: LD_INT 1
85519: NEG
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 1
85527: PUSH
85528: LD_INT 0
85530: PUSH
85531: EMPTY
85532: LIST
85533: LIST
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: LD_INT 1
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: PUSH
85545: LD_INT 0
85547: PUSH
85548: LD_INT 1
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: LD_INT 0
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: LD_INT 1
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: NEG
85581: PUSH
85582: LD_INT 2
85584: NEG
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 0
85592: PUSH
85593: LD_INT 2
85595: NEG
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 1
85603: PUSH
85604: LD_INT 1
85606: NEG
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 2
85614: PUSH
85615: LD_INT 1
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: LD_INT 2
85627: PUSH
85628: EMPTY
85629: LIST
85630: LIST
85631: PUSH
85632: LD_INT 1
85634: PUSH
85635: LD_INT 2
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: NEG
85645: PUSH
85646: LD_INT 1
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 2
85655: NEG
85656: PUSH
85657: LD_INT 0
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 2
85666: NEG
85667: PUSH
85668: LD_INT 1
85670: NEG
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: LD_INT 2
85678: NEG
85679: PUSH
85680: LD_INT 2
85682: NEG
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 1
85690: NEG
85691: PUSH
85692: LD_INT 3
85694: NEG
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: PUSH
85703: LD_INT 2
85705: NEG
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: LD_INT 3
85713: PUSH
85714: LD_INT 2
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 2
85723: PUSH
85724: LD_INT 3
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: LD_INT 2
85733: NEG
85734: PUSH
85735: LD_INT 1
85737: PUSH
85738: EMPTY
85739: LIST
85740: LIST
85741: PUSH
85742: LD_INT 3
85744: NEG
85745: PUSH
85746: LD_INT 1
85748: NEG
85749: PUSH
85750: EMPTY
85751: LIST
85752: LIST
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85779: LD_ADDR_VAR 0 35
85783: PUSH
85784: LD_INT 0
85786: PUSH
85787: LD_INT 0
85789: PUSH
85790: EMPTY
85791: LIST
85792: LIST
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: LD_INT 1
85799: NEG
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: PUSH
85805: LD_INT 1
85807: PUSH
85808: LD_INT 0
85810: PUSH
85811: EMPTY
85812: LIST
85813: LIST
85814: PUSH
85815: LD_INT 1
85817: PUSH
85818: LD_INT 1
85820: PUSH
85821: EMPTY
85822: LIST
85823: LIST
85824: PUSH
85825: LD_INT 0
85827: PUSH
85828: LD_INT 1
85830: PUSH
85831: EMPTY
85832: LIST
85833: LIST
85834: PUSH
85835: LD_INT 1
85837: NEG
85838: PUSH
85839: LD_INT 0
85841: PUSH
85842: EMPTY
85843: LIST
85844: LIST
85845: PUSH
85846: LD_INT 1
85848: NEG
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 2
85860: PUSH
85861: LD_INT 1
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 2
85870: NEG
85871: PUSH
85872: LD_INT 1
85874: NEG
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85891: LD_ADDR_VAR 0 36
85895: PUSH
85896: LD_INT 0
85898: PUSH
85899: LD_INT 0
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 0
85908: PUSH
85909: LD_INT 1
85911: NEG
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 1
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: PUSH
85927: LD_INT 1
85929: PUSH
85930: LD_INT 1
85932: PUSH
85933: EMPTY
85934: LIST
85935: LIST
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: LD_INT 1
85942: PUSH
85943: EMPTY
85944: LIST
85945: LIST
85946: PUSH
85947: LD_INT 1
85949: NEG
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: EMPTY
85955: LIST
85956: LIST
85957: PUSH
85958: LD_INT 1
85960: NEG
85961: PUSH
85962: LD_INT 1
85964: NEG
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 1
85972: NEG
85973: PUSH
85974: LD_INT 2
85976: NEG
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: PUSH
85985: LD_INT 2
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86003: LD_ADDR_VAR 0 37
86007: PUSH
86008: LD_INT 0
86010: PUSH
86011: LD_INT 0
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: PUSH
86018: LD_INT 0
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 1
86031: PUSH
86032: LD_INT 0
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 1
86041: PUSH
86042: LD_INT 1
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 0
86051: PUSH
86052: LD_INT 1
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 1
86061: NEG
86062: PUSH
86063: LD_INT 0
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 1
86072: NEG
86073: PUSH
86074: LD_INT 1
86076: NEG
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: LD_INT 1
86084: PUSH
86085: LD_INT 1
86087: NEG
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 1
86095: NEG
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86115: LD_ADDR_VAR 0 38
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: LD_INT 0
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 0
86132: PUSH
86133: LD_INT 1
86135: NEG
86136: PUSH
86137: EMPTY
86138: LIST
86139: LIST
86140: PUSH
86141: LD_INT 1
86143: PUSH
86144: LD_INT 0
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 1
86153: PUSH
86154: LD_INT 1
86156: PUSH
86157: EMPTY
86158: LIST
86159: LIST
86160: PUSH
86161: LD_INT 0
86163: PUSH
86164: LD_INT 1
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: LD_INT 1
86173: NEG
86174: PUSH
86175: LD_INT 0
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 1
86184: NEG
86185: PUSH
86186: LD_INT 1
86188: NEG
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 2
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 2
86206: NEG
86207: PUSH
86208: LD_INT 1
86210: NEG
86211: PUSH
86212: EMPTY
86213: LIST
86214: LIST
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86227: LD_ADDR_VAR 0 39
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: EMPTY
86239: LIST
86240: LIST
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: EMPTY
86250: LIST
86251: LIST
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: LD_INT 0
86258: PUSH
86259: EMPTY
86260: LIST
86261: LIST
86262: PUSH
86263: LD_INT 1
86265: PUSH
86266: LD_INT 1
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 0
86275: PUSH
86276: LD_INT 1
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: PUSH
86283: LD_INT 1
86285: NEG
86286: PUSH
86287: LD_INT 0
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: PUSH
86294: LD_INT 1
86296: NEG
86297: PUSH
86298: LD_INT 1
86300: NEG
86301: PUSH
86302: EMPTY
86303: LIST
86304: LIST
86305: PUSH
86306: LD_INT 1
86308: NEG
86309: PUSH
86310: LD_INT 2
86312: NEG
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 1
86320: PUSH
86321: LD_INT 2
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: LIST
86332: LIST
86333: LIST
86334: LIST
86335: LIST
86336: LIST
86337: LIST
86338: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86339: LD_ADDR_VAR 0 40
86343: PUSH
86344: LD_INT 0
86346: PUSH
86347: LD_INT 0
86349: PUSH
86350: EMPTY
86351: LIST
86352: LIST
86353: PUSH
86354: LD_INT 0
86356: PUSH
86357: LD_INT 1
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: PUSH
86368: LD_INT 0
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: LD_INT 1
86380: PUSH
86381: EMPTY
86382: LIST
86383: LIST
86384: PUSH
86385: LD_INT 0
86387: PUSH
86388: LD_INT 1
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PUSH
86395: LD_INT 1
86397: NEG
86398: PUSH
86399: LD_INT 0
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 1
86408: NEG
86409: PUSH
86410: LD_INT 1
86412: NEG
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: LD_INT 1
86420: PUSH
86421: LD_INT 1
86423: NEG
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 1
86431: NEG
86432: PUSH
86433: LD_INT 1
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86451: LD_ADDR_VAR 0 41
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 0
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 1
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: PUSH
86490: LD_INT 1
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 0
86499: PUSH
86500: LD_INT 1
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 1
86509: NEG
86510: PUSH
86511: LD_INT 0
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 1
86520: NEG
86521: PUSH
86522: LD_INT 1
86524: NEG
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: NEG
86533: PUSH
86534: LD_INT 2
86536: NEG
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 1
86544: PUSH
86545: LD_INT 1
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 2
86555: PUSH
86556: LD_INT 0
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 2
86565: PUSH
86566: LD_INT 1
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 2
86575: PUSH
86576: LD_INT 2
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: LD_INT 2
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: NEG
86596: PUSH
86597: LD_INT 1
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 2
86606: NEG
86607: PUSH
86608: LD_INT 0
86610: PUSH
86611: EMPTY
86612: LIST
86613: LIST
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: LD_INT 1
86621: NEG
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: PUSH
86627: LD_INT 2
86629: NEG
86630: PUSH
86631: LD_INT 2
86633: NEG
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: LD_INT 3
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 2
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 3
86664: PUSH
86665: LD_INT 0
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 3
86674: PUSH
86675: LD_INT 1
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 3
86684: PUSH
86685: LD_INT 2
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 3
86694: PUSH
86695: LD_INT 3
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 2
86704: PUSH
86705: LD_INT 3
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 2
86714: NEG
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 3
86725: NEG
86726: PUSH
86727: LD_INT 0
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: LD_INT 3
86736: NEG
86737: PUSH
86738: LD_INT 1
86740: NEG
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 3
86748: NEG
86749: PUSH
86750: LD_INT 2
86752: NEG
86753: PUSH
86754: EMPTY
86755: LIST
86756: LIST
86757: PUSH
86758: LD_INT 3
86760: NEG
86761: PUSH
86762: LD_INT 3
86764: NEG
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86801: LD_ADDR_VAR 0 42
86805: PUSH
86806: LD_INT 0
86808: PUSH
86809: LD_INT 0
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 0
86818: PUSH
86819: LD_INT 1
86821: NEG
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: LD_INT 0
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 1
86839: PUSH
86840: LD_INT 1
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 0
86849: PUSH
86850: LD_INT 1
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: NEG
86860: PUSH
86861: LD_INT 0
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 1
86874: NEG
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: LD_INT 1
86882: NEG
86883: PUSH
86884: LD_INT 2
86886: NEG
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 0
86894: PUSH
86895: LD_INT 2
86897: NEG
86898: PUSH
86899: EMPTY
86900: LIST
86901: LIST
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: LD_INT 1
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 2
86916: PUSH
86917: LD_INT 1
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: PUSH
86924: LD_INT 2
86926: PUSH
86927: LD_INT 2
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: PUSH
86934: LD_INT 1
86936: PUSH
86937: LD_INT 2
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: PUSH
86944: LD_INT 0
86946: PUSH
86947: LD_INT 2
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 1
86956: NEG
86957: PUSH
86958: LD_INT 1
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 2
86967: NEG
86968: PUSH
86969: LD_INT 1
86971: NEG
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: NEG
86980: PUSH
86981: LD_INT 2
86983: NEG
86984: PUSH
86985: EMPTY
86986: LIST
86987: LIST
86988: PUSH
86989: LD_INT 2
86991: NEG
86992: PUSH
86993: LD_INT 3
86995: NEG
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 1
87003: NEG
87004: PUSH
87005: LD_INT 3
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: LD_INT 3
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 1
87026: PUSH
87027: LD_INT 2
87029: NEG
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 3
87037: PUSH
87038: LD_INT 2
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 3
87047: PUSH
87048: LD_INT 3
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 2
87057: PUSH
87058: LD_INT 3
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 1
87067: PUSH
87068: LD_INT 3
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: LD_INT 0
87077: PUSH
87078: LD_INT 3
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: PUSH
87085: LD_INT 1
87087: NEG
87088: PUSH
87089: LD_INT 2
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 3
87098: NEG
87099: PUSH
87100: LD_INT 2
87102: NEG
87103: PUSH
87104: EMPTY
87105: LIST
87106: LIST
87107: PUSH
87108: LD_INT 3
87110: NEG
87111: PUSH
87112: LD_INT 3
87114: NEG
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: LIST
87124: LIST
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87151: LD_ADDR_VAR 0 43
87155: PUSH
87156: LD_INT 0
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 0
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 1
87179: PUSH
87180: LD_INT 0
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PUSH
87187: LD_INT 1
87189: PUSH
87190: LD_INT 1
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 0
87199: PUSH
87200: LD_INT 1
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 1
87209: NEG
87210: PUSH
87211: LD_INT 0
87213: PUSH
87214: EMPTY
87215: LIST
87216: LIST
87217: PUSH
87218: LD_INT 1
87220: NEG
87221: PUSH
87222: LD_INT 1
87224: NEG
87225: PUSH
87226: EMPTY
87227: LIST
87228: LIST
87229: PUSH
87230: LD_INT 1
87232: NEG
87233: PUSH
87234: LD_INT 2
87236: NEG
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 0
87244: PUSH
87245: LD_INT 2
87247: NEG
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: PUSH
87253: LD_INT 1
87255: PUSH
87256: LD_INT 1
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: PUSH
87267: LD_INT 0
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 2
87276: PUSH
87277: LD_INT 1
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 1
87286: PUSH
87287: LD_INT 2
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: LD_INT 2
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 1
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 2
87317: NEG
87318: PUSH
87319: LD_INT 0
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 2
87328: NEG
87329: PUSH
87330: LD_INT 1
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 1
87340: NEG
87341: PUSH
87342: LD_INT 3
87344: NEG
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: LD_INT 3
87355: NEG
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: LD_INT 2
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 2
87374: PUSH
87375: LD_INT 1
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 3
87385: PUSH
87386: LD_INT 0
87388: PUSH
87389: EMPTY
87390: LIST
87391: LIST
87392: PUSH
87393: LD_INT 3
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 1
87405: PUSH
87406: LD_INT 3
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 0
87415: PUSH
87416: LD_INT 3
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 1
87425: NEG
87426: PUSH
87427: LD_INT 2
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: PUSH
87434: LD_INT 2
87436: NEG
87437: PUSH
87438: LD_INT 1
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 3
87447: NEG
87448: PUSH
87449: LD_INT 0
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 3
87458: NEG
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87499: LD_ADDR_VAR 0 44
87503: PUSH
87504: LD_INT 0
87506: PUSH
87507: LD_INT 0
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 0
87516: PUSH
87517: LD_INT 1
87519: NEG
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PUSH
87525: LD_INT 1
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: PUSH
87538: LD_INT 1
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 0
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 1
87568: NEG
87569: PUSH
87570: LD_INT 1
87572: NEG
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 1
87580: NEG
87581: PUSH
87582: LD_INT 2
87584: NEG
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 1
87592: PUSH
87593: LD_INT 1
87595: NEG
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: LD_INT 0
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 2
87613: PUSH
87614: LD_INT 1
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 2
87623: PUSH
87624: LD_INT 2
87626: PUSH
87627: EMPTY
87628: LIST
87629: LIST
87630: PUSH
87631: LD_INT 1
87633: PUSH
87634: LD_INT 2
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: PUSH
87641: LD_INT 1
87643: NEG
87644: PUSH
87645: LD_INT 1
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 2
87654: NEG
87655: PUSH
87656: LD_INT 0
87658: PUSH
87659: EMPTY
87660: LIST
87661: LIST
87662: PUSH
87663: LD_INT 2
87665: NEG
87666: PUSH
87667: LD_INT 1
87669: NEG
87670: PUSH
87671: EMPTY
87672: LIST
87673: LIST
87674: PUSH
87675: LD_INT 2
87677: NEG
87678: PUSH
87679: LD_INT 2
87681: NEG
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 2
87689: NEG
87690: PUSH
87691: LD_INT 3
87693: NEG
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 2
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 3
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 3
87722: PUSH
87723: LD_INT 1
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 3
87732: PUSH
87733: LD_INT 2
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 3
87742: PUSH
87743: LD_INT 3
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 2
87752: PUSH
87753: LD_INT 3
87755: PUSH
87756: EMPTY
87757: LIST
87758: LIST
87759: PUSH
87760: LD_INT 2
87762: NEG
87763: PUSH
87764: LD_INT 1
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 3
87773: NEG
87774: PUSH
87775: LD_INT 0
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: PUSH
87782: LD_INT 3
87784: NEG
87785: PUSH
87786: LD_INT 1
87788: NEG
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 3
87796: NEG
87797: PUSH
87798: LD_INT 2
87800: NEG
87801: PUSH
87802: EMPTY
87803: LIST
87804: LIST
87805: PUSH
87806: LD_INT 3
87808: NEG
87809: PUSH
87810: LD_INT 3
87812: NEG
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87849: LD_ADDR_VAR 0 45
87853: PUSH
87854: LD_INT 0
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: LD_INT 1
87869: NEG
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PUSH
87875: LD_INT 1
87877: PUSH
87878: LD_INT 0
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PUSH
87885: LD_INT 1
87887: PUSH
87888: LD_INT 1
87890: PUSH
87891: EMPTY
87892: LIST
87893: LIST
87894: PUSH
87895: LD_INT 0
87897: PUSH
87898: LD_INT 1
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 1
87907: NEG
87908: PUSH
87909: LD_INT 0
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 1
87918: NEG
87919: PUSH
87920: LD_INT 1
87922: NEG
87923: PUSH
87924: EMPTY
87925: LIST
87926: LIST
87927: PUSH
87928: LD_INT 1
87930: NEG
87931: PUSH
87932: LD_INT 2
87934: NEG
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 0
87942: PUSH
87943: LD_INT 2
87945: NEG
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 1
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 2
87964: PUSH
87965: LD_INT 1
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 2
87974: PUSH
87975: LD_INT 2
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: LD_INT 2
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 0
87994: PUSH
87995: LD_INT 2
87997: PUSH
87998: EMPTY
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 1
88004: NEG
88005: PUSH
88006: LD_INT 1
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 2
88015: NEG
88016: PUSH
88017: LD_INT 1
88019: NEG
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 2
88027: NEG
88028: PUSH
88029: LD_INT 2
88031: NEG
88032: PUSH
88033: EMPTY
88034: LIST
88035: LIST
88036: PUSH
88037: LD_INT 2
88039: NEG
88040: PUSH
88041: LD_INT 3
88043: NEG
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 1
88051: NEG
88052: PUSH
88053: LD_INT 3
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 0
88063: PUSH
88064: LD_INT 3
88066: NEG
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 1
88074: PUSH
88075: LD_INT 2
88077: NEG
88078: PUSH
88079: EMPTY
88080: LIST
88081: LIST
88082: PUSH
88083: LD_INT 3
88085: PUSH
88086: LD_INT 2
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 3
88095: PUSH
88096: LD_INT 3
88098: PUSH
88099: EMPTY
88100: LIST
88101: LIST
88102: PUSH
88103: LD_INT 2
88105: PUSH
88106: LD_INT 3
88108: PUSH
88109: EMPTY
88110: LIST
88111: LIST
88112: PUSH
88113: LD_INT 1
88115: PUSH
88116: LD_INT 3
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: LD_INT 3
88128: PUSH
88129: EMPTY
88130: LIST
88131: LIST
88132: PUSH
88133: LD_INT 1
88135: NEG
88136: PUSH
88137: LD_INT 2
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: PUSH
88144: LD_INT 3
88146: NEG
88147: PUSH
88148: LD_INT 2
88150: NEG
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: PUSH
88156: LD_INT 3
88158: NEG
88159: PUSH
88160: LD_INT 3
88162: NEG
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: EMPTY
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88199: LD_ADDR_VAR 0 46
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: LD_INT 0
88216: PUSH
88217: LD_INT 1
88219: NEG
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_INT 1
88227: PUSH
88228: LD_INT 0
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 1
88237: PUSH
88238: LD_INT 1
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 0
88247: PUSH
88248: LD_INT 1
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: LD_INT 1
88257: NEG
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 1
88268: NEG
88269: PUSH
88270: LD_INT 1
88272: NEG
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: LD_INT 2
88284: NEG
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 0
88292: PUSH
88293: LD_INT 2
88295: NEG
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 1
88303: PUSH
88304: LD_INT 1
88306: NEG
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 2
88324: PUSH
88325: LD_INT 1
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: PUSH
88335: LD_INT 2
88337: PUSH
88338: EMPTY
88339: LIST
88340: LIST
88341: PUSH
88342: LD_INT 0
88344: PUSH
88345: LD_INT 2
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 1
88354: NEG
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: LD_INT 2
88365: NEG
88366: PUSH
88367: LD_INT 0
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: LD_INT 1
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 1
88388: NEG
88389: PUSH
88390: LD_INT 3
88392: NEG
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 0
88400: PUSH
88401: LD_INT 3
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 1
88411: PUSH
88412: LD_INT 2
88414: NEG
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: LD_INT 1
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 3
88433: PUSH
88434: LD_INT 0
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 3
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: EMPTY
88448: LIST
88449: LIST
88450: PUSH
88451: LD_INT 1
88453: PUSH
88454: LD_INT 3
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: PUSH
88461: LD_INT 0
88463: PUSH
88464: LD_INT 3
88466: PUSH
88467: EMPTY
88468: LIST
88469: LIST
88470: PUSH
88471: LD_INT 1
88473: NEG
88474: PUSH
88475: LD_INT 2
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 2
88484: NEG
88485: PUSH
88486: LD_INT 1
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 3
88495: NEG
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 3
88506: NEG
88507: PUSH
88508: LD_INT 1
88510: NEG
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: LIST
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: LIST
88534: LIST
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88547: LD_ADDR_VAR 0 47
88551: PUSH
88552: LD_INT 0
88554: PUSH
88555: LD_INT 0
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 0
88564: PUSH
88565: LD_INT 1
88567: NEG
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: LD_INT 0
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: PUSH
88583: LD_INT 1
88585: PUSH
88586: LD_INT 1
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 0
88595: PUSH
88596: LD_INT 1
88598: PUSH
88599: EMPTY
88600: LIST
88601: LIST
88602: PUSH
88603: LD_INT 1
88605: NEG
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: EMPTY
88611: LIST
88612: LIST
88613: PUSH
88614: LD_INT 1
88616: NEG
88617: PUSH
88618: LD_INT 1
88620: NEG
88621: PUSH
88622: EMPTY
88623: LIST
88624: LIST
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: LD_INT 2
88632: NEG
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 0
88640: PUSH
88641: LD_INT 2
88643: NEG
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 1
88651: PUSH
88652: LD_INT 1
88654: NEG
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 2
88662: NEG
88663: PUSH
88664: LD_INT 1
88666: NEG
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 2
88674: NEG
88675: PUSH
88676: LD_INT 2
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88698: LD_ADDR_VAR 0 48
88702: PUSH
88703: LD_INT 0
88705: PUSH
88706: LD_INT 0
88708: PUSH
88709: EMPTY
88710: LIST
88711: LIST
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 1
88726: PUSH
88727: LD_INT 0
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 1
88736: PUSH
88737: LD_INT 1
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: LD_INT 1
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 1
88767: NEG
88768: PUSH
88769: LD_INT 1
88771: NEG
88772: PUSH
88773: EMPTY
88774: LIST
88775: LIST
88776: PUSH
88777: LD_INT 1
88779: NEG
88780: PUSH
88781: LD_INT 2
88783: NEG
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: PUSH
88789: LD_INT 0
88791: PUSH
88792: LD_INT 2
88794: NEG
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: LD_INT 1
88802: PUSH
88803: LD_INT 1
88805: NEG
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 2
88813: PUSH
88814: LD_INT 0
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 2
88823: PUSH
88824: LD_INT 1
88826: PUSH
88827: EMPTY
88828: LIST
88829: LIST
88830: PUSH
88831: EMPTY
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88845: LD_ADDR_VAR 0 49
88849: PUSH
88850: LD_INT 0
88852: PUSH
88853: LD_INT 0
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 1
88865: NEG
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 1
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: PUSH
88884: LD_INT 1
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 0
88893: PUSH
88894: LD_INT 1
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: PUSH
88912: LD_INT 1
88914: NEG
88915: PUSH
88916: LD_INT 1
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: LD_INT 1
88929: NEG
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 2
88937: PUSH
88938: LD_INT 0
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PUSH
88945: LD_INT 2
88947: PUSH
88948: LD_INT 1
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: PUSH
88955: LD_INT 2
88957: PUSH
88958: LD_INT 2
88960: PUSH
88961: EMPTY
88962: LIST
88963: LIST
88964: PUSH
88965: LD_INT 1
88967: PUSH
88968: LD_INT 2
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88989: LD_ADDR_VAR 0 50
88993: PUSH
88994: LD_INT 0
88996: PUSH
88997: LD_INT 0
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: LD_INT 1
89009: NEG
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: PUSH
89015: LD_INT 1
89017: PUSH
89018: LD_INT 0
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: PUSH
89025: LD_INT 1
89027: PUSH
89028: LD_INT 1
89030: PUSH
89031: EMPTY
89032: LIST
89033: LIST
89034: PUSH
89035: LD_INT 0
89037: PUSH
89038: LD_INT 1
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 1
89047: NEG
89048: PUSH
89049: LD_INT 0
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 1
89058: NEG
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 2
89070: PUSH
89071: LD_INT 1
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 2
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 1
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 0
89100: PUSH
89101: LD_INT 2
89103: PUSH
89104: EMPTY
89105: LIST
89106: LIST
89107: PUSH
89108: LD_INT 1
89110: NEG
89111: PUSH
89112: LD_INT 1
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89133: LD_ADDR_VAR 0 51
89137: PUSH
89138: LD_INT 0
89140: PUSH
89141: LD_INT 0
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: LD_INT 1
89153: NEG
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: LD_INT 0
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 0
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 1
89191: NEG
89192: PUSH
89193: LD_INT 0
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: LD_INT 1
89206: NEG
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 1
89214: PUSH
89215: LD_INT 2
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 0
89224: PUSH
89225: LD_INT 2
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: NEG
89235: PUSH
89236: LD_INT 1
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 2
89245: NEG
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: PUSH
89254: LD_INT 2
89256: NEG
89257: PUSH
89258: LD_INT 1
89260: NEG
89261: PUSH
89262: EMPTY
89263: LIST
89264: LIST
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: LIST
89270: LIST
89271: LIST
89272: LIST
89273: LIST
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89280: LD_ADDR_VAR 0 52
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: LD_INT 0
89290: PUSH
89291: EMPTY
89292: LIST
89293: LIST
89294: PUSH
89295: LD_INT 0
89297: PUSH
89298: LD_INT 1
89300: NEG
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: LD_INT 0
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: PUSH
89316: LD_INT 1
89318: PUSH
89319: LD_INT 1
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: PUSH
89326: LD_INT 0
89328: PUSH
89329: LD_INT 1
89331: PUSH
89332: EMPTY
89333: LIST
89334: LIST
89335: PUSH
89336: LD_INT 1
89338: NEG
89339: PUSH
89340: LD_INT 0
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 1
89349: NEG
89350: PUSH
89351: LD_INT 1
89353: NEG
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 1
89361: NEG
89362: PUSH
89363: LD_INT 2
89365: NEG
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: NEG
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: LD_INT 0
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 2
89395: NEG
89396: PUSH
89397: LD_INT 1
89399: NEG
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 2
89407: NEG
89408: PUSH
89409: LD_INT 2
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89431: LD_ADDR_VAR 0 53
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: LD_INT 1
89451: NEG
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 1
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: LD_INT 1
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: LD_INT 0
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: LD_INT 1
89504: NEG
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: NEG
89513: PUSH
89514: LD_INT 2
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 0
89524: PUSH
89525: LD_INT 2
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 1
89535: PUSH
89536: LD_INT 1
89538: NEG
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: LD_INT 0
89549: PUSH
89550: EMPTY
89551: LIST
89552: LIST
89553: PUSH
89554: LD_INT 2
89556: PUSH
89557: LD_INT 1
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 2
89566: PUSH
89567: LD_INT 2
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 1
89576: PUSH
89577: LD_INT 2
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: LD_INT 2
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 1
89596: NEG
89597: PUSH
89598: LD_INT 1
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 2
89607: NEG
89608: PUSH
89609: LD_INT 0
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 2
89618: NEG
89619: PUSH
89620: LD_INT 1
89622: NEG
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 2
89630: NEG
89631: PUSH
89632: LD_INT 2
89634: NEG
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: EMPTY
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89661: LD_ADDR_VAR 0 54
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: LD_INT 0
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: LD_INT 1
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 1
89689: PUSH
89690: LD_INT 0
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 1
89699: PUSH
89700: LD_INT 1
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: PUSH
89707: LD_INT 0
89709: PUSH
89710: LD_INT 1
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 1
89719: NEG
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 1
89730: NEG
89731: PUSH
89732: LD_INT 1
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 1
89742: NEG
89743: PUSH
89744: LD_INT 2
89746: NEG
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_INT 2
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 1
89765: PUSH
89766: LD_INT 1
89768: NEG
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: LD_INT 2
89776: PUSH
89777: LD_INT 0
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: PUSH
89784: LD_INT 2
89786: PUSH
89787: LD_INT 1
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PUSH
89794: LD_INT 2
89796: PUSH
89797: LD_INT 2
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 1
89806: PUSH
89807: LD_INT 2
89809: PUSH
89810: EMPTY
89811: LIST
89812: LIST
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: LD_INT 2
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 1
89826: NEG
89827: PUSH
89828: LD_INT 1
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 2
89837: NEG
89838: PUSH
89839: LD_INT 0
89841: PUSH
89842: EMPTY
89843: LIST
89844: LIST
89845: PUSH
89846: LD_INT 2
89848: NEG
89849: PUSH
89850: LD_INT 1
89852: NEG
89853: PUSH
89854: EMPTY
89855: LIST
89856: LIST
89857: PUSH
89858: LD_INT 2
89860: NEG
89861: PUSH
89862: LD_INT 2
89864: NEG
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89891: LD_ADDR_VAR 0 55
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: LD_INT 0
89901: PUSH
89902: EMPTY
89903: LIST
89904: LIST
89905: PUSH
89906: LD_INT 0
89908: PUSH
89909: LD_INT 1
89911: NEG
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: LD_INT 1
89919: PUSH
89920: LD_INT 0
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 1
89929: PUSH
89930: LD_INT 1
89932: PUSH
89933: EMPTY
89934: LIST
89935: LIST
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: LD_INT 1
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: LD_INT 0
89953: PUSH
89954: EMPTY
89955: LIST
89956: LIST
89957: PUSH
89958: LD_INT 1
89960: NEG
89961: PUSH
89962: LD_INT 1
89964: NEG
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 1
89972: NEG
89973: PUSH
89974: LD_INT 2
89976: NEG
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: LD_INT 2
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 1
89995: PUSH
89996: LD_INT 1
89998: NEG
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 2
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: LD_INT 2
90016: PUSH
90017: LD_INT 1
90019: PUSH
90020: EMPTY
90021: LIST
90022: LIST
90023: PUSH
90024: LD_INT 2
90026: PUSH
90027: LD_INT 2
90029: PUSH
90030: EMPTY
90031: LIST
90032: LIST
90033: PUSH
90034: LD_INT 1
90036: PUSH
90037: LD_INT 2
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 0
90046: PUSH
90047: LD_INT 2
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 1
90056: NEG
90057: PUSH
90058: LD_INT 1
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: PUSH
90065: LD_INT 2
90067: NEG
90068: PUSH
90069: LD_INT 0
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 2
90078: NEG
90079: PUSH
90080: LD_INT 1
90082: NEG
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 2
90090: NEG
90091: PUSH
90092: LD_INT 2
90094: NEG
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90121: LD_ADDR_VAR 0 56
90125: PUSH
90126: LD_INT 0
90128: PUSH
90129: LD_INT 0
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PUSH
90136: LD_INT 0
90138: PUSH
90139: LD_INT 1
90141: NEG
90142: PUSH
90143: EMPTY
90144: LIST
90145: LIST
90146: PUSH
90147: LD_INT 1
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 1
90159: PUSH
90160: LD_INT 1
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 0
90169: PUSH
90170: LD_INT 1
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 1
90179: NEG
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: EMPTY
90185: LIST
90186: LIST
90187: PUSH
90188: LD_INT 1
90190: NEG
90191: PUSH
90192: LD_INT 1
90194: NEG
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 1
90202: NEG
90203: PUSH
90204: LD_INT 2
90206: NEG
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 2
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: PUSH
90226: LD_INT 1
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 2
90236: PUSH
90237: LD_INT 0
90239: PUSH
90240: EMPTY
90241: LIST
90242: LIST
90243: PUSH
90244: LD_INT 2
90246: PUSH
90247: LD_INT 1
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 2
90256: PUSH
90257: LD_INT 2
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PUSH
90264: LD_INT 1
90266: PUSH
90267: LD_INT 2
90269: PUSH
90270: EMPTY
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 0
90276: PUSH
90277: LD_INT 2
90279: PUSH
90280: EMPTY
90281: LIST
90282: LIST
90283: PUSH
90284: LD_INT 1
90286: NEG
90287: PUSH
90288: LD_INT 1
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 2
90297: NEG
90298: PUSH
90299: LD_INT 0
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 2
90308: NEG
90309: PUSH
90310: LD_INT 1
90312: NEG
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 2
90320: NEG
90321: PUSH
90322: LD_INT 2
90324: NEG
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: PUSH
90330: EMPTY
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: LIST
90350: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90351: LD_ADDR_VAR 0 57
90355: PUSH
90356: LD_INT 0
90358: PUSH
90359: LD_INT 0
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 0
90368: PUSH
90369: LD_INT 1
90371: NEG
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 1
90379: PUSH
90380: LD_INT 0
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PUSH
90387: LD_INT 1
90389: PUSH
90390: LD_INT 1
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 0
90399: PUSH
90400: LD_INT 1
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: LD_INT 1
90420: NEG
90421: PUSH
90422: LD_INT 1
90424: NEG
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 1
90432: NEG
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: LD_INT 2
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 1
90455: PUSH
90456: LD_INT 1
90458: NEG
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 2
90466: PUSH
90467: LD_INT 0
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 2
90476: PUSH
90477: LD_INT 1
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: LD_INT 2
90486: PUSH
90487: LD_INT 2
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: PUSH
90494: LD_INT 1
90496: PUSH
90497: LD_INT 2
90499: PUSH
90500: EMPTY
90501: LIST
90502: LIST
90503: PUSH
90504: LD_INT 0
90506: PUSH
90507: LD_INT 2
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 1
90516: NEG
90517: PUSH
90518: LD_INT 1
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 2
90527: NEG
90528: PUSH
90529: LD_INT 0
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 2
90538: NEG
90539: PUSH
90540: LD_INT 1
90542: NEG
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 2
90550: NEG
90551: PUSH
90552: LD_INT 2
90554: NEG
90555: PUSH
90556: EMPTY
90557: LIST
90558: LIST
90559: PUSH
90560: EMPTY
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90581: LD_ADDR_VAR 0 58
90585: PUSH
90586: LD_INT 0
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 0
90598: PUSH
90599: LD_INT 1
90601: NEG
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: PUSH
90607: LD_INT 1
90609: PUSH
90610: LD_INT 0
90612: PUSH
90613: EMPTY
90614: LIST
90615: LIST
90616: PUSH
90617: LD_INT 1
90619: PUSH
90620: LD_INT 1
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 0
90629: PUSH
90630: LD_INT 1
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 1
90639: NEG
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 1
90650: NEG
90651: PUSH
90652: LD_INT 1
90654: NEG
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 1
90662: NEG
90663: PUSH
90664: LD_INT 2
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: LD_INT 2
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 1
90685: PUSH
90686: LD_INT 1
90688: NEG
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 2
90696: PUSH
90697: LD_INT 0
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 2
90706: PUSH
90707: LD_INT 1
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 2
90716: PUSH
90717: LD_INT 2
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 1
90726: PUSH
90727: LD_INT 2
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 0
90736: PUSH
90737: LD_INT 2
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 1
90746: NEG
90747: PUSH
90748: LD_INT 1
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 2
90757: NEG
90758: PUSH
90759: LD_INT 0
90761: PUSH
90762: EMPTY
90763: LIST
90764: LIST
90765: PUSH
90766: LD_INT 2
90768: NEG
90769: PUSH
90770: LD_INT 1
90772: NEG
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: LD_INT 2
90780: NEG
90781: PUSH
90782: LD_INT 2
90784: NEG
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90811: LD_ADDR_VAR 0 59
90815: PUSH
90816: LD_INT 0
90818: PUSH
90819: LD_INT 0
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 0
90828: PUSH
90829: LD_INT 1
90831: NEG
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 1
90839: PUSH
90840: LD_INT 0
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 1
90849: PUSH
90850: LD_INT 1
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 0
90859: PUSH
90860: LD_INT 1
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 1
90869: NEG
90870: PUSH
90871: LD_INT 0
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 1
90880: NEG
90881: PUSH
90882: LD_INT 1
90884: NEG
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90899: LD_ADDR_VAR 0 60
90903: PUSH
90904: LD_INT 0
90906: PUSH
90907: LD_INT 0
90909: PUSH
90910: EMPTY
90911: LIST
90912: LIST
90913: PUSH
90914: LD_INT 0
90916: PUSH
90917: LD_INT 1
90919: NEG
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 1
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: PUSH
90938: LD_INT 1
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: LD_INT 1
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 1
90957: NEG
90958: PUSH
90959: LD_INT 0
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: NEG
90969: PUSH
90970: LD_INT 1
90972: NEG
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: EMPTY
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90987: LD_ADDR_VAR 0 61
90991: PUSH
90992: LD_INT 0
90994: PUSH
90995: LD_INT 0
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 0
91004: PUSH
91005: LD_INT 1
91007: NEG
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: PUSH
91013: LD_INT 1
91015: PUSH
91016: LD_INT 0
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 1
91025: PUSH
91026: LD_INT 1
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: PUSH
91043: LD_INT 1
91045: NEG
91046: PUSH
91047: LD_INT 0
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 1
91056: NEG
91057: PUSH
91058: LD_INT 1
91060: NEG
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91075: LD_ADDR_VAR 0 62
91079: PUSH
91080: LD_INT 0
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: LD_INT 1
91095: NEG
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: PUSH
91104: LD_INT 0
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PUSH
91111: LD_INT 1
91113: PUSH
91114: LD_INT 1
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 1
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 1
91133: NEG
91134: PUSH
91135: LD_INT 0
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: NEG
91145: PUSH
91146: LD_INT 1
91148: NEG
91149: PUSH
91150: EMPTY
91151: LIST
91152: LIST
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: LIST
91162: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91163: LD_ADDR_VAR 0 63
91167: PUSH
91168: LD_INT 0
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: EMPTY
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 0
91180: PUSH
91181: LD_INT 1
91183: NEG
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 1
91191: PUSH
91192: LD_INT 0
91194: PUSH
91195: EMPTY
91196: LIST
91197: LIST
91198: PUSH
91199: LD_INT 1
91201: PUSH
91202: LD_INT 1
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 0
91211: PUSH
91212: LD_INT 1
91214: PUSH
91215: EMPTY
91216: LIST
91217: LIST
91218: PUSH
91219: LD_INT 1
91221: NEG
91222: PUSH
91223: LD_INT 0
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: NEG
91233: PUSH
91234: LD_INT 1
91236: NEG
91237: PUSH
91238: EMPTY
91239: LIST
91240: LIST
91241: PUSH
91242: EMPTY
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91251: LD_ADDR_VAR 0 64
91255: PUSH
91256: LD_INT 0
91258: PUSH
91259: LD_INT 0
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: LD_INT 0
91268: PUSH
91269: LD_INT 1
91271: NEG
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 1
91279: PUSH
91280: LD_INT 0
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: LD_INT 1
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 0
91299: PUSH
91300: LD_INT 1
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 1
91309: NEG
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: NEG
91321: PUSH
91322: LD_INT 1
91324: NEG
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: EMPTY
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: ST_TO_ADDR
// end ; 1 :
91339: GO 97236
91341: LD_INT 1
91343: DOUBLE
91344: EQUAL
91345: IFTRUE 91349
91347: GO 93972
91349: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91350: LD_ADDR_VAR 0 11
91354: PUSH
91355: LD_INT 1
91357: NEG
91358: PUSH
91359: LD_INT 3
91361: NEG
91362: PUSH
91363: EMPTY
91364: LIST
91365: LIST
91366: PUSH
91367: LD_INT 0
91369: PUSH
91370: LD_INT 3
91372: NEG
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 1
91380: PUSH
91381: LD_INT 2
91383: NEG
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: LIST
91393: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91394: LD_ADDR_VAR 0 12
91398: PUSH
91399: LD_INT 2
91401: PUSH
91402: LD_INT 1
91404: NEG
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PUSH
91410: LD_INT 3
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 3
91422: PUSH
91423: LD_INT 1
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: LIST
91434: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91435: LD_ADDR_VAR 0 13
91439: PUSH
91440: LD_INT 3
91442: PUSH
91443: LD_INT 2
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 3
91452: PUSH
91453: LD_INT 3
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 2
91462: PUSH
91463: LD_INT 3
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: LIST
91474: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91475: LD_ADDR_VAR 0 14
91479: PUSH
91480: LD_INT 1
91482: PUSH
91483: LD_INT 3
91485: PUSH
91486: EMPTY
91487: LIST
91488: LIST
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: LD_INT 3
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PUSH
91500: LD_INT 1
91502: NEG
91503: PUSH
91504: LD_INT 2
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: LIST
91515: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91516: LD_ADDR_VAR 0 15
91520: PUSH
91521: LD_INT 2
91523: NEG
91524: PUSH
91525: LD_INT 1
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: PUSH
91532: LD_INT 3
91534: NEG
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 3
91545: NEG
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: LIST
91559: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91560: LD_ADDR_VAR 0 16
91564: PUSH
91565: LD_INT 2
91567: NEG
91568: PUSH
91569: LD_INT 3
91571: NEG
91572: PUSH
91573: EMPTY
91574: LIST
91575: LIST
91576: PUSH
91577: LD_INT 3
91579: NEG
91580: PUSH
91581: LD_INT 2
91583: NEG
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: PUSH
91589: LD_INT 3
91591: NEG
91592: PUSH
91593: LD_INT 3
91595: NEG
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: LIST
91605: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91606: LD_ADDR_VAR 0 17
91610: PUSH
91611: LD_INT 1
91613: NEG
91614: PUSH
91615: LD_INT 3
91617: NEG
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 0
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 1
91636: PUSH
91637: LD_INT 2
91639: NEG
91640: PUSH
91641: EMPTY
91642: LIST
91643: LIST
91644: PUSH
91645: EMPTY
91646: LIST
91647: LIST
91648: LIST
91649: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91650: LD_ADDR_VAR 0 18
91654: PUSH
91655: LD_INT 2
91657: PUSH
91658: LD_INT 1
91660: NEG
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 3
91668: PUSH
91669: LD_INT 0
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 3
91678: PUSH
91679: LD_INT 1
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: LIST
91690: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91691: LD_ADDR_VAR 0 19
91695: PUSH
91696: LD_INT 3
91698: PUSH
91699: LD_INT 2
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: LD_INT 3
91708: PUSH
91709: LD_INT 3
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: LD_INT 2
91718: PUSH
91719: LD_INT 3
91721: PUSH
91722: EMPTY
91723: LIST
91724: LIST
91725: PUSH
91726: EMPTY
91727: LIST
91728: LIST
91729: LIST
91730: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91731: LD_ADDR_VAR 0 20
91735: PUSH
91736: LD_INT 1
91738: PUSH
91739: LD_INT 3
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 0
91748: PUSH
91749: LD_INT 3
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: LD_INT 1
91758: NEG
91759: PUSH
91760: LD_INT 2
91762: PUSH
91763: EMPTY
91764: LIST
91765: LIST
91766: PUSH
91767: EMPTY
91768: LIST
91769: LIST
91770: LIST
91771: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91772: LD_ADDR_VAR 0 21
91776: PUSH
91777: LD_INT 2
91779: NEG
91780: PUSH
91781: LD_INT 1
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 3
91790: NEG
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: LD_INT 3
91801: NEG
91802: PUSH
91803: LD_INT 1
91805: NEG
91806: PUSH
91807: EMPTY
91808: LIST
91809: LIST
91810: PUSH
91811: EMPTY
91812: LIST
91813: LIST
91814: LIST
91815: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91816: LD_ADDR_VAR 0 22
91820: PUSH
91821: LD_INT 2
91823: NEG
91824: PUSH
91825: LD_INT 3
91827: NEG
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 3
91835: NEG
91836: PUSH
91837: LD_INT 2
91839: NEG
91840: PUSH
91841: EMPTY
91842: LIST
91843: LIST
91844: PUSH
91845: LD_INT 3
91847: NEG
91848: PUSH
91849: LD_INT 3
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: LIST
91861: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91862: LD_ADDR_VAR 0 23
91866: PUSH
91867: LD_INT 0
91869: PUSH
91870: LD_INT 3
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: LD_INT 1
91880: NEG
91881: PUSH
91882: LD_INT 4
91884: NEG
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: LD_INT 3
91895: NEG
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: EMPTY
91902: LIST
91903: LIST
91904: LIST
91905: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91906: LD_ADDR_VAR 0 24
91910: PUSH
91911: LD_INT 3
91913: PUSH
91914: LD_INT 0
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 3
91923: PUSH
91924: LD_INT 1
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 4
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91947: LD_ADDR_VAR 0 25
91951: PUSH
91952: LD_INT 3
91954: PUSH
91955: LD_INT 3
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 4
91964: PUSH
91965: LD_INT 3
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 3
91974: PUSH
91975: LD_INT 4
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: LIST
91986: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91987: LD_ADDR_VAR 0 26
91991: PUSH
91992: LD_INT 0
91994: PUSH
91995: LD_INT 3
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 1
92004: PUSH
92005: LD_INT 4
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 1
92014: NEG
92015: PUSH
92016: LD_INT 3
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: LIST
92027: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92028: LD_ADDR_VAR 0 27
92032: PUSH
92033: LD_INT 3
92035: NEG
92036: PUSH
92037: LD_INT 0
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 3
92046: NEG
92047: PUSH
92048: LD_INT 1
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 4
92057: NEG
92058: PUSH
92059: LD_INT 1
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: EMPTY
92068: LIST
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92072: LD_ADDR_VAR 0 28
92076: PUSH
92077: LD_INT 3
92079: NEG
92080: PUSH
92081: LD_INT 3
92083: NEG
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: LD_INT 3
92091: NEG
92092: PUSH
92093: LD_INT 4
92095: NEG
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 4
92103: NEG
92104: PUSH
92105: LD_INT 3
92107: NEG
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: LIST
92117: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92118: LD_ADDR_VAR 0 29
92122: PUSH
92123: LD_INT 1
92125: NEG
92126: PUSH
92127: LD_INT 3
92129: NEG
92130: PUSH
92131: EMPTY
92132: LIST
92133: LIST
92134: PUSH
92135: LD_INT 0
92137: PUSH
92138: LD_INT 3
92140: NEG
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: PUSH
92146: LD_INT 1
92148: PUSH
92149: LD_INT 2
92151: NEG
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 1
92159: NEG
92160: PUSH
92161: LD_INT 4
92163: NEG
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 0
92171: PUSH
92172: LD_INT 4
92174: NEG
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 1
92182: PUSH
92183: LD_INT 3
92185: NEG
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 1
92193: NEG
92194: PUSH
92195: LD_INT 5
92197: NEG
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 0
92205: PUSH
92206: LD_INT 5
92208: NEG
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 1
92216: PUSH
92217: LD_INT 4
92219: NEG
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 1
92227: NEG
92228: PUSH
92229: LD_INT 6
92231: NEG
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 0
92239: PUSH
92240: LD_INT 6
92242: NEG
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: PUSH
92248: LD_INT 1
92250: PUSH
92251: LD_INT 5
92253: NEG
92254: PUSH
92255: EMPTY
92256: LIST
92257: LIST
92258: PUSH
92259: EMPTY
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92273: LD_ADDR_VAR 0 30
92277: PUSH
92278: LD_INT 2
92280: PUSH
92281: LD_INT 1
92283: NEG
92284: PUSH
92285: EMPTY
92286: LIST
92287: LIST
92288: PUSH
92289: LD_INT 3
92291: PUSH
92292: LD_INT 0
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 3
92301: PUSH
92302: LD_INT 1
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: LD_INT 3
92311: PUSH
92312: LD_INT 1
92314: NEG
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: PUSH
92320: LD_INT 4
92322: PUSH
92323: LD_INT 0
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 4
92332: PUSH
92333: LD_INT 1
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 4
92342: PUSH
92343: LD_INT 1
92345: NEG
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: PUSH
92351: LD_INT 5
92353: PUSH
92354: LD_INT 0
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: PUSH
92361: LD_INT 5
92363: PUSH
92364: LD_INT 1
92366: PUSH
92367: EMPTY
92368: LIST
92369: LIST
92370: PUSH
92371: LD_INT 5
92373: PUSH
92374: LD_INT 1
92376: NEG
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: LD_INT 6
92384: PUSH
92385: LD_INT 0
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 6
92394: PUSH
92395: LD_INT 1
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: LIST
92406: LIST
92407: LIST
92408: LIST
92409: LIST
92410: LIST
92411: LIST
92412: LIST
92413: LIST
92414: LIST
92415: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92416: LD_ADDR_VAR 0 31
92420: PUSH
92421: LD_INT 3
92423: PUSH
92424: LD_INT 2
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 3
92433: PUSH
92434: LD_INT 3
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 2
92443: PUSH
92444: LD_INT 3
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 4
92453: PUSH
92454: LD_INT 3
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: LD_INT 4
92463: PUSH
92464: LD_INT 4
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PUSH
92471: LD_INT 3
92473: PUSH
92474: LD_INT 4
92476: PUSH
92477: EMPTY
92478: LIST
92479: LIST
92480: PUSH
92481: LD_INT 5
92483: PUSH
92484: LD_INT 4
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: PUSH
92491: LD_INT 5
92493: PUSH
92494: LD_INT 5
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 4
92503: PUSH
92504: LD_INT 5
92506: PUSH
92507: EMPTY
92508: LIST
92509: LIST
92510: PUSH
92511: LD_INT 6
92513: PUSH
92514: LD_INT 5
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 6
92523: PUSH
92524: LD_INT 6
92526: PUSH
92527: EMPTY
92528: LIST
92529: LIST
92530: PUSH
92531: LD_INT 5
92533: PUSH
92534: LD_INT 6
92536: PUSH
92537: EMPTY
92538: LIST
92539: LIST
92540: PUSH
92541: EMPTY
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92555: LD_ADDR_VAR 0 32
92559: PUSH
92560: LD_INT 1
92562: PUSH
92563: LD_INT 3
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 0
92572: PUSH
92573: LD_INT 3
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: LD_INT 1
92582: NEG
92583: PUSH
92584: LD_INT 2
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 1
92593: PUSH
92594: LD_INT 4
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 0
92603: PUSH
92604: LD_INT 4
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 1
92613: NEG
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 1
92624: PUSH
92625: LD_INT 5
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 0
92634: PUSH
92635: LD_INT 5
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 1
92644: NEG
92645: PUSH
92646: LD_INT 4
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: LD_INT 1
92655: PUSH
92656: LD_INT 6
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 0
92665: PUSH
92666: LD_INT 6
92668: PUSH
92669: EMPTY
92670: LIST
92671: LIST
92672: PUSH
92673: LD_INT 1
92675: NEG
92676: PUSH
92677: LD_INT 5
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92698: LD_ADDR_VAR 0 33
92702: PUSH
92703: LD_INT 2
92705: NEG
92706: PUSH
92707: LD_INT 1
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: PUSH
92714: LD_INT 3
92716: NEG
92717: PUSH
92718: LD_INT 0
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 3
92727: NEG
92728: PUSH
92729: LD_INT 1
92731: NEG
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: PUSH
92737: LD_INT 3
92739: NEG
92740: PUSH
92741: LD_INT 1
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 4
92750: NEG
92751: PUSH
92752: LD_INT 0
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 4
92761: NEG
92762: PUSH
92763: LD_INT 1
92765: NEG
92766: PUSH
92767: EMPTY
92768: LIST
92769: LIST
92770: PUSH
92771: LD_INT 4
92773: NEG
92774: PUSH
92775: LD_INT 1
92777: PUSH
92778: EMPTY
92779: LIST
92780: LIST
92781: PUSH
92782: LD_INT 5
92784: NEG
92785: PUSH
92786: LD_INT 0
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 5
92795: NEG
92796: PUSH
92797: LD_INT 1
92799: NEG
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 5
92807: NEG
92808: PUSH
92809: LD_INT 1
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 6
92818: NEG
92819: PUSH
92820: LD_INT 0
92822: PUSH
92823: EMPTY
92824: LIST
92825: LIST
92826: PUSH
92827: LD_INT 6
92829: NEG
92830: PUSH
92831: LD_INT 1
92833: NEG
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92853: LD_ADDR_VAR 0 34
92857: PUSH
92858: LD_INT 2
92860: NEG
92861: PUSH
92862: LD_INT 3
92864: NEG
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PUSH
92870: LD_INT 3
92872: NEG
92873: PUSH
92874: LD_INT 2
92876: NEG
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PUSH
92882: LD_INT 3
92884: NEG
92885: PUSH
92886: LD_INT 3
92888: NEG
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 3
92896: NEG
92897: PUSH
92898: LD_INT 4
92900: NEG
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: LD_INT 4
92908: NEG
92909: PUSH
92910: LD_INT 3
92912: NEG
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 4
92920: NEG
92921: PUSH
92922: LD_INT 4
92924: NEG
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 4
92932: NEG
92933: PUSH
92934: LD_INT 5
92936: NEG
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 5
92944: NEG
92945: PUSH
92946: LD_INT 4
92948: NEG
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: LD_INT 5
92956: NEG
92957: PUSH
92958: LD_INT 5
92960: NEG
92961: PUSH
92962: EMPTY
92963: LIST
92964: LIST
92965: PUSH
92966: LD_INT 5
92968: NEG
92969: PUSH
92970: LD_INT 6
92972: NEG
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 6
92980: NEG
92981: PUSH
92982: LD_INT 5
92984: NEG
92985: PUSH
92986: EMPTY
92987: LIST
92988: LIST
92989: PUSH
92990: LD_INT 6
92992: NEG
92993: PUSH
92994: LD_INT 6
92996: NEG
92997: PUSH
92998: EMPTY
92999: LIST
93000: LIST
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93016: LD_ADDR_VAR 0 41
93020: PUSH
93021: LD_INT 0
93023: PUSH
93024: LD_INT 2
93026: NEG
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 1
93034: NEG
93035: PUSH
93036: LD_INT 3
93038: NEG
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 1
93046: PUSH
93047: LD_INT 2
93049: NEG
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: LIST
93059: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93060: LD_ADDR_VAR 0 42
93064: PUSH
93065: LD_INT 2
93067: PUSH
93068: LD_INT 0
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 2
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 3
93088: PUSH
93089: LD_INT 1
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: LIST
93100: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93101: LD_ADDR_VAR 0 43
93105: PUSH
93106: LD_INT 2
93108: PUSH
93109: LD_INT 2
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: LD_INT 3
93118: PUSH
93119: LD_INT 2
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: LD_INT 2
93128: PUSH
93129: LD_INT 3
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: LIST
93140: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93141: LD_ADDR_VAR 0 44
93145: PUSH
93146: LD_INT 0
93148: PUSH
93149: LD_INT 2
93151: PUSH
93152: EMPTY
93153: LIST
93154: LIST
93155: PUSH
93156: LD_INT 1
93158: PUSH
93159: LD_INT 3
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 1
93168: NEG
93169: PUSH
93170: LD_INT 2
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: LIST
93181: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93182: LD_ADDR_VAR 0 45
93186: PUSH
93187: LD_INT 2
93189: NEG
93190: PUSH
93191: LD_INT 0
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: LD_INT 2
93200: NEG
93201: PUSH
93202: LD_INT 1
93204: PUSH
93205: EMPTY
93206: LIST
93207: LIST
93208: PUSH
93209: LD_INT 3
93211: NEG
93212: PUSH
93213: LD_INT 1
93215: NEG
93216: PUSH
93217: EMPTY
93218: LIST
93219: LIST
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: LIST
93225: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93226: LD_ADDR_VAR 0 46
93230: PUSH
93231: LD_INT 2
93233: NEG
93234: PUSH
93235: LD_INT 2
93237: NEG
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: LD_INT 3
93249: NEG
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 3
93257: NEG
93258: PUSH
93259: LD_INT 2
93261: NEG
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: PUSH
93267: EMPTY
93268: LIST
93269: LIST
93270: LIST
93271: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93272: LD_ADDR_VAR 0 47
93276: PUSH
93277: LD_INT 2
93279: NEG
93280: PUSH
93281: LD_INT 3
93283: NEG
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: LD_INT 1
93291: NEG
93292: PUSH
93293: LD_INT 3
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93305: LD_ADDR_VAR 0 48
93309: PUSH
93310: LD_INT 1
93312: PUSH
93313: LD_INT 2
93315: NEG
93316: PUSH
93317: EMPTY
93318: LIST
93319: LIST
93320: PUSH
93321: LD_INT 2
93323: PUSH
93324: LD_INT 1
93326: NEG
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93336: LD_ADDR_VAR 0 49
93340: PUSH
93341: LD_INT 3
93343: PUSH
93344: LD_INT 1
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: PUSH
93351: LD_INT 3
93353: PUSH
93354: LD_INT 2
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: EMPTY
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93365: LD_ADDR_VAR 0 50
93369: PUSH
93370: LD_INT 2
93372: PUSH
93373: LD_INT 3
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 1
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93394: LD_ADDR_VAR 0 51
93398: PUSH
93399: LD_INT 1
93401: NEG
93402: PUSH
93403: LD_INT 2
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 2
93412: NEG
93413: PUSH
93414: LD_INT 1
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93425: LD_ADDR_VAR 0 52
93429: PUSH
93430: LD_INT 3
93432: NEG
93433: PUSH
93434: LD_INT 1
93436: NEG
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 3
93444: NEG
93445: PUSH
93446: LD_INT 2
93448: NEG
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93458: LD_ADDR_VAR 0 53
93462: PUSH
93463: LD_INT 1
93465: NEG
93466: PUSH
93467: LD_INT 3
93469: NEG
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 0
93477: PUSH
93478: LD_INT 3
93480: NEG
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 1
93488: PUSH
93489: LD_INT 2
93491: NEG
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: LIST
93501: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93502: LD_ADDR_VAR 0 54
93506: PUSH
93507: LD_INT 2
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 3
93520: PUSH
93521: LD_INT 0
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: PUSH
93528: LD_INT 3
93530: PUSH
93531: LD_INT 1
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: LIST
93542: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93543: LD_ADDR_VAR 0 55
93547: PUSH
93548: LD_INT 3
93550: PUSH
93551: LD_INT 2
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: PUSH
93558: LD_INT 3
93560: PUSH
93561: LD_INT 3
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_INT 2
93570: PUSH
93571: LD_INT 3
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: LIST
93582: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93583: LD_ADDR_VAR 0 56
93587: PUSH
93588: LD_INT 1
93590: PUSH
93591: LD_INT 3
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PUSH
93598: LD_INT 0
93600: PUSH
93601: LD_INT 3
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: NEG
93611: PUSH
93612: LD_INT 2
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: LIST
93623: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93624: LD_ADDR_VAR 0 57
93628: PUSH
93629: LD_INT 2
93631: NEG
93632: PUSH
93633: LD_INT 1
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: LD_INT 3
93642: NEG
93643: PUSH
93644: LD_INT 0
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: LD_INT 1
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: EMPTY
93664: LIST
93665: LIST
93666: LIST
93667: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93668: LD_ADDR_VAR 0 58
93672: PUSH
93673: LD_INT 2
93675: NEG
93676: PUSH
93677: LD_INT 3
93679: NEG
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 3
93687: NEG
93688: PUSH
93689: LD_INT 2
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 3
93699: NEG
93700: PUSH
93701: LD_INT 3
93703: NEG
93704: PUSH
93705: EMPTY
93706: LIST
93707: LIST
93708: PUSH
93709: EMPTY
93710: LIST
93711: LIST
93712: LIST
93713: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93714: LD_ADDR_VAR 0 59
93718: PUSH
93719: LD_INT 1
93721: NEG
93722: PUSH
93723: LD_INT 2
93725: NEG
93726: PUSH
93727: EMPTY
93728: LIST
93729: LIST
93730: PUSH
93731: LD_INT 0
93733: PUSH
93734: LD_INT 2
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 1
93744: PUSH
93745: LD_INT 1
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: LIST
93757: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93758: LD_ADDR_VAR 0 60
93762: PUSH
93763: LD_INT 1
93765: PUSH
93766: LD_INT 1
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 2
93776: PUSH
93777: LD_INT 0
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 2
93786: PUSH
93787: LD_INT 1
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: LIST
93798: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93799: LD_ADDR_VAR 0 61
93803: PUSH
93804: LD_INT 2
93806: PUSH
93807: LD_INT 1
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 2
93816: PUSH
93817: LD_INT 2
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: LD_INT 1
93826: PUSH
93827: LD_INT 2
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: LIST
93838: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93839: LD_ADDR_VAR 0 62
93843: PUSH
93844: LD_INT 1
93846: PUSH
93847: LD_INT 2
93849: PUSH
93850: EMPTY
93851: LIST
93852: LIST
93853: PUSH
93854: LD_INT 0
93856: PUSH
93857: LD_INT 2
93859: PUSH
93860: EMPTY
93861: LIST
93862: LIST
93863: PUSH
93864: LD_INT 1
93866: NEG
93867: PUSH
93868: LD_INT 1
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: LIST
93879: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93880: LD_ADDR_VAR 0 63
93884: PUSH
93885: LD_INT 1
93887: NEG
93888: PUSH
93889: LD_INT 1
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 2
93898: NEG
93899: PUSH
93900: LD_INT 0
93902: PUSH
93903: EMPTY
93904: LIST
93905: LIST
93906: PUSH
93907: LD_INT 2
93909: NEG
93910: PUSH
93911: LD_INT 1
93913: NEG
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: LIST
93923: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93924: LD_ADDR_VAR 0 64
93928: PUSH
93929: LD_INT 1
93931: NEG
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 2
93943: NEG
93944: PUSH
93945: LD_INT 1
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: LD_INT 2
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: EMPTY
93966: LIST
93967: LIST
93968: LIST
93969: ST_TO_ADDR
// end ; 2 :
93970: GO 97236
93972: LD_INT 2
93974: DOUBLE
93975: EQUAL
93976: IFTRUE 93980
93978: GO 97235
93980: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93981: LD_ADDR_VAR 0 29
93985: PUSH
93986: LD_INT 4
93988: PUSH
93989: LD_INT 0
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: PUSH
93996: LD_INT 4
93998: PUSH
93999: LD_INT 1
94001: NEG
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: LD_INT 5
94009: PUSH
94010: LD_INT 0
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 5
94019: PUSH
94020: LD_INT 1
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: PUSH
94027: LD_INT 4
94029: PUSH
94030: LD_INT 1
94032: PUSH
94033: EMPTY
94034: LIST
94035: LIST
94036: PUSH
94037: LD_INT 3
94039: PUSH
94040: LD_INT 0
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 3
94049: PUSH
94050: LD_INT 1
94052: NEG
94053: PUSH
94054: EMPTY
94055: LIST
94056: LIST
94057: PUSH
94058: LD_INT 3
94060: PUSH
94061: LD_INT 2
94063: NEG
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 5
94071: PUSH
94072: LD_INT 2
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 3
94081: PUSH
94082: LD_INT 3
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 3
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 4
94101: PUSH
94102: LD_INT 3
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 4
94111: PUSH
94112: LD_INT 4
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 3
94121: PUSH
94122: LD_INT 4
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 2
94131: PUSH
94132: LD_INT 3
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 2
94141: PUSH
94142: LD_INT 2
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 4
94151: PUSH
94152: LD_INT 2
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: PUSH
94159: LD_INT 2
94161: PUSH
94162: LD_INT 4
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 0
94171: PUSH
94172: LD_INT 4
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: LD_INT 0
94181: PUSH
94182: LD_INT 3
94184: PUSH
94185: EMPTY
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 1
94191: PUSH
94192: LD_INT 4
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 1
94201: PUSH
94202: LD_INT 5
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 0
94211: PUSH
94212: LD_INT 5
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: NEG
94222: PUSH
94223: LD_INT 4
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 1
94232: NEG
94233: PUSH
94234: LD_INT 3
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 2
94243: PUSH
94244: LD_INT 5
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 2
94253: NEG
94254: PUSH
94255: LD_INT 3
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 3
94264: NEG
94265: PUSH
94266: LD_INT 0
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 3
94275: NEG
94276: PUSH
94277: LD_INT 1
94279: NEG
94280: PUSH
94281: EMPTY
94282: LIST
94283: LIST
94284: PUSH
94285: LD_INT 2
94287: NEG
94288: PUSH
94289: LD_INT 0
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: PUSH
94296: LD_INT 2
94298: NEG
94299: PUSH
94300: LD_INT 1
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: LD_INT 3
94309: NEG
94310: PUSH
94311: LD_INT 1
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 4
94320: NEG
94321: PUSH
94322: LD_INT 0
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 4
94331: NEG
94332: PUSH
94333: LD_INT 1
94335: NEG
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 4
94343: NEG
94344: PUSH
94345: LD_INT 2
94347: NEG
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 2
94355: NEG
94356: PUSH
94357: LD_INT 2
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 4
94366: NEG
94367: PUSH
94368: LD_INT 4
94370: NEG
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 4
94378: NEG
94379: PUSH
94380: LD_INT 5
94382: NEG
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: PUSH
94388: LD_INT 3
94390: NEG
94391: PUSH
94392: LD_INT 4
94394: NEG
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 3
94402: NEG
94403: PUSH
94404: LD_INT 3
94406: NEG
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 4
94414: NEG
94415: PUSH
94416: LD_INT 3
94418: NEG
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 5
94426: NEG
94427: PUSH
94428: LD_INT 4
94430: NEG
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 5
94438: NEG
94439: PUSH
94440: LD_INT 5
94442: NEG
94443: PUSH
94444: EMPTY
94445: LIST
94446: LIST
94447: PUSH
94448: LD_INT 3
94450: NEG
94451: PUSH
94452: LD_INT 5
94454: NEG
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: PUSH
94460: LD_INT 5
94462: NEG
94463: PUSH
94464: LD_INT 3
94466: NEG
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: EMPTY
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94519: LD_ADDR_VAR 0 30
94523: PUSH
94524: LD_INT 4
94526: PUSH
94527: LD_INT 4
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: PUSH
94534: LD_INT 4
94536: PUSH
94537: LD_INT 3
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: PUSH
94544: LD_INT 5
94546: PUSH
94547: LD_INT 4
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: LD_INT 5
94556: PUSH
94557: LD_INT 5
94559: PUSH
94560: EMPTY
94561: LIST
94562: LIST
94563: PUSH
94564: LD_INT 4
94566: PUSH
94567: LD_INT 5
94569: PUSH
94570: EMPTY
94571: LIST
94572: LIST
94573: PUSH
94574: LD_INT 3
94576: PUSH
94577: LD_INT 4
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 3
94586: PUSH
94587: LD_INT 3
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 5
94596: PUSH
94597: LD_INT 3
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 3
94606: PUSH
94607: LD_INT 5
94609: PUSH
94610: EMPTY
94611: LIST
94612: LIST
94613: PUSH
94614: LD_INT 0
94616: PUSH
94617: LD_INT 3
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 0
94626: PUSH
94627: LD_INT 2
94629: PUSH
94630: EMPTY
94631: LIST
94632: LIST
94633: PUSH
94634: LD_INT 1
94636: PUSH
94637: LD_INT 3
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 1
94646: PUSH
94647: LD_INT 4
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 0
94656: PUSH
94657: LD_INT 4
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 1
94666: NEG
94667: PUSH
94668: LD_INT 3
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 1
94677: NEG
94678: PUSH
94679: LD_INT 2
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: PUSH
94686: LD_INT 2
94688: PUSH
94689: LD_INT 4
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 2
94698: NEG
94699: PUSH
94700: LD_INT 2
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: PUSH
94707: LD_INT 4
94709: NEG
94710: PUSH
94711: LD_INT 0
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 4
94720: NEG
94721: PUSH
94722: LD_INT 1
94724: NEG
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 3
94732: NEG
94733: PUSH
94734: LD_INT 0
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 3
94743: NEG
94744: PUSH
94745: LD_INT 1
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 4
94754: NEG
94755: PUSH
94756: LD_INT 1
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 5
94765: NEG
94766: PUSH
94767: LD_INT 0
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 5
94776: NEG
94777: PUSH
94778: LD_INT 1
94780: NEG
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 5
94788: NEG
94789: PUSH
94790: LD_INT 2
94792: NEG
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 3
94800: NEG
94801: PUSH
94802: LD_INT 2
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 3
94811: NEG
94812: PUSH
94813: LD_INT 3
94815: NEG
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 3
94823: NEG
94824: PUSH
94825: LD_INT 4
94827: NEG
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 2
94835: NEG
94836: PUSH
94837: LD_INT 3
94839: NEG
94840: PUSH
94841: EMPTY
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 2
94847: NEG
94848: PUSH
94849: LD_INT 2
94851: NEG
94852: PUSH
94853: EMPTY
94854: LIST
94855: LIST
94856: PUSH
94857: LD_INT 3
94859: NEG
94860: PUSH
94861: LD_INT 2
94863: NEG
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 4
94871: NEG
94872: PUSH
94873: LD_INT 3
94875: NEG
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 4
94883: NEG
94884: PUSH
94885: LD_INT 4
94887: NEG
94888: PUSH
94889: EMPTY
94890: LIST
94891: LIST
94892: PUSH
94893: LD_INT 2
94895: NEG
94896: PUSH
94897: LD_INT 4
94899: NEG
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 4
94907: NEG
94908: PUSH
94909: LD_INT 2
94911: NEG
94912: PUSH
94913: EMPTY
94914: LIST
94915: LIST
94916: PUSH
94917: LD_INT 0
94919: PUSH
94920: LD_INT 4
94922: NEG
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 0
94930: PUSH
94931: LD_INT 5
94933: NEG
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: PUSH
94942: LD_INT 4
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 1
94952: PUSH
94953: LD_INT 3
94955: NEG
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 0
94963: PUSH
94964: LD_INT 3
94966: NEG
94967: PUSH
94968: EMPTY
94969: LIST
94970: LIST
94971: PUSH
94972: LD_INT 1
94974: NEG
94975: PUSH
94976: LD_INT 4
94978: NEG
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: LD_INT 1
94986: NEG
94987: PUSH
94988: LD_INT 5
94990: NEG
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 2
94998: PUSH
94999: LD_INT 3
95001: NEG
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: PUSH
95007: LD_INT 2
95009: NEG
95010: PUSH
95011: LD_INT 5
95013: NEG
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95066: LD_ADDR_VAR 0 31
95070: PUSH
95071: LD_INT 0
95073: PUSH
95074: LD_INT 4
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 0
95083: PUSH
95084: LD_INT 3
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 1
95093: PUSH
95094: LD_INT 4
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: LD_INT 1
95103: PUSH
95104: LD_INT 5
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: LD_INT 0
95113: PUSH
95114: LD_INT 5
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: PUSH
95121: LD_INT 1
95123: NEG
95124: PUSH
95125: LD_INT 4
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 1
95134: NEG
95135: PUSH
95136: LD_INT 3
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 2
95145: PUSH
95146: LD_INT 5
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 2
95155: NEG
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: EMPTY
95161: LIST
95162: LIST
95163: PUSH
95164: LD_INT 3
95166: NEG
95167: PUSH
95168: LD_INT 0
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 3
95177: NEG
95178: PUSH
95179: LD_INT 1
95181: NEG
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 2
95189: NEG
95190: PUSH
95191: LD_INT 0
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: PUSH
95198: LD_INT 2
95200: NEG
95201: PUSH
95202: LD_INT 1
95204: PUSH
95205: EMPTY
95206: LIST
95207: LIST
95208: PUSH
95209: LD_INT 3
95211: NEG
95212: PUSH
95213: LD_INT 1
95215: PUSH
95216: EMPTY
95217: LIST
95218: LIST
95219: PUSH
95220: LD_INT 4
95222: NEG
95223: PUSH
95224: LD_INT 0
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: PUSH
95231: LD_INT 4
95233: NEG
95234: PUSH
95235: LD_INT 1
95237: NEG
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 4
95245: NEG
95246: PUSH
95247: LD_INT 2
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 2
95257: NEG
95258: PUSH
95259: LD_INT 2
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: LD_INT 4
95268: NEG
95269: PUSH
95270: LD_INT 4
95272: NEG
95273: PUSH
95274: EMPTY
95275: LIST
95276: LIST
95277: PUSH
95278: LD_INT 4
95280: NEG
95281: PUSH
95282: LD_INT 5
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 3
95292: NEG
95293: PUSH
95294: LD_INT 4
95296: NEG
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 3
95304: NEG
95305: PUSH
95306: LD_INT 3
95308: NEG
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 4
95316: NEG
95317: PUSH
95318: LD_INT 3
95320: NEG
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 5
95328: NEG
95329: PUSH
95330: LD_INT 4
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 5
95340: NEG
95341: PUSH
95342: LD_INT 5
95344: NEG
95345: PUSH
95346: EMPTY
95347: LIST
95348: LIST
95349: PUSH
95350: LD_INT 3
95352: NEG
95353: PUSH
95354: LD_INT 5
95356: NEG
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: PUSH
95362: LD_INT 5
95364: NEG
95365: PUSH
95366: LD_INT 3
95368: NEG
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 0
95376: PUSH
95377: LD_INT 3
95379: NEG
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 0
95387: PUSH
95388: LD_INT 4
95390: NEG
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 1
95398: PUSH
95399: LD_INT 3
95401: NEG
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 1
95409: PUSH
95410: LD_INT 2
95412: NEG
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 0
95420: PUSH
95421: LD_INT 2
95423: NEG
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 1
95431: NEG
95432: PUSH
95433: LD_INT 3
95435: NEG
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 1
95443: NEG
95444: PUSH
95445: LD_INT 4
95447: NEG
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: LD_INT 2
95455: PUSH
95456: LD_INT 2
95458: NEG
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PUSH
95464: LD_INT 2
95466: NEG
95467: PUSH
95468: LD_INT 4
95470: NEG
95471: PUSH
95472: EMPTY
95473: LIST
95474: LIST
95475: PUSH
95476: LD_INT 4
95478: PUSH
95479: LD_INT 0
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 4
95488: PUSH
95489: LD_INT 1
95491: NEG
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: LD_INT 5
95499: PUSH
95500: LD_INT 0
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 5
95509: PUSH
95510: LD_INT 1
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: PUSH
95517: LD_INT 4
95519: PUSH
95520: LD_INT 1
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: PUSH
95527: LD_INT 3
95529: PUSH
95530: LD_INT 0
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 3
95539: PUSH
95540: LD_INT 1
95542: NEG
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: PUSH
95548: LD_INT 3
95550: PUSH
95551: LD_INT 2
95553: NEG
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: PUSH
95559: LD_INT 5
95561: PUSH
95562: LD_INT 2
95564: PUSH
95565: EMPTY
95566: LIST
95567: LIST
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95616: LD_ADDR_VAR 0 32
95620: PUSH
95621: LD_INT 4
95623: NEG
95624: PUSH
95625: LD_INT 0
95627: PUSH
95628: EMPTY
95629: LIST
95630: LIST
95631: PUSH
95632: LD_INT 4
95634: NEG
95635: PUSH
95636: LD_INT 1
95638: NEG
95639: PUSH
95640: EMPTY
95641: LIST
95642: LIST
95643: PUSH
95644: LD_INT 3
95646: NEG
95647: PUSH
95648: LD_INT 0
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 3
95657: NEG
95658: PUSH
95659: LD_INT 1
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: PUSH
95666: LD_INT 4
95668: NEG
95669: PUSH
95670: LD_INT 1
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 5
95679: NEG
95680: PUSH
95681: LD_INT 0
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 5
95690: NEG
95691: PUSH
95692: LD_INT 1
95694: NEG
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 5
95702: NEG
95703: PUSH
95704: LD_INT 2
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 3
95714: NEG
95715: PUSH
95716: LD_INT 2
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: LD_INT 3
95725: NEG
95726: PUSH
95727: LD_INT 3
95729: NEG
95730: PUSH
95731: EMPTY
95732: LIST
95733: LIST
95734: PUSH
95735: LD_INT 3
95737: NEG
95738: PUSH
95739: LD_INT 4
95741: NEG
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 2
95749: NEG
95750: PUSH
95751: LD_INT 3
95753: NEG
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 2
95761: NEG
95762: PUSH
95763: LD_INT 2
95765: NEG
95766: PUSH
95767: EMPTY
95768: LIST
95769: LIST
95770: PUSH
95771: LD_INT 3
95773: NEG
95774: PUSH
95775: LD_INT 2
95777: NEG
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: LD_INT 4
95785: NEG
95786: PUSH
95787: LD_INT 3
95789: NEG
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 4
95797: NEG
95798: PUSH
95799: LD_INT 4
95801: NEG
95802: PUSH
95803: EMPTY
95804: LIST
95805: LIST
95806: PUSH
95807: LD_INT 2
95809: NEG
95810: PUSH
95811: LD_INT 4
95813: NEG
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 4
95821: NEG
95822: PUSH
95823: LD_INT 2
95825: NEG
95826: PUSH
95827: EMPTY
95828: LIST
95829: LIST
95830: PUSH
95831: LD_INT 0
95833: PUSH
95834: LD_INT 4
95836: NEG
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 0
95844: PUSH
95845: LD_INT 5
95847: NEG
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 1
95855: PUSH
95856: LD_INT 4
95858: NEG
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 1
95866: PUSH
95867: LD_INT 3
95869: NEG
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 0
95877: PUSH
95878: LD_INT 3
95880: NEG
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 1
95888: NEG
95889: PUSH
95890: LD_INT 4
95892: NEG
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: LD_INT 5
95904: NEG
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: LD_INT 2
95912: PUSH
95913: LD_INT 3
95915: NEG
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 2
95923: NEG
95924: PUSH
95925: LD_INT 5
95927: NEG
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 3
95935: PUSH
95936: LD_INT 0
95938: PUSH
95939: EMPTY
95940: LIST
95941: LIST
95942: PUSH
95943: LD_INT 3
95945: PUSH
95946: LD_INT 1
95948: NEG
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 4
95956: PUSH
95957: LD_INT 0
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 4
95966: PUSH
95967: LD_INT 1
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 3
95976: PUSH
95977: LD_INT 1
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 2
95986: PUSH
95987: LD_INT 0
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 2
95996: PUSH
95997: LD_INT 1
95999: NEG
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 2
96007: PUSH
96008: LD_INT 2
96010: NEG
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 4
96018: PUSH
96019: LD_INT 2
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 4
96028: PUSH
96029: LD_INT 4
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 4
96038: PUSH
96039: LD_INT 3
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 5
96048: PUSH
96049: LD_INT 4
96051: PUSH
96052: EMPTY
96053: LIST
96054: LIST
96055: PUSH
96056: LD_INT 5
96058: PUSH
96059: LD_INT 5
96061: PUSH
96062: EMPTY
96063: LIST
96064: LIST
96065: PUSH
96066: LD_INT 4
96068: PUSH
96069: LD_INT 5
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 3
96078: PUSH
96079: LD_INT 4
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 3
96088: PUSH
96089: LD_INT 3
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 5
96098: PUSH
96099: LD_INT 3
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 3
96108: PUSH
96109: LD_INT 5
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96163: LD_ADDR_VAR 0 33
96167: PUSH
96168: LD_INT 4
96170: NEG
96171: PUSH
96172: LD_INT 4
96174: NEG
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: PUSH
96180: LD_INT 4
96182: NEG
96183: PUSH
96184: LD_INT 5
96186: NEG
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 3
96194: NEG
96195: PUSH
96196: LD_INT 4
96198: NEG
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 3
96206: NEG
96207: PUSH
96208: LD_INT 3
96210: NEG
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 4
96218: NEG
96219: PUSH
96220: LD_INT 3
96222: NEG
96223: PUSH
96224: EMPTY
96225: LIST
96226: LIST
96227: PUSH
96228: LD_INT 5
96230: NEG
96231: PUSH
96232: LD_INT 4
96234: NEG
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: PUSH
96240: LD_INT 5
96242: NEG
96243: PUSH
96244: LD_INT 5
96246: NEG
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 3
96254: NEG
96255: PUSH
96256: LD_INT 5
96258: NEG
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 5
96266: NEG
96267: PUSH
96268: LD_INT 3
96270: NEG
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 0
96278: PUSH
96279: LD_INT 3
96281: NEG
96282: PUSH
96283: EMPTY
96284: LIST
96285: LIST
96286: PUSH
96287: LD_INT 0
96289: PUSH
96290: LD_INT 4
96292: NEG
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: PUSH
96298: LD_INT 1
96300: PUSH
96301: LD_INT 3
96303: NEG
96304: PUSH
96305: EMPTY
96306: LIST
96307: LIST
96308: PUSH
96309: LD_INT 1
96311: PUSH
96312: LD_INT 2
96314: NEG
96315: PUSH
96316: EMPTY
96317: LIST
96318: LIST
96319: PUSH
96320: LD_INT 0
96322: PUSH
96323: LD_INT 2
96325: NEG
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 1
96333: NEG
96334: PUSH
96335: LD_INT 3
96337: NEG
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: LD_INT 1
96345: NEG
96346: PUSH
96347: LD_INT 4
96349: NEG
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 2
96357: PUSH
96358: LD_INT 2
96360: NEG
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: LD_INT 2
96368: NEG
96369: PUSH
96370: LD_INT 4
96372: NEG
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 4
96380: PUSH
96381: LD_INT 0
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: PUSH
96388: LD_INT 4
96390: PUSH
96391: LD_INT 1
96393: NEG
96394: PUSH
96395: EMPTY
96396: LIST
96397: LIST
96398: PUSH
96399: LD_INT 5
96401: PUSH
96402: LD_INT 0
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 5
96411: PUSH
96412: LD_INT 1
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: PUSH
96419: LD_INT 4
96421: PUSH
96422: LD_INT 1
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: PUSH
96429: LD_INT 3
96431: PUSH
96432: LD_INT 0
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: LD_INT 3
96441: PUSH
96442: LD_INT 1
96444: NEG
96445: PUSH
96446: EMPTY
96447: LIST
96448: LIST
96449: PUSH
96450: LD_INT 3
96452: PUSH
96453: LD_INT 2
96455: NEG
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: PUSH
96461: LD_INT 5
96463: PUSH
96464: LD_INT 2
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: PUSH
96474: LD_INT 3
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 3
96483: PUSH
96484: LD_INT 2
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 4
96493: PUSH
96494: LD_INT 3
96496: PUSH
96497: EMPTY
96498: LIST
96499: LIST
96500: PUSH
96501: LD_INT 4
96503: PUSH
96504: LD_INT 4
96506: PUSH
96507: EMPTY
96508: LIST
96509: LIST
96510: PUSH
96511: LD_INT 3
96513: PUSH
96514: LD_INT 4
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PUSH
96521: LD_INT 2
96523: PUSH
96524: LD_INT 3
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 2
96533: PUSH
96534: LD_INT 2
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 4
96543: PUSH
96544: LD_INT 2
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_INT 2
96553: PUSH
96554: LD_INT 4
96556: PUSH
96557: EMPTY
96558: LIST
96559: LIST
96560: PUSH
96561: LD_INT 0
96563: PUSH
96564: LD_INT 4
96566: PUSH
96567: EMPTY
96568: LIST
96569: LIST
96570: PUSH
96571: LD_INT 0
96573: PUSH
96574: LD_INT 3
96576: PUSH
96577: EMPTY
96578: LIST
96579: LIST
96580: PUSH
96581: LD_INT 1
96583: PUSH
96584: LD_INT 4
96586: PUSH
96587: EMPTY
96588: LIST
96589: LIST
96590: PUSH
96591: LD_INT 1
96593: PUSH
96594: LD_INT 5
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: PUSH
96601: LD_INT 0
96603: PUSH
96604: LD_INT 5
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: PUSH
96611: LD_INT 1
96613: NEG
96614: PUSH
96615: LD_INT 4
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 1
96624: NEG
96625: PUSH
96626: LD_INT 3
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 2
96635: PUSH
96636: LD_INT 5
96638: PUSH
96639: EMPTY
96640: LIST
96641: LIST
96642: PUSH
96643: LD_INT 2
96645: NEG
96646: PUSH
96647: LD_INT 3
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96701: LD_ADDR_VAR 0 34
96705: PUSH
96706: LD_INT 0
96708: PUSH
96709: LD_INT 4
96711: NEG
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 0
96719: PUSH
96720: LD_INT 5
96722: NEG
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: PUSH
96728: LD_INT 1
96730: PUSH
96731: LD_INT 4
96733: NEG
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: LD_INT 1
96741: PUSH
96742: LD_INT 3
96744: NEG
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: LD_INT 0
96752: PUSH
96753: LD_INT 3
96755: NEG
96756: PUSH
96757: EMPTY
96758: LIST
96759: LIST
96760: PUSH
96761: LD_INT 1
96763: NEG
96764: PUSH
96765: LD_INT 4
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 1
96775: NEG
96776: PUSH
96777: LD_INT 5
96779: NEG
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 2
96787: PUSH
96788: LD_INT 3
96790: NEG
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 2
96798: NEG
96799: PUSH
96800: LD_INT 5
96802: NEG
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 3
96810: PUSH
96811: LD_INT 0
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 3
96820: PUSH
96821: LD_INT 1
96823: NEG
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PUSH
96829: LD_INT 4
96831: PUSH
96832: LD_INT 0
96834: PUSH
96835: EMPTY
96836: LIST
96837: LIST
96838: PUSH
96839: LD_INT 4
96841: PUSH
96842: LD_INT 1
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 3
96851: PUSH
96852: LD_INT 1
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 2
96861: PUSH
96862: LD_INT 0
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 2
96871: PUSH
96872: LD_INT 1
96874: NEG
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 2
96882: PUSH
96883: LD_INT 2
96885: NEG
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: PUSH
96891: LD_INT 4
96893: PUSH
96894: LD_INT 2
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PUSH
96901: LD_INT 4
96903: PUSH
96904: LD_INT 4
96906: PUSH
96907: EMPTY
96908: LIST
96909: LIST
96910: PUSH
96911: LD_INT 4
96913: PUSH
96914: LD_INT 3
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: PUSH
96921: LD_INT 5
96923: PUSH
96924: LD_INT 4
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 5
96933: PUSH
96934: LD_INT 5
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: PUSH
96941: LD_INT 4
96943: PUSH
96944: LD_INT 5
96946: PUSH
96947: EMPTY
96948: LIST
96949: LIST
96950: PUSH
96951: LD_INT 3
96953: PUSH
96954: LD_INT 4
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: LD_INT 3
96963: PUSH
96964: LD_INT 3
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: PUSH
96971: LD_INT 5
96973: PUSH
96974: LD_INT 3
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 3
96983: PUSH
96984: LD_INT 5
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 0
96993: PUSH
96994: LD_INT 3
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 0
97003: PUSH
97004: LD_INT 2
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: LD_INT 1
97013: PUSH
97014: LD_INT 3
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 4
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 0
97033: PUSH
97034: LD_INT 4
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 1
97043: NEG
97044: PUSH
97045: LD_INT 3
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 1
97054: NEG
97055: PUSH
97056: LD_INT 2
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 2
97065: PUSH
97066: LD_INT 4
97068: PUSH
97069: EMPTY
97070: LIST
97071: LIST
97072: PUSH
97073: LD_INT 2
97075: NEG
97076: PUSH
97077: LD_INT 2
97079: PUSH
97080: EMPTY
97081: LIST
97082: LIST
97083: PUSH
97084: LD_INT 4
97086: NEG
97087: PUSH
97088: LD_INT 0
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 4
97097: NEG
97098: PUSH
97099: LD_INT 1
97101: NEG
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 3
97109: NEG
97110: PUSH
97111: LD_INT 0
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 3
97120: NEG
97121: PUSH
97122: LD_INT 1
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 4
97131: NEG
97132: PUSH
97133: LD_INT 1
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 5
97142: NEG
97143: PUSH
97144: LD_INT 0
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: PUSH
97151: LD_INT 5
97153: NEG
97154: PUSH
97155: LD_INT 1
97157: NEG
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: PUSH
97163: LD_INT 5
97165: NEG
97166: PUSH
97167: LD_INT 2
97169: NEG
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 3
97177: NEG
97178: PUSH
97179: LD_INT 2
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: LIST
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: ST_TO_ADDR
// end ; end ;
97233: GO 97236
97235: POP
// case btype of b_depot , b_warehouse :
97236: LD_VAR 0 1
97240: PUSH
97241: LD_INT 0
97243: DOUBLE
97244: EQUAL
97245: IFTRUE 97255
97247: LD_INT 1
97249: DOUBLE
97250: EQUAL
97251: IFTRUE 97255
97253: GO 97456
97255: POP
// case nation of nation_american :
97256: LD_VAR 0 5
97260: PUSH
97261: LD_INT 1
97263: DOUBLE
97264: EQUAL
97265: IFTRUE 97269
97267: GO 97325
97269: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97270: LD_ADDR_VAR 0 9
97274: PUSH
97275: LD_VAR 0 11
97279: PUSH
97280: LD_VAR 0 12
97284: PUSH
97285: LD_VAR 0 13
97289: PUSH
97290: LD_VAR 0 14
97294: PUSH
97295: LD_VAR 0 15
97299: PUSH
97300: LD_VAR 0 16
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: PUSH
97313: LD_VAR 0 4
97317: PUSH
97318: LD_INT 1
97320: PLUS
97321: ARRAY
97322: ST_TO_ADDR
97323: GO 97454
97325: LD_INT 2
97327: DOUBLE
97328: EQUAL
97329: IFTRUE 97333
97331: GO 97389
97333: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97334: LD_ADDR_VAR 0 9
97338: PUSH
97339: LD_VAR 0 17
97343: PUSH
97344: LD_VAR 0 18
97348: PUSH
97349: LD_VAR 0 19
97353: PUSH
97354: LD_VAR 0 20
97358: PUSH
97359: LD_VAR 0 21
97363: PUSH
97364: LD_VAR 0 22
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: PUSH
97377: LD_VAR 0 4
97381: PUSH
97382: LD_INT 1
97384: PLUS
97385: ARRAY
97386: ST_TO_ADDR
97387: GO 97454
97389: LD_INT 3
97391: DOUBLE
97392: EQUAL
97393: IFTRUE 97397
97395: GO 97453
97397: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97398: LD_ADDR_VAR 0 9
97402: PUSH
97403: LD_VAR 0 23
97407: PUSH
97408: LD_VAR 0 24
97412: PUSH
97413: LD_VAR 0 25
97417: PUSH
97418: LD_VAR 0 26
97422: PUSH
97423: LD_VAR 0 27
97427: PUSH
97428: LD_VAR 0 28
97432: PUSH
97433: EMPTY
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: PUSH
97441: LD_VAR 0 4
97445: PUSH
97446: LD_INT 1
97448: PLUS
97449: ARRAY
97450: ST_TO_ADDR
97451: GO 97454
97453: POP
97454: GO 98009
97456: LD_INT 2
97458: DOUBLE
97459: EQUAL
97460: IFTRUE 97470
97462: LD_INT 3
97464: DOUBLE
97465: EQUAL
97466: IFTRUE 97470
97468: GO 97526
97470: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97471: LD_ADDR_VAR 0 9
97475: PUSH
97476: LD_VAR 0 29
97480: PUSH
97481: LD_VAR 0 30
97485: PUSH
97486: LD_VAR 0 31
97490: PUSH
97491: LD_VAR 0 32
97495: PUSH
97496: LD_VAR 0 33
97500: PUSH
97501: LD_VAR 0 34
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: PUSH
97514: LD_VAR 0 4
97518: PUSH
97519: LD_INT 1
97521: PLUS
97522: ARRAY
97523: ST_TO_ADDR
97524: GO 98009
97526: LD_INT 16
97528: DOUBLE
97529: EQUAL
97530: IFTRUE 97588
97532: LD_INT 17
97534: DOUBLE
97535: EQUAL
97536: IFTRUE 97588
97538: LD_INT 18
97540: DOUBLE
97541: EQUAL
97542: IFTRUE 97588
97544: LD_INT 19
97546: DOUBLE
97547: EQUAL
97548: IFTRUE 97588
97550: LD_INT 22
97552: DOUBLE
97553: EQUAL
97554: IFTRUE 97588
97556: LD_INT 20
97558: DOUBLE
97559: EQUAL
97560: IFTRUE 97588
97562: LD_INT 21
97564: DOUBLE
97565: EQUAL
97566: IFTRUE 97588
97568: LD_INT 23
97570: DOUBLE
97571: EQUAL
97572: IFTRUE 97588
97574: LD_INT 24
97576: DOUBLE
97577: EQUAL
97578: IFTRUE 97588
97580: LD_INT 25
97582: DOUBLE
97583: EQUAL
97584: IFTRUE 97588
97586: GO 97644
97588: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97589: LD_ADDR_VAR 0 9
97593: PUSH
97594: LD_VAR 0 35
97598: PUSH
97599: LD_VAR 0 36
97603: PUSH
97604: LD_VAR 0 37
97608: PUSH
97609: LD_VAR 0 38
97613: PUSH
97614: LD_VAR 0 39
97618: PUSH
97619: LD_VAR 0 40
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: PUSH
97632: LD_VAR 0 4
97636: PUSH
97637: LD_INT 1
97639: PLUS
97640: ARRAY
97641: ST_TO_ADDR
97642: GO 98009
97644: LD_INT 6
97646: DOUBLE
97647: EQUAL
97648: IFTRUE 97700
97650: LD_INT 7
97652: DOUBLE
97653: EQUAL
97654: IFTRUE 97700
97656: LD_INT 8
97658: DOUBLE
97659: EQUAL
97660: IFTRUE 97700
97662: LD_INT 13
97664: DOUBLE
97665: EQUAL
97666: IFTRUE 97700
97668: LD_INT 12
97670: DOUBLE
97671: EQUAL
97672: IFTRUE 97700
97674: LD_INT 15
97676: DOUBLE
97677: EQUAL
97678: IFTRUE 97700
97680: LD_INT 11
97682: DOUBLE
97683: EQUAL
97684: IFTRUE 97700
97686: LD_INT 14
97688: DOUBLE
97689: EQUAL
97690: IFTRUE 97700
97692: LD_INT 10
97694: DOUBLE
97695: EQUAL
97696: IFTRUE 97700
97698: GO 97756
97700: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97701: LD_ADDR_VAR 0 9
97705: PUSH
97706: LD_VAR 0 41
97710: PUSH
97711: LD_VAR 0 42
97715: PUSH
97716: LD_VAR 0 43
97720: PUSH
97721: LD_VAR 0 44
97725: PUSH
97726: LD_VAR 0 45
97730: PUSH
97731: LD_VAR 0 46
97735: PUSH
97736: EMPTY
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: PUSH
97744: LD_VAR 0 4
97748: PUSH
97749: LD_INT 1
97751: PLUS
97752: ARRAY
97753: ST_TO_ADDR
97754: GO 98009
97756: LD_INT 36
97758: DOUBLE
97759: EQUAL
97760: IFTRUE 97764
97762: GO 97820
97764: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97765: LD_ADDR_VAR 0 9
97769: PUSH
97770: LD_VAR 0 47
97774: PUSH
97775: LD_VAR 0 48
97779: PUSH
97780: LD_VAR 0 49
97784: PUSH
97785: LD_VAR 0 50
97789: PUSH
97790: LD_VAR 0 51
97794: PUSH
97795: LD_VAR 0 52
97799: PUSH
97800: EMPTY
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: PUSH
97808: LD_VAR 0 4
97812: PUSH
97813: LD_INT 1
97815: PLUS
97816: ARRAY
97817: ST_TO_ADDR
97818: GO 98009
97820: LD_INT 4
97822: DOUBLE
97823: EQUAL
97824: IFTRUE 97846
97826: LD_INT 5
97828: DOUBLE
97829: EQUAL
97830: IFTRUE 97846
97832: LD_INT 34
97834: DOUBLE
97835: EQUAL
97836: IFTRUE 97846
97838: LD_INT 37
97840: DOUBLE
97841: EQUAL
97842: IFTRUE 97846
97844: GO 97902
97846: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97847: LD_ADDR_VAR 0 9
97851: PUSH
97852: LD_VAR 0 53
97856: PUSH
97857: LD_VAR 0 54
97861: PUSH
97862: LD_VAR 0 55
97866: PUSH
97867: LD_VAR 0 56
97871: PUSH
97872: LD_VAR 0 57
97876: PUSH
97877: LD_VAR 0 58
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: PUSH
97890: LD_VAR 0 4
97894: PUSH
97895: LD_INT 1
97897: PLUS
97898: ARRAY
97899: ST_TO_ADDR
97900: GO 98009
97902: LD_INT 31
97904: DOUBLE
97905: EQUAL
97906: IFTRUE 97952
97908: LD_INT 32
97910: DOUBLE
97911: EQUAL
97912: IFTRUE 97952
97914: LD_INT 33
97916: DOUBLE
97917: EQUAL
97918: IFTRUE 97952
97920: LD_INT 27
97922: DOUBLE
97923: EQUAL
97924: IFTRUE 97952
97926: LD_INT 26
97928: DOUBLE
97929: EQUAL
97930: IFTRUE 97952
97932: LD_INT 28
97934: DOUBLE
97935: EQUAL
97936: IFTRUE 97952
97938: LD_INT 29
97940: DOUBLE
97941: EQUAL
97942: IFTRUE 97952
97944: LD_INT 30
97946: DOUBLE
97947: EQUAL
97948: IFTRUE 97952
97950: GO 98008
97952: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97953: LD_ADDR_VAR 0 9
97957: PUSH
97958: LD_VAR 0 59
97962: PUSH
97963: LD_VAR 0 60
97967: PUSH
97968: LD_VAR 0 61
97972: PUSH
97973: LD_VAR 0 62
97977: PUSH
97978: LD_VAR 0 63
97982: PUSH
97983: LD_VAR 0 64
97987: PUSH
97988: EMPTY
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: PUSH
97996: LD_VAR 0 4
98000: PUSH
98001: LD_INT 1
98003: PLUS
98004: ARRAY
98005: ST_TO_ADDR
98006: GO 98009
98008: POP
// temp_list2 = [ ] ;
98009: LD_ADDR_VAR 0 10
98013: PUSH
98014: EMPTY
98015: ST_TO_ADDR
// for i in temp_list do
98016: LD_ADDR_VAR 0 8
98020: PUSH
98021: LD_VAR 0 9
98025: PUSH
98026: FOR_IN
98027: IFFALSE 98079
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98029: LD_ADDR_VAR 0 10
98033: PUSH
98034: LD_VAR 0 10
98038: PUSH
98039: LD_VAR 0 8
98043: PUSH
98044: LD_INT 1
98046: ARRAY
98047: PUSH
98048: LD_VAR 0 2
98052: PLUS
98053: PUSH
98054: LD_VAR 0 8
98058: PUSH
98059: LD_INT 2
98061: ARRAY
98062: PUSH
98063: LD_VAR 0 3
98067: PLUS
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: EMPTY
98074: LIST
98075: ADD
98076: ST_TO_ADDR
98077: GO 98026
98079: POP
98080: POP
// result = temp_list2 ;
98081: LD_ADDR_VAR 0 7
98085: PUSH
98086: LD_VAR 0 10
98090: ST_TO_ADDR
// end ;
98091: LD_VAR 0 7
98095: RET
// export function EnemyInRange ( unit , dist ) ; begin
98096: LD_INT 0
98098: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98099: LD_ADDR_VAR 0 3
98103: PUSH
98104: LD_VAR 0 1
98108: PPUSH
98109: CALL_OW 255
98113: PPUSH
98114: LD_VAR 0 1
98118: PPUSH
98119: CALL_OW 250
98123: PPUSH
98124: LD_VAR 0 1
98128: PPUSH
98129: CALL_OW 251
98133: PPUSH
98134: LD_VAR 0 2
98138: PPUSH
98139: CALL 72200 0 4
98143: PUSH
98144: LD_INT 4
98146: ARRAY
98147: ST_TO_ADDR
// end ;
98148: LD_VAR 0 3
98152: RET
// export function PlayerSeeMe ( unit ) ; begin
98153: LD_INT 0
98155: PPUSH
// result := See ( your_side , unit ) ;
98156: LD_ADDR_VAR 0 2
98160: PUSH
98161: LD_OWVAR 2
98165: PPUSH
98166: LD_VAR 0 1
98170: PPUSH
98171: CALL_OW 292
98175: ST_TO_ADDR
// end ;
98176: LD_VAR 0 2
98180: RET
// export function ReverseDir ( unit ) ; begin
98181: LD_INT 0
98183: PPUSH
// if not unit then
98184: LD_VAR 0 1
98188: NOT
98189: IFFALSE 98193
// exit ;
98191: GO 98239
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98193: LD_ADDR_VAR 0 2
98197: PUSH
98198: LD_INT 3
98200: PUSH
98201: LD_INT 4
98203: PUSH
98204: LD_INT 5
98206: PUSH
98207: LD_INT 0
98209: PUSH
98210: LD_INT 1
98212: PUSH
98213: LD_INT 2
98215: PUSH
98216: EMPTY
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: PUSH
98224: LD_VAR 0 1
98228: PPUSH
98229: CALL_OW 254
98233: PUSH
98234: LD_INT 1
98236: PLUS
98237: ARRAY
98238: ST_TO_ADDR
// end ;
98239: LD_VAR 0 2
98243: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98244: LD_INT 0
98246: PPUSH
98247: PPUSH
98248: PPUSH
98249: PPUSH
98250: PPUSH
// if not hexes then
98251: LD_VAR 0 2
98255: NOT
98256: IFFALSE 98260
// exit ;
98258: GO 98408
// dist := 9999 ;
98260: LD_ADDR_VAR 0 5
98264: PUSH
98265: LD_INT 9999
98267: ST_TO_ADDR
// for i = 1 to hexes do
98268: LD_ADDR_VAR 0 4
98272: PUSH
98273: DOUBLE
98274: LD_INT 1
98276: DEC
98277: ST_TO_ADDR
98278: LD_VAR 0 2
98282: PUSH
98283: FOR_TO
98284: IFFALSE 98396
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98286: LD_VAR 0 1
98290: PPUSH
98291: LD_VAR 0 2
98295: PUSH
98296: LD_VAR 0 4
98300: ARRAY
98301: PUSH
98302: LD_INT 1
98304: ARRAY
98305: PPUSH
98306: LD_VAR 0 2
98310: PUSH
98311: LD_VAR 0 4
98315: ARRAY
98316: PUSH
98317: LD_INT 2
98319: ARRAY
98320: PPUSH
98321: CALL_OW 297
98325: PUSH
98326: LD_VAR 0 5
98330: LESS
98331: IFFALSE 98394
// begin hex := hexes [ i ] ;
98333: LD_ADDR_VAR 0 7
98337: PUSH
98338: LD_VAR 0 2
98342: PUSH
98343: LD_VAR 0 4
98347: ARRAY
98348: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98349: LD_ADDR_VAR 0 5
98353: PUSH
98354: LD_VAR 0 1
98358: PPUSH
98359: LD_VAR 0 2
98363: PUSH
98364: LD_VAR 0 4
98368: ARRAY
98369: PUSH
98370: LD_INT 1
98372: ARRAY
98373: PPUSH
98374: LD_VAR 0 2
98378: PUSH
98379: LD_VAR 0 4
98383: ARRAY
98384: PUSH
98385: LD_INT 2
98387: ARRAY
98388: PPUSH
98389: CALL_OW 297
98393: ST_TO_ADDR
// end ; end ;
98394: GO 98283
98396: POP
98397: POP
// result := hex ;
98398: LD_ADDR_VAR 0 3
98402: PUSH
98403: LD_VAR 0 7
98407: ST_TO_ADDR
// end ;
98408: LD_VAR 0 3
98412: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98413: LD_INT 0
98415: PPUSH
98416: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98417: LD_VAR 0 1
98421: NOT
98422: PUSH
98423: LD_VAR 0 1
98427: PUSH
98428: LD_INT 21
98430: PUSH
98431: LD_INT 2
98433: PUSH
98434: EMPTY
98435: LIST
98436: LIST
98437: PUSH
98438: LD_INT 23
98440: PUSH
98441: LD_INT 2
98443: PUSH
98444: EMPTY
98445: LIST
98446: LIST
98447: PUSH
98448: EMPTY
98449: LIST
98450: LIST
98451: PPUSH
98452: CALL_OW 69
98456: IN
98457: NOT
98458: OR
98459: IFFALSE 98463
// exit ;
98461: GO 98510
// for i = 1 to 3 do
98463: LD_ADDR_VAR 0 3
98467: PUSH
98468: DOUBLE
98469: LD_INT 1
98471: DEC
98472: ST_TO_ADDR
98473: LD_INT 3
98475: PUSH
98476: FOR_TO
98477: IFFALSE 98508
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98479: LD_VAR 0 1
98483: PPUSH
98484: CALL_OW 250
98488: PPUSH
98489: LD_VAR 0 1
98493: PPUSH
98494: CALL_OW 251
98498: PPUSH
98499: LD_INT 1
98501: PPUSH
98502: CALL_OW 453
98506: GO 98476
98508: POP
98509: POP
// end ;
98510: LD_VAR 0 2
98514: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98515: LD_INT 0
98517: PPUSH
98518: PPUSH
98519: PPUSH
98520: PPUSH
98521: PPUSH
98522: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98523: LD_VAR 0 1
98527: NOT
98528: PUSH
98529: LD_VAR 0 2
98533: NOT
98534: OR
98535: PUSH
98536: LD_VAR 0 1
98540: PPUSH
98541: CALL_OW 314
98545: OR
98546: IFFALSE 98550
// exit ;
98548: GO 98991
// x := GetX ( enemy_unit ) ;
98550: LD_ADDR_VAR 0 7
98554: PUSH
98555: LD_VAR 0 2
98559: PPUSH
98560: CALL_OW 250
98564: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98565: LD_ADDR_VAR 0 8
98569: PUSH
98570: LD_VAR 0 2
98574: PPUSH
98575: CALL_OW 251
98579: ST_TO_ADDR
// if not x or not y then
98580: LD_VAR 0 7
98584: NOT
98585: PUSH
98586: LD_VAR 0 8
98590: NOT
98591: OR
98592: IFFALSE 98596
// exit ;
98594: GO 98991
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98596: LD_ADDR_VAR 0 6
98600: PUSH
98601: LD_VAR 0 7
98605: PPUSH
98606: LD_INT 0
98608: PPUSH
98609: LD_INT 4
98611: PPUSH
98612: CALL_OW 272
98616: PUSH
98617: LD_VAR 0 8
98621: PPUSH
98622: LD_INT 0
98624: PPUSH
98625: LD_INT 4
98627: PPUSH
98628: CALL_OW 273
98632: PUSH
98633: EMPTY
98634: LIST
98635: LIST
98636: PUSH
98637: LD_VAR 0 7
98641: PPUSH
98642: LD_INT 1
98644: PPUSH
98645: LD_INT 4
98647: PPUSH
98648: CALL_OW 272
98652: PUSH
98653: LD_VAR 0 8
98657: PPUSH
98658: LD_INT 1
98660: PPUSH
98661: LD_INT 4
98663: PPUSH
98664: CALL_OW 273
98668: PUSH
98669: EMPTY
98670: LIST
98671: LIST
98672: PUSH
98673: LD_VAR 0 7
98677: PPUSH
98678: LD_INT 2
98680: PPUSH
98681: LD_INT 4
98683: PPUSH
98684: CALL_OW 272
98688: PUSH
98689: LD_VAR 0 8
98693: PPUSH
98694: LD_INT 2
98696: PPUSH
98697: LD_INT 4
98699: PPUSH
98700: CALL_OW 273
98704: PUSH
98705: EMPTY
98706: LIST
98707: LIST
98708: PUSH
98709: LD_VAR 0 7
98713: PPUSH
98714: LD_INT 3
98716: PPUSH
98717: LD_INT 4
98719: PPUSH
98720: CALL_OW 272
98724: PUSH
98725: LD_VAR 0 8
98729: PPUSH
98730: LD_INT 3
98732: PPUSH
98733: LD_INT 4
98735: PPUSH
98736: CALL_OW 273
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_VAR 0 7
98749: PPUSH
98750: LD_INT 4
98752: PPUSH
98753: LD_INT 4
98755: PPUSH
98756: CALL_OW 272
98760: PUSH
98761: LD_VAR 0 8
98765: PPUSH
98766: LD_INT 4
98768: PPUSH
98769: LD_INT 4
98771: PPUSH
98772: CALL_OW 273
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: PUSH
98781: LD_VAR 0 7
98785: PPUSH
98786: LD_INT 5
98788: PPUSH
98789: LD_INT 4
98791: PPUSH
98792: CALL_OW 272
98796: PUSH
98797: LD_VAR 0 8
98801: PPUSH
98802: LD_INT 5
98804: PPUSH
98805: LD_INT 4
98807: PPUSH
98808: CALL_OW 273
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: ST_TO_ADDR
// for i = tmp downto 1 do
98825: LD_ADDR_VAR 0 4
98829: PUSH
98830: DOUBLE
98831: LD_VAR 0 6
98835: INC
98836: ST_TO_ADDR
98837: LD_INT 1
98839: PUSH
98840: FOR_DOWNTO
98841: IFFALSE 98942
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98843: LD_VAR 0 6
98847: PUSH
98848: LD_VAR 0 4
98852: ARRAY
98853: PUSH
98854: LD_INT 1
98856: ARRAY
98857: PPUSH
98858: LD_VAR 0 6
98862: PUSH
98863: LD_VAR 0 4
98867: ARRAY
98868: PUSH
98869: LD_INT 2
98871: ARRAY
98872: PPUSH
98873: CALL_OW 488
98877: NOT
98878: PUSH
98879: LD_VAR 0 6
98883: PUSH
98884: LD_VAR 0 4
98888: ARRAY
98889: PUSH
98890: LD_INT 1
98892: ARRAY
98893: PPUSH
98894: LD_VAR 0 6
98898: PUSH
98899: LD_VAR 0 4
98903: ARRAY
98904: PUSH
98905: LD_INT 2
98907: ARRAY
98908: PPUSH
98909: CALL_OW 428
98913: PUSH
98914: LD_INT 0
98916: NONEQUAL
98917: OR
98918: IFFALSE 98940
// tmp := Delete ( tmp , i ) ;
98920: LD_ADDR_VAR 0 6
98924: PUSH
98925: LD_VAR 0 6
98929: PPUSH
98930: LD_VAR 0 4
98934: PPUSH
98935: CALL_OW 3
98939: ST_TO_ADDR
98940: GO 98840
98942: POP
98943: POP
// j := GetClosestHex ( unit , tmp ) ;
98944: LD_ADDR_VAR 0 5
98948: PUSH
98949: LD_VAR 0 1
98953: PPUSH
98954: LD_VAR 0 6
98958: PPUSH
98959: CALL 98244 0 2
98963: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98964: LD_VAR 0 1
98968: PPUSH
98969: LD_VAR 0 5
98973: PUSH
98974: LD_INT 1
98976: ARRAY
98977: PPUSH
98978: LD_VAR 0 5
98982: PUSH
98983: LD_INT 2
98985: ARRAY
98986: PPUSH
98987: CALL_OW 111
// end ;
98991: LD_VAR 0 3
98995: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98996: LD_INT 0
98998: PPUSH
98999: PPUSH
99000: PPUSH
// uc_side = 0 ;
99001: LD_ADDR_OWVAR 20
99005: PUSH
99006: LD_INT 0
99008: ST_TO_ADDR
// uc_nation = 0 ;
99009: LD_ADDR_OWVAR 21
99013: PUSH
99014: LD_INT 0
99016: ST_TO_ADDR
// InitHc ;
99017: CALL_OW 19
// InitVc ;
99021: CALL_OW 20
// if mastodonts then
99025: LD_VAR 0 6
99029: IFFALSE 99096
// for i = 1 to mastodonts do
99031: LD_ADDR_VAR 0 11
99035: PUSH
99036: DOUBLE
99037: LD_INT 1
99039: DEC
99040: ST_TO_ADDR
99041: LD_VAR 0 6
99045: PUSH
99046: FOR_TO
99047: IFFALSE 99094
// begin vc_chassis := 31 ;
99049: LD_ADDR_OWVAR 37
99053: PUSH
99054: LD_INT 31
99056: ST_TO_ADDR
// vc_control := control_rider ;
99057: LD_ADDR_OWVAR 38
99061: PUSH
99062: LD_INT 4
99064: ST_TO_ADDR
// animal := CreateVehicle ;
99065: LD_ADDR_VAR 0 12
99069: PUSH
99070: CALL_OW 45
99074: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99075: LD_VAR 0 12
99079: PPUSH
99080: LD_VAR 0 8
99084: PPUSH
99085: LD_INT 0
99087: PPUSH
99088: CALL 105841 0 3
// end ;
99092: GO 99046
99094: POP
99095: POP
// if horses then
99096: LD_VAR 0 5
99100: IFFALSE 99167
// for i = 1 to horses do
99102: LD_ADDR_VAR 0 11
99106: PUSH
99107: DOUBLE
99108: LD_INT 1
99110: DEC
99111: ST_TO_ADDR
99112: LD_VAR 0 5
99116: PUSH
99117: FOR_TO
99118: IFFALSE 99165
// begin hc_class := 21 ;
99120: LD_ADDR_OWVAR 28
99124: PUSH
99125: LD_INT 21
99127: ST_TO_ADDR
// hc_gallery :=  ;
99128: LD_ADDR_OWVAR 33
99132: PUSH
99133: LD_STRING 
99135: ST_TO_ADDR
// animal := CreateHuman ;
99136: LD_ADDR_VAR 0 12
99140: PUSH
99141: CALL_OW 44
99145: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99146: LD_VAR 0 12
99150: PPUSH
99151: LD_VAR 0 8
99155: PPUSH
99156: LD_INT 0
99158: PPUSH
99159: CALL 105841 0 3
// end ;
99163: GO 99117
99165: POP
99166: POP
// if birds then
99167: LD_VAR 0 1
99171: IFFALSE 99238
// for i = 1 to birds do
99173: LD_ADDR_VAR 0 11
99177: PUSH
99178: DOUBLE
99179: LD_INT 1
99181: DEC
99182: ST_TO_ADDR
99183: LD_VAR 0 1
99187: PUSH
99188: FOR_TO
99189: IFFALSE 99236
// begin hc_class = 18 ;
99191: LD_ADDR_OWVAR 28
99195: PUSH
99196: LD_INT 18
99198: ST_TO_ADDR
// hc_gallery =  ;
99199: LD_ADDR_OWVAR 33
99203: PUSH
99204: LD_STRING 
99206: ST_TO_ADDR
// animal := CreateHuman ;
99207: LD_ADDR_VAR 0 12
99211: PUSH
99212: CALL_OW 44
99216: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99217: LD_VAR 0 12
99221: PPUSH
99222: LD_VAR 0 8
99226: PPUSH
99227: LD_INT 0
99229: PPUSH
99230: CALL 105841 0 3
// end ;
99234: GO 99188
99236: POP
99237: POP
// if tigers then
99238: LD_VAR 0 2
99242: IFFALSE 99326
// for i = 1 to tigers do
99244: LD_ADDR_VAR 0 11
99248: PUSH
99249: DOUBLE
99250: LD_INT 1
99252: DEC
99253: ST_TO_ADDR
99254: LD_VAR 0 2
99258: PUSH
99259: FOR_TO
99260: IFFALSE 99324
// begin hc_class = class_tiger ;
99262: LD_ADDR_OWVAR 28
99266: PUSH
99267: LD_INT 14
99269: ST_TO_ADDR
// hc_gallery =  ;
99270: LD_ADDR_OWVAR 33
99274: PUSH
99275: LD_STRING 
99277: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99278: LD_ADDR_OWVAR 35
99282: PUSH
99283: LD_INT 7
99285: NEG
99286: PPUSH
99287: LD_INT 7
99289: PPUSH
99290: CALL_OW 12
99294: ST_TO_ADDR
// animal := CreateHuman ;
99295: LD_ADDR_VAR 0 12
99299: PUSH
99300: CALL_OW 44
99304: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99305: LD_VAR 0 12
99309: PPUSH
99310: LD_VAR 0 8
99314: PPUSH
99315: LD_INT 0
99317: PPUSH
99318: CALL 105841 0 3
// end ;
99322: GO 99259
99324: POP
99325: POP
// if apemans then
99326: LD_VAR 0 3
99330: IFFALSE 99453
// for i = 1 to apemans do
99332: LD_ADDR_VAR 0 11
99336: PUSH
99337: DOUBLE
99338: LD_INT 1
99340: DEC
99341: ST_TO_ADDR
99342: LD_VAR 0 3
99346: PUSH
99347: FOR_TO
99348: IFFALSE 99451
// begin hc_class = class_apeman ;
99350: LD_ADDR_OWVAR 28
99354: PUSH
99355: LD_INT 12
99357: ST_TO_ADDR
// hc_gallery =  ;
99358: LD_ADDR_OWVAR 33
99362: PUSH
99363: LD_STRING 
99365: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99366: LD_ADDR_OWVAR 35
99370: PUSH
99371: LD_INT 5
99373: NEG
99374: PPUSH
99375: LD_INT 5
99377: PPUSH
99378: CALL_OW 12
99382: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99383: LD_ADDR_OWVAR 31
99387: PUSH
99388: LD_INT 1
99390: PPUSH
99391: LD_INT 3
99393: PPUSH
99394: CALL_OW 12
99398: PUSH
99399: LD_INT 1
99401: PPUSH
99402: LD_INT 3
99404: PPUSH
99405: CALL_OW 12
99409: PUSH
99410: LD_INT 0
99412: PUSH
99413: LD_INT 0
99415: PUSH
99416: EMPTY
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: ST_TO_ADDR
// animal := CreateHuman ;
99422: LD_ADDR_VAR 0 12
99426: PUSH
99427: CALL_OW 44
99431: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99432: LD_VAR 0 12
99436: PPUSH
99437: LD_VAR 0 8
99441: PPUSH
99442: LD_INT 0
99444: PPUSH
99445: CALL 105841 0 3
// end ;
99449: GO 99347
99451: POP
99452: POP
// if enchidnas then
99453: LD_VAR 0 4
99457: IFFALSE 99524
// for i = 1 to enchidnas do
99459: LD_ADDR_VAR 0 11
99463: PUSH
99464: DOUBLE
99465: LD_INT 1
99467: DEC
99468: ST_TO_ADDR
99469: LD_VAR 0 4
99473: PUSH
99474: FOR_TO
99475: IFFALSE 99522
// begin hc_class = 13 ;
99477: LD_ADDR_OWVAR 28
99481: PUSH
99482: LD_INT 13
99484: ST_TO_ADDR
// hc_gallery =  ;
99485: LD_ADDR_OWVAR 33
99489: PUSH
99490: LD_STRING 
99492: ST_TO_ADDR
// animal := CreateHuman ;
99493: LD_ADDR_VAR 0 12
99497: PUSH
99498: CALL_OW 44
99502: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99503: LD_VAR 0 12
99507: PPUSH
99508: LD_VAR 0 8
99512: PPUSH
99513: LD_INT 0
99515: PPUSH
99516: CALL 105841 0 3
// end ;
99520: GO 99474
99522: POP
99523: POP
// if fishes then
99524: LD_VAR 0 7
99528: IFFALSE 99595
// for i = 1 to fishes do
99530: LD_ADDR_VAR 0 11
99534: PUSH
99535: DOUBLE
99536: LD_INT 1
99538: DEC
99539: ST_TO_ADDR
99540: LD_VAR 0 7
99544: PUSH
99545: FOR_TO
99546: IFFALSE 99593
// begin hc_class = 20 ;
99548: LD_ADDR_OWVAR 28
99552: PUSH
99553: LD_INT 20
99555: ST_TO_ADDR
// hc_gallery =  ;
99556: LD_ADDR_OWVAR 33
99560: PUSH
99561: LD_STRING 
99563: ST_TO_ADDR
// animal := CreateHuman ;
99564: LD_ADDR_VAR 0 12
99568: PUSH
99569: CALL_OW 44
99573: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99574: LD_VAR 0 12
99578: PPUSH
99579: LD_VAR 0 9
99583: PPUSH
99584: LD_INT 0
99586: PPUSH
99587: CALL 105841 0 3
// end ;
99591: GO 99545
99593: POP
99594: POP
// end ;
99595: LD_VAR 0 10
99599: RET
// export function WantHeal ( sci , unit ) ; begin
99600: LD_INT 0
99602: PPUSH
// if GetTaskList ( sci ) > 0 then
99603: LD_VAR 0 1
99607: PPUSH
99608: CALL_OW 437
99612: PUSH
99613: LD_INT 0
99615: GREATER
99616: IFFALSE 99686
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99618: LD_VAR 0 1
99622: PPUSH
99623: CALL_OW 437
99627: PUSH
99628: LD_INT 1
99630: ARRAY
99631: PUSH
99632: LD_INT 1
99634: ARRAY
99635: PUSH
99636: LD_STRING l
99638: EQUAL
99639: PUSH
99640: LD_VAR 0 1
99644: PPUSH
99645: CALL_OW 437
99649: PUSH
99650: LD_INT 1
99652: ARRAY
99653: PUSH
99654: LD_INT 4
99656: ARRAY
99657: PUSH
99658: LD_VAR 0 2
99662: EQUAL
99663: AND
99664: IFFALSE 99676
// result := true else
99666: LD_ADDR_VAR 0 3
99670: PUSH
99671: LD_INT 1
99673: ST_TO_ADDR
99674: GO 99684
// result := false ;
99676: LD_ADDR_VAR 0 3
99680: PUSH
99681: LD_INT 0
99683: ST_TO_ADDR
// end else
99684: GO 99694
// result := false ;
99686: LD_ADDR_VAR 0 3
99690: PUSH
99691: LD_INT 0
99693: ST_TO_ADDR
// end ;
99694: LD_VAR 0 3
99698: RET
// export function HealTarget ( sci ) ; begin
99699: LD_INT 0
99701: PPUSH
// if not sci then
99702: LD_VAR 0 1
99706: NOT
99707: IFFALSE 99711
// exit ;
99709: GO 99776
// result := 0 ;
99711: LD_ADDR_VAR 0 2
99715: PUSH
99716: LD_INT 0
99718: ST_TO_ADDR
// if GetTaskList ( sci ) then
99719: LD_VAR 0 1
99723: PPUSH
99724: CALL_OW 437
99728: IFFALSE 99776
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99730: LD_VAR 0 1
99734: PPUSH
99735: CALL_OW 437
99739: PUSH
99740: LD_INT 1
99742: ARRAY
99743: PUSH
99744: LD_INT 1
99746: ARRAY
99747: PUSH
99748: LD_STRING l
99750: EQUAL
99751: IFFALSE 99776
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99753: LD_ADDR_VAR 0 2
99757: PUSH
99758: LD_VAR 0 1
99762: PPUSH
99763: CALL_OW 437
99767: PUSH
99768: LD_INT 1
99770: ARRAY
99771: PUSH
99772: LD_INT 4
99774: ARRAY
99775: ST_TO_ADDR
// end ;
99776: LD_VAR 0 2
99780: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99781: LD_INT 0
99783: PPUSH
99784: PPUSH
99785: PPUSH
99786: PPUSH
99787: PPUSH
99788: PPUSH
99789: PPUSH
99790: PPUSH
99791: PPUSH
99792: PPUSH
99793: PPUSH
99794: PPUSH
99795: PPUSH
99796: PPUSH
99797: PPUSH
99798: PPUSH
99799: PPUSH
99800: PPUSH
99801: PPUSH
99802: PPUSH
99803: PPUSH
99804: PPUSH
99805: PPUSH
99806: PPUSH
99807: PPUSH
99808: PPUSH
99809: PPUSH
99810: PPUSH
99811: PPUSH
99812: PPUSH
99813: PPUSH
99814: PPUSH
99815: PPUSH
99816: PPUSH
// if not list then
99817: LD_VAR 0 1
99821: NOT
99822: IFFALSE 99826
// exit ;
99824: GO 104452
// base := list [ 1 ] ;
99826: LD_ADDR_VAR 0 3
99830: PUSH
99831: LD_VAR 0 1
99835: PUSH
99836: LD_INT 1
99838: ARRAY
99839: ST_TO_ADDR
// group := list [ 2 ] ;
99840: LD_ADDR_VAR 0 4
99844: PUSH
99845: LD_VAR 0 1
99849: PUSH
99850: LD_INT 2
99852: ARRAY
99853: ST_TO_ADDR
// path := list [ 3 ] ;
99854: LD_ADDR_VAR 0 5
99858: PUSH
99859: LD_VAR 0 1
99863: PUSH
99864: LD_INT 3
99866: ARRAY
99867: ST_TO_ADDR
// flags := list [ 4 ] ;
99868: LD_ADDR_VAR 0 6
99872: PUSH
99873: LD_VAR 0 1
99877: PUSH
99878: LD_INT 4
99880: ARRAY
99881: ST_TO_ADDR
// mined := [ ] ;
99882: LD_ADDR_VAR 0 27
99886: PUSH
99887: EMPTY
99888: ST_TO_ADDR
// bombed := [ ] ;
99889: LD_ADDR_VAR 0 28
99893: PUSH
99894: EMPTY
99895: ST_TO_ADDR
// healers := [ ] ;
99896: LD_ADDR_VAR 0 31
99900: PUSH
99901: EMPTY
99902: ST_TO_ADDR
// to_heal := [ ] ;
99903: LD_ADDR_VAR 0 30
99907: PUSH
99908: EMPTY
99909: ST_TO_ADDR
// repairs := [ ] ;
99910: LD_ADDR_VAR 0 33
99914: PUSH
99915: EMPTY
99916: ST_TO_ADDR
// to_repair := [ ] ;
99917: LD_ADDR_VAR 0 32
99921: PUSH
99922: EMPTY
99923: ST_TO_ADDR
// if not group or not path then
99924: LD_VAR 0 4
99928: NOT
99929: PUSH
99930: LD_VAR 0 5
99934: NOT
99935: OR
99936: IFFALSE 99940
// exit ;
99938: GO 104452
// side := GetSide ( group [ 1 ] ) ;
99940: LD_ADDR_VAR 0 35
99944: PUSH
99945: LD_VAR 0 4
99949: PUSH
99950: LD_INT 1
99952: ARRAY
99953: PPUSH
99954: CALL_OW 255
99958: ST_TO_ADDR
// if flags then
99959: LD_VAR 0 6
99963: IFFALSE 100107
// begin f_ignore_area := flags [ 1 ] ;
99965: LD_ADDR_VAR 0 17
99969: PUSH
99970: LD_VAR 0 6
99974: PUSH
99975: LD_INT 1
99977: ARRAY
99978: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99979: LD_ADDR_VAR 0 18
99983: PUSH
99984: LD_VAR 0 6
99988: PUSH
99989: LD_INT 2
99991: ARRAY
99992: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99993: LD_ADDR_VAR 0 19
99997: PUSH
99998: LD_VAR 0 6
100002: PUSH
100003: LD_INT 3
100005: ARRAY
100006: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100007: LD_ADDR_VAR 0 20
100011: PUSH
100012: LD_VAR 0 6
100016: PUSH
100017: LD_INT 4
100019: ARRAY
100020: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100021: LD_ADDR_VAR 0 21
100025: PUSH
100026: LD_VAR 0 6
100030: PUSH
100031: LD_INT 5
100033: ARRAY
100034: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100035: LD_ADDR_VAR 0 22
100039: PUSH
100040: LD_VAR 0 6
100044: PUSH
100045: LD_INT 6
100047: ARRAY
100048: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100049: LD_ADDR_VAR 0 23
100053: PUSH
100054: LD_VAR 0 6
100058: PUSH
100059: LD_INT 7
100061: ARRAY
100062: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100063: LD_ADDR_VAR 0 24
100067: PUSH
100068: LD_VAR 0 6
100072: PUSH
100073: LD_INT 8
100075: ARRAY
100076: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100077: LD_ADDR_VAR 0 25
100081: PUSH
100082: LD_VAR 0 6
100086: PUSH
100087: LD_INT 9
100089: ARRAY
100090: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100091: LD_ADDR_VAR 0 26
100095: PUSH
100096: LD_VAR 0 6
100100: PUSH
100101: LD_INT 10
100103: ARRAY
100104: ST_TO_ADDR
// end else
100105: GO 100187
// begin f_ignore_area := false ;
100107: LD_ADDR_VAR 0 17
100111: PUSH
100112: LD_INT 0
100114: ST_TO_ADDR
// f_capture := false ;
100115: LD_ADDR_VAR 0 18
100119: PUSH
100120: LD_INT 0
100122: ST_TO_ADDR
// f_ignore_civ := false ;
100123: LD_ADDR_VAR 0 19
100127: PUSH
100128: LD_INT 0
100130: ST_TO_ADDR
// f_murder := false ;
100131: LD_ADDR_VAR 0 20
100135: PUSH
100136: LD_INT 0
100138: ST_TO_ADDR
// f_mines := false ;
100139: LD_ADDR_VAR 0 21
100143: PUSH
100144: LD_INT 0
100146: ST_TO_ADDR
// f_repair := false ;
100147: LD_ADDR_VAR 0 22
100151: PUSH
100152: LD_INT 0
100154: ST_TO_ADDR
// f_heal := false ;
100155: LD_ADDR_VAR 0 23
100159: PUSH
100160: LD_INT 0
100162: ST_TO_ADDR
// f_spacetime := false ;
100163: LD_ADDR_VAR 0 24
100167: PUSH
100168: LD_INT 0
100170: ST_TO_ADDR
// f_attack_depot := false ;
100171: LD_ADDR_VAR 0 25
100175: PUSH
100176: LD_INT 0
100178: ST_TO_ADDR
// f_crawl := false ;
100179: LD_ADDR_VAR 0 26
100183: PUSH
100184: LD_INT 0
100186: ST_TO_ADDR
// end ; if f_heal then
100187: LD_VAR 0 23
100191: IFFALSE 100218
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100193: LD_ADDR_VAR 0 31
100197: PUSH
100198: LD_VAR 0 4
100202: PPUSH
100203: LD_INT 25
100205: PUSH
100206: LD_INT 4
100208: PUSH
100209: EMPTY
100210: LIST
100211: LIST
100212: PPUSH
100213: CALL_OW 72
100217: ST_TO_ADDR
// if f_repair then
100218: LD_VAR 0 22
100222: IFFALSE 100249
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100224: LD_ADDR_VAR 0 33
100228: PUSH
100229: LD_VAR 0 4
100233: PPUSH
100234: LD_INT 25
100236: PUSH
100237: LD_INT 3
100239: PUSH
100240: EMPTY
100241: LIST
100242: LIST
100243: PPUSH
100244: CALL_OW 72
100248: ST_TO_ADDR
// units_path := [ ] ;
100249: LD_ADDR_VAR 0 16
100253: PUSH
100254: EMPTY
100255: ST_TO_ADDR
// for i = 1 to group do
100256: LD_ADDR_VAR 0 7
100260: PUSH
100261: DOUBLE
100262: LD_INT 1
100264: DEC
100265: ST_TO_ADDR
100266: LD_VAR 0 4
100270: PUSH
100271: FOR_TO
100272: IFFALSE 100301
// units_path := Replace ( units_path , i , path ) ;
100274: LD_ADDR_VAR 0 16
100278: PUSH
100279: LD_VAR 0 16
100283: PPUSH
100284: LD_VAR 0 7
100288: PPUSH
100289: LD_VAR 0 5
100293: PPUSH
100294: CALL_OW 1
100298: ST_TO_ADDR
100299: GO 100271
100301: POP
100302: POP
// repeat for i = group downto 1 do
100303: LD_ADDR_VAR 0 7
100307: PUSH
100308: DOUBLE
100309: LD_VAR 0 4
100313: INC
100314: ST_TO_ADDR
100315: LD_INT 1
100317: PUSH
100318: FOR_DOWNTO
100319: IFFALSE 104415
// begin wait ( 5 ) ;
100321: LD_INT 5
100323: PPUSH
100324: CALL_OW 67
// tmp := [ ] ;
100328: LD_ADDR_VAR 0 14
100332: PUSH
100333: EMPTY
100334: ST_TO_ADDR
// attacking := false ;
100335: LD_ADDR_VAR 0 29
100339: PUSH
100340: LD_INT 0
100342: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100343: LD_VAR 0 4
100347: PUSH
100348: LD_VAR 0 7
100352: ARRAY
100353: PPUSH
100354: CALL_OW 301
100358: PUSH
100359: LD_VAR 0 4
100363: PUSH
100364: LD_VAR 0 7
100368: ARRAY
100369: NOT
100370: OR
100371: IFFALSE 100480
// begin if GetType ( group [ i ] ) = unit_human then
100373: LD_VAR 0 4
100377: PUSH
100378: LD_VAR 0 7
100382: ARRAY
100383: PPUSH
100384: CALL_OW 247
100388: PUSH
100389: LD_INT 1
100391: EQUAL
100392: IFFALSE 100438
// begin to_heal := to_heal diff group [ i ] ;
100394: LD_ADDR_VAR 0 30
100398: PUSH
100399: LD_VAR 0 30
100403: PUSH
100404: LD_VAR 0 4
100408: PUSH
100409: LD_VAR 0 7
100413: ARRAY
100414: DIFF
100415: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100416: LD_ADDR_VAR 0 31
100420: PUSH
100421: LD_VAR 0 31
100425: PUSH
100426: LD_VAR 0 4
100430: PUSH
100431: LD_VAR 0 7
100435: ARRAY
100436: DIFF
100437: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100438: LD_ADDR_VAR 0 4
100442: PUSH
100443: LD_VAR 0 4
100447: PPUSH
100448: LD_VAR 0 7
100452: PPUSH
100453: CALL_OW 3
100457: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100458: LD_ADDR_VAR 0 16
100462: PUSH
100463: LD_VAR 0 16
100467: PPUSH
100468: LD_VAR 0 7
100472: PPUSH
100473: CALL_OW 3
100477: ST_TO_ADDR
// continue ;
100478: GO 100318
// end ; if f_repair then
100480: LD_VAR 0 22
100484: IFFALSE 100973
// begin if GetType ( group [ i ] ) = unit_vehicle then
100486: LD_VAR 0 4
100490: PUSH
100491: LD_VAR 0 7
100495: ARRAY
100496: PPUSH
100497: CALL_OW 247
100501: PUSH
100502: LD_INT 2
100504: EQUAL
100505: IFFALSE 100695
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100507: LD_VAR 0 4
100511: PUSH
100512: LD_VAR 0 7
100516: ARRAY
100517: PPUSH
100518: CALL_OW 256
100522: PUSH
100523: LD_INT 700
100525: LESS
100526: PUSH
100527: LD_VAR 0 4
100531: PUSH
100532: LD_VAR 0 7
100536: ARRAY
100537: PUSH
100538: LD_VAR 0 32
100542: IN
100543: NOT
100544: AND
100545: IFFALSE 100569
// to_repair := to_repair union group [ i ] ;
100547: LD_ADDR_VAR 0 32
100551: PUSH
100552: LD_VAR 0 32
100556: PUSH
100557: LD_VAR 0 4
100561: PUSH
100562: LD_VAR 0 7
100566: ARRAY
100567: UNION
100568: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100569: LD_VAR 0 4
100573: PUSH
100574: LD_VAR 0 7
100578: ARRAY
100579: PPUSH
100580: CALL_OW 256
100584: PUSH
100585: LD_INT 1000
100587: EQUAL
100588: PUSH
100589: LD_VAR 0 4
100593: PUSH
100594: LD_VAR 0 7
100598: ARRAY
100599: PUSH
100600: LD_VAR 0 32
100604: IN
100605: AND
100606: IFFALSE 100630
// to_repair := to_repair diff group [ i ] ;
100608: LD_ADDR_VAR 0 32
100612: PUSH
100613: LD_VAR 0 32
100617: PUSH
100618: LD_VAR 0 4
100622: PUSH
100623: LD_VAR 0 7
100627: ARRAY
100628: DIFF
100629: ST_TO_ADDR
// if group [ i ] in to_repair then
100630: LD_VAR 0 4
100634: PUSH
100635: LD_VAR 0 7
100639: ARRAY
100640: PUSH
100641: LD_VAR 0 32
100645: IN
100646: IFFALSE 100693
// begin if not IsInArea ( group [ i ] , f_repair ) then
100648: LD_VAR 0 4
100652: PUSH
100653: LD_VAR 0 7
100657: ARRAY
100658: PPUSH
100659: LD_VAR 0 22
100663: PPUSH
100664: CALL_OW 308
100668: NOT
100669: IFFALSE 100691
// ComMoveToArea ( group [ i ] , f_repair ) ;
100671: LD_VAR 0 4
100675: PUSH
100676: LD_VAR 0 7
100680: ARRAY
100681: PPUSH
100682: LD_VAR 0 22
100686: PPUSH
100687: CALL_OW 113
// continue ;
100691: GO 100318
// end ; end else
100693: GO 100973
// if group [ i ] in repairs then
100695: LD_VAR 0 4
100699: PUSH
100700: LD_VAR 0 7
100704: ARRAY
100705: PUSH
100706: LD_VAR 0 33
100710: IN
100711: IFFALSE 100973
// begin if IsInUnit ( group [ i ] ) then
100713: LD_VAR 0 4
100717: PUSH
100718: LD_VAR 0 7
100722: ARRAY
100723: PPUSH
100724: CALL_OW 310
100728: IFFALSE 100796
// begin z := IsInUnit ( group [ i ] ) ;
100730: LD_ADDR_VAR 0 13
100734: PUSH
100735: LD_VAR 0 4
100739: PUSH
100740: LD_VAR 0 7
100744: ARRAY
100745: PPUSH
100746: CALL_OW 310
100750: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100751: LD_VAR 0 13
100755: PUSH
100756: LD_VAR 0 32
100760: IN
100761: PUSH
100762: LD_VAR 0 13
100766: PPUSH
100767: LD_VAR 0 22
100771: PPUSH
100772: CALL_OW 308
100776: AND
100777: IFFALSE 100794
// ComExitVehicle ( group [ i ] ) ;
100779: LD_VAR 0 4
100783: PUSH
100784: LD_VAR 0 7
100788: ARRAY
100789: PPUSH
100790: CALL_OW 121
// end else
100794: GO 100973
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100796: LD_ADDR_VAR 0 13
100800: PUSH
100801: LD_VAR 0 4
100805: PPUSH
100806: LD_INT 95
100808: PUSH
100809: LD_VAR 0 22
100813: PUSH
100814: EMPTY
100815: LIST
100816: LIST
100817: PUSH
100818: LD_INT 58
100820: PUSH
100821: EMPTY
100822: LIST
100823: PUSH
100824: EMPTY
100825: LIST
100826: LIST
100827: PPUSH
100828: CALL_OW 72
100832: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100833: LD_VAR 0 4
100837: PUSH
100838: LD_VAR 0 7
100842: ARRAY
100843: PPUSH
100844: CALL_OW 314
100848: NOT
100849: IFFALSE 100971
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100851: LD_ADDR_VAR 0 10
100855: PUSH
100856: LD_VAR 0 13
100860: PPUSH
100861: LD_VAR 0 4
100865: PUSH
100866: LD_VAR 0 7
100870: ARRAY
100871: PPUSH
100872: CALL_OW 74
100876: ST_TO_ADDR
// if not x then
100877: LD_VAR 0 10
100881: NOT
100882: IFFALSE 100886
// continue ;
100884: GO 100318
// if GetLives ( x ) < 1000 then
100886: LD_VAR 0 10
100890: PPUSH
100891: CALL_OW 256
100895: PUSH
100896: LD_INT 1000
100898: LESS
100899: IFFALSE 100923
// ComRepairVehicle ( group [ i ] , x ) else
100901: LD_VAR 0 4
100905: PUSH
100906: LD_VAR 0 7
100910: ARRAY
100911: PPUSH
100912: LD_VAR 0 10
100916: PPUSH
100917: CALL_OW 129
100921: GO 100971
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100923: LD_VAR 0 23
100927: PUSH
100928: LD_VAR 0 4
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PPUSH
100939: CALL_OW 256
100943: PUSH
100944: LD_INT 1000
100946: LESS
100947: AND
100948: NOT
100949: IFFALSE 100971
// ComEnterUnit ( group [ i ] , x ) ;
100951: LD_VAR 0 4
100955: PUSH
100956: LD_VAR 0 7
100960: ARRAY
100961: PPUSH
100962: LD_VAR 0 10
100966: PPUSH
100967: CALL_OW 120
// end ; continue ;
100971: GO 100318
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100973: LD_VAR 0 23
100977: PUSH
100978: LD_VAR 0 4
100982: PUSH
100983: LD_VAR 0 7
100987: ARRAY
100988: PPUSH
100989: CALL_OW 247
100993: PUSH
100994: LD_INT 1
100996: EQUAL
100997: AND
100998: IFFALSE 101476
// begin if group [ i ] in healers then
101000: LD_VAR 0 4
101004: PUSH
101005: LD_VAR 0 7
101009: ARRAY
101010: PUSH
101011: LD_VAR 0 31
101015: IN
101016: IFFALSE 101289
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101018: LD_VAR 0 4
101022: PUSH
101023: LD_VAR 0 7
101027: ARRAY
101028: PPUSH
101029: LD_VAR 0 23
101033: PPUSH
101034: CALL_OW 308
101038: NOT
101039: PUSH
101040: LD_VAR 0 4
101044: PUSH
101045: LD_VAR 0 7
101049: ARRAY
101050: PPUSH
101051: CALL_OW 314
101055: NOT
101056: AND
101057: IFFALSE 101081
// ComMoveToArea ( group [ i ] , f_heal ) else
101059: LD_VAR 0 4
101063: PUSH
101064: LD_VAR 0 7
101068: ARRAY
101069: PPUSH
101070: LD_VAR 0 23
101074: PPUSH
101075: CALL_OW 113
101079: GO 101287
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101081: LD_VAR 0 4
101085: PUSH
101086: LD_VAR 0 7
101090: ARRAY
101091: PPUSH
101092: CALL 99699 0 1
101096: PPUSH
101097: CALL_OW 256
101101: PUSH
101102: LD_INT 1000
101104: EQUAL
101105: IFFALSE 101124
// ComStop ( group [ i ] ) else
101107: LD_VAR 0 4
101111: PUSH
101112: LD_VAR 0 7
101116: ARRAY
101117: PPUSH
101118: CALL_OW 141
101122: GO 101287
// if not HasTask ( group [ i ] ) and to_heal then
101124: LD_VAR 0 4
101128: PUSH
101129: LD_VAR 0 7
101133: ARRAY
101134: PPUSH
101135: CALL_OW 314
101139: NOT
101140: PUSH
101141: LD_VAR 0 30
101145: AND
101146: IFFALSE 101287
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101148: LD_ADDR_VAR 0 13
101152: PUSH
101153: LD_VAR 0 30
101157: PPUSH
101158: LD_INT 3
101160: PUSH
101161: LD_INT 54
101163: PUSH
101164: EMPTY
101165: LIST
101166: PUSH
101167: EMPTY
101168: LIST
101169: LIST
101170: PPUSH
101171: CALL_OW 72
101175: PPUSH
101176: LD_VAR 0 4
101180: PUSH
101181: LD_VAR 0 7
101185: ARRAY
101186: PPUSH
101187: CALL_OW 74
101191: ST_TO_ADDR
// if z then
101192: LD_VAR 0 13
101196: IFFALSE 101287
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101198: LD_INT 91
101200: PUSH
101201: LD_VAR 0 13
101205: PUSH
101206: LD_INT 10
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: LIST
101213: PUSH
101214: LD_INT 81
101216: PUSH
101217: LD_VAR 0 13
101221: PPUSH
101222: CALL_OW 255
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: PPUSH
101235: CALL_OW 69
101239: PUSH
101240: LD_INT 0
101242: EQUAL
101243: IFFALSE 101267
// ComHeal ( group [ i ] , z ) else
101245: LD_VAR 0 4
101249: PUSH
101250: LD_VAR 0 7
101254: ARRAY
101255: PPUSH
101256: LD_VAR 0 13
101260: PPUSH
101261: CALL_OW 128
101265: GO 101287
// ComMoveToArea ( group [ i ] , f_heal ) ;
101267: LD_VAR 0 4
101271: PUSH
101272: LD_VAR 0 7
101276: ARRAY
101277: PPUSH
101278: LD_VAR 0 23
101282: PPUSH
101283: CALL_OW 113
// end ; continue ;
101287: GO 100318
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101289: LD_VAR 0 4
101293: PUSH
101294: LD_VAR 0 7
101298: ARRAY
101299: PPUSH
101300: CALL_OW 256
101304: PUSH
101305: LD_INT 700
101307: LESS
101308: PUSH
101309: LD_VAR 0 4
101313: PUSH
101314: LD_VAR 0 7
101318: ARRAY
101319: PUSH
101320: LD_VAR 0 30
101324: IN
101325: NOT
101326: AND
101327: IFFALSE 101351
// to_heal := to_heal union group [ i ] ;
101329: LD_ADDR_VAR 0 30
101333: PUSH
101334: LD_VAR 0 30
101338: PUSH
101339: LD_VAR 0 4
101343: PUSH
101344: LD_VAR 0 7
101348: ARRAY
101349: UNION
101350: ST_TO_ADDR
// if group [ i ] in to_heal then
101351: LD_VAR 0 4
101355: PUSH
101356: LD_VAR 0 7
101360: ARRAY
101361: PUSH
101362: LD_VAR 0 30
101366: IN
101367: IFFALSE 101476
// begin if GetLives ( group [ i ] ) = 1000 then
101369: LD_VAR 0 4
101373: PUSH
101374: LD_VAR 0 7
101378: ARRAY
101379: PPUSH
101380: CALL_OW 256
101384: PUSH
101385: LD_INT 1000
101387: EQUAL
101388: IFFALSE 101414
// to_heal := to_heal diff group [ i ] else
101390: LD_ADDR_VAR 0 30
101394: PUSH
101395: LD_VAR 0 30
101399: PUSH
101400: LD_VAR 0 4
101404: PUSH
101405: LD_VAR 0 7
101409: ARRAY
101410: DIFF
101411: ST_TO_ADDR
101412: GO 101476
// begin if not IsInArea ( group [ i ] , to_heal ) then
101414: LD_VAR 0 4
101418: PUSH
101419: LD_VAR 0 7
101423: ARRAY
101424: PPUSH
101425: LD_VAR 0 30
101429: PPUSH
101430: CALL_OW 308
101434: NOT
101435: IFFALSE 101459
// ComMoveToArea ( group [ i ] , f_heal ) else
101437: LD_VAR 0 4
101441: PUSH
101442: LD_VAR 0 7
101446: ARRAY
101447: PPUSH
101448: LD_VAR 0 23
101452: PPUSH
101453: CALL_OW 113
101457: GO 101474
// ComHold ( group [ i ] ) ;
101459: LD_VAR 0 4
101463: PUSH
101464: LD_VAR 0 7
101468: ARRAY
101469: PPUSH
101470: CALL_OW 140
// continue ;
101474: GO 100318
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101476: LD_VAR 0 4
101480: PUSH
101481: LD_VAR 0 7
101485: ARRAY
101486: PPUSH
101487: LD_INT 10
101489: PPUSH
101490: CALL 98096 0 2
101494: NOT
101495: PUSH
101496: LD_VAR 0 16
101500: PUSH
101501: LD_VAR 0 7
101505: ARRAY
101506: PUSH
101507: EMPTY
101508: EQUAL
101509: NOT
101510: AND
101511: IFFALSE 101777
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101513: LD_VAR 0 4
101517: PUSH
101518: LD_VAR 0 7
101522: ARRAY
101523: PPUSH
101524: CALL_OW 262
101528: PUSH
101529: LD_INT 1
101531: PUSH
101532: LD_INT 2
101534: PUSH
101535: EMPTY
101536: LIST
101537: LIST
101538: IN
101539: IFFALSE 101580
// if GetFuel ( group [ i ] ) < 10 then
101541: LD_VAR 0 4
101545: PUSH
101546: LD_VAR 0 7
101550: ARRAY
101551: PPUSH
101552: CALL_OW 261
101556: PUSH
101557: LD_INT 10
101559: LESS
101560: IFFALSE 101580
// SetFuel ( group [ i ] , 12 ) ;
101562: LD_VAR 0 4
101566: PUSH
101567: LD_VAR 0 7
101571: ARRAY
101572: PPUSH
101573: LD_INT 12
101575: PPUSH
101576: CALL_OW 240
// if units_path [ i ] then
101580: LD_VAR 0 16
101584: PUSH
101585: LD_VAR 0 7
101589: ARRAY
101590: IFFALSE 101775
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101592: LD_VAR 0 4
101596: PUSH
101597: LD_VAR 0 7
101601: ARRAY
101602: PPUSH
101603: LD_VAR 0 16
101607: PUSH
101608: LD_VAR 0 7
101612: ARRAY
101613: PUSH
101614: LD_INT 1
101616: ARRAY
101617: PUSH
101618: LD_INT 1
101620: ARRAY
101621: PPUSH
101622: LD_VAR 0 16
101626: PUSH
101627: LD_VAR 0 7
101631: ARRAY
101632: PUSH
101633: LD_INT 1
101635: ARRAY
101636: PUSH
101637: LD_INT 2
101639: ARRAY
101640: PPUSH
101641: CALL_OW 297
101645: PUSH
101646: LD_INT 6
101648: GREATER
101649: IFFALSE 101724
// begin if not HasTask ( group [ i ] ) then
101651: LD_VAR 0 4
101655: PUSH
101656: LD_VAR 0 7
101660: ARRAY
101661: PPUSH
101662: CALL_OW 314
101666: NOT
101667: IFFALSE 101722
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101669: LD_VAR 0 4
101673: PUSH
101674: LD_VAR 0 7
101678: ARRAY
101679: PPUSH
101680: LD_VAR 0 16
101684: PUSH
101685: LD_VAR 0 7
101689: ARRAY
101690: PUSH
101691: LD_INT 1
101693: ARRAY
101694: PUSH
101695: LD_INT 1
101697: ARRAY
101698: PPUSH
101699: LD_VAR 0 16
101703: PUSH
101704: LD_VAR 0 7
101708: ARRAY
101709: PUSH
101710: LD_INT 1
101712: ARRAY
101713: PUSH
101714: LD_INT 2
101716: ARRAY
101717: PPUSH
101718: CALL_OW 114
// end else
101722: GO 101775
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101724: LD_ADDR_VAR 0 15
101728: PUSH
101729: LD_VAR 0 16
101733: PUSH
101734: LD_VAR 0 7
101738: ARRAY
101739: PPUSH
101740: LD_INT 1
101742: PPUSH
101743: CALL_OW 3
101747: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101748: LD_ADDR_VAR 0 16
101752: PUSH
101753: LD_VAR 0 16
101757: PPUSH
101758: LD_VAR 0 7
101762: PPUSH
101763: LD_VAR 0 15
101767: PPUSH
101768: CALL_OW 1
101772: ST_TO_ADDR
// continue ;
101773: GO 100318
// end ; end ; end else
101775: GO 104413
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101777: LD_ADDR_VAR 0 14
101781: PUSH
101782: LD_INT 81
101784: PUSH
101785: LD_VAR 0 4
101789: PUSH
101790: LD_VAR 0 7
101794: ARRAY
101795: PPUSH
101796: CALL_OW 255
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PPUSH
101805: CALL_OW 69
101809: ST_TO_ADDR
// if not tmp then
101810: LD_VAR 0 14
101814: NOT
101815: IFFALSE 101819
// continue ;
101817: GO 100318
// if f_ignore_area then
101819: LD_VAR 0 17
101823: IFFALSE 101911
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101825: LD_ADDR_VAR 0 15
101829: PUSH
101830: LD_VAR 0 14
101834: PPUSH
101835: LD_INT 3
101837: PUSH
101838: LD_INT 92
101840: PUSH
101841: LD_VAR 0 17
101845: PUSH
101846: LD_INT 1
101848: ARRAY
101849: PUSH
101850: LD_VAR 0 17
101854: PUSH
101855: LD_INT 2
101857: ARRAY
101858: PUSH
101859: LD_VAR 0 17
101863: PUSH
101864: LD_INT 3
101866: ARRAY
101867: PUSH
101868: EMPTY
101869: LIST
101870: LIST
101871: LIST
101872: LIST
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PPUSH
101878: CALL_OW 72
101882: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101883: LD_VAR 0 14
101887: PUSH
101888: LD_VAR 0 15
101892: DIFF
101893: IFFALSE 101911
// tmp := tmp diff tmp2 ;
101895: LD_ADDR_VAR 0 14
101899: PUSH
101900: LD_VAR 0 14
101904: PUSH
101905: LD_VAR 0 15
101909: DIFF
101910: ST_TO_ADDR
// end ; if not f_murder then
101911: LD_VAR 0 20
101915: NOT
101916: IFFALSE 101974
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101918: LD_ADDR_VAR 0 15
101922: PUSH
101923: LD_VAR 0 14
101927: PPUSH
101928: LD_INT 3
101930: PUSH
101931: LD_INT 50
101933: PUSH
101934: EMPTY
101935: LIST
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PPUSH
101941: CALL_OW 72
101945: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101946: LD_VAR 0 14
101950: PUSH
101951: LD_VAR 0 15
101955: DIFF
101956: IFFALSE 101974
// tmp := tmp diff tmp2 ;
101958: LD_ADDR_VAR 0 14
101962: PUSH
101963: LD_VAR 0 14
101967: PUSH
101968: LD_VAR 0 15
101972: DIFF
101973: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101974: LD_ADDR_VAR 0 14
101978: PUSH
101979: LD_VAR 0 4
101983: PUSH
101984: LD_VAR 0 7
101988: ARRAY
101989: PPUSH
101990: LD_VAR 0 14
101994: PPUSH
101995: LD_INT 1
101997: PPUSH
101998: LD_INT 1
102000: PPUSH
102001: CALL 71739 0 4
102005: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102006: LD_VAR 0 4
102010: PUSH
102011: LD_VAR 0 7
102015: ARRAY
102016: PPUSH
102017: CALL_OW 257
102021: PUSH
102022: LD_INT 1
102024: EQUAL
102025: IFFALSE 102473
// begin if WantPlant ( group [ i ] ) then
102027: LD_VAR 0 4
102031: PUSH
102032: LD_VAR 0 7
102036: ARRAY
102037: PPUSH
102038: CALL 71240 0 1
102042: IFFALSE 102046
// continue ;
102044: GO 100318
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102046: LD_VAR 0 18
102050: PUSH
102051: LD_VAR 0 4
102055: PUSH
102056: LD_VAR 0 7
102060: ARRAY
102061: PPUSH
102062: CALL_OW 310
102066: NOT
102067: AND
102068: PUSH
102069: LD_VAR 0 14
102073: PUSH
102074: LD_INT 1
102076: ARRAY
102077: PUSH
102078: LD_VAR 0 14
102082: PPUSH
102083: LD_INT 21
102085: PUSH
102086: LD_INT 2
102088: PUSH
102089: EMPTY
102090: LIST
102091: LIST
102092: PUSH
102093: LD_INT 58
102095: PUSH
102096: EMPTY
102097: LIST
102098: PUSH
102099: EMPTY
102100: LIST
102101: LIST
102102: PPUSH
102103: CALL_OW 72
102107: IN
102108: AND
102109: IFFALSE 102145
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102111: LD_VAR 0 4
102115: PUSH
102116: LD_VAR 0 7
102120: ARRAY
102121: PPUSH
102122: LD_VAR 0 14
102126: PUSH
102127: LD_INT 1
102129: ARRAY
102130: PPUSH
102131: CALL_OW 120
// attacking := true ;
102135: LD_ADDR_VAR 0 29
102139: PUSH
102140: LD_INT 1
102142: ST_TO_ADDR
// continue ;
102143: GO 100318
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102145: LD_VAR 0 26
102149: PUSH
102150: LD_VAR 0 4
102154: PUSH
102155: LD_VAR 0 7
102159: ARRAY
102160: PPUSH
102161: CALL_OW 257
102165: PUSH
102166: LD_INT 1
102168: EQUAL
102169: AND
102170: PUSH
102171: LD_VAR 0 4
102175: PUSH
102176: LD_VAR 0 7
102180: ARRAY
102181: PPUSH
102182: CALL_OW 256
102186: PUSH
102187: LD_INT 800
102189: LESS
102190: AND
102191: PUSH
102192: LD_VAR 0 4
102196: PUSH
102197: LD_VAR 0 7
102201: ARRAY
102202: PPUSH
102203: CALL_OW 318
102207: NOT
102208: AND
102209: IFFALSE 102226
// ComCrawl ( group [ i ] ) ;
102211: LD_VAR 0 4
102215: PUSH
102216: LD_VAR 0 7
102220: ARRAY
102221: PPUSH
102222: CALL_OW 137
// if f_mines then
102226: LD_VAR 0 21
102230: IFFALSE 102473
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102232: LD_VAR 0 14
102236: PUSH
102237: LD_INT 1
102239: ARRAY
102240: PPUSH
102241: CALL_OW 247
102245: PUSH
102246: LD_INT 3
102248: EQUAL
102249: PUSH
102250: LD_VAR 0 14
102254: PUSH
102255: LD_INT 1
102257: ARRAY
102258: PUSH
102259: LD_VAR 0 27
102263: IN
102264: NOT
102265: AND
102266: IFFALSE 102473
// begin x := GetX ( tmp [ 1 ] ) ;
102268: LD_ADDR_VAR 0 10
102272: PUSH
102273: LD_VAR 0 14
102277: PUSH
102278: LD_INT 1
102280: ARRAY
102281: PPUSH
102282: CALL_OW 250
102286: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102287: LD_ADDR_VAR 0 11
102291: PUSH
102292: LD_VAR 0 14
102296: PUSH
102297: LD_INT 1
102299: ARRAY
102300: PPUSH
102301: CALL_OW 251
102305: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102306: LD_ADDR_VAR 0 12
102310: PUSH
102311: LD_VAR 0 4
102315: PUSH
102316: LD_VAR 0 7
102320: ARRAY
102321: PPUSH
102322: CALL 98181 0 1
102326: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102327: LD_VAR 0 4
102331: PUSH
102332: LD_VAR 0 7
102336: ARRAY
102337: PPUSH
102338: LD_VAR 0 10
102342: PPUSH
102343: LD_VAR 0 11
102347: PPUSH
102348: LD_VAR 0 14
102352: PUSH
102353: LD_INT 1
102355: ARRAY
102356: PPUSH
102357: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102361: LD_VAR 0 4
102365: PUSH
102366: LD_VAR 0 7
102370: ARRAY
102371: PPUSH
102372: LD_VAR 0 10
102376: PPUSH
102377: LD_VAR 0 12
102381: PPUSH
102382: LD_INT 7
102384: PPUSH
102385: CALL_OW 272
102389: PPUSH
102390: LD_VAR 0 11
102394: PPUSH
102395: LD_VAR 0 12
102399: PPUSH
102400: LD_INT 7
102402: PPUSH
102403: CALL_OW 273
102407: PPUSH
102408: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102412: LD_VAR 0 4
102416: PUSH
102417: LD_VAR 0 7
102421: ARRAY
102422: PPUSH
102423: LD_INT 71
102425: PPUSH
102426: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102430: LD_ADDR_VAR 0 27
102434: PUSH
102435: LD_VAR 0 27
102439: PPUSH
102440: LD_VAR 0 27
102444: PUSH
102445: LD_INT 1
102447: PLUS
102448: PPUSH
102449: LD_VAR 0 14
102453: PUSH
102454: LD_INT 1
102456: ARRAY
102457: PPUSH
102458: CALL_OW 1
102462: ST_TO_ADDR
// attacking := true ;
102463: LD_ADDR_VAR 0 29
102467: PUSH
102468: LD_INT 1
102470: ST_TO_ADDR
// continue ;
102471: GO 100318
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102473: LD_VAR 0 4
102477: PUSH
102478: LD_VAR 0 7
102482: ARRAY
102483: PPUSH
102484: CALL_OW 257
102488: PUSH
102489: LD_INT 17
102491: EQUAL
102492: PUSH
102493: LD_VAR 0 4
102497: PUSH
102498: LD_VAR 0 7
102502: ARRAY
102503: PPUSH
102504: CALL_OW 110
102508: PUSH
102509: LD_INT 71
102511: EQUAL
102512: NOT
102513: AND
102514: IFFALSE 102660
// begin attacking := false ;
102516: LD_ADDR_VAR 0 29
102520: PUSH
102521: LD_INT 0
102523: ST_TO_ADDR
// k := 5 ;
102524: LD_ADDR_VAR 0 9
102528: PUSH
102529: LD_INT 5
102531: ST_TO_ADDR
// if tmp < k then
102532: LD_VAR 0 14
102536: PUSH
102537: LD_VAR 0 9
102541: LESS
102542: IFFALSE 102554
// k := tmp ;
102544: LD_ADDR_VAR 0 9
102548: PUSH
102549: LD_VAR 0 14
102553: ST_TO_ADDR
// for j = 1 to k do
102554: LD_ADDR_VAR 0 8
102558: PUSH
102559: DOUBLE
102560: LD_INT 1
102562: DEC
102563: ST_TO_ADDR
102564: LD_VAR 0 9
102568: PUSH
102569: FOR_TO
102570: IFFALSE 102658
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102572: LD_VAR 0 14
102576: PUSH
102577: LD_VAR 0 8
102581: ARRAY
102582: PUSH
102583: LD_VAR 0 14
102587: PPUSH
102588: LD_INT 58
102590: PUSH
102591: EMPTY
102592: LIST
102593: PPUSH
102594: CALL_OW 72
102598: IN
102599: NOT
102600: IFFALSE 102656
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102602: LD_VAR 0 4
102606: PUSH
102607: LD_VAR 0 7
102611: ARRAY
102612: PPUSH
102613: LD_VAR 0 14
102617: PUSH
102618: LD_VAR 0 8
102622: ARRAY
102623: PPUSH
102624: CALL_OW 115
// attacking := true ;
102628: LD_ADDR_VAR 0 29
102632: PUSH
102633: LD_INT 1
102635: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102636: LD_VAR 0 4
102640: PUSH
102641: LD_VAR 0 7
102645: ARRAY
102646: PPUSH
102647: LD_INT 71
102649: PPUSH
102650: CALL_OW 109
// continue ;
102654: GO 102569
// end ; end ;
102656: GO 102569
102658: POP
102659: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102660: LD_VAR 0 4
102664: PUSH
102665: LD_VAR 0 7
102669: ARRAY
102670: PPUSH
102671: CALL_OW 257
102675: PUSH
102676: LD_INT 8
102678: EQUAL
102679: PUSH
102680: LD_VAR 0 4
102684: PUSH
102685: LD_VAR 0 7
102689: ARRAY
102690: PPUSH
102691: CALL_OW 264
102695: PUSH
102696: LD_INT 28
102698: PUSH
102699: LD_INT 45
102701: PUSH
102702: LD_INT 7
102704: PUSH
102705: LD_INT 47
102707: PUSH
102708: EMPTY
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: IN
102714: OR
102715: IFFALSE 102945
// begin attacking := false ;
102717: LD_ADDR_VAR 0 29
102721: PUSH
102722: LD_INT 0
102724: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102725: LD_VAR 0 14
102729: PUSH
102730: LD_INT 1
102732: ARRAY
102733: PPUSH
102734: CALL_OW 266
102738: PUSH
102739: LD_INT 32
102741: PUSH
102742: LD_INT 31
102744: PUSH
102745: LD_INT 33
102747: PUSH
102748: LD_INT 4
102750: PUSH
102751: LD_INT 5
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: LIST
102758: LIST
102759: LIST
102760: IN
102761: IFFALSE 102945
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102763: LD_ADDR_VAR 0 9
102767: PUSH
102768: LD_VAR 0 14
102772: PUSH
102773: LD_INT 1
102775: ARRAY
102776: PPUSH
102777: CALL_OW 266
102781: PPUSH
102782: LD_VAR 0 14
102786: PUSH
102787: LD_INT 1
102789: ARRAY
102790: PPUSH
102791: CALL_OW 250
102795: PPUSH
102796: LD_VAR 0 14
102800: PUSH
102801: LD_INT 1
102803: ARRAY
102804: PPUSH
102805: CALL_OW 251
102809: PPUSH
102810: LD_VAR 0 14
102814: PUSH
102815: LD_INT 1
102817: ARRAY
102818: PPUSH
102819: CALL_OW 254
102823: PPUSH
102824: LD_VAR 0 14
102828: PUSH
102829: LD_INT 1
102831: ARRAY
102832: PPUSH
102833: CALL_OW 248
102837: PPUSH
102838: LD_INT 0
102840: PPUSH
102841: CALL 79551 0 6
102845: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102846: LD_ADDR_VAR 0 8
102850: PUSH
102851: LD_VAR 0 4
102855: PUSH
102856: LD_VAR 0 7
102860: ARRAY
102861: PPUSH
102862: LD_VAR 0 9
102866: PPUSH
102867: CALL 98244 0 2
102871: ST_TO_ADDR
// if j then
102872: LD_VAR 0 8
102876: IFFALSE 102945
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102878: LD_VAR 0 8
102882: PUSH
102883: LD_INT 1
102885: ARRAY
102886: PPUSH
102887: LD_VAR 0 8
102891: PUSH
102892: LD_INT 2
102894: ARRAY
102895: PPUSH
102896: CALL_OW 488
102900: IFFALSE 102945
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102902: LD_VAR 0 4
102906: PUSH
102907: LD_VAR 0 7
102911: ARRAY
102912: PPUSH
102913: LD_VAR 0 8
102917: PUSH
102918: LD_INT 1
102920: ARRAY
102921: PPUSH
102922: LD_VAR 0 8
102926: PUSH
102927: LD_INT 2
102929: ARRAY
102930: PPUSH
102931: CALL_OW 116
// attacking := true ;
102935: LD_ADDR_VAR 0 29
102939: PUSH
102940: LD_INT 1
102942: ST_TO_ADDR
// continue ;
102943: GO 100318
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102945: LD_VAR 0 4
102949: PUSH
102950: LD_VAR 0 7
102954: ARRAY
102955: PPUSH
102956: CALL_OW 265
102960: PUSH
102961: LD_INT 11
102963: EQUAL
102964: IFFALSE 103242
// begin k := 10 ;
102966: LD_ADDR_VAR 0 9
102970: PUSH
102971: LD_INT 10
102973: ST_TO_ADDR
// x := 0 ;
102974: LD_ADDR_VAR 0 10
102978: PUSH
102979: LD_INT 0
102981: ST_TO_ADDR
// if tmp < k then
102982: LD_VAR 0 14
102986: PUSH
102987: LD_VAR 0 9
102991: LESS
102992: IFFALSE 103004
// k := tmp ;
102994: LD_ADDR_VAR 0 9
102998: PUSH
102999: LD_VAR 0 14
103003: ST_TO_ADDR
// for j = k downto 1 do
103004: LD_ADDR_VAR 0 8
103008: PUSH
103009: DOUBLE
103010: LD_VAR 0 9
103014: INC
103015: ST_TO_ADDR
103016: LD_INT 1
103018: PUSH
103019: FOR_DOWNTO
103020: IFFALSE 103095
// begin if GetType ( tmp [ j ] ) = unit_human then
103022: LD_VAR 0 14
103026: PUSH
103027: LD_VAR 0 8
103031: ARRAY
103032: PPUSH
103033: CALL_OW 247
103037: PUSH
103038: LD_INT 1
103040: EQUAL
103041: IFFALSE 103093
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103043: LD_VAR 0 4
103047: PUSH
103048: LD_VAR 0 7
103052: ARRAY
103053: PPUSH
103054: LD_VAR 0 14
103058: PUSH
103059: LD_VAR 0 8
103063: ARRAY
103064: PPUSH
103065: CALL 98515 0 2
// x := tmp [ j ] ;
103069: LD_ADDR_VAR 0 10
103073: PUSH
103074: LD_VAR 0 14
103078: PUSH
103079: LD_VAR 0 8
103083: ARRAY
103084: ST_TO_ADDR
// attacking := true ;
103085: LD_ADDR_VAR 0 29
103089: PUSH
103090: LD_INT 1
103092: ST_TO_ADDR
// end ; end ;
103093: GO 103019
103095: POP
103096: POP
// if not x then
103097: LD_VAR 0 10
103101: NOT
103102: IFFALSE 103242
// begin attacking := true ;
103104: LD_ADDR_VAR 0 29
103108: PUSH
103109: LD_INT 1
103111: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103112: LD_VAR 0 4
103116: PUSH
103117: LD_VAR 0 7
103121: ARRAY
103122: PPUSH
103123: CALL_OW 250
103127: PPUSH
103128: LD_VAR 0 4
103132: PUSH
103133: LD_VAR 0 7
103137: ARRAY
103138: PPUSH
103139: CALL_OW 251
103143: PPUSH
103144: CALL_OW 546
103148: PUSH
103149: LD_INT 2
103151: ARRAY
103152: PUSH
103153: LD_VAR 0 14
103157: PUSH
103158: LD_INT 1
103160: ARRAY
103161: PPUSH
103162: CALL_OW 250
103166: PPUSH
103167: LD_VAR 0 14
103171: PUSH
103172: LD_INT 1
103174: ARRAY
103175: PPUSH
103176: CALL_OW 251
103180: PPUSH
103181: CALL_OW 546
103185: PUSH
103186: LD_INT 2
103188: ARRAY
103189: EQUAL
103190: IFFALSE 103218
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103192: LD_VAR 0 4
103196: PUSH
103197: LD_VAR 0 7
103201: ARRAY
103202: PPUSH
103203: LD_VAR 0 14
103207: PUSH
103208: LD_INT 1
103210: ARRAY
103211: PPUSH
103212: CALL 98515 0 2
103216: GO 103242
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103218: LD_VAR 0 4
103222: PUSH
103223: LD_VAR 0 7
103227: ARRAY
103228: PPUSH
103229: LD_VAR 0 14
103233: PUSH
103234: LD_INT 1
103236: ARRAY
103237: PPUSH
103238: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103242: LD_VAR 0 4
103246: PUSH
103247: LD_VAR 0 7
103251: ARRAY
103252: PPUSH
103253: CALL_OW 264
103257: PUSH
103258: LD_INT 29
103260: EQUAL
103261: IFFALSE 103627
// begin if WantsToAttack ( group [ i ] ) in bombed then
103263: LD_VAR 0 4
103267: PUSH
103268: LD_VAR 0 7
103272: ARRAY
103273: PPUSH
103274: CALL_OW 319
103278: PUSH
103279: LD_VAR 0 28
103283: IN
103284: IFFALSE 103288
// continue ;
103286: GO 100318
// k := 8 ;
103288: LD_ADDR_VAR 0 9
103292: PUSH
103293: LD_INT 8
103295: ST_TO_ADDR
// x := 0 ;
103296: LD_ADDR_VAR 0 10
103300: PUSH
103301: LD_INT 0
103303: ST_TO_ADDR
// if tmp < k then
103304: LD_VAR 0 14
103308: PUSH
103309: LD_VAR 0 9
103313: LESS
103314: IFFALSE 103326
// k := tmp ;
103316: LD_ADDR_VAR 0 9
103320: PUSH
103321: LD_VAR 0 14
103325: ST_TO_ADDR
// for j = 1 to k do
103326: LD_ADDR_VAR 0 8
103330: PUSH
103331: DOUBLE
103332: LD_INT 1
103334: DEC
103335: ST_TO_ADDR
103336: LD_VAR 0 9
103340: PUSH
103341: FOR_TO
103342: IFFALSE 103474
// begin if GetType ( tmp [ j ] ) = unit_building then
103344: LD_VAR 0 14
103348: PUSH
103349: LD_VAR 0 8
103353: ARRAY
103354: PPUSH
103355: CALL_OW 247
103359: PUSH
103360: LD_INT 3
103362: EQUAL
103363: IFFALSE 103472
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103365: LD_VAR 0 14
103369: PUSH
103370: LD_VAR 0 8
103374: ARRAY
103375: PUSH
103376: LD_VAR 0 28
103380: IN
103381: NOT
103382: PUSH
103383: LD_VAR 0 14
103387: PUSH
103388: LD_VAR 0 8
103392: ARRAY
103393: PPUSH
103394: CALL_OW 313
103398: AND
103399: IFFALSE 103472
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103401: LD_VAR 0 4
103405: PUSH
103406: LD_VAR 0 7
103410: ARRAY
103411: PPUSH
103412: LD_VAR 0 14
103416: PUSH
103417: LD_VAR 0 8
103421: ARRAY
103422: PPUSH
103423: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103427: LD_ADDR_VAR 0 28
103431: PUSH
103432: LD_VAR 0 28
103436: PPUSH
103437: LD_VAR 0 28
103441: PUSH
103442: LD_INT 1
103444: PLUS
103445: PPUSH
103446: LD_VAR 0 14
103450: PUSH
103451: LD_VAR 0 8
103455: ARRAY
103456: PPUSH
103457: CALL_OW 1
103461: ST_TO_ADDR
// attacking := true ;
103462: LD_ADDR_VAR 0 29
103466: PUSH
103467: LD_INT 1
103469: ST_TO_ADDR
// break ;
103470: GO 103474
// end ; end ;
103472: GO 103341
103474: POP
103475: POP
// if not attacking and f_attack_depot then
103476: LD_VAR 0 29
103480: NOT
103481: PUSH
103482: LD_VAR 0 25
103486: AND
103487: IFFALSE 103582
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103489: LD_ADDR_VAR 0 13
103493: PUSH
103494: LD_VAR 0 14
103498: PPUSH
103499: LD_INT 2
103501: PUSH
103502: LD_INT 30
103504: PUSH
103505: LD_INT 0
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: PUSH
103512: LD_INT 30
103514: PUSH
103515: LD_INT 1
103517: PUSH
103518: EMPTY
103519: LIST
103520: LIST
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: PPUSH
103527: CALL_OW 72
103531: ST_TO_ADDR
// if z then
103532: LD_VAR 0 13
103536: IFFALSE 103582
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103538: LD_VAR 0 4
103542: PUSH
103543: LD_VAR 0 7
103547: ARRAY
103548: PPUSH
103549: LD_VAR 0 13
103553: PPUSH
103554: LD_VAR 0 4
103558: PUSH
103559: LD_VAR 0 7
103563: ARRAY
103564: PPUSH
103565: CALL_OW 74
103569: PPUSH
103570: CALL_OW 115
// attacking := true ;
103574: LD_ADDR_VAR 0 29
103578: PUSH
103579: LD_INT 1
103581: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103582: LD_VAR 0 4
103586: PUSH
103587: LD_VAR 0 7
103591: ARRAY
103592: PPUSH
103593: CALL_OW 256
103597: PUSH
103598: LD_INT 500
103600: LESS
103601: IFFALSE 103627
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103603: LD_VAR 0 4
103607: PUSH
103608: LD_VAR 0 7
103612: ARRAY
103613: PPUSH
103614: LD_VAR 0 14
103618: PUSH
103619: LD_INT 1
103621: ARRAY
103622: PPUSH
103623: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103627: LD_VAR 0 4
103631: PUSH
103632: LD_VAR 0 7
103636: ARRAY
103637: PPUSH
103638: CALL_OW 264
103642: PUSH
103643: LD_INT 49
103645: EQUAL
103646: IFFALSE 103767
// begin if not HasTask ( group [ i ] ) then
103648: LD_VAR 0 4
103652: PUSH
103653: LD_VAR 0 7
103657: ARRAY
103658: PPUSH
103659: CALL_OW 314
103663: NOT
103664: IFFALSE 103767
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103666: LD_ADDR_VAR 0 9
103670: PUSH
103671: LD_INT 81
103673: PUSH
103674: LD_VAR 0 4
103678: PUSH
103679: LD_VAR 0 7
103683: ARRAY
103684: PPUSH
103685: CALL_OW 255
103689: PUSH
103690: EMPTY
103691: LIST
103692: LIST
103693: PPUSH
103694: CALL_OW 69
103698: PPUSH
103699: LD_VAR 0 4
103703: PUSH
103704: LD_VAR 0 7
103708: ARRAY
103709: PPUSH
103710: CALL_OW 74
103714: ST_TO_ADDR
// if k then
103715: LD_VAR 0 9
103719: IFFALSE 103767
// if GetDistUnits ( group [ i ] , k ) > 10 then
103721: LD_VAR 0 4
103725: PUSH
103726: LD_VAR 0 7
103730: ARRAY
103731: PPUSH
103732: LD_VAR 0 9
103736: PPUSH
103737: CALL_OW 296
103741: PUSH
103742: LD_INT 10
103744: GREATER
103745: IFFALSE 103767
// ComMoveUnit ( group [ i ] , k ) ;
103747: LD_VAR 0 4
103751: PUSH
103752: LD_VAR 0 7
103756: ARRAY
103757: PPUSH
103758: LD_VAR 0 9
103762: PPUSH
103763: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103767: LD_VAR 0 4
103771: PUSH
103772: LD_VAR 0 7
103776: ARRAY
103777: PPUSH
103778: CALL_OW 256
103782: PUSH
103783: LD_INT 250
103785: LESS
103786: PUSH
103787: LD_VAR 0 4
103791: PUSH
103792: LD_VAR 0 7
103796: ARRAY
103797: PUSH
103798: LD_INT 21
103800: PUSH
103801: LD_INT 2
103803: PUSH
103804: EMPTY
103805: LIST
103806: LIST
103807: PUSH
103808: LD_INT 23
103810: PUSH
103811: LD_INT 2
103813: PUSH
103814: EMPTY
103815: LIST
103816: LIST
103817: PUSH
103818: EMPTY
103819: LIST
103820: LIST
103821: PPUSH
103822: CALL_OW 69
103826: IN
103827: AND
103828: IFFALSE 103953
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103830: LD_ADDR_VAR 0 9
103834: PUSH
103835: LD_OWVAR 3
103839: PUSH
103840: LD_VAR 0 4
103844: PUSH
103845: LD_VAR 0 7
103849: ARRAY
103850: DIFF
103851: PPUSH
103852: LD_VAR 0 4
103856: PUSH
103857: LD_VAR 0 7
103861: ARRAY
103862: PPUSH
103863: CALL_OW 74
103867: ST_TO_ADDR
// if not k then
103868: LD_VAR 0 9
103872: NOT
103873: IFFALSE 103877
// continue ;
103875: GO 100318
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103877: LD_VAR 0 9
103881: PUSH
103882: LD_INT 81
103884: PUSH
103885: LD_VAR 0 4
103889: PUSH
103890: LD_VAR 0 7
103894: ARRAY
103895: PPUSH
103896: CALL_OW 255
103900: PUSH
103901: EMPTY
103902: LIST
103903: LIST
103904: PPUSH
103905: CALL_OW 69
103909: IN
103910: PUSH
103911: LD_VAR 0 9
103915: PPUSH
103916: LD_VAR 0 4
103920: PUSH
103921: LD_VAR 0 7
103925: ARRAY
103926: PPUSH
103927: CALL_OW 296
103931: PUSH
103932: LD_INT 5
103934: LESS
103935: AND
103936: IFFALSE 103953
// ComAutodestruct ( group [ i ] ) ;
103938: LD_VAR 0 4
103942: PUSH
103943: LD_VAR 0 7
103947: ARRAY
103948: PPUSH
103949: CALL 98413 0 1
// end ; if f_attack_depot then
103953: LD_VAR 0 25
103957: IFFALSE 104069
// begin k := 6 ;
103959: LD_ADDR_VAR 0 9
103963: PUSH
103964: LD_INT 6
103966: ST_TO_ADDR
// if tmp < k then
103967: LD_VAR 0 14
103971: PUSH
103972: LD_VAR 0 9
103976: LESS
103977: IFFALSE 103989
// k := tmp ;
103979: LD_ADDR_VAR 0 9
103983: PUSH
103984: LD_VAR 0 14
103988: ST_TO_ADDR
// for j = 1 to k do
103989: LD_ADDR_VAR 0 8
103993: PUSH
103994: DOUBLE
103995: LD_INT 1
103997: DEC
103998: ST_TO_ADDR
103999: LD_VAR 0 9
104003: PUSH
104004: FOR_TO
104005: IFFALSE 104067
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104007: LD_VAR 0 8
104011: PPUSH
104012: CALL_OW 266
104016: PUSH
104017: LD_INT 0
104019: PUSH
104020: LD_INT 1
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: IN
104027: IFFALSE 104065
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104029: LD_VAR 0 4
104033: PUSH
104034: LD_VAR 0 7
104038: ARRAY
104039: PPUSH
104040: LD_VAR 0 14
104044: PUSH
104045: LD_VAR 0 8
104049: ARRAY
104050: PPUSH
104051: CALL_OW 115
// attacking := true ;
104055: LD_ADDR_VAR 0 29
104059: PUSH
104060: LD_INT 1
104062: ST_TO_ADDR
// break ;
104063: GO 104067
// end ;
104065: GO 104004
104067: POP
104068: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104069: LD_VAR 0 4
104073: PUSH
104074: LD_VAR 0 7
104078: ARRAY
104079: PPUSH
104080: CALL_OW 302
104084: PUSH
104085: LD_VAR 0 29
104089: NOT
104090: AND
104091: IFFALSE 104413
// begin if GetTag ( group [ i ] ) = 71 then
104093: LD_VAR 0 4
104097: PUSH
104098: LD_VAR 0 7
104102: ARRAY
104103: PPUSH
104104: CALL_OW 110
104108: PUSH
104109: LD_INT 71
104111: EQUAL
104112: IFFALSE 104153
// begin if HasTask ( group [ i ] ) then
104114: LD_VAR 0 4
104118: PUSH
104119: LD_VAR 0 7
104123: ARRAY
104124: PPUSH
104125: CALL_OW 314
104129: IFFALSE 104135
// continue else
104131: GO 100318
104133: GO 104153
// SetTag ( group [ i ] , 0 ) ;
104135: LD_VAR 0 4
104139: PUSH
104140: LD_VAR 0 7
104144: ARRAY
104145: PPUSH
104146: LD_INT 0
104148: PPUSH
104149: CALL_OW 109
// end ; k := 8 ;
104153: LD_ADDR_VAR 0 9
104157: PUSH
104158: LD_INT 8
104160: ST_TO_ADDR
// x := 0 ;
104161: LD_ADDR_VAR 0 10
104165: PUSH
104166: LD_INT 0
104168: ST_TO_ADDR
// if tmp < k then
104169: LD_VAR 0 14
104173: PUSH
104174: LD_VAR 0 9
104178: LESS
104179: IFFALSE 104191
// k := tmp ;
104181: LD_ADDR_VAR 0 9
104185: PUSH
104186: LD_VAR 0 14
104190: ST_TO_ADDR
// for j = 1 to k do
104191: LD_ADDR_VAR 0 8
104195: PUSH
104196: DOUBLE
104197: LD_INT 1
104199: DEC
104200: ST_TO_ADDR
104201: LD_VAR 0 9
104205: PUSH
104206: FOR_TO
104207: IFFALSE 104305
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104209: LD_VAR 0 14
104213: PUSH
104214: LD_VAR 0 8
104218: ARRAY
104219: PPUSH
104220: CALL_OW 247
104224: PUSH
104225: LD_INT 1
104227: EQUAL
104228: PUSH
104229: LD_VAR 0 14
104233: PUSH
104234: LD_VAR 0 8
104238: ARRAY
104239: PPUSH
104240: CALL_OW 256
104244: PUSH
104245: LD_INT 250
104247: LESS
104248: PUSH
104249: LD_VAR 0 20
104253: AND
104254: PUSH
104255: LD_VAR 0 20
104259: NOT
104260: PUSH
104261: LD_VAR 0 14
104265: PUSH
104266: LD_VAR 0 8
104270: ARRAY
104271: PPUSH
104272: CALL_OW 256
104276: PUSH
104277: LD_INT 250
104279: GREATEREQUAL
104280: AND
104281: OR
104282: AND
104283: IFFALSE 104303
// begin x := tmp [ j ] ;
104285: LD_ADDR_VAR 0 10
104289: PUSH
104290: LD_VAR 0 14
104294: PUSH
104295: LD_VAR 0 8
104299: ARRAY
104300: ST_TO_ADDR
// break ;
104301: GO 104305
// end ;
104303: GO 104206
104305: POP
104306: POP
// if x then
104307: LD_VAR 0 10
104311: IFFALSE 104335
// ComAttackUnit ( group [ i ] , x ) else
104313: LD_VAR 0 4
104317: PUSH
104318: LD_VAR 0 7
104322: ARRAY
104323: PPUSH
104324: LD_VAR 0 10
104328: PPUSH
104329: CALL_OW 115
104333: GO 104359
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104335: LD_VAR 0 4
104339: PUSH
104340: LD_VAR 0 7
104344: ARRAY
104345: PPUSH
104346: LD_VAR 0 14
104350: PUSH
104351: LD_INT 1
104353: ARRAY
104354: PPUSH
104355: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104359: LD_VAR 0 4
104363: PUSH
104364: LD_VAR 0 7
104368: ARRAY
104369: PPUSH
104370: CALL_OW 314
104374: NOT
104375: IFFALSE 104413
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104377: LD_VAR 0 4
104381: PUSH
104382: LD_VAR 0 7
104386: ARRAY
104387: PPUSH
104388: LD_VAR 0 14
104392: PPUSH
104393: LD_VAR 0 4
104397: PUSH
104398: LD_VAR 0 7
104402: ARRAY
104403: PPUSH
104404: CALL_OW 74
104408: PPUSH
104409: CALL_OW 115
// end ; end ; end ;
104413: GO 100318
104415: POP
104416: POP
// wait ( 0 0$1 ) ;
104417: LD_INT 35
104419: PPUSH
104420: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104424: LD_VAR 0 4
104428: PUSH
104429: EMPTY
104430: EQUAL
104431: PUSH
104432: LD_INT 81
104434: PUSH
104435: LD_VAR 0 35
104439: PUSH
104440: EMPTY
104441: LIST
104442: LIST
104443: PPUSH
104444: CALL_OW 69
104448: NOT
104449: OR
104450: IFFALSE 100303
// end ;
104452: LD_VAR 0 2
104456: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104457: LD_INT 0
104459: PPUSH
104460: PPUSH
104461: PPUSH
104462: PPUSH
// if not base_units then
104463: LD_VAR 0 1
104467: NOT
104468: IFFALSE 104472
// exit ;
104470: GO 104559
// result := false ;
104472: LD_ADDR_VAR 0 2
104476: PUSH
104477: LD_INT 0
104479: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104480: LD_ADDR_VAR 0 5
104484: PUSH
104485: LD_VAR 0 1
104489: PPUSH
104490: LD_INT 21
104492: PUSH
104493: LD_INT 3
104495: PUSH
104496: EMPTY
104497: LIST
104498: LIST
104499: PPUSH
104500: CALL_OW 72
104504: ST_TO_ADDR
// if not tmp then
104505: LD_VAR 0 5
104509: NOT
104510: IFFALSE 104514
// exit ;
104512: GO 104559
// for i in tmp do
104514: LD_ADDR_VAR 0 3
104518: PUSH
104519: LD_VAR 0 5
104523: PUSH
104524: FOR_IN
104525: IFFALSE 104557
// begin result := EnemyInRange ( i , 22 ) ;
104527: LD_ADDR_VAR 0 2
104531: PUSH
104532: LD_VAR 0 3
104536: PPUSH
104537: LD_INT 22
104539: PPUSH
104540: CALL 98096 0 2
104544: ST_TO_ADDR
// if result then
104545: LD_VAR 0 2
104549: IFFALSE 104555
// exit ;
104551: POP
104552: POP
104553: GO 104559
// end ;
104555: GO 104524
104557: POP
104558: POP
// end ;
104559: LD_VAR 0 2
104563: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104564: LD_INT 0
104566: PPUSH
104567: PPUSH
// if not units then
104568: LD_VAR 0 1
104572: NOT
104573: IFFALSE 104577
// exit ;
104575: GO 104647
// result := [ ] ;
104577: LD_ADDR_VAR 0 3
104581: PUSH
104582: EMPTY
104583: ST_TO_ADDR
// for i in units do
104584: LD_ADDR_VAR 0 4
104588: PUSH
104589: LD_VAR 0 1
104593: PUSH
104594: FOR_IN
104595: IFFALSE 104645
// if GetTag ( i ) = tag then
104597: LD_VAR 0 4
104601: PPUSH
104602: CALL_OW 110
104606: PUSH
104607: LD_VAR 0 2
104611: EQUAL
104612: IFFALSE 104643
// result := Insert ( result , result + 1 , i ) ;
104614: LD_ADDR_VAR 0 3
104618: PUSH
104619: LD_VAR 0 3
104623: PPUSH
104624: LD_VAR 0 3
104628: PUSH
104629: LD_INT 1
104631: PLUS
104632: PPUSH
104633: LD_VAR 0 4
104637: PPUSH
104638: CALL_OW 2
104642: ST_TO_ADDR
104643: GO 104594
104645: POP
104646: POP
// end ;
104647: LD_VAR 0 3
104651: RET
// export function IsDriver ( un ) ; begin
104652: LD_INT 0
104654: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104655: LD_ADDR_VAR 0 2
104659: PUSH
104660: LD_VAR 0 1
104664: PUSH
104665: LD_INT 55
104667: PUSH
104668: EMPTY
104669: LIST
104670: PPUSH
104671: CALL_OW 69
104675: IN
104676: ST_TO_ADDR
// end ;
104677: LD_VAR 0 2
104681: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104682: LD_INT 0
104684: PPUSH
104685: PPUSH
// list := [ ] ;
104686: LD_ADDR_VAR 0 5
104690: PUSH
104691: EMPTY
104692: ST_TO_ADDR
// case d of 0 :
104693: LD_VAR 0 3
104697: PUSH
104698: LD_INT 0
104700: DOUBLE
104701: EQUAL
104702: IFTRUE 104706
104704: GO 104839
104706: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104707: LD_ADDR_VAR 0 5
104711: PUSH
104712: LD_VAR 0 1
104716: PUSH
104717: LD_INT 4
104719: MINUS
104720: PUSH
104721: LD_VAR 0 2
104725: PUSH
104726: LD_INT 4
104728: MINUS
104729: PUSH
104730: LD_INT 2
104732: PUSH
104733: EMPTY
104734: LIST
104735: LIST
104736: LIST
104737: PUSH
104738: LD_VAR 0 1
104742: PUSH
104743: LD_INT 3
104745: MINUS
104746: PUSH
104747: LD_VAR 0 2
104751: PUSH
104752: LD_INT 1
104754: PUSH
104755: EMPTY
104756: LIST
104757: LIST
104758: LIST
104759: PUSH
104760: LD_VAR 0 1
104764: PUSH
104765: LD_INT 4
104767: PLUS
104768: PUSH
104769: LD_VAR 0 2
104773: PUSH
104774: LD_INT 4
104776: PUSH
104777: EMPTY
104778: LIST
104779: LIST
104780: LIST
104781: PUSH
104782: LD_VAR 0 1
104786: PUSH
104787: LD_INT 3
104789: PLUS
104790: PUSH
104791: LD_VAR 0 2
104795: PUSH
104796: LD_INT 3
104798: PLUS
104799: PUSH
104800: LD_INT 5
104802: PUSH
104803: EMPTY
104804: LIST
104805: LIST
104806: LIST
104807: PUSH
104808: LD_VAR 0 1
104812: PUSH
104813: LD_VAR 0 2
104817: PUSH
104818: LD_INT 4
104820: PLUS
104821: PUSH
104822: LD_INT 0
104824: PUSH
104825: EMPTY
104826: LIST
104827: LIST
104828: LIST
104829: PUSH
104830: EMPTY
104831: LIST
104832: LIST
104833: LIST
104834: LIST
104835: LIST
104836: ST_TO_ADDR
// end ; 1 :
104837: GO 105537
104839: LD_INT 1
104841: DOUBLE
104842: EQUAL
104843: IFTRUE 104847
104845: GO 104980
104847: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104848: LD_ADDR_VAR 0 5
104852: PUSH
104853: LD_VAR 0 1
104857: PUSH
104858: LD_VAR 0 2
104862: PUSH
104863: LD_INT 4
104865: MINUS
104866: PUSH
104867: LD_INT 3
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: LIST
104874: PUSH
104875: LD_VAR 0 1
104879: PUSH
104880: LD_INT 3
104882: MINUS
104883: PUSH
104884: LD_VAR 0 2
104888: PUSH
104889: LD_INT 3
104891: MINUS
104892: PUSH
104893: LD_INT 2
104895: PUSH
104896: EMPTY
104897: LIST
104898: LIST
104899: LIST
104900: PUSH
104901: LD_VAR 0 1
104905: PUSH
104906: LD_INT 4
104908: MINUS
104909: PUSH
104910: LD_VAR 0 2
104914: PUSH
104915: LD_INT 1
104917: PUSH
104918: EMPTY
104919: LIST
104920: LIST
104921: LIST
104922: PUSH
104923: LD_VAR 0 1
104927: PUSH
104928: LD_VAR 0 2
104932: PUSH
104933: LD_INT 3
104935: PLUS
104936: PUSH
104937: LD_INT 0
104939: PUSH
104940: EMPTY
104941: LIST
104942: LIST
104943: LIST
104944: PUSH
104945: LD_VAR 0 1
104949: PUSH
104950: LD_INT 4
104952: PLUS
104953: PUSH
104954: LD_VAR 0 2
104958: PUSH
104959: LD_INT 4
104961: PLUS
104962: PUSH
104963: LD_INT 5
104965: PUSH
104966: EMPTY
104967: LIST
104968: LIST
104969: LIST
104970: PUSH
104971: EMPTY
104972: LIST
104973: LIST
104974: LIST
104975: LIST
104976: LIST
104977: ST_TO_ADDR
// end ; 2 :
104978: GO 105537
104980: LD_INT 2
104982: DOUBLE
104983: EQUAL
104984: IFTRUE 104988
104986: GO 105117
104988: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104989: LD_ADDR_VAR 0 5
104993: PUSH
104994: LD_VAR 0 1
104998: PUSH
104999: LD_VAR 0 2
105003: PUSH
105004: LD_INT 3
105006: MINUS
105007: PUSH
105008: LD_INT 3
105010: PUSH
105011: EMPTY
105012: LIST
105013: LIST
105014: LIST
105015: PUSH
105016: LD_VAR 0 1
105020: PUSH
105021: LD_INT 4
105023: PLUS
105024: PUSH
105025: LD_VAR 0 2
105029: PUSH
105030: LD_INT 4
105032: PUSH
105033: EMPTY
105034: LIST
105035: LIST
105036: LIST
105037: PUSH
105038: LD_VAR 0 1
105042: PUSH
105043: LD_VAR 0 2
105047: PUSH
105048: LD_INT 4
105050: PLUS
105051: PUSH
105052: LD_INT 0
105054: PUSH
105055: EMPTY
105056: LIST
105057: LIST
105058: LIST
105059: PUSH
105060: LD_VAR 0 1
105064: PUSH
105065: LD_INT 3
105067: MINUS
105068: PUSH
105069: LD_VAR 0 2
105073: PUSH
105074: LD_INT 1
105076: PUSH
105077: EMPTY
105078: LIST
105079: LIST
105080: LIST
105081: PUSH
105082: LD_VAR 0 1
105086: PUSH
105087: LD_INT 4
105089: MINUS
105090: PUSH
105091: LD_VAR 0 2
105095: PUSH
105096: LD_INT 4
105098: MINUS
105099: PUSH
105100: LD_INT 2
105102: PUSH
105103: EMPTY
105104: LIST
105105: LIST
105106: LIST
105107: PUSH
105108: EMPTY
105109: LIST
105110: LIST
105111: LIST
105112: LIST
105113: LIST
105114: ST_TO_ADDR
// end ; 3 :
105115: GO 105537
105117: LD_INT 3
105119: DOUBLE
105120: EQUAL
105121: IFTRUE 105125
105123: GO 105258
105125: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105126: LD_ADDR_VAR 0 5
105130: PUSH
105131: LD_VAR 0 1
105135: PUSH
105136: LD_INT 3
105138: PLUS
105139: PUSH
105140: LD_VAR 0 2
105144: PUSH
105145: LD_INT 4
105147: PUSH
105148: EMPTY
105149: LIST
105150: LIST
105151: LIST
105152: PUSH
105153: LD_VAR 0 1
105157: PUSH
105158: LD_INT 4
105160: PLUS
105161: PUSH
105162: LD_VAR 0 2
105166: PUSH
105167: LD_INT 4
105169: PLUS
105170: PUSH
105171: LD_INT 5
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: LIST
105178: PUSH
105179: LD_VAR 0 1
105183: PUSH
105184: LD_INT 4
105186: MINUS
105187: PUSH
105188: LD_VAR 0 2
105192: PUSH
105193: LD_INT 1
105195: PUSH
105196: EMPTY
105197: LIST
105198: LIST
105199: LIST
105200: PUSH
105201: LD_VAR 0 1
105205: PUSH
105206: LD_VAR 0 2
105210: PUSH
105211: LD_INT 4
105213: MINUS
105214: PUSH
105215: LD_INT 3
105217: PUSH
105218: EMPTY
105219: LIST
105220: LIST
105221: LIST
105222: PUSH
105223: LD_VAR 0 1
105227: PUSH
105228: LD_INT 3
105230: MINUS
105231: PUSH
105232: LD_VAR 0 2
105236: PUSH
105237: LD_INT 3
105239: MINUS
105240: PUSH
105241: LD_INT 2
105243: PUSH
105244: EMPTY
105245: LIST
105246: LIST
105247: LIST
105248: PUSH
105249: EMPTY
105250: LIST
105251: LIST
105252: LIST
105253: LIST
105254: LIST
105255: ST_TO_ADDR
// end ; 4 :
105256: GO 105537
105258: LD_INT 4
105260: DOUBLE
105261: EQUAL
105262: IFTRUE 105266
105264: GO 105399
105266: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105267: LD_ADDR_VAR 0 5
105271: PUSH
105272: LD_VAR 0 1
105276: PUSH
105277: LD_VAR 0 2
105281: PUSH
105282: LD_INT 4
105284: PLUS
105285: PUSH
105286: LD_INT 0
105288: PUSH
105289: EMPTY
105290: LIST
105291: LIST
105292: LIST
105293: PUSH
105294: LD_VAR 0 1
105298: PUSH
105299: LD_INT 3
105301: PLUS
105302: PUSH
105303: LD_VAR 0 2
105307: PUSH
105308: LD_INT 3
105310: PLUS
105311: PUSH
105312: LD_INT 5
105314: PUSH
105315: EMPTY
105316: LIST
105317: LIST
105318: LIST
105319: PUSH
105320: LD_VAR 0 1
105324: PUSH
105325: LD_INT 4
105327: PLUS
105328: PUSH
105329: LD_VAR 0 2
105333: PUSH
105334: LD_INT 4
105336: PUSH
105337: EMPTY
105338: LIST
105339: LIST
105340: LIST
105341: PUSH
105342: LD_VAR 0 1
105346: PUSH
105347: LD_VAR 0 2
105351: PUSH
105352: LD_INT 3
105354: MINUS
105355: PUSH
105356: LD_INT 3
105358: PUSH
105359: EMPTY
105360: LIST
105361: LIST
105362: LIST
105363: PUSH
105364: LD_VAR 0 1
105368: PUSH
105369: LD_INT 4
105371: MINUS
105372: PUSH
105373: LD_VAR 0 2
105377: PUSH
105378: LD_INT 4
105380: MINUS
105381: PUSH
105382: LD_INT 2
105384: PUSH
105385: EMPTY
105386: LIST
105387: LIST
105388: LIST
105389: PUSH
105390: EMPTY
105391: LIST
105392: LIST
105393: LIST
105394: LIST
105395: LIST
105396: ST_TO_ADDR
// end ; 5 :
105397: GO 105537
105399: LD_INT 5
105401: DOUBLE
105402: EQUAL
105403: IFTRUE 105407
105405: GO 105536
105407: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105408: LD_ADDR_VAR 0 5
105412: PUSH
105413: LD_VAR 0 1
105417: PUSH
105418: LD_INT 4
105420: MINUS
105421: PUSH
105422: LD_VAR 0 2
105426: PUSH
105427: LD_INT 1
105429: PUSH
105430: EMPTY
105431: LIST
105432: LIST
105433: LIST
105434: PUSH
105435: LD_VAR 0 1
105439: PUSH
105440: LD_VAR 0 2
105444: PUSH
105445: LD_INT 4
105447: MINUS
105448: PUSH
105449: LD_INT 3
105451: PUSH
105452: EMPTY
105453: LIST
105454: LIST
105455: LIST
105456: PUSH
105457: LD_VAR 0 1
105461: PUSH
105462: LD_INT 4
105464: PLUS
105465: PUSH
105466: LD_VAR 0 2
105470: PUSH
105471: LD_INT 4
105473: PLUS
105474: PUSH
105475: LD_INT 5
105477: PUSH
105478: EMPTY
105479: LIST
105480: LIST
105481: LIST
105482: PUSH
105483: LD_VAR 0 1
105487: PUSH
105488: LD_INT 3
105490: PLUS
105491: PUSH
105492: LD_VAR 0 2
105496: PUSH
105497: LD_INT 4
105499: PUSH
105500: EMPTY
105501: LIST
105502: LIST
105503: LIST
105504: PUSH
105505: LD_VAR 0 1
105509: PUSH
105510: LD_VAR 0 2
105514: PUSH
105515: LD_INT 3
105517: PLUS
105518: PUSH
105519: LD_INT 0
105521: PUSH
105522: EMPTY
105523: LIST
105524: LIST
105525: LIST
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: LIST
105531: LIST
105532: LIST
105533: ST_TO_ADDR
// end ; end ;
105534: GO 105537
105536: POP
// result := list ;
105537: LD_ADDR_VAR 0 4
105541: PUSH
105542: LD_VAR 0 5
105546: ST_TO_ADDR
// end ;
105547: LD_VAR 0 4
105551: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105552: LD_INT 0
105554: PPUSH
105555: PPUSH
105556: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105557: LD_VAR 0 1
105561: NOT
105562: PUSH
105563: LD_VAR 0 2
105567: PUSH
105568: LD_INT 1
105570: PUSH
105571: LD_INT 2
105573: PUSH
105574: LD_INT 3
105576: PUSH
105577: LD_INT 4
105579: PUSH
105580: EMPTY
105581: LIST
105582: LIST
105583: LIST
105584: LIST
105585: IN
105586: NOT
105587: OR
105588: IFFALSE 105592
// exit ;
105590: GO 105684
// tmp := [ ] ;
105592: LD_ADDR_VAR 0 5
105596: PUSH
105597: EMPTY
105598: ST_TO_ADDR
// for i in units do
105599: LD_ADDR_VAR 0 4
105603: PUSH
105604: LD_VAR 0 1
105608: PUSH
105609: FOR_IN
105610: IFFALSE 105653
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105612: LD_ADDR_VAR 0 5
105616: PUSH
105617: LD_VAR 0 5
105621: PPUSH
105622: LD_VAR 0 5
105626: PUSH
105627: LD_INT 1
105629: PLUS
105630: PPUSH
105631: LD_VAR 0 4
105635: PPUSH
105636: LD_VAR 0 2
105640: PPUSH
105641: CALL_OW 259
105645: PPUSH
105646: CALL_OW 2
105650: ST_TO_ADDR
105651: GO 105609
105653: POP
105654: POP
// if not tmp then
105655: LD_VAR 0 5
105659: NOT
105660: IFFALSE 105664
// exit ;
105662: GO 105684
// result := SortListByListDesc ( units , tmp ) ;
105664: LD_ADDR_VAR 0 3
105668: PUSH
105669: LD_VAR 0 1
105673: PPUSH
105674: LD_VAR 0 5
105678: PPUSH
105679: CALL_OW 77
105683: ST_TO_ADDR
// end ;
105684: LD_VAR 0 3
105688: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105689: LD_INT 0
105691: PPUSH
105692: PPUSH
105693: PPUSH
// x := GetX ( building ) ;
105694: LD_ADDR_VAR 0 4
105698: PUSH
105699: LD_VAR 0 2
105703: PPUSH
105704: CALL_OW 250
105708: ST_TO_ADDR
// y := GetY ( building ) ;
105709: LD_ADDR_VAR 0 5
105713: PUSH
105714: LD_VAR 0 2
105718: PPUSH
105719: CALL_OW 251
105723: ST_TO_ADDR
// if GetTaskList ( unit ) then
105724: LD_VAR 0 1
105728: PPUSH
105729: CALL_OW 437
105733: IFFALSE 105828
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105735: LD_STRING e
105737: PUSH
105738: LD_VAR 0 1
105742: PPUSH
105743: CALL_OW 437
105747: PUSH
105748: LD_INT 1
105750: ARRAY
105751: PUSH
105752: LD_INT 1
105754: ARRAY
105755: EQUAL
105756: PUSH
105757: LD_VAR 0 4
105761: PUSH
105762: LD_VAR 0 1
105766: PPUSH
105767: CALL_OW 437
105771: PUSH
105772: LD_INT 1
105774: ARRAY
105775: PUSH
105776: LD_INT 2
105778: ARRAY
105779: EQUAL
105780: AND
105781: PUSH
105782: LD_VAR 0 5
105786: PUSH
105787: LD_VAR 0 1
105791: PPUSH
105792: CALL_OW 437
105796: PUSH
105797: LD_INT 1
105799: ARRAY
105800: PUSH
105801: LD_INT 3
105803: ARRAY
105804: EQUAL
105805: AND
105806: IFFALSE 105818
// result := true else
105808: LD_ADDR_VAR 0 3
105812: PUSH
105813: LD_INT 1
105815: ST_TO_ADDR
105816: GO 105826
// result := false ;
105818: LD_ADDR_VAR 0 3
105822: PUSH
105823: LD_INT 0
105825: ST_TO_ADDR
// end else
105826: GO 105836
// result := false ;
105828: LD_ADDR_VAR 0 3
105832: PUSH
105833: LD_INT 0
105835: ST_TO_ADDR
// end ;
105836: LD_VAR 0 3
105840: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105841: LD_INT 0
105843: PPUSH
105844: PPUSH
105845: PPUSH
105846: PPUSH
// if not unit or not area then
105847: LD_VAR 0 1
105851: NOT
105852: PUSH
105853: LD_VAR 0 2
105857: NOT
105858: OR
105859: IFFALSE 105863
// exit ;
105861: GO 106027
// tmp := AreaToList ( area , i ) ;
105863: LD_ADDR_VAR 0 6
105867: PUSH
105868: LD_VAR 0 2
105872: PPUSH
105873: LD_VAR 0 5
105877: PPUSH
105878: CALL_OW 517
105882: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105883: LD_ADDR_VAR 0 5
105887: PUSH
105888: DOUBLE
105889: LD_INT 1
105891: DEC
105892: ST_TO_ADDR
105893: LD_VAR 0 6
105897: PUSH
105898: LD_INT 1
105900: ARRAY
105901: PUSH
105902: FOR_TO
105903: IFFALSE 106025
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105905: LD_ADDR_VAR 0 7
105909: PUSH
105910: LD_VAR 0 6
105914: PUSH
105915: LD_INT 1
105917: ARRAY
105918: PUSH
105919: LD_VAR 0 5
105923: ARRAY
105924: PUSH
105925: LD_VAR 0 6
105929: PUSH
105930: LD_INT 2
105932: ARRAY
105933: PUSH
105934: LD_VAR 0 5
105938: ARRAY
105939: PUSH
105940: EMPTY
105941: LIST
105942: LIST
105943: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105944: LD_VAR 0 7
105948: PUSH
105949: LD_INT 1
105951: ARRAY
105952: PPUSH
105953: LD_VAR 0 7
105957: PUSH
105958: LD_INT 2
105960: ARRAY
105961: PPUSH
105962: CALL_OW 428
105966: PUSH
105967: LD_INT 0
105969: EQUAL
105970: IFFALSE 106023
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105972: LD_VAR 0 1
105976: PPUSH
105977: LD_VAR 0 7
105981: PUSH
105982: LD_INT 1
105984: ARRAY
105985: PPUSH
105986: LD_VAR 0 7
105990: PUSH
105991: LD_INT 2
105993: ARRAY
105994: PPUSH
105995: LD_VAR 0 3
105999: PPUSH
106000: CALL_OW 48
// result := IsPlaced ( unit ) ;
106004: LD_ADDR_VAR 0 4
106008: PUSH
106009: LD_VAR 0 1
106013: PPUSH
106014: CALL_OW 305
106018: ST_TO_ADDR
// exit ;
106019: POP
106020: POP
106021: GO 106027
// end ; end ;
106023: GO 105902
106025: POP
106026: POP
// end ;
106027: LD_VAR 0 4
106031: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106032: LD_INT 0
106034: PPUSH
106035: PPUSH
106036: PPUSH
// if not side or side > 8 then
106037: LD_VAR 0 1
106041: NOT
106042: PUSH
106043: LD_VAR 0 1
106047: PUSH
106048: LD_INT 8
106050: GREATER
106051: OR
106052: IFFALSE 106056
// exit ;
106054: GO 106243
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106056: LD_ADDR_VAR 0 4
106060: PUSH
106061: LD_INT 22
106063: PUSH
106064: LD_VAR 0 1
106068: PUSH
106069: EMPTY
106070: LIST
106071: LIST
106072: PUSH
106073: LD_INT 21
106075: PUSH
106076: LD_INT 3
106078: PUSH
106079: EMPTY
106080: LIST
106081: LIST
106082: PUSH
106083: EMPTY
106084: LIST
106085: LIST
106086: PPUSH
106087: CALL_OW 69
106091: ST_TO_ADDR
// if not tmp then
106092: LD_VAR 0 4
106096: NOT
106097: IFFALSE 106101
// exit ;
106099: GO 106243
// enable_addtolog := true ;
106101: LD_ADDR_OWVAR 81
106105: PUSH
106106: LD_INT 1
106108: ST_TO_ADDR
// AddToLog ( [ ) ;
106109: LD_STRING [
106111: PPUSH
106112: CALL_OW 561
// for i in tmp do
106116: LD_ADDR_VAR 0 3
106120: PUSH
106121: LD_VAR 0 4
106125: PUSH
106126: FOR_IN
106127: IFFALSE 106234
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106129: LD_STRING [
106131: PUSH
106132: LD_VAR 0 3
106136: PPUSH
106137: CALL_OW 266
106141: STR
106142: PUSH
106143: LD_STRING , 
106145: STR
106146: PUSH
106147: LD_VAR 0 3
106151: PPUSH
106152: CALL_OW 250
106156: STR
106157: PUSH
106158: LD_STRING , 
106160: STR
106161: PUSH
106162: LD_VAR 0 3
106166: PPUSH
106167: CALL_OW 251
106171: STR
106172: PUSH
106173: LD_STRING , 
106175: STR
106176: PUSH
106177: LD_VAR 0 3
106181: PPUSH
106182: CALL_OW 254
106186: STR
106187: PUSH
106188: LD_STRING , 
106190: STR
106191: PUSH
106192: LD_VAR 0 3
106196: PPUSH
106197: LD_INT 1
106199: PPUSH
106200: CALL_OW 268
106204: STR
106205: PUSH
106206: LD_STRING , 
106208: STR
106209: PUSH
106210: LD_VAR 0 3
106214: PPUSH
106215: LD_INT 2
106217: PPUSH
106218: CALL_OW 268
106222: STR
106223: PUSH
106224: LD_STRING ],
106226: STR
106227: PPUSH
106228: CALL_OW 561
// end ;
106232: GO 106126
106234: POP
106235: POP
// AddToLog ( ]; ) ;
106236: LD_STRING ];
106238: PPUSH
106239: CALL_OW 561
// end ;
106243: LD_VAR 0 2
106247: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106248: LD_INT 0
106250: PPUSH
106251: PPUSH
106252: PPUSH
106253: PPUSH
106254: PPUSH
// if not area or not rate or not max then
106255: LD_VAR 0 1
106259: NOT
106260: PUSH
106261: LD_VAR 0 2
106265: NOT
106266: OR
106267: PUSH
106268: LD_VAR 0 4
106272: NOT
106273: OR
106274: IFFALSE 106278
// exit ;
106276: GO 106470
// while 1 do
106278: LD_INT 1
106280: IFFALSE 106470
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106282: LD_ADDR_VAR 0 9
106286: PUSH
106287: LD_VAR 0 1
106291: PPUSH
106292: LD_INT 1
106294: PPUSH
106295: CALL_OW 287
106299: PUSH
106300: LD_INT 10
106302: MUL
106303: ST_TO_ADDR
// r := rate / 10 ;
106304: LD_ADDR_VAR 0 7
106308: PUSH
106309: LD_VAR 0 2
106313: PUSH
106314: LD_INT 10
106316: DIVREAL
106317: ST_TO_ADDR
// time := 1 1$00 ;
106318: LD_ADDR_VAR 0 8
106322: PUSH
106323: LD_INT 2100
106325: ST_TO_ADDR
// if amount < min then
106326: LD_VAR 0 9
106330: PUSH
106331: LD_VAR 0 3
106335: LESS
106336: IFFALSE 106354
// r := r * 2 else
106338: LD_ADDR_VAR 0 7
106342: PUSH
106343: LD_VAR 0 7
106347: PUSH
106348: LD_INT 2
106350: MUL
106351: ST_TO_ADDR
106352: GO 106380
// if amount > max then
106354: LD_VAR 0 9
106358: PUSH
106359: LD_VAR 0 4
106363: GREATER
106364: IFFALSE 106380
// r := r / 2 ;
106366: LD_ADDR_VAR 0 7
106370: PUSH
106371: LD_VAR 0 7
106375: PUSH
106376: LD_INT 2
106378: DIVREAL
106379: ST_TO_ADDR
// time := time / r ;
106380: LD_ADDR_VAR 0 8
106384: PUSH
106385: LD_VAR 0 8
106389: PUSH
106390: LD_VAR 0 7
106394: DIVREAL
106395: ST_TO_ADDR
// if time < 0 then
106396: LD_VAR 0 8
106400: PUSH
106401: LD_INT 0
106403: LESS
106404: IFFALSE 106421
// time := time * - 1 ;
106406: LD_ADDR_VAR 0 8
106410: PUSH
106411: LD_VAR 0 8
106415: PUSH
106416: LD_INT 1
106418: NEG
106419: MUL
106420: ST_TO_ADDR
// wait ( time ) ;
106421: LD_VAR 0 8
106425: PPUSH
106426: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106430: LD_INT 35
106432: PPUSH
106433: LD_INT 875
106435: PPUSH
106436: CALL_OW 12
106440: PPUSH
106441: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106445: LD_INT 1
106447: PPUSH
106448: LD_INT 5
106450: PPUSH
106451: CALL_OW 12
106455: PPUSH
106456: LD_VAR 0 1
106460: PPUSH
106461: LD_INT 1
106463: PPUSH
106464: CALL_OW 55
// end ;
106468: GO 106278
// end ;
106470: LD_VAR 0 5
106474: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106475: LD_INT 0
106477: PPUSH
106478: PPUSH
106479: PPUSH
106480: PPUSH
106481: PPUSH
106482: PPUSH
106483: PPUSH
106484: PPUSH
// if not turrets or not factories then
106485: LD_VAR 0 1
106489: NOT
106490: PUSH
106491: LD_VAR 0 2
106495: NOT
106496: OR
106497: IFFALSE 106501
// exit ;
106499: GO 106808
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106501: LD_ADDR_VAR 0 10
106505: PUSH
106506: LD_INT 5
106508: PUSH
106509: LD_INT 6
106511: PUSH
106512: EMPTY
106513: LIST
106514: LIST
106515: PUSH
106516: LD_INT 2
106518: PUSH
106519: LD_INT 4
106521: PUSH
106522: EMPTY
106523: LIST
106524: LIST
106525: PUSH
106526: LD_INT 3
106528: PUSH
106529: LD_INT 5
106531: PUSH
106532: EMPTY
106533: LIST
106534: LIST
106535: PUSH
106536: EMPTY
106537: LIST
106538: LIST
106539: LIST
106540: PUSH
106541: LD_INT 24
106543: PUSH
106544: LD_INT 25
106546: PUSH
106547: EMPTY
106548: LIST
106549: LIST
106550: PUSH
106551: LD_INT 23
106553: PUSH
106554: LD_INT 27
106556: PUSH
106557: EMPTY
106558: LIST
106559: LIST
106560: PUSH
106561: EMPTY
106562: LIST
106563: LIST
106564: PUSH
106565: LD_INT 42
106567: PUSH
106568: LD_INT 43
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PUSH
106575: LD_INT 44
106577: PUSH
106578: LD_INT 46
106580: PUSH
106581: EMPTY
106582: LIST
106583: LIST
106584: PUSH
106585: LD_INT 45
106587: PUSH
106588: LD_INT 47
106590: PUSH
106591: EMPTY
106592: LIST
106593: LIST
106594: PUSH
106595: EMPTY
106596: LIST
106597: LIST
106598: LIST
106599: PUSH
106600: EMPTY
106601: LIST
106602: LIST
106603: LIST
106604: ST_TO_ADDR
// result := [ ] ;
106605: LD_ADDR_VAR 0 3
106609: PUSH
106610: EMPTY
106611: ST_TO_ADDR
// for i in turrets do
106612: LD_ADDR_VAR 0 4
106616: PUSH
106617: LD_VAR 0 1
106621: PUSH
106622: FOR_IN
106623: IFFALSE 106806
// begin nat := GetNation ( i ) ;
106625: LD_ADDR_VAR 0 7
106629: PUSH
106630: LD_VAR 0 4
106634: PPUSH
106635: CALL_OW 248
106639: ST_TO_ADDR
// weapon := 0 ;
106640: LD_ADDR_VAR 0 8
106644: PUSH
106645: LD_INT 0
106647: ST_TO_ADDR
// if not nat then
106648: LD_VAR 0 7
106652: NOT
106653: IFFALSE 106657
// continue ;
106655: GO 106622
// for j in list [ nat ] do
106657: LD_ADDR_VAR 0 5
106661: PUSH
106662: LD_VAR 0 10
106666: PUSH
106667: LD_VAR 0 7
106671: ARRAY
106672: PUSH
106673: FOR_IN
106674: IFFALSE 106715
// if GetBWeapon ( i ) = j [ 1 ] then
106676: LD_VAR 0 4
106680: PPUSH
106681: CALL_OW 269
106685: PUSH
106686: LD_VAR 0 5
106690: PUSH
106691: LD_INT 1
106693: ARRAY
106694: EQUAL
106695: IFFALSE 106713
// begin weapon := j [ 2 ] ;
106697: LD_ADDR_VAR 0 8
106701: PUSH
106702: LD_VAR 0 5
106706: PUSH
106707: LD_INT 2
106709: ARRAY
106710: ST_TO_ADDR
// break ;
106711: GO 106715
// end ;
106713: GO 106673
106715: POP
106716: POP
// if not weapon then
106717: LD_VAR 0 8
106721: NOT
106722: IFFALSE 106726
// continue ;
106724: GO 106622
// for k in factories do
106726: LD_ADDR_VAR 0 6
106730: PUSH
106731: LD_VAR 0 2
106735: PUSH
106736: FOR_IN
106737: IFFALSE 106802
// begin weapons := AvailableWeaponList ( k ) ;
106739: LD_ADDR_VAR 0 9
106743: PUSH
106744: LD_VAR 0 6
106748: PPUSH
106749: CALL_OW 478
106753: ST_TO_ADDR
// if not weapons then
106754: LD_VAR 0 9
106758: NOT
106759: IFFALSE 106763
// continue ;
106761: GO 106736
// if weapon in weapons then
106763: LD_VAR 0 8
106767: PUSH
106768: LD_VAR 0 9
106772: IN
106773: IFFALSE 106800
// begin result := [ i , weapon ] ;
106775: LD_ADDR_VAR 0 3
106779: PUSH
106780: LD_VAR 0 4
106784: PUSH
106785: LD_VAR 0 8
106789: PUSH
106790: EMPTY
106791: LIST
106792: LIST
106793: ST_TO_ADDR
// exit ;
106794: POP
106795: POP
106796: POP
106797: POP
106798: GO 106808
// end ; end ;
106800: GO 106736
106802: POP
106803: POP
// end ;
106804: GO 106622
106806: POP
106807: POP
// end ;
106808: LD_VAR 0 3
106812: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106813: LD_INT 0
106815: PPUSH
// if not side or side > 8 then
106816: LD_VAR 0 3
106820: NOT
106821: PUSH
106822: LD_VAR 0 3
106826: PUSH
106827: LD_INT 8
106829: GREATER
106830: OR
106831: IFFALSE 106835
// exit ;
106833: GO 106894
// if not range then
106835: LD_VAR 0 4
106839: NOT
106840: IFFALSE 106851
// range := - 12 ;
106842: LD_ADDR_VAR 0 4
106846: PUSH
106847: LD_INT 12
106849: NEG
106850: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106851: LD_VAR 0 1
106855: PPUSH
106856: LD_VAR 0 2
106860: PPUSH
106861: LD_VAR 0 3
106865: PPUSH
106866: LD_VAR 0 4
106870: PPUSH
106871: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106875: LD_VAR 0 1
106879: PPUSH
106880: LD_VAR 0 2
106884: PPUSH
106885: LD_VAR 0 3
106889: PPUSH
106890: CALL_OW 331
// end ;
106894: LD_VAR 0 5
106898: RET
// export function Video ( mode ) ; begin
106899: LD_INT 0
106901: PPUSH
// ingame_video = mode ;
106902: LD_ADDR_OWVAR 52
106906: PUSH
106907: LD_VAR 0 1
106911: ST_TO_ADDR
// interface_hidden = mode ;
106912: LD_ADDR_OWVAR 54
106916: PUSH
106917: LD_VAR 0 1
106921: ST_TO_ADDR
// end ;
106922: LD_VAR 0 2
106926: RET
// export function Join ( array , element ) ; begin
106927: LD_INT 0
106929: PPUSH
// result := array ^ element ;
106930: LD_ADDR_VAR 0 3
106934: PUSH
106935: LD_VAR 0 1
106939: PUSH
106940: LD_VAR 0 2
106944: ADD
106945: ST_TO_ADDR
// end ;
106946: LD_VAR 0 3
106950: RET
// export function JoinUnion ( array , element ) ; begin
106951: LD_INT 0
106953: PPUSH
// result := array union element ;
106954: LD_ADDR_VAR 0 3
106958: PUSH
106959: LD_VAR 0 1
106963: PUSH
106964: LD_VAR 0 2
106968: UNION
106969: ST_TO_ADDR
// end ;
106970: LD_VAR 0 3
106974: RET
// export function GetBehemoths ( side ) ; begin
106975: LD_INT 0
106977: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106978: LD_ADDR_VAR 0 2
106982: PUSH
106983: LD_INT 22
106985: PUSH
106986: LD_VAR 0 1
106990: PUSH
106991: EMPTY
106992: LIST
106993: LIST
106994: PUSH
106995: LD_INT 31
106997: PUSH
106998: LD_INT 25
107000: PUSH
107001: EMPTY
107002: LIST
107003: LIST
107004: PUSH
107005: EMPTY
107006: LIST
107007: LIST
107008: PPUSH
107009: CALL_OW 69
107013: ST_TO_ADDR
// end ;
107014: LD_VAR 0 2
107018: RET
// export function Shuffle ( array ) ; var i , index ; begin
107019: LD_INT 0
107021: PPUSH
107022: PPUSH
107023: PPUSH
// result := [ ] ;
107024: LD_ADDR_VAR 0 2
107028: PUSH
107029: EMPTY
107030: ST_TO_ADDR
// if not array then
107031: LD_VAR 0 1
107035: NOT
107036: IFFALSE 107040
// exit ;
107038: GO 107139
// Randomize ;
107040: CALL_OW 10
// for i = array downto 1 do
107044: LD_ADDR_VAR 0 3
107048: PUSH
107049: DOUBLE
107050: LD_VAR 0 1
107054: INC
107055: ST_TO_ADDR
107056: LD_INT 1
107058: PUSH
107059: FOR_DOWNTO
107060: IFFALSE 107137
// begin index := rand ( 1 , array ) ;
107062: LD_ADDR_VAR 0 4
107066: PUSH
107067: LD_INT 1
107069: PPUSH
107070: LD_VAR 0 1
107074: PPUSH
107075: CALL_OW 12
107079: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107080: LD_ADDR_VAR 0 2
107084: PUSH
107085: LD_VAR 0 2
107089: PPUSH
107090: LD_VAR 0 2
107094: PUSH
107095: LD_INT 1
107097: PLUS
107098: PPUSH
107099: LD_VAR 0 1
107103: PUSH
107104: LD_VAR 0 4
107108: ARRAY
107109: PPUSH
107110: CALL_OW 2
107114: ST_TO_ADDR
// array := Delete ( array , index ) ;
107115: LD_ADDR_VAR 0 1
107119: PUSH
107120: LD_VAR 0 1
107124: PPUSH
107125: LD_VAR 0 4
107129: PPUSH
107130: CALL_OW 3
107134: ST_TO_ADDR
// end ;
107135: GO 107059
107137: POP
107138: POP
// end ;
107139: LD_VAR 0 2
107143: RET
// export function GetBaseMaterials ( base ) ; begin
107144: LD_INT 0
107146: PPUSH
// result := [ 0 , 0 , 0 ] ;
107147: LD_ADDR_VAR 0 2
107151: PUSH
107152: LD_INT 0
107154: PUSH
107155: LD_INT 0
107157: PUSH
107158: LD_INT 0
107160: PUSH
107161: EMPTY
107162: LIST
107163: LIST
107164: LIST
107165: ST_TO_ADDR
// if not base then
107166: LD_VAR 0 1
107170: NOT
107171: IFFALSE 107175
// exit ;
107173: GO 107224
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107175: LD_ADDR_VAR 0 2
107179: PUSH
107180: LD_VAR 0 1
107184: PPUSH
107185: LD_INT 1
107187: PPUSH
107188: CALL_OW 275
107192: PUSH
107193: LD_VAR 0 1
107197: PPUSH
107198: LD_INT 2
107200: PPUSH
107201: CALL_OW 275
107205: PUSH
107206: LD_VAR 0 1
107210: PPUSH
107211: LD_INT 3
107213: PPUSH
107214: CALL_OW 275
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: LIST
107223: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107224: LD_VAR 0 2
107228: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107229: LD_INT 0
107231: PPUSH
107232: PPUSH
107233: PPUSH
107234: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107235: LD_VAR 0 1
107239: PPUSH
107240: CALL_OW 264
107244: PUSH
107245: LD_EXP 96
107249: EQUAL
107250: IFFALSE 107322
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107252: LD_INT 68
107254: PPUSH
107255: LD_VAR 0 1
107259: PPUSH
107260: CALL_OW 255
107264: PPUSH
107265: CALL_OW 321
107269: PUSH
107270: LD_INT 2
107272: EQUAL
107273: IFFALSE 107285
// eff := 70 else
107275: LD_ADDR_VAR 0 6
107279: PUSH
107280: LD_INT 70
107282: ST_TO_ADDR
107283: GO 107293
// eff := 30 ;
107285: LD_ADDR_VAR 0 6
107289: PUSH
107290: LD_INT 30
107292: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107293: LD_VAR 0 1
107297: PPUSH
107298: CALL_OW 250
107302: PPUSH
107303: LD_VAR 0 1
107307: PPUSH
107308: CALL_OW 251
107312: PPUSH
107313: LD_VAR 0 6
107317: PPUSH
107318: CALL_OW 495
// end ; end ;
107322: LD_VAR 0 4
107326: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107327: LD_INT 0
107329: PPUSH
107330: PPUSH
107331: PPUSH
107332: PPUSH
107333: PPUSH
107334: PPUSH
// if cmd = 124 then
107335: LD_VAR 0 1
107339: PUSH
107340: LD_INT 124
107342: EQUAL
107343: IFFALSE 107549
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107345: LD_ADDR_VAR 0 5
107349: PUSH
107350: LD_INT 2
107352: PUSH
107353: LD_INT 34
107355: PUSH
107356: LD_INT 53
107358: PUSH
107359: EMPTY
107360: LIST
107361: LIST
107362: PUSH
107363: LD_INT 34
107365: PUSH
107366: LD_INT 14
107368: PUSH
107369: EMPTY
107370: LIST
107371: LIST
107372: PUSH
107373: EMPTY
107374: LIST
107375: LIST
107376: LIST
107377: PPUSH
107378: CALL_OW 69
107382: ST_TO_ADDR
// if not tmp then
107383: LD_VAR 0 5
107387: NOT
107388: IFFALSE 107392
// exit ;
107390: GO 107549
// for i in tmp do
107392: LD_ADDR_VAR 0 3
107396: PUSH
107397: LD_VAR 0 5
107401: PUSH
107402: FOR_IN
107403: IFFALSE 107547
// begin taskList := GetTaskList ( i ) ;
107405: LD_ADDR_VAR 0 6
107409: PUSH
107410: LD_VAR 0 3
107414: PPUSH
107415: CALL_OW 437
107419: ST_TO_ADDR
// if not taskList then
107420: LD_VAR 0 6
107424: NOT
107425: IFFALSE 107429
// continue ;
107427: GO 107402
// for j = 1 to taskList do
107429: LD_ADDR_VAR 0 4
107433: PUSH
107434: DOUBLE
107435: LD_INT 1
107437: DEC
107438: ST_TO_ADDR
107439: LD_VAR 0 6
107443: PUSH
107444: FOR_TO
107445: IFFALSE 107543
// if taskList [ j ] [ 1 ] = | then
107447: LD_VAR 0 6
107451: PUSH
107452: LD_VAR 0 4
107456: ARRAY
107457: PUSH
107458: LD_INT 1
107460: ARRAY
107461: PUSH
107462: LD_STRING |
107464: EQUAL
107465: IFFALSE 107541
// begin _taskList := Delete ( taskList , 1 ) ;
107467: LD_ADDR_VAR 0 7
107471: PUSH
107472: LD_VAR 0 6
107476: PPUSH
107477: LD_INT 1
107479: PPUSH
107480: CALL_OW 3
107484: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107485: LD_VAR 0 3
107489: PPUSH
107490: LD_VAR 0 7
107494: PPUSH
107495: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107499: LD_VAR 0 3
107503: PPUSH
107504: LD_VAR 0 6
107508: PUSH
107509: LD_VAR 0 4
107513: ARRAY
107514: PUSH
107515: LD_INT 2
107517: ARRAY
107518: PPUSH
107519: LD_VAR 0 6
107523: PUSH
107524: LD_VAR 0 4
107528: ARRAY
107529: PUSH
107530: LD_INT 3
107532: ARRAY
107533: PPUSH
107534: LD_INT 8
107536: PPUSH
107537: CALL 107554 0 4
// end ;
107541: GO 107444
107543: POP
107544: POP
// end ;
107545: GO 107402
107547: POP
107548: POP
// end ; end ;
107549: LD_VAR 0 2
107553: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107554: LD_INT 0
107556: PPUSH
107557: PPUSH
107558: PPUSH
107559: PPUSH
107560: PPUSH
107561: PPUSH
107562: PPUSH
107563: PPUSH
107564: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107565: LD_VAR 0 1
107569: NOT
107570: PUSH
107571: LD_VAR 0 2
107575: PPUSH
107576: LD_VAR 0 3
107580: PPUSH
107581: CALL_OW 488
107585: NOT
107586: OR
107587: PUSH
107588: LD_VAR 0 4
107592: NOT
107593: OR
107594: IFFALSE 107598
// exit ;
107596: GO 107938
// list := [ ] ;
107598: LD_ADDR_VAR 0 13
107602: PUSH
107603: EMPTY
107604: ST_TO_ADDR
// if x - r < 0 then
107605: LD_VAR 0 2
107609: PUSH
107610: LD_VAR 0 4
107614: MINUS
107615: PUSH
107616: LD_INT 0
107618: LESS
107619: IFFALSE 107631
// min_x := 0 else
107621: LD_ADDR_VAR 0 7
107625: PUSH
107626: LD_INT 0
107628: ST_TO_ADDR
107629: GO 107647
// min_x := x - r ;
107631: LD_ADDR_VAR 0 7
107635: PUSH
107636: LD_VAR 0 2
107640: PUSH
107641: LD_VAR 0 4
107645: MINUS
107646: ST_TO_ADDR
// if y - r < 0 then
107647: LD_VAR 0 3
107651: PUSH
107652: LD_VAR 0 4
107656: MINUS
107657: PUSH
107658: LD_INT 0
107660: LESS
107661: IFFALSE 107673
// min_y := 0 else
107663: LD_ADDR_VAR 0 8
107667: PUSH
107668: LD_INT 0
107670: ST_TO_ADDR
107671: GO 107689
// min_y := y - r ;
107673: LD_ADDR_VAR 0 8
107677: PUSH
107678: LD_VAR 0 3
107682: PUSH
107683: LD_VAR 0 4
107687: MINUS
107688: ST_TO_ADDR
// max_x := x + r ;
107689: LD_ADDR_VAR 0 9
107693: PUSH
107694: LD_VAR 0 2
107698: PUSH
107699: LD_VAR 0 4
107703: PLUS
107704: ST_TO_ADDR
// max_y := y + r ;
107705: LD_ADDR_VAR 0 10
107709: PUSH
107710: LD_VAR 0 3
107714: PUSH
107715: LD_VAR 0 4
107719: PLUS
107720: ST_TO_ADDR
// for _x = min_x to max_x do
107721: LD_ADDR_VAR 0 11
107725: PUSH
107726: DOUBLE
107727: LD_VAR 0 7
107731: DEC
107732: ST_TO_ADDR
107733: LD_VAR 0 9
107737: PUSH
107738: FOR_TO
107739: IFFALSE 107856
// for _y = min_y to max_y do
107741: LD_ADDR_VAR 0 12
107745: PUSH
107746: DOUBLE
107747: LD_VAR 0 8
107751: DEC
107752: ST_TO_ADDR
107753: LD_VAR 0 10
107757: PUSH
107758: FOR_TO
107759: IFFALSE 107852
// begin if not ValidHex ( _x , _y ) then
107761: LD_VAR 0 11
107765: PPUSH
107766: LD_VAR 0 12
107770: PPUSH
107771: CALL_OW 488
107775: NOT
107776: IFFALSE 107780
// continue ;
107778: GO 107758
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107780: LD_VAR 0 11
107784: PPUSH
107785: LD_VAR 0 12
107789: PPUSH
107790: CALL_OW 351
107794: PUSH
107795: LD_VAR 0 11
107799: PPUSH
107800: LD_VAR 0 12
107804: PPUSH
107805: CALL_OW 554
107809: AND
107810: IFFALSE 107850
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107812: LD_ADDR_VAR 0 13
107816: PUSH
107817: LD_VAR 0 13
107821: PPUSH
107822: LD_VAR 0 13
107826: PUSH
107827: LD_INT 1
107829: PLUS
107830: PPUSH
107831: LD_VAR 0 11
107835: PUSH
107836: LD_VAR 0 12
107840: PUSH
107841: EMPTY
107842: LIST
107843: LIST
107844: PPUSH
107845: CALL_OW 2
107849: ST_TO_ADDR
// end ;
107850: GO 107758
107852: POP
107853: POP
107854: GO 107738
107856: POP
107857: POP
// if not list then
107858: LD_VAR 0 13
107862: NOT
107863: IFFALSE 107867
// exit ;
107865: GO 107938
// for i in list do
107867: LD_ADDR_VAR 0 6
107871: PUSH
107872: LD_VAR 0 13
107876: PUSH
107877: FOR_IN
107878: IFFALSE 107936
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107880: LD_VAR 0 1
107884: PPUSH
107885: LD_STRING M
107887: PUSH
107888: LD_VAR 0 6
107892: PUSH
107893: LD_INT 1
107895: ARRAY
107896: PUSH
107897: LD_VAR 0 6
107901: PUSH
107902: LD_INT 2
107904: ARRAY
107905: PUSH
107906: LD_INT 0
107908: PUSH
107909: LD_INT 0
107911: PUSH
107912: LD_INT 0
107914: PUSH
107915: LD_INT 0
107917: PUSH
107918: EMPTY
107919: LIST
107920: LIST
107921: LIST
107922: LIST
107923: LIST
107924: LIST
107925: LIST
107926: PUSH
107927: EMPTY
107928: LIST
107929: PPUSH
107930: CALL_OW 447
107934: GO 107877
107936: POP
107937: POP
// end ;
107938: LD_VAR 0 5
107942: RET
