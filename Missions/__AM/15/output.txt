// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33689 0 0
// InitNature ;
  19: CALL 33513 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10792 0 0
// PrepareRussian ;
  40: CALL 6785 0 0
// PrepareLegion ;
  44: CALL 4025 0 0
// PreparePowell ;
  48: CALL 2779 0 0
// PrepareAmerican ;
  52: CALL 1602 0 0
// Action ;
  56: CALL 14699 0 0
// MC_Start ( ) ;
  60: CALL 35801 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 57541 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 57634 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57047 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 56862 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 57541 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 57634 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 24
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 47
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 24
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 47
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 56862 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 802: LD_INT 2
 804: PPUSH
 805: LD_INT 5
 807: PPUSH
 808: CALL 57047 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 812: LD_INT 2
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL 57414 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 822: LD_INT 3
 824: PPUSH
 825: LD_INT 10
 827: PUSH
 828: LD_INT 12
 830: PUSH
 831: LD_INT 15
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: LIST
 838: PUSH
 839: LD_OWVAR 67
 843: ARRAY
 844: PPUSH
 845: LD_INT 27
 847: PPUSH
 848: CALL 56544 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 852: LD_INT 3
 854: PPUSH
 855: LD_INT 10
 857: PUSH
 858: LD_INT 11
 860: PUSH
 861: LD_INT 13
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL 57541 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 15
 882: PUSH
 883: EMPTY
 884: LIST
 885: PPUSH
 886: CALL 57634 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 890: LD_ADDR_EXP 128
 894: PUSH
 895: LD_EXP 128
 899: PPUSH
 900: LD_INT 3
 902: PPUSH
 903: LD_INT 22
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 25
 915: PUSH
 916: LD_INT 15
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL_OW 69
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 13
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 31
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 13
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 31
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 13
 978: PUSH
 979: LD_INT 3
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: LD_INT 32
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: LIST
 992: LIST
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: PPUSH
 999: CALL 56862 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1003: LD_INT 4
1005: PPUSH
1006: LD_INT 10
1008: PUSH
1009: LD_INT 12
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL 57541 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1020: LD_INT 4
1022: PPUSH
1023: LD_INT 9
1025: PUSH
1026: EMPTY
1027: LIST
1028: PPUSH
1029: CALL 57634 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1033: LD_INT 4
1035: PPUSH
1036: LD_INT 26
1038: PUSH
1039: LD_INT 74
1041: PUSH
1042: LD_INT 107
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: LD_INT 77
1059: PUSH
1060: LD_INT 101
1062: PUSH
1063: LD_INT 4
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_INT 32
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 86
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_INT 27
1092: PUSH
1093: LD_INT 77
1095: PUSH
1096: LD_INT 110
1098: PUSH
1099: LD_INT 3
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 27
1110: PUSH
1111: LD_INT 42
1113: PUSH
1114: LD_INT 79
1116: PUSH
1117: LD_INT 5
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 29
1128: PUSH
1129: LD_INT 86
1131: PUSH
1132: LD_INT 105
1134: PUSH
1135: LD_INT 2
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 30
1146: PUSH
1147: LD_INT 40
1149: PUSH
1150: LD_INT 75
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 80
1167: PUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: LD_INT 75
1185: PUSH
1186: LD_INT 114
1188: PUSH
1189: LD_INT 5
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 32
1200: PUSH
1201: LD_INT 82
1203: PUSH
1204: LD_INT 110
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 62
1221: PUSH
1222: LD_INT 78
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 4
1236: PUSH
1237: LD_INT 39
1239: PUSH
1240: LD_INT 61
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 56754 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 5
1275: PUSH
1276: LD_INT 6
1278: PUSH
1279: LD_INT 7
1281: PUSH
1282: LD_INT 9
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PPUSH
1291: CALL 57952 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 40
1300: PUSH
1301: LD_INT 75
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_INT 86
1314: PUSH
1315: LD_INT 105
1317: PUSH
1318: LD_INT 0
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL 57186 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 2
1339: PPUSH
1340: CALL 57414 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1344: LD_INT 4
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 57414 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 54
1359: PPUSH
1360: LD_INT 85
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: LD_INT 19
1368: PUSH
1369: LD_INT 16
1371: PUSH
1372: LD_INT 17
1374: PUSH
1375: LD_INT 18
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 57746 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 4
1411: PUSH
1412: LD_INT 1
1414: PUSH
1415: LD_INT 1
1417: PUSH
1418: LD_INT 6
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_INT 4
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 7
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 4
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PPUSH
1469: CALL 56862 0 2
// MC_SetTame ( 4 , powellApe ) ;
1473: LD_INT 4
1475: PPUSH
1476: LD_INT 13
1478: PPUSH
1479: CALL 57365 0 2
// end ;
1483: LD_VAR 0 1
1487: RET
// every 0 0$1 trigger debug do var i , tmp ;
1488: LD_EXP 1
1492: IFFALSE 1599
1494: GO 1496
1496: DISABLE
1497: LD_INT 0
1499: PPUSH
1500: PPUSH
// begin enable ;
1501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1502: LD_ADDR_VAR 0 2
1506: PUSH
1507: LD_INT 22
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 21
1522: PUSH
1523: LD_INT 3
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 3
1536: PUSH
1537: LD_INT 24
1539: PUSH
1540: LD_INT 999
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PPUSH
1556: CALL_OW 69
1560: ST_TO_ADDR
// if not tmp then
1561: LD_VAR 0 2
1565: NOT
1566: IFFALSE 1570
// exit ;
1568: GO 1599
// for i in tmp do
1570: LD_ADDR_VAR 0 1
1574: PUSH
1575: LD_VAR 0 2
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1597
// SetLives ( i , 1000 ) ;
1583: LD_VAR 0 1
1587: PPUSH
1588: LD_INT 1000
1590: PPUSH
1591: CALL_OW 234
1595: GO 1580
1597: POP
1598: POP
// end ; end_of_file
1599: PPOPN 2
1601: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1602: LD_INT 0
1604: PPUSH
// uc_side := 1 ;
1605: LD_ADDR_OWVAR 20
1609: PUSH
1610: LD_INT 1
1612: ST_TO_ADDR
// uc_nation := 1 ;
1613: LD_ADDR_OWVAR 21
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1621: LD_ADDR_EXP 36
1625: PUSH
1626: LD_STRING JMM
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 14_
1637: PPUSH
1638: CALL 62912 0 3
1642: ST_TO_ADDR
// if not JMMVeh then
1643: LD_EXP 4
1647: NOT
1648: IFFALSE 1671
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1650: LD_INT 3
1652: PPUSH
1653: LD_INT 3
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: LD_INT 100
1664: PPUSH
1665: CALL 69515 0 5
1669: GO 1730
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1671: LD_EXP 4
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_EXP 4
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PUSH
1693: LD_INT 1
1695: ARRAY
1696: PPUSH
1697: LD_EXP 4
1701: PUSH
1702: LD_INT 3
1704: ARRAY
1705: PUSH
1706: LD_INT 1
1708: ARRAY
1709: PPUSH
1710: LD_EXP 4
1714: PUSH
1715: LD_INT 4
1717: ARRAY
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: PPUSH
1723: LD_INT 30
1725: PPUSH
1726: CALL 69515 0 5
// JMMNewVeh := CreateVehicle ;
1730: LD_ADDR_EXP 53
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1740: LD_EXP 53
1744: PPUSH
1745: LD_INT 4
1747: PPUSH
1748: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1752: LD_EXP 53
1756: PPUSH
1757: LD_INT 75
1759: PPUSH
1760: LD_INT 92
1762: PPUSH
1763: LD_INT 0
1765: PPUSH
1766: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1770: LD_EXP 36
1774: PPUSH
1775: LD_EXP 53
1779: PPUSH
1780: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1784: LD_EXP 6
1788: PUSH
1789: LD_EXP 2
1793: NOT
1794: AND
1795: IFFALSE 2053
// begin if not JMMGirlVeh then
1797: LD_EXP 5
1801: NOT
1802: IFFALSE 1825
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1804: LD_INT 3
1806: PPUSH
1807: LD_INT 3
1809: PPUSH
1810: LD_INT 1
1812: PPUSH
1813: LD_INT 9
1815: PPUSH
1816: LD_INT 100
1818: PPUSH
1819: CALL 69515 0 5
1823: GO 1884
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1825: LD_EXP 5
1829: PUSH
1830: LD_INT 1
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 5
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_EXP 5
1855: PUSH
1856: LD_INT 3
1858: ARRAY
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PPUSH
1864: LD_EXP 5
1868: PUSH
1869: LD_INT 4
1871: ARRAY
1872: PUSH
1873: LD_INT 1
1875: ARRAY
1876: PPUSH
1877: LD_INT 30
1879: PPUSH
1880: CALL 69515 0 5
// GirlNewVeh := CreateVehicle ;
1884: LD_ADDR_EXP 54
1888: PUSH
1889: CALL_OW 45
1893: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1894: LD_EXP 54
1898: PPUSH
1899: LD_INT 4
1901: PPUSH
1902: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1906: LD_EXP 54
1910: PPUSH
1911: LD_INT 82
1913: PPUSH
1914: LD_INT 96
1916: PPUSH
1917: LD_INT 0
1919: PPUSH
1920: CALL_OW 48
// if JMMGirl = 1 then
1924: LD_EXP 7
1928: PUSH
1929: LD_INT 1
1931: EQUAL
1932: IFFALSE 1967
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1934: LD_ADDR_EXP 37
1938: PUSH
1939: LD_STRING Joan
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_STRING 14_
1947: PPUSH
1948: CALL 62912 0 3
1952: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1953: LD_EXP 37
1957: PPUSH
1958: LD_EXP 54
1962: PPUSH
1963: CALL_OW 52
// end ; if JMMGirl = 2 then
1967: LD_EXP 7
1971: PUSH
1972: LD_INT 2
1974: EQUAL
1975: IFFALSE 2010
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1977: LD_ADDR_EXP 39
1981: PUSH
1982: LD_STRING Lisa
1984: PPUSH
1985: LD_INT 1
1987: PPUSH
1988: LD_STRING 14_
1990: PPUSH
1991: CALL 62912 0 3
1995: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1996: LD_EXP 39
2000: PPUSH
2001: LD_EXP 54
2005: PPUSH
2006: CALL_OW 52
// end ; if JMMGirl = 3 then
2010: LD_EXP 7
2014: PUSH
2015: LD_INT 3
2017: EQUAL
2018: IFFALSE 2053
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2020: LD_ADDR_EXP 51
2024: PUSH
2025: LD_STRING Connie
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_STRING 14_
2033: PPUSH
2034: CALL 62912 0 3
2038: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2039: LD_EXP 51
2043: PPUSH
2044: LD_EXP 54
2048: PPUSH
2049: CALL_OW 52
// end ; end ; end ;
2053: LD_VAR 0 1
2057: RET
// export function PrepareStevensSquad ; var tmp ; begin
2058: LD_INT 0
2060: PPUSH
2061: PPUSH
// uc_side := 1 ;
2062: LD_ADDR_OWVAR 20
2066: PUSH
2067: LD_INT 1
2069: ST_TO_ADDR
// uc_nation := 1 ;
2070: LD_ADDR_OWVAR 21
2074: PUSH
2075: LD_INT 1
2077: ST_TO_ADDR
// tmp := [ ] ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: EMPTY
2084: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2085: LD_ADDR_EXP 38
2089: PUSH
2090: LD_STRING Stevens
2092: PPUSH
2093: LD_EXP 1
2097: NOT
2098: PPUSH
2099: LD_STRING 13f_
2101: PPUSH
2102: CALL 62912 0 3
2106: ST_TO_ADDR
// if not Stevens then
2107: LD_EXP 38
2111: NOT
2112: IFFALSE 2168
// begin hc_name = Baker Smith ;
2114: LD_ADDR_OWVAR 26
2118: PUSH
2119: LD_STRING Baker Smith
2121: ST_TO_ADDR
// hc_gallery =  ;
2122: LD_ADDR_OWVAR 33
2126: PUSH
2127: LD_STRING 
2129: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 10
2135: PPUSH
2136: CALL_OW 384
// Baker = CreateHuman ;
2140: LD_ADDR_EXP 52
2144: PUSH
2145: CALL_OW 44
2149: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2150: LD_ADDR_VAR 0 2
2154: PUSH
2155: LD_VAR 0 2
2159: PUSH
2160: LD_EXP 52
2164: ADD
2165: ST_TO_ADDR
// end else
2166: GO 2184
// tmp := tmp ^ Stevens ;
2168: LD_ADDR_VAR 0 2
2172: PUSH
2173: LD_VAR 0 2
2177: PUSH
2178: LD_EXP 38
2182: ADD
2183: ST_TO_ADDR
// if not Lisa then
2184: LD_EXP 39
2188: NOT
2189: IFFALSE 2235
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2191: LD_ADDR_EXP 39
2195: PUSH
2196: LD_STRING Lisa
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13f_
2207: PPUSH
2208: CALL 62912 0 3
2212: ST_TO_ADDR
// if Lisa then
2213: LD_EXP 39
2217: IFFALSE 2235
// tmp := tmp ^ Lisa ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_VAR 0 2
2228: PUSH
2229: LD_EXP 39
2233: ADD
2234: ST_TO_ADDR
// end ; if not Donaldson then
2235: LD_EXP 40
2239: NOT
2240: IFFALSE 2286
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2242: LD_ADDR_EXP 40
2246: PUSH
2247: LD_STRING Donaldson
2249: PPUSH
2250: LD_EXP 1
2254: NOT
2255: PPUSH
2256: LD_STRING 13f_
2258: PPUSH
2259: CALL 62912 0 3
2263: ST_TO_ADDR
// if Donaldson then
2264: LD_EXP 40
2268: IFFALSE 2286
// tmp := tmp ^ Donaldson ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 40
2284: ADD
2285: ST_TO_ADDR
// end ; if not Bobby then
2286: LD_EXP 41
2290: NOT
2291: IFFALSE 2337
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2293: LD_ADDR_EXP 41
2297: PUSH
2298: LD_STRING Bobby
2300: PPUSH
2301: LD_EXP 1
2305: NOT
2306: PPUSH
2307: LD_STRING 13f_
2309: PPUSH
2310: CALL 62912 0 3
2314: ST_TO_ADDR
// if Bobby then
2315: LD_EXP 41
2319: IFFALSE 2337
// tmp := tmp ^ Bobby ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_VAR 0 2
2330: PUSH
2331: LD_EXP 41
2335: ADD
2336: ST_TO_ADDR
// end ; if not Cyrus then
2337: LD_EXP 42
2341: NOT
2342: IFFALSE 2388
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2344: LD_ADDR_EXP 42
2348: PUSH
2349: LD_STRING Cyrus
2351: PPUSH
2352: LD_EXP 1
2356: NOT
2357: PPUSH
2358: LD_STRING 13f_
2360: PPUSH
2361: CALL 62912 0 3
2365: ST_TO_ADDR
// if Cyrus then
2366: LD_EXP 42
2370: IFFALSE 2388
// tmp := tmp ^ Cyrus ;
2372: LD_ADDR_VAR 0 2
2376: PUSH
2377: LD_VAR 0 2
2381: PUSH
2382: LD_EXP 42
2386: ADD
2387: ST_TO_ADDR
// end ; if not Brown then
2388: LD_EXP 44
2392: NOT
2393: IFFALSE 2439
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2395: LD_ADDR_EXP 44
2399: PUSH
2400: LD_STRING Brown
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13f_
2411: PPUSH
2412: CALL 62912 0 3
2416: ST_TO_ADDR
// if Brown then
2417: LD_EXP 44
2421: IFFALSE 2439
// tmp := tmp ^ Brown ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 44
2437: ADD
2438: ST_TO_ADDR
// end ; if not Gladstone then
2439: LD_EXP 45
2443: NOT
2444: IFFALSE 2490
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2446: LD_ADDR_EXP 45
2450: PUSH
2451: LD_STRING Gladstone
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13f_
2462: PPUSH
2463: CALL 62912 0 3
2467: ST_TO_ADDR
// if Gladstone then
2468: LD_EXP 45
2472: IFFALSE 2490
// tmp := tmp ^ Gladstone ;
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 2
2483: PUSH
2484: LD_EXP 45
2488: ADD
2489: ST_TO_ADDR
// end ; if not Houten then
2490: LD_EXP 46
2494: NOT
2495: IFFALSE 2541
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2497: LD_ADDR_EXP 46
2501: PUSH
2502: LD_STRING Houten
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13f_
2513: PPUSH
2514: CALL 62912 0 3
2518: ST_TO_ADDR
// if Houten then
2519: LD_EXP 46
2523: IFFALSE 2541
// tmp := tmp ^ Houten ;
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: LD_VAR 0 2
2534: PUSH
2535: LD_EXP 46
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cornel then
2541: LD_EXP 47
2545: NOT
2546: IFFALSE 2592
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2548: LD_ADDR_EXP 47
2552: PUSH
2553: LD_STRING Cornel
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13f_
2564: PPUSH
2565: CALL 62912 0 3
2569: ST_TO_ADDR
// if Cornel then
2570: LD_EXP 47
2574: IFFALSE 2592
// tmp := tmp ^ Cornel ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_VAR 0 2
2585: PUSH
2586: LD_EXP 47
2590: ADD
2591: ST_TO_ADDR
// end ; if not Gary then
2592: LD_EXP 48
2596: NOT
2597: IFFALSE 2643
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2599: LD_ADDR_EXP 48
2603: PUSH
2604: LD_STRING Gary
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13f_
2615: PPUSH
2616: CALL 62912 0 3
2620: ST_TO_ADDR
// if Gary then
2621: LD_EXP 48
2625: IFFALSE 2643
// tmp := tmp ^ Gary ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: LD_EXP 48
2641: ADD
2642: ST_TO_ADDR
// end ; if not Frank then
2643: LD_EXP 49
2647: NOT
2648: IFFALSE 2694
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2650: LD_ADDR_EXP 49
2654: PUSH
2655: LD_STRING Frank
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13f_
2666: PPUSH
2667: CALL 62912 0 3
2671: ST_TO_ADDR
// if Frank then
2672: LD_EXP 49
2676: IFFALSE 2694
// tmp := tmp ^ Frank ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 49
2692: ADD
2693: ST_TO_ADDR
// end ; if not Kikuchi then
2694: LD_EXP 50
2698: NOT
2699: IFFALSE 2745
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2701: LD_ADDR_EXP 50
2705: PUSH
2706: LD_STRING Kikuchi
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13f_
2717: PPUSH
2718: CALL 62912 0 3
2722: ST_TO_ADDR
// if Kikuchi then
2723: LD_EXP 50
2727: IFFALSE 2745
// tmp := tmp ^ Kikuchi ;
2729: LD_ADDR_VAR 0 2
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: LD_EXP 50
2743: ADD
2744: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2745: LD_ADDR_VAR 0 2
2749: PUSH
2750: LD_VAR 0 2
2754: PUSH
2755: LD_STRING 13_other_survivors
2757: PPUSH
2758: CALL_OW 31
2762: UNION
2763: ST_TO_ADDR
// result := tmp ;
2764: LD_ADDR_VAR 0 1
2768: PUSH
2769: LD_VAR 0 2
2773: ST_TO_ADDR
// end ; end_of_file
2774: LD_VAR 0 1
2778: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
2783: PPUSH
2784: PPUSH
2785: PPUSH
2786: PPUSH
2787: PPUSH
2788: PPUSH
2789: PPUSH
2790: PPUSH
// uc_side := 4 ;
2791: LD_ADDR_OWVAR 20
2795: PUSH
2796: LD_INT 4
2798: ST_TO_ADDR
// uc_nation := 1 ;
2799: LD_ADDR_OWVAR 21
2803: PUSH
2804: LD_INT 1
2806: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2807: LD_INT 387
2809: PPUSH
2810: CALL_OW 274
2814: PPUSH
2815: LD_INT 1
2817: PPUSH
2818: LD_INT 2500
2820: PPUSH
2821: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2825: LD_INT 387
2827: PPUSH
2828: CALL_OW 274
2832: PPUSH
2833: LD_INT 2
2835: PPUSH
2836: LD_INT 400
2838: PPUSH
2839: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2843: LD_INT 387
2845: PPUSH
2846: CALL_OW 274
2850: PPUSH
2851: LD_INT 3
2853: PPUSH
2854: LD_INT 10
2856: PPUSH
2857: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2861: LD_ADDR_EXP 55
2865: PUSH
2866: LD_STRING Powell
2868: PPUSH
2869: CALL_OW 25
2873: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2874: LD_EXP 55
2878: PPUSH
2879: LD_INT 57
2881: PPUSH
2882: LD_INT 94
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2892: LD_EXP 55
2896: PPUSH
2897: LD_INT 58
2899: PPUSH
2900: LD_INT 94
2902: PPUSH
2903: CALL_OW 118
// vip := [ ] ;
2907: LD_ADDR_EXP 56
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// tmp := [ ] ;
2914: LD_ADDR_VAR 0 6
2918: PUSH
2919: EMPTY
2920: ST_TO_ADDR
// if JMMGirl <> 2 then
2921: LD_EXP 7
2925: PUSH
2926: LD_INT 2
2928: NONEQUAL
2929: IFFALSE 2953
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2931: LD_ADDR_EXP 39
2935: PUSH
2936: LD_STRING Lisa
2938: PPUSH
2939: LD_EXP 1
2943: NOT
2944: PPUSH
2945: LD_STRING 13s_
2947: PPUSH
2948: CALL 62912 0 3
2952: ST_TO_ADDR
// if Lisa then
2953: LD_EXP 39
2957: IFFALSE 2975
// tmp := tmp ^ Lisa ;
2959: LD_ADDR_VAR 0 6
2963: PUSH
2964: LD_VAR 0 6
2968: PUSH
2969: LD_EXP 39
2973: ADD
2974: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2975: LD_ADDR_EXP 40
2979: PUSH
2980: LD_STRING Donaldson
2982: PPUSH
2983: LD_EXP 1
2987: NOT
2988: PPUSH
2989: LD_STRING 13s_
2991: PPUSH
2992: CALL 62912 0 3
2996: ST_TO_ADDR
// if Donaldson then
2997: LD_EXP 40
3001: IFFALSE 3019
// tmp := tmp ^ Donaldson ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: LD_VAR 0 6
3012: PUSH
3013: LD_EXP 40
3017: ADD
3018: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3019: LD_ADDR_EXP 41
3023: PUSH
3024: LD_STRING Bobby
3026: PPUSH
3027: LD_EXP 1
3031: NOT
3032: PPUSH
3033: LD_STRING 13s_
3035: PPUSH
3036: CALL 62912 0 3
3040: ST_TO_ADDR
// if Bobby then
3041: LD_EXP 41
3045: IFFALSE 3063
// tmp := tmp ^ Bobby ;
3047: LD_ADDR_VAR 0 6
3051: PUSH
3052: LD_VAR 0 6
3056: PUSH
3057: LD_EXP 41
3061: ADD
3062: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 42
3067: PUSH
3068: LD_STRING Cyrus
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 62912 0 3
3084: ST_TO_ADDR
// if Cyrus then
3085: LD_EXP 42
3089: IFFALSE 3107
// tmp := tmp ^ Cyrus ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 42
3105: ADD
3106: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 43
3111: PUSH
3112: LD_STRING Denis
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 62912 0 3
3128: ST_TO_ADDR
// if not Denis then
3129: LD_EXP 43
3133: NOT
3134: IFFALSE 3158
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 43
3140: PUSH
3141: LD_STRING Denis
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 62912 0 3
3157: ST_TO_ADDR
// if Denis then
3158: LD_EXP 43
3162: IFFALSE 3180
// tmp := tmp ^ Denis ;
3164: LD_ADDR_VAR 0 6
3168: PUSH
3169: LD_VAR 0 6
3173: PUSH
3174: LD_EXP 43
3178: ADD
3179: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3180: LD_ADDR_EXP 44
3184: PUSH
3185: LD_STRING Brown
3187: PPUSH
3188: LD_EXP 1
3192: NOT
3193: PPUSH
3194: LD_STRING 13s_
3196: PPUSH
3197: CALL 62912 0 3
3201: ST_TO_ADDR
// if Brown then
3202: LD_EXP 44
3206: IFFALSE 3224
// tmp := tmp ^ Brown ;
3208: LD_ADDR_VAR 0 6
3212: PUSH
3213: LD_VAR 0 6
3217: PUSH
3218: LD_EXP 44
3222: ADD
3223: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3224: LD_ADDR_EXP 45
3228: PUSH
3229: LD_STRING Gladstone
3231: PPUSH
3232: LD_EXP 1
3236: NOT
3237: PPUSH
3238: LD_STRING 13s_
3240: PPUSH
3241: CALL 62912 0 3
3245: ST_TO_ADDR
// if Gladstone then
3246: LD_EXP 45
3250: IFFALSE 3268
// tmp := tmp ^ Gladstone ;
3252: LD_ADDR_VAR 0 6
3256: PUSH
3257: LD_VAR 0 6
3261: PUSH
3262: LD_EXP 45
3266: ADD
3267: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3268: LD_ADDR_EXP 46
3272: PUSH
3273: LD_STRING Houten
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13s_
3284: PPUSH
3285: CALL 62912 0 3
3289: ST_TO_ADDR
// if Houten then
3290: LD_EXP 46
3294: IFFALSE 3312
// tmp := tmp ^ Houten ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 46
3310: ADD
3311: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 47
3316: PUSH
3317: LD_STRING Cornel
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 62912 0 3
3333: ST_TO_ADDR
// if Cornel then
3334: LD_EXP 47
3338: IFFALSE 3356
// tmp := tmp ^ Cornel ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 47
3354: ADD
3355: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 48
3360: PUSH
3361: LD_STRING Gary
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 62912 0 3
3377: ST_TO_ADDR
// if Gary then
3378: LD_EXP 48
3382: IFFALSE 3400
// tmp := tmp ^ Gary ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 48
3398: ADD
3399: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 49
3404: PUSH
3405: LD_STRING Frank
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 62912 0 3
3421: ST_TO_ADDR
// if Frank then
3422: LD_EXP 49
3426: IFFALSE 3444
// tmp := tmp ^ Frank ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 49
3442: ADD
3443: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 50
3448: PUSH
3449: LD_STRING Kikuchi
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 62912 0 3
3465: ST_TO_ADDR
// if Kikuchi then
3466: LD_EXP 50
3470: IFFALSE 3488
// tmp := tmp ^ Kikuchi ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 50
3486: ADD
3487: ST_TO_ADDR
// vip := tmp ;
3488: LD_ADDR_EXP 56
3492: PUSH
3493: LD_VAR 0 6
3497: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3498: LD_ADDR_VAR 0 6
3502: PUSH
3503: LD_VAR 0 6
3507: PUSH
3508: LD_STRING 13s_others
3510: PPUSH
3511: CALL_OW 31
3515: UNION
3516: ST_TO_ADDR
// if tmp < 20 then
3517: LD_VAR 0 6
3521: PUSH
3522: LD_INT 20
3524: LESS
3525: IFFALSE 3592
// for i = 1 to 20 - tmp do
3527: LD_ADDR_VAR 0 2
3531: PUSH
3532: DOUBLE
3533: LD_INT 1
3535: DEC
3536: ST_TO_ADDR
3537: LD_INT 20
3539: PUSH
3540: LD_VAR 0 6
3544: MINUS
3545: PUSH
3546: FOR_TO
3547: IFFALSE 3590
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3549: LD_INT 1
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 4
3559: MOD
3560: PUSH
3561: LD_INT 1
3563: PLUS
3564: PPUSH
3565: LD_INT 5
3567: PPUSH
3568: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3572: LD_ADDR_VAR 0 6
3576: PUSH
3577: LD_VAR 0 6
3581: PUSH
3582: CALL_OW 44
3586: ADD
3587: ST_TO_ADDR
// end ;
3588: GO 3546
3590: POP
3591: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3592: LD_ADDR_VAR 0 7
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 4
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 0
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3630: LD_ADDR_VAR 0 8
3634: PUSH
3635: LD_INT 22
3637: PUSH
3638: LD_INT 4
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 30
3647: PUSH
3648: LD_INT 6
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PPUSH
3659: CALL_OW 69
3663: PUSH
3664: LD_INT 1
3666: ARRAY
3667: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3668: LD_ADDR_VAR 0 9
3672: PUSH
3673: LD_INT 22
3675: PUSH
3676: LD_INT 4
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 30
3685: PUSH
3686: LD_INT 4
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 69
3701: PUSH
3702: LD_INT 1
3704: ARRAY
3705: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3706: LD_ADDR_VAR 0 10
3710: PUSH
3711: LD_INT 22
3713: PUSH
3714: LD_INT 4
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 30
3723: PUSH
3724: LD_INT 2
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PPUSH
3735: CALL_OW 69
3739: PUSH
3740: LD_INT 1
3742: ARRAY
3743: ST_TO_ADDR
// for i in tmp do
3744: LD_ADDR_VAR 0 2
3748: PUSH
3749: LD_VAR 0 6
3753: PUSH
3754: FOR_IN
3755: IFFALSE 3881
// begin cl := GetClass ( i ) ;
3757: LD_ADDR_VAR 0 5
3761: PUSH
3762: LD_VAR 0 2
3766: PPUSH
3767: CALL_OW 257
3771: ST_TO_ADDR
// if cl > 4 then
3772: LD_VAR 0 5
3776: PUSH
3777: LD_INT 4
3779: GREATER
3780: IFFALSE 3790
// cl := 1 ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_INT 1
3789: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3790: LD_ADDR_VAR 0 3
3794: PUSH
3795: LD_VAR 0 9
3799: PUSH
3800: LD_VAR 0 7
3804: PUSH
3805: LD_VAR 0 10
3809: PUSH
3810: LD_VAR 0 8
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: PUSH
3821: LD_VAR 0 5
3825: ARRAY
3826: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3827: LD_VAR 0 3
3831: PPUSH
3832: CALL_OW 313
3836: PUSH
3837: LD_INT 5
3839: LESS
3840: IFFALSE 3858
// PlaceHumanInUnit ( i , b ) else
3842: LD_VAR 0 2
3846: PPUSH
3847: LD_VAR 0 3
3851: PPUSH
3852: CALL_OW 52
3856: GO 3879
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3858: LD_VAR 0 2
3862: PPUSH
3863: LD_INT 58
3865: PPUSH
3866: LD_INT 91
3868: PPUSH
3869: LD_INT 6
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 50
// end ;
3879: GO 3754
3881: POP
3882: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3883: LD_INT 2
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 12
3894: PPUSH
3895: LD_INT 100
3897: PPUSH
3898: CALL 69515 0 5
// veh := CreateVehicle ;
3902: LD_ADDR_VAR 0 4
3906: PUSH
3907: CALL_OW 45
3911: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3912: LD_VAR 0 4
3916: PPUSH
3917: LD_INT 4
3919: PPUSH
3920: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3924: LD_VAR 0 4
3928: PPUSH
3929: LD_INT 49
3931: PPUSH
3932: LD_INT 88
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 1
3949: PPUSH
3950: LD_INT 100
3952: PPUSH
3953: CALL_OW 290
// uc_side := 0 ;
3957: LD_ADDR_OWVAR 20
3961: PUSH
3962: LD_INT 0
3964: ST_TO_ADDR
// uc_nation := 0 ;
3965: LD_ADDR_OWVAR 21
3969: PUSH
3970: LD_INT 0
3972: ST_TO_ADDR
// for i = 1 to 4 do
3973: LD_ADDR_VAR 0 2
3977: PUSH
3978: DOUBLE
3979: LD_INT 1
3981: DEC
3982: ST_TO_ADDR
3983: LD_INT 4
3985: PUSH
3986: FOR_TO
3987: IFFALSE 4018
// begin InitHc ;
3989: CALL_OW 19
// hc_class := class_apeman ;
3993: LD_ADDR_OWVAR 28
3997: PUSH
3998: LD_INT 12
4000: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4001: CALL_OW 44
4005: PPUSH
4006: LD_INT 13
4008: PPUSH
4009: LD_INT 0
4011: PPUSH
4012: CALL_OW 49
// end ;
4016: GO 3986
4018: POP
4019: POP
// end ; end_of_file
4020: LD_VAR 0 1
4024: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4025: LD_INT 0
4027: PPUSH
4028: PPUSH
4029: PPUSH
4030: PPUSH
4031: PPUSH
// side := 8 ;
4032: LD_ADDR_VAR 0 3
4036: PUSH
4037: LD_INT 8
4039: ST_TO_ADDR
// uc_side := side ;
4040: LD_ADDR_OWVAR 20
4044: PUSH
4045: LD_VAR 0 3
4049: ST_TO_ADDR
// uc_nation := 2 ;
4050: LD_ADDR_OWVAR 21
4054: PUSH
4055: LD_INT 2
4057: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4058: LD_ADDR_VAR 0 2
4062: PUSH
4063: LD_INT 22
4065: PUSH
4066: LD_VAR 0 3
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: LD_INT 21
4077: PUSH
4078: LD_INT 3
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: PPUSH
4089: CALL_OW 69
4093: PUSH
4094: FOR_IN
4095: IFFALSE 4111
// SetBLevel ( i , 10 ) ;
4097: LD_VAR 0 2
4101: PPUSH
4102: LD_INT 10
4104: PPUSH
4105: CALL_OW 241
4109: GO 4094
4111: POP
4112: POP
// if KurtStatus then
4113: LD_EXP 3
4117: IFFALSE 4140
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4119: LD_ADDR_EXP 57
4123: PUSH
4124: LD_STRING Kurt
4126: PPUSH
4127: LD_INT 0
4129: PPUSH
4130: LD_STRING 
4132: PPUSH
4133: CALL 62912 0 3
4137: ST_TO_ADDR
4138: GO 4162
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4140: LD_ADDR_EXP 57
4144: PUSH
4145: LD_STRING AltKurt
4147: PPUSH
4148: LD_EXP 1
4152: NOT
4153: PPUSH
4154: LD_STRING 
4156: PPUSH
4157: CALL 62912 0 3
4161: ST_TO_ADDR
// if not Kurt then
4162: LD_EXP 57
4166: NOT
4167: IFFALSE 4193
// begin InitHc ;
4169: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 10
4178: PPUSH
4179: CALL_OW 381
// Kurt := CreateHuman ;
4183: LD_ADDR_EXP 57
4187: PUSH
4188: CALL_OW 44
4192: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4193: LD_EXP 57
4197: PPUSH
4198: LD_INT 324
4200: PPUSH
4201: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4205: LD_ADDR_EXP 58
4209: PUSH
4210: LD_STRING Kozlov
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: LD_STRING 
4218: PPUSH
4219: CALL 62912 0 3
4223: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4224: LD_EXP 58
4228: PPUSH
4229: LD_INT 22
4231: PUSH
4232: LD_INT 8
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 23
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 8
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 69
4268: PUSH
4269: LD_INT 1
4271: ARRAY
4272: PPUSH
4273: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4277: LD_EXP 58
4281: PPUSH
4282: LD_INT 3
4284: PPUSH
4285: LD_INT 10
4287: PPUSH
4288: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4292: LD_ADDR_VAR 0 5
4296: PUSH
4297: LD_INT 22
4299: PUSH
4300: LD_VAR 0 3
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 30
4311: PUSH
4312: LD_INT 32
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 58
4321: PUSH
4322: EMPTY
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// for i = 1 to 10 do
4335: LD_ADDR_VAR 0 2
4339: PUSH
4340: DOUBLE
4341: LD_INT 1
4343: DEC
4344: ST_TO_ADDR
4345: LD_INT 10
4347: PUSH
4348: FOR_TO
4349: IFFALSE 4421
// begin uc_nation := nation_nature ;
4351: LD_ADDR_OWVAR 21
4355: PUSH
4356: LD_INT 0
4358: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4359: LD_ADDR_OWVAR 28
4363: PUSH
4364: LD_INT 15
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_name :=  ;
4375: LD_ADDR_OWVAR 26
4379: PUSH
4380: LD_STRING 
4382: ST_TO_ADDR
// un := CreateHuman ;
4383: LD_ADDR_VAR 0 4
4387: PUSH
4388: CALL_OW 44
4392: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4393: LD_VAR 0 4
4397: PPUSH
4398: LD_VAR 0 5
4402: PUSH
4403: LD_VAR 0 5
4407: PUSH
4408: LD_VAR 0 2
4412: MINUS
4413: ARRAY
4414: PPUSH
4415: CALL_OW 52
// end ;
4419: GO 4348
4421: POP
4422: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4423: LD_ADDR_VAR 0 5
4427: PUSH
4428: LD_STRING 12_kurt_squad
4430: PPUSH
4431: CALL_OW 31
4435: ST_TO_ADDR
// if tmp then
4436: LD_VAR 0 5
4440: IFFALSE 4474
// for i in tmp do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: LD_VAR 0 5
4451: PUSH
4452: FOR_IN
4453: IFFALSE 4472
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4455: LD_VAR 0 2
4459: PPUSH
4460: LD_INT 5
4462: PPUSH
4463: LD_INT 0
4465: PPUSH
4466: CALL_OW 49
4470: GO 4452
4472: POP
4473: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4474: LD_INT 324
4476: PPUSH
4477: LD_INT 5
4479: PPUSH
4480: LD_STRING 
4482: PPUSH
4483: LD_INT 8
4485: PUSH
4486: LD_INT 9
4488: PUSH
4489: LD_INT 10
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: LD_OWVAR 67
4501: ARRAY
4502: PPUSH
4503: LD_INT 3000
4505: PUSH
4506: LD_INT 500
4508: PUSH
4509: LD_INT 150
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: PPUSH
4517: LD_INT 16
4519: PUSH
4520: LD_INT 6
4522: PUSH
4523: LD_INT 6
4525: PUSH
4526: LD_INT 8
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL 72924 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4539: LD_ADDR_EXP 99
4543: PUSH
4544: LD_EXP 99
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 22
4554: PUSH
4555: LD_VAR 0 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 23
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: LD_INT 3
4576: PUSH
4577: LD_INT 21
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: PPUSH
4596: CALL_OW 69
4600: PUSH
4601: LD_EXP 57
4605: DIFF
4606: PPUSH
4607: CALL_OW 1
4611: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4612: LD_INT 1
4614: PPUSH
4615: LD_INT 7
4617: PPUSH
4618: CALL_OW 383
// Friend := CreateHuman ;
4622: LD_ADDR_EXP 59
4626: PUSH
4627: CALL_OW 44
4631: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4632: LD_INT 14
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_INT 29
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 69515 0 5
// powellBomb := CreateVehicle ;
4651: LD_ADDR_EXP 60
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4661: LD_EXP 60
4665: PPUSH
4666: LD_INT 90
4668: PPUSH
4669: LD_INT 51
4671: PPUSH
4672: LD_INT 0
4674: PPUSH
4675: CALL_OW 48
// end ;
4679: LD_VAR 0 1
4683: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
// if IsLive ( kozlov_fac ) then
4689: LD_INT 332
4691: PPUSH
4692: CALL_OW 300
4696: IFFALSE 4700
// exit ;
4698: GO 5267
// ComExitBuilding ( Kozlov ) ;
4700: LD_EXP 58
4704: PPUSH
4705: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4709: LD_EXP 58
4713: PPUSH
4714: CALL_OW 257
4718: PUSH
4719: LD_INT 2
4721: NONEQUAL
4722: IFFALSE 4757
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4724: LD_EXP 58
4728: PPUSH
4729: LD_INT 324
4731: PPUSH
4732: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4736: LD_EXP 58
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4748: LD_EXP 58
4752: PPUSH
4753: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4757: LD_EXP 58
4761: PPUSH
4762: LD_INT 2
4764: PPUSH
4765: LD_INT 93
4767: PPUSH
4768: LD_INT 32
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4778: LD_INT 35
4780: PPUSH
4781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4785: LD_INT 22
4787: PUSH
4788: LD_INT 8
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 30
4797: PUSH
4798: LD_INT 3
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 23
4807: PUSH
4808: LD_INT 3
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 57
4817: PUSH
4818: EMPTY
4819: LIST
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: PPUSH
4827: CALL_OW 69
4831: IFFALSE 4778
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4833: LD_ADDR_VAR 0 2
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 8
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 30
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 23
4860: PUSH
4861: LD_INT 3
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 57
4870: PUSH
4871: EMPTY
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: PPUSH
4880: CALL_OW 69
4884: PUSH
4885: LD_INT 1
4887: ARRAY
4888: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4889: LD_INT 22
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: LD_INT 23
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PUSH
4909: LD_INT 30
4911: PUSH
4912: LD_INT 21
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 69
4928: NOT
4929: IFFALSE 5007
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4931: LD_EXP 58
4935: PPUSH
4936: LD_INT 21
4938: PPUSH
4939: LD_INT 97
4941: PPUSH
4942: LD_INT 36
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4952: LD_INT 35
4954: PPUSH
4955: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4959: LD_INT 22
4961: PUSH
4962: LD_INT 8
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 23
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 30
4981: PUSH
4982: LD_INT 21
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 57
4991: PUSH
4992: EMPTY
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 69
5005: IFFALSE 4952
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5007: LD_INT 22
5009: PUSH
5010: LD_INT 8
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 23
5019: PUSH
5020: LD_INT 3
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 18
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 69
5046: NOT
5047: IFFALSE 5125
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5049: LD_EXP 58
5053: PPUSH
5054: LD_INT 18
5056: PPUSH
5057: LD_INT 89
5059: PPUSH
5060: LD_INT 32
5062: PPUSH
5063: LD_INT 1
5065: PPUSH
5066: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5070: LD_INT 35
5072: PPUSH
5073: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5077: LD_INT 22
5079: PUSH
5080: LD_INT 8
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 23
5089: PUSH
5090: LD_INT 3
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 30
5099: PUSH
5100: LD_INT 18
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 57
5109: PUSH
5110: EMPTY
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 69
5123: IFFALSE 5070
// end ; lab := kozlov_lab ;
5125: LD_ADDR_VAR 0 3
5129: PUSH
5130: LD_INT 336
5132: ST_TO_ADDR
// if not lab then
5133: LD_VAR 0 3
5137: NOT
5138: IFFALSE 5142
// exit ;
5140: GO 5267
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5142: LD_EXP 58
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5160: LD_EXP 58
5164: PPUSH
5165: LD_INT 4
5167: PPUSH
5168: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5172: LD_VAR 0 3
5176: PUSH
5177: LD_INT 1
5179: ARRAY
5180: PPUSH
5181: LD_INT 25
5183: PPUSH
5184: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5195: LD_INT 25
5197: PPUSH
5198: LD_INT 8
5200: PPUSH
5201: CALL_OW 321
5205: PUSH
5206: LD_INT 2
5208: EQUAL
5209: IFFALSE 5188
// ComExitBuilding ( Kozlov ) ;
5211: LD_EXP 58
5215: PPUSH
5216: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5220: LD_EXP 58
5224: PPUSH
5225: LD_VAR 0 2
5229: PPUSH
5230: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5234: LD_EXP 58
5238: PPUSH
5239: LD_INT 3
5241: PPUSH
5242: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5246: LD_VAR 0 2
5250: PPUSH
5251: LD_INT 23
5253: PPUSH
5254: LD_INT 3
5256: PPUSH
5257: LD_INT 1
5259: PPUSH
5260: LD_INT 48
5262: PPUSH
5263: CALL_OW 125
// end ;
5267: LD_VAR 0 1
5271: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5272: LD_EXP 22
5276: NOT
5277: PUSH
5278: LD_EXP 15
5282: PUSH
5283: LD_INT 6
5285: GREATEREQUAL
5286: AND
5287: IFFALSE 5368
5289: GO 5291
5291: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: CALL 57047 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5302: LD_INT 3
5304: PPUSH
5305: LD_INT 14
5307: PUSH
5308: LD_INT 1
5310: PUSH
5311: LD_INT 1
5313: PUSH
5314: LD_INT 28
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 14
5325: PUSH
5326: LD_INT 1
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: LD_INT 28
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 14
5343: PUSH
5344: LD_INT 1
5346: PUSH
5347: LD_INT 1
5349: PUSH
5350: LD_INT 28
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL 56910 0 2
// end ;
5368: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5369: LD_EXP 22
5373: NOT
5374: PUSH
5375: LD_EXP 15
5379: PUSH
5380: LD_INT 6
5382: GREATEREQUAL
5383: AND
5384: PUSH
5385: LD_INT 3
5387: PPUSH
5388: LD_INT 1
5390: PPUSH
5391: CALL 58265 0 2
5395: NOT
5396: AND
5397: IFFALSE 6237
5399: GO 5401
5401: DISABLE
5402: LD_INT 0
5404: PPUSH
5405: PPUSH
5406: PPUSH
// begin enable ;
5407: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5408: LD_INT 22
5410: PUSH
5411: LD_INT 8
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PUSH
5418: LD_INT 23
5420: PUSH
5421: LD_INT 2
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PUSH
5428: LD_INT 30
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: NOT
5448: IFFALSE 5452
// exit ;
5450: GO 6237
// if Prob ( 40 ) then
5452: LD_INT 40
5454: PPUSH
5455: CALL_OW 13
5459: IFFALSE 5586
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5461: LD_INT 3
5463: PPUSH
5464: LD_INT 14
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 2
5472: PUSH
5473: LD_INT 28
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PUSH
5482: LD_INT 14
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 2
5490: PUSH
5491: LD_INT 28
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_INT 14
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 2
5508: PUSH
5509: LD_INT 28
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PUSH
5518: LD_INT 14
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: LD_INT 2
5526: PUSH
5527: LD_INT 28
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_INT 14
5538: PUSH
5539: LD_INT 1
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 28
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 14
5556: PUSH
5557: LD_INT 1
5559: PUSH
5560: LD_INT 2
5562: PUSH
5563: LD_INT 26
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL 56910 0 2
// end else
5584: GO 5777
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5586: LD_INT 3
5588: PPUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 27
5600: PUSH
5601: LD_INT 26
5603: PUSH
5604: LD_INT 26
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_OWVAR 67
5616: ARRAY
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 14
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 27
5635: PUSH
5636: LD_INT 26
5638: PUSH
5639: LD_INT 26
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: PUSH
5647: LD_OWVAR 67
5651: ARRAY
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 14
5661: PUSH
5662: LD_INT 1
5664: PUSH
5665: LD_INT 2
5667: PUSH
5668: LD_INT 26
5670: PUSH
5671: LD_INT 26
5673: PUSH
5674: LD_INT 29
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_OWVAR 67
5686: ARRAY
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: PUSH
5694: LD_INT 13
5696: PUSH
5697: LD_INT 1
5699: PUSH
5700: LD_INT 2
5702: PUSH
5703: LD_INT 26
5705: PUSH
5706: LD_INT 29
5708: PUSH
5709: LD_INT 29
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: PUSH
5717: LD_OWVAR 67
5721: ARRAY
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 13
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 29
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 14
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 26
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PPUSH
5773: CALL 56910 0 2
// end ; repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 1
5789: PPUSH
5790: CALL 58265 0 2
5794: PUSH
5795: LD_INT 6
5797: GREATEREQUAL
5798: IFFALSE 5777
// wait ( 0 0$30 ) ;
5800: LD_INT 1050
5802: PPUSH
5803: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: LD_INT 3
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL 58265 0 2
5822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5823: LD_ADDR_EXP 118
5827: PUSH
5828: LD_EXP 118
5832: PPUSH
5833: LD_INT 3
5835: PPUSH
5836: LD_EXP 118
5840: PUSH
5841: LD_INT 3
5843: ARRAY
5844: PUSH
5845: LD_VAR 0 2
5849: DIFF
5850: PPUSH
5851: CALL_OW 1
5855: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5856: LD_ADDR_VAR 0 3
5860: PUSH
5861: LD_INT 0
5863: PPUSH
5864: LD_INT 2
5866: PPUSH
5867: CALL_OW 12
5871: ST_TO_ADDR
// if target then
5872: LD_VAR 0 3
5876: IFFALSE 6004
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5878: LD_ADDR_VAR 0 2
5882: PUSH
5883: LD_VAR 0 2
5887: PPUSH
5888: LD_INT 24
5890: PUSH
5891: LD_INT 250
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PPUSH
5898: CALL_OW 72
5902: ST_TO_ADDR
// for i in tmp do
5903: LD_ADDR_VAR 0 1
5907: PUSH
5908: LD_VAR 0 2
5912: PUSH
5913: FOR_IN
5914: IFFALSE 5954
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5916: LD_VAR 0 1
5920: PPUSH
5921: LD_INT 89
5923: PPUSH
5924: LD_INT 71
5926: PPUSH
5927: CALL_OW 297
5931: PUSH
5932: LD_INT 9
5934: GREATER
5935: IFFALSE 5952
// ComMoveXY ( i , 89 , 71 ) ;
5937: LD_VAR 0 1
5941: PPUSH
5942: LD_INT 89
5944: PPUSH
5945: LD_INT 71
5947: PPUSH
5948: CALL_OW 111
5952: GO 5913
5954: POP
5955: POP
// wait ( 0 0$1 ) ;
5956: LD_INT 35
5958: PPUSH
5959: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5963: LD_VAR 0 2
5967: PPUSH
5968: LD_INT 92
5970: PUSH
5971: LD_INT 89
5973: PUSH
5974: LD_INT 71
5976: PUSH
5977: LD_INT 9
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PPUSH
5986: CALL_OW 72
5990: PUSH
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: MINUS
5999: GREATEREQUAL
6000: IFFALSE 5878
// end else
6002: GO 6128
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 24
6016: PUSH
6017: LD_INT 250
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 72
6028: ST_TO_ADDR
// for i in tmp do
6029: LD_ADDR_VAR 0 1
6033: PUSH
6034: LD_VAR 0 2
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6080
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6042: LD_VAR 0 1
6046: PPUSH
6047: LD_INT 125
6049: PPUSH
6050: LD_INT 129
6052: PPUSH
6053: CALL_OW 297
6057: PUSH
6058: LD_INT 9
6060: GREATER
6061: IFFALSE 6078
// ComMoveXY ( i , 125 , 129 ) ;
6063: LD_VAR 0 1
6067: PPUSH
6068: LD_INT 125
6070: PPUSH
6071: LD_INT 129
6073: PPUSH
6074: CALL_OW 111
6078: GO 6039
6080: POP
6081: POP
// wait ( 0 0$1 ) ;
6082: LD_INT 35
6084: PPUSH
6085: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6089: LD_VAR 0 2
6093: PPUSH
6094: LD_INT 92
6096: PUSH
6097: LD_INT 125
6099: PUSH
6100: LD_INT 129
6102: PUSH
6103: LD_INT 9
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PPUSH
6112: CALL_OW 72
6116: PUSH
6117: LD_VAR 0 2
6121: PUSH
6122: LD_INT 1
6124: MINUS
6125: GREATEREQUAL
6126: IFFALSE 6004
// end ; repeat wait ( 0 0$1 ) ;
6128: LD_INT 35
6130: PPUSH
6131: CALL_OW 67
// for i in tmp do
6135: LD_ADDR_VAR 0 1
6139: PUSH
6140: LD_VAR 0 2
6144: PUSH
6145: FOR_IN
6146: IFFALSE 6228
// begin if GetLives ( i ) > 251 then
6148: LD_VAR 0 1
6152: PPUSH
6153: CALL_OW 256
6157: PUSH
6158: LD_INT 251
6160: GREATER
6161: IFFALSE 6199
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6163: LD_VAR 0 1
6167: PPUSH
6168: LD_INT 81
6170: PUSH
6171: LD_INT 8
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PPUSH
6178: CALL_OW 69
6182: PPUSH
6183: LD_VAR 0 1
6187: PPUSH
6188: CALL_OW 74
6192: PPUSH
6193: CALL_OW 115
6197: GO 6226
// if IsDead ( i ) then
6199: LD_VAR 0 1
6203: PPUSH
6204: CALL_OW 301
6208: IFFALSE 6226
// tmp := tmp diff i ;
6210: LD_ADDR_VAR 0 2
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_VAR 0 1
6224: DIFF
6225: ST_TO_ADDR
// end ;
6226: GO 6145
6228: POP
6229: POP
// until not tmp ;
6230: LD_VAR 0 2
6234: NOT
6235: IFFALSE 6128
// end ;
6237: PPOPN 3
6239: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6240: LD_EXP 22
6244: NOT
6245: PUSH
6246: LD_EXP 15
6250: PUSH
6251: LD_INT 6
6253: GREATEREQUAL
6254: AND
6255: PUSH
6256: LD_OWVAR 67
6260: PUSH
6261: LD_INT 1
6263: GREATER
6264: AND
6265: IFFALSE 6782
6267: GO 6269
6269: DISABLE
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
6274: PPUSH
// begin enable ;
6275: ENABLE
// tmp := [ ] ;
6276: LD_ADDR_VAR 0 3
6280: PUSH
6281: EMPTY
6282: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: DOUBLE
6289: LD_INT 1
6291: DEC
6292: ST_TO_ADDR
6293: LD_INT 4
6295: PUSH
6296: LD_INT 6
6298: PUSH
6299: LD_INT 7
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: PUSH
6307: LD_OWVAR 67
6311: ARRAY
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6474
// begin uc_side := 8 ;
6316: LD_ADDR_OWVAR 20
6320: PUSH
6321: LD_INT 8
6323: ST_TO_ADDR
// uc_nation := 2 ;
6324: LD_ADDR_OWVAR 21
6328: PUSH
6329: LD_INT 2
6331: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6332: LD_INT 13
6334: PUSH
6335: LD_INT 14
6337: PUSH
6338: EMPTY
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 1
6344: PPUSH
6345: LD_INT 2
6347: PPUSH
6348: CALL_OW 12
6352: ARRAY
6353: PPUSH
6354: LD_INT 1
6356: PPUSH
6357: LD_INT 5
6359: PPUSH
6360: LD_INT 27
6362: PUSH
6363: LD_INT 28
6365: PUSH
6366: LD_INT 26
6368: PUSH
6369: LD_INT 25
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 4
6383: PPUSH
6384: CALL_OW 12
6388: ARRAY
6389: PPUSH
6390: LD_INT 88
6392: PPUSH
6393: CALL 69515 0 5
// un := CreateVehicle ;
6397: LD_ADDR_VAR 0 2
6401: PUSH
6402: CALL_OW 45
6406: ST_TO_ADDR
// tmp := tmp ^ un ;
6407: LD_ADDR_VAR 0 3
6411: PUSH
6412: LD_VAR 0 3
6416: PUSH
6417: LD_VAR 0 2
6421: ADD
6422: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6423: LD_VAR 0 2
6427: PPUSH
6428: LD_INT 3
6430: PPUSH
6431: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6435: LD_VAR 0 2
6439: PPUSH
6440: LD_INT 30
6442: PPUSH
6443: LD_INT 0
6445: PPUSH
6446: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6450: LD_VAR 0 2
6454: PPUSH
6455: LD_INT 16
6457: PPUSH
6458: LD_INT 11
6460: PPUSH
6461: CALL_OW 111
// wait ( 0 0$2 ) ;
6465: LD_INT 70
6467: PPUSH
6468: CALL_OW 67
// end ;
6472: GO 6313
6474: POP
6475: POP
// for i = 1 to Difficulty do
6476: LD_ADDR_VAR 0 1
6480: PUSH
6481: DOUBLE
6482: LD_INT 1
6484: DEC
6485: ST_TO_ADDR
6486: LD_OWVAR 67
6490: PUSH
6491: FOR_TO
6492: IFFALSE 6617
// begin uc_side := 8 ;
6494: LD_ADDR_OWVAR 20
6498: PUSH
6499: LD_INT 8
6501: ST_TO_ADDR
// uc_nation := 2 ;
6502: LD_ADDR_OWVAR 21
6506: PUSH
6507: LD_INT 2
6509: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6510: LD_INT 0
6512: PPUSH
6513: LD_INT 8
6515: PPUSH
6516: LD_INT 8
6518: PUSH
6519: LD_INT 8
6521: PUSH
6522: LD_INT 9
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: PUSH
6530: LD_OWVAR 67
6534: ARRAY
6535: PPUSH
6536: CALL_OW 380
// un := CreateHuman ;
6540: LD_ADDR_VAR 0 2
6544: PUSH
6545: CALL_OW 44
6549: ST_TO_ADDR
// tmp := tmp ^ un ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 2
6564: ADD
6565: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6566: LD_VAR 0 2
6570: PPUSH
6571: LD_INT 3
6573: PPUSH
6574: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6578: LD_VAR 0 2
6582: PPUSH
6583: LD_INT 30
6585: PPUSH
6586: LD_INT 0
6588: PPUSH
6589: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6593: LD_VAR 0 2
6597: PPUSH
6598: LD_INT 16
6600: PPUSH
6601: LD_INT 11
6603: PPUSH
6604: CALL_OW 111
// wait ( 0 0$2 ) ;
6608: LD_INT 70
6610: PPUSH
6611: CALL_OW 67
// end ;
6615: GO 6491
6617: POP
6618: POP
// repeat wait ( 0 0$1 ) ;
6619: LD_INT 35
6621: PPUSH
6622: CALL_OW 67
// for i in tmp do
6626: LD_ADDR_VAR 0 1
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: FOR_IN
6637: IFFALSE 6773
// begin if GetLives ( i ) > 250 then
6639: LD_VAR 0 1
6643: PPUSH
6644: CALL_OW 256
6648: PUSH
6649: LD_INT 250
6651: GREATER
6652: IFFALSE 6744
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6654: LD_INT 81
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 91
6666: PUSH
6667: LD_VAR 0 1
6671: PUSH
6672: LD_INT 10
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PPUSH
6684: CALL_OW 69
6688: NOT
6689: IFFALSE 6708
// ComAgressiveMove ( i , 67 , 110 ) else
6691: LD_VAR 0 1
6695: PPUSH
6696: LD_INT 67
6698: PPUSH
6699: LD_INT 110
6701: PPUSH
6702: CALL_OW 114
6706: GO 6742
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6708: LD_VAR 0 1
6712: PPUSH
6713: LD_INT 81
6715: PUSH
6716: LD_INT 8
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: PPUSH
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 74
6737: PPUSH
6738: CALL_OW 115
// end else
6742: GO 6771
// if IsDead ( i ) then
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 301
6753: IFFALSE 6771
// tmp := tmp diff i ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_VAR 0 3
6764: PUSH
6765: LD_VAR 0 1
6769: DIFF
6770: ST_TO_ADDR
// end ;
6771: GO 6636
6773: POP
6774: POP
// until not tmp ;
6775: LD_VAR 0 3
6779: NOT
6780: IFFALSE 6619
// end ; end_of_file
6782: PPOPN 3
6784: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6785: LD_INT 0
6787: PPUSH
6788: PPUSH
6789: PPUSH
6790: PPUSH
6791: PPUSH
6792: PPUSH
6793: PPUSH
6794: PPUSH
6795: PPUSH
// side := 3 ;
6796: LD_ADDR_VAR 0 6
6800: PUSH
6801: LD_INT 3
6803: ST_TO_ADDR
// uc_side := side ;
6804: LD_ADDR_OWVAR 20
6808: PUSH
6809: LD_VAR 0 6
6813: ST_TO_ADDR
// uc_nation := 3 ;
6814: LD_ADDR_OWVAR 21
6818: PUSH
6819: LD_INT 3
6821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6822: LD_ADDR_VAR 0 2
6826: PUSH
6827: LD_INT 22
6829: PUSH
6830: LD_VAR 0 6
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PPUSH
6853: CALL_OW 69
6857: PUSH
6858: FOR_IN
6859: IFFALSE 6875
// SetBLevel ( i , 10 ) ;
6861: LD_VAR 0 2
6865: PPUSH
6866: LD_INT 10
6868: PPUSH
6869: CALL_OW 241
6873: GO 6858
6875: POP
6876: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6877: LD_ADDR_VAR 0 9
6881: PUSH
6882: LD_INT 22
6884: PUSH
6885: LD_VAR 0 6
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 30
6896: PUSH
6897: LD_INT 34
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL_OW 69
6912: ST_TO_ADDR
// if teleport then
6913: LD_VAR 0 9
6917: IFFALSE 6938
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6919: LD_VAR 0 9
6923: PUSH
6924: LD_INT 1
6926: ARRAY
6927: PPUSH
6928: LD_INT 123
6930: PPUSH
6931: LD_INT 122
6933: PPUSH
6934: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6938: LD_ADDR_EXP 61
6942: PUSH
6943: LD_STRING Platonov
6945: PPUSH
6946: CALL_OW 25
6950: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6951: LD_ADDR_EXP 62
6955: PUSH
6956: LD_STRING Kovalyuk
6958: PPUSH
6959: CALL_OW 25
6963: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6964: LD_ADDR_EXP 64
6968: PUSH
6969: LD_STRING Yakotich
6971: PPUSH
6972: CALL_OW 25
6976: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6977: LD_ADDR_EXP 63
6981: PUSH
6982: LD_STRING Bystrov
6984: PPUSH
6985: CALL_OW 25
6989: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6990: LD_ADDR_EXP 65
6994: PUSH
6995: LD_STRING Gleb
6997: PPUSH
6998: CALL_OW 25
7002: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7003: LD_STRING 03_Cornel
7005: PPUSH
7006: CALL_OW 28
7010: IFFALSE 7058
// begin Bierezov := NewCharacter ( Mikhail ) ;
7012: LD_ADDR_EXP 66
7016: PUSH
7017: LD_STRING Mikhail
7019: PPUSH
7020: CALL_OW 25
7024: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7025: LD_EXP 66
7029: PPUSH
7030: LD_INT 197
7032: PPUSH
7033: LD_INT 111
7035: PPUSH
7036: LD_INT 9
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7046: LD_EXP 66
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7058: LD_EXP 61
7062: PPUSH
7063: LD_INT 126
7065: PPUSH
7066: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7070: LD_EXP 62
7074: PPUSH
7075: LD_INT 134
7077: PPUSH
7078: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7082: LD_EXP 64
7086: PPUSH
7087: LD_INT 197
7089: PPUSH
7090: LD_INT 111
7092: PPUSH
7093: LD_INT 9
7095: PPUSH
7096: LD_INT 0
7098: PPUSH
7099: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7103: LD_EXP 63
7107: PPUSH
7108: LD_INT 197
7110: PPUSH
7111: LD_INT 111
7113: PPUSH
7114: LD_INT 9
7116: PPUSH
7117: LD_INT 0
7119: PPUSH
7120: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7124: LD_EXP 65
7128: PPUSH
7129: LD_INT 197
7131: PPUSH
7132: LD_INT 111
7134: PPUSH
7135: LD_INT 9
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7145: LD_ADDR_VAR 0 5
7149: PUSH
7150: LD_INT 126
7152: PPUSH
7153: LD_INT 4
7155: PPUSH
7156: LD_STRING zhukov
7158: PPUSH
7159: LD_INT 9
7161: PUSH
7162: LD_INT 10
7164: PUSH
7165: LD_INT 10
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_OWVAR 67
7177: ARRAY
7178: PPUSH
7179: LD_INT 99999
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: LD_INT 300
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: PPUSH
7193: LD_INT 12
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: LD_INT 13
7201: PUSH
7202: LD_INT 8
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PPUSH
7211: CALL 72924 0 6
7215: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7216: LD_ADDR_VAR 0 4
7220: PUSH
7221: LD_INT 267
7223: PPUSH
7224: CALL_OW 274
7228: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7229: LD_VAR 0 4
7233: PPUSH
7234: LD_INT 1
7236: PPUSH
7237: LD_INT 5000
7239: PPUSH
7240: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7244: LD_VAR 0 4
7248: PPUSH
7249: LD_INT 2
7251: PPUSH
7252: LD_INT 200
7254: PPUSH
7255: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7259: LD_VAR 0 4
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 200
7269: PPUSH
7270: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7274: LD_ADDR_EXP 99
7278: PUSH
7279: LD_EXP 99
7283: PPUSH
7284: LD_INT 2
7286: PPUSH
7287: LD_VAR 0 5
7291: PUSH
7292: LD_INT 22
7294: PUSH
7295: LD_VAR 0 6
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PUSH
7304: LD_INT 3
7306: PUSH
7307: LD_INT 21
7309: PUSH
7310: LD_INT 2
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PPUSH
7325: CALL_OW 69
7329: UNION
7330: PUSH
7331: LD_EXP 61
7335: DIFF
7336: PPUSH
7337: CALL_OW 1
7341: ST_TO_ADDR
// behemoths := [ ] ;
7342: LD_ADDR_EXP 69
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// behemothBuilders := [ ] ;
7349: LD_ADDR_EXP 70
7353: PUSH
7354: EMPTY
7355: ST_TO_ADDR
// if Kovalyuk then
7356: LD_EXP 62
7360: IFFALSE 7382
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7362: LD_ADDR_EXP 70
7366: PUSH
7367: LD_EXP 70
7371: PPUSH
7372: LD_EXP 62
7376: PPUSH
7377: CALL 105260 0 2
7381: ST_TO_ADDR
// j := 3 ;
7382: LD_ADDR_VAR 0 3
7386: PUSH
7387: LD_INT 3
7389: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7390: LD_ADDR_VAR 0 2
7394: PUSH
7395: LD_INT 22
7397: PUSH
7398: LD_INT 3
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 25
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: PPUSH
7419: CALL_OW 69
7423: PUSH
7424: LD_EXP 62
7428: DIFF
7429: PUSH
7430: FOR_IN
7431: IFFALSE 7481
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7433: LD_ADDR_EXP 70
7437: PUSH
7438: LD_EXP 70
7442: PPUSH
7443: LD_VAR 0 2
7447: PPUSH
7448: CALL 105260 0 2
7452: ST_TO_ADDR
// j := j - 1 ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_VAR 0 3
7462: PUSH
7463: LD_INT 1
7465: MINUS
7466: ST_TO_ADDR
// if j = 0 then
7467: LD_VAR 0 3
7471: PUSH
7472: LD_INT 0
7474: EQUAL
7475: IFFALSE 7479
// break ;
7477: GO 7481
// end ;
7479: GO 7430
7481: POP
7482: POP
// end ;
7483: LD_VAR 0 1
7487: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7488: LD_INT 0
7490: PPUSH
7491: PPUSH
7492: PPUSH
7493: PPUSH
7494: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7495: LD_ADDR_VAR 0 4
7499: PUSH
7500: LD_INT 209
7502: PUSH
7503: LD_INT 149
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 219
7512: PUSH
7513: LD_INT 154
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 223
7522: PUSH
7523: LD_INT 149
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 232
7532: PUSH
7533: LD_INT 155
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: ST_TO_ADDR
// if not behemothBuilders then
7546: LD_EXP 70
7550: NOT
7551: IFFALSE 7555
// exit ;
7553: GO 7659
// j := 1 ;
7555: LD_ADDR_VAR 0 3
7559: PUSH
7560: LD_INT 1
7562: ST_TO_ADDR
// for i in behemothBuilders do
7563: LD_ADDR_VAR 0 2
7567: PUSH
7568: LD_EXP 70
7572: PUSH
7573: FOR_IN
7574: IFFALSE 7657
// begin if IsInUnit ( i ) then
7576: LD_VAR 0 2
7580: PPUSH
7581: CALL_OW 310
7585: IFFALSE 7596
// ComExitBuilding ( i ) ;
7587: LD_VAR 0 2
7591: PPUSH
7592: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7596: LD_VAR 0 2
7600: PPUSH
7601: LD_INT 37
7603: PPUSH
7604: LD_VAR 0 4
7608: PUSH
7609: LD_VAR 0 3
7613: ARRAY
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_VAR 0 4
7623: PUSH
7624: LD_VAR 0 3
7628: ARRAY
7629: PUSH
7630: LD_INT 2
7632: ARRAY
7633: PPUSH
7634: LD_INT 0
7636: PPUSH
7637: CALL_OW 230
// j := j + 1 ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: LD_VAR 0 3
7650: PUSH
7651: LD_INT 1
7653: PLUS
7654: ST_TO_ADDR
// end ;
7655: GO 7573
7657: POP
7658: POP
// end ;
7659: LD_VAR 0 1
7663: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7664: LD_INT 24
7666: PPUSH
7667: LD_INT 30
7669: PUSH
7670: LD_INT 37
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL_OW 70
7681: IFFALSE 7694
7683: GO 7685
7685: DISABLE
// behemothUnderConstruct := true ;
7686: LD_ADDR_EXP 26
7690: PUSH
7691: LD_INT 1
7693: ST_TO_ADDR
7694: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7695: LD_INT 3
7697: PPUSH
7698: CALL 105308 0 1
7702: PUSH
7703: LD_INT 22
7705: PUSH
7706: LD_INT 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 30
7715: PUSH
7716: LD_INT 37
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PPUSH
7727: CALL_OW 69
7731: NOT
7732: AND
7733: IFFALSE 7919
7735: GO 7737
7737: DISABLE
7738: LD_INT 0
7740: PPUSH
7741: PPUSH
// begin enable ;
7742: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_INT 3
7750: PPUSH
7751: CALL 105308 0 1
7755: ST_TO_ADDR
// for i in tmp do
7756: LD_ADDR_VAR 0 1
7760: PUSH
7761: LD_VAR 0 2
7765: PUSH
7766: FOR_IN
7767: IFFALSE 7917
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7769: LD_VAR 0 1
7773: PPUSH
7774: LD_INT 9
7776: PPUSH
7777: CALL_OW 308
7781: PUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 110
7791: PUSH
7792: LD_INT 2
7794: EQUAL
7795: NOT
7796: AND
7797: IFFALSE 7811
// SetTag ( i , 2 ) ;
7799: LD_VAR 0 1
7803: PPUSH
7804: LD_INT 2
7806: PPUSH
7807: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7811: LD_INT 81
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 91
7823: PUSH
7824: LD_VAR 0 1
7828: PUSH
7829: LD_INT 12
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: NOT
7846: PUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: CALL_OW 110
7856: PUSH
7857: LD_INT 2
7859: EQUAL
7860: NOT
7861: AND
7862: IFFALSE 7881
// ComAgressiveMove ( i , 64 , 93 ) else
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 64
7871: PPUSH
7872: LD_INT 93
7874: PPUSH
7875: CALL_OW 114
7879: GO 7915
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7881: LD_VAR 0 1
7885: PPUSH
7886: LD_INT 81
7888: PUSH
7889: LD_INT 3
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PPUSH
7896: CALL_OW 69
7900: PPUSH
7901: LD_VAR 0 1
7905: PPUSH
7906: CALL_OW 74
7910: PPUSH
7911: CALL_OW 115
// end ;
7915: GO 7766
7917: POP
7918: POP
// end ;
7919: PPOPN 2
7921: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7922: LD_INT 0
7924: PPUSH
7925: PPUSH
7926: PPUSH
// result := [ ] ;
7927: LD_ADDR_VAR 0 2
7931: PUSH
7932: EMPTY
7933: ST_TO_ADDR
// uc_side := 6 ;
7934: LD_ADDR_OWVAR 20
7938: PUSH
7939: LD_INT 6
7941: ST_TO_ADDR
// uc_nation := 3 ;
7942: LD_ADDR_OWVAR 21
7946: PUSH
7947: LD_INT 3
7949: ST_TO_ADDR
// case strength of 1 :
7950: LD_VAR 0 1
7954: PUSH
7955: LD_INT 1
7957: DOUBLE
7958: EQUAL
7959: IFTRUE 7963
7961: GO 8101
7963: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7964: LD_ADDR_VAR 0 3
7968: PUSH
7969: DOUBLE
7970: LD_INT 1
7972: DEC
7973: ST_TO_ADDR
7974: LD_INT 4
7976: PUSH
7977: LD_INT 5
7979: PUSH
7980: LD_INT 6
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: PUSH
7988: LD_OWVAR 67
7992: ARRAY
7993: PUSH
7994: FOR_TO
7995: IFFALSE 8097
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7997: LD_INT 22
7999: PUSH
8000: LD_INT 24
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_VAR 0 3
8011: PUSH
8012: LD_INT 2
8014: MOD
8015: PUSH
8016: LD_INT 1
8018: PLUS
8019: ARRAY
8020: PPUSH
8021: LD_INT 1
8023: PUSH
8024: LD_INT 3
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 1
8033: PPUSH
8034: LD_INT 2
8036: PPUSH
8037: CALL_OW 12
8041: ARRAY
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: LD_INT 43
8048: PUSH
8049: LD_INT 44
8051: PUSH
8052: LD_INT 45
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 1
8062: PPUSH
8063: LD_INT 3
8065: PPUSH
8066: CALL_OW 12
8070: ARRAY
8071: PPUSH
8072: LD_INT 80
8074: PPUSH
8075: CALL 69515 0 5
// result := result union CreateVehicle ;
8079: LD_ADDR_VAR 0 2
8083: PUSH
8084: LD_VAR 0 2
8088: PUSH
8089: CALL_OW 45
8093: UNION
8094: ST_TO_ADDR
// end ;
8095: GO 7994
8097: POP
8098: POP
// end ; 2 :
8099: GO 9045
8101: LD_INT 2
8103: DOUBLE
8104: EQUAL
8105: IFTRUE 8109
8107: GO 8265
8109: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8110: LD_ADDR_VAR 0 3
8114: PUSH
8115: DOUBLE
8116: LD_INT 1
8118: DEC
8119: ST_TO_ADDR
8120: LD_INT 6
8122: PUSH
8123: LD_INT 6
8125: PUSH
8126: LD_INT 7
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: PUSH
8134: LD_OWVAR 67
8138: ARRAY
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8261
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8143: LD_INT 22
8145: PUSH
8146: LD_INT 24
8148: PUSH
8149: LD_INT 24
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: LIST
8156: PUSH
8157: LD_VAR 0 3
8161: PUSH
8162: LD_INT 3
8164: MOD
8165: PUSH
8166: LD_INT 1
8168: PLUS
8169: ARRAY
8170: PPUSH
8171: LD_INT 1
8173: PUSH
8174: LD_INT 3
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PPUSH
8193: LD_INT 3
8195: PPUSH
8196: LD_INT 43
8198: PUSH
8199: LD_INT 44
8201: PUSH
8202: LD_INT 45
8204: PUSH
8205: LD_INT 44
8207: PUSH
8208: LD_INT 46
8210: PUSH
8211: LD_INT 46
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_VAR 0 3
8226: PUSH
8227: LD_INT 6
8229: MOD
8230: PUSH
8231: LD_INT 1
8233: PLUS
8234: ARRAY
8235: PPUSH
8236: LD_INT 80
8238: PPUSH
8239: CALL 69515 0 5
// result := result union CreateVehicle ;
8243: LD_ADDR_VAR 0 2
8247: PUSH
8248: LD_VAR 0 2
8252: PUSH
8253: CALL_OW 45
8257: UNION
8258: ST_TO_ADDR
// end ;
8259: GO 8140
8261: POP
8262: POP
// end ; 3 :
8263: GO 9045
8265: LD_INT 3
8267: DOUBLE
8268: EQUAL
8269: IFTRUE 8273
8271: GO 8429
8273: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8274: LD_ADDR_VAR 0 3
8278: PUSH
8279: DOUBLE
8280: LD_INT 1
8282: DEC
8283: ST_TO_ADDR
8284: LD_INT 6
8286: PUSH
8287: LD_INT 7
8289: PUSH
8290: LD_INT 8
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: LIST
8297: PUSH
8298: LD_OWVAR 67
8302: ARRAY
8303: PUSH
8304: FOR_TO
8305: IFFALSE 8425
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8307: LD_INT 22
8309: PUSH
8310: LD_INT 24
8312: PUSH
8313: LD_INT 24
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: PUSH
8321: LD_VAR 0 3
8325: PUSH
8326: LD_INT 3
8328: MOD
8329: PUSH
8330: LD_INT 1
8332: PLUS
8333: ARRAY
8334: PPUSH
8335: LD_INT 1
8337: PUSH
8338: LD_INT 3
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 1
8347: PPUSH
8348: LD_INT 2
8350: PPUSH
8351: CALL_OW 12
8355: ARRAY
8356: PPUSH
8357: LD_INT 3
8359: PPUSH
8360: LD_INT 43
8362: PUSH
8363: LD_INT 47
8365: PUSH
8366: LD_INT 45
8368: PUSH
8369: LD_INT 45
8371: PUSH
8372: LD_INT 46
8374: PUSH
8375: LD_INT 46
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: PUSH
8386: LD_VAR 0 3
8390: PUSH
8391: LD_INT 6
8393: MOD
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: ARRAY
8399: PPUSH
8400: LD_INT 80
8402: PPUSH
8403: CALL 69515 0 5
// result := result union CreateVehicle ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_VAR 0 2
8416: PUSH
8417: CALL_OW 45
8421: UNION
8422: ST_TO_ADDR
// end ;
8423: GO 8304
8425: POP
8426: POP
// end ; 4 :
8427: GO 9045
8429: LD_INT 4
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 9044
8437: POP
// begin uc_nation := 3 ;
8438: LD_ADDR_OWVAR 21
8442: PUSH
8443: LD_INT 3
8445: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8446: LD_ADDR_VAR 0 3
8450: PUSH
8451: DOUBLE
8452: LD_INT 1
8454: DEC
8455: ST_TO_ADDR
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: LD_INT 9
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_OWVAR 67
8474: ARRAY
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8597
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8479: LD_INT 22
8481: PUSH
8482: LD_INT 24
8484: PUSH
8485: LD_INT 24
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: LIST
8492: PUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_INT 3
8500: MOD
8501: PUSH
8502: LD_INT 1
8504: PLUS
8505: ARRAY
8506: PPUSH
8507: LD_INT 1
8509: PUSH
8510: LD_INT 3
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: LD_INT 1
8519: PPUSH
8520: LD_INT 2
8522: PPUSH
8523: CALL_OW 12
8527: ARRAY
8528: PPUSH
8529: LD_INT 3
8531: PPUSH
8532: LD_INT 45
8534: PUSH
8535: LD_INT 47
8537: PUSH
8538: LD_INT 47
8540: PUSH
8541: LD_INT 45
8543: PUSH
8544: LD_INT 46
8546: PUSH
8547: LD_INT 46
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 6
8565: MOD
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: ARRAY
8571: PPUSH
8572: LD_INT 80
8574: PPUSH
8575: CALL 69515 0 5
// result := result union CreateVehicle ;
8579: LD_ADDR_VAR 0 2
8583: PUSH
8584: LD_VAR 0 2
8588: PUSH
8589: CALL_OW 45
8593: UNION
8594: ST_TO_ADDR
// end ;
8595: GO 8476
8597: POP
8598: POP
// if not KappaStatus then
8599: LD_EXP 2
8603: NOT
8604: IFFALSE 8839
// begin uc_nation := 1 ;
8606: LD_ADDR_OWVAR 21
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// for i = 1 to 3 do
8614: LD_ADDR_VAR 0 3
8618: PUSH
8619: DOUBLE
8620: LD_INT 1
8622: DEC
8623: ST_TO_ADDR
8624: LD_INT 3
8626: PUSH
8627: FOR_TO
8628: IFFALSE 8764
// begin j := rand ( 0 , 1 ) ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 0
8637: PPUSH
8638: LD_INT 1
8640: PPUSH
8641: CALL_OW 12
8645: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8646: LD_INT 3
8648: PUSH
8649: LD_INT 5
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: LD_INT 4
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_VAR 0 4
8668: PUSH
8669: LD_INT 1
8671: PPUSH
8672: LD_INT 3
8674: PPUSH
8675: CALL_OW 12
8679: PLUS
8680: ARRAY
8681: PPUSH
8682: LD_INT 1
8684: PUSH
8685: LD_INT 3
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: PUSH
8692: LD_INT 1
8694: PPUSH
8695: LD_INT 2
8697: PPUSH
8698: CALL_OW 12
8702: ARRAY
8703: PPUSH
8704: LD_INT 3
8706: PPUSH
8707: LD_INT 9
8709: PUSH
8710: LD_INT 7
8712: PUSH
8713: LD_INT 6
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: PUSH
8721: LD_VAR 0 4
8725: PUSH
8726: LD_INT 1
8728: PPUSH
8729: LD_INT 2
8731: PPUSH
8732: CALL_OW 12
8736: PLUS
8737: ARRAY
8738: PPUSH
8739: LD_INT 85
8741: PPUSH
8742: CALL 69515 0 5
// result := result union CreateVehicle ;
8746: LD_ADDR_VAR 0 2
8750: PUSH
8751: LD_VAR 0 2
8755: PUSH
8756: CALL_OW 45
8760: UNION
8761: ST_TO_ADDR
// end ;
8762: GO 8627
8764: POP
8765: POP
// if vsevolodFirstAttack then
8766: LD_EXP 24
8770: IFFALSE 8837
// begin vsevolodFirstAttack := false ;
8772: LD_ADDR_EXP 24
8776: PUSH
8777: LD_INT 0
8779: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8780: LD_INT 5
8782: PPUSH
8783: LD_INT 3
8785: PPUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 6
8791: PPUSH
8792: LD_INT 100
8794: PPUSH
8795: CALL 69515 0 5
// sewiVeh := CreateVehicle ;
8799: LD_ADDR_EXP 68
8803: PUSH
8804: CALL_OW 45
8808: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8809: LD_EXP 68
8813: PPUSH
8814: LD_INT 1
8816: PPUSH
8817: CALL_OW 242
// result := result union sewiVeh ;
8821: LD_ADDR_VAR 0 2
8825: PUSH
8826: LD_VAR 0 2
8830: PUSH
8831: LD_EXP 68
8835: UNION
8836: ST_TO_ADDR
// end ; end else
8837: GO 9042
// if vsevolodFirstAttack then
8839: LD_EXP 24
8843: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8845: LD_ADDR_EXP 24
8849: PUSH
8850: LD_INT 0
8852: ST_TO_ADDR
// uc_nation := 3 ;
8853: LD_ADDR_OWVAR 21
8857: PUSH
8858: LD_INT 3
8860: ST_TO_ADDR
// for i = 1 to 3 do
8861: LD_ADDR_VAR 0 3
8865: PUSH
8866: DOUBLE
8867: LD_INT 1
8869: DEC
8870: ST_TO_ADDR
8871: LD_INT 3
8873: PUSH
8874: FOR_TO
8875: IFFALSE 8983
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8877: LD_INT 22
8879: PUSH
8880: LD_INT 24
8882: PUSH
8883: LD_INT 24
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: LIST
8890: PUSH
8891: LD_VAR 0 3
8895: PUSH
8896: LD_INT 3
8898: MOD
8899: PUSH
8900: LD_INT 1
8902: PLUS
8903: ARRAY
8904: PPUSH
8905: LD_INT 1
8907: PUSH
8908: LD_INT 3
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 2
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: PPUSH
8927: LD_INT 3
8929: PPUSH
8930: LD_INT 45
8932: PUSH
8933: LD_INT 47
8935: PUSH
8936: LD_INT 47
8938: PUSH
8939: EMPTY
8940: LIST
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 3
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 80
8960: PPUSH
8961: CALL 69515 0 5
// result := result union CreateVehicle ;
8965: LD_ADDR_VAR 0 2
8969: PUSH
8970: LD_VAR 0 2
8974: PUSH
8975: CALL_OW 45
8979: UNION
8980: ST_TO_ADDR
// end ;
8981: GO 8874
8983: POP
8984: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8985: LD_INT 24
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 47
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 69515 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 68
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 68
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 68
9040: UNION
9041: ST_TO_ADDR
// end ; end ; end ;
9042: GO 9045
9044: POP
// end ;
9045: LD_VAR 0 2
9049: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9050: LD_EXP 16
9054: IFFALSE 9802
9056: GO 9058
9058: DISABLE
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9067: LD_ADDR_VAR 0 4
9071: PUSH
9072: LD_INT 11
9074: PUSH
9075: LD_INT 12
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9082: LD_ADDR_VAR 0 3
9086: PUSH
9087: LD_INT 8400
9089: PUSH
9090: LD_INT 7350
9092: PUSH
9093: LD_INT 6650
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9107: LD_ADDR_VAR 0 6
9111: PUSH
9112: LD_INT 70
9114: PUSH
9115: LD_INT 118
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 78
9124: PUSH
9125: LD_INT 31
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: ST_TO_ADDR
// repeat if missionStage = 2 then
9136: LD_EXP 15
9140: PUSH
9141: LD_INT 2
9143: EQUAL
9144: IFFALSE 9155
// wait ( 1 1$30 ) else
9146: LD_INT 3150
9148: PPUSH
9149: CALL_OW 67
9153: GO 9164
// wait ( time ) ;
9155: LD_VAR 0 3
9159: PPUSH
9160: CALL_OW 67
// if missionStage = 6 then
9164: LD_EXP 15
9168: PUSH
9169: LD_INT 6
9171: EQUAL
9172: IFFALSE 9200
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9174: LD_INT 51
9176: PPUSH
9177: LD_INT 6
9179: PPUSH
9180: LD_INT 2
9182: PPUSH
9183: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9187: LD_INT 57
9189: PPUSH
9190: LD_INT 6
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 322
// end ; if missionStage = 8 then
9200: LD_EXP 15
9204: PUSH
9205: LD_INT 8
9207: EQUAL
9208: IFFALSE 9236
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9210: LD_INT 52
9212: PPUSH
9213: LD_INT 6
9215: PPUSH
9216: LD_INT 2
9218: PPUSH
9219: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9223: LD_INT 58
9225: PPUSH
9226: LD_INT 6
9228: PPUSH
9229: LD_INT 2
9231: PPUSH
9232: CALL_OW 322
// end ; if missionStage = 10 then
9236: LD_EXP 15
9240: PUSH
9241: LD_INT 10
9243: EQUAL
9244: IFFALSE 9272
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9246: LD_INT 53
9248: PPUSH
9249: LD_INT 6
9251: PPUSH
9252: LD_INT 2
9254: PPUSH
9255: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9259: LD_INT 59
9261: PPUSH
9262: LD_INT 6
9264: PPUSH
9265: LD_INT 2
9267: PPUSH
9268: CALL_OW 322
// end ; if activeAttacks then
9272: LD_EXP 16
9276: IFFALSE 9796
// begin if missionStage = 2 then
9278: LD_EXP 15
9282: PUSH
9283: LD_INT 2
9285: EQUAL
9286: IFFALSE 9296
// strength := 1 ;
9288: LD_ADDR_VAR 0 5
9292: PUSH
9293: LD_INT 1
9295: ST_TO_ADDR
// if missionStage > 2 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 2
9303: GREATER
9304: IFFALSE 9314
// strength := 2 ;
9306: LD_ADDR_VAR 0 5
9310: PUSH
9311: LD_INT 2
9313: ST_TO_ADDR
// if missionStage > 6 then
9314: LD_EXP 15
9318: PUSH
9319: LD_INT 6
9321: GREATER
9322: IFFALSE 9332
// strength := 3 ;
9324: LD_ADDR_VAR 0 5
9328: PUSH
9329: LD_INT 3
9331: ST_TO_ADDR
// if missionStage > 10 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 10
9339: GREATER
9340: IFFALSE 9350
// strength := 4 ;
9342: LD_ADDR_VAR 0 5
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9350: LD_ADDR_VAR 0 2
9354: PUSH
9355: LD_VAR 0 5
9359: PPUSH
9360: CALL 7922 0 1
9364: ST_TO_ADDR
// for i in tmp do
9365: LD_ADDR_VAR 0 1
9369: PUSH
9370: LD_VAR 0 2
9374: PUSH
9375: FOR_IN
9376: IFFALSE 9476
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9378: LD_VAR 0 1
9382: PPUSH
9383: LD_VAR 0 4
9387: PUSH
9388: LD_INT 1
9390: PPUSH
9391: LD_INT 2
9393: PPUSH
9394: CALL_OW 12
9398: ARRAY
9399: PPUSH
9400: LD_INT 0
9402: PPUSH
9403: CALL_OW 49
// if i = sewiVeh then
9407: LD_VAR 0 1
9411: PUSH
9412: LD_EXP 68
9416: EQUAL
9417: IFFALSE 9452
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9419: LD_ADDR_EXP 67
9423: PUSH
9424: LD_STRING Vsevolod
9426: PPUSH
9427: LD_INT 0
9429: PPUSH
9430: LD_STRING 
9432: PPUSH
9433: CALL 62912 0 3
9437: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9438: LD_EXP 67
9442: PPUSH
9443: LD_VAR 0 1
9447: PPUSH
9448: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9452: LD_VAR 0 1
9456: PPUSH
9457: LD_INT 111
9459: PPUSH
9460: LD_INT 197
9462: PPUSH
9463: CALL_OW 111
// wait ( 0 0$2 ) ;
9467: LD_INT 70
9469: PPUSH
9470: CALL_OW 67
// end ;
9474: GO 9375
9476: POP
9477: POP
// repeat wait ( 0 0$1 ) ;
9478: LD_INT 35
9480: PPUSH
9481: CALL_OW 67
// for i in tmp do
9485: LD_ADDR_VAR 0 1
9489: PUSH
9490: LD_VAR 0 2
9494: PUSH
9495: FOR_IN
9496: IFFALSE 9777
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9498: LD_INT 81
9500: PUSH
9501: LD_INT 6
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 91
9510: PUSH
9511: LD_VAR 0 1
9515: PUSH
9516: LD_INT 12
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: LIST
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PPUSH
9528: CALL_OW 69
9532: IFFALSE 9590
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_INT 81
9541: PUSH
9542: LD_INT 6
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 92
9551: PUSH
9552: LD_VAR 0 1
9556: PUSH
9557: LD_INT 12
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: PPUSH
9574: LD_VAR 0 1
9578: PPUSH
9579: CALL_OW 74
9583: PPUSH
9584: CALL_OW 115
9588: GO 9775
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9590: LD_INT 9
9592: PPUSH
9593: LD_INT 81
9595: PUSH
9596: LD_INT 6
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 70
9607: IFFALSE 9741
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9609: LD_VAR 0 1
9613: PPUSH
9614: LD_VAR 0 6
9618: PUSH
9619: LD_INT 1
9621: ARRAY
9622: PUSH
9623: LD_INT 1
9625: ARRAY
9626: PPUSH
9627: LD_VAR 0 6
9631: PUSH
9632: LD_INT 1
9634: ARRAY
9635: PUSH
9636: LD_INT 2
9638: ARRAY
9639: PPUSH
9640: CALL_OW 297
9644: PUSH
9645: LD_INT 10
9647: GREATER
9648: PUSH
9649: LD_VAR 0 1
9653: PPUSH
9654: LD_INT 9
9656: PPUSH
9657: CALL_OW 308
9661: NOT
9662: AND
9663: IFFALSE 9702
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9665: LD_VAR 0 1
9669: PPUSH
9670: LD_VAR 0 6
9674: PUSH
9675: LD_INT 1
9677: ARRAY
9678: PUSH
9679: LD_INT 1
9681: ARRAY
9682: PPUSH
9683: LD_VAR 0 6
9687: PUSH
9688: LD_INT 1
9690: ARRAY
9691: PUSH
9692: LD_INT 2
9694: ARRAY
9695: PPUSH
9696: CALL_OW 114
9700: GO 9739
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9702: LD_VAR 0 1
9706: PPUSH
9707: LD_INT 9
9709: PPUSH
9710: LD_INT 81
9712: PUSH
9713: LD_INT 6
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PPUSH
9720: CALL_OW 70
9724: PPUSH
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 74
9734: PPUSH
9735: CALL_OW 115
// end else
9739: GO 9775
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 81
9748: PUSH
9749: LD_INT 6
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PPUSH
9756: CALL_OW 69
9760: PPUSH
9761: LD_VAR 0 1
9765: PPUSH
9766: CALL_OW 74
9770: PPUSH
9771: CALL_OW 115
// end ;
9775: GO 9495
9777: POP
9778: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9779: LD_INT 22
9781: PUSH
9782: LD_INT 6
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: CALL_OW 69
9793: NOT
9794: IFFALSE 9478
// end ; until russianDestroyed ;
9796: LD_EXP 21
9800: IFFALSE 9136
// end ;
9802: PPOPN 6
9804: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9805: LD_EXP 21
9809: NOT
9810: PUSH
9811: LD_EXP 15
9815: PUSH
9816: LD_INT 6
9818: GREATEREQUAL
9819: AND
9820: PUSH
9821: LD_INT 2
9823: PPUSH
9824: LD_INT 1
9826: PPUSH
9827: CALL 58265 0 2
9831: NOT
9832: AND
9833: IFFALSE 10789
9835: GO 9837
9837: DISABLE
9838: LD_INT 0
9840: PPUSH
9841: PPUSH
9842: PPUSH
9843: PPUSH
// begin enable ;
9844: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9845: LD_INT 22
9847: PUSH
9848: LD_INT 3
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PUSH
9855: LD_INT 30
9857: PUSH
9858: LD_INT 3
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: NOT
9874: IFFALSE 9878
// exit ;
9876: GO 10789
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9878: LD_ADDR_VAR 0 4
9882: PUSH
9883: LD_INT 22
9885: PUSH
9886: LD_INT 3
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: LD_INT 30
9895: PUSH
9896: LD_INT 34
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PUSH
9903: EMPTY
9904: LIST
9905: LIST
9906: PPUSH
9907: CALL_OW 69
9911: ST_TO_ADDR
// if Prob ( 40 ) then
9912: LD_INT 40
9914: PPUSH
9915: CALL_OW 13
9919: IFFALSE 10046
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9921: LD_INT 2
9923: PPUSH
9924: LD_INT 22
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: LD_INT 3
9932: PUSH
9933: LD_INT 49
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: PUSH
9942: LD_INT 22
9944: PUSH
9945: LD_INT 3
9947: PUSH
9948: LD_INT 3
9950: PUSH
9951: LD_INT 49
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_INT 3
9965: PUSH
9966: LD_INT 3
9968: PUSH
9969: LD_INT 49
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 24
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: LD_INT 46
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 24
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: LD_INT 46
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 3
10022: PUSH
10023: LD_INT 46
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: LIST
10039: PPUSH
10040: CALL 56910 0 2
// end else
10044: GO 10169
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10046: LD_INT 2
10048: PPUSH
10049: LD_INT 24
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 47
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 47
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 47
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 3
10129: PUSH
10130: LD_INT 46
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 24
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: LD_INT 46
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: PPUSH
10165: CALL 56910 0 2
// end ; if Difficulty > 1 then
10169: LD_OWVAR 67
10173: PUSH
10174: LD_INT 1
10176: GREATER
10177: IFFALSE 10207
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10179: LD_INT 2
10181: PPUSH
10182: LD_INT 24
10184: PUSH
10185: LD_INT 3
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 47
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: PPUSH
10203: CALL 56910 0 2
// repeat wait ( 0 0$1 ) ;
10207: LD_INT 35
10209: PPUSH
10210: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10214: LD_INT 2
10216: PPUSH
10217: LD_INT 1
10219: PPUSH
10220: CALL 58265 0 2
10224: PUSH
10225: LD_INT 6
10227: PUSH
10228: LD_INT 7
10230: PUSH
10231: LD_INT 7
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: PUSH
10239: LD_OWVAR 67
10243: ARRAY
10244: GREATEREQUAL
10245: IFFALSE 10207
// wait ( 0 0$30 ) ;
10247: LD_INT 1050
10249: PPUSH
10250: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10254: LD_ADDR_VAR 0 2
10258: PUSH
10259: LD_INT 2
10261: PPUSH
10262: LD_INT 1
10264: PPUSH
10265: CALL 58265 0 2
10269: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10270: LD_ADDR_EXP 118
10274: PUSH
10275: LD_EXP 118
10279: PPUSH
10280: LD_INT 2
10282: PPUSH
10283: LD_EXP 118
10287: PUSH
10288: LD_INT 2
10290: ARRAY
10291: PUSH
10292: LD_VAR 0 2
10296: DIFF
10297: PPUSH
10298: CALL_OW 1
10302: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10303: LD_ADDR_VAR 0 3
10307: PUSH
10308: LD_INT 0
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 12
10318: ST_TO_ADDR
// if target then
10319: LD_VAR 0 3
10323: IFFALSE 10451
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10325: LD_ADDR_VAR 0 2
10329: PUSH
10330: LD_VAR 0 2
10334: PPUSH
10335: LD_INT 24
10337: PUSH
10338: LD_INT 250
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL_OW 72
10349: ST_TO_ADDR
// for i in tmp do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_VAR 0 2
10359: PUSH
10360: FOR_IN
10361: IFFALSE 10401
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10363: LD_VAR 0 1
10367: PPUSH
10368: LD_INT 139
10370: PPUSH
10371: LD_INT 89
10373: PPUSH
10374: CALL_OW 297
10378: PUSH
10379: LD_INT 9
10381: GREATER
10382: IFFALSE 10399
// ComMoveXY ( i , 139 , 89 ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 139
10391: PPUSH
10392: LD_INT 89
10394: PPUSH
10395: CALL_OW 111
10399: GO 10360
10401: POP
10402: POP
// wait ( 0 0$1 ) ;
10403: LD_INT 35
10405: PPUSH
10406: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10410: LD_VAR 0 2
10414: PPUSH
10415: LD_INT 92
10417: PUSH
10418: LD_INT 139
10420: PUSH
10421: LD_INT 89
10423: PUSH
10424: LD_INT 9
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: PPUSH
10433: CALL_OW 72
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: LD_INT 1
10445: MINUS
10446: GREATEREQUAL
10447: IFFALSE 10325
// end else
10449: GO 10593
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10451: LD_VAR 0 2
10455: PPUSH
10456: LD_VAR 0 4
10460: PUSH
10461: LD_INT 1
10463: ARRAY
10464: PPUSH
10465: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10469: LD_ADDR_VAR 0 2
10473: PUSH
10474: LD_VAR 0 2
10478: PPUSH
10479: LD_INT 24
10481: PUSH
10482: LD_INT 250
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PPUSH
10489: CALL_OW 72
10493: ST_TO_ADDR
// for i in tmp do
10494: LD_ADDR_VAR 0 1
10498: PUSH
10499: LD_VAR 0 2
10503: PUSH
10504: FOR_IN
10505: IFFALSE 10545
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10507: LD_VAR 0 1
10511: PPUSH
10512: LD_INT 124
10514: PPUSH
10515: LD_INT 139
10517: PPUSH
10518: CALL_OW 297
10522: PUSH
10523: LD_INT 9
10525: GREATER
10526: IFFALSE 10543
// ComMoveXY ( i , 124 , 139 ) ;
10528: LD_VAR 0 1
10532: PPUSH
10533: LD_INT 124
10535: PPUSH
10536: LD_INT 139
10538: PPUSH
10539: CALL_OW 111
10543: GO 10504
10545: POP
10546: POP
// wait ( 0 0$1 ) ;
10547: LD_INT 35
10549: PPUSH
10550: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10554: LD_VAR 0 2
10558: PPUSH
10559: LD_INT 92
10561: PUSH
10562: LD_INT 124
10564: PUSH
10565: LD_INT 139
10567: PUSH
10568: LD_INT 9
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 72
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: LD_INT 1
10589: MINUS
10590: GREATEREQUAL
10591: IFFALSE 10469
// end ; repeat wait ( 0 0$1 ) ;
10593: LD_INT 35
10595: PPUSH
10596: CALL_OW 67
// for i in tmp do
10600: LD_ADDR_VAR 0 1
10604: PUSH
10605: LD_VAR 0 2
10609: PUSH
10610: FOR_IN
10611: IFFALSE 10780
// begin if GetLives ( i ) > 251 then
10613: LD_VAR 0 1
10617: PPUSH
10618: CALL_OW 256
10622: PUSH
10623: LD_INT 251
10625: GREATER
10626: IFFALSE 10751
// begin if GetWeapon ( i ) = ru_time_lapser then
10628: LD_VAR 0 1
10632: PPUSH
10633: CALL_OW 264
10637: PUSH
10638: LD_INT 49
10640: EQUAL
10641: IFFALSE 10697
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 2
10650: PUSH
10651: LD_INT 22
10653: PUSH
10654: LD_INT 1
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 22
10663: PUSH
10664: LD_INT 8
10666: PUSH
10667: EMPTY
10668: LIST
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 69
10680: PPUSH
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 74
10690: PPUSH
10691: CALL_OW 112
10695: GO 10749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_INT 2
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 1
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 22
10717: PUSH
10718: LD_INT 8
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: PPUSH
10730: CALL_OW 69
10734: PPUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 74
10744: PPUSH
10745: CALL_OW 115
// end else
10749: GO 10778
// if IsDead ( i ) then
10751: LD_VAR 0 1
10755: PPUSH
10756: CALL_OW 301
10760: IFFALSE 10778
// tmp := tmp diff i ;
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_VAR 0 2
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// end ;
10778: GO 10610
10780: POP
10781: POP
// until not tmp ;
10782: LD_VAR 0 2
10786: NOT
10787: IFFALSE 10593
// end ; end_of_file
10789: PPOPN 4
10791: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10792: LD_INT 0
10794: PPUSH
10795: PPUSH
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
// side := 7 ;
10800: LD_ADDR_VAR 0 5
10804: PUSH
10805: LD_INT 7
10807: ST_TO_ADDR
// uc_side := side ;
10808: LD_ADDR_OWVAR 20
10812: PUSH
10813: LD_VAR 0 5
10817: ST_TO_ADDR
// uc_nation := 1 ;
10818: LD_ADDR_OWVAR 21
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10826: LD_ADDR_VAR 0 2
10830: PUSH
10831: LD_INT 22
10833: PUSH
10834: LD_VAR 0 5
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PUSH
10843: LD_INT 21
10845: PUSH
10846: LD_INT 3
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 69
10861: PUSH
10862: FOR_IN
10863: IFFALSE 10879
// SetBLevel ( i , 10 ) ;
10865: LD_VAR 0 2
10869: PPUSH
10870: LD_INT 10
10872: PPUSH
10873: CALL_OW 241
10877: GO 10862
10879: POP
10880: POP
// base := GetBase ( al_depot ) ;
10881: LD_ADDR_VAR 0 4
10885: PUSH
10886: LD_INT 2
10888: PPUSH
10889: CALL_OW 274
10893: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10894: LD_ADDR_VAR 0 6
10898: PUSH
10899: LD_INT 22
10901: PUSH
10902: LD_VAR 0 5
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: LD_INT 30
10913: PUSH
10914: LD_INT 34
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PPUSH
10925: CALL_OW 69
10929: ST_TO_ADDR
// if teleport then
10930: LD_VAR 0 6
10934: IFFALSE 10955
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10936: LD_VAR 0 6
10940: PUSH
10941: LD_INT 1
10943: ARRAY
10944: PPUSH
10945: LD_INT 262
10947: PPUSH
10948: LD_INT 119
10950: PPUSH
10951: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10955: LD_VAR 0 4
10959: PPUSH
10960: LD_INT 1
10962: PPUSH
10963: LD_INT 19500
10965: PPUSH
10966: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10970: LD_VAR 0 4
10974: PPUSH
10975: LD_INT 2
10977: PPUSH
10978: LD_INT 200
10980: PPUSH
10981: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10985: LD_VAR 0 4
10989: PPUSH
10990: LD_INT 3
10992: PPUSH
10993: LD_INT 650
10995: PPUSH
10996: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11000: LD_ADDR_EXP 71
11004: PUSH
11005: LD_STRING Roth
11007: PPUSH
11008: CALL_OW 25
11012: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11013: LD_ADDR_EXP 72
11017: PUSH
11018: LD_STRING Simms
11020: PPUSH
11021: LD_EXP 1
11025: NOT
11026: PPUSH
11027: LD_STRING 10c_
11029: PPUSH
11030: CALL 62912 0 3
11034: ST_TO_ADDR
// if not Simms then
11035: LD_EXP 72
11039: NOT
11040: IFFALSE 11070
// begin uc_nation := 1 ;
11042: LD_ADDR_OWVAR 21
11046: PUSH
11047: LD_INT 1
11049: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11050: LD_INT 2
11052: PPUSH
11053: LD_INT 10
11055: PPUSH
11056: CALL_OW 384
// Simms := CreateHuman ;
11060: LD_ADDR_EXP 72
11064: PUSH
11065: CALL_OW 44
11069: ST_TO_ADDR
// end ; uc_nation := 3 ;
11070: LD_ADDR_OWVAR 21
11074: PUSH
11075: LD_INT 3
11077: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11078: LD_ADDR_EXP 73
11082: PUSH
11083: LD_STRING Kirilenkova
11085: PPUSH
11086: CALL_OW 25
11090: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11091: LD_ADDR_EXP 87
11095: PUSH
11096: LD_STRING Oblukov
11098: PPUSH
11099: CALL_OW 25
11103: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11104: LD_ADDR_EXP 74
11108: PUSH
11109: LD_STRING Dolgov
11111: PPUSH
11112: CALL_OW 25
11116: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11117: LD_ADDR_EXP 75
11121: PUSH
11122: LD_STRING Petrosyan
11124: PPUSH
11125: CALL_OW 25
11129: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11130: LD_ADDR_EXP 86
11134: PUSH
11135: LD_STRING Scholtze
11137: PPUSH
11138: CALL_OW 25
11142: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11143: LD_ADDR_EXP 85
11147: PUSH
11148: LD_STRING Kapitsova
11150: PPUSH
11151: CALL_OW 25
11155: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11156: LD_ADDR_EXP 76
11160: PUSH
11161: LD_STRING Petrovova
11163: PPUSH
11164: CALL_OW 25
11168: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11169: LD_ADDR_EXP 77
11173: PUSH
11174: LD_STRING Kuzmov
11176: PPUSH
11177: CALL_OW 25
11181: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11182: LD_ADDR_EXP 84
11186: PUSH
11187: LD_STRING Karamazov
11189: PPUSH
11190: CALL_OW 25
11194: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11195: LD_STRING 13_Lipshchin_1
11197: PPUSH
11198: LD_INT 0
11200: PPUSH
11201: CALL_OW 30
11205: IFFALSE 11220
// Lipshchin := NewCharacter ( Lipshchin ) ;
11207: LD_ADDR_EXP 78
11211: PUSH
11212: LD_STRING Lipshchin
11214: PPUSH
11215: CALL_OW 25
11219: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11220: LD_STRING 13_Titov_1
11222: PPUSH
11223: LD_INT 0
11225: PPUSH
11226: CALL_OW 30
11230: IFFALSE 11245
// Titov := NewCharacter ( Titov ) ;
11232: LD_ADDR_EXP 80
11236: PUSH
11237: LD_STRING Titov
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11245: LD_STRING 13_Gnyevko_1
11247: PPUSH
11248: LD_INT 0
11250: PPUSH
11251: CALL_OW 30
11255: IFFALSE 11270
// Gnyevko := NewCharacter ( Gnyevko ) ;
11257: LD_ADDR_EXP 79
11261: PUSH
11262: LD_STRING Gnyevko
11264: PPUSH
11265: CALL_OW 25
11269: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11270: LD_STRING 13_Xavier_1
11272: PPUSH
11273: LD_INT 0
11275: PPUSH
11276: CALL_OW 30
11280: IFFALSE 11295
// Xavier := NewCharacter ( Xavier2 ) ;
11282: LD_ADDR_EXP 81
11286: PUSH
11287: LD_STRING Xavier2
11289: PPUSH
11290: CALL_OW 25
11294: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11295: LD_STRING 13_Belkov_1
11297: PPUSH
11298: LD_INT 0
11300: PPUSH
11301: CALL_OW 30
11305: IFFALSE 11320
// Belkov := NewCharacter ( Belkov ) ;
11307: LD_ADDR_EXP 82
11311: PUSH
11312: LD_STRING Belkov
11314: PPUSH
11315: CALL_OW 25
11319: ST_TO_ADDR
// if not BurlakStatus then
11320: LD_EXP 9
11324: NOT
11325: IFFALSE 11340
// Burlak = NewCharacter ( Burlak ) ;
11327: LD_ADDR_EXP 83
11331: PUSH
11332: LD_STRING Burlak
11334: PPUSH
11335: CALL_OW 25
11339: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11340: LD_ADDR_VAR 0 3
11344: PUSH
11345: LD_EXP 71
11349: PUSH
11350: LD_EXP 73
11354: PUSH
11355: LD_EXP 87
11359: PUSH
11360: LD_EXP 74
11364: PUSH
11365: LD_EXP 75
11369: PUSH
11370: LD_EXP 86
11374: PUSH
11375: LD_EXP 85
11379: PUSH
11380: LD_EXP 76
11384: PUSH
11385: LD_EXP 77
11389: PUSH
11390: LD_EXP 84
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: ST_TO_ADDR
// if Simms then
11407: LD_EXP 72
11411: IFFALSE 11429
// tmp := tmp ^ Simms ;
11413: LD_ADDR_VAR 0 3
11417: PUSH
11418: LD_VAR 0 3
11422: PUSH
11423: LD_EXP 72
11427: ADD
11428: ST_TO_ADDR
// if Titov then
11429: LD_EXP 80
11433: IFFALSE 11451
// tmp := tmp ^ Titov ;
11435: LD_ADDR_VAR 0 3
11439: PUSH
11440: LD_VAR 0 3
11444: PUSH
11445: LD_EXP 80
11449: ADD
11450: ST_TO_ADDR
// if Lipshchin then
11451: LD_EXP 78
11455: IFFALSE 11473
// tmp := tmp ^ Lipshchin ;
11457: LD_ADDR_VAR 0 3
11461: PUSH
11462: LD_VAR 0 3
11466: PUSH
11467: LD_EXP 78
11471: ADD
11472: ST_TO_ADDR
// if Gnyevko then
11473: LD_EXP 79
11477: IFFALSE 11495
// tmp := tmp ^ Gnyevko ;
11479: LD_ADDR_VAR 0 3
11483: PUSH
11484: LD_VAR 0 3
11488: PUSH
11489: LD_EXP 79
11493: ADD
11494: ST_TO_ADDR
// if Xavier then
11495: LD_EXP 81
11499: IFFALSE 11517
// tmp := tmp ^ Xavier ;
11501: LD_ADDR_VAR 0 3
11505: PUSH
11506: LD_VAR 0 3
11510: PUSH
11511: LD_EXP 81
11515: ADD
11516: ST_TO_ADDR
// if Belkov then
11517: LD_EXP 82
11521: IFFALSE 11539
// tmp := tmp ^ Belkov ;
11523: LD_ADDR_VAR 0 3
11527: PUSH
11528: LD_VAR 0 3
11532: PUSH
11533: LD_EXP 82
11537: ADD
11538: ST_TO_ADDR
// if Burlak then
11539: LD_EXP 83
11543: IFFALSE 11561
// tmp := tmp ^ Burlak ;
11545: LD_ADDR_VAR 0 3
11549: PUSH
11550: LD_VAR 0 3
11554: PUSH
11555: LD_EXP 83
11559: ADD
11560: ST_TO_ADDR
// for i = 1 to 8 do
11561: LD_ADDR_VAR 0 2
11565: PUSH
11566: DOUBLE
11567: LD_INT 1
11569: DEC
11570: ST_TO_ADDR
11571: LD_INT 8
11573: PUSH
11574: FOR_TO
11575: IFFALSE 11641
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11577: LD_ADDR_OWVAR 21
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: LD_INT 3
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 1
11594: PPUSH
11595: LD_INT 2
11597: PPUSH
11598: CALL_OW 12
11602: ARRAY
11603: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11604: LD_INT 0
11606: PPUSH
11607: LD_VAR 0 2
11611: PUSH
11612: LD_INT 2
11614: DIV
11615: PPUSH
11616: LD_INT 10
11618: PPUSH
11619: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: CALL_OW 44
11637: ADD
11638: ST_TO_ADDR
// end ;
11639: GO 11574
11641: POP
11642: POP
// for i in tmp do
11643: LD_ADDR_VAR 0 2
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: FOR_IN
11654: IFFALSE 11679
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11656: LD_VAR 0 2
11660: PPUSH
11661: LD_INT 260
11663: PPUSH
11664: LD_INT 235
11666: PPUSH
11667: LD_INT 8
11669: PPUSH
11670: LD_INT 0
11672: PPUSH
11673: CALL_OW 50
11677: GO 11653
11679: POP
11680: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11681: LD_ADDR_EXP 99
11685: PUSH
11686: LD_EXP 99
11690: PPUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 22
11696: PUSH
11697: LD_VAR 0 5
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: LD_INT 3
11708: PUSH
11709: LD_INT 21
11711: PUSH
11712: LD_INT 2
11714: PUSH
11715: EMPTY
11716: LIST
11717: LIST
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 69
11731: PUSH
11732: LD_EXP 71
11736: PUSH
11737: LD_EXP 72
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: DIFF
11746: PPUSH
11747: CALL_OW 1
11751: ST_TO_ADDR
// uc_side := 0 ;
11752: LD_ADDR_OWVAR 20
11756: PUSH
11757: LD_INT 0
11759: ST_TO_ADDR
// uc_nation := 0 ;
11760: LD_ADDR_OWVAR 21
11764: PUSH
11765: LD_INT 0
11767: ST_TO_ADDR
// for i = 1 to 5 do
11768: LD_ADDR_VAR 0 2
11772: PUSH
11773: DOUBLE
11774: LD_INT 1
11776: DEC
11777: ST_TO_ADDR
11778: LD_INT 5
11780: PUSH
11781: FOR_TO
11782: IFFALSE 11819
// begin InitHc ;
11784: CALL_OW 19
// hc_class := class_apeman ;
11788: LD_ADDR_OWVAR 28
11792: PUSH
11793: LD_INT 12
11795: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11796: CALL_OW 44
11800: PPUSH
11801: LD_INT 299
11803: PPUSH
11804: LD_INT 229
11806: PPUSH
11807: LD_INT 10
11809: PPUSH
11810: LD_INT 0
11812: PPUSH
11813: CALL_OW 50
// end ;
11817: GO 11781
11819: POP
11820: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11821: LD_EXP 71
11825: PPUSH
11826: LD_INT 259
11828: PPUSH
11829: LD_INT 235
11831: PPUSH
11832: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11836: LD_EXP 71
11840: PPUSH
11841: LD_INT 262
11843: PPUSH
11844: LD_INT 235
11846: PPUSH
11847: CALL_OW 178
// if Simms then
11851: LD_EXP 72
11855: IFFALSE 11886
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11857: LD_EXP 72
11861: PPUSH
11862: LD_INT 262
11864: PPUSH
11865: LD_INT 235
11867: PPUSH
11868: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11872: LD_EXP 72
11876: PPUSH
11877: LD_EXP 71
11881: PPUSH
11882: CALL_OW 179
// end ; end ;
11886: LD_VAR 0 1
11890: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11891: LD_EXP 31
11895: PUSH
11896: LD_EXP 23
11900: NOT
11901: AND
11902: IFFALSE 12078
11904: GO 11906
11906: DISABLE
11907: LD_INT 0
11909: PPUSH
11910: PPUSH
11911: PPUSH
// begin enable ;
11912: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11913: LD_ADDR_VAR 0 2
11917: PUSH
11918: LD_INT 81
11920: PUSH
11921: LD_INT 7
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: LD_INT 2
11930: PUSH
11931: LD_INT 32
11933: PUSH
11934: LD_INT 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PUSH
11941: LD_INT 30
11943: PUSH
11944: LD_INT 30
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 30
11953: PUSH
11954: LD_INT 28
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 34
11963: PUSH
11964: LD_INT 49
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 34
11973: PUSH
11974: LD_INT 10
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PUSH
11981: LD_INT 34
11983: PUSH
11984: LD_INT 8
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: ST_TO_ADDR
// if not tmp then
12009: LD_VAR 0 2
12013: NOT
12014: IFFALSE 12018
// exit ;
12016: GO 12078
// target := tmp [ rand ( 1 , tmp ) ] ;
12018: LD_ADDR_VAR 0 3
12022: PUSH
12023: LD_VAR 0 2
12027: PUSH
12028: LD_INT 1
12030: PPUSH
12031: LD_VAR 0 2
12035: PPUSH
12036: CALL_OW 12
12040: ARRAY
12041: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12042: LD_VAR 0 3
12046: PPUSH
12047: CALL_OW 255
12051: PUSH
12052: LD_INT 1
12054: EQUAL
12055: IFFALSE 12066
// CenterNowOnUnits ( target ) ;
12057: LD_VAR 0 3
12061: PPUSH
12062: CALL_OW 87
// SetLives ( target , 0 ) ;
12066: LD_VAR 0 3
12070: PPUSH
12071: LD_INT 0
12073: PPUSH
12074: CALL_OW 234
// end ;
12078: PPOPN 3
12080: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12081: LD_EXP 23
12085: NOT
12086: PUSH
12087: LD_EXP 31
12091: AND
12092: IFFALSE 12614
12094: GO 12096
12096: DISABLE
12097: LD_INT 0
12099: PPUSH
12100: PPUSH
12101: PPUSH
// begin uc_side := 7 ;
12102: LD_ADDR_OWVAR 20
12106: PUSH
12107: LD_INT 7
12109: ST_TO_ADDR
// uc_nation := 1 ;
12110: LD_ADDR_OWVAR 21
12114: PUSH
12115: LD_INT 1
12117: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12118: LD_ADDR_VAR 0 3
12122: PUSH
12123: LD_INT 125
12125: PUSH
12126: LD_INT 163
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 185
12135: PUSH
12136: LD_INT 168
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: LD_INT 111
12145: PUSH
12146: LD_INT 97
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL 105352 0 1
12162: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12163: LD_ADDR_EXP 88
12167: PUSH
12168: EMPTY
12169: ST_TO_ADDR
// for i = 1 to Difficulty do
12170: LD_ADDR_VAR 0 1
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_OWVAR 67
12184: PUSH
12185: FOR_TO
12186: IFFALSE 12344
// begin InitHc ;
12188: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12192: LD_INT 0
12194: PPUSH
12195: LD_INT 8
12197: PPUSH
12198: CALL_OW 381
// un := CreateHuman ;
12202: LD_ADDR_VAR 0 2
12206: PUSH
12207: CALL_OW 44
12211: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12212: LD_VAR 0 2
12216: PPUSH
12217: LD_INT 258
12219: PPUSH
12220: LD_INT 267
12222: PPUSH
12223: LD_INT 4
12225: PPUSH
12226: LD_INT 0
12228: PPUSH
12229: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12233: LD_ADDR_EXP 88
12237: PUSH
12238: LD_EXP 88
12242: PUSH
12243: LD_VAR 0 2
12247: UNION
12248: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12249: LD_VAR 0 2
12253: PPUSH
12254: LD_VAR 0 3
12258: PUSH
12259: LD_VAR 0 1
12263: ARRAY
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_VAR 0 3
12273: PUSH
12274: LD_VAR 0 1
12278: ARRAY
12279: PUSH
12280: LD_INT 2
12282: ARRAY
12283: PPUSH
12284: LD_INT 4
12286: PPUSH
12287: LD_INT 1
12289: PPUSH
12290: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12294: LD_VAR 0 2
12298: PPUSH
12299: LD_VAR 0 3
12303: PUSH
12304: LD_VAR 0 1
12308: ARRAY
12309: PUSH
12310: LD_INT 1
12312: ARRAY
12313: PPUSH
12314: LD_VAR 0 3
12318: PUSH
12319: LD_VAR 0 1
12323: ARRAY
12324: PUSH
12325: LD_INT 2
12327: ARRAY
12328: PPUSH
12329: CALL_OW 171
// AddComInvisible ( un ) ;
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 212
// end ;
12342: GO 12185
12344: POP
12345: POP
// repeat wait ( 0 0$20 ) ;
12346: LD_INT 700
12348: PPUSH
12349: CALL_OW 67
// for i in allianceSpecialForce do
12353: LD_ADDR_VAR 0 1
12357: PUSH
12358: LD_EXP 88
12362: PUSH
12363: FOR_IN
12364: IFFALSE 12599
// begin if IsInvisible ( i ) then
12366: LD_VAR 0 1
12370: PPUSH
12371: CALL_OW 571
12375: IFFALSE 12568
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12377: LD_ADDR_VAR 0 3
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_INT 1
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 50
12394: PUSH
12395: EMPTY
12396: LIST
12397: PUSH
12398: LD_INT 56
12400: PUSH
12401: EMPTY
12402: LIST
12403: PUSH
12404: LD_INT 91
12406: PUSH
12407: LD_VAR 0 1
12411: PUSH
12412: LD_INT 25
12414: PUSH
12415: LD_INT 30
12417: PUSH
12418: LD_INT 35
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: LIST
12425: PUSH
12426: LD_OWVAR 67
12430: ARRAY
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 2
12439: PUSH
12440: LD_INT 25
12442: PUSH
12443: LD_INT 1
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 25
12452: PUSH
12453: LD_INT 2
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 25
12462: PUSH
12463: LD_INT 3
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 25
12482: PUSH
12483: LD_INT 5
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 25
12492: PUSH
12493: LD_INT 8
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: PPUSH
12516: CALL_OW 69
12520: ST_TO_ADDR
// if not tmp then
12521: LD_VAR 0 3
12525: NOT
12526: IFFALSE 12530
// continue ;
12528: GO 12363
// if Prob ( 30 * Difficulty ) then
12530: LD_INT 30
12532: PUSH
12533: LD_OWVAR 67
12537: MUL
12538: PPUSH
12539: CALL_OW 13
12543: IFFALSE 12568
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12545: LD_VAR 0 3
12549: PUSH
12550: LD_INT 1
12552: PPUSH
12553: LD_VAR 0 3
12557: PPUSH
12558: CALL_OW 12
12562: ARRAY
12563: PPUSH
12564: CALL 30032 0 1
// end ; if IsDead ( i ) then
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 301
12577: IFFALSE 12597
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12579: LD_ADDR_EXP 88
12583: PUSH
12584: LD_EXP 88
12588: PUSH
12589: LD_VAR 0 1
12593: DIFF
12594: ST_TO_ADDR
// continue ;
12595: GO 12363
// end ; end ;
12597: GO 12363
12599: POP
12600: POP
// until allianceDestroyed or not allianceSpecialForce ;
12601: LD_EXP 23
12605: PUSH
12606: LD_EXP 88
12610: NOT
12611: OR
12612: IFFALSE 12346
// end ;
12614: PPOPN 3
12616: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12617: LD_EXP 23
12621: NOT
12622: PUSH
12623: LD_EXP 31
12627: AND
12628: PUSH
12629: LD_INT 1
12631: PPUSH
12632: LD_INT 1
12634: PPUSH
12635: CALL 58265 0 2
12639: NOT
12640: AND
12641: IFFALSE 13608
12643: GO 12645
12645: DISABLE
12646: LD_INT 0
12648: PPUSH
12649: PPUSH
12650: PPUSH
12651: PPUSH
// begin enable ;
12652: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12653: LD_INT 22
12655: PUSH
12656: LD_INT 7
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: PUSH
12663: LD_INT 30
12665: PUSH
12666: LD_INT 3
12668: PUSH
12669: EMPTY
12670: LIST
12671: LIST
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PPUSH
12677: CALL_OW 69
12681: NOT
12682: IFFALSE 12686
// exit ;
12684: GO 13608
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12686: LD_ADDR_VAR 0 4
12690: PUSH
12691: LD_INT 22
12693: PUSH
12694: LD_INT 7
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 30
12703: PUSH
12704: LD_INT 34
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PPUSH
12715: CALL_OW 69
12719: ST_TO_ADDR
// if Prob ( 40 ) then
12720: LD_INT 40
12722: PPUSH
12723: CALL_OW 13
12727: IFFALSE 12854
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12729: LD_INT 1
12731: PPUSH
12732: LD_INT 5
12734: PUSH
12735: LD_INT 3
12737: PUSH
12738: LD_INT 2
12740: PUSH
12741: LD_INT 6
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 5
12752: PUSH
12753: LD_INT 3
12755: PUSH
12756: LD_INT 2
12758: PUSH
12759: LD_INT 6
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 5
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: LD_INT 6
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 24
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: LD_INT 3
12794: PUSH
12795: LD_INT 45
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 24
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: LD_INT 47
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 24
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: LD_INT 3
12830: PUSH
12831: LD_INT 45
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL 56910 0 2
// end else
12852: GO 12977
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12854: LD_INT 1
12856: PPUSH
12857: LD_INT 24
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 3
12865: PUSH
12866: LD_INT 47
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 47
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 5
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 2
12901: PUSH
12902: LD_INT 9
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 5
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: LD_INT 9
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 24
12931: PUSH
12932: LD_INT 1
12934: PUSH
12935: LD_INT 3
12937: PUSH
12938: LD_INT 45
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 24
12949: PUSH
12950: LD_INT 1
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: LD_INT 45
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL 56910 0 2
// end ; if Difficulty > 1 then
12977: LD_OWVAR 67
12981: PUSH
12982: LD_INT 1
12984: GREATER
12985: IFFALSE 13015
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12987: LD_INT 1
12989: PPUSH
12990: LD_INT 24
12992: PUSH
12993: LD_INT 3
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: LD_INT 47
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PUSH
13008: EMPTY
13009: LIST
13010: PPUSH
13011: CALL 56910 0 2
// repeat wait ( 0 0$1 ) ;
13015: LD_INT 35
13017: PPUSH
13018: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13022: LD_INT 1
13024: PPUSH
13025: LD_INT 1
13027: PPUSH
13028: CALL 58265 0 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: LD_INT 7
13038: PUSH
13039: LD_INT 7
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: LIST
13046: PUSH
13047: LD_OWVAR 67
13051: ARRAY
13052: GREATEREQUAL
13053: IFFALSE 13015
// wait ( 0 0$40 ) ;
13055: LD_INT 1400
13057: PPUSH
13058: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13062: LD_ADDR_VAR 0 2
13066: PUSH
13067: LD_INT 1
13069: PPUSH
13070: LD_INT 1
13072: PPUSH
13073: CALL 58265 0 2
13077: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13078: LD_ADDR_EXP 118
13082: PUSH
13083: LD_EXP 118
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: LD_EXP 118
13095: PUSH
13096: LD_INT 1
13098: ARRAY
13099: PUSH
13100: LD_VAR 0 2
13104: DIFF
13105: PPUSH
13106: CALL_OW 1
13110: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13111: LD_ADDR_VAR 0 3
13115: PUSH
13116: LD_INT 0
13118: PPUSH
13119: LD_INT 1
13121: PPUSH
13122: CALL_OW 12
13126: ST_TO_ADDR
// if target then
13127: LD_VAR 0 3
13131: IFFALSE 13297
// begin for i in tmp do
13133: LD_ADDR_VAR 0 1
13137: PUSH
13138: LD_VAR 0 2
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13169
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13146: LD_VAR 0 1
13150: PPUSH
13151: LD_INT 179
13153: PPUSH
13154: LD_INT 209
13156: PPUSH
13157: LD_INT 8
13159: PPUSH
13160: LD_INT 1
13162: PPUSH
13163: CALL_OW 483
13167: GO 13143
13169: POP
13170: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13171: LD_ADDR_VAR 0 2
13175: PUSH
13176: LD_VAR 0 2
13180: PPUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 250
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: PPUSH
13191: CALL_OW 72
13195: ST_TO_ADDR
// for i in tmp do
13196: LD_ADDR_VAR 0 1
13200: PUSH
13201: LD_VAR 0 2
13205: PUSH
13206: FOR_IN
13207: IFFALSE 13247
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13209: LD_VAR 0 1
13213: PPUSH
13214: LD_INT 179
13216: PPUSH
13217: LD_INT 209
13219: PPUSH
13220: CALL_OW 297
13224: PUSH
13225: LD_INT 9
13227: GREATER
13228: IFFALSE 13245
// ComMoveXY ( i , 179 , 209 ) ;
13230: LD_VAR 0 1
13234: PPUSH
13235: LD_INT 179
13237: PPUSH
13238: LD_INT 209
13240: PPUSH
13241: CALL_OW 111
13245: GO 13206
13247: POP
13248: POP
// wait ( 0 0$1 ) ;
13249: LD_INT 35
13251: PPUSH
13252: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13256: LD_VAR 0 2
13260: PPUSH
13261: LD_INT 92
13263: PUSH
13264: LD_INT 179
13266: PUSH
13267: LD_INT 209
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PPUSH
13279: CALL_OW 72
13283: PUSH
13284: LD_VAR 0 2
13288: PUSH
13289: LD_INT 1
13291: MINUS
13292: GREATEREQUAL
13293: IFFALSE 13171
// end else
13295: GO 13459
// begin for i in tmp do
13297: LD_ADDR_VAR 0 1
13301: PUSH
13302: LD_VAR 0 2
13306: PUSH
13307: FOR_IN
13308: IFFALSE 13333
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13310: LD_VAR 0 1
13314: PPUSH
13315: LD_INT 285
13317: PPUSH
13318: LD_INT 163
13320: PPUSH
13321: LD_INT 8
13323: PPUSH
13324: LD_INT 1
13326: PPUSH
13327: CALL_OW 483
13331: GO 13307
13333: POP
13334: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13335: LD_ADDR_VAR 0 2
13339: PUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: LD_INT 24
13347: PUSH
13348: LD_INT 250
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 72
13359: ST_TO_ADDR
// for i in tmp do
13360: LD_ADDR_VAR 0 1
13364: PUSH
13365: LD_VAR 0 2
13369: PUSH
13370: FOR_IN
13371: IFFALSE 13411
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13373: LD_VAR 0 1
13377: PPUSH
13378: LD_INT 285
13380: PPUSH
13381: LD_INT 163
13383: PPUSH
13384: CALL_OW 297
13388: PUSH
13389: LD_INT 9
13391: GREATER
13392: IFFALSE 13409
// ComMoveXY ( i , 285 , 163 ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: LD_INT 285
13401: PPUSH
13402: LD_INT 163
13404: PPUSH
13405: CALL_OW 111
13409: GO 13370
13411: POP
13412: POP
// wait ( 0 0$1 ) ;
13413: LD_INT 35
13415: PPUSH
13416: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13420: LD_VAR 0 2
13424: PPUSH
13425: LD_INT 92
13427: PUSH
13428: LD_INT 285
13430: PUSH
13431: LD_INT 163
13433: PUSH
13434: LD_INT 9
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: PUSH
13448: LD_VAR 0 2
13452: PUSH
13453: LD_INT 1
13455: MINUS
13456: GREATEREQUAL
13457: IFFALSE 13335
// end ; repeat wait ( 0 0$1 ) ;
13459: LD_INT 35
13461: PPUSH
13462: CALL_OW 67
// for i in tmp do
13466: LD_ADDR_VAR 0 1
13470: PUSH
13471: LD_VAR 0 2
13475: PUSH
13476: FOR_IN
13477: IFFALSE 13599
// if GetLives ( i ) > 251 then
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 256
13488: PUSH
13489: LD_INT 251
13491: GREATER
13492: IFFALSE 13581
// begin if GetWeapon ( i ) = ru_time_lapser then
13494: LD_VAR 0 1
13498: PPUSH
13499: CALL_OW 264
13503: PUSH
13504: LD_INT 49
13506: EQUAL
13507: IFFALSE 13545
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13509: LD_VAR 0 1
13513: PPUSH
13514: LD_INT 81
13516: PUSH
13517: LD_INT 7
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 69
13528: PPUSH
13529: LD_VAR 0 1
13533: PPUSH
13534: CALL_OW 74
13538: PPUSH
13539: CALL_OW 112
13543: GO 13579
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13545: LD_VAR 0 1
13549: PPUSH
13550: LD_INT 81
13552: PUSH
13553: LD_INT 7
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PPUSH
13565: LD_VAR 0 1
13569: PPUSH
13570: CALL_OW 74
13574: PPUSH
13575: CALL_OW 115
// end else
13579: GO 13597
// tmp := tmp diff i ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_VAR 0 2
13590: PUSH
13591: LD_VAR 0 1
13595: DIFF
13596: ST_TO_ADDR
13597: GO 13476
13599: POP
13600: POP
// until not tmp ;
13601: LD_VAR 0 2
13605: NOT
13606: IFFALSE 13459
// end ; end_of_file
13608: PPOPN 4
13610: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
13615: PPUSH
13616: PPUSH
// missionStage := 13 ;
13617: LD_ADDR_EXP 15
13621: PUSH
13622: LD_INT 13
13624: ST_TO_ADDR
// uc_side := 2 ;
13625: LD_ADDR_OWVAR 20
13629: PUSH
13630: LD_INT 2
13632: ST_TO_ADDR
// uc_nation := 2 ;
13633: LD_ADDR_OWVAR 21
13637: PUSH
13638: LD_INT 2
13640: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13641: LD_ADDR_EXP 89
13645: PUSH
13646: LD_STRING Omar
13648: PPUSH
13649: CALL_OW 25
13653: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13654: LD_EXP 89
13658: PPUSH
13659: LD_INT 4
13661: PPUSH
13662: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13666: LD_EXP 89
13670: PPUSH
13671: LD_INT 242
13673: PPUSH
13674: LD_INT 75
13676: PPUSH
13677: LD_INT 0
13679: PPUSH
13680: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13684: LD_ADDR_EXP 90
13688: PUSH
13689: LD_STRING Heike
13691: PPUSH
13692: CALL_OW 25
13696: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13697: LD_INT 14
13699: PPUSH
13700: LD_INT 3
13702: PPUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_INT 27
13708: PPUSH
13709: LD_INT 100
13711: PPUSH
13712: CALL 69515 0 5
// veh := CreateVehicle ;
13716: LD_ADDR_VAR 0 3
13720: PUSH
13721: CALL_OW 45
13725: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13726: LD_VAR 0 3
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 242
// SetDir ( veh , 4 ) ;
13738: LD_VAR 0 3
13742: PPUSH
13743: LD_INT 4
13745: PPUSH
13746: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13750: LD_VAR 0 3
13754: PPUSH
13755: LD_INT 241
13757: PPUSH
13758: LD_INT 72
13760: PPUSH
13761: LD_INT 0
13763: PPUSH
13764: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13768: LD_EXP 90
13772: PPUSH
13773: LD_VAR 0 3
13777: PPUSH
13778: CALL_OW 52
// if KhatamStatus then
13782: LD_EXP 8
13786: IFFALSE 13837
// begin Khatam := NewCharacter ( Khatam ) ;
13788: LD_ADDR_EXP 91
13792: PUSH
13793: LD_STRING Khatam
13795: PPUSH
13796: CALL_OW 25
13800: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13801: LD_EXP 91
13805: PPUSH
13806: LD_INT 245
13808: PPUSH
13809: LD_INT 78
13811: PPUSH
13812: LD_INT 3
13814: PPUSH
13815: LD_INT 0
13817: PPUSH
13818: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13822: LD_EXP 91
13826: PPUSH
13827: LD_INT 4
13829: PPUSH
13830: LD_INT 10
13832: PPUSH
13833: CALL_OW 237
// end ; for i = 1 to Difficulty do
13837: LD_ADDR_VAR 0 2
13841: PUSH
13842: DOUBLE
13843: LD_INT 1
13845: DEC
13846: ST_TO_ADDR
13847: LD_OWVAR 67
13851: PUSH
13852: FOR_TO
13853: IFFALSE 13919
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13855: LD_INT 0
13857: PPUSH
13858: LD_INT 7
13860: PUSH
13861: LD_OWVAR 67
13865: PLUS
13866: PPUSH
13867: CALL_OW 384
// un := CreateHuman ;
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: CALL_OW 44
13880: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13881: LD_VAR 0 4
13885: PPUSH
13886: LD_INT 28
13888: PUSH
13889: LD_INT 29
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_VAR 0 2
13900: PUSH
13901: LD_INT 2
13903: MOD
13904: PUSH
13905: LD_INT 1
13907: PLUS
13908: ARRAY
13909: PPUSH
13910: LD_INT 0
13912: PPUSH
13913: CALL_OW 49
// end ;
13917: GO 13852
13919: POP
13920: POP
// for i = 1 to 6 do
13921: LD_ADDR_VAR 0 2
13925: PUSH
13926: DOUBLE
13927: LD_INT 1
13929: DEC
13930: ST_TO_ADDR
13931: LD_INT 6
13933: PUSH
13934: FOR_TO
13935: IFFALSE 13980
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13937: LD_INT 0
13939: PPUSH
13940: LD_INT 7
13942: PUSH
13943: LD_OWVAR 67
13947: PLUS
13948: PPUSH
13949: CALL_OW 381
// un := CreateHuman ;
13953: LD_ADDR_VAR 0 4
13957: PUSH
13958: CALL_OW 44
13962: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13963: LD_VAR 0 4
13967: PPUSH
13968: LD_INT 28
13970: PPUSH
13971: LD_INT 0
13973: PPUSH
13974: CALL_OW 49
// end ;
13978: GO 13934
13980: POP
13981: POP
// for i = 1 to 3 do
13982: LD_ADDR_VAR 0 2
13986: PUSH
13987: DOUBLE
13988: LD_INT 1
13990: DEC
13991: ST_TO_ADDR
13992: LD_INT 3
13994: PUSH
13995: FOR_TO
13996: IFFALSE 14044
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13998: LD_INT 0
14000: PPUSH
14001: LD_INT 8
14003: PPUSH
14004: LD_INT 7
14006: PUSH
14007: LD_OWVAR 67
14011: PLUS
14012: PPUSH
14013: CALL_OW 380
// un := CreateHuman ;
14017: LD_ADDR_VAR 0 4
14021: PUSH
14022: CALL_OW 44
14026: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14027: LD_VAR 0 4
14031: PPUSH
14032: LD_INT 28
14034: PPUSH
14035: LD_INT 0
14037: PPUSH
14038: CALL_OW 49
// end ;
14042: GO 13995
14044: POP
14045: POP
// for i = 1 to 3 do
14046: LD_ADDR_VAR 0 2
14050: PUSH
14051: DOUBLE
14052: LD_INT 1
14054: DEC
14055: ST_TO_ADDR
14056: LD_INT 3
14058: PUSH
14059: FOR_TO
14060: IFFALSE 14150
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14062: LD_INT 14
14064: PPUSH
14065: LD_INT 2
14067: PPUSH
14068: LD_INT 1
14070: PPUSH
14071: LD_INT 28
14073: PPUSH
14074: LD_INT 80
14076: PPUSH
14077: CALL 69515 0 5
// veh := CreateVehicle ;
14081: LD_ADDR_VAR 0 3
14085: PUSH
14086: CALL_OW 45
14090: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14091: LD_VAR 0 3
14095: PPUSH
14096: LD_INT 3
14098: PPUSH
14099: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 29
14110: PPUSH
14111: LD_INT 0
14113: PPUSH
14114: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14118: LD_INT 0
14120: PPUSH
14121: LD_INT 7
14123: PUSH
14124: LD_OWVAR 67
14128: PLUS
14129: PPUSH
14130: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14134: CALL_OW 44
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: CALL_OW 52
// end ;
14148: GO 14059
14150: POP
14151: POP
// for i = 1 to 5 + Difficulty do
14152: LD_ADDR_VAR 0 2
14156: PUSH
14157: DOUBLE
14158: LD_INT 1
14160: DEC
14161: ST_TO_ADDR
14162: LD_INT 5
14164: PUSH
14165: LD_OWVAR 67
14169: PLUS
14170: PUSH
14171: FOR_TO
14172: IFFALSE 14299
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14174: LD_INT 14
14176: PPUSH
14177: LD_INT 1
14179: PPUSH
14180: LD_INT 3
14182: PPUSH
14183: CALL_OW 12
14187: PPUSH
14188: LD_INT 1
14190: PPUSH
14191: LD_INT 28
14193: PUSH
14194: LD_INT 26
14196: PUSH
14197: LD_INT 27
14199: PUSH
14200: LD_INT 25
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: PUSH
14209: LD_VAR 0 2
14213: PUSH
14214: LD_INT 4
14216: MOD
14217: PUSH
14218: LD_INT 1
14220: PLUS
14221: ARRAY
14222: PPUSH
14223: LD_INT 80
14225: PPUSH
14226: CALL 69515 0 5
// veh := CreateVehicle ;
14230: LD_ADDR_VAR 0 3
14234: PUSH
14235: CALL_OW 45
14239: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14240: LD_VAR 0 3
14244: PPUSH
14245: LD_INT 4
14247: PPUSH
14248: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14252: LD_VAR 0 3
14256: PPUSH
14257: LD_INT 28
14259: PPUSH
14260: LD_INT 0
14262: PPUSH
14263: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14267: LD_INT 0
14269: PPUSH
14270: LD_INT 7
14272: PUSH
14273: LD_OWVAR 67
14277: PLUS
14278: PPUSH
14279: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14283: CALL_OW 44
14287: PPUSH
14288: LD_VAR 0 3
14292: PPUSH
14293: CALL_OW 52
// end ;
14297: GO 14171
14299: POP
14300: POP
// for i = 1 to 3 do
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: DOUBLE
14307: LD_INT 1
14309: DEC
14310: ST_TO_ADDR
14311: LD_INT 3
14313: PUSH
14314: FOR_TO
14315: IFFALSE 14375
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14317: LD_INT 14
14319: PPUSH
14320: LD_INT 3
14322: PPUSH
14323: LD_INT 5
14325: PPUSH
14326: LD_INT 29
14328: PPUSH
14329: LD_INT 80
14331: PPUSH
14332: CALL 69515 0 5
// veh := CreateVehicle ;
14336: LD_ADDR_VAR 0 3
14340: PUSH
14341: CALL_OW 45
14345: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14346: LD_VAR 0 3
14350: PPUSH
14351: LD_INT 4
14353: PPUSH
14354: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 0
14368: PPUSH
14369: CALL_OW 49
// end ;
14373: GO 14314
14375: POP
14376: POP
// end ;
14377: LD_VAR 0 1
14381: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14382: LD_INT 22
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PPUSH
14392: CALL_OW 69
14396: IFFALSE 14696
14398: GO 14400
14400: DISABLE
14401: LD_INT 0
14403: PPUSH
14404: PPUSH
14405: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14406: LD_ADDR_VAR 0 3
14410: PUSH
14411: LD_INT 22
14413: PUSH
14414: LD_INT 2
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 25
14423: PUSH
14424: LD_INT 4
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PPUSH
14435: CALL_OW 69
14439: PUSH
14440: LD_EXP 91
14444: DIFF
14445: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: LD_INT 22
14453: PUSH
14454: LD_INT 2
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PPUSH
14461: CALL_OW 69
14465: PUSH
14466: LD_EXP 91
14470: PUSH
14471: LD_VAR 0 3
14475: UNION
14476: DIFF
14477: ST_TO_ADDR
// if Khatam then
14478: LD_EXP 91
14482: IFFALSE 14499
// ComMoveXY ( Khatam , 211 , 92 ) ;
14484: LD_EXP 91
14488: PPUSH
14489: LD_INT 211
14491: PPUSH
14492: LD_INT 92
14494: PPUSH
14495: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14499: LD_INT 197
14501: PPUSH
14502: LD_INT 80
14504: PPUSH
14505: LD_INT 2
14507: PPUSH
14508: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14512: LD_INT 213
14514: PPUSH
14515: LD_INT 90
14517: PPUSH
14518: LD_INT 2
14520: PPUSH
14521: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14525: LD_INT 215
14527: PPUSH
14528: LD_INT 129
14530: PPUSH
14531: LD_INT 2
14533: PPUSH
14534: CALL_OW 441
// if sci then
14538: LD_VAR 0 3
14542: IFFALSE 14563
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14544: LD_VAR 0 3
14548: PUSH
14549: LD_INT 1
14551: ARRAY
14552: PPUSH
14553: LD_INT 197
14555: PPUSH
14556: LD_INT 80
14558: PPUSH
14559: CALL_OW 158
// if sci > 1 then
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 1
14570: GREATER
14571: IFFALSE 14592
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14573: LD_VAR 0 3
14577: PUSH
14578: LD_INT 2
14580: ARRAY
14581: PPUSH
14582: LD_INT 213
14584: PPUSH
14585: LD_INT 90
14587: PPUSH
14588: CALL_OW 158
// if sci > 2 then
14592: LD_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: GREATER
14600: IFFALSE 14621
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14602: LD_VAR 0 3
14606: PUSH
14607: LD_INT 3
14609: ARRAY
14610: PPUSH
14611: LD_INT 215
14613: PPUSH
14614: LD_INT 129
14616: PPUSH
14617: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14621: LD_INT 35
14623: PPUSH
14624: CALL_OW 67
// for i in tmp do
14628: LD_ADDR_VAR 0 1
14632: PUSH
14633: LD_VAR 0 2
14637: PUSH
14638: FOR_IN
14639: IFFALSE 14677
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14641: LD_VAR 0 1
14645: PPUSH
14646: LD_INT 81
14648: PUSH
14649: LD_INT 2
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PPUSH
14656: CALL_OW 69
14660: PPUSH
14661: LD_VAR 0 1
14665: PPUSH
14666: CALL_OW 74
14670: PPUSH
14671: CALL_OW 115
14675: GO 14638
14677: POP
14678: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14679: LD_INT 22
14681: PUSH
14682: LD_INT 2
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: NOT
14694: IFFALSE 14621
// end ; end_of_file
14696: PPOPN 3
14698: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14699: LD_INT 0
14701: PPUSH
14702: PPUSH
14703: PPUSH
14704: PPUSH
14705: PPUSH
14706: PPUSH
14707: PPUSH
14708: PPUSH
14709: PPUSH
// Video ( true ) ;
14710: LD_INT 1
14712: PPUSH
14713: CALL 105232 0 1
// if debug then
14717: LD_EXP 1
14721: IFFALSE 14731
// dialogue_skipped := true ;
14723: LD_ADDR_OWVAR 59
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14731: LD_ADDR_VAR 0 5
14735: PUSH
14736: LD_INT 7
14738: PPUSH
14739: LD_INT 0
14741: PPUSH
14742: CALL_OW 517
14746: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14747: LD_ADDR_VAR 0 2
14751: PUSH
14752: DOUBLE
14753: LD_INT 1
14755: DEC
14756: ST_TO_ADDR
14757: LD_VAR 0 5
14761: PUSH
14762: LD_INT 1
14764: ARRAY
14765: PUSH
14766: FOR_TO
14767: IFFALSE 14812
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14769: LD_VAR 0 5
14773: PUSH
14774: LD_INT 1
14776: ARRAY
14777: PUSH
14778: LD_VAR 0 2
14782: ARRAY
14783: PPUSH
14784: LD_VAR 0 5
14788: PUSH
14789: LD_INT 2
14791: ARRAY
14792: PUSH
14793: LD_VAR 0 2
14797: ARRAY
14798: PPUSH
14799: LD_INT 1
14801: PPUSH
14802: LD_INT 15
14804: NEG
14805: PPUSH
14806: CALL 105146 0 4
14810: GO 14766
14812: POP
14813: POP
// CenterNowOnUnits ( Powell ) ;
14814: LD_EXP 55
14818: PPUSH
14819: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14823: LD_ADDR_VAR 0 5
14827: PUSH
14828: LD_EXP 53
14832: PUSH
14833: EMPTY
14834: LIST
14835: ST_TO_ADDR
// if GirlNewVeh then
14836: LD_EXP 54
14840: IFFALSE 14858
// tmp := tmp ^ GirlNewVeh ;
14842: LD_ADDR_VAR 0 5
14846: PUSH
14847: LD_VAR 0 5
14851: PUSH
14852: LD_EXP 54
14856: ADD
14857: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14858: LD_VAR 0 5
14862: PPUSH
14863: LD_INT 60
14865: PPUSH
14866: LD_INT 109
14868: PPUSH
14869: CALL_OW 111
// if KappaStatus then
14873: LD_EXP 2
14877: IFFALSE 14929
// begin Say ( JMM , D1nT-JMM-1 ) ;
14879: LD_EXP 36
14883: PPUSH
14884: LD_STRING D1nT-JMM-1
14886: PPUSH
14887: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14891: LD_EXP 55
14895: PPUSH
14896: LD_STRING D1T-Pow-1
14898: PPUSH
14899: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14903: LD_EXP 36
14907: PPUSH
14908: LD_STRING D1T-JMM-2
14910: PPUSH
14911: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14915: LD_EXP 55
14919: PPUSH
14920: LD_STRING D1T-Pow-2
14922: PPUSH
14923: CALL_OW 88
// end else
14927: GO 15135
// if JMMGirlStatus then
14929: LD_EXP 6
14933: IFFALSE 15078
// begin Say ( JMM , D1T-JMM-1 ) ;
14935: LD_EXP 36
14939: PPUSH
14940: LD_STRING D1T-JMM-1
14942: PPUSH
14943: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14947: LD_EXP 55
14951: PPUSH
14952: LD_STRING D1T-Pow-1
14954: PPUSH
14955: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14959: LD_EXP 36
14963: PPUSH
14964: LD_STRING D1T-JMM-3
14966: PPUSH
14967: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14971: LD_EXP 55
14975: PPUSH
14976: LD_STRING D1T-Pow-3
14978: PPUSH
14979: CALL_OW 88
// if JMMGirl then
14983: LD_EXP 7
14987: IFFALSE 15076
// begin case JMMGirl of 1 :
14989: LD_EXP 7
14993: PUSH
14994: LD_INT 1
14996: DOUBLE
14997: EQUAL
14998: IFTRUE 15002
15000: GO 15017
15002: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15003: LD_EXP 37
15007: PPUSH
15008: LD_STRING D1T-Joan-3
15010: PPUSH
15011: CALL_OW 88
15015: GO 15064
15017: LD_INT 2
15019: DOUBLE
15020: EQUAL
15021: IFTRUE 15025
15023: GO 15040
15025: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15026: LD_EXP 39
15030: PPUSH
15031: LD_STRING D1T-Lisa-3
15033: PPUSH
15034: CALL_OW 88
15038: GO 15064
15040: LD_INT 3
15042: DOUBLE
15043: EQUAL
15044: IFTRUE 15048
15046: GO 15063
15048: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15049: LD_EXP 51
15053: PPUSH
15054: LD_STRING D1T-Con-3
15056: PPUSH
15057: CALL_OW 88
15061: GO 15064
15063: POP
// Say ( Powell , D1T-Pow-4 ) ;
15064: LD_EXP 55
15068: PPUSH
15069: LD_STRING D1T-Pow-4
15071: PPUSH
15072: CALL_OW 88
// end ; end else
15076: GO 15135
// if not FastEnd then
15078: LD_EXP 11
15082: NOT
15083: IFFALSE 15111
// begin Say ( JMM , D1T-JMM-4 ) ;
15085: LD_EXP 36
15089: PPUSH
15090: LD_STRING D1T-JMM-4
15092: PPUSH
15093: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15097: LD_EXP 55
15101: PPUSH
15102: LD_STRING D1T-Pow-5
15104: PPUSH
15105: CALL_OW 88
// end else
15109: GO 15135
// begin Say ( JMM , D1nT-JMM-1 ) ;
15111: LD_EXP 36
15115: PPUSH
15116: LD_STRING D1nT-JMM-1
15118: PPUSH
15119: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15123: LD_EXP 55
15127: PPUSH
15128: LD_STRING D1nT-Pow-1
15130: PPUSH
15131: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15135: LD_INT 35
15137: PPUSH
15138: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15142: LD_EXP 53
15146: PPUSH
15147: CALL_OW 314
15151: NOT
15152: IFFALSE 15135
// ComExitVehicle ( JMM ) ;
15154: LD_EXP 36
15158: PPUSH
15159: CALL_OW 121
// wait ( 3 ) ;
15163: LD_INT 3
15165: PPUSH
15166: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_INT 60
15177: PPUSH
15178: LD_INT 94
15180: PPUSH
15181: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15185: LD_EXP 36
15189: PPUSH
15190: LD_EXP 55
15194: PPUSH
15195: CALL_OW 179
// if Joan then
15199: LD_EXP 37
15203: IFFALSE 15257
// begin ComExitVehicle ( Joan ) ;
15205: LD_EXP 37
15209: PPUSH
15210: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15214: LD_EXP 37
15218: PPUSH
15219: LD_INT 35
15221: PPUSH
15222: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15226: LD_EXP 37
15230: PPUSH
15231: LD_INT 65
15233: PPUSH
15234: LD_INT 104
15236: PPUSH
15237: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15241: LD_EXP 37
15245: PPUSH
15246: LD_EXP 36
15250: PPUSH
15251: CALL_OW 179
// end else
15255: GO 15391
// if Lisa and JMMGirl = 2 then
15257: LD_EXP 39
15261: PUSH
15262: LD_EXP 7
15266: PUSH
15267: LD_INT 2
15269: EQUAL
15270: AND
15271: IFFALSE 15325
// begin ComExitVehicle ( Lisa ) ;
15273: LD_EXP 39
15277: PPUSH
15278: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15282: LD_EXP 39
15286: PPUSH
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15294: LD_EXP 39
15298: PPUSH
15299: LD_INT 65
15301: PPUSH
15302: LD_INT 104
15304: PPUSH
15305: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15309: LD_EXP 39
15313: PPUSH
15314: LD_EXP 36
15318: PPUSH
15319: CALL_OW 179
// end else
15323: GO 15391
// if Connie and JMMGirl = 3 then
15325: LD_EXP 51
15329: PUSH
15330: LD_EXP 7
15334: PUSH
15335: LD_INT 3
15337: EQUAL
15338: AND
15339: IFFALSE 15391
// begin ComExitVehicle ( Connie ) ;
15341: LD_EXP 51
15345: PPUSH
15346: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15350: LD_EXP 51
15354: PPUSH
15355: LD_INT 35
15357: PPUSH
15358: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15362: LD_EXP 51
15366: PPUSH
15367: LD_INT 65
15369: PPUSH
15370: LD_INT 104
15372: PPUSH
15373: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15377: LD_EXP 51
15381: PPUSH
15382: LD_EXP 36
15386: PPUSH
15387: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15391: LD_INT 35
15393: PPUSH
15394: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15398: LD_EXP 36
15402: PPUSH
15403: LD_EXP 55
15407: PPUSH
15408: CALL_OW 296
15412: PUSH
15413: LD_INT 6
15415: LESS
15416: IFFALSE 15391
// wait ( 0 0$0.5 ) ;
15418: LD_INT 18
15420: PPUSH
15421: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15425: LD_EXP 36
15429: PPUSH
15430: LD_STRING D1-JMM-1
15432: PPUSH
15433: CALL_OW 88
// async ;
15437: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15438: LD_EXP 55
15442: PPUSH
15443: LD_STRING D1-Pow-1
15445: PPUSH
15446: CALL_OW 88
// if not dialogue_skipped then
15450: LD_OWVAR 59
15454: NOT
15455: IFFALSE 15464
// wait ( 0 0$2 ) ;
15457: LD_INT 70
15459: PPUSH
15460: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15464: LD_INT 170
15466: PPUSH
15467: LD_INT 99
15469: PPUSH
15470: LD_INT 1
15472: PPUSH
15473: LD_INT 6
15475: NEG
15476: PPUSH
15477: CALL 105146 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15481: LD_INT 174
15483: PPUSH
15484: LD_INT 115
15486: PPUSH
15487: LD_INT 1
15489: PPUSH
15490: LD_INT 6
15492: NEG
15493: PPUSH
15494: CALL 105146 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15498: LD_INT 169
15500: PPUSH
15501: LD_INT 71
15503: PPUSH
15504: LD_INT 1
15506: PPUSH
15507: LD_INT 6
15509: NEG
15510: PPUSH
15511: CALL 105146 0 4
// if not dialogue_skipped then
15515: LD_OWVAR 59
15519: NOT
15520: IFFALSE 15539
// begin CenterOnXY ( 170 , 99 ) ;
15522: LD_INT 170
15524: PPUSH
15525: LD_INT 99
15527: PPUSH
15528: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15532: LD_INT 80
15534: PPUSH
15535: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15539: LD_INT 75
15541: PPUSH
15542: LD_INT 53
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 9
15550: NEG
15551: PPUSH
15552: CALL 105146 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15556: LD_INT 54
15558: PPUSH
15559: LD_INT 42
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 9
15567: NEG
15568: PPUSH
15569: CALL 105146 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15573: LD_INT 62
15575: PPUSH
15576: LD_INT 51
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 9
15584: NEG
15585: PPUSH
15586: CALL 105146 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 75 , 53 ) ;
15597: LD_INT 75
15599: PPUSH
15600: LD_INT 53
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$4 ) ;
15607: LD_INT 140
15609: PPUSH
15610: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15614: LD_EXP 55
15618: PPUSH
15619: CALL_OW 87
// if not dialogue_skipped then
15623: LD_OWVAR 59
15627: NOT
15628: IFFALSE 15637
// wait ( 0 0$2 ) ;
15630: LD_INT 70
15632: PPUSH
15633: CALL_OW 67
// sync ;
15637: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15638: LD_EXP 36
15642: PPUSH
15643: LD_STRING D1-JMM-2
15645: PPUSH
15646: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15650: LD_EXP 55
15654: PPUSH
15655: LD_STRING D1-Pow-2
15657: PPUSH
15658: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15662: LD_EXP 36
15666: PPUSH
15667: LD_STRING D1-JMM-3
15669: PPUSH
15670: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15674: LD_EXP 55
15678: PPUSH
15679: LD_STRING D1-Pow-3
15681: PPUSH
15682: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15686: LD_EXP 36
15690: PPUSH
15691: LD_STRING D1-JMM-4
15693: PPUSH
15694: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15698: LD_EXP 55
15702: PPUSH
15703: LD_STRING D1-Pow-4
15705: PPUSH
15706: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15710: LD_EXP 36
15714: PPUSH
15715: LD_STRING D1-JMM-5
15717: PPUSH
15718: CALL_OW 88
// async ;
15722: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15723: LD_EXP 55
15727: PPUSH
15728: LD_STRING D1-Pow-5
15730: PPUSH
15731: CALL_OW 88
// if not dialogue_skipped then
15735: LD_OWVAR 59
15739: NOT
15740: IFFALSE 15749
// wait ( 0 0$3.6 ) ;
15742: LD_INT 126
15744: PPUSH
15745: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15749: LD_INT 134
15751: PPUSH
15752: LD_INT 210
15754: PPUSH
15755: LD_INT 1
15757: PPUSH
15758: LD_INT 11
15760: NEG
15761: PPUSH
15762: CALL 105146 0 4
// if not dialogue_skipped then
15766: LD_OWVAR 59
15770: NOT
15771: IFFALSE 15790
// begin CenterOnXY ( 134 , 210 ) ;
15773: LD_INT 134
15775: PPUSH
15776: LD_INT 210
15778: PPUSH
15779: CALL_OW 84
// wait ( 0 0$2 ) ;
15783: LD_INT 70
15785: PPUSH
15786: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15790: LD_INT 101
15792: PPUSH
15793: LD_INT 159
15795: PPUSH
15796: LD_INT 1
15798: PPUSH
15799: LD_INT 10
15801: NEG
15802: PPUSH
15803: CALL 105146 0 4
// if not dialogue_skipped then
15807: LD_OWVAR 59
15811: NOT
15812: IFFALSE 15831
// begin CenterOnXY ( 101 , 159 ) ;
15814: LD_INT 101
15816: PPUSH
15817: LD_INT 159
15819: PPUSH
15820: CALL_OW 84
// wait ( 0 0$2 ) ;
15824: LD_INT 70
15826: PPUSH
15827: CALL_OW 67
// end ; sync ;
15831: SYNC
// CenterNowOnUnits ( Powell ) ;
15832: LD_EXP 55
15836: PPUSH
15837: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15841: LD_ADDR_VAR 0 6
15845: PUSH
15846: LD_INT 1
15848: PUSH
15849: LD_INT 2
15851: PUSH
15852: LD_INT 3
15854: PUSH
15855: LD_INT 4
15857: PUSH
15858: LD_INT 5
15860: PUSH
15861: LD_INT 6
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: LIST
15868: LIST
15869: LIST
15870: LIST
15871: ST_TO_ADDR
// if not dialogue_skipped then
15872: LD_OWVAR 59
15876: NOT
15877: IFFALSE 16046
// begin game_speed := 4 ;
15879: LD_ADDR_OWVAR 65
15883: PUSH
15884: LD_INT 4
15886: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15887: LD_INT 210
15889: PPUSH
15890: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15894: LD_ADDR_VAR 0 7
15898: PUSH
15899: LD_STRING Q1
15901: PPUSH
15902: LD_VAR 0 6
15906: PPUSH
15907: CALL_OW 98
15911: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15912: LD_ADDR_VAR 0 7
15916: PUSH
15917: LD_STRING Q1
15919: PPUSH
15920: LD_VAR 0 6
15924: PPUSH
15925: CALL_OW 98
15929: ST_TO_ADDR
// options = options diff dec ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 6
15939: PUSH
15940: LD_VAR 0 7
15944: DIFF
15945: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15946: LD_VAR 0 7
15950: PPUSH
15951: LD_VAR 0 6
15955: PPUSH
15956: CALL 17349 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15960: LD_VAR 0 7
15964: PUSH
15965: LD_INT 5
15967: PUSH
15968: LD_INT 6
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: IN
15975: PUSH
15976: LD_VAR 0 6
15980: PUSH
15981: LD_INT 2
15983: EQUAL
15984: OR
15985: IFFALSE 15912
// if not ( dec in [ 5 , 6 ] ) then
15987: LD_VAR 0 7
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 6
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: IN
16002: NOT
16003: IFFALSE 16046
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16005: LD_ADDR_VAR 0 7
16009: PUSH
16010: LD_STRING Q1a
16012: PPUSH
16013: LD_INT 1
16015: PUSH
16016: LD_INT 2
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PPUSH
16023: CALL_OW 98
16027: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16028: LD_VAR 0 7
16032: PUSH
16033: LD_INT 4
16035: PLUS
16036: PPUSH
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL 17349 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16046: LD_INT 81
16048: PPUSH
16049: LD_INT 127
16051: PPUSH
16052: CALL_OW 84
// amount := 5 ;
16056: LD_ADDR_VAR 0 8
16060: PUSH
16061: LD_INT 5
16063: ST_TO_ADDR
// macmilan_squad := [ ] ;
16064: LD_ADDR_VAR 0 9
16068: PUSH
16069: EMPTY
16070: ST_TO_ADDR
// if vip < amount then
16071: LD_EXP 56
16075: PUSH
16076: LD_VAR 0 8
16080: LESS
16081: IFFALSE 16125
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16083: LD_ADDR_VAR 0 5
16087: PUSH
16088: LD_EXP 56
16092: PUSH
16093: LD_INT 22
16095: PUSH
16096: LD_INT 4
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 21
16105: PUSH
16106: LD_INT 1
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 69
16121: UNION
16122: ST_TO_ADDR
16123: GO 16135
// tmp := vip ;
16125: LD_ADDR_VAR 0 5
16129: PUSH
16130: LD_EXP 56
16134: ST_TO_ADDR
// tmp := tmp diff Powell ;
16135: LD_ADDR_VAR 0 5
16139: PUSH
16140: LD_VAR 0 5
16144: PUSH
16145: LD_EXP 55
16149: DIFF
16150: ST_TO_ADDR
// if tmp < amount then
16151: LD_VAR 0 5
16155: PUSH
16156: LD_VAR 0 8
16160: LESS
16161: IFFALSE 16173
// amount := tmp ;
16163: LD_ADDR_VAR 0 8
16167: PUSH
16168: LD_VAR 0 5
16172: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16173: LD_VAR 0 5
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PPUSH
16182: CALL_OW 257
16186: PUSH
16187: LD_INT 2
16189: NONEQUAL
16190: IFFALSE 16252
// begin if IsInUnit ( tmp [ 1 ] ) then
16192: LD_VAR 0 5
16196: PUSH
16197: LD_INT 1
16199: ARRAY
16200: PPUSH
16201: CALL_OW 310
16205: IFFALSE 16220
// ComExitBuilding ( tmp [ 1 ] ) ;
16207: LD_VAR 0 5
16211: PUSH
16212: LD_INT 1
16214: ARRAY
16215: PPUSH
16216: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16220: LD_VAR 0 5
16224: PUSH
16225: LD_INT 1
16227: ARRAY
16228: PPUSH
16229: LD_INT 387
16231: PPUSH
16232: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16236: LD_VAR 0 5
16240: PUSH
16241: LD_INT 1
16243: ARRAY
16244: PPUSH
16245: LD_INT 2
16247: PPUSH
16248: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16252: LD_EXP 36
16256: PPUSH
16257: LD_INT 82
16259: PPUSH
16260: LD_INT 129
16262: PPUSH
16263: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16267: LD_EXP 36
16271: PPUSH
16272: LD_EXP 55
16276: PPUSH
16277: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16281: LD_INT 22
16283: PUSH
16284: LD_INT 1
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PPUSH
16291: CALL_OW 69
16295: PUSH
16296: LD_EXP 36
16300: DIFF
16301: PPUSH
16302: LD_INT 84
16304: PPUSH
16305: LD_INT 128
16307: PPUSH
16308: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16312: LD_INT 22
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PPUSH
16322: CALL_OW 69
16326: PUSH
16327: LD_EXP 36
16331: DIFF
16332: PPUSH
16333: LD_EXP 36
16337: PPUSH
16338: CALL_OW 179
// for i = 1 to amount do
16342: LD_ADDR_VAR 0 2
16346: PUSH
16347: DOUBLE
16348: LD_INT 1
16350: DEC
16351: ST_TO_ADDR
16352: LD_VAR 0 8
16356: PUSH
16357: FOR_TO
16358: IFFALSE 16526
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16360: LD_ADDR_VAR 0 9
16364: PUSH
16365: LD_VAR 0 9
16369: PUSH
16370: LD_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: ARRAY
16380: ADD
16381: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16382: LD_VAR 0 5
16386: PUSH
16387: LD_VAR 0 2
16391: ARRAY
16392: PPUSH
16393: CALL_OW 310
16397: IFFALSE 16414
// AddComExitBuilding ( tmp [ i ] ) ;
16399: LD_VAR 0 5
16403: PUSH
16404: LD_VAR 0 2
16408: ARRAY
16409: PPUSH
16410: CALL_OW 182
// if i = 2 and JMMNewVeh then
16414: LD_VAR 0 2
16418: PUSH
16419: LD_INT 2
16421: EQUAL
16422: PUSH
16423: LD_EXP 53
16427: AND
16428: IFFALSE 16486
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16430: LD_VAR 0 5
16434: PUSH
16435: LD_VAR 0 2
16439: ARRAY
16440: PPUSH
16441: LD_EXP 53
16445: PPUSH
16446: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16450: LD_VAR 0 5
16454: PUSH
16455: LD_VAR 0 2
16459: ARRAY
16460: PPUSH
16461: LD_INT 86
16463: PPUSH
16464: LD_INT 133
16466: PPUSH
16467: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16471: LD_VAR 0 5
16475: PUSH
16476: LD_VAR 0 2
16480: ARRAY
16481: PPUSH
16482: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16486: LD_VAR 0 5
16490: PUSH
16491: LD_VAR 0 2
16495: ARRAY
16496: PPUSH
16497: LD_INT 8
16499: PPUSH
16500: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16504: LD_VAR 0 5
16508: PUSH
16509: LD_VAR 0 2
16513: ARRAY
16514: PPUSH
16515: LD_EXP 36
16519: PPUSH
16520: CALL_OW 179
// end ;
16524: GO 16357
16526: POP
16527: POP
// if GirlNewVeh then
16528: LD_EXP 54
16532: IFFALSE 16546
// SetSide ( GirlNewVeh , 4 ) ;
16534: LD_EXP 54
16538: PPUSH
16539: LD_INT 4
16541: PPUSH
16542: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16546: LD_INT 35
16548: PPUSH
16549: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16553: LD_VAR 0 9
16557: PPUSH
16558: LD_INT 95
16560: PUSH
16561: LD_INT 9
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PPUSH
16568: CALL_OW 72
16572: PUSH
16573: LD_INT 0
16575: EQUAL
16576: PUSH
16577: LD_EXP 36
16581: PPUSH
16582: LD_INT 9
16584: PPUSH
16585: CALL_OW 308
16589: NOT
16590: AND
16591: IFFALSE 16546
// wait ( 0 0$2 ) ;
16593: LD_INT 70
16595: PPUSH
16596: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16600: LD_VAR 0 9
16604: PPUSH
16605: LD_INT 1
16607: PPUSH
16608: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16612: LD_INT 21
16614: PUSH
16615: LD_INT 2
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: LD_INT 92
16624: PUSH
16625: LD_INT 83
16627: PUSH
16628: LD_INT 130
16630: PUSH
16631: LD_INT 10
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: PPUSH
16644: CALL_OW 69
16648: PPUSH
16649: LD_INT 1
16651: PPUSH
16652: CALL_OW 235
// Video ( false ) ;
16656: LD_INT 0
16658: PPUSH
16659: CALL 105232 0 1
// ChangeMissionObjectives ( M1 ) ;
16663: LD_STRING M1
16665: PPUSH
16666: CALL_OW 337
// SaveForQuickRestart ;
16670: CALL_OW 22
// missionStart := true ;
16674: LD_ADDR_EXP 13
16678: PUSH
16679: LD_INT 1
16681: ST_TO_ADDR
// missionStage := 2 ;
16682: LD_ADDR_EXP 15
16686: PUSH
16687: LD_INT 2
16689: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16690: LD_INT 105
16692: PPUSH
16693: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16697: LD_ADDR_VAR 0 5
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_INT 4
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 21
16714: PUSH
16715: LD_INT 1
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PPUSH
16726: CALL_OW 69
16730: PUSH
16731: LD_EXP 55
16735: DIFF
16736: ST_TO_ADDR
// if not tmp then
16737: LD_VAR 0 5
16741: NOT
16742: IFFALSE 16757
// tmp := [ Powell ] ;
16744: LD_ADDR_VAR 0 5
16748: PUSH
16749: LD_EXP 55
16753: PUSH
16754: EMPTY
16755: LIST
16756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16757: LD_ADDR_EXP 99
16761: PUSH
16762: LD_EXP 99
16766: PPUSH
16767: LD_INT 4
16769: PPUSH
16770: LD_INT 22
16772: PUSH
16773: LD_INT 4
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: LD_INT 23
16782: PUSH
16783: LD_INT 1
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: PUSH
16790: LD_INT 3
16792: PUSH
16793: LD_INT 21
16795: PUSH
16796: LD_INT 2
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PPUSH
16812: CALL_OW 69
16816: PUSH
16817: LD_EXP 55
16821: DIFF
16822: PPUSH
16823: CALL_OW 1
16827: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16828: LD_ADDR_VAR 0 4
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 4
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 34
16845: PUSH
16846: LD_INT 12
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: PUSH
16862: LD_INT 1
16864: ARRAY
16865: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16866: LD_VAR 0 5
16870: PUSH
16871: LD_INT 1
16873: ARRAY
16874: PPUSH
16875: CALL_OW 310
16879: IFFALSE 16894
// ComExitBuilding ( tmp [ 1 ] ) ;
16881: LD_VAR 0 5
16885: PUSH
16886: LD_INT 1
16888: ARRAY
16889: PPUSH
16890: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16894: LD_VAR 0 5
16898: PUSH
16899: LD_INT 1
16901: ARRAY
16902: PPUSH
16903: LD_VAR 0 4
16907: PPUSH
16908: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16912: LD_VAR 0 5
16916: PUSH
16917: LD_INT 1
16919: ARRAY
16920: PPUSH
16921: LD_INT 80
16923: PPUSH
16924: LD_INT 136
16926: PPUSH
16927: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16931: LD_VAR 0 5
16935: PUSH
16936: LD_INT 1
16938: ARRAY
16939: PPUSH
16940: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16944: LD_VAR 0 5
16948: PUSH
16949: LD_INT 1
16951: ARRAY
16952: PPUSH
16953: LD_INT 59
16955: PPUSH
16956: LD_INT 112
16958: PPUSH
16959: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16963: LD_VAR 0 5
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PPUSH
16972: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16976: LD_EXP 39
16980: PUSH
16981: LD_EXP 56
16985: IN
16986: PUSH
16987: LD_EXP 39
16991: PPUSH
16992: CALL_OW 255
16996: PUSH
16997: LD_INT 1
16999: EQUAL
17000: AND
17001: IFFALSE 17017
// Say ( Lisa , D3nW-Lisa-1 ) else
17003: LD_EXP 39
17007: PPUSH
17008: LD_STRING D3nW-Lisa-1
17010: PPUSH
17011: CALL_OW 88
17015: GO 17261
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17017: LD_EXP 42
17021: PUSH
17022: LD_EXP 56
17026: IN
17027: PUSH
17028: LD_EXP 42
17032: PPUSH
17033: CALL_OW 255
17037: PUSH
17038: LD_INT 1
17040: EQUAL
17041: AND
17042: IFFALSE 17058
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17044: LD_EXP 42
17048: PPUSH
17049: LD_STRING D3nW-Cyrus-1
17051: PPUSH
17052: CALL_OW 88
17056: GO 17261
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17058: LD_EXP 41
17062: PUSH
17063: LD_EXP 56
17067: IN
17068: PUSH
17069: LD_EXP 41
17073: PPUSH
17074: CALL_OW 255
17078: PUSH
17079: LD_INT 1
17081: EQUAL
17082: AND
17083: IFFALSE 17099
// Say ( Bobby , D3nW-Bobby-1 ) else
17085: LD_EXP 41
17089: PPUSH
17090: LD_STRING D3nW-Bobby-1
17092: PPUSH
17093: CALL_OW 88
17097: GO 17261
// if Gary in vip and GetSide ( Gary ) = 1 then
17099: LD_EXP 48
17103: PUSH
17104: LD_EXP 56
17108: IN
17109: PUSH
17110: LD_EXP 48
17114: PPUSH
17115: CALL_OW 255
17119: PUSH
17120: LD_INT 1
17122: EQUAL
17123: AND
17124: IFFALSE 17140
// Say ( Gary , D3nW-Gary-1 ) else
17126: LD_EXP 48
17130: PPUSH
17131: LD_STRING D3nW-Gary-1
17133: PPUSH
17134: CALL_OW 88
17138: GO 17261
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17140: LD_EXP 40
17144: PUSH
17145: LD_EXP 56
17149: IN
17150: PUSH
17151: LD_EXP 40
17155: PPUSH
17156: CALL_OW 255
17160: PUSH
17161: LD_INT 1
17163: EQUAL
17164: AND
17165: IFFALSE 17181
// Say ( Donaldson , D3nW-Don-1 ) else
17167: LD_EXP 40
17171: PPUSH
17172: LD_STRING D3nW-Don-1
17174: PPUSH
17175: CALL_OW 88
17179: GO 17261
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17181: LD_EXP 47
17185: PUSH
17186: LD_EXP 56
17190: IN
17191: PUSH
17192: LD_EXP 47
17196: PPUSH
17197: CALL_OW 255
17201: PUSH
17202: LD_INT 1
17204: EQUAL
17205: AND
17206: IFFALSE 17222
// Say ( Cornel , D3nW-Corn-1 ) else
17208: LD_EXP 47
17212: PPUSH
17213: LD_STRING D3nW-Corn-1
17215: PPUSH
17216: CALL_OW 88
17220: GO 17261
// if Frank in vip and GetSide ( Frank ) = 1 then
17222: LD_EXP 49
17226: PUSH
17227: LD_EXP 56
17231: IN
17232: PUSH
17233: LD_EXP 49
17237: PPUSH
17238: CALL_OW 255
17242: PUSH
17243: LD_INT 1
17245: EQUAL
17246: AND
17247: IFFALSE 17261
// Say ( Frank , D3nW-Frank-1 ) ;
17249: LD_EXP 49
17253: PPUSH
17254: LD_STRING D3nW-Frank-1
17256: PPUSH
17257: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17261: LD_EXP 36
17265: PPUSH
17266: LD_STRING D3nW-JMM-1
17268: PPUSH
17269: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17273: LD_EXP 36
17277: PPUSH
17278: LD_STRING D3nW-JMM-1a
17280: PPUSH
17281: CALL_OW 88
// t := 0 0$00 ;
17285: LD_ADDR_VAR 0 3
17289: PUSH
17290: LD_INT 0
17292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17293: LD_INT 35
17295: PPUSH
17296: CALL_OW 67
// t := t + 0 0$1 ;
17300: LD_ADDR_VAR 0 3
17304: PUSH
17305: LD_VAR 0 3
17309: PUSH
17310: LD_INT 35
17312: PLUS
17313: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17314: LD_INT 59
17316: PPUSH
17317: LD_INT 112
17319: PPUSH
17320: CALL_OW 428
17324: PUSH
17325: LD_VAR 0 3
17329: PUSH
17330: LD_INT 2100
17332: GREATER
17333: OR
17334: IFFALSE 17293
// activeAttacks := true ;
17336: LD_ADDR_EXP 16
17340: PUSH
17341: LD_INT 1
17343: ST_TO_ADDR
// end ;
17344: LD_VAR 0 1
17348: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17349: LD_INT 0
17351: PPUSH
// case question of 1 :
17352: LD_VAR 0 1
17356: PUSH
17357: LD_INT 1
17359: DOUBLE
17360: EQUAL
17361: IFTRUE 17365
17363: GO 17416
17365: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17366: LD_EXP 36
17370: PPUSH
17371: LD_STRING D2Mot-JMM-1
17373: PPUSH
17374: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17378: LD_EXP 55
17382: PPUSH
17383: LD_STRING D2Mot-Pow-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17390: LD_EXP 36
17394: PPUSH
17395: LD_STRING D2Mot-JMM-2
17397: PPUSH
17398: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17402: LD_EXP 55
17406: PPUSH
17407: LD_STRING D2Mot-Pow-2
17409: PPUSH
17410: CALL_OW 88
// end ; 2 :
17414: GO 17759
17416: LD_INT 2
17418: DOUBLE
17419: EQUAL
17420: IFTRUE 17424
17422: GO 17500
17424: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17425: LD_EXP 36
17429: PPUSH
17430: LD_STRING D2Rus-JMM-1
17432: PPUSH
17433: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17437: LD_EXP 55
17441: PPUSH
17442: LD_STRING D2Rus-Pow-1
17444: PPUSH
17445: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17449: LD_EXP 36
17453: PPUSH
17454: LD_STRING D2Rus-JMM-2
17456: PPUSH
17457: CALL_OW 88
// if not ( 3 in list_of_q ) then
17461: LD_INT 3
17463: PUSH
17464: LD_VAR 0 2
17468: IN
17469: NOT
17470: IFFALSE 17486
// Say ( Powell , D2Rus-Pow-2 ) else
17472: LD_EXP 55
17476: PPUSH
17477: LD_STRING D2Rus-Pow-2
17479: PPUSH
17480: CALL_OW 88
17484: GO 17498
// Say ( Powell , D2Rus-Pow-2a ) ;
17486: LD_EXP 55
17490: PPUSH
17491: LD_STRING D2Rus-Pow-2a
17493: PPUSH
17494: CALL_OW 88
// end ; 3 :
17498: GO 17759
17500: LD_INT 3
17502: DOUBLE
17503: EQUAL
17504: IFTRUE 17508
17506: GO 17593
17508: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17509: LD_EXP 36
17513: PPUSH
17514: LD_STRING D2Leg-JMM-1
17516: PPUSH
17517: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17521: LD_EXP 55
17525: PPUSH
17526: LD_STRING D2Leg-Pow-1
17528: PPUSH
17529: CALL_OW 88
// if 2 in list_of_q then
17533: LD_INT 2
17535: PUSH
17536: LD_VAR 0 2
17540: IN
17541: IFFALSE 17567
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17543: LD_EXP 36
17547: PPUSH
17548: LD_STRING D2Leg-JMM-2
17550: PPUSH
17551: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17555: LD_EXP 55
17559: PPUSH
17560: LD_STRING D2Leg-Pow-2
17562: PPUSH
17563: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17567: LD_EXP 36
17571: PPUSH
17572: LD_STRING D2Leg-JMM-3
17574: PPUSH
17575: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17579: LD_EXP 55
17583: PPUSH
17584: LD_STRING D2Leg-Pow-3
17586: PPUSH
17587: CALL_OW 88
// end ; 4 :
17591: GO 17759
17593: LD_INT 4
17595: DOUBLE
17596: EQUAL
17597: IFTRUE 17601
17599: GO 17676
17601: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17602: LD_EXP 36
17606: PPUSH
17607: LD_STRING D2Ar-JMM-1
17609: PPUSH
17610: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17614: LD_EXP 55
17618: PPUSH
17619: LD_STRING D2Ar-Pow-1
17621: PPUSH
17622: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17626: LD_EXP 36
17630: PPUSH
17631: LD_STRING D2Ar-JMM-2
17633: PPUSH
17634: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17638: LD_EXP 55
17642: PPUSH
17643: LD_STRING D2Ar-Pow-2
17645: PPUSH
17646: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17650: LD_EXP 36
17654: PPUSH
17655: LD_STRING D2Ar-JMM-3
17657: PPUSH
17658: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17662: LD_EXP 55
17666: PPUSH
17667: LD_STRING D2Ar-Pow-3
17669: PPUSH
17670: CALL_OW 88
// end ; 5 :
17674: GO 17759
17676: LD_INT 5
17678: DOUBLE
17679: EQUAL
17680: IFTRUE 17684
17682: GO 17699
17684: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17685: LD_EXP 36
17689: PPUSH
17690: LD_STRING D2Conf-JMM-1
17692: PPUSH
17693: CALL_OW 88
17697: GO 17759
17699: LD_INT 6
17701: DOUBLE
17702: EQUAL
17703: IFTRUE 17707
17705: GO 17758
17707: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17708: LD_EXP 36
17712: PPUSH
17713: LD_STRING D2Com-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17720: LD_EXP 55
17724: PPUSH
17725: LD_STRING D2Com-Pow-1
17727: PPUSH
17728: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17732: LD_EXP 36
17736: PPUSH
17737: LD_STRING D2Com-JMM-2
17739: PPUSH
17740: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17744: LD_EXP 55
17748: PPUSH
17749: LD_STRING D2Com-Pow-2
17751: PPUSH
17752: CALL_OW 88
// end ; end ;
17756: GO 17759
17758: POP
// end ;
17759: LD_VAR 0 3
17763: RET
// every 0 0$5 trigger missionStart do var tmp ;
17764: LD_EXP 13
17768: IFFALSE 18051
17770: GO 17772
17772: DISABLE
17773: LD_INT 0
17775: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17776: LD_INT 35
17778: PPUSH
17779: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17783: LD_INT 14
17785: PPUSH
17786: LD_INT 22
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PPUSH
17796: CALL_OW 70
17800: PUSH
17801: LD_EXP 15
17805: PUSH
17806: LD_INT 2
17808: PUSH
17809: LD_INT 3
17811: PUSH
17812: LD_INT 4
17814: PUSH
17815: LD_INT 5
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: AND
17825: IFFALSE 18041
// begin powellAnger := powellAnger + 1 ;
17827: LD_ADDR_EXP 17
17831: PUSH
17832: LD_EXP 17
17836: PUSH
17837: LD_INT 1
17839: PLUS
17840: ST_TO_ADDR
// Video ( true ) ;
17841: LD_INT 1
17843: PPUSH
17844: CALL 105232 0 1
// CenterNowOnUnits ( tmp ) ;
17848: LD_VAR 0 1
17852: PPUSH
17853: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17857: LD_INT 14
17859: PPUSH
17860: LD_INT 22
17862: PUSH
17863: LD_INT 1
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PPUSH
17870: CALL_OW 70
17874: PPUSH
17875: LD_INT 86
17877: PPUSH
17878: LD_INT 133
17880: PPUSH
17881: CALL_OW 111
// async ;
17885: ASYNC
// case powellAnger of 1 :
17886: LD_EXP 17
17890: PUSH
17891: LD_INT 1
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17914
17899: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17900: LD_EXP 55
17904: PPUSH
17905: LD_STRING DBack1-Pow-1
17907: PPUSH
17908: CALL_OW 88
17912: GO 17961
17914: LD_INT 2
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17937
17922: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17923: LD_EXP 55
17927: PPUSH
17928: LD_STRING DBack2-Pow-1
17930: PPUSH
17931: CALL_OW 88
17935: GO 17961
17937: LD_INT 3
17939: DOUBLE
17940: EQUAL
17941: IFTRUE 17945
17943: GO 17960
17945: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17946: LD_EXP 55
17950: PPUSH
17951: LD_STRING DBack3-Pow-1
17953: PPUSH
17954: CALL_OW 88
17958: GO 17961
17960: POP
// sync ;
17961: SYNC
// repeat wait ( 0 0$1 ) ;
17962: LD_INT 35
17964: PPUSH
17965: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17969: LD_INT 14
17971: PPUSH
17972: LD_INT 22
17974: PUSH
17975: LD_INT 1
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: PPUSH
17982: CALL_OW 70
17986: PPUSH
17987: LD_INT 86
17989: PPUSH
17990: LD_INT 133
17992: PPUSH
17993: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17997: LD_INT 14
17999: PPUSH
18000: LD_INT 22
18002: PUSH
18003: LD_INT 1
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PPUSH
18010: CALL_OW 70
18014: NOT
18015: IFFALSE 17962
// if powellAnger >= 3 then
18017: LD_EXP 17
18021: PUSH
18022: LD_INT 3
18024: GREATEREQUAL
18025: IFFALSE 18034
// YouLost ( Dismissed ) ;
18027: LD_STRING Dismissed
18029: PPUSH
18030: CALL_OW 104
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 105232 0 1
// end ; until missionStage > 5 ;
18041: LD_EXP 15
18045: PUSH
18046: LD_INT 5
18048: GREATER
18049: IFFALSE 17776
// end ;
18051: PPOPN 1
18053: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18054: LD_EXP 13
18058: PUSH
18059: LD_INT 22
18061: PUSH
18062: LD_INT 4
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 21
18071: PUSH
18072: LD_INT 2
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PPUSH
18083: CALL_OW 69
18087: PUSH
18088: LD_INT 4
18090: GREATEREQUAL
18091: AND
18092: PUSH
18093: LD_EXP 15
18097: PUSH
18098: LD_INT 2
18100: EQUAL
18101: AND
18102: IFFALSE 19925
18104: GO 18106
18106: DISABLE
18107: LD_INT 0
18109: PPUSH
18110: PPUSH
18111: PPUSH
18112: PPUSH
18113: PPUSH
18114: PPUSH
18115: PPUSH
18116: PPUSH
// begin missionStage := 3 ;
18117: LD_ADDR_EXP 15
18121: PUSH
18122: LD_INT 3
18124: ST_TO_ADDR
// retreat := false ;
18125: LD_ADDR_VAR 0 4
18129: PUSH
18130: LD_INT 0
18132: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18133: LD_ADDR_VAR 0 5
18137: PUSH
18138: LD_INT 22
18140: PUSH
18141: LD_INT 4
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: PUSH
18148: LD_INT 30
18150: PUSH
18151: LD_INT 4
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PPUSH
18162: CALL_OW 69
18166: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18167: LD_ADDR_VAR 0 6
18171: PUSH
18172: LD_INT 22
18174: PUSH
18175: LD_INT 4
18177: PUSH
18178: EMPTY
18179: LIST
18180: LIST
18181: PUSH
18182: LD_INT 30
18184: PUSH
18185: LD_INT 5
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PPUSH
18196: CALL_OW 69
18200: ST_TO_ADDR
// if not bar then
18201: LD_VAR 0 6
18205: NOT
18206: IFFALSE 18259
// begin repeat wait ( 0 0$1 ) ;
18208: LD_INT 35
18210: PPUSH
18211: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18215: LD_INT 22
18217: PUSH
18218: LD_INT 4
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 3
18227: PUSH
18228: LD_INT 57
18230: PUSH
18231: EMPTY
18232: LIST
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: PUSH
18238: LD_INT 30
18240: PUSH
18241: LD_INT 5
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: PPUSH
18253: CALL_OW 69
18257: IFFALSE 18208
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18259: LD_ADDR_VAR 0 6
18263: PUSH
18264: LD_INT 22
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: EMPTY
18271: LIST
18272: LIST
18273: PUSH
18274: LD_INT 30
18276: PUSH
18277: LD_INT 5
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: EMPTY
18285: LIST
18286: LIST
18287: PPUSH
18288: CALL_OW 69
18292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18300: LD_EXP 118
18304: PUSH
18305: LD_INT 4
18307: ARRAY
18308: PUSH
18309: LD_INT 4
18311: GREATEREQUAL
18312: IFFALSE 18293
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18314: LD_ADDR_VAR 0 2
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_INT 4
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 2
18331: PUSH
18332: LD_INT 25
18334: PUSH
18335: LD_INT 1
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PUSH
18342: LD_INT 25
18344: PUSH
18345: LD_INT 2
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 25
18354: PUSH
18355: LD_INT 3
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: LD_INT 25
18364: PUSH
18365: LD_INT 4
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PUSH
18372: LD_INT 25
18374: PUSH
18375: LD_INT 5
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: PPUSH
18394: CALL_OW 69
18398: PUSH
18399: LD_EXP 55
18403: PUSH
18404: LD_EXP 56
18408: ADD
18409: DIFF
18410: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18411: LD_ADDR_VAR 0 3
18415: PUSH
18416: LD_VAR 0 2
18420: PPUSH
18421: LD_INT 26
18423: PUSH
18424: LD_INT 1
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PPUSH
18431: CALL_OW 72
18435: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18436: LD_ADDR_VAR 0 2
18440: PUSH
18441: LD_VAR 0 2
18445: PUSH
18446: LD_VAR 0 3
18450: DIFF
18451: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18452: LD_ADDR_VAR 0 2
18456: PUSH
18457: LD_VAR 0 2
18461: PPUSH
18462: LD_INT 1
18464: PPUSH
18465: CALL 103885 0 2
18469: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18470: LD_ADDR_VAR 0 3
18474: PUSH
18475: LD_VAR 0 3
18479: PPUSH
18480: LD_INT 1
18482: PPUSH
18483: CALL 103885 0 2
18487: ST_TO_ADDR
// for i = 1 to 4 do
18488: LD_ADDR_VAR 0 1
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 4
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18668
// begin if tmp2 then
18504: LD_VAR 0 3
18508: IFFALSE 18589
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18510: LD_ADDR_EXP 18
18514: PUSH
18515: LD_EXP 18
18519: PPUSH
18520: LD_INT 1
18522: PPUSH
18523: LD_EXP 18
18527: PUSH
18528: LD_INT 1
18530: ARRAY
18531: PUSH
18532: LD_VAR 0 3
18536: PUSH
18537: LD_VAR 0 3
18541: ARRAY
18542: ADD
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18549: LD_VAR 0 3
18553: PUSH
18554: LD_VAR 0 3
18558: ARRAY
18559: PPUSH
18560: LD_INT 1
18562: PPUSH
18563: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_VAR 0 3
18576: PPUSH
18577: LD_VAR 0 3
18581: PPUSH
18582: CALL_OW 3
18586: ST_TO_ADDR
// end else
18587: GO 18666
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18589: LD_ADDR_EXP 18
18593: PUSH
18594: LD_EXP 18
18598: PPUSH
18599: LD_INT 1
18601: PPUSH
18602: LD_EXP 18
18606: PUSH
18607: LD_INT 1
18609: ARRAY
18610: PUSH
18611: LD_VAR 0 2
18615: PUSH
18616: LD_VAR 0 2
18620: ARRAY
18621: ADD
18622: PPUSH
18623: CALL_OW 1
18627: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18628: LD_VAR 0 2
18632: PUSH
18633: LD_VAR 0 2
18637: ARRAY
18638: PPUSH
18639: LD_INT 1
18641: PPUSH
18642: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18646: LD_ADDR_VAR 0 2
18650: PUSH
18651: LD_VAR 0 2
18655: PPUSH
18656: LD_VAR 0 2
18660: PPUSH
18661: CALL_OW 3
18665: ST_TO_ADDR
// end ; end ;
18666: GO 18501
18668: POP
18669: POP
// if tmp2 then
18670: LD_VAR 0 3
18674: IFFALSE 18692
// tmp := tmp union tmp2 ;
18676: LD_ADDR_VAR 0 2
18680: PUSH
18681: LD_VAR 0 2
18685: PUSH
18686: LD_VAR 0 3
18690: UNION
18691: ST_TO_ADDR
// for i = 1 to 4 do
18692: LD_ADDR_VAR 0 1
18696: PUSH
18697: DOUBLE
18698: LD_INT 1
18700: DEC
18701: ST_TO_ADDR
18702: LD_INT 4
18704: PUSH
18705: FOR_TO
18706: IFFALSE 18755
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18708: LD_ADDR_EXP 18
18712: PUSH
18713: LD_EXP 18
18717: PPUSH
18718: LD_INT 2
18720: PPUSH
18721: LD_EXP 18
18725: PUSH
18726: LD_INT 2
18728: ARRAY
18729: PUSH
18730: LD_VAR 0 2
18734: PUSH
18735: LD_VAR 0 2
18739: PUSH
18740: LD_VAR 0 1
18744: MINUS
18745: ARRAY
18746: ADD
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
18753: GO 18705
18755: POP
18756: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18757: LD_ADDR_EXP 99
18761: PUSH
18762: LD_EXP 99
18766: PPUSH
18767: LD_INT 4
18769: PPUSH
18770: LD_EXP 99
18774: PUSH
18775: LD_INT 4
18777: ARRAY
18778: PUSH
18779: LD_EXP 18
18783: PUSH
18784: LD_INT 1
18786: ARRAY
18787: DIFF
18788: PPUSH
18789: CALL_OW 1
18793: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18794: LD_VAR 0 5
18798: PUSH
18799: LD_INT 1
18801: ARRAY
18802: PPUSH
18803: CALL_OW 313
18807: IFFALSE 18862
// begin for i in UnitsInside ( arm [ 1 ] ) do
18809: LD_ADDR_VAR 0 1
18813: PUSH
18814: LD_VAR 0 5
18818: PUSH
18819: LD_INT 1
18821: ARRAY
18822: PPUSH
18823: CALL_OW 313
18827: PUSH
18828: FOR_IN
18829: IFFALSE 18860
// begin ComExitBuilding ( i ) ;
18831: LD_VAR 0 1
18835: PPUSH
18836: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18840: LD_VAR 0 1
18844: PPUSH
18845: LD_VAR 0 6
18849: PUSH
18850: LD_INT 1
18852: ARRAY
18853: PPUSH
18854: CALL_OW 180
// end ;
18858: GO 18828
18860: POP
18861: POP
// end ; wait ( 0 0$3 ) ;
18862: LD_INT 105
18864: PPUSH
18865: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18869: LD_ADDR_VAR 0 1
18873: PUSH
18874: LD_EXP 18
18878: PUSH
18879: LD_INT 1
18881: ARRAY
18882: PUSH
18883: FOR_IN
18884: IFFALSE 18991
// begin if IsInUnit ( i ) then
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 310
18895: IFFALSE 18906
// ComExitBuilding ( i ) ;
18897: LD_VAR 0 1
18901: PPUSH
18902: CALL_OW 122
// if GetClass ( i ) <> 1 then
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 257
18915: PUSH
18916: LD_INT 1
18918: NONEQUAL
18919: IFFALSE 18960
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18921: LD_VAR 0 1
18925: PPUSH
18926: LD_VAR 0 5
18930: PUSH
18931: LD_INT 1
18933: ARRAY
18934: PPUSH
18935: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18939: LD_VAR 0 1
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 183
// AddComExitBuilding ( i ) ;
18951: LD_VAR 0 1
18955: PPUSH
18956: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18960: LD_VAR 0 1
18964: PPUSH
18965: LD_INT 60
18967: PPUSH
18968: LD_INT 94
18970: PPUSH
18971: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_EXP 55
18984: PPUSH
18985: CALL_OW 179
// end ;
18989: GO 18883
18991: POP
18992: POP
// wait ( 0 0$15 ) ;
18993: LD_INT 525
18995: PPUSH
18996: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19000: LD_EXP 55
19004: PPUSH
19005: LD_STRING D4-Pow-1
19007: PPUSH
19008: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19012: LD_ADDR_VAR 0 2
19016: PUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PPUSH
19026: LD_INT 26
19028: PUSH
19029: LD_INT 1
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PPUSH
19036: CALL_OW 72
19040: ST_TO_ADDR
// if tmp then
19041: LD_VAR 0 2
19045: IFFALSE 19063
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19047: LD_VAR 0 2
19051: PUSH
19052: LD_INT 1
19054: ARRAY
19055: PPUSH
19056: LD_STRING D4-Sol1-1
19058: PPUSH
19059: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19063: LD_EXP 55
19067: PPUSH
19068: LD_STRING D4-Pow-2
19070: PPUSH
19071: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19075: LD_ADDR_VAR 0 1
19079: PUSH
19080: DOUBLE
19081: LD_INT 1
19083: DEC
19084: ST_TO_ADDR
19085: LD_EXP 18
19089: PUSH
19090: LD_INT 1
19092: ARRAY
19093: PUSH
19094: FOR_TO
19095: IFFALSE 19188
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19097: LD_EXP 18
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: PUSH
19106: LD_VAR 0 1
19110: ARRAY
19111: PPUSH
19112: LD_EXP 118
19116: PUSH
19117: LD_INT 4
19119: ARRAY
19120: PUSH
19121: LD_INT 1
19123: ARRAY
19124: PPUSH
19125: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19129: LD_ADDR_EXP 118
19133: PUSH
19134: LD_EXP 118
19138: PPUSH
19139: LD_INT 4
19141: PPUSH
19142: LD_EXP 118
19146: PUSH
19147: LD_INT 4
19149: ARRAY
19150: PPUSH
19151: LD_INT 1
19153: PPUSH
19154: CALL_OW 3
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19164: LD_INT 8
19166: PPUSH
19167: LD_EXP 18
19171: PUSH
19172: LD_INT 1
19174: ARRAY
19175: PUSH
19176: LD_VAR 0 1
19180: ARRAY
19181: PPUSH
19182: CALL_OW 471
// end ;
19186: GO 19094
19188: POP
19189: POP
// repeat wait ( 0 0$1 ) ;
19190: LD_INT 35
19192: PPUSH
19193: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19197: LD_EXP 18
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: LD_INT 55
19208: PUSH
19209: EMPTY
19210: LIST
19211: PPUSH
19212: CALL_OW 72
19216: PUSH
19217: LD_INT 4
19219: GREATEREQUAL
19220: IFFALSE 19190
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19222: LD_EXP 18
19226: PUSH
19227: LD_INT 1
19229: ARRAY
19230: PPUSH
19231: LD_INT 69
19233: PPUSH
19234: LD_INT 94
19236: PPUSH
19237: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19241: LD_EXP 18
19245: PUSH
19246: LD_INT 1
19248: ARRAY
19249: PPUSH
19250: LD_INT 82
19252: PPUSH
19253: LD_INT 83
19255: PPUSH
19256: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19260: LD_EXP 18
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: LD_INT 77
19271: PPUSH
19272: LD_INT 69
19274: PPUSH
19275: CALL_OW 174
// repeat wait ( 3 ) ;
19279: LD_INT 3
19281: PPUSH
19282: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19286: LD_ADDR_VAR 0 1
19290: PUSH
19291: LD_EXP 18
19295: PUSH
19296: LD_INT 1
19298: ARRAY
19299: PUSH
19300: FOR_IN
19301: IFFALSE 19437
// begin if GetLives ( i ) < 990 then
19303: LD_VAR 0 1
19307: PPUSH
19308: CALL_OW 256
19312: PUSH
19313: LD_INT 990
19315: LESS
19316: IFFALSE 19330
// SetLives ( i , 1000 ) ;
19318: LD_VAR 0 1
19322: PPUSH
19323: LD_INT 1000
19325: PPUSH
19326: CALL_OW 234
// if not IsInUnit ( i ) then
19330: LD_VAR 0 1
19334: PPUSH
19335: CALL_OW 310
19339: NOT
19340: IFFALSE 19435
// begin if not HasTask ( i ) then
19342: LD_VAR 0 1
19346: PPUSH
19347: CALL_OW 314
19351: NOT
19352: IFFALSE 19369
// ComMoveXY ( i , 64 , 93 ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 64
19361: PPUSH
19362: LD_INT 93
19364: PPUSH
19365: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19369: LD_VAR 0 4
19373: NOT
19374: PUSH
19375: LD_VAR 0 1
19379: PPUSH
19380: CALL_OW 258
19384: PUSH
19385: LD_INT 1
19387: EQUAL
19388: AND
19389: IFFALSE 19435
// begin retreat := true ;
19391: LD_ADDR_VAR 0 4
19395: PUSH
19396: LD_INT 1
19398: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19399: LD_VAR 0 1
19403: PPUSH
19404: LD_INT 2
19406: PPUSH
19407: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19411: LD_VAR 0 1
19415: PPUSH
19416: LD_STRING D4a-Sol1-1
19418: PPUSH
19419: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19423: LD_EXP 55
19427: PPUSH
19428: LD_STRING D4a-Pow-1
19430: PPUSH
19431: CALL_OW 88
// end ; end ; end ;
19435: GO 19300
19437: POP
19438: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19439: LD_EXP 18
19443: PUSH
19444: LD_INT 1
19446: ARRAY
19447: PPUSH
19448: LD_INT 95
19450: PUSH
19451: LD_INT 9
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 3
19460: PUSH
19461: LD_INT 55
19463: PUSH
19464: EMPTY
19465: LIST
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: PPUSH
19475: CALL_OW 72
19479: PUSH
19480: LD_INT 4
19482: GREATEREQUAL
19483: IFFALSE 19279
// for i in powellSquadAttack [ 1 ] do
19485: LD_ADDR_VAR 0 1
19489: PUSH
19490: LD_EXP 18
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PUSH
19499: FOR_IN
19500: IFFALSE 19636
// begin if GetTag ( i ) = 2 then
19502: LD_VAR 0 1
19506: PPUSH
19507: CALL_OW 110
19511: PUSH
19512: LD_INT 2
19514: EQUAL
19515: IFFALSE 19577
// begin ComMoveXY ( i , 60 , 94 ) ;
19517: LD_VAR 0 1
19521: PPUSH
19522: LD_INT 60
19524: PPUSH
19525: LD_INT 94
19527: PPUSH
19528: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19532: LD_VAR 0 1
19536: PPUSH
19537: LD_EXP 55
19541: PPUSH
19542: CALL_OW 179
// wait ( 0 0$3 ) ;
19546: LD_INT 105
19548: PPUSH
19549: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19553: LD_VAR 0 1
19557: PPUSH
19558: LD_STRING D4a-Sol1-2
19560: PPUSH
19561: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19565: LD_EXP 55
19569: PPUSH
19570: LD_STRING D4a-Pow-2
19572: PPUSH
19573: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19577: LD_VAR 0 1
19581: PPUSH
19582: LD_INT 0
19584: PPUSH
19585: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19589: LD_ADDR_EXP 99
19593: PUSH
19594: LD_EXP 99
19598: PPUSH
19599: LD_INT 4
19601: PPUSH
19602: LD_EXP 99
19606: PUSH
19607: LD_INT 4
19609: ARRAY
19610: PUSH
19611: LD_VAR 0 1
19615: UNION
19616: PPUSH
19617: CALL_OW 1
19621: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19622: LD_INT 8
19624: PPUSH
19625: LD_VAR 0 1
19629: PPUSH
19630: CALL_OW 472
// end ;
19634: GO 19499
19636: POP
19637: POP
// wait ( 4 4$00 ) ;
19638: LD_INT 8400
19640: PPUSH
19641: CALL_OW 67
// uc_side := 6 ;
19645: LD_ADDR_OWVAR 20
19649: PUSH
19650: LD_INT 6
19652: ST_TO_ADDR
// uc_nation := 3 ;
19653: LD_ADDR_OWVAR 21
19657: PUSH
19658: LD_INT 3
19660: ST_TO_ADDR
// ru := [ ] ;
19661: LD_ADDR_VAR 0 7
19665: PUSH
19666: EMPTY
19667: ST_TO_ADDR
// for i = 1 to 4 do
19668: LD_ADDR_VAR 0 1
19672: PUSH
19673: DOUBLE
19674: LD_INT 1
19676: DEC
19677: ST_TO_ADDR
19678: LD_INT 4
19680: PUSH
19681: FOR_TO
19682: IFFALSE 19783
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19684: LD_INT 22
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 3
19692: PPUSH
19693: LD_INT 43
19695: PUSH
19696: LD_INT 44
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_INT 1
19705: PPUSH
19706: LD_INT 2
19708: PPUSH
19709: CALL_OW 12
19713: ARRAY
19714: PPUSH
19715: LD_INT 89
19717: PPUSH
19718: CALL 69515 0 5
// un := CreateVehicle ;
19722: LD_ADDR_VAR 0 8
19726: PUSH
19727: CALL_OW 45
19731: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19732: LD_VAR 0 8
19736: PPUSH
19737: LD_INT 4
19739: PPUSH
19740: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19744: LD_VAR 0 8
19748: PPUSH
19749: LD_INT 136
19751: PPUSH
19752: LD_INT 90
19754: PPUSH
19755: LD_INT 8
19757: PPUSH
19758: LD_INT 0
19760: PPUSH
19761: CALL_OW 50
// ru := ru ^ un ;
19765: LD_ADDR_VAR 0 7
19769: PUSH
19770: LD_VAR 0 7
19774: PUSH
19775: LD_VAR 0 8
19779: ADD
19780: ST_TO_ADDR
// end ;
19781: GO 19681
19783: POP
19784: POP
// if ru then
19785: LD_VAR 0 7
19789: IFFALSE 19806
// ComAgressiveMove ( ru , 80 , 92 ) ;
19791: LD_VAR 0 7
19795: PPUSH
19796: LD_INT 80
19798: PPUSH
19799: LD_INT 92
19801: PPUSH
19802: CALL_OW 114
// wait ( 8 8$00 ) ;
19806: LD_INT 16800
19808: PPUSH
19809: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19813: LD_INT 4
19815: PPUSH
19816: LD_INT 3
19818: PUSH
19819: LD_INT 1
19821: PUSH
19822: LD_INT 1
19824: PUSH
19825: LD_INT 5
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: PUSH
19834: LD_INT 4
19836: PUSH
19837: LD_INT 1
19839: PUSH
19840: LD_INT 1
19842: PUSH
19843: LD_INT 6
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: PUSH
19852: LD_INT 4
19854: PUSH
19855: LD_INT 1
19857: PUSH
19858: LD_INT 1
19860: PUSH
19861: LD_INT 7
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: PUSH
19870: LD_INT 3
19872: PUSH
19873: LD_INT 1
19875: PUSH
19876: LD_INT 1
19878: PUSH
19879: LD_INT 7
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 1
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 5
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL 56862 0 2
// missionStage := 4 ;
19917: LD_ADDR_EXP 15
19921: PUSH
19922: LD_INT 4
19924: ST_TO_ADDR
// end ;
19925: PPOPN 8
19927: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19928: LD_EXP 15
19932: PUSH
19933: LD_INT 4
19935: EQUAL
19936: PUSH
19937: LD_INT 22
19939: PUSH
19940: LD_INT 4
19942: PUSH
19943: EMPTY
19944: LIST
19945: LIST
19946: PUSH
19947: LD_INT 21
19949: PUSH
19950: LD_INT 2
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: PPUSH
19961: CALL_OW 69
19965: PUSH
19966: LD_INT 5
19968: GREATEREQUAL
19969: AND
19970: IFFALSE 24056
19972: GO 19974
19974: DISABLE
19975: LD_INT 0
19977: PPUSH
19978: PPUSH
19979: PPUSH
19980: PPUSH
19981: PPUSH
19982: PPUSH
19983: PPUSH
19984: PPUSH
19985: PPUSH
19986: PPUSH
19987: PPUSH
19988: PPUSH
19989: PPUSH
// begin missionStage := 5 ;
19990: LD_ADDR_EXP 15
19994: PUSH
19995: LD_INT 5
19997: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19998: LD_ADDR_VAR 0 10
20002: PUSH
20003: LD_INT 22
20005: PUSH
20006: LD_INT 4
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 2
20015: PUSH
20016: LD_INT 30
20018: PUSH
20019: LD_INT 4
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 30
20028: PUSH
20029: LD_INT 5
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: EMPTY
20042: LIST
20043: LIST
20044: PPUSH
20045: CALL_OW 69
20049: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20050: LD_ADDR_VAR 0 6
20054: PUSH
20055: LD_INT 22
20057: PUSH
20058: LD_INT 4
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PUSH
20065: LD_INT 21
20067: PUSH
20068: LD_INT 1
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: PUSH
20075: LD_INT 3
20077: PUSH
20078: LD_INT 25
20080: PUSH
20081: LD_INT 16
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PUSH
20092: LD_INT 3
20094: PUSH
20095: LD_INT 25
20097: PUSH
20098: LD_INT 12
20100: PUSH
20101: EMPTY
20102: LIST
20103: LIST
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: PPUSH
20115: CALL_OW 69
20119: PUSH
20120: LD_EXP 55
20124: DIFF
20125: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20126: LD_ADDR_VAR 0 9
20130: PUSH
20131: LD_INT 22
20133: PUSH
20134: LD_INT 4
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: PUSH
20141: LD_INT 30
20143: PUSH
20144: LD_INT 3
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PPUSH
20155: CALL_OW 69
20159: PUSH
20160: LD_INT 1
20162: ARRAY
20163: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20171: LD_EXP 118
20175: PUSH
20176: LD_INT 4
20178: ARRAY
20179: PUSH
20180: LD_INT 5
20182: GREATEREQUAL
20183: PUSH
20184: LD_EXP 118
20188: PUSH
20189: LD_INT 4
20191: ARRAY
20192: PPUSH
20193: LD_INT 58
20195: PUSH
20196: EMPTY
20197: LIST
20198: PPUSH
20199: CALL_OW 72
20203: PUSH
20204: LD_INT 5
20206: GREATEREQUAL
20207: AND
20208: IFFALSE 20164
// powellAllowRetreat := false ;
20210: LD_ADDR_EXP 19
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20218: LD_INT 700
20220: PPUSH
20221: CALL_OW 67
// activeAttacks := false ;
20225: LD_ADDR_EXP 16
20229: PUSH
20230: LD_INT 0
20232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20233: LD_INT 35
20235: PPUSH
20236: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20240: LD_INT 22
20242: PUSH
20243: LD_INT 6
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: PPUSH
20250: CALL_OW 69
20254: PUSH
20255: LD_INT 0
20257: EQUAL
20258: IFFALSE 20233
// tmp := mc_vehicles [ 4 ] ;
20260: LD_ADDR_VAR 0 3
20264: PUSH
20265: LD_EXP 118
20269: PUSH
20270: LD_INT 4
20272: ARRAY
20273: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20274: LD_ADDR_VAR 0 1
20278: PUSH
20279: DOUBLE
20280: LD_INT 1
20282: DEC
20283: ST_TO_ADDR
20284: LD_EXP 18
20288: PUSH
20289: FOR_TO
20290: IFFALSE 20551
// begin for j in powellSquadAttack [ i ] do
20292: LD_ADDR_VAR 0 2
20296: PUSH
20297: LD_EXP 18
20301: PUSH
20302: LD_VAR 0 1
20306: ARRAY
20307: PUSH
20308: FOR_IN
20309: IFFALSE 20547
// begin forces := forces diff j ;
20311: LD_ADDR_VAR 0 6
20315: PUSH
20316: LD_VAR 0 6
20320: PUSH
20321: LD_VAR 0 2
20325: DIFF
20326: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_INT 1
20334: PPUSH
20335: CALL_OW 109
// wait ( 0 0$2 ) ;
20339: LD_INT 70
20341: PPUSH
20342: CALL_OW 67
// if IsInUnit ( j ) then
20346: LD_VAR 0 2
20350: PPUSH
20351: CALL_OW 310
20355: IFFALSE 20366
// ComExitBuilding ( j ) ;
20357: LD_VAR 0 2
20361: PPUSH
20362: CALL_OW 122
// if GetClass ( j ) <> 1 then
20366: LD_VAR 0 2
20370: PPUSH
20371: CALL_OW 257
20375: PUSH
20376: LD_INT 1
20378: NONEQUAL
20379: IFFALSE 20459
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20381: LD_VAR 0 10
20385: PUSH
20386: LD_INT 1
20388: ARRAY
20389: PPUSH
20390: CALL_OW 313
20394: PUSH
20395: LD_INT 5
20397: GREATEREQUAL
20398: IFFALSE 20420
// AddComEnterUnit ( j , arm [ 2 ] ) else
20400: LD_VAR 0 2
20404: PPUSH
20405: LD_VAR 0 10
20409: PUSH
20410: LD_INT 2
20412: ARRAY
20413: PPUSH
20414: CALL_OW 180
20418: GO 20438
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20420: LD_VAR 0 2
20424: PPUSH
20425: LD_VAR 0 10
20429: PUSH
20430: LD_INT 1
20432: ARRAY
20433: PPUSH
20434: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20438: LD_VAR 0 2
20442: PPUSH
20443: LD_INT 1
20445: PPUSH
20446: CALL_OW 183
// AddComExitBuilding ( j ) ;
20450: LD_VAR 0 2
20454: PPUSH
20455: CALL_OW 182
// end ; if i = 2 then
20459: LD_VAR 0 1
20463: PUSH
20464: LD_INT 2
20466: EQUAL
20467: IFFALSE 20484
// AddComMoveXY ( j , 61 , 93 ) ;
20469: LD_VAR 0 2
20473: PPUSH
20474: LD_INT 61
20476: PPUSH
20477: LD_INT 93
20479: PPUSH
20480: CALL_OW 171
// if i = 1 then
20484: LD_VAR 0 1
20488: PUSH
20489: LD_INT 1
20491: EQUAL
20492: IFFALSE 20545
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20494: LD_VAR 0 2
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PPUSH
20508: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20512: LD_ADDR_VAR 0 3
20516: PUSH
20517: LD_VAR 0 3
20521: PPUSH
20522: LD_INT 1
20524: PPUSH
20525: CALL_OW 3
20529: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20530: LD_VAR 0 2
20534: PPUSH
20535: LD_INT 69
20537: PPUSH
20538: LD_INT 94
20540: PPUSH
20541: CALL_OW 171
// end ; end ;
20545: GO 20308
20547: POP
20548: POP
// end ;
20549: GO 20289
20551: POP
20552: POP
// wait ( 0 0$55 ) ;
20553: LD_INT 1925
20555: PPUSH
20556: CALL_OW 67
// MC_Kill ( 4 ) ;
20560: LD_INT 4
20562: PPUSH
20563: CALL 33924 0 1
// tmp := UnitsInside ( fac ) ;
20567: LD_ADDR_VAR 0 3
20571: PUSH
20572: LD_VAR 0 9
20576: PPUSH
20577: CALL_OW 313
20581: ST_TO_ADDR
// if tmp then
20582: LD_VAR 0 3
20586: IFFALSE 20707
// for i in tmp do
20588: LD_ADDR_VAR 0 1
20592: PUSH
20593: LD_VAR 0 3
20597: PUSH
20598: FOR_IN
20599: IFFALSE 20705
// begin ComExitBuilding ( i ) ;
20601: LD_VAR 0 1
20605: PPUSH
20606: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20610: LD_VAR 0 10
20614: PUSH
20615: LD_INT 2
20617: ARRAY
20618: PPUSH
20619: CALL_OW 313
20623: PUSH
20624: LD_INT 6
20626: LESS
20627: IFFALSE 20649
// AddComEnterUnit ( i , arm [ 2 ] ) else
20629: LD_VAR 0 1
20633: PPUSH
20634: LD_VAR 0 10
20638: PUSH
20639: LD_INT 2
20641: ARRAY
20642: PPUSH
20643: CALL_OW 180
20647: GO 20703
// if UnitsInside ( arm [ 1 ] ) < 6 then
20649: LD_VAR 0 10
20653: PUSH
20654: LD_INT 1
20656: ARRAY
20657: PPUSH
20658: CALL_OW 313
20662: PUSH
20663: LD_INT 6
20665: LESS
20666: IFFALSE 20688
// AddComEnterUnit ( i , arm [ 1 ] ) else
20668: LD_VAR 0 1
20672: PPUSH
20673: LD_VAR 0 10
20677: PUSH
20678: LD_INT 1
20680: ARRAY
20681: PPUSH
20682: CALL_OW 180
20686: GO 20703
// AddComMoveXY ( i , 37 , 68 ) ;
20688: LD_VAR 0 1
20692: PPUSH
20693: LD_INT 37
20695: PPUSH
20696: LD_INT 68
20698: PPUSH
20699: CALL_OW 171
// end ;
20703: GO 20598
20705: POP
20706: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20707: LD_ADDR_VAR 0 11
20711: PUSH
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_INT 26
20719: PUSH
20720: LD_INT 1
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: PPUSH
20727: CALL_OW 72
20731: PUSH
20732: LD_EXP 56
20736: DIFF
20737: ST_TO_ADDR
// if not speaker then
20738: LD_VAR 0 11
20742: NOT
20743: IFFALSE 20770
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20745: LD_ADDR_VAR 0 11
20749: PUSH
20750: LD_VAR 0 6
20754: PPUSH
20755: LD_INT 26
20757: PUSH
20758: LD_INT 1
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: PPUSH
20765: CALL_OW 72
20769: ST_TO_ADDR
// if speaker then
20770: LD_VAR 0 11
20774: IFFALSE 20790
// speaker := speaker [ 1 ] ;
20776: LD_ADDR_VAR 0 11
20780: PUSH
20781: LD_VAR 0 11
20785: PUSH
20786: LD_INT 1
20788: ARRAY
20789: ST_TO_ADDR
// Video ( true ) ;
20790: LD_INT 1
20792: PPUSH
20793: CALL 105232 0 1
// CenterNowOnUnits ( Powell ) ;
20797: LD_EXP 55
20801: PPUSH
20802: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20806: LD_ADDR_VAR 0 3
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: LD_INT 3
20818: PUSH
20819: LD_INT 25
20821: PUSH
20822: LD_INT 1
20824: PUSH
20825: EMPTY
20826: LIST
20827: LIST
20828: PUSH
20829: EMPTY
20830: LIST
20831: LIST
20832: PPUSH
20833: CALL_OW 72
20837: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20838: LD_ADDR_VAR 0 12
20842: PUSH
20843: LD_INT 22
20845: PUSH
20846: LD_INT 4
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: PUSH
20853: LD_INT 30
20855: PUSH
20856: LD_INT 32
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PUSH
20863: LD_INT 58
20865: PUSH
20866: EMPTY
20867: LIST
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: LIST
20873: PPUSH
20874: CALL_OW 69
20878: ST_TO_ADDR
// for i = 1 to 6 do
20879: LD_ADDR_VAR 0 1
20883: PUSH
20884: DOUBLE
20885: LD_INT 1
20887: DEC
20888: ST_TO_ADDR
20889: LD_INT 6
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if IsInUnit ( tmp [ i ] ) then
20895: LD_VAR 0 3
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PPUSH
20906: CALL_OW 310
20910: IFFALSE 20927
// ComExitBuilding ( tmp [ i ] ) ;
20912: LD_VAR 0 3
20916: PUSH
20917: LD_VAR 0 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20927: LD_VAR 0 3
20931: PUSH
20932: LD_VAR 0 1
20936: ARRAY
20937: PPUSH
20938: LD_VAR 0 10
20942: PUSH
20943: LD_INT 1
20945: ARRAY
20946: PPUSH
20947: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20951: LD_VAR 0 3
20955: PUSH
20956: LD_VAR 0 1
20960: ARRAY
20961: PPUSH
20962: LD_INT 1
20964: PPUSH
20965: CALL_OW 183
// if emp_towers then
20969: LD_VAR 0 12
20973: IFFALSE 21032
// begin AddComExitBuilding ( tmp [ i ] ) ;
20975: LD_VAR 0 3
20979: PUSH
20980: LD_VAR 0 1
20984: ARRAY
20985: PPUSH
20986: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20990: LD_VAR 0 3
20994: PUSH
20995: LD_VAR 0 1
20999: ARRAY
21000: PPUSH
21001: LD_VAR 0 12
21005: PUSH
21006: LD_INT 1
21008: ARRAY
21009: PPUSH
21010: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21014: LD_ADDR_VAR 0 12
21018: PUSH
21019: LD_VAR 0 12
21023: PPUSH
21024: LD_INT 1
21026: PPUSH
21027: CALL_OW 3
21031: ST_TO_ADDR
// end ; end ;
21032: GO 20892
21034: POP
21035: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21036: LD_ADDR_VAR 0 3
21040: PUSH
21041: LD_EXP 18
21045: PUSH
21046: LD_INT 1
21048: ARRAY
21049: PUSH
21050: LD_EXP 18
21054: PUSH
21055: LD_INT 2
21057: ARRAY
21058: ADD
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21075: LD_ADDR_VAR 0 1
21079: PUSH
21080: LD_EXP 18
21084: PUSH
21085: LD_INT 2
21087: ARRAY
21088: PUSH
21089: FOR_IN
21090: IFFALSE 21108
// ComTurnUnit ( i , Powell ) ;
21092: LD_VAR 0 1
21096: PPUSH
21097: LD_EXP 55
21101: PPUSH
21102: CALL_OW 119
21106: GO 21089
21108: POP
21109: POP
// Say ( Powell , D5-Pow-1 ) ;
21110: LD_EXP 55
21114: PPUSH
21115: LD_STRING D5-Pow-1
21117: PPUSH
21118: CALL_OW 88
// if tmp then
21122: LD_VAR 0 3
21126: IFFALSE 21144
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21128: LD_VAR 0 3
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: LD_STRING D5-Sol2-1
21139: PPUSH
21140: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21144: LD_EXP 55
21148: PPUSH
21149: LD_STRING D5-Pow-2
21151: PPUSH
21152: CALL_OW 88
// if tmp > 1 then
21156: LD_VAR 0 3
21160: PUSH
21161: LD_INT 1
21163: GREATER
21164: IFFALSE 21182
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21166: LD_VAR 0 3
21170: PUSH
21171: LD_INT 2
21173: ARRAY
21174: PPUSH
21175: LD_STRING D5-Sol2-2
21177: PPUSH
21178: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21182: LD_EXP 55
21186: PPUSH
21187: LD_STRING D5-Pow-3
21189: PPUSH
21190: CALL_OW 88
// wait ( 0 0$1 ) ;
21194: LD_INT 35
21196: PPUSH
21197: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21201: LD_ADDR_VAR 0 3
21205: PUSH
21206: LD_EXP 18
21210: PUSH
21211: LD_INT 1
21213: ARRAY
21214: PUSH
21215: LD_EXP 18
21219: PUSH
21220: LD_INT 2
21222: ARRAY
21223: UNION
21224: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21225: LD_VAR 0 3
21229: PPUSH
21230: LD_INT 80
21232: PPUSH
21233: LD_INT 67
21235: PPUSH
21236: CALL_OW 114
// wait ( 0 0$2 ) ;
21240: LD_INT 70
21242: PPUSH
21243: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21247: LD_INT 79
21249: PPUSH
21250: LD_INT 72
21252: PPUSH
21253: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21257: LD_INT 35
21259: PPUSH
21260: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21264: LD_VAR 0 3
21268: PPUSH
21269: LD_INT 3
21271: PUSH
21272: LD_INT 24
21274: PUSH
21275: LD_INT 1000
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PPUSH
21286: CALL_OW 72
21290: IFFALSE 21257
// Say ( Powell , D5a-Pow-1 ) ;
21292: LD_EXP 55
21296: PPUSH
21297: LD_STRING D5a-Pow-1
21299: PPUSH
21300: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21304: LD_EXP 55
21308: PPUSH
21309: LD_STRING D5a-Pow-1a
21311: PPUSH
21312: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21316: LD_INT 10
21318: PPUSH
21319: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21323: LD_EXP 55
21327: PPUSH
21328: LD_STRING D5a-Pow-1b
21330: PPUSH
21331: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21335: LD_EXP 55
21339: PPUSH
21340: LD_STRING D5a-Pow-1c
21342: PPUSH
21343: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21347: LD_EXP 55
21351: PPUSH
21352: LD_STRING D5a-Pow-1d
21354: PPUSH
21355: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21359: LD_INT 35
21361: PPUSH
21362: CALL_OW 67
// if not HasTask ( tmp ) then
21366: LD_VAR 0 3
21370: PPUSH
21371: CALL_OW 314
21375: NOT
21376: IFFALSE 21393
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21378: LD_VAR 0 3
21382: PPUSH
21383: LD_INT 80
21385: PPUSH
21386: LD_INT 67
21388: PPUSH
21389: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21393: LD_VAR 0 3
21397: PPUSH
21398: LD_INT 24
21400: PUSH
21401: LD_INT 1
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: PPUSH
21408: CALL_OW 72
21412: NOT
21413: IFFALSE 21359
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_INT 22
21422: PUSH
21423: LD_INT 4
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PUSH
21430: LD_INT 92
21432: PUSH
21433: LD_INT 60
21435: PUSH
21436: LD_INT 93
21438: PUSH
21439: LD_INT 10
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 3
21450: PUSH
21451: LD_INT 54
21453: PUSH
21454: EMPTY
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: LIST
21465: PPUSH
21466: CALL_OW 69
21470: PUSH
21471: LD_EXP 55
21475: DIFF
21476: ST_TO_ADDR
// if tmp then
21477: LD_VAR 0 3
21481: IFFALSE 21515
// for i in tmp do
21483: LD_ADDR_VAR 0 1
21487: PUSH
21488: LD_VAR 0 3
21492: PUSH
21493: FOR_IN
21494: IFFALSE 21513
// ComMoveXY ( i , 36 , 67 ) ;
21496: LD_VAR 0 1
21500: PPUSH
21501: LD_INT 36
21503: PPUSH
21504: LD_INT 67
21506: PPUSH
21507: CALL_OW 111
21511: GO 21493
21513: POP
21514: POP
// wait ( 0 0$3 ) ;
21515: LD_INT 105
21517: PPUSH
21518: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21522: LD_VAR 0 11
21526: PPUSH
21527: LD_STRING D6-Sol3-1
21529: PPUSH
21530: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21534: LD_EXP 55
21538: PPUSH
21539: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21543: LD_EXP 55
21547: PPUSH
21548: LD_STRING D6-Pow-1
21550: PPUSH
21551: CALL_OW 88
// tmp := [ ] ;
21555: LD_ADDR_VAR 0 3
21559: PUSH
21560: EMPTY
21561: ST_TO_ADDR
// for i = 1 to 2 do
21562: LD_ADDR_VAR 0 1
21566: PUSH
21567: DOUBLE
21568: LD_INT 1
21570: DEC
21571: ST_TO_ADDR
21572: LD_INT 2
21574: PUSH
21575: FOR_TO
21576: IFFALSE 21683
// begin uc_side := 8 ;
21578: LD_ADDR_OWVAR 20
21582: PUSH
21583: LD_INT 8
21585: ST_TO_ADDR
// uc_nation := 2 ;
21586: LD_ADDR_OWVAR 21
21590: PUSH
21591: LD_INT 2
21593: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21594: LD_INT 14
21596: PPUSH
21597: LD_INT 3
21599: PPUSH
21600: LD_INT 2
21602: PPUSH
21603: LD_INT 29
21605: PPUSH
21606: LD_INT 100
21608: PPUSH
21609: CALL 69515 0 5
// veh := CreateVehicle ;
21613: LD_ADDR_VAR 0 13
21617: PUSH
21618: CALL_OW 45
21622: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21623: LD_VAR 0 13
21627: PPUSH
21628: LD_INT 4
21630: PPUSH
21631: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21635: LD_VAR 0 13
21639: PPUSH
21640: LD_INT 99
21642: PPUSH
21643: LD_INT 83
21645: PPUSH
21646: LD_INT 5
21648: PPUSH
21649: LD_INT 0
21651: PPUSH
21652: CALL_OW 50
// Connect ( veh ) ;
21656: LD_VAR 0 13
21660: PPUSH
21661: CALL 72570 0 1
// tmp := tmp ^ veh ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_VAR 0 13
21679: ADD
21680: ST_TO_ADDR
// end ;
21681: GO 21575
21683: POP
21684: POP
// wait ( 0 0$1 ) ;
21685: LD_INT 35
21687: PPUSH
21688: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21692: LD_INT 99
21694: PPUSH
21695: LD_INT 83
21697: PPUSH
21698: LD_INT 1
21700: PPUSH
21701: LD_INT 10
21703: PPUSH
21704: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21708: LD_INT 99
21710: PPUSH
21711: LD_INT 83
21713: PPUSH
21714: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21718: LD_VAR 0 11
21722: PPUSH
21723: LD_STRING D6-Sol3-2
21725: PPUSH
21726: CALL_OW 88
// async ;
21730: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21731: LD_EXP 55
21735: PPUSH
21736: LD_STRING D6-Pow-2
21738: PPUSH
21739: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21743: LD_VAR 0 3
21747: PUSH
21748: LD_INT 1
21750: ARRAY
21751: PPUSH
21752: LD_VAR 0 9
21756: PPUSH
21757: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21761: LD_VAR 0 3
21765: PUSH
21766: LD_INT 2
21768: ARRAY
21769: PPUSH
21770: LD_INT 22
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: LD_INT 21
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PPUSH
21794: CALL_OW 69
21798: PPUSH
21799: LD_VAR 0 3
21803: PUSH
21804: LD_INT 2
21806: ARRAY
21807: PPUSH
21808: CALL_OW 74
21812: PPUSH
21813: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21817: LD_EXP 55
21821: PPUSH
21822: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21826: LD_INT 99
21828: PPUSH
21829: LD_INT 83
21831: PPUSH
21832: LD_INT 1
21834: PPUSH
21835: CALL_OW 331
// repeat wait ( 4 ) ;
21839: LD_INT 4
21841: PPUSH
21842: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21846: LD_VAR 0 3
21850: PUSH
21851: LD_INT 1
21853: ARRAY
21854: PPUSH
21855: CALL_OW 256
21859: PUSH
21860: LD_INT 1000
21862: LESS
21863: IFFALSE 21881
// SetLives ( tmp [ 1 ] , 1000 ) ;
21865: LD_VAR 0 3
21869: PUSH
21870: LD_INT 1
21872: ARRAY
21873: PPUSH
21874: LD_INT 1000
21876: PPUSH
21877: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21881: LD_INT 22
21883: PUSH
21884: LD_INT 4
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: LD_INT 30
21893: PUSH
21894: LD_INT 3
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: PUSH
21910: LD_INT 0
21912: EQUAL
21913: IFFALSE 21839
// sync ;
21915: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21916: LD_EXP 55
21920: PPUSH
21921: LD_STRING D6a-Pow-1
21923: PPUSH
21924: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21928: LD_VAR 0 11
21932: PPUSH
21933: LD_STRING D6a-Sol3-1
21935: PPUSH
21936: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21940: LD_EXP 55
21944: PPUSH
21945: LD_STRING D6a-Pow-2
21947: PPUSH
21948: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6a-Sol3-2
21959: PPUSH
21960: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21964: LD_EXP 55
21968: PPUSH
21969: LD_STRING D6a-Pow-3
21971: PPUSH
21972: CALL_OW 88
// powellCenterCameraMode := true ;
21976: LD_ADDR_EXP 20
21980: PUSH
21981: LD_INT 1
21983: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21984: LD_ADDR_VAR 0 1
21988: PUSH
21989: LD_INT 22
21991: PUSH
21992: LD_INT 8
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: LD_INT 25
22001: PUSH
22002: LD_INT 2
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: PPUSH
22013: CALL_OW 69
22017: PUSH
22018: FOR_IN
22019: IFFALSE 22074
// begin SetTag ( i , 1 ) ;
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 1
22028: PPUSH
22029: CALL_OW 109
// ComExitBuilding ( i ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22042: LD_VAR 0 1
22046: PPUSH
22047: LD_INT 35
22049: PPUSH
22050: LD_INT 6
22052: PPUSH
22053: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22057: LD_VAR 0 1
22061: PPUSH
22062: LD_INT 53
22064: PPUSH
22065: LD_INT 4
22067: PPUSH
22068: CALL_OW 171
// end ;
22072: GO 22018
22074: POP
22075: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22076: LD_ADDR_VAR 0 3
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 4
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 21
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 3
22103: PUSH
22104: LD_INT 34
22106: PUSH
22107: LD_INT 12
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: LIST
22122: PPUSH
22123: CALL_OW 69
22127: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22128: LD_EXP 55
22132: PPUSH
22133: LD_VAR 0 3
22137: PPUSH
22138: LD_EXP 55
22142: PPUSH
22143: CALL_OW 74
22147: PPUSH
22148: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22152: LD_EXP 55
22156: PPUSH
22157: LD_INT 100
22159: PPUSH
22160: LD_INT 88
22162: PPUSH
22163: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22167: LD_EXP 55
22171: PPUSH
22172: LD_INT 100
22174: PPUSH
22175: LD_INT 75
22177: PPUSH
22178: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22182: LD_EXP 55
22186: PPUSH
22187: LD_INT 88
22189: PPUSH
22190: LD_INT 53
22192: PPUSH
22193: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22197: LD_INT 8
22199: PPUSH
22200: LD_EXP 55
22204: PPUSH
22205: CALL_OW 471
// repeat wait ( 3 ) ;
22209: LD_INT 3
22211: PPUSH
22212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22216: LD_INT 22
22218: PUSH
22219: LD_INT 4
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 92
22228: PUSH
22229: LD_INT 100
22231: PUSH
22232: LD_INT 75
22234: PUSH
22235: LD_INT 6
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PPUSH
22248: CALL_OW 69
22252: IFFALSE 22209
// async ;
22254: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22255: LD_EXP 55
22259: PPUSH
22260: LD_STRING D6b-Pow-1
22262: PPUSH
22263: CALL_OW 88
// repeat wait ( 3 ) ;
22267: LD_INT 3
22269: PPUSH
22270: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22274: LD_EXP 55
22278: PPUSH
22279: CALL_OW 310
22283: PPUSH
22284: CALL_OW 256
22288: PUSH
22289: LD_INT 1000
22291: LESS
22292: IFFALSE 22311
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22294: LD_EXP 55
22298: PPUSH
22299: CALL_OW 310
22303: PPUSH
22304: LD_INT 1000
22306: PPUSH
22307: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22311: LD_EXP 55
22315: PPUSH
22316: CALL_OW 256
22320: PUSH
22321: LD_INT 1000
22323: LESS
22324: IFFALSE 22338
// SetLives ( Powell , 1000 ) ;
22326: LD_EXP 55
22330: PPUSH
22331: LD_INT 1000
22333: PPUSH
22334: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22338: LD_EXP 55
22342: PPUSH
22343: LD_EXP 60
22347: PPUSH
22348: CALL_OW 296
22352: PUSH
22353: LD_INT 5
22355: LESS
22356: PUSH
22357: LD_EXP 55
22361: PPUSH
22362: CALL_OW 310
22366: PPUSH
22367: LD_EXP 60
22371: PPUSH
22372: CALL_OW 296
22376: PUSH
22377: LD_INT 5
22379: LESS
22380: OR
22381: IFFALSE 22400
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22383: LD_EXP 55
22387: PPUSH
22388: CALL_OW 310
22392: PPUSH
22393: LD_INT 100
22395: PPUSH
22396: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22400: LD_EXP 55
22404: PPUSH
22405: CALL_OW 310
22409: NOT
22410: IFFALSE 22267
// game_speed := 4 ;
22412: LD_ADDR_OWVAR 65
22416: PUSH
22417: LD_INT 4
22419: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22420: LD_EXP 55
22424: PPUSH
22425: LD_STRING D6b-Pow-1a
22427: PPUSH
22428: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22432: LD_EXP 55
22436: PPUSH
22437: LD_EXP 60
22441: PPUSH
22442: CALL_OW 180
// sync ;
22446: SYNC
// repeat wait ( 0 0$1 ) ;
22447: LD_INT 35
22449: PPUSH
22450: CALL_OW 67
// until IsInUnit ( Powell ) ;
22454: LD_EXP 55
22458: PPUSH
22459: CALL_OW 310
22463: IFFALSE 22447
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22465: LD_INT 8
22467: PPUSH
22468: LD_EXP 55
22472: PPUSH
22473: CALL_OW 310
22477: PPUSH
22478: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22482: LD_EXP 55
22486: PPUSH
22487: LD_INT 91
22489: PPUSH
22490: LD_INT 44
22492: PPUSH
22493: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22497: LD_EXP 55
22501: PPUSH
22502: LD_INT 96
22504: PPUSH
22505: LD_INT 44
22507: PPUSH
22508: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22512: LD_EXP 55
22516: PPUSH
22517: LD_INT 96
22519: PPUSH
22520: LD_INT 41
22522: PPUSH
22523: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22527: LD_EXP 55
22531: PPUSH
22532: LD_INT 92
22534: PPUSH
22535: LD_INT 39
22537: PPUSH
22538: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22542: LD_EXP 55
22546: PPUSH
22547: LD_INT 88
22549: PPUSH
22550: LD_INT 41
22552: PPUSH
22553: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22557: LD_EXP 55
22561: PPUSH
22562: LD_INT 91
22564: PPUSH
22565: LD_INT 44
22567: PPUSH
22568: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22572: LD_EXP 55
22576: PPUSH
22577: LD_INT 96
22579: PPUSH
22580: LD_INT 44
22582: PPUSH
22583: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22587: LD_EXP 55
22591: PPUSH
22592: LD_INT 96
22594: PPUSH
22595: LD_INT 41
22597: PPUSH
22598: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22602: LD_EXP 55
22606: PPUSH
22607: LD_INT 92
22609: PPUSH
22610: LD_INT 39
22612: PPUSH
22613: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22617: LD_EXP 55
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: LD_INT 41
22627: PPUSH
22628: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22632: LD_EXP 55
22636: PPUSH
22637: LD_INT 91
22639: PPUSH
22640: LD_INT 44
22642: PPUSH
22643: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22647: LD_EXP 55
22651: PPUSH
22652: LD_INT 93
22654: PPUSH
22655: LD_INT 39
22657: PPUSH
22658: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22662: LD_EXP 55
22666: PPUSH
22667: LD_INT 93
22669: PPUSH
22670: LD_INT 36
22672: PPUSH
22673: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22677: LD_INT 122
22679: PPUSH
22680: CALL_OW 67
// game_speed := 4 ;
22684: LD_ADDR_OWVAR 65
22688: PUSH
22689: LD_INT 4
22691: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22692: LD_EXP 55
22696: PPUSH
22697: LD_STRING D6b-Pow-1b
22699: PPUSH
22700: CALL_OW 88
// tmp := [ ] ;
22704: LD_ADDR_VAR 0 3
22708: PUSH
22709: EMPTY
22710: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22711: LD_ADDR_VAR 0 5
22715: PUSH
22716: LD_INT 78
22718: PUSH
22719: LD_INT 47
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: PUSH
22726: LD_INT 106
22728: PUSH
22729: LD_INT 53
22731: PUSH
22732: EMPTY
22733: LIST
22734: LIST
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22740: LD_ADDR_VAR 0 1
22744: PUSH
22745: LD_INT 22
22747: PUSH
22748: LD_INT 8
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: PUSH
22755: LD_INT 21
22757: PUSH
22758: LD_INT 3
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 92
22767: PUSH
22768: LD_INT 90
22770: PUSH
22771: LD_INT 52
22773: PUSH
22774: LD_INT 12
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: LIST
22787: PPUSH
22788: CALL_OW 69
22792: PUSH
22793: FOR_IN
22794: IFFALSE 22819
// tmp := tmp ^ UnitsInside ( i ) ;
22796: LD_ADDR_VAR 0 3
22800: PUSH
22801: LD_VAR 0 3
22805: PUSH
22806: LD_VAR 0 1
22810: PPUSH
22811: CALL_OW 313
22815: ADD
22816: ST_TO_ADDR
22817: GO 22793
22819: POP
22820: POP
// for i in tmp do
22821: LD_ADDR_VAR 0 1
22825: PUSH
22826: LD_VAR 0 3
22830: PUSH
22831: FOR_IN
22832: IFFALSE 22994
// begin dist := 9999 ;
22834: LD_ADDR_VAR 0 8
22838: PUSH
22839: LD_INT 9999
22841: ST_TO_ADDR
// _xy := [ ] ;
22842: LD_ADDR_VAR 0 7
22846: PUSH
22847: EMPTY
22848: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22849: LD_VAR 0 1
22853: PPUSH
22854: LD_INT 1
22856: PPUSH
22857: CALL_OW 109
// ComExitBuilding ( i ) ;
22861: LD_VAR 0 1
22865: PPUSH
22866: CALL_OW 122
// for j in xy do
22870: LD_ADDR_VAR 0 2
22874: PUSH
22875: LD_VAR 0 5
22879: PUSH
22880: FOR_IN
22881: IFFALSE 22963
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_VAR 0 2
22892: PUSH
22893: LD_INT 1
22895: ARRAY
22896: PPUSH
22897: LD_VAR 0 2
22901: PUSH
22902: LD_INT 2
22904: ARRAY
22905: PPUSH
22906: CALL_OW 297
22910: PUSH
22911: LD_VAR 0 8
22915: LESS
22916: IFFALSE 22961
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22918: LD_ADDR_VAR 0 8
22922: PUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: LD_VAR 0 2
22932: PUSH
22933: LD_INT 1
22935: ARRAY
22936: PPUSH
22937: LD_VAR 0 2
22941: PUSH
22942: LD_INT 2
22944: ARRAY
22945: PPUSH
22946: CALL_OW 297
22950: ST_TO_ADDR
// _xy := j ;
22951: LD_ADDR_VAR 0 7
22955: PUSH
22956: LD_VAR 0 2
22960: ST_TO_ADDR
// end ;
22961: GO 22880
22963: POP
22964: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 7
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 7
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 171
// end ;
22992: GO 22831
22994: POP
22995: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22996: LD_ADDR_VAR 0 4
23000: PUSH
23001: LD_VAR 0 3
23005: PPUSH
23006: LD_INT 26
23008: PUSH
23009: LD_INT 1
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: LD_INT 25
23018: PUSH
23019: LD_INT 1
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL_OW 72
23034: ST_TO_ADDR
// if tmp2 < 2 then
23035: LD_VAR 0 4
23039: PUSH
23040: LD_INT 2
23042: LESS
23043: IFFALSE 23112
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23045: LD_ADDR_VAR 0 4
23049: PUSH
23050: LD_INT 22
23052: PUSH
23053: LD_INT 8
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: LD_INT 26
23062: PUSH
23063: LD_INT 1
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 3
23072: PUSH
23073: LD_INT 25
23075: PUSH
23076: LD_INT 15
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: PPUSH
23092: CALL_OW 69
23096: PUSH
23097: LD_EXP 57
23101: PUSH
23102: LD_EXP 58
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: DIFF
23111: ST_TO_ADDR
// if tmp2 then
23112: LD_VAR 0 4
23116: IFFALSE 23134
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23118: LD_VAR 0 4
23122: PUSH
23123: LD_INT 1
23125: ARRAY
23126: PPUSH
23127: LD_STRING D6b-ArSol1-1
23129: PPUSH
23130: CALL_OW 88
// async ;
23134: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23135: LD_EXP 55
23139: PPUSH
23140: LD_STRING D6b-Pow-2
23142: PPUSH
23143: CALL_OW 88
// wait ( 0 0$1 ) ;
23147: LD_INT 35
23149: PPUSH
23150: CALL_OW 67
// if tmp2 > 1 then
23154: LD_VAR 0 4
23158: PUSH
23159: LD_INT 1
23161: GREATER
23162: IFFALSE 23180
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23164: LD_VAR 0 4
23168: PUSH
23169: LD_INT 2
23171: ARRAY
23172: PPUSH
23173: LD_STRING D6b-ArSol2-1
23175: PPUSH
23176: CALL_OW 88
// sync ;
23180: SYNC
// repeat wait ( 5 ) ;
23181: LD_INT 5
23183: PPUSH
23184: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23188: LD_INT 93
23190: PPUSH
23191: LD_INT 36
23193: PPUSH
23194: CALL_OW 428
23198: PPUSH
23199: CALL_OW 255
23203: PUSH
23204: LD_INT 4
23206: EQUAL
23207: IFFALSE 23181
// DialogueOn ;
23209: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23213: LD_INT 10
23215: PPUSH
23216: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23220: LD_EXP 55
23224: PPUSH
23225: LD_STRING D6b-Pow-2a
23227: PPUSH
23228: CALL_OW 88
// DialogueOff ;
23232: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23236: LD_EXP 55
23240: PPUSH
23241: CALL_OW 310
23245: PPUSH
23246: LD_INT 332
23248: PPUSH
23249: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23253: LD_INT 93
23255: PPUSH
23256: LD_INT 35
23258: PPUSH
23259: LD_INT 1
23261: PPUSH
23262: LD_INT 6
23264: NEG
23265: PPUSH
23266: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23270: LD_INT 35
23272: PPUSH
23273: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23277: LD_INT 332
23279: PPUSH
23280: CALL_OW 256
23284: PUSH
23285: LD_INT 1000
23287: LESS
23288: PUSH
23289: LD_INT 332
23291: PPUSH
23292: CALL_OW 300
23296: AND
23297: IFFALSE 23309
// SetLives ( kozlov_fac , 0 ) ;
23299: LD_INT 332
23301: PPUSH
23302: LD_INT 0
23304: PPUSH
23305: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23309: LD_INT 332
23311: PPUSH
23312: CALL_OW 301
23316: PUSH
23317: LD_EXP 55
23321: PPUSH
23322: CALL_OW 301
23326: OR
23327: IFFALSE 23270
// game_speed := 4 ;
23329: LD_ADDR_OWVAR 65
23333: PUSH
23334: LD_INT 4
23336: ST_TO_ADDR
// powellCenterCameraMode := false ;
23337: LD_ADDR_EXP 20
23341: PUSH
23342: LD_INT 0
23344: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23345: LD_ADDR_VAR 0 1
23349: PUSH
23350: LD_VAR 0 3
23354: PUSH
23355: LD_INT 22
23357: PUSH
23358: LD_INT 8
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 25
23367: PUSH
23368: LD_INT 2
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PPUSH
23379: CALL_OW 69
23383: UNION
23384: PUSH
23385: FOR_IN
23386: IFFALSE 23402
// SetTag ( i , 0 ) ;
23388: LD_VAR 0 1
23392: PPUSH
23393: LD_INT 0
23395: PPUSH
23396: CALL_OW 109
23400: GO 23385
23402: POP
23403: POP
// wait ( 0 0$3 ) ;
23404: LD_INT 105
23406: PPUSH
23407: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23411: LD_INT 93
23413: PPUSH
23414: LD_INT 35
23416: PPUSH
23417: LD_INT 1
23419: PPUSH
23420: CALL_OW 331
// DialogueOn ;
23424: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23428: LD_VAR 0 11
23432: PPUSH
23433: LD_STRING D6c-Sol3-1
23435: PPUSH
23436: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23440: LD_INT 10
23442: PPUSH
23443: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23447: LD_EXP 36
23451: PPUSH
23452: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23456: LD_EXP 36
23460: PPUSH
23461: LD_STRING D6c-JMM-1
23463: PPUSH
23464: CALL_OW 88
// if Cyrus then
23468: LD_EXP 42
23472: IFFALSE 23486
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23474: LD_EXP 42
23478: PPUSH
23479: LD_STRING D6c-Cyrus-1
23481: PPUSH
23482: CALL_OW 88
// if Bobby then
23486: LD_EXP 41
23490: IFFALSE 23504
// Say ( Bobby , D6c-Bobby-1 ) ;
23492: LD_EXP 41
23496: PPUSH
23497: LD_STRING D6c-Bobby-1
23499: PPUSH
23500: CALL_OW 88
// if Cornel then
23504: LD_EXP 47
23508: IFFALSE 23522
// Say ( Cornel , D6c-Corn-1 ) ;
23510: LD_EXP 47
23514: PPUSH
23515: LD_STRING D6c-Corn-1
23517: PPUSH
23518: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23522: LD_ADDR_VAR 0 4
23526: PUSH
23527: LD_INT 2
23529: PUSH
23530: LD_INT 22
23532: PUSH
23533: LD_INT 1
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: PUSH
23540: LD_INT 22
23542: PUSH
23543: LD_INT 4
23545: PUSH
23546: EMPTY
23547: LIST
23548: LIST
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: LIST
23554: PUSH
23555: LD_INT 26
23557: PUSH
23558: LD_INT 1
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: PUSH
23565: LD_INT 3
23567: PUSH
23568: LD_INT 25
23570: PUSH
23571: LD_INT 16
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 12
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: LIST
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: PPUSH
23598: CALL_OW 69
23602: PUSH
23603: LD_VAR 0 11
23607: PUSH
23608: LD_EXP 36
23612: UNION
23613: PUSH
23614: LD_EXP 56
23618: UNION
23619: PUSH
23620: EMPTY
23621: LIST
23622: DIFF
23623: ST_TO_ADDR
// if tmp2 then
23624: LD_VAR 0 4
23628: IFFALSE 23646
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23630: LD_VAR 0 4
23634: PUSH
23635: LD_INT 1
23637: ARRAY
23638: PPUSH
23639: LD_STRING D6c-Sol1-1
23641: PPUSH
23642: CALL_OW 88
// if Lisa then
23646: LD_EXP 39
23650: IFFALSE 23664
// Say ( Lisa , D6c-Lisa-1 ) ;
23652: LD_EXP 39
23656: PPUSH
23657: LD_STRING D6c-Lisa-1
23659: PPUSH
23660: CALL_OW 88
// if Gary then
23664: LD_EXP 48
23668: IFFALSE 23682
// Say ( Gary , D6c-Gary-1 ) ;
23670: LD_EXP 48
23674: PPUSH
23675: LD_STRING D6c-Gary-1
23677: PPUSH
23678: CALL_OW 88
// if Donaldson then
23682: LD_EXP 40
23686: IFFALSE 23700
// Say ( Donaldson , D6c-Don-1 ) ;
23688: LD_EXP 40
23692: PPUSH
23693: LD_STRING D6c-Don-1
23695: PPUSH
23696: CALL_OW 88
// if tmp2 > 1 then
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 1
23707: GREATER
23708: IFFALSE 23726
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23710: LD_VAR 0 4
23714: PUSH
23715: LD_INT 2
23717: ARRAY
23718: PPUSH
23719: LD_STRING D6c-Sol2-1
23721: PPUSH
23722: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23726: LD_VAR 0 11
23730: PPUSH
23731: LD_STRING D6c-Sol3-2
23733: PPUSH
23734: CALL_OW 88
// dwait ( 0 0$1 ) ;
23738: LD_INT 35
23740: PPUSH
23741: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23745: LD_EXP 36
23749: PPUSH
23750: LD_STRING D6c-JMM-2
23752: PPUSH
23753: CALL_OW 88
// DialogueOff ;
23757: CALL_OW 7
// Video ( false ) ;
23761: LD_INT 0
23763: PPUSH
23764: CALL 105232 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23768: LD_INT 22
23770: PUSH
23771: LD_INT 4
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PPUSH
23778: CALL_OW 69
23782: PPUSH
23783: LD_INT 1
23785: PPUSH
23786: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23790: LD_INT 4
23792: PPUSH
23793: LD_INT 4
23795: PPUSH
23796: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23800: LD_ADDR_VAR 0 1
23804: PUSH
23805: LD_INT 4
23807: PPUSH
23808: LD_INT 1
23810: PPUSH
23811: LD_INT 2
23813: PPUSH
23814: CALL 62975 0 3
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23857
// if GetTech ( i , 1 ) <> state_researched then
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 1
23829: PPUSH
23830: CALL_OW 321
23834: PUSH
23835: LD_INT 2
23837: NONEQUAL
23838: IFFALSE 23855
// SetTech ( i , 1 , state_researched ) ;
23840: LD_VAR 0 1
23844: PPUSH
23845: LD_INT 1
23847: PPUSH
23848: LD_INT 2
23850: PPUSH
23851: CALL_OW 322
23855: GO 23819
23857: POP
23858: POP
// missionStage := 6 ;
23859: LD_ADDR_EXP 15
23863: PUSH
23864: LD_INT 6
23866: ST_TO_ADDR
// activeAttacks := true ;
23867: LD_ADDR_EXP 16
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23875: LD_STRING M2
23877: PPUSH
23878: CALL_OW 337
// SaveForQuickRestart ;
23882: CALL_OW 22
// wait ( 0 0$40 ) ;
23886: LD_INT 1400
23888: PPUSH
23889: CALL_OW 67
// DialogueOn ;
23893: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23897: LD_EXP 59
23901: PPUSH
23902: LD_STRING D7-Friend-1
23904: PPUSH
23905: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23909: LD_EXP 36
23913: PPUSH
23914: LD_STRING D7-JMM-1
23916: PPUSH
23917: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23921: LD_EXP 59
23925: PPUSH
23926: LD_STRING D7-Friend-2
23928: PPUSH
23929: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23933: LD_EXP 36
23937: PPUSH
23938: LD_STRING D7-JMM-2
23940: PPUSH
23941: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23945: LD_EXP 59
23949: PPUSH
23950: LD_STRING D7-Friend-3
23952: PPUSH
23953: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23957: LD_EXP 36
23961: PPUSH
23962: LD_STRING D7-JMM-3
23964: PPUSH
23965: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23969: LD_EXP 59
23973: PPUSH
23974: LD_STRING D7-Friend-4
23976: PPUSH
23977: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23981: LD_EXP 36
23985: PPUSH
23986: LD_STRING D7-JMM-4
23988: PPUSH
23989: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23993: LD_EXP 59
23997: PPUSH
23998: LD_STRING D7-Friend-5
24000: PPUSH
24001: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24005: LD_EXP 36
24009: PPUSH
24010: LD_STRING D7-JMM-5
24012: PPUSH
24013: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24017: LD_EXP 59
24021: PPUSH
24022: LD_STRING D7-Friend-6
24024: PPUSH
24025: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24029: LD_EXP 36
24033: PPUSH
24034: LD_STRING D7-JMM-6
24036: PPUSH
24037: CALL_OW 88
// DialogueOff ;
24041: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24045: LD_STRING Mlegion
24047: PPUSH
24048: CALL_OW 337
// RebuildKozlovFactory ;
24052: CALL 4684 0 0
// end ;
24056: PPOPN 13
24058: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24059: LD_EXP 20
24063: PUSH
24064: LD_EXP 55
24068: PPUSH
24069: CALL_OW 300
24073: AND
24074: IFFALSE 24116
24076: GO 24078
24078: DISABLE
// begin enable ;
24079: ENABLE
// if IsInUnit ( Powell ) then
24080: LD_EXP 55
24084: PPUSH
24085: CALL_OW 310
24089: IFFALSE 24107
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24091: LD_EXP 55
24095: PPUSH
24096: CALL_OW 310
24100: PPUSH
24101: CALL_OW 85
24105: GO 24116
// CenterOnUnits ( Powell ) ;
24107: LD_EXP 55
24111: PPUSH
24112: CALL_OW 85
// end ;
24116: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24117: LD_INT 22
24119: PUSH
24120: LD_INT 8
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 34
24129: PUSH
24130: LD_INT 48
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PPUSH
24141: CALL_OW 69
24145: IFFALSE 24408
24147: GO 24149
24149: DISABLE
24150: LD_INT 0
24152: PPUSH
24153: PPUSH
// begin if missionStage < 9 then
24154: LD_EXP 15
24158: PUSH
24159: LD_INT 9
24161: LESS
24162: IFFALSE 24172
// missionStage := 9 ;
24164: LD_ADDR_EXP 15
24168: PUSH
24169: LD_INT 9
24171: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24172: LD_ADDR_VAR 0 1
24176: PUSH
24177: LD_INT 22
24179: PUSH
24180: LD_INT 8
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: LD_INT 34
24189: PUSH
24190: LD_INT 48
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: EMPTY
24198: LIST
24199: LIST
24200: PPUSH
24201: CALL_OW 69
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24210: LD_INT 175
24212: PPUSH
24213: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24217: LD_EXP 12
24221: PUSH
24222: LD_EXP 3
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 2
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: IN
24237: OR
24238: IFFALSE 24261
// target := [ 68 , 108 , 1 ] else
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: LD_INT 68
24247: PUSH
24248: LD_INT 108
24250: PUSH
24251: LD_INT 1
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: LIST
24258: ST_TO_ADDR
24259: GO 24280
// target := [ 181 , 88 , 2 ] ;
24261: LD_ADDR_VAR 0 2
24265: PUSH
24266: LD_INT 181
24268: PUSH
24269: LD_INT 88
24271: PUSH
24272: LD_INT 2
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: LIST
24279: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24280: LD_VAR 0 1
24284: PPUSH
24285: LD_VAR 0 2
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 2
24298: PUSH
24299: LD_INT 2
24301: ARRAY
24302: PPUSH
24303: CALL_OW 176
// if target [ 3 ] = 1 then
24307: LD_VAR 0 2
24311: PUSH
24312: LD_INT 3
24314: ARRAY
24315: PUSH
24316: LD_INT 1
24318: EQUAL
24319: IFFALSE 24335
// SayRadio ( Kurt , D12-Kurt-1 ) else
24321: LD_EXP 57
24325: PPUSH
24326: LD_STRING D12-Kurt-1
24328: PPUSH
24329: CALL_OW 94
24333: GO 24359
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24335: LD_EXP 57
24339: PPUSH
24340: LD_STRING D12a-Kurt-1
24342: PPUSH
24343: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24347: LD_EXP 71
24351: PPUSH
24352: LD_STRING D12a-Roth-1
24354: PPUSH
24355: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24359: LD_INT 350
24361: PPUSH
24362: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24366: LD_VAR 0 1
24370: PPUSH
24371: LD_INT 22
24373: PUSH
24374: LD_INT 8
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 30
24383: PUSH
24384: LD_INT 3
24386: PUSH
24387: EMPTY
24388: LIST
24389: LIST
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PPUSH
24395: CALL_OW 69
24399: PUSH
24400: LD_INT 1
24402: ARRAY
24403: PPUSH
24404: CALL_OW 228
// end ;
24408: PPOPN 2
24410: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24411: LD_INT 22
24413: PUSH
24414: LD_INT 8
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: PUSH
24421: LD_INT 21
24423: PUSH
24424: LD_INT 1
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_INT 23
24433: PUSH
24434: LD_INT 2
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: PPUSH
24446: CALL_OW 69
24450: PUSH
24451: LD_INT 8
24453: PUSH
24454: LD_INT 7
24456: PUSH
24457: LD_INT 6
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: LIST
24464: PUSH
24465: LD_OWVAR 67
24469: ARRAY
24470: LESSEQUAL
24471: PUSH
24472: LD_INT 22
24474: PUSH
24475: LD_INT 8
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 34
24484: PUSH
24485: LD_INT 48
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PPUSH
24496: CALL_OW 69
24500: NOT
24501: AND
24502: PUSH
24503: LD_EXP 57
24507: PPUSH
24508: CALL_OW 302
24512: AND
24513: IFFALSE 24830
24515: GO 24517
24517: DISABLE
// begin DialogueOn ;
24518: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24522: LD_EXP 36
24526: PPUSH
24527: LD_STRING D13-JMM-1
24529: PPUSH
24530: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24534: LD_EXP 57
24538: PPUSH
24539: LD_STRING D13-Kurt-1
24541: PPUSH
24542: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24546: LD_EXP 36
24550: PPUSH
24551: LD_STRING D13-JMM-2
24553: PPUSH
24554: CALL_OW 88
// if FakeInfo then
24558: LD_EXP 12
24562: IFFALSE 24582
// begin Say ( Kurt , D13-Kurt-2 ) ;
24564: LD_EXP 57
24568: PPUSH
24569: LD_STRING D13-Kurt-2
24571: PPUSH
24572: CALL_OW 88
// DialogueOff ;
24576: CALL_OW 7
// exit ;
24580: GO 24830
// end ; if not KurtStatus then
24582: LD_EXP 3
24586: NOT
24587: IFFALSE 24603
// Say ( Kurt , D13-Kurt-2b ) else
24589: LD_EXP 57
24593: PPUSH
24594: LD_STRING D13-Kurt-2b
24596: PPUSH
24597: CALL_OW 88
24601: GO 24615
// Say ( Kurt , D13-Kurt-2a ) ;
24603: LD_EXP 57
24607: PPUSH
24608: LD_STRING D13-Kurt-2a
24610: PPUSH
24611: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24615: LD_EXP 57
24619: PPUSH
24620: LD_STRING D13-Kurt-2a
24622: PPUSH
24623: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24627: LD_EXP 36
24631: PPUSH
24632: LD_STRING D13-JMM-3
24634: PPUSH
24635: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24639: LD_EXP 57
24643: PPUSH
24644: LD_STRING D13-Kurt-3
24646: PPUSH
24647: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24651: LD_EXP 36
24655: PPUSH
24656: LD_STRING D13-JMM-4
24658: PPUSH
24659: CALL_OW 88
// DialogueOff ;
24663: CALL_OW 7
// MC_Kill ( 3 ) ;
24667: LD_INT 3
24669: PPUSH
24670: CALL 33924 0 1
// KillUnit ( Kozlov ) ;
24674: LD_EXP 58
24678: PPUSH
24679: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24683: LD_INT 22
24685: PUSH
24686: LD_INT 8
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: LD_INT 21
24695: PUSH
24696: LD_INT 3
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PUSH
24703: LD_INT 23
24705: PUSH
24706: LD_INT 3
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: PUSH
24713: LD_INT 30
24715: PUSH
24716: LD_INT 3
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: LIST
24727: LIST
24728: PPUSH
24729: CALL_OW 69
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24742: LD_INT 8
24744: PPUSH
24745: LD_INT 1
24747: PPUSH
24748: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24752: LD_INT 22
24754: PUSH
24755: LD_INT 8
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PPUSH
24762: CALL_OW 69
24766: PPUSH
24767: LD_INT 1
24769: PPUSH
24770: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24774: LD_INT 8
24776: PPUSH
24777: LD_INT 1
24779: PPUSH
24780: LD_INT 1
24782: PPUSH
24783: LD_INT 1
24785: PPUSH
24786: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24790: LD_EXP 59
24794: PPUSH
24795: LD_INT 37
24797: PPUSH
24798: LD_INT 1
24800: PPUSH
24801: LD_INT 0
24803: PPUSH
24804: CALL_OW 48
// wait ( 0 0$1 ) ;
24808: LD_INT 35
24810: PPUSH
24811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24815: LD_EXP 59
24819: PPUSH
24820: LD_INT 60
24822: PPUSH
24823: LD_INT 95
24825: PPUSH
24826: CALL_OW 111
// end ;
24830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24831: LD_INT 22
24833: PUSH
24834: LD_INT 8
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 21
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 0
24862: EQUAL
24863: IFFALSE 24883
24865: GO 24867
24867: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24868: LD_STRING MlegionOut
24870: PPUSH
24871: CALL_OW 337
// legionDestroyed := true ;
24875: LD_ADDR_EXP 22
24879: PUSH
24880: LD_INT 1
24882: ST_TO_ADDR
// end ;
24883: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24884: LD_INT 1
24886: PPUSH
24887: LD_EXP 59
24891: PPUSH
24892: CALL_OW 292
24896: IFFALSE 25196
24898: GO 24900
24900: DISABLE
24901: LD_INT 0
24903: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24904: LD_EXP 59
24908: PPUSH
24909: CALL_OW 87
// DialogueOn ;
24913: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24917: LD_EXP 36
24921: PPUSH
24922: LD_STRING D14-JMM-1
24924: PPUSH
24925: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24929: LD_EXP 59
24933: PPUSH
24934: LD_STRING D14-Friend-1
24936: PPUSH
24937: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24941: LD_EXP 36
24945: PPUSH
24946: LD_STRING D14-JMM-2
24948: PPUSH
24949: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24953: LD_EXP 59
24957: PPUSH
24958: LD_STRING D14-Friend-2
24960: PPUSH
24961: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24965: LD_EXP 36
24969: PPUSH
24970: LD_STRING D14-JMM-3
24972: PPUSH
24973: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24977: LD_EXP 59
24981: PPUSH
24982: LD_STRING D14-Friend-3
24984: PPUSH
24985: CALL_OW 88
// DialogueOff ;
24989: CALL_OW 7
// dec = Query ( Q14 ) ;
24993: LD_ADDR_VAR 0 1
24997: PUSH
24998: LD_STRING Q14
25000: PPUSH
25001: CALL_OW 97
25005: ST_TO_ADDR
// if dec = 1 then
25006: LD_VAR 0 1
25010: PUSH
25011: LD_INT 1
25013: EQUAL
25014: IFFALSE 25048
// begin DialogueOn ;
25016: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25020: LD_EXP 36
25024: PPUSH
25025: LD_STRING D14a-JMM-1
25027: PPUSH
25028: CALL_OW 88
// DialogueOff ;
25032: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25036: LD_EXP 59
25040: PPUSH
25041: LD_INT 1
25043: PPUSH
25044: CALL_OW 235
// end ; if dec = 2 then
25048: LD_VAR 0 1
25052: PUSH
25053: LD_INT 2
25055: EQUAL
25056: IFFALSE 25102
// begin DialogueOn ;
25058: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25062: LD_EXP 36
25066: PPUSH
25067: LD_STRING D14b-JMM-1
25069: PPUSH
25070: CALL_OW 88
// DialogueOff ;
25074: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25078: LD_EXP 59
25082: PPUSH
25083: LD_INT 9
25085: PPUSH
25086: LD_INT 2
25088: PPUSH
25089: CALL_OW 111
// AddComHold ( Friend ) ;
25093: LD_EXP 59
25097: PPUSH
25098: CALL_OW 200
// end ; if dec = 3 then
25102: LD_VAR 0 1
25106: PUSH
25107: LD_INT 3
25109: EQUAL
25110: IFFALSE 25196
// begin DialogueOn ;
25112: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25116: LD_EXP 36
25120: PPUSH
25121: LD_STRING D14c-JMM-1
25123: PPUSH
25124: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25128: LD_EXP 59
25132: PPUSH
25133: LD_STRING D14c-Friend-1
25135: PPUSH
25136: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25140: LD_EXP 36
25144: PPUSH
25145: LD_STRING D14c-JMM-2
25147: PPUSH
25148: CALL_OW 88
// DialogueOff ;
25152: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25156: LD_INT 8
25158: PPUSH
25159: LD_INT 1
25161: PPUSH
25162: LD_INT 2
25164: PPUSH
25165: LD_INT 1
25167: PPUSH
25168: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25172: LD_EXP 59
25176: PPUSH
25177: LD_INT 9
25179: PPUSH
25180: LD_INT 2
25182: PPUSH
25183: CALL_OW 111
// AddComHold ( Friend ) ;
25187: LD_EXP 59
25191: PPUSH
25192: CALL_OW 200
// end ; end ;
25196: PPOPN 1
25198: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25199: LD_INT 9
25201: PPUSH
25202: LD_INT 2
25204: PPUSH
25205: CALL_OW 428
25209: PUSH
25210: LD_EXP 59
25214: EQUAL
25215: PUSH
25216: LD_EXP 59
25220: PPUSH
25221: CALL_OW 255
25225: PUSH
25226: LD_INT 8
25228: EQUAL
25229: AND
25230: IFFALSE 25244
25232: GO 25234
25234: DISABLE
// RemoveUnit ( Friend ) ;
25235: LD_EXP 59
25239: PPUSH
25240: CALL_OW 64
25244: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25245: LD_EXP 14
25249: PUSH
25250: LD_INT 31500
25252: GREATEREQUAL
25253: PUSH
25254: LD_EXP 7
25258: AND
25259: PUSH
25260: LD_EXP 2
25264: AND
25265: IFFALSE 25695
25267: GO 25269
25269: DISABLE
25270: LD_INT 0
25272: PPUSH
25273: PPUSH
25274: PPUSH
// begin missionStage := 7 ;
25275: LD_ADDR_EXP 15
25279: PUSH
25280: LD_INT 7
25282: ST_TO_ADDR
// uc_side = 1 ;
25283: LD_ADDR_OWVAR 20
25287: PUSH
25288: LD_INT 1
25290: ST_TO_ADDR
// uc_nation = 1 ;
25291: LD_ADDR_OWVAR 21
25295: PUSH
25296: LD_INT 1
25298: ST_TO_ADDR
// for i = 1 to 5 do
25299: LD_ADDR_VAR 0 1
25303: PUSH
25304: DOUBLE
25305: LD_INT 1
25307: DEC
25308: ST_TO_ADDR
25309: LD_INT 5
25311: PUSH
25312: FOR_TO
25313: IFFALSE 25409
// begin vc_engine = 3 ;
25315: LD_ADDR_OWVAR 39
25319: PUSH
25320: LD_INT 3
25322: ST_TO_ADDR
// vc_control = 3 ;
25323: LD_ADDR_OWVAR 38
25327: PUSH
25328: LD_INT 3
25330: ST_TO_ADDR
// vc_chassis = 3 ;
25331: LD_ADDR_OWVAR 37
25335: PUSH
25336: LD_INT 3
25338: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25339: LD_ADDR_OWVAR 40
25343: PUSH
25344: LD_INT 5
25346: PUSH
25347: LD_INT 9
25349: PUSH
25350: LD_INT 7
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 1
25360: PPUSH
25361: LD_INT 3
25363: PPUSH
25364: CALL_OW 12
25368: ARRAY
25369: ST_TO_ADDR
// veh = CreateVehicle ;
25370: LD_ADDR_VAR 0 2
25374: PUSH
25375: CALL_OW 45
25379: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25380: LD_VAR 0 2
25384: PPUSH
25385: LD_INT 1
25387: PPUSH
25388: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25392: LD_VAR 0 2
25396: PPUSH
25397: LD_INT 19
25399: PPUSH
25400: LD_INT 0
25402: PPUSH
25403: CALL_OW 49
// end ;
25407: GO 25312
25409: POP
25410: POP
// vc_engine = 3 ;
25411: LD_ADDR_OWVAR 39
25415: PUSH
25416: LD_INT 3
25418: ST_TO_ADDR
// vc_control = 1 ;
25419: LD_ADDR_OWVAR 38
25423: PUSH
25424: LD_INT 1
25426: ST_TO_ADDR
// vc_chassis = 3 ;
25427: LD_ADDR_OWVAR 37
25431: PUSH
25432: LD_INT 3
25434: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25435: LD_ADDR_OWVAR 40
25439: PUSH
25440: LD_INT 5
25442: PUSH
25443: LD_INT 9
25445: PUSH
25446: LD_INT 7
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 1
25456: PPUSH
25457: LD_INT 3
25459: PPUSH
25460: CALL_OW 12
25464: ARRAY
25465: ST_TO_ADDR
// vehG = CreateVehicle ;
25466: LD_ADDR_VAR 0 3
25470: PUSH
25471: CALL_OW 45
25475: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25476: LD_VAR 0 3
25480: PPUSH
25481: LD_INT 1
25483: PPUSH
25484: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25488: LD_VAR 0 3
25492: PPUSH
25493: LD_INT 19
25495: PPUSH
25496: LD_INT 0
25498: PPUSH
25499: CALL_OW 49
// if JMMGirl = 1 then
25503: LD_EXP 7
25507: PUSH
25508: LD_INT 1
25510: EQUAL
25511: IFFALSE 25567
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25513: LD_ADDR_EXP 37
25517: PUSH
25518: LD_STRING Joan
25520: PPUSH
25521: LD_INT 1
25523: PPUSH
25524: LD_STRING 14_
25526: PPUSH
25527: CALL 62912 0 3
25531: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25532: LD_EXP 37
25536: PPUSH
25537: LD_VAR 0 3
25541: PPUSH
25542: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25546: LD_VAR 0 3
25550: PPUSH
25551: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25555: LD_EXP 37
25559: PPUSH
25560: LD_STRING D10BW-Joan-1
25562: PPUSH
25563: CALL_OW 94
// end ; if JMMGirl = 2 then
25567: LD_EXP 7
25571: PUSH
25572: LD_INT 2
25574: EQUAL
25575: IFFALSE 25631
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25577: LD_ADDR_EXP 39
25581: PUSH
25582: LD_STRING Lisa
25584: PPUSH
25585: LD_INT 1
25587: PPUSH
25588: LD_STRING 14_
25590: PPUSH
25591: CALL 62912 0 3
25595: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25596: LD_EXP 39
25600: PPUSH
25601: LD_VAR 0 3
25605: PPUSH
25606: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25610: LD_VAR 0 3
25614: PPUSH
25615: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25619: LD_EXP 39
25623: PPUSH
25624: LD_STRING D10BW-Lisa-1
25626: PPUSH
25627: CALL_OW 94
// end ; if JMMGirl = 3 then
25631: LD_EXP 7
25635: PUSH
25636: LD_INT 3
25638: EQUAL
25639: IFFALSE 25695
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25641: LD_ADDR_EXP 51
25645: PUSH
25646: LD_STRING Connie
25648: PPUSH
25649: LD_INT 1
25651: PPUSH
25652: LD_STRING 14_
25654: PPUSH
25655: CALL 62912 0 3
25659: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25660: LD_EXP 51
25664: PPUSH
25665: LD_VAR 0 3
25669: PPUSH
25670: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25674: LD_VAR 0 3
25678: PPUSH
25679: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25683: LD_EXP 39
25687: PPUSH
25688: LD_STRING D10BW-Con-1
25690: PPUSH
25691: CALL_OW 94
// end ; end ;
25695: PPOPN 3
25697: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25698: LD_EXP 14
25702: PUSH
25703: LD_INT 94500
25705: GREATEREQUAL
25706: IFFALSE 26118
25708: GO 25710
25710: DISABLE
25711: LD_INT 0
25713: PPUSH
25714: PPUSH
25715: PPUSH
// begin tmp := PrepareStevensSquad ;
25716: LD_ADDR_VAR 0 3
25720: PUSH
25721: CALL 2058 0 0
25725: ST_TO_ADDR
// if not tmp then
25726: LD_VAR 0 3
25730: NOT
25731: IFFALSE 25735
// exit ;
25733: GO 26118
// uc_side := 1 ;
25735: LD_ADDR_OWVAR 20
25739: PUSH
25740: LD_INT 1
25742: ST_TO_ADDR
// uc_nation := 1 ;
25743: LD_ADDR_OWVAR 21
25747: PUSH
25748: LD_INT 1
25750: ST_TO_ADDR
// for i in tmp do
25751: LD_ADDR_VAR 0 1
25755: PUSH
25756: LD_VAR 0 3
25760: PUSH
25761: FOR_IN
25762: IFFALSE 25859
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25764: LD_INT 3
25766: PPUSH
25767: LD_INT 3
25769: PPUSH
25770: LD_INT 1
25772: PPUSH
25773: LD_INT 5
25775: PUSH
25776: LD_INT 9
25778: PUSH
25779: LD_INT 7
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: PPUSH
25790: LD_INT 3
25792: PPUSH
25793: CALL_OW 12
25797: ARRAY
25798: PPUSH
25799: LD_INT 40
25801: PPUSH
25802: CALL 69515 0 5
// veh := CreateVehicle ;
25806: LD_ADDR_VAR 0 2
25810: PUSH
25811: CALL_OW 45
25815: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25816: LD_VAR 0 2
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25828: LD_VAR 0 2
25832: PPUSH
25833: LD_INT 19
25835: PPUSH
25836: LD_INT 0
25838: PPUSH
25839: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25843: LD_VAR 0 1
25847: PPUSH
25848: LD_VAR 0 2
25852: PPUSH
25853: CALL_OW 52
// end ;
25857: GO 25761
25859: POP
25860: POP
// missionStage := 8 ;
25861: LD_ADDR_EXP 15
25865: PUSH
25866: LD_INT 8
25868: ST_TO_ADDR
// DialogueOn ;
25869: CALL_OW 6
// if Stevens then
25873: LD_EXP 38
25877: IFFALSE 25991
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25879: LD_EXP 38
25883: PPUSH
25884: CALL_OW 310
25888: PPUSH
25889: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25893: LD_EXP 38
25897: PPUSH
25898: LD_STRING D8-Huck-1
25900: PPUSH
25901: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25905: LD_EXP 36
25909: PPUSH
25910: LD_STRING D8-JMM-1
25912: PPUSH
25913: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25917: LD_EXP 38
25921: PPUSH
25922: LD_STRING D8-Huck-2
25924: PPUSH
25925: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25929: LD_EXP 36
25933: PPUSH
25934: LD_STRING D8-JMM-2
25936: PPUSH
25937: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25941: LD_EXP 38
25945: PPUSH
25946: LD_STRING D8-Huck-3
25948: PPUSH
25949: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25953: LD_EXP 36
25957: PPUSH
25958: LD_STRING D8-JMM-3
25960: PPUSH
25961: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25965: LD_EXP 38
25969: PPUSH
25970: LD_STRING D8-Huck-4
25972: PPUSH
25973: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25977: LD_EXP 36
25981: PPUSH
25982: LD_STRING D8-JMM-4
25984: PPUSH
25985: CALL_OW 88
// end else
25989: GO 26101
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25991: LD_EXP 52
25995: PPUSH
25996: CALL_OW 310
26000: PPUSH
26001: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26005: LD_EXP 52
26009: PPUSH
26010: LD_STRING D8-Huck-1
26012: PPUSH
26013: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26017: LD_EXP 36
26021: PPUSH
26022: LD_STRING D8-JMM-1a
26024: PPUSH
26025: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26029: LD_EXP 52
26033: PPUSH
26034: LD_STRING D8-Huck-2
26036: PPUSH
26037: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26041: LD_EXP 36
26045: PPUSH
26046: LD_STRING D8-JMM-2
26048: PPUSH
26049: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26053: LD_EXP 52
26057: PPUSH
26058: LD_STRING D8-Huck-3
26060: PPUSH
26061: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26065: LD_EXP 36
26069: PPUSH
26070: LD_STRING D8-JMM-3
26072: PPUSH
26073: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26077: LD_EXP 52
26081: PPUSH
26082: LD_STRING D8-Huck-4
26084: PPUSH
26085: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26089: LD_EXP 36
26093: PPUSH
26094: LD_STRING D8-JMM-4
26096: PPUSH
26097: CALL_OW 88
// end ; DialogueOff ;
26101: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26105: LD_INT 25
26107: PPUSH
26108: LD_INT 1
26110: PPUSH
26111: LD_INT 1
26113: PPUSH
26114: CALL_OW 322
// end ;
26118: PPOPN 3
26120: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26121: LD_INT 1
26123: PPUSH
26124: LD_EXP 68
26128: PPUSH
26129: CALL_OW 292
26133: IFFALSE 26384
26135: GO 26137
26137: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26138: LD_EXP 68
26142: PPUSH
26143: CALL_OW 87
// DialogueOn ;
26147: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26151: LD_EXP 36
26155: PPUSH
26156: LD_STRING D10nB-JMM-1
26158: PPUSH
26159: CALL_OW 88
// if BurlakStatus = 1 then
26163: LD_EXP 9
26167: PUSH
26168: LD_INT 1
26170: EQUAL
26171: IFFALSE 26185
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26173: LD_EXP 67
26177: PPUSH
26178: LD_STRING D10nB-Vse-1a
26180: PPUSH
26181: CALL_OW 94
// end ; if BurlakStatus = 0 then
26185: LD_EXP 9
26189: PUSH
26190: LD_INT 0
26192: EQUAL
26193: IFFALSE 26207
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26195: LD_EXP 67
26199: PPUSH
26200: LD_STRING D10nB-Vse-1
26202: PPUSH
26203: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26207: LD_EXP 36
26211: PPUSH
26212: LD_STRING D10nB-JMM-2
26214: PPUSH
26215: CALL_OW 88
// if KappaStatus then
26219: LD_EXP 2
26223: IFFALSE 26237
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26225: LD_EXP 67
26229: PPUSH
26230: LD_STRING D10nB-Vse-5a
26232: PPUSH
26233: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26237: LD_EXP 2
26241: NOT
26242: PUSH
26243: LD_EXP 6
26247: PUSH
26248: LD_INT 0
26250: EQUAL
26251: AND
26252: IFFALSE 26380
// begin if JMMGirl = 1 then
26254: LD_EXP 7
26258: PUSH
26259: LD_INT 1
26261: EQUAL
26262: IFFALSE 26312
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26264: LD_EXP 67
26268: PPUSH
26269: LD_STRING D10nB-Vse-2
26271: PPUSH
26272: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26276: LD_EXP 36
26280: PPUSH
26281: LD_STRING D10nB-JMM-3
26283: PPUSH
26284: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26288: LD_EXP 67
26292: PPUSH
26293: LD_STRING D10nB-Vse-3
26295: PPUSH
26296: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26300: LD_EXP 36
26304: PPUSH
26305: LD_STRING D10nB-JMM-4
26307: PPUSH
26308: CALL_OW 88
// end ; if JMMGirl = 2 then
26312: LD_EXP 7
26316: PUSH
26317: LD_INT 2
26319: EQUAL
26320: IFFALSE 26346
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26322: LD_EXP 67
26326: PPUSH
26327: LD_STRING D10nB-Vse-4
26329: PPUSH
26330: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26334: LD_EXP 36
26338: PPUSH
26339: LD_STRING D10nB-JMM-5
26341: PPUSH
26342: CALL_OW 88
// end ; if JMMGirl = 3 then
26346: LD_EXP 7
26350: PUSH
26351: LD_INT 3
26353: EQUAL
26354: IFFALSE 26380
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26356: LD_EXP 67
26360: PPUSH
26361: LD_STRING D10nB-Vse-5
26363: PPUSH
26364: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26368: LD_EXP 36
26372: PPUSH
26373: LD_STRING D10nB-JMM-6
26375: PPUSH
26376: CALL_OW 88
// end ; end ; DialogueOff ;
26380: CALL_OW 7
// end ;
26384: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26385: LD_EXP 14
26389: PUSH
26390: LD_INT 115500
26392: GREATEREQUAL
26393: IFFALSE 26752
26395: GO 26397
26397: DISABLE
26398: LD_INT 0
26400: PPUSH
// begin missionStage := 10 ;
26401: LD_ADDR_EXP 15
26405: PUSH
26406: LD_INT 10
26408: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26409: LD_ADDR_VAR 0 1
26413: PUSH
26414: LD_INT 22
26416: PUSH
26417: LD_INT 1
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 26
26426: PUSH
26427: LD_INT 1
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: LD_INT 25
26439: PUSH
26440: LD_INT 12
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 25
26456: PUSH
26457: LD_INT 16
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: PPUSH
26474: CALL_OW 69
26478: PUSH
26479: LD_EXP 36
26483: PUSH
26484: LD_EXP 38
26488: PUSH
26489: LD_EXP 52
26493: PUSH
26494: LD_EXP 39
26498: PUSH
26499: LD_EXP 40
26503: PUSH
26504: LD_EXP 41
26508: PUSH
26509: LD_EXP 42
26513: PUSH
26514: LD_EXP 43
26518: PUSH
26519: LD_EXP 44
26523: PUSH
26524: LD_EXP 45
26528: PUSH
26529: LD_EXP 46
26533: PUSH
26534: LD_EXP 47
26538: PUSH
26539: LD_EXP 48
26543: PUSH
26544: LD_EXP 49
26548: PUSH
26549: LD_EXP 50
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: LIST
26569: LIST
26570: DIFF
26571: ST_TO_ADDR
// if not tmp and Brown then
26572: LD_VAR 0 1
26576: NOT
26577: PUSH
26578: LD_EXP 44
26582: AND
26583: IFFALSE 26598
// tmp := [ Brown ] ;
26585: LD_ADDR_VAR 0 1
26589: PUSH
26590: LD_EXP 44
26594: PUSH
26595: EMPTY
26596: LIST
26597: ST_TO_ADDR
// DialogueOn ;
26598: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26602: LD_VAR 0 1
26606: PUSH
26607: LD_INT 1
26609: ARRAY
26610: PPUSH
26611: LD_STRING D11-Sol1-1
26613: PPUSH
26614: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26618: LD_EXP 61
26622: PPUSH
26623: LD_STRING D11-Pla-1
26625: PPUSH
26626: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26630: LD_EXP 62
26634: PPUSH
26635: LD_STRING D11-Kov-1
26637: PPUSH
26638: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26642: LD_EXP 61
26646: PPUSH
26647: LD_STRING D11-Pla-2
26649: PPUSH
26650: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26654: LD_VAR 0 1
26658: PUSH
26659: LD_INT 1
26661: ARRAY
26662: PPUSH
26663: LD_STRING D11-Sol1-2
26665: PPUSH
26666: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26670: LD_EXP 36
26674: PPUSH
26675: LD_STRING D11-JMM-2
26677: PPUSH
26678: CALL_OW 88
// DialogueOff ;
26682: CALL_OW 7
// allowBehemothConstruct := true ;
26686: LD_ADDR_EXP 25
26690: PUSH
26691: LD_INT 1
26693: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26694: LD_STRING M4
26696: PPUSH
26697: CALL_OW 337
// BuildBehemoths ;
26701: CALL 7488 0 0
// repeat wait ( 15 15$00 ) ;
26705: LD_INT 31500
26707: PPUSH
26708: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26712: LD_EXP 27
26716: IFFALSE 26720
// break ;
26718: GO 26752
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26720: LD_INT 267
26722: PPUSH
26723: CALL_OW 274
26727: PPUSH
26728: LD_INT 1
26730: PPUSH
26731: CALL_OW 275
26735: PUSH
26736: LD_INT 1000
26738: GREATEREQUAL
26739: IFFALSE 26745
// BuildBehemoths ;
26741: CALL 7488 0 0
// until not behemothBuilders ;
26745: LD_EXP 70
26749: NOT
26750: IFFALSE 26705
// end ;
26752: PPOPN 1
26754: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26755: LD_EXP 70
26759: NOT
26760: PUSH
26761: LD_EXP 28
26765: NOT
26766: AND
26767: PUSH
26768: LD_EXP 25
26772: AND
26773: IFFALSE 26793
26775: GO 26777
26777: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26778: LD_STRING M4a
26780: PPUSH
26781: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26785: LD_ADDR_EXP 27
26789: PUSH
26790: LD_INT 1
26792: ST_TO_ADDR
// end ;
26793: END
// every 0 0$1 trigger behemothDone do
26794: LD_EXP 28
26798: IFFALSE 26810
26800: GO 26802
26802: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26803: LD_STRING M4b
26805: PPUSH
26806: CALL_OW 337
26810: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26811: LD_EXP 29
26815: NOT
26816: IFFALSE 27012
26818: GO 26820
26820: DISABLE
26821: LD_INT 0
26823: PPUSH
26824: PPUSH
// begin enable ;
26825: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26826: LD_ADDR_VAR 0 1
26830: PUSH
26831: LD_INT 3
26833: PPUSH
26834: CALL 105308 0 1
26838: ST_TO_ADDR
// if not tmp and not behemothDone then
26839: LD_VAR 0 1
26843: NOT
26844: PUSH
26845: LD_EXP 28
26849: NOT
26850: AND
26851: IFFALSE 26887
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26853: LD_ADDR_VAR 0 1
26857: PUSH
26858: LD_INT 22
26860: PUSH
26861: LD_INT 3
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 30
26870: PUSH
26871: LD_INT 37
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: PPUSH
26882: CALL_OW 69
26886: ST_TO_ADDR
// if not tmp then
26887: LD_VAR 0 1
26891: NOT
26892: IFFALSE 26896
// exit ;
26894: GO 27012
// for i in tmp do
26896: LD_ADDR_VAR 0 2
26900: PUSH
26901: LD_VAR 0 1
26905: PUSH
26906: FOR_IN
26907: IFFALSE 27010
// if See ( 1 , i ) then
26909: LD_INT 1
26911: PPUSH
26912: LD_VAR 0 2
26916: PPUSH
26917: CALL_OW 292
26921: IFFALSE 27008
// begin if GetType ( i ) = unit_building then
26923: LD_VAR 0 2
26927: PPUSH
26928: CALL_OW 247
26932: PUSH
26933: LD_INT 3
26935: EQUAL
26936: IFFALSE 26974
// begin CenterNowOnUnits ( i ) ;
26938: LD_VAR 0 2
26942: PPUSH
26943: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26947: LD_EXP 36
26951: PPUSH
26952: LD_STRING D17a-JMM-1
26954: PPUSH
26955: CALL_OW 88
// seeBehemoth := true ;
26959: LD_ADDR_EXP 29
26963: PUSH
26964: LD_INT 1
26966: ST_TO_ADDR
// disable ;
26967: DISABLE
// exit ;
26968: POP
26969: POP
26970: GO 27012
// end else
26972: GO 27008
// begin CenterNowOnUnits ( i ) ;
26974: LD_VAR 0 2
26978: PPUSH
26979: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26983: LD_EXP 36
26987: PPUSH
26988: LD_STRING D17b-JMM-1
26990: PPUSH
26991: CALL_OW 88
// seeBehemoth := true ;
26995: LD_ADDR_EXP 29
26999: PUSH
27000: LD_INT 1
27002: ST_TO_ADDR
// disable ;
27003: DISABLE
// exit ;
27004: POP
27005: POP
27006: GO 27012
// end ; end ;
27008: GO 26906
27010: POP
27011: POP
// end ;
27012: PPOPN 2
27014: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27015: LD_EXP 14
27019: PUSH
27020: LD_INT 116550
27022: GREATEREQUAL
27023: IFFALSE 28199
27025: GO 27027
27027: DISABLE
27028: LD_INT 0
27030: PPUSH
27031: PPUSH
27032: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27033: LD_INT 2
27035: PPUSH
27036: LD_INT 23
27038: PUSH
27039: LD_INT 3
27041: PUSH
27042: LD_INT 3
27044: PUSH
27045: LD_INT 48
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: PPUSH
27057: CALL 56910 0 2
// repeat wait ( 0 0$1 ) ;
27061: LD_INT 35
27063: PPUSH
27064: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27068: LD_INT 22
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 34
27080: PUSH
27081: LD_INT 48
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PPUSH
27092: CALL_OW 69
27096: IFFALSE 27061
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27098: LD_ADDR_VAR 0 1
27102: PUSH
27103: LD_INT 22
27105: PUSH
27106: LD_INT 3
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 34
27115: PUSH
27116: LD_INT 48
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PPUSH
27127: CALL_OW 69
27131: PUSH
27132: LD_INT 1
27134: ARRAY
27135: ST_TO_ADDR
// missionStage := 12 ;
27136: LD_ADDR_EXP 15
27140: PUSH
27141: LD_INT 12
27143: ST_TO_ADDR
// platonovHasBomb := true ;
27144: LD_ADDR_EXP 30
27148: PUSH
27149: LD_INT 1
27151: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 181
27159: PPUSH
27160: LD_INT 86
27162: PPUSH
27163: CALL_OW 171
// AddComHold ( bomb ) ;
27167: LD_VAR 0 1
27171: PPUSH
27172: CALL_OW 200
// wait ( 0 0$10 ) ;
27176: LD_INT 350
27178: PPUSH
27179: CALL_OW 67
// DialogueOn ;
27183: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27187: LD_EXP 61
27191: PPUSH
27192: LD_STRING D15-Pla-1
27194: PPUSH
27195: CALL_OW 94
// dec = Query ( Q15a ) ;
27199: LD_ADDR_VAR 0 2
27203: PUSH
27204: LD_STRING Q15a
27206: PPUSH
27207: CALL_OW 97
27211: ST_TO_ADDR
// if dec = 1 then
27212: LD_VAR 0 2
27216: PUSH
27217: LD_INT 1
27219: EQUAL
27220: IFFALSE 27243
// begin Say ( JMM , D15a-JMM-1 ) ;
27222: LD_EXP 36
27226: PPUSH
27227: LD_STRING D15a-JMM-1
27229: PPUSH
27230: CALL_OW 88
// YouLost ( Surrender ) ;
27234: LD_STRING Surrender
27236: PPUSH
27237: CALL_OW 104
// exit ;
27241: GO 28199
// end ; if dec = 2 then
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: EQUAL
27251: IFFALSE 27320
// begin Say ( JMM , D15b-JMM-1 ) ;
27253: LD_EXP 36
27257: PPUSH
27258: LD_STRING D15b-JMM-1
27260: PPUSH
27261: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27265: LD_EXP 61
27269: PPUSH
27270: LD_STRING D15b-Pla-1
27272: PPUSH
27273: CALL_OW 94
// DialogueOff ;
27277: CALL_OW 7
// wait ( 3 3$00 ) ;
27281: LD_INT 6300
27283: PPUSH
27284: CALL_OW 67
// DialogueOn ;
27288: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27292: LD_EXP 36
27296: PPUSH
27297: LD_STRING D15d-JMM-1a
27299: PPUSH
27300: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27304: LD_EXP 61
27308: PPUSH
27309: LD_STRING D15d-Pla-1
27311: PPUSH
27312: CALL_OW 94
// DialogueOff ;
27316: CALL_OW 7
// end ; if dec = 3 then
27320: LD_VAR 0 2
27324: PUSH
27325: LD_INT 3
27327: EQUAL
27328: IFFALSE 27382
// begin Say ( JMM , D15c-JMM-1 ) ;
27330: LD_EXP 36
27334: PPUSH
27335: LD_STRING D15c-JMM-1
27337: PPUSH
27338: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27342: LD_EXP 61
27346: PPUSH
27347: LD_STRING D15c-Pla-1
27349: PPUSH
27350: CALL_OW 94
// DialogueOff ;
27354: CALL_OW 7
// wait ( 0 0$15 ) ;
27358: LD_INT 525
27360: PPUSH
27361: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27365: LD_VAR 0 1
27369: PPUSH
27370: LD_INT 60
27372: PPUSH
27373: LD_INT 95
27375: PPUSH
27376: CALL_OW 116
// exit ;
27380: GO 28199
// end ; if dec = 4 then
27382: LD_VAR 0 2
27386: PUSH
27387: LD_INT 4
27389: EQUAL
27390: IFFALSE 27420
// begin Say ( JMM , D15d-JMM-1 ) ;
27392: LD_EXP 36
27396: PPUSH
27397: LD_STRING D15d-JMM-1
27399: PPUSH
27400: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27404: LD_EXP 61
27408: PPUSH
27409: LD_STRING D15d-Pla-1
27411: PPUSH
27412: CALL_OW 94
// DialogueOff ;
27416: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27420: LD_EXP 59
27424: PPUSH
27425: CALL_OW 302
27429: PUSH
27430: LD_EXP 59
27434: PPUSH
27435: CALL_OW 255
27439: PUSH
27440: LD_INT 1
27442: EQUAL
27443: AND
27444: PUSH
27445: LD_INT 22
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 34
27457: PUSH
27458: LD_INT 8
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PPUSH
27469: CALL_OW 69
27473: NOT
27474: AND
27475: IFFALSE 28100
// begin SetSide ( Friend , 8 ) ;
27477: LD_EXP 59
27481: PPUSH
27482: LD_INT 8
27484: PPUSH
27485: CALL_OW 235
// if IsInUnit ( Friend ) then
27489: LD_EXP 59
27493: PPUSH
27494: CALL_OW 310
27498: IFFALSE 27509
// ComExitBuilding ( Friend ) ;
27500: LD_EXP 59
27504: PPUSH
27505: CALL_OW 122
// if IsDriver ( Friend ) then
27509: LD_EXP 59
27513: PPUSH
27514: CALL 102985 0 1
27518: IFFALSE 27529
// ComExitVehicle ( Friend ) ;
27520: LD_EXP 59
27524: PPUSH
27525: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27529: LD_EXP 59
27533: PPUSH
27534: LD_INT 9
27536: PPUSH
27537: LD_INT 2
27539: PPUSH
27540: CALL_OW 171
// wait ( 0 0$05 ) ;
27544: LD_INT 175
27546: PPUSH
27547: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27551: LD_EXP 59
27555: PPUSH
27556: CALL_OW 87
// DialogueOn ;
27560: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27564: LD_EXP 36
27568: PPUSH
27569: LD_STRING D16-JMM-1
27571: PPUSH
27572: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27576: LD_EXP 59
27580: PPUSH
27581: LD_STRING D16-Friend-1
27583: PPUSH
27584: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27588: LD_EXP 36
27592: PPUSH
27593: LD_STRING D16-JMM-2
27595: PPUSH
27596: CALL_OW 88
// DialogueOff ;
27600: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27604: LD_EXP 59
27608: PPUSH
27609: LD_INT 1
27611: PPUSH
27612: CALL_OW 235
// ComHold ( Friend ) ;
27616: LD_EXP 59
27620: PPUSH
27621: CALL_OW 140
// wait ( 0 0$20 ) ;
27625: LD_INT 700
27627: PPUSH
27628: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27632: LD_EXP 59
27636: PPUSH
27637: LD_INT 9
27639: PPUSH
27640: LD_INT 2
27642: PPUSH
27643: CALL_OW 297
27647: PUSH
27648: LD_INT 30
27650: LESS
27651: IFFALSE 27720
// begin SetSide ( Friend , 8 ) ;
27653: LD_EXP 59
27657: PPUSH
27658: LD_INT 8
27660: PPUSH
27661: CALL_OW 235
// if IsInUnit ( Friend ) then
27665: LD_EXP 59
27669: PPUSH
27670: CALL_OW 310
27674: IFFALSE 27685
// ComExitBuilding ( Friend ) ;
27676: LD_EXP 59
27680: PPUSH
27681: CALL_OW 122
// if IsDriver ( Friend ) then
27685: LD_EXP 59
27689: PPUSH
27690: CALL 102985 0 1
27694: IFFALSE 27705
// ComExitVehicle ( Friend ) ;
27696: LD_EXP 59
27700: PPUSH
27701: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27705: LD_EXP 59
27709: PPUSH
27710: LD_INT 9
27712: PPUSH
27713: LD_INT 2
27715: PPUSH
27716: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27720: LD_INT 1050
27722: PPUSH
27723: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27727: LD_INT 22
27729: PUSH
27730: LD_INT 1
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: LD_INT 34
27739: PUSH
27740: LD_INT 8
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PPUSH
27751: CALL_OW 69
27755: NOT
27756: IFFALSE 28078
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27758: LD_ADDR_VAR 0 3
27762: PUSH
27763: LD_INT 22
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 26
27775: PUSH
27776: LD_INT 1
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 3
27785: PUSH
27786: LD_INT 25
27788: PUSH
27789: LD_INT 12
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 25
27798: PUSH
27799: LD_INT 16
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PPUSH
27816: CALL_OW 69
27820: PUSH
27821: LD_EXP 36
27825: PUSH
27826: LD_EXP 38
27830: PUSH
27831: LD_EXP 52
27835: PUSH
27836: LD_EXP 39
27840: PUSH
27841: LD_EXP 40
27845: PUSH
27846: LD_EXP 41
27850: PUSH
27851: LD_EXP 42
27855: PUSH
27856: LD_EXP 43
27860: PUSH
27861: LD_EXP 44
27865: PUSH
27866: LD_EXP 45
27870: PUSH
27871: LD_EXP 46
27875: PUSH
27876: LD_EXP 47
27880: PUSH
27881: LD_EXP 48
27885: PUSH
27886: LD_EXP 49
27890: PUSH
27891: LD_EXP 50
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: DIFF
27913: ST_TO_ADDR
// DialogueOn ;
27914: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27918: LD_EXP 61
27922: PPUSH
27923: LD_STRING D16a-Pla-1
27925: PPUSH
27926: CALL_OW 94
// if Stevens then
27930: LD_EXP 38
27934: IFFALSE 27950
// Say ( Stevens , D16a-Huck-1 ) else
27936: LD_EXP 38
27940: PPUSH
27941: LD_STRING D16a-Huck-1
27943: PPUSH
27944: CALL_OW 88
27948: GO 27992
// if Baker then
27950: LD_EXP 52
27954: IFFALSE 27970
// Say ( Baker , D16a-Huck-1 ) else
27956: LD_EXP 52
27960: PPUSH
27961: LD_STRING D16a-Huck-1
27963: PPUSH
27964: CALL_OW 88
27968: GO 27992
// if tmp then
27970: LD_VAR 0 3
27974: IFFALSE 27992
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27976: LD_VAR 0 3
27980: PUSH
27981: LD_INT 1
27983: ARRAY
27984: PPUSH
27985: LD_STRING D16a-Sol1-1
27987: PPUSH
27988: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27992: LD_EXP 59
27996: PPUSH
27997: CALL_OW 255
28001: PUSH
28002: LD_INT 8
28004: EQUAL
28005: IFFALSE 28021
// Say ( JMM , D16a-JMM-1 ) else
28007: LD_EXP 36
28011: PPUSH
28012: LD_STRING D16a-JMM-1
28014: PPUSH
28015: CALL_OW 88
28019: GO 28057
// begin Say ( JMM , D16a-JMM-1a ) ;
28021: LD_EXP 36
28025: PPUSH
28026: LD_STRING D16a-JMM-1a
28028: PPUSH
28029: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28033: LD_EXP 59
28037: PPUSH
28038: LD_STRING D16a-Friend-1
28040: PPUSH
28041: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28045: LD_EXP 59
28049: PPUSH
28050: LD_INT 3
28052: PPUSH
28053: CALL_OW 235
// end ; DialogueOff ;
28057: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28061: LD_VAR 0 1
28065: PPUSH
28066: LD_INT 60
28068: PPUSH
28069: LD_INT 95
28071: PPUSH
28072: CALL_OW 116
// end else
28076: GO 28098
// begin DialogueOn ;
28078: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28082: LD_EXP 61
28086: PPUSH
28087: LD_STRING D16c-Pla-
28089: PPUSH
28090: CALL_OW 94
// DialogueOff ;
28094: CALL_OW 7
// end ; end else
28098: GO 28199
// begin wait ( 3 3$00 ) ;
28100: LD_INT 6300
28102: PPUSH
28103: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28107: LD_INT 22
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 34
28119: PUSH
28120: LD_INT 8
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PPUSH
28131: CALL_OW 69
28135: NOT
28136: IFFALSE 28179
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28138: LD_EXP 61
28142: PPUSH
28143: LD_STRING D16b-Pla-1
28145: PPUSH
28146: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28150: LD_EXP 36
28154: PPUSH
28155: LD_STRING D16b-JMM-
28157: PPUSH
28158: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28162: LD_VAR 0 1
28166: PPUSH
28167: LD_INT 60
28169: PPUSH
28170: LD_INT 95
28172: PPUSH
28173: CALL_OW 116
// end else
28177: GO 28199
// begin DialogueOn ;
28179: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28183: LD_EXP 61
28187: PPUSH
28188: LD_STRING D16c-Pla-
28190: PPUSH
28191: CALL_OW 94
// DialogueOff ;
28195: CALL_OW 7
// end ; end ; end ;
28199: PPOPN 3
28201: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28202: LD_EXP 14
28206: PUSH
28207: LD_INT 126000
28209: GREATEREQUAL
28210: PUSH
28211: LD_EXP 23
28215: NOT
28216: AND
28217: PUSH
28218: LD_EXP 71
28222: PPUSH
28223: CALL_OW 302
28227: AND
28228: IFFALSE 28586
28230: GO 28232
28232: DISABLE
28233: LD_INT 0
28235: PPUSH
// begin missionStage = 11 ;
28236: LD_ADDR_EXP 15
28240: PUSH
28241: LD_INT 11
28243: ST_TO_ADDR
// DialogueOn ;
28244: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28248: LD_EXP 71
28252: PPUSH
28253: LD_STRING D9-Roth-1
28255: PPUSH
28256: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28260: LD_EXP 36
28264: PPUSH
28265: LD_STRING D9-JMM-1
28267: PPUSH
28268: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28272: LD_EXP 71
28276: PPUSH
28277: LD_STRING D9-Roth-2
28279: PPUSH
28280: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28284: LD_EXP 71
28288: PPUSH
28289: LD_STRING D9-Roth-2a
28291: PPUSH
28292: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28296: LD_EXP 61
28300: PPUSH
28301: LD_STRING D9-Pla-2
28303: PPUSH
28304: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28308: LD_EXP 71
28312: PPUSH
28313: LD_STRING D9-Roth-3
28315: PPUSH
28316: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28320: LD_EXP 61
28324: PPUSH
28325: LD_STRING D9-Pla-3
28327: PPUSH
28328: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28332: LD_EXP 71
28336: PPUSH
28337: LD_STRING D9-Roth-4
28339: PPUSH
28340: CALL_OW 94
// dec = Query ( Q9 ) ;
28344: LD_ADDR_VAR 0 1
28348: PUSH
28349: LD_STRING Q9
28351: PPUSH
28352: CALL_OW 97
28356: ST_TO_ADDR
// if dec = 1 then
28357: LD_VAR 0 1
28361: PUSH
28362: LD_INT 1
28364: EQUAL
28365: IFFALSE 28379
// SayRadio ( Roth , D9a-Roth-1 ) ;
28367: LD_EXP 71
28371: PPUSH
28372: LD_STRING D9a-Roth-1
28374: PPUSH
28375: CALL_OW 94
// if dec = 2 then
28379: LD_VAR 0 1
28383: PUSH
28384: LD_INT 2
28386: EQUAL
28387: IFFALSE 28413
// begin Say ( JMM , D9b-JMM-1 ) ;
28389: LD_EXP 36
28393: PPUSH
28394: LD_STRING D9b-JMM-1
28396: PPUSH
28397: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28401: LD_EXP 71
28405: PPUSH
28406: LD_STRING D9b-Roth-1
28408: PPUSH
28409: CALL_OW 94
// end ; if dec = 3 then
28413: LD_VAR 0 1
28417: PUSH
28418: LD_INT 3
28420: EQUAL
28421: IFFALSE 28483
// begin Say ( JMM , D9c-JMM-1 ) ;
28423: LD_EXP 36
28427: PPUSH
28428: LD_STRING D9c-JMM-1
28430: PPUSH
28431: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28435: LD_EXP 71
28439: PPUSH
28440: LD_STRING D9c-Roth-1
28442: PPUSH
28443: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28447: LD_EXP 36
28451: PPUSH
28452: LD_STRING D9c-JMM-2
28454: PPUSH
28455: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28459: LD_EXP 71
28463: PPUSH
28464: LD_STRING D9c-Roth-2
28466: PPUSH
28467: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9c-JMM-3
28478: PPUSH
28479: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9c-Roth-3
28490: PPUSH
28491: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28495: LD_EXP 71
28499: PPUSH
28500: LD_STRING D9cont-Roth-1
28502: PPUSH
28503: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28507: LD_EXP 36
28511: PPUSH
28512: LD_STRING D9cont-JMM-1
28514: PPUSH
28515: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28519: LD_EXP 71
28523: PPUSH
28524: LD_STRING D9cont-Roth-2
28526: PPUSH
28527: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28531: LD_EXP 36
28535: PPUSH
28536: LD_STRING D9cont-JMM-2
28538: PPUSH
28539: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28543: LD_EXP 71
28547: PPUSH
28548: LD_STRING D9cont-Roth-3
28550: PPUSH
28551: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28555: LD_EXP 36
28559: PPUSH
28560: LD_STRING D9cont-JMM-3
28562: PPUSH
28563: CALL_OW 88
// DialogueOff ;
28567: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28571: LD_STRING M3
28573: PPUSH
28574: CALL_OW 337
// allianceActive := true ;
28578: LD_ADDR_EXP 31
28582: PUSH
28583: LD_INT 1
28585: ST_TO_ADDR
// end ;
28586: PPOPN 1
28588: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28589: LD_EXP 61
28593: PPUSH
28594: CALL_OW 301
28598: PUSH
28599: LD_EXP 64
28603: PPUSH
28604: CALL_OW 301
28608: AND
28609: PUSH
28610: LD_INT 22
28612: PUSH
28613: LD_INT 3
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: LD_INT 21
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: EMPTY
28627: LIST
28628: LIST
28629: PUSH
28630: LD_INT 50
28632: PUSH
28633: EMPTY
28634: LIST
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: PPUSH
28641: CALL_OW 69
28645: PUSH
28646: LD_INT 7
28648: PUSH
28649: LD_INT 8
28651: PUSH
28652: LD_INT 9
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: LIST
28659: PUSH
28660: LD_OWVAR 67
28664: ARRAY
28665: LESS
28666: AND
28667: IFFALSE 29438
28669: GO 28671
28671: DISABLE
28672: LD_INT 0
28674: PPUSH
28675: PPUSH
28676: PPUSH
28677: PPUSH
// begin MC_Kill ( 1 ) ;
28678: LD_INT 1
28680: PPUSH
28681: CALL 33924 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28685: LD_INT 1
28687: PPUSH
28688: LD_INT 3
28690: PPUSH
28691: LD_INT 1
28693: PPUSH
28694: LD_INT 1
28696: PPUSH
28697: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28701: LD_ADDR_VAR 0 1
28705: PUSH
28706: LD_INT 22
28708: PUSH
28709: LD_INT 3
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: LD_INT 1
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 24
28728: PUSH
28729: LD_INT 900
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: LIST
28740: PPUSH
28741: CALL_OW 69
28745: PUSH
28746: FOR_IN
28747: IFFALSE 28778
// if GetSex ( i ) = sex_male then
28749: LD_VAR 0 1
28753: PPUSH
28754: CALL_OW 258
28758: PUSH
28759: LD_INT 1
28761: EQUAL
28762: IFFALSE 28776
// begin tmp = i ;
28764: LD_ADDR_VAR 0 2
28768: PUSH
28769: LD_VAR 0 1
28773: ST_TO_ADDR
// break ;
28774: GO 28778
// end ;
28776: GO 28746
28778: POP
28779: POP
// if tmp = 0 then
28780: LD_VAR 0 2
28784: PUSH
28785: LD_INT 0
28787: EQUAL
28788: IFFALSE 28842
// begin uc_side = 3 ;
28790: LD_ADDR_OWVAR 20
28794: PUSH
28795: LD_INT 3
28797: ST_TO_ADDR
// uc_nation = 3 ;
28798: LD_ADDR_OWVAR 21
28802: PUSH
28803: LD_INT 3
28805: ST_TO_ADDR
// hc_name =  ;
28806: LD_ADDR_OWVAR 26
28810: PUSH
28811: LD_STRING 
28813: ST_TO_ADDR
// hc_gallery =  ;
28814: LD_ADDR_OWVAR 33
28818: PUSH
28819: LD_STRING 
28821: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28822: LD_INT 1
28824: PPUSH
28825: LD_INT 10
28827: PPUSH
28828: CALL_OW 381
// tmp = CreateHuman ;
28832: LD_ADDR_VAR 0 2
28836: PUSH
28837: CALL_OW 44
28841: ST_TO_ADDR
// end ; DialogueOn ;
28842: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28846: LD_VAR 0 2
28850: PPUSH
28851: LD_STRING DSurrenderRussians-RSol1-1a
28853: PPUSH
28854: CALL_OW 88
// DialogueOff ;
28858: CALL_OW 7
// russianDestroyed := true ;
28862: LD_ADDR_EXP 21
28866: PUSH
28867: LD_INT 1
28869: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28870: LD_INT 22
28872: PUSH
28873: LD_INT 3
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 21
28882: PUSH
28883: LD_INT 1
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PPUSH
28894: CALL_OW 69
28898: PPUSH
28899: CALL_OW 122
// wait ( 0 0$1 ) ;
28903: LD_INT 35
28905: PPUSH
28906: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28910: LD_INT 22
28912: PUSH
28913: LD_INT 3
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 21
28922: PUSH
28923: LD_INT 1
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PPUSH
28934: CALL_OW 69
28938: PPUSH
28939: LD_INT 25
28941: PPUSH
28942: CALL_OW 173
// wait ( 0 0$10 ) ;
28946: LD_INT 350
28948: PPUSH
28949: CALL_OW 67
// PrepareOmarInvasion ;
28953: CALL 13611 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28957: LD_ADDR_VAR 0 2
28961: PUSH
28962: LD_EXP 89
28966: PPUSH
28967: CALL_OW 250
28971: PUSH
28972: LD_EXP 89
28976: PPUSH
28977: CALL_OW 251
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28986: LD_VAR 0 2
28990: PUSH
28991: LD_INT 1
28993: ARRAY
28994: PPUSH
28995: LD_VAR 0 2
28999: PUSH
29000: LD_INT 2
29002: ARRAY
29003: PPUSH
29004: LD_INT 1
29006: PPUSH
29007: LD_INT 8
29009: NEG
29010: PPUSH
29011: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29015: LD_EXP 89
29019: PPUSH
29020: CALL_OW 87
// DialogueOn ;
29024: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29028: LD_EXP 36
29032: PPUSH
29033: LD_STRING D19-JMM-1
29035: PPUSH
29036: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29040: LD_ADDR_VAR 0 3
29044: PUSH
29045: LD_INT 22
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 26
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 2
29067: PUSH
29068: LD_INT 25
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 25
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 25
29090: PUSH
29091: LD_INT 3
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 25
29100: PUSH
29101: LD_INT 4
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 25
29110: PUSH
29111: LD_INT 5
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 25
29120: PUSH
29121: LD_INT 8
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: LIST
29141: PPUSH
29142: CALL_OW 69
29146: PUSH
29147: LD_EXP 36
29151: PUSH
29152: LD_EXP 37
29156: PUSH
29157: LD_EXP 38
29161: PUSH
29162: LD_EXP 39
29166: PUSH
29167: LD_EXP 40
29171: PUSH
29172: LD_EXP 41
29176: PUSH
29177: LD_EXP 42
29181: PUSH
29182: LD_EXP 43
29186: PUSH
29187: LD_EXP 44
29191: PUSH
29192: LD_EXP 45
29196: PUSH
29197: LD_EXP 46
29201: PUSH
29202: LD_EXP 47
29206: PUSH
29207: LD_EXP 48
29211: PUSH
29212: LD_EXP 49
29216: PUSH
29217: LD_EXP 50
29221: PUSH
29222: LD_EXP 51
29226: PUSH
29227: LD_EXP 52
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: DIFF
29251: ST_TO_ADDR
// if tmp2 then
29252: LD_VAR 0 3
29256: IFFALSE 29274
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29258: LD_VAR 0 3
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PPUSH
29267: LD_STRING D19-Sol1-1
29269: PPUSH
29270: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29274: LD_EXP 36
29278: PPUSH
29279: LD_STRING D19-JMM-2
29281: PPUSH
29282: CALL_OW 88
// DialogueOff ;
29286: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29290: LD_VAR 0 2
29294: PUSH
29295: LD_INT 1
29297: ARRAY
29298: PPUSH
29299: LD_VAR 0 2
29303: PUSH
29304: LD_INT 2
29306: ARRAY
29307: PPUSH
29308: LD_INT 1
29310: PPUSH
29311: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29315: LD_STRING M5
29317: PPUSH
29318: CALL_OW 337
// omarOnMotherLode := false ;
29322: LD_ADDR_VAR 0 4
29326: PUSH
29327: LD_INT 0
29329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29330: LD_INT 35
29332: PPUSH
29333: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29337: LD_EXP 89
29341: PPUSH
29342: LD_INT 215
29344: PPUSH
29345: LD_INT 100
29347: PPUSH
29348: CALL_OW 297
29352: PUSH
29353: LD_INT 10
29355: LESS
29356: PUSH
29357: LD_VAR 0 4
29361: NOT
29362: AND
29363: IFFALSE 29397
// begin omarOnMotherLode := true ;
29365: LD_ADDR_VAR 0 4
29369: PUSH
29370: LD_INT 1
29372: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29373: LD_EXP 36
29377: PPUSH
29378: LD_STRING D19b-JMM-1
29380: PPUSH
29381: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29385: LD_EXP 89
29389: PPUSH
29390: LD_STRING DOmarContam-Omar-1
29392: PPUSH
29393: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29397: LD_EXP 89
29401: PPUSH
29402: CALL_OW 301
29406: IFFALSE 29330
// Say ( JMM , D19a-JMM-1 ) ;
29408: LD_EXP 36
29412: PPUSH
29413: LD_STRING D19a-JMM-1
29415: PPUSH
29416: CALL_OW 88
// if Heike then
29420: LD_EXP 90
29424: IFFALSE 29438
// Say ( Heike , D19a-Hke-1 ) ;
29426: LD_EXP 90
29430: PPUSH
29431: LD_STRING D19a-Hke-1
29433: PPUSH
29434: CALL_OW 88
// end ;
29438: PPOPN 4
29440: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29441: LD_INT 22
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 21
29453: PUSH
29454: LD_INT 1
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PPUSH
29465: CALL_OW 69
29469: PUSH
29470: LD_EXP 21
29474: AND
29475: IFFALSE 29543
29477: GO 29479
29479: DISABLE
29480: LD_INT 0
29482: PPUSH
29483: PPUSH
// begin enable ;
29484: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29485: LD_ADDR_VAR 0 2
29489: PUSH
29490: LD_INT 25
29492: PPUSH
29493: LD_INT 22
29495: PUSH
29496: LD_INT 3
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PPUSH
29503: CALL_OW 70
29507: ST_TO_ADDR
// if not tmp then
29508: LD_VAR 0 2
29512: NOT
29513: IFFALSE 29517
// exit ;
29515: GO 29543
// for i in tmp do
29517: LD_ADDR_VAR 0 1
29521: PUSH
29522: LD_VAR 0 2
29526: PUSH
29527: FOR_IN
29528: IFFALSE 29541
// RemoveUnit ( i ) ;
29530: LD_VAR 0 1
29534: PPUSH
29535: CALL_OW 64
29539: GO 29527
29541: POP
29542: POP
// end ;
29543: PPOPN 2
29545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29546: LD_INT 22
29548: PUSH
29549: LD_INT 7
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 21
29558: PUSH
29559: LD_INT 1
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PPUSH
29570: CALL_OW 69
29574: PUSH
29575: LD_INT 6
29577: LESS
29578: IFFALSE 30029
29580: GO 29582
29582: DISABLE
29583: LD_INT 0
29585: PPUSH
29586: PPUSH
// begin MC_Kill ( 1 ) ;
29587: LD_INT 1
29589: PPUSH
29590: CALL 33924 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29594: LD_INT 7
29596: PPUSH
29597: LD_INT 1
29599: PPUSH
29600: LD_INT 1
29602: PPUSH
29603: LD_INT 1
29605: PPUSH
29606: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29610: LD_ADDR_VAR 0 1
29614: PUSH
29615: LD_INT 22
29617: PUSH
29618: LD_INT 7
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 26
29627: PUSH
29628: LD_INT 1
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PPUSH
29639: CALL_OW 69
29643: PUSH
29644: LD_EXP 71
29648: DIFF
29649: ST_TO_ADDR
// if tmp then
29650: LD_VAR 0 1
29654: IFFALSE 29672
// tmp := tmp [ 1 ] else
29656: LD_ADDR_VAR 0 1
29660: PUSH
29661: LD_VAR 0 1
29665: PUSH
29666: LD_INT 1
29668: ARRAY
29669: ST_TO_ADDR
29670: GO 29708
// begin uc_side := 7 ;
29672: LD_ADDR_OWVAR 20
29676: PUSH
29677: LD_INT 7
29679: ST_TO_ADDR
// uc_nation := 1 ;
29680: LD_ADDR_OWVAR 21
29684: PUSH
29685: LD_INT 1
29687: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29688: LD_INT 1
29690: PPUSH
29691: LD_INT 8
29693: PPUSH
29694: CALL_OW 384
// tmp := CreateHuman ;
29698: LD_ADDR_VAR 0 1
29702: PUSH
29703: CALL_OW 44
29707: ST_TO_ADDR
// end ; DialogueOn ;
29708: CALL_OW 6
// if IsOK ( Roth ) then
29712: LD_EXP 71
29716: PPUSH
29717: CALL_OW 302
29721: IFFALSE 29735
// Say ( JMM , DAb-JMM-1 ) ;
29723: LD_EXP 36
29727: PPUSH
29728: LD_STRING DAb-JMM-1
29730: PPUSH
29731: CALL_OW 88
// if IsOK ( Roth ) then
29735: LD_EXP 71
29739: PPUSH
29740: CALL_OW 302
29744: IFFALSE 29768
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29746: LD_EXP 71
29750: PPUSH
29751: LD_STRING DSurrenderAlliance-Roth-1
29753: PPUSH
29754: CALL_OW 88
// RothCaptured := true ;
29758: LD_ADDR_EXP 33
29762: PUSH
29763: LD_INT 1
29765: ST_TO_ADDR
// end else
29766: GO 29780
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29768: LD_VAR 0 1
29772: PPUSH
29773: LD_STRING DSurrenderAlliance-Sci1-1
29775: PPUSH
29776: CALL_OW 88
// DialogueOff ;
29780: CALL_OW 7
// allianceDestroyed := true ;
29784: LD_ADDR_EXP 23
29788: PUSH
29789: LD_INT 1
29791: ST_TO_ADDR
// if trueAmericans then
29792: LD_EXP 35
29796: IFFALSE 29872
// begin if trueAmericans = 1 then
29798: LD_EXP 35
29802: PUSH
29803: LD_INT 1
29805: EQUAL
29806: IFFALSE 29822
// Say ( JMM , DAb-JMM-1a ) else
29808: LD_EXP 36
29812: PPUSH
29813: LD_STRING DAb-JMM-1a
29815: PPUSH
29816: CALL_OW 88
29820: GO 29834
// Say ( JMM , DAb-JMM-1b ) ;
29822: LD_EXP 36
29826: PPUSH
29827: LD_STRING DAb-JMM-1b
29829: PPUSH
29830: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29834: LD_EXP 35
29838: PPUSH
29839: CALL_OW 87
// for i in trueAmericans do
29843: LD_ADDR_VAR 0 2
29847: PUSH
29848: LD_EXP 35
29852: PUSH
29853: FOR_IN
29854: IFFALSE 29870
// SetSide ( i , 1 ) ;
29856: LD_VAR 0 2
29860: PPUSH
29861: LD_INT 1
29863: PPUSH
29864: CALL_OW 235
29868: GO 29853
29870: POP
29871: POP
// end ; repeat wait ( 0 0$1 ) ;
29872: LD_INT 35
29874: PPUSH
29875: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29879: LD_ADDR_VAR 0 2
29883: PUSH
29884: LD_INT 22
29886: PUSH
29887: LD_INT 7
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 21
29896: PUSH
29897: LD_INT 1
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PPUSH
29908: CALL_OW 69
29912: PUSH
29913: FOR_IN
29914: IFFALSE 29996
// begin if IsInUnit ( i ) then
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL_OW 310
29925: IFFALSE 29936
// ComExitBuilding ( i ) ;
29927: LD_VAR 0 2
29931: PPUSH
29932: CALL_OW 122
// if IsDriver ( i ) then
29936: LD_VAR 0 2
29940: PPUSH
29941: CALL 102985 0 1
29945: IFFALSE 29956
// ComExitVehicle ( i ) ;
29947: LD_VAR 0 2
29951: PPUSH
29952: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29956: LD_VAR 0 2
29960: PPUSH
29961: LD_INT 26
29963: PPUSH
29964: CALL_OW 308
29968: NOT
29969: IFFALSE 29985
// AddComMoveToArea ( i , allianceEscapeArea ) else
29971: LD_VAR 0 2
29975: PPUSH
29976: LD_INT 26
29978: PPUSH
29979: CALL_OW 173
29983: GO 29994
// RemoveUnit ( i ) ;
29985: LD_VAR 0 2
29989: PPUSH
29990: CALL_OW 64
// end ;
29994: GO 29913
29996: POP
29997: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29998: LD_INT 22
30000: PUSH
30001: LD_INT 7
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 21
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PPUSH
30022: CALL_OW 69
30026: NOT
30027: IFFALSE 29872
// end ;
30029: PPOPN 2
30031: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30032: LD_INT 0
30034: PPUSH
30035: PPUSH
// if not unit then
30036: LD_VAR 0 1
30040: NOT
30041: IFFALSE 30045
// exit ;
30043: GO 31543
// DoNotAttack ( 7 , unit ) ;
30045: LD_INT 7
30047: PPUSH
30048: LD_VAR 0 1
30052: PPUSH
30053: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30057: LD_VAR 0 1
30061: PPUSH
30062: LD_INT 260
30064: PPUSH
30065: LD_INT 235
30067: PPUSH
30068: LD_INT 3
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: CALL_OW 483
// SetSide ( unit , 4 ) ;
30078: LD_VAR 0 1
30082: PPUSH
30083: LD_INT 4
30085: PPUSH
30086: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30090: LD_ADDR_EXP 34
30094: PUSH
30095: LD_EXP 34
30099: PUSH
30100: LD_INT 1
30102: PLUS
30103: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30104: LD_INT 70
30106: PPUSH
30107: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30111: LD_INT 260
30113: PPUSH
30114: LD_INT 235
30116: PPUSH
30117: LD_INT 1
30119: PPUSH
30120: LD_INT 8
30122: NEG
30123: PPUSH
30124: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30128: LD_VAR 0 1
30132: PPUSH
30133: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30137: LD_VAR 0 1
30141: PPUSH
30142: LD_EXP 71
30146: PPUSH
30147: CALL_OW 119
// DialogueOn ;
30151: CALL_OW 6
// case unit of JMM :
30155: LD_VAR 0 1
30159: PUSH
30160: LD_EXP 36
30164: DOUBLE
30165: EQUAL
30166: IFTRUE 30170
30168: GO 30185
30170: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30171: LD_EXP 36
30175: PPUSH
30176: LD_STRING DA1-JMM-1
30178: PPUSH
30179: CALL_OW 91
30183: GO 30627
30185: LD_EXP 37
30189: DOUBLE
30190: EQUAL
30191: IFTRUE 30195
30193: GO 30210
30195: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30196: LD_EXP 37
30200: PPUSH
30201: LD_STRING DA1-Joan-1
30203: PPUSH
30204: CALL_OW 91
30208: GO 30627
30210: LD_EXP 39
30214: DOUBLE
30215: EQUAL
30216: IFTRUE 30220
30218: GO 30235
30220: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30221: LD_EXP 39
30225: PPUSH
30226: LD_STRING DA1-Lisa-1
30228: PPUSH
30229: CALL_OW 91
30233: GO 30627
30235: LD_EXP 40
30239: DOUBLE
30240: EQUAL
30241: IFTRUE 30245
30243: GO 30260
30245: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30246: LD_EXP 40
30250: PPUSH
30251: LD_STRING DA1-Don-1
30253: PPUSH
30254: CALL_OW 91
30258: GO 30627
30260: LD_EXP 47
30264: DOUBLE
30265: EQUAL
30266: IFTRUE 30270
30268: GO 30285
30270: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30271: LD_EXP 47
30275: PPUSH
30276: LD_STRING DA1-Corn-1
30278: PPUSH
30279: CALL_OW 91
30283: GO 30627
30285: LD_EXP 43
30289: DOUBLE
30290: EQUAL
30291: IFTRUE 30295
30293: GO 30310
30295: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30296: LD_EXP 43
30300: PPUSH
30301: LD_STRING DA1-Den-1
30303: PPUSH
30304: CALL_OW 91
30308: GO 30627
30310: LD_EXP 41
30314: DOUBLE
30315: EQUAL
30316: IFTRUE 30320
30318: GO 30335
30320: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30321: LD_EXP 41
30325: PPUSH
30326: LD_STRING DA1-Bobby-1
30328: PPUSH
30329: CALL_OW 91
30333: GO 30627
30335: LD_EXP 45
30339: DOUBLE
30340: EQUAL
30341: IFTRUE 30345
30343: GO 30360
30345: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30346: LD_EXP 45
30350: PPUSH
30351: LD_STRING DA1-Glad-1
30353: PPUSH
30354: CALL_OW 91
30358: GO 30627
30360: LD_EXP 42
30364: DOUBLE
30365: EQUAL
30366: IFTRUE 30370
30368: GO 30385
30370: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30371: LD_EXP 42
30375: PPUSH
30376: LD_STRING DA1-Cyrus-1
30378: PPUSH
30379: CALL_OW 91
30383: GO 30627
30385: LD_EXP 38
30389: DOUBLE
30390: EQUAL
30391: IFTRUE 30395
30393: GO 30410
30395: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30396: LD_EXP 38
30400: PPUSH
30401: LD_STRING DA1-Huck-1
30403: PPUSH
30404: CALL_OW 91
30408: GO 30627
30410: LD_EXP 52
30414: DOUBLE
30415: EQUAL
30416: IFTRUE 30420
30418: GO 30435
30420: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30421: LD_EXP 52
30425: PPUSH
30426: LD_STRING DA1-Huck-1
30428: PPUSH
30429: CALL_OW 91
30433: GO 30627
30435: LD_EXP 44
30439: DOUBLE
30440: EQUAL
30441: IFTRUE 30445
30443: GO 30460
30445: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30446: LD_EXP 44
30450: PPUSH
30451: LD_STRING DA1-Brown-1
30453: PPUSH
30454: CALL_OW 91
30458: GO 30627
30460: LD_EXP 48
30464: DOUBLE
30465: EQUAL
30466: IFTRUE 30470
30468: GO 30485
30470: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30471: LD_EXP 48
30475: PPUSH
30476: LD_STRING DA1-Gary-1
30478: PPUSH
30479: CALL_OW 91
30483: GO 30627
30485: LD_EXP 51
30489: DOUBLE
30490: EQUAL
30491: IFTRUE 30495
30493: GO 30510
30495: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30496: LD_EXP 51
30500: PPUSH
30501: LD_STRING DA1-Con-1
30503: PPUSH
30504: CALL_OW 91
30508: GO 30627
30510: LD_EXP 57
30514: DOUBLE
30515: EQUAL
30516: IFTRUE 30520
30518: GO 30535
30520: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30521: LD_EXP 57
30525: PPUSH
30526: LD_STRING DA1-Kurt-1
30528: PPUSH
30529: CALL_OW 91
30533: GO 30627
30535: LD_EXP 50
30539: DOUBLE
30540: EQUAL
30541: IFTRUE 30545
30543: GO 30560
30545: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30546: LD_EXP 50
30550: PPUSH
30551: LD_STRING DA1-Yam-1
30553: PPUSH
30554: CALL_OW 91
30558: GO 30627
30560: LD_EXP 49
30564: DOUBLE
30565: EQUAL
30566: IFTRUE 30570
30568: GO 30585
30570: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30571: LD_EXP 49
30575: PPUSH
30576: LD_STRING DA1-Frank-1
30578: PPUSH
30579: CALL_OW 91
30583: GO 30627
30585: POP
// begin if GetSex ( unit ) = sex_male then
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 258
30595: PUSH
30596: LD_INT 1
30598: EQUAL
30599: IFFALSE 30615
// ForceSay ( unit , DA1-Sol1-1 ) else
30601: LD_VAR 0 1
30605: PPUSH
30606: LD_STRING DA1-Sol1-1
30608: PPUSH
30609: CALL_OW 91
30613: GO 30627
// ForceSay ( unit , DA1-FSol1-1 ) ;
30615: LD_VAR 0 1
30619: PPUSH
30620: LD_STRING DA1-FSol1-1
30622: PPUSH
30623: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30627: LD_EXP 71
30631: PPUSH
30632: LD_STRING DA-Roth-1
30634: PPUSH
30635: CALL_OW 88
// if capturedUnit = 1 then
30639: LD_EXP 34
30643: PUSH
30644: LD_INT 1
30646: EQUAL
30647: IFFALSE 30675
// begin Say ( Simms , DA-Sim-1 ) ;
30649: LD_EXP 72
30653: PPUSH
30654: LD_STRING DA-Sim-1
30656: PPUSH
30657: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30661: LD_EXP 71
30665: PPUSH
30666: LD_STRING DA-Roth-2
30668: PPUSH
30669: CALL_OW 88
// end else
30673: GO 30687
// Say ( Simms , DA-Sim-2 ) ;
30675: LD_EXP 72
30679: PPUSH
30680: LD_STRING DA-Sim-2
30682: PPUSH
30683: CALL_OW 88
// case unit of JMM :
30687: LD_VAR 0 1
30691: PUSH
30692: LD_EXP 36
30696: DOUBLE
30697: EQUAL
30698: IFTRUE 30702
30700: GO 30717
30702: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30703: LD_EXP 36
30707: PPUSH
30708: LD_STRING DA1-JMM-1a
30710: PPUSH
30711: CALL_OW 91
30715: GO 31224
30717: LD_EXP 37
30721: DOUBLE
30722: EQUAL
30723: IFTRUE 30727
30725: GO 30742
30727: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30728: LD_EXP 37
30732: PPUSH
30733: LD_STRING DA1-Joan-1a
30735: PPUSH
30736: CALL_OW 91
30740: GO 31224
30742: LD_EXP 39
30746: DOUBLE
30747: EQUAL
30748: IFTRUE 30752
30750: GO 30767
30752: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30753: LD_EXP 39
30757: PPUSH
30758: LD_STRING DA1-Lisa-1a
30760: PPUSH
30761: CALL_OW 91
30765: GO 31224
30767: LD_EXP 40
30771: DOUBLE
30772: EQUAL
30773: IFTRUE 30777
30775: GO 30792
30777: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30778: LD_EXP 40
30782: PPUSH
30783: LD_STRING DA1-Don-1a
30785: PPUSH
30786: CALL_OW 91
30790: GO 31224
30792: LD_EXP 47
30796: DOUBLE
30797: EQUAL
30798: IFTRUE 30802
30800: GO 30817
30802: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30803: LD_EXP 47
30807: PPUSH
30808: LD_STRING DA1-Corn-1a
30810: PPUSH
30811: CALL_OW 91
30815: GO 31224
30817: LD_EXP 43
30821: DOUBLE
30822: EQUAL
30823: IFTRUE 30827
30825: GO 30842
30827: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30828: LD_EXP 43
30832: PPUSH
30833: LD_STRING DA1-Den-1a
30835: PPUSH
30836: CALL_OW 91
30840: GO 31224
30842: LD_EXP 41
30846: DOUBLE
30847: EQUAL
30848: IFTRUE 30852
30850: GO 30867
30852: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30853: LD_EXP 41
30857: PPUSH
30858: LD_STRING DA1-Bobby-1a
30860: PPUSH
30861: CALL_OW 91
30865: GO 31224
30867: LD_EXP 45
30871: DOUBLE
30872: EQUAL
30873: IFTRUE 30877
30875: GO 30892
30877: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30878: LD_EXP 45
30882: PPUSH
30883: LD_STRING DA1-Glad-1a
30885: PPUSH
30886: CALL_OW 91
30890: GO 31224
30892: LD_EXP 42
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30902
30900: GO 30917
30902: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30903: LD_EXP 42
30907: PPUSH
30908: LD_STRING DA1-Cyrus-1a
30910: PPUSH
30911: CALL_OW 91
30915: GO 31224
30917: LD_EXP 38
30921: DOUBLE
30922: EQUAL
30923: IFTRUE 30927
30925: GO 30942
30927: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30928: LD_EXP 38
30932: PPUSH
30933: LD_STRING DA1-Huck-1a
30935: PPUSH
30936: CALL_OW 91
30940: GO 31224
30942: LD_EXP 52
30946: DOUBLE
30947: EQUAL
30948: IFTRUE 30952
30950: GO 30967
30952: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30953: LD_EXP 52
30957: PPUSH
30958: LD_STRING DA1-Huck-1a
30960: PPUSH
30961: CALL_OW 91
30965: GO 31224
30967: LD_EXP 44
30971: DOUBLE
30972: EQUAL
30973: IFTRUE 30977
30975: GO 30992
30977: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30978: LD_EXP 44
30982: PPUSH
30983: LD_STRING DA1-Brown-1a
30985: PPUSH
30986: CALL_OW 91
30990: GO 31224
30992: LD_EXP 48
30996: DOUBLE
30997: EQUAL
30998: IFTRUE 31002
31000: GO 31017
31002: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31003: LD_EXP 48
31007: PPUSH
31008: LD_STRING DA1-Gary-1a
31010: PPUSH
31011: CALL_OW 91
31015: GO 31224
31017: LD_EXP 51
31021: DOUBLE
31022: EQUAL
31023: IFTRUE 31027
31025: GO 31042
31027: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31028: LD_EXP 51
31032: PPUSH
31033: LD_STRING DA1-Con-1a
31035: PPUSH
31036: CALL_OW 91
31040: GO 31224
31042: LD_EXP 57
31046: DOUBLE
31047: EQUAL
31048: IFTRUE 31052
31050: GO 31067
31052: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31053: LD_EXP 57
31057: PPUSH
31058: LD_STRING DA1-Kurt-1a
31060: PPUSH
31061: CALL_OW 91
31065: GO 31224
31067: LD_EXP 50
31071: DOUBLE
31072: EQUAL
31073: IFTRUE 31077
31075: GO 31092
31077: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31078: LD_EXP 50
31082: PPUSH
31083: LD_STRING DA1-Yam-1a
31085: PPUSH
31086: CALL_OW 91
31090: GO 31224
31092: LD_EXP 49
31096: DOUBLE
31097: EQUAL
31098: IFTRUE 31102
31100: GO 31117
31102: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31103: LD_EXP 49
31107: PPUSH
31108: LD_STRING DA1-Frank-1a
31110: PPUSH
31111: CALL_OW 91
31115: GO 31224
31117: POP
// begin join := rand ( 0 , 1 ) ;
31118: LD_ADDR_VAR 0 3
31122: PUSH
31123: LD_INT 0
31125: PPUSH
31126: LD_INT 1
31128: PPUSH
31129: CALL_OW 12
31133: ST_TO_ADDR
// if join then
31134: LD_VAR 0 3
31138: IFFALSE 31183
// begin if GetSex ( unit ) = sex_male then
31140: LD_VAR 0 1
31144: PPUSH
31145: CALL_OW 258
31149: PUSH
31150: LD_INT 1
31152: EQUAL
31153: IFFALSE 31169
// ForceSay ( unit , DA1-Sol1-1b ) else
31155: LD_VAR 0 1
31159: PPUSH
31160: LD_STRING DA1-Sol1-1b
31162: PPUSH
31163: CALL_OW 91
31167: GO 31181
// ForceSay ( unit , DA1-FSol1-1b ) ;
31169: LD_VAR 0 1
31173: PPUSH
31174: LD_STRING DA1-FSol1-1b
31176: PPUSH
31177: CALL_OW 91
// end else
31181: GO 31224
// begin if GetSex ( unit ) = sex_male then
31183: LD_VAR 0 1
31187: PPUSH
31188: CALL_OW 258
31192: PUSH
31193: LD_INT 1
31195: EQUAL
31196: IFFALSE 31212
// ForceSay ( unit , DA1-Sol1-1a ) else
31198: LD_VAR 0 1
31202: PPUSH
31203: LD_STRING DA1-Sol1-1a
31205: PPUSH
31206: CALL_OW 91
31210: GO 31224
// ForceSay ( unit , DA1-FSol1-1a ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_STRING DA1-FSol1-1a
31219: PPUSH
31220: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31224: LD_VAR 0 1
31228: PUSH
31229: LD_EXP 36
31233: EQUAL
31234: IFFALSE 31245
// begin YouLost ( JMMCaptured ) ;
31236: LD_STRING JMMCaptured
31238: PPUSH
31239: CALL_OW 104
// exit ;
31243: GO 31543
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31245: LD_VAR 0 1
31249: PUSH
31250: LD_EXP 40
31254: PUSH
31255: LD_EXP 43
31259: PUSH
31260: LD_EXP 41
31264: PUSH
31265: LD_EXP 38
31269: PUSH
31270: LD_EXP 52
31274: PUSH
31275: LD_EXP 44
31279: PUSH
31280: LD_EXP 50
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: IN
31294: PUSH
31295: LD_VAR 0 3
31299: OR
31300: IFFALSE 31399
// begin Say ( Roth , DA-Roth-3 ) ;
31302: LD_EXP 71
31306: PPUSH
31307: LD_STRING DA-Roth-3
31309: PPUSH
31310: CALL_OW 88
// SetSide ( unit , 7 ) ;
31314: LD_VAR 0 1
31318: PPUSH
31319: LD_INT 7
31321: PPUSH
31322: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31326: LD_ADDR_EXP 99
31330: PUSH
31331: LD_EXP 99
31335: PPUSH
31336: LD_INT 1
31338: PPUSH
31339: LD_EXP 99
31343: PUSH
31344: LD_INT 1
31346: ARRAY
31347: PUSH
31348: LD_VAR 0 1
31352: ADD
31353: PPUSH
31354: CALL_OW 1
31358: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31359: LD_INT 260
31361: PPUSH
31362: LD_INT 235
31364: PPUSH
31365: LD_INT 1
31367: PPUSH
31368: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31372: LD_VAR 0 1
31376: PPUSH
31377: LD_INT 1000
31379: PPUSH
31380: CALL_OW 234
// DialogueOff ;
31384: CALL_OW 7
// ComFree ( unit ) ;
31388: LD_VAR 0 1
31392: PPUSH
31393: CALL_OW 139
// end else
31397: GO 31480
// begin Say ( Roth , DA-Roth-3a ) ;
31399: LD_EXP 71
31403: PPUSH
31404: LD_STRING DA-Roth-3a
31406: PPUSH
31407: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31411: LD_ADDR_EXP 35
31415: PUSH
31416: LD_EXP 35
31420: PUSH
31421: LD_VAR 0 1
31425: ADD
31426: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31427: LD_INT 260
31429: PPUSH
31430: LD_INT 235
31432: PPUSH
31433: LD_INT 1
31435: PPUSH
31436: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31440: LD_VAR 0 1
31444: PPUSH
31445: LD_INT 1000
31447: PPUSH
31448: CALL_OW 234
// DialogueOff ;
31452: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31456: LD_VAR 0 1
31460: PPUSH
31461: LD_INT 272
31463: PPUSH
31464: LD_INT 254
31466: PPUSH
31467: CALL_OW 111
// AddComHold ( unit ) ;
31471: LD_VAR 0 1
31475: PPUSH
31476: CALL_OW 200
// end ; if capturedUnit = 1 then
31480: LD_EXP 34
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31543
// begin DialogueOn ;
31490: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31494: LD_EXP 36
31498: PPUSH
31499: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31503: LD_EXP 36
31507: PPUSH
31508: LD_STRING DAa-JMM-1
31510: PPUSH
31511: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31515: LD_EXP 36
31519: PPUSH
31520: LD_STRING DAa-JMM-1a
31522: PPUSH
31523: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31527: LD_EXP 36
31531: PPUSH
31532: LD_STRING DAa-JMM-1b
31534: PPUSH
31535: CALL_OW 88
// DialogueOff ;
31539: CALL_OW 7
// end ; end ;
31543: LD_VAR 0 2
31547: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31548: LD_EXP 15
31552: PUSH
31553: LD_INT 13
31555: GREATEREQUAL
31556: PUSH
31557: LD_INT 22
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 21
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PPUSH
31581: CALL_OW 69
31585: PUSH
31586: LD_INT 0
31588: EQUAL
31589: AND
31590: PUSH
31591: LD_INT 22
31593: PUSH
31594: LD_INT 2
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 21
31603: PUSH
31604: LD_INT 2
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 50
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: PPUSH
31622: CALL_OW 69
31626: PUSH
31627: LD_INT 0
31629: EQUAL
31630: AND
31631: PUSH
31632: LD_EXP 21
31636: AND
31637: PUSH
31638: LD_EXP 22
31642: AND
31643: PUSH
31644: LD_EXP 23
31648: AND
31649: IFFALSE 32130
31651: GO 31653
31653: DISABLE
// begin DialogueOn ;
31654: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31658: LD_EXP 36
31662: PPUSH
31663: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31667: LD_EXP 36
31671: PPUSH
31672: LD_STRING D20-JMM-1
31674: PPUSH
31675: CALL_OW 88
// if IsOK ( Joan ) then
31679: LD_EXP 37
31683: PPUSH
31684: CALL_OW 302
31688: IFFALSE 31702
// Say ( Joan , D20-Joan-1 ) ;
31690: LD_EXP 37
31694: PPUSH
31695: LD_STRING D20-Joan-1
31697: PPUSH
31698: CALL_OW 88
// if IsOk ( Lisa ) then
31702: LD_EXP 39
31706: PPUSH
31707: CALL_OW 302
31711: IFFALSE 31725
// Say ( Lisa , D20-Lisa-1 ) ;
31713: LD_EXP 39
31717: PPUSH
31718: LD_STRING D20-Lisa-1
31720: PPUSH
31721: CALL_OW 88
// if IsOk ( Donaldson ) then
31725: LD_EXP 40
31729: PPUSH
31730: CALL_OW 302
31734: IFFALSE 31748
// Say ( Donaldson , D20-Don-1 ) ;
31736: LD_EXP 40
31740: PPUSH
31741: LD_STRING D20-Don-1
31743: PPUSH
31744: CALL_OW 88
// if IsOK ( Cornel ) then
31748: LD_EXP 47
31752: PPUSH
31753: CALL_OW 302
31757: IFFALSE 31771
// Say ( Cornel , D20-Corn-1 ) ;
31759: LD_EXP 47
31763: PPUSH
31764: LD_STRING D20-Corn-1
31766: PPUSH
31767: CALL_OW 88
// if IsOk ( Denis ) then
31771: LD_EXP 43
31775: PPUSH
31776: CALL_OW 302
31780: IFFALSE 31794
// Say ( Denis , D20-Den-1 ) ;
31782: LD_EXP 43
31786: PPUSH
31787: LD_STRING D20-Den-1
31789: PPUSH
31790: CALL_OW 88
// if IsOk ( Bobby ) then
31794: LD_EXP 41
31798: PPUSH
31799: CALL_OW 302
31803: IFFALSE 31817
// Say ( Bobby , D20-Bobby-1 ) ;
31805: LD_EXP 41
31809: PPUSH
31810: LD_STRING D20-Bobby-1
31812: PPUSH
31813: CALL_OW 88
// if IsOk ( Gladstone ) then
31817: LD_EXP 45
31821: PPUSH
31822: CALL_OW 302
31826: IFFALSE 31840
// Say ( Gladstone , D20-Glad-1 ) ;
31828: LD_EXP 45
31832: PPUSH
31833: LD_STRING D20-Glad-1
31835: PPUSH
31836: CALL_OW 88
// if IsOk ( Cyrus ) then
31840: LD_EXP 42
31844: PPUSH
31845: CALL_OW 302
31849: IFFALSE 31863
// Say ( Cyrus , D20-Cyrus-1 ) ;
31851: LD_EXP 42
31855: PPUSH
31856: LD_STRING D20-Cyrus-1
31858: PPUSH
31859: CALL_OW 88
// if IsOk ( Stevens ) then
31863: LD_EXP 38
31867: PPUSH
31868: CALL_OW 302
31872: IFFALSE 31886
// Say ( Stevens , D20-Huck-1 ) ;
31874: LD_EXP 38
31878: PPUSH
31879: LD_STRING D20-Huck-1
31881: PPUSH
31882: CALL_OW 88
// if IsOk ( Brown ) then
31886: LD_EXP 44
31890: PPUSH
31891: CALL_OW 302
31895: IFFALSE 31909
// Say ( Brown , D20-Brown-1 ) ;
31897: LD_EXP 44
31901: PPUSH
31902: LD_STRING D20-Brown-1
31904: PPUSH
31905: CALL_OW 88
// if IsOk ( Gary ) then
31909: LD_EXP 48
31913: PPUSH
31914: CALL_OW 302
31918: IFFALSE 31932
// Say ( Gary , D20-Gary-1 ) ;
31920: LD_EXP 48
31924: PPUSH
31925: LD_STRING D20-Gary-1
31927: PPUSH
31928: CALL_OW 88
// if IsOk ( Connie ) then
31932: LD_EXP 51
31936: PPUSH
31937: CALL_OW 302
31941: IFFALSE 31955
// Say ( Connie , D20-Con-1 ) ;
31943: LD_EXP 51
31947: PPUSH
31948: LD_STRING D20-Con-1
31950: PPUSH
31951: CALL_OW 88
// if IsOk ( Kurt ) then
31955: LD_EXP 57
31959: PPUSH
31960: CALL_OW 302
31964: IFFALSE 31978
// Say ( Kurt , D20-Kurt-1 ) ;
31966: LD_EXP 57
31970: PPUSH
31971: LD_STRING D20-Kurt-1
31973: PPUSH
31974: CALL_OW 88
// if IsOk ( Kikuchi ) then
31978: LD_EXP 50
31982: PPUSH
31983: CALL_OW 302
31987: IFFALSE 32001
// Say ( Kikuchi , D20-Yam-1 ) ;
31989: LD_EXP 50
31993: PPUSH
31994: LD_STRING D20-Yam-1
31996: PPUSH
31997: CALL_OW 88
// if IsOk ( Frank ) then
32001: LD_EXP 49
32005: PPUSH
32006: CALL_OW 302
32010: IFFALSE 32024
// Say ( Frank , D20-Frank-1 ) ;
32012: LD_EXP 49
32016: PPUSH
32017: LD_STRING D20-Frank-1
32019: PPUSH
32020: CALL_OW 88
// DialogueOff ;
32024: CALL_OW 7
// if RothCaptured then
32028: LD_EXP 33
32032: IFFALSE 32046
// AddMedal ( Roth , 1 ) else
32034: LD_STRING Roth
32036: PPUSH
32037: LD_INT 1
32039: PPUSH
32040: CALL_OW 101
32044: GO 32057
// AddMedal ( Roth , - 1 ) ;
32046: LD_STRING Roth
32048: PPUSH
32049: LD_INT 1
32051: NEG
32052: PPUSH
32053: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32057: LD_EXP 27
32061: IFFALSE 32075
// AddMedal ( Project , 1 ) else
32063: LD_STRING Project
32065: PPUSH
32066: LD_INT 1
32068: PPUSH
32069: CALL_OW 101
32073: GO 32086
// AddMedal ( Project , - 1 ) ;
32075: LD_STRING Project
32077: PPUSH
32078: LD_INT 1
32080: NEG
32081: PPUSH
32082: CALL_OW 101
// if lostCounter = 0 then
32086: LD_EXP 32
32090: PUSH
32091: LD_INT 0
32093: EQUAL
32094: IFFALSE 32108
// AddMedal ( NoLosses , 1 ) else
32096: LD_STRING NoLosses
32098: PPUSH
32099: LD_INT 1
32101: PPUSH
32102: CALL_OW 101
32106: GO 32119
// AddMedal ( NoLosses , - 1 ) ;
32108: LD_STRING NoLosses
32110: PPUSH
32111: LD_INT 1
32113: NEG
32114: PPUSH
32115: CALL_OW 101
// GiveMedals ( MAIN ) ;
32119: LD_STRING MAIN
32121: PPUSH
32122: CALL_OW 102
// YouWin ;
32126: CALL_OW 103
// end ; end_of_file
32130: END
// export function CustomEvent ( event ) ; begin
32131: LD_INT 0
32133: PPUSH
// end ;
32134: LD_VAR 0 2
32138: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32139: LD_VAR 0 1
32143: PUSH
32144: LD_INT 1
32146: EQUAL
32147: PUSH
32148: LD_VAR 0 2
32152: PUSH
32153: LD_INT 4
32155: EQUAL
32156: AND
32157: PUSH
32158: LD_EXP 55
32162: PPUSH
32163: CALL_OW 300
32167: AND
32168: IFFALSE 32184
// begin wait ( 0 0$2 ) ;
32170: LD_INT 70
32172: PPUSH
32173: CALL_OW 67
// YouLost ( Dismissed ) ;
32177: LD_STRING Dismissed
32179: PPUSH
32180: CALL_OW 104
// end ; end ;
32184: PPOPN 2
32186: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32187: LD_VAR 0 2
32191: PPUSH
32192: LD_VAR 0 3
32196: PPUSH
32197: LD_INT 18
32199: PPUSH
32200: CALL_OW 309
32204: IFFALSE 32213
// YouLost ( Motherlode3 ) ;
32206: LD_STRING Motherlode3
32208: PPUSH
32209: CALL_OW 104
// end ;
32213: PPOPN 3
32215: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32216: LD_EXP 27
32220: NOT
32221: IFFALSE 32231
// behemothDone := true ;
32223: LD_ADDR_EXP 28
32227: PUSH
32228: LD_INT 1
32230: ST_TO_ADDR
// end ;
32231: PPOPN 1
32233: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32234: LD_VAR 0 1
32238: PPUSH
32239: CALL_OW 255
32243: PUSH
32244: LD_INT 1
32246: EQUAL
32247: PUSH
32248: LD_EXP 30
32252: AND
32253: PUSH
32254: LD_INT 22
32256: PUSH
32257: LD_INT 3
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 34
32266: PUSH
32267: LD_INT 48
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PPUSH
32278: CALL_OW 69
32282: AND
32283: PUSH
32284: LD_INT 22
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 34
32296: PUSH
32297: LD_INT 8
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PPUSH
32308: CALL_OW 69
32312: NOT
32313: AND
32314: IFFALSE 32366
// begin wait ( 0 0$5 ) ;
32316: LD_INT 175
32318: PPUSH
32319: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32323: LD_INT 22
32325: PUSH
32326: LD_INT 3
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 34
32335: PUSH
32336: LD_INT 48
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PPUSH
32347: CALL_OW 69
32351: PUSH
32352: LD_INT 1
32354: ARRAY
32355: PPUSH
32356: LD_INT 60
32358: PPUSH
32359: LD_INT 95
32361: PPUSH
32362: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32366: LD_VAR 0 2
32370: PPUSH
32371: LD_VAR 0 3
32375: PPUSH
32376: LD_INT 18
32378: PPUSH
32379: CALL_OW 309
32383: IFFALSE 32443
// begin if GetSide ( unit ) = 1 then
32385: LD_VAR 0 1
32389: PPUSH
32390: CALL_OW 255
32394: PUSH
32395: LD_INT 1
32397: EQUAL
32398: IFFALSE 32414
// begin wait ( 0 0$6 ) ;
32400: LD_INT 210
32402: PPUSH
32403: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32407: LD_STRING Motherlode2
32409: PPUSH
32410: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32414: LD_VAR 0 1
32418: PPUSH
32419: CALL_OW 255
32423: PUSH
32424: LD_INT 8
32426: EQUAL
32427: IFFALSE 32443
// begin wait ( 0 0$6 ) ;
32429: LD_INT 210
32431: PPUSH
32432: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32436: LD_STRING Motherlode1
32438: PPUSH
32439: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 255
32452: PUSH
32453: LD_INT 3
32455: EQUAL
32456: IFFALSE 32477
// begin wait ( 0 0$5 ) ;
32458: LD_INT 175
32460: PPUSH
32461: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32465: LD_EXP 61
32469: PPUSH
32470: LD_STRING D18-Pla-1
32472: PPUSH
32473: CALL_OW 94
// end ; end ;
32477: PPOPN 3
32479: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32480: LD_VAR 0 1
32484: PUSH
32485: LD_EXP 70
32489: IN
32490: IFFALSE 32510
// begin behemothBuilders := behemothBuilders diff un ;
32492: LD_ADDR_EXP 70
32496: PUSH
32497: LD_EXP 70
32501: PUSH
32502: LD_VAR 0 1
32506: DIFF
32507: ST_TO_ADDR
// exit ;
32508: GO 32608
// end ; if un = JMM then
32510: LD_VAR 0 1
32514: PUSH
32515: LD_EXP 36
32519: EQUAL
32520: IFFALSE 32531
// begin YouLost ( JMM ) ;
32522: LD_STRING JMM
32524: PPUSH
32525: CALL_OW 104
// exit ;
32529: GO 32608
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32531: LD_VAR 0 1
32535: PUSH
32536: LD_INT 22
32538: PUSH
32539: LD_INT 1
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 3
32548: PUSH
32549: LD_INT 25
32551: PUSH
32552: LD_INT 16
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 25
32561: PUSH
32562: LD_INT 12
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: LIST
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PPUSH
32578: CALL_OW 69
32582: IN
32583: IFFALSE 32599
// lostCounter := lostCounter + 1 ;
32585: LD_ADDR_EXP 32
32589: PUSH
32590: LD_EXP 32
32594: PUSH
32595: LD_INT 1
32597: PLUS
32598: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32599: LD_VAR 0 1
32603: PPUSH
32604: CALL 60239 0 1
// end ;
32608: PPOPN 1
32610: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32611: LD_VAR 0 1
32615: PPUSH
32616: LD_VAR 0 2
32620: PPUSH
32621: CALL 62294 0 2
// end ;
32625: PPOPN 2
32627: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32628: LD_VAR 0 1
32632: PPUSH
32633: CALL 61362 0 1
// end ;
32637: PPOPN 1
32639: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32640: LD_VAR 0 1
32644: PUSH
32645: LD_INT 22
32647: PUSH
32648: LD_INT 8
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 30
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 23
32667: PUSH
32668: LD_INT 3
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: LIST
32679: PPUSH
32680: CALL_OW 69
32684: IN
32685: IFFALSE 32712
// begin ComUpgrade ( building ) ;
32687: LD_VAR 0 1
32691: PPUSH
32692: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32696: LD_EXP 58
32700: PPUSH
32701: LD_VAR 0 1
32705: PPUSH
32706: CALL 72488 0 2
// exit ;
32710: GO 32721
// end ; MCE_BuildingComplete ( building ) ;
32712: LD_VAR 0 1
32716: PPUSH
32717: CALL 61603 0 1
// end ;
32721: PPOPN 1
32723: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32724: LD_VAR 0 1
32728: PPUSH
32729: LD_VAR 0 2
32733: PPUSH
32734: CALL 59935 0 2
// end ;
32738: PPOPN 2
32740: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32741: LD_VAR 0 1
32745: PPUSH
32746: LD_VAR 0 2
32750: PPUSH
32751: LD_VAR 0 3
32755: PPUSH
32756: LD_VAR 0 4
32760: PPUSH
32761: LD_VAR 0 5
32765: PPUSH
32766: CALL 59555 0 5
// end ;
32770: PPOPN 5
32772: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32773: LD_VAR 0 1
32777: PPUSH
32778: LD_VAR 0 2
32782: PPUSH
32783: CALL 59151 0 2
// end ;
32787: PPOPN 2
32789: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32790: LD_VAR 0 1
32794: PPUSH
32795: LD_VAR 0 2
32799: PPUSH
32800: LD_VAR 0 3
32804: PPUSH
32805: LD_VAR 0 4
32809: PPUSH
32810: CALL 58989 0 4
// end ;
32814: PPOPN 4
32816: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32817: LD_VAR 0 1
32821: PPUSH
32822: LD_VAR 0 2
32826: PPUSH
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL 58764 0 3
// end ;
32836: PPOPN 3
32838: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32839: LD_VAR 0 1
32843: PPUSH
32844: LD_VAR 0 2
32848: PPUSH
32849: CALL 58649 0 2
// end ;
32853: PPOPN 2
32855: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32856: LD_VAR 0 1
32860: PPUSH
32861: LD_VAR 0 2
32865: PPUSH
32866: CALL 62555 0 2
// end ;
32870: PPOPN 2
32872: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32873: LD_VAR 0 1
32877: PPUSH
32878: CALL_OW 255
32882: PUSH
32883: LD_INT 4
32885: EQUAL
32886: PUSH
32887: LD_VAR 0 1
32891: PUSH
32892: LD_EXP 18
32896: PUSH
32897: LD_INT 1
32899: ARRAY
32900: IN
32901: AND
32902: PUSH
32903: LD_EXP 19
32907: AND
32908: IFFALSE 32927
// begin ComMoveXY ( driver , 61 , 93 ) ;
32910: LD_VAR 0 1
32914: PPUSH
32915: LD_INT 61
32917: PPUSH
32918: LD_INT 93
32920: PPUSH
32921: CALL_OW 111
// exit ;
32925: GO 32951
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32927: LD_VAR 0 1
32931: PPUSH
32932: LD_VAR 0 2
32936: PPUSH
32937: LD_VAR 0 3
32941: PPUSH
32942: LD_VAR 0 4
32946: PPUSH
32947: CALL 62771 0 4
// end ;
32951: PPOPN 4
32953: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: LD_VAR 0 2
32963: PPUSH
32964: CALL 58458 0 2
// end ; end_of_file
32968: PPOPN 2
32970: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32971: LD_EXP 15
32975: PUSH
32976: LD_INT 2
32978: EQUAL
32979: IFFALSE 33458
32981: GO 32983
32983: DISABLE
32984: LD_INT 0
32986: PPUSH
// begin time := 0 0$40 ;
32987: LD_ADDR_VAR 0 1
32991: PUSH
32992: LD_INT 1400
32994: ST_TO_ADDR
// repeat wait ( time ) ;
32995: LD_VAR 0 1
32999: PPUSH
33000: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33004: LD_INT 1
33006: PPUSH
33007: LD_INT 5
33009: PPUSH
33010: CALL_OW 12
33014: PPUSH
33015: LD_INT 106
33017: PPUSH
33018: LD_INT 150
33020: PPUSH
33021: LD_INT 19
33023: PPUSH
33024: LD_INT 1
33026: PPUSH
33027: CALL_OW 56
// time := time + 0 0$9 ;
33031: LD_ADDR_VAR 0 1
33035: PUSH
33036: LD_VAR 0 1
33040: PUSH
33041: LD_INT 315
33043: PLUS
33044: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33045: LD_INT 455
33047: PPUSH
33048: LD_INT 840
33050: PPUSH
33051: CALL_OW 12
33055: PPUSH
33056: CALL_OW 67
// if Prob ( 50 ) then
33060: LD_INT 50
33062: PPUSH
33063: CALL_OW 13
33067: IFFALSE 33096
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33069: LD_INT 1
33071: PPUSH
33072: LD_INT 5
33074: PPUSH
33075: CALL_OW 12
33079: PPUSH
33080: LD_INT 62
33082: PPUSH
33083: LD_INT 108
33085: PPUSH
33086: LD_INT 10
33088: PPUSH
33089: LD_INT 1
33091: PPUSH
33092: CALL_OW 56
// until missionStage > 4 ;
33096: LD_EXP 15
33100: PUSH
33101: LD_INT 4
33103: GREATER
33104: IFFALSE 32995
// repeat wait ( 0 0$1 ) ;
33106: LD_INT 35
33108: PPUSH
33109: CALL_OW 67
// until missionStage = 6 ;
33113: LD_EXP 15
33117: PUSH
33118: LD_INT 6
33120: EQUAL
33121: IFFALSE 33106
// time := 0 0$50 ;
33123: LD_ADDR_VAR 0 1
33127: PUSH
33128: LD_INT 1750
33130: ST_TO_ADDR
// repeat wait ( time ) ;
33131: LD_VAR 0 1
33135: PPUSH
33136: CALL_OW 67
// if Prob ( 50 ) then
33140: LD_INT 50
33142: PPUSH
33143: CALL_OW 13
33147: IFFALSE 33176
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33149: LD_INT 1
33151: PPUSH
33152: LD_INT 5
33154: PPUSH
33155: CALL_OW 12
33159: PPUSH
33160: LD_INT 106
33162: PPUSH
33163: LD_INT 89
33165: PPUSH
33166: LD_INT 45
33168: PPUSH
33169: LD_INT 1
33171: PPUSH
33172: CALL_OW 56
// time := time + 0 0$3 ;
33176: LD_ADDR_VAR 0 1
33180: PUSH
33181: LD_VAR 0 1
33185: PUSH
33186: LD_INT 105
33188: PLUS
33189: ST_TO_ADDR
// if Prob ( 30 ) then
33190: LD_INT 30
33192: PPUSH
33193: CALL_OW 13
33197: IFFALSE 33243
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33199: LD_INT 525
33201: PPUSH
33202: LD_INT 735
33204: PPUSH
33205: CALL_OW 12
33209: PPUSH
33210: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33214: LD_INT 1
33216: PPUSH
33217: LD_INT 5
33219: PPUSH
33220: CALL_OW 12
33224: PPUSH
33225: LD_INT 21
33227: PPUSH
33228: LD_INT 26
33230: PPUSH
33231: LD_INT 12
33233: PPUSH
33234: LD_INT 1
33236: PPUSH
33237: CALL_OW 56
// end else
33241: GO 33279
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33243: LD_INT 700
33245: PPUSH
33246: LD_INT 1225
33248: PPUSH
33249: CALL_OW 12
33253: PPUSH
33254: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33258: LD_INT 1
33260: PPUSH
33261: LD_INT 5
33263: PPUSH
33264: CALL_OW 12
33268: PPUSH
33269: LD_INT 16
33271: PPUSH
33272: LD_INT 1
33274: PPUSH
33275: CALL_OW 55
// end ; if Prob ( 50 ) then
33279: LD_INT 50
33281: PPUSH
33282: CALL_OW 13
33286: IFFALSE 33332
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33288: LD_INT 700
33290: PPUSH
33291: LD_INT 1050
33293: PPUSH
33294: CALL_OW 12
33298: PPUSH
33299: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33303: LD_INT 1
33305: PPUSH
33306: LD_INT 5
33308: PPUSH
33309: CALL_OW 12
33313: PPUSH
33314: LD_INT 181
33316: PPUSH
33317: LD_INT 218
33319: PPUSH
33320: LD_INT 16
33322: PPUSH
33323: LD_INT 1
33325: PPUSH
33326: CALL_OW 56
// end else
33330: GO 33368
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33332: LD_INT 350
33334: PPUSH
33335: LD_INT 525
33337: PPUSH
33338: CALL_OW 12
33342: PPUSH
33343: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33347: LD_INT 1
33349: PPUSH
33350: LD_INT 5
33352: PPUSH
33353: CALL_OW 12
33357: PPUSH
33358: LD_INT 15
33360: PPUSH
33361: LD_INT 1
33363: PPUSH
33364: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33368: LD_INT 45
33370: PUSH
33371: LD_INT 32
33373: PUSH
33374: LD_INT 25
33376: PUSH
33377: EMPTY
33378: LIST
33379: LIST
33380: LIST
33381: PUSH
33382: LD_OWVAR 67
33386: ARRAY
33387: PPUSH
33388: CALL_OW 13
33392: IFFALSE 33436
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33394: LD_INT 525
33396: PPUSH
33397: LD_INT 875
33399: PPUSH
33400: CALL_OW 12
33404: PPUSH
33405: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33409: LD_INT 1
33411: PPUSH
33412: LD_INT 5
33414: PPUSH
33415: CALL_OW 12
33419: PPUSH
33420: LD_INT 103
33422: PPUSH
33423: LD_INT 140
33425: PPUSH
33426: LD_INT 20
33428: PPUSH
33429: LD_INT 1
33431: PPUSH
33432: CALL_OW 56
// end ; if time > 2 2$20 then
33436: LD_VAR 0 1
33440: PUSH
33441: LD_INT 4900
33443: GREATER
33444: IFFALSE 33454
// time := 0 0$50 ;
33446: LD_ADDR_VAR 0 1
33450: PUSH
33451: LD_INT 1750
33453: ST_TO_ADDR
// until false ;
33454: LD_INT 0
33456: IFFALSE 33131
// end ; end_of_file
33458: PPOPN 1
33460: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33461: LD_EXP 13
33465: PUSH
33466: LD_EXP 15
33470: PUSH
33471: LD_INT 6
33473: GREATEREQUAL
33474: AND
33475: IFFALSE 33512
33477: GO 33479
33479: DISABLE
// begin enable ;
33480: ENABLE
// missionTime := missionTime + 0 0$1 ;
33481: LD_ADDR_EXP 14
33485: PUSH
33486: LD_EXP 14
33490: PUSH
33491: LD_INT 35
33493: PLUS
33494: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33495: LD_ADDR_OWVAR 47
33499: PUSH
33500: LD_STRING #Am15-1
33502: PUSH
33503: LD_EXP 14
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: ST_TO_ADDR
// end ; end_of_file
33512: END
// export function InitNature ; begin
33513: LD_INT 0
33515: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33516: LD_INT 3
33518: PPUSH
33519: LD_INT 3
33521: PPUSH
33522: LD_INT 2
33524: PPUSH
33525: LD_INT 1
33527: PPUSH
33528: LD_INT 1
33530: PPUSH
33531: LD_INT 0
33533: PPUSH
33534: LD_INT 0
33536: PPUSH
33537: LD_INT 20
33539: PPUSH
33540: LD_INT 0
33542: PPUSH
33543: CALL 97329 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33547: LD_INT 2
33549: PPUSH
33550: LD_INT 1
33552: PPUSH
33553: LD_INT 1
33555: PPUSH
33556: LD_INT 1
33558: PPUSH
33559: LD_INT 1
33561: PPUSH
33562: LD_INT 0
33564: PPUSH
33565: LD_INT 0
33567: PPUSH
33568: LD_INT 21
33570: PPUSH
33571: LD_INT 0
33573: PPUSH
33574: CALL 97329 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33578: LD_INT 4
33580: PPUSH
33581: LD_INT 1
33583: PPUSH
33584: LD_INT 2
33586: PPUSH
33587: LD_INT 4
33589: PPUSH
33590: LD_INT 2
33592: PPUSH
33593: LD_INT 1
33595: PPUSH
33596: LD_INT 0
33598: PPUSH
33599: LD_INT 22
33601: PPUSH
33602: LD_INT 0
33604: PPUSH
33605: CALL 97329 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33609: LD_INT 0
33611: PPUSH
33612: LD_INT 0
33614: PPUSH
33615: LD_INT 0
33617: PPUSH
33618: LD_INT 0
33620: PPUSH
33621: LD_INT 0
33623: PPUSH
33624: LD_INT 0
33626: PPUSH
33627: LD_INT 9
33629: PPUSH
33630: LD_INT 0
33632: PPUSH
33633: LD_INT 23
33635: PPUSH
33636: CALL 97329 0 9
// end ; end_of_file
33640: LD_VAR 0 1
33644: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33645: GO 33647
33647: DISABLE
// begin ru_radar := 98 ;
33648: LD_ADDR_EXP 92
33652: PUSH
33653: LD_INT 98
33655: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33656: LD_ADDR_EXP 93
33660: PUSH
33661: LD_INT 89
33663: ST_TO_ADDR
// us_hack := 99 ;
33664: LD_ADDR_EXP 94
33668: PUSH
33669: LD_INT 99
33671: ST_TO_ADDR
// us_artillery := 97 ;
33672: LD_ADDR_EXP 95
33676: PUSH
33677: LD_INT 97
33679: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33680: LD_ADDR_EXP 96
33684: PUSH
33685: LD_INT 91
33687: ST_TO_ADDR
// end ; end_of_file
33688: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33689: LD_INT 0
33691: PPUSH
33692: PPUSH
// skirmish := false ;
33693: LD_ADDR_EXP 97
33697: PUSH
33698: LD_INT 0
33700: ST_TO_ADDR
// debug_mc := false ;
33701: LD_ADDR_EXP 98
33705: PUSH
33706: LD_INT 0
33708: ST_TO_ADDR
// mc_bases := [ ] ;
33709: LD_ADDR_EXP 99
33713: PUSH
33714: EMPTY
33715: ST_TO_ADDR
// mc_sides := [ ] ;
33716: LD_ADDR_EXP 125
33720: PUSH
33721: EMPTY
33722: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33723: LD_ADDR_EXP 100
33727: PUSH
33728: EMPTY
33729: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33730: LD_ADDR_EXP 101
33734: PUSH
33735: EMPTY
33736: ST_TO_ADDR
// mc_need_heal := [ ] ;
33737: LD_ADDR_EXP 102
33741: PUSH
33742: EMPTY
33743: ST_TO_ADDR
// mc_healers := [ ] ;
33744: LD_ADDR_EXP 103
33748: PUSH
33749: EMPTY
33750: ST_TO_ADDR
// mc_build_list := [ ] ;
33751: LD_ADDR_EXP 104
33755: PUSH
33756: EMPTY
33757: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33758: LD_ADDR_EXP 131
33762: PUSH
33763: EMPTY
33764: ST_TO_ADDR
// mc_builders := [ ] ;
33765: LD_ADDR_EXP 105
33769: PUSH
33770: EMPTY
33771: ST_TO_ADDR
// mc_construct_list := [ ] ;
33772: LD_ADDR_EXP 106
33776: PUSH
33777: EMPTY
33778: ST_TO_ADDR
// mc_turret_list := [ ] ;
33779: LD_ADDR_EXP 107
33783: PUSH
33784: EMPTY
33785: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33786: LD_ADDR_EXP 108
33790: PUSH
33791: EMPTY
33792: ST_TO_ADDR
// mc_miners := [ ] ;
33793: LD_ADDR_EXP 113
33797: PUSH
33798: EMPTY
33799: ST_TO_ADDR
// mc_mines := [ ] ;
33800: LD_ADDR_EXP 112
33804: PUSH
33805: EMPTY
33806: ST_TO_ADDR
// mc_minefields := [ ] ;
33807: LD_ADDR_EXP 114
33811: PUSH
33812: EMPTY
33813: ST_TO_ADDR
// mc_crates := [ ] ;
33814: LD_ADDR_EXP 115
33818: PUSH
33819: EMPTY
33820: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33821: LD_ADDR_EXP 116
33825: PUSH
33826: EMPTY
33827: ST_TO_ADDR
// mc_crates_area := [ ] ;
33828: LD_ADDR_EXP 117
33832: PUSH
33833: EMPTY
33834: ST_TO_ADDR
// mc_vehicles := [ ] ;
33835: LD_ADDR_EXP 118
33839: PUSH
33840: EMPTY
33841: ST_TO_ADDR
// mc_attack := [ ] ;
33842: LD_ADDR_EXP 119
33846: PUSH
33847: EMPTY
33848: ST_TO_ADDR
// mc_produce := [ ] ;
33849: LD_ADDR_EXP 120
33853: PUSH
33854: EMPTY
33855: ST_TO_ADDR
// mc_defender := [ ] ;
33856: LD_ADDR_EXP 121
33860: PUSH
33861: EMPTY
33862: ST_TO_ADDR
// mc_parking := [ ] ;
33863: LD_ADDR_EXP 123
33867: PUSH
33868: EMPTY
33869: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33870: LD_ADDR_EXP 109
33874: PUSH
33875: EMPTY
33876: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33877: LD_ADDR_EXP 111
33881: PUSH
33882: EMPTY
33883: ST_TO_ADDR
// mc_scan := [ ] ;
33884: LD_ADDR_EXP 122
33888: PUSH
33889: EMPTY
33890: ST_TO_ADDR
// mc_scan_area := [ ] ;
33891: LD_ADDR_EXP 124
33895: PUSH
33896: EMPTY
33897: ST_TO_ADDR
// mc_tech := [ ] ;
33898: LD_ADDR_EXP 126
33902: PUSH
33903: EMPTY
33904: ST_TO_ADDR
// mc_class := [ ] ;
33905: LD_ADDR_EXP 140
33909: PUSH
33910: EMPTY
33911: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33912: LD_ADDR_EXP 141
33916: PUSH
33917: EMPTY
33918: ST_TO_ADDR
// end ;
33919: LD_VAR 0 1
33923: RET
// export function MC_Kill ( base ) ; begin
33924: LD_INT 0
33926: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33927: LD_ADDR_EXP 99
33931: PUSH
33932: LD_EXP 99
33936: PPUSH
33937: LD_VAR 0 1
33941: PPUSH
33942: EMPTY
33943: PPUSH
33944: CALL_OW 1
33948: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33949: LD_ADDR_EXP 100
33953: PUSH
33954: LD_EXP 100
33958: PPUSH
33959: LD_VAR 0 1
33963: PPUSH
33964: EMPTY
33965: PPUSH
33966: CALL_OW 1
33970: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33971: LD_ADDR_EXP 101
33975: PUSH
33976: LD_EXP 101
33980: PPUSH
33981: LD_VAR 0 1
33985: PPUSH
33986: EMPTY
33987: PPUSH
33988: CALL_OW 1
33992: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
33993: LD_ADDR_EXP 102
33997: PUSH
33998: LD_EXP 102
34002: PPUSH
34003: LD_VAR 0 1
34007: PPUSH
34008: EMPTY
34009: PPUSH
34010: CALL_OW 1
34014: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34015: LD_ADDR_EXP 103
34019: PUSH
34020: LD_EXP 103
34024: PPUSH
34025: LD_VAR 0 1
34029: PPUSH
34030: EMPTY
34031: PPUSH
34032: CALL_OW 1
34036: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34037: LD_ADDR_EXP 104
34041: PUSH
34042: LD_EXP 104
34046: PPUSH
34047: LD_VAR 0 1
34051: PPUSH
34052: EMPTY
34053: PPUSH
34054: CALL_OW 1
34058: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34059: LD_ADDR_EXP 105
34063: PUSH
34064: LD_EXP 105
34068: PPUSH
34069: LD_VAR 0 1
34073: PPUSH
34074: EMPTY
34075: PPUSH
34076: CALL_OW 1
34080: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34081: LD_ADDR_EXP 106
34085: PUSH
34086: LD_EXP 106
34090: PPUSH
34091: LD_VAR 0 1
34095: PPUSH
34096: EMPTY
34097: PPUSH
34098: CALL_OW 1
34102: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34103: LD_ADDR_EXP 107
34107: PUSH
34108: LD_EXP 107
34112: PPUSH
34113: LD_VAR 0 1
34117: PPUSH
34118: EMPTY
34119: PPUSH
34120: CALL_OW 1
34124: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34125: LD_ADDR_EXP 108
34129: PUSH
34130: LD_EXP 108
34134: PPUSH
34135: LD_VAR 0 1
34139: PPUSH
34140: EMPTY
34141: PPUSH
34142: CALL_OW 1
34146: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34147: LD_ADDR_EXP 109
34151: PUSH
34152: LD_EXP 109
34156: PPUSH
34157: LD_VAR 0 1
34161: PPUSH
34162: EMPTY
34163: PPUSH
34164: CALL_OW 1
34168: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34169: LD_ADDR_EXP 110
34173: PUSH
34174: LD_EXP 110
34178: PPUSH
34179: LD_VAR 0 1
34183: PPUSH
34184: LD_INT 0
34186: PPUSH
34187: CALL_OW 1
34191: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34192: LD_ADDR_EXP 111
34196: PUSH
34197: LD_EXP 111
34201: PPUSH
34202: LD_VAR 0 1
34206: PPUSH
34207: EMPTY
34208: PPUSH
34209: CALL_OW 1
34213: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34214: LD_ADDR_EXP 112
34218: PUSH
34219: LD_EXP 112
34223: PPUSH
34224: LD_VAR 0 1
34228: PPUSH
34229: EMPTY
34230: PPUSH
34231: CALL_OW 1
34235: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34236: LD_ADDR_EXP 113
34240: PUSH
34241: LD_EXP 113
34245: PPUSH
34246: LD_VAR 0 1
34250: PPUSH
34251: EMPTY
34252: PPUSH
34253: CALL_OW 1
34257: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34258: LD_ADDR_EXP 114
34262: PUSH
34263: LD_EXP 114
34267: PPUSH
34268: LD_VAR 0 1
34272: PPUSH
34273: EMPTY
34274: PPUSH
34275: CALL_OW 1
34279: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34280: LD_ADDR_EXP 115
34284: PUSH
34285: LD_EXP 115
34289: PPUSH
34290: LD_VAR 0 1
34294: PPUSH
34295: EMPTY
34296: PPUSH
34297: CALL_OW 1
34301: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34302: LD_ADDR_EXP 116
34306: PUSH
34307: LD_EXP 116
34311: PPUSH
34312: LD_VAR 0 1
34316: PPUSH
34317: EMPTY
34318: PPUSH
34319: CALL_OW 1
34323: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34324: LD_ADDR_EXP 117
34328: PUSH
34329: LD_EXP 117
34333: PPUSH
34334: LD_VAR 0 1
34338: PPUSH
34339: EMPTY
34340: PPUSH
34341: CALL_OW 1
34345: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34346: LD_ADDR_EXP 118
34350: PUSH
34351: LD_EXP 118
34355: PPUSH
34356: LD_VAR 0 1
34360: PPUSH
34361: EMPTY
34362: PPUSH
34363: CALL_OW 1
34367: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34368: LD_ADDR_EXP 119
34372: PUSH
34373: LD_EXP 119
34377: PPUSH
34378: LD_VAR 0 1
34382: PPUSH
34383: EMPTY
34384: PPUSH
34385: CALL_OW 1
34389: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34390: LD_ADDR_EXP 120
34394: PUSH
34395: LD_EXP 120
34399: PPUSH
34400: LD_VAR 0 1
34404: PPUSH
34405: EMPTY
34406: PPUSH
34407: CALL_OW 1
34411: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34412: LD_ADDR_EXP 121
34416: PUSH
34417: LD_EXP 121
34421: PPUSH
34422: LD_VAR 0 1
34426: PPUSH
34427: EMPTY
34428: PPUSH
34429: CALL_OW 1
34433: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34434: LD_ADDR_EXP 122
34438: PUSH
34439: LD_EXP 122
34443: PPUSH
34444: LD_VAR 0 1
34448: PPUSH
34449: EMPTY
34450: PPUSH
34451: CALL_OW 1
34455: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34456: LD_ADDR_EXP 123
34460: PUSH
34461: LD_EXP 123
34465: PPUSH
34466: LD_VAR 0 1
34470: PPUSH
34471: EMPTY
34472: PPUSH
34473: CALL_OW 1
34477: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34478: LD_ADDR_EXP 124
34482: PUSH
34483: LD_EXP 124
34487: PPUSH
34488: LD_VAR 0 1
34492: PPUSH
34493: EMPTY
34494: PPUSH
34495: CALL_OW 1
34499: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34500: LD_ADDR_EXP 126
34504: PUSH
34505: LD_EXP 126
34509: PPUSH
34510: LD_VAR 0 1
34514: PPUSH
34515: EMPTY
34516: PPUSH
34517: CALL_OW 1
34521: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34522: LD_ADDR_EXP 128
34526: PUSH
34527: LD_EXP 128
34531: PPUSH
34532: LD_VAR 0 1
34536: PPUSH
34537: EMPTY
34538: PPUSH
34539: CALL_OW 1
34543: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34544: LD_ADDR_EXP 129
34548: PUSH
34549: LD_EXP 129
34553: PPUSH
34554: LD_VAR 0 1
34558: PPUSH
34559: EMPTY
34560: PPUSH
34561: CALL_OW 1
34565: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34566: LD_ADDR_EXP 130
34570: PUSH
34571: LD_EXP 130
34575: PPUSH
34576: LD_VAR 0 1
34580: PPUSH
34581: EMPTY
34582: PPUSH
34583: CALL_OW 1
34587: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34588: LD_ADDR_EXP 131
34592: PUSH
34593: LD_EXP 131
34597: PPUSH
34598: LD_VAR 0 1
34602: PPUSH
34603: EMPTY
34604: PPUSH
34605: CALL_OW 1
34609: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34610: LD_ADDR_EXP 132
34614: PUSH
34615: LD_EXP 132
34619: PPUSH
34620: LD_VAR 0 1
34624: PPUSH
34625: EMPTY
34626: PPUSH
34627: CALL_OW 1
34631: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34632: LD_ADDR_EXP 133
34636: PUSH
34637: LD_EXP 133
34641: PPUSH
34642: LD_VAR 0 1
34646: PPUSH
34647: EMPTY
34648: PPUSH
34649: CALL_OW 1
34653: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34654: LD_ADDR_EXP 134
34658: PUSH
34659: LD_EXP 134
34663: PPUSH
34664: LD_VAR 0 1
34668: PPUSH
34669: EMPTY
34670: PPUSH
34671: CALL_OW 1
34675: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34676: LD_ADDR_EXP 135
34680: PUSH
34681: LD_EXP 135
34685: PPUSH
34686: LD_VAR 0 1
34690: PPUSH
34691: EMPTY
34692: PPUSH
34693: CALL_OW 1
34697: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34698: LD_ADDR_EXP 136
34702: PUSH
34703: LD_EXP 136
34707: PPUSH
34708: LD_VAR 0 1
34712: PPUSH
34713: EMPTY
34714: PPUSH
34715: CALL_OW 1
34719: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34720: LD_ADDR_EXP 137
34724: PUSH
34725: LD_EXP 137
34729: PPUSH
34730: LD_VAR 0 1
34734: PPUSH
34735: EMPTY
34736: PPUSH
34737: CALL_OW 1
34741: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34742: LD_ADDR_EXP 138
34746: PUSH
34747: LD_EXP 138
34751: PPUSH
34752: LD_VAR 0 1
34756: PPUSH
34757: EMPTY
34758: PPUSH
34759: CALL_OW 1
34763: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34764: LD_ADDR_EXP 139
34768: PUSH
34769: LD_EXP 139
34773: PPUSH
34774: LD_VAR 0 1
34778: PPUSH
34779: EMPTY
34780: PPUSH
34781: CALL_OW 1
34785: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34786: LD_ADDR_EXP 140
34790: PUSH
34791: LD_EXP 140
34795: PPUSH
34796: LD_VAR 0 1
34800: PPUSH
34801: EMPTY
34802: PPUSH
34803: CALL_OW 1
34807: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34808: LD_ADDR_EXP 141
34812: PUSH
34813: LD_EXP 141
34817: PPUSH
34818: LD_VAR 0 1
34822: PPUSH
34823: LD_INT 0
34825: PPUSH
34826: CALL_OW 1
34830: ST_TO_ADDR
// end ;
34831: LD_VAR 0 2
34835: RET
// export function MC_Add ( side , units ) ; var base ; begin
34836: LD_INT 0
34838: PPUSH
34839: PPUSH
// base := mc_bases + 1 ;
34840: LD_ADDR_VAR 0 4
34844: PUSH
34845: LD_EXP 99
34849: PUSH
34850: LD_INT 1
34852: PLUS
34853: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34854: LD_ADDR_EXP 125
34858: PUSH
34859: LD_EXP 125
34863: PPUSH
34864: LD_VAR 0 4
34868: PPUSH
34869: LD_VAR 0 1
34873: PPUSH
34874: CALL_OW 1
34878: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34879: LD_ADDR_EXP 99
34883: PUSH
34884: LD_EXP 99
34888: PPUSH
34889: LD_VAR 0 4
34893: PPUSH
34894: LD_VAR 0 2
34898: PPUSH
34899: CALL_OW 1
34903: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34904: LD_ADDR_EXP 100
34908: PUSH
34909: LD_EXP 100
34913: PPUSH
34914: LD_VAR 0 4
34918: PPUSH
34919: EMPTY
34920: PPUSH
34921: CALL_OW 1
34925: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34926: LD_ADDR_EXP 101
34930: PUSH
34931: LD_EXP 101
34935: PPUSH
34936: LD_VAR 0 4
34940: PPUSH
34941: EMPTY
34942: PPUSH
34943: CALL_OW 1
34947: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34948: LD_ADDR_EXP 102
34952: PUSH
34953: LD_EXP 102
34957: PPUSH
34958: LD_VAR 0 4
34962: PPUSH
34963: EMPTY
34964: PPUSH
34965: CALL_OW 1
34969: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34970: LD_ADDR_EXP 103
34974: PUSH
34975: LD_EXP 103
34979: PPUSH
34980: LD_VAR 0 4
34984: PPUSH
34985: EMPTY
34986: PPUSH
34987: CALL_OW 1
34991: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34992: LD_ADDR_EXP 104
34996: PUSH
34997: LD_EXP 104
35001: PPUSH
35002: LD_VAR 0 4
35006: PPUSH
35007: EMPTY
35008: PPUSH
35009: CALL_OW 1
35013: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35014: LD_ADDR_EXP 105
35018: PUSH
35019: LD_EXP 105
35023: PPUSH
35024: LD_VAR 0 4
35028: PPUSH
35029: EMPTY
35030: PPUSH
35031: CALL_OW 1
35035: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_EXP 106
35045: PPUSH
35046: LD_VAR 0 4
35050: PPUSH
35051: EMPTY
35052: PPUSH
35053: CALL_OW 1
35057: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35058: LD_ADDR_EXP 107
35062: PUSH
35063: LD_EXP 107
35067: PPUSH
35068: LD_VAR 0 4
35072: PPUSH
35073: EMPTY
35074: PPUSH
35075: CALL_OW 1
35079: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35080: LD_ADDR_EXP 108
35084: PUSH
35085: LD_EXP 108
35089: PPUSH
35090: LD_VAR 0 4
35094: PPUSH
35095: EMPTY
35096: PPUSH
35097: CALL_OW 1
35101: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35102: LD_ADDR_EXP 109
35106: PUSH
35107: LD_EXP 109
35111: PPUSH
35112: LD_VAR 0 4
35116: PPUSH
35117: EMPTY
35118: PPUSH
35119: CALL_OW 1
35123: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35124: LD_ADDR_EXP 110
35128: PUSH
35129: LD_EXP 110
35133: PPUSH
35134: LD_VAR 0 4
35138: PPUSH
35139: LD_INT 0
35141: PPUSH
35142: CALL_OW 1
35146: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35147: LD_ADDR_EXP 111
35151: PUSH
35152: LD_EXP 111
35156: PPUSH
35157: LD_VAR 0 4
35161: PPUSH
35162: EMPTY
35163: PPUSH
35164: CALL_OW 1
35168: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35169: LD_ADDR_EXP 112
35173: PUSH
35174: LD_EXP 112
35178: PPUSH
35179: LD_VAR 0 4
35183: PPUSH
35184: EMPTY
35185: PPUSH
35186: CALL_OW 1
35190: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35191: LD_ADDR_EXP 113
35195: PUSH
35196: LD_EXP 113
35200: PPUSH
35201: LD_VAR 0 4
35205: PPUSH
35206: EMPTY
35207: PPUSH
35208: CALL_OW 1
35212: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35213: LD_ADDR_EXP 114
35217: PUSH
35218: LD_EXP 114
35222: PPUSH
35223: LD_VAR 0 4
35227: PPUSH
35228: EMPTY
35229: PPUSH
35230: CALL_OW 1
35234: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35235: LD_ADDR_EXP 115
35239: PUSH
35240: LD_EXP 115
35244: PPUSH
35245: LD_VAR 0 4
35249: PPUSH
35250: EMPTY
35251: PPUSH
35252: CALL_OW 1
35256: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35257: LD_ADDR_EXP 116
35261: PUSH
35262: LD_EXP 116
35266: PPUSH
35267: LD_VAR 0 4
35271: PPUSH
35272: EMPTY
35273: PPUSH
35274: CALL_OW 1
35278: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35279: LD_ADDR_EXP 117
35283: PUSH
35284: LD_EXP 117
35288: PPUSH
35289: LD_VAR 0 4
35293: PPUSH
35294: EMPTY
35295: PPUSH
35296: CALL_OW 1
35300: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35301: LD_ADDR_EXP 118
35305: PUSH
35306: LD_EXP 118
35310: PPUSH
35311: LD_VAR 0 4
35315: PPUSH
35316: EMPTY
35317: PPUSH
35318: CALL_OW 1
35322: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35323: LD_ADDR_EXP 119
35327: PUSH
35328: LD_EXP 119
35332: PPUSH
35333: LD_VAR 0 4
35337: PPUSH
35338: EMPTY
35339: PPUSH
35340: CALL_OW 1
35344: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35345: LD_ADDR_EXP 120
35349: PUSH
35350: LD_EXP 120
35354: PPUSH
35355: LD_VAR 0 4
35359: PPUSH
35360: EMPTY
35361: PPUSH
35362: CALL_OW 1
35366: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35367: LD_ADDR_EXP 121
35371: PUSH
35372: LD_EXP 121
35376: PPUSH
35377: LD_VAR 0 4
35381: PPUSH
35382: EMPTY
35383: PPUSH
35384: CALL_OW 1
35388: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35389: LD_ADDR_EXP 122
35393: PUSH
35394: LD_EXP 122
35398: PPUSH
35399: LD_VAR 0 4
35403: PPUSH
35404: EMPTY
35405: PPUSH
35406: CALL_OW 1
35410: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35411: LD_ADDR_EXP 123
35415: PUSH
35416: LD_EXP 123
35420: PPUSH
35421: LD_VAR 0 4
35425: PPUSH
35426: EMPTY
35427: PPUSH
35428: CALL_OW 1
35432: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35433: LD_ADDR_EXP 124
35437: PUSH
35438: LD_EXP 124
35442: PPUSH
35443: LD_VAR 0 4
35447: PPUSH
35448: EMPTY
35449: PPUSH
35450: CALL_OW 1
35454: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35455: LD_ADDR_EXP 126
35459: PUSH
35460: LD_EXP 126
35464: PPUSH
35465: LD_VAR 0 4
35469: PPUSH
35470: EMPTY
35471: PPUSH
35472: CALL_OW 1
35476: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35477: LD_ADDR_EXP 128
35481: PUSH
35482: LD_EXP 128
35486: PPUSH
35487: LD_VAR 0 4
35491: PPUSH
35492: EMPTY
35493: PPUSH
35494: CALL_OW 1
35498: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35499: LD_ADDR_EXP 129
35503: PUSH
35504: LD_EXP 129
35508: PPUSH
35509: LD_VAR 0 4
35513: PPUSH
35514: EMPTY
35515: PPUSH
35516: CALL_OW 1
35520: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35521: LD_ADDR_EXP 130
35525: PUSH
35526: LD_EXP 130
35530: PPUSH
35531: LD_VAR 0 4
35535: PPUSH
35536: EMPTY
35537: PPUSH
35538: CALL_OW 1
35542: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35543: LD_ADDR_EXP 131
35547: PUSH
35548: LD_EXP 131
35552: PPUSH
35553: LD_VAR 0 4
35557: PPUSH
35558: EMPTY
35559: PPUSH
35560: CALL_OW 1
35564: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35565: LD_ADDR_EXP 132
35569: PUSH
35570: LD_EXP 132
35574: PPUSH
35575: LD_VAR 0 4
35579: PPUSH
35580: EMPTY
35581: PPUSH
35582: CALL_OW 1
35586: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35587: LD_ADDR_EXP 133
35591: PUSH
35592: LD_EXP 133
35596: PPUSH
35597: LD_VAR 0 4
35601: PPUSH
35602: EMPTY
35603: PPUSH
35604: CALL_OW 1
35608: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35609: LD_ADDR_EXP 134
35613: PUSH
35614: LD_EXP 134
35618: PPUSH
35619: LD_VAR 0 4
35623: PPUSH
35624: EMPTY
35625: PPUSH
35626: CALL_OW 1
35630: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35631: LD_ADDR_EXP 135
35635: PUSH
35636: LD_EXP 135
35640: PPUSH
35641: LD_VAR 0 4
35645: PPUSH
35646: EMPTY
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35653: LD_ADDR_EXP 136
35657: PUSH
35658: LD_EXP 136
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: EMPTY
35669: PPUSH
35670: CALL_OW 1
35674: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35675: LD_ADDR_EXP 137
35679: PUSH
35680: LD_EXP 137
35684: PPUSH
35685: LD_VAR 0 4
35689: PPUSH
35690: EMPTY
35691: PPUSH
35692: CALL_OW 1
35696: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35697: LD_ADDR_EXP 138
35701: PUSH
35702: LD_EXP 138
35706: PPUSH
35707: LD_VAR 0 4
35711: PPUSH
35712: EMPTY
35713: PPUSH
35714: CALL_OW 1
35718: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35719: LD_ADDR_EXP 139
35723: PUSH
35724: LD_EXP 139
35728: PPUSH
35729: LD_VAR 0 4
35733: PPUSH
35734: EMPTY
35735: PPUSH
35736: CALL_OW 1
35740: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35741: LD_ADDR_EXP 140
35745: PUSH
35746: LD_EXP 140
35750: PPUSH
35751: LD_VAR 0 4
35755: PPUSH
35756: EMPTY
35757: PPUSH
35758: CALL_OW 1
35762: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35763: LD_ADDR_EXP 141
35767: PUSH
35768: LD_EXP 141
35772: PPUSH
35773: LD_VAR 0 4
35777: PPUSH
35778: LD_INT 0
35780: PPUSH
35781: CALL_OW 1
35785: ST_TO_ADDR
// result := base ;
35786: LD_ADDR_VAR 0 3
35790: PUSH
35791: LD_VAR 0 4
35795: ST_TO_ADDR
// end ;
35796: LD_VAR 0 3
35800: RET
// export function MC_Start ( ) ; var i ; begin
35801: LD_INT 0
35803: PPUSH
35804: PPUSH
// for i = 1 to mc_bases do
35805: LD_ADDR_VAR 0 2
35809: PUSH
35810: DOUBLE
35811: LD_INT 1
35813: DEC
35814: ST_TO_ADDR
35815: LD_EXP 99
35819: PUSH
35820: FOR_TO
35821: IFFALSE 36898
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35823: LD_ADDR_EXP 99
35827: PUSH
35828: LD_EXP 99
35832: PPUSH
35833: LD_VAR 0 2
35837: PPUSH
35838: LD_EXP 99
35842: PUSH
35843: LD_VAR 0 2
35847: ARRAY
35848: PUSH
35849: LD_INT 0
35851: DIFF
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35858: LD_ADDR_EXP 100
35862: PUSH
35863: LD_EXP 100
35867: PPUSH
35868: LD_VAR 0 2
35872: PPUSH
35873: EMPTY
35874: PPUSH
35875: CALL_OW 1
35879: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35880: LD_ADDR_EXP 101
35884: PUSH
35885: LD_EXP 101
35889: PPUSH
35890: LD_VAR 0 2
35894: PPUSH
35895: EMPTY
35896: PPUSH
35897: CALL_OW 1
35901: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35902: LD_ADDR_EXP 102
35906: PUSH
35907: LD_EXP 102
35911: PPUSH
35912: LD_VAR 0 2
35916: PPUSH
35917: EMPTY
35918: PPUSH
35919: CALL_OW 1
35923: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
35924: LD_ADDR_EXP 103
35928: PUSH
35929: LD_EXP 103
35933: PPUSH
35934: LD_VAR 0 2
35938: PPUSH
35939: EMPTY
35940: PUSH
35941: EMPTY
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
35952: LD_ADDR_EXP 104
35956: PUSH
35957: LD_EXP 104
35961: PPUSH
35962: LD_VAR 0 2
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
35974: LD_ADDR_EXP 131
35978: PUSH
35979: LD_EXP 131
35983: PPUSH
35984: LD_VAR 0 2
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
35996: LD_ADDR_EXP 105
36000: PUSH
36001: LD_EXP 105
36005: PPUSH
36006: LD_VAR 0 2
36010: PPUSH
36011: EMPTY
36012: PPUSH
36013: CALL_OW 1
36017: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36018: LD_ADDR_EXP 106
36022: PUSH
36023: LD_EXP 106
36027: PPUSH
36028: LD_VAR 0 2
36032: PPUSH
36033: EMPTY
36034: PPUSH
36035: CALL_OW 1
36039: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36040: LD_ADDR_EXP 107
36044: PUSH
36045: LD_EXP 107
36049: PPUSH
36050: LD_VAR 0 2
36054: PPUSH
36055: LD_EXP 99
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: PPUSH
36066: LD_INT 2
36068: PUSH
36069: LD_INT 30
36071: PUSH
36072: LD_INT 32
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 30
36081: PUSH
36082: LD_INT 33
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: EMPTY
36090: LIST
36091: LIST
36092: LIST
36093: PPUSH
36094: CALL_OW 72
36098: PPUSH
36099: CALL_OW 1
36103: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36104: LD_ADDR_EXP 108
36108: PUSH
36109: LD_EXP 108
36113: PPUSH
36114: LD_VAR 0 2
36118: PPUSH
36119: LD_EXP 99
36123: PUSH
36124: LD_VAR 0 2
36128: ARRAY
36129: PPUSH
36130: LD_INT 2
36132: PUSH
36133: LD_INT 30
36135: PUSH
36136: LD_INT 32
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 30
36145: PUSH
36146: LD_INT 31
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 58
36160: PUSH
36161: EMPTY
36162: LIST
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PPUSH
36168: CALL_OW 72
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36178: LD_ADDR_EXP 109
36182: PUSH
36183: LD_EXP 109
36187: PPUSH
36188: LD_VAR 0 2
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36200: LD_ADDR_EXP 113
36204: PUSH
36205: LD_EXP 113
36209: PPUSH
36210: LD_VAR 0 2
36214: PPUSH
36215: EMPTY
36216: PPUSH
36217: CALL_OW 1
36221: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36222: LD_ADDR_EXP 112
36226: PUSH
36227: LD_EXP 112
36231: PPUSH
36232: LD_VAR 0 2
36236: PPUSH
36237: EMPTY
36238: PPUSH
36239: CALL_OW 1
36243: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36244: LD_ADDR_EXP 114
36248: PUSH
36249: LD_EXP 114
36253: PPUSH
36254: LD_VAR 0 2
36258: PPUSH
36259: EMPTY
36260: PPUSH
36261: CALL_OW 1
36265: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36266: LD_ADDR_EXP 115
36270: PUSH
36271: LD_EXP 115
36275: PPUSH
36276: LD_VAR 0 2
36280: PPUSH
36281: EMPTY
36282: PPUSH
36283: CALL_OW 1
36287: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36288: LD_ADDR_EXP 116
36292: PUSH
36293: LD_EXP 116
36297: PPUSH
36298: LD_VAR 0 2
36302: PPUSH
36303: EMPTY
36304: PPUSH
36305: CALL_OW 1
36309: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36310: LD_ADDR_EXP 117
36314: PUSH
36315: LD_EXP 117
36319: PPUSH
36320: LD_VAR 0 2
36324: PPUSH
36325: EMPTY
36326: PPUSH
36327: CALL_OW 1
36331: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36332: LD_ADDR_EXP 118
36336: PUSH
36337: LD_EXP 118
36341: PPUSH
36342: LD_VAR 0 2
36346: PPUSH
36347: EMPTY
36348: PPUSH
36349: CALL_OW 1
36353: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36354: LD_ADDR_EXP 119
36358: PUSH
36359: LD_EXP 119
36363: PPUSH
36364: LD_VAR 0 2
36368: PPUSH
36369: EMPTY
36370: PPUSH
36371: CALL_OW 1
36375: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36376: LD_ADDR_EXP 120
36380: PUSH
36381: LD_EXP 120
36385: PPUSH
36386: LD_VAR 0 2
36390: PPUSH
36391: EMPTY
36392: PPUSH
36393: CALL_OW 1
36397: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36398: LD_ADDR_EXP 121
36402: PUSH
36403: LD_EXP 121
36407: PPUSH
36408: LD_VAR 0 2
36412: PPUSH
36413: EMPTY
36414: PPUSH
36415: CALL_OW 1
36419: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36420: LD_ADDR_EXP 110
36424: PUSH
36425: LD_EXP 110
36429: PPUSH
36430: LD_VAR 0 2
36434: PPUSH
36435: LD_INT 0
36437: PPUSH
36438: CALL_OW 1
36442: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36443: LD_ADDR_EXP 123
36447: PUSH
36448: LD_EXP 123
36452: PPUSH
36453: LD_VAR 0 2
36457: PPUSH
36458: LD_INT 0
36460: PPUSH
36461: CALL_OW 1
36465: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36466: LD_ADDR_EXP 111
36470: PUSH
36471: LD_EXP 111
36475: PPUSH
36476: LD_VAR 0 2
36480: PPUSH
36481: EMPTY
36482: PPUSH
36483: CALL_OW 1
36487: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36488: LD_ADDR_EXP 122
36492: PUSH
36493: LD_EXP 122
36497: PPUSH
36498: LD_VAR 0 2
36502: PPUSH
36503: LD_INT 0
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36511: LD_ADDR_EXP 124
36515: PUSH
36516: LD_EXP 124
36520: PPUSH
36521: LD_VAR 0 2
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36533: LD_ADDR_EXP 127
36537: PUSH
36538: LD_EXP 127
36542: PPUSH
36543: LD_VAR 0 2
36547: PPUSH
36548: LD_INT 0
36550: PPUSH
36551: CALL_OW 1
36555: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36556: LD_ADDR_EXP 128
36560: PUSH
36561: LD_EXP 128
36565: PPUSH
36566: LD_VAR 0 2
36570: PPUSH
36571: EMPTY
36572: PPUSH
36573: CALL_OW 1
36577: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36578: LD_ADDR_EXP 129
36582: PUSH
36583: LD_EXP 129
36587: PPUSH
36588: LD_VAR 0 2
36592: PPUSH
36593: EMPTY
36594: PPUSH
36595: CALL_OW 1
36599: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36600: LD_ADDR_EXP 130
36604: PUSH
36605: LD_EXP 130
36609: PPUSH
36610: LD_VAR 0 2
36614: PPUSH
36615: EMPTY
36616: PPUSH
36617: CALL_OW 1
36621: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36622: LD_ADDR_EXP 132
36626: PUSH
36627: LD_EXP 132
36631: PPUSH
36632: LD_VAR 0 2
36636: PPUSH
36637: LD_EXP 99
36641: PUSH
36642: LD_VAR 0 2
36646: ARRAY
36647: PPUSH
36648: LD_INT 2
36650: PUSH
36651: LD_INT 30
36653: PUSH
36654: LD_INT 6
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 30
36663: PUSH
36664: LD_INT 7
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 30
36673: PUSH
36674: LD_INT 8
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: PPUSH
36687: CALL_OW 72
36691: PPUSH
36692: CALL_OW 1
36696: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36697: LD_ADDR_EXP 133
36701: PUSH
36702: LD_EXP 133
36706: PPUSH
36707: LD_VAR 0 2
36711: PPUSH
36712: EMPTY
36713: PPUSH
36714: CALL_OW 1
36718: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36719: LD_ADDR_EXP 134
36723: PUSH
36724: LD_EXP 134
36728: PPUSH
36729: LD_VAR 0 2
36733: PPUSH
36734: EMPTY
36735: PPUSH
36736: CALL_OW 1
36740: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36741: LD_ADDR_EXP 135
36745: PUSH
36746: LD_EXP 135
36750: PPUSH
36751: LD_VAR 0 2
36755: PPUSH
36756: EMPTY
36757: PPUSH
36758: CALL_OW 1
36762: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36763: LD_ADDR_EXP 136
36767: PUSH
36768: LD_EXP 136
36772: PPUSH
36773: LD_VAR 0 2
36777: PPUSH
36778: EMPTY
36779: PPUSH
36780: CALL_OW 1
36784: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36785: LD_ADDR_EXP 137
36789: PUSH
36790: LD_EXP 137
36794: PPUSH
36795: LD_VAR 0 2
36799: PPUSH
36800: EMPTY
36801: PPUSH
36802: CALL_OW 1
36806: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36807: LD_ADDR_EXP 138
36811: PUSH
36812: LD_EXP 138
36816: PPUSH
36817: LD_VAR 0 2
36821: PPUSH
36822: EMPTY
36823: PPUSH
36824: CALL_OW 1
36828: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36829: LD_ADDR_EXP 139
36833: PUSH
36834: LD_EXP 139
36838: PPUSH
36839: LD_VAR 0 2
36843: PPUSH
36844: EMPTY
36845: PPUSH
36846: CALL_OW 1
36850: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36851: LD_ADDR_EXP 140
36855: PUSH
36856: LD_EXP 140
36860: PPUSH
36861: LD_VAR 0 2
36865: PPUSH
36866: EMPTY
36867: PPUSH
36868: CALL_OW 1
36872: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36873: LD_ADDR_EXP 141
36877: PUSH
36878: LD_EXP 141
36882: PPUSH
36883: LD_VAR 0 2
36887: PPUSH
36888: LD_INT 0
36890: PPUSH
36891: CALL_OW 1
36895: ST_TO_ADDR
// end ;
36896: GO 35820
36898: POP
36899: POP
// MC_InitSides ( ) ;
36900: CALL 37186 0 0
// MC_InitResearch ( ) ;
36904: CALL 36925 0 0
// CustomInitMacro ( ) ;
36908: CALL 444 0 0
// skirmish := true ;
36912: LD_ADDR_EXP 97
36916: PUSH
36917: LD_INT 1
36919: ST_TO_ADDR
// end ;
36920: LD_VAR 0 1
36924: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
36925: LD_INT 0
36927: PPUSH
36928: PPUSH
36929: PPUSH
36930: PPUSH
36931: PPUSH
36932: PPUSH
// if not mc_bases then
36933: LD_EXP 99
36937: NOT
36938: IFFALSE 36942
// exit ;
36940: GO 37181
// for i = 1 to 8 do
36942: LD_ADDR_VAR 0 2
36946: PUSH
36947: DOUBLE
36948: LD_INT 1
36950: DEC
36951: ST_TO_ADDR
36952: LD_INT 8
36954: PUSH
36955: FOR_TO
36956: IFFALSE 36982
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
36958: LD_ADDR_EXP 126
36962: PUSH
36963: LD_EXP 126
36967: PPUSH
36968: LD_VAR 0 2
36972: PPUSH
36973: EMPTY
36974: PPUSH
36975: CALL_OW 1
36979: ST_TO_ADDR
36980: GO 36955
36982: POP
36983: POP
// tmp := [ ] ;
36984: LD_ADDR_VAR 0 5
36988: PUSH
36989: EMPTY
36990: ST_TO_ADDR
// for i = 1 to mc_sides do
36991: LD_ADDR_VAR 0 2
36995: PUSH
36996: DOUBLE
36997: LD_INT 1
36999: DEC
37000: ST_TO_ADDR
37001: LD_EXP 125
37005: PUSH
37006: FOR_TO
37007: IFFALSE 37065
// if not mc_sides [ i ] in tmp then
37009: LD_EXP 125
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_VAR 0 5
37024: IN
37025: NOT
37026: IFFALSE 37063
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37028: LD_ADDR_VAR 0 5
37032: PUSH
37033: LD_VAR 0 5
37037: PPUSH
37038: LD_VAR 0 5
37042: PUSH
37043: LD_INT 1
37045: PLUS
37046: PPUSH
37047: LD_EXP 125
37051: PUSH
37052: LD_VAR 0 2
37056: ARRAY
37057: PPUSH
37058: CALL_OW 2
37062: ST_TO_ADDR
37063: GO 37006
37065: POP
37066: POP
// if not tmp then
37067: LD_VAR 0 5
37071: NOT
37072: IFFALSE 37076
// exit ;
37074: GO 37181
// for j in tmp do
37076: LD_ADDR_VAR 0 3
37080: PUSH
37081: LD_VAR 0 5
37085: PUSH
37086: FOR_IN
37087: IFFALSE 37179
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37089: LD_ADDR_VAR 0 6
37093: PUSH
37094: LD_INT 22
37096: PUSH
37097: LD_VAR 0 3
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PPUSH
37106: CALL_OW 69
37110: ST_TO_ADDR
// if not un then
37111: LD_VAR 0 6
37115: NOT
37116: IFFALSE 37120
// continue ;
37118: GO 37086
// nation := GetNation ( un [ 1 ] ) ;
37120: LD_ADDR_VAR 0 4
37124: PUSH
37125: LD_VAR 0 6
37129: PUSH
37130: LD_INT 1
37132: ARRAY
37133: PPUSH
37134: CALL_OW 248
37138: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37139: LD_ADDR_EXP 126
37143: PUSH
37144: LD_EXP 126
37148: PPUSH
37149: LD_VAR 0 3
37153: PPUSH
37154: LD_VAR 0 3
37158: PPUSH
37159: LD_VAR 0 4
37163: PPUSH
37164: LD_INT 1
37166: PPUSH
37167: CALL 62975 0 3
37171: PPUSH
37172: CALL_OW 1
37176: ST_TO_ADDR
// end ;
37177: GO 37086
37179: POP
37180: POP
// end ;
37181: LD_VAR 0 1
37185: RET
// export function MC_InitSides ( ) ; var i ; begin
37186: LD_INT 0
37188: PPUSH
37189: PPUSH
// if not mc_bases then
37190: LD_EXP 99
37194: NOT
37195: IFFALSE 37199
// exit ;
37197: GO 37273
// for i = 1 to mc_bases do
37199: LD_ADDR_VAR 0 2
37203: PUSH
37204: DOUBLE
37205: LD_INT 1
37207: DEC
37208: ST_TO_ADDR
37209: LD_EXP 99
37213: PUSH
37214: FOR_TO
37215: IFFALSE 37271
// if mc_bases [ i ] then
37217: LD_EXP 99
37221: PUSH
37222: LD_VAR 0 2
37226: ARRAY
37227: IFFALSE 37269
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37229: LD_ADDR_EXP 125
37233: PUSH
37234: LD_EXP 125
37238: PPUSH
37239: LD_VAR 0 2
37243: PPUSH
37244: LD_EXP 99
37248: PUSH
37249: LD_VAR 0 2
37253: ARRAY
37254: PUSH
37255: LD_INT 1
37257: ARRAY
37258: PPUSH
37259: CALL_OW 255
37263: PPUSH
37264: CALL_OW 1
37268: ST_TO_ADDR
37269: GO 37214
37271: POP
37272: POP
// end ;
37273: LD_VAR 0 1
37277: RET
// every 0 0$01 trigger skirmish do
37278: LD_EXP 97
37282: IFFALSE 37436
37284: GO 37286
37286: DISABLE
// begin enable ;
37287: ENABLE
// MC_CheckBuildings ( ) ;
37288: CALL 41925 0 0
// MC_CheckPeopleLife ( ) ;
37292: CALL 42050 0 0
// RaiseSailEvent ( 100 ) ;
37296: LD_INT 100
37298: PPUSH
37299: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37303: LD_INT 103
37305: PPUSH
37306: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37310: LD_INT 104
37312: PPUSH
37313: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37317: LD_INT 105
37319: PPUSH
37320: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37324: LD_INT 106
37326: PPUSH
37327: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37331: LD_INT 107
37333: PPUSH
37334: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37338: LD_INT 108
37340: PPUSH
37341: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37345: LD_INT 109
37347: PPUSH
37348: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37352: LD_INT 110
37354: PPUSH
37355: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37359: LD_INT 111
37361: PPUSH
37362: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37366: LD_INT 112
37368: PPUSH
37369: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37373: LD_INT 113
37375: PPUSH
37376: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37380: LD_INT 120
37382: PPUSH
37383: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37387: LD_INT 121
37389: PPUSH
37390: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37394: LD_INT 122
37396: PPUSH
37397: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37401: LD_INT 123
37403: PPUSH
37404: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37408: LD_INT 124
37410: PPUSH
37411: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37415: LD_INT 125
37417: PPUSH
37418: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37422: LD_INT 126
37424: PPUSH
37425: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37429: LD_INT 200
37431: PPUSH
37432: CALL_OW 427
// end ;
37436: END
// on SailEvent ( event ) do begin if event < 100 then
37437: LD_VAR 0 1
37441: PUSH
37442: LD_INT 100
37444: LESS
37445: IFFALSE 37456
// CustomEvent ( event ) ;
37447: LD_VAR 0 1
37451: PPUSH
37452: CALL 32131 0 1
// if event = 100 then
37456: LD_VAR 0 1
37460: PUSH
37461: LD_INT 100
37463: EQUAL
37464: IFFALSE 37470
// MC_ClassManager ( ) ;
37466: CALL 37862 0 0
// if event = 101 then
37470: LD_VAR 0 1
37474: PUSH
37475: LD_INT 101
37477: EQUAL
37478: IFFALSE 37484
// MC_RepairBuildings ( ) ;
37480: CALL 42646 0 0
// if event = 102 then
37484: LD_VAR 0 1
37488: PUSH
37489: LD_INT 102
37491: EQUAL
37492: IFFALSE 37498
// MC_Heal ( ) ;
37494: CALL 43052 0 0
// if event = 103 then
37498: LD_VAR 0 1
37502: PUSH
37503: LD_INT 103
37505: EQUAL
37506: IFFALSE 37512
// MC_Build ( ) ;
37508: CALL 43474 0 0
// if event = 104 then
37512: LD_VAR 0 1
37516: PUSH
37517: LD_INT 104
37519: EQUAL
37520: IFFALSE 37526
// MC_TurretWeapon ( ) ;
37522: CALL 45087 0 0
// if event = 105 then
37526: LD_VAR 0 1
37530: PUSH
37531: LD_INT 105
37533: EQUAL
37534: IFFALSE 37540
// MC_BuildUpgrade ( ) ;
37536: CALL 44638 0 0
// if event = 106 then
37540: LD_VAR 0 1
37544: PUSH
37545: LD_INT 106
37547: EQUAL
37548: IFFALSE 37554
// MC_PlantMines ( ) ;
37550: CALL 45517 0 0
// if event = 107 then
37554: LD_VAR 0 1
37558: PUSH
37559: LD_INT 107
37561: EQUAL
37562: IFFALSE 37568
// MC_CollectCrates ( ) ;
37564: CALL 46551 0 0
// if event = 108 then
37568: LD_VAR 0 1
37572: PUSH
37573: LD_INT 108
37575: EQUAL
37576: IFFALSE 37582
// MC_LinkRemoteControl ( ) ;
37578: CALL 48308 0 0
// if event = 109 then
37582: LD_VAR 0 1
37586: PUSH
37587: LD_INT 109
37589: EQUAL
37590: IFFALSE 37596
// MC_ProduceVehicle ( ) ;
37592: CALL 48489 0 0
// if event = 110 then
37596: LD_VAR 0 1
37600: PUSH
37601: LD_INT 110
37603: EQUAL
37604: IFFALSE 37610
// MC_SendAttack ( ) ;
37606: CALL 48970 0 0
// if event = 111 then
37610: LD_VAR 0 1
37614: PUSH
37615: LD_INT 111
37617: EQUAL
37618: IFFALSE 37624
// MC_Defend ( ) ;
37620: CALL 49078 0 0
// if event = 112 then
37624: LD_VAR 0 1
37628: PUSH
37629: LD_INT 112
37631: EQUAL
37632: IFFALSE 37638
// MC_Research ( ) ;
37634: CALL 49683 0 0
// if event = 113 then
37638: LD_VAR 0 1
37642: PUSH
37643: LD_INT 113
37645: EQUAL
37646: IFFALSE 37652
// MC_MinesTrigger ( ) ;
37648: CALL 50797 0 0
// if event = 120 then
37652: LD_VAR 0 1
37656: PUSH
37657: LD_INT 120
37659: EQUAL
37660: IFFALSE 37666
// MC_RepairVehicle ( ) ;
37662: CALL 50896 0 0
// if event = 121 then
37666: LD_VAR 0 1
37670: PUSH
37671: LD_INT 121
37673: EQUAL
37674: IFFALSE 37680
// MC_TameApe ( ) ;
37676: CALL 51603 0 0
// if event = 122 then
37680: LD_VAR 0 1
37684: PUSH
37685: LD_INT 122
37687: EQUAL
37688: IFFALSE 37694
// MC_ChangeApeClass ( ) ;
37690: CALL 52432 0 0
// if event = 123 then
37694: LD_VAR 0 1
37698: PUSH
37699: LD_INT 123
37701: EQUAL
37702: IFFALSE 37708
// MC_Bazooka ( ) ;
37704: CALL 53082 0 0
// if event = 124 then
37708: LD_VAR 0 1
37712: PUSH
37713: LD_INT 124
37715: EQUAL
37716: IFFALSE 37722
// MC_TeleportExit ( ) ;
37718: CALL 53280 0 0
// if event = 125 then
37722: LD_VAR 0 1
37726: PUSH
37727: LD_INT 125
37729: EQUAL
37730: IFFALSE 37736
// MC_Deposits ( ) ;
37732: CALL 53927 0 0
// if event = 126 then
37736: LD_VAR 0 1
37740: PUSH
37741: LD_INT 126
37743: EQUAL
37744: IFFALSE 37750
// MC_RemoteDriver ( ) ;
37746: CALL 54552 0 0
// if event = 200 then
37750: LD_VAR 0 1
37754: PUSH
37755: LD_INT 200
37757: EQUAL
37758: IFFALSE 37764
// MC_Idle ( ) ;
37760: CALL 56285 0 0
// end ;
37764: PPOPN 1
37766: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37767: LD_INT 0
37769: PPUSH
37770: PPUSH
// if not mc_bases [ base ] or not tag then
37771: LD_EXP 99
37775: PUSH
37776: LD_VAR 0 1
37780: ARRAY
37781: NOT
37782: PUSH
37783: LD_VAR 0 2
37787: NOT
37788: OR
37789: IFFALSE 37793
// exit ;
37791: GO 37857
// for i in mc_bases [ base ] union mc_ape [ base ] do
37793: LD_ADDR_VAR 0 4
37797: PUSH
37798: LD_EXP 99
37802: PUSH
37803: LD_VAR 0 1
37807: ARRAY
37808: PUSH
37809: LD_EXP 128
37813: PUSH
37814: LD_VAR 0 1
37818: ARRAY
37819: UNION
37820: PUSH
37821: FOR_IN
37822: IFFALSE 37855
// if GetTag ( i ) = tag then
37824: LD_VAR 0 4
37828: PPUSH
37829: CALL_OW 110
37833: PUSH
37834: LD_VAR 0 2
37838: EQUAL
37839: IFFALSE 37853
// SetTag ( i , 0 ) ;
37841: LD_VAR 0 4
37845: PPUSH
37846: LD_INT 0
37848: PPUSH
37849: CALL_OW 109
37853: GO 37821
37855: POP
37856: POP
// end ;
37857: LD_VAR 0 3
37861: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37862: LD_INT 0
37864: PPUSH
37865: PPUSH
37866: PPUSH
37867: PPUSH
37868: PPUSH
37869: PPUSH
37870: PPUSH
37871: PPUSH
// if not mc_bases then
37872: LD_EXP 99
37876: NOT
37877: IFFALSE 37881
// exit ;
37879: GO 38339
// for i = 1 to mc_bases do
37881: LD_ADDR_VAR 0 2
37885: PUSH
37886: DOUBLE
37887: LD_INT 1
37889: DEC
37890: ST_TO_ADDR
37891: LD_EXP 99
37895: PUSH
37896: FOR_TO
37897: IFFALSE 38337
// begin tmp := MC_ClassCheckReq ( i ) ;
37899: LD_ADDR_VAR 0 4
37903: PUSH
37904: LD_VAR 0 2
37908: PPUSH
37909: CALL 38344 0 1
37913: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
37914: LD_ADDR_EXP 140
37918: PUSH
37919: LD_EXP 140
37923: PPUSH
37924: LD_VAR 0 2
37928: PPUSH
37929: LD_VAR 0 4
37933: PPUSH
37934: CALL_OW 1
37938: ST_TO_ADDR
// if not tmp then
37939: LD_VAR 0 4
37943: NOT
37944: IFFALSE 37948
// continue ;
37946: GO 37896
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
37948: LD_ADDR_VAR 0 6
37952: PUSH
37953: LD_EXP 99
37957: PUSH
37958: LD_VAR 0 2
37962: ARRAY
37963: PPUSH
37964: LD_INT 2
37966: PUSH
37967: LD_INT 30
37969: PUSH
37970: LD_INT 4
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 30
37979: PUSH
37980: LD_INT 5
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: LIST
37991: PPUSH
37992: CALL_OW 72
37996: PUSH
37997: LD_EXP 99
38001: PUSH
38002: LD_VAR 0 2
38006: ARRAY
38007: PPUSH
38008: LD_INT 2
38010: PUSH
38011: LD_INT 30
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 30
38023: PUSH
38024: LD_INT 1
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: LIST
38035: PPUSH
38036: CALL_OW 72
38040: PUSH
38041: LD_EXP 99
38045: PUSH
38046: LD_VAR 0 2
38050: ARRAY
38051: PPUSH
38052: LD_INT 30
38054: PUSH
38055: LD_INT 3
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PPUSH
38062: CALL_OW 72
38066: PUSH
38067: LD_EXP 99
38071: PUSH
38072: LD_VAR 0 2
38076: ARRAY
38077: PPUSH
38078: LD_INT 2
38080: PUSH
38081: LD_INT 30
38083: PUSH
38084: LD_INT 6
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 30
38093: PUSH
38094: LD_INT 7
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 30
38103: PUSH
38104: LD_INT 8
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: PPUSH
38117: CALL_OW 72
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: LIST
38126: LIST
38127: ST_TO_ADDR
// for j = 1 to 4 do
38128: LD_ADDR_VAR 0 3
38132: PUSH
38133: DOUBLE
38134: LD_INT 1
38136: DEC
38137: ST_TO_ADDR
38138: LD_INT 4
38140: PUSH
38141: FOR_TO
38142: IFFALSE 38333
// begin if not tmp [ j ] then
38144: LD_VAR 0 4
38148: PUSH
38149: LD_VAR 0 3
38153: ARRAY
38154: NOT
38155: IFFALSE 38159
// continue ;
38157: GO 38141
// for p in tmp [ j ] do
38159: LD_ADDR_VAR 0 5
38163: PUSH
38164: LD_VAR 0 4
38168: PUSH
38169: LD_VAR 0 3
38173: ARRAY
38174: PUSH
38175: FOR_IN
38176: IFFALSE 38329
// begin if not b [ j ] then
38178: LD_VAR 0 6
38182: PUSH
38183: LD_VAR 0 3
38187: ARRAY
38188: NOT
38189: IFFALSE 38193
// break ;
38191: GO 38329
// e := 0 ;
38193: LD_ADDR_VAR 0 7
38197: PUSH
38198: LD_INT 0
38200: ST_TO_ADDR
// for k in b [ j ] do
38201: LD_ADDR_VAR 0 8
38205: PUSH
38206: LD_VAR 0 6
38210: PUSH
38211: LD_VAR 0 3
38215: ARRAY
38216: PUSH
38217: FOR_IN
38218: IFFALSE 38245
// if IsNotFull ( k ) then
38220: LD_VAR 0 8
38224: PPUSH
38225: CALL 66964 0 1
38229: IFFALSE 38243
// begin e := k ;
38231: LD_ADDR_VAR 0 7
38235: PUSH
38236: LD_VAR 0 8
38240: ST_TO_ADDR
// break ;
38241: GO 38245
// end ;
38243: GO 38217
38245: POP
38246: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38247: LD_VAR 0 7
38251: PUSH
38252: LD_VAR 0 5
38256: PPUSH
38257: LD_VAR 0 7
38261: PPUSH
38262: CALL 104022 0 2
38266: NOT
38267: AND
38268: IFFALSE 38327
// begin if IsInUnit ( p ) then
38270: LD_VAR 0 5
38274: PPUSH
38275: CALL_OW 310
38279: IFFALSE 38290
// ComExitBuilding ( p ) ;
38281: LD_VAR 0 5
38285: PPUSH
38286: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38290: LD_VAR 0 5
38294: PPUSH
38295: LD_VAR 0 7
38299: PPUSH
38300: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38304: LD_VAR 0 5
38308: PPUSH
38309: LD_VAR 0 3
38313: PPUSH
38314: CALL_OW 183
// AddComExitBuilding ( p ) ;
38318: LD_VAR 0 5
38322: PPUSH
38323: CALL_OW 182
// end ; end ;
38327: GO 38175
38329: POP
38330: POP
// end ;
38331: GO 38141
38333: POP
38334: POP
// end ;
38335: GO 37896
38337: POP
38338: POP
// end ;
38339: LD_VAR 0 1
38343: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38344: LD_INT 0
38346: PPUSH
38347: PPUSH
38348: PPUSH
38349: PPUSH
38350: PPUSH
38351: PPUSH
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38358: LD_VAR 0 1
38362: NOT
38363: PUSH
38364: LD_EXP 99
38368: PUSH
38369: LD_VAR 0 1
38373: ARRAY
38374: NOT
38375: OR
38376: PUSH
38377: LD_EXP 99
38381: PUSH
38382: LD_VAR 0 1
38386: ARRAY
38387: PPUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 30
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 30
38403: PUSH
38404: LD_INT 1
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: LIST
38415: PPUSH
38416: CALL_OW 72
38420: NOT
38421: OR
38422: IFFALSE 38426
// exit ;
38424: GO 41920
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38426: LD_ADDR_VAR 0 4
38430: PUSH
38431: LD_EXP 99
38435: PUSH
38436: LD_VAR 0 1
38440: ARRAY
38441: PPUSH
38442: LD_INT 2
38444: PUSH
38445: LD_INT 25
38447: PUSH
38448: LD_INT 1
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 25
38457: PUSH
38458: LD_INT 2
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 25
38467: PUSH
38468: LD_INT 3
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 25
38477: PUSH
38478: LD_INT 4
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 25
38487: PUSH
38488: LD_INT 5
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 25
38497: PUSH
38498: LD_INT 8
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 25
38507: PUSH
38508: LD_INT 9
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL_OW 72
38529: ST_TO_ADDR
// for i in tmp do
38530: LD_ADDR_VAR 0 3
38534: PUSH
38535: LD_VAR 0 4
38539: PUSH
38540: FOR_IN
38541: IFFALSE 38572
// if GetTag ( i ) then
38543: LD_VAR 0 3
38547: PPUSH
38548: CALL_OW 110
38552: IFFALSE 38570
// tmp := tmp diff i ;
38554: LD_ADDR_VAR 0 4
38558: PUSH
38559: LD_VAR 0 4
38563: PUSH
38564: LD_VAR 0 3
38568: DIFF
38569: ST_TO_ADDR
38570: GO 38540
38572: POP
38573: POP
// if not tmp then
38574: LD_VAR 0 4
38578: NOT
38579: IFFALSE 38583
// exit ;
38581: GO 41920
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38583: LD_ADDR_VAR 0 5
38587: PUSH
38588: LD_EXP 99
38592: PUSH
38593: LD_VAR 0 1
38597: ARRAY
38598: PPUSH
38599: LD_INT 2
38601: PUSH
38602: LD_INT 25
38604: PUSH
38605: LD_INT 1
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 25
38614: PUSH
38615: LD_INT 5
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 25
38624: PUSH
38625: LD_INT 8
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 25
38634: PUSH
38635: LD_INT 9
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: PPUSH
38649: CALL_OW 72
38653: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38654: LD_ADDR_VAR 0 6
38658: PUSH
38659: LD_EXP 99
38663: PUSH
38664: LD_VAR 0 1
38668: ARRAY
38669: PPUSH
38670: LD_INT 25
38672: PUSH
38673: LD_INT 2
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PPUSH
38680: CALL_OW 72
38684: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38685: LD_ADDR_VAR 0 7
38689: PUSH
38690: LD_EXP 99
38694: PUSH
38695: LD_VAR 0 1
38699: ARRAY
38700: PPUSH
38701: LD_INT 25
38703: PUSH
38704: LD_INT 3
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PPUSH
38711: CALL_OW 72
38715: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38716: LD_ADDR_VAR 0 8
38720: PUSH
38721: LD_EXP 99
38725: PUSH
38726: LD_VAR 0 1
38730: ARRAY
38731: PPUSH
38732: LD_INT 25
38734: PUSH
38735: LD_INT 4
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 24
38744: PUSH
38745: LD_INT 251
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PPUSH
38756: CALL_OW 72
38760: ST_TO_ADDR
// if mc_scan [ base ] then
38761: LD_EXP 122
38765: PUSH
38766: LD_VAR 0 1
38770: ARRAY
38771: IFFALSE 39232
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38773: LD_ADDR_EXP 141
38777: PUSH
38778: LD_EXP 141
38782: PPUSH
38783: LD_VAR 0 1
38787: PPUSH
38788: LD_INT 4
38790: PPUSH
38791: CALL_OW 1
38795: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38796: LD_ADDR_VAR 0 12
38800: PUSH
38801: LD_EXP 99
38805: PUSH
38806: LD_VAR 0 1
38810: ARRAY
38811: PPUSH
38812: LD_INT 2
38814: PUSH
38815: LD_INT 30
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 30
38827: PUSH
38828: LD_INT 5
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: LIST
38839: PPUSH
38840: CALL_OW 72
38844: ST_TO_ADDR
// if not b then
38845: LD_VAR 0 12
38849: NOT
38850: IFFALSE 38854
// exit ;
38852: GO 41920
// p := [ ] ;
38854: LD_ADDR_VAR 0 11
38858: PUSH
38859: EMPTY
38860: ST_TO_ADDR
// if sci >= 2 then
38861: LD_VAR 0 8
38865: PUSH
38866: LD_INT 2
38868: GREATEREQUAL
38869: IFFALSE 38900
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38871: LD_ADDR_VAR 0 8
38875: PUSH
38876: LD_VAR 0 8
38880: PUSH
38881: LD_INT 1
38883: ARRAY
38884: PUSH
38885: LD_VAR 0 8
38889: PUSH
38890: LD_INT 2
38892: ARRAY
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: ST_TO_ADDR
38898: GO 38961
// if sci = 1 then
38900: LD_VAR 0 8
38904: PUSH
38905: LD_INT 1
38907: EQUAL
38908: IFFALSE 38929
// sci := [ sci [ 1 ] ] else
38910: LD_ADDR_VAR 0 8
38914: PUSH
38915: LD_VAR 0 8
38919: PUSH
38920: LD_INT 1
38922: ARRAY
38923: PUSH
38924: EMPTY
38925: LIST
38926: ST_TO_ADDR
38927: GO 38961
// if sci = 0 then
38929: LD_VAR 0 8
38933: PUSH
38934: LD_INT 0
38936: EQUAL
38937: IFFALSE 38961
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
38939: LD_ADDR_VAR 0 11
38943: PUSH
38944: LD_VAR 0 4
38948: PPUSH
38949: LD_INT 4
38951: PPUSH
38952: CALL 103885 0 2
38956: PUSH
38957: LD_INT 1
38959: ARRAY
38960: ST_TO_ADDR
// if eng > 4 then
38961: LD_VAR 0 6
38965: PUSH
38966: LD_INT 4
38968: GREATER
38969: IFFALSE 39015
// for i = eng downto 4 do
38971: LD_ADDR_VAR 0 3
38975: PUSH
38976: DOUBLE
38977: LD_VAR 0 6
38981: INC
38982: ST_TO_ADDR
38983: LD_INT 4
38985: PUSH
38986: FOR_DOWNTO
38987: IFFALSE 39013
// eng := eng diff eng [ i ] ;
38989: LD_ADDR_VAR 0 6
38993: PUSH
38994: LD_VAR 0 6
38998: PUSH
38999: LD_VAR 0 6
39003: PUSH
39004: LD_VAR 0 3
39008: ARRAY
39009: DIFF
39010: ST_TO_ADDR
39011: GO 38986
39013: POP
39014: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39015: LD_ADDR_VAR 0 4
39019: PUSH
39020: LD_VAR 0 4
39024: PUSH
39025: LD_VAR 0 5
39029: PUSH
39030: LD_VAR 0 6
39034: UNION
39035: PUSH
39036: LD_VAR 0 7
39040: UNION
39041: PUSH
39042: LD_VAR 0 8
39046: UNION
39047: DIFF
39048: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39049: LD_ADDR_VAR 0 13
39053: PUSH
39054: LD_EXP 99
39058: PUSH
39059: LD_VAR 0 1
39063: ARRAY
39064: PPUSH
39065: LD_INT 2
39067: PUSH
39068: LD_INT 30
39070: PUSH
39071: LD_INT 32
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 30
39080: PUSH
39081: LD_INT 31
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: PPUSH
39093: CALL_OW 72
39097: PUSH
39098: LD_EXP 99
39102: PUSH
39103: LD_VAR 0 1
39107: ARRAY
39108: PPUSH
39109: LD_INT 2
39111: PUSH
39112: LD_INT 30
39114: PUSH
39115: LD_INT 4
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 30
39124: PUSH
39125: LD_INT 5
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: LIST
39136: PPUSH
39137: CALL_OW 72
39141: PUSH
39142: LD_INT 6
39144: MUL
39145: PLUS
39146: ST_TO_ADDR
// if bcount < tmp then
39147: LD_VAR 0 13
39151: PUSH
39152: LD_VAR 0 4
39156: LESS
39157: IFFALSE 39203
// for i = tmp downto bcount do
39159: LD_ADDR_VAR 0 3
39163: PUSH
39164: DOUBLE
39165: LD_VAR 0 4
39169: INC
39170: ST_TO_ADDR
39171: LD_VAR 0 13
39175: PUSH
39176: FOR_DOWNTO
39177: IFFALSE 39201
// tmp := Delete ( tmp , tmp ) ;
39179: LD_ADDR_VAR 0 4
39183: PUSH
39184: LD_VAR 0 4
39188: PPUSH
39189: LD_VAR 0 4
39193: PPUSH
39194: CALL_OW 3
39198: ST_TO_ADDR
39199: GO 39176
39201: POP
39202: POP
// result := [ tmp , 0 , 0 , p ] ;
39203: LD_ADDR_VAR 0 2
39207: PUSH
39208: LD_VAR 0 4
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: LD_VAR 0 11
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: ST_TO_ADDR
// exit ;
39230: GO 41920
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39232: LD_EXP 99
39236: PUSH
39237: LD_VAR 0 1
39241: ARRAY
39242: PPUSH
39243: LD_INT 2
39245: PUSH
39246: LD_INT 30
39248: PUSH
39249: LD_INT 6
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 30
39258: PUSH
39259: LD_INT 7
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 30
39268: PUSH
39269: LD_INT 8
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: PPUSH
39282: CALL_OW 72
39286: NOT
39287: PUSH
39288: LD_EXP 99
39292: PUSH
39293: LD_VAR 0 1
39297: ARRAY
39298: PPUSH
39299: LD_INT 30
39301: PUSH
39302: LD_INT 3
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PPUSH
39309: CALL_OW 72
39313: NOT
39314: AND
39315: IFFALSE 39387
// begin if eng = tmp then
39317: LD_VAR 0 6
39321: PUSH
39322: LD_VAR 0 4
39326: EQUAL
39327: IFFALSE 39331
// exit ;
39329: GO 41920
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39331: LD_ADDR_EXP 141
39335: PUSH
39336: LD_EXP 141
39340: PPUSH
39341: LD_VAR 0 1
39345: PPUSH
39346: LD_INT 1
39348: PPUSH
39349: CALL_OW 1
39353: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39354: LD_ADDR_VAR 0 2
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_VAR 0 4
39366: PUSH
39367: LD_VAR 0 6
39371: DIFF
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: LD_INT 0
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: LIST
39383: LIST
39384: ST_TO_ADDR
// exit ;
39385: GO 41920
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39387: LD_EXP 126
39391: PUSH
39392: LD_EXP 125
39396: PUSH
39397: LD_VAR 0 1
39401: ARRAY
39402: ARRAY
39403: PUSH
39404: LD_EXP 99
39408: PUSH
39409: LD_VAR 0 1
39413: ARRAY
39414: PPUSH
39415: LD_INT 2
39417: PUSH
39418: LD_INT 30
39420: PUSH
39421: LD_INT 6
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 30
39430: PUSH
39431: LD_INT 7
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 30
39440: PUSH
39441: LD_INT 8
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: PPUSH
39454: CALL_OW 72
39458: AND
39459: PUSH
39460: LD_EXP 99
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 30
39473: PUSH
39474: LD_INT 3
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PPUSH
39481: CALL_OW 72
39485: NOT
39486: AND
39487: IFFALSE 39701
// begin if sci >= 6 then
39489: LD_VAR 0 8
39493: PUSH
39494: LD_INT 6
39496: GREATEREQUAL
39497: IFFALSE 39501
// exit ;
39499: GO 41920
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39501: LD_ADDR_EXP 141
39505: PUSH
39506: LD_EXP 141
39510: PPUSH
39511: LD_VAR 0 1
39515: PPUSH
39516: LD_INT 2
39518: PPUSH
39519: CALL_OW 1
39523: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39524: LD_ADDR_VAR 0 9
39528: PUSH
39529: LD_VAR 0 4
39533: PUSH
39534: LD_VAR 0 8
39538: DIFF
39539: PPUSH
39540: LD_INT 4
39542: PPUSH
39543: CALL 103885 0 2
39547: ST_TO_ADDR
// p := [ ] ;
39548: LD_ADDR_VAR 0 11
39552: PUSH
39553: EMPTY
39554: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39555: LD_VAR 0 8
39559: PUSH
39560: LD_INT 6
39562: LESS
39563: PUSH
39564: LD_VAR 0 9
39568: PUSH
39569: LD_INT 6
39571: GREATER
39572: AND
39573: IFFALSE 39654
// begin for i = 1 to 6 - sci do
39575: LD_ADDR_VAR 0 3
39579: PUSH
39580: DOUBLE
39581: LD_INT 1
39583: DEC
39584: ST_TO_ADDR
39585: LD_INT 6
39587: PUSH
39588: LD_VAR 0 8
39592: MINUS
39593: PUSH
39594: FOR_TO
39595: IFFALSE 39650
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39597: LD_ADDR_VAR 0 11
39601: PUSH
39602: LD_VAR 0 11
39606: PPUSH
39607: LD_VAR 0 11
39611: PUSH
39612: LD_INT 1
39614: PLUS
39615: PPUSH
39616: LD_VAR 0 9
39620: PUSH
39621: LD_INT 1
39623: ARRAY
39624: PPUSH
39625: CALL_OW 2
39629: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39630: LD_ADDR_VAR 0 9
39634: PUSH
39635: LD_VAR 0 9
39639: PPUSH
39640: LD_INT 1
39642: PPUSH
39643: CALL_OW 3
39647: ST_TO_ADDR
// end ;
39648: GO 39594
39650: POP
39651: POP
// end else
39652: GO 39674
// if sort then
39654: LD_VAR 0 9
39658: IFFALSE 39674
// p := sort [ 1 ] ;
39660: LD_ADDR_VAR 0 11
39664: PUSH
39665: LD_VAR 0 9
39669: PUSH
39670: LD_INT 1
39672: ARRAY
39673: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39674: LD_ADDR_VAR 0 2
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: LD_VAR 0 11
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: ST_TO_ADDR
// exit ;
39699: GO 41920
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39701: LD_EXP 126
39705: PUSH
39706: LD_EXP 125
39710: PUSH
39711: LD_VAR 0 1
39715: ARRAY
39716: ARRAY
39717: PUSH
39718: LD_EXP 99
39722: PUSH
39723: LD_VAR 0 1
39727: ARRAY
39728: PPUSH
39729: LD_INT 2
39731: PUSH
39732: LD_INT 30
39734: PUSH
39735: LD_INT 6
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 30
39744: PUSH
39745: LD_INT 7
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 30
39754: PUSH
39755: LD_INT 8
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: PPUSH
39768: CALL_OW 72
39772: AND
39773: PUSH
39774: LD_EXP 99
39778: PUSH
39779: LD_VAR 0 1
39783: ARRAY
39784: PPUSH
39785: LD_INT 30
39787: PUSH
39788: LD_INT 3
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PPUSH
39795: CALL_OW 72
39799: AND
39800: IFFALSE 40534
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39802: LD_ADDR_EXP 141
39806: PUSH
39807: LD_EXP 141
39811: PPUSH
39812: LD_VAR 0 1
39816: PPUSH
39817: LD_INT 3
39819: PPUSH
39820: CALL_OW 1
39824: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39825: LD_ADDR_VAR 0 2
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: LD_INT 0
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: ST_TO_ADDR
// if not eng then
39848: LD_VAR 0 6
39852: NOT
39853: IFFALSE 39916
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39855: LD_ADDR_VAR 0 11
39859: PUSH
39860: LD_VAR 0 4
39864: PPUSH
39865: LD_INT 2
39867: PPUSH
39868: CALL 103885 0 2
39872: PUSH
39873: LD_INT 1
39875: ARRAY
39876: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39877: LD_ADDR_VAR 0 2
39881: PUSH
39882: LD_VAR 0 2
39886: PPUSH
39887: LD_INT 2
39889: PPUSH
39890: LD_VAR 0 11
39894: PPUSH
39895: CALL_OW 1
39899: ST_TO_ADDR
// tmp := tmp diff p ;
39900: LD_ADDR_VAR 0 4
39904: PUSH
39905: LD_VAR 0 4
39909: PUSH
39910: LD_VAR 0 11
39914: DIFF
39915: ST_TO_ADDR
// end ; if tmp and sci < 6 then
39916: LD_VAR 0 4
39920: PUSH
39921: LD_VAR 0 8
39925: PUSH
39926: LD_INT 6
39928: LESS
39929: AND
39930: IFFALSE 40118
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
39932: LD_ADDR_VAR 0 9
39936: PUSH
39937: LD_VAR 0 4
39941: PUSH
39942: LD_VAR 0 8
39946: PUSH
39947: LD_VAR 0 7
39951: UNION
39952: DIFF
39953: PPUSH
39954: LD_INT 4
39956: PPUSH
39957: CALL 103885 0 2
39961: ST_TO_ADDR
// p := [ ] ;
39962: LD_ADDR_VAR 0 11
39966: PUSH
39967: EMPTY
39968: ST_TO_ADDR
// if sort then
39969: LD_VAR 0 9
39973: IFFALSE 40089
// for i = 1 to 6 - sci do
39975: LD_ADDR_VAR 0 3
39979: PUSH
39980: DOUBLE
39981: LD_INT 1
39983: DEC
39984: ST_TO_ADDR
39985: LD_INT 6
39987: PUSH
39988: LD_VAR 0 8
39992: MINUS
39993: PUSH
39994: FOR_TO
39995: IFFALSE 40087
// begin if i = sort then
39997: LD_VAR 0 3
40001: PUSH
40002: LD_VAR 0 9
40006: EQUAL
40007: IFFALSE 40011
// break ;
40009: GO 40087
// if GetClass ( i ) = 4 then
40011: LD_VAR 0 3
40015: PPUSH
40016: CALL_OW 257
40020: PUSH
40021: LD_INT 4
40023: EQUAL
40024: IFFALSE 40028
// continue ;
40026: GO 39994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40028: LD_ADDR_VAR 0 11
40032: PUSH
40033: LD_VAR 0 11
40037: PPUSH
40038: LD_VAR 0 11
40042: PUSH
40043: LD_INT 1
40045: PLUS
40046: PPUSH
40047: LD_VAR 0 9
40051: PUSH
40052: LD_VAR 0 3
40056: ARRAY
40057: PPUSH
40058: CALL_OW 2
40062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40063: LD_ADDR_VAR 0 4
40067: PUSH
40068: LD_VAR 0 4
40072: PUSH
40073: LD_VAR 0 9
40077: PUSH
40078: LD_VAR 0 3
40082: ARRAY
40083: DIFF
40084: ST_TO_ADDR
// end ;
40085: GO 39994
40087: POP
40088: POP
// if p then
40089: LD_VAR 0 11
40093: IFFALSE 40118
// result := Replace ( result , 4 , p ) ;
40095: LD_ADDR_VAR 0 2
40099: PUSH
40100: LD_VAR 0 2
40104: PPUSH
40105: LD_INT 4
40107: PPUSH
40108: LD_VAR 0 11
40112: PPUSH
40113: CALL_OW 1
40117: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40118: LD_VAR 0 4
40122: PUSH
40123: LD_VAR 0 7
40127: PUSH
40128: LD_INT 6
40130: LESS
40131: AND
40132: IFFALSE 40320
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40134: LD_ADDR_VAR 0 9
40138: PUSH
40139: LD_VAR 0 4
40143: PUSH
40144: LD_VAR 0 8
40148: PUSH
40149: LD_VAR 0 7
40153: UNION
40154: DIFF
40155: PPUSH
40156: LD_INT 3
40158: PPUSH
40159: CALL 103885 0 2
40163: ST_TO_ADDR
// p := [ ] ;
40164: LD_ADDR_VAR 0 11
40168: PUSH
40169: EMPTY
40170: ST_TO_ADDR
// if sort then
40171: LD_VAR 0 9
40175: IFFALSE 40291
// for i = 1 to 6 - mech do
40177: LD_ADDR_VAR 0 3
40181: PUSH
40182: DOUBLE
40183: LD_INT 1
40185: DEC
40186: ST_TO_ADDR
40187: LD_INT 6
40189: PUSH
40190: LD_VAR 0 7
40194: MINUS
40195: PUSH
40196: FOR_TO
40197: IFFALSE 40289
// begin if i = sort then
40199: LD_VAR 0 3
40203: PUSH
40204: LD_VAR 0 9
40208: EQUAL
40209: IFFALSE 40213
// break ;
40211: GO 40289
// if GetClass ( i ) = 3 then
40213: LD_VAR 0 3
40217: PPUSH
40218: CALL_OW 257
40222: PUSH
40223: LD_INT 3
40225: EQUAL
40226: IFFALSE 40230
// continue ;
40228: GO 40196
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40230: LD_ADDR_VAR 0 11
40234: PUSH
40235: LD_VAR 0 11
40239: PPUSH
40240: LD_VAR 0 11
40244: PUSH
40245: LD_INT 1
40247: PLUS
40248: PPUSH
40249: LD_VAR 0 9
40253: PUSH
40254: LD_VAR 0 3
40258: ARRAY
40259: PPUSH
40260: CALL_OW 2
40264: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40265: LD_ADDR_VAR 0 4
40269: PUSH
40270: LD_VAR 0 4
40274: PUSH
40275: LD_VAR 0 9
40279: PUSH
40280: LD_VAR 0 3
40284: ARRAY
40285: DIFF
40286: ST_TO_ADDR
// end ;
40287: GO 40196
40289: POP
40290: POP
// if p then
40291: LD_VAR 0 11
40295: IFFALSE 40320
// result := Replace ( result , 3 , p ) ;
40297: LD_ADDR_VAR 0 2
40301: PUSH
40302: LD_VAR 0 2
40306: PPUSH
40307: LD_INT 3
40309: PPUSH
40310: LD_VAR 0 11
40314: PPUSH
40315: CALL_OW 1
40319: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40320: LD_VAR 0 4
40324: PUSH
40325: LD_INT 6
40327: GREATER
40328: PUSH
40329: LD_VAR 0 6
40333: PUSH
40334: LD_INT 6
40336: LESS
40337: AND
40338: IFFALSE 40532
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40340: LD_ADDR_VAR 0 9
40344: PUSH
40345: LD_VAR 0 4
40349: PUSH
40350: LD_VAR 0 8
40354: PUSH
40355: LD_VAR 0 7
40359: UNION
40360: PUSH
40361: LD_VAR 0 6
40365: UNION
40366: DIFF
40367: PPUSH
40368: LD_INT 2
40370: PPUSH
40371: CALL 103885 0 2
40375: ST_TO_ADDR
// p := [ ] ;
40376: LD_ADDR_VAR 0 11
40380: PUSH
40381: EMPTY
40382: ST_TO_ADDR
// if sort then
40383: LD_VAR 0 9
40387: IFFALSE 40503
// for i = 1 to 6 - eng do
40389: LD_ADDR_VAR 0 3
40393: PUSH
40394: DOUBLE
40395: LD_INT 1
40397: DEC
40398: ST_TO_ADDR
40399: LD_INT 6
40401: PUSH
40402: LD_VAR 0 6
40406: MINUS
40407: PUSH
40408: FOR_TO
40409: IFFALSE 40501
// begin if i = sort then
40411: LD_VAR 0 3
40415: PUSH
40416: LD_VAR 0 9
40420: EQUAL
40421: IFFALSE 40425
// break ;
40423: GO 40501
// if GetClass ( i ) = 2 then
40425: LD_VAR 0 3
40429: PPUSH
40430: CALL_OW 257
40434: PUSH
40435: LD_INT 2
40437: EQUAL
40438: IFFALSE 40442
// continue ;
40440: GO 40408
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40442: LD_ADDR_VAR 0 11
40446: PUSH
40447: LD_VAR 0 11
40451: PPUSH
40452: LD_VAR 0 11
40456: PUSH
40457: LD_INT 1
40459: PLUS
40460: PPUSH
40461: LD_VAR 0 9
40465: PUSH
40466: LD_VAR 0 3
40470: ARRAY
40471: PPUSH
40472: CALL_OW 2
40476: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40477: LD_ADDR_VAR 0 4
40481: PUSH
40482: LD_VAR 0 4
40486: PUSH
40487: LD_VAR 0 9
40491: PUSH
40492: LD_VAR 0 3
40496: ARRAY
40497: DIFF
40498: ST_TO_ADDR
// end ;
40499: GO 40408
40501: POP
40502: POP
// if p then
40503: LD_VAR 0 11
40507: IFFALSE 40532
// result := Replace ( result , 2 , p ) ;
40509: LD_ADDR_VAR 0 2
40513: PUSH
40514: LD_VAR 0 2
40518: PPUSH
40519: LD_INT 2
40521: PPUSH
40522: LD_VAR 0 11
40526: PPUSH
40527: CALL_OW 1
40531: ST_TO_ADDR
// end ; exit ;
40532: GO 41920
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40534: LD_EXP 126
40538: PUSH
40539: LD_EXP 125
40543: PUSH
40544: LD_VAR 0 1
40548: ARRAY
40549: ARRAY
40550: NOT
40551: PUSH
40552: LD_EXP 99
40556: PUSH
40557: LD_VAR 0 1
40561: ARRAY
40562: PPUSH
40563: LD_INT 30
40565: PUSH
40566: LD_INT 3
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PPUSH
40573: CALL_OW 72
40577: AND
40578: PUSH
40579: LD_EXP 104
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: AND
40590: IFFALSE 41198
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40592: LD_ADDR_EXP 141
40596: PUSH
40597: LD_EXP 141
40601: PPUSH
40602: LD_VAR 0 1
40606: PPUSH
40607: LD_INT 5
40609: PPUSH
40610: CALL_OW 1
40614: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40615: LD_ADDR_VAR 0 2
40619: PUSH
40620: LD_INT 0
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: LD_INT 0
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: LIST
40636: LIST
40637: ST_TO_ADDR
// if sci > 1 then
40638: LD_VAR 0 8
40642: PUSH
40643: LD_INT 1
40645: GREATER
40646: IFFALSE 40674
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40648: LD_ADDR_VAR 0 4
40652: PUSH
40653: LD_VAR 0 4
40657: PUSH
40658: LD_VAR 0 8
40662: PUSH
40663: LD_VAR 0 8
40667: PUSH
40668: LD_INT 1
40670: ARRAY
40671: DIFF
40672: DIFF
40673: ST_TO_ADDR
// if tmp and not sci then
40674: LD_VAR 0 4
40678: PUSH
40679: LD_VAR 0 8
40683: NOT
40684: AND
40685: IFFALSE 40754
// begin sort := SortBySkill ( tmp , 4 ) ;
40687: LD_ADDR_VAR 0 9
40691: PUSH
40692: LD_VAR 0 4
40696: PPUSH
40697: LD_INT 4
40699: PPUSH
40700: CALL 103885 0 2
40704: ST_TO_ADDR
// if sort then
40705: LD_VAR 0 9
40709: IFFALSE 40725
// p := sort [ 1 ] ;
40711: LD_ADDR_VAR 0 11
40715: PUSH
40716: LD_VAR 0 9
40720: PUSH
40721: LD_INT 1
40723: ARRAY
40724: ST_TO_ADDR
// if p then
40725: LD_VAR 0 11
40729: IFFALSE 40754
// result := Replace ( result , 4 , p ) ;
40731: LD_ADDR_VAR 0 2
40735: PUSH
40736: LD_VAR 0 2
40740: PPUSH
40741: LD_INT 4
40743: PPUSH
40744: LD_VAR 0 11
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40754: LD_ADDR_VAR 0 4
40758: PUSH
40759: LD_VAR 0 4
40763: PUSH
40764: LD_VAR 0 7
40768: DIFF
40769: ST_TO_ADDR
// if tmp and mech < 6 then
40770: LD_VAR 0 4
40774: PUSH
40775: LD_VAR 0 7
40779: PUSH
40780: LD_INT 6
40782: LESS
40783: AND
40784: IFFALSE 40972
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40786: LD_ADDR_VAR 0 9
40790: PUSH
40791: LD_VAR 0 4
40795: PUSH
40796: LD_VAR 0 8
40800: PUSH
40801: LD_VAR 0 7
40805: UNION
40806: DIFF
40807: PPUSH
40808: LD_INT 3
40810: PPUSH
40811: CALL 103885 0 2
40815: ST_TO_ADDR
// p := [ ] ;
40816: LD_ADDR_VAR 0 11
40820: PUSH
40821: EMPTY
40822: ST_TO_ADDR
// if sort then
40823: LD_VAR 0 9
40827: IFFALSE 40943
// for i = 1 to 6 - mech do
40829: LD_ADDR_VAR 0 3
40833: PUSH
40834: DOUBLE
40835: LD_INT 1
40837: DEC
40838: ST_TO_ADDR
40839: LD_INT 6
40841: PUSH
40842: LD_VAR 0 7
40846: MINUS
40847: PUSH
40848: FOR_TO
40849: IFFALSE 40941
// begin if i = sort then
40851: LD_VAR 0 3
40855: PUSH
40856: LD_VAR 0 9
40860: EQUAL
40861: IFFALSE 40865
// break ;
40863: GO 40941
// if GetClass ( i ) = 3 then
40865: LD_VAR 0 3
40869: PPUSH
40870: CALL_OW 257
40874: PUSH
40875: LD_INT 3
40877: EQUAL
40878: IFFALSE 40882
// continue ;
40880: GO 40848
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40882: LD_ADDR_VAR 0 11
40886: PUSH
40887: LD_VAR 0 11
40891: PPUSH
40892: LD_VAR 0 11
40896: PUSH
40897: LD_INT 1
40899: PLUS
40900: PPUSH
40901: LD_VAR 0 9
40905: PUSH
40906: LD_VAR 0 3
40910: ARRAY
40911: PPUSH
40912: CALL_OW 2
40916: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40917: LD_ADDR_VAR 0 4
40921: PUSH
40922: LD_VAR 0 4
40926: PUSH
40927: LD_VAR 0 9
40931: PUSH
40932: LD_VAR 0 3
40936: ARRAY
40937: DIFF
40938: ST_TO_ADDR
// end ;
40939: GO 40848
40941: POP
40942: POP
// if p then
40943: LD_VAR 0 11
40947: IFFALSE 40972
// result := Replace ( result , 3 , p ) ;
40949: LD_ADDR_VAR 0 2
40953: PUSH
40954: LD_VAR 0 2
40958: PPUSH
40959: LD_INT 3
40961: PPUSH
40962: LD_VAR 0 11
40966: PPUSH
40967: CALL_OW 1
40971: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40972: LD_ADDR_VAR 0 4
40976: PUSH
40977: LD_VAR 0 4
40981: PUSH
40982: LD_VAR 0 6
40986: DIFF
40987: ST_TO_ADDR
// if tmp and eng < 6 then
40988: LD_VAR 0 4
40992: PUSH
40993: LD_VAR 0 6
40997: PUSH
40998: LD_INT 6
41000: LESS
41001: AND
41002: IFFALSE 41196
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41004: LD_ADDR_VAR 0 9
41008: PUSH
41009: LD_VAR 0 4
41013: PUSH
41014: LD_VAR 0 8
41018: PUSH
41019: LD_VAR 0 7
41023: UNION
41024: PUSH
41025: LD_VAR 0 6
41029: UNION
41030: DIFF
41031: PPUSH
41032: LD_INT 2
41034: PPUSH
41035: CALL 103885 0 2
41039: ST_TO_ADDR
// p := [ ] ;
41040: LD_ADDR_VAR 0 11
41044: PUSH
41045: EMPTY
41046: ST_TO_ADDR
// if sort then
41047: LD_VAR 0 9
41051: IFFALSE 41167
// for i = 1 to 6 - eng do
41053: LD_ADDR_VAR 0 3
41057: PUSH
41058: DOUBLE
41059: LD_INT 1
41061: DEC
41062: ST_TO_ADDR
41063: LD_INT 6
41065: PUSH
41066: LD_VAR 0 6
41070: MINUS
41071: PUSH
41072: FOR_TO
41073: IFFALSE 41165
// begin if i = sort then
41075: LD_VAR 0 3
41079: PUSH
41080: LD_VAR 0 9
41084: EQUAL
41085: IFFALSE 41089
// break ;
41087: GO 41165
// if GetClass ( i ) = 2 then
41089: LD_VAR 0 3
41093: PPUSH
41094: CALL_OW 257
41098: PUSH
41099: LD_INT 2
41101: EQUAL
41102: IFFALSE 41106
// continue ;
41104: GO 41072
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41106: LD_ADDR_VAR 0 11
41110: PUSH
41111: LD_VAR 0 11
41115: PPUSH
41116: LD_VAR 0 11
41120: PUSH
41121: LD_INT 1
41123: PLUS
41124: PPUSH
41125: LD_VAR 0 9
41129: PUSH
41130: LD_VAR 0 3
41134: ARRAY
41135: PPUSH
41136: CALL_OW 2
41140: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41141: LD_ADDR_VAR 0 4
41145: PUSH
41146: LD_VAR 0 4
41150: PUSH
41151: LD_VAR 0 9
41155: PUSH
41156: LD_VAR 0 3
41160: ARRAY
41161: DIFF
41162: ST_TO_ADDR
// end ;
41163: GO 41072
41165: POP
41166: POP
// if p then
41167: LD_VAR 0 11
41171: IFFALSE 41196
// result := Replace ( result , 2 , p ) ;
41173: LD_ADDR_VAR 0 2
41177: PUSH
41178: LD_VAR 0 2
41182: PPUSH
41183: LD_INT 2
41185: PPUSH
41186: LD_VAR 0 11
41190: PPUSH
41191: CALL_OW 1
41195: ST_TO_ADDR
// end ; exit ;
41196: GO 41920
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41198: LD_EXP 126
41202: PUSH
41203: LD_EXP 125
41207: PUSH
41208: LD_VAR 0 1
41212: ARRAY
41213: ARRAY
41214: NOT
41215: PUSH
41216: LD_EXP 99
41220: PUSH
41221: LD_VAR 0 1
41225: ARRAY
41226: PPUSH
41227: LD_INT 30
41229: PUSH
41230: LD_INT 3
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PPUSH
41237: CALL_OW 72
41241: AND
41242: PUSH
41243: LD_EXP 104
41247: PUSH
41248: LD_VAR 0 1
41252: ARRAY
41253: NOT
41254: AND
41255: IFFALSE 41920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41257: LD_ADDR_EXP 141
41261: PUSH
41262: LD_EXP 141
41266: PPUSH
41267: LD_VAR 0 1
41271: PPUSH
41272: LD_INT 6
41274: PPUSH
41275: CALL_OW 1
41279: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41280: LD_ADDR_VAR 0 2
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: LD_INT 0
41290: PUSH
41291: LD_INT 0
41293: PUSH
41294: LD_INT 0
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: LIST
41302: ST_TO_ADDR
// if sci >= 1 then
41303: LD_VAR 0 8
41307: PUSH
41308: LD_INT 1
41310: GREATEREQUAL
41311: IFFALSE 41333
// tmp := tmp diff sci [ 1 ] ;
41313: LD_ADDR_VAR 0 4
41317: PUSH
41318: LD_VAR 0 4
41322: PUSH
41323: LD_VAR 0 8
41327: PUSH
41328: LD_INT 1
41330: ARRAY
41331: DIFF
41332: ST_TO_ADDR
// if tmp and not sci then
41333: LD_VAR 0 4
41337: PUSH
41338: LD_VAR 0 8
41342: NOT
41343: AND
41344: IFFALSE 41413
// begin sort := SortBySkill ( tmp , 4 ) ;
41346: LD_ADDR_VAR 0 9
41350: PUSH
41351: LD_VAR 0 4
41355: PPUSH
41356: LD_INT 4
41358: PPUSH
41359: CALL 103885 0 2
41363: ST_TO_ADDR
// if sort then
41364: LD_VAR 0 9
41368: IFFALSE 41384
// p := sort [ 1 ] ;
41370: LD_ADDR_VAR 0 11
41374: PUSH
41375: LD_VAR 0 9
41379: PUSH
41380: LD_INT 1
41382: ARRAY
41383: ST_TO_ADDR
// if p then
41384: LD_VAR 0 11
41388: IFFALSE 41413
// result := Replace ( result , 4 , p ) ;
41390: LD_ADDR_VAR 0 2
41394: PUSH
41395: LD_VAR 0 2
41399: PPUSH
41400: LD_INT 4
41402: PPUSH
41403: LD_VAR 0 11
41407: PPUSH
41408: CALL_OW 1
41412: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41413: LD_ADDR_VAR 0 4
41417: PUSH
41418: LD_VAR 0 4
41422: PUSH
41423: LD_VAR 0 7
41427: DIFF
41428: ST_TO_ADDR
// if tmp and mech < 6 then
41429: LD_VAR 0 4
41433: PUSH
41434: LD_VAR 0 7
41438: PUSH
41439: LD_INT 6
41441: LESS
41442: AND
41443: IFFALSE 41625
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41445: LD_ADDR_VAR 0 9
41449: PUSH
41450: LD_VAR 0 4
41454: PUSH
41455: LD_VAR 0 7
41459: DIFF
41460: PPUSH
41461: LD_INT 3
41463: PPUSH
41464: CALL 103885 0 2
41468: ST_TO_ADDR
// p := [ ] ;
41469: LD_ADDR_VAR 0 11
41473: PUSH
41474: EMPTY
41475: ST_TO_ADDR
// if sort then
41476: LD_VAR 0 9
41480: IFFALSE 41596
// for i = 1 to 6 - mech do
41482: LD_ADDR_VAR 0 3
41486: PUSH
41487: DOUBLE
41488: LD_INT 1
41490: DEC
41491: ST_TO_ADDR
41492: LD_INT 6
41494: PUSH
41495: LD_VAR 0 7
41499: MINUS
41500: PUSH
41501: FOR_TO
41502: IFFALSE 41594
// begin if i = sort then
41504: LD_VAR 0 3
41508: PUSH
41509: LD_VAR 0 9
41513: EQUAL
41514: IFFALSE 41518
// break ;
41516: GO 41594
// if GetClass ( i ) = 3 then
41518: LD_VAR 0 3
41522: PPUSH
41523: CALL_OW 257
41527: PUSH
41528: LD_INT 3
41530: EQUAL
41531: IFFALSE 41535
// continue ;
41533: GO 41501
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41535: LD_ADDR_VAR 0 11
41539: PUSH
41540: LD_VAR 0 11
41544: PPUSH
41545: LD_VAR 0 11
41549: PUSH
41550: LD_INT 1
41552: PLUS
41553: PPUSH
41554: LD_VAR 0 9
41558: PUSH
41559: LD_VAR 0 3
41563: ARRAY
41564: PPUSH
41565: CALL_OW 2
41569: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41570: LD_ADDR_VAR 0 4
41574: PUSH
41575: LD_VAR 0 4
41579: PUSH
41580: LD_VAR 0 9
41584: PUSH
41585: LD_VAR 0 3
41589: ARRAY
41590: DIFF
41591: ST_TO_ADDR
// end ;
41592: GO 41501
41594: POP
41595: POP
// if p then
41596: LD_VAR 0 11
41600: IFFALSE 41625
// result := Replace ( result , 3 , p ) ;
41602: LD_ADDR_VAR 0 2
41606: PUSH
41607: LD_VAR 0 2
41611: PPUSH
41612: LD_INT 3
41614: PPUSH
41615: LD_VAR 0 11
41619: PPUSH
41620: CALL_OW 1
41624: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41625: LD_ADDR_VAR 0 4
41629: PUSH
41630: LD_VAR 0 4
41634: PUSH
41635: LD_VAR 0 6
41639: DIFF
41640: ST_TO_ADDR
// if tmp and eng < 4 then
41641: LD_VAR 0 4
41645: PUSH
41646: LD_VAR 0 6
41650: PUSH
41651: LD_INT 4
41653: LESS
41654: AND
41655: IFFALSE 41845
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41657: LD_ADDR_VAR 0 9
41661: PUSH
41662: LD_VAR 0 4
41666: PUSH
41667: LD_VAR 0 7
41671: PUSH
41672: LD_VAR 0 6
41676: UNION
41677: DIFF
41678: PPUSH
41679: LD_INT 2
41681: PPUSH
41682: CALL 103885 0 2
41686: ST_TO_ADDR
// p := [ ] ;
41687: LD_ADDR_VAR 0 11
41691: PUSH
41692: EMPTY
41693: ST_TO_ADDR
// if sort then
41694: LD_VAR 0 9
41698: IFFALSE 41814
// for i = 1 to 4 - eng do
41700: LD_ADDR_VAR 0 3
41704: PUSH
41705: DOUBLE
41706: LD_INT 1
41708: DEC
41709: ST_TO_ADDR
41710: LD_INT 4
41712: PUSH
41713: LD_VAR 0 6
41717: MINUS
41718: PUSH
41719: FOR_TO
41720: IFFALSE 41812
// begin if i = sort then
41722: LD_VAR 0 3
41726: PUSH
41727: LD_VAR 0 9
41731: EQUAL
41732: IFFALSE 41736
// break ;
41734: GO 41812
// if GetClass ( i ) = 2 then
41736: LD_VAR 0 3
41740: PPUSH
41741: CALL_OW 257
41745: PUSH
41746: LD_INT 2
41748: EQUAL
41749: IFFALSE 41753
// continue ;
41751: GO 41719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41753: LD_ADDR_VAR 0 11
41757: PUSH
41758: LD_VAR 0 11
41762: PPUSH
41763: LD_VAR 0 11
41767: PUSH
41768: LD_INT 1
41770: PLUS
41771: PPUSH
41772: LD_VAR 0 9
41776: PUSH
41777: LD_VAR 0 3
41781: ARRAY
41782: PPUSH
41783: CALL_OW 2
41787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41788: LD_ADDR_VAR 0 4
41792: PUSH
41793: LD_VAR 0 4
41797: PUSH
41798: LD_VAR 0 9
41802: PUSH
41803: LD_VAR 0 3
41807: ARRAY
41808: DIFF
41809: ST_TO_ADDR
// end ;
41810: GO 41719
41812: POP
41813: POP
// if p then
41814: LD_VAR 0 11
41818: IFFALSE 41843
// result := Replace ( result , 2 , p ) ;
41820: LD_ADDR_VAR 0 2
41824: PUSH
41825: LD_VAR 0 2
41829: PPUSH
41830: LD_INT 2
41832: PPUSH
41833: LD_VAR 0 11
41837: PPUSH
41838: CALL_OW 1
41842: ST_TO_ADDR
// end else
41843: GO 41889
// for i = eng downto 5 do
41845: LD_ADDR_VAR 0 3
41849: PUSH
41850: DOUBLE
41851: LD_VAR 0 6
41855: INC
41856: ST_TO_ADDR
41857: LD_INT 5
41859: PUSH
41860: FOR_DOWNTO
41861: IFFALSE 41887
// tmp := tmp union eng [ i ] ;
41863: LD_ADDR_VAR 0 4
41867: PUSH
41868: LD_VAR 0 4
41872: PUSH
41873: LD_VAR 0 6
41877: PUSH
41878: LD_VAR 0 3
41882: ARRAY
41883: UNION
41884: ST_TO_ADDR
41885: GO 41860
41887: POP
41888: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41889: LD_ADDR_VAR 0 2
41893: PUSH
41894: LD_VAR 0 2
41898: PPUSH
41899: LD_INT 1
41901: PPUSH
41902: LD_VAR 0 4
41906: PUSH
41907: LD_VAR 0 5
41911: DIFF
41912: PPUSH
41913: CALL_OW 1
41917: ST_TO_ADDR
// exit ;
41918: GO 41920
// end ; end ;
41920: LD_VAR 0 2
41924: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
41925: LD_INT 0
41927: PPUSH
41928: PPUSH
41929: PPUSH
// if not mc_bases then
41930: LD_EXP 99
41934: NOT
41935: IFFALSE 41939
// exit ;
41937: GO 42045
// for i = 1 to mc_bases do
41939: LD_ADDR_VAR 0 2
41943: PUSH
41944: DOUBLE
41945: LD_INT 1
41947: DEC
41948: ST_TO_ADDR
41949: LD_EXP 99
41953: PUSH
41954: FOR_TO
41955: IFFALSE 42036
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41957: LD_ADDR_VAR 0 3
41961: PUSH
41962: LD_EXP 99
41966: PUSH
41967: LD_VAR 0 2
41971: ARRAY
41972: PPUSH
41973: LD_INT 21
41975: PUSH
41976: LD_INT 3
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: LD_INT 3
41985: PUSH
41986: LD_INT 24
41988: PUSH
41989: LD_INT 1000
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PPUSH
42004: CALL_OW 72
42008: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42009: LD_ADDR_EXP 100
42013: PUSH
42014: LD_EXP 100
42018: PPUSH
42019: LD_VAR 0 2
42023: PPUSH
42024: LD_VAR 0 3
42028: PPUSH
42029: CALL_OW 1
42033: ST_TO_ADDR
// end ;
42034: GO 41954
42036: POP
42037: POP
// RaiseSailEvent ( 101 ) ;
42038: LD_INT 101
42040: PPUSH
42041: CALL_OW 427
// end ;
42045: LD_VAR 0 1
42049: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42050: LD_INT 0
42052: PPUSH
42053: PPUSH
42054: PPUSH
42055: PPUSH
42056: PPUSH
42057: PPUSH
42058: PPUSH
// if not mc_bases then
42059: LD_EXP 99
42063: NOT
42064: IFFALSE 42068
// exit ;
42066: GO 42641
// for i = 1 to mc_bases do
42068: LD_ADDR_VAR 0 2
42072: PUSH
42073: DOUBLE
42074: LD_INT 1
42076: DEC
42077: ST_TO_ADDR
42078: LD_EXP 99
42082: PUSH
42083: FOR_TO
42084: IFFALSE 42632
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42086: LD_ADDR_VAR 0 5
42090: PUSH
42091: LD_EXP 99
42095: PUSH
42096: LD_VAR 0 2
42100: ARRAY
42101: PUSH
42102: LD_EXP 128
42106: PUSH
42107: LD_VAR 0 2
42111: ARRAY
42112: UNION
42113: PPUSH
42114: LD_INT 21
42116: PUSH
42117: LD_INT 1
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 1
42126: PUSH
42127: LD_INT 3
42129: PUSH
42130: LD_INT 54
42132: PUSH
42133: EMPTY
42134: LIST
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 3
42142: PUSH
42143: LD_INT 24
42145: PUSH
42146: LD_INT 800
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: LIST
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PPUSH
42166: CALL_OW 72
42170: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42171: LD_ADDR_VAR 0 6
42175: PUSH
42176: LD_EXP 99
42180: PUSH
42181: LD_VAR 0 2
42185: ARRAY
42186: PPUSH
42187: LD_INT 21
42189: PUSH
42190: LD_INT 1
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 1
42199: PUSH
42200: LD_INT 3
42202: PUSH
42203: LD_INT 54
42205: PUSH
42206: EMPTY
42207: LIST
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: PUSH
42216: LD_INT 24
42218: PUSH
42219: LD_INT 250
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: LIST
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PPUSH
42239: CALL_OW 72
42243: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42244: LD_ADDR_VAR 0 7
42248: PUSH
42249: LD_VAR 0 5
42253: PUSH
42254: LD_VAR 0 6
42258: DIFF
42259: ST_TO_ADDR
// if not need_heal_1 then
42260: LD_VAR 0 6
42264: NOT
42265: IFFALSE 42298
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42267: LD_ADDR_EXP 102
42271: PUSH
42272: LD_EXP 102
42276: PPUSH
42277: LD_VAR 0 2
42281: PUSH
42282: LD_INT 1
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PPUSH
42289: EMPTY
42290: PPUSH
42291: CALL 69637 0 3
42295: ST_TO_ADDR
42296: GO 42368
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42298: LD_ADDR_EXP 102
42302: PUSH
42303: LD_EXP 102
42307: PPUSH
42308: LD_VAR 0 2
42312: PUSH
42313: LD_INT 1
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PPUSH
42320: LD_EXP 102
42324: PUSH
42325: LD_VAR 0 2
42329: ARRAY
42330: PUSH
42331: LD_INT 1
42333: ARRAY
42334: PPUSH
42335: LD_INT 3
42337: PUSH
42338: LD_INT 24
42340: PUSH
42341: LD_INT 1000
42343: PUSH
42344: EMPTY
42345: LIST
42346: LIST
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PPUSH
42352: CALL_OW 72
42356: PUSH
42357: LD_VAR 0 6
42361: UNION
42362: PPUSH
42363: CALL 69637 0 3
42367: ST_TO_ADDR
// if not need_heal_2 then
42368: LD_VAR 0 7
42372: NOT
42373: IFFALSE 42406
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42375: LD_ADDR_EXP 102
42379: PUSH
42380: LD_EXP 102
42384: PPUSH
42385: LD_VAR 0 2
42389: PUSH
42390: LD_INT 2
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PPUSH
42397: EMPTY
42398: PPUSH
42399: CALL 69637 0 3
42403: ST_TO_ADDR
42404: GO 42438
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42406: LD_ADDR_EXP 102
42410: PUSH
42411: LD_EXP 102
42415: PPUSH
42416: LD_VAR 0 2
42420: PUSH
42421: LD_INT 2
42423: PUSH
42424: EMPTY
42425: LIST
42426: LIST
42427: PPUSH
42428: LD_VAR 0 7
42432: PPUSH
42433: CALL 69637 0 3
42437: ST_TO_ADDR
// if need_heal_2 then
42438: LD_VAR 0 7
42442: IFFALSE 42614
// for j in need_heal_2 do
42444: LD_ADDR_VAR 0 3
42448: PUSH
42449: LD_VAR 0 7
42453: PUSH
42454: FOR_IN
42455: IFFALSE 42612
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42457: LD_ADDR_VAR 0 5
42461: PUSH
42462: LD_EXP 99
42466: PUSH
42467: LD_VAR 0 2
42471: ARRAY
42472: PPUSH
42473: LD_INT 2
42475: PUSH
42476: LD_INT 30
42478: PUSH
42479: LD_INT 6
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: LD_INT 30
42488: PUSH
42489: LD_INT 7
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 30
42498: PUSH
42499: LD_INT 8
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 30
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 30
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 25
42528: PUSH
42529: LD_INT 4
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: PPUSH
42545: CALL_OW 72
42549: ST_TO_ADDR
// if tmp then
42550: LD_VAR 0 5
42554: IFFALSE 42610
// begin k := NearestUnitToUnit ( tmp , j ) ;
42556: LD_ADDR_VAR 0 4
42560: PUSH
42561: LD_VAR 0 5
42565: PPUSH
42566: LD_VAR 0 3
42570: PPUSH
42571: CALL_OW 74
42575: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42576: LD_VAR 0 3
42580: PPUSH
42581: LD_VAR 0 4
42585: PPUSH
42586: CALL_OW 296
42590: PUSH
42591: LD_INT 7
42593: GREATER
42594: IFFALSE 42610
// ComMoveUnit ( j , k ) ;
42596: LD_VAR 0 3
42600: PPUSH
42601: LD_VAR 0 4
42605: PPUSH
42606: CALL_OW 112
// end ; end ;
42610: GO 42454
42612: POP
42613: POP
// if not need_heal_1 and not need_heal_2 then
42614: LD_VAR 0 6
42618: NOT
42619: PUSH
42620: LD_VAR 0 7
42624: NOT
42625: AND
42626: IFFALSE 42630
// continue ;
42628: GO 42083
// end ;
42630: GO 42083
42632: POP
42633: POP
// RaiseSailEvent ( 102 ) ;
42634: LD_INT 102
42636: PPUSH
42637: CALL_OW 427
// end ;
42641: LD_VAR 0 1
42645: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
42646: LD_INT 0
42648: PPUSH
42649: PPUSH
42650: PPUSH
42651: PPUSH
42652: PPUSH
// if not mc_bases then
42653: LD_EXP 99
42657: NOT
42658: IFFALSE 42662
// exit ;
42660: GO 43047
// for i = 1 to mc_bases do
42662: LD_ADDR_VAR 0 2
42666: PUSH
42667: DOUBLE
42668: LD_INT 1
42670: DEC
42671: ST_TO_ADDR
42672: LD_EXP 99
42676: PUSH
42677: FOR_TO
42678: IFFALSE 43045
// begin if not mc_building_need_repair [ i ] then
42680: LD_EXP 100
42684: PUSH
42685: LD_VAR 0 2
42689: ARRAY
42690: NOT
42691: IFFALSE 42729
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42693: LD_ADDR_EXP 101
42697: PUSH
42698: LD_EXP 101
42702: PPUSH
42703: LD_VAR 0 2
42707: PPUSH
42708: EMPTY
42709: PPUSH
42710: CALL_OW 1
42714: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42715: LD_VAR 0 2
42719: PPUSH
42720: LD_INT 101
42722: PPUSH
42723: CALL 37767 0 2
// continue ;
42727: GO 42677
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42729: LD_ADDR_EXP 105
42733: PUSH
42734: LD_EXP 105
42738: PPUSH
42739: LD_VAR 0 2
42743: PPUSH
42744: EMPTY
42745: PPUSH
42746: CALL_OW 1
42750: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42751: LD_VAR 0 2
42755: PPUSH
42756: LD_INT 103
42758: PPUSH
42759: CALL 37767 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
42763: LD_ADDR_VAR 0 5
42767: PUSH
42768: LD_EXP 99
42772: PUSH
42773: LD_VAR 0 2
42777: ARRAY
42778: PUSH
42779: LD_EXP 128
42783: PUSH
42784: LD_VAR 0 2
42788: ARRAY
42789: UNION
42790: PPUSH
42791: LD_INT 2
42793: PUSH
42794: LD_INT 25
42796: PUSH
42797: LD_INT 2
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 25
42806: PUSH
42807: LD_INT 16
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: LIST
42818: PUSH
42819: EMPTY
42820: LIST
42821: PPUSH
42822: CALL_OW 72
42826: ST_TO_ADDR
// if not tmp then
42827: LD_VAR 0 5
42831: NOT
42832: IFFALSE 42836
// continue ;
42834: GO 42677
// for j in tmp do
42836: LD_ADDR_VAR 0 3
42840: PUSH
42841: LD_VAR 0 5
42845: PUSH
42846: FOR_IN
42847: IFFALSE 43041
// begin if mc_need_heal [ i ] then
42849: LD_EXP 102
42853: PUSH
42854: LD_VAR 0 2
42858: ARRAY
42859: IFFALSE 42907
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
42861: LD_VAR 0 3
42865: PUSH
42866: LD_EXP 102
42870: PUSH
42871: LD_VAR 0 2
42875: ARRAY
42876: PUSH
42877: LD_INT 1
42879: ARRAY
42880: IN
42881: PUSH
42882: LD_VAR 0 3
42886: PUSH
42887: LD_EXP 102
42891: PUSH
42892: LD_VAR 0 2
42896: ARRAY
42897: PUSH
42898: LD_INT 2
42900: ARRAY
42901: IN
42902: OR
42903: IFFALSE 42907
// continue ;
42905: GO 42846
// if IsInUnit ( j ) then
42907: LD_VAR 0 3
42911: PPUSH
42912: CALL_OW 310
42916: IFFALSE 42927
// ComExitBuilding ( j ) ;
42918: LD_VAR 0 3
42922: PPUSH
42923: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
42927: LD_VAR 0 3
42931: PUSH
42932: LD_EXP 101
42936: PUSH
42937: LD_VAR 0 2
42941: ARRAY
42942: IN
42943: NOT
42944: IFFALSE 43002
// begin SetTag ( j , 101 ) ;
42946: LD_VAR 0 3
42950: PPUSH
42951: LD_INT 101
42953: PPUSH
42954: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
42958: LD_ADDR_EXP 101
42962: PUSH
42963: LD_EXP 101
42967: PPUSH
42968: LD_VAR 0 2
42972: PUSH
42973: LD_EXP 101
42977: PUSH
42978: LD_VAR 0 2
42982: ARRAY
42983: PUSH
42984: LD_INT 1
42986: PLUS
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: PPUSH
42992: LD_VAR 0 3
42996: PPUSH
42997: CALL 69637 0 3
43001: ST_TO_ADDR
// end ; wait ( 1 ) ;
43002: LD_INT 1
43004: PPUSH
43005: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43009: LD_VAR 0 3
43013: PPUSH
43014: LD_EXP 100
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PPUSH
43025: LD_VAR 0 3
43029: PPUSH
43030: CALL_OW 74
43034: PPUSH
43035: CALL_OW 130
// end ;
43039: GO 42846
43041: POP
43042: POP
// end ;
43043: GO 42677
43045: POP
43046: POP
// end ;
43047: LD_VAR 0 1
43051: RET
// export function MC_Heal ; var i , j , tmp ; begin
43052: LD_INT 0
43054: PPUSH
43055: PPUSH
43056: PPUSH
43057: PPUSH
// if not mc_bases then
43058: LD_EXP 99
43062: NOT
43063: IFFALSE 43067
// exit ;
43065: GO 43469
// for i = 1 to mc_bases do
43067: LD_ADDR_VAR 0 2
43071: PUSH
43072: DOUBLE
43073: LD_INT 1
43075: DEC
43076: ST_TO_ADDR
43077: LD_EXP 99
43081: PUSH
43082: FOR_TO
43083: IFFALSE 43467
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43085: LD_EXP 102
43089: PUSH
43090: LD_VAR 0 2
43094: ARRAY
43095: PUSH
43096: LD_INT 1
43098: ARRAY
43099: NOT
43100: PUSH
43101: LD_EXP 102
43105: PUSH
43106: LD_VAR 0 2
43110: ARRAY
43111: PUSH
43112: LD_INT 2
43114: ARRAY
43115: NOT
43116: AND
43117: IFFALSE 43155
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43119: LD_ADDR_EXP 103
43123: PUSH
43124: LD_EXP 103
43128: PPUSH
43129: LD_VAR 0 2
43133: PPUSH
43134: EMPTY
43135: PPUSH
43136: CALL_OW 1
43140: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43141: LD_VAR 0 2
43145: PPUSH
43146: LD_INT 102
43148: PPUSH
43149: CALL 37767 0 2
// continue ;
43153: GO 43082
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43155: LD_ADDR_VAR 0 4
43159: PUSH
43160: LD_EXP 99
43164: PUSH
43165: LD_VAR 0 2
43169: ARRAY
43170: PPUSH
43171: LD_INT 25
43173: PUSH
43174: LD_INT 4
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PPUSH
43181: CALL_OW 72
43185: ST_TO_ADDR
// if not tmp then
43186: LD_VAR 0 4
43190: NOT
43191: IFFALSE 43195
// continue ;
43193: GO 43082
// if mc_taming [ i ] then
43195: LD_EXP 130
43199: PUSH
43200: LD_VAR 0 2
43204: ARRAY
43205: IFFALSE 43229
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43207: LD_ADDR_EXP 130
43211: PUSH
43212: LD_EXP 130
43216: PPUSH
43217: LD_VAR 0 2
43221: PPUSH
43222: EMPTY
43223: PPUSH
43224: CALL_OW 1
43228: ST_TO_ADDR
// for j in tmp do
43229: LD_ADDR_VAR 0 3
43233: PUSH
43234: LD_VAR 0 4
43238: PUSH
43239: FOR_IN
43240: IFFALSE 43463
// begin if IsInUnit ( j ) then
43242: LD_VAR 0 3
43246: PPUSH
43247: CALL_OW 310
43251: IFFALSE 43262
// ComExitBuilding ( j ) ;
43253: LD_VAR 0 3
43257: PPUSH
43258: CALL_OW 122
// if not j in mc_healers [ i ] then
43262: LD_VAR 0 3
43266: PUSH
43267: LD_EXP 103
43271: PUSH
43272: LD_VAR 0 2
43276: ARRAY
43277: IN
43278: NOT
43279: IFFALSE 43325
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43281: LD_ADDR_EXP 103
43285: PUSH
43286: LD_EXP 103
43290: PPUSH
43291: LD_VAR 0 2
43295: PUSH
43296: LD_EXP 103
43300: PUSH
43301: LD_VAR 0 2
43305: ARRAY
43306: PUSH
43307: LD_INT 1
43309: PLUS
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PPUSH
43315: LD_VAR 0 3
43319: PPUSH
43320: CALL 69637 0 3
43324: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43325: LD_VAR 0 3
43329: PPUSH
43330: CALL_OW 110
43334: PUSH
43335: LD_INT 102
43337: NONEQUAL
43338: IFFALSE 43352
// SetTag ( j , 102 ) ;
43340: LD_VAR 0 3
43344: PPUSH
43345: LD_INT 102
43347: PPUSH
43348: CALL_OW 109
// Wait ( 3 ) ;
43352: LD_INT 3
43354: PPUSH
43355: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43359: LD_EXP 102
43363: PUSH
43364: LD_VAR 0 2
43368: ARRAY
43369: PUSH
43370: LD_INT 1
43372: ARRAY
43373: IFFALSE 43405
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43375: LD_VAR 0 3
43379: PPUSH
43380: LD_EXP 102
43384: PUSH
43385: LD_VAR 0 2
43389: ARRAY
43390: PUSH
43391: LD_INT 1
43393: ARRAY
43394: PUSH
43395: LD_INT 1
43397: ARRAY
43398: PPUSH
43399: CALL_OW 128
43403: GO 43461
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43405: LD_VAR 0 3
43409: PPUSH
43410: CALL_OW 314
43414: NOT
43415: PUSH
43416: LD_EXP 102
43420: PUSH
43421: LD_VAR 0 2
43425: ARRAY
43426: PUSH
43427: LD_INT 2
43429: ARRAY
43430: AND
43431: IFFALSE 43461
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43433: LD_VAR 0 3
43437: PPUSH
43438: LD_EXP 102
43442: PUSH
43443: LD_VAR 0 2
43447: ARRAY
43448: PUSH
43449: LD_INT 2
43451: ARRAY
43452: PUSH
43453: LD_INT 1
43455: ARRAY
43456: PPUSH
43457: CALL_OW 128
// end ;
43461: GO 43239
43463: POP
43464: POP
// end ;
43465: GO 43082
43467: POP
43468: POP
// end ;
43469: LD_VAR 0 1
43473: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43474: LD_INT 0
43476: PPUSH
43477: PPUSH
43478: PPUSH
43479: PPUSH
43480: PPUSH
// if not mc_bases then
43481: LD_EXP 99
43485: NOT
43486: IFFALSE 43490
// exit ;
43488: GO 44633
// for i = 1 to mc_bases do
43490: LD_ADDR_VAR 0 2
43494: PUSH
43495: DOUBLE
43496: LD_INT 1
43498: DEC
43499: ST_TO_ADDR
43500: LD_EXP 99
43504: PUSH
43505: FOR_TO
43506: IFFALSE 44631
// begin if mc_scan [ i ] then
43508: LD_EXP 122
43512: PUSH
43513: LD_VAR 0 2
43517: ARRAY
43518: IFFALSE 43522
// continue ;
43520: GO 43505
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43522: LD_EXP 104
43526: PUSH
43527: LD_VAR 0 2
43531: ARRAY
43532: NOT
43533: PUSH
43534: LD_EXP 106
43538: PUSH
43539: LD_VAR 0 2
43543: ARRAY
43544: NOT
43545: AND
43546: PUSH
43547: LD_EXP 105
43551: PUSH
43552: LD_VAR 0 2
43556: ARRAY
43557: AND
43558: IFFALSE 43596
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43560: LD_ADDR_EXP 105
43564: PUSH
43565: LD_EXP 105
43569: PPUSH
43570: LD_VAR 0 2
43574: PPUSH
43575: EMPTY
43576: PPUSH
43577: CALL_OW 1
43581: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43582: LD_VAR 0 2
43586: PPUSH
43587: LD_INT 103
43589: PPUSH
43590: CALL 37767 0 2
// continue ;
43594: GO 43505
// end ; if mc_construct_list [ i ] then
43596: LD_EXP 106
43600: PUSH
43601: LD_VAR 0 2
43605: ARRAY
43606: IFFALSE 43826
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43608: LD_ADDR_VAR 0 4
43612: PUSH
43613: LD_EXP 99
43617: PUSH
43618: LD_VAR 0 2
43622: ARRAY
43623: PPUSH
43624: LD_INT 25
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PPUSH
43634: CALL_OW 72
43638: PUSH
43639: LD_EXP 101
43643: PUSH
43644: LD_VAR 0 2
43648: ARRAY
43649: DIFF
43650: ST_TO_ADDR
// if not tmp then
43651: LD_VAR 0 4
43655: NOT
43656: IFFALSE 43660
// continue ;
43658: GO 43505
// for j in tmp do
43660: LD_ADDR_VAR 0 3
43664: PUSH
43665: LD_VAR 0 4
43669: PUSH
43670: FOR_IN
43671: IFFALSE 43822
// begin if not mc_builders [ i ] then
43673: LD_EXP 105
43677: PUSH
43678: LD_VAR 0 2
43682: ARRAY
43683: NOT
43684: IFFALSE 43742
// begin SetTag ( j , 103 ) ;
43686: LD_VAR 0 3
43690: PPUSH
43691: LD_INT 103
43693: PPUSH
43694: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43698: LD_ADDR_EXP 105
43702: PUSH
43703: LD_EXP 105
43707: PPUSH
43708: LD_VAR 0 2
43712: PUSH
43713: LD_EXP 105
43717: PUSH
43718: LD_VAR 0 2
43722: ARRAY
43723: PUSH
43724: LD_INT 1
43726: PLUS
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PPUSH
43732: LD_VAR 0 3
43736: PPUSH
43737: CALL 69637 0 3
43741: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43742: LD_VAR 0 3
43746: PPUSH
43747: CALL_OW 310
43751: IFFALSE 43762
// ComExitBuilding ( j ) ;
43753: LD_VAR 0 3
43757: PPUSH
43758: CALL_OW 122
// wait ( 3 ) ;
43762: LD_INT 3
43764: PPUSH
43765: CALL_OW 67
// if not mc_construct_list [ i ] then
43769: LD_EXP 106
43773: PUSH
43774: LD_VAR 0 2
43778: ARRAY
43779: NOT
43780: IFFALSE 43784
// break ;
43782: GO 43822
// if not HasTask ( j ) then
43784: LD_VAR 0 3
43788: PPUSH
43789: CALL_OW 314
43793: NOT
43794: IFFALSE 43820
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
43796: LD_VAR 0 3
43800: PPUSH
43801: LD_EXP 106
43805: PUSH
43806: LD_VAR 0 2
43810: ARRAY
43811: PUSH
43812: LD_INT 1
43814: ARRAY
43815: PPUSH
43816: CALL 72488 0 2
// end ;
43820: GO 43670
43822: POP
43823: POP
// end else
43824: GO 44629
// if mc_build_list [ i ] then
43826: LD_EXP 104
43830: PUSH
43831: LD_VAR 0 2
43835: ARRAY
43836: IFFALSE 44629
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43838: LD_ADDR_VAR 0 5
43842: PUSH
43843: LD_EXP 99
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PPUSH
43854: LD_INT 2
43856: PUSH
43857: LD_INT 30
43859: PUSH
43860: LD_INT 0
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 30
43869: PUSH
43870: LD_INT 1
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: LIST
43881: PPUSH
43882: CALL_OW 72
43886: ST_TO_ADDR
// if depot then
43887: LD_VAR 0 5
43891: IFFALSE 43909
// depot := depot [ 1 ] else
43893: LD_ADDR_VAR 0 5
43897: PUSH
43898: LD_VAR 0 5
43902: PUSH
43903: LD_INT 1
43905: ARRAY
43906: ST_TO_ADDR
43907: GO 43917
// depot := 0 ;
43909: LD_ADDR_VAR 0 5
43913: PUSH
43914: LD_INT 0
43916: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
43917: LD_EXP 104
43921: PUSH
43922: LD_VAR 0 2
43926: ARRAY
43927: PUSH
43928: LD_INT 1
43930: ARRAY
43931: PUSH
43932: LD_INT 1
43934: ARRAY
43935: PPUSH
43936: CALL 72318 0 1
43940: PUSH
43941: LD_EXP 99
43945: PUSH
43946: LD_VAR 0 2
43950: ARRAY
43951: PPUSH
43952: LD_INT 2
43954: PUSH
43955: LD_INT 30
43957: PUSH
43958: LD_INT 2
43960: PUSH
43961: EMPTY
43962: LIST
43963: LIST
43964: PUSH
43965: LD_INT 30
43967: PUSH
43968: LD_INT 3
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: LIST
43979: PPUSH
43980: CALL_OW 72
43984: NOT
43985: AND
43986: IFFALSE 44091
// begin for j = 1 to mc_build_list [ i ] do
43988: LD_ADDR_VAR 0 3
43992: PUSH
43993: DOUBLE
43994: LD_INT 1
43996: DEC
43997: ST_TO_ADDR
43998: LD_EXP 104
44002: PUSH
44003: LD_VAR 0 2
44007: ARRAY
44008: PUSH
44009: FOR_TO
44010: IFFALSE 44089
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44012: LD_EXP 104
44016: PUSH
44017: LD_VAR 0 2
44021: ARRAY
44022: PUSH
44023: LD_VAR 0 3
44027: ARRAY
44028: PUSH
44029: LD_INT 1
44031: ARRAY
44032: PUSH
44033: LD_INT 2
44035: EQUAL
44036: IFFALSE 44087
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44038: LD_ADDR_EXP 104
44042: PUSH
44043: LD_EXP 104
44047: PPUSH
44048: LD_VAR 0 2
44052: PPUSH
44053: LD_EXP 104
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: PPUSH
44064: LD_VAR 0 3
44068: PPUSH
44069: LD_INT 1
44071: PPUSH
44072: LD_INT 0
44074: PPUSH
44075: CALL 69055 0 4
44079: PPUSH
44080: CALL_OW 1
44084: ST_TO_ADDR
// break ;
44085: GO 44089
// end ;
44087: GO 44009
44089: POP
44090: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44091: LD_EXP 104
44095: PUSH
44096: LD_VAR 0 2
44100: ARRAY
44101: PUSH
44102: LD_INT 1
44104: ARRAY
44105: PUSH
44106: LD_INT 1
44108: ARRAY
44109: PUSH
44110: LD_INT 0
44112: EQUAL
44113: PUSH
44114: LD_VAR 0 5
44118: PUSH
44119: LD_VAR 0 5
44123: PPUSH
44124: LD_EXP 104
44128: PUSH
44129: LD_VAR 0 2
44133: ARRAY
44134: PUSH
44135: LD_INT 1
44137: ARRAY
44138: PUSH
44139: LD_INT 1
44141: ARRAY
44142: PPUSH
44143: LD_EXP 104
44147: PUSH
44148: LD_VAR 0 2
44152: ARRAY
44153: PUSH
44154: LD_INT 1
44156: ARRAY
44157: PUSH
44158: LD_INT 2
44160: ARRAY
44161: PPUSH
44162: LD_EXP 104
44166: PUSH
44167: LD_VAR 0 2
44171: ARRAY
44172: PUSH
44173: LD_INT 1
44175: ARRAY
44176: PUSH
44177: LD_INT 3
44179: ARRAY
44180: PPUSH
44181: LD_EXP 104
44185: PUSH
44186: LD_VAR 0 2
44190: ARRAY
44191: PUSH
44192: LD_INT 1
44194: ARRAY
44195: PUSH
44196: LD_INT 4
44198: ARRAY
44199: PPUSH
44200: CALL 77052 0 5
44204: AND
44205: OR
44206: IFFALSE 44487
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44208: LD_ADDR_VAR 0 4
44212: PUSH
44213: LD_EXP 99
44217: PUSH
44218: LD_VAR 0 2
44222: ARRAY
44223: PPUSH
44224: LD_INT 25
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PPUSH
44234: CALL_OW 72
44238: PUSH
44239: LD_EXP 101
44243: PUSH
44244: LD_VAR 0 2
44248: ARRAY
44249: DIFF
44250: ST_TO_ADDR
// if not tmp then
44251: LD_VAR 0 4
44255: NOT
44256: IFFALSE 44260
// continue ;
44258: GO 43505
// for j in tmp do
44260: LD_ADDR_VAR 0 3
44264: PUSH
44265: LD_VAR 0 4
44269: PUSH
44270: FOR_IN
44271: IFFALSE 44483
// begin if not mc_builders [ i ] then
44273: LD_EXP 105
44277: PUSH
44278: LD_VAR 0 2
44282: ARRAY
44283: NOT
44284: IFFALSE 44342
// begin SetTag ( j , 103 ) ;
44286: LD_VAR 0 3
44290: PPUSH
44291: LD_INT 103
44293: PPUSH
44294: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44298: LD_ADDR_EXP 105
44302: PUSH
44303: LD_EXP 105
44307: PPUSH
44308: LD_VAR 0 2
44312: PUSH
44313: LD_EXP 105
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PUSH
44324: LD_INT 1
44326: PLUS
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PPUSH
44332: LD_VAR 0 3
44336: PPUSH
44337: CALL 69637 0 3
44341: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44342: LD_VAR 0 3
44346: PPUSH
44347: CALL_OW 310
44351: IFFALSE 44362
// ComExitBuilding ( j ) ;
44353: LD_VAR 0 3
44357: PPUSH
44358: CALL_OW 122
// wait ( 3 ) ;
44362: LD_INT 3
44364: PPUSH
44365: CALL_OW 67
// if not mc_build_list [ i ] then
44369: LD_EXP 104
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: NOT
44380: IFFALSE 44384
// break ;
44382: GO 44483
// if not HasTask ( j ) then
44384: LD_VAR 0 3
44388: PPUSH
44389: CALL_OW 314
44393: NOT
44394: IFFALSE 44481
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44396: LD_VAR 0 3
44400: PPUSH
44401: LD_EXP 104
44405: PUSH
44406: LD_VAR 0 2
44410: ARRAY
44411: PUSH
44412: LD_INT 1
44414: ARRAY
44415: PUSH
44416: LD_INT 1
44418: ARRAY
44419: PPUSH
44420: LD_EXP 104
44424: PUSH
44425: LD_VAR 0 2
44429: ARRAY
44430: PUSH
44431: LD_INT 1
44433: ARRAY
44434: PUSH
44435: LD_INT 2
44437: ARRAY
44438: PPUSH
44439: LD_EXP 104
44443: PUSH
44444: LD_VAR 0 2
44448: ARRAY
44449: PUSH
44450: LD_INT 1
44452: ARRAY
44453: PUSH
44454: LD_INT 3
44456: ARRAY
44457: PPUSH
44458: LD_EXP 104
44462: PUSH
44463: LD_VAR 0 2
44467: ARRAY
44468: PUSH
44469: LD_INT 1
44471: ARRAY
44472: PUSH
44473: LD_INT 4
44475: ARRAY
44476: PPUSH
44477: CALL_OW 145
// end ;
44481: GO 44270
44483: POP
44484: POP
// end else
44485: GO 44629
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44487: LD_EXP 99
44491: PUSH
44492: LD_VAR 0 2
44496: ARRAY
44497: PPUSH
44498: LD_EXP 104
44502: PUSH
44503: LD_VAR 0 2
44507: ARRAY
44508: PUSH
44509: LD_INT 1
44511: ARRAY
44512: PUSH
44513: LD_INT 1
44515: ARRAY
44516: PPUSH
44517: LD_EXP 104
44521: PUSH
44522: LD_VAR 0 2
44526: ARRAY
44527: PUSH
44528: LD_INT 1
44530: ARRAY
44531: PUSH
44532: LD_INT 2
44534: ARRAY
44535: PPUSH
44536: LD_EXP 104
44540: PUSH
44541: LD_VAR 0 2
44545: ARRAY
44546: PUSH
44547: LD_INT 1
44549: ARRAY
44550: PUSH
44551: LD_INT 3
44553: ARRAY
44554: PPUSH
44555: LD_EXP 104
44559: PUSH
44560: LD_VAR 0 2
44564: ARRAY
44565: PUSH
44566: LD_INT 1
44568: ARRAY
44569: PUSH
44570: LD_INT 4
44572: ARRAY
44573: PPUSH
44574: CALL 76388 0 5
44578: NOT
44579: IFFALSE 44629
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
44581: LD_ADDR_EXP 104
44585: PUSH
44586: LD_EXP 104
44590: PPUSH
44591: LD_VAR 0 2
44595: PPUSH
44596: LD_EXP 104
44600: PUSH
44601: LD_VAR 0 2
44605: ARRAY
44606: PPUSH
44607: LD_INT 1
44609: PPUSH
44610: LD_INT 1
44612: NEG
44613: PPUSH
44614: LD_INT 0
44616: PPUSH
44617: CALL 69055 0 4
44621: PPUSH
44622: CALL_OW 1
44626: ST_TO_ADDR
// continue ;
44627: GO 43505
// end ; end ; end ;
44629: GO 43505
44631: POP
44632: POP
// end ;
44633: LD_VAR 0 1
44637: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
44638: LD_INT 0
44640: PPUSH
44641: PPUSH
44642: PPUSH
44643: PPUSH
44644: PPUSH
44645: PPUSH
// if not mc_bases then
44646: LD_EXP 99
44650: NOT
44651: IFFALSE 44655
// exit ;
44653: GO 45082
// for i = 1 to mc_bases do
44655: LD_ADDR_VAR 0 2
44659: PUSH
44660: DOUBLE
44661: LD_INT 1
44663: DEC
44664: ST_TO_ADDR
44665: LD_EXP 99
44669: PUSH
44670: FOR_TO
44671: IFFALSE 45080
// begin tmp := mc_build_upgrade [ i ] ;
44673: LD_ADDR_VAR 0 4
44677: PUSH
44678: LD_EXP 131
44682: PUSH
44683: LD_VAR 0 2
44687: ARRAY
44688: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
44689: LD_ADDR_VAR 0 6
44693: PUSH
44694: LD_EXP 132
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: PPUSH
44705: LD_INT 2
44707: PUSH
44708: LD_INT 30
44710: PUSH
44711: LD_INT 6
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 30
44720: PUSH
44721: LD_INT 7
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: LIST
44732: PPUSH
44733: CALL_OW 72
44737: ST_TO_ADDR
// if not tmp and not lab then
44738: LD_VAR 0 4
44742: NOT
44743: PUSH
44744: LD_VAR 0 6
44748: NOT
44749: AND
44750: IFFALSE 44754
// continue ;
44752: GO 44670
// if tmp then
44754: LD_VAR 0 4
44758: IFFALSE 44878
// for j in tmp do
44760: LD_ADDR_VAR 0 3
44764: PUSH
44765: LD_VAR 0 4
44769: PUSH
44770: FOR_IN
44771: IFFALSE 44876
// begin if UpgradeCost ( j ) then
44773: LD_VAR 0 3
44777: PPUSH
44778: CALL 76048 0 1
44782: IFFALSE 44874
// begin ComUpgrade ( j ) ;
44784: LD_VAR 0 3
44788: PPUSH
44789: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
44793: LD_ADDR_EXP 131
44797: PUSH
44798: LD_EXP 131
44802: PPUSH
44803: LD_VAR 0 2
44807: PPUSH
44808: LD_EXP 131
44812: PUSH
44813: LD_VAR 0 2
44817: ARRAY
44818: PUSH
44819: LD_VAR 0 3
44823: DIFF
44824: PPUSH
44825: CALL_OW 1
44829: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44830: LD_ADDR_EXP 106
44834: PUSH
44835: LD_EXP 106
44839: PPUSH
44840: LD_VAR 0 2
44844: PUSH
44845: LD_EXP 106
44849: PUSH
44850: LD_VAR 0 2
44854: ARRAY
44855: PUSH
44856: LD_INT 1
44858: PLUS
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PPUSH
44864: LD_VAR 0 3
44868: PPUSH
44869: CALL 69637 0 3
44873: ST_TO_ADDR
// end ; end ;
44874: GO 44770
44876: POP
44877: POP
// if not lab or not mc_lab_upgrade [ i ] then
44878: LD_VAR 0 6
44882: NOT
44883: PUSH
44884: LD_EXP 133
44888: PUSH
44889: LD_VAR 0 2
44893: ARRAY
44894: NOT
44895: OR
44896: IFFALSE 44900
// continue ;
44898: GO 44670
// for j in lab do
44900: LD_ADDR_VAR 0 3
44904: PUSH
44905: LD_VAR 0 6
44909: PUSH
44910: FOR_IN
44911: IFFALSE 45076
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
44913: LD_VAR 0 3
44917: PPUSH
44918: CALL_OW 266
44922: PUSH
44923: LD_INT 6
44925: PUSH
44926: LD_INT 7
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: IN
44933: PUSH
44934: LD_VAR 0 3
44938: PPUSH
44939: CALL_OW 461
44943: PUSH
44944: LD_INT 1
44946: NONEQUAL
44947: AND
44948: IFFALSE 45074
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
44950: LD_VAR 0 3
44954: PPUSH
44955: LD_EXP 133
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PUSH
44966: LD_INT 1
44968: ARRAY
44969: PPUSH
44970: CALL 76253 0 2
44974: IFFALSE 45074
// begin ComCancel ( j ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
44985: LD_VAR 0 3
44989: PPUSH
44990: LD_EXP 133
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: PUSH
45001: LD_INT 1
45003: ARRAY
45004: PPUSH
45005: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45009: LD_VAR 0 3
45013: PUSH
45014: LD_EXP 106
45018: PUSH
45019: LD_VAR 0 2
45023: ARRAY
45024: IN
45025: NOT
45026: IFFALSE 45072
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45028: LD_ADDR_EXP 106
45032: PUSH
45033: LD_EXP 106
45037: PPUSH
45038: LD_VAR 0 2
45042: PUSH
45043: LD_EXP 106
45047: PUSH
45048: LD_VAR 0 2
45052: ARRAY
45053: PUSH
45054: LD_INT 1
45056: PLUS
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PPUSH
45062: LD_VAR 0 3
45066: PPUSH
45067: CALL 69637 0 3
45071: ST_TO_ADDR
// break ;
45072: GO 45076
// end ; end ; end ;
45074: GO 44910
45076: POP
45077: POP
// end ;
45078: GO 44670
45080: POP
45081: POP
// end ;
45082: LD_VAR 0 1
45086: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45087: LD_INT 0
45089: PPUSH
45090: PPUSH
45091: PPUSH
45092: PPUSH
45093: PPUSH
45094: PPUSH
45095: PPUSH
45096: PPUSH
45097: PPUSH
// if not mc_bases then
45098: LD_EXP 99
45102: NOT
45103: IFFALSE 45107
// exit ;
45105: GO 45512
// for i = 1 to mc_bases do
45107: LD_ADDR_VAR 0 2
45111: PUSH
45112: DOUBLE
45113: LD_INT 1
45115: DEC
45116: ST_TO_ADDR
45117: LD_EXP 99
45121: PUSH
45122: FOR_TO
45123: IFFALSE 45510
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45125: LD_EXP 107
45129: PUSH
45130: LD_VAR 0 2
45134: ARRAY
45135: NOT
45136: PUSH
45137: LD_EXP 99
45141: PUSH
45142: LD_VAR 0 2
45146: ARRAY
45147: PPUSH
45148: LD_INT 30
45150: PUSH
45151: LD_INT 3
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PPUSH
45158: CALL_OW 72
45162: NOT
45163: OR
45164: IFFALSE 45168
// continue ;
45166: GO 45122
// busy := false ;
45168: LD_ADDR_VAR 0 8
45172: PUSH
45173: LD_INT 0
45175: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45176: LD_ADDR_VAR 0 4
45180: PUSH
45181: LD_EXP 99
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: PPUSH
45192: LD_INT 30
45194: PUSH
45195: LD_INT 3
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PPUSH
45202: CALL_OW 72
45206: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45207: LD_ADDR_VAR 0 6
45211: PUSH
45212: LD_EXP 107
45216: PUSH
45217: LD_VAR 0 2
45221: ARRAY
45222: PPUSH
45223: LD_INT 2
45225: PUSH
45226: LD_INT 30
45228: PUSH
45229: LD_INT 32
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 30
45238: PUSH
45239: LD_INT 33
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: LIST
45250: PPUSH
45251: CALL_OW 72
45255: ST_TO_ADDR
// if not t then
45256: LD_VAR 0 6
45260: NOT
45261: IFFALSE 45265
// continue ;
45263: GO 45122
// for j in tmp do
45265: LD_ADDR_VAR 0 3
45269: PUSH
45270: LD_VAR 0 4
45274: PUSH
45275: FOR_IN
45276: IFFALSE 45306
// if not BuildingStatus ( j ) = bs_idle then
45278: LD_VAR 0 3
45282: PPUSH
45283: CALL_OW 461
45287: PUSH
45288: LD_INT 2
45290: EQUAL
45291: NOT
45292: IFFALSE 45304
// begin busy := true ;
45294: LD_ADDR_VAR 0 8
45298: PUSH
45299: LD_INT 1
45301: ST_TO_ADDR
// break ;
45302: GO 45306
// end ;
45304: GO 45275
45306: POP
45307: POP
// if busy then
45308: LD_VAR 0 8
45312: IFFALSE 45316
// continue ;
45314: GO 45122
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45316: LD_ADDR_VAR 0 7
45320: PUSH
45321: LD_VAR 0 6
45325: PPUSH
45326: LD_INT 35
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PPUSH
45336: CALL_OW 72
45340: ST_TO_ADDR
// if tw then
45341: LD_VAR 0 7
45345: IFFALSE 45422
// begin tw := tw [ 1 ] ;
45347: LD_ADDR_VAR 0 7
45351: PUSH
45352: LD_VAR 0 7
45356: PUSH
45357: LD_INT 1
45359: ARRAY
45360: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45361: LD_ADDR_VAR 0 9
45365: PUSH
45366: LD_VAR 0 7
45370: PPUSH
45371: LD_EXP 124
45375: PUSH
45376: LD_VAR 0 2
45380: ARRAY
45381: PPUSH
45382: CALL 74607 0 2
45386: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45387: LD_EXP 138
45391: PUSH
45392: LD_VAR 0 2
45396: ARRAY
45397: IFFALSE 45420
// if not weapon in mc_allowed_tower_weapons [ i ] then
45399: LD_VAR 0 9
45403: PUSH
45404: LD_EXP 138
45408: PUSH
45409: LD_VAR 0 2
45413: ARRAY
45414: IN
45415: NOT
45416: IFFALSE 45420
// continue ;
45418: GO 45122
// end else
45420: GO 45485
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45422: LD_ADDR_VAR 0 5
45426: PUSH
45427: LD_EXP 107
45431: PUSH
45432: LD_VAR 0 2
45436: ARRAY
45437: PPUSH
45438: LD_VAR 0 4
45442: PPUSH
45443: CALL 104808 0 2
45447: ST_TO_ADDR
// if not tmp2 then
45448: LD_VAR 0 5
45452: NOT
45453: IFFALSE 45457
// continue ;
45455: GO 45122
// tw := tmp2 [ 1 ] ;
45457: LD_ADDR_VAR 0 7
45461: PUSH
45462: LD_VAR 0 5
45466: PUSH
45467: LD_INT 1
45469: ARRAY
45470: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45471: LD_ADDR_VAR 0 9
45475: PUSH
45476: LD_VAR 0 5
45480: PUSH
45481: LD_INT 2
45483: ARRAY
45484: ST_TO_ADDR
// end ; if not weapon then
45485: LD_VAR 0 9
45489: NOT
45490: IFFALSE 45494
// continue ;
45492: GO 45122
// ComPlaceWeapon ( tw , weapon ) ;
45494: LD_VAR 0 7
45498: PPUSH
45499: LD_VAR 0 9
45503: PPUSH
45504: CALL_OW 148
// end ;
45508: GO 45122
45510: POP
45511: POP
// end ;
45512: LD_VAR 0 1
45516: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
45522: PPUSH
45523: PPUSH
45524: PPUSH
// if not mc_bases then
45525: LD_EXP 99
45529: NOT
45530: IFFALSE 45534
// exit ;
45532: GO 46546
// for i = 1 to mc_bases do
45534: LD_ADDR_VAR 0 2
45538: PUSH
45539: DOUBLE
45540: LD_INT 1
45542: DEC
45543: ST_TO_ADDR
45544: LD_EXP 99
45548: PUSH
45549: FOR_TO
45550: IFFALSE 46544
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45552: LD_EXP 112
45556: PUSH
45557: LD_VAR 0 2
45561: ARRAY
45562: NOT
45563: PUSH
45564: LD_EXP 112
45568: PUSH
45569: LD_VAR 0 2
45573: ARRAY
45574: PUSH
45575: LD_EXP 113
45579: PUSH
45580: LD_VAR 0 2
45584: ARRAY
45585: EQUAL
45586: OR
45587: IFFALSE 45591
// continue ;
45589: GO 45549
// if mc_miners [ i ] then
45591: LD_EXP 113
45595: PUSH
45596: LD_VAR 0 2
45600: ARRAY
45601: IFFALSE 46231
// begin k := 1 ;
45603: LD_ADDR_VAR 0 4
45607: PUSH
45608: LD_INT 1
45610: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
45611: LD_ADDR_VAR 0 3
45615: PUSH
45616: DOUBLE
45617: LD_EXP 113
45621: PUSH
45622: LD_VAR 0 2
45626: ARRAY
45627: INC
45628: ST_TO_ADDR
45629: LD_INT 1
45631: PUSH
45632: FOR_DOWNTO
45633: IFFALSE 46229
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
45635: LD_EXP 113
45639: PUSH
45640: LD_VAR 0 2
45644: ARRAY
45645: PUSH
45646: LD_VAR 0 3
45650: ARRAY
45651: PPUSH
45652: CALL_OW 301
45656: PUSH
45657: LD_EXP 113
45661: PUSH
45662: LD_VAR 0 2
45666: ARRAY
45667: PUSH
45668: LD_VAR 0 3
45672: ARRAY
45673: PPUSH
45674: CALL_OW 257
45678: PUSH
45679: LD_INT 1
45681: NONEQUAL
45682: OR
45683: IFFALSE 45746
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
45685: LD_ADDR_VAR 0 5
45689: PUSH
45690: LD_EXP 113
45694: PUSH
45695: LD_VAR 0 2
45699: ARRAY
45700: PUSH
45701: LD_EXP 113
45705: PUSH
45706: LD_VAR 0 2
45710: ARRAY
45711: PUSH
45712: LD_VAR 0 3
45716: ARRAY
45717: DIFF
45718: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
45719: LD_ADDR_EXP 113
45723: PUSH
45724: LD_EXP 113
45728: PPUSH
45729: LD_VAR 0 2
45733: PPUSH
45734: LD_VAR 0 5
45738: PPUSH
45739: CALL_OW 1
45743: ST_TO_ADDR
// continue ;
45744: GO 45632
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
45746: LD_EXP 113
45750: PUSH
45751: LD_VAR 0 2
45755: ARRAY
45756: PUSH
45757: LD_VAR 0 3
45761: ARRAY
45762: PPUSH
45763: CALL 69573 0 1
45767: PUSH
45768: LD_EXP 113
45772: PUSH
45773: LD_VAR 0 2
45777: ARRAY
45778: PUSH
45779: LD_VAR 0 3
45783: ARRAY
45784: PPUSH
45785: CALL_OW 255
45789: PPUSH
45790: LD_EXP 112
45794: PUSH
45795: LD_VAR 0 2
45799: ARRAY
45800: PUSH
45801: LD_VAR 0 4
45805: ARRAY
45806: PUSH
45807: LD_INT 1
45809: ARRAY
45810: PPUSH
45811: LD_EXP 112
45815: PUSH
45816: LD_VAR 0 2
45820: ARRAY
45821: PUSH
45822: LD_VAR 0 4
45826: ARRAY
45827: PUSH
45828: LD_INT 2
45830: ARRAY
45831: PPUSH
45832: LD_INT 15
45834: PPUSH
45835: CALL 70533 0 4
45839: PUSH
45840: LD_INT 4
45842: ARRAY
45843: PUSH
45844: LD_EXP 113
45848: PUSH
45849: LD_VAR 0 2
45853: ARRAY
45854: PUSH
45855: LD_VAR 0 3
45859: ARRAY
45860: PPUSH
45861: LD_INT 10
45863: PPUSH
45864: CALL 72230 0 2
45868: PUSH
45869: LD_INT 4
45871: ARRAY
45872: OR
45873: AND
45874: IFFALSE 45897
// ComStop ( mc_miners [ i ] [ j ] ) ;
45876: LD_EXP 113
45880: PUSH
45881: LD_VAR 0 2
45885: ARRAY
45886: PUSH
45887: LD_VAR 0 3
45891: ARRAY
45892: PPUSH
45893: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
45897: LD_EXP 113
45901: PUSH
45902: LD_VAR 0 2
45906: ARRAY
45907: PUSH
45908: LD_VAR 0 3
45912: ARRAY
45913: PPUSH
45914: CALL_OW 257
45918: PUSH
45919: LD_INT 1
45921: EQUAL
45922: PUSH
45923: LD_EXP 113
45927: PUSH
45928: LD_VAR 0 2
45932: ARRAY
45933: PUSH
45934: LD_VAR 0 3
45938: ARRAY
45939: PPUSH
45940: CALL_OW 459
45944: NOT
45945: AND
45946: PUSH
45947: LD_EXP 113
45951: PUSH
45952: LD_VAR 0 2
45956: ARRAY
45957: PUSH
45958: LD_VAR 0 3
45962: ARRAY
45963: PPUSH
45964: CALL_OW 255
45968: PPUSH
45969: LD_EXP 112
45973: PUSH
45974: LD_VAR 0 2
45978: ARRAY
45979: PUSH
45980: LD_VAR 0 4
45984: ARRAY
45985: PUSH
45986: LD_INT 1
45988: ARRAY
45989: PPUSH
45990: LD_EXP 112
45994: PUSH
45995: LD_VAR 0 2
45999: ARRAY
46000: PUSH
46001: LD_VAR 0 4
46005: ARRAY
46006: PUSH
46007: LD_INT 2
46009: ARRAY
46010: PPUSH
46011: LD_INT 15
46013: PPUSH
46014: CALL 70533 0 4
46018: PUSH
46019: LD_INT 4
46021: ARRAY
46022: PUSH
46023: LD_INT 0
46025: EQUAL
46026: AND
46027: PUSH
46028: LD_EXP 113
46032: PUSH
46033: LD_VAR 0 2
46037: ARRAY
46038: PUSH
46039: LD_VAR 0 3
46043: ARRAY
46044: PPUSH
46045: CALL_OW 314
46049: NOT
46050: AND
46051: IFFALSE 46227
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46053: LD_EXP 113
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_VAR 0 3
46068: ARRAY
46069: PPUSH
46070: CALL_OW 310
46074: IFFALSE 46097
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46076: LD_EXP 113
46080: PUSH
46081: LD_VAR 0 2
46085: ARRAY
46086: PUSH
46087: LD_VAR 0 3
46091: ARRAY
46092: PPUSH
46093: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46097: LD_EXP 113
46101: PUSH
46102: LD_VAR 0 2
46106: ARRAY
46107: PUSH
46108: LD_VAR 0 3
46112: ARRAY
46113: PPUSH
46114: CALL_OW 314
46118: NOT
46119: IFFALSE 46187
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46121: LD_EXP 113
46125: PUSH
46126: LD_VAR 0 2
46130: ARRAY
46131: PUSH
46132: LD_VAR 0 3
46136: ARRAY
46137: PPUSH
46138: LD_EXP 112
46142: PUSH
46143: LD_VAR 0 2
46147: ARRAY
46148: PUSH
46149: LD_VAR 0 4
46153: ARRAY
46154: PUSH
46155: LD_INT 1
46157: ARRAY
46158: PPUSH
46159: LD_EXP 112
46163: PUSH
46164: LD_VAR 0 2
46168: ARRAY
46169: PUSH
46170: LD_VAR 0 4
46174: ARRAY
46175: PUSH
46176: LD_INT 2
46178: ARRAY
46179: PPUSH
46180: LD_INT 0
46182: PPUSH
46183: CALL_OW 193
// k := k + 1 ;
46187: LD_ADDR_VAR 0 4
46191: PUSH
46192: LD_VAR 0 4
46196: PUSH
46197: LD_INT 1
46199: PLUS
46200: ST_TO_ADDR
// if k > mc_mines [ i ] then
46201: LD_VAR 0 4
46205: PUSH
46206: LD_EXP 112
46210: PUSH
46211: LD_VAR 0 2
46215: ARRAY
46216: GREATER
46217: IFFALSE 46227
// k := 1 ;
46219: LD_ADDR_VAR 0 4
46223: PUSH
46224: LD_INT 1
46226: ST_TO_ADDR
// end ; end ;
46227: GO 45632
46229: POP
46230: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46231: LD_ADDR_VAR 0 5
46235: PUSH
46236: LD_EXP 99
46240: PUSH
46241: LD_VAR 0 2
46245: ARRAY
46246: PPUSH
46247: LD_INT 2
46249: PUSH
46250: LD_INT 30
46252: PUSH
46253: LD_INT 4
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 30
46262: PUSH
46263: LD_INT 5
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 30
46272: PUSH
46273: LD_INT 32
46275: PUSH
46276: EMPTY
46277: LIST
46278: LIST
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: PPUSH
46286: CALL_OW 72
46290: ST_TO_ADDR
// if not tmp then
46291: LD_VAR 0 5
46295: NOT
46296: IFFALSE 46300
// continue ;
46298: GO 45549
// list := [ ] ;
46300: LD_ADDR_VAR 0 6
46304: PUSH
46305: EMPTY
46306: ST_TO_ADDR
// for j in tmp do
46307: LD_ADDR_VAR 0 3
46311: PUSH
46312: LD_VAR 0 5
46316: PUSH
46317: FOR_IN
46318: IFFALSE 46387
// begin for k in UnitsInside ( j ) do
46320: LD_ADDR_VAR 0 4
46324: PUSH
46325: LD_VAR 0 3
46329: PPUSH
46330: CALL_OW 313
46334: PUSH
46335: FOR_IN
46336: IFFALSE 46383
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46338: LD_VAR 0 4
46342: PPUSH
46343: CALL_OW 257
46347: PUSH
46348: LD_INT 1
46350: EQUAL
46351: PUSH
46352: LD_VAR 0 4
46356: PPUSH
46357: CALL_OW 459
46361: NOT
46362: AND
46363: IFFALSE 46381
// list := list ^ k ;
46365: LD_ADDR_VAR 0 6
46369: PUSH
46370: LD_VAR 0 6
46374: PUSH
46375: LD_VAR 0 4
46379: ADD
46380: ST_TO_ADDR
46381: GO 46335
46383: POP
46384: POP
// end ;
46385: GO 46317
46387: POP
46388: POP
// list := list diff mc_miners [ i ] ;
46389: LD_ADDR_VAR 0 6
46393: PUSH
46394: LD_VAR 0 6
46398: PUSH
46399: LD_EXP 113
46403: PUSH
46404: LD_VAR 0 2
46408: ARRAY
46409: DIFF
46410: ST_TO_ADDR
// if not list then
46411: LD_VAR 0 6
46415: NOT
46416: IFFALSE 46420
// continue ;
46418: GO 45549
// k := mc_mines [ i ] - mc_miners [ i ] ;
46420: LD_ADDR_VAR 0 4
46424: PUSH
46425: LD_EXP 112
46429: PUSH
46430: LD_VAR 0 2
46434: ARRAY
46435: PUSH
46436: LD_EXP 113
46440: PUSH
46441: LD_VAR 0 2
46445: ARRAY
46446: MINUS
46447: ST_TO_ADDR
// if k > list then
46448: LD_VAR 0 4
46452: PUSH
46453: LD_VAR 0 6
46457: GREATER
46458: IFFALSE 46470
// k := list ;
46460: LD_ADDR_VAR 0 4
46464: PUSH
46465: LD_VAR 0 6
46469: ST_TO_ADDR
// for j = 1 to k do
46470: LD_ADDR_VAR 0 3
46474: PUSH
46475: DOUBLE
46476: LD_INT 1
46478: DEC
46479: ST_TO_ADDR
46480: LD_VAR 0 4
46484: PUSH
46485: FOR_TO
46486: IFFALSE 46540
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46488: LD_ADDR_EXP 113
46492: PUSH
46493: LD_EXP 113
46497: PPUSH
46498: LD_VAR 0 2
46502: PUSH
46503: LD_EXP 113
46507: PUSH
46508: LD_VAR 0 2
46512: ARRAY
46513: PUSH
46514: LD_INT 1
46516: PLUS
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PPUSH
46522: LD_VAR 0 6
46526: PUSH
46527: LD_VAR 0 3
46531: ARRAY
46532: PPUSH
46533: CALL 69637 0 3
46537: ST_TO_ADDR
46538: GO 46485
46540: POP
46541: POP
// end ;
46542: GO 45549
46544: POP
46545: POP
// end ;
46546: LD_VAR 0 1
46550: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46551: LD_INT 0
46553: PPUSH
46554: PPUSH
46555: PPUSH
46556: PPUSH
46557: PPUSH
46558: PPUSH
46559: PPUSH
46560: PPUSH
46561: PPUSH
46562: PPUSH
// if not mc_bases then
46563: LD_EXP 99
46567: NOT
46568: IFFALSE 46572
// exit ;
46570: GO 48303
// for i = 1 to mc_bases do
46572: LD_ADDR_VAR 0 2
46576: PUSH
46577: DOUBLE
46578: LD_INT 1
46580: DEC
46581: ST_TO_ADDR
46582: LD_EXP 99
46586: PUSH
46587: FOR_TO
46588: IFFALSE 48301
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
46590: LD_EXP 99
46594: PUSH
46595: LD_VAR 0 2
46599: ARRAY
46600: NOT
46601: PUSH
46602: LD_EXP 106
46606: PUSH
46607: LD_VAR 0 2
46611: ARRAY
46612: OR
46613: IFFALSE 46617
// continue ;
46615: GO 46587
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
46617: LD_EXP 115
46621: PUSH
46622: LD_VAR 0 2
46626: ARRAY
46627: NOT
46628: PUSH
46629: LD_EXP 116
46633: PUSH
46634: LD_VAR 0 2
46638: ARRAY
46639: AND
46640: IFFALSE 46678
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
46642: LD_ADDR_EXP 116
46646: PUSH
46647: LD_EXP 116
46651: PPUSH
46652: LD_VAR 0 2
46656: PPUSH
46657: EMPTY
46658: PPUSH
46659: CALL_OW 1
46663: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
46664: LD_VAR 0 2
46668: PPUSH
46669: LD_INT 107
46671: PPUSH
46672: CALL 37767 0 2
// continue ;
46676: GO 46587
// end ; target := [ ] ;
46678: LD_ADDR_VAR 0 6
46682: PUSH
46683: EMPTY
46684: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
46685: LD_ADDR_VAR 0 3
46689: PUSH
46690: DOUBLE
46691: LD_EXP 115
46695: PUSH
46696: LD_VAR 0 2
46700: ARRAY
46701: INC
46702: ST_TO_ADDR
46703: LD_INT 1
46705: PUSH
46706: FOR_DOWNTO
46707: IFFALSE 46967
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
46709: LD_EXP 115
46713: PUSH
46714: LD_VAR 0 2
46718: ARRAY
46719: PUSH
46720: LD_VAR 0 3
46724: ARRAY
46725: PUSH
46726: LD_INT 2
46728: ARRAY
46729: PPUSH
46730: LD_EXP 115
46734: PUSH
46735: LD_VAR 0 2
46739: ARRAY
46740: PUSH
46741: LD_VAR 0 3
46745: ARRAY
46746: PUSH
46747: LD_INT 3
46749: ARRAY
46750: PPUSH
46751: CALL_OW 488
46755: PUSH
46756: LD_EXP 115
46760: PUSH
46761: LD_VAR 0 2
46765: ARRAY
46766: PUSH
46767: LD_VAR 0 3
46771: ARRAY
46772: PUSH
46773: LD_INT 2
46775: ARRAY
46776: PPUSH
46777: LD_EXP 115
46781: PUSH
46782: LD_VAR 0 2
46786: ARRAY
46787: PUSH
46788: LD_VAR 0 3
46792: ARRAY
46793: PUSH
46794: LD_INT 3
46796: ARRAY
46797: PPUSH
46798: CALL_OW 284
46802: PUSH
46803: LD_INT 0
46805: EQUAL
46806: AND
46807: IFFALSE 46862
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
46809: LD_ADDR_VAR 0 5
46813: PUSH
46814: LD_EXP 115
46818: PUSH
46819: LD_VAR 0 2
46823: ARRAY
46824: PPUSH
46825: LD_VAR 0 3
46829: PPUSH
46830: CALL_OW 3
46834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
46835: LD_ADDR_EXP 115
46839: PUSH
46840: LD_EXP 115
46844: PPUSH
46845: LD_VAR 0 2
46849: PPUSH
46850: LD_VAR 0 5
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// continue ;
46860: GO 46706
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
46862: LD_EXP 99
46866: PUSH
46867: LD_VAR 0 2
46871: ARRAY
46872: PUSH
46873: LD_INT 1
46875: ARRAY
46876: PPUSH
46877: CALL_OW 255
46881: PPUSH
46882: LD_EXP 115
46886: PUSH
46887: LD_VAR 0 2
46891: ARRAY
46892: PUSH
46893: LD_VAR 0 3
46897: ARRAY
46898: PUSH
46899: LD_INT 2
46901: ARRAY
46902: PPUSH
46903: LD_EXP 115
46907: PUSH
46908: LD_VAR 0 2
46912: ARRAY
46913: PUSH
46914: LD_VAR 0 3
46918: ARRAY
46919: PUSH
46920: LD_INT 3
46922: ARRAY
46923: PPUSH
46924: LD_INT 30
46926: PPUSH
46927: CALL 70533 0 4
46931: PUSH
46932: LD_INT 4
46934: ARRAY
46935: PUSH
46936: LD_INT 0
46938: EQUAL
46939: IFFALSE 46965
// begin target := mc_crates [ i ] [ j ] ;
46941: LD_ADDR_VAR 0 6
46945: PUSH
46946: LD_EXP 115
46950: PUSH
46951: LD_VAR 0 2
46955: ARRAY
46956: PUSH
46957: LD_VAR 0 3
46961: ARRAY
46962: ST_TO_ADDR
// break ;
46963: GO 46967
// end ; end ;
46965: GO 46706
46967: POP
46968: POP
// if not target then
46969: LD_VAR 0 6
46973: NOT
46974: IFFALSE 46978
// continue ;
46976: GO 46587
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
46978: LD_ADDR_VAR 0 7
46982: PUSH
46983: LD_EXP 118
46987: PUSH
46988: LD_VAR 0 2
46992: ARRAY
46993: PPUSH
46994: LD_INT 2
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: LD_INT 58
47002: PUSH
47003: EMPTY
47004: LIST
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 61
47012: PUSH
47013: EMPTY
47014: LIST
47015: PUSH
47016: LD_INT 33
47018: PUSH
47019: LD_INT 5
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PUSH
47026: LD_INT 33
47028: PUSH
47029: LD_INT 3
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: EMPTY
47037: LIST
47038: LIST
47039: LIST
47040: LIST
47041: LIST
47042: PUSH
47043: LD_INT 2
47045: PUSH
47046: LD_INT 34
47048: PUSH
47049: LD_INT 32
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 34
47058: PUSH
47059: LD_INT 51
47061: PUSH
47062: EMPTY
47063: LIST
47064: LIST
47065: PUSH
47066: LD_INT 34
47068: PUSH
47069: LD_INT 12
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PPUSH
47086: CALL_OW 72
47090: ST_TO_ADDR
// if not cargo then
47091: LD_VAR 0 7
47095: NOT
47096: IFFALSE 47739
// begin if mc_crates_collector [ i ] < 5 then
47098: LD_EXP 116
47102: PUSH
47103: LD_VAR 0 2
47107: ARRAY
47108: PUSH
47109: LD_INT 5
47111: LESS
47112: IFFALSE 47478
// begin if mc_ape [ i ] then
47114: LD_EXP 128
47118: PUSH
47119: LD_VAR 0 2
47123: ARRAY
47124: IFFALSE 47171
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47126: LD_ADDR_VAR 0 5
47130: PUSH
47131: LD_EXP 128
47135: PUSH
47136: LD_VAR 0 2
47140: ARRAY
47141: PPUSH
47142: LD_INT 25
47144: PUSH
47145: LD_INT 16
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 24
47154: PUSH
47155: LD_INT 750
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: EMPTY
47163: LIST
47164: LIST
47165: PPUSH
47166: CALL_OW 72
47170: ST_TO_ADDR
// if not tmp then
47171: LD_VAR 0 5
47175: NOT
47176: IFFALSE 47223
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47178: LD_ADDR_VAR 0 5
47182: PUSH
47183: LD_EXP 99
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: PPUSH
47194: LD_INT 25
47196: PUSH
47197: LD_INT 2
47199: PUSH
47200: EMPTY
47201: LIST
47202: LIST
47203: PUSH
47204: LD_INT 24
47206: PUSH
47207: LD_INT 750
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PPUSH
47218: CALL_OW 72
47222: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47223: LD_EXP 128
47227: PUSH
47228: LD_VAR 0 2
47232: ARRAY
47233: PUSH
47234: LD_EXP 99
47238: PUSH
47239: LD_VAR 0 2
47243: ARRAY
47244: PPUSH
47245: LD_INT 25
47247: PUSH
47248: LD_INT 2
47250: PUSH
47251: EMPTY
47252: LIST
47253: LIST
47254: PUSH
47255: LD_INT 24
47257: PUSH
47258: LD_INT 750
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PPUSH
47269: CALL_OW 72
47273: AND
47274: PUSH
47275: LD_VAR 0 5
47279: PUSH
47280: LD_INT 5
47282: LESS
47283: AND
47284: IFFALSE 47366
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47286: LD_ADDR_VAR 0 3
47290: PUSH
47291: LD_EXP 99
47295: PUSH
47296: LD_VAR 0 2
47300: ARRAY
47301: PPUSH
47302: LD_INT 25
47304: PUSH
47305: LD_INT 2
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: PUSH
47312: LD_INT 24
47314: PUSH
47315: LD_INT 750
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PPUSH
47326: CALL_OW 72
47330: PUSH
47331: FOR_IN
47332: IFFALSE 47364
// begin tmp := tmp union j ;
47334: LD_ADDR_VAR 0 5
47338: PUSH
47339: LD_VAR 0 5
47343: PUSH
47344: LD_VAR 0 3
47348: UNION
47349: ST_TO_ADDR
// if tmp >= 5 then
47350: LD_VAR 0 5
47354: PUSH
47355: LD_INT 5
47357: GREATEREQUAL
47358: IFFALSE 47362
// break ;
47360: GO 47364
// end ;
47362: GO 47331
47364: POP
47365: POP
// end ; if not tmp then
47366: LD_VAR 0 5
47370: NOT
47371: IFFALSE 47375
// continue ;
47373: GO 46587
// for j in tmp do
47375: LD_ADDR_VAR 0 3
47379: PUSH
47380: LD_VAR 0 5
47384: PUSH
47385: FOR_IN
47386: IFFALSE 47476
// if not GetTag ( j ) then
47388: LD_VAR 0 3
47392: PPUSH
47393: CALL_OW 110
47397: NOT
47398: IFFALSE 47474
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47400: LD_ADDR_EXP 116
47404: PUSH
47405: LD_EXP 116
47409: PPUSH
47410: LD_VAR 0 2
47414: PUSH
47415: LD_EXP 116
47419: PUSH
47420: LD_VAR 0 2
47424: ARRAY
47425: PUSH
47426: LD_INT 1
47428: PLUS
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PPUSH
47434: LD_VAR 0 3
47438: PPUSH
47439: CALL 69637 0 3
47443: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47444: LD_VAR 0 3
47448: PPUSH
47449: LD_INT 107
47451: PPUSH
47452: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47456: LD_EXP 116
47460: PUSH
47461: LD_VAR 0 2
47465: ARRAY
47466: PUSH
47467: LD_INT 5
47469: GREATEREQUAL
47470: IFFALSE 47474
// break ;
47472: GO 47476
// end ;
47474: GO 47385
47476: POP
47477: POP
// end ; if mc_crates_collector [ i ] and target then
47478: LD_EXP 116
47482: PUSH
47483: LD_VAR 0 2
47487: ARRAY
47488: PUSH
47489: LD_VAR 0 6
47493: AND
47494: IFFALSE 47737
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47496: LD_EXP 116
47500: PUSH
47501: LD_VAR 0 2
47505: ARRAY
47506: PUSH
47507: LD_VAR 0 6
47511: PUSH
47512: LD_INT 1
47514: ARRAY
47515: LESS
47516: IFFALSE 47536
// tmp := mc_crates_collector [ i ] else
47518: LD_ADDR_VAR 0 5
47522: PUSH
47523: LD_EXP 116
47527: PUSH
47528: LD_VAR 0 2
47532: ARRAY
47533: ST_TO_ADDR
47534: GO 47550
// tmp := target [ 1 ] ;
47536: LD_ADDR_VAR 0 5
47540: PUSH
47541: LD_VAR 0 6
47545: PUSH
47546: LD_INT 1
47548: ARRAY
47549: ST_TO_ADDR
// k := 0 ;
47550: LD_ADDR_VAR 0 4
47554: PUSH
47555: LD_INT 0
47557: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47558: LD_ADDR_VAR 0 3
47562: PUSH
47563: LD_EXP 116
47567: PUSH
47568: LD_VAR 0 2
47572: ARRAY
47573: PUSH
47574: FOR_IN
47575: IFFALSE 47735
// begin k := k + 1 ;
47577: LD_ADDR_VAR 0 4
47581: PUSH
47582: LD_VAR 0 4
47586: PUSH
47587: LD_INT 1
47589: PLUS
47590: ST_TO_ADDR
// if k > tmp then
47591: LD_VAR 0 4
47595: PUSH
47596: LD_VAR 0 5
47600: GREATER
47601: IFFALSE 47605
// break ;
47603: GO 47735
// if not GetClass ( j ) in [ 2 , 16 ] then
47605: LD_VAR 0 3
47609: PPUSH
47610: CALL_OW 257
47614: PUSH
47615: LD_INT 2
47617: PUSH
47618: LD_INT 16
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: IN
47625: NOT
47626: IFFALSE 47679
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
47628: LD_ADDR_EXP 116
47632: PUSH
47633: LD_EXP 116
47637: PPUSH
47638: LD_VAR 0 2
47642: PPUSH
47643: LD_EXP 116
47647: PUSH
47648: LD_VAR 0 2
47652: ARRAY
47653: PUSH
47654: LD_VAR 0 3
47658: DIFF
47659: PPUSH
47660: CALL_OW 1
47664: ST_TO_ADDR
// SetTag ( j , 0 ) ;
47665: LD_VAR 0 3
47669: PPUSH
47670: LD_INT 0
47672: PPUSH
47673: CALL_OW 109
// continue ;
47677: GO 47574
// end ; if IsInUnit ( j ) then
47679: LD_VAR 0 3
47683: PPUSH
47684: CALL_OW 310
47688: IFFALSE 47699
// ComExitBuilding ( j ) ;
47690: LD_VAR 0 3
47694: PPUSH
47695: CALL_OW 122
// wait ( 3 ) ;
47699: LD_INT 3
47701: PPUSH
47702: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47706: LD_VAR 0 3
47710: PPUSH
47711: LD_VAR 0 6
47715: PUSH
47716: LD_INT 2
47718: ARRAY
47719: PPUSH
47720: LD_VAR 0 6
47724: PUSH
47725: LD_INT 3
47727: ARRAY
47728: PPUSH
47729: CALL_OW 117
// end ;
47733: GO 47574
47735: POP
47736: POP
// end ; end else
47737: GO 48299
// begin for j in cargo do
47739: LD_ADDR_VAR 0 3
47743: PUSH
47744: LD_VAR 0 7
47748: PUSH
47749: FOR_IN
47750: IFFALSE 48297
// begin if GetTag ( j ) <> 0 then
47752: LD_VAR 0 3
47756: PPUSH
47757: CALL_OW 110
47761: PUSH
47762: LD_INT 0
47764: NONEQUAL
47765: IFFALSE 47769
// continue ;
47767: GO 47749
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
47769: LD_VAR 0 3
47773: PPUSH
47774: CALL_OW 256
47778: PUSH
47779: LD_INT 1000
47781: LESS
47782: PUSH
47783: LD_VAR 0 3
47787: PPUSH
47788: LD_EXP 123
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PPUSH
47799: CALL_OW 308
47803: NOT
47804: AND
47805: IFFALSE 47827
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47807: LD_VAR 0 3
47811: PPUSH
47812: LD_EXP 123
47816: PUSH
47817: LD_VAR 0 2
47821: ARRAY
47822: PPUSH
47823: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
47827: LD_VAR 0 3
47831: PPUSH
47832: CALL_OW 256
47836: PUSH
47837: LD_INT 1000
47839: LESS
47840: PUSH
47841: LD_VAR 0 3
47845: PPUSH
47846: LD_EXP 123
47850: PUSH
47851: LD_VAR 0 2
47855: ARRAY
47856: PPUSH
47857: CALL_OW 308
47861: AND
47862: IFFALSE 47866
// continue ;
47864: GO 47749
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
47866: LD_VAR 0 3
47870: PPUSH
47871: CALL_OW 262
47875: PUSH
47876: LD_INT 2
47878: EQUAL
47879: PUSH
47880: LD_VAR 0 3
47884: PPUSH
47885: CALL_OW 261
47889: PUSH
47890: LD_INT 15
47892: LESS
47893: AND
47894: IFFALSE 47898
// continue ;
47896: GO 47749
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
47898: LD_VAR 0 3
47902: PPUSH
47903: CALL_OW 262
47907: PUSH
47908: LD_INT 1
47910: EQUAL
47911: PUSH
47912: LD_VAR 0 3
47916: PPUSH
47917: CALL_OW 261
47921: PUSH
47922: LD_INT 10
47924: LESS
47925: AND
47926: IFFALSE 48236
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47928: LD_ADDR_VAR 0 8
47932: PUSH
47933: LD_EXP 99
47937: PUSH
47938: LD_VAR 0 2
47942: ARRAY
47943: PPUSH
47944: LD_INT 2
47946: PUSH
47947: LD_INT 30
47949: PUSH
47950: LD_INT 0
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 30
47959: PUSH
47960: LD_INT 1
47962: PUSH
47963: EMPTY
47964: LIST
47965: LIST
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: LIST
47971: PPUSH
47972: CALL_OW 72
47976: ST_TO_ADDR
// if not depot then
47977: LD_VAR 0 8
47981: NOT
47982: IFFALSE 47986
// continue ;
47984: GO 47749
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
47986: LD_VAR 0 3
47990: PPUSH
47991: LD_VAR 0 8
47995: PPUSH
47996: LD_VAR 0 3
48000: PPUSH
48001: CALL_OW 74
48005: PPUSH
48006: CALL_OW 296
48010: PUSH
48011: LD_INT 6
48013: LESS
48014: IFFALSE 48030
// SetFuel ( j , 100 ) else
48016: LD_VAR 0 3
48020: PPUSH
48021: LD_INT 100
48023: PPUSH
48024: CALL_OW 240
48028: GO 48236
// if GetFuel ( j ) = 0 then
48030: LD_VAR 0 3
48034: PPUSH
48035: CALL_OW 261
48039: PUSH
48040: LD_INT 0
48042: EQUAL
48043: IFFALSE 48236
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48045: LD_ADDR_EXP 118
48049: PUSH
48050: LD_EXP 118
48054: PPUSH
48055: LD_VAR 0 2
48059: PPUSH
48060: LD_EXP 118
48064: PUSH
48065: LD_VAR 0 2
48069: ARRAY
48070: PUSH
48071: LD_VAR 0 3
48075: DIFF
48076: PPUSH
48077: CALL_OW 1
48081: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48082: LD_VAR 0 3
48086: PPUSH
48087: CALL_OW 263
48091: PUSH
48092: LD_INT 1
48094: EQUAL
48095: IFFALSE 48111
// ComExitVehicle ( IsInUnit ( j ) ) ;
48097: LD_VAR 0 3
48101: PPUSH
48102: CALL_OW 310
48106: PPUSH
48107: CALL_OW 121
// if GetControl ( j ) = control_remote then
48111: LD_VAR 0 3
48115: PPUSH
48116: CALL_OW 263
48120: PUSH
48121: LD_INT 2
48123: EQUAL
48124: IFFALSE 48135
// ComUnlink ( j ) ;
48126: LD_VAR 0 3
48130: PPUSH
48131: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
48135: LD_ADDR_VAR 0 9
48139: PUSH
48140: LD_VAR 0 2
48144: PPUSH
48145: LD_INT 3
48147: PPUSH
48148: CALL 57282 0 2
48152: ST_TO_ADDR
// if fac then
48153: LD_VAR 0 9
48157: IFFALSE 48234
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48159: LD_ADDR_VAR 0 10
48163: PUSH
48164: LD_VAR 0 9
48168: PPUSH
48169: LD_VAR 0 3
48173: PPUSH
48174: CALL_OW 265
48178: PPUSH
48179: LD_VAR 0 3
48183: PPUSH
48184: CALL_OW 262
48188: PPUSH
48189: LD_VAR 0 3
48193: PPUSH
48194: CALL_OW 263
48198: PPUSH
48199: LD_VAR 0 3
48203: PPUSH
48204: CALL_OW 264
48208: PPUSH
48209: CALL 67230 0 5
48213: ST_TO_ADDR
// if components then
48214: LD_VAR 0 10
48218: IFFALSE 48234
// MC_InsertProduceList ( i , components ) ;
48220: LD_VAR 0 2
48224: PPUSH
48225: LD_VAR 0 10
48229: PPUSH
48230: CALL 56910 0 2
// end ; continue ;
48234: GO 47749
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48236: LD_VAR 0 3
48240: PPUSH
48241: LD_INT 1
48243: PPUSH
48244: CALL_OW 289
48248: PUSH
48249: LD_INT 100
48251: LESS
48252: PUSH
48253: LD_VAR 0 3
48257: PPUSH
48258: CALL_OW 314
48262: NOT
48263: AND
48264: IFFALSE 48293
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48266: LD_VAR 0 3
48270: PPUSH
48271: LD_VAR 0 6
48275: PUSH
48276: LD_INT 2
48278: ARRAY
48279: PPUSH
48280: LD_VAR 0 6
48284: PUSH
48285: LD_INT 3
48287: ARRAY
48288: PPUSH
48289: CALL_OW 117
// break ;
48293: GO 48297
// end ;
48295: GO 47749
48297: POP
48298: POP
// end ; end ;
48299: GO 46587
48301: POP
48302: POP
// end ;
48303: LD_VAR 0 1
48307: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48308: LD_INT 0
48310: PPUSH
48311: PPUSH
48312: PPUSH
48313: PPUSH
// if not mc_bases then
48314: LD_EXP 99
48318: NOT
48319: IFFALSE 48323
// exit ;
48321: GO 48484
// for i = 1 to mc_bases do
48323: LD_ADDR_VAR 0 2
48327: PUSH
48328: DOUBLE
48329: LD_INT 1
48331: DEC
48332: ST_TO_ADDR
48333: LD_EXP 99
48337: PUSH
48338: FOR_TO
48339: IFFALSE 48482
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48341: LD_ADDR_VAR 0 4
48345: PUSH
48346: LD_EXP 118
48350: PUSH
48351: LD_VAR 0 2
48355: ARRAY
48356: PUSH
48357: LD_EXP 121
48361: PUSH
48362: LD_VAR 0 2
48366: ARRAY
48367: UNION
48368: PPUSH
48369: LD_INT 33
48371: PUSH
48372: LD_INT 2
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PPUSH
48379: CALL_OW 72
48383: ST_TO_ADDR
// if tmp then
48384: LD_VAR 0 4
48388: IFFALSE 48480
// for j in tmp do
48390: LD_ADDR_VAR 0 3
48394: PUSH
48395: LD_VAR 0 4
48399: PUSH
48400: FOR_IN
48401: IFFALSE 48478
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48403: LD_VAR 0 3
48407: PPUSH
48408: CALL_OW 312
48412: NOT
48413: PUSH
48414: LD_VAR 0 3
48418: PPUSH
48419: CALL_OW 256
48423: PUSH
48424: LD_INT 250
48426: GREATEREQUAL
48427: AND
48428: IFFALSE 48441
// Connect ( j ) else
48430: LD_VAR 0 3
48434: PPUSH
48435: CALL 72570 0 1
48439: GO 48476
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48441: LD_VAR 0 3
48445: PPUSH
48446: CALL_OW 256
48450: PUSH
48451: LD_INT 250
48453: LESS
48454: PUSH
48455: LD_VAR 0 3
48459: PPUSH
48460: CALL_OW 312
48464: AND
48465: IFFALSE 48476
// ComUnlink ( j ) ;
48467: LD_VAR 0 3
48471: PPUSH
48472: CALL_OW 136
48476: GO 48400
48478: POP
48479: POP
// end ;
48480: GO 48338
48482: POP
48483: POP
// end ;
48484: LD_VAR 0 1
48488: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48489: LD_INT 0
48491: PPUSH
48492: PPUSH
48493: PPUSH
48494: PPUSH
48495: PPUSH
// if not mc_bases then
48496: LD_EXP 99
48500: NOT
48501: IFFALSE 48505
// exit ;
48503: GO 48965
// for i = 1 to mc_bases do
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: DOUBLE
48511: LD_INT 1
48513: DEC
48514: ST_TO_ADDR
48515: LD_EXP 99
48519: PUSH
48520: FOR_TO
48521: IFFALSE 48963
// begin if not mc_produce [ i ] then
48523: LD_EXP 120
48527: PUSH
48528: LD_VAR 0 2
48532: ARRAY
48533: NOT
48534: IFFALSE 48538
// continue ;
48536: GO 48520
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48538: LD_ADDR_VAR 0 5
48542: PUSH
48543: LD_EXP 99
48547: PUSH
48548: LD_VAR 0 2
48552: ARRAY
48553: PPUSH
48554: LD_INT 30
48556: PUSH
48557: LD_INT 3
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PPUSH
48564: CALL_OW 72
48568: ST_TO_ADDR
// if not fac then
48569: LD_VAR 0 5
48573: NOT
48574: IFFALSE 48578
// continue ;
48576: GO 48520
// for j in fac do
48578: LD_ADDR_VAR 0 3
48582: PUSH
48583: LD_VAR 0 5
48587: PUSH
48588: FOR_IN
48589: IFFALSE 48959
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
48591: LD_VAR 0 3
48595: PPUSH
48596: CALL_OW 461
48600: PUSH
48601: LD_INT 2
48603: NONEQUAL
48604: PUSH
48605: LD_VAR 0 3
48609: PPUSH
48610: LD_INT 15
48612: PPUSH
48613: CALL 72230 0 2
48617: PUSH
48618: LD_INT 4
48620: ARRAY
48621: OR
48622: PUSH
48623: LD_VAR 0 3
48627: PPUSH
48628: CALL_OW 313
48632: PUSH
48633: LD_INT 0
48635: EQUAL
48636: OR
48637: IFFALSE 48641
// continue ;
48639: GO 48588
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
48641: LD_VAR 0 3
48645: PPUSH
48646: LD_EXP 120
48650: PUSH
48651: LD_VAR 0 2
48655: ARRAY
48656: PUSH
48657: LD_INT 1
48659: ARRAY
48660: PUSH
48661: LD_INT 1
48663: ARRAY
48664: PPUSH
48665: LD_EXP 120
48669: PUSH
48670: LD_VAR 0 2
48674: ARRAY
48675: PUSH
48676: LD_INT 1
48678: ARRAY
48679: PUSH
48680: LD_INT 2
48682: ARRAY
48683: PPUSH
48684: LD_EXP 120
48688: PUSH
48689: LD_VAR 0 2
48693: ARRAY
48694: PUSH
48695: LD_INT 1
48697: ARRAY
48698: PUSH
48699: LD_INT 3
48701: ARRAY
48702: PPUSH
48703: LD_EXP 120
48707: PUSH
48708: LD_VAR 0 2
48712: ARRAY
48713: PUSH
48714: LD_INT 1
48716: ARRAY
48717: PUSH
48718: LD_INT 4
48720: ARRAY
48721: PPUSH
48722: CALL_OW 448
48726: PUSH
48727: LD_VAR 0 3
48731: PPUSH
48732: LD_EXP 120
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: PUSH
48743: LD_INT 1
48745: ARRAY
48746: PUSH
48747: LD_INT 1
48749: ARRAY
48750: PUSH
48751: LD_EXP 120
48755: PUSH
48756: LD_VAR 0 2
48760: ARRAY
48761: PUSH
48762: LD_INT 1
48764: ARRAY
48765: PUSH
48766: LD_INT 2
48768: ARRAY
48769: PUSH
48770: LD_EXP 120
48774: PUSH
48775: LD_VAR 0 2
48779: ARRAY
48780: PUSH
48781: LD_INT 1
48783: ARRAY
48784: PUSH
48785: LD_INT 3
48787: ARRAY
48788: PUSH
48789: LD_EXP 120
48793: PUSH
48794: LD_VAR 0 2
48798: ARRAY
48799: PUSH
48800: LD_INT 1
48802: ARRAY
48803: PUSH
48804: LD_INT 4
48806: ARRAY
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: PPUSH
48814: CALL 75901 0 2
48818: AND
48819: IFFALSE 48957
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
48821: LD_VAR 0 3
48825: PPUSH
48826: LD_EXP 120
48830: PUSH
48831: LD_VAR 0 2
48835: ARRAY
48836: PUSH
48837: LD_INT 1
48839: ARRAY
48840: PUSH
48841: LD_INT 1
48843: ARRAY
48844: PPUSH
48845: LD_EXP 120
48849: PUSH
48850: LD_VAR 0 2
48854: ARRAY
48855: PUSH
48856: LD_INT 1
48858: ARRAY
48859: PUSH
48860: LD_INT 2
48862: ARRAY
48863: PPUSH
48864: LD_EXP 120
48868: PUSH
48869: LD_VAR 0 2
48873: ARRAY
48874: PUSH
48875: LD_INT 1
48877: ARRAY
48878: PUSH
48879: LD_INT 3
48881: ARRAY
48882: PPUSH
48883: LD_EXP 120
48887: PUSH
48888: LD_VAR 0 2
48892: ARRAY
48893: PUSH
48894: LD_INT 1
48896: ARRAY
48897: PUSH
48898: LD_INT 4
48900: ARRAY
48901: PPUSH
48902: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
48906: LD_ADDR_VAR 0 4
48910: PUSH
48911: LD_EXP 120
48915: PUSH
48916: LD_VAR 0 2
48920: ARRAY
48921: PPUSH
48922: LD_INT 1
48924: PPUSH
48925: CALL_OW 3
48929: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48930: LD_ADDR_EXP 120
48934: PUSH
48935: LD_EXP 120
48939: PPUSH
48940: LD_VAR 0 2
48944: PPUSH
48945: LD_VAR 0 4
48949: PPUSH
48950: CALL_OW 1
48954: ST_TO_ADDR
// break ;
48955: GO 48959
// end ; end ;
48957: GO 48588
48959: POP
48960: POP
// end ;
48961: GO 48520
48963: POP
48964: POP
// end ;
48965: LD_VAR 0 1
48969: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
48970: LD_INT 0
48972: PPUSH
48973: PPUSH
48974: PPUSH
// if not mc_bases then
48975: LD_EXP 99
48979: NOT
48980: IFFALSE 48984
// exit ;
48982: GO 49073
// for i = 1 to mc_bases do
48984: LD_ADDR_VAR 0 2
48988: PUSH
48989: DOUBLE
48990: LD_INT 1
48992: DEC
48993: ST_TO_ADDR
48994: LD_EXP 99
48998: PUSH
48999: FOR_TO
49000: IFFALSE 49071
// begin if mc_attack [ i ] then
49002: LD_EXP 119
49006: PUSH
49007: LD_VAR 0 2
49011: ARRAY
49012: IFFALSE 49069
// begin tmp := mc_attack [ i ] [ 1 ] ;
49014: LD_ADDR_VAR 0 3
49018: PUSH
49019: LD_EXP 119
49023: PUSH
49024: LD_VAR 0 2
49028: ARRAY
49029: PUSH
49030: LD_INT 1
49032: ARRAY
49033: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49034: LD_ADDR_EXP 119
49038: PUSH
49039: LD_EXP 119
49043: PPUSH
49044: LD_VAR 0 2
49048: PPUSH
49049: EMPTY
49050: PPUSH
49051: CALL_OW 1
49055: ST_TO_ADDR
// Attack ( tmp ) ;
49056: LD_VAR 0 3
49060: PPUSH
49061: CALL 98114 0 1
// exit ;
49065: POP
49066: POP
49067: GO 49073
// end ; end ;
49069: GO 48999
49071: POP
49072: POP
// end ;
49073: LD_VAR 0 1
49077: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49078: LD_INT 0
49080: PPUSH
49081: PPUSH
49082: PPUSH
49083: PPUSH
49084: PPUSH
49085: PPUSH
49086: PPUSH
// if not mc_bases then
49087: LD_EXP 99
49091: NOT
49092: IFFALSE 49096
// exit ;
49094: GO 49678
// for i = 1 to mc_bases do
49096: LD_ADDR_VAR 0 2
49100: PUSH
49101: DOUBLE
49102: LD_INT 1
49104: DEC
49105: ST_TO_ADDR
49106: LD_EXP 99
49110: PUSH
49111: FOR_TO
49112: IFFALSE 49676
// begin if not mc_bases [ i ] then
49114: LD_EXP 99
49118: PUSH
49119: LD_VAR 0 2
49123: ARRAY
49124: NOT
49125: IFFALSE 49129
// continue ;
49127: GO 49111
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49129: LD_ADDR_VAR 0 7
49133: PUSH
49134: LD_EXP 99
49138: PUSH
49139: LD_VAR 0 2
49143: ARRAY
49144: PUSH
49145: LD_INT 1
49147: ARRAY
49148: PPUSH
49149: CALL 66534 0 1
49153: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49154: LD_ADDR_EXP 122
49158: PUSH
49159: LD_EXP 122
49163: PPUSH
49164: LD_VAR 0 2
49168: PPUSH
49169: LD_EXP 99
49173: PUSH
49174: LD_VAR 0 2
49178: ARRAY
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PPUSH
49184: CALL_OW 255
49188: PPUSH
49189: LD_EXP 124
49193: PUSH
49194: LD_VAR 0 2
49198: ARRAY
49199: PPUSH
49200: CALL 64531 0 2
49204: PPUSH
49205: CALL_OW 1
49209: ST_TO_ADDR
// if not mc_scan [ i ] then
49210: LD_EXP 122
49214: PUSH
49215: LD_VAR 0 2
49219: ARRAY
49220: NOT
49221: IFFALSE 49376
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49223: LD_ADDR_VAR 0 4
49227: PUSH
49228: LD_EXP 99
49232: PUSH
49233: LD_VAR 0 2
49237: ARRAY
49238: PPUSH
49239: LD_INT 2
49241: PUSH
49242: LD_INT 25
49244: PUSH
49245: LD_INT 5
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 25
49254: PUSH
49255: LD_INT 8
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: PUSH
49262: LD_INT 25
49264: PUSH
49265: LD_INT 9
49267: PUSH
49268: EMPTY
49269: LIST
49270: LIST
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: LIST
49277: PPUSH
49278: CALL_OW 72
49282: ST_TO_ADDR
// if not tmp then
49283: LD_VAR 0 4
49287: NOT
49288: IFFALSE 49292
// continue ;
49290: GO 49111
// for j in tmp do
49292: LD_ADDR_VAR 0 3
49296: PUSH
49297: LD_VAR 0 4
49301: PUSH
49302: FOR_IN
49303: IFFALSE 49374
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49305: LD_VAR 0 3
49309: PPUSH
49310: CALL_OW 310
49314: PPUSH
49315: CALL_OW 266
49319: PUSH
49320: LD_INT 5
49322: EQUAL
49323: PUSH
49324: LD_VAR 0 3
49328: PPUSH
49329: CALL_OW 257
49333: PUSH
49334: LD_INT 1
49336: EQUAL
49337: AND
49338: PUSH
49339: LD_VAR 0 3
49343: PPUSH
49344: CALL_OW 459
49348: NOT
49349: AND
49350: PUSH
49351: LD_VAR 0 7
49355: AND
49356: IFFALSE 49372
// ComChangeProfession ( j , class ) ;
49358: LD_VAR 0 3
49362: PPUSH
49363: LD_VAR 0 7
49367: PPUSH
49368: CALL_OW 123
49372: GO 49302
49374: POP
49375: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49376: LD_EXP 122
49380: PUSH
49381: LD_VAR 0 2
49385: ARRAY
49386: PUSH
49387: LD_EXP 121
49391: PUSH
49392: LD_VAR 0 2
49396: ARRAY
49397: NOT
49398: AND
49399: PUSH
49400: LD_EXP 99
49404: PUSH
49405: LD_VAR 0 2
49409: ARRAY
49410: PPUSH
49411: LD_INT 30
49413: PUSH
49414: LD_INT 32
49416: PUSH
49417: EMPTY
49418: LIST
49419: LIST
49420: PPUSH
49421: CALL_OW 72
49425: NOT
49426: AND
49427: PUSH
49428: LD_EXP 99
49432: PUSH
49433: LD_VAR 0 2
49437: ARRAY
49438: PPUSH
49439: LD_INT 2
49441: PUSH
49442: LD_INT 30
49444: PUSH
49445: LD_INT 4
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 30
49454: PUSH
49455: LD_INT 5
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: LIST
49466: PPUSH
49467: CALL_OW 72
49471: NOT
49472: AND
49473: IFFALSE 49605
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49475: LD_ADDR_VAR 0 4
49479: PUSH
49480: LD_EXP 99
49484: PUSH
49485: LD_VAR 0 2
49489: ARRAY
49490: PPUSH
49491: LD_INT 2
49493: PUSH
49494: LD_INT 25
49496: PUSH
49497: LD_INT 1
49499: PUSH
49500: EMPTY
49501: LIST
49502: LIST
49503: PUSH
49504: LD_INT 25
49506: PUSH
49507: LD_INT 5
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: PUSH
49514: LD_INT 25
49516: PUSH
49517: LD_INT 8
49519: PUSH
49520: EMPTY
49521: LIST
49522: LIST
49523: PUSH
49524: LD_INT 25
49526: PUSH
49527: LD_INT 9
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: LIST
49538: LIST
49539: LIST
49540: PPUSH
49541: CALL_OW 72
49545: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49546: LD_ADDR_VAR 0 4
49550: PUSH
49551: LD_VAR 0 4
49555: PUSH
49556: LD_VAR 0 4
49560: PPUSH
49561: LD_INT 18
49563: PPUSH
49564: CALL 102897 0 2
49568: DIFF
49569: ST_TO_ADDR
// if tmp then
49570: LD_VAR 0 4
49574: IFFALSE 49605
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
49576: LD_VAR 0 2
49580: PPUSH
49581: LD_VAR 0 4
49585: PPUSH
49586: LD_EXP 124
49590: PUSH
49591: LD_VAR 0 2
49595: ARRAY
49596: PPUSH
49597: CALL 64566 0 3
// exit ;
49601: POP
49602: POP
49603: GO 49678
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
49605: LD_EXP 122
49609: PUSH
49610: LD_VAR 0 2
49614: ARRAY
49615: PUSH
49616: LD_EXP 121
49620: PUSH
49621: LD_VAR 0 2
49625: ARRAY
49626: AND
49627: IFFALSE 49674
// begin tmp := mc_defender [ i ] ;
49629: LD_ADDR_VAR 0 4
49633: PUSH
49634: LD_EXP 121
49638: PUSH
49639: LD_VAR 0 2
49643: ARRAY
49644: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
49645: LD_VAR 0 2
49649: PPUSH
49650: LD_VAR 0 4
49654: PPUSH
49655: LD_EXP 122
49659: PUSH
49660: LD_VAR 0 2
49664: ARRAY
49665: PPUSH
49666: CALL 65064 0 3
// exit ;
49670: POP
49671: POP
49672: GO 49678
// end ; end ;
49674: GO 49111
49676: POP
49677: POP
// end ;
49678: LD_VAR 0 1
49682: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
49683: LD_INT 0
49685: PPUSH
49686: PPUSH
49687: PPUSH
49688: PPUSH
49689: PPUSH
49690: PPUSH
49691: PPUSH
49692: PPUSH
49693: PPUSH
49694: PPUSH
49695: PPUSH
// if not mc_bases then
49696: LD_EXP 99
49700: NOT
49701: IFFALSE 49705
// exit ;
49703: GO 50792
// for i = 1 to mc_bases do
49705: LD_ADDR_VAR 0 2
49709: PUSH
49710: DOUBLE
49711: LD_INT 1
49713: DEC
49714: ST_TO_ADDR
49715: LD_EXP 99
49719: PUSH
49720: FOR_TO
49721: IFFALSE 50790
// begin tmp := mc_lab [ i ] ;
49723: LD_ADDR_VAR 0 6
49727: PUSH
49728: LD_EXP 132
49732: PUSH
49733: LD_VAR 0 2
49737: ARRAY
49738: ST_TO_ADDR
// if not tmp then
49739: LD_VAR 0 6
49743: NOT
49744: IFFALSE 49748
// continue ;
49746: GO 49720
// idle_lab := 0 ;
49748: LD_ADDR_VAR 0 11
49752: PUSH
49753: LD_INT 0
49755: ST_TO_ADDR
// for j in tmp do
49756: LD_ADDR_VAR 0 3
49760: PUSH
49761: LD_VAR 0 6
49765: PUSH
49766: FOR_IN
49767: IFFALSE 50786
// begin researching := false ;
49769: LD_ADDR_VAR 0 10
49773: PUSH
49774: LD_INT 0
49776: ST_TO_ADDR
// side := GetSide ( j ) ;
49777: LD_ADDR_VAR 0 4
49781: PUSH
49782: LD_VAR 0 3
49786: PPUSH
49787: CALL_OW 255
49791: ST_TO_ADDR
// if not mc_tech [ side ] then
49792: LD_EXP 126
49796: PUSH
49797: LD_VAR 0 4
49801: ARRAY
49802: NOT
49803: IFFALSE 49807
// continue ;
49805: GO 49766
// if BuildingStatus ( j ) = bs_idle then
49807: LD_VAR 0 3
49811: PPUSH
49812: CALL_OW 461
49816: PUSH
49817: LD_INT 2
49819: EQUAL
49820: IFFALSE 50008
// begin if idle_lab and UnitsInside ( j ) < 6 then
49822: LD_VAR 0 11
49826: PUSH
49827: LD_VAR 0 3
49831: PPUSH
49832: CALL_OW 313
49836: PUSH
49837: LD_INT 6
49839: LESS
49840: AND
49841: IFFALSE 49912
// begin tmp2 := UnitsInside ( idle_lab ) ;
49843: LD_ADDR_VAR 0 9
49847: PUSH
49848: LD_VAR 0 11
49852: PPUSH
49853: CALL_OW 313
49857: ST_TO_ADDR
// if tmp2 then
49858: LD_VAR 0 9
49862: IFFALSE 49904
// for x in tmp2 do
49864: LD_ADDR_VAR 0 7
49868: PUSH
49869: LD_VAR 0 9
49873: PUSH
49874: FOR_IN
49875: IFFALSE 49902
// begin ComExitBuilding ( x ) ;
49877: LD_VAR 0 7
49881: PPUSH
49882: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49886: LD_VAR 0 7
49890: PPUSH
49891: LD_VAR 0 3
49895: PPUSH
49896: CALL_OW 180
// end ;
49900: GO 49874
49902: POP
49903: POP
// idle_lab := 0 ;
49904: LD_ADDR_VAR 0 11
49908: PUSH
49909: LD_INT 0
49911: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
49912: LD_ADDR_VAR 0 5
49916: PUSH
49917: LD_EXP 126
49921: PUSH
49922: LD_VAR 0 4
49926: ARRAY
49927: PUSH
49928: FOR_IN
49929: IFFALSE 49989
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
49931: LD_VAR 0 3
49935: PPUSH
49936: LD_VAR 0 5
49940: PPUSH
49941: CALL_OW 430
49945: PUSH
49946: LD_VAR 0 4
49950: PPUSH
49951: LD_VAR 0 5
49955: PPUSH
49956: CALL 63636 0 2
49960: AND
49961: IFFALSE 49987
// begin researching := true ;
49963: LD_ADDR_VAR 0 10
49967: PUSH
49968: LD_INT 1
49970: ST_TO_ADDR
// ComResearch ( j , t ) ;
49971: LD_VAR 0 3
49975: PPUSH
49976: LD_VAR 0 5
49980: PPUSH
49981: CALL_OW 124
// break ;
49985: GO 49989
// end ;
49987: GO 49928
49989: POP
49990: POP
// if not researching then
49991: LD_VAR 0 10
49995: NOT
49996: IFFALSE 50008
// idle_lab := j ;
49998: LD_ADDR_VAR 0 11
50002: PUSH
50003: LD_VAR 0 3
50007: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50008: LD_VAR 0 3
50012: PPUSH
50013: CALL_OW 461
50017: PUSH
50018: LD_INT 10
50020: EQUAL
50021: IFFALSE 50609
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50023: LD_EXP 128
50027: PUSH
50028: LD_VAR 0 2
50032: ARRAY
50033: NOT
50034: PUSH
50035: LD_EXP 129
50039: PUSH
50040: LD_VAR 0 2
50044: ARRAY
50045: NOT
50046: AND
50047: PUSH
50048: LD_EXP 126
50052: PUSH
50053: LD_VAR 0 4
50057: ARRAY
50058: PUSH
50059: LD_INT 1
50061: GREATER
50062: AND
50063: IFFALSE 50194
// begin ComCancel ( j ) ;
50065: LD_VAR 0 3
50069: PPUSH
50070: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50074: LD_ADDR_EXP 126
50078: PUSH
50079: LD_EXP 126
50083: PPUSH
50084: LD_VAR 0 4
50088: PPUSH
50089: LD_EXP 126
50093: PUSH
50094: LD_VAR 0 4
50098: ARRAY
50099: PPUSH
50100: LD_EXP 126
50104: PUSH
50105: LD_VAR 0 4
50109: ARRAY
50110: PUSH
50111: LD_INT 1
50113: MINUS
50114: PPUSH
50115: LD_EXP 126
50119: PUSH
50120: LD_VAR 0 4
50124: ARRAY
50125: PPUSH
50126: LD_INT 0
50128: PPUSH
50129: CALL 69055 0 4
50133: PPUSH
50134: CALL_OW 1
50138: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50139: LD_ADDR_EXP 126
50143: PUSH
50144: LD_EXP 126
50148: PPUSH
50149: LD_VAR 0 4
50153: PPUSH
50154: LD_EXP 126
50158: PUSH
50159: LD_VAR 0 4
50163: ARRAY
50164: PPUSH
50165: LD_EXP 126
50169: PUSH
50170: LD_VAR 0 4
50174: ARRAY
50175: PPUSH
50176: LD_INT 1
50178: PPUSH
50179: LD_INT 0
50181: PPUSH
50182: CALL 69055 0 4
50186: PPUSH
50187: CALL_OW 1
50191: ST_TO_ADDR
// continue ;
50192: GO 49766
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50194: LD_EXP 128
50198: PUSH
50199: LD_VAR 0 2
50203: ARRAY
50204: PUSH
50205: LD_EXP 129
50209: PUSH
50210: LD_VAR 0 2
50214: ARRAY
50215: NOT
50216: AND
50217: IFFALSE 50344
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50219: LD_ADDR_EXP 129
50223: PUSH
50224: LD_EXP 129
50228: PPUSH
50229: LD_VAR 0 2
50233: PUSH
50234: LD_EXP 129
50238: PUSH
50239: LD_VAR 0 2
50243: ARRAY
50244: PUSH
50245: LD_INT 1
50247: PLUS
50248: PUSH
50249: EMPTY
50250: LIST
50251: LIST
50252: PPUSH
50253: LD_EXP 128
50257: PUSH
50258: LD_VAR 0 2
50262: ARRAY
50263: PUSH
50264: LD_INT 1
50266: ARRAY
50267: PPUSH
50268: CALL 69637 0 3
50272: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50273: LD_EXP 128
50277: PUSH
50278: LD_VAR 0 2
50282: ARRAY
50283: PUSH
50284: LD_INT 1
50286: ARRAY
50287: PPUSH
50288: LD_INT 112
50290: PPUSH
50291: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50295: LD_ADDR_VAR 0 9
50299: PUSH
50300: LD_EXP 128
50304: PUSH
50305: LD_VAR 0 2
50309: ARRAY
50310: PPUSH
50311: LD_INT 1
50313: PPUSH
50314: CALL_OW 3
50318: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50319: LD_ADDR_EXP 128
50323: PUSH
50324: LD_EXP 128
50328: PPUSH
50329: LD_VAR 0 2
50333: PPUSH
50334: LD_VAR 0 9
50338: PPUSH
50339: CALL_OW 1
50343: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50344: LD_EXP 128
50348: PUSH
50349: LD_VAR 0 2
50353: ARRAY
50354: PUSH
50355: LD_EXP 129
50359: PUSH
50360: LD_VAR 0 2
50364: ARRAY
50365: AND
50366: PUSH
50367: LD_EXP 129
50371: PUSH
50372: LD_VAR 0 2
50376: ARRAY
50377: PUSH
50378: LD_INT 1
50380: ARRAY
50381: PPUSH
50382: CALL_OW 310
50386: NOT
50387: AND
50388: PUSH
50389: LD_VAR 0 3
50393: PPUSH
50394: CALL_OW 313
50398: PUSH
50399: LD_INT 6
50401: EQUAL
50402: AND
50403: IFFALSE 50459
// begin tmp2 := UnitsInside ( j ) ;
50405: LD_ADDR_VAR 0 9
50409: PUSH
50410: LD_VAR 0 3
50414: PPUSH
50415: CALL_OW 313
50419: ST_TO_ADDR
// if tmp2 = 6 then
50420: LD_VAR 0 9
50424: PUSH
50425: LD_INT 6
50427: EQUAL
50428: IFFALSE 50459
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50430: LD_VAR 0 9
50434: PUSH
50435: LD_INT 1
50437: ARRAY
50438: PPUSH
50439: LD_INT 112
50441: PPUSH
50442: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50446: LD_VAR 0 9
50450: PUSH
50451: LD_INT 1
50453: ARRAY
50454: PPUSH
50455: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50459: LD_EXP 129
50463: PUSH
50464: LD_VAR 0 2
50468: ARRAY
50469: PUSH
50470: LD_EXP 129
50474: PUSH
50475: LD_VAR 0 2
50479: ARRAY
50480: PUSH
50481: LD_INT 1
50483: ARRAY
50484: PPUSH
50485: CALL_OW 314
50489: NOT
50490: AND
50491: PUSH
50492: LD_EXP 129
50496: PUSH
50497: LD_VAR 0 2
50501: ARRAY
50502: PUSH
50503: LD_INT 1
50505: ARRAY
50506: PPUSH
50507: CALL_OW 310
50511: NOT
50512: AND
50513: IFFALSE 50539
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50515: LD_EXP 129
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: PUSH
50526: LD_INT 1
50528: ARRAY
50529: PPUSH
50530: LD_VAR 0 3
50534: PPUSH
50535: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50539: LD_EXP 129
50543: PUSH
50544: LD_VAR 0 2
50548: ARRAY
50549: PUSH
50550: LD_INT 1
50552: ARRAY
50553: PPUSH
50554: CALL_OW 310
50558: PUSH
50559: LD_EXP 129
50563: PUSH
50564: LD_VAR 0 2
50568: ARRAY
50569: PUSH
50570: LD_INT 1
50572: ARRAY
50573: PPUSH
50574: CALL_OW 310
50578: PPUSH
50579: CALL_OW 461
50583: PUSH
50584: LD_INT 3
50586: NONEQUAL
50587: AND
50588: IFFALSE 50609
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
50590: LD_EXP 129
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: PUSH
50601: LD_INT 1
50603: ARRAY
50604: PPUSH
50605: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
50609: LD_VAR 0 3
50613: PPUSH
50614: CALL_OW 461
50618: PUSH
50619: LD_INT 6
50621: EQUAL
50622: PUSH
50623: LD_VAR 0 6
50627: PUSH
50628: LD_INT 1
50630: GREATER
50631: AND
50632: IFFALSE 50784
// begin sci := [ ] ;
50634: LD_ADDR_VAR 0 8
50638: PUSH
50639: EMPTY
50640: ST_TO_ADDR
// for x in ( tmp diff j ) do
50641: LD_ADDR_VAR 0 7
50645: PUSH
50646: LD_VAR 0 6
50650: PUSH
50651: LD_VAR 0 3
50655: DIFF
50656: PUSH
50657: FOR_IN
50658: IFFALSE 50710
// begin if sci = 6 then
50660: LD_VAR 0 8
50664: PUSH
50665: LD_INT 6
50667: EQUAL
50668: IFFALSE 50672
// break ;
50670: GO 50710
// if BuildingStatus ( x ) = bs_idle then
50672: LD_VAR 0 7
50676: PPUSH
50677: CALL_OW 461
50681: PUSH
50682: LD_INT 2
50684: EQUAL
50685: IFFALSE 50708
// sci := sci ^ UnitsInside ( x ) ;
50687: LD_ADDR_VAR 0 8
50691: PUSH
50692: LD_VAR 0 8
50696: PUSH
50697: LD_VAR 0 7
50701: PPUSH
50702: CALL_OW 313
50706: ADD
50707: ST_TO_ADDR
// end ;
50708: GO 50657
50710: POP
50711: POP
// if not sci then
50712: LD_VAR 0 8
50716: NOT
50717: IFFALSE 50721
// continue ;
50719: GO 49766
// for x in sci do
50721: LD_ADDR_VAR 0 7
50725: PUSH
50726: LD_VAR 0 8
50730: PUSH
50731: FOR_IN
50732: IFFALSE 50782
// if IsInUnit ( x ) and not HasTask ( x ) then
50734: LD_VAR 0 7
50738: PPUSH
50739: CALL_OW 310
50743: PUSH
50744: LD_VAR 0 7
50748: PPUSH
50749: CALL_OW 314
50753: NOT
50754: AND
50755: IFFALSE 50780
// begin ComExitBuilding ( x ) ;
50757: LD_VAR 0 7
50761: PPUSH
50762: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50766: LD_VAR 0 7
50770: PPUSH
50771: LD_VAR 0 3
50775: PPUSH
50776: CALL_OW 180
// end ;
50780: GO 50731
50782: POP
50783: POP
// end ; end ;
50784: GO 49766
50786: POP
50787: POP
// end ;
50788: GO 49720
50790: POP
50791: POP
// end ;
50792: LD_VAR 0 1
50796: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
50797: LD_INT 0
50799: PPUSH
50800: PPUSH
// if not mc_bases then
50801: LD_EXP 99
50805: NOT
50806: IFFALSE 50810
// exit ;
50808: GO 50891
// for i = 1 to mc_bases do
50810: LD_ADDR_VAR 0 2
50814: PUSH
50815: DOUBLE
50816: LD_INT 1
50818: DEC
50819: ST_TO_ADDR
50820: LD_EXP 99
50824: PUSH
50825: FOR_TO
50826: IFFALSE 50889
// if mc_mines [ i ] and mc_miners [ i ] then
50828: LD_EXP 112
50832: PUSH
50833: LD_VAR 0 2
50837: ARRAY
50838: PUSH
50839: LD_EXP 113
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: AND
50850: IFFALSE 50887
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
50852: LD_EXP 113
50856: PUSH
50857: LD_VAR 0 2
50861: ARRAY
50862: PUSH
50863: LD_INT 1
50865: ARRAY
50866: PPUSH
50867: CALL_OW 255
50871: PPUSH
50872: LD_EXP 112
50876: PUSH
50877: LD_VAR 0 2
50881: ARRAY
50882: PPUSH
50883: CALL 66687 0 2
50887: GO 50825
50889: POP
50890: POP
// end ;
50891: LD_VAR 0 1
50895: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
50896: LD_INT 0
50898: PPUSH
50899: PPUSH
50900: PPUSH
50901: PPUSH
50902: PPUSH
50903: PPUSH
50904: PPUSH
50905: PPUSH
// if not mc_bases or not mc_parking then
50906: LD_EXP 99
50910: NOT
50911: PUSH
50912: LD_EXP 123
50916: NOT
50917: OR
50918: IFFALSE 50922
// exit ;
50920: GO 51598
// for i = 1 to mc_bases do
50922: LD_ADDR_VAR 0 2
50926: PUSH
50927: DOUBLE
50928: LD_INT 1
50930: DEC
50931: ST_TO_ADDR
50932: LD_EXP 99
50936: PUSH
50937: FOR_TO
50938: IFFALSE 51596
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
50940: LD_EXP 99
50944: PUSH
50945: LD_VAR 0 2
50949: ARRAY
50950: NOT
50951: PUSH
50952: LD_EXP 123
50956: PUSH
50957: LD_VAR 0 2
50961: ARRAY
50962: NOT
50963: OR
50964: IFFALSE 50968
// continue ;
50966: GO 50937
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50968: LD_ADDR_VAR 0 5
50972: PUSH
50973: LD_EXP 99
50977: PUSH
50978: LD_VAR 0 2
50982: ARRAY
50983: PUSH
50984: LD_INT 1
50986: ARRAY
50987: PPUSH
50988: CALL_OW 255
50992: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50993: LD_ADDR_VAR 0 6
50997: PUSH
50998: LD_EXP 99
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: PPUSH
51009: LD_INT 30
51011: PUSH
51012: LD_INT 3
51014: PUSH
51015: EMPTY
51016: LIST
51017: LIST
51018: PPUSH
51019: CALL_OW 72
51023: ST_TO_ADDR
// if not fac then
51024: LD_VAR 0 6
51028: NOT
51029: IFFALSE 51080
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51031: LD_ADDR_VAR 0 6
51035: PUSH
51036: LD_EXP 99
51040: PUSH
51041: LD_VAR 0 2
51045: ARRAY
51046: PPUSH
51047: LD_INT 2
51049: PUSH
51050: LD_INT 30
51052: PUSH
51053: LD_INT 0
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: PUSH
51060: LD_INT 30
51062: PUSH
51063: LD_INT 1
51065: PUSH
51066: EMPTY
51067: LIST
51068: LIST
51069: PUSH
51070: EMPTY
51071: LIST
51072: LIST
51073: LIST
51074: PPUSH
51075: CALL_OW 72
51079: ST_TO_ADDR
// if not fac then
51080: LD_VAR 0 6
51084: NOT
51085: IFFALSE 51089
// continue ;
51087: GO 50937
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51089: LD_ADDR_VAR 0 7
51093: PUSH
51094: LD_EXP 123
51098: PUSH
51099: LD_VAR 0 2
51103: ARRAY
51104: PPUSH
51105: LD_INT 22
51107: PUSH
51108: LD_VAR 0 5
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: PUSH
51117: LD_INT 21
51119: PUSH
51120: LD_INT 2
51122: PUSH
51123: EMPTY
51124: LIST
51125: LIST
51126: PUSH
51127: LD_INT 3
51129: PUSH
51130: LD_INT 24
51132: PUSH
51133: LD_INT 1000
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: LIST
51148: PPUSH
51149: CALL_OW 70
51153: PUSH
51154: LD_INT 22
51156: PUSH
51157: LD_VAR 0 5
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PUSH
51166: LD_INT 91
51168: PUSH
51169: LD_VAR 0 6
51173: PUSH
51174: LD_INT 1
51176: ARRAY
51177: PUSH
51178: LD_INT 25
51180: PUSH
51181: EMPTY
51182: LIST
51183: LIST
51184: LIST
51185: PUSH
51186: LD_INT 21
51188: PUSH
51189: LD_INT 2
51191: PUSH
51192: EMPTY
51193: LIST
51194: LIST
51195: PUSH
51196: LD_INT 3
51198: PUSH
51199: LD_INT 24
51201: PUSH
51202: LD_INT 1000
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: EMPTY
51214: LIST
51215: LIST
51216: LIST
51217: LIST
51218: PPUSH
51219: CALL_OW 69
51223: UNION
51224: ST_TO_ADDR
// if not vehs then
51225: LD_VAR 0 7
51229: NOT
51230: IFFALSE 51256
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51232: LD_ADDR_EXP 111
51236: PUSH
51237: LD_EXP 111
51241: PPUSH
51242: LD_VAR 0 2
51246: PPUSH
51247: EMPTY
51248: PPUSH
51249: CALL_OW 1
51253: ST_TO_ADDR
// continue ;
51254: GO 50937
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51256: LD_ADDR_VAR 0 8
51260: PUSH
51261: LD_EXP 99
51265: PUSH
51266: LD_VAR 0 2
51270: ARRAY
51271: PPUSH
51272: LD_INT 30
51274: PUSH
51275: LD_INT 3
51277: PUSH
51278: EMPTY
51279: LIST
51280: LIST
51281: PPUSH
51282: CALL_OW 72
51286: ST_TO_ADDR
// if tmp then
51287: LD_VAR 0 8
51291: IFFALSE 51394
// begin for j in tmp do
51293: LD_ADDR_VAR 0 3
51297: PUSH
51298: LD_VAR 0 8
51302: PUSH
51303: FOR_IN
51304: IFFALSE 51392
// for k in UnitsInside ( j ) do
51306: LD_ADDR_VAR 0 4
51310: PUSH
51311: LD_VAR 0 3
51315: PPUSH
51316: CALL_OW 313
51320: PUSH
51321: FOR_IN
51322: IFFALSE 51388
// if k then
51324: LD_VAR 0 4
51328: IFFALSE 51386
// if not k in mc_repair_vehicle [ i ] then
51330: LD_VAR 0 4
51334: PUSH
51335: LD_EXP 111
51339: PUSH
51340: LD_VAR 0 2
51344: ARRAY
51345: IN
51346: NOT
51347: IFFALSE 51386
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51349: LD_ADDR_EXP 111
51353: PUSH
51354: LD_EXP 111
51358: PPUSH
51359: LD_VAR 0 2
51363: PPUSH
51364: LD_EXP 111
51368: PUSH
51369: LD_VAR 0 2
51373: ARRAY
51374: PUSH
51375: LD_VAR 0 4
51379: UNION
51380: PPUSH
51381: CALL_OW 1
51385: ST_TO_ADDR
51386: GO 51321
51388: POP
51389: POP
51390: GO 51303
51392: POP
51393: POP
// end ; if not mc_repair_vehicle [ i ] then
51394: LD_EXP 111
51398: PUSH
51399: LD_VAR 0 2
51403: ARRAY
51404: NOT
51405: IFFALSE 51409
// continue ;
51407: GO 50937
// for j in mc_repair_vehicle [ i ] do
51409: LD_ADDR_VAR 0 3
51413: PUSH
51414: LD_EXP 111
51418: PUSH
51419: LD_VAR 0 2
51423: ARRAY
51424: PUSH
51425: FOR_IN
51426: IFFALSE 51592
// begin if GetClass ( j ) <> 3 then
51428: LD_VAR 0 3
51432: PPUSH
51433: CALL_OW 257
51437: PUSH
51438: LD_INT 3
51440: NONEQUAL
51441: IFFALSE 51482
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51443: LD_ADDR_EXP 111
51447: PUSH
51448: LD_EXP 111
51452: PPUSH
51453: LD_VAR 0 2
51457: PPUSH
51458: LD_EXP 111
51462: PUSH
51463: LD_VAR 0 2
51467: ARRAY
51468: PUSH
51469: LD_VAR 0 3
51473: DIFF
51474: PPUSH
51475: CALL_OW 1
51479: ST_TO_ADDR
// continue ;
51480: GO 51425
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51482: LD_VAR 0 3
51486: PPUSH
51487: CALL_OW 311
51491: NOT
51492: PUSH
51493: LD_VAR 0 3
51497: PUSH
51498: LD_EXP 102
51502: PUSH
51503: LD_VAR 0 2
51507: ARRAY
51508: PUSH
51509: LD_INT 1
51511: ARRAY
51512: IN
51513: NOT
51514: AND
51515: PUSH
51516: LD_VAR 0 3
51520: PUSH
51521: LD_EXP 102
51525: PUSH
51526: LD_VAR 0 2
51530: ARRAY
51531: PUSH
51532: LD_INT 2
51534: ARRAY
51535: IN
51536: NOT
51537: AND
51538: IFFALSE 51590
// begin if IsInUnit ( j ) then
51540: LD_VAR 0 3
51544: PPUSH
51545: CALL_OW 310
51549: IFFALSE 51560
// ComExitBuilding ( j ) ;
51551: LD_VAR 0 3
51555: PPUSH
51556: CALL_OW 122
// if not HasTask ( j ) then
51560: LD_VAR 0 3
51564: PPUSH
51565: CALL_OW 314
51569: NOT
51570: IFFALSE 51590
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
51572: LD_VAR 0 3
51576: PPUSH
51577: LD_VAR 0 7
51581: PUSH
51582: LD_INT 1
51584: ARRAY
51585: PPUSH
51586: CALL_OW 189
// end ; end ;
51590: GO 51425
51592: POP
51593: POP
// end ;
51594: GO 50937
51596: POP
51597: POP
// end ;
51598: LD_VAR 0 1
51602: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
51603: LD_INT 0
51605: PPUSH
51606: PPUSH
51607: PPUSH
51608: PPUSH
51609: PPUSH
51610: PPUSH
51611: PPUSH
51612: PPUSH
51613: PPUSH
51614: PPUSH
51615: PPUSH
// if not mc_bases then
51616: LD_EXP 99
51620: NOT
51621: IFFALSE 51625
// exit ;
51623: GO 52427
// for i = 1 to mc_bases do
51625: LD_ADDR_VAR 0 2
51629: PUSH
51630: DOUBLE
51631: LD_INT 1
51633: DEC
51634: ST_TO_ADDR
51635: LD_EXP 99
51639: PUSH
51640: FOR_TO
51641: IFFALSE 52425
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
51643: LD_EXP 127
51647: PUSH
51648: LD_VAR 0 2
51652: ARRAY
51653: NOT
51654: PUSH
51655: LD_EXP 102
51659: PUSH
51660: LD_VAR 0 2
51664: ARRAY
51665: PUSH
51666: LD_INT 1
51668: ARRAY
51669: OR
51670: PUSH
51671: LD_EXP 102
51675: PUSH
51676: LD_VAR 0 2
51680: ARRAY
51681: PUSH
51682: LD_INT 2
51684: ARRAY
51685: OR
51686: PUSH
51687: LD_EXP 125
51691: PUSH
51692: LD_VAR 0 2
51696: ARRAY
51697: PPUSH
51698: LD_INT 1
51700: PPUSH
51701: CALL_OW 325
51705: NOT
51706: OR
51707: PUSH
51708: LD_EXP 122
51712: PUSH
51713: LD_VAR 0 2
51717: ARRAY
51718: OR
51719: IFFALSE 51723
// continue ;
51721: GO 51640
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
51723: LD_ADDR_VAR 0 8
51727: PUSH
51728: LD_EXP 99
51732: PUSH
51733: LD_VAR 0 2
51737: ARRAY
51738: PPUSH
51739: LD_INT 25
51741: PUSH
51742: LD_INT 4
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: PUSH
51749: LD_INT 50
51751: PUSH
51752: EMPTY
51753: LIST
51754: PUSH
51755: LD_INT 3
51757: PUSH
51758: LD_INT 60
51760: PUSH
51761: EMPTY
51762: LIST
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: EMPTY
51769: LIST
51770: LIST
51771: LIST
51772: PPUSH
51773: CALL_OW 72
51777: PUSH
51778: LD_EXP 103
51782: PUSH
51783: LD_VAR 0 2
51787: ARRAY
51788: DIFF
51789: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51790: LD_ADDR_VAR 0 9
51794: PUSH
51795: LD_EXP 99
51799: PUSH
51800: LD_VAR 0 2
51804: ARRAY
51805: PPUSH
51806: LD_INT 2
51808: PUSH
51809: LD_INT 30
51811: PUSH
51812: LD_INT 0
51814: PUSH
51815: EMPTY
51816: LIST
51817: LIST
51818: PUSH
51819: LD_INT 30
51821: PUSH
51822: LD_INT 1
51824: PUSH
51825: EMPTY
51826: LIST
51827: LIST
51828: PUSH
51829: EMPTY
51830: LIST
51831: LIST
51832: LIST
51833: PPUSH
51834: CALL_OW 72
51838: ST_TO_ADDR
// if not tmp or not dep then
51839: LD_VAR 0 8
51843: NOT
51844: PUSH
51845: LD_VAR 0 9
51849: NOT
51850: OR
51851: IFFALSE 51855
// continue ;
51853: GO 51640
// side := GetSide ( tmp [ 1 ] ) ;
51855: LD_ADDR_VAR 0 11
51859: PUSH
51860: LD_VAR 0 8
51864: PUSH
51865: LD_INT 1
51867: ARRAY
51868: PPUSH
51869: CALL_OW 255
51873: ST_TO_ADDR
// dep := dep [ 1 ] ;
51874: LD_ADDR_VAR 0 9
51878: PUSH
51879: LD_VAR 0 9
51883: PUSH
51884: LD_INT 1
51886: ARRAY
51887: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
51888: LD_ADDR_VAR 0 7
51892: PUSH
51893: LD_EXP 127
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: PPUSH
51904: LD_INT 22
51906: PUSH
51907: LD_INT 0
51909: PUSH
51910: EMPTY
51911: LIST
51912: LIST
51913: PUSH
51914: LD_INT 25
51916: PUSH
51917: LD_INT 12
51919: PUSH
51920: EMPTY
51921: LIST
51922: LIST
51923: PUSH
51924: EMPTY
51925: LIST
51926: LIST
51927: PPUSH
51928: CALL_OW 70
51932: PUSH
51933: LD_INT 22
51935: PUSH
51936: LD_INT 0
51938: PUSH
51939: EMPTY
51940: LIST
51941: LIST
51942: PUSH
51943: LD_INT 25
51945: PUSH
51946: LD_INT 12
51948: PUSH
51949: EMPTY
51950: LIST
51951: LIST
51952: PUSH
51953: LD_INT 91
51955: PUSH
51956: LD_VAR 0 9
51960: PUSH
51961: LD_INT 20
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: LIST
51968: PUSH
51969: EMPTY
51970: LIST
51971: LIST
51972: LIST
51973: PPUSH
51974: CALL_OW 69
51978: UNION
51979: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
51980: LD_ADDR_VAR 0 10
51984: PUSH
51985: LD_EXP 127
51989: PUSH
51990: LD_VAR 0 2
51994: ARRAY
51995: PPUSH
51996: LD_INT 81
51998: PUSH
51999: LD_VAR 0 11
52003: PUSH
52004: EMPTY
52005: LIST
52006: LIST
52007: PPUSH
52008: CALL_OW 70
52012: ST_TO_ADDR
// if not apes or danger_at_area then
52013: LD_VAR 0 7
52017: NOT
52018: PUSH
52019: LD_VAR 0 10
52023: OR
52024: IFFALSE 52074
// begin if mc_taming [ i ] then
52026: LD_EXP 130
52030: PUSH
52031: LD_VAR 0 2
52035: ARRAY
52036: IFFALSE 52072
// begin MC_Reset ( i , 121 ) ;
52038: LD_VAR 0 2
52042: PPUSH
52043: LD_INT 121
52045: PPUSH
52046: CALL 37767 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52050: LD_ADDR_EXP 130
52054: PUSH
52055: LD_EXP 130
52059: PPUSH
52060: LD_VAR 0 2
52064: PPUSH
52065: EMPTY
52066: PPUSH
52067: CALL_OW 1
52071: ST_TO_ADDR
// end ; continue ;
52072: GO 51640
// end ; for j in tmp do
52074: LD_ADDR_VAR 0 3
52078: PUSH
52079: LD_VAR 0 8
52083: PUSH
52084: FOR_IN
52085: IFFALSE 52421
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52087: LD_VAR 0 3
52091: PUSH
52092: LD_EXP 130
52096: PUSH
52097: LD_VAR 0 2
52101: ARRAY
52102: IN
52103: NOT
52104: PUSH
52105: LD_EXP 130
52109: PUSH
52110: LD_VAR 0 2
52114: ARRAY
52115: PUSH
52116: LD_INT 3
52118: LESS
52119: AND
52120: IFFALSE 52178
// begin SetTag ( j , 121 ) ;
52122: LD_VAR 0 3
52126: PPUSH
52127: LD_INT 121
52129: PPUSH
52130: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52134: LD_ADDR_EXP 130
52138: PUSH
52139: LD_EXP 130
52143: PPUSH
52144: LD_VAR 0 2
52148: PUSH
52149: LD_EXP 130
52153: PUSH
52154: LD_VAR 0 2
52158: ARRAY
52159: PUSH
52160: LD_INT 1
52162: PLUS
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PPUSH
52168: LD_VAR 0 3
52172: PPUSH
52173: CALL 69637 0 3
52177: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52178: LD_VAR 0 3
52182: PUSH
52183: LD_EXP 130
52187: PUSH
52188: LD_VAR 0 2
52192: ARRAY
52193: IN
52194: IFFALSE 52419
// begin if GetClass ( j ) <> 4 then
52196: LD_VAR 0 3
52200: PPUSH
52201: CALL_OW 257
52205: PUSH
52206: LD_INT 4
52208: NONEQUAL
52209: IFFALSE 52262
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52211: LD_ADDR_EXP 130
52215: PUSH
52216: LD_EXP 130
52220: PPUSH
52221: LD_VAR 0 2
52225: PPUSH
52226: LD_EXP 130
52230: PUSH
52231: LD_VAR 0 2
52235: ARRAY
52236: PUSH
52237: LD_VAR 0 3
52241: DIFF
52242: PPUSH
52243: CALL_OW 1
52247: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52248: LD_VAR 0 3
52252: PPUSH
52253: LD_INT 0
52255: PPUSH
52256: CALL_OW 109
// continue ;
52260: GO 52084
// end ; if IsInUnit ( j ) then
52262: LD_VAR 0 3
52266: PPUSH
52267: CALL_OW 310
52271: IFFALSE 52282
// ComExitBuilding ( j ) ;
52273: LD_VAR 0 3
52277: PPUSH
52278: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52282: LD_ADDR_VAR 0 6
52286: PUSH
52287: LD_VAR 0 7
52291: PPUSH
52292: LD_VAR 0 3
52296: PPUSH
52297: CALL_OW 74
52301: ST_TO_ADDR
// if not ape then
52302: LD_VAR 0 6
52306: NOT
52307: IFFALSE 52311
// break ;
52309: GO 52421
// x := GetX ( ape ) ;
52311: LD_ADDR_VAR 0 4
52315: PUSH
52316: LD_VAR 0 6
52320: PPUSH
52321: CALL_OW 250
52325: ST_TO_ADDR
// y := GetY ( ape ) ;
52326: LD_ADDR_VAR 0 5
52330: PUSH
52331: LD_VAR 0 6
52335: PPUSH
52336: CALL_OW 251
52340: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52341: LD_VAR 0 4
52345: PPUSH
52346: LD_VAR 0 5
52350: PPUSH
52351: CALL_OW 488
52355: NOT
52356: PUSH
52357: LD_VAR 0 11
52361: PPUSH
52362: LD_VAR 0 4
52366: PPUSH
52367: LD_VAR 0 5
52371: PPUSH
52372: LD_INT 20
52374: PPUSH
52375: CALL 70533 0 4
52379: PUSH
52380: LD_INT 4
52382: ARRAY
52383: OR
52384: IFFALSE 52388
// break ;
52386: GO 52421
// if not HasTask ( j ) then
52388: LD_VAR 0 3
52392: PPUSH
52393: CALL_OW 314
52397: NOT
52398: IFFALSE 52419
// ComTameXY ( j , x , y ) ;
52400: LD_VAR 0 3
52404: PPUSH
52405: LD_VAR 0 4
52409: PPUSH
52410: LD_VAR 0 5
52414: PPUSH
52415: CALL_OW 131
// end ; end ;
52419: GO 52084
52421: POP
52422: POP
// end ;
52423: GO 51640
52425: POP
52426: POP
// end ;
52427: LD_VAR 0 1
52431: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52432: LD_INT 0
52434: PPUSH
52435: PPUSH
52436: PPUSH
52437: PPUSH
52438: PPUSH
52439: PPUSH
52440: PPUSH
52441: PPUSH
// if not mc_bases then
52442: LD_EXP 99
52446: NOT
52447: IFFALSE 52451
// exit ;
52449: GO 53077
// for i = 1 to mc_bases do
52451: LD_ADDR_VAR 0 2
52455: PUSH
52456: DOUBLE
52457: LD_INT 1
52459: DEC
52460: ST_TO_ADDR
52461: LD_EXP 99
52465: PUSH
52466: FOR_TO
52467: IFFALSE 53075
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52469: LD_EXP 128
52473: PUSH
52474: LD_VAR 0 2
52478: ARRAY
52479: NOT
52480: PUSH
52481: LD_EXP 128
52485: PUSH
52486: LD_VAR 0 2
52490: ARRAY
52491: PPUSH
52492: LD_INT 25
52494: PUSH
52495: LD_INT 12
52497: PUSH
52498: EMPTY
52499: LIST
52500: LIST
52501: PPUSH
52502: CALL_OW 72
52506: NOT
52507: OR
52508: IFFALSE 52512
// continue ;
52510: GO 52466
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52512: LD_ADDR_VAR 0 5
52516: PUSH
52517: LD_EXP 128
52521: PUSH
52522: LD_VAR 0 2
52526: ARRAY
52527: PUSH
52528: LD_INT 1
52530: ARRAY
52531: PPUSH
52532: CALL_OW 255
52536: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52537: LD_VAR 0 5
52541: PPUSH
52542: LD_INT 2
52544: PPUSH
52545: CALL_OW 325
52549: IFFALSE 52802
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52551: LD_ADDR_VAR 0 4
52555: PUSH
52556: LD_EXP 128
52560: PUSH
52561: LD_VAR 0 2
52565: ARRAY
52566: PPUSH
52567: LD_INT 25
52569: PUSH
52570: LD_INT 16
52572: PUSH
52573: EMPTY
52574: LIST
52575: LIST
52576: PPUSH
52577: CALL_OW 72
52581: ST_TO_ADDR
// if tmp < 6 then
52582: LD_VAR 0 4
52586: PUSH
52587: LD_INT 6
52589: LESS
52590: IFFALSE 52802
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52592: LD_ADDR_VAR 0 6
52596: PUSH
52597: LD_EXP 99
52601: PUSH
52602: LD_VAR 0 2
52606: ARRAY
52607: PPUSH
52608: LD_INT 2
52610: PUSH
52611: LD_INT 30
52613: PUSH
52614: LD_INT 0
52616: PUSH
52617: EMPTY
52618: LIST
52619: LIST
52620: PUSH
52621: LD_INT 30
52623: PUSH
52624: LD_INT 1
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: LIST
52635: PPUSH
52636: CALL_OW 72
52640: ST_TO_ADDR
// if depot then
52641: LD_VAR 0 6
52645: IFFALSE 52802
// begin selected := 0 ;
52647: LD_ADDR_VAR 0 7
52651: PUSH
52652: LD_INT 0
52654: ST_TO_ADDR
// for j in depot do
52655: LD_ADDR_VAR 0 3
52659: PUSH
52660: LD_VAR 0 6
52664: PUSH
52665: FOR_IN
52666: IFFALSE 52697
// begin if UnitsInside ( j ) < 6 then
52668: LD_VAR 0 3
52672: PPUSH
52673: CALL_OW 313
52677: PUSH
52678: LD_INT 6
52680: LESS
52681: IFFALSE 52695
// begin selected := j ;
52683: LD_ADDR_VAR 0 7
52687: PUSH
52688: LD_VAR 0 3
52692: ST_TO_ADDR
// break ;
52693: GO 52697
// end ; end ;
52695: GO 52665
52697: POP
52698: POP
// if selected then
52699: LD_VAR 0 7
52703: IFFALSE 52802
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52705: LD_ADDR_VAR 0 3
52709: PUSH
52710: LD_EXP 128
52714: PUSH
52715: LD_VAR 0 2
52719: ARRAY
52720: PPUSH
52721: LD_INT 25
52723: PUSH
52724: LD_INT 12
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: PPUSH
52731: CALL_OW 72
52735: PUSH
52736: FOR_IN
52737: IFFALSE 52800
// if not HasTask ( j ) then
52739: LD_VAR 0 3
52743: PPUSH
52744: CALL_OW 314
52748: NOT
52749: IFFALSE 52798
// begin if not IsInUnit ( j ) then
52751: LD_VAR 0 3
52755: PPUSH
52756: CALL_OW 310
52760: NOT
52761: IFFALSE 52777
// ComEnterUnit ( j , selected ) ;
52763: LD_VAR 0 3
52767: PPUSH
52768: LD_VAR 0 7
52772: PPUSH
52773: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
52777: LD_VAR 0 3
52781: PPUSH
52782: LD_INT 16
52784: PPUSH
52785: CALL_OW 183
// AddComExitBuilding ( j ) ;
52789: LD_VAR 0 3
52793: PPUSH
52794: CALL_OW 182
// end ;
52798: GO 52736
52800: POP
52801: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
52802: LD_VAR 0 5
52806: PPUSH
52807: LD_INT 11
52809: PPUSH
52810: CALL_OW 325
52814: IFFALSE 53073
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52816: LD_ADDR_VAR 0 4
52820: PUSH
52821: LD_EXP 128
52825: PUSH
52826: LD_VAR 0 2
52830: ARRAY
52831: PPUSH
52832: LD_INT 25
52834: PUSH
52835: LD_INT 16
52837: PUSH
52838: EMPTY
52839: LIST
52840: LIST
52841: PPUSH
52842: CALL_OW 72
52846: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
52847: LD_VAR 0 4
52851: PUSH
52852: LD_INT 6
52854: GREATEREQUAL
52855: PUSH
52856: LD_VAR 0 5
52860: PPUSH
52861: LD_INT 2
52863: PPUSH
52864: CALL_OW 325
52868: NOT
52869: OR
52870: IFFALSE 53073
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52872: LD_ADDR_VAR 0 8
52876: PUSH
52877: LD_EXP 99
52881: PUSH
52882: LD_VAR 0 2
52886: ARRAY
52887: PPUSH
52888: LD_INT 2
52890: PUSH
52891: LD_INT 30
52893: PUSH
52894: LD_INT 4
52896: PUSH
52897: EMPTY
52898: LIST
52899: LIST
52900: PUSH
52901: LD_INT 30
52903: PUSH
52904: LD_INT 5
52906: PUSH
52907: EMPTY
52908: LIST
52909: LIST
52910: PUSH
52911: EMPTY
52912: LIST
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 72
52920: ST_TO_ADDR
// if barracks then
52921: LD_VAR 0 8
52925: IFFALSE 53073
// begin selected := 0 ;
52927: LD_ADDR_VAR 0 7
52931: PUSH
52932: LD_INT 0
52934: ST_TO_ADDR
// for j in barracks do
52935: LD_ADDR_VAR 0 3
52939: PUSH
52940: LD_VAR 0 8
52944: PUSH
52945: FOR_IN
52946: IFFALSE 52977
// begin if UnitsInside ( j ) < 6 then
52948: LD_VAR 0 3
52952: PPUSH
52953: CALL_OW 313
52957: PUSH
52958: LD_INT 6
52960: LESS
52961: IFFALSE 52975
// begin selected := j ;
52963: LD_ADDR_VAR 0 7
52967: PUSH
52968: LD_VAR 0 3
52972: ST_TO_ADDR
// break ;
52973: GO 52977
// end ; end ;
52975: GO 52945
52977: POP
52978: POP
// if selected then
52979: LD_VAR 0 7
52983: IFFALSE 53073
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52985: LD_ADDR_VAR 0 3
52989: PUSH
52990: LD_EXP 128
52994: PUSH
52995: LD_VAR 0 2
52999: ARRAY
53000: PPUSH
53001: LD_INT 25
53003: PUSH
53004: LD_INT 12
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PPUSH
53011: CALL_OW 72
53015: PUSH
53016: FOR_IN
53017: IFFALSE 53071
// if not IsInUnit ( j ) and not HasTask ( j ) then
53019: LD_VAR 0 3
53023: PPUSH
53024: CALL_OW 310
53028: NOT
53029: PUSH
53030: LD_VAR 0 3
53034: PPUSH
53035: CALL_OW 314
53039: NOT
53040: AND
53041: IFFALSE 53069
// begin ComEnterUnit ( j , selected ) ;
53043: LD_VAR 0 3
53047: PPUSH
53048: LD_VAR 0 7
53052: PPUSH
53053: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53057: LD_VAR 0 3
53061: PPUSH
53062: LD_INT 15
53064: PPUSH
53065: CALL_OW 183
// end ;
53069: GO 53016
53071: POP
53072: POP
// end ; end ; end ; end ; end ;
53073: GO 52466
53075: POP
53076: POP
// end ;
53077: LD_VAR 0 1
53081: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53082: LD_INT 0
53084: PPUSH
53085: PPUSH
53086: PPUSH
53087: PPUSH
// if not mc_bases then
53088: LD_EXP 99
53092: NOT
53093: IFFALSE 53097
// exit ;
53095: GO 53275
// for i = 1 to mc_bases do
53097: LD_ADDR_VAR 0 2
53101: PUSH
53102: DOUBLE
53103: LD_INT 1
53105: DEC
53106: ST_TO_ADDR
53107: LD_EXP 99
53111: PUSH
53112: FOR_TO
53113: IFFALSE 53273
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53115: LD_ADDR_VAR 0 4
53119: PUSH
53120: LD_EXP 99
53124: PUSH
53125: LD_VAR 0 2
53129: ARRAY
53130: PPUSH
53131: LD_INT 25
53133: PUSH
53134: LD_INT 9
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PPUSH
53141: CALL_OW 72
53145: ST_TO_ADDR
// if not tmp then
53146: LD_VAR 0 4
53150: NOT
53151: IFFALSE 53155
// continue ;
53153: GO 53112
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53155: LD_EXP 125
53159: PUSH
53160: LD_VAR 0 2
53164: ARRAY
53165: PPUSH
53166: LD_INT 29
53168: PPUSH
53169: CALL_OW 325
53173: NOT
53174: PUSH
53175: LD_EXP 125
53179: PUSH
53180: LD_VAR 0 2
53184: ARRAY
53185: PPUSH
53186: LD_INT 28
53188: PPUSH
53189: CALL_OW 325
53193: NOT
53194: AND
53195: IFFALSE 53199
// continue ;
53197: GO 53112
// for j in tmp do
53199: LD_ADDR_VAR 0 3
53203: PUSH
53204: LD_VAR 0 4
53208: PUSH
53209: FOR_IN
53210: IFFALSE 53269
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53212: LD_VAR 0 3
53216: PUSH
53217: LD_EXP 102
53221: PUSH
53222: LD_VAR 0 2
53226: ARRAY
53227: PUSH
53228: LD_INT 1
53230: ARRAY
53231: IN
53232: NOT
53233: PUSH
53234: LD_VAR 0 3
53238: PUSH
53239: LD_EXP 102
53243: PUSH
53244: LD_VAR 0 2
53248: ARRAY
53249: PUSH
53250: LD_INT 2
53252: ARRAY
53253: IN
53254: NOT
53255: AND
53256: IFFALSE 53267
// ComSpaceTimeShoot ( j ) ;
53258: LD_VAR 0 3
53262: PPUSH
53263: CALL 63727 0 1
53267: GO 53209
53269: POP
53270: POP
// end ;
53271: GO 53112
53273: POP
53274: POP
// end ;
53275: LD_VAR 0 1
53279: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53280: LD_INT 0
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
53287: PPUSH
53288: PPUSH
53289: PPUSH
53290: PPUSH
// if not mc_bases then
53291: LD_EXP 99
53295: NOT
53296: IFFALSE 53300
// exit ;
53298: GO 53922
// for i = 1 to mc_bases do
53300: LD_ADDR_VAR 0 2
53304: PUSH
53305: DOUBLE
53306: LD_INT 1
53308: DEC
53309: ST_TO_ADDR
53310: LD_EXP 99
53314: PUSH
53315: FOR_TO
53316: IFFALSE 53920
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53318: LD_EXP 134
53322: PUSH
53323: LD_VAR 0 2
53327: ARRAY
53328: NOT
53329: PUSH
53330: LD_INT 38
53332: PPUSH
53333: LD_EXP 125
53337: PUSH
53338: LD_VAR 0 2
53342: ARRAY
53343: PPUSH
53344: CALL_OW 321
53348: PUSH
53349: LD_INT 2
53351: NONEQUAL
53352: OR
53353: IFFALSE 53357
// continue ;
53355: GO 53315
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53357: LD_ADDR_VAR 0 8
53361: PUSH
53362: LD_EXP 99
53366: PUSH
53367: LD_VAR 0 2
53371: ARRAY
53372: PPUSH
53373: LD_INT 30
53375: PUSH
53376: LD_INT 34
53378: PUSH
53379: EMPTY
53380: LIST
53381: LIST
53382: PPUSH
53383: CALL_OW 72
53387: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53388: LD_ADDR_VAR 0 9
53392: PUSH
53393: LD_EXP 99
53397: PUSH
53398: LD_VAR 0 2
53402: ARRAY
53403: PPUSH
53404: LD_INT 25
53406: PUSH
53407: LD_INT 4
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: PPUSH
53414: CALL_OW 72
53418: PPUSH
53419: LD_INT 0
53421: PPUSH
53422: CALL 102897 0 2
53426: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53427: LD_VAR 0 9
53431: NOT
53432: PUSH
53433: LD_VAR 0 8
53437: NOT
53438: OR
53439: PUSH
53440: LD_EXP 99
53444: PUSH
53445: LD_VAR 0 2
53449: ARRAY
53450: PPUSH
53451: LD_INT 124
53453: PPUSH
53454: CALL 102897 0 2
53458: OR
53459: IFFALSE 53463
// continue ;
53461: GO 53315
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53463: LD_EXP 135
53467: PUSH
53468: LD_VAR 0 2
53472: ARRAY
53473: PUSH
53474: LD_EXP 134
53478: PUSH
53479: LD_VAR 0 2
53483: ARRAY
53484: LESS
53485: PUSH
53486: LD_EXP 135
53490: PUSH
53491: LD_VAR 0 2
53495: ARRAY
53496: PUSH
53497: LD_VAR 0 8
53501: LESS
53502: AND
53503: IFFALSE 53918
// begin tmp := sci [ 1 ] ;
53505: LD_ADDR_VAR 0 7
53509: PUSH
53510: LD_VAR 0 9
53514: PUSH
53515: LD_INT 1
53517: ARRAY
53518: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53519: LD_VAR 0 7
53523: PPUSH
53524: LD_INT 124
53526: PPUSH
53527: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53531: LD_ADDR_VAR 0 3
53535: PUSH
53536: DOUBLE
53537: LD_EXP 134
53541: PUSH
53542: LD_VAR 0 2
53546: ARRAY
53547: INC
53548: ST_TO_ADDR
53549: LD_EXP 134
53553: PUSH
53554: LD_VAR 0 2
53558: ARRAY
53559: PUSH
53560: FOR_DOWNTO
53561: IFFALSE 53904
// begin if IsInUnit ( tmp ) then
53563: LD_VAR 0 7
53567: PPUSH
53568: CALL_OW 310
53572: IFFALSE 53583
// ComExitBuilding ( tmp ) ;
53574: LD_VAR 0 7
53578: PPUSH
53579: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
53583: LD_INT 35
53585: PPUSH
53586: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
53590: LD_VAR 0 7
53594: PPUSH
53595: CALL_OW 310
53599: NOT
53600: PUSH
53601: LD_VAR 0 7
53605: PPUSH
53606: CALL_OW 314
53610: NOT
53611: AND
53612: IFFALSE 53583
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
53614: LD_ADDR_VAR 0 6
53618: PUSH
53619: LD_VAR 0 7
53623: PPUSH
53624: CALL_OW 250
53628: PUSH
53629: LD_VAR 0 7
53633: PPUSH
53634: CALL_OW 251
53638: PUSH
53639: EMPTY
53640: LIST
53641: LIST
53642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53643: LD_INT 35
53645: PPUSH
53646: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
53650: LD_ADDR_VAR 0 4
53654: PUSH
53655: LD_EXP 134
53659: PUSH
53660: LD_VAR 0 2
53664: ARRAY
53665: PUSH
53666: LD_VAR 0 3
53670: ARRAY
53671: PUSH
53672: LD_INT 1
53674: ARRAY
53675: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
53676: LD_ADDR_VAR 0 5
53680: PUSH
53681: LD_EXP 134
53685: PUSH
53686: LD_VAR 0 2
53690: ARRAY
53691: PUSH
53692: LD_VAR 0 3
53696: ARRAY
53697: PUSH
53698: LD_INT 2
53700: ARRAY
53701: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
53702: LD_VAR 0 7
53706: PPUSH
53707: LD_INT 10
53709: PPUSH
53710: CALL 72230 0 2
53714: PUSH
53715: LD_INT 4
53717: ARRAY
53718: IFFALSE 53756
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
53720: LD_VAR 0 7
53724: PPUSH
53725: LD_VAR 0 6
53729: PUSH
53730: LD_INT 1
53732: ARRAY
53733: PPUSH
53734: LD_VAR 0 6
53738: PUSH
53739: LD_INT 2
53741: ARRAY
53742: PPUSH
53743: CALL_OW 111
// wait ( 0 0$10 ) ;
53747: LD_INT 350
53749: PPUSH
53750: CALL_OW 67
// end else
53754: GO 53782
// begin ComMoveXY ( tmp , x , y ) ;
53756: LD_VAR 0 7
53760: PPUSH
53761: LD_VAR 0 4
53765: PPUSH
53766: LD_VAR 0 5
53770: PPUSH
53771: CALL_OW 111
// wait ( 0 0$3 ) ;
53775: LD_INT 105
53777: PPUSH
53778: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
53782: LD_VAR 0 7
53786: PPUSH
53787: LD_VAR 0 4
53791: PPUSH
53792: LD_VAR 0 5
53796: PPUSH
53797: CALL_OW 307
53801: IFFALSE 53643
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
53803: LD_VAR 0 7
53807: PPUSH
53808: LD_VAR 0 4
53812: PPUSH
53813: LD_VAR 0 5
53817: PPUSH
53818: LD_VAR 0 8
53822: PUSH
53823: LD_VAR 0 3
53827: ARRAY
53828: PPUSH
53829: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
53833: LD_INT 35
53835: PPUSH
53836: CALL_OW 67
// until not HasTask ( tmp ) ;
53840: LD_VAR 0 7
53844: PPUSH
53845: CALL_OW 314
53849: NOT
53850: IFFALSE 53833
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
53852: LD_ADDR_EXP 135
53856: PUSH
53857: LD_EXP 135
53861: PPUSH
53862: LD_VAR 0 2
53866: PUSH
53867: LD_EXP 135
53871: PUSH
53872: LD_VAR 0 2
53876: ARRAY
53877: PUSH
53878: LD_INT 1
53880: PLUS
53881: PUSH
53882: EMPTY
53883: LIST
53884: LIST
53885: PPUSH
53886: LD_VAR 0 8
53890: PUSH
53891: LD_VAR 0 3
53895: ARRAY
53896: PPUSH
53897: CALL 69637 0 3
53901: ST_TO_ADDR
// end ;
53902: GO 53560
53904: POP
53905: POP
// MC_Reset ( i , 124 ) ;
53906: LD_VAR 0 2
53910: PPUSH
53911: LD_INT 124
53913: PPUSH
53914: CALL 37767 0 2
// end ; end ;
53918: GO 53315
53920: POP
53921: POP
// end ;
53922: LD_VAR 0 1
53926: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53927: LD_INT 0
53929: PPUSH
53930: PPUSH
53931: PPUSH
// if not mc_bases then
53932: LD_EXP 99
53936: NOT
53937: IFFALSE 53941
// exit ;
53939: GO 54547
// for i = 1 to mc_bases do
53941: LD_ADDR_VAR 0 2
53945: PUSH
53946: DOUBLE
53947: LD_INT 1
53949: DEC
53950: ST_TO_ADDR
53951: LD_EXP 99
53955: PUSH
53956: FOR_TO
53957: IFFALSE 54545
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
53959: LD_ADDR_VAR 0 3
53963: PUSH
53964: LD_EXP 99
53968: PUSH
53969: LD_VAR 0 2
53973: ARRAY
53974: PPUSH
53975: LD_INT 25
53977: PUSH
53978: LD_INT 4
53980: PUSH
53981: EMPTY
53982: LIST
53983: LIST
53984: PPUSH
53985: CALL_OW 72
53989: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
53990: LD_VAR 0 3
53994: NOT
53995: PUSH
53996: LD_EXP 136
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: NOT
54007: OR
54008: PUSH
54009: LD_EXP 99
54013: PUSH
54014: LD_VAR 0 2
54018: ARRAY
54019: PPUSH
54020: LD_INT 2
54022: PUSH
54023: LD_INT 30
54025: PUSH
54026: LD_INT 0
54028: PUSH
54029: EMPTY
54030: LIST
54031: LIST
54032: PUSH
54033: LD_INT 30
54035: PUSH
54036: LD_INT 1
54038: PUSH
54039: EMPTY
54040: LIST
54041: LIST
54042: PUSH
54043: EMPTY
54044: LIST
54045: LIST
54046: LIST
54047: PPUSH
54048: CALL_OW 72
54052: NOT
54053: OR
54054: IFFALSE 54104
// begin if mc_deposits_finder [ i ] then
54056: LD_EXP 137
54060: PUSH
54061: LD_VAR 0 2
54065: ARRAY
54066: IFFALSE 54102
// begin MC_Reset ( i , 125 ) ;
54068: LD_VAR 0 2
54072: PPUSH
54073: LD_INT 125
54075: PPUSH
54076: CALL 37767 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54080: LD_ADDR_EXP 137
54084: PUSH
54085: LD_EXP 137
54089: PPUSH
54090: LD_VAR 0 2
54094: PPUSH
54095: EMPTY
54096: PPUSH
54097: CALL_OW 1
54101: ST_TO_ADDR
// end ; continue ;
54102: GO 53956
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54104: LD_EXP 136
54108: PUSH
54109: LD_VAR 0 2
54113: ARRAY
54114: PUSH
54115: LD_INT 1
54117: ARRAY
54118: PUSH
54119: LD_INT 3
54121: ARRAY
54122: PUSH
54123: LD_INT 1
54125: EQUAL
54126: PUSH
54127: LD_INT 20
54129: PPUSH
54130: LD_EXP 125
54134: PUSH
54135: LD_VAR 0 2
54139: ARRAY
54140: PPUSH
54141: CALL_OW 321
54145: PUSH
54146: LD_INT 2
54148: NONEQUAL
54149: AND
54150: IFFALSE 54200
// begin if mc_deposits_finder [ i ] then
54152: LD_EXP 137
54156: PUSH
54157: LD_VAR 0 2
54161: ARRAY
54162: IFFALSE 54198
// begin MC_Reset ( i , 125 ) ;
54164: LD_VAR 0 2
54168: PPUSH
54169: LD_INT 125
54171: PPUSH
54172: CALL 37767 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54176: LD_ADDR_EXP 137
54180: PUSH
54181: LD_EXP 137
54185: PPUSH
54186: LD_VAR 0 2
54190: PPUSH
54191: EMPTY
54192: PPUSH
54193: CALL_OW 1
54197: ST_TO_ADDR
// end ; continue ;
54198: GO 53956
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54200: LD_EXP 136
54204: PUSH
54205: LD_VAR 0 2
54209: ARRAY
54210: PUSH
54211: LD_INT 1
54213: ARRAY
54214: PUSH
54215: LD_INT 1
54217: ARRAY
54218: PPUSH
54219: LD_EXP 136
54223: PUSH
54224: LD_VAR 0 2
54228: ARRAY
54229: PUSH
54230: LD_INT 1
54232: ARRAY
54233: PUSH
54234: LD_INT 2
54236: ARRAY
54237: PPUSH
54238: LD_EXP 125
54242: PUSH
54243: LD_VAR 0 2
54247: ARRAY
54248: PPUSH
54249: CALL_OW 440
54253: IFFALSE 54296
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54255: LD_ADDR_EXP 136
54259: PUSH
54260: LD_EXP 136
54264: PPUSH
54265: LD_VAR 0 2
54269: PPUSH
54270: LD_EXP 136
54274: PUSH
54275: LD_VAR 0 2
54279: ARRAY
54280: PPUSH
54281: LD_INT 1
54283: PPUSH
54284: CALL_OW 3
54288: PPUSH
54289: CALL_OW 1
54293: ST_TO_ADDR
54294: GO 54543
// begin if not mc_deposits_finder [ i ] then
54296: LD_EXP 137
54300: PUSH
54301: LD_VAR 0 2
54305: ARRAY
54306: NOT
54307: IFFALSE 54359
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54309: LD_ADDR_EXP 137
54313: PUSH
54314: LD_EXP 137
54318: PPUSH
54319: LD_VAR 0 2
54323: PPUSH
54324: LD_VAR 0 3
54328: PUSH
54329: LD_INT 1
54331: ARRAY
54332: PUSH
54333: EMPTY
54334: LIST
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54341: LD_VAR 0 3
54345: PUSH
54346: LD_INT 1
54348: ARRAY
54349: PPUSH
54350: LD_INT 125
54352: PPUSH
54353: CALL_OW 109
// end else
54357: GO 54543
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54359: LD_EXP 137
54363: PUSH
54364: LD_VAR 0 2
54368: ARRAY
54369: PUSH
54370: LD_INT 1
54372: ARRAY
54373: PPUSH
54374: CALL_OW 310
54378: IFFALSE 54401
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54380: LD_EXP 137
54384: PUSH
54385: LD_VAR 0 2
54389: ARRAY
54390: PUSH
54391: LD_INT 1
54393: ARRAY
54394: PPUSH
54395: CALL_OW 122
54399: GO 54543
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54401: LD_EXP 137
54405: PUSH
54406: LD_VAR 0 2
54410: ARRAY
54411: PUSH
54412: LD_INT 1
54414: ARRAY
54415: PPUSH
54416: CALL_OW 314
54420: NOT
54421: PUSH
54422: LD_EXP 137
54426: PUSH
54427: LD_VAR 0 2
54431: ARRAY
54432: PUSH
54433: LD_INT 1
54435: ARRAY
54436: PPUSH
54437: LD_EXP 136
54441: PUSH
54442: LD_VAR 0 2
54446: ARRAY
54447: PUSH
54448: LD_INT 1
54450: ARRAY
54451: PUSH
54452: LD_INT 1
54454: ARRAY
54455: PPUSH
54456: LD_EXP 136
54460: PUSH
54461: LD_VAR 0 2
54465: ARRAY
54466: PUSH
54467: LD_INT 1
54469: ARRAY
54470: PUSH
54471: LD_INT 2
54473: ARRAY
54474: PPUSH
54475: CALL_OW 297
54479: PUSH
54480: LD_INT 6
54482: GREATER
54483: AND
54484: IFFALSE 54543
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54486: LD_EXP 137
54490: PUSH
54491: LD_VAR 0 2
54495: ARRAY
54496: PUSH
54497: LD_INT 1
54499: ARRAY
54500: PPUSH
54501: LD_EXP 136
54505: PUSH
54506: LD_VAR 0 2
54510: ARRAY
54511: PUSH
54512: LD_INT 1
54514: ARRAY
54515: PUSH
54516: LD_INT 1
54518: ARRAY
54519: PPUSH
54520: LD_EXP 136
54524: PUSH
54525: LD_VAR 0 2
54529: ARRAY
54530: PUSH
54531: LD_INT 1
54533: ARRAY
54534: PUSH
54535: LD_INT 2
54537: ARRAY
54538: PPUSH
54539: CALL_OW 111
// end ; end ; end ;
54543: GO 53956
54545: POP
54546: POP
// end ;
54547: LD_VAR 0 1
54551: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
54552: LD_INT 0
54554: PPUSH
54555: PPUSH
54556: PPUSH
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
54561: PPUSH
54562: PPUSH
54563: PPUSH
54564: PPUSH
// if not mc_bases then
54565: LD_EXP 99
54569: NOT
54570: IFFALSE 54574
// exit ;
54572: GO 55298
// for i = 1 to mc_bases do
54574: LD_ADDR_VAR 0 2
54578: PUSH
54579: DOUBLE
54580: LD_INT 1
54582: DEC
54583: ST_TO_ADDR
54584: LD_EXP 99
54588: PUSH
54589: FOR_TO
54590: IFFALSE 55296
// begin if not mc_bases [ i ] then
54592: LD_EXP 99
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: NOT
54603: IFFALSE 54607
// continue ;
54605: GO 54589
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
54607: LD_ADDR_VAR 0 7
54611: PUSH
54612: LD_EXP 99
54616: PUSH
54617: LD_VAR 0 2
54621: ARRAY
54622: PUSH
54623: LD_INT 1
54625: ARRAY
54626: PPUSH
54627: CALL_OW 248
54631: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
54632: LD_VAR 0 7
54636: PUSH
54637: LD_INT 3
54639: EQUAL
54640: PUSH
54641: LD_EXP 118
54645: PUSH
54646: LD_VAR 0 2
54650: ARRAY
54651: PUSH
54652: LD_EXP 121
54656: PUSH
54657: LD_VAR 0 2
54661: ARRAY
54662: UNION
54663: PPUSH
54664: LD_INT 33
54666: PUSH
54667: LD_INT 2
54669: PUSH
54670: EMPTY
54671: LIST
54672: LIST
54673: PPUSH
54674: CALL_OW 72
54678: NOT
54679: OR
54680: IFFALSE 54684
// continue ;
54682: GO 54589
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
54684: LD_ADDR_VAR 0 9
54688: PUSH
54689: LD_EXP 99
54693: PUSH
54694: LD_VAR 0 2
54698: ARRAY
54699: PPUSH
54700: LD_INT 30
54702: PUSH
54703: LD_INT 36
54705: PUSH
54706: EMPTY
54707: LIST
54708: LIST
54709: PPUSH
54710: CALL_OW 72
54714: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
54715: LD_ADDR_VAR 0 10
54719: PUSH
54720: LD_EXP 118
54724: PUSH
54725: LD_VAR 0 2
54729: ARRAY
54730: PPUSH
54731: LD_INT 34
54733: PUSH
54734: LD_INT 31
54736: PUSH
54737: EMPTY
54738: LIST
54739: LIST
54740: PPUSH
54741: CALL_OW 72
54745: ST_TO_ADDR
// if not cts and not mcts then
54746: LD_VAR 0 9
54750: NOT
54751: PUSH
54752: LD_VAR 0 10
54756: NOT
54757: AND
54758: IFFALSE 54762
// continue ;
54760: GO 54589
// x := cts ;
54762: LD_ADDR_VAR 0 11
54766: PUSH
54767: LD_VAR 0 9
54771: ST_TO_ADDR
// if not x then
54772: LD_VAR 0 11
54776: NOT
54777: IFFALSE 54789
// x := mcts ;
54779: LD_ADDR_VAR 0 11
54783: PUSH
54784: LD_VAR 0 10
54788: ST_TO_ADDR
// if mc_remote_driver [ i ] then
54789: LD_EXP 139
54793: PUSH
54794: LD_VAR 0 2
54798: ARRAY
54799: IFFALSE 55068
// for j in mc_remote_driver [ i ] do
54801: LD_ADDR_VAR 0 3
54805: PUSH
54806: LD_EXP 139
54810: PUSH
54811: LD_VAR 0 2
54815: ARRAY
54816: PUSH
54817: FOR_IN
54818: IFFALSE 55066
// begin if GetClass ( j ) <> 3 then
54820: LD_VAR 0 3
54824: PPUSH
54825: CALL_OW 257
54829: PUSH
54830: LD_INT 3
54832: NONEQUAL
54833: IFFALSE 54886
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
54835: LD_ADDR_EXP 139
54839: PUSH
54840: LD_EXP 139
54844: PPUSH
54845: LD_VAR 0 2
54849: PPUSH
54850: LD_EXP 139
54854: PUSH
54855: LD_VAR 0 2
54859: ARRAY
54860: PUSH
54861: LD_VAR 0 3
54865: DIFF
54866: PPUSH
54867: CALL_OW 1
54871: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54872: LD_VAR 0 3
54876: PPUSH
54877: LD_INT 0
54879: PPUSH
54880: CALL_OW 109
// continue ;
54884: GO 54817
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
54886: LD_VAR 0 3
54890: PPUSH
54891: CALL_OW 310
54895: NOT
54896: PUSH
54897: LD_VAR 0 3
54901: PPUSH
54902: CALL_OW 310
54906: PPUSH
54907: CALL_OW 266
54911: PUSH
54912: LD_INT 36
54914: NONEQUAL
54915: PUSH
54916: LD_VAR 0 3
54920: PPUSH
54921: CALL 102985 0 1
54925: NOT
54926: AND
54927: OR
54928: IFFALSE 55064
// begin if IsInUnit ( j ) then
54930: LD_VAR 0 3
54934: PPUSH
54935: CALL_OW 310
54939: IFFALSE 54950
// ComExitBuilding ( j ) ;
54941: LD_VAR 0 3
54945: PPUSH
54946: CALL_OW 122
// ct := 0 ;
54950: LD_ADDR_VAR 0 8
54954: PUSH
54955: LD_INT 0
54957: ST_TO_ADDR
// for k in x do
54958: LD_ADDR_VAR 0 4
54962: PUSH
54963: LD_VAR 0 11
54967: PUSH
54968: FOR_IN
54969: IFFALSE 55042
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
54971: LD_VAR 0 4
54975: PPUSH
54976: CALL_OW 264
54980: PUSH
54981: LD_INT 31
54983: EQUAL
54984: PUSH
54985: LD_VAR 0 4
54989: PPUSH
54990: CALL_OW 311
54994: NOT
54995: AND
54996: PUSH
54997: LD_VAR 0 4
55001: PPUSH
55002: CALL_OW 266
55006: PUSH
55007: LD_INT 36
55009: EQUAL
55010: PUSH
55011: LD_VAR 0 4
55015: PPUSH
55016: CALL_OW 313
55020: PUSH
55021: LD_INT 3
55023: LESS
55024: AND
55025: OR
55026: IFFALSE 55040
// begin ct := k ;
55028: LD_ADDR_VAR 0 8
55032: PUSH
55033: LD_VAR 0 4
55037: ST_TO_ADDR
// break ;
55038: GO 55042
// end ;
55040: GO 54968
55042: POP
55043: POP
// if ct then
55044: LD_VAR 0 8
55048: IFFALSE 55064
// ComEnterUnit ( j , ct ) ;
55050: LD_VAR 0 3
55054: PPUSH
55055: LD_VAR 0 8
55059: PPUSH
55060: CALL_OW 120
// end ; end ;
55064: GO 54817
55066: POP
55067: POP
// places := 0 ;
55068: LD_ADDR_VAR 0 5
55072: PUSH
55073: LD_INT 0
55075: ST_TO_ADDR
// for j = 1 to x do
55076: LD_ADDR_VAR 0 3
55080: PUSH
55081: DOUBLE
55082: LD_INT 1
55084: DEC
55085: ST_TO_ADDR
55086: LD_VAR 0 11
55090: PUSH
55091: FOR_TO
55092: IFFALSE 55147
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55094: LD_VAR 0 11
55098: PUSH
55099: LD_VAR 0 3
55103: ARRAY
55104: PPUSH
55105: CALL_OW 264
55109: PUSH
55110: LD_INT 31
55112: EQUAL
55113: IFFALSE 55131
// places := places + 1 else
55115: LD_ADDR_VAR 0 5
55119: PUSH
55120: LD_VAR 0 5
55124: PUSH
55125: LD_INT 1
55127: PLUS
55128: ST_TO_ADDR
55129: GO 55145
// places := places + 3 ;
55131: LD_ADDR_VAR 0 5
55135: PUSH
55136: LD_VAR 0 5
55140: PUSH
55141: LD_INT 3
55143: PLUS
55144: ST_TO_ADDR
55145: GO 55091
55147: POP
55148: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55149: LD_ADDR_VAR 0 6
55153: PUSH
55154: LD_EXP 99
55158: PUSH
55159: LD_VAR 0 2
55163: ARRAY
55164: PPUSH
55165: LD_INT 25
55167: PUSH
55168: LD_INT 3
55170: PUSH
55171: EMPTY
55172: LIST
55173: LIST
55174: PPUSH
55175: CALL_OW 72
55179: PUSH
55180: LD_EXP 139
55184: PUSH
55185: LD_VAR 0 2
55189: ARRAY
55190: DIFF
55191: PPUSH
55192: LD_INT 3
55194: PPUSH
55195: CALL 103885 0 2
55199: ST_TO_ADDR
// if not tmp then
55200: LD_VAR 0 6
55204: NOT
55205: IFFALSE 55209
// continue ;
55207: GO 54589
// places := places - mc_remote_driver [ i ] ;
55209: LD_ADDR_VAR 0 5
55213: PUSH
55214: LD_VAR 0 5
55218: PUSH
55219: LD_EXP 139
55223: PUSH
55224: LD_VAR 0 2
55228: ARRAY
55229: MINUS
55230: ST_TO_ADDR
// if places then
55231: LD_VAR 0 5
55235: IFFALSE 55294
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55237: LD_ADDR_EXP 139
55241: PUSH
55242: LD_EXP 139
55246: PPUSH
55247: LD_VAR 0 2
55251: PPUSH
55252: LD_EXP 139
55256: PUSH
55257: LD_VAR 0 2
55261: ARRAY
55262: PUSH
55263: LD_VAR 0 6
55267: PUSH
55268: LD_INT 1
55270: ARRAY
55271: UNION
55272: PPUSH
55273: CALL_OW 1
55277: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55278: LD_VAR 0 6
55282: PUSH
55283: LD_INT 1
55285: ARRAY
55286: PPUSH
55287: LD_INT 126
55289: PPUSH
55290: CALL_OW 109
// end ; end ;
55294: GO 54589
55296: POP
55297: POP
// end ;
55298: LD_VAR 0 1
55302: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55303: LD_INT 0
55305: PPUSH
55306: PPUSH
55307: PPUSH
55308: PPUSH
55309: PPUSH
55310: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55311: LD_VAR 0 1
55315: NOT
55316: PUSH
55317: LD_VAR 0 2
55321: NOT
55322: OR
55323: PUSH
55324: LD_VAR 0 3
55328: NOT
55329: OR
55330: PUSH
55331: LD_VAR 0 4
55335: PUSH
55336: LD_INT 1
55338: PUSH
55339: LD_INT 2
55341: PUSH
55342: LD_INT 3
55344: PUSH
55345: LD_INT 4
55347: PUSH
55348: LD_INT 5
55350: PUSH
55351: LD_INT 8
55353: PUSH
55354: LD_INT 9
55356: PUSH
55357: LD_INT 15
55359: PUSH
55360: LD_INT 16
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: LIST
55368: LIST
55369: LIST
55370: LIST
55371: LIST
55372: LIST
55373: IN
55374: NOT
55375: OR
55376: IFFALSE 55380
// exit ;
55378: GO 56280
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55380: LD_ADDR_VAR 0 2
55384: PUSH
55385: LD_VAR 0 2
55389: PPUSH
55390: LD_INT 21
55392: PUSH
55393: LD_INT 3
55395: PUSH
55396: EMPTY
55397: LIST
55398: LIST
55399: PUSH
55400: LD_INT 24
55402: PUSH
55403: LD_INT 250
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PPUSH
55414: CALL_OW 72
55418: ST_TO_ADDR
// case class of 1 , 15 :
55419: LD_VAR 0 4
55423: PUSH
55424: LD_INT 1
55426: DOUBLE
55427: EQUAL
55428: IFTRUE 55438
55430: LD_INT 15
55432: DOUBLE
55433: EQUAL
55434: IFTRUE 55438
55436: GO 55523
55438: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55439: LD_ADDR_VAR 0 8
55443: PUSH
55444: LD_VAR 0 2
55448: PPUSH
55449: LD_INT 2
55451: PUSH
55452: LD_INT 30
55454: PUSH
55455: LD_INT 32
55457: PUSH
55458: EMPTY
55459: LIST
55460: LIST
55461: PUSH
55462: LD_INT 30
55464: PUSH
55465: LD_INT 31
55467: PUSH
55468: EMPTY
55469: LIST
55470: LIST
55471: PUSH
55472: EMPTY
55473: LIST
55474: LIST
55475: LIST
55476: PPUSH
55477: CALL_OW 72
55481: PUSH
55482: LD_VAR 0 2
55486: PPUSH
55487: LD_INT 2
55489: PUSH
55490: LD_INT 30
55492: PUSH
55493: LD_INT 4
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 30
55502: PUSH
55503: LD_INT 5
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: LIST
55514: PPUSH
55515: CALL_OW 72
55519: ADD
55520: ST_TO_ADDR
55521: GO 55769
55523: LD_INT 2
55525: DOUBLE
55526: EQUAL
55527: IFTRUE 55537
55529: LD_INT 16
55531: DOUBLE
55532: EQUAL
55533: IFTRUE 55537
55535: GO 55583
55537: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55538: LD_ADDR_VAR 0 8
55542: PUSH
55543: LD_VAR 0 2
55547: PPUSH
55548: LD_INT 2
55550: PUSH
55551: LD_INT 30
55553: PUSH
55554: LD_INT 0
55556: PUSH
55557: EMPTY
55558: LIST
55559: LIST
55560: PUSH
55561: LD_INT 30
55563: PUSH
55564: LD_INT 1
55566: PUSH
55567: EMPTY
55568: LIST
55569: LIST
55570: PUSH
55571: EMPTY
55572: LIST
55573: LIST
55574: LIST
55575: PPUSH
55576: CALL_OW 72
55580: ST_TO_ADDR
55581: GO 55769
55583: LD_INT 3
55585: DOUBLE
55586: EQUAL
55587: IFTRUE 55591
55589: GO 55637
55591: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
55592: LD_ADDR_VAR 0 8
55596: PUSH
55597: LD_VAR 0 2
55601: PPUSH
55602: LD_INT 2
55604: PUSH
55605: LD_INT 30
55607: PUSH
55608: LD_INT 2
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: PUSH
55615: LD_INT 30
55617: PUSH
55618: LD_INT 3
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: PUSH
55625: EMPTY
55626: LIST
55627: LIST
55628: LIST
55629: PPUSH
55630: CALL_OW 72
55634: ST_TO_ADDR
55635: GO 55769
55637: LD_INT 4
55639: DOUBLE
55640: EQUAL
55641: IFTRUE 55645
55643: GO 55702
55645: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
55646: LD_ADDR_VAR 0 8
55650: PUSH
55651: LD_VAR 0 2
55655: PPUSH
55656: LD_INT 2
55658: PUSH
55659: LD_INT 30
55661: PUSH
55662: LD_INT 6
55664: PUSH
55665: EMPTY
55666: LIST
55667: LIST
55668: PUSH
55669: LD_INT 30
55671: PUSH
55672: LD_INT 7
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: PUSH
55679: LD_INT 30
55681: PUSH
55682: LD_INT 8
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: LIST
55694: PPUSH
55695: CALL_OW 72
55699: ST_TO_ADDR
55700: GO 55769
55702: LD_INT 5
55704: DOUBLE
55705: EQUAL
55706: IFTRUE 55722
55708: LD_INT 8
55710: DOUBLE
55711: EQUAL
55712: IFTRUE 55722
55714: LD_INT 9
55716: DOUBLE
55717: EQUAL
55718: IFTRUE 55722
55720: GO 55768
55722: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
55723: LD_ADDR_VAR 0 8
55727: PUSH
55728: LD_VAR 0 2
55732: PPUSH
55733: LD_INT 2
55735: PUSH
55736: LD_INT 30
55738: PUSH
55739: LD_INT 4
55741: PUSH
55742: EMPTY
55743: LIST
55744: LIST
55745: PUSH
55746: LD_INT 30
55748: PUSH
55749: LD_INT 5
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: PUSH
55756: EMPTY
55757: LIST
55758: LIST
55759: LIST
55760: PPUSH
55761: CALL_OW 72
55765: ST_TO_ADDR
55766: GO 55769
55768: POP
// if not tmp then
55769: LD_VAR 0 8
55773: NOT
55774: IFFALSE 55778
// exit ;
55776: GO 56280
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
55778: LD_VAR 0 4
55782: PUSH
55783: LD_INT 1
55785: PUSH
55786: LD_INT 15
55788: PUSH
55789: EMPTY
55790: LIST
55791: LIST
55792: IN
55793: PUSH
55794: LD_EXP 108
55798: PUSH
55799: LD_VAR 0 1
55803: ARRAY
55804: AND
55805: IFFALSE 55961
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
55807: LD_ADDR_VAR 0 9
55811: PUSH
55812: LD_EXP 108
55816: PUSH
55817: LD_VAR 0 1
55821: ARRAY
55822: PUSH
55823: LD_INT 1
55825: ARRAY
55826: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
55827: LD_VAR 0 9
55831: PUSH
55832: LD_EXP 109
55836: PUSH
55837: LD_VAR 0 1
55841: ARRAY
55842: IN
55843: NOT
55844: IFFALSE 55959
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
55846: LD_ADDR_EXP 109
55850: PUSH
55851: LD_EXP 109
55855: PPUSH
55856: LD_VAR 0 1
55860: PUSH
55861: LD_EXP 109
55865: PUSH
55866: LD_VAR 0 1
55870: ARRAY
55871: PUSH
55872: LD_INT 1
55874: PLUS
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: PPUSH
55880: LD_VAR 0 9
55884: PPUSH
55885: CALL 69637 0 3
55889: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
55890: LD_ADDR_EXP 108
55894: PUSH
55895: LD_EXP 108
55899: PPUSH
55900: LD_VAR 0 1
55904: PPUSH
55905: LD_EXP 108
55909: PUSH
55910: LD_VAR 0 1
55914: ARRAY
55915: PUSH
55916: LD_VAR 0 9
55920: DIFF
55921: PPUSH
55922: CALL_OW 1
55926: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55927: LD_VAR 0 3
55931: PPUSH
55932: LD_EXP 109
55936: PUSH
55937: LD_VAR 0 1
55941: ARRAY
55942: PUSH
55943: LD_EXP 109
55947: PUSH
55948: LD_VAR 0 1
55952: ARRAY
55953: ARRAY
55954: PPUSH
55955: CALL_OW 120
// end ; exit ;
55959: GO 56280
// end ; if tmp > 1 then
55961: LD_VAR 0 8
55965: PUSH
55966: LD_INT 1
55968: GREATER
55969: IFFALSE 56073
// for i = 2 to tmp do
55971: LD_ADDR_VAR 0 6
55975: PUSH
55976: DOUBLE
55977: LD_INT 2
55979: DEC
55980: ST_TO_ADDR
55981: LD_VAR 0 8
55985: PUSH
55986: FOR_TO
55987: IFFALSE 56071
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
55989: LD_VAR 0 8
55993: PUSH
55994: LD_VAR 0 6
55998: ARRAY
55999: PPUSH
56000: CALL_OW 461
56004: PUSH
56005: LD_INT 6
56007: EQUAL
56008: IFFALSE 56069
// begin x := tmp [ i ] ;
56010: LD_ADDR_VAR 0 9
56014: PUSH
56015: LD_VAR 0 8
56019: PUSH
56020: LD_VAR 0 6
56024: ARRAY
56025: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56026: LD_ADDR_VAR 0 8
56030: PUSH
56031: LD_VAR 0 8
56035: PPUSH
56036: LD_VAR 0 6
56040: PPUSH
56041: CALL_OW 3
56045: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56046: LD_ADDR_VAR 0 8
56050: PUSH
56051: LD_VAR 0 8
56055: PPUSH
56056: LD_INT 1
56058: PPUSH
56059: LD_VAR 0 9
56063: PPUSH
56064: CALL_OW 2
56068: ST_TO_ADDR
// end ;
56069: GO 55986
56071: POP
56072: POP
// for i in tmp do
56073: LD_ADDR_VAR 0 6
56077: PUSH
56078: LD_VAR 0 8
56082: PUSH
56083: FOR_IN
56084: IFFALSE 56153
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56086: LD_VAR 0 6
56090: PPUSH
56091: CALL_OW 313
56095: PUSH
56096: LD_INT 6
56098: LESS
56099: PUSH
56100: LD_VAR 0 6
56104: PPUSH
56105: CALL_OW 266
56109: PUSH
56110: LD_INT 31
56112: PUSH
56113: LD_INT 32
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: IN
56120: NOT
56121: AND
56122: PUSH
56123: LD_VAR 0 6
56127: PPUSH
56128: CALL_OW 313
56132: PUSH
56133: LD_INT 0
56135: EQUAL
56136: OR
56137: IFFALSE 56151
// begin j := i ;
56139: LD_ADDR_VAR 0 7
56143: PUSH
56144: LD_VAR 0 6
56148: ST_TO_ADDR
// break ;
56149: GO 56153
// end ; end ;
56151: GO 56083
56153: POP
56154: POP
// if j then
56155: LD_VAR 0 7
56159: IFFALSE 56177
// ComEnterUnit ( unit , j ) else
56161: LD_VAR 0 3
56165: PPUSH
56166: LD_VAR 0 7
56170: PPUSH
56171: CALL_OW 120
56175: GO 56280
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56177: LD_ADDR_VAR 0 10
56181: PUSH
56182: LD_VAR 0 2
56186: PPUSH
56187: LD_INT 2
56189: PUSH
56190: LD_INT 30
56192: PUSH
56193: LD_INT 0
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: LD_INT 30
56202: PUSH
56203: LD_INT 1
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: LIST
56214: PPUSH
56215: CALL_OW 72
56219: ST_TO_ADDR
// if depot then
56220: LD_VAR 0 10
56224: IFFALSE 56280
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56226: LD_ADDR_VAR 0 10
56230: PUSH
56231: LD_VAR 0 10
56235: PPUSH
56236: LD_VAR 0 3
56240: PPUSH
56241: CALL_OW 74
56245: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56246: LD_VAR 0 3
56250: PPUSH
56251: LD_VAR 0 10
56255: PPUSH
56256: CALL_OW 296
56260: PUSH
56261: LD_INT 10
56263: GREATER
56264: IFFALSE 56280
// ComStandNearbyBuilding ( unit , depot ) ;
56266: LD_VAR 0 3
56270: PPUSH
56271: LD_VAR 0 10
56275: PPUSH
56276: CALL 64344 0 2
// end ; end ; end ;
56280: LD_VAR 0 5
56284: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56285: LD_INT 0
56287: PPUSH
56288: PPUSH
56289: PPUSH
56290: PPUSH
// if not mc_bases then
56291: LD_EXP 99
56295: NOT
56296: IFFALSE 56300
// exit ;
56298: GO 56539
// for i = 1 to mc_bases do
56300: LD_ADDR_VAR 0 2
56304: PUSH
56305: DOUBLE
56306: LD_INT 1
56308: DEC
56309: ST_TO_ADDR
56310: LD_EXP 99
56314: PUSH
56315: FOR_TO
56316: IFFALSE 56537
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56318: LD_ADDR_VAR 0 4
56322: PUSH
56323: LD_EXP 99
56327: PUSH
56328: LD_VAR 0 2
56332: ARRAY
56333: PPUSH
56334: LD_INT 21
56336: PUSH
56337: LD_INT 1
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PPUSH
56344: CALL_OW 72
56348: PUSH
56349: LD_EXP 128
56353: PUSH
56354: LD_VAR 0 2
56358: ARRAY
56359: UNION
56360: ST_TO_ADDR
// if not tmp then
56361: LD_VAR 0 4
56365: NOT
56366: IFFALSE 56370
// continue ;
56368: GO 56315
// for j in tmp do
56370: LD_ADDR_VAR 0 3
56374: PUSH
56375: LD_VAR 0 4
56379: PUSH
56380: FOR_IN
56381: IFFALSE 56533
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56383: LD_VAR 0 3
56387: PPUSH
56388: CALL_OW 110
56392: NOT
56393: PUSH
56394: LD_VAR 0 3
56398: PPUSH
56399: CALL_OW 314
56403: NOT
56404: AND
56405: PUSH
56406: LD_VAR 0 3
56410: PPUSH
56411: CALL_OW 311
56415: NOT
56416: AND
56417: PUSH
56418: LD_VAR 0 3
56422: PPUSH
56423: CALL_OW 310
56427: NOT
56428: AND
56429: PUSH
56430: LD_VAR 0 3
56434: PUSH
56435: LD_EXP 102
56439: PUSH
56440: LD_VAR 0 2
56444: ARRAY
56445: PUSH
56446: LD_INT 1
56448: ARRAY
56449: IN
56450: NOT
56451: AND
56452: PUSH
56453: LD_VAR 0 3
56457: PUSH
56458: LD_EXP 102
56462: PUSH
56463: LD_VAR 0 2
56467: ARRAY
56468: PUSH
56469: LD_INT 2
56471: ARRAY
56472: IN
56473: NOT
56474: AND
56475: PUSH
56476: LD_VAR 0 3
56480: PUSH
56481: LD_EXP 111
56485: PUSH
56486: LD_VAR 0 2
56490: ARRAY
56491: IN
56492: NOT
56493: AND
56494: IFFALSE 56531
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56496: LD_VAR 0 2
56500: PPUSH
56501: LD_EXP 99
56505: PUSH
56506: LD_VAR 0 2
56510: ARRAY
56511: PPUSH
56512: LD_VAR 0 3
56516: PPUSH
56517: LD_VAR 0 3
56521: PPUSH
56522: CALL_OW 257
56526: PPUSH
56527: CALL 55303 0 4
// end ;
56531: GO 56380
56533: POP
56534: POP
// end ;
56535: GO 56315
56537: POP
56538: POP
// end ;
56539: LD_VAR 0 1
56543: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
56544: LD_INT 0
56546: PPUSH
56547: PPUSH
56548: PPUSH
56549: PPUSH
56550: PPUSH
56551: PPUSH
// if not mc_bases [ base ] then
56552: LD_EXP 99
56556: PUSH
56557: LD_VAR 0 1
56561: ARRAY
56562: NOT
56563: IFFALSE 56567
// exit ;
56565: GO 56749
// tmp := [ ] ;
56567: LD_ADDR_VAR 0 6
56571: PUSH
56572: EMPTY
56573: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
56574: LD_ADDR_VAR 0 7
56578: PUSH
56579: LD_VAR 0 3
56583: PPUSH
56584: LD_INT 0
56586: PPUSH
56587: CALL_OW 517
56591: ST_TO_ADDR
// if not list then
56592: LD_VAR 0 7
56596: NOT
56597: IFFALSE 56601
// exit ;
56599: GO 56749
// for i = 1 to amount do
56601: LD_ADDR_VAR 0 5
56605: PUSH
56606: DOUBLE
56607: LD_INT 1
56609: DEC
56610: ST_TO_ADDR
56611: LD_VAR 0 2
56615: PUSH
56616: FOR_TO
56617: IFFALSE 56697
// begin x := rand ( 1 , list [ 1 ] ) ;
56619: LD_ADDR_VAR 0 8
56623: PUSH
56624: LD_INT 1
56626: PPUSH
56627: LD_VAR 0 7
56631: PUSH
56632: LD_INT 1
56634: ARRAY
56635: PPUSH
56636: CALL_OW 12
56640: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
56641: LD_ADDR_VAR 0 6
56645: PUSH
56646: LD_VAR 0 6
56650: PPUSH
56651: LD_VAR 0 5
56655: PPUSH
56656: LD_VAR 0 7
56660: PUSH
56661: LD_INT 1
56663: ARRAY
56664: PUSH
56665: LD_VAR 0 8
56669: ARRAY
56670: PUSH
56671: LD_VAR 0 7
56675: PUSH
56676: LD_INT 2
56678: ARRAY
56679: PUSH
56680: LD_VAR 0 8
56684: ARRAY
56685: PUSH
56686: EMPTY
56687: LIST
56688: LIST
56689: PPUSH
56690: CALL_OW 1
56694: ST_TO_ADDR
// end ;
56695: GO 56616
56697: POP
56698: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
56699: LD_ADDR_EXP 112
56703: PUSH
56704: LD_EXP 112
56708: PPUSH
56709: LD_VAR 0 1
56713: PPUSH
56714: LD_VAR 0 6
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
56724: LD_ADDR_EXP 114
56728: PUSH
56729: LD_EXP 114
56733: PPUSH
56734: LD_VAR 0 1
56738: PPUSH
56739: LD_VAR 0 3
56743: PPUSH
56744: CALL_OW 1
56748: ST_TO_ADDR
// end ;
56749: LD_VAR 0 4
56753: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
56754: LD_INT 0
56756: PPUSH
// if not mc_bases [ base ] then
56757: LD_EXP 99
56761: PUSH
56762: LD_VAR 0 1
56766: ARRAY
56767: NOT
56768: IFFALSE 56772
// exit ;
56770: GO 56797
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
56772: LD_ADDR_EXP 104
56776: PUSH
56777: LD_EXP 104
56781: PPUSH
56782: LD_VAR 0 1
56786: PPUSH
56787: LD_VAR 0 2
56791: PPUSH
56792: CALL_OW 1
56796: ST_TO_ADDR
// end ;
56797: LD_VAR 0 3
56801: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
56802: LD_INT 0
56804: PPUSH
// if not mc_bases [ base ] then
56805: LD_EXP 99
56809: PUSH
56810: LD_VAR 0 1
56814: ARRAY
56815: NOT
56816: IFFALSE 56820
// exit ;
56818: GO 56857
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
56820: LD_ADDR_EXP 104
56824: PUSH
56825: LD_EXP 104
56829: PPUSH
56830: LD_VAR 0 1
56834: PPUSH
56835: LD_EXP 104
56839: PUSH
56840: LD_VAR 0 1
56844: ARRAY
56845: PUSH
56846: LD_VAR 0 2
56850: UNION
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// end ;
56857: LD_VAR 0 3
56861: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
56862: LD_INT 0
56864: PPUSH
// if not mc_bases [ base ] then
56865: LD_EXP 99
56869: PUSH
56870: LD_VAR 0 1
56874: ARRAY
56875: NOT
56876: IFFALSE 56880
// exit ;
56878: GO 56905
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
56880: LD_ADDR_EXP 120
56884: PUSH
56885: LD_EXP 120
56889: PPUSH
56890: LD_VAR 0 1
56894: PPUSH
56895: LD_VAR 0 2
56899: PPUSH
56900: CALL_OW 1
56904: ST_TO_ADDR
// end ;
56905: LD_VAR 0 3
56909: RET
// export function MC_InsertProduceList ( base , components ) ; begin
56910: LD_INT 0
56912: PPUSH
// if not mc_bases [ base ] then
56913: LD_EXP 99
56917: PUSH
56918: LD_VAR 0 1
56922: ARRAY
56923: NOT
56924: IFFALSE 56928
// exit ;
56926: GO 56965
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56928: LD_ADDR_EXP 120
56932: PUSH
56933: LD_EXP 120
56937: PPUSH
56938: LD_VAR 0 1
56942: PPUSH
56943: LD_EXP 120
56947: PUSH
56948: LD_VAR 0 1
56952: ARRAY
56953: PUSH
56954: LD_VAR 0 2
56958: ADD
56959: PPUSH
56960: CALL_OW 1
56964: ST_TO_ADDR
// end ;
56965: LD_VAR 0 3
56969: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
56970: LD_INT 0
56972: PPUSH
// if not mc_bases [ base ] then
56973: LD_EXP 99
56977: PUSH
56978: LD_VAR 0 1
56982: ARRAY
56983: NOT
56984: IFFALSE 56988
// exit ;
56986: GO 57042
// mc_defender := Replace ( mc_defender , base , deflist ) ;
56988: LD_ADDR_EXP 121
56992: PUSH
56993: LD_EXP 121
56997: PPUSH
56998: LD_VAR 0 1
57002: PPUSH
57003: LD_VAR 0 2
57007: PPUSH
57008: CALL_OW 1
57012: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57013: LD_ADDR_EXP 110
57017: PUSH
57018: LD_EXP 110
57022: PPUSH
57023: LD_VAR 0 1
57027: PPUSH
57028: LD_VAR 0 2
57032: PUSH
57033: LD_INT 0
57035: PLUS
57036: PPUSH
57037: CALL_OW 1
57041: ST_TO_ADDR
// end ;
57042: LD_VAR 0 3
57046: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57047: LD_INT 0
57049: PPUSH
// if not mc_bases [ base ] then
57050: LD_EXP 99
57054: PUSH
57055: LD_VAR 0 1
57059: ARRAY
57060: NOT
57061: IFFALSE 57065
// exit ;
57063: GO 57090
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57065: LD_ADDR_EXP 110
57069: PUSH
57070: LD_EXP 110
57074: PPUSH
57075: LD_VAR 0 1
57079: PPUSH
57080: LD_VAR 0 2
57084: PPUSH
57085: CALL_OW 1
57089: ST_TO_ADDR
// end ;
57090: LD_VAR 0 3
57094: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57095: LD_INT 0
57097: PPUSH
57098: PPUSH
57099: PPUSH
57100: PPUSH
// if not mc_bases [ base ] then
57101: LD_EXP 99
57105: PUSH
57106: LD_VAR 0 1
57110: ARRAY
57111: NOT
57112: IFFALSE 57116
// exit ;
57114: GO 57181
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57116: LD_ADDR_EXP 119
57120: PUSH
57121: LD_EXP 119
57125: PPUSH
57126: LD_VAR 0 1
57130: PUSH
57131: LD_EXP 119
57135: PUSH
57136: LD_VAR 0 1
57140: ARRAY
57141: PUSH
57142: LD_INT 1
57144: PLUS
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PPUSH
57150: LD_VAR 0 1
57154: PUSH
57155: LD_VAR 0 2
57159: PUSH
57160: LD_VAR 0 3
57164: PUSH
57165: LD_VAR 0 4
57169: PUSH
57170: EMPTY
57171: LIST
57172: LIST
57173: LIST
57174: LIST
57175: PPUSH
57176: CALL 69637 0 3
57180: ST_TO_ADDR
// end ;
57181: LD_VAR 0 5
57185: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57186: LD_INT 0
57188: PPUSH
// if not mc_bases [ base ] then
57189: LD_EXP 99
57193: PUSH
57194: LD_VAR 0 1
57198: ARRAY
57199: NOT
57200: IFFALSE 57204
// exit ;
57202: GO 57229
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57204: LD_ADDR_EXP 136
57208: PUSH
57209: LD_EXP 136
57213: PPUSH
57214: LD_VAR 0 1
57218: PPUSH
57219: LD_VAR 0 2
57223: PPUSH
57224: CALL_OW 1
57228: ST_TO_ADDR
// end ;
57229: LD_VAR 0 3
57233: RET
// export function MC_GetMinesField ( base ) ; begin
57234: LD_INT 0
57236: PPUSH
// result := mc_mines [ base ] ;
57237: LD_ADDR_VAR 0 2
57241: PUSH
57242: LD_EXP 112
57246: PUSH
57247: LD_VAR 0 1
57251: ARRAY
57252: ST_TO_ADDR
// end ;
57253: LD_VAR 0 2
57257: RET
// export function MC_GetProduceList ( base ) ; begin
57258: LD_INT 0
57260: PPUSH
// result := mc_produce [ base ] ;
57261: LD_ADDR_VAR 0 2
57265: PUSH
57266: LD_EXP 120
57270: PUSH
57271: LD_VAR 0 1
57275: ARRAY
57276: ST_TO_ADDR
// end ;
57277: LD_VAR 0 2
57281: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57282: LD_INT 0
57284: PPUSH
57285: PPUSH
// if not mc_bases then
57286: LD_EXP 99
57290: NOT
57291: IFFALSE 57295
// exit ;
57293: GO 57360
// if mc_bases [ base ] then
57295: LD_EXP 99
57299: PUSH
57300: LD_VAR 0 1
57304: ARRAY
57305: IFFALSE 57360
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57307: LD_ADDR_VAR 0 3
57311: PUSH
57312: LD_EXP 99
57316: PUSH
57317: LD_VAR 0 1
57321: ARRAY
57322: PPUSH
57323: LD_INT 30
57325: PUSH
57326: LD_VAR 0 2
57330: PUSH
57331: EMPTY
57332: LIST
57333: LIST
57334: PPUSH
57335: CALL_OW 72
57339: ST_TO_ADDR
// if result then
57340: LD_VAR 0 3
57344: IFFALSE 57360
// result := result [ 1 ] ;
57346: LD_ADDR_VAR 0 3
57350: PUSH
57351: LD_VAR 0 3
57355: PUSH
57356: LD_INT 1
57358: ARRAY
57359: ST_TO_ADDR
// end ; end ;
57360: LD_VAR 0 3
57364: RET
// export function MC_SetTame ( base , area ) ; begin
57365: LD_INT 0
57367: PPUSH
// if not mc_bases or not base then
57368: LD_EXP 99
57372: NOT
57373: PUSH
57374: LD_VAR 0 1
57378: NOT
57379: OR
57380: IFFALSE 57384
// exit ;
57382: GO 57409
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57384: LD_ADDR_EXP 127
57388: PUSH
57389: LD_EXP 127
57393: PPUSH
57394: LD_VAR 0 1
57398: PPUSH
57399: LD_VAR 0 2
57403: PPUSH
57404: CALL_OW 1
57408: ST_TO_ADDR
// end ;
57409: LD_VAR 0 3
57413: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57414: LD_INT 0
57416: PPUSH
57417: PPUSH
// if not mc_bases or not base then
57418: LD_EXP 99
57422: NOT
57423: PUSH
57424: LD_VAR 0 1
57428: NOT
57429: OR
57430: IFFALSE 57434
// exit ;
57432: GO 57536
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57434: LD_ADDR_VAR 0 4
57438: PUSH
57439: LD_EXP 99
57443: PUSH
57444: LD_VAR 0 1
57448: ARRAY
57449: PPUSH
57450: LD_INT 30
57452: PUSH
57453: LD_VAR 0 2
57457: PUSH
57458: EMPTY
57459: LIST
57460: LIST
57461: PPUSH
57462: CALL_OW 72
57466: ST_TO_ADDR
// if not tmp then
57467: LD_VAR 0 4
57471: NOT
57472: IFFALSE 57476
// exit ;
57474: GO 57536
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57476: LD_ADDR_EXP 131
57480: PUSH
57481: LD_EXP 131
57485: PPUSH
57486: LD_VAR 0 1
57490: PPUSH
57491: LD_EXP 131
57495: PUSH
57496: LD_VAR 0 1
57500: ARRAY
57501: PPUSH
57502: LD_EXP 131
57506: PUSH
57507: LD_VAR 0 1
57511: ARRAY
57512: PUSH
57513: LD_INT 1
57515: PLUS
57516: PPUSH
57517: LD_VAR 0 4
57521: PUSH
57522: LD_INT 1
57524: ARRAY
57525: PPUSH
57526: CALL_OW 2
57530: PPUSH
57531: CALL_OW 1
57535: ST_TO_ADDR
// end ;
57536: LD_VAR 0 3
57540: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
57541: LD_INT 0
57543: PPUSH
57544: PPUSH
// if not mc_bases or not base or not kinds then
57545: LD_EXP 99
57549: NOT
57550: PUSH
57551: LD_VAR 0 1
57555: NOT
57556: OR
57557: PUSH
57558: LD_VAR 0 2
57562: NOT
57563: OR
57564: IFFALSE 57568
// exit ;
57566: GO 57629
// for i in kinds do
57568: LD_ADDR_VAR 0 4
57572: PUSH
57573: LD_VAR 0 2
57577: PUSH
57578: FOR_IN
57579: IFFALSE 57627
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
57581: LD_ADDR_EXP 133
57585: PUSH
57586: LD_EXP 133
57590: PPUSH
57591: LD_VAR 0 1
57595: PUSH
57596: LD_EXP 133
57600: PUSH
57601: LD_VAR 0 1
57605: ARRAY
57606: PUSH
57607: LD_INT 1
57609: PLUS
57610: PUSH
57611: EMPTY
57612: LIST
57613: LIST
57614: PPUSH
57615: LD_VAR 0 4
57619: PPUSH
57620: CALL 69637 0 3
57624: ST_TO_ADDR
57625: GO 57578
57627: POP
57628: POP
// end ;
57629: LD_VAR 0 3
57633: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
57634: LD_INT 0
57636: PPUSH
// if not mc_bases or not base or not areas then
57637: LD_EXP 99
57641: NOT
57642: PUSH
57643: LD_VAR 0 1
57647: NOT
57648: OR
57649: PUSH
57650: LD_VAR 0 2
57654: NOT
57655: OR
57656: IFFALSE 57660
// exit ;
57658: GO 57685
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
57660: LD_ADDR_EXP 117
57664: PUSH
57665: LD_EXP 117
57669: PPUSH
57670: LD_VAR 0 1
57674: PPUSH
57675: LD_VAR 0 2
57679: PPUSH
57680: CALL_OW 1
57684: ST_TO_ADDR
// end ;
57685: LD_VAR 0 3
57689: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
57690: LD_INT 0
57692: PPUSH
// if not mc_bases or not base or not teleports_exit then
57693: LD_EXP 99
57697: NOT
57698: PUSH
57699: LD_VAR 0 1
57703: NOT
57704: OR
57705: PUSH
57706: LD_VAR 0 2
57710: NOT
57711: OR
57712: IFFALSE 57716
// exit ;
57714: GO 57741
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
57716: LD_ADDR_EXP 134
57720: PUSH
57721: LD_EXP 134
57725: PPUSH
57726: LD_VAR 0 1
57730: PPUSH
57731: LD_VAR 0 2
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// end ;
57741: LD_VAR 0 3
57745: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
57746: LD_INT 0
57748: PPUSH
57749: PPUSH
57750: PPUSH
// if not mc_bases or not base or not ext_list then
57751: LD_EXP 99
57755: NOT
57756: PUSH
57757: LD_VAR 0 1
57761: NOT
57762: OR
57763: PUSH
57764: LD_VAR 0 5
57768: NOT
57769: OR
57770: IFFALSE 57774
// exit ;
57772: GO 57947
// tmp := GetFacExtXYD ( x , y , d ) ;
57774: LD_ADDR_VAR 0 8
57778: PUSH
57779: LD_VAR 0 2
57783: PPUSH
57784: LD_VAR 0 3
57788: PPUSH
57789: LD_VAR 0 4
57793: PPUSH
57794: CALL 103015 0 3
57798: ST_TO_ADDR
// if not tmp then
57799: LD_VAR 0 8
57803: NOT
57804: IFFALSE 57808
// exit ;
57806: GO 57947
// for i in tmp do
57808: LD_ADDR_VAR 0 7
57812: PUSH
57813: LD_VAR 0 8
57817: PUSH
57818: FOR_IN
57819: IFFALSE 57945
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
57821: LD_ADDR_EXP 104
57825: PUSH
57826: LD_EXP 104
57830: PPUSH
57831: LD_VAR 0 1
57835: PPUSH
57836: LD_EXP 104
57840: PUSH
57841: LD_VAR 0 1
57845: ARRAY
57846: PPUSH
57847: LD_EXP 104
57851: PUSH
57852: LD_VAR 0 1
57856: ARRAY
57857: PUSH
57858: LD_INT 1
57860: PLUS
57861: PPUSH
57862: LD_VAR 0 5
57866: PUSH
57867: LD_INT 1
57869: ARRAY
57870: PUSH
57871: LD_VAR 0 7
57875: PUSH
57876: LD_INT 1
57878: ARRAY
57879: PUSH
57880: LD_VAR 0 7
57884: PUSH
57885: LD_INT 2
57887: ARRAY
57888: PUSH
57889: LD_VAR 0 7
57893: PUSH
57894: LD_INT 3
57896: ARRAY
57897: PUSH
57898: EMPTY
57899: LIST
57900: LIST
57901: LIST
57902: LIST
57903: PPUSH
57904: CALL_OW 2
57908: PPUSH
57909: CALL_OW 1
57913: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57914: LD_ADDR_VAR 0 5
57918: PUSH
57919: LD_VAR 0 5
57923: PPUSH
57924: LD_INT 1
57926: PPUSH
57927: CALL_OW 3
57931: ST_TO_ADDR
// if not ext_list then
57932: LD_VAR 0 5
57936: NOT
57937: IFFALSE 57943
// exit ;
57939: POP
57940: POP
57941: GO 57947
// end ;
57943: GO 57818
57945: POP
57946: POP
// end ;
57947: LD_VAR 0 6
57951: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
57952: LD_INT 0
57954: PPUSH
// if not mc_bases or not base or not weapon_list then
57955: LD_EXP 99
57959: NOT
57960: PUSH
57961: LD_VAR 0 1
57965: NOT
57966: OR
57967: PUSH
57968: LD_VAR 0 2
57972: NOT
57973: OR
57974: IFFALSE 57978
// exit ;
57976: GO 58003
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
57978: LD_ADDR_EXP 138
57982: PUSH
57983: LD_EXP 138
57987: PPUSH
57988: LD_VAR 0 1
57992: PPUSH
57993: LD_VAR 0 2
57997: PPUSH
57998: CALL_OW 1
58002: ST_TO_ADDR
// end ;
58003: LD_VAR 0 3
58007: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58008: LD_INT 0
58010: PPUSH
// if not mc_bases or not base or not tech_list then
58011: LD_EXP 99
58015: NOT
58016: PUSH
58017: LD_VAR 0 1
58021: NOT
58022: OR
58023: PUSH
58024: LD_VAR 0 2
58028: NOT
58029: OR
58030: IFFALSE 58034
// exit ;
58032: GO 58059
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58034: LD_ADDR_EXP 126
58038: PUSH
58039: LD_EXP 126
58043: PPUSH
58044: LD_VAR 0 1
58048: PPUSH
58049: LD_VAR 0 2
58053: PPUSH
58054: CALL_OW 1
58058: ST_TO_ADDR
// end ;
58059: LD_VAR 0 3
58063: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58064: LD_INT 0
58066: PPUSH
// if not mc_bases or not parking_area or not base then
58067: LD_EXP 99
58071: NOT
58072: PUSH
58073: LD_VAR 0 2
58077: NOT
58078: OR
58079: PUSH
58080: LD_VAR 0 1
58084: NOT
58085: OR
58086: IFFALSE 58090
// exit ;
58088: GO 58115
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58090: LD_ADDR_EXP 123
58094: PUSH
58095: LD_EXP 123
58099: PPUSH
58100: LD_VAR 0 1
58104: PPUSH
58105: LD_VAR 0 2
58109: PPUSH
58110: CALL_OW 1
58114: ST_TO_ADDR
// end ;
58115: LD_VAR 0 3
58119: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58120: LD_INT 0
58122: PPUSH
// if not mc_bases or not base or not scan_area then
58123: LD_EXP 99
58127: NOT
58128: PUSH
58129: LD_VAR 0 1
58133: NOT
58134: OR
58135: PUSH
58136: LD_VAR 0 2
58140: NOT
58141: OR
58142: IFFALSE 58146
// exit ;
58144: GO 58171
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58146: LD_ADDR_EXP 124
58150: PUSH
58151: LD_EXP 124
58155: PPUSH
58156: LD_VAR 0 1
58160: PPUSH
58161: LD_VAR 0 2
58165: PPUSH
58166: CALL_OW 1
58170: ST_TO_ADDR
// end ;
58171: LD_VAR 0 3
58175: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58176: LD_INT 0
58178: PPUSH
58179: PPUSH
// if not mc_bases or not base then
58180: LD_EXP 99
58184: NOT
58185: PUSH
58186: LD_VAR 0 1
58190: NOT
58191: OR
58192: IFFALSE 58196
// exit ;
58194: GO 58260
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58196: LD_ADDR_VAR 0 3
58200: PUSH
58201: LD_INT 1
58203: PUSH
58204: LD_INT 2
58206: PUSH
58207: LD_INT 3
58209: PUSH
58210: LD_INT 4
58212: PUSH
58213: LD_INT 11
58215: PUSH
58216: EMPTY
58217: LIST
58218: LIST
58219: LIST
58220: LIST
58221: LIST
58222: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58223: LD_ADDR_EXP 126
58227: PUSH
58228: LD_EXP 126
58232: PPUSH
58233: LD_VAR 0 1
58237: PPUSH
58238: LD_EXP 126
58242: PUSH
58243: LD_VAR 0 1
58247: ARRAY
58248: PUSH
58249: LD_VAR 0 3
58253: DIFF
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// end ;
58260: LD_VAR 0 2
58264: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58265: LD_INT 0
58267: PPUSH
// result := mc_vehicles [ base ] ;
58268: LD_ADDR_VAR 0 3
58272: PUSH
58273: LD_EXP 118
58277: PUSH
58278: LD_VAR 0 1
58282: ARRAY
58283: ST_TO_ADDR
// if onlyCombat then
58284: LD_VAR 0 2
58288: IFFALSE 58453
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58290: LD_ADDR_VAR 0 3
58294: PUSH
58295: LD_VAR 0 3
58299: PUSH
58300: LD_VAR 0 3
58304: PPUSH
58305: LD_INT 2
58307: PUSH
58308: LD_INT 34
58310: PUSH
58311: LD_INT 12
58313: PUSH
58314: EMPTY
58315: LIST
58316: LIST
58317: PUSH
58318: LD_INT 34
58320: PUSH
58321: LD_INT 51
58323: PUSH
58324: EMPTY
58325: LIST
58326: LIST
58327: PUSH
58328: LD_INT 34
58330: PUSH
58331: LD_EXP 93
58335: PUSH
58336: EMPTY
58337: LIST
58338: LIST
58339: PUSH
58340: LD_INT 34
58342: PUSH
58343: LD_INT 32
58345: PUSH
58346: EMPTY
58347: LIST
58348: LIST
58349: PUSH
58350: LD_INT 34
58352: PUSH
58353: LD_INT 13
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: PUSH
58360: LD_INT 34
58362: PUSH
58363: LD_INT 52
58365: PUSH
58366: EMPTY
58367: LIST
58368: LIST
58369: PUSH
58370: LD_INT 34
58372: PUSH
58373: LD_INT 14
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: PUSH
58380: LD_INT 34
58382: PUSH
58383: LD_INT 53
58385: PUSH
58386: EMPTY
58387: LIST
58388: LIST
58389: PUSH
58390: LD_INT 34
58392: PUSH
58393: LD_EXP 92
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: PUSH
58402: LD_INT 34
58404: PUSH
58405: LD_INT 31
58407: PUSH
58408: EMPTY
58409: LIST
58410: LIST
58411: PUSH
58412: LD_INT 34
58414: PUSH
58415: LD_INT 48
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: PUSH
58422: LD_INT 34
58424: PUSH
58425: LD_INT 8
58427: PUSH
58428: EMPTY
58429: LIST
58430: LIST
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: LIST
58437: LIST
58438: LIST
58439: LIST
58440: LIST
58441: LIST
58442: LIST
58443: LIST
58444: LIST
58445: LIST
58446: PPUSH
58447: CALL_OW 72
58451: DIFF
58452: ST_TO_ADDR
// end ; end_of_file
58453: LD_VAR 0 3
58457: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58458: LD_INT 0
58460: PPUSH
58461: PPUSH
58462: PPUSH
// if not mc_bases or not skirmish then
58463: LD_EXP 99
58467: NOT
58468: PUSH
58469: LD_EXP 97
58473: NOT
58474: OR
58475: IFFALSE 58479
// exit ;
58477: GO 58644
// for i = 1 to mc_bases do
58479: LD_ADDR_VAR 0 4
58483: PUSH
58484: DOUBLE
58485: LD_INT 1
58487: DEC
58488: ST_TO_ADDR
58489: LD_EXP 99
58493: PUSH
58494: FOR_TO
58495: IFFALSE 58642
// begin if sci in mc_bases [ i ] then
58497: LD_VAR 0 2
58501: PUSH
58502: LD_EXP 99
58506: PUSH
58507: LD_VAR 0 4
58511: ARRAY
58512: IN
58513: IFFALSE 58640
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
58515: LD_ADDR_EXP 128
58519: PUSH
58520: LD_EXP 128
58524: PPUSH
58525: LD_VAR 0 4
58529: PUSH
58530: LD_EXP 128
58534: PUSH
58535: LD_VAR 0 4
58539: ARRAY
58540: PUSH
58541: LD_INT 1
58543: PLUS
58544: PUSH
58545: EMPTY
58546: LIST
58547: LIST
58548: PPUSH
58549: LD_VAR 0 1
58553: PPUSH
58554: CALL 69637 0 3
58558: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
58559: LD_ADDR_VAR 0 5
58563: PUSH
58564: LD_EXP 99
58568: PUSH
58569: LD_VAR 0 4
58573: ARRAY
58574: PPUSH
58575: LD_INT 2
58577: PUSH
58578: LD_INT 30
58580: PUSH
58581: LD_INT 0
58583: PUSH
58584: EMPTY
58585: LIST
58586: LIST
58587: PUSH
58588: LD_INT 30
58590: PUSH
58591: LD_INT 1
58593: PUSH
58594: EMPTY
58595: LIST
58596: LIST
58597: PUSH
58598: EMPTY
58599: LIST
58600: LIST
58601: LIST
58602: PPUSH
58603: CALL_OW 72
58607: PPUSH
58608: LD_VAR 0 1
58612: PPUSH
58613: CALL_OW 74
58617: ST_TO_ADDR
// if tmp then
58618: LD_VAR 0 5
58622: IFFALSE 58638
// ComStandNearbyBuilding ( ape , tmp ) ;
58624: LD_VAR 0 1
58628: PPUSH
58629: LD_VAR 0 5
58633: PPUSH
58634: CALL 64344 0 2
// break ;
58638: GO 58642
// end ; end ;
58640: GO 58494
58642: POP
58643: POP
// end ;
58644: LD_VAR 0 3
58648: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
58649: LD_INT 0
58651: PPUSH
58652: PPUSH
58653: PPUSH
// if not mc_bases or not skirmish then
58654: LD_EXP 99
58658: NOT
58659: PUSH
58660: LD_EXP 97
58664: NOT
58665: OR
58666: IFFALSE 58670
// exit ;
58668: GO 58759
// for i = 1 to mc_bases do
58670: LD_ADDR_VAR 0 4
58674: PUSH
58675: DOUBLE
58676: LD_INT 1
58678: DEC
58679: ST_TO_ADDR
58680: LD_EXP 99
58684: PUSH
58685: FOR_TO
58686: IFFALSE 58757
// begin if building in mc_busy_turret_list [ i ] then
58688: LD_VAR 0 1
58692: PUSH
58693: LD_EXP 109
58697: PUSH
58698: LD_VAR 0 4
58702: ARRAY
58703: IN
58704: IFFALSE 58755
// begin tmp := mc_busy_turret_list [ i ] diff building ;
58706: LD_ADDR_VAR 0 5
58710: PUSH
58711: LD_EXP 109
58715: PUSH
58716: LD_VAR 0 4
58720: ARRAY
58721: PUSH
58722: LD_VAR 0 1
58726: DIFF
58727: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
58728: LD_ADDR_EXP 109
58732: PUSH
58733: LD_EXP 109
58737: PPUSH
58738: LD_VAR 0 4
58742: PPUSH
58743: LD_VAR 0 5
58747: PPUSH
58748: CALL_OW 1
58752: ST_TO_ADDR
// break ;
58753: GO 58757
// end ; end ;
58755: GO 58685
58757: POP
58758: POP
// end ;
58759: LD_VAR 0 3
58763: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
58764: LD_INT 0
58766: PPUSH
58767: PPUSH
58768: PPUSH
// if not mc_bases or not skirmish then
58769: LD_EXP 99
58773: NOT
58774: PUSH
58775: LD_EXP 97
58779: NOT
58780: OR
58781: IFFALSE 58785
// exit ;
58783: GO 58984
// for i = 1 to mc_bases do
58785: LD_ADDR_VAR 0 5
58789: PUSH
58790: DOUBLE
58791: LD_INT 1
58793: DEC
58794: ST_TO_ADDR
58795: LD_EXP 99
58799: PUSH
58800: FOR_TO
58801: IFFALSE 58982
// if building in mc_bases [ i ] then
58803: LD_VAR 0 1
58807: PUSH
58808: LD_EXP 99
58812: PUSH
58813: LD_VAR 0 5
58817: ARRAY
58818: IN
58819: IFFALSE 58980
// begin tmp := mc_bases [ i ] diff building ;
58821: LD_ADDR_VAR 0 6
58825: PUSH
58826: LD_EXP 99
58830: PUSH
58831: LD_VAR 0 5
58835: ARRAY
58836: PUSH
58837: LD_VAR 0 1
58841: DIFF
58842: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
58843: LD_ADDR_EXP 99
58847: PUSH
58848: LD_EXP 99
58852: PPUSH
58853: LD_VAR 0 5
58857: PPUSH
58858: LD_VAR 0 6
58862: PPUSH
58863: CALL_OW 1
58867: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
58868: LD_VAR 0 1
58872: PUSH
58873: LD_EXP 107
58877: PUSH
58878: LD_VAR 0 5
58882: ARRAY
58883: IN
58884: IFFALSE 58923
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
58886: LD_ADDR_EXP 107
58890: PUSH
58891: LD_EXP 107
58895: PPUSH
58896: LD_VAR 0 5
58900: PPUSH
58901: LD_EXP 107
58905: PUSH
58906: LD_VAR 0 5
58910: ARRAY
58911: PUSH
58912: LD_VAR 0 1
58916: DIFF
58917: PPUSH
58918: CALL_OW 1
58922: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58923: LD_VAR 0 1
58927: PUSH
58928: LD_EXP 108
58932: PUSH
58933: LD_VAR 0 5
58937: ARRAY
58938: IN
58939: IFFALSE 58978
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
58941: LD_ADDR_EXP 108
58945: PUSH
58946: LD_EXP 108
58950: PPUSH
58951: LD_VAR 0 5
58955: PPUSH
58956: LD_EXP 108
58960: PUSH
58961: LD_VAR 0 5
58965: ARRAY
58966: PUSH
58967: LD_VAR 0 1
58971: DIFF
58972: PPUSH
58973: CALL_OW 1
58977: ST_TO_ADDR
// break ;
58978: GO 58982
// end ;
58980: GO 58800
58982: POP
58983: POP
// end ;
58984: LD_VAR 0 4
58988: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
58989: LD_INT 0
58991: PPUSH
58992: PPUSH
58993: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
58994: LD_EXP 99
58998: NOT
58999: PUSH
59000: LD_EXP 97
59004: NOT
59005: OR
59006: PUSH
59007: LD_VAR 0 3
59011: PUSH
59012: LD_EXP 125
59016: IN
59017: NOT
59018: OR
59019: IFFALSE 59023
// exit ;
59021: GO 59146
// for i = 1 to mc_vehicles do
59023: LD_ADDR_VAR 0 6
59027: PUSH
59028: DOUBLE
59029: LD_INT 1
59031: DEC
59032: ST_TO_ADDR
59033: LD_EXP 118
59037: PUSH
59038: FOR_TO
59039: IFFALSE 59144
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59041: LD_VAR 0 2
59045: PUSH
59046: LD_EXP 118
59050: PUSH
59051: LD_VAR 0 6
59055: ARRAY
59056: IN
59057: PUSH
59058: LD_VAR 0 1
59062: PUSH
59063: LD_EXP 118
59067: PUSH
59068: LD_VAR 0 6
59072: ARRAY
59073: IN
59074: OR
59075: IFFALSE 59142
// begin tmp := mc_vehicles [ i ] diff old ;
59077: LD_ADDR_VAR 0 7
59081: PUSH
59082: LD_EXP 118
59086: PUSH
59087: LD_VAR 0 6
59091: ARRAY
59092: PUSH
59093: LD_VAR 0 2
59097: DIFF
59098: ST_TO_ADDR
// tmp := tmp diff new ;
59099: LD_ADDR_VAR 0 7
59103: PUSH
59104: LD_VAR 0 7
59108: PUSH
59109: LD_VAR 0 1
59113: DIFF
59114: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59115: LD_ADDR_EXP 118
59119: PUSH
59120: LD_EXP 118
59124: PPUSH
59125: LD_VAR 0 6
59129: PPUSH
59130: LD_VAR 0 7
59134: PPUSH
59135: CALL_OW 1
59139: ST_TO_ADDR
// break ;
59140: GO 59144
// end ;
59142: GO 59038
59144: POP
59145: POP
// end ;
59146: LD_VAR 0 5
59150: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59151: LD_INT 0
59153: PPUSH
59154: PPUSH
59155: PPUSH
59156: PPUSH
// if not mc_bases or not skirmish then
59157: LD_EXP 99
59161: NOT
59162: PUSH
59163: LD_EXP 97
59167: NOT
59168: OR
59169: IFFALSE 59173
// exit ;
59171: GO 59550
// side := GetSide ( vehicle ) ;
59173: LD_ADDR_VAR 0 5
59177: PUSH
59178: LD_VAR 0 1
59182: PPUSH
59183: CALL_OW 255
59187: ST_TO_ADDR
// for i = 1 to mc_bases do
59188: LD_ADDR_VAR 0 4
59192: PUSH
59193: DOUBLE
59194: LD_INT 1
59196: DEC
59197: ST_TO_ADDR
59198: LD_EXP 99
59202: PUSH
59203: FOR_TO
59204: IFFALSE 59548
// begin if factory in mc_bases [ i ] then
59206: LD_VAR 0 2
59210: PUSH
59211: LD_EXP 99
59215: PUSH
59216: LD_VAR 0 4
59220: ARRAY
59221: IN
59222: IFFALSE 59546
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59224: LD_EXP 121
59228: PUSH
59229: LD_VAR 0 4
59233: ARRAY
59234: PUSH
59235: LD_EXP 110
59239: PUSH
59240: LD_VAR 0 4
59244: ARRAY
59245: LESS
59246: PUSH
59247: LD_VAR 0 1
59251: PPUSH
59252: CALL_OW 264
59256: PUSH
59257: LD_INT 31
59259: PUSH
59260: LD_INT 32
59262: PUSH
59263: LD_INT 51
59265: PUSH
59266: LD_EXP 93
59270: PUSH
59271: LD_INT 12
59273: PUSH
59274: LD_INT 30
59276: PUSH
59277: LD_EXP 92
59281: PUSH
59282: LD_INT 11
59284: PUSH
59285: LD_INT 53
59287: PUSH
59288: LD_INT 14
59290: PUSH
59291: LD_EXP 96
59295: PUSH
59296: LD_INT 29
59298: PUSH
59299: LD_EXP 94
59303: PUSH
59304: LD_INT 13
59306: PUSH
59307: LD_INT 52
59309: PUSH
59310: LD_INT 48
59312: PUSH
59313: LD_INT 8
59315: PUSH
59316: EMPTY
59317: LIST
59318: LIST
59319: LIST
59320: LIST
59321: LIST
59322: LIST
59323: LIST
59324: LIST
59325: LIST
59326: LIST
59327: LIST
59328: LIST
59329: LIST
59330: LIST
59331: LIST
59332: LIST
59333: LIST
59334: IN
59335: NOT
59336: AND
59337: IFFALSE 59385
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59339: LD_ADDR_EXP 121
59343: PUSH
59344: LD_EXP 121
59348: PPUSH
59349: LD_VAR 0 4
59353: PUSH
59354: LD_EXP 121
59358: PUSH
59359: LD_VAR 0 4
59363: ARRAY
59364: PUSH
59365: LD_INT 1
59367: PLUS
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PPUSH
59373: LD_VAR 0 1
59377: PPUSH
59378: CALL 69637 0 3
59382: ST_TO_ADDR
59383: GO 59429
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59385: LD_ADDR_EXP 118
59389: PUSH
59390: LD_EXP 118
59394: PPUSH
59395: LD_VAR 0 4
59399: PUSH
59400: LD_EXP 118
59404: PUSH
59405: LD_VAR 0 4
59409: ARRAY
59410: PUSH
59411: LD_INT 1
59413: PLUS
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PPUSH
59419: LD_VAR 0 1
59423: PPUSH
59424: CALL 69637 0 3
59428: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59429: LD_VAR 0 1
59433: PPUSH
59434: CALL_OW 263
59438: PUSH
59439: LD_INT 2
59441: EQUAL
59442: IFFALSE 59462
// begin repeat wait ( 0 0$1 ) ;
59444: LD_INT 35
59446: PPUSH
59447: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59451: LD_VAR 0 1
59455: PPUSH
59456: CALL_OW 312
59460: IFFALSE 59444
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59462: LD_VAR 0 1
59466: PPUSH
59467: LD_EXP 123
59471: PUSH
59472: LD_VAR 0 4
59476: ARRAY
59477: PPUSH
59478: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
59482: LD_VAR 0 1
59486: PPUSH
59487: CALL_OW 263
59491: PUSH
59492: LD_INT 1
59494: NONEQUAL
59495: IFFALSE 59499
// break ;
59497: GO 59548
// repeat wait ( 0 0$1 ) ;
59499: LD_INT 35
59501: PPUSH
59502: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
59506: LD_VAR 0 1
59510: PPUSH
59511: LD_EXP 123
59515: PUSH
59516: LD_VAR 0 4
59520: ARRAY
59521: PPUSH
59522: CALL_OW 308
59526: IFFALSE 59499
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
59528: LD_VAR 0 1
59532: PPUSH
59533: CALL_OW 311
59537: PPUSH
59538: CALL_OW 121
// exit ;
59542: POP
59543: POP
59544: GO 59550
// end ; end ;
59546: GO 59203
59548: POP
59549: POP
// end ;
59550: LD_VAR 0 3
59554: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
59555: LD_INT 0
59557: PPUSH
59558: PPUSH
59559: PPUSH
59560: PPUSH
// if not mc_bases or not skirmish then
59561: LD_EXP 99
59565: NOT
59566: PUSH
59567: LD_EXP 97
59571: NOT
59572: OR
59573: IFFALSE 59577
// exit ;
59575: GO 59930
// repeat wait ( 0 0$1 ) ;
59577: LD_INT 35
59579: PPUSH
59580: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
59584: LD_VAR 0 2
59588: PPUSH
59589: LD_VAR 0 3
59593: PPUSH
59594: CALL_OW 284
59598: IFFALSE 59577
// if GetResourceTypeXY ( x , y ) = mat_artefact then
59600: LD_VAR 0 2
59604: PPUSH
59605: LD_VAR 0 3
59609: PPUSH
59610: CALL_OW 283
59614: PUSH
59615: LD_INT 4
59617: EQUAL
59618: IFFALSE 59622
// exit ;
59620: GO 59930
// for i = 1 to mc_bases do
59622: LD_ADDR_VAR 0 7
59626: PUSH
59627: DOUBLE
59628: LD_INT 1
59630: DEC
59631: ST_TO_ADDR
59632: LD_EXP 99
59636: PUSH
59637: FOR_TO
59638: IFFALSE 59928
// begin if mc_crates_area [ i ] then
59640: LD_EXP 117
59644: PUSH
59645: LD_VAR 0 7
59649: ARRAY
59650: IFFALSE 59761
// for j in mc_crates_area [ i ] do
59652: LD_ADDR_VAR 0 8
59656: PUSH
59657: LD_EXP 117
59661: PUSH
59662: LD_VAR 0 7
59666: ARRAY
59667: PUSH
59668: FOR_IN
59669: IFFALSE 59759
// if InArea ( x , y , j ) then
59671: LD_VAR 0 2
59675: PPUSH
59676: LD_VAR 0 3
59680: PPUSH
59681: LD_VAR 0 8
59685: PPUSH
59686: CALL_OW 309
59690: IFFALSE 59757
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59692: LD_ADDR_EXP 115
59696: PUSH
59697: LD_EXP 115
59701: PPUSH
59702: LD_VAR 0 7
59706: PUSH
59707: LD_EXP 115
59711: PUSH
59712: LD_VAR 0 7
59716: ARRAY
59717: PUSH
59718: LD_INT 1
59720: PLUS
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: PPUSH
59726: LD_VAR 0 4
59730: PUSH
59731: LD_VAR 0 2
59735: PUSH
59736: LD_VAR 0 3
59740: PUSH
59741: EMPTY
59742: LIST
59743: LIST
59744: LIST
59745: PPUSH
59746: CALL 69637 0 3
59750: ST_TO_ADDR
// exit ;
59751: POP
59752: POP
59753: POP
59754: POP
59755: GO 59930
// end ;
59757: GO 59668
59759: POP
59760: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59761: LD_ADDR_VAR 0 9
59765: PUSH
59766: LD_EXP 99
59770: PUSH
59771: LD_VAR 0 7
59775: ARRAY
59776: PPUSH
59777: LD_INT 2
59779: PUSH
59780: LD_INT 30
59782: PUSH
59783: LD_INT 0
59785: PUSH
59786: EMPTY
59787: LIST
59788: LIST
59789: PUSH
59790: LD_INT 30
59792: PUSH
59793: LD_INT 1
59795: PUSH
59796: EMPTY
59797: LIST
59798: LIST
59799: PUSH
59800: EMPTY
59801: LIST
59802: LIST
59803: LIST
59804: PPUSH
59805: CALL_OW 72
59809: ST_TO_ADDR
// if not depot then
59810: LD_VAR 0 9
59814: NOT
59815: IFFALSE 59819
// continue ;
59817: GO 59637
// for j in depot do
59819: LD_ADDR_VAR 0 8
59823: PUSH
59824: LD_VAR 0 9
59828: PUSH
59829: FOR_IN
59830: IFFALSE 59924
// if GetDistUnitXY ( j , x , y ) < 30 then
59832: LD_VAR 0 8
59836: PPUSH
59837: LD_VAR 0 2
59841: PPUSH
59842: LD_VAR 0 3
59846: PPUSH
59847: CALL_OW 297
59851: PUSH
59852: LD_INT 30
59854: LESS
59855: IFFALSE 59922
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59857: LD_ADDR_EXP 115
59861: PUSH
59862: LD_EXP 115
59866: PPUSH
59867: LD_VAR 0 7
59871: PUSH
59872: LD_EXP 115
59876: PUSH
59877: LD_VAR 0 7
59881: ARRAY
59882: PUSH
59883: LD_INT 1
59885: PLUS
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PPUSH
59891: LD_VAR 0 4
59895: PUSH
59896: LD_VAR 0 2
59900: PUSH
59901: LD_VAR 0 3
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: LIST
59910: PPUSH
59911: CALL 69637 0 3
59915: ST_TO_ADDR
// exit ;
59916: POP
59917: POP
59918: POP
59919: POP
59920: GO 59930
// end ;
59922: GO 59829
59924: POP
59925: POP
// end ;
59926: GO 59637
59928: POP
59929: POP
// end ;
59930: LD_VAR 0 6
59934: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59935: LD_INT 0
59937: PPUSH
59938: PPUSH
59939: PPUSH
59940: PPUSH
// if not mc_bases or not skirmish then
59941: LD_EXP 99
59945: NOT
59946: PUSH
59947: LD_EXP 97
59951: NOT
59952: OR
59953: IFFALSE 59957
// exit ;
59955: GO 60234
// side := GetSide ( lab ) ;
59957: LD_ADDR_VAR 0 4
59961: PUSH
59962: LD_VAR 0 2
59966: PPUSH
59967: CALL_OW 255
59971: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
59972: LD_VAR 0 4
59976: PUSH
59977: LD_EXP 125
59981: IN
59982: NOT
59983: PUSH
59984: LD_EXP 126
59988: NOT
59989: OR
59990: PUSH
59991: LD_EXP 99
59995: NOT
59996: OR
59997: IFFALSE 60001
// exit ;
59999: GO 60234
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60001: LD_ADDR_EXP 126
60005: PUSH
60006: LD_EXP 126
60010: PPUSH
60011: LD_VAR 0 4
60015: PPUSH
60016: LD_EXP 126
60020: PUSH
60021: LD_VAR 0 4
60025: ARRAY
60026: PUSH
60027: LD_VAR 0 1
60031: DIFF
60032: PPUSH
60033: CALL_OW 1
60037: ST_TO_ADDR
// for i = 1 to mc_bases do
60038: LD_ADDR_VAR 0 5
60042: PUSH
60043: DOUBLE
60044: LD_INT 1
60046: DEC
60047: ST_TO_ADDR
60048: LD_EXP 99
60052: PUSH
60053: FOR_TO
60054: IFFALSE 60232
// begin if lab in mc_bases [ i ] then
60056: LD_VAR 0 2
60060: PUSH
60061: LD_EXP 99
60065: PUSH
60066: LD_VAR 0 5
60070: ARRAY
60071: IN
60072: IFFALSE 60230
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60074: LD_VAR 0 1
60078: PUSH
60079: LD_INT 11
60081: PUSH
60082: LD_INT 4
60084: PUSH
60085: LD_INT 3
60087: PUSH
60088: LD_INT 2
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: LIST
60095: LIST
60096: IN
60097: PUSH
60098: LD_EXP 129
60102: PUSH
60103: LD_VAR 0 5
60107: ARRAY
60108: AND
60109: IFFALSE 60230
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60111: LD_ADDR_VAR 0 6
60115: PUSH
60116: LD_EXP 129
60120: PUSH
60121: LD_VAR 0 5
60125: ARRAY
60126: PUSH
60127: LD_INT 1
60129: ARRAY
60130: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60131: LD_ADDR_EXP 129
60135: PUSH
60136: LD_EXP 129
60140: PPUSH
60141: LD_VAR 0 5
60145: PPUSH
60146: EMPTY
60147: PPUSH
60148: CALL_OW 1
60152: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60153: LD_VAR 0 6
60157: PPUSH
60158: LD_INT 0
60160: PPUSH
60161: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60165: LD_VAR 0 6
60169: PPUSH
60170: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60174: LD_ADDR_EXP 128
60178: PUSH
60179: LD_EXP 128
60183: PPUSH
60184: LD_VAR 0 5
60188: PPUSH
60189: LD_EXP 128
60193: PUSH
60194: LD_VAR 0 5
60198: ARRAY
60199: PPUSH
60200: LD_INT 1
60202: PPUSH
60203: LD_VAR 0 6
60207: PPUSH
60208: CALL_OW 2
60212: PPUSH
60213: CALL_OW 1
60217: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60218: LD_VAR 0 5
60222: PPUSH
60223: LD_INT 112
60225: PPUSH
60226: CALL 37767 0 2
// end ; end ; end ;
60230: GO 60053
60232: POP
60233: POP
// end ;
60234: LD_VAR 0 3
60238: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60239: LD_INT 0
60241: PPUSH
60242: PPUSH
60243: PPUSH
60244: PPUSH
60245: PPUSH
60246: PPUSH
60247: PPUSH
60248: PPUSH
// if not mc_bases or not skirmish then
60249: LD_EXP 99
60253: NOT
60254: PUSH
60255: LD_EXP 97
60259: NOT
60260: OR
60261: IFFALSE 60265
// exit ;
60263: GO 61357
// for i = 1 to mc_bases do
60265: LD_ADDR_VAR 0 3
60269: PUSH
60270: DOUBLE
60271: LD_INT 1
60273: DEC
60274: ST_TO_ADDR
60275: LD_EXP 99
60279: PUSH
60280: FOR_TO
60281: IFFALSE 61355
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60283: LD_VAR 0 1
60287: PUSH
60288: LD_EXP 99
60292: PUSH
60293: LD_VAR 0 3
60297: ARRAY
60298: IN
60299: PUSH
60300: LD_VAR 0 1
60304: PUSH
60305: LD_EXP 106
60309: PUSH
60310: LD_VAR 0 3
60314: ARRAY
60315: IN
60316: OR
60317: PUSH
60318: LD_VAR 0 1
60322: PUSH
60323: LD_EXP 121
60327: PUSH
60328: LD_VAR 0 3
60332: ARRAY
60333: IN
60334: OR
60335: PUSH
60336: LD_VAR 0 1
60340: PUSH
60341: LD_EXP 118
60345: PUSH
60346: LD_VAR 0 3
60350: ARRAY
60351: IN
60352: OR
60353: PUSH
60354: LD_VAR 0 1
60358: PUSH
60359: LD_EXP 128
60363: PUSH
60364: LD_VAR 0 3
60368: ARRAY
60369: IN
60370: OR
60371: PUSH
60372: LD_VAR 0 1
60376: PUSH
60377: LD_EXP 129
60381: PUSH
60382: LD_VAR 0 3
60386: ARRAY
60387: IN
60388: OR
60389: IFFALSE 61353
// begin if un in mc_ape [ i ] then
60391: LD_VAR 0 1
60395: PUSH
60396: LD_EXP 128
60400: PUSH
60401: LD_VAR 0 3
60405: ARRAY
60406: IN
60407: IFFALSE 60446
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60409: LD_ADDR_EXP 128
60413: PUSH
60414: LD_EXP 128
60418: PPUSH
60419: LD_VAR 0 3
60423: PPUSH
60424: LD_EXP 128
60428: PUSH
60429: LD_VAR 0 3
60433: ARRAY
60434: PUSH
60435: LD_VAR 0 1
60439: DIFF
60440: PPUSH
60441: CALL_OW 1
60445: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60446: LD_VAR 0 1
60450: PUSH
60451: LD_EXP 129
60455: PUSH
60456: LD_VAR 0 3
60460: ARRAY
60461: IN
60462: IFFALSE 60486
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60464: LD_ADDR_EXP 129
60468: PUSH
60469: LD_EXP 129
60473: PPUSH
60474: LD_VAR 0 3
60478: PPUSH
60479: EMPTY
60480: PPUSH
60481: CALL_OW 1
60485: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
60486: LD_VAR 0 1
60490: PPUSH
60491: CALL_OW 247
60495: PUSH
60496: LD_INT 2
60498: EQUAL
60499: PUSH
60500: LD_VAR 0 1
60504: PPUSH
60505: CALL_OW 110
60509: PUSH
60510: LD_INT 20
60512: EQUAL
60513: PUSH
60514: LD_VAR 0 1
60518: PUSH
60519: LD_EXP 121
60523: PUSH
60524: LD_VAR 0 3
60528: ARRAY
60529: IN
60530: OR
60531: AND
60532: IFFALSE 60693
// begin if un in mc_defender [ i ] then
60534: LD_VAR 0 1
60538: PUSH
60539: LD_EXP 121
60543: PUSH
60544: LD_VAR 0 3
60548: ARRAY
60549: IN
60550: IFFALSE 60589
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
60552: LD_ADDR_EXP 121
60556: PUSH
60557: LD_EXP 121
60561: PPUSH
60562: LD_VAR 0 3
60566: PPUSH
60567: LD_EXP 121
60571: PUSH
60572: LD_VAR 0 3
60576: ARRAY
60577: PUSH
60578: LD_VAR 0 1
60582: DIFF
60583: PPUSH
60584: CALL_OW 1
60588: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
60589: LD_ADDR_VAR 0 8
60593: PUSH
60594: LD_VAR 0 3
60598: PPUSH
60599: LD_INT 3
60601: PPUSH
60602: CALL 57282 0 2
60606: ST_TO_ADDR
// if fac then
60607: LD_VAR 0 8
60611: IFFALSE 60693
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
60613: LD_ADDR_VAR 0 9
60617: PUSH
60618: LD_VAR 0 8
60622: PPUSH
60623: LD_VAR 0 1
60627: PPUSH
60628: CALL_OW 265
60632: PPUSH
60633: LD_VAR 0 1
60637: PPUSH
60638: CALL_OW 262
60642: PPUSH
60643: LD_VAR 0 1
60647: PPUSH
60648: CALL_OW 263
60652: PPUSH
60653: LD_VAR 0 1
60657: PPUSH
60658: CALL_OW 264
60662: PPUSH
60663: CALL 67230 0 5
60667: ST_TO_ADDR
// if components then
60668: LD_VAR 0 9
60672: IFFALSE 60691
// MC_InsertProduceList ( i , [ components ] ) ;
60674: LD_VAR 0 3
60678: PPUSH
60679: LD_VAR 0 9
60683: PUSH
60684: EMPTY
60685: LIST
60686: PPUSH
60687: CALL 56910 0 2
// break ;
60691: GO 61355
// end ; end ; if GetType ( un ) = unit_building then
60693: LD_VAR 0 1
60697: PPUSH
60698: CALL_OW 247
60702: PUSH
60703: LD_INT 3
60705: EQUAL
60706: IFFALSE 61021
// begin btype := GetBType ( un ) ;
60708: LD_ADDR_VAR 0 5
60712: PUSH
60713: LD_VAR 0 1
60717: PPUSH
60718: CALL_OW 266
60722: ST_TO_ADDR
// if btype = b_warehouse then
60723: LD_VAR 0 5
60727: PUSH
60728: LD_INT 1
60730: EQUAL
60731: IFFALSE 60749
// begin btype := b_depot ;
60733: LD_ADDR_VAR 0 5
60737: PUSH
60738: LD_INT 0
60740: ST_TO_ADDR
// pos := 1 ;
60741: LD_ADDR_VAR 0 6
60745: PUSH
60746: LD_INT 1
60748: ST_TO_ADDR
// end ; if btype = b_factory then
60749: LD_VAR 0 5
60753: PUSH
60754: LD_INT 3
60756: EQUAL
60757: IFFALSE 60775
// begin btype := b_workshop ;
60759: LD_ADDR_VAR 0 5
60763: PUSH
60764: LD_INT 2
60766: ST_TO_ADDR
// pos := 1 ;
60767: LD_ADDR_VAR 0 6
60771: PUSH
60772: LD_INT 1
60774: ST_TO_ADDR
// end ; if btype = b_barracks then
60775: LD_VAR 0 5
60779: PUSH
60780: LD_INT 5
60782: EQUAL
60783: IFFALSE 60793
// btype := b_armoury ;
60785: LD_ADDR_VAR 0 5
60789: PUSH
60790: LD_INT 4
60792: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
60793: LD_VAR 0 5
60797: PUSH
60798: LD_INT 7
60800: PUSH
60801: LD_INT 8
60803: PUSH
60804: EMPTY
60805: LIST
60806: LIST
60807: IN
60808: IFFALSE 60818
// btype := b_lab ;
60810: LD_ADDR_VAR 0 5
60814: PUSH
60815: LD_INT 6
60817: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
60818: LD_ADDR_EXP 104
60822: PUSH
60823: LD_EXP 104
60827: PPUSH
60828: LD_VAR 0 3
60832: PUSH
60833: LD_EXP 104
60837: PUSH
60838: LD_VAR 0 3
60842: ARRAY
60843: PUSH
60844: LD_INT 1
60846: PLUS
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PPUSH
60852: LD_VAR 0 5
60856: PUSH
60857: LD_VAR 0 1
60861: PPUSH
60862: CALL_OW 250
60866: PUSH
60867: LD_VAR 0 1
60871: PPUSH
60872: CALL_OW 251
60876: PUSH
60877: LD_VAR 0 1
60881: PPUSH
60882: CALL_OW 254
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: LIST
60891: LIST
60892: PPUSH
60893: CALL 69637 0 3
60897: ST_TO_ADDR
// if pos = 1 then
60898: LD_VAR 0 6
60902: PUSH
60903: LD_INT 1
60905: EQUAL
60906: IFFALSE 61021
// begin tmp := mc_build_list [ i ] ;
60908: LD_ADDR_VAR 0 7
60912: PUSH
60913: LD_EXP 104
60917: PUSH
60918: LD_VAR 0 3
60922: ARRAY
60923: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60924: LD_VAR 0 7
60928: PPUSH
60929: LD_INT 2
60931: PUSH
60932: LD_INT 30
60934: PUSH
60935: LD_INT 0
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 30
60944: PUSH
60945: LD_INT 1
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: LIST
60956: PPUSH
60957: CALL_OW 72
60961: IFFALSE 60971
// pos := 2 ;
60963: LD_ADDR_VAR 0 6
60967: PUSH
60968: LD_INT 2
60970: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
60971: LD_ADDR_VAR 0 7
60975: PUSH
60976: LD_VAR 0 7
60980: PPUSH
60981: LD_VAR 0 6
60985: PPUSH
60986: LD_VAR 0 7
60990: PPUSH
60991: CALL 69963 0 3
60995: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
60996: LD_ADDR_EXP 104
61000: PUSH
61001: LD_EXP 104
61005: PPUSH
61006: LD_VAR 0 3
61010: PPUSH
61011: LD_VAR 0 7
61015: PPUSH
61016: CALL_OW 1
61020: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61021: LD_VAR 0 1
61025: PUSH
61026: LD_EXP 99
61030: PUSH
61031: LD_VAR 0 3
61035: ARRAY
61036: IN
61037: IFFALSE 61076
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61039: LD_ADDR_EXP 99
61043: PUSH
61044: LD_EXP 99
61048: PPUSH
61049: LD_VAR 0 3
61053: PPUSH
61054: LD_EXP 99
61058: PUSH
61059: LD_VAR 0 3
61063: ARRAY
61064: PUSH
61065: LD_VAR 0 1
61069: DIFF
61070: PPUSH
61071: CALL_OW 1
61075: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61076: LD_VAR 0 1
61080: PUSH
61081: LD_EXP 106
61085: PUSH
61086: LD_VAR 0 3
61090: ARRAY
61091: IN
61092: IFFALSE 61131
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61094: LD_ADDR_EXP 106
61098: PUSH
61099: LD_EXP 106
61103: PPUSH
61104: LD_VAR 0 3
61108: PPUSH
61109: LD_EXP 106
61113: PUSH
61114: LD_VAR 0 3
61118: ARRAY
61119: PUSH
61120: LD_VAR 0 1
61124: DIFF
61125: PPUSH
61126: CALL_OW 1
61130: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61131: LD_VAR 0 1
61135: PUSH
61136: LD_EXP 118
61140: PUSH
61141: LD_VAR 0 3
61145: ARRAY
61146: IN
61147: IFFALSE 61186
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61149: LD_ADDR_EXP 118
61153: PUSH
61154: LD_EXP 118
61158: PPUSH
61159: LD_VAR 0 3
61163: PPUSH
61164: LD_EXP 118
61168: PUSH
61169: LD_VAR 0 3
61173: ARRAY
61174: PUSH
61175: LD_VAR 0 1
61179: DIFF
61180: PPUSH
61181: CALL_OW 1
61185: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61186: LD_VAR 0 1
61190: PUSH
61191: LD_EXP 121
61195: PUSH
61196: LD_VAR 0 3
61200: ARRAY
61201: IN
61202: IFFALSE 61241
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61204: LD_ADDR_EXP 121
61208: PUSH
61209: LD_EXP 121
61213: PPUSH
61214: LD_VAR 0 3
61218: PPUSH
61219: LD_EXP 121
61223: PUSH
61224: LD_VAR 0 3
61228: ARRAY
61229: PUSH
61230: LD_VAR 0 1
61234: DIFF
61235: PPUSH
61236: CALL_OW 1
61240: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61241: LD_VAR 0 1
61245: PUSH
61246: LD_EXP 108
61250: PUSH
61251: LD_VAR 0 3
61255: ARRAY
61256: IN
61257: IFFALSE 61296
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61259: LD_ADDR_EXP 108
61263: PUSH
61264: LD_EXP 108
61268: PPUSH
61269: LD_VAR 0 3
61273: PPUSH
61274: LD_EXP 108
61278: PUSH
61279: LD_VAR 0 3
61283: ARRAY
61284: PUSH
61285: LD_VAR 0 1
61289: DIFF
61290: PPUSH
61291: CALL_OW 1
61295: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61296: LD_VAR 0 1
61300: PUSH
61301: LD_EXP 107
61305: PUSH
61306: LD_VAR 0 3
61310: ARRAY
61311: IN
61312: IFFALSE 61351
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61314: LD_ADDR_EXP 107
61318: PUSH
61319: LD_EXP 107
61323: PPUSH
61324: LD_VAR 0 3
61328: PPUSH
61329: LD_EXP 107
61333: PUSH
61334: LD_VAR 0 3
61338: ARRAY
61339: PUSH
61340: LD_VAR 0 1
61344: DIFF
61345: PPUSH
61346: CALL_OW 1
61350: ST_TO_ADDR
// end ; break ;
61351: GO 61355
// end ;
61353: GO 60280
61355: POP
61356: POP
// end ;
61357: LD_VAR 0 2
61361: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61362: LD_INT 0
61364: PPUSH
61365: PPUSH
61366: PPUSH
// if not mc_bases or not skirmish then
61367: LD_EXP 99
61371: NOT
61372: PUSH
61373: LD_EXP 97
61377: NOT
61378: OR
61379: IFFALSE 61383
// exit ;
61381: GO 61598
// for i = 1 to mc_bases do
61383: LD_ADDR_VAR 0 3
61387: PUSH
61388: DOUBLE
61389: LD_INT 1
61391: DEC
61392: ST_TO_ADDR
61393: LD_EXP 99
61397: PUSH
61398: FOR_TO
61399: IFFALSE 61596
// begin if building in mc_construct_list [ i ] then
61401: LD_VAR 0 1
61405: PUSH
61406: LD_EXP 106
61410: PUSH
61411: LD_VAR 0 3
61415: ARRAY
61416: IN
61417: IFFALSE 61594
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61419: LD_ADDR_EXP 106
61423: PUSH
61424: LD_EXP 106
61428: PPUSH
61429: LD_VAR 0 3
61433: PPUSH
61434: LD_EXP 106
61438: PUSH
61439: LD_VAR 0 3
61443: ARRAY
61444: PUSH
61445: LD_VAR 0 1
61449: DIFF
61450: PPUSH
61451: CALL_OW 1
61455: ST_TO_ADDR
// if building in mc_lab [ i ] then
61456: LD_VAR 0 1
61460: PUSH
61461: LD_EXP 132
61465: PUSH
61466: LD_VAR 0 3
61470: ARRAY
61471: IN
61472: IFFALSE 61527
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
61474: LD_ADDR_EXP 133
61478: PUSH
61479: LD_EXP 133
61483: PPUSH
61484: LD_VAR 0 3
61488: PPUSH
61489: LD_EXP 133
61493: PUSH
61494: LD_VAR 0 3
61498: ARRAY
61499: PPUSH
61500: LD_INT 1
61502: PPUSH
61503: LD_EXP 133
61507: PUSH
61508: LD_VAR 0 3
61512: ARRAY
61513: PPUSH
61514: LD_INT 0
61516: PPUSH
61517: CALL 69055 0 4
61521: PPUSH
61522: CALL_OW 1
61526: ST_TO_ADDR
// if not building in mc_bases [ i ] then
61527: LD_VAR 0 1
61531: PUSH
61532: LD_EXP 99
61536: PUSH
61537: LD_VAR 0 3
61541: ARRAY
61542: IN
61543: NOT
61544: IFFALSE 61590
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61546: LD_ADDR_EXP 99
61550: PUSH
61551: LD_EXP 99
61555: PPUSH
61556: LD_VAR 0 3
61560: PUSH
61561: LD_EXP 99
61565: PUSH
61566: LD_VAR 0 3
61570: ARRAY
61571: PUSH
61572: LD_INT 1
61574: PLUS
61575: PUSH
61576: EMPTY
61577: LIST
61578: LIST
61579: PPUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: CALL 69637 0 3
61589: ST_TO_ADDR
// exit ;
61590: POP
61591: POP
61592: GO 61598
// end ; end ;
61594: GO 61398
61596: POP
61597: POP
// end ;
61598: LD_VAR 0 2
61602: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
61603: LD_INT 0
61605: PPUSH
61606: PPUSH
61607: PPUSH
61608: PPUSH
61609: PPUSH
61610: PPUSH
61611: PPUSH
// if not mc_bases or not skirmish then
61612: LD_EXP 99
61616: NOT
61617: PUSH
61618: LD_EXP 97
61622: NOT
61623: OR
61624: IFFALSE 61628
// exit ;
61626: GO 62289
// for i = 1 to mc_bases do
61628: LD_ADDR_VAR 0 3
61632: PUSH
61633: DOUBLE
61634: LD_INT 1
61636: DEC
61637: ST_TO_ADDR
61638: LD_EXP 99
61642: PUSH
61643: FOR_TO
61644: IFFALSE 62287
// begin if building in mc_construct_list [ i ] then
61646: LD_VAR 0 1
61650: PUSH
61651: LD_EXP 106
61655: PUSH
61656: LD_VAR 0 3
61660: ARRAY
61661: IN
61662: IFFALSE 62285
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61664: LD_ADDR_EXP 106
61668: PUSH
61669: LD_EXP 106
61673: PPUSH
61674: LD_VAR 0 3
61678: PPUSH
61679: LD_EXP 106
61683: PUSH
61684: LD_VAR 0 3
61688: ARRAY
61689: PUSH
61690: LD_VAR 0 1
61694: DIFF
61695: PPUSH
61696: CALL_OW 1
61700: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61701: LD_ADDR_EXP 99
61705: PUSH
61706: LD_EXP 99
61710: PPUSH
61711: LD_VAR 0 3
61715: PUSH
61716: LD_EXP 99
61720: PUSH
61721: LD_VAR 0 3
61725: ARRAY
61726: PUSH
61727: LD_INT 1
61729: PLUS
61730: PUSH
61731: EMPTY
61732: LIST
61733: LIST
61734: PPUSH
61735: LD_VAR 0 1
61739: PPUSH
61740: CALL 69637 0 3
61744: ST_TO_ADDR
// btype := GetBType ( building ) ;
61745: LD_ADDR_VAR 0 5
61749: PUSH
61750: LD_VAR 0 1
61754: PPUSH
61755: CALL_OW 266
61759: ST_TO_ADDR
// side := GetSide ( building ) ;
61760: LD_ADDR_VAR 0 8
61764: PUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: CALL_OW 255
61774: ST_TO_ADDR
// if btype = b_lab then
61775: LD_VAR 0 5
61779: PUSH
61780: LD_INT 6
61782: EQUAL
61783: IFFALSE 61833
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
61785: LD_ADDR_EXP 132
61789: PUSH
61790: LD_EXP 132
61794: PPUSH
61795: LD_VAR 0 3
61799: PUSH
61800: LD_EXP 132
61804: PUSH
61805: LD_VAR 0 3
61809: ARRAY
61810: PUSH
61811: LD_INT 1
61813: PLUS
61814: PUSH
61815: EMPTY
61816: LIST
61817: LIST
61818: PPUSH
61819: LD_VAR 0 1
61823: PPUSH
61824: CALL 69637 0 3
61828: ST_TO_ADDR
// exit ;
61829: POP
61830: POP
61831: GO 62289
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
61833: LD_VAR 0 5
61837: PUSH
61838: LD_INT 0
61840: PUSH
61841: LD_INT 2
61843: PUSH
61844: LD_INT 4
61846: PUSH
61847: EMPTY
61848: LIST
61849: LIST
61850: LIST
61851: IN
61852: IFFALSE 61976
// begin if btype = b_armoury then
61854: LD_VAR 0 5
61858: PUSH
61859: LD_INT 4
61861: EQUAL
61862: IFFALSE 61872
// btype := b_barracks ;
61864: LD_ADDR_VAR 0 5
61868: PUSH
61869: LD_INT 5
61871: ST_TO_ADDR
// if btype = b_depot then
61872: LD_VAR 0 5
61876: PUSH
61877: LD_INT 0
61879: EQUAL
61880: IFFALSE 61890
// btype := b_warehouse ;
61882: LD_ADDR_VAR 0 5
61886: PUSH
61887: LD_INT 1
61889: ST_TO_ADDR
// if btype = b_workshop then
61890: LD_VAR 0 5
61894: PUSH
61895: LD_INT 2
61897: EQUAL
61898: IFFALSE 61908
// btype := b_factory ;
61900: LD_ADDR_VAR 0 5
61904: PUSH
61905: LD_INT 3
61907: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
61908: LD_VAR 0 5
61912: PPUSH
61913: LD_VAR 0 8
61917: PPUSH
61918: CALL_OW 323
61922: PUSH
61923: LD_INT 1
61925: EQUAL
61926: IFFALSE 61972
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
61928: LD_ADDR_EXP 131
61932: PUSH
61933: LD_EXP 131
61937: PPUSH
61938: LD_VAR 0 3
61942: PUSH
61943: LD_EXP 131
61947: PUSH
61948: LD_VAR 0 3
61952: ARRAY
61953: PUSH
61954: LD_INT 1
61956: PLUS
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: LD_VAR 0 1
61966: PPUSH
61967: CALL 69637 0 3
61971: ST_TO_ADDR
// exit ;
61972: POP
61973: POP
61974: GO 62289
// end ; if btype in [ b_bunker , b_turret ] then
61976: LD_VAR 0 5
61980: PUSH
61981: LD_INT 32
61983: PUSH
61984: LD_INT 33
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: IN
61991: IFFALSE 62281
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
61993: LD_ADDR_EXP 107
61997: PUSH
61998: LD_EXP 107
62002: PPUSH
62003: LD_VAR 0 3
62007: PUSH
62008: LD_EXP 107
62012: PUSH
62013: LD_VAR 0 3
62017: ARRAY
62018: PUSH
62019: LD_INT 1
62021: PLUS
62022: PUSH
62023: EMPTY
62024: LIST
62025: LIST
62026: PPUSH
62027: LD_VAR 0 1
62031: PPUSH
62032: CALL 69637 0 3
62036: ST_TO_ADDR
// if btype = b_bunker then
62037: LD_VAR 0 5
62041: PUSH
62042: LD_INT 32
62044: EQUAL
62045: IFFALSE 62281
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62047: LD_ADDR_EXP 108
62051: PUSH
62052: LD_EXP 108
62056: PPUSH
62057: LD_VAR 0 3
62061: PUSH
62062: LD_EXP 108
62066: PUSH
62067: LD_VAR 0 3
62071: ARRAY
62072: PUSH
62073: LD_INT 1
62075: PLUS
62076: PUSH
62077: EMPTY
62078: LIST
62079: LIST
62080: PPUSH
62081: LD_VAR 0 1
62085: PPUSH
62086: CALL 69637 0 3
62090: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62091: LD_ADDR_VAR 0 6
62095: PUSH
62096: LD_EXP 99
62100: PUSH
62101: LD_VAR 0 3
62105: ARRAY
62106: PPUSH
62107: LD_INT 25
62109: PUSH
62110: LD_INT 1
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PUSH
62117: LD_INT 3
62119: PUSH
62120: LD_INT 54
62122: PUSH
62123: EMPTY
62124: LIST
62125: PUSH
62126: EMPTY
62127: LIST
62128: LIST
62129: PUSH
62130: EMPTY
62131: LIST
62132: LIST
62133: PPUSH
62134: CALL_OW 72
62138: ST_TO_ADDR
// if tmp then
62139: LD_VAR 0 6
62143: IFFALSE 62149
// exit ;
62145: POP
62146: POP
62147: GO 62289
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62149: LD_ADDR_VAR 0 6
62153: PUSH
62154: LD_EXP 99
62158: PUSH
62159: LD_VAR 0 3
62163: ARRAY
62164: PPUSH
62165: LD_INT 2
62167: PUSH
62168: LD_INT 30
62170: PUSH
62171: LD_INT 4
62173: PUSH
62174: EMPTY
62175: LIST
62176: LIST
62177: PUSH
62178: LD_INT 30
62180: PUSH
62181: LD_INT 5
62183: PUSH
62184: EMPTY
62185: LIST
62186: LIST
62187: PUSH
62188: EMPTY
62189: LIST
62190: LIST
62191: LIST
62192: PPUSH
62193: CALL_OW 72
62197: ST_TO_ADDR
// if not tmp then
62198: LD_VAR 0 6
62202: NOT
62203: IFFALSE 62209
// exit ;
62205: POP
62206: POP
62207: GO 62289
// for j in tmp do
62209: LD_ADDR_VAR 0 4
62213: PUSH
62214: LD_VAR 0 6
62218: PUSH
62219: FOR_IN
62220: IFFALSE 62279
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62222: LD_ADDR_VAR 0 7
62226: PUSH
62227: LD_VAR 0 4
62231: PPUSH
62232: CALL_OW 313
62236: PPUSH
62237: LD_INT 25
62239: PUSH
62240: LD_INT 1
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: PPUSH
62247: CALL_OW 72
62251: ST_TO_ADDR
// if units then
62252: LD_VAR 0 7
62256: IFFALSE 62277
// begin ComExitBuilding ( units [ 1 ] ) ;
62258: LD_VAR 0 7
62262: PUSH
62263: LD_INT 1
62265: ARRAY
62266: PPUSH
62267: CALL_OW 122
// exit ;
62271: POP
62272: POP
62273: POP
62274: POP
62275: GO 62289
// end ; end ;
62277: GO 62219
62279: POP
62280: POP
// end ; end ; exit ;
62281: POP
62282: POP
62283: GO 62289
// end ; end ;
62285: GO 61643
62287: POP
62288: POP
// end ;
62289: LD_VAR 0 2
62293: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62294: LD_INT 0
62296: PPUSH
62297: PPUSH
62298: PPUSH
62299: PPUSH
62300: PPUSH
62301: PPUSH
62302: PPUSH
// if not mc_bases or not skirmish then
62303: LD_EXP 99
62307: NOT
62308: PUSH
62309: LD_EXP 97
62313: NOT
62314: OR
62315: IFFALSE 62319
// exit ;
62317: GO 62550
// btype := GetBType ( building ) ;
62319: LD_ADDR_VAR 0 6
62323: PUSH
62324: LD_VAR 0 1
62328: PPUSH
62329: CALL_OW 266
62333: ST_TO_ADDR
// x := GetX ( building ) ;
62334: LD_ADDR_VAR 0 7
62338: PUSH
62339: LD_VAR 0 1
62343: PPUSH
62344: CALL_OW 250
62348: ST_TO_ADDR
// y := GetY ( building ) ;
62349: LD_ADDR_VAR 0 8
62353: PUSH
62354: LD_VAR 0 1
62358: PPUSH
62359: CALL_OW 251
62363: ST_TO_ADDR
// d := GetDir ( building ) ;
62364: LD_ADDR_VAR 0 9
62368: PUSH
62369: LD_VAR 0 1
62373: PPUSH
62374: CALL_OW 254
62378: ST_TO_ADDR
// for i = 1 to mc_bases do
62379: LD_ADDR_VAR 0 4
62383: PUSH
62384: DOUBLE
62385: LD_INT 1
62387: DEC
62388: ST_TO_ADDR
62389: LD_EXP 99
62393: PUSH
62394: FOR_TO
62395: IFFALSE 62548
// begin if not mc_build_list [ i ] then
62397: LD_EXP 104
62401: PUSH
62402: LD_VAR 0 4
62406: ARRAY
62407: NOT
62408: IFFALSE 62412
// continue ;
62410: GO 62394
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62412: LD_VAR 0 6
62416: PUSH
62417: LD_VAR 0 7
62421: PUSH
62422: LD_VAR 0 8
62426: PUSH
62427: LD_VAR 0 9
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: LIST
62436: LIST
62437: PPUSH
62438: LD_EXP 104
62442: PUSH
62443: LD_VAR 0 4
62447: ARRAY
62448: PUSH
62449: LD_INT 1
62451: ARRAY
62452: PPUSH
62453: CALL 75806 0 2
62457: IFFALSE 62546
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
62459: LD_ADDR_EXP 104
62463: PUSH
62464: LD_EXP 104
62468: PPUSH
62469: LD_VAR 0 4
62473: PPUSH
62474: LD_EXP 104
62478: PUSH
62479: LD_VAR 0 4
62483: ARRAY
62484: PPUSH
62485: LD_INT 1
62487: PPUSH
62488: CALL_OW 3
62492: PPUSH
62493: CALL_OW 1
62497: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
62498: LD_ADDR_EXP 106
62502: PUSH
62503: LD_EXP 106
62507: PPUSH
62508: LD_VAR 0 4
62512: PUSH
62513: LD_EXP 106
62517: PUSH
62518: LD_VAR 0 4
62522: ARRAY
62523: PUSH
62524: LD_INT 1
62526: PLUS
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PPUSH
62532: LD_VAR 0 1
62536: PPUSH
62537: CALL 69637 0 3
62541: ST_TO_ADDR
// exit ;
62542: POP
62543: POP
62544: GO 62550
// end ; end ;
62546: GO 62394
62548: POP
62549: POP
// end ;
62550: LD_VAR 0 3
62554: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
62555: LD_INT 0
62557: PPUSH
62558: PPUSH
62559: PPUSH
// if not mc_bases or not skirmish then
62560: LD_EXP 99
62564: NOT
62565: PUSH
62566: LD_EXP 97
62570: NOT
62571: OR
62572: IFFALSE 62576
// exit ;
62574: GO 62766
// for i = 1 to mc_bases do
62576: LD_ADDR_VAR 0 4
62580: PUSH
62581: DOUBLE
62582: LD_INT 1
62584: DEC
62585: ST_TO_ADDR
62586: LD_EXP 99
62590: PUSH
62591: FOR_TO
62592: IFFALSE 62679
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
62594: LD_VAR 0 1
62598: PUSH
62599: LD_EXP 107
62603: PUSH
62604: LD_VAR 0 4
62608: ARRAY
62609: IN
62610: PUSH
62611: LD_VAR 0 1
62615: PUSH
62616: LD_EXP 108
62620: PUSH
62621: LD_VAR 0 4
62625: ARRAY
62626: IN
62627: NOT
62628: AND
62629: IFFALSE 62677
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62631: LD_ADDR_EXP 108
62635: PUSH
62636: LD_EXP 108
62640: PPUSH
62641: LD_VAR 0 4
62645: PUSH
62646: LD_EXP 108
62650: PUSH
62651: LD_VAR 0 4
62655: ARRAY
62656: PUSH
62657: LD_INT 1
62659: PLUS
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: PPUSH
62665: LD_VAR 0 1
62669: PPUSH
62670: CALL 69637 0 3
62674: ST_TO_ADDR
// break ;
62675: GO 62679
// end ; end ;
62677: GO 62591
62679: POP
62680: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
62681: LD_VAR 0 1
62685: PPUSH
62686: CALL_OW 257
62690: PUSH
62691: LD_EXP 125
62695: IN
62696: PUSH
62697: LD_VAR 0 1
62701: PPUSH
62702: CALL_OW 266
62706: PUSH
62707: LD_INT 5
62709: EQUAL
62710: AND
62711: PUSH
62712: LD_VAR 0 2
62716: PPUSH
62717: CALL_OW 110
62721: PUSH
62722: LD_INT 18
62724: NONEQUAL
62725: AND
62726: IFFALSE 62766
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
62728: LD_VAR 0 2
62732: PPUSH
62733: CALL_OW 257
62737: PUSH
62738: LD_INT 5
62740: PUSH
62741: LD_INT 8
62743: PUSH
62744: LD_INT 9
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: LIST
62751: IN
62752: IFFALSE 62766
// SetClass ( unit , 1 ) ;
62754: LD_VAR 0 2
62758: PPUSH
62759: LD_INT 1
62761: PPUSH
62762: CALL_OW 336
// end ;
62766: LD_VAR 0 3
62770: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
62771: LD_INT 0
62773: PPUSH
62774: PPUSH
// if not mc_bases or not skirmish then
62775: LD_EXP 99
62779: NOT
62780: PUSH
62781: LD_EXP 97
62785: NOT
62786: OR
62787: IFFALSE 62791
// exit ;
62789: GO 62907
// if GetLives ( abandoned_vehicle ) > 250 then
62791: LD_VAR 0 2
62795: PPUSH
62796: CALL_OW 256
62800: PUSH
62801: LD_INT 250
62803: GREATER
62804: IFFALSE 62808
// exit ;
62806: GO 62907
// for i = 1 to mc_bases do
62808: LD_ADDR_VAR 0 6
62812: PUSH
62813: DOUBLE
62814: LD_INT 1
62816: DEC
62817: ST_TO_ADDR
62818: LD_EXP 99
62822: PUSH
62823: FOR_TO
62824: IFFALSE 62905
// begin if driver in mc_bases [ i ] then
62826: LD_VAR 0 1
62830: PUSH
62831: LD_EXP 99
62835: PUSH
62836: LD_VAR 0 6
62840: ARRAY
62841: IN
62842: IFFALSE 62903
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
62844: LD_VAR 0 1
62848: PPUSH
62849: LD_EXP 99
62853: PUSH
62854: LD_VAR 0 6
62858: ARRAY
62859: PPUSH
62860: LD_INT 2
62862: PUSH
62863: LD_INT 30
62865: PUSH
62866: LD_INT 0
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: PUSH
62873: LD_INT 30
62875: PUSH
62876: LD_INT 1
62878: PUSH
62879: EMPTY
62880: LIST
62881: LIST
62882: PUSH
62883: EMPTY
62884: LIST
62885: LIST
62886: LIST
62887: PPUSH
62888: CALL_OW 72
62892: PUSH
62893: LD_INT 1
62895: ARRAY
62896: PPUSH
62897: CALL_OW 112
// break ;
62901: GO 62905
// end ; end ;
62903: GO 62823
62905: POP
62906: POP
// end ; end_of_file
62907: LD_VAR 0 5
62911: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62912: LD_INT 0
62914: PPUSH
62915: PPUSH
// if exist_mode then
62916: LD_VAR 0 2
62920: IFFALSE 62945
// unit := CreateCharacter ( prefix & ident ) else
62922: LD_ADDR_VAR 0 5
62926: PUSH
62927: LD_VAR 0 3
62931: PUSH
62932: LD_VAR 0 1
62936: STR
62937: PPUSH
62938: CALL_OW 34
62942: ST_TO_ADDR
62943: GO 62960
// unit := NewCharacter ( ident ) ;
62945: LD_ADDR_VAR 0 5
62949: PUSH
62950: LD_VAR 0 1
62954: PPUSH
62955: CALL_OW 25
62959: ST_TO_ADDR
// result := unit ;
62960: LD_ADDR_VAR 0 4
62964: PUSH
62965: LD_VAR 0 5
62969: ST_TO_ADDR
// end ;
62970: LD_VAR 0 4
62974: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
62975: LD_INT 0
62977: PPUSH
62978: PPUSH
// if not side or not nation then
62979: LD_VAR 0 1
62983: NOT
62984: PUSH
62985: LD_VAR 0 2
62989: NOT
62990: OR
62991: IFFALSE 62995
// exit ;
62993: GO 63631
// case nation of nation_american :
62995: LD_VAR 0 2
62999: PUSH
63000: LD_INT 1
63002: DOUBLE
63003: EQUAL
63004: IFTRUE 63008
63006: GO 63178
63008: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
63009: LD_ADDR_VAR 0 4
63013: PUSH
63014: LD_INT 35
63016: PUSH
63017: LD_INT 45
63019: PUSH
63020: LD_INT 46
63022: PUSH
63023: LD_INT 47
63025: PUSH
63026: LD_INT 1
63028: PUSH
63029: LD_INT 2
63031: PUSH
63032: LD_INT 6
63034: PUSH
63035: LD_INT 15
63037: PUSH
63038: LD_INT 16
63040: PUSH
63041: LD_INT 7
63043: PUSH
63044: LD_INT 12
63046: PUSH
63047: LD_INT 13
63049: PUSH
63050: LD_INT 10
63052: PUSH
63053: LD_INT 14
63055: PUSH
63056: LD_INT 20
63058: PUSH
63059: LD_INT 21
63061: PUSH
63062: LD_INT 22
63064: PUSH
63065: LD_INT 25
63067: PUSH
63068: LD_INT 32
63070: PUSH
63071: LD_INT 27
63073: PUSH
63074: LD_INT 36
63076: PUSH
63077: LD_INT 69
63079: PUSH
63080: LD_INT 39
63082: PUSH
63083: LD_INT 34
63085: PUSH
63086: LD_INT 40
63088: PUSH
63089: LD_INT 48
63091: PUSH
63092: LD_INT 49
63094: PUSH
63095: LD_INT 50
63097: PUSH
63098: LD_INT 51
63100: PUSH
63101: LD_INT 52
63103: PUSH
63104: LD_INT 53
63106: PUSH
63107: LD_INT 54
63109: PUSH
63110: LD_INT 55
63112: PUSH
63113: LD_INT 56
63115: PUSH
63116: LD_INT 57
63118: PUSH
63119: LD_INT 58
63121: PUSH
63122: LD_INT 59
63124: PUSH
63125: LD_INT 60
63127: PUSH
63128: LD_INT 61
63130: PUSH
63131: LD_INT 62
63133: PUSH
63134: EMPTY
63135: LIST
63136: LIST
63137: LIST
63138: LIST
63139: LIST
63140: LIST
63141: LIST
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: LIST
63173: LIST
63174: LIST
63175: ST_TO_ADDR
63176: GO 63555
63178: LD_INT 2
63180: DOUBLE
63181: EQUAL
63182: IFTRUE 63186
63184: GO 63364
63186: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
63187: LD_ADDR_VAR 0 4
63191: PUSH
63192: LD_INT 35
63194: PUSH
63195: LD_INT 45
63197: PUSH
63198: LD_INT 46
63200: PUSH
63201: LD_INT 47
63203: PUSH
63204: LD_INT 70
63206: PUSH
63207: LD_INT 1
63209: PUSH
63210: LD_INT 11
63212: PUSH
63213: LD_INT 3
63215: PUSH
63216: LD_INT 4
63218: PUSH
63219: LD_INT 5
63221: PUSH
63222: LD_INT 6
63224: PUSH
63225: LD_INT 15
63227: PUSH
63228: LD_INT 18
63230: PUSH
63231: LD_INT 7
63233: PUSH
63234: LD_INT 17
63236: PUSH
63237: LD_INT 8
63239: PUSH
63240: LD_INT 20
63242: PUSH
63243: LD_INT 21
63245: PUSH
63246: LD_INT 22
63248: PUSH
63249: LD_INT 72
63251: PUSH
63252: LD_INT 26
63254: PUSH
63255: LD_INT 69
63257: PUSH
63258: LD_INT 39
63260: PUSH
63261: LD_INT 40
63263: PUSH
63264: LD_INT 41
63266: PUSH
63267: LD_INT 42
63269: PUSH
63270: LD_INT 43
63272: PUSH
63273: LD_INT 48
63275: PUSH
63276: LD_INT 49
63278: PUSH
63279: LD_INT 50
63281: PUSH
63282: LD_INT 51
63284: PUSH
63285: LD_INT 52
63287: PUSH
63288: LD_INT 53
63290: PUSH
63291: LD_INT 54
63293: PUSH
63294: LD_INT 55
63296: PUSH
63297: LD_INT 56
63299: PUSH
63300: LD_INT 60
63302: PUSH
63303: LD_INT 61
63305: PUSH
63306: LD_INT 62
63308: PUSH
63309: LD_INT 66
63311: PUSH
63312: LD_INT 67
63314: PUSH
63315: LD_INT 68
63317: PUSH
63318: EMPTY
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: LIST
63325: LIST
63326: LIST
63327: LIST
63328: LIST
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: ST_TO_ADDR
63362: GO 63555
63364: LD_INT 3
63366: DOUBLE
63367: EQUAL
63368: IFTRUE 63372
63370: GO 63554
63372: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63373: LD_ADDR_VAR 0 4
63377: PUSH
63378: LD_INT 46
63380: PUSH
63381: LD_INT 47
63383: PUSH
63384: LD_INT 1
63386: PUSH
63387: LD_INT 2
63389: PUSH
63390: LD_INT 11
63392: PUSH
63393: LD_INT 9
63395: PUSH
63396: LD_INT 20
63398: PUSH
63399: LD_INT 19
63401: PUSH
63402: LD_INT 21
63404: PUSH
63405: LD_INT 24
63407: PUSH
63408: LD_INT 22
63410: PUSH
63411: LD_INT 25
63413: PUSH
63414: LD_INT 28
63416: PUSH
63417: LD_INT 29
63419: PUSH
63420: LD_INT 30
63422: PUSH
63423: LD_INT 31
63425: PUSH
63426: LD_INT 37
63428: PUSH
63429: LD_INT 38
63431: PUSH
63432: LD_INT 32
63434: PUSH
63435: LD_INT 27
63437: PUSH
63438: LD_INT 33
63440: PUSH
63441: LD_INT 69
63443: PUSH
63444: LD_INT 39
63446: PUSH
63447: LD_INT 34
63449: PUSH
63450: LD_INT 40
63452: PUSH
63453: LD_INT 71
63455: PUSH
63456: LD_INT 23
63458: PUSH
63459: LD_INT 44
63461: PUSH
63462: LD_INT 48
63464: PUSH
63465: LD_INT 49
63467: PUSH
63468: LD_INT 50
63470: PUSH
63471: LD_INT 51
63473: PUSH
63474: LD_INT 52
63476: PUSH
63477: LD_INT 53
63479: PUSH
63480: LD_INT 54
63482: PUSH
63483: LD_INT 55
63485: PUSH
63486: LD_INT 56
63488: PUSH
63489: LD_INT 57
63491: PUSH
63492: LD_INT 58
63494: PUSH
63495: LD_INT 59
63497: PUSH
63498: LD_INT 63
63500: PUSH
63501: LD_INT 64
63503: PUSH
63504: LD_INT 65
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: LIST
63511: LIST
63512: LIST
63513: LIST
63514: LIST
63515: LIST
63516: LIST
63517: LIST
63518: LIST
63519: LIST
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: LIST
63529: LIST
63530: LIST
63531: LIST
63532: LIST
63533: LIST
63534: LIST
63535: LIST
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: ST_TO_ADDR
63552: GO 63555
63554: POP
// if state > - 1 and state < 3 then
63555: LD_VAR 0 3
63559: PUSH
63560: LD_INT 1
63562: NEG
63563: GREATER
63564: PUSH
63565: LD_VAR 0 3
63569: PUSH
63570: LD_INT 3
63572: LESS
63573: AND
63574: IFFALSE 63631
// for i in result do
63576: LD_ADDR_VAR 0 5
63580: PUSH
63581: LD_VAR 0 4
63585: PUSH
63586: FOR_IN
63587: IFFALSE 63629
// if GetTech ( i , side ) <> state then
63589: LD_VAR 0 5
63593: PPUSH
63594: LD_VAR 0 1
63598: PPUSH
63599: CALL_OW 321
63603: PUSH
63604: LD_VAR 0 3
63608: NONEQUAL
63609: IFFALSE 63627
// result := result diff i ;
63611: LD_ADDR_VAR 0 4
63615: PUSH
63616: LD_VAR 0 4
63620: PUSH
63621: LD_VAR 0 5
63625: DIFF
63626: ST_TO_ADDR
63627: GO 63586
63629: POP
63630: POP
// end ;
63631: LD_VAR 0 4
63635: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63636: LD_INT 0
63638: PPUSH
63639: PPUSH
63640: PPUSH
// result := true ;
63641: LD_ADDR_VAR 0 3
63645: PUSH
63646: LD_INT 1
63648: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63649: LD_ADDR_VAR 0 5
63653: PUSH
63654: LD_VAR 0 2
63658: PPUSH
63659: CALL_OW 480
63663: ST_TO_ADDR
// if not tmp then
63664: LD_VAR 0 5
63668: NOT
63669: IFFALSE 63673
// exit ;
63671: GO 63722
// for i in tmp do
63673: LD_ADDR_VAR 0 4
63677: PUSH
63678: LD_VAR 0 5
63682: PUSH
63683: FOR_IN
63684: IFFALSE 63720
// if GetTech ( i , side ) <> state_researched then
63686: LD_VAR 0 4
63690: PPUSH
63691: LD_VAR 0 1
63695: PPUSH
63696: CALL_OW 321
63700: PUSH
63701: LD_INT 2
63703: NONEQUAL
63704: IFFALSE 63718
// begin result := false ;
63706: LD_ADDR_VAR 0 3
63710: PUSH
63711: LD_INT 0
63713: ST_TO_ADDR
// exit ;
63714: POP
63715: POP
63716: GO 63722
// end ;
63718: GO 63683
63720: POP
63721: POP
// end ;
63722: LD_VAR 0 3
63726: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63727: LD_INT 0
63729: PPUSH
63730: PPUSH
63731: PPUSH
63732: PPUSH
63733: PPUSH
63734: PPUSH
63735: PPUSH
63736: PPUSH
63737: PPUSH
63738: PPUSH
63739: PPUSH
63740: PPUSH
63741: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63742: LD_VAR 0 1
63746: NOT
63747: PUSH
63748: LD_VAR 0 1
63752: PPUSH
63753: CALL_OW 257
63757: PUSH
63758: LD_INT 9
63760: NONEQUAL
63761: OR
63762: IFFALSE 63766
// exit ;
63764: GO 64339
// side := GetSide ( unit ) ;
63766: LD_ADDR_VAR 0 9
63770: PUSH
63771: LD_VAR 0 1
63775: PPUSH
63776: CALL_OW 255
63780: ST_TO_ADDR
// tech_space := tech_spacanom ;
63781: LD_ADDR_VAR 0 12
63785: PUSH
63786: LD_INT 29
63788: ST_TO_ADDR
// tech_time := tech_taurad ;
63789: LD_ADDR_VAR 0 13
63793: PUSH
63794: LD_INT 28
63796: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63797: LD_ADDR_VAR 0 11
63801: PUSH
63802: LD_VAR 0 1
63806: PPUSH
63807: CALL_OW 310
63811: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63812: LD_VAR 0 11
63816: PPUSH
63817: CALL_OW 247
63821: PUSH
63822: LD_INT 2
63824: EQUAL
63825: IFFALSE 63829
// exit ;
63827: GO 64339
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63829: LD_ADDR_VAR 0 8
63833: PUSH
63834: LD_INT 81
63836: PUSH
63837: LD_VAR 0 9
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: PUSH
63846: LD_INT 3
63848: PUSH
63849: LD_INT 21
63851: PUSH
63852: LD_INT 3
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PPUSH
63867: CALL_OW 69
63871: ST_TO_ADDR
// if not tmp then
63872: LD_VAR 0 8
63876: NOT
63877: IFFALSE 63881
// exit ;
63879: GO 64339
// if in_unit then
63881: LD_VAR 0 11
63885: IFFALSE 63909
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63887: LD_ADDR_VAR 0 10
63891: PUSH
63892: LD_VAR 0 8
63896: PPUSH
63897: LD_VAR 0 11
63901: PPUSH
63902: CALL_OW 74
63906: ST_TO_ADDR
63907: GO 63929
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63909: LD_ADDR_VAR 0 10
63913: PUSH
63914: LD_VAR 0 8
63918: PPUSH
63919: LD_VAR 0 1
63923: PPUSH
63924: CALL_OW 74
63928: ST_TO_ADDR
// if not enemy then
63929: LD_VAR 0 10
63933: NOT
63934: IFFALSE 63938
// exit ;
63936: GO 64339
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
63938: LD_VAR 0 11
63942: PUSH
63943: LD_VAR 0 11
63947: PPUSH
63948: LD_VAR 0 10
63952: PPUSH
63953: CALL_OW 296
63957: PUSH
63958: LD_INT 13
63960: GREATER
63961: AND
63962: PUSH
63963: LD_VAR 0 1
63967: PPUSH
63968: LD_VAR 0 10
63972: PPUSH
63973: CALL_OW 296
63977: PUSH
63978: LD_INT 12
63980: GREATER
63981: OR
63982: IFFALSE 63986
// exit ;
63984: GO 64339
// missile := [ 1 ] ;
63986: LD_ADDR_VAR 0 14
63990: PUSH
63991: LD_INT 1
63993: PUSH
63994: EMPTY
63995: LIST
63996: ST_TO_ADDR
// if Researched ( side , tech_space ) then
63997: LD_VAR 0 9
64001: PPUSH
64002: LD_VAR 0 12
64006: PPUSH
64007: CALL_OW 325
64011: IFFALSE 64040
// missile := Insert ( missile , missile + 1 , 2 ) ;
64013: LD_ADDR_VAR 0 14
64017: PUSH
64018: LD_VAR 0 14
64022: PPUSH
64023: LD_VAR 0 14
64027: PUSH
64028: LD_INT 1
64030: PLUS
64031: PPUSH
64032: LD_INT 2
64034: PPUSH
64035: CALL_OW 2
64039: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64040: LD_VAR 0 9
64044: PPUSH
64045: LD_VAR 0 13
64049: PPUSH
64050: CALL_OW 325
64054: PUSH
64055: LD_VAR 0 10
64059: PPUSH
64060: CALL_OW 255
64064: PPUSH
64065: LD_VAR 0 13
64069: PPUSH
64070: CALL_OW 325
64074: NOT
64075: AND
64076: IFFALSE 64105
// missile := Insert ( missile , missile + 1 , 3 ) ;
64078: LD_ADDR_VAR 0 14
64082: PUSH
64083: LD_VAR 0 14
64087: PPUSH
64088: LD_VAR 0 14
64092: PUSH
64093: LD_INT 1
64095: PLUS
64096: PPUSH
64097: LD_INT 3
64099: PPUSH
64100: CALL_OW 2
64104: ST_TO_ADDR
// if missile < 2 then
64105: LD_VAR 0 14
64109: PUSH
64110: LD_INT 2
64112: LESS
64113: IFFALSE 64117
// exit ;
64115: GO 64339
// x := GetX ( enemy ) ;
64117: LD_ADDR_VAR 0 4
64121: PUSH
64122: LD_VAR 0 10
64126: PPUSH
64127: CALL_OW 250
64131: ST_TO_ADDR
// y := GetY ( enemy ) ;
64132: LD_ADDR_VAR 0 5
64136: PUSH
64137: LD_VAR 0 10
64141: PPUSH
64142: CALL_OW 251
64146: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64147: LD_ADDR_VAR 0 6
64151: PUSH
64152: LD_VAR 0 4
64156: PUSH
64157: LD_INT 1
64159: NEG
64160: PPUSH
64161: LD_INT 1
64163: PPUSH
64164: CALL_OW 12
64168: PLUS
64169: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64170: LD_ADDR_VAR 0 7
64174: PUSH
64175: LD_VAR 0 5
64179: PUSH
64180: LD_INT 1
64182: NEG
64183: PPUSH
64184: LD_INT 1
64186: PPUSH
64187: CALL_OW 12
64191: PLUS
64192: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64193: LD_VAR 0 6
64197: PPUSH
64198: LD_VAR 0 7
64202: PPUSH
64203: CALL_OW 488
64207: NOT
64208: IFFALSE 64230
// begin _x := x ;
64210: LD_ADDR_VAR 0 6
64214: PUSH
64215: LD_VAR 0 4
64219: ST_TO_ADDR
// _y := y ;
64220: LD_ADDR_VAR 0 7
64224: PUSH
64225: LD_VAR 0 5
64229: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64230: LD_ADDR_VAR 0 3
64234: PUSH
64235: LD_INT 1
64237: PPUSH
64238: LD_VAR 0 14
64242: PPUSH
64243: CALL_OW 12
64247: ST_TO_ADDR
// case i of 1 :
64248: LD_VAR 0 3
64252: PUSH
64253: LD_INT 1
64255: DOUBLE
64256: EQUAL
64257: IFTRUE 64261
64259: GO 64278
64261: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64262: LD_VAR 0 1
64266: PPUSH
64267: LD_VAR 0 10
64271: PPUSH
64272: CALL_OW 115
64276: GO 64339
64278: LD_INT 2
64280: DOUBLE
64281: EQUAL
64282: IFTRUE 64286
64284: GO 64308
64286: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64287: LD_VAR 0 1
64291: PPUSH
64292: LD_VAR 0 6
64296: PPUSH
64297: LD_VAR 0 7
64301: PPUSH
64302: CALL_OW 153
64306: GO 64339
64308: LD_INT 3
64310: DOUBLE
64311: EQUAL
64312: IFTRUE 64316
64314: GO 64338
64316: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64317: LD_VAR 0 1
64321: PPUSH
64322: LD_VAR 0 6
64326: PPUSH
64327: LD_VAR 0 7
64331: PPUSH
64332: CALL_OW 154
64336: GO 64339
64338: POP
// end ;
64339: LD_VAR 0 2
64343: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64344: LD_INT 0
64346: PPUSH
64347: PPUSH
64348: PPUSH
64349: PPUSH
64350: PPUSH
64351: PPUSH
// if not unit or not building then
64352: LD_VAR 0 1
64356: NOT
64357: PUSH
64358: LD_VAR 0 2
64362: NOT
64363: OR
64364: IFFALSE 64368
// exit ;
64366: GO 64526
// x := GetX ( building ) ;
64368: LD_ADDR_VAR 0 5
64372: PUSH
64373: LD_VAR 0 2
64377: PPUSH
64378: CALL_OW 250
64382: ST_TO_ADDR
// y := GetY ( building ) ;
64383: LD_ADDR_VAR 0 6
64387: PUSH
64388: LD_VAR 0 2
64392: PPUSH
64393: CALL_OW 251
64397: ST_TO_ADDR
// for i = 0 to 5 do
64398: LD_ADDR_VAR 0 4
64402: PUSH
64403: DOUBLE
64404: LD_INT 0
64406: DEC
64407: ST_TO_ADDR
64408: LD_INT 5
64410: PUSH
64411: FOR_TO
64412: IFFALSE 64524
// begin _x := ShiftX ( x , i , 3 ) ;
64414: LD_ADDR_VAR 0 7
64418: PUSH
64419: LD_VAR 0 5
64423: PPUSH
64424: LD_VAR 0 4
64428: PPUSH
64429: LD_INT 3
64431: PPUSH
64432: CALL_OW 272
64436: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64437: LD_ADDR_VAR 0 8
64441: PUSH
64442: LD_VAR 0 6
64446: PPUSH
64447: LD_VAR 0 4
64451: PPUSH
64452: LD_INT 3
64454: PPUSH
64455: CALL_OW 273
64459: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64460: LD_VAR 0 7
64464: PPUSH
64465: LD_VAR 0 8
64469: PPUSH
64470: CALL_OW 488
64474: NOT
64475: IFFALSE 64479
// continue ;
64477: GO 64411
// if HexInfo ( _x , _y ) = 0 then
64479: LD_VAR 0 7
64483: PPUSH
64484: LD_VAR 0 8
64488: PPUSH
64489: CALL_OW 428
64493: PUSH
64494: LD_INT 0
64496: EQUAL
64497: IFFALSE 64522
// begin ComMoveXY ( unit , _x , _y ) ;
64499: LD_VAR 0 1
64503: PPUSH
64504: LD_VAR 0 7
64508: PPUSH
64509: LD_VAR 0 8
64513: PPUSH
64514: CALL_OW 111
// exit ;
64518: POP
64519: POP
64520: GO 64526
// end ; end ;
64522: GO 64411
64524: POP
64525: POP
// end ;
64526: LD_VAR 0 3
64530: RET
// export function ScanBase ( side , base_area ) ; begin
64531: LD_INT 0
64533: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64534: LD_ADDR_VAR 0 3
64538: PUSH
64539: LD_VAR 0 2
64543: PPUSH
64544: LD_INT 81
64546: PUSH
64547: LD_VAR 0 1
64551: PUSH
64552: EMPTY
64553: LIST
64554: LIST
64555: PPUSH
64556: CALL_OW 70
64560: ST_TO_ADDR
// end ;
64561: LD_VAR 0 3
64565: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
64566: LD_INT 0
64568: PPUSH
64569: PPUSH
64570: PPUSH
64571: PPUSH
64572: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
64573: LD_VAR 0 1
64577: NOT
64578: PUSH
64579: LD_EXP 99
64583: PUSH
64584: LD_VAR 0 1
64588: ARRAY
64589: NOT
64590: OR
64591: PUSH
64592: LD_VAR 0 2
64596: NOT
64597: OR
64598: PUSH
64599: LD_VAR 0 3
64603: NOT
64604: OR
64605: IFFALSE 64609
// exit ;
64607: GO 65059
// side := mc_sides [ base ] ;
64609: LD_ADDR_VAR 0 6
64613: PUSH
64614: LD_EXP 125
64618: PUSH
64619: LD_VAR 0 1
64623: ARRAY
64624: ST_TO_ADDR
// if not side then
64625: LD_VAR 0 6
64629: NOT
64630: IFFALSE 64634
// exit ;
64632: GO 65059
// for i in solds do
64634: LD_ADDR_VAR 0 7
64638: PUSH
64639: LD_VAR 0 2
64643: PUSH
64644: FOR_IN
64645: IFFALSE 64706
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
64647: LD_VAR 0 7
64651: PPUSH
64652: CALL_OW 310
64656: PPUSH
64657: CALL_OW 266
64661: PUSH
64662: LD_INT 32
64664: PUSH
64665: LD_INT 31
64667: PUSH
64668: EMPTY
64669: LIST
64670: LIST
64671: IN
64672: IFFALSE 64692
// solds := solds diff i else
64674: LD_ADDR_VAR 0 2
64678: PUSH
64679: LD_VAR 0 2
64683: PUSH
64684: LD_VAR 0 7
64688: DIFF
64689: ST_TO_ADDR
64690: GO 64704
// SetTag ( i , 18 ) ;
64692: LD_VAR 0 7
64696: PPUSH
64697: LD_INT 18
64699: PPUSH
64700: CALL_OW 109
64704: GO 64644
64706: POP
64707: POP
// if not solds then
64708: LD_VAR 0 2
64712: NOT
64713: IFFALSE 64717
// exit ;
64715: GO 65059
// repeat wait ( 0 0$1 ) ;
64717: LD_INT 35
64719: PPUSH
64720: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
64724: LD_ADDR_VAR 0 5
64728: PUSH
64729: LD_VAR 0 6
64733: PPUSH
64734: LD_VAR 0 3
64738: PPUSH
64739: CALL 64531 0 2
64743: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
64744: LD_VAR 0 5
64748: NOT
64749: PUSH
64750: LD_VAR 0 5
64754: PUSH
64755: LD_INT 3
64757: GREATER
64758: OR
64759: PUSH
64760: LD_EXP 121
64764: PUSH
64765: LD_VAR 0 1
64769: ARRAY
64770: OR
64771: IFFALSE 64812
// begin for i in solds do
64773: LD_ADDR_VAR 0 7
64777: PUSH
64778: LD_VAR 0 2
64782: PUSH
64783: FOR_IN
64784: IFFALSE 64808
// if HasTask ( i ) then
64786: LD_VAR 0 7
64790: PPUSH
64791: CALL_OW 314
64795: IFFALSE 64806
// ComStop ( i ) ;
64797: LD_VAR 0 7
64801: PPUSH
64802: CALL_OW 141
64806: GO 64783
64808: POP
64809: POP
// break ;
64810: GO 65047
// end ; for i in solds do
64812: LD_ADDR_VAR 0 7
64816: PUSH
64817: LD_VAR 0 2
64821: PUSH
64822: FOR_IN
64823: IFFALSE 65039
// begin if IsInUnit ( i ) then
64825: LD_VAR 0 7
64829: PPUSH
64830: CALL_OW 310
64834: IFFALSE 64845
// ComExitBuilding ( i ) ;
64836: LD_VAR 0 7
64840: PPUSH
64841: CALL_OW 122
// if GetLives ( i ) > 333 then
64845: LD_VAR 0 7
64849: PPUSH
64850: CALL_OW 256
64854: PUSH
64855: LD_INT 333
64857: GREATER
64858: IFFALSE 64886
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
64860: LD_VAR 0 7
64864: PPUSH
64865: LD_VAR 0 5
64869: PPUSH
64870: LD_VAR 0 7
64874: PPUSH
64875: CALL_OW 74
64879: PPUSH
64880: CALL_OW 115
64884: GO 65037
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
64886: LD_ADDR_VAR 0 8
64890: PUSH
64891: LD_EXP 99
64895: PUSH
64896: LD_VAR 0 1
64900: ARRAY
64901: PPUSH
64902: LD_INT 2
64904: PUSH
64905: LD_INT 30
64907: PUSH
64908: LD_INT 0
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: LD_INT 30
64917: PUSH
64918: LD_INT 1
64920: PUSH
64921: EMPTY
64922: LIST
64923: LIST
64924: PUSH
64925: LD_INT 30
64927: PUSH
64928: LD_INT 6
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: PPUSH
64941: CALL_OW 72
64945: PPUSH
64946: LD_VAR 0 7
64950: PPUSH
64951: CALL_OW 74
64955: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
64956: LD_VAR 0 7
64960: PPUSH
64961: LD_VAR 0 8
64965: PPUSH
64966: CALL_OW 250
64970: PPUSH
64971: LD_INT 3
64973: PPUSH
64974: LD_INT 5
64976: PPUSH
64977: CALL_OW 272
64981: PPUSH
64982: LD_VAR 0 8
64986: PPUSH
64987: CALL_OW 251
64991: PPUSH
64992: LD_INT 3
64994: PPUSH
64995: LD_INT 5
64997: PPUSH
64998: CALL_OW 273
65002: PPUSH
65003: CALL_OW 111
// SetTag ( i , 0 ) ;
65007: LD_VAR 0 7
65011: PPUSH
65012: LD_INT 0
65014: PPUSH
65015: CALL_OW 109
// solds := solds diff i ;
65019: LD_ADDR_VAR 0 2
65023: PUSH
65024: LD_VAR 0 2
65028: PUSH
65029: LD_VAR 0 7
65033: DIFF
65034: ST_TO_ADDR
// continue ;
65035: GO 64822
// end ; end ;
65037: GO 64822
65039: POP
65040: POP
// until solds ;
65041: LD_VAR 0 2
65045: IFFALSE 64717
// MC_Reset ( base , 18 ) ;
65047: LD_VAR 0 1
65051: PPUSH
65052: LD_INT 18
65054: PPUSH
65055: CALL 37767 0 2
// end ;
65059: LD_VAR 0 4
65063: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65064: LD_INT 0
65066: PPUSH
65067: PPUSH
65068: PPUSH
65069: PPUSH
65070: PPUSH
65071: PPUSH
65072: PPUSH
65073: PPUSH
65074: PPUSH
65075: PPUSH
65076: PPUSH
65077: PPUSH
65078: PPUSH
65079: PPUSH
65080: PPUSH
65081: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65082: LD_ADDR_VAR 0 12
65086: PUSH
65087: LD_EXP 99
65091: PUSH
65092: LD_VAR 0 1
65096: ARRAY
65097: PPUSH
65098: LD_INT 25
65100: PUSH
65101: LD_INT 3
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PPUSH
65108: CALL_OW 72
65112: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65113: LD_ADDR_VAR 0 8
65117: PUSH
65118: LD_EXP 99
65122: PUSH
65123: LD_VAR 0 1
65127: ARRAY
65128: PPUSH
65129: LD_INT 2
65131: PUSH
65132: LD_INT 25
65134: PUSH
65135: LD_INT 1
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: LD_INT 25
65144: PUSH
65145: LD_INT 5
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 25
65154: PUSH
65155: LD_INT 8
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: PUSH
65162: LD_INT 25
65164: PUSH
65165: LD_INT 9
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: PPUSH
65179: CALL_OW 72
65183: ST_TO_ADDR
// if not defenders and not solds then
65184: LD_VAR 0 2
65188: NOT
65189: PUSH
65190: LD_VAR 0 8
65194: NOT
65195: AND
65196: IFFALSE 65200
// exit ;
65198: GO 66529
// depot_under_attack := false ;
65200: LD_ADDR_VAR 0 16
65204: PUSH
65205: LD_INT 0
65207: ST_TO_ADDR
// sold_defenders := [ ] ;
65208: LD_ADDR_VAR 0 17
65212: PUSH
65213: EMPTY
65214: ST_TO_ADDR
// if mechs then
65215: LD_VAR 0 12
65219: IFFALSE 65348
// for i in defenders do
65221: LD_ADDR_VAR 0 5
65225: PUSH
65226: LD_VAR 0 2
65230: PUSH
65231: FOR_IN
65232: IFFALSE 65346
// begin SetTag ( i , 20 ) ;
65234: LD_VAR 0 5
65238: PPUSH
65239: LD_INT 20
65241: PPUSH
65242: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65246: LD_VAR 0 5
65250: PPUSH
65251: CALL_OW 263
65255: PUSH
65256: LD_INT 1
65258: EQUAL
65259: PUSH
65260: LD_VAR 0 5
65264: PPUSH
65265: CALL_OW 311
65269: NOT
65270: AND
65271: PUSH
65272: LD_VAR 0 12
65276: AND
65277: IFFALSE 65344
// begin un := mechs [ 1 ] ;
65279: LD_ADDR_VAR 0 10
65283: PUSH
65284: LD_VAR 0 12
65288: PUSH
65289: LD_INT 1
65291: ARRAY
65292: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65293: LD_VAR 0 10
65297: PPUSH
65298: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65302: LD_VAR 0 10
65306: PPUSH
65307: LD_VAR 0 5
65311: PPUSH
65312: CALL_OW 180
// SetTag ( un , 19 ) ;
65316: LD_VAR 0 10
65320: PPUSH
65321: LD_INT 19
65323: PPUSH
65324: CALL_OW 109
// mechs := mechs diff un ;
65328: LD_ADDR_VAR 0 12
65332: PUSH
65333: LD_VAR 0 12
65337: PUSH
65338: LD_VAR 0 10
65342: DIFF
65343: ST_TO_ADDR
// end ; end ;
65344: GO 65231
65346: POP
65347: POP
// if solds then
65348: LD_VAR 0 8
65352: IFFALSE 65411
// for i in solds do
65354: LD_ADDR_VAR 0 5
65358: PUSH
65359: LD_VAR 0 8
65363: PUSH
65364: FOR_IN
65365: IFFALSE 65409
// if not GetTag ( i ) then
65367: LD_VAR 0 5
65371: PPUSH
65372: CALL_OW 110
65376: NOT
65377: IFFALSE 65407
// begin defenders := defenders union i ;
65379: LD_ADDR_VAR 0 2
65383: PUSH
65384: LD_VAR 0 2
65388: PUSH
65389: LD_VAR 0 5
65393: UNION
65394: ST_TO_ADDR
// SetTag ( i , 18 ) ;
65395: LD_VAR 0 5
65399: PPUSH
65400: LD_INT 18
65402: PPUSH
65403: CALL_OW 109
// end ;
65407: GO 65364
65409: POP
65410: POP
// repeat wait ( 0 0$1 ) ;
65411: LD_INT 35
65413: PPUSH
65414: CALL_OW 67
// enemy := mc_scan [ base ] ;
65418: LD_ADDR_VAR 0 3
65422: PUSH
65423: LD_EXP 122
65427: PUSH
65428: LD_VAR 0 1
65432: ARRAY
65433: ST_TO_ADDR
// for i in defenders do
65434: LD_ADDR_VAR 0 5
65438: PUSH
65439: LD_VAR 0 2
65443: PUSH
65444: FOR_IN
65445: IFFALSE 66130
// begin e := NearestUnitToUnit ( enemy , i ) ;
65447: LD_ADDR_VAR 0 13
65451: PUSH
65452: LD_VAR 0 3
65456: PPUSH
65457: LD_VAR 0 5
65461: PPUSH
65462: CALL_OW 74
65466: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
65467: LD_ADDR_VAR 0 16
65471: PUSH
65472: LD_EXP 99
65476: PUSH
65477: LD_VAR 0 1
65481: ARRAY
65482: PPUSH
65483: LD_INT 2
65485: PUSH
65486: LD_INT 30
65488: PUSH
65489: LD_INT 0
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: PUSH
65496: LD_INT 30
65498: PUSH
65499: LD_INT 1
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: EMPTY
65507: LIST
65508: LIST
65509: LIST
65510: PPUSH
65511: CALL_OW 72
65515: NOT
65516: PUSH
65517: LD_EXP 99
65521: PUSH
65522: LD_VAR 0 1
65526: ARRAY
65527: PPUSH
65528: LD_INT 2
65530: PUSH
65531: LD_INT 30
65533: PUSH
65534: LD_INT 0
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: PUSH
65541: LD_INT 30
65543: PUSH
65544: LD_INT 1
65546: PUSH
65547: EMPTY
65548: LIST
65549: LIST
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: LIST
65555: PPUSH
65556: CALL_OW 72
65560: PPUSH
65561: CALL_OW 256
65565: PUSH
65566: LD_INT 600
65568: LESS
65569: OR
65570: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
65571: LD_VAR 0 5
65575: PPUSH
65576: CALL_OW 247
65580: PUSH
65581: LD_INT 2
65583: DOUBLE
65584: EQUAL
65585: IFTRUE 65589
65587: GO 65836
65589: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
65590: LD_VAR 0 5
65594: PPUSH
65595: CALL_OW 256
65599: PUSH
65600: LD_INT 650
65602: GREATER
65603: PUSH
65604: LD_VAR 0 5
65608: PPUSH
65609: LD_VAR 0 13
65613: PPUSH
65614: CALL_OW 296
65618: PUSH
65619: LD_INT 40
65621: LESS
65622: AND
65623: IFFALSE 65641
// ComAttackUnit ( i , e ) else
65625: LD_VAR 0 5
65629: PPUSH
65630: LD_VAR 0 13
65634: PPUSH
65635: CALL_OW 115
65639: GO 65719
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
65641: LD_VAR 0 5
65645: PPUSH
65646: LD_VAR 0 13
65650: PPUSH
65651: CALL_OW 296
65655: PUSH
65656: LD_INT 30
65658: GREATEREQUAL
65659: PUSH
65660: LD_VAR 0 5
65664: PPUSH
65665: CALL_OW 256
65669: PUSH
65670: LD_INT 650
65672: LESSEQUAL
65673: OR
65674: PUSH
65675: LD_VAR 0 5
65679: PPUSH
65680: LD_EXP 123
65684: PUSH
65685: LD_VAR 0 1
65689: ARRAY
65690: PPUSH
65691: CALL_OW 308
65695: NOT
65696: AND
65697: IFFALSE 65719
// ComMoveToArea ( i , mc_parking [ base ] ) ;
65699: LD_VAR 0 5
65703: PPUSH
65704: LD_EXP 123
65708: PUSH
65709: LD_VAR 0 1
65713: ARRAY
65714: PPUSH
65715: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
65719: LD_VAR 0 5
65723: PPUSH
65724: CALL_OW 256
65728: PUSH
65729: LD_INT 998
65731: LESS
65732: PUSH
65733: LD_VAR 0 5
65737: PPUSH
65738: CALL_OW 263
65742: PUSH
65743: LD_INT 1
65745: EQUAL
65746: AND
65747: PUSH
65748: LD_VAR 0 5
65752: PPUSH
65753: CALL_OW 311
65757: AND
65758: PUSH
65759: LD_VAR 0 5
65763: PPUSH
65764: LD_EXP 123
65768: PUSH
65769: LD_VAR 0 1
65773: ARRAY
65774: PPUSH
65775: CALL_OW 308
65779: AND
65780: IFFALSE 65834
// begin mech := IsDrivenBy ( i ) ;
65782: LD_ADDR_VAR 0 9
65786: PUSH
65787: LD_VAR 0 5
65791: PPUSH
65792: CALL_OW 311
65796: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
65797: LD_VAR 0 9
65801: PPUSH
65802: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
65806: LD_VAR 0 9
65810: PPUSH
65811: LD_VAR 0 5
65815: PPUSH
65816: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
65820: LD_VAR 0 9
65824: PPUSH
65825: LD_VAR 0 5
65829: PPUSH
65830: CALL_OW 180
// end ; end ; unit_human :
65834: GO 66101
65836: LD_INT 1
65838: DOUBLE
65839: EQUAL
65840: IFTRUE 65844
65842: GO 66100
65844: POP
// begin b := IsInUnit ( i ) ;
65845: LD_ADDR_VAR 0 18
65849: PUSH
65850: LD_VAR 0 5
65854: PPUSH
65855: CALL_OW 310
65859: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
65860: LD_ADDR_VAR 0 19
65864: PUSH
65865: LD_VAR 0 18
65869: NOT
65870: PUSH
65871: LD_VAR 0 18
65875: PPUSH
65876: CALL_OW 266
65880: PUSH
65881: LD_INT 32
65883: PUSH
65884: LD_INT 31
65886: PUSH
65887: EMPTY
65888: LIST
65889: LIST
65890: IN
65891: OR
65892: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
65893: LD_VAR 0 16
65897: PUSH
65898: LD_VAR 0 2
65902: PPUSH
65903: LD_INT 21
65905: PUSH
65906: LD_INT 2
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: PPUSH
65913: CALL_OW 72
65917: PUSH
65918: LD_INT 1
65920: LESSEQUAL
65921: OR
65922: PUSH
65923: LD_VAR 0 19
65927: AND
65928: PUSH
65929: LD_VAR 0 5
65933: PUSH
65934: LD_VAR 0 17
65938: IN
65939: NOT
65940: AND
65941: IFFALSE 66034
// begin if b then
65943: LD_VAR 0 18
65947: IFFALSE 65996
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
65949: LD_VAR 0 18
65953: PPUSH
65954: LD_VAR 0 3
65958: PPUSH
65959: LD_VAR 0 18
65963: PPUSH
65964: CALL_OW 74
65968: PPUSH
65969: CALL_OW 296
65973: PUSH
65974: LD_INT 10
65976: LESS
65977: PUSH
65978: LD_VAR 0 18
65982: PPUSH
65983: CALL_OW 461
65987: PUSH
65988: LD_INT 7
65990: NONEQUAL
65991: AND
65992: IFFALSE 65996
// continue ;
65994: GO 65444
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
65996: LD_ADDR_VAR 0 17
66000: PUSH
66001: LD_VAR 0 17
66005: PPUSH
66006: LD_VAR 0 17
66010: PUSH
66011: LD_INT 1
66013: PLUS
66014: PPUSH
66015: LD_VAR 0 5
66019: PPUSH
66020: CALL_OW 1
66024: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66025: LD_VAR 0 5
66029: PPUSH
66030: CALL_OW 122
// end ; if sold_defenders then
66034: LD_VAR 0 17
66038: IFFALSE 66098
// if i in sold_defenders then
66040: LD_VAR 0 5
66044: PUSH
66045: LD_VAR 0 17
66049: IN
66050: IFFALSE 66098
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66052: LD_VAR 0 5
66056: PPUSH
66057: CALL_OW 314
66061: NOT
66062: PUSH
66063: LD_VAR 0 5
66067: PPUSH
66068: LD_VAR 0 13
66072: PPUSH
66073: CALL_OW 296
66077: PUSH
66078: LD_INT 30
66080: LESS
66081: AND
66082: IFFALSE 66098
// ComAttackUnit ( i , e ) ;
66084: LD_VAR 0 5
66088: PPUSH
66089: LD_VAR 0 13
66093: PPUSH
66094: CALL_OW 115
// end ; end ; end ;
66098: GO 66101
66100: POP
// if IsDead ( i ) then
66101: LD_VAR 0 5
66105: PPUSH
66106: CALL_OW 301
66110: IFFALSE 66128
// defenders := defenders diff i ;
66112: LD_ADDR_VAR 0 2
66116: PUSH
66117: LD_VAR 0 2
66121: PUSH
66122: LD_VAR 0 5
66126: DIFF
66127: ST_TO_ADDR
// end ;
66128: GO 65444
66130: POP
66131: POP
// until not enemy or not defenders ;
66132: LD_VAR 0 3
66136: NOT
66137: PUSH
66138: LD_VAR 0 2
66142: NOT
66143: OR
66144: IFFALSE 65411
// MC_Reset ( base , 18 ) ;
66146: LD_VAR 0 1
66150: PPUSH
66151: LD_INT 18
66153: PPUSH
66154: CALL 37767 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66158: LD_ADDR_VAR 0 2
66162: PUSH
66163: LD_VAR 0 2
66167: PUSH
66168: LD_VAR 0 2
66172: PPUSH
66173: LD_INT 2
66175: PUSH
66176: LD_INT 25
66178: PUSH
66179: LD_INT 1
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: PUSH
66186: LD_INT 25
66188: PUSH
66189: LD_INT 5
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 25
66198: PUSH
66199: LD_INT 8
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: LD_INT 25
66208: PUSH
66209: LD_INT 9
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: LIST
66222: PPUSH
66223: CALL_OW 72
66227: DIFF
66228: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66229: LD_VAR 0 3
66233: NOT
66234: PUSH
66235: LD_VAR 0 2
66239: PPUSH
66240: LD_INT 21
66242: PUSH
66243: LD_INT 2
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PPUSH
66250: CALL_OW 72
66254: AND
66255: IFFALSE 66517
// begin tmp := FilterByTag ( defenders , 19 ) ;
66257: LD_ADDR_VAR 0 11
66261: PUSH
66262: LD_VAR 0 2
66266: PPUSH
66267: LD_INT 19
66269: PPUSH
66270: CALL 102897 0 2
66274: ST_TO_ADDR
// if tmp then
66275: LD_VAR 0 11
66279: IFFALSE 66349
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66281: LD_ADDR_VAR 0 11
66285: PUSH
66286: LD_VAR 0 11
66290: PPUSH
66291: LD_INT 25
66293: PUSH
66294: LD_INT 3
66296: PUSH
66297: EMPTY
66298: LIST
66299: LIST
66300: PPUSH
66301: CALL_OW 72
66305: ST_TO_ADDR
// if tmp then
66306: LD_VAR 0 11
66310: IFFALSE 66349
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66312: LD_ADDR_EXP 111
66316: PUSH
66317: LD_EXP 111
66321: PPUSH
66322: LD_VAR 0 1
66326: PPUSH
66327: LD_EXP 111
66331: PUSH
66332: LD_VAR 0 1
66336: ARRAY
66337: PUSH
66338: LD_VAR 0 11
66342: UNION
66343: PPUSH
66344: CALL_OW 1
66348: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
66349: LD_VAR 0 1
66353: PPUSH
66354: LD_INT 19
66356: PPUSH
66357: CALL 37767 0 2
// repeat wait ( 0 0$1 ) ;
66361: LD_INT 35
66363: PPUSH
66364: CALL_OW 67
// for i in defenders do
66368: LD_ADDR_VAR 0 5
66372: PUSH
66373: LD_VAR 0 2
66377: PUSH
66378: FOR_IN
66379: IFFALSE 66468
// begin if not IsInArea ( i , mc_parking [ base ] ) then
66381: LD_VAR 0 5
66385: PPUSH
66386: LD_EXP 123
66390: PUSH
66391: LD_VAR 0 1
66395: ARRAY
66396: PPUSH
66397: CALL_OW 308
66401: NOT
66402: IFFALSE 66426
// ComMoveToArea ( i , mc_parking [ base ] ) else
66404: LD_VAR 0 5
66408: PPUSH
66409: LD_EXP 123
66413: PUSH
66414: LD_VAR 0 1
66418: ARRAY
66419: PPUSH
66420: CALL_OW 113
66424: GO 66466
// if GetControl ( i ) = control_manual then
66426: LD_VAR 0 5
66430: PPUSH
66431: CALL_OW 263
66435: PUSH
66436: LD_INT 1
66438: EQUAL
66439: IFFALSE 66466
// if IsDrivenBy ( i ) then
66441: LD_VAR 0 5
66445: PPUSH
66446: CALL_OW 311
66450: IFFALSE 66466
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
66452: LD_VAR 0 5
66456: PPUSH
66457: CALL_OW 311
66461: PPUSH
66462: CALL_OW 121
// end ;
66466: GO 66378
66468: POP
66469: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
66470: LD_VAR 0 2
66474: PPUSH
66475: LD_INT 95
66477: PUSH
66478: LD_EXP 123
66482: PUSH
66483: LD_VAR 0 1
66487: ARRAY
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PPUSH
66493: CALL_OW 72
66497: PUSH
66498: LD_VAR 0 2
66502: EQUAL
66503: PUSH
66504: LD_EXP 122
66508: PUSH
66509: LD_VAR 0 1
66513: ARRAY
66514: OR
66515: IFFALSE 66361
// end ; MC_Reset ( base , 20 ) ;
66517: LD_VAR 0 1
66521: PPUSH
66522: LD_INT 20
66524: PPUSH
66525: CALL 37767 0 2
// end ;
66529: LD_VAR 0 4
66533: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66534: LD_INT 0
66536: PPUSH
66537: PPUSH
66538: PPUSH
66539: PPUSH
// result := false ;
66540: LD_ADDR_VAR 0 2
66544: PUSH
66545: LD_INT 0
66547: ST_TO_ADDR
// side := GetSide ( unit ) ;
66548: LD_ADDR_VAR 0 3
66552: PUSH
66553: LD_VAR 0 1
66557: PPUSH
66558: CALL_OW 255
66562: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66563: LD_ADDR_VAR 0 4
66567: PUSH
66568: LD_VAR 0 1
66572: PPUSH
66573: CALL_OW 248
66577: ST_TO_ADDR
// case nat of 1 :
66578: LD_VAR 0 4
66582: PUSH
66583: LD_INT 1
66585: DOUBLE
66586: EQUAL
66587: IFTRUE 66591
66589: GO 66602
66591: POP
// tech := tech_lassight ; 2 :
66592: LD_ADDR_VAR 0 5
66596: PUSH
66597: LD_INT 12
66599: ST_TO_ADDR
66600: GO 66641
66602: LD_INT 2
66604: DOUBLE
66605: EQUAL
66606: IFTRUE 66610
66608: GO 66621
66610: POP
// tech := tech_mortar ; 3 :
66611: LD_ADDR_VAR 0 5
66615: PUSH
66616: LD_INT 41
66618: ST_TO_ADDR
66619: GO 66641
66621: LD_INT 3
66623: DOUBLE
66624: EQUAL
66625: IFTRUE 66629
66627: GO 66640
66629: POP
// tech := tech_bazooka ; end ;
66630: LD_ADDR_VAR 0 5
66634: PUSH
66635: LD_INT 44
66637: ST_TO_ADDR
66638: GO 66641
66640: POP
// if Researched ( side , tech ) then
66641: LD_VAR 0 3
66645: PPUSH
66646: LD_VAR 0 5
66650: PPUSH
66651: CALL_OW 325
66655: IFFALSE 66682
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66657: LD_ADDR_VAR 0 2
66661: PUSH
66662: LD_INT 5
66664: PUSH
66665: LD_INT 8
66667: PUSH
66668: LD_INT 9
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: LIST
66675: PUSH
66676: LD_VAR 0 4
66680: ARRAY
66681: ST_TO_ADDR
// end ;
66682: LD_VAR 0 2
66686: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66687: LD_INT 0
66689: PPUSH
66690: PPUSH
66691: PPUSH
// if not mines then
66692: LD_VAR 0 2
66696: NOT
66697: IFFALSE 66701
// exit ;
66699: GO 66845
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66701: LD_ADDR_VAR 0 5
66705: PUSH
66706: LD_INT 81
66708: PUSH
66709: LD_VAR 0 1
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 3
66720: PUSH
66721: LD_INT 21
66723: PUSH
66724: LD_INT 3
66726: PUSH
66727: EMPTY
66728: LIST
66729: LIST
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PPUSH
66739: CALL_OW 69
66743: ST_TO_ADDR
// for i in mines do
66744: LD_ADDR_VAR 0 4
66748: PUSH
66749: LD_VAR 0 2
66753: PUSH
66754: FOR_IN
66755: IFFALSE 66843
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66757: LD_VAR 0 4
66761: PUSH
66762: LD_INT 1
66764: ARRAY
66765: PPUSH
66766: LD_VAR 0 4
66770: PUSH
66771: LD_INT 2
66773: ARRAY
66774: PPUSH
66775: CALL_OW 458
66779: NOT
66780: IFFALSE 66784
// continue ;
66782: GO 66754
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66784: LD_VAR 0 4
66788: PUSH
66789: LD_INT 1
66791: ARRAY
66792: PPUSH
66793: LD_VAR 0 4
66797: PUSH
66798: LD_INT 2
66800: ARRAY
66801: PPUSH
66802: CALL_OW 428
66806: PUSH
66807: LD_VAR 0 5
66811: IN
66812: IFFALSE 66841
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66814: LD_VAR 0 4
66818: PUSH
66819: LD_INT 1
66821: ARRAY
66822: PPUSH
66823: LD_VAR 0 4
66827: PUSH
66828: LD_INT 2
66830: ARRAY
66831: PPUSH
66832: LD_VAR 0 1
66836: PPUSH
66837: CALL_OW 456
// end ;
66841: GO 66754
66843: POP
66844: POP
// end ;
66845: LD_VAR 0 3
66849: RET
// export function Count ( array ) ; var i ; begin
66850: LD_INT 0
66852: PPUSH
66853: PPUSH
// result := 0 ;
66854: LD_ADDR_VAR 0 2
66858: PUSH
66859: LD_INT 0
66861: ST_TO_ADDR
// for i in array do
66862: LD_ADDR_VAR 0 3
66866: PUSH
66867: LD_VAR 0 1
66871: PUSH
66872: FOR_IN
66873: IFFALSE 66897
// if i then
66875: LD_VAR 0 3
66879: IFFALSE 66895
// result := result + 1 ;
66881: LD_ADDR_VAR 0 2
66885: PUSH
66886: LD_VAR 0 2
66890: PUSH
66891: LD_INT 1
66893: PLUS
66894: ST_TO_ADDR
66895: GO 66872
66897: POP
66898: POP
// end ;
66899: LD_VAR 0 2
66903: RET
// export function IsEmpty ( building ) ; begin
66904: LD_INT 0
66906: PPUSH
// if not building then
66907: LD_VAR 0 1
66911: NOT
66912: IFFALSE 66916
// exit ;
66914: GO 66959
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66916: LD_ADDR_VAR 0 2
66920: PUSH
66921: LD_VAR 0 1
66925: PUSH
66926: LD_INT 22
66928: PUSH
66929: LD_VAR 0 1
66933: PPUSH
66934: CALL_OW 255
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: LD_INT 58
66945: PUSH
66946: EMPTY
66947: LIST
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PPUSH
66953: CALL_OW 69
66957: IN
66958: ST_TO_ADDR
// end ;
66959: LD_VAR 0 2
66963: RET
// export function IsNotFull ( building ) ; begin
66964: LD_INT 0
66966: PPUSH
// if not building then
66967: LD_VAR 0 1
66971: NOT
66972: IFFALSE 66976
// exit ;
66974: GO 66995
// result := UnitsInside ( building ) < 6 ;
66976: LD_ADDR_VAR 0 2
66980: PUSH
66981: LD_VAR 0 1
66985: PPUSH
66986: CALL_OW 313
66990: PUSH
66991: LD_INT 6
66993: LESS
66994: ST_TO_ADDR
// end ;
66995: LD_VAR 0 2
66999: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67000: LD_INT 0
67002: PPUSH
67003: PPUSH
67004: PPUSH
67005: PPUSH
// tmp := [ ] ;
67006: LD_ADDR_VAR 0 3
67010: PUSH
67011: EMPTY
67012: ST_TO_ADDR
// list := [ ] ;
67013: LD_ADDR_VAR 0 5
67017: PUSH
67018: EMPTY
67019: ST_TO_ADDR
// for i = 16 to 25 do
67020: LD_ADDR_VAR 0 4
67024: PUSH
67025: DOUBLE
67026: LD_INT 16
67028: DEC
67029: ST_TO_ADDR
67030: LD_INT 25
67032: PUSH
67033: FOR_TO
67034: IFFALSE 67107
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67036: LD_ADDR_VAR 0 3
67040: PUSH
67041: LD_VAR 0 3
67045: PUSH
67046: LD_INT 22
67048: PUSH
67049: LD_VAR 0 1
67053: PPUSH
67054: CALL_OW 255
67058: PUSH
67059: EMPTY
67060: LIST
67061: LIST
67062: PUSH
67063: LD_INT 91
67065: PUSH
67066: LD_VAR 0 1
67070: PUSH
67071: LD_INT 6
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 30
67081: PUSH
67082: LD_VAR 0 4
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: LIST
67095: PUSH
67096: EMPTY
67097: LIST
67098: PPUSH
67099: CALL_OW 69
67103: ADD
67104: ST_TO_ADDR
67105: GO 67033
67107: POP
67108: POP
// for i = 1 to tmp do
67109: LD_ADDR_VAR 0 4
67113: PUSH
67114: DOUBLE
67115: LD_INT 1
67117: DEC
67118: ST_TO_ADDR
67119: LD_VAR 0 3
67123: PUSH
67124: FOR_TO
67125: IFFALSE 67213
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67127: LD_ADDR_VAR 0 5
67131: PUSH
67132: LD_VAR 0 5
67136: PUSH
67137: LD_VAR 0 3
67141: PUSH
67142: LD_VAR 0 4
67146: ARRAY
67147: PPUSH
67148: CALL_OW 266
67152: PUSH
67153: LD_VAR 0 3
67157: PUSH
67158: LD_VAR 0 4
67162: ARRAY
67163: PPUSH
67164: CALL_OW 250
67168: PUSH
67169: LD_VAR 0 3
67173: PUSH
67174: LD_VAR 0 4
67178: ARRAY
67179: PPUSH
67180: CALL_OW 251
67184: PUSH
67185: LD_VAR 0 3
67189: PUSH
67190: LD_VAR 0 4
67194: ARRAY
67195: PPUSH
67196: CALL_OW 254
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: PUSH
67207: EMPTY
67208: LIST
67209: ADD
67210: ST_TO_ADDR
67211: GO 67124
67213: POP
67214: POP
// result := list ;
67215: LD_ADDR_VAR 0 2
67219: PUSH
67220: LD_VAR 0 5
67224: ST_TO_ADDR
// end ;
67225: LD_VAR 0 2
67229: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67230: LD_INT 0
67232: PPUSH
67233: PPUSH
67234: PPUSH
67235: PPUSH
67236: PPUSH
67237: PPUSH
67238: PPUSH
// if not factory then
67239: LD_VAR 0 1
67243: NOT
67244: IFFALSE 67248
// exit ;
67246: GO 67780
// if control = control_apeman then
67248: LD_VAR 0 4
67252: PUSH
67253: LD_INT 5
67255: EQUAL
67256: IFFALSE 67365
// begin tmp := UnitsInside ( factory ) ;
67258: LD_ADDR_VAR 0 8
67262: PUSH
67263: LD_VAR 0 1
67267: PPUSH
67268: CALL_OW 313
67272: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67273: LD_VAR 0 8
67277: PPUSH
67278: LD_INT 25
67280: PUSH
67281: LD_INT 12
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PPUSH
67288: CALL_OW 72
67292: NOT
67293: IFFALSE 67303
// control := control_manual ;
67295: LD_ADDR_VAR 0 4
67299: PUSH
67300: LD_INT 1
67302: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67303: LD_ADDR_VAR 0 8
67307: PUSH
67308: LD_VAR 0 1
67312: PPUSH
67313: CALL 67000 0 1
67317: ST_TO_ADDR
// if tmp then
67318: LD_VAR 0 8
67322: IFFALSE 67365
// begin for i in tmp do
67324: LD_ADDR_VAR 0 7
67328: PUSH
67329: LD_VAR 0 8
67333: PUSH
67334: FOR_IN
67335: IFFALSE 67363
// if i [ 1 ] = b_ext_radio then
67337: LD_VAR 0 7
67341: PUSH
67342: LD_INT 1
67344: ARRAY
67345: PUSH
67346: LD_INT 22
67348: EQUAL
67349: IFFALSE 67361
// begin control := control_remote ;
67351: LD_ADDR_VAR 0 4
67355: PUSH
67356: LD_INT 2
67358: ST_TO_ADDR
// break ;
67359: GO 67363
// end ;
67361: GO 67334
67363: POP
67364: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67365: LD_VAR 0 1
67369: PPUSH
67370: LD_VAR 0 2
67374: PPUSH
67375: LD_VAR 0 3
67379: PPUSH
67380: LD_VAR 0 4
67384: PPUSH
67385: LD_VAR 0 5
67389: PPUSH
67390: CALL_OW 448
67394: IFFALSE 67429
// begin result := [ chassis , engine , control , weapon ] ;
67396: LD_ADDR_VAR 0 6
67400: PUSH
67401: LD_VAR 0 2
67405: PUSH
67406: LD_VAR 0 3
67410: PUSH
67411: LD_VAR 0 4
67415: PUSH
67416: LD_VAR 0 5
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: LIST
67425: LIST
67426: ST_TO_ADDR
// exit ;
67427: GO 67780
// end ; _chassis := AvailableChassisList ( factory ) ;
67429: LD_ADDR_VAR 0 9
67433: PUSH
67434: LD_VAR 0 1
67438: PPUSH
67439: CALL_OW 475
67443: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67444: LD_ADDR_VAR 0 11
67448: PUSH
67449: LD_VAR 0 1
67453: PPUSH
67454: CALL_OW 476
67458: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67459: LD_ADDR_VAR 0 12
67463: PUSH
67464: LD_VAR 0 1
67468: PPUSH
67469: CALL_OW 477
67473: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67474: LD_ADDR_VAR 0 10
67478: PUSH
67479: LD_VAR 0 1
67483: PPUSH
67484: CALL_OW 478
67488: ST_TO_ADDR
// if not chassis in _chassis then
67489: LD_VAR 0 2
67493: PUSH
67494: LD_VAR 0 9
67498: IN
67499: NOT
67500: IFFALSE 67526
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67502: LD_ADDR_VAR 0 2
67506: PUSH
67507: LD_VAR 0 9
67511: PUSH
67512: LD_INT 1
67514: PPUSH
67515: LD_VAR 0 9
67519: PPUSH
67520: CALL_OW 12
67524: ARRAY
67525: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67526: LD_VAR 0 2
67530: PPUSH
67531: LD_VAR 0 3
67535: PPUSH
67536: CALL 67785 0 2
67540: NOT
67541: IFFALSE 67600
// repeat engine := _engine [ 1 ] ;
67543: LD_ADDR_VAR 0 3
67547: PUSH
67548: LD_VAR 0 11
67552: PUSH
67553: LD_INT 1
67555: ARRAY
67556: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67557: LD_ADDR_VAR 0 11
67561: PUSH
67562: LD_VAR 0 11
67566: PPUSH
67567: LD_INT 1
67569: PPUSH
67570: CALL_OW 3
67574: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67575: LD_VAR 0 2
67579: PPUSH
67580: LD_VAR 0 3
67584: PPUSH
67585: CALL 67785 0 2
67589: PUSH
67590: LD_VAR 0 11
67594: PUSH
67595: EMPTY
67596: EQUAL
67597: OR
67598: IFFALSE 67543
// if not control in _control then
67600: LD_VAR 0 4
67604: PUSH
67605: LD_VAR 0 12
67609: IN
67610: NOT
67611: IFFALSE 67637
// control := _control [ rand ( 1 , _control ) ] ;
67613: LD_ADDR_VAR 0 4
67617: PUSH
67618: LD_VAR 0 12
67622: PUSH
67623: LD_INT 1
67625: PPUSH
67626: LD_VAR 0 12
67630: PPUSH
67631: CALL_OW 12
67635: ARRAY
67636: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67637: LD_VAR 0 2
67641: PPUSH
67642: LD_VAR 0 5
67646: PPUSH
67647: CALL 68005 0 2
67651: NOT
67652: IFFALSE 67711
// repeat weapon := _weapon [ 1 ] ;
67654: LD_ADDR_VAR 0 5
67658: PUSH
67659: LD_VAR 0 10
67663: PUSH
67664: LD_INT 1
67666: ARRAY
67667: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67668: LD_ADDR_VAR 0 10
67672: PUSH
67673: LD_VAR 0 10
67677: PPUSH
67678: LD_INT 1
67680: PPUSH
67681: CALL_OW 3
67685: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67686: LD_VAR 0 2
67690: PPUSH
67691: LD_VAR 0 5
67695: PPUSH
67696: CALL 68005 0 2
67700: PUSH
67701: LD_VAR 0 10
67705: PUSH
67706: EMPTY
67707: EQUAL
67708: OR
67709: IFFALSE 67654
// result := [ ] ;
67711: LD_ADDR_VAR 0 6
67715: PUSH
67716: EMPTY
67717: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67718: LD_VAR 0 1
67722: PPUSH
67723: LD_VAR 0 2
67727: PPUSH
67728: LD_VAR 0 3
67732: PPUSH
67733: LD_VAR 0 4
67737: PPUSH
67738: LD_VAR 0 5
67742: PPUSH
67743: CALL_OW 448
67747: IFFALSE 67780
// result := [ chassis , engine , control , weapon ] ;
67749: LD_ADDR_VAR 0 6
67753: PUSH
67754: LD_VAR 0 2
67758: PUSH
67759: LD_VAR 0 3
67763: PUSH
67764: LD_VAR 0 4
67768: PUSH
67769: LD_VAR 0 5
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: ST_TO_ADDR
// end ;
67780: LD_VAR 0 6
67784: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67785: LD_INT 0
67787: PPUSH
// if not chassis or not engine then
67788: LD_VAR 0 1
67792: NOT
67793: PUSH
67794: LD_VAR 0 2
67798: NOT
67799: OR
67800: IFFALSE 67804
// exit ;
67802: GO 68000
// case engine of engine_solar :
67804: LD_VAR 0 2
67808: PUSH
67809: LD_INT 2
67811: DOUBLE
67812: EQUAL
67813: IFTRUE 67817
67815: GO 67855
67817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67818: LD_ADDR_VAR 0 3
67822: PUSH
67823: LD_INT 11
67825: PUSH
67826: LD_INT 12
67828: PUSH
67829: LD_INT 13
67831: PUSH
67832: LD_INT 14
67834: PUSH
67835: LD_INT 1
67837: PUSH
67838: LD_INT 2
67840: PUSH
67841: LD_INT 3
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: ST_TO_ADDR
67853: GO 67984
67855: LD_INT 1
67857: DOUBLE
67858: EQUAL
67859: IFTRUE 67863
67861: GO 67925
67863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67864: LD_ADDR_VAR 0 3
67868: PUSH
67869: LD_INT 11
67871: PUSH
67872: LD_INT 12
67874: PUSH
67875: LD_INT 13
67877: PUSH
67878: LD_INT 14
67880: PUSH
67881: LD_INT 1
67883: PUSH
67884: LD_INT 2
67886: PUSH
67887: LD_INT 3
67889: PUSH
67890: LD_INT 4
67892: PUSH
67893: LD_INT 5
67895: PUSH
67896: LD_INT 21
67898: PUSH
67899: LD_INT 23
67901: PUSH
67902: LD_INT 22
67904: PUSH
67905: LD_INT 24
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: LIST
67912: LIST
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: ST_TO_ADDR
67923: GO 67984
67925: LD_INT 3
67927: DOUBLE
67928: EQUAL
67929: IFTRUE 67933
67931: GO 67983
67933: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67934: LD_ADDR_VAR 0 3
67938: PUSH
67939: LD_INT 13
67941: PUSH
67942: LD_INT 14
67944: PUSH
67945: LD_INT 2
67947: PUSH
67948: LD_INT 3
67950: PUSH
67951: LD_INT 4
67953: PUSH
67954: LD_INT 5
67956: PUSH
67957: LD_INT 21
67959: PUSH
67960: LD_INT 22
67962: PUSH
67963: LD_INT 23
67965: PUSH
67966: LD_INT 24
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: LIST
67978: LIST
67979: LIST
67980: ST_TO_ADDR
67981: GO 67984
67983: POP
// result := ( chassis in result ) ;
67984: LD_ADDR_VAR 0 3
67988: PUSH
67989: LD_VAR 0 1
67993: PUSH
67994: LD_VAR 0 3
67998: IN
67999: ST_TO_ADDR
// end ;
68000: LD_VAR 0 3
68004: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68005: LD_INT 0
68007: PPUSH
// if not chassis or not weapon then
68008: LD_VAR 0 1
68012: NOT
68013: PUSH
68014: LD_VAR 0 2
68018: NOT
68019: OR
68020: IFFALSE 68024
// exit ;
68022: GO 69050
// case weapon of us_machine_gun :
68024: LD_VAR 0 2
68028: PUSH
68029: LD_INT 2
68031: DOUBLE
68032: EQUAL
68033: IFTRUE 68037
68035: GO 68067
68037: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68038: LD_ADDR_VAR 0 3
68042: PUSH
68043: LD_INT 1
68045: PUSH
68046: LD_INT 2
68048: PUSH
68049: LD_INT 3
68051: PUSH
68052: LD_INT 4
68054: PUSH
68055: LD_INT 5
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: ST_TO_ADDR
68065: GO 69034
68067: LD_INT 3
68069: DOUBLE
68070: EQUAL
68071: IFTRUE 68075
68073: GO 68105
68075: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68076: LD_ADDR_VAR 0 3
68080: PUSH
68081: LD_INT 1
68083: PUSH
68084: LD_INT 2
68086: PUSH
68087: LD_INT 3
68089: PUSH
68090: LD_INT 4
68092: PUSH
68093: LD_INT 5
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: ST_TO_ADDR
68103: GO 69034
68105: LD_INT 11
68107: DOUBLE
68108: EQUAL
68109: IFTRUE 68113
68111: GO 68143
68113: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68114: LD_ADDR_VAR 0 3
68118: PUSH
68119: LD_INT 1
68121: PUSH
68122: LD_INT 2
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: LD_INT 4
68130: PUSH
68131: LD_INT 5
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: ST_TO_ADDR
68141: GO 69034
68143: LD_INT 4
68145: DOUBLE
68146: EQUAL
68147: IFTRUE 68151
68149: GO 68177
68151: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68152: LD_ADDR_VAR 0 3
68156: PUSH
68157: LD_INT 2
68159: PUSH
68160: LD_INT 3
68162: PUSH
68163: LD_INT 4
68165: PUSH
68166: LD_INT 5
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: ST_TO_ADDR
68175: GO 69034
68177: LD_INT 5
68179: DOUBLE
68180: EQUAL
68181: IFTRUE 68185
68183: GO 68211
68185: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68186: LD_ADDR_VAR 0 3
68190: PUSH
68191: LD_INT 2
68193: PUSH
68194: LD_INT 3
68196: PUSH
68197: LD_INT 4
68199: PUSH
68200: LD_INT 5
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: ST_TO_ADDR
68209: GO 69034
68211: LD_INT 9
68213: DOUBLE
68214: EQUAL
68215: IFTRUE 68219
68217: GO 68245
68219: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68220: LD_ADDR_VAR 0 3
68224: PUSH
68225: LD_INT 2
68227: PUSH
68228: LD_INT 3
68230: PUSH
68231: LD_INT 4
68233: PUSH
68234: LD_INT 5
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: LIST
68241: LIST
68242: ST_TO_ADDR
68243: GO 69034
68245: LD_INT 7
68247: DOUBLE
68248: EQUAL
68249: IFTRUE 68253
68251: GO 68279
68253: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68254: LD_ADDR_VAR 0 3
68258: PUSH
68259: LD_INT 2
68261: PUSH
68262: LD_INT 3
68264: PUSH
68265: LD_INT 4
68267: PUSH
68268: LD_INT 5
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: ST_TO_ADDR
68277: GO 69034
68279: LD_INT 12
68281: DOUBLE
68282: EQUAL
68283: IFTRUE 68287
68285: GO 68313
68287: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68288: LD_ADDR_VAR 0 3
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: LD_INT 3
68298: PUSH
68299: LD_INT 4
68301: PUSH
68302: LD_INT 5
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: ST_TO_ADDR
68311: GO 69034
68313: LD_INT 13
68315: DOUBLE
68316: EQUAL
68317: IFTRUE 68321
68319: GO 68347
68321: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68322: LD_ADDR_VAR 0 3
68326: PUSH
68327: LD_INT 2
68329: PUSH
68330: LD_INT 3
68332: PUSH
68333: LD_INT 4
68335: PUSH
68336: LD_INT 5
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: LIST
68343: LIST
68344: ST_TO_ADDR
68345: GO 69034
68347: LD_INT 14
68349: DOUBLE
68350: EQUAL
68351: IFTRUE 68355
68353: GO 68373
68355: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68356: LD_ADDR_VAR 0 3
68360: PUSH
68361: LD_INT 4
68363: PUSH
68364: LD_INT 5
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: ST_TO_ADDR
68371: GO 69034
68373: LD_INT 6
68375: DOUBLE
68376: EQUAL
68377: IFTRUE 68381
68379: GO 68399
68381: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68382: LD_ADDR_VAR 0 3
68386: PUSH
68387: LD_INT 4
68389: PUSH
68390: LD_INT 5
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: ST_TO_ADDR
68397: GO 69034
68399: LD_INT 10
68401: DOUBLE
68402: EQUAL
68403: IFTRUE 68407
68405: GO 68425
68407: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68408: LD_ADDR_VAR 0 3
68412: PUSH
68413: LD_INT 4
68415: PUSH
68416: LD_INT 5
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: ST_TO_ADDR
68423: GO 69034
68425: LD_INT 22
68427: DOUBLE
68428: EQUAL
68429: IFTRUE 68433
68431: GO 68459
68433: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68434: LD_ADDR_VAR 0 3
68438: PUSH
68439: LD_INT 11
68441: PUSH
68442: LD_INT 12
68444: PUSH
68445: LD_INT 13
68447: PUSH
68448: LD_INT 14
68450: PUSH
68451: EMPTY
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: ST_TO_ADDR
68457: GO 69034
68459: LD_INT 23
68461: DOUBLE
68462: EQUAL
68463: IFTRUE 68467
68465: GO 68493
68467: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68468: LD_ADDR_VAR 0 3
68472: PUSH
68473: LD_INT 11
68475: PUSH
68476: LD_INT 12
68478: PUSH
68479: LD_INT 13
68481: PUSH
68482: LD_INT 14
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: ST_TO_ADDR
68491: GO 69034
68493: LD_INT 24
68495: DOUBLE
68496: EQUAL
68497: IFTRUE 68501
68499: GO 68527
68501: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68502: LD_ADDR_VAR 0 3
68506: PUSH
68507: LD_INT 11
68509: PUSH
68510: LD_INT 12
68512: PUSH
68513: LD_INT 13
68515: PUSH
68516: LD_INT 14
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: ST_TO_ADDR
68525: GO 69034
68527: LD_INT 30
68529: DOUBLE
68530: EQUAL
68531: IFTRUE 68535
68533: GO 68561
68535: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68536: LD_ADDR_VAR 0 3
68540: PUSH
68541: LD_INT 11
68543: PUSH
68544: LD_INT 12
68546: PUSH
68547: LD_INT 13
68549: PUSH
68550: LD_INT 14
68552: PUSH
68553: EMPTY
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: ST_TO_ADDR
68559: GO 69034
68561: LD_INT 25
68563: DOUBLE
68564: EQUAL
68565: IFTRUE 68569
68567: GO 68587
68569: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68570: LD_ADDR_VAR 0 3
68574: PUSH
68575: LD_INT 13
68577: PUSH
68578: LD_INT 14
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: ST_TO_ADDR
68585: GO 69034
68587: LD_INT 27
68589: DOUBLE
68590: EQUAL
68591: IFTRUE 68595
68593: GO 68613
68595: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68596: LD_ADDR_VAR 0 3
68600: PUSH
68601: LD_INT 13
68603: PUSH
68604: LD_INT 14
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: ST_TO_ADDR
68611: GO 69034
68613: LD_INT 28
68615: DOUBLE
68616: EQUAL
68617: IFTRUE 68621
68619: GO 68639
68621: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68622: LD_ADDR_VAR 0 3
68626: PUSH
68627: LD_INT 13
68629: PUSH
68630: LD_INT 14
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: ST_TO_ADDR
68637: GO 69034
68639: LD_INT 29
68641: DOUBLE
68642: EQUAL
68643: IFTRUE 68647
68645: GO 68665
68647: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68648: LD_ADDR_VAR 0 3
68652: PUSH
68653: LD_INT 13
68655: PUSH
68656: LD_INT 14
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: ST_TO_ADDR
68663: GO 69034
68665: LD_INT 31
68667: DOUBLE
68668: EQUAL
68669: IFTRUE 68673
68671: GO 68691
68673: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68674: LD_ADDR_VAR 0 3
68678: PUSH
68679: LD_INT 13
68681: PUSH
68682: LD_INT 14
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: ST_TO_ADDR
68689: GO 69034
68691: LD_INT 26
68693: DOUBLE
68694: EQUAL
68695: IFTRUE 68699
68697: GO 68717
68699: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68700: LD_ADDR_VAR 0 3
68704: PUSH
68705: LD_INT 13
68707: PUSH
68708: LD_INT 14
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: ST_TO_ADDR
68715: GO 69034
68717: LD_INT 42
68719: DOUBLE
68720: EQUAL
68721: IFTRUE 68725
68723: GO 68751
68725: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68726: LD_ADDR_VAR 0 3
68730: PUSH
68731: LD_INT 21
68733: PUSH
68734: LD_INT 22
68736: PUSH
68737: LD_INT 23
68739: PUSH
68740: LD_INT 24
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: LIST
68747: LIST
68748: ST_TO_ADDR
68749: GO 69034
68751: LD_INT 43
68753: DOUBLE
68754: EQUAL
68755: IFTRUE 68759
68757: GO 68785
68759: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68760: LD_ADDR_VAR 0 3
68764: PUSH
68765: LD_INT 21
68767: PUSH
68768: LD_INT 22
68770: PUSH
68771: LD_INT 23
68773: PUSH
68774: LD_INT 24
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: LIST
68781: LIST
68782: ST_TO_ADDR
68783: GO 69034
68785: LD_INT 44
68787: DOUBLE
68788: EQUAL
68789: IFTRUE 68793
68791: GO 68819
68793: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68794: LD_ADDR_VAR 0 3
68798: PUSH
68799: LD_INT 21
68801: PUSH
68802: LD_INT 22
68804: PUSH
68805: LD_INT 23
68807: PUSH
68808: LD_INT 24
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: ST_TO_ADDR
68817: GO 69034
68819: LD_INT 45
68821: DOUBLE
68822: EQUAL
68823: IFTRUE 68827
68825: GO 68853
68827: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68828: LD_ADDR_VAR 0 3
68832: PUSH
68833: LD_INT 21
68835: PUSH
68836: LD_INT 22
68838: PUSH
68839: LD_INT 23
68841: PUSH
68842: LD_INT 24
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: ST_TO_ADDR
68851: GO 69034
68853: LD_INT 49
68855: DOUBLE
68856: EQUAL
68857: IFTRUE 68861
68859: GO 68887
68861: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68862: LD_ADDR_VAR 0 3
68866: PUSH
68867: LD_INT 21
68869: PUSH
68870: LD_INT 22
68872: PUSH
68873: LD_INT 23
68875: PUSH
68876: LD_INT 24
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: LIST
68883: LIST
68884: ST_TO_ADDR
68885: GO 69034
68887: LD_INT 51
68889: DOUBLE
68890: EQUAL
68891: IFTRUE 68895
68893: GO 68921
68895: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68896: LD_ADDR_VAR 0 3
68900: PUSH
68901: LD_INT 21
68903: PUSH
68904: LD_INT 22
68906: PUSH
68907: LD_INT 23
68909: PUSH
68910: LD_INT 24
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: ST_TO_ADDR
68919: GO 69034
68921: LD_INT 52
68923: DOUBLE
68924: EQUAL
68925: IFTRUE 68929
68927: GO 68955
68929: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68930: LD_ADDR_VAR 0 3
68934: PUSH
68935: LD_INT 21
68937: PUSH
68938: LD_INT 22
68940: PUSH
68941: LD_INT 23
68943: PUSH
68944: LD_INT 24
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: ST_TO_ADDR
68953: GO 69034
68955: LD_INT 53
68957: DOUBLE
68958: EQUAL
68959: IFTRUE 68963
68961: GO 68981
68963: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68964: LD_ADDR_VAR 0 3
68968: PUSH
68969: LD_INT 23
68971: PUSH
68972: LD_INT 24
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: ST_TO_ADDR
68979: GO 69034
68981: LD_INT 46
68983: DOUBLE
68984: EQUAL
68985: IFTRUE 68989
68987: GO 69007
68989: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
68990: LD_ADDR_VAR 0 3
68994: PUSH
68995: LD_INT 23
68997: PUSH
68998: LD_INT 24
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: ST_TO_ADDR
69005: GO 69034
69007: LD_INT 47
69009: DOUBLE
69010: EQUAL
69011: IFTRUE 69015
69013: GO 69033
69015: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_INT 23
69023: PUSH
69024: LD_INT 24
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: ST_TO_ADDR
69031: GO 69034
69033: POP
// result := ( chassis in result ) ;
69034: LD_ADDR_VAR 0 3
69038: PUSH
69039: LD_VAR 0 1
69043: PUSH
69044: LD_VAR 0 3
69048: IN
69049: ST_TO_ADDR
// end ;
69050: LD_VAR 0 3
69054: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69055: LD_INT 0
69057: PPUSH
69058: PPUSH
69059: PPUSH
69060: PPUSH
69061: PPUSH
69062: PPUSH
69063: PPUSH
// result := array ;
69064: LD_ADDR_VAR 0 5
69068: PUSH
69069: LD_VAR 0 1
69073: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69074: LD_VAR 0 1
69078: NOT
69079: PUSH
69080: LD_VAR 0 2
69084: NOT
69085: OR
69086: PUSH
69087: LD_VAR 0 3
69091: NOT
69092: OR
69093: PUSH
69094: LD_VAR 0 2
69098: PUSH
69099: LD_VAR 0 1
69103: GREATER
69104: OR
69105: PUSH
69106: LD_VAR 0 3
69110: PUSH
69111: LD_VAR 0 1
69115: GREATER
69116: OR
69117: IFFALSE 69121
// exit ;
69119: GO 69417
// if direction then
69121: LD_VAR 0 4
69125: IFFALSE 69189
// begin d := 1 ;
69127: LD_ADDR_VAR 0 9
69131: PUSH
69132: LD_INT 1
69134: ST_TO_ADDR
// if i_from > i_to then
69135: LD_VAR 0 2
69139: PUSH
69140: LD_VAR 0 3
69144: GREATER
69145: IFFALSE 69171
// length := ( array - i_from ) + i_to else
69147: LD_ADDR_VAR 0 11
69151: PUSH
69152: LD_VAR 0 1
69156: PUSH
69157: LD_VAR 0 2
69161: MINUS
69162: PUSH
69163: LD_VAR 0 3
69167: PLUS
69168: ST_TO_ADDR
69169: GO 69187
// length := i_to - i_from ;
69171: LD_ADDR_VAR 0 11
69175: PUSH
69176: LD_VAR 0 3
69180: PUSH
69181: LD_VAR 0 2
69185: MINUS
69186: ST_TO_ADDR
// end else
69187: GO 69250
// begin d := - 1 ;
69189: LD_ADDR_VAR 0 9
69193: PUSH
69194: LD_INT 1
69196: NEG
69197: ST_TO_ADDR
// if i_from > i_to then
69198: LD_VAR 0 2
69202: PUSH
69203: LD_VAR 0 3
69207: GREATER
69208: IFFALSE 69228
// length := i_from - i_to else
69210: LD_ADDR_VAR 0 11
69214: PUSH
69215: LD_VAR 0 2
69219: PUSH
69220: LD_VAR 0 3
69224: MINUS
69225: ST_TO_ADDR
69226: GO 69250
// length := ( array - i_to ) + i_from ;
69228: LD_ADDR_VAR 0 11
69232: PUSH
69233: LD_VAR 0 1
69237: PUSH
69238: LD_VAR 0 3
69242: MINUS
69243: PUSH
69244: LD_VAR 0 2
69248: PLUS
69249: ST_TO_ADDR
// end ; if not length then
69250: LD_VAR 0 11
69254: NOT
69255: IFFALSE 69259
// exit ;
69257: GO 69417
// tmp := array ;
69259: LD_ADDR_VAR 0 10
69263: PUSH
69264: LD_VAR 0 1
69268: ST_TO_ADDR
// for i = 1 to length do
69269: LD_ADDR_VAR 0 6
69273: PUSH
69274: DOUBLE
69275: LD_INT 1
69277: DEC
69278: ST_TO_ADDR
69279: LD_VAR 0 11
69283: PUSH
69284: FOR_TO
69285: IFFALSE 69405
// begin for j = 1 to array do
69287: LD_ADDR_VAR 0 7
69291: PUSH
69292: DOUBLE
69293: LD_INT 1
69295: DEC
69296: ST_TO_ADDR
69297: LD_VAR 0 1
69301: PUSH
69302: FOR_TO
69303: IFFALSE 69391
// begin k := j + d ;
69305: LD_ADDR_VAR 0 8
69309: PUSH
69310: LD_VAR 0 7
69314: PUSH
69315: LD_VAR 0 9
69319: PLUS
69320: ST_TO_ADDR
// if k > array then
69321: LD_VAR 0 8
69325: PUSH
69326: LD_VAR 0 1
69330: GREATER
69331: IFFALSE 69341
// k := 1 ;
69333: LD_ADDR_VAR 0 8
69337: PUSH
69338: LD_INT 1
69340: ST_TO_ADDR
// if not k then
69341: LD_VAR 0 8
69345: NOT
69346: IFFALSE 69358
// k := array ;
69348: LD_ADDR_VAR 0 8
69352: PUSH
69353: LD_VAR 0 1
69357: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69358: LD_ADDR_VAR 0 10
69362: PUSH
69363: LD_VAR 0 10
69367: PPUSH
69368: LD_VAR 0 8
69372: PPUSH
69373: LD_VAR 0 1
69377: PUSH
69378: LD_VAR 0 7
69382: ARRAY
69383: PPUSH
69384: CALL_OW 1
69388: ST_TO_ADDR
// end ;
69389: GO 69302
69391: POP
69392: POP
// array := tmp ;
69393: LD_ADDR_VAR 0 1
69397: PUSH
69398: LD_VAR 0 10
69402: ST_TO_ADDR
// end ;
69403: GO 69284
69405: POP
69406: POP
// result := array ;
69407: LD_ADDR_VAR 0 5
69411: PUSH
69412: LD_VAR 0 1
69416: ST_TO_ADDR
// end ;
69417: LD_VAR 0 5
69421: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69422: LD_INT 0
69424: PPUSH
69425: PPUSH
// result := 0 ;
69426: LD_ADDR_VAR 0 3
69430: PUSH
69431: LD_INT 0
69433: ST_TO_ADDR
// if not array or not value in array then
69434: LD_VAR 0 1
69438: NOT
69439: PUSH
69440: LD_VAR 0 2
69444: PUSH
69445: LD_VAR 0 1
69449: IN
69450: NOT
69451: OR
69452: IFFALSE 69456
// exit ;
69454: GO 69510
// for i = 1 to array do
69456: LD_ADDR_VAR 0 4
69460: PUSH
69461: DOUBLE
69462: LD_INT 1
69464: DEC
69465: ST_TO_ADDR
69466: LD_VAR 0 1
69470: PUSH
69471: FOR_TO
69472: IFFALSE 69508
// if value = array [ i ] then
69474: LD_VAR 0 2
69478: PUSH
69479: LD_VAR 0 1
69483: PUSH
69484: LD_VAR 0 4
69488: ARRAY
69489: EQUAL
69490: IFFALSE 69506
// begin result := i ;
69492: LD_ADDR_VAR 0 3
69496: PUSH
69497: LD_VAR 0 4
69501: ST_TO_ADDR
// exit ;
69502: POP
69503: POP
69504: GO 69510
// end ;
69506: GO 69471
69508: POP
69509: POP
// end ;
69510: LD_VAR 0 3
69514: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69515: LD_INT 0
69517: PPUSH
// vc_chassis := chassis ;
69518: LD_ADDR_OWVAR 37
69522: PUSH
69523: LD_VAR 0 1
69527: ST_TO_ADDR
// vc_engine := engine ;
69528: LD_ADDR_OWVAR 39
69532: PUSH
69533: LD_VAR 0 2
69537: ST_TO_ADDR
// vc_control := control ;
69538: LD_ADDR_OWVAR 38
69542: PUSH
69543: LD_VAR 0 3
69547: ST_TO_ADDR
// vc_weapon := weapon ;
69548: LD_ADDR_OWVAR 40
69552: PUSH
69553: LD_VAR 0 4
69557: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69558: LD_ADDR_OWVAR 41
69562: PUSH
69563: LD_VAR 0 5
69567: ST_TO_ADDR
// end ;
69568: LD_VAR 0 6
69572: RET
// export function WantPlant ( unit ) ; var task ; begin
69573: LD_INT 0
69575: PPUSH
69576: PPUSH
// result := false ;
69577: LD_ADDR_VAR 0 2
69581: PUSH
69582: LD_INT 0
69584: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69585: LD_ADDR_VAR 0 3
69589: PUSH
69590: LD_VAR 0 1
69594: PPUSH
69595: CALL_OW 437
69599: ST_TO_ADDR
// if task then
69600: LD_VAR 0 3
69604: IFFALSE 69632
// if task [ 1 ] [ 1 ] = p then
69606: LD_VAR 0 3
69610: PUSH
69611: LD_INT 1
69613: ARRAY
69614: PUSH
69615: LD_INT 1
69617: ARRAY
69618: PUSH
69619: LD_STRING p
69621: EQUAL
69622: IFFALSE 69632
// result := true ;
69624: LD_ADDR_VAR 0 2
69628: PUSH
69629: LD_INT 1
69631: ST_TO_ADDR
// end ;
69632: LD_VAR 0 2
69636: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69637: LD_INT 0
69639: PPUSH
69640: PPUSH
69641: PPUSH
69642: PPUSH
// if pos < 1 then
69643: LD_VAR 0 2
69647: PUSH
69648: LD_INT 1
69650: LESS
69651: IFFALSE 69655
// exit ;
69653: GO 69958
// if pos = 1 then
69655: LD_VAR 0 2
69659: PUSH
69660: LD_INT 1
69662: EQUAL
69663: IFFALSE 69696
// result := Replace ( arr , pos [ 1 ] , value ) else
69665: LD_ADDR_VAR 0 4
69669: PUSH
69670: LD_VAR 0 1
69674: PPUSH
69675: LD_VAR 0 2
69679: PUSH
69680: LD_INT 1
69682: ARRAY
69683: PPUSH
69684: LD_VAR 0 3
69688: PPUSH
69689: CALL_OW 1
69693: ST_TO_ADDR
69694: GO 69958
// begin tmp := arr ;
69696: LD_ADDR_VAR 0 6
69700: PUSH
69701: LD_VAR 0 1
69705: ST_TO_ADDR
// s_arr := [ tmp ] ;
69706: LD_ADDR_VAR 0 7
69710: PUSH
69711: LD_VAR 0 6
69715: PUSH
69716: EMPTY
69717: LIST
69718: ST_TO_ADDR
// for i = 1 to pos - 1 do
69719: LD_ADDR_VAR 0 5
69723: PUSH
69724: DOUBLE
69725: LD_INT 1
69727: DEC
69728: ST_TO_ADDR
69729: LD_VAR 0 2
69733: PUSH
69734: LD_INT 1
69736: MINUS
69737: PUSH
69738: FOR_TO
69739: IFFALSE 69784
// begin tmp := tmp [ pos [ i ] ] ;
69741: LD_ADDR_VAR 0 6
69745: PUSH
69746: LD_VAR 0 6
69750: PUSH
69751: LD_VAR 0 2
69755: PUSH
69756: LD_VAR 0 5
69760: ARRAY
69761: ARRAY
69762: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69763: LD_ADDR_VAR 0 7
69767: PUSH
69768: LD_VAR 0 7
69772: PUSH
69773: LD_VAR 0 6
69777: PUSH
69778: EMPTY
69779: LIST
69780: ADD
69781: ST_TO_ADDR
// end ;
69782: GO 69738
69784: POP
69785: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69786: LD_ADDR_VAR 0 6
69790: PUSH
69791: LD_VAR 0 6
69795: PPUSH
69796: LD_VAR 0 2
69800: PUSH
69801: LD_VAR 0 2
69805: ARRAY
69806: PPUSH
69807: LD_VAR 0 3
69811: PPUSH
69812: CALL_OW 1
69816: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69817: LD_ADDR_VAR 0 7
69821: PUSH
69822: LD_VAR 0 7
69826: PPUSH
69827: LD_VAR 0 7
69831: PPUSH
69832: LD_VAR 0 6
69836: PPUSH
69837: CALL_OW 1
69841: ST_TO_ADDR
// for i = s_arr downto 2 do
69842: LD_ADDR_VAR 0 5
69846: PUSH
69847: DOUBLE
69848: LD_VAR 0 7
69852: INC
69853: ST_TO_ADDR
69854: LD_INT 2
69856: PUSH
69857: FOR_DOWNTO
69858: IFFALSE 69942
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69860: LD_ADDR_VAR 0 6
69864: PUSH
69865: LD_VAR 0 7
69869: PUSH
69870: LD_VAR 0 5
69874: PUSH
69875: LD_INT 1
69877: MINUS
69878: ARRAY
69879: PPUSH
69880: LD_VAR 0 2
69884: PUSH
69885: LD_VAR 0 5
69889: PUSH
69890: LD_INT 1
69892: MINUS
69893: ARRAY
69894: PPUSH
69895: LD_VAR 0 7
69899: PUSH
69900: LD_VAR 0 5
69904: ARRAY
69905: PPUSH
69906: CALL_OW 1
69910: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69911: LD_ADDR_VAR 0 7
69915: PUSH
69916: LD_VAR 0 7
69920: PPUSH
69921: LD_VAR 0 5
69925: PUSH
69926: LD_INT 1
69928: MINUS
69929: PPUSH
69930: LD_VAR 0 6
69934: PPUSH
69935: CALL_OW 1
69939: ST_TO_ADDR
// end ;
69940: GO 69857
69942: POP
69943: POP
// result := s_arr [ 1 ] ;
69944: LD_ADDR_VAR 0 4
69948: PUSH
69949: LD_VAR 0 7
69953: PUSH
69954: LD_INT 1
69956: ARRAY
69957: ST_TO_ADDR
// end ; end ;
69958: LD_VAR 0 4
69962: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69963: LD_INT 0
69965: PPUSH
69966: PPUSH
// if not list then
69967: LD_VAR 0 1
69971: NOT
69972: IFFALSE 69976
// exit ;
69974: GO 70067
// i := list [ pos1 ] ;
69976: LD_ADDR_VAR 0 5
69980: PUSH
69981: LD_VAR 0 1
69985: PUSH
69986: LD_VAR 0 2
69990: ARRAY
69991: ST_TO_ADDR
// if not i then
69992: LD_VAR 0 5
69996: NOT
69997: IFFALSE 70001
// exit ;
69999: GO 70067
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70001: LD_ADDR_VAR 0 1
70005: PUSH
70006: LD_VAR 0 1
70010: PPUSH
70011: LD_VAR 0 2
70015: PPUSH
70016: LD_VAR 0 1
70020: PUSH
70021: LD_VAR 0 3
70025: ARRAY
70026: PPUSH
70027: CALL_OW 1
70031: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70032: LD_ADDR_VAR 0 1
70036: PUSH
70037: LD_VAR 0 1
70041: PPUSH
70042: LD_VAR 0 3
70046: PPUSH
70047: LD_VAR 0 5
70051: PPUSH
70052: CALL_OW 1
70056: ST_TO_ADDR
// result := list ;
70057: LD_ADDR_VAR 0 4
70061: PUSH
70062: LD_VAR 0 1
70066: ST_TO_ADDR
// end ;
70067: LD_VAR 0 4
70071: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70072: LD_INT 0
70074: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70075: LD_ADDR_VAR 0 5
70079: PUSH
70080: LD_VAR 0 1
70084: PPUSH
70085: CALL_OW 250
70089: PPUSH
70090: LD_VAR 0 1
70094: PPUSH
70095: CALL_OW 251
70099: PPUSH
70100: LD_VAR 0 2
70104: PPUSH
70105: LD_VAR 0 3
70109: PPUSH
70110: LD_VAR 0 4
70114: PPUSH
70115: CALL 70125 0 5
70119: ST_TO_ADDR
// end ;
70120: LD_VAR 0 5
70124: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70125: LD_INT 0
70127: PPUSH
70128: PPUSH
70129: PPUSH
70130: PPUSH
// if not list then
70131: LD_VAR 0 3
70135: NOT
70136: IFFALSE 70140
// exit ;
70138: GO 70528
// result := [ ] ;
70140: LD_ADDR_VAR 0 6
70144: PUSH
70145: EMPTY
70146: ST_TO_ADDR
// for i in list do
70147: LD_ADDR_VAR 0 7
70151: PUSH
70152: LD_VAR 0 3
70156: PUSH
70157: FOR_IN
70158: IFFALSE 70360
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70160: LD_ADDR_VAR 0 9
70164: PUSH
70165: LD_VAR 0 7
70169: PPUSH
70170: LD_VAR 0 1
70174: PPUSH
70175: LD_VAR 0 2
70179: PPUSH
70180: CALL_OW 297
70184: ST_TO_ADDR
// if not result then
70185: LD_VAR 0 6
70189: NOT
70190: IFFALSE 70216
// result := [ [ i , tmp ] ] else
70192: LD_ADDR_VAR 0 6
70196: PUSH
70197: LD_VAR 0 7
70201: PUSH
70202: LD_VAR 0 9
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: EMPTY
70212: LIST
70213: ST_TO_ADDR
70214: GO 70358
// begin if result [ result ] [ 2 ] < tmp then
70216: LD_VAR 0 6
70220: PUSH
70221: LD_VAR 0 6
70225: ARRAY
70226: PUSH
70227: LD_INT 2
70229: ARRAY
70230: PUSH
70231: LD_VAR 0 9
70235: LESS
70236: IFFALSE 70278
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70238: LD_ADDR_VAR 0 6
70242: PUSH
70243: LD_VAR 0 6
70247: PPUSH
70248: LD_VAR 0 6
70252: PUSH
70253: LD_INT 1
70255: PLUS
70256: PPUSH
70257: LD_VAR 0 7
70261: PUSH
70262: LD_VAR 0 9
70266: PUSH
70267: EMPTY
70268: LIST
70269: LIST
70270: PPUSH
70271: CALL_OW 2
70275: ST_TO_ADDR
70276: GO 70358
// for j = 1 to result do
70278: LD_ADDR_VAR 0 8
70282: PUSH
70283: DOUBLE
70284: LD_INT 1
70286: DEC
70287: ST_TO_ADDR
70288: LD_VAR 0 6
70292: PUSH
70293: FOR_TO
70294: IFFALSE 70356
// begin if tmp < result [ j ] [ 2 ] then
70296: LD_VAR 0 9
70300: PUSH
70301: LD_VAR 0 6
70305: PUSH
70306: LD_VAR 0 8
70310: ARRAY
70311: PUSH
70312: LD_INT 2
70314: ARRAY
70315: LESS
70316: IFFALSE 70354
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70318: LD_ADDR_VAR 0 6
70322: PUSH
70323: LD_VAR 0 6
70327: PPUSH
70328: LD_VAR 0 8
70332: PPUSH
70333: LD_VAR 0 7
70337: PUSH
70338: LD_VAR 0 9
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PPUSH
70347: CALL_OW 2
70351: ST_TO_ADDR
// break ;
70352: GO 70356
// end ; end ;
70354: GO 70293
70356: POP
70357: POP
// end ; end ;
70358: GO 70157
70360: POP
70361: POP
// if result and not asc then
70362: LD_VAR 0 6
70366: PUSH
70367: LD_VAR 0 4
70371: NOT
70372: AND
70373: IFFALSE 70448
// begin tmp := result ;
70375: LD_ADDR_VAR 0 9
70379: PUSH
70380: LD_VAR 0 6
70384: ST_TO_ADDR
// for i = tmp downto 1 do
70385: LD_ADDR_VAR 0 7
70389: PUSH
70390: DOUBLE
70391: LD_VAR 0 9
70395: INC
70396: ST_TO_ADDR
70397: LD_INT 1
70399: PUSH
70400: FOR_DOWNTO
70401: IFFALSE 70446
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70403: LD_ADDR_VAR 0 6
70407: PUSH
70408: LD_VAR 0 6
70412: PPUSH
70413: LD_VAR 0 9
70417: PUSH
70418: LD_VAR 0 7
70422: MINUS
70423: PUSH
70424: LD_INT 1
70426: PLUS
70427: PPUSH
70428: LD_VAR 0 9
70432: PUSH
70433: LD_VAR 0 7
70437: ARRAY
70438: PPUSH
70439: CALL_OW 1
70443: ST_TO_ADDR
70444: GO 70400
70446: POP
70447: POP
// end ; tmp := [ ] ;
70448: LD_ADDR_VAR 0 9
70452: PUSH
70453: EMPTY
70454: ST_TO_ADDR
// if mode then
70455: LD_VAR 0 5
70459: IFFALSE 70528
// begin for i = 1 to result do
70461: LD_ADDR_VAR 0 7
70465: PUSH
70466: DOUBLE
70467: LD_INT 1
70469: DEC
70470: ST_TO_ADDR
70471: LD_VAR 0 6
70475: PUSH
70476: FOR_TO
70477: IFFALSE 70516
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70479: LD_ADDR_VAR 0 9
70483: PUSH
70484: LD_VAR 0 9
70488: PPUSH
70489: LD_VAR 0 7
70493: PPUSH
70494: LD_VAR 0 6
70498: PUSH
70499: LD_VAR 0 7
70503: ARRAY
70504: PUSH
70505: LD_INT 1
70507: ARRAY
70508: PPUSH
70509: CALL_OW 1
70513: ST_TO_ADDR
70514: GO 70476
70516: POP
70517: POP
// result := tmp ;
70518: LD_ADDR_VAR 0 6
70522: PUSH
70523: LD_VAR 0 9
70527: ST_TO_ADDR
// end ; end ;
70528: LD_VAR 0 6
70532: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70533: LD_INT 0
70535: PPUSH
70536: PPUSH
70537: PPUSH
70538: PPUSH
70539: PPUSH
70540: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70541: LD_ADDR_VAR 0 5
70545: PUSH
70546: LD_INT 0
70548: PUSH
70549: LD_INT 0
70551: PUSH
70552: LD_INT 0
70554: PUSH
70555: EMPTY
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: ST_TO_ADDR
// if not x or not y then
70563: LD_VAR 0 2
70567: NOT
70568: PUSH
70569: LD_VAR 0 3
70573: NOT
70574: OR
70575: IFFALSE 70579
// exit ;
70577: GO 72225
// if not range then
70579: LD_VAR 0 4
70583: NOT
70584: IFFALSE 70594
// range := 10 ;
70586: LD_ADDR_VAR 0 4
70590: PUSH
70591: LD_INT 10
70593: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70594: LD_ADDR_VAR 0 8
70598: PUSH
70599: LD_INT 81
70601: PUSH
70602: LD_VAR 0 1
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 92
70613: PUSH
70614: LD_VAR 0 2
70618: PUSH
70619: LD_VAR 0 3
70623: PUSH
70624: LD_VAR 0 4
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 3
70637: PUSH
70638: LD_INT 21
70640: PUSH
70641: LD_INT 3
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: EMPTY
70649: LIST
70650: LIST
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: LIST
70656: PPUSH
70657: CALL_OW 69
70661: ST_TO_ADDR
// if not tmp then
70662: LD_VAR 0 8
70666: NOT
70667: IFFALSE 70671
// exit ;
70669: GO 72225
// for i in tmp do
70671: LD_ADDR_VAR 0 6
70675: PUSH
70676: LD_VAR 0 8
70680: PUSH
70681: FOR_IN
70682: IFFALSE 72200
// begin points := [ 0 , 0 , 0 ] ;
70684: LD_ADDR_VAR 0 9
70688: PUSH
70689: LD_INT 0
70691: PUSH
70692: LD_INT 0
70694: PUSH
70695: LD_INT 0
70697: PUSH
70698: EMPTY
70699: LIST
70700: LIST
70701: LIST
70702: ST_TO_ADDR
// bpoints := 1 ;
70703: LD_ADDR_VAR 0 10
70707: PUSH
70708: LD_INT 1
70710: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70711: LD_VAR 0 6
70715: PPUSH
70716: CALL_OW 247
70720: PUSH
70721: LD_INT 1
70723: DOUBLE
70724: EQUAL
70725: IFTRUE 70729
70727: GO 71307
70729: POP
// begin if GetClass ( i ) = 1 then
70730: LD_VAR 0 6
70734: PPUSH
70735: CALL_OW 257
70739: PUSH
70740: LD_INT 1
70742: EQUAL
70743: IFFALSE 70764
// points := [ 10 , 5 , 3 ] ;
70745: LD_ADDR_VAR 0 9
70749: PUSH
70750: LD_INT 10
70752: PUSH
70753: LD_INT 5
70755: PUSH
70756: LD_INT 3
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: LIST
70763: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70764: LD_VAR 0 6
70768: PPUSH
70769: CALL_OW 257
70773: PUSH
70774: LD_INT 2
70776: PUSH
70777: LD_INT 3
70779: PUSH
70780: LD_INT 4
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: LIST
70787: IN
70788: IFFALSE 70809
// points := [ 3 , 2 , 1 ] ;
70790: LD_ADDR_VAR 0 9
70794: PUSH
70795: LD_INT 3
70797: PUSH
70798: LD_INT 2
70800: PUSH
70801: LD_INT 1
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: LIST
70808: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70809: LD_VAR 0 6
70813: PPUSH
70814: CALL_OW 257
70818: PUSH
70819: LD_INT 5
70821: EQUAL
70822: IFFALSE 70843
// points := [ 130 , 5 , 2 ] ;
70824: LD_ADDR_VAR 0 9
70828: PUSH
70829: LD_INT 130
70831: PUSH
70832: LD_INT 5
70834: PUSH
70835: LD_INT 2
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: LIST
70842: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70843: LD_VAR 0 6
70847: PPUSH
70848: CALL_OW 257
70852: PUSH
70853: LD_INT 8
70855: EQUAL
70856: IFFALSE 70877
// points := [ 35 , 35 , 30 ] ;
70858: LD_ADDR_VAR 0 9
70862: PUSH
70863: LD_INT 35
70865: PUSH
70866: LD_INT 35
70868: PUSH
70869: LD_INT 30
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: LIST
70876: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70877: LD_VAR 0 6
70881: PPUSH
70882: CALL_OW 257
70886: PUSH
70887: LD_INT 9
70889: EQUAL
70890: IFFALSE 70911
// points := [ 20 , 55 , 40 ] ;
70892: LD_ADDR_VAR 0 9
70896: PUSH
70897: LD_INT 20
70899: PUSH
70900: LD_INT 55
70902: PUSH
70903: LD_INT 40
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: LIST
70910: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70911: LD_VAR 0 6
70915: PPUSH
70916: CALL_OW 257
70920: PUSH
70921: LD_INT 12
70923: PUSH
70924: LD_INT 16
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: IN
70931: IFFALSE 70952
// points := [ 5 , 3 , 2 ] ;
70933: LD_ADDR_VAR 0 9
70937: PUSH
70938: LD_INT 5
70940: PUSH
70941: LD_INT 3
70943: PUSH
70944: LD_INT 2
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: LIST
70951: ST_TO_ADDR
// if GetClass ( i ) = 17 then
70952: LD_VAR 0 6
70956: PPUSH
70957: CALL_OW 257
70961: PUSH
70962: LD_INT 17
70964: EQUAL
70965: IFFALSE 70986
// points := [ 100 , 50 , 75 ] ;
70967: LD_ADDR_VAR 0 9
70971: PUSH
70972: LD_INT 100
70974: PUSH
70975: LD_INT 50
70977: PUSH
70978: LD_INT 75
70980: PUSH
70981: EMPTY
70982: LIST
70983: LIST
70984: LIST
70985: ST_TO_ADDR
// if GetClass ( i ) = 15 then
70986: LD_VAR 0 6
70990: PPUSH
70991: CALL_OW 257
70995: PUSH
70996: LD_INT 15
70998: EQUAL
70999: IFFALSE 71020
// points := [ 10 , 5 , 3 ] ;
71001: LD_ADDR_VAR 0 9
71005: PUSH
71006: LD_INT 10
71008: PUSH
71009: LD_INT 5
71011: PUSH
71012: LD_INT 3
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: LIST
71019: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71020: LD_VAR 0 6
71024: PPUSH
71025: CALL_OW 257
71029: PUSH
71030: LD_INT 14
71032: EQUAL
71033: IFFALSE 71054
// points := [ 10 , 0 , 0 ] ;
71035: LD_ADDR_VAR 0 9
71039: PUSH
71040: LD_INT 10
71042: PUSH
71043: LD_INT 0
71045: PUSH
71046: LD_INT 0
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: LIST
71053: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71054: LD_VAR 0 6
71058: PPUSH
71059: CALL_OW 257
71063: PUSH
71064: LD_INT 11
71066: EQUAL
71067: IFFALSE 71088
// points := [ 30 , 10 , 5 ] ;
71069: LD_ADDR_VAR 0 9
71073: PUSH
71074: LD_INT 30
71076: PUSH
71077: LD_INT 10
71079: PUSH
71080: LD_INT 5
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71088: LD_VAR 0 1
71092: PPUSH
71093: LD_INT 5
71095: PPUSH
71096: CALL_OW 321
71100: PUSH
71101: LD_INT 2
71103: EQUAL
71104: IFFALSE 71121
// bpoints := bpoints * 1.8 ;
71106: LD_ADDR_VAR 0 10
71110: PUSH
71111: LD_VAR 0 10
71115: PUSH
71116: LD_REAL  1.80000000000000E+0000
71119: MUL
71120: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71121: LD_VAR 0 6
71125: PPUSH
71126: CALL_OW 257
71130: PUSH
71131: LD_INT 1
71133: PUSH
71134: LD_INT 2
71136: PUSH
71137: LD_INT 3
71139: PUSH
71140: LD_INT 4
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: IN
71149: PUSH
71150: LD_VAR 0 1
71154: PPUSH
71155: LD_INT 51
71157: PPUSH
71158: CALL_OW 321
71162: PUSH
71163: LD_INT 2
71165: EQUAL
71166: AND
71167: IFFALSE 71184
// bpoints := bpoints * 1.2 ;
71169: LD_ADDR_VAR 0 10
71173: PUSH
71174: LD_VAR 0 10
71178: PUSH
71179: LD_REAL  1.20000000000000E+0000
71182: MUL
71183: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71184: LD_VAR 0 6
71188: PPUSH
71189: CALL_OW 257
71193: PUSH
71194: LD_INT 5
71196: PUSH
71197: LD_INT 7
71199: PUSH
71200: LD_INT 9
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: LIST
71207: IN
71208: PUSH
71209: LD_VAR 0 1
71213: PPUSH
71214: LD_INT 52
71216: PPUSH
71217: CALL_OW 321
71221: PUSH
71222: LD_INT 2
71224: EQUAL
71225: AND
71226: IFFALSE 71243
// bpoints := bpoints * 1.5 ;
71228: LD_ADDR_VAR 0 10
71232: PUSH
71233: LD_VAR 0 10
71237: PUSH
71238: LD_REAL  1.50000000000000E+0000
71241: MUL
71242: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71243: LD_VAR 0 1
71247: PPUSH
71248: LD_INT 66
71250: PPUSH
71251: CALL_OW 321
71255: PUSH
71256: LD_INT 2
71258: EQUAL
71259: IFFALSE 71276
// bpoints := bpoints * 1.1 ;
71261: LD_ADDR_VAR 0 10
71265: PUSH
71266: LD_VAR 0 10
71270: PUSH
71271: LD_REAL  1.10000000000000E+0000
71274: MUL
71275: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71276: LD_ADDR_VAR 0 10
71280: PUSH
71281: LD_VAR 0 10
71285: PUSH
71286: LD_VAR 0 6
71290: PPUSH
71291: LD_INT 1
71293: PPUSH
71294: CALL_OW 259
71298: PUSH
71299: LD_REAL  1.15000000000000E+0000
71302: MUL
71303: MUL
71304: ST_TO_ADDR
// end ; unit_vehicle :
71305: GO 72129
71307: LD_INT 2
71309: DOUBLE
71310: EQUAL
71311: IFTRUE 71315
71313: GO 72117
71315: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71316: LD_VAR 0 6
71320: PPUSH
71321: CALL_OW 264
71325: PUSH
71326: LD_INT 2
71328: PUSH
71329: LD_INT 42
71331: PUSH
71332: LD_INT 24
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: LIST
71339: IN
71340: IFFALSE 71361
// points := [ 25 , 5 , 3 ] ;
71342: LD_ADDR_VAR 0 9
71346: PUSH
71347: LD_INT 25
71349: PUSH
71350: LD_INT 5
71352: PUSH
71353: LD_INT 3
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: LIST
71360: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71361: LD_VAR 0 6
71365: PPUSH
71366: CALL_OW 264
71370: PUSH
71371: LD_INT 4
71373: PUSH
71374: LD_INT 43
71376: PUSH
71377: LD_INT 25
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: LIST
71384: IN
71385: IFFALSE 71406
// points := [ 40 , 15 , 5 ] ;
71387: LD_ADDR_VAR 0 9
71391: PUSH
71392: LD_INT 40
71394: PUSH
71395: LD_INT 15
71397: PUSH
71398: LD_INT 5
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: LIST
71405: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71406: LD_VAR 0 6
71410: PPUSH
71411: CALL_OW 264
71415: PUSH
71416: LD_INT 3
71418: PUSH
71419: LD_INT 23
71421: PUSH
71422: EMPTY
71423: LIST
71424: LIST
71425: IN
71426: IFFALSE 71447
// points := [ 7 , 25 , 8 ] ;
71428: LD_ADDR_VAR 0 9
71432: PUSH
71433: LD_INT 7
71435: PUSH
71436: LD_INT 25
71438: PUSH
71439: LD_INT 8
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: LIST
71446: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71447: LD_VAR 0 6
71451: PPUSH
71452: CALL_OW 264
71456: PUSH
71457: LD_INT 5
71459: PUSH
71460: LD_INT 27
71462: PUSH
71463: LD_INT 44
71465: PUSH
71466: EMPTY
71467: LIST
71468: LIST
71469: LIST
71470: IN
71471: IFFALSE 71492
// points := [ 14 , 50 , 16 ] ;
71473: LD_ADDR_VAR 0 9
71477: PUSH
71478: LD_INT 14
71480: PUSH
71481: LD_INT 50
71483: PUSH
71484: LD_INT 16
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: LIST
71491: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71492: LD_VAR 0 6
71496: PPUSH
71497: CALL_OW 264
71501: PUSH
71502: LD_INT 6
71504: PUSH
71505: LD_INT 46
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: IN
71512: IFFALSE 71533
// points := [ 32 , 120 , 70 ] ;
71514: LD_ADDR_VAR 0 9
71518: PUSH
71519: LD_INT 32
71521: PUSH
71522: LD_INT 120
71524: PUSH
71525: LD_INT 70
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: LIST
71532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71533: LD_VAR 0 6
71537: PPUSH
71538: CALL_OW 264
71542: PUSH
71543: LD_INT 7
71545: PUSH
71546: LD_INT 28
71548: PUSH
71549: LD_INT 45
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: LIST
71556: IN
71557: IFFALSE 71578
// points := [ 35 , 20 , 45 ] ;
71559: LD_ADDR_VAR 0 9
71563: PUSH
71564: LD_INT 35
71566: PUSH
71567: LD_INT 20
71569: PUSH
71570: LD_INT 45
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: LIST
71577: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71578: LD_VAR 0 6
71582: PPUSH
71583: CALL_OW 264
71587: PUSH
71588: LD_INT 47
71590: PUSH
71591: EMPTY
71592: LIST
71593: IN
71594: IFFALSE 71615
// points := [ 67 , 45 , 75 ] ;
71596: LD_ADDR_VAR 0 9
71600: PUSH
71601: LD_INT 67
71603: PUSH
71604: LD_INT 45
71606: PUSH
71607: LD_INT 75
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: LIST
71614: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71615: LD_VAR 0 6
71619: PPUSH
71620: CALL_OW 264
71624: PUSH
71625: LD_INT 26
71627: PUSH
71628: EMPTY
71629: LIST
71630: IN
71631: IFFALSE 71652
// points := [ 120 , 30 , 80 ] ;
71633: LD_ADDR_VAR 0 9
71637: PUSH
71638: LD_INT 120
71640: PUSH
71641: LD_INT 30
71643: PUSH
71644: LD_INT 80
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: LIST
71651: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71652: LD_VAR 0 6
71656: PPUSH
71657: CALL_OW 264
71661: PUSH
71662: LD_INT 22
71664: PUSH
71665: EMPTY
71666: LIST
71667: IN
71668: IFFALSE 71689
// points := [ 40 , 1 , 1 ] ;
71670: LD_ADDR_VAR 0 9
71674: PUSH
71675: LD_INT 40
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: LD_INT 1
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: LIST
71688: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71689: LD_VAR 0 6
71693: PPUSH
71694: CALL_OW 264
71698: PUSH
71699: LD_INT 29
71701: PUSH
71702: EMPTY
71703: LIST
71704: IN
71705: IFFALSE 71726
// points := [ 70 , 200 , 400 ] ;
71707: LD_ADDR_VAR 0 9
71711: PUSH
71712: LD_INT 70
71714: PUSH
71715: LD_INT 200
71717: PUSH
71718: LD_INT 400
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: LIST
71725: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71726: LD_VAR 0 6
71730: PPUSH
71731: CALL_OW 264
71735: PUSH
71736: LD_INT 14
71738: PUSH
71739: LD_INT 53
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: IN
71746: IFFALSE 71767
// points := [ 40 , 10 , 20 ] ;
71748: LD_ADDR_VAR 0 9
71752: PUSH
71753: LD_INT 40
71755: PUSH
71756: LD_INT 10
71758: PUSH
71759: LD_INT 20
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: LIST
71766: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71767: LD_VAR 0 6
71771: PPUSH
71772: CALL_OW 264
71776: PUSH
71777: LD_INT 9
71779: PUSH
71780: EMPTY
71781: LIST
71782: IN
71783: IFFALSE 71804
// points := [ 5 , 70 , 20 ] ;
71785: LD_ADDR_VAR 0 9
71789: PUSH
71790: LD_INT 5
71792: PUSH
71793: LD_INT 70
71795: PUSH
71796: LD_INT 20
71798: PUSH
71799: EMPTY
71800: LIST
71801: LIST
71802: LIST
71803: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71804: LD_VAR 0 6
71808: PPUSH
71809: CALL_OW 264
71813: PUSH
71814: LD_INT 10
71816: PUSH
71817: EMPTY
71818: LIST
71819: IN
71820: IFFALSE 71841
// points := [ 35 , 110 , 70 ] ;
71822: LD_ADDR_VAR 0 9
71826: PUSH
71827: LD_INT 35
71829: PUSH
71830: LD_INT 110
71832: PUSH
71833: LD_INT 70
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: LIST
71840: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71841: LD_VAR 0 6
71845: PPUSH
71846: CALL_OW 265
71850: PUSH
71851: LD_INT 25
71853: EQUAL
71854: IFFALSE 71875
// points := [ 80 , 65 , 100 ] ;
71856: LD_ADDR_VAR 0 9
71860: PUSH
71861: LD_INT 80
71863: PUSH
71864: LD_INT 65
71866: PUSH
71867: LD_INT 100
71869: PUSH
71870: EMPTY
71871: LIST
71872: LIST
71873: LIST
71874: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71875: LD_VAR 0 6
71879: PPUSH
71880: CALL_OW 263
71884: PUSH
71885: LD_INT 1
71887: EQUAL
71888: IFFALSE 71923
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71890: LD_ADDR_VAR 0 10
71894: PUSH
71895: LD_VAR 0 10
71899: PUSH
71900: LD_VAR 0 6
71904: PPUSH
71905: CALL_OW 311
71909: PPUSH
71910: LD_INT 3
71912: PPUSH
71913: CALL_OW 259
71917: PUSH
71918: LD_INT 4
71920: MUL
71921: MUL
71922: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71923: LD_VAR 0 6
71927: PPUSH
71928: CALL_OW 263
71932: PUSH
71933: LD_INT 2
71935: EQUAL
71936: IFFALSE 71987
// begin j := IsControledBy ( i ) ;
71938: LD_ADDR_VAR 0 7
71942: PUSH
71943: LD_VAR 0 6
71947: PPUSH
71948: CALL_OW 312
71952: ST_TO_ADDR
// if j then
71953: LD_VAR 0 7
71957: IFFALSE 71987
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71959: LD_ADDR_VAR 0 10
71963: PUSH
71964: LD_VAR 0 10
71968: PUSH
71969: LD_VAR 0 7
71973: PPUSH
71974: LD_INT 3
71976: PPUSH
71977: CALL_OW 259
71981: PUSH
71982: LD_INT 3
71984: MUL
71985: MUL
71986: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
71987: LD_VAR 0 6
71991: PPUSH
71992: CALL_OW 264
71996: PUSH
71997: LD_INT 5
71999: PUSH
72000: LD_INT 6
72002: PUSH
72003: LD_INT 46
72005: PUSH
72006: LD_INT 44
72008: PUSH
72009: LD_INT 47
72011: PUSH
72012: LD_INT 45
72014: PUSH
72015: LD_INT 28
72017: PUSH
72018: LD_INT 7
72020: PUSH
72021: LD_INT 27
72023: PUSH
72024: LD_INT 29
72026: PUSH
72027: EMPTY
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: IN
72039: PUSH
72040: LD_VAR 0 1
72044: PPUSH
72045: LD_INT 52
72047: PPUSH
72048: CALL_OW 321
72052: PUSH
72053: LD_INT 2
72055: EQUAL
72056: AND
72057: IFFALSE 72074
// bpoints := bpoints * 1.2 ;
72059: LD_ADDR_VAR 0 10
72063: PUSH
72064: LD_VAR 0 10
72068: PUSH
72069: LD_REAL  1.20000000000000E+0000
72072: MUL
72073: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72074: LD_VAR 0 6
72078: PPUSH
72079: CALL_OW 264
72083: PUSH
72084: LD_INT 6
72086: PUSH
72087: LD_INT 46
72089: PUSH
72090: LD_INT 47
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: LIST
72097: IN
72098: IFFALSE 72115
// bpoints := bpoints * 1.2 ;
72100: LD_ADDR_VAR 0 10
72104: PUSH
72105: LD_VAR 0 10
72109: PUSH
72110: LD_REAL  1.20000000000000E+0000
72113: MUL
72114: ST_TO_ADDR
// end ; unit_building :
72115: GO 72129
72117: LD_INT 3
72119: DOUBLE
72120: EQUAL
72121: IFTRUE 72125
72123: GO 72128
72125: POP
// ; end ;
72126: GO 72129
72128: POP
// for j = 1 to 3 do
72129: LD_ADDR_VAR 0 7
72133: PUSH
72134: DOUBLE
72135: LD_INT 1
72137: DEC
72138: ST_TO_ADDR
72139: LD_INT 3
72141: PUSH
72142: FOR_TO
72143: IFFALSE 72196
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72145: LD_ADDR_VAR 0 5
72149: PUSH
72150: LD_VAR 0 5
72154: PPUSH
72155: LD_VAR 0 7
72159: PPUSH
72160: LD_VAR 0 5
72164: PUSH
72165: LD_VAR 0 7
72169: ARRAY
72170: PUSH
72171: LD_VAR 0 9
72175: PUSH
72176: LD_VAR 0 7
72180: ARRAY
72181: PUSH
72182: LD_VAR 0 10
72186: MUL
72187: PLUS
72188: PPUSH
72189: CALL_OW 1
72193: ST_TO_ADDR
72194: GO 72142
72196: POP
72197: POP
// end ;
72198: GO 70681
72200: POP
72201: POP
// result := Replace ( result , 4 , tmp ) ;
72202: LD_ADDR_VAR 0 5
72206: PUSH
72207: LD_VAR 0 5
72211: PPUSH
72212: LD_INT 4
72214: PPUSH
72215: LD_VAR 0 8
72219: PPUSH
72220: CALL_OW 1
72224: ST_TO_ADDR
// end ;
72225: LD_VAR 0 5
72229: RET
// export function DangerAtRange ( unit , range ) ; begin
72230: LD_INT 0
72232: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72233: LD_ADDR_VAR 0 3
72237: PUSH
72238: LD_VAR 0 1
72242: PPUSH
72243: CALL_OW 255
72247: PPUSH
72248: LD_VAR 0 1
72252: PPUSH
72253: CALL_OW 250
72257: PPUSH
72258: LD_VAR 0 1
72262: PPUSH
72263: CALL_OW 251
72267: PPUSH
72268: LD_VAR 0 2
72272: PPUSH
72273: CALL 70533 0 4
72277: ST_TO_ADDR
// end ;
72278: LD_VAR 0 3
72282: RET
// export function DangerInArea ( side , area ) ; begin
72283: LD_INT 0
72285: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72286: LD_ADDR_VAR 0 3
72290: PUSH
72291: LD_VAR 0 2
72295: PPUSH
72296: LD_INT 81
72298: PUSH
72299: LD_VAR 0 1
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PPUSH
72308: CALL_OW 70
72312: ST_TO_ADDR
// end ;
72313: LD_VAR 0 3
72317: RET
// export function IsExtension ( b ) ; begin
72318: LD_INT 0
72320: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72321: LD_ADDR_VAR 0 2
72325: PUSH
72326: LD_VAR 0 1
72330: PUSH
72331: LD_INT 23
72333: PUSH
72334: LD_INT 20
72336: PUSH
72337: LD_INT 22
72339: PUSH
72340: LD_INT 17
72342: PUSH
72343: LD_INT 24
72345: PUSH
72346: LD_INT 21
72348: PUSH
72349: LD_INT 19
72351: PUSH
72352: LD_INT 16
72354: PUSH
72355: LD_INT 25
72357: PUSH
72358: LD_INT 18
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: IN
72373: ST_TO_ADDR
// end ;
72374: LD_VAR 0 2
72378: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72379: LD_INT 0
72381: PPUSH
72382: PPUSH
72383: PPUSH
// result := [ ] ;
72384: LD_ADDR_VAR 0 3
72388: PUSH
72389: EMPTY
72390: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72391: LD_ADDR_VAR 0 4
72395: PUSH
72396: LD_VAR 0 2
72400: PPUSH
72401: LD_INT 21
72403: PUSH
72404: LD_INT 3
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PPUSH
72411: CALL_OW 70
72415: ST_TO_ADDR
// if not tmp then
72416: LD_VAR 0 4
72420: NOT
72421: IFFALSE 72425
// exit ;
72423: GO 72483
// for i in tmp do
72425: LD_ADDR_VAR 0 5
72429: PUSH
72430: LD_VAR 0 4
72434: PUSH
72435: FOR_IN
72436: IFFALSE 72471
// if GetBase ( i ) <> base then
72438: LD_VAR 0 5
72442: PPUSH
72443: CALL_OW 274
72447: PUSH
72448: LD_VAR 0 1
72452: NONEQUAL
72453: IFFALSE 72469
// ComLinkToBase ( base , i ) ;
72455: LD_VAR 0 1
72459: PPUSH
72460: LD_VAR 0 5
72464: PPUSH
72465: CALL_OW 169
72469: GO 72435
72471: POP
72472: POP
// result := tmp ;
72473: LD_ADDR_VAR 0 3
72477: PUSH
72478: LD_VAR 0 4
72482: ST_TO_ADDR
// end ;
72483: LD_VAR 0 3
72487: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72488: LD_INT 0
72490: PPUSH
72491: PPUSH
// if BuildingStatus ( b ) = bs_build then
72492: LD_VAR 0 2
72496: PPUSH
72497: CALL_OW 461
72501: PUSH
72502: LD_INT 1
72504: EQUAL
72505: IFFALSE 72565
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72507: LD_VAR 0 1
72511: PPUSH
72512: LD_STRING h
72514: PUSH
72515: LD_VAR 0 2
72519: PPUSH
72520: CALL_OW 250
72524: PUSH
72525: LD_VAR 0 2
72529: PPUSH
72530: CALL_OW 251
72534: PUSH
72535: LD_VAR 0 2
72539: PUSH
72540: LD_INT 0
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: LIST
72553: LIST
72554: LIST
72555: LIST
72556: LIST
72557: PUSH
72558: EMPTY
72559: LIST
72560: PPUSH
72561: CALL_OW 446
// end ;
72565: LD_VAR 0 3
72569: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72570: LD_INT 0
72572: PPUSH
72573: PPUSH
72574: PPUSH
72575: PPUSH
72576: PPUSH
72577: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72578: LD_VAR 0 1
72582: NOT
72583: PUSH
72584: LD_VAR 0 1
72588: PPUSH
72589: CALL_OW 263
72593: PUSH
72594: LD_INT 2
72596: EQUAL
72597: NOT
72598: OR
72599: IFFALSE 72603
// exit ;
72601: GO 72919
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72603: LD_ADDR_VAR 0 6
72607: PUSH
72608: LD_INT 22
72610: PUSH
72611: LD_VAR 0 1
72615: PPUSH
72616: CALL_OW 255
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 2
72627: PUSH
72628: LD_INT 30
72630: PUSH
72631: LD_INT 36
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 34
72640: PUSH
72641: LD_INT 31
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: LIST
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PPUSH
72657: CALL_OW 69
72661: ST_TO_ADDR
// if not tmp then
72662: LD_VAR 0 6
72666: NOT
72667: IFFALSE 72671
// exit ;
72669: GO 72919
// result := [ ] ;
72671: LD_ADDR_VAR 0 2
72675: PUSH
72676: EMPTY
72677: ST_TO_ADDR
// for i in tmp do
72678: LD_ADDR_VAR 0 3
72682: PUSH
72683: LD_VAR 0 6
72687: PUSH
72688: FOR_IN
72689: IFFALSE 72760
// begin t := UnitsInside ( i ) ;
72691: LD_ADDR_VAR 0 4
72695: PUSH
72696: LD_VAR 0 3
72700: PPUSH
72701: CALL_OW 313
72705: ST_TO_ADDR
// if t then
72706: LD_VAR 0 4
72710: IFFALSE 72758
// for j in t do
72712: LD_ADDR_VAR 0 7
72716: PUSH
72717: LD_VAR 0 4
72721: PUSH
72722: FOR_IN
72723: IFFALSE 72756
// result := Insert ( result , result + 1 , j ) ;
72725: LD_ADDR_VAR 0 2
72729: PUSH
72730: LD_VAR 0 2
72734: PPUSH
72735: LD_VAR 0 2
72739: PUSH
72740: LD_INT 1
72742: PLUS
72743: PPUSH
72744: LD_VAR 0 7
72748: PPUSH
72749: CALL_OW 2
72753: ST_TO_ADDR
72754: GO 72722
72756: POP
72757: POP
// end ;
72758: GO 72688
72760: POP
72761: POP
// if not result then
72762: LD_VAR 0 2
72766: NOT
72767: IFFALSE 72771
// exit ;
72769: GO 72919
// mech := result [ 1 ] ;
72771: LD_ADDR_VAR 0 5
72775: PUSH
72776: LD_VAR 0 2
72780: PUSH
72781: LD_INT 1
72783: ARRAY
72784: ST_TO_ADDR
// if result > 1 then
72785: LD_VAR 0 2
72789: PUSH
72790: LD_INT 1
72792: GREATER
72793: IFFALSE 72905
// for i = 2 to result do
72795: LD_ADDR_VAR 0 3
72799: PUSH
72800: DOUBLE
72801: LD_INT 2
72803: DEC
72804: ST_TO_ADDR
72805: LD_VAR 0 2
72809: PUSH
72810: FOR_TO
72811: IFFALSE 72903
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72813: LD_ADDR_VAR 0 4
72817: PUSH
72818: LD_VAR 0 2
72822: PUSH
72823: LD_VAR 0 3
72827: ARRAY
72828: PPUSH
72829: LD_INT 3
72831: PPUSH
72832: CALL_OW 259
72836: PUSH
72837: LD_VAR 0 2
72841: PUSH
72842: LD_VAR 0 3
72846: ARRAY
72847: PPUSH
72848: CALL_OW 432
72852: MINUS
72853: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72854: LD_VAR 0 4
72858: PUSH
72859: LD_VAR 0 5
72863: PPUSH
72864: LD_INT 3
72866: PPUSH
72867: CALL_OW 259
72871: PUSH
72872: LD_VAR 0 5
72876: PPUSH
72877: CALL_OW 432
72881: MINUS
72882: GREATEREQUAL
72883: IFFALSE 72901
// mech := result [ i ] ;
72885: LD_ADDR_VAR 0 5
72889: PUSH
72890: LD_VAR 0 2
72894: PUSH
72895: LD_VAR 0 3
72899: ARRAY
72900: ST_TO_ADDR
// end ;
72901: GO 72810
72903: POP
72904: POP
// ComLinkTo ( vehicle , mech ) ;
72905: LD_VAR 0 1
72909: PPUSH
72910: LD_VAR 0 5
72914: PPUSH
72915: CALL_OW 135
// end ;
72919: LD_VAR 0 2
72923: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72924: LD_INT 0
72926: PPUSH
72927: PPUSH
72928: PPUSH
72929: PPUSH
72930: PPUSH
72931: PPUSH
72932: PPUSH
72933: PPUSH
72934: PPUSH
72935: PPUSH
72936: PPUSH
72937: PPUSH
72938: PPUSH
// result := [ ] ;
72939: LD_ADDR_VAR 0 7
72943: PUSH
72944: EMPTY
72945: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
72946: LD_VAR 0 1
72950: PPUSH
72951: CALL_OW 266
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: LD_INT 1
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: IN
72966: NOT
72967: IFFALSE 72971
// exit ;
72969: GO 74602
// if name then
72971: LD_VAR 0 3
72975: IFFALSE 72991
// SetBName ( base_dep , name ) ;
72977: LD_VAR 0 1
72981: PPUSH
72982: LD_VAR 0 3
72986: PPUSH
72987: CALL_OW 500
// base := GetBase ( base_dep ) ;
72991: LD_ADDR_VAR 0 15
72995: PUSH
72996: LD_VAR 0 1
73000: PPUSH
73001: CALL_OW 274
73005: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73006: LD_ADDR_VAR 0 16
73010: PUSH
73011: LD_VAR 0 1
73015: PPUSH
73016: CALL_OW 255
73020: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73021: LD_ADDR_VAR 0 17
73025: PUSH
73026: LD_VAR 0 1
73030: PPUSH
73031: CALL_OW 248
73035: ST_TO_ADDR
// if sources then
73036: LD_VAR 0 5
73040: IFFALSE 73087
// for i = 1 to 3 do
73042: LD_ADDR_VAR 0 8
73046: PUSH
73047: DOUBLE
73048: LD_INT 1
73050: DEC
73051: ST_TO_ADDR
73052: LD_INT 3
73054: PUSH
73055: FOR_TO
73056: IFFALSE 73085
// AddResourceType ( base , i , sources [ i ] ) ;
73058: LD_VAR 0 15
73062: PPUSH
73063: LD_VAR 0 8
73067: PPUSH
73068: LD_VAR 0 5
73072: PUSH
73073: LD_VAR 0 8
73077: ARRAY
73078: PPUSH
73079: CALL_OW 276
73083: GO 73055
73085: POP
73086: POP
// buildings := GetBaseBuildings ( base , area ) ;
73087: LD_ADDR_VAR 0 18
73091: PUSH
73092: LD_VAR 0 15
73096: PPUSH
73097: LD_VAR 0 2
73101: PPUSH
73102: CALL 72379 0 2
73106: ST_TO_ADDR
// InitHc ;
73107: CALL_OW 19
// InitUc ;
73111: CALL_OW 18
// uc_side := side ;
73115: LD_ADDR_OWVAR 20
73119: PUSH
73120: LD_VAR 0 16
73124: ST_TO_ADDR
// uc_nation := nation ;
73125: LD_ADDR_OWVAR 21
73129: PUSH
73130: LD_VAR 0 17
73134: ST_TO_ADDR
// if buildings then
73135: LD_VAR 0 18
73139: IFFALSE 74461
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73141: LD_ADDR_VAR 0 19
73145: PUSH
73146: LD_VAR 0 18
73150: PPUSH
73151: LD_INT 2
73153: PUSH
73154: LD_INT 30
73156: PUSH
73157: LD_INT 29
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 30
73166: PUSH
73167: LD_INT 30
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: LIST
73178: PPUSH
73179: CALL_OW 72
73183: ST_TO_ADDR
// if tmp then
73184: LD_VAR 0 19
73188: IFFALSE 73236
// for i in tmp do
73190: LD_ADDR_VAR 0 8
73194: PUSH
73195: LD_VAR 0 19
73199: PUSH
73200: FOR_IN
73201: IFFALSE 73234
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73203: LD_VAR 0 8
73207: PPUSH
73208: CALL_OW 250
73212: PPUSH
73213: LD_VAR 0 8
73217: PPUSH
73218: CALL_OW 251
73222: PPUSH
73223: LD_VAR 0 16
73227: PPUSH
73228: CALL_OW 441
73232: GO 73200
73234: POP
73235: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73236: LD_VAR 0 18
73240: PPUSH
73241: LD_INT 2
73243: PUSH
73244: LD_INT 30
73246: PUSH
73247: LD_INT 32
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 30
73256: PUSH
73257: LD_INT 33
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: LIST
73268: PPUSH
73269: CALL_OW 72
73273: IFFALSE 73361
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73275: LD_ADDR_VAR 0 8
73279: PUSH
73280: LD_VAR 0 18
73284: PPUSH
73285: LD_INT 2
73287: PUSH
73288: LD_INT 30
73290: PUSH
73291: LD_INT 32
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 30
73300: PUSH
73301: LD_INT 33
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: LIST
73312: PPUSH
73313: CALL_OW 72
73317: PUSH
73318: FOR_IN
73319: IFFALSE 73359
// begin if not GetBWeapon ( i ) then
73321: LD_VAR 0 8
73325: PPUSH
73326: CALL_OW 269
73330: NOT
73331: IFFALSE 73357
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73333: LD_VAR 0 8
73337: PPUSH
73338: LD_VAR 0 8
73342: PPUSH
73343: LD_VAR 0 2
73347: PPUSH
73348: CALL 74607 0 2
73352: PPUSH
73353: CALL_OW 431
// end ;
73357: GO 73318
73359: POP
73360: POP
// end ; for i = 1 to personel do
73361: LD_ADDR_VAR 0 8
73365: PUSH
73366: DOUBLE
73367: LD_INT 1
73369: DEC
73370: ST_TO_ADDR
73371: LD_VAR 0 6
73375: PUSH
73376: FOR_TO
73377: IFFALSE 74441
// begin if i > 4 then
73379: LD_VAR 0 8
73383: PUSH
73384: LD_INT 4
73386: GREATER
73387: IFFALSE 73391
// break ;
73389: GO 74441
// case i of 1 :
73391: LD_VAR 0 8
73395: PUSH
73396: LD_INT 1
73398: DOUBLE
73399: EQUAL
73400: IFTRUE 73404
73402: GO 73484
73404: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73405: LD_ADDR_VAR 0 12
73409: PUSH
73410: LD_VAR 0 18
73414: PPUSH
73415: LD_INT 22
73417: PUSH
73418: LD_VAR 0 16
73422: PUSH
73423: EMPTY
73424: LIST
73425: LIST
73426: PUSH
73427: LD_INT 58
73429: PUSH
73430: EMPTY
73431: LIST
73432: PUSH
73433: LD_INT 2
73435: PUSH
73436: LD_INT 30
73438: PUSH
73439: LD_INT 32
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: LD_INT 30
73448: PUSH
73449: LD_INT 4
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 30
73458: PUSH
73459: LD_INT 5
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: LIST
73476: PPUSH
73477: CALL_OW 72
73481: ST_TO_ADDR
73482: GO 73706
73484: LD_INT 2
73486: DOUBLE
73487: EQUAL
73488: IFTRUE 73492
73490: GO 73554
73492: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73493: LD_ADDR_VAR 0 12
73497: PUSH
73498: LD_VAR 0 18
73502: PPUSH
73503: LD_INT 22
73505: PUSH
73506: LD_VAR 0 16
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 2
73517: PUSH
73518: LD_INT 30
73520: PUSH
73521: LD_INT 0
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 30
73530: PUSH
73531: LD_INT 1
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: LIST
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PPUSH
73547: CALL_OW 72
73551: ST_TO_ADDR
73552: GO 73706
73554: LD_INT 3
73556: DOUBLE
73557: EQUAL
73558: IFTRUE 73562
73560: GO 73624
73562: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73563: LD_ADDR_VAR 0 12
73567: PUSH
73568: LD_VAR 0 18
73572: PPUSH
73573: LD_INT 22
73575: PUSH
73576: LD_VAR 0 16
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 2
73587: PUSH
73588: LD_INT 30
73590: PUSH
73591: LD_INT 2
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 30
73600: PUSH
73601: LD_INT 3
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: LIST
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PPUSH
73617: CALL_OW 72
73621: ST_TO_ADDR
73622: GO 73706
73624: LD_INT 4
73626: DOUBLE
73627: EQUAL
73628: IFTRUE 73632
73630: GO 73705
73632: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73633: LD_ADDR_VAR 0 12
73637: PUSH
73638: LD_VAR 0 18
73642: PPUSH
73643: LD_INT 22
73645: PUSH
73646: LD_VAR 0 16
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 2
73657: PUSH
73658: LD_INT 30
73660: PUSH
73661: LD_INT 6
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 30
73670: PUSH
73671: LD_INT 7
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 30
73680: PUSH
73681: LD_INT 8
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PPUSH
73698: CALL_OW 72
73702: ST_TO_ADDR
73703: GO 73706
73705: POP
// if i = 1 then
73706: LD_VAR 0 8
73710: PUSH
73711: LD_INT 1
73713: EQUAL
73714: IFFALSE 73825
// begin tmp := [ ] ;
73716: LD_ADDR_VAR 0 19
73720: PUSH
73721: EMPTY
73722: ST_TO_ADDR
// for j in f do
73723: LD_ADDR_VAR 0 9
73727: PUSH
73728: LD_VAR 0 12
73732: PUSH
73733: FOR_IN
73734: IFFALSE 73807
// if GetBType ( j ) = b_bunker then
73736: LD_VAR 0 9
73740: PPUSH
73741: CALL_OW 266
73745: PUSH
73746: LD_INT 32
73748: EQUAL
73749: IFFALSE 73776
// tmp := Insert ( tmp , 1 , j ) else
73751: LD_ADDR_VAR 0 19
73755: PUSH
73756: LD_VAR 0 19
73760: PPUSH
73761: LD_INT 1
73763: PPUSH
73764: LD_VAR 0 9
73768: PPUSH
73769: CALL_OW 2
73773: ST_TO_ADDR
73774: GO 73805
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73776: LD_ADDR_VAR 0 19
73780: PUSH
73781: LD_VAR 0 19
73785: PPUSH
73786: LD_VAR 0 19
73790: PUSH
73791: LD_INT 1
73793: PLUS
73794: PPUSH
73795: LD_VAR 0 9
73799: PPUSH
73800: CALL_OW 2
73804: ST_TO_ADDR
73805: GO 73733
73807: POP
73808: POP
// if tmp then
73809: LD_VAR 0 19
73813: IFFALSE 73825
// f := tmp ;
73815: LD_ADDR_VAR 0 12
73819: PUSH
73820: LD_VAR 0 19
73824: ST_TO_ADDR
// end ; x := personel [ i ] ;
73825: LD_ADDR_VAR 0 13
73829: PUSH
73830: LD_VAR 0 6
73834: PUSH
73835: LD_VAR 0 8
73839: ARRAY
73840: ST_TO_ADDR
// if x = - 1 then
73841: LD_VAR 0 13
73845: PUSH
73846: LD_INT 1
73848: NEG
73849: EQUAL
73850: IFFALSE 74059
// begin for j in f do
73852: LD_ADDR_VAR 0 9
73856: PUSH
73857: LD_VAR 0 12
73861: PUSH
73862: FOR_IN
73863: IFFALSE 74055
// repeat InitHc ;
73865: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73869: LD_VAR 0 9
73873: PPUSH
73874: CALL_OW 266
73878: PUSH
73879: LD_INT 5
73881: EQUAL
73882: IFFALSE 73952
// begin if UnitsInside ( j ) < 3 then
73884: LD_VAR 0 9
73888: PPUSH
73889: CALL_OW 313
73893: PUSH
73894: LD_INT 3
73896: LESS
73897: IFFALSE 73933
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73899: LD_INT 0
73901: PPUSH
73902: LD_INT 5
73904: PUSH
73905: LD_INT 8
73907: PUSH
73908: LD_INT 9
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: LIST
73915: PUSH
73916: LD_VAR 0 17
73920: ARRAY
73921: PPUSH
73922: LD_VAR 0 4
73926: PPUSH
73927: CALL_OW 380
73931: GO 73950
// PrepareHuman ( false , i , skill ) ;
73933: LD_INT 0
73935: PPUSH
73936: LD_VAR 0 8
73940: PPUSH
73941: LD_VAR 0 4
73945: PPUSH
73946: CALL_OW 380
// end else
73950: GO 73969
// PrepareHuman ( false , i , skill ) ;
73952: LD_INT 0
73954: PPUSH
73955: LD_VAR 0 8
73959: PPUSH
73960: LD_VAR 0 4
73964: PPUSH
73965: CALL_OW 380
// un := CreateHuman ;
73969: LD_ADDR_VAR 0 14
73973: PUSH
73974: CALL_OW 44
73978: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73979: LD_ADDR_VAR 0 7
73983: PUSH
73984: LD_VAR 0 7
73988: PPUSH
73989: LD_INT 1
73991: PPUSH
73992: LD_VAR 0 14
73996: PPUSH
73997: CALL_OW 2
74001: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74002: LD_VAR 0 14
74006: PPUSH
74007: LD_VAR 0 9
74011: PPUSH
74012: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74016: LD_VAR 0 9
74020: PPUSH
74021: CALL_OW 313
74025: PUSH
74026: LD_INT 6
74028: EQUAL
74029: PUSH
74030: LD_VAR 0 9
74034: PPUSH
74035: CALL_OW 266
74039: PUSH
74040: LD_INT 32
74042: PUSH
74043: LD_INT 31
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: IN
74050: OR
74051: IFFALSE 73865
74053: GO 73862
74055: POP
74056: POP
// end else
74057: GO 74439
// for j = 1 to x do
74059: LD_ADDR_VAR 0 9
74063: PUSH
74064: DOUBLE
74065: LD_INT 1
74067: DEC
74068: ST_TO_ADDR
74069: LD_VAR 0 13
74073: PUSH
74074: FOR_TO
74075: IFFALSE 74437
// begin InitHc ;
74077: CALL_OW 19
// if not f then
74081: LD_VAR 0 12
74085: NOT
74086: IFFALSE 74175
// begin PrepareHuman ( false , i , skill ) ;
74088: LD_INT 0
74090: PPUSH
74091: LD_VAR 0 8
74095: PPUSH
74096: LD_VAR 0 4
74100: PPUSH
74101: CALL_OW 380
// un := CreateHuman ;
74105: LD_ADDR_VAR 0 14
74109: PUSH
74110: CALL_OW 44
74114: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74115: LD_ADDR_VAR 0 7
74119: PUSH
74120: LD_VAR 0 7
74124: PPUSH
74125: LD_INT 1
74127: PPUSH
74128: LD_VAR 0 14
74132: PPUSH
74133: CALL_OW 2
74137: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74138: LD_VAR 0 14
74142: PPUSH
74143: LD_VAR 0 1
74147: PPUSH
74148: CALL_OW 250
74152: PPUSH
74153: LD_VAR 0 1
74157: PPUSH
74158: CALL_OW 251
74162: PPUSH
74163: LD_INT 10
74165: PPUSH
74166: LD_INT 0
74168: PPUSH
74169: CALL_OW 50
// continue ;
74173: GO 74074
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74175: LD_VAR 0 12
74179: PUSH
74180: LD_INT 1
74182: ARRAY
74183: PPUSH
74184: CALL_OW 313
74188: PUSH
74189: LD_VAR 0 12
74193: PUSH
74194: LD_INT 1
74196: ARRAY
74197: PPUSH
74198: CALL_OW 266
74202: PUSH
74203: LD_INT 32
74205: PUSH
74206: LD_INT 31
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: IN
74213: AND
74214: PUSH
74215: LD_VAR 0 12
74219: PUSH
74220: LD_INT 1
74222: ARRAY
74223: PPUSH
74224: CALL_OW 313
74228: PUSH
74229: LD_INT 6
74231: EQUAL
74232: OR
74233: IFFALSE 74253
// f := Delete ( f , 1 ) ;
74235: LD_ADDR_VAR 0 12
74239: PUSH
74240: LD_VAR 0 12
74244: PPUSH
74245: LD_INT 1
74247: PPUSH
74248: CALL_OW 3
74252: ST_TO_ADDR
// if not f then
74253: LD_VAR 0 12
74257: NOT
74258: IFFALSE 74276
// begin x := x + 2 ;
74260: LD_ADDR_VAR 0 13
74264: PUSH
74265: LD_VAR 0 13
74269: PUSH
74270: LD_INT 2
74272: PLUS
74273: ST_TO_ADDR
// continue ;
74274: GO 74074
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74276: LD_VAR 0 12
74280: PUSH
74281: LD_INT 1
74283: ARRAY
74284: PPUSH
74285: CALL_OW 266
74289: PUSH
74290: LD_INT 5
74292: EQUAL
74293: IFFALSE 74367
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74295: LD_VAR 0 12
74299: PUSH
74300: LD_INT 1
74302: ARRAY
74303: PPUSH
74304: CALL_OW 313
74308: PUSH
74309: LD_INT 3
74311: LESS
74312: IFFALSE 74348
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74314: LD_INT 0
74316: PPUSH
74317: LD_INT 5
74319: PUSH
74320: LD_INT 8
74322: PUSH
74323: LD_INT 9
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: LIST
74330: PUSH
74331: LD_VAR 0 17
74335: ARRAY
74336: PPUSH
74337: LD_VAR 0 4
74341: PPUSH
74342: CALL_OW 380
74346: GO 74365
// PrepareHuman ( false , i , skill ) ;
74348: LD_INT 0
74350: PPUSH
74351: LD_VAR 0 8
74355: PPUSH
74356: LD_VAR 0 4
74360: PPUSH
74361: CALL_OW 380
// end else
74365: GO 74384
// PrepareHuman ( false , i , skill ) ;
74367: LD_INT 0
74369: PPUSH
74370: LD_VAR 0 8
74374: PPUSH
74375: LD_VAR 0 4
74379: PPUSH
74380: CALL_OW 380
// un := CreateHuman ;
74384: LD_ADDR_VAR 0 14
74388: PUSH
74389: CALL_OW 44
74393: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74394: LD_ADDR_VAR 0 7
74398: PUSH
74399: LD_VAR 0 7
74403: PPUSH
74404: LD_INT 1
74406: PPUSH
74407: LD_VAR 0 14
74411: PPUSH
74412: CALL_OW 2
74416: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74417: LD_VAR 0 14
74421: PPUSH
74422: LD_VAR 0 12
74426: PUSH
74427: LD_INT 1
74429: ARRAY
74430: PPUSH
74431: CALL_OW 52
// end ;
74435: GO 74074
74437: POP
74438: POP
// end ;
74439: GO 73376
74441: POP
74442: POP
// result := result ^ buildings ;
74443: LD_ADDR_VAR 0 7
74447: PUSH
74448: LD_VAR 0 7
74452: PUSH
74453: LD_VAR 0 18
74457: ADD
74458: ST_TO_ADDR
// end else
74459: GO 74602
// begin for i = 1 to personel do
74461: LD_ADDR_VAR 0 8
74465: PUSH
74466: DOUBLE
74467: LD_INT 1
74469: DEC
74470: ST_TO_ADDR
74471: LD_VAR 0 6
74475: PUSH
74476: FOR_TO
74477: IFFALSE 74600
// begin if i > 4 then
74479: LD_VAR 0 8
74483: PUSH
74484: LD_INT 4
74486: GREATER
74487: IFFALSE 74491
// break ;
74489: GO 74600
// x := personel [ i ] ;
74491: LD_ADDR_VAR 0 13
74495: PUSH
74496: LD_VAR 0 6
74500: PUSH
74501: LD_VAR 0 8
74505: ARRAY
74506: ST_TO_ADDR
// if x = - 1 then
74507: LD_VAR 0 13
74511: PUSH
74512: LD_INT 1
74514: NEG
74515: EQUAL
74516: IFFALSE 74520
// continue ;
74518: GO 74476
// PrepareHuman ( false , i , skill ) ;
74520: LD_INT 0
74522: PPUSH
74523: LD_VAR 0 8
74527: PPUSH
74528: LD_VAR 0 4
74532: PPUSH
74533: CALL_OW 380
// un := CreateHuman ;
74537: LD_ADDR_VAR 0 14
74541: PUSH
74542: CALL_OW 44
74546: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74547: LD_VAR 0 14
74551: PPUSH
74552: LD_VAR 0 1
74556: PPUSH
74557: CALL_OW 250
74561: PPUSH
74562: LD_VAR 0 1
74566: PPUSH
74567: CALL_OW 251
74571: PPUSH
74572: LD_INT 10
74574: PPUSH
74575: LD_INT 0
74577: PPUSH
74578: CALL_OW 50
// result := result ^ un ;
74582: LD_ADDR_VAR 0 7
74586: PUSH
74587: LD_VAR 0 7
74591: PUSH
74592: LD_VAR 0 14
74596: ADD
74597: ST_TO_ADDR
// end ;
74598: GO 74476
74600: POP
74601: POP
// end ; end ;
74602: LD_VAR 0 7
74606: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74607: LD_INT 0
74609: PPUSH
74610: PPUSH
74611: PPUSH
74612: PPUSH
74613: PPUSH
74614: PPUSH
74615: PPUSH
74616: PPUSH
74617: PPUSH
74618: PPUSH
74619: PPUSH
74620: PPUSH
74621: PPUSH
74622: PPUSH
74623: PPUSH
74624: PPUSH
// result := false ;
74625: LD_ADDR_VAR 0 3
74629: PUSH
74630: LD_INT 0
74632: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74633: LD_VAR 0 1
74637: NOT
74638: PUSH
74639: LD_VAR 0 1
74643: PPUSH
74644: CALL_OW 266
74648: PUSH
74649: LD_INT 32
74651: PUSH
74652: LD_INT 33
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: IN
74659: NOT
74660: OR
74661: IFFALSE 74665
// exit ;
74663: GO 75801
// nat := GetNation ( tower ) ;
74665: LD_ADDR_VAR 0 12
74669: PUSH
74670: LD_VAR 0 1
74674: PPUSH
74675: CALL_OW 248
74679: ST_TO_ADDR
// side := GetSide ( tower ) ;
74680: LD_ADDR_VAR 0 16
74684: PUSH
74685: LD_VAR 0 1
74689: PPUSH
74690: CALL_OW 255
74694: ST_TO_ADDR
// x := GetX ( tower ) ;
74695: LD_ADDR_VAR 0 10
74699: PUSH
74700: LD_VAR 0 1
74704: PPUSH
74705: CALL_OW 250
74709: ST_TO_ADDR
// y := GetY ( tower ) ;
74710: LD_ADDR_VAR 0 11
74714: PUSH
74715: LD_VAR 0 1
74719: PPUSH
74720: CALL_OW 251
74724: ST_TO_ADDR
// if not x or not y then
74725: LD_VAR 0 10
74729: NOT
74730: PUSH
74731: LD_VAR 0 11
74735: NOT
74736: OR
74737: IFFALSE 74741
// exit ;
74739: GO 75801
// weapon := 0 ;
74741: LD_ADDR_VAR 0 18
74745: PUSH
74746: LD_INT 0
74748: ST_TO_ADDR
// fac_list := [ ] ;
74749: LD_ADDR_VAR 0 17
74753: PUSH
74754: EMPTY
74755: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
74756: LD_ADDR_VAR 0 6
74760: PUSH
74761: LD_VAR 0 1
74765: PPUSH
74766: CALL_OW 274
74770: PPUSH
74771: LD_VAR 0 2
74775: PPUSH
74776: CALL 72379 0 2
74780: PPUSH
74781: LD_INT 30
74783: PUSH
74784: LD_INT 3
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PPUSH
74791: CALL_OW 72
74795: ST_TO_ADDR
// if not factories then
74796: LD_VAR 0 6
74800: NOT
74801: IFFALSE 74805
// exit ;
74803: GO 75801
// for i in factories do
74805: LD_ADDR_VAR 0 8
74809: PUSH
74810: LD_VAR 0 6
74814: PUSH
74815: FOR_IN
74816: IFFALSE 74841
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74818: LD_ADDR_VAR 0 17
74822: PUSH
74823: LD_VAR 0 17
74827: PUSH
74828: LD_VAR 0 8
74832: PPUSH
74833: CALL_OW 478
74837: UNION
74838: ST_TO_ADDR
74839: GO 74815
74841: POP
74842: POP
// if not fac_list then
74843: LD_VAR 0 17
74847: NOT
74848: IFFALSE 74852
// exit ;
74850: GO 75801
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74852: LD_ADDR_VAR 0 5
74856: PUSH
74857: LD_INT 4
74859: PUSH
74860: LD_INT 5
74862: PUSH
74863: LD_INT 9
74865: PUSH
74866: LD_INT 10
74868: PUSH
74869: LD_INT 6
74871: PUSH
74872: LD_INT 7
74874: PUSH
74875: LD_INT 11
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: LIST
74882: LIST
74883: LIST
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 27
74889: PUSH
74890: LD_INT 28
74892: PUSH
74893: LD_INT 26
74895: PUSH
74896: LD_INT 30
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: PUSH
74905: LD_INT 43
74907: PUSH
74908: LD_INT 44
74910: PUSH
74911: LD_INT 46
74913: PUSH
74914: LD_INT 45
74916: PUSH
74917: LD_INT 47
74919: PUSH
74920: LD_INT 49
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: LIST
74929: LIST
74930: PUSH
74931: EMPTY
74932: LIST
74933: LIST
74934: LIST
74935: PUSH
74936: LD_VAR 0 12
74940: ARRAY
74941: ST_TO_ADDR
// for i in list do
74942: LD_ADDR_VAR 0 8
74946: PUSH
74947: LD_VAR 0 5
74951: PUSH
74952: FOR_IN
74953: IFFALSE 74986
// if not i in fac_list then
74955: LD_VAR 0 8
74959: PUSH
74960: LD_VAR 0 17
74964: IN
74965: NOT
74966: IFFALSE 74984
// list := list diff i ;
74968: LD_ADDR_VAR 0 5
74972: PUSH
74973: LD_VAR 0 5
74977: PUSH
74978: LD_VAR 0 8
74982: DIFF
74983: ST_TO_ADDR
74984: GO 74952
74986: POP
74987: POP
// if not list then
74988: LD_VAR 0 5
74992: NOT
74993: IFFALSE 74997
// exit ;
74995: GO 75801
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
74997: LD_VAR 0 12
75001: PUSH
75002: LD_INT 3
75004: EQUAL
75005: PUSH
75006: LD_INT 49
75008: PUSH
75009: LD_VAR 0 5
75013: IN
75014: AND
75015: PUSH
75016: LD_INT 31
75018: PPUSH
75019: LD_VAR 0 16
75023: PPUSH
75024: CALL_OW 321
75028: PUSH
75029: LD_INT 2
75031: EQUAL
75032: AND
75033: IFFALSE 75093
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75035: LD_INT 22
75037: PUSH
75038: LD_VAR 0 16
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 35
75049: PUSH
75050: LD_INT 49
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 91
75059: PUSH
75060: LD_VAR 0 1
75064: PUSH
75065: LD_INT 10
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: LIST
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: LIST
75077: PPUSH
75078: CALL_OW 69
75082: NOT
75083: IFFALSE 75093
// weapon := ru_time_lapser ;
75085: LD_ADDR_VAR 0 18
75089: PUSH
75090: LD_INT 49
75092: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75093: LD_VAR 0 12
75097: PUSH
75098: LD_INT 1
75100: PUSH
75101: LD_INT 2
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: IN
75108: PUSH
75109: LD_INT 11
75111: PUSH
75112: LD_VAR 0 5
75116: IN
75117: PUSH
75118: LD_INT 30
75120: PUSH
75121: LD_VAR 0 5
75125: IN
75126: OR
75127: AND
75128: PUSH
75129: LD_INT 6
75131: PPUSH
75132: LD_VAR 0 16
75136: PPUSH
75137: CALL_OW 321
75141: PUSH
75142: LD_INT 2
75144: EQUAL
75145: AND
75146: IFFALSE 75311
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75148: LD_INT 22
75150: PUSH
75151: LD_VAR 0 16
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 2
75162: PUSH
75163: LD_INT 35
75165: PUSH
75166: LD_INT 11
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 35
75175: PUSH
75176: LD_INT 30
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 91
75190: PUSH
75191: LD_VAR 0 1
75195: PUSH
75196: LD_INT 18
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: LIST
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: PPUSH
75209: CALL_OW 69
75213: NOT
75214: PUSH
75215: LD_INT 22
75217: PUSH
75218: LD_VAR 0 16
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 2
75229: PUSH
75230: LD_INT 30
75232: PUSH
75233: LD_INT 32
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 30
75242: PUSH
75243: LD_INT 33
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: LIST
75254: PUSH
75255: LD_INT 91
75257: PUSH
75258: LD_VAR 0 1
75262: PUSH
75263: LD_INT 12
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: LIST
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: LIST
75275: PUSH
75276: EMPTY
75277: LIST
75278: PPUSH
75279: CALL_OW 69
75283: PUSH
75284: LD_INT 2
75286: GREATER
75287: AND
75288: IFFALSE 75311
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75290: LD_ADDR_VAR 0 18
75294: PUSH
75295: LD_INT 11
75297: PUSH
75298: LD_INT 30
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_VAR 0 12
75309: ARRAY
75310: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75311: LD_VAR 0 18
75315: NOT
75316: PUSH
75317: LD_INT 40
75319: PPUSH
75320: LD_VAR 0 16
75324: PPUSH
75325: CALL_OW 321
75329: PUSH
75330: LD_INT 2
75332: EQUAL
75333: AND
75334: PUSH
75335: LD_INT 7
75337: PUSH
75338: LD_VAR 0 5
75342: IN
75343: PUSH
75344: LD_INT 28
75346: PUSH
75347: LD_VAR 0 5
75351: IN
75352: OR
75353: PUSH
75354: LD_INT 45
75356: PUSH
75357: LD_VAR 0 5
75361: IN
75362: OR
75363: AND
75364: IFFALSE 75618
// begin hex := GetHexInfo ( x , y ) ;
75366: LD_ADDR_VAR 0 4
75370: PUSH
75371: LD_VAR 0 10
75375: PPUSH
75376: LD_VAR 0 11
75380: PPUSH
75381: CALL_OW 546
75385: ST_TO_ADDR
// if hex [ 1 ] then
75386: LD_VAR 0 4
75390: PUSH
75391: LD_INT 1
75393: ARRAY
75394: IFFALSE 75398
// exit ;
75396: GO 75801
// height := hex [ 2 ] ;
75398: LD_ADDR_VAR 0 15
75402: PUSH
75403: LD_VAR 0 4
75407: PUSH
75408: LD_INT 2
75410: ARRAY
75411: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75412: LD_ADDR_VAR 0 14
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: LD_INT 2
75422: PUSH
75423: LD_INT 3
75425: PUSH
75426: LD_INT 5
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: LIST
75433: LIST
75434: ST_TO_ADDR
// for i in tmp do
75435: LD_ADDR_VAR 0 8
75439: PUSH
75440: LD_VAR 0 14
75444: PUSH
75445: FOR_IN
75446: IFFALSE 75616
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75448: LD_ADDR_VAR 0 9
75452: PUSH
75453: LD_VAR 0 10
75457: PPUSH
75458: LD_VAR 0 8
75462: PPUSH
75463: LD_INT 5
75465: PPUSH
75466: CALL_OW 272
75470: PUSH
75471: LD_VAR 0 11
75475: PPUSH
75476: LD_VAR 0 8
75480: PPUSH
75481: LD_INT 5
75483: PPUSH
75484: CALL_OW 273
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75493: LD_VAR 0 9
75497: PUSH
75498: LD_INT 1
75500: ARRAY
75501: PPUSH
75502: LD_VAR 0 9
75506: PUSH
75507: LD_INT 2
75509: ARRAY
75510: PPUSH
75511: CALL_OW 488
75515: IFFALSE 75614
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75517: LD_ADDR_VAR 0 4
75521: PUSH
75522: LD_VAR 0 9
75526: PUSH
75527: LD_INT 1
75529: ARRAY
75530: PPUSH
75531: LD_VAR 0 9
75535: PUSH
75536: LD_INT 2
75538: ARRAY
75539: PPUSH
75540: CALL_OW 546
75544: ST_TO_ADDR
// if hex [ 1 ] then
75545: LD_VAR 0 4
75549: PUSH
75550: LD_INT 1
75552: ARRAY
75553: IFFALSE 75557
// continue ;
75555: GO 75445
// h := hex [ 2 ] ;
75557: LD_ADDR_VAR 0 13
75561: PUSH
75562: LD_VAR 0 4
75566: PUSH
75567: LD_INT 2
75569: ARRAY
75570: ST_TO_ADDR
// if h + 7 < height then
75571: LD_VAR 0 13
75575: PUSH
75576: LD_INT 7
75578: PLUS
75579: PUSH
75580: LD_VAR 0 15
75584: LESS
75585: IFFALSE 75614
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75587: LD_ADDR_VAR 0 18
75591: PUSH
75592: LD_INT 7
75594: PUSH
75595: LD_INT 28
75597: PUSH
75598: LD_INT 45
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: LIST
75605: PUSH
75606: LD_VAR 0 12
75610: ARRAY
75611: ST_TO_ADDR
// break ;
75612: GO 75616
// end ; end ; end ;
75614: GO 75445
75616: POP
75617: POP
// end ; if not weapon then
75618: LD_VAR 0 18
75622: NOT
75623: IFFALSE 75683
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75625: LD_ADDR_VAR 0 5
75629: PUSH
75630: LD_VAR 0 5
75634: PUSH
75635: LD_INT 11
75637: PUSH
75638: LD_INT 30
75640: PUSH
75641: LD_INT 49
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: LIST
75648: DIFF
75649: ST_TO_ADDR
// if not list then
75650: LD_VAR 0 5
75654: NOT
75655: IFFALSE 75659
// exit ;
75657: GO 75801
// weapon := list [ rand ( 1 , list ) ] ;
75659: LD_ADDR_VAR 0 18
75663: PUSH
75664: LD_VAR 0 5
75668: PUSH
75669: LD_INT 1
75671: PPUSH
75672: LD_VAR 0 5
75676: PPUSH
75677: CALL_OW 12
75681: ARRAY
75682: ST_TO_ADDR
// end ; if weapon then
75683: LD_VAR 0 18
75687: IFFALSE 75801
// begin tmp := CostOfWeapon ( weapon ) ;
75689: LD_ADDR_VAR 0 14
75693: PUSH
75694: LD_VAR 0 18
75698: PPUSH
75699: CALL_OW 451
75703: ST_TO_ADDR
// j := GetBase ( tower ) ;
75704: LD_ADDR_VAR 0 9
75708: PUSH
75709: LD_VAR 0 1
75713: PPUSH
75714: CALL_OW 274
75718: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75719: LD_VAR 0 9
75723: PPUSH
75724: LD_INT 1
75726: PPUSH
75727: CALL_OW 275
75731: PUSH
75732: LD_VAR 0 14
75736: PUSH
75737: LD_INT 1
75739: ARRAY
75740: GREATEREQUAL
75741: PUSH
75742: LD_VAR 0 9
75746: PPUSH
75747: LD_INT 2
75749: PPUSH
75750: CALL_OW 275
75754: PUSH
75755: LD_VAR 0 14
75759: PUSH
75760: LD_INT 2
75762: ARRAY
75763: GREATEREQUAL
75764: AND
75765: PUSH
75766: LD_VAR 0 9
75770: PPUSH
75771: LD_INT 3
75773: PPUSH
75774: CALL_OW 275
75778: PUSH
75779: LD_VAR 0 14
75783: PUSH
75784: LD_INT 3
75786: ARRAY
75787: GREATEREQUAL
75788: AND
75789: IFFALSE 75801
// result := weapon ;
75791: LD_ADDR_VAR 0 3
75795: PUSH
75796: LD_VAR 0 18
75800: ST_TO_ADDR
// end ; end ;
75801: LD_VAR 0 3
75805: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75806: LD_INT 0
75808: PPUSH
75809: PPUSH
// result := true ;
75810: LD_ADDR_VAR 0 3
75814: PUSH
75815: LD_INT 1
75817: ST_TO_ADDR
// if array1 = array2 then
75818: LD_VAR 0 1
75822: PUSH
75823: LD_VAR 0 2
75827: EQUAL
75828: IFFALSE 75888
// begin for i = 1 to array1 do
75830: LD_ADDR_VAR 0 4
75834: PUSH
75835: DOUBLE
75836: LD_INT 1
75838: DEC
75839: ST_TO_ADDR
75840: LD_VAR 0 1
75844: PUSH
75845: FOR_TO
75846: IFFALSE 75884
// if array1 [ i ] <> array2 [ i ] then
75848: LD_VAR 0 1
75852: PUSH
75853: LD_VAR 0 4
75857: ARRAY
75858: PUSH
75859: LD_VAR 0 2
75863: PUSH
75864: LD_VAR 0 4
75868: ARRAY
75869: NONEQUAL
75870: IFFALSE 75882
// begin result := false ;
75872: LD_ADDR_VAR 0 3
75876: PUSH
75877: LD_INT 0
75879: ST_TO_ADDR
// break ;
75880: GO 75884
// end ;
75882: GO 75845
75884: POP
75885: POP
// end else
75886: GO 75896
// result := false ;
75888: LD_ADDR_VAR 0 3
75892: PUSH
75893: LD_INT 0
75895: ST_TO_ADDR
// end ;
75896: LD_VAR 0 3
75900: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75901: LD_INT 0
75903: PPUSH
75904: PPUSH
75905: PPUSH
// pom := GetBase ( fac ) ;
75906: LD_ADDR_VAR 0 5
75910: PUSH
75911: LD_VAR 0 1
75915: PPUSH
75916: CALL_OW 274
75920: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75921: LD_ADDR_VAR 0 4
75925: PUSH
75926: LD_VAR 0 2
75930: PUSH
75931: LD_INT 1
75933: ARRAY
75934: PPUSH
75935: LD_VAR 0 2
75939: PUSH
75940: LD_INT 2
75942: ARRAY
75943: PPUSH
75944: LD_VAR 0 2
75948: PUSH
75949: LD_INT 3
75951: ARRAY
75952: PPUSH
75953: LD_VAR 0 2
75957: PUSH
75958: LD_INT 4
75960: ARRAY
75961: PPUSH
75962: CALL_OW 449
75966: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75967: LD_ADDR_VAR 0 3
75971: PUSH
75972: LD_VAR 0 5
75976: PPUSH
75977: LD_INT 1
75979: PPUSH
75980: CALL_OW 275
75984: PUSH
75985: LD_VAR 0 4
75989: PUSH
75990: LD_INT 1
75992: ARRAY
75993: GREATEREQUAL
75994: PUSH
75995: LD_VAR 0 5
75999: PPUSH
76000: LD_INT 2
76002: PPUSH
76003: CALL_OW 275
76007: PUSH
76008: LD_VAR 0 4
76012: PUSH
76013: LD_INT 2
76015: ARRAY
76016: GREATEREQUAL
76017: AND
76018: PUSH
76019: LD_VAR 0 5
76023: PPUSH
76024: LD_INT 3
76026: PPUSH
76027: CALL_OW 275
76031: PUSH
76032: LD_VAR 0 4
76036: PUSH
76037: LD_INT 3
76039: ARRAY
76040: GREATEREQUAL
76041: AND
76042: ST_TO_ADDR
// end ;
76043: LD_VAR 0 3
76047: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76048: LD_INT 0
76050: PPUSH
76051: PPUSH
76052: PPUSH
76053: PPUSH
// pom := GetBase ( building ) ;
76054: LD_ADDR_VAR 0 3
76058: PUSH
76059: LD_VAR 0 1
76063: PPUSH
76064: CALL_OW 274
76068: ST_TO_ADDR
// if not pom then
76069: LD_VAR 0 3
76073: NOT
76074: IFFALSE 76078
// exit ;
76076: GO 76248
// btype := GetBType ( building ) ;
76078: LD_ADDR_VAR 0 5
76082: PUSH
76083: LD_VAR 0 1
76087: PPUSH
76088: CALL_OW 266
76092: ST_TO_ADDR
// if btype = b_armoury then
76093: LD_VAR 0 5
76097: PUSH
76098: LD_INT 4
76100: EQUAL
76101: IFFALSE 76111
// btype := b_barracks ;
76103: LD_ADDR_VAR 0 5
76107: PUSH
76108: LD_INT 5
76110: ST_TO_ADDR
// if btype = b_depot then
76111: LD_VAR 0 5
76115: PUSH
76116: LD_INT 0
76118: EQUAL
76119: IFFALSE 76129
// btype := b_warehouse ;
76121: LD_ADDR_VAR 0 5
76125: PUSH
76126: LD_INT 1
76128: ST_TO_ADDR
// if btype = b_workshop then
76129: LD_VAR 0 5
76133: PUSH
76134: LD_INT 2
76136: EQUAL
76137: IFFALSE 76147
// btype := b_factory ;
76139: LD_ADDR_VAR 0 5
76143: PUSH
76144: LD_INT 3
76146: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76147: LD_ADDR_VAR 0 4
76151: PUSH
76152: LD_VAR 0 5
76156: PPUSH
76157: LD_VAR 0 1
76161: PPUSH
76162: CALL_OW 248
76166: PPUSH
76167: CALL_OW 450
76171: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76172: LD_ADDR_VAR 0 2
76176: PUSH
76177: LD_VAR 0 3
76181: PPUSH
76182: LD_INT 1
76184: PPUSH
76185: CALL_OW 275
76189: PUSH
76190: LD_VAR 0 4
76194: PUSH
76195: LD_INT 1
76197: ARRAY
76198: GREATEREQUAL
76199: PUSH
76200: LD_VAR 0 3
76204: PPUSH
76205: LD_INT 2
76207: PPUSH
76208: CALL_OW 275
76212: PUSH
76213: LD_VAR 0 4
76217: PUSH
76218: LD_INT 2
76220: ARRAY
76221: GREATEREQUAL
76222: AND
76223: PUSH
76224: LD_VAR 0 3
76228: PPUSH
76229: LD_INT 3
76231: PPUSH
76232: CALL_OW 275
76236: PUSH
76237: LD_VAR 0 4
76241: PUSH
76242: LD_INT 3
76244: ARRAY
76245: GREATEREQUAL
76246: AND
76247: ST_TO_ADDR
// end ;
76248: LD_VAR 0 2
76252: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76253: LD_INT 0
76255: PPUSH
76256: PPUSH
76257: PPUSH
// pom := GetBase ( building ) ;
76258: LD_ADDR_VAR 0 4
76262: PUSH
76263: LD_VAR 0 1
76267: PPUSH
76268: CALL_OW 274
76272: ST_TO_ADDR
// if not pom then
76273: LD_VAR 0 4
76277: NOT
76278: IFFALSE 76282
// exit ;
76280: GO 76383
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76282: LD_ADDR_VAR 0 5
76286: PUSH
76287: LD_VAR 0 2
76291: PPUSH
76292: LD_VAR 0 1
76296: PPUSH
76297: CALL_OW 248
76301: PPUSH
76302: CALL_OW 450
76306: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76307: LD_ADDR_VAR 0 3
76311: PUSH
76312: LD_VAR 0 4
76316: PPUSH
76317: LD_INT 1
76319: PPUSH
76320: CALL_OW 275
76324: PUSH
76325: LD_VAR 0 5
76329: PUSH
76330: LD_INT 1
76332: ARRAY
76333: GREATEREQUAL
76334: PUSH
76335: LD_VAR 0 4
76339: PPUSH
76340: LD_INT 2
76342: PPUSH
76343: CALL_OW 275
76347: PUSH
76348: LD_VAR 0 5
76352: PUSH
76353: LD_INT 2
76355: ARRAY
76356: GREATEREQUAL
76357: AND
76358: PUSH
76359: LD_VAR 0 4
76363: PPUSH
76364: LD_INT 3
76366: PPUSH
76367: CALL_OW 275
76371: PUSH
76372: LD_VAR 0 5
76376: PUSH
76377: LD_INT 3
76379: ARRAY
76380: GREATEREQUAL
76381: AND
76382: ST_TO_ADDR
// end ;
76383: LD_VAR 0 3
76387: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76388: LD_INT 0
76390: PPUSH
76391: PPUSH
76392: PPUSH
76393: PPUSH
76394: PPUSH
76395: PPUSH
76396: PPUSH
76397: PPUSH
76398: PPUSH
76399: PPUSH
// result := false ;
76400: LD_ADDR_VAR 0 6
76404: PUSH
76405: LD_INT 0
76407: ST_TO_ADDR
// if not base or not btype or not x or not y then
76408: LD_VAR 0 1
76412: NOT
76413: PUSH
76414: LD_VAR 0 2
76418: NOT
76419: OR
76420: PUSH
76421: LD_VAR 0 3
76425: NOT
76426: OR
76427: PUSH
76428: LD_VAR 0 4
76432: NOT
76433: OR
76434: IFFALSE 76438
// exit ;
76436: GO 77047
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76438: LD_ADDR_VAR 0 12
76442: PUSH
76443: LD_VAR 0 2
76447: PPUSH
76448: LD_VAR 0 3
76452: PPUSH
76453: LD_VAR 0 4
76457: PPUSH
76458: LD_VAR 0 5
76462: PPUSH
76463: LD_VAR 0 1
76467: PUSH
76468: LD_INT 1
76470: ARRAY
76471: PPUSH
76472: CALL_OW 248
76476: PPUSH
76477: LD_INT 0
76479: PPUSH
76480: CALL 77884 0 6
76484: ST_TO_ADDR
// if not hexes then
76485: LD_VAR 0 12
76489: NOT
76490: IFFALSE 76494
// exit ;
76492: GO 77047
// for i = 1 to hexes do
76494: LD_ADDR_VAR 0 7
76498: PUSH
76499: DOUBLE
76500: LD_INT 1
76502: DEC
76503: ST_TO_ADDR
76504: LD_VAR 0 12
76508: PUSH
76509: FOR_TO
76510: IFFALSE 77045
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76512: LD_ADDR_VAR 0 11
76516: PUSH
76517: LD_VAR 0 12
76521: PUSH
76522: LD_VAR 0 7
76526: ARRAY
76527: PUSH
76528: LD_INT 1
76530: ARRAY
76531: PPUSH
76532: LD_VAR 0 12
76536: PUSH
76537: LD_VAR 0 7
76541: ARRAY
76542: PUSH
76543: LD_INT 2
76545: ARRAY
76546: PPUSH
76547: CALL_OW 428
76551: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76552: LD_VAR 0 12
76556: PUSH
76557: LD_VAR 0 7
76561: ARRAY
76562: PUSH
76563: LD_INT 1
76565: ARRAY
76566: PPUSH
76567: LD_VAR 0 12
76571: PUSH
76572: LD_VAR 0 7
76576: ARRAY
76577: PUSH
76578: LD_INT 2
76580: ARRAY
76581: PPUSH
76582: CALL_OW 351
76586: PUSH
76587: LD_VAR 0 12
76591: PUSH
76592: LD_VAR 0 7
76596: ARRAY
76597: PUSH
76598: LD_INT 1
76600: ARRAY
76601: PPUSH
76602: LD_VAR 0 12
76606: PUSH
76607: LD_VAR 0 7
76611: ARRAY
76612: PUSH
76613: LD_INT 2
76615: ARRAY
76616: PPUSH
76617: CALL_OW 488
76621: NOT
76622: OR
76623: PUSH
76624: LD_VAR 0 11
76628: PPUSH
76629: CALL_OW 247
76633: PUSH
76634: LD_INT 3
76636: EQUAL
76637: OR
76638: IFFALSE 76644
// exit ;
76640: POP
76641: POP
76642: GO 77047
// if not tmp or not tmp in base then
76644: LD_VAR 0 11
76648: NOT
76649: PUSH
76650: LD_VAR 0 11
76654: PUSH
76655: LD_VAR 0 1
76659: IN
76660: NOT
76661: OR
76662: IFFALSE 76666
// continue ;
76664: GO 76509
// result := true ;
76666: LD_ADDR_VAR 0 6
76670: PUSH
76671: LD_INT 1
76673: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76674: LD_ADDR_VAR 0 15
76678: PUSH
76679: LD_VAR 0 1
76683: PPUSH
76684: LD_INT 22
76686: PUSH
76687: LD_VAR 0 11
76691: PPUSH
76692: CALL_OW 255
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 2
76703: PUSH
76704: LD_INT 30
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 30
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: LIST
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PPUSH
76733: CALL_OW 72
76737: ST_TO_ADDR
// if dep then
76738: LD_VAR 0 15
76742: IFFALSE 76878
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76744: LD_ADDR_VAR 0 14
76748: PUSH
76749: LD_VAR 0 15
76753: PUSH
76754: LD_INT 1
76756: ARRAY
76757: PPUSH
76758: CALL_OW 250
76762: PPUSH
76763: LD_VAR 0 15
76767: PUSH
76768: LD_INT 1
76770: ARRAY
76771: PPUSH
76772: CALL_OW 254
76776: PPUSH
76777: LD_INT 5
76779: PPUSH
76780: CALL_OW 272
76784: PUSH
76785: LD_VAR 0 15
76789: PUSH
76790: LD_INT 1
76792: ARRAY
76793: PPUSH
76794: CALL_OW 251
76798: PPUSH
76799: LD_VAR 0 15
76803: PUSH
76804: LD_INT 1
76806: ARRAY
76807: PPUSH
76808: CALL_OW 254
76812: PPUSH
76813: LD_INT 5
76815: PPUSH
76816: CALL_OW 273
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76825: LD_VAR 0 14
76829: PUSH
76830: LD_INT 1
76832: ARRAY
76833: PPUSH
76834: LD_VAR 0 14
76838: PUSH
76839: LD_INT 2
76841: ARRAY
76842: PPUSH
76843: CALL_OW 488
76847: IFFALSE 76878
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76849: LD_VAR 0 11
76853: PPUSH
76854: LD_VAR 0 14
76858: PUSH
76859: LD_INT 1
76861: ARRAY
76862: PPUSH
76863: LD_VAR 0 14
76867: PUSH
76868: LD_INT 2
76870: ARRAY
76871: PPUSH
76872: CALL_OW 111
// continue ;
76876: GO 76509
// end ; end ; r := GetDir ( tmp ) ;
76878: LD_ADDR_VAR 0 13
76882: PUSH
76883: LD_VAR 0 11
76887: PPUSH
76888: CALL_OW 254
76892: ST_TO_ADDR
// if r = 5 then
76893: LD_VAR 0 13
76897: PUSH
76898: LD_INT 5
76900: EQUAL
76901: IFFALSE 76911
// r := 0 ;
76903: LD_ADDR_VAR 0 13
76907: PUSH
76908: LD_INT 0
76910: ST_TO_ADDR
// for j = r to 5 do
76911: LD_ADDR_VAR 0 8
76915: PUSH
76916: DOUBLE
76917: LD_VAR 0 13
76921: DEC
76922: ST_TO_ADDR
76923: LD_INT 5
76925: PUSH
76926: FOR_TO
76927: IFFALSE 77041
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76929: LD_ADDR_VAR 0 9
76933: PUSH
76934: LD_VAR 0 11
76938: PPUSH
76939: CALL_OW 250
76943: PPUSH
76944: LD_VAR 0 8
76948: PPUSH
76949: LD_INT 2
76951: PPUSH
76952: CALL_OW 272
76956: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76957: LD_ADDR_VAR 0 10
76961: PUSH
76962: LD_VAR 0 11
76966: PPUSH
76967: CALL_OW 251
76971: PPUSH
76972: LD_VAR 0 8
76976: PPUSH
76977: LD_INT 2
76979: PPUSH
76980: CALL_OW 273
76984: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76985: LD_VAR 0 9
76989: PPUSH
76990: LD_VAR 0 10
76994: PPUSH
76995: CALL_OW 488
76999: PUSH
77000: LD_VAR 0 9
77004: PPUSH
77005: LD_VAR 0 10
77009: PPUSH
77010: CALL_OW 428
77014: NOT
77015: AND
77016: IFFALSE 77039
// begin ComMoveXY ( tmp , _x , _y ) ;
77018: LD_VAR 0 11
77022: PPUSH
77023: LD_VAR 0 9
77027: PPUSH
77028: LD_VAR 0 10
77032: PPUSH
77033: CALL_OW 111
// break ;
77037: GO 77041
// end ; end ;
77039: GO 76926
77041: POP
77042: POP
// end ;
77043: GO 76509
77045: POP
77046: POP
// end ;
77047: LD_VAR 0 6
77051: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77052: LD_INT 0
77054: PPUSH
77055: PPUSH
77056: PPUSH
77057: PPUSH
77058: PPUSH
77059: PPUSH
77060: PPUSH
77061: PPUSH
77062: PPUSH
77063: PPUSH
// result := false ;
77064: LD_ADDR_VAR 0 6
77068: PUSH
77069: LD_INT 0
77071: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77072: LD_VAR 0 1
77076: NOT
77077: PUSH
77078: LD_VAR 0 1
77082: PPUSH
77083: CALL_OW 266
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: LD_INT 1
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: IN
77098: NOT
77099: OR
77100: PUSH
77101: LD_VAR 0 2
77105: NOT
77106: OR
77107: PUSH
77108: LD_VAR 0 5
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 2
77121: PUSH
77122: LD_INT 3
77124: PUSH
77125: LD_INT 4
77127: PUSH
77128: LD_INT 5
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: IN
77139: NOT
77140: OR
77141: PUSH
77142: LD_VAR 0 3
77146: PPUSH
77147: LD_VAR 0 4
77151: PPUSH
77152: CALL_OW 488
77156: NOT
77157: OR
77158: IFFALSE 77162
// exit ;
77160: GO 77879
// pom := GetBase ( depot ) ;
77162: LD_ADDR_VAR 0 10
77166: PUSH
77167: LD_VAR 0 1
77171: PPUSH
77172: CALL_OW 274
77176: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77177: LD_ADDR_VAR 0 11
77181: PUSH
77182: LD_VAR 0 2
77186: PPUSH
77187: LD_VAR 0 1
77191: PPUSH
77192: CALL_OW 248
77196: PPUSH
77197: CALL_OW 450
77201: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77202: LD_VAR 0 10
77206: PPUSH
77207: LD_INT 1
77209: PPUSH
77210: CALL_OW 275
77214: PUSH
77215: LD_VAR 0 11
77219: PUSH
77220: LD_INT 1
77222: ARRAY
77223: GREATEREQUAL
77224: PUSH
77225: LD_VAR 0 10
77229: PPUSH
77230: LD_INT 2
77232: PPUSH
77233: CALL_OW 275
77237: PUSH
77238: LD_VAR 0 11
77242: PUSH
77243: LD_INT 2
77245: ARRAY
77246: GREATEREQUAL
77247: AND
77248: PUSH
77249: LD_VAR 0 10
77253: PPUSH
77254: LD_INT 3
77256: PPUSH
77257: CALL_OW 275
77261: PUSH
77262: LD_VAR 0 11
77266: PUSH
77267: LD_INT 3
77269: ARRAY
77270: GREATEREQUAL
77271: AND
77272: NOT
77273: IFFALSE 77277
// exit ;
77275: GO 77879
// if GetBType ( depot ) = b_depot then
77277: LD_VAR 0 1
77281: PPUSH
77282: CALL_OW 266
77286: PUSH
77287: LD_INT 0
77289: EQUAL
77290: IFFALSE 77302
// dist := 28 else
77292: LD_ADDR_VAR 0 14
77296: PUSH
77297: LD_INT 28
77299: ST_TO_ADDR
77300: GO 77310
// dist := 36 ;
77302: LD_ADDR_VAR 0 14
77306: PUSH
77307: LD_INT 36
77309: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77310: LD_VAR 0 1
77314: PPUSH
77315: LD_VAR 0 3
77319: PPUSH
77320: LD_VAR 0 4
77324: PPUSH
77325: CALL_OW 297
77329: PUSH
77330: LD_VAR 0 14
77334: GREATER
77335: IFFALSE 77339
// exit ;
77337: GO 77879
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77339: LD_ADDR_VAR 0 12
77343: PUSH
77344: LD_VAR 0 2
77348: PPUSH
77349: LD_VAR 0 3
77353: PPUSH
77354: LD_VAR 0 4
77358: PPUSH
77359: LD_VAR 0 5
77363: PPUSH
77364: LD_VAR 0 1
77368: PPUSH
77369: CALL_OW 248
77373: PPUSH
77374: LD_INT 0
77376: PPUSH
77377: CALL 77884 0 6
77381: ST_TO_ADDR
// if not hexes then
77382: LD_VAR 0 12
77386: NOT
77387: IFFALSE 77391
// exit ;
77389: GO 77879
// hex := GetHexInfo ( x , y ) ;
77391: LD_ADDR_VAR 0 15
77395: PUSH
77396: LD_VAR 0 3
77400: PPUSH
77401: LD_VAR 0 4
77405: PPUSH
77406: CALL_OW 546
77410: ST_TO_ADDR
// if hex [ 1 ] then
77411: LD_VAR 0 15
77415: PUSH
77416: LD_INT 1
77418: ARRAY
77419: IFFALSE 77423
// exit ;
77421: GO 77879
// height := hex [ 2 ] ;
77423: LD_ADDR_VAR 0 13
77427: PUSH
77428: LD_VAR 0 15
77432: PUSH
77433: LD_INT 2
77435: ARRAY
77436: ST_TO_ADDR
// for i = 1 to hexes do
77437: LD_ADDR_VAR 0 7
77441: PUSH
77442: DOUBLE
77443: LD_INT 1
77445: DEC
77446: ST_TO_ADDR
77447: LD_VAR 0 12
77451: PUSH
77452: FOR_TO
77453: IFFALSE 77783
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77455: LD_VAR 0 12
77459: PUSH
77460: LD_VAR 0 7
77464: ARRAY
77465: PUSH
77466: LD_INT 1
77468: ARRAY
77469: PPUSH
77470: LD_VAR 0 12
77474: PUSH
77475: LD_VAR 0 7
77479: ARRAY
77480: PUSH
77481: LD_INT 2
77483: ARRAY
77484: PPUSH
77485: CALL_OW 488
77489: NOT
77490: PUSH
77491: LD_VAR 0 12
77495: PUSH
77496: LD_VAR 0 7
77500: ARRAY
77501: PUSH
77502: LD_INT 1
77504: ARRAY
77505: PPUSH
77506: LD_VAR 0 12
77510: PUSH
77511: LD_VAR 0 7
77515: ARRAY
77516: PUSH
77517: LD_INT 2
77519: ARRAY
77520: PPUSH
77521: CALL_OW 428
77525: PUSH
77526: LD_INT 0
77528: GREATER
77529: OR
77530: PUSH
77531: LD_VAR 0 12
77535: PUSH
77536: LD_VAR 0 7
77540: ARRAY
77541: PUSH
77542: LD_INT 1
77544: ARRAY
77545: PPUSH
77546: LD_VAR 0 12
77550: PUSH
77551: LD_VAR 0 7
77555: ARRAY
77556: PUSH
77557: LD_INT 2
77559: ARRAY
77560: PPUSH
77561: CALL_OW 351
77565: OR
77566: IFFALSE 77572
// exit ;
77568: POP
77569: POP
77570: GO 77879
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77572: LD_ADDR_VAR 0 8
77576: PUSH
77577: LD_VAR 0 12
77581: PUSH
77582: LD_VAR 0 7
77586: ARRAY
77587: PUSH
77588: LD_INT 1
77590: ARRAY
77591: PPUSH
77592: LD_VAR 0 12
77596: PUSH
77597: LD_VAR 0 7
77601: ARRAY
77602: PUSH
77603: LD_INT 2
77605: ARRAY
77606: PPUSH
77607: CALL_OW 546
77611: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77612: LD_VAR 0 8
77616: PUSH
77617: LD_INT 1
77619: ARRAY
77620: PUSH
77621: LD_VAR 0 8
77625: PUSH
77626: LD_INT 2
77628: ARRAY
77629: PUSH
77630: LD_VAR 0 13
77634: PUSH
77635: LD_INT 2
77637: PLUS
77638: GREATER
77639: OR
77640: PUSH
77641: LD_VAR 0 8
77645: PUSH
77646: LD_INT 2
77648: ARRAY
77649: PUSH
77650: LD_VAR 0 13
77654: PUSH
77655: LD_INT 2
77657: MINUS
77658: LESS
77659: OR
77660: PUSH
77661: LD_VAR 0 8
77665: PUSH
77666: LD_INT 3
77668: ARRAY
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: LD_INT 8
77675: PUSH
77676: LD_INT 9
77678: PUSH
77679: LD_INT 10
77681: PUSH
77682: LD_INT 11
77684: PUSH
77685: LD_INT 12
77687: PUSH
77688: LD_INT 13
77690: PUSH
77691: LD_INT 16
77693: PUSH
77694: LD_INT 17
77696: PUSH
77697: LD_INT 18
77699: PUSH
77700: LD_INT 19
77702: PUSH
77703: LD_INT 20
77705: PUSH
77706: LD_INT 21
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: LIST
77713: LIST
77714: LIST
77715: LIST
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: LIST
77721: LIST
77722: LIST
77723: IN
77724: NOT
77725: OR
77726: PUSH
77727: LD_VAR 0 8
77731: PUSH
77732: LD_INT 5
77734: ARRAY
77735: NOT
77736: OR
77737: PUSH
77738: LD_VAR 0 8
77742: PUSH
77743: LD_INT 6
77745: ARRAY
77746: PUSH
77747: LD_INT 1
77749: PUSH
77750: LD_INT 2
77752: PUSH
77753: LD_INT 7
77755: PUSH
77756: LD_INT 9
77758: PUSH
77759: LD_INT 10
77761: PUSH
77762: LD_INT 11
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: IN
77773: NOT
77774: OR
77775: IFFALSE 77781
// exit ;
77777: POP
77778: POP
77779: GO 77879
// end ;
77781: GO 77452
77783: POP
77784: POP
// side := GetSide ( depot ) ;
77785: LD_ADDR_VAR 0 9
77789: PUSH
77790: LD_VAR 0 1
77794: PPUSH
77795: CALL_OW 255
77799: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77800: LD_VAR 0 9
77804: PPUSH
77805: LD_VAR 0 3
77809: PPUSH
77810: LD_VAR 0 4
77814: PPUSH
77815: LD_INT 20
77817: PPUSH
77818: CALL 70533 0 4
77822: PUSH
77823: LD_INT 4
77825: ARRAY
77826: IFFALSE 77830
// exit ;
77828: GO 77879
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77830: LD_VAR 0 2
77834: PUSH
77835: LD_INT 29
77837: PUSH
77838: LD_INT 30
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: IN
77845: PUSH
77846: LD_VAR 0 3
77850: PPUSH
77851: LD_VAR 0 4
77855: PPUSH
77856: LD_VAR 0 9
77860: PPUSH
77861: CALL_OW 440
77865: NOT
77866: AND
77867: IFFALSE 77871
// exit ;
77869: GO 77879
// result := true ;
77871: LD_ADDR_VAR 0 6
77875: PUSH
77876: LD_INT 1
77878: ST_TO_ADDR
// end ;
77879: LD_VAR 0 6
77883: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
77884: LD_INT 0
77886: PPUSH
77887: PPUSH
77888: PPUSH
77889: PPUSH
77890: PPUSH
77891: PPUSH
77892: PPUSH
77893: PPUSH
77894: PPUSH
77895: PPUSH
77896: PPUSH
77897: PPUSH
77898: PPUSH
77899: PPUSH
77900: PPUSH
77901: PPUSH
77902: PPUSH
77903: PPUSH
77904: PPUSH
77905: PPUSH
77906: PPUSH
77907: PPUSH
77908: PPUSH
77909: PPUSH
77910: PPUSH
77911: PPUSH
77912: PPUSH
77913: PPUSH
77914: PPUSH
77915: PPUSH
77916: PPUSH
77917: PPUSH
77918: PPUSH
77919: PPUSH
77920: PPUSH
77921: PPUSH
77922: PPUSH
77923: PPUSH
77924: PPUSH
77925: PPUSH
77926: PPUSH
77927: PPUSH
77928: PPUSH
77929: PPUSH
77930: PPUSH
77931: PPUSH
77932: PPUSH
77933: PPUSH
77934: PPUSH
77935: PPUSH
77936: PPUSH
77937: PPUSH
77938: PPUSH
77939: PPUSH
77940: PPUSH
77941: PPUSH
77942: PPUSH
77943: PPUSH
// result = [ ] ;
77944: LD_ADDR_VAR 0 7
77948: PUSH
77949: EMPTY
77950: ST_TO_ADDR
// temp_list = [ ] ;
77951: LD_ADDR_VAR 0 9
77955: PUSH
77956: EMPTY
77957: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77958: LD_VAR 0 4
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: LD_INT 1
77968: PUSH
77969: LD_INT 2
77971: PUSH
77972: LD_INT 3
77974: PUSH
77975: LD_INT 4
77977: PUSH
77978: LD_INT 5
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: IN
77989: NOT
77990: PUSH
77991: LD_VAR 0 1
77995: PUSH
77996: LD_INT 0
77998: PUSH
77999: LD_INT 1
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: IN
78006: PUSH
78007: LD_VAR 0 5
78011: PUSH
78012: LD_INT 1
78014: PUSH
78015: LD_INT 2
78017: PUSH
78018: LD_INT 3
78020: PUSH
78021: EMPTY
78022: LIST
78023: LIST
78024: LIST
78025: IN
78026: NOT
78027: AND
78028: OR
78029: IFFALSE 78033
// exit ;
78031: GO 96424
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78033: LD_VAR 0 1
78037: PUSH
78038: LD_INT 6
78040: PUSH
78041: LD_INT 7
78043: PUSH
78044: LD_INT 8
78046: PUSH
78047: LD_INT 13
78049: PUSH
78050: LD_INT 12
78052: PUSH
78053: LD_INT 15
78055: PUSH
78056: LD_INT 11
78058: PUSH
78059: LD_INT 14
78061: PUSH
78062: LD_INT 10
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: IN
78076: IFFALSE 78086
// btype = b_lab ;
78078: LD_ADDR_VAR 0 1
78082: PUSH
78083: LD_INT 6
78085: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78086: LD_VAR 0 6
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: LD_INT 1
78096: PUSH
78097: LD_INT 2
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: LIST
78104: IN
78105: NOT
78106: PUSH
78107: LD_VAR 0 1
78111: PUSH
78112: LD_INT 0
78114: PUSH
78115: LD_INT 1
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: LD_INT 3
78123: PUSH
78124: LD_INT 6
78126: PUSH
78127: LD_INT 36
78129: PUSH
78130: LD_INT 4
78132: PUSH
78133: LD_INT 5
78135: PUSH
78136: LD_INT 31
78138: PUSH
78139: LD_INT 32
78141: PUSH
78142: LD_INT 33
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: IN
78158: NOT
78159: PUSH
78160: LD_VAR 0 6
78164: PUSH
78165: LD_INT 1
78167: EQUAL
78168: AND
78169: OR
78170: PUSH
78171: LD_VAR 0 1
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: LD_INT 3
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: IN
78186: NOT
78187: PUSH
78188: LD_VAR 0 6
78192: PUSH
78193: LD_INT 2
78195: EQUAL
78196: AND
78197: OR
78198: IFFALSE 78208
// mode = 0 ;
78200: LD_ADDR_VAR 0 6
78204: PUSH
78205: LD_INT 0
78207: ST_TO_ADDR
// case mode of 0 :
78208: LD_VAR 0 6
78212: PUSH
78213: LD_INT 0
78215: DOUBLE
78216: EQUAL
78217: IFTRUE 78221
78219: GO 89674
78221: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78222: LD_ADDR_VAR 0 11
78226: PUSH
78227: LD_INT 0
78229: PUSH
78230: LD_INT 0
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: PUSH
78237: LD_INT 0
78239: PUSH
78240: LD_INT 1
78242: NEG
78243: PUSH
78244: EMPTY
78245: LIST
78246: LIST
78247: PUSH
78248: LD_INT 1
78250: PUSH
78251: LD_INT 0
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PUSH
78258: LD_INT 1
78260: PUSH
78261: LD_INT 1
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 1
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 1
78280: NEG
78281: PUSH
78282: LD_INT 0
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 1
78291: NEG
78292: PUSH
78293: LD_INT 1
78295: NEG
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: LD_INT 2
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 0
78315: PUSH
78316: LD_INT 2
78318: NEG
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 1
78326: PUSH
78327: LD_INT 1
78329: NEG
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: LD_INT 1
78337: PUSH
78338: LD_INT 2
78340: PUSH
78341: EMPTY
78342: LIST
78343: LIST
78344: PUSH
78345: LD_INT 0
78347: PUSH
78348: LD_INT 2
78350: PUSH
78351: EMPTY
78352: LIST
78353: LIST
78354: PUSH
78355: LD_INT 1
78357: NEG
78358: PUSH
78359: LD_INT 1
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: LD_INT 1
78368: PUSH
78369: LD_INT 3
78371: PUSH
78372: EMPTY
78373: LIST
78374: LIST
78375: PUSH
78376: LD_INT 0
78378: PUSH
78379: LD_INT 3
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 1
78388: NEG
78389: PUSH
78390: LD_INT 2
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78415: LD_ADDR_VAR 0 12
78419: PUSH
78420: LD_INT 0
78422: PUSH
78423: LD_INT 0
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 0
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 1
78443: PUSH
78444: LD_INT 0
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 1
78453: PUSH
78454: LD_INT 1
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 0
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 1
78473: NEG
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: LD_INT 1
78484: NEG
78485: PUSH
78486: LD_INT 1
78488: NEG
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 1
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 2
78507: PUSH
78508: LD_INT 0
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 2
78517: PUSH
78518: LD_INT 1
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 1
78527: NEG
78528: PUSH
78529: LD_INT 1
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 2
78538: NEG
78539: PUSH
78540: LD_INT 0
78542: PUSH
78543: EMPTY
78544: LIST
78545: LIST
78546: PUSH
78547: LD_INT 2
78549: NEG
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 2
78561: NEG
78562: PUSH
78563: LD_INT 1
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 3
78572: NEG
78573: PUSH
78574: LD_INT 0
78576: PUSH
78577: EMPTY
78578: LIST
78579: LIST
78580: PUSH
78581: LD_INT 3
78583: NEG
78584: PUSH
78585: LD_INT 1
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: LIST
78597: LIST
78598: LIST
78599: LIST
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78611: LD_ADDR_VAR 0 13
78615: PUSH
78616: LD_INT 0
78618: PUSH
78619: LD_INT 0
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 0
78628: PUSH
78629: LD_INT 1
78631: NEG
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 1
78639: PUSH
78640: LD_INT 0
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 1
78649: PUSH
78650: LD_INT 1
78652: PUSH
78653: EMPTY
78654: LIST
78655: LIST
78656: PUSH
78657: LD_INT 0
78659: PUSH
78660: LD_INT 1
78662: PUSH
78663: EMPTY
78664: LIST
78665: LIST
78666: PUSH
78667: LD_INT 1
78669: NEG
78670: PUSH
78671: LD_INT 0
78673: PUSH
78674: EMPTY
78675: LIST
78676: LIST
78677: PUSH
78678: LD_INT 1
78680: NEG
78681: PUSH
78682: LD_INT 1
78684: NEG
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: LD_INT 2
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 2
78704: PUSH
78705: LD_INT 1
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: LD_INT 2
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 1
78724: PUSH
78725: LD_INT 2
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 2
78734: NEG
78735: PUSH
78736: LD_INT 1
78738: NEG
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: LD_INT 2
78750: NEG
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 2
78758: NEG
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 3
78770: NEG
78771: PUSH
78772: LD_INT 2
78774: NEG
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 3
78782: NEG
78783: PUSH
78784: LD_INT 3
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78810: LD_ADDR_VAR 0 14
78814: PUSH
78815: LD_INT 0
78817: PUSH
78818: LD_INT 0
78820: PUSH
78821: EMPTY
78822: LIST
78823: LIST
78824: PUSH
78825: LD_INT 0
78827: PUSH
78828: LD_INT 1
78830: NEG
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 1
78838: PUSH
78839: LD_INT 0
78841: PUSH
78842: EMPTY
78843: LIST
78844: LIST
78845: PUSH
78846: LD_INT 1
78848: PUSH
78849: LD_INT 1
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 0
78858: PUSH
78859: LD_INT 1
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: PUSH
78866: LD_INT 1
78868: NEG
78869: PUSH
78870: LD_INT 0
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 1
78879: NEG
78880: PUSH
78881: LD_INT 1
78883: NEG
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 1
78891: NEG
78892: PUSH
78893: LD_INT 2
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 0
78903: PUSH
78904: LD_INT 2
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 1
78914: PUSH
78915: LD_INT 1
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 1
78925: PUSH
78926: LD_INT 2
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 0
78935: PUSH
78936: LD_INT 2
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: LD_INT 1
78945: NEG
78946: PUSH
78947: LD_INT 1
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: PUSH
78954: LD_INT 1
78956: NEG
78957: PUSH
78958: LD_INT 3
78960: NEG
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 0
78968: PUSH
78969: LD_INT 3
78971: NEG
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: PUSH
78977: LD_INT 1
78979: PUSH
78980: LD_INT 2
78982: NEG
78983: PUSH
78984: EMPTY
78985: LIST
78986: LIST
78987: PUSH
78988: EMPTY
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79006: LD_ADDR_VAR 0 15
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 0
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 0
79023: PUSH
79024: LD_INT 1
79026: NEG
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 1
79034: PUSH
79035: LD_INT 0
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 1
79044: PUSH
79045: LD_INT 1
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 0
79054: PUSH
79055: LD_INT 1
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 1
79064: NEG
79065: PUSH
79066: LD_INT 0
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: LD_INT 1
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: LD_INT 1
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 2
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 2
79108: PUSH
79109: LD_INT 1
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 1
79118: NEG
79119: PUSH
79120: LD_INT 1
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 2
79129: NEG
79130: PUSH
79131: LD_INT 0
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: LD_INT 1
79144: NEG
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: PUSH
79153: LD_INT 1
79155: NEG
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: LD_INT 0
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 3
79173: PUSH
79174: LD_INT 1
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79199: LD_ADDR_VAR 0 16
79203: PUSH
79204: LD_INT 0
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 0
79216: PUSH
79217: LD_INT 1
79219: NEG
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: LD_INT 0
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: LD_INT 1
79237: PUSH
79238: LD_INT 1
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PUSH
79245: LD_INT 0
79247: PUSH
79248: LD_INT 1
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 1
79257: NEG
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 1
79268: NEG
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: NEG
79281: PUSH
79282: LD_INT 2
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 2
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 2
79302: PUSH
79303: LD_INT 2
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 1
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 2
79322: NEG
79323: PUSH
79324: LD_INT 1
79326: NEG
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: LD_INT 2
79334: NEG
79335: PUSH
79336: LD_INT 2
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 3
79346: PUSH
79347: LD_INT 2
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 3
79356: PUSH
79357: LD_INT 3
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 3
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79392: LD_ADDR_VAR 0 17
79396: PUSH
79397: LD_INT 0
79399: PUSH
79400: LD_INT 0
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: LD_INT 1
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 1
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 1
79430: PUSH
79431: LD_INT 1
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 0
79440: PUSH
79441: LD_INT 1
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 1
79450: NEG
79451: PUSH
79452: LD_INT 0
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 1
79461: NEG
79462: PUSH
79463: LD_INT 1
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 1
79473: NEG
79474: PUSH
79475: LD_INT 2
79477: NEG
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 0
79485: PUSH
79486: LD_INT 2
79488: NEG
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: LD_INT 1
79496: PUSH
79497: LD_INT 1
79499: NEG
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 2
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 2
79517: PUSH
79518: LD_INT 1
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: LD_INT 2
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: LD_INT 1
79537: PUSH
79538: LD_INT 2
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 0
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: LD_INT 1
79561: PUSH
79562: EMPTY
79563: LIST
79564: LIST
79565: PUSH
79566: LD_INT 2
79568: NEG
79569: PUSH
79570: LD_INT 0
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 2
79579: NEG
79580: PUSH
79581: LD_INT 1
79583: NEG
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: NEG
79592: PUSH
79593: LD_INT 2
79595: NEG
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79622: LD_ADDR_VAR 0 18
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 0
79639: PUSH
79640: LD_INT 1
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 1
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 1
79660: PUSH
79661: LD_INT 1
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 0
79670: PUSH
79671: LD_INT 1
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 1
79680: NEG
79681: PUSH
79682: LD_INT 0
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 1
79691: NEG
79692: PUSH
79693: LD_INT 1
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 1
79703: NEG
79704: PUSH
79705: LD_INT 2
79707: NEG
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 0
79715: PUSH
79716: LD_INT 2
79718: NEG
79719: PUSH
79720: EMPTY
79721: LIST
79722: LIST
79723: PUSH
79724: LD_INT 1
79726: PUSH
79727: LD_INT 1
79729: NEG
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: LD_INT 0
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 2
79747: PUSH
79748: LD_INT 1
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: PUSH
79755: LD_INT 2
79757: PUSH
79758: LD_INT 2
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: LD_INT 2
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: PUSH
79775: LD_INT 0
79777: PUSH
79778: LD_INT 2
79780: PUSH
79781: EMPTY
79782: LIST
79783: LIST
79784: PUSH
79785: LD_INT 1
79787: NEG
79788: PUSH
79789: LD_INT 1
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 2
79798: NEG
79799: PUSH
79800: LD_INT 0
79802: PUSH
79803: EMPTY
79804: LIST
79805: LIST
79806: PUSH
79807: LD_INT 2
79809: NEG
79810: PUSH
79811: LD_INT 1
79813: NEG
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: NEG
79822: PUSH
79823: LD_INT 2
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: EMPTY
79832: LIST
79833: LIST
79834: LIST
79835: LIST
79836: LIST
79837: LIST
79838: LIST
79839: LIST
79840: LIST
79841: LIST
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79852: LD_ADDR_VAR 0 19
79856: PUSH
79857: LD_INT 0
79859: PUSH
79860: LD_INT 0
79862: PUSH
79863: EMPTY
79864: LIST
79865: LIST
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: LD_INT 1
79872: NEG
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: LD_INT 1
79880: PUSH
79881: LD_INT 0
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PUSH
79888: LD_INT 1
79890: PUSH
79891: LD_INT 1
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 1
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 1
79910: NEG
79911: PUSH
79912: LD_INT 0
79914: PUSH
79915: EMPTY
79916: LIST
79917: LIST
79918: PUSH
79919: LD_INT 1
79921: NEG
79922: PUSH
79923: LD_INT 1
79925: NEG
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: LD_INT 2
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 0
79945: PUSH
79946: LD_INT 2
79948: NEG
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: LD_INT 1
79959: NEG
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 2
79967: PUSH
79968: LD_INT 0
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 2
79977: PUSH
79978: LD_INT 1
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 2
79987: PUSH
79988: LD_INT 2
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 1
79997: PUSH
79998: LD_INT 2
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 0
80007: PUSH
80008: LD_INT 2
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 1
80017: NEG
80018: PUSH
80019: LD_INT 1
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 2
80028: NEG
80029: PUSH
80030: LD_INT 0
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: NEG
80040: PUSH
80041: LD_INT 1
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 2
80051: NEG
80052: PUSH
80053: LD_INT 2
80055: NEG
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80082: LD_ADDR_VAR 0 20
80086: PUSH
80087: LD_INT 0
80089: PUSH
80090: LD_INT 0
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 0
80099: PUSH
80100: LD_INT 1
80102: NEG
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 1
80110: PUSH
80111: LD_INT 0
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 1
80120: PUSH
80121: LD_INT 1
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 0
80130: PUSH
80131: LD_INT 1
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 1
80140: NEG
80141: PUSH
80142: LD_INT 0
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: LD_INT 1
80155: NEG
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: LD_INT 2
80167: NEG
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 0
80175: PUSH
80176: LD_INT 2
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: LD_INT 0
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 2
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: LD_INT 2
80217: PUSH
80218: LD_INT 2
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: PUSH
80228: LD_INT 2
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 0
80237: PUSH
80238: LD_INT 2
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 1
80247: NEG
80248: PUSH
80249: LD_INT 1
80251: PUSH
80252: EMPTY
80253: LIST
80254: LIST
80255: PUSH
80256: LD_INT 2
80258: NEG
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 2
80269: NEG
80270: PUSH
80271: LD_INT 1
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: LD_INT 2
80285: NEG
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: LIST
80301: LIST
80302: LIST
80303: LIST
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80312: LD_ADDR_VAR 0 21
80316: PUSH
80317: LD_INT 0
80319: PUSH
80320: LD_INT 0
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 0
80329: PUSH
80330: LD_INT 1
80332: NEG
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 1
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: LD_INT 1
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: LD_INT 0
80360: PUSH
80361: LD_INT 1
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: PUSH
80368: LD_INT 1
80370: NEG
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 1
80381: NEG
80382: PUSH
80383: LD_INT 1
80385: NEG
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: NEG
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 2
80408: NEG
80409: PUSH
80410: EMPTY
80411: LIST
80412: LIST
80413: PUSH
80414: LD_INT 1
80416: PUSH
80417: LD_INT 1
80419: NEG
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 2
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 2
80437: PUSH
80438: LD_INT 1
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 2
80447: PUSH
80448: LD_INT 2
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 1
80457: PUSH
80458: LD_INT 2
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 0
80467: PUSH
80468: LD_INT 2
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 1
80477: NEG
80478: PUSH
80479: LD_INT 1
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 2
80488: NEG
80489: PUSH
80490: LD_INT 0
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 2
80499: NEG
80500: PUSH
80501: LD_INT 1
80503: NEG
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: NEG
80512: PUSH
80513: LD_INT 2
80515: NEG
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: LIST
80525: LIST
80526: LIST
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80542: LD_ADDR_VAR 0 22
80546: PUSH
80547: LD_INT 0
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: LD_INT 1
80562: NEG
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: LD_INT 0
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 1
80580: PUSH
80581: LD_INT 1
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 0
80590: PUSH
80591: LD_INT 1
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 1
80600: NEG
80601: PUSH
80602: LD_INT 0
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 1
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 2
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 0
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 1
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 2
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 2
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: LD_INT 2
80677: PUSH
80678: LD_INT 2
80680: PUSH
80681: EMPTY
80682: LIST
80683: LIST
80684: PUSH
80685: LD_INT 1
80687: PUSH
80688: LD_INT 2
80690: PUSH
80691: EMPTY
80692: LIST
80693: LIST
80694: PUSH
80695: LD_INT 0
80697: PUSH
80698: LD_INT 2
80700: PUSH
80701: EMPTY
80702: LIST
80703: LIST
80704: PUSH
80705: LD_INT 1
80707: NEG
80708: PUSH
80709: LD_INT 1
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 2
80718: NEG
80719: PUSH
80720: LD_INT 0
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: NEG
80730: PUSH
80731: LD_INT 1
80733: NEG
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: LD_INT 2
80745: NEG
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: EMPTY
80752: LIST
80753: LIST
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80772: LD_ADDR_VAR 0 23
80776: PUSH
80777: LD_INT 0
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: EMPTY
80784: LIST
80785: LIST
80786: PUSH
80787: LD_INT 0
80789: PUSH
80790: LD_INT 1
80792: NEG
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 1
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: PUSH
80811: LD_INT 1
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 0
80820: PUSH
80821: LD_INT 1
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: LD_INT 0
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 1
80841: NEG
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 1
80853: NEG
80854: PUSH
80855: LD_INT 2
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 0
80865: PUSH
80866: LD_INT 2
80868: NEG
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 1
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 2
80887: PUSH
80888: LD_INT 0
80890: PUSH
80891: EMPTY
80892: LIST
80893: LIST
80894: PUSH
80895: LD_INT 2
80897: PUSH
80898: LD_INT 1
80900: PUSH
80901: EMPTY
80902: LIST
80903: LIST
80904: PUSH
80905: LD_INT 2
80907: PUSH
80908: LD_INT 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 1
80917: PUSH
80918: LD_INT 2
80920: PUSH
80921: EMPTY
80922: LIST
80923: LIST
80924: PUSH
80925: LD_INT 0
80927: PUSH
80928: LD_INT 2
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 1
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: LD_INT 2
80948: NEG
80949: PUSH
80950: LD_INT 0
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PUSH
80957: LD_INT 2
80959: NEG
80960: PUSH
80961: LD_INT 1
80963: NEG
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: NEG
80972: PUSH
80973: LD_INT 2
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 2
80983: NEG
80984: PUSH
80985: LD_INT 3
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 1
80995: NEG
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: LD_INT 2
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 2
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: LIST
81031: LIST
81032: LIST
81033: LIST
81034: LIST
81035: LIST
81036: LIST
81037: LIST
81038: LIST
81039: LIST
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81052: LD_ADDR_VAR 0 24
81056: PUSH
81057: LD_INT 0
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 1
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: PUSH
81081: LD_INT 0
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 1
81090: PUSH
81091: LD_INT 1
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 0
81100: PUSH
81101: LD_INT 1
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 1
81110: NEG
81111: PUSH
81112: LD_INT 0
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PUSH
81119: LD_INT 1
81121: NEG
81122: PUSH
81123: LD_INT 1
81125: NEG
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 0
81145: PUSH
81146: LD_INT 2
81148: NEG
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 1
81156: PUSH
81157: LD_INT 1
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 2
81167: PUSH
81168: LD_INT 0
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: PUSH
81178: LD_INT 1
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: PUSH
81188: LD_INT 2
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: LD_INT 2
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: PUSH
81205: LD_INT 0
81207: PUSH
81208: LD_INT 2
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: PUSH
81215: LD_INT 1
81217: NEG
81218: PUSH
81219: LD_INT 1
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PUSH
81226: LD_INT 2
81228: NEG
81229: PUSH
81230: LD_INT 0
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 2
81239: NEG
81240: PUSH
81241: LD_INT 1
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: LD_INT 2
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: PUSH
81264: LD_INT 2
81266: NEG
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 2
81274: PUSH
81275: LD_INT 1
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 3
81285: PUSH
81286: LD_INT 1
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 3
81295: PUSH
81296: LD_INT 2
81298: PUSH
81299: EMPTY
81300: LIST
81301: LIST
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: LIST
81307: LIST
81308: LIST
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81328: LD_ADDR_VAR 0 25
81332: PUSH
81333: LD_INT 0
81335: PUSH
81336: LD_INT 0
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: PUSH
81343: LD_INT 0
81345: PUSH
81346: LD_INT 1
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 1
81356: PUSH
81357: LD_INT 0
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 1
81366: PUSH
81367: LD_INT 1
81369: PUSH
81370: EMPTY
81371: LIST
81372: LIST
81373: PUSH
81374: LD_INT 0
81376: PUSH
81377: LD_INT 1
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 1
81386: NEG
81387: PUSH
81388: LD_INT 0
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: NEG
81398: PUSH
81399: LD_INT 1
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 2
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 0
81421: PUSH
81422: LD_INT 2
81424: NEG
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: PUSH
81430: LD_INT 1
81432: PUSH
81433: LD_INT 1
81435: NEG
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: LD_INT 0
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 2
81453: PUSH
81454: LD_INT 1
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 2
81463: PUSH
81464: LD_INT 2
81466: PUSH
81467: EMPTY
81468: LIST
81469: LIST
81470: PUSH
81471: LD_INT 1
81473: PUSH
81474: LD_INT 2
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 0
81483: PUSH
81484: LD_INT 2
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 1
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 2
81504: NEG
81505: PUSH
81506: LD_INT 0
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 2
81515: NEG
81516: PUSH
81517: LD_INT 1
81519: NEG
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: NEG
81528: PUSH
81529: LD_INT 2
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 3
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 3
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 2
81559: PUSH
81560: LD_INT 3
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 3
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: LIST
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81602: LD_ADDR_VAR 0 26
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 0
81619: PUSH
81620: LD_INT 1
81622: NEG
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: PUSH
81631: LD_INT 0
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: PUSH
81641: LD_INT 1
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 0
81650: PUSH
81651: LD_INT 1
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: LD_INT 1
81675: NEG
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 1
81683: NEG
81684: PUSH
81685: LD_INT 2
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 0
81695: PUSH
81696: LD_INT 2
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 1
81706: PUSH
81707: LD_INT 1
81709: NEG
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 2
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 2
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 2
81737: PUSH
81738: LD_INT 2
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 1
81747: PUSH
81748: LD_INT 2
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 0
81757: PUSH
81758: LD_INT 2
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 1
81767: NEG
81768: PUSH
81769: LD_INT 1
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 2
81778: NEG
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 2
81789: NEG
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: LD_INT 2
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 2
81813: PUSH
81814: LD_INT 3
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 1
81823: PUSH
81824: LD_INT 3
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: LD_INT 2
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: LD_INT 1
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: LIST
81857: LIST
81858: LIST
81859: LIST
81860: LIST
81861: LIST
81862: LIST
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81878: LD_ADDR_VAR 0 27
81882: PUSH
81883: LD_INT 0
81885: PUSH
81886: LD_INT 0
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_INT 0
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: PUSH
81907: LD_INT 0
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PUSH
81914: LD_INT 1
81916: PUSH
81917: LD_INT 1
81919: PUSH
81920: EMPTY
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 0
81926: PUSH
81927: LD_INT 1
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: PUSH
81934: LD_INT 1
81936: NEG
81937: PUSH
81938: LD_INT 0
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 1
81947: NEG
81948: PUSH
81949: LD_INT 1
81951: NEG
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 2
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_INT 2
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: EMPTY
82008: LIST
82009: LIST
82010: PUSH
82011: LD_INT 2
82013: PUSH
82014: LD_INT 2
82016: PUSH
82017: EMPTY
82018: LIST
82019: LIST
82020: PUSH
82021: LD_INT 1
82023: PUSH
82024: LD_INT 2
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: LD_INT 2
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 1
82043: NEG
82044: PUSH
82045: LD_INT 1
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 2
82054: NEG
82055: PUSH
82056: LD_INT 0
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 2
82065: NEG
82066: PUSH
82067: LD_INT 1
82069: NEG
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 2
82077: NEG
82078: PUSH
82079: LD_INT 2
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 2
82100: NEG
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 3
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 3
82123: NEG
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: LIST
82137: LIST
82138: LIST
82139: LIST
82140: LIST
82141: LIST
82142: LIST
82143: LIST
82144: LIST
82145: LIST
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82158: LD_ADDR_VAR 0 28
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: LD_INT 0
82168: PUSH
82169: EMPTY
82170: LIST
82171: LIST
82172: PUSH
82173: LD_INT 0
82175: PUSH
82176: LD_INT 1
82178: NEG
82179: PUSH
82180: EMPTY
82181: LIST
82182: LIST
82183: PUSH
82184: LD_INT 1
82186: PUSH
82187: LD_INT 0
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: PUSH
82194: LD_INT 1
82196: PUSH
82197: LD_INT 1
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 0
82206: PUSH
82207: LD_INT 1
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 1
82216: NEG
82217: PUSH
82218: LD_INT 0
82220: PUSH
82221: EMPTY
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: LD_INT 1
82231: NEG
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 1
82239: NEG
82240: PUSH
82241: LD_INT 2
82243: NEG
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 0
82251: PUSH
82252: LD_INT 2
82254: NEG
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 2
82273: PUSH
82274: LD_INT 0
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 2
82283: PUSH
82284: LD_INT 1
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 2
82293: PUSH
82294: LD_INT 2
82296: PUSH
82297: EMPTY
82298: LIST
82299: LIST
82300: PUSH
82301: LD_INT 1
82303: PUSH
82304: LD_INT 2
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 0
82313: PUSH
82314: LD_INT 2
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: NEG
82324: PUSH
82325: LD_INT 1
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: NEG
82335: PUSH
82336: LD_INT 0
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 2
82345: NEG
82346: PUSH
82347: LD_INT 1
82349: NEG
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: NEG
82358: PUSH
82359: LD_INT 2
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: LD_INT 3
82373: NEG
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 1
82381: NEG
82382: PUSH
82383: LD_INT 3
82385: NEG
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 3
82393: NEG
82394: PUSH
82395: LD_INT 1
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 3
82405: NEG
82406: PUSH
82407: LD_INT 2
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82440: LD_ADDR_VAR 0 29
82444: PUSH
82445: LD_INT 0
82447: PUSH
82448: LD_INT 0
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 1
82478: PUSH
82479: LD_INT 1
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 0
82488: PUSH
82489: LD_INT 1
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 1
82498: NEG
82499: PUSH
82500: LD_INT 0
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 1
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 1
82521: NEG
82522: PUSH
82523: LD_INT 2
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 0
82533: PUSH
82534: LD_INT 2
82536: NEG
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 1
82544: PUSH
82545: LD_INT 1
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 2
82555: PUSH
82556: LD_INT 0
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 2
82565: PUSH
82566: LD_INT 1
82568: PUSH
82569: EMPTY
82570: LIST
82571: LIST
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: LD_INT 2
82578: PUSH
82579: EMPTY
82580: LIST
82581: LIST
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: LD_INT 2
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 1
82595: NEG
82596: PUSH
82597: LD_INT 1
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 2
82606: NEG
82607: PUSH
82608: LD_INT 1
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: LD_INT 2
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 2
82630: NEG
82631: PUSH
82632: LD_INT 3
82634: NEG
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: LD_INT 1
82645: NEG
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 3
82653: PUSH
82654: LD_INT 1
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 1
82663: PUSH
82664: LD_INT 3
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 1
82673: NEG
82674: PUSH
82675: LD_INT 2
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 3
82684: NEG
82685: PUSH
82686: LD_INT 2
82688: NEG
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82719: LD_ADDR_VAR 0 30
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 0
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 0
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: LD_INT 0
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 1
82757: PUSH
82758: LD_INT 1
82760: PUSH
82761: EMPTY
82762: LIST
82763: LIST
82764: PUSH
82765: LD_INT 0
82767: PUSH
82768: LD_INT 1
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: PUSH
82775: LD_INT 1
82777: NEG
82778: PUSH
82779: LD_INT 0
82781: PUSH
82782: EMPTY
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 1
82788: NEG
82789: PUSH
82790: LD_INT 1
82792: NEG
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: LD_INT 2
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 0
82812: PUSH
82813: LD_INT 2
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: PUSH
82824: LD_INT 1
82826: NEG
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: EMPTY
82839: LIST
82840: LIST
82841: PUSH
82842: LD_INT 2
82844: PUSH
82845: LD_INT 1
82847: PUSH
82848: EMPTY
82849: LIST
82850: LIST
82851: PUSH
82852: LD_INT 2
82854: PUSH
82855: LD_INT 2
82857: PUSH
82858: EMPTY
82859: LIST
82860: LIST
82861: PUSH
82862: LD_INT 1
82864: PUSH
82865: LD_INT 2
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: LD_INT 1
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PUSH
82883: LD_INT 2
82885: NEG
82886: PUSH
82887: LD_INT 0
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: PUSH
82894: LD_INT 2
82896: NEG
82897: PUSH
82898: LD_INT 1
82900: NEG
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 1
82908: NEG
82909: PUSH
82910: LD_INT 3
82912: NEG
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 1
82920: PUSH
82921: LD_INT 2
82923: NEG
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 3
82931: PUSH
82932: LD_INT 2
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: PUSH
82942: LD_INT 3
82944: PUSH
82945: EMPTY
82946: LIST
82947: LIST
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: LD_INT 1
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 3
82962: NEG
82963: PUSH
82964: LD_INT 1
82966: NEG
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82997: LD_ADDR_VAR 0 31
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: LD_INT 0
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: LD_INT 1
83017: NEG
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 1
83025: PUSH
83026: LD_INT 0
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: LD_INT 1
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 0
83045: PUSH
83046: LD_INT 1
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: NEG
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 1
83066: NEG
83067: PUSH
83068: LD_INT 1
83070: NEG
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: PUSH
83091: LD_INT 1
83093: NEG
83094: PUSH
83095: EMPTY
83096: LIST
83097: LIST
83098: PUSH
83099: LD_INT 2
83101: PUSH
83102: LD_INT 0
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 2
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 1
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 0
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: NEG
83152: PUSH
83153: LD_INT 1
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 2
83162: NEG
83163: PUSH
83164: LD_INT 1
83166: NEG
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 2
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: LD_INT 3
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 3
83209: PUSH
83210: LD_INT 1
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: PUSH
83220: LD_INT 3
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 1
83229: NEG
83230: PUSH
83231: LD_INT 2
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 3
83240: NEG
83241: PUSH
83242: LD_INT 2
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83275: LD_ADDR_VAR 0 32
83279: PUSH
83280: LD_INT 0
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 1
83303: PUSH
83304: LD_INT 0
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: PUSH
83314: LD_INT 1
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 0
83323: PUSH
83324: LD_INT 1
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 1
83333: NEG
83334: PUSH
83335: LD_INT 0
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 1
83344: NEG
83345: PUSH
83346: LD_INT 1
83348: NEG
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: LD_INT 2
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 0
83368: PUSH
83369: LD_INT 2
83371: NEG
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: PUSH
83380: LD_INT 1
83382: NEG
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 2
83390: PUSH
83391: LD_INT 1
83393: PUSH
83394: EMPTY
83395: LIST
83396: LIST
83397: PUSH
83398: LD_INT 2
83400: PUSH
83401: LD_INT 2
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: PUSH
83408: LD_INT 1
83410: PUSH
83411: LD_INT 2
83413: PUSH
83414: EMPTY
83415: LIST
83416: LIST
83417: PUSH
83418: LD_INT 0
83420: PUSH
83421: LD_INT 2
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: NEG
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: NEG
83442: PUSH
83443: LD_INT 0
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 2
83452: NEG
83453: PUSH
83454: LD_INT 1
83456: NEG
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: LD_INT 3
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: LD_INT 2
83479: NEG
83480: PUSH
83481: EMPTY
83482: LIST
83483: LIST
83484: PUSH
83485: LD_INT 3
83487: PUSH
83488: LD_INT 2
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 2
83497: PUSH
83498: LD_INT 3
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 2
83507: NEG
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 3
83518: NEG
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83553: LD_ADDR_VAR 0 33
83557: PUSH
83558: LD_INT 0
83560: PUSH
83561: LD_INT 0
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 0
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 1
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: PUSH
83592: LD_INT 1
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 0
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 1
83611: NEG
83612: PUSH
83613: LD_INT 0
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 1
83622: NEG
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: NEG
83635: PUSH
83636: LD_INT 2
83638: NEG
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 1
83646: PUSH
83647: LD_INT 1
83649: NEG
83650: PUSH
83651: EMPTY
83652: LIST
83653: LIST
83654: PUSH
83655: LD_INT 2
83657: PUSH
83658: LD_INT 0
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 2
83667: PUSH
83668: LD_INT 1
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PUSH
83675: LD_INT 1
83677: PUSH
83678: LD_INT 2
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 0
83687: PUSH
83688: LD_INT 2
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: LD_INT 1
83701: PUSH
83702: EMPTY
83703: LIST
83704: LIST
83705: PUSH
83706: LD_INT 2
83708: NEG
83709: PUSH
83710: LD_INT 0
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: LD_INT 2
83719: NEG
83720: PUSH
83721: LD_INT 1
83723: NEG
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: LD_INT 2
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 3
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: PUSH
83756: LD_INT 1
83758: NEG
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 3
83766: PUSH
83767: LD_INT 1
83769: PUSH
83770: EMPTY
83771: LIST
83772: LIST
83773: PUSH
83774: LD_INT 1
83776: PUSH
83777: LD_INT 3
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 1
83786: NEG
83787: PUSH
83788: LD_INT 2
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: LD_INT 3
83797: NEG
83798: PUSH
83799: LD_INT 2
83801: NEG
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83832: LD_ADDR_VAR 0 34
83836: PUSH
83837: LD_INT 0
83839: PUSH
83840: LD_INT 0
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 0
83849: PUSH
83850: LD_INT 1
83852: NEG
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 1
83860: PUSH
83861: LD_INT 0
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: PUSH
83871: LD_INT 1
83873: PUSH
83874: EMPTY
83875: LIST
83876: LIST
83877: PUSH
83878: LD_INT 0
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: EMPTY
83885: LIST
83886: LIST
83887: PUSH
83888: LD_INT 1
83890: NEG
83891: PUSH
83892: LD_INT 0
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 1
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: NEG
83914: PUSH
83915: LD_INT 2
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 0
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 1
83936: PUSH
83937: LD_INT 1
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 2
83947: PUSH
83948: LD_INT 1
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 2
83957: PUSH
83958: LD_INT 2
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 2
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: LD_INT 1
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 2
83988: NEG
83989: PUSH
83990: LD_INT 0
83992: PUSH
83993: EMPTY
83994: LIST
83995: LIST
83996: PUSH
83997: LD_INT 2
83999: NEG
84000: PUSH
84001: LD_INT 1
84003: NEG
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: NEG
84012: PUSH
84013: LD_INT 2
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 1
84023: NEG
84024: PUSH
84025: LD_INT 3
84027: NEG
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: PUSH
84036: LD_INT 2
84038: NEG
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 3
84046: PUSH
84047: LD_INT 2
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 2
84056: PUSH
84057: LD_INT 3
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: PUSH
84064: LD_INT 2
84066: NEG
84067: PUSH
84068: LD_INT 1
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 3
84077: NEG
84078: PUSH
84079: LD_INT 1
84081: NEG
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84112: LD_ADDR_VAR 0 35
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: LD_INT 0
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PUSH
84127: LD_INT 0
84129: PUSH
84130: LD_INT 1
84132: NEG
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 1
84140: PUSH
84141: LD_INT 0
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 1
84150: PUSH
84151: LD_INT 1
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PUSH
84158: LD_INT 0
84160: PUSH
84161: LD_INT 1
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 1
84170: NEG
84171: PUSH
84172: LD_INT 0
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: LD_INT 1
84185: NEG
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 2
84203: NEG
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84224: LD_ADDR_VAR 0 36
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: LD_INT 0
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: LD_INT 1
84244: NEG
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 1
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 1
84262: PUSH
84263: LD_INT 1
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 0
84272: PUSH
84273: LD_INT 1
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: NEG
84283: PUSH
84284: LD_INT 0
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 1
84293: NEG
84294: PUSH
84295: LD_INT 1
84297: NEG
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 2
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 1
84317: PUSH
84318: LD_INT 2
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84336: LD_ADDR_VAR 0 37
84340: PUSH
84341: LD_INT 0
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: LD_INT 0
84353: PUSH
84354: LD_INT 1
84356: NEG
84357: PUSH
84358: EMPTY
84359: LIST
84360: LIST
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: LD_INT 0
84367: PUSH
84368: EMPTY
84369: LIST
84370: LIST
84371: PUSH
84372: LD_INT 1
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: LD_INT 1
84387: PUSH
84388: EMPTY
84389: LIST
84390: LIST
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: PUSH
84396: LD_INT 0
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 1
84405: NEG
84406: PUSH
84407: LD_INT 1
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 1
84417: PUSH
84418: LD_INT 1
84420: NEG
84421: PUSH
84422: EMPTY
84423: LIST
84424: LIST
84425: PUSH
84426: LD_INT 1
84428: NEG
84429: PUSH
84430: LD_INT 1
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84448: LD_ADDR_VAR 0 38
84452: PUSH
84453: LD_INT 0
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 0
84465: PUSH
84466: LD_INT 1
84468: NEG
84469: PUSH
84470: EMPTY
84471: LIST
84472: LIST
84473: PUSH
84474: LD_INT 1
84476: PUSH
84477: LD_INT 0
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: LD_INT 1
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 0
84496: PUSH
84497: LD_INT 1
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: PUSH
84504: LD_INT 1
84506: NEG
84507: PUSH
84508: LD_INT 0
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: NEG
84518: PUSH
84519: LD_INT 1
84521: NEG
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 2
84529: PUSH
84530: LD_INT 1
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 2
84539: NEG
84540: PUSH
84541: LD_INT 1
84543: NEG
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: EMPTY
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84560: LD_ADDR_VAR 0 39
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: LD_INT 0
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 0
84577: PUSH
84578: LD_INT 1
84580: NEG
84581: PUSH
84582: EMPTY
84583: LIST
84584: LIST
84585: PUSH
84586: LD_INT 1
84588: PUSH
84589: LD_INT 0
84591: PUSH
84592: EMPTY
84593: LIST
84594: LIST
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: LD_INT 1
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 0
84608: PUSH
84609: LD_INT 1
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 1
84618: NEG
84619: PUSH
84620: LD_INT 0
84622: PUSH
84623: EMPTY
84624: LIST
84625: LIST
84626: PUSH
84627: LD_INT 1
84629: NEG
84630: PUSH
84631: LD_INT 1
84633: NEG
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: NEG
84642: PUSH
84643: LD_INT 2
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: PUSH
84654: LD_INT 2
84656: PUSH
84657: EMPTY
84658: LIST
84659: LIST
84660: PUSH
84661: EMPTY
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84672: LD_ADDR_VAR 0 40
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: LD_INT 0
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 0
84689: PUSH
84690: LD_INT 1
84692: NEG
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: PUSH
84698: LD_INT 1
84700: PUSH
84701: LD_INT 0
84703: PUSH
84704: EMPTY
84705: LIST
84706: LIST
84707: PUSH
84708: LD_INT 1
84710: PUSH
84711: LD_INT 1
84713: PUSH
84714: EMPTY
84715: LIST
84716: LIST
84717: PUSH
84718: LD_INT 0
84720: PUSH
84721: LD_INT 1
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: LD_INT 0
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: PUSH
84739: LD_INT 1
84741: NEG
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: LD_INT 1
84756: NEG
84757: PUSH
84758: EMPTY
84759: LIST
84760: LIST
84761: PUSH
84762: LD_INT 1
84764: NEG
84765: PUSH
84766: LD_INT 1
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84784: LD_ADDR_VAR 0 41
84788: PUSH
84789: LD_INT 0
84791: PUSH
84792: LD_INT 0
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 0
84801: PUSH
84802: LD_INT 1
84804: NEG
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 1
84812: PUSH
84813: LD_INT 0
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: LD_INT 1
84825: PUSH
84826: EMPTY
84827: LIST
84828: LIST
84829: PUSH
84830: LD_INT 0
84832: PUSH
84833: LD_INT 1
84835: PUSH
84836: EMPTY
84837: LIST
84838: LIST
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: LD_INT 0
84846: PUSH
84847: EMPTY
84848: LIST
84849: LIST
84850: PUSH
84851: LD_INT 1
84853: NEG
84854: PUSH
84855: LD_INT 1
84857: NEG
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 1
84865: NEG
84866: PUSH
84867: LD_INT 2
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: PUSH
84878: LD_INT 1
84880: NEG
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: PUSH
84889: LD_INT 0
84891: PUSH
84892: EMPTY
84893: LIST
84894: LIST
84895: PUSH
84896: LD_INT 2
84898: PUSH
84899: LD_INT 1
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: PUSH
84906: LD_INT 2
84908: PUSH
84909: LD_INT 2
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 1
84918: PUSH
84919: LD_INT 2
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 1
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: LD_INT 2
84939: NEG
84940: PUSH
84941: LD_INT 0
84943: PUSH
84944: EMPTY
84945: LIST
84946: LIST
84947: PUSH
84948: LD_INT 2
84950: NEG
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: NEG
84963: PUSH
84964: LD_INT 2
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: NEG
84975: PUSH
84976: LD_INT 3
84978: NEG
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 2
84986: PUSH
84987: LD_INT 1
84989: NEG
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 3
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: LD_INT 3
85007: PUSH
85008: LD_INT 1
85010: PUSH
85011: EMPTY
85012: LIST
85013: LIST
85014: PUSH
85015: LD_INT 3
85017: PUSH
85018: LD_INT 2
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 3
85027: PUSH
85028: LD_INT 3
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 2
85037: PUSH
85038: LD_INT 3
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: LD_INT 1
85051: PUSH
85052: EMPTY
85053: LIST
85054: LIST
85055: PUSH
85056: LD_INT 3
85058: NEG
85059: PUSH
85060: LD_INT 0
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 3
85069: NEG
85070: PUSH
85071: LD_INT 1
85073: NEG
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 3
85081: NEG
85082: PUSH
85083: LD_INT 2
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 3
85093: NEG
85094: PUSH
85095: LD_INT 3
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85134: LD_ADDR_VAR 0 42
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 0
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 1
85162: PUSH
85163: LD_INT 0
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: PUSH
85173: LD_INT 1
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 0
85182: PUSH
85183: LD_INT 1
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: PUSH
85190: LD_INT 1
85192: NEG
85193: PUSH
85194: LD_INT 0
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_INT 1
85203: NEG
85204: PUSH
85205: LD_INT 1
85207: NEG
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 2
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: LD_INT 2
85230: NEG
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: LD_INT 1
85241: NEG
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 2
85249: PUSH
85250: LD_INT 1
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 2
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 1
85269: PUSH
85270: LD_INT 2
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: LD_INT 2
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: PUSH
85291: LD_INT 1
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 2
85300: NEG
85301: PUSH
85302: LD_INT 1
85304: NEG
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 2
85312: NEG
85313: PUSH
85314: LD_INT 2
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: NEG
85325: PUSH
85326: LD_INT 3
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 1
85336: NEG
85337: PUSH
85338: LD_INT 3
85340: NEG
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: LD_INT 3
85351: NEG
85352: PUSH
85353: EMPTY
85354: LIST
85355: LIST
85356: PUSH
85357: LD_INT 1
85359: PUSH
85360: LD_INT 2
85362: NEG
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: PUSH
85368: LD_INT 3
85370: PUSH
85371: LD_INT 2
85373: PUSH
85374: EMPTY
85375: LIST
85376: LIST
85377: PUSH
85378: LD_INT 3
85380: PUSH
85381: LD_INT 3
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 2
85390: PUSH
85391: LD_INT 3
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 1
85400: PUSH
85401: LD_INT 3
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: LD_INT 3
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: NEG
85421: PUSH
85422: LD_INT 2
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: PUSH
85429: LD_INT 3
85431: NEG
85432: PUSH
85433: LD_INT 2
85435: NEG
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 3
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85484: LD_ADDR_VAR 0 43
85488: PUSH
85489: LD_INT 0
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: EMPTY
85496: LIST
85497: LIST
85498: PUSH
85499: LD_INT 0
85501: PUSH
85502: LD_INT 1
85504: NEG
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 1
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: PUSH
85520: LD_INT 1
85522: PUSH
85523: LD_INT 1
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: LD_INT 0
85532: PUSH
85533: LD_INT 1
85535: PUSH
85536: EMPTY
85537: LIST
85538: LIST
85539: PUSH
85540: LD_INT 1
85542: NEG
85543: PUSH
85544: LD_INT 0
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: NEG
85566: PUSH
85567: LD_INT 2
85569: NEG
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 0
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 2
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 0
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 1
85639: NEG
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: NEG
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 2
85661: NEG
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 1
85673: NEG
85674: PUSH
85675: LD_INT 3
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 0
85685: PUSH
85686: LD_INT 3
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 1
85696: PUSH
85697: LD_INT 2
85699: NEG
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 2
85707: PUSH
85708: LD_INT 1
85710: NEG
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 3
85718: PUSH
85719: LD_INT 0
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 3
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: LD_INT 3
85741: PUSH
85742: EMPTY
85743: LIST
85744: LIST
85745: PUSH
85746: LD_INT 0
85748: PUSH
85749: LD_INT 3
85751: PUSH
85752: EMPTY
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 1
85758: NEG
85759: PUSH
85760: LD_INT 2
85762: PUSH
85763: EMPTY
85764: LIST
85765: LIST
85766: PUSH
85767: LD_INT 2
85769: NEG
85770: PUSH
85771: LD_INT 1
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: PUSH
85778: LD_INT 3
85780: NEG
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 3
85791: NEG
85792: PUSH
85793: LD_INT 1
85795: NEG
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: EMPTY
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85832: LD_ADDR_VAR 0 44
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: LD_INT 0
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: PUSH
85847: LD_INT 0
85849: PUSH
85850: LD_INT 1
85852: NEG
85853: PUSH
85854: EMPTY
85855: LIST
85856: LIST
85857: PUSH
85858: LD_INT 1
85860: PUSH
85861: LD_INT 0
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: LD_INT 1
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 0
85880: PUSH
85881: LD_INT 1
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 1
85890: NEG
85891: PUSH
85892: LD_INT 0
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: NEG
85902: PUSH
85903: LD_INT 1
85905: NEG
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: NEG
85914: PUSH
85915: LD_INT 2
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 2
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 2
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 2
85956: PUSH
85957: LD_INT 2
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: PUSH
85967: LD_INT 2
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 1
85976: NEG
85977: PUSH
85978: LD_INT 1
85980: PUSH
85981: EMPTY
85982: LIST
85983: LIST
85984: PUSH
85985: LD_INT 2
85987: NEG
85988: PUSH
85989: LD_INT 0
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: NEG
85999: PUSH
86000: LD_INT 1
86002: NEG
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 2
86010: NEG
86011: PUSH
86012: LD_INT 2
86014: NEG
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 2
86022: NEG
86023: PUSH
86024: LD_INT 3
86026: NEG
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 2
86034: PUSH
86035: LD_INT 1
86037: NEG
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 3
86045: PUSH
86046: LD_INT 0
86048: PUSH
86049: EMPTY
86050: LIST
86051: LIST
86052: PUSH
86053: LD_INT 3
86055: PUSH
86056: LD_INT 1
86058: PUSH
86059: EMPTY
86060: LIST
86061: LIST
86062: PUSH
86063: LD_INT 3
86065: PUSH
86066: LD_INT 2
86068: PUSH
86069: EMPTY
86070: LIST
86071: LIST
86072: PUSH
86073: LD_INT 3
86075: PUSH
86076: LD_INT 3
86078: PUSH
86079: EMPTY
86080: LIST
86081: LIST
86082: PUSH
86083: LD_INT 2
86085: PUSH
86086: LD_INT 3
86088: PUSH
86089: EMPTY
86090: LIST
86091: LIST
86092: PUSH
86093: LD_INT 2
86095: NEG
86096: PUSH
86097: LD_INT 1
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: LD_INT 3
86106: NEG
86107: PUSH
86108: LD_INT 0
86110: PUSH
86111: EMPTY
86112: LIST
86113: LIST
86114: PUSH
86115: LD_INT 3
86117: NEG
86118: PUSH
86119: LD_INT 1
86121: NEG
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 3
86129: NEG
86130: PUSH
86131: LD_INT 2
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 3
86141: NEG
86142: PUSH
86143: LD_INT 3
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86182: LD_ADDR_VAR 0 45
86186: PUSH
86187: LD_INT 0
86189: PUSH
86190: LD_INT 0
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 0
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: PUSH
86211: LD_INT 0
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 1
86220: PUSH
86221: LD_INT 1
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 0
86230: PUSH
86231: LD_INT 1
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: PUSH
86238: LD_INT 1
86240: NEG
86241: PUSH
86242: LD_INT 0
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: LD_INT 1
86255: NEG
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: LD_INT 2
86267: NEG
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 0
86275: PUSH
86276: LD_INT 2
86278: NEG
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: PUSH
86284: LD_INT 1
86286: PUSH
86287: LD_INT 1
86289: NEG
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 2
86297: PUSH
86298: LD_INT 1
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 2
86307: PUSH
86308: LD_INT 2
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 1
86317: PUSH
86318: LD_INT 2
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: PUSH
86325: LD_INT 0
86327: PUSH
86328: LD_INT 2
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: LD_INT 1
86337: NEG
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 2
86348: NEG
86349: PUSH
86350: LD_INT 1
86352: NEG
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 2
86360: NEG
86361: PUSH
86362: LD_INT 2
86364: NEG
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 3
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 1
86384: NEG
86385: PUSH
86386: LD_INT 3
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 0
86396: PUSH
86397: LD_INT 3
86399: NEG
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: LD_INT 2
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 3
86418: PUSH
86419: LD_INT 2
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 3
86428: PUSH
86429: LD_INT 3
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 2
86438: PUSH
86439: LD_INT 3
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: PUSH
86449: LD_INT 3
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 0
86458: PUSH
86459: LD_INT 3
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 1
86468: NEG
86469: PUSH
86470: LD_INT 2
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 3
86479: NEG
86480: PUSH
86481: LD_INT 2
86483: NEG
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 3
86491: NEG
86492: PUSH
86493: LD_INT 3
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86532: LD_ADDR_VAR 0 46
86536: PUSH
86537: LD_INT 0
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: EMPTY
86544: LIST
86545: LIST
86546: PUSH
86547: LD_INT 0
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: PUSH
86561: LD_INT 0
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: PUSH
86568: LD_INT 1
86570: PUSH
86571: LD_INT 1
86573: PUSH
86574: EMPTY
86575: LIST
86576: LIST
86577: PUSH
86578: LD_INT 0
86580: PUSH
86581: LD_INT 1
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: NEG
86591: PUSH
86592: LD_INT 0
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PUSH
86599: LD_INT 1
86601: NEG
86602: PUSH
86603: LD_INT 1
86605: NEG
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 2
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 0
86625: PUSH
86626: LD_INT 2
86628: NEG
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: LD_INT 1
86639: NEG
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 2
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: LD_INT 2
86657: PUSH
86658: LD_INT 1
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: PUSH
86665: LD_INT 1
86667: PUSH
86668: LD_INT 2
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: LD_INT 0
86677: PUSH
86678: LD_INT 2
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: LD_INT 1
86691: PUSH
86692: EMPTY
86693: LIST
86694: LIST
86695: PUSH
86696: LD_INT 2
86698: NEG
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 2
86709: NEG
86710: PUSH
86711: LD_INT 1
86713: NEG
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 1
86721: NEG
86722: PUSH
86723: LD_INT 3
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 3
86736: NEG
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 1
86744: PUSH
86745: LD_INT 2
86747: NEG
86748: PUSH
86749: EMPTY
86750: LIST
86751: LIST
86752: PUSH
86753: LD_INT 2
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 3
86766: PUSH
86767: LD_INT 0
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 3
86776: PUSH
86777: LD_INT 1
86779: PUSH
86780: EMPTY
86781: LIST
86782: LIST
86783: PUSH
86784: LD_INT 1
86786: PUSH
86787: LD_INT 3
86789: PUSH
86790: EMPTY
86791: LIST
86792: LIST
86793: PUSH
86794: LD_INT 0
86796: PUSH
86797: LD_INT 3
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: NEG
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 2
86817: NEG
86818: PUSH
86819: LD_INT 1
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 3
86828: NEG
86829: PUSH
86830: LD_INT 0
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 3
86839: NEG
86840: PUSH
86841: LD_INT 1
86843: NEG
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: EMPTY
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86880: LD_ADDR_VAR 0 47
86884: PUSH
86885: LD_INT 0
86887: PUSH
86888: LD_INT 0
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: LD_INT 1
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 1
86908: PUSH
86909: LD_INT 0
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 1
86918: PUSH
86919: LD_INT 1
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 0
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 1
86938: NEG
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 1
86949: NEG
86950: PUSH
86951: LD_INT 1
86953: NEG
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: LD_INT 2
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 0
86973: PUSH
86974: LD_INT 2
86976: NEG
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: PUSH
86982: LD_INT 1
86984: PUSH
86985: LD_INT 1
86987: NEG
86988: PUSH
86989: EMPTY
86990: LIST
86991: LIST
86992: PUSH
86993: LD_INT 2
86995: NEG
86996: PUSH
86997: LD_INT 1
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 2
87007: NEG
87008: PUSH
87009: LD_INT 2
87011: NEG
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: LIST
87025: LIST
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87031: LD_ADDR_VAR 0 48
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 0
87048: PUSH
87049: LD_INT 1
87051: NEG
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: LD_INT 1
87059: PUSH
87060: LD_INT 0
87062: PUSH
87063: EMPTY
87064: LIST
87065: LIST
87066: PUSH
87067: LD_INT 1
87069: PUSH
87070: LD_INT 1
87072: PUSH
87073: EMPTY
87074: LIST
87075: LIST
87076: PUSH
87077: LD_INT 0
87079: PUSH
87080: LD_INT 1
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PUSH
87087: LD_INT 1
87089: NEG
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 1
87100: NEG
87101: PUSH
87102: LD_INT 1
87104: NEG
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: NEG
87113: PUSH
87114: LD_INT 2
87116: NEG
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 2
87127: NEG
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 2
87146: PUSH
87147: LD_INT 0
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 2
87156: PUSH
87157: LD_INT 1
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: EMPTY
87165: LIST
87166: LIST
87167: LIST
87168: LIST
87169: LIST
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87178: LD_ADDR_VAR 0 49
87182: PUSH
87183: LD_INT 0
87185: PUSH
87186: LD_INT 0
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 0
87195: PUSH
87196: LD_INT 1
87198: NEG
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: LD_INT 1
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: EMPTY
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 1
87216: PUSH
87217: LD_INT 1
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PUSH
87224: LD_INT 0
87226: PUSH
87227: LD_INT 1
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 1
87236: NEG
87237: PUSH
87238: LD_INT 0
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 1
87247: NEG
87248: PUSH
87249: LD_INT 1
87251: NEG
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: PUSH
87260: LD_INT 1
87262: NEG
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 2
87270: PUSH
87271: LD_INT 0
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: PUSH
87278: LD_INT 2
87280: PUSH
87281: LD_INT 1
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 2
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 1
87300: PUSH
87301: LD_INT 2
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87322: LD_ADDR_VAR 0 50
87326: PUSH
87327: LD_INT 0
87329: PUSH
87330: LD_INT 0
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 0
87339: PUSH
87340: LD_INT 1
87342: NEG
87343: PUSH
87344: EMPTY
87345: LIST
87346: LIST
87347: PUSH
87348: LD_INT 1
87350: PUSH
87351: LD_INT 0
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: PUSH
87358: LD_INT 1
87360: PUSH
87361: LD_INT 1
87363: PUSH
87364: EMPTY
87365: LIST
87366: LIST
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: LD_INT 1
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 1
87380: NEG
87381: PUSH
87382: LD_INT 0
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: NEG
87392: PUSH
87393: LD_INT 1
87395: NEG
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 2
87403: PUSH
87404: LD_INT 1
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 2
87413: PUSH
87414: LD_INT 2
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 1
87423: PUSH
87424: LD_INT 2
87426: PUSH
87427: EMPTY
87428: LIST
87429: LIST
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 2
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 1
87443: NEG
87444: PUSH
87445: LD_INT 1
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87466: LD_ADDR_VAR 0 51
87470: PUSH
87471: LD_INT 0
87473: PUSH
87474: LD_INT 0
87476: PUSH
87477: EMPTY
87478: LIST
87479: LIST
87480: PUSH
87481: LD_INT 0
87483: PUSH
87484: LD_INT 1
87486: NEG
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 0
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 1
87524: NEG
87525: PUSH
87526: LD_INT 0
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: LD_INT 1
87535: NEG
87536: PUSH
87537: LD_INT 1
87539: NEG
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: PUSH
87548: LD_INT 2
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 0
87557: PUSH
87558: LD_INT 2
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: LD_INT 1
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 2
87578: NEG
87579: PUSH
87580: LD_INT 0
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PUSH
87587: LD_INT 2
87589: NEG
87590: PUSH
87591: LD_INT 1
87593: NEG
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: EMPTY
87600: LIST
87601: LIST
87602: LIST
87603: LIST
87604: LIST
87605: LIST
87606: LIST
87607: LIST
87608: LIST
87609: LIST
87610: LIST
87611: LIST
87612: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87613: LD_ADDR_VAR 0 52
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: LD_INT 0
87623: PUSH
87624: EMPTY
87625: LIST
87626: LIST
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: LD_INT 1
87633: NEG
87634: PUSH
87635: EMPTY
87636: LIST
87637: LIST
87638: PUSH
87639: LD_INT 1
87641: PUSH
87642: LD_INT 0
87644: PUSH
87645: EMPTY
87646: LIST
87647: LIST
87648: PUSH
87649: LD_INT 1
87651: PUSH
87652: LD_INT 1
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: LD_INT 1
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: PUSH
87669: LD_INT 1
87671: NEG
87672: PUSH
87673: LD_INT 0
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: LD_INT 1
87686: NEG
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 1
87694: NEG
87695: PUSH
87696: LD_INT 2
87698: NEG
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 1
87706: NEG
87707: PUSH
87708: LD_INT 1
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 2
87717: NEG
87718: PUSH
87719: LD_INT 0
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: LD_INT 2
87728: NEG
87729: PUSH
87730: LD_INT 1
87732: NEG
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: LD_INT 2
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87764: LD_ADDR_VAR 0 53
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: LD_INT 0
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 1
87784: NEG
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: PUSH
87803: LD_INT 1
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 0
87812: PUSH
87813: LD_INT 1
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 1
87822: NEG
87823: PUSH
87824: LD_INT 0
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 1
87833: NEG
87834: PUSH
87835: LD_INT 1
87837: NEG
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: LD_INT 2
87849: NEG
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 2
87860: NEG
87861: PUSH
87862: EMPTY
87863: LIST
87864: LIST
87865: PUSH
87866: LD_INT 1
87868: PUSH
87869: LD_INT 1
87871: NEG
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 2
87879: PUSH
87880: LD_INT 0
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 2
87889: PUSH
87890: LD_INT 1
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 2
87899: PUSH
87900: LD_INT 2
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: PUSH
87910: LD_INT 2
87912: PUSH
87913: EMPTY
87914: LIST
87915: LIST
87916: PUSH
87917: LD_INT 0
87919: PUSH
87920: LD_INT 2
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 1
87929: NEG
87930: PUSH
87931: LD_INT 1
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: LD_INT 0
87944: PUSH
87945: EMPTY
87946: LIST
87947: LIST
87948: PUSH
87949: LD_INT 2
87951: NEG
87952: PUSH
87953: LD_INT 1
87955: NEG
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 2
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87994: LD_ADDR_VAR 0 54
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: PUSH
88009: LD_INT 0
88011: PUSH
88012: LD_INT 1
88014: NEG
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PUSH
88020: LD_INT 1
88022: PUSH
88023: LD_INT 0
88025: PUSH
88026: EMPTY
88027: LIST
88028: LIST
88029: PUSH
88030: LD_INT 1
88032: PUSH
88033: LD_INT 1
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PUSH
88040: LD_INT 0
88042: PUSH
88043: LD_INT 1
88045: PUSH
88046: EMPTY
88047: LIST
88048: LIST
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: LD_INT 0
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: LD_INT 1
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: LD_INT 2
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 0
88087: PUSH
88088: LD_INT 2
88090: NEG
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: LD_INT 1
88101: NEG
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: LD_INT 2
88109: PUSH
88110: LD_INT 0
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 2
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 2
88129: PUSH
88130: LD_INT 2
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 1
88139: PUSH
88140: LD_INT 2
88142: PUSH
88143: EMPTY
88144: LIST
88145: LIST
88146: PUSH
88147: LD_INT 0
88149: PUSH
88150: LD_INT 2
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 1
88159: NEG
88160: PUSH
88161: LD_INT 1
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: PUSH
88168: LD_INT 2
88170: NEG
88171: PUSH
88172: LD_INT 0
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: PUSH
88179: LD_INT 2
88181: NEG
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 2
88193: NEG
88194: PUSH
88195: LD_INT 2
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88224: LD_ADDR_VAR 0 55
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: LD_INT 0
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 0
88241: PUSH
88242: LD_INT 1
88244: NEG
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 1
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 0
88272: PUSH
88273: LD_INT 1
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 1
88282: NEG
88283: PUSH
88284: LD_INT 0
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: LD_INT 1
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: LD_INT 2
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 0
88317: PUSH
88318: LD_INT 2
88320: NEG
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 1
88328: PUSH
88329: LD_INT 1
88331: NEG
88332: PUSH
88333: EMPTY
88334: LIST
88335: LIST
88336: PUSH
88337: LD_INT 2
88339: PUSH
88340: LD_INT 0
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 2
88349: PUSH
88350: LD_INT 1
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: LD_INT 2
88359: PUSH
88360: LD_INT 2
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 1
88369: PUSH
88370: LD_INT 2
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 0
88379: PUSH
88380: LD_INT 2
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 1
88389: NEG
88390: PUSH
88391: LD_INT 1
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 2
88400: NEG
88401: PUSH
88402: LD_INT 0
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 2
88411: NEG
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: NEG
88424: PUSH
88425: LD_INT 2
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: EMPTY
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88454: LD_ADDR_VAR 0 56
88458: PUSH
88459: LD_INT 0
88461: PUSH
88462: LD_INT 0
88464: PUSH
88465: EMPTY
88466: LIST
88467: LIST
88468: PUSH
88469: LD_INT 0
88471: PUSH
88472: LD_INT 1
88474: NEG
88475: PUSH
88476: EMPTY
88477: LIST
88478: LIST
88479: PUSH
88480: LD_INT 1
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: EMPTY
88487: LIST
88488: LIST
88489: PUSH
88490: LD_INT 1
88492: PUSH
88493: LD_INT 1
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 0
88502: PUSH
88503: LD_INT 1
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 1
88512: NEG
88513: PUSH
88514: LD_INT 0
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PUSH
88521: LD_INT 1
88523: NEG
88524: PUSH
88525: LD_INT 1
88527: NEG
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: LD_INT 2
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 0
88547: PUSH
88548: LD_INT 2
88550: NEG
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: LD_INT 1
88561: NEG
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 2
88569: PUSH
88570: LD_INT 0
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 2
88589: PUSH
88590: LD_INT 2
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: LD_INT 2
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 0
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 1
88619: NEG
88620: PUSH
88621: LD_INT 1
88623: PUSH
88624: EMPTY
88625: LIST
88626: LIST
88627: PUSH
88628: LD_INT 2
88630: NEG
88631: PUSH
88632: LD_INT 0
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: NEG
88642: PUSH
88643: LD_INT 1
88645: NEG
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 2
88653: NEG
88654: PUSH
88655: LD_INT 2
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: EMPTY
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: LIST
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88684: LD_ADDR_VAR 0 57
88688: PUSH
88689: LD_INT 0
88691: PUSH
88692: LD_INT 0
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 0
88701: PUSH
88702: LD_INT 1
88704: NEG
88705: PUSH
88706: EMPTY
88707: LIST
88708: LIST
88709: PUSH
88710: LD_INT 1
88712: PUSH
88713: LD_INT 0
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 1
88722: PUSH
88723: LD_INT 1
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: PUSH
88730: LD_INT 0
88732: PUSH
88733: LD_INT 1
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: LD_INT 1
88742: NEG
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 1
88753: NEG
88754: PUSH
88755: LD_INT 1
88757: NEG
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: LD_INT 2
88769: NEG
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 0
88777: PUSH
88778: LD_INT 2
88780: NEG
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: LD_INT 1
88791: NEG
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: PUSH
88797: LD_INT 2
88799: PUSH
88800: LD_INT 0
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 2
88809: PUSH
88810: LD_INT 1
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 2
88819: PUSH
88820: LD_INT 2
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 1
88829: PUSH
88830: LD_INT 2
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: EMPTY
88844: LIST
88845: LIST
88846: PUSH
88847: LD_INT 1
88849: NEG
88850: PUSH
88851: LD_INT 1
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 2
88860: NEG
88861: PUSH
88862: LD_INT 0
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 2
88871: NEG
88872: PUSH
88873: LD_INT 1
88875: NEG
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 2
88883: NEG
88884: PUSH
88885: LD_INT 2
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: EMPTY
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88914: LD_ADDR_VAR 0 58
88918: PUSH
88919: LD_INT 0
88921: PUSH
88922: LD_INT 0
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: PUSH
88929: LD_INT 0
88931: PUSH
88932: LD_INT 1
88934: NEG
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 1
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 1
88952: PUSH
88953: LD_INT 1
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: LD_INT 1
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 1
88972: NEG
88973: PUSH
88974: LD_INT 0
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: NEG
88984: PUSH
88985: LD_INT 1
88987: NEG
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: NEG
88996: PUSH
88997: LD_INT 2
88999: NEG
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 0
89007: PUSH
89008: LD_INT 2
89010: NEG
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: LD_INT 1
89018: PUSH
89019: LD_INT 1
89021: NEG
89022: PUSH
89023: EMPTY
89024: LIST
89025: LIST
89026: PUSH
89027: LD_INT 2
89029: PUSH
89030: LD_INT 0
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 2
89039: PUSH
89040: LD_INT 1
89042: PUSH
89043: EMPTY
89044: LIST
89045: LIST
89046: PUSH
89047: LD_INT 2
89049: PUSH
89050: LD_INT 2
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: PUSH
89057: LD_INT 1
89059: PUSH
89060: LD_INT 2
89062: PUSH
89063: EMPTY
89064: LIST
89065: LIST
89066: PUSH
89067: LD_INT 0
89069: PUSH
89070: LD_INT 2
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: LD_INT 1
89079: NEG
89080: PUSH
89081: LD_INT 1
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 2
89090: NEG
89091: PUSH
89092: LD_INT 0
89094: PUSH
89095: EMPTY
89096: LIST
89097: LIST
89098: PUSH
89099: LD_INT 2
89101: NEG
89102: PUSH
89103: LD_INT 1
89105: NEG
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: NEG
89114: PUSH
89115: LD_INT 2
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89144: LD_ADDR_VAR 0 59
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: LD_INT 0
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 0
89161: PUSH
89162: LD_INT 1
89164: NEG
89165: PUSH
89166: EMPTY
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 1
89172: PUSH
89173: LD_INT 0
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: PUSH
89180: LD_INT 1
89182: PUSH
89183: LD_INT 1
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 1
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 1
89202: NEG
89203: PUSH
89204: LD_INT 0
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: NEG
89214: PUSH
89215: LD_INT 1
89217: NEG
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: EMPTY
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89232: LD_ADDR_VAR 0 60
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 0
89242: PUSH
89243: EMPTY
89244: LIST
89245: LIST
89246: PUSH
89247: LD_INT 0
89249: PUSH
89250: LD_INT 1
89252: NEG
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: LD_INT 0
89263: PUSH
89264: EMPTY
89265: LIST
89266: LIST
89267: PUSH
89268: LD_INT 1
89270: PUSH
89271: LD_INT 1
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: PUSH
89278: LD_INT 0
89280: PUSH
89281: LD_INT 1
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 1
89301: NEG
89302: PUSH
89303: LD_INT 1
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89320: LD_ADDR_VAR 0 61
89324: PUSH
89325: LD_INT 0
89327: PUSH
89328: LD_INT 0
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: LD_INT 0
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: PUSH
89356: LD_INT 1
89358: PUSH
89359: LD_INT 1
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 0
89368: PUSH
89369: LD_INT 1
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 1
89378: NEG
89379: PUSH
89380: LD_INT 0
89382: PUSH
89383: EMPTY
89384: LIST
89385: LIST
89386: PUSH
89387: LD_INT 1
89389: NEG
89390: PUSH
89391: LD_INT 1
89393: NEG
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89408: LD_ADDR_VAR 0 62
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89496: LD_ADDR_VAR 0 63
89500: PUSH
89501: LD_INT 0
89503: PUSH
89504: LD_INT 0
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 0
89513: PUSH
89514: LD_INT 1
89516: NEG
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: PUSH
89522: LD_INT 1
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: PUSH
89532: LD_INT 1
89534: PUSH
89535: LD_INT 1
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PUSH
89542: LD_INT 0
89544: PUSH
89545: LD_INT 1
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 0
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: PUSH
89563: LD_INT 1
89565: NEG
89566: PUSH
89567: LD_INT 1
89569: NEG
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89584: LD_ADDR_VAR 0 64
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: LD_INT 0
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: LD_INT 1
89604: NEG
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 1
89612: PUSH
89613: LD_INT 0
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: PUSH
89620: LD_INT 1
89622: PUSH
89623: LD_INT 1
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PUSH
89630: LD_INT 0
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: PUSH
89640: LD_INT 1
89642: NEG
89643: PUSH
89644: LD_INT 0
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 1
89653: NEG
89654: PUSH
89655: LD_INT 1
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: ST_TO_ADDR
// end ; 1 :
89672: GO 95569
89674: LD_INT 1
89676: DOUBLE
89677: EQUAL
89678: IFTRUE 89682
89680: GO 92305
89682: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89683: LD_ADDR_VAR 0 11
89687: PUSH
89688: LD_INT 1
89690: NEG
89691: PUSH
89692: LD_INT 3
89694: NEG
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PUSH
89700: LD_INT 0
89702: PUSH
89703: LD_INT 3
89705: NEG
89706: PUSH
89707: EMPTY
89708: LIST
89709: LIST
89710: PUSH
89711: LD_INT 1
89713: PUSH
89714: LD_INT 2
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89727: LD_ADDR_VAR 0 12
89731: PUSH
89732: LD_INT 2
89734: PUSH
89735: LD_INT 1
89737: NEG
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 3
89745: PUSH
89746: LD_INT 0
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: LD_INT 3
89755: PUSH
89756: LD_INT 1
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: LIST
89767: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89768: LD_ADDR_VAR 0 13
89772: PUSH
89773: LD_INT 3
89775: PUSH
89776: LD_INT 2
89778: PUSH
89779: EMPTY
89780: LIST
89781: LIST
89782: PUSH
89783: LD_INT 3
89785: PUSH
89786: LD_INT 3
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 2
89795: PUSH
89796: LD_INT 3
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: EMPTY
89804: LIST
89805: LIST
89806: LIST
89807: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89808: LD_ADDR_VAR 0 14
89812: PUSH
89813: LD_INT 1
89815: PUSH
89816: LD_INT 3
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 0
89825: PUSH
89826: LD_INT 3
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: NEG
89836: PUSH
89837: LD_INT 2
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: LIST
89848: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89849: LD_ADDR_VAR 0 15
89853: PUSH
89854: LD_INT 2
89856: NEG
89857: PUSH
89858: LD_INT 1
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: LD_INT 3
89867: NEG
89868: PUSH
89869: LD_INT 0
89871: PUSH
89872: EMPTY
89873: LIST
89874: LIST
89875: PUSH
89876: LD_INT 3
89878: NEG
89879: PUSH
89880: LD_INT 1
89882: NEG
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: LIST
89892: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89893: LD_ADDR_VAR 0 16
89897: PUSH
89898: LD_INT 2
89900: NEG
89901: PUSH
89902: LD_INT 3
89904: NEG
89905: PUSH
89906: EMPTY
89907: LIST
89908: LIST
89909: PUSH
89910: LD_INT 3
89912: NEG
89913: PUSH
89914: LD_INT 2
89916: NEG
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 3
89924: NEG
89925: PUSH
89926: LD_INT 3
89928: NEG
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: LIST
89938: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89939: LD_ADDR_VAR 0 17
89943: PUSH
89944: LD_INT 1
89946: NEG
89947: PUSH
89948: LD_INT 3
89950: NEG
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 0
89958: PUSH
89959: LD_INT 3
89961: NEG
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: PUSH
89967: LD_INT 1
89969: PUSH
89970: LD_INT 2
89972: NEG
89973: PUSH
89974: EMPTY
89975: LIST
89976: LIST
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: LIST
89982: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89983: LD_ADDR_VAR 0 18
89987: PUSH
89988: LD_INT 2
89990: PUSH
89991: LD_INT 1
89993: NEG
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 3
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 3
90011: PUSH
90012: LD_INT 1
90014: PUSH
90015: EMPTY
90016: LIST
90017: LIST
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: LIST
90023: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90024: LD_ADDR_VAR 0 19
90028: PUSH
90029: LD_INT 3
90031: PUSH
90032: LD_INT 2
90034: PUSH
90035: EMPTY
90036: LIST
90037: LIST
90038: PUSH
90039: LD_INT 3
90041: PUSH
90042: LD_INT 3
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 3
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: LIST
90063: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90064: LD_ADDR_VAR 0 20
90068: PUSH
90069: LD_INT 1
90071: PUSH
90072: LD_INT 3
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 0
90081: PUSH
90082: LD_INT 3
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 1
90091: NEG
90092: PUSH
90093: LD_INT 2
90095: PUSH
90096: EMPTY
90097: LIST
90098: LIST
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: LIST
90104: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90105: LD_ADDR_VAR 0 21
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: LD_INT 1
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 3
90123: NEG
90124: PUSH
90125: LD_INT 0
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 3
90134: NEG
90135: PUSH
90136: LD_INT 1
90138: NEG
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: EMPTY
90145: LIST
90146: LIST
90147: LIST
90148: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90149: LD_ADDR_VAR 0 22
90153: PUSH
90154: LD_INT 2
90156: NEG
90157: PUSH
90158: LD_INT 3
90160: NEG
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 3
90168: NEG
90169: PUSH
90170: LD_INT 2
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 3
90180: NEG
90181: PUSH
90182: LD_INT 3
90184: NEG
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: EMPTY
90191: LIST
90192: LIST
90193: LIST
90194: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90195: LD_ADDR_VAR 0 23
90199: PUSH
90200: LD_INT 0
90202: PUSH
90203: LD_INT 3
90205: NEG
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 1
90213: NEG
90214: PUSH
90215: LD_INT 4
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: PUSH
90226: LD_INT 3
90228: NEG
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: LIST
90238: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90239: LD_ADDR_VAR 0 24
90243: PUSH
90244: LD_INT 3
90246: PUSH
90247: LD_INT 0
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: PUSH
90254: LD_INT 3
90256: PUSH
90257: LD_INT 1
90259: NEG
90260: PUSH
90261: EMPTY
90262: LIST
90263: LIST
90264: PUSH
90265: LD_INT 4
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: LIST
90279: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90280: LD_ADDR_VAR 0 25
90284: PUSH
90285: LD_INT 3
90287: PUSH
90288: LD_INT 3
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PUSH
90295: LD_INT 4
90297: PUSH
90298: LD_INT 3
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 3
90307: PUSH
90308: LD_INT 4
90310: PUSH
90311: EMPTY
90312: LIST
90313: LIST
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: LIST
90319: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90320: LD_ADDR_VAR 0 26
90324: PUSH
90325: LD_INT 0
90327: PUSH
90328: LD_INT 3
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: PUSH
90338: LD_INT 4
90340: PUSH
90341: EMPTY
90342: LIST
90343: LIST
90344: PUSH
90345: LD_INT 1
90347: NEG
90348: PUSH
90349: LD_INT 3
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: PUSH
90356: EMPTY
90357: LIST
90358: LIST
90359: LIST
90360: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90361: LD_ADDR_VAR 0 27
90365: PUSH
90366: LD_INT 3
90368: NEG
90369: PUSH
90370: LD_INT 0
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 3
90379: NEG
90380: PUSH
90381: LD_INT 1
90383: PUSH
90384: EMPTY
90385: LIST
90386: LIST
90387: PUSH
90388: LD_INT 4
90390: NEG
90391: PUSH
90392: LD_INT 1
90394: NEG
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: LIST
90404: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90405: LD_ADDR_VAR 0 28
90409: PUSH
90410: LD_INT 3
90412: NEG
90413: PUSH
90414: LD_INT 3
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 3
90424: NEG
90425: PUSH
90426: LD_INT 4
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 4
90436: NEG
90437: PUSH
90438: LD_INT 3
90440: NEG
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: EMPTY
90447: LIST
90448: LIST
90449: LIST
90450: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90451: LD_ADDR_VAR 0 29
90455: PUSH
90456: LD_INT 1
90458: NEG
90459: PUSH
90460: LD_INT 3
90462: NEG
90463: PUSH
90464: EMPTY
90465: LIST
90466: LIST
90467: PUSH
90468: LD_INT 0
90470: PUSH
90471: LD_INT 3
90473: NEG
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 1
90481: PUSH
90482: LD_INT 2
90484: NEG
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: LD_INT 4
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 0
90504: PUSH
90505: LD_INT 4
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: PUSH
90516: LD_INT 3
90518: NEG
90519: PUSH
90520: EMPTY
90521: LIST
90522: LIST
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: LD_INT 5
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: LD_INT 5
90541: NEG
90542: PUSH
90543: EMPTY
90544: LIST
90545: LIST
90546: PUSH
90547: LD_INT 1
90549: PUSH
90550: LD_INT 4
90552: NEG
90553: PUSH
90554: EMPTY
90555: LIST
90556: LIST
90557: PUSH
90558: LD_INT 1
90560: NEG
90561: PUSH
90562: LD_INT 6
90564: NEG
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 0
90572: PUSH
90573: LD_INT 6
90575: NEG
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 1
90583: PUSH
90584: LD_INT 5
90586: NEG
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: LIST
90604: LIST
90605: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90606: LD_ADDR_VAR 0 30
90610: PUSH
90611: LD_INT 2
90613: PUSH
90614: LD_INT 1
90616: NEG
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: PUSH
90622: LD_INT 3
90624: PUSH
90625: LD_INT 0
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: PUSH
90632: LD_INT 3
90634: PUSH
90635: LD_INT 1
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 3
90644: PUSH
90645: LD_INT 1
90647: NEG
90648: PUSH
90649: EMPTY
90650: LIST
90651: LIST
90652: PUSH
90653: LD_INT 4
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 4
90665: PUSH
90666: LD_INT 1
90668: PUSH
90669: EMPTY
90670: LIST
90671: LIST
90672: PUSH
90673: LD_INT 4
90675: PUSH
90676: LD_INT 1
90678: NEG
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 5
90686: PUSH
90687: LD_INT 0
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 5
90696: PUSH
90697: LD_INT 1
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 5
90706: PUSH
90707: LD_INT 1
90709: NEG
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 6
90717: PUSH
90718: LD_INT 0
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PUSH
90725: LD_INT 6
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: EMPTY
90732: LIST
90733: LIST
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90749: LD_ADDR_VAR 0 31
90753: PUSH
90754: LD_INT 3
90756: PUSH
90757: LD_INT 2
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 3
90766: PUSH
90767: LD_INT 3
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: LD_INT 3
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 4
90786: PUSH
90787: LD_INT 3
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 4
90796: PUSH
90797: LD_INT 4
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 3
90806: PUSH
90807: LD_INT 4
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 5
90816: PUSH
90817: LD_INT 4
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 5
90826: PUSH
90827: LD_INT 5
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 4
90836: PUSH
90837: LD_INT 5
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: PUSH
90844: LD_INT 6
90846: PUSH
90847: LD_INT 5
90849: PUSH
90850: EMPTY
90851: LIST
90852: LIST
90853: PUSH
90854: LD_INT 6
90856: PUSH
90857: LD_INT 6
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: PUSH
90864: LD_INT 5
90866: PUSH
90867: LD_INT 6
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90888: LD_ADDR_VAR 0 32
90892: PUSH
90893: LD_INT 1
90895: PUSH
90896: LD_INT 3
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 0
90905: PUSH
90906: LD_INT 3
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 1
90915: NEG
90916: PUSH
90917: LD_INT 2
90919: PUSH
90920: EMPTY
90921: LIST
90922: LIST
90923: PUSH
90924: LD_INT 1
90926: PUSH
90927: LD_INT 4
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: PUSH
90934: LD_INT 0
90936: PUSH
90937: LD_INT 4
90939: PUSH
90940: EMPTY
90941: LIST
90942: LIST
90943: PUSH
90944: LD_INT 1
90946: NEG
90947: PUSH
90948: LD_INT 3
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 1
90957: PUSH
90958: LD_INT 5
90960: PUSH
90961: EMPTY
90962: LIST
90963: LIST
90964: PUSH
90965: LD_INT 0
90967: PUSH
90968: LD_INT 5
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 1
90977: NEG
90978: PUSH
90979: LD_INT 4
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 1
90988: PUSH
90989: LD_INT 6
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 0
90998: PUSH
90999: LD_INT 6
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 1
91008: NEG
91009: PUSH
91010: LD_INT 5
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: LIST
91030: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91031: LD_ADDR_VAR 0 33
91035: PUSH
91036: LD_INT 2
91038: NEG
91039: PUSH
91040: LD_INT 1
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 3
91049: NEG
91050: PUSH
91051: LD_INT 0
91053: PUSH
91054: EMPTY
91055: LIST
91056: LIST
91057: PUSH
91058: LD_INT 3
91060: NEG
91061: PUSH
91062: LD_INT 1
91064: NEG
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 3
91072: NEG
91073: PUSH
91074: LD_INT 1
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 4
91083: NEG
91084: PUSH
91085: LD_INT 0
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 4
91094: NEG
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 4
91106: NEG
91107: PUSH
91108: LD_INT 1
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 5
91117: NEG
91118: PUSH
91119: LD_INT 0
91121: PUSH
91122: EMPTY
91123: LIST
91124: LIST
91125: PUSH
91126: LD_INT 5
91128: NEG
91129: PUSH
91130: LD_INT 1
91132: NEG
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 5
91140: NEG
91141: PUSH
91142: LD_INT 1
91144: PUSH
91145: EMPTY
91146: LIST
91147: LIST
91148: PUSH
91149: LD_INT 6
91151: NEG
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: PUSH
91160: LD_INT 6
91162: NEG
91163: PUSH
91164: LD_INT 1
91166: NEG
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91186: LD_ADDR_VAR 0 34
91190: PUSH
91191: LD_INT 2
91193: NEG
91194: PUSH
91195: LD_INT 3
91197: NEG
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: PUSH
91203: LD_INT 3
91205: NEG
91206: PUSH
91207: LD_INT 2
91209: NEG
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: LD_INT 3
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 3
91229: NEG
91230: PUSH
91231: LD_INT 4
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 4
91241: NEG
91242: PUSH
91243: LD_INT 3
91245: NEG
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 4
91253: NEG
91254: PUSH
91255: LD_INT 4
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 4
91265: NEG
91266: PUSH
91267: LD_INT 5
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 5
91277: NEG
91278: PUSH
91279: LD_INT 4
91281: NEG
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 5
91289: NEG
91290: PUSH
91291: LD_INT 5
91293: NEG
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 5
91301: NEG
91302: PUSH
91303: LD_INT 6
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 6
91313: NEG
91314: PUSH
91315: LD_INT 5
91317: NEG
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 6
91325: NEG
91326: PUSH
91327: LD_INT 6
91329: NEG
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91349: LD_ADDR_VAR 0 41
91353: PUSH
91354: LD_INT 0
91356: PUSH
91357: LD_INT 2
91359: NEG
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: LD_INT 3
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 1
91379: PUSH
91380: LD_INT 2
91382: NEG
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: LIST
91392: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91393: LD_ADDR_VAR 0 42
91397: PUSH
91398: LD_INT 2
91400: PUSH
91401: LD_INT 0
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: PUSH
91408: LD_INT 2
91410: PUSH
91411: LD_INT 1
91413: NEG
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 3
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91434: LD_ADDR_VAR 0 43
91438: PUSH
91439: LD_INT 2
91441: PUSH
91442: LD_INT 2
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 3
91451: PUSH
91452: LD_INT 2
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: PUSH
91459: LD_INT 2
91461: PUSH
91462: LD_INT 3
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91474: LD_ADDR_VAR 0 44
91478: PUSH
91479: LD_INT 0
91481: PUSH
91482: LD_INT 2
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: PUSH
91489: LD_INT 1
91491: PUSH
91492: LD_INT 3
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 1
91501: NEG
91502: PUSH
91503: LD_INT 2
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: LIST
91514: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91515: LD_ADDR_VAR 0 45
91519: PUSH
91520: LD_INT 2
91522: NEG
91523: PUSH
91524: LD_INT 0
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PUSH
91531: LD_INT 2
91533: NEG
91534: PUSH
91535: LD_INT 1
91537: PUSH
91538: EMPTY
91539: LIST
91540: LIST
91541: PUSH
91542: LD_INT 3
91544: NEG
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: EMPTY
91555: LIST
91556: LIST
91557: LIST
91558: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91559: LD_ADDR_VAR 0 46
91563: PUSH
91564: LD_INT 2
91566: NEG
91567: PUSH
91568: LD_INT 2
91570: NEG
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: LD_INT 3
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 3
91590: NEG
91591: PUSH
91592: LD_INT 2
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: LIST
91604: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91605: LD_ADDR_VAR 0 47
91609: PUSH
91610: LD_INT 2
91612: NEG
91613: PUSH
91614: LD_INT 3
91616: NEG
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 1
91624: NEG
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91638: LD_ADDR_VAR 0 48
91642: PUSH
91643: LD_INT 1
91645: PUSH
91646: LD_INT 2
91648: NEG
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 2
91656: PUSH
91657: LD_INT 1
91659: NEG
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91669: LD_ADDR_VAR 0 49
91673: PUSH
91674: LD_INT 3
91676: PUSH
91677: LD_INT 1
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: LD_INT 3
91686: PUSH
91687: LD_INT 2
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91698: LD_ADDR_VAR 0 50
91702: PUSH
91703: LD_INT 2
91705: PUSH
91706: LD_INT 3
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 1
91715: PUSH
91716: LD_INT 3
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: EMPTY
91724: LIST
91725: LIST
91726: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91727: LD_ADDR_VAR 0 51
91731: PUSH
91732: LD_INT 1
91734: NEG
91735: PUSH
91736: LD_INT 2
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: PUSH
91743: LD_INT 2
91745: NEG
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91758: LD_ADDR_VAR 0 52
91762: PUSH
91763: LD_INT 3
91765: NEG
91766: PUSH
91767: LD_INT 1
91769: NEG
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: LD_INT 2
91781: NEG
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: EMPTY
91788: LIST
91789: LIST
91790: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91791: LD_ADDR_VAR 0 53
91795: PUSH
91796: LD_INT 1
91798: NEG
91799: PUSH
91800: LD_INT 3
91802: NEG
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 0
91810: PUSH
91811: LD_INT 3
91813: NEG
91814: PUSH
91815: EMPTY
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 1
91821: PUSH
91822: LD_INT 2
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91835: LD_ADDR_VAR 0 54
91839: PUSH
91840: LD_INT 2
91842: PUSH
91843: LD_INT 1
91845: NEG
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 3
91853: PUSH
91854: LD_INT 0
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 3
91863: PUSH
91864: LD_INT 1
91866: PUSH
91867: EMPTY
91868: LIST
91869: LIST
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: LIST
91875: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91876: LD_ADDR_VAR 0 55
91880: PUSH
91881: LD_INT 3
91883: PUSH
91884: LD_INT 2
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: PUSH
91891: LD_INT 3
91893: PUSH
91894: LD_INT 3
91896: PUSH
91897: EMPTY
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 2
91903: PUSH
91904: LD_INT 3
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: LIST
91915: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91916: LD_ADDR_VAR 0 56
91920: PUSH
91921: LD_INT 1
91923: PUSH
91924: LD_INT 3
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 0
91933: PUSH
91934: LD_INT 3
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: LD_INT 2
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: LIST
91956: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91957: LD_ADDR_VAR 0 57
91961: PUSH
91962: LD_INT 2
91964: NEG
91965: PUSH
91966: LD_INT 1
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: PUSH
91973: LD_INT 3
91975: NEG
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 3
91986: NEG
91987: PUSH
91988: LD_INT 1
91990: NEG
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: EMPTY
91997: LIST
91998: LIST
91999: LIST
92000: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92001: LD_ADDR_VAR 0 58
92005: PUSH
92006: LD_INT 2
92008: NEG
92009: PUSH
92010: LD_INT 3
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 3
92020: NEG
92021: PUSH
92022: LD_INT 2
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 3
92032: NEG
92033: PUSH
92034: LD_INT 3
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92047: LD_ADDR_VAR 0 59
92051: PUSH
92052: LD_INT 1
92054: NEG
92055: PUSH
92056: LD_INT 2
92058: NEG
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: PUSH
92064: LD_INT 0
92066: PUSH
92067: LD_INT 2
92069: NEG
92070: PUSH
92071: EMPTY
92072: LIST
92073: LIST
92074: PUSH
92075: LD_INT 1
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92091: LD_ADDR_VAR 0 60
92095: PUSH
92096: LD_INT 1
92098: PUSH
92099: LD_INT 1
92101: NEG
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 2
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 2
92119: PUSH
92120: LD_INT 1
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: LIST
92131: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92132: LD_ADDR_VAR 0 61
92136: PUSH
92137: LD_INT 2
92139: PUSH
92140: LD_INT 1
92142: PUSH
92143: EMPTY
92144: LIST
92145: LIST
92146: PUSH
92147: LD_INT 2
92149: PUSH
92150: LD_INT 2
92152: PUSH
92153: EMPTY
92154: LIST
92155: LIST
92156: PUSH
92157: LD_INT 1
92159: PUSH
92160: LD_INT 2
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: LIST
92171: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92172: LD_ADDR_VAR 0 62
92176: PUSH
92177: LD_INT 1
92179: PUSH
92180: LD_INT 2
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PUSH
92187: LD_INT 0
92189: PUSH
92190: LD_INT 2
92192: PUSH
92193: EMPTY
92194: LIST
92195: LIST
92196: PUSH
92197: LD_INT 1
92199: NEG
92200: PUSH
92201: LD_INT 1
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PUSH
92208: EMPTY
92209: LIST
92210: LIST
92211: LIST
92212: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92213: LD_ADDR_VAR 0 63
92217: PUSH
92218: LD_INT 1
92220: NEG
92221: PUSH
92222: LD_INT 1
92224: PUSH
92225: EMPTY
92226: LIST
92227: LIST
92228: PUSH
92229: LD_INT 2
92231: NEG
92232: PUSH
92233: LD_INT 0
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 2
92242: NEG
92243: PUSH
92244: LD_INT 1
92246: NEG
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: LIST
92256: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92257: LD_ADDR_VAR 0 64
92261: PUSH
92262: LD_INT 1
92264: NEG
92265: PUSH
92266: LD_INT 2
92268: NEG
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 2
92276: NEG
92277: PUSH
92278: LD_INT 1
92280: NEG
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 2
92288: NEG
92289: PUSH
92290: LD_INT 2
92292: NEG
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// end ; 2 :
92303: GO 95569
92305: LD_INT 2
92307: DOUBLE
92308: EQUAL
92309: IFTRUE 92313
92311: GO 95568
92313: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92314: LD_ADDR_VAR 0 29
92318: PUSH
92319: LD_INT 4
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 4
92331: PUSH
92332: LD_INT 1
92334: NEG
92335: PUSH
92336: EMPTY
92337: LIST
92338: LIST
92339: PUSH
92340: LD_INT 5
92342: PUSH
92343: LD_INT 0
92345: PUSH
92346: EMPTY
92347: LIST
92348: LIST
92349: PUSH
92350: LD_INT 5
92352: PUSH
92353: LD_INT 1
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PUSH
92360: LD_INT 4
92362: PUSH
92363: LD_INT 1
92365: PUSH
92366: EMPTY
92367: LIST
92368: LIST
92369: PUSH
92370: LD_INT 3
92372: PUSH
92373: LD_INT 0
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: LD_INT 3
92382: PUSH
92383: LD_INT 1
92385: NEG
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 3
92393: PUSH
92394: LD_INT 2
92396: NEG
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 5
92404: PUSH
92405: LD_INT 2
92407: PUSH
92408: EMPTY
92409: LIST
92410: LIST
92411: PUSH
92412: LD_INT 3
92414: PUSH
92415: LD_INT 3
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: PUSH
92422: LD_INT 3
92424: PUSH
92425: LD_INT 2
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 4
92434: PUSH
92435: LD_INT 3
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: LD_INT 4
92444: PUSH
92445: LD_INT 4
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 3
92454: PUSH
92455: LD_INT 4
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 2
92464: PUSH
92465: LD_INT 3
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: LD_INT 2
92474: PUSH
92475: LD_INT 2
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 4
92484: PUSH
92485: LD_INT 2
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: LD_INT 2
92494: PUSH
92495: LD_INT 4
92497: PUSH
92498: EMPTY
92499: LIST
92500: LIST
92501: PUSH
92502: LD_INT 0
92504: PUSH
92505: LD_INT 4
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 0
92514: PUSH
92515: LD_INT 3
92517: PUSH
92518: EMPTY
92519: LIST
92520: LIST
92521: PUSH
92522: LD_INT 1
92524: PUSH
92525: LD_INT 4
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 1
92534: PUSH
92535: LD_INT 5
92537: PUSH
92538: EMPTY
92539: LIST
92540: LIST
92541: PUSH
92542: LD_INT 0
92544: PUSH
92545: LD_INT 5
92547: PUSH
92548: EMPTY
92549: LIST
92550: LIST
92551: PUSH
92552: LD_INT 1
92554: NEG
92555: PUSH
92556: LD_INT 4
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 1
92565: NEG
92566: PUSH
92567: LD_INT 3
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 2
92576: PUSH
92577: LD_INT 5
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 2
92586: NEG
92587: PUSH
92588: LD_INT 3
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 3
92597: NEG
92598: PUSH
92599: LD_INT 0
92601: PUSH
92602: EMPTY
92603: LIST
92604: LIST
92605: PUSH
92606: LD_INT 3
92608: NEG
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 2
92620: NEG
92621: PUSH
92622: LD_INT 0
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 2
92631: NEG
92632: PUSH
92633: LD_INT 1
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 3
92642: NEG
92643: PUSH
92644: LD_INT 1
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 4
92653: NEG
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: LD_INT 4
92664: NEG
92665: PUSH
92666: LD_INT 1
92668: NEG
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 4
92676: NEG
92677: PUSH
92678: LD_INT 2
92680: NEG
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 2
92688: NEG
92689: PUSH
92690: LD_INT 2
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 4
92699: NEG
92700: PUSH
92701: LD_INT 4
92703: NEG
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 4
92711: NEG
92712: PUSH
92713: LD_INT 5
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 3
92723: NEG
92724: PUSH
92725: LD_INT 4
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: NEG
92736: PUSH
92737: LD_INT 3
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 4
92747: NEG
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 5
92759: NEG
92760: PUSH
92761: LD_INT 4
92763: NEG
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 5
92771: NEG
92772: PUSH
92773: LD_INT 5
92775: NEG
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 3
92783: NEG
92784: PUSH
92785: LD_INT 5
92787: NEG
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 5
92795: NEG
92796: PUSH
92797: LD_INT 3
92799: NEG
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: LIST
92809: LIST
92810: LIST
92811: LIST
92812: LIST
92813: LIST
92814: LIST
92815: LIST
92816: LIST
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92852: LD_ADDR_VAR 0 30
92856: PUSH
92857: LD_INT 4
92859: PUSH
92860: LD_INT 4
92862: PUSH
92863: EMPTY
92864: LIST
92865: LIST
92866: PUSH
92867: LD_INT 4
92869: PUSH
92870: LD_INT 3
92872: PUSH
92873: EMPTY
92874: LIST
92875: LIST
92876: PUSH
92877: LD_INT 5
92879: PUSH
92880: LD_INT 4
92882: PUSH
92883: EMPTY
92884: LIST
92885: LIST
92886: PUSH
92887: LD_INT 5
92889: PUSH
92890: LD_INT 5
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 4
92899: PUSH
92900: LD_INT 5
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 3
92909: PUSH
92910: LD_INT 4
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 3
92919: PUSH
92920: LD_INT 3
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 5
92929: PUSH
92930: LD_INT 3
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 3
92939: PUSH
92940: LD_INT 5
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: LD_INT 3
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PUSH
92957: LD_INT 0
92959: PUSH
92960: LD_INT 2
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PUSH
92967: LD_INT 1
92969: PUSH
92970: LD_INT 3
92972: PUSH
92973: EMPTY
92974: LIST
92975: LIST
92976: PUSH
92977: LD_INT 1
92979: PUSH
92980: LD_INT 4
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 0
92989: PUSH
92990: LD_INT 4
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: LD_INT 1
92999: NEG
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 1
93010: NEG
93011: PUSH
93012: LD_INT 2
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 2
93021: PUSH
93022: LD_INT 4
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 2
93031: NEG
93032: PUSH
93033: LD_INT 2
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 4
93042: NEG
93043: PUSH
93044: LD_INT 0
93046: PUSH
93047: EMPTY
93048: LIST
93049: LIST
93050: PUSH
93051: LD_INT 4
93053: NEG
93054: PUSH
93055: LD_INT 1
93057: NEG
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 3
93065: NEG
93066: PUSH
93067: LD_INT 0
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 3
93076: NEG
93077: PUSH
93078: LD_INT 1
93080: PUSH
93081: EMPTY
93082: LIST
93083: LIST
93084: PUSH
93085: LD_INT 4
93087: NEG
93088: PUSH
93089: LD_INT 1
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 5
93098: NEG
93099: PUSH
93100: LD_INT 0
93102: PUSH
93103: EMPTY
93104: LIST
93105: LIST
93106: PUSH
93107: LD_INT 5
93109: NEG
93110: PUSH
93111: LD_INT 1
93113: NEG
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 5
93121: NEG
93122: PUSH
93123: LD_INT 2
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 3
93133: NEG
93134: PUSH
93135: LD_INT 2
93137: PUSH
93138: EMPTY
93139: LIST
93140: LIST
93141: PUSH
93142: LD_INT 3
93144: NEG
93145: PUSH
93146: LD_INT 3
93148: NEG
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 3
93156: NEG
93157: PUSH
93158: LD_INT 4
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 2
93168: NEG
93169: PUSH
93170: LD_INT 3
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 2
93180: NEG
93181: PUSH
93182: LD_INT 2
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 3
93192: NEG
93193: PUSH
93194: LD_INT 2
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 4
93204: NEG
93205: PUSH
93206: LD_INT 3
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 4
93216: NEG
93217: PUSH
93218: LD_INT 4
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 2
93228: NEG
93229: PUSH
93230: LD_INT 4
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 4
93240: NEG
93241: PUSH
93242: LD_INT 2
93244: NEG
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 0
93252: PUSH
93253: LD_INT 4
93255: NEG
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PUSH
93261: LD_INT 0
93263: PUSH
93264: LD_INT 5
93266: NEG
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: LD_INT 4
93277: NEG
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PUSH
93283: LD_INT 1
93285: PUSH
93286: LD_INT 3
93288: NEG
93289: PUSH
93290: EMPTY
93291: LIST
93292: LIST
93293: PUSH
93294: LD_INT 0
93296: PUSH
93297: LD_INT 3
93299: NEG
93300: PUSH
93301: EMPTY
93302: LIST
93303: LIST
93304: PUSH
93305: LD_INT 1
93307: NEG
93308: PUSH
93309: LD_INT 4
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: LD_INT 5
93323: NEG
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 2
93331: PUSH
93332: LD_INT 3
93334: NEG
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 2
93342: NEG
93343: PUSH
93344: LD_INT 5
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: EMPTY
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93399: LD_ADDR_VAR 0 31
93403: PUSH
93404: LD_INT 0
93406: PUSH
93407: LD_INT 4
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 0
93416: PUSH
93417: LD_INT 3
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 1
93426: PUSH
93427: LD_INT 4
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: LD_INT 1
93436: PUSH
93437: LD_INT 5
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 0
93446: PUSH
93447: LD_INT 5
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 1
93456: NEG
93457: PUSH
93458: LD_INT 4
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 1
93467: NEG
93468: PUSH
93469: LD_INT 3
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 2
93478: PUSH
93479: LD_INT 5
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 2
93488: NEG
93489: PUSH
93490: LD_INT 3
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: LD_INT 3
93499: NEG
93500: PUSH
93501: LD_INT 0
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: PUSH
93508: LD_INT 3
93510: NEG
93511: PUSH
93512: LD_INT 1
93514: NEG
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 2
93522: NEG
93523: PUSH
93524: LD_INT 0
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 2
93533: NEG
93534: PUSH
93535: LD_INT 1
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 3
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 4
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 4
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 4
93578: NEG
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 2
93590: NEG
93591: PUSH
93592: LD_INT 2
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 4
93601: NEG
93602: PUSH
93603: LD_INT 4
93605: NEG
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 4
93613: NEG
93614: PUSH
93615: LD_INT 5
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 3
93625: NEG
93626: PUSH
93627: LD_INT 4
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 3
93637: NEG
93638: PUSH
93639: LD_INT 3
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 4
93649: NEG
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 5
93661: NEG
93662: PUSH
93663: LD_INT 4
93665: NEG
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 5
93673: NEG
93674: PUSH
93675: LD_INT 5
93677: NEG
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: LD_INT 3
93685: NEG
93686: PUSH
93687: LD_INT 5
93689: NEG
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 5
93697: NEG
93698: PUSH
93699: LD_INT 3
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 0
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 0
93720: PUSH
93721: LD_INT 4
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 1
93731: PUSH
93732: LD_INT 3
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 1
93742: PUSH
93743: LD_INT 2
93745: NEG
93746: PUSH
93747: EMPTY
93748: LIST
93749: LIST
93750: PUSH
93751: LD_INT 0
93753: PUSH
93754: LD_INT 2
93756: NEG
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 1
93764: NEG
93765: PUSH
93766: LD_INT 3
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: NEG
93777: PUSH
93778: LD_INT 4
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 2
93788: PUSH
93789: LD_INT 2
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: LD_INT 2
93799: NEG
93800: PUSH
93801: LD_INT 4
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 4
93811: PUSH
93812: LD_INT 0
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 4
93821: PUSH
93822: LD_INT 1
93824: NEG
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: PUSH
93830: LD_INT 5
93832: PUSH
93833: LD_INT 0
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: PUSH
93840: LD_INT 5
93842: PUSH
93843: LD_INT 1
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: PUSH
93850: LD_INT 4
93852: PUSH
93853: LD_INT 1
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 3
93862: PUSH
93863: LD_INT 0
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 3
93872: PUSH
93873: LD_INT 1
93875: NEG
93876: PUSH
93877: EMPTY
93878: LIST
93879: LIST
93880: PUSH
93881: LD_INT 3
93883: PUSH
93884: LD_INT 2
93886: NEG
93887: PUSH
93888: EMPTY
93889: LIST
93890: LIST
93891: PUSH
93892: LD_INT 5
93894: PUSH
93895: LD_INT 2
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93949: LD_ADDR_VAR 0 32
93953: PUSH
93954: LD_INT 4
93956: NEG
93957: PUSH
93958: LD_INT 0
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 4
93967: NEG
93968: PUSH
93969: LD_INT 1
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 3
93979: NEG
93980: PUSH
93981: LD_INT 0
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: PUSH
93988: LD_INT 3
93990: NEG
93991: PUSH
93992: LD_INT 1
93994: PUSH
93995: EMPTY
93996: LIST
93997: LIST
93998: PUSH
93999: LD_INT 4
94001: NEG
94002: PUSH
94003: LD_INT 1
94005: PUSH
94006: EMPTY
94007: LIST
94008: LIST
94009: PUSH
94010: LD_INT 5
94012: NEG
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 5
94023: NEG
94024: PUSH
94025: LD_INT 1
94027: NEG
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 5
94035: NEG
94036: PUSH
94037: LD_INT 2
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 3
94047: NEG
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: EMPTY
94053: LIST
94054: LIST
94055: PUSH
94056: LD_INT 3
94058: NEG
94059: PUSH
94060: LD_INT 3
94062: NEG
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 3
94070: NEG
94071: PUSH
94072: LD_INT 4
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 2
94082: NEG
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 2
94094: NEG
94095: PUSH
94096: LD_INT 2
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 3
94106: NEG
94107: PUSH
94108: LD_INT 2
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 4
94118: NEG
94119: PUSH
94120: LD_INT 3
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 4
94130: NEG
94131: PUSH
94132: LD_INT 4
94134: NEG
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: LD_INT 2
94142: NEG
94143: PUSH
94144: LD_INT 4
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 4
94154: NEG
94155: PUSH
94156: LD_INT 2
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 0
94166: PUSH
94167: LD_INT 4
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 0
94177: PUSH
94178: LD_INT 5
94180: NEG
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 1
94188: PUSH
94189: LD_INT 4
94191: NEG
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 1
94199: PUSH
94200: LD_INT 3
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 0
94210: PUSH
94211: LD_INT 3
94213: NEG
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 1
94221: NEG
94222: PUSH
94223: LD_INT 4
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: NEG
94234: PUSH
94235: LD_INT 5
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 2
94245: PUSH
94246: LD_INT 3
94248: NEG
94249: PUSH
94250: EMPTY
94251: LIST
94252: LIST
94253: PUSH
94254: LD_INT 2
94256: NEG
94257: PUSH
94258: LD_INT 5
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 3
94268: PUSH
94269: LD_INT 0
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 3
94278: PUSH
94279: LD_INT 1
94281: NEG
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 4
94289: PUSH
94290: LD_INT 0
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 4
94299: PUSH
94300: LD_INT 1
94302: PUSH
94303: EMPTY
94304: LIST
94305: LIST
94306: PUSH
94307: LD_INT 3
94309: PUSH
94310: LD_INT 1
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 2
94319: PUSH
94320: LD_INT 0
94322: PUSH
94323: EMPTY
94324: LIST
94325: LIST
94326: PUSH
94327: LD_INT 2
94329: PUSH
94330: LD_INT 1
94332: NEG
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 2
94340: PUSH
94341: LD_INT 2
94343: NEG
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 4
94351: PUSH
94352: LD_INT 2
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 4
94361: PUSH
94362: LD_INT 4
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: PUSH
94369: LD_INT 4
94371: PUSH
94372: LD_INT 3
94374: PUSH
94375: EMPTY
94376: LIST
94377: LIST
94378: PUSH
94379: LD_INT 5
94381: PUSH
94382: LD_INT 4
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 5
94391: PUSH
94392: LD_INT 5
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: PUSH
94399: LD_INT 4
94401: PUSH
94402: LD_INT 5
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: LD_INT 3
94411: PUSH
94412: LD_INT 4
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: PUSH
94419: LD_INT 3
94421: PUSH
94422: LD_INT 3
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 5
94431: PUSH
94432: LD_INT 3
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 3
94441: PUSH
94442: LD_INT 5
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94496: LD_ADDR_VAR 0 33
94500: PUSH
94501: LD_INT 4
94503: NEG
94504: PUSH
94505: LD_INT 4
94507: NEG
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 4
94515: NEG
94516: PUSH
94517: LD_INT 5
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 3
94527: NEG
94528: PUSH
94529: LD_INT 4
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 3
94539: NEG
94540: PUSH
94541: LD_INT 3
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 4
94551: NEG
94552: PUSH
94553: LD_INT 3
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 5
94563: NEG
94564: PUSH
94565: LD_INT 4
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 5
94575: NEG
94576: PUSH
94577: LD_INT 5
94579: NEG
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 3
94587: NEG
94588: PUSH
94589: LD_INT 5
94591: NEG
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PUSH
94597: LD_INT 5
94599: NEG
94600: PUSH
94601: LD_INT 3
94603: NEG
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: PUSH
94609: LD_INT 0
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: EMPTY
94617: LIST
94618: LIST
94619: PUSH
94620: LD_INT 0
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: PUSH
94631: LD_INT 1
94633: PUSH
94634: LD_INT 3
94636: NEG
94637: PUSH
94638: EMPTY
94639: LIST
94640: LIST
94641: PUSH
94642: LD_INT 1
94644: PUSH
94645: LD_INT 2
94647: NEG
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: PUSH
94653: LD_INT 0
94655: PUSH
94656: LD_INT 2
94658: NEG
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 1
94666: NEG
94667: PUSH
94668: LD_INT 3
94670: NEG
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: PUSH
94676: LD_INT 1
94678: NEG
94679: PUSH
94680: LD_INT 4
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 2
94690: PUSH
94691: LD_INT 2
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 2
94701: NEG
94702: PUSH
94703: LD_INT 4
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 4
94713: PUSH
94714: LD_INT 0
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 4
94723: PUSH
94724: LD_INT 1
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 5
94734: PUSH
94735: LD_INT 0
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 5
94744: PUSH
94745: LD_INT 1
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 4
94754: PUSH
94755: LD_INT 1
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 3
94764: PUSH
94765: LD_INT 0
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 3
94774: PUSH
94775: LD_INT 1
94777: NEG
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 3
94785: PUSH
94786: LD_INT 2
94788: NEG
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 5
94796: PUSH
94797: LD_INT 2
94799: PUSH
94800: EMPTY
94801: LIST
94802: LIST
94803: PUSH
94804: LD_INT 3
94806: PUSH
94807: LD_INT 3
94809: PUSH
94810: EMPTY
94811: LIST
94812: LIST
94813: PUSH
94814: LD_INT 3
94816: PUSH
94817: LD_INT 2
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 4
94826: PUSH
94827: LD_INT 3
94829: PUSH
94830: EMPTY
94831: LIST
94832: LIST
94833: PUSH
94834: LD_INT 4
94836: PUSH
94837: LD_INT 4
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 3
94846: PUSH
94847: LD_INT 4
94849: PUSH
94850: EMPTY
94851: LIST
94852: LIST
94853: PUSH
94854: LD_INT 2
94856: PUSH
94857: LD_INT 3
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 2
94866: PUSH
94867: LD_INT 2
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: LD_INT 4
94876: PUSH
94877: LD_INT 2
94879: PUSH
94880: EMPTY
94881: LIST
94882: LIST
94883: PUSH
94884: LD_INT 2
94886: PUSH
94887: LD_INT 4
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 0
94896: PUSH
94897: LD_INT 4
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 0
94906: PUSH
94907: LD_INT 3
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: PUSH
94917: LD_INT 4
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 1
94926: PUSH
94927: LD_INT 5
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 0
94936: PUSH
94937: LD_INT 5
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 1
94946: NEG
94947: PUSH
94948: LD_INT 4
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 1
94957: NEG
94958: PUSH
94959: LD_INT 3
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: LD_INT 5
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 2
94978: NEG
94979: PUSH
94980: LD_INT 3
94982: PUSH
94983: EMPTY
94984: LIST
94985: LIST
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95034: LD_ADDR_VAR 0 34
95038: PUSH
95039: LD_INT 0
95041: PUSH
95042: LD_INT 4
95044: NEG
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 0
95052: PUSH
95053: LD_INT 5
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 1
95063: PUSH
95064: LD_INT 4
95066: NEG
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: LD_INT 3
95077: NEG
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 0
95085: PUSH
95086: LD_INT 3
95088: NEG
95089: PUSH
95090: EMPTY
95091: LIST
95092: LIST
95093: PUSH
95094: LD_INT 1
95096: NEG
95097: PUSH
95098: LD_INT 4
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 1
95108: NEG
95109: PUSH
95110: LD_INT 5
95112: NEG
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: PUSH
95118: LD_INT 2
95120: PUSH
95121: LD_INT 3
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 2
95131: NEG
95132: PUSH
95133: LD_INT 5
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 3
95143: PUSH
95144: LD_INT 0
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 3
95153: PUSH
95154: LD_INT 1
95156: NEG
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 4
95164: PUSH
95165: LD_INT 0
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 4
95174: PUSH
95175: LD_INT 1
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 3
95184: PUSH
95185: LD_INT 1
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 2
95194: PUSH
95195: LD_INT 0
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 2
95204: PUSH
95205: LD_INT 1
95207: NEG
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: PUSH
95213: LD_INT 2
95215: PUSH
95216: LD_INT 2
95218: NEG
95219: PUSH
95220: EMPTY
95221: LIST
95222: LIST
95223: PUSH
95224: LD_INT 4
95226: PUSH
95227: LD_INT 2
95229: PUSH
95230: EMPTY
95231: LIST
95232: LIST
95233: PUSH
95234: LD_INT 4
95236: PUSH
95237: LD_INT 4
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 4
95246: PUSH
95247: LD_INT 3
95249: PUSH
95250: EMPTY
95251: LIST
95252: LIST
95253: PUSH
95254: LD_INT 5
95256: PUSH
95257: LD_INT 4
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: LD_INT 5
95266: PUSH
95267: LD_INT 5
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 4
95276: PUSH
95277: LD_INT 5
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: LD_INT 3
95286: PUSH
95287: LD_INT 4
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 3
95296: PUSH
95297: LD_INT 3
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 5
95306: PUSH
95307: LD_INT 3
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 3
95316: PUSH
95317: LD_INT 5
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 0
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 0
95336: PUSH
95337: LD_INT 2
95339: PUSH
95340: EMPTY
95341: LIST
95342: LIST
95343: PUSH
95344: LD_INT 1
95346: PUSH
95347: LD_INT 3
95349: PUSH
95350: EMPTY
95351: LIST
95352: LIST
95353: PUSH
95354: LD_INT 1
95356: PUSH
95357: LD_INT 4
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: PUSH
95364: LD_INT 0
95366: PUSH
95367: LD_INT 4
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: PUSH
95374: LD_INT 1
95376: NEG
95377: PUSH
95378: LD_INT 3
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: LD_INT 1
95387: NEG
95388: PUSH
95389: LD_INT 2
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 2
95398: PUSH
95399: LD_INT 4
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 2
95408: NEG
95409: PUSH
95410: LD_INT 2
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 4
95419: NEG
95420: PUSH
95421: LD_INT 0
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 4
95430: NEG
95431: PUSH
95432: LD_INT 1
95434: NEG
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 3
95442: NEG
95443: PUSH
95444: LD_INT 0
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 3
95453: NEG
95454: PUSH
95455: LD_INT 1
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 4
95464: NEG
95465: PUSH
95466: LD_INT 1
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 5
95475: NEG
95476: PUSH
95477: LD_INT 0
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 5
95486: NEG
95487: PUSH
95488: LD_INT 1
95490: NEG
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 5
95498: NEG
95499: PUSH
95500: LD_INT 2
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 3
95510: NEG
95511: PUSH
95512: LD_INT 2
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: ST_TO_ADDR
// end ; end ;
95566: GO 95569
95568: POP
// case btype of b_depot , b_warehouse :
95569: LD_VAR 0 1
95573: PUSH
95574: LD_INT 0
95576: DOUBLE
95577: EQUAL
95578: IFTRUE 95588
95580: LD_INT 1
95582: DOUBLE
95583: EQUAL
95584: IFTRUE 95588
95586: GO 95789
95588: POP
// case nation of nation_american :
95589: LD_VAR 0 5
95593: PUSH
95594: LD_INT 1
95596: DOUBLE
95597: EQUAL
95598: IFTRUE 95602
95600: GO 95658
95602: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95603: LD_ADDR_VAR 0 9
95607: PUSH
95608: LD_VAR 0 11
95612: PUSH
95613: LD_VAR 0 12
95617: PUSH
95618: LD_VAR 0 13
95622: PUSH
95623: LD_VAR 0 14
95627: PUSH
95628: LD_VAR 0 15
95632: PUSH
95633: LD_VAR 0 16
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: PUSH
95646: LD_VAR 0 4
95650: PUSH
95651: LD_INT 1
95653: PLUS
95654: ARRAY
95655: ST_TO_ADDR
95656: GO 95787
95658: LD_INT 2
95660: DOUBLE
95661: EQUAL
95662: IFTRUE 95666
95664: GO 95722
95666: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95667: LD_ADDR_VAR 0 9
95671: PUSH
95672: LD_VAR 0 17
95676: PUSH
95677: LD_VAR 0 18
95681: PUSH
95682: LD_VAR 0 19
95686: PUSH
95687: LD_VAR 0 20
95691: PUSH
95692: LD_VAR 0 21
95696: PUSH
95697: LD_VAR 0 22
95701: PUSH
95702: EMPTY
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: PUSH
95710: LD_VAR 0 4
95714: PUSH
95715: LD_INT 1
95717: PLUS
95718: ARRAY
95719: ST_TO_ADDR
95720: GO 95787
95722: LD_INT 3
95724: DOUBLE
95725: EQUAL
95726: IFTRUE 95730
95728: GO 95786
95730: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95731: LD_ADDR_VAR 0 9
95735: PUSH
95736: LD_VAR 0 23
95740: PUSH
95741: LD_VAR 0 24
95745: PUSH
95746: LD_VAR 0 25
95750: PUSH
95751: LD_VAR 0 26
95755: PUSH
95756: LD_VAR 0 27
95760: PUSH
95761: LD_VAR 0 28
95765: PUSH
95766: EMPTY
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: LIST
95773: PUSH
95774: LD_VAR 0 4
95778: PUSH
95779: LD_INT 1
95781: PLUS
95782: ARRAY
95783: ST_TO_ADDR
95784: GO 95787
95786: POP
95787: GO 96342
95789: LD_INT 2
95791: DOUBLE
95792: EQUAL
95793: IFTRUE 95803
95795: LD_INT 3
95797: DOUBLE
95798: EQUAL
95799: IFTRUE 95803
95801: GO 95859
95803: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95804: LD_ADDR_VAR 0 9
95808: PUSH
95809: LD_VAR 0 29
95813: PUSH
95814: LD_VAR 0 30
95818: PUSH
95819: LD_VAR 0 31
95823: PUSH
95824: LD_VAR 0 32
95828: PUSH
95829: LD_VAR 0 33
95833: PUSH
95834: LD_VAR 0 34
95838: PUSH
95839: EMPTY
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: PUSH
95847: LD_VAR 0 4
95851: PUSH
95852: LD_INT 1
95854: PLUS
95855: ARRAY
95856: ST_TO_ADDR
95857: GO 96342
95859: LD_INT 16
95861: DOUBLE
95862: EQUAL
95863: IFTRUE 95921
95865: LD_INT 17
95867: DOUBLE
95868: EQUAL
95869: IFTRUE 95921
95871: LD_INT 18
95873: DOUBLE
95874: EQUAL
95875: IFTRUE 95921
95877: LD_INT 19
95879: DOUBLE
95880: EQUAL
95881: IFTRUE 95921
95883: LD_INT 22
95885: DOUBLE
95886: EQUAL
95887: IFTRUE 95921
95889: LD_INT 20
95891: DOUBLE
95892: EQUAL
95893: IFTRUE 95921
95895: LD_INT 21
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95921
95901: LD_INT 23
95903: DOUBLE
95904: EQUAL
95905: IFTRUE 95921
95907: LD_INT 24
95909: DOUBLE
95910: EQUAL
95911: IFTRUE 95921
95913: LD_INT 25
95915: DOUBLE
95916: EQUAL
95917: IFTRUE 95921
95919: GO 95977
95921: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95922: LD_ADDR_VAR 0 9
95926: PUSH
95927: LD_VAR 0 35
95931: PUSH
95932: LD_VAR 0 36
95936: PUSH
95937: LD_VAR 0 37
95941: PUSH
95942: LD_VAR 0 38
95946: PUSH
95947: LD_VAR 0 39
95951: PUSH
95952: LD_VAR 0 40
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: PUSH
95965: LD_VAR 0 4
95969: PUSH
95970: LD_INT 1
95972: PLUS
95973: ARRAY
95974: ST_TO_ADDR
95975: GO 96342
95977: LD_INT 6
95979: DOUBLE
95980: EQUAL
95981: IFTRUE 96033
95983: LD_INT 7
95985: DOUBLE
95986: EQUAL
95987: IFTRUE 96033
95989: LD_INT 8
95991: DOUBLE
95992: EQUAL
95993: IFTRUE 96033
95995: LD_INT 13
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96033
96001: LD_INT 12
96003: DOUBLE
96004: EQUAL
96005: IFTRUE 96033
96007: LD_INT 15
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96033
96013: LD_INT 11
96015: DOUBLE
96016: EQUAL
96017: IFTRUE 96033
96019: LD_INT 14
96021: DOUBLE
96022: EQUAL
96023: IFTRUE 96033
96025: LD_INT 10
96027: DOUBLE
96028: EQUAL
96029: IFTRUE 96033
96031: GO 96089
96033: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96034: LD_ADDR_VAR 0 9
96038: PUSH
96039: LD_VAR 0 41
96043: PUSH
96044: LD_VAR 0 42
96048: PUSH
96049: LD_VAR 0 43
96053: PUSH
96054: LD_VAR 0 44
96058: PUSH
96059: LD_VAR 0 45
96063: PUSH
96064: LD_VAR 0 46
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: PUSH
96077: LD_VAR 0 4
96081: PUSH
96082: LD_INT 1
96084: PLUS
96085: ARRAY
96086: ST_TO_ADDR
96087: GO 96342
96089: LD_INT 36
96091: DOUBLE
96092: EQUAL
96093: IFTRUE 96097
96095: GO 96153
96097: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96098: LD_ADDR_VAR 0 9
96102: PUSH
96103: LD_VAR 0 47
96107: PUSH
96108: LD_VAR 0 48
96112: PUSH
96113: LD_VAR 0 49
96117: PUSH
96118: LD_VAR 0 50
96122: PUSH
96123: LD_VAR 0 51
96127: PUSH
96128: LD_VAR 0 52
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: PUSH
96141: LD_VAR 0 4
96145: PUSH
96146: LD_INT 1
96148: PLUS
96149: ARRAY
96150: ST_TO_ADDR
96151: GO 96342
96153: LD_INT 4
96155: DOUBLE
96156: EQUAL
96157: IFTRUE 96179
96159: LD_INT 5
96161: DOUBLE
96162: EQUAL
96163: IFTRUE 96179
96165: LD_INT 34
96167: DOUBLE
96168: EQUAL
96169: IFTRUE 96179
96171: LD_INT 37
96173: DOUBLE
96174: EQUAL
96175: IFTRUE 96179
96177: GO 96235
96179: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96180: LD_ADDR_VAR 0 9
96184: PUSH
96185: LD_VAR 0 53
96189: PUSH
96190: LD_VAR 0 54
96194: PUSH
96195: LD_VAR 0 55
96199: PUSH
96200: LD_VAR 0 56
96204: PUSH
96205: LD_VAR 0 57
96209: PUSH
96210: LD_VAR 0 58
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: PUSH
96223: LD_VAR 0 4
96227: PUSH
96228: LD_INT 1
96230: PLUS
96231: ARRAY
96232: ST_TO_ADDR
96233: GO 96342
96235: LD_INT 31
96237: DOUBLE
96238: EQUAL
96239: IFTRUE 96285
96241: LD_INT 32
96243: DOUBLE
96244: EQUAL
96245: IFTRUE 96285
96247: LD_INT 33
96249: DOUBLE
96250: EQUAL
96251: IFTRUE 96285
96253: LD_INT 27
96255: DOUBLE
96256: EQUAL
96257: IFTRUE 96285
96259: LD_INT 26
96261: DOUBLE
96262: EQUAL
96263: IFTRUE 96285
96265: LD_INT 28
96267: DOUBLE
96268: EQUAL
96269: IFTRUE 96285
96271: LD_INT 29
96273: DOUBLE
96274: EQUAL
96275: IFTRUE 96285
96277: LD_INT 30
96279: DOUBLE
96280: EQUAL
96281: IFTRUE 96285
96283: GO 96341
96285: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96286: LD_ADDR_VAR 0 9
96290: PUSH
96291: LD_VAR 0 59
96295: PUSH
96296: LD_VAR 0 60
96300: PUSH
96301: LD_VAR 0 61
96305: PUSH
96306: LD_VAR 0 62
96310: PUSH
96311: LD_VAR 0 63
96315: PUSH
96316: LD_VAR 0 64
96320: PUSH
96321: EMPTY
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: PUSH
96329: LD_VAR 0 4
96333: PUSH
96334: LD_INT 1
96336: PLUS
96337: ARRAY
96338: ST_TO_ADDR
96339: GO 96342
96341: POP
// temp_list2 = [ ] ;
96342: LD_ADDR_VAR 0 10
96346: PUSH
96347: EMPTY
96348: ST_TO_ADDR
// for i in temp_list do
96349: LD_ADDR_VAR 0 8
96353: PUSH
96354: LD_VAR 0 9
96358: PUSH
96359: FOR_IN
96360: IFFALSE 96412
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96362: LD_ADDR_VAR 0 10
96366: PUSH
96367: LD_VAR 0 10
96371: PUSH
96372: LD_VAR 0 8
96376: PUSH
96377: LD_INT 1
96379: ARRAY
96380: PUSH
96381: LD_VAR 0 2
96385: PLUS
96386: PUSH
96387: LD_VAR 0 8
96391: PUSH
96392: LD_INT 2
96394: ARRAY
96395: PUSH
96396: LD_VAR 0 3
96400: PLUS
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: EMPTY
96407: LIST
96408: ADD
96409: ST_TO_ADDR
96410: GO 96359
96412: POP
96413: POP
// result = temp_list2 ;
96414: LD_ADDR_VAR 0 7
96418: PUSH
96419: LD_VAR 0 10
96423: ST_TO_ADDR
// end ;
96424: LD_VAR 0 7
96428: RET
// export function EnemyInRange ( unit , dist ) ; begin
96429: LD_INT 0
96431: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96432: LD_ADDR_VAR 0 3
96436: PUSH
96437: LD_VAR 0 1
96441: PPUSH
96442: CALL_OW 255
96446: PPUSH
96447: LD_VAR 0 1
96451: PPUSH
96452: CALL_OW 250
96456: PPUSH
96457: LD_VAR 0 1
96461: PPUSH
96462: CALL_OW 251
96466: PPUSH
96467: LD_VAR 0 2
96471: PPUSH
96472: CALL 70533 0 4
96476: PUSH
96477: LD_INT 4
96479: ARRAY
96480: ST_TO_ADDR
// end ;
96481: LD_VAR 0 3
96485: RET
// export function PlayerSeeMe ( unit ) ; begin
96486: LD_INT 0
96488: PPUSH
// result := See ( your_side , unit ) ;
96489: LD_ADDR_VAR 0 2
96493: PUSH
96494: LD_OWVAR 2
96498: PPUSH
96499: LD_VAR 0 1
96503: PPUSH
96504: CALL_OW 292
96508: ST_TO_ADDR
// end ;
96509: LD_VAR 0 2
96513: RET
// export function ReverseDir ( unit ) ; begin
96514: LD_INT 0
96516: PPUSH
// if not unit then
96517: LD_VAR 0 1
96521: NOT
96522: IFFALSE 96526
// exit ;
96524: GO 96572
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
96526: LD_ADDR_VAR 0 2
96530: PUSH
96531: LD_INT 3
96533: PUSH
96534: LD_INT 4
96536: PUSH
96537: LD_INT 5
96539: PUSH
96540: LD_INT 0
96542: PUSH
96543: LD_INT 1
96545: PUSH
96546: LD_INT 2
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: PUSH
96557: LD_VAR 0 1
96561: PPUSH
96562: CALL_OW 254
96566: PUSH
96567: LD_INT 1
96569: PLUS
96570: ARRAY
96571: ST_TO_ADDR
// end ;
96572: LD_VAR 0 2
96576: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96577: LD_INT 0
96579: PPUSH
96580: PPUSH
96581: PPUSH
96582: PPUSH
96583: PPUSH
// if not hexes then
96584: LD_VAR 0 2
96588: NOT
96589: IFFALSE 96593
// exit ;
96591: GO 96741
// dist := 9999 ;
96593: LD_ADDR_VAR 0 5
96597: PUSH
96598: LD_INT 9999
96600: ST_TO_ADDR
// for i = 1 to hexes do
96601: LD_ADDR_VAR 0 4
96605: PUSH
96606: DOUBLE
96607: LD_INT 1
96609: DEC
96610: ST_TO_ADDR
96611: LD_VAR 0 2
96615: PUSH
96616: FOR_TO
96617: IFFALSE 96729
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96619: LD_VAR 0 1
96623: PPUSH
96624: LD_VAR 0 2
96628: PUSH
96629: LD_VAR 0 4
96633: ARRAY
96634: PUSH
96635: LD_INT 1
96637: ARRAY
96638: PPUSH
96639: LD_VAR 0 2
96643: PUSH
96644: LD_VAR 0 4
96648: ARRAY
96649: PUSH
96650: LD_INT 2
96652: ARRAY
96653: PPUSH
96654: CALL_OW 297
96658: PUSH
96659: LD_VAR 0 5
96663: LESS
96664: IFFALSE 96727
// begin hex := hexes [ i ] ;
96666: LD_ADDR_VAR 0 7
96670: PUSH
96671: LD_VAR 0 2
96675: PUSH
96676: LD_VAR 0 4
96680: ARRAY
96681: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96682: LD_ADDR_VAR 0 5
96686: PUSH
96687: LD_VAR 0 1
96691: PPUSH
96692: LD_VAR 0 2
96696: PUSH
96697: LD_VAR 0 4
96701: ARRAY
96702: PUSH
96703: LD_INT 1
96705: ARRAY
96706: PPUSH
96707: LD_VAR 0 2
96711: PUSH
96712: LD_VAR 0 4
96716: ARRAY
96717: PUSH
96718: LD_INT 2
96720: ARRAY
96721: PPUSH
96722: CALL_OW 297
96726: ST_TO_ADDR
// end ; end ;
96727: GO 96616
96729: POP
96730: POP
// result := hex ;
96731: LD_ADDR_VAR 0 3
96735: PUSH
96736: LD_VAR 0 7
96740: ST_TO_ADDR
// end ;
96741: LD_VAR 0 3
96745: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96746: LD_INT 0
96748: PPUSH
96749: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96750: LD_VAR 0 1
96754: NOT
96755: PUSH
96756: LD_VAR 0 1
96760: PUSH
96761: LD_INT 21
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 23
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: EMPTY
96778: LIST
96779: LIST
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PPUSH
96785: CALL_OW 69
96789: IN
96790: NOT
96791: OR
96792: IFFALSE 96796
// exit ;
96794: GO 96843
// for i = 1 to 3 do
96796: LD_ADDR_VAR 0 3
96800: PUSH
96801: DOUBLE
96802: LD_INT 1
96804: DEC
96805: ST_TO_ADDR
96806: LD_INT 3
96808: PUSH
96809: FOR_TO
96810: IFFALSE 96841
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96812: LD_VAR 0 1
96816: PPUSH
96817: CALL_OW 250
96821: PPUSH
96822: LD_VAR 0 1
96826: PPUSH
96827: CALL_OW 251
96831: PPUSH
96832: LD_INT 1
96834: PPUSH
96835: CALL_OW 453
96839: GO 96809
96841: POP
96842: POP
// end ;
96843: LD_VAR 0 2
96847: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96848: LD_INT 0
96850: PPUSH
96851: PPUSH
96852: PPUSH
96853: PPUSH
96854: PPUSH
96855: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96856: LD_VAR 0 1
96860: NOT
96861: PUSH
96862: LD_VAR 0 2
96866: NOT
96867: OR
96868: PUSH
96869: LD_VAR 0 1
96873: PPUSH
96874: CALL_OW 314
96878: OR
96879: IFFALSE 96883
// exit ;
96881: GO 97324
// x := GetX ( enemy_unit ) ;
96883: LD_ADDR_VAR 0 7
96887: PUSH
96888: LD_VAR 0 2
96892: PPUSH
96893: CALL_OW 250
96897: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96898: LD_ADDR_VAR 0 8
96902: PUSH
96903: LD_VAR 0 2
96907: PPUSH
96908: CALL_OW 251
96912: ST_TO_ADDR
// if not x or not y then
96913: LD_VAR 0 7
96917: NOT
96918: PUSH
96919: LD_VAR 0 8
96923: NOT
96924: OR
96925: IFFALSE 96929
// exit ;
96927: GO 97324
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96929: LD_ADDR_VAR 0 6
96933: PUSH
96934: LD_VAR 0 7
96938: PPUSH
96939: LD_INT 0
96941: PPUSH
96942: LD_INT 4
96944: PPUSH
96945: CALL_OW 272
96949: PUSH
96950: LD_VAR 0 8
96954: PPUSH
96955: LD_INT 0
96957: PPUSH
96958: LD_INT 4
96960: PPUSH
96961: CALL_OW 273
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_VAR 0 7
96974: PPUSH
96975: LD_INT 1
96977: PPUSH
96978: LD_INT 4
96980: PPUSH
96981: CALL_OW 272
96985: PUSH
96986: LD_VAR 0 8
96990: PPUSH
96991: LD_INT 1
96993: PPUSH
96994: LD_INT 4
96996: PPUSH
96997: CALL_OW 273
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: LD_VAR 0 7
97010: PPUSH
97011: LD_INT 2
97013: PPUSH
97014: LD_INT 4
97016: PPUSH
97017: CALL_OW 272
97021: PUSH
97022: LD_VAR 0 8
97026: PPUSH
97027: LD_INT 2
97029: PPUSH
97030: LD_INT 4
97032: PPUSH
97033: CALL_OW 273
97037: PUSH
97038: EMPTY
97039: LIST
97040: LIST
97041: PUSH
97042: LD_VAR 0 7
97046: PPUSH
97047: LD_INT 3
97049: PPUSH
97050: LD_INT 4
97052: PPUSH
97053: CALL_OW 272
97057: PUSH
97058: LD_VAR 0 8
97062: PPUSH
97063: LD_INT 3
97065: PPUSH
97066: LD_INT 4
97068: PPUSH
97069: CALL_OW 273
97073: PUSH
97074: EMPTY
97075: LIST
97076: LIST
97077: PUSH
97078: LD_VAR 0 7
97082: PPUSH
97083: LD_INT 4
97085: PPUSH
97086: LD_INT 4
97088: PPUSH
97089: CALL_OW 272
97093: PUSH
97094: LD_VAR 0 8
97098: PPUSH
97099: LD_INT 4
97101: PPUSH
97102: LD_INT 4
97104: PPUSH
97105: CALL_OW 273
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_VAR 0 7
97118: PPUSH
97119: LD_INT 5
97121: PPUSH
97122: LD_INT 4
97124: PPUSH
97125: CALL_OW 272
97129: PUSH
97130: LD_VAR 0 8
97134: PPUSH
97135: LD_INT 5
97137: PPUSH
97138: LD_INT 4
97140: PPUSH
97141: CALL_OW 273
97145: PUSH
97146: EMPTY
97147: LIST
97148: LIST
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: ST_TO_ADDR
// for i = tmp downto 1 do
97158: LD_ADDR_VAR 0 4
97162: PUSH
97163: DOUBLE
97164: LD_VAR 0 6
97168: INC
97169: ST_TO_ADDR
97170: LD_INT 1
97172: PUSH
97173: FOR_DOWNTO
97174: IFFALSE 97275
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97176: LD_VAR 0 6
97180: PUSH
97181: LD_VAR 0 4
97185: ARRAY
97186: PUSH
97187: LD_INT 1
97189: ARRAY
97190: PPUSH
97191: LD_VAR 0 6
97195: PUSH
97196: LD_VAR 0 4
97200: ARRAY
97201: PUSH
97202: LD_INT 2
97204: ARRAY
97205: PPUSH
97206: CALL_OW 488
97210: NOT
97211: PUSH
97212: LD_VAR 0 6
97216: PUSH
97217: LD_VAR 0 4
97221: ARRAY
97222: PUSH
97223: LD_INT 1
97225: ARRAY
97226: PPUSH
97227: LD_VAR 0 6
97231: PUSH
97232: LD_VAR 0 4
97236: ARRAY
97237: PUSH
97238: LD_INT 2
97240: ARRAY
97241: PPUSH
97242: CALL_OW 428
97246: PUSH
97247: LD_INT 0
97249: NONEQUAL
97250: OR
97251: IFFALSE 97273
// tmp := Delete ( tmp , i ) ;
97253: LD_ADDR_VAR 0 6
97257: PUSH
97258: LD_VAR 0 6
97262: PPUSH
97263: LD_VAR 0 4
97267: PPUSH
97268: CALL_OW 3
97272: ST_TO_ADDR
97273: GO 97173
97275: POP
97276: POP
// j := GetClosestHex ( unit , tmp ) ;
97277: LD_ADDR_VAR 0 5
97281: PUSH
97282: LD_VAR 0 1
97286: PPUSH
97287: LD_VAR 0 6
97291: PPUSH
97292: CALL 96577 0 2
97296: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97297: LD_VAR 0 1
97301: PPUSH
97302: LD_VAR 0 5
97306: PUSH
97307: LD_INT 1
97309: ARRAY
97310: PPUSH
97311: LD_VAR 0 5
97315: PUSH
97316: LD_INT 2
97318: ARRAY
97319: PPUSH
97320: CALL_OW 111
// end ;
97324: LD_VAR 0 3
97328: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97329: LD_INT 0
97331: PPUSH
97332: PPUSH
97333: PPUSH
// uc_side = 0 ;
97334: LD_ADDR_OWVAR 20
97338: PUSH
97339: LD_INT 0
97341: ST_TO_ADDR
// uc_nation = 0 ;
97342: LD_ADDR_OWVAR 21
97346: PUSH
97347: LD_INT 0
97349: ST_TO_ADDR
// InitHc ;
97350: CALL_OW 19
// InitVc ;
97354: CALL_OW 20
// if mastodonts then
97358: LD_VAR 0 6
97362: IFFALSE 97429
// for i = 1 to mastodonts do
97364: LD_ADDR_VAR 0 11
97368: PUSH
97369: DOUBLE
97370: LD_INT 1
97372: DEC
97373: ST_TO_ADDR
97374: LD_VAR 0 6
97378: PUSH
97379: FOR_TO
97380: IFFALSE 97427
// begin vc_chassis := 31 ;
97382: LD_ADDR_OWVAR 37
97386: PUSH
97387: LD_INT 31
97389: ST_TO_ADDR
// vc_control := control_rider ;
97390: LD_ADDR_OWVAR 38
97394: PUSH
97395: LD_INT 4
97397: ST_TO_ADDR
// animal := CreateVehicle ;
97398: LD_ADDR_VAR 0 12
97402: PUSH
97403: CALL_OW 45
97407: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97408: LD_VAR 0 12
97412: PPUSH
97413: LD_VAR 0 8
97417: PPUSH
97418: LD_INT 0
97420: PPUSH
97421: CALL 104174 0 3
// end ;
97425: GO 97379
97427: POP
97428: POP
// if horses then
97429: LD_VAR 0 5
97433: IFFALSE 97500
// for i = 1 to horses do
97435: LD_ADDR_VAR 0 11
97439: PUSH
97440: DOUBLE
97441: LD_INT 1
97443: DEC
97444: ST_TO_ADDR
97445: LD_VAR 0 5
97449: PUSH
97450: FOR_TO
97451: IFFALSE 97498
// begin hc_class := 21 ;
97453: LD_ADDR_OWVAR 28
97457: PUSH
97458: LD_INT 21
97460: ST_TO_ADDR
// hc_gallery :=  ;
97461: LD_ADDR_OWVAR 33
97465: PUSH
97466: LD_STRING 
97468: ST_TO_ADDR
// animal := CreateHuman ;
97469: LD_ADDR_VAR 0 12
97473: PUSH
97474: CALL_OW 44
97478: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97479: LD_VAR 0 12
97483: PPUSH
97484: LD_VAR 0 8
97488: PPUSH
97489: LD_INT 0
97491: PPUSH
97492: CALL 104174 0 3
// end ;
97496: GO 97450
97498: POP
97499: POP
// if birds then
97500: LD_VAR 0 1
97504: IFFALSE 97571
// for i = 1 to birds do
97506: LD_ADDR_VAR 0 11
97510: PUSH
97511: DOUBLE
97512: LD_INT 1
97514: DEC
97515: ST_TO_ADDR
97516: LD_VAR 0 1
97520: PUSH
97521: FOR_TO
97522: IFFALSE 97569
// begin hc_class = 18 ;
97524: LD_ADDR_OWVAR 28
97528: PUSH
97529: LD_INT 18
97531: ST_TO_ADDR
// hc_gallery =  ;
97532: LD_ADDR_OWVAR 33
97536: PUSH
97537: LD_STRING 
97539: ST_TO_ADDR
// animal := CreateHuman ;
97540: LD_ADDR_VAR 0 12
97544: PUSH
97545: CALL_OW 44
97549: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97550: LD_VAR 0 12
97554: PPUSH
97555: LD_VAR 0 8
97559: PPUSH
97560: LD_INT 0
97562: PPUSH
97563: CALL 104174 0 3
// end ;
97567: GO 97521
97569: POP
97570: POP
// if tigers then
97571: LD_VAR 0 2
97575: IFFALSE 97659
// for i = 1 to tigers do
97577: LD_ADDR_VAR 0 11
97581: PUSH
97582: DOUBLE
97583: LD_INT 1
97585: DEC
97586: ST_TO_ADDR
97587: LD_VAR 0 2
97591: PUSH
97592: FOR_TO
97593: IFFALSE 97657
// begin hc_class = class_tiger ;
97595: LD_ADDR_OWVAR 28
97599: PUSH
97600: LD_INT 14
97602: ST_TO_ADDR
// hc_gallery =  ;
97603: LD_ADDR_OWVAR 33
97607: PUSH
97608: LD_STRING 
97610: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97611: LD_ADDR_OWVAR 35
97615: PUSH
97616: LD_INT 7
97618: NEG
97619: PPUSH
97620: LD_INT 7
97622: PPUSH
97623: CALL_OW 12
97627: ST_TO_ADDR
// animal := CreateHuman ;
97628: LD_ADDR_VAR 0 12
97632: PUSH
97633: CALL_OW 44
97637: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97638: LD_VAR 0 12
97642: PPUSH
97643: LD_VAR 0 8
97647: PPUSH
97648: LD_INT 0
97650: PPUSH
97651: CALL 104174 0 3
// end ;
97655: GO 97592
97657: POP
97658: POP
// if apemans then
97659: LD_VAR 0 3
97663: IFFALSE 97786
// for i = 1 to apemans do
97665: LD_ADDR_VAR 0 11
97669: PUSH
97670: DOUBLE
97671: LD_INT 1
97673: DEC
97674: ST_TO_ADDR
97675: LD_VAR 0 3
97679: PUSH
97680: FOR_TO
97681: IFFALSE 97784
// begin hc_class = class_apeman ;
97683: LD_ADDR_OWVAR 28
97687: PUSH
97688: LD_INT 12
97690: ST_TO_ADDR
// hc_gallery =  ;
97691: LD_ADDR_OWVAR 33
97695: PUSH
97696: LD_STRING 
97698: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97699: LD_ADDR_OWVAR 35
97703: PUSH
97704: LD_INT 5
97706: NEG
97707: PPUSH
97708: LD_INT 5
97710: PPUSH
97711: CALL_OW 12
97715: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97716: LD_ADDR_OWVAR 31
97720: PUSH
97721: LD_INT 1
97723: PPUSH
97724: LD_INT 3
97726: PPUSH
97727: CALL_OW 12
97731: PUSH
97732: LD_INT 1
97734: PPUSH
97735: LD_INT 3
97737: PPUSH
97738: CALL_OW 12
97742: PUSH
97743: LD_INT 0
97745: PUSH
97746: LD_INT 0
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: ST_TO_ADDR
// animal := CreateHuman ;
97755: LD_ADDR_VAR 0 12
97759: PUSH
97760: CALL_OW 44
97764: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97765: LD_VAR 0 12
97769: PPUSH
97770: LD_VAR 0 8
97774: PPUSH
97775: LD_INT 0
97777: PPUSH
97778: CALL 104174 0 3
// end ;
97782: GO 97680
97784: POP
97785: POP
// if enchidnas then
97786: LD_VAR 0 4
97790: IFFALSE 97857
// for i = 1 to enchidnas do
97792: LD_ADDR_VAR 0 11
97796: PUSH
97797: DOUBLE
97798: LD_INT 1
97800: DEC
97801: ST_TO_ADDR
97802: LD_VAR 0 4
97806: PUSH
97807: FOR_TO
97808: IFFALSE 97855
// begin hc_class = 13 ;
97810: LD_ADDR_OWVAR 28
97814: PUSH
97815: LD_INT 13
97817: ST_TO_ADDR
// hc_gallery =  ;
97818: LD_ADDR_OWVAR 33
97822: PUSH
97823: LD_STRING 
97825: ST_TO_ADDR
// animal := CreateHuman ;
97826: LD_ADDR_VAR 0 12
97830: PUSH
97831: CALL_OW 44
97835: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97836: LD_VAR 0 12
97840: PPUSH
97841: LD_VAR 0 8
97845: PPUSH
97846: LD_INT 0
97848: PPUSH
97849: CALL 104174 0 3
// end ;
97853: GO 97807
97855: POP
97856: POP
// if fishes then
97857: LD_VAR 0 7
97861: IFFALSE 97928
// for i = 1 to fishes do
97863: LD_ADDR_VAR 0 11
97867: PUSH
97868: DOUBLE
97869: LD_INT 1
97871: DEC
97872: ST_TO_ADDR
97873: LD_VAR 0 7
97877: PUSH
97878: FOR_TO
97879: IFFALSE 97926
// begin hc_class = 20 ;
97881: LD_ADDR_OWVAR 28
97885: PUSH
97886: LD_INT 20
97888: ST_TO_ADDR
// hc_gallery =  ;
97889: LD_ADDR_OWVAR 33
97893: PUSH
97894: LD_STRING 
97896: ST_TO_ADDR
// animal := CreateHuman ;
97897: LD_ADDR_VAR 0 12
97901: PUSH
97902: CALL_OW 44
97906: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97907: LD_VAR 0 12
97911: PPUSH
97912: LD_VAR 0 9
97916: PPUSH
97917: LD_INT 0
97919: PPUSH
97920: CALL 104174 0 3
// end ;
97924: GO 97878
97926: POP
97927: POP
// end ;
97928: LD_VAR 0 10
97932: RET
// export function WantHeal ( sci , unit ) ; begin
97933: LD_INT 0
97935: PPUSH
// if GetTaskList ( sci ) > 0 then
97936: LD_VAR 0 1
97940: PPUSH
97941: CALL_OW 437
97945: PUSH
97946: LD_INT 0
97948: GREATER
97949: IFFALSE 98019
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97951: LD_VAR 0 1
97955: PPUSH
97956: CALL_OW 437
97960: PUSH
97961: LD_INT 1
97963: ARRAY
97964: PUSH
97965: LD_INT 1
97967: ARRAY
97968: PUSH
97969: LD_STRING l
97971: EQUAL
97972: PUSH
97973: LD_VAR 0 1
97977: PPUSH
97978: CALL_OW 437
97982: PUSH
97983: LD_INT 1
97985: ARRAY
97986: PUSH
97987: LD_INT 4
97989: ARRAY
97990: PUSH
97991: LD_VAR 0 2
97995: EQUAL
97996: AND
97997: IFFALSE 98009
// result := true else
97999: LD_ADDR_VAR 0 3
98003: PUSH
98004: LD_INT 1
98006: ST_TO_ADDR
98007: GO 98017
// result := false ;
98009: LD_ADDR_VAR 0 3
98013: PUSH
98014: LD_INT 0
98016: ST_TO_ADDR
// end else
98017: GO 98027
// result := false ;
98019: LD_ADDR_VAR 0 3
98023: PUSH
98024: LD_INT 0
98026: ST_TO_ADDR
// end ;
98027: LD_VAR 0 3
98031: RET
// export function HealTarget ( sci ) ; begin
98032: LD_INT 0
98034: PPUSH
// if not sci then
98035: LD_VAR 0 1
98039: NOT
98040: IFFALSE 98044
// exit ;
98042: GO 98109
// result := 0 ;
98044: LD_ADDR_VAR 0 2
98048: PUSH
98049: LD_INT 0
98051: ST_TO_ADDR
// if GetTaskList ( sci ) then
98052: LD_VAR 0 1
98056: PPUSH
98057: CALL_OW 437
98061: IFFALSE 98109
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98063: LD_VAR 0 1
98067: PPUSH
98068: CALL_OW 437
98072: PUSH
98073: LD_INT 1
98075: ARRAY
98076: PUSH
98077: LD_INT 1
98079: ARRAY
98080: PUSH
98081: LD_STRING l
98083: EQUAL
98084: IFFALSE 98109
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98086: LD_ADDR_VAR 0 2
98090: PUSH
98091: LD_VAR 0 1
98095: PPUSH
98096: CALL_OW 437
98100: PUSH
98101: LD_INT 1
98103: ARRAY
98104: PUSH
98105: LD_INT 4
98107: ARRAY
98108: ST_TO_ADDR
// end ;
98109: LD_VAR 0 2
98113: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98114: LD_INT 0
98116: PPUSH
98117: PPUSH
98118: PPUSH
98119: PPUSH
98120: PPUSH
98121: PPUSH
98122: PPUSH
98123: PPUSH
98124: PPUSH
98125: PPUSH
98126: PPUSH
98127: PPUSH
98128: PPUSH
98129: PPUSH
98130: PPUSH
98131: PPUSH
98132: PPUSH
98133: PPUSH
98134: PPUSH
98135: PPUSH
98136: PPUSH
98137: PPUSH
98138: PPUSH
98139: PPUSH
98140: PPUSH
98141: PPUSH
98142: PPUSH
98143: PPUSH
98144: PPUSH
98145: PPUSH
98146: PPUSH
98147: PPUSH
98148: PPUSH
98149: PPUSH
// if not list then
98150: LD_VAR 0 1
98154: NOT
98155: IFFALSE 98159
// exit ;
98157: GO 102785
// base := list [ 1 ] ;
98159: LD_ADDR_VAR 0 3
98163: PUSH
98164: LD_VAR 0 1
98168: PUSH
98169: LD_INT 1
98171: ARRAY
98172: ST_TO_ADDR
// group := list [ 2 ] ;
98173: LD_ADDR_VAR 0 4
98177: PUSH
98178: LD_VAR 0 1
98182: PUSH
98183: LD_INT 2
98185: ARRAY
98186: ST_TO_ADDR
// path := list [ 3 ] ;
98187: LD_ADDR_VAR 0 5
98191: PUSH
98192: LD_VAR 0 1
98196: PUSH
98197: LD_INT 3
98199: ARRAY
98200: ST_TO_ADDR
// flags := list [ 4 ] ;
98201: LD_ADDR_VAR 0 6
98205: PUSH
98206: LD_VAR 0 1
98210: PUSH
98211: LD_INT 4
98213: ARRAY
98214: ST_TO_ADDR
// mined := [ ] ;
98215: LD_ADDR_VAR 0 27
98219: PUSH
98220: EMPTY
98221: ST_TO_ADDR
// bombed := [ ] ;
98222: LD_ADDR_VAR 0 28
98226: PUSH
98227: EMPTY
98228: ST_TO_ADDR
// healers := [ ] ;
98229: LD_ADDR_VAR 0 31
98233: PUSH
98234: EMPTY
98235: ST_TO_ADDR
// to_heal := [ ] ;
98236: LD_ADDR_VAR 0 30
98240: PUSH
98241: EMPTY
98242: ST_TO_ADDR
// repairs := [ ] ;
98243: LD_ADDR_VAR 0 33
98247: PUSH
98248: EMPTY
98249: ST_TO_ADDR
// to_repair := [ ] ;
98250: LD_ADDR_VAR 0 32
98254: PUSH
98255: EMPTY
98256: ST_TO_ADDR
// if not group or not path then
98257: LD_VAR 0 4
98261: NOT
98262: PUSH
98263: LD_VAR 0 5
98267: NOT
98268: OR
98269: IFFALSE 98273
// exit ;
98271: GO 102785
// side := GetSide ( group [ 1 ] ) ;
98273: LD_ADDR_VAR 0 35
98277: PUSH
98278: LD_VAR 0 4
98282: PUSH
98283: LD_INT 1
98285: ARRAY
98286: PPUSH
98287: CALL_OW 255
98291: ST_TO_ADDR
// if flags then
98292: LD_VAR 0 6
98296: IFFALSE 98440
// begin f_ignore_area := flags [ 1 ] ;
98298: LD_ADDR_VAR 0 17
98302: PUSH
98303: LD_VAR 0 6
98307: PUSH
98308: LD_INT 1
98310: ARRAY
98311: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98312: LD_ADDR_VAR 0 18
98316: PUSH
98317: LD_VAR 0 6
98321: PUSH
98322: LD_INT 2
98324: ARRAY
98325: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98326: LD_ADDR_VAR 0 19
98330: PUSH
98331: LD_VAR 0 6
98335: PUSH
98336: LD_INT 3
98338: ARRAY
98339: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98340: LD_ADDR_VAR 0 20
98344: PUSH
98345: LD_VAR 0 6
98349: PUSH
98350: LD_INT 4
98352: ARRAY
98353: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98354: LD_ADDR_VAR 0 21
98358: PUSH
98359: LD_VAR 0 6
98363: PUSH
98364: LD_INT 5
98366: ARRAY
98367: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98368: LD_ADDR_VAR 0 22
98372: PUSH
98373: LD_VAR 0 6
98377: PUSH
98378: LD_INT 6
98380: ARRAY
98381: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98382: LD_ADDR_VAR 0 23
98386: PUSH
98387: LD_VAR 0 6
98391: PUSH
98392: LD_INT 7
98394: ARRAY
98395: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98396: LD_ADDR_VAR 0 24
98400: PUSH
98401: LD_VAR 0 6
98405: PUSH
98406: LD_INT 8
98408: ARRAY
98409: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98410: LD_ADDR_VAR 0 25
98414: PUSH
98415: LD_VAR 0 6
98419: PUSH
98420: LD_INT 9
98422: ARRAY
98423: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98424: LD_ADDR_VAR 0 26
98428: PUSH
98429: LD_VAR 0 6
98433: PUSH
98434: LD_INT 10
98436: ARRAY
98437: ST_TO_ADDR
// end else
98438: GO 98520
// begin f_ignore_area := false ;
98440: LD_ADDR_VAR 0 17
98444: PUSH
98445: LD_INT 0
98447: ST_TO_ADDR
// f_capture := false ;
98448: LD_ADDR_VAR 0 18
98452: PUSH
98453: LD_INT 0
98455: ST_TO_ADDR
// f_ignore_civ := false ;
98456: LD_ADDR_VAR 0 19
98460: PUSH
98461: LD_INT 0
98463: ST_TO_ADDR
// f_murder := false ;
98464: LD_ADDR_VAR 0 20
98468: PUSH
98469: LD_INT 0
98471: ST_TO_ADDR
// f_mines := false ;
98472: LD_ADDR_VAR 0 21
98476: PUSH
98477: LD_INT 0
98479: ST_TO_ADDR
// f_repair := false ;
98480: LD_ADDR_VAR 0 22
98484: PUSH
98485: LD_INT 0
98487: ST_TO_ADDR
// f_heal := false ;
98488: LD_ADDR_VAR 0 23
98492: PUSH
98493: LD_INT 0
98495: ST_TO_ADDR
// f_spacetime := false ;
98496: LD_ADDR_VAR 0 24
98500: PUSH
98501: LD_INT 0
98503: ST_TO_ADDR
// f_attack_depot := false ;
98504: LD_ADDR_VAR 0 25
98508: PUSH
98509: LD_INT 0
98511: ST_TO_ADDR
// f_crawl := false ;
98512: LD_ADDR_VAR 0 26
98516: PUSH
98517: LD_INT 0
98519: ST_TO_ADDR
// end ; if f_heal then
98520: LD_VAR 0 23
98524: IFFALSE 98551
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98526: LD_ADDR_VAR 0 31
98530: PUSH
98531: LD_VAR 0 4
98535: PPUSH
98536: LD_INT 25
98538: PUSH
98539: LD_INT 4
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PPUSH
98546: CALL_OW 72
98550: ST_TO_ADDR
// if f_repair then
98551: LD_VAR 0 22
98555: IFFALSE 98582
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98557: LD_ADDR_VAR 0 33
98561: PUSH
98562: LD_VAR 0 4
98566: PPUSH
98567: LD_INT 25
98569: PUSH
98570: LD_INT 3
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PPUSH
98577: CALL_OW 72
98581: ST_TO_ADDR
// units_path := [ ] ;
98582: LD_ADDR_VAR 0 16
98586: PUSH
98587: EMPTY
98588: ST_TO_ADDR
// for i = 1 to group do
98589: LD_ADDR_VAR 0 7
98593: PUSH
98594: DOUBLE
98595: LD_INT 1
98597: DEC
98598: ST_TO_ADDR
98599: LD_VAR 0 4
98603: PUSH
98604: FOR_TO
98605: IFFALSE 98634
// units_path := Replace ( units_path , i , path ) ;
98607: LD_ADDR_VAR 0 16
98611: PUSH
98612: LD_VAR 0 16
98616: PPUSH
98617: LD_VAR 0 7
98621: PPUSH
98622: LD_VAR 0 5
98626: PPUSH
98627: CALL_OW 1
98631: ST_TO_ADDR
98632: GO 98604
98634: POP
98635: POP
// repeat for i = group downto 1 do
98636: LD_ADDR_VAR 0 7
98640: PUSH
98641: DOUBLE
98642: LD_VAR 0 4
98646: INC
98647: ST_TO_ADDR
98648: LD_INT 1
98650: PUSH
98651: FOR_DOWNTO
98652: IFFALSE 102748
// begin wait ( 5 ) ;
98654: LD_INT 5
98656: PPUSH
98657: CALL_OW 67
// tmp := [ ] ;
98661: LD_ADDR_VAR 0 14
98665: PUSH
98666: EMPTY
98667: ST_TO_ADDR
// attacking := false ;
98668: LD_ADDR_VAR 0 29
98672: PUSH
98673: LD_INT 0
98675: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98676: LD_VAR 0 4
98680: PUSH
98681: LD_VAR 0 7
98685: ARRAY
98686: PPUSH
98687: CALL_OW 301
98691: PUSH
98692: LD_VAR 0 4
98696: PUSH
98697: LD_VAR 0 7
98701: ARRAY
98702: NOT
98703: OR
98704: IFFALSE 98813
// begin if GetType ( group [ i ] ) = unit_human then
98706: LD_VAR 0 4
98710: PUSH
98711: LD_VAR 0 7
98715: ARRAY
98716: PPUSH
98717: CALL_OW 247
98721: PUSH
98722: LD_INT 1
98724: EQUAL
98725: IFFALSE 98771
// begin to_heal := to_heal diff group [ i ] ;
98727: LD_ADDR_VAR 0 30
98731: PUSH
98732: LD_VAR 0 30
98736: PUSH
98737: LD_VAR 0 4
98741: PUSH
98742: LD_VAR 0 7
98746: ARRAY
98747: DIFF
98748: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98749: LD_ADDR_VAR 0 31
98753: PUSH
98754: LD_VAR 0 31
98758: PUSH
98759: LD_VAR 0 4
98763: PUSH
98764: LD_VAR 0 7
98768: ARRAY
98769: DIFF
98770: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98771: LD_ADDR_VAR 0 4
98775: PUSH
98776: LD_VAR 0 4
98780: PPUSH
98781: LD_VAR 0 7
98785: PPUSH
98786: CALL_OW 3
98790: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98791: LD_ADDR_VAR 0 16
98795: PUSH
98796: LD_VAR 0 16
98800: PPUSH
98801: LD_VAR 0 7
98805: PPUSH
98806: CALL_OW 3
98810: ST_TO_ADDR
// continue ;
98811: GO 98651
// end ; if f_repair then
98813: LD_VAR 0 22
98817: IFFALSE 99306
// begin if GetType ( group [ i ] ) = unit_vehicle then
98819: LD_VAR 0 4
98823: PUSH
98824: LD_VAR 0 7
98828: ARRAY
98829: PPUSH
98830: CALL_OW 247
98834: PUSH
98835: LD_INT 2
98837: EQUAL
98838: IFFALSE 99028
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98840: LD_VAR 0 4
98844: PUSH
98845: LD_VAR 0 7
98849: ARRAY
98850: PPUSH
98851: CALL_OW 256
98855: PUSH
98856: LD_INT 700
98858: LESS
98859: PUSH
98860: LD_VAR 0 4
98864: PUSH
98865: LD_VAR 0 7
98869: ARRAY
98870: PUSH
98871: LD_VAR 0 32
98875: IN
98876: NOT
98877: AND
98878: IFFALSE 98902
// to_repair := to_repair union group [ i ] ;
98880: LD_ADDR_VAR 0 32
98884: PUSH
98885: LD_VAR 0 32
98889: PUSH
98890: LD_VAR 0 4
98894: PUSH
98895: LD_VAR 0 7
98899: ARRAY
98900: UNION
98901: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98902: LD_VAR 0 4
98906: PUSH
98907: LD_VAR 0 7
98911: ARRAY
98912: PPUSH
98913: CALL_OW 256
98917: PUSH
98918: LD_INT 1000
98920: EQUAL
98921: PUSH
98922: LD_VAR 0 4
98926: PUSH
98927: LD_VAR 0 7
98931: ARRAY
98932: PUSH
98933: LD_VAR 0 32
98937: IN
98938: AND
98939: IFFALSE 98963
// to_repair := to_repair diff group [ i ] ;
98941: LD_ADDR_VAR 0 32
98945: PUSH
98946: LD_VAR 0 32
98950: PUSH
98951: LD_VAR 0 4
98955: PUSH
98956: LD_VAR 0 7
98960: ARRAY
98961: DIFF
98962: ST_TO_ADDR
// if group [ i ] in to_repair then
98963: LD_VAR 0 4
98967: PUSH
98968: LD_VAR 0 7
98972: ARRAY
98973: PUSH
98974: LD_VAR 0 32
98978: IN
98979: IFFALSE 99026
// begin if not IsInArea ( group [ i ] , f_repair ) then
98981: LD_VAR 0 4
98985: PUSH
98986: LD_VAR 0 7
98990: ARRAY
98991: PPUSH
98992: LD_VAR 0 22
98996: PPUSH
98997: CALL_OW 308
99001: NOT
99002: IFFALSE 99024
// ComMoveToArea ( group [ i ] , f_repair ) ;
99004: LD_VAR 0 4
99008: PUSH
99009: LD_VAR 0 7
99013: ARRAY
99014: PPUSH
99015: LD_VAR 0 22
99019: PPUSH
99020: CALL_OW 113
// continue ;
99024: GO 98651
// end ; end else
99026: GO 99306
// if group [ i ] in repairs then
99028: LD_VAR 0 4
99032: PUSH
99033: LD_VAR 0 7
99037: ARRAY
99038: PUSH
99039: LD_VAR 0 33
99043: IN
99044: IFFALSE 99306
// begin if IsInUnit ( group [ i ] ) then
99046: LD_VAR 0 4
99050: PUSH
99051: LD_VAR 0 7
99055: ARRAY
99056: PPUSH
99057: CALL_OW 310
99061: IFFALSE 99129
// begin z := IsInUnit ( group [ i ] ) ;
99063: LD_ADDR_VAR 0 13
99067: PUSH
99068: LD_VAR 0 4
99072: PUSH
99073: LD_VAR 0 7
99077: ARRAY
99078: PPUSH
99079: CALL_OW 310
99083: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99084: LD_VAR 0 13
99088: PUSH
99089: LD_VAR 0 32
99093: IN
99094: PUSH
99095: LD_VAR 0 13
99099: PPUSH
99100: LD_VAR 0 22
99104: PPUSH
99105: CALL_OW 308
99109: AND
99110: IFFALSE 99127
// ComExitVehicle ( group [ i ] ) ;
99112: LD_VAR 0 4
99116: PUSH
99117: LD_VAR 0 7
99121: ARRAY
99122: PPUSH
99123: CALL_OW 121
// end else
99127: GO 99306
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99129: LD_ADDR_VAR 0 13
99133: PUSH
99134: LD_VAR 0 4
99138: PPUSH
99139: LD_INT 95
99141: PUSH
99142: LD_VAR 0 22
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PUSH
99151: LD_INT 58
99153: PUSH
99154: EMPTY
99155: LIST
99156: PUSH
99157: EMPTY
99158: LIST
99159: LIST
99160: PPUSH
99161: CALL_OW 72
99165: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99166: LD_VAR 0 4
99170: PUSH
99171: LD_VAR 0 7
99175: ARRAY
99176: PPUSH
99177: CALL_OW 314
99181: NOT
99182: IFFALSE 99304
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99184: LD_ADDR_VAR 0 10
99188: PUSH
99189: LD_VAR 0 13
99193: PPUSH
99194: LD_VAR 0 4
99198: PUSH
99199: LD_VAR 0 7
99203: ARRAY
99204: PPUSH
99205: CALL_OW 74
99209: ST_TO_ADDR
// if not x then
99210: LD_VAR 0 10
99214: NOT
99215: IFFALSE 99219
// continue ;
99217: GO 98651
// if GetLives ( x ) < 1000 then
99219: LD_VAR 0 10
99223: PPUSH
99224: CALL_OW 256
99228: PUSH
99229: LD_INT 1000
99231: LESS
99232: IFFALSE 99256
// ComRepairVehicle ( group [ i ] , x ) else
99234: LD_VAR 0 4
99238: PUSH
99239: LD_VAR 0 7
99243: ARRAY
99244: PPUSH
99245: LD_VAR 0 10
99249: PPUSH
99250: CALL_OW 129
99254: GO 99304
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99256: LD_VAR 0 23
99260: PUSH
99261: LD_VAR 0 4
99265: PUSH
99266: LD_VAR 0 7
99270: ARRAY
99271: PPUSH
99272: CALL_OW 256
99276: PUSH
99277: LD_INT 1000
99279: LESS
99280: AND
99281: NOT
99282: IFFALSE 99304
// ComEnterUnit ( group [ i ] , x ) ;
99284: LD_VAR 0 4
99288: PUSH
99289: LD_VAR 0 7
99293: ARRAY
99294: PPUSH
99295: LD_VAR 0 10
99299: PPUSH
99300: CALL_OW 120
// end ; continue ;
99304: GO 98651
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99306: LD_VAR 0 23
99310: PUSH
99311: LD_VAR 0 4
99315: PUSH
99316: LD_VAR 0 7
99320: ARRAY
99321: PPUSH
99322: CALL_OW 247
99326: PUSH
99327: LD_INT 1
99329: EQUAL
99330: AND
99331: IFFALSE 99809
// begin if group [ i ] in healers then
99333: LD_VAR 0 4
99337: PUSH
99338: LD_VAR 0 7
99342: ARRAY
99343: PUSH
99344: LD_VAR 0 31
99348: IN
99349: IFFALSE 99622
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99351: LD_VAR 0 4
99355: PUSH
99356: LD_VAR 0 7
99360: ARRAY
99361: PPUSH
99362: LD_VAR 0 23
99366: PPUSH
99367: CALL_OW 308
99371: NOT
99372: PUSH
99373: LD_VAR 0 4
99377: PUSH
99378: LD_VAR 0 7
99382: ARRAY
99383: PPUSH
99384: CALL_OW 314
99388: NOT
99389: AND
99390: IFFALSE 99414
// ComMoveToArea ( group [ i ] , f_heal ) else
99392: LD_VAR 0 4
99396: PUSH
99397: LD_VAR 0 7
99401: ARRAY
99402: PPUSH
99403: LD_VAR 0 23
99407: PPUSH
99408: CALL_OW 113
99412: GO 99620
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99414: LD_VAR 0 4
99418: PUSH
99419: LD_VAR 0 7
99423: ARRAY
99424: PPUSH
99425: CALL 98032 0 1
99429: PPUSH
99430: CALL_OW 256
99434: PUSH
99435: LD_INT 1000
99437: EQUAL
99438: IFFALSE 99457
// ComStop ( group [ i ] ) else
99440: LD_VAR 0 4
99444: PUSH
99445: LD_VAR 0 7
99449: ARRAY
99450: PPUSH
99451: CALL_OW 141
99455: GO 99620
// if not HasTask ( group [ i ] ) and to_heal then
99457: LD_VAR 0 4
99461: PUSH
99462: LD_VAR 0 7
99466: ARRAY
99467: PPUSH
99468: CALL_OW 314
99472: NOT
99473: PUSH
99474: LD_VAR 0 30
99478: AND
99479: IFFALSE 99620
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99481: LD_ADDR_VAR 0 13
99485: PUSH
99486: LD_VAR 0 30
99490: PPUSH
99491: LD_INT 3
99493: PUSH
99494: LD_INT 54
99496: PUSH
99497: EMPTY
99498: LIST
99499: PUSH
99500: EMPTY
99501: LIST
99502: LIST
99503: PPUSH
99504: CALL_OW 72
99508: PPUSH
99509: LD_VAR 0 4
99513: PUSH
99514: LD_VAR 0 7
99518: ARRAY
99519: PPUSH
99520: CALL_OW 74
99524: ST_TO_ADDR
// if z then
99525: LD_VAR 0 13
99529: IFFALSE 99620
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99531: LD_INT 91
99533: PUSH
99534: LD_VAR 0 13
99538: PUSH
99539: LD_INT 10
99541: PUSH
99542: EMPTY
99543: LIST
99544: LIST
99545: LIST
99546: PUSH
99547: LD_INT 81
99549: PUSH
99550: LD_VAR 0 13
99554: PPUSH
99555: CALL_OW 255
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: EMPTY
99565: LIST
99566: LIST
99567: PPUSH
99568: CALL_OW 69
99572: PUSH
99573: LD_INT 0
99575: EQUAL
99576: IFFALSE 99600
// ComHeal ( group [ i ] , z ) else
99578: LD_VAR 0 4
99582: PUSH
99583: LD_VAR 0 7
99587: ARRAY
99588: PPUSH
99589: LD_VAR 0 13
99593: PPUSH
99594: CALL_OW 128
99598: GO 99620
// ComMoveToArea ( group [ i ] , f_heal ) ;
99600: LD_VAR 0 4
99604: PUSH
99605: LD_VAR 0 7
99609: ARRAY
99610: PPUSH
99611: LD_VAR 0 23
99615: PPUSH
99616: CALL_OW 113
// end ; continue ;
99620: GO 98651
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99622: LD_VAR 0 4
99626: PUSH
99627: LD_VAR 0 7
99631: ARRAY
99632: PPUSH
99633: CALL_OW 256
99637: PUSH
99638: LD_INT 700
99640: LESS
99641: PUSH
99642: LD_VAR 0 4
99646: PUSH
99647: LD_VAR 0 7
99651: ARRAY
99652: PUSH
99653: LD_VAR 0 30
99657: IN
99658: NOT
99659: AND
99660: IFFALSE 99684
// to_heal := to_heal union group [ i ] ;
99662: LD_ADDR_VAR 0 30
99666: PUSH
99667: LD_VAR 0 30
99671: PUSH
99672: LD_VAR 0 4
99676: PUSH
99677: LD_VAR 0 7
99681: ARRAY
99682: UNION
99683: ST_TO_ADDR
// if group [ i ] in to_heal then
99684: LD_VAR 0 4
99688: PUSH
99689: LD_VAR 0 7
99693: ARRAY
99694: PUSH
99695: LD_VAR 0 30
99699: IN
99700: IFFALSE 99809
// begin if GetLives ( group [ i ] ) = 1000 then
99702: LD_VAR 0 4
99706: PUSH
99707: LD_VAR 0 7
99711: ARRAY
99712: PPUSH
99713: CALL_OW 256
99717: PUSH
99718: LD_INT 1000
99720: EQUAL
99721: IFFALSE 99747
// to_heal := to_heal diff group [ i ] else
99723: LD_ADDR_VAR 0 30
99727: PUSH
99728: LD_VAR 0 30
99732: PUSH
99733: LD_VAR 0 4
99737: PUSH
99738: LD_VAR 0 7
99742: ARRAY
99743: DIFF
99744: ST_TO_ADDR
99745: GO 99809
// begin if not IsInArea ( group [ i ] , to_heal ) then
99747: LD_VAR 0 4
99751: PUSH
99752: LD_VAR 0 7
99756: ARRAY
99757: PPUSH
99758: LD_VAR 0 30
99762: PPUSH
99763: CALL_OW 308
99767: NOT
99768: IFFALSE 99792
// ComMoveToArea ( group [ i ] , f_heal ) else
99770: LD_VAR 0 4
99774: PUSH
99775: LD_VAR 0 7
99779: ARRAY
99780: PPUSH
99781: LD_VAR 0 23
99785: PPUSH
99786: CALL_OW 113
99790: GO 99807
// ComHold ( group [ i ] ) ;
99792: LD_VAR 0 4
99796: PUSH
99797: LD_VAR 0 7
99801: ARRAY
99802: PPUSH
99803: CALL_OW 140
// continue ;
99807: GO 98651
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99809: LD_VAR 0 4
99813: PUSH
99814: LD_VAR 0 7
99818: ARRAY
99819: PPUSH
99820: LD_INT 10
99822: PPUSH
99823: CALL 96429 0 2
99827: NOT
99828: PUSH
99829: LD_VAR 0 16
99833: PUSH
99834: LD_VAR 0 7
99838: ARRAY
99839: PUSH
99840: EMPTY
99841: EQUAL
99842: NOT
99843: AND
99844: IFFALSE 100110
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99846: LD_VAR 0 4
99850: PUSH
99851: LD_VAR 0 7
99855: ARRAY
99856: PPUSH
99857: CALL_OW 262
99861: PUSH
99862: LD_INT 1
99864: PUSH
99865: LD_INT 2
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: IN
99872: IFFALSE 99913
// if GetFuel ( group [ i ] ) < 10 then
99874: LD_VAR 0 4
99878: PUSH
99879: LD_VAR 0 7
99883: ARRAY
99884: PPUSH
99885: CALL_OW 261
99889: PUSH
99890: LD_INT 10
99892: LESS
99893: IFFALSE 99913
// SetFuel ( group [ i ] , 12 ) ;
99895: LD_VAR 0 4
99899: PUSH
99900: LD_VAR 0 7
99904: ARRAY
99905: PPUSH
99906: LD_INT 12
99908: PPUSH
99909: CALL_OW 240
// if units_path [ i ] then
99913: LD_VAR 0 16
99917: PUSH
99918: LD_VAR 0 7
99922: ARRAY
99923: IFFALSE 100108
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99925: LD_VAR 0 4
99929: PUSH
99930: LD_VAR 0 7
99934: ARRAY
99935: PPUSH
99936: LD_VAR 0 16
99940: PUSH
99941: LD_VAR 0 7
99945: ARRAY
99946: PUSH
99947: LD_INT 1
99949: ARRAY
99950: PUSH
99951: LD_INT 1
99953: ARRAY
99954: PPUSH
99955: LD_VAR 0 16
99959: PUSH
99960: LD_VAR 0 7
99964: ARRAY
99965: PUSH
99966: LD_INT 1
99968: ARRAY
99969: PUSH
99970: LD_INT 2
99972: ARRAY
99973: PPUSH
99974: CALL_OW 297
99978: PUSH
99979: LD_INT 6
99981: GREATER
99982: IFFALSE 100057
// begin if not HasTask ( group [ i ] ) then
99984: LD_VAR 0 4
99988: PUSH
99989: LD_VAR 0 7
99993: ARRAY
99994: PPUSH
99995: CALL_OW 314
99999: NOT
100000: IFFALSE 100055
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100002: LD_VAR 0 4
100006: PUSH
100007: LD_VAR 0 7
100011: ARRAY
100012: PPUSH
100013: LD_VAR 0 16
100017: PUSH
100018: LD_VAR 0 7
100022: ARRAY
100023: PUSH
100024: LD_INT 1
100026: ARRAY
100027: PUSH
100028: LD_INT 1
100030: ARRAY
100031: PPUSH
100032: LD_VAR 0 16
100036: PUSH
100037: LD_VAR 0 7
100041: ARRAY
100042: PUSH
100043: LD_INT 1
100045: ARRAY
100046: PUSH
100047: LD_INT 2
100049: ARRAY
100050: PPUSH
100051: CALL_OW 114
// end else
100055: GO 100108
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100057: LD_ADDR_VAR 0 15
100061: PUSH
100062: LD_VAR 0 16
100066: PUSH
100067: LD_VAR 0 7
100071: ARRAY
100072: PPUSH
100073: LD_INT 1
100075: PPUSH
100076: CALL_OW 3
100080: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100081: LD_ADDR_VAR 0 16
100085: PUSH
100086: LD_VAR 0 16
100090: PPUSH
100091: LD_VAR 0 7
100095: PPUSH
100096: LD_VAR 0 15
100100: PPUSH
100101: CALL_OW 1
100105: ST_TO_ADDR
// continue ;
100106: GO 98651
// end ; end ; end else
100108: GO 102746
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100110: LD_ADDR_VAR 0 14
100114: PUSH
100115: LD_INT 81
100117: PUSH
100118: LD_VAR 0 4
100122: PUSH
100123: LD_VAR 0 7
100127: ARRAY
100128: PPUSH
100129: CALL_OW 255
100133: PUSH
100134: EMPTY
100135: LIST
100136: LIST
100137: PPUSH
100138: CALL_OW 69
100142: ST_TO_ADDR
// if not tmp then
100143: LD_VAR 0 14
100147: NOT
100148: IFFALSE 100152
// continue ;
100150: GO 98651
// if f_ignore_area then
100152: LD_VAR 0 17
100156: IFFALSE 100244
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100158: LD_ADDR_VAR 0 15
100162: PUSH
100163: LD_VAR 0 14
100167: PPUSH
100168: LD_INT 3
100170: PUSH
100171: LD_INT 92
100173: PUSH
100174: LD_VAR 0 17
100178: PUSH
100179: LD_INT 1
100181: ARRAY
100182: PUSH
100183: LD_VAR 0 17
100187: PUSH
100188: LD_INT 2
100190: ARRAY
100191: PUSH
100192: LD_VAR 0 17
100196: PUSH
100197: LD_INT 3
100199: ARRAY
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: LIST
100205: LIST
100206: PUSH
100207: EMPTY
100208: LIST
100209: LIST
100210: PPUSH
100211: CALL_OW 72
100215: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100216: LD_VAR 0 14
100220: PUSH
100221: LD_VAR 0 15
100225: DIFF
100226: IFFALSE 100244
// tmp := tmp diff tmp2 ;
100228: LD_ADDR_VAR 0 14
100232: PUSH
100233: LD_VAR 0 14
100237: PUSH
100238: LD_VAR 0 15
100242: DIFF
100243: ST_TO_ADDR
// end ; if not f_murder then
100244: LD_VAR 0 20
100248: NOT
100249: IFFALSE 100307
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100251: LD_ADDR_VAR 0 15
100255: PUSH
100256: LD_VAR 0 14
100260: PPUSH
100261: LD_INT 3
100263: PUSH
100264: LD_INT 50
100266: PUSH
100267: EMPTY
100268: LIST
100269: PUSH
100270: EMPTY
100271: LIST
100272: LIST
100273: PPUSH
100274: CALL_OW 72
100278: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100279: LD_VAR 0 14
100283: PUSH
100284: LD_VAR 0 15
100288: DIFF
100289: IFFALSE 100307
// tmp := tmp diff tmp2 ;
100291: LD_ADDR_VAR 0 14
100295: PUSH
100296: LD_VAR 0 14
100300: PUSH
100301: LD_VAR 0 15
100305: DIFF
100306: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100307: LD_ADDR_VAR 0 14
100311: PUSH
100312: LD_VAR 0 4
100316: PUSH
100317: LD_VAR 0 7
100321: ARRAY
100322: PPUSH
100323: LD_VAR 0 14
100327: PPUSH
100328: LD_INT 1
100330: PPUSH
100331: LD_INT 1
100333: PPUSH
100334: CALL 70072 0 4
100338: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100339: LD_VAR 0 4
100343: PUSH
100344: LD_VAR 0 7
100348: ARRAY
100349: PPUSH
100350: CALL_OW 257
100354: PUSH
100355: LD_INT 1
100357: EQUAL
100358: IFFALSE 100806
// begin if WantPlant ( group [ i ] ) then
100360: LD_VAR 0 4
100364: PUSH
100365: LD_VAR 0 7
100369: ARRAY
100370: PPUSH
100371: CALL 69573 0 1
100375: IFFALSE 100379
// continue ;
100377: GO 98651
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100379: LD_VAR 0 18
100383: PUSH
100384: LD_VAR 0 4
100388: PUSH
100389: LD_VAR 0 7
100393: ARRAY
100394: PPUSH
100395: CALL_OW 310
100399: NOT
100400: AND
100401: PUSH
100402: LD_VAR 0 14
100406: PUSH
100407: LD_INT 1
100409: ARRAY
100410: PUSH
100411: LD_VAR 0 14
100415: PPUSH
100416: LD_INT 21
100418: PUSH
100419: LD_INT 2
100421: PUSH
100422: EMPTY
100423: LIST
100424: LIST
100425: PUSH
100426: LD_INT 58
100428: PUSH
100429: EMPTY
100430: LIST
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: PPUSH
100436: CALL_OW 72
100440: IN
100441: AND
100442: IFFALSE 100478
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100444: LD_VAR 0 4
100448: PUSH
100449: LD_VAR 0 7
100453: ARRAY
100454: PPUSH
100455: LD_VAR 0 14
100459: PUSH
100460: LD_INT 1
100462: ARRAY
100463: PPUSH
100464: CALL_OW 120
// attacking := true ;
100468: LD_ADDR_VAR 0 29
100472: PUSH
100473: LD_INT 1
100475: ST_TO_ADDR
// continue ;
100476: GO 98651
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100478: LD_VAR 0 26
100482: PUSH
100483: LD_VAR 0 4
100487: PUSH
100488: LD_VAR 0 7
100492: ARRAY
100493: PPUSH
100494: CALL_OW 257
100498: PUSH
100499: LD_INT 1
100501: EQUAL
100502: AND
100503: PUSH
100504: LD_VAR 0 4
100508: PUSH
100509: LD_VAR 0 7
100513: ARRAY
100514: PPUSH
100515: CALL_OW 256
100519: PUSH
100520: LD_INT 800
100522: LESS
100523: AND
100524: PUSH
100525: LD_VAR 0 4
100529: PUSH
100530: LD_VAR 0 7
100534: ARRAY
100535: PPUSH
100536: CALL_OW 318
100540: NOT
100541: AND
100542: IFFALSE 100559
// ComCrawl ( group [ i ] ) ;
100544: LD_VAR 0 4
100548: PUSH
100549: LD_VAR 0 7
100553: ARRAY
100554: PPUSH
100555: CALL_OW 137
// if f_mines then
100559: LD_VAR 0 21
100563: IFFALSE 100806
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100565: LD_VAR 0 14
100569: PUSH
100570: LD_INT 1
100572: ARRAY
100573: PPUSH
100574: CALL_OW 247
100578: PUSH
100579: LD_INT 3
100581: EQUAL
100582: PUSH
100583: LD_VAR 0 14
100587: PUSH
100588: LD_INT 1
100590: ARRAY
100591: PUSH
100592: LD_VAR 0 27
100596: IN
100597: NOT
100598: AND
100599: IFFALSE 100806
// begin x := GetX ( tmp [ 1 ] ) ;
100601: LD_ADDR_VAR 0 10
100605: PUSH
100606: LD_VAR 0 14
100610: PUSH
100611: LD_INT 1
100613: ARRAY
100614: PPUSH
100615: CALL_OW 250
100619: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100620: LD_ADDR_VAR 0 11
100624: PUSH
100625: LD_VAR 0 14
100629: PUSH
100630: LD_INT 1
100632: ARRAY
100633: PPUSH
100634: CALL_OW 251
100638: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100639: LD_ADDR_VAR 0 12
100643: PUSH
100644: LD_VAR 0 4
100648: PUSH
100649: LD_VAR 0 7
100653: ARRAY
100654: PPUSH
100655: CALL 96514 0 1
100659: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100660: LD_VAR 0 4
100664: PUSH
100665: LD_VAR 0 7
100669: ARRAY
100670: PPUSH
100671: LD_VAR 0 10
100675: PPUSH
100676: LD_VAR 0 11
100680: PPUSH
100681: LD_VAR 0 14
100685: PUSH
100686: LD_INT 1
100688: ARRAY
100689: PPUSH
100690: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100694: LD_VAR 0 4
100698: PUSH
100699: LD_VAR 0 7
100703: ARRAY
100704: PPUSH
100705: LD_VAR 0 10
100709: PPUSH
100710: LD_VAR 0 12
100714: PPUSH
100715: LD_INT 7
100717: PPUSH
100718: CALL_OW 272
100722: PPUSH
100723: LD_VAR 0 11
100727: PPUSH
100728: LD_VAR 0 12
100732: PPUSH
100733: LD_INT 7
100735: PPUSH
100736: CALL_OW 273
100740: PPUSH
100741: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100745: LD_VAR 0 4
100749: PUSH
100750: LD_VAR 0 7
100754: ARRAY
100755: PPUSH
100756: LD_INT 71
100758: PPUSH
100759: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100763: LD_ADDR_VAR 0 27
100767: PUSH
100768: LD_VAR 0 27
100772: PPUSH
100773: LD_VAR 0 27
100777: PUSH
100778: LD_INT 1
100780: PLUS
100781: PPUSH
100782: LD_VAR 0 14
100786: PUSH
100787: LD_INT 1
100789: ARRAY
100790: PPUSH
100791: CALL_OW 1
100795: ST_TO_ADDR
// attacking := true ;
100796: LD_ADDR_VAR 0 29
100800: PUSH
100801: LD_INT 1
100803: ST_TO_ADDR
// continue ;
100804: GO 98651
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100806: LD_VAR 0 4
100810: PUSH
100811: LD_VAR 0 7
100815: ARRAY
100816: PPUSH
100817: CALL_OW 257
100821: PUSH
100822: LD_INT 17
100824: EQUAL
100825: PUSH
100826: LD_VAR 0 4
100830: PUSH
100831: LD_VAR 0 7
100835: ARRAY
100836: PPUSH
100837: CALL_OW 110
100841: PUSH
100842: LD_INT 71
100844: EQUAL
100845: NOT
100846: AND
100847: IFFALSE 100993
// begin attacking := false ;
100849: LD_ADDR_VAR 0 29
100853: PUSH
100854: LD_INT 0
100856: ST_TO_ADDR
// k := 5 ;
100857: LD_ADDR_VAR 0 9
100861: PUSH
100862: LD_INT 5
100864: ST_TO_ADDR
// if tmp < k then
100865: LD_VAR 0 14
100869: PUSH
100870: LD_VAR 0 9
100874: LESS
100875: IFFALSE 100887
// k := tmp ;
100877: LD_ADDR_VAR 0 9
100881: PUSH
100882: LD_VAR 0 14
100886: ST_TO_ADDR
// for j = 1 to k do
100887: LD_ADDR_VAR 0 8
100891: PUSH
100892: DOUBLE
100893: LD_INT 1
100895: DEC
100896: ST_TO_ADDR
100897: LD_VAR 0 9
100901: PUSH
100902: FOR_TO
100903: IFFALSE 100991
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100905: LD_VAR 0 14
100909: PUSH
100910: LD_VAR 0 8
100914: ARRAY
100915: PUSH
100916: LD_VAR 0 14
100920: PPUSH
100921: LD_INT 58
100923: PUSH
100924: EMPTY
100925: LIST
100926: PPUSH
100927: CALL_OW 72
100931: IN
100932: NOT
100933: IFFALSE 100989
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100935: LD_VAR 0 4
100939: PUSH
100940: LD_VAR 0 7
100944: ARRAY
100945: PPUSH
100946: LD_VAR 0 14
100950: PUSH
100951: LD_VAR 0 8
100955: ARRAY
100956: PPUSH
100957: CALL_OW 115
// attacking := true ;
100961: LD_ADDR_VAR 0 29
100965: PUSH
100966: LD_INT 1
100968: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
100969: LD_VAR 0 4
100973: PUSH
100974: LD_VAR 0 7
100978: ARRAY
100979: PPUSH
100980: LD_INT 71
100982: PPUSH
100983: CALL_OW 109
// continue ;
100987: GO 100902
// end ; end ;
100989: GO 100902
100991: POP
100992: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
100993: LD_VAR 0 4
100997: PUSH
100998: LD_VAR 0 7
101002: ARRAY
101003: PPUSH
101004: CALL_OW 257
101008: PUSH
101009: LD_INT 8
101011: EQUAL
101012: PUSH
101013: LD_VAR 0 4
101017: PUSH
101018: LD_VAR 0 7
101022: ARRAY
101023: PPUSH
101024: CALL_OW 264
101028: PUSH
101029: LD_INT 28
101031: PUSH
101032: LD_INT 45
101034: PUSH
101035: LD_INT 7
101037: PUSH
101038: LD_INT 47
101040: PUSH
101041: EMPTY
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: IN
101047: OR
101048: IFFALSE 101278
// begin attacking := false ;
101050: LD_ADDR_VAR 0 29
101054: PUSH
101055: LD_INT 0
101057: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101058: LD_VAR 0 14
101062: PUSH
101063: LD_INT 1
101065: ARRAY
101066: PPUSH
101067: CALL_OW 266
101071: PUSH
101072: LD_INT 32
101074: PUSH
101075: LD_INT 31
101077: PUSH
101078: LD_INT 33
101080: PUSH
101081: LD_INT 4
101083: PUSH
101084: LD_INT 5
101086: PUSH
101087: EMPTY
101088: LIST
101089: LIST
101090: LIST
101091: LIST
101092: LIST
101093: IN
101094: IFFALSE 101278
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101096: LD_ADDR_VAR 0 9
101100: PUSH
101101: LD_VAR 0 14
101105: PUSH
101106: LD_INT 1
101108: ARRAY
101109: PPUSH
101110: CALL_OW 266
101114: PPUSH
101115: LD_VAR 0 14
101119: PUSH
101120: LD_INT 1
101122: ARRAY
101123: PPUSH
101124: CALL_OW 250
101128: PPUSH
101129: LD_VAR 0 14
101133: PUSH
101134: LD_INT 1
101136: ARRAY
101137: PPUSH
101138: CALL_OW 251
101142: PPUSH
101143: LD_VAR 0 14
101147: PUSH
101148: LD_INT 1
101150: ARRAY
101151: PPUSH
101152: CALL_OW 254
101156: PPUSH
101157: LD_VAR 0 14
101161: PUSH
101162: LD_INT 1
101164: ARRAY
101165: PPUSH
101166: CALL_OW 248
101170: PPUSH
101171: LD_INT 0
101173: PPUSH
101174: CALL 77884 0 6
101178: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101179: LD_ADDR_VAR 0 8
101183: PUSH
101184: LD_VAR 0 4
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PPUSH
101195: LD_VAR 0 9
101199: PPUSH
101200: CALL 96577 0 2
101204: ST_TO_ADDR
// if j then
101205: LD_VAR 0 8
101209: IFFALSE 101278
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101211: LD_VAR 0 8
101215: PUSH
101216: LD_INT 1
101218: ARRAY
101219: PPUSH
101220: LD_VAR 0 8
101224: PUSH
101225: LD_INT 2
101227: ARRAY
101228: PPUSH
101229: CALL_OW 488
101233: IFFALSE 101278
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101235: LD_VAR 0 4
101239: PUSH
101240: LD_VAR 0 7
101244: ARRAY
101245: PPUSH
101246: LD_VAR 0 8
101250: PUSH
101251: LD_INT 1
101253: ARRAY
101254: PPUSH
101255: LD_VAR 0 8
101259: PUSH
101260: LD_INT 2
101262: ARRAY
101263: PPUSH
101264: CALL_OW 116
// attacking := true ;
101268: LD_ADDR_VAR 0 29
101272: PUSH
101273: LD_INT 1
101275: ST_TO_ADDR
// continue ;
101276: GO 98651
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101278: LD_VAR 0 4
101282: PUSH
101283: LD_VAR 0 7
101287: ARRAY
101288: PPUSH
101289: CALL_OW 265
101293: PUSH
101294: LD_INT 11
101296: EQUAL
101297: IFFALSE 101575
// begin k := 10 ;
101299: LD_ADDR_VAR 0 9
101303: PUSH
101304: LD_INT 10
101306: ST_TO_ADDR
// x := 0 ;
101307: LD_ADDR_VAR 0 10
101311: PUSH
101312: LD_INT 0
101314: ST_TO_ADDR
// if tmp < k then
101315: LD_VAR 0 14
101319: PUSH
101320: LD_VAR 0 9
101324: LESS
101325: IFFALSE 101337
// k := tmp ;
101327: LD_ADDR_VAR 0 9
101331: PUSH
101332: LD_VAR 0 14
101336: ST_TO_ADDR
// for j = k downto 1 do
101337: LD_ADDR_VAR 0 8
101341: PUSH
101342: DOUBLE
101343: LD_VAR 0 9
101347: INC
101348: ST_TO_ADDR
101349: LD_INT 1
101351: PUSH
101352: FOR_DOWNTO
101353: IFFALSE 101428
// begin if GetType ( tmp [ j ] ) = unit_human then
101355: LD_VAR 0 14
101359: PUSH
101360: LD_VAR 0 8
101364: ARRAY
101365: PPUSH
101366: CALL_OW 247
101370: PUSH
101371: LD_INT 1
101373: EQUAL
101374: IFFALSE 101426
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101376: LD_VAR 0 4
101380: PUSH
101381: LD_VAR 0 7
101385: ARRAY
101386: PPUSH
101387: LD_VAR 0 14
101391: PUSH
101392: LD_VAR 0 8
101396: ARRAY
101397: PPUSH
101398: CALL 96848 0 2
// x := tmp [ j ] ;
101402: LD_ADDR_VAR 0 10
101406: PUSH
101407: LD_VAR 0 14
101411: PUSH
101412: LD_VAR 0 8
101416: ARRAY
101417: ST_TO_ADDR
// attacking := true ;
101418: LD_ADDR_VAR 0 29
101422: PUSH
101423: LD_INT 1
101425: ST_TO_ADDR
// end ; end ;
101426: GO 101352
101428: POP
101429: POP
// if not x then
101430: LD_VAR 0 10
101434: NOT
101435: IFFALSE 101575
// begin attacking := true ;
101437: LD_ADDR_VAR 0 29
101441: PUSH
101442: LD_INT 1
101444: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101445: LD_VAR 0 4
101449: PUSH
101450: LD_VAR 0 7
101454: ARRAY
101455: PPUSH
101456: CALL_OW 250
101460: PPUSH
101461: LD_VAR 0 4
101465: PUSH
101466: LD_VAR 0 7
101470: ARRAY
101471: PPUSH
101472: CALL_OW 251
101476: PPUSH
101477: CALL_OW 546
101481: PUSH
101482: LD_INT 2
101484: ARRAY
101485: PUSH
101486: LD_VAR 0 14
101490: PUSH
101491: LD_INT 1
101493: ARRAY
101494: PPUSH
101495: CALL_OW 250
101499: PPUSH
101500: LD_VAR 0 14
101504: PUSH
101505: LD_INT 1
101507: ARRAY
101508: PPUSH
101509: CALL_OW 251
101513: PPUSH
101514: CALL_OW 546
101518: PUSH
101519: LD_INT 2
101521: ARRAY
101522: EQUAL
101523: IFFALSE 101551
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101525: LD_VAR 0 4
101529: PUSH
101530: LD_VAR 0 7
101534: ARRAY
101535: PPUSH
101536: LD_VAR 0 14
101540: PUSH
101541: LD_INT 1
101543: ARRAY
101544: PPUSH
101545: CALL 96848 0 2
101549: GO 101575
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101551: LD_VAR 0 4
101555: PUSH
101556: LD_VAR 0 7
101560: ARRAY
101561: PPUSH
101562: LD_VAR 0 14
101566: PUSH
101567: LD_INT 1
101569: ARRAY
101570: PPUSH
101571: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101575: LD_VAR 0 4
101579: PUSH
101580: LD_VAR 0 7
101584: ARRAY
101585: PPUSH
101586: CALL_OW 264
101590: PUSH
101591: LD_INT 29
101593: EQUAL
101594: IFFALSE 101960
// begin if WantsToAttack ( group [ i ] ) in bombed then
101596: LD_VAR 0 4
101600: PUSH
101601: LD_VAR 0 7
101605: ARRAY
101606: PPUSH
101607: CALL_OW 319
101611: PUSH
101612: LD_VAR 0 28
101616: IN
101617: IFFALSE 101621
// continue ;
101619: GO 98651
// k := 8 ;
101621: LD_ADDR_VAR 0 9
101625: PUSH
101626: LD_INT 8
101628: ST_TO_ADDR
// x := 0 ;
101629: LD_ADDR_VAR 0 10
101633: PUSH
101634: LD_INT 0
101636: ST_TO_ADDR
// if tmp < k then
101637: LD_VAR 0 14
101641: PUSH
101642: LD_VAR 0 9
101646: LESS
101647: IFFALSE 101659
// k := tmp ;
101649: LD_ADDR_VAR 0 9
101653: PUSH
101654: LD_VAR 0 14
101658: ST_TO_ADDR
// for j = 1 to k do
101659: LD_ADDR_VAR 0 8
101663: PUSH
101664: DOUBLE
101665: LD_INT 1
101667: DEC
101668: ST_TO_ADDR
101669: LD_VAR 0 9
101673: PUSH
101674: FOR_TO
101675: IFFALSE 101807
// begin if GetType ( tmp [ j ] ) = unit_building then
101677: LD_VAR 0 14
101681: PUSH
101682: LD_VAR 0 8
101686: ARRAY
101687: PPUSH
101688: CALL_OW 247
101692: PUSH
101693: LD_INT 3
101695: EQUAL
101696: IFFALSE 101805
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101698: LD_VAR 0 14
101702: PUSH
101703: LD_VAR 0 8
101707: ARRAY
101708: PUSH
101709: LD_VAR 0 28
101713: IN
101714: NOT
101715: PUSH
101716: LD_VAR 0 14
101720: PUSH
101721: LD_VAR 0 8
101725: ARRAY
101726: PPUSH
101727: CALL_OW 313
101731: AND
101732: IFFALSE 101805
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101734: LD_VAR 0 4
101738: PUSH
101739: LD_VAR 0 7
101743: ARRAY
101744: PPUSH
101745: LD_VAR 0 14
101749: PUSH
101750: LD_VAR 0 8
101754: ARRAY
101755: PPUSH
101756: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101760: LD_ADDR_VAR 0 28
101764: PUSH
101765: LD_VAR 0 28
101769: PPUSH
101770: LD_VAR 0 28
101774: PUSH
101775: LD_INT 1
101777: PLUS
101778: PPUSH
101779: LD_VAR 0 14
101783: PUSH
101784: LD_VAR 0 8
101788: ARRAY
101789: PPUSH
101790: CALL_OW 1
101794: ST_TO_ADDR
// attacking := true ;
101795: LD_ADDR_VAR 0 29
101799: PUSH
101800: LD_INT 1
101802: ST_TO_ADDR
// break ;
101803: GO 101807
// end ; end ;
101805: GO 101674
101807: POP
101808: POP
// if not attacking and f_attack_depot then
101809: LD_VAR 0 29
101813: NOT
101814: PUSH
101815: LD_VAR 0 25
101819: AND
101820: IFFALSE 101915
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101822: LD_ADDR_VAR 0 13
101826: PUSH
101827: LD_VAR 0 14
101831: PPUSH
101832: LD_INT 2
101834: PUSH
101835: LD_INT 30
101837: PUSH
101838: LD_INT 0
101840: PUSH
101841: EMPTY
101842: LIST
101843: LIST
101844: PUSH
101845: LD_INT 30
101847: PUSH
101848: LD_INT 1
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: PUSH
101855: EMPTY
101856: LIST
101857: LIST
101858: LIST
101859: PPUSH
101860: CALL_OW 72
101864: ST_TO_ADDR
// if z then
101865: LD_VAR 0 13
101869: IFFALSE 101915
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101871: LD_VAR 0 4
101875: PUSH
101876: LD_VAR 0 7
101880: ARRAY
101881: PPUSH
101882: LD_VAR 0 13
101886: PPUSH
101887: LD_VAR 0 4
101891: PUSH
101892: LD_VAR 0 7
101896: ARRAY
101897: PPUSH
101898: CALL_OW 74
101902: PPUSH
101903: CALL_OW 115
// attacking := true ;
101907: LD_ADDR_VAR 0 29
101911: PUSH
101912: LD_INT 1
101914: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101915: LD_VAR 0 4
101919: PUSH
101920: LD_VAR 0 7
101924: ARRAY
101925: PPUSH
101926: CALL_OW 256
101930: PUSH
101931: LD_INT 500
101933: LESS
101934: IFFALSE 101960
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101936: LD_VAR 0 4
101940: PUSH
101941: LD_VAR 0 7
101945: ARRAY
101946: PPUSH
101947: LD_VAR 0 14
101951: PUSH
101952: LD_INT 1
101954: ARRAY
101955: PPUSH
101956: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
101960: LD_VAR 0 4
101964: PUSH
101965: LD_VAR 0 7
101969: ARRAY
101970: PPUSH
101971: CALL_OW 264
101975: PUSH
101976: LD_INT 49
101978: EQUAL
101979: IFFALSE 102100
// begin if not HasTask ( group [ i ] ) then
101981: LD_VAR 0 4
101985: PUSH
101986: LD_VAR 0 7
101990: ARRAY
101991: PPUSH
101992: CALL_OW 314
101996: NOT
101997: IFFALSE 102100
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
101999: LD_ADDR_VAR 0 9
102003: PUSH
102004: LD_INT 81
102006: PUSH
102007: LD_VAR 0 4
102011: PUSH
102012: LD_VAR 0 7
102016: ARRAY
102017: PPUSH
102018: CALL_OW 255
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: PPUSH
102027: CALL_OW 69
102031: PPUSH
102032: LD_VAR 0 4
102036: PUSH
102037: LD_VAR 0 7
102041: ARRAY
102042: PPUSH
102043: CALL_OW 74
102047: ST_TO_ADDR
// if k then
102048: LD_VAR 0 9
102052: IFFALSE 102100
// if GetDistUnits ( group [ i ] , k ) > 10 then
102054: LD_VAR 0 4
102058: PUSH
102059: LD_VAR 0 7
102063: ARRAY
102064: PPUSH
102065: LD_VAR 0 9
102069: PPUSH
102070: CALL_OW 296
102074: PUSH
102075: LD_INT 10
102077: GREATER
102078: IFFALSE 102100
// ComMoveUnit ( group [ i ] , k ) ;
102080: LD_VAR 0 4
102084: PUSH
102085: LD_VAR 0 7
102089: ARRAY
102090: PPUSH
102091: LD_VAR 0 9
102095: PPUSH
102096: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102100: LD_VAR 0 4
102104: PUSH
102105: LD_VAR 0 7
102109: ARRAY
102110: PPUSH
102111: CALL_OW 256
102115: PUSH
102116: LD_INT 250
102118: LESS
102119: PUSH
102120: LD_VAR 0 4
102124: PUSH
102125: LD_VAR 0 7
102129: ARRAY
102130: PUSH
102131: LD_INT 21
102133: PUSH
102134: LD_INT 2
102136: PUSH
102137: EMPTY
102138: LIST
102139: LIST
102140: PUSH
102141: LD_INT 23
102143: PUSH
102144: LD_INT 2
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: PUSH
102151: EMPTY
102152: LIST
102153: LIST
102154: PPUSH
102155: CALL_OW 69
102159: IN
102160: AND
102161: IFFALSE 102286
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102163: LD_ADDR_VAR 0 9
102167: PUSH
102168: LD_OWVAR 3
102172: PUSH
102173: LD_VAR 0 4
102177: PUSH
102178: LD_VAR 0 7
102182: ARRAY
102183: DIFF
102184: PPUSH
102185: LD_VAR 0 4
102189: PUSH
102190: LD_VAR 0 7
102194: ARRAY
102195: PPUSH
102196: CALL_OW 74
102200: ST_TO_ADDR
// if not k then
102201: LD_VAR 0 9
102205: NOT
102206: IFFALSE 102210
// continue ;
102208: GO 98651
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102210: LD_VAR 0 9
102214: PUSH
102215: LD_INT 81
102217: PUSH
102218: LD_VAR 0 4
102222: PUSH
102223: LD_VAR 0 7
102227: ARRAY
102228: PPUSH
102229: CALL_OW 255
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: PPUSH
102238: CALL_OW 69
102242: IN
102243: PUSH
102244: LD_VAR 0 9
102248: PPUSH
102249: LD_VAR 0 4
102253: PUSH
102254: LD_VAR 0 7
102258: ARRAY
102259: PPUSH
102260: CALL_OW 296
102264: PUSH
102265: LD_INT 5
102267: LESS
102268: AND
102269: IFFALSE 102286
// ComAutodestruct ( group [ i ] ) ;
102271: LD_VAR 0 4
102275: PUSH
102276: LD_VAR 0 7
102280: ARRAY
102281: PPUSH
102282: CALL 96746 0 1
// end ; if f_attack_depot then
102286: LD_VAR 0 25
102290: IFFALSE 102402
// begin k := 6 ;
102292: LD_ADDR_VAR 0 9
102296: PUSH
102297: LD_INT 6
102299: ST_TO_ADDR
// if tmp < k then
102300: LD_VAR 0 14
102304: PUSH
102305: LD_VAR 0 9
102309: LESS
102310: IFFALSE 102322
// k := tmp ;
102312: LD_ADDR_VAR 0 9
102316: PUSH
102317: LD_VAR 0 14
102321: ST_TO_ADDR
// for j = 1 to k do
102322: LD_ADDR_VAR 0 8
102326: PUSH
102327: DOUBLE
102328: LD_INT 1
102330: DEC
102331: ST_TO_ADDR
102332: LD_VAR 0 9
102336: PUSH
102337: FOR_TO
102338: IFFALSE 102400
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102340: LD_VAR 0 8
102344: PPUSH
102345: CALL_OW 266
102349: PUSH
102350: LD_INT 0
102352: PUSH
102353: LD_INT 1
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: IN
102360: IFFALSE 102398
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102362: LD_VAR 0 4
102366: PUSH
102367: LD_VAR 0 7
102371: ARRAY
102372: PPUSH
102373: LD_VAR 0 14
102377: PUSH
102378: LD_VAR 0 8
102382: ARRAY
102383: PPUSH
102384: CALL_OW 115
// attacking := true ;
102388: LD_ADDR_VAR 0 29
102392: PUSH
102393: LD_INT 1
102395: ST_TO_ADDR
// break ;
102396: GO 102400
// end ;
102398: GO 102337
102400: POP
102401: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102402: LD_VAR 0 4
102406: PUSH
102407: LD_VAR 0 7
102411: ARRAY
102412: PPUSH
102413: CALL_OW 302
102417: PUSH
102418: LD_VAR 0 29
102422: NOT
102423: AND
102424: IFFALSE 102746
// begin if GetTag ( group [ i ] ) = 71 then
102426: LD_VAR 0 4
102430: PUSH
102431: LD_VAR 0 7
102435: ARRAY
102436: PPUSH
102437: CALL_OW 110
102441: PUSH
102442: LD_INT 71
102444: EQUAL
102445: IFFALSE 102486
// begin if HasTask ( group [ i ] ) then
102447: LD_VAR 0 4
102451: PUSH
102452: LD_VAR 0 7
102456: ARRAY
102457: PPUSH
102458: CALL_OW 314
102462: IFFALSE 102468
// continue else
102464: GO 98651
102466: GO 102486
// SetTag ( group [ i ] , 0 ) ;
102468: LD_VAR 0 4
102472: PUSH
102473: LD_VAR 0 7
102477: ARRAY
102478: PPUSH
102479: LD_INT 0
102481: PPUSH
102482: CALL_OW 109
// end ; k := 8 ;
102486: LD_ADDR_VAR 0 9
102490: PUSH
102491: LD_INT 8
102493: ST_TO_ADDR
// x := 0 ;
102494: LD_ADDR_VAR 0 10
102498: PUSH
102499: LD_INT 0
102501: ST_TO_ADDR
// if tmp < k then
102502: LD_VAR 0 14
102506: PUSH
102507: LD_VAR 0 9
102511: LESS
102512: IFFALSE 102524
// k := tmp ;
102514: LD_ADDR_VAR 0 9
102518: PUSH
102519: LD_VAR 0 14
102523: ST_TO_ADDR
// for j = 1 to k do
102524: LD_ADDR_VAR 0 8
102528: PUSH
102529: DOUBLE
102530: LD_INT 1
102532: DEC
102533: ST_TO_ADDR
102534: LD_VAR 0 9
102538: PUSH
102539: FOR_TO
102540: IFFALSE 102638
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102542: LD_VAR 0 14
102546: PUSH
102547: LD_VAR 0 8
102551: ARRAY
102552: PPUSH
102553: CALL_OW 247
102557: PUSH
102558: LD_INT 1
102560: EQUAL
102561: PUSH
102562: LD_VAR 0 14
102566: PUSH
102567: LD_VAR 0 8
102571: ARRAY
102572: PPUSH
102573: CALL_OW 256
102577: PUSH
102578: LD_INT 250
102580: LESS
102581: PUSH
102582: LD_VAR 0 20
102586: AND
102587: PUSH
102588: LD_VAR 0 20
102592: NOT
102593: PUSH
102594: LD_VAR 0 14
102598: PUSH
102599: LD_VAR 0 8
102603: ARRAY
102604: PPUSH
102605: CALL_OW 256
102609: PUSH
102610: LD_INT 250
102612: GREATEREQUAL
102613: AND
102614: OR
102615: AND
102616: IFFALSE 102636
// begin x := tmp [ j ] ;
102618: LD_ADDR_VAR 0 10
102622: PUSH
102623: LD_VAR 0 14
102627: PUSH
102628: LD_VAR 0 8
102632: ARRAY
102633: ST_TO_ADDR
// break ;
102634: GO 102638
// end ;
102636: GO 102539
102638: POP
102639: POP
// if x then
102640: LD_VAR 0 10
102644: IFFALSE 102668
// ComAttackUnit ( group [ i ] , x ) else
102646: LD_VAR 0 4
102650: PUSH
102651: LD_VAR 0 7
102655: ARRAY
102656: PPUSH
102657: LD_VAR 0 10
102661: PPUSH
102662: CALL_OW 115
102666: GO 102692
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102668: LD_VAR 0 4
102672: PUSH
102673: LD_VAR 0 7
102677: ARRAY
102678: PPUSH
102679: LD_VAR 0 14
102683: PUSH
102684: LD_INT 1
102686: ARRAY
102687: PPUSH
102688: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102692: LD_VAR 0 4
102696: PUSH
102697: LD_VAR 0 7
102701: ARRAY
102702: PPUSH
102703: CALL_OW 314
102707: NOT
102708: IFFALSE 102746
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102710: LD_VAR 0 4
102714: PUSH
102715: LD_VAR 0 7
102719: ARRAY
102720: PPUSH
102721: LD_VAR 0 14
102725: PPUSH
102726: LD_VAR 0 4
102730: PUSH
102731: LD_VAR 0 7
102735: ARRAY
102736: PPUSH
102737: CALL_OW 74
102741: PPUSH
102742: CALL_OW 115
// end ; end ; end ;
102746: GO 98651
102748: POP
102749: POP
// wait ( 0 0$1 ) ;
102750: LD_INT 35
102752: PPUSH
102753: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102757: LD_VAR 0 4
102761: PUSH
102762: EMPTY
102763: EQUAL
102764: PUSH
102765: LD_INT 81
102767: PUSH
102768: LD_VAR 0 35
102772: PUSH
102773: EMPTY
102774: LIST
102775: LIST
102776: PPUSH
102777: CALL_OW 69
102781: NOT
102782: OR
102783: IFFALSE 98636
// end ;
102785: LD_VAR 0 2
102789: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102790: LD_INT 0
102792: PPUSH
102793: PPUSH
102794: PPUSH
102795: PPUSH
// if not base_units then
102796: LD_VAR 0 1
102800: NOT
102801: IFFALSE 102805
// exit ;
102803: GO 102892
// result := false ;
102805: LD_ADDR_VAR 0 2
102809: PUSH
102810: LD_INT 0
102812: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102813: LD_ADDR_VAR 0 5
102817: PUSH
102818: LD_VAR 0 1
102822: PPUSH
102823: LD_INT 21
102825: PUSH
102826: LD_INT 3
102828: PUSH
102829: EMPTY
102830: LIST
102831: LIST
102832: PPUSH
102833: CALL_OW 72
102837: ST_TO_ADDR
// if not tmp then
102838: LD_VAR 0 5
102842: NOT
102843: IFFALSE 102847
// exit ;
102845: GO 102892
// for i in tmp do
102847: LD_ADDR_VAR 0 3
102851: PUSH
102852: LD_VAR 0 5
102856: PUSH
102857: FOR_IN
102858: IFFALSE 102890
// begin result := EnemyInRange ( i , 22 ) ;
102860: LD_ADDR_VAR 0 2
102864: PUSH
102865: LD_VAR 0 3
102869: PPUSH
102870: LD_INT 22
102872: PPUSH
102873: CALL 96429 0 2
102877: ST_TO_ADDR
// if result then
102878: LD_VAR 0 2
102882: IFFALSE 102888
// exit ;
102884: POP
102885: POP
102886: GO 102892
// end ;
102888: GO 102857
102890: POP
102891: POP
// end ;
102892: LD_VAR 0 2
102896: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
102897: LD_INT 0
102899: PPUSH
102900: PPUSH
// if not units then
102901: LD_VAR 0 1
102905: NOT
102906: IFFALSE 102910
// exit ;
102908: GO 102980
// result := [ ] ;
102910: LD_ADDR_VAR 0 3
102914: PUSH
102915: EMPTY
102916: ST_TO_ADDR
// for i in units do
102917: LD_ADDR_VAR 0 4
102921: PUSH
102922: LD_VAR 0 1
102926: PUSH
102927: FOR_IN
102928: IFFALSE 102978
// if GetTag ( i ) = tag then
102930: LD_VAR 0 4
102934: PPUSH
102935: CALL_OW 110
102939: PUSH
102940: LD_VAR 0 2
102944: EQUAL
102945: IFFALSE 102976
// result := Insert ( result , result + 1 , i ) ;
102947: LD_ADDR_VAR 0 3
102951: PUSH
102952: LD_VAR 0 3
102956: PPUSH
102957: LD_VAR 0 3
102961: PUSH
102962: LD_INT 1
102964: PLUS
102965: PPUSH
102966: LD_VAR 0 4
102970: PPUSH
102971: CALL_OW 2
102975: ST_TO_ADDR
102976: GO 102927
102978: POP
102979: POP
// end ;
102980: LD_VAR 0 3
102984: RET
// export function IsDriver ( un ) ; begin
102985: LD_INT 0
102987: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102988: LD_ADDR_VAR 0 2
102992: PUSH
102993: LD_VAR 0 1
102997: PUSH
102998: LD_INT 55
103000: PUSH
103001: EMPTY
103002: LIST
103003: PPUSH
103004: CALL_OW 69
103008: IN
103009: ST_TO_ADDR
// end ;
103010: LD_VAR 0 2
103014: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103015: LD_INT 0
103017: PPUSH
103018: PPUSH
// list := [ ] ;
103019: LD_ADDR_VAR 0 5
103023: PUSH
103024: EMPTY
103025: ST_TO_ADDR
// case d of 0 :
103026: LD_VAR 0 3
103030: PUSH
103031: LD_INT 0
103033: DOUBLE
103034: EQUAL
103035: IFTRUE 103039
103037: GO 103172
103039: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103040: LD_ADDR_VAR 0 5
103044: PUSH
103045: LD_VAR 0 1
103049: PUSH
103050: LD_INT 4
103052: MINUS
103053: PUSH
103054: LD_VAR 0 2
103058: PUSH
103059: LD_INT 4
103061: MINUS
103062: PUSH
103063: LD_INT 2
103065: PUSH
103066: EMPTY
103067: LIST
103068: LIST
103069: LIST
103070: PUSH
103071: LD_VAR 0 1
103075: PUSH
103076: LD_INT 3
103078: MINUS
103079: PUSH
103080: LD_VAR 0 2
103084: PUSH
103085: LD_INT 1
103087: PUSH
103088: EMPTY
103089: LIST
103090: LIST
103091: LIST
103092: PUSH
103093: LD_VAR 0 1
103097: PUSH
103098: LD_INT 4
103100: PLUS
103101: PUSH
103102: LD_VAR 0 2
103106: PUSH
103107: LD_INT 4
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: LIST
103114: PUSH
103115: LD_VAR 0 1
103119: PUSH
103120: LD_INT 3
103122: PLUS
103123: PUSH
103124: LD_VAR 0 2
103128: PUSH
103129: LD_INT 3
103131: PLUS
103132: PUSH
103133: LD_INT 5
103135: PUSH
103136: EMPTY
103137: LIST
103138: LIST
103139: LIST
103140: PUSH
103141: LD_VAR 0 1
103145: PUSH
103146: LD_VAR 0 2
103150: PUSH
103151: LD_INT 4
103153: PLUS
103154: PUSH
103155: LD_INT 0
103157: PUSH
103158: EMPTY
103159: LIST
103160: LIST
103161: LIST
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: ST_TO_ADDR
// end ; 1 :
103170: GO 103870
103172: LD_INT 1
103174: DOUBLE
103175: EQUAL
103176: IFTRUE 103180
103178: GO 103313
103180: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103181: LD_ADDR_VAR 0 5
103185: PUSH
103186: LD_VAR 0 1
103190: PUSH
103191: LD_VAR 0 2
103195: PUSH
103196: LD_INT 4
103198: MINUS
103199: PUSH
103200: LD_INT 3
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: LIST
103207: PUSH
103208: LD_VAR 0 1
103212: PUSH
103213: LD_INT 3
103215: MINUS
103216: PUSH
103217: LD_VAR 0 2
103221: PUSH
103222: LD_INT 3
103224: MINUS
103225: PUSH
103226: LD_INT 2
103228: PUSH
103229: EMPTY
103230: LIST
103231: LIST
103232: LIST
103233: PUSH
103234: LD_VAR 0 1
103238: PUSH
103239: LD_INT 4
103241: MINUS
103242: PUSH
103243: LD_VAR 0 2
103247: PUSH
103248: LD_INT 1
103250: PUSH
103251: EMPTY
103252: LIST
103253: LIST
103254: LIST
103255: PUSH
103256: LD_VAR 0 1
103260: PUSH
103261: LD_VAR 0 2
103265: PUSH
103266: LD_INT 3
103268: PLUS
103269: PUSH
103270: LD_INT 0
103272: PUSH
103273: EMPTY
103274: LIST
103275: LIST
103276: LIST
103277: PUSH
103278: LD_VAR 0 1
103282: PUSH
103283: LD_INT 4
103285: PLUS
103286: PUSH
103287: LD_VAR 0 2
103291: PUSH
103292: LD_INT 4
103294: PLUS
103295: PUSH
103296: LD_INT 5
103298: PUSH
103299: EMPTY
103300: LIST
103301: LIST
103302: LIST
103303: PUSH
103304: EMPTY
103305: LIST
103306: LIST
103307: LIST
103308: LIST
103309: LIST
103310: ST_TO_ADDR
// end ; 2 :
103311: GO 103870
103313: LD_INT 2
103315: DOUBLE
103316: EQUAL
103317: IFTRUE 103321
103319: GO 103450
103321: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103322: LD_ADDR_VAR 0 5
103326: PUSH
103327: LD_VAR 0 1
103331: PUSH
103332: LD_VAR 0 2
103336: PUSH
103337: LD_INT 3
103339: MINUS
103340: PUSH
103341: LD_INT 3
103343: PUSH
103344: EMPTY
103345: LIST
103346: LIST
103347: LIST
103348: PUSH
103349: LD_VAR 0 1
103353: PUSH
103354: LD_INT 4
103356: PLUS
103357: PUSH
103358: LD_VAR 0 2
103362: PUSH
103363: LD_INT 4
103365: PUSH
103366: EMPTY
103367: LIST
103368: LIST
103369: LIST
103370: PUSH
103371: LD_VAR 0 1
103375: PUSH
103376: LD_VAR 0 2
103380: PUSH
103381: LD_INT 4
103383: PLUS
103384: PUSH
103385: LD_INT 0
103387: PUSH
103388: EMPTY
103389: LIST
103390: LIST
103391: LIST
103392: PUSH
103393: LD_VAR 0 1
103397: PUSH
103398: LD_INT 3
103400: MINUS
103401: PUSH
103402: LD_VAR 0 2
103406: PUSH
103407: LD_INT 1
103409: PUSH
103410: EMPTY
103411: LIST
103412: LIST
103413: LIST
103414: PUSH
103415: LD_VAR 0 1
103419: PUSH
103420: LD_INT 4
103422: MINUS
103423: PUSH
103424: LD_VAR 0 2
103428: PUSH
103429: LD_INT 4
103431: MINUS
103432: PUSH
103433: LD_INT 2
103435: PUSH
103436: EMPTY
103437: LIST
103438: LIST
103439: LIST
103440: PUSH
103441: EMPTY
103442: LIST
103443: LIST
103444: LIST
103445: LIST
103446: LIST
103447: ST_TO_ADDR
// end ; 3 :
103448: GO 103870
103450: LD_INT 3
103452: DOUBLE
103453: EQUAL
103454: IFTRUE 103458
103456: GO 103591
103458: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103459: LD_ADDR_VAR 0 5
103463: PUSH
103464: LD_VAR 0 1
103468: PUSH
103469: LD_INT 3
103471: PLUS
103472: PUSH
103473: LD_VAR 0 2
103477: PUSH
103478: LD_INT 4
103480: PUSH
103481: EMPTY
103482: LIST
103483: LIST
103484: LIST
103485: PUSH
103486: LD_VAR 0 1
103490: PUSH
103491: LD_INT 4
103493: PLUS
103494: PUSH
103495: LD_VAR 0 2
103499: PUSH
103500: LD_INT 4
103502: PLUS
103503: PUSH
103504: LD_INT 5
103506: PUSH
103507: EMPTY
103508: LIST
103509: LIST
103510: LIST
103511: PUSH
103512: LD_VAR 0 1
103516: PUSH
103517: LD_INT 4
103519: MINUS
103520: PUSH
103521: LD_VAR 0 2
103525: PUSH
103526: LD_INT 1
103528: PUSH
103529: EMPTY
103530: LIST
103531: LIST
103532: LIST
103533: PUSH
103534: LD_VAR 0 1
103538: PUSH
103539: LD_VAR 0 2
103543: PUSH
103544: LD_INT 4
103546: MINUS
103547: PUSH
103548: LD_INT 3
103550: PUSH
103551: EMPTY
103552: LIST
103553: LIST
103554: LIST
103555: PUSH
103556: LD_VAR 0 1
103560: PUSH
103561: LD_INT 3
103563: MINUS
103564: PUSH
103565: LD_VAR 0 2
103569: PUSH
103570: LD_INT 3
103572: MINUS
103573: PUSH
103574: LD_INT 2
103576: PUSH
103577: EMPTY
103578: LIST
103579: LIST
103580: LIST
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: LIST
103586: LIST
103587: LIST
103588: ST_TO_ADDR
// end ; 4 :
103589: GO 103870
103591: LD_INT 4
103593: DOUBLE
103594: EQUAL
103595: IFTRUE 103599
103597: GO 103732
103599: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103600: LD_ADDR_VAR 0 5
103604: PUSH
103605: LD_VAR 0 1
103609: PUSH
103610: LD_VAR 0 2
103614: PUSH
103615: LD_INT 4
103617: PLUS
103618: PUSH
103619: LD_INT 0
103621: PUSH
103622: EMPTY
103623: LIST
103624: LIST
103625: LIST
103626: PUSH
103627: LD_VAR 0 1
103631: PUSH
103632: LD_INT 3
103634: PLUS
103635: PUSH
103636: LD_VAR 0 2
103640: PUSH
103641: LD_INT 3
103643: PLUS
103644: PUSH
103645: LD_INT 5
103647: PUSH
103648: EMPTY
103649: LIST
103650: LIST
103651: LIST
103652: PUSH
103653: LD_VAR 0 1
103657: PUSH
103658: LD_INT 4
103660: PLUS
103661: PUSH
103662: LD_VAR 0 2
103666: PUSH
103667: LD_INT 4
103669: PUSH
103670: EMPTY
103671: LIST
103672: LIST
103673: LIST
103674: PUSH
103675: LD_VAR 0 1
103679: PUSH
103680: LD_VAR 0 2
103684: PUSH
103685: LD_INT 3
103687: MINUS
103688: PUSH
103689: LD_INT 3
103691: PUSH
103692: EMPTY
103693: LIST
103694: LIST
103695: LIST
103696: PUSH
103697: LD_VAR 0 1
103701: PUSH
103702: LD_INT 4
103704: MINUS
103705: PUSH
103706: LD_VAR 0 2
103710: PUSH
103711: LD_INT 4
103713: MINUS
103714: PUSH
103715: LD_INT 2
103717: PUSH
103718: EMPTY
103719: LIST
103720: LIST
103721: LIST
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: LIST
103727: LIST
103728: LIST
103729: ST_TO_ADDR
// end ; 5 :
103730: GO 103870
103732: LD_INT 5
103734: DOUBLE
103735: EQUAL
103736: IFTRUE 103740
103738: GO 103869
103740: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103741: LD_ADDR_VAR 0 5
103745: PUSH
103746: LD_VAR 0 1
103750: PUSH
103751: LD_INT 4
103753: MINUS
103754: PUSH
103755: LD_VAR 0 2
103759: PUSH
103760: LD_INT 1
103762: PUSH
103763: EMPTY
103764: LIST
103765: LIST
103766: LIST
103767: PUSH
103768: LD_VAR 0 1
103772: PUSH
103773: LD_VAR 0 2
103777: PUSH
103778: LD_INT 4
103780: MINUS
103781: PUSH
103782: LD_INT 3
103784: PUSH
103785: EMPTY
103786: LIST
103787: LIST
103788: LIST
103789: PUSH
103790: LD_VAR 0 1
103794: PUSH
103795: LD_INT 4
103797: PLUS
103798: PUSH
103799: LD_VAR 0 2
103803: PUSH
103804: LD_INT 4
103806: PLUS
103807: PUSH
103808: LD_INT 5
103810: PUSH
103811: EMPTY
103812: LIST
103813: LIST
103814: LIST
103815: PUSH
103816: LD_VAR 0 1
103820: PUSH
103821: LD_INT 3
103823: PLUS
103824: PUSH
103825: LD_VAR 0 2
103829: PUSH
103830: LD_INT 4
103832: PUSH
103833: EMPTY
103834: LIST
103835: LIST
103836: LIST
103837: PUSH
103838: LD_VAR 0 1
103842: PUSH
103843: LD_VAR 0 2
103847: PUSH
103848: LD_INT 3
103850: PLUS
103851: PUSH
103852: LD_INT 0
103854: PUSH
103855: EMPTY
103856: LIST
103857: LIST
103858: LIST
103859: PUSH
103860: EMPTY
103861: LIST
103862: LIST
103863: LIST
103864: LIST
103865: LIST
103866: ST_TO_ADDR
// end ; end ;
103867: GO 103870
103869: POP
// result := list ;
103870: LD_ADDR_VAR 0 4
103874: PUSH
103875: LD_VAR 0 5
103879: ST_TO_ADDR
// end ;
103880: LD_VAR 0 4
103884: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103885: LD_INT 0
103887: PPUSH
103888: PPUSH
103889: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103890: LD_VAR 0 1
103894: NOT
103895: PUSH
103896: LD_VAR 0 2
103900: PUSH
103901: LD_INT 1
103903: PUSH
103904: LD_INT 2
103906: PUSH
103907: LD_INT 3
103909: PUSH
103910: LD_INT 4
103912: PUSH
103913: EMPTY
103914: LIST
103915: LIST
103916: LIST
103917: LIST
103918: IN
103919: NOT
103920: OR
103921: IFFALSE 103925
// exit ;
103923: GO 104017
// tmp := [ ] ;
103925: LD_ADDR_VAR 0 5
103929: PUSH
103930: EMPTY
103931: ST_TO_ADDR
// for i in units do
103932: LD_ADDR_VAR 0 4
103936: PUSH
103937: LD_VAR 0 1
103941: PUSH
103942: FOR_IN
103943: IFFALSE 103986
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103945: LD_ADDR_VAR 0 5
103949: PUSH
103950: LD_VAR 0 5
103954: PPUSH
103955: LD_VAR 0 5
103959: PUSH
103960: LD_INT 1
103962: PLUS
103963: PPUSH
103964: LD_VAR 0 4
103968: PPUSH
103969: LD_VAR 0 2
103973: PPUSH
103974: CALL_OW 259
103978: PPUSH
103979: CALL_OW 2
103983: ST_TO_ADDR
103984: GO 103942
103986: POP
103987: POP
// if not tmp then
103988: LD_VAR 0 5
103992: NOT
103993: IFFALSE 103997
// exit ;
103995: GO 104017
// result := SortListByListDesc ( units , tmp ) ;
103997: LD_ADDR_VAR 0 3
104001: PUSH
104002: LD_VAR 0 1
104006: PPUSH
104007: LD_VAR 0 5
104011: PPUSH
104012: CALL_OW 77
104016: ST_TO_ADDR
// end ;
104017: LD_VAR 0 3
104021: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104022: LD_INT 0
104024: PPUSH
104025: PPUSH
104026: PPUSH
// x := GetX ( building ) ;
104027: LD_ADDR_VAR 0 4
104031: PUSH
104032: LD_VAR 0 2
104036: PPUSH
104037: CALL_OW 250
104041: ST_TO_ADDR
// y := GetY ( building ) ;
104042: LD_ADDR_VAR 0 5
104046: PUSH
104047: LD_VAR 0 2
104051: PPUSH
104052: CALL_OW 251
104056: ST_TO_ADDR
// if GetTaskList ( unit ) then
104057: LD_VAR 0 1
104061: PPUSH
104062: CALL_OW 437
104066: IFFALSE 104161
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104068: LD_STRING e
104070: PUSH
104071: LD_VAR 0 1
104075: PPUSH
104076: CALL_OW 437
104080: PUSH
104081: LD_INT 1
104083: ARRAY
104084: PUSH
104085: LD_INT 1
104087: ARRAY
104088: EQUAL
104089: PUSH
104090: LD_VAR 0 4
104094: PUSH
104095: LD_VAR 0 1
104099: PPUSH
104100: CALL_OW 437
104104: PUSH
104105: LD_INT 1
104107: ARRAY
104108: PUSH
104109: LD_INT 2
104111: ARRAY
104112: EQUAL
104113: AND
104114: PUSH
104115: LD_VAR 0 5
104119: PUSH
104120: LD_VAR 0 1
104124: PPUSH
104125: CALL_OW 437
104129: PUSH
104130: LD_INT 1
104132: ARRAY
104133: PUSH
104134: LD_INT 3
104136: ARRAY
104137: EQUAL
104138: AND
104139: IFFALSE 104151
// result := true else
104141: LD_ADDR_VAR 0 3
104145: PUSH
104146: LD_INT 1
104148: ST_TO_ADDR
104149: GO 104159
// result := false ;
104151: LD_ADDR_VAR 0 3
104155: PUSH
104156: LD_INT 0
104158: ST_TO_ADDR
// end else
104159: GO 104169
// result := false ;
104161: LD_ADDR_VAR 0 3
104165: PUSH
104166: LD_INT 0
104168: ST_TO_ADDR
// end ;
104169: LD_VAR 0 3
104173: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104174: LD_INT 0
104176: PPUSH
104177: PPUSH
104178: PPUSH
104179: PPUSH
// if not unit or not area then
104180: LD_VAR 0 1
104184: NOT
104185: PUSH
104186: LD_VAR 0 2
104190: NOT
104191: OR
104192: IFFALSE 104196
// exit ;
104194: GO 104360
// tmp := AreaToList ( area , i ) ;
104196: LD_ADDR_VAR 0 6
104200: PUSH
104201: LD_VAR 0 2
104205: PPUSH
104206: LD_VAR 0 5
104210: PPUSH
104211: CALL_OW 517
104215: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104216: LD_ADDR_VAR 0 5
104220: PUSH
104221: DOUBLE
104222: LD_INT 1
104224: DEC
104225: ST_TO_ADDR
104226: LD_VAR 0 6
104230: PUSH
104231: LD_INT 1
104233: ARRAY
104234: PUSH
104235: FOR_TO
104236: IFFALSE 104358
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104238: LD_ADDR_VAR 0 7
104242: PUSH
104243: LD_VAR 0 6
104247: PUSH
104248: LD_INT 1
104250: ARRAY
104251: PUSH
104252: LD_VAR 0 5
104256: ARRAY
104257: PUSH
104258: LD_VAR 0 6
104262: PUSH
104263: LD_INT 2
104265: ARRAY
104266: PUSH
104267: LD_VAR 0 5
104271: ARRAY
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104277: LD_VAR 0 7
104281: PUSH
104282: LD_INT 1
104284: ARRAY
104285: PPUSH
104286: LD_VAR 0 7
104290: PUSH
104291: LD_INT 2
104293: ARRAY
104294: PPUSH
104295: CALL_OW 428
104299: PUSH
104300: LD_INT 0
104302: EQUAL
104303: IFFALSE 104356
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104305: LD_VAR 0 1
104309: PPUSH
104310: LD_VAR 0 7
104314: PUSH
104315: LD_INT 1
104317: ARRAY
104318: PPUSH
104319: LD_VAR 0 7
104323: PUSH
104324: LD_INT 2
104326: ARRAY
104327: PPUSH
104328: LD_VAR 0 3
104332: PPUSH
104333: CALL_OW 48
// result := IsPlaced ( unit ) ;
104337: LD_ADDR_VAR 0 4
104341: PUSH
104342: LD_VAR 0 1
104346: PPUSH
104347: CALL_OW 305
104351: ST_TO_ADDR
// exit ;
104352: POP
104353: POP
104354: GO 104360
// end ; end ;
104356: GO 104235
104358: POP
104359: POP
// end ;
104360: LD_VAR 0 4
104364: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104365: LD_INT 0
104367: PPUSH
104368: PPUSH
104369: PPUSH
// if not side or side > 8 then
104370: LD_VAR 0 1
104374: NOT
104375: PUSH
104376: LD_VAR 0 1
104380: PUSH
104381: LD_INT 8
104383: GREATER
104384: OR
104385: IFFALSE 104389
// exit ;
104387: GO 104576
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104389: LD_ADDR_VAR 0 4
104393: PUSH
104394: LD_INT 22
104396: PUSH
104397: LD_VAR 0 1
104401: PUSH
104402: EMPTY
104403: LIST
104404: LIST
104405: PUSH
104406: LD_INT 21
104408: PUSH
104409: LD_INT 3
104411: PUSH
104412: EMPTY
104413: LIST
104414: LIST
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: PPUSH
104420: CALL_OW 69
104424: ST_TO_ADDR
// if not tmp then
104425: LD_VAR 0 4
104429: NOT
104430: IFFALSE 104434
// exit ;
104432: GO 104576
// enable_addtolog := true ;
104434: LD_ADDR_OWVAR 81
104438: PUSH
104439: LD_INT 1
104441: ST_TO_ADDR
// AddToLog ( [ ) ;
104442: LD_STRING [
104444: PPUSH
104445: CALL_OW 561
// for i in tmp do
104449: LD_ADDR_VAR 0 3
104453: PUSH
104454: LD_VAR 0 4
104458: PUSH
104459: FOR_IN
104460: IFFALSE 104567
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104462: LD_STRING [
104464: PUSH
104465: LD_VAR 0 3
104469: PPUSH
104470: CALL_OW 266
104474: STR
104475: PUSH
104476: LD_STRING , 
104478: STR
104479: PUSH
104480: LD_VAR 0 3
104484: PPUSH
104485: CALL_OW 250
104489: STR
104490: PUSH
104491: LD_STRING , 
104493: STR
104494: PUSH
104495: LD_VAR 0 3
104499: PPUSH
104500: CALL_OW 251
104504: STR
104505: PUSH
104506: LD_STRING , 
104508: STR
104509: PUSH
104510: LD_VAR 0 3
104514: PPUSH
104515: CALL_OW 254
104519: STR
104520: PUSH
104521: LD_STRING , 
104523: STR
104524: PUSH
104525: LD_VAR 0 3
104529: PPUSH
104530: LD_INT 1
104532: PPUSH
104533: CALL_OW 268
104537: STR
104538: PUSH
104539: LD_STRING , 
104541: STR
104542: PUSH
104543: LD_VAR 0 3
104547: PPUSH
104548: LD_INT 2
104550: PPUSH
104551: CALL_OW 268
104555: STR
104556: PUSH
104557: LD_STRING ],
104559: STR
104560: PPUSH
104561: CALL_OW 561
// end ;
104565: GO 104459
104567: POP
104568: POP
// AddToLog ( ]; ) ;
104569: LD_STRING ];
104571: PPUSH
104572: CALL_OW 561
// end ;
104576: LD_VAR 0 2
104580: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104581: LD_INT 0
104583: PPUSH
104584: PPUSH
104585: PPUSH
104586: PPUSH
104587: PPUSH
// if not area or not rate or not max then
104588: LD_VAR 0 1
104592: NOT
104593: PUSH
104594: LD_VAR 0 2
104598: NOT
104599: OR
104600: PUSH
104601: LD_VAR 0 4
104605: NOT
104606: OR
104607: IFFALSE 104611
// exit ;
104609: GO 104803
// while 1 do
104611: LD_INT 1
104613: IFFALSE 104803
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104615: LD_ADDR_VAR 0 9
104619: PUSH
104620: LD_VAR 0 1
104624: PPUSH
104625: LD_INT 1
104627: PPUSH
104628: CALL_OW 287
104632: PUSH
104633: LD_INT 10
104635: MUL
104636: ST_TO_ADDR
// r := rate / 10 ;
104637: LD_ADDR_VAR 0 7
104641: PUSH
104642: LD_VAR 0 2
104646: PUSH
104647: LD_INT 10
104649: DIVREAL
104650: ST_TO_ADDR
// time := 1 1$00 ;
104651: LD_ADDR_VAR 0 8
104655: PUSH
104656: LD_INT 2100
104658: ST_TO_ADDR
// if amount < min then
104659: LD_VAR 0 9
104663: PUSH
104664: LD_VAR 0 3
104668: LESS
104669: IFFALSE 104687
// r := r * 2 else
104671: LD_ADDR_VAR 0 7
104675: PUSH
104676: LD_VAR 0 7
104680: PUSH
104681: LD_INT 2
104683: MUL
104684: ST_TO_ADDR
104685: GO 104713
// if amount > max then
104687: LD_VAR 0 9
104691: PUSH
104692: LD_VAR 0 4
104696: GREATER
104697: IFFALSE 104713
// r := r / 2 ;
104699: LD_ADDR_VAR 0 7
104703: PUSH
104704: LD_VAR 0 7
104708: PUSH
104709: LD_INT 2
104711: DIVREAL
104712: ST_TO_ADDR
// time := time / r ;
104713: LD_ADDR_VAR 0 8
104717: PUSH
104718: LD_VAR 0 8
104722: PUSH
104723: LD_VAR 0 7
104727: DIVREAL
104728: ST_TO_ADDR
// if time < 0 then
104729: LD_VAR 0 8
104733: PUSH
104734: LD_INT 0
104736: LESS
104737: IFFALSE 104754
// time := time * - 1 ;
104739: LD_ADDR_VAR 0 8
104743: PUSH
104744: LD_VAR 0 8
104748: PUSH
104749: LD_INT 1
104751: NEG
104752: MUL
104753: ST_TO_ADDR
// wait ( time ) ;
104754: LD_VAR 0 8
104758: PPUSH
104759: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
104763: LD_INT 35
104765: PPUSH
104766: LD_INT 875
104768: PPUSH
104769: CALL_OW 12
104773: PPUSH
104774: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104778: LD_INT 1
104780: PPUSH
104781: LD_INT 5
104783: PPUSH
104784: CALL_OW 12
104788: PPUSH
104789: LD_VAR 0 1
104793: PPUSH
104794: LD_INT 1
104796: PPUSH
104797: CALL_OW 55
// end ;
104801: GO 104611
// end ;
104803: LD_VAR 0 5
104807: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104808: LD_INT 0
104810: PPUSH
104811: PPUSH
104812: PPUSH
104813: PPUSH
104814: PPUSH
104815: PPUSH
104816: PPUSH
104817: PPUSH
// if not turrets or not factories then
104818: LD_VAR 0 1
104822: NOT
104823: PUSH
104824: LD_VAR 0 2
104828: NOT
104829: OR
104830: IFFALSE 104834
// exit ;
104832: GO 105141
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104834: LD_ADDR_VAR 0 10
104838: PUSH
104839: LD_INT 5
104841: PUSH
104842: LD_INT 6
104844: PUSH
104845: EMPTY
104846: LIST
104847: LIST
104848: PUSH
104849: LD_INT 2
104851: PUSH
104852: LD_INT 4
104854: PUSH
104855: EMPTY
104856: LIST
104857: LIST
104858: PUSH
104859: LD_INT 3
104861: PUSH
104862: LD_INT 5
104864: PUSH
104865: EMPTY
104866: LIST
104867: LIST
104868: PUSH
104869: EMPTY
104870: LIST
104871: LIST
104872: LIST
104873: PUSH
104874: LD_INT 24
104876: PUSH
104877: LD_INT 25
104879: PUSH
104880: EMPTY
104881: LIST
104882: LIST
104883: PUSH
104884: LD_INT 23
104886: PUSH
104887: LD_INT 27
104889: PUSH
104890: EMPTY
104891: LIST
104892: LIST
104893: PUSH
104894: EMPTY
104895: LIST
104896: LIST
104897: PUSH
104898: LD_INT 42
104900: PUSH
104901: LD_INT 43
104903: PUSH
104904: EMPTY
104905: LIST
104906: LIST
104907: PUSH
104908: LD_INT 44
104910: PUSH
104911: LD_INT 46
104913: PUSH
104914: EMPTY
104915: LIST
104916: LIST
104917: PUSH
104918: LD_INT 45
104920: PUSH
104921: LD_INT 47
104923: PUSH
104924: EMPTY
104925: LIST
104926: LIST
104927: PUSH
104928: EMPTY
104929: LIST
104930: LIST
104931: LIST
104932: PUSH
104933: EMPTY
104934: LIST
104935: LIST
104936: LIST
104937: ST_TO_ADDR
// result := [ ] ;
104938: LD_ADDR_VAR 0 3
104942: PUSH
104943: EMPTY
104944: ST_TO_ADDR
// for i in turrets do
104945: LD_ADDR_VAR 0 4
104949: PUSH
104950: LD_VAR 0 1
104954: PUSH
104955: FOR_IN
104956: IFFALSE 105139
// begin nat := GetNation ( i ) ;
104958: LD_ADDR_VAR 0 7
104962: PUSH
104963: LD_VAR 0 4
104967: PPUSH
104968: CALL_OW 248
104972: ST_TO_ADDR
// weapon := 0 ;
104973: LD_ADDR_VAR 0 8
104977: PUSH
104978: LD_INT 0
104980: ST_TO_ADDR
// if not nat then
104981: LD_VAR 0 7
104985: NOT
104986: IFFALSE 104990
// continue ;
104988: GO 104955
// for j in list [ nat ] do
104990: LD_ADDR_VAR 0 5
104994: PUSH
104995: LD_VAR 0 10
104999: PUSH
105000: LD_VAR 0 7
105004: ARRAY
105005: PUSH
105006: FOR_IN
105007: IFFALSE 105048
// if GetBWeapon ( i ) = j [ 1 ] then
105009: LD_VAR 0 4
105013: PPUSH
105014: CALL_OW 269
105018: PUSH
105019: LD_VAR 0 5
105023: PUSH
105024: LD_INT 1
105026: ARRAY
105027: EQUAL
105028: IFFALSE 105046
// begin weapon := j [ 2 ] ;
105030: LD_ADDR_VAR 0 8
105034: PUSH
105035: LD_VAR 0 5
105039: PUSH
105040: LD_INT 2
105042: ARRAY
105043: ST_TO_ADDR
// break ;
105044: GO 105048
// end ;
105046: GO 105006
105048: POP
105049: POP
// if not weapon then
105050: LD_VAR 0 8
105054: NOT
105055: IFFALSE 105059
// continue ;
105057: GO 104955
// for k in factories do
105059: LD_ADDR_VAR 0 6
105063: PUSH
105064: LD_VAR 0 2
105068: PUSH
105069: FOR_IN
105070: IFFALSE 105135
// begin weapons := AvailableWeaponList ( k ) ;
105072: LD_ADDR_VAR 0 9
105076: PUSH
105077: LD_VAR 0 6
105081: PPUSH
105082: CALL_OW 478
105086: ST_TO_ADDR
// if not weapons then
105087: LD_VAR 0 9
105091: NOT
105092: IFFALSE 105096
// continue ;
105094: GO 105069
// if weapon in weapons then
105096: LD_VAR 0 8
105100: PUSH
105101: LD_VAR 0 9
105105: IN
105106: IFFALSE 105133
// begin result := [ i , weapon ] ;
105108: LD_ADDR_VAR 0 3
105112: PUSH
105113: LD_VAR 0 4
105117: PUSH
105118: LD_VAR 0 8
105122: PUSH
105123: EMPTY
105124: LIST
105125: LIST
105126: ST_TO_ADDR
// exit ;
105127: POP
105128: POP
105129: POP
105130: POP
105131: GO 105141
// end ; end ;
105133: GO 105069
105135: POP
105136: POP
// end ;
105137: GO 104955
105139: POP
105140: POP
// end ;
105141: LD_VAR 0 3
105145: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105146: LD_INT 0
105148: PPUSH
// if not side or side > 8 then
105149: LD_VAR 0 3
105153: NOT
105154: PUSH
105155: LD_VAR 0 3
105159: PUSH
105160: LD_INT 8
105162: GREATER
105163: OR
105164: IFFALSE 105168
// exit ;
105166: GO 105227
// if not range then
105168: LD_VAR 0 4
105172: NOT
105173: IFFALSE 105184
// range := - 12 ;
105175: LD_ADDR_VAR 0 4
105179: PUSH
105180: LD_INT 12
105182: NEG
105183: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105184: LD_VAR 0 1
105188: PPUSH
105189: LD_VAR 0 2
105193: PPUSH
105194: LD_VAR 0 3
105198: PPUSH
105199: LD_VAR 0 4
105203: PPUSH
105204: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105208: LD_VAR 0 1
105212: PPUSH
105213: LD_VAR 0 2
105217: PPUSH
105218: LD_VAR 0 3
105222: PPUSH
105223: CALL_OW 331
// end ;
105227: LD_VAR 0 5
105231: RET
// export function Video ( mode ) ; begin
105232: LD_INT 0
105234: PPUSH
// ingame_video = mode ;
105235: LD_ADDR_OWVAR 52
105239: PUSH
105240: LD_VAR 0 1
105244: ST_TO_ADDR
// interface_hidden = mode ;
105245: LD_ADDR_OWVAR 54
105249: PUSH
105250: LD_VAR 0 1
105254: ST_TO_ADDR
// end ;
105255: LD_VAR 0 2
105259: RET
// export function Join ( array , element ) ; begin
105260: LD_INT 0
105262: PPUSH
// result := array ^ element ;
105263: LD_ADDR_VAR 0 3
105267: PUSH
105268: LD_VAR 0 1
105272: PUSH
105273: LD_VAR 0 2
105277: ADD
105278: ST_TO_ADDR
// end ;
105279: LD_VAR 0 3
105283: RET
// export function JoinUnion ( array , element ) ; begin
105284: LD_INT 0
105286: PPUSH
// result := array union element ;
105287: LD_ADDR_VAR 0 3
105291: PUSH
105292: LD_VAR 0 1
105296: PUSH
105297: LD_VAR 0 2
105301: UNION
105302: ST_TO_ADDR
// end ;
105303: LD_VAR 0 3
105307: RET
// export function GetBehemoths ( side ) ; begin
105308: LD_INT 0
105310: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
105311: LD_ADDR_VAR 0 2
105315: PUSH
105316: LD_INT 22
105318: PUSH
105319: LD_VAR 0 1
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: PUSH
105328: LD_INT 31
105330: PUSH
105331: LD_INT 25
105333: PUSH
105334: EMPTY
105335: LIST
105336: LIST
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: PPUSH
105342: CALL_OW 69
105346: ST_TO_ADDR
// end ;
105347: LD_VAR 0 2
105351: RET
// export function Shuffle ( array ) ; var i , index ; begin
105352: LD_INT 0
105354: PPUSH
105355: PPUSH
105356: PPUSH
// result := [ ] ;
105357: LD_ADDR_VAR 0 2
105361: PUSH
105362: EMPTY
105363: ST_TO_ADDR
// if not array then
105364: LD_VAR 0 1
105368: NOT
105369: IFFALSE 105373
// exit ;
105371: GO 105472
// Randomize ;
105373: CALL_OW 10
// for i = array downto 1 do
105377: LD_ADDR_VAR 0 3
105381: PUSH
105382: DOUBLE
105383: LD_VAR 0 1
105387: INC
105388: ST_TO_ADDR
105389: LD_INT 1
105391: PUSH
105392: FOR_DOWNTO
105393: IFFALSE 105470
// begin index := rand ( 1 , array ) ;
105395: LD_ADDR_VAR 0 4
105399: PUSH
105400: LD_INT 1
105402: PPUSH
105403: LD_VAR 0 1
105407: PPUSH
105408: CALL_OW 12
105412: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105413: LD_ADDR_VAR 0 2
105417: PUSH
105418: LD_VAR 0 2
105422: PPUSH
105423: LD_VAR 0 2
105427: PUSH
105428: LD_INT 1
105430: PLUS
105431: PPUSH
105432: LD_VAR 0 1
105436: PUSH
105437: LD_VAR 0 4
105441: ARRAY
105442: PPUSH
105443: CALL_OW 2
105447: ST_TO_ADDR
// array := Delete ( array , index ) ;
105448: LD_ADDR_VAR 0 1
105452: PUSH
105453: LD_VAR 0 1
105457: PPUSH
105458: LD_VAR 0 4
105462: PPUSH
105463: CALL_OW 3
105467: ST_TO_ADDR
// end ;
105468: GO 105392
105470: POP
105471: POP
// end ;
105472: LD_VAR 0 2
105476: RET
