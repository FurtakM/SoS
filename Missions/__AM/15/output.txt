// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 35081 0 0
// InitNature ;
  19: CALL 34813 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11072 0 0
// PrepareRussian ;
  40: CALL 6956 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14966 0 0
// MC_Start ( ) ;
  60: CALL 37193 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 136
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 137
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59454 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59547 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58897 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58712 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59454 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59547 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58712 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58897 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59327 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58394 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59454 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59547 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 141
 955: PUSH
 956: LD_EXP 141
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58712 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59454 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59547 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58604 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59865 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 59036 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59327 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59327 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59659 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58712 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59278 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 65104 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 69928 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 69928 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 69928 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 69928 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 69928 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 65104 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 65104 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 65104 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 65104 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 65104 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 65104 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 65104 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 65104 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 65104 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 65104 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 65104 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 65104 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 65104 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 65104 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 65104 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 65104 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 65104 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 65104 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 65104 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 65104 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 65104 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 65104 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 65104 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 65104 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 65104 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 65104 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 65104 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 65104 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 18 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 18
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 18 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 18
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 6
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 61
4021: PPUSH
4022: LD_INT 89
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 69928 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 65104 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 65104 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 65104 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4448: LD_EXP 61
4452: PPUSH
4453: LD_INT 4
4455: PPUSH
4456: LD_INT 10
4458: PPUSH
4459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4463: LD_ADDR_VAR 0 5
4467: PUSH
4468: LD_INT 22
4470: PUSH
4471: LD_VAR 0 3
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PUSH
4480: LD_INT 30
4482: PUSH
4483: LD_INT 32
4485: PUSH
4486: EMPTY
4487: LIST
4488: LIST
4489: PUSH
4490: LD_INT 58
4492: PUSH
4493: EMPTY
4494: LIST
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: PPUSH
4501: CALL_OW 69
4505: ST_TO_ADDR
// for i = 1 to 10 do
4506: LD_ADDR_VAR 0 2
4510: PUSH
4511: DOUBLE
4512: LD_INT 1
4514: DEC
4515: ST_TO_ADDR
4516: LD_INT 10
4518: PUSH
4519: FOR_TO
4520: IFFALSE 4592
// begin uc_nation := nation_nature ;
4522: LD_ADDR_OWVAR 21
4526: PUSH
4527: LD_INT 0
4529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4530: LD_ADDR_OWVAR 28
4534: PUSH
4535: LD_INT 15
4537: ST_TO_ADDR
// hc_gallery :=  ;
4538: LD_ADDR_OWVAR 33
4542: PUSH
4543: LD_STRING 
4545: ST_TO_ADDR
// hc_name :=  ;
4546: LD_ADDR_OWVAR 26
4550: PUSH
4551: LD_STRING 
4553: ST_TO_ADDR
// un := CreateHuman ;
4554: LD_ADDR_VAR 0 4
4558: PUSH
4559: CALL_OW 44
4563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4564: LD_VAR 0 4
4568: PPUSH
4569: LD_VAR 0 5
4573: PUSH
4574: LD_VAR 0 5
4578: PUSH
4579: LD_VAR 0 2
4583: MINUS
4584: ARRAY
4585: PPUSH
4586: CALL_OW 52
// end ;
4590: GO 4519
4592: POP
4593: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4594: LD_ADDR_VAR 0 5
4598: PUSH
4599: LD_STRING 12_kurt_squad
4601: PPUSH
4602: CALL_OW 31
4606: ST_TO_ADDR
// if tmp then
4607: LD_VAR 0 5
4611: IFFALSE 4645
// for i in tmp do
4613: LD_ADDR_VAR 0 2
4617: PUSH
4618: LD_VAR 0 5
4622: PUSH
4623: FOR_IN
4624: IFFALSE 4643
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4626: LD_VAR 0 2
4630: PPUSH
4631: LD_INT 5
4633: PPUSH
4634: LD_INT 0
4636: PPUSH
4637: CALL_OW 49
4641: GO 4623
4643: POP
4644: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4645: LD_INT 324
4647: PPUSH
4648: LD_INT 5
4650: PPUSH
4651: LD_STRING 
4653: PPUSH
4654: LD_INT 8
4656: PUSH
4657: LD_INT 9
4659: PUSH
4660: LD_INT 10
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_OWVAR 67
4672: ARRAY
4673: PPUSH
4674: LD_INT 3000
4676: PUSH
4677: LD_INT 500
4679: PUSH
4680: LD_INT 150
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: LIST
4687: PPUSH
4688: LD_INT 16
4690: PUSH
4691: LD_INT 6
4693: PUSH
4694: LD_INT 6
4696: PUSH
4697: LD_INT 8
4699: PUSH
4700: EMPTY
4701: LIST
4702: LIST
4703: LIST
4704: LIST
4705: PPUSH
4706: CALL 73337 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4710: LD_ADDR_EXP 112
4714: PUSH
4715: LD_EXP 112
4719: PPUSH
4720: LD_INT 3
4722: PPUSH
4723: LD_INT 22
4725: PUSH
4726: LD_VAR 0 3
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 3
4747: PUSH
4748: LD_INT 21
4750: PUSH
4751: LD_INT 2
4753: PUSH
4754: EMPTY
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: PUSH
4772: LD_EXP 60
4776: DIFF
4777: PPUSH
4778: CALL_OW 1
4782: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 7
4788: PPUSH
4789: CALL_OW 383
// Friend := CreateHuman ;
4793: LD_ADDR_EXP 62
4797: PUSH
4798: CALL_OW 44
4802: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4803: LD_INT 14
4805: PPUSH
4806: LD_INT 3
4808: PPUSH
4809: LD_INT 1
4811: PPUSH
4812: LD_INT 29
4814: PPUSH
4815: LD_INT 100
4817: PPUSH
4818: CALL 69928 0 5
// powellBomb := CreateVehicle ;
4822: LD_ADDR_EXP 63
4826: PUSH
4827: CALL_OW 45
4831: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4832: LD_EXP 63
4836: PPUSH
4837: LD_INT 90
4839: PPUSH
4840: LD_INT 51
4842: PPUSH
4843: LD_INT 0
4845: PPUSH
4846: CALL_OW 48
// end ;
4850: LD_VAR 0 1
4854: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4855: LD_INT 0
4857: PPUSH
4858: PPUSH
4859: PPUSH
// if IsLive ( kozlov_fac ) then
4860: LD_INT 332
4862: PPUSH
4863: CALL_OW 300
4867: IFFALSE 4871
// exit ;
4869: GO 5438
// ComExitBuilding ( Kozlov ) ;
4871: LD_EXP 61
4875: PPUSH
4876: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4880: LD_EXP 61
4884: PPUSH
4885: CALL_OW 257
4889: PUSH
4890: LD_INT 2
4892: NONEQUAL
4893: IFFALSE 4928
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4895: LD_EXP 61
4899: PPUSH
4900: LD_INT 324
4902: PPUSH
4903: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4907: LD_EXP 61
4911: PPUSH
4912: LD_INT 2
4914: PPUSH
4915: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4919: LD_EXP 61
4923: PPUSH
4924: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4928: LD_EXP 61
4932: PPUSH
4933: LD_INT 2
4935: PPUSH
4936: LD_INT 93
4938: PPUSH
4939: LD_INT 32
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4949: LD_INT 35
4951: PPUSH
4952: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4956: LD_INT 22
4958: PUSH
4959: LD_INT 8
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 3
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PUSH
4986: LD_INT 57
4988: PUSH
4989: EMPTY
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 69
5002: IFFALSE 4949
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5004: LD_ADDR_VAR 0 2
5008: PUSH
5009: LD_INT 22
5011: PUSH
5012: LD_INT 8
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: LD_INT 30
5021: PUSH
5022: LD_INT 3
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 23
5031: PUSH
5032: LD_INT 3
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 57
5041: PUSH
5042: EMPTY
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: PPUSH
5051: CALL_OW 69
5055: PUSH
5056: LD_INT 1
5058: ARRAY
5059: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5060: LD_INT 22
5062: PUSH
5063: LD_INT 8
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 23
5072: PUSH
5073: LD_INT 3
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 21
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 69
5099: NOT
5100: IFFALSE 5178
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5102: LD_EXP 61
5106: PPUSH
5107: LD_INT 21
5109: PPUSH
5110: LD_INT 97
5112: PPUSH
5113: LD_INT 36
5115: PPUSH
5116: LD_INT 5
5118: PPUSH
5119: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5123: LD_INT 35
5125: PPUSH
5126: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5130: LD_INT 22
5132: PUSH
5133: LD_INT 8
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PUSH
5140: LD_INT 23
5142: PUSH
5143: LD_INT 3
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 30
5152: PUSH
5153: LD_INT 21
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 57
5162: PUSH
5163: EMPTY
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: PPUSH
5172: CALL_OW 69
5176: IFFALSE 5123
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5178: LD_INT 22
5180: PUSH
5181: LD_INT 8
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: PUSH
5188: LD_INT 23
5190: PUSH
5191: LD_INT 3
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: PUSH
5198: LD_INT 30
5200: PUSH
5201: LD_INT 18
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 69
5217: NOT
5218: IFFALSE 5296
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5220: LD_EXP 61
5224: PPUSH
5225: LD_INT 18
5227: PPUSH
5228: LD_INT 89
5230: PPUSH
5231: LD_INT 32
5233: PPUSH
5234: LD_INT 1
5236: PPUSH
5237: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5241: LD_INT 35
5243: PPUSH
5244: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5248: LD_INT 22
5250: PUSH
5251: LD_INT 8
5253: PUSH
5254: EMPTY
5255: LIST
5256: LIST
5257: PUSH
5258: LD_INT 23
5260: PUSH
5261: LD_INT 3
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 30
5270: PUSH
5271: LD_INT 18
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: PUSH
5278: LD_INT 57
5280: PUSH
5281: EMPTY
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 69
5294: IFFALSE 5241
// end ; lab := kozlov_lab ;
5296: LD_ADDR_VAR 0 3
5300: PUSH
5301: LD_INT 336
5303: ST_TO_ADDR
// if not lab then
5304: LD_VAR 0 3
5308: NOT
5309: IFFALSE 5313
// exit ;
5311: GO 5438
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5313: LD_EXP 61
5317: PPUSH
5318: LD_VAR 0 3
5322: PUSH
5323: LD_INT 1
5325: ARRAY
5326: PPUSH
5327: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5331: LD_EXP 61
5335: PPUSH
5336: LD_INT 4
5338: PPUSH
5339: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5343: LD_VAR 0 3
5347: PUSH
5348: LD_INT 1
5350: ARRAY
5351: PPUSH
5352: LD_INT 25
5354: PPUSH
5355: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5359: LD_INT 35
5361: PPUSH
5362: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5366: LD_INT 25
5368: PPUSH
5369: LD_INT 8
5371: PPUSH
5372: CALL_OW 321
5376: PUSH
5377: LD_INT 2
5379: EQUAL
5380: IFFALSE 5359
// ComExitBuilding ( Kozlov ) ;
5382: LD_EXP 61
5386: PPUSH
5387: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5391: LD_EXP 61
5395: PPUSH
5396: LD_VAR 0 2
5400: PPUSH
5401: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5405: LD_EXP 61
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5417: LD_VAR 0 2
5421: PPUSH
5422: LD_INT 23
5424: PPUSH
5425: LD_INT 3
5427: PPUSH
5428: LD_INT 1
5430: PPUSH
5431: LD_INT 48
5433: PPUSH
5434: CALL_OW 125
// end ;
5438: LD_VAR 0 1
5442: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5443: LD_EXP 22
5447: NOT
5448: PUSH
5449: LD_EXP 15
5453: PUSH
5454: LD_INT 6
5456: GREATEREQUAL
5457: AND
5458: IFFALSE 5539
5460: GO 5462
5462: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5463: LD_INT 3
5465: PPUSH
5466: LD_INT 3
5468: PPUSH
5469: CALL 58897 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5473: LD_INT 3
5475: PPUSH
5476: LD_INT 14
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 28
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: LIST
5493: PUSH
5494: LD_INT 14
5496: PUSH
5497: LD_INT 1
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 28
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: PUSH
5512: LD_INT 14
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: LD_INT 1
5520: PUSH
5521: LD_INT 28
5523: PUSH
5524: EMPTY
5525: LIST
5526: LIST
5527: LIST
5528: LIST
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: PPUSH
5535: CALL 58760 0 2
// end ;
5539: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5540: LD_EXP 22
5544: NOT
5545: PUSH
5546: LD_EXP 15
5550: PUSH
5551: LD_INT 6
5553: GREATEREQUAL
5554: AND
5555: PUSH
5556: LD_INT 3
5558: PPUSH
5559: LD_INT 1
5561: PPUSH
5562: CALL 60178 0 2
5566: NOT
5567: AND
5568: IFFALSE 6408
5570: GO 5572
5572: DISABLE
5573: LD_INT 0
5575: PPUSH
5576: PPUSH
5577: PPUSH
// begin enable ;
5578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5579: LD_INT 22
5581: PUSH
5582: LD_INT 8
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 23
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: PUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 69
5618: NOT
5619: IFFALSE 5623
// exit ;
5621: GO 6408
// if Prob ( 40 ) then
5623: LD_INT 40
5625: PPUSH
5626: CALL_OW 13
5630: IFFALSE 5757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5632: LD_INT 3
5634: PPUSH
5635: LD_INT 14
5637: PUSH
5638: LD_INT 1
5640: PUSH
5641: LD_INT 2
5643: PUSH
5644: LD_INT 28
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: PUSH
5653: LD_INT 14
5655: PUSH
5656: LD_INT 1
5658: PUSH
5659: LD_INT 2
5661: PUSH
5662: LD_INT 28
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 14
5673: PUSH
5674: LD_INT 1
5676: PUSH
5677: LD_INT 2
5679: PUSH
5680: LD_INT 28
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 14
5691: PUSH
5692: LD_INT 1
5694: PUSH
5695: LD_INT 2
5697: PUSH
5698: LD_INT 28
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: LD_INT 26
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PPUSH
5751: CALL 58760 0 2
// end else
5755: GO 5948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5757: LD_INT 3
5759: PPUSH
5760: LD_INT 14
5762: PUSH
5763: LD_INT 1
5765: PUSH
5766: LD_INT 2
5768: PUSH
5769: LD_INT 27
5771: PUSH
5772: LD_INT 26
5774: PUSH
5775: LD_INT 26
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_OWVAR 67
5787: ARRAY
5788: PUSH
5789: EMPTY
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 14
5797: PUSH
5798: LD_INT 1
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 27
5806: PUSH
5807: LD_INT 26
5809: PUSH
5810: LD_INT 26
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_OWVAR 67
5822: ARRAY
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 14
5832: PUSH
5833: LD_INT 1
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 26
5841: PUSH
5842: LD_INT 26
5844: PUSH
5845: LD_INT 29
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: PUSH
5853: LD_OWVAR 67
5857: ARRAY
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: PUSH
5865: LD_INT 13
5867: PUSH
5868: LD_INT 1
5870: PUSH
5871: LD_INT 2
5873: PUSH
5874: LD_INT 26
5876: PUSH
5877: LD_INT 29
5879: PUSH
5880: LD_INT 29
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: LIST
5887: PUSH
5888: LD_OWVAR 67
5892: ARRAY
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: PUSH
5900: LD_INT 13
5902: PUSH
5903: LD_INT 1
5905: PUSH
5906: LD_INT 2
5908: PUSH
5909: LD_INT 29
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 14
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: LD_INT 26
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: PPUSH
5944: CALL 58760 0 2
// end ; repeat wait ( 0 0$1 ) ;
5948: LD_INT 35
5950: PPUSH
5951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5955: LD_INT 3
5957: PPUSH
5958: LD_INT 1
5960: PPUSH
5961: CALL 60178 0 2
5965: PUSH
5966: LD_INT 6
5968: GREATEREQUAL
5969: IFFALSE 5948
// wait ( 0 0$30 ) ;
5971: LD_INT 1050
5973: PPUSH
5974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5978: LD_ADDR_VAR 0 2
5982: PUSH
5983: LD_INT 3
5985: PPUSH
5986: LD_INT 1
5988: PPUSH
5989: CALL 60178 0 2
5993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5994: LD_ADDR_EXP 131
5998: PUSH
5999: LD_EXP 131
6003: PPUSH
6004: LD_INT 3
6006: PPUSH
6007: LD_EXP 131
6011: PUSH
6012: LD_INT 3
6014: ARRAY
6015: PUSH
6016: LD_VAR 0 2
6020: DIFF
6021: PPUSH
6022: CALL_OW 1
6026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6027: LD_ADDR_VAR 0 3
6031: PUSH
6032: LD_INT 0
6034: PPUSH
6035: LD_INT 2
6037: PPUSH
6038: CALL_OW 12
6042: ST_TO_ADDR
// if target then
6043: LD_VAR 0 3
6047: IFFALSE 6175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6049: LD_ADDR_VAR 0 2
6053: PUSH
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 24
6061: PUSH
6062: LD_INT 250
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 72
6073: ST_TO_ADDR
// for i in tmp do
6074: LD_ADDR_VAR 0 1
6078: PUSH
6079: LD_VAR 0 2
6083: PUSH
6084: FOR_IN
6085: IFFALSE 6125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6087: LD_VAR 0 1
6091: PPUSH
6092: LD_INT 89
6094: PPUSH
6095: LD_INT 71
6097: PPUSH
6098: CALL_OW 297
6102: PUSH
6103: LD_INT 9
6105: GREATER
6106: IFFALSE 6123
// ComMoveXY ( i , 89 , 71 ) ;
6108: LD_VAR 0 1
6112: PPUSH
6113: LD_INT 89
6115: PPUSH
6116: LD_INT 71
6118: PPUSH
6119: CALL_OW 111
6123: GO 6084
6125: POP
6126: POP
// wait ( 0 0$1 ) ;
6127: LD_INT 35
6129: PPUSH
6130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6134: LD_VAR 0 2
6138: PPUSH
6139: LD_INT 92
6141: PUSH
6142: LD_INT 89
6144: PUSH
6145: LD_INT 71
6147: PUSH
6148: LD_INT 9
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 72
6161: PUSH
6162: LD_VAR 0 2
6166: PUSH
6167: LD_INT 1
6169: MINUS
6170: GREATEREQUAL
6171: IFFALSE 6049
// end else
6173: GO 6299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6175: LD_ADDR_VAR 0 2
6179: PUSH
6180: LD_VAR 0 2
6184: PPUSH
6185: LD_INT 24
6187: PUSH
6188: LD_INT 250
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: PPUSH
6195: CALL_OW 72
6199: ST_TO_ADDR
// for i in tmp do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: FOR_IN
6211: IFFALSE 6251
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 125
6220: PPUSH
6221: LD_INT 129
6223: PPUSH
6224: CALL_OW 297
6228: PUSH
6229: LD_INT 9
6231: GREATER
6232: IFFALSE 6249
// ComMoveXY ( i , 125 , 129 ) ;
6234: LD_VAR 0 1
6238: PPUSH
6239: LD_INT 125
6241: PPUSH
6242: LD_INT 129
6244: PPUSH
6245: CALL_OW 111
6249: GO 6210
6251: POP
6252: POP
// wait ( 0 0$1 ) ;
6253: LD_INT 35
6255: PPUSH
6256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6260: LD_VAR 0 2
6264: PPUSH
6265: LD_INT 92
6267: PUSH
6268: LD_INT 125
6270: PUSH
6271: LD_INT 129
6273: PUSH
6274: LD_INT 9
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: LIST
6282: PPUSH
6283: CALL_OW 72
6287: PUSH
6288: LD_VAR 0 2
6292: PUSH
6293: LD_INT 1
6295: MINUS
6296: GREATEREQUAL
6297: IFFALSE 6175
// end ; repeat wait ( 0 0$1 ) ;
6299: LD_INT 35
6301: PPUSH
6302: CALL_OW 67
// for i in tmp do
6306: LD_ADDR_VAR 0 1
6310: PUSH
6311: LD_VAR 0 2
6315: PUSH
6316: FOR_IN
6317: IFFALSE 6399
// begin if GetLives ( i ) > 251 then
6319: LD_VAR 0 1
6323: PPUSH
6324: CALL_OW 256
6328: PUSH
6329: LD_INT 251
6331: GREATER
6332: IFFALSE 6370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6334: LD_VAR 0 1
6338: PPUSH
6339: LD_INT 81
6341: PUSH
6342: LD_INT 8
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: PPUSH
6349: CALL_OW 69
6353: PPUSH
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 74
6363: PPUSH
6364: CALL_OW 115
6368: GO 6397
// if IsDead ( i ) then
6370: LD_VAR 0 1
6374: PPUSH
6375: CALL_OW 301
6379: IFFALSE 6397
// tmp := tmp diff i ;
6381: LD_ADDR_VAR 0 2
6385: PUSH
6386: LD_VAR 0 2
6390: PUSH
6391: LD_VAR 0 1
6395: DIFF
6396: ST_TO_ADDR
// end ;
6397: GO 6316
6399: POP
6400: POP
// until not tmp ;
6401: LD_VAR 0 2
6405: NOT
6406: IFFALSE 6299
// end ;
6408: PPOPN 3
6410: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6411: LD_EXP 22
6415: NOT
6416: PUSH
6417: LD_EXP 15
6421: PUSH
6422: LD_INT 6
6424: GREATEREQUAL
6425: AND
6426: PUSH
6427: LD_OWVAR 67
6431: PUSH
6432: LD_INT 1
6434: GREATER
6435: AND
6436: IFFALSE 6953
6438: GO 6440
6440: DISABLE
6441: LD_INT 0
6443: PPUSH
6444: PPUSH
6445: PPUSH
// begin enable ;
6446: ENABLE
// tmp := [ ] ;
6447: LD_ADDR_VAR 0 3
6451: PUSH
6452: EMPTY
6453: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6454: LD_ADDR_VAR 0 1
6458: PUSH
6459: DOUBLE
6460: LD_INT 1
6462: DEC
6463: ST_TO_ADDR
6464: LD_INT 4
6466: PUSH
6467: LD_INT 6
6469: PUSH
6470: LD_INT 7
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_OWVAR 67
6482: ARRAY
6483: PUSH
6484: FOR_TO
6485: IFFALSE 6645
// begin uc_side := 8 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 8
6494: ST_TO_ADDR
// uc_nation := 2 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 2
6502: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6503: LD_INT 13
6505: PUSH
6506: LD_INT 14
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: LD_INT 1
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 12
6523: ARRAY
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_INT 5
6530: PPUSH
6531: LD_INT 27
6533: PUSH
6534: LD_INT 28
6536: PUSH
6537: LD_INT 26
6539: PUSH
6540: LD_INT 25
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: LIST
6547: LIST
6548: PUSH
6549: LD_INT 1
6551: PPUSH
6552: LD_INT 4
6554: PPUSH
6555: CALL_OW 12
6559: ARRAY
6560: PPUSH
6561: LD_INT 88
6563: PPUSH
6564: CALL 69928 0 5
// un := CreateVehicle ;
6568: LD_ADDR_VAR 0 2
6572: PUSH
6573: CALL_OW 45
6577: ST_TO_ADDR
// tmp := tmp ^ un ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: ADD
6593: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 3
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 30
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6621: LD_VAR 0 2
6625: PPUSH
6626: LD_INT 16
6628: PPUSH
6629: LD_INT 11
6631: PPUSH
6632: CALL_OW 111
// wait ( 0 0$2 ) ;
6636: LD_INT 70
6638: PPUSH
6639: CALL_OW 67
// end ;
6643: GO 6484
6645: POP
6646: POP
// for i = 1 to Difficulty do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_OWVAR 67
6661: PUSH
6662: FOR_TO
6663: IFFALSE 6788
// begin uc_side := 8 ;
6665: LD_ADDR_OWVAR 20
6669: PUSH
6670: LD_INT 8
6672: ST_TO_ADDR
// uc_nation := 2 ;
6673: LD_ADDR_OWVAR 21
6677: PUSH
6678: LD_INT 2
6680: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6681: LD_INT 0
6683: PPUSH
6684: LD_INT 8
6686: PPUSH
6687: LD_INT 8
6689: PUSH
6690: LD_INT 8
6692: PUSH
6693: LD_INT 9
6695: PUSH
6696: EMPTY
6697: LIST
6698: LIST
6699: LIST
6700: PUSH
6701: LD_OWVAR 67
6705: ARRAY
6706: PPUSH
6707: CALL_OW 380
// un := CreateHuman ;
6711: LD_ADDR_VAR 0 2
6715: PUSH
6716: CALL_OW 44
6720: ST_TO_ADDR
// tmp := tmp ^ un ;
6721: LD_ADDR_VAR 0 3
6725: PUSH
6726: LD_VAR 0 3
6730: PUSH
6731: LD_VAR 0 2
6735: ADD
6736: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6737: LD_VAR 0 2
6741: PPUSH
6742: LD_INT 3
6744: PPUSH
6745: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 30
6756: PPUSH
6757: LD_INT 0
6759: PPUSH
6760: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6764: LD_VAR 0 2
6768: PPUSH
6769: LD_INT 16
6771: PPUSH
6772: LD_INT 11
6774: PPUSH
6775: CALL_OW 111
// wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// end ;
6786: GO 6662
6788: POP
6789: POP
// repeat wait ( 0 0$1 ) ;
6790: LD_INT 35
6792: PPUSH
6793: CALL_OW 67
// for i in tmp do
6797: LD_ADDR_VAR 0 1
6801: PUSH
6802: LD_VAR 0 3
6806: PUSH
6807: FOR_IN
6808: IFFALSE 6944
// begin if GetLives ( i ) > 250 then
6810: LD_VAR 0 1
6814: PPUSH
6815: CALL_OW 256
6819: PUSH
6820: LD_INT 250
6822: GREATER
6823: IFFALSE 6915
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6825: LD_INT 81
6827: PUSH
6828: LD_INT 8
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: PUSH
6835: LD_INT 91
6837: PUSH
6838: LD_VAR 0 1
6842: PUSH
6843: LD_INT 10
6845: PUSH
6846: EMPTY
6847: LIST
6848: LIST
6849: LIST
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: NOT
6860: IFFALSE 6879
// ComAgressiveMove ( i , 67 , 110 ) else
6862: LD_VAR 0 1
6866: PPUSH
6867: LD_INT 67
6869: PPUSH
6870: LD_INT 110
6872: PPUSH
6873: CALL_OW 114
6877: GO 6913
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6879: LD_VAR 0 1
6883: PPUSH
6884: LD_INT 81
6886: PUSH
6887: LD_INT 8
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: CALL_OW 74
6908: PPUSH
6909: CALL_OW 115
// end else
6913: GO 6942
// if IsDead ( i ) then
6915: LD_VAR 0 1
6919: PPUSH
6920: CALL_OW 301
6924: IFFALSE 6942
// tmp := tmp diff i ;
6926: LD_ADDR_VAR 0 3
6930: PUSH
6931: LD_VAR 0 3
6935: PUSH
6936: LD_VAR 0 1
6940: DIFF
6941: ST_TO_ADDR
// end ;
6942: GO 6807
6944: POP
6945: POP
// until not tmp ;
6946: LD_VAR 0 3
6950: NOT
6951: IFFALSE 6790
// end ; end_of_file
6953: PPOPN 3
6955: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
// side := 3 ;
6967: LD_ADDR_VAR 0 6
6971: PUSH
6972: LD_INT 3
6974: ST_TO_ADDR
// uc_side := side ;
6975: LD_ADDR_OWVAR 20
6979: PUSH
6980: LD_VAR 0 6
6984: ST_TO_ADDR
// uc_nation := 3 ;
6985: LD_ADDR_OWVAR 21
6989: PUSH
6990: LD_INT 3
6992: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6993: LD_ADDR_VAR 0 2
6997: PUSH
6998: LD_INT 22
7000: PUSH
7001: LD_VAR 0 6
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: LD_INT 21
7012: PUSH
7013: LD_INT 3
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PPUSH
7024: CALL_OW 69
7028: PUSH
7029: FOR_IN
7030: IFFALSE 7046
// SetBLevel ( i , 10 ) ;
7032: LD_VAR 0 2
7036: PPUSH
7037: LD_INT 10
7039: PPUSH
7040: CALL_OW 241
7044: GO 7029
7046: POP
7047: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7048: LD_ADDR_VAR 0 9
7052: PUSH
7053: LD_INT 22
7055: PUSH
7056: LD_VAR 0 6
7060: PUSH
7061: EMPTY
7062: LIST
7063: LIST
7064: PUSH
7065: LD_INT 30
7067: PUSH
7068: LD_INT 34
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PPUSH
7079: CALL_OW 69
7083: ST_TO_ADDR
// if teleport then
7084: LD_VAR 0 9
7088: IFFALSE 7109
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7090: LD_VAR 0 9
7094: PUSH
7095: LD_INT 1
7097: ARRAY
7098: PPUSH
7099: LD_INT 123
7101: PPUSH
7102: LD_INT 122
7104: PPUSH
7105: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7109: LD_ADDR_EXP 64
7113: PUSH
7114: LD_STRING Platonov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7122: LD_ADDR_EXP 65
7126: PUSH
7127: LD_STRING Kovalyuk
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7135: LD_ADDR_EXP 67
7139: PUSH
7140: LD_STRING Yakotich
7142: PPUSH
7143: LD_EXP 1
7147: NOT
7148: PPUSH
7149: LD_STRING 09_
7151: PPUSH
7152: CALL 65104 0 3
7156: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7157: LD_ADDR_EXP 66
7161: PUSH
7162: LD_STRING Bystrov
7164: PPUSH
7165: CALL_OW 25
7169: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7170: LD_ADDR_EXP 68
7174: PUSH
7175: LD_STRING Gleb
7177: PPUSH
7178: CALL_OW 25
7182: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7183: LD_STRING 03_Cornel
7185: PPUSH
7186: CALL_OW 28
7190: IFFALSE 7238
// begin Bierezov := NewCharacter ( Mikhail ) ;
7192: LD_ADDR_EXP 69
7196: PUSH
7197: LD_STRING Mikhail
7199: PPUSH
7200: CALL_OW 25
7204: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7205: LD_EXP 69
7209: PPUSH
7210: LD_INT 197
7212: PPUSH
7213: LD_INT 111
7215: PPUSH
7216: LD_INT 9
7218: PPUSH
7219: LD_INT 0
7221: PPUSH
7222: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7226: LD_EXP 69
7230: PPUSH
7231: LD_INT 3
7233: PPUSH
7234: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7238: LD_EXP 64
7242: PPUSH
7243: LD_INT 126
7245: PPUSH
7246: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7250: LD_EXP 65
7254: PPUSH
7255: LD_INT 134
7257: PPUSH
7258: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7262: LD_EXP 67
7266: PPUSH
7267: LD_INT 197
7269: PPUSH
7270: LD_INT 111
7272: PPUSH
7273: LD_INT 9
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7283: LD_EXP 66
7287: PPUSH
7288: LD_INT 197
7290: PPUSH
7291: LD_INT 111
7293: PPUSH
7294: LD_INT 9
7296: PPUSH
7297: LD_INT 0
7299: PPUSH
7300: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7304: LD_EXP 68
7308: PPUSH
7309: LD_INT 197
7311: PPUSH
7312: LD_INT 111
7314: PPUSH
7315: LD_INT 9
7317: PPUSH
7318: LD_INT 0
7320: PPUSH
7321: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7325: LD_ADDR_VAR 0 5
7329: PUSH
7330: LD_INT 126
7332: PPUSH
7333: LD_INT 4
7335: PPUSH
7336: LD_STRING zhukov
7338: PPUSH
7339: LD_INT 9
7341: PUSH
7342: LD_INT 10
7344: PUSH
7345: LD_INT 10
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PUSH
7353: LD_OWVAR 67
7357: ARRAY
7358: PPUSH
7359: LD_INT 90000
7361: PUSH
7362: LD_INT 1000
7364: PUSH
7365: LD_INT 300
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: LIST
7372: PPUSH
7373: LD_INT 18
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: LD_INT 13
7381: PUSH
7382: LD_INT 8
7384: PUSH
7385: EMPTY
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: PPUSH
7391: CALL 73337 0 6
7395: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7396: LD_ADDR_VAR 0 4
7400: PUSH
7401: LD_INT 267
7403: PPUSH
7404: CALL_OW 274
7408: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 1
7416: PPUSH
7417: LD_INT 5000
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 2
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7439: LD_VAR 0 4
7443: PPUSH
7444: LD_INT 3
7446: PPUSH
7447: LD_INT 200
7449: PPUSH
7450: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7454: LD_ADDR_EXP 112
7458: PUSH
7459: LD_EXP 112
7463: PPUSH
7464: LD_INT 2
7466: PPUSH
7467: LD_VAR 0 5
7471: PUSH
7472: LD_INT 22
7474: PUSH
7475: LD_VAR 0 6
7479: PUSH
7480: EMPTY
7481: LIST
7482: LIST
7483: PUSH
7484: LD_INT 3
7486: PUSH
7487: LD_INT 21
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: EMPTY
7498: LIST
7499: LIST
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: PPUSH
7505: CALL_OW 69
7509: UNION
7510: PUSH
7511: LD_EXP 64
7515: DIFF
7516: PPUSH
7517: CALL_OW 1
7521: ST_TO_ADDR
// behemoths := [ ] ;
7522: LD_ADDR_EXP 72
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// behemothBuilders := [ ] ;
7529: LD_ADDR_EXP 73
7533: PUSH
7534: EMPTY
7535: ST_TO_ADDR
// if Kovalyuk then
7536: LD_EXP 65
7540: IFFALSE 7562
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7542: LD_ADDR_EXP 73
7546: PUSH
7547: LD_EXP 73
7551: PPUSH
7552: LD_EXP 65
7556: PPUSH
7557: CALL 100974 0 2
7561: ST_TO_ADDR
// j := 3 ;
7562: LD_ADDR_VAR 0 3
7566: PUSH
7567: LD_INT 3
7569: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7570: LD_ADDR_VAR 0 2
7574: PUSH
7575: LD_INT 22
7577: PUSH
7578: LD_INT 3
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 25
7587: PUSH
7588: LD_INT 3
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PPUSH
7599: CALL_OW 69
7603: PUSH
7604: LD_EXP 65
7608: DIFF
7609: PUSH
7610: FOR_IN
7611: IFFALSE 7661
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7613: LD_ADDR_EXP 73
7617: PUSH
7618: LD_EXP 73
7622: PPUSH
7623: LD_VAR 0 2
7627: PPUSH
7628: CALL 100974 0 2
7632: ST_TO_ADDR
// j := j - 1 ;
7633: LD_ADDR_VAR 0 3
7637: PUSH
7638: LD_VAR 0 3
7642: PUSH
7643: LD_INT 1
7645: MINUS
7646: ST_TO_ADDR
// if j = 0 then
7647: LD_VAR 0 3
7651: PUSH
7652: LD_INT 0
7654: EQUAL
7655: IFFALSE 7659
// break ;
7657: GO 7661
// end ;
7659: GO 7610
7661: POP
7662: POP
// end ;
7663: LD_VAR 0 1
7667: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7668: LD_INT 0
7670: PPUSH
7671: PPUSH
7672: PPUSH
7673: PPUSH
7674: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 209
7682: PUSH
7683: LD_INT 149
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 219
7692: PUSH
7693: LD_INT 154
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 223
7702: PUSH
7703: LD_INT 149
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 232
7712: PUSH
7713: LD_INT 155
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: ST_TO_ADDR
// if not behemothBuilders then
7726: LD_EXP 73
7730: NOT
7731: IFFALSE 7735
// exit ;
7733: GO 7839
// j := 1 ;
7735: LD_ADDR_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: ST_TO_ADDR
// for i in behemothBuilders do
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_EXP 73
7752: PUSH
7753: FOR_IN
7754: IFFALSE 7837
// begin if IsInUnit ( i ) then
7756: LD_VAR 0 2
7760: PPUSH
7761: CALL_OW 310
7765: IFFALSE 7776
// ComExitBuilding ( i ) ;
7767: LD_VAR 0 2
7771: PPUSH
7772: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 37
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 1
7797: ARRAY
7798: PPUSH
7799: LD_VAR 0 4
7803: PUSH
7804: LD_VAR 0 3
7808: ARRAY
7809: PUSH
7810: LD_INT 2
7812: ARRAY
7813: PPUSH
7814: LD_INT 0
7816: PPUSH
7817: CALL_OW 230
// j := j + 1 ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_VAR 0 3
7830: PUSH
7831: LD_INT 1
7833: PLUS
7834: ST_TO_ADDR
// end ;
7835: GO 7753
7837: POP
7838: POP
// end ;
7839: LD_VAR 0 1
7843: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7844: LD_INT 24
7846: PPUSH
7847: LD_INT 30
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 70
7861: IFFALSE 7874
7863: GO 7865
7865: DISABLE
// behemothUnderConstruct := true ;
7866: LD_ADDR_EXP 26
7870: PUSH
7871: LD_INT 1
7873: ST_TO_ADDR
7874: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7875: LD_INT 3
7877: PPUSH
7878: CALL 101035 0 1
7882: PUSH
7883: LD_INT 22
7885: PUSH
7886: LD_INT 3
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: PUSH
7893: LD_INT 30
7895: PUSH
7896: LD_INT 37
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PPUSH
7907: CALL_OW 69
7911: NOT
7912: AND
7913: IFFALSE 8099
7915: GO 7917
7917: DISABLE
7918: LD_INT 0
7920: PPUSH
7921: PPUSH
// begin enable ;
7922: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7923: LD_ADDR_VAR 0 2
7927: PUSH
7928: LD_INT 3
7930: PPUSH
7931: CALL 101035 0 1
7935: ST_TO_ADDR
// for i in tmp do
7936: LD_ADDR_VAR 0 1
7940: PUSH
7941: LD_VAR 0 2
7945: PUSH
7946: FOR_IN
7947: IFFALSE 8097
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 9
7956: PPUSH
7957: CALL_OW 308
7961: PUSH
7962: LD_VAR 0 1
7966: PPUSH
7967: CALL_OW 110
7971: PUSH
7972: LD_INT 2
7974: EQUAL
7975: NOT
7976: AND
7977: IFFALSE 7991
// SetTag ( i , 2 ) ;
7979: LD_VAR 0 1
7983: PPUSH
7984: LD_INT 2
7986: PPUSH
7987: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7991: LD_INT 81
7993: PUSH
7994: LD_INT 3
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: PUSH
8001: LD_INT 91
8003: PUSH
8004: LD_VAR 0 1
8008: PUSH
8009: LD_INT 12
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: LIST
8016: PUSH
8017: EMPTY
8018: LIST
8019: LIST
8020: PPUSH
8021: CALL_OW 69
8025: NOT
8026: PUSH
8027: LD_VAR 0 1
8031: PPUSH
8032: CALL_OW 110
8036: PUSH
8037: LD_INT 2
8039: EQUAL
8040: NOT
8041: AND
8042: IFFALSE 8061
// ComAgressiveMove ( i , 64 , 93 ) else
8044: LD_VAR 0 1
8048: PPUSH
8049: LD_INT 64
8051: PPUSH
8052: LD_INT 93
8054: PPUSH
8055: CALL_OW 114
8059: GO 8095
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8061: LD_VAR 0 1
8065: PPUSH
8066: LD_INT 81
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: PPUSH
8076: CALL_OW 69
8080: PPUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 74
8090: PPUSH
8091: CALL_OW 115
// end ;
8095: GO 7946
8097: POP
8098: POP
// end ;
8099: PPOPN 2
8101: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8102: LD_INT 0
8104: PPUSH
8105: PPUSH
8106: PPUSH
// result := [ ] ;
8107: LD_ADDR_VAR 0 2
8111: PUSH
8112: EMPTY
8113: ST_TO_ADDR
// uc_side := 6 ;
8114: LD_ADDR_OWVAR 20
8118: PUSH
8119: LD_INT 6
8121: ST_TO_ADDR
// uc_nation := 3 ;
8122: LD_ADDR_OWVAR 21
8126: PUSH
8127: LD_INT 3
8129: ST_TO_ADDR
// case strength of 1 :
8130: LD_VAR 0 1
8134: PUSH
8135: LD_INT 1
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8281
8143: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8144: LD_ADDR_VAR 0 3
8148: PUSH
8149: DOUBLE
8150: LD_INT 1
8152: DEC
8153: ST_TO_ADDR
8154: LD_INT 4
8156: PUSH
8157: LD_INT 5
8159: PUSH
8160: LD_INT 6
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: LIST
8167: PUSH
8168: LD_OWVAR 67
8172: ARRAY
8173: PUSH
8174: FOR_TO
8175: IFFALSE 8277
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8177: LD_INT 22
8179: PUSH
8180: LD_INT 24
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: PUSH
8187: LD_VAR 0 3
8191: PUSH
8192: LD_INT 2
8194: MOD
8195: PUSH
8196: LD_INT 1
8198: PLUS
8199: ARRAY
8200: PPUSH
8201: LD_INT 1
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_INT 2
8216: PPUSH
8217: CALL_OW 12
8221: ARRAY
8222: PPUSH
8223: LD_INT 3
8225: PPUSH
8226: LD_INT 43
8228: PUSH
8229: LD_INT 44
8231: PUSH
8232: LD_INT 45
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: PUSH
8240: LD_INT 1
8242: PPUSH
8243: LD_INT 3
8245: PPUSH
8246: CALL_OW 12
8250: ARRAY
8251: PPUSH
8252: LD_INT 80
8254: PPUSH
8255: CALL 69928 0 5
// result := result union CreateVehicle ;
8259: LD_ADDR_VAR 0 2
8263: PUSH
8264: LD_VAR 0 2
8268: PUSH
8269: CALL_OW 45
8273: UNION
8274: ST_TO_ADDR
// end ;
8275: GO 8174
8277: POP
8278: POP
// end ; 2 :
8279: GO 9232
8281: LD_INT 2
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8445
8289: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 5
8302: PUSH
8303: LD_INT 6
8305: PUSH
8306: LD_INT 7
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: PUSH
8314: LD_OWVAR 67
8318: ARRAY
8319: PUSH
8320: FOR_TO
8321: IFFALSE 8441
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8323: LD_INT 22
8325: PUSH
8326: LD_INT 24
8328: PUSH
8329: LD_INT 24
8331: PUSH
8332: EMPTY
8333: LIST
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 3
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: LD_INT 44
8387: PUSH
8388: LD_INT 46
8390: PUSH
8391: LD_INT 46
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: LIST
8398: LIST
8399: LIST
8400: LIST
8401: PUSH
8402: LD_VAR 0 3
8406: PUSH
8407: LD_INT 6
8409: MOD
8410: PUSH
8411: LD_INT 1
8413: PLUS
8414: ARRAY
8415: PPUSH
8416: LD_INT 80
8418: PPUSH
8419: CALL 69928 0 5
// result := result union CreateVehicle ;
8423: LD_ADDR_VAR 0 2
8427: PUSH
8428: LD_VAR 0 2
8432: PUSH
8433: CALL_OW 45
8437: UNION
8438: ST_TO_ADDR
// end ;
8439: GO 8320
8441: POP
8442: POP
// end ; 3 :
8443: GO 9232
8445: LD_INT 3
8447: DOUBLE
8448: EQUAL
8449: IFTRUE 8453
8451: GO 8609
8453: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8454: LD_ADDR_VAR 0 3
8458: PUSH
8459: DOUBLE
8460: LD_INT 1
8462: DEC
8463: ST_TO_ADDR
8464: LD_INT 5
8466: PUSH
8467: LD_INT 7
8469: PUSH
8470: LD_INT 8
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_OWVAR 67
8482: ARRAY
8483: PUSH
8484: FOR_TO
8485: IFFALSE 8605
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8487: LD_INT 22
8489: PUSH
8490: LD_INT 24
8492: PUSH
8493: LD_INT 24
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: LIST
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_INT 3
8508: MOD
8509: PUSH
8510: LD_INT 1
8512: PLUS
8513: ARRAY
8514: PPUSH
8515: LD_INT 1
8517: PUSH
8518: LD_INT 3
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: PUSH
8525: LD_INT 1
8527: PPUSH
8528: LD_INT 2
8530: PPUSH
8531: CALL_OW 12
8535: ARRAY
8536: PPUSH
8537: LD_INT 3
8539: PPUSH
8540: LD_INT 43
8542: PUSH
8543: LD_INT 47
8545: PUSH
8546: LD_INT 45
8548: PUSH
8549: LD_INT 45
8551: PUSH
8552: LD_INT 46
8554: PUSH
8555: LD_INT 46
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: PUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 6
8573: MOD
8574: PUSH
8575: LD_INT 1
8577: PLUS
8578: ARRAY
8579: PPUSH
8580: LD_INT 80
8582: PPUSH
8583: CALL 69928 0 5
// result := result union CreateVehicle ;
8587: LD_ADDR_VAR 0 2
8591: PUSH
8592: LD_VAR 0 2
8596: PUSH
8597: CALL_OW 45
8601: UNION
8602: ST_TO_ADDR
// end ;
8603: GO 8484
8605: POP
8606: POP
// end ; 4 :
8607: GO 9232
8609: LD_INT 4
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 9231
8617: POP
// begin uc_nation := 3 ;
8618: LD_ADDR_OWVAR 21
8622: PUSH
8623: LD_INT 3
8625: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8626: LD_ADDR_VAR 0 3
8630: PUSH
8631: DOUBLE
8632: LD_INT 1
8634: DEC
8635: ST_TO_ADDR
8636: LD_INT 6
8638: PUSH
8639: LD_INT 8
8641: PUSH
8642: LD_INT 9
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: FOR_TO
8657: IFFALSE 8777
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8659: LD_INT 22
8661: PUSH
8662: LD_INT 24
8664: PUSH
8665: LD_INT 24
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: LD_INT 3
8680: MOD
8681: PUSH
8682: LD_INT 1
8684: PLUS
8685: ARRAY
8686: PPUSH
8687: LD_INT 1
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 1
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: CALL_OW 12
8707: ARRAY
8708: PPUSH
8709: LD_INT 3
8711: PPUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 47
8717: PUSH
8718: LD_INT 47
8720: PUSH
8721: LD_INT 45
8723: PUSH
8724: LD_INT 46
8726: PUSH
8727: LD_INT 46
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_VAR 0 3
8742: PUSH
8743: LD_INT 6
8745: MOD
8746: PUSH
8747: LD_INT 1
8749: PLUS
8750: ARRAY
8751: PPUSH
8752: LD_INT 80
8754: PPUSH
8755: CALL 69928 0 5
// result := result union CreateVehicle ;
8759: LD_ADDR_VAR 0 2
8763: PUSH
8764: LD_VAR 0 2
8768: PUSH
8769: CALL_OW 45
8773: UNION
8774: ST_TO_ADDR
// end ;
8775: GO 8656
8777: POP
8778: POP
// if not KappaStatus then
8779: LD_EXP 2
8783: NOT
8784: IFFALSE 9019
// begin uc_nation := 1 ;
8786: LD_ADDR_OWVAR 21
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// for i = 1 to 3 do
8794: LD_ADDR_VAR 0 3
8798: PUSH
8799: DOUBLE
8800: LD_INT 1
8802: DEC
8803: ST_TO_ADDR
8804: LD_INT 3
8806: PUSH
8807: FOR_TO
8808: IFFALSE 8944
// begin j := rand ( 0 , 1 ) ;
8810: LD_ADDR_VAR 0 4
8814: PUSH
8815: LD_INT 0
8817: PPUSH
8818: LD_INT 1
8820: PPUSH
8821: CALL_OW 12
8825: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8826: LD_INT 3
8828: PUSH
8829: LD_INT 5
8831: PUSH
8832: LD_INT 5
8834: PUSH
8835: LD_INT 4
8837: PUSH
8838: EMPTY
8839: LIST
8840: LIST
8841: LIST
8842: LIST
8843: PUSH
8844: LD_VAR 0 4
8848: PUSH
8849: LD_INT 1
8851: PPUSH
8852: LD_INT 3
8854: PPUSH
8855: CALL_OW 12
8859: PLUS
8860: ARRAY
8861: PPUSH
8862: LD_INT 1
8864: PUSH
8865: LD_INT 3
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: PUSH
8872: LD_INT 1
8874: PPUSH
8875: LD_INT 2
8877: PPUSH
8878: CALL_OW 12
8882: ARRAY
8883: PPUSH
8884: LD_INT 3
8886: PPUSH
8887: LD_INT 9
8889: PUSH
8890: LD_INT 7
8892: PUSH
8893: LD_INT 6
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_VAR 0 4
8905: PUSH
8906: LD_INT 1
8908: PPUSH
8909: LD_INT 2
8911: PPUSH
8912: CALL_OW 12
8916: PLUS
8917: ARRAY
8918: PPUSH
8919: LD_INT 85
8921: PPUSH
8922: CALL 69928 0 5
// result := result union CreateVehicle ;
8926: LD_ADDR_VAR 0 2
8930: PUSH
8931: LD_VAR 0 2
8935: PUSH
8936: CALL_OW 45
8940: UNION
8941: ST_TO_ADDR
// end ;
8942: GO 8807
8944: POP
8945: POP
// if vsevolodFirstAttack then
8946: LD_EXP 24
8950: IFFALSE 9017
// begin vsevolodFirstAttack := false ;
8952: LD_ADDR_EXP 24
8956: PUSH
8957: LD_INT 0
8959: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8960: LD_INT 5
8962: PPUSH
8963: LD_INT 3
8965: PPUSH
8966: LD_INT 1
8968: PPUSH
8969: LD_INT 6
8971: PPUSH
8972: LD_INT 100
8974: PPUSH
8975: CALL 69928 0 5
// sewiVeh := CreateVehicle ;
8979: LD_ADDR_EXP 71
8983: PUSH
8984: CALL_OW 45
8988: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8989: LD_EXP 71
8993: PPUSH
8994: LD_INT 1
8996: PPUSH
8997: CALL_OW 242
// result := result union sewiVeh ;
9001: LD_ADDR_VAR 0 2
9005: PUSH
9006: LD_VAR 0 2
9010: PUSH
9011: LD_EXP 71
9015: UNION
9016: ST_TO_ADDR
// end ; end else
9017: GO 9229
// if vsevolodFirstAttack then
9019: LD_EXP 24
9023: IFFALSE 9229
// begin vsevolodFirstAttack := false ;
9025: LD_ADDR_EXP 24
9029: PUSH
9030: LD_INT 0
9032: ST_TO_ADDR
// uc_nation := 3 ;
9033: LD_ADDR_OWVAR 21
9037: PUSH
9038: LD_INT 3
9040: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: DOUBLE
9047: LD_INT 1
9049: DEC
9050: ST_TO_ADDR
9051: LD_INT 2
9053: PUSH
9054: LD_OWVAR 67
9058: PLUS
9059: PUSH
9060: FOR_TO
9061: IFFALSE 9169
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9063: LD_INT 22
9065: PUSH
9066: LD_INT 24
9068: PUSH
9069: LD_INT 24
9071: PUSH
9072: EMPTY
9073: LIST
9074: LIST
9075: LIST
9076: PUSH
9077: LD_VAR 0 3
9081: PUSH
9082: LD_INT 3
9084: MOD
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: PPUSH
9091: LD_INT 1
9093: PUSH
9094: LD_INT 3
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: PUSH
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 2
9106: PPUSH
9107: CALL_OW 12
9111: ARRAY
9112: PPUSH
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 45
9118: PUSH
9119: LD_INT 47
9121: PUSH
9122: LD_INT 47
9124: PUSH
9125: EMPTY
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_VAR 0 3
9134: PUSH
9135: LD_INT 3
9137: MOD
9138: PUSH
9139: LD_INT 1
9141: PLUS
9142: ARRAY
9143: PPUSH
9144: LD_INT 80
9146: PPUSH
9147: CALL 69928 0 5
// result := result union CreateVehicle ;
9151: LD_ADDR_VAR 0 2
9155: PUSH
9156: LD_VAR 0 2
9160: PUSH
9161: CALL_OW 45
9165: UNION
9166: ST_TO_ADDR
// end ;
9167: GO 9060
9169: POP
9170: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9171: LD_INT 24
9173: PPUSH
9174: LD_INT 3
9176: PPUSH
9177: LD_INT 1
9179: PPUSH
9180: LD_INT 47
9182: PPUSH
9183: LD_INT 100
9185: PPUSH
9186: CALL 69928 0 5
// sewiVeh := CreateVehicle ;
9190: LD_ADDR_EXP 71
9194: PUSH
9195: CALL_OW 45
9199: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9200: LD_EXP 71
9204: PPUSH
9205: LD_INT 6
9207: NEG
9208: PPUSH
9209: CALL_OW 242
// result := result union sewiVeh ;
9213: LD_ADDR_VAR 0 2
9217: PUSH
9218: LD_VAR 0 2
9222: PUSH
9223: LD_EXP 71
9227: UNION
9228: ST_TO_ADDR
// end ; end ; end ;
9229: GO 9232
9231: POP
// end ;
9232: LD_VAR 0 2
9236: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9237: LD_EXP 16
9241: IFFALSE 10082
9243: GO 9245
9245: DISABLE
9246: LD_INT 0
9248: PPUSH
9249: PPUSH
9250: PPUSH
9251: PPUSH
9252: PPUSH
9253: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9254: LD_ADDR_VAR 0 4
9258: PUSH
9259: LD_INT 11
9261: PUSH
9262: LD_INT 12
9264: PUSH
9265: EMPTY
9266: LIST
9267: LIST
9268: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9269: LD_ADDR_VAR 0 3
9273: PUSH
9274: LD_INT 11550
9276: PUSH
9277: LD_INT 10150
9279: PUSH
9280: LD_INT 9800
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: LIST
9287: PUSH
9288: LD_OWVAR 67
9292: ARRAY
9293: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9294: LD_ADDR_VAR 0 6
9298: PUSH
9299: LD_INT 70
9301: PUSH
9302: LD_INT 118
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PUSH
9309: LD_INT 78
9311: PUSH
9312: LD_INT 31
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: ST_TO_ADDR
// repeat if missionStage = 2 then
9323: LD_EXP 15
9327: PUSH
9328: LD_INT 2
9330: EQUAL
9331: IFFALSE 9342
// wait ( 1 1$30 ) else
9333: LD_INT 3150
9335: PPUSH
9336: CALL_OW 67
9340: GO 9351
// wait ( time ) ;
9342: LD_VAR 0 3
9346: PPUSH
9347: CALL_OW 67
// if missionStage = 6 then
9351: LD_EXP 15
9355: PUSH
9356: LD_INT 6
9358: EQUAL
9359: IFFALSE 9387
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9361: LD_INT 51
9363: PPUSH
9364: LD_INT 6
9366: PPUSH
9367: LD_INT 2
9369: PPUSH
9370: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9374: LD_INT 57
9376: PPUSH
9377: LD_INT 6
9379: PPUSH
9380: LD_INT 2
9382: PPUSH
9383: CALL_OW 322
// end ; if missionStage = 8 then
9387: LD_EXP 15
9391: PUSH
9392: LD_INT 8
9394: EQUAL
9395: IFFALSE 9423
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9397: LD_INT 52
9399: PPUSH
9400: LD_INT 6
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9410: LD_INT 58
9412: PPUSH
9413: LD_INT 6
9415: PPUSH
9416: LD_INT 2
9418: PPUSH
9419: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9423: LD_EXP 15
9427: PUSH
9428: LD_INT 10
9430: EQUAL
9431: PUSH
9432: LD_OWVAR 67
9436: PUSH
9437: LD_INT 1
9439: GREATER
9440: AND
9441: IFFALSE 9469
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9443: LD_INT 53
9445: PPUSH
9446: LD_INT 6
9448: PPUSH
9449: LD_INT 2
9451: PPUSH
9452: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9456: LD_INT 59
9458: PPUSH
9459: LD_INT 6
9461: PPUSH
9462: LD_INT 2
9464: PPUSH
9465: CALL_OW 322
// end ; if activeAttacks then
9469: LD_EXP 16
9473: IFFALSE 10076
// begin if missionStage = 2 then
9475: LD_EXP 15
9479: PUSH
9480: LD_INT 2
9482: EQUAL
9483: IFFALSE 9493
// strength := 1 ;
9485: LD_ADDR_VAR 0 5
9489: PUSH
9490: LD_INT 1
9492: ST_TO_ADDR
// if missionStage > 2 then
9493: LD_EXP 15
9497: PUSH
9498: LD_INT 2
9500: GREATER
9501: IFFALSE 9511
// strength := 2 ;
9503: LD_ADDR_VAR 0 5
9507: PUSH
9508: LD_INT 2
9510: ST_TO_ADDR
// if missionStage > 6 then
9511: LD_EXP 15
9515: PUSH
9516: LD_INT 6
9518: GREATER
9519: IFFALSE 9529
// strength := 3 ;
9521: LD_ADDR_VAR 0 5
9525: PUSH
9526: LD_INT 3
9528: ST_TO_ADDR
// if missionStage > 10 then
9529: LD_EXP 15
9533: PUSH
9534: LD_INT 10
9536: GREATER
9537: IFFALSE 9547
// strength := 4 ;
9539: LD_ADDR_VAR 0 5
9543: PUSH
9544: LD_INT 4
9546: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9547: LD_ADDR_VAR 0 2
9551: PUSH
9552: LD_VAR 0 5
9556: PPUSH
9557: CALL 8102 0 1
9561: ST_TO_ADDR
// for i in tmp do
9562: LD_ADDR_VAR 0 1
9566: PUSH
9567: LD_VAR 0 2
9571: PUSH
9572: FOR_IN
9573: IFFALSE 9756
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9575: LD_VAR 0 1
9579: PPUSH
9580: LD_VAR 0 4
9584: PUSH
9585: LD_INT 1
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 12
9595: ARRAY
9596: PPUSH
9597: LD_INT 0
9599: PPUSH
9600: CALL_OW 49
// if i = sewiVeh then
9604: LD_VAR 0 1
9608: PUSH
9609: LD_EXP 71
9613: EQUAL
9614: IFFALSE 9651
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9616: LD_ADDR_EXP 70
9620: PUSH
9621: LD_STRING Vsevolod
9623: PPUSH
9624: LD_INT 0
9626: PPUSH
9627: LD_STRING 
9629: PPUSH
9630: CALL 65104 0 3
9634: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9635: LD_EXP 70
9639: PPUSH
9640: LD_VAR 0 1
9644: PPUSH
9645: CALL_OW 52
// end else
9649: GO 9732
// if GetControl ( i ) = control_manual then
9651: LD_VAR 0 1
9655: PPUSH
9656: CALL_OW 263
9660: PUSH
9661: LD_INT 1
9663: EQUAL
9664: IFFALSE 9732
// begin uc_side := 6 ;
9666: LD_ADDR_OWVAR 20
9670: PUSH
9671: LD_INT 6
9673: ST_TO_ADDR
// uc_nation := 3 ;
9674: LD_ADDR_OWVAR 21
9678: PUSH
9679: LD_INT 3
9681: ST_TO_ADDR
// hc_gallery :=  ;
9682: LD_ADDR_OWVAR 33
9686: PUSH
9687: LD_STRING 
9689: ST_TO_ADDR
// hc_name :=  ;
9690: LD_ADDR_OWVAR 26
9694: PUSH
9695: LD_STRING 
9697: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9698: LD_INT 0
9700: PPUSH
9701: LD_INT 3
9703: PPUSH
9704: LD_INT 10
9706: PPUSH
9707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9711: CALL_OW 44
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9725: LD_INT 10
9727: PPUSH
9728: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9732: LD_VAR 0 1
9736: PPUSH
9737: LD_INT 111
9739: PPUSH
9740: LD_INT 197
9742: PPUSH
9743: CALL_OW 111
// wait ( 0 0$2 ) ;
9747: LD_INT 70
9749: PPUSH
9750: CALL_OW 67
// end ;
9754: GO 9572
9756: POP
9757: POP
// repeat wait ( 0 0$1 ) ;
9758: LD_INT 35
9760: PPUSH
9761: CALL_OW 67
// for i in tmp do
9765: LD_ADDR_VAR 0 1
9769: PUSH
9770: LD_VAR 0 2
9774: PUSH
9775: FOR_IN
9776: IFFALSE 10057
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9778: LD_INT 81
9780: PUSH
9781: LD_INT 6
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: LD_INT 91
9790: PUSH
9791: LD_VAR 0 1
9795: PUSH
9796: LD_INT 12
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: LIST
9803: PUSH
9804: EMPTY
9805: LIST
9806: LIST
9807: PPUSH
9808: CALL_OW 69
9812: IFFALSE 9870
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9814: LD_VAR 0 1
9818: PPUSH
9819: LD_INT 81
9821: PUSH
9822: LD_INT 6
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: PUSH
9829: LD_INT 91
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_INT 12
9839: PUSH
9840: EMPTY
9841: LIST
9842: LIST
9843: LIST
9844: PUSH
9845: EMPTY
9846: LIST
9847: LIST
9848: PPUSH
9849: CALL_OW 69
9853: PPUSH
9854: LD_VAR 0 1
9858: PPUSH
9859: CALL_OW 74
9863: PPUSH
9864: CALL_OW 115
9868: GO 10055
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9870: LD_INT 9
9872: PPUSH
9873: LD_INT 81
9875: PUSH
9876: LD_INT 6
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PPUSH
9883: CALL_OW 70
9887: IFFALSE 10021
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9889: LD_VAR 0 1
9893: PPUSH
9894: LD_VAR 0 6
9898: PUSH
9899: LD_INT 1
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PPUSH
9907: LD_VAR 0 6
9911: PUSH
9912: LD_INT 1
9914: ARRAY
9915: PUSH
9916: LD_INT 2
9918: ARRAY
9919: PPUSH
9920: CALL_OW 297
9924: PUSH
9925: LD_INT 10
9927: GREATER
9928: PUSH
9929: LD_VAR 0 1
9933: PPUSH
9934: LD_INT 9
9936: PPUSH
9937: CALL_OW 308
9941: NOT
9942: AND
9943: IFFALSE 9982
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9945: LD_VAR 0 1
9949: PPUSH
9950: LD_VAR 0 6
9954: PUSH
9955: LD_INT 1
9957: ARRAY
9958: PUSH
9959: LD_INT 1
9961: ARRAY
9962: PPUSH
9963: LD_VAR 0 6
9967: PUSH
9968: LD_INT 1
9970: ARRAY
9971: PUSH
9972: LD_INT 2
9974: ARRAY
9975: PPUSH
9976: CALL_OW 114
9980: GO 10019
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_INT 9
9989: PPUSH
9990: LD_INT 81
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PPUSH
10000: CALL_OW 70
10004: PPUSH
10005: LD_VAR 0 1
10009: PPUSH
10010: CALL_OW 74
10014: PPUSH
10015: CALL_OW 115
// end else
10019: GO 10055
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10021: LD_VAR 0 1
10025: PPUSH
10026: LD_INT 81
10028: PUSH
10029: LD_INT 6
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: PPUSH
10036: CALL_OW 69
10040: PPUSH
10041: LD_VAR 0 1
10045: PPUSH
10046: CALL_OW 74
10050: PPUSH
10051: CALL_OW 115
// end ;
10055: GO 9775
10057: POP
10058: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10059: LD_INT 22
10061: PUSH
10062: LD_INT 6
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PPUSH
10069: CALL_OW 69
10073: NOT
10074: IFFALSE 9758
// end ; until russianDestroyed ;
10076: LD_EXP 21
10080: IFFALSE 9323
// end ;
10082: PPOPN 6
10084: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10085: LD_EXP 21
10089: NOT
10090: PUSH
10091: LD_EXP 15
10095: PUSH
10096: LD_INT 6
10098: GREATEREQUAL
10099: AND
10100: PUSH
10101: LD_INT 2
10103: PPUSH
10104: LD_INT 1
10106: PPUSH
10107: CALL 60178 0 2
10111: NOT
10112: AND
10113: IFFALSE 11069
10115: GO 10117
10117: DISABLE
10118: LD_INT 0
10120: PPUSH
10121: PPUSH
10122: PPUSH
10123: PPUSH
// begin enable ;
10124: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10125: LD_INT 22
10127: PUSH
10128: LD_INT 3
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: PUSH
10135: LD_INT 30
10137: PUSH
10138: LD_INT 3
10140: PUSH
10141: EMPTY
10142: LIST
10143: LIST
10144: PUSH
10145: EMPTY
10146: LIST
10147: LIST
10148: PPUSH
10149: CALL_OW 69
10153: NOT
10154: IFFALSE 10158
// exit ;
10156: GO 11069
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10158: LD_ADDR_VAR 0 4
10162: PUSH
10163: LD_INT 22
10165: PUSH
10166: LD_INT 3
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PUSH
10173: LD_INT 30
10175: PUSH
10176: LD_INT 34
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: PUSH
10183: EMPTY
10184: LIST
10185: LIST
10186: PPUSH
10187: CALL_OW 69
10191: ST_TO_ADDR
// if Prob ( 40 ) then
10192: LD_INT 40
10194: PPUSH
10195: CALL_OW 13
10199: IFFALSE 10326
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 22
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 49
10215: PUSH
10216: EMPTY
10217: LIST
10218: LIST
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 22
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 49
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: LIST
10239: PUSH
10240: LD_INT 22
10242: PUSH
10243: LD_INT 3
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 49
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 24
10260: PUSH
10261: LD_INT 3
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 46
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 24
10278: PUSH
10279: LD_INT 3
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 46
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: LIST
10292: LIST
10293: PUSH
10294: LD_INT 24
10296: PUSH
10297: LD_INT 3
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 46
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: PPUSH
10320: CALL 58760 0 2
// end else
10324: GO 10449
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10326: LD_INT 2
10328: PPUSH
10329: LD_INT 24
10331: PUSH
10332: LD_INT 3
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 47
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: PUSH
10347: LD_INT 24
10349: PUSH
10350: LD_INT 3
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 47
10358: PUSH
10359: EMPTY
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: PUSH
10365: LD_INT 24
10367: PUSH
10368: LD_INT 3
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 47
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 24
10385: PUSH
10386: LD_INT 3
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 46
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 24
10403: PUSH
10404: LD_INT 3
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 46
10412: PUSH
10413: EMPTY
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 24
10421: PUSH
10422: LD_INT 3
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 46
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: LIST
10435: LIST
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: PPUSH
10445: CALL 58760 0 2
// end ; if Difficulty > 1 then
10449: LD_OWVAR 67
10453: PUSH
10454: LD_INT 1
10456: GREATER
10457: IFFALSE 10487
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10459: LD_INT 2
10461: PPUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 47
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: PPUSH
10483: CALL 58760 0 2
// repeat wait ( 0 0$1 ) ;
10487: LD_INT 35
10489: PPUSH
10490: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10494: LD_INT 2
10496: PPUSH
10497: LD_INT 1
10499: PPUSH
10500: CALL 60178 0 2
10504: PUSH
10505: LD_INT 6
10507: PUSH
10508: LD_INT 7
10510: PUSH
10511: LD_INT 7
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: LIST
10518: PUSH
10519: LD_OWVAR 67
10523: ARRAY
10524: GREATEREQUAL
10525: IFFALSE 10487
// wait ( 0 0$30 ) ;
10527: LD_INT 1050
10529: PPUSH
10530: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10534: LD_ADDR_VAR 0 2
10538: PUSH
10539: LD_INT 2
10541: PPUSH
10542: LD_INT 1
10544: PPUSH
10545: CALL 60178 0 2
10549: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10550: LD_ADDR_EXP 131
10554: PUSH
10555: LD_EXP 131
10559: PPUSH
10560: LD_INT 2
10562: PPUSH
10563: LD_EXP 131
10567: PUSH
10568: LD_INT 2
10570: ARRAY
10571: PUSH
10572: LD_VAR 0 2
10576: DIFF
10577: PPUSH
10578: CALL_OW 1
10582: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10583: LD_ADDR_VAR 0 3
10587: PUSH
10588: LD_INT 0
10590: PPUSH
10591: LD_INT 1
10593: PPUSH
10594: CALL_OW 12
10598: ST_TO_ADDR
// if target then
10599: LD_VAR 0 3
10603: IFFALSE 10731
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10605: LD_ADDR_VAR 0 2
10609: PUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: LD_INT 24
10617: PUSH
10618: LD_INT 250
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PPUSH
10625: CALL_OW 72
10629: ST_TO_ADDR
// for i in tmp do
10630: LD_ADDR_VAR 0 1
10634: PUSH
10635: LD_VAR 0 2
10639: PUSH
10640: FOR_IN
10641: IFFALSE 10681
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 139
10650: PPUSH
10651: LD_INT 89
10653: PPUSH
10654: CALL_OW 297
10658: PUSH
10659: LD_INT 9
10661: GREATER
10662: IFFALSE 10679
// ComMoveXY ( i , 139 , 89 ) ;
10664: LD_VAR 0 1
10668: PPUSH
10669: LD_INT 139
10671: PPUSH
10672: LD_INT 89
10674: PPUSH
10675: CALL_OW 111
10679: GO 10640
10681: POP
10682: POP
// wait ( 0 0$1 ) ;
10683: LD_INT 35
10685: PPUSH
10686: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10690: LD_VAR 0 2
10694: PPUSH
10695: LD_INT 92
10697: PUSH
10698: LD_INT 139
10700: PUSH
10701: LD_INT 89
10703: PUSH
10704: LD_INT 9
10706: PUSH
10707: EMPTY
10708: LIST
10709: LIST
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 72
10717: PUSH
10718: LD_VAR 0 2
10722: PUSH
10723: LD_INT 1
10725: MINUS
10726: GREATEREQUAL
10727: IFFALSE 10605
// end else
10729: GO 10873
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10731: LD_VAR 0 2
10735: PPUSH
10736: LD_VAR 0 4
10740: PUSH
10741: LD_INT 1
10743: ARRAY
10744: PPUSH
10745: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10749: LD_ADDR_VAR 0 2
10753: PUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_INT 24
10761: PUSH
10762: LD_INT 250
10764: PUSH
10765: EMPTY
10766: LIST
10767: LIST
10768: PPUSH
10769: CALL_OW 72
10773: ST_TO_ADDR
// for i in tmp do
10774: LD_ADDR_VAR 0 1
10778: PUSH
10779: LD_VAR 0 2
10783: PUSH
10784: FOR_IN
10785: IFFALSE 10825
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10787: LD_VAR 0 1
10791: PPUSH
10792: LD_INT 124
10794: PPUSH
10795: LD_INT 139
10797: PPUSH
10798: CALL_OW 297
10802: PUSH
10803: LD_INT 9
10805: GREATER
10806: IFFALSE 10823
// ComMoveXY ( i , 124 , 139 ) ;
10808: LD_VAR 0 1
10812: PPUSH
10813: LD_INT 124
10815: PPUSH
10816: LD_INT 139
10818: PPUSH
10819: CALL_OW 111
10823: GO 10784
10825: POP
10826: POP
// wait ( 0 0$1 ) ;
10827: LD_INT 35
10829: PPUSH
10830: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_INT 92
10841: PUSH
10842: LD_INT 124
10844: PUSH
10845: LD_INT 139
10847: PUSH
10848: LD_INT 9
10850: PUSH
10851: EMPTY
10852: LIST
10853: LIST
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 72
10861: PUSH
10862: LD_VAR 0 2
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: GREATEREQUAL
10871: IFFALSE 10749
// end ; repeat wait ( 0 0$1 ) ;
10873: LD_INT 35
10875: PPUSH
10876: CALL_OW 67
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 11060
// begin if GetLives ( i ) > 251 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 251
10905: GREATER
10906: IFFALSE 11031
// begin if GetWeapon ( i ) = ru_time_lapser then
10908: LD_VAR 0 1
10912: PPUSH
10913: CALL_OW 264
10917: PUSH
10918: LD_INT 49
10920: EQUAL
10921: IFFALSE 10977
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10923: LD_VAR 0 1
10927: PPUSH
10928: LD_INT 2
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 1
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PUSH
10941: LD_INT 22
10943: PUSH
10944: LD_INT 8
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PPUSH
10961: LD_VAR 0 1
10965: PPUSH
10966: CALL_OW 74
10970: PPUSH
10971: CALL_OW 112
10975: GO 11029
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10977: LD_VAR 0 1
10981: PPUSH
10982: LD_INT 2
10984: PUSH
10985: LD_INT 22
10987: PUSH
10988: LD_INT 1
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: LD_INT 22
10997: PUSH
10998: LD_INT 8
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PUSH
11005: EMPTY
11006: LIST
11007: LIST
11008: LIST
11009: PPUSH
11010: CALL_OW 69
11014: PPUSH
11015: LD_VAR 0 1
11019: PPUSH
11020: CALL_OW 74
11024: PPUSH
11025: CALL_OW 115
// end else
11029: GO 11058
// if IsDead ( i ) then
11031: LD_VAR 0 1
11035: PPUSH
11036: CALL_OW 301
11040: IFFALSE 11058
// tmp := tmp diff i ;
11042: LD_ADDR_VAR 0 2
11046: PUSH
11047: LD_VAR 0 2
11051: PUSH
11052: LD_VAR 0 1
11056: DIFF
11057: ST_TO_ADDR
// end ;
11058: GO 10890
11060: POP
11061: POP
// until not tmp ;
11062: LD_VAR 0 2
11066: NOT
11067: IFFALSE 10873
// end ; end_of_file
11069: PPOPN 4
11071: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11072: LD_INT 0
11074: PPUSH
11075: PPUSH
11076: PPUSH
11077: PPUSH
11078: PPUSH
11079: PPUSH
// side := 7 ;
11080: LD_ADDR_VAR 0 5
11084: PUSH
11085: LD_INT 7
11087: ST_TO_ADDR
// uc_side := side ;
11088: LD_ADDR_OWVAR 20
11092: PUSH
11093: LD_VAR 0 5
11097: ST_TO_ADDR
// uc_nation := 1 ;
11098: LD_ADDR_OWVAR 21
11102: PUSH
11103: LD_INT 1
11105: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11106: LD_ADDR_VAR 0 2
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_VAR 0 5
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: LD_INT 21
11125: PUSH
11126: LD_INT 3
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PPUSH
11137: CALL_OW 69
11141: PUSH
11142: FOR_IN
11143: IFFALSE 11159
// SetBLevel ( i , 10 ) ;
11145: LD_VAR 0 2
11149: PPUSH
11150: LD_INT 10
11152: PPUSH
11153: CALL_OW 241
11157: GO 11142
11159: POP
11160: POP
// base := GetBase ( al_depot ) ;
11161: LD_ADDR_VAR 0 4
11165: PUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 274
11173: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11174: LD_ADDR_VAR 0 6
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_VAR 0 5
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PUSH
11191: LD_INT 30
11193: PUSH
11194: LD_INT 34
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PPUSH
11205: CALL_OW 69
11209: ST_TO_ADDR
// if teleport then
11210: LD_VAR 0 6
11214: IFFALSE 11235
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11216: LD_VAR 0 6
11220: PUSH
11221: LD_INT 1
11223: ARRAY
11224: PPUSH
11225: LD_INT 262
11227: PPUSH
11228: LD_INT 119
11230: PPUSH
11231: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 1
11242: PPUSH
11243: LD_INT 19500
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 2
11257: PPUSH
11258: LD_INT 200
11260: PPUSH
11261: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_INT 3
11272: PPUSH
11273: LD_INT 650
11275: PPUSH
11276: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11280: LD_ADDR_EXP 74
11284: PUSH
11285: LD_STRING Roth
11287: PPUSH
11288: CALL_OW 25
11292: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11293: LD_ADDR_EXP 75
11297: PUSH
11298: LD_STRING Simms
11300: PPUSH
11301: LD_EXP 1
11305: NOT
11306: PPUSH
11307: LD_STRING 10c_
11309: PPUSH
11310: CALL 65104 0 3
11314: ST_TO_ADDR
// if not Simms then
11315: LD_EXP 75
11319: NOT
11320: IFFALSE 11350
// begin uc_nation := 1 ;
11322: LD_ADDR_OWVAR 21
11326: PUSH
11327: LD_INT 1
11329: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11330: LD_INT 2
11332: PPUSH
11333: LD_INT 10
11335: PPUSH
11336: CALL_OW 384
// Simms := CreateHuman ;
11340: LD_ADDR_EXP 75
11344: PUSH
11345: CALL_OW 44
11349: ST_TO_ADDR
// end ; uc_nation := 3 ;
11350: LD_ADDR_OWVAR 21
11354: PUSH
11355: LD_INT 3
11357: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11358: LD_ADDR_EXP 76
11362: PUSH
11363: LD_STRING Kirilenkova
11365: PPUSH
11366: CALL_OW 25
11370: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11371: LD_ADDR_EXP 90
11375: PUSH
11376: LD_STRING Oblukov
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11384: LD_ADDR_EXP 77
11388: PUSH
11389: LD_STRING Dolgov
11391: PPUSH
11392: CALL_OW 25
11396: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11397: LD_ADDR_EXP 78
11401: PUSH
11402: LD_STRING Petrosyan
11404: PPUSH
11405: CALL_OW 25
11409: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11410: LD_ADDR_EXP 89
11414: PUSH
11415: LD_STRING Scholtze
11417: PPUSH
11418: CALL_OW 25
11422: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11423: LD_ADDR_EXP 88
11427: PUSH
11428: LD_STRING Kapitsova
11430: PPUSH
11431: CALL_OW 25
11435: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11436: LD_ADDR_EXP 79
11440: PUSH
11441: LD_STRING Petrovova
11443: PPUSH
11444: CALL_OW 25
11448: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11449: LD_ADDR_EXP 80
11453: PUSH
11454: LD_STRING Kuzmov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11462: LD_ADDR_EXP 87
11466: PUSH
11467: LD_STRING Karamazov
11469: PPUSH
11470: CALL_OW 25
11474: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11475: LD_STRING 13_Lipshchin_1
11477: PPUSH
11478: LD_INT 0
11480: PPUSH
11481: CALL_OW 30
11485: IFFALSE 11500
// Lipshchin := NewCharacter ( Lipshchin ) ;
11487: LD_ADDR_EXP 81
11491: PUSH
11492: LD_STRING Lipshchin
11494: PPUSH
11495: CALL_OW 25
11499: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11500: LD_STRING 13_Titov_1
11502: PPUSH
11503: LD_INT 0
11505: PPUSH
11506: CALL_OW 30
11510: IFFALSE 11525
// Titov := NewCharacter ( Titov ) ;
11512: LD_ADDR_EXP 83
11516: PUSH
11517: LD_STRING Titov
11519: PPUSH
11520: CALL_OW 25
11524: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11525: LD_STRING 13_Gnyevko_1
11527: PPUSH
11528: LD_INT 0
11530: PPUSH
11531: CALL_OW 30
11535: IFFALSE 11550
// Gnyevko := NewCharacter ( Gnyevko ) ;
11537: LD_ADDR_EXP 82
11541: PUSH
11542: LD_STRING Gnyevko
11544: PPUSH
11545: CALL_OW 25
11549: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11550: LD_STRING 13_Xavier_1
11552: PPUSH
11553: LD_INT 0
11555: PPUSH
11556: CALL_OW 30
11560: IFFALSE 11575
// Xavier := NewCharacter ( Xavier2 ) ;
11562: LD_ADDR_EXP 84
11566: PUSH
11567: LD_STRING Xavier2
11569: PPUSH
11570: CALL_OW 25
11574: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11575: LD_STRING 13_Belkov_1
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 30
11585: IFFALSE 11600
// Belkov := NewCharacter ( Belkov ) ;
11587: LD_ADDR_EXP 85
11591: PUSH
11592: LD_STRING Belkov
11594: PPUSH
11595: CALL_OW 25
11599: ST_TO_ADDR
// if not BurlakStatus then
11600: LD_EXP 9
11604: NOT
11605: IFFALSE 11620
// Burlak = NewCharacter ( Burlak ) ;
11607: LD_ADDR_EXP 86
11611: PUSH
11612: LD_STRING Burlak
11614: PPUSH
11615: CALL_OW 25
11619: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11620: LD_ADDR_VAR 0 3
11624: PUSH
11625: LD_EXP 74
11629: PUSH
11630: LD_EXP 76
11634: PUSH
11635: LD_EXP 90
11639: PUSH
11640: LD_EXP 77
11644: PUSH
11645: LD_EXP 78
11649: PUSH
11650: LD_EXP 89
11654: PUSH
11655: LD_EXP 88
11659: PUSH
11660: LD_EXP 79
11664: PUSH
11665: LD_EXP 80
11669: PUSH
11670: LD_EXP 87
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: ST_TO_ADDR
// if Simms then
11687: LD_EXP 75
11691: IFFALSE 11709
// tmp := tmp ^ Simms ;
11693: LD_ADDR_VAR 0 3
11697: PUSH
11698: LD_VAR 0 3
11702: PUSH
11703: LD_EXP 75
11707: ADD
11708: ST_TO_ADDR
// if Titov then
11709: LD_EXP 83
11713: IFFALSE 11731
// tmp := tmp ^ Titov ;
11715: LD_ADDR_VAR 0 3
11719: PUSH
11720: LD_VAR 0 3
11724: PUSH
11725: LD_EXP 83
11729: ADD
11730: ST_TO_ADDR
// if Lipshchin then
11731: LD_EXP 81
11735: IFFALSE 11753
// tmp := tmp ^ Lipshchin ;
11737: LD_ADDR_VAR 0 3
11741: PUSH
11742: LD_VAR 0 3
11746: PUSH
11747: LD_EXP 81
11751: ADD
11752: ST_TO_ADDR
// if Gnyevko then
11753: LD_EXP 82
11757: IFFALSE 11775
// tmp := tmp ^ Gnyevko ;
11759: LD_ADDR_VAR 0 3
11763: PUSH
11764: LD_VAR 0 3
11768: PUSH
11769: LD_EXP 82
11773: ADD
11774: ST_TO_ADDR
// if Xavier then
11775: LD_EXP 84
11779: IFFALSE 11797
// tmp := tmp ^ Xavier ;
11781: LD_ADDR_VAR 0 3
11785: PUSH
11786: LD_VAR 0 3
11790: PUSH
11791: LD_EXP 84
11795: ADD
11796: ST_TO_ADDR
// if Belkov then
11797: LD_EXP 85
11801: IFFALSE 11819
// tmp := tmp ^ Belkov ;
11803: LD_ADDR_VAR 0 3
11807: PUSH
11808: LD_VAR 0 3
11812: PUSH
11813: LD_EXP 85
11817: ADD
11818: ST_TO_ADDR
// if Burlak then
11819: LD_EXP 86
11823: IFFALSE 11841
// tmp := tmp ^ Burlak ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_VAR 0 3
11834: PUSH
11835: LD_EXP 86
11839: ADD
11840: ST_TO_ADDR
// for i = 1 to 11 do
11841: LD_ADDR_VAR 0 2
11845: PUSH
11846: DOUBLE
11847: LD_INT 1
11849: DEC
11850: ST_TO_ADDR
11851: LD_INT 11
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11921
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11857: LD_ADDR_OWVAR 21
11861: PUSH
11862: LD_INT 1
11864: PUSH
11865: LD_INT 3
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: PUSH
11872: LD_INT 1
11874: PPUSH
11875: LD_INT 2
11877: PPUSH
11878: CALL_OW 12
11882: ARRAY
11883: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11884: LD_INT 0
11886: PPUSH
11887: LD_VAR 0 2
11891: PUSH
11892: LD_INT 2
11894: DIV
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11903: LD_ADDR_VAR 0 3
11907: PUSH
11908: LD_VAR 0 3
11912: PUSH
11913: CALL_OW 44
11917: ADD
11918: ST_TO_ADDR
// end ;
11919: GO 11854
11921: POP
11922: POP
// for i in tmp do
11923: LD_ADDR_VAR 0 2
11927: PUSH
11928: LD_VAR 0 3
11932: PUSH
11933: FOR_IN
11934: IFFALSE 11959
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11936: LD_VAR 0 2
11940: PPUSH
11941: LD_INT 260
11943: PPUSH
11944: LD_INT 235
11946: PPUSH
11947: LD_INT 8
11949: PPUSH
11950: LD_INT 0
11952: PPUSH
11953: CALL_OW 50
11957: GO 11933
11959: POP
11960: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11961: LD_ADDR_EXP 112
11965: PUSH
11966: LD_EXP 112
11970: PPUSH
11971: LD_INT 1
11973: PPUSH
11974: LD_INT 22
11976: PUSH
11977: LD_VAR 0 5
11981: PUSH
11982: EMPTY
11983: LIST
11984: LIST
11985: PUSH
11986: LD_INT 3
11988: PUSH
11989: LD_INT 21
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: PPUSH
12007: CALL_OW 69
12011: PUSH
12012: LD_EXP 74
12016: PUSH
12017: LD_EXP 75
12021: PUSH
12022: EMPTY
12023: LIST
12024: LIST
12025: DIFF
12026: PPUSH
12027: CALL_OW 1
12031: ST_TO_ADDR
// uc_side := 0 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 0
12039: ST_TO_ADDR
// uc_nation := 0 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 0
12047: ST_TO_ADDR
// for i = 1 to 5 do
12048: LD_ADDR_VAR 0 2
12052: PUSH
12053: DOUBLE
12054: LD_INT 1
12056: DEC
12057: ST_TO_ADDR
12058: LD_INT 5
12060: PUSH
12061: FOR_TO
12062: IFFALSE 12099
// begin InitHc ;
12064: CALL_OW 19
// hc_class := class_apeman ;
12068: LD_ADDR_OWVAR 28
12072: PUSH
12073: LD_INT 12
12075: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12076: CALL_OW 44
12080: PPUSH
12081: LD_INT 299
12083: PPUSH
12084: LD_INT 229
12086: PPUSH
12087: LD_INT 10
12089: PPUSH
12090: LD_INT 0
12092: PPUSH
12093: CALL_OW 50
// end ;
12097: GO 12061
12099: POP
12100: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 259
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12116: LD_EXP 74
12120: PPUSH
12121: LD_INT 262
12123: PPUSH
12124: LD_INT 235
12126: PPUSH
12127: CALL_OW 178
// if Simms then
12131: LD_EXP 75
12135: IFFALSE 12166
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_INT 262
12144: PPUSH
12145: LD_INT 235
12147: PPUSH
12148: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12152: LD_EXP 75
12156: PPUSH
12157: LD_EXP 74
12161: PPUSH
12162: CALL_OW 179
// end ; end ;
12166: LD_VAR 0 1
12170: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12171: LD_EXP 31
12175: PUSH
12176: LD_EXP 23
12180: NOT
12181: AND
12182: IFFALSE 12358
12184: GO 12186
12186: DISABLE
12187: LD_INT 0
12189: PPUSH
12190: PPUSH
12191: PPUSH
// begin enable ;
12192: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 81
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 2
12210: PUSH
12211: LD_INT 32
12213: PUSH
12214: LD_INT 3
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 30
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: PUSH
12231: LD_INT 30
12233: PUSH
12234: LD_INT 28
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: PUSH
12241: LD_INT 34
12243: PUSH
12244: LD_INT 49
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: PUSH
12251: LD_INT 34
12253: PUSH
12254: LD_INT 10
12256: PUSH
12257: EMPTY
12258: LIST
12259: LIST
12260: PUSH
12261: LD_INT 34
12263: PUSH
12264: LD_INT 8
12266: PUSH
12267: EMPTY
12268: LIST
12269: LIST
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: LIST
12275: LIST
12276: LIST
12277: LIST
12278: LIST
12279: PUSH
12280: EMPTY
12281: LIST
12282: LIST
12283: PPUSH
12284: CALL_OW 69
12288: ST_TO_ADDR
// if not tmp then
12289: LD_VAR 0 2
12293: NOT
12294: IFFALSE 12298
// exit ;
12296: GO 12358
// target := tmp [ rand ( 1 , tmp ) ] ;
12298: LD_ADDR_VAR 0 3
12302: PUSH
12303: LD_VAR 0 2
12307: PUSH
12308: LD_INT 1
12310: PPUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 12
12320: ARRAY
12321: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 255
12331: PUSH
12332: LD_INT 1
12334: EQUAL
12335: IFFALSE 12346
// CenterNowOnUnits ( target ) ;
12337: LD_VAR 0 3
12341: PPUSH
12342: CALL_OW 87
// SetLives ( target , 0 ) ;
12346: LD_VAR 0 3
12350: PPUSH
12351: LD_INT 0
12353: PPUSH
12354: CALL_OW 234
// end ;
12358: PPOPN 3
12360: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12361: LD_EXP 23
12365: NOT
12366: PUSH
12367: LD_EXP 31
12371: AND
12372: IFFALSE 12894
12374: GO 12376
12376: DISABLE
12377: LD_INT 0
12379: PPUSH
12380: PPUSH
12381: PPUSH
// begin uc_side := 7 ;
12382: LD_ADDR_OWVAR 20
12386: PUSH
12387: LD_INT 7
12389: ST_TO_ADDR
// uc_nation := 1 ;
12390: LD_ADDR_OWVAR 21
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_INT 125
12405: PUSH
12406: LD_INT 163
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: LD_INT 185
12415: PUSH
12416: LD_INT 168
12418: PUSH
12419: EMPTY
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 111
12425: PUSH
12426: LD_INT 97
12428: PUSH
12429: EMPTY
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: PPUSH
12438: CALL 101079 0 1
12442: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12443: LD_ADDR_EXP 91
12447: PUSH
12448: EMPTY
12449: ST_TO_ADDR
// for i = 1 to Difficulty do
12450: LD_ADDR_VAR 0 1
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_OWVAR 67
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12624
// begin InitHc ;
12468: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12472: LD_INT 0
12474: PPUSH
12475: LD_INT 8
12477: PPUSH
12478: CALL_OW 381
// un := CreateHuman ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: CALL_OW 44
12491: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12492: LD_VAR 0 2
12496: PPUSH
12497: LD_INT 258
12499: PPUSH
12500: LD_INT 267
12502: PPUSH
12503: LD_INT 4
12505: PPUSH
12506: LD_INT 0
12508: PPUSH
12509: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12513: LD_ADDR_EXP 91
12517: PUSH
12518: LD_EXP 91
12522: PUSH
12523: LD_VAR 0 2
12527: UNION
12528: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12529: LD_VAR 0 2
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 1
12547: ARRAY
12548: PPUSH
12549: LD_VAR 0 3
12553: PUSH
12554: LD_VAR 0 1
12558: ARRAY
12559: PUSH
12560: LD_INT 2
12562: ARRAY
12563: PPUSH
12564: LD_INT 4
12566: PPUSH
12567: LD_INT 1
12569: PPUSH
12570: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12574: LD_VAR 0 2
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 1
12592: ARRAY
12593: PPUSH
12594: LD_VAR 0 3
12598: PUSH
12599: LD_VAR 0 1
12603: ARRAY
12604: PUSH
12605: LD_INT 2
12607: ARRAY
12608: PPUSH
12609: CALL_OW 171
// AddComInvisible ( un ) ;
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL_OW 212
// end ;
12622: GO 12465
12624: POP
12625: POP
// repeat wait ( 0 0$20 ) ;
12626: LD_INT 700
12628: PPUSH
12629: CALL_OW 67
// for i in allianceSpecialForce do
12633: LD_ADDR_VAR 0 1
12637: PUSH
12638: LD_EXP 91
12642: PUSH
12643: FOR_IN
12644: IFFALSE 12879
// begin if IsInvisible ( i ) then
12646: LD_VAR 0 1
12650: PPUSH
12651: CALL_OW 571
12655: IFFALSE 12848
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12657: LD_ADDR_VAR 0 3
12661: PUSH
12662: LD_INT 22
12664: PUSH
12665: LD_INT 1
12667: PUSH
12668: EMPTY
12669: LIST
12670: LIST
12671: PUSH
12672: LD_INT 50
12674: PUSH
12675: EMPTY
12676: LIST
12677: PUSH
12678: LD_INT 56
12680: PUSH
12681: EMPTY
12682: LIST
12683: PUSH
12684: LD_INT 91
12686: PUSH
12687: LD_VAR 0 1
12691: PUSH
12692: LD_INT 25
12694: PUSH
12695: LD_INT 30
12697: PUSH
12698: LD_INT 35
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: LIST
12705: PUSH
12706: LD_OWVAR 67
12710: ARRAY
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: LIST
12716: PUSH
12717: LD_INT 2
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 1
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: LD_INT 25
12732: PUSH
12733: LD_INT 2
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PUSH
12740: LD_INT 25
12742: PUSH
12743: LD_INT 3
12745: PUSH
12746: EMPTY
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 25
12752: PUSH
12753: LD_INT 4
12755: PUSH
12756: EMPTY
12757: LIST
12758: LIST
12759: PUSH
12760: LD_INT 25
12762: PUSH
12763: LD_INT 5
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 25
12772: PUSH
12773: LD_INT 8
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 3
12805: NOT
12806: IFFALSE 12810
// continue ;
12808: GO 12643
// if Prob ( 30 * Difficulty ) then
12810: LD_INT 30
12812: PUSH
12813: LD_OWVAR 67
12817: MUL
12818: PPUSH
12819: CALL_OW 13
12823: IFFALSE 12848
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12825: LD_VAR 0 3
12829: PUSH
12830: LD_INT 1
12832: PPUSH
12833: LD_VAR 0 3
12837: PPUSH
12838: CALL_OW 12
12842: ARRAY
12843: PPUSH
12844: CALL 31141 0 1
// end ; if IsDead ( i ) then
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 301
12857: IFFALSE 12877
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12859: LD_ADDR_EXP 91
12863: PUSH
12864: LD_EXP 91
12868: PUSH
12869: LD_VAR 0 1
12873: DIFF
12874: ST_TO_ADDR
// continue ;
12875: GO 12643
// end ; end ;
12877: GO 12643
12879: POP
12880: POP
// until allianceDestroyed or not allianceSpecialForce ;
12881: LD_EXP 23
12885: PUSH
12886: LD_EXP 91
12890: NOT
12891: OR
12892: IFFALSE 12626
// end ;
12894: PPOPN 3
12896: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12897: LD_EXP 23
12901: NOT
12902: PUSH
12903: LD_EXP 31
12907: AND
12908: IFFALSE 13875
12910: GO 12912
12912: DISABLE
12913: LD_INT 0
12915: PPUSH
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12920: LD_INT 22
12922: PUSH
12923: LD_INT 7
12925: PUSH
12926: EMPTY
12927: LIST
12928: LIST
12929: PUSH
12930: LD_INT 30
12932: PUSH
12933: LD_INT 3
12935: PUSH
12936: EMPTY
12937: LIST
12938: LIST
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PPUSH
12944: CALL_OW 69
12948: NOT
12949: IFFALSE 12953
// exit ;
12951: GO 13875
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12953: LD_ADDR_VAR 0 4
12957: PUSH
12958: LD_INT 22
12960: PUSH
12961: LD_INT 7
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 30
12970: PUSH
12971: LD_INT 34
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PPUSH
12982: CALL_OW 69
12986: ST_TO_ADDR
// if Prob ( 40 ) then
12987: LD_INT 40
12989: PPUSH
12990: CALL_OW 13
12994: IFFALSE 13121
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 5
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 6
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 5
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 2
13025: PUSH
13026: LD_INT 6
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 6
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 24
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 45
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 3
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 47
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58760 0 2
// end else
13119: GO 13244
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 24
13126: PUSH
13127: LD_INT 3
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 47
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 24
13144: PUSH
13145: LD_INT 3
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 47
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PUSH
13160: LD_INT 5
13162: PUSH
13163: LD_INT 3
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: EMPTY
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: PUSH
13178: LD_INT 5
13180: PUSH
13181: LD_INT 3
13183: PUSH
13184: LD_INT 2
13186: PUSH
13187: LD_INT 9
13189: PUSH
13190: EMPTY
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 24
13198: PUSH
13199: LD_INT 1
13201: PUSH
13202: LD_INT 3
13204: PUSH
13205: LD_INT 45
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 1
13219: PUSH
13220: LD_INT 3
13222: PUSH
13223: LD_INT 45
13225: PUSH
13226: EMPTY
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: PPUSH
13240: CALL 58760 0 2
// end ; if Difficulty > 1 then
13244: LD_OWVAR 67
13248: PUSH
13249: LD_INT 1
13251: GREATER
13252: IFFALSE 13282
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13254: LD_INT 1
13256: PPUSH
13257: LD_INT 24
13259: PUSH
13260: LD_INT 3
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 47
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: PUSH
13275: EMPTY
13276: LIST
13277: PPUSH
13278: CALL 58760 0 2
// repeat wait ( 0 0$1 ) ;
13282: LD_INT 35
13284: PPUSH
13285: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13289: LD_INT 1
13291: PPUSH
13292: LD_INT 1
13294: PPUSH
13295: CALL 60178 0 2
13299: PUSH
13300: LD_INT 6
13302: PUSH
13303: LD_INT 7
13305: PUSH
13306: LD_INT 7
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: PUSH
13314: LD_OWVAR 67
13318: ARRAY
13319: GREATEREQUAL
13320: IFFALSE 13282
// wait ( 0 0$40 ) ;
13322: LD_INT 1400
13324: PPUSH
13325: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13329: LD_ADDR_VAR 0 2
13333: PUSH
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 1
13339: PPUSH
13340: CALL 60178 0 2
13344: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13345: LD_ADDR_EXP 131
13349: PUSH
13350: LD_EXP 131
13354: PPUSH
13355: LD_INT 1
13357: PPUSH
13358: LD_EXP 131
13362: PUSH
13363: LD_INT 1
13365: ARRAY
13366: PUSH
13367: LD_VAR 0 2
13371: DIFF
13372: PPUSH
13373: CALL_OW 1
13377: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13378: LD_ADDR_VAR 0 3
13382: PUSH
13383: LD_INT 0
13385: PPUSH
13386: LD_INT 1
13388: PPUSH
13389: CALL_OW 12
13393: ST_TO_ADDR
// if target then
13394: LD_VAR 0 3
13398: IFFALSE 13564
// begin for i in tmp do
13400: LD_ADDR_VAR 0 1
13404: PUSH
13405: LD_VAR 0 2
13409: PUSH
13410: FOR_IN
13411: IFFALSE 13436
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13413: LD_VAR 0 1
13417: PPUSH
13418: LD_INT 179
13420: PPUSH
13421: LD_INT 209
13423: PPUSH
13424: LD_INT 8
13426: PPUSH
13427: LD_INT 1
13429: PPUSH
13430: CALL_OW 483
13434: GO 13410
13436: POP
13437: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: LD_INT 24
13450: PUSH
13451: LD_INT 250
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PPUSH
13458: CALL_OW 72
13462: ST_TO_ADDR
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13514
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13476: LD_VAR 0 1
13480: PPUSH
13481: LD_INT 179
13483: PPUSH
13484: LD_INT 209
13486: PPUSH
13487: CALL_OW 297
13491: PUSH
13492: LD_INT 9
13494: GREATER
13495: IFFALSE 13512
// ComMoveXY ( i , 179 , 209 ) ;
13497: LD_VAR 0 1
13501: PPUSH
13502: LD_INT 179
13504: PPUSH
13505: LD_INT 209
13507: PPUSH
13508: CALL_OW 111
13512: GO 13473
13514: POP
13515: POP
// wait ( 0 0$1 ) ;
13516: LD_INT 35
13518: PPUSH
13519: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: LD_INT 92
13530: PUSH
13531: LD_INT 179
13533: PUSH
13534: LD_INT 209
13536: PUSH
13537: LD_INT 9
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: PPUSH
13546: CALL_OW 72
13550: PUSH
13551: LD_VAR 0 2
13555: PUSH
13556: LD_INT 1
13558: MINUS
13559: GREATEREQUAL
13560: IFFALSE 13438
// end else
13562: GO 13726
// begin for i in tmp do
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_VAR 0 2
13573: PUSH
13574: FOR_IN
13575: IFFALSE 13600
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_INT 285
13584: PPUSH
13585: LD_INT 163
13587: PPUSH
13588: LD_INT 8
13590: PPUSH
13591: LD_INT 1
13593: PPUSH
13594: CALL_OW 483
13598: GO 13574
13600: POP
13601: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13602: LD_ADDR_VAR 0 2
13606: PUSH
13607: LD_VAR 0 2
13611: PPUSH
13612: LD_INT 24
13614: PUSH
13615: LD_INT 250
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PPUSH
13622: CALL_OW 72
13626: ST_TO_ADDR
// for i in tmp do
13627: LD_ADDR_VAR 0 1
13631: PUSH
13632: LD_VAR 0 2
13636: PUSH
13637: FOR_IN
13638: IFFALSE 13678
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13640: LD_VAR 0 1
13644: PPUSH
13645: LD_INT 285
13647: PPUSH
13648: LD_INT 163
13650: PPUSH
13651: CALL_OW 297
13655: PUSH
13656: LD_INT 9
13658: GREATER
13659: IFFALSE 13676
// ComMoveXY ( i , 285 , 163 ) ;
13661: LD_VAR 0 1
13665: PPUSH
13666: LD_INT 285
13668: PPUSH
13669: LD_INT 163
13671: PPUSH
13672: CALL_OW 111
13676: GO 13637
13678: POP
13679: POP
// wait ( 0 0$1 ) ;
13680: LD_INT 35
13682: PPUSH
13683: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13687: LD_VAR 0 2
13691: PPUSH
13692: LD_INT 92
13694: PUSH
13695: LD_INT 285
13697: PUSH
13698: LD_INT 163
13700: PUSH
13701: LD_INT 9
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: PPUSH
13710: CALL_OW 72
13714: PUSH
13715: LD_VAR 0 2
13719: PUSH
13720: LD_INT 1
13722: MINUS
13723: GREATEREQUAL
13724: IFFALSE 13602
// end ; repeat wait ( 0 0$1 ) ;
13726: LD_INT 35
13728: PPUSH
13729: CALL_OW 67
// for i in tmp do
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_VAR 0 2
13742: PUSH
13743: FOR_IN
13744: IFFALSE 13866
// if GetLives ( i ) > 251 then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 256
13755: PUSH
13756: LD_INT 251
13758: GREATER
13759: IFFALSE 13848
// begin if GetWeapon ( i ) = ru_time_lapser then
13761: LD_VAR 0 1
13765: PPUSH
13766: CALL_OW 264
13770: PUSH
13771: LD_INT 49
13773: EQUAL
13774: IFFALSE 13812
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13776: LD_VAR 0 1
13780: PPUSH
13781: LD_INT 81
13783: PUSH
13784: LD_INT 7
13786: PUSH
13787: EMPTY
13788: LIST
13789: LIST
13790: PPUSH
13791: CALL_OW 69
13795: PPUSH
13796: LD_VAR 0 1
13800: PPUSH
13801: CALL_OW 74
13805: PPUSH
13806: CALL_OW 112
13810: GO 13846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13812: LD_VAR 0 1
13816: PPUSH
13817: LD_INT 81
13819: PUSH
13820: LD_INT 7
13822: PUSH
13823: EMPTY
13824: LIST
13825: LIST
13826: PPUSH
13827: CALL_OW 69
13831: PPUSH
13832: LD_VAR 0 1
13836: PPUSH
13837: CALL_OW 74
13841: PPUSH
13842: CALL_OW 115
// end else
13846: GO 13864
// tmp := tmp diff i ;
13848: LD_ADDR_VAR 0 2
13852: PUSH
13853: LD_VAR 0 2
13857: PUSH
13858: LD_VAR 0 1
13862: DIFF
13863: ST_TO_ADDR
13864: GO 13743
13866: POP
13867: POP
// until not tmp ;
13868: LD_VAR 0 2
13872: NOT
13873: IFFALSE 13726
// end ; end_of_file
13875: PPOPN 4
13877: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13878: LD_INT 0
13880: PPUSH
13881: PPUSH
13882: PPUSH
13883: PPUSH
// missionStage := 13 ;
13884: LD_ADDR_EXP 15
13888: PUSH
13889: LD_INT 13
13891: ST_TO_ADDR
// uc_side := 2 ;
13892: LD_ADDR_OWVAR 20
13896: PUSH
13897: LD_INT 2
13899: ST_TO_ADDR
// uc_nation := 2 ;
13900: LD_ADDR_OWVAR 21
13904: PUSH
13905: LD_INT 2
13907: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13908: LD_ADDR_EXP 92
13912: PUSH
13913: LD_STRING Omar
13915: PPUSH
13916: CALL_OW 25
13920: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13921: LD_EXP 92
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13933: LD_EXP 92
13937: PPUSH
13938: LD_INT 242
13940: PPUSH
13941: LD_INT 75
13943: PPUSH
13944: LD_INT 0
13946: PPUSH
13947: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13951: LD_ADDR_EXP 93
13955: PUSH
13956: LD_STRING Heike
13958: PPUSH
13959: CALL_OW 25
13963: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13964: LD_INT 14
13966: PPUSH
13967: LD_INT 3
13969: PPUSH
13970: LD_INT 1
13972: PPUSH
13973: LD_INT 27
13975: PPUSH
13976: LD_INT 100
13978: PPUSH
13979: CALL 69928 0 5
// veh := CreateVehicle ;
13983: LD_ADDR_VAR 0 3
13987: PUSH
13988: CALL_OW 45
13992: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13993: LD_VAR 0 3
13997: PPUSH
13998: LD_INT 1
14000: PPUSH
14001: CALL_OW 242
// SetDir ( veh , 4 ) ;
14005: LD_VAR 0 3
14009: PPUSH
14010: LD_INT 4
14012: PPUSH
14013: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 241
14024: PPUSH
14025: LD_INT 72
14027: PPUSH
14028: LD_INT 0
14030: PPUSH
14031: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14035: LD_EXP 93
14039: PPUSH
14040: LD_VAR 0 3
14044: PPUSH
14045: CALL_OW 52
// if KhatamStatus then
14049: LD_EXP 8
14053: IFFALSE 14104
// begin Khatam := NewCharacter ( Khatam ) ;
14055: LD_ADDR_EXP 94
14059: PUSH
14060: LD_STRING Khatam
14062: PPUSH
14063: CALL_OW 25
14067: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14068: LD_EXP 94
14072: PPUSH
14073: LD_INT 245
14075: PPUSH
14076: LD_INT 78
14078: PPUSH
14079: LD_INT 3
14081: PPUSH
14082: LD_INT 0
14084: PPUSH
14085: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14089: LD_EXP 94
14093: PPUSH
14094: LD_INT 4
14096: PPUSH
14097: LD_INT 10
14099: PPUSH
14100: CALL_OW 237
// end ; for i = 1 to Difficulty do
14104: LD_ADDR_VAR 0 2
14108: PUSH
14109: DOUBLE
14110: LD_INT 1
14112: DEC
14113: ST_TO_ADDR
14114: LD_OWVAR 67
14118: PUSH
14119: FOR_TO
14120: IFFALSE 14186
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14122: LD_INT 0
14124: PPUSH
14125: LD_INT 7
14127: PUSH
14128: LD_OWVAR 67
14132: PLUS
14133: PPUSH
14134: CALL_OW 384
// un := CreateHuman ;
14138: LD_ADDR_VAR 0 4
14142: PUSH
14143: CALL_OW 44
14147: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14148: LD_VAR 0 4
14152: PPUSH
14153: LD_INT 28
14155: PUSH
14156: LD_INT 29
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: PUSH
14163: LD_VAR 0 2
14167: PUSH
14168: LD_INT 2
14170: MOD
14171: PUSH
14172: LD_INT 1
14174: PLUS
14175: ARRAY
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14119
14186: POP
14187: POP
// for i = 1 to 6 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 6
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14247
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14204: LD_INT 0
14206: PPUSH
14207: LD_INT 7
14209: PUSH
14210: LD_OWVAR 67
14214: PLUS
14215: PPUSH
14216: CALL_OW 381
// un := CreateHuman ;
14220: LD_ADDR_VAR 0 4
14224: PUSH
14225: CALL_OW 44
14229: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14230: LD_VAR 0 4
14234: PPUSH
14235: LD_INT 28
14237: PPUSH
14238: LD_INT 0
14240: PPUSH
14241: CALL_OW 49
// end ;
14245: GO 14201
14247: POP
14248: POP
// for i = 1 to 3 do
14249: LD_ADDR_VAR 0 2
14253: PUSH
14254: DOUBLE
14255: LD_INT 1
14257: DEC
14258: ST_TO_ADDR
14259: LD_INT 3
14261: PUSH
14262: FOR_TO
14263: IFFALSE 14311
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14265: LD_INT 0
14267: PPUSH
14268: LD_INT 8
14270: PPUSH
14271: LD_INT 7
14273: PUSH
14274: LD_OWVAR 67
14278: PLUS
14279: PPUSH
14280: CALL_OW 380
// un := CreateHuman ;
14284: LD_ADDR_VAR 0 4
14288: PUSH
14289: CALL_OW 44
14293: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14294: LD_VAR 0 4
14298: PPUSH
14299: LD_INT 28
14301: PPUSH
14302: LD_INT 0
14304: PPUSH
14305: CALL_OW 49
// end ;
14309: GO 14262
14311: POP
14312: POP
// for i = 1 to 3 do
14313: LD_ADDR_VAR 0 2
14317: PUSH
14318: DOUBLE
14319: LD_INT 1
14321: DEC
14322: ST_TO_ADDR
14323: LD_INT 3
14325: PUSH
14326: FOR_TO
14327: IFFALSE 14417
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14329: LD_INT 14
14331: PPUSH
14332: LD_INT 2
14334: PPUSH
14335: LD_INT 1
14337: PPUSH
14338: LD_INT 28
14340: PPUSH
14341: LD_INT 80
14343: PPUSH
14344: CALL 69928 0 5
// veh := CreateVehicle ;
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: CALL_OW 45
14357: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 3
14365: PPUSH
14366: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_INT 29
14377: PPUSH
14378: LD_INT 0
14380: PPUSH
14381: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14385: LD_INT 0
14387: PPUSH
14388: LD_INT 7
14390: PUSH
14391: LD_OWVAR 67
14395: PLUS
14396: PPUSH
14397: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14401: CALL_OW 44
14405: PPUSH
14406: LD_VAR 0 3
14410: PPUSH
14411: CALL_OW 52
// end ;
14415: GO 14326
14417: POP
14418: POP
// for i = 1 to 5 + Difficulty do
14419: LD_ADDR_VAR 0 2
14423: PUSH
14424: DOUBLE
14425: LD_INT 1
14427: DEC
14428: ST_TO_ADDR
14429: LD_INT 5
14431: PUSH
14432: LD_OWVAR 67
14436: PLUS
14437: PUSH
14438: FOR_TO
14439: IFFALSE 14566
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14441: LD_INT 14
14443: PPUSH
14444: LD_INT 1
14446: PPUSH
14447: LD_INT 3
14449: PPUSH
14450: CALL_OW 12
14454: PPUSH
14455: LD_INT 1
14457: PPUSH
14458: LD_INT 28
14460: PUSH
14461: LD_INT 26
14463: PUSH
14464: LD_INT 27
14466: PUSH
14467: LD_INT 25
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PUSH
14476: LD_VAR 0 2
14480: PUSH
14481: LD_INT 4
14483: MOD
14484: PUSH
14485: LD_INT 1
14487: PLUS
14488: ARRAY
14489: PPUSH
14490: LD_INT 80
14492: PPUSH
14493: CALL 69928 0 5
// veh := CreateVehicle ;
14497: LD_ADDR_VAR 0 3
14501: PUSH
14502: CALL_OW 45
14506: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14507: LD_VAR 0 3
14511: PPUSH
14512: LD_INT 4
14514: PPUSH
14515: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14519: LD_VAR 0 3
14523: PPUSH
14524: LD_INT 28
14526: PPUSH
14527: LD_INT 0
14529: PPUSH
14530: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14534: LD_INT 0
14536: PPUSH
14537: LD_INT 7
14539: PUSH
14540: LD_OWVAR 67
14544: PLUS
14545: PPUSH
14546: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14550: CALL_OW 44
14554: PPUSH
14555: LD_VAR 0 3
14559: PPUSH
14560: CALL_OW 52
// end ;
14564: GO 14438
14566: POP
14567: POP
// for i = 1 to 3 do
14568: LD_ADDR_VAR 0 2
14572: PUSH
14573: DOUBLE
14574: LD_INT 1
14576: DEC
14577: ST_TO_ADDR
14578: LD_INT 3
14580: PUSH
14581: FOR_TO
14582: IFFALSE 14642
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14584: LD_INT 14
14586: PPUSH
14587: LD_INT 3
14589: PPUSH
14590: LD_INT 5
14592: PPUSH
14593: LD_INT 29
14595: PPUSH
14596: LD_INT 80
14598: PPUSH
14599: CALL 69928 0 5
// veh := CreateVehicle ;
14603: LD_ADDR_VAR 0 3
14607: PUSH
14608: CALL_OW 45
14612: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 4
14620: PPUSH
14621: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14625: LD_VAR 0 3
14629: PPUSH
14630: LD_INT 28
14632: PPUSH
14633: LD_INT 0
14635: PPUSH
14636: CALL_OW 49
// end ;
14640: GO 14581
14642: POP
14643: POP
// end ;
14644: LD_VAR 0 1
14648: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14649: LD_INT 22
14651: PUSH
14652: LD_INT 2
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: IFFALSE 14963
14665: GO 14667
14667: DISABLE
14668: LD_INT 0
14670: PPUSH
14671: PPUSH
14672: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 22
14680: PUSH
14681: LD_INT 2
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: PUSH
14688: LD_INT 25
14690: PUSH
14691: LD_INT 4
14693: PUSH
14694: EMPTY
14695: LIST
14696: LIST
14697: PUSH
14698: EMPTY
14699: LIST
14700: LIST
14701: PPUSH
14702: CALL_OW 69
14706: PUSH
14707: LD_EXP 94
14711: DIFF
14712: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14713: LD_ADDR_VAR 0 2
14717: PUSH
14718: LD_INT 22
14720: PUSH
14721: LD_INT 2
14723: PUSH
14724: EMPTY
14725: LIST
14726: LIST
14727: PPUSH
14728: CALL_OW 69
14732: PUSH
14733: LD_EXP 94
14737: PUSH
14738: LD_VAR 0 3
14742: UNION
14743: DIFF
14744: ST_TO_ADDR
// if Khatam then
14745: LD_EXP 94
14749: IFFALSE 14766
// ComMoveXY ( Khatam , 211 , 92 ) ;
14751: LD_EXP 94
14755: PPUSH
14756: LD_INT 211
14758: PPUSH
14759: LD_INT 92
14761: PPUSH
14762: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14766: LD_INT 197
14768: PPUSH
14769: LD_INT 80
14771: PPUSH
14772: LD_INT 2
14774: PPUSH
14775: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14779: LD_INT 213
14781: PPUSH
14782: LD_INT 90
14784: PPUSH
14785: LD_INT 2
14787: PPUSH
14788: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14792: LD_INT 215
14794: PPUSH
14795: LD_INT 129
14797: PPUSH
14798: LD_INT 2
14800: PPUSH
14801: CALL_OW 441
// if sci then
14805: LD_VAR 0 3
14809: IFFALSE 14830
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14811: LD_VAR 0 3
14815: PUSH
14816: LD_INT 1
14818: ARRAY
14819: PPUSH
14820: LD_INT 197
14822: PPUSH
14823: LD_INT 80
14825: PPUSH
14826: CALL_OW 158
// if sci > 1 then
14830: LD_VAR 0 3
14834: PUSH
14835: LD_INT 1
14837: GREATER
14838: IFFALSE 14859
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14840: LD_VAR 0 3
14844: PUSH
14845: LD_INT 2
14847: ARRAY
14848: PPUSH
14849: LD_INT 213
14851: PPUSH
14852: LD_INT 90
14854: PPUSH
14855: CALL_OW 158
// if sci > 2 then
14859: LD_VAR 0 3
14863: PUSH
14864: LD_INT 2
14866: GREATER
14867: IFFALSE 14888
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14869: LD_VAR 0 3
14873: PUSH
14874: LD_INT 3
14876: ARRAY
14877: PPUSH
14878: LD_INT 215
14880: PPUSH
14881: LD_INT 129
14883: PPUSH
14884: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14888: LD_INT 35
14890: PPUSH
14891: CALL_OW 67
// for i in tmp do
14895: LD_ADDR_VAR 0 1
14899: PUSH
14900: LD_VAR 0 2
14904: PUSH
14905: FOR_IN
14906: IFFALSE 14944
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14908: LD_VAR 0 1
14912: PPUSH
14913: LD_INT 81
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: EMPTY
14920: LIST
14921: LIST
14922: PPUSH
14923: CALL_OW 69
14927: PPUSH
14928: LD_VAR 0 1
14932: PPUSH
14933: CALL_OW 74
14937: PPUSH
14938: CALL_OW 115
14942: GO 14905
14944: POP
14945: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14946: LD_INT 22
14948: PUSH
14949: LD_INT 2
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: CALL_OW 69
14960: NOT
14961: IFFALSE 14888
// end ; end_of_file
14963: PPOPN 3
14965: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14966: LD_INT 0
14968: PPUSH
14969: PPUSH
14970: PPUSH
14971: PPUSH
14972: PPUSH
14973: PPUSH
14974: PPUSH
14975: PPUSH
14976: PPUSH
// Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 100946 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14984: LD_ADDR_VAR 0 5
14988: PUSH
14989: LD_INT 7
14991: PPUSH
14992: LD_INT 0
14994: PPUSH
14995: CALL_OW 517
14999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15000: LD_ADDR_VAR 0 2
15004: PUSH
15005: DOUBLE
15006: LD_INT 1
15008: DEC
15009: ST_TO_ADDR
15010: LD_VAR 0 5
15014: PUSH
15015: LD_INT 1
15017: ARRAY
15018: PUSH
15019: FOR_TO
15020: IFFALSE 15065
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 2
15044: ARRAY
15045: PUSH
15046: LD_VAR 0 2
15050: ARRAY
15051: PPUSH
15052: LD_INT 1
15054: PPUSH
15055: LD_INT 15
15057: NEG
15058: PPUSH
15059: CALL 100860 0 4
15063: GO 15019
15065: POP
15066: POP
// CenterNowOnUnits ( Powell ) ;
15067: LD_EXP 58
15071: PPUSH
15072: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: LD_EXP 56
15085: PUSH
15086: EMPTY
15087: LIST
15088: ST_TO_ADDR
// if GirlNewVeh then
15089: LD_EXP 57
15093: IFFALSE 15111
// tmp := tmp ^ GirlNewVeh ;
15095: LD_ADDR_VAR 0 5
15099: PUSH
15100: LD_VAR 0 5
15104: PUSH
15105: LD_EXP 57
15109: ADD
15110: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15111: LD_VAR 0 5
15115: PPUSH
15116: LD_INT 60
15118: PPUSH
15119: LD_INT 109
15121: PPUSH
15122: CALL_OW 111
// if KappaStatus then
15126: LD_EXP 2
15130: IFFALSE 15182
// begin Say ( JMM , D1nT-JMM-1 ) ;
15132: LD_EXP 39
15136: PPUSH
15137: LD_STRING D1nT-JMM-1
15139: PPUSH
15140: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15144: LD_EXP 58
15148: PPUSH
15149: LD_STRING D1T-Pow-1
15151: PPUSH
15152: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15156: LD_EXP 39
15160: PPUSH
15161: LD_STRING D1T-JMM-2
15163: PPUSH
15164: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15168: LD_EXP 58
15172: PPUSH
15173: LD_STRING D1T-Pow-2
15175: PPUSH
15176: CALL_OW 88
// end else
15180: GO 15388
// if JMMGirlStatus then
15182: LD_EXP 6
15186: IFFALSE 15331
// begin Say ( JMM , D1T-JMM-1 ) ;
15188: LD_EXP 39
15192: PPUSH
15193: LD_STRING D1T-JMM-1
15195: PPUSH
15196: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15200: LD_EXP 58
15204: PPUSH
15205: LD_STRING D1T-Pow-1
15207: PPUSH
15208: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15212: LD_EXP 39
15216: PPUSH
15217: LD_STRING D1T-JMM-3
15219: PPUSH
15220: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15224: LD_EXP 58
15228: PPUSH
15229: LD_STRING D1T-Pow-3
15231: PPUSH
15232: CALL_OW 88
// if JMMGirl then
15236: LD_EXP 7
15240: IFFALSE 15329
// begin case JMMGirl of 1 :
15242: LD_EXP 7
15246: PUSH
15247: LD_INT 1
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15270
15255: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15256: LD_EXP 40
15260: PPUSH
15261: LD_STRING D1T-Joan-3
15263: PPUSH
15264: CALL_OW 88
15268: GO 15317
15270: LD_INT 2
15272: DOUBLE
15273: EQUAL
15274: IFTRUE 15278
15276: GO 15293
15278: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15279: LD_EXP 42
15283: PPUSH
15284: LD_STRING D1T-Lisa-3
15286: PPUSH
15287: CALL_OW 88
15291: GO 15317
15293: LD_INT 3
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15316
15301: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15302: LD_EXP 54
15306: PPUSH
15307: LD_STRING D1T-Con-3
15309: PPUSH
15310: CALL_OW 88
15314: GO 15317
15316: POP
// Say ( Powell , D1T-Pow-4 ) ;
15317: LD_EXP 58
15321: PPUSH
15322: LD_STRING D1T-Pow-4
15324: PPUSH
15325: CALL_OW 88
// end ; end else
15329: GO 15388
// if not FastEnd then
15331: LD_EXP 11
15335: NOT
15336: IFFALSE 15364
// begin Say ( JMM , D1T-JMM-4 ) ;
15338: LD_EXP 39
15342: PPUSH
15343: LD_STRING D1T-JMM-4
15345: PPUSH
15346: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15350: LD_EXP 58
15354: PPUSH
15355: LD_STRING D1T-Pow-5
15357: PPUSH
15358: CALL_OW 88
// end else
15362: GO 15388
// begin Say ( JMM , D1nT-JMM-1 ) ;
15364: LD_EXP 39
15368: PPUSH
15369: LD_STRING D1nT-JMM-1
15371: PPUSH
15372: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15376: LD_EXP 58
15380: PPUSH
15381: LD_STRING D1nT-Pow-1
15383: PPUSH
15384: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15388: LD_INT 35
15390: PPUSH
15391: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15395: LD_EXP 56
15399: PPUSH
15400: CALL_OW 314
15404: NOT
15405: IFFALSE 15388
// ComExitVehicle ( JMM ) ;
15407: LD_EXP 39
15411: PPUSH
15412: CALL_OW 121
// wait ( 3 ) ;
15416: LD_INT 3
15418: PPUSH
15419: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_INT 60
15430: PPUSH
15431: LD_INT 94
15433: PPUSH
15434: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15438: LD_EXP 39
15442: PPUSH
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 179
// if Joan then
15452: LD_EXP 40
15456: IFFALSE 15510
// begin ComExitVehicle ( Joan ) ;
15458: LD_EXP 40
15462: PPUSH
15463: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15467: LD_EXP 40
15471: PPUSH
15472: LD_INT 35
15474: PPUSH
15475: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_INT 65
15486: PPUSH
15487: LD_INT 104
15489: PPUSH
15490: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15494: LD_EXP 40
15498: PPUSH
15499: LD_EXP 39
15503: PPUSH
15504: CALL_OW 179
// end else
15508: GO 15644
// if Lisa and JMMGirl = 2 then
15510: LD_EXP 42
15514: PUSH
15515: LD_EXP 7
15519: PUSH
15520: LD_INT 2
15522: EQUAL
15523: AND
15524: IFFALSE 15578
// begin ComExitVehicle ( Lisa ) ;
15526: LD_EXP 42
15530: PPUSH
15531: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15535: LD_EXP 42
15539: PPUSH
15540: LD_INT 35
15542: PPUSH
15543: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_INT 65
15554: PPUSH
15555: LD_INT 104
15557: PPUSH
15558: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15562: LD_EXP 42
15566: PPUSH
15567: LD_EXP 39
15571: PPUSH
15572: CALL_OW 179
// end else
15576: GO 15644
// if Connie and JMMGirl = 3 then
15578: LD_EXP 54
15582: PUSH
15583: LD_EXP 7
15587: PUSH
15588: LD_INT 3
15590: EQUAL
15591: AND
15592: IFFALSE 15644
// begin ComExitVehicle ( Connie ) ;
15594: LD_EXP 54
15598: PPUSH
15599: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15603: LD_EXP 54
15607: PPUSH
15608: LD_INT 35
15610: PPUSH
15611: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_INT 65
15622: PPUSH
15623: LD_INT 104
15625: PPUSH
15626: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15630: LD_EXP 54
15634: PPUSH
15635: LD_EXP 39
15639: PPUSH
15640: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15644: LD_INT 35
15646: PPUSH
15647: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15651: LD_EXP 39
15655: PPUSH
15656: LD_EXP 58
15660: PPUSH
15661: CALL_OW 296
15665: PUSH
15666: LD_INT 6
15668: LESS
15669: IFFALSE 15644
// wait ( 0 0$0.5 ) ;
15671: LD_INT 18
15673: PPUSH
15674: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15678: LD_EXP 39
15682: PPUSH
15683: LD_STRING D1-JMM-1
15685: PPUSH
15686: CALL_OW 88
// async ;
15690: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15691: LD_EXP 58
15695: PPUSH
15696: LD_STRING D1-Pow-1
15698: PPUSH
15699: CALL_OW 88
// if not dialogue_skipped then
15703: LD_OWVAR 59
15707: NOT
15708: IFFALSE 15717
// wait ( 0 0$2 ) ;
15710: LD_INT 70
15712: PPUSH
15713: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15717: LD_INT 170
15719: PPUSH
15720: LD_INT 99
15722: PPUSH
15723: LD_INT 1
15725: PPUSH
15726: LD_INT 6
15728: NEG
15729: PPUSH
15730: CALL 100860 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15734: LD_INT 174
15736: PPUSH
15737: LD_INT 115
15739: PPUSH
15740: LD_INT 1
15742: PPUSH
15743: LD_INT 6
15745: NEG
15746: PPUSH
15747: CALL 100860 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15751: LD_INT 169
15753: PPUSH
15754: LD_INT 71
15756: PPUSH
15757: LD_INT 1
15759: PPUSH
15760: LD_INT 6
15762: NEG
15763: PPUSH
15764: CALL 100860 0 4
// if not dialogue_skipped then
15768: LD_OWVAR 59
15772: NOT
15773: IFFALSE 15792
// begin CenterOnXY ( 170 , 99 ) ;
15775: LD_INT 170
15777: PPUSH
15778: LD_INT 99
15780: PPUSH
15781: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15785: LD_INT 80
15787: PPUSH
15788: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15792: LD_INT 75
15794: PPUSH
15795: LD_INT 53
15797: PPUSH
15798: LD_INT 1
15800: PPUSH
15801: LD_INT 9
15803: NEG
15804: PPUSH
15805: CALL 100860 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15809: LD_INT 54
15811: PPUSH
15812: LD_INT 42
15814: PPUSH
15815: LD_INT 1
15817: PPUSH
15818: LD_INT 9
15820: NEG
15821: PPUSH
15822: CALL 100860 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15826: LD_INT 62
15828: PPUSH
15829: LD_INT 51
15831: PPUSH
15832: LD_INT 1
15834: PPUSH
15835: LD_INT 9
15837: NEG
15838: PPUSH
15839: CALL 100860 0 4
// if not dialogue_skipped then
15843: LD_OWVAR 59
15847: NOT
15848: IFFALSE 15867
// begin CenterOnXY ( 75 , 53 ) ;
15850: LD_INT 75
15852: PPUSH
15853: LD_INT 53
15855: PPUSH
15856: CALL_OW 84
// wait ( 0 0$4 ) ;
15860: LD_INT 140
15862: PPUSH
15863: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15867: LD_EXP 58
15871: PPUSH
15872: CALL_OW 87
// if not dialogue_skipped then
15876: LD_OWVAR 59
15880: NOT
15881: IFFALSE 15890
// wait ( 0 0$2 ) ;
15883: LD_INT 70
15885: PPUSH
15886: CALL_OW 67
// sync ;
15890: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15891: LD_EXP 39
15895: PPUSH
15896: LD_STRING D1-JMM-2
15898: PPUSH
15899: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15903: LD_EXP 58
15907: PPUSH
15908: LD_STRING D1-Pow-2
15910: PPUSH
15911: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15915: LD_EXP 39
15919: PPUSH
15920: LD_STRING D1-JMM-3
15922: PPUSH
15923: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15927: LD_EXP 58
15931: PPUSH
15932: LD_STRING D1-Pow-3
15934: PPUSH
15935: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15939: LD_EXP 39
15943: PPUSH
15944: LD_STRING D1-JMM-4
15946: PPUSH
15947: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15951: LD_EXP 58
15955: PPUSH
15956: LD_STRING D1-Pow-4
15958: PPUSH
15959: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15963: LD_EXP 39
15967: PPUSH
15968: LD_STRING D1-JMM-5
15970: PPUSH
15971: CALL_OW 88
// async ;
15975: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15976: LD_EXP 58
15980: PPUSH
15981: LD_STRING D1-Pow-5
15983: PPUSH
15984: CALL_OW 88
// if not dialogue_skipped then
15988: LD_OWVAR 59
15992: NOT
15993: IFFALSE 16002
// wait ( 0 0$3.6 ) ;
15995: LD_INT 126
15997: PPUSH
15998: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16002: LD_INT 134
16004: PPUSH
16005: LD_INT 210
16007: PPUSH
16008: LD_INT 1
16010: PPUSH
16011: LD_INT 11
16013: NEG
16014: PPUSH
16015: CALL 100860 0 4
// if not dialogue_skipped then
16019: LD_OWVAR 59
16023: NOT
16024: IFFALSE 16043
// begin CenterOnXY ( 134 , 210 ) ;
16026: LD_INT 134
16028: PPUSH
16029: LD_INT 210
16031: PPUSH
16032: CALL_OW 84
// wait ( 0 0$2 ) ;
16036: LD_INT 70
16038: PPUSH
16039: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16043: LD_INT 101
16045: PPUSH
16046: LD_INT 159
16048: PPUSH
16049: LD_INT 1
16051: PPUSH
16052: LD_INT 10
16054: NEG
16055: PPUSH
16056: CALL 100860 0 4
// if not dialogue_skipped then
16060: LD_OWVAR 59
16064: NOT
16065: IFFALSE 16084
// begin CenterOnXY ( 101 , 159 ) ;
16067: LD_INT 101
16069: PPUSH
16070: LD_INT 159
16072: PPUSH
16073: CALL_OW 84
// wait ( 0 0$2 ) ;
16077: LD_INT 70
16079: PPUSH
16080: CALL_OW 67
// end ; sync ;
16084: SYNC
// CenterNowOnUnits ( Powell ) ;
16085: LD_EXP 58
16089: PPUSH
16090: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: LD_INT 2
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: LD_INT 4
16110: PUSH
16111: LD_INT 5
16113: PUSH
16114: LD_INT 6
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: LIST
16121: LIST
16122: LIST
16123: LIST
16124: ST_TO_ADDR
// if not dialogue_skipped then
16125: LD_OWVAR 59
16129: NOT
16130: IFFALSE 16299
// begin game_speed := 4 ;
16132: LD_ADDR_OWVAR 65
16136: PUSH
16137: LD_INT 4
16139: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16140: LD_INT 210
16142: PPUSH
16143: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16147: LD_ADDR_VAR 0 7
16151: PUSH
16152: LD_STRING Q1
16154: PPUSH
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 98
16164: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16165: LD_ADDR_VAR 0 7
16169: PUSH
16170: LD_STRING Q1
16172: PPUSH
16173: LD_VAR 0 6
16177: PPUSH
16178: CALL_OW 98
16182: ST_TO_ADDR
// options = options diff dec ;
16183: LD_ADDR_VAR 0 6
16187: PUSH
16188: LD_VAR 0 6
16192: PUSH
16193: LD_VAR 0 7
16197: DIFF
16198: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16199: LD_VAR 0 7
16203: PPUSH
16204: LD_VAR 0 6
16208: PPUSH
16209: CALL 17771 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16213: LD_VAR 0 7
16217: PUSH
16218: LD_INT 5
16220: PUSH
16221: LD_INT 6
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: IN
16228: PUSH
16229: LD_VAR 0 6
16233: PUSH
16234: LD_INT 2
16236: EQUAL
16237: OR
16238: IFFALSE 16165
// if not ( dec in [ 5 , 6 ] ) then
16240: LD_VAR 0 7
16244: PUSH
16245: LD_INT 5
16247: PUSH
16248: LD_INT 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: LIST
16254: IN
16255: NOT
16256: IFFALSE 16299
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16258: LD_ADDR_VAR 0 7
16262: PUSH
16263: LD_STRING Q1a
16265: PPUSH
16266: LD_INT 1
16268: PUSH
16269: LD_INT 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PPUSH
16276: CALL_OW 98
16280: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16281: LD_VAR 0 7
16285: PUSH
16286: LD_INT 4
16288: PLUS
16289: PPUSH
16290: LD_VAR 0 6
16294: PPUSH
16295: CALL 17771 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16299: LD_INT 81
16301: PPUSH
16302: LD_INT 127
16304: PPUSH
16305: CALL_OW 84
// amount := 5 ;
16309: LD_ADDR_VAR 0 8
16313: PUSH
16314: LD_INT 5
16316: ST_TO_ADDR
// macmilan_squad := [ ] ;
16317: LD_ADDR_VAR 0 9
16321: PUSH
16322: EMPTY
16323: ST_TO_ADDR
// if vip < amount then
16324: LD_EXP 59
16328: PUSH
16329: LD_VAR 0 8
16333: LESS
16334: IFFALSE 16378
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16336: LD_ADDR_VAR 0 5
16340: PUSH
16341: LD_EXP 59
16345: PUSH
16346: LD_INT 22
16348: PUSH
16349: LD_INT 4
16351: PUSH
16352: EMPTY
16353: LIST
16354: LIST
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PPUSH
16370: CALL_OW 69
16374: UNION
16375: ST_TO_ADDR
16376: GO 16388
// tmp := vip ;
16378: LD_ADDR_VAR 0 5
16382: PUSH
16383: LD_EXP 59
16387: ST_TO_ADDR
// tmp := tmp diff Powell ;
16388: LD_ADDR_VAR 0 5
16392: PUSH
16393: LD_VAR 0 5
16397: PUSH
16398: LD_EXP 58
16402: DIFF
16403: ST_TO_ADDR
// if tmp < amount then
16404: LD_VAR 0 5
16408: PUSH
16409: LD_VAR 0 8
16413: LESS
16414: IFFALSE 16426
// amount := tmp ;
16416: LD_ADDR_VAR 0 8
16420: PUSH
16421: LD_VAR 0 5
16425: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16426: LD_VAR 0 5
16430: PUSH
16431: LD_INT 1
16433: ARRAY
16434: PPUSH
16435: CALL_OW 257
16439: PUSH
16440: LD_INT 2
16442: NONEQUAL
16443: IFFALSE 16505
// begin if IsInUnit ( tmp [ 1 ] ) then
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 310
16458: IFFALSE 16473
// ComExitBuilding ( tmp [ 1 ] ) ;
16460: LD_VAR 0 5
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16473: LD_VAR 0 5
16477: PUSH
16478: LD_INT 1
16480: ARRAY
16481: PPUSH
16482: LD_INT 387
16484: PPUSH
16485: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16489: LD_VAR 0 5
16493: PUSH
16494: LD_INT 1
16496: ARRAY
16497: PPUSH
16498: LD_INT 2
16500: PPUSH
16501: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_INT 82
16512: PPUSH
16513: LD_INT 129
16515: PPUSH
16516: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16520: LD_EXP 39
16524: PPUSH
16525: LD_EXP 58
16529: PPUSH
16530: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16534: LD_INT 22
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: PUSH
16549: LD_EXP 39
16553: DIFF
16554: PPUSH
16555: LD_INT 84
16557: PPUSH
16558: LD_INT 128
16560: PPUSH
16561: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PPUSH
16575: CALL_OW 69
16579: PUSH
16580: LD_EXP 39
16584: DIFF
16585: PPUSH
16586: LD_EXP 39
16590: PPUSH
16591: CALL_OW 179
// for i = 1 to amount do
16595: LD_ADDR_VAR 0 2
16599: PUSH
16600: DOUBLE
16601: LD_INT 1
16603: DEC
16604: ST_TO_ADDR
16605: LD_VAR 0 8
16609: PUSH
16610: FOR_TO
16611: IFFALSE 16779
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16613: LD_ADDR_VAR 0 9
16617: PUSH
16618: LD_VAR 0 9
16622: PUSH
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 2
16632: ARRAY
16633: ADD
16634: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 2
16644: ARRAY
16645: PPUSH
16646: CALL_OW 310
16650: IFFALSE 16667
// AddComExitBuilding ( tmp [ i ] ) ;
16652: LD_VAR 0 5
16656: PUSH
16657: LD_VAR 0 2
16661: ARRAY
16662: PPUSH
16663: CALL_OW 182
// if i = 2 and JMMNewVeh then
16667: LD_VAR 0 2
16671: PUSH
16672: LD_INT 2
16674: EQUAL
16675: PUSH
16676: LD_EXP 56
16680: AND
16681: IFFALSE 16739
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 2
16692: ARRAY
16693: PPUSH
16694: LD_EXP 56
16698: PPUSH
16699: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16703: LD_VAR 0 5
16707: PUSH
16708: LD_VAR 0 2
16712: ARRAY
16713: PPUSH
16714: LD_INT 86
16716: PPUSH
16717: LD_INT 133
16719: PPUSH
16720: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16739: LD_VAR 0 5
16743: PUSH
16744: LD_VAR 0 2
16748: ARRAY
16749: PPUSH
16750: LD_INT 8
16752: PPUSH
16753: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: LD_EXP 39
16772: PPUSH
16773: CALL_OW 179
// end ;
16777: GO 16610
16779: POP
16780: POP
// if GirlNewVeh then
16781: LD_EXP 57
16785: IFFALSE 16799
// SetSide ( GirlNewVeh , 4 ) ;
16787: LD_EXP 57
16791: PPUSH
16792: LD_INT 4
16794: PPUSH
16795: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16799: LD_INT 35
16801: PPUSH
16802: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16806: LD_VAR 0 9
16810: PPUSH
16811: LD_INT 95
16813: PUSH
16814: LD_INT 9
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: PPUSH
16821: CALL_OW 72
16825: PUSH
16826: LD_INT 0
16828: EQUAL
16829: PUSH
16830: LD_EXP 39
16834: PPUSH
16835: LD_INT 9
16837: PPUSH
16838: CALL_OW 308
16842: NOT
16843: AND
16844: IFFALSE 16799
// wait ( 0 0$2 ) ;
16846: LD_INT 70
16848: PPUSH
16849: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16853: LD_VAR 0 9
16857: PPUSH
16858: LD_INT 1
16860: PPUSH
16861: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16865: LD_INT 21
16867: PUSH
16868: LD_INT 2
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 92
16877: PUSH
16878: LD_INT 83
16880: PUSH
16881: LD_INT 130
16883: PUSH
16884: LD_INT 10
16886: PUSH
16887: EMPTY
16888: LIST
16889: LIST
16890: LIST
16891: LIST
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PPUSH
16902: LD_INT 1
16904: PPUSH
16905: CALL_OW 235
// Video ( false ) ;
16909: LD_INT 0
16911: PPUSH
16912: CALL 100946 0 1
// ChangeMissionObjectives ( M1 ) ;
16916: LD_STRING M1
16918: PPUSH
16919: CALL_OW 337
// SaveForQuickRestart ;
16923: CALL_OW 22
// missionStart := true ;
16927: LD_ADDR_EXP 13
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// missionStage := 2 ;
16935: LD_ADDR_EXP 15
16939: PUSH
16940: LD_INT 2
16942: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16943: LD_INT 105
16945: PPUSH
16946: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16950: LD_ADDR_VAR 0 5
16954: PUSH
16955: LD_INT 22
16957: PUSH
16958: LD_INT 4
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PUSH
16965: LD_INT 21
16967: PUSH
16968: LD_INT 1
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PPUSH
16979: CALL_OW 69
16983: PUSH
16984: LD_EXP 58
16988: DIFF
16989: ST_TO_ADDR
// if not tmp then
16990: LD_VAR 0 5
16994: NOT
16995: IFFALSE 17010
// tmp := [ Powell ] ;
16997: LD_ADDR_VAR 0 5
17001: PUSH
17002: LD_EXP 58
17006: PUSH
17007: EMPTY
17008: LIST
17009: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17010: LD_ADDR_EXP 112
17014: PUSH
17015: LD_EXP 112
17019: PPUSH
17020: LD_INT 4
17022: PPUSH
17023: LD_INT 22
17025: PUSH
17026: LD_INT 4
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: PUSH
17033: LD_INT 23
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: PUSH
17043: LD_INT 3
17045: PUSH
17046: LD_INT 21
17048: PUSH
17049: LD_INT 2
17051: PUSH
17052: EMPTY
17053: LIST
17054: LIST
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: PPUSH
17065: CALL_OW 69
17069: PUSH
17070: LD_EXP 58
17074: DIFF
17075: PPUSH
17076: CALL_OW 1
17080: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17081: LD_ADDR_VAR 0 4
17085: PUSH
17086: LD_INT 22
17088: PUSH
17089: LD_INT 4
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 34
17098: PUSH
17099: LD_INT 12
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: PPUSH
17110: CALL_OW 69
17114: PUSH
17115: LD_INT 1
17117: ARRAY
17118: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 310
17132: IFFALSE 17147
// ComExitBuilding ( tmp [ 1 ] ) ;
17134: LD_VAR 0 5
17138: PUSH
17139: LD_INT 1
17141: ARRAY
17142: PPUSH
17143: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17147: LD_VAR 0 5
17151: PUSH
17152: LD_INT 1
17154: ARRAY
17155: PPUSH
17156: LD_VAR 0 4
17160: PPUSH
17161: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17165: LD_VAR 0 5
17169: PUSH
17170: LD_INT 1
17172: ARRAY
17173: PPUSH
17174: LD_INT 80
17176: PPUSH
17177: LD_INT 136
17179: PPUSH
17180: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17184: LD_VAR 0 5
17188: PUSH
17189: LD_INT 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17197: LD_VAR 0 5
17201: PUSH
17202: LD_INT 1
17204: ARRAY
17205: PPUSH
17206: LD_INT 59
17208: PPUSH
17209: LD_INT 112
17211: PPUSH
17212: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17216: LD_VAR 0 5
17220: PUSH
17221: LD_INT 1
17223: ARRAY
17224: PPUSH
17225: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17229: LD_EXP 40
17233: PUSH
17234: LD_EXP 40
17238: PPUSH
17239: CALL_OW 255
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: AND
17248: IFFALSE 17274
// begin Say ( Joan , D3W-Joan-1 ) ;
17250: LD_EXP 40
17254: PPUSH
17255: LD_STRING D3W-Joan-1
17257: PPUSH
17258: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17262: LD_EXP 39
17266: PPUSH
17267: LD_STRING D3W-JMM-1
17269: PPUSH
17270: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17274: LD_EXP 42
17278: PUSH
17279: LD_EXP 42
17283: PPUSH
17284: CALL_OW 255
17288: PUSH
17289: LD_INT 1
17291: EQUAL
17292: AND
17293: PUSH
17294: LD_EXP 42
17298: PUSH
17299: LD_EXP 59
17303: IN
17304: NOT
17305: AND
17306: IFFALSE 17332
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17308: LD_EXP 42
17312: PPUSH
17313: LD_STRING D3W-Lisa-1
17315: PPUSH
17316: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17320: LD_EXP 39
17324: PPUSH
17325: LD_STRING D3W-JMM-1
17327: PPUSH
17328: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17332: LD_EXP 54
17336: PUSH
17337: LD_EXP 54
17341: PPUSH
17342: CALL_OW 255
17346: PUSH
17347: LD_INT 1
17349: EQUAL
17350: AND
17351: IFFALSE 17377
// begin Say ( Connie , D3W-Con-1 ) ;
17353: LD_EXP 54
17357: PPUSH
17358: LD_STRING D3W-Con-1
17360: PPUSH
17361: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17365: LD_EXP 39
17369: PPUSH
17370: LD_STRING D3W-JMM-1
17372: PPUSH
17373: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17377: LD_EXP 42
17381: PUSH
17382: LD_EXP 59
17386: IN
17387: PUSH
17388: LD_EXP 42
17392: PPUSH
17393: CALL_OW 255
17397: PUSH
17398: LD_INT 1
17400: EQUAL
17401: AND
17402: IFFALSE 17418
// Say ( Lisa , D3nW-Lisa-1 ) else
17404: LD_EXP 42
17408: PPUSH
17409: LD_STRING D3nW-Lisa-1
17411: PPUSH
17412: CALL_OW 88
17416: GO 17662
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17418: LD_EXP 45
17422: PUSH
17423: LD_EXP 59
17427: IN
17428: PUSH
17429: LD_EXP 45
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 1
17441: EQUAL
17442: AND
17443: IFFALSE 17459
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17445: LD_EXP 45
17449: PPUSH
17450: LD_STRING D3nW-Cyrus-1
17452: PPUSH
17453: CALL_OW 88
17457: GO 17662
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17459: LD_EXP 44
17463: PUSH
17464: LD_EXP 59
17468: IN
17469: PUSH
17470: LD_EXP 44
17474: PPUSH
17475: CALL_OW 255
17479: PUSH
17480: LD_INT 1
17482: EQUAL
17483: AND
17484: IFFALSE 17500
// Say ( Bobby , D3nW-Bobby-1 ) else
17486: LD_EXP 44
17490: PPUSH
17491: LD_STRING D3nW-Bobby-1
17493: PPUSH
17494: CALL_OW 88
17498: GO 17662
// if Gary in vip and GetSide ( Gary ) = 1 then
17500: LD_EXP 51
17504: PUSH
17505: LD_EXP 59
17509: IN
17510: PUSH
17511: LD_EXP 51
17515: PPUSH
17516: CALL_OW 255
17520: PUSH
17521: LD_INT 1
17523: EQUAL
17524: AND
17525: IFFALSE 17541
// Say ( Gary , D3nW-Gary-1 ) else
17527: LD_EXP 51
17531: PPUSH
17532: LD_STRING D3nW-Gary-1
17534: PPUSH
17535: CALL_OW 88
17539: GO 17662
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17541: LD_EXP 43
17545: PUSH
17546: LD_EXP 59
17550: IN
17551: PUSH
17552: LD_EXP 43
17556: PPUSH
17557: CALL_OW 255
17561: PUSH
17562: LD_INT 1
17564: EQUAL
17565: AND
17566: IFFALSE 17582
// Say ( Donaldson , D3nW-Don-1 ) else
17568: LD_EXP 43
17572: PPUSH
17573: LD_STRING D3nW-Don-1
17575: PPUSH
17576: CALL_OW 88
17580: GO 17662
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17582: LD_EXP 50
17586: PUSH
17587: LD_EXP 59
17591: IN
17592: PUSH
17593: LD_EXP 50
17597: PPUSH
17598: CALL_OW 255
17602: PUSH
17603: LD_INT 1
17605: EQUAL
17606: AND
17607: IFFALSE 17623
// Say ( Cornel , D3nW-Corn-1 ) else
17609: LD_EXP 50
17613: PPUSH
17614: LD_STRING D3nW-Corn-1
17616: PPUSH
17617: CALL_OW 88
17621: GO 17662
// if Frank in vip and GetSide ( Frank ) = 1 then
17623: LD_EXP 52
17627: PUSH
17628: LD_EXP 59
17632: IN
17633: PUSH
17634: LD_EXP 52
17638: PPUSH
17639: CALL_OW 255
17643: PUSH
17644: LD_INT 1
17646: EQUAL
17647: AND
17648: IFFALSE 17662
// Say ( Frank , D3nW-Frank-1 ) ;
17650: LD_EXP 52
17654: PPUSH
17655: LD_STRING D3nW-Frank-1
17657: PPUSH
17658: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17662: LD_EXP 59
17666: PPUSH
17667: LD_INT 22
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PPUSH
17677: CALL_OW 72
17681: IFFALSE 17707
// begin Say ( JMM , D3nW-JMM-1 ) ;
17683: LD_EXP 39
17687: PPUSH
17688: LD_STRING D3nW-JMM-1
17690: PPUSH
17691: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17695: LD_EXP 39
17699: PPUSH
17700: LD_STRING D3nW-JMM-1a
17702: PPUSH
17703: CALL_OW 88
// end ; t := 0 0$00 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_INT 0
17714: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17715: LD_INT 35
17717: PPUSH
17718: CALL_OW 67
// t := t + 0 0$1 ;
17722: LD_ADDR_VAR 0 3
17726: PUSH
17727: LD_VAR 0 3
17731: PUSH
17732: LD_INT 35
17734: PLUS
17735: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17736: LD_INT 59
17738: PPUSH
17739: LD_INT 112
17741: PPUSH
17742: CALL_OW 428
17746: PUSH
17747: LD_VAR 0 3
17751: PUSH
17752: LD_INT 2100
17754: GREATER
17755: OR
17756: IFFALSE 17715
// activeAttacks := true ;
17758: LD_ADDR_EXP 16
17762: PUSH
17763: LD_INT 1
17765: ST_TO_ADDR
// end ;
17766: LD_VAR 0 1
17770: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17771: LD_INT 0
17773: PPUSH
// case question of 1 :
17774: LD_VAR 0 1
17778: PUSH
17779: LD_INT 1
17781: DOUBLE
17782: EQUAL
17783: IFTRUE 17787
17785: GO 17838
17787: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D2Mot-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17800: LD_EXP 58
17804: PPUSH
17805: LD_STRING D2Mot-Pow-1
17807: PPUSH
17808: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17812: LD_EXP 39
17816: PPUSH
17817: LD_STRING D2Mot-JMM-2
17819: PPUSH
17820: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17824: LD_EXP 58
17828: PPUSH
17829: LD_STRING D2Mot-Pow-2
17831: PPUSH
17832: CALL_OW 88
// end ; 2 :
17836: GO 18189
17838: LD_INT 2
17840: DOUBLE
17841: EQUAL
17842: IFTRUE 17846
17844: GO 17922
17846: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17847: LD_EXP 39
17851: PPUSH
17852: LD_STRING D2Rus-JMM-1
17854: PPUSH
17855: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17859: LD_EXP 58
17863: PPUSH
17864: LD_STRING D2Rus-Pow-1
17866: PPUSH
17867: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17871: LD_EXP 39
17875: PPUSH
17876: LD_STRING D2Rus-JMM-2
17878: PPUSH
17879: CALL_OW 88
// if not ( 3 in list_of_q ) then
17883: LD_INT 3
17885: PUSH
17886: LD_VAR 0 2
17890: IN
17891: NOT
17892: IFFALSE 17908
// Say ( Powell , D2Rus-Pow-2 ) else
17894: LD_EXP 58
17898: PPUSH
17899: LD_STRING D2Rus-Pow-2
17901: PPUSH
17902: CALL_OW 88
17906: GO 17920
// Say ( Powell , D2Rus-Pow-2a ) ;
17908: LD_EXP 58
17912: PPUSH
17913: LD_STRING D2Rus-Pow-2a
17915: PPUSH
17916: CALL_OW 88
// end ; 3 :
17920: GO 18189
17922: LD_INT 3
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18015
17930: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17931: LD_EXP 39
17935: PPUSH
17936: LD_STRING D2Leg-JMM-1
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17943: LD_EXP 58
17947: PPUSH
17948: LD_STRING D2Leg-Pow-1
17950: PPUSH
17951: CALL_OW 88
// if 2 in list_of_q then
17955: LD_INT 2
17957: PUSH
17958: LD_VAR 0 2
17962: IN
17963: IFFALSE 17989
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17965: LD_EXP 39
17969: PPUSH
17970: LD_STRING D2Leg-JMM-2
17972: PPUSH
17973: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17977: LD_EXP 58
17981: PPUSH
17982: LD_STRING D2Leg-Pow-2
17984: PPUSH
17985: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17989: LD_EXP 39
17993: PPUSH
17994: LD_STRING D2Leg-JMM-3
17996: PPUSH
17997: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18001: LD_EXP 58
18005: PPUSH
18006: LD_STRING D2Leg-Pow-3
18008: PPUSH
18009: CALL_OW 88
// end ; 4 :
18013: GO 18189
18015: LD_INT 4
18017: DOUBLE
18018: EQUAL
18019: IFTRUE 18023
18021: GO 18098
18023: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18024: LD_EXP 39
18028: PPUSH
18029: LD_STRING D2Ar-JMM-1
18031: PPUSH
18032: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18036: LD_EXP 58
18040: PPUSH
18041: LD_STRING D2Ar-Pow-1
18043: PPUSH
18044: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18048: LD_EXP 39
18052: PPUSH
18053: LD_STRING D2Ar-JMM-2
18055: PPUSH
18056: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18060: LD_EXP 58
18064: PPUSH
18065: LD_STRING D2Ar-Pow-2
18067: PPUSH
18068: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18072: LD_EXP 39
18076: PPUSH
18077: LD_STRING D2Ar-JMM-3
18079: PPUSH
18080: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18084: LD_EXP 58
18088: PPUSH
18089: LD_STRING D2Ar-Pow-3
18091: PPUSH
18092: CALL_OW 88
// end ; 5 :
18096: GO 18189
18098: LD_INT 5
18100: DOUBLE
18101: EQUAL
18102: IFTRUE 18106
18104: GO 18121
18106: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18107: LD_EXP 39
18111: PPUSH
18112: LD_STRING D2Conf-JMM-1
18114: PPUSH
18115: CALL_OW 88
18119: GO 18189
18121: LD_INT 6
18123: DOUBLE
18124: EQUAL
18125: IFTRUE 18129
18127: GO 18188
18129: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18130: LD_EXP 39
18134: PPUSH
18135: LD_STRING D2Com-JMM-1
18137: PPUSH
18138: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18142: LD_EXP 58
18146: PPUSH
18147: LD_STRING D2Com-Pow-1
18149: PPUSH
18150: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18154: LD_EXP 39
18158: PPUSH
18159: LD_STRING D2Com-JMM-2
18161: PPUSH
18162: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18166: LD_EXP 58
18170: PPUSH
18171: LD_STRING D2Com-Pow-2
18173: PPUSH
18174: CALL_OW 88
// powellAngerQuery := true ;
18178: LD_ADDR_EXP 36
18182: PUSH
18183: LD_INT 1
18185: ST_TO_ADDR
// end ; end ;
18186: GO 18189
18188: POP
// end ;
18189: LD_VAR 0 3
18193: RET
// every 0 0$5 trigger missionStart do var tmp ;
18194: LD_EXP 13
18198: IFFALSE 18481
18200: GO 18202
18202: DISABLE
18203: LD_INT 0
18205: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18206: LD_INT 35
18208: PPUSH
18209: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18213: LD_INT 14
18215: PPUSH
18216: LD_INT 22
18218: PUSH
18219: LD_INT 1
18221: PUSH
18222: EMPTY
18223: LIST
18224: LIST
18225: PPUSH
18226: CALL_OW 70
18230: PUSH
18231: LD_EXP 15
18235: PUSH
18236: LD_INT 2
18238: PUSH
18239: LD_INT 3
18241: PUSH
18242: LD_INT 4
18244: PUSH
18245: LD_INT 5
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: IN
18254: AND
18255: IFFALSE 18471
// begin powellAnger := powellAnger + 1 ;
18257: LD_ADDR_EXP 17
18261: PUSH
18262: LD_EXP 17
18266: PUSH
18267: LD_INT 1
18269: PLUS
18270: ST_TO_ADDR
// Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 100946 0 1
// CenterNowOnUnits ( tmp ) ;
18278: LD_VAR 0 1
18282: PPUSH
18283: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18287: LD_INT 14
18289: PPUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 1
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PPUSH
18300: CALL_OW 70
18304: PPUSH
18305: LD_INT 86
18307: PPUSH
18308: LD_INT 133
18310: PPUSH
18311: CALL_OW 111
// async ;
18315: ASYNC
// case powellAnger of 1 :
18316: LD_EXP 17
18320: PUSH
18321: LD_INT 1
18323: DOUBLE
18324: EQUAL
18325: IFTRUE 18329
18327: GO 18344
18329: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18330: LD_EXP 58
18334: PPUSH
18335: LD_STRING DBack1-Pow-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18391
18344: LD_INT 2
18346: DOUBLE
18347: EQUAL
18348: IFTRUE 18352
18350: GO 18367
18352: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18353: LD_EXP 58
18357: PPUSH
18358: LD_STRING DBack2-Pow-1
18360: PPUSH
18361: CALL_OW 88
18365: GO 18391
18367: LD_INT 3
18369: DOUBLE
18370: EQUAL
18371: IFTRUE 18375
18373: GO 18390
18375: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18376: LD_EXP 58
18380: PPUSH
18381: LD_STRING DBack3-Pow-1
18383: PPUSH
18384: CALL_OW 88
18388: GO 18391
18390: POP
// sync ;
18391: SYNC
// repeat wait ( 0 0$1 ) ;
18392: LD_INT 35
18394: PPUSH
18395: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18399: LD_INT 14
18401: PPUSH
18402: LD_INT 22
18404: PUSH
18405: LD_INT 1
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PPUSH
18412: CALL_OW 70
18416: PPUSH
18417: LD_INT 86
18419: PPUSH
18420: LD_INT 133
18422: PPUSH
18423: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18427: LD_INT 14
18429: PPUSH
18430: LD_INT 22
18432: PUSH
18433: LD_INT 1
18435: PUSH
18436: EMPTY
18437: LIST
18438: LIST
18439: PPUSH
18440: CALL_OW 70
18444: NOT
18445: IFFALSE 18392
// if powellAnger >= 3 then
18447: LD_EXP 17
18451: PUSH
18452: LD_INT 3
18454: GREATEREQUAL
18455: IFFALSE 18464
// YouLost ( Dismissed ) ;
18457: LD_STRING Dismissed
18459: PPUSH
18460: CALL_OW 104
// Video ( false ) ;
18464: LD_INT 0
18466: PPUSH
18467: CALL 100946 0 1
// end ; until missionStage > 5 ;
18471: LD_EXP 15
18475: PUSH
18476: LD_INT 5
18478: GREATER
18479: IFFALSE 18206
// end ;
18481: PPOPN 1
18483: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18484: LD_EXP 13
18488: PUSH
18489: LD_INT 22
18491: PUSH
18492: LD_INT 4
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 21
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: EMPTY
18510: LIST
18511: LIST
18512: PPUSH
18513: CALL_OW 69
18517: PUSH
18518: LD_INT 4
18520: GREATEREQUAL
18521: AND
18522: PUSH
18523: LD_EXP 15
18527: PUSH
18528: LD_INT 2
18530: EQUAL
18531: AND
18532: IFFALSE 20355
18534: GO 18536
18536: DISABLE
18537: LD_INT 0
18539: PPUSH
18540: PPUSH
18541: PPUSH
18542: PPUSH
18543: PPUSH
18544: PPUSH
18545: PPUSH
18546: PPUSH
// begin missionStage := 3 ;
18547: LD_ADDR_EXP 15
18551: PUSH
18552: LD_INT 3
18554: ST_TO_ADDR
// retreat := false ;
18555: LD_ADDR_VAR 0 4
18559: PUSH
18560: LD_INT 0
18562: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18563: LD_ADDR_VAR 0 5
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 4
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 30
18580: PUSH
18581: LD_INT 4
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PPUSH
18592: CALL_OW 69
18596: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18597: LD_ADDR_VAR 0 6
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_INT 4
18607: PUSH
18608: EMPTY
18609: LIST
18610: LIST
18611: PUSH
18612: LD_INT 30
18614: PUSH
18615: LD_INT 5
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PPUSH
18626: CALL_OW 69
18630: ST_TO_ADDR
// if not bar then
18631: LD_VAR 0 6
18635: NOT
18636: IFFALSE 18689
// begin repeat wait ( 0 0$1 ) ;
18638: LD_INT 35
18640: PPUSH
18641: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18645: LD_INT 22
18647: PUSH
18648: LD_INT 4
18650: PUSH
18651: EMPTY
18652: LIST
18653: LIST
18654: PUSH
18655: LD_INT 3
18657: PUSH
18658: LD_INT 57
18660: PUSH
18661: EMPTY
18662: LIST
18663: PUSH
18664: EMPTY
18665: LIST
18666: LIST
18667: PUSH
18668: LD_INT 30
18670: PUSH
18671: LD_INT 5
18673: PUSH
18674: EMPTY
18675: LIST
18676: LIST
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: LIST
18682: PPUSH
18683: CALL_OW 69
18687: IFFALSE 18638
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18689: LD_ADDR_VAR 0 6
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 4
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 30
18706: PUSH
18707: LD_INT 5
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PPUSH
18718: CALL_OW 69
18722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18723: LD_INT 35
18725: PPUSH
18726: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18730: LD_EXP 131
18734: PUSH
18735: LD_INT 4
18737: ARRAY
18738: PUSH
18739: LD_INT 4
18741: GREATEREQUAL
18742: IFFALSE 18723
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18744: LD_ADDR_VAR 0 2
18748: PUSH
18749: LD_INT 22
18751: PUSH
18752: LD_INT 4
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: PUSH
18759: LD_INT 2
18761: PUSH
18762: LD_INT 25
18764: PUSH
18765: LD_INT 1
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: PUSH
18772: LD_INT 25
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 25
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: LD_INT 25
18794: PUSH
18795: LD_INT 4
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PUSH
18802: LD_INT 25
18804: PUSH
18805: LD_INT 5
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: PUSH
18820: EMPTY
18821: LIST
18822: LIST
18823: PPUSH
18824: CALL_OW 69
18828: PUSH
18829: LD_EXP 58
18833: PUSH
18834: LD_EXP 59
18838: ADD
18839: DIFF
18840: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18841: LD_ADDR_VAR 0 3
18845: PUSH
18846: LD_VAR 0 2
18850: PPUSH
18851: LD_INT 26
18853: PUSH
18854: LD_INT 1
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: PPUSH
18861: CALL_OW 72
18865: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18866: LD_ADDR_VAR 0 2
18870: PUSH
18871: LD_VAR 0 2
18875: PUSH
18876: LD_VAR 0 3
18880: DIFF
18881: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18882: LD_ADDR_VAR 0 2
18886: PUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: LD_INT 1
18894: PPUSH
18895: CALL 99599 0 2
18899: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 3
18909: PPUSH
18910: LD_INT 1
18912: PPUSH
18913: CALL 99599 0 2
18917: ST_TO_ADDR
// for i = 1 to 4 do
18918: LD_ADDR_VAR 0 1
18922: PUSH
18923: DOUBLE
18924: LD_INT 1
18926: DEC
18927: ST_TO_ADDR
18928: LD_INT 4
18930: PUSH
18931: FOR_TO
18932: IFFALSE 19098
// begin if tmp2 then
18934: LD_VAR 0 3
18938: IFFALSE 19019
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18940: LD_ADDR_EXP 18
18944: PUSH
18945: LD_EXP 18
18949: PPUSH
18950: LD_INT 1
18952: PPUSH
18953: LD_EXP 18
18957: PUSH
18958: LD_INT 1
18960: ARRAY
18961: PUSH
18962: LD_VAR 0 3
18966: PUSH
18967: LD_VAR 0 3
18971: ARRAY
18972: ADD
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18979: LD_VAR 0 3
18983: PUSH
18984: LD_VAR 0 3
18988: ARRAY
18989: PPUSH
18990: LD_INT 1
18992: PPUSH
18993: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18997: LD_ADDR_VAR 0 3
19001: PUSH
19002: LD_VAR 0 3
19006: PPUSH
19007: LD_VAR 0 3
19011: PPUSH
19012: CALL_OW 3
19016: ST_TO_ADDR
// end else
19017: GO 19096
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19019: LD_ADDR_EXP 18
19023: PUSH
19024: LD_EXP 18
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: LD_EXP 18
19036: PUSH
19037: LD_INT 1
19039: ARRAY
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 2
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19058: LD_VAR 0 2
19062: PUSH
19063: LD_VAR 0 2
19067: ARRAY
19068: PPUSH
19069: LD_INT 1
19071: PPUSH
19072: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19076: LD_ADDR_VAR 0 2
19080: PUSH
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_VAR 0 2
19090: PPUSH
19091: CALL_OW 3
19095: ST_TO_ADDR
// end ; end ;
19096: GO 18931
19098: POP
19099: POP
// if tmp2 then
19100: LD_VAR 0 3
19104: IFFALSE 19122
// tmp := tmp union tmp2 ;
19106: LD_ADDR_VAR 0 2
19110: PUSH
19111: LD_VAR 0 2
19115: PUSH
19116: LD_VAR 0 3
19120: UNION
19121: ST_TO_ADDR
// for i = 1 to 4 do
19122: LD_ADDR_VAR 0 1
19126: PUSH
19127: DOUBLE
19128: LD_INT 1
19130: DEC
19131: ST_TO_ADDR
19132: LD_INT 4
19134: PUSH
19135: FOR_TO
19136: IFFALSE 19185
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19138: LD_ADDR_EXP 18
19142: PUSH
19143: LD_EXP 18
19147: PPUSH
19148: LD_INT 2
19150: PPUSH
19151: LD_EXP 18
19155: PUSH
19156: LD_INT 2
19158: ARRAY
19159: PUSH
19160: LD_VAR 0 2
19164: PUSH
19165: LD_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: MINUS
19175: ARRAY
19176: ADD
19177: PPUSH
19178: CALL_OW 1
19182: ST_TO_ADDR
19183: GO 19135
19185: POP
19186: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19187: LD_ADDR_EXP 112
19191: PUSH
19192: LD_EXP 112
19196: PPUSH
19197: LD_INT 4
19199: PPUSH
19200: LD_EXP 112
19204: PUSH
19205: LD_INT 4
19207: ARRAY
19208: PUSH
19209: LD_EXP 18
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: DIFF
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19224: LD_VAR 0 5
19228: PUSH
19229: LD_INT 1
19231: ARRAY
19232: PPUSH
19233: CALL_OW 313
19237: IFFALSE 19292
// begin for i in UnitsInside ( arm [ 1 ] ) do
19239: LD_ADDR_VAR 0 1
19243: PUSH
19244: LD_VAR 0 5
19248: PUSH
19249: LD_INT 1
19251: ARRAY
19252: PPUSH
19253: CALL_OW 313
19257: PUSH
19258: FOR_IN
19259: IFFALSE 19290
// begin ComExitBuilding ( i ) ;
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19270: LD_VAR 0 1
19274: PPUSH
19275: LD_VAR 0 6
19279: PUSH
19280: LD_INT 1
19282: ARRAY
19283: PPUSH
19284: CALL_OW 180
// end ;
19288: GO 19258
19290: POP
19291: POP
// end ; wait ( 0 0$3 ) ;
19292: LD_INT 105
19294: PPUSH
19295: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19299: LD_ADDR_VAR 0 1
19303: PUSH
19304: LD_EXP 18
19308: PUSH
19309: LD_INT 1
19311: ARRAY
19312: PUSH
19313: FOR_IN
19314: IFFALSE 19421
// begin if IsInUnit ( i ) then
19316: LD_VAR 0 1
19320: PPUSH
19321: CALL_OW 310
19325: IFFALSE 19336
// ComExitBuilding ( i ) ;
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 122
// if GetClass ( i ) <> 1 then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 257
19345: PUSH
19346: LD_INT 1
19348: NONEQUAL
19349: IFFALSE 19390
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19351: LD_VAR 0 1
19355: PPUSH
19356: LD_VAR 0 5
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19369: LD_VAR 0 1
19373: PPUSH
19374: LD_INT 1
19376: PPUSH
19377: CALL_OW 183
// AddComExitBuilding ( i ) ;
19381: LD_VAR 0 1
19385: PPUSH
19386: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_INT 60
19397: PPUSH
19398: LD_INT 94
19400: PPUSH
19401: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19405: LD_VAR 0 1
19409: PPUSH
19410: LD_EXP 58
19414: PPUSH
19415: CALL_OW 179
// end ;
19419: GO 19313
19421: POP
19422: POP
// wait ( 0 0$15 ) ;
19423: LD_INT 525
19425: PPUSH
19426: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19430: LD_EXP 58
19434: PPUSH
19435: LD_STRING D4-Pow-1
19437: PPUSH
19438: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19442: LD_ADDR_VAR 0 2
19446: PUSH
19447: LD_EXP 18
19451: PUSH
19452: LD_INT 1
19454: ARRAY
19455: PPUSH
19456: LD_INT 26
19458: PUSH
19459: LD_INT 1
19461: PUSH
19462: EMPTY
19463: LIST
19464: LIST
19465: PPUSH
19466: CALL_OW 72
19470: ST_TO_ADDR
// if tmp then
19471: LD_VAR 0 2
19475: IFFALSE 19493
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19477: LD_VAR 0 2
19481: PUSH
19482: LD_INT 1
19484: ARRAY
19485: PPUSH
19486: LD_STRING D4-Sol1-1
19488: PPUSH
19489: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19493: LD_EXP 58
19497: PPUSH
19498: LD_STRING D4-Pow-2
19500: PPUSH
19501: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19505: LD_ADDR_VAR 0 1
19509: PUSH
19510: DOUBLE
19511: LD_INT 1
19513: DEC
19514: ST_TO_ADDR
19515: LD_EXP 18
19519: PUSH
19520: LD_INT 1
19522: ARRAY
19523: PUSH
19524: FOR_TO
19525: IFFALSE 19618
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PUSH
19536: LD_VAR 0 1
19540: ARRAY
19541: PPUSH
19542: LD_EXP 131
19546: PUSH
19547: LD_INT 4
19549: ARRAY
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19559: LD_ADDR_EXP 131
19563: PUSH
19564: LD_EXP 131
19568: PPUSH
19569: LD_INT 4
19571: PPUSH
19572: LD_EXP 131
19576: PUSH
19577: LD_INT 4
19579: ARRAY
19580: PPUSH
19581: LD_INT 1
19583: PPUSH
19584: CALL_OW 3
19588: PPUSH
19589: CALL_OW 1
19593: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19594: LD_INT 8
19596: PPUSH
19597: LD_EXP 18
19601: PUSH
19602: LD_INT 1
19604: ARRAY
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 471
// end ;
19616: GO 19524
19618: POP
19619: POP
// repeat wait ( 0 0$1 ) ;
19620: LD_INT 35
19622: PPUSH
19623: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19627: LD_EXP 18
19631: PUSH
19632: LD_INT 1
19634: ARRAY
19635: PPUSH
19636: LD_INT 55
19638: PUSH
19639: EMPTY
19640: LIST
19641: PPUSH
19642: CALL_OW 72
19646: PUSH
19647: LD_INT 4
19649: GREATEREQUAL
19650: IFFALSE 19620
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19652: LD_EXP 18
19656: PUSH
19657: LD_INT 1
19659: ARRAY
19660: PPUSH
19661: LD_INT 69
19663: PPUSH
19664: LD_INT 94
19666: PPUSH
19667: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19671: LD_EXP 18
19675: PUSH
19676: LD_INT 1
19678: ARRAY
19679: PPUSH
19680: LD_INT 82
19682: PPUSH
19683: LD_INT 83
19685: PPUSH
19686: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19690: LD_EXP 18
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PPUSH
19699: LD_INT 77
19701: PPUSH
19702: LD_INT 69
19704: PPUSH
19705: CALL_OW 174
// repeat wait ( 3 ) ;
19709: LD_INT 3
19711: PPUSH
19712: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19716: LD_ADDR_VAR 0 1
19720: PUSH
19721: LD_EXP 18
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: FOR_IN
19731: IFFALSE 19867
// begin if GetLives ( i ) < 990 then
19733: LD_VAR 0 1
19737: PPUSH
19738: CALL_OW 256
19742: PUSH
19743: LD_INT 990
19745: LESS
19746: IFFALSE 19760
// SetLives ( i , 1000 ) ;
19748: LD_VAR 0 1
19752: PPUSH
19753: LD_INT 1000
19755: PPUSH
19756: CALL_OW 234
// if not IsInUnit ( i ) then
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 310
19769: NOT
19770: IFFALSE 19865
// begin if not HasTask ( i ) then
19772: LD_VAR 0 1
19776: PPUSH
19777: CALL_OW 314
19781: NOT
19782: IFFALSE 19799
// ComMoveXY ( i , 64 , 93 ) ;
19784: LD_VAR 0 1
19788: PPUSH
19789: LD_INT 64
19791: PPUSH
19792: LD_INT 93
19794: PPUSH
19795: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19799: LD_VAR 0 4
19803: NOT
19804: PUSH
19805: LD_VAR 0 1
19809: PPUSH
19810: CALL_OW 258
19814: PUSH
19815: LD_INT 1
19817: EQUAL
19818: AND
19819: IFFALSE 19865
// begin retreat := true ;
19821: LD_ADDR_VAR 0 4
19825: PUSH
19826: LD_INT 1
19828: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_INT 2
19836: PPUSH
19837: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19841: LD_VAR 0 1
19845: PPUSH
19846: LD_STRING D4a-Sol1-1
19848: PPUSH
19849: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19853: LD_EXP 58
19857: PPUSH
19858: LD_STRING D4a-Pow-1
19860: PPUSH
19861: CALL_OW 88
// end ; end ; end ;
19865: GO 19730
19867: POP
19868: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19869: LD_EXP 18
19873: PUSH
19874: LD_INT 1
19876: ARRAY
19877: PPUSH
19878: LD_INT 95
19880: PUSH
19881: LD_INT 9
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 55
19893: PUSH
19894: EMPTY
19895: LIST
19896: PUSH
19897: EMPTY
19898: LIST
19899: LIST
19900: PUSH
19901: EMPTY
19902: LIST
19903: LIST
19904: PPUSH
19905: CALL_OW 72
19909: PUSH
19910: LD_INT 4
19912: GREATEREQUAL
19913: IFFALSE 19709
// for i in powellSquadAttack [ 1 ] do
19915: LD_ADDR_VAR 0 1
19919: PUSH
19920: LD_EXP 18
19924: PUSH
19925: LD_INT 1
19927: ARRAY
19928: PUSH
19929: FOR_IN
19930: IFFALSE 20066
// begin if GetTag ( i ) = 2 then
19932: LD_VAR 0 1
19936: PPUSH
19937: CALL_OW 110
19941: PUSH
19942: LD_INT 2
19944: EQUAL
19945: IFFALSE 20007
// begin ComMoveXY ( i , 60 , 94 ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_INT 60
19954: PPUSH
19955: LD_INT 94
19957: PPUSH
19958: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19962: LD_VAR 0 1
19966: PPUSH
19967: LD_EXP 58
19971: PPUSH
19972: CALL_OW 179
// wait ( 0 0$3 ) ;
19976: LD_INT 105
19978: PPUSH
19979: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19983: LD_VAR 0 1
19987: PPUSH
19988: LD_STRING D4a-Sol1-2
19990: PPUSH
19991: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19995: LD_EXP 58
19999: PPUSH
20000: LD_STRING D4a-Pow-2
20002: PPUSH
20003: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20007: LD_VAR 0 1
20011: PPUSH
20012: LD_INT 0
20014: PPUSH
20015: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20019: LD_ADDR_EXP 112
20023: PUSH
20024: LD_EXP 112
20028: PPUSH
20029: LD_INT 4
20031: PPUSH
20032: LD_EXP 112
20036: PUSH
20037: LD_INT 4
20039: ARRAY
20040: PUSH
20041: LD_VAR 0 1
20045: UNION
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20052: LD_INT 8
20054: PPUSH
20055: LD_VAR 0 1
20059: PPUSH
20060: CALL_OW 472
// end ;
20064: GO 19929
20066: POP
20067: POP
// wait ( 4 4$00 ) ;
20068: LD_INT 8400
20070: PPUSH
20071: CALL_OW 67
// uc_side := 6 ;
20075: LD_ADDR_OWVAR 20
20079: PUSH
20080: LD_INT 6
20082: ST_TO_ADDR
// uc_nation := 3 ;
20083: LD_ADDR_OWVAR 21
20087: PUSH
20088: LD_INT 3
20090: ST_TO_ADDR
// ru := [ ] ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: EMPTY
20097: ST_TO_ADDR
// for i = 1 to 4 do
20098: LD_ADDR_VAR 0 1
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_INT 4
20110: PUSH
20111: FOR_TO
20112: IFFALSE 20213
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20114: LD_INT 22
20116: PPUSH
20117: LD_INT 1
20119: PPUSH
20120: LD_INT 3
20122: PPUSH
20123: LD_INT 43
20125: PUSH
20126: LD_INT 44
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: PUSH
20133: LD_INT 1
20135: PPUSH
20136: LD_INT 2
20138: PPUSH
20139: CALL_OW 12
20143: ARRAY
20144: PPUSH
20145: LD_INT 89
20147: PPUSH
20148: CALL 69928 0 5
// un := CreateVehicle ;
20152: LD_ADDR_VAR 0 8
20156: PUSH
20157: CALL_OW 45
20161: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20162: LD_VAR 0 8
20166: PPUSH
20167: LD_INT 4
20169: PPUSH
20170: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20174: LD_VAR 0 8
20178: PPUSH
20179: LD_INT 136
20181: PPUSH
20182: LD_INT 90
20184: PPUSH
20185: LD_INT 8
20187: PPUSH
20188: LD_INT 0
20190: PPUSH
20191: CALL_OW 50
// ru := ru ^ un ;
20195: LD_ADDR_VAR 0 7
20199: PUSH
20200: LD_VAR 0 7
20204: PUSH
20205: LD_VAR 0 8
20209: ADD
20210: ST_TO_ADDR
// end ;
20211: GO 20111
20213: POP
20214: POP
// if ru then
20215: LD_VAR 0 7
20219: IFFALSE 20236
// ComAgressiveMove ( ru , 80 , 92 ) ;
20221: LD_VAR 0 7
20225: PPUSH
20226: LD_INT 80
20228: PPUSH
20229: LD_INT 92
20231: PPUSH
20232: CALL_OW 114
// wait ( 8 8$00 ) ;
20236: LD_INT 16800
20238: PPUSH
20239: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20243: LD_INT 4
20245: PPUSH
20246: LD_INT 3
20248: PUSH
20249: LD_INT 1
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 5
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: LIST
20262: LIST
20263: PUSH
20264: LD_INT 4
20266: PUSH
20267: LD_INT 1
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 6
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 4
20284: PUSH
20285: LD_INT 1
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 7
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: LIST
20299: PUSH
20300: LD_INT 3
20302: PUSH
20303: LD_INT 1
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 7
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 3
20320: PUSH
20321: LD_INT 1
20323: PUSH
20324: LD_INT 1
20326: PUSH
20327: LD_INT 5
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: LIST
20340: LIST
20341: LIST
20342: PPUSH
20343: CALL 58712 0 2
// missionStage := 4 ;
20347: LD_ADDR_EXP 15
20351: PUSH
20352: LD_INT 4
20354: ST_TO_ADDR
// end ;
20355: PPOPN 8
20357: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20358: LD_EXP 15
20362: PUSH
20363: LD_INT 4
20365: EQUAL
20366: PUSH
20367: LD_INT 22
20369: PUSH
20370: LD_INT 4
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 21
20379: PUSH
20380: LD_INT 2
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PPUSH
20391: CALL_OW 69
20395: PUSH
20396: LD_INT 5
20398: GREATEREQUAL
20399: AND
20400: IFFALSE 24505
20402: GO 20404
20404: DISABLE
20405: LD_INT 0
20407: PPUSH
20408: PPUSH
20409: PPUSH
20410: PPUSH
20411: PPUSH
20412: PPUSH
20413: PPUSH
20414: PPUSH
20415: PPUSH
20416: PPUSH
20417: PPUSH
20418: PPUSH
20419: PPUSH
// begin missionStage := 5 ;
20420: LD_ADDR_EXP 15
20424: PUSH
20425: LD_INT 5
20427: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20428: LD_ADDR_VAR 0 10
20432: PUSH
20433: LD_INT 22
20435: PUSH
20436: LD_INT 4
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: LD_INT 2
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 4
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: LD_INT 30
20458: PUSH
20459: LD_INT 5
20461: PUSH
20462: EMPTY
20463: LIST
20464: LIST
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: LIST
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PPUSH
20475: CALL_OW 69
20479: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20480: LD_ADDR_VAR 0 6
20484: PUSH
20485: LD_INT 22
20487: PUSH
20488: LD_INT 4
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 21
20497: PUSH
20498: LD_INT 1
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 3
20507: PUSH
20508: LD_INT 25
20510: PUSH
20511: LD_INT 16
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 3
20524: PUSH
20525: LD_INT 25
20527: PUSH
20528: LD_INT 12
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: LIST
20543: LIST
20544: PPUSH
20545: CALL_OW 69
20549: PUSH
20550: LD_EXP 58
20554: DIFF
20555: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20556: LD_ADDR_VAR 0 9
20560: PUSH
20561: LD_INT 22
20563: PUSH
20564: LD_INT 4
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: LD_INT 30
20573: PUSH
20574: LD_INT 3
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PUSH
20581: EMPTY
20582: LIST
20583: LIST
20584: PPUSH
20585: CALL_OW 69
20589: PUSH
20590: LD_INT 1
20592: ARRAY
20593: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20594: LD_INT 35
20596: PPUSH
20597: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20601: LD_EXP 131
20605: PUSH
20606: LD_INT 4
20608: ARRAY
20609: PUSH
20610: LD_INT 5
20612: GREATEREQUAL
20613: PUSH
20614: LD_EXP 131
20618: PUSH
20619: LD_INT 4
20621: ARRAY
20622: PPUSH
20623: LD_INT 58
20625: PUSH
20626: EMPTY
20627: LIST
20628: PPUSH
20629: CALL_OW 72
20633: PUSH
20634: LD_INT 5
20636: GREATEREQUAL
20637: AND
20638: IFFALSE 20594
// powellAllowRetreat := false ;
20640: LD_ADDR_EXP 19
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20648: LD_INT 700
20650: PPUSH
20651: CALL_OW 67
// activeAttacks := false ;
20655: LD_ADDR_EXP 16
20659: PUSH
20660: LD_INT 0
20662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20663: LD_INT 35
20665: PPUSH
20666: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20670: LD_INT 22
20672: PUSH
20673: LD_INT 6
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PPUSH
20680: CALL_OW 69
20684: PUSH
20685: LD_INT 0
20687: EQUAL
20688: IFFALSE 20663
// tmp := mc_vehicles [ 4 ] ;
20690: LD_ADDR_VAR 0 3
20694: PUSH
20695: LD_EXP 131
20699: PUSH
20700: LD_INT 4
20702: ARRAY
20703: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20704: LD_ADDR_VAR 0 1
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_EXP 18
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20981
// begin for j in powellSquadAttack [ i ] do
20722: LD_ADDR_VAR 0 2
20726: PUSH
20727: LD_EXP 18
20731: PUSH
20732: LD_VAR 0 1
20736: ARRAY
20737: PUSH
20738: FOR_IN
20739: IFFALSE 20977
// begin forces := forces diff j ;
20741: LD_ADDR_VAR 0 6
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: LD_VAR 0 2
20755: DIFF
20756: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20757: LD_VAR 0 2
20761: PPUSH
20762: LD_INT 1
20764: PPUSH
20765: CALL_OW 109
// wait ( 0 0$2 ) ;
20769: LD_INT 70
20771: PPUSH
20772: CALL_OW 67
// if IsInUnit ( j ) then
20776: LD_VAR 0 2
20780: PPUSH
20781: CALL_OW 310
20785: IFFALSE 20796
// ComExitBuilding ( j ) ;
20787: LD_VAR 0 2
20791: PPUSH
20792: CALL_OW 122
// if GetClass ( j ) <> 1 then
20796: LD_VAR 0 2
20800: PPUSH
20801: CALL_OW 257
20805: PUSH
20806: LD_INT 1
20808: NONEQUAL
20809: IFFALSE 20889
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20811: LD_VAR 0 10
20815: PUSH
20816: LD_INT 1
20818: ARRAY
20819: PPUSH
20820: CALL_OW 313
20824: PUSH
20825: LD_INT 5
20827: GREATEREQUAL
20828: IFFALSE 20850
// AddComEnterUnit ( j , arm [ 2 ] ) else
20830: LD_VAR 0 2
20834: PPUSH
20835: LD_VAR 0 10
20839: PUSH
20840: LD_INT 2
20842: ARRAY
20843: PPUSH
20844: CALL_OW 180
20848: GO 20868
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20850: LD_VAR 0 2
20854: PPUSH
20855: LD_VAR 0 10
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20868: LD_VAR 0 2
20872: PPUSH
20873: LD_INT 1
20875: PPUSH
20876: CALL_OW 183
// AddComExitBuilding ( j ) ;
20880: LD_VAR 0 2
20884: PPUSH
20885: CALL_OW 182
// end ; if i = 2 then
20889: LD_VAR 0 1
20893: PUSH
20894: LD_INT 2
20896: EQUAL
20897: IFFALSE 20914
// AddComMoveXY ( j , 61 , 93 ) ;
20899: LD_VAR 0 2
20903: PPUSH
20904: LD_INT 61
20906: PPUSH
20907: LD_INT 93
20909: PPUSH
20910: CALL_OW 171
// if i = 1 then
20914: LD_VAR 0 1
20918: PUSH
20919: LD_INT 1
20921: EQUAL
20922: IFFALSE 20975
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20924: LD_VAR 0 2
20928: PPUSH
20929: LD_VAR 0 3
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20942: LD_ADDR_VAR 0 3
20946: PUSH
20947: LD_VAR 0 3
20951: PPUSH
20952: LD_INT 1
20954: PPUSH
20955: CALL_OW 3
20959: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_INT 69
20967: PPUSH
20968: LD_INT 94
20970: PPUSH
20971: CALL_OW 171
// end ; end ;
20975: GO 20738
20977: POP
20978: POP
// end ;
20979: GO 20719
20981: POP
20982: POP
// wait ( 0 0$55 ) ;
20983: LD_INT 1925
20985: PPUSH
20986: CALL_OW 67
// MC_Kill ( 4 ) ;
20990: LD_INT 4
20992: PPUSH
20993: CALL 35316 0 1
// tmp := UnitsInside ( fac ) ;
20997: LD_ADDR_VAR 0 3
21001: PUSH
21002: LD_VAR 0 9
21006: PPUSH
21007: CALL_OW 313
21011: ST_TO_ADDR
// if tmp then
21012: LD_VAR 0 3
21016: IFFALSE 21137
// for i in tmp do
21018: LD_ADDR_VAR 0 1
21022: PUSH
21023: LD_VAR 0 3
21027: PUSH
21028: FOR_IN
21029: IFFALSE 21135
// begin ComExitBuilding ( i ) ;
21031: LD_VAR 0 1
21035: PPUSH
21036: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21040: LD_VAR 0 10
21044: PUSH
21045: LD_INT 2
21047: ARRAY
21048: PPUSH
21049: CALL_OW 313
21053: PUSH
21054: LD_INT 6
21056: LESS
21057: IFFALSE 21079
// AddComEnterUnit ( i , arm [ 2 ] ) else
21059: LD_VAR 0 1
21063: PPUSH
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 2
21071: ARRAY
21072: PPUSH
21073: CALL_OW 180
21077: GO 21133
// if UnitsInside ( arm [ 1 ] ) < 6 then
21079: LD_VAR 0 10
21083: PUSH
21084: LD_INT 1
21086: ARRAY
21087: PPUSH
21088: CALL_OW 313
21092: PUSH
21093: LD_INT 6
21095: LESS
21096: IFFALSE 21118
// AddComEnterUnit ( i , arm [ 1 ] ) else
21098: LD_VAR 0 1
21102: PPUSH
21103: LD_VAR 0 10
21107: PUSH
21108: LD_INT 1
21110: ARRAY
21111: PPUSH
21112: CALL_OW 180
21116: GO 21133
// AddComMoveXY ( i , 37 , 68 ) ;
21118: LD_VAR 0 1
21122: PPUSH
21123: LD_INT 37
21125: PPUSH
21126: LD_INT 68
21128: PPUSH
21129: CALL_OW 171
// end ;
21133: GO 21028
21135: POP
21136: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21137: LD_ADDR_VAR 0 11
21141: PUSH
21142: LD_VAR 0 6
21146: PPUSH
21147: LD_INT 26
21149: PUSH
21150: LD_INT 1
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: PPUSH
21157: CALL_OW 72
21161: PUSH
21162: LD_EXP 59
21166: DIFF
21167: ST_TO_ADDR
// if not speaker then
21168: LD_VAR 0 11
21172: NOT
21173: IFFALSE 21200
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21175: LD_ADDR_VAR 0 11
21179: PUSH
21180: LD_VAR 0 6
21184: PPUSH
21185: LD_INT 26
21187: PUSH
21188: LD_INT 1
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PPUSH
21195: CALL_OW 72
21199: ST_TO_ADDR
// if speaker then
21200: LD_VAR 0 11
21204: IFFALSE 21220
// speaker := speaker [ 1 ] ;
21206: LD_ADDR_VAR 0 11
21210: PUSH
21211: LD_VAR 0 11
21215: PUSH
21216: LD_INT 1
21218: ARRAY
21219: ST_TO_ADDR
// Video ( true ) ;
21220: LD_INT 1
21222: PPUSH
21223: CALL 100946 0 1
// CenterNowOnUnits ( Powell ) ;
21227: LD_EXP 58
21231: PPUSH
21232: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21236: LD_ADDR_VAR 0 3
21240: PUSH
21241: LD_VAR 0 6
21245: PPUSH
21246: LD_INT 3
21248: PUSH
21249: LD_INT 25
21251: PUSH
21252: LD_INT 1
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 72
21267: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21268: LD_ADDR_VAR 0 12
21272: PUSH
21273: LD_INT 22
21275: PUSH
21276: LD_INT 4
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 30
21285: PUSH
21286: LD_INT 32
21288: PUSH
21289: EMPTY
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 58
21295: PUSH
21296: EMPTY
21297: LIST
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: PPUSH
21304: CALL_OW 69
21308: ST_TO_ADDR
// for i = 1 to 6 do
21309: LD_ADDR_VAR 0 1
21313: PUSH
21314: DOUBLE
21315: LD_INT 1
21317: DEC
21318: ST_TO_ADDR
21319: LD_INT 6
21321: PUSH
21322: FOR_TO
21323: IFFALSE 21464
// begin if IsInUnit ( tmp [ i ] ) then
21325: LD_VAR 0 3
21329: PUSH
21330: LD_VAR 0 1
21334: ARRAY
21335: PPUSH
21336: CALL_OW 310
21340: IFFALSE 21357
// ComExitBuilding ( tmp [ i ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21357: LD_VAR 0 3
21361: PUSH
21362: LD_VAR 0 1
21366: ARRAY
21367: PPUSH
21368: LD_VAR 0 10
21372: PUSH
21373: LD_INT 1
21375: ARRAY
21376: PPUSH
21377: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21381: LD_VAR 0 3
21385: PUSH
21386: LD_VAR 0 1
21390: ARRAY
21391: PPUSH
21392: LD_INT 1
21394: PPUSH
21395: CALL_OW 183
// if emp_towers then
21399: LD_VAR 0 12
21403: IFFALSE 21462
// begin AddComExitBuilding ( tmp [ i ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21420: LD_VAR 0 3
21424: PUSH
21425: LD_VAR 0 1
21429: ARRAY
21430: PPUSH
21431: LD_VAR 0 12
21435: PUSH
21436: LD_INT 1
21438: ARRAY
21439: PPUSH
21440: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21444: LD_ADDR_VAR 0 12
21448: PUSH
21449: LD_VAR 0 12
21453: PPUSH
21454: LD_INT 1
21456: PPUSH
21457: CALL_OW 3
21461: ST_TO_ADDR
// end ; end ;
21462: GO 21322
21464: POP
21465: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21466: LD_ADDR_VAR 0 3
21470: PUSH
21471: LD_EXP 18
21475: PUSH
21476: LD_INT 1
21478: ARRAY
21479: PUSH
21480: LD_EXP 18
21484: PUSH
21485: LD_INT 2
21487: ARRAY
21488: ADD
21489: PPUSH
21490: LD_INT 26
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PPUSH
21500: CALL_OW 72
21504: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21505: LD_ADDR_VAR 0 1
21509: PUSH
21510: LD_EXP 18
21514: PUSH
21515: LD_INT 2
21517: ARRAY
21518: PUSH
21519: FOR_IN
21520: IFFALSE 21538
// ComTurnUnit ( i , Powell ) ;
21522: LD_VAR 0 1
21526: PPUSH
21527: LD_EXP 58
21531: PPUSH
21532: CALL_OW 119
21536: GO 21519
21538: POP
21539: POP
// Say ( Powell , D5-Pow-1 ) ;
21540: LD_EXP 58
21544: PPUSH
21545: LD_STRING D5-Pow-1
21547: PPUSH
21548: CALL_OW 88
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21574
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21558: LD_VAR 0 3
21562: PUSH
21563: LD_INT 1
21565: ARRAY
21566: PPUSH
21567: LD_STRING D5-Sol2-1
21569: PPUSH
21570: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21574: LD_EXP 58
21578: PPUSH
21579: LD_STRING D5-Pow-2
21581: PPUSH
21582: CALL_OW 88
// if tmp > 1 then
21586: LD_VAR 0 3
21590: PUSH
21591: LD_INT 1
21593: GREATER
21594: IFFALSE 21612
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21596: LD_VAR 0 3
21600: PUSH
21601: LD_INT 2
21603: ARRAY
21604: PPUSH
21605: LD_STRING D5-Sol2-2
21607: PPUSH
21608: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21612: LD_EXP 58
21616: PPUSH
21617: LD_STRING D5-Pow-3
21619: PPUSH
21620: CALL_OW 88
// wait ( 0 0$1 ) ;
21624: LD_INT 35
21626: PPUSH
21627: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21631: LD_ADDR_VAR 0 3
21635: PUSH
21636: LD_EXP 18
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PUSH
21645: LD_EXP 18
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: UNION
21654: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21655: LD_VAR 0 3
21659: PPUSH
21660: LD_INT 80
21662: PPUSH
21663: LD_INT 67
21665: PPUSH
21666: CALL_OW 114
// wait ( 0 0$2 ) ;
21670: LD_INT 70
21672: PPUSH
21673: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21677: LD_INT 79
21679: PPUSH
21680: LD_INT 72
21682: PPUSH
21683: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21687: LD_INT 35
21689: PPUSH
21690: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21694: LD_VAR 0 3
21698: PPUSH
21699: LD_INT 3
21701: PUSH
21702: LD_INT 24
21704: PUSH
21705: LD_INT 1000
21707: PUSH
21708: EMPTY
21709: LIST
21710: LIST
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: PPUSH
21716: CALL_OW 72
21720: IFFALSE 21687
// Say ( Powell , D5a-Pow-1 ) ;
21722: LD_EXP 58
21726: PPUSH
21727: LD_STRING D5a-Pow-1
21729: PPUSH
21730: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21734: LD_EXP 58
21738: PPUSH
21739: LD_STRING D5a-Pow-1a
21741: PPUSH
21742: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21746: LD_INT 10
21748: PPUSH
21749: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21753: LD_EXP 58
21757: PPUSH
21758: LD_STRING D5a-Pow-1b
21760: PPUSH
21761: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21765: LD_EXP 58
21769: PPUSH
21770: LD_STRING D5a-Pow-1c
21772: PPUSH
21773: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21777: LD_EXP 58
21781: PPUSH
21782: LD_STRING D5a-Pow-1d
21784: PPUSH
21785: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21789: LD_INT 35
21791: PPUSH
21792: CALL_OW 67
// if not HasTask ( tmp ) then
21796: LD_VAR 0 3
21800: PPUSH
21801: CALL_OW 314
21805: NOT
21806: IFFALSE 21823
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 80
21815: PPUSH
21816: LD_INT 67
21818: PPUSH
21819: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 24
21830: PUSH
21831: LD_INT 1
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PPUSH
21838: CALL_OW 72
21842: NOT
21843: IFFALSE 21789
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21845: LD_ADDR_VAR 0 3
21849: PUSH
21850: LD_INT 22
21852: PUSH
21853: LD_INT 4
21855: PUSH
21856: EMPTY
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 92
21862: PUSH
21863: LD_INT 60
21865: PUSH
21866: LD_INT 93
21868: PUSH
21869: LD_INT 10
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 3
21880: PUSH
21881: LD_INT 54
21883: PUSH
21884: EMPTY
21885: LIST
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PPUSH
21896: CALL_OW 69
21900: PUSH
21901: LD_EXP 58
21905: DIFF
21906: ST_TO_ADDR
// if tmp then
21907: LD_VAR 0 3
21911: IFFALSE 21945
// for i in tmp do
21913: LD_ADDR_VAR 0 1
21917: PUSH
21918: LD_VAR 0 3
21922: PUSH
21923: FOR_IN
21924: IFFALSE 21943
// ComMoveXY ( i , 36 , 67 ) ;
21926: LD_VAR 0 1
21930: PPUSH
21931: LD_INT 36
21933: PPUSH
21934: LD_INT 67
21936: PPUSH
21937: CALL_OW 111
21941: GO 21923
21943: POP
21944: POP
// wait ( 0 0$3 ) ;
21945: LD_INT 105
21947: PPUSH
21948: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6-Sol3-1
21959: PPUSH
21960: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21964: LD_EXP 58
21968: PPUSH
21969: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21973: LD_EXP 58
21977: PPUSH
21978: LD_STRING D6-Pow-1
21980: PPUSH
21981: CALL_OW 88
// tmp := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// for i = 1 to 2 do
21992: LD_ADDR_VAR 0 1
21996: PUSH
21997: DOUBLE
21998: LD_INT 1
22000: DEC
22001: ST_TO_ADDR
22002: LD_INT 2
22004: PUSH
22005: FOR_TO
22006: IFFALSE 22120
// begin uc_side := 8 ;
22008: LD_ADDR_OWVAR 20
22012: PUSH
22013: LD_INT 8
22015: ST_TO_ADDR
// uc_nation := 2 ;
22016: LD_ADDR_OWVAR 21
22020: PUSH
22021: LD_INT 2
22023: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22024: LD_INT 14
22026: PPUSH
22027: LD_INT 3
22029: PPUSH
22030: LD_INT 2
22032: PPUSH
22033: LD_INT 29
22035: PPUSH
22036: LD_INT 100
22038: PPUSH
22039: CALL 69928 0 5
// veh := CreateVehicle ;
22043: LD_ADDR_VAR 0 13
22047: PUSH
22048: CALL_OW 45
22052: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22053: LD_VAR 0 13
22057: PPUSH
22058: LD_INT 4
22060: PPUSH
22061: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22065: LD_VAR 0 13
22069: PPUSH
22070: LD_INT 99
22072: PPUSH
22073: LD_INT 83
22075: PPUSH
22076: LD_INT 6
22078: PPUSH
22079: LD_INT 0
22081: PPUSH
22082: CALL_OW 50
// wait ( 3 ) ;
22086: LD_INT 3
22088: PPUSH
22089: CALL_OW 67
// Connect ( veh ) ;
22093: LD_VAR 0 13
22097: PPUSH
22098: CALL 72983 0 1
// tmp := tmp ^ veh ;
22102: LD_ADDR_VAR 0 3
22106: PUSH
22107: LD_VAR 0 3
22111: PUSH
22112: LD_VAR 0 13
22116: ADD
22117: ST_TO_ADDR
// end ;
22118: GO 22005
22120: POP
22121: POP
// wait ( 0 0$1 ) ;
22122: LD_INT 35
22124: PPUSH
22125: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22129: LD_INT 99
22131: PPUSH
22132: LD_INT 83
22134: PPUSH
22135: LD_INT 1
22137: PPUSH
22138: LD_INT 10
22140: PPUSH
22141: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22145: LD_INT 99
22147: PPUSH
22148: LD_INT 83
22150: PPUSH
22151: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22155: LD_VAR 0 11
22159: PPUSH
22160: LD_STRING D6-Sol3-2
22162: PPUSH
22163: CALL_OW 88
// async ;
22167: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22168: LD_EXP 58
22172: PPUSH
22173: LD_STRING D6-Pow-2
22175: PPUSH
22176: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22180: LD_VAR 0 3
22184: PUSH
22185: LD_INT 1
22187: ARRAY
22188: PPUSH
22189: LD_VAR 0 9
22193: PPUSH
22194: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22198: LD_VAR 0 3
22202: PUSH
22203: LD_INT 2
22205: ARRAY
22206: PPUSH
22207: LD_INT 22
22209: PUSH
22210: LD_INT 4
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PUSH
22217: LD_INT 21
22219: PUSH
22220: LD_INT 3
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: PPUSH
22231: CALL_OW 69
22235: PPUSH
22236: LD_VAR 0 3
22240: PUSH
22241: LD_INT 2
22243: ARRAY
22244: PPUSH
22245: CALL_OW 74
22249: PPUSH
22250: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22254: LD_EXP 58
22258: PPUSH
22259: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22263: LD_INT 99
22265: PPUSH
22266: LD_INT 83
22268: PPUSH
22269: LD_INT 1
22271: PPUSH
22272: CALL_OW 331
// repeat wait ( 4 ) ;
22276: LD_INT 4
22278: PPUSH
22279: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22283: LD_VAR 0 3
22287: PUSH
22288: LD_INT 1
22290: ARRAY
22291: PPUSH
22292: CALL_OW 256
22296: PUSH
22297: LD_INT 1000
22299: LESS
22300: IFFALSE 22318
// SetLives ( tmp [ 1 ] , 1000 ) ;
22302: LD_VAR 0 3
22306: PUSH
22307: LD_INT 1
22309: ARRAY
22310: PPUSH
22311: LD_INT 1000
22313: PPUSH
22314: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22318: LD_INT 22
22320: PUSH
22321: LD_INT 4
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: LD_INT 30
22330: PUSH
22331: LD_INT 3
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: PPUSH
22342: CALL_OW 69
22346: PUSH
22347: LD_INT 0
22349: EQUAL
22350: IFFALSE 22276
// sync ;
22352: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22353: LD_EXP 58
22357: PPUSH
22358: LD_STRING D6a-Pow-1
22360: PPUSH
22361: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22365: LD_VAR 0 11
22369: PPUSH
22370: LD_STRING D6a-Sol3-1
22372: PPUSH
22373: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22377: LD_EXP 58
22381: PPUSH
22382: LD_STRING D6a-Pow-2
22384: PPUSH
22385: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22389: LD_VAR 0 11
22393: PPUSH
22394: LD_STRING D6a-Sol3-2
22396: PPUSH
22397: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22401: LD_EXP 58
22405: PPUSH
22406: LD_STRING D6a-Pow-3
22408: PPUSH
22409: CALL_OW 88
// powellCenterCameraMode := true ;
22413: LD_ADDR_EXP 20
22417: PUSH
22418: LD_INT 1
22420: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22421: LD_ADDR_VAR 0 1
22425: PUSH
22426: LD_INT 22
22428: PUSH
22429: LD_INT 8
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: PUSH
22436: LD_INT 25
22438: PUSH
22439: LD_INT 2
22441: PUSH
22442: EMPTY
22443: LIST
22444: LIST
22445: PUSH
22446: EMPTY
22447: LIST
22448: LIST
22449: PPUSH
22450: CALL_OW 69
22454: PUSH
22455: FOR_IN
22456: IFFALSE 22511
// begin SetTag ( i , 1 ) ;
22458: LD_VAR 0 1
22462: PPUSH
22463: LD_INT 1
22465: PPUSH
22466: CALL_OW 109
// ComExitBuilding ( i ) ;
22470: LD_VAR 0 1
22474: PPUSH
22475: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 35
22486: PPUSH
22487: LD_INT 6
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22494: LD_VAR 0 1
22498: PPUSH
22499: LD_INT 53
22501: PPUSH
22502: LD_INT 4
22504: PPUSH
22505: CALL_OW 171
// end ;
22509: GO 22455
22511: POP
22512: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 22
22520: PUSH
22521: LD_INT 4
22523: PUSH
22524: EMPTY
22525: LIST
22526: LIST
22527: PUSH
22528: LD_INT 21
22530: PUSH
22531: LD_INT 2
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 3
22540: PUSH
22541: LD_INT 34
22543: PUSH
22544: LD_INT 12
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22565: LD_EXP 58
22569: PPUSH
22570: LD_VAR 0 3
22574: PPUSH
22575: LD_EXP 58
22579: PPUSH
22580: CALL_OW 74
22584: PPUSH
22585: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 88
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 100
22611: PPUSH
22612: LD_INT 75
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22619: LD_EXP 58
22623: PPUSH
22624: LD_INT 88
22626: PPUSH
22627: LD_INT 53
22629: PPUSH
22630: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22634: LD_INT 8
22636: PPUSH
22637: LD_EXP 58
22641: PPUSH
22642: CALL_OW 471
// repeat wait ( 3 ) ;
22646: LD_INT 3
22648: PPUSH
22649: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 92
22665: PUSH
22666: LD_INT 100
22668: PUSH
22669: LD_INT 75
22671: PUSH
22672: LD_INT 6
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: PUSH
22681: EMPTY
22682: LIST
22683: LIST
22684: PPUSH
22685: CALL_OW 69
22689: IFFALSE 22646
// async ;
22691: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22692: LD_EXP 58
22696: PPUSH
22697: LD_STRING D6b-Pow-1
22699: PPUSH
22700: CALL_OW 88
// repeat wait ( 3 ) ;
22704: LD_INT 3
22706: PPUSH
22707: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22711: LD_EXP 58
22715: PPUSH
22716: CALL_OW 310
22720: PPUSH
22721: CALL_OW 256
22725: PUSH
22726: LD_INT 1000
22728: LESS
22729: IFFALSE 22748
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22731: LD_EXP 58
22735: PPUSH
22736: CALL_OW 310
22740: PPUSH
22741: LD_INT 1000
22743: PPUSH
22744: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22748: LD_EXP 58
22752: PPUSH
22753: CALL_OW 256
22757: PUSH
22758: LD_INT 1000
22760: LESS
22761: IFFALSE 22775
// SetLives ( Powell , 1000 ) ;
22763: LD_EXP 58
22767: PPUSH
22768: LD_INT 1000
22770: PPUSH
22771: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22775: LD_EXP 58
22779: PPUSH
22780: LD_EXP 63
22784: PPUSH
22785: CALL_OW 296
22789: PUSH
22790: LD_INT 5
22792: LESS
22793: PUSH
22794: LD_EXP 58
22798: PPUSH
22799: CALL_OW 310
22803: PPUSH
22804: LD_EXP 63
22808: PPUSH
22809: CALL_OW 296
22813: PUSH
22814: LD_INT 5
22816: LESS
22817: OR
22818: IFFALSE 22837
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22820: LD_EXP 58
22824: PPUSH
22825: CALL_OW 310
22829: PPUSH
22830: LD_INT 100
22832: PPUSH
22833: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22837: LD_EXP 58
22841: PPUSH
22842: CALL_OW 310
22846: NOT
22847: IFFALSE 22704
// DoNotAttack ( 8 , powellBomb ) ;
22849: LD_INT 8
22851: PPUSH
22852: LD_EXP 63
22856: PPUSH
22857: CALL_OW 471
// game_speed := 4 ;
22861: LD_ADDR_OWVAR 65
22865: PUSH
22866: LD_INT 4
22868: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22869: LD_EXP 58
22873: PPUSH
22874: LD_STRING D6b-Pow-1a
22876: PPUSH
22877: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22881: LD_EXP 58
22885: PPUSH
22886: LD_EXP 63
22890: PPUSH
22891: CALL_OW 180
// sync ;
22895: SYNC
// repeat wait ( 0 0$1 ) ;
22896: LD_INT 35
22898: PPUSH
22899: CALL_OW 67
// until IsInUnit ( Powell ) ;
22903: LD_EXP 58
22907: PPUSH
22908: CALL_OW 310
22912: IFFALSE 22896
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22914: LD_INT 8
22916: PPUSH
22917: LD_EXP 58
22921: PPUSH
22922: CALL_OW 310
22926: PPUSH
22927: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 91
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 44
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 96
22968: PPUSH
22969: LD_INT 41
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 92
22983: PPUSH
22984: LD_INT 39
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 88
22998: PPUSH
22999: LD_INT 41
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 91
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 44
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 96
23043: PPUSH
23044: LD_INT 41
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 92
23058: PPUSH
23059: LD_INT 39
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 88
23073: PPUSH
23074: LD_INT 41
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 91
23088: PPUSH
23089: LD_INT 44
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 39
23106: PPUSH
23107: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23111: LD_EXP 58
23115: PPUSH
23116: LD_INT 93
23118: PPUSH
23119: LD_INT 36
23121: PPUSH
23122: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23126: LD_INT 122
23128: PPUSH
23129: CALL_OW 67
// game_speed := 4 ;
23133: LD_ADDR_OWVAR 65
23137: PUSH
23138: LD_INT 4
23140: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23141: LD_EXP 58
23145: PPUSH
23146: LD_STRING D6b-Pow-1b
23148: PPUSH
23149: CALL_OW 88
// tmp := [ ] ;
23153: LD_ADDR_VAR 0 3
23157: PUSH
23158: EMPTY
23159: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23160: LD_ADDR_VAR 0 5
23164: PUSH
23165: LD_INT 78
23167: PUSH
23168: LD_INT 47
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: LD_INT 106
23177: PUSH
23178: LD_INT 53
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23189: LD_ADDR_VAR 0 1
23193: PUSH
23194: LD_INT 22
23196: PUSH
23197: LD_INT 8
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: PUSH
23204: LD_INT 21
23206: PUSH
23207: LD_INT 3
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 92
23216: PUSH
23217: LD_INT 90
23219: PUSH
23220: LD_INT 52
23222: PUSH
23223: LD_INT 12
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: PPUSH
23237: CALL_OW 69
23241: PUSH
23242: FOR_IN
23243: IFFALSE 23268
// tmp := tmp ^ UnitsInside ( i ) ;
23245: LD_ADDR_VAR 0 3
23249: PUSH
23250: LD_VAR 0 3
23254: PUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 313
23264: ADD
23265: ST_TO_ADDR
23266: GO 23242
23268: POP
23269: POP
// for i in tmp do
23270: LD_ADDR_VAR 0 1
23274: PUSH
23275: LD_VAR 0 3
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23443
// begin dist := 9999 ;
23283: LD_ADDR_VAR 0 8
23287: PUSH
23288: LD_INT 9999
23290: ST_TO_ADDR
// _xy := [ ] ;
23291: LD_ADDR_VAR 0 7
23295: PUSH
23296: EMPTY
23297: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23298: LD_VAR 0 1
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL_OW 109
// ComExitBuilding ( i ) ;
23310: LD_VAR 0 1
23314: PPUSH
23315: CALL_OW 122
// for j in xy do
23319: LD_ADDR_VAR 0 2
23323: PUSH
23324: LD_VAR 0 5
23328: PUSH
23329: FOR_IN
23330: IFFALSE 23412
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23332: LD_VAR 0 1
23336: PPUSH
23337: LD_VAR 0 2
23341: PUSH
23342: LD_INT 1
23344: ARRAY
23345: PPUSH
23346: LD_VAR 0 2
23350: PUSH
23351: LD_INT 2
23353: ARRAY
23354: PPUSH
23355: CALL_OW 297
23359: PUSH
23360: LD_VAR 0 8
23364: LESS
23365: IFFALSE 23410
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23367: LD_ADDR_VAR 0 8
23371: PUSH
23372: LD_VAR 0 1
23376: PPUSH
23377: LD_VAR 0 2
23381: PUSH
23382: LD_INT 1
23384: ARRAY
23385: PPUSH
23386: LD_VAR 0 2
23390: PUSH
23391: LD_INT 2
23393: ARRAY
23394: PPUSH
23395: CALL_OW 297
23399: ST_TO_ADDR
// _xy := j ;
23400: LD_ADDR_VAR 0 7
23404: PUSH
23405: LD_VAR 0 2
23409: ST_TO_ADDR
// end ;
23410: GO 23329
23412: POP
23413: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23414: LD_VAR 0 1
23418: PPUSH
23419: LD_VAR 0 7
23423: PUSH
23424: LD_INT 1
23426: ARRAY
23427: PPUSH
23428: LD_VAR 0 7
23432: PUSH
23433: LD_INT 2
23435: ARRAY
23436: PPUSH
23437: CALL_OW 171
// end ;
23441: GO 23280
23443: POP
23444: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23445: LD_ADDR_VAR 0 4
23449: PUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: LD_INT 26
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 25
23467: PUSH
23468: LD_INT 1
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PPUSH
23479: CALL_OW 72
23483: ST_TO_ADDR
// if tmp2 < 2 then
23484: LD_VAR 0 4
23488: PUSH
23489: LD_INT 2
23491: LESS
23492: IFFALSE 23561
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23494: LD_ADDR_VAR 0 4
23498: PUSH
23499: LD_INT 22
23501: PUSH
23502: LD_INT 8
23504: PUSH
23505: EMPTY
23506: LIST
23507: LIST
23508: PUSH
23509: LD_INT 26
23511: PUSH
23512: LD_INT 1
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 3
23521: PUSH
23522: LD_INT 25
23524: PUSH
23525: LD_INT 15
23527: PUSH
23528: EMPTY
23529: LIST
23530: LIST
23531: PUSH
23532: EMPTY
23533: LIST
23534: LIST
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: LIST
23540: PPUSH
23541: CALL_OW 69
23545: PUSH
23546: LD_EXP 60
23550: PUSH
23551: LD_EXP 61
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: DIFF
23560: ST_TO_ADDR
// if tmp2 then
23561: LD_VAR 0 4
23565: IFFALSE 23583
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23567: LD_VAR 0 4
23571: PUSH
23572: LD_INT 1
23574: ARRAY
23575: PPUSH
23576: LD_STRING D6b-ArSol1-1
23578: PPUSH
23579: CALL_OW 88
// async ;
23583: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23584: LD_EXP 58
23588: PPUSH
23589: LD_STRING D6b-Pow-2
23591: PPUSH
23592: CALL_OW 88
// wait ( 0 0$1 ) ;
23596: LD_INT 35
23598: PPUSH
23599: CALL_OW 67
// if tmp2 > 1 then
23603: LD_VAR 0 4
23607: PUSH
23608: LD_INT 1
23610: GREATER
23611: IFFALSE 23629
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23613: LD_VAR 0 4
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: LD_STRING D6b-ArSol2-1
23624: PPUSH
23625: CALL_OW 88
// sync ;
23629: SYNC
// repeat wait ( 5 ) ;
23630: LD_INT 5
23632: PPUSH
23633: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23637: LD_INT 93
23639: PPUSH
23640: LD_INT 36
23642: PPUSH
23643: CALL_OW 428
23647: PPUSH
23648: CALL_OW 255
23652: PUSH
23653: LD_INT 4
23655: EQUAL
23656: IFFALSE 23630
// DialogueOn ;
23658: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23662: LD_INT 10
23664: PPUSH
23665: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23669: LD_EXP 58
23673: PPUSH
23674: LD_STRING D6b-Pow-2a
23676: PPUSH
23677: CALL_OW 88
// DialogueOff ;
23681: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23685: LD_EXP 58
23689: PPUSH
23690: CALL_OW 310
23694: PPUSH
23695: LD_INT 332
23697: PPUSH
23698: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23702: LD_INT 93
23704: PPUSH
23705: LD_INT 35
23707: PPUSH
23708: LD_INT 1
23710: PPUSH
23711: LD_INT 6
23713: NEG
23714: PPUSH
23715: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23719: LD_INT 35
23721: PPUSH
23722: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23726: LD_INT 332
23728: PPUSH
23729: CALL_OW 256
23733: PUSH
23734: LD_INT 1000
23736: LESS
23737: PUSH
23738: LD_INT 332
23740: PPUSH
23741: CALL_OW 300
23745: AND
23746: IFFALSE 23758
// SetLives ( kozlov_fac , 0 ) ;
23748: LD_INT 332
23750: PPUSH
23751: LD_INT 0
23753: PPUSH
23754: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23758: LD_INT 332
23760: PPUSH
23761: CALL_OW 301
23765: PUSH
23766: LD_EXP 58
23770: PPUSH
23771: CALL_OW 301
23775: OR
23776: IFFALSE 23719
// game_speed := 4 ;
23778: LD_ADDR_OWVAR 65
23782: PUSH
23783: LD_INT 4
23785: ST_TO_ADDR
// powellCenterCameraMode := false ;
23786: LD_ADDR_EXP 20
23790: PUSH
23791: LD_INT 0
23793: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23794: LD_ADDR_VAR 0 1
23798: PUSH
23799: LD_VAR 0 3
23803: PUSH
23804: LD_INT 22
23806: PUSH
23807: LD_INT 8
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 25
23816: PUSH
23817: LD_INT 2
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 69
23832: UNION
23833: PUSH
23834: FOR_IN
23835: IFFALSE 23851
// SetTag ( i , 0 ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_INT 0
23844: PPUSH
23845: CALL_OW 109
23849: GO 23834
23851: POP
23852: POP
// wait ( 0 0$3 ) ;
23853: LD_INT 105
23855: PPUSH
23856: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23860: LD_INT 93
23862: PPUSH
23863: LD_INT 35
23865: PPUSH
23866: LD_INT 1
23868: PPUSH
23869: CALL_OW 331
// DialogueOn ;
23873: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23877: LD_VAR 0 11
23881: PPUSH
23882: LD_STRING D6c-Sol3-1
23884: PPUSH
23885: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23889: LD_INT 10
23891: PPUSH
23892: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23896: LD_EXP 39
23900: PPUSH
23901: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23905: LD_EXP 39
23909: PPUSH
23910: LD_STRING D6c-JMM-1
23912: PPUSH
23913: CALL_OW 88
// if Cyrus then
23917: LD_EXP 45
23921: IFFALSE 23935
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23923: LD_EXP 45
23927: PPUSH
23928: LD_STRING D6c-Cyrus-1
23930: PPUSH
23931: CALL_OW 88
// if Bobby then
23935: LD_EXP 44
23939: IFFALSE 23953
// Say ( Bobby , D6c-Bobby-1 ) ;
23941: LD_EXP 44
23945: PPUSH
23946: LD_STRING D6c-Bobby-1
23948: PPUSH
23949: CALL_OW 88
// if Cornel then
23953: LD_EXP 50
23957: IFFALSE 23971
// Say ( Cornel , D6c-Corn-1 ) ;
23959: LD_EXP 50
23963: PPUSH
23964: LD_STRING D6c-Corn-1
23966: PPUSH
23967: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23971: LD_ADDR_VAR 0 4
23975: PUSH
23976: LD_INT 2
23978: PUSH
23979: LD_INT 22
23981: PUSH
23982: LD_INT 1
23984: PUSH
23985: EMPTY
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 22
23991: PUSH
23992: LD_INT 4
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 26
24006: PUSH
24007: LD_INT 1
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: LD_INT 3
24016: PUSH
24017: LD_INT 25
24019: PUSH
24020: LD_INT 16
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 25
24029: PUSH
24030: LD_INT 12
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: EMPTY
24038: LIST
24039: LIST
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: PPUSH
24047: CALL_OW 69
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_EXP 39
24061: UNION
24062: PUSH
24063: LD_EXP 59
24067: UNION
24068: PUSH
24069: EMPTY
24070: LIST
24071: DIFF
24072: ST_TO_ADDR
// if tmp2 then
24073: LD_VAR 0 4
24077: IFFALSE 24095
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24079: LD_VAR 0 4
24083: PUSH
24084: LD_INT 1
24086: ARRAY
24087: PPUSH
24088: LD_STRING D6c-Sol1-1
24090: PPUSH
24091: CALL_OW 88
// if Lisa then
24095: LD_EXP 42
24099: IFFALSE 24113
// Say ( Lisa , D6c-Lisa-1 ) ;
24101: LD_EXP 42
24105: PPUSH
24106: LD_STRING D6c-Lisa-1
24108: PPUSH
24109: CALL_OW 88
// if Gary then
24113: LD_EXP 51
24117: IFFALSE 24131
// Say ( Gary , D6c-Gary-1 ) ;
24119: LD_EXP 51
24123: PPUSH
24124: LD_STRING D6c-Gary-1
24126: PPUSH
24127: CALL_OW 88
// if Donaldson then
24131: LD_EXP 43
24135: IFFALSE 24149
// Say ( Donaldson , D6c-Don-1 ) ;
24137: LD_EXP 43
24141: PPUSH
24142: LD_STRING D6c-Don-1
24144: PPUSH
24145: CALL_OW 88
// if tmp2 > 1 then
24149: LD_VAR 0 4
24153: PUSH
24154: LD_INT 1
24156: GREATER
24157: IFFALSE 24175
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24159: LD_VAR 0 4
24163: PUSH
24164: LD_INT 2
24166: ARRAY
24167: PPUSH
24168: LD_STRING D6c-Sol2-1
24170: PPUSH
24171: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24175: LD_VAR 0 11
24179: PPUSH
24180: LD_STRING D6c-Sol3-2
24182: PPUSH
24183: CALL_OW 88
// dwait ( 0 0$1 ) ;
24187: LD_INT 35
24189: PPUSH
24190: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24194: LD_EXP 39
24198: PPUSH
24199: LD_STRING D6c-JMM-2
24201: PPUSH
24202: CALL_OW 88
// DialogueOff ;
24206: CALL_OW 7
// Video ( false ) ;
24210: LD_INT 0
24212: PPUSH
24213: CALL 100946 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24217: LD_INT 22
24219: PUSH
24220: LD_INT 4
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PPUSH
24227: CALL_OW 69
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 4
24244: PPUSH
24245: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24249: LD_ADDR_VAR 0 1
24253: PUSH
24254: LD_INT 4
24256: PPUSH
24257: LD_INT 1
24259: PPUSH
24260: LD_INT 2
24262: PPUSH
24263: CALL 65167 0 3
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24306
// if GetTech ( i , 1 ) <> state_researched then
24271: LD_VAR 0 1
24275: PPUSH
24276: LD_INT 1
24278: PPUSH
24279: CALL_OW 321
24283: PUSH
24284: LD_INT 2
24286: NONEQUAL
24287: IFFALSE 24304
// SetTech ( i , 1 , state_researched ) ;
24289: LD_VAR 0 1
24293: PPUSH
24294: LD_INT 1
24296: PPUSH
24297: LD_INT 2
24299: PPUSH
24300: CALL_OW 322
24304: GO 24268
24306: POP
24307: POP
// missionStage := 6 ;
24308: LD_ADDR_EXP 15
24312: PUSH
24313: LD_INT 6
24315: ST_TO_ADDR
// activeAttacks := true ;
24316: LD_ADDR_EXP 16
24320: PUSH
24321: LD_INT 1
24323: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24324: LD_STRING M2
24326: PPUSH
24327: CALL_OW 337
// SaveForQuickRestart ;
24331: CALL_OW 22
// wait ( 0 0$40 ) ;
24335: LD_INT 1400
24337: PPUSH
24338: CALL_OW 67
// DialogueOn ;
24342: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24346: LD_EXP 62
24350: PPUSH
24351: LD_STRING D7-Friend-1
24353: PPUSH
24354: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24358: LD_EXP 39
24362: PPUSH
24363: LD_STRING D7-JMM-1
24365: PPUSH
24366: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24370: LD_EXP 62
24374: PPUSH
24375: LD_STRING D7-Friend-2
24377: PPUSH
24378: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24382: LD_EXP 39
24386: PPUSH
24387: LD_STRING D7-JMM-2
24389: PPUSH
24390: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24394: LD_EXP 62
24398: PPUSH
24399: LD_STRING D7-Friend-3
24401: PPUSH
24402: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24406: LD_EXP 39
24410: PPUSH
24411: LD_STRING D7-JMM-3
24413: PPUSH
24414: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24418: LD_EXP 62
24422: PPUSH
24423: LD_STRING D7-Friend-4
24425: PPUSH
24426: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24430: LD_EXP 39
24434: PPUSH
24435: LD_STRING D7-JMM-4
24437: PPUSH
24438: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24442: LD_EXP 62
24446: PPUSH
24447: LD_STRING D7-Friend-5
24449: PPUSH
24450: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24454: LD_EXP 39
24458: PPUSH
24459: LD_STRING D7-JMM-5
24461: PPUSH
24462: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24466: LD_EXP 62
24470: PPUSH
24471: LD_STRING D7-Friend-6
24473: PPUSH
24474: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24478: LD_EXP 39
24482: PPUSH
24483: LD_STRING D7-JMM-6
24485: PPUSH
24486: CALL_OW 88
// DialogueOff ;
24490: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24494: LD_STRING Mlegion
24496: PPUSH
24497: CALL_OW 337
// RebuildKozlovFactory ;
24501: CALL 4855 0 0
// end ;
24505: PPOPN 13
24507: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24508: LD_EXP 20
24512: PUSH
24513: LD_EXP 58
24517: PPUSH
24518: CALL_OW 300
24522: AND
24523: IFFALSE 24565
24525: GO 24527
24527: DISABLE
// begin enable ;
24528: ENABLE
// if IsInUnit ( Powell ) then
24529: LD_EXP 58
24533: PPUSH
24534: CALL_OW 310
24538: IFFALSE 24556
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24540: LD_EXP 58
24544: PPUSH
24545: CALL_OW 310
24549: PPUSH
24550: CALL_OW 85
24554: GO 24565
// CenterOnUnits ( Powell ) ;
24556: LD_EXP 58
24560: PPUSH
24561: CALL_OW 85
// end ;
24565: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24566: LD_INT 22
24568: PUSH
24569: LD_INT 8
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 34
24578: PUSH
24579: LD_INT 48
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 69
24594: IFFALSE 24868
24596: GO 24598
24598: DISABLE
24599: LD_INT 0
24601: PPUSH
24602: PPUSH
// begin if missionStage < 9 then
24603: LD_EXP 15
24607: PUSH
24608: LD_INT 9
24610: LESS
24611: IFFALSE 24621
// missionStage := 9 ;
24613: LD_ADDR_EXP 15
24617: PUSH
24618: LD_INT 9
24620: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24621: LD_ADDR_VAR 0 1
24625: PUSH
24626: LD_INT 22
24628: PUSH
24629: LD_INT 8
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 34
24638: PUSH
24639: LD_INT 48
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PPUSH
24650: CALL_OW 69
24654: PUSH
24655: LD_INT 1
24657: ARRAY
24658: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24659: LD_INT 175
24661: PPUSH
24662: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24666: LD_EXP 12
24670: PUSH
24671: LD_EXP 3
24675: PUSH
24676: LD_INT 0
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: IN
24686: OR
24687: IFFALSE 24710
// target := [ 68 , 108 , 1 ] else
24689: LD_ADDR_VAR 0 2
24693: PUSH
24694: LD_INT 68
24696: PUSH
24697: LD_INT 108
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: LIST
24707: ST_TO_ADDR
24708: GO 24729
// target := [ 181 , 88 , 2 ] ;
24710: LD_ADDR_VAR 0 2
24714: PUSH
24715: LD_INT 181
24717: PUSH
24718: LD_INT 88
24720: PUSH
24721: LD_INT 2
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: LIST
24728: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24729: LD_VAR 0 1
24733: PPUSH
24734: LD_VAR 0 2
24738: PUSH
24739: LD_INT 1
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 2
24747: PUSH
24748: LD_INT 2
24750: ARRAY
24751: PPUSH
24752: CALL_OW 176
// if target [ 3 ] = 1 then
24756: LD_VAR 0 2
24760: PUSH
24761: LD_INT 3
24763: ARRAY
24764: PUSH
24765: LD_INT 1
24767: EQUAL
24768: IFFALSE 24784
// SayRadio ( Kurt , D12-Kurt-1 ) else
24770: LD_EXP 60
24774: PPUSH
24775: LD_STRING D12-Kurt-1
24777: PPUSH
24778: CALL_OW 94
24782: GO 24808
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24784: LD_EXP 60
24788: PPUSH
24789: LD_STRING D12a-Kurt-1
24791: PPUSH
24792: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24796: LD_EXP 74
24800: PPUSH
24801: LD_STRING D12a-Roth-1
24803: PPUSH
24804: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24808: LD_INT 350
24810: PPUSH
24811: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24815: LD_VAR 0 1
24819: PPUSH
24820: LD_INT 22
24822: PUSH
24823: LD_INT 8
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: PUSH
24830: LD_INT 23
24832: PUSH
24833: LD_INT 2
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 30
24842: PUSH
24843: LD_INT 3
24845: PUSH
24846: EMPTY
24847: LIST
24848: LIST
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: CALL_OW 228
// end ;
24868: PPOPN 2
24870: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24871: LD_EXP 60
24875: PPUSH
24876: CALL_OW 256
24880: PUSH
24881: LD_INT 999
24883: LESS
24884: PUSH
24885: LD_INT 22
24887: PUSH
24888: LD_INT 8
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: PUSH
24895: LD_INT 21
24897: PUSH
24898: LD_INT 1
24900: PUSH
24901: EMPTY
24902: LIST
24903: LIST
24904: PUSH
24905: LD_INT 23
24907: PUSH
24908: LD_INT 2
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: LIST
24919: PPUSH
24920: CALL_OW 69
24924: PUSH
24925: LD_INT 9
24927: PUSH
24928: LD_INT 8
24930: PUSH
24931: LD_INT 7
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: LIST
24938: PUSH
24939: LD_OWVAR 67
24943: ARRAY
24944: LESSEQUAL
24945: OR
24946: PUSH
24947: LD_INT 22
24949: PUSH
24950: LD_INT 8
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: PUSH
24957: LD_INT 34
24959: PUSH
24960: LD_INT 48
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PPUSH
24971: CALL_OW 69
24975: NOT
24976: AND
24977: PUSH
24978: LD_EXP 60
24982: PPUSH
24983: CALL_OW 302
24987: AND
24988: PUSH
24989: LD_INT 5
24991: PPUSH
24992: LD_INT 22
24994: PUSH
24995: LD_INT 1
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PPUSH
25002: CALL_OW 70
25006: AND
25007: IFFALSE 25712
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
25016: PPUSH
// begin DialogueOn ;
25017: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25021: LD_EXP 39
25025: PPUSH
25026: LD_STRING D13-JMM-1
25028: PPUSH
25029: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25033: LD_EXP 60
25037: PPUSH
25038: LD_STRING D13-Kurt-1
25040: PPUSH
25041: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25045: LD_EXP 39
25049: PPUSH
25050: LD_STRING D13-JMM-2
25052: PPUSH
25053: CALL_OW 88
// if FakeInfo then
25057: LD_EXP 12
25061: IFFALSE 25081
// begin Say ( Kurt , D13-Kurt-2 ) ;
25063: LD_EXP 60
25067: PPUSH
25068: LD_STRING D13-Kurt-2
25070: PPUSH
25071: CALL_OW 88
// DialogueOff ;
25075: CALL_OW 7
// exit ;
25079: GO 25712
// end ; if not KurtStatus then
25081: LD_EXP 3
25085: NOT
25086: IFFALSE 25102
// Say ( Kurt , D13-Kurt-2b ) else
25088: LD_EXP 60
25092: PPUSH
25093: LD_STRING D13-Kurt-2b
25095: PPUSH
25096: CALL_OW 88
25100: GO 25114
// Say ( Kurt , D13-Kurt-2a ) ;
25102: LD_EXP 60
25106: PPUSH
25107: LD_STRING D13-Kurt-2a
25109: PPUSH
25110: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25114: LD_EXP 39
25118: PPUSH
25119: LD_STRING D13-JMM-3
25121: PPUSH
25122: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25126: LD_EXP 60
25130: PPUSH
25131: LD_STRING D13-Kurt-3
25133: PPUSH
25134: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25138: LD_EXP 39
25142: PPUSH
25143: LD_STRING D13-JMM-4
25145: PPUSH
25146: CALL_OW 88
// DialogueOff ;
25150: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25154: LD_STRING MlegionOut
25156: PPUSH
25157: CALL_OW 337
// legionDestroyed := true ;
25161: LD_ADDR_EXP 22
25165: PUSH
25166: LD_INT 1
25168: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25169: LD_INT 3
25171: PPUSH
25172: CALL 35316 0 1
// KillUnit ( Kozlov ) ;
25176: LD_EXP 61
25180: PPUSH
25181: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25185: LD_ADDR_VAR 0 1
25189: PUSH
25190: LD_INT 22
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 23
25202: PUSH
25203: LD_INT 3
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: PUSH
25210: LD_INT 3
25212: PUSH
25213: LD_INT 21
25215: PUSH
25216: LD_INT 33
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 69
25236: PUSH
25237: FOR_IN
25238: IFFALSE 25251
// KillUnit ( i ) ;
25240: LD_VAR 0 1
25244: PPUSH
25245: CALL_OW 66
25249: GO 25237
25251: POP
25252: POP
// ChangeSideFog ( 8 , 1 ) ;
25253: LD_INT 8
25255: PPUSH
25256: LD_INT 1
25258: PPUSH
25259: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25263: LD_ADDR_VAR 0 2
25267: PUSH
25268: LD_INT 22
25270: PUSH
25271: LD_INT 8
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 21
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PPUSH
25292: CALL_OW 69
25296: PUSH
25297: LD_EXP 61
25301: PUSH
25302: LD_EXP 60
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: DIFF
25311: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25312: LD_VAR 0 2
25316: PUSH
25317: LD_INT 6
25319: PUSH
25320: LD_INT 5
25322: PUSH
25323: LD_INT 4
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: LIST
25330: PUSH
25331: LD_OWVAR 67
25335: ARRAY
25336: GREATEREQUAL
25337: IFFALSE 25511
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25339: LD_ADDR_VAR 0 3
25343: PUSH
25344: LD_INT 6
25346: PUSH
25347: LD_INT 5
25349: PUSH
25350: LD_INT 4
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_OWVAR 67
25362: ARRAY
25363: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25364: LD_ADDR_VAR 0 1
25368: PUSH
25369: DOUBLE
25370: LD_VAR 0 2
25374: PUSH
25375: LD_VAR 0 3
25379: PUSH
25380: LD_INT 1
25382: PLUS
25383: MINUS
25384: INC
25385: ST_TO_ADDR
25386: LD_INT 1
25388: PUSH
25389: FOR_DOWNTO
25390: IFFALSE 25507
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25392: LD_ADDR_EXP 38
25396: PUSH
25397: LD_EXP 38
25401: PUSH
25402: LD_VAR 0 2
25406: PUSH
25407: LD_VAR 0 1
25411: ARRAY
25412: ADD
25413: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25414: LD_VAR 0 2
25418: PUSH
25419: LD_VAR 0 1
25423: ARRAY
25424: PPUSH
25425: CALL_OW 310
25429: IFFALSE 25446
// ComExitBuilding ( tmp [ i ] ) ;
25431: LD_VAR 0 2
25435: PUSH
25436: LD_VAR 0 1
25440: ARRAY
25441: PPUSH
25442: CALL_OW 122
// if IsInUnit ( i ) then
25446: LD_VAR 0 1
25450: PPUSH
25451: CALL_OW 310
25455: IFFALSE 25472
// ComExitVehicle ( tmp [ i ] ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25472: LD_VAR 0 2
25476: PUSH
25477: LD_VAR 0 1
25481: ARRAY
25482: PPUSH
25483: LD_INT 34
25485: PUSH
25486: LD_INT 0
25488: PPUSH
25489: LD_INT 6
25491: PPUSH
25492: CALL_OW 12
25496: PLUS
25497: PPUSH
25498: LD_INT 1
25500: PPUSH
25501: CALL_OW 171
// end ;
25505: GO 25389
25507: POP
25508: POP
// end else
25509: GO 25521
// x := tmp ;
25511: LD_ADDR_VAR 0 3
25515: PUSH
25516: LD_VAR 0 2
25520: ST_TO_ADDR
// for i := tmp downto tmp - x do
25521: LD_ADDR_VAR 0 1
25525: PUSH
25526: DOUBLE
25527: LD_VAR 0 2
25531: INC
25532: ST_TO_ADDR
25533: LD_VAR 0 2
25537: PUSH
25538: LD_VAR 0 3
25542: MINUS
25543: PUSH
25544: FOR_DOWNTO
25545: IFFALSE 25599
// begin if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitVehicle ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25579: LD_VAR 0 2
25583: PUSH
25584: LD_VAR 0 1
25588: ARRAY
25589: PPUSH
25590: LD_INT 1
25592: PPUSH
25593: CALL_OW 235
// end ;
25597: GO 25544
25599: POP
25600: POP
// SetSide ( Kurt , 1 ) ;
25601: LD_EXP 60
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25613: LD_INT 22
25615: PUSH
25616: LD_INT 8
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 21
25625: PUSH
25626: LD_INT 3
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PPUSH
25637: CALL_OW 69
25641: PPUSH
25642: LD_INT 1
25644: PPUSH
25645: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25649: LD_INT 8
25651: PPUSH
25652: LD_INT 1
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: LD_INT 1
25660: PPUSH
25661: CALL_OW 80
// wait ( 1 1$20 ) ;
25665: LD_INT 2800
25667: PPUSH
25668: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25672: LD_EXP 62
25676: PPUSH
25677: LD_INT 37
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 0
25685: PPUSH
25686: CALL_OW 48
// wait ( 0 0$1 ) ;
25690: LD_INT 35
25692: PPUSH
25693: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25697: LD_EXP 62
25701: PPUSH
25702: LD_INT 60
25704: PPUSH
25705: LD_INT 95
25707: PPUSH
25708: CALL_OW 111
// end ;
25712: PPOPN 3
25714: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25715: LD_EXP 22
25719: NOT
25720: PUSH
25721: LD_INT 22
25723: PUSH
25724: LD_INT 8
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 21
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PPUSH
25745: CALL_OW 69
25749: PUSH
25750: LD_INT 0
25752: EQUAL
25753: AND
25754: IFFALSE 25774
25756: GO 25758
25758: DISABLE
// begin legionDestroyed := true ;
25759: LD_ADDR_EXP 22
25763: PUSH
25764: LD_INT 1
25766: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25767: LD_STRING MlegionOut
25769: PPUSH
25770: CALL_OW 337
// end ;
25774: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25775: LD_EXP 38
25779: IFFALSE 25854
25781: GO 25783
25783: DISABLE
25784: LD_INT 0
25786: PPUSH
// begin enable ;
25787: ENABLE
// for i in legionEscapeUnits do
25788: LD_ADDR_VAR 0 1
25792: PUSH
25793: LD_EXP 38
25797: PUSH
25798: FOR_IN
25799: IFFALSE 25852
// begin if IsInArea ( i , legionEscapeArea ) then
25801: LD_VAR 0 1
25805: PPUSH
25806: LD_INT 31
25808: PPUSH
25809: CALL_OW 308
25813: IFFALSE 25826
// RemoveUnit ( i ) else
25815: LD_VAR 0 1
25819: PPUSH
25820: CALL_OW 64
25824: GO 25850
// if not HasTask ( i ) then
25826: LD_VAR 0 1
25830: PPUSH
25831: CALL_OW 314
25835: NOT
25836: IFFALSE 25850
// ComMoveToArea ( i , legionEscapeArea ) ;
25838: LD_VAR 0 1
25842: PPUSH
25843: LD_INT 31
25845: PPUSH
25846: CALL_OW 113
// end ;
25850: GO 25798
25852: POP
25853: POP
// end ;
25854: PPOPN 1
25856: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25857: LD_INT 1
25859: PPUSH
25860: LD_EXP 62
25864: PPUSH
25865: CALL_OW 292
25869: IFFALSE 26167
25871: GO 25873
25873: DISABLE
25874: LD_INT 0
25876: PPUSH
// begin wait ( 0 0$2 ) ;
25877: LD_INT 70
25879: PPUSH
25880: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25884: LD_EXP 62
25888: PPUSH
25889: CALL_OW 87
// DialogueOn ;
25893: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25897: LD_EXP 39
25901: PPUSH
25902: LD_STRING D14-JMM-1
25904: PPUSH
25905: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25909: LD_EXP 62
25913: PPUSH
25914: LD_STRING D14-Friend-1
25916: PPUSH
25917: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25921: LD_EXP 39
25925: PPUSH
25926: LD_STRING D14-JMM-2
25928: PPUSH
25929: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25933: LD_EXP 62
25937: PPUSH
25938: LD_STRING D14-Friend-2
25940: PPUSH
25941: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25945: LD_EXP 39
25949: PPUSH
25950: LD_STRING D14-JMM-3
25952: PPUSH
25953: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25957: LD_EXP 62
25961: PPUSH
25962: LD_STRING D14-Friend-3
25964: PPUSH
25965: CALL_OW 88
// DialogueOff ;
25969: CALL_OW 7
// dec = Query ( Q14 ) ;
25973: LD_ADDR_VAR 0 1
25977: PUSH
25978: LD_STRING Q14
25980: PPUSH
25981: CALL_OW 97
25985: ST_TO_ADDR
// if dec = 1 then
25986: LD_VAR 0 1
25990: PUSH
25991: LD_INT 1
25993: EQUAL
25994: IFFALSE 26028
// begin DialogueOn ;
25996: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26000: LD_EXP 39
26004: PPUSH
26005: LD_STRING D14a-JMM-1
26007: PPUSH
26008: CALL_OW 88
// DialogueOff ;
26012: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26016: LD_EXP 62
26020: PPUSH
26021: LD_INT 1
26023: PPUSH
26024: CALL_OW 235
// end ; if dec = 2 then
26028: LD_VAR 0 1
26032: PUSH
26033: LD_INT 2
26035: EQUAL
26036: IFFALSE 26089
// begin DialogueOn ;
26038: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26042: LD_EXP 39
26046: PPUSH
26047: LD_STRING D14b-JMM-1
26049: PPUSH
26050: CALL_OW 88
// DialogueOff ;
26054: CALL_OW 7
// wait ( 0 0$1 ) ;
26058: LD_INT 35
26060: PPUSH
26061: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26065: LD_EXP 62
26069: PPUSH
26070: LD_INT 9
26072: PPUSH
26073: LD_INT 2
26075: PPUSH
26076: CALL_OW 111
// AddComHold ( Friend ) ;
26080: LD_EXP 62
26084: PPUSH
26085: CALL_OW 200
// end ; if dec = 3 then
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 3
26096: EQUAL
26097: IFFALSE 26167
// begin DialogueOn ;
26099: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26103: LD_EXP 39
26107: PPUSH
26108: LD_STRING D14c-JMM-1
26110: PPUSH
26111: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26115: LD_EXP 62
26119: PPUSH
26120: LD_STRING D14c-Friend-1
26122: PPUSH
26123: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26127: LD_EXP 39
26131: PPUSH
26132: LD_STRING D14c-JMM-2
26134: PPUSH
26135: CALL_OW 88
// DialogueOff ;
26139: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26143: LD_EXP 62
26147: PPUSH
26148: LD_INT 9
26150: PPUSH
26151: LD_INT 2
26153: PPUSH
26154: CALL_OW 111
// AddComHold ( Friend ) ;
26158: LD_EXP 62
26162: PPUSH
26163: CALL_OW 200
// end ; end ;
26167: PPOPN 1
26169: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26170: LD_INT 9
26172: PPUSH
26173: LD_INT 2
26175: PPUSH
26176: CALL_OW 428
26180: PUSH
26181: LD_EXP 62
26185: EQUAL
26186: PUSH
26187: LD_EXP 62
26191: PPUSH
26192: CALL_OW 255
26196: PUSH
26197: LD_INT 8
26199: EQUAL
26200: AND
26201: IFFALSE 26215
26203: GO 26205
26205: DISABLE
// RemoveUnit ( Friend ) ;
26206: LD_EXP 62
26210: PPUSH
26211: CALL_OW 64
26215: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26216: LD_EXP 14
26220: PUSH
26221: LD_INT 31500
26223: GREATEREQUAL
26224: PUSH
26225: LD_EXP 7
26229: AND
26230: PUSH
26231: LD_EXP 2
26235: AND
26236: IFFALSE 26666
26238: GO 26240
26240: DISABLE
26241: LD_INT 0
26243: PPUSH
26244: PPUSH
26245: PPUSH
// begin missionStage := 7 ;
26246: LD_ADDR_EXP 15
26250: PUSH
26251: LD_INT 7
26253: ST_TO_ADDR
// uc_side = 1 ;
26254: LD_ADDR_OWVAR 20
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// uc_nation = 1 ;
26262: LD_ADDR_OWVAR 21
26266: PUSH
26267: LD_INT 1
26269: ST_TO_ADDR
// for i = 1 to 5 do
26270: LD_ADDR_VAR 0 1
26274: PUSH
26275: DOUBLE
26276: LD_INT 1
26278: DEC
26279: ST_TO_ADDR
26280: LD_INT 5
26282: PUSH
26283: FOR_TO
26284: IFFALSE 26380
// begin vc_engine = 3 ;
26286: LD_ADDR_OWVAR 39
26290: PUSH
26291: LD_INT 3
26293: ST_TO_ADDR
// vc_control = 3 ;
26294: LD_ADDR_OWVAR 38
26298: PUSH
26299: LD_INT 3
26301: ST_TO_ADDR
// vc_chassis = 3 ;
26302: LD_ADDR_OWVAR 37
26306: PUSH
26307: LD_INT 3
26309: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26310: LD_ADDR_OWVAR 40
26314: PUSH
26315: LD_INT 5
26317: PUSH
26318: LD_INT 9
26320: PUSH
26321: LD_INT 7
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PPUSH
26332: LD_INT 3
26334: PPUSH
26335: CALL_OW 12
26339: ARRAY
26340: ST_TO_ADDR
// veh = CreateVehicle ;
26341: LD_ADDR_VAR 0 2
26345: PUSH
26346: CALL_OW 45
26350: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26351: LD_VAR 0 2
26355: PPUSH
26356: LD_INT 1
26358: PPUSH
26359: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26363: LD_VAR 0 2
26367: PPUSH
26368: LD_INT 19
26370: PPUSH
26371: LD_INT 0
26373: PPUSH
26374: CALL_OW 49
// end ;
26378: GO 26283
26380: POP
26381: POP
// vc_engine = 3 ;
26382: LD_ADDR_OWVAR 39
26386: PUSH
26387: LD_INT 3
26389: ST_TO_ADDR
// vc_control = 1 ;
26390: LD_ADDR_OWVAR 38
26394: PUSH
26395: LD_INT 1
26397: ST_TO_ADDR
// vc_chassis = 3 ;
26398: LD_ADDR_OWVAR 37
26402: PUSH
26403: LD_INT 3
26405: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26406: LD_ADDR_OWVAR 40
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: LD_INT 9
26416: PUSH
26417: LD_INT 7
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 1
26427: PPUSH
26428: LD_INT 3
26430: PPUSH
26431: CALL_OW 12
26435: ARRAY
26436: ST_TO_ADDR
// vehG = CreateVehicle ;
26437: LD_ADDR_VAR 0 3
26441: PUSH
26442: CALL_OW 45
26446: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26447: LD_VAR 0 3
26451: PPUSH
26452: LD_INT 1
26454: PPUSH
26455: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26459: LD_VAR 0 3
26463: PPUSH
26464: LD_INT 19
26466: PPUSH
26467: LD_INT 0
26469: PPUSH
26470: CALL_OW 49
// if JMMGirl = 1 then
26474: LD_EXP 7
26478: PUSH
26479: LD_INT 1
26481: EQUAL
26482: IFFALSE 26538
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26484: LD_ADDR_EXP 40
26488: PUSH
26489: LD_STRING Joan
26491: PPUSH
26492: LD_INT 1
26494: PPUSH
26495: LD_STRING 14_
26497: PPUSH
26498: CALL 65104 0 3
26502: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26503: LD_EXP 40
26507: PPUSH
26508: LD_VAR 0 3
26512: PPUSH
26513: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26517: LD_VAR 0 3
26521: PPUSH
26522: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26526: LD_EXP 40
26530: PPUSH
26531: LD_STRING D10BW-Joan-1
26533: PPUSH
26534: CALL_OW 94
// end ; if JMMGirl = 2 then
26538: LD_EXP 7
26542: PUSH
26543: LD_INT 2
26545: EQUAL
26546: IFFALSE 26602
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26548: LD_ADDR_EXP 42
26552: PUSH
26553: LD_STRING Lisa
26555: PPUSH
26556: LD_INT 1
26558: PPUSH
26559: LD_STRING 14_
26561: PPUSH
26562: CALL 65104 0 3
26566: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26567: LD_EXP 42
26571: PPUSH
26572: LD_VAR 0 3
26576: PPUSH
26577: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26581: LD_VAR 0 3
26585: PPUSH
26586: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26590: LD_EXP 42
26594: PPUSH
26595: LD_STRING D10BW-Lisa-1
26597: PPUSH
26598: CALL_OW 94
// end ; if JMMGirl = 3 then
26602: LD_EXP 7
26606: PUSH
26607: LD_INT 3
26609: EQUAL
26610: IFFALSE 26666
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26612: LD_ADDR_EXP 54
26616: PUSH
26617: LD_STRING Connie
26619: PPUSH
26620: LD_INT 1
26622: PPUSH
26623: LD_STRING 14_
26625: PPUSH
26626: CALL 65104 0 3
26630: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26631: LD_EXP 54
26635: PPUSH
26636: LD_VAR 0 3
26640: PPUSH
26641: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26654: LD_EXP 54
26658: PPUSH
26659: LD_STRING D10BW-Con-1
26661: PPUSH
26662: CALL_OW 94
// end ; end ;
26666: PPOPN 3
26668: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26669: LD_EXP 14
26673: PUSH
26674: LD_INT 94500
26676: GREATEREQUAL
26677: IFFALSE 27089
26679: GO 26681
26681: DISABLE
26682: LD_INT 0
26684: PPUSH
26685: PPUSH
26686: PPUSH
// begin tmp := PrepareStevensSquad ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: CALL 2197 0 0
26696: ST_TO_ADDR
// if not tmp then
26697: LD_VAR 0 3
26701: NOT
26702: IFFALSE 26706
// exit ;
26704: GO 27089
// uc_side := 1 ;
26706: LD_ADDR_OWVAR 20
26710: PUSH
26711: LD_INT 1
26713: ST_TO_ADDR
// uc_nation := 1 ;
26714: LD_ADDR_OWVAR 21
26718: PUSH
26719: LD_INT 1
26721: ST_TO_ADDR
// for i in tmp do
26722: LD_ADDR_VAR 0 1
26726: PUSH
26727: LD_VAR 0 3
26731: PUSH
26732: FOR_IN
26733: IFFALSE 26830
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26735: LD_INT 3
26737: PPUSH
26738: LD_INT 3
26740: PPUSH
26741: LD_INT 1
26743: PPUSH
26744: LD_INT 5
26746: PUSH
26747: LD_INT 9
26749: PUSH
26750: LD_INT 7
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: PPUSH
26761: LD_INT 3
26763: PPUSH
26764: CALL_OW 12
26768: ARRAY
26769: PPUSH
26770: LD_INT 40
26772: PPUSH
26773: CALL 69928 0 5
// veh := CreateVehicle ;
26777: LD_ADDR_VAR 0 2
26781: PUSH
26782: CALL_OW 45
26786: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26787: LD_VAR 0 2
26791: PPUSH
26792: LD_INT 1
26794: PPUSH
26795: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26799: LD_VAR 0 2
26803: PPUSH
26804: LD_INT 19
26806: PPUSH
26807: LD_INT 0
26809: PPUSH
26810: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26814: LD_VAR 0 1
26818: PPUSH
26819: LD_VAR 0 2
26823: PPUSH
26824: CALL_OW 52
// end ;
26828: GO 26732
26830: POP
26831: POP
// missionStage := 8 ;
26832: LD_ADDR_EXP 15
26836: PUSH
26837: LD_INT 8
26839: ST_TO_ADDR
// DialogueOn ;
26840: CALL_OW 6
// if Stevens then
26844: LD_EXP 41
26848: IFFALSE 26962
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26850: LD_EXP 41
26854: PPUSH
26855: CALL_OW 310
26859: PPUSH
26860: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26864: LD_EXP 41
26868: PPUSH
26869: LD_STRING D8-Huck-1
26871: PPUSH
26872: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26876: LD_EXP 39
26880: PPUSH
26881: LD_STRING D8-JMM-1
26883: PPUSH
26884: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26888: LD_EXP 41
26892: PPUSH
26893: LD_STRING D8-Huck-2
26895: PPUSH
26896: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26900: LD_EXP 39
26904: PPUSH
26905: LD_STRING D8-JMM-2
26907: PPUSH
26908: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26912: LD_EXP 41
26916: PPUSH
26917: LD_STRING D8-Huck-3
26919: PPUSH
26920: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26924: LD_EXP 39
26928: PPUSH
26929: LD_STRING D8-JMM-3
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26936: LD_EXP 41
26940: PPUSH
26941: LD_STRING D8-Huck-4
26943: PPUSH
26944: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26948: LD_EXP 39
26952: PPUSH
26953: LD_STRING D8-JMM-4
26955: PPUSH
26956: CALL_OW 88
// end else
26960: GO 27072
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26962: LD_EXP 55
26966: PPUSH
26967: CALL_OW 310
26971: PPUSH
26972: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26976: LD_EXP 55
26980: PPUSH
26981: LD_STRING D8-Huck-1
26983: PPUSH
26984: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26988: LD_EXP 39
26992: PPUSH
26993: LD_STRING D8-JMM-1a
26995: PPUSH
26996: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27000: LD_EXP 55
27004: PPUSH
27005: LD_STRING D8-Huck-2
27007: PPUSH
27008: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27012: LD_EXP 39
27016: PPUSH
27017: LD_STRING D8-JMM-2
27019: PPUSH
27020: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27024: LD_EXP 55
27028: PPUSH
27029: LD_STRING D8-Huck-3
27031: PPUSH
27032: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27036: LD_EXP 39
27040: PPUSH
27041: LD_STRING D8-JMM-3
27043: PPUSH
27044: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27048: LD_EXP 55
27052: PPUSH
27053: LD_STRING D8-Huck-4
27055: PPUSH
27056: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27060: LD_EXP 39
27064: PPUSH
27065: LD_STRING D8-JMM-4
27067: PPUSH
27068: CALL_OW 88
// end ; DialogueOff ;
27072: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27076: LD_INT 25
27078: PPUSH
27079: LD_INT 1
27081: PPUSH
27082: LD_INT 1
27084: PPUSH
27085: CALL_OW 322
// end ;
27089: PPOPN 3
27091: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27092: LD_INT 1
27094: PPUSH
27095: LD_EXP 71
27099: PPUSH
27100: CALL_OW 292
27104: IFFALSE 27355
27106: GO 27108
27108: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27109: LD_EXP 71
27113: PPUSH
27114: CALL_OW 87
// DialogueOn ;
27118: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27122: LD_EXP 39
27126: PPUSH
27127: LD_STRING D10nB-JMM-1
27129: PPUSH
27130: CALL_OW 88
// if BurlakStatus = 1 then
27134: LD_EXP 9
27138: PUSH
27139: LD_INT 1
27141: EQUAL
27142: IFFALSE 27156
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27144: LD_EXP 70
27148: PPUSH
27149: LD_STRING D10nB-Vse-1a
27151: PPUSH
27152: CALL_OW 94
// end ; if BurlakStatus = 0 then
27156: LD_EXP 9
27160: PUSH
27161: LD_INT 0
27163: EQUAL
27164: IFFALSE 27178
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27166: LD_EXP 70
27170: PPUSH
27171: LD_STRING D10nB-Vse-1
27173: PPUSH
27174: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27178: LD_EXP 39
27182: PPUSH
27183: LD_STRING D10nB-JMM-2
27185: PPUSH
27186: CALL_OW 88
// if KappaStatus then
27190: LD_EXP 2
27194: IFFALSE 27208
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27196: LD_EXP 70
27200: PPUSH
27201: LD_STRING D10nB-Vse-5a
27203: PPUSH
27204: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27208: LD_EXP 2
27212: NOT
27213: PUSH
27214: LD_EXP 6
27218: PUSH
27219: LD_INT 0
27221: EQUAL
27222: AND
27223: IFFALSE 27351
// begin if JMMGirl = 1 then
27225: LD_EXP 7
27229: PUSH
27230: LD_INT 1
27232: EQUAL
27233: IFFALSE 27283
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27235: LD_EXP 70
27239: PPUSH
27240: LD_STRING D10nB-Vse-2
27242: PPUSH
27243: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27247: LD_EXP 39
27251: PPUSH
27252: LD_STRING D10nB-JMM-3
27254: PPUSH
27255: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27259: LD_EXP 70
27263: PPUSH
27264: LD_STRING D10nB-Vse-3
27266: PPUSH
27267: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27271: LD_EXP 39
27275: PPUSH
27276: LD_STRING D10nB-JMM-4
27278: PPUSH
27279: CALL_OW 88
// end ; if JMMGirl = 2 then
27283: LD_EXP 7
27287: PUSH
27288: LD_INT 2
27290: EQUAL
27291: IFFALSE 27317
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27293: LD_EXP 70
27297: PPUSH
27298: LD_STRING D10nB-Vse-4
27300: PPUSH
27301: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27305: LD_EXP 39
27309: PPUSH
27310: LD_STRING D10nB-JMM-5
27312: PPUSH
27313: CALL_OW 88
// end ; if JMMGirl = 3 then
27317: LD_EXP 7
27321: PUSH
27322: LD_INT 3
27324: EQUAL
27325: IFFALSE 27351
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27327: LD_EXP 70
27331: PPUSH
27332: LD_STRING D10nB-Vse-5
27334: PPUSH
27335: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27339: LD_EXP 39
27343: PPUSH
27344: LD_STRING D10nB-JMM-6
27346: PPUSH
27347: CALL_OW 88
// end ; end ; DialogueOff ;
27351: CALL_OW 7
// end ;
27355: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27356: LD_EXP 14
27360: PUSH
27361: LD_INT 115500
27363: GREATEREQUAL
27364: IFFALSE 27740
27366: GO 27368
27368: DISABLE
27369: LD_INT 0
27371: PPUSH
// begin missionStage := 10 ;
27372: LD_ADDR_EXP 15
27376: PUSH
27377: LD_INT 10
27379: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27380: LD_ADDR_VAR 0 1
27384: PUSH
27385: LD_INT 22
27387: PUSH
27388: LD_INT 1
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 23
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 26
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 25
27420: PUSH
27421: LD_INT 12
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 3
27434: PUSH
27435: LD_INT 25
27437: PUSH
27438: LD_INT 16
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: PPUSH
27456: CALL_OW 69
27460: PUSH
27461: LD_EXP 39
27465: PUSH
27466: LD_EXP 60
27470: PUSH
27471: LD_EXP 41
27475: PUSH
27476: LD_EXP 55
27480: PUSH
27481: LD_EXP 42
27485: PUSH
27486: LD_EXP 43
27490: PUSH
27491: LD_EXP 44
27495: PUSH
27496: LD_EXP 45
27500: PUSH
27501: LD_EXP 46
27505: PUSH
27506: LD_EXP 47
27510: PUSH
27511: LD_EXP 48
27515: PUSH
27516: LD_EXP 49
27520: PUSH
27521: LD_EXP 50
27525: PUSH
27526: LD_EXP 51
27530: PUSH
27531: LD_EXP 52
27535: PUSH
27536: LD_EXP 53
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: DIFF
27559: ST_TO_ADDR
// if not tmp and Brown then
27560: LD_VAR 0 1
27564: NOT
27565: PUSH
27566: LD_EXP 47
27570: AND
27571: IFFALSE 27586
// tmp := [ Brown ] ;
27573: LD_ADDR_VAR 0 1
27577: PUSH
27578: LD_EXP 47
27582: PUSH
27583: EMPTY
27584: LIST
27585: ST_TO_ADDR
// DialogueOn ;
27586: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27590: LD_VAR 0 1
27594: PUSH
27595: LD_INT 1
27597: ARRAY
27598: PPUSH
27599: LD_STRING D11-Sol1-1
27601: PPUSH
27602: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27606: LD_EXP 64
27610: PPUSH
27611: LD_STRING D11-Pla-1
27613: PPUSH
27614: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27618: LD_EXP 65
27622: PPUSH
27623: LD_STRING D11-Kov-1
27625: PPUSH
27626: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27630: LD_EXP 64
27634: PPUSH
27635: LD_STRING D11-Pla-2
27637: PPUSH
27638: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27642: LD_VAR 0 1
27646: PUSH
27647: LD_INT 1
27649: ARRAY
27650: PPUSH
27651: LD_STRING D11-Sol1-2
27653: PPUSH
27654: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27658: LD_EXP 39
27662: PPUSH
27663: LD_STRING D11-JMM-2
27665: PPUSH
27666: CALL_OW 88
// DialogueOff ;
27670: CALL_OW 7
// allowBehemothConstruct := true ;
27674: LD_ADDR_EXP 25
27678: PUSH
27679: LD_INT 1
27681: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27682: LD_STRING M4
27684: PPUSH
27685: CALL_OW 337
// BuildBehemoths ;
27689: CALL 7668 0 0
// repeat wait ( 15 15$00 ) ;
27693: LD_INT 31500
27695: PPUSH
27696: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27700: LD_EXP 27
27704: IFFALSE 27708
// break ;
27706: GO 27740
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27708: LD_INT 267
27710: PPUSH
27711: CALL_OW 274
27715: PPUSH
27716: LD_INT 1
27718: PPUSH
27719: CALL_OW 275
27723: PUSH
27724: LD_INT 1000
27726: GREATEREQUAL
27727: IFFALSE 27733
// BuildBehemoths ;
27729: CALL 7668 0 0
// until not behemothBuilders ;
27733: LD_EXP 73
27737: NOT
27738: IFFALSE 27693
// end ;
27740: PPOPN 1
27742: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27743: LD_EXP 73
27747: NOT
27748: PUSH
27749: LD_EXP 28
27753: NOT
27754: AND
27755: PUSH
27756: LD_EXP 25
27760: AND
27761: IFFALSE 27781
27763: GO 27765
27765: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27766: LD_STRING M4a
27768: PPUSH
27769: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27773: LD_ADDR_EXP 27
27777: PUSH
27778: LD_INT 1
27780: ST_TO_ADDR
// end ;
27781: END
// every 0 0$1 trigger behemothDone do
27782: LD_EXP 28
27786: IFFALSE 27798
27788: GO 27790
27790: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27791: LD_STRING M4b
27793: PPUSH
27794: CALL_OW 337
27798: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27799: LD_EXP 29
27803: NOT
27804: IFFALSE 28000
27806: GO 27808
27808: DISABLE
27809: LD_INT 0
27811: PPUSH
27812: PPUSH
// begin enable ;
27813: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27814: LD_ADDR_VAR 0 1
27818: PUSH
27819: LD_INT 3
27821: PPUSH
27822: CALL 101035 0 1
27826: ST_TO_ADDR
// if not tmp and not behemothDone then
27827: LD_VAR 0 1
27831: NOT
27832: PUSH
27833: LD_EXP 28
27837: NOT
27838: AND
27839: IFFALSE 27875
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27841: LD_ADDR_VAR 0 1
27845: PUSH
27846: LD_INT 22
27848: PUSH
27849: LD_INT 3
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 30
27858: PUSH
27859: LD_INT 37
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: ST_TO_ADDR
// if not tmp then
27875: LD_VAR 0 1
27879: NOT
27880: IFFALSE 27884
// exit ;
27882: GO 28000
// for i in tmp do
27884: LD_ADDR_VAR 0 2
27888: PUSH
27889: LD_VAR 0 1
27893: PUSH
27894: FOR_IN
27895: IFFALSE 27998
// if See ( 1 , i ) then
27897: LD_INT 1
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: CALL_OW 292
27909: IFFALSE 27996
// begin if GetType ( i ) = unit_building then
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 247
27920: PUSH
27921: LD_INT 3
27923: EQUAL
27924: IFFALSE 27962
// begin CenterNowOnUnits ( i ) ;
27926: LD_VAR 0 2
27930: PPUSH
27931: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27935: LD_EXP 39
27939: PPUSH
27940: LD_STRING D17a-JMM-1
27942: PPUSH
27943: CALL_OW 88
// seeBehemoth := true ;
27947: LD_ADDR_EXP 29
27951: PUSH
27952: LD_INT 1
27954: ST_TO_ADDR
// disable ;
27955: DISABLE
// exit ;
27956: POP
27957: POP
27958: GO 28000
// end else
27960: GO 27996
// begin CenterNowOnUnits ( i ) ;
27962: LD_VAR 0 2
27966: PPUSH
27967: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27971: LD_EXP 39
27975: PPUSH
27976: LD_STRING D17b-JMM-1
27978: PPUSH
27979: CALL_OW 88
// seeBehemoth := true ;
27983: LD_ADDR_EXP 29
27987: PUSH
27988: LD_INT 1
27990: ST_TO_ADDR
// disable ;
27991: DISABLE
// exit ;
27992: POP
27993: POP
27994: GO 28000
// end ; end ;
27996: GO 27894
27998: POP
27999: POP
// end ;
28000: PPOPN 2
28002: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28003: LD_EXP 14
28007: PUSH
28008: LD_INT 123200
28010: GREATEREQUAL
28011: IFFALSE 29187
28013: GO 28015
28015: DISABLE
28016: LD_INT 0
28018: PPUSH
28019: PPUSH
28020: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28021: LD_INT 2
28023: PPUSH
28024: LD_INT 23
28026: PUSH
28027: LD_INT 3
28029: PUSH
28030: LD_INT 3
28032: PUSH
28033: LD_INT 48
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: EMPTY
28043: LIST
28044: PPUSH
28045: CALL 58760 0 2
// repeat wait ( 0 0$1 ) ;
28049: LD_INT 35
28051: PPUSH
28052: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28056: LD_INT 22
28058: PUSH
28059: LD_INT 3
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 34
28068: PUSH
28069: LD_INT 48
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PPUSH
28080: CALL_OW 69
28084: IFFALSE 28049
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28086: LD_ADDR_VAR 0 1
28090: PUSH
28091: LD_INT 22
28093: PUSH
28094: LD_INT 3
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 34
28103: PUSH
28104: LD_INT 48
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PPUSH
28115: CALL_OW 69
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: ST_TO_ADDR
// missionStage := 12 ;
28124: LD_ADDR_EXP 15
28128: PUSH
28129: LD_INT 12
28131: ST_TO_ADDR
// platonovHasBomb := true ;
28132: LD_ADDR_EXP 30
28136: PUSH
28137: LD_INT 1
28139: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: LD_INT 181
28147: PPUSH
28148: LD_INT 86
28150: PPUSH
28151: CALL_OW 171
// AddComHold ( bomb ) ;
28155: LD_VAR 0 1
28159: PPUSH
28160: CALL_OW 200
// wait ( 0 0$10 ) ;
28164: LD_INT 350
28166: PPUSH
28167: CALL_OW 67
// DialogueOn ;
28171: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28175: LD_EXP 64
28179: PPUSH
28180: LD_STRING D15-Pla-1
28182: PPUSH
28183: CALL_OW 94
// dec = Query ( Q15a ) ;
28187: LD_ADDR_VAR 0 2
28191: PUSH
28192: LD_STRING Q15a
28194: PPUSH
28195: CALL_OW 97
28199: ST_TO_ADDR
// if dec = 1 then
28200: LD_VAR 0 2
28204: PUSH
28205: LD_INT 1
28207: EQUAL
28208: IFFALSE 28231
// begin Say ( JMM , D15a-JMM-1 ) ;
28210: LD_EXP 39
28214: PPUSH
28215: LD_STRING D15a-JMM-1
28217: PPUSH
28218: CALL_OW 88
// YouLost ( Surrender ) ;
28222: LD_STRING Surrender
28224: PPUSH
28225: CALL_OW 104
// exit ;
28229: GO 29187
// end ; if dec = 2 then
28231: LD_VAR 0 2
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28308
// begin Say ( JMM , D15b-JMM-1 ) ;
28241: LD_EXP 39
28245: PPUSH
28246: LD_STRING D15b-JMM-1
28248: PPUSH
28249: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28253: LD_EXP 64
28257: PPUSH
28258: LD_STRING D15b-Pla-1
28260: PPUSH
28261: CALL_OW 94
// DialogueOff ;
28265: CALL_OW 7
// wait ( 3 3$00 ) ;
28269: LD_INT 6300
28271: PPUSH
28272: CALL_OW 67
// DialogueOn ;
28276: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28280: LD_EXP 39
28284: PPUSH
28285: LD_STRING D15d-JMM-1a
28287: PPUSH
28288: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28292: LD_EXP 64
28296: PPUSH
28297: LD_STRING D15d-Pla-1
28299: PPUSH
28300: CALL_OW 94
// DialogueOff ;
28304: CALL_OW 7
// end ; if dec = 3 then
28308: LD_VAR 0 2
28312: PUSH
28313: LD_INT 3
28315: EQUAL
28316: IFFALSE 28370
// begin Say ( JMM , D15c-JMM-1 ) ;
28318: LD_EXP 39
28322: PPUSH
28323: LD_STRING D15c-JMM-1
28325: PPUSH
28326: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28330: LD_EXP 64
28334: PPUSH
28335: LD_STRING D15c-Pla-1
28337: PPUSH
28338: CALL_OW 94
// DialogueOff ;
28342: CALL_OW 7
// wait ( 0 0$15 ) ;
28346: LD_INT 525
28348: PPUSH
28349: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28353: LD_VAR 0 1
28357: PPUSH
28358: LD_INT 60
28360: PPUSH
28361: LD_INT 95
28363: PPUSH
28364: CALL_OW 116
// exit ;
28368: GO 29187
// end ; if dec = 4 then
28370: LD_VAR 0 2
28374: PUSH
28375: LD_INT 4
28377: EQUAL
28378: IFFALSE 28408
// begin Say ( JMM , D15d-JMM-1 ) ;
28380: LD_EXP 39
28384: PPUSH
28385: LD_STRING D15d-JMM-1
28387: PPUSH
28388: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28392: LD_EXP 64
28396: PPUSH
28397: LD_STRING D15d-Pla-1
28399: PPUSH
28400: CALL_OW 94
// DialogueOff ;
28404: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28408: LD_EXP 62
28412: PPUSH
28413: CALL_OW 302
28417: PUSH
28418: LD_EXP 62
28422: PPUSH
28423: CALL_OW 255
28427: PUSH
28428: LD_INT 1
28430: EQUAL
28431: AND
28432: PUSH
28433: LD_INT 22
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 34
28445: PUSH
28446: LD_INT 8
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PPUSH
28457: CALL_OW 69
28461: NOT
28462: AND
28463: IFFALSE 29088
// begin SetSide ( Friend , 8 ) ;
28465: LD_EXP 62
28469: PPUSH
28470: LD_INT 8
28472: PPUSH
28473: CALL_OW 235
// if IsInUnit ( Friend ) then
28477: LD_EXP 62
28481: PPUSH
28482: CALL_OW 310
28486: IFFALSE 28497
// ComExitBuilding ( Friend ) ;
28488: LD_EXP 62
28492: PPUSH
28493: CALL_OW 122
// if IsDriver ( Friend ) then
28497: LD_EXP 62
28501: PPUSH
28502: CALL 98699 0 1
28506: IFFALSE 28517
// ComExitVehicle ( Friend ) ;
28508: LD_EXP 62
28512: PPUSH
28513: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28517: LD_EXP 62
28521: PPUSH
28522: LD_INT 9
28524: PPUSH
28525: LD_INT 2
28527: PPUSH
28528: CALL_OW 171
// wait ( 0 0$05 ) ;
28532: LD_INT 175
28534: PPUSH
28535: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28539: LD_EXP 62
28543: PPUSH
28544: CALL_OW 87
// DialogueOn ;
28548: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28552: LD_EXP 39
28556: PPUSH
28557: LD_STRING D16-JMM-1
28559: PPUSH
28560: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28564: LD_EXP 62
28568: PPUSH
28569: LD_STRING D16-Friend-1
28571: PPUSH
28572: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28576: LD_EXP 39
28580: PPUSH
28581: LD_STRING D16-JMM-2
28583: PPUSH
28584: CALL_OW 88
// DialogueOff ;
28588: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28592: LD_EXP 62
28596: PPUSH
28597: LD_INT 1
28599: PPUSH
28600: CALL_OW 235
// ComHold ( Friend ) ;
28604: LD_EXP 62
28608: PPUSH
28609: CALL_OW 140
// wait ( 0 0$20 ) ;
28613: LD_INT 700
28615: PPUSH
28616: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28620: LD_EXP 62
28624: PPUSH
28625: LD_INT 9
28627: PPUSH
28628: LD_INT 2
28630: PPUSH
28631: CALL_OW 297
28635: PUSH
28636: LD_INT 30
28638: LESS
28639: IFFALSE 28708
// begin SetSide ( Friend , 8 ) ;
28641: LD_EXP 62
28645: PPUSH
28646: LD_INT 8
28648: PPUSH
28649: CALL_OW 235
// if IsInUnit ( Friend ) then
28653: LD_EXP 62
28657: PPUSH
28658: CALL_OW 310
28662: IFFALSE 28673
// ComExitBuilding ( Friend ) ;
28664: LD_EXP 62
28668: PPUSH
28669: CALL_OW 122
// if IsDriver ( Friend ) then
28673: LD_EXP 62
28677: PPUSH
28678: CALL 98699 0 1
28682: IFFALSE 28693
// ComExitVehicle ( Friend ) ;
28684: LD_EXP 62
28688: PPUSH
28689: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28693: LD_EXP 62
28697: PPUSH
28698: LD_INT 9
28700: PPUSH
28701: LD_INT 2
28703: PPUSH
28704: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28708: LD_INT 1050
28710: PPUSH
28711: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28715: LD_INT 22
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 34
28727: PUSH
28728: LD_INT 8
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PPUSH
28739: CALL_OW 69
28743: NOT
28744: IFFALSE 29066
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28746: LD_ADDR_VAR 0 3
28750: PUSH
28751: LD_INT 22
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: PUSH
28761: LD_INT 26
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: PUSH
28774: LD_INT 25
28776: PUSH
28777: LD_INT 12
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 25
28786: PUSH
28787: LD_INT 16
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: LIST
28803: PPUSH
28804: CALL_OW 69
28808: PUSH
28809: LD_EXP 39
28813: PUSH
28814: LD_EXP 41
28818: PUSH
28819: LD_EXP 55
28823: PUSH
28824: LD_EXP 42
28828: PUSH
28829: LD_EXP 43
28833: PUSH
28834: LD_EXP 44
28838: PUSH
28839: LD_EXP 45
28843: PUSH
28844: LD_EXP 46
28848: PUSH
28849: LD_EXP 47
28853: PUSH
28854: LD_EXP 48
28858: PUSH
28859: LD_EXP 49
28863: PUSH
28864: LD_EXP 50
28868: PUSH
28869: LD_EXP 51
28873: PUSH
28874: LD_EXP 52
28878: PUSH
28879: LD_EXP 53
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: DIFF
28901: ST_TO_ADDR
// DialogueOn ;
28902: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28906: LD_EXP 64
28910: PPUSH
28911: LD_STRING D16a-Pla-1
28913: PPUSH
28914: CALL_OW 94
// if Stevens then
28918: LD_EXP 41
28922: IFFALSE 28938
// Say ( Stevens , D16a-Huck-1 ) else
28924: LD_EXP 41
28928: PPUSH
28929: LD_STRING D16a-Huck-1
28931: PPUSH
28932: CALL_OW 88
28936: GO 28980
// if Baker then
28938: LD_EXP 55
28942: IFFALSE 28958
// Say ( Baker , D16a-Huck-1 ) else
28944: LD_EXP 55
28948: PPUSH
28949: LD_STRING D16a-Huck-1
28951: PPUSH
28952: CALL_OW 88
28956: GO 28980
// if tmp then
28958: LD_VAR 0 3
28962: IFFALSE 28980
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28964: LD_VAR 0 3
28968: PUSH
28969: LD_INT 1
28971: ARRAY
28972: PPUSH
28973: LD_STRING D16a-Sol1-1
28975: PPUSH
28976: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28980: LD_EXP 62
28984: PPUSH
28985: CALL_OW 255
28989: PUSH
28990: LD_INT 8
28992: EQUAL
28993: IFFALSE 29009
// Say ( JMM , D16a-JMM-1 ) else
28995: LD_EXP 39
28999: PPUSH
29000: LD_STRING D16a-JMM-1
29002: PPUSH
29003: CALL_OW 88
29007: GO 29045
// begin Say ( JMM , D16a-JMM-1a ) ;
29009: LD_EXP 39
29013: PPUSH
29014: LD_STRING D16a-JMM-1a
29016: PPUSH
29017: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29021: LD_EXP 62
29025: PPUSH
29026: LD_STRING D16a-Friend-1
29028: PPUSH
29029: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29033: LD_EXP 62
29037: PPUSH
29038: LD_INT 3
29040: PPUSH
29041: CALL_OW 235
// end ; DialogueOff ;
29045: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29049: LD_VAR 0 1
29053: PPUSH
29054: LD_INT 60
29056: PPUSH
29057: LD_INT 95
29059: PPUSH
29060: CALL_OW 116
// end else
29064: GO 29086
// begin DialogueOn ;
29066: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29070: LD_EXP 64
29074: PPUSH
29075: LD_STRING D16c-Pla-
29077: PPUSH
29078: CALL_OW 94
// DialogueOff ;
29082: CALL_OW 7
// end ; end else
29086: GO 29187
// begin wait ( 3 3$00 ) ;
29088: LD_INT 6300
29090: PPUSH
29091: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29095: LD_INT 22
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 34
29107: PUSH
29108: LD_INT 8
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PPUSH
29119: CALL_OW 69
29123: NOT
29124: IFFALSE 29167
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29126: LD_EXP 64
29130: PPUSH
29131: LD_STRING D16b-Pla-1
29133: PPUSH
29134: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29138: LD_EXP 39
29142: PPUSH
29143: LD_STRING D16b-JMM-
29145: PPUSH
29146: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29150: LD_VAR 0 1
29154: PPUSH
29155: LD_INT 60
29157: PPUSH
29158: LD_INT 95
29160: PPUSH
29161: CALL_OW 116
// end else
29165: GO 29187
// begin DialogueOn ;
29167: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D16c-Pla-
29178: PPUSH
29179: CALL_OW 94
// DialogueOff ;
29183: CALL_OW 7
// end ; end ; end ;
29187: PPOPN 3
29189: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29190: LD_EXP 14
29194: PUSH
29195: LD_INT 126000
29197: GREATEREQUAL
29198: PUSH
29199: LD_EXP 23
29203: NOT
29204: AND
29205: PUSH
29206: LD_EXP 74
29210: PPUSH
29211: CALL_OW 302
29215: AND
29216: IFFALSE 29574
29218: GO 29220
29220: DISABLE
29221: LD_INT 0
29223: PPUSH
// begin missionStage = 11 ;
29224: LD_ADDR_EXP 15
29228: PUSH
29229: LD_INT 11
29231: ST_TO_ADDR
// DialogueOn ;
29232: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29236: LD_EXP 74
29240: PPUSH
29241: LD_STRING D9-Roth-1
29243: PPUSH
29244: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29248: LD_EXP 39
29252: PPUSH
29253: LD_STRING D9-JMM-1
29255: PPUSH
29256: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29260: LD_EXP 74
29264: PPUSH
29265: LD_STRING D9-Roth-2
29267: PPUSH
29268: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29272: LD_EXP 74
29276: PPUSH
29277: LD_STRING D9-Roth-2a
29279: PPUSH
29280: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29284: LD_EXP 64
29288: PPUSH
29289: LD_STRING D9-Pla-2
29291: PPUSH
29292: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29296: LD_EXP 74
29300: PPUSH
29301: LD_STRING D9-Roth-3
29303: PPUSH
29304: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29308: LD_EXP 64
29312: PPUSH
29313: LD_STRING D9-Pla-3
29315: PPUSH
29316: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29320: LD_EXP 74
29324: PPUSH
29325: LD_STRING D9-Roth-4
29327: PPUSH
29328: CALL_OW 94
// dec = Query ( Q9 ) ;
29332: LD_ADDR_VAR 0 1
29336: PUSH
29337: LD_STRING Q9
29339: PPUSH
29340: CALL_OW 97
29344: ST_TO_ADDR
// if dec = 1 then
29345: LD_VAR 0 1
29349: PUSH
29350: LD_INT 1
29352: EQUAL
29353: IFFALSE 29367
// SayRadio ( Roth , D9a-Roth-1 ) ;
29355: LD_EXP 74
29359: PPUSH
29360: LD_STRING D9a-Roth-1
29362: PPUSH
29363: CALL_OW 94
// if dec = 2 then
29367: LD_VAR 0 1
29371: PUSH
29372: LD_INT 2
29374: EQUAL
29375: IFFALSE 29401
// begin Say ( JMM , D9b-JMM-1 ) ;
29377: LD_EXP 39
29381: PPUSH
29382: LD_STRING D9b-JMM-1
29384: PPUSH
29385: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29389: LD_EXP 74
29393: PPUSH
29394: LD_STRING D9b-Roth-1
29396: PPUSH
29397: CALL_OW 94
// end ; if dec = 3 then
29401: LD_VAR 0 1
29405: PUSH
29406: LD_INT 3
29408: EQUAL
29409: IFFALSE 29471
// begin Say ( JMM , D9c-JMM-1 ) ;
29411: LD_EXP 39
29415: PPUSH
29416: LD_STRING D9c-JMM-1
29418: PPUSH
29419: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29423: LD_EXP 74
29427: PPUSH
29428: LD_STRING D9c-Roth-1
29430: PPUSH
29431: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29435: LD_EXP 39
29439: PPUSH
29440: LD_STRING D9c-JMM-2
29442: PPUSH
29443: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29447: LD_EXP 74
29451: PPUSH
29452: LD_STRING D9c-Roth-2
29454: PPUSH
29455: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29459: LD_EXP 39
29463: PPUSH
29464: LD_STRING D9c-JMM-3
29466: PPUSH
29467: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29471: LD_EXP 74
29475: PPUSH
29476: LD_STRING D9c-Roth-3
29478: PPUSH
29479: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29483: LD_EXP 74
29487: PPUSH
29488: LD_STRING D9cont-Roth-1
29490: PPUSH
29491: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29495: LD_EXP 39
29499: PPUSH
29500: LD_STRING D9cont-JMM-1
29502: PPUSH
29503: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29507: LD_EXP 74
29511: PPUSH
29512: LD_STRING D9cont-Roth-2
29514: PPUSH
29515: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29519: LD_EXP 39
29523: PPUSH
29524: LD_STRING D9cont-JMM-2
29526: PPUSH
29527: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29531: LD_EXP 74
29535: PPUSH
29536: LD_STRING D9cont-Roth-3
29538: PPUSH
29539: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29543: LD_EXP 39
29547: PPUSH
29548: LD_STRING D9cont-JMM-3
29550: PPUSH
29551: CALL_OW 88
// DialogueOff ;
29555: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29559: LD_STRING M3
29561: PPUSH
29562: CALL_OW 337
// allianceActive := true ;
29566: LD_ADDR_EXP 31
29570: PUSH
29571: LD_INT 1
29573: ST_TO_ADDR
// end ;
29574: PPOPN 1
29576: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29577: LD_INT 1
29579: PPUSH
29580: LD_INT 126
29582: PPUSH
29583: CALL_OW 292
29587: PUSH
29588: LD_EXP 64
29592: PPUSH
29593: CALL_OW 310
29597: AND
29598: IFFALSE 29678
29600: GO 29602
29602: DISABLE
29603: LD_INT 0
29605: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29606: LD_EXP 64
29610: PPUSH
29611: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 4
29622: PPUSH
29623: LD_INT 22
29625: PUSH
29626: LD_INT 1
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PPUSH
29633: CALL_OW 70
29637: PPUSH
29638: LD_EXP 64
29642: PPUSH
29643: CALL_OW 74
29647: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29648: LD_EXP 64
29652: PPUSH
29653: LD_VAR 0 1
29657: PUSH
29658: LD_INT 1
29660: ARRAY
29661: PPUSH
29662: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29666: LD_EXP 64
29670: PPUSH
29671: LD_STRING D18-Pla-1
29673: PPUSH
29674: CALL_OW 88
// end ;
29678: PPOPN 1
29680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29681: LD_EXP 64
29685: PPUSH
29686: CALL_OW 301
29690: PUSH
29691: LD_EXP 67
29695: PPUSH
29696: CALL_OW 301
29700: AND
29701: PUSH
29702: LD_INT 22
29704: PUSH
29705: LD_INT 3
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 21
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 50
29724: PUSH
29725: EMPTY
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: PPUSH
29733: CALL_OW 69
29737: PUSH
29738: LD_INT 7
29740: PUSH
29741: LD_INT 8
29743: PUSH
29744: LD_INT 9
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: PUSH
29752: LD_OWVAR 67
29756: ARRAY
29757: LESS
29758: AND
29759: IFFALSE 30530
29761: GO 29763
29763: DISABLE
29764: LD_INT 0
29766: PPUSH
29767: PPUSH
29768: PPUSH
29769: PPUSH
// begin MC_Kill ( 1 ) ;
29770: LD_INT 1
29772: PPUSH
29773: CALL 35316 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29777: LD_INT 1
29779: PPUSH
29780: LD_INT 3
29782: PPUSH
29783: LD_INT 1
29785: PPUSH
29786: LD_INT 1
29788: PPUSH
29789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29793: LD_ADDR_VAR 0 1
29797: PUSH
29798: LD_INT 22
29800: PUSH
29801: LD_INT 3
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 21
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 24
29820: PUSH
29821: LD_INT 900
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: PPUSH
29833: CALL_OW 69
29837: PUSH
29838: FOR_IN
29839: IFFALSE 29870
// if GetSex ( i ) = sex_male then
29841: LD_VAR 0 1
29845: PPUSH
29846: CALL_OW 258
29850: PUSH
29851: LD_INT 1
29853: EQUAL
29854: IFFALSE 29868
// begin tmp = i ;
29856: LD_ADDR_VAR 0 2
29860: PUSH
29861: LD_VAR 0 1
29865: ST_TO_ADDR
// break ;
29866: GO 29870
// end ;
29868: GO 29838
29870: POP
29871: POP
// if tmp = 0 then
29872: LD_VAR 0 2
29876: PUSH
29877: LD_INT 0
29879: EQUAL
29880: IFFALSE 29934
// begin uc_side = 3 ;
29882: LD_ADDR_OWVAR 20
29886: PUSH
29887: LD_INT 3
29889: ST_TO_ADDR
// uc_nation = 3 ;
29890: LD_ADDR_OWVAR 21
29894: PUSH
29895: LD_INT 3
29897: ST_TO_ADDR
// hc_name =  ;
29898: LD_ADDR_OWVAR 26
29902: PUSH
29903: LD_STRING 
29905: ST_TO_ADDR
// hc_gallery =  ;
29906: LD_ADDR_OWVAR 33
29910: PUSH
29911: LD_STRING 
29913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 10
29919: PPUSH
29920: CALL_OW 381
// tmp = CreateHuman ;
29924: LD_ADDR_VAR 0 2
29928: PUSH
29929: CALL_OW 44
29933: ST_TO_ADDR
// end ; DialogueOn ;
29934: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_STRING DSurrenderRussians-RSol1-1a
29945: PPUSH
29946: CALL_OW 94
// DialogueOff ;
29950: CALL_OW 7
// russianDestroyed := true ;
29954: LD_ADDR_EXP 21
29958: PUSH
29959: LD_INT 1
29961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29962: LD_INT 22
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 21
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PPUSH
29986: CALL_OW 69
29990: PPUSH
29991: CALL_OW 122
// wait ( 0 0$1 ) ;
29995: LD_INT 35
29997: PPUSH
29998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30002: LD_INT 22
30004: PUSH
30005: LD_INT 3
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 21
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PPUSH
30026: CALL_OW 69
30030: PPUSH
30031: LD_INT 25
30033: PPUSH
30034: CALL_OW 173
// wait ( 0 0$10 ) ;
30038: LD_INT 350
30040: PPUSH
30041: CALL_OW 67
// PrepareOmarInvasion ;
30045: CALL 13878 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30049: LD_ADDR_VAR 0 2
30053: PUSH
30054: LD_EXP 92
30058: PPUSH
30059: CALL_OW 250
30063: PUSH
30064: LD_EXP 92
30068: PPUSH
30069: CALL_OW 251
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30078: LD_VAR 0 2
30082: PUSH
30083: LD_INT 1
30085: ARRAY
30086: PPUSH
30087: LD_VAR 0 2
30091: PUSH
30092: LD_INT 2
30094: ARRAY
30095: PPUSH
30096: LD_INT 1
30098: PPUSH
30099: LD_INT 8
30101: NEG
30102: PPUSH
30103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30107: LD_EXP 92
30111: PPUSH
30112: CALL_OW 87
// DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30120: LD_EXP 39
30124: PPUSH
30125: LD_STRING D19-JMM-1
30127: PPUSH
30128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30132: LD_ADDR_VAR 0 3
30136: PUSH
30137: LD_INT 22
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 26
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 2
30159: PUSH
30160: LD_INT 25
30162: PUSH
30163: LD_INT 1
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 25
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 25
30182: PUSH
30183: LD_INT 3
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 25
30192: PUSH
30193: LD_INT 4
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 25
30202: PUSH
30203: LD_INT 5
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 25
30212: PUSH
30213: LD_INT 8
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 69
30238: PUSH
30239: LD_EXP 39
30243: PUSH
30244: LD_EXP 40
30248: PUSH
30249: LD_EXP 41
30253: PUSH
30254: LD_EXP 42
30258: PUSH
30259: LD_EXP 43
30263: PUSH
30264: LD_EXP 44
30268: PUSH
30269: LD_EXP 45
30273: PUSH
30274: LD_EXP 46
30278: PUSH
30279: LD_EXP 47
30283: PUSH
30284: LD_EXP 48
30288: PUSH
30289: LD_EXP 49
30293: PUSH
30294: LD_EXP 50
30298: PUSH
30299: LD_EXP 51
30303: PUSH
30304: LD_EXP 52
30308: PUSH
30309: LD_EXP 53
30313: PUSH
30314: LD_EXP 54
30318: PUSH
30319: LD_EXP 55
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: DIFF
30343: ST_TO_ADDR
// if tmp2 then
30344: LD_VAR 0 3
30348: IFFALSE 30366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30350: LD_VAR 0 3
30354: PUSH
30355: LD_INT 1
30357: ARRAY
30358: PPUSH
30359: LD_STRING D19-Sol1-1
30361: PPUSH
30362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30366: LD_EXP 39
30370: PPUSH
30371: LD_STRING D19-JMM-2
30373: PPUSH
30374: CALL_OW 88
// DialogueOff ;
30378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30382: LD_VAR 0 2
30386: PUSH
30387: LD_INT 1
30389: ARRAY
30390: PPUSH
30391: LD_VAR 0 2
30395: PUSH
30396: LD_INT 2
30398: ARRAY
30399: PPUSH
30400: LD_INT 1
30402: PPUSH
30403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30407: LD_STRING M5
30409: PPUSH
30410: CALL_OW 337
// omarOnMotherLode := false ;
30414: LD_ADDR_VAR 0 4
30418: PUSH
30419: LD_INT 0
30421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30422: LD_INT 35
30424: PPUSH
30425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30429: LD_EXP 92
30433: PPUSH
30434: LD_INT 215
30436: PPUSH
30437: LD_INT 100
30439: PPUSH
30440: CALL_OW 297
30444: PUSH
30445: LD_INT 10
30447: LESS
30448: PUSH
30449: LD_VAR 0 4
30453: NOT
30454: AND
30455: IFFALSE 30489
// begin omarOnMotherLode := true ;
30457: LD_ADDR_VAR 0 4
30461: PUSH
30462: LD_INT 1
30464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30465: LD_EXP 39
30469: PPUSH
30470: LD_STRING D19b-JMM-1
30472: PPUSH
30473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30477: LD_EXP 92
30481: PPUSH
30482: LD_STRING DOmarContam-Omar-1
30484: PPUSH
30485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30489: LD_EXP 92
30493: PPUSH
30494: CALL_OW 301
30498: IFFALSE 30422
// Say ( JMM , D19a-JMM-1 ) ;
30500: LD_EXP 39
30504: PPUSH
30505: LD_STRING D19a-JMM-1
30507: PPUSH
30508: CALL_OW 88
// if Heike then
30512: LD_EXP 93
30516: IFFALSE 30530
// Say ( Heike , D19a-Hke-1 ) ;
30518: LD_EXP 93
30522: PPUSH
30523: LD_STRING D19a-Hke-1
30525: PPUSH
30526: CALL_OW 88
// end ;
30530: PPOPN 4
30532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30533: LD_INT 22
30535: PUSH
30536: LD_INT 3
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 21
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PPUSH
30557: CALL_OW 69
30561: PUSH
30562: LD_EXP 21
30566: AND
30567: IFFALSE 30635
30569: GO 30571
30571: DISABLE
30572: LD_INT 0
30574: PPUSH
30575: PPUSH
// begin enable ;
30576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30577: LD_ADDR_VAR 0 2
30581: PUSH
30582: LD_INT 25
30584: PPUSH
30585: LD_INT 22
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 70
30599: ST_TO_ADDR
// if not tmp then
30600: LD_VAR 0 2
30604: NOT
30605: IFFALSE 30609
// exit ;
30607: GO 30635
// for i in tmp do
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_VAR 0 2
30618: PUSH
30619: FOR_IN
30620: IFFALSE 30633
// RemoveUnit ( i ) ;
30622: LD_VAR 0 1
30626: PPUSH
30627: CALL_OW 64
30631: GO 30619
30633: POP
30634: POP
// end ;
30635: PPOPN 2
30637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30638: LD_INT 22
30640: PUSH
30641: LD_INT 7
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 21
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 69
30666: PUSH
30667: LD_INT 6
30669: LESS
30670: IFFALSE 31138
30672: GO 30674
30674: DISABLE
30675: LD_INT 0
30677: PPUSH
30678: PPUSH
// begin MC_Kill ( 1 ) ;
30679: LD_INT 1
30681: PPUSH
30682: CALL 35316 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30686: LD_INT 7
30688: PPUSH
30689: LD_INT 1
30691: PPUSH
30692: LD_INT 1
30694: PPUSH
30695: LD_INT 1
30697: PPUSH
30698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30702: LD_ADDR_VAR 0 1
30706: PUSH
30707: LD_INT 22
30709: PUSH
30710: LD_INT 7
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 26
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PPUSH
30731: CALL_OW 69
30735: PUSH
30736: LD_EXP 74
30740: DIFF
30741: ST_TO_ADDR
// if tmp then
30742: LD_VAR 0 1
30746: IFFALSE 30764
// tmp := tmp [ 1 ] else
30748: LD_ADDR_VAR 0 1
30752: PUSH
30753: LD_VAR 0 1
30757: PUSH
30758: LD_INT 1
30760: ARRAY
30761: ST_TO_ADDR
30762: GO 30800
// begin uc_side := 7 ;
30764: LD_ADDR_OWVAR 20
30768: PUSH
30769: LD_INT 7
30771: ST_TO_ADDR
// uc_nation := 1 ;
30772: LD_ADDR_OWVAR 21
30776: PUSH
30777: LD_INT 1
30779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30780: LD_INT 1
30782: PPUSH
30783: LD_INT 8
30785: PPUSH
30786: CALL_OW 384
// tmp := CreateHuman ;
30790: LD_ADDR_VAR 0 1
30794: PUSH
30795: CALL_OW 44
30799: ST_TO_ADDR
// end ; DialogueOn ;
30800: CALL_OW 6
// if IsOK ( Roth ) then
30804: LD_EXP 74
30808: PPUSH
30809: CALL_OW 302
30813: IFFALSE 30827
// Say ( JMM , DAb-JMM-1 ) ;
30815: LD_EXP 39
30819: PPUSH
30820: LD_STRING DAb-JMM-1
30822: PPUSH
30823: CALL_OW 88
// if IsOK ( Roth ) then
30827: LD_EXP 74
30831: PPUSH
30832: CALL_OW 302
30836: IFFALSE 30860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30838: LD_EXP 74
30842: PPUSH
30843: LD_STRING DSurrenderAlliance-Roth-1
30845: PPUSH
30846: CALL_OW 88
// RothCaptured := true ;
30850: LD_ADDR_EXP 33
30854: PUSH
30855: LD_INT 1
30857: ST_TO_ADDR
// end else
30858: GO 30872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30860: LD_VAR 0 1
30864: PPUSH
30865: LD_STRING DSurrenderAlliance-Sci1-1
30867: PPUSH
30868: CALL_OW 88
// DialogueOff ;
30872: CALL_OW 7
// allianceDestroyed := true ;
30876: LD_ADDR_EXP 23
30880: PUSH
30881: LD_INT 1
30883: ST_TO_ADDR
// if capturedUnit = 0 then
30884: LD_EXP 34
30888: PUSH
30889: LD_INT 0
30891: EQUAL
30892: IFFALSE 30901
// SetAchievement ( ACH_ALLIANCE ) ;
30894: LD_STRING ACH_ALLIANCE
30896: PPUSH
30897: CALL_OW 543
// if trueAmericans then
30901: LD_EXP 35
30905: IFFALSE 30981
// begin if trueAmericans = 1 then
30907: LD_EXP 35
30911: PUSH
30912: LD_INT 1
30914: EQUAL
30915: IFFALSE 30931
// Say ( JMM , DAb-JMM-1a ) else
30917: LD_EXP 39
30921: PPUSH
30922: LD_STRING DAb-JMM-1a
30924: PPUSH
30925: CALL_OW 88
30929: GO 30943
// Say ( JMM , DAb-JMM-1b ) ;
30931: LD_EXP 39
30935: PPUSH
30936: LD_STRING DAb-JMM-1b
30938: PPUSH
30939: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30943: LD_EXP 35
30947: PPUSH
30948: CALL_OW 87
// for i in trueAmericans do
30952: LD_ADDR_VAR 0 2
30956: PUSH
30957: LD_EXP 35
30961: PUSH
30962: FOR_IN
30963: IFFALSE 30979
// SetSide ( i , 1 ) ;
30965: LD_VAR 0 2
30969: PPUSH
30970: LD_INT 1
30972: PPUSH
30973: CALL_OW 235
30977: GO 30962
30979: POP
30980: POP
// end ; repeat wait ( 0 0$1 ) ;
30981: LD_INT 35
30983: PPUSH
30984: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30988: LD_ADDR_VAR 0 2
30992: PUSH
30993: LD_INT 22
30995: PUSH
30996: LD_INT 7
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 21
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: CALL_OW 69
31021: PUSH
31022: FOR_IN
31023: IFFALSE 31105
// begin if IsInUnit ( i ) then
31025: LD_VAR 0 2
31029: PPUSH
31030: CALL_OW 310
31034: IFFALSE 31045
// ComExitBuilding ( i ) ;
31036: LD_VAR 0 2
31040: PPUSH
31041: CALL_OW 122
// if IsDriver ( i ) then
31045: LD_VAR 0 2
31049: PPUSH
31050: CALL 98699 0 1
31054: IFFALSE 31065
// ComExitVehicle ( i ) ;
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31065: LD_VAR 0 2
31069: PPUSH
31070: LD_INT 26
31072: PPUSH
31073: CALL_OW 308
31077: NOT
31078: IFFALSE 31094
// AddComMoveToArea ( i , allianceEscapeArea ) else
31080: LD_VAR 0 2
31084: PPUSH
31085: LD_INT 26
31087: PPUSH
31088: CALL_OW 173
31092: GO 31103
// RemoveUnit ( i ) ;
31094: LD_VAR 0 2
31098: PPUSH
31099: CALL_OW 64
// end ;
31103: GO 31022
31105: POP
31106: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31107: LD_INT 22
31109: PUSH
31110: LD_INT 7
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 21
31119: PUSH
31120: LD_INT 1
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PPUSH
31131: CALL_OW 69
31135: NOT
31136: IFFALSE 30981
// end ;
31138: PPOPN 2
31140: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31141: LD_INT 0
31143: PPUSH
31144: PPUSH
// if not unit then
31145: LD_VAR 0 1
31149: NOT
31150: IFFALSE 31154
// exit ;
31152: GO 32652
// DoNotAttack ( 7 , unit ) ;
31154: LD_INT 7
31156: PPUSH
31157: LD_VAR 0 1
31161: PPUSH
31162: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31166: LD_VAR 0 1
31170: PPUSH
31171: LD_INT 260
31173: PPUSH
31174: LD_INT 235
31176: PPUSH
31177: LD_INT 3
31179: PPUSH
31180: LD_INT 1
31182: PPUSH
31183: CALL_OW 483
// SetSide ( unit , 4 ) ;
31187: LD_VAR 0 1
31191: PPUSH
31192: LD_INT 4
31194: PPUSH
31195: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31199: LD_ADDR_EXP 34
31203: PUSH
31204: LD_EXP 34
31208: PUSH
31209: LD_INT 1
31211: PLUS
31212: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31213: LD_INT 70
31215: PPUSH
31216: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31220: LD_INT 260
31222: PPUSH
31223: LD_INT 235
31225: PPUSH
31226: LD_INT 1
31228: PPUSH
31229: LD_INT 8
31231: NEG
31232: PPUSH
31233: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31237: LD_VAR 0 1
31241: PPUSH
31242: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31246: LD_VAR 0 1
31250: PPUSH
31251: LD_EXP 74
31255: PPUSH
31256: CALL_OW 119
// DialogueOn ;
31260: CALL_OW 6
// case unit of JMM :
31264: LD_VAR 0 1
31268: PUSH
31269: LD_EXP 39
31273: DOUBLE
31274: EQUAL
31275: IFTRUE 31279
31277: GO 31294
31279: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31280: LD_EXP 39
31284: PPUSH
31285: LD_STRING DA1-JMM-1
31287: PPUSH
31288: CALL_OW 91
31292: GO 31736
31294: LD_EXP 40
31298: DOUBLE
31299: EQUAL
31300: IFTRUE 31304
31302: GO 31319
31304: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31305: LD_EXP 40
31309: PPUSH
31310: LD_STRING DA1-Joan-1
31312: PPUSH
31313: CALL_OW 91
31317: GO 31736
31319: LD_EXP 42
31323: DOUBLE
31324: EQUAL
31325: IFTRUE 31329
31327: GO 31344
31329: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31330: LD_EXP 42
31334: PPUSH
31335: LD_STRING DA1-Lisa-1
31337: PPUSH
31338: CALL_OW 91
31342: GO 31736
31344: LD_EXP 43
31348: DOUBLE
31349: EQUAL
31350: IFTRUE 31354
31352: GO 31369
31354: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31355: LD_EXP 43
31359: PPUSH
31360: LD_STRING DA1-Don-1
31362: PPUSH
31363: CALL_OW 91
31367: GO 31736
31369: LD_EXP 50
31373: DOUBLE
31374: EQUAL
31375: IFTRUE 31379
31377: GO 31394
31379: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31380: LD_EXP 50
31384: PPUSH
31385: LD_STRING DA1-Corn-1
31387: PPUSH
31388: CALL_OW 91
31392: GO 31736
31394: LD_EXP 46
31398: DOUBLE
31399: EQUAL
31400: IFTRUE 31404
31402: GO 31419
31404: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31405: LD_EXP 46
31409: PPUSH
31410: LD_STRING DA1-Den-1
31412: PPUSH
31413: CALL_OW 91
31417: GO 31736
31419: LD_EXP 44
31423: DOUBLE
31424: EQUAL
31425: IFTRUE 31429
31427: GO 31444
31429: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31430: LD_EXP 44
31434: PPUSH
31435: LD_STRING DA1-Bobby-1
31437: PPUSH
31438: CALL_OW 91
31442: GO 31736
31444: LD_EXP 48
31448: DOUBLE
31449: EQUAL
31450: IFTRUE 31454
31452: GO 31469
31454: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31455: LD_EXP 48
31459: PPUSH
31460: LD_STRING DA1-Glad-1
31462: PPUSH
31463: CALL_OW 91
31467: GO 31736
31469: LD_EXP 45
31473: DOUBLE
31474: EQUAL
31475: IFTRUE 31479
31477: GO 31494
31479: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31480: LD_EXP 45
31484: PPUSH
31485: LD_STRING DA1-Cyrus-1
31487: PPUSH
31488: CALL_OW 91
31492: GO 31736
31494: LD_EXP 41
31498: DOUBLE
31499: EQUAL
31500: IFTRUE 31504
31502: GO 31519
31504: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31505: LD_EXP 41
31509: PPUSH
31510: LD_STRING DA1-Huck-1
31512: PPUSH
31513: CALL_OW 91
31517: GO 31736
31519: LD_EXP 55
31523: DOUBLE
31524: EQUAL
31525: IFTRUE 31529
31527: GO 31544
31529: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31530: LD_EXP 55
31534: PPUSH
31535: LD_STRING DA1-Huck-1
31537: PPUSH
31538: CALL_OW 91
31542: GO 31736
31544: LD_EXP 47
31548: DOUBLE
31549: EQUAL
31550: IFTRUE 31554
31552: GO 31569
31554: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31555: LD_EXP 47
31559: PPUSH
31560: LD_STRING DA1-Brown-1
31562: PPUSH
31563: CALL_OW 91
31567: GO 31736
31569: LD_EXP 51
31573: DOUBLE
31574: EQUAL
31575: IFTRUE 31579
31577: GO 31594
31579: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31580: LD_EXP 51
31584: PPUSH
31585: LD_STRING DA1-Gary-1
31587: PPUSH
31588: CALL_OW 91
31592: GO 31736
31594: LD_EXP 54
31598: DOUBLE
31599: EQUAL
31600: IFTRUE 31604
31602: GO 31619
31604: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31605: LD_EXP 54
31609: PPUSH
31610: LD_STRING DA1-Con-1
31612: PPUSH
31613: CALL_OW 91
31617: GO 31736
31619: LD_EXP 60
31623: DOUBLE
31624: EQUAL
31625: IFTRUE 31629
31627: GO 31644
31629: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31630: LD_EXP 60
31634: PPUSH
31635: LD_STRING DA1-Kurt-1
31637: PPUSH
31638: CALL_OW 91
31642: GO 31736
31644: LD_EXP 53
31648: DOUBLE
31649: EQUAL
31650: IFTRUE 31654
31652: GO 31669
31654: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31655: LD_EXP 53
31659: PPUSH
31660: LD_STRING DA1-Yam-1
31662: PPUSH
31663: CALL_OW 91
31667: GO 31736
31669: LD_EXP 52
31673: DOUBLE
31674: EQUAL
31675: IFTRUE 31679
31677: GO 31694
31679: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31680: LD_EXP 52
31684: PPUSH
31685: LD_STRING DA1-Frank-1
31687: PPUSH
31688: CALL_OW 91
31692: GO 31736
31694: POP
// begin if GetSex ( unit ) = sex_male then
31695: LD_VAR 0 1
31699: PPUSH
31700: CALL_OW 258
31704: PUSH
31705: LD_INT 1
31707: EQUAL
31708: IFFALSE 31724
// ForceSay ( unit , DA1-Sol1-1 ) else
31710: LD_VAR 0 1
31714: PPUSH
31715: LD_STRING DA1-Sol1-1
31717: PPUSH
31718: CALL_OW 91
31722: GO 31736
// ForceSay ( unit , DA1-FSol1-1 ) ;
31724: LD_VAR 0 1
31728: PPUSH
31729: LD_STRING DA1-FSol1-1
31731: PPUSH
31732: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31736: LD_EXP 74
31740: PPUSH
31741: LD_STRING DA-Roth-1
31743: PPUSH
31744: CALL_OW 88
// if capturedUnit = 1 then
31748: LD_EXP 34
31752: PUSH
31753: LD_INT 1
31755: EQUAL
31756: IFFALSE 31784
// begin Say ( Simms , DA-Sim-1 ) ;
31758: LD_EXP 75
31762: PPUSH
31763: LD_STRING DA-Sim-1
31765: PPUSH
31766: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31770: LD_EXP 74
31774: PPUSH
31775: LD_STRING DA-Roth-2
31777: PPUSH
31778: CALL_OW 88
// end else
31782: GO 31796
// Say ( Simms , DA-Sim-2 ) ;
31784: LD_EXP 75
31788: PPUSH
31789: LD_STRING DA-Sim-2
31791: PPUSH
31792: CALL_OW 88
// case unit of JMM :
31796: LD_VAR 0 1
31800: PUSH
31801: LD_EXP 39
31805: DOUBLE
31806: EQUAL
31807: IFTRUE 31811
31809: GO 31826
31811: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31812: LD_EXP 39
31816: PPUSH
31817: LD_STRING DA1-JMM-1a
31819: PPUSH
31820: CALL_OW 91
31824: GO 32333
31826: LD_EXP 40
31830: DOUBLE
31831: EQUAL
31832: IFTRUE 31836
31834: GO 31851
31836: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31837: LD_EXP 40
31841: PPUSH
31842: LD_STRING DA1-Joan-1a
31844: PPUSH
31845: CALL_OW 91
31849: GO 32333
31851: LD_EXP 42
31855: DOUBLE
31856: EQUAL
31857: IFTRUE 31861
31859: GO 31876
31861: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31862: LD_EXP 42
31866: PPUSH
31867: LD_STRING DA1-Lisa-1a
31869: PPUSH
31870: CALL_OW 91
31874: GO 32333
31876: LD_EXP 43
31880: DOUBLE
31881: EQUAL
31882: IFTRUE 31886
31884: GO 31901
31886: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31887: LD_EXP 43
31891: PPUSH
31892: LD_STRING DA1-Don-1a
31894: PPUSH
31895: CALL_OW 91
31899: GO 32333
31901: LD_EXP 50
31905: DOUBLE
31906: EQUAL
31907: IFTRUE 31911
31909: GO 31926
31911: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31912: LD_EXP 50
31916: PPUSH
31917: LD_STRING DA1-Corn-1a
31919: PPUSH
31920: CALL_OW 91
31924: GO 32333
31926: LD_EXP 46
31930: DOUBLE
31931: EQUAL
31932: IFTRUE 31936
31934: GO 31951
31936: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31937: LD_EXP 46
31941: PPUSH
31942: LD_STRING DA1-Den-1a
31944: PPUSH
31945: CALL_OW 91
31949: GO 32333
31951: LD_EXP 44
31955: DOUBLE
31956: EQUAL
31957: IFTRUE 31961
31959: GO 31976
31961: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31962: LD_EXP 44
31966: PPUSH
31967: LD_STRING DA1-Bobby-1a
31969: PPUSH
31970: CALL_OW 91
31974: GO 32333
31976: LD_EXP 48
31980: DOUBLE
31981: EQUAL
31982: IFTRUE 31986
31984: GO 32001
31986: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31987: LD_EXP 48
31991: PPUSH
31992: LD_STRING DA1-Glad-1a
31994: PPUSH
31995: CALL_OW 91
31999: GO 32333
32001: LD_EXP 45
32005: DOUBLE
32006: EQUAL
32007: IFTRUE 32011
32009: GO 32026
32011: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32012: LD_EXP 45
32016: PPUSH
32017: LD_STRING DA1-Cyrus-1a
32019: PPUSH
32020: CALL_OW 91
32024: GO 32333
32026: LD_EXP 41
32030: DOUBLE
32031: EQUAL
32032: IFTRUE 32036
32034: GO 32051
32036: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32037: LD_EXP 41
32041: PPUSH
32042: LD_STRING DA1-Huck-1a
32044: PPUSH
32045: CALL_OW 91
32049: GO 32333
32051: LD_EXP 55
32055: DOUBLE
32056: EQUAL
32057: IFTRUE 32061
32059: GO 32076
32061: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32062: LD_EXP 55
32066: PPUSH
32067: LD_STRING DA1-Huck-1a
32069: PPUSH
32070: CALL_OW 91
32074: GO 32333
32076: LD_EXP 47
32080: DOUBLE
32081: EQUAL
32082: IFTRUE 32086
32084: GO 32101
32086: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32087: LD_EXP 47
32091: PPUSH
32092: LD_STRING DA1-Brown-1a
32094: PPUSH
32095: CALL_OW 91
32099: GO 32333
32101: LD_EXP 51
32105: DOUBLE
32106: EQUAL
32107: IFTRUE 32111
32109: GO 32126
32111: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32112: LD_EXP 51
32116: PPUSH
32117: LD_STRING DA1-Gary-1a
32119: PPUSH
32120: CALL_OW 91
32124: GO 32333
32126: LD_EXP 54
32130: DOUBLE
32131: EQUAL
32132: IFTRUE 32136
32134: GO 32151
32136: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32137: LD_EXP 54
32141: PPUSH
32142: LD_STRING DA1-Con-1a
32144: PPUSH
32145: CALL_OW 91
32149: GO 32333
32151: LD_EXP 60
32155: DOUBLE
32156: EQUAL
32157: IFTRUE 32161
32159: GO 32176
32161: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32162: LD_EXP 60
32166: PPUSH
32167: LD_STRING DA1-Kurt-1a
32169: PPUSH
32170: CALL_OW 91
32174: GO 32333
32176: LD_EXP 53
32180: DOUBLE
32181: EQUAL
32182: IFTRUE 32186
32184: GO 32201
32186: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32187: LD_EXP 53
32191: PPUSH
32192: LD_STRING DA1-Yam-1a
32194: PPUSH
32195: CALL_OW 91
32199: GO 32333
32201: LD_EXP 52
32205: DOUBLE
32206: EQUAL
32207: IFTRUE 32211
32209: GO 32226
32211: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32212: LD_EXP 52
32216: PPUSH
32217: LD_STRING DA1-Frank-1a
32219: PPUSH
32220: CALL_OW 91
32224: GO 32333
32226: POP
// begin join := rand ( 0 , 1 ) ;
32227: LD_ADDR_VAR 0 3
32231: PUSH
32232: LD_INT 0
32234: PPUSH
32235: LD_INT 1
32237: PPUSH
32238: CALL_OW 12
32242: ST_TO_ADDR
// if join then
32243: LD_VAR 0 3
32247: IFFALSE 32292
// begin if GetSex ( unit ) = sex_male then
32249: LD_VAR 0 1
32253: PPUSH
32254: CALL_OW 258
32258: PUSH
32259: LD_INT 1
32261: EQUAL
32262: IFFALSE 32278
// ForceSay ( unit , DA1-Sol1-1b ) else
32264: LD_VAR 0 1
32268: PPUSH
32269: LD_STRING DA1-Sol1-1b
32271: PPUSH
32272: CALL_OW 91
32276: GO 32290
// ForceSay ( unit , DA1-FSol1-1b ) ;
32278: LD_VAR 0 1
32282: PPUSH
32283: LD_STRING DA1-FSol1-1b
32285: PPUSH
32286: CALL_OW 91
// end else
32290: GO 32333
// begin if GetSex ( unit ) = sex_male then
32292: LD_VAR 0 1
32296: PPUSH
32297: CALL_OW 258
32301: PUSH
32302: LD_INT 1
32304: EQUAL
32305: IFFALSE 32321
// ForceSay ( unit , DA1-Sol1-1a ) else
32307: LD_VAR 0 1
32311: PPUSH
32312: LD_STRING DA1-Sol1-1a
32314: PPUSH
32315: CALL_OW 91
32319: GO 32333
// ForceSay ( unit , DA1-FSol1-1a ) ;
32321: LD_VAR 0 1
32325: PPUSH
32326: LD_STRING DA1-FSol1-1a
32328: PPUSH
32329: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32333: LD_VAR 0 1
32337: PUSH
32338: LD_EXP 39
32342: EQUAL
32343: IFFALSE 32354
// begin YouLost ( JMMCaptured ) ;
32345: LD_STRING JMMCaptured
32347: PPUSH
32348: CALL_OW 104
// exit ;
32352: GO 32652
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32354: LD_VAR 0 1
32358: PUSH
32359: LD_EXP 43
32363: PUSH
32364: LD_EXP 46
32368: PUSH
32369: LD_EXP 44
32373: PUSH
32374: LD_EXP 41
32378: PUSH
32379: LD_EXP 55
32383: PUSH
32384: LD_EXP 47
32388: PUSH
32389: LD_EXP 53
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: IN
32403: PUSH
32404: LD_VAR 0 3
32408: OR
32409: IFFALSE 32508
// begin Say ( Roth , DA-Roth-3 ) ;
32411: LD_EXP 74
32415: PPUSH
32416: LD_STRING DA-Roth-3
32418: PPUSH
32419: CALL_OW 88
// SetSide ( unit , 7 ) ;
32423: LD_VAR 0 1
32427: PPUSH
32428: LD_INT 7
32430: PPUSH
32431: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32435: LD_ADDR_EXP 112
32439: PUSH
32440: LD_EXP 112
32444: PPUSH
32445: LD_INT 1
32447: PPUSH
32448: LD_EXP 112
32452: PUSH
32453: LD_INT 1
32455: ARRAY
32456: PUSH
32457: LD_VAR 0 1
32461: ADD
32462: PPUSH
32463: CALL_OW 1
32467: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32468: LD_INT 260
32470: PPUSH
32471: LD_INT 235
32473: PPUSH
32474: LD_INT 1
32476: PPUSH
32477: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32481: LD_VAR 0 1
32485: PPUSH
32486: LD_INT 1000
32488: PPUSH
32489: CALL_OW 234
// DialogueOff ;
32493: CALL_OW 7
// ComFree ( unit ) ;
32497: LD_VAR 0 1
32501: PPUSH
32502: CALL_OW 139
// end else
32506: GO 32589
// begin Say ( Roth , DA-Roth-3a ) ;
32508: LD_EXP 74
32512: PPUSH
32513: LD_STRING DA-Roth-3a
32515: PPUSH
32516: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32520: LD_ADDR_EXP 35
32524: PUSH
32525: LD_EXP 35
32529: PUSH
32530: LD_VAR 0 1
32534: ADD
32535: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32536: LD_INT 260
32538: PPUSH
32539: LD_INT 235
32541: PPUSH
32542: LD_INT 1
32544: PPUSH
32545: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32549: LD_VAR 0 1
32553: PPUSH
32554: LD_INT 1000
32556: PPUSH
32557: CALL_OW 234
// DialogueOff ;
32561: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32565: LD_VAR 0 1
32569: PPUSH
32570: LD_INT 272
32572: PPUSH
32573: LD_INT 254
32575: PPUSH
32576: CALL_OW 111
// AddComHold ( unit ) ;
32580: LD_VAR 0 1
32584: PPUSH
32585: CALL_OW 200
// end ; if capturedUnit = 1 then
32589: LD_EXP 34
32593: PUSH
32594: LD_INT 1
32596: EQUAL
32597: IFFALSE 32652
// begin DialogueOn ;
32599: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32603: LD_EXP 39
32607: PPUSH
32608: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32612: LD_EXP 39
32616: PPUSH
32617: LD_STRING DAa-JMM-1
32619: PPUSH
32620: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32624: LD_EXP 39
32628: PPUSH
32629: LD_STRING DAa-JMM-1a
32631: PPUSH
32632: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32636: LD_EXP 39
32640: PPUSH
32641: LD_STRING DAa-JMM-1b
32643: PPUSH
32644: CALL_OW 88
// DialogueOff ;
32648: CALL_OW 7
// end ; end ;
32652: LD_VAR 0 2
32656: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32657: LD_EXP 15
32661: PUSH
32662: LD_INT 13
32664: GREATEREQUAL
32665: PUSH
32666: LD_INT 22
32668: PUSH
32669: LD_INT 2
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 21
32678: PUSH
32679: LD_INT 1
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PPUSH
32690: CALL_OW 69
32694: PUSH
32695: LD_INT 0
32697: EQUAL
32698: AND
32699: PUSH
32700: LD_INT 22
32702: PUSH
32703: LD_INT 2
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 21
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 50
32722: PUSH
32723: EMPTY
32724: LIST
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: LIST
32730: PPUSH
32731: CALL_OW 69
32735: PUSH
32736: LD_INT 0
32738: EQUAL
32739: AND
32740: PUSH
32741: LD_EXP 21
32745: AND
32746: PUSH
32747: LD_EXP 22
32751: AND
32752: PUSH
32753: LD_EXP 23
32757: AND
32758: IFFALSE 33400
32760: GO 32762
32762: DISABLE
32763: LD_INT 0
32765: PPUSH
32766: PPUSH
32767: PPUSH
// begin m1 := false ;
32768: LD_ADDR_VAR 0 1
32772: PUSH
32773: LD_INT 0
32775: ST_TO_ADDR
// m2 := false ;
32776: LD_ADDR_VAR 0 2
32780: PUSH
32781: LD_INT 0
32783: ST_TO_ADDR
// m3 := false ;
32784: LD_ADDR_VAR 0 3
32788: PUSH
32789: LD_INT 0
32791: ST_TO_ADDR
// if not bombExploded then
32792: LD_EXP 37
32796: NOT
32797: IFFALSE 32806
// SetAchievement ( ACH_SIBROCKET ) ;
32799: LD_STRING ACH_SIBROCKET
32801: PPUSH
32802: CALL_OW 543
// if tick <= 120 120$00 then
32806: LD_OWVAR 1
32810: PUSH
32811: LD_INT 252000
32813: LESSEQUAL
32814: IFFALSE 32830
// begin wait ( 3 ) ;
32816: LD_INT 3
32818: PPUSH
32819: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32823: LD_STRING ACH_ASPEED_15
32825: PPUSH
32826: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32830: LD_EXP 39
32834: PPUSH
32835: CALL_OW 87
// music_class := 5 ;
32839: LD_ADDR_OWVAR 72
32843: PUSH
32844: LD_INT 5
32846: ST_TO_ADDR
// music_nat := 5 ;
32847: LD_ADDR_OWVAR 71
32851: PUSH
32852: LD_INT 5
32854: ST_TO_ADDR
// DialogueOn ;
32855: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32859: LD_EXP 39
32863: PPUSH
32864: LD_STRING D20-JMM-1
32866: PPUSH
32867: CALL_OW 88
// if IsOK ( Joan ) then
32871: LD_EXP 40
32875: PPUSH
32876: CALL_OW 302
32880: IFFALSE 32894
// Say ( Joan , D20-Joan-1 ) ;
32882: LD_EXP 40
32886: PPUSH
32887: LD_STRING D20-Joan-1
32889: PPUSH
32890: CALL_OW 88
// if IsOk ( Lisa ) then
32894: LD_EXP 42
32898: PPUSH
32899: CALL_OW 302
32903: IFFALSE 32917
// Say ( Lisa , D20-Lisa-1 ) ;
32905: LD_EXP 42
32909: PPUSH
32910: LD_STRING D20-Lisa-1
32912: PPUSH
32913: CALL_OW 88
// if IsOk ( Donaldson ) then
32917: LD_EXP 43
32921: PPUSH
32922: CALL_OW 302
32926: IFFALSE 32940
// Say ( Donaldson , D20-Don-1 ) ;
32928: LD_EXP 43
32932: PPUSH
32933: LD_STRING D20-Don-1
32935: PPUSH
32936: CALL_OW 88
// if IsOK ( Cornel ) then
32940: LD_EXP 50
32944: PPUSH
32945: CALL_OW 302
32949: IFFALSE 32963
// Say ( Cornel , D20-Corn-1 ) ;
32951: LD_EXP 50
32955: PPUSH
32956: LD_STRING D20-Corn-1
32958: PPUSH
32959: CALL_OW 88
// if IsOk ( Denis ) then
32963: LD_EXP 46
32967: PPUSH
32968: CALL_OW 302
32972: IFFALSE 32986
// Say ( Denis , D20-Den-1 ) ;
32974: LD_EXP 46
32978: PPUSH
32979: LD_STRING D20-Den-1
32981: PPUSH
32982: CALL_OW 88
// if IsOk ( Bobby ) then
32986: LD_EXP 44
32990: PPUSH
32991: CALL_OW 302
32995: IFFALSE 33009
// Say ( Bobby , D20-Bobby-1 ) ;
32997: LD_EXP 44
33001: PPUSH
33002: LD_STRING D20-Bobby-1
33004: PPUSH
33005: CALL_OW 88
// if IsOk ( Gladstone ) then
33009: LD_EXP 48
33013: PPUSH
33014: CALL_OW 302
33018: IFFALSE 33032
// Say ( Gladstone , D20-Glad-1 ) ;
33020: LD_EXP 48
33024: PPUSH
33025: LD_STRING D20-Glad-1
33027: PPUSH
33028: CALL_OW 88
// if IsOk ( Cyrus ) then
33032: LD_EXP 45
33036: PPUSH
33037: CALL_OW 302
33041: IFFALSE 33055
// Say ( Cyrus , D20-Cyrus-1 ) ;
33043: LD_EXP 45
33047: PPUSH
33048: LD_STRING D20-Cyrus-1
33050: PPUSH
33051: CALL_OW 88
// if IsOk ( Stevens ) then
33055: LD_EXP 41
33059: PPUSH
33060: CALL_OW 302
33064: IFFALSE 33078
// Say ( Stevens , D20-Huck-1 ) ;
33066: LD_EXP 41
33070: PPUSH
33071: LD_STRING D20-Huck-1
33073: PPUSH
33074: CALL_OW 88
// if IsOk ( Brown ) then
33078: LD_EXP 47
33082: PPUSH
33083: CALL_OW 302
33087: IFFALSE 33101
// Say ( Brown , D20-Brown-1 ) ;
33089: LD_EXP 47
33093: PPUSH
33094: LD_STRING D20-Brown-1
33096: PPUSH
33097: CALL_OW 88
// if IsOk ( Gary ) then
33101: LD_EXP 51
33105: PPUSH
33106: CALL_OW 302
33110: IFFALSE 33124
// Say ( Gary , D20-Gary-1 ) ;
33112: LD_EXP 51
33116: PPUSH
33117: LD_STRING D20-Gary-1
33119: PPUSH
33120: CALL_OW 88
// if IsOk ( Connie ) then
33124: LD_EXP 54
33128: PPUSH
33129: CALL_OW 302
33133: IFFALSE 33147
// Say ( Connie , D20-Con-1 ) ;
33135: LD_EXP 54
33139: PPUSH
33140: LD_STRING D20-Con-1
33142: PPUSH
33143: CALL_OW 88
// if IsOk ( Kurt ) then
33147: LD_EXP 60
33151: PPUSH
33152: CALL_OW 302
33156: IFFALSE 33170
// Say ( Kurt , D20-Kurt-1 ) ;
33158: LD_EXP 60
33162: PPUSH
33163: LD_STRING D20-Kurt-1
33165: PPUSH
33166: CALL_OW 88
// if IsOk ( Kikuchi ) then
33170: LD_EXP 53
33174: PPUSH
33175: CALL_OW 302
33179: IFFALSE 33193
// Say ( Kikuchi , D20-Yam-1 ) ;
33181: LD_EXP 53
33185: PPUSH
33186: LD_STRING D20-Yam-1
33188: PPUSH
33189: CALL_OW 88
// if IsOk ( Frank ) then
33193: LD_EXP 52
33197: PPUSH
33198: CALL_OW 302
33202: IFFALSE 33216
// Say ( Frank , D20-Frank-1 ) ;
33204: LD_EXP 52
33208: PPUSH
33209: LD_STRING D20-Frank-1
33211: PPUSH
33212: CALL_OW 88
// DialogueOff ;
33216: CALL_OW 7
// if RothCaptured then
33220: LD_EXP 33
33224: IFFALSE 33246
// begin m1 := true ;
33226: LD_ADDR_VAR 0 1
33230: PUSH
33231: LD_INT 1
33233: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33234: LD_STRING Roth
33236: PPUSH
33237: LD_INT 1
33239: PPUSH
33240: CALL_OW 101
// end else
33244: GO 33257
// AddMedal ( Roth , - 1 ) ;
33246: LD_STRING Roth
33248: PPUSH
33249: LD_INT 1
33251: NEG
33252: PPUSH
33253: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33257: LD_EXP 27
33261: IFFALSE 33283
// begin m2 := true ;
33263: LD_ADDR_VAR 0 2
33267: PUSH
33268: LD_INT 1
33270: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33271: LD_STRING Project
33273: PPUSH
33274: LD_INT 1
33276: PPUSH
33277: CALL_OW 101
// end else
33281: GO 33294
// AddMedal ( Project , - 1 ) ;
33283: LD_STRING Project
33285: PPUSH
33286: LD_INT 1
33288: NEG
33289: PPUSH
33290: CALL_OW 101
// if lostCounter = 0 then
33294: LD_EXP 32
33298: PUSH
33299: LD_INT 0
33301: EQUAL
33302: IFFALSE 33324
// begin m3 := true ;
33304: LD_ADDR_VAR 0 3
33308: PUSH
33309: LD_INT 1
33311: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33312: LD_STRING NoLosses
33314: PPUSH
33315: LD_INT 1
33317: PPUSH
33318: CALL_OW 101
// end else
33322: GO 33335
// AddMedal ( NoLosses , - 1 ) ;
33324: LD_STRING NoLosses
33326: PPUSH
33327: LD_INT 1
33329: NEG
33330: PPUSH
33331: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33335: LD_VAR 0 1
33339: PUSH
33340: LD_VAR 0 2
33344: AND
33345: PUSH
33346: LD_VAR 0 3
33350: AND
33351: PUSH
33352: LD_OWVAR 67
33356: PUSH
33357: LD_INT 3
33359: EQUAL
33360: AND
33361: IFFALSE 33373
// SetAchievementEX ( ACH_AMER , 15 ) ;
33363: LD_STRING ACH_AMER
33365: PPUSH
33366: LD_INT 15
33368: PPUSH
33369: CALL_OW 564
// GiveMedals ( MAIN ) ;
33373: LD_STRING MAIN
33375: PPUSH
33376: CALL_OW 102
// music_class := 4 ;
33380: LD_ADDR_OWVAR 72
33384: PUSH
33385: LD_INT 4
33387: ST_TO_ADDR
// music_nat := 1 ;
33388: LD_ADDR_OWVAR 71
33392: PUSH
33393: LD_INT 1
33395: ST_TO_ADDR
// YouWin ;
33396: CALL_OW 103
// end ; end_of_file
33400: PPOPN 3
33402: END
// export function CustomEvent ( event ) ; begin
33403: LD_INT 0
33405: PPUSH
// end ;
33406: LD_VAR 0 2
33410: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33411: LD_VAR 0 1
33415: PUSH
33416: LD_INT 1
33418: EQUAL
33419: PUSH
33420: LD_VAR 0 2
33424: PUSH
33425: LD_INT 4
33427: EQUAL
33428: AND
33429: PUSH
33430: LD_EXP 58
33434: PPUSH
33435: CALL_OW 300
33439: AND
33440: IFFALSE 33456
// begin wait ( 0 0$2 ) ;
33442: LD_INT 70
33444: PPUSH
33445: CALL_OW 67
// YouLost ( Dismissed ) ;
33449: LD_STRING Dismissed
33451: PPUSH
33452: CALL_OW 104
// end ; end ;
33456: PPOPN 2
33458: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33459: LD_VAR 0 2
33463: PPUSH
33464: LD_VAR 0 3
33468: PPUSH
33469: LD_INT 18
33471: PPUSH
33472: CALL_OW 309
33476: IFFALSE 33485
// YouLost ( Motherlode3 ) ;
33478: LD_STRING Motherlode3
33480: PPUSH
33481: CALL_OW 104
// end ;
33485: PPOPN 3
33487: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33488: LD_EXP 27
33492: NOT
33493: IFFALSE 33503
// behemothDone := true ;
33495: LD_ADDR_EXP 28
33499: PUSH
33500: LD_INT 1
33502: ST_TO_ADDR
// end ;
33503: PPOPN 1
33505: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33506: LD_VAR 0 1
33510: PPUSH
33511: CALL_OW 255
33515: PUSH
33516: LD_INT 1
33518: EQUAL
33519: IFFALSE 33529
// bombExploded := true ;
33521: LD_ADDR_EXP 37
33525: PUSH
33526: LD_INT 1
33528: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33529: LD_VAR 0 1
33533: PPUSH
33534: CALL_OW 255
33538: PUSH
33539: LD_INT 1
33541: EQUAL
33542: PUSH
33543: LD_EXP 30
33547: AND
33548: PUSH
33549: LD_INT 22
33551: PUSH
33552: LD_INT 3
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 34
33561: PUSH
33562: LD_INT 48
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PPUSH
33573: CALL_OW 69
33577: AND
33578: PUSH
33579: LD_INT 22
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 34
33591: PUSH
33592: LD_INT 8
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PPUSH
33603: CALL_OW 69
33607: NOT
33608: AND
33609: IFFALSE 33661
// begin wait ( 0 0$5 ) ;
33611: LD_INT 175
33613: PPUSH
33614: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33618: LD_INT 22
33620: PUSH
33621: LD_INT 3
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 34
33630: PUSH
33631: LD_INT 48
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PPUSH
33642: CALL_OW 69
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: LD_INT 60
33653: PPUSH
33654: LD_INT 95
33656: PPUSH
33657: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33661: LD_VAR 0 2
33665: PPUSH
33666: LD_VAR 0 3
33670: PPUSH
33671: LD_INT 18
33673: PPUSH
33674: CALL_OW 309
33678: IFFALSE 33738
// begin if GetSide ( unit ) = 1 then
33680: LD_VAR 0 1
33684: PPUSH
33685: CALL_OW 255
33689: PUSH
33690: LD_INT 1
33692: EQUAL
33693: IFFALSE 33709
// begin wait ( 0 0$6 ) ;
33695: LD_INT 210
33697: PPUSH
33698: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33702: LD_STRING Motherlode2
33704: PPUSH
33705: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33709: LD_VAR 0 1
33713: PPUSH
33714: CALL_OW 255
33718: PUSH
33719: LD_INT 8
33721: EQUAL
33722: IFFALSE 33738
// begin wait ( 0 0$6 ) ;
33724: LD_INT 210
33726: PPUSH
33727: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33731: LD_STRING Motherlode1
33733: PPUSH
33734: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33738: LD_VAR 0 1
33742: PPUSH
33743: CALL_OW 255
33747: PUSH
33748: LD_INT 3
33750: EQUAL
33751: IFFALSE 33772
// begin wait ( 0 0$5 ) ;
33753: LD_INT 175
33755: PPUSH
33756: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33760: LD_EXP 64
33764: PPUSH
33765: LD_STRING D18-Pla-1
33767: PPUSH
33768: CALL_OW 94
// end ; end ;
33772: PPOPN 3
33774: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33775: LD_VAR 0 1
33779: PUSH
33780: LD_INT 22
33782: PUSH
33783: LD_INT 1
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 21
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 23
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: PPUSH
33815: CALL_OW 69
33819: IN
33820: IFFALSE 33836
// lostCounter := lostCounter + 1 ;
33822: LD_ADDR_EXP 32
33826: PUSH
33827: LD_EXP 32
33831: PUSH
33832: LD_INT 1
33834: PLUS
33835: ST_TO_ADDR
// if un in behemothBuilders then
33836: LD_VAR 0 1
33840: PUSH
33841: LD_EXP 73
33845: IN
33846: IFFALSE 33866
// begin behemothBuilders := behemothBuilders diff un ;
33848: LD_ADDR_EXP 73
33852: PUSH
33853: LD_EXP 73
33857: PUSH
33858: LD_VAR 0 1
33862: DIFF
33863: ST_TO_ADDR
// exit ;
33864: GO 33896
// end ; if un = JMM then
33866: LD_VAR 0 1
33870: PUSH
33871: LD_EXP 39
33875: EQUAL
33876: IFFALSE 33887
// begin YouLost ( JMM ) ;
33878: LD_STRING JMM
33880: PPUSH
33881: CALL_OW 104
// exit ;
33885: GO 33896
// end ; MCE_UnitDestroyed ( un ) ;
33887: LD_VAR 0 1
33891: PPUSH
33892: CALL 62152 0 1
// end ;
33896: PPOPN 1
33898: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33899: LD_VAR 0 1
33903: PPUSH
33904: LD_VAR 0 2
33908: PPUSH
33909: CALL 64486 0 2
// end ;
33913: PPOPN 2
33915: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33916: LD_VAR 0 1
33920: PPUSH
33921: CALL 63554 0 1
// end ;
33925: PPOPN 1
33927: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33928: LD_VAR 0 1
33932: PUSH
33933: LD_INT 22
33935: PUSH
33936: LD_INT 8
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 30
33945: PUSH
33946: LD_INT 2
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 23
33955: PUSH
33956: LD_INT 3
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: LIST
33967: PPUSH
33968: CALL_OW 69
33972: IN
33973: IFFALSE 34000
// begin ComUpgrade ( building ) ;
33975: LD_VAR 0 1
33979: PPUSH
33980: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33984: LD_EXP 61
33988: PPUSH
33989: LD_VAR 0 1
33993: PPUSH
33994: CALL 72901 0 2
// exit ;
33998: GO 34009
// end ; MCE_BuildingComplete ( building ) ;
34000: LD_VAR 0 1
34004: PPUSH
34005: CALL 63795 0 1
// end ;
34009: PPOPN 1
34011: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34012: LD_VAR 0 1
34016: PPUSH
34017: LD_VAR 0 2
34021: PPUSH
34022: CALL 61848 0 2
// end ;
34026: PPOPN 2
34028: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_VAR 0 3
34043: PPUSH
34044: LD_VAR 0 4
34048: PPUSH
34049: LD_VAR 0 5
34053: PPUSH
34054: CALL 61468 0 5
// end ;
34058: PPOPN 5
34060: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34061: LD_VAR 0 1
34065: PPUSH
34066: LD_VAR 0 2
34070: PPUSH
34071: CALL 61064 0 2
// end ;
34075: PPOPN 2
34077: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34078: LD_VAR 0 1
34082: PPUSH
34083: LD_VAR 0 2
34087: PPUSH
34088: LD_VAR 0 3
34092: PPUSH
34093: LD_VAR 0 4
34097: PPUSH
34098: CALL 60902 0 4
// end ;
34102: PPOPN 4
34104: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34105: LD_VAR 0 1
34109: PPUSH
34110: LD_VAR 0 2
34114: PPUSH
34115: LD_VAR 0 3
34119: PPUSH
34120: CALL 60677 0 3
// end ;
34124: PPOPN 3
34126: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34127: LD_VAR 0 1
34131: PPUSH
34132: LD_VAR 0 2
34136: PPUSH
34137: CALL 60562 0 2
// end ;
34141: PPOPN 2
34143: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34144: LD_VAR 0 1
34148: PPUSH
34149: LD_VAR 0 2
34153: PPUSH
34154: CALL 64747 0 2
// end ;
34158: PPOPN 2
34160: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 255
34170: PUSH
34171: LD_INT 4
34173: EQUAL
34174: PUSH
34175: LD_VAR 0 1
34179: PUSH
34180: LD_EXP 18
34184: PUSH
34185: LD_INT 1
34187: ARRAY
34188: IN
34189: AND
34190: PUSH
34191: LD_EXP 19
34195: AND
34196: IFFALSE 34215
// begin ComMoveXY ( driver , 61 , 93 ) ;
34198: LD_VAR 0 1
34202: PPUSH
34203: LD_INT 61
34205: PPUSH
34206: LD_INT 93
34208: PPUSH
34209: CALL_OW 111
// exit ;
34213: GO 34239
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34215: LD_VAR 0 1
34219: PPUSH
34220: LD_VAR 0 2
34224: PPUSH
34225: LD_VAR 0 3
34229: PPUSH
34230: LD_VAR 0 4
34234: PPUSH
34235: CALL 64963 0 4
// end ;
34239: PPOPN 4
34241: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34242: LD_VAR 0 1
34246: PPUSH
34247: LD_VAR 0 2
34251: PPUSH
34252: CALL 60371 0 2
// end ;
34256: PPOPN 2
34258: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34259: LD_VAR 0 1
34263: PPUSH
34264: CALL 114738 0 1
// end ; end_of_file
34268: PPOPN 1
34270: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34271: LD_EXP 15
34275: PUSH
34276: LD_INT 2
34278: EQUAL
34279: IFFALSE 34758
34281: GO 34283
34283: DISABLE
34284: LD_INT 0
34286: PPUSH
// begin time := 0 0$40 ;
34287: LD_ADDR_VAR 0 1
34291: PUSH
34292: LD_INT 1400
34294: ST_TO_ADDR
// repeat wait ( time ) ;
34295: LD_VAR 0 1
34299: PPUSH
34300: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34304: LD_INT 1
34306: PPUSH
34307: LD_INT 5
34309: PPUSH
34310: CALL_OW 12
34314: PPUSH
34315: LD_INT 106
34317: PPUSH
34318: LD_INT 150
34320: PPUSH
34321: LD_INT 19
34323: PPUSH
34324: LD_INT 1
34326: PPUSH
34327: CALL_OW 56
// time := time + 0 0$9 ;
34331: LD_ADDR_VAR 0 1
34335: PUSH
34336: LD_VAR 0 1
34340: PUSH
34341: LD_INT 315
34343: PLUS
34344: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34345: LD_INT 455
34347: PPUSH
34348: LD_INT 840
34350: PPUSH
34351: CALL_OW 12
34355: PPUSH
34356: CALL_OW 67
// if Prob ( 50 ) then
34360: LD_INT 50
34362: PPUSH
34363: CALL_OW 13
34367: IFFALSE 34396
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34369: LD_INT 1
34371: PPUSH
34372: LD_INT 5
34374: PPUSH
34375: CALL_OW 12
34379: PPUSH
34380: LD_INT 62
34382: PPUSH
34383: LD_INT 108
34385: PPUSH
34386: LD_INT 10
34388: PPUSH
34389: LD_INT 1
34391: PPUSH
34392: CALL_OW 56
// until missionStage > 4 ;
34396: LD_EXP 15
34400: PUSH
34401: LD_INT 4
34403: GREATER
34404: IFFALSE 34295
// repeat wait ( 0 0$1 ) ;
34406: LD_INT 35
34408: PPUSH
34409: CALL_OW 67
// until missionStage = 6 ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 6
34420: EQUAL
34421: IFFALSE 34406
// time := 0 0$50 ;
34423: LD_ADDR_VAR 0 1
34427: PUSH
34428: LD_INT 1750
34430: ST_TO_ADDR
// repeat wait ( time ) ;
34431: LD_VAR 0 1
34435: PPUSH
34436: CALL_OW 67
// if Prob ( 50 ) then
34440: LD_INT 50
34442: PPUSH
34443: CALL_OW 13
34447: IFFALSE 34476
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34449: LD_INT 1
34451: PPUSH
34452: LD_INT 5
34454: PPUSH
34455: CALL_OW 12
34459: PPUSH
34460: LD_INT 106
34462: PPUSH
34463: LD_INT 89
34465: PPUSH
34466: LD_INT 45
34468: PPUSH
34469: LD_INT 1
34471: PPUSH
34472: CALL_OW 56
// time := time + 0 0$2 ;
34476: LD_ADDR_VAR 0 1
34480: PUSH
34481: LD_VAR 0 1
34485: PUSH
34486: LD_INT 70
34488: PLUS
34489: ST_TO_ADDR
// if Prob ( 30 ) then
34490: LD_INT 30
34492: PPUSH
34493: CALL_OW 13
34497: IFFALSE 34543
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34499: LD_INT 385
34501: PPUSH
34502: LD_INT 945
34504: PPUSH
34505: CALL_OW 12
34509: PPUSH
34510: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34514: LD_INT 1
34516: PPUSH
34517: LD_INT 5
34519: PPUSH
34520: CALL_OW 12
34524: PPUSH
34525: LD_INT 21
34527: PPUSH
34528: LD_INT 26
34530: PPUSH
34531: LD_INT 12
34533: PPUSH
34534: LD_INT 1
34536: PPUSH
34537: CALL_OW 56
// end else
34541: GO 34579
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34543: LD_INT 700
34545: PPUSH
34546: LD_INT 1225
34548: PPUSH
34549: CALL_OW 12
34553: PPUSH
34554: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34558: LD_INT 1
34560: PPUSH
34561: LD_INT 5
34563: PPUSH
34564: CALL_OW 12
34568: PPUSH
34569: LD_INT 16
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: CALL_OW 55
// end ; if Prob ( 50 ) then
34579: LD_INT 50
34581: PPUSH
34582: CALL_OW 13
34586: IFFALSE 34632
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34588: LD_INT 700
34590: PPUSH
34591: LD_INT 1050
34593: PPUSH
34594: CALL_OW 12
34598: PPUSH
34599: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34603: LD_INT 1
34605: PPUSH
34606: LD_INT 5
34608: PPUSH
34609: CALL_OW 12
34613: PPUSH
34614: LD_INT 181
34616: PPUSH
34617: LD_INT 218
34619: PPUSH
34620: LD_INT 16
34622: PPUSH
34623: LD_INT 1
34625: PPUSH
34626: CALL_OW 56
// end else
34630: GO 34668
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34632: LD_INT 350
34634: PPUSH
34635: LD_INT 525
34637: PPUSH
34638: CALL_OW 12
34642: PPUSH
34643: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34647: LD_INT 1
34649: PPUSH
34650: LD_INT 5
34652: PPUSH
34653: CALL_OW 12
34657: PPUSH
34658: LD_INT 15
34660: PPUSH
34661: LD_INT 1
34663: PPUSH
34664: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34668: LD_INT 45
34670: PUSH
34671: LD_INT 32
34673: PUSH
34674: LD_INT 25
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: LIST
34681: PUSH
34682: LD_OWVAR 67
34686: ARRAY
34687: PPUSH
34688: CALL_OW 13
34692: IFFALSE 34736
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34694: LD_INT 175
34696: PPUSH
34697: LD_INT 315
34699: PPUSH
34700: CALL_OW 12
34704: PPUSH
34705: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34709: LD_INT 1
34711: PPUSH
34712: LD_INT 5
34714: PPUSH
34715: CALL_OW 12
34719: PPUSH
34720: LD_INT 103
34722: PPUSH
34723: LD_INT 140
34725: PPUSH
34726: LD_INT 20
34728: PPUSH
34729: LD_INT 1
34731: PPUSH
34732: CALL_OW 56
// end ; if time > 1 1$20 then
34736: LD_VAR 0 1
34740: PUSH
34741: LD_INT 2800
34743: GREATER
34744: IFFALSE 34754
// time := 0 0$30 ;
34746: LD_ADDR_VAR 0 1
34750: PUSH
34751: LD_INT 1050
34753: ST_TO_ADDR
// until false ;
34754: LD_INT 0
34756: IFFALSE 34431
// end ; end_of_file
34758: PPOPN 1
34760: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34761: LD_EXP 13
34765: PUSH
34766: LD_EXP 15
34770: PUSH
34771: LD_INT 6
34773: GREATEREQUAL
34774: AND
34775: IFFALSE 34812
34777: GO 34779
34779: DISABLE
// begin enable ;
34780: ENABLE
// missionTime := missionTime + 0 0$1 ;
34781: LD_ADDR_EXP 14
34785: PUSH
34786: LD_EXP 14
34790: PUSH
34791: LD_INT 35
34793: PLUS
34794: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34795: LD_ADDR_OWVAR 47
34799: PUSH
34800: LD_STRING #Am15-1
34802: PUSH
34803: LD_EXP 14
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: ST_TO_ADDR
// end ; end_of_file
34812: END
// export function InitNature ; begin
34813: LD_INT 0
34815: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34816: LD_INT 3
34818: PPUSH
34819: LD_INT 3
34821: PPUSH
34822: LD_INT 2
34824: PPUSH
34825: LD_INT 1
34827: PPUSH
34828: LD_INT 1
34830: PPUSH
34831: LD_INT 0
34833: PPUSH
34834: LD_INT 0
34836: PPUSH
34837: LD_INT 20
34839: PPUSH
34840: LD_INT 0
34842: PPUSH
34843: CALL 97719 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34847: LD_INT 2
34849: PPUSH
34850: LD_INT 1
34852: PPUSH
34853: LD_INT 1
34855: PPUSH
34856: LD_INT 1
34858: PPUSH
34859: LD_INT 1
34861: PPUSH
34862: LD_INT 0
34864: PPUSH
34865: LD_INT 0
34867: PPUSH
34868: LD_INT 21
34870: PPUSH
34871: LD_INT 0
34873: PPUSH
34874: CALL 97719 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34878: LD_INT 4
34880: PPUSH
34881: LD_INT 1
34883: PPUSH
34884: LD_INT 2
34886: PPUSH
34887: LD_INT 4
34889: PPUSH
34890: LD_INT 2
34892: PPUSH
34893: LD_INT 1
34895: PPUSH
34896: LD_INT 0
34898: PPUSH
34899: LD_INT 22
34901: PPUSH
34902: LD_INT 0
34904: PPUSH
34905: CALL 97719 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34909: LD_INT 0
34911: PPUSH
34912: LD_INT 0
34914: PPUSH
34915: LD_INT 0
34917: PPUSH
34918: LD_INT 0
34920: PPUSH
34921: LD_INT 0
34923: PPUSH
34924: LD_INT 0
34926: PPUSH
34927: LD_INT 9
34929: PPUSH
34930: LD_INT 0
34932: PPUSH
34933: LD_INT 23
34935: PPUSH
34936: CALL 97719 0 9
// end ; end_of_file
34940: LD_VAR 0 1
34944: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
34945: LD_INT 0
34947: PPUSH
// ar_crane := 88 ;
34948: LD_ADDR_EXP 101
34952: PUSH
34953: LD_INT 88
34955: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34956: LD_ADDR_EXP 96
34960: PUSH
34961: LD_INT 89
34963: ST_TO_ADDR
// us_hack := 99 ;
34964: LD_ADDR_EXP 97
34968: PUSH
34969: LD_INT 99
34971: ST_TO_ADDR
// us_artillery := 97 ;
34972: LD_ADDR_EXP 98
34976: PUSH
34977: LD_INT 97
34979: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34980: LD_ADDR_EXP 99
34984: PUSH
34985: LD_INT 91
34987: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
34988: LD_ADDR_EXP 100
34992: PUSH
34993: LD_INT 92
34995: ST_TO_ADDR
// ru_radar := 98 ;
34996: LD_ADDR_EXP 95
35000: PUSH
35001: LD_INT 98
35003: ST_TO_ADDR
// tech_Artillery := 80 ;
35004: LD_ADDR_EXP 102
35008: PUSH
35009: LD_INT 80
35011: ST_TO_ADDR
// tech_RadMat := 81 ;
35012: LD_ADDR_EXP 103
35016: PUSH
35017: LD_INT 81
35019: ST_TO_ADDR
// tech_BasicTools := 82 ;
35020: LD_ADDR_EXP 104
35024: PUSH
35025: LD_INT 82
35027: ST_TO_ADDR
// tech_Cargo := 83 ;
35028: LD_ADDR_EXP 105
35032: PUSH
35033: LD_INT 83
35035: ST_TO_ADDR
// tech_Track := 84 ;
35036: LD_ADDR_EXP 106
35040: PUSH
35041: LD_INT 84
35043: ST_TO_ADDR
// tech_Crane := 85 ;
35044: LD_ADDR_EXP 107
35048: PUSH
35049: LD_INT 85
35051: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35052: LD_ADDR_EXP 108
35056: PUSH
35057: LD_INT 86
35059: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35060: LD_ADDR_EXP 109
35064: PUSH
35065: LD_INT 87
35067: ST_TO_ADDR
// end ;
35068: LD_VAR 0 1
35072: RET
// every 1 do
35073: GO 35075
35075: DISABLE
// InitGlobalVariables ; end_of_file
35076: CALL 34945 0 0
35080: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
35081: LD_INT 0
35083: PPUSH
35084: PPUSH
// skirmish := false ;
35085: LD_ADDR_EXP 110
35089: PUSH
35090: LD_INT 0
35092: ST_TO_ADDR
// debug_mc := false ;
35093: LD_ADDR_EXP 111
35097: PUSH
35098: LD_INT 0
35100: ST_TO_ADDR
// mc_bases := [ ] ;
35101: LD_ADDR_EXP 112
35105: PUSH
35106: EMPTY
35107: ST_TO_ADDR
// mc_sides := [ ] ;
35108: LD_ADDR_EXP 138
35112: PUSH
35113: EMPTY
35114: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35115: LD_ADDR_EXP 113
35119: PUSH
35120: EMPTY
35121: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35122: LD_ADDR_EXP 114
35126: PUSH
35127: EMPTY
35128: ST_TO_ADDR
// mc_need_heal := [ ] ;
35129: LD_ADDR_EXP 115
35133: PUSH
35134: EMPTY
35135: ST_TO_ADDR
// mc_healers := [ ] ;
35136: LD_ADDR_EXP 116
35140: PUSH
35141: EMPTY
35142: ST_TO_ADDR
// mc_build_list := [ ] ;
35143: LD_ADDR_EXP 117
35147: PUSH
35148: EMPTY
35149: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35150: LD_ADDR_EXP 144
35154: PUSH
35155: EMPTY
35156: ST_TO_ADDR
// mc_builders := [ ] ;
35157: LD_ADDR_EXP 118
35161: PUSH
35162: EMPTY
35163: ST_TO_ADDR
// mc_construct_list := [ ] ;
35164: LD_ADDR_EXP 119
35168: PUSH
35169: EMPTY
35170: ST_TO_ADDR
// mc_turret_list := [ ] ;
35171: LD_ADDR_EXP 120
35175: PUSH
35176: EMPTY
35177: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35178: LD_ADDR_EXP 121
35182: PUSH
35183: EMPTY
35184: ST_TO_ADDR
// mc_miners := [ ] ;
35185: LD_ADDR_EXP 126
35189: PUSH
35190: EMPTY
35191: ST_TO_ADDR
// mc_mines := [ ] ;
35192: LD_ADDR_EXP 125
35196: PUSH
35197: EMPTY
35198: ST_TO_ADDR
// mc_minefields := [ ] ;
35199: LD_ADDR_EXP 127
35203: PUSH
35204: EMPTY
35205: ST_TO_ADDR
// mc_crates := [ ] ;
35206: LD_ADDR_EXP 128
35210: PUSH
35211: EMPTY
35212: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35213: LD_ADDR_EXP 129
35217: PUSH
35218: EMPTY
35219: ST_TO_ADDR
// mc_crates_area := [ ] ;
35220: LD_ADDR_EXP 130
35224: PUSH
35225: EMPTY
35226: ST_TO_ADDR
// mc_vehicles := [ ] ;
35227: LD_ADDR_EXP 131
35231: PUSH
35232: EMPTY
35233: ST_TO_ADDR
// mc_attack := [ ] ;
35234: LD_ADDR_EXP 132
35238: PUSH
35239: EMPTY
35240: ST_TO_ADDR
// mc_produce := [ ] ;
35241: LD_ADDR_EXP 133
35245: PUSH
35246: EMPTY
35247: ST_TO_ADDR
// mc_defender := [ ] ;
35248: LD_ADDR_EXP 134
35252: PUSH
35253: EMPTY
35254: ST_TO_ADDR
// mc_parking := [ ] ;
35255: LD_ADDR_EXP 136
35259: PUSH
35260: EMPTY
35261: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35262: LD_ADDR_EXP 122
35266: PUSH
35267: EMPTY
35268: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35269: LD_ADDR_EXP 124
35273: PUSH
35274: EMPTY
35275: ST_TO_ADDR
// mc_scan := [ ] ;
35276: LD_ADDR_EXP 135
35280: PUSH
35281: EMPTY
35282: ST_TO_ADDR
// mc_scan_area := [ ] ;
35283: LD_ADDR_EXP 137
35287: PUSH
35288: EMPTY
35289: ST_TO_ADDR
// mc_tech := [ ] ;
35290: LD_ADDR_EXP 139
35294: PUSH
35295: EMPTY
35296: ST_TO_ADDR
// mc_class := [ ] ;
35297: LD_ADDR_EXP 153
35301: PUSH
35302: EMPTY
35303: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35304: LD_ADDR_EXP 154
35308: PUSH
35309: EMPTY
35310: ST_TO_ADDR
// end ;
35311: LD_VAR 0 1
35315: RET
// export function MC_Kill ( base ) ; begin
35316: LD_INT 0
35318: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35319: LD_ADDR_EXP 112
35323: PUSH
35324: LD_EXP 112
35328: PPUSH
35329: LD_VAR 0 1
35333: PPUSH
35334: EMPTY
35335: PPUSH
35336: CALL_OW 1
35340: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35341: LD_ADDR_EXP 113
35345: PUSH
35346: LD_EXP 113
35350: PPUSH
35351: LD_VAR 0 1
35355: PPUSH
35356: EMPTY
35357: PPUSH
35358: CALL_OW 1
35362: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35363: LD_ADDR_EXP 114
35367: PUSH
35368: LD_EXP 114
35372: PPUSH
35373: LD_VAR 0 1
35377: PPUSH
35378: EMPTY
35379: PPUSH
35380: CALL_OW 1
35384: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35385: LD_ADDR_EXP 115
35389: PUSH
35390: LD_EXP 115
35394: PPUSH
35395: LD_VAR 0 1
35399: PPUSH
35400: EMPTY
35401: PPUSH
35402: CALL_OW 1
35406: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35407: LD_ADDR_EXP 116
35411: PUSH
35412: LD_EXP 116
35416: PPUSH
35417: LD_VAR 0 1
35421: PPUSH
35422: EMPTY
35423: PPUSH
35424: CALL_OW 1
35428: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35429: LD_ADDR_EXP 117
35433: PUSH
35434: LD_EXP 117
35438: PPUSH
35439: LD_VAR 0 1
35443: PPUSH
35444: EMPTY
35445: PPUSH
35446: CALL_OW 1
35450: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35451: LD_ADDR_EXP 118
35455: PUSH
35456: LD_EXP 118
35460: PPUSH
35461: LD_VAR 0 1
35465: PPUSH
35466: EMPTY
35467: PPUSH
35468: CALL_OW 1
35472: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35473: LD_ADDR_EXP 119
35477: PUSH
35478: LD_EXP 119
35482: PPUSH
35483: LD_VAR 0 1
35487: PPUSH
35488: EMPTY
35489: PPUSH
35490: CALL_OW 1
35494: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35495: LD_ADDR_EXP 120
35499: PUSH
35500: LD_EXP 120
35504: PPUSH
35505: LD_VAR 0 1
35509: PPUSH
35510: EMPTY
35511: PPUSH
35512: CALL_OW 1
35516: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35517: LD_ADDR_EXP 121
35521: PUSH
35522: LD_EXP 121
35526: PPUSH
35527: LD_VAR 0 1
35531: PPUSH
35532: EMPTY
35533: PPUSH
35534: CALL_OW 1
35538: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35539: LD_ADDR_EXP 122
35543: PUSH
35544: LD_EXP 122
35548: PPUSH
35549: LD_VAR 0 1
35553: PPUSH
35554: EMPTY
35555: PPUSH
35556: CALL_OW 1
35560: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35561: LD_ADDR_EXP 123
35565: PUSH
35566: LD_EXP 123
35570: PPUSH
35571: LD_VAR 0 1
35575: PPUSH
35576: LD_INT 0
35578: PPUSH
35579: CALL_OW 1
35583: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35584: LD_ADDR_EXP 124
35588: PUSH
35589: LD_EXP 124
35593: PPUSH
35594: LD_VAR 0 1
35598: PPUSH
35599: EMPTY
35600: PPUSH
35601: CALL_OW 1
35605: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35606: LD_ADDR_EXP 125
35610: PUSH
35611: LD_EXP 125
35615: PPUSH
35616: LD_VAR 0 1
35620: PPUSH
35621: EMPTY
35622: PPUSH
35623: CALL_OW 1
35627: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35628: LD_ADDR_EXP 126
35632: PUSH
35633: LD_EXP 126
35637: PPUSH
35638: LD_VAR 0 1
35642: PPUSH
35643: EMPTY
35644: PPUSH
35645: CALL_OW 1
35649: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35650: LD_ADDR_EXP 127
35654: PUSH
35655: LD_EXP 127
35659: PPUSH
35660: LD_VAR 0 1
35664: PPUSH
35665: EMPTY
35666: PPUSH
35667: CALL_OW 1
35671: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35672: LD_ADDR_EXP 128
35676: PUSH
35677: LD_EXP 128
35681: PPUSH
35682: LD_VAR 0 1
35686: PPUSH
35687: EMPTY
35688: PPUSH
35689: CALL_OW 1
35693: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35694: LD_ADDR_EXP 129
35698: PUSH
35699: LD_EXP 129
35703: PPUSH
35704: LD_VAR 0 1
35708: PPUSH
35709: EMPTY
35710: PPUSH
35711: CALL_OW 1
35715: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35716: LD_ADDR_EXP 130
35720: PUSH
35721: LD_EXP 130
35725: PPUSH
35726: LD_VAR 0 1
35730: PPUSH
35731: EMPTY
35732: PPUSH
35733: CALL_OW 1
35737: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35738: LD_ADDR_EXP 131
35742: PUSH
35743: LD_EXP 131
35747: PPUSH
35748: LD_VAR 0 1
35752: PPUSH
35753: EMPTY
35754: PPUSH
35755: CALL_OW 1
35759: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35760: LD_ADDR_EXP 132
35764: PUSH
35765: LD_EXP 132
35769: PPUSH
35770: LD_VAR 0 1
35774: PPUSH
35775: EMPTY
35776: PPUSH
35777: CALL_OW 1
35781: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35782: LD_ADDR_EXP 133
35786: PUSH
35787: LD_EXP 133
35791: PPUSH
35792: LD_VAR 0 1
35796: PPUSH
35797: EMPTY
35798: PPUSH
35799: CALL_OW 1
35803: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35804: LD_ADDR_EXP 134
35808: PUSH
35809: LD_EXP 134
35813: PPUSH
35814: LD_VAR 0 1
35818: PPUSH
35819: EMPTY
35820: PPUSH
35821: CALL_OW 1
35825: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35826: LD_ADDR_EXP 135
35830: PUSH
35831: LD_EXP 135
35835: PPUSH
35836: LD_VAR 0 1
35840: PPUSH
35841: EMPTY
35842: PPUSH
35843: CALL_OW 1
35847: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35848: LD_ADDR_EXP 136
35852: PUSH
35853: LD_EXP 136
35857: PPUSH
35858: LD_VAR 0 1
35862: PPUSH
35863: EMPTY
35864: PPUSH
35865: CALL_OW 1
35869: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35870: LD_ADDR_EXP 137
35874: PUSH
35875: LD_EXP 137
35879: PPUSH
35880: LD_VAR 0 1
35884: PPUSH
35885: EMPTY
35886: PPUSH
35887: CALL_OW 1
35891: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35892: LD_ADDR_EXP 139
35896: PUSH
35897: LD_EXP 139
35901: PPUSH
35902: LD_VAR 0 1
35906: PPUSH
35907: EMPTY
35908: PPUSH
35909: CALL_OW 1
35913: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35914: LD_ADDR_EXP 141
35918: PUSH
35919: LD_EXP 141
35923: PPUSH
35924: LD_VAR 0 1
35928: PPUSH
35929: EMPTY
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35936: LD_ADDR_EXP 142
35940: PUSH
35941: LD_EXP 142
35945: PPUSH
35946: LD_VAR 0 1
35950: PPUSH
35951: EMPTY
35952: PPUSH
35953: CALL_OW 1
35957: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35958: LD_ADDR_EXP 143
35962: PUSH
35963: LD_EXP 143
35967: PPUSH
35968: LD_VAR 0 1
35972: PPUSH
35973: EMPTY
35974: PPUSH
35975: CALL_OW 1
35979: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35980: LD_ADDR_EXP 144
35984: PUSH
35985: LD_EXP 144
35989: PPUSH
35990: LD_VAR 0 1
35994: PPUSH
35995: EMPTY
35996: PPUSH
35997: CALL_OW 1
36001: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36002: LD_ADDR_EXP 145
36006: PUSH
36007: LD_EXP 145
36011: PPUSH
36012: LD_VAR 0 1
36016: PPUSH
36017: EMPTY
36018: PPUSH
36019: CALL_OW 1
36023: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36024: LD_ADDR_EXP 146
36028: PUSH
36029: LD_EXP 146
36033: PPUSH
36034: LD_VAR 0 1
36038: PPUSH
36039: EMPTY
36040: PPUSH
36041: CALL_OW 1
36045: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36046: LD_ADDR_EXP 147
36050: PUSH
36051: LD_EXP 147
36055: PPUSH
36056: LD_VAR 0 1
36060: PPUSH
36061: EMPTY
36062: PPUSH
36063: CALL_OW 1
36067: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36068: LD_ADDR_EXP 148
36072: PUSH
36073: LD_EXP 148
36077: PPUSH
36078: LD_VAR 0 1
36082: PPUSH
36083: EMPTY
36084: PPUSH
36085: CALL_OW 1
36089: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36090: LD_ADDR_EXP 149
36094: PUSH
36095: LD_EXP 149
36099: PPUSH
36100: LD_VAR 0 1
36104: PPUSH
36105: EMPTY
36106: PPUSH
36107: CALL_OW 1
36111: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36112: LD_ADDR_EXP 150
36116: PUSH
36117: LD_EXP 150
36121: PPUSH
36122: LD_VAR 0 1
36126: PPUSH
36127: EMPTY
36128: PPUSH
36129: CALL_OW 1
36133: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36134: LD_ADDR_EXP 151
36138: PUSH
36139: LD_EXP 151
36143: PPUSH
36144: LD_VAR 0 1
36148: PPUSH
36149: EMPTY
36150: PPUSH
36151: CALL_OW 1
36155: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36156: LD_ADDR_EXP 152
36160: PUSH
36161: LD_EXP 152
36165: PPUSH
36166: LD_VAR 0 1
36170: PPUSH
36171: EMPTY
36172: PPUSH
36173: CALL_OW 1
36177: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36178: LD_ADDR_EXP 153
36182: PUSH
36183: LD_EXP 153
36187: PPUSH
36188: LD_VAR 0 1
36192: PPUSH
36193: EMPTY
36194: PPUSH
36195: CALL_OW 1
36199: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36200: LD_ADDR_EXP 154
36204: PUSH
36205: LD_EXP 154
36209: PPUSH
36210: LD_VAR 0 1
36214: PPUSH
36215: LD_INT 0
36217: PPUSH
36218: CALL_OW 1
36222: ST_TO_ADDR
// end ;
36223: LD_VAR 0 2
36227: RET
// export function MC_Add ( side , units ) ; var base ; begin
36228: LD_INT 0
36230: PPUSH
36231: PPUSH
// base := mc_bases + 1 ;
36232: LD_ADDR_VAR 0 4
36236: PUSH
36237: LD_EXP 112
36241: PUSH
36242: LD_INT 1
36244: PLUS
36245: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36246: LD_ADDR_EXP 138
36250: PUSH
36251: LD_EXP 138
36255: PPUSH
36256: LD_VAR 0 4
36260: PPUSH
36261: LD_VAR 0 1
36265: PPUSH
36266: CALL_OW 1
36270: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36271: LD_ADDR_EXP 112
36275: PUSH
36276: LD_EXP 112
36280: PPUSH
36281: LD_VAR 0 4
36285: PPUSH
36286: LD_VAR 0 2
36290: PPUSH
36291: CALL_OW 1
36295: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36296: LD_ADDR_EXP 113
36300: PUSH
36301: LD_EXP 113
36305: PPUSH
36306: LD_VAR 0 4
36310: PPUSH
36311: EMPTY
36312: PPUSH
36313: CALL_OW 1
36317: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36318: LD_ADDR_EXP 114
36322: PUSH
36323: LD_EXP 114
36327: PPUSH
36328: LD_VAR 0 4
36332: PPUSH
36333: EMPTY
36334: PPUSH
36335: CALL_OW 1
36339: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36340: LD_ADDR_EXP 115
36344: PUSH
36345: LD_EXP 115
36349: PPUSH
36350: LD_VAR 0 4
36354: PPUSH
36355: EMPTY
36356: PPUSH
36357: CALL_OW 1
36361: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36362: LD_ADDR_EXP 116
36366: PUSH
36367: LD_EXP 116
36371: PPUSH
36372: LD_VAR 0 4
36376: PPUSH
36377: EMPTY
36378: PPUSH
36379: CALL_OW 1
36383: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36384: LD_ADDR_EXP 117
36388: PUSH
36389: LD_EXP 117
36393: PPUSH
36394: LD_VAR 0 4
36398: PPUSH
36399: EMPTY
36400: PPUSH
36401: CALL_OW 1
36405: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36406: LD_ADDR_EXP 118
36410: PUSH
36411: LD_EXP 118
36415: PPUSH
36416: LD_VAR 0 4
36420: PPUSH
36421: EMPTY
36422: PPUSH
36423: CALL_OW 1
36427: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36428: LD_ADDR_EXP 119
36432: PUSH
36433: LD_EXP 119
36437: PPUSH
36438: LD_VAR 0 4
36442: PPUSH
36443: EMPTY
36444: PPUSH
36445: CALL_OW 1
36449: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36450: LD_ADDR_EXP 120
36454: PUSH
36455: LD_EXP 120
36459: PPUSH
36460: LD_VAR 0 4
36464: PPUSH
36465: EMPTY
36466: PPUSH
36467: CALL_OW 1
36471: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36472: LD_ADDR_EXP 121
36476: PUSH
36477: LD_EXP 121
36481: PPUSH
36482: LD_VAR 0 4
36486: PPUSH
36487: EMPTY
36488: PPUSH
36489: CALL_OW 1
36493: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36494: LD_ADDR_EXP 122
36498: PUSH
36499: LD_EXP 122
36503: PPUSH
36504: LD_VAR 0 4
36508: PPUSH
36509: EMPTY
36510: PPUSH
36511: CALL_OW 1
36515: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36516: LD_ADDR_EXP 123
36520: PUSH
36521: LD_EXP 123
36525: PPUSH
36526: LD_VAR 0 4
36530: PPUSH
36531: LD_INT 0
36533: PPUSH
36534: CALL_OW 1
36538: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36539: LD_ADDR_EXP 124
36543: PUSH
36544: LD_EXP 124
36548: PPUSH
36549: LD_VAR 0 4
36553: PPUSH
36554: EMPTY
36555: PPUSH
36556: CALL_OW 1
36560: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36561: LD_ADDR_EXP 125
36565: PUSH
36566: LD_EXP 125
36570: PPUSH
36571: LD_VAR 0 4
36575: PPUSH
36576: EMPTY
36577: PPUSH
36578: CALL_OW 1
36582: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36583: LD_ADDR_EXP 126
36587: PUSH
36588: LD_EXP 126
36592: PPUSH
36593: LD_VAR 0 4
36597: PPUSH
36598: EMPTY
36599: PPUSH
36600: CALL_OW 1
36604: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36605: LD_ADDR_EXP 127
36609: PUSH
36610: LD_EXP 127
36614: PPUSH
36615: LD_VAR 0 4
36619: PPUSH
36620: EMPTY
36621: PPUSH
36622: CALL_OW 1
36626: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36627: LD_ADDR_EXP 128
36631: PUSH
36632: LD_EXP 128
36636: PPUSH
36637: LD_VAR 0 4
36641: PPUSH
36642: EMPTY
36643: PPUSH
36644: CALL_OW 1
36648: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36649: LD_ADDR_EXP 129
36653: PUSH
36654: LD_EXP 129
36658: PPUSH
36659: LD_VAR 0 4
36663: PPUSH
36664: EMPTY
36665: PPUSH
36666: CALL_OW 1
36670: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36671: LD_ADDR_EXP 130
36675: PUSH
36676: LD_EXP 130
36680: PPUSH
36681: LD_VAR 0 4
36685: PPUSH
36686: EMPTY
36687: PPUSH
36688: CALL_OW 1
36692: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36693: LD_ADDR_EXP 131
36697: PUSH
36698: LD_EXP 131
36702: PPUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: EMPTY
36709: PPUSH
36710: CALL_OW 1
36714: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36715: LD_ADDR_EXP 132
36719: PUSH
36720: LD_EXP 132
36724: PPUSH
36725: LD_VAR 0 4
36729: PPUSH
36730: EMPTY
36731: PPUSH
36732: CALL_OW 1
36736: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36737: LD_ADDR_EXP 133
36741: PUSH
36742: LD_EXP 133
36746: PPUSH
36747: LD_VAR 0 4
36751: PPUSH
36752: EMPTY
36753: PPUSH
36754: CALL_OW 1
36758: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36759: LD_ADDR_EXP 134
36763: PUSH
36764: LD_EXP 134
36768: PPUSH
36769: LD_VAR 0 4
36773: PPUSH
36774: EMPTY
36775: PPUSH
36776: CALL_OW 1
36780: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36781: LD_ADDR_EXP 135
36785: PUSH
36786: LD_EXP 135
36790: PPUSH
36791: LD_VAR 0 4
36795: PPUSH
36796: EMPTY
36797: PPUSH
36798: CALL_OW 1
36802: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36803: LD_ADDR_EXP 136
36807: PUSH
36808: LD_EXP 136
36812: PPUSH
36813: LD_VAR 0 4
36817: PPUSH
36818: EMPTY
36819: PPUSH
36820: CALL_OW 1
36824: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36825: LD_ADDR_EXP 137
36829: PUSH
36830: LD_EXP 137
36834: PPUSH
36835: LD_VAR 0 4
36839: PPUSH
36840: EMPTY
36841: PPUSH
36842: CALL_OW 1
36846: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36847: LD_ADDR_EXP 139
36851: PUSH
36852: LD_EXP 139
36856: PPUSH
36857: LD_VAR 0 4
36861: PPUSH
36862: EMPTY
36863: PPUSH
36864: CALL_OW 1
36868: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36869: LD_ADDR_EXP 141
36873: PUSH
36874: LD_EXP 141
36878: PPUSH
36879: LD_VAR 0 4
36883: PPUSH
36884: EMPTY
36885: PPUSH
36886: CALL_OW 1
36890: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36891: LD_ADDR_EXP 142
36895: PUSH
36896: LD_EXP 142
36900: PPUSH
36901: LD_VAR 0 4
36905: PPUSH
36906: EMPTY
36907: PPUSH
36908: CALL_OW 1
36912: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36913: LD_ADDR_EXP 143
36917: PUSH
36918: LD_EXP 143
36922: PPUSH
36923: LD_VAR 0 4
36927: PPUSH
36928: EMPTY
36929: PPUSH
36930: CALL_OW 1
36934: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36935: LD_ADDR_EXP 144
36939: PUSH
36940: LD_EXP 144
36944: PPUSH
36945: LD_VAR 0 4
36949: PPUSH
36950: EMPTY
36951: PPUSH
36952: CALL_OW 1
36956: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36957: LD_ADDR_EXP 145
36961: PUSH
36962: LD_EXP 145
36966: PPUSH
36967: LD_VAR 0 4
36971: PPUSH
36972: EMPTY
36973: PPUSH
36974: CALL_OW 1
36978: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36979: LD_ADDR_EXP 146
36983: PUSH
36984: LD_EXP 146
36988: PPUSH
36989: LD_VAR 0 4
36993: PPUSH
36994: EMPTY
36995: PPUSH
36996: CALL_OW 1
37000: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37001: LD_ADDR_EXP 147
37005: PUSH
37006: LD_EXP 147
37010: PPUSH
37011: LD_VAR 0 4
37015: PPUSH
37016: EMPTY
37017: PPUSH
37018: CALL_OW 1
37022: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37023: LD_ADDR_EXP 148
37027: PUSH
37028: LD_EXP 148
37032: PPUSH
37033: LD_VAR 0 4
37037: PPUSH
37038: EMPTY
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37045: LD_ADDR_EXP 149
37049: PUSH
37050: LD_EXP 149
37054: PPUSH
37055: LD_VAR 0 4
37059: PPUSH
37060: EMPTY
37061: PPUSH
37062: CALL_OW 1
37066: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37067: LD_ADDR_EXP 150
37071: PUSH
37072: LD_EXP 150
37076: PPUSH
37077: LD_VAR 0 4
37081: PPUSH
37082: EMPTY
37083: PPUSH
37084: CALL_OW 1
37088: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37089: LD_ADDR_EXP 151
37093: PUSH
37094: LD_EXP 151
37098: PPUSH
37099: LD_VAR 0 4
37103: PPUSH
37104: EMPTY
37105: PPUSH
37106: CALL_OW 1
37110: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37111: LD_ADDR_EXP 152
37115: PUSH
37116: LD_EXP 152
37120: PPUSH
37121: LD_VAR 0 4
37125: PPUSH
37126: EMPTY
37127: PPUSH
37128: CALL_OW 1
37132: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37133: LD_ADDR_EXP 153
37137: PUSH
37138: LD_EXP 153
37142: PPUSH
37143: LD_VAR 0 4
37147: PPUSH
37148: EMPTY
37149: PPUSH
37150: CALL_OW 1
37154: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37155: LD_ADDR_EXP 154
37159: PUSH
37160: LD_EXP 154
37164: PPUSH
37165: LD_VAR 0 4
37169: PPUSH
37170: LD_INT 0
37172: PPUSH
37173: CALL_OW 1
37177: ST_TO_ADDR
// result := base ;
37178: LD_ADDR_VAR 0 3
37182: PUSH
37183: LD_VAR 0 4
37187: ST_TO_ADDR
// end ;
37188: LD_VAR 0 3
37192: RET
// export function MC_Start ( ) ; var i ; begin
37193: LD_INT 0
37195: PPUSH
37196: PPUSH
// for i = 1 to mc_bases do
37197: LD_ADDR_VAR 0 2
37201: PUSH
37202: DOUBLE
37203: LD_INT 1
37205: DEC
37206: ST_TO_ADDR
37207: LD_EXP 112
37211: PUSH
37212: FOR_TO
37213: IFFALSE 38290
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37215: LD_ADDR_EXP 112
37219: PUSH
37220: LD_EXP 112
37224: PPUSH
37225: LD_VAR 0 2
37229: PPUSH
37230: LD_EXP 112
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: PUSH
37241: LD_INT 0
37243: DIFF
37244: PPUSH
37245: CALL_OW 1
37249: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37250: LD_ADDR_EXP 113
37254: PUSH
37255: LD_EXP 113
37259: PPUSH
37260: LD_VAR 0 2
37264: PPUSH
37265: EMPTY
37266: PPUSH
37267: CALL_OW 1
37271: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37272: LD_ADDR_EXP 114
37276: PUSH
37277: LD_EXP 114
37281: PPUSH
37282: LD_VAR 0 2
37286: PPUSH
37287: EMPTY
37288: PPUSH
37289: CALL_OW 1
37293: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37294: LD_ADDR_EXP 115
37298: PUSH
37299: LD_EXP 115
37303: PPUSH
37304: LD_VAR 0 2
37308: PPUSH
37309: EMPTY
37310: PPUSH
37311: CALL_OW 1
37315: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37316: LD_ADDR_EXP 116
37320: PUSH
37321: LD_EXP 116
37325: PPUSH
37326: LD_VAR 0 2
37330: PPUSH
37331: EMPTY
37332: PUSH
37333: EMPTY
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PPUSH
37339: CALL_OW 1
37343: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37344: LD_ADDR_EXP 117
37348: PUSH
37349: LD_EXP 117
37353: PPUSH
37354: LD_VAR 0 2
37358: PPUSH
37359: EMPTY
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37366: LD_ADDR_EXP 144
37370: PUSH
37371: LD_EXP 144
37375: PPUSH
37376: LD_VAR 0 2
37380: PPUSH
37381: EMPTY
37382: PPUSH
37383: CALL_OW 1
37387: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37388: LD_ADDR_EXP 118
37392: PUSH
37393: LD_EXP 118
37397: PPUSH
37398: LD_VAR 0 2
37402: PPUSH
37403: EMPTY
37404: PPUSH
37405: CALL_OW 1
37409: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37410: LD_ADDR_EXP 119
37414: PUSH
37415: LD_EXP 119
37419: PPUSH
37420: LD_VAR 0 2
37424: PPUSH
37425: EMPTY
37426: PPUSH
37427: CALL_OW 1
37431: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37432: LD_ADDR_EXP 120
37436: PUSH
37437: LD_EXP 120
37441: PPUSH
37442: LD_VAR 0 2
37446: PPUSH
37447: LD_EXP 112
37451: PUSH
37452: LD_VAR 0 2
37456: ARRAY
37457: PPUSH
37458: LD_INT 2
37460: PUSH
37461: LD_INT 30
37463: PUSH
37464: LD_INT 32
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 30
37473: PUSH
37474: LD_INT 33
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: LIST
37485: PPUSH
37486: CALL_OW 72
37490: PPUSH
37491: CALL_OW 1
37495: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37496: LD_ADDR_EXP 121
37500: PUSH
37501: LD_EXP 121
37505: PPUSH
37506: LD_VAR 0 2
37510: PPUSH
37511: LD_EXP 112
37515: PUSH
37516: LD_VAR 0 2
37520: ARRAY
37521: PPUSH
37522: LD_INT 2
37524: PUSH
37525: LD_INT 30
37527: PUSH
37528: LD_INT 32
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 30
37537: PUSH
37538: LD_INT 31
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 58
37552: PUSH
37553: EMPTY
37554: LIST
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PPUSH
37560: CALL_OW 72
37564: PPUSH
37565: CALL_OW 1
37569: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37570: LD_ADDR_EXP 122
37574: PUSH
37575: LD_EXP 122
37579: PPUSH
37580: LD_VAR 0 2
37584: PPUSH
37585: EMPTY
37586: PPUSH
37587: CALL_OW 1
37591: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37592: LD_ADDR_EXP 126
37596: PUSH
37597: LD_EXP 126
37601: PPUSH
37602: LD_VAR 0 2
37606: PPUSH
37607: EMPTY
37608: PPUSH
37609: CALL_OW 1
37613: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37614: LD_ADDR_EXP 125
37618: PUSH
37619: LD_EXP 125
37623: PPUSH
37624: LD_VAR 0 2
37628: PPUSH
37629: EMPTY
37630: PPUSH
37631: CALL_OW 1
37635: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37636: LD_ADDR_EXP 127
37640: PUSH
37641: LD_EXP 127
37645: PPUSH
37646: LD_VAR 0 2
37650: PPUSH
37651: EMPTY
37652: PPUSH
37653: CALL_OW 1
37657: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37658: LD_ADDR_EXP 128
37662: PUSH
37663: LD_EXP 128
37667: PPUSH
37668: LD_VAR 0 2
37672: PPUSH
37673: EMPTY
37674: PPUSH
37675: CALL_OW 1
37679: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37680: LD_ADDR_EXP 129
37684: PUSH
37685: LD_EXP 129
37689: PPUSH
37690: LD_VAR 0 2
37694: PPUSH
37695: EMPTY
37696: PPUSH
37697: CALL_OW 1
37701: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37702: LD_ADDR_EXP 130
37706: PUSH
37707: LD_EXP 130
37711: PPUSH
37712: LD_VAR 0 2
37716: PPUSH
37717: EMPTY
37718: PPUSH
37719: CALL_OW 1
37723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37724: LD_ADDR_EXP 131
37728: PUSH
37729: LD_EXP 131
37733: PPUSH
37734: LD_VAR 0 2
37738: PPUSH
37739: EMPTY
37740: PPUSH
37741: CALL_OW 1
37745: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37746: LD_ADDR_EXP 132
37750: PUSH
37751: LD_EXP 132
37755: PPUSH
37756: LD_VAR 0 2
37760: PPUSH
37761: EMPTY
37762: PPUSH
37763: CALL_OW 1
37767: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37768: LD_ADDR_EXP 133
37772: PUSH
37773: LD_EXP 133
37777: PPUSH
37778: LD_VAR 0 2
37782: PPUSH
37783: EMPTY
37784: PPUSH
37785: CALL_OW 1
37789: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37790: LD_ADDR_EXP 134
37794: PUSH
37795: LD_EXP 134
37799: PPUSH
37800: LD_VAR 0 2
37804: PPUSH
37805: EMPTY
37806: PPUSH
37807: CALL_OW 1
37811: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37812: LD_ADDR_EXP 123
37816: PUSH
37817: LD_EXP 123
37821: PPUSH
37822: LD_VAR 0 2
37826: PPUSH
37827: LD_INT 0
37829: PPUSH
37830: CALL_OW 1
37834: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37835: LD_ADDR_EXP 136
37839: PUSH
37840: LD_EXP 136
37844: PPUSH
37845: LD_VAR 0 2
37849: PPUSH
37850: LD_INT 0
37852: PPUSH
37853: CALL_OW 1
37857: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37858: LD_ADDR_EXP 124
37862: PUSH
37863: LD_EXP 124
37867: PPUSH
37868: LD_VAR 0 2
37872: PPUSH
37873: EMPTY
37874: PPUSH
37875: CALL_OW 1
37879: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37880: LD_ADDR_EXP 135
37884: PUSH
37885: LD_EXP 135
37889: PPUSH
37890: LD_VAR 0 2
37894: PPUSH
37895: LD_INT 0
37897: PPUSH
37898: CALL_OW 1
37902: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37903: LD_ADDR_EXP 137
37907: PUSH
37908: LD_EXP 137
37912: PPUSH
37913: LD_VAR 0 2
37917: PPUSH
37918: EMPTY
37919: PPUSH
37920: CALL_OW 1
37924: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37925: LD_ADDR_EXP 140
37929: PUSH
37930: LD_EXP 140
37934: PPUSH
37935: LD_VAR 0 2
37939: PPUSH
37940: LD_INT 0
37942: PPUSH
37943: CALL_OW 1
37947: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37948: LD_ADDR_EXP 141
37952: PUSH
37953: LD_EXP 141
37957: PPUSH
37958: LD_VAR 0 2
37962: PPUSH
37963: EMPTY
37964: PPUSH
37965: CALL_OW 1
37969: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37970: LD_ADDR_EXP 142
37974: PUSH
37975: LD_EXP 142
37979: PPUSH
37980: LD_VAR 0 2
37984: PPUSH
37985: EMPTY
37986: PPUSH
37987: CALL_OW 1
37991: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37992: LD_ADDR_EXP 143
37996: PUSH
37997: LD_EXP 143
38001: PPUSH
38002: LD_VAR 0 2
38006: PPUSH
38007: EMPTY
38008: PPUSH
38009: CALL_OW 1
38013: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38014: LD_ADDR_EXP 145
38018: PUSH
38019: LD_EXP 145
38023: PPUSH
38024: LD_VAR 0 2
38028: PPUSH
38029: LD_EXP 112
38033: PUSH
38034: LD_VAR 0 2
38038: ARRAY
38039: PPUSH
38040: LD_INT 2
38042: PUSH
38043: LD_INT 30
38045: PUSH
38046: LD_INT 6
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 30
38055: PUSH
38056: LD_INT 7
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 30
38065: PUSH
38066: LD_INT 8
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: PPUSH
38079: CALL_OW 72
38083: PPUSH
38084: CALL_OW 1
38088: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38089: LD_ADDR_EXP 146
38093: PUSH
38094: LD_EXP 146
38098: PPUSH
38099: LD_VAR 0 2
38103: PPUSH
38104: EMPTY
38105: PPUSH
38106: CALL_OW 1
38110: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38111: LD_ADDR_EXP 147
38115: PUSH
38116: LD_EXP 147
38120: PPUSH
38121: LD_VAR 0 2
38125: PPUSH
38126: EMPTY
38127: PPUSH
38128: CALL_OW 1
38132: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38133: LD_ADDR_EXP 148
38137: PUSH
38138: LD_EXP 148
38142: PPUSH
38143: LD_VAR 0 2
38147: PPUSH
38148: EMPTY
38149: PPUSH
38150: CALL_OW 1
38154: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38155: LD_ADDR_EXP 149
38159: PUSH
38160: LD_EXP 149
38164: PPUSH
38165: LD_VAR 0 2
38169: PPUSH
38170: EMPTY
38171: PPUSH
38172: CALL_OW 1
38176: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38177: LD_ADDR_EXP 150
38181: PUSH
38182: LD_EXP 150
38186: PPUSH
38187: LD_VAR 0 2
38191: PPUSH
38192: EMPTY
38193: PPUSH
38194: CALL_OW 1
38198: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38199: LD_ADDR_EXP 151
38203: PUSH
38204: LD_EXP 151
38208: PPUSH
38209: LD_VAR 0 2
38213: PPUSH
38214: EMPTY
38215: PPUSH
38216: CALL_OW 1
38220: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38221: LD_ADDR_EXP 152
38225: PUSH
38226: LD_EXP 152
38230: PPUSH
38231: LD_VAR 0 2
38235: PPUSH
38236: EMPTY
38237: PPUSH
38238: CALL_OW 1
38242: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38243: LD_ADDR_EXP 153
38247: PUSH
38248: LD_EXP 153
38252: PPUSH
38253: LD_VAR 0 2
38257: PPUSH
38258: EMPTY
38259: PPUSH
38260: CALL_OW 1
38264: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38265: LD_ADDR_EXP 154
38269: PUSH
38270: LD_EXP 154
38274: PPUSH
38275: LD_VAR 0 2
38279: PPUSH
38280: LD_INT 0
38282: PPUSH
38283: CALL_OW 1
38287: ST_TO_ADDR
// end ;
38288: GO 37212
38290: POP
38291: POP
// MC_InitSides ( ) ;
38292: CALL 38578 0 0
// MC_InitResearch ( ) ;
38296: CALL 38317 0 0
// CustomInitMacro ( ) ;
38300: CALL 467 0 0
// skirmish := true ;
38304: LD_ADDR_EXP 110
38308: PUSH
38309: LD_INT 1
38311: ST_TO_ADDR
// end ;
38312: LD_VAR 0 1
38316: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38317: LD_INT 0
38319: PPUSH
38320: PPUSH
38321: PPUSH
38322: PPUSH
38323: PPUSH
38324: PPUSH
// if not mc_bases then
38325: LD_EXP 112
38329: NOT
38330: IFFALSE 38334
// exit ;
38332: GO 38573
// for i = 1 to 8 do
38334: LD_ADDR_VAR 0 2
38338: PUSH
38339: DOUBLE
38340: LD_INT 1
38342: DEC
38343: ST_TO_ADDR
38344: LD_INT 8
38346: PUSH
38347: FOR_TO
38348: IFFALSE 38374
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38350: LD_ADDR_EXP 139
38354: PUSH
38355: LD_EXP 139
38359: PPUSH
38360: LD_VAR 0 2
38364: PPUSH
38365: EMPTY
38366: PPUSH
38367: CALL_OW 1
38371: ST_TO_ADDR
38372: GO 38347
38374: POP
38375: POP
// tmp := [ ] ;
38376: LD_ADDR_VAR 0 5
38380: PUSH
38381: EMPTY
38382: ST_TO_ADDR
// for i = 1 to mc_sides do
38383: LD_ADDR_VAR 0 2
38387: PUSH
38388: DOUBLE
38389: LD_INT 1
38391: DEC
38392: ST_TO_ADDR
38393: LD_EXP 138
38397: PUSH
38398: FOR_TO
38399: IFFALSE 38457
// if not mc_sides [ i ] in tmp then
38401: LD_EXP 138
38405: PUSH
38406: LD_VAR 0 2
38410: ARRAY
38411: PUSH
38412: LD_VAR 0 5
38416: IN
38417: NOT
38418: IFFALSE 38455
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38420: LD_ADDR_VAR 0 5
38424: PUSH
38425: LD_VAR 0 5
38429: PPUSH
38430: LD_VAR 0 5
38434: PUSH
38435: LD_INT 1
38437: PLUS
38438: PPUSH
38439: LD_EXP 138
38443: PUSH
38444: LD_VAR 0 2
38448: ARRAY
38449: PPUSH
38450: CALL_OW 2
38454: ST_TO_ADDR
38455: GO 38398
38457: POP
38458: POP
// if not tmp then
38459: LD_VAR 0 5
38463: NOT
38464: IFFALSE 38468
// exit ;
38466: GO 38573
// for j in tmp do
38468: LD_ADDR_VAR 0 3
38472: PUSH
38473: LD_VAR 0 5
38477: PUSH
38478: FOR_IN
38479: IFFALSE 38571
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38481: LD_ADDR_VAR 0 6
38485: PUSH
38486: LD_INT 22
38488: PUSH
38489: LD_VAR 0 3
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PPUSH
38498: CALL_OW 69
38502: ST_TO_ADDR
// if not un then
38503: LD_VAR 0 6
38507: NOT
38508: IFFALSE 38512
// continue ;
38510: GO 38478
// nation := GetNation ( un [ 1 ] ) ;
38512: LD_ADDR_VAR 0 4
38516: PUSH
38517: LD_VAR 0 6
38521: PUSH
38522: LD_INT 1
38524: ARRAY
38525: PPUSH
38526: CALL_OW 248
38530: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38531: LD_ADDR_EXP 139
38535: PUSH
38536: LD_EXP 139
38540: PPUSH
38541: LD_VAR 0 3
38545: PPUSH
38546: LD_VAR 0 3
38550: PPUSH
38551: LD_VAR 0 4
38555: PPUSH
38556: LD_INT 1
38558: PPUSH
38559: CALL 65167 0 3
38563: PPUSH
38564: CALL_OW 1
38568: ST_TO_ADDR
// end ;
38569: GO 38478
38571: POP
38572: POP
// end ;
38573: LD_VAR 0 1
38577: RET
// export function MC_InitSides ( ) ; var i ; begin
38578: LD_INT 0
38580: PPUSH
38581: PPUSH
// if not mc_bases then
38582: LD_EXP 112
38586: NOT
38587: IFFALSE 38591
// exit ;
38589: GO 38665
// for i = 1 to mc_bases do
38591: LD_ADDR_VAR 0 2
38595: PUSH
38596: DOUBLE
38597: LD_INT 1
38599: DEC
38600: ST_TO_ADDR
38601: LD_EXP 112
38605: PUSH
38606: FOR_TO
38607: IFFALSE 38663
// if mc_bases [ i ] then
38609: LD_EXP 112
38613: PUSH
38614: LD_VAR 0 2
38618: ARRAY
38619: IFFALSE 38661
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38621: LD_ADDR_EXP 138
38625: PUSH
38626: LD_EXP 138
38630: PPUSH
38631: LD_VAR 0 2
38635: PPUSH
38636: LD_EXP 112
38640: PUSH
38641: LD_VAR 0 2
38645: ARRAY
38646: PUSH
38647: LD_INT 1
38649: ARRAY
38650: PPUSH
38651: CALL_OW 255
38655: PPUSH
38656: CALL_OW 1
38660: ST_TO_ADDR
38661: GO 38606
38663: POP
38664: POP
// end ;
38665: LD_VAR 0 1
38669: RET
// every 0 0$01 trigger skirmish do
38670: LD_EXP 110
38674: IFFALSE 38828
38676: GO 38678
38678: DISABLE
// begin enable ;
38679: ENABLE
// MC_CheckBuildings ( ) ;
38680: CALL 43326 0 0
// MC_CheckPeopleLife ( ) ;
38684: CALL 43451 0 0
// RaiseSailEvent ( 100 ) ;
38688: LD_INT 100
38690: PPUSH
38691: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38695: LD_INT 103
38697: PPUSH
38698: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38702: LD_INT 104
38704: PPUSH
38705: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38709: LD_INT 105
38711: PPUSH
38712: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38716: LD_INT 106
38718: PPUSH
38719: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38723: LD_INT 107
38725: PPUSH
38726: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38730: LD_INT 108
38732: PPUSH
38733: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38737: LD_INT 109
38739: PPUSH
38740: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38744: LD_INT 110
38746: PPUSH
38747: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38751: LD_INT 111
38753: PPUSH
38754: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38758: LD_INT 112
38760: PPUSH
38761: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38765: LD_INT 113
38767: PPUSH
38768: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38772: LD_INT 120
38774: PPUSH
38775: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38779: LD_INT 121
38781: PPUSH
38782: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38786: LD_INT 122
38788: PPUSH
38789: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38793: LD_INT 123
38795: PPUSH
38796: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38800: LD_INT 124
38802: PPUSH
38803: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38807: LD_INT 125
38809: PPUSH
38810: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38814: LD_INT 126
38816: PPUSH
38817: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38821: LD_INT 200
38823: PPUSH
38824: CALL_OW 427
// end ;
38828: END
// on SailEvent ( event ) do begin if event < 100 then
38829: LD_VAR 0 1
38833: PUSH
38834: LD_INT 100
38836: LESS
38837: IFFALSE 38848
// CustomEvent ( event ) ;
38839: LD_VAR 0 1
38843: PPUSH
38844: CALL 33403 0 1
// if event = 100 then
38848: LD_VAR 0 1
38852: PUSH
38853: LD_INT 100
38855: EQUAL
38856: IFFALSE 38862
// MC_ClassManager ( ) ;
38858: CALL 39254 0 0
// if event = 101 then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_INT 101
38869: EQUAL
38870: IFFALSE 38876
// MC_RepairBuildings ( ) ;
38872: CALL 44036 0 0
// if event = 102 then
38876: LD_VAR 0 1
38880: PUSH
38881: LD_INT 102
38883: EQUAL
38884: IFFALSE 38890
// MC_Heal ( ) ;
38886: CALL 44895 0 0
// if event = 103 then
38890: LD_VAR 0 1
38894: PUSH
38895: LD_INT 103
38897: EQUAL
38898: IFFALSE 38904
// MC_Build ( ) ;
38900: CALL 45317 0 0
// if event = 104 then
38904: LD_VAR 0 1
38908: PUSH
38909: LD_INT 104
38911: EQUAL
38912: IFFALSE 38918
// MC_TurretWeapon ( ) ;
38914: CALL 46930 0 0
// if event = 105 then
38918: LD_VAR 0 1
38922: PUSH
38923: LD_INT 105
38925: EQUAL
38926: IFFALSE 38932
// MC_BuildUpgrade ( ) ;
38928: CALL 46481 0 0
// if event = 106 then
38932: LD_VAR 0 1
38936: PUSH
38937: LD_INT 106
38939: EQUAL
38940: IFFALSE 38946
// MC_PlantMines ( ) ;
38942: CALL 47360 0 0
// if event = 107 then
38946: LD_VAR 0 1
38950: PUSH
38951: LD_INT 107
38953: EQUAL
38954: IFFALSE 38960
// MC_CollectCrates ( ) ;
38956: CALL 48158 0 0
// if event = 108 then
38960: LD_VAR 0 1
38964: PUSH
38965: LD_INT 108
38967: EQUAL
38968: IFFALSE 38974
// MC_LinkRemoteControl ( ) ;
38970: CALL 49934 0 0
// if event = 109 then
38974: LD_VAR 0 1
38978: PUSH
38979: LD_INT 109
38981: EQUAL
38982: IFFALSE 38988
// MC_ProduceVehicle ( ) ;
38984: CALL 50115 0 0
// if event = 110 then
38988: LD_VAR 0 1
38992: PUSH
38993: LD_INT 110
38995: EQUAL
38996: IFFALSE 39002
// MC_SendAttack ( ) ;
38998: CALL 50581 0 0
// if event = 111 then
39002: LD_VAR 0 1
39006: PUSH
39007: LD_INT 111
39009: EQUAL
39010: IFFALSE 39016
// MC_Defend ( ) ;
39012: CALL 50689 0 0
// if event = 112 then
39016: LD_VAR 0 1
39020: PUSH
39021: LD_INT 112
39023: EQUAL
39024: IFFALSE 39030
// MC_Research ( ) ;
39026: CALL 51294 0 0
// if event = 113 then
39030: LD_VAR 0 1
39034: PUSH
39035: LD_INT 113
39037: EQUAL
39038: IFFALSE 39044
// MC_MinesTrigger ( ) ;
39040: CALL 52408 0 0
// if event = 120 then
39044: LD_VAR 0 1
39048: PUSH
39049: LD_INT 120
39051: EQUAL
39052: IFFALSE 39058
// MC_RepairVehicle ( ) ;
39054: CALL 52507 0 0
// if event = 121 then
39058: LD_VAR 0 1
39062: PUSH
39063: LD_INT 121
39065: EQUAL
39066: IFFALSE 39072
// MC_TameApe ( ) ;
39068: CALL 53237 0 0
// if event = 122 then
39072: LD_VAR 0 1
39076: PUSH
39077: LD_INT 122
39079: EQUAL
39080: IFFALSE 39086
// MC_ChangeApeClass ( ) ;
39082: CALL 54066 0 0
// if event = 123 then
39086: LD_VAR 0 1
39090: PUSH
39091: LD_INT 123
39093: EQUAL
39094: IFFALSE 39100
// MC_Bazooka ( ) ;
39096: CALL 54716 0 0
// if event = 124 then
39100: LD_VAR 0 1
39104: PUSH
39105: LD_INT 124
39107: EQUAL
39108: IFFALSE 39114
// MC_TeleportExit ( ) ;
39110: CALL 54914 0 0
// if event = 125 then
39114: LD_VAR 0 1
39118: PUSH
39119: LD_INT 125
39121: EQUAL
39122: IFFALSE 39128
// MC_Deposits ( ) ;
39124: CALL 55561 0 0
// if event = 126 then
39128: LD_VAR 0 1
39132: PUSH
39133: LD_INT 126
39135: EQUAL
39136: IFFALSE 39142
// MC_RemoteDriver ( ) ;
39138: CALL 56186 0 0
// if event = 200 then
39142: LD_VAR 0 1
39146: PUSH
39147: LD_INT 200
39149: EQUAL
39150: IFFALSE 39156
// MC_Idle ( ) ;
39152: CALL 58135 0 0
// end ;
39156: PPOPN 1
39158: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39159: LD_INT 0
39161: PPUSH
39162: PPUSH
// if not mc_bases [ base ] or not tag then
39163: LD_EXP 112
39167: PUSH
39168: LD_VAR 0 1
39172: ARRAY
39173: NOT
39174: PUSH
39175: LD_VAR 0 2
39179: NOT
39180: OR
39181: IFFALSE 39185
// exit ;
39183: GO 39249
// for i in mc_bases [ base ] union mc_ape [ base ] do
39185: LD_ADDR_VAR 0 4
39189: PUSH
39190: LD_EXP 112
39194: PUSH
39195: LD_VAR 0 1
39199: ARRAY
39200: PUSH
39201: LD_EXP 141
39205: PUSH
39206: LD_VAR 0 1
39210: ARRAY
39211: UNION
39212: PUSH
39213: FOR_IN
39214: IFFALSE 39247
// if GetTag ( i ) = tag then
39216: LD_VAR 0 4
39220: PPUSH
39221: CALL_OW 110
39225: PUSH
39226: LD_VAR 0 2
39230: EQUAL
39231: IFFALSE 39245
// SetTag ( i , 0 ) ;
39233: LD_VAR 0 4
39237: PPUSH
39238: LD_INT 0
39240: PPUSH
39241: CALL_OW 109
39245: GO 39213
39247: POP
39248: POP
// end ;
39249: LD_VAR 0 3
39253: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39254: LD_INT 0
39256: PPUSH
39257: PPUSH
39258: PPUSH
39259: PPUSH
39260: PPUSH
39261: PPUSH
39262: PPUSH
39263: PPUSH
// if not mc_bases then
39264: LD_EXP 112
39268: NOT
39269: IFFALSE 39273
// exit ;
39271: GO 39731
// for i = 1 to mc_bases do
39273: LD_ADDR_VAR 0 2
39277: PUSH
39278: DOUBLE
39279: LD_INT 1
39281: DEC
39282: ST_TO_ADDR
39283: LD_EXP 112
39287: PUSH
39288: FOR_TO
39289: IFFALSE 39729
// begin tmp := MC_ClassCheckReq ( i ) ;
39291: LD_ADDR_VAR 0 4
39295: PUSH
39296: LD_VAR 0 2
39300: PPUSH
39301: CALL 39736 0 1
39305: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39306: LD_ADDR_EXP 153
39310: PUSH
39311: LD_EXP 153
39315: PPUSH
39316: LD_VAR 0 2
39320: PPUSH
39321: LD_VAR 0 4
39325: PPUSH
39326: CALL_OW 1
39330: ST_TO_ADDR
// if not tmp then
39331: LD_VAR 0 4
39335: NOT
39336: IFFALSE 39340
// continue ;
39338: GO 39288
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39340: LD_ADDR_VAR 0 6
39344: PUSH
39345: LD_EXP 112
39349: PUSH
39350: LD_VAR 0 2
39354: ARRAY
39355: PPUSH
39356: LD_INT 2
39358: PUSH
39359: LD_INT 30
39361: PUSH
39362: LD_INT 4
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 30
39371: PUSH
39372: LD_INT 5
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: LIST
39383: PPUSH
39384: CALL_OW 72
39388: PUSH
39389: LD_EXP 112
39393: PUSH
39394: LD_VAR 0 2
39398: ARRAY
39399: PPUSH
39400: LD_INT 2
39402: PUSH
39403: LD_INT 30
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 30
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: LIST
39427: PPUSH
39428: CALL_OW 72
39432: PUSH
39433: LD_EXP 112
39437: PUSH
39438: LD_VAR 0 2
39442: ARRAY
39443: PPUSH
39444: LD_INT 30
39446: PUSH
39447: LD_INT 3
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PPUSH
39454: CALL_OW 72
39458: PUSH
39459: LD_EXP 112
39463: PUSH
39464: LD_VAR 0 2
39468: ARRAY
39469: PPUSH
39470: LD_INT 2
39472: PUSH
39473: LD_INT 30
39475: PUSH
39476: LD_INT 6
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 30
39485: PUSH
39486: LD_INT 7
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 30
39495: PUSH
39496: LD_INT 8
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: LIST
39507: LIST
39508: PPUSH
39509: CALL_OW 72
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: ST_TO_ADDR
// for j = 1 to 4 do
39520: LD_ADDR_VAR 0 3
39524: PUSH
39525: DOUBLE
39526: LD_INT 1
39528: DEC
39529: ST_TO_ADDR
39530: LD_INT 4
39532: PUSH
39533: FOR_TO
39534: IFFALSE 39725
// begin if not tmp [ j ] then
39536: LD_VAR 0 4
39540: PUSH
39541: LD_VAR 0 3
39545: ARRAY
39546: NOT
39547: IFFALSE 39551
// continue ;
39549: GO 39533
// for p in tmp [ j ] do
39551: LD_ADDR_VAR 0 5
39555: PUSH
39556: LD_VAR 0 4
39560: PUSH
39561: LD_VAR 0 3
39565: ARRAY
39566: PUSH
39567: FOR_IN
39568: IFFALSE 39721
// begin if not b [ j ] then
39570: LD_VAR 0 6
39574: PUSH
39575: LD_VAR 0 3
39579: ARRAY
39580: NOT
39581: IFFALSE 39585
// break ;
39583: GO 39721
// e := 0 ;
39585: LD_ADDR_VAR 0 7
39589: PUSH
39590: LD_INT 0
39592: ST_TO_ADDR
// for k in b [ j ] do
39593: LD_ADDR_VAR 0 8
39597: PUSH
39598: LD_VAR 0 6
39602: PUSH
39603: LD_VAR 0 3
39607: ARRAY
39608: PUSH
39609: FOR_IN
39610: IFFALSE 39637
// if IsNotFull ( k ) then
39612: LD_VAR 0 8
39616: PPUSH
39617: CALL 67316 0 1
39621: IFFALSE 39635
// begin e := k ;
39623: LD_ADDR_VAR 0 7
39627: PUSH
39628: LD_VAR 0 8
39632: ST_TO_ADDR
// break ;
39633: GO 39637
// end ;
39635: GO 39609
39637: POP
39638: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39639: LD_VAR 0 7
39643: PUSH
39644: LD_VAR 0 5
39648: PPUSH
39649: LD_VAR 0 7
39653: PPUSH
39654: CALL 99736 0 2
39658: NOT
39659: AND
39660: IFFALSE 39719
// begin if IsInUnit ( p ) then
39662: LD_VAR 0 5
39666: PPUSH
39667: CALL_OW 310
39671: IFFALSE 39682
// ComExitBuilding ( p ) ;
39673: LD_VAR 0 5
39677: PPUSH
39678: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39682: LD_VAR 0 5
39686: PPUSH
39687: LD_VAR 0 7
39691: PPUSH
39692: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39696: LD_VAR 0 5
39700: PPUSH
39701: LD_VAR 0 3
39705: PPUSH
39706: CALL_OW 183
// AddComExitBuilding ( p ) ;
39710: LD_VAR 0 5
39714: PPUSH
39715: CALL_OW 182
// end ; end ;
39719: GO 39567
39721: POP
39722: POP
// end ;
39723: GO 39533
39725: POP
39726: POP
// end ;
39727: GO 39288
39729: POP
39730: POP
// end ;
39731: LD_VAR 0 1
39735: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39736: LD_INT 0
39738: PPUSH
39739: PPUSH
39740: PPUSH
39741: PPUSH
39742: PPUSH
39743: PPUSH
39744: PPUSH
39745: PPUSH
39746: PPUSH
39747: PPUSH
39748: PPUSH
39749: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39750: LD_VAR 0 1
39754: NOT
39755: PUSH
39756: LD_EXP 112
39760: PUSH
39761: LD_VAR 0 1
39765: ARRAY
39766: NOT
39767: OR
39768: PUSH
39769: LD_EXP 112
39773: PUSH
39774: LD_VAR 0 1
39778: ARRAY
39779: PPUSH
39780: LD_INT 2
39782: PUSH
39783: LD_INT 30
39785: PUSH
39786: LD_INT 0
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 30
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: LIST
39807: PPUSH
39808: CALL_OW 72
39812: NOT
39813: OR
39814: IFFALSE 39818
// exit ;
39816: GO 43321
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39818: LD_ADDR_VAR 0 4
39822: PUSH
39823: LD_EXP 112
39827: PUSH
39828: LD_VAR 0 1
39832: ARRAY
39833: PPUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 25
39839: PUSH
39840: LD_INT 1
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 25
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 25
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 25
39869: PUSH
39870: LD_INT 4
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 25
39879: PUSH
39880: LD_INT 5
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 25
39889: PUSH
39890: LD_INT 8
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 25
39899: PUSH
39900: LD_INT 9
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: PPUSH
39917: CALL_OW 72
39921: ST_TO_ADDR
// if not tmp then
39922: LD_VAR 0 4
39926: NOT
39927: IFFALSE 39931
// exit ;
39929: GO 43321
// for i in tmp do
39931: LD_ADDR_VAR 0 3
39935: PUSH
39936: LD_VAR 0 4
39940: PUSH
39941: FOR_IN
39942: IFFALSE 39973
// if GetTag ( i ) then
39944: LD_VAR 0 3
39948: PPUSH
39949: CALL_OW 110
39953: IFFALSE 39971
// tmp := tmp diff i ;
39955: LD_ADDR_VAR 0 4
39959: PUSH
39960: LD_VAR 0 4
39964: PUSH
39965: LD_VAR 0 3
39969: DIFF
39970: ST_TO_ADDR
39971: GO 39941
39973: POP
39974: POP
// if not tmp then
39975: LD_VAR 0 4
39979: NOT
39980: IFFALSE 39984
// exit ;
39982: GO 43321
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39984: LD_ADDR_VAR 0 5
39988: PUSH
39989: LD_EXP 112
39993: PUSH
39994: LD_VAR 0 1
39998: ARRAY
39999: PPUSH
40000: LD_INT 2
40002: PUSH
40003: LD_INT 25
40005: PUSH
40006: LD_INT 1
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 25
40015: PUSH
40016: LD_INT 5
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 25
40025: PUSH
40026: LD_INT 8
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 25
40035: PUSH
40036: LD_INT 9
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: PPUSH
40050: CALL_OW 72
40054: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40055: LD_ADDR_VAR 0 6
40059: PUSH
40060: LD_EXP 112
40064: PUSH
40065: LD_VAR 0 1
40069: ARRAY
40070: PPUSH
40071: LD_INT 25
40073: PUSH
40074: LD_INT 2
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PPUSH
40081: CALL_OW 72
40085: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40086: LD_ADDR_VAR 0 7
40090: PUSH
40091: LD_EXP 112
40095: PUSH
40096: LD_VAR 0 1
40100: ARRAY
40101: PPUSH
40102: LD_INT 25
40104: PUSH
40105: LD_INT 3
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PPUSH
40112: CALL_OW 72
40116: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40117: LD_ADDR_VAR 0 8
40121: PUSH
40122: LD_EXP 112
40126: PUSH
40127: LD_VAR 0 1
40131: ARRAY
40132: PPUSH
40133: LD_INT 25
40135: PUSH
40136: LD_INT 4
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 24
40145: PUSH
40146: LD_INT 251
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PPUSH
40157: CALL_OW 72
40161: ST_TO_ADDR
// if mc_scan [ base ] then
40162: LD_EXP 135
40166: PUSH
40167: LD_VAR 0 1
40171: ARRAY
40172: IFFALSE 40633
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40174: LD_ADDR_EXP 154
40178: PUSH
40179: LD_EXP 154
40183: PPUSH
40184: LD_VAR 0 1
40188: PPUSH
40189: LD_INT 4
40191: PPUSH
40192: CALL_OW 1
40196: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40197: LD_ADDR_VAR 0 12
40201: PUSH
40202: LD_EXP 112
40206: PUSH
40207: LD_VAR 0 1
40211: ARRAY
40212: PPUSH
40213: LD_INT 2
40215: PUSH
40216: LD_INT 30
40218: PUSH
40219: LD_INT 4
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 30
40228: PUSH
40229: LD_INT 5
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: LIST
40240: PPUSH
40241: CALL_OW 72
40245: ST_TO_ADDR
// if not b then
40246: LD_VAR 0 12
40250: NOT
40251: IFFALSE 40255
// exit ;
40253: GO 43321
// p := [ ] ;
40255: LD_ADDR_VAR 0 11
40259: PUSH
40260: EMPTY
40261: ST_TO_ADDR
// if sci >= 2 then
40262: LD_VAR 0 8
40266: PUSH
40267: LD_INT 2
40269: GREATEREQUAL
40270: IFFALSE 40301
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40272: LD_ADDR_VAR 0 8
40276: PUSH
40277: LD_VAR 0 8
40281: PUSH
40282: LD_INT 1
40284: ARRAY
40285: PUSH
40286: LD_VAR 0 8
40290: PUSH
40291: LD_INT 2
40293: ARRAY
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: ST_TO_ADDR
40299: GO 40362
// if sci = 1 then
40301: LD_VAR 0 8
40305: PUSH
40306: LD_INT 1
40308: EQUAL
40309: IFFALSE 40330
// sci := [ sci [ 1 ] ] else
40311: LD_ADDR_VAR 0 8
40315: PUSH
40316: LD_VAR 0 8
40320: PUSH
40321: LD_INT 1
40323: ARRAY
40324: PUSH
40325: EMPTY
40326: LIST
40327: ST_TO_ADDR
40328: GO 40362
// if sci = 0 then
40330: LD_VAR 0 8
40334: PUSH
40335: LD_INT 0
40337: EQUAL
40338: IFFALSE 40362
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40340: LD_ADDR_VAR 0 11
40344: PUSH
40345: LD_VAR 0 4
40349: PPUSH
40350: LD_INT 4
40352: PPUSH
40353: CALL 99599 0 2
40357: PUSH
40358: LD_INT 1
40360: ARRAY
40361: ST_TO_ADDR
// if eng > 4 then
40362: LD_VAR 0 6
40366: PUSH
40367: LD_INT 4
40369: GREATER
40370: IFFALSE 40416
// for i = eng downto 4 do
40372: LD_ADDR_VAR 0 3
40376: PUSH
40377: DOUBLE
40378: LD_VAR 0 6
40382: INC
40383: ST_TO_ADDR
40384: LD_INT 4
40386: PUSH
40387: FOR_DOWNTO
40388: IFFALSE 40414
// eng := eng diff eng [ i ] ;
40390: LD_ADDR_VAR 0 6
40394: PUSH
40395: LD_VAR 0 6
40399: PUSH
40400: LD_VAR 0 6
40404: PUSH
40405: LD_VAR 0 3
40409: ARRAY
40410: DIFF
40411: ST_TO_ADDR
40412: GO 40387
40414: POP
40415: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40416: LD_ADDR_VAR 0 4
40420: PUSH
40421: LD_VAR 0 4
40425: PUSH
40426: LD_VAR 0 5
40430: PUSH
40431: LD_VAR 0 6
40435: UNION
40436: PUSH
40437: LD_VAR 0 7
40441: UNION
40442: PUSH
40443: LD_VAR 0 8
40447: UNION
40448: DIFF
40449: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40450: LD_ADDR_VAR 0 13
40454: PUSH
40455: LD_EXP 112
40459: PUSH
40460: LD_VAR 0 1
40464: ARRAY
40465: PPUSH
40466: LD_INT 2
40468: PUSH
40469: LD_INT 30
40471: PUSH
40472: LD_INT 32
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 30
40481: PUSH
40482: LD_INT 31
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: LIST
40493: PPUSH
40494: CALL_OW 72
40498: PUSH
40499: LD_EXP 112
40503: PUSH
40504: LD_VAR 0 1
40508: ARRAY
40509: PPUSH
40510: LD_INT 2
40512: PUSH
40513: LD_INT 30
40515: PUSH
40516: LD_INT 4
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 30
40525: PUSH
40526: LD_INT 5
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: PPUSH
40538: CALL_OW 72
40542: PUSH
40543: LD_INT 6
40545: MUL
40546: PLUS
40547: ST_TO_ADDR
// if bcount < tmp then
40548: LD_VAR 0 13
40552: PUSH
40553: LD_VAR 0 4
40557: LESS
40558: IFFALSE 40604
// for i = tmp downto bcount do
40560: LD_ADDR_VAR 0 3
40564: PUSH
40565: DOUBLE
40566: LD_VAR 0 4
40570: INC
40571: ST_TO_ADDR
40572: LD_VAR 0 13
40576: PUSH
40577: FOR_DOWNTO
40578: IFFALSE 40602
// tmp := Delete ( tmp , tmp ) ;
40580: LD_ADDR_VAR 0 4
40584: PUSH
40585: LD_VAR 0 4
40589: PPUSH
40590: LD_VAR 0 4
40594: PPUSH
40595: CALL_OW 3
40599: ST_TO_ADDR
40600: GO 40577
40602: POP
40603: POP
// result := [ tmp , 0 , 0 , p ] ;
40604: LD_ADDR_VAR 0 2
40608: PUSH
40609: LD_VAR 0 4
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: LD_VAR 0 11
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: ST_TO_ADDR
// exit ;
40631: GO 43321
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40633: LD_EXP 112
40637: PUSH
40638: LD_VAR 0 1
40642: ARRAY
40643: PPUSH
40644: LD_INT 2
40646: PUSH
40647: LD_INT 30
40649: PUSH
40650: LD_INT 6
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 30
40659: PUSH
40660: LD_INT 7
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 30
40669: PUSH
40670: LD_INT 8
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: PPUSH
40683: CALL_OW 72
40687: NOT
40688: PUSH
40689: LD_EXP 112
40693: PUSH
40694: LD_VAR 0 1
40698: ARRAY
40699: PPUSH
40700: LD_INT 30
40702: PUSH
40703: LD_INT 3
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PPUSH
40710: CALL_OW 72
40714: NOT
40715: AND
40716: IFFALSE 40788
// begin if eng = tmp then
40718: LD_VAR 0 6
40722: PUSH
40723: LD_VAR 0 4
40727: EQUAL
40728: IFFALSE 40732
// exit ;
40730: GO 43321
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40732: LD_ADDR_EXP 154
40736: PUSH
40737: LD_EXP 154
40741: PPUSH
40742: LD_VAR 0 1
40746: PPUSH
40747: LD_INT 1
40749: PPUSH
40750: CALL_OW 1
40754: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40755: LD_ADDR_VAR 0 2
40759: PUSH
40760: LD_INT 0
40762: PUSH
40763: LD_VAR 0 4
40767: PUSH
40768: LD_VAR 0 6
40772: DIFF
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: LD_INT 0
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: ST_TO_ADDR
// exit ;
40786: GO 43321
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40788: LD_EXP 139
40792: PUSH
40793: LD_EXP 138
40797: PUSH
40798: LD_VAR 0 1
40802: ARRAY
40803: ARRAY
40804: PUSH
40805: LD_EXP 112
40809: PUSH
40810: LD_VAR 0 1
40814: ARRAY
40815: PPUSH
40816: LD_INT 2
40818: PUSH
40819: LD_INT 30
40821: PUSH
40822: LD_INT 6
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 30
40831: PUSH
40832: LD_INT 7
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 30
40841: PUSH
40842: LD_INT 8
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: LIST
40853: LIST
40854: PPUSH
40855: CALL_OW 72
40859: AND
40860: PUSH
40861: LD_EXP 112
40865: PUSH
40866: LD_VAR 0 1
40870: ARRAY
40871: PPUSH
40872: LD_INT 30
40874: PUSH
40875: LD_INT 3
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PPUSH
40882: CALL_OW 72
40886: NOT
40887: AND
40888: IFFALSE 41102
// begin if sci >= 6 then
40890: LD_VAR 0 8
40894: PUSH
40895: LD_INT 6
40897: GREATEREQUAL
40898: IFFALSE 40902
// exit ;
40900: GO 43321
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40902: LD_ADDR_EXP 154
40906: PUSH
40907: LD_EXP 154
40911: PPUSH
40912: LD_VAR 0 1
40916: PPUSH
40917: LD_INT 2
40919: PPUSH
40920: CALL_OW 1
40924: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40925: LD_ADDR_VAR 0 9
40929: PUSH
40930: LD_VAR 0 4
40934: PUSH
40935: LD_VAR 0 8
40939: DIFF
40940: PPUSH
40941: LD_INT 4
40943: PPUSH
40944: CALL 99599 0 2
40948: ST_TO_ADDR
// p := [ ] ;
40949: LD_ADDR_VAR 0 11
40953: PUSH
40954: EMPTY
40955: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40956: LD_VAR 0 8
40960: PUSH
40961: LD_INT 6
40963: LESS
40964: PUSH
40965: LD_VAR 0 9
40969: PUSH
40970: LD_INT 6
40972: GREATER
40973: AND
40974: IFFALSE 41055
// begin for i = 1 to 6 - sci do
40976: LD_ADDR_VAR 0 3
40980: PUSH
40981: DOUBLE
40982: LD_INT 1
40984: DEC
40985: ST_TO_ADDR
40986: LD_INT 6
40988: PUSH
40989: LD_VAR 0 8
40993: MINUS
40994: PUSH
40995: FOR_TO
40996: IFFALSE 41051
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40998: LD_ADDR_VAR 0 11
41002: PUSH
41003: LD_VAR 0 11
41007: PPUSH
41008: LD_VAR 0 11
41012: PUSH
41013: LD_INT 1
41015: PLUS
41016: PPUSH
41017: LD_VAR 0 9
41021: PUSH
41022: LD_INT 1
41024: ARRAY
41025: PPUSH
41026: CALL_OW 2
41030: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41031: LD_ADDR_VAR 0 9
41035: PUSH
41036: LD_VAR 0 9
41040: PPUSH
41041: LD_INT 1
41043: PPUSH
41044: CALL_OW 3
41048: ST_TO_ADDR
// end ;
41049: GO 40995
41051: POP
41052: POP
// end else
41053: GO 41075
// if sort then
41055: LD_VAR 0 9
41059: IFFALSE 41075
// p := sort [ 1 ] ;
41061: LD_ADDR_VAR 0 11
41065: PUSH
41066: LD_VAR 0 9
41070: PUSH
41071: LD_INT 1
41073: ARRAY
41074: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41075: LD_ADDR_VAR 0 2
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: LD_INT 0
41085: PUSH
41086: LD_INT 0
41088: PUSH
41089: LD_VAR 0 11
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: ST_TO_ADDR
// exit ;
41100: GO 43321
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41102: LD_EXP 139
41106: PUSH
41107: LD_EXP 138
41111: PUSH
41112: LD_VAR 0 1
41116: ARRAY
41117: ARRAY
41118: PUSH
41119: LD_EXP 112
41123: PUSH
41124: LD_VAR 0 1
41128: ARRAY
41129: PPUSH
41130: LD_INT 2
41132: PUSH
41133: LD_INT 30
41135: PUSH
41136: LD_INT 6
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 30
41145: PUSH
41146: LD_INT 7
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 30
41155: PUSH
41156: LD_INT 8
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: PPUSH
41169: CALL_OW 72
41173: AND
41174: PUSH
41175: LD_EXP 112
41179: PUSH
41180: LD_VAR 0 1
41184: ARRAY
41185: PPUSH
41186: LD_INT 30
41188: PUSH
41189: LD_INT 3
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PPUSH
41196: CALL_OW 72
41200: AND
41201: IFFALSE 41935
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41203: LD_ADDR_EXP 154
41207: PUSH
41208: LD_EXP 154
41212: PPUSH
41213: LD_VAR 0 1
41217: PPUSH
41218: LD_INT 3
41220: PPUSH
41221: CALL_OW 1
41225: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41226: LD_ADDR_VAR 0 2
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: LD_INT 0
41236: PUSH
41237: LD_INT 0
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: ST_TO_ADDR
// if not eng then
41249: LD_VAR 0 6
41253: NOT
41254: IFFALSE 41317
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41256: LD_ADDR_VAR 0 11
41260: PUSH
41261: LD_VAR 0 4
41265: PPUSH
41266: LD_INT 2
41268: PPUSH
41269: CALL 99599 0 2
41273: PUSH
41274: LD_INT 1
41276: ARRAY
41277: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41278: LD_ADDR_VAR 0 2
41282: PUSH
41283: LD_VAR 0 2
41287: PPUSH
41288: LD_INT 2
41290: PPUSH
41291: LD_VAR 0 11
41295: PPUSH
41296: CALL_OW 1
41300: ST_TO_ADDR
// tmp := tmp diff p ;
41301: LD_ADDR_VAR 0 4
41305: PUSH
41306: LD_VAR 0 4
41310: PUSH
41311: LD_VAR 0 11
41315: DIFF
41316: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41317: LD_VAR 0 4
41321: PUSH
41322: LD_VAR 0 8
41326: PUSH
41327: LD_INT 6
41329: LESS
41330: AND
41331: IFFALSE 41519
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41333: LD_ADDR_VAR 0 9
41337: PUSH
41338: LD_VAR 0 4
41342: PUSH
41343: LD_VAR 0 8
41347: PUSH
41348: LD_VAR 0 7
41352: UNION
41353: DIFF
41354: PPUSH
41355: LD_INT 4
41357: PPUSH
41358: CALL 99599 0 2
41362: ST_TO_ADDR
// p := [ ] ;
41363: LD_ADDR_VAR 0 11
41367: PUSH
41368: EMPTY
41369: ST_TO_ADDR
// if sort then
41370: LD_VAR 0 9
41374: IFFALSE 41490
// for i = 1 to 6 - sci do
41376: LD_ADDR_VAR 0 3
41380: PUSH
41381: DOUBLE
41382: LD_INT 1
41384: DEC
41385: ST_TO_ADDR
41386: LD_INT 6
41388: PUSH
41389: LD_VAR 0 8
41393: MINUS
41394: PUSH
41395: FOR_TO
41396: IFFALSE 41488
// begin if i = sort then
41398: LD_VAR 0 3
41402: PUSH
41403: LD_VAR 0 9
41407: EQUAL
41408: IFFALSE 41412
// break ;
41410: GO 41488
// if GetClass ( i ) = 4 then
41412: LD_VAR 0 3
41416: PPUSH
41417: CALL_OW 257
41421: PUSH
41422: LD_INT 4
41424: EQUAL
41425: IFFALSE 41429
// continue ;
41427: GO 41395
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41429: LD_ADDR_VAR 0 11
41433: PUSH
41434: LD_VAR 0 11
41438: PPUSH
41439: LD_VAR 0 11
41443: PUSH
41444: LD_INT 1
41446: PLUS
41447: PPUSH
41448: LD_VAR 0 9
41452: PUSH
41453: LD_VAR 0 3
41457: ARRAY
41458: PPUSH
41459: CALL_OW 2
41463: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41464: LD_ADDR_VAR 0 4
41468: PUSH
41469: LD_VAR 0 4
41473: PUSH
41474: LD_VAR 0 9
41478: PUSH
41479: LD_VAR 0 3
41483: ARRAY
41484: DIFF
41485: ST_TO_ADDR
// end ;
41486: GO 41395
41488: POP
41489: POP
// if p then
41490: LD_VAR 0 11
41494: IFFALSE 41519
// result := Replace ( result , 4 , p ) ;
41496: LD_ADDR_VAR 0 2
41500: PUSH
41501: LD_VAR 0 2
41505: PPUSH
41506: LD_INT 4
41508: PPUSH
41509: LD_VAR 0 11
41513: PPUSH
41514: CALL_OW 1
41518: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41519: LD_VAR 0 4
41523: PUSH
41524: LD_VAR 0 7
41528: PUSH
41529: LD_INT 6
41531: LESS
41532: AND
41533: IFFALSE 41721
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41535: LD_ADDR_VAR 0 9
41539: PUSH
41540: LD_VAR 0 4
41544: PUSH
41545: LD_VAR 0 8
41549: PUSH
41550: LD_VAR 0 7
41554: UNION
41555: DIFF
41556: PPUSH
41557: LD_INT 3
41559: PPUSH
41560: CALL 99599 0 2
41564: ST_TO_ADDR
// p := [ ] ;
41565: LD_ADDR_VAR 0 11
41569: PUSH
41570: EMPTY
41571: ST_TO_ADDR
// if sort then
41572: LD_VAR 0 9
41576: IFFALSE 41692
// for i = 1 to 6 - mech do
41578: LD_ADDR_VAR 0 3
41582: PUSH
41583: DOUBLE
41584: LD_INT 1
41586: DEC
41587: ST_TO_ADDR
41588: LD_INT 6
41590: PUSH
41591: LD_VAR 0 7
41595: MINUS
41596: PUSH
41597: FOR_TO
41598: IFFALSE 41690
// begin if i = sort then
41600: LD_VAR 0 3
41604: PUSH
41605: LD_VAR 0 9
41609: EQUAL
41610: IFFALSE 41614
// break ;
41612: GO 41690
// if GetClass ( i ) = 3 then
41614: LD_VAR 0 3
41618: PPUSH
41619: CALL_OW 257
41623: PUSH
41624: LD_INT 3
41626: EQUAL
41627: IFFALSE 41631
// continue ;
41629: GO 41597
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41631: LD_ADDR_VAR 0 11
41635: PUSH
41636: LD_VAR 0 11
41640: PPUSH
41641: LD_VAR 0 11
41645: PUSH
41646: LD_INT 1
41648: PLUS
41649: PPUSH
41650: LD_VAR 0 9
41654: PUSH
41655: LD_VAR 0 3
41659: ARRAY
41660: PPUSH
41661: CALL_OW 2
41665: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41666: LD_ADDR_VAR 0 4
41670: PUSH
41671: LD_VAR 0 4
41675: PUSH
41676: LD_VAR 0 9
41680: PUSH
41681: LD_VAR 0 3
41685: ARRAY
41686: DIFF
41687: ST_TO_ADDR
// end ;
41688: GO 41597
41690: POP
41691: POP
// if p then
41692: LD_VAR 0 11
41696: IFFALSE 41721
// result := Replace ( result , 3 , p ) ;
41698: LD_ADDR_VAR 0 2
41702: PUSH
41703: LD_VAR 0 2
41707: PPUSH
41708: LD_INT 3
41710: PPUSH
41711: LD_VAR 0 11
41715: PPUSH
41716: CALL_OW 1
41720: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41721: LD_VAR 0 4
41725: PUSH
41726: LD_INT 6
41728: GREATER
41729: PUSH
41730: LD_VAR 0 6
41734: PUSH
41735: LD_INT 6
41737: LESS
41738: AND
41739: IFFALSE 41933
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41741: LD_ADDR_VAR 0 9
41745: PUSH
41746: LD_VAR 0 4
41750: PUSH
41751: LD_VAR 0 8
41755: PUSH
41756: LD_VAR 0 7
41760: UNION
41761: PUSH
41762: LD_VAR 0 6
41766: UNION
41767: DIFF
41768: PPUSH
41769: LD_INT 2
41771: PPUSH
41772: CALL 99599 0 2
41776: ST_TO_ADDR
// p := [ ] ;
41777: LD_ADDR_VAR 0 11
41781: PUSH
41782: EMPTY
41783: ST_TO_ADDR
// if sort then
41784: LD_VAR 0 9
41788: IFFALSE 41904
// for i = 1 to 6 - eng do
41790: LD_ADDR_VAR 0 3
41794: PUSH
41795: DOUBLE
41796: LD_INT 1
41798: DEC
41799: ST_TO_ADDR
41800: LD_INT 6
41802: PUSH
41803: LD_VAR 0 6
41807: MINUS
41808: PUSH
41809: FOR_TO
41810: IFFALSE 41902
// begin if i = sort then
41812: LD_VAR 0 3
41816: PUSH
41817: LD_VAR 0 9
41821: EQUAL
41822: IFFALSE 41826
// break ;
41824: GO 41902
// if GetClass ( i ) = 2 then
41826: LD_VAR 0 3
41830: PPUSH
41831: CALL_OW 257
41835: PUSH
41836: LD_INT 2
41838: EQUAL
41839: IFFALSE 41843
// continue ;
41841: GO 41809
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41843: LD_ADDR_VAR 0 11
41847: PUSH
41848: LD_VAR 0 11
41852: PPUSH
41853: LD_VAR 0 11
41857: PUSH
41858: LD_INT 1
41860: PLUS
41861: PPUSH
41862: LD_VAR 0 9
41866: PUSH
41867: LD_VAR 0 3
41871: ARRAY
41872: PPUSH
41873: CALL_OW 2
41877: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41878: LD_ADDR_VAR 0 4
41882: PUSH
41883: LD_VAR 0 4
41887: PUSH
41888: LD_VAR 0 9
41892: PUSH
41893: LD_VAR 0 3
41897: ARRAY
41898: DIFF
41899: ST_TO_ADDR
// end ;
41900: GO 41809
41902: POP
41903: POP
// if p then
41904: LD_VAR 0 11
41908: IFFALSE 41933
// result := Replace ( result , 2 , p ) ;
41910: LD_ADDR_VAR 0 2
41914: PUSH
41915: LD_VAR 0 2
41919: PPUSH
41920: LD_INT 2
41922: PPUSH
41923: LD_VAR 0 11
41927: PPUSH
41928: CALL_OW 1
41932: ST_TO_ADDR
// end ; exit ;
41933: GO 43321
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41935: LD_EXP 139
41939: PUSH
41940: LD_EXP 138
41944: PUSH
41945: LD_VAR 0 1
41949: ARRAY
41950: ARRAY
41951: NOT
41952: PUSH
41953: LD_EXP 112
41957: PUSH
41958: LD_VAR 0 1
41962: ARRAY
41963: PPUSH
41964: LD_INT 30
41966: PUSH
41967: LD_INT 3
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PPUSH
41974: CALL_OW 72
41978: AND
41979: PUSH
41980: LD_EXP 117
41984: PUSH
41985: LD_VAR 0 1
41989: ARRAY
41990: AND
41991: IFFALSE 42599
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41993: LD_ADDR_EXP 154
41997: PUSH
41998: LD_EXP 154
42002: PPUSH
42003: LD_VAR 0 1
42007: PPUSH
42008: LD_INT 5
42010: PPUSH
42011: CALL_OW 1
42015: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42016: LD_ADDR_VAR 0 2
42020: PUSH
42021: LD_INT 0
42023: PUSH
42024: LD_INT 0
42026: PUSH
42027: LD_INT 0
42029: PUSH
42030: LD_INT 0
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: ST_TO_ADDR
// if sci > 1 then
42039: LD_VAR 0 8
42043: PUSH
42044: LD_INT 1
42046: GREATER
42047: IFFALSE 42075
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42049: LD_ADDR_VAR 0 4
42053: PUSH
42054: LD_VAR 0 4
42058: PUSH
42059: LD_VAR 0 8
42063: PUSH
42064: LD_VAR 0 8
42068: PUSH
42069: LD_INT 1
42071: ARRAY
42072: DIFF
42073: DIFF
42074: ST_TO_ADDR
// if tmp and not sci then
42075: LD_VAR 0 4
42079: PUSH
42080: LD_VAR 0 8
42084: NOT
42085: AND
42086: IFFALSE 42155
// begin sort := SortBySkill ( tmp , 4 ) ;
42088: LD_ADDR_VAR 0 9
42092: PUSH
42093: LD_VAR 0 4
42097: PPUSH
42098: LD_INT 4
42100: PPUSH
42101: CALL 99599 0 2
42105: ST_TO_ADDR
// if sort then
42106: LD_VAR 0 9
42110: IFFALSE 42126
// p := sort [ 1 ] ;
42112: LD_ADDR_VAR 0 11
42116: PUSH
42117: LD_VAR 0 9
42121: PUSH
42122: LD_INT 1
42124: ARRAY
42125: ST_TO_ADDR
// if p then
42126: LD_VAR 0 11
42130: IFFALSE 42155
// result := Replace ( result , 4 , p ) ;
42132: LD_ADDR_VAR 0 2
42136: PUSH
42137: LD_VAR 0 2
42141: PPUSH
42142: LD_INT 4
42144: PPUSH
42145: LD_VAR 0 11
42149: PPUSH
42150: CALL_OW 1
42154: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42155: LD_ADDR_VAR 0 4
42159: PUSH
42160: LD_VAR 0 4
42164: PUSH
42165: LD_VAR 0 7
42169: DIFF
42170: ST_TO_ADDR
// if tmp and mech < 6 then
42171: LD_VAR 0 4
42175: PUSH
42176: LD_VAR 0 7
42180: PUSH
42181: LD_INT 6
42183: LESS
42184: AND
42185: IFFALSE 42373
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42187: LD_ADDR_VAR 0 9
42191: PUSH
42192: LD_VAR 0 4
42196: PUSH
42197: LD_VAR 0 8
42201: PUSH
42202: LD_VAR 0 7
42206: UNION
42207: DIFF
42208: PPUSH
42209: LD_INT 3
42211: PPUSH
42212: CALL 99599 0 2
42216: ST_TO_ADDR
// p := [ ] ;
42217: LD_ADDR_VAR 0 11
42221: PUSH
42222: EMPTY
42223: ST_TO_ADDR
// if sort then
42224: LD_VAR 0 9
42228: IFFALSE 42344
// for i = 1 to 6 - mech do
42230: LD_ADDR_VAR 0 3
42234: PUSH
42235: DOUBLE
42236: LD_INT 1
42238: DEC
42239: ST_TO_ADDR
42240: LD_INT 6
42242: PUSH
42243: LD_VAR 0 7
42247: MINUS
42248: PUSH
42249: FOR_TO
42250: IFFALSE 42342
// begin if i = sort then
42252: LD_VAR 0 3
42256: PUSH
42257: LD_VAR 0 9
42261: EQUAL
42262: IFFALSE 42266
// break ;
42264: GO 42342
// if GetClass ( i ) = 3 then
42266: LD_VAR 0 3
42270: PPUSH
42271: CALL_OW 257
42275: PUSH
42276: LD_INT 3
42278: EQUAL
42279: IFFALSE 42283
// continue ;
42281: GO 42249
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42283: LD_ADDR_VAR 0 11
42287: PUSH
42288: LD_VAR 0 11
42292: PPUSH
42293: LD_VAR 0 11
42297: PUSH
42298: LD_INT 1
42300: PLUS
42301: PPUSH
42302: LD_VAR 0 9
42306: PUSH
42307: LD_VAR 0 3
42311: ARRAY
42312: PPUSH
42313: CALL_OW 2
42317: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42318: LD_ADDR_VAR 0 4
42322: PUSH
42323: LD_VAR 0 4
42327: PUSH
42328: LD_VAR 0 9
42332: PUSH
42333: LD_VAR 0 3
42337: ARRAY
42338: DIFF
42339: ST_TO_ADDR
// end ;
42340: GO 42249
42342: POP
42343: POP
// if p then
42344: LD_VAR 0 11
42348: IFFALSE 42373
// result := Replace ( result , 3 , p ) ;
42350: LD_ADDR_VAR 0 2
42354: PUSH
42355: LD_VAR 0 2
42359: PPUSH
42360: LD_INT 3
42362: PPUSH
42363: LD_VAR 0 11
42367: PPUSH
42368: CALL_OW 1
42372: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42373: LD_ADDR_VAR 0 4
42377: PUSH
42378: LD_VAR 0 4
42382: PUSH
42383: LD_VAR 0 6
42387: DIFF
42388: ST_TO_ADDR
// if tmp and eng < 6 then
42389: LD_VAR 0 4
42393: PUSH
42394: LD_VAR 0 6
42398: PUSH
42399: LD_INT 6
42401: LESS
42402: AND
42403: IFFALSE 42597
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42405: LD_ADDR_VAR 0 9
42409: PUSH
42410: LD_VAR 0 4
42414: PUSH
42415: LD_VAR 0 8
42419: PUSH
42420: LD_VAR 0 7
42424: UNION
42425: PUSH
42426: LD_VAR 0 6
42430: UNION
42431: DIFF
42432: PPUSH
42433: LD_INT 2
42435: PPUSH
42436: CALL 99599 0 2
42440: ST_TO_ADDR
// p := [ ] ;
42441: LD_ADDR_VAR 0 11
42445: PUSH
42446: EMPTY
42447: ST_TO_ADDR
// if sort then
42448: LD_VAR 0 9
42452: IFFALSE 42568
// for i = 1 to 6 - eng do
42454: LD_ADDR_VAR 0 3
42458: PUSH
42459: DOUBLE
42460: LD_INT 1
42462: DEC
42463: ST_TO_ADDR
42464: LD_INT 6
42466: PUSH
42467: LD_VAR 0 6
42471: MINUS
42472: PUSH
42473: FOR_TO
42474: IFFALSE 42566
// begin if i = sort then
42476: LD_VAR 0 3
42480: PUSH
42481: LD_VAR 0 9
42485: EQUAL
42486: IFFALSE 42490
// break ;
42488: GO 42566
// if GetClass ( i ) = 2 then
42490: LD_VAR 0 3
42494: PPUSH
42495: CALL_OW 257
42499: PUSH
42500: LD_INT 2
42502: EQUAL
42503: IFFALSE 42507
// continue ;
42505: GO 42473
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42507: LD_ADDR_VAR 0 11
42511: PUSH
42512: LD_VAR 0 11
42516: PPUSH
42517: LD_VAR 0 11
42521: PUSH
42522: LD_INT 1
42524: PLUS
42525: PPUSH
42526: LD_VAR 0 9
42530: PUSH
42531: LD_VAR 0 3
42535: ARRAY
42536: PPUSH
42537: CALL_OW 2
42541: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42542: LD_ADDR_VAR 0 4
42546: PUSH
42547: LD_VAR 0 4
42551: PUSH
42552: LD_VAR 0 9
42556: PUSH
42557: LD_VAR 0 3
42561: ARRAY
42562: DIFF
42563: ST_TO_ADDR
// end ;
42564: GO 42473
42566: POP
42567: POP
// if p then
42568: LD_VAR 0 11
42572: IFFALSE 42597
// result := Replace ( result , 2 , p ) ;
42574: LD_ADDR_VAR 0 2
42578: PUSH
42579: LD_VAR 0 2
42583: PPUSH
42584: LD_INT 2
42586: PPUSH
42587: LD_VAR 0 11
42591: PPUSH
42592: CALL_OW 1
42596: ST_TO_ADDR
// end ; exit ;
42597: GO 43321
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42599: LD_EXP 139
42603: PUSH
42604: LD_EXP 138
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: ARRAY
42615: NOT
42616: PUSH
42617: LD_EXP 112
42621: PUSH
42622: LD_VAR 0 1
42626: ARRAY
42627: PPUSH
42628: LD_INT 30
42630: PUSH
42631: LD_INT 3
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PPUSH
42638: CALL_OW 72
42642: AND
42643: PUSH
42644: LD_EXP 117
42648: PUSH
42649: LD_VAR 0 1
42653: ARRAY
42654: NOT
42655: AND
42656: IFFALSE 43321
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42658: LD_ADDR_EXP 154
42662: PUSH
42663: LD_EXP 154
42667: PPUSH
42668: LD_VAR 0 1
42672: PPUSH
42673: LD_INT 6
42675: PPUSH
42676: CALL_OW 1
42680: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42681: LD_ADDR_VAR 0 2
42685: PUSH
42686: LD_INT 0
42688: PUSH
42689: LD_INT 0
42691: PUSH
42692: LD_INT 0
42694: PUSH
42695: LD_INT 0
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: ST_TO_ADDR
// if sci >= 1 then
42704: LD_VAR 0 8
42708: PUSH
42709: LD_INT 1
42711: GREATEREQUAL
42712: IFFALSE 42734
// tmp := tmp diff sci [ 1 ] ;
42714: LD_ADDR_VAR 0 4
42718: PUSH
42719: LD_VAR 0 4
42723: PUSH
42724: LD_VAR 0 8
42728: PUSH
42729: LD_INT 1
42731: ARRAY
42732: DIFF
42733: ST_TO_ADDR
// if tmp and not sci then
42734: LD_VAR 0 4
42738: PUSH
42739: LD_VAR 0 8
42743: NOT
42744: AND
42745: IFFALSE 42814
// begin sort := SortBySkill ( tmp , 4 ) ;
42747: LD_ADDR_VAR 0 9
42751: PUSH
42752: LD_VAR 0 4
42756: PPUSH
42757: LD_INT 4
42759: PPUSH
42760: CALL 99599 0 2
42764: ST_TO_ADDR
// if sort then
42765: LD_VAR 0 9
42769: IFFALSE 42785
// p := sort [ 1 ] ;
42771: LD_ADDR_VAR 0 11
42775: PUSH
42776: LD_VAR 0 9
42780: PUSH
42781: LD_INT 1
42783: ARRAY
42784: ST_TO_ADDR
// if p then
42785: LD_VAR 0 11
42789: IFFALSE 42814
// result := Replace ( result , 4 , p ) ;
42791: LD_ADDR_VAR 0 2
42795: PUSH
42796: LD_VAR 0 2
42800: PPUSH
42801: LD_INT 4
42803: PPUSH
42804: LD_VAR 0 11
42808: PPUSH
42809: CALL_OW 1
42813: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42814: LD_ADDR_VAR 0 4
42818: PUSH
42819: LD_VAR 0 4
42823: PUSH
42824: LD_VAR 0 7
42828: DIFF
42829: ST_TO_ADDR
// if tmp and mech < 6 then
42830: LD_VAR 0 4
42834: PUSH
42835: LD_VAR 0 7
42839: PUSH
42840: LD_INT 6
42842: LESS
42843: AND
42844: IFFALSE 43026
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42846: LD_ADDR_VAR 0 9
42850: PUSH
42851: LD_VAR 0 4
42855: PUSH
42856: LD_VAR 0 7
42860: DIFF
42861: PPUSH
42862: LD_INT 3
42864: PPUSH
42865: CALL 99599 0 2
42869: ST_TO_ADDR
// p := [ ] ;
42870: LD_ADDR_VAR 0 11
42874: PUSH
42875: EMPTY
42876: ST_TO_ADDR
// if sort then
42877: LD_VAR 0 9
42881: IFFALSE 42997
// for i = 1 to 6 - mech do
42883: LD_ADDR_VAR 0 3
42887: PUSH
42888: DOUBLE
42889: LD_INT 1
42891: DEC
42892: ST_TO_ADDR
42893: LD_INT 6
42895: PUSH
42896: LD_VAR 0 7
42900: MINUS
42901: PUSH
42902: FOR_TO
42903: IFFALSE 42995
// begin if i = sort then
42905: LD_VAR 0 3
42909: PUSH
42910: LD_VAR 0 9
42914: EQUAL
42915: IFFALSE 42919
// break ;
42917: GO 42995
// if GetClass ( i ) = 3 then
42919: LD_VAR 0 3
42923: PPUSH
42924: CALL_OW 257
42928: PUSH
42929: LD_INT 3
42931: EQUAL
42932: IFFALSE 42936
// continue ;
42934: GO 42902
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42936: LD_ADDR_VAR 0 11
42940: PUSH
42941: LD_VAR 0 11
42945: PPUSH
42946: LD_VAR 0 11
42950: PUSH
42951: LD_INT 1
42953: PLUS
42954: PPUSH
42955: LD_VAR 0 9
42959: PUSH
42960: LD_VAR 0 3
42964: ARRAY
42965: PPUSH
42966: CALL_OW 2
42970: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42971: LD_ADDR_VAR 0 4
42975: PUSH
42976: LD_VAR 0 4
42980: PUSH
42981: LD_VAR 0 9
42985: PUSH
42986: LD_VAR 0 3
42990: ARRAY
42991: DIFF
42992: ST_TO_ADDR
// end ;
42993: GO 42902
42995: POP
42996: POP
// if p then
42997: LD_VAR 0 11
43001: IFFALSE 43026
// result := Replace ( result , 3 , p ) ;
43003: LD_ADDR_VAR 0 2
43007: PUSH
43008: LD_VAR 0 2
43012: PPUSH
43013: LD_INT 3
43015: PPUSH
43016: LD_VAR 0 11
43020: PPUSH
43021: CALL_OW 1
43025: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43026: LD_ADDR_VAR 0 4
43030: PUSH
43031: LD_VAR 0 4
43035: PUSH
43036: LD_VAR 0 6
43040: DIFF
43041: ST_TO_ADDR
// if tmp and eng < 4 then
43042: LD_VAR 0 4
43046: PUSH
43047: LD_VAR 0 6
43051: PUSH
43052: LD_INT 4
43054: LESS
43055: AND
43056: IFFALSE 43246
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43058: LD_ADDR_VAR 0 9
43062: PUSH
43063: LD_VAR 0 4
43067: PUSH
43068: LD_VAR 0 7
43072: PUSH
43073: LD_VAR 0 6
43077: UNION
43078: DIFF
43079: PPUSH
43080: LD_INT 2
43082: PPUSH
43083: CALL 99599 0 2
43087: ST_TO_ADDR
// p := [ ] ;
43088: LD_ADDR_VAR 0 11
43092: PUSH
43093: EMPTY
43094: ST_TO_ADDR
// if sort then
43095: LD_VAR 0 9
43099: IFFALSE 43215
// for i = 1 to 4 - eng do
43101: LD_ADDR_VAR 0 3
43105: PUSH
43106: DOUBLE
43107: LD_INT 1
43109: DEC
43110: ST_TO_ADDR
43111: LD_INT 4
43113: PUSH
43114: LD_VAR 0 6
43118: MINUS
43119: PUSH
43120: FOR_TO
43121: IFFALSE 43213
// begin if i = sort then
43123: LD_VAR 0 3
43127: PUSH
43128: LD_VAR 0 9
43132: EQUAL
43133: IFFALSE 43137
// break ;
43135: GO 43213
// if GetClass ( i ) = 2 then
43137: LD_VAR 0 3
43141: PPUSH
43142: CALL_OW 257
43146: PUSH
43147: LD_INT 2
43149: EQUAL
43150: IFFALSE 43154
// continue ;
43152: GO 43120
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43154: LD_ADDR_VAR 0 11
43158: PUSH
43159: LD_VAR 0 11
43163: PPUSH
43164: LD_VAR 0 11
43168: PUSH
43169: LD_INT 1
43171: PLUS
43172: PPUSH
43173: LD_VAR 0 9
43177: PUSH
43178: LD_VAR 0 3
43182: ARRAY
43183: PPUSH
43184: CALL_OW 2
43188: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43189: LD_ADDR_VAR 0 4
43193: PUSH
43194: LD_VAR 0 4
43198: PUSH
43199: LD_VAR 0 9
43203: PUSH
43204: LD_VAR 0 3
43208: ARRAY
43209: DIFF
43210: ST_TO_ADDR
// end ;
43211: GO 43120
43213: POP
43214: POP
// if p then
43215: LD_VAR 0 11
43219: IFFALSE 43244
// result := Replace ( result , 2 , p ) ;
43221: LD_ADDR_VAR 0 2
43225: PUSH
43226: LD_VAR 0 2
43230: PPUSH
43231: LD_INT 2
43233: PPUSH
43234: LD_VAR 0 11
43238: PPUSH
43239: CALL_OW 1
43243: ST_TO_ADDR
// end else
43244: GO 43290
// for i = eng downto 5 do
43246: LD_ADDR_VAR 0 3
43250: PUSH
43251: DOUBLE
43252: LD_VAR 0 6
43256: INC
43257: ST_TO_ADDR
43258: LD_INT 5
43260: PUSH
43261: FOR_DOWNTO
43262: IFFALSE 43288
// tmp := tmp union eng [ i ] ;
43264: LD_ADDR_VAR 0 4
43268: PUSH
43269: LD_VAR 0 4
43273: PUSH
43274: LD_VAR 0 6
43278: PUSH
43279: LD_VAR 0 3
43283: ARRAY
43284: UNION
43285: ST_TO_ADDR
43286: GO 43261
43288: POP
43289: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43290: LD_ADDR_VAR 0 2
43294: PUSH
43295: LD_VAR 0 2
43299: PPUSH
43300: LD_INT 1
43302: PPUSH
43303: LD_VAR 0 4
43307: PUSH
43308: LD_VAR 0 5
43312: DIFF
43313: PPUSH
43314: CALL_OW 1
43318: ST_TO_ADDR
// exit ;
43319: GO 43321
// end ; end ;
43321: LD_VAR 0 2
43325: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43326: LD_INT 0
43328: PPUSH
43329: PPUSH
43330: PPUSH
// if not mc_bases then
43331: LD_EXP 112
43335: NOT
43336: IFFALSE 43340
// exit ;
43338: GO 43446
// for i = 1 to mc_bases do
43340: LD_ADDR_VAR 0 2
43344: PUSH
43345: DOUBLE
43346: LD_INT 1
43348: DEC
43349: ST_TO_ADDR
43350: LD_EXP 112
43354: PUSH
43355: FOR_TO
43356: IFFALSE 43437
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43358: LD_ADDR_VAR 0 3
43362: PUSH
43363: LD_EXP 112
43367: PUSH
43368: LD_VAR 0 2
43372: ARRAY
43373: PPUSH
43374: LD_INT 21
43376: PUSH
43377: LD_INT 3
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 3
43386: PUSH
43387: LD_INT 24
43389: PUSH
43390: LD_INT 1000
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PPUSH
43405: CALL_OW 72
43409: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43410: LD_ADDR_EXP 113
43414: PUSH
43415: LD_EXP 113
43419: PPUSH
43420: LD_VAR 0 2
43424: PPUSH
43425: LD_VAR 0 3
43429: PPUSH
43430: CALL_OW 1
43434: ST_TO_ADDR
// end ;
43435: GO 43355
43437: POP
43438: POP
// RaiseSailEvent ( 101 ) ;
43439: LD_INT 101
43441: PPUSH
43442: CALL_OW 427
// end ;
43446: LD_VAR 0 1
43450: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43451: LD_INT 0
43453: PPUSH
43454: PPUSH
43455: PPUSH
43456: PPUSH
43457: PPUSH
43458: PPUSH
43459: PPUSH
// if not mc_bases then
43460: LD_EXP 112
43464: NOT
43465: IFFALSE 43469
// exit ;
43467: GO 44031
// for i = 1 to mc_bases do
43469: LD_ADDR_VAR 0 2
43473: PUSH
43474: DOUBLE
43475: LD_INT 1
43477: DEC
43478: ST_TO_ADDR
43479: LD_EXP 112
43483: PUSH
43484: FOR_TO
43485: IFFALSE 44022
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43487: LD_ADDR_VAR 0 5
43491: PUSH
43492: LD_EXP 112
43496: PUSH
43497: LD_VAR 0 2
43501: ARRAY
43502: PUSH
43503: LD_EXP 141
43507: PUSH
43508: LD_VAR 0 2
43512: ARRAY
43513: UNION
43514: PPUSH
43515: LD_INT 21
43517: PUSH
43518: LD_INT 1
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: LD_INT 3
43530: PUSH
43531: LD_INT 54
43533: PUSH
43534: EMPTY
43535: LIST
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 3
43543: PUSH
43544: LD_INT 24
43546: PUSH
43547: LD_INT 800
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: LIST
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PPUSH
43567: CALL_OW 72
43571: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43572: LD_ADDR_VAR 0 6
43576: PUSH
43577: LD_EXP 112
43581: PUSH
43582: LD_VAR 0 2
43586: ARRAY
43587: PPUSH
43588: LD_INT 21
43590: PUSH
43591: LD_INT 1
43593: PUSH
43594: EMPTY
43595: LIST
43596: LIST
43597: PUSH
43598: LD_INT 1
43600: PUSH
43601: LD_INT 3
43603: PUSH
43604: LD_INT 54
43606: PUSH
43607: EMPTY
43608: LIST
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: PUSH
43617: LD_INT 24
43619: PUSH
43620: LD_INT 250
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: LIST
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: PPUSH
43640: CALL_OW 72
43644: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43645: LD_ADDR_VAR 0 7
43649: PUSH
43650: LD_VAR 0 5
43654: PUSH
43655: LD_VAR 0 6
43659: DIFF
43660: ST_TO_ADDR
// if not need_heal_1 then
43661: LD_VAR 0 6
43665: NOT
43666: IFFALSE 43699
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43668: LD_ADDR_EXP 115
43672: PUSH
43673: LD_EXP 115
43677: PPUSH
43678: LD_VAR 0 2
43682: PUSH
43683: LD_INT 1
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PPUSH
43690: EMPTY
43691: PPUSH
43692: CALL 70050 0 3
43696: ST_TO_ADDR
43697: GO 43769
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43699: LD_ADDR_EXP 115
43703: PUSH
43704: LD_EXP 115
43708: PPUSH
43709: LD_VAR 0 2
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PPUSH
43721: LD_EXP 115
43725: PUSH
43726: LD_VAR 0 2
43730: ARRAY
43731: PUSH
43732: LD_INT 1
43734: ARRAY
43735: PPUSH
43736: LD_INT 3
43738: PUSH
43739: LD_INT 24
43741: PUSH
43742: LD_INT 1000
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PPUSH
43753: CALL_OW 72
43757: PUSH
43758: LD_VAR 0 6
43762: UNION
43763: PPUSH
43764: CALL 70050 0 3
43768: ST_TO_ADDR
// if not need_heal_2 then
43769: LD_VAR 0 7
43773: NOT
43774: IFFALSE 43807
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43776: LD_ADDR_EXP 115
43780: PUSH
43781: LD_EXP 115
43785: PPUSH
43786: LD_VAR 0 2
43790: PUSH
43791: LD_INT 2
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PPUSH
43798: EMPTY
43799: PPUSH
43800: CALL 70050 0 3
43804: ST_TO_ADDR
43805: GO 43839
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43807: LD_ADDR_EXP 115
43811: PUSH
43812: LD_EXP 115
43816: PPUSH
43817: LD_VAR 0 2
43821: PUSH
43822: LD_INT 2
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PPUSH
43829: LD_VAR 0 7
43833: PPUSH
43834: CALL 70050 0 3
43838: ST_TO_ADDR
// if need_heal_2 then
43839: LD_VAR 0 7
43843: IFFALSE 44004
// for j in need_heal_2 do
43845: LD_ADDR_VAR 0 3
43849: PUSH
43850: LD_VAR 0 7
43854: PUSH
43855: FOR_IN
43856: IFFALSE 44002
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43858: LD_ADDR_VAR 0 5
43862: PUSH
43863: LD_EXP 112
43867: PUSH
43868: LD_VAR 0 2
43872: ARRAY
43873: PPUSH
43874: LD_INT 2
43876: PUSH
43877: LD_INT 30
43879: PUSH
43880: LD_INT 6
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 30
43889: PUSH
43890: LD_INT 7
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 30
43899: PUSH
43900: LD_INT 8
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 30
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 30
43919: PUSH
43920: LD_INT 1
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: PPUSH
43935: CALL_OW 72
43939: ST_TO_ADDR
// if tmp then
43940: LD_VAR 0 5
43944: IFFALSE 44000
// begin k := NearestUnitToUnit ( tmp , j ) ;
43946: LD_ADDR_VAR 0 4
43950: PUSH
43951: LD_VAR 0 5
43955: PPUSH
43956: LD_VAR 0 3
43960: PPUSH
43961: CALL_OW 74
43965: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
43966: LD_VAR 0 3
43970: PPUSH
43971: LD_VAR 0 4
43975: PPUSH
43976: CALL_OW 296
43980: PUSH
43981: LD_INT 5
43983: GREATER
43984: IFFALSE 44000
// ComMoveUnit ( j , k ) ;
43986: LD_VAR 0 3
43990: PPUSH
43991: LD_VAR 0 4
43995: PPUSH
43996: CALL_OW 112
// end ; end ;
44000: GO 43855
44002: POP
44003: POP
// if not need_heal_1 and not need_heal_2 then
44004: LD_VAR 0 6
44008: NOT
44009: PUSH
44010: LD_VAR 0 7
44014: NOT
44015: AND
44016: IFFALSE 44020
// continue ;
44018: GO 43484
// end ;
44020: GO 43484
44022: POP
44023: POP
// RaiseSailEvent ( 102 ) ;
44024: LD_INT 102
44026: PPUSH
44027: CALL_OW 427
// end ;
44031: LD_VAR 0 1
44035: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44036: LD_INT 0
44038: PPUSH
44039: PPUSH
44040: PPUSH
44041: PPUSH
44042: PPUSH
44043: PPUSH
44044: PPUSH
44045: PPUSH
// if not mc_bases then
44046: LD_EXP 112
44050: NOT
44051: IFFALSE 44055
// exit ;
44053: GO 44890
// for i = 1 to mc_bases do
44055: LD_ADDR_VAR 0 2
44059: PUSH
44060: DOUBLE
44061: LD_INT 1
44063: DEC
44064: ST_TO_ADDR
44065: LD_EXP 112
44069: PUSH
44070: FOR_TO
44071: IFFALSE 44888
// begin if not mc_building_need_repair [ i ] then
44073: LD_EXP 113
44077: PUSH
44078: LD_VAR 0 2
44082: ARRAY
44083: NOT
44084: IFFALSE 44258
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
44086: LD_ADDR_VAR 0 6
44090: PUSH
44091: LD_EXP 131
44095: PUSH
44096: LD_VAR 0 2
44100: ARRAY
44101: PPUSH
44102: LD_INT 3
44104: PUSH
44105: LD_INT 24
44107: PUSH
44108: LD_INT 1000
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 2
44121: PUSH
44122: LD_INT 34
44124: PUSH
44125: LD_INT 13
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 34
44134: PUSH
44135: LD_INT 52
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: LIST
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PPUSH
44151: CALL_OW 72
44155: ST_TO_ADDR
// if cranes then
44156: LD_VAR 0 6
44160: IFFALSE 44222
// for j in cranes do
44162: LD_ADDR_VAR 0 3
44166: PUSH
44167: LD_VAR 0 6
44171: PUSH
44172: FOR_IN
44173: IFFALSE 44220
// if not IsInArea ( j , mc_parking [ i ] ) then
44175: LD_VAR 0 3
44179: PPUSH
44180: LD_EXP 136
44184: PUSH
44185: LD_VAR 0 2
44189: ARRAY
44190: PPUSH
44191: CALL_OW 308
44195: NOT
44196: IFFALSE 44218
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44198: LD_VAR 0 3
44202: PPUSH
44203: LD_EXP 136
44207: PUSH
44208: LD_VAR 0 2
44212: ARRAY
44213: PPUSH
44214: CALL_OW 113
44218: GO 44172
44220: POP
44221: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44222: LD_ADDR_EXP 114
44226: PUSH
44227: LD_EXP 114
44231: PPUSH
44232: LD_VAR 0 2
44236: PPUSH
44237: EMPTY
44238: PPUSH
44239: CALL_OW 1
44243: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44244: LD_VAR 0 2
44248: PPUSH
44249: LD_INT 101
44251: PPUSH
44252: CALL 39159 0 2
// continue ;
44256: GO 44070
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44258: LD_ADDR_EXP 118
44262: PUSH
44263: LD_EXP 118
44267: PPUSH
44268: LD_VAR 0 2
44272: PPUSH
44273: EMPTY
44274: PPUSH
44275: CALL_OW 1
44279: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44280: LD_VAR 0 2
44284: PPUSH
44285: LD_INT 103
44287: PPUSH
44288: CALL 39159 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44292: LD_ADDR_VAR 0 5
44296: PUSH
44297: LD_EXP 112
44301: PUSH
44302: LD_VAR 0 2
44306: ARRAY
44307: PUSH
44308: LD_EXP 141
44312: PUSH
44313: LD_VAR 0 2
44317: ARRAY
44318: UNION
44319: PPUSH
44320: LD_INT 2
44322: PUSH
44323: LD_INT 25
44325: PUSH
44326: LD_INT 2
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 25
44335: PUSH
44336: LD_INT 16
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: LIST
44347: PUSH
44348: EMPTY
44349: LIST
44350: PPUSH
44351: CALL_OW 72
44355: PUSH
44356: LD_EXP 115
44360: PUSH
44361: LD_VAR 0 2
44365: ARRAY
44366: PUSH
44367: LD_INT 1
44369: ARRAY
44370: PUSH
44371: LD_EXP 115
44375: PUSH
44376: LD_VAR 0 2
44380: ARRAY
44381: PUSH
44382: LD_INT 2
44384: ARRAY
44385: UNION
44386: DIFF
44387: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44388: LD_ADDR_VAR 0 6
44392: PUSH
44393: LD_EXP 131
44397: PUSH
44398: LD_VAR 0 2
44402: ARRAY
44403: PPUSH
44404: LD_INT 2
44406: PUSH
44407: LD_INT 34
44409: PUSH
44410: LD_INT 13
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: PUSH
44417: LD_INT 34
44419: PUSH
44420: LD_INT 52
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: LIST
44431: PPUSH
44432: CALL_OW 72
44436: ST_TO_ADDR
// if cranes then
44437: LD_VAR 0 6
44441: IFFALSE 44577
// begin for j in cranes do
44443: LD_ADDR_VAR 0 3
44447: PUSH
44448: LD_VAR 0 6
44452: PUSH
44453: FOR_IN
44454: IFFALSE 44575
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44456: LD_VAR 0 3
44460: PPUSH
44461: CALL_OW 256
44465: PUSH
44466: LD_INT 500
44468: GREATEREQUAL
44469: PUSH
44470: LD_VAR 0 3
44474: PPUSH
44475: CALL_OW 314
44479: NOT
44480: AND
44481: IFFALSE 44515
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44483: LD_VAR 0 3
44487: PPUSH
44488: LD_EXP 113
44492: PUSH
44493: LD_VAR 0 2
44497: ARRAY
44498: PPUSH
44499: LD_VAR 0 3
44503: PPUSH
44504: CALL_OW 74
44508: PPUSH
44509: CALL_OW 130
44513: GO 44573
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44515: LD_VAR 0 3
44519: PPUSH
44520: CALL_OW 256
44524: PUSH
44525: LD_INT 500
44527: LESS
44528: PUSH
44529: LD_VAR 0 3
44533: PPUSH
44534: LD_EXP 136
44538: PUSH
44539: LD_VAR 0 2
44543: ARRAY
44544: PPUSH
44545: CALL_OW 308
44549: NOT
44550: AND
44551: IFFALSE 44573
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44553: LD_VAR 0 3
44557: PPUSH
44558: LD_EXP 136
44562: PUSH
44563: LD_VAR 0 2
44567: ARRAY
44568: PPUSH
44569: CALL_OW 113
44573: GO 44453
44575: POP
44576: POP
// end ; if tmp > 3 then
44577: LD_VAR 0 5
44581: PUSH
44582: LD_INT 3
44584: GREATER
44585: IFFALSE 44605
// tmp := ShrinkArray ( tmp , 4 ) ;
44587: LD_ADDR_VAR 0 5
44591: PUSH
44592: LD_VAR 0 5
44596: PPUSH
44597: LD_INT 4
44599: PPUSH
44600: CALL 101289 0 2
44604: ST_TO_ADDR
// if not tmp then
44605: LD_VAR 0 5
44609: NOT
44610: IFFALSE 44614
// continue ;
44612: GO 44070
// for j in tmp do
44614: LD_ADDR_VAR 0 3
44618: PUSH
44619: LD_VAR 0 5
44623: PUSH
44624: FOR_IN
44625: IFFALSE 44884
// begin if IsInUnit ( j ) then
44627: LD_VAR 0 3
44631: PPUSH
44632: CALL_OW 310
44636: IFFALSE 44647
// ComExitBuilding ( j ) ;
44638: LD_VAR 0 3
44642: PPUSH
44643: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44647: LD_VAR 0 3
44651: PUSH
44652: LD_EXP 114
44656: PUSH
44657: LD_VAR 0 2
44661: ARRAY
44662: IN
44663: NOT
44664: IFFALSE 44722
// begin SetTag ( j , 101 ) ;
44666: LD_VAR 0 3
44670: PPUSH
44671: LD_INT 101
44673: PPUSH
44674: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44678: LD_ADDR_EXP 114
44682: PUSH
44683: LD_EXP 114
44687: PPUSH
44688: LD_VAR 0 2
44692: PUSH
44693: LD_EXP 114
44697: PUSH
44698: LD_VAR 0 2
44702: ARRAY
44703: PUSH
44704: LD_INT 1
44706: PLUS
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PPUSH
44712: LD_VAR 0 3
44716: PPUSH
44717: CALL 70050 0 3
44721: ST_TO_ADDR
// end ; wait ( 1 ) ;
44722: LD_INT 1
44724: PPUSH
44725: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44729: LD_ADDR_VAR 0 7
44733: PUSH
44734: LD_EXP 113
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: ST_TO_ADDR
// if mc_scan [ i ] then
44745: LD_EXP 135
44749: PUSH
44750: LD_VAR 0 2
44754: ARRAY
44755: IFFALSE 44817
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
44757: LD_ADDR_VAR 0 7
44761: PUSH
44762: LD_EXP 113
44766: PUSH
44767: LD_VAR 0 2
44771: ARRAY
44772: PPUSH
44773: LD_INT 3
44775: PUSH
44776: LD_INT 30
44778: PUSH
44779: LD_INT 32
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 30
44788: PUSH
44789: LD_INT 33
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 30
44798: PUSH
44799: LD_INT 31
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: EMPTY
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: PPUSH
44812: CALL_OW 72
44816: ST_TO_ADDR
// if not to_repair_tmp then
44817: LD_VAR 0 7
44821: NOT
44822: IFFALSE 44826
// continue ;
44824: GO 44624
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44826: LD_ADDR_VAR 0 8
44830: PUSH
44831: LD_VAR 0 7
44835: PPUSH
44836: LD_VAR 0 3
44840: PPUSH
44841: CALL_OW 74
44845: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
44846: LD_VAR 0 8
44850: PPUSH
44851: LD_INT 16
44853: PPUSH
44854: CALL 72643 0 2
44858: PUSH
44859: LD_INT 4
44861: ARRAY
44862: PUSH
44863: LD_INT 5
44865: LESS
44866: IFFALSE 44882
// ComRepairBuilding ( j , to_repair ) ;
44868: LD_VAR 0 3
44872: PPUSH
44873: LD_VAR 0 8
44877: PPUSH
44878: CALL_OW 130
// end ;
44882: GO 44624
44884: POP
44885: POP
// end ;
44886: GO 44070
44888: POP
44889: POP
// end ;
44890: LD_VAR 0 1
44894: RET
// export function MC_Heal ; var i , j , tmp ; begin
44895: LD_INT 0
44897: PPUSH
44898: PPUSH
44899: PPUSH
44900: PPUSH
// if not mc_bases then
44901: LD_EXP 112
44905: NOT
44906: IFFALSE 44910
// exit ;
44908: GO 45312
// for i = 1 to mc_bases do
44910: LD_ADDR_VAR 0 2
44914: PUSH
44915: DOUBLE
44916: LD_INT 1
44918: DEC
44919: ST_TO_ADDR
44920: LD_EXP 112
44924: PUSH
44925: FOR_TO
44926: IFFALSE 45310
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44928: LD_EXP 115
44932: PUSH
44933: LD_VAR 0 2
44937: ARRAY
44938: PUSH
44939: LD_INT 1
44941: ARRAY
44942: NOT
44943: PUSH
44944: LD_EXP 115
44948: PUSH
44949: LD_VAR 0 2
44953: ARRAY
44954: PUSH
44955: LD_INT 2
44957: ARRAY
44958: NOT
44959: AND
44960: IFFALSE 44998
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44962: LD_ADDR_EXP 116
44966: PUSH
44967: LD_EXP 116
44971: PPUSH
44972: LD_VAR 0 2
44976: PPUSH
44977: EMPTY
44978: PPUSH
44979: CALL_OW 1
44983: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44984: LD_VAR 0 2
44988: PPUSH
44989: LD_INT 102
44991: PPUSH
44992: CALL 39159 0 2
// continue ;
44996: GO 44925
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44998: LD_ADDR_VAR 0 4
45002: PUSH
45003: LD_EXP 112
45007: PUSH
45008: LD_VAR 0 2
45012: ARRAY
45013: PPUSH
45014: LD_INT 25
45016: PUSH
45017: LD_INT 4
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PPUSH
45024: CALL_OW 72
45028: ST_TO_ADDR
// if not tmp then
45029: LD_VAR 0 4
45033: NOT
45034: IFFALSE 45038
// continue ;
45036: GO 44925
// if mc_taming [ i ] then
45038: LD_EXP 143
45042: PUSH
45043: LD_VAR 0 2
45047: ARRAY
45048: IFFALSE 45072
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45050: LD_ADDR_EXP 143
45054: PUSH
45055: LD_EXP 143
45059: PPUSH
45060: LD_VAR 0 2
45064: PPUSH
45065: EMPTY
45066: PPUSH
45067: CALL_OW 1
45071: ST_TO_ADDR
// for j in tmp do
45072: LD_ADDR_VAR 0 3
45076: PUSH
45077: LD_VAR 0 4
45081: PUSH
45082: FOR_IN
45083: IFFALSE 45306
// begin if IsInUnit ( j ) then
45085: LD_VAR 0 3
45089: PPUSH
45090: CALL_OW 310
45094: IFFALSE 45105
// ComExitBuilding ( j ) ;
45096: LD_VAR 0 3
45100: PPUSH
45101: CALL_OW 122
// if not j in mc_healers [ i ] then
45105: LD_VAR 0 3
45109: PUSH
45110: LD_EXP 116
45114: PUSH
45115: LD_VAR 0 2
45119: ARRAY
45120: IN
45121: NOT
45122: IFFALSE 45168
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45124: LD_ADDR_EXP 116
45128: PUSH
45129: LD_EXP 116
45133: PPUSH
45134: LD_VAR 0 2
45138: PUSH
45139: LD_EXP 116
45143: PUSH
45144: LD_VAR 0 2
45148: ARRAY
45149: PUSH
45150: LD_INT 1
45152: PLUS
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PPUSH
45158: LD_VAR 0 3
45162: PPUSH
45163: CALL 70050 0 3
45167: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45168: LD_VAR 0 3
45172: PPUSH
45173: CALL_OW 110
45177: PUSH
45178: LD_INT 102
45180: NONEQUAL
45181: IFFALSE 45195
// SetTag ( j , 102 ) ;
45183: LD_VAR 0 3
45187: PPUSH
45188: LD_INT 102
45190: PPUSH
45191: CALL_OW 109
// Wait ( 3 ) ;
45195: LD_INT 3
45197: PPUSH
45198: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45202: LD_EXP 115
45206: PUSH
45207: LD_VAR 0 2
45211: ARRAY
45212: PUSH
45213: LD_INT 1
45215: ARRAY
45216: IFFALSE 45248
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45218: LD_VAR 0 3
45222: PPUSH
45223: LD_EXP 115
45227: PUSH
45228: LD_VAR 0 2
45232: ARRAY
45233: PUSH
45234: LD_INT 1
45236: ARRAY
45237: PUSH
45238: LD_INT 1
45240: ARRAY
45241: PPUSH
45242: CALL_OW 128
45246: GO 45304
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45248: LD_VAR 0 3
45252: PPUSH
45253: CALL_OW 314
45257: NOT
45258: PUSH
45259: LD_EXP 115
45263: PUSH
45264: LD_VAR 0 2
45268: ARRAY
45269: PUSH
45270: LD_INT 2
45272: ARRAY
45273: AND
45274: IFFALSE 45304
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45276: LD_VAR 0 3
45280: PPUSH
45281: LD_EXP 115
45285: PUSH
45286: LD_VAR 0 2
45290: ARRAY
45291: PUSH
45292: LD_INT 2
45294: ARRAY
45295: PUSH
45296: LD_INT 1
45298: ARRAY
45299: PPUSH
45300: CALL_OW 128
// end ;
45304: GO 45082
45306: POP
45307: POP
// end ;
45308: GO 44925
45310: POP
45311: POP
// end ;
45312: LD_VAR 0 1
45316: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45317: LD_INT 0
45319: PPUSH
45320: PPUSH
45321: PPUSH
45322: PPUSH
45323: PPUSH
// if not mc_bases then
45324: LD_EXP 112
45328: NOT
45329: IFFALSE 45333
// exit ;
45331: GO 46476
// for i = 1 to mc_bases do
45333: LD_ADDR_VAR 0 2
45337: PUSH
45338: DOUBLE
45339: LD_INT 1
45341: DEC
45342: ST_TO_ADDR
45343: LD_EXP 112
45347: PUSH
45348: FOR_TO
45349: IFFALSE 46474
// begin if mc_scan [ i ] then
45351: LD_EXP 135
45355: PUSH
45356: LD_VAR 0 2
45360: ARRAY
45361: IFFALSE 45365
// continue ;
45363: GO 45348
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45365: LD_EXP 117
45369: PUSH
45370: LD_VAR 0 2
45374: ARRAY
45375: NOT
45376: PUSH
45377: LD_EXP 119
45381: PUSH
45382: LD_VAR 0 2
45386: ARRAY
45387: NOT
45388: AND
45389: PUSH
45390: LD_EXP 118
45394: PUSH
45395: LD_VAR 0 2
45399: ARRAY
45400: AND
45401: IFFALSE 45439
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45403: LD_ADDR_EXP 118
45407: PUSH
45408: LD_EXP 118
45412: PPUSH
45413: LD_VAR 0 2
45417: PPUSH
45418: EMPTY
45419: PPUSH
45420: CALL_OW 1
45424: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45425: LD_VAR 0 2
45429: PPUSH
45430: LD_INT 103
45432: PPUSH
45433: CALL 39159 0 2
// continue ;
45437: GO 45348
// end ; if mc_construct_list [ i ] then
45439: LD_EXP 119
45443: PUSH
45444: LD_VAR 0 2
45448: ARRAY
45449: IFFALSE 45669
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45451: LD_ADDR_VAR 0 4
45455: PUSH
45456: LD_EXP 112
45460: PUSH
45461: LD_VAR 0 2
45465: ARRAY
45466: PPUSH
45467: LD_INT 25
45469: PUSH
45470: LD_INT 2
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: PPUSH
45477: CALL_OW 72
45481: PUSH
45482: LD_EXP 114
45486: PUSH
45487: LD_VAR 0 2
45491: ARRAY
45492: DIFF
45493: ST_TO_ADDR
// if not tmp then
45494: LD_VAR 0 4
45498: NOT
45499: IFFALSE 45503
// continue ;
45501: GO 45348
// for j in tmp do
45503: LD_ADDR_VAR 0 3
45507: PUSH
45508: LD_VAR 0 4
45512: PUSH
45513: FOR_IN
45514: IFFALSE 45665
// begin if not mc_builders [ i ] then
45516: LD_EXP 118
45520: PUSH
45521: LD_VAR 0 2
45525: ARRAY
45526: NOT
45527: IFFALSE 45585
// begin SetTag ( j , 103 ) ;
45529: LD_VAR 0 3
45533: PPUSH
45534: LD_INT 103
45536: PPUSH
45537: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45541: LD_ADDR_EXP 118
45545: PUSH
45546: LD_EXP 118
45550: PPUSH
45551: LD_VAR 0 2
45555: PUSH
45556: LD_EXP 118
45560: PUSH
45561: LD_VAR 0 2
45565: ARRAY
45566: PUSH
45567: LD_INT 1
45569: PLUS
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PPUSH
45575: LD_VAR 0 3
45579: PPUSH
45580: CALL 70050 0 3
45584: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45585: LD_VAR 0 3
45589: PPUSH
45590: CALL_OW 310
45594: IFFALSE 45605
// ComExitBuilding ( j ) ;
45596: LD_VAR 0 3
45600: PPUSH
45601: CALL_OW 122
// wait ( 3 ) ;
45605: LD_INT 3
45607: PPUSH
45608: CALL_OW 67
// if not mc_construct_list [ i ] then
45612: LD_EXP 119
45616: PUSH
45617: LD_VAR 0 2
45621: ARRAY
45622: NOT
45623: IFFALSE 45627
// break ;
45625: GO 45665
// if not HasTask ( j ) then
45627: LD_VAR 0 3
45631: PPUSH
45632: CALL_OW 314
45636: NOT
45637: IFFALSE 45663
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45639: LD_VAR 0 3
45643: PPUSH
45644: LD_EXP 119
45648: PUSH
45649: LD_VAR 0 2
45653: ARRAY
45654: PUSH
45655: LD_INT 1
45657: ARRAY
45658: PPUSH
45659: CALL 72901 0 2
// end ;
45663: GO 45513
45665: POP
45666: POP
// end else
45667: GO 46472
// if mc_build_list [ i ] then
45669: LD_EXP 117
45673: PUSH
45674: LD_VAR 0 2
45678: ARRAY
45679: IFFALSE 46472
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45681: LD_ADDR_VAR 0 5
45685: PUSH
45686: LD_EXP 112
45690: PUSH
45691: LD_VAR 0 2
45695: ARRAY
45696: PPUSH
45697: LD_INT 2
45699: PUSH
45700: LD_INT 30
45702: PUSH
45703: LD_INT 0
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: PUSH
45710: LD_INT 30
45712: PUSH
45713: LD_INT 1
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: LIST
45724: PPUSH
45725: CALL_OW 72
45729: ST_TO_ADDR
// if depot then
45730: LD_VAR 0 5
45734: IFFALSE 45752
// depot := depot [ 1 ] else
45736: LD_ADDR_VAR 0 5
45740: PUSH
45741: LD_VAR 0 5
45745: PUSH
45746: LD_INT 1
45748: ARRAY
45749: ST_TO_ADDR
45750: GO 45760
// depot := 0 ;
45752: LD_ADDR_VAR 0 5
45756: PUSH
45757: LD_INT 0
45759: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45760: LD_EXP 117
45764: PUSH
45765: LD_VAR 0 2
45769: ARRAY
45770: PUSH
45771: LD_INT 1
45773: ARRAY
45774: PUSH
45775: LD_INT 1
45777: ARRAY
45778: PPUSH
45779: CALL 72731 0 1
45783: PUSH
45784: LD_EXP 112
45788: PUSH
45789: LD_VAR 0 2
45793: ARRAY
45794: PPUSH
45795: LD_INT 2
45797: PUSH
45798: LD_INT 30
45800: PUSH
45801: LD_INT 2
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 30
45810: PUSH
45811: LD_INT 3
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: LIST
45822: PPUSH
45823: CALL_OW 72
45827: NOT
45828: AND
45829: IFFALSE 45934
// begin for j = 1 to mc_build_list [ i ] do
45831: LD_ADDR_VAR 0 3
45835: PUSH
45836: DOUBLE
45837: LD_INT 1
45839: DEC
45840: ST_TO_ADDR
45841: LD_EXP 117
45845: PUSH
45846: LD_VAR 0 2
45850: ARRAY
45851: PUSH
45852: FOR_TO
45853: IFFALSE 45932
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45855: LD_EXP 117
45859: PUSH
45860: LD_VAR 0 2
45864: ARRAY
45865: PUSH
45866: LD_VAR 0 3
45870: ARRAY
45871: PUSH
45872: LD_INT 1
45874: ARRAY
45875: PUSH
45876: LD_INT 2
45878: EQUAL
45879: IFFALSE 45930
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45881: LD_ADDR_EXP 117
45885: PUSH
45886: LD_EXP 117
45890: PPUSH
45891: LD_VAR 0 2
45895: PPUSH
45896: LD_EXP 117
45900: PUSH
45901: LD_VAR 0 2
45905: ARRAY
45906: PPUSH
45907: LD_VAR 0 3
45911: PPUSH
45912: LD_INT 1
45914: PPUSH
45915: LD_INT 0
45917: PPUSH
45918: CALL 69468 0 4
45922: PPUSH
45923: CALL_OW 1
45927: ST_TO_ADDR
// break ;
45928: GO 45932
// end ;
45930: GO 45852
45932: POP
45933: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45934: LD_EXP 117
45938: PUSH
45939: LD_VAR 0 2
45943: ARRAY
45944: PUSH
45945: LD_INT 1
45947: ARRAY
45948: PUSH
45949: LD_INT 1
45951: ARRAY
45952: PUSH
45953: LD_INT 0
45955: EQUAL
45956: PUSH
45957: LD_VAR 0 5
45961: PUSH
45962: LD_VAR 0 5
45966: PPUSH
45967: LD_EXP 117
45971: PUSH
45972: LD_VAR 0 2
45976: ARRAY
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_INT 1
45984: ARRAY
45985: PPUSH
45986: LD_EXP 117
45990: PUSH
45991: LD_VAR 0 2
45995: ARRAY
45996: PUSH
45997: LD_INT 1
45999: ARRAY
46000: PUSH
46001: LD_INT 2
46003: ARRAY
46004: PPUSH
46005: LD_EXP 117
46009: PUSH
46010: LD_VAR 0 2
46014: ARRAY
46015: PUSH
46016: LD_INT 1
46018: ARRAY
46019: PUSH
46020: LD_INT 3
46022: ARRAY
46023: PPUSH
46024: LD_EXP 117
46028: PUSH
46029: LD_VAR 0 2
46033: ARRAY
46034: PUSH
46035: LD_INT 1
46037: ARRAY
46038: PUSH
46039: LD_INT 4
46041: ARRAY
46042: PPUSH
46043: CALL 77465 0 5
46047: AND
46048: OR
46049: IFFALSE 46330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46051: LD_ADDR_VAR 0 4
46055: PUSH
46056: LD_EXP 112
46060: PUSH
46061: LD_VAR 0 2
46065: ARRAY
46066: PPUSH
46067: LD_INT 25
46069: PUSH
46070: LD_INT 2
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PPUSH
46077: CALL_OW 72
46081: PUSH
46082: LD_EXP 114
46086: PUSH
46087: LD_VAR 0 2
46091: ARRAY
46092: DIFF
46093: ST_TO_ADDR
// if not tmp then
46094: LD_VAR 0 4
46098: NOT
46099: IFFALSE 46103
// continue ;
46101: GO 45348
// for j in tmp do
46103: LD_ADDR_VAR 0 3
46107: PUSH
46108: LD_VAR 0 4
46112: PUSH
46113: FOR_IN
46114: IFFALSE 46326
// begin if not mc_builders [ i ] then
46116: LD_EXP 118
46120: PUSH
46121: LD_VAR 0 2
46125: ARRAY
46126: NOT
46127: IFFALSE 46185
// begin SetTag ( j , 103 ) ;
46129: LD_VAR 0 3
46133: PPUSH
46134: LD_INT 103
46136: PPUSH
46137: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46141: LD_ADDR_EXP 118
46145: PUSH
46146: LD_EXP 118
46150: PPUSH
46151: LD_VAR 0 2
46155: PUSH
46156: LD_EXP 118
46160: PUSH
46161: LD_VAR 0 2
46165: ARRAY
46166: PUSH
46167: LD_INT 1
46169: PLUS
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PPUSH
46175: LD_VAR 0 3
46179: PPUSH
46180: CALL 70050 0 3
46184: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46185: LD_VAR 0 3
46189: PPUSH
46190: CALL_OW 310
46194: IFFALSE 46205
// ComExitBuilding ( j ) ;
46196: LD_VAR 0 3
46200: PPUSH
46201: CALL_OW 122
// wait ( 3 ) ;
46205: LD_INT 3
46207: PPUSH
46208: CALL_OW 67
// if not mc_build_list [ i ] then
46212: LD_EXP 117
46216: PUSH
46217: LD_VAR 0 2
46221: ARRAY
46222: NOT
46223: IFFALSE 46227
// break ;
46225: GO 46326
// if not HasTask ( j ) then
46227: LD_VAR 0 3
46231: PPUSH
46232: CALL_OW 314
46236: NOT
46237: IFFALSE 46324
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46239: LD_VAR 0 3
46243: PPUSH
46244: LD_EXP 117
46248: PUSH
46249: LD_VAR 0 2
46253: ARRAY
46254: PUSH
46255: LD_INT 1
46257: ARRAY
46258: PUSH
46259: LD_INT 1
46261: ARRAY
46262: PPUSH
46263: LD_EXP 117
46267: PUSH
46268: LD_VAR 0 2
46272: ARRAY
46273: PUSH
46274: LD_INT 1
46276: ARRAY
46277: PUSH
46278: LD_INT 2
46280: ARRAY
46281: PPUSH
46282: LD_EXP 117
46286: PUSH
46287: LD_VAR 0 2
46291: ARRAY
46292: PUSH
46293: LD_INT 1
46295: ARRAY
46296: PUSH
46297: LD_INT 3
46299: ARRAY
46300: PPUSH
46301: LD_EXP 117
46305: PUSH
46306: LD_VAR 0 2
46310: ARRAY
46311: PUSH
46312: LD_INT 1
46314: ARRAY
46315: PUSH
46316: LD_INT 4
46318: ARRAY
46319: PPUSH
46320: CALL_OW 145
// end ;
46324: GO 46113
46326: POP
46327: POP
// end else
46328: GO 46472
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46330: LD_EXP 112
46334: PUSH
46335: LD_VAR 0 2
46339: ARRAY
46340: PPUSH
46341: LD_EXP 117
46345: PUSH
46346: LD_VAR 0 2
46350: ARRAY
46351: PUSH
46352: LD_INT 1
46354: ARRAY
46355: PUSH
46356: LD_INT 1
46358: ARRAY
46359: PPUSH
46360: LD_EXP 117
46364: PUSH
46365: LD_VAR 0 2
46369: ARRAY
46370: PUSH
46371: LD_INT 1
46373: ARRAY
46374: PUSH
46375: LD_INT 2
46377: ARRAY
46378: PPUSH
46379: LD_EXP 117
46383: PUSH
46384: LD_VAR 0 2
46388: ARRAY
46389: PUSH
46390: LD_INT 1
46392: ARRAY
46393: PUSH
46394: LD_INT 3
46396: ARRAY
46397: PPUSH
46398: LD_EXP 117
46402: PUSH
46403: LD_VAR 0 2
46407: ARRAY
46408: PUSH
46409: LD_INT 1
46411: ARRAY
46412: PUSH
46413: LD_INT 4
46415: ARRAY
46416: PPUSH
46417: CALL 76801 0 5
46421: NOT
46422: IFFALSE 46472
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46424: LD_ADDR_EXP 117
46428: PUSH
46429: LD_EXP 117
46433: PPUSH
46434: LD_VAR 0 2
46438: PPUSH
46439: LD_EXP 117
46443: PUSH
46444: LD_VAR 0 2
46448: ARRAY
46449: PPUSH
46450: LD_INT 1
46452: PPUSH
46453: LD_INT 1
46455: NEG
46456: PPUSH
46457: LD_INT 0
46459: PPUSH
46460: CALL 69468 0 4
46464: PPUSH
46465: CALL_OW 1
46469: ST_TO_ADDR
// continue ;
46470: GO 45348
// end ; end ; end ;
46472: GO 45348
46474: POP
46475: POP
// end ;
46476: LD_VAR 0 1
46480: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46481: LD_INT 0
46483: PPUSH
46484: PPUSH
46485: PPUSH
46486: PPUSH
46487: PPUSH
46488: PPUSH
// if not mc_bases then
46489: LD_EXP 112
46493: NOT
46494: IFFALSE 46498
// exit ;
46496: GO 46925
// for i = 1 to mc_bases do
46498: LD_ADDR_VAR 0 2
46502: PUSH
46503: DOUBLE
46504: LD_INT 1
46506: DEC
46507: ST_TO_ADDR
46508: LD_EXP 112
46512: PUSH
46513: FOR_TO
46514: IFFALSE 46923
// begin tmp := mc_build_upgrade [ i ] ;
46516: LD_ADDR_VAR 0 4
46520: PUSH
46521: LD_EXP 144
46525: PUSH
46526: LD_VAR 0 2
46530: ARRAY
46531: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46532: LD_ADDR_VAR 0 6
46536: PUSH
46537: LD_EXP 145
46541: PUSH
46542: LD_VAR 0 2
46546: ARRAY
46547: PPUSH
46548: LD_INT 2
46550: PUSH
46551: LD_INT 30
46553: PUSH
46554: LD_INT 6
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: LD_INT 30
46563: PUSH
46564: LD_INT 7
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: LIST
46575: PPUSH
46576: CALL_OW 72
46580: ST_TO_ADDR
// if not tmp and not lab then
46581: LD_VAR 0 4
46585: NOT
46586: PUSH
46587: LD_VAR 0 6
46591: NOT
46592: AND
46593: IFFALSE 46597
// continue ;
46595: GO 46513
// if tmp then
46597: LD_VAR 0 4
46601: IFFALSE 46721
// for j in tmp do
46603: LD_ADDR_VAR 0 3
46607: PUSH
46608: LD_VAR 0 4
46612: PUSH
46613: FOR_IN
46614: IFFALSE 46719
// begin if UpgradeCost ( j ) then
46616: LD_VAR 0 3
46620: PPUSH
46621: CALL 76461 0 1
46625: IFFALSE 46717
// begin ComUpgrade ( j ) ;
46627: LD_VAR 0 3
46631: PPUSH
46632: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46636: LD_ADDR_EXP 144
46640: PUSH
46641: LD_EXP 144
46645: PPUSH
46646: LD_VAR 0 2
46650: PPUSH
46651: LD_EXP 144
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 3
46666: DIFF
46667: PPUSH
46668: CALL_OW 1
46672: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46673: LD_ADDR_EXP 119
46677: PUSH
46678: LD_EXP 119
46682: PPUSH
46683: LD_VAR 0 2
46687: PUSH
46688: LD_EXP 119
46692: PUSH
46693: LD_VAR 0 2
46697: ARRAY
46698: PUSH
46699: LD_INT 1
46701: PLUS
46702: PUSH
46703: EMPTY
46704: LIST
46705: LIST
46706: PPUSH
46707: LD_VAR 0 3
46711: PPUSH
46712: CALL 70050 0 3
46716: ST_TO_ADDR
// end ; end ;
46717: GO 46613
46719: POP
46720: POP
// if not lab or not mc_lab_upgrade [ i ] then
46721: LD_VAR 0 6
46725: NOT
46726: PUSH
46727: LD_EXP 146
46731: PUSH
46732: LD_VAR 0 2
46736: ARRAY
46737: NOT
46738: OR
46739: IFFALSE 46743
// continue ;
46741: GO 46513
// for j in lab do
46743: LD_ADDR_VAR 0 3
46747: PUSH
46748: LD_VAR 0 6
46752: PUSH
46753: FOR_IN
46754: IFFALSE 46919
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46756: LD_VAR 0 3
46760: PPUSH
46761: CALL_OW 266
46765: PUSH
46766: LD_INT 6
46768: PUSH
46769: LD_INT 7
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: IN
46776: PUSH
46777: LD_VAR 0 3
46781: PPUSH
46782: CALL_OW 461
46786: PUSH
46787: LD_INT 1
46789: NONEQUAL
46790: AND
46791: IFFALSE 46917
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46793: LD_VAR 0 3
46797: PPUSH
46798: LD_EXP 146
46802: PUSH
46803: LD_VAR 0 2
46807: ARRAY
46808: PUSH
46809: LD_INT 1
46811: ARRAY
46812: PPUSH
46813: CALL 76666 0 2
46817: IFFALSE 46917
// begin ComCancel ( j ) ;
46819: LD_VAR 0 3
46823: PPUSH
46824: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46828: LD_VAR 0 3
46832: PPUSH
46833: LD_EXP 146
46837: PUSH
46838: LD_VAR 0 2
46842: ARRAY
46843: PUSH
46844: LD_INT 1
46846: ARRAY
46847: PPUSH
46848: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46852: LD_VAR 0 3
46856: PUSH
46857: LD_EXP 119
46861: PUSH
46862: LD_VAR 0 2
46866: ARRAY
46867: IN
46868: NOT
46869: IFFALSE 46915
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46871: LD_ADDR_EXP 119
46875: PUSH
46876: LD_EXP 119
46880: PPUSH
46881: LD_VAR 0 2
46885: PUSH
46886: LD_EXP 119
46890: PUSH
46891: LD_VAR 0 2
46895: ARRAY
46896: PUSH
46897: LD_INT 1
46899: PLUS
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: PPUSH
46905: LD_VAR 0 3
46909: PPUSH
46910: CALL 70050 0 3
46914: ST_TO_ADDR
// break ;
46915: GO 46919
// end ; end ; end ;
46917: GO 46753
46919: POP
46920: POP
// end ;
46921: GO 46513
46923: POP
46924: POP
// end ;
46925: LD_VAR 0 1
46929: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46930: LD_INT 0
46932: PPUSH
46933: PPUSH
46934: PPUSH
46935: PPUSH
46936: PPUSH
46937: PPUSH
46938: PPUSH
46939: PPUSH
46940: PPUSH
// if not mc_bases then
46941: LD_EXP 112
46945: NOT
46946: IFFALSE 46950
// exit ;
46948: GO 47355
// for i = 1 to mc_bases do
46950: LD_ADDR_VAR 0 2
46954: PUSH
46955: DOUBLE
46956: LD_INT 1
46958: DEC
46959: ST_TO_ADDR
46960: LD_EXP 112
46964: PUSH
46965: FOR_TO
46966: IFFALSE 47353
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46968: LD_EXP 120
46972: PUSH
46973: LD_VAR 0 2
46977: ARRAY
46978: NOT
46979: PUSH
46980: LD_EXP 112
46984: PUSH
46985: LD_VAR 0 2
46989: ARRAY
46990: PPUSH
46991: LD_INT 30
46993: PUSH
46994: LD_INT 3
46996: PUSH
46997: EMPTY
46998: LIST
46999: LIST
47000: PPUSH
47001: CALL_OW 72
47005: NOT
47006: OR
47007: IFFALSE 47011
// continue ;
47009: GO 46965
// busy := false ;
47011: LD_ADDR_VAR 0 8
47015: PUSH
47016: LD_INT 0
47018: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47019: LD_ADDR_VAR 0 4
47023: PUSH
47024: LD_EXP 112
47028: PUSH
47029: LD_VAR 0 2
47033: ARRAY
47034: PPUSH
47035: LD_INT 30
47037: PUSH
47038: LD_INT 3
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PPUSH
47045: CALL_OW 72
47049: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47050: LD_ADDR_VAR 0 6
47054: PUSH
47055: LD_EXP 120
47059: PUSH
47060: LD_VAR 0 2
47064: ARRAY
47065: PPUSH
47066: LD_INT 2
47068: PUSH
47069: LD_INT 30
47071: PUSH
47072: LD_INT 32
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PUSH
47079: LD_INT 30
47081: PUSH
47082: LD_INT 33
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: LIST
47093: PPUSH
47094: CALL_OW 72
47098: ST_TO_ADDR
// if not t then
47099: LD_VAR 0 6
47103: NOT
47104: IFFALSE 47108
// continue ;
47106: GO 46965
// for j in tmp do
47108: LD_ADDR_VAR 0 3
47112: PUSH
47113: LD_VAR 0 4
47117: PUSH
47118: FOR_IN
47119: IFFALSE 47149
// if not BuildingStatus ( j ) = bs_idle then
47121: LD_VAR 0 3
47125: PPUSH
47126: CALL_OW 461
47130: PUSH
47131: LD_INT 2
47133: EQUAL
47134: NOT
47135: IFFALSE 47147
// begin busy := true ;
47137: LD_ADDR_VAR 0 8
47141: PUSH
47142: LD_INT 1
47144: ST_TO_ADDR
// break ;
47145: GO 47149
// end ;
47147: GO 47118
47149: POP
47150: POP
// if busy then
47151: LD_VAR 0 8
47155: IFFALSE 47159
// continue ;
47157: GO 46965
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47159: LD_ADDR_VAR 0 7
47163: PUSH
47164: LD_VAR 0 6
47168: PPUSH
47169: LD_INT 35
47171: PUSH
47172: LD_INT 0
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PPUSH
47179: CALL_OW 72
47183: ST_TO_ADDR
// if tw then
47184: LD_VAR 0 7
47188: IFFALSE 47265
// begin tw := tw [ 1 ] ;
47190: LD_ADDR_VAR 0 7
47194: PUSH
47195: LD_VAR 0 7
47199: PUSH
47200: LD_INT 1
47202: ARRAY
47203: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47204: LD_ADDR_VAR 0 9
47208: PUSH
47209: LD_VAR 0 7
47213: PPUSH
47214: LD_EXP 137
47218: PUSH
47219: LD_VAR 0 2
47223: ARRAY
47224: PPUSH
47225: CALL 75020 0 2
47229: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47230: LD_EXP 151
47234: PUSH
47235: LD_VAR 0 2
47239: ARRAY
47240: IFFALSE 47263
// if not weapon in mc_allowed_tower_weapons [ i ] then
47242: LD_VAR 0 9
47246: PUSH
47247: LD_EXP 151
47251: PUSH
47252: LD_VAR 0 2
47256: ARRAY
47257: IN
47258: NOT
47259: IFFALSE 47263
// continue ;
47261: GO 46965
// end else
47263: GO 47328
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47265: LD_ADDR_VAR 0 5
47269: PUSH
47270: LD_EXP 120
47274: PUSH
47275: LD_VAR 0 2
47279: ARRAY
47280: PPUSH
47281: LD_VAR 0 4
47285: PPUSH
47286: CALL 100522 0 2
47290: ST_TO_ADDR
// if not tmp2 then
47291: LD_VAR 0 5
47295: NOT
47296: IFFALSE 47300
// continue ;
47298: GO 46965
// tw := tmp2 [ 1 ] ;
47300: LD_ADDR_VAR 0 7
47304: PUSH
47305: LD_VAR 0 5
47309: PUSH
47310: LD_INT 1
47312: ARRAY
47313: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47314: LD_ADDR_VAR 0 9
47318: PUSH
47319: LD_VAR 0 5
47323: PUSH
47324: LD_INT 2
47326: ARRAY
47327: ST_TO_ADDR
// end ; if not weapon then
47328: LD_VAR 0 9
47332: NOT
47333: IFFALSE 47337
// continue ;
47335: GO 46965
// ComPlaceWeapon ( tw , weapon ) ;
47337: LD_VAR 0 7
47341: PPUSH
47342: LD_VAR 0 9
47346: PPUSH
47347: CALL_OW 148
// end ;
47351: GO 46965
47353: POP
47354: POP
// end ;
47355: LD_VAR 0 1
47359: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47360: LD_INT 0
47362: PPUSH
47363: PPUSH
47364: PPUSH
47365: PPUSH
47366: PPUSH
47367: PPUSH
// if not mc_bases then
47368: LD_EXP 112
47372: NOT
47373: IFFALSE 47377
// exit ;
47375: GO 48153
// for i = 1 to mc_bases do
47377: LD_ADDR_VAR 0 2
47381: PUSH
47382: DOUBLE
47383: LD_INT 1
47385: DEC
47386: ST_TO_ADDR
47387: LD_EXP 112
47391: PUSH
47392: FOR_TO
47393: IFFALSE 48151
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47395: LD_EXP 125
47399: PUSH
47400: LD_VAR 0 2
47404: ARRAY
47405: NOT
47406: PUSH
47407: LD_EXP 125
47411: PUSH
47412: LD_VAR 0 2
47416: ARRAY
47417: PUSH
47418: LD_EXP 126
47422: PUSH
47423: LD_VAR 0 2
47427: ARRAY
47428: EQUAL
47429: OR
47430: PUSH
47431: LD_EXP 135
47435: PUSH
47436: LD_VAR 0 2
47440: ARRAY
47441: OR
47442: IFFALSE 47446
// continue ;
47444: GO 47392
// if mc_miners [ i ] then
47446: LD_EXP 126
47450: PUSH
47451: LD_VAR 0 2
47455: ARRAY
47456: IFFALSE 47838
// begin for j = mc_miners [ i ] downto 1 do
47458: LD_ADDR_VAR 0 3
47462: PUSH
47463: DOUBLE
47464: LD_EXP 126
47468: PUSH
47469: LD_VAR 0 2
47473: ARRAY
47474: INC
47475: ST_TO_ADDR
47476: LD_INT 1
47478: PUSH
47479: FOR_DOWNTO
47480: IFFALSE 47836
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47482: LD_EXP 126
47486: PUSH
47487: LD_VAR 0 2
47491: ARRAY
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PPUSH
47499: CALL_OW 301
47503: PUSH
47504: LD_EXP 126
47508: PUSH
47509: LD_VAR 0 2
47513: ARRAY
47514: PUSH
47515: LD_VAR 0 3
47519: ARRAY
47520: PPUSH
47521: CALL_OW 257
47525: PUSH
47526: LD_INT 1
47528: NONEQUAL
47529: OR
47530: IFFALSE 47593
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47532: LD_ADDR_VAR 0 5
47536: PUSH
47537: LD_EXP 126
47541: PUSH
47542: LD_VAR 0 2
47546: ARRAY
47547: PUSH
47548: LD_EXP 126
47552: PUSH
47553: LD_VAR 0 2
47557: ARRAY
47558: PUSH
47559: LD_VAR 0 3
47563: ARRAY
47564: DIFF
47565: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47566: LD_ADDR_EXP 126
47570: PUSH
47571: LD_EXP 126
47575: PPUSH
47576: LD_VAR 0 2
47580: PPUSH
47581: LD_VAR 0 5
47585: PPUSH
47586: CALL_OW 1
47590: ST_TO_ADDR
// continue ;
47591: GO 47479
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47593: LD_EXP 126
47597: PUSH
47598: LD_VAR 0 2
47602: ARRAY
47603: PUSH
47604: LD_VAR 0 3
47608: ARRAY
47609: PPUSH
47610: CALL_OW 257
47614: PUSH
47615: LD_INT 1
47617: EQUAL
47618: PUSH
47619: LD_EXP 126
47623: PUSH
47624: LD_VAR 0 2
47628: ARRAY
47629: PUSH
47630: LD_VAR 0 3
47634: ARRAY
47635: PPUSH
47636: CALL_OW 459
47640: NOT
47641: AND
47642: PUSH
47643: LD_EXP 126
47647: PUSH
47648: LD_VAR 0 2
47652: ARRAY
47653: PUSH
47654: LD_VAR 0 3
47658: ARRAY
47659: PPUSH
47660: CALL_OW 314
47664: NOT
47665: AND
47666: IFFALSE 47834
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47668: LD_EXP 126
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: PUSH
47679: LD_VAR 0 3
47683: ARRAY
47684: PPUSH
47685: CALL_OW 310
47689: IFFALSE 47712
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47691: LD_EXP 126
47695: PUSH
47696: LD_VAR 0 2
47700: ARRAY
47701: PUSH
47702: LD_VAR 0 3
47706: ARRAY
47707: PPUSH
47708: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47712: LD_EXP 126
47716: PUSH
47717: LD_VAR 0 2
47721: ARRAY
47722: PUSH
47723: LD_VAR 0 3
47727: ARRAY
47728: PPUSH
47729: CALL_OW 314
47733: NOT
47734: IFFALSE 47834
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47736: LD_EXP 126
47740: PUSH
47741: LD_VAR 0 2
47745: ARRAY
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: PPUSH
47753: LD_EXP 125
47757: PUSH
47758: LD_VAR 0 2
47762: ARRAY
47763: PUSH
47764: LD_VAR 0 3
47768: PUSH
47769: LD_EXP 125
47773: PUSH
47774: LD_VAR 0 2
47778: ARRAY
47779: MOD
47780: PUSH
47781: LD_INT 1
47783: PLUS
47784: ARRAY
47785: PUSH
47786: LD_INT 1
47788: ARRAY
47789: PPUSH
47790: LD_EXP 125
47794: PUSH
47795: LD_VAR 0 2
47799: ARRAY
47800: PUSH
47801: LD_VAR 0 3
47805: PUSH
47806: LD_EXP 125
47810: PUSH
47811: LD_VAR 0 2
47815: ARRAY
47816: MOD
47817: PUSH
47818: LD_INT 1
47820: PLUS
47821: ARRAY
47822: PUSH
47823: LD_INT 2
47825: ARRAY
47826: PPUSH
47827: LD_INT 0
47829: PPUSH
47830: CALL_OW 193
// end ; end ;
47834: GO 47479
47836: POP
47837: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47838: LD_ADDR_VAR 0 5
47842: PUSH
47843: LD_EXP 112
47847: PUSH
47848: LD_VAR 0 2
47852: ARRAY
47853: PPUSH
47854: LD_INT 2
47856: PUSH
47857: LD_INT 30
47859: PUSH
47860: LD_INT 4
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: PUSH
47867: LD_INT 30
47869: PUSH
47870: LD_INT 5
47872: PUSH
47873: EMPTY
47874: LIST
47875: LIST
47876: PUSH
47877: LD_INT 30
47879: PUSH
47880: LD_INT 32
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: EMPTY
47888: LIST
47889: LIST
47890: LIST
47891: LIST
47892: PPUSH
47893: CALL_OW 72
47897: ST_TO_ADDR
// if not tmp then
47898: LD_VAR 0 5
47902: NOT
47903: IFFALSE 47907
// continue ;
47905: GO 47392
// list := [ ] ;
47907: LD_ADDR_VAR 0 6
47911: PUSH
47912: EMPTY
47913: ST_TO_ADDR
// for j in tmp do
47914: LD_ADDR_VAR 0 3
47918: PUSH
47919: LD_VAR 0 5
47923: PUSH
47924: FOR_IN
47925: IFFALSE 47994
// begin for k in UnitsInside ( j ) do
47927: LD_ADDR_VAR 0 4
47931: PUSH
47932: LD_VAR 0 3
47936: PPUSH
47937: CALL_OW 313
47941: PUSH
47942: FOR_IN
47943: IFFALSE 47990
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47945: LD_VAR 0 4
47949: PPUSH
47950: CALL_OW 257
47954: PUSH
47955: LD_INT 1
47957: EQUAL
47958: PUSH
47959: LD_VAR 0 4
47963: PPUSH
47964: CALL_OW 459
47968: NOT
47969: AND
47970: IFFALSE 47988
// list := list ^ k ;
47972: LD_ADDR_VAR 0 6
47976: PUSH
47977: LD_VAR 0 6
47981: PUSH
47982: LD_VAR 0 4
47986: ADD
47987: ST_TO_ADDR
47988: GO 47942
47990: POP
47991: POP
// end ;
47992: GO 47924
47994: POP
47995: POP
// list := list diff mc_miners [ i ] ;
47996: LD_ADDR_VAR 0 6
48000: PUSH
48001: LD_VAR 0 6
48005: PUSH
48006: LD_EXP 126
48010: PUSH
48011: LD_VAR 0 2
48015: ARRAY
48016: DIFF
48017: ST_TO_ADDR
// if not list then
48018: LD_VAR 0 6
48022: NOT
48023: IFFALSE 48027
// continue ;
48025: GO 47392
// k := mc_mines [ i ] - mc_miners [ i ] ;
48027: LD_ADDR_VAR 0 4
48031: PUSH
48032: LD_EXP 125
48036: PUSH
48037: LD_VAR 0 2
48041: ARRAY
48042: PUSH
48043: LD_EXP 126
48047: PUSH
48048: LD_VAR 0 2
48052: ARRAY
48053: MINUS
48054: ST_TO_ADDR
// if k > list then
48055: LD_VAR 0 4
48059: PUSH
48060: LD_VAR 0 6
48064: GREATER
48065: IFFALSE 48077
// k := list ;
48067: LD_ADDR_VAR 0 4
48071: PUSH
48072: LD_VAR 0 6
48076: ST_TO_ADDR
// for j = 1 to k do
48077: LD_ADDR_VAR 0 3
48081: PUSH
48082: DOUBLE
48083: LD_INT 1
48085: DEC
48086: ST_TO_ADDR
48087: LD_VAR 0 4
48091: PUSH
48092: FOR_TO
48093: IFFALSE 48147
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48095: LD_ADDR_EXP 126
48099: PUSH
48100: LD_EXP 126
48104: PPUSH
48105: LD_VAR 0 2
48109: PUSH
48110: LD_EXP 126
48114: PUSH
48115: LD_VAR 0 2
48119: ARRAY
48120: PUSH
48121: LD_INT 1
48123: PLUS
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: PPUSH
48129: LD_VAR 0 6
48133: PUSH
48134: LD_VAR 0 3
48138: ARRAY
48139: PPUSH
48140: CALL 70050 0 3
48144: ST_TO_ADDR
48145: GO 48092
48147: POP
48148: POP
// end ;
48149: GO 47392
48151: POP
48152: POP
// end ;
48153: LD_VAR 0 1
48157: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
48158: LD_INT 0
48160: PPUSH
48161: PPUSH
48162: PPUSH
48163: PPUSH
48164: PPUSH
48165: PPUSH
48166: PPUSH
48167: PPUSH
48168: PPUSH
48169: PPUSH
// if not mc_bases then
48170: LD_EXP 112
48174: NOT
48175: IFFALSE 48179
// exit ;
48177: GO 49929
// for i = 1 to mc_bases do
48179: LD_ADDR_VAR 0 2
48183: PUSH
48184: DOUBLE
48185: LD_INT 1
48187: DEC
48188: ST_TO_ADDR
48189: LD_EXP 112
48193: PUSH
48194: FOR_TO
48195: IFFALSE 49927
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48197: LD_EXP 112
48201: PUSH
48202: LD_VAR 0 2
48206: ARRAY
48207: NOT
48208: PUSH
48209: LD_EXP 119
48213: PUSH
48214: LD_VAR 0 2
48218: ARRAY
48219: OR
48220: IFFALSE 48224
// continue ;
48222: GO 48194
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48224: LD_EXP 128
48228: PUSH
48229: LD_VAR 0 2
48233: ARRAY
48234: NOT
48235: PUSH
48236: LD_EXP 129
48240: PUSH
48241: LD_VAR 0 2
48245: ARRAY
48246: AND
48247: IFFALSE 48285
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48249: LD_ADDR_EXP 129
48253: PUSH
48254: LD_EXP 129
48258: PPUSH
48259: LD_VAR 0 2
48263: PPUSH
48264: EMPTY
48265: PPUSH
48266: CALL_OW 1
48270: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48271: LD_VAR 0 2
48275: PPUSH
48276: LD_INT 107
48278: PPUSH
48279: CALL 39159 0 2
// continue ;
48283: GO 48194
// end ; target := [ ] ;
48285: LD_ADDR_VAR 0 6
48289: PUSH
48290: EMPTY
48291: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48292: LD_ADDR_VAR 0 3
48296: PUSH
48297: DOUBLE
48298: LD_EXP 128
48302: PUSH
48303: LD_VAR 0 2
48307: ARRAY
48308: INC
48309: ST_TO_ADDR
48310: LD_INT 1
48312: PUSH
48313: FOR_DOWNTO
48314: IFFALSE 48574
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48316: LD_EXP 128
48320: PUSH
48321: LD_VAR 0 2
48325: ARRAY
48326: PUSH
48327: LD_VAR 0 3
48331: ARRAY
48332: PUSH
48333: LD_INT 2
48335: ARRAY
48336: PPUSH
48337: LD_EXP 128
48341: PUSH
48342: LD_VAR 0 2
48346: ARRAY
48347: PUSH
48348: LD_VAR 0 3
48352: ARRAY
48353: PUSH
48354: LD_INT 3
48356: ARRAY
48357: PPUSH
48358: CALL_OW 488
48362: PUSH
48363: LD_EXP 128
48367: PUSH
48368: LD_VAR 0 2
48372: ARRAY
48373: PUSH
48374: LD_VAR 0 3
48378: ARRAY
48379: PUSH
48380: LD_INT 2
48382: ARRAY
48383: PPUSH
48384: LD_EXP 128
48388: PUSH
48389: LD_VAR 0 2
48393: ARRAY
48394: PUSH
48395: LD_VAR 0 3
48399: ARRAY
48400: PUSH
48401: LD_INT 3
48403: ARRAY
48404: PPUSH
48405: CALL_OW 284
48409: PUSH
48410: LD_INT 0
48412: EQUAL
48413: AND
48414: IFFALSE 48469
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48416: LD_ADDR_VAR 0 5
48420: PUSH
48421: LD_EXP 128
48425: PUSH
48426: LD_VAR 0 2
48430: ARRAY
48431: PPUSH
48432: LD_VAR 0 3
48436: PPUSH
48437: CALL_OW 3
48441: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48442: LD_ADDR_EXP 128
48446: PUSH
48447: LD_EXP 128
48451: PPUSH
48452: LD_VAR 0 2
48456: PPUSH
48457: LD_VAR 0 5
48461: PPUSH
48462: CALL_OW 1
48466: ST_TO_ADDR
// continue ;
48467: GO 48313
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48469: LD_EXP 112
48473: PUSH
48474: LD_VAR 0 2
48478: ARRAY
48479: PUSH
48480: LD_INT 1
48482: ARRAY
48483: PPUSH
48484: CALL_OW 255
48488: PPUSH
48489: LD_EXP 128
48493: PUSH
48494: LD_VAR 0 2
48498: ARRAY
48499: PUSH
48500: LD_VAR 0 3
48504: ARRAY
48505: PUSH
48506: LD_INT 2
48508: ARRAY
48509: PPUSH
48510: LD_EXP 128
48514: PUSH
48515: LD_VAR 0 2
48519: ARRAY
48520: PUSH
48521: LD_VAR 0 3
48525: ARRAY
48526: PUSH
48527: LD_INT 3
48529: ARRAY
48530: PPUSH
48531: LD_INT 30
48533: PPUSH
48534: CALL 70946 0 4
48538: PUSH
48539: LD_INT 4
48541: ARRAY
48542: PUSH
48543: LD_INT 0
48545: EQUAL
48546: IFFALSE 48572
// begin target := mc_crates [ i ] [ j ] ;
48548: LD_ADDR_VAR 0 6
48552: PUSH
48553: LD_EXP 128
48557: PUSH
48558: LD_VAR 0 2
48562: ARRAY
48563: PUSH
48564: LD_VAR 0 3
48568: ARRAY
48569: ST_TO_ADDR
// break ;
48570: GO 48574
// end ; end ;
48572: GO 48313
48574: POP
48575: POP
// if not target then
48576: LD_VAR 0 6
48580: NOT
48581: IFFALSE 48585
// continue ;
48583: GO 48194
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48585: LD_ADDR_VAR 0 7
48589: PUSH
48590: LD_EXP 131
48594: PUSH
48595: LD_VAR 0 2
48599: ARRAY
48600: PPUSH
48601: LD_INT 2
48603: PUSH
48604: LD_INT 3
48606: PUSH
48607: LD_INT 58
48609: PUSH
48610: EMPTY
48611: LIST
48612: PUSH
48613: EMPTY
48614: LIST
48615: LIST
48616: PUSH
48617: LD_INT 61
48619: PUSH
48620: EMPTY
48621: LIST
48622: PUSH
48623: LD_INT 33
48625: PUSH
48626: LD_INT 5
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: LD_INT 33
48635: PUSH
48636: LD_INT 3
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: EMPTY
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: PUSH
48650: LD_INT 2
48652: PUSH
48653: LD_INT 34
48655: PUSH
48656: LD_INT 32
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 34
48665: PUSH
48666: LD_INT 51
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PUSH
48673: LD_INT 34
48675: PUSH
48676: LD_INT 12
48678: PUSH
48679: EMPTY
48680: LIST
48681: LIST
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: PUSH
48689: EMPTY
48690: LIST
48691: LIST
48692: PPUSH
48693: CALL_OW 72
48697: ST_TO_ADDR
// if not cargo then
48698: LD_VAR 0 7
48702: NOT
48703: IFFALSE 49346
// begin if mc_crates_collector [ i ] < 5 then
48705: LD_EXP 129
48709: PUSH
48710: LD_VAR 0 2
48714: ARRAY
48715: PUSH
48716: LD_INT 5
48718: LESS
48719: IFFALSE 49085
// begin if mc_ape [ i ] then
48721: LD_EXP 141
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: IFFALSE 48778
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48733: LD_ADDR_VAR 0 5
48737: PUSH
48738: LD_EXP 141
48742: PUSH
48743: LD_VAR 0 2
48747: ARRAY
48748: PPUSH
48749: LD_INT 25
48751: PUSH
48752: LD_INT 16
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PUSH
48759: LD_INT 24
48761: PUSH
48762: LD_INT 750
48764: PUSH
48765: EMPTY
48766: LIST
48767: LIST
48768: PUSH
48769: EMPTY
48770: LIST
48771: LIST
48772: PPUSH
48773: CALL_OW 72
48777: ST_TO_ADDR
// if not tmp then
48778: LD_VAR 0 5
48782: NOT
48783: IFFALSE 48830
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48785: LD_ADDR_VAR 0 5
48789: PUSH
48790: LD_EXP 112
48794: PUSH
48795: LD_VAR 0 2
48799: ARRAY
48800: PPUSH
48801: LD_INT 25
48803: PUSH
48804: LD_INT 2
48806: PUSH
48807: EMPTY
48808: LIST
48809: LIST
48810: PUSH
48811: LD_INT 24
48813: PUSH
48814: LD_INT 750
48816: PUSH
48817: EMPTY
48818: LIST
48819: LIST
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PPUSH
48825: CALL_OW 72
48829: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48830: LD_EXP 141
48834: PUSH
48835: LD_VAR 0 2
48839: ARRAY
48840: PUSH
48841: LD_EXP 112
48845: PUSH
48846: LD_VAR 0 2
48850: ARRAY
48851: PPUSH
48852: LD_INT 25
48854: PUSH
48855: LD_INT 2
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 24
48864: PUSH
48865: LD_INT 750
48867: PUSH
48868: EMPTY
48869: LIST
48870: LIST
48871: PUSH
48872: EMPTY
48873: LIST
48874: LIST
48875: PPUSH
48876: CALL_OW 72
48880: AND
48881: PUSH
48882: LD_VAR 0 5
48886: PUSH
48887: LD_INT 5
48889: LESS
48890: AND
48891: IFFALSE 48973
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48893: LD_ADDR_VAR 0 3
48897: PUSH
48898: LD_EXP 112
48902: PUSH
48903: LD_VAR 0 2
48907: ARRAY
48908: PPUSH
48909: LD_INT 25
48911: PUSH
48912: LD_INT 2
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 24
48921: PUSH
48922: LD_INT 750
48924: PUSH
48925: EMPTY
48926: LIST
48927: LIST
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: PPUSH
48933: CALL_OW 72
48937: PUSH
48938: FOR_IN
48939: IFFALSE 48971
// begin tmp := tmp union j ;
48941: LD_ADDR_VAR 0 5
48945: PUSH
48946: LD_VAR 0 5
48950: PUSH
48951: LD_VAR 0 3
48955: UNION
48956: ST_TO_ADDR
// if tmp >= 5 then
48957: LD_VAR 0 5
48961: PUSH
48962: LD_INT 5
48964: GREATEREQUAL
48965: IFFALSE 48969
// break ;
48967: GO 48971
// end ;
48969: GO 48938
48971: POP
48972: POP
// end ; if not tmp then
48973: LD_VAR 0 5
48977: NOT
48978: IFFALSE 48982
// continue ;
48980: GO 48194
// for j in tmp do
48982: LD_ADDR_VAR 0 3
48986: PUSH
48987: LD_VAR 0 5
48991: PUSH
48992: FOR_IN
48993: IFFALSE 49083
// if not GetTag ( j ) then
48995: LD_VAR 0 3
48999: PPUSH
49000: CALL_OW 110
49004: NOT
49005: IFFALSE 49081
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49007: LD_ADDR_EXP 129
49011: PUSH
49012: LD_EXP 129
49016: PPUSH
49017: LD_VAR 0 2
49021: PUSH
49022: LD_EXP 129
49026: PUSH
49027: LD_VAR 0 2
49031: ARRAY
49032: PUSH
49033: LD_INT 1
49035: PLUS
49036: PUSH
49037: EMPTY
49038: LIST
49039: LIST
49040: PPUSH
49041: LD_VAR 0 3
49045: PPUSH
49046: CALL 70050 0 3
49050: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49051: LD_VAR 0 3
49055: PPUSH
49056: LD_INT 107
49058: PPUSH
49059: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49063: LD_EXP 129
49067: PUSH
49068: LD_VAR 0 2
49072: ARRAY
49073: PUSH
49074: LD_INT 5
49076: GREATEREQUAL
49077: IFFALSE 49081
// break ;
49079: GO 49083
// end ;
49081: GO 48992
49083: POP
49084: POP
// end ; if mc_crates_collector [ i ] and target then
49085: LD_EXP 129
49089: PUSH
49090: LD_VAR 0 2
49094: ARRAY
49095: PUSH
49096: LD_VAR 0 6
49100: AND
49101: IFFALSE 49344
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49103: LD_EXP 129
49107: PUSH
49108: LD_VAR 0 2
49112: ARRAY
49113: PUSH
49114: LD_VAR 0 6
49118: PUSH
49119: LD_INT 1
49121: ARRAY
49122: LESS
49123: IFFALSE 49143
// tmp := mc_crates_collector [ i ] else
49125: LD_ADDR_VAR 0 5
49129: PUSH
49130: LD_EXP 129
49134: PUSH
49135: LD_VAR 0 2
49139: ARRAY
49140: ST_TO_ADDR
49141: GO 49157
// tmp := target [ 1 ] ;
49143: LD_ADDR_VAR 0 5
49147: PUSH
49148: LD_VAR 0 6
49152: PUSH
49153: LD_INT 1
49155: ARRAY
49156: ST_TO_ADDR
// k := 0 ;
49157: LD_ADDR_VAR 0 4
49161: PUSH
49162: LD_INT 0
49164: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49165: LD_ADDR_VAR 0 3
49169: PUSH
49170: LD_EXP 129
49174: PUSH
49175: LD_VAR 0 2
49179: ARRAY
49180: PUSH
49181: FOR_IN
49182: IFFALSE 49342
// begin k := k + 1 ;
49184: LD_ADDR_VAR 0 4
49188: PUSH
49189: LD_VAR 0 4
49193: PUSH
49194: LD_INT 1
49196: PLUS
49197: ST_TO_ADDR
// if k > tmp then
49198: LD_VAR 0 4
49202: PUSH
49203: LD_VAR 0 5
49207: GREATER
49208: IFFALSE 49212
// break ;
49210: GO 49342
// if not GetClass ( j ) in [ 2 , 16 ] then
49212: LD_VAR 0 3
49216: PPUSH
49217: CALL_OW 257
49221: PUSH
49222: LD_INT 2
49224: PUSH
49225: LD_INT 16
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: IN
49232: NOT
49233: IFFALSE 49286
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49235: LD_ADDR_EXP 129
49239: PUSH
49240: LD_EXP 129
49244: PPUSH
49245: LD_VAR 0 2
49249: PPUSH
49250: LD_EXP 129
49254: PUSH
49255: LD_VAR 0 2
49259: ARRAY
49260: PUSH
49261: LD_VAR 0 3
49265: DIFF
49266: PPUSH
49267: CALL_OW 1
49271: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49272: LD_VAR 0 3
49276: PPUSH
49277: LD_INT 0
49279: PPUSH
49280: CALL_OW 109
// continue ;
49284: GO 49181
// end ; if IsInUnit ( j ) then
49286: LD_VAR 0 3
49290: PPUSH
49291: CALL_OW 310
49295: IFFALSE 49306
// ComExitBuilding ( j ) ;
49297: LD_VAR 0 3
49301: PPUSH
49302: CALL_OW 122
// wait ( 3 ) ;
49306: LD_INT 3
49308: PPUSH
49309: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49313: LD_VAR 0 3
49317: PPUSH
49318: LD_VAR 0 6
49322: PUSH
49323: LD_INT 2
49325: ARRAY
49326: PPUSH
49327: LD_VAR 0 6
49331: PUSH
49332: LD_INT 3
49334: ARRAY
49335: PPUSH
49336: CALL_OW 117
// end ;
49340: GO 49181
49342: POP
49343: POP
// end ; end else
49344: GO 49925
// begin for j in cargo do
49346: LD_ADDR_VAR 0 3
49350: PUSH
49351: LD_VAR 0 7
49355: PUSH
49356: FOR_IN
49357: IFFALSE 49923
// begin if GetTag ( j ) <> 0 then
49359: LD_VAR 0 3
49363: PPUSH
49364: CALL_OW 110
49368: PUSH
49369: LD_INT 0
49371: NONEQUAL
49372: IFFALSE 49376
// continue ;
49374: GO 49356
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49376: LD_VAR 0 3
49380: PPUSH
49381: CALL_OW 256
49385: PUSH
49386: LD_INT 1000
49388: LESS
49389: PUSH
49390: LD_VAR 0 3
49394: PPUSH
49395: LD_EXP 136
49399: PUSH
49400: LD_VAR 0 2
49404: ARRAY
49405: PPUSH
49406: CALL_OW 308
49410: NOT
49411: AND
49412: IFFALSE 49434
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49414: LD_VAR 0 3
49418: PPUSH
49419: LD_EXP 136
49423: PUSH
49424: LD_VAR 0 2
49428: ARRAY
49429: PPUSH
49430: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49434: LD_VAR 0 3
49438: PPUSH
49439: CALL_OW 256
49443: PUSH
49444: LD_INT 1000
49446: LESS
49447: PUSH
49448: LD_VAR 0 3
49452: PPUSH
49453: LD_EXP 136
49457: PUSH
49458: LD_VAR 0 2
49462: ARRAY
49463: PPUSH
49464: CALL_OW 308
49468: AND
49469: IFFALSE 49473
// continue ;
49471: GO 49356
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49473: LD_VAR 0 3
49477: PPUSH
49478: CALL_OW 262
49482: PUSH
49483: LD_INT 2
49485: EQUAL
49486: PUSH
49487: LD_VAR 0 3
49491: PPUSH
49492: CALL_OW 261
49496: PUSH
49497: LD_INT 15
49499: LESS
49500: AND
49501: IFFALSE 49505
// continue ;
49503: GO 49356
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49505: LD_VAR 0 3
49509: PPUSH
49510: CALL_OW 262
49514: PUSH
49515: LD_INT 1
49517: EQUAL
49518: PUSH
49519: LD_VAR 0 3
49523: PPUSH
49524: CALL_OW 261
49528: PUSH
49529: LD_INT 10
49531: LESS
49532: AND
49533: IFFALSE 49862
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49535: LD_ADDR_VAR 0 8
49539: PUSH
49540: LD_EXP 112
49544: PUSH
49545: LD_VAR 0 2
49549: ARRAY
49550: PPUSH
49551: LD_INT 2
49553: PUSH
49554: LD_INT 30
49556: PUSH
49557: LD_INT 0
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: PUSH
49564: LD_INT 30
49566: PUSH
49567: LD_INT 1
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: LIST
49578: PPUSH
49579: CALL_OW 72
49583: ST_TO_ADDR
// if not depot then
49584: LD_VAR 0 8
49588: NOT
49589: IFFALSE 49593
// continue ;
49591: GO 49356
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49593: LD_VAR 0 3
49597: PPUSH
49598: LD_VAR 0 8
49602: PPUSH
49603: LD_VAR 0 3
49607: PPUSH
49608: CALL_OW 74
49612: PPUSH
49613: CALL_OW 296
49617: PUSH
49618: LD_INT 6
49620: LESS
49621: IFFALSE 49637
// SetFuel ( j , 100 ) else
49623: LD_VAR 0 3
49627: PPUSH
49628: LD_INT 100
49630: PPUSH
49631: CALL_OW 240
49635: GO 49862
// if GetFuel ( j ) = 0 then
49637: LD_VAR 0 3
49641: PPUSH
49642: CALL_OW 261
49646: PUSH
49647: LD_INT 0
49649: EQUAL
49650: IFFALSE 49862
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49652: LD_ADDR_EXP 131
49656: PUSH
49657: LD_EXP 131
49661: PPUSH
49662: LD_VAR 0 2
49666: PPUSH
49667: LD_EXP 131
49671: PUSH
49672: LD_VAR 0 2
49676: ARRAY
49677: PUSH
49678: LD_VAR 0 3
49682: DIFF
49683: PPUSH
49684: CALL_OW 1
49688: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49689: LD_VAR 0 3
49693: PPUSH
49694: CALL_OW 263
49698: PUSH
49699: LD_INT 1
49701: EQUAL
49702: IFFALSE 49718
// ComExitVehicle ( IsInUnit ( j ) ) ;
49704: LD_VAR 0 3
49708: PPUSH
49709: CALL_OW 310
49713: PPUSH
49714: CALL_OW 121
// if GetControl ( j ) = control_remote then
49718: LD_VAR 0 3
49722: PPUSH
49723: CALL_OW 263
49727: PUSH
49728: LD_INT 2
49730: EQUAL
49731: IFFALSE 49742
// ComUnlink ( j ) ;
49733: LD_VAR 0 3
49737: PPUSH
49738: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49742: LD_ADDR_VAR 0 9
49746: PUSH
49747: LD_VAR 0 2
49751: PPUSH
49752: LD_INT 3
49754: PPUSH
49755: CALL 59215 0 2
49759: ST_TO_ADDR
// if fac then
49760: LD_VAR 0 9
49764: IFFALSE 49860
// begin for k in fac do
49766: LD_ADDR_VAR 0 4
49770: PUSH
49771: LD_VAR 0 9
49775: PUSH
49776: FOR_IN
49777: IFFALSE 49858
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49779: LD_ADDR_VAR 0 10
49783: PUSH
49784: LD_VAR 0 9
49788: PPUSH
49789: LD_VAR 0 3
49793: PPUSH
49794: CALL_OW 265
49798: PPUSH
49799: LD_VAR 0 3
49803: PPUSH
49804: CALL_OW 262
49808: PPUSH
49809: LD_VAR 0 3
49813: PPUSH
49814: CALL_OW 263
49818: PPUSH
49819: LD_VAR 0 3
49823: PPUSH
49824: CALL_OW 264
49828: PPUSH
49829: CALL 67582 0 5
49833: ST_TO_ADDR
// if components then
49834: LD_VAR 0 10
49838: IFFALSE 49856
// begin MC_InsertProduceList ( i , components ) ;
49840: LD_VAR 0 2
49844: PPUSH
49845: LD_VAR 0 10
49849: PPUSH
49850: CALL 58760 0 2
// break ;
49854: GO 49858
// end ; end ;
49856: GO 49776
49858: POP
49859: POP
// end ; continue ;
49860: GO 49356
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49862: LD_VAR 0 3
49866: PPUSH
49867: LD_INT 1
49869: PPUSH
49870: CALL_OW 289
49874: PUSH
49875: LD_INT 100
49877: LESS
49878: PUSH
49879: LD_VAR 0 3
49883: PPUSH
49884: CALL_OW 314
49888: NOT
49889: AND
49890: IFFALSE 49919
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49892: LD_VAR 0 3
49896: PPUSH
49897: LD_VAR 0 6
49901: PUSH
49902: LD_INT 2
49904: ARRAY
49905: PPUSH
49906: LD_VAR 0 6
49910: PUSH
49911: LD_INT 3
49913: ARRAY
49914: PPUSH
49915: CALL_OW 117
// break ;
49919: GO 49923
// end ;
49921: GO 49356
49923: POP
49924: POP
// end ; end ;
49925: GO 48194
49927: POP
49928: POP
// end ;
49929: LD_VAR 0 1
49933: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49934: LD_INT 0
49936: PPUSH
49937: PPUSH
49938: PPUSH
49939: PPUSH
// if not mc_bases then
49940: LD_EXP 112
49944: NOT
49945: IFFALSE 49949
// exit ;
49947: GO 50110
// for i = 1 to mc_bases do
49949: LD_ADDR_VAR 0 2
49953: PUSH
49954: DOUBLE
49955: LD_INT 1
49957: DEC
49958: ST_TO_ADDR
49959: LD_EXP 112
49963: PUSH
49964: FOR_TO
49965: IFFALSE 50108
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49967: LD_ADDR_VAR 0 4
49971: PUSH
49972: LD_EXP 131
49976: PUSH
49977: LD_VAR 0 2
49981: ARRAY
49982: PUSH
49983: LD_EXP 134
49987: PUSH
49988: LD_VAR 0 2
49992: ARRAY
49993: UNION
49994: PPUSH
49995: LD_INT 33
49997: PUSH
49998: LD_INT 2
50000: PUSH
50001: EMPTY
50002: LIST
50003: LIST
50004: PPUSH
50005: CALL_OW 72
50009: ST_TO_ADDR
// if tmp then
50010: LD_VAR 0 4
50014: IFFALSE 50106
// for j in tmp do
50016: LD_ADDR_VAR 0 3
50020: PUSH
50021: LD_VAR 0 4
50025: PUSH
50026: FOR_IN
50027: IFFALSE 50104
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50029: LD_VAR 0 3
50033: PPUSH
50034: CALL_OW 312
50038: NOT
50039: PUSH
50040: LD_VAR 0 3
50044: PPUSH
50045: CALL_OW 256
50049: PUSH
50050: LD_INT 250
50052: GREATEREQUAL
50053: AND
50054: IFFALSE 50067
// Connect ( j ) else
50056: LD_VAR 0 3
50060: PPUSH
50061: CALL 72983 0 1
50065: GO 50102
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50067: LD_VAR 0 3
50071: PPUSH
50072: CALL_OW 256
50076: PUSH
50077: LD_INT 250
50079: LESS
50080: PUSH
50081: LD_VAR 0 3
50085: PPUSH
50086: CALL_OW 312
50090: AND
50091: IFFALSE 50102
// ComUnlink ( j ) ;
50093: LD_VAR 0 3
50097: PPUSH
50098: CALL_OW 136
50102: GO 50026
50104: POP
50105: POP
// end ;
50106: GO 49964
50108: POP
50109: POP
// end ;
50110: LD_VAR 0 1
50114: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50115: LD_INT 0
50117: PPUSH
50118: PPUSH
50119: PPUSH
50120: PPUSH
50121: PPUSH
// if not mc_bases then
50122: LD_EXP 112
50126: NOT
50127: IFFALSE 50131
// exit ;
50129: GO 50576
// for i = 1 to mc_bases do
50131: LD_ADDR_VAR 0 2
50135: PUSH
50136: DOUBLE
50137: LD_INT 1
50139: DEC
50140: ST_TO_ADDR
50141: LD_EXP 112
50145: PUSH
50146: FOR_TO
50147: IFFALSE 50574
// begin if not mc_produce [ i ] then
50149: LD_EXP 133
50153: PUSH
50154: LD_VAR 0 2
50158: ARRAY
50159: NOT
50160: IFFALSE 50164
// continue ;
50162: GO 50146
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50164: LD_ADDR_VAR 0 5
50168: PUSH
50169: LD_EXP 112
50173: PUSH
50174: LD_VAR 0 2
50178: ARRAY
50179: PPUSH
50180: LD_INT 30
50182: PUSH
50183: LD_INT 3
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PPUSH
50190: CALL_OW 72
50194: ST_TO_ADDR
// if not fac then
50195: LD_VAR 0 5
50199: NOT
50200: IFFALSE 50204
// continue ;
50202: GO 50146
// for j in fac do
50204: LD_ADDR_VAR 0 3
50208: PUSH
50209: LD_VAR 0 5
50213: PUSH
50214: FOR_IN
50215: IFFALSE 50570
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50217: LD_VAR 0 3
50221: PPUSH
50222: CALL_OW 461
50226: PUSH
50227: LD_INT 2
50229: NONEQUAL
50230: PUSH
50231: LD_VAR 0 3
50235: PPUSH
50236: LD_INT 15
50238: PPUSH
50239: CALL 72643 0 2
50243: PUSH
50244: LD_INT 4
50246: ARRAY
50247: OR
50248: IFFALSE 50252
// continue ;
50250: GO 50214
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50252: LD_VAR 0 3
50256: PPUSH
50257: LD_EXP 133
50261: PUSH
50262: LD_VAR 0 2
50266: ARRAY
50267: PUSH
50268: LD_INT 1
50270: ARRAY
50271: PUSH
50272: LD_INT 1
50274: ARRAY
50275: PPUSH
50276: LD_EXP 133
50280: PUSH
50281: LD_VAR 0 2
50285: ARRAY
50286: PUSH
50287: LD_INT 1
50289: ARRAY
50290: PUSH
50291: LD_INT 2
50293: ARRAY
50294: PPUSH
50295: LD_EXP 133
50299: PUSH
50300: LD_VAR 0 2
50304: ARRAY
50305: PUSH
50306: LD_INT 1
50308: ARRAY
50309: PUSH
50310: LD_INT 3
50312: ARRAY
50313: PPUSH
50314: LD_EXP 133
50318: PUSH
50319: LD_VAR 0 2
50323: ARRAY
50324: PUSH
50325: LD_INT 1
50327: ARRAY
50328: PUSH
50329: LD_INT 4
50331: ARRAY
50332: PPUSH
50333: CALL_OW 448
50337: PUSH
50338: LD_VAR 0 3
50342: PPUSH
50343: LD_EXP 133
50347: PUSH
50348: LD_VAR 0 2
50352: ARRAY
50353: PUSH
50354: LD_INT 1
50356: ARRAY
50357: PUSH
50358: LD_INT 1
50360: ARRAY
50361: PUSH
50362: LD_EXP 133
50366: PUSH
50367: LD_VAR 0 2
50371: ARRAY
50372: PUSH
50373: LD_INT 1
50375: ARRAY
50376: PUSH
50377: LD_INT 2
50379: ARRAY
50380: PUSH
50381: LD_EXP 133
50385: PUSH
50386: LD_VAR 0 2
50390: ARRAY
50391: PUSH
50392: LD_INT 1
50394: ARRAY
50395: PUSH
50396: LD_INT 3
50398: ARRAY
50399: PUSH
50400: LD_EXP 133
50404: PUSH
50405: LD_VAR 0 2
50409: ARRAY
50410: PUSH
50411: LD_INT 1
50413: ARRAY
50414: PUSH
50415: LD_INT 4
50417: ARRAY
50418: PUSH
50419: EMPTY
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: PPUSH
50425: CALL 76314 0 2
50429: AND
50430: IFFALSE 50568
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50432: LD_VAR 0 3
50436: PPUSH
50437: LD_EXP 133
50441: PUSH
50442: LD_VAR 0 2
50446: ARRAY
50447: PUSH
50448: LD_INT 1
50450: ARRAY
50451: PUSH
50452: LD_INT 1
50454: ARRAY
50455: PPUSH
50456: LD_EXP 133
50460: PUSH
50461: LD_VAR 0 2
50465: ARRAY
50466: PUSH
50467: LD_INT 1
50469: ARRAY
50470: PUSH
50471: LD_INT 2
50473: ARRAY
50474: PPUSH
50475: LD_EXP 133
50479: PUSH
50480: LD_VAR 0 2
50484: ARRAY
50485: PUSH
50486: LD_INT 1
50488: ARRAY
50489: PUSH
50490: LD_INT 3
50492: ARRAY
50493: PPUSH
50494: LD_EXP 133
50498: PUSH
50499: LD_VAR 0 2
50503: ARRAY
50504: PUSH
50505: LD_INT 1
50507: ARRAY
50508: PUSH
50509: LD_INT 4
50511: ARRAY
50512: PPUSH
50513: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50517: LD_ADDR_VAR 0 4
50521: PUSH
50522: LD_EXP 133
50526: PUSH
50527: LD_VAR 0 2
50531: ARRAY
50532: PPUSH
50533: LD_INT 1
50535: PPUSH
50536: CALL_OW 3
50540: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50541: LD_ADDR_EXP 133
50545: PUSH
50546: LD_EXP 133
50550: PPUSH
50551: LD_VAR 0 2
50555: PPUSH
50556: LD_VAR 0 4
50560: PPUSH
50561: CALL_OW 1
50565: ST_TO_ADDR
// break ;
50566: GO 50570
// end ; end ;
50568: GO 50214
50570: POP
50571: POP
// end ;
50572: GO 50146
50574: POP
50575: POP
// end ;
50576: LD_VAR 0 1
50580: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50581: LD_INT 0
50583: PPUSH
50584: PPUSH
50585: PPUSH
// if not mc_bases then
50586: LD_EXP 112
50590: NOT
50591: IFFALSE 50595
// exit ;
50593: GO 50684
// for i = 1 to mc_bases do
50595: LD_ADDR_VAR 0 2
50599: PUSH
50600: DOUBLE
50601: LD_INT 1
50603: DEC
50604: ST_TO_ADDR
50605: LD_EXP 112
50609: PUSH
50610: FOR_TO
50611: IFFALSE 50682
// begin if mc_attack [ i ] then
50613: LD_EXP 132
50617: PUSH
50618: LD_VAR 0 2
50622: ARRAY
50623: IFFALSE 50680
// begin tmp := mc_attack [ i ] [ 1 ] ;
50625: LD_ADDR_VAR 0 3
50629: PUSH
50630: LD_EXP 132
50634: PUSH
50635: LD_VAR 0 2
50639: ARRAY
50640: PUSH
50641: LD_INT 1
50643: ARRAY
50644: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50645: LD_ADDR_EXP 132
50649: PUSH
50650: LD_EXP 132
50654: PPUSH
50655: LD_VAR 0 2
50659: PPUSH
50660: EMPTY
50661: PPUSH
50662: CALL_OW 1
50666: ST_TO_ADDR
// Attack ( tmp ) ;
50667: LD_VAR 0 3
50671: PPUSH
50672: CALL 116425 0 1
// exit ;
50676: POP
50677: POP
50678: GO 50684
// end ; end ;
50680: GO 50610
50682: POP
50683: POP
// end ;
50684: LD_VAR 0 1
50688: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50689: LD_INT 0
50691: PPUSH
50692: PPUSH
50693: PPUSH
50694: PPUSH
50695: PPUSH
50696: PPUSH
50697: PPUSH
// if not mc_bases then
50698: LD_EXP 112
50702: NOT
50703: IFFALSE 50707
// exit ;
50705: GO 51289
// for i = 1 to mc_bases do
50707: LD_ADDR_VAR 0 2
50711: PUSH
50712: DOUBLE
50713: LD_INT 1
50715: DEC
50716: ST_TO_ADDR
50717: LD_EXP 112
50721: PUSH
50722: FOR_TO
50723: IFFALSE 51287
// begin if not mc_bases [ i ] then
50725: LD_EXP 112
50729: PUSH
50730: LD_VAR 0 2
50734: ARRAY
50735: NOT
50736: IFFALSE 50740
// continue ;
50738: GO 50722
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50740: LD_ADDR_VAR 0 7
50744: PUSH
50745: LD_EXP 112
50749: PUSH
50750: LD_VAR 0 2
50754: ARRAY
50755: PUSH
50756: LD_INT 1
50758: ARRAY
50759: PPUSH
50760: CALL 66886 0 1
50764: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50765: LD_ADDR_EXP 135
50769: PUSH
50770: LD_EXP 135
50774: PPUSH
50775: LD_VAR 0 2
50779: PPUSH
50780: LD_EXP 112
50784: PUSH
50785: LD_VAR 0 2
50789: ARRAY
50790: PUSH
50791: LD_INT 1
50793: ARRAY
50794: PPUSH
50795: CALL_OW 255
50799: PPUSH
50800: LD_EXP 137
50804: PUSH
50805: LD_VAR 0 2
50809: ARRAY
50810: PPUSH
50811: CALL 66851 0 2
50815: PPUSH
50816: CALL_OW 1
50820: ST_TO_ADDR
// if not mc_scan [ i ] then
50821: LD_EXP 135
50825: PUSH
50826: LD_VAR 0 2
50830: ARRAY
50831: NOT
50832: IFFALSE 50987
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50834: LD_ADDR_VAR 0 4
50838: PUSH
50839: LD_EXP 112
50843: PUSH
50844: LD_VAR 0 2
50848: ARRAY
50849: PPUSH
50850: LD_INT 2
50852: PUSH
50853: LD_INT 25
50855: PUSH
50856: LD_INT 5
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: LD_INT 25
50865: PUSH
50866: LD_INT 8
50868: PUSH
50869: EMPTY
50870: LIST
50871: LIST
50872: PUSH
50873: LD_INT 25
50875: PUSH
50876: LD_INT 9
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: PPUSH
50889: CALL_OW 72
50893: ST_TO_ADDR
// if not tmp then
50894: LD_VAR 0 4
50898: NOT
50899: IFFALSE 50903
// continue ;
50901: GO 50722
// for j in tmp do
50903: LD_ADDR_VAR 0 3
50907: PUSH
50908: LD_VAR 0 4
50912: PUSH
50913: FOR_IN
50914: IFFALSE 50985
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50916: LD_VAR 0 3
50920: PPUSH
50921: CALL_OW 310
50925: PPUSH
50926: CALL_OW 266
50930: PUSH
50931: LD_INT 5
50933: EQUAL
50934: PUSH
50935: LD_VAR 0 3
50939: PPUSH
50940: CALL_OW 257
50944: PUSH
50945: LD_INT 1
50947: EQUAL
50948: AND
50949: PUSH
50950: LD_VAR 0 3
50954: PPUSH
50955: CALL_OW 459
50959: NOT
50960: AND
50961: PUSH
50962: LD_VAR 0 7
50966: AND
50967: IFFALSE 50983
// ComChangeProfession ( j , class ) ;
50969: LD_VAR 0 3
50973: PPUSH
50974: LD_VAR 0 7
50978: PPUSH
50979: CALL_OW 123
50983: GO 50913
50985: POP
50986: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50987: LD_EXP 135
50991: PUSH
50992: LD_VAR 0 2
50996: ARRAY
50997: PUSH
50998: LD_EXP 134
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: NOT
51009: AND
51010: PUSH
51011: LD_EXP 112
51015: PUSH
51016: LD_VAR 0 2
51020: ARRAY
51021: PPUSH
51022: LD_INT 30
51024: PUSH
51025: LD_INT 32
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: PPUSH
51032: CALL_OW 72
51036: NOT
51037: AND
51038: PUSH
51039: LD_EXP 112
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: PPUSH
51050: LD_INT 2
51052: PUSH
51053: LD_INT 30
51055: PUSH
51056: LD_INT 4
51058: PUSH
51059: EMPTY
51060: LIST
51061: LIST
51062: PUSH
51063: LD_INT 30
51065: PUSH
51066: LD_INT 5
51068: PUSH
51069: EMPTY
51070: LIST
51071: LIST
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: PPUSH
51078: CALL_OW 72
51082: NOT
51083: AND
51084: IFFALSE 51216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51086: LD_ADDR_VAR 0 4
51090: PUSH
51091: LD_EXP 112
51095: PUSH
51096: LD_VAR 0 2
51100: ARRAY
51101: PPUSH
51102: LD_INT 2
51104: PUSH
51105: LD_INT 25
51107: PUSH
51108: LD_INT 1
51110: PUSH
51111: EMPTY
51112: LIST
51113: LIST
51114: PUSH
51115: LD_INT 25
51117: PUSH
51118: LD_INT 5
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: PUSH
51125: LD_INT 25
51127: PUSH
51128: LD_INT 8
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: PUSH
51135: LD_INT 25
51137: PUSH
51138: LD_INT 9
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: PPUSH
51152: CALL_OW 72
51156: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51157: LD_ADDR_VAR 0 4
51161: PUSH
51162: LD_VAR 0 4
51166: PUSH
51167: LD_VAR 0 4
51171: PPUSH
51172: LD_INT 18
51174: PPUSH
51175: CALL 98611 0 2
51179: DIFF
51180: ST_TO_ADDR
// if tmp then
51181: LD_VAR 0 4
51185: IFFALSE 51216
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
51187: LD_VAR 0 2
51191: PPUSH
51192: LD_VAR 0 4
51196: PPUSH
51197: LD_EXP 137
51201: PUSH
51202: LD_VAR 0 2
51206: ARRAY
51207: PPUSH
51208: CALL 121134 0 3
// exit ;
51212: POP
51213: POP
51214: GO 51289
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51216: LD_EXP 135
51220: PUSH
51221: LD_VAR 0 2
51225: ARRAY
51226: PUSH
51227: LD_EXP 134
51231: PUSH
51232: LD_VAR 0 2
51236: ARRAY
51237: AND
51238: IFFALSE 51285
// begin tmp := mc_defender [ i ] ;
51240: LD_ADDR_VAR 0 4
51244: PUSH
51245: LD_EXP 134
51249: PUSH
51250: LD_VAR 0 2
51254: ARRAY
51255: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51256: LD_VAR 0 2
51260: PPUSH
51261: LD_VAR 0 4
51265: PPUSH
51266: LD_EXP 135
51270: PUSH
51271: LD_VAR 0 2
51275: ARRAY
51276: PPUSH
51277: CALL 121695 0 3
// exit ;
51281: POP
51282: POP
51283: GO 51289
// end ; end ;
51285: GO 50722
51287: POP
51288: POP
// end ;
51289: LD_VAR 0 1
51293: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51294: LD_INT 0
51296: PPUSH
51297: PPUSH
51298: PPUSH
51299: PPUSH
51300: PPUSH
51301: PPUSH
51302: PPUSH
51303: PPUSH
51304: PPUSH
51305: PPUSH
51306: PPUSH
// if not mc_bases then
51307: LD_EXP 112
51311: NOT
51312: IFFALSE 51316
// exit ;
51314: GO 52403
// for i = 1 to mc_bases do
51316: LD_ADDR_VAR 0 2
51320: PUSH
51321: DOUBLE
51322: LD_INT 1
51324: DEC
51325: ST_TO_ADDR
51326: LD_EXP 112
51330: PUSH
51331: FOR_TO
51332: IFFALSE 52401
// begin tmp := mc_lab [ i ] ;
51334: LD_ADDR_VAR 0 6
51338: PUSH
51339: LD_EXP 145
51343: PUSH
51344: LD_VAR 0 2
51348: ARRAY
51349: ST_TO_ADDR
// if not tmp then
51350: LD_VAR 0 6
51354: NOT
51355: IFFALSE 51359
// continue ;
51357: GO 51331
// idle_lab := 0 ;
51359: LD_ADDR_VAR 0 11
51363: PUSH
51364: LD_INT 0
51366: ST_TO_ADDR
// for j in tmp do
51367: LD_ADDR_VAR 0 3
51371: PUSH
51372: LD_VAR 0 6
51376: PUSH
51377: FOR_IN
51378: IFFALSE 52397
// begin researching := false ;
51380: LD_ADDR_VAR 0 10
51384: PUSH
51385: LD_INT 0
51387: ST_TO_ADDR
// side := GetSide ( j ) ;
51388: LD_ADDR_VAR 0 4
51392: PUSH
51393: LD_VAR 0 3
51397: PPUSH
51398: CALL_OW 255
51402: ST_TO_ADDR
// if not mc_tech [ side ] then
51403: LD_EXP 139
51407: PUSH
51408: LD_VAR 0 4
51412: ARRAY
51413: NOT
51414: IFFALSE 51418
// continue ;
51416: GO 51377
// if BuildingStatus ( j ) = bs_idle then
51418: LD_VAR 0 3
51422: PPUSH
51423: CALL_OW 461
51427: PUSH
51428: LD_INT 2
51430: EQUAL
51431: IFFALSE 51619
// begin if idle_lab and UnitsInside ( j ) < 6 then
51433: LD_VAR 0 11
51437: PUSH
51438: LD_VAR 0 3
51442: PPUSH
51443: CALL_OW 313
51447: PUSH
51448: LD_INT 6
51450: LESS
51451: AND
51452: IFFALSE 51523
// begin tmp2 := UnitsInside ( idle_lab ) ;
51454: LD_ADDR_VAR 0 9
51458: PUSH
51459: LD_VAR 0 11
51463: PPUSH
51464: CALL_OW 313
51468: ST_TO_ADDR
// if tmp2 then
51469: LD_VAR 0 9
51473: IFFALSE 51515
// for x in tmp2 do
51475: LD_ADDR_VAR 0 7
51479: PUSH
51480: LD_VAR 0 9
51484: PUSH
51485: FOR_IN
51486: IFFALSE 51513
// begin ComExitBuilding ( x ) ;
51488: LD_VAR 0 7
51492: PPUSH
51493: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51497: LD_VAR 0 7
51501: PPUSH
51502: LD_VAR 0 3
51506: PPUSH
51507: CALL_OW 180
// end ;
51511: GO 51485
51513: POP
51514: POP
// idle_lab := 0 ;
51515: LD_ADDR_VAR 0 11
51519: PUSH
51520: LD_INT 0
51522: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51523: LD_ADDR_VAR 0 5
51527: PUSH
51528: LD_EXP 139
51532: PUSH
51533: LD_VAR 0 4
51537: ARRAY
51538: PUSH
51539: FOR_IN
51540: IFFALSE 51600
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51542: LD_VAR 0 3
51546: PPUSH
51547: LD_VAR 0 5
51551: PPUSH
51552: CALL_OW 430
51556: PUSH
51557: LD_VAR 0 4
51561: PPUSH
51562: LD_VAR 0 5
51566: PPUSH
51567: CALL 65956 0 2
51571: AND
51572: IFFALSE 51598
// begin researching := true ;
51574: LD_ADDR_VAR 0 10
51578: PUSH
51579: LD_INT 1
51581: ST_TO_ADDR
// ComResearch ( j , t ) ;
51582: LD_VAR 0 3
51586: PPUSH
51587: LD_VAR 0 5
51591: PPUSH
51592: CALL_OW 124
// break ;
51596: GO 51600
// end ;
51598: GO 51539
51600: POP
51601: POP
// if not researching then
51602: LD_VAR 0 10
51606: NOT
51607: IFFALSE 51619
// idle_lab := j ;
51609: LD_ADDR_VAR 0 11
51613: PUSH
51614: LD_VAR 0 3
51618: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51619: LD_VAR 0 3
51623: PPUSH
51624: CALL_OW 461
51628: PUSH
51629: LD_INT 10
51631: EQUAL
51632: IFFALSE 52220
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51634: LD_EXP 141
51638: PUSH
51639: LD_VAR 0 2
51643: ARRAY
51644: NOT
51645: PUSH
51646: LD_EXP 142
51650: PUSH
51651: LD_VAR 0 2
51655: ARRAY
51656: NOT
51657: AND
51658: PUSH
51659: LD_EXP 139
51663: PUSH
51664: LD_VAR 0 4
51668: ARRAY
51669: PUSH
51670: LD_INT 1
51672: GREATER
51673: AND
51674: IFFALSE 51805
// begin ComCancel ( j ) ;
51676: LD_VAR 0 3
51680: PPUSH
51681: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51685: LD_ADDR_EXP 139
51689: PUSH
51690: LD_EXP 139
51694: PPUSH
51695: LD_VAR 0 4
51699: PPUSH
51700: LD_EXP 139
51704: PUSH
51705: LD_VAR 0 4
51709: ARRAY
51710: PPUSH
51711: LD_EXP 139
51715: PUSH
51716: LD_VAR 0 4
51720: ARRAY
51721: PUSH
51722: LD_INT 1
51724: MINUS
51725: PPUSH
51726: LD_EXP 139
51730: PUSH
51731: LD_VAR 0 4
51735: ARRAY
51736: PPUSH
51737: LD_INT 0
51739: PPUSH
51740: CALL 69468 0 4
51744: PPUSH
51745: CALL_OW 1
51749: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51750: LD_ADDR_EXP 139
51754: PUSH
51755: LD_EXP 139
51759: PPUSH
51760: LD_VAR 0 4
51764: PPUSH
51765: LD_EXP 139
51769: PUSH
51770: LD_VAR 0 4
51774: ARRAY
51775: PPUSH
51776: LD_EXP 139
51780: PUSH
51781: LD_VAR 0 4
51785: ARRAY
51786: PPUSH
51787: LD_INT 1
51789: PPUSH
51790: LD_INT 0
51792: PPUSH
51793: CALL 69468 0 4
51797: PPUSH
51798: CALL_OW 1
51802: ST_TO_ADDR
// continue ;
51803: GO 51377
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51805: LD_EXP 141
51809: PUSH
51810: LD_VAR 0 2
51814: ARRAY
51815: PUSH
51816: LD_EXP 142
51820: PUSH
51821: LD_VAR 0 2
51825: ARRAY
51826: NOT
51827: AND
51828: IFFALSE 51955
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51830: LD_ADDR_EXP 142
51834: PUSH
51835: LD_EXP 142
51839: PPUSH
51840: LD_VAR 0 2
51844: PUSH
51845: LD_EXP 142
51849: PUSH
51850: LD_VAR 0 2
51854: ARRAY
51855: PUSH
51856: LD_INT 1
51858: PLUS
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PPUSH
51864: LD_EXP 141
51868: PUSH
51869: LD_VAR 0 2
51873: ARRAY
51874: PUSH
51875: LD_INT 1
51877: ARRAY
51878: PPUSH
51879: CALL 70050 0 3
51883: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51884: LD_EXP 141
51888: PUSH
51889: LD_VAR 0 2
51893: ARRAY
51894: PUSH
51895: LD_INT 1
51897: ARRAY
51898: PPUSH
51899: LD_INT 112
51901: PPUSH
51902: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51906: LD_ADDR_VAR 0 9
51910: PUSH
51911: LD_EXP 141
51915: PUSH
51916: LD_VAR 0 2
51920: ARRAY
51921: PPUSH
51922: LD_INT 1
51924: PPUSH
51925: CALL_OW 3
51929: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51930: LD_ADDR_EXP 141
51934: PUSH
51935: LD_EXP 141
51939: PPUSH
51940: LD_VAR 0 2
51944: PPUSH
51945: LD_VAR 0 9
51949: PPUSH
51950: CALL_OW 1
51954: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51955: LD_EXP 141
51959: PUSH
51960: LD_VAR 0 2
51964: ARRAY
51965: PUSH
51966: LD_EXP 142
51970: PUSH
51971: LD_VAR 0 2
51975: ARRAY
51976: AND
51977: PUSH
51978: LD_EXP 142
51982: PUSH
51983: LD_VAR 0 2
51987: ARRAY
51988: PUSH
51989: LD_INT 1
51991: ARRAY
51992: PPUSH
51993: CALL_OW 310
51997: NOT
51998: AND
51999: PUSH
52000: LD_VAR 0 3
52004: PPUSH
52005: CALL_OW 313
52009: PUSH
52010: LD_INT 6
52012: EQUAL
52013: AND
52014: IFFALSE 52070
// begin tmp2 := UnitsInside ( j ) ;
52016: LD_ADDR_VAR 0 9
52020: PUSH
52021: LD_VAR 0 3
52025: PPUSH
52026: CALL_OW 313
52030: ST_TO_ADDR
// if tmp2 = 6 then
52031: LD_VAR 0 9
52035: PUSH
52036: LD_INT 6
52038: EQUAL
52039: IFFALSE 52070
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52041: LD_VAR 0 9
52045: PUSH
52046: LD_INT 1
52048: ARRAY
52049: PPUSH
52050: LD_INT 112
52052: PPUSH
52053: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52057: LD_VAR 0 9
52061: PUSH
52062: LD_INT 1
52064: ARRAY
52065: PPUSH
52066: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52070: LD_EXP 142
52074: PUSH
52075: LD_VAR 0 2
52079: ARRAY
52080: PUSH
52081: LD_EXP 142
52085: PUSH
52086: LD_VAR 0 2
52090: ARRAY
52091: PUSH
52092: LD_INT 1
52094: ARRAY
52095: PPUSH
52096: CALL_OW 314
52100: NOT
52101: AND
52102: PUSH
52103: LD_EXP 142
52107: PUSH
52108: LD_VAR 0 2
52112: ARRAY
52113: PUSH
52114: LD_INT 1
52116: ARRAY
52117: PPUSH
52118: CALL_OW 310
52122: NOT
52123: AND
52124: IFFALSE 52150
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52126: LD_EXP 142
52130: PUSH
52131: LD_VAR 0 2
52135: ARRAY
52136: PUSH
52137: LD_INT 1
52139: ARRAY
52140: PPUSH
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52150: LD_EXP 142
52154: PUSH
52155: LD_VAR 0 2
52159: ARRAY
52160: PUSH
52161: LD_INT 1
52163: ARRAY
52164: PPUSH
52165: CALL_OW 310
52169: PUSH
52170: LD_EXP 142
52174: PUSH
52175: LD_VAR 0 2
52179: ARRAY
52180: PUSH
52181: LD_INT 1
52183: ARRAY
52184: PPUSH
52185: CALL_OW 310
52189: PPUSH
52190: CALL_OW 461
52194: PUSH
52195: LD_INT 3
52197: NONEQUAL
52198: AND
52199: IFFALSE 52220
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52201: LD_EXP 142
52205: PUSH
52206: LD_VAR 0 2
52210: ARRAY
52211: PUSH
52212: LD_INT 1
52214: ARRAY
52215: PPUSH
52216: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52220: LD_VAR 0 3
52224: PPUSH
52225: CALL_OW 461
52229: PUSH
52230: LD_INT 6
52232: EQUAL
52233: PUSH
52234: LD_VAR 0 6
52238: PUSH
52239: LD_INT 1
52241: GREATER
52242: AND
52243: IFFALSE 52395
// begin sci := [ ] ;
52245: LD_ADDR_VAR 0 8
52249: PUSH
52250: EMPTY
52251: ST_TO_ADDR
// for x in ( tmp diff j ) do
52252: LD_ADDR_VAR 0 7
52256: PUSH
52257: LD_VAR 0 6
52261: PUSH
52262: LD_VAR 0 3
52266: DIFF
52267: PUSH
52268: FOR_IN
52269: IFFALSE 52321
// begin if sci = 6 then
52271: LD_VAR 0 8
52275: PUSH
52276: LD_INT 6
52278: EQUAL
52279: IFFALSE 52283
// break ;
52281: GO 52321
// if BuildingStatus ( x ) = bs_idle then
52283: LD_VAR 0 7
52287: PPUSH
52288: CALL_OW 461
52292: PUSH
52293: LD_INT 2
52295: EQUAL
52296: IFFALSE 52319
// sci := sci ^ UnitsInside ( x ) ;
52298: LD_ADDR_VAR 0 8
52302: PUSH
52303: LD_VAR 0 8
52307: PUSH
52308: LD_VAR 0 7
52312: PPUSH
52313: CALL_OW 313
52317: ADD
52318: ST_TO_ADDR
// end ;
52319: GO 52268
52321: POP
52322: POP
// if not sci then
52323: LD_VAR 0 8
52327: NOT
52328: IFFALSE 52332
// continue ;
52330: GO 51377
// for x in sci do
52332: LD_ADDR_VAR 0 7
52336: PUSH
52337: LD_VAR 0 8
52341: PUSH
52342: FOR_IN
52343: IFFALSE 52393
// if IsInUnit ( x ) and not HasTask ( x ) then
52345: LD_VAR 0 7
52349: PPUSH
52350: CALL_OW 310
52354: PUSH
52355: LD_VAR 0 7
52359: PPUSH
52360: CALL_OW 314
52364: NOT
52365: AND
52366: IFFALSE 52391
// begin ComExitBuilding ( x ) ;
52368: LD_VAR 0 7
52372: PPUSH
52373: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52377: LD_VAR 0 7
52381: PPUSH
52382: LD_VAR 0 3
52386: PPUSH
52387: CALL_OW 180
// end ;
52391: GO 52342
52393: POP
52394: POP
// end ; end ;
52395: GO 51377
52397: POP
52398: POP
// end ;
52399: GO 51331
52401: POP
52402: POP
// end ;
52403: LD_VAR 0 1
52407: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52408: LD_INT 0
52410: PPUSH
52411: PPUSH
// if not mc_bases then
52412: LD_EXP 112
52416: NOT
52417: IFFALSE 52421
// exit ;
52419: GO 52502
// for i = 1 to mc_bases do
52421: LD_ADDR_VAR 0 2
52425: PUSH
52426: DOUBLE
52427: LD_INT 1
52429: DEC
52430: ST_TO_ADDR
52431: LD_EXP 112
52435: PUSH
52436: FOR_TO
52437: IFFALSE 52500
// if mc_mines [ i ] and mc_miners [ i ] then
52439: LD_EXP 125
52443: PUSH
52444: LD_VAR 0 2
52448: ARRAY
52449: PUSH
52450: LD_EXP 126
52454: PUSH
52455: LD_VAR 0 2
52459: ARRAY
52460: AND
52461: IFFALSE 52498
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52463: LD_EXP 126
52467: PUSH
52468: LD_VAR 0 2
52472: ARRAY
52473: PUSH
52474: LD_INT 1
52476: ARRAY
52477: PPUSH
52478: CALL_OW 255
52482: PPUSH
52483: LD_EXP 125
52487: PUSH
52488: LD_VAR 0 2
52492: ARRAY
52493: PPUSH
52494: CALL 67039 0 2
52498: GO 52436
52500: POP
52501: POP
// end ;
52502: LD_VAR 0 1
52506: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52507: LD_INT 0
52509: PPUSH
52510: PPUSH
52511: PPUSH
52512: PPUSH
52513: PPUSH
52514: PPUSH
52515: PPUSH
52516: PPUSH
// if not mc_bases or not mc_parking then
52517: LD_EXP 112
52521: NOT
52522: PUSH
52523: LD_EXP 136
52527: NOT
52528: OR
52529: IFFALSE 52533
// exit ;
52531: GO 53232
// for i = 1 to mc_bases do
52533: LD_ADDR_VAR 0 2
52537: PUSH
52538: DOUBLE
52539: LD_INT 1
52541: DEC
52542: ST_TO_ADDR
52543: LD_EXP 112
52547: PUSH
52548: FOR_TO
52549: IFFALSE 53230
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52551: LD_EXP 112
52555: PUSH
52556: LD_VAR 0 2
52560: ARRAY
52561: NOT
52562: PUSH
52563: LD_EXP 136
52567: PUSH
52568: LD_VAR 0 2
52572: ARRAY
52573: NOT
52574: OR
52575: IFFALSE 52579
// continue ;
52577: GO 52548
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52579: LD_ADDR_VAR 0 5
52583: PUSH
52584: LD_EXP 112
52588: PUSH
52589: LD_VAR 0 2
52593: ARRAY
52594: PUSH
52595: LD_INT 1
52597: ARRAY
52598: PPUSH
52599: CALL_OW 255
52603: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52604: LD_ADDR_VAR 0 6
52608: PUSH
52609: LD_EXP 112
52613: PUSH
52614: LD_VAR 0 2
52618: ARRAY
52619: PPUSH
52620: LD_INT 30
52622: PUSH
52623: LD_INT 3
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: PPUSH
52630: CALL_OW 72
52634: ST_TO_ADDR
// if not fac then
52635: LD_VAR 0 6
52639: NOT
52640: IFFALSE 52691
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52642: LD_ADDR_VAR 0 6
52646: PUSH
52647: LD_EXP 112
52651: PUSH
52652: LD_VAR 0 2
52656: ARRAY
52657: PPUSH
52658: LD_INT 2
52660: PUSH
52661: LD_INT 30
52663: PUSH
52664: LD_INT 0
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: PUSH
52671: LD_INT 30
52673: PUSH
52674: LD_INT 1
52676: PUSH
52677: EMPTY
52678: LIST
52679: LIST
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: LIST
52685: PPUSH
52686: CALL_OW 72
52690: ST_TO_ADDR
// if not fac then
52691: LD_VAR 0 6
52695: NOT
52696: IFFALSE 52700
// continue ;
52698: GO 52548
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52700: LD_ADDR_VAR 0 7
52704: PUSH
52705: LD_EXP 136
52709: PUSH
52710: LD_VAR 0 2
52714: ARRAY
52715: PPUSH
52716: LD_INT 22
52718: PUSH
52719: LD_VAR 0 5
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PUSH
52728: LD_INT 21
52730: PUSH
52731: LD_INT 2
52733: PUSH
52734: EMPTY
52735: LIST
52736: LIST
52737: PUSH
52738: LD_INT 3
52740: PUSH
52741: LD_INT 24
52743: PUSH
52744: LD_INT 1000
52746: PUSH
52747: EMPTY
52748: LIST
52749: LIST
52750: PUSH
52751: EMPTY
52752: LIST
52753: LIST
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: LIST
52759: PPUSH
52760: CALL_OW 70
52764: ST_TO_ADDR
// for j in fac do
52765: LD_ADDR_VAR 0 3
52769: PUSH
52770: LD_VAR 0 6
52774: PUSH
52775: FOR_IN
52776: IFFALSE 52857
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52778: LD_ADDR_VAR 0 7
52782: PUSH
52783: LD_VAR 0 7
52787: PUSH
52788: LD_INT 22
52790: PUSH
52791: LD_VAR 0 5
52795: PUSH
52796: EMPTY
52797: LIST
52798: LIST
52799: PUSH
52800: LD_INT 91
52802: PUSH
52803: LD_VAR 0 3
52807: PUSH
52808: LD_INT 15
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: LIST
52815: PUSH
52816: LD_INT 21
52818: PUSH
52819: LD_INT 2
52821: PUSH
52822: EMPTY
52823: LIST
52824: LIST
52825: PUSH
52826: LD_INT 3
52828: PUSH
52829: LD_INT 24
52831: PUSH
52832: LD_INT 1000
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: LIST
52847: LIST
52848: PPUSH
52849: CALL_OW 69
52853: UNION
52854: ST_TO_ADDR
52855: GO 52775
52857: POP
52858: POP
// if not vehs then
52859: LD_VAR 0 7
52863: NOT
52864: IFFALSE 52890
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52866: LD_ADDR_EXP 124
52870: PUSH
52871: LD_EXP 124
52875: PPUSH
52876: LD_VAR 0 2
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// continue ;
52888: GO 52548
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52890: LD_ADDR_VAR 0 8
52894: PUSH
52895: LD_EXP 112
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: PPUSH
52906: LD_INT 30
52908: PUSH
52909: LD_INT 3
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: PPUSH
52916: CALL_OW 72
52920: ST_TO_ADDR
// if tmp then
52921: LD_VAR 0 8
52925: IFFALSE 53028
// begin for j in tmp do
52927: LD_ADDR_VAR 0 3
52931: PUSH
52932: LD_VAR 0 8
52936: PUSH
52937: FOR_IN
52938: IFFALSE 53026
// for k in UnitsInside ( j ) do
52940: LD_ADDR_VAR 0 4
52944: PUSH
52945: LD_VAR 0 3
52949: PPUSH
52950: CALL_OW 313
52954: PUSH
52955: FOR_IN
52956: IFFALSE 53022
// if k then
52958: LD_VAR 0 4
52962: IFFALSE 53020
// if not k in mc_repair_vehicle [ i ] then
52964: LD_VAR 0 4
52968: PUSH
52969: LD_EXP 124
52973: PUSH
52974: LD_VAR 0 2
52978: ARRAY
52979: IN
52980: NOT
52981: IFFALSE 53020
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52983: LD_ADDR_EXP 124
52987: PUSH
52988: LD_EXP 124
52992: PPUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_EXP 124
53002: PUSH
53003: LD_VAR 0 2
53007: ARRAY
53008: PUSH
53009: LD_VAR 0 4
53013: UNION
53014: PPUSH
53015: CALL_OW 1
53019: ST_TO_ADDR
53020: GO 52955
53022: POP
53023: POP
53024: GO 52937
53026: POP
53027: POP
// end ; if not mc_repair_vehicle [ i ] then
53028: LD_EXP 124
53032: PUSH
53033: LD_VAR 0 2
53037: ARRAY
53038: NOT
53039: IFFALSE 53043
// continue ;
53041: GO 52548
// for j in mc_repair_vehicle [ i ] do
53043: LD_ADDR_VAR 0 3
53047: PUSH
53048: LD_EXP 124
53052: PUSH
53053: LD_VAR 0 2
53057: ARRAY
53058: PUSH
53059: FOR_IN
53060: IFFALSE 53226
// begin if GetClass ( j ) <> 3 then
53062: LD_VAR 0 3
53066: PPUSH
53067: CALL_OW 257
53071: PUSH
53072: LD_INT 3
53074: NONEQUAL
53075: IFFALSE 53116
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53077: LD_ADDR_EXP 124
53081: PUSH
53082: LD_EXP 124
53086: PPUSH
53087: LD_VAR 0 2
53091: PPUSH
53092: LD_EXP 124
53096: PUSH
53097: LD_VAR 0 2
53101: ARRAY
53102: PUSH
53103: LD_VAR 0 3
53107: DIFF
53108: PPUSH
53109: CALL_OW 1
53113: ST_TO_ADDR
// continue ;
53114: GO 53059
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53116: LD_VAR 0 3
53120: PPUSH
53121: CALL_OW 311
53125: NOT
53126: PUSH
53127: LD_VAR 0 3
53131: PUSH
53132: LD_EXP 115
53136: PUSH
53137: LD_VAR 0 2
53141: ARRAY
53142: PUSH
53143: LD_INT 1
53145: ARRAY
53146: IN
53147: NOT
53148: AND
53149: PUSH
53150: LD_VAR 0 3
53154: PUSH
53155: LD_EXP 115
53159: PUSH
53160: LD_VAR 0 2
53164: ARRAY
53165: PUSH
53166: LD_INT 2
53168: ARRAY
53169: IN
53170: NOT
53171: AND
53172: IFFALSE 53224
// begin if IsInUnit ( j ) then
53174: LD_VAR 0 3
53178: PPUSH
53179: CALL_OW 310
53183: IFFALSE 53194
// ComExitBuilding ( j ) ;
53185: LD_VAR 0 3
53189: PPUSH
53190: CALL_OW 122
// if not HasTask ( j ) then
53194: LD_VAR 0 3
53198: PPUSH
53199: CALL_OW 314
53203: NOT
53204: IFFALSE 53224
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53206: LD_VAR 0 3
53210: PPUSH
53211: LD_VAR 0 7
53215: PUSH
53216: LD_INT 1
53218: ARRAY
53219: PPUSH
53220: CALL_OW 189
// end ; end ;
53224: GO 53059
53226: POP
53227: POP
// end ;
53228: GO 52548
53230: POP
53231: POP
// end ;
53232: LD_VAR 0 1
53236: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53237: LD_INT 0
53239: PPUSH
53240: PPUSH
53241: PPUSH
53242: PPUSH
53243: PPUSH
53244: PPUSH
53245: PPUSH
53246: PPUSH
53247: PPUSH
53248: PPUSH
53249: PPUSH
// if not mc_bases then
53250: LD_EXP 112
53254: NOT
53255: IFFALSE 53259
// exit ;
53257: GO 54061
// for i = 1 to mc_bases do
53259: LD_ADDR_VAR 0 2
53263: PUSH
53264: DOUBLE
53265: LD_INT 1
53267: DEC
53268: ST_TO_ADDR
53269: LD_EXP 112
53273: PUSH
53274: FOR_TO
53275: IFFALSE 54059
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53277: LD_EXP 140
53281: PUSH
53282: LD_VAR 0 2
53286: ARRAY
53287: NOT
53288: PUSH
53289: LD_EXP 115
53293: PUSH
53294: LD_VAR 0 2
53298: ARRAY
53299: PUSH
53300: LD_INT 1
53302: ARRAY
53303: OR
53304: PUSH
53305: LD_EXP 115
53309: PUSH
53310: LD_VAR 0 2
53314: ARRAY
53315: PUSH
53316: LD_INT 2
53318: ARRAY
53319: OR
53320: PUSH
53321: LD_EXP 138
53325: PUSH
53326: LD_VAR 0 2
53330: ARRAY
53331: PPUSH
53332: LD_INT 1
53334: PPUSH
53335: CALL_OW 325
53339: NOT
53340: OR
53341: PUSH
53342: LD_EXP 135
53346: PUSH
53347: LD_VAR 0 2
53351: ARRAY
53352: OR
53353: IFFALSE 53357
// continue ;
53355: GO 53274
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53357: LD_ADDR_VAR 0 8
53361: PUSH
53362: LD_EXP 112
53366: PUSH
53367: LD_VAR 0 2
53371: ARRAY
53372: PPUSH
53373: LD_INT 25
53375: PUSH
53376: LD_INT 4
53378: PUSH
53379: EMPTY
53380: LIST
53381: LIST
53382: PUSH
53383: LD_INT 50
53385: PUSH
53386: EMPTY
53387: LIST
53388: PUSH
53389: LD_INT 3
53391: PUSH
53392: LD_INT 60
53394: PUSH
53395: EMPTY
53396: LIST
53397: PUSH
53398: EMPTY
53399: LIST
53400: LIST
53401: PUSH
53402: EMPTY
53403: LIST
53404: LIST
53405: LIST
53406: PPUSH
53407: CALL_OW 72
53411: PUSH
53412: LD_EXP 116
53416: PUSH
53417: LD_VAR 0 2
53421: ARRAY
53422: DIFF
53423: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53424: LD_ADDR_VAR 0 9
53428: PUSH
53429: LD_EXP 112
53433: PUSH
53434: LD_VAR 0 2
53438: ARRAY
53439: PPUSH
53440: LD_INT 2
53442: PUSH
53443: LD_INT 30
53445: PUSH
53446: LD_INT 0
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: PUSH
53453: LD_INT 30
53455: PUSH
53456: LD_INT 1
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: LIST
53467: PPUSH
53468: CALL_OW 72
53472: ST_TO_ADDR
// if not tmp or not dep then
53473: LD_VAR 0 8
53477: NOT
53478: PUSH
53479: LD_VAR 0 9
53483: NOT
53484: OR
53485: IFFALSE 53489
// continue ;
53487: GO 53274
// side := GetSide ( tmp [ 1 ] ) ;
53489: LD_ADDR_VAR 0 11
53493: PUSH
53494: LD_VAR 0 8
53498: PUSH
53499: LD_INT 1
53501: ARRAY
53502: PPUSH
53503: CALL_OW 255
53507: ST_TO_ADDR
// dep := dep [ 1 ] ;
53508: LD_ADDR_VAR 0 9
53512: PUSH
53513: LD_VAR 0 9
53517: PUSH
53518: LD_INT 1
53520: ARRAY
53521: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53522: LD_ADDR_VAR 0 7
53526: PUSH
53527: LD_EXP 140
53531: PUSH
53532: LD_VAR 0 2
53536: ARRAY
53537: PPUSH
53538: LD_INT 22
53540: PUSH
53541: LD_INT 0
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: PUSH
53548: LD_INT 25
53550: PUSH
53551: LD_INT 12
53553: PUSH
53554: EMPTY
53555: LIST
53556: LIST
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: PPUSH
53562: CALL_OW 70
53566: PUSH
53567: LD_INT 22
53569: PUSH
53570: LD_INT 0
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: PUSH
53577: LD_INT 25
53579: PUSH
53580: LD_INT 12
53582: PUSH
53583: EMPTY
53584: LIST
53585: LIST
53586: PUSH
53587: LD_INT 91
53589: PUSH
53590: LD_VAR 0 9
53594: PUSH
53595: LD_INT 20
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: LIST
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: LIST
53607: PPUSH
53608: CALL_OW 69
53612: UNION
53613: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53614: LD_ADDR_VAR 0 10
53618: PUSH
53619: LD_EXP 140
53623: PUSH
53624: LD_VAR 0 2
53628: ARRAY
53629: PPUSH
53630: LD_INT 81
53632: PUSH
53633: LD_VAR 0 11
53637: PUSH
53638: EMPTY
53639: LIST
53640: LIST
53641: PPUSH
53642: CALL_OW 70
53646: ST_TO_ADDR
// if not apes or danger_at_area then
53647: LD_VAR 0 7
53651: NOT
53652: PUSH
53653: LD_VAR 0 10
53657: OR
53658: IFFALSE 53708
// begin if mc_taming [ i ] then
53660: LD_EXP 143
53664: PUSH
53665: LD_VAR 0 2
53669: ARRAY
53670: IFFALSE 53706
// begin MC_Reset ( i , 121 ) ;
53672: LD_VAR 0 2
53676: PPUSH
53677: LD_INT 121
53679: PPUSH
53680: CALL 39159 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53684: LD_ADDR_EXP 143
53688: PUSH
53689: LD_EXP 143
53693: PPUSH
53694: LD_VAR 0 2
53698: PPUSH
53699: EMPTY
53700: PPUSH
53701: CALL_OW 1
53705: ST_TO_ADDR
// end ; continue ;
53706: GO 53274
// end ; for j in tmp do
53708: LD_ADDR_VAR 0 3
53712: PUSH
53713: LD_VAR 0 8
53717: PUSH
53718: FOR_IN
53719: IFFALSE 54055
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53721: LD_VAR 0 3
53725: PUSH
53726: LD_EXP 143
53730: PUSH
53731: LD_VAR 0 2
53735: ARRAY
53736: IN
53737: NOT
53738: PUSH
53739: LD_EXP 143
53743: PUSH
53744: LD_VAR 0 2
53748: ARRAY
53749: PUSH
53750: LD_INT 3
53752: LESS
53753: AND
53754: IFFALSE 53812
// begin SetTag ( j , 121 ) ;
53756: LD_VAR 0 3
53760: PPUSH
53761: LD_INT 121
53763: PPUSH
53764: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53768: LD_ADDR_EXP 143
53772: PUSH
53773: LD_EXP 143
53777: PPUSH
53778: LD_VAR 0 2
53782: PUSH
53783: LD_EXP 143
53787: PUSH
53788: LD_VAR 0 2
53792: ARRAY
53793: PUSH
53794: LD_INT 1
53796: PLUS
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PPUSH
53802: LD_VAR 0 3
53806: PPUSH
53807: CALL 70050 0 3
53811: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53812: LD_VAR 0 3
53816: PUSH
53817: LD_EXP 143
53821: PUSH
53822: LD_VAR 0 2
53826: ARRAY
53827: IN
53828: IFFALSE 54053
// begin if GetClass ( j ) <> 4 then
53830: LD_VAR 0 3
53834: PPUSH
53835: CALL_OW 257
53839: PUSH
53840: LD_INT 4
53842: NONEQUAL
53843: IFFALSE 53896
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53845: LD_ADDR_EXP 143
53849: PUSH
53850: LD_EXP 143
53854: PPUSH
53855: LD_VAR 0 2
53859: PPUSH
53860: LD_EXP 143
53864: PUSH
53865: LD_VAR 0 2
53869: ARRAY
53870: PUSH
53871: LD_VAR 0 3
53875: DIFF
53876: PPUSH
53877: CALL_OW 1
53881: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53882: LD_VAR 0 3
53886: PPUSH
53887: LD_INT 0
53889: PPUSH
53890: CALL_OW 109
// continue ;
53894: GO 53718
// end ; if IsInUnit ( j ) then
53896: LD_VAR 0 3
53900: PPUSH
53901: CALL_OW 310
53905: IFFALSE 53916
// ComExitBuilding ( j ) ;
53907: LD_VAR 0 3
53911: PPUSH
53912: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53916: LD_ADDR_VAR 0 6
53920: PUSH
53921: LD_VAR 0 7
53925: PPUSH
53926: LD_VAR 0 3
53930: PPUSH
53931: CALL_OW 74
53935: ST_TO_ADDR
// if not ape then
53936: LD_VAR 0 6
53940: NOT
53941: IFFALSE 53945
// break ;
53943: GO 54055
// x := GetX ( ape ) ;
53945: LD_ADDR_VAR 0 4
53949: PUSH
53950: LD_VAR 0 6
53954: PPUSH
53955: CALL_OW 250
53959: ST_TO_ADDR
// y := GetY ( ape ) ;
53960: LD_ADDR_VAR 0 5
53964: PUSH
53965: LD_VAR 0 6
53969: PPUSH
53970: CALL_OW 251
53974: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53975: LD_VAR 0 4
53979: PPUSH
53980: LD_VAR 0 5
53984: PPUSH
53985: CALL_OW 488
53989: NOT
53990: PUSH
53991: LD_VAR 0 11
53995: PPUSH
53996: LD_VAR 0 4
54000: PPUSH
54001: LD_VAR 0 5
54005: PPUSH
54006: LD_INT 20
54008: PPUSH
54009: CALL 70946 0 4
54013: PUSH
54014: LD_INT 4
54016: ARRAY
54017: OR
54018: IFFALSE 54022
// break ;
54020: GO 54055
// if not HasTask ( j ) then
54022: LD_VAR 0 3
54026: PPUSH
54027: CALL_OW 314
54031: NOT
54032: IFFALSE 54053
// ComTameXY ( j , x , y ) ;
54034: LD_VAR 0 3
54038: PPUSH
54039: LD_VAR 0 4
54043: PPUSH
54044: LD_VAR 0 5
54048: PPUSH
54049: CALL_OW 131
// end ; end ;
54053: GO 53718
54055: POP
54056: POP
// end ;
54057: GO 53274
54059: POP
54060: POP
// end ;
54061: LD_VAR 0 1
54065: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54066: LD_INT 0
54068: PPUSH
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
54073: PPUSH
54074: PPUSH
54075: PPUSH
// if not mc_bases then
54076: LD_EXP 112
54080: NOT
54081: IFFALSE 54085
// exit ;
54083: GO 54711
// for i = 1 to mc_bases do
54085: LD_ADDR_VAR 0 2
54089: PUSH
54090: DOUBLE
54091: LD_INT 1
54093: DEC
54094: ST_TO_ADDR
54095: LD_EXP 112
54099: PUSH
54100: FOR_TO
54101: IFFALSE 54709
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54103: LD_EXP 141
54107: PUSH
54108: LD_VAR 0 2
54112: ARRAY
54113: NOT
54114: PUSH
54115: LD_EXP 141
54119: PUSH
54120: LD_VAR 0 2
54124: ARRAY
54125: PPUSH
54126: LD_INT 25
54128: PUSH
54129: LD_INT 12
54131: PUSH
54132: EMPTY
54133: LIST
54134: LIST
54135: PPUSH
54136: CALL_OW 72
54140: NOT
54141: OR
54142: IFFALSE 54146
// continue ;
54144: GO 54100
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54146: LD_ADDR_VAR 0 5
54150: PUSH
54151: LD_EXP 141
54155: PUSH
54156: LD_VAR 0 2
54160: ARRAY
54161: PUSH
54162: LD_INT 1
54164: ARRAY
54165: PPUSH
54166: CALL_OW 255
54170: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54171: LD_VAR 0 5
54175: PPUSH
54176: LD_INT 2
54178: PPUSH
54179: CALL_OW 325
54183: IFFALSE 54436
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54185: LD_ADDR_VAR 0 4
54189: PUSH
54190: LD_EXP 141
54194: PUSH
54195: LD_VAR 0 2
54199: ARRAY
54200: PPUSH
54201: LD_INT 25
54203: PUSH
54204: LD_INT 16
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: PPUSH
54211: CALL_OW 72
54215: ST_TO_ADDR
// if tmp < 6 then
54216: LD_VAR 0 4
54220: PUSH
54221: LD_INT 6
54223: LESS
54224: IFFALSE 54436
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54226: LD_ADDR_VAR 0 6
54230: PUSH
54231: LD_EXP 112
54235: PUSH
54236: LD_VAR 0 2
54240: ARRAY
54241: PPUSH
54242: LD_INT 2
54244: PUSH
54245: LD_INT 30
54247: PUSH
54248: LD_INT 0
54250: PUSH
54251: EMPTY
54252: LIST
54253: LIST
54254: PUSH
54255: LD_INT 30
54257: PUSH
54258: LD_INT 1
54260: PUSH
54261: EMPTY
54262: LIST
54263: LIST
54264: PUSH
54265: EMPTY
54266: LIST
54267: LIST
54268: LIST
54269: PPUSH
54270: CALL_OW 72
54274: ST_TO_ADDR
// if depot then
54275: LD_VAR 0 6
54279: IFFALSE 54436
// begin selected := 0 ;
54281: LD_ADDR_VAR 0 7
54285: PUSH
54286: LD_INT 0
54288: ST_TO_ADDR
// for j in depot do
54289: LD_ADDR_VAR 0 3
54293: PUSH
54294: LD_VAR 0 6
54298: PUSH
54299: FOR_IN
54300: IFFALSE 54331
// begin if UnitsInside ( j ) < 6 then
54302: LD_VAR 0 3
54306: PPUSH
54307: CALL_OW 313
54311: PUSH
54312: LD_INT 6
54314: LESS
54315: IFFALSE 54329
// begin selected := j ;
54317: LD_ADDR_VAR 0 7
54321: PUSH
54322: LD_VAR 0 3
54326: ST_TO_ADDR
// break ;
54327: GO 54331
// end ; end ;
54329: GO 54299
54331: POP
54332: POP
// if selected then
54333: LD_VAR 0 7
54337: IFFALSE 54436
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54339: LD_ADDR_VAR 0 3
54343: PUSH
54344: LD_EXP 141
54348: PUSH
54349: LD_VAR 0 2
54353: ARRAY
54354: PPUSH
54355: LD_INT 25
54357: PUSH
54358: LD_INT 12
54360: PUSH
54361: EMPTY
54362: LIST
54363: LIST
54364: PPUSH
54365: CALL_OW 72
54369: PUSH
54370: FOR_IN
54371: IFFALSE 54434
// if not HasTask ( j ) then
54373: LD_VAR 0 3
54377: PPUSH
54378: CALL_OW 314
54382: NOT
54383: IFFALSE 54432
// begin if not IsInUnit ( j ) then
54385: LD_VAR 0 3
54389: PPUSH
54390: CALL_OW 310
54394: NOT
54395: IFFALSE 54411
// ComEnterUnit ( j , selected ) ;
54397: LD_VAR 0 3
54401: PPUSH
54402: LD_VAR 0 7
54406: PPUSH
54407: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54411: LD_VAR 0 3
54415: PPUSH
54416: LD_INT 16
54418: PPUSH
54419: CALL_OW 183
// AddComExitBuilding ( j ) ;
54423: LD_VAR 0 3
54427: PPUSH
54428: CALL_OW 182
// end ;
54432: GO 54370
54434: POP
54435: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54436: LD_VAR 0 5
54440: PPUSH
54441: LD_INT 11
54443: PPUSH
54444: CALL_OW 325
54448: IFFALSE 54707
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54450: LD_ADDR_VAR 0 4
54454: PUSH
54455: LD_EXP 141
54459: PUSH
54460: LD_VAR 0 2
54464: ARRAY
54465: PPUSH
54466: LD_INT 25
54468: PUSH
54469: LD_INT 16
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: PPUSH
54476: CALL_OW 72
54480: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54481: LD_VAR 0 4
54485: PUSH
54486: LD_INT 6
54488: GREATEREQUAL
54489: PUSH
54490: LD_VAR 0 5
54494: PPUSH
54495: LD_INT 2
54497: PPUSH
54498: CALL_OW 325
54502: NOT
54503: OR
54504: IFFALSE 54707
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54506: LD_ADDR_VAR 0 8
54510: PUSH
54511: LD_EXP 112
54515: PUSH
54516: LD_VAR 0 2
54520: ARRAY
54521: PPUSH
54522: LD_INT 2
54524: PUSH
54525: LD_INT 30
54527: PUSH
54528: LD_INT 4
54530: PUSH
54531: EMPTY
54532: LIST
54533: LIST
54534: PUSH
54535: LD_INT 30
54537: PUSH
54538: LD_INT 5
54540: PUSH
54541: EMPTY
54542: LIST
54543: LIST
54544: PUSH
54545: EMPTY
54546: LIST
54547: LIST
54548: LIST
54549: PPUSH
54550: CALL_OW 72
54554: ST_TO_ADDR
// if barracks then
54555: LD_VAR 0 8
54559: IFFALSE 54707
// begin selected := 0 ;
54561: LD_ADDR_VAR 0 7
54565: PUSH
54566: LD_INT 0
54568: ST_TO_ADDR
// for j in barracks do
54569: LD_ADDR_VAR 0 3
54573: PUSH
54574: LD_VAR 0 8
54578: PUSH
54579: FOR_IN
54580: IFFALSE 54611
// begin if UnitsInside ( j ) < 6 then
54582: LD_VAR 0 3
54586: PPUSH
54587: CALL_OW 313
54591: PUSH
54592: LD_INT 6
54594: LESS
54595: IFFALSE 54609
// begin selected := j ;
54597: LD_ADDR_VAR 0 7
54601: PUSH
54602: LD_VAR 0 3
54606: ST_TO_ADDR
// break ;
54607: GO 54611
// end ; end ;
54609: GO 54579
54611: POP
54612: POP
// if selected then
54613: LD_VAR 0 7
54617: IFFALSE 54707
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54619: LD_ADDR_VAR 0 3
54623: PUSH
54624: LD_EXP 141
54628: PUSH
54629: LD_VAR 0 2
54633: ARRAY
54634: PPUSH
54635: LD_INT 25
54637: PUSH
54638: LD_INT 12
54640: PUSH
54641: EMPTY
54642: LIST
54643: LIST
54644: PPUSH
54645: CALL_OW 72
54649: PUSH
54650: FOR_IN
54651: IFFALSE 54705
// if not IsInUnit ( j ) and not HasTask ( j ) then
54653: LD_VAR 0 3
54657: PPUSH
54658: CALL_OW 310
54662: NOT
54663: PUSH
54664: LD_VAR 0 3
54668: PPUSH
54669: CALL_OW 314
54673: NOT
54674: AND
54675: IFFALSE 54703
// begin ComEnterUnit ( j , selected ) ;
54677: LD_VAR 0 3
54681: PPUSH
54682: LD_VAR 0 7
54686: PPUSH
54687: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54691: LD_VAR 0 3
54695: PPUSH
54696: LD_INT 15
54698: PPUSH
54699: CALL_OW 183
// end ;
54703: GO 54650
54705: POP
54706: POP
// end ; end ; end ; end ; end ;
54707: GO 54100
54709: POP
54710: POP
// end ;
54711: LD_VAR 0 1
54715: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54716: LD_INT 0
54718: PPUSH
54719: PPUSH
54720: PPUSH
54721: PPUSH
// if not mc_bases then
54722: LD_EXP 112
54726: NOT
54727: IFFALSE 54731
// exit ;
54729: GO 54909
// for i = 1 to mc_bases do
54731: LD_ADDR_VAR 0 2
54735: PUSH
54736: DOUBLE
54737: LD_INT 1
54739: DEC
54740: ST_TO_ADDR
54741: LD_EXP 112
54745: PUSH
54746: FOR_TO
54747: IFFALSE 54907
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54749: LD_ADDR_VAR 0 4
54753: PUSH
54754: LD_EXP 112
54758: PUSH
54759: LD_VAR 0 2
54763: ARRAY
54764: PPUSH
54765: LD_INT 25
54767: PUSH
54768: LD_INT 9
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PPUSH
54775: CALL_OW 72
54779: ST_TO_ADDR
// if not tmp then
54780: LD_VAR 0 4
54784: NOT
54785: IFFALSE 54789
// continue ;
54787: GO 54746
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54789: LD_EXP 138
54793: PUSH
54794: LD_VAR 0 2
54798: ARRAY
54799: PPUSH
54800: LD_INT 29
54802: PPUSH
54803: CALL_OW 325
54807: NOT
54808: PUSH
54809: LD_EXP 138
54813: PUSH
54814: LD_VAR 0 2
54818: ARRAY
54819: PPUSH
54820: LD_INT 28
54822: PPUSH
54823: CALL_OW 325
54827: NOT
54828: AND
54829: IFFALSE 54833
// continue ;
54831: GO 54746
// for j in tmp do
54833: LD_ADDR_VAR 0 3
54837: PUSH
54838: LD_VAR 0 4
54842: PUSH
54843: FOR_IN
54844: IFFALSE 54903
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54846: LD_VAR 0 3
54850: PUSH
54851: LD_EXP 115
54855: PUSH
54856: LD_VAR 0 2
54860: ARRAY
54861: PUSH
54862: LD_INT 1
54864: ARRAY
54865: IN
54866: NOT
54867: PUSH
54868: LD_VAR 0 3
54872: PUSH
54873: LD_EXP 115
54877: PUSH
54878: LD_VAR 0 2
54882: ARRAY
54883: PUSH
54884: LD_INT 2
54886: ARRAY
54887: IN
54888: NOT
54889: AND
54890: IFFALSE 54901
// ComSpaceTimeShoot ( j ) ;
54892: LD_VAR 0 3
54896: PPUSH
54897: CALL 66047 0 1
54901: GO 54843
54903: POP
54904: POP
// end ;
54905: GO 54746
54907: POP
54908: POP
// end ;
54909: LD_VAR 0 1
54913: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54914: LD_INT 0
54916: PPUSH
54917: PPUSH
54918: PPUSH
54919: PPUSH
54920: PPUSH
54921: PPUSH
54922: PPUSH
54923: PPUSH
54924: PPUSH
// if not mc_bases then
54925: LD_EXP 112
54929: NOT
54930: IFFALSE 54934
// exit ;
54932: GO 55556
// for i = 1 to mc_bases do
54934: LD_ADDR_VAR 0 2
54938: PUSH
54939: DOUBLE
54940: LD_INT 1
54942: DEC
54943: ST_TO_ADDR
54944: LD_EXP 112
54948: PUSH
54949: FOR_TO
54950: IFFALSE 55554
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54952: LD_EXP 147
54956: PUSH
54957: LD_VAR 0 2
54961: ARRAY
54962: NOT
54963: PUSH
54964: LD_INT 38
54966: PPUSH
54967: LD_EXP 138
54971: PUSH
54972: LD_VAR 0 2
54976: ARRAY
54977: PPUSH
54978: CALL_OW 321
54982: PUSH
54983: LD_INT 2
54985: NONEQUAL
54986: OR
54987: IFFALSE 54991
// continue ;
54989: GO 54949
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54991: LD_ADDR_VAR 0 8
54995: PUSH
54996: LD_EXP 112
55000: PUSH
55001: LD_VAR 0 2
55005: ARRAY
55006: PPUSH
55007: LD_INT 30
55009: PUSH
55010: LD_INT 34
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: PPUSH
55017: CALL_OW 72
55021: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55022: LD_ADDR_VAR 0 9
55026: PUSH
55027: LD_EXP 112
55031: PUSH
55032: LD_VAR 0 2
55036: ARRAY
55037: PPUSH
55038: LD_INT 25
55040: PUSH
55041: LD_INT 4
55043: PUSH
55044: EMPTY
55045: LIST
55046: LIST
55047: PPUSH
55048: CALL_OW 72
55052: PPUSH
55053: LD_INT 0
55055: PPUSH
55056: CALL 98611 0 2
55060: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55061: LD_VAR 0 9
55065: NOT
55066: PUSH
55067: LD_VAR 0 8
55071: NOT
55072: OR
55073: PUSH
55074: LD_EXP 112
55078: PUSH
55079: LD_VAR 0 2
55083: ARRAY
55084: PPUSH
55085: LD_INT 124
55087: PPUSH
55088: CALL 98611 0 2
55092: OR
55093: IFFALSE 55097
// continue ;
55095: GO 54949
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55097: LD_EXP 148
55101: PUSH
55102: LD_VAR 0 2
55106: ARRAY
55107: PUSH
55108: LD_EXP 147
55112: PUSH
55113: LD_VAR 0 2
55117: ARRAY
55118: LESS
55119: PUSH
55120: LD_EXP 148
55124: PUSH
55125: LD_VAR 0 2
55129: ARRAY
55130: PUSH
55131: LD_VAR 0 8
55135: LESS
55136: AND
55137: IFFALSE 55552
// begin tmp := sci [ 1 ] ;
55139: LD_ADDR_VAR 0 7
55143: PUSH
55144: LD_VAR 0 9
55148: PUSH
55149: LD_INT 1
55151: ARRAY
55152: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55153: LD_VAR 0 7
55157: PPUSH
55158: LD_INT 124
55160: PPUSH
55161: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55165: LD_ADDR_VAR 0 3
55169: PUSH
55170: DOUBLE
55171: LD_EXP 147
55175: PUSH
55176: LD_VAR 0 2
55180: ARRAY
55181: INC
55182: ST_TO_ADDR
55183: LD_EXP 147
55187: PUSH
55188: LD_VAR 0 2
55192: ARRAY
55193: PUSH
55194: FOR_DOWNTO
55195: IFFALSE 55538
// begin if IsInUnit ( tmp ) then
55197: LD_VAR 0 7
55201: PPUSH
55202: CALL_OW 310
55206: IFFALSE 55217
// ComExitBuilding ( tmp ) ;
55208: LD_VAR 0 7
55212: PPUSH
55213: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55217: LD_INT 35
55219: PPUSH
55220: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55224: LD_VAR 0 7
55228: PPUSH
55229: CALL_OW 310
55233: NOT
55234: PUSH
55235: LD_VAR 0 7
55239: PPUSH
55240: CALL_OW 314
55244: NOT
55245: AND
55246: IFFALSE 55217
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55248: LD_ADDR_VAR 0 6
55252: PUSH
55253: LD_VAR 0 7
55257: PPUSH
55258: CALL_OW 250
55262: PUSH
55263: LD_VAR 0 7
55267: PPUSH
55268: CALL_OW 251
55272: PUSH
55273: EMPTY
55274: LIST
55275: LIST
55276: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55277: LD_INT 35
55279: PPUSH
55280: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55284: LD_ADDR_VAR 0 4
55288: PUSH
55289: LD_EXP 147
55293: PUSH
55294: LD_VAR 0 2
55298: ARRAY
55299: PUSH
55300: LD_VAR 0 3
55304: ARRAY
55305: PUSH
55306: LD_INT 1
55308: ARRAY
55309: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55310: LD_ADDR_VAR 0 5
55314: PUSH
55315: LD_EXP 147
55319: PUSH
55320: LD_VAR 0 2
55324: ARRAY
55325: PUSH
55326: LD_VAR 0 3
55330: ARRAY
55331: PUSH
55332: LD_INT 2
55334: ARRAY
55335: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55336: LD_VAR 0 7
55340: PPUSH
55341: LD_INT 10
55343: PPUSH
55344: CALL 72643 0 2
55348: PUSH
55349: LD_INT 4
55351: ARRAY
55352: IFFALSE 55390
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55354: LD_VAR 0 7
55358: PPUSH
55359: LD_VAR 0 6
55363: PUSH
55364: LD_INT 1
55366: ARRAY
55367: PPUSH
55368: LD_VAR 0 6
55372: PUSH
55373: LD_INT 2
55375: ARRAY
55376: PPUSH
55377: CALL_OW 111
// wait ( 0 0$10 ) ;
55381: LD_INT 350
55383: PPUSH
55384: CALL_OW 67
// end else
55388: GO 55416
// begin ComMoveXY ( tmp , x , y ) ;
55390: LD_VAR 0 7
55394: PPUSH
55395: LD_VAR 0 4
55399: PPUSH
55400: LD_VAR 0 5
55404: PPUSH
55405: CALL_OW 111
// wait ( 0 0$3 ) ;
55409: LD_INT 105
55411: PPUSH
55412: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55416: LD_VAR 0 7
55420: PPUSH
55421: LD_VAR 0 4
55425: PPUSH
55426: LD_VAR 0 5
55430: PPUSH
55431: CALL_OW 307
55435: IFFALSE 55277
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55437: LD_VAR 0 7
55441: PPUSH
55442: LD_VAR 0 4
55446: PPUSH
55447: LD_VAR 0 5
55451: PPUSH
55452: LD_VAR 0 8
55456: PUSH
55457: LD_VAR 0 3
55461: ARRAY
55462: PPUSH
55463: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55467: LD_INT 35
55469: PPUSH
55470: CALL_OW 67
// until not HasTask ( tmp ) ;
55474: LD_VAR 0 7
55478: PPUSH
55479: CALL_OW 314
55483: NOT
55484: IFFALSE 55467
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55486: LD_ADDR_EXP 148
55490: PUSH
55491: LD_EXP 148
55495: PPUSH
55496: LD_VAR 0 2
55500: PUSH
55501: LD_EXP 148
55505: PUSH
55506: LD_VAR 0 2
55510: ARRAY
55511: PUSH
55512: LD_INT 1
55514: PLUS
55515: PUSH
55516: EMPTY
55517: LIST
55518: LIST
55519: PPUSH
55520: LD_VAR 0 8
55524: PUSH
55525: LD_VAR 0 3
55529: ARRAY
55530: PPUSH
55531: CALL 70050 0 3
55535: ST_TO_ADDR
// end ;
55536: GO 55194
55538: POP
55539: POP
// MC_Reset ( i , 124 ) ;
55540: LD_VAR 0 2
55544: PPUSH
55545: LD_INT 124
55547: PPUSH
55548: CALL 39159 0 2
// end ; end ;
55552: GO 54949
55554: POP
55555: POP
// end ;
55556: LD_VAR 0 1
55560: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55561: LD_INT 0
55563: PPUSH
55564: PPUSH
55565: PPUSH
// if not mc_bases then
55566: LD_EXP 112
55570: NOT
55571: IFFALSE 55575
// exit ;
55573: GO 56181
// for i = 1 to mc_bases do
55575: LD_ADDR_VAR 0 2
55579: PUSH
55580: DOUBLE
55581: LD_INT 1
55583: DEC
55584: ST_TO_ADDR
55585: LD_EXP 112
55589: PUSH
55590: FOR_TO
55591: IFFALSE 56179
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55593: LD_ADDR_VAR 0 3
55597: PUSH
55598: LD_EXP 112
55602: PUSH
55603: LD_VAR 0 2
55607: ARRAY
55608: PPUSH
55609: LD_INT 25
55611: PUSH
55612: LD_INT 4
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: PPUSH
55619: CALL_OW 72
55623: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55624: LD_VAR 0 3
55628: NOT
55629: PUSH
55630: LD_EXP 149
55634: PUSH
55635: LD_VAR 0 2
55639: ARRAY
55640: NOT
55641: OR
55642: PUSH
55643: LD_EXP 112
55647: PUSH
55648: LD_VAR 0 2
55652: ARRAY
55653: PPUSH
55654: LD_INT 2
55656: PUSH
55657: LD_INT 30
55659: PUSH
55660: LD_INT 0
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: PUSH
55667: LD_INT 30
55669: PUSH
55670: LD_INT 1
55672: PUSH
55673: EMPTY
55674: LIST
55675: LIST
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: LIST
55681: PPUSH
55682: CALL_OW 72
55686: NOT
55687: OR
55688: IFFALSE 55738
// begin if mc_deposits_finder [ i ] then
55690: LD_EXP 150
55694: PUSH
55695: LD_VAR 0 2
55699: ARRAY
55700: IFFALSE 55736
// begin MC_Reset ( i , 125 ) ;
55702: LD_VAR 0 2
55706: PPUSH
55707: LD_INT 125
55709: PPUSH
55710: CALL 39159 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55714: LD_ADDR_EXP 150
55718: PUSH
55719: LD_EXP 150
55723: PPUSH
55724: LD_VAR 0 2
55728: PPUSH
55729: EMPTY
55730: PPUSH
55731: CALL_OW 1
55735: ST_TO_ADDR
// end ; continue ;
55736: GO 55590
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55738: LD_EXP 149
55742: PUSH
55743: LD_VAR 0 2
55747: ARRAY
55748: PUSH
55749: LD_INT 1
55751: ARRAY
55752: PUSH
55753: LD_INT 3
55755: ARRAY
55756: PUSH
55757: LD_INT 1
55759: EQUAL
55760: PUSH
55761: LD_INT 20
55763: PPUSH
55764: LD_EXP 138
55768: PUSH
55769: LD_VAR 0 2
55773: ARRAY
55774: PPUSH
55775: CALL_OW 321
55779: PUSH
55780: LD_INT 2
55782: NONEQUAL
55783: AND
55784: IFFALSE 55834
// begin if mc_deposits_finder [ i ] then
55786: LD_EXP 150
55790: PUSH
55791: LD_VAR 0 2
55795: ARRAY
55796: IFFALSE 55832
// begin MC_Reset ( i , 125 ) ;
55798: LD_VAR 0 2
55802: PPUSH
55803: LD_INT 125
55805: PPUSH
55806: CALL 39159 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55810: LD_ADDR_EXP 150
55814: PUSH
55815: LD_EXP 150
55819: PPUSH
55820: LD_VAR 0 2
55824: PPUSH
55825: EMPTY
55826: PPUSH
55827: CALL_OW 1
55831: ST_TO_ADDR
// end ; continue ;
55832: GO 55590
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55834: LD_EXP 149
55838: PUSH
55839: LD_VAR 0 2
55843: ARRAY
55844: PUSH
55845: LD_INT 1
55847: ARRAY
55848: PUSH
55849: LD_INT 1
55851: ARRAY
55852: PPUSH
55853: LD_EXP 149
55857: PUSH
55858: LD_VAR 0 2
55862: ARRAY
55863: PUSH
55864: LD_INT 1
55866: ARRAY
55867: PUSH
55868: LD_INT 2
55870: ARRAY
55871: PPUSH
55872: LD_EXP 138
55876: PUSH
55877: LD_VAR 0 2
55881: ARRAY
55882: PPUSH
55883: CALL_OW 440
55887: IFFALSE 55930
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55889: LD_ADDR_EXP 149
55893: PUSH
55894: LD_EXP 149
55898: PPUSH
55899: LD_VAR 0 2
55903: PPUSH
55904: LD_EXP 149
55908: PUSH
55909: LD_VAR 0 2
55913: ARRAY
55914: PPUSH
55915: LD_INT 1
55917: PPUSH
55918: CALL_OW 3
55922: PPUSH
55923: CALL_OW 1
55927: ST_TO_ADDR
55928: GO 56177
// begin if not mc_deposits_finder [ i ] then
55930: LD_EXP 150
55934: PUSH
55935: LD_VAR 0 2
55939: ARRAY
55940: NOT
55941: IFFALSE 55993
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55943: LD_ADDR_EXP 150
55947: PUSH
55948: LD_EXP 150
55952: PPUSH
55953: LD_VAR 0 2
55957: PPUSH
55958: LD_VAR 0 3
55962: PUSH
55963: LD_INT 1
55965: ARRAY
55966: PUSH
55967: EMPTY
55968: LIST
55969: PPUSH
55970: CALL_OW 1
55974: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55975: LD_VAR 0 3
55979: PUSH
55980: LD_INT 1
55982: ARRAY
55983: PPUSH
55984: LD_INT 125
55986: PPUSH
55987: CALL_OW 109
// end else
55991: GO 56177
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55993: LD_EXP 150
55997: PUSH
55998: LD_VAR 0 2
56002: ARRAY
56003: PUSH
56004: LD_INT 1
56006: ARRAY
56007: PPUSH
56008: CALL_OW 310
56012: IFFALSE 56035
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56014: LD_EXP 150
56018: PUSH
56019: LD_VAR 0 2
56023: ARRAY
56024: PUSH
56025: LD_INT 1
56027: ARRAY
56028: PPUSH
56029: CALL_OW 122
56033: GO 56177
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56035: LD_EXP 150
56039: PUSH
56040: LD_VAR 0 2
56044: ARRAY
56045: PUSH
56046: LD_INT 1
56048: ARRAY
56049: PPUSH
56050: CALL_OW 314
56054: NOT
56055: PUSH
56056: LD_EXP 150
56060: PUSH
56061: LD_VAR 0 2
56065: ARRAY
56066: PUSH
56067: LD_INT 1
56069: ARRAY
56070: PPUSH
56071: LD_EXP 149
56075: PUSH
56076: LD_VAR 0 2
56080: ARRAY
56081: PUSH
56082: LD_INT 1
56084: ARRAY
56085: PUSH
56086: LD_INT 1
56088: ARRAY
56089: PPUSH
56090: LD_EXP 149
56094: PUSH
56095: LD_VAR 0 2
56099: ARRAY
56100: PUSH
56101: LD_INT 1
56103: ARRAY
56104: PUSH
56105: LD_INT 2
56107: ARRAY
56108: PPUSH
56109: CALL_OW 297
56113: PUSH
56114: LD_INT 6
56116: GREATER
56117: AND
56118: IFFALSE 56177
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56120: LD_EXP 150
56124: PUSH
56125: LD_VAR 0 2
56129: ARRAY
56130: PUSH
56131: LD_INT 1
56133: ARRAY
56134: PPUSH
56135: LD_EXP 149
56139: PUSH
56140: LD_VAR 0 2
56144: ARRAY
56145: PUSH
56146: LD_INT 1
56148: ARRAY
56149: PUSH
56150: LD_INT 1
56152: ARRAY
56153: PPUSH
56154: LD_EXP 149
56158: PUSH
56159: LD_VAR 0 2
56163: ARRAY
56164: PUSH
56165: LD_INT 1
56167: ARRAY
56168: PUSH
56169: LD_INT 2
56171: ARRAY
56172: PPUSH
56173: CALL_OW 111
// end ; end ; end ;
56177: GO 55590
56179: POP
56180: POP
// end ;
56181: LD_VAR 0 1
56185: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56186: LD_INT 0
56188: PPUSH
56189: PPUSH
56190: PPUSH
56191: PPUSH
56192: PPUSH
56193: PPUSH
56194: PPUSH
56195: PPUSH
56196: PPUSH
56197: PPUSH
56198: PPUSH
// if not mc_bases then
56199: LD_EXP 112
56203: NOT
56204: IFFALSE 56208
// exit ;
56206: GO 57148
// for i = 1 to mc_bases do
56208: LD_ADDR_VAR 0 2
56212: PUSH
56213: DOUBLE
56214: LD_INT 1
56216: DEC
56217: ST_TO_ADDR
56218: LD_EXP 112
56222: PUSH
56223: FOR_TO
56224: IFFALSE 57146
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56226: LD_EXP 112
56230: PUSH
56231: LD_VAR 0 2
56235: ARRAY
56236: NOT
56237: PUSH
56238: LD_EXP 135
56242: PUSH
56243: LD_VAR 0 2
56247: ARRAY
56248: OR
56249: IFFALSE 56253
// continue ;
56251: GO 56223
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56253: LD_ADDR_VAR 0 7
56257: PUSH
56258: LD_EXP 112
56262: PUSH
56263: LD_VAR 0 2
56267: ARRAY
56268: PUSH
56269: LD_INT 1
56271: ARRAY
56272: PPUSH
56273: CALL_OW 248
56277: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56278: LD_VAR 0 7
56282: PUSH
56283: LD_INT 3
56285: EQUAL
56286: PUSH
56287: LD_EXP 131
56291: PUSH
56292: LD_VAR 0 2
56296: ARRAY
56297: PUSH
56298: LD_EXP 134
56302: PUSH
56303: LD_VAR 0 2
56307: ARRAY
56308: UNION
56309: PPUSH
56310: LD_INT 33
56312: PUSH
56313: LD_INT 2
56315: PUSH
56316: EMPTY
56317: LIST
56318: LIST
56319: PPUSH
56320: CALL_OW 72
56324: NOT
56325: OR
56326: IFFALSE 56330
// continue ;
56328: GO 56223
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56330: LD_ADDR_VAR 0 9
56334: PUSH
56335: LD_EXP 112
56339: PUSH
56340: LD_VAR 0 2
56344: ARRAY
56345: PPUSH
56346: LD_INT 30
56348: PUSH
56349: LD_INT 36
56351: PUSH
56352: EMPTY
56353: LIST
56354: LIST
56355: PPUSH
56356: CALL_OW 72
56360: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56361: LD_ADDR_VAR 0 10
56365: PUSH
56366: LD_EXP 131
56370: PUSH
56371: LD_VAR 0 2
56375: ARRAY
56376: PPUSH
56377: LD_INT 34
56379: PUSH
56380: LD_INT 31
56382: PUSH
56383: EMPTY
56384: LIST
56385: LIST
56386: PPUSH
56387: CALL_OW 72
56391: ST_TO_ADDR
// if not cts and not mcts then
56392: LD_VAR 0 9
56396: NOT
56397: PUSH
56398: LD_VAR 0 10
56402: NOT
56403: AND
56404: IFFALSE 56408
// continue ;
56406: GO 56223
// x := cts ;
56408: LD_ADDR_VAR 0 11
56412: PUSH
56413: LD_VAR 0 9
56417: ST_TO_ADDR
// if not x then
56418: LD_VAR 0 11
56422: NOT
56423: IFFALSE 56435
// x := mcts ;
56425: LD_ADDR_VAR 0 11
56429: PUSH
56430: LD_VAR 0 10
56434: ST_TO_ADDR
// if not x then
56435: LD_VAR 0 11
56439: NOT
56440: IFFALSE 56444
// continue ;
56442: GO 56223
// if mc_remote_driver [ i ] then
56444: LD_EXP 152
56448: PUSH
56449: LD_VAR 0 2
56453: ARRAY
56454: IFFALSE 56841
// for j in mc_remote_driver [ i ] do
56456: LD_ADDR_VAR 0 3
56460: PUSH
56461: LD_EXP 152
56465: PUSH
56466: LD_VAR 0 2
56470: ARRAY
56471: PUSH
56472: FOR_IN
56473: IFFALSE 56839
// begin if GetClass ( j ) <> 3 then
56475: LD_VAR 0 3
56479: PPUSH
56480: CALL_OW 257
56484: PUSH
56485: LD_INT 3
56487: NONEQUAL
56488: IFFALSE 56541
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56490: LD_ADDR_EXP 152
56494: PUSH
56495: LD_EXP 152
56499: PPUSH
56500: LD_VAR 0 2
56504: PPUSH
56505: LD_EXP 152
56509: PUSH
56510: LD_VAR 0 2
56514: ARRAY
56515: PUSH
56516: LD_VAR 0 3
56520: DIFF
56521: PPUSH
56522: CALL_OW 1
56526: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56527: LD_VAR 0 3
56531: PPUSH
56532: LD_INT 0
56534: PPUSH
56535: CALL_OW 109
// continue ;
56539: GO 56472
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56541: LD_EXP 131
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: PPUSH
56552: LD_INT 34
56554: PUSH
56555: LD_INT 31
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: PUSH
56562: LD_INT 58
56564: PUSH
56565: EMPTY
56566: LIST
56567: PUSH
56568: EMPTY
56569: LIST
56570: LIST
56571: PPUSH
56572: CALL_OW 72
56576: PUSH
56577: LD_VAR 0 3
56581: PPUSH
56582: CALL 98699 0 1
56586: NOT
56587: AND
56588: IFFALSE 56659
// begin if IsInUnit ( j ) then
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 310
56599: IFFALSE 56610
// ComExitBuilding ( j ) ;
56601: LD_VAR 0 3
56605: PPUSH
56606: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56610: LD_VAR 0 3
56614: PPUSH
56615: LD_EXP 131
56619: PUSH
56620: LD_VAR 0 2
56624: ARRAY
56625: PPUSH
56626: LD_INT 34
56628: PUSH
56629: LD_INT 31
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: PUSH
56636: LD_INT 58
56638: PUSH
56639: EMPTY
56640: LIST
56641: PUSH
56642: EMPTY
56643: LIST
56644: LIST
56645: PPUSH
56646: CALL_OW 72
56650: PUSH
56651: LD_INT 1
56653: ARRAY
56654: PPUSH
56655: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56659: LD_VAR 0 3
56663: PPUSH
56664: CALL_OW 310
56668: NOT
56669: PUSH
56670: LD_VAR 0 3
56674: PPUSH
56675: CALL_OW 310
56679: PPUSH
56680: CALL_OW 266
56684: PUSH
56685: LD_INT 36
56687: NONEQUAL
56688: PUSH
56689: LD_VAR 0 3
56693: PPUSH
56694: CALL 98699 0 1
56698: NOT
56699: AND
56700: OR
56701: IFFALSE 56837
// begin if IsInUnit ( j ) then
56703: LD_VAR 0 3
56707: PPUSH
56708: CALL_OW 310
56712: IFFALSE 56723
// ComExitBuilding ( j ) ;
56714: LD_VAR 0 3
56718: PPUSH
56719: CALL_OW 122
// ct := 0 ;
56723: LD_ADDR_VAR 0 8
56727: PUSH
56728: LD_INT 0
56730: ST_TO_ADDR
// for k in x do
56731: LD_ADDR_VAR 0 4
56735: PUSH
56736: LD_VAR 0 11
56740: PUSH
56741: FOR_IN
56742: IFFALSE 56815
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56744: LD_VAR 0 4
56748: PPUSH
56749: CALL_OW 264
56753: PUSH
56754: LD_INT 31
56756: EQUAL
56757: PUSH
56758: LD_VAR 0 4
56762: PPUSH
56763: CALL_OW 311
56767: NOT
56768: AND
56769: PUSH
56770: LD_VAR 0 4
56774: PPUSH
56775: CALL_OW 266
56779: PUSH
56780: LD_INT 36
56782: EQUAL
56783: PUSH
56784: LD_VAR 0 4
56788: PPUSH
56789: CALL_OW 313
56793: PUSH
56794: LD_INT 3
56796: LESS
56797: AND
56798: OR
56799: IFFALSE 56813
// begin ct := k ;
56801: LD_ADDR_VAR 0 8
56805: PUSH
56806: LD_VAR 0 4
56810: ST_TO_ADDR
// break ;
56811: GO 56815
// end ;
56813: GO 56741
56815: POP
56816: POP
// if ct then
56817: LD_VAR 0 8
56821: IFFALSE 56837
// ComEnterUnit ( j , ct ) ;
56823: LD_VAR 0 3
56827: PPUSH
56828: LD_VAR 0 8
56832: PPUSH
56833: CALL_OW 120
// end ; end ;
56837: GO 56472
56839: POP
56840: POP
// places := 0 ;
56841: LD_ADDR_VAR 0 5
56845: PUSH
56846: LD_INT 0
56848: ST_TO_ADDR
// for j = 1 to x do
56849: LD_ADDR_VAR 0 3
56853: PUSH
56854: DOUBLE
56855: LD_INT 1
56857: DEC
56858: ST_TO_ADDR
56859: LD_VAR 0 11
56863: PUSH
56864: FOR_TO
56865: IFFALSE 56941
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56867: LD_VAR 0 11
56871: PUSH
56872: LD_VAR 0 3
56876: ARRAY
56877: PPUSH
56878: CALL_OW 264
56882: PUSH
56883: LD_INT 31
56885: EQUAL
56886: IFFALSE 56904
// places := places + 1 else
56888: LD_ADDR_VAR 0 5
56892: PUSH
56893: LD_VAR 0 5
56897: PUSH
56898: LD_INT 1
56900: PLUS
56901: ST_TO_ADDR
56902: GO 56939
// if GetBType ( x [ j ] ) = b_control_tower then
56904: LD_VAR 0 11
56908: PUSH
56909: LD_VAR 0 3
56913: ARRAY
56914: PPUSH
56915: CALL_OW 266
56919: PUSH
56920: LD_INT 36
56922: EQUAL
56923: IFFALSE 56939
// places := places + 3 ;
56925: LD_ADDR_VAR 0 5
56929: PUSH
56930: LD_VAR 0 5
56934: PUSH
56935: LD_INT 3
56937: PLUS
56938: ST_TO_ADDR
56939: GO 56864
56941: POP
56942: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56943: LD_VAR 0 5
56947: PUSH
56948: LD_INT 0
56950: EQUAL
56951: PUSH
56952: LD_VAR 0 5
56956: PUSH
56957: LD_EXP 152
56961: PUSH
56962: LD_VAR 0 2
56966: ARRAY
56967: LESSEQUAL
56968: OR
56969: IFFALSE 56973
// continue ;
56971: GO 56223
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56973: LD_ADDR_VAR 0 6
56977: PUSH
56978: LD_EXP 112
56982: PUSH
56983: LD_VAR 0 2
56987: ARRAY
56988: PPUSH
56989: LD_INT 25
56991: PUSH
56992: LD_INT 3
56994: PUSH
56995: EMPTY
56996: LIST
56997: LIST
56998: PPUSH
56999: CALL_OW 72
57003: PUSH
57004: LD_EXP 152
57008: PUSH
57009: LD_VAR 0 2
57013: ARRAY
57014: DIFF
57015: PPUSH
57016: LD_INT 3
57018: PPUSH
57019: CALL 99599 0 2
57023: ST_TO_ADDR
// for j in tmp do
57024: LD_ADDR_VAR 0 3
57028: PUSH
57029: LD_VAR 0 6
57033: PUSH
57034: FOR_IN
57035: IFFALSE 57070
// if GetTag ( j ) > 0 then
57037: LD_VAR 0 3
57041: PPUSH
57042: CALL_OW 110
57046: PUSH
57047: LD_INT 0
57049: GREATER
57050: IFFALSE 57068
// tmp := tmp diff j ;
57052: LD_ADDR_VAR 0 6
57056: PUSH
57057: LD_VAR 0 6
57061: PUSH
57062: LD_VAR 0 3
57066: DIFF
57067: ST_TO_ADDR
57068: GO 57034
57070: POP
57071: POP
// if not tmp then
57072: LD_VAR 0 6
57076: NOT
57077: IFFALSE 57081
// continue ;
57079: GO 56223
// if places then
57081: LD_VAR 0 5
57085: IFFALSE 57144
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57087: LD_ADDR_EXP 152
57091: PUSH
57092: LD_EXP 152
57096: PPUSH
57097: LD_VAR 0 2
57101: PPUSH
57102: LD_EXP 152
57106: PUSH
57107: LD_VAR 0 2
57111: ARRAY
57112: PUSH
57113: LD_VAR 0 6
57117: PUSH
57118: LD_INT 1
57120: ARRAY
57121: UNION
57122: PPUSH
57123: CALL_OW 1
57127: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57128: LD_VAR 0 6
57132: PUSH
57133: LD_INT 1
57135: ARRAY
57136: PPUSH
57137: LD_INT 126
57139: PPUSH
57140: CALL_OW 109
// end ; end ;
57144: GO 56223
57146: POP
57147: POP
// end ;
57148: LD_VAR 0 1
57152: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57153: LD_INT 0
57155: PPUSH
57156: PPUSH
57157: PPUSH
57158: PPUSH
57159: PPUSH
57160: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57161: LD_VAR 0 1
57165: NOT
57166: PUSH
57167: LD_VAR 0 2
57171: NOT
57172: OR
57173: PUSH
57174: LD_VAR 0 3
57178: NOT
57179: OR
57180: PUSH
57181: LD_VAR 0 4
57185: PUSH
57186: LD_INT 1
57188: PUSH
57189: LD_INT 2
57191: PUSH
57192: LD_INT 3
57194: PUSH
57195: LD_INT 4
57197: PUSH
57198: LD_INT 5
57200: PUSH
57201: LD_INT 8
57203: PUSH
57204: LD_INT 9
57206: PUSH
57207: LD_INT 15
57209: PUSH
57210: LD_INT 16
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: LIST
57217: LIST
57218: LIST
57219: LIST
57220: LIST
57221: LIST
57222: LIST
57223: IN
57224: NOT
57225: OR
57226: IFFALSE 57230
// exit ;
57228: GO 58130
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57230: LD_ADDR_VAR 0 2
57234: PUSH
57235: LD_VAR 0 2
57239: PPUSH
57240: LD_INT 21
57242: PUSH
57243: LD_INT 3
57245: PUSH
57246: EMPTY
57247: LIST
57248: LIST
57249: PUSH
57250: LD_INT 24
57252: PUSH
57253: LD_INT 250
57255: PUSH
57256: EMPTY
57257: LIST
57258: LIST
57259: PUSH
57260: EMPTY
57261: LIST
57262: LIST
57263: PPUSH
57264: CALL_OW 72
57268: ST_TO_ADDR
// case class of 1 , 15 :
57269: LD_VAR 0 4
57273: PUSH
57274: LD_INT 1
57276: DOUBLE
57277: EQUAL
57278: IFTRUE 57288
57280: LD_INT 15
57282: DOUBLE
57283: EQUAL
57284: IFTRUE 57288
57286: GO 57373
57288: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57289: LD_ADDR_VAR 0 8
57293: PUSH
57294: LD_VAR 0 2
57298: PPUSH
57299: LD_INT 2
57301: PUSH
57302: LD_INT 30
57304: PUSH
57305: LD_INT 32
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PUSH
57312: LD_INT 30
57314: PUSH
57315: LD_INT 31
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: LIST
57326: PPUSH
57327: CALL_OW 72
57331: PUSH
57332: LD_VAR 0 2
57336: PPUSH
57337: LD_INT 2
57339: PUSH
57340: LD_INT 30
57342: PUSH
57343: LD_INT 4
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PUSH
57350: LD_INT 30
57352: PUSH
57353: LD_INT 5
57355: PUSH
57356: EMPTY
57357: LIST
57358: LIST
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: LIST
57364: PPUSH
57365: CALL_OW 72
57369: ADD
57370: ST_TO_ADDR
57371: GO 57619
57373: LD_INT 2
57375: DOUBLE
57376: EQUAL
57377: IFTRUE 57387
57379: LD_INT 16
57381: DOUBLE
57382: EQUAL
57383: IFTRUE 57387
57385: GO 57433
57387: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57388: LD_ADDR_VAR 0 8
57392: PUSH
57393: LD_VAR 0 2
57397: PPUSH
57398: LD_INT 2
57400: PUSH
57401: LD_INT 30
57403: PUSH
57404: LD_INT 0
57406: PUSH
57407: EMPTY
57408: LIST
57409: LIST
57410: PUSH
57411: LD_INT 30
57413: PUSH
57414: LD_INT 1
57416: PUSH
57417: EMPTY
57418: LIST
57419: LIST
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: LIST
57425: PPUSH
57426: CALL_OW 72
57430: ST_TO_ADDR
57431: GO 57619
57433: LD_INT 3
57435: DOUBLE
57436: EQUAL
57437: IFTRUE 57441
57439: GO 57487
57441: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57442: LD_ADDR_VAR 0 8
57446: PUSH
57447: LD_VAR 0 2
57451: PPUSH
57452: LD_INT 2
57454: PUSH
57455: LD_INT 30
57457: PUSH
57458: LD_INT 2
57460: PUSH
57461: EMPTY
57462: LIST
57463: LIST
57464: PUSH
57465: LD_INT 30
57467: PUSH
57468: LD_INT 3
57470: PUSH
57471: EMPTY
57472: LIST
57473: LIST
57474: PUSH
57475: EMPTY
57476: LIST
57477: LIST
57478: LIST
57479: PPUSH
57480: CALL_OW 72
57484: ST_TO_ADDR
57485: GO 57619
57487: LD_INT 4
57489: DOUBLE
57490: EQUAL
57491: IFTRUE 57495
57493: GO 57552
57495: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57496: LD_ADDR_VAR 0 8
57500: PUSH
57501: LD_VAR 0 2
57505: PPUSH
57506: LD_INT 2
57508: PUSH
57509: LD_INT 30
57511: PUSH
57512: LD_INT 6
57514: PUSH
57515: EMPTY
57516: LIST
57517: LIST
57518: PUSH
57519: LD_INT 30
57521: PUSH
57522: LD_INT 7
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: PUSH
57529: LD_INT 30
57531: PUSH
57532: LD_INT 8
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: PUSH
57539: EMPTY
57540: LIST
57541: LIST
57542: LIST
57543: LIST
57544: PPUSH
57545: CALL_OW 72
57549: ST_TO_ADDR
57550: GO 57619
57552: LD_INT 5
57554: DOUBLE
57555: EQUAL
57556: IFTRUE 57572
57558: LD_INT 8
57560: DOUBLE
57561: EQUAL
57562: IFTRUE 57572
57564: LD_INT 9
57566: DOUBLE
57567: EQUAL
57568: IFTRUE 57572
57570: GO 57618
57572: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57573: LD_ADDR_VAR 0 8
57577: PUSH
57578: LD_VAR 0 2
57582: PPUSH
57583: LD_INT 2
57585: PUSH
57586: LD_INT 30
57588: PUSH
57589: LD_INT 4
57591: PUSH
57592: EMPTY
57593: LIST
57594: LIST
57595: PUSH
57596: LD_INT 30
57598: PUSH
57599: LD_INT 5
57601: PUSH
57602: EMPTY
57603: LIST
57604: LIST
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: LIST
57610: PPUSH
57611: CALL_OW 72
57615: ST_TO_ADDR
57616: GO 57619
57618: POP
// if not tmp then
57619: LD_VAR 0 8
57623: NOT
57624: IFFALSE 57628
// exit ;
57626: GO 58130
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57628: LD_VAR 0 4
57632: PUSH
57633: LD_INT 1
57635: PUSH
57636: LD_INT 15
57638: PUSH
57639: EMPTY
57640: LIST
57641: LIST
57642: IN
57643: PUSH
57644: LD_EXP 121
57648: PUSH
57649: LD_VAR 0 1
57653: ARRAY
57654: AND
57655: IFFALSE 57811
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57657: LD_ADDR_VAR 0 9
57661: PUSH
57662: LD_EXP 121
57666: PUSH
57667: LD_VAR 0 1
57671: ARRAY
57672: PUSH
57673: LD_INT 1
57675: ARRAY
57676: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57677: LD_VAR 0 9
57681: PUSH
57682: LD_EXP 122
57686: PUSH
57687: LD_VAR 0 1
57691: ARRAY
57692: IN
57693: NOT
57694: IFFALSE 57809
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57696: LD_ADDR_EXP 122
57700: PUSH
57701: LD_EXP 122
57705: PPUSH
57706: LD_VAR 0 1
57710: PUSH
57711: LD_EXP 122
57715: PUSH
57716: LD_VAR 0 1
57720: ARRAY
57721: PUSH
57722: LD_INT 1
57724: PLUS
57725: PUSH
57726: EMPTY
57727: LIST
57728: LIST
57729: PPUSH
57730: LD_VAR 0 9
57734: PPUSH
57735: CALL 70050 0 3
57739: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57740: LD_ADDR_EXP 121
57744: PUSH
57745: LD_EXP 121
57749: PPUSH
57750: LD_VAR 0 1
57754: PPUSH
57755: LD_EXP 121
57759: PUSH
57760: LD_VAR 0 1
57764: ARRAY
57765: PUSH
57766: LD_VAR 0 9
57770: DIFF
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57777: LD_VAR 0 3
57781: PPUSH
57782: LD_EXP 122
57786: PUSH
57787: LD_VAR 0 1
57791: ARRAY
57792: PUSH
57793: LD_EXP 122
57797: PUSH
57798: LD_VAR 0 1
57802: ARRAY
57803: ARRAY
57804: PPUSH
57805: CALL_OW 120
// end ; exit ;
57809: GO 58130
// end ; if tmp > 1 then
57811: LD_VAR 0 8
57815: PUSH
57816: LD_INT 1
57818: GREATER
57819: IFFALSE 57923
// for i = 2 to tmp do
57821: LD_ADDR_VAR 0 6
57825: PUSH
57826: DOUBLE
57827: LD_INT 2
57829: DEC
57830: ST_TO_ADDR
57831: LD_VAR 0 8
57835: PUSH
57836: FOR_TO
57837: IFFALSE 57921
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57839: LD_VAR 0 8
57843: PUSH
57844: LD_VAR 0 6
57848: ARRAY
57849: PPUSH
57850: CALL_OW 461
57854: PUSH
57855: LD_INT 6
57857: EQUAL
57858: IFFALSE 57919
// begin x := tmp [ i ] ;
57860: LD_ADDR_VAR 0 9
57864: PUSH
57865: LD_VAR 0 8
57869: PUSH
57870: LD_VAR 0 6
57874: ARRAY
57875: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57876: LD_ADDR_VAR 0 8
57880: PUSH
57881: LD_VAR 0 8
57885: PPUSH
57886: LD_VAR 0 6
57890: PPUSH
57891: CALL_OW 3
57895: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57896: LD_ADDR_VAR 0 8
57900: PUSH
57901: LD_VAR 0 8
57905: PPUSH
57906: LD_INT 1
57908: PPUSH
57909: LD_VAR 0 9
57913: PPUSH
57914: CALL_OW 2
57918: ST_TO_ADDR
// end ;
57919: GO 57836
57921: POP
57922: POP
// for i in tmp do
57923: LD_ADDR_VAR 0 6
57927: PUSH
57928: LD_VAR 0 8
57932: PUSH
57933: FOR_IN
57934: IFFALSE 58003
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57936: LD_VAR 0 6
57940: PPUSH
57941: CALL_OW 313
57945: PUSH
57946: LD_INT 6
57948: LESS
57949: PUSH
57950: LD_VAR 0 6
57954: PPUSH
57955: CALL_OW 266
57959: PUSH
57960: LD_INT 31
57962: PUSH
57963: LD_INT 32
57965: PUSH
57966: EMPTY
57967: LIST
57968: LIST
57969: IN
57970: NOT
57971: AND
57972: PUSH
57973: LD_VAR 0 6
57977: PPUSH
57978: CALL_OW 313
57982: PUSH
57983: LD_INT 0
57985: EQUAL
57986: OR
57987: IFFALSE 58001
// begin j := i ;
57989: LD_ADDR_VAR 0 7
57993: PUSH
57994: LD_VAR 0 6
57998: ST_TO_ADDR
// break ;
57999: GO 58003
// end ; end ;
58001: GO 57933
58003: POP
58004: POP
// if j then
58005: LD_VAR 0 7
58009: IFFALSE 58027
// ComEnterUnit ( unit , j ) else
58011: LD_VAR 0 3
58015: PPUSH
58016: LD_VAR 0 7
58020: PPUSH
58021: CALL_OW 120
58025: GO 58130
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58027: LD_ADDR_VAR 0 10
58031: PUSH
58032: LD_VAR 0 2
58036: PPUSH
58037: LD_INT 2
58039: PUSH
58040: LD_INT 30
58042: PUSH
58043: LD_INT 0
58045: PUSH
58046: EMPTY
58047: LIST
58048: LIST
58049: PUSH
58050: LD_INT 30
58052: PUSH
58053: LD_INT 1
58055: PUSH
58056: EMPTY
58057: LIST
58058: LIST
58059: PUSH
58060: EMPTY
58061: LIST
58062: LIST
58063: LIST
58064: PPUSH
58065: CALL_OW 72
58069: ST_TO_ADDR
// if depot then
58070: LD_VAR 0 10
58074: IFFALSE 58130
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58076: LD_ADDR_VAR 0 10
58080: PUSH
58081: LD_VAR 0 10
58085: PPUSH
58086: LD_VAR 0 3
58090: PPUSH
58091: CALL_OW 74
58095: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58096: LD_VAR 0 3
58100: PPUSH
58101: LD_VAR 0 10
58105: PPUSH
58106: CALL_OW 296
58110: PUSH
58111: LD_INT 10
58113: GREATER
58114: IFFALSE 58130
// ComStandNearbyBuilding ( unit , depot ) ;
58116: LD_VAR 0 3
58120: PPUSH
58121: LD_VAR 0 10
58125: PPUSH
58126: CALL 66664 0 2
// end ; end ; end ;
58130: LD_VAR 0 5
58134: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58135: LD_INT 0
58137: PPUSH
58138: PPUSH
58139: PPUSH
58140: PPUSH
// if not mc_bases then
58141: LD_EXP 112
58145: NOT
58146: IFFALSE 58150
// exit ;
58148: GO 58389
// for i = 1 to mc_bases do
58150: LD_ADDR_VAR 0 2
58154: PUSH
58155: DOUBLE
58156: LD_INT 1
58158: DEC
58159: ST_TO_ADDR
58160: LD_EXP 112
58164: PUSH
58165: FOR_TO
58166: IFFALSE 58387
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58168: LD_ADDR_VAR 0 4
58172: PUSH
58173: LD_EXP 112
58177: PUSH
58178: LD_VAR 0 2
58182: ARRAY
58183: PPUSH
58184: LD_INT 21
58186: PUSH
58187: LD_INT 1
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: PPUSH
58194: CALL_OW 72
58198: PUSH
58199: LD_EXP 141
58203: PUSH
58204: LD_VAR 0 2
58208: ARRAY
58209: UNION
58210: ST_TO_ADDR
// if not tmp then
58211: LD_VAR 0 4
58215: NOT
58216: IFFALSE 58220
// continue ;
58218: GO 58165
// for j in tmp do
58220: LD_ADDR_VAR 0 3
58224: PUSH
58225: LD_VAR 0 4
58229: PUSH
58230: FOR_IN
58231: IFFALSE 58383
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58233: LD_VAR 0 3
58237: PPUSH
58238: CALL_OW 110
58242: NOT
58243: PUSH
58244: LD_VAR 0 3
58248: PPUSH
58249: CALL_OW 314
58253: NOT
58254: AND
58255: PUSH
58256: LD_VAR 0 3
58260: PPUSH
58261: CALL_OW 311
58265: NOT
58266: AND
58267: PUSH
58268: LD_VAR 0 3
58272: PPUSH
58273: CALL_OW 310
58277: NOT
58278: AND
58279: PUSH
58280: LD_VAR 0 3
58284: PUSH
58285: LD_EXP 115
58289: PUSH
58290: LD_VAR 0 2
58294: ARRAY
58295: PUSH
58296: LD_INT 1
58298: ARRAY
58299: IN
58300: NOT
58301: AND
58302: PUSH
58303: LD_VAR 0 3
58307: PUSH
58308: LD_EXP 115
58312: PUSH
58313: LD_VAR 0 2
58317: ARRAY
58318: PUSH
58319: LD_INT 2
58321: ARRAY
58322: IN
58323: NOT
58324: AND
58325: PUSH
58326: LD_VAR 0 3
58330: PUSH
58331: LD_EXP 124
58335: PUSH
58336: LD_VAR 0 2
58340: ARRAY
58341: IN
58342: NOT
58343: AND
58344: IFFALSE 58381
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58346: LD_VAR 0 2
58350: PPUSH
58351: LD_EXP 112
58355: PUSH
58356: LD_VAR 0 2
58360: ARRAY
58361: PPUSH
58362: LD_VAR 0 3
58366: PPUSH
58367: LD_VAR 0 3
58371: PPUSH
58372: CALL_OW 257
58376: PPUSH
58377: CALL 57153 0 4
// end ;
58381: GO 58230
58383: POP
58384: POP
// end ;
58385: GO 58165
58387: POP
58388: POP
// end ;
58389: LD_VAR 0 1
58393: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58394: LD_INT 0
58396: PPUSH
58397: PPUSH
58398: PPUSH
58399: PPUSH
58400: PPUSH
58401: PPUSH
// if not mc_bases [ base ] then
58402: LD_EXP 112
58406: PUSH
58407: LD_VAR 0 1
58411: ARRAY
58412: NOT
58413: IFFALSE 58417
// exit ;
58415: GO 58599
// tmp := [ ] ;
58417: LD_ADDR_VAR 0 6
58421: PUSH
58422: EMPTY
58423: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58424: LD_ADDR_VAR 0 7
58428: PUSH
58429: LD_VAR 0 3
58433: PPUSH
58434: LD_INT 0
58436: PPUSH
58437: CALL_OW 517
58441: ST_TO_ADDR
// if not list then
58442: LD_VAR 0 7
58446: NOT
58447: IFFALSE 58451
// exit ;
58449: GO 58599
// for i = 1 to amount do
58451: LD_ADDR_VAR 0 5
58455: PUSH
58456: DOUBLE
58457: LD_INT 1
58459: DEC
58460: ST_TO_ADDR
58461: LD_VAR 0 2
58465: PUSH
58466: FOR_TO
58467: IFFALSE 58547
// begin x := rand ( 1 , list [ 1 ] ) ;
58469: LD_ADDR_VAR 0 8
58473: PUSH
58474: LD_INT 1
58476: PPUSH
58477: LD_VAR 0 7
58481: PUSH
58482: LD_INT 1
58484: ARRAY
58485: PPUSH
58486: CALL_OW 12
58490: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58491: LD_ADDR_VAR 0 6
58495: PUSH
58496: LD_VAR 0 6
58500: PPUSH
58501: LD_VAR 0 5
58505: PPUSH
58506: LD_VAR 0 7
58510: PUSH
58511: LD_INT 1
58513: ARRAY
58514: PUSH
58515: LD_VAR 0 8
58519: ARRAY
58520: PUSH
58521: LD_VAR 0 7
58525: PUSH
58526: LD_INT 2
58528: ARRAY
58529: PUSH
58530: LD_VAR 0 8
58534: ARRAY
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// end ;
58545: GO 58466
58547: POP
58548: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58549: LD_ADDR_EXP 125
58553: PUSH
58554: LD_EXP 125
58558: PPUSH
58559: LD_VAR 0 1
58563: PPUSH
58564: LD_VAR 0 6
58568: PPUSH
58569: CALL_OW 1
58573: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58574: LD_ADDR_EXP 127
58578: PUSH
58579: LD_EXP 127
58583: PPUSH
58584: LD_VAR 0 1
58588: PPUSH
58589: LD_VAR 0 3
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
// end ;
58599: LD_VAR 0 4
58603: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58604: LD_INT 0
58606: PPUSH
// if not mc_bases [ base ] then
58607: LD_EXP 112
58611: PUSH
58612: LD_VAR 0 1
58616: ARRAY
58617: NOT
58618: IFFALSE 58622
// exit ;
58620: GO 58647
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58622: LD_ADDR_EXP 117
58626: PUSH
58627: LD_EXP 117
58631: PPUSH
58632: LD_VAR 0 1
58636: PPUSH
58637: LD_VAR 0 2
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// end ;
58647: LD_VAR 0 3
58651: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58652: LD_INT 0
58654: PPUSH
// if not mc_bases [ base ] then
58655: LD_EXP 112
58659: PUSH
58660: LD_VAR 0 1
58664: ARRAY
58665: NOT
58666: IFFALSE 58670
// exit ;
58668: GO 58707
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58670: LD_ADDR_EXP 117
58674: PUSH
58675: LD_EXP 117
58679: PPUSH
58680: LD_VAR 0 1
58684: PPUSH
58685: LD_EXP 117
58689: PUSH
58690: LD_VAR 0 1
58694: ARRAY
58695: PUSH
58696: LD_VAR 0 2
58700: UNION
58701: PPUSH
58702: CALL_OW 1
58706: ST_TO_ADDR
// end ;
58707: LD_VAR 0 3
58711: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58712: LD_INT 0
58714: PPUSH
// if not mc_bases [ base ] then
58715: LD_EXP 112
58719: PUSH
58720: LD_VAR 0 1
58724: ARRAY
58725: NOT
58726: IFFALSE 58730
// exit ;
58728: GO 58755
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58730: LD_ADDR_EXP 133
58734: PUSH
58735: LD_EXP 133
58739: PPUSH
58740: LD_VAR 0 1
58744: PPUSH
58745: LD_VAR 0 2
58749: PPUSH
58750: CALL_OW 1
58754: ST_TO_ADDR
// end ;
58755: LD_VAR 0 3
58759: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58760: LD_INT 0
58762: PPUSH
// if not mc_bases [ base ] then
58763: LD_EXP 112
58767: PUSH
58768: LD_VAR 0 1
58772: ARRAY
58773: NOT
58774: IFFALSE 58778
// exit ;
58776: GO 58815
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58778: LD_ADDR_EXP 133
58782: PUSH
58783: LD_EXP 133
58787: PPUSH
58788: LD_VAR 0 1
58792: PPUSH
58793: LD_EXP 133
58797: PUSH
58798: LD_VAR 0 1
58802: ARRAY
58803: PUSH
58804: LD_VAR 0 2
58808: ADD
58809: PPUSH
58810: CALL_OW 1
58814: ST_TO_ADDR
// end ;
58815: LD_VAR 0 3
58819: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58820: LD_INT 0
58822: PPUSH
// if not mc_bases [ base ] then
58823: LD_EXP 112
58827: PUSH
58828: LD_VAR 0 1
58832: ARRAY
58833: NOT
58834: IFFALSE 58838
// exit ;
58836: GO 58892
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58838: LD_ADDR_EXP 134
58842: PUSH
58843: LD_EXP 134
58847: PPUSH
58848: LD_VAR 0 1
58852: PPUSH
58853: LD_VAR 0 2
58857: PPUSH
58858: CALL_OW 1
58862: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58863: LD_ADDR_EXP 123
58867: PUSH
58868: LD_EXP 123
58872: PPUSH
58873: LD_VAR 0 1
58877: PPUSH
58878: LD_VAR 0 2
58882: PUSH
58883: LD_INT 0
58885: PLUS
58886: PPUSH
58887: CALL_OW 1
58891: ST_TO_ADDR
// end ;
58892: LD_VAR 0 3
58896: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58897: LD_INT 0
58899: PPUSH
// if not mc_bases [ base ] then
58900: LD_EXP 112
58904: PUSH
58905: LD_VAR 0 1
58909: ARRAY
58910: NOT
58911: IFFALSE 58915
// exit ;
58913: GO 58940
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58915: LD_ADDR_EXP 123
58919: PUSH
58920: LD_EXP 123
58924: PPUSH
58925: LD_VAR 0 1
58929: PPUSH
58930: LD_VAR 0 2
58934: PPUSH
58935: CALL_OW 1
58939: ST_TO_ADDR
// end ;
58940: LD_VAR 0 3
58944: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58945: LD_INT 0
58947: PPUSH
58948: PPUSH
58949: PPUSH
58950: PPUSH
// if not mc_bases [ base ] then
58951: LD_EXP 112
58955: PUSH
58956: LD_VAR 0 1
58960: ARRAY
58961: NOT
58962: IFFALSE 58966
// exit ;
58964: GO 59031
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58966: LD_ADDR_EXP 132
58970: PUSH
58971: LD_EXP 132
58975: PPUSH
58976: LD_VAR 0 1
58980: PUSH
58981: LD_EXP 132
58985: PUSH
58986: LD_VAR 0 1
58990: ARRAY
58991: PUSH
58992: LD_INT 1
58994: PLUS
58995: PUSH
58996: EMPTY
58997: LIST
58998: LIST
58999: PPUSH
59000: LD_VAR 0 1
59004: PUSH
59005: LD_VAR 0 2
59009: PUSH
59010: LD_VAR 0 3
59014: PUSH
59015: LD_VAR 0 4
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: LIST
59024: LIST
59025: PPUSH
59026: CALL 70050 0 3
59030: ST_TO_ADDR
// end ;
59031: LD_VAR 0 5
59035: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59036: LD_INT 0
59038: PPUSH
// if not mc_bases [ base ] then
59039: LD_EXP 112
59043: PUSH
59044: LD_VAR 0 1
59048: ARRAY
59049: NOT
59050: IFFALSE 59054
// exit ;
59052: GO 59079
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59054: LD_ADDR_EXP 149
59058: PUSH
59059: LD_EXP 149
59063: PPUSH
59064: LD_VAR 0 1
59068: PPUSH
59069: LD_VAR 0 2
59073: PPUSH
59074: CALL_OW 1
59078: ST_TO_ADDR
// end ;
59079: LD_VAR 0 3
59083: RET
// export function MC_GetMinesField ( base ) ; begin
59084: LD_INT 0
59086: PPUSH
// result := mc_mines [ base ] ;
59087: LD_ADDR_VAR 0 2
59091: PUSH
59092: LD_EXP 125
59096: PUSH
59097: LD_VAR 0 1
59101: ARRAY
59102: ST_TO_ADDR
// end ;
59103: LD_VAR 0 2
59107: RET
// export function MC_GetProduceList ( base ) ; begin
59108: LD_INT 0
59110: PPUSH
// result := mc_produce [ base ] ;
59111: LD_ADDR_VAR 0 2
59115: PUSH
59116: LD_EXP 133
59120: PUSH
59121: LD_VAR 0 1
59125: ARRAY
59126: ST_TO_ADDR
// end ;
59127: LD_VAR 0 2
59131: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59132: LD_INT 0
59134: PPUSH
59135: PPUSH
// if not mc_bases then
59136: LD_EXP 112
59140: NOT
59141: IFFALSE 59145
// exit ;
59143: GO 59210
// if mc_bases [ base ] then
59145: LD_EXP 112
59149: PUSH
59150: LD_VAR 0 1
59154: ARRAY
59155: IFFALSE 59210
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59157: LD_ADDR_VAR 0 3
59161: PUSH
59162: LD_EXP 112
59166: PUSH
59167: LD_VAR 0 1
59171: ARRAY
59172: PPUSH
59173: LD_INT 30
59175: PUSH
59176: LD_VAR 0 2
59180: PUSH
59181: EMPTY
59182: LIST
59183: LIST
59184: PPUSH
59185: CALL_OW 72
59189: ST_TO_ADDR
// if result then
59190: LD_VAR 0 3
59194: IFFALSE 59210
// result := result [ 1 ] ;
59196: LD_ADDR_VAR 0 3
59200: PUSH
59201: LD_VAR 0 3
59205: PUSH
59206: LD_INT 1
59208: ARRAY
59209: ST_TO_ADDR
// end ; end ;
59210: LD_VAR 0 3
59214: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59215: LD_INT 0
59217: PPUSH
59218: PPUSH
// if not mc_bases then
59219: LD_EXP 112
59223: NOT
59224: IFFALSE 59228
// exit ;
59226: GO 59273
// if mc_bases [ base ] then
59228: LD_EXP 112
59232: PUSH
59233: LD_VAR 0 1
59237: ARRAY
59238: IFFALSE 59273
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59240: LD_ADDR_VAR 0 3
59244: PUSH
59245: LD_EXP 112
59249: PUSH
59250: LD_VAR 0 1
59254: ARRAY
59255: PPUSH
59256: LD_INT 30
59258: PUSH
59259: LD_VAR 0 2
59263: PUSH
59264: EMPTY
59265: LIST
59266: LIST
59267: PPUSH
59268: CALL_OW 72
59272: ST_TO_ADDR
// end ;
59273: LD_VAR 0 3
59277: RET
// export function MC_SetTame ( base , area ) ; begin
59278: LD_INT 0
59280: PPUSH
// if not mc_bases or not base then
59281: LD_EXP 112
59285: NOT
59286: PUSH
59287: LD_VAR 0 1
59291: NOT
59292: OR
59293: IFFALSE 59297
// exit ;
59295: GO 59322
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59297: LD_ADDR_EXP 140
59301: PUSH
59302: LD_EXP 140
59306: PPUSH
59307: LD_VAR 0 1
59311: PPUSH
59312: LD_VAR 0 2
59316: PPUSH
59317: CALL_OW 1
59321: ST_TO_ADDR
// end ;
59322: LD_VAR 0 3
59326: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59327: LD_INT 0
59329: PPUSH
59330: PPUSH
// if not mc_bases or not base then
59331: LD_EXP 112
59335: NOT
59336: PUSH
59337: LD_VAR 0 1
59341: NOT
59342: OR
59343: IFFALSE 59347
// exit ;
59345: GO 59449
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59347: LD_ADDR_VAR 0 4
59351: PUSH
59352: LD_EXP 112
59356: PUSH
59357: LD_VAR 0 1
59361: ARRAY
59362: PPUSH
59363: LD_INT 30
59365: PUSH
59366: LD_VAR 0 2
59370: PUSH
59371: EMPTY
59372: LIST
59373: LIST
59374: PPUSH
59375: CALL_OW 72
59379: ST_TO_ADDR
// if not tmp then
59380: LD_VAR 0 4
59384: NOT
59385: IFFALSE 59389
// exit ;
59387: GO 59449
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59389: LD_ADDR_EXP 144
59393: PUSH
59394: LD_EXP 144
59398: PPUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: LD_EXP 144
59408: PUSH
59409: LD_VAR 0 1
59413: ARRAY
59414: PPUSH
59415: LD_EXP 144
59419: PUSH
59420: LD_VAR 0 1
59424: ARRAY
59425: PUSH
59426: LD_INT 1
59428: PLUS
59429: PPUSH
59430: LD_VAR 0 4
59434: PUSH
59435: LD_INT 1
59437: ARRAY
59438: PPUSH
59439: CALL_OW 2
59443: PPUSH
59444: CALL_OW 1
59448: ST_TO_ADDR
// end ;
59449: LD_VAR 0 3
59453: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59454: LD_INT 0
59456: PPUSH
59457: PPUSH
// if not mc_bases or not base or not kinds then
59458: LD_EXP 112
59462: NOT
59463: PUSH
59464: LD_VAR 0 1
59468: NOT
59469: OR
59470: PUSH
59471: LD_VAR 0 2
59475: NOT
59476: OR
59477: IFFALSE 59481
// exit ;
59479: GO 59542
// for i in kinds do
59481: LD_ADDR_VAR 0 4
59485: PUSH
59486: LD_VAR 0 2
59490: PUSH
59491: FOR_IN
59492: IFFALSE 59540
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59494: LD_ADDR_EXP 146
59498: PUSH
59499: LD_EXP 146
59503: PPUSH
59504: LD_VAR 0 1
59508: PUSH
59509: LD_EXP 146
59513: PUSH
59514: LD_VAR 0 1
59518: ARRAY
59519: PUSH
59520: LD_INT 1
59522: PLUS
59523: PUSH
59524: EMPTY
59525: LIST
59526: LIST
59527: PPUSH
59528: LD_VAR 0 4
59532: PPUSH
59533: CALL 70050 0 3
59537: ST_TO_ADDR
59538: GO 59491
59540: POP
59541: POP
// end ;
59542: LD_VAR 0 3
59546: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59547: LD_INT 0
59549: PPUSH
// if not mc_bases or not base or not areas then
59550: LD_EXP 112
59554: NOT
59555: PUSH
59556: LD_VAR 0 1
59560: NOT
59561: OR
59562: PUSH
59563: LD_VAR 0 2
59567: NOT
59568: OR
59569: IFFALSE 59573
// exit ;
59571: GO 59598
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59573: LD_ADDR_EXP 130
59577: PUSH
59578: LD_EXP 130
59582: PPUSH
59583: LD_VAR 0 1
59587: PPUSH
59588: LD_VAR 0 2
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// end ;
59598: LD_VAR 0 3
59602: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59603: LD_INT 0
59605: PPUSH
// if not mc_bases or not base or not teleports_exit then
59606: LD_EXP 112
59610: NOT
59611: PUSH
59612: LD_VAR 0 1
59616: NOT
59617: OR
59618: PUSH
59619: LD_VAR 0 2
59623: NOT
59624: OR
59625: IFFALSE 59629
// exit ;
59627: GO 59654
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59629: LD_ADDR_EXP 147
59633: PUSH
59634: LD_EXP 147
59638: PPUSH
59639: LD_VAR 0 1
59643: PPUSH
59644: LD_VAR 0 2
59648: PPUSH
59649: CALL_OW 1
59653: ST_TO_ADDR
// end ;
59654: LD_VAR 0 3
59658: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59659: LD_INT 0
59661: PPUSH
59662: PPUSH
59663: PPUSH
// if not mc_bases or not base or not ext_list then
59664: LD_EXP 112
59668: NOT
59669: PUSH
59670: LD_VAR 0 1
59674: NOT
59675: OR
59676: PUSH
59677: LD_VAR 0 5
59681: NOT
59682: OR
59683: IFFALSE 59687
// exit ;
59685: GO 59860
// tmp := GetFacExtXYD ( x , y , d ) ;
59687: LD_ADDR_VAR 0 8
59691: PUSH
59692: LD_VAR 0 2
59696: PPUSH
59697: LD_VAR 0 3
59701: PPUSH
59702: LD_VAR 0 4
59706: PPUSH
59707: CALL 98729 0 3
59711: ST_TO_ADDR
// if not tmp then
59712: LD_VAR 0 8
59716: NOT
59717: IFFALSE 59721
// exit ;
59719: GO 59860
// for i in tmp do
59721: LD_ADDR_VAR 0 7
59725: PUSH
59726: LD_VAR 0 8
59730: PUSH
59731: FOR_IN
59732: IFFALSE 59858
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59734: LD_ADDR_EXP 117
59738: PUSH
59739: LD_EXP 117
59743: PPUSH
59744: LD_VAR 0 1
59748: PPUSH
59749: LD_EXP 117
59753: PUSH
59754: LD_VAR 0 1
59758: ARRAY
59759: PPUSH
59760: LD_EXP 117
59764: PUSH
59765: LD_VAR 0 1
59769: ARRAY
59770: PUSH
59771: LD_INT 1
59773: PLUS
59774: PPUSH
59775: LD_VAR 0 5
59779: PUSH
59780: LD_INT 1
59782: ARRAY
59783: PUSH
59784: LD_VAR 0 7
59788: PUSH
59789: LD_INT 1
59791: ARRAY
59792: PUSH
59793: LD_VAR 0 7
59797: PUSH
59798: LD_INT 2
59800: ARRAY
59801: PUSH
59802: LD_VAR 0 7
59806: PUSH
59807: LD_INT 3
59809: ARRAY
59810: PUSH
59811: EMPTY
59812: LIST
59813: LIST
59814: LIST
59815: LIST
59816: PPUSH
59817: CALL_OW 2
59821: PPUSH
59822: CALL_OW 1
59826: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59827: LD_ADDR_VAR 0 5
59831: PUSH
59832: LD_VAR 0 5
59836: PPUSH
59837: LD_INT 1
59839: PPUSH
59840: CALL_OW 3
59844: ST_TO_ADDR
// if not ext_list then
59845: LD_VAR 0 5
59849: NOT
59850: IFFALSE 59856
// exit ;
59852: POP
59853: POP
59854: GO 59860
// end ;
59856: GO 59731
59858: POP
59859: POP
// end ;
59860: LD_VAR 0 6
59864: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59865: LD_INT 0
59867: PPUSH
// if not mc_bases or not base or not weapon_list then
59868: LD_EXP 112
59872: NOT
59873: PUSH
59874: LD_VAR 0 1
59878: NOT
59879: OR
59880: PUSH
59881: LD_VAR 0 2
59885: NOT
59886: OR
59887: IFFALSE 59891
// exit ;
59889: GO 59916
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59891: LD_ADDR_EXP 151
59895: PUSH
59896: LD_EXP 151
59900: PPUSH
59901: LD_VAR 0 1
59905: PPUSH
59906: LD_VAR 0 2
59910: PPUSH
59911: CALL_OW 1
59915: ST_TO_ADDR
// end ;
59916: LD_VAR 0 3
59920: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59921: LD_INT 0
59923: PPUSH
// if not mc_bases or not base or not tech_list then
59924: LD_EXP 112
59928: NOT
59929: PUSH
59930: LD_VAR 0 1
59934: NOT
59935: OR
59936: PUSH
59937: LD_VAR 0 2
59941: NOT
59942: OR
59943: IFFALSE 59947
// exit ;
59945: GO 59972
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59947: LD_ADDR_EXP 139
59951: PUSH
59952: LD_EXP 139
59956: PPUSH
59957: LD_VAR 0 1
59961: PPUSH
59962: LD_VAR 0 2
59966: PPUSH
59967: CALL_OW 1
59971: ST_TO_ADDR
// end ;
59972: LD_VAR 0 3
59976: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59977: LD_INT 0
59979: PPUSH
// if not mc_bases or not parking_area or not base then
59980: LD_EXP 112
59984: NOT
59985: PUSH
59986: LD_VAR 0 2
59990: NOT
59991: OR
59992: PUSH
59993: LD_VAR 0 1
59997: NOT
59998: OR
59999: IFFALSE 60003
// exit ;
60001: GO 60028
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60003: LD_ADDR_EXP 136
60007: PUSH
60008: LD_EXP 136
60012: PPUSH
60013: LD_VAR 0 1
60017: PPUSH
60018: LD_VAR 0 2
60022: PPUSH
60023: CALL_OW 1
60027: ST_TO_ADDR
// end ;
60028: LD_VAR 0 3
60032: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60033: LD_INT 0
60035: PPUSH
// if not mc_bases or not base or not scan_area then
60036: LD_EXP 112
60040: NOT
60041: PUSH
60042: LD_VAR 0 1
60046: NOT
60047: OR
60048: PUSH
60049: LD_VAR 0 2
60053: NOT
60054: OR
60055: IFFALSE 60059
// exit ;
60057: GO 60084
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60059: LD_ADDR_EXP 137
60063: PUSH
60064: LD_EXP 137
60068: PPUSH
60069: LD_VAR 0 1
60073: PPUSH
60074: LD_VAR 0 2
60078: PPUSH
60079: CALL_OW 1
60083: ST_TO_ADDR
// end ;
60084: LD_VAR 0 3
60088: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60089: LD_INT 0
60091: PPUSH
60092: PPUSH
// if not mc_bases or not base then
60093: LD_EXP 112
60097: NOT
60098: PUSH
60099: LD_VAR 0 1
60103: NOT
60104: OR
60105: IFFALSE 60109
// exit ;
60107: GO 60173
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60109: LD_ADDR_VAR 0 3
60113: PUSH
60114: LD_INT 1
60116: PUSH
60117: LD_INT 2
60119: PUSH
60120: LD_INT 3
60122: PUSH
60123: LD_INT 4
60125: PUSH
60126: LD_INT 11
60128: PUSH
60129: EMPTY
60130: LIST
60131: LIST
60132: LIST
60133: LIST
60134: LIST
60135: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60136: LD_ADDR_EXP 139
60140: PUSH
60141: LD_EXP 139
60145: PPUSH
60146: LD_VAR 0 1
60150: PPUSH
60151: LD_EXP 139
60155: PUSH
60156: LD_VAR 0 1
60160: ARRAY
60161: PUSH
60162: LD_VAR 0 3
60166: DIFF
60167: PPUSH
60168: CALL_OW 1
60172: ST_TO_ADDR
// end ;
60173: LD_VAR 0 2
60177: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60178: LD_INT 0
60180: PPUSH
// result := mc_vehicles [ base ] ;
60181: LD_ADDR_VAR 0 3
60185: PUSH
60186: LD_EXP 131
60190: PUSH
60191: LD_VAR 0 1
60195: ARRAY
60196: ST_TO_ADDR
// if onlyCombat then
60197: LD_VAR 0 2
60201: IFFALSE 60366
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60203: LD_ADDR_VAR 0 3
60207: PUSH
60208: LD_VAR 0 3
60212: PUSH
60213: LD_VAR 0 3
60217: PPUSH
60218: LD_INT 2
60220: PUSH
60221: LD_INT 34
60223: PUSH
60224: LD_INT 12
60226: PUSH
60227: EMPTY
60228: LIST
60229: LIST
60230: PUSH
60231: LD_INT 34
60233: PUSH
60234: LD_INT 51
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PUSH
60241: LD_INT 34
60243: PUSH
60244: LD_EXP 96
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: PUSH
60253: LD_INT 34
60255: PUSH
60256: LD_INT 32
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 34
60265: PUSH
60266: LD_INT 13
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: PUSH
60273: LD_INT 34
60275: PUSH
60276: LD_INT 52
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: PUSH
60283: LD_INT 34
60285: PUSH
60286: LD_INT 14
60288: PUSH
60289: EMPTY
60290: LIST
60291: LIST
60292: PUSH
60293: LD_INT 34
60295: PUSH
60296: LD_INT 53
60298: PUSH
60299: EMPTY
60300: LIST
60301: LIST
60302: PUSH
60303: LD_INT 34
60305: PUSH
60306: LD_EXP 95
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PUSH
60315: LD_INT 34
60317: PUSH
60318: LD_INT 31
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: PUSH
60325: LD_INT 34
60327: PUSH
60328: LD_INT 48
60330: PUSH
60331: EMPTY
60332: LIST
60333: LIST
60334: PUSH
60335: LD_INT 34
60337: PUSH
60338: LD_INT 8
60340: PUSH
60341: EMPTY
60342: LIST
60343: LIST
60344: PUSH
60345: EMPTY
60346: LIST
60347: LIST
60348: LIST
60349: LIST
60350: LIST
60351: LIST
60352: LIST
60353: LIST
60354: LIST
60355: LIST
60356: LIST
60357: LIST
60358: LIST
60359: PPUSH
60360: CALL_OW 72
60364: DIFF
60365: ST_TO_ADDR
// end ; end_of_file
60366: LD_VAR 0 3
60370: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60371: LD_INT 0
60373: PPUSH
60374: PPUSH
60375: PPUSH
// if not mc_bases or not skirmish then
60376: LD_EXP 112
60380: NOT
60381: PUSH
60382: LD_EXP 110
60386: NOT
60387: OR
60388: IFFALSE 60392
// exit ;
60390: GO 60557
// for i = 1 to mc_bases do
60392: LD_ADDR_VAR 0 4
60396: PUSH
60397: DOUBLE
60398: LD_INT 1
60400: DEC
60401: ST_TO_ADDR
60402: LD_EXP 112
60406: PUSH
60407: FOR_TO
60408: IFFALSE 60555
// begin if sci in mc_bases [ i ] then
60410: LD_VAR 0 2
60414: PUSH
60415: LD_EXP 112
60419: PUSH
60420: LD_VAR 0 4
60424: ARRAY
60425: IN
60426: IFFALSE 60553
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60428: LD_ADDR_EXP 141
60432: PUSH
60433: LD_EXP 141
60437: PPUSH
60438: LD_VAR 0 4
60442: PUSH
60443: LD_EXP 141
60447: PUSH
60448: LD_VAR 0 4
60452: ARRAY
60453: PUSH
60454: LD_INT 1
60456: PLUS
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PPUSH
60462: LD_VAR 0 1
60466: PPUSH
60467: CALL 70050 0 3
60471: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60472: LD_ADDR_VAR 0 5
60476: PUSH
60477: LD_EXP 112
60481: PUSH
60482: LD_VAR 0 4
60486: ARRAY
60487: PPUSH
60488: LD_INT 2
60490: PUSH
60491: LD_INT 30
60493: PUSH
60494: LD_INT 0
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PUSH
60501: LD_INT 30
60503: PUSH
60504: LD_INT 1
60506: PUSH
60507: EMPTY
60508: LIST
60509: LIST
60510: PUSH
60511: EMPTY
60512: LIST
60513: LIST
60514: LIST
60515: PPUSH
60516: CALL_OW 72
60520: PPUSH
60521: LD_VAR 0 1
60525: PPUSH
60526: CALL_OW 74
60530: ST_TO_ADDR
// if tmp then
60531: LD_VAR 0 5
60535: IFFALSE 60551
// ComStandNearbyBuilding ( ape , tmp ) ;
60537: LD_VAR 0 1
60541: PPUSH
60542: LD_VAR 0 5
60546: PPUSH
60547: CALL 66664 0 2
// break ;
60551: GO 60555
// end ; end ;
60553: GO 60407
60555: POP
60556: POP
// end ;
60557: LD_VAR 0 3
60561: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60562: LD_INT 0
60564: PPUSH
60565: PPUSH
60566: PPUSH
// if not mc_bases or not skirmish then
60567: LD_EXP 112
60571: NOT
60572: PUSH
60573: LD_EXP 110
60577: NOT
60578: OR
60579: IFFALSE 60583
// exit ;
60581: GO 60672
// for i = 1 to mc_bases do
60583: LD_ADDR_VAR 0 4
60587: PUSH
60588: DOUBLE
60589: LD_INT 1
60591: DEC
60592: ST_TO_ADDR
60593: LD_EXP 112
60597: PUSH
60598: FOR_TO
60599: IFFALSE 60670
// begin if building in mc_busy_turret_list [ i ] then
60601: LD_VAR 0 1
60605: PUSH
60606: LD_EXP 122
60610: PUSH
60611: LD_VAR 0 4
60615: ARRAY
60616: IN
60617: IFFALSE 60668
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60619: LD_ADDR_VAR 0 5
60623: PUSH
60624: LD_EXP 122
60628: PUSH
60629: LD_VAR 0 4
60633: ARRAY
60634: PUSH
60635: LD_VAR 0 1
60639: DIFF
60640: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60641: LD_ADDR_EXP 122
60645: PUSH
60646: LD_EXP 122
60650: PPUSH
60651: LD_VAR 0 4
60655: PPUSH
60656: LD_VAR 0 5
60660: PPUSH
60661: CALL_OW 1
60665: ST_TO_ADDR
// break ;
60666: GO 60670
// end ; end ;
60668: GO 60598
60670: POP
60671: POP
// end ;
60672: LD_VAR 0 3
60676: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60677: LD_INT 0
60679: PPUSH
60680: PPUSH
60681: PPUSH
// if not mc_bases or not skirmish then
60682: LD_EXP 112
60686: NOT
60687: PUSH
60688: LD_EXP 110
60692: NOT
60693: OR
60694: IFFALSE 60698
// exit ;
60696: GO 60897
// for i = 1 to mc_bases do
60698: LD_ADDR_VAR 0 5
60702: PUSH
60703: DOUBLE
60704: LD_INT 1
60706: DEC
60707: ST_TO_ADDR
60708: LD_EXP 112
60712: PUSH
60713: FOR_TO
60714: IFFALSE 60895
// if building in mc_bases [ i ] then
60716: LD_VAR 0 1
60720: PUSH
60721: LD_EXP 112
60725: PUSH
60726: LD_VAR 0 5
60730: ARRAY
60731: IN
60732: IFFALSE 60893
// begin tmp := mc_bases [ i ] diff building ;
60734: LD_ADDR_VAR 0 6
60738: PUSH
60739: LD_EXP 112
60743: PUSH
60744: LD_VAR 0 5
60748: ARRAY
60749: PUSH
60750: LD_VAR 0 1
60754: DIFF
60755: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60756: LD_ADDR_EXP 112
60760: PUSH
60761: LD_EXP 112
60765: PPUSH
60766: LD_VAR 0 5
60770: PPUSH
60771: LD_VAR 0 6
60775: PPUSH
60776: CALL_OW 1
60780: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60781: LD_VAR 0 1
60785: PUSH
60786: LD_EXP 120
60790: PUSH
60791: LD_VAR 0 5
60795: ARRAY
60796: IN
60797: IFFALSE 60836
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60799: LD_ADDR_EXP 120
60803: PUSH
60804: LD_EXP 120
60808: PPUSH
60809: LD_VAR 0 5
60813: PPUSH
60814: LD_EXP 120
60818: PUSH
60819: LD_VAR 0 5
60823: ARRAY
60824: PUSH
60825: LD_VAR 0 1
60829: DIFF
60830: PPUSH
60831: CALL_OW 1
60835: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60836: LD_VAR 0 1
60840: PUSH
60841: LD_EXP 121
60845: PUSH
60846: LD_VAR 0 5
60850: ARRAY
60851: IN
60852: IFFALSE 60891
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60854: LD_ADDR_EXP 121
60858: PUSH
60859: LD_EXP 121
60863: PPUSH
60864: LD_VAR 0 5
60868: PPUSH
60869: LD_EXP 121
60873: PUSH
60874: LD_VAR 0 5
60878: ARRAY
60879: PUSH
60880: LD_VAR 0 1
60884: DIFF
60885: PPUSH
60886: CALL_OW 1
60890: ST_TO_ADDR
// break ;
60891: GO 60895
// end ;
60893: GO 60713
60895: POP
60896: POP
// end ;
60897: LD_VAR 0 4
60901: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60902: LD_INT 0
60904: PPUSH
60905: PPUSH
60906: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60907: LD_EXP 112
60911: NOT
60912: PUSH
60913: LD_EXP 110
60917: NOT
60918: OR
60919: PUSH
60920: LD_VAR 0 3
60924: PUSH
60925: LD_EXP 138
60929: IN
60930: NOT
60931: OR
60932: IFFALSE 60936
// exit ;
60934: GO 61059
// for i = 1 to mc_vehicles do
60936: LD_ADDR_VAR 0 6
60940: PUSH
60941: DOUBLE
60942: LD_INT 1
60944: DEC
60945: ST_TO_ADDR
60946: LD_EXP 131
60950: PUSH
60951: FOR_TO
60952: IFFALSE 61057
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60954: LD_VAR 0 2
60958: PUSH
60959: LD_EXP 131
60963: PUSH
60964: LD_VAR 0 6
60968: ARRAY
60969: IN
60970: PUSH
60971: LD_VAR 0 1
60975: PUSH
60976: LD_EXP 131
60980: PUSH
60981: LD_VAR 0 6
60985: ARRAY
60986: IN
60987: OR
60988: IFFALSE 61055
// begin tmp := mc_vehicles [ i ] diff old ;
60990: LD_ADDR_VAR 0 7
60994: PUSH
60995: LD_EXP 131
60999: PUSH
61000: LD_VAR 0 6
61004: ARRAY
61005: PUSH
61006: LD_VAR 0 2
61010: DIFF
61011: ST_TO_ADDR
// tmp := tmp diff new ;
61012: LD_ADDR_VAR 0 7
61016: PUSH
61017: LD_VAR 0 7
61021: PUSH
61022: LD_VAR 0 1
61026: DIFF
61027: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61028: LD_ADDR_EXP 131
61032: PUSH
61033: LD_EXP 131
61037: PPUSH
61038: LD_VAR 0 6
61042: PPUSH
61043: LD_VAR 0 7
61047: PPUSH
61048: CALL_OW 1
61052: ST_TO_ADDR
// break ;
61053: GO 61057
// end ;
61055: GO 60951
61057: POP
61058: POP
// end ;
61059: LD_VAR 0 5
61063: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61064: LD_INT 0
61066: PPUSH
61067: PPUSH
61068: PPUSH
61069: PPUSH
// if not mc_bases or not skirmish then
61070: LD_EXP 112
61074: NOT
61075: PUSH
61076: LD_EXP 110
61080: NOT
61081: OR
61082: IFFALSE 61086
// exit ;
61084: GO 61463
// side := GetSide ( vehicle ) ;
61086: LD_ADDR_VAR 0 5
61090: PUSH
61091: LD_VAR 0 1
61095: PPUSH
61096: CALL_OW 255
61100: ST_TO_ADDR
// for i = 1 to mc_bases do
61101: LD_ADDR_VAR 0 4
61105: PUSH
61106: DOUBLE
61107: LD_INT 1
61109: DEC
61110: ST_TO_ADDR
61111: LD_EXP 112
61115: PUSH
61116: FOR_TO
61117: IFFALSE 61461
// begin if factory in mc_bases [ i ] then
61119: LD_VAR 0 2
61123: PUSH
61124: LD_EXP 112
61128: PUSH
61129: LD_VAR 0 4
61133: ARRAY
61134: IN
61135: IFFALSE 61459
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
61137: LD_EXP 134
61141: PUSH
61142: LD_VAR 0 4
61146: ARRAY
61147: PUSH
61148: LD_EXP 123
61152: PUSH
61153: LD_VAR 0 4
61157: ARRAY
61158: LESS
61159: PUSH
61160: LD_VAR 0 1
61164: PPUSH
61165: CALL_OW 264
61169: PUSH
61170: LD_INT 31
61172: PUSH
61173: LD_INT 32
61175: PUSH
61176: LD_INT 51
61178: PUSH
61179: LD_EXP 96
61183: PUSH
61184: LD_INT 12
61186: PUSH
61187: LD_INT 30
61189: PUSH
61190: LD_EXP 95
61194: PUSH
61195: LD_INT 11
61197: PUSH
61198: LD_INT 53
61200: PUSH
61201: LD_INT 14
61203: PUSH
61204: LD_EXP 99
61208: PUSH
61209: LD_INT 29
61211: PUSH
61212: LD_EXP 97
61216: PUSH
61217: LD_INT 13
61219: PUSH
61220: LD_INT 52
61222: PUSH
61223: LD_INT 48
61225: PUSH
61226: LD_INT 8
61228: PUSH
61229: EMPTY
61230: LIST
61231: LIST
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: LIST
61246: LIST
61247: IN
61248: NOT
61249: AND
61250: IFFALSE 61298
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61252: LD_ADDR_EXP 134
61256: PUSH
61257: LD_EXP 134
61261: PPUSH
61262: LD_VAR 0 4
61266: PUSH
61267: LD_EXP 134
61271: PUSH
61272: LD_VAR 0 4
61276: ARRAY
61277: PUSH
61278: LD_INT 1
61280: PLUS
61281: PUSH
61282: EMPTY
61283: LIST
61284: LIST
61285: PPUSH
61286: LD_VAR 0 1
61290: PPUSH
61291: CALL 70050 0 3
61295: ST_TO_ADDR
61296: GO 61342
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61298: LD_ADDR_EXP 131
61302: PUSH
61303: LD_EXP 131
61307: PPUSH
61308: LD_VAR 0 4
61312: PUSH
61313: LD_EXP 131
61317: PUSH
61318: LD_VAR 0 4
61322: ARRAY
61323: PUSH
61324: LD_INT 1
61326: PLUS
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: PPUSH
61332: LD_VAR 0 1
61336: PPUSH
61337: CALL 70050 0 3
61341: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61342: LD_VAR 0 1
61346: PPUSH
61347: CALL_OW 263
61351: PUSH
61352: LD_INT 2
61354: EQUAL
61355: IFFALSE 61375
// begin repeat wait ( 0 0$1 ) ;
61357: LD_INT 35
61359: PPUSH
61360: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61364: LD_VAR 0 1
61368: PPUSH
61369: CALL_OW 312
61373: IFFALSE 61357
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61375: LD_VAR 0 1
61379: PPUSH
61380: LD_EXP 136
61384: PUSH
61385: LD_VAR 0 4
61389: ARRAY
61390: PPUSH
61391: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61395: LD_VAR 0 1
61399: PPUSH
61400: CALL_OW 263
61404: PUSH
61405: LD_INT 1
61407: NONEQUAL
61408: IFFALSE 61412
// break ;
61410: GO 61461
// repeat wait ( 0 0$1 ) ;
61412: LD_INT 35
61414: PPUSH
61415: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61419: LD_VAR 0 1
61423: PPUSH
61424: LD_EXP 136
61428: PUSH
61429: LD_VAR 0 4
61433: ARRAY
61434: PPUSH
61435: CALL_OW 308
61439: IFFALSE 61412
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61441: LD_VAR 0 1
61445: PPUSH
61446: CALL_OW 311
61450: PPUSH
61451: CALL_OW 121
// exit ;
61455: POP
61456: POP
61457: GO 61463
// end ; end ;
61459: GO 61116
61461: POP
61462: POP
// end ;
61463: LD_VAR 0 3
61467: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61468: LD_INT 0
61470: PPUSH
61471: PPUSH
61472: PPUSH
61473: PPUSH
// if not mc_bases or not skirmish then
61474: LD_EXP 112
61478: NOT
61479: PUSH
61480: LD_EXP 110
61484: NOT
61485: OR
61486: IFFALSE 61490
// exit ;
61488: GO 61843
// repeat wait ( 0 0$1 ) ;
61490: LD_INT 35
61492: PPUSH
61493: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61497: LD_VAR 0 2
61501: PPUSH
61502: LD_VAR 0 3
61506: PPUSH
61507: CALL_OW 284
61511: IFFALSE 61490
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61513: LD_VAR 0 2
61517: PPUSH
61518: LD_VAR 0 3
61522: PPUSH
61523: CALL_OW 283
61527: PUSH
61528: LD_INT 4
61530: EQUAL
61531: IFFALSE 61535
// exit ;
61533: GO 61843
// for i = 1 to mc_bases do
61535: LD_ADDR_VAR 0 7
61539: PUSH
61540: DOUBLE
61541: LD_INT 1
61543: DEC
61544: ST_TO_ADDR
61545: LD_EXP 112
61549: PUSH
61550: FOR_TO
61551: IFFALSE 61841
// begin if mc_crates_area [ i ] then
61553: LD_EXP 130
61557: PUSH
61558: LD_VAR 0 7
61562: ARRAY
61563: IFFALSE 61674
// for j in mc_crates_area [ i ] do
61565: LD_ADDR_VAR 0 8
61569: PUSH
61570: LD_EXP 130
61574: PUSH
61575: LD_VAR 0 7
61579: ARRAY
61580: PUSH
61581: FOR_IN
61582: IFFALSE 61672
// if InArea ( x , y , j ) then
61584: LD_VAR 0 2
61588: PPUSH
61589: LD_VAR 0 3
61593: PPUSH
61594: LD_VAR 0 8
61598: PPUSH
61599: CALL_OW 309
61603: IFFALSE 61670
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61605: LD_ADDR_EXP 128
61609: PUSH
61610: LD_EXP 128
61614: PPUSH
61615: LD_VAR 0 7
61619: PUSH
61620: LD_EXP 128
61624: PUSH
61625: LD_VAR 0 7
61629: ARRAY
61630: PUSH
61631: LD_INT 1
61633: PLUS
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: PPUSH
61639: LD_VAR 0 4
61643: PUSH
61644: LD_VAR 0 2
61648: PUSH
61649: LD_VAR 0 3
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: LIST
61658: PPUSH
61659: CALL 70050 0 3
61663: ST_TO_ADDR
// exit ;
61664: POP
61665: POP
61666: POP
61667: POP
61668: GO 61843
// end ;
61670: GO 61581
61672: POP
61673: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61674: LD_ADDR_VAR 0 9
61678: PUSH
61679: LD_EXP 112
61683: PUSH
61684: LD_VAR 0 7
61688: ARRAY
61689: PPUSH
61690: LD_INT 2
61692: PUSH
61693: LD_INT 30
61695: PUSH
61696: LD_INT 0
61698: PUSH
61699: EMPTY
61700: LIST
61701: LIST
61702: PUSH
61703: LD_INT 30
61705: PUSH
61706: LD_INT 1
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: EMPTY
61714: LIST
61715: LIST
61716: LIST
61717: PPUSH
61718: CALL_OW 72
61722: ST_TO_ADDR
// if not depot then
61723: LD_VAR 0 9
61727: NOT
61728: IFFALSE 61732
// continue ;
61730: GO 61550
// for j in depot do
61732: LD_ADDR_VAR 0 8
61736: PUSH
61737: LD_VAR 0 9
61741: PUSH
61742: FOR_IN
61743: IFFALSE 61837
// if GetDistUnitXY ( j , x , y ) < 30 then
61745: LD_VAR 0 8
61749: PPUSH
61750: LD_VAR 0 2
61754: PPUSH
61755: LD_VAR 0 3
61759: PPUSH
61760: CALL_OW 297
61764: PUSH
61765: LD_INT 30
61767: LESS
61768: IFFALSE 61835
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61770: LD_ADDR_EXP 128
61774: PUSH
61775: LD_EXP 128
61779: PPUSH
61780: LD_VAR 0 7
61784: PUSH
61785: LD_EXP 128
61789: PUSH
61790: LD_VAR 0 7
61794: ARRAY
61795: PUSH
61796: LD_INT 1
61798: PLUS
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: PPUSH
61804: LD_VAR 0 4
61808: PUSH
61809: LD_VAR 0 2
61813: PUSH
61814: LD_VAR 0 3
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: LIST
61823: PPUSH
61824: CALL 70050 0 3
61828: ST_TO_ADDR
// exit ;
61829: POP
61830: POP
61831: POP
61832: POP
61833: GO 61843
// end ;
61835: GO 61742
61837: POP
61838: POP
// end ;
61839: GO 61550
61841: POP
61842: POP
// end ;
61843: LD_VAR 0 6
61847: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61848: LD_INT 0
61850: PPUSH
61851: PPUSH
61852: PPUSH
61853: PPUSH
// if not mc_bases or not skirmish then
61854: LD_EXP 112
61858: NOT
61859: PUSH
61860: LD_EXP 110
61864: NOT
61865: OR
61866: IFFALSE 61870
// exit ;
61868: GO 62147
// side := GetSide ( lab ) ;
61870: LD_ADDR_VAR 0 4
61874: PUSH
61875: LD_VAR 0 2
61879: PPUSH
61880: CALL_OW 255
61884: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61885: LD_VAR 0 4
61889: PUSH
61890: LD_EXP 138
61894: IN
61895: NOT
61896: PUSH
61897: LD_EXP 139
61901: NOT
61902: OR
61903: PUSH
61904: LD_EXP 112
61908: NOT
61909: OR
61910: IFFALSE 61914
// exit ;
61912: GO 62147
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61914: LD_ADDR_EXP 139
61918: PUSH
61919: LD_EXP 139
61923: PPUSH
61924: LD_VAR 0 4
61928: PPUSH
61929: LD_EXP 139
61933: PUSH
61934: LD_VAR 0 4
61938: ARRAY
61939: PUSH
61940: LD_VAR 0 1
61944: DIFF
61945: PPUSH
61946: CALL_OW 1
61950: ST_TO_ADDR
// for i = 1 to mc_bases do
61951: LD_ADDR_VAR 0 5
61955: PUSH
61956: DOUBLE
61957: LD_INT 1
61959: DEC
61960: ST_TO_ADDR
61961: LD_EXP 112
61965: PUSH
61966: FOR_TO
61967: IFFALSE 62145
// begin if lab in mc_bases [ i ] then
61969: LD_VAR 0 2
61973: PUSH
61974: LD_EXP 112
61978: PUSH
61979: LD_VAR 0 5
61983: ARRAY
61984: IN
61985: IFFALSE 62143
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61987: LD_VAR 0 1
61991: PUSH
61992: LD_INT 11
61994: PUSH
61995: LD_INT 4
61997: PUSH
61998: LD_INT 3
62000: PUSH
62001: LD_INT 2
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: IN
62010: PUSH
62011: LD_EXP 142
62015: PUSH
62016: LD_VAR 0 5
62020: ARRAY
62021: AND
62022: IFFALSE 62143
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62024: LD_ADDR_VAR 0 6
62028: PUSH
62029: LD_EXP 142
62033: PUSH
62034: LD_VAR 0 5
62038: ARRAY
62039: PUSH
62040: LD_INT 1
62042: ARRAY
62043: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62044: LD_ADDR_EXP 142
62048: PUSH
62049: LD_EXP 142
62053: PPUSH
62054: LD_VAR 0 5
62058: PPUSH
62059: EMPTY
62060: PPUSH
62061: CALL_OW 1
62065: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62066: LD_VAR 0 6
62070: PPUSH
62071: LD_INT 0
62073: PPUSH
62074: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62078: LD_VAR 0 6
62082: PPUSH
62083: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62087: LD_ADDR_EXP 141
62091: PUSH
62092: LD_EXP 141
62096: PPUSH
62097: LD_VAR 0 5
62101: PPUSH
62102: LD_EXP 141
62106: PUSH
62107: LD_VAR 0 5
62111: ARRAY
62112: PPUSH
62113: LD_INT 1
62115: PPUSH
62116: LD_VAR 0 6
62120: PPUSH
62121: CALL_OW 2
62125: PPUSH
62126: CALL_OW 1
62130: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62131: LD_VAR 0 5
62135: PPUSH
62136: LD_INT 112
62138: PPUSH
62139: CALL 39159 0 2
// end ; end ; end ;
62143: GO 61966
62145: POP
62146: POP
// end ;
62147: LD_VAR 0 3
62151: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62152: LD_INT 0
62154: PPUSH
62155: PPUSH
62156: PPUSH
62157: PPUSH
62158: PPUSH
62159: PPUSH
62160: PPUSH
62161: PPUSH
// if not mc_bases or not skirmish then
62162: LD_EXP 112
62166: NOT
62167: PUSH
62168: LD_EXP 110
62172: NOT
62173: OR
62174: IFFALSE 62178
// exit ;
62176: GO 63549
// for i = 1 to mc_bases do
62178: LD_ADDR_VAR 0 3
62182: PUSH
62183: DOUBLE
62184: LD_INT 1
62186: DEC
62187: ST_TO_ADDR
62188: LD_EXP 112
62192: PUSH
62193: FOR_TO
62194: IFFALSE 63547
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62196: LD_VAR 0 1
62200: PUSH
62201: LD_EXP 112
62205: PUSH
62206: LD_VAR 0 3
62210: ARRAY
62211: IN
62212: PUSH
62213: LD_VAR 0 1
62217: PUSH
62218: LD_EXP 119
62222: PUSH
62223: LD_VAR 0 3
62227: ARRAY
62228: IN
62229: OR
62230: PUSH
62231: LD_VAR 0 1
62235: PUSH
62236: LD_EXP 134
62240: PUSH
62241: LD_VAR 0 3
62245: ARRAY
62246: IN
62247: OR
62248: PUSH
62249: LD_VAR 0 1
62253: PUSH
62254: LD_EXP 131
62258: PUSH
62259: LD_VAR 0 3
62263: ARRAY
62264: IN
62265: OR
62266: PUSH
62267: LD_VAR 0 1
62271: PUSH
62272: LD_EXP 141
62276: PUSH
62277: LD_VAR 0 3
62281: ARRAY
62282: IN
62283: OR
62284: PUSH
62285: LD_VAR 0 1
62289: PUSH
62290: LD_EXP 142
62294: PUSH
62295: LD_VAR 0 3
62299: ARRAY
62300: IN
62301: OR
62302: IFFALSE 63545
// begin if un in mc_ape [ i ] then
62304: LD_VAR 0 1
62308: PUSH
62309: LD_EXP 141
62313: PUSH
62314: LD_VAR 0 3
62318: ARRAY
62319: IN
62320: IFFALSE 62359
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62322: LD_ADDR_EXP 141
62326: PUSH
62327: LD_EXP 141
62331: PPUSH
62332: LD_VAR 0 3
62336: PPUSH
62337: LD_EXP 141
62341: PUSH
62342: LD_VAR 0 3
62346: ARRAY
62347: PUSH
62348: LD_VAR 0 1
62352: DIFF
62353: PPUSH
62354: CALL_OW 1
62358: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62359: LD_VAR 0 1
62363: PUSH
62364: LD_EXP 142
62368: PUSH
62369: LD_VAR 0 3
62373: ARRAY
62374: IN
62375: IFFALSE 62399
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62377: LD_ADDR_EXP 142
62381: PUSH
62382: LD_EXP 142
62386: PPUSH
62387: LD_VAR 0 3
62391: PPUSH
62392: EMPTY
62393: PPUSH
62394: CALL_OW 1
62398: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62399: LD_VAR 0 1
62403: PPUSH
62404: CALL_OW 247
62408: PUSH
62409: LD_INT 2
62411: EQUAL
62412: PUSH
62413: LD_VAR 0 1
62417: PPUSH
62418: CALL_OW 110
62422: PUSH
62423: LD_INT 20
62425: EQUAL
62426: PUSH
62427: LD_VAR 0 1
62431: PUSH
62432: LD_EXP 134
62436: PUSH
62437: LD_VAR 0 3
62441: ARRAY
62442: IN
62443: OR
62444: PUSH
62445: LD_VAR 0 1
62449: PPUSH
62450: CALL_OW 264
62454: PUSH
62455: LD_INT 12
62457: PUSH
62458: LD_INT 51
62460: PUSH
62461: LD_EXP 96
62465: PUSH
62466: LD_INT 32
62468: PUSH
62469: LD_INT 13
62471: PUSH
62472: LD_INT 52
62474: PUSH
62475: LD_INT 31
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: LIST
62482: LIST
62483: LIST
62484: LIST
62485: LIST
62486: IN
62487: OR
62488: AND
62489: IFFALSE 62797
// begin if un in mc_defender [ i ] then
62491: LD_VAR 0 1
62495: PUSH
62496: LD_EXP 134
62500: PUSH
62501: LD_VAR 0 3
62505: ARRAY
62506: IN
62507: IFFALSE 62546
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62509: LD_ADDR_EXP 134
62513: PUSH
62514: LD_EXP 134
62518: PPUSH
62519: LD_VAR 0 3
62523: PPUSH
62524: LD_EXP 134
62528: PUSH
62529: LD_VAR 0 3
62533: ARRAY
62534: PUSH
62535: LD_VAR 0 1
62539: DIFF
62540: PPUSH
62541: CALL_OW 1
62545: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62546: LD_ADDR_VAR 0 8
62550: PUSH
62551: LD_VAR 0 3
62555: PPUSH
62556: LD_INT 3
62558: PPUSH
62559: CALL 59215 0 2
62563: ST_TO_ADDR
// if fac then
62564: LD_VAR 0 8
62568: IFFALSE 62797
// begin for j in fac do
62570: LD_ADDR_VAR 0 4
62574: PUSH
62575: LD_VAR 0 8
62579: PUSH
62580: FOR_IN
62581: IFFALSE 62795
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62583: LD_ADDR_VAR 0 9
62587: PUSH
62588: LD_VAR 0 8
62592: PPUSH
62593: LD_VAR 0 1
62597: PPUSH
62598: CALL_OW 265
62602: PPUSH
62603: LD_VAR 0 1
62607: PPUSH
62608: CALL_OW 262
62612: PPUSH
62613: LD_VAR 0 1
62617: PPUSH
62618: CALL_OW 263
62622: PPUSH
62623: LD_VAR 0 1
62627: PPUSH
62628: CALL_OW 264
62632: PPUSH
62633: CALL 67582 0 5
62637: ST_TO_ADDR
// if components then
62638: LD_VAR 0 9
62642: IFFALSE 62793
// begin if GetWeapon ( un ) = ar_control_tower then
62644: LD_VAR 0 1
62648: PPUSH
62649: CALL_OW 264
62653: PUSH
62654: LD_INT 31
62656: EQUAL
62657: IFFALSE 62774
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62659: LD_VAR 0 1
62663: PPUSH
62664: CALL_OW 311
62668: PPUSH
62669: LD_INT 0
62671: PPUSH
62672: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62676: LD_ADDR_EXP 152
62680: PUSH
62681: LD_EXP 152
62685: PPUSH
62686: LD_VAR 0 3
62690: PPUSH
62691: LD_EXP 152
62695: PUSH
62696: LD_VAR 0 3
62700: ARRAY
62701: PUSH
62702: LD_VAR 0 1
62706: PPUSH
62707: CALL_OW 311
62711: DIFF
62712: PPUSH
62713: CALL_OW 1
62717: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62718: LD_ADDR_VAR 0 7
62722: PUSH
62723: LD_EXP 133
62727: PUSH
62728: LD_VAR 0 3
62732: ARRAY
62733: PPUSH
62734: LD_INT 1
62736: PPUSH
62737: LD_VAR 0 9
62741: PPUSH
62742: CALL_OW 2
62746: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62747: LD_ADDR_EXP 133
62751: PUSH
62752: LD_EXP 133
62756: PPUSH
62757: LD_VAR 0 3
62761: PPUSH
62762: LD_VAR 0 7
62766: PPUSH
62767: CALL_OW 1
62771: ST_TO_ADDR
// end else
62772: GO 62791
// MC_InsertProduceList ( i , [ components ] ) ;
62774: LD_VAR 0 3
62778: PPUSH
62779: LD_VAR 0 9
62783: PUSH
62784: EMPTY
62785: LIST
62786: PPUSH
62787: CALL 58760 0 2
// break ;
62791: GO 62795
// end ; end ;
62793: GO 62580
62795: POP
62796: POP
// end ; end ; if GetType ( un ) = unit_building then
62797: LD_VAR 0 1
62801: PPUSH
62802: CALL_OW 247
62806: PUSH
62807: LD_INT 3
62809: EQUAL
62810: IFFALSE 63213
// begin btype := GetBType ( un ) ;
62812: LD_ADDR_VAR 0 5
62816: PUSH
62817: LD_VAR 0 1
62821: PPUSH
62822: CALL_OW 266
62826: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62827: LD_VAR 0 5
62831: PUSH
62832: LD_INT 29
62834: PUSH
62835: LD_INT 30
62837: PUSH
62838: EMPTY
62839: LIST
62840: LIST
62841: IN
62842: IFFALSE 62915
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62844: LD_VAR 0 1
62848: PPUSH
62849: CALL_OW 250
62853: PPUSH
62854: LD_VAR 0 1
62858: PPUSH
62859: CALL_OW 251
62863: PPUSH
62864: LD_VAR 0 1
62868: PPUSH
62869: CALL_OW 255
62873: PPUSH
62874: CALL_OW 440
62878: NOT
62879: IFFALSE 62915
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62881: LD_VAR 0 1
62885: PPUSH
62886: CALL_OW 250
62890: PPUSH
62891: LD_VAR 0 1
62895: PPUSH
62896: CALL_OW 251
62900: PPUSH
62901: LD_VAR 0 1
62905: PPUSH
62906: CALL_OW 255
62910: PPUSH
62911: CALL_OW 441
// end ; if btype = b_warehouse then
62915: LD_VAR 0 5
62919: PUSH
62920: LD_INT 1
62922: EQUAL
62923: IFFALSE 62941
// begin btype := b_depot ;
62925: LD_ADDR_VAR 0 5
62929: PUSH
62930: LD_INT 0
62932: ST_TO_ADDR
// pos := 1 ;
62933: LD_ADDR_VAR 0 6
62937: PUSH
62938: LD_INT 1
62940: ST_TO_ADDR
// end ; if btype = b_factory then
62941: LD_VAR 0 5
62945: PUSH
62946: LD_INT 3
62948: EQUAL
62949: IFFALSE 62967
// begin btype := b_workshop ;
62951: LD_ADDR_VAR 0 5
62955: PUSH
62956: LD_INT 2
62958: ST_TO_ADDR
// pos := 1 ;
62959: LD_ADDR_VAR 0 6
62963: PUSH
62964: LD_INT 1
62966: ST_TO_ADDR
// end ; if btype = b_barracks then
62967: LD_VAR 0 5
62971: PUSH
62972: LD_INT 5
62974: EQUAL
62975: IFFALSE 62985
// btype := b_armoury ;
62977: LD_ADDR_VAR 0 5
62981: PUSH
62982: LD_INT 4
62984: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62985: LD_VAR 0 5
62989: PUSH
62990: LD_INT 7
62992: PUSH
62993: LD_INT 8
62995: PUSH
62996: EMPTY
62997: LIST
62998: LIST
62999: IN
63000: IFFALSE 63010
// btype := b_lab ;
63002: LD_ADDR_VAR 0 5
63006: PUSH
63007: LD_INT 6
63009: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63010: LD_ADDR_EXP 117
63014: PUSH
63015: LD_EXP 117
63019: PPUSH
63020: LD_VAR 0 3
63024: PUSH
63025: LD_EXP 117
63029: PUSH
63030: LD_VAR 0 3
63034: ARRAY
63035: PUSH
63036: LD_INT 1
63038: PLUS
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PPUSH
63044: LD_VAR 0 5
63048: PUSH
63049: LD_VAR 0 1
63053: PPUSH
63054: CALL_OW 250
63058: PUSH
63059: LD_VAR 0 1
63063: PPUSH
63064: CALL_OW 251
63068: PUSH
63069: LD_VAR 0 1
63073: PPUSH
63074: CALL_OW 254
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: LIST
63083: LIST
63084: PPUSH
63085: CALL 70050 0 3
63089: ST_TO_ADDR
// if pos = 1 then
63090: LD_VAR 0 6
63094: PUSH
63095: LD_INT 1
63097: EQUAL
63098: IFFALSE 63213
// begin tmp := mc_build_list [ i ] ;
63100: LD_ADDR_VAR 0 7
63104: PUSH
63105: LD_EXP 117
63109: PUSH
63110: LD_VAR 0 3
63114: ARRAY
63115: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63116: LD_VAR 0 7
63120: PPUSH
63121: LD_INT 2
63123: PUSH
63124: LD_INT 30
63126: PUSH
63127: LD_INT 0
63129: PUSH
63130: EMPTY
63131: LIST
63132: LIST
63133: PUSH
63134: LD_INT 30
63136: PUSH
63137: LD_INT 1
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: PUSH
63144: EMPTY
63145: LIST
63146: LIST
63147: LIST
63148: PPUSH
63149: CALL_OW 72
63153: IFFALSE 63163
// pos := 2 ;
63155: LD_ADDR_VAR 0 6
63159: PUSH
63160: LD_INT 2
63162: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63163: LD_ADDR_VAR 0 7
63167: PUSH
63168: LD_VAR 0 7
63172: PPUSH
63173: LD_VAR 0 6
63177: PPUSH
63178: LD_VAR 0 7
63182: PPUSH
63183: CALL 70376 0 3
63187: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63188: LD_ADDR_EXP 117
63192: PUSH
63193: LD_EXP 117
63197: PPUSH
63198: LD_VAR 0 3
63202: PPUSH
63203: LD_VAR 0 7
63207: PPUSH
63208: CALL_OW 1
63212: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63213: LD_VAR 0 1
63217: PUSH
63218: LD_EXP 112
63222: PUSH
63223: LD_VAR 0 3
63227: ARRAY
63228: IN
63229: IFFALSE 63268
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63231: LD_ADDR_EXP 112
63235: PUSH
63236: LD_EXP 112
63240: PPUSH
63241: LD_VAR 0 3
63245: PPUSH
63246: LD_EXP 112
63250: PUSH
63251: LD_VAR 0 3
63255: ARRAY
63256: PUSH
63257: LD_VAR 0 1
63261: DIFF
63262: PPUSH
63263: CALL_OW 1
63267: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63268: LD_VAR 0 1
63272: PUSH
63273: LD_EXP 119
63277: PUSH
63278: LD_VAR 0 3
63282: ARRAY
63283: IN
63284: IFFALSE 63323
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63286: LD_ADDR_EXP 119
63290: PUSH
63291: LD_EXP 119
63295: PPUSH
63296: LD_VAR 0 3
63300: PPUSH
63301: LD_EXP 119
63305: PUSH
63306: LD_VAR 0 3
63310: ARRAY
63311: PUSH
63312: LD_VAR 0 1
63316: DIFF
63317: PPUSH
63318: CALL_OW 1
63322: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63323: LD_VAR 0 1
63327: PUSH
63328: LD_EXP 131
63332: PUSH
63333: LD_VAR 0 3
63337: ARRAY
63338: IN
63339: IFFALSE 63378
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63341: LD_ADDR_EXP 131
63345: PUSH
63346: LD_EXP 131
63350: PPUSH
63351: LD_VAR 0 3
63355: PPUSH
63356: LD_EXP 131
63360: PUSH
63361: LD_VAR 0 3
63365: ARRAY
63366: PUSH
63367: LD_VAR 0 1
63371: DIFF
63372: PPUSH
63373: CALL_OW 1
63377: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63378: LD_VAR 0 1
63382: PUSH
63383: LD_EXP 134
63387: PUSH
63388: LD_VAR 0 3
63392: ARRAY
63393: IN
63394: IFFALSE 63433
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63396: LD_ADDR_EXP 134
63400: PUSH
63401: LD_EXP 134
63405: PPUSH
63406: LD_VAR 0 3
63410: PPUSH
63411: LD_EXP 134
63415: PUSH
63416: LD_VAR 0 3
63420: ARRAY
63421: PUSH
63422: LD_VAR 0 1
63426: DIFF
63427: PPUSH
63428: CALL_OW 1
63432: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63433: LD_VAR 0 1
63437: PUSH
63438: LD_EXP 121
63442: PUSH
63443: LD_VAR 0 3
63447: ARRAY
63448: IN
63449: IFFALSE 63488
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63451: LD_ADDR_EXP 121
63455: PUSH
63456: LD_EXP 121
63460: PPUSH
63461: LD_VAR 0 3
63465: PPUSH
63466: LD_EXP 121
63470: PUSH
63471: LD_VAR 0 3
63475: ARRAY
63476: PUSH
63477: LD_VAR 0 1
63481: DIFF
63482: PPUSH
63483: CALL_OW 1
63487: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63488: LD_VAR 0 1
63492: PUSH
63493: LD_EXP 120
63497: PUSH
63498: LD_VAR 0 3
63502: ARRAY
63503: IN
63504: IFFALSE 63543
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63506: LD_ADDR_EXP 120
63510: PUSH
63511: LD_EXP 120
63515: PPUSH
63516: LD_VAR 0 3
63520: PPUSH
63521: LD_EXP 120
63525: PUSH
63526: LD_VAR 0 3
63530: ARRAY
63531: PUSH
63532: LD_VAR 0 1
63536: DIFF
63537: PPUSH
63538: CALL_OW 1
63542: ST_TO_ADDR
// end ; break ;
63543: GO 63547
// end ;
63545: GO 62193
63547: POP
63548: POP
// end ;
63549: LD_VAR 0 2
63553: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63554: LD_INT 0
63556: PPUSH
63557: PPUSH
63558: PPUSH
// if not mc_bases or not skirmish then
63559: LD_EXP 112
63563: NOT
63564: PUSH
63565: LD_EXP 110
63569: NOT
63570: OR
63571: IFFALSE 63575
// exit ;
63573: GO 63790
// for i = 1 to mc_bases do
63575: LD_ADDR_VAR 0 3
63579: PUSH
63580: DOUBLE
63581: LD_INT 1
63583: DEC
63584: ST_TO_ADDR
63585: LD_EXP 112
63589: PUSH
63590: FOR_TO
63591: IFFALSE 63788
// begin if building in mc_construct_list [ i ] then
63593: LD_VAR 0 1
63597: PUSH
63598: LD_EXP 119
63602: PUSH
63603: LD_VAR 0 3
63607: ARRAY
63608: IN
63609: IFFALSE 63786
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63611: LD_ADDR_EXP 119
63615: PUSH
63616: LD_EXP 119
63620: PPUSH
63621: LD_VAR 0 3
63625: PPUSH
63626: LD_EXP 119
63630: PUSH
63631: LD_VAR 0 3
63635: ARRAY
63636: PUSH
63637: LD_VAR 0 1
63641: DIFF
63642: PPUSH
63643: CALL_OW 1
63647: ST_TO_ADDR
// if building in mc_lab [ i ] then
63648: LD_VAR 0 1
63652: PUSH
63653: LD_EXP 145
63657: PUSH
63658: LD_VAR 0 3
63662: ARRAY
63663: IN
63664: IFFALSE 63719
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63666: LD_ADDR_EXP 146
63670: PUSH
63671: LD_EXP 146
63675: PPUSH
63676: LD_VAR 0 3
63680: PPUSH
63681: LD_EXP 146
63685: PUSH
63686: LD_VAR 0 3
63690: ARRAY
63691: PPUSH
63692: LD_INT 1
63694: PPUSH
63695: LD_EXP 146
63699: PUSH
63700: LD_VAR 0 3
63704: ARRAY
63705: PPUSH
63706: LD_INT 0
63708: PPUSH
63709: CALL 69468 0 4
63713: PPUSH
63714: CALL_OW 1
63718: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63719: LD_VAR 0 1
63723: PUSH
63724: LD_EXP 112
63728: PUSH
63729: LD_VAR 0 3
63733: ARRAY
63734: IN
63735: NOT
63736: IFFALSE 63782
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63738: LD_ADDR_EXP 112
63742: PUSH
63743: LD_EXP 112
63747: PPUSH
63748: LD_VAR 0 3
63752: PUSH
63753: LD_EXP 112
63757: PUSH
63758: LD_VAR 0 3
63762: ARRAY
63763: PUSH
63764: LD_INT 1
63766: PLUS
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PPUSH
63772: LD_VAR 0 1
63776: PPUSH
63777: CALL 70050 0 3
63781: ST_TO_ADDR
// exit ;
63782: POP
63783: POP
63784: GO 63790
// end ; end ;
63786: GO 63590
63788: POP
63789: POP
// end ;
63790: LD_VAR 0 2
63794: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63795: LD_INT 0
63797: PPUSH
63798: PPUSH
63799: PPUSH
63800: PPUSH
63801: PPUSH
63802: PPUSH
63803: PPUSH
// if not mc_bases or not skirmish then
63804: LD_EXP 112
63808: NOT
63809: PUSH
63810: LD_EXP 110
63814: NOT
63815: OR
63816: IFFALSE 63820
// exit ;
63818: GO 64481
// for i = 1 to mc_bases do
63820: LD_ADDR_VAR 0 3
63824: PUSH
63825: DOUBLE
63826: LD_INT 1
63828: DEC
63829: ST_TO_ADDR
63830: LD_EXP 112
63834: PUSH
63835: FOR_TO
63836: IFFALSE 64479
// begin if building in mc_construct_list [ i ] then
63838: LD_VAR 0 1
63842: PUSH
63843: LD_EXP 119
63847: PUSH
63848: LD_VAR 0 3
63852: ARRAY
63853: IN
63854: IFFALSE 64477
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63856: LD_ADDR_EXP 119
63860: PUSH
63861: LD_EXP 119
63865: PPUSH
63866: LD_VAR 0 3
63870: PPUSH
63871: LD_EXP 119
63875: PUSH
63876: LD_VAR 0 3
63880: ARRAY
63881: PUSH
63882: LD_VAR 0 1
63886: DIFF
63887: PPUSH
63888: CALL_OW 1
63892: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63893: LD_ADDR_EXP 112
63897: PUSH
63898: LD_EXP 112
63902: PPUSH
63903: LD_VAR 0 3
63907: PUSH
63908: LD_EXP 112
63912: PUSH
63913: LD_VAR 0 3
63917: ARRAY
63918: PUSH
63919: LD_INT 1
63921: PLUS
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PPUSH
63927: LD_VAR 0 1
63931: PPUSH
63932: CALL 70050 0 3
63936: ST_TO_ADDR
// btype := GetBType ( building ) ;
63937: LD_ADDR_VAR 0 5
63941: PUSH
63942: LD_VAR 0 1
63946: PPUSH
63947: CALL_OW 266
63951: ST_TO_ADDR
// side := GetSide ( building ) ;
63952: LD_ADDR_VAR 0 8
63956: PUSH
63957: LD_VAR 0 1
63961: PPUSH
63962: CALL_OW 255
63966: ST_TO_ADDR
// if btype = b_lab then
63967: LD_VAR 0 5
63971: PUSH
63972: LD_INT 6
63974: EQUAL
63975: IFFALSE 64025
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63977: LD_ADDR_EXP 145
63981: PUSH
63982: LD_EXP 145
63986: PPUSH
63987: LD_VAR 0 3
63991: PUSH
63992: LD_EXP 145
63996: PUSH
63997: LD_VAR 0 3
64001: ARRAY
64002: PUSH
64003: LD_INT 1
64005: PLUS
64006: PUSH
64007: EMPTY
64008: LIST
64009: LIST
64010: PPUSH
64011: LD_VAR 0 1
64015: PPUSH
64016: CALL 70050 0 3
64020: ST_TO_ADDR
// exit ;
64021: POP
64022: POP
64023: GO 64481
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64025: LD_VAR 0 5
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: LD_INT 2
64035: PUSH
64036: LD_INT 4
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: LIST
64043: IN
64044: IFFALSE 64168
// begin if btype = b_armoury then
64046: LD_VAR 0 5
64050: PUSH
64051: LD_INT 4
64053: EQUAL
64054: IFFALSE 64064
// btype := b_barracks ;
64056: LD_ADDR_VAR 0 5
64060: PUSH
64061: LD_INT 5
64063: ST_TO_ADDR
// if btype = b_depot then
64064: LD_VAR 0 5
64068: PUSH
64069: LD_INT 0
64071: EQUAL
64072: IFFALSE 64082
// btype := b_warehouse ;
64074: LD_ADDR_VAR 0 5
64078: PUSH
64079: LD_INT 1
64081: ST_TO_ADDR
// if btype = b_workshop then
64082: LD_VAR 0 5
64086: PUSH
64087: LD_INT 2
64089: EQUAL
64090: IFFALSE 64100
// btype := b_factory ;
64092: LD_ADDR_VAR 0 5
64096: PUSH
64097: LD_INT 3
64099: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64100: LD_VAR 0 5
64104: PPUSH
64105: LD_VAR 0 8
64109: PPUSH
64110: CALL_OW 323
64114: PUSH
64115: LD_INT 1
64117: EQUAL
64118: IFFALSE 64164
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64120: LD_ADDR_EXP 144
64124: PUSH
64125: LD_EXP 144
64129: PPUSH
64130: LD_VAR 0 3
64134: PUSH
64135: LD_EXP 144
64139: PUSH
64140: LD_VAR 0 3
64144: ARRAY
64145: PUSH
64146: LD_INT 1
64148: PLUS
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PPUSH
64154: LD_VAR 0 1
64158: PPUSH
64159: CALL 70050 0 3
64163: ST_TO_ADDR
// exit ;
64164: POP
64165: POP
64166: GO 64481
// end ; if btype in [ b_bunker , b_turret ] then
64168: LD_VAR 0 5
64172: PUSH
64173: LD_INT 32
64175: PUSH
64176: LD_INT 33
64178: PUSH
64179: EMPTY
64180: LIST
64181: LIST
64182: IN
64183: IFFALSE 64473
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64185: LD_ADDR_EXP 120
64189: PUSH
64190: LD_EXP 120
64194: PPUSH
64195: LD_VAR 0 3
64199: PUSH
64200: LD_EXP 120
64204: PUSH
64205: LD_VAR 0 3
64209: ARRAY
64210: PUSH
64211: LD_INT 1
64213: PLUS
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: PPUSH
64219: LD_VAR 0 1
64223: PPUSH
64224: CALL 70050 0 3
64228: ST_TO_ADDR
// if btype = b_bunker then
64229: LD_VAR 0 5
64233: PUSH
64234: LD_INT 32
64236: EQUAL
64237: IFFALSE 64473
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64239: LD_ADDR_EXP 121
64243: PUSH
64244: LD_EXP 121
64248: PPUSH
64249: LD_VAR 0 3
64253: PUSH
64254: LD_EXP 121
64258: PUSH
64259: LD_VAR 0 3
64263: ARRAY
64264: PUSH
64265: LD_INT 1
64267: PLUS
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PPUSH
64273: LD_VAR 0 1
64277: PPUSH
64278: CALL 70050 0 3
64282: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64283: LD_ADDR_VAR 0 6
64287: PUSH
64288: LD_EXP 112
64292: PUSH
64293: LD_VAR 0 3
64297: ARRAY
64298: PPUSH
64299: LD_INT 25
64301: PUSH
64302: LD_INT 1
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 3
64311: PUSH
64312: LD_INT 54
64314: PUSH
64315: EMPTY
64316: LIST
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: PPUSH
64326: CALL_OW 72
64330: ST_TO_ADDR
// if tmp then
64331: LD_VAR 0 6
64335: IFFALSE 64341
// exit ;
64337: POP
64338: POP
64339: GO 64481
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64341: LD_ADDR_VAR 0 6
64345: PUSH
64346: LD_EXP 112
64350: PUSH
64351: LD_VAR 0 3
64355: ARRAY
64356: PPUSH
64357: LD_INT 2
64359: PUSH
64360: LD_INT 30
64362: PUSH
64363: LD_INT 4
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 30
64372: PUSH
64373: LD_INT 5
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: EMPTY
64381: LIST
64382: LIST
64383: LIST
64384: PPUSH
64385: CALL_OW 72
64389: ST_TO_ADDR
// if not tmp then
64390: LD_VAR 0 6
64394: NOT
64395: IFFALSE 64401
// exit ;
64397: POP
64398: POP
64399: GO 64481
// for j in tmp do
64401: LD_ADDR_VAR 0 4
64405: PUSH
64406: LD_VAR 0 6
64410: PUSH
64411: FOR_IN
64412: IFFALSE 64471
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64414: LD_ADDR_VAR 0 7
64418: PUSH
64419: LD_VAR 0 4
64423: PPUSH
64424: CALL_OW 313
64428: PPUSH
64429: LD_INT 25
64431: PUSH
64432: LD_INT 1
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PPUSH
64439: CALL_OW 72
64443: ST_TO_ADDR
// if units then
64444: LD_VAR 0 7
64448: IFFALSE 64469
// begin ComExitBuilding ( units [ 1 ] ) ;
64450: LD_VAR 0 7
64454: PUSH
64455: LD_INT 1
64457: ARRAY
64458: PPUSH
64459: CALL_OW 122
// exit ;
64463: POP
64464: POP
64465: POP
64466: POP
64467: GO 64481
// end ; end ;
64469: GO 64411
64471: POP
64472: POP
// end ; end ; exit ;
64473: POP
64474: POP
64475: GO 64481
// end ; end ;
64477: GO 63835
64479: POP
64480: POP
// end ;
64481: LD_VAR 0 2
64485: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64486: LD_INT 0
64488: PPUSH
64489: PPUSH
64490: PPUSH
64491: PPUSH
64492: PPUSH
64493: PPUSH
64494: PPUSH
// if not mc_bases or not skirmish then
64495: LD_EXP 112
64499: NOT
64500: PUSH
64501: LD_EXP 110
64505: NOT
64506: OR
64507: IFFALSE 64511
// exit ;
64509: GO 64742
// btype := GetBType ( building ) ;
64511: LD_ADDR_VAR 0 6
64515: PUSH
64516: LD_VAR 0 1
64520: PPUSH
64521: CALL_OW 266
64525: ST_TO_ADDR
// x := GetX ( building ) ;
64526: LD_ADDR_VAR 0 7
64530: PUSH
64531: LD_VAR 0 1
64535: PPUSH
64536: CALL_OW 250
64540: ST_TO_ADDR
// y := GetY ( building ) ;
64541: LD_ADDR_VAR 0 8
64545: PUSH
64546: LD_VAR 0 1
64550: PPUSH
64551: CALL_OW 251
64555: ST_TO_ADDR
// d := GetDir ( building ) ;
64556: LD_ADDR_VAR 0 9
64560: PUSH
64561: LD_VAR 0 1
64565: PPUSH
64566: CALL_OW 254
64570: ST_TO_ADDR
// for i = 1 to mc_bases do
64571: LD_ADDR_VAR 0 4
64575: PUSH
64576: DOUBLE
64577: LD_INT 1
64579: DEC
64580: ST_TO_ADDR
64581: LD_EXP 112
64585: PUSH
64586: FOR_TO
64587: IFFALSE 64740
// begin if not mc_build_list [ i ] then
64589: LD_EXP 117
64593: PUSH
64594: LD_VAR 0 4
64598: ARRAY
64599: NOT
64600: IFFALSE 64604
// continue ;
64602: GO 64586
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64604: LD_VAR 0 6
64608: PUSH
64609: LD_VAR 0 7
64613: PUSH
64614: LD_VAR 0 8
64618: PUSH
64619: LD_VAR 0 9
64623: PUSH
64624: EMPTY
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: PPUSH
64630: LD_EXP 117
64634: PUSH
64635: LD_VAR 0 4
64639: ARRAY
64640: PUSH
64641: LD_INT 1
64643: ARRAY
64644: PPUSH
64645: CALL 76219 0 2
64649: IFFALSE 64738
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64651: LD_ADDR_EXP 117
64655: PUSH
64656: LD_EXP 117
64660: PPUSH
64661: LD_VAR 0 4
64665: PPUSH
64666: LD_EXP 117
64670: PUSH
64671: LD_VAR 0 4
64675: ARRAY
64676: PPUSH
64677: LD_INT 1
64679: PPUSH
64680: CALL_OW 3
64684: PPUSH
64685: CALL_OW 1
64689: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64690: LD_ADDR_EXP 119
64694: PUSH
64695: LD_EXP 119
64699: PPUSH
64700: LD_VAR 0 4
64704: PUSH
64705: LD_EXP 119
64709: PUSH
64710: LD_VAR 0 4
64714: ARRAY
64715: PUSH
64716: LD_INT 1
64718: PLUS
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PPUSH
64724: LD_VAR 0 1
64728: PPUSH
64729: CALL 70050 0 3
64733: ST_TO_ADDR
// exit ;
64734: POP
64735: POP
64736: GO 64742
// end ; end ;
64738: GO 64586
64740: POP
64741: POP
// end ;
64742: LD_VAR 0 3
64746: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64747: LD_INT 0
64749: PPUSH
64750: PPUSH
64751: PPUSH
// if not mc_bases or not skirmish then
64752: LD_EXP 112
64756: NOT
64757: PUSH
64758: LD_EXP 110
64762: NOT
64763: OR
64764: IFFALSE 64768
// exit ;
64766: GO 64958
// for i = 1 to mc_bases do
64768: LD_ADDR_VAR 0 4
64772: PUSH
64773: DOUBLE
64774: LD_INT 1
64776: DEC
64777: ST_TO_ADDR
64778: LD_EXP 112
64782: PUSH
64783: FOR_TO
64784: IFFALSE 64871
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64786: LD_VAR 0 1
64790: PUSH
64791: LD_EXP 120
64795: PUSH
64796: LD_VAR 0 4
64800: ARRAY
64801: IN
64802: PUSH
64803: LD_VAR 0 1
64807: PUSH
64808: LD_EXP 121
64812: PUSH
64813: LD_VAR 0 4
64817: ARRAY
64818: IN
64819: NOT
64820: AND
64821: IFFALSE 64869
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64823: LD_ADDR_EXP 121
64827: PUSH
64828: LD_EXP 121
64832: PPUSH
64833: LD_VAR 0 4
64837: PUSH
64838: LD_EXP 121
64842: PUSH
64843: LD_VAR 0 4
64847: ARRAY
64848: PUSH
64849: LD_INT 1
64851: PLUS
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: PPUSH
64857: LD_VAR 0 1
64861: PPUSH
64862: CALL 70050 0 3
64866: ST_TO_ADDR
// break ;
64867: GO 64871
// end ; end ;
64869: GO 64783
64871: POP
64872: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64873: LD_VAR 0 1
64877: PPUSH
64878: CALL_OW 257
64882: PUSH
64883: LD_EXP 138
64887: IN
64888: PUSH
64889: LD_VAR 0 1
64893: PPUSH
64894: CALL_OW 266
64898: PUSH
64899: LD_INT 5
64901: EQUAL
64902: AND
64903: PUSH
64904: LD_VAR 0 2
64908: PPUSH
64909: CALL_OW 110
64913: PUSH
64914: LD_INT 18
64916: NONEQUAL
64917: AND
64918: IFFALSE 64958
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64920: LD_VAR 0 2
64924: PPUSH
64925: CALL_OW 257
64929: PUSH
64930: LD_INT 5
64932: PUSH
64933: LD_INT 8
64935: PUSH
64936: LD_INT 9
64938: PUSH
64939: EMPTY
64940: LIST
64941: LIST
64942: LIST
64943: IN
64944: IFFALSE 64958
// SetClass ( unit , 1 ) ;
64946: LD_VAR 0 2
64950: PPUSH
64951: LD_INT 1
64953: PPUSH
64954: CALL_OW 336
// end ;
64958: LD_VAR 0 3
64962: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64963: LD_INT 0
64965: PPUSH
64966: PPUSH
// if not mc_bases or not skirmish then
64967: LD_EXP 112
64971: NOT
64972: PUSH
64973: LD_EXP 110
64977: NOT
64978: OR
64979: IFFALSE 64983
// exit ;
64981: GO 65099
// if GetLives ( abandoned_vehicle ) > 250 then
64983: LD_VAR 0 2
64987: PPUSH
64988: CALL_OW 256
64992: PUSH
64993: LD_INT 250
64995: GREATER
64996: IFFALSE 65000
// exit ;
64998: GO 65099
// for i = 1 to mc_bases do
65000: LD_ADDR_VAR 0 6
65004: PUSH
65005: DOUBLE
65006: LD_INT 1
65008: DEC
65009: ST_TO_ADDR
65010: LD_EXP 112
65014: PUSH
65015: FOR_TO
65016: IFFALSE 65097
// begin if driver in mc_bases [ i ] then
65018: LD_VAR 0 1
65022: PUSH
65023: LD_EXP 112
65027: PUSH
65028: LD_VAR 0 6
65032: ARRAY
65033: IN
65034: IFFALSE 65095
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65036: LD_VAR 0 1
65040: PPUSH
65041: LD_EXP 112
65045: PUSH
65046: LD_VAR 0 6
65050: ARRAY
65051: PPUSH
65052: LD_INT 2
65054: PUSH
65055: LD_INT 30
65057: PUSH
65058: LD_INT 0
65060: PUSH
65061: EMPTY
65062: LIST
65063: LIST
65064: PUSH
65065: LD_INT 30
65067: PUSH
65068: LD_INT 1
65070: PUSH
65071: EMPTY
65072: LIST
65073: LIST
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: LIST
65079: PPUSH
65080: CALL_OW 72
65084: PUSH
65085: LD_INT 1
65087: ARRAY
65088: PPUSH
65089: CALL_OW 112
// break ;
65093: GO 65097
// end ; end ;
65095: GO 65015
65097: POP
65098: POP
// end ; end_of_file
65099: LD_VAR 0 5
65103: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65104: LD_INT 0
65106: PPUSH
65107: PPUSH
// if exist_mode then
65108: LD_VAR 0 2
65112: IFFALSE 65137
// unit := CreateCharacter ( prefix & ident ) else
65114: LD_ADDR_VAR 0 5
65118: PUSH
65119: LD_VAR 0 3
65123: PUSH
65124: LD_VAR 0 1
65128: STR
65129: PPUSH
65130: CALL_OW 34
65134: ST_TO_ADDR
65135: GO 65152
// unit := NewCharacter ( ident ) ;
65137: LD_ADDR_VAR 0 5
65141: PUSH
65142: LD_VAR 0 1
65146: PPUSH
65147: CALL_OW 25
65151: ST_TO_ADDR
// result := unit ;
65152: LD_ADDR_VAR 0 4
65156: PUSH
65157: LD_VAR 0 5
65161: ST_TO_ADDR
// end ;
65162: LD_VAR 0 4
65166: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65167: LD_INT 0
65169: PPUSH
65170: PPUSH
// if not side or not nation then
65171: LD_VAR 0 1
65175: NOT
65176: PUSH
65177: LD_VAR 0 2
65181: NOT
65182: OR
65183: IFFALSE 65187
// exit ;
65185: GO 65951
// case nation of nation_american :
65187: LD_VAR 0 2
65191: PUSH
65192: LD_INT 1
65194: DOUBLE
65195: EQUAL
65196: IFTRUE 65200
65198: GO 65414
65200: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65201: LD_ADDR_VAR 0 4
65205: PUSH
65206: LD_INT 35
65208: PUSH
65209: LD_INT 45
65211: PUSH
65212: LD_INT 46
65214: PUSH
65215: LD_INT 47
65217: PUSH
65218: LD_INT 82
65220: PUSH
65221: LD_INT 83
65223: PUSH
65224: LD_INT 84
65226: PUSH
65227: LD_INT 85
65229: PUSH
65230: LD_INT 86
65232: PUSH
65233: LD_INT 1
65235: PUSH
65236: LD_INT 2
65238: PUSH
65239: LD_INT 6
65241: PUSH
65242: LD_INT 15
65244: PUSH
65245: LD_INT 16
65247: PUSH
65248: LD_INT 7
65250: PUSH
65251: LD_INT 12
65253: PUSH
65254: LD_INT 13
65256: PUSH
65257: LD_INT 10
65259: PUSH
65260: LD_INT 14
65262: PUSH
65263: LD_INT 20
65265: PUSH
65266: LD_INT 21
65268: PUSH
65269: LD_INT 22
65271: PUSH
65272: LD_INT 25
65274: PUSH
65275: LD_INT 32
65277: PUSH
65278: LD_INT 27
65280: PUSH
65281: LD_INT 36
65283: PUSH
65284: LD_INT 69
65286: PUSH
65287: LD_INT 39
65289: PUSH
65290: LD_INT 34
65292: PUSH
65293: LD_INT 40
65295: PUSH
65296: LD_INT 48
65298: PUSH
65299: LD_INT 49
65301: PUSH
65302: LD_INT 50
65304: PUSH
65305: LD_INT 51
65307: PUSH
65308: LD_INT 52
65310: PUSH
65311: LD_INT 53
65313: PUSH
65314: LD_INT 54
65316: PUSH
65317: LD_INT 55
65319: PUSH
65320: LD_INT 56
65322: PUSH
65323: LD_INT 57
65325: PUSH
65326: LD_INT 58
65328: PUSH
65329: LD_INT 59
65331: PUSH
65332: LD_INT 60
65334: PUSH
65335: LD_INT 61
65337: PUSH
65338: LD_INT 62
65340: PUSH
65341: LD_INT 80
65343: PUSH
65344: LD_INT 82
65346: PUSH
65347: LD_INT 83
65349: PUSH
65350: LD_INT 84
65352: PUSH
65353: LD_INT 85
65355: PUSH
65356: LD_INT 86
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: ST_TO_ADDR
65412: GO 65875
65414: LD_INT 2
65416: DOUBLE
65417: EQUAL
65418: IFTRUE 65422
65420: GO 65644
65422: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
65423: LD_ADDR_VAR 0 4
65427: PUSH
65428: LD_INT 35
65430: PUSH
65431: LD_INT 45
65433: PUSH
65434: LD_INT 46
65436: PUSH
65437: LD_INT 47
65439: PUSH
65440: LD_INT 82
65442: PUSH
65443: LD_INT 83
65445: PUSH
65446: LD_INT 84
65448: PUSH
65449: LD_INT 85
65451: PUSH
65452: LD_INT 87
65454: PUSH
65455: LD_INT 70
65457: PUSH
65458: LD_INT 1
65460: PUSH
65461: LD_INT 11
65463: PUSH
65464: LD_INT 3
65466: PUSH
65467: LD_INT 4
65469: PUSH
65470: LD_INT 5
65472: PUSH
65473: LD_INT 6
65475: PUSH
65476: LD_INT 15
65478: PUSH
65479: LD_INT 18
65481: PUSH
65482: LD_INT 7
65484: PUSH
65485: LD_INT 17
65487: PUSH
65488: LD_INT 8
65490: PUSH
65491: LD_INT 20
65493: PUSH
65494: LD_INT 21
65496: PUSH
65497: LD_INT 22
65499: PUSH
65500: LD_INT 72
65502: PUSH
65503: LD_INT 26
65505: PUSH
65506: LD_INT 69
65508: PUSH
65509: LD_INT 39
65511: PUSH
65512: LD_INT 40
65514: PUSH
65515: LD_INT 41
65517: PUSH
65518: LD_INT 42
65520: PUSH
65521: LD_INT 43
65523: PUSH
65524: LD_INT 48
65526: PUSH
65527: LD_INT 49
65529: PUSH
65530: LD_INT 50
65532: PUSH
65533: LD_INT 51
65535: PUSH
65536: LD_INT 52
65538: PUSH
65539: LD_INT 53
65541: PUSH
65542: LD_INT 54
65544: PUSH
65545: LD_INT 55
65547: PUSH
65548: LD_INT 56
65550: PUSH
65551: LD_INT 60
65553: PUSH
65554: LD_INT 61
65556: PUSH
65557: LD_INT 62
65559: PUSH
65560: LD_INT 66
65562: PUSH
65563: LD_INT 67
65565: PUSH
65566: LD_INT 68
65568: PUSH
65569: LD_INT 81
65571: PUSH
65572: LD_INT 82
65574: PUSH
65575: LD_INT 83
65577: PUSH
65578: LD_INT 84
65580: PUSH
65581: LD_INT 85
65583: PUSH
65584: LD_INT 87
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: LIST
65629: LIST
65630: LIST
65631: LIST
65632: LIST
65633: LIST
65634: LIST
65635: LIST
65636: LIST
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: ST_TO_ADDR
65642: GO 65875
65644: LD_INT 3
65646: DOUBLE
65647: EQUAL
65648: IFTRUE 65652
65650: GO 65874
65652: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
65653: LD_ADDR_VAR 0 4
65657: PUSH
65658: LD_INT 46
65660: PUSH
65661: LD_INT 47
65663: PUSH
65664: LD_INT 1
65666: PUSH
65667: LD_INT 2
65669: PUSH
65670: LD_INT 82
65672: PUSH
65673: LD_INT 83
65675: PUSH
65676: LD_INT 84
65678: PUSH
65679: LD_INT 85
65681: PUSH
65682: LD_INT 86
65684: PUSH
65685: LD_INT 11
65687: PUSH
65688: LD_INT 9
65690: PUSH
65691: LD_INT 20
65693: PUSH
65694: LD_INT 19
65696: PUSH
65697: LD_INT 21
65699: PUSH
65700: LD_INT 24
65702: PUSH
65703: LD_INT 22
65705: PUSH
65706: LD_INT 25
65708: PUSH
65709: LD_INT 28
65711: PUSH
65712: LD_INT 29
65714: PUSH
65715: LD_INT 30
65717: PUSH
65718: LD_INT 31
65720: PUSH
65721: LD_INT 37
65723: PUSH
65724: LD_INT 38
65726: PUSH
65727: LD_INT 32
65729: PUSH
65730: LD_INT 27
65732: PUSH
65733: LD_INT 33
65735: PUSH
65736: LD_INT 69
65738: PUSH
65739: LD_INT 39
65741: PUSH
65742: LD_INT 34
65744: PUSH
65745: LD_INT 40
65747: PUSH
65748: LD_INT 71
65750: PUSH
65751: LD_INT 23
65753: PUSH
65754: LD_INT 44
65756: PUSH
65757: LD_INT 48
65759: PUSH
65760: LD_INT 49
65762: PUSH
65763: LD_INT 50
65765: PUSH
65766: LD_INT 51
65768: PUSH
65769: LD_INT 52
65771: PUSH
65772: LD_INT 53
65774: PUSH
65775: LD_INT 54
65777: PUSH
65778: LD_INT 55
65780: PUSH
65781: LD_INT 56
65783: PUSH
65784: LD_INT 57
65786: PUSH
65787: LD_INT 58
65789: PUSH
65790: LD_INT 59
65792: PUSH
65793: LD_INT 63
65795: PUSH
65796: LD_INT 64
65798: PUSH
65799: LD_INT 65
65801: PUSH
65802: LD_INT 82
65804: PUSH
65805: LD_INT 83
65807: PUSH
65808: LD_INT 84
65810: PUSH
65811: LD_INT 85
65813: PUSH
65814: LD_INT 86
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: LIST
65830: LIST
65831: LIST
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: LIST
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: ST_TO_ADDR
65872: GO 65875
65874: POP
// if state > - 1 and state < 3 then
65875: LD_VAR 0 3
65879: PUSH
65880: LD_INT 1
65882: NEG
65883: GREATER
65884: PUSH
65885: LD_VAR 0 3
65889: PUSH
65890: LD_INT 3
65892: LESS
65893: AND
65894: IFFALSE 65951
// for i in result do
65896: LD_ADDR_VAR 0 5
65900: PUSH
65901: LD_VAR 0 4
65905: PUSH
65906: FOR_IN
65907: IFFALSE 65949
// if GetTech ( i , side ) <> state then
65909: LD_VAR 0 5
65913: PPUSH
65914: LD_VAR 0 1
65918: PPUSH
65919: CALL_OW 321
65923: PUSH
65924: LD_VAR 0 3
65928: NONEQUAL
65929: IFFALSE 65947
// result := result diff i ;
65931: LD_ADDR_VAR 0 4
65935: PUSH
65936: LD_VAR 0 4
65940: PUSH
65941: LD_VAR 0 5
65945: DIFF
65946: ST_TO_ADDR
65947: GO 65906
65949: POP
65950: POP
// end ;
65951: LD_VAR 0 4
65955: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65956: LD_INT 0
65958: PPUSH
65959: PPUSH
65960: PPUSH
// result := true ;
65961: LD_ADDR_VAR 0 3
65965: PUSH
65966: LD_INT 1
65968: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65969: LD_ADDR_VAR 0 5
65973: PUSH
65974: LD_VAR 0 2
65978: PPUSH
65979: CALL_OW 480
65983: ST_TO_ADDR
// if not tmp then
65984: LD_VAR 0 5
65988: NOT
65989: IFFALSE 65993
// exit ;
65991: GO 66042
// for i in tmp do
65993: LD_ADDR_VAR 0 4
65997: PUSH
65998: LD_VAR 0 5
66002: PUSH
66003: FOR_IN
66004: IFFALSE 66040
// if GetTech ( i , side ) <> state_researched then
66006: LD_VAR 0 4
66010: PPUSH
66011: LD_VAR 0 1
66015: PPUSH
66016: CALL_OW 321
66020: PUSH
66021: LD_INT 2
66023: NONEQUAL
66024: IFFALSE 66038
// begin result := false ;
66026: LD_ADDR_VAR 0 3
66030: PUSH
66031: LD_INT 0
66033: ST_TO_ADDR
// exit ;
66034: POP
66035: POP
66036: GO 66042
// end ;
66038: GO 66003
66040: POP
66041: POP
// end ;
66042: LD_VAR 0 3
66046: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66047: LD_INT 0
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66062: LD_VAR 0 1
66066: NOT
66067: PUSH
66068: LD_VAR 0 1
66072: PPUSH
66073: CALL_OW 257
66077: PUSH
66078: LD_INT 9
66080: NONEQUAL
66081: OR
66082: IFFALSE 66086
// exit ;
66084: GO 66659
// side := GetSide ( unit ) ;
66086: LD_ADDR_VAR 0 9
66090: PUSH
66091: LD_VAR 0 1
66095: PPUSH
66096: CALL_OW 255
66100: ST_TO_ADDR
// tech_space := tech_spacanom ;
66101: LD_ADDR_VAR 0 12
66105: PUSH
66106: LD_INT 29
66108: ST_TO_ADDR
// tech_time := tech_taurad ;
66109: LD_ADDR_VAR 0 13
66113: PUSH
66114: LD_INT 28
66116: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66117: LD_ADDR_VAR 0 11
66121: PUSH
66122: LD_VAR 0 1
66126: PPUSH
66127: CALL_OW 310
66131: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66132: LD_VAR 0 11
66136: PPUSH
66137: CALL_OW 247
66141: PUSH
66142: LD_INT 2
66144: EQUAL
66145: IFFALSE 66149
// exit ;
66147: GO 66659
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66149: LD_ADDR_VAR 0 8
66153: PUSH
66154: LD_INT 81
66156: PUSH
66157: LD_VAR 0 9
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 3
66168: PUSH
66169: LD_INT 21
66171: PUSH
66172: LD_INT 3
66174: PUSH
66175: EMPTY
66176: LIST
66177: LIST
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PPUSH
66187: CALL_OW 69
66191: ST_TO_ADDR
// if not tmp then
66192: LD_VAR 0 8
66196: NOT
66197: IFFALSE 66201
// exit ;
66199: GO 66659
// if in_unit then
66201: LD_VAR 0 11
66205: IFFALSE 66229
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66207: LD_ADDR_VAR 0 10
66211: PUSH
66212: LD_VAR 0 8
66216: PPUSH
66217: LD_VAR 0 11
66221: PPUSH
66222: CALL_OW 74
66226: ST_TO_ADDR
66227: GO 66249
// enemy := NearestUnitToUnit ( tmp , unit ) ;
66229: LD_ADDR_VAR 0 10
66233: PUSH
66234: LD_VAR 0 8
66238: PPUSH
66239: LD_VAR 0 1
66243: PPUSH
66244: CALL_OW 74
66248: ST_TO_ADDR
// if not enemy then
66249: LD_VAR 0 10
66253: NOT
66254: IFFALSE 66258
// exit ;
66256: GO 66659
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66258: LD_VAR 0 11
66262: PUSH
66263: LD_VAR 0 11
66267: PPUSH
66268: LD_VAR 0 10
66272: PPUSH
66273: CALL_OW 296
66277: PUSH
66278: LD_INT 13
66280: GREATER
66281: AND
66282: PUSH
66283: LD_VAR 0 1
66287: PPUSH
66288: LD_VAR 0 10
66292: PPUSH
66293: CALL_OW 296
66297: PUSH
66298: LD_INT 12
66300: GREATER
66301: OR
66302: IFFALSE 66306
// exit ;
66304: GO 66659
// missile := [ 1 ] ;
66306: LD_ADDR_VAR 0 14
66310: PUSH
66311: LD_INT 1
66313: PUSH
66314: EMPTY
66315: LIST
66316: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66317: LD_VAR 0 9
66321: PPUSH
66322: LD_VAR 0 12
66326: PPUSH
66327: CALL_OW 325
66331: IFFALSE 66360
// missile := Insert ( missile , missile + 1 , 2 ) ;
66333: LD_ADDR_VAR 0 14
66337: PUSH
66338: LD_VAR 0 14
66342: PPUSH
66343: LD_VAR 0 14
66347: PUSH
66348: LD_INT 1
66350: PLUS
66351: PPUSH
66352: LD_INT 2
66354: PPUSH
66355: CALL_OW 2
66359: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66360: LD_VAR 0 9
66364: PPUSH
66365: LD_VAR 0 13
66369: PPUSH
66370: CALL_OW 325
66374: PUSH
66375: LD_VAR 0 10
66379: PPUSH
66380: CALL_OW 255
66384: PPUSH
66385: LD_VAR 0 13
66389: PPUSH
66390: CALL_OW 325
66394: NOT
66395: AND
66396: IFFALSE 66425
// missile := Insert ( missile , missile + 1 , 3 ) ;
66398: LD_ADDR_VAR 0 14
66402: PUSH
66403: LD_VAR 0 14
66407: PPUSH
66408: LD_VAR 0 14
66412: PUSH
66413: LD_INT 1
66415: PLUS
66416: PPUSH
66417: LD_INT 3
66419: PPUSH
66420: CALL_OW 2
66424: ST_TO_ADDR
// if missile < 2 then
66425: LD_VAR 0 14
66429: PUSH
66430: LD_INT 2
66432: LESS
66433: IFFALSE 66437
// exit ;
66435: GO 66659
// x := GetX ( enemy ) ;
66437: LD_ADDR_VAR 0 4
66441: PUSH
66442: LD_VAR 0 10
66446: PPUSH
66447: CALL_OW 250
66451: ST_TO_ADDR
// y := GetY ( enemy ) ;
66452: LD_ADDR_VAR 0 5
66456: PUSH
66457: LD_VAR 0 10
66461: PPUSH
66462: CALL_OW 251
66466: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66467: LD_ADDR_VAR 0 6
66471: PUSH
66472: LD_VAR 0 4
66476: PUSH
66477: LD_INT 1
66479: NEG
66480: PPUSH
66481: LD_INT 1
66483: PPUSH
66484: CALL_OW 12
66488: PLUS
66489: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66490: LD_ADDR_VAR 0 7
66494: PUSH
66495: LD_VAR 0 5
66499: PUSH
66500: LD_INT 1
66502: NEG
66503: PPUSH
66504: LD_INT 1
66506: PPUSH
66507: CALL_OW 12
66511: PLUS
66512: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66513: LD_VAR 0 6
66517: PPUSH
66518: LD_VAR 0 7
66522: PPUSH
66523: CALL_OW 488
66527: NOT
66528: IFFALSE 66550
// begin _x := x ;
66530: LD_ADDR_VAR 0 6
66534: PUSH
66535: LD_VAR 0 4
66539: ST_TO_ADDR
// _y := y ;
66540: LD_ADDR_VAR 0 7
66544: PUSH
66545: LD_VAR 0 5
66549: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66550: LD_ADDR_VAR 0 3
66554: PUSH
66555: LD_INT 1
66557: PPUSH
66558: LD_VAR 0 14
66562: PPUSH
66563: CALL_OW 12
66567: ST_TO_ADDR
// case i of 1 :
66568: LD_VAR 0 3
66572: PUSH
66573: LD_INT 1
66575: DOUBLE
66576: EQUAL
66577: IFTRUE 66581
66579: GO 66598
66581: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66582: LD_VAR 0 1
66586: PPUSH
66587: LD_VAR 0 10
66591: PPUSH
66592: CALL_OW 115
66596: GO 66659
66598: LD_INT 2
66600: DOUBLE
66601: EQUAL
66602: IFTRUE 66606
66604: GO 66628
66606: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66607: LD_VAR 0 1
66611: PPUSH
66612: LD_VAR 0 6
66616: PPUSH
66617: LD_VAR 0 7
66621: PPUSH
66622: CALL_OW 153
66626: GO 66659
66628: LD_INT 3
66630: DOUBLE
66631: EQUAL
66632: IFTRUE 66636
66634: GO 66658
66636: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66637: LD_VAR 0 1
66641: PPUSH
66642: LD_VAR 0 6
66646: PPUSH
66647: LD_VAR 0 7
66651: PPUSH
66652: CALL_OW 154
66656: GO 66659
66658: POP
// end ;
66659: LD_VAR 0 2
66663: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66664: LD_INT 0
66666: PPUSH
66667: PPUSH
66668: PPUSH
66669: PPUSH
66670: PPUSH
66671: PPUSH
// if not unit or not building then
66672: LD_VAR 0 1
66676: NOT
66677: PUSH
66678: LD_VAR 0 2
66682: NOT
66683: OR
66684: IFFALSE 66688
// exit ;
66686: GO 66846
// x := GetX ( building ) ;
66688: LD_ADDR_VAR 0 5
66692: PUSH
66693: LD_VAR 0 2
66697: PPUSH
66698: CALL_OW 250
66702: ST_TO_ADDR
// y := GetY ( building ) ;
66703: LD_ADDR_VAR 0 6
66707: PUSH
66708: LD_VAR 0 2
66712: PPUSH
66713: CALL_OW 251
66717: ST_TO_ADDR
// for i = 0 to 5 do
66718: LD_ADDR_VAR 0 4
66722: PUSH
66723: DOUBLE
66724: LD_INT 0
66726: DEC
66727: ST_TO_ADDR
66728: LD_INT 5
66730: PUSH
66731: FOR_TO
66732: IFFALSE 66844
// begin _x := ShiftX ( x , i , 3 ) ;
66734: LD_ADDR_VAR 0 7
66738: PUSH
66739: LD_VAR 0 5
66743: PPUSH
66744: LD_VAR 0 4
66748: PPUSH
66749: LD_INT 3
66751: PPUSH
66752: CALL_OW 272
66756: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66757: LD_ADDR_VAR 0 8
66761: PUSH
66762: LD_VAR 0 6
66766: PPUSH
66767: LD_VAR 0 4
66771: PPUSH
66772: LD_INT 3
66774: PPUSH
66775: CALL_OW 273
66779: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66780: LD_VAR 0 7
66784: PPUSH
66785: LD_VAR 0 8
66789: PPUSH
66790: CALL_OW 488
66794: NOT
66795: IFFALSE 66799
// continue ;
66797: GO 66731
// if HexInfo ( _x , _y ) = 0 then
66799: LD_VAR 0 7
66803: PPUSH
66804: LD_VAR 0 8
66808: PPUSH
66809: CALL_OW 428
66813: PUSH
66814: LD_INT 0
66816: EQUAL
66817: IFFALSE 66842
// begin ComMoveXY ( unit , _x , _y ) ;
66819: LD_VAR 0 1
66823: PPUSH
66824: LD_VAR 0 7
66828: PPUSH
66829: LD_VAR 0 8
66833: PPUSH
66834: CALL_OW 111
// exit ;
66838: POP
66839: POP
66840: GO 66846
// end ; end ;
66842: GO 66731
66844: POP
66845: POP
// end ;
66846: LD_VAR 0 3
66850: RET
// export function ScanBase ( side , base_area ) ; begin
66851: LD_INT 0
66853: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66854: LD_ADDR_VAR 0 3
66858: PUSH
66859: LD_VAR 0 2
66863: PPUSH
66864: LD_INT 81
66866: PUSH
66867: LD_VAR 0 1
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PPUSH
66876: CALL_OW 70
66880: ST_TO_ADDR
// end ;
66881: LD_VAR 0 3
66885: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66886: LD_INT 0
66888: PPUSH
66889: PPUSH
66890: PPUSH
66891: PPUSH
// result := false ;
66892: LD_ADDR_VAR 0 2
66896: PUSH
66897: LD_INT 0
66899: ST_TO_ADDR
// side := GetSide ( unit ) ;
66900: LD_ADDR_VAR 0 3
66904: PUSH
66905: LD_VAR 0 1
66909: PPUSH
66910: CALL_OW 255
66914: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66915: LD_ADDR_VAR 0 4
66919: PUSH
66920: LD_VAR 0 1
66924: PPUSH
66925: CALL_OW 248
66929: ST_TO_ADDR
// case nat of 1 :
66930: LD_VAR 0 4
66934: PUSH
66935: LD_INT 1
66937: DOUBLE
66938: EQUAL
66939: IFTRUE 66943
66941: GO 66954
66943: POP
// tech := tech_lassight ; 2 :
66944: LD_ADDR_VAR 0 5
66948: PUSH
66949: LD_INT 12
66951: ST_TO_ADDR
66952: GO 66993
66954: LD_INT 2
66956: DOUBLE
66957: EQUAL
66958: IFTRUE 66962
66960: GO 66973
66962: POP
// tech := tech_mortar ; 3 :
66963: LD_ADDR_VAR 0 5
66967: PUSH
66968: LD_INT 41
66970: ST_TO_ADDR
66971: GO 66993
66973: LD_INT 3
66975: DOUBLE
66976: EQUAL
66977: IFTRUE 66981
66979: GO 66992
66981: POP
// tech := tech_bazooka ; end ;
66982: LD_ADDR_VAR 0 5
66986: PUSH
66987: LD_INT 44
66989: ST_TO_ADDR
66990: GO 66993
66992: POP
// if Researched ( side , tech ) then
66993: LD_VAR 0 3
66997: PPUSH
66998: LD_VAR 0 5
67002: PPUSH
67003: CALL_OW 325
67007: IFFALSE 67034
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67009: LD_ADDR_VAR 0 2
67013: PUSH
67014: LD_INT 5
67016: PUSH
67017: LD_INT 8
67019: PUSH
67020: LD_INT 9
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: LIST
67027: PUSH
67028: LD_VAR 0 4
67032: ARRAY
67033: ST_TO_ADDR
// end ;
67034: LD_VAR 0 2
67038: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67039: LD_INT 0
67041: PPUSH
67042: PPUSH
67043: PPUSH
// if not mines then
67044: LD_VAR 0 2
67048: NOT
67049: IFFALSE 67053
// exit ;
67051: GO 67197
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67053: LD_ADDR_VAR 0 5
67057: PUSH
67058: LD_INT 81
67060: PUSH
67061: LD_VAR 0 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 3
67072: PUSH
67073: LD_INT 21
67075: PUSH
67076: LD_INT 3
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: EMPTY
67084: LIST
67085: LIST
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PPUSH
67091: CALL_OW 69
67095: ST_TO_ADDR
// for i in mines do
67096: LD_ADDR_VAR 0 4
67100: PUSH
67101: LD_VAR 0 2
67105: PUSH
67106: FOR_IN
67107: IFFALSE 67195
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67109: LD_VAR 0 4
67113: PUSH
67114: LD_INT 1
67116: ARRAY
67117: PPUSH
67118: LD_VAR 0 4
67122: PUSH
67123: LD_INT 2
67125: ARRAY
67126: PPUSH
67127: CALL_OW 458
67131: NOT
67132: IFFALSE 67136
// continue ;
67134: GO 67106
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67136: LD_VAR 0 4
67140: PUSH
67141: LD_INT 1
67143: ARRAY
67144: PPUSH
67145: LD_VAR 0 4
67149: PUSH
67150: LD_INT 2
67152: ARRAY
67153: PPUSH
67154: CALL_OW 428
67158: PUSH
67159: LD_VAR 0 5
67163: IN
67164: IFFALSE 67193
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67166: LD_VAR 0 4
67170: PUSH
67171: LD_INT 1
67173: ARRAY
67174: PPUSH
67175: LD_VAR 0 4
67179: PUSH
67180: LD_INT 2
67182: ARRAY
67183: PPUSH
67184: LD_VAR 0 1
67188: PPUSH
67189: CALL_OW 456
// end ;
67193: GO 67106
67195: POP
67196: POP
// end ;
67197: LD_VAR 0 3
67201: RET
// export function Count ( array ) ; var i ; begin
67202: LD_INT 0
67204: PPUSH
67205: PPUSH
// result := 0 ;
67206: LD_ADDR_VAR 0 2
67210: PUSH
67211: LD_INT 0
67213: ST_TO_ADDR
// for i in array do
67214: LD_ADDR_VAR 0 3
67218: PUSH
67219: LD_VAR 0 1
67223: PUSH
67224: FOR_IN
67225: IFFALSE 67249
// if i then
67227: LD_VAR 0 3
67231: IFFALSE 67247
// result := result + 1 ;
67233: LD_ADDR_VAR 0 2
67237: PUSH
67238: LD_VAR 0 2
67242: PUSH
67243: LD_INT 1
67245: PLUS
67246: ST_TO_ADDR
67247: GO 67224
67249: POP
67250: POP
// end ;
67251: LD_VAR 0 2
67255: RET
// export function IsEmpty ( building ) ; begin
67256: LD_INT 0
67258: PPUSH
// if not building then
67259: LD_VAR 0 1
67263: NOT
67264: IFFALSE 67268
// exit ;
67266: GO 67311
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
67268: LD_ADDR_VAR 0 2
67272: PUSH
67273: LD_VAR 0 1
67277: PUSH
67278: LD_INT 22
67280: PUSH
67281: LD_VAR 0 1
67285: PPUSH
67286: CALL_OW 255
67290: PUSH
67291: EMPTY
67292: LIST
67293: LIST
67294: PUSH
67295: LD_INT 58
67297: PUSH
67298: EMPTY
67299: LIST
67300: PUSH
67301: EMPTY
67302: LIST
67303: LIST
67304: PPUSH
67305: CALL_OW 69
67309: IN
67310: ST_TO_ADDR
// end ;
67311: LD_VAR 0 2
67315: RET
// export function IsNotFull ( building ) ; begin
67316: LD_INT 0
67318: PPUSH
// if not building then
67319: LD_VAR 0 1
67323: NOT
67324: IFFALSE 67328
// exit ;
67326: GO 67347
// result := UnitsInside ( building ) < 6 ;
67328: LD_ADDR_VAR 0 2
67332: PUSH
67333: LD_VAR 0 1
67337: PPUSH
67338: CALL_OW 313
67342: PUSH
67343: LD_INT 6
67345: LESS
67346: ST_TO_ADDR
// end ;
67347: LD_VAR 0 2
67351: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67352: LD_INT 0
67354: PPUSH
67355: PPUSH
67356: PPUSH
67357: PPUSH
// tmp := [ ] ;
67358: LD_ADDR_VAR 0 3
67362: PUSH
67363: EMPTY
67364: ST_TO_ADDR
// list := [ ] ;
67365: LD_ADDR_VAR 0 5
67369: PUSH
67370: EMPTY
67371: ST_TO_ADDR
// for i = 16 to 25 do
67372: LD_ADDR_VAR 0 4
67376: PUSH
67377: DOUBLE
67378: LD_INT 16
67380: DEC
67381: ST_TO_ADDR
67382: LD_INT 25
67384: PUSH
67385: FOR_TO
67386: IFFALSE 67459
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67388: LD_ADDR_VAR 0 3
67392: PUSH
67393: LD_VAR 0 3
67397: PUSH
67398: LD_INT 22
67400: PUSH
67401: LD_VAR 0 1
67405: PPUSH
67406: CALL_OW 255
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 91
67417: PUSH
67418: LD_VAR 0 1
67422: PUSH
67423: LD_INT 6
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: LIST
67430: PUSH
67431: LD_INT 30
67433: PUSH
67434: LD_VAR 0 4
67438: PUSH
67439: EMPTY
67440: LIST
67441: LIST
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: LIST
67447: PUSH
67448: EMPTY
67449: LIST
67450: PPUSH
67451: CALL_OW 69
67455: ADD
67456: ST_TO_ADDR
67457: GO 67385
67459: POP
67460: POP
// for i = 1 to tmp do
67461: LD_ADDR_VAR 0 4
67465: PUSH
67466: DOUBLE
67467: LD_INT 1
67469: DEC
67470: ST_TO_ADDR
67471: LD_VAR 0 3
67475: PUSH
67476: FOR_TO
67477: IFFALSE 67565
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67479: LD_ADDR_VAR 0 5
67483: PUSH
67484: LD_VAR 0 5
67488: PUSH
67489: LD_VAR 0 3
67493: PUSH
67494: LD_VAR 0 4
67498: ARRAY
67499: PPUSH
67500: CALL_OW 266
67504: PUSH
67505: LD_VAR 0 3
67509: PUSH
67510: LD_VAR 0 4
67514: ARRAY
67515: PPUSH
67516: CALL_OW 250
67520: PUSH
67521: LD_VAR 0 3
67525: PUSH
67526: LD_VAR 0 4
67530: ARRAY
67531: PPUSH
67532: CALL_OW 251
67536: PUSH
67537: LD_VAR 0 3
67541: PUSH
67542: LD_VAR 0 4
67546: ARRAY
67547: PPUSH
67548: CALL_OW 254
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: PUSH
67559: EMPTY
67560: LIST
67561: ADD
67562: ST_TO_ADDR
67563: GO 67476
67565: POP
67566: POP
// result := list ;
67567: LD_ADDR_VAR 0 2
67571: PUSH
67572: LD_VAR 0 5
67576: ST_TO_ADDR
// end ;
67577: LD_VAR 0 2
67581: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67582: LD_INT 0
67584: PPUSH
67585: PPUSH
67586: PPUSH
67587: PPUSH
67588: PPUSH
67589: PPUSH
67590: PPUSH
// if not factory then
67591: LD_VAR 0 1
67595: NOT
67596: IFFALSE 67600
// exit ;
67598: GO 68193
// if control = control_apeman then
67600: LD_VAR 0 4
67604: PUSH
67605: LD_INT 5
67607: EQUAL
67608: IFFALSE 67717
// begin tmp := UnitsInside ( factory ) ;
67610: LD_ADDR_VAR 0 8
67614: PUSH
67615: LD_VAR 0 1
67619: PPUSH
67620: CALL_OW 313
67624: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67625: LD_VAR 0 8
67629: PPUSH
67630: LD_INT 25
67632: PUSH
67633: LD_INT 12
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PPUSH
67640: CALL_OW 72
67644: NOT
67645: IFFALSE 67655
// control := control_manual ;
67647: LD_ADDR_VAR 0 4
67651: PUSH
67652: LD_INT 1
67654: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67655: LD_ADDR_VAR 0 8
67659: PUSH
67660: LD_VAR 0 1
67664: PPUSH
67665: CALL 67352 0 1
67669: ST_TO_ADDR
// if tmp then
67670: LD_VAR 0 8
67674: IFFALSE 67717
// begin for i in tmp do
67676: LD_ADDR_VAR 0 7
67680: PUSH
67681: LD_VAR 0 8
67685: PUSH
67686: FOR_IN
67687: IFFALSE 67715
// if i [ 1 ] = b_ext_radio then
67689: LD_VAR 0 7
67693: PUSH
67694: LD_INT 1
67696: ARRAY
67697: PUSH
67698: LD_INT 22
67700: EQUAL
67701: IFFALSE 67713
// begin control := control_remote ;
67703: LD_ADDR_VAR 0 4
67707: PUSH
67708: LD_INT 2
67710: ST_TO_ADDR
// break ;
67711: GO 67715
// end ;
67713: GO 67686
67715: POP
67716: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67717: LD_VAR 0 1
67721: PPUSH
67722: LD_VAR 0 2
67726: PPUSH
67727: LD_VAR 0 3
67731: PPUSH
67732: LD_VAR 0 4
67736: PPUSH
67737: LD_VAR 0 5
67741: PPUSH
67742: CALL_OW 448
67746: IFFALSE 67781
// begin result := [ chassis , engine , control , weapon ] ;
67748: LD_ADDR_VAR 0 6
67752: PUSH
67753: LD_VAR 0 2
67757: PUSH
67758: LD_VAR 0 3
67762: PUSH
67763: LD_VAR 0 4
67767: PUSH
67768: LD_VAR 0 5
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: ST_TO_ADDR
// exit ;
67779: GO 68193
// end ; _chassis := AvailableChassisList ( factory ) ;
67781: LD_ADDR_VAR 0 9
67785: PUSH
67786: LD_VAR 0 1
67790: PPUSH
67791: CALL_OW 475
67795: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67796: LD_ADDR_VAR 0 11
67800: PUSH
67801: LD_VAR 0 1
67805: PPUSH
67806: CALL_OW 476
67810: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67811: LD_ADDR_VAR 0 12
67815: PUSH
67816: LD_VAR 0 1
67820: PPUSH
67821: CALL_OW 477
67825: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67826: LD_ADDR_VAR 0 10
67830: PUSH
67831: LD_VAR 0 1
67835: PPUSH
67836: CALL_OW 478
67840: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
67841: LD_VAR 0 9
67845: NOT
67846: PUSH
67847: LD_VAR 0 11
67851: NOT
67852: OR
67853: PUSH
67854: LD_VAR 0 12
67858: NOT
67859: OR
67860: PUSH
67861: LD_VAR 0 10
67865: NOT
67866: OR
67867: IFFALSE 67902
// begin result := [ chassis , engine , control , weapon ] ;
67869: LD_ADDR_VAR 0 6
67873: PUSH
67874: LD_VAR 0 2
67878: PUSH
67879: LD_VAR 0 3
67883: PUSH
67884: LD_VAR 0 4
67888: PUSH
67889: LD_VAR 0 5
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: ST_TO_ADDR
// exit ;
67900: GO 68193
// end ; if not chassis in _chassis then
67902: LD_VAR 0 2
67906: PUSH
67907: LD_VAR 0 9
67911: IN
67912: NOT
67913: IFFALSE 67939
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67915: LD_ADDR_VAR 0 2
67919: PUSH
67920: LD_VAR 0 9
67924: PUSH
67925: LD_INT 1
67927: PPUSH
67928: LD_VAR 0 9
67932: PPUSH
67933: CALL_OW 12
67937: ARRAY
67938: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67939: LD_VAR 0 2
67943: PPUSH
67944: LD_VAR 0 3
67948: PPUSH
67949: CALL 68198 0 2
67953: NOT
67954: IFFALSE 68013
// repeat engine := _engine [ 1 ] ;
67956: LD_ADDR_VAR 0 3
67960: PUSH
67961: LD_VAR 0 11
67965: PUSH
67966: LD_INT 1
67968: ARRAY
67969: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67970: LD_ADDR_VAR 0 11
67974: PUSH
67975: LD_VAR 0 11
67979: PPUSH
67980: LD_INT 1
67982: PPUSH
67983: CALL_OW 3
67987: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67988: LD_VAR 0 2
67992: PPUSH
67993: LD_VAR 0 3
67997: PPUSH
67998: CALL 68198 0 2
68002: PUSH
68003: LD_VAR 0 11
68007: PUSH
68008: EMPTY
68009: EQUAL
68010: OR
68011: IFFALSE 67956
// if not control in _control then
68013: LD_VAR 0 4
68017: PUSH
68018: LD_VAR 0 12
68022: IN
68023: NOT
68024: IFFALSE 68050
// control := _control [ rand ( 1 , _control ) ] ;
68026: LD_ADDR_VAR 0 4
68030: PUSH
68031: LD_VAR 0 12
68035: PUSH
68036: LD_INT 1
68038: PPUSH
68039: LD_VAR 0 12
68043: PPUSH
68044: CALL_OW 12
68048: ARRAY
68049: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68050: LD_VAR 0 2
68054: PPUSH
68055: LD_VAR 0 5
68059: PPUSH
68060: CALL 68418 0 2
68064: NOT
68065: IFFALSE 68124
// repeat weapon := _weapon [ 1 ] ;
68067: LD_ADDR_VAR 0 5
68071: PUSH
68072: LD_VAR 0 10
68076: PUSH
68077: LD_INT 1
68079: ARRAY
68080: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68081: LD_ADDR_VAR 0 10
68085: PUSH
68086: LD_VAR 0 10
68090: PPUSH
68091: LD_INT 1
68093: PPUSH
68094: CALL_OW 3
68098: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68099: LD_VAR 0 2
68103: PPUSH
68104: LD_VAR 0 5
68108: PPUSH
68109: CALL 68418 0 2
68113: PUSH
68114: LD_VAR 0 10
68118: PUSH
68119: EMPTY
68120: EQUAL
68121: OR
68122: IFFALSE 68067
// result := [ ] ;
68124: LD_ADDR_VAR 0 6
68128: PUSH
68129: EMPTY
68130: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68131: LD_VAR 0 1
68135: PPUSH
68136: LD_VAR 0 2
68140: PPUSH
68141: LD_VAR 0 3
68145: PPUSH
68146: LD_VAR 0 4
68150: PPUSH
68151: LD_VAR 0 5
68155: PPUSH
68156: CALL_OW 448
68160: IFFALSE 68193
// result := [ chassis , engine , control , weapon ] ;
68162: LD_ADDR_VAR 0 6
68166: PUSH
68167: LD_VAR 0 2
68171: PUSH
68172: LD_VAR 0 3
68176: PUSH
68177: LD_VAR 0 4
68181: PUSH
68182: LD_VAR 0 5
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: LIST
68191: LIST
68192: ST_TO_ADDR
// end ;
68193: LD_VAR 0 6
68197: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68198: LD_INT 0
68200: PPUSH
// if not chassis or not engine then
68201: LD_VAR 0 1
68205: NOT
68206: PUSH
68207: LD_VAR 0 2
68211: NOT
68212: OR
68213: IFFALSE 68217
// exit ;
68215: GO 68413
// case engine of engine_solar :
68217: LD_VAR 0 2
68221: PUSH
68222: LD_INT 2
68224: DOUBLE
68225: EQUAL
68226: IFTRUE 68230
68228: GO 68268
68230: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68231: LD_ADDR_VAR 0 3
68235: PUSH
68236: LD_INT 11
68238: PUSH
68239: LD_INT 12
68241: PUSH
68242: LD_INT 13
68244: PUSH
68245: LD_INT 14
68247: PUSH
68248: LD_INT 1
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: LD_INT 3
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: LIST
68261: LIST
68262: LIST
68263: LIST
68264: LIST
68265: ST_TO_ADDR
68266: GO 68397
68268: LD_INT 1
68270: DOUBLE
68271: EQUAL
68272: IFTRUE 68276
68274: GO 68338
68276: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
68277: LD_ADDR_VAR 0 3
68281: PUSH
68282: LD_INT 11
68284: PUSH
68285: LD_INT 12
68287: PUSH
68288: LD_INT 13
68290: PUSH
68291: LD_INT 14
68293: PUSH
68294: LD_INT 1
68296: PUSH
68297: LD_INT 2
68299: PUSH
68300: LD_INT 3
68302: PUSH
68303: LD_INT 4
68305: PUSH
68306: LD_INT 5
68308: PUSH
68309: LD_INT 21
68311: PUSH
68312: LD_INT 23
68314: PUSH
68315: LD_INT 22
68317: PUSH
68318: LD_INT 24
68320: PUSH
68321: EMPTY
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: LIST
68335: ST_TO_ADDR
68336: GO 68397
68338: LD_INT 3
68340: DOUBLE
68341: EQUAL
68342: IFTRUE 68346
68344: GO 68396
68346: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
68347: LD_ADDR_VAR 0 3
68351: PUSH
68352: LD_INT 13
68354: PUSH
68355: LD_INT 14
68357: PUSH
68358: LD_INT 2
68360: PUSH
68361: LD_INT 3
68363: PUSH
68364: LD_INT 4
68366: PUSH
68367: LD_INT 5
68369: PUSH
68370: LD_INT 21
68372: PUSH
68373: LD_INT 22
68375: PUSH
68376: LD_INT 23
68378: PUSH
68379: LD_INT 24
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: ST_TO_ADDR
68394: GO 68397
68396: POP
// result := ( chassis in result ) ;
68397: LD_ADDR_VAR 0 3
68401: PUSH
68402: LD_VAR 0 1
68406: PUSH
68407: LD_VAR 0 3
68411: IN
68412: ST_TO_ADDR
// end ;
68413: LD_VAR 0 3
68417: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68418: LD_INT 0
68420: PPUSH
// if not chassis or not weapon then
68421: LD_VAR 0 1
68425: NOT
68426: PUSH
68427: LD_VAR 0 2
68431: NOT
68432: OR
68433: IFFALSE 68437
// exit ;
68435: GO 69463
// case weapon of us_machine_gun :
68437: LD_VAR 0 2
68441: PUSH
68442: LD_INT 2
68444: DOUBLE
68445: EQUAL
68446: IFTRUE 68450
68448: GO 68480
68450: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68451: LD_ADDR_VAR 0 3
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: LD_INT 2
68461: PUSH
68462: LD_INT 3
68464: PUSH
68465: LD_INT 4
68467: PUSH
68468: LD_INT 5
68470: PUSH
68471: EMPTY
68472: LIST
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: ST_TO_ADDR
68478: GO 69447
68480: LD_INT 3
68482: DOUBLE
68483: EQUAL
68484: IFTRUE 68488
68486: GO 68518
68488: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68489: LD_ADDR_VAR 0 3
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 2
68499: PUSH
68500: LD_INT 3
68502: PUSH
68503: LD_INT 4
68505: PUSH
68506: LD_INT 5
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: LIST
68513: LIST
68514: LIST
68515: ST_TO_ADDR
68516: GO 69447
68518: LD_INT 11
68520: DOUBLE
68521: EQUAL
68522: IFTRUE 68526
68524: GO 68556
68526: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68527: LD_ADDR_VAR 0 3
68531: PUSH
68532: LD_INT 1
68534: PUSH
68535: LD_INT 2
68537: PUSH
68538: LD_INT 3
68540: PUSH
68541: LD_INT 4
68543: PUSH
68544: LD_INT 5
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: ST_TO_ADDR
68554: GO 69447
68556: LD_INT 4
68558: DOUBLE
68559: EQUAL
68560: IFTRUE 68564
68562: GO 68590
68564: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68565: LD_ADDR_VAR 0 3
68569: PUSH
68570: LD_INT 2
68572: PUSH
68573: LD_INT 3
68575: PUSH
68576: LD_INT 4
68578: PUSH
68579: LD_INT 5
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: ST_TO_ADDR
68588: GO 69447
68590: LD_INT 5
68592: DOUBLE
68593: EQUAL
68594: IFTRUE 68598
68596: GO 68624
68598: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68599: LD_ADDR_VAR 0 3
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: LD_INT 3
68609: PUSH
68610: LD_INT 4
68612: PUSH
68613: LD_INT 5
68615: PUSH
68616: EMPTY
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: ST_TO_ADDR
68622: GO 69447
68624: LD_INT 9
68626: DOUBLE
68627: EQUAL
68628: IFTRUE 68632
68630: GO 68658
68632: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68633: LD_ADDR_VAR 0 3
68637: PUSH
68638: LD_INT 2
68640: PUSH
68641: LD_INT 3
68643: PUSH
68644: LD_INT 4
68646: PUSH
68647: LD_INT 5
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: LIST
68654: LIST
68655: ST_TO_ADDR
68656: GO 69447
68658: LD_INT 7
68660: DOUBLE
68661: EQUAL
68662: IFTRUE 68666
68664: GO 68692
68666: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68667: LD_ADDR_VAR 0 3
68671: PUSH
68672: LD_INT 2
68674: PUSH
68675: LD_INT 3
68677: PUSH
68678: LD_INT 4
68680: PUSH
68681: LD_INT 5
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: LIST
68688: LIST
68689: ST_TO_ADDR
68690: GO 69447
68692: LD_INT 12
68694: DOUBLE
68695: EQUAL
68696: IFTRUE 68700
68698: GO 68726
68700: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68701: LD_ADDR_VAR 0 3
68705: PUSH
68706: LD_INT 2
68708: PUSH
68709: LD_INT 3
68711: PUSH
68712: LD_INT 4
68714: PUSH
68715: LD_INT 5
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: LIST
68722: LIST
68723: ST_TO_ADDR
68724: GO 69447
68726: LD_INT 13
68728: DOUBLE
68729: EQUAL
68730: IFTRUE 68734
68732: GO 68760
68734: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68735: LD_ADDR_VAR 0 3
68739: PUSH
68740: LD_INT 2
68742: PUSH
68743: LD_INT 3
68745: PUSH
68746: LD_INT 4
68748: PUSH
68749: LD_INT 5
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: ST_TO_ADDR
68758: GO 69447
68760: LD_INT 14
68762: DOUBLE
68763: EQUAL
68764: IFTRUE 68768
68766: GO 68786
68768: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68769: LD_ADDR_VAR 0 3
68773: PUSH
68774: LD_INT 4
68776: PUSH
68777: LD_INT 5
68779: PUSH
68780: EMPTY
68781: LIST
68782: LIST
68783: ST_TO_ADDR
68784: GO 69447
68786: LD_INT 6
68788: DOUBLE
68789: EQUAL
68790: IFTRUE 68794
68792: GO 68812
68794: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68795: LD_ADDR_VAR 0 3
68799: PUSH
68800: LD_INT 4
68802: PUSH
68803: LD_INT 5
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: ST_TO_ADDR
68810: GO 69447
68812: LD_INT 10
68814: DOUBLE
68815: EQUAL
68816: IFTRUE 68820
68818: GO 68838
68820: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68821: LD_ADDR_VAR 0 3
68825: PUSH
68826: LD_INT 4
68828: PUSH
68829: LD_INT 5
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: ST_TO_ADDR
68836: GO 69447
68838: LD_INT 22
68840: DOUBLE
68841: EQUAL
68842: IFTRUE 68846
68844: GO 68872
68846: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68847: LD_ADDR_VAR 0 3
68851: PUSH
68852: LD_INT 11
68854: PUSH
68855: LD_INT 12
68857: PUSH
68858: LD_INT 13
68860: PUSH
68861: LD_INT 14
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: ST_TO_ADDR
68870: GO 69447
68872: LD_INT 23
68874: DOUBLE
68875: EQUAL
68876: IFTRUE 68880
68878: GO 68906
68880: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68881: LD_ADDR_VAR 0 3
68885: PUSH
68886: LD_INT 11
68888: PUSH
68889: LD_INT 12
68891: PUSH
68892: LD_INT 13
68894: PUSH
68895: LD_INT 14
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: ST_TO_ADDR
68904: GO 69447
68906: LD_INT 24
68908: DOUBLE
68909: EQUAL
68910: IFTRUE 68914
68912: GO 68940
68914: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68915: LD_ADDR_VAR 0 3
68919: PUSH
68920: LD_INT 11
68922: PUSH
68923: LD_INT 12
68925: PUSH
68926: LD_INT 13
68928: PUSH
68929: LD_INT 14
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: ST_TO_ADDR
68938: GO 69447
68940: LD_INT 30
68942: DOUBLE
68943: EQUAL
68944: IFTRUE 68948
68946: GO 68974
68948: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68949: LD_ADDR_VAR 0 3
68953: PUSH
68954: LD_INT 11
68956: PUSH
68957: LD_INT 12
68959: PUSH
68960: LD_INT 13
68962: PUSH
68963: LD_INT 14
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: LIST
68970: LIST
68971: ST_TO_ADDR
68972: GO 69447
68974: LD_INT 25
68976: DOUBLE
68977: EQUAL
68978: IFTRUE 68982
68980: GO 69000
68982: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68983: LD_ADDR_VAR 0 3
68987: PUSH
68988: LD_INT 13
68990: PUSH
68991: LD_INT 14
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: ST_TO_ADDR
68998: GO 69447
69000: LD_INT 27
69002: DOUBLE
69003: EQUAL
69004: IFTRUE 69008
69006: GO 69026
69008: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69009: LD_ADDR_VAR 0 3
69013: PUSH
69014: LD_INT 13
69016: PUSH
69017: LD_INT 14
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: ST_TO_ADDR
69024: GO 69447
69026: LD_INT 28
69028: DOUBLE
69029: EQUAL
69030: IFTRUE 69034
69032: GO 69052
69034: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69035: LD_ADDR_VAR 0 3
69039: PUSH
69040: LD_INT 13
69042: PUSH
69043: LD_INT 14
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: ST_TO_ADDR
69050: GO 69447
69052: LD_INT 29
69054: DOUBLE
69055: EQUAL
69056: IFTRUE 69060
69058: GO 69078
69060: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69061: LD_ADDR_VAR 0 3
69065: PUSH
69066: LD_INT 13
69068: PUSH
69069: LD_INT 14
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: ST_TO_ADDR
69076: GO 69447
69078: LD_INT 31
69080: DOUBLE
69081: EQUAL
69082: IFTRUE 69086
69084: GO 69104
69086: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69087: LD_ADDR_VAR 0 3
69091: PUSH
69092: LD_INT 13
69094: PUSH
69095: LD_INT 14
69097: PUSH
69098: EMPTY
69099: LIST
69100: LIST
69101: ST_TO_ADDR
69102: GO 69447
69104: LD_INT 26
69106: DOUBLE
69107: EQUAL
69108: IFTRUE 69112
69110: GO 69130
69112: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69113: LD_ADDR_VAR 0 3
69117: PUSH
69118: LD_INT 13
69120: PUSH
69121: LD_INT 14
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: ST_TO_ADDR
69128: GO 69447
69130: LD_INT 42
69132: DOUBLE
69133: EQUAL
69134: IFTRUE 69138
69136: GO 69164
69138: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69139: LD_ADDR_VAR 0 3
69143: PUSH
69144: LD_INT 21
69146: PUSH
69147: LD_INT 22
69149: PUSH
69150: LD_INT 23
69152: PUSH
69153: LD_INT 24
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: ST_TO_ADDR
69162: GO 69447
69164: LD_INT 43
69166: DOUBLE
69167: EQUAL
69168: IFTRUE 69172
69170: GO 69198
69172: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69173: LD_ADDR_VAR 0 3
69177: PUSH
69178: LD_INT 21
69180: PUSH
69181: LD_INT 22
69183: PUSH
69184: LD_INT 23
69186: PUSH
69187: LD_INT 24
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: ST_TO_ADDR
69196: GO 69447
69198: LD_INT 44
69200: DOUBLE
69201: EQUAL
69202: IFTRUE 69206
69204: GO 69232
69206: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69207: LD_ADDR_VAR 0 3
69211: PUSH
69212: LD_INT 21
69214: PUSH
69215: LD_INT 22
69217: PUSH
69218: LD_INT 23
69220: PUSH
69221: LD_INT 24
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: LIST
69228: LIST
69229: ST_TO_ADDR
69230: GO 69447
69232: LD_INT 45
69234: DOUBLE
69235: EQUAL
69236: IFTRUE 69240
69238: GO 69266
69240: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69241: LD_ADDR_VAR 0 3
69245: PUSH
69246: LD_INT 21
69248: PUSH
69249: LD_INT 22
69251: PUSH
69252: LD_INT 23
69254: PUSH
69255: LD_INT 24
69257: PUSH
69258: EMPTY
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: ST_TO_ADDR
69264: GO 69447
69266: LD_INT 49
69268: DOUBLE
69269: EQUAL
69270: IFTRUE 69274
69272: GO 69300
69274: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
69275: LD_ADDR_VAR 0 3
69279: PUSH
69280: LD_INT 21
69282: PUSH
69283: LD_INT 22
69285: PUSH
69286: LD_INT 23
69288: PUSH
69289: LD_INT 24
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: ST_TO_ADDR
69298: GO 69447
69300: LD_INT 51
69302: DOUBLE
69303: EQUAL
69304: IFTRUE 69308
69306: GO 69334
69308: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
69309: LD_ADDR_VAR 0 3
69313: PUSH
69314: LD_INT 21
69316: PUSH
69317: LD_INT 22
69319: PUSH
69320: LD_INT 23
69322: PUSH
69323: LD_INT 24
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: ST_TO_ADDR
69332: GO 69447
69334: LD_INT 52
69336: DOUBLE
69337: EQUAL
69338: IFTRUE 69342
69340: GO 69368
69342: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
69343: LD_ADDR_VAR 0 3
69347: PUSH
69348: LD_INT 21
69350: PUSH
69351: LD_INT 22
69353: PUSH
69354: LD_INT 23
69356: PUSH
69357: LD_INT 24
69359: PUSH
69360: EMPTY
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: ST_TO_ADDR
69366: GO 69447
69368: LD_INT 53
69370: DOUBLE
69371: EQUAL
69372: IFTRUE 69376
69374: GO 69394
69376: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
69377: LD_ADDR_VAR 0 3
69381: PUSH
69382: LD_INT 23
69384: PUSH
69385: LD_INT 24
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: ST_TO_ADDR
69392: GO 69447
69394: LD_INT 46
69396: DOUBLE
69397: EQUAL
69398: IFTRUE 69402
69400: GO 69420
69402: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69403: LD_ADDR_VAR 0 3
69407: PUSH
69408: LD_INT 23
69410: PUSH
69411: LD_INT 24
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: ST_TO_ADDR
69418: GO 69447
69420: LD_INT 47
69422: DOUBLE
69423: EQUAL
69424: IFTRUE 69428
69426: GO 69446
69428: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69429: LD_ADDR_VAR 0 3
69433: PUSH
69434: LD_INT 23
69436: PUSH
69437: LD_INT 24
69439: PUSH
69440: EMPTY
69441: LIST
69442: LIST
69443: ST_TO_ADDR
69444: GO 69447
69446: POP
// result := ( chassis in result ) ;
69447: LD_ADDR_VAR 0 3
69451: PUSH
69452: LD_VAR 0 1
69456: PUSH
69457: LD_VAR 0 3
69461: IN
69462: ST_TO_ADDR
// end ;
69463: LD_VAR 0 3
69467: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69468: LD_INT 0
69470: PPUSH
69471: PPUSH
69472: PPUSH
69473: PPUSH
69474: PPUSH
69475: PPUSH
69476: PPUSH
// result := array ;
69477: LD_ADDR_VAR 0 5
69481: PUSH
69482: LD_VAR 0 1
69486: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69487: LD_VAR 0 1
69491: NOT
69492: PUSH
69493: LD_VAR 0 2
69497: NOT
69498: OR
69499: PUSH
69500: LD_VAR 0 3
69504: NOT
69505: OR
69506: PUSH
69507: LD_VAR 0 2
69511: PUSH
69512: LD_VAR 0 1
69516: GREATER
69517: OR
69518: PUSH
69519: LD_VAR 0 3
69523: PUSH
69524: LD_VAR 0 1
69528: GREATER
69529: OR
69530: IFFALSE 69534
// exit ;
69532: GO 69830
// if direction then
69534: LD_VAR 0 4
69538: IFFALSE 69602
// begin d := 1 ;
69540: LD_ADDR_VAR 0 9
69544: PUSH
69545: LD_INT 1
69547: ST_TO_ADDR
// if i_from > i_to then
69548: LD_VAR 0 2
69552: PUSH
69553: LD_VAR 0 3
69557: GREATER
69558: IFFALSE 69584
// length := ( array - i_from ) + i_to else
69560: LD_ADDR_VAR 0 11
69564: PUSH
69565: LD_VAR 0 1
69569: PUSH
69570: LD_VAR 0 2
69574: MINUS
69575: PUSH
69576: LD_VAR 0 3
69580: PLUS
69581: ST_TO_ADDR
69582: GO 69600
// length := i_to - i_from ;
69584: LD_ADDR_VAR 0 11
69588: PUSH
69589: LD_VAR 0 3
69593: PUSH
69594: LD_VAR 0 2
69598: MINUS
69599: ST_TO_ADDR
// end else
69600: GO 69663
// begin d := - 1 ;
69602: LD_ADDR_VAR 0 9
69606: PUSH
69607: LD_INT 1
69609: NEG
69610: ST_TO_ADDR
// if i_from > i_to then
69611: LD_VAR 0 2
69615: PUSH
69616: LD_VAR 0 3
69620: GREATER
69621: IFFALSE 69641
// length := i_from - i_to else
69623: LD_ADDR_VAR 0 11
69627: PUSH
69628: LD_VAR 0 2
69632: PUSH
69633: LD_VAR 0 3
69637: MINUS
69638: ST_TO_ADDR
69639: GO 69663
// length := ( array - i_to ) + i_from ;
69641: LD_ADDR_VAR 0 11
69645: PUSH
69646: LD_VAR 0 1
69650: PUSH
69651: LD_VAR 0 3
69655: MINUS
69656: PUSH
69657: LD_VAR 0 2
69661: PLUS
69662: ST_TO_ADDR
// end ; if not length then
69663: LD_VAR 0 11
69667: NOT
69668: IFFALSE 69672
// exit ;
69670: GO 69830
// tmp := array ;
69672: LD_ADDR_VAR 0 10
69676: PUSH
69677: LD_VAR 0 1
69681: ST_TO_ADDR
// for i = 1 to length do
69682: LD_ADDR_VAR 0 6
69686: PUSH
69687: DOUBLE
69688: LD_INT 1
69690: DEC
69691: ST_TO_ADDR
69692: LD_VAR 0 11
69696: PUSH
69697: FOR_TO
69698: IFFALSE 69818
// begin for j = 1 to array do
69700: LD_ADDR_VAR 0 7
69704: PUSH
69705: DOUBLE
69706: LD_INT 1
69708: DEC
69709: ST_TO_ADDR
69710: LD_VAR 0 1
69714: PUSH
69715: FOR_TO
69716: IFFALSE 69804
// begin k := j + d ;
69718: LD_ADDR_VAR 0 8
69722: PUSH
69723: LD_VAR 0 7
69727: PUSH
69728: LD_VAR 0 9
69732: PLUS
69733: ST_TO_ADDR
// if k > array then
69734: LD_VAR 0 8
69738: PUSH
69739: LD_VAR 0 1
69743: GREATER
69744: IFFALSE 69754
// k := 1 ;
69746: LD_ADDR_VAR 0 8
69750: PUSH
69751: LD_INT 1
69753: ST_TO_ADDR
// if not k then
69754: LD_VAR 0 8
69758: NOT
69759: IFFALSE 69771
// k := array ;
69761: LD_ADDR_VAR 0 8
69765: PUSH
69766: LD_VAR 0 1
69770: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69771: LD_ADDR_VAR 0 10
69775: PUSH
69776: LD_VAR 0 10
69780: PPUSH
69781: LD_VAR 0 8
69785: PPUSH
69786: LD_VAR 0 1
69790: PUSH
69791: LD_VAR 0 7
69795: ARRAY
69796: PPUSH
69797: CALL_OW 1
69801: ST_TO_ADDR
// end ;
69802: GO 69715
69804: POP
69805: POP
// array := tmp ;
69806: LD_ADDR_VAR 0 1
69810: PUSH
69811: LD_VAR 0 10
69815: ST_TO_ADDR
// end ;
69816: GO 69697
69818: POP
69819: POP
// result := array ;
69820: LD_ADDR_VAR 0 5
69824: PUSH
69825: LD_VAR 0 1
69829: ST_TO_ADDR
// end ;
69830: LD_VAR 0 5
69834: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69835: LD_INT 0
69837: PPUSH
69838: PPUSH
// result := 0 ;
69839: LD_ADDR_VAR 0 3
69843: PUSH
69844: LD_INT 0
69846: ST_TO_ADDR
// if not array or not value in array then
69847: LD_VAR 0 1
69851: NOT
69852: PUSH
69853: LD_VAR 0 2
69857: PUSH
69858: LD_VAR 0 1
69862: IN
69863: NOT
69864: OR
69865: IFFALSE 69869
// exit ;
69867: GO 69923
// for i = 1 to array do
69869: LD_ADDR_VAR 0 4
69873: PUSH
69874: DOUBLE
69875: LD_INT 1
69877: DEC
69878: ST_TO_ADDR
69879: LD_VAR 0 1
69883: PUSH
69884: FOR_TO
69885: IFFALSE 69921
// if value = array [ i ] then
69887: LD_VAR 0 2
69891: PUSH
69892: LD_VAR 0 1
69896: PUSH
69897: LD_VAR 0 4
69901: ARRAY
69902: EQUAL
69903: IFFALSE 69919
// begin result := i ;
69905: LD_ADDR_VAR 0 3
69909: PUSH
69910: LD_VAR 0 4
69914: ST_TO_ADDR
// exit ;
69915: POP
69916: POP
69917: GO 69923
// end ;
69919: GO 69884
69921: POP
69922: POP
// end ;
69923: LD_VAR 0 3
69927: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69928: LD_INT 0
69930: PPUSH
// vc_chassis := chassis ;
69931: LD_ADDR_OWVAR 37
69935: PUSH
69936: LD_VAR 0 1
69940: ST_TO_ADDR
// vc_engine := engine ;
69941: LD_ADDR_OWVAR 39
69945: PUSH
69946: LD_VAR 0 2
69950: ST_TO_ADDR
// vc_control := control ;
69951: LD_ADDR_OWVAR 38
69955: PUSH
69956: LD_VAR 0 3
69960: ST_TO_ADDR
// vc_weapon := weapon ;
69961: LD_ADDR_OWVAR 40
69965: PUSH
69966: LD_VAR 0 4
69970: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69971: LD_ADDR_OWVAR 41
69975: PUSH
69976: LD_VAR 0 5
69980: ST_TO_ADDR
// end ;
69981: LD_VAR 0 6
69985: RET
// export function WantPlant ( unit ) ; var task ; begin
69986: LD_INT 0
69988: PPUSH
69989: PPUSH
// result := false ;
69990: LD_ADDR_VAR 0 2
69994: PUSH
69995: LD_INT 0
69997: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69998: LD_ADDR_VAR 0 3
70002: PUSH
70003: LD_VAR 0 1
70007: PPUSH
70008: CALL_OW 437
70012: ST_TO_ADDR
// if task then
70013: LD_VAR 0 3
70017: IFFALSE 70045
// if task [ 1 ] [ 1 ] = p then
70019: LD_VAR 0 3
70023: PUSH
70024: LD_INT 1
70026: ARRAY
70027: PUSH
70028: LD_INT 1
70030: ARRAY
70031: PUSH
70032: LD_STRING p
70034: EQUAL
70035: IFFALSE 70045
// result := true ;
70037: LD_ADDR_VAR 0 2
70041: PUSH
70042: LD_INT 1
70044: ST_TO_ADDR
// end ;
70045: LD_VAR 0 2
70049: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70050: LD_INT 0
70052: PPUSH
70053: PPUSH
70054: PPUSH
70055: PPUSH
// if pos < 1 then
70056: LD_VAR 0 2
70060: PUSH
70061: LD_INT 1
70063: LESS
70064: IFFALSE 70068
// exit ;
70066: GO 70371
// if pos = 1 then
70068: LD_VAR 0 2
70072: PUSH
70073: LD_INT 1
70075: EQUAL
70076: IFFALSE 70109
// result := Replace ( arr , pos [ 1 ] , value ) else
70078: LD_ADDR_VAR 0 4
70082: PUSH
70083: LD_VAR 0 1
70087: PPUSH
70088: LD_VAR 0 2
70092: PUSH
70093: LD_INT 1
70095: ARRAY
70096: PPUSH
70097: LD_VAR 0 3
70101: PPUSH
70102: CALL_OW 1
70106: ST_TO_ADDR
70107: GO 70371
// begin tmp := arr ;
70109: LD_ADDR_VAR 0 6
70113: PUSH
70114: LD_VAR 0 1
70118: ST_TO_ADDR
// s_arr := [ tmp ] ;
70119: LD_ADDR_VAR 0 7
70123: PUSH
70124: LD_VAR 0 6
70128: PUSH
70129: EMPTY
70130: LIST
70131: ST_TO_ADDR
// for i = 1 to pos - 1 do
70132: LD_ADDR_VAR 0 5
70136: PUSH
70137: DOUBLE
70138: LD_INT 1
70140: DEC
70141: ST_TO_ADDR
70142: LD_VAR 0 2
70146: PUSH
70147: LD_INT 1
70149: MINUS
70150: PUSH
70151: FOR_TO
70152: IFFALSE 70197
// begin tmp := tmp [ pos [ i ] ] ;
70154: LD_ADDR_VAR 0 6
70158: PUSH
70159: LD_VAR 0 6
70163: PUSH
70164: LD_VAR 0 2
70168: PUSH
70169: LD_VAR 0 5
70173: ARRAY
70174: ARRAY
70175: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70176: LD_ADDR_VAR 0 7
70180: PUSH
70181: LD_VAR 0 7
70185: PUSH
70186: LD_VAR 0 6
70190: PUSH
70191: EMPTY
70192: LIST
70193: ADD
70194: ST_TO_ADDR
// end ;
70195: GO 70151
70197: POP
70198: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70199: LD_ADDR_VAR 0 6
70203: PUSH
70204: LD_VAR 0 6
70208: PPUSH
70209: LD_VAR 0 2
70213: PUSH
70214: LD_VAR 0 2
70218: ARRAY
70219: PPUSH
70220: LD_VAR 0 3
70224: PPUSH
70225: CALL_OW 1
70229: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70230: LD_ADDR_VAR 0 7
70234: PUSH
70235: LD_VAR 0 7
70239: PPUSH
70240: LD_VAR 0 7
70244: PPUSH
70245: LD_VAR 0 6
70249: PPUSH
70250: CALL_OW 1
70254: ST_TO_ADDR
// for i = s_arr downto 2 do
70255: LD_ADDR_VAR 0 5
70259: PUSH
70260: DOUBLE
70261: LD_VAR 0 7
70265: INC
70266: ST_TO_ADDR
70267: LD_INT 2
70269: PUSH
70270: FOR_DOWNTO
70271: IFFALSE 70355
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
70273: LD_ADDR_VAR 0 6
70277: PUSH
70278: LD_VAR 0 7
70282: PUSH
70283: LD_VAR 0 5
70287: PUSH
70288: LD_INT 1
70290: MINUS
70291: ARRAY
70292: PPUSH
70293: LD_VAR 0 2
70297: PUSH
70298: LD_VAR 0 5
70302: PUSH
70303: LD_INT 1
70305: MINUS
70306: ARRAY
70307: PPUSH
70308: LD_VAR 0 7
70312: PUSH
70313: LD_VAR 0 5
70317: ARRAY
70318: PPUSH
70319: CALL_OW 1
70323: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
70324: LD_ADDR_VAR 0 7
70328: PUSH
70329: LD_VAR 0 7
70333: PPUSH
70334: LD_VAR 0 5
70338: PUSH
70339: LD_INT 1
70341: MINUS
70342: PPUSH
70343: LD_VAR 0 6
70347: PPUSH
70348: CALL_OW 1
70352: ST_TO_ADDR
// end ;
70353: GO 70270
70355: POP
70356: POP
// result := s_arr [ 1 ] ;
70357: LD_ADDR_VAR 0 4
70361: PUSH
70362: LD_VAR 0 7
70366: PUSH
70367: LD_INT 1
70369: ARRAY
70370: ST_TO_ADDR
// end ; end ;
70371: LD_VAR 0 4
70375: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
70376: LD_INT 0
70378: PPUSH
70379: PPUSH
// if not list then
70380: LD_VAR 0 1
70384: NOT
70385: IFFALSE 70389
// exit ;
70387: GO 70480
// i := list [ pos1 ] ;
70389: LD_ADDR_VAR 0 5
70393: PUSH
70394: LD_VAR 0 1
70398: PUSH
70399: LD_VAR 0 2
70403: ARRAY
70404: ST_TO_ADDR
// if not i then
70405: LD_VAR 0 5
70409: NOT
70410: IFFALSE 70414
// exit ;
70412: GO 70480
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70414: LD_ADDR_VAR 0 1
70418: PUSH
70419: LD_VAR 0 1
70423: PPUSH
70424: LD_VAR 0 2
70428: PPUSH
70429: LD_VAR 0 1
70433: PUSH
70434: LD_VAR 0 3
70438: ARRAY
70439: PPUSH
70440: CALL_OW 1
70444: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70445: LD_ADDR_VAR 0 1
70449: PUSH
70450: LD_VAR 0 1
70454: PPUSH
70455: LD_VAR 0 3
70459: PPUSH
70460: LD_VAR 0 5
70464: PPUSH
70465: CALL_OW 1
70469: ST_TO_ADDR
// result := list ;
70470: LD_ADDR_VAR 0 4
70474: PUSH
70475: LD_VAR 0 1
70479: ST_TO_ADDR
// end ;
70480: LD_VAR 0 4
70484: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70485: LD_INT 0
70487: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70488: LD_ADDR_VAR 0 5
70492: PUSH
70493: LD_VAR 0 1
70497: PPUSH
70498: CALL_OW 250
70502: PPUSH
70503: LD_VAR 0 1
70507: PPUSH
70508: CALL_OW 251
70512: PPUSH
70513: LD_VAR 0 2
70517: PPUSH
70518: LD_VAR 0 3
70522: PPUSH
70523: LD_VAR 0 4
70527: PPUSH
70528: CALL 70538 0 5
70532: ST_TO_ADDR
// end ;
70533: LD_VAR 0 5
70537: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70538: LD_INT 0
70540: PPUSH
70541: PPUSH
70542: PPUSH
70543: PPUSH
// if not list then
70544: LD_VAR 0 3
70548: NOT
70549: IFFALSE 70553
// exit ;
70551: GO 70941
// result := [ ] ;
70553: LD_ADDR_VAR 0 6
70557: PUSH
70558: EMPTY
70559: ST_TO_ADDR
// for i in list do
70560: LD_ADDR_VAR 0 7
70564: PUSH
70565: LD_VAR 0 3
70569: PUSH
70570: FOR_IN
70571: IFFALSE 70773
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70573: LD_ADDR_VAR 0 9
70577: PUSH
70578: LD_VAR 0 7
70582: PPUSH
70583: LD_VAR 0 1
70587: PPUSH
70588: LD_VAR 0 2
70592: PPUSH
70593: CALL_OW 297
70597: ST_TO_ADDR
// if not result then
70598: LD_VAR 0 6
70602: NOT
70603: IFFALSE 70629
// result := [ [ i , tmp ] ] else
70605: LD_ADDR_VAR 0 6
70609: PUSH
70610: LD_VAR 0 7
70614: PUSH
70615: LD_VAR 0 9
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: EMPTY
70625: LIST
70626: ST_TO_ADDR
70627: GO 70771
// begin if result [ result ] [ 2 ] < tmp then
70629: LD_VAR 0 6
70633: PUSH
70634: LD_VAR 0 6
70638: ARRAY
70639: PUSH
70640: LD_INT 2
70642: ARRAY
70643: PUSH
70644: LD_VAR 0 9
70648: LESS
70649: IFFALSE 70691
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70651: LD_ADDR_VAR 0 6
70655: PUSH
70656: LD_VAR 0 6
70660: PPUSH
70661: LD_VAR 0 6
70665: PUSH
70666: LD_INT 1
70668: PLUS
70669: PPUSH
70670: LD_VAR 0 7
70674: PUSH
70675: LD_VAR 0 9
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PPUSH
70684: CALL_OW 2
70688: ST_TO_ADDR
70689: GO 70771
// for j = 1 to result do
70691: LD_ADDR_VAR 0 8
70695: PUSH
70696: DOUBLE
70697: LD_INT 1
70699: DEC
70700: ST_TO_ADDR
70701: LD_VAR 0 6
70705: PUSH
70706: FOR_TO
70707: IFFALSE 70769
// begin if tmp < result [ j ] [ 2 ] then
70709: LD_VAR 0 9
70713: PUSH
70714: LD_VAR 0 6
70718: PUSH
70719: LD_VAR 0 8
70723: ARRAY
70724: PUSH
70725: LD_INT 2
70727: ARRAY
70728: LESS
70729: IFFALSE 70767
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70731: LD_ADDR_VAR 0 6
70735: PUSH
70736: LD_VAR 0 6
70740: PPUSH
70741: LD_VAR 0 8
70745: PPUSH
70746: LD_VAR 0 7
70750: PUSH
70751: LD_VAR 0 9
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: PPUSH
70760: CALL_OW 2
70764: ST_TO_ADDR
// break ;
70765: GO 70769
// end ; end ;
70767: GO 70706
70769: POP
70770: POP
// end ; end ;
70771: GO 70570
70773: POP
70774: POP
// if result and not asc then
70775: LD_VAR 0 6
70779: PUSH
70780: LD_VAR 0 4
70784: NOT
70785: AND
70786: IFFALSE 70861
// begin tmp := result ;
70788: LD_ADDR_VAR 0 9
70792: PUSH
70793: LD_VAR 0 6
70797: ST_TO_ADDR
// for i = tmp downto 1 do
70798: LD_ADDR_VAR 0 7
70802: PUSH
70803: DOUBLE
70804: LD_VAR 0 9
70808: INC
70809: ST_TO_ADDR
70810: LD_INT 1
70812: PUSH
70813: FOR_DOWNTO
70814: IFFALSE 70859
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70816: LD_ADDR_VAR 0 6
70820: PUSH
70821: LD_VAR 0 6
70825: PPUSH
70826: LD_VAR 0 9
70830: PUSH
70831: LD_VAR 0 7
70835: MINUS
70836: PUSH
70837: LD_INT 1
70839: PLUS
70840: PPUSH
70841: LD_VAR 0 9
70845: PUSH
70846: LD_VAR 0 7
70850: ARRAY
70851: PPUSH
70852: CALL_OW 1
70856: ST_TO_ADDR
70857: GO 70813
70859: POP
70860: POP
// end ; tmp := [ ] ;
70861: LD_ADDR_VAR 0 9
70865: PUSH
70866: EMPTY
70867: ST_TO_ADDR
// if mode then
70868: LD_VAR 0 5
70872: IFFALSE 70941
// begin for i = 1 to result do
70874: LD_ADDR_VAR 0 7
70878: PUSH
70879: DOUBLE
70880: LD_INT 1
70882: DEC
70883: ST_TO_ADDR
70884: LD_VAR 0 6
70888: PUSH
70889: FOR_TO
70890: IFFALSE 70929
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70892: LD_ADDR_VAR 0 9
70896: PUSH
70897: LD_VAR 0 9
70901: PPUSH
70902: LD_VAR 0 7
70906: PPUSH
70907: LD_VAR 0 6
70911: PUSH
70912: LD_VAR 0 7
70916: ARRAY
70917: PUSH
70918: LD_INT 1
70920: ARRAY
70921: PPUSH
70922: CALL_OW 1
70926: ST_TO_ADDR
70927: GO 70889
70929: POP
70930: POP
// result := tmp ;
70931: LD_ADDR_VAR 0 6
70935: PUSH
70936: LD_VAR 0 9
70940: ST_TO_ADDR
// end ; end ;
70941: LD_VAR 0 6
70945: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70946: LD_INT 0
70948: PPUSH
70949: PPUSH
70950: PPUSH
70951: PPUSH
70952: PPUSH
70953: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70954: LD_ADDR_VAR 0 5
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: LD_INT 0
70967: PUSH
70968: EMPTY
70969: PUSH
70970: EMPTY
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: ST_TO_ADDR
// if not x or not y then
70976: LD_VAR 0 2
70980: NOT
70981: PUSH
70982: LD_VAR 0 3
70986: NOT
70987: OR
70988: IFFALSE 70992
// exit ;
70990: GO 72638
// if not range then
70992: LD_VAR 0 4
70996: NOT
70997: IFFALSE 71007
// range := 10 ;
70999: LD_ADDR_VAR 0 4
71003: PUSH
71004: LD_INT 10
71006: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71007: LD_ADDR_VAR 0 8
71011: PUSH
71012: LD_INT 81
71014: PUSH
71015: LD_VAR 0 1
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 92
71026: PUSH
71027: LD_VAR 0 2
71031: PUSH
71032: LD_VAR 0 3
71036: PUSH
71037: LD_VAR 0 4
71041: PUSH
71042: EMPTY
71043: LIST
71044: LIST
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 3
71050: PUSH
71051: LD_INT 21
71053: PUSH
71054: LD_INT 3
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: LIST
71069: PPUSH
71070: CALL_OW 69
71074: ST_TO_ADDR
// if not tmp then
71075: LD_VAR 0 8
71079: NOT
71080: IFFALSE 71084
// exit ;
71082: GO 72638
// for i in tmp do
71084: LD_ADDR_VAR 0 6
71088: PUSH
71089: LD_VAR 0 8
71093: PUSH
71094: FOR_IN
71095: IFFALSE 72613
// begin points := [ 0 , 0 , 0 ] ;
71097: LD_ADDR_VAR 0 9
71101: PUSH
71102: LD_INT 0
71104: PUSH
71105: LD_INT 0
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: LIST
71115: ST_TO_ADDR
// bpoints := 1 ;
71116: LD_ADDR_VAR 0 10
71120: PUSH
71121: LD_INT 1
71123: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71124: LD_VAR 0 6
71128: PPUSH
71129: CALL_OW 247
71133: PUSH
71134: LD_INT 1
71136: DOUBLE
71137: EQUAL
71138: IFTRUE 71142
71140: GO 71720
71142: POP
// begin if GetClass ( i ) = 1 then
71143: LD_VAR 0 6
71147: PPUSH
71148: CALL_OW 257
71152: PUSH
71153: LD_INT 1
71155: EQUAL
71156: IFFALSE 71177
// points := [ 10 , 5 , 3 ] ;
71158: LD_ADDR_VAR 0 9
71162: PUSH
71163: LD_INT 10
71165: PUSH
71166: LD_INT 5
71168: PUSH
71169: LD_INT 3
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: LIST
71176: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71177: LD_VAR 0 6
71181: PPUSH
71182: CALL_OW 257
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: LD_INT 3
71192: PUSH
71193: LD_INT 4
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: LIST
71200: IN
71201: IFFALSE 71222
// points := [ 3 , 2 , 1 ] ;
71203: LD_ADDR_VAR 0 9
71207: PUSH
71208: LD_INT 3
71210: PUSH
71211: LD_INT 2
71213: PUSH
71214: LD_INT 1
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: LIST
71221: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71222: LD_VAR 0 6
71226: PPUSH
71227: CALL_OW 257
71231: PUSH
71232: LD_INT 5
71234: EQUAL
71235: IFFALSE 71256
// points := [ 130 , 5 , 2 ] ;
71237: LD_ADDR_VAR 0 9
71241: PUSH
71242: LD_INT 130
71244: PUSH
71245: LD_INT 5
71247: PUSH
71248: LD_INT 2
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71256: LD_VAR 0 6
71260: PPUSH
71261: CALL_OW 257
71265: PUSH
71266: LD_INT 8
71268: EQUAL
71269: IFFALSE 71290
// points := [ 35 , 35 , 30 ] ;
71271: LD_ADDR_VAR 0 9
71275: PUSH
71276: LD_INT 35
71278: PUSH
71279: LD_INT 35
71281: PUSH
71282: LD_INT 30
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: LIST
71289: ST_TO_ADDR
// if GetClass ( i ) = 9 then
71290: LD_VAR 0 6
71294: PPUSH
71295: CALL_OW 257
71299: PUSH
71300: LD_INT 9
71302: EQUAL
71303: IFFALSE 71324
// points := [ 20 , 55 , 40 ] ;
71305: LD_ADDR_VAR 0 9
71309: PUSH
71310: LD_INT 20
71312: PUSH
71313: LD_INT 55
71315: PUSH
71316: LD_INT 40
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: LIST
71323: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
71324: LD_VAR 0 6
71328: PPUSH
71329: CALL_OW 257
71333: PUSH
71334: LD_INT 12
71336: PUSH
71337: LD_INT 16
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: IN
71344: IFFALSE 71365
// points := [ 5 , 3 , 2 ] ;
71346: LD_ADDR_VAR 0 9
71350: PUSH
71351: LD_INT 5
71353: PUSH
71354: LD_INT 3
71356: PUSH
71357: LD_INT 2
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: LIST
71364: ST_TO_ADDR
// if GetClass ( i ) = 17 then
71365: LD_VAR 0 6
71369: PPUSH
71370: CALL_OW 257
71374: PUSH
71375: LD_INT 17
71377: EQUAL
71378: IFFALSE 71399
// points := [ 100 , 50 , 75 ] ;
71380: LD_ADDR_VAR 0 9
71384: PUSH
71385: LD_INT 100
71387: PUSH
71388: LD_INT 50
71390: PUSH
71391: LD_INT 75
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: LIST
71398: ST_TO_ADDR
// if GetClass ( i ) = 15 then
71399: LD_VAR 0 6
71403: PPUSH
71404: CALL_OW 257
71408: PUSH
71409: LD_INT 15
71411: EQUAL
71412: IFFALSE 71433
// points := [ 10 , 5 , 3 ] ;
71414: LD_ADDR_VAR 0 9
71418: PUSH
71419: LD_INT 10
71421: PUSH
71422: LD_INT 5
71424: PUSH
71425: LD_INT 3
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: LIST
71432: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71433: LD_VAR 0 6
71437: PPUSH
71438: CALL_OW 257
71442: PUSH
71443: LD_INT 14
71445: EQUAL
71446: IFFALSE 71467
// points := [ 10 , 0 , 0 ] ;
71448: LD_ADDR_VAR 0 9
71452: PUSH
71453: LD_INT 10
71455: PUSH
71456: LD_INT 0
71458: PUSH
71459: LD_INT 0
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: LIST
71466: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71467: LD_VAR 0 6
71471: PPUSH
71472: CALL_OW 257
71476: PUSH
71477: LD_INT 11
71479: EQUAL
71480: IFFALSE 71501
// points := [ 30 , 10 , 5 ] ;
71482: LD_ADDR_VAR 0 9
71486: PUSH
71487: LD_INT 30
71489: PUSH
71490: LD_INT 10
71492: PUSH
71493: LD_INT 5
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: LIST
71500: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71501: LD_VAR 0 1
71505: PPUSH
71506: LD_INT 5
71508: PPUSH
71509: CALL_OW 321
71513: PUSH
71514: LD_INT 2
71516: EQUAL
71517: IFFALSE 71534
// bpoints := bpoints * 1.8 ;
71519: LD_ADDR_VAR 0 10
71523: PUSH
71524: LD_VAR 0 10
71528: PUSH
71529: LD_REAL  1.80000000000000E+0000
71532: MUL
71533: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71534: LD_VAR 0 6
71538: PPUSH
71539: CALL_OW 257
71543: PUSH
71544: LD_INT 1
71546: PUSH
71547: LD_INT 2
71549: PUSH
71550: LD_INT 3
71552: PUSH
71553: LD_INT 4
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: IN
71562: PUSH
71563: LD_VAR 0 1
71567: PPUSH
71568: LD_INT 51
71570: PPUSH
71571: CALL_OW 321
71575: PUSH
71576: LD_INT 2
71578: EQUAL
71579: AND
71580: IFFALSE 71597
// bpoints := bpoints * 1.2 ;
71582: LD_ADDR_VAR 0 10
71586: PUSH
71587: LD_VAR 0 10
71591: PUSH
71592: LD_REAL  1.20000000000000E+0000
71595: MUL
71596: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71597: LD_VAR 0 6
71601: PPUSH
71602: CALL_OW 257
71606: PUSH
71607: LD_INT 5
71609: PUSH
71610: LD_INT 7
71612: PUSH
71613: LD_INT 9
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: LIST
71620: IN
71621: PUSH
71622: LD_VAR 0 1
71626: PPUSH
71627: LD_INT 52
71629: PPUSH
71630: CALL_OW 321
71634: PUSH
71635: LD_INT 2
71637: EQUAL
71638: AND
71639: IFFALSE 71656
// bpoints := bpoints * 1.5 ;
71641: LD_ADDR_VAR 0 10
71645: PUSH
71646: LD_VAR 0 10
71650: PUSH
71651: LD_REAL  1.50000000000000E+0000
71654: MUL
71655: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71656: LD_VAR 0 1
71660: PPUSH
71661: LD_INT 66
71663: PPUSH
71664: CALL_OW 321
71668: PUSH
71669: LD_INT 2
71671: EQUAL
71672: IFFALSE 71689
// bpoints := bpoints * 1.1 ;
71674: LD_ADDR_VAR 0 10
71678: PUSH
71679: LD_VAR 0 10
71683: PUSH
71684: LD_REAL  1.10000000000000E+0000
71687: MUL
71688: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71689: LD_ADDR_VAR 0 10
71693: PUSH
71694: LD_VAR 0 10
71698: PUSH
71699: LD_VAR 0 6
71703: PPUSH
71704: LD_INT 1
71706: PPUSH
71707: CALL_OW 259
71711: PUSH
71712: LD_REAL  1.15000000000000E+0000
71715: MUL
71716: MUL
71717: ST_TO_ADDR
// end ; unit_vehicle :
71718: GO 72542
71720: LD_INT 2
71722: DOUBLE
71723: EQUAL
71724: IFTRUE 71728
71726: GO 72530
71728: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71729: LD_VAR 0 6
71733: PPUSH
71734: CALL_OW 264
71738: PUSH
71739: LD_INT 2
71741: PUSH
71742: LD_INT 42
71744: PUSH
71745: LD_INT 24
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: LIST
71752: IN
71753: IFFALSE 71774
// points := [ 25 , 5 , 3 ] ;
71755: LD_ADDR_VAR 0 9
71759: PUSH
71760: LD_INT 25
71762: PUSH
71763: LD_INT 5
71765: PUSH
71766: LD_INT 3
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: LIST
71773: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71774: LD_VAR 0 6
71778: PPUSH
71779: CALL_OW 264
71783: PUSH
71784: LD_INT 4
71786: PUSH
71787: LD_INT 43
71789: PUSH
71790: LD_INT 25
71792: PUSH
71793: EMPTY
71794: LIST
71795: LIST
71796: LIST
71797: IN
71798: IFFALSE 71819
// points := [ 40 , 15 , 5 ] ;
71800: LD_ADDR_VAR 0 9
71804: PUSH
71805: LD_INT 40
71807: PUSH
71808: LD_INT 15
71810: PUSH
71811: LD_INT 5
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: LIST
71818: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71819: LD_VAR 0 6
71823: PPUSH
71824: CALL_OW 264
71828: PUSH
71829: LD_INT 3
71831: PUSH
71832: LD_INT 23
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: IN
71839: IFFALSE 71860
// points := [ 7 , 25 , 8 ] ;
71841: LD_ADDR_VAR 0 9
71845: PUSH
71846: LD_INT 7
71848: PUSH
71849: LD_INT 25
71851: PUSH
71852: LD_INT 8
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: LIST
71859: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71860: LD_VAR 0 6
71864: PPUSH
71865: CALL_OW 264
71869: PUSH
71870: LD_INT 5
71872: PUSH
71873: LD_INT 27
71875: PUSH
71876: LD_INT 44
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: LIST
71883: IN
71884: IFFALSE 71905
// points := [ 14 , 50 , 16 ] ;
71886: LD_ADDR_VAR 0 9
71890: PUSH
71891: LD_INT 14
71893: PUSH
71894: LD_INT 50
71896: PUSH
71897: LD_INT 16
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: LIST
71904: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71905: LD_VAR 0 6
71909: PPUSH
71910: CALL_OW 264
71914: PUSH
71915: LD_INT 6
71917: PUSH
71918: LD_INT 46
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: IN
71925: IFFALSE 71946
// points := [ 32 , 120 , 70 ] ;
71927: LD_ADDR_VAR 0 9
71931: PUSH
71932: LD_INT 32
71934: PUSH
71935: LD_INT 120
71937: PUSH
71938: LD_INT 70
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: LIST
71945: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71946: LD_VAR 0 6
71950: PPUSH
71951: CALL_OW 264
71955: PUSH
71956: LD_INT 7
71958: PUSH
71959: LD_INT 28
71961: PUSH
71962: LD_INT 45
71964: PUSH
71965: EMPTY
71966: LIST
71967: LIST
71968: LIST
71969: IN
71970: IFFALSE 71991
// points := [ 35 , 20 , 45 ] ;
71972: LD_ADDR_VAR 0 9
71976: PUSH
71977: LD_INT 35
71979: PUSH
71980: LD_INT 20
71982: PUSH
71983: LD_INT 45
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: LIST
71990: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71991: LD_VAR 0 6
71995: PPUSH
71996: CALL_OW 264
72000: PUSH
72001: LD_INT 47
72003: PUSH
72004: EMPTY
72005: LIST
72006: IN
72007: IFFALSE 72028
// points := [ 67 , 45 , 75 ] ;
72009: LD_ADDR_VAR 0 9
72013: PUSH
72014: LD_INT 67
72016: PUSH
72017: LD_INT 45
72019: PUSH
72020: LD_INT 75
72022: PUSH
72023: EMPTY
72024: LIST
72025: LIST
72026: LIST
72027: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72028: LD_VAR 0 6
72032: PPUSH
72033: CALL_OW 264
72037: PUSH
72038: LD_INT 26
72040: PUSH
72041: EMPTY
72042: LIST
72043: IN
72044: IFFALSE 72065
// points := [ 120 , 30 , 80 ] ;
72046: LD_ADDR_VAR 0 9
72050: PUSH
72051: LD_INT 120
72053: PUSH
72054: LD_INT 30
72056: PUSH
72057: LD_INT 80
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: LIST
72064: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72065: LD_VAR 0 6
72069: PPUSH
72070: CALL_OW 264
72074: PUSH
72075: LD_INT 22
72077: PUSH
72078: EMPTY
72079: LIST
72080: IN
72081: IFFALSE 72102
// points := [ 40 , 1 , 1 ] ;
72083: LD_ADDR_VAR 0 9
72087: PUSH
72088: LD_INT 40
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: LD_INT 1
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: LIST
72101: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72102: LD_VAR 0 6
72106: PPUSH
72107: CALL_OW 264
72111: PUSH
72112: LD_INT 29
72114: PUSH
72115: EMPTY
72116: LIST
72117: IN
72118: IFFALSE 72139
// points := [ 70 , 200 , 400 ] ;
72120: LD_ADDR_VAR 0 9
72124: PUSH
72125: LD_INT 70
72127: PUSH
72128: LD_INT 200
72130: PUSH
72131: LD_INT 400
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: LIST
72138: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72139: LD_VAR 0 6
72143: PPUSH
72144: CALL_OW 264
72148: PUSH
72149: LD_INT 14
72151: PUSH
72152: LD_INT 53
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: IN
72159: IFFALSE 72180
// points := [ 40 , 10 , 20 ] ;
72161: LD_ADDR_VAR 0 9
72165: PUSH
72166: LD_INT 40
72168: PUSH
72169: LD_INT 10
72171: PUSH
72172: LD_INT 20
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72180: LD_VAR 0 6
72184: PPUSH
72185: CALL_OW 264
72189: PUSH
72190: LD_INT 9
72192: PUSH
72193: EMPTY
72194: LIST
72195: IN
72196: IFFALSE 72217
// points := [ 5 , 70 , 20 ] ;
72198: LD_ADDR_VAR 0 9
72202: PUSH
72203: LD_INT 5
72205: PUSH
72206: LD_INT 70
72208: PUSH
72209: LD_INT 20
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72217: LD_VAR 0 6
72221: PPUSH
72222: CALL_OW 264
72226: PUSH
72227: LD_INT 10
72229: PUSH
72230: EMPTY
72231: LIST
72232: IN
72233: IFFALSE 72254
// points := [ 35 , 110 , 70 ] ;
72235: LD_ADDR_VAR 0 9
72239: PUSH
72240: LD_INT 35
72242: PUSH
72243: LD_INT 110
72245: PUSH
72246: LD_INT 70
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: LIST
72253: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72254: LD_VAR 0 6
72258: PPUSH
72259: CALL_OW 265
72263: PUSH
72264: LD_INT 25
72266: EQUAL
72267: IFFALSE 72288
// points := [ 80 , 65 , 100 ] ;
72269: LD_ADDR_VAR 0 9
72273: PUSH
72274: LD_INT 80
72276: PUSH
72277: LD_INT 65
72279: PUSH
72280: LD_INT 100
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: LIST
72287: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
72288: LD_VAR 0 6
72292: PPUSH
72293: CALL_OW 263
72297: PUSH
72298: LD_INT 1
72300: EQUAL
72301: IFFALSE 72336
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
72303: LD_ADDR_VAR 0 10
72307: PUSH
72308: LD_VAR 0 10
72312: PUSH
72313: LD_VAR 0 6
72317: PPUSH
72318: CALL_OW 311
72322: PPUSH
72323: LD_INT 3
72325: PPUSH
72326: CALL_OW 259
72330: PUSH
72331: LD_INT 4
72333: MUL
72334: MUL
72335: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
72336: LD_VAR 0 6
72340: PPUSH
72341: CALL_OW 263
72345: PUSH
72346: LD_INT 2
72348: EQUAL
72349: IFFALSE 72400
// begin j := IsControledBy ( i ) ;
72351: LD_ADDR_VAR 0 7
72355: PUSH
72356: LD_VAR 0 6
72360: PPUSH
72361: CALL_OW 312
72365: ST_TO_ADDR
// if j then
72366: LD_VAR 0 7
72370: IFFALSE 72400
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
72372: LD_ADDR_VAR 0 10
72376: PUSH
72377: LD_VAR 0 10
72381: PUSH
72382: LD_VAR 0 7
72386: PPUSH
72387: LD_INT 3
72389: PPUSH
72390: CALL_OW 259
72394: PUSH
72395: LD_INT 3
72397: MUL
72398: MUL
72399: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
72400: LD_VAR 0 6
72404: PPUSH
72405: CALL_OW 264
72409: PUSH
72410: LD_INT 5
72412: PUSH
72413: LD_INT 6
72415: PUSH
72416: LD_INT 46
72418: PUSH
72419: LD_INT 44
72421: PUSH
72422: LD_INT 47
72424: PUSH
72425: LD_INT 45
72427: PUSH
72428: LD_INT 28
72430: PUSH
72431: LD_INT 7
72433: PUSH
72434: LD_INT 27
72436: PUSH
72437: LD_INT 29
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: IN
72452: PUSH
72453: LD_VAR 0 1
72457: PPUSH
72458: LD_INT 52
72460: PPUSH
72461: CALL_OW 321
72465: PUSH
72466: LD_INT 2
72468: EQUAL
72469: AND
72470: IFFALSE 72487
// bpoints := bpoints * 1.2 ;
72472: LD_ADDR_VAR 0 10
72476: PUSH
72477: LD_VAR 0 10
72481: PUSH
72482: LD_REAL  1.20000000000000E+0000
72485: MUL
72486: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72487: LD_VAR 0 6
72491: PPUSH
72492: CALL_OW 264
72496: PUSH
72497: LD_INT 6
72499: PUSH
72500: LD_INT 46
72502: PUSH
72503: LD_INT 47
72505: PUSH
72506: EMPTY
72507: LIST
72508: LIST
72509: LIST
72510: IN
72511: IFFALSE 72528
// bpoints := bpoints * 1.2 ;
72513: LD_ADDR_VAR 0 10
72517: PUSH
72518: LD_VAR 0 10
72522: PUSH
72523: LD_REAL  1.20000000000000E+0000
72526: MUL
72527: ST_TO_ADDR
// end ; unit_building :
72528: GO 72542
72530: LD_INT 3
72532: DOUBLE
72533: EQUAL
72534: IFTRUE 72538
72536: GO 72541
72538: POP
// ; end ;
72539: GO 72542
72541: POP
// for j = 1 to 3 do
72542: LD_ADDR_VAR 0 7
72546: PUSH
72547: DOUBLE
72548: LD_INT 1
72550: DEC
72551: ST_TO_ADDR
72552: LD_INT 3
72554: PUSH
72555: FOR_TO
72556: IFFALSE 72609
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72558: LD_ADDR_VAR 0 5
72562: PUSH
72563: LD_VAR 0 5
72567: PPUSH
72568: LD_VAR 0 7
72572: PPUSH
72573: LD_VAR 0 5
72577: PUSH
72578: LD_VAR 0 7
72582: ARRAY
72583: PUSH
72584: LD_VAR 0 9
72588: PUSH
72589: LD_VAR 0 7
72593: ARRAY
72594: PUSH
72595: LD_VAR 0 10
72599: MUL
72600: PLUS
72601: PPUSH
72602: CALL_OW 1
72606: ST_TO_ADDR
72607: GO 72555
72609: POP
72610: POP
// end ;
72611: GO 71094
72613: POP
72614: POP
// result := Replace ( result , 4 , tmp ) ;
72615: LD_ADDR_VAR 0 5
72619: PUSH
72620: LD_VAR 0 5
72624: PPUSH
72625: LD_INT 4
72627: PPUSH
72628: LD_VAR 0 8
72632: PPUSH
72633: CALL_OW 1
72637: ST_TO_ADDR
// end ;
72638: LD_VAR 0 5
72642: RET
// export function DangerAtRange ( unit , range ) ; begin
72643: LD_INT 0
72645: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72646: LD_ADDR_VAR 0 3
72650: PUSH
72651: LD_VAR 0 1
72655: PPUSH
72656: CALL_OW 255
72660: PPUSH
72661: LD_VAR 0 1
72665: PPUSH
72666: CALL_OW 250
72670: PPUSH
72671: LD_VAR 0 1
72675: PPUSH
72676: CALL_OW 251
72680: PPUSH
72681: LD_VAR 0 2
72685: PPUSH
72686: CALL 70946 0 4
72690: ST_TO_ADDR
// end ;
72691: LD_VAR 0 3
72695: RET
// export function DangerInArea ( side , area ) ; begin
72696: LD_INT 0
72698: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72699: LD_ADDR_VAR 0 3
72703: PUSH
72704: LD_VAR 0 2
72708: PPUSH
72709: LD_INT 81
72711: PUSH
72712: LD_VAR 0 1
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PPUSH
72721: CALL_OW 70
72725: ST_TO_ADDR
// end ;
72726: LD_VAR 0 3
72730: RET
// export function IsExtension ( b ) ; begin
72731: LD_INT 0
72733: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72734: LD_ADDR_VAR 0 2
72738: PUSH
72739: LD_VAR 0 1
72743: PUSH
72744: LD_INT 23
72746: PUSH
72747: LD_INT 20
72749: PUSH
72750: LD_INT 22
72752: PUSH
72753: LD_INT 17
72755: PUSH
72756: LD_INT 24
72758: PUSH
72759: LD_INT 21
72761: PUSH
72762: LD_INT 19
72764: PUSH
72765: LD_INT 16
72767: PUSH
72768: LD_INT 25
72770: PUSH
72771: LD_INT 18
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: IN
72786: ST_TO_ADDR
// end ;
72787: LD_VAR 0 2
72791: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72792: LD_INT 0
72794: PPUSH
72795: PPUSH
72796: PPUSH
// result := [ ] ;
72797: LD_ADDR_VAR 0 3
72801: PUSH
72802: EMPTY
72803: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72804: LD_ADDR_VAR 0 4
72808: PUSH
72809: LD_VAR 0 2
72813: PPUSH
72814: LD_INT 21
72816: PUSH
72817: LD_INT 3
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PPUSH
72824: CALL_OW 70
72828: ST_TO_ADDR
// if not tmp then
72829: LD_VAR 0 4
72833: NOT
72834: IFFALSE 72838
// exit ;
72836: GO 72896
// for i in tmp do
72838: LD_ADDR_VAR 0 5
72842: PUSH
72843: LD_VAR 0 4
72847: PUSH
72848: FOR_IN
72849: IFFALSE 72884
// if GetBase ( i ) <> base then
72851: LD_VAR 0 5
72855: PPUSH
72856: CALL_OW 274
72860: PUSH
72861: LD_VAR 0 1
72865: NONEQUAL
72866: IFFALSE 72882
// ComLinkToBase ( base , i ) ;
72868: LD_VAR 0 1
72872: PPUSH
72873: LD_VAR 0 5
72877: PPUSH
72878: CALL_OW 169
72882: GO 72848
72884: POP
72885: POP
// result := tmp ;
72886: LD_ADDR_VAR 0 3
72890: PUSH
72891: LD_VAR 0 4
72895: ST_TO_ADDR
// end ;
72896: LD_VAR 0 3
72900: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72901: LD_INT 0
72903: PPUSH
72904: PPUSH
// if BuildingStatus ( b ) = bs_build then
72905: LD_VAR 0 2
72909: PPUSH
72910: CALL_OW 461
72914: PUSH
72915: LD_INT 1
72917: EQUAL
72918: IFFALSE 72978
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72920: LD_VAR 0 1
72924: PPUSH
72925: LD_STRING h
72927: PUSH
72928: LD_VAR 0 2
72932: PPUSH
72933: CALL_OW 250
72937: PUSH
72938: LD_VAR 0 2
72942: PPUSH
72943: CALL_OW 251
72947: PUSH
72948: LD_VAR 0 2
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 0
72958: PUSH
72959: LD_INT 0
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: LIST
72966: LIST
72967: LIST
72968: LIST
72969: LIST
72970: PUSH
72971: EMPTY
72972: LIST
72973: PPUSH
72974: CALL_OW 446
// end ;
72978: LD_VAR 0 3
72982: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72983: LD_INT 0
72985: PPUSH
72986: PPUSH
72987: PPUSH
72988: PPUSH
72989: PPUSH
72990: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72991: LD_VAR 0 1
72995: NOT
72996: PUSH
72997: LD_VAR 0 1
73001: PPUSH
73002: CALL_OW 263
73006: PUSH
73007: LD_INT 2
73009: EQUAL
73010: NOT
73011: OR
73012: IFFALSE 73016
// exit ;
73014: GO 73332
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73016: LD_ADDR_VAR 0 6
73020: PUSH
73021: LD_INT 22
73023: PUSH
73024: LD_VAR 0 1
73028: PPUSH
73029: CALL_OW 255
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 2
73040: PUSH
73041: LD_INT 30
73043: PUSH
73044: LD_INT 36
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 34
73053: PUSH
73054: LD_INT 31
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: LIST
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PPUSH
73070: CALL_OW 69
73074: ST_TO_ADDR
// if not tmp then
73075: LD_VAR 0 6
73079: NOT
73080: IFFALSE 73084
// exit ;
73082: GO 73332
// result := [ ] ;
73084: LD_ADDR_VAR 0 2
73088: PUSH
73089: EMPTY
73090: ST_TO_ADDR
// for i in tmp do
73091: LD_ADDR_VAR 0 3
73095: PUSH
73096: LD_VAR 0 6
73100: PUSH
73101: FOR_IN
73102: IFFALSE 73173
// begin t := UnitsInside ( i ) ;
73104: LD_ADDR_VAR 0 4
73108: PUSH
73109: LD_VAR 0 3
73113: PPUSH
73114: CALL_OW 313
73118: ST_TO_ADDR
// if t then
73119: LD_VAR 0 4
73123: IFFALSE 73171
// for j in t do
73125: LD_ADDR_VAR 0 7
73129: PUSH
73130: LD_VAR 0 4
73134: PUSH
73135: FOR_IN
73136: IFFALSE 73169
// result := Insert ( result , result + 1 , j ) ;
73138: LD_ADDR_VAR 0 2
73142: PUSH
73143: LD_VAR 0 2
73147: PPUSH
73148: LD_VAR 0 2
73152: PUSH
73153: LD_INT 1
73155: PLUS
73156: PPUSH
73157: LD_VAR 0 7
73161: PPUSH
73162: CALL_OW 2
73166: ST_TO_ADDR
73167: GO 73135
73169: POP
73170: POP
// end ;
73171: GO 73101
73173: POP
73174: POP
// if not result then
73175: LD_VAR 0 2
73179: NOT
73180: IFFALSE 73184
// exit ;
73182: GO 73332
// mech := result [ 1 ] ;
73184: LD_ADDR_VAR 0 5
73188: PUSH
73189: LD_VAR 0 2
73193: PUSH
73194: LD_INT 1
73196: ARRAY
73197: ST_TO_ADDR
// if result > 1 then
73198: LD_VAR 0 2
73202: PUSH
73203: LD_INT 1
73205: GREATER
73206: IFFALSE 73318
// for i = 2 to result do
73208: LD_ADDR_VAR 0 3
73212: PUSH
73213: DOUBLE
73214: LD_INT 2
73216: DEC
73217: ST_TO_ADDR
73218: LD_VAR 0 2
73222: PUSH
73223: FOR_TO
73224: IFFALSE 73316
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73226: LD_ADDR_VAR 0 4
73230: PUSH
73231: LD_VAR 0 2
73235: PUSH
73236: LD_VAR 0 3
73240: ARRAY
73241: PPUSH
73242: LD_INT 3
73244: PPUSH
73245: CALL_OW 259
73249: PUSH
73250: LD_VAR 0 2
73254: PUSH
73255: LD_VAR 0 3
73259: ARRAY
73260: PPUSH
73261: CALL_OW 432
73265: MINUS
73266: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
73267: LD_VAR 0 4
73271: PUSH
73272: LD_VAR 0 5
73276: PPUSH
73277: LD_INT 3
73279: PPUSH
73280: CALL_OW 259
73284: PUSH
73285: LD_VAR 0 5
73289: PPUSH
73290: CALL_OW 432
73294: MINUS
73295: GREATEREQUAL
73296: IFFALSE 73314
// mech := result [ i ] ;
73298: LD_ADDR_VAR 0 5
73302: PUSH
73303: LD_VAR 0 2
73307: PUSH
73308: LD_VAR 0 3
73312: ARRAY
73313: ST_TO_ADDR
// end ;
73314: GO 73223
73316: POP
73317: POP
// ComLinkTo ( vehicle , mech ) ;
73318: LD_VAR 0 1
73322: PPUSH
73323: LD_VAR 0 5
73327: PPUSH
73328: CALL_OW 135
// end ;
73332: LD_VAR 0 2
73336: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
73337: LD_INT 0
73339: PPUSH
73340: PPUSH
73341: PPUSH
73342: PPUSH
73343: PPUSH
73344: PPUSH
73345: PPUSH
73346: PPUSH
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
73351: PPUSH
// result := [ ] ;
73352: LD_ADDR_VAR 0 7
73356: PUSH
73357: EMPTY
73358: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
73359: LD_VAR 0 1
73363: PPUSH
73364: CALL_OW 266
73368: PUSH
73369: LD_INT 0
73371: PUSH
73372: LD_INT 1
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: IN
73379: NOT
73380: IFFALSE 73384
// exit ;
73382: GO 75015
// if name then
73384: LD_VAR 0 3
73388: IFFALSE 73404
// SetBName ( base_dep , name ) ;
73390: LD_VAR 0 1
73394: PPUSH
73395: LD_VAR 0 3
73399: PPUSH
73400: CALL_OW 500
// base := GetBase ( base_dep ) ;
73404: LD_ADDR_VAR 0 15
73408: PUSH
73409: LD_VAR 0 1
73413: PPUSH
73414: CALL_OW 274
73418: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73419: LD_ADDR_VAR 0 16
73423: PUSH
73424: LD_VAR 0 1
73428: PPUSH
73429: CALL_OW 255
73433: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73434: LD_ADDR_VAR 0 17
73438: PUSH
73439: LD_VAR 0 1
73443: PPUSH
73444: CALL_OW 248
73448: ST_TO_ADDR
// if sources then
73449: LD_VAR 0 5
73453: IFFALSE 73500
// for i = 1 to 3 do
73455: LD_ADDR_VAR 0 8
73459: PUSH
73460: DOUBLE
73461: LD_INT 1
73463: DEC
73464: ST_TO_ADDR
73465: LD_INT 3
73467: PUSH
73468: FOR_TO
73469: IFFALSE 73498
// AddResourceType ( base , i , sources [ i ] ) ;
73471: LD_VAR 0 15
73475: PPUSH
73476: LD_VAR 0 8
73480: PPUSH
73481: LD_VAR 0 5
73485: PUSH
73486: LD_VAR 0 8
73490: ARRAY
73491: PPUSH
73492: CALL_OW 276
73496: GO 73468
73498: POP
73499: POP
// buildings := GetBaseBuildings ( base , area ) ;
73500: LD_ADDR_VAR 0 18
73504: PUSH
73505: LD_VAR 0 15
73509: PPUSH
73510: LD_VAR 0 2
73514: PPUSH
73515: CALL 72792 0 2
73519: ST_TO_ADDR
// InitHc ;
73520: CALL_OW 19
// InitUc ;
73524: CALL_OW 18
// uc_side := side ;
73528: LD_ADDR_OWVAR 20
73532: PUSH
73533: LD_VAR 0 16
73537: ST_TO_ADDR
// uc_nation := nation ;
73538: LD_ADDR_OWVAR 21
73542: PUSH
73543: LD_VAR 0 17
73547: ST_TO_ADDR
// if buildings then
73548: LD_VAR 0 18
73552: IFFALSE 74874
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73554: LD_ADDR_VAR 0 19
73558: PUSH
73559: LD_VAR 0 18
73563: PPUSH
73564: LD_INT 2
73566: PUSH
73567: LD_INT 30
73569: PUSH
73570: LD_INT 29
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 30
73579: PUSH
73580: LD_INT 30
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: LIST
73591: PPUSH
73592: CALL_OW 72
73596: ST_TO_ADDR
// if tmp then
73597: LD_VAR 0 19
73601: IFFALSE 73649
// for i in tmp do
73603: LD_ADDR_VAR 0 8
73607: PUSH
73608: LD_VAR 0 19
73612: PUSH
73613: FOR_IN
73614: IFFALSE 73647
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73616: LD_VAR 0 8
73620: PPUSH
73621: CALL_OW 250
73625: PPUSH
73626: LD_VAR 0 8
73630: PPUSH
73631: CALL_OW 251
73635: PPUSH
73636: LD_VAR 0 16
73640: PPUSH
73641: CALL_OW 441
73645: GO 73613
73647: POP
73648: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73649: LD_VAR 0 18
73653: PPUSH
73654: LD_INT 2
73656: PUSH
73657: LD_INT 30
73659: PUSH
73660: LD_INT 32
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 30
73669: PUSH
73670: LD_INT 33
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: LIST
73681: PPUSH
73682: CALL_OW 72
73686: IFFALSE 73774
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73688: LD_ADDR_VAR 0 8
73692: PUSH
73693: LD_VAR 0 18
73697: PPUSH
73698: LD_INT 2
73700: PUSH
73701: LD_INT 30
73703: PUSH
73704: LD_INT 32
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: PUSH
73711: LD_INT 30
73713: PUSH
73714: LD_INT 33
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: LIST
73725: PPUSH
73726: CALL_OW 72
73730: PUSH
73731: FOR_IN
73732: IFFALSE 73772
// begin if not GetBWeapon ( i ) then
73734: LD_VAR 0 8
73738: PPUSH
73739: CALL_OW 269
73743: NOT
73744: IFFALSE 73770
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73746: LD_VAR 0 8
73750: PPUSH
73751: LD_VAR 0 8
73755: PPUSH
73756: LD_VAR 0 2
73760: PPUSH
73761: CALL 75020 0 2
73765: PPUSH
73766: CALL_OW 431
// end ;
73770: GO 73731
73772: POP
73773: POP
// end ; for i = 1 to personel do
73774: LD_ADDR_VAR 0 8
73778: PUSH
73779: DOUBLE
73780: LD_INT 1
73782: DEC
73783: ST_TO_ADDR
73784: LD_VAR 0 6
73788: PUSH
73789: FOR_TO
73790: IFFALSE 74854
// begin if i > 4 then
73792: LD_VAR 0 8
73796: PUSH
73797: LD_INT 4
73799: GREATER
73800: IFFALSE 73804
// break ;
73802: GO 74854
// case i of 1 :
73804: LD_VAR 0 8
73808: PUSH
73809: LD_INT 1
73811: DOUBLE
73812: EQUAL
73813: IFTRUE 73817
73815: GO 73897
73817: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73818: LD_ADDR_VAR 0 12
73822: PUSH
73823: LD_VAR 0 18
73827: PPUSH
73828: LD_INT 22
73830: PUSH
73831: LD_VAR 0 16
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 58
73842: PUSH
73843: EMPTY
73844: LIST
73845: PUSH
73846: LD_INT 2
73848: PUSH
73849: LD_INT 30
73851: PUSH
73852: LD_INT 32
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 30
73861: PUSH
73862: LD_INT 4
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 30
73871: PUSH
73872: LD_INT 5
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: LIST
73883: LIST
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: LIST
73889: PPUSH
73890: CALL_OW 72
73894: ST_TO_ADDR
73895: GO 74119
73897: LD_INT 2
73899: DOUBLE
73900: EQUAL
73901: IFTRUE 73905
73903: GO 73967
73905: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73906: LD_ADDR_VAR 0 12
73910: PUSH
73911: LD_VAR 0 18
73915: PPUSH
73916: LD_INT 22
73918: PUSH
73919: LD_VAR 0 16
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PUSH
73928: LD_INT 2
73930: PUSH
73931: LD_INT 30
73933: PUSH
73934: LD_INT 0
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 30
73943: PUSH
73944: LD_INT 1
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: EMPTY
73952: LIST
73953: LIST
73954: LIST
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PPUSH
73960: CALL_OW 72
73964: ST_TO_ADDR
73965: GO 74119
73967: LD_INT 3
73969: DOUBLE
73970: EQUAL
73971: IFTRUE 73975
73973: GO 74037
73975: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73976: LD_ADDR_VAR 0 12
73980: PUSH
73981: LD_VAR 0 18
73985: PPUSH
73986: LD_INT 22
73988: PUSH
73989: LD_VAR 0 16
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 2
74000: PUSH
74001: LD_INT 30
74003: PUSH
74004: LD_INT 2
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 30
74013: PUSH
74014: LD_INT 3
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: LIST
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PPUSH
74030: CALL_OW 72
74034: ST_TO_ADDR
74035: GO 74119
74037: LD_INT 4
74039: DOUBLE
74040: EQUAL
74041: IFTRUE 74045
74043: GO 74118
74045: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74046: LD_ADDR_VAR 0 12
74050: PUSH
74051: LD_VAR 0 18
74055: PPUSH
74056: LD_INT 22
74058: PUSH
74059: LD_VAR 0 16
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 2
74070: PUSH
74071: LD_INT 30
74073: PUSH
74074: LD_INT 6
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: LD_INT 30
74083: PUSH
74084: LD_INT 7
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 30
74093: PUSH
74094: LD_INT 8
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: LIST
74105: LIST
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PPUSH
74111: CALL_OW 72
74115: ST_TO_ADDR
74116: GO 74119
74118: POP
// if i = 1 then
74119: LD_VAR 0 8
74123: PUSH
74124: LD_INT 1
74126: EQUAL
74127: IFFALSE 74238
// begin tmp := [ ] ;
74129: LD_ADDR_VAR 0 19
74133: PUSH
74134: EMPTY
74135: ST_TO_ADDR
// for j in f do
74136: LD_ADDR_VAR 0 9
74140: PUSH
74141: LD_VAR 0 12
74145: PUSH
74146: FOR_IN
74147: IFFALSE 74220
// if GetBType ( j ) = b_bunker then
74149: LD_VAR 0 9
74153: PPUSH
74154: CALL_OW 266
74158: PUSH
74159: LD_INT 32
74161: EQUAL
74162: IFFALSE 74189
// tmp := Insert ( tmp , 1 , j ) else
74164: LD_ADDR_VAR 0 19
74168: PUSH
74169: LD_VAR 0 19
74173: PPUSH
74174: LD_INT 1
74176: PPUSH
74177: LD_VAR 0 9
74181: PPUSH
74182: CALL_OW 2
74186: ST_TO_ADDR
74187: GO 74218
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74189: LD_ADDR_VAR 0 19
74193: PUSH
74194: LD_VAR 0 19
74198: PPUSH
74199: LD_VAR 0 19
74203: PUSH
74204: LD_INT 1
74206: PLUS
74207: PPUSH
74208: LD_VAR 0 9
74212: PPUSH
74213: CALL_OW 2
74217: ST_TO_ADDR
74218: GO 74146
74220: POP
74221: POP
// if tmp then
74222: LD_VAR 0 19
74226: IFFALSE 74238
// f := tmp ;
74228: LD_ADDR_VAR 0 12
74232: PUSH
74233: LD_VAR 0 19
74237: ST_TO_ADDR
// end ; x := personel [ i ] ;
74238: LD_ADDR_VAR 0 13
74242: PUSH
74243: LD_VAR 0 6
74247: PUSH
74248: LD_VAR 0 8
74252: ARRAY
74253: ST_TO_ADDR
// if x = - 1 then
74254: LD_VAR 0 13
74258: PUSH
74259: LD_INT 1
74261: NEG
74262: EQUAL
74263: IFFALSE 74472
// begin for j in f do
74265: LD_ADDR_VAR 0 9
74269: PUSH
74270: LD_VAR 0 12
74274: PUSH
74275: FOR_IN
74276: IFFALSE 74468
// repeat InitHc ;
74278: CALL_OW 19
// if GetBType ( j ) = b_barracks then
74282: LD_VAR 0 9
74286: PPUSH
74287: CALL_OW 266
74291: PUSH
74292: LD_INT 5
74294: EQUAL
74295: IFFALSE 74365
// begin if UnitsInside ( j ) < 3 then
74297: LD_VAR 0 9
74301: PPUSH
74302: CALL_OW 313
74306: PUSH
74307: LD_INT 3
74309: LESS
74310: IFFALSE 74346
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74312: LD_INT 0
74314: PPUSH
74315: LD_INT 5
74317: PUSH
74318: LD_INT 8
74320: PUSH
74321: LD_INT 9
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: LIST
74328: PUSH
74329: LD_VAR 0 17
74333: ARRAY
74334: PPUSH
74335: LD_VAR 0 4
74339: PPUSH
74340: CALL_OW 380
74344: GO 74363
// PrepareHuman ( false , i , skill ) ;
74346: LD_INT 0
74348: PPUSH
74349: LD_VAR 0 8
74353: PPUSH
74354: LD_VAR 0 4
74358: PPUSH
74359: CALL_OW 380
// end else
74363: GO 74382
// PrepareHuman ( false , i , skill ) ;
74365: LD_INT 0
74367: PPUSH
74368: LD_VAR 0 8
74372: PPUSH
74373: LD_VAR 0 4
74377: PPUSH
74378: CALL_OW 380
// un := CreateHuman ;
74382: LD_ADDR_VAR 0 14
74386: PUSH
74387: CALL_OW 44
74391: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74392: LD_ADDR_VAR 0 7
74396: PUSH
74397: LD_VAR 0 7
74401: PPUSH
74402: LD_INT 1
74404: PPUSH
74405: LD_VAR 0 14
74409: PPUSH
74410: CALL_OW 2
74414: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74415: LD_VAR 0 14
74419: PPUSH
74420: LD_VAR 0 9
74424: PPUSH
74425: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74429: LD_VAR 0 9
74433: PPUSH
74434: CALL_OW 313
74438: PUSH
74439: LD_INT 6
74441: EQUAL
74442: PUSH
74443: LD_VAR 0 9
74447: PPUSH
74448: CALL_OW 266
74452: PUSH
74453: LD_INT 32
74455: PUSH
74456: LD_INT 31
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: IN
74463: OR
74464: IFFALSE 74278
74466: GO 74275
74468: POP
74469: POP
// end else
74470: GO 74852
// for j = 1 to x do
74472: LD_ADDR_VAR 0 9
74476: PUSH
74477: DOUBLE
74478: LD_INT 1
74480: DEC
74481: ST_TO_ADDR
74482: LD_VAR 0 13
74486: PUSH
74487: FOR_TO
74488: IFFALSE 74850
// begin InitHc ;
74490: CALL_OW 19
// if not f then
74494: LD_VAR 0 12
74498: NOT
74499: IFFALSE 74588
// begin PrepareHuman ( false , i , skill ) ;
74501: LD_INT 0
74503: PPUSH
74504: LD_VAR 0 8
74508: PPUSH
74509: LD_VAR 0 4
74513: PPUSH
74514: CALL_OW 380
// un := CreateHuman ;
74518: LD_ADDR_VAR 0 14
74522: PUSH
74523: CALL_OW 44
74527: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74528: LD_ADDR_VAR 0 7
74532: PUSH
74533: LD_VAR 0 7
74537: PPUSH
74538: LD_INT 1
74540: PPUSH
74541: LD_VAR 0 14
74545: PPUSH
74546: CALL_OW 2
74550: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74551: LD_VAR 0 14
74555: PPUSH
74556: LD_VAR 0 1
74560: PPUSH
74561: CALL_OW 250
74565: PPUSH
74566: LD_VAR 0 1
74570: PPUSH
74571: CALL_OW 251
74575: PPUSH
74576: LD_INT 10
74578: PPUSH
74579: LD_INT 0
74581: PPUSH
74582: CALL_OW 50
// continue ;
74586: GO 74487
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74588: LD_VAR 0 12
74592: PUSH
74593: LD_INT 1
74595: ARRAY
74596: PPUSH
74597: CALL_OW 313
74601: PUSH
74602: LD_VAR 0 12
74606: PUSH
74607: LD_INT 1
74609: ARRAY
74610: PPUSH
74611: CALL_OW 266
74615: PUSH
74616: LD_INT 32
74618: PUSH
74619: LD_INT 31
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: IN
74626: AND
74627: PUSH
74628: LD_VAR 0 12
74632: PUSH
74633: LD_INT 1
74635: ARRAY
74636: PPUSH
74637: CALL_OW 313
74641: PUSH
74642: LD_INT 6
74644: EQUAL
74645: OR
74646: IFFALSE 74666
// f := Delete ( f , 1 ) ;
74648: LD_ADDR_VAR 0 12
74652: PUSH
74653: LD_VAR 0 12
74657: PPUSH
74658: LD_INT 1
74660: PPUSH
74661: CALL_OW 3
74665: ST_TO_ADDR
// if not f then
74666: LD_VAR 0 12
74670: NOT
74671: IFFALSE 74689
// begin x := x + 2 ;
74673: LD_ADDR_VAR 0 13
74677: PUSH
74678: LD_VAR 0 13
74682: PUSH
74683: LD_INT 2
74685: PLUS
74686: ST_TO_ADDR
// continue ;
74687: GO 74487
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74689: LD_VAR 0 12
74693: PUSH
74694: LD_INT 1
74696: ARRAY
74697: PPUSH
74698: CALL_OW 266
74702: PUSH
74703: LD_INT 5
74705: EQUAL
74706: IFFALSE 74780
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74708: LD_VAR 0 12
74712: PUSH
74713: LD_INT 1
74715: ARRAY
74716: PPUSH
74717: CALL_OW 313
74721: PUSH
74722: LD_INT 3
74724: LESS
74725: IFFALSE 74761
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74727: LD_INT 0
74729: PPUSH
74730: LD_INT 5
74732: PUSH
74733: LD_INT 8
74735: PUSH
74736: LD_INT 9
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: LIST
74743: PUSH
74744: LD_VAR 0 17
74748: ARRAY
74749: PPUSH
74750: LD_VAR 0 4
74754: PPUSH
74755: CALL_OW 380
74759: GO 74778
// PrepareHuman ( false , i , skill ) ;
74761: LD_INT 0
74763: PPUSH
74764: LD_VAR 0 8
74768: PPUSH
74769: LD_VAR 0 4
74773: PPUSH
74774: CALL_OW 380
// end else
74778: GO 74797
// PrepareHuman ( false , i , skill ) ;
74780: LD_INT 0
74782: PPUSH
74783: LD_VAR 0 8
74787: PPUSH
74788: LD_VAR 0 4
74792: PPUSH
74793: CALL_OW 380
// un := CreateHuman ;
74797: LD_ADDR_VAR 0 14
74801: PUSH
74802: CALL_OW 44
74806: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74807: LD_ADDR_VAR 0 7
74811: PUSH
74812: LD_VAR 0 7
74816: PPUSH
74817: LD_INT 1
74819: PPUSH
74820: LD_VAR 0 14
74824: PPUSH
74825: CALL_OW 2
74829: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74830: LD_VAR 0 14
74834: PPUSH
74835: LD_VAR 0 12
74839: PUSH
74840: LD_INT 1
74842: ARRAY
74843: PPUSH
74844: CALL_OW 52
// end ;
74848: GO 74487
74850: POP
74851: POP
// end ;
74852: GO 73789
74854: POP
74855: POP
// result := result ^ buildings ;
74856: LD_ADDR_VAR 0 7
74860: PUSH
74861: LD_VAR 0 7
74865: PUSH
74866: LD_VAR 0 18
74870: ADD
74871: ST_TO_ADDR
// end else
74872: GO 75015
// begin for i = 1 to personel do
74874: LD_ADDR_VAR 0 8
74878: PUSH
74879: DOUBLE
74880: LD_INT 1
74882: DEC
74883: ST_TO_ADDR
74884: LD_VAR 0 6
74888: PUSH
74889: FOR_TO
74890: IFFALSE 75013
// begin if i > 4 then
74892: LD_VAR 0 8
74896: PUSH
74897: LD_INT 4
74899: GREATER
74900: IFFALSE 74904
// break ;
74902: GO 75013
// x := personel [ i ] ;
74904: LD_ADDR_VAR 0 13
74908: PUSH
74909: LD_VAR 0 6
74913: PUSH
74914: LD_VAR 0 8
74918: ARRAY
74919: ST_TO_ADDR
// if x = - 1 then
74920: LD_VAR 0 13
74924: PUSH
74925: LD_INT 1
74927: NEG
74928: EQUAL
74929: IFFALSE 74933
// continue ;
74931: GO 74889
// PrepareHuman ( false , i , skill ) ;
74933: LD_INT 0
74935: PPUSH
74936: LD_VAR 0 8
74940: PPUSH
74941: LD_VAR 0 4
74945: PPUSH
74946: CALL_OW 380
// un := CreateHuman ;
74950: LD_ADDR_VAR 0 14
74954: PUSH
74955: CALL_OW 44
74959: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74960: LD_VAR 0 14
74964: PPUSH
74965: LD_VAR 0 1
74969: PPUSH
74970: CALL_OW 250
74974: PPUSH
74975: LD_VAR 0 1
74979: PPUSH
74980: CALL_OW 251
74984: PPUSH
74985: LD_INT 10
74987: PPUSH
74988: LD_INT 0
74990: PPUSH
74991: CALL_OW 50
// result := result ^ un ;
74995: LD_ADDR_VAR 0 7
74999: PUSH
75000: LD_VAR 0 7
75004: PUSH
75005: LD_VAR 0 14
75009: ADD
75010: ST_TO_ADDR
// end ;
75011: GO 74889
75013: POP
75014: POP
// end ; end ;
75015: LD_VAR 0 7
75019: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75020: LD_INT 0
75022: PPUSH
75023: PPUSH
75024: PPUSH
75025: PPUSH
75026: PPUSH
75027: PPUSH
75028: PPUSH
75029: PPUSH
75030: PPUSH
75031: PPUSH
75032: PPUSH
75033: PPUSH
75034: PPUSH
75035: PPUSH
75036: PPUSH
75037: PPUSH
// result := false ;
75038: LD_ADDR_VAR 0 3
75042: PUSH
75043: LD_INT 0
75045: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75046: LD_VAR 0 1
75050: NOT
75051: PUSH
75052: LD_VAR 0 1
75056: PPUSH
75057: CALL_OW 266
75061: PUSH
75062: LD_INT 32
75064: PUSH
75065: LD_INT 33
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: IN
75072: NOT
75073: OR
75074: IFFALSE 75078
// exit ;
75076: GO 76214
// nat := GetNation ( tower ) ;
75078: LD_ADDR_VAR 0 12
75082: PUSH
75083: LD_VAR 0 1
75087: PPUSH
75088: CALL_OW 248
75092: ST_TO_ADDR
// side := GetSide ( tower ) ;
75093: LD_ADDR_VAR 0 16
75097: PUSH
75098: LD_VAR 0 1
75102: PPUSH
75103: CALL_OW 255
75107: ST_TO_ADDR
// x := GetX ( tower ) ;
75108: LD_ADDR_VAR 0 10
75112: PUSH
75113: LD_VAR 0 1
75117: PPUSH
75118: CALL_OW 250
75122: ST_TO_ADDR
// y := GetY ( tower ) ;
75123: LD_ADDR_VAR 0 11
75127: PUSH
75128: LD_VAR 0 1
75132: PPUSH
75133: CALL_OW 251
75137: ST_TO_ADDR
// if not x or not y then
75138: LD_VAR 0 10
75142: NOT
75143: PUSH
75144: LD_VAR 0 11
75148: NOT
75149: OR
75150: IFFALSE 75154
// exit ;
75152: GO 76214
// weapon := 0 ;
75154: LD_ADDR_VAR 0 18
75158: PUSH
75159: LD_INT 0
75161: ST_TO_ADDR
// fac_list := [ ] ;
75162: LD_ADDR_VAR 0 17
75166: PUSH
75167: EMPTY
75168: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75169: LD_ADDR_VAR 0 6
75173: PUSH
75174: LD_VAR 0 1
75178: PPUSH
75179: CALL_OW 274
75183: PPUSH
75184: LD_VAR 0 2
75188: PPUSH
75189: CALL 72792 0 2
75193: PPUSH
75194: LD_INT 30
75196: PUSH
75197: LD_INT 3
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PPUSH
75204: CALL_OW 72
75208: ST_TO_ADDR
// if not factories then
75209: LD_VAR 0 6
75213: NOT
75214: IFFALSE 75218
// exit ;
75216: GO 76214
// for i in factories do
75218: LD_ADDR_VAR 0 8
75222: PUSH
75223: LD_VAR 0 6
75227: PUSH
75228: FOR_IN
75229: IFFALSE 75254
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75231: LD_ADDR_VAR 0 17
75235: PUSH
75236: LD_VAR 0 17
75240: PUSH
75241: LD_VAR 0 8
75245: PPUSH
75246: CALL_OW 478
75250: UNION
75251: ST_TO_ADDR
75252: GO 75228
75254: POP
75255: POP
// if not fac_list then
75256: LD_VAR 0 17
75260: NOT
75261: IFFALSE 75265
// exit ;
75263: GO 76214
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
75265: LD_ADDR_VAR 0 5
75269: PUSH
75270: LD_INT 4
75272: PUSH
75273: LD_INT 5
75275: PUSH
75276: LD_INT 9
75278: PUSH
75279: LD_INT 10
75281: PUSH
75282: LD_INT 6
75284: PUSH
75285: LD_INT 7
75287: PUSH
75288: LD_INT 11
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 27
75302: PUSH
75303: LD_INT 28
75305: PUSH
75306: LD_INT 26
75308: PUSH
75309: LD_INT 30
75311: PUSH
75312: EMPTY
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 43
75320: PUSH
75321: LD_INT 44
75323: PUSH
75324: LD_INT 46
75326: PUSH
75327: LD_INT 45
75329: PUSH
75330: LD_INT 47
75332: PUSH
75333: LD_INT 49
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: LIST
75342: LIST
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: LIST
75348: PUSH
75349: LD_VAR 0 12
75353: ARRAY
75354: ST_TO_ADDR
// for i in list do
75355: LD_ADDR_VAR 0 8
75359: PUSH
75360: LD_VAR 0 5
75364: PUSH
75365: FOR_IN
75366: IFFALSE 75399
// if not i in fac_list then
75368: LD_VAR 0 8
75372: PUSH
75373: LD_VAR 0 17
75377: IN
75378: NOT
75379: IFFALSE 75397
// list := list diff i ;
75381: LD_ADDR_VAR 0 5
75385: PUSH
75386: LD_VAR 0 5
75390: PUSH
75391: LD_VAR 0 8
75395: DIFF
75396: ST_TO_ADDR
75397: GO 75365
75399: POP
75400: POP
// if not list then
75401: LD_VAR 0 5
75405: NOT
75406: IFFALSE 75410
// exit ;
75408: GO 76214
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75410: LD_VAR 0 12
75414: PUSH
75415: LD_INT 3
75417: EQUAL
75418: PUSH
75419: LD_INT 49
75421: PUSH
75422: LD_VAR 0 5
75426: IN
75427: AND
75428: PUSH
75429: LD_INT 31
75431: PPUSH
75432: LD_VAR 0 16
75436: PPUSH
75437: CALL_OW 321
75441: PUSH
75442: LD_INT 2
75444: EQUAL
75445: AND
75446: IFFALSE 75506
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75448: LD_INT 22
75450: PUSH
75451: LD_VAR 0 16
75455: PUSH
75456: EMPTY
75457: LIST
75458: LIST
75459: PUSH
75460: LD_INT 35
75462: PUSH
75463: LD_INT 49
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 91
75472: PUSH
75473: LD_VAR 0 1
75477: PUSH
75478: LD_INT 10
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: LIST
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: LIST
75490: PPUSH
75491: CALL_OW 69
75495: NOT
75496: IFFALSE 75506
// weapon := ru_time_lapser ;
75498: LD_ADDR_VAR 0 18
75502: PUSH
75503: LD_INT 49
75505: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75506: LD_VAR 0 12
75510: PUSH
75511: LD_INT 1
75513: PUSH
75514: LD_INT 2
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: IN
75521: PUSH
75522: LD_INT 11
75524: PUSH
75525: LD_VAR 0 5
75529: IN
75530: PUSH
75531: LD_INT 30
75533: PUSH
75534: LD_VAR 0 5
75538: IN
75539: OR
75540: AND
75541: PUSH
75542: LD_INT 6
75544: PPUSH
75545: LD_VAR 0 16
75549: PPUSH
75550: CALL_OW 321
75554: PUSH
75555: LD_INT 2
75557: EQUAL
75558: AND
75559: IFFALSE 75724
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75561: LD_INT 22
75563: PUSH
75564: LD_VAR 0 16
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 2
75575: PUSH
75576: LD_INT 35
75578: PUSH
75579: LD_INT 11
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 35
75588: PUSH
75589: LD_INT 30
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: LIST
75600: PUSH
75601: LD_INT 91
75603: PUSH
75604: LD_VAR 0 1
75608: PUSH
75609: LD_INT 18
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: LIST
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: LIST
75621: PPUSH
75622: CALL_OW 69
75626: NOT
75627: PUSH
75628: LD_INT 22
75630: PUSH
75631: LD_VAR 0 16
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 2
75642: PUSH
75643: LD_INT 30
75645: PUSH
75646: LD_INT 32
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 30
75655: PUSH
75656: LD_INT 33
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: EMPTY
75664: LIST
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 91
75670: PUSH
75671: LD_VAR 0 1
75675: PUSH
75676: LD_INT 12
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: LIST
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: LIST
75688: PUSH
75689: EMPTY
75690: LIST
75691: PPUSH
75692: CALL_OW 69
75696: PUSH
75697: LD_INT 2
75699: GREATER
75700: AND
75701: IFFALSE 75724
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75703: LD_ADDR_VAR 0 18
75707: PUSH
75708: LD_INT 11
75710: PUSH
75711: LD_INT 30
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_VAR 0 12
75722: ARRAY
75723: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75724: LD_VAR 0 18
75728: NOT
75729: PUSH
75730: LD_INT 40
75732: PPUSH
75733: LD_VAR 0 16
75737: PPUSH
75738: CALL_OW 321
75742: PUSH
75743: LD_INT 2
75745: EQUAL
75746: AND
75747: PUSH
75748: LD_INT 7
75750: PUSH
75751: LD_VAR 0 5
75755: IN
75756: PUSH
75757: LD_INT 28
75759: PUSH
75760: LD_VAR 0 5
75764: IN
75765: OR
75766: PUSH
75767: LD_INT 45
75769: PUSH
75770: LD_VAR 0 5
75774: IN
75775: OR
75776: AND
75777: IFFALSE 76031
// begin hex := GetHexInfo ( x , y ) ;
75779: LD_ADDR_VAR 0 4
75783: PUSH
75784: LD_VAR 0 10
75788: PPUSH
75789: LD_VAR 0 11
75793: PPUSH
75794: CALL_OW 546
75798: ST_TO_ADDR
// if hex [ 1 ] then
75799: LD_VAR 0 4
75803: PUSH
75804: LD_INT 1
75806: ARRAY
75807: IFFALSE 75811
// exit ;
75809: GO 76214
// height := hex [ 2 ] ;
75811: LD_ADDR_VAR 0 15
75815: PUSH
75816: LD_VAR 0 4
75820: PUSH
75821: LD_INT 2
75823: ARRAY
75824: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75825: LD_ADDR_VAR 0 14
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: LD_INT 2
75835: PUSH
75836: LD_INT 3
75838: PUSH
75839: LD_INT 5
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: ST_TO_ADDR
// for i in tmp do
75848: LD_ADDR_VAR 0 8
75852: PUSH
75853: LD_VAR 0 14
75857: PUSH
75858: FOR_IN
75859: IFFALSE 76029
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75861: LD_ADDR_VAR 0 9
75865: PUSH
75866: LD_VAR 0 10
75870: PPUSH
75871: LD_VAR 0 8
75875: PPUSH
75876: LD_INT 5
75878: PPUSH
75879: CALL_OW 272
75883: PUSH
75884: LD_VAR 0 11
75888: PPUSH
75889: LD_VAR 0 8
75893: PPUSH
75894: LD_INT 5
75896: PPUSH
75897: CALL_OW 273
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75906: LD_VAR 0 9
75910: PUSH
75911: LD_INT 1
75913: ARRAY
75914: PPUSH
75915: LD_VAR 0 9
75919: PUSH
75920: LD_INT 2
75922: ARRAY
75923: PPUSH
75924: CALL_OW 488
75928: IFFALSE 76027
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75930: LD_ADDR_VAR 0 4
75934: PUSH
75935: LD_VAR 0 9
75939: PUSH
75940: LD_INT 1
75942: ARRAY
75943: PPUSH
75944: LD_VAR 0 9
75948: PUSH
75949: LD_INT 2
75951: ARRAY
75952: PPUSH
75953: CALL_OW 546
75957: ST_TO_ADDR
// if hex [ 1 ] then
75958: LD_VAR 0 4
75962: PUSH
75963: LD_INT 1
75965: ARRAY
75966: IFFALSE 75970
// continue ;
75968: GO 75858
// h := hex [ 2 ] ;
75970: LD_ADDR_VAR 0 13
75974: PUSH
75975: LD_VAR 0 4
75979: PUSH
75980: LD_INT 2
75982: ARRAY
75983: ST_TO_ADDR
// if h + 7 < height then
75984: LD_VAR 0 13
75988: PUSH
75989: LD_INT 7
75991: PLUS
75992: PUSH
75993: LD_VAR 0 15
75997: LESS
75998: IFFALSE 76027
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76000: LD_ADDR_VAR 0 18
76004: PUSH
76005: LD_INT 7
76007: PUSH
76008: LD_INT 28
76010: PUSH
76011: LD_INT 45
76013: PUSH
76014: EMPTY
76015: LIST
76016: LIST
76017: LIST
76018: PUSH
76019: LD_VAR 0 12
76023: ARRAY
76024: ST_TO_ADDR
// break ;
76025: GO 76029
// end ; end ; end ;
76027: GO 75858
76029: POP
76030: POP
// end ; if not weapon then
76031: LD_VAR 0 18
76035: NOT
76036: IFFALSE 76096
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76038: LD_ADDR_VAR 0 5
76042: PUSH
76043: LD_VAR 0 5
76047: PUSH
76048: LD_INT 11
76050: PUSH
76051: LD_INT 30
76053: PUSH
76054: LD_INT 49
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: LIST
76061: DIFF
76062: ST_TO_ADDR
// if not list then
76063: LD_VAR 0 5
76067: NOT
76068: IFFALSE 76072
// exit ;
76070: GO 76214
// weapon := list [ rand ( 1 , list ) ] ;
76072: LD_ADDR_VAR 0 18
76076: PUSH
76077: LD_VAR 0 5
76081: PUSH
76082: LD_INT 1
76084: PPUSH
76085: LD_VAR 0 5
76089: PPUSH
76090: CALL_OW 12
76094: ARRAY
76095: ST_TO_ADDR
// end ; if weapon then
76096: LD_VAR 0 18
76100: IFFALSE 76214
// begin tmp := CostOfWeapon ( weapon ) ;
76102: LD_ADDR_VAR 0 14
76106: PUSH
76107: LD_VAR 0 18
76111: PPUSH
76112: CALL_OW 451
76116: ST_TO_ADDR
// j := GetBase ( tower ) ;
76117: LD_ADDR_VAR 0 9
76121: PUSH
76122: LD_VAR 0 1
76126: PPUSH
76127: CALL_OW 274
76131: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76132: LD_VAR 0 9
76136: PPUSH
76137: LD_INT 1
76139: PPUSH
76140: CALL_OW 275
76144: PUSH
76145: LD_VAR 0 14
76149: PUSH
76150: LD_INT 1
76152: ARRAY
76153: GREATEREQUAL
76154: PUSH
76155: LD_VAR 0 9
76159: PPUSH
76160: LD_INT 2
76162: PPUSH
76163: CALL_OW 275
76167: PUSH
76168: LD_VAR 0 14
76172: PUSH
76173: LD_INT 2
76175: ARRAY
76176: GREATEREQUAL
76177: AND
76178: PUSH
76179: LD_VAR 0 9
76183: PPUSH
76184: LD_INT 3
76186: PPUSH
76187: CALL_OW 275
76191: PUSH
76192: LD_VAR 0 14
76196: PUSH
76197: LD_INT 3
76199: ARRAY
76200: GREATEREQUAL
76201: AND
76202: IFFALSE 76214
// result := weapon ;
76204: LD_ADDR_VAR 0 3
76208: PUSH
76209: LD_VAR 0 18
76213: ST_TO_ADDR
// end ; end ;
76214: LD_VAR 0 3
76218: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76219: LD_INT 0
76221: PPUSH
76222: PPUSH
// result := true ;
76223: LD_ADDR_VAR 0 3
76227: PUSH
76228: LD_INT 1
76230: ST_TO_ADDR
// if array1 = array2 then
76231: LD_VAR 0 1
76235: PUSH
76236: LD_VAR 0 2
76240: EQUAL
76241: IFFALSE 76301
// begin for i = 1 to array1 do
76243: LD_ADDR_VAR 0 4
76247: PUSH
76248: DOUBLE
76249: LD_INT 1
76251: DEC
76252: ST_TO_ADDR
76253: LD_VAR 0 1
76257: PUSH
76258: FOR_TO
76259: IFFALSE 76297
// if array1 [ i ] <> array2 [ i ] then
76261: LD_VAR 0 1
76265: PUSH
76266: LD_VAR 0 4
76270: ARRAY
76271: PUSH
76272: LD_VAR 0 2
76276: PUSH
76277: LD_VAR 0 4
76281: ARRAY
76282: NONEQUAL
76283: IFFALSE 76295
// begin result := false ;
76285: LD_ADDR_VAR 0 3
76289: PUSH
76290: LD_INT 0
76292: ST_TO_ADDR
// break ;
76293: GO 76297
// end ;
76295: GO 76258
76297: POP
76298: POP
// end else
76299: GO 76309
// result := false ;
76301: LD_ADDR_VAR 0 3
76305: PUSH
76306: LD_INT 0
76308: ST_TO_ADDR
// end ;
76309: LD_VAR 0 3
76313: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
76314: LD_INT 0
76316: PPUSH
76317: PPUSH
76318: PPUSH
// pom := GetBase ( fac ) ;
76319: LD_ADDR_VAR 0 5
76323: PUSH
76324: LD_VAR 0 1
76328: PPUSH
76329: CALL_OW 274
76333: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
76334: LD_ADDR_VAR 0 4
76338: PUSH
76339: LD_VAR 0 2
76343: PUSH
76344: LD_INT 1
76346: ARRAY
76347: PPUSH
76348: LD_VAR 0 2
76352: PUSH
76353: LD_INT 2
76355: ARRAY
76356: PPUSH
76357: LD_VAR 0 2
76361: PUSH
76362: LD_INT 3
76364: ARRAY
76365: PPUSH
76366: LD_VAR 0 2
76370: PUSH
76371: LD_INT 4
76373: ARRAY
76374: PPUSH
76375: CALL_OW 449
76379: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76380: LD_ADDR_VAR 0 3
76384: PUSH
76385: LD_VAR 0 5
76389: PPUSH
76390: LD_INT 1
76392: PPUSH
76393: CALL_OW 275
76397: PUSH
76398: LD_VAR 0 4
76402: PUSH
76403: LD_INT 1
76405: ARRAY
76406: GREATEREQUAL
76407: PUSH
76408: LD_VAR 0 5
76412: PPUSH
76413: LD_INT 2
76415: PPUSH
76416: CALL_OW 275
76420: PUSH
76421: LD_VAR 0 4
76425: PUSH
76426: LD_INT 2
76428: ARRAY
76429: GREATEREQUAL
76430: AND
76431: PUSH
76432: LD_VAR 0 5
76436: PPUSH
76437: LD_INT 3
76439: PPUSH
76440: CALL_OW 275
76444: PUSH
76445: LD_VAR 0 4
76449: PUSH
76450: LD_INT 3
76452: ARRAY
76453: GREATEREQUAL
76454: AND
76455: ST_TO_ADDR
// end ;
76456: LD_VAR 0 3
76460: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76461: LD_INT 0
76463: PPUSH
76464: PPUSH
76465: PPUSH
76466: PPUSH
// pom := GetBase ( building ) ;
76467: LD_ADDR_VAR 0 3
76471: PUSH
76472: LD_VAR 0 1
76476: PPUSH
76477: CALL_OW 274
76481: ST_TO_ADDR
// if not pom then
76482: LD_VAR 0 3
76486: NOT
76487: IFFALSE 76491
// exit ;
76489: GO 76661
// btype := GetBType ( building ) ;
76491: LD_ADDR_VAR 0 5
76495: PUSH
76496: LD_VAR 0 1
76500: PPUSH
76501: CALL_OW 266
76505: ST_TO_ADDR
// if btype = b_armoury then
76506: LD_VAR 0 5
76510: PUSH
76511: LD_INT 4
76513: EQUAL
76514: IFFALSE 76524
// btype := b_barracks ;
76516: LD_ADDR_VAR 0 5
76520: PUSH
76521: LD_INT 5
76523: ST_TO_ADDR
// if btype = b_depot then
76524: LD_VAR 0 5
76528: PUSH
76529: LD_INT 0
76531: EQUAL
76532: IFFALSE 76542
// btype := b_warehouse ;
76534: LD_ADDR_VAR 0 5
76538: PUSH
76539: LD_INT 1
76541: ST_TO_ADDR
// if btype = b_workshop then
76542: LD_VAR 0 5
76546: PUSH
76547: LD_INT 2
76549: EQUAL
76550: IFFALSE 76560
// btype := b_factory ;
76552: LD_ADDR_VAR 0 5
76556: PUSH
76557: LD_INT 3
76559: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76560: LD_ADDR_VAR 0 4
76564: PUSH
76565: LD_VAR 0 5
76569: PPUSH
76570: LD_VAR 0 1
76574: PPUSH
76575: CALL_OW 248
76579: PPUSH
76580: CALL_OW 450
76584: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76585: LD_ADDR_VAR 0 2
76589: PUSH
76590: LD_VAR 0 3
76594: PPUSH
76595: LD_INT 1
76597: PPUSH
76598: CALL_OW 275
76602: PUSH
76603: LD_VAR 0 4
76607: PUSH
76608: LD_INT 1
76610: ARRAY
76611: GREATEREQUAL
76612: PUSH
76613: LD_VAR 0 3
76617: PPUSH
76618: LD_INT 2
76620: PPUSH
76621: CALL_OW 275
76625: PUSH
76626: LD_VAR 0 4
76630: PUSH
76631: LD_INT 2
76633: ARRAY
76634: GREATEREQUAL
76635: AND
76636: PUSH
76637: LD_VAR 0 3
76641: PPUSH
76642: LD_INT 3
76644: PPUSH
76645: CALL_OW 275
76649: PUSH
76650: LD_VAR 0 4
76654: PUSH
76655: LD_INT 3
76657: ARRAY
76658: GREATEREQUAL
76659: AND
76660: ST_TO_ADDR
// end ;
76661: LD_VAR 0 2
76665: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76666: LD_INT 0
76668: PPUSH
76669: PPUSH
76670: PPUSH
// pom := GetBase ( building ) ;
76671: LD_ADDR_VAR 0 4
76675: PUSH
76676: LD_VAR 0 1
76680: PPUSH
76681: CALL_OW 274
76685: ST_TO_ADDR
// if not pom then
76686: LD_VAR 0 4
76690: NOT
76691: IFFALSE 76695
// exit ;
76693: GO 76796
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76695: LD_ADDR_VAR 0 5
76699: PUSH
76700: LD_VAR 0 2
76704: PPUSH
76705: LD_VAR 0 1
76709: PPUSH
76710: CALL_OW 248
76714: PPUSH
76715: CALL_OW 450
76719: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76720: LD_ADDR_VAR 0 3
76724: PUSH
76725: LD_VAR 0 4
76729: PPUSH
76730: LD_INT 1
76732: PPUSH
76733: CALL_OW 275
76737: PUSH
76738: LD_VAR 0 5
76742: PUSH
76743: LD_INT 1
76745: ARRAY
76746: GREATEREQUAL
76747: PUSH
76748: LD_VAR 0 4
76752: PPUSH
76753: LD_INT 2
76755: PPUSH
76756: CALL_OW 275
76760: PUSH
76761: LD_VAR 0 5
76765: PUSH
76766: LD_INT 2
76768: ARRAY
76769: GREATEREQUAL
76770: AND
76771: PUSH
76772: LD_VAR 0 4
76776: PPUSH
76777: LD_INT 3
76779: PPUSH
76780: CALL_OW 275
76784: PUSH
76785: LD_VAR 0 5
76789: PUSH
76790: LD_INT 3
76792: ARRAY
76793: GREATEREQUAL
76794: AND
76795: ST_TO_ADDR
// end ;
76796: LD_VAR 0 3
76800: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76801: LD_INT 0
76803: PPUSH
76804: PPUSH
76805: PPUSH
76806: PPUSH
76807: PPUSH
76808: PPUSH
76809: PPUSH
76810: PPUSH
76811: PPUSH
76812: PPUSH
// result := false ;
76813: LD_ADDR_VAR 0 6
76817: PUSH
76818: LD_INT 0
76820: ST_TO_ADDR
// if not base or not btype or not x or not y then
76821: LD_VAR 0 1
76825: NOT
76826: PUSH
76827: LD_VAR 0 2
76831: NOT
76832: OR
76833: PUSH
76834: LD_VAR 0 3
76838: NOT
76839: OR
76840: PUSH
76841: LD_VAR 0 4
76845: NOT
76846: OR
76847: IFFALSE 76851
// exit ;
76849: GO 77460
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76851: LD_ADDR_VAR 0 12
76855: PUSH
76856: LD_VAR 0 2
76860: PPUSH
76861: LD_VAR 0 3
76865: PPUSH
76866: LD_VAR 0 4
76870: PPUSH
76871: LD_VAR 0 5
76875: PPUSH
76876: LD_VAR 0 1
76880: PUSH
76881: LD_INT 1
76883: ARRAY
76884: PPUSH
76885: CALL_OW 248
76889: PPUSH
76890: LD_INT 0
76892: PPUSH
76893: CALL 78297 0 6
76897: ST_TO_ADDR
// if not hexes then
76898: LD_VAR 0 12
76902: NOT
76903: IFFALSE 76907
// exit ;
76905: GO 77460
// for i = 1 to hexes do
76907: LD_ADDR_VAR 0 7
76911: PUSH
76912: DOUBLE
76913: LD_INT 1
76915: DEC
76916: ST_TO_ADDR
76917: LD_VAR 0 12
76921: PUSH
76922: FOR_TO
76923: IFFALSE 77458
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76925: LD_ADDR_VAR 0 11
76929: PUSH
76930: LD_VAR 0 12
76934: PUSH
76935: LD_VAR 0 7
76939: ARRAY
76940: PUSH
76941: LD_INT 1
76943: ARRAY
76944: PPUSH
76945: LD_VAR 0 12
76949: PUSH
76950: LD_VAR 0 7
76954: ARRAY
76955: PUSH
76956: LD_INT 2
76958: ARRAY
76959: PPUSH
76960: CALL_OW 428
76964: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76965: LD_VAR 0 12
76969: PUSH
76970: LD_VAR 0 7
76974: ARRAY
76975: PUSH
76976: LD_INT 1
76978: ARRAY
76979: PPUSH
76980: LD_VAR 0 12
76984: PUSH
76985: LD_VAR 0 7
76989: ARRAY
76990: PUSH
76991: LD_INT 2
76993: ARRAY
76994: PPUSH
76995: CALL_OW 351
76999: PUSH
77000: LD_VAR 0 12
77004: PUSH
77005: LD_VAR 0 7
77009: ARRAY
77010: PUSH
77011: LD_INT 1
77013: ARRAY
77014: PPUSH
77015: LD_VAR 0 12
77019: PUSH
77020: LD_VAR 0 7
77024: ARRAY
77025: PUSH
77026: LD_INT 2
77028: ARRAY
77029: PPUSH
77030: CALL_OW 488
77034: NOT
77035: OR
77036: PUSH
77037: LD_VAR 0 11
77041: PPUSH
77042: CALL_OW 247
77046: PUSH
77047: LD_INT 3
77049: EQUAL
77050: OR
77051: IFFALSE 77057
// exit ;
77053: POP
77054: POP
77055: GO 77460
// if not tmp or not tmp in base then
77057: LD_VAR 0 11
77061: NOT
77062: PUSH
77063: LD_VAR 0 11
77067: PUSH
77068: LD_VAR 0 1
77072: IN
77073: NOT
77074: OR
77075: IFFALSE 77079
// continue ;
77077: GO 76922
// result := true ;
77079: LD_ADDR_VAR 0 6
77083: PUSH
77084: LD_INT 1
77086: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77087: LD_ADDR_VAR 0 15
77091: PUSH
77092: LD_VAR 0 1
77096: PPUSH
77097: LD_INT 22
77099: PUSH
77100: LD_VAR 0 11
77104: PPUSH
77105: CALL_OW 255
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PUSH
77114: LD_INT 2
77116: PUSH
77117: LD_INT 30
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 30
77129: PUSH
77130: LD_INT 1
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: LIST
77141: PUSH
77142: EMPTY
77143: LIST
77144: LIST
77145: PPUSH
77146: CALL_OW 72
77150: ST_TO_ADDR
// if dep then
77151: LD_VAR 0 15
77155: IFFALSE 77291
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77157: LD_ADDR_VAR 0 14
77161: PUSH
77162: LD_VAR 0 15
77166: PUSH
77167: LD_INT 1
77169: ARRAY
77170: PPUSH
77171: CALL_OW 250
77175: PPUSH
77176: LD_VAR 0 15
77180: PUSH
77181: LD_INT 1
77183: ARRAY
77184: PPUSH
77185: CALL_OW 254
77189: PPUSH
77190: LD_INT 5
77192: PPUSH
77193: CALL_OW 272
77197: PUSH
77198: LD_VAR 0 15
77202: PUSH
77203: LD_INT 1
77205: ARRAY
77206: PPUSH
77207: CALL_OW 251
77211: PPUSH
77212: LD_VAR 0 15
77216: PUSH
77217: LD_INT 1
77219: ARRAY
77220: PPUSH
77221: CALL_OW 254
77225: PPUSH
77226: LD_INT 5
77228: PPUSH
77229: CALL_OW 273
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77238: LD_VAR 0 14
77242: PUSH
77243: LD_INT 1
77245: ARRAY
77246: PPUSH
77247: LD_VAR 0 14
77251: PUSH
77252: LD_INT 2
77254: ARRAY
77255: PPUSH
77256: CALL_OW 488
77260: IFFALSE 77291
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
77262: LD_VAR 0 11
77266: PPUSH
77267: LD_VAR 0 14
77271: PUSH
77272: LD_INT 1
77274: ARRAY
77275: PPUSH
77276: LD_VAR 0 14
77280: PUSH
77281: LD_INT 2
77283: ARRAY
77284: PPUSH
77285: CALL_OW 111
// continue ;
77289: GO 76922
// end ; end ; r := GetDir ( tmp ) ;
77291: LD_ADDR_VAR 0 13
77295: PUSH
77296: LD_VAR 0 11
77300: PPUSH
77301: CALL_OW 254
77305: ST_TO_ADDR
// if r = 5 then
77306: LD_VAR 0 13
77310: PUSH
77311: LD_INT 5
77313: EQUAL
77314: IFFALSE 77324
// r := 0 ;
77316: LD_ADDR_VAR 0 13
77320: PUSH
77321: LD_INT 0
77323: ST_TO_ADDR
// for j = r to 5 do
77324: LD_ADDR_VAR 0 8
77328: PUSH
77329: DOUBLE
77330: LD_VAR 0 13
77334: DEC
77335: ST_TO_ADDR
77336: LD_INT 5
77338: PUSH
77339: FOR_TO
77340: IFFALSE 77454
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
77342: LD_ADDR_VAR 0 9
77346: PUSH
77347: LD_VAR 0 11
77351: PPUSH
77352: CALL_OW 250
77356: PPUSH
77357: LD_VAR 0 8
77361: PPUSH
77362: LD_INT 2
77364: PPUSH
77365: CALL_OW 272
77369: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
77370: LD_ADDR_VAR 0 10
77374: PUSH
77375: LD_VAR 0 11
77379: PPUSH
77380: CALL_OW 251
77384: PPUSH
77385: LD_VAR 0 8
77389: PPUSH
77390: LD_INT 2
77392: PPUSH
77393: CALL_OW 273
77397: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
77398: LD_VAR 0 9
77402: PPUSH
77403: LD_VAR 0 10
77407: PPUSH
77408: CALL_OW 488
77412: PUSH
77413: LD_VAR 0 9
77417: PPUSH
77418: LD_VAR 0 10
77422: PPUSH
77423: CALL_OW 428
77427: NOT
77428: AND
77429: IFFALSE 77452
// begin ComMoveXY ( tmp , _x , _y ) ;
77431: LD_VAR 0 11
77435: PPUSH
77436: LD_VAR 0 9
77440: PPUSH
77441: LD_VAR 0 10
77445: PPUSH
77446: CALL_OW 111
// break ;
77450: GO 77454
// end ; end ;
77452: GO 77339
77454: POP
77455: POP
// end ;
77456: GO 76922
77458: POP
77459: POP
// end ;
77460: LD_VAR 0 6
77464: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77465: LD_INT 0
77467: PPUSH
77468: PPUSH
77469: PPUSH
77470: PPUSH
77471: PPUSH
77472: PPUSH
77473: PPUSH
77474: PPUSH
77475: PPUSH
77476: PPUSH
// result := false ;
77477: LD_ADDR_VAR 0 6
77481: PUSH
77482: LD_INT 0
77484: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77485: LD_VAR 0 1
77489: NOT
77490: PUSH
77491: LD_VAR 0 1
77495: PPUSH
77496: CALL_OW 266
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 1
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: IN
77511: NOT
77512: OR
77513: PUSH
77514: LD_VAR 0 2
77518: NOT
77519: OR
77520: PUSH
77521: LD_VAR 0 5
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: LD_INT 1
77531: PUSH
77532: LD_INT 2
77534: PUSH
77535: LD_INT 3
77537: PUSH
77538: LD_INT 4
77540: PUSH
77541: LD_INT 5
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: IN
77552: NOT
77553: OR
77554: PUSH
77555: LD_VAR 0 3
77559: PPUSH
77560: LD_VAR 0 4
77564: PPUSH
77565: CALL_OW 488
77569: NOT
77570: OR
77571: IFFALSE 77575
// exit ;
77573: GO 78292
// pom := GetBase ( depot ) ;
77575: LD_ADDR_VAR 0 10
77579: PUSH
77580: LD_VAR 0 1
77584: PPUSH
77585: CALL_OW 274
77589: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77590: LD_ADDR_VAR 0 11
77594: PUSH
77595: LD_VAR 0 2
77599: PPUSH
77600: LD_VAR 0 1
77604: PPUSH
77605: CALL_OW 248
77609: PPUSH
77610: CALL_OW 450
77614: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77615: LD_VAR 0 10
77619: PPUSH
77620: LD_INT 1
77622: PPUSH
77623: CALL_OW 275
77627: PUSH
77628: LD_VAR 0 11
77632: PUSH
77633: LD_INT 1
77635: ARRAY
77636: GREATEREQUAL
77637: PUSH
77638: LD_VAR 0 10
77642: PPUSH
77643: LD_INT 2
77645: PPUSH
77646: CALL_OW 275
77650: PUSH
77651: LD_VAR 0 11
77655: PUSH
77656: LD_INT 2
77658: ARRAY
77659: GREATEREQUAL
77660: AND
77661: PUSH
77662: LD_VAR 0 10
77666: PPUSH
77667: LD_INT 3
77669: PPUSH
77670: CALL_OW 275
77674: PUSH
77675: LD_VAR 0 11
77679: PUSH
77680: LD_INT 3
77682: ARRAY
77683: GREATEREQUAL
77684: AND
77685: NOT
77686: IFFALSE 77690
// exit ;
77688: GO 78292
// if GetBType ( depot ) = b_depot then
77690: LD_VAR 0 1
77694: PPUSH
77695: CALL_OW 266
77699: PUSH
77700: LD_INT 0
77702: EQUAL
77703: IFFALSE 77715
// dist := 28 else
77705: LD_ADDR_VAR 0 14
77709: PUSH
77710: LD_INT 28
77712: ST_TO_ADDR
77713: GO 77723
// dist := 36 ;
77715: LD_ADDR_VAR 0 14
77719: PUSH
77720: LD_INT 36
77722: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77723: LD_VAR 0 1
77727: PPUSH
77728: LD_VAR 0 3
77732: PPUSH
77733: LD_VAR 0 4
77737: PPUSH
77738: CALL_OW 297
77742: PUSH
77743: LD_VAR 0 14
77747: GREATER
77748: IFFALSE 77752
// exit ;
77750: GO 78292
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77752: LD_ADDR_VAR 0 12
77756: PUSH
77757: LD_VAR 0 2
77761: PPUSH
77762: LD_VAR 0 3
77766: PPUSH
77767: LD_VAR 0 4
77771: PPUSH
77772: LD_VAR 0 5
77776: PPUSH
77777: LD_VAR 0 1
77781: PPUSH
77782: CALL_OW 248
77786: PPUSH
77787: LD_INT 0
77789: PPUSH
77790: CALL 78297 0 6
77794: ST_TO_ADDR
// if not hexes then
77795: LD_VAR 0 12
77799: NOT
77800: IFFALSE 77804
// exit ;
77802: GO 78292
// hex := GetHexInfo ( x , y ) ;
77804: LD_ADDR_VAR 0 15
77808: PUSH
77809: LD_VAR 0 3
77813: PPUSH
77814: LD_VAR 0 4
77818: PPUSH
77819: CALL_OW 546
77823: ST_TO_ADDR
// if hex [ 1 ] then
77824: LD_VAR 0 15
77828: PUSH
77829: LD_INT 1
77831: ARRAY
77832: IFFALSE 77836
// exit ;
77834: GO 78292
// height := hex [ 2 ] ;
77836: LD_ADDR_VAR 0 13
77840: PUSH
77841: LD_VAR 0 15
77845: PUSH
77846: LD_INT 2
77848: ARRAY
77849: ST_TO_ADDR
// for i = 1 to hexes do
77850: LD_ADDR_VAR 0 7
77854: PUSH
77855: DOUBLE
77856: LD_INT 1
77858: DEC
77859: ST_TO_ADDR
77860: LD_VAR 0 12
77864: PUSH
77865: FOR_TO
77866: IFFALSE 78196
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77868: LD_VAR 0 12
77872: PUSH
77873: LD_VAR 0 7
77877: ARRAY
77878: PUSH
77879: LD_INT 1
77881: ARRAY
77882: PPUSH
77883: LD_VAR 0 12
77887: PUSH
77888: LD_VAR 0 7
77892: ARRAY
77893: PUSH
77894: LD_INT 2
77896: ARRAY
77897: PPUSH
77898: CALL_OW 488
77902: NOT
77903: PUSH
77904: LD_VAR 0 12
77908: PUSH
77909: LD_VAR 0 7
77913: ARRAY
77914: PUSH
77915: LD_INT 1
77917: ARRAY
77918: PPUSH
77919: LD_VAR 0 12
77923: PUSH
77924: LD_VAR 0 7
77928: ARRAY
77929: PUSH
77930: LD_INT 2
77932: ARRAY
77933: PPUSH
77934: CALL_OW 428
77938: PUSH
77939: LD_INT 0
77941: GREATER
77942: OR
77943: PUSH
77944: LD_VAR 0 12
77948: PUSH
77949: LD_VAR 0 7
77953: ARRAY
77954: PUSH
77955: LD_INT 1
77957: ARRAY
77958: PPUSH
77959: LD_VAR 0 12
77963: PUSH
77964: LD_VAR 0 7
77968: ARRAY
77969: PUSH
77970: LD_INT 2
77972: ARRAY
77973: PPUSH
77974: CALL_OW 351
77978: OR
77979: IFFALSE 77985
// exit ;
77981: POP
77982: POP
77983: GO 78292
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77985: LD_ADDR_VAR 0 8
77989: PUSH
77990: LD_VAR 0 12
77994: PUSH
77995: LD_VAR 0 7
77999: ARRAY
78000: PUSH
78001: LD_INT 1
78003: ARRAY
78004: PPUSH
78005: LD_VAR 0 12
78009: PUSH
78010: LD_VAR 0 7
78014: ARRAY
78015: PUSH
78016: LD_INT 2
78018: ARRAY
78019: PPUSH
78020: CALL_OW 546
78024: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78025: LD_VAR 0 8
78029: PUSH
78030: LD_INT 1
78032: ARRAY
78033: PUSH
78034: LD_VAR 0 8
78038: PUSH
78039: LD_INT 2
78041: ARRAY
78042: PUSH
78043: LD_VAR 0 13
78047: PUSH
78048: LD_INT 2
78050: PLUS
78051: GREATER
78052: OR
78053: PUSH
78054: LD_VAR 0 8
78058: PUSH
78059: LD_INT 2
78061: ARRAY
78062: PUSH
78063: LD_VAR 0 13
78067: PUSH
78068: LD_INT 2
78070: MINUS
78071: LESS
78072: OR
78073: PUSH
78074: LD_VAR 0 8
78078: PUSH
78079: LD_INT 3
78081: ARRAY
78082: PUSH
78083: LD_INT 0
78085: PUSH
78086: LD_INT 8
78088: PUSH
78089: LD_INT 9
78091: PUSH
78092: LD_INT 10
78094: PUSH
78095: LD_INT 11
78097: PUSH
78098: LD_INT 12
78100: PUSH
78101: LD_INT 13
78103: PUSH
78104: LD_INT 16
78106: PUSH
78107: LD_INT 17
78109: PUSH
78110: LD_INT 18
78112: PUSH
78113: LD_INT 19
78115: PUSH
78116: LD_INT 20
78118: PUSH
78119: LD_INT 21
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: IN
78137: NOT
78138: OR
78139: PUSH
78140: LD_VAR 0 8
78144: PUSH
78145: LD_INT 5
78147: ARRAY
78148: NOT
78149: OR
78150: PUSH
78151: LD_VAR 0 8
78155: PUSH
78156: LD_INT 6
78158: ARRAY
78159: PUSH
78160: LD_INT 1
78162: PUSH
78163: LD_INT 2
78165: PUSH
78166: LD_INT 7
78168: PUSH
78169: LD_INT 9
78171: PUSH
78172: LD_INT 10
78174: PUSH
78175: LD_INT 11
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: IN
78186: NOT
78187: OR
78188: IFFALSE 78194
// exit ;
78190: POP
78191: POP
78192: GO 78292
// end ;
78194: GO 77865
78196: POP
78197: POP
// side := GetSide ( depot ) ;
78198: LD_ADDR_VAR 0 9
78202: PUSH
78203: LD_VAR 0 1
78207: PPUSH
78208: CALL_OW 255
78212: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78213: LD_VAR 0 9
78217: PPUSH
78218: LD_VAR 0 3
78222: PPUSH
78223: LD_VAR 0 4
78227: PPUSH
78228: LD_INT 20
78230: PPUSH
78231: CALL 70946 0 4
78235: PUSH
78236: LD_INT 4
78238: ARRAY
78239: IFFALSE 78243
// exit ;
78241: GO 78292
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78243: LD_VAR 0 2
78247: PUSH
78248: LD_INT 29
78250: PUSH
78251: LD_INT 30
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: IN
78258: PUSH
78259: LD_VAR 0 3
78263: PPUSH
78264: LD_VAR 0 4
78268: PPUSH
78269: LD_VAR 0 9
78273: PPUSH
78274: CALL_OW 440
78278: NOT
78279: AND
78280: IFFALSE 78284
// exit ;
78282: GO 78292
// result := true ;
78284: LD_ADDR_VAR 0 6
78288: PUSH
78289: LD_INT 1
78291: ST_TO_ADDR
// end ;
78292: LD_VAR 0 6
78296: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
78297: LD_INT 0
78299: PPUSH
78300: PPUSH
78301: PPUSH
78302: PPUSH
78303: PPUSH
78304: PPUSH
78305: PPUSH
78306: PPUSH
78307: PPUSH
78308: PPUSH
78309: PPUSH
78310: PPUSH
78311: PPUSH
78312: PPUSH
78313: PPUSH
78314: PPUSH
78315: PPUSH
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
78320: PPUSH
78321: PPUSH
78322: PPUSH
78323: PPUSH
78324: PPUSH
78325: PPUSH
78326: PPUSH
78327: PPUSH
78328: PPUSH
78329: PPUSH
78330: PPUSH
78331: PPUSH
78332: PPUSH
78333: PPUSH
78334: PPUSH
78335: PPUSH
78336: PPUSH
78337: PPUSH
78338: PPUSH
78339: PPUSH
78340: PPUSH
78341: PPUSH
78342: PPUSH
78343: PPUSH
78344: PPUSH
78345: PPUSH
78346: PPUSH
78347: PPUSH
78348: PPUSH
78349: PPUSH
78350: PPUSH
78351: PPUSH
78352: PPUSH
78353: PPUSH
78354: PPUSH
78355: PPUSH
78356: PPUSH
// result = [ ] ;
78357: LD_ADDR_VAR 0 7
78361: PUSH
78362: EMPTY
78363: ST_TO_ADDR
// temp_list = [ ] ;
78364: LD_ADDR_VAR 0 9
78368: PUSH
78369: EMPTY
78370: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
78371: LD_VAR 0 4
78375: PUSH
78376: LD_INT 0
78378: PUSH
78379: LD_INT 1
78381: PUSH
78382: LD_INT 2
78384: PUSH
78385: LD_INT 3
78387: PUSH
78388: LD_INT 4
78390: PUSH
78391: LD_INT 5
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: IN
78402: NOT
78403: PUSH
78404: LD_VAR 0 1
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: LD_INT 1
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: IN
78419: PUSH
78420: LD_VAR 0 5
78424: PUSH
78425: LD_INT 1
78427: PUSH
78428: LD_INT 2
78430: PUSH
78431: LD_INT 3
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: LIST
78438: IN
78439: NOT
78440: AND
78441: OR
78442: IFFALSE 78446
// exit ;
78444: GO 96837
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78446: LD_VAR 0 1
78450: PUSH
78451: LD_INT 6
78453: PUSH
78454: LD_INT 7
78456: PUSH
78457: LD_INT 8
78459: PUSH
78460: LD_INT 13
78462: PUSH
78463: LD_INT 12
78465: PUSH
78466: LD_INT 15
78468: PUSH
78469: LD_INT 11
78471: PUSH
78472: LD_INT 14
78474: PUSH
78475: LD_INT 10
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: LIST
78482: LIST
78483: LIST
78484: LIST
78485: LIST
78486: LIST
78487: LIST
78488: IN
78489: IFFALSE 78499
// btype = b_lab ;
78491: LD_ADDR_VAR 0 1
78495: PUSH
78496: LD_INT 6
78498: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78499: LD_VAR 0 6
78503: PUSH
78504: LD_INT 0
78506: PUSH
78507: LD_INT 1
78509: PUSH
78510: LD_INT 2
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: LIST
78517: IN
78518: NOT
78519: PUSH
78520: LD_VAR 0 1
78524: PUSH
78525: LD_INT 0
78527: PUSH
78528: LD_INT 1
78530: PUSH
78531: LD_INT 2
78533: PUSH
78534: LD_INT 3
78536: PUSH
78537: LD_INT 6
78539: PUSH
78540: LD_INT 36
78542: PUSH
78543: LD_INT 4
78545: PUSH
78546: LD_INT 5
78548: PUSH
78549: LD_INT 31
78551: PUSH
78552: LD_INT 32
78554: PUSH
78555: LD_INT 33
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: LIST
78562: LIST
78563: LIST
78564: LIST
78565: LIST
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: IN
78571: NOT
78572: PUSH
78573: LD_VAR 0 6
78577: PUSH
78578: LD_INT 1
78580: EQUAL
78581: AND
78582: OR
78583: PUSH
78584: LD_VAR 0 1
78588: PUSH
78589: LD_INT 2
78591: PUSH
78592: LD_INT 3
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: IN
78599: NOT
78600: PUSH
78601: LD_VAR 0 6
78605: PUSH
78606: LD_INT 2
78608: EQUAL
78609: AND
78610: OR
78611: IFFALSE 78621
// mode = 0 ;
78613: LD_ADDR_VAR 0 6
78617: PUSH
78618: LD_INT 0
78620: ST_TO_ADDR
// case mode of 0 :
78621: LD_VAR 0 6
78625: PUSH
78626: LD_INT 0
78628: DOUBLE
78629: EQUAL
78630: IFTRUE 78634
78632: GO 90087
78634: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78635: LD_ADDR_VAR 0 11
78639: PUSH
78640: LD_INT 0
78642: PUSH
78643: LD_INT 0
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 0
78652: PUSH
78653: LD_INT 1
78655: NEG
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 1
78663: PUSH
78664: LD_INT 0
78666: PUSH
78667: EMPTY
78668: LIST
78669: LIST
78670: PUSH
78671: LD_INT 1
78673: PUSH
78674: LD_INT 1
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 0
78683: PUSH
78684: LD_INT 1
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 1
78693: NEG
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: LD_INT 1
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: LD_INT 2
78720: NEG
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 0
78728: PUSH
78729: LD_INT 2
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 1
78739: PUSH
78740: LD_INT 1
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 1
78750: PUSH
78751: LD_INT 2
78753: PUSH
78754: EMPTY
78755: LIST
78756: LIST
78757: PUSH
78758: LD_INT 0
78760: PUSH
78761: LD_INT 2
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 1
78770: NEG
78771: PUSH
78772: LD_INT 1
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 1
78781: PUSH
78782: LD_INT 3
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: PUSH
78789: LD_INT 0
78791: PUSH
78792: LD_INT 3
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 1
78801: NEG
78802: PUSH
78803: LD_INT 2
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78828: LD_ADDR_VAR 0 12
78832: PUSH
78833: LD_INT 0
78835: PUSH
78836: LD_INT 0
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: LD_INT 1
78848: NEG
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 1
78856: PUSH
78857: LD_INT 0
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 1
78866: PUSH
78867: LD_INT 1
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: PUSH
78874: LD_INT 0
78876: PUSH
78877: LD_INT 1
78879: PUSH
78880: EMPTY
78881: LIST
78882: LIST
78883: PUSH
78884: LD_INT 1
78886: NEG
78887: PUSH
78888: LD_INT 0
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 1
78897: NEG
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 1
78909: PUSH
78910: LD_INT 1
78912: NEG
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 2
78920: PUSH
78921: LD_INT 0
78923: PUSH
78924: EMPTY
78925: LIST
78926: LIST
78927: PUSH
78928: LD_INT 2
78930: PUSH
78931: LD_INT 1
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 1
78940: NEG
78941: PUSH
78942: LD_INT 1
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 2
78951: NEG
78952: PUSH
78953: LD_INT 0
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 2
78962: NEG
78963: PUSH
78964: LD_INT 1
78966: NEG
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 2
78974: NEG
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: EMPTY
78980: LIST
78981: LIST
78982: PUSH
78983: LD_INT 3
78985: NEG
78986: PUSH
78987: LD_INT 0
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 3
78996: NEG
78997: PUSH
78998: LD_INT 1
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79024: LD_ADDR_VAR 0 13
79028: PUSH
79029: LD_INT 0
79031: PUSH
79032: LD_INT 0
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: LD_INT 0
79041: PUSH
79042: LD_INT 1
79044: NEG
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 1
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: EMPTY
79057: LIST
79058: LIST
79059: PUSH
79060: LD_INT 1
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 0
79072: PUSH
79073: LD_INT 1
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 1
79082: NEG
79083: PUSH
79084: LD_INT 0
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 1
79093: NEG
79094: PUSH
79095: LD_INT 1
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: LD_INT 1
79105: NEG
79106: PUSH
79107: LD_INT 2
79109: NEG
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 2
79117: PUSH
79118: LD_INT 1
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 2
79127: PUSH
79128: LD_INT 2
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: PUSH
79138: LD_INT 2
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 2
79147: NEG
79148: PUSH
79149: LD_INT 1
79151: NEG
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 2
79159: NEG
79160: PUSH
79161: LD_INT 2
79163: NEG
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 2
79171: NEG
79172: PUSH
79173: LD_INT 3
79175: NEG
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 3
79183: NEG
79184: PUSH
79185: LD_INT 2
79187: NEG
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 3
79195: NEG
79196: PUSH
79197: LD_INT 3
79199: NEG
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79223: LD_ADDR_VAR 0 14
79227: PUSH
79228: LD_INT 0
79230: PUSH
79231: LD_INT 0
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 0
79240: PUSH
79241: LD_INT 1
79243: NEG
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 1
79251: PUSH
79252: LD_INT 0
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 1
79261: PUSH
79262: LD_INT 1
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 0
79271: PUSH
79272: LD_INT 1
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 1
79281: NEG
79282: PUSH
79283: LD_INT 0
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 1
79292: NEG
79293: PUSH
79294: LD_INT 1
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 1
79304: NEG
79305: PUSH
79306: LD_INT 2
79308: NEG
79309: PUSH
79310: EMPTY
79311: LIST
79312: LIST
79313: PUSH
79314: LD_INT 0
79316: PUSH
79317: LD_INT 2
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 1
79327: PUSH
79328: LD_INT 1
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 2
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 0
79348: PUSH
79349: LD_INT 2
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: LD_INT 1
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 1
79369: NEG
79370: PUSH
79371: LD_INT 3
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 0
79381: PUSH
79382: LD_INT 3
79384: NEG
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: LD_INT 1
79392: PUSH
79393: LD_INT 2
79395: NEG
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79419: LD_ADDR_VAR 0 15
79423: PUSH
79424: LD_INT 0
79426: PUSH
79427: LD_INT 0
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: LD_INT 1
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 1
79447: PUSH
79448: LD_INT 0
79450: PUSH
79451: EMPTY
79452: LIST
79453: LIST
79454: PUSH
79455: LD_INT 1
79457: PUSH
79458: LD_INT 1
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 0
79467: PUSH
79468: LD_INT 1
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: PUSH
79475: LD_INT 1
79477: NEG
79478: PUSH
79479: LD_INT 0
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: LD_INT 1
79488: NEG
79489: PUSH
79490: LD_INT 1
79492: NEG
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: PUSH
79498: LD_INT 1
79500: PUSH
79501: LD_INT 1
79503: NEG
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 2
79511: PUSH
79512: LD_INT 0
79514: PUSH
79515: EMPTY
79516: LIST
79517: LIST
79518: PUSH
79519: LD_INT 2
79521: PUSH
79522: LD_INT 1
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PUSH
79529: LD_INT 1
79531: NEG
79532: PUSH
79533: LD_INT 1
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 2
79542: NEG
79543: PUSH
79544: LD_INT 0
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PUSH
79551: LD_INT 2
79553: NEG
79554: PUSH
79555: LD_INT 1
79557: NEG
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: LD_INT 2
79565: PUSH
79566: LD_INT 1
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 3
79576: PUSH
79577: LD_INT 0
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PUSH
79584: LD_INT 3
79586: PUSH
79587: LD_INT 1
79589: PUSH
79590: EMPTY
79591: LIST
79592: LIST
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: LIST
79598: LIST
79599: LIST
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79612: LD_ADDR_VAR 0 16
79616: PUSH
79617: LD_INT 0
79619: PUSH
79620: LD_INT 0
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: LD_INT 1
79632: NEG
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PUSH
79638: LD_INT 1
79640: PUSH
79641: LD_INT 0
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 1
79650: PUSH
79651: LD_INT 1
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 0
79660: PUSH
79661: LD_INT 1
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 1
79670: NEG
79671: PUSH
79672: LD_INT 0
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 1
79681: NEG
79682: PUSH
79683: LD_INT 1
79685: NEG
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 1
79693: NEG
79694: PUSH
79695: LD_INT 2
79697: NEG
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PUSH
79703: LD_INT 2
79705: PUSH
79706: LD_INT 1
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 2
79715: PUSH
79716: LD_INT 2
79718: PUSH
79719: EMPTY
79720: LIST
79721: LIST
79722: PUSH
79723: LD_INT 1
79725: PUSH
79726: LD_INT 2
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 2
79735: NEG
79736: PUSH
79737: LD_INT 1
79739: NEG
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: LD_INT 2
79747: NEG
79748: PUSH
79749: LD_INT 2
79751: NEG
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 3
79759: PUSH
79760: LD_INT 2
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 3
79769: PUSH
79770: LD_INT 3
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 2
79779: PUSH
79780: LD_INT 3
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79805: LD_ADDR_VAR 0 17
79809: PUSH
79810: LD_INT 0
79812: PUSH
79813: LD_INT 0
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 0
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 1
79833: PUSH
79834: LD_INT 0
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: LD_INT 1
79843: PUSH
79844: LD_INT 1
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: PUSH
79851: LD_INT 0
79853: PUSH
79854: LD_INT 1
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: NEG
79864: PUSH
79865: LD_INT 0
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 1
79874: NEG
79875: PUSH
79876: LD_INT 1
79878: NEG
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: LD_INT 2
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 0
79898: PUSH
79899: LD_INT 2
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: LD_INT 1
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: LD_INT 2
79920: PUSH
79921: LD_INT 0
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PUSH
79928: LD_INT 2
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 2
79940: PUSH
79941: LD_INT 2
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 0
79960: PUSH
79961: LD_INT 2
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 1
79970: NEG
79971: PUSH
79972: LD_INT 1
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 2
79981: NEG
79982: PUSH
79983: LD_INT 0
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 2
79992: NEG
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: NEG
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: LIST
80018: LIST
80019: LIST
80020: LIST
80021: LIST
80022: LIST
80023: LIST
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80035: LD_ADDR_VAR 0 18
80039: PUSH
80040: LD_INT 0
80042: PUSH
80043: LD_INT 0
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: PUSH
80050: LD_INT 0
80052: PUSH
80053: LD_INT 1
80055: NEG
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 1
80063: PUSH
80064: LD_INT 0
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 1
80073: PUSH
80074: LD_INT 1
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 0
80083: PUSH
80084: LD_INT 1
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 1
80093: NEG
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: LD_INT 1
80104: NEG
80105: PUSH
80106: LD_INT 1
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 1
80116: NEG
80117: PUSH
80118: LD_INT 2
80120: NEG
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 0
80128: PUSH
80129: LD_INT 2
80131: NEG
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 1
80139: PUSH
80140: LD_INT 1
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 2
80150: PUSH
80151: LD_INT 0
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 2
80160: PUSH
80161: LD_INT 1
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 2
80170: PUSH
80171: LD_INT 2
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 1
80180: PUSH
80181: LD_INT 2
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: NEG
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 2
80211: NEG
80212: PUSH
80213: LD_INT 0
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 2
80222: NEG
80223: PUSH
80224: LD_INT 1
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: LD_INT 2
80234: NEG
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: LIST
80248: LIST
80249: LIST
80250: LIST
80251: LIST
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: LIST
80257: LIST
80258: LIST
80259: LIST
80260: LIST
80261: LIST
80262: LIST
80263: LIST
80264: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80265: LD_ADDR_VAR 0 19
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: LD_INT 0
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: LD_INT 0
80282: PUSH
80283: LD_INT 1
80285: NEG
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 1
80293: PUSH
80294: LD_INT 0
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: LD_INT 1
80303: PUSH
80304: LD_INT 1
80306: PUSH
80307: EMPTY
80308: LIST
80309: LIST
80310: PUSH
80311: LD_INT 0
80313: PUSH
80314: LD_INT 1
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 1
80323: NEG
80324: PUSH
80325: LD_INT 0
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 1
80334: NEG
80335: PUSH
80336: LD_INT 1
80338: NEG
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 1
80346: NEG
80347: PUSH
80348: LD_INT 2
80350: NEG
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 0
80358: PUSH
80359: LD_INT 2
80361: NEG
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 1
80369: PUSH
80370: LD_INT 1
80372: NEG
80373: PUSH
80374: EMPTY
80375: LIST
80376: LIST
80377: PUSH
80378: LD_INT 2
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: EMPTY
80385: LIST
80386: LIST
80387: PUSH
80388: LD_INT 2
80390: PUSH
80391: LD_INT 1
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 2
80400: PUSH
80401: LD_INT 2
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: LD_INT 2
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 0
80420: PUSH
80421: LD_INT 2
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: LD_INT 1
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: LD_INT 0
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: LD_INT 2
80452: NEG
80453: PUSH
80454: LD_INT 1
80456: NEG
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 2
80464: NEG
80465: PUSH
80466: LD_INT 2
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: LIST
80478: LIST
80479: LIST
80480: LIST
80481: LIST
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80495: LD_ADDR_VAR 0 20
80499: PUSH
80500: LD_INT 0
80502: PUSH
80503: LD_INT 0
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 0
80512: PUSH
80513: LD_INT 1
80515: NEG
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 1
80523: PUSH
80524: LD_INT 0
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: LD_INT 1
80533: PUSH
80534: LD_INT 1
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 0
80543: PUSH
80544: LD_INT 1
80546: PUSH
80547: EMPTY
80548: LIST
80549: LIST
80550: PUSH
80551: LD_INT 1
80553: NEG
80554: PUSH
80555: LD_INT 0
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: PUSH
80562: LD_INT 1
80564: NEG
80565: PUSH
80566: LD_INT 1
80568: NEG
80569: PUSH
80570: EMPTY
80571: LIST
80572: LIST
80573: PUSH
80574: LD_INT 1
80576: NEG
80577: PUSH
80578: LD_INT 2
80580: NEG
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: LD_INT 2
80591: NEG
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 1
80599: PUSH
80600: LD_INT 1
80602: NEG
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 2
80610: PUSH
80611: LD_INT 0
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 2
80620: PUSH
80621: LD_INT 1
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 2
80630: PUSH
80631: LD_INT 2
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 1
80640: PUSH
80641: LD_INT 2
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 2
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: LD_INT 1
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 2
80671: NEG
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 2
80682: NEG
80683: PUSH
80684: LD_INT 1
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 2
80694: NEG
80695: PUSH
80696: LD_INT 2
80698: NEG
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: EMPTY
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80725: LD_ADDR_VAR 0 21
80729: PUSH
80730: LD_INT 0
80732: PUSH
80733: LD_INT 0
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 0
80742: PUSH
80743: LD_INT 1
80745: NEG
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 1
80753: PUSH
80754: LD_INT 0
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: PUSH
80761: LD_INT 1
80763: PUSH
80764: LD_INT 1
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: LD_INT 1
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 1
80783: NEG
80784: PUSH
80785: LD_INT 0
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: LD_INT 1
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 1
80806: NEG
80807: PUSH
80808: LD_INT 2
80810: NEG
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 0
80818: PUSH
80819: LD_INT 2
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: PUSH
80830: LD_INT 1
80832: NEG
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 2
80840: PUSH
80841: LD_INT 0
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 2
80850: PUSH
80851: LD_INT 1
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 2
80860: PUSH
80861: LD_INT 2
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: LD_INT 1
80870: PUSH
80871: LD_INT 2
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 0
80880: PUSH
80881: LD_INT 2
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: NEG
80891: PUSH
80892: LD_INT 1
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 2
80901: NEG
80902: PUSH
80903: LD_INT 0
80905: PUSH
80906: EMPTY
80907: LIST
80908: LIST
80909: PUSH
80910: LD_INT 2
80912: NEG
80913: PUSH
80914: LD_INT 1
80916: NEG
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: PUSH
80922: LD_INT 2
80924: NEG
80925: PUSH
80926: LD_INT 2
80928: NEG
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80955: LD_ADDR_VAR 0 22
80959: PUSH
80960: LD_INT 0
80962: PUSH
80963: LD_INT 0
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 0
80972: PUSH
80973: LD_INT 1
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 1
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: PUSH
80991: LD_INT 1
80993: PUSH
80994: LD_INT 1
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PUSH
81001: LD_INT 0
81003: PUSH
81004: LD_INT 1
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 1
81013: NEG
81014: PUSH
81015: LD_INT 0
81017: PUSH
81018: EMPTY
81019: LIST
81020: LIST
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: LD_INT 1
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 1
81036: NEG
81037: PUSH
81038: LD_INT 2
81040: NEG
81041: PUSH
81042: EMPTY
81043: LIST
81044: LIST
81045: PUSH
81046: LD_INT 0
81048: PUSH
81049: LD_INT 2
81051: NEG
81052: PUSH
81053: EMPTY
81054: LIST
81055: LIST
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: LD_INT 1
81062: NEG
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 2
81070: PUSH
81071: LD_INT 0
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 2
81080: PUSH
81081: LD_INT 1
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: PUSH
81088: LD_INT 2
81090: PUSH
81091: LD_INT 2
81093: PUSH
81094: EMPTY
81095: LIST
81096: LIST
81097: PUSH
81098: LD_INT 1
81100: PUSH
81101: LD_INT 2
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: PUSH
81108: LD_INT 0
81110: PUSH
81111: LD_INT 2
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: LD_INT 1
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 2
81131: NEG
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: EMPTY
81137: LIST
81138: LIST
81139: PUSH
81140: LD_INT 2
81142: NEG
81143: PUSH
81144: LD_INT 1
81146: NEG
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PUSH
81152: LD_INT 2
81154: NEG
81155: PUSH
81156: LD_INT 2
81158: NEG
81159: PUSH
81160: EMPTY
81161: LIST
81162: LIST
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81185: LD_ADDR_VAR 0 23
81189: PUSH
81190: LD_INT 0
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 0
81202: PUSH
81203: LD_INT 1
81205: NEG
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 1
81213: PUSH
81214: LD_INT 0
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 1
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 0
81233: PUSH
81234: LD_INT 1
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PUSH
81241: LD_INT 1
81243: NEG
81244: PUSH
81245: LD_INT 0
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 1
81254: NEG
81255: PUSH
81256: LD_INT 1
81258: NEG
81259: PUSH
81260: EMPTY
81261: LIST
81262: LIST
81263: PUSH
81264: LD_INT 1
81266: NEG
81267: PUSH
81268: LD_INT 2
81270: NEG
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 0
81278: PUSH
81279: LD_INT 2
81281: NEG
81282: PUSH
81283: EMPTY
81284: LIST
81285: LIST
81286: PUSH
81287: LD_INT 1
81289: PUSH
81290: LD_INT 1
81292: NEG
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 2
81300: PUSH
81301: LD_INT 0
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 2
81310: PUSH
81311: LD_INT 1
81313: PUSH
81314: EMPTY
81315: LIST
81316: LIST
81317: PUSH
81318: LD_INT 2
81320: PUSH
81321: LD_INT 2
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: PUSH
81328: LD_INT 1
81330: PUSH
81331: LD_INT 2
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 0
81340: PUSH
81341: LD_INT 2
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 1
81350: NEG
81351: PUSH
81352: LD_INT 1
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: LD_INT 2
81361: NEG
81362: PUSH
81363: LD_INT 0
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 2
81372: NEG
81373: PUSH
81374: LD_INT 1
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 2
81384: NEG
81385: PUSH
81386: LD_INT 2
81388: NEG
81389: PUSH
81390: EMPTY
81391: LIST
81392: LIST
81393: PUSH
81394: LD_INT 2
81396: NEG
81397: PUSH
81398: LD_INT 3
81400: NEG
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PUSH
81406: LD_INT 1
81408: NEG
81409: PUSH
81410: LD_INT 3
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 2
81423: NEG
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 2
81431: PUSH
81432: LD_INT 1
81434: NEG
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81465: LD_ADDR_VAR 0 24
81469: PUSH
81470: LD_INT 0
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 0
81482: PUSH
81483: LD_INT 1
81485: NEG
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: PUSH
81494: LD_INT 0
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: LD_INT 1
81506: PUSH
81507: EMPTY
81508: LIST
81509: LIST
81510: PUSH
81511: LD_INT 0
81513: PUSH
81514: LD_INT 1
81516: PUSH
81517: EMPTY
81518: LIST
81519: LIST
81520: PUSH
81521: LD_INT 1
81523: NEG
81524: PUSH
81525: LD_INT 0
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 1
81534: NEG
81535: PUSH
81536: LD_INT 1
81538: NEG
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: PUSH
81544: LD_INT 1
81546: NEG
81547: PUSH
81548: LD_INT 2
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 0
81558: PUSH
81559: LD_INT 2
81561: NEG
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 1
81572: NEG
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PUSH
81578: LD_INT 2
81580: PUSH
81581: LD_INT 0
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 2
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 2
81600: PUSH
81601: LD_INT 2
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: LD_INT 2
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 0
81620: PUSH
81621: LD_INT 2
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 1
81630: NEG
81631: PUSH
81632: LD_INT 1
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 2
81641: NEG
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 2
81652: NEG
81653: PUSH
81654: LD_INT 1
81656: NEG
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PUSH
81662: LD_INT 2
81664: NEG
81665: PUSH
81666: LD_INT 2
81668: NEG
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: PUSH
81674: LD_INT 1
81676: PUSH
81677: LD_INT 2
81679: NEG
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 2
81687: PUSH
81688: LD_INT 1
81690: NEG
81691: PUSH
81692: EMPTY
81693: LIST
81694: LIST
81695: PUSH
81696: LD_INT 3
81698: PUSH
81699: LD_INT 1
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 3
81708: PUSH
81709: LD_INT 2
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: LIST
81723: LIST
81724: LIST
81725: LIST
81726: LIST
81727: LIST
81728: LIST
81729: LIST
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: LIST
81735: LIST
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81741: LD_ADDR_VAR 0 25
81745: PUSH
81746: LD_INT 0
81748: PUSH
81749: LD_INT 0
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 0
81758: PUSH
81759: LD_INT 1
81761: NEG
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 1
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 1
81779: PUSH
81780: LD_INT 1
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 0
81789: PUSH
81790: LD_INT 1
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 1
81799: NEG
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: EMPTY
81805: LIST
81806: LIST
81807: PUSH
81808: LD_INT 1
81810: NEG
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: NEG
81823: PUSH
81824: LD_INT 2
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: LD_INT 2
81837: NEG
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 1
81845: PUSH
81846: LD_INT 1
81848: NEG
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 2
81856: PUSH
81857: LD_INT 0
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 2
81866: PUSH
81867: LD_INT 1
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: LD_INT 2
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 1
81886: PUSH
81887: LD_INT 2
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 0
81896: PUSH
81897: LD_INT 2
81899: PUSH
81900: EMPTY
81901: LIST
81902: LIST
81903: PUSH
81904: LD_INT 1
81906: NEG
81907: PUSH
81908: LD_INT 1
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 2
81917: NEG
81918: PUSH
81919: LD_INT 0
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 2
81928: NEG
81929: PUSH
81930: LD_INT 1
81932: NEG
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 2
81940: NEG
81941: PUSH
81942: LD_INT 2
81944: NEG
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 3
81952: PUSH
81953: LD_INT 1
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 3
81962: PUSH
81963: LD_INT 2
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 2
81972: PUSH
81973: LD_INT 3
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: PUSH
81983: LD_INT 3
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82015: LD_ADDR_VAR 0 26
82019: PUSH
82020: LD_INT 0
82022: PUSH
82023: LD_INT 0
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: PUSH
82030: LD_INT 0
82032: PUSH
82033: LD_INT 1
82035: NEG
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 1
82043: PUSH
82044: LD_INT 0
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: LD_INT 1
82056: PUSH
82057: EMPTY
82058: LIST
82059: LIST
82060: PUSH
82061: LD_INT 0
82063: PUSH
82064: LD_INT 1
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 1
82073: NEG
82074: PUSH
82075: LD_INT 0
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 1
82084: NEG
82085: PUSH
82086: LD_INT 1
82088: NEG
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 1
82096: NEG
82097: PUSH
82098: LD_INT 2
82100: NEG
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: PUSH
82106: LD_INT 0
82108: PUSH
82109: LD_INT 2
82111: NEG
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 1
82119: PUSH
82120: LD_INT 1
82122: NEG
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 2
82130: PUSH
82131: LD_INT 0
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 2
82140: PUSH
82141: LD_INT 1
82143: PUSH
82144: EMPTY
82145: LIST
82146: LIST
82147: PUSH
82148: LD_INT 2
82150: PUSH
82151: LD_INT 2
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: PUSH
82158: LD_INT 1
82160: PUSH
82161: LD_INT 2
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 0
82170: PUSH
82171: LD_INT 2
82173: PUSH
82174: EMPTY
82175: LIST
82176: LIST
82177: PUSH
82178: LD_INT 1
82180: NEG
82181: PUSH
82182: LD_INT 1
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: LD_INT 2
82191: NEG
82192: PUSH
82193: LD_INT 0
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 2
82202: NEG
82203: PUSH
82204: LD_INT 1
82206: NEG
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 2
82214: NEG
82215: PUSH
82216: LD_INT 2
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 2
82226: PUSH
82227: LD_INT 3
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 3
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 1
82246: NEG
82247: PUSH
82248: LD_INT 2
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 2
82257: NEG
82258: PUSH
82259: LD_INT 1
82261: PUSH
82262: EMPTY
82263: LIST
82264: LIST
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: LIST
82277: LIST
82278: LIST
82279: LIST
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82291: LD_ADDR_VAR 0 27
82295: PUSH
82296: LD_INT 0
82298: PUSH
82299: LD_INT 0
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: LD_INT 1
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 1
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 1
82329: PUSH
82330: LD_INT 1
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: LD_INT 1
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 1
82349: NEG
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: EMPTY
82355: LIST
82356: LIST
82357: PUSH
82358: LD_INT 1
82360: NEG
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 1
82372: NEG
82373: PUSH
82374: LD_INT 2
82376: NEG
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: LD_INT 2
82387: NEG
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: LD_INT 1
82398: NEG
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 2
82406: PUSH
82407: LD_INT 0
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 2
82416: PUSH
82417: LD_INT 1
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 2
82426: PUSH
82427: LD_INT 2
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 2
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: LD_INT 2
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: LD_INT 1
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 2
82467: NEG
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: NEG
82479: PUSH
82480: LD_INT 1
82482: NEG
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 2
82490: NEG
82491: PUSH
82492: LD_INT 2
82494: NEG
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PUSH
82500: LD_INT 1
82502: NEG
82503: PUSH
82504: LD_INT 2
82506: PUSH
82507: EMPTY
82508: LIST
82509: LIST
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: LD_INT 1
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 3
82524: NEG
82525: PUSH
82526: LD_INT 1
82528: NEG
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 3
82536: NEG
82537: PUSH
82538: LD_INT 2
82540: NEG
82541: PUSH
82542: EMPTY
82543: LIST
82544: LIST
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82571: LD_ADDR_VAR 0 28
82575: PUSH
82576: LD_INT 0
82578: PUSH
82579: LD_INT 0
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 0
82588: PUSH
82589: LD_INT 1
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 1
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 1
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 0
82619: PUSH
82620: LD_INT 1
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: NEG
82630: PUSH
82631: LD_INT 0
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: NEG
82641: PUSH
82642: LD_INT 1
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: NEG
82653: PUSH
82654: LD_INT 2
82656: NEG
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: LD_INT 2
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 1
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 2
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 2
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: PUSH
82707: LD_INT 2
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: LD_INT 2
82719: PUSH
82720: EMPTY
82721: LIST
82722: LIST
82723: PUSH
82724: LD_INT 0
82726: PUSH
82727: LD_INT 2
82729: PUSH
82730: EMPTY
82731: LIST
82732: LIST
82733: PUSH
82734: LD_INT 1
82736: NEG
82737: PUSH
82738: LD_INT 1
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: LD_INT 2
82747: NEG
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 2
82758: NEG
82759: PUSH
82760: LD_INT 1
82762: NEG
82763: PUSH
82764: EMPTY
82765: LIST
82766: LIST
82767: PUSH
82768: LD_INT 2
82770: NEG
82771: PUSH
82772: LD_INT 2
82774: NEG
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 2
82782: NEG
82783: PUSH
82784: LD_INT 3
82786: NEG
82787: PUSH
82788: EMPTY
82789: LIST
82790: LIST
82791: PUSH
82792: LD_INT 1
82794: NEG
82795: PUSH
82796: LD_INT 3
82798: NEG
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 3
82806: NEG
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 3
82818: NEG
82819: PUSH
82820: LD_INT 2
82822: NEG
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82853: LD_ADDR_VAR 0 29
82857: PUSH
82858: LD_INT 0
82860: PUSH
82861: LD_INT 0
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 0
82870: PUSH
82871: LD_INT 1
82873: NEG
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: PUSH
82882: LD_INT 0
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 1
82891: PUSH
82892: LD_INT 1
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 0
82901: PUSH
82902: LD_INT 1
82904: PUSH
82905: EMPTY
82906: LIST
82907: LIST
82908: PUSH
82909: LD_INT 1
82911: NEG
82912: PUSH
82913: LD_INT 0
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 1
82922: NEG
82923: PUSH
82924: LD_INT 1
82926: NEG
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: LD_INT 1
82934: NEG
82935: PUSH
82936: LD_INT 2
82938: NEG
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 0
82946: PUSH
82947: LD_INT 2
82949: NEG
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: LD_INT 2
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 2
82978: PUSH
82979: LD_INT 1
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 1
82988: PUSH
82989: LD_INT 2
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: PUSH
82996: LD_INT 0
82998: PUSH
82999: LD_INT 2
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PUSH
83006: LD_INT 1
83008: NEG
83009: PUSH
83010: LD_INT 1
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 2
83019: NEG
83020: PUSH
83021: LD_INT 1
83023: NEG
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 2
83031: NEG
83032: PUSH
83033: LD_INT 2
83035: NEG
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 2
83043: NEG
83044: PUSH
83045: LD_INT 3
83047: NEG
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 2
83055: PUSH
83056: LD_INT 1
83058: NEG
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 3
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 1
83076: PUSH
83077: LD_INT 3
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: NEG
83087: PUSH
83088: LD_INT 2
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: PUSH
83095: LD_INT 3
83097: NEG
83098: PUSH
83099: LD_INT 2
83101: NEG
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83132: LD_ADDR_VAR 0 30
83136: PUSH
83137: LD_INT 0
83139: PUSH
83140: LD_INT 0
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 1
83152: NEG
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 1
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 1
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: LD_INT 1
83183: PUSH
83184: EMPTY
83185: LIST
83186: LIST
83187: PUSH
83188: LD_INT 1
83190: NEG
83191: PUSH
83192: LD_INT 0
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 1
83201: NEG
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: EMPTY
83208: LIST
83209: LIST
83210: PUSH
83211: LD_INT 1
83213: NEG
83214: PUSH
83215: LD_INT 2
83217: NEG
83218: PUSH
83219: EMPTY
83220: LIST
83221: LIST
83222: PUSH
83223: LD_INT 0
83225: PUSH
83226: LD_INT 2
83228: NEG
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 1
83236: PUSH
83237: LD_INT 1
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 2
83247: PUSH
83248: LD_INT 0
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 2
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 2
83267: PUSH
83268: LD_INT 2
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 1
83277: PUSH
83278: LD_INT 2
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 1
83287: NEG
83288: PUSH
83289: LD_INT 1
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: NEG
83299: PUSH
83300: LD_INT 0
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 2
83309: NEG
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: NEG
83322: PUSH
83323: LD_INT 3
83325: NEG
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 1
83333: PUSH
83334: LD_INT 2
83336: NEG
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 3
83344: PUSH
83345: LD_INT 2
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 2
83354: PUSH
83355: LD_INT 3
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 2
83364: NEG
83365: PUSH
83366: LD_INT 1
83368: PUSH
83369: EMPTY
83370: LIST
83371: LIST
83372: PUSH
83373: LD_INT 3
83375: NEG
83376: PUSH
83377: LD_INT 1
83379: NEG
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83410: LD_ADDR_VAR 0 31
83414: PUSH
83415: LD_INT 0
83417: PUSH
83418: LD_INT 0
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: LD_INT 0
83427: PUSH
83428: LD_INT 1
83430: NEG
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: LD_INT 0
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 1
83448: PUSH
83449: LD_INT 1
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 0
83458: PUSH
83459: LD_INT 1
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: LD_INT 0
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: PUSH
83477: LD_INT 1
83479: NEG
83480: PUSH
83481: LD_INT 1
83483: NEG
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: LD_INT 2
83495: NEG
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 1
83503: PUSH
83504: LD_INT 1
83506: NEG
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 2
83514: PUSH
83515: LD_INT 0
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 2
83534: PUSH
83535: LD_INT 2
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 1
83544: PUSH
83545: LD_INT 2
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 0
83554: PUSH
83555: LD_INT 2
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 1
83564: NEG
83565: PUSH
83566: LD_INT 1
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 2
83575: NEG
83576: PUSH
83577: LD_INT 1
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 2
83587: NEG
83588: PUSH
83589: LD_INT 2
83591: NEG
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 2
83599: NEG
83600: PUSH
83601: LD_INT 3
83603: NEG
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 2
83611: PUSH
83612: LD_INT 1
83614: NEG
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 3
83622: PUSH
83623: LD_INT 1
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: LD_INT 3
83635: PUSH
83636: EMPTY
83637: LIST
83638: LIST
83639: PUSH
83640: LD_INT 1
83642: NEG
83643: PUSH
83644: LD_INT 2
83646: PUSH
83647: EMPTY
83648: LIST
83649: LIST
83650: PUSH
83651: LD_INT 3
83653: NEG
83654: PUSH
83655: LD_INT 2
83657: NEG
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83688: LD_ADDR_VAR 0 32
83692: PUSH
83693: LD_INT 0
83695: PUSH
83696: LD_INT 0
83698: PUSH
83699: EMPTY
83700: LIST
83701: LIST
83702: PUSH
83703: LD_INT 0
83705: PUSH
83706: LD_INT 1
83708: NEG
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 1
83716: PUSH
83717: LD_INT 0
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: LD_INT 1
83726: PUSH
83727: LD_INT 1
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 0
83736: PUSH
83737: LD_INT 1
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: PUSH
83744: LD_INT 1
83746: NEG
83747: PUSH
83748: LD_INT 0
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 1
83757: NEG
83758: PUSH
83759: LD_INT 1
83761: NEG
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: PUSH
83767: LD_INT 1
83769: NEG
83770: PUSH
83771: LD_INT 2
83773: NEG
83774: PUSH
83775: EMPTY
83776: LIST
83777: LIST
83778: PUSH
83779: LD_INT 0
83781: PUSH
83782: LD_INT 2
83784: NEG
83785: PUSH
83786: EMPTY
83787: LIST
83788: LIST
83789: PUSH
83790: LD_INT 1
83792: PUSH
83793: LD_INT 1
83795: NEG
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PUSH
83801: LD_INT 2
83803: PUSH
83804: LD_INT 1
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 2
83813: PUSH
83814: LD_INT 2
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 1
83823: PUSH
83824: LD_INT 2
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: LD_INT 0
83833: PUSH
83834: LD_INT 2
83836: PUSH
83837: EMPTY
83838: LIST
83839: LIST
83840: PUSH
83841: LD_INT 1
83843: NEG
83844: PUSH
83845: LD_INT 1
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 2
83854: NEG
83855: PUSH
83856: LD_INT 0
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 2
83865: NEG
83866: PUSH
83867: LD_INT 1
83869: NEG
83870: PUSH
83871: EMPTY
83872: LIST
83873: LIST
83874: PUSH
83875: LD_INT 1
83877: NEG
83878: PUSH
83879: LD_INT 3
83881: NEG
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: PUSH
83890: LD_INT 2
83892: NEG
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PUSH
83898: LD_INT 3
83900: PUSH
83901: LD_INT 2
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 2
83910: PUSH
83911: LD_INT 3
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 2
83920: NEG
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: EMPTY
83926: LIST
83927: LIST
83928: PUSH
83929: LD_INT 3
83931: NEG
83932: PUSH
83933: LD_INT 1
83935: NEG
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83966: LD_ADDR_VAR 0 33
83970: PUSH
83971: LD_INT 0
83973: PUSH
83974: LD_INT 0
83976: PUSH
83977: EMPTY
83978: LIST
83979: LIST
83980: PUSH
83981: LD_INT 0
83983: PUSH
83984: LD_INT 1
83986: NEG
83987: PUSH
83988: EMPTY
83989: LIST
83990: LIST
83991: PUSH
83992: LD_INT 1
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: PUSH
84002: LD_INT 1
84004: PUSH
84005: LD_INT 1
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PUSH
84012: LD_INT 0
84014: PUSH
84015: LD_INT 1
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: LD_INT 1
84024: NEG
84025: PUSH
84026: LD_INT 0
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: LD_INT 1
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: LD_INT 2
84051: NEG
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 1
84059: PUSH
84060: LD_INT 1
84062: NEG
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 2
84070: PUSH
84071: LD_INT 0
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 2
84080: PUSH
84081: LD_INT 1
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 1
84090: PUSH
84091: LD_INT 2
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: LD_INT 0
84100: PUSH
84101: LD_INT 2
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 1
84110: NEG
84111: PUSH
84112: LD_INT 1
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 2
84121: NEG
84122: PUSH
84123: LD_INT 0
84125: PUSH
84126: EMPTY
84127: LIST
84128: LIST
84129: PUSH
84130: LD_INT 2
84132: NEG
84133: PUSH
84134: LD_INT 1
84136: NEG
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 2
84144: NEG
84145: PUSH
84146: LD_INT 2
84148: NEG
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: PUSH
84154: LD_INT 2
84156: NEG
84157: PUSH
84158: LD_INT 3
84160: NEG
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PUSH
84166: LD_INT 2
84168: PUSH
84169: LD_INT 1
84171: NEG
84172: PUSH
84173: EMPTY
84174: LIST
84175: LIST
84176: PUSH
84177: LD_INT 3
84179: PUSH
84180: LD_INT 1
84182: PUSH
84183: EMPTY
84184: LIST
84185: LIST
84186: PUSH
84187: LD_INT 1
84189: PUSH
84190: LD_INT 3
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PUSH
84197: LD_INT 1
84199: NEG
84200: PUSH
84201: LD_INT 2
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PUSH
84208: LD_INT 3
84210: NEG
84211: PUSH
84212: LD_INT 2
84214: NEG
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84245: LD_ADDR_VAR 0 34
84249: PUSH
84250: LD_INT 0
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 0
84262: PUSH
84263: LD_INT 1
84265: NEG
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 1
84273: PUSH
84274: LD_INT 0
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 1
84283: PUSH
84284: LD_INT 1
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: LD_INT 1
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 1
84303: NEG
84304: PUSH
84305: LD_INT 0
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: NEG
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 1
84326: NEG
84327: PUSH
84328: LD_INT 2
84330: NEG
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 0
84338: PUSH
84339: LD_INT 2
84341: NEG
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: PUSH
84350: LD_INT 1
84352: NEG
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 2
84360: PUSH
84361: LD_INT 1
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 2
84370: PUSH
84371: LD_INT 2
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: LD_INT 1
84380: PUSH
84381: LD_INT 2
84383: PUSH
84384: EMPTY
84385: LIST
84386: LIST
84387: PUSH
84388: LD_INT 1
84390: NEG
84391: PUSH
84392: LD_INT 1
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: PUSH
84399: LD_INT 2
84401: NEG
84402: PUSH
84403: LD_INT 0
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: PUSH
84410: LD_INT 2
84412: NEG
84413: PUSH
84414: LD_INT 1
84416: NEG
84417: PUSH
84418: EMPTY
84419: LIST
84420: LIST
84421: PUSH
84422: LD_INT 2
84424: NEG
84425: PUSH
84426: LD_INT 2
84428: NEG
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: NEG
84437: PUSH
84438: LD_INT 3
84440: NEG
84441: PUSH
84442: EMPTY
84443: LIST
84444: LIST
84445: PUSH
84446: LD_INT 1
84448: PUSH
84449: LD_INT 2
84451: NEG
84452: PUSH
84453: EMPTY
84454: LIST
84455: LIST
84456: PUSH
84457: LD_INT 3
84459: PUSH
84460: LD_INT 2
84462: PUSH
84463: EMPTY
84464: LIST
84465: LIST
84466: PUSH
84467: LD_INT 2
84469: PUSH
84470: LD_INT 3
84472: PUSH
84473: EMPTY
84474: LIST
84475: LIST
84476: PUSH
84477: LD_INT 2
84479: NEG
84480: PUSH
84481: LD_INT 1
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 3
84490: NEG
84491: PUSH
84492: LD_INT 1
84494: NEG
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: EMPTY
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: LIST
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84525: LD_ADDR_VAR 0 35
84529: PUSH
84530: LD_INT 0
84532: PUSH
84533: LD_INT 0
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 0
84542: PUSH
84543: LD_INT 1
84545: NEG
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 1
84553: PUSH
84554: LD_INT 0
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 1
84563: PUSH
84564: LD_INT 1
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: LD_INT 0
84573: PUSH
84574: LD_INT 1
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 1
84583: NEG
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: NEG
84595: PUSH
84596: LD_INT 1
84598: NEG
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PUSH
84604: LD_INT 2
84606: PUSH
84607: LD_INT 1
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 2
84616: NEG
84617: PUSH
84618: LD_INT 1
84620: NEG
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: EMPTY
84627: LIST
84628: LIST
84629: LIST
84630: LIST
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84637: LD_ADDR_VAR 0 36
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: LD_INT 0
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: LD_INT 0
84654: PUSH
84655: LD_INT 1
84657: NEG
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 1
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: LD_INT 1
84675: PUSH
84676: LD_INT 1
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PUSH
84683: LD_INT 0
84685: PUSH
84686: LD_INT 1
84688: PUSH
84689: EMPTY
84690: LIST
84691: LIST
84692: PUSH
84693: LD_INT 1
84695: NEG
84696: PUSH
84697: LD_INT 0
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PUSH
84704: LD_INT 1
84706: NEG
84707: PUSH
84708: LD_INT 1
84710: NEG
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 1
84718: NEG
84719: PUSH
84720: LD_INT 2
84722: NEG
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: PUSH
84731: LD_INT 2
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84749: LD_ADDR_VAR 0 37
84753: PUSH
84754: LD_INT 0
84756: PUSH
84757: LD_INT 0
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 0
84766: PUSH
84767: LD_INT 1
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 1
84777: PUSH
84778: LD_INT 0
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: LD_INT 1
84787: PUSH
84788: LD_INT 1
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: PUSH
84795: LD_INT 0
84797: PUSH
84798: LD_INT 1
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: PUSH
84805: LD_INT 1
84807: NEG
84808: PUSH
84809: LD_INT 0
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: NEG
84819: PUSH
84820: LD_INT 1
84822: NEG
84823: PUSH
84824: EMPTY
84825: LIST
84826: LIST
84827: PUSH
84828: LD_INT 1
84830: PUSH
84831: LD_INT 1
84833: NEG
84834: PUSH
84835: EMPTY
84836: LIST
84837: LIST
84838: PUSH
84839: LD_INT 1
84841: NEG
84842: PUSH
84843: LD_INT 1
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84861: LD_ADDR_VAR 0 38
84865: PUSH
84866: LD_INT 0
84868: PUSH
84869: LD_INT 0
84871: PUSH
84872: EMPTY
84873: LIST
84874: LIST
84875: PUSH
84876: LD_INT 0
84878: PUSH
84879: LD_INT 1
84881: NEG
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: LD_INT 0
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PUSH
84907: LD_INT 0
84909: PUSH
84910: LD_INT 1
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: LD_INT 1
84919: NEG
84920: PUSH
84921: LD_INT 0
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: NEG
84931: PUSH
84932: LD_INT 1
84934: NEG
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 2
84942: PUSH
84943: LD_INT 1
84945: PUSH
84946: EMPTY
84947: LIST
84948: LIST
84949: PUSH
84950: LD_INT 2
84952: NEG
84953: PUSH
84954: LD_INT 1
84956: NEG
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: EMPTY
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84973: LD_ADDR_VAR 0 39
84977: PUSH
84978: LD_INT 0
84980: PUSH
84981: LD_INT 0
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 0
84990: PUSH
84991: LD_INT 1
84993: NEG
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 1
85001: PUSH
85002: LD_INT 0
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 1
85011: PUSH
85012: LD_INT 1
85014: PUSH
85015: EMPTY
85016: LIST
85017: LIST
85018: PUSH
85019: LD_INT 0
85021: PUSH
85022: LD_INT 1
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 1
85031: NEG
85032: PUSH
85033: LD_INT 0
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 1
85042: NEG
85043: PUSH
85044: LD_INT 1
85046: NEG
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 1
85054: NEG
85055: PUSH
85056: LD_INT 2
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 1
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85085: LD_ADDR_VAR 0 40
85089: PUSH
85090: LD_INT 0
85092: PUSH
85093: LD_INT 0
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: LD_INT 0
85102: PUSH
85103: LD_INT 1
85105: NEG
85106: PUSH
85107: EMPTY
85108: LIST
85109: LIST
85110: PUSH
85111: LD_INT 1
85113: PUSH
85114: LD_INT 0
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: PUSH
85121: LD_INT 1
85123: PUSH
85124: LD_INT 1
85126: PUSH
85127: EMPTY
85128: LIST
85129: LIST
85130: PUSH
85131: LD_INT 0
85133: PUSH
85134: LD_INT 1
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: PUSH
85141: LD_INT 1
85143: NEG
85144: PUSH
85145: LD_INT 0
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 1
85154: NEG
85155: PUSH
85156: LD_INT 1
85158: NEG
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: LD_INT 1
85169: NEG
85170: PUSH
85171: EMPTY
85172: LIST
85173: LIST
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: LD_INT 1
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: EMPTY
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85197: LD_ADDR_VAR 0 41
85201: PUSH
85202: LD_INT 0
85204: PUSH
85205: LD_INT 0
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: PUSH
85212: LD_INT 0
85214: PUSH
85215: LD_INT 1
85217: NEG
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: PUSH
85223: LD_INT 1
85225: PUSH
85226: LD_INT 0
85228: PUSH
85229: EMPTY
85230: LIST
85231: LIST
85232: PUSH
85233: LD_INT 1
85235: PUSH
85236: LD_INT 1
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 0
85245: PUSH
85246: LD_INT 1
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 1
85255: NEG
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PUSH
85264: LD_INT 1
85266: NEG
85267: PUSH
85268: LD_INT 1
85270: NEG
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: LD_INT 2
85282: NEG
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 1
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 2
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 2
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 2
85321: PUSH
85322: LD_INT 2
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: PUSH
85332: LD_INT 2
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 1
85341: NEG
85342: PUSH
85343: LD_INT 1
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 2
85352: NEG
85353: PUSH
85354: LD_INT 0
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 2
85363: NEG
85364: PUSH
85365: LD_INT 1
85367: NEG
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 2
85375: NEG
85376: PUSH
85377: LD_INT 2
85379: NEG
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: LD_INT 2
85387: NEG
85388: PUSH
85389: LD_INT 3
85391: NEG
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 2
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 3
85410: PUSH
85411: LD_INT 0
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 3
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 3
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 3
85440: PUSH
85441: LD_INT 3
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 2
85450: PUSH
85451: LD_INT 3
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 2
85460: NEG
85461: PUSH
85462: LD_INT 1
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: PUSH
85469: LD_INT 3
85471: NEG
85472: PUSH
85473: LD_INT 0
85475: PUSH
85476: EMPTY
85477: LIST
85478: LIST
85479: PUSH
85480: LD_INT 3
85482: NEG
85483: PUSH
85484: LD_INT 1
85486: NEG
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 3
85494: NEG
85495: PUSH
85496: LD_INT 2
85498: NEG
85499: PUSH
85500: EMPTY
85501: LIST
85502: LIST
85503: PUSH
85504: LD_INT 3
85506: NEG
85507: PUSH
85508: LD_INT 3
85510: NEG
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: PUSH
85516: EMPTY
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85547: LD_ADDR_VAR 0 42
85551: PUSH
85552: LD_INT 0
85554: PUSH
85555: LD_INT 0
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 0
85564: PUSH
85565: LD_INT 1
85567: NEG
85568: PUSH
85569: EMPTY
85570: LIST
85571: LIST
85572: PUSH
85573: LD_INT 1
85575: PUSH
85576: LD_INT 0
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: PUSH
85583: LD_INT 1
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 0
85595: PUSH
85596: LD_INT 1
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: LD_INT 1
85605: NEG
85606: PUSH
85607: LD_INT 0
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: PUSH
85614: LD_INT 1
85616: NEG
85617: PUSH
85618: LD_INT 1
85620: NEG
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 1
85628: NEG
85629: PUSH
85630: LD_INT 2
85632: NEG
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: PUSH
85638: LD_INT 0
85640: PUSH
85641: LD_INT 2
85643: NEG
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: PUSH
85652: LD_INT 1
85654: NEG
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 2
85662: PUSH
85663: LD_INT 1
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: LD_INT 2
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 1
85682: PUSH
85683: LD_INT 2
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 0
85692: PUSH
85693: LD_INT 2
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 1
85702: NEG
85703: PUSH
85704: LD_INT 1
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: LD_INT 2
85713: NEG
85714: PUSH
85715: LD_INT 1
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 2
85725: NEG
85726: PUSH
85727: LD_INT 2
85729: NEG
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: LD_INT 2
85737: NEG
85738: PUSH
85739: LD_INT 3
85741: NEG
85742: PUSH
85743: EMPTY
85744: LIST
85745: LIST
85746: PUSH
85747: LD_INT 1
85749: NEG
85750: PUSH
85751: LD_INT 3
85753: NEG
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 0
85761: PUSH
85762: LD_INT 3
85764: NEG
85765: PUSH
85766: EMPTY
85767: LIST
85768: LIST
85769: PUSH
85770: LD_INT 1
85772: PUSH
85773: LD_INT 2
85775: NEG
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 3
85783: PUSH
85784: LD_INT 2
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 3
85793: PUSH
85794: LD_INT 3
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 2
85803: PUSH
85804: LD_INT 3
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 1
85813: PUSH
85814: LD_INT 3
85816: PUSH
85817: EMPTY
85818: LIST
85819: LIST
85820: PUSH
85821: LD_INT 0
85823: PUSH
85824: LD_INT 3
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 1
85833: NEG
85834: PUSH
85835: LD_INT 2
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 3
85844: NEG
85845: PUSH
85846: LD_INT 2
85848: NEG
85849: PUSH
85850: EMPTY
85851: LIST
85852: LIST
85853: PUSH
85854: LD_INT 3
85856: NEG
85857: PUSH
85858: LD_INT 3
85860: NEG
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: LIST
85878: LIST
85879: LIST
85880: LIST
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: LIST
85886: LIST
85887: LIST
85888: LIST
85889: LIST
85890: LIST
85891: LIST
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85897: LD_ADDR_VAR 0 43
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: LD_INT 0
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: LD_INT 1
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: LD_INT 0
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 1
85935: PUSH
85936: LD_INT 1
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 0
85945: PUSH
85946: LD_INT 1
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: PUSH
85953: LD_INT 1
85955: NEG
85956: PUSH
85957: LD_INT 0
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: NEG
85967: PUSH
85968: LD_INT 1
85970: NEG
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: NEG
85979: PUSH
85980: LD_INT 2
85982: NEG
85983: PUSH
85984: EMPTY
85985: LIST
85986: LIST
85987: PUSH
85988: LD_INT 0
85990: PUSH
85991: LD_INT 2
85993: NEG
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PUSH
85999: LD_INT 1
86001: PUSH
86002: LD_INT 1
86004: NEG
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 2
86012: PUSH
86013: LD_INT 0
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 2
86022: PUSH
86023: LD_INT 1
86025: PUSH
86026: EMPTY
86027: LIST
86028: LIST
86029: PUSH
86030: LD_INT 1
86032: PUSH
86033: LD_INT 2
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 0
86042: PUSH
86043: LD_INT 2
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: NEG
86053: PUSH
86054: LD_INT 1
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 2
86063: NEG
86064: PUSH
86065: LD_INT 0
86067: PUSH
86068: EMPTY
86069: LIST
86070: LIST
86071: PUSH
86072: LD_INT 2
86074: NEG
86075: PUSH
86076: LD_INT 1
86078: NEG
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 1
86086: NEG
86087: PUSH
86088: LD_INT 3
86090: NEG
86091: PUSH
86092: EMPTY
86093: LIST
86094: LIST
86095: PUSH
86096: LD_INT 0
86098: PUSH
86099: LD_INT 3
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: LD_INT 1
86109: PUSH
86110: LD_INT 2
86112: NEG
86113: PUSH
86114: EMPTY
86115: LIST
86116: LIST
86117: PUSH
86118: LD_INT 2
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: EMPTY
86126: LIST
86127: LIST
86128: PUSH
86129: LD_INT 3
86131: PUSH
86132: LD_INT 0
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 3
86141: PUSH
86142: LD_INT 1
86144: PUSH
86145: EMPTY
86146: LIST
86147: LIST
86148: PUSH
86149: LD_INT 1
86151: PUSH
86152: LD_INT 3
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 0
86161: PUSH
86162: LD_INT 3
86164: PUSH
86165: EMPTY
86166: LIST
86167: LIST
86168: PUSH
86169: LD_INT 1
86171: NEG
86172: PUSH
86173: LD_INT 2
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 2
86182: NEG
86183: PUSH
86184: LD_INT 1
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 3
86193: NEG
86194: PUSH
86195: LD_INT 0
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 3
86204: NEG
86205: PUSH
86206: LD_INT 1
86208: NEG
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86245: LD_ADDR_VAR 0 44
86249: PUSH
86250: LD_INT 0
86252: PUSH
86253: LD_INT 0
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 0
86262: PUSH
86263: LD_INT 1
86265: NEG
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 1
86273: PUSH
86274: LD_INT 0
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: LD_INT 1
86283: PUSH
86284: LD_INT 1
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 0
86293: PUSH
86294: LD_INT 1
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 1
86303: NEG
86304: PUSH
86305: LD_INT 0
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: NEG
86315: PUSH
86316: LD_INT 1
86318: NEG
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: LD_INT 2
86330: NEG
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 1
86338: PUSH
86339: LD_INT 1
86341: NEG
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 2
86349: PUSH
86350: LD_INT 0
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 2
86359: PUSH
86360: LD_INT 1
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 2
86369: PUSH
86370: LD_INT 2
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 1
86379: PUSH
86380: LD_INT 2
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: NEG
86390: PUSH
86391: LD_INT 1
86393: PUSH
86394: EMPTY
86395: LIST
86396: LIST
86397: PUSH
86398: LD_INT 2
86400: NEG
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 1
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: LD_INT 2
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 2
86435: NEG
86436: PUSH
86437: LD_INT 3
86439: NEG
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 2
86447: PUSH
86448: LD_INT 1
86450: NEG
86451: PUSH
86452: EMPTY
86453: LIST
86454: LIST
86455: PUSH
86456: LD_INT 3
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: LD_INT 3
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: PUSH
86476: LD_INT 3
86478: PUSH
86479: LD_INT 2
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 3
86488: PUSH
86489: LD_INT 3
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: LD_INT 2
86498: PUSH
86499: LD_INT 3
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: PUSH
86506: LD_INT 2
86508: NEG
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 3
86519: NEG
86520: PUSH
86521: LD_INT 0
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 3
86530: NEG
86531: PUSH
86532: LD_INT 1
86534: NEG
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 3
86542: NEG
86543: PUSH
86544: LD_INT 2
86546: NEG
86547: PUSH
86548: EMPTY
86549: LIST
86550: LIST
86551: PUSH
86552: LD_INT 3
86554: NEG
86555: PUSH
86556: LD_INT 3
86558: NEG
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: PUSH
86564: EMPTY
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: LIST
86592: LIST
86593: LIST
86594: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86595: LD_ADDR_VAR 0 45
86599: PUSH
86600: LD_INT 0
86602: PUSH
86603: LD_INT 0
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: PUSH
86610: LD_INT 0
86612: PUSH
86613: LD_INT 1
86615: NEG
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: LD_INT 0
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 1
86633: PUSH
86634: LD_INT 1
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: LD_INT 0
86643: PUSH
86644: LD_INT 1
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 1
86653: NEG
86654: PUSH
86655: LD_INT 0
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: NEG
86665: PUSH
86666: LD_INT 1
86668: NEG
86669: PUSH
86670: EMPTY
86671: LIST
86672: LIST
86673: PUSH
86674: LD_INT 1
86676: NEG
86677: PUSH
86678: LD_INT 2
86680: NEG
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 0
86688: PUSH
86689: LD_INT 2
86691: NEG
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: PUSH
86700: LD_INT 1
86702: NEG
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: PUSH
86711: LD_INT 1
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 2
86720: PUSH
86721: LD_INT 2
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: LD_INT 2
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 0
86740: PUSH
86741: LD_INT 2
86743: PUSH
86744: EMPTY
86745: LIST
86746: LIST
86747: PUSH
86748: LD_INT 1
86750: NEG
86751: PUSH
86752: LD_INT 1
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 2
86761: NEG
86762: PUSH
86763: LD_INT 1
86765: NEG
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: NEG
86774: PUSH
86775: LD_INT 2
86777: NEG
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PUSH
86783: LD_INT 2
86785: NEG
86786: PUSH
86787: LD_INT 3
86789: NEG
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 1
86797: NEG
86798: PUSH
86799: LD_INT 3
86801: NEG
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: LD_INT 3
86812: NEG
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 1
86820: PUSH
86821: LD_INT 2
86823: NEG
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 3
86831: PUSH
86832: LD_INT 2
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 3
86841: PUSH
86842: LD_INT 3
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 2
86851: PUSH
86852: LD_INT 3
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: PUSH
86862: LD_INT 3
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 0
86871: PUSH
86872: LD_INT 3
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 1
86881: NEG
86882: PUSH
86883: LD_INT 2
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 3
86892: NEG
86893: PUSH
86894: LD_INT 2
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 3
86904: NEG
86905: PUSH
86906: LD_INT 3
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: LIST
86918: LIST
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: LIST
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86945: LD_ADDR_VAR 0 46
86949: PUSH
86950: LD_INT 0
86952: PUSH
86953: LD_INT 0
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 0
86962: PUSH
86963: LD_INT 1
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 1
86973: PUSH
86974: LD_INT 0
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: LD_INT 1
86983: PUSH
86984: LD_INT 1
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 0
86993: PUSH
86994: LD_INT 1
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 1
87003: NEG
87004: PUSH
87005: LD_INT 0
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 1
87014: NEG
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: PUSH
87020: EMPTY
87021: LIST
87022: LIST
87023: PUSH
87024: LD_INT 1
87026: NEG
87027: PUSH
87028: LD_INT 2
87030: NEG
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 0
87038: PUSH
87039: LD_INT 2
87041: NEG
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 1
87049: PUSH
87050: LD_INT 1
87052: NEG
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 2
87060: PUSH
87061: LD_INT 0
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 2
87070: PUSH
87071: LD_INT 1
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: PUSH
87081: LD_INT 2
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: LD_INT 0
87090: PUSH
87091: LD_INT 2
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 1
87100: NEG
87101: PUSH
87102: LD_INT 1
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 2
87111: NEG
87112: PUSH
87113: LD_INT 0
87115: PUSH
87116: EMPTY
87117: LIST
87118: LIST
87119: PUSH
87120: LD_INT 2
87122: NEG
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: LD_INT 3
87138: NEG
87139: PUSH
87140: EMPTY
87141: LIST
87142: LIST
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: LD_INT 3
87149: NEG
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 1
87157: PUSH
87158: LD_INT 2
87160: NEG
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 2
87168: PUSH
87169: LD_INT 1
87171: NEG
87172: PUSH
87173: EMPTY
87174: LIST
87175: LIST
87176: PUSH
87177: LD_INT 3
87179: PUSH
87180: LD_INT 0
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PUSH
87187: LD_INT 3
87189: PUSH
87190: LD_INT 1
87192: PUSH
87193: EMPTY
87194: LIST
87195: LIST
87196: PUSH
87197: LD_INT 1
87199: PUSH
87200: LD_INT 3
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 0
87209: PUSH
87210: LD_INT 3
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: PUSH
87217: LD_INT 1
87219: NEG
87220: PUSH
87221: LD_INT 2
87223: PUSH
87224: EMPTY
87225: LIST
87226: LIST
87227: PUSH
87228: LD_INT 2
87230: NEG
87231: PUSH
87232: LD_INT 1
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: PUSH
87239: LD_INT 3
87241: NEG
87242: PUSH
87243: LD_INT 0
87245: PUSH
87246: EMPTY
87247: LIST
87248: LIST
87249: PUSH
87250: LD_INT 3
87252: NEG
87253: PUSH
87254: LD_INT 1
87256: NEG
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: LIST
87290: LIST
87291: LIST
87292: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87293: LD_ADDR_VAR 0 47
87297: PUSH
87298: LD_INT 0
87300: PUSH
87301: LD_INT 0
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: LD_INT 1
87313: NEG
87314: PUSH
87315: EMPTY
87316: LIST
87317: LIST
87318: PUSH
87319: LD_INT 1
87321: PUSH
87322: LD_INT 0
87324: PUSH
87325: EMPTY
87326: LIST
87327: LIST
87328: PUSH
87329: LD_INT 1
87331: PUSH
87332: LD_INT 1
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 0
87341: PUSH
87342: LD_INT 1
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 1
87351: NEG
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: PUSH
87364: LD_INT 1
87366: NEG
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 1
87374: NEG
87375: PUSH
87376: LD_INT 2
87378: NEG
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 0
87386: PUSH
87387: LD_INT 2
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: LD_INT 1
87397: PUSH
87398: LD_INT 1
87400: NEG
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 2
87408: NEG
87409: PUSH
87410: LD_INT 1
87412: NEG
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: LD_INT 2
87420: NEG
87421: PUSH
87422: LD_INT 2
87424: NEG
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: EMPTY
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87444: LD_ADDR_VAR 0 48
87448: PUSH
87449: LD_INT 0
87451: PUSH
87452: LD_INT 0
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: PUSH
87459: LD_INT 0
87461: PUSH
87462: LD_INT 1
87464: NEG
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 1
87472: PUSH
87473: LD_INT 0
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 1
87482: PUSH
87483: LD_INT 1
87485: PUSH
87486: EMPTY
87487: LIST
87488: LIST
87489: PUSH
87490: LD_INT 0
87492: PUSH
87493: LD_INT 1
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: PUSH
87500: LD_INT 1
87502: NEG
87503: PUSH
87504: LD_INT 0
87506: PUSH
87507: EMPTY
87508: LIST
87509: LIST
87510: PUSH
87511: LD_INT 1
87513: NEG
87514: PUSH
87515: LD_INT 1
87517: NEG
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 1
87525: NEG
87526: PUSH
87527: LD_INT 2
87529: NEG
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 0
87537: PUSH
87538: LD_INT 2
87540: NEG
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 1
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 2
87559: PUSH
87560: LD_INT 0
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 2
87569: PUSH
87570: LD_INT 1
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87591: LD_ADDR_VAR 0 49
87595: PUSH
87596: LD_INT 0
87598: PUSH
87599: LD_INT 0
87601: PUSH
87602: EMPTY
87603: LIST
87604: LIST
87605: PUSH
87606: LD_INT 0
87608: PUSH
87609: LD_INT 1
87611: NEG
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 1
87619: PUSH
87620: LD_INT 0
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 1
87629: PUSH
87630: LD_INT 1
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 0
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 1
87649: NEG
87650: PUSH
87651: LD_INT 0
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 1
87660: NEG
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 2
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 2
87693: PUSH
87694: LD_INT 1
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 2
87703: PUSH
87704: LD_INT 2
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: PUSH
87714: LD_INT 2
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87735: LD_ADDR_VAR 0 50
87739: PUSH
87740: LD_INT 0
87742: PUSH
87743: LD_INT 0
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 0
87752: PUSH
87753: LD_INT 1
87755: NEG
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 1
87763: PUSH
87764: LD_INT 0
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 1
87773: PUSH
87774: LD_INT 1
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 1
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: NEG
87794: PUSH
87795: LD_INT 0
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: NEG
87805: PUSH
87806: LD_INT 1
87808: NEG
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: LD_INT 1
87819: PUSH
87820: EMPTY
87821: LIST
87822: LIST
87823: PUSH
87824: LD_INT 2
87826: PUSH
87827: LD_INT 2
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: LD_INT 1
87836: PUSH
87837: LD_INT 2
87839: PUSH
87840: EMPTY
87841: LIST
87842: LIST
87843: PUSH
87844: LD_INT 0
87846: PUSH
87847: LD_INT 2
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 1
87856: NEG
87857: PUSH
87858: LD_INT 1
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87879: LD_ADDR_VAR 0 51
87883: PUSH
87884: LD_INT 0
87886: PUSH
87887: LD_INT 0
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 0
87896: PUSH
87897: LD_INT 1
87899: NEG
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 1
87907: PUSH
87908: LD_INT 0
87910: PUSH
87911: EMPTY
87912: LIST
87913: LIST
87914: PUSH
87915: LD_INT 1
87917: PUSH
87918: LD_INT 1
87920: PUSH
87921: EMPTY
87922: LIST
87923: LIST
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: LD_INT 1
87930: PUSH
87931: EMPTY
87932: LIST
87933: LIST
87934: PUSH
87935: LD_INT 1
87937: NEG
87938: PUSH
87939: LD_INT 0
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 1
87948: NEG
87949: PUSH
87950: LD_INT 1
87952: NEG
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: LD_INT 2
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: LD_INT 2
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: NEG
87981: PUSH
87982: LD_INT 1
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 2
87991: NEG
87992: PUSH
87993: LD_INT 0
87995: PUSH
87996: EMPTY
87997: LIST
87998: LIST
87999: PUSH
88000: LD_INT 2
88002: NEG
88003: PUSH
88004: LD_INT 1
88006: NEG
88007: PUSH
88008: EMPTY
88009: LIST
88010: LIST
88011: PUSH
88012: EMPTY
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88026: LD_ADDR_VAR 0 52
88030: PUSH
88031: LD_INT 0
88033: PUSH
88034: LD_INT 0
88036: PUSH
88037: EMPTY
88038: LIST
88039: LIST
88040: PUSH
88041: LD_INT 0
88043: PUSH
88044: LD_INT 1
88046: NEG
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 1
88054: PUSH
88055: LD_INT 0
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 1
88064: PUSH
88065: LD_INT 1
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: LD_INT 1
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: LD_INT 0
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 1
88095: NEG
88096: PUSH
88097: LD_INT 1
88099: NEG
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: LD_INT 2
88111: NEG
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 1
88119: NEG
88120: PUSH
88121: LD_INT 1
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: LD_INT 2
88130: NEG
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: NEG
88142: PUSH
88143: LD_INT 1
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 2
88153: NEG
88154: PUSH
88155: LD_INT 2
88157: NEG
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: LIST
88167: LIST
88168: LIST
88169: LIST
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88177: LD_ADDR_VAR 0 53
88181: PUSH
88182: LD_INT 0
88184: PUSH
88185: LD_INT 0
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: LD_INT 0
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 1
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 1
88215: PUSH
88216: LD_INT 1
88218: PUSH
88219: EMPTY
88220: LIST
88221: LIST
88222: PUSH
88223: LD_INT 0
88225: PUSH
88226: LD_INT 1
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 1
88235: NEG
88236: PUSH
88237: LD_INT 0
88239: PUSH
88240: EMPTY
88241: LIST
88242: LIST
88243: PUSH
88244: LD_INT 1
88246: NEG
88247: PUSH
88248: LD_INT 1
88250: NEG
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 1
88258: NEG
88259: PUSH
88260: LD_INT 2
88262: NEG
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 0
88270: PUSH
88271: LD_INT 2
88273: NEG
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 1
88281: PUSH
88282: LD_INT 1
88284: NEG
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 2
88292: PUSH
88293: LD_INT 0
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 2
88302: PUSH
88303: LD_INT 1
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 2
88312: PUSH
88313: LD_INT 2
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 1
88322: PUSH
88323: LD_INT 2
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 0
88332: PUSH
88333: LD_INT 2
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 1
88342: NEG
88343: PUSH
88344: LD_INT 1
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 2
88353: NEG
88354: PUSH
88355: LD_INT 0
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 2
88364: NEG
88365: PUSH
88366: LD_INT 1
88368: NEG
88369: PUSH
88370: EMPTY
88371: LIST
88372: LIST
88373: PUSH
88374: LD_INT 2
88376: NEG
88377: PUSH
88378: LD_INT 2
88380: NEG
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: EMPTY
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88407: LD_ADDR_VAR 0 54
88411: PUSH
88412: LD_INT 0
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: PUSH
88422: LD_INT 0
88424: PUSH
88425: LD_INT 1
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 1
88435: PUSH
88436: LD_INT 0
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: LD_INT 1
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 0
88455: PUSH
88456: LD_INT 1
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: NEG
88466: PUSH
88467: LD_INT 0
88469: PUSH
88470: EMPTY
88471: LIST
88472: LIST
88473: PUSH
88474: LD_INT 1
88476: NEG
88477: PUSH
88478: LD_INT 1
88480: NEG
88481: PUSH
88482: EMPTY
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 1
88488: NEG
88489: PUSH
88490: LD_INT 2
88492: NEG
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 0
88500: PUSH
88501: LD_INT 2
88503: NEG
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 1
88511: PUSH
88512: LD_INT 1
88514: NEG
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 2
88522: PUSH
88523: LD_INT 0
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 2
88532: PUSH
88533: LD_INT 1
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 2
88542: PUSH
88543: LD_INT 2
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: PUSH
88553: LD_INT 2
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 0
88562: PUSH
88563: LD_INT 2
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 1
88572: NEG
88573: PUSH
88574: LD_INT 1
88576: PUSH
88577: EMPTY
88578: LIST
88579: LIST
88580: PUSH
88581: LD_INT 2
88583: NEG
88584: PUSH
88585: LD_INT 0
88587: PUSH
88588: EMPTY
88589: LIST
88590: LIST
88591: PUSH
88592: LD_INT 2
88594: NEG
88595: PUSH
88596: LD_INT 1
88598: NEG
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 2
88606: NEG
88607: PUSH
88608: LD_INT 2
88610: NEG
88611: PUSH
88612: EMPTY
88613: LIST
88614: LIST
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88637: LD_ADDR_VAR 0 55
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: LD_INT 0
88647: PUSH
88648: EMPTY
88649: LIST
88650: LIST
88651: PUSH
88652: LD_INT 0
88654: PUSH
88655: LD_INT 1
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 1
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 1
88675: PUSH
88676: LD_INT 1
88678: PUSH
88679: EMPTY
88680: LIST
88681: LIST
88682: PUSH
88683: LD_INT 0
88685: PUSH
88686: LD_INT 1
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PUSH
88693: LD_INT 1
88695: NEG
88696: PUSH
88697: LD_INT 0
88699: PUSH
88700: EMPTY
88701: LIST
88702: LIST
88703: PUSH
88704: LD_INT 1
88706: NEG
88707: PUSH
88708: LD_INT 1
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 1
88718: NEG
88719: PUSH
88720: LD_INT 2
88722: NEG
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 0
88730: PUSH
88731: LD_INT 2
88733: NEG
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 1
88741: PUSH
88742: LD_INT 1
88744: NEG
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 2
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 2
88762: PUSH
88763: LD_INT 1
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: LD_INT 2
88772: PUSH
88773: LD_INT 2
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 1
88782: PUSH
88783: LD_INT 2
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 0
88792: PUSH
88793: LD_INT 2
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: LD_INT 1
88802: NEG
88803: PUSH
88804: LD_INT 1
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 2
88813: NEG
88814: PUSH
88815: LD_INT 0
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 2
88824: NEG
88825: PUSH
88826: LD_INT 1
88828: NEG
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 2
88836: NEG
88837: PUSH
88838: LD_INT 2
88840: NEG
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88867: LD_ADDR_VAR 0 56
88871: PUSH
88872: LD_INT 0
88874: PUSH
88875: LD_INT 0
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: LD_INT 1
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: LD_INT 0
88898: PUSH
88899: EMPTY
88900: LIST
88901: LIST
88902: PUSH
88903: LD_INT 1
88905: PUSH
88906: LD_INT 1
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 0
88915: PUSH
88916: LD_INT 1
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: PUSH
88923: LD_INT 1
88925: NEG
88926: PUSH
88927: LD_INT 0
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: LD_INT 1
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 1
88948: NEG
88949: PUSH
88950: LD_INT 2
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 0
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 1
88971: PUSH
88972: LD_INT 1
88974: NEG
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 2
88982: PUSH
88983: LD_INT 0
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 2
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: LD_INT 2
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 1
89012: PUSH
89013: LD_INT 2
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 0
89022: PUSH
89023: LD_INT 2
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 1
89032: NEG
89033: PUSH
89034: LD_INT 1
89036: PUSH
89037: EMPTY
89038: LIST
89039: LIST
89040: PUSH
89041: LD_INT 2
89043: NEG
89044: PUSH
89045: LD_INT 0
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 2
89054: NEG
89055: PUSH
89056: LD_INT 1
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 2
89066: NEG
89067: PUSH
89068: LD_INT 2
89070: NEG
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89097: LD_ADDR_VAR 0 57
89101: PUSH
89102: LD_INT 0
89104: PUSH
89105: LD_INT 0
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 0
89114: PUSH
89115: LD_INT 1
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 1
89125: PUSH
89126: LD_INT 0
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 1
89135: PUSH
89136: LD_INT 1
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: PUSH
89143: LD_INT 0
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 1
89155: NEG
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: LD_INT 1
89170: NEG
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: LD_INT 2
89182: NEG
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 0
89190: PUSH
89191: LD_INT 2
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 2
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 2
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 2
89232: PUSH
89233: LD_INT 2
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 0
89252: PUSH
89253: LD_INT 2
89255: PUSH
89256: EMPTY
89257: LIST
89258: LIST
89259: PUSH
89260: LD_INT 1
89262: NEG
89263: PUSH
89264: LD_INT 1
89266: PUSH
89267: EMPTY
89268: LIST
89269: LIST
89270: PUSH
89271: LD_INT 2
89273: NEG
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 2
89284: NEG
89285: PUSH
89286: LD_INT 1
89288: NEG
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: LD_INT 2
89296: NEG
89297: PUSH
89298: LD_INT 2
89300: NEG
89301: PUSH
89302: EMPTY
89303: LIST
89304: LIST
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: LIST
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89327: LD_ADDR_VAR 0 58
89331: PUSH
89332: LD_INT 0
89334: PUSH
89335: LD_INT 0
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 0
89344: PUSH
89345: LD_INT 1
89347: NEG
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: LD_INT 0
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 1
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: LD_INT 1
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 1
89396: NEG
89397: PUSH
89398: LD_INT 1
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 1
89408: NEG
89409: PUSH
89410: LD_INT 2
89412: NEG
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 0
89420: PUSH
89421: LD_INT 2
89423: NEG
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 1
89431: PUSH
89432: LD_INT 1
89434: NEG
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 2
89442: PUSH
89443: LD_INT 0
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 2
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 2
89462: PUSH
89463: LD_INT 2
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: LD_INT 2
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 0
89482: PUSH
89483: LD_INT 2
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 1
89492: NEG
89493: PUSH
89494: LD_INT 1
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 2
89503: NEG
89504: PUSH
89505: LD_INT 0
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 2
89514: NEG
89515: PUSH
89516: LD_INT 1
89518: NEG
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: PUSH
89524: LD_INT 2
89526: NEG
89527: PUSH
89528: LD_INT 2
89530: NEG
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89557: LD_ADDR_VAR 0 59
89561: PUSH
89562: LD_INT 0
89564: PUSH
89565: LD_INT 0
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 0
89574: PUSH
89575: LD_INT 1
89577: NEG
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 1
89585: PUSH
89586: LD_INT 0
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 1
89595: PUSH
89596: LD_INT 1
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: PUSH
89603: LD_INT 0
89605: PUSH
89606: LD_INT 1
89608: PUSH
89609: EMPTY
89610: LIST
89611: LIST
89612: PUSH
89613: LD_INT 1
89615: NEG
89616: PUSH
89617: LD_INT 0
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: LD_INT 1
89630: NEG
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PUSH
89636: EMPTY
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89645: LD_ADDR_VAR 0 60
89649: PUSH
89650: LD_INT 0
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: EMPTY
89657: LIST
89658: LIST
89659: PUSH
89660: LD_INT 0
89662: PUSH
89663: LD_INT 1
89665: NEG
89666: PUSH
89667: EMPTY
89668: LIST
89669: LIST
89670: PUSH
89671: LD_INT 1
89673: PUSH
89674: LD_INT 0
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 1
89683: PUSH
89684: LD_INT 1
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 0
89693: PUSH
89694: LD_INT 1
89696: PUSH
89697: EMPTY
89698: LIST
89699: LIST
89700: PUSH
89701: LD_INT 1
89703: NEG
89704: PUSH
89705: LD_INT 0
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: LD_INT 1
89718: NEG
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89733: LD_ADDR_VAR 0 61
89737: PUSH
89738: LD_INT 0
89740: PUSH
89741: LD_INT 0
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 0
89750: PUSH
89751: LD_INT 1
89753: NEG
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 1
89761: PUSH
89762: LD_INT 0
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: PUSH
89772: LD_INT 1
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 0
89781: PUSH
89782: LD_INT 1
89784: PUSH
89785: EMPTY
89786: LIST
89787: LIST
89788: PUSH
89789: LD_INT 1
89791: NEG
89792: PUSH
89793: LD_INT 0
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: NEG
89803: PUSH
89804: LD_INT 1
89806: NEG
89807: PUSH
89808: EMPTY
89809: LIST
89810: LIST
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89821: LD_ADDR_VAR 0 62
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: LD_INT 0
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PUSH
89836: LD_INT 0
89838: PUSH
89839: LD_INT 1
89841: NEG
89842: PUSH
89843: EMPTY
89844: LIST
89845: LIST
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: LD_INT 0
89852: PUSH
89853: EMPTY
89854: LIST
89855: LIST
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: LD_INT 1
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 0
89869: PUSH
89870: LD_INT 1
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 1
89879: NEG
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 1
89890: NEG
89891: PUSH
89892: LD_INT 1
89894: NEG
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89909: LD_ADDR_VAR 0 63
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 0
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 0
89926: PUSH
89927: LD_INT 1
89929: NEG
89930: PUSH
89931: EMPTY
89932: LIST
89933: LIST
89934: PUSH
89935: LD_INT 1
89937: PUSH
89938: LD_INT 0
89940: PUSH
89941: EMPTY
89942: LIST
89943: LIST
89944: PUSH
89945: LD_INT 1
89947: PUSH
89948: LD_INT 1
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 0
89957: PUSH
89958: LD_INT 1
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 1
89967: NEG
89968: PUSH
89969: LD_INT 0
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 1
89978: NEG
89979: PUSH
89980: LD_INT 1
89982: NEG
89983: PUSH
89984: EMPTY
89985: LIST
89986: LIST
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: LIST
89992: LIST
89993: LIST
89994: LIST
89995: LIST
89996: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89997: LD_ADDR_VAR 0 64
90001: PUSH
90002: LD_INT 0
90004: PUSH
90005: LD_INT 0
90007: PUSH
90008: EMPTY
90009: LIST
90010: LIST
90011: PUSH
90012: LD_INT 0
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: EMPTY
90020: LIST
90021: LIST
90022: PUSH
90023: LD_INT 1
90025: PUSH
90026: LD_INT 0
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: LD_INT 1
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 0
90045: PUSH
90046: LD_INT 1
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 1
90055: NEG
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 1
90066: NEG
90067: PUSH
90068: LD_INT 1
90070: NEG
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: ST_TO_ADDR
// end ; 1 :
90085: GO 95982
90087: LD_INT 1
90089: DOUBLE
90090: EQUAL
90091: IFTRUE 90095
90093: GO 92718
90095: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90096: LD_ADDR_VAR 0 11
90100: PUSH
90101: LD_INT 1
90103: NEG
90104: PUSH
90105: LD_INT 3
90107: NEG
90108: PUSH
90109: EMPTY
90110: LIST
90111: LIST
90112: PUSH
90113: LD_INT 0
90115: PUSH
90116: LD_INT 3
90118: NEG
90119: PUSH
90120: EMPTY
90121: LIST
90122: LIST
90123: PUSH
90124: LD_INT 1
90126: PUSH
90127: LD_INT 2
90129: NEG
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: LIST
90139: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90140: LD_ADDR_VAR 0 12
90144: PUSH
90145: LD_INT 2
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 3
90158: PUSH
90159: LD_INT 0
90161: PUSH
90162: EMPTY
90163: LIST
90164: LIST
90165: PUSH
90166: LD_INT 3
90168: PUSH
90169: LD_INT 1
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: LIST
90180: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90181: LD_ADDR_VAR 0 13
90185: PUSH
90186: LD_INT 3
90188: PUSH
90189: LD_INT 2
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 3
90198: PUSH
90199: LD_INT 3
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: PUSH
90206: LD_INT 2
90208: PUSH
90209: LD_INT 3
90211: PUSH
90212: EMPTY
90213: LIST
90214: LIST
90215: PUSH
90216: EMPTY
90217: LIST
90218: LIST
90219: LIST
90220: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90221: LD_ADDR_VAR 0 14
90225: PUSH
90226: LD_INT 1
90228: PUSH
90229: LD_INT 3
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: PUSH
90236: LD_INT 0
90238: PUSH
90239: LD_INT 3
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 1
90248: NEG
90249: PUSH
90250: LD_INT 2
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: LIST
90261: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90262: LD_ADDR_VAR 0 15
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: LD_INT 1
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 3
90280: NEG
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 3
90291: NEG
90292: PUSH
90293: LD_INT 1
90295: NEG
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: LIST
90305: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90306: LD_ADDR_VAR 0 16
90310: PUSH
90311: LD_INT 2
90313: NEG
90314: PUSH
90315: LD_INT 3
90317: NEG
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 3
90325: NEG
90326: PUSH
90327: LD_INT 2
90329: NEG
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 3
90337: NEG
90338: PUSH
90339: LD_INT 3
90341: NEG
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: LIST
90351: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90352: LD_ADDR_VAR 0 17
90356: PUSH
90357: LD_INT 1
90359: NEG
90360: PUSH
90361: LD_INT 3
90363: NEG
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: LD_INT 3
90374: NEG
90375: PUSH
90376: EMPTY
90377: LIST
90378: LIST
90379: PUSH
90380: LD_INT 1
90382: PUSH
90383: LD_INT 2
90385: NEG
90386: PUSH
90387: EMPTY
90388: LIST
90389: LIST
90390: PUSH
90391: EMPTY
90392: LIST
90393: LIST
90394: LIST
90395: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90396: LD_ADDR_VAR 0 18
90400: PUSH
90401: LD_INT 2
90403: PUSH
90404: LD_INT 1
90406: NEG
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: LD_INT 3
90414: PUSH
90415: LD_INT 0
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 3
90424: PUSH
90425: LD_INT 1
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: LIST
90436: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90437: LD_ADDR_VAR 0 19
90441: PUSH
90442: LD_INT 3
90444: PUSH
90445: LD_INT 2
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 3
90454: PUSH
90455: LD_INT 3
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: PUSH
90462: LD_INT 2
90464: PUSH
90465: LD_INT 3
90467: PUSH
90468: EMPTY
90469: LIST
90470: LIST
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: LIST
90476: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90477: LD_ADDR_VAR 0 20
90481: PUSH
90482: LD_INT 1
90484: PUSH
90485: LD_INT 3
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 0
90494: PUSH
90495: LD_INT 3
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 1
90504: NEG
90505: PUSH
90506: LD_INT 2
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: LIST
90517: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90518: LD_ADDR_VAR 0 21
90522: PUSH
90523: LD_INT 2
90525: NEG
90526: PUSH
90527: LD_INT 1
90529: PUSH
90530: EMPTY
90531: LIST
90532: LIST
90533: PUSH
90534: LD_INT 3
90536: NEG
90537: PUSH
90538: LD_INT 0
90540: PUSH
90541: EMPTY
90542: LIST
90543: LIST
90544: PUSH
90545: LD_INT 3
90547: NEG
90548: PUSH
90549: LD_INT 1
90551: NEG
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: LIST
90561: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90562: LD_ADDR_VAR 0 22
90566: PUSH
90567: LD_INT 2
90569: NEG
90570: PUSH
90571: LD_INT 3
90573: NEG
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: LD_INT 3
90581: NEG
90582: PUSH
90583: LD_INT 2
90585: NEG
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PUSH
90591: LD_INT 3
90593: NEG
90594: PUSH
90595: LD_INT 3
90597: NEG
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90608: LD_ADDR_VAR 0 23
90612: PUSH
90613: LD_INT 0
90615: PUSH
90616: LD_INT 3
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 1
90626: NEG
90627: PUSH
90628: LD_INT 4
90630: NEG
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 1
90638: PUSH
90639: LD_INT 3
90641: NEG
90642: PUSH
90643: EMPTY
90644: LIST
90645: LIST
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: LIST
90651: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90652: LD_ADDR_VAR 0 24
90656: PUSH
90657: LD_INT 3
90659: PUSH
90660: LD_INT 0
90662: PUSH
90663: EMPTY
90664: LIST
90665: LIST
90666: PUSH
90667: LD_INT 3
90669: PUSH
90670: LD_INT 1
90672: NEG
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: PUSH
90678: LD_INT 4
90680: PUSH
90681: LD_INT 1
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: LIST
90692: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90693: LD_ADDR_VAR 0 25
90697: PUSH
90698: LD_INT 3
90700: PUSH
90701: LD_INT 3
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 4
90710: PUSH
90711: LD_INT 3
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 3
90720: PUSH
90721: LD_INT 4
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: LIST
90732: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90733: LD_ADDR_VAR 0 26
90737: PUSH
90738: LD_INT 0
90740: PUSH
90741: LD_INT 3
90743: PUSH
90744: EMPTY
90745: LIST
90746: LIST
90747: PUSH
90748: LD_INT 1
90750: PUSH
90751: LD_INT 4
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 1
90760: NEG
90761: PUSH
90762: LD_INT 3
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: EMPTY
90770: LIST
90771: LIST
90772: LIST
90773: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90774: LD_ADDR_VAR 0 27
90778: PUSH
90779: LD_INT 3
90781: NEG
90782: PUSH
90783: LD_INT 0
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: PUSH
90790: LD_INT 3
90792: NEG
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: PUSH
90801: LD_INT 4
90803: NEG
90804: PUSH
90805: LD_INT 1
90807: NEG
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: LIST
90817: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90818: LD_ADDR_VAR 0 28
90822: PUSH
90823: LD_INT 3
90825: NEG
90826: PUSH
90827: LD_INT 3
90829: NEG
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: LD_INT 3
90837: NEG
90838: PUSH
90839: LD_INT 4
90841: NEG
90842: PUSH
90843: EMPTY
90844: LIST
90845: LIST
90846: PUSH
90847: LD_INT 4
90849: NEG
90850: PUSH
90851: LD_INT 3
90853: NEG
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: LIST
90863: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90864: LD_ADDR_VAR 0 29
90868: PUSH
90869: LD_INT 1
90871: NEG
90872: PUSH
90873: LD_INT 3
90875: NEG
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 0
90883: PUSH
90884: LD_INT 3
90886: NEG
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: LD_INT 2
90897: NEG
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 1
90905: NEG
90906: PUSH
90907: LD_INT 4
90909: NEG
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 0
90917: PUSH
90918: LD_INT 4
90920: NEG
90921: PUSH
90922: EMPTY
90923: LIST
90924: LIST
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: LD_INT 3
90931: NEG
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: PUSH
90937: LD_INT 1
90939: NEG
90940: PUSH
90941: LD_INT 5
90943: NEG
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 0
90951: PUSH
90952: LD_INT 5
90954: NEG
90955: PUSH
90956: EMPTY
90957: LIST
90958: LIST
90959: PUSH
90960: LD_INT 1
90962: PUSH
90963: LD_INT 4
90965: NEG
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 1
90973: NEG
90974: PUSH
90975: LD_INT 6
90977: NEG
90978: PUSH
90979: EMPTY
90980: LIST
90981: LIST
90982: PUSH
90983: LD_INT 0
90985: PUSH
90986: LD_INT 6
90988: NEG
90989: PUSH
90990: EMPTY
90991: LIST
90992: LIST
90993: PUSH
90994: LD_INT 1
90996: PUSH
90997: LD_INT 5
90999: NEG
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91019: LD_ADDR_VAR 0 30
91023: PUSH
91024: LD_INT 2
91026: PUSH
91027: LD_INT 1
91029: NEG
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PUSH
91035: LD_INT 3
91037: PUSH
91038: LD_INT 0
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 3
91047: PUSH
91048: LD_INT 1
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 3
91057: PUSH
91058: LD_INT 1
91060: NEG
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 4
91068: PUSH
91069: LD_INT 0
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 4
91078: PUSH
91079: LD_INT 1
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 4
91088: PUSH
91089: LD_INT 1
91091: NEG
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 5
91099: PUSH
91100: LD_INT 0
91102: PUSH
91103: EMPTY
91104: LIST
91105: LIST
91106: PUSH
91107: LD_INT 5
91109: PUSH
91110: LD_INT 1
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PUSH
91117: LD_INT 5
91119: PUSH
91120: LD_INT 1
91122: NEG
91123: PUSH
91124: EMPTY
91125: LIST
91126: LIST
91127: PUSH
91128: LD_INT 6
91130: PUSH
91131: LD_INT 0
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 6
91140: PUSH
91141: LD_INT 1
91143: PUSH
91144: EMPTY
91145: LIST
91146: LIST
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: LIST
91161: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91162: LD_ADDR_VAR 0 31
91166: PUSH
91167: LD_INT 3
91169: PUSH
91170: LD_INT 2
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: PUSH
91177: LD_INT 3
91179: PUSH
91180: LD_INT 3
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 2
91189: PUSH
91190: LD_INT 3
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 4
91199: PUSH
91200: LD_INT 3
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 4
91209: PUSH
91210: LD_INT 4
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 3
91219: PUSH
91220: LD_INT 4
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 5
91229: PUSH
91230: LD_INT 4
91232: PUSH
91233: EMPTY
91234: LIST
91235: LIST
91236: PUSH
91237: LD_INT 5
91239: PUSH
91240: LD_INT 5
91242: PUSH
91243: EMPTY
91244: LIST
91245: LIST
91246: PUSH
91247: LD_INT 4
91249: PUSH
91250: LD_INT 5
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: PUSH
91257: LD_INT 6
91259: PUSH
91260: LD_INT 5
91262: PUSH
91263: EMPTY
91264: LIST
91265: LIST
91266: PUSH
91267: LD_INT 6
91269: PUSH
91270: LD_INT 6
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 5
91279: PUSH
91280: LD_INT 6
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: EMPTY
91288: LIST
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
91301: LD_ADDR_VAR 0 32
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: LD_INT 3
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 0
91318: PUSH
91319: LD_INT 3
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 1
91328: NEG
91329: PUSH
91330: LD_INT 2
91332: PUSH
91333: EMPTY
91334: LIST
91335: LIST
91336: PUSH
91337: LD_INT 1
91339: PUSH
91340: LD_INT 4
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: LD_INT 0
91349: PUSH
91350: LD_INT 4
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 1
91359: NEG
91360: PUSH
91361: LD_INT 3
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: LD_INT 1
91370: PUSH
91371: LD_INT 5
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: PUSH
91378: LD_INT 0
91380: PUSH
91381: LD_INT 5
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 1
91390: NEG
91391: PUSH
91392: LD_INT 4
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 1
91401: PUSH
91402: LD_INT 6
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 0
91411: PUSH
91412: LD_INT 6
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 1
91421: NEG
91422: PUSH
91423: LD_INT 5
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91444: LD_ADDR_VAR 0 33
91448: PUSH
91449: LD_INT 2
91451: NEG
91452: PUSH
91453: LD_INT 1
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 3
91462: NEG
91463: PUSH
91464: LD_INT 0
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 3
91473: NEG
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 3
91485: NEG
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 4
91496: NEG
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 4
91507: NEG
91508: PUSH
91509: LD_INT 1
91511: NEG
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 4
91519: NEG
91520: PUSH
91521: LD_INT 1
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 5
91530: NEG
91531: PUSH
91532: LD_INT 0
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 5
91541: NEG
91542: PUSH
91543: LD_INT 1
91545: NEG
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 5
91553: NEG
91554: PUSH
91555: LD_INT 1
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 6
91564: NEG
91565: PUSH
91566: LD_INT 0
91568: PUSH
91569: EMPTY
91570: LIST
91571: LIST
91572: PUSH
91573: LD_INT 6
91575: NEG
91576: PUSH
91577: LD_INT 1
91579: NEG
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: EMPTY
91586: LIST
91587: LIST
91588: LIST
91589: LIST
91590: LIST
91591: LIST
91592: LIST
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91599: LD_ADDR_VAR 0 34
91603: PUSH
91604: LD_INT 2
91606: NEG
91607: PUSH
91608: LD_INT 3
91610: NEG
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 3
91618: NEG
91619: PUSH
91620: LD_INT 2
91622: NEG
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 3
91630: NEG
91631: PUSH
91632: LD_INT 3
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 3
91642: NEG
91643: PUSH
91644: LD_INT 4
91646: NEG
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 4
91654: NEG
91655: PUSH
91656: LD_INT 3
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 4
91666: NEG
91667: PUSH
91668: LD_INT 4
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 4
91678: NEG
91679: PUSH
91680: LD_INT 5
91682: NEG
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 5
91690: NEG
91691: PUSH
91692: LD_INT 4
91694: NEG
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 5
91702: NEG
91703: PUSH
91704: LD_INT 5
91706: NEG
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 5
91714: NEG
91715: PUSH
91716: LD_INT 6
91718: NEG
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 6
91726: NEG
91727: PUSH
91728: LD_INT 5
91730: NEG
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PUSH
91736: LD_INT 6
91738: NEG
91739: PUSH
91740: LD_INT 6
91742: NEG
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91762: LD_ADDR_VAR 0 41
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 2
91772: NEG
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 1
91780: NEG
91781: PUSH
91782: LD_INT 3
91784: NEG
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: PUSH
91790: LD_INT 1
91792: PUSH
91793: LD_INT 2
91795: NEG
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: LIST
91805: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91806: LD_ADDR_VAR 0 42
91810: PUSH
91811: LD_INT 2
91813: PUSH
91814: LD_INT 0
91816: PUSH
91817: EMPTY
91818: LIST
91819: LIST
91820: PUSH
91821: LD_INT 2
91823: PUSH
91824: LD_INT 1
91826: NEG
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 3
91834: PUSH
91835: LD_INT 1
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: LIST
91846: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91847: LD_ADDR_VAR 0 43
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 2
91857: PUSH
91858: EMPTY
91859: LIST
91860: LIST
91861: PUSH
91862: LD_INT 3
91864: PUSH
91865: LD_INT 2
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 2
91874: PUSH
91875: LD_INT 3
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: LIST
91886: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91887: LD_ADDR_VAR 0 44
91891: PUSH
91892: LD_INT 0
91894: PUSH
91895: LD_INT 2
91897: PUSH
91898: EMPTY
91899: LIST
91900: LIST
91901: PUSH
91902: LD_INT 1
91904: PUSH
91905: LD_INT 3
91907: PUSH
91908: EMPTY
91909: LIST
91910: LIST
91911: PUSH
91912: LD_INT 1
91914: NEG
91915: PUSH
91916: LD_INT 2
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: LIST
91927: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91928: LD_ADDR_VAR 0 45
91932: PUSH
91933: LD_INT 2
91935: NEG
91936: PUSH
91937: LD_INT 0
91939: PUSH
91940: EMPTY
91941: LIST
91942: LIST
91943: PUSH
91944: LD_INT 2
91946: NEG
91947: PUSH
91948: LD_INT 1
91950: PUSH
91951: EMPTY
91952: LIST
91953: LIST
91954: PUSH
91955: LD_INT 3
91957: NEG
91958: PUSH
91959: LD_INT 1
91961: NEG
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: LIST
91971: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91972: LD_ADDR_VAR 0 46
91976: PUSH
91977: LD_INT 2
91979: NEG
91980: PUSH
91981: LD_INT 2
91983: NEG
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 2
91991: NEG
91992: PUSH
91993: LD_INT 3
91995: NEG
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: LD_INT 3
92003: NEG
92004: PUSH
92005: LD_INT 2
92007: NEG
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: PUSH
92013: EMPTY
92014: LIST
92015: LIST
92016: LIST
92017: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92018: LD_ADDR_VAR 0 47
92022: PUSH
92023: LD_INT 2
92025: NEG
92026: PUSH
92027: LD_INT 3
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 1
92037: NEG
92038: PUSH
92039: LD_INT 3
92041: NEG
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92051: LD_ADDR_VAR 0 48
92055: PUSH
92056: LD_INT 1
92058: PUSH
92059: LD_INT 2
92061: NEG
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: PUSH
92067: LD_INT 2
92069: PUSH
92070: LD_INT 1
92072: NEG
92073: PUSH
92074: EMPTY
92075: LIST
92076: LIST
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92082: LD_ADDR_VAR 0 49
92086: PUSH
92087: LD_INT 3
92089: PUSH
92090: LD_INT 1
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 3
92099: PUSH
92100: LD_INT 2
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: EMPTY
92108: LIST
92109: LIST
92110: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92111: LD_ADDR_VAR 0 50
92115: PUSH
92116: LD_INT 2
92118: PUSH
92119: LD_INT 3
92121: PUSH
92122: EMPTY
92123: LIST
92124: LIST
92125: PUSH
92126: LD_INT 1
92128: PUSH
92129: LD_INT 3
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: PUSH
92136: EMPTY
92137: LIST
92138: LIST
92139: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92140: LD_ADDR_VAR 0 51
92144: PUSH
92145: LD_INT 1
92147: NEG
92148: PUSH
92149: LD_INT 2
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 2
92158: NEG
92159: PUSH
92160: LD_INT 1
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PUSH
92167: EMPTY
92168: LIST
92169: LIST
92170: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92171: LD_ADDR_VAR 0 52
92175: PUSH
92176: LD_INT 3
92178: NEG
92179: PUSH
92180: LD_INT 1
92182: NEG
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 3
92190: NEG
92191: PUSH
92192: LD_INT 2
92194: NEG
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92204: LD_ADDR_VAR 0 53
92208: PUSH
92209: LD_INT 1
92211: NEG
92212: PUSH
92213: LD_INT 3
92215: NEG
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: PUSH
92221: LD_INT 0
92223: PUSH
92224: LD_INT 3
92226: NEG
92227: PUSH
92228: EMPTY
92229: LIST
92230: LIST
92231: PUSH
92232: LD_INT 1
92234: PUSH
92235: LD_INT 2
92237: NEG
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: LIST
92247: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92248: LD_ADDR_VAR 0 54
92252: PUSH
92253: LD_INT 2
92255: PUSH
92256: LD_INT 1
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: LD_INT 3
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: EMPTY
92271: LIST
92272: LIST
92273: PUSH
92274: LD_INT 3
92276: PUSH
92277: LD_INT 1
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: LIST
92288: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92289: LD_ADDR_VAR 0 55
92293: PUSH
92294: LD_INT 3
92296: PUSH
92297: LD_INT 2
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 3
92306: PUSH
92307: LD_INT 3
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 2
92316: PUSH
92317: LD_INT 3
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92329: LD_ADDR_VAR 0 56
92333: PUSH
92334: LD_INT 1
92336: PUSH
92337: LD_INT 3
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PUSH
92344: LD_INT 0
92346: PUSH
92347: LD_INT 3
92349: PUSH
92350: EMPTY
92351: LIST
92352: LIST
92353: PUSH
92354: LD_INT 1
92356: NEG
92357: PUSH
92358: LD_INT 2
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: LIST
92369: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92370: LD_ADDR_VAR 0 57
92374: PUSH
92375: LD_INT 2
92377: NEG
92378: PUSH
92379: LD_INT 1
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 3
92388: NEG
92389: PUSH
92390: LD_INT 0
92392: PUSH
92393: EMPTY
92394: LIST
92395: LIST
92396: PUSH
92397: LD_INT 3
92399: NEG
92400: PUSH
92401: LD_INT 1
92403: NEG
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: LIST
92413: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92414: LD_ADDR_VAR 0 58
92418: PUSH
92419: LD_INT 2
92421: NEG
92422: PUSH
92423: LD_INT 3
92425: NEG
92426: PUSH
92427: EMPTY
92428: LIST
92429: LIST
92430: PUSH
92431: LD_INT 3
92433: NEG
92434: PUSH
92435: LD_INT 2
92437: NEG
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: PUSH
92443: LD_INT 3
92445: NEG
92446: PUSH
92447: LD_INT 3
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: EMPTY
92456: LIST
92457: LIST
92458: LIST
92459: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92460: LD_ADDR_VAR 0 59
92464: PUSH
92465: LD_INT 1
92467: NEG
92468: PUSH
92469: LD_INT 2
92471: NEG
92472: PUSH
92473: EMPTY
92474: LIST
92475: LIST
92476: PUSH
92477: LD_INT 0
92479: PUSH
92480: LD_INT 2
92482: NEG
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: PUSH
92488: LD_INT 1
92490: PUSH
92491: LD_INT 1
92493: NEG
92494: PUSH
92495: EMPTY
92496: LIST
92497: LIST
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: LIST
92503: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92504: LD_ADDR_VAR 0 60
92508: PUSH
92509: LD_INT 1
92511: PUSH
92512: LD_INT 1
92514: NEG
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: LD_INT 2
92522: PUSH
92523: LD_INT 0
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PUSH
92530: LD_INT 2
92532: PUSH
92533: LD_INT 1
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: LIST
92544: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92545: LD_ADDR_VAR 0 61
92549: PUSH
92550: LD_INT 2
92552: PUSH
92553: LD_INT 1
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 2
92562: PUSH
92563: LD_INT 2
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PUSH
92570: LD_INT 1
92572: PUSH
92573: LD_INT 2
92575: PUSH
92576: EMPTY
92577: LIST
92578: LIST
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: LIST
92584: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92585: LD_ADDR_VAR 0 62
92589: PUSH
92590: LD_INT 1
92592: PUSH
92593: LD_INT 2
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PUSH
92600: LD_INT 0
92602: PUSH
92603: LD_INT 2
92605: PUSH
92606: EMPTY
92607: LIST
92608: LIST
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: LD_INT 1
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92626: LD_ADDR_VAR 0 63
92630: PUSH
92631: LD_INT 1
92633: NEG
92634: PUSH
92635: LD_INT 1
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 2
92644: NEG
92645: PUSH
92646: LD_INT 0
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: LD_INT 2
92655: NEG
92656: PUSH
92657: LD_INT 1
92659: NEG
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: LIST
92669: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92670: LD_ADDR_VAR 0 64
92674: PUSH
92675: LD_INT 1
92677: NEG
92678: PUSH
92679: LD_INT 2
92681: NEG
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 2
92689: NEG
92690: PUSH
92691: LD_INT 1
92693: NEG
92694: PUSH
92695: EMPTY
92696: LIST
92697: LIST
92698: PUSH
92699: LD_INT 2
92701: NEG
92702: PUSH
92703: LD_INT 2
92705: NEG
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: LIST
92715: ST_TO_ADDR
// end ; 2 :
92716: GO 95982
92718: LD_INT 2
92720: DOUBLE
92721: EQUAL
92722: IFTRUE 92726
92724: GO 95981
92726: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92727: LD_ADDR_VAR 0 29
92731: PUSH
92732: LD_INT 4
92734: PUSH
92735: LD_INT 0
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 4
92744: PUSH
92745: LD_INT 1
92747: NEG
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 5
92755: PUSH
92756: LD_INT 0
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 5
92765: PUSH
92766: LD_INT 1
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 4
92775: PUSH
92776: LD_INT 1
92778: PUSH
92779: EMPTY
92780: LIST
92781: LIST
92782: PUSH
92783: LD_INT 3
92785: PUSH
92786: LD_INT 0
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 3
92795: PUSH
92796: LD_INT 1
92798: NEG
92799: PUSH
92800: EMPTY
92801: LIST
92802: LIST
92803: PUSH
92804: LD_INT 3
92806: PUSH
92807: LD_INT 2
92809: NEG
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: LD_INT 5
92817: PUSH
92818: LD_INT 2
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 3
92827: PUSH
92828: LD_INT 3
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 3
92837: PUSH
92838: LD_INT 2
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 4
92847: PUSH
92848: LD_INT 3
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 4
92857: PUSH
92858: LD_INT 4
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 3
92867: PUSH
92868: LD_INT 4
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: LD_INT 2
92877: PUSH
92878: LD_INT 3
92880: PUSH
92881: EMPTY
92882: LIST
92883: LIST
92884: PUSH
92885: LD_INT 2
92887: PUSH
92888: LD_INT 2
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 4
92897: PUSH
92898: LD_INT 2
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 2
92907: PUSH
92908: LD_INT 4
92910: PUSH
92911: EMPTY
92912: LIST
92913: LIST
92914: PUSH
92915: LD_INT 0
92917: PUSH
92918: LD_INT 4
92920: PUSH
92921: EMPTY
92922: LIST
92923: LIST
92924: PUSH
92925: LD_INT 0
92927: PUSH
92928: LD_INT 3
92930: PUSH
92931: EMPTY
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 1
92937: PUSH
92938: LD_INT 4
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 1
92947: PUSH
92948: LD_INT 5
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 0
92957: PUSH
92958: LD_INT 5
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 1
92967: NEG
92968: PUSH
92969: LD_INT 4
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 1
92978: NEG
92979: PUSH
92980: LD_INT 3
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 2
92989: PUSH
92990: LD_INT 5
92992: PUSH
92993: EMPTY
92994: LIST
92995: LIST
92996: PUSH
92997: LD_INT 2
92999: NEG
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 3
93010: NEG
93011: PUSH
93012: LD_INT 0
93014: PUSH
93015: EMPTY
93016: LIST
93017: LIST
93018: PUSH
93019: LD_INT 3
93021: NEG
93022: PUSH
93023: LD_INT 1
93025: NEG
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 2
93033: NEG
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 2
93044: NEG
93045: PUSH
93046: LD_INT 1
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 3
93055: NEG
93056: PUSH
93057: LD_INT 1
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 4
93066: NEG
93067: PUSH
93068: LD_INT 0
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 4
93077: NEG
93078: PUSH
93079: LD_INT 1
93081: NEG
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: PUSH
93087: LD_INT 4
93089: NEG
93090: PUSH
93091: LD_INT 2
93093: NEG
93094: PUSH
93095: EMPTY
93096: LIST
93097: LIST
93098: PUSH
93099: LD_INT 2
93101: NEG
93102: PUSH
93103: LD_INT 2
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: LD_INT 4
93112: NEG
93113: PUSH
93114: LD_INT 4
93116: NEG
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: PUSH
93122: LD_INT 4
93124: NEG
93125: PUSH
93126: LD_INT 5
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 3
93136: NEG
93137: PUSH
93138: LD_INT 4
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 3
93148: NEG
93149: PUSH
93150: LD_INT 3
93152: NEG
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: LD_INT 4
93160: NEG
93161: PUSH
93162: LD_INT 3
93164: NEG
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PUSH
93170: LD_INT 5
93172: NEG
93173: PUSH
93174: LD_INT 4
93176: NEG
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 5
93184: NEG
93185: PUSH
93186: LD_INT 5
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 3
93196: NEG
93197: PUSH
93198: LD_INT 5
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: LD_INT 5
93208: NEG
93209: PUSH
93210: LD_INT 3
93212: NEG
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: EMPTY
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: LIST
93224: LIST
93225: LIST
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: LIST
93244: LIST
93245: LIST
93246: LIST
93247: LIST
93248: LIST
93249: LIST
93250: LIST
93251: LIST
93252: LIST
93253: LIST
93254: LIST
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
93265: LD_ADDR_VAR 0 30
93269: PUSH
93270: LD_INT 4
93272: PUSH
93273: LD_INT 4
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 4
93282: PUSH
93283: LD_INT 3
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 5
93292: PUSH
93293: LD_INT 4
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: LD_INT 5
93302: PUSH
93303: LD_INT 5
93305: PUSH
93306: EMPTY
93307: LIST
93308: LIST
93309: PUSH
93310: LD_INT 4
93312: PUSH
93313: LD_INT 5
93315: PUSH
93316: EMPTY
93317: LIST
93318: LIST
93319: PUSH
93320: LD_INT 3
93322: PUSH
93323: LD_INT 4
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 3
93332: PUSH
93333: LD_INT 3
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 5
93342: PUSH
93343: LD_INT 3
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 3
93352: PUSH
93353: LD_INT 5
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 0
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 0
93372: PUSH
93373: LD_INT 2
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 1
93382: PUSH
93383: LD_INT 3
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 1
93392: PUSH
93393: LD_INT 4
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 0
93402: PUSH
93403: LD_INT 4
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 1
93412: NEG
93413: PUSH
93414: LD_INT 3
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 1
93423: NEG
93424: PUSH
93425: LD_INT 2
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 2
93434: PUSH
93435: LD_INT 4
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: PUSH
93442: LD_INT 2
93444: NEG
93445: PUSH
93446: LD_INT 2
93448: PUSH
93449: EMPTY
93450: LIST
93451: LIST
93452: PUSH
93453: LD_INT 4
93455: NEG
93456: PUSH
93457: LD_INT 0
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 4
93466: NEG
93467: PUSH
93468: LD_INT 1
93470: NEG
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 3
93478: NEG
93479: PUSH
93480: LD_INT 0
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: PUSH
93487: LD_INT 3
93489: NEG
93490: PUSH
93491: LD_INT 1
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 4
93500: NEG
93501: PUSH
93502: LD_INT 1
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: LD_INT 5
93511: NEG
93512: PUSH
93513: LD_INT 0
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 5
93522: NEG
93523: PUSH
93524: LD_INT 1
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 5
93534: NEG
93535: PUSH
93536: LD_INT 2
93538: NEG
93539: PUSH
93540: EMPTY
93541: LIST
93542: LIST
93543: PUSH
93544: LD_INT 3
93546: NEG
93547: PUSH
93548: LD_INT 2
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: LD_INT 3
93557: NEG
93558: PUSH
93559: LD_INT 3
93561: NEG
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: PUSH
93567: LD_INT 3
93569: NEG
93570: PUSH
93571: LD_INT 4
93573: NEG
93574: PUSH
93575: EMPTY
93576: LIST
93577: LIST
93578: PUSH
93579: LD_INT 2
93581: NEG
93582: PUSH
93583: LD_INT 3
93585: NEG
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: PUSH
93591: LD_INT 2
93593: NEG
93594: PUSH
93595: LD_INT 2
93597: NEG
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 3
93605: NEG
93606: PUSH
93607: LD_INT 2
93609: NEG
93610: PUSH
93611: EMPTY
93612: LIST
93613: LIST
93614: PUSH
93615: LD_INT 4
93617: NEG
93618: PUSH
93619: LD_INT 3
93621: NEG
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 4
93629: NEG
93630: PUSH
93631: LD_INT 4
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 2
93641: NEG
93642: PUSH
93643: LD_INT 4
93645: NEG
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 4
93653: NEG
93654: PUSH
93655: LD_INT 2
93657: NEG
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 0
93665: PUSH
93666: LD_INT 4
93668: NEG
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 0
93676: PUSH
93677: LD_INT 5
93679: NEG
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 1
93687: PUSH
93688: LD_INT 4
93690: NEG
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: LD_INT 1
93698: PUSH
93699: LD_INT 3
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 0
93709: PUSH
93710: LD_INT 3
93712: NEG
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 1
93720: NEG
93721: PUSH
93722: LD_INT 4
93724: NEG
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 1
93732: NEG
93733: PUSH
93734: LD_INT 5
93736: NEG
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 2
93744: PUSH
93745: LD_INT 3
93747: NEG
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: LD_INT 2
93755: NEG
93756: PUSH
93757: LD_INT 5
93759: NEG
93760: PUSH
93761: EMPTY
93762: LIST
93763: LIST
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93812: LD_ADDR_VAR 0 31
93816: PUSH
93817: LD_INT 0
93819: PUSH
93820: LD_INT 4
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 0
93829: PUSH
93830: LD_INT 3
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 1
93839: PUSH
93840: LD_INT 4
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 1
93849: PUSH
93850: LD_INT 5
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: PUSH
93857: LD_INT 0
93859: PUSH
93860: LD_INT 5
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: PUSH
93867: LD_INT 1
93869: NEG
93870: PUSH
93871: LD_INT 4
93873: PUSH
93874: EMPTY
93875: LIST
93876: LIST
93877: PUSH
93878: LD_INT 1
93880: NEG
93881: PUSH
93882: LD_INT 3
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 2
93891: PUSH
93892: LD_INT 5
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 2
93901: NEG
93902: PUSH
93903: LD_INT 3
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 3
93912: NEG
93913: PUSH
93914: LD_INT 0
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 3
93923: NEG
93924: PUSH
93925: LD_INT 1
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: LD_INT 0
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 2
93946: NEG
93947: PUSH
93948: LD_INT 1
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: PUSH
93955: LD_INT 3
93957: NEG
93958: PUSH
93959: LD_INT 1
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 4
93968: NEG
93969: PUSH
93970: LD_INT 0
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 4
93979: NEG
93980: PUSH
93981: LD_INT 1
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 4
93991: NEG
93992: PUSH
93993: LD_INT 2
93995: NEG
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 2
94003: NEG
94004: PUSH
94005: LD_INT 2
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 4
94014: NEG
94015: PUSH
94016: LD_INT 4
94018: NEG
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 4
94026: NEG
94027: PUSH
94028: LD_INT 5
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 3
94038: NEG
94039: PUSH
94040: LD_INT 4
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: LD_INT 3
94050: NEG
94051: PUSH
94052: LD_INT 3
94054: NEG
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 4
94062: NEG
94063: PUSH
94064: LD_INT 3
94066: NEG
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 5
94074: NEG
94075: PUSH
94076: LD_INT 4
94078: NEG
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 5
94086: NEG
94087: PUSH
94088: LD_INT 5
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 3
94098: NEG
94099: PUSH
94100: LD_INT 5
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: LD_INT 5
94110: NEG
94111: PUSH
94112: LD_INT 3
94114: NEG
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: PUSH
94120: LD_INT 0
94122: PUSH
94123: LD_INT 3
94125: NEG
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 0
94133: PUSH
94134: LD_INT 4
94136: NEG
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 1
94144: PUSH
94145: LD_INT 3
94147: NEG
94148: PUSH
94149: EMPTY
94150: LIST
94151: LIST
94152: PUSH
94153: LD_INT 1
94155: PUSH
94156: LD_INT 2
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 0
94166: PUSH
94167: LD_INT 2
94169: NEG
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 1
94177: NEG
94178: PUSH
94179: LD_INT 3
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 1
94189: NEG
94190: PUSH
94191: LD_INT 4
94193: NEG
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: PUSH
94199: LD_INT 2
94201: PUSH
94202: LD_INT 2
94204: NEG
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: LD_INT 2
94212: NEG
94213: PUSH
94214: LD_INT 4
94216: NEG
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 4
94224: PUSH
94225: LD_INT 0
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: LD_INT 4
94234: PUSH
94235: LD_INT 1
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 5
94245: PUSH
94246: LD_INT 0
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 5
94255: PUSH
94256: LD_INT 1
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 4
94265: PUSH
94266: LD_INT 1
94268: PUSH
94269: EMPTY
94270: LIST
94271: LIST
94272: PUSH
94273: LD_INT 3
94275: PUSH
94276: LD_INT 0
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 3
94285: PUSH
94286: LD_INT 1
94288: NEG
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 3
94296: PUSH
94297: LD_INT 2
94299: NEG
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 5
94307: PUSH
94308: LD_INT 2
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
94362: LD_ADDR_VAR 0 32
94366: PUSH
94367: LD_INT 4
94369: NEG
94370: PUSH
94371: LD_INT 0
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 4
94380: NEG
94381: PUSH
94382: LD_INT 1
94384: NEG
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 3
94392: NEG
94393: PUSH
94394: LD_INT 0
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 3
94403: NEG
94404: PUSH
94405: LD_INT 1
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: LD_INT 4
94414: NEG
94415: PUSH
94416: LD_INT 1
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: PUSH
94423: LD_INT 5
94425: NEG
94426: PUSH
94427: LD_INT 0
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 5
94436: NEG
94437: PUSH
94438: LD_INT 1
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 5
94448: NEG
94449: PUSH
94450: LD_INT 2
94452: NEG
94453: PUSH
94454: EMPTY
94455: LIST
94456: LIST
94457: PUSH
94458: LD_INT 3
94460: NEG
94461: PUSH
94462: LD_INT 2
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 3
94471: NEG
94472: PUSH
94473: LD_INT 3
94475: NEG
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 3
94483: NEG
94484: PUSH
94485: LD_INT 4
94487: NEG
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 2
94495: NEG
94496: PUSH
94497: LD_INT 3
94499: NEG
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 2
94507: NEG
94508: PUSH
94509: LD_INT 2
94511: NEG
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 3
94519: NEG
94520: PUSH
94521: LD_INT 2
94523: NEG
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 4
94531: NEG
94532: PUSH
94533: LD_INT 3
94535: NEG
94536: PUSH
94537: EMPTY
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 4
94543: NEG
94544: PUSH
94545: LD_INT 4
94547: NEG
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: PUSH
94553: LD_INT 2
94555: NEG
94556: PUSH
94557: LD_INT 4
94559: NEG
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 4
94567: NEG
94568: PUSH
94569: LD_INT 2
94571: NEG
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: LD_INT 0
94579: PUSH
94580: LD_INT 4
94582: NEG
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: LD_INT 0
94590: PUSH
94591: LD_INT 5
94593: NEG
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: PUSH
94599: LD_INT 1
94601: PUSH
94602: LD_INT 4
94604: NEG
94605: PUSH
94606: EMPTY
94607: LIST
94608: LIST
94609: PUSH
94610: LD_INT 1
94612: PUSH
94613: LD_INT 3
94615: NEG
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: LD_INT 0
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 1
94634: NEG
94635: PUSH
94636: LD_INT 4
94638: NEG
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: PUSH
94644: LD_INT 1
94646: NEG
94647: PUSH
94648: LD_INT 5
94650: NEG
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PUSH
94656: LD_INT 2
94658: PUSH
94659: LD_INT 3
94661: NEG
94662: PUSH
94663: EMPTY
94664: LIST
94665: LIST
94666: PUSH
94667: LD_INT 2
94669: NEG
94670: PUSH
94671: LD_INT 5
94673: NEG
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 3
94681: PUSH
94682: LD_INT 0
94684: PUSH
94685: EMPTY
94686: LIST
94687: LIST
94688: PUSH
94689: LD_INT 3
94691: PUSH
94692: LD_INT 1
94694: NEG
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 4
94702: PUSH
94703: LD_INT 0
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 4
94712: PUSH
94713: LD_INT 1
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 3
94722: PUSH
94723: LD_INT 1
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: PUSH
94730: LD_INT 2
94732: PUSH
94733: LD_INT 0
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 2
94742: PUSH
94743: LD_INT 1
94745: NEG
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: LD_INT 2
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 4
94764: PUSH
94765: LD_INT 2
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PUSH
94772: LD_INT 4
94774: PUSH
94775: LD_INT 4
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: PUSH
94782: LD_INT 4
94784: PUSH
94785: LD_INT 3
94787: PUSH
94788: EMPTY
94789: LIST
94790: LIST
94791: PUSH
94792: LD_INT 5
94794: PUSH
94795: LD_INT 4
94797: PUSH
94798: EMPTY
94799: LIST
94800: LIST
94801: PUSH
94802: LD_INT 5
94804: PUSH
94805: LD_INT 5
94807: PUSH
94808: EMPTY
94809: LIST
94810: LIST
94811: PUSH
94812: LD_INT 4
94814: PUSH
94815: LD_INT 5
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 3
94824: PUSH
94825: LD_INT 4
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 3
94834: PUSH
94835: LD_INT 3
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 5
94844: PUSH
94845: LD_INT 3
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 3
94854: PUSH
94855: LD_INT 5
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: LIST
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94909: LD_ADDR_VAR 0 33
94913: PUSH
94914: LD_INT 4
94916: NEG
94917: PUSH
94918: LD_INT 4
94920: NEG
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 4
94928: NEG
94929: PUSH
94930: LD_INT 5
94932: NEG
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: LD_INT 3
94940: NEG
94941: PUSH
94942: LD_INT 4
94944: NEG
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 3
94952: NEG
94953: PUSH
94954: LD_INT 3
94956: NEG
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 4
94964: NEG
94965: PUSH
94966: LD_INT 3
94968: NEG
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 5
94976: NEG
94977: PUSH
94978: LD_INT 4
94980: NEG
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 5
94988: NEG
94989: PUSH
94990: LD_INT 5
94992: NEG
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 3
95000: NEG
95001: PUSH
95002: LD_INT 5
95004: NEG
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PUSH
95010: LD_INT 5
95012: NEG
95013: PUSH
95014: LD_INT 3
95016: NEG
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 0
95024: PUSH
95025: LD_INT 3
95027: NEG
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 0
95035: PUSH
95036: LD_INT 4
95038: NEG
95039: PUSH
95040: EMPTY
95041: LIST
95042: LIST
95043: PUSH
95044: LD_INT 1
95046: PUSH
95047: LD_INT 3
95049: NEG
95050: PUSH
95051: EMPTY
95052: LIST
95053: LIST
95054: PUSH
95055: LD_INT 1
95057: PUSH
95058: LD_INT 2
95060: NEG
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: PUSH
95066: LD_INT 0
95068: PUSH
95069: LD_INT 2
95071: NEG
95072: PUSH
95073: EMPTY
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 1
95079: NEG
95080: PUSH
95081: LD_INT 3
95083: NEG
95084: PUSH
95085: EMPTY
95086: LIST
95087: LIST
95088: PUSH
95089: LD_INT 1
95091: NEG
95092: PUSH
95093: LD_INT 4
95095: NEG
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: LD_INT 2
95103: PUSH
95104: LD_INT 2
95106: NEG
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PUSH
95112: LD_INT 2
95114: NEG
95115: PUSH
95116: LD_INT 4
95118: NEG
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: PUSH
95124: LD_INT 4
95126: PUSH
95127: LD_INT 0
95129: PUSH
95130: EMPTY
95131: LIST
95132: LIST
95133: PUSH
95134: LD_INT 4
95136: PUSH
95137: LD_INT 1
95139: NEG
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 5
95147: PUSH
95148: LD_INT 0
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 5
95157: PUSH
95158: LD_INT 1
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: LD_INT 4
95167: PUSH
95168: LD_INT 1
95170: PUSH
95171: EMPTY
95172: LIST
95173: LIST
95174: PUSH
95175: LD_INT 3
95177: PUSH
95178: LD_INT 0
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 3
95187: PUSH
95188: LD_INT 1
95190: NEG
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: PUSH
95196: LD_INT 3
95198: PUSH
95199: LD_INT 2
95201: NEG
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 5
95209: PUSH
95210: LD_INT 2
95212: PUSH
95213: EMPTY
95214: LIST
95215: LIST
95216: PUSH
95217: LD_INT 3
95219: PUSH
95220: LD_INT 3
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 3
95229: PUSH
95230: LD_INT 2
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 4
95239: PUSH
95240: LD_INT 3
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 4
95249: PUSH
95250: LD_INT 4
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 3
95259: PUSH
95260: LD_INT 4
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 2
95269: PUSH
95270: LD_INT 3
95272: PUSH
95273: EMPTY
95274: LIST
95275: LIST
95276: PUSH
95277: LD_INT 2
95279: PUSH
95280: LD_INT 2
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 4
95289: PUSH
95290: LD_INT 2
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 2
95299: PUSH
95300: LD_INT 4
95302: PUSH
95303: EMPTY
95304: LIST
95305: LIST
95306: PUSH
95307: LD_INT 0
95309: PUSH
95310: LD_INT 4
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: LD_INT 0
95319: PUSH
95320: LD_INT 3
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 1
95329: PUSH
95330: LD_INT 4
95332: PUSH
95333: EMPTY
95334: LIST
95335: LIST
95336: PUSH
95337: LD_INT 1
95339: PUSH
95340: LD_INT 5
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 0
95349: PUSH
95350: LD_INT 5
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 1
95359: NEG
95360: PUSH
95361: LD_INT 4
95363: PUSH
95364: EMPTY
95365: LIST
95366: LIST
95367: PUSH
95368: LD_INT 1
95370: NEG
95371: PUSH
95372: LD_INT 3
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 2
95381: PUSH
95382: LD_INT 5
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PUSH
95389: LD_INT 2
95391: NEG
95392: PUSH
95393: LD_INT 3
95395: PUSH
95396: EMPTY
95397: LIST
95398: LIST
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95447: LD_ADDR_VAR 0 34
95451: PUSH
95452: LD_INT 0
95454: PUSH
95455: LD_INT 4
95457: NEG
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: PUSH
95463: LD_INT 0
95465: PUSH
95466: LD_INT 5
95468: NEG
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 1
95476: PUSH
95477: LD_INT 4
95479: NEG
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 1
95487: PUSH
95488: LD_INT 3
95490: NEG
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 0
95498: PUSH
95499: LD_INT 3
95501: NEG
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 1
95509: NEG
95510: PUSH
95511: LD_INT 4
95513: NEG
95514: PUSH
95515: EMPTY
95516: LIST
95517: LIST
95518: PUSH
95519: LD_INT 1
95521: NEG
95522: PUSH
95523: LD_INT 5
95525: NEG
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 2
95533: PUSH
95534: LD_INT 3
95536: NEG
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 2
95544: NEG
95545: PUSH
95546: LD_INT 5
95548: NEG
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 3
95556: PUSH
95557: LD_INT 0
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: LD_INT 3
95566: PUSH
95567: LD_INT 1
95569: NEG
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PUSH
95575: LD_INT 4
95577: PUSH
95578: LD_INT 0
95580: PUSH
95581: EMPTY
95582: LIST
95583: LIST
95584: PUSH
95585: LD_INT 4
95587: PUSH
95588: LD_INT 1
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 3
95597: PUSH
95598: LD_INT 1
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 2
95607: PUSH
95608: LD_INT 0
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: LD_INT 2
95617: PUSH
95618: LD_INT 1
95620: NEG
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 2
95628: PUSH
95629: LD_INT 2
95631: NEG
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 4
95639: PUSH
95640: LD_INT 2
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 4
95649: PUSH
95650: LD_INT 4
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 4
95659: PUSH
95660: LD_INT 3
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PUSH
95667: LD_INT 5
95669: PUSH
95670: LD_INT 4
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 5
95679: PUSH
95680: LD_INT 5
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PUSH
95687: LD_INT 4
95689: PUSH
95690: LD_INT 5
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: PUSH
95697: LD_INT 3
95699: PUSH
95700: LD_INT 4
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 3
95709: PUSH
95710: LD_INT 3
95712: PUSH
95713: EMPTY
95714: LIST
95715: LIST
95716: PUSH
95717: LD_INT 5
95719: PUSH
95720: LD_INT 3
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 3
95729: PUSH
95730: LD_INT 5
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 0
95739: PUSH
95740: LD_INT 3
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 0
95749: PUSH
95750: LD_INT 2
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 1
95759: PUSH
95760: LD_INT 3
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 1
95769: PUSH
95770: LD_INT 4
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 0
95779: PUSH
95780: LD_INT 4
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: PUSH
95787: LD_INT 1
95789: NEG
95790: PUSH
95791: LD_INT 3
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: LD_INT 1
95800: NEG
95801: PUSH
95802: LD_INT 2
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: PUSH
95809: LD_INT 2
95811: PUSH
95812: LD_INT 4
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 2
95821: NEG
95822: PUSH
95823: LD_INT 2
95825: PUSH
95826: EMPTY
95827: LIST
95828: LIST
95829: PUSH
95830: LD_INT 4
95832: NEG
95833: PUSH
95834: LD_INT 0
95836: PUSH
95837: EMPTY
95838: LIST
95839: LIST
95840: PUSH
95841: LD_INT 4
95843: NEG
95844: PUSH
95845: LD_INT 1
95847: NEG
95848: PUSH
95849: EMPTY
95850: LIST
95851: LIST
95852: PUSH
95853: LD_INT 3
95855: NEG
95856: PUSH
95857: LD_INT 0
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: PUSH
95864: LD_INT 3
95866: NEG
95867: PUSH
95868: LD_INT 1
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 4
95877: NEG
95878: PUSH
95879: LD_INT 1
95881: PUSH
95882: EMPTY
95883: LIST
95884: LIST
95885: PUSH
95886: LD_INT 5
95888: NEG
95889: PUSH
95890: LD_INT 0
95892: PUSH
95893: EMPTY
95894: LIST
95895: LIST
95896: PUSH
95897: LD_INT 5
95899: NEG
95900: PUSH
95901: LD_INT 1
95903: NEG
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 5
95911: NEG
95912: PUSH
95913: LD_INT 2
95915: NEG
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 3
95923: NEG
95924: PUSH
95925: LD_INT 2
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: PUSH
95932: EMPTY
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: ST_TO_ADDR
// end ; end ;
95979: GO 95982
95981: POP
// case btype of b_depot , b_warehouse :
95982: LD_VAR 0 1
95986: PUSH
95987: LD_INT 0
95989: DOUBLE
95990: EQUAL
95991: IFTRUE 96001
95993: LD_INT 1
95995: DOUBLE
95996: EQUAL
95997: IFTRUE 96001
95999: GO 96202
96001: POP
// case nation of nation_american :
96002: LD_VAR 0 5
96006: PUSH
96007: LD_INT 1
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96015
96013: GO 96071
96015: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
96016: LD_ADDR_VAR 0 9
96020: PUSH
96021: LD_VAR 0 11
96025: PUSH
96026: LD_VAR 0 12
96030: PUSH
96031: LD_VAR 0 13
96035: PUSH
96036: LD_VAR 0 14
96040: PUSH
96041: LD_VAR 0 15
96045: PUSH
96046: LD_VAR 0 16
96050: PUSH
96051: EMPTY
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: PUSH
96059: LD_VAR 0 4
96063: PUSH
96064: LD_INT 1
96066: PLUS
96067: ARRAY
96068: ST_TO_ADDR
96069: GO 96200
96071: LD_INT 2
96073: DOUBLE
96074: EQUAL
96075: IFTRUE 96079
96077: GO 96135
96079: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
96080: LD_ADDR_VAR 0 9
96084: PUSH
96085: LD_VAR 0 17
96089: PUSH
96090: LD_VAR 0 18
96094: PUSH
96095: LD_VAR 0 19
96099: PUSH
96100: LD_VAR 0 20
96104: PUSH
96105: LD_VAR 0 21
96109: PUSH
96110: LD_VAR 0 22
96114: PUSH
96115: EMPTY
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: PUSH
96123: LD_VAR 0 4
96127: PUSH
96128: LD_INT 1
96130: PLUS
96131: ARRAY
96132: ST_TO_ADDR
96133: GO 96200
96135: LD_INT 3
96137: DOUBLE
96138: EQUAL
96139: IFTRUE 96143
96141: GO 96199
96143: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96144: LD_ADDR_VAR 0 9
96148: PUSH
96149: LD_VAR 0 23
96153: PUSH
96154: LD_VAR 0 24
96158: PUSH
96159: LD_VAR 0 25
96163: PUSH
96164: LD_VAR 0 26
96168: PUSH
96169: LD_VAR 0 27
96173: PUSH
96174: LD_VAR 0 28
96178: PUSH
96179: EMPTY
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: PUSH
96187: LD_VAR 0 4
96191: PUSH
96192: LD_INT 1
96194: PLUS
96195: ARRAY
96196: ST_TO_ADDR
96197: GO 96200
96199: POP
96200: GO 96755
96202: LD_INT 2
96204: DOUBLE
96205: EQUAL
96206: IFTRUE 96216
96208: LD_INT 3
96210: DOUBLE
96211: EQUAL
96212: IFTRUE 96216
96214: GO 96272
96216: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96217: LD_ADDR_VAR 0 9
96221: PUSH
96222: LD_VAR 0 29
96226: PUSH
96227: LD_VAR 0 30
96231: PUSH
96232: LD_VAR 0 31
96236: PUSH
96237: LD_VAR 0 32
96241: PUSH
96242: LD_VAR 0 33
96246: PUSH
96247: LD_VAR 0 34
96251: PUSH
96252: EMPTY
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: PUSH
96260: LD_VAR 0 4
96264: PUSH
96265: LD_INT 1
96267: PLUS
96268: ARRAY
96269: ST_TO_ADDR
96270: GO 96755
96272: LD_INT 16
96274: DOUBLE
96275: EQUAL
96276: IFTRUE 96334
96278: LD_INT 17
96280: DOUBLE
96281: EQUAL
96282: IFTRUE 96334
96284: LD_INT 18
96286: DOUBLE
96287: EQUAL
96288: IFTRUE 96334
96290: LD_INT 19
96292: DOUBLE
96293: EQUAL
96294: IFTRUE 96334
96296: LD_INT 22
96298: DOUBLE
96299: EQUAL
96300: IFTRUE 96334
96302: LD_INT 20
96304: DOUBLE
96305: EQUAL
96306: IFTRUE 96334
96308: LD_INT 21
96310: DOUBLE
96311: EQUAL
96312: IFTRUE 96334
96314: LD_INT 23
96316: DOUBLE
96317: EQUAL
96318: IFTRUE 96334
96320: LD_INT 24
96322: DOUBLE
96323: EQUAL
96324: IFTRUE 96334
96326: LD_INT 25
96328: DOUBLE
96329: EQUAL
96330: IFTRUE 96334
96332: GO 96390
96334: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
96335: LD_ADDR_VAR 0 9
96339: PUSH
96340: LD_VAR 0 35
96344: PUSH
96345: LD_VAR 0 36
96349: PUSH
96350: LD_VAR 0 37
96354: PUSH
96355: LD_VAR 0 38
96359: PUSH
96360: LD_VAR 0 39
96364: PUSH
96365: LD_VAR 0 40
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: PUSH
96378: LD_VAR 0 4
96382: PUSH
96383: LD_INT 1
96385: PLUS
96386: ARRAY
96387: ST_TO_ADDR
96388: GO 96755
96390: LD_INT 6
96392: DOUBLE
96393: EQUAL
96394: IFTRUE 96446
96396: LD_INT 7
96398: DOUBLE
96399: EQUAL
96400: IFTRUE 96446
96402: LD_INT 8
96404: DOUBLE
96405: EQUAL
96406: IFTRUE 96446
96408: LD_INT 13
96410: DOUBLE
96411: EQUAL
96412: IFTRUE 96446
96414: LD_INT 12
96416: DOUBLE
96417: EQUAL
96418: IFTRUE 96446
96420: LD_INT 15
96422: DOUBLE
96423: EQUAL
96424: IFTRUE 96446
96426: LD_INT 11
96428: DOUBLE
96429: EQUAL
96430: IFTRUE 96446
96432: LD_INT 14
96434: DOUBLE
96435: EQUAL
96436: IFTRUE 96446
96438: LD_INT 10
96440: DOUBLE
96441: EQUAL
96442: IFTRUE 96446
96444: GO 96502
96446: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
96447: LD_ADDR_VAR 0 9
96451: PUSH
96452: LD_VAR 0 41
96456: PUSH
96457: LD_VAR 0 42
96461: PUSH
96462: LD_VAR 0 43
96466: PUSH
96467: LD_VAR 0 44
96471: PUSH
96472: LD_VAR 0 45
96476: PUSH
96477: LD_VAR 0 46
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: PUSH
96490: LD_VAR 0 4
96494: PUSH
96495: LD_INT 1
96497: PLUS
96498: ARRAY
96499: ST_TO_ADDR
96500: GO 96755
96502: LD_INT 36
96504: DOUBLE
96505: EQUAL
96506: IFTRUE 96510
96508: GO 96566
96510: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96511: LD_ADDR_VAR 0 9
96515: PUSH
96516: LD_VAR 0 47
96520: PUSH
96521: LD_VAR 0 48
96525: PUSH
96526: LD_VAR 0 49
96530: PUSH
96531: LD_VAR 0 50
96535: PUSH
96536: LD_VAR 0 51
96540: PUSH
96541: LD_VAR 0 52
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: PUSH
96554: LD_VAR 0 4
96558: PUSH
96559: LD_INT 1
96561: PLUS
96562: ARRAY
96563: ST_TO_ADDR
96564: GO 96755
96566: LD_INT 4
96568: DOUBLE
96569: EQUAL
96570: IFTRUE 96592
96572: LD_INT 5
96574: DOUBLE
96575: EQUAL
96576: IFTRUE 96592
96578: LD_INT 34
96580: DOUBLE
96581: EQUAL
96582: IFTRUE 96592
96584: LD_INT 37
96586: DOUBLE
96587: EQUAL
96588: IFTRUE 96592
96590: GO 96648
96592: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96593: LD_ADDR_VAR 0 9
96597: PUSH
96598: LD_VAR 0 53
96602: PUSH
96603: LD_VAR 0 54
96607: PUSH
96608: LD_VAR 0 55
96612: PUSH
96613: LD_VAR 0 56
96617: PUSH
96618: LD_VAR 0 57
96622: PUSH
96623: LD_VAR 0 58
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: PUSH
96636: LD_VAR 0 4
96640: PUSH
96641: LD_INT 1
96643: PLUS
96644: ARRAY
96645: ST_TO_ADDR
96646: GO 96755
96648: LD_INT 31
96650: DOUBLE
96651: EQUAL
96652: IFTRUE 96698
96654: LD_INT 32
96656: DOUBLE
96657: EQUAL
96658: IFTRUE 96698
96660: LD_INT 33
96662: DOUBLE
96663: EQUAL
96664: IFTRUE 96698
96666: LD_INT 27
96668: DOUBLE
96669: EQUAL
96670: IFTRUE 96698
96672: LD_INT 26
96674: DOUBLE
96675: EQUAL
96676: IFTRUE 96698
96678: LD_INT 28
96680: DOUBLE
96681: EQUAL
96682: IFTRUE 96698
96684: LD_INT 29
96686: DOUBLE
96687: EQUAL
96688: IFTRUE 96698
96690: LD_INT 30
96692: DOUBLE
96693: EQUAL
96694: IFTRUE 96698
96696: GO 96754
96698: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
96699: LD_ADDR_VAR 0 9
96703: PUSH
96704: LD_VAR 0 59
96708: PUSH
96709: LD_VAR 0 60
96713: PUSH
96714: LD_VAR 0 61
96718: PUSH
96719: LD_VAR 0 62
96723: PUSH
96724: LD_VAR 0 63
96728: PUSH
96729: LD_VAR 0 64
96733: PUSH
96734: EMPTY
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: PUSH
96742: LD_VAR 0 4
96746: PUSH
96747: LD_INT 1
96749: PLUS
96750: ARRAY
96751: ST_TO_ADDR
96752: GO 96755
96754: POP
// temp_list2 = [ ] ;
96755: LD_ADDR_VAR 0 10
96759: PUSH
96760: EMPTY
96761: ST_TO_ADDR
// for i in temp_list do
96762: LD_ADDR_VAR 0 8
96766: PUSH
96767: LD_VAR 0 9
96771: PUSH
96772: FOR_IN
96773: IFFALSE 96825
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96775: LD_ADDR_VAR 0 10
96779: PUSH
96780: LD_VAR 0 10
96784: PUSH
96785: LD_VAR 0 8
96789: PUSH
96790: LD_INT 1
96792: ARRAY
96793: PUSH
96794: LD_VAR 0 2
96798: PLUS
96799: PUSH
96800: LD_VAR 0 8
96804: PUSH
96805: LD_INT 2
96807: ARRAY
96808: PUSH
96809: LD_VAR 0 3
96813: PLUS
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: EMPTY
96820: LIST
96821: ADD
96822: ST_TO_ADDR
96823: GO 96772
96825: POP
96826: POP
// result = temp_list2 ;
96827: LD_ADDR_VAR 0 7
96831: PUSH
96832: LD_VAR 0 10
96836: ST_TO_ADDR
// end ;
96837: LD_VAR 0 7
96841: RET
// export function EnemyInRange ( unit , dist ) ; begin
96842: LD_INT 0
96844: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96845: LD_ADDR_VAR 0 3
96849: PUSH
96850: LD_VAR 0 1
96854: PPUSH
96855: CALL_OW 255
96859: PPUSH
96860: LD_VAR 0 1
96864: PPUSH
96865: CALL_OW 250
96869: PPUSH
96870: LD_VAR 0 1
96874: PPUSH
96875: CALL_OW 251
96879: PPUSH
96880: LD_VAR 0 2
96884: PPUSH
96885: CALL 70946 0 4
96889: PUSH
96890: LD_INT 4
96892: ARRAY
96893: ST_TO_ADDR
// end ;
96894: LD_VAR 0 3
96898: RET
// export function PlayerSeeMe ( unit ) ; begin
96899: LD_INT 0
96901: PPUSH
// result := See ( your_side , unit ) ;
96902: LD_ADDR_VAR 0 2
96906: PUSH
96907: LD_OWVAR 2
96911: PPUSH
96912: LD_VAR 0 1
96916: PPUSH
96917: CALL_OW 292
96921: ST_TO_ADDR
// end ;
96922: LD_VAR 0 2
96926: RET
// export function ReverseDir ( unit ) ; begin
96927: LD_INT 0
96929: PPUSH
// if not unit then
96930: LD_VAR 0 1
96934: NOT
96935: IFFALSE 96939
// exit ;
96937: GO 96962
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
96939: LD_ADDR_VAR 0 2
96943: PUSH
96944: LD_VAR 0 1
96948: PPUSH
96949: CALL_OW 254
96953: PUSH
96954: LD_INT 3
96956: PLUS
96957: PUSH
96958: LD_INT 6
96960: MOD
96961: ST_TO_ADDR
// end ;
96962: LD_VAR 0 2
96966: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96967: LD_INT 0
96969: PPUSH
96970: PPUSH
96971: PPUSH
96972: PPUSH
96973: PPUSH
// if not hexes then
96974: LD_VAR 0 2
96978: NOT
96979: IFFALSE 96983
// exit ;
96981: GO 97131
// dist := 9999 ;
96983: LD_ADDR_VAR 0 5
96987: PUSH
96988: LD_INT 9999
96990: ST_TO_ADDR
// for i = 1 to hexes do
96991: LD_ADDR_VAR 0 4
96995: PUSH
96996: DOUBLE
96997: LD_INT 1
96999: DEC
97000: ST_TO_ADDR
97001: LD_VAR 0 2
97005: PUSH
97006: FOR_TO
97007: IFFALSE 97119
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97009: LD_VAR 0 1
97013: PPUSH
97014: LD_VAR 0 2
97018: PUSH
97019: LD_VAR 0 4
97023: ARRAY
97024: PUSH
97025: LD_INT 1
97027: ARRAY
97028: PPUSH
97029: LD_VAR 0 2
97033: PUSH
97034: LD_VAR 0 4
97038: ARRAY
97039: PUSH
97040: LD_INT 2
97042: ARRAY
97043: PPUSH
97044: CALL_OW 297
97048: PUSH
97049: LD_VAR 0 5
97053: LESS
97054: IFFALSE 97117
// begin hex := hexes [ i ] ;
97056: LD_ADDR_VAR 0 7
97060: PUSH
97061: LD_VAR 0 2
97065: PUSH
97066: LD_VAR 0 4
97070: ARRAY
97071: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97072: LD_ADDR_VAR 0 5
97076: PUSH
97077: LD_VAR 0 1
97081: PPUSH
97082: LD_VAR 0 2
97086: PUSH
97087: LD_VAR 0 4
97091: ARRAY
97092: PUSH
97093: LD_INT 1
97095: ARRAY
97096: PPUSH
97097: LD_VAR 0 2
97101: PUSH
97102: LD_VAR 0 4
97106: ARRAY
97107: PUSH
97108: LD_INT 2
97110: ARRAY
97111: PPUSH
97112: CALL_OW 297
97116: ST_TO_ADDR
// end ; end ;
97117: GO 97006
97119: POP
97120: POP
// result := hex ;
97121: LD_ADDR_VAR 0 3
97125: PUSH
97126: LD_VAR 0 7
97130: ST_TO_ADDR
// end ;
97131: LD_VAR 0 3
97135: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97136: LD_INT 0
97138: PPUSH
97139: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97140: LD_VAR 0 1
97144: NOT
97145: PUSH
97146: LD_VAR 0 1
97150: PUSH
97151: LD_INT 21
97153: PUSH
97154: LD_INT 2
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: PUSH
97161: LD_INT 23
97163: PUSH
97164: LD_INT 2
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PPUSH
97175: CALL_OW 69
97179: IN
97180: NOT
97181: OR
97182: IFFALSE 97186
// exit ;
97184: GO 97233
// for i = 1 to 3 do
97186: LD_ADDR_VAR 0 3
97190: PUSH
97191: DOUBLE
97192: LD_INT 1
97194: DEC
97195: ST_TO_ADDR
97196: LD_INT 3
97198: PUSH
97199: FOR_TO
97200: IFFALSE 97231
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97202: LD_VAR 0 1
97206: PPUSH
97207: CALL_OW 250
97211: PPUSH
97212: LD_VAR 0 1
97216: PPUSH
97217: CALL_OW 251
97221: PPUSH
97222: LD_INT 1
97224: PPUSH
97225: CALL_OW 453
97229: GO 97199
97231: POP
97232: POP
// end ;
97233: LD_VAR 0 2
97237: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
97238: LD_INT 0
97240: PPUSH
97241: PPUSH
97242: PPUSH
97243: PPUSH
97244: PPUSH
97245: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
97246: LD_VAR 0 1
97250: NOT
97251: PUSH
97252: LD_VAR 0 2
97256: NOT
97257: OR
97258: PUSH
97259: LD_VAR 0 1
97263: PPUSH
97264: CALL_OW 314
97268: OR
97269: IFFALSE 97273
// exit ;
97271: GO 97714
// x := GetX ( enemy_unit ) ;
97273: LD_ADDR_VAR 0 7
97277: PUSH
97278: LD_VAR 0 2
97282: PPUSH
97283: CALL_OW 250
97287: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
97288: LD_ADDR_VAR 0 8
97292: PUSH
97293: LD_VAR 0 2
97297: PPUSH
97298: CALL_OW 251
97302: ST_TO_ADDR
// if not x or not y then
97303: LD_VAR 0 7
97307: NOT
97308: PUSH
97309: LD_VAR 0 8
97313: NOT
97314: OR
97315: IFFALSE 97319
// exit ;
97317: GO 97714
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
97319: LD_ADDR_VAR 0 6
97323: PUSH
97324: LD_VAR 0 7
97328: PPUSH
97329: LD_INT 0
97331: PPUSH
97332: LD_INT 4
97334: PPUSH
97335: CALL_OW 272
97339: PUSH
97340: LD_VAR 0 8
97344: PPUSH
97345: LD_INT 0
97347: PPUSH
97348: LD_INT 4
97350: PPUSH
97351: CALL_OW 273
97355: PUSH
97356: EMPTY
97357: LIST
97358: LIST
97359: PUSH
97360: LD_VAR 0 7
97364: PPUSH
97365: LD_INT 1
97367: PPUSH
97368: LD_INT 4
97370: PPUSH
97371: CALL_OW 272
97375: PUSH
97376: LD_VAR 0 8
97380: PPUSH
97381: LD_INT 1
97383: PPUSH
97384: LD_INT 4
97386: PPUSH
97387: CALL_OW 273
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_VAR 0 7
97400: PPUSH
97401: LD_INT 2
97403: PPUSH
97404: LD_INT 4
97406: PPUSH
97407: CALL_OW 272
97411: PUSH
97412: LD_VAR 0 8
97416: PPUSH
97417: LD_INT 2
97419: PPUSH
97420: LD_INT 4
97422: PPUSH
97423: CALL_OW 273
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: PUSH
97432: LD_VAR 0 7
97436: PPUSH
97437: LD_INT 3
97439: PPUSH
97440: LD_INT 4
97442: PPUSH
97443: CALL_OW 272
97447: PUSH
97448: LD_VAR 0 8
97452: PPUSH
97453: LD_INT 3
97455: PPUSH
97456: LD_INT 4
97458: PPUSH
97459: CALL_OW 273
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: LD_VAR 0 7
97472: PPUSH
97473: LD_INT 4
97475: PPUSH
97476: LD_INT 4
97478: PPUSH
97479: CALL_OW 272
97483: PUSH
97484: LD_VAR 0 8
97488: PPUSH
97489: LD_INT 4
97491: PPUSH
97492: LD_INT 4
97494: PPUSH
97495: CALL_OW 273
97499: PUSH
97500: EMPTY
97501: LIST
97502: LIST
97503: PUSH
97504: LD_VAR 0 7
97508: PPUSH
97509: LD_INT 5
97511: PPUSH
97512: LD_INT 4
97514: PPUSH
97515: CALL_OW 272
97519: PUSH
97520: LD_VAR 0 8
97524: PPUSH
97525: LD_INT 5
97527: PPUSH
97528: LD_INT 4
97530: PPUSH
97531: CALL_OW 273
97535: PUSH
97536: EMPTY
97537: LIST
97538: LIST
97539: PUSH
97540: EMPTY
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: ST_TO_ADDR
// for i = tmp downto 1 do
97548: LD_ADDR_VAR 0 4
97552: PUSH
97553: DOUBLE
97554: LD_VAR 0 6
97558: INC
97559: ST_TO_ADDR
97560: LD_INT 1
97562: PUSH
97563: FOR_DOWNTO
97564: IFFALSE 97665
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97566: LD_VAR 0 6
97570: PUSH
97571: LD_VAR 0 4
97575: ARRAY
97576: PUSH
97577: LD_INT 1
97579: ARRAY
97580: PPUSH
97581: LD_VAR 0 6
97585: PUSH
97586: LD_VAR 0 4
97590: ARRAY
97591: PUSH
97592: LD_INT 2
97594: ARRAY
97595: PPUSH
97596: CALL_OW 488
97600: NOT
97601: PUSH
97602: LD_VAR 0 6
97606: PUSH
97607: LD_VAR 0 4
97611: ARRAY
97612: PUSH
97613: LD_INT 1
97615: ARRAY
97616: PPUSH
97617: LD_VAR 0 6
97621: PUSH
97622: LD_VAR 0 4
97626: ARRAY
97627: PUSH
97628: LD_INT 2
97630: ARRAY
97631: PPUSH
97632: CALL_OW 428
97636: PUSH
97637: LD_INT 0
97639: NONEQUAL
97640: OR
97641: IFFALSE 97663
// tmp := Delete ( tmp , i ) ;
97643: LD_ADDR_VAR 0 6
97647: PUSH
97648: LD_VAR 0 6
97652: PPUSH
97653: LD_VAR 0 4
97657: PPUSH
97658: CALL_OW 3
97662: ST_TO_ADDR
97663: GO 97563
97665: POP
97666: POP
// j := GetClosestHex ( unit , tmp ) ;
97667: LD_ADDR_VAR 0 5
97671: PUSH
97672: LD_VAR 0 1
97676: PPUSH
97677: LD_VAR 0 6
97681: PPUSH
97682: CALL 96967 0 2
97686: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97687: LD_VAR 0 1
97691: PPUSH
97692: LD_VAR 0 5
97696: PUSH
97697: LD_INT 1
97699: ARRAY
97700: PPUSH
97701: LD_VAR 0 5
97705: PUSH
97706: LD_INT 2
97708: ARRAY
97709: PPUSH
97710: CALL_OW 111
// end ;
97714: LD_VAR 0 3
97718: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97719: LD_INT 0
97721: PPUSH
97722: PPUSH
97723: PPUSH
// uc_side = 0 ;
97724: LD_ADDR_OWVAR 20
97728: PUSH
97729: LD_INT 0
97731: ST_TO_ADDR
// uc_nation = 0 ;
97732: LD_ADDR_OWVAR 21
97736: PUSH
97737: LD_INT 0
97739: ST_TO_ADDR
// InitHc ;
97740: CALL_OW 19
// InitVc ;
97744: CALL_OW 20
// if mastodonts then
97748: LD_VAR 0 6
97752: IFFALSE 97819
// for i = 1 to mastodonts do
97754: LD_ADDR_VAR 0 11
97758: PUSH
97759: DOUBLE
97760: LD_INT 1
97762: DEC
97763: ST_TO_ADDR
97764: LD_VAR 0 6
97768: PUSH
97769: FOR_TO
97770: IFFALSE 97817
// begin vc_chassis := 31 ;
97772: LD_ADDR_OWVAR 37
97776: PUSH
97777: LD_INT 31
97779: ST_TO_ADDR
// vc_control := control_rider ;
97780: LD_ADDR_OWVAR 38
97784: PUSH
97785: LD_INT 4
97787: ST_TO_ADDR
// animal := CreateVehicle ;
97788: LD_ADDR_VAR 0 12
97792: PUSH
97793: CALL_OW 45
97797: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97798: LD_VAR 0 12
97802: PPUSH
97803: LD_VAR 0 8
97807: PPUSH
97808: LD_INT 0
97810: PPUSH
97811: CALL 99888 0 3
// end ;
97815: GO 97769
97817: POP
97818: POP
// if horses then
97819: LD_VAR 0 5
97823: IFFALSE 97890
// for i = 1 to horses do
97825: LD_ADDR_VAR 0 11
97829: PUSH
97830: DOUBLE
97831: LD_INT 1
97833: DEC
97834: ST_TO_ADDR
97835: LD_VAR 0 5
97839: PUSH
97840: FOR_TO
97841: IFFALSE 97888
// begin hc_class := 21 ;
97843: LD_ADDR_OWVAR 28
97847: PUSH
97848: LD_INT 21
97850: ST_TO_ADDR
// hc_gallery :=  ;
97851: LD_ADDR_OWVAR 33
97855: PUSH
97856: LD_STRING 
97858: ST_TO_ADDR
// animal := CreateHuman ;
97859: LD_ADDR_VAR 0 12
97863: PUSH
97864: CALL_OW 44
97868: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97869: LD_VAR 0 12
97873: PPUSH
97874: LD_VAR 0 8
97878: PPUSH
97879: LD_INT 0
97881: PPUSH
97882: CALL 99888 0 3
// end ;
97886: GO 97840
97888: POP
97889: POP
// if birds then
97890: LD_VAR 0 1
97894: IFFALSE 97961
// for i = 1 to birds do
97896: LD_ADDR_VAR 0 11
97900: PUSH
97901: DOUBLE
97902: LD_INT 1
97904: DEC
97905: ST_TO_ADDR
97906: LD_VAR 0 1
97910: PUSH
97911: FOR_TO
97912: IFFALSE 97959
// begin hc_class = 18 ;
97914: LD_ADDR_OWVAR 28
97918: PUSH
97919: LD_INT 18
97921: ST_TO_ADDR
// hc_gallery =  ;
97922: LD_ADDR_OWVAR 33
97926: PUSH
97927: LD_STRING 
97929: ST_TO_ADDR
// animal := CreateHuman ;
97930: LD_ADDR_VAR 0 12
97934: PUSH
97935: CALL_OW 44
97939: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97940: LD_VAR 0 12
97944: PPUSH
97945: LD_VAR 0 8
97949: PPUSH
97950: LD_INT 0
97952: PPUSH
97953: CALL 99888 0 3
// end ;
97957: GO 97911
97959: POP
97960: POP
// if tigers then
97961: LD_VAR 0 2
97965: IFFALSE 98049
// for i = 1 to tigers do
97967: LD_ADDR_VAR 0 11
97971: PUSH
97972: DOUBLE
97973: LD_INT 1
97975: DEC
97976: ST_TO_ADDR
97977: LD_VAR 0 2
97981: PUSH
97982: FOR_TO
97983: IFFALSE 98047
// begin hc_class = class_tiger ;
97985: LD_ADDR_OWVAR 28
97989: PUSH
97990: LD_INT 14
97992: ST_TO_ADDR
// hc_gallery =  ;
97993: LD_ADDR_OWVAR 33
97997: PUSH
97998: LD_STRING 
98000: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98001: LD_ADDR_OWVAR 35
98005: PUSH
98006: LD_INT 7
98008: NEG
98009: PPUSH
98010: LD_INT 7
98012: PPUSH
98013: CALL_OW 12
98017: ST_TO_ADDR
// animal := CreateHuman ;
98018: LD_ADDR_VAR 0 12
98022: PUSH
98023: CALL_OW 44
98027: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98028: LD_VAR 0 12
98032: PPUSH
98033: LD_VAR 0 8
98037: PPUSH
98038: LD_INT 0
98040: PPUSH
98041: CALL 99888 0 3
// end ;
98045: GO 97982
98047: POP
98048: POP
// if apemans then
98049: LD_VAR 0 3
98053: IFFALSE 98176
// for i = 1 to apemans do
98055: LD_ADDR_VAR 0 11
98059: PUSH
98060: DOUBLE
98061: LD_INT 1
98063: DEC
98064: ST_TO_ADDR
98065: LD_VAR 0 3
98069: PUSH
98070: FOR_TO
98071: IFFALSE 98174
// begin hc_class = class_apeman ;
98073: LD_ADDR_OWVAR 28
98077: PUSH
98078: LD_INT 12
98080: ST_TO_ADDR
// hc_gallery =  ;
98081: LD_ADDR_OWVAR 33
98085: PUSH
98086: LD_STRING 
98088: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98089: LD_ADDR_OWVAR 35
98093: PUSH
98094: LD_INT 5
98096: NEG
98097: PPUSH
98098: LD_INT 5
98100: PPUSH
98101: CALL_OW 12
98105: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98106: LD_ADDR_OWVAR 31
98110: PUSH
98111: LD_INT 1
98113: PPUSH
98114: LD_INT 3
98116: PPUSH
98117: CALL_OW 12
98121: PUSH
98122: LD_INT 1
98124: PPUSH
98125: LD_INT 3
98127: PPUSH
98128: CALL_OW 12
98132: PUSH
98133: LD_INT 0
98135: PUSH
98136: LD_INT 0
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: ST_TO_ADDR
// animal := CreateHuman ;
98145: LD_ADDR_VAR 0 12
98149: PUSH
98150: CALL_OW 44
98154: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98155: LD_VAR 0 12
98159: PPUSH
98160: LD_VAR 0 8
98164: PPUSH
98165: LD_INT 0
98167: PPUSH
98168: CALL 99888 0 3
// end ;
98172: GO 98070
98174: POP
98175: POP
// if enchidnas then
98176: LD_VAR 0 4
98180: IFFALSE 98247
// for i = 1 to enchidnas do
98182: LD_ADDR_VAR 0 11
98186: PUSH
98187: DOUBLE
98188: LD_INT 1
98190: DEC
98191: ST_TO_ADDR
98192: LD_VAR 0 4
98196: PUSH
98197: FOR_TO
98198: IFFALSE 98245
// begin hc_class = 13 ;
98200: LD_ADDR_OWVAR 28
98204: PUSH
98205: LD_INT 13
98207: ST_TO_ADDR
// hc_gallery =  ;
98208: LD_ADDR_OWVAR 33
98212: PUSH
98213: LD_STRING 
98215: ST_TO_ADDR
// animal := CreateHuman ;
98216: LD_ADDR_VAR 0 12
98220: PUSH
98221: CALL_OW 44
98225: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98226: LD_VAR 0 12
98230: PPUSH
98231: LD_VAR 0 8
98235: PPUSH
98236: LD_INT 0
98238: PPUSH
98239: CALL 99888 0 3
// end ;
98243: GO 98197
98245: POP
98246: POP
// if fishes then
98247: LD_VAR 0 7
98251: IFFALSE 98318
// for i = 1 to fishes do
98253: LD_ADDR_VAR 0 11
98257: PUSH
98258: DOUBLE
98259: LD_INT 1
98261: DEC
98262: ST_TO_ADDR
98263: LD_VAR 0 7
98267: PUSH
98268: FOR_TO
98269: IFFALSE 98316
// begin hc_class = 20 ;
98271: LD_ADDR_OWVAR 28
98275: PUSH
98276: LD_INT 20
98278: ST_TO_ADDR
// hc_gallery =  ;
98279: LD_ADDR_OWVAR 33
98283: PUSH
98284: LD_STRING 
98286: ST_TO_ADDR
// animal := CreateHuman ;
98287: LD_ADDR_VAR 0 12
98291: PUSH
98292: CALL_OW 44
98296: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
98297: LD_VAR 0 12
98301: PPUSH
98302: LD_VAR 0 9
98306: PPUSH
98307: LD_INT 0
98309: PPUSH
98310: CALL 99888 0 3
// end ;
98314: GO 98268
98316: POP
98317: POP
// end ;
98318: LD_VAR 0 10
98322: RET
// export function WantHeal ( sci , unit ) ; begin
98323: LD_INT 0
98325: PPUSH
// if GetTaskList ( sci ) > 0 then
98326: LD_VAR 0 1
98330: PPUSH
98331: CALL_OW 437
98335: PUSH
98336: LD_INT 0
98338: GREATER
98339: IFFALSE 98409
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
98341: LD_VAR 0 1
98345: PPUSH
98346: CALL_OW 437
98350: PUSH
98351: LD_INT 1
98353: ARRAY
98354: PUSH
98355: LD_INT 1
98357: ARRAY
98358: PUSH
98359: LD_STRING l
98361: EQUAL
98362: PUSH
98363: LD_VAR 0 1
98367: PPUSH
98368: CALL_OW 437
98372: PUSH
98373: LD_INT 1
98375: ARRAY
98376: PUSH
98377: LD_INT 4
98379: ARRAY
98380: PUSH
98381: LD_VAR 0 2
98385: EQUAL
98386: AND
98387: IFFALSE 98399
// result := true else
98389: LD_ADDR_VAR 0 3
98393: PUSH
98394: LD_INT 1
98396: ST_TO_ADDR
98397: GO 98407
// result := false ;
98399: LD_ADDR_VAR 0 3
98403: PUSH
98404: LD_INT 0
98406: ST_TO_ADDR
// end else
98407: GO 98417
// result := false ;
98409: LD_ADDR_VAR 0 3
98413: PUSH
98414: LD_INT 0
98416: ST_TO_ADDR
// end ;
98417: LD_VAR 0 3
98421: RET
// export function HealTarget ( sci ) ; begin
98422: LD_INT 0
98424: PPUSH
// if not sci then
98425: LD_VAR 0 1
98429: NOT
98430: IFFALSE 98434
// exit ;
98432: GO 98499
// result := 0 ;
98434: LD_ADDR_VAR 0 2
98438: PUSH
98439: LD_INT 0
98441: ST_TO_ADDR
// if GetTaskList ( sci ) then
98442: LD_VAR 0 1
98446: PPUSH
98447: CALL_OW 437
98451: IFFALSE 98499
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98453: LD_VAR 0 1
98457: PPUSH
98458: CALL_OW 437
98462: PUSH
98463: LD_INT 1
98465: ARRAY
98466: PUSH
98467: LD_INT 1
98469: ARRAY
98470: PUSH
98471: LD_STRING l
98473: EQUAL
98474: IFFALSE 98499
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98476: LD_ADDR_VAR 0 2
98480: PUSH
98481: LD_VAR 0 1
98485: PPUSH
98486: CALL_OW 437
98490: PUSH
98491: LD_INT 1
98493: ARRAY
98494: PUSH
98495: LD_INT 4
98497: ARRAY
98498: ST_TO_ADDR
// end ;
98499: LD_VAR 0 2
98503: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
98504: LD_INT 0
98506: PPUSH
98507: PPUSH
98508: PPUSH
98509: PPUSH
// if not base_units then
98510: LD_VAR 0 1
98514: NOT
98515: IFFALSE 98519
// exit ;
98517: GO 98606
// result := false ;
98519: LD_ADDR_VAR 0 2
98523: PUSH
98524: LD_INT 0
98526: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
98527: LD_ADDR_VAR 0 5
98531: PUSH
98532: LD_VAR 0 1
98536: PPUSH
98537: LD_INT 21
98539: PUSH
98540: LD_INT 3
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: PPUSH
98547: CALL_OW 72
98551: ST_TO_ADDR
// if not tmp then
98552: LD_VAR 0 5
98556: NOT
98557: IFFALSE 98561
// exit ;
98559: GO 98606
// for i in tmp do
98561: LD_ADDR_VAR 0 3
98565: PUSH
98566: LD_VAR 0 5
98570: PUSH
98571: FOR_IN
98572: IFFALSE 98604
// begin result := EnemyInRange ( i , 22 ) ;
98574: LD_ADDR_VAR 0 2
98578: PUSH
98579: LD_VAR 0 3
98583: PPUSH
98584: LD_INT 22
98586: PPUSH
98587: CALL 96842 0 2
98591: ST_TO_ADDR
// if result then
98592: LD_VAR 0 2
98596: IFFALSE 98602
// exit ;
98598: POP
98599: POP
98600: GO 98606
// end ;
98602: GO 98571
98604: POP
98605: POP
// end ;
98606: LD_VAR 0 2
98610: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
98611: LD_INT 0
98613: PPUSH
98614: PPUSH
// if not units then
98615: LD_VAR 0 1
98619: NOT
98620: IFFALSE 98624
// exit ;
98622: GO 98694
// result := [ ] ;
98624: LD_ADDR_VAR 0 3
98628: PUSH
98629: EMPTY
98630: ST_TO_ADDR
// for i in units do
98631: LD_ADDR_VAR 0 4
98635: PUSH
98636: LD_VAR 0 1
98640: PUSH
98641: FOR_IN
98642: IFFALSE 98692
// if GetTag ( i ) = tag then
98644: LD_VAR 0 4
98648: PPUSH
98649: CALL_OW 110
98653: PUSH
98654: LD_VAR 0 2
98658: EQUAL
98659: IFFALSE 98690
// result := Insert ( result , result + 1 , i ) ;
98661: LD_ADDR_VAR 0 3
98665: PUSH
98666: LD_VAR 0 3
98670: PPUSH
98671: LD_VAR 0 3
98675: PUSH
98676: LD_INT 1
98678: PLUS
98679: PPUSH
98680: LD_VAR 0 4
98684: PPUSH
98685: CALL_OW 2
98689: ST_TO_ADDR
98690: GO 98641
98692: POP
98693: POP
// end ;
98694: LD_VAR 0 3
98698: RET
// export function IsDriver ( un ) ; begin
98699: LD_INT 0
98701: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
98702: LD_ADDR_VAR 0 2
98706: PUSH
98707: LD_VAR 0 1
98711: PUSH
98712: LD_INT 55
98714: PUSH
98715: EMPTY
98716: LIST
98717: PPUSH
98718: CALL_OW 69
98722: IN
98723: ST_TO_ADDR
// end ;
98724: LD_VAR 0 2
98728: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
98729: LD_INT 0
98731: PPUSH
98732: PPUSH
// list := [ ] ;
98733: LD_ADDR_VAR 0 5
98737: PUSH
98738: EMPTY
98739: ST_TO_ADDR
// case d of 0 :
98740: LD_VAR 0 3
98744: PUSH
98745: LD_INT 0
98747: DOUBLE
98748: EQUAL
98749: IFTRUE 98753
98751: GO 98886
98753: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
98754: LD_ADDR_VAR 0 5
98758: PUSH
98759: LD_VAR 0 1
98763: PUSH
98764: LD_INT 4
98766: MINUS
98767: PUSH
98768: LD_VAR 0 2
98772: PUSH
98773: LD_INT 4
98775: MINUS
98776: PUSH
98777: LD_INT 2
98779: PUSH
98780: EMPTY
98781: LIST
98782: LIST
98783: LIST
98784: PUSH
98785: LD_VAR 0 1
98789: PUSH
98790: LD_INT 3
98792: MINUS
98793: PUSH
98794: LD_VAR 0 2
98798: PUSH
98799: LD_INT 1
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: LIST
98806: PUSH
98807: LD_VAR 0 1
98811: PUSH
98812: LD_INT 4
98814: PLUS
98815: PUSH
98816: LD_VAR 0 2
98820: PUSH
98821: LD_INT 4
98823: PUSH
98824: EMPTY
98825: LIST
98826: LIST
98827: LIST
98828: PUSH
98829: LD_VAR 0 1
98833: PUSH
98834: LD_INT 3
98836: PLUS
98837: PUSH
98838: LD_VAR 0 2
98842: PUSH
98843: LD_INT 3
98845: PLUS
98846: PUSH
98847: LD_INT 5
98849: PUSH
98850: EMPTY
98851: LIST
98852: LIST
98853: LIST
98854: PUSH
98855: LD_VAR 0 1
98859: PUSH
98860: LD_VAR 0 2
98864: PUSH
98865: LD_INT 4
98867: PLUS
98868: PUSH
98869: LD_INT 0
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: LIST
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: ST_TO_ADDR
// end ; 1 :
98884: GO 99584
98886: LD_INT 1
98888: DOUBLE
98889: EQUAL
98890: IFTRUE 98894
98892: GO 99027
98894: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
98895: LD_ADDR_VAR 0 5
98899: PUSH
98900: LD_VAR 0 1
98904: PUSH
98905: LD_VAR 0 2
98909: PUSH
98910: LD_INT 4
98912: MINUS
98913: PUSH
98914: LD_INT 3
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: LIST
98921: PUSH
98922: LD_VAR 0 1
98926: PUSH
98927: LD_INT 3
98929: MINUS
98930: PUSH
98931: LD_VAR 0 2
98935: PUSH
98936: LD_INT 3
98938: MINUS
98939: PUSH
98940: LD_INT 2
98942: PUSH
98943: EMPTY
98944: LIST
98945: LIST
98946: LIST
98947: PUSH
98948: LD_VAR 0 1
98952: PUSH
98953: LD_INT 4
98955: MINUS
98956: PUSH
98957: LD_VAR 0 2
98961: PUSH
98962: LD_INT 1
98964: PUSH
98965: EMPTY
98966: LIST
98967: LIST
98968: LIST
98969: PUSH
98970: LD_VAR 0 1
98974: PUSH
98975: LD_VAR 0 2
98979: PUSH
98980: LD_INT 3
98982: PLUS
98983: PUSH
98984: LD_INT 0
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: LIST
98991: PUSH
98992: LD_VAR 0 1
98996: PUSH
98997: LD_INT 4
98999: PLUS
99000: PUSH
99001: LD_VAR 0 2
99005: PUSH
99006: LD_INT 4
99008: PLUS
99009: PUSH
99010: LD_INT 5
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: LIST
99017: PUSH
99018: EMPTY
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: ST_TO_ADDR
// end ; 2 :
99025: GO 99584
99027: LD_INT 2
99029: DOUBLE
99030: EQUAL
99031: IFTRUE 99035
99033: GO 99164
99035: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99036: LD_ADDR_VAR 0 5
99040: PUSH
99041: LD_VAR 0 1
99045: PUSH
99046: LD_VAR 0 2
99050: PUSH
99051: LD_INT 3
99053: MINUS
99054: PUSH
99055: LD_INT 3
99057: PUSH
99058: EMPTY
99059: LIST
99060: LIST
99061: LIST
99062: PUSH
99063: LD_VAR 0 1
99067: PUSH
99068: LD_INT 4
99070: PLUS
99071: PUSH
99072: LD_VAR 0 2
99076: PUSH
99077: LD_INT 4
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: LIST
99084: PUSH
99085: LD_VAR 0 1
99089: PUSH
99090: LD_VAR 0 2
99094: PUSH
99095: LD_INT 4
99097: PLUS
99098: PUSH
99099: LD_INT 0
99101: PUSH
99102: EMPTY
99103: LIST
99104: LIST
99105: LIST
99106: PUSH
99107: LD_VAR 0 1
99111: PUSH
99112: LD_INT 3
99114: MINUS
99115: PUSH
99116: LD_VAR 0 2
99120: PUSH
99121: LD_INT 1
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: LIST
99128: PUSH
99129: LD_VAR 0 1
99133: PUSH
99134: LD_INT 4
99136: MINUS
99137: PUSH
99138: LD_VAR 0 2
99142: PUSH
99143: LD_INT 4
99145: MINUS
99146: PUSH
99147: LD_INT 2
99149: PUSH
99150: EMPTY
99151: LIST
99152: LIST
99153: LIST
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: ST_TO_ADDR
// end ; 3 :
99162: GO 99584
99164: LD_INT 3
99166: DOUBLE
99167: EQUAL
99168: IFTRUE 99172
99170: GO 99305
99172: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99173: LD_ADDR_VAR 0 5
99177: PUSH
99178: LD_VAR 0 1
99182: PUSH
99183: LD_INT 3
99185: PLUS
99186: PUSH
99187: LD_VAR 0 2
99191: PUSH
99192: LD_INT 4
99194: PUSH
99195: EMPTY
99196: LIST
99197: LIST
99198: LIST
99199: PUSH
99200: LD_VAR 0 1
99204: PUSH
99205: LD_INT 4
99207: PLUS
99208: PUSH
99209: LD_VAR 0 2
99213: PUSH
99214: LD_INT 4
99216: PLUS
99217: PUSH
99218: LD_INT 5
99220: PUSH
99221: EMPTY
99222: LIST
99223: LIST
99224: LIST
99225: PUSH
99226: LD_VAR 0 1
99230: PUSH
99231: LD_INT 4
99233: MINUS
99234: PUSH
99235: LD_VAR 0 2
99239: PUSH
99240: LD_INT 1
99242: PUSH
99243: EMPTY
99244: LIST
99245: LIST
99246: LIST
99247: PUSH
99248: LD_VAR 0 1
99252: PUSH
99253: LD_VAR 0 2
99257: PUSH
99258: LD_INT 4
99260: MINUS
99261: PUSH
99262: LD_INT 3
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: LIST
99269: PUSH
99270: LD_VAR 0 1
99274: PUSH
99275: LD_INT 3
99277: MINUS
99278: PUSH
99279: LD_VAR 0 2
99283: PUSH
99284: LD_INT 3
99286: MINUS
99287: PUSH
99288: LD_INT 2
99290: PUSH
99291: EMPTY
99292: LIST
99293: LIST
99294: LIST
99295: PUSH
99296: EMPTY
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: ST_TO_ADDR
// end ; 4 :
99303: GO 99584
99305: LD_INT 4
99307: DOUBLE
99308: EQUAL
99309: IFTRUE 99313
99311: GO 99446
99313: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
99314: LD_ADDR_VAR 0 5
99318: PUSH
99319: LD_VAR 0 1
99323: PUSH
99324: LD_VAR 0 2
99328: PUSH
99329: LD_INT 4
99331: PLUS
99332: PUSH
99333: LD_INT 0
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: LIST
99340: PUSH
99341: LD_VAR 0 1
99345: PUSH
99346: LD_INT 3
99348: PLUS
99349: PUSH
99350: LD_VAR 0 2
99354: PUSH
99355: LD_INT 3
99357: PLUS
99358: PUSH
99359: LD_INT 5
99361: PUSH
99362: EMPTY
99363: LIST
99364: LIST
99365: LIST
99366: PUSH
99367: LD_VAR 0 1
99371: PUSH
99372: LD_INT 4
99374: PLUS
99375: PUSH
99376: LD_VAR 0 2
99380: PUSH
99381: LD_INT 4
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: LIST
99388: PUSH
99389: LD_VAR 0 1
99393: PUSH
99394: LD_VAR 0 2
99398: PUSH
99399: LD_INT 3
99401: MINUS
99402: PUSH
99403: LD_INT 3
99405: PUSH
99406: EMPTY
99407: LIST
99408: LIST
99409: LIST
99410: PUSH
99411: LD_VAR 0 1
99415: PUSH
99416: LD_INT 4
99418: MINUS
99419: PUSH
99420: LD_VAR 0 2
99424: PUSH
99425: LD_INT 4
99427: MINUS
99428: PUSH
99429: LD_INT 2
99431: PUSH
99432: EMPTY
99433: LIST
99434: LIST
99435: LIST
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: LIST
99441: LIST
99442: LIST
99443: ST_TO_ADDR
// end ; 5 :
99444: GO 99584
99446: LD_INT 5
99448: DOUBLE
99449: EQUAL
99450: IFTRUE 99454
99452: GO 99583
99454: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
99455: LD_ADDR_VAR 0 5
99459: PUSH
99460: LD_VAR 0 1
99464: PUSH
99465: LD_INT 4
99467: MINUS
99468: PUSH
99469: LD_VAR 0 2
99473: PUSH
99474: LD_INT 1
99476: PUSH
99477: EMPTY
99478: LIST
99479: LIST
99480: LIST
99481: PUSH
99482: LD_VAR 0 1
99486: PUSH
99487: LD_VAR 0 2
99491: PUSH
99492: LD_INT 4
99494: MINUS
99495: PUSH
99496: LD_INT 3
99498: PUSH
99499: EMPTY
99500: LIST
99501: LIST
99502: LIST
99503: PUSH
99504: LD_VAR 0 1
99508: PUSH
99509: LD_INT 4
99511: PLUS
99512: PUSH
99513: LD_VAR 0 2
99517: PUSH
99518: LD_INT 4
99520: PLUS
99521: PUSH
99522: LD_INT 5
99524: PUSH
99525: EMPTY
99526: LIST
99527: LIST
99528: LIST
99529: PUSH
99530: LD_VAR 0 1
99534: PUSH
99535: LD_INT 3
99537: PLUS
99538: PUSH
99539: LD_VAR 0 2
99543: PUSH
99544: LD_INT 4
99546: PUSH
99547: EMPTY
99548: LIST
99549: LIST
99550: LIST
99551: PUSH
99552: LD_VAR 0 1
99556: PUSH
99557: LD_VAR 0 2
99561: PUSH
99562: LD_INT 3
99564: PLUS
99565: PUSH
99566: LD_INT 0
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: LIST
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: ST_TO_ADDR
// end ; end ;
99581: GO 99584
99583: POP
// result := list ;
99584: LD_ADDR_VAR 0 4
99588: PUSH
99589: LD_VAR 0 5
99593: ST_TO_ADDR
// end ;
99594: LD_VAR 0 4
99598: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
99599: LD_INT 0
99601: PPUSH
99602: PPUSH
99603: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
99604: LD_VAR 0 1
99608: NOT
99609: PUSH
99610: LD_VAR 0 2
99614: PUSH
99615: LD_INT 1
99617: PUSH
99618: LD_INT 2
99620: PUSH
99621: LD_INT 3
99623: PUSH
99624: LD_INT 4
99626: PUSH
99627: EMPTY
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: IN
99633: NOT
99634: OR
99635: IFFALSE 99639
// exit ;
99637: GO 99731
// tmp := [ ] ;
99639: LD_ADDR_VAR 0 5
99643: PUSH
99644: EMPTY
99645: ST_TO_ADDR
// for i in units do
99646: LD_ADDR_VAR 0 4
99650: PUSH
99651: LD_VAR 0 1
99655: PUSH
99656: FOR_IN
99657: IFFALSE 99700
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
99659: LD_ADDR_VAR 0 5
99663: PUSH
99664: LD_VAR 0 5
99668: PPUSH
99669: LD_VAR 0 5
99673: PUSH
99674: LD_INT 1
99676: PLUS
99677: PPUSH
99678: LD_VAR 0 4
99682: PPUSH
99683: LD_VAR 0 2
99687: PPUSH
99688: CALL_OW 259
99692: PPUSH
99693: CALL_OW 2
99697: ST_TO_ADDR
99698: GO 99656
99700: POP
99701: POP
// if not tmp then
99702: LD_VAR 0 5
99706: NOT
99707: IFFALSE 99711
// exit ;
99709: GO 99731
// result := SortListByListDesc ( units , tmp ) ;
99711: LD_ADDR_VAR 0 3
99715: PUSH
99716: LD_VAR 0 1
99720: PPUSH
99721: LD_VAR 0 5
99725: PPUSH
99726: CALL_OW 77
99730: ST_TO_ADDR
// end ;
99731: LD_VAR 0 3
99735: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
99736: LD_INT 0
99738: PPUSH
99739: PPUSH
99740: PPUSH
// x := GetX ( building ) ;
99741: LD_ADDR_VAR 0 4
99745: PUSH
99746: LD_VAR 0 2
99750: PPUSH
99751: CALL_OW 250
99755: ST_TO_ADDR
// y := GetY ( building ) ;
99756: LD_ADDR_VAR 0 5
99760: PUSH
99761: LD_VAR 0 2
99765: PPUSH
99766: CALL_OW 251
99770: ST_TO_ADDR
// if GetTaskList ( unit ) then
99771: LD_VAR 0 1
99775: PPUSH
99776: CALL_OW 437
99780: IFFALSE 99875
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
99782: LD_STRING e
99784: PUSH
99785: LD_VAR 0 1
99789: PPUSH
99790: CALL_OW 437
99794: PUSH
99795: LD_INT 1
99797: ARRAY
99798: PUSH
99799: LD_INT 1
99801: ARRAY
99802: EQUAL
99803: PUSH
99804: LD_VAR 0 4
99808: PUSH
99809: LD_VAR 0 1
99813: PPUSH
99814: CALL_OW 437
99818: PUSH
99819: LD_INT 1
99821: ARRAY
99822: PUSH
99823: LD_INT 2
99825: ARRAY
99826: EQUAL
99827: AND
99828: PUSH
99829: LD_VAR 0 5
99833: PUSH
99834: LD_VAR 0 1
99838: PPUSH
99839: CALL_OW 437
99843: PUSH
99844: LD_INT 1
99846: ARRAY
99847: PUSH
99848: LD_INT 3
99850: ARRAY
99851: EQUAL
99852: AND
99853: IFFALSE 99865
// result := true else
99855: LD_ADDR_VAR 0 3
99859: PUSH
99860: LD_INT 1
99862: ST_TO_ADDR
99863: GO 99873
// result := false ;
99865: LD_ADDR_VAR 0 3
99869: PUSH
99870: LD_INT 0
99872: ST_TO_ADDR
// end else
99873: GO 99883
// result := false ;
99875: LD_ADDR_VAR 0 3
99879: PUSH
99880: LD_INT 0
99882: ST_TO_ADDR
// end ;
99883: LD_VAR 0 3
99887: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
99888: LD_INT 0
99890: PPUSH
99891: PPUSH
99892: PPUSH
99893: PPUSH
// if not unit or not area then
99894: LD_VAR 0 1
99898: NOT
99899: PUSH
99900: LD_VAR 0 2
99904: NOT
99905: OR
99906: IFFALSE 99910
// exit ;
99908: GO 100074
// tmp := AreaToList ( area , i ) ;
99910: LD_ADDR_VAR 0 6
99914: PUSH
99915: LD_VAR 0 2
99919: PPUSH
99920: LD_VAR 0 5
99924: PPUSH
99925: CALL_OW 517
99929: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
99930: LD_ADDR_VAR 0 5
99934: PUSH
99935: DOUBLE
99936: LD_INT 1
99938: DEC
99939: ST_TO_ADDR
99940: LD_VAR 0 6
99944: PUSH
99945: LD_INT 1
99947: ARRAY
99948: PUSH
99949: FOR_TO
99950: IFFALSE 100072
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
99952: LD_ADDR_VAR 0 7
99956: PUSH
99957: LD_VAR 0 6
99961: PUSH
99962: LD_INT 1
99964: ARRAY
99965: PUSH
99966: LD_VAR 0 5
99970: ARRAY
99971: PUSH
99972: LD_VAR 0 6
99976: PUSH
99977: LD_INT 2
99979: ARRAY
99980: PUSH
99981: LD_VAR 0 5
99985: ARRAY
99986: PUSH
99987: EMPTY
99988: LIST
99989: LIST
99990: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
99991: LD_VAR 0 7
99995: PUSH
99996: LD_INT 1
99998: ARRAY
99999: PPUSH
100000: LD_VAR 0 7
100004: PUSH
100005: LD_INT 2
100007: ARRAY
100008: PPUSH
100009: CALL_OW 428
100013: PUSH
100014: LD_INT 0
100016: EQUAL
100017: IFFALSE 100070
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100019: LD_VAR 0 1
100023: PPUSH
100024: LD_VAR 0 7
100028: PUSH
100029: LD_INT 1
100031: ARRAY
100032: PPUSH
100033: LD_VAR 0 7
100037: PUSH
100038: LD_INT 2
100040: ARRAY
100041: PPUSH
100042: LD_VAR 0 3
100046: PPUSH
100047: CALL_OW 48
// result := IsPlaced ( unit ) ;
100051: LD_ADDR_VAR 0 4
100055: PUSH
100056: LD_VAR 0 1
100060: PPUSH
100061: CALL_OW 305
100065: ST_TO_ADDR
// exit ;
100066: POP
100067: POP
100068: GO 100074
// end ; end ;
100070: GO 99949
100072: POP
100073: POP
// end ;
100074: LD_VAR 0 4
100078: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100079: LD_INT 0
100081: PPUSH
100082: PPUSH
100083: PPUSH
// if not side or side > 8 then
100084: LD_VAR 0 1
100088: NOT
100089: PUSH
100090: LD_VAR 0 1
100094: PUSH
100095: LD_INT 8
100097: GREATER
100098: OR
100099: IFFALSE 100103
// exit ;
100101: GO 100290
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100103: LD_ADDR_VAR 0 4
100107: PUSH
100108: LD_INT 22
100110: PUSH
100111: LD_VAR 0 1
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: PUSH
100120: LD_INT 21
100122: PUSH
100123: LD_INT 3
100125: PUSH
100126: EMPTY
100127: LIST
100128: LIST
100129: PUSH
100130: EMPTY
100131: LIST
100132: LIST
100133: PPUSH
100134: CALL_OW 69
100138: ST_TO_ADDR
// if not tmp then
100139: LD_VAR 0 4
100143: NOT
100144: IFFALSE 100148
// exit ;
100146: GO 100290
// enable_addtolog := true ;
100148: LD_ADDR_OWVAR 81
100152: PUSH
100153: LD_INT 1
100155: ST_TO_ADDR
// AddToLog ( [ ) ;
100156: LD_STRING [
100158: PPUSH
100159: CALL_OW 561
// for i in tmp do
100163: LD_ADDR_VAR 0 3
100167: PUSH
100168: LD_VAR 0 4
100172: PUSH
100173: FOR_IN
100174: IFFALSE 100281
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100176: LD_STRING [
100178: PUSH
100179: LD_VAR 0 3
100183: PPUSH
100184: CALL_OW 266
100188: STR
100189: PUSH
100190: LD_STRING , 
100192: STR
100193: PUSH
100194: LD_VAR 0 3
100198: PPUSH
100199: CALL_OW 250
100203: STR
100204: PUSH
100205: LD_STRING , 
100207: STR
100208: PUSH
100209: LD_VAR 0 3
100213: PPUSH
100214: CALL_OW 251
100218: STR
100219: PUSH
100220: LD_STRING , 
100222: STR
100223: PUSH
100224: LD_VAR 0 3
100228: PPUSH
100229: CALL_OW 254
100233: STR
100234: PUSH
100235: LD_STRING , 
100237: STR
100238: PUSH
100239: LD_VAR 0 3
100243: PPUSH
100244: LD_INT 1
100246: PPUSH
100247: CALL_OW 268
100251: STR
100252: PUSH
100253: LD_STRING , 
100255: STR
100256: PUSH
100257: LD_VAR 0 3
100261: PPUSH
100262: LD_INT 2
100264: PPUSH
100265: CALL_OW 268
100269: STR
100270: PUSH
100271: LD_STRING ],
100273: STR
100274: PPUSH
100275: CALL_OW 561
// end ;
100279: GO 100173
100281: POP
100282: POP
// AddToLog ( ]; ) ;
100283: LD_STRING ];
100285: PPUSH
100286: CALL_OW 561
// end ;
100290: LD_VAR 0 2
100294: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
100295: LD_INT 0
100297: PPUSH
100298: PPUSH
100299: PPUSH
100300: PPUSH
100301: PPUSH
// if not area or not rate or not max then
100302: LD_VAR 0 1
100306: NOT
100307: PUSH
100308: LD_VAR 0 2
100312: NOT
100313: OR
100314: PUSH
100315: LD_VAR 0 4
100319: NOT
100320: OR
100321: IFFALSE 100325
// exit ;
100323: GO 100517
// while 1 do
100325: LD_INT 1
100327: IFFALSE 100517
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
100329: LD_ADDR_VAR 0 9
100333: PUSH
100334: LD_VAR 0 1
100338: PPUSH
100339: LD_INT 1
100341: PPUSH
100342: CALL_OW 287
100346: PUSH
100347: LD_INT 10
100349: MUL
100350: ST_TO_ADDR
// r := rate / 10 ;
100351: LD_ADDR_VAR 0 7
100355: PUSH
100356: LD_VAR 0 2
100360: PUSH
100361: LD_INT 10
100363: DIVREAL
100364: ST_TO_ADDR
// time := 1 1$00 ;
100365: LD_ADDR_VAR 0 8
100369: PUSH
100370: LD_INT 2100
100372: ST_TO_ADDR
// if amount < min then
100373: LD_VAR 0 9
100377: PUSH
100378: LD_VAR 0 3
100382: LESS
100383: IFFALSE 100401
// r := r * 2 else
100385: LD_ADDR_VAR 0 7
100389: PUSH
100390: LD_VAR 0 7
100394: PUSH
100395: LD_INT 2
100397: MUL
100398: ST_TO_ADDR
100399: GO 100427
// if amount > max then
100401: LD_VAR 0 9
100405: PUSH
100406: LD_VAR 0 4
100410: GREATER
100411: IFFALSE 100427
// r := r / 2 ;
100413: LD_ADDR_VAR 0 7
100417: PUSH
100418: LD_VAR 0 7
100422: PUSH
100423: LD_INT 2
100425: DIVREAL
100426: ST_TO_ADDR
// time := time / r ;
100427: LD_ADDR_VAR 0 8
100431: PUSH
100432: LD_VAR 0 8
100436: PUSH
100437: LD_VAR 0 7
100441: DIVREAL
100442: ST_TO_ADDR
// if time < 0 then
100443: LD_VAR 0 8
100447: PUSH
100448: LD_INT 0
100450: LESS
100451: IFFALSE 100468
// time := time * - 1 ;
100453: LD_ADDR_VAR 0 8
100457: PUSH
100458: LD_VAR 0 8
100462: PUSH
100463: LD_INT 1
100465: NEG
100466: MUL
100467: ST_TO_ADDR
// wait ( time ) ;
100468: LD_VAR 0 8
100472: PPUSH
100473: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
100477: LD_INT 35
100479: PPUSH
100480: LD_INT 875
100482: PPUSH
100483: CALL_OW 12
100487: PPUSH
100488: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
100492: LD_INT 1
100494: PPUSH
100495: LD_INT 5
100497: PPUSH
100498: CALL_OW 12
100502: PPUSH
100503: LD_VAR 0 1
100507: PPUSH
100508: LD_INT 1
100510: PPUSH
100511: CALL_OW 55
// end ;
100515: GO 100325
// end ;
100517: LD_VAR 0 5
100521: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
100522: LD_INT 0
100524: PPUSH
100525: PPUSH
100526: PPUSH
100527: PPUSH
100528: PPUSH
100529: PPUSH
100530: PPUSH
100531: PPUSH
// if not turrets or not factories then
100532: LD_VAR 0 1
100536: NOT
100537: PUSH
100538: LD_VAR 0 2
100542: NOT
100543: OR
100544: IFFALSE 100548
// exit ;
100546: GO 100855
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
100548: LD_ADDR_VAR 0 10
100552: PUSH
100553: LD_INT 5
100555: PUSH
100556: LD_INT 6
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: LD_INT 2
100565: PUSH
100566: LD_INT 4
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PUSH
100573: LD_INT 3
100575: PUSH
100576: LD_INT 5
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PUSH
100583: EMPTY
100584: LIST
100585: LIST
100586: LIST
100587: PUSH
100588: LD_INT 24
100590: PUSH
100591: LD_INT 25
100593: PUSH
100594: EMPTY
100595: LIST
100596: LIST
100597: PUSH
100598: LD_INT 23
100600: PUSH
100601: LD_INT 27
100603: PUSH
100604: EMPTY
100605: LIST
100606: LIST
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_INT 42
100614: PUSH
100615: LD_INT 43
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: LD_INT 44
100624: PUSH
100625: LD_INT 46
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: PUSH
100632: LD_INT 45
100634: PUSH
100635: LD_INT 47
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PUSH
100642: EMPTY
100643: LIST
100644: LIST
100645: LIST
100646: PUSH
100647: EMPTY
100648: LIST
100649: LIST
100650: LIST
100651: ST_TO_ADDR
// result := [ ] ;
100652: LD_ADDR_VAR 0 3
100656: PUSH
100657: EMPTY
100658: ST_TO_ADDR
// for i in turrets do
100659: LD_ADDR_VAR 0 4
100663: PUSH
100664: LD_VAR 0 1
100668: PUSH
100669: FOR_IN
100670: IFFALSE 100853
// begin nat := GetNation ( i ) ;
100672: LD_ADDR_VAR 0 7
100676: PUSH
100677: LD_VAR 0 4
100681: PPUSH
100682: CALL_OW 248
100686: ST_TO_ADDR
// weapon := 0 ;
100687: LD_ADDR_VAR 0 8
100691: PUSH
100692: LD_INT 0
100694: ST_TO_ADDR
// if not nat then
100695: LD_VAR 0 7
100699: NOT
100700: IFFALSE 100704
// continue ;
100702: GO 100669
// for j in list [ nat ] do
100704: LD_ADDR_VAR 0 5
100708: PUSH
100709: LD_VAR 0 10
100713: PUSH
100714: LD_VAR 0 7
100718: ARRAY
100719: PUSH
100720: FOR_IN
100721: IFFALSE 100762
// if GetBWeapon ( i ) = j [ 1 ] then
100723: LD_VAR 0 4
100727: PPUSH
100728: CALL_OW 269
100732: PUSH
100733: LD_VAR 0 5
100737: PUSH
100738: LD_INT 1
100740: ARRAY
100741: EQUAL
100742: IFFALSE 100760
// begin weapon := j [ 2 ] ;
100744: LD_ADDR_VAR 0 8
100748: PUSH
100749: LD_VAR 0 5
100753: PUSH
100754: LD_INT 2
100756: ARRAY
100757: ST_TO_ADDR
// break ;
100758: GO 100762
// end ;
100760: GO 100720
100762: POP
100763: POP
// if not weapon then
100764: LD_VAR 0 8
100768: NOT
100769: IFFALSE 100773
// continue ;
100771: GO 100669
// for k in factories do
100773: LD_ADDR_VAR 0 6
100777: PUSH
100778: LD_VAR 0 2
100782: PUSH
100783: FOR_IN
100784: IFFALSE 100849
// begin weapons := AvailableWeaponList ( k ) ;
100786: LD_ADDR_VAR 0 9
100790: PUSH
100791: LD_VAR 0 6
100795: PPUSH
100796: CALL_OW 478
100800: ST_TO_ADDR
// if not weapons then
100801: LD_VAR 0 9
100805: NOT
100806: IFFALSE 100810
// continue ;
100808: GO 100783
// if weapon in weapons then
100810: LD_VAR 0 8
100814: PUSH
100815: LD_VAR 0 9
100819: IN
100820: IFFALSE 100847
// begin result := [ i , weapon ] ;
100822: LD_ADDR_VAR 0 3
100826: PUSH
100827: LD_VAR 0 4
100831: PUSH
100832: LD_VAR 0 8
100836: PUSH
100837: EMPTY
100838: LIST
100839: LIST
100840: ST_TO_ADDR
// exit ;
100841: POP
100842: POP
100843: POP
100844: POP
100845: GO 100855
// end ; end ;
100847: GO 100783
100849: POP
100850: POP
// end ;
100851: GO 100669
100853: POP
100854: POP
// end ;
100855: LD_VAR 0 3
100859: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
100860: LD_INT 0
100862: PPUSH
// if not side or side > 8 then
100863: LD_VAR 0 3
100867: NOT
100868: PUSH
100869: LD_VAR 0 3
100873: PUSH
100874: LD_INT 8
100876: GREATER
100877: OR
100878: IFFALSE 100882
// exit ;
100880: GO 100941
// if not range then
100882: LD_VAR 0 4
100886: NOT
100887: IFFALSE 100898
// range := - 12 ;
100889: LD_ADDR_VAR 0 4
100893: PUSH
100894: LD_INT 12
100896: NEG
100897: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
100898: LD_VAR 0 1
100902: PPUSH
100903: LD_VAR 0 2
100907: PPUSH
100908: LD_VAR 0 3
100912: PPUSH
100913: LD_VAR 0 4
100917: PPUSH
100918: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
100922: LD_VAR 0 1
100926: PPUSH
100927: LD_VAR 0 2
100931: PPUSH
100932: LD_VAR 0 3
100936: PPUSH
100937: CALL_OW 331
// end ;
100941: LD_VAR 0 5
100945: RET
// export function Video ( mode ) ; begin
100946: LD_INT 0
100948: PPUSH
// ingame_video = mode ;
100949: LD_ADDR_OWVAR 52
100953: PUSH
100954: LD_VAR 0 1
100958: ST_TO_ADDR
// interface_hidden = mode ;
100959: LD_ADDR_OWVAR 54
100963: PUSH
100964: LD_VAR 0 1
100968: ST_TO_ADDR
// end ;
100969: LD_VAR 0 2
100973: RET
// export function Join ( array , element ) ; begin
100974: LD_INT 0
100976: PPUSH
// result := Replace ( array , array + 1 , element ) ;
100977: LD_ADDR_VAR 0 3
100981: PUSH
100982: LD_VAR 0 1
100986: PPUSH
100987: LD_VAR 0 1
100991: PUSH
100992: LD_INT 1
100994: PLUS
100995: PPUSH
100996: LD_VAR 0 2
101000: PPUSH
101001: CALL_OW 1
101005: ST_TO_ADDR
// end ;
101006: LD_VAR 0 3
101010: RET
// export function JoinUnion ( array , element ) ; begin
101011: LD_INT 0
101013: PPUSH
// result := array union element ;
101014: LD_ADDR_VAR 0 3
101018: PUSH
101019: LD_VAR 0 1
101023: PUSH
101024: LD_VAR 0 2
101028: UNION
101029: ST_TO_ADDR
// end ;
101030: LD_VAR 0 3
101034: RET
// export function GetBehemoths ( side ) ; begin
101035: LD_INT 0
101037: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101038: LD_ADDR_VAR 0 2
101042: PUSH
101043: LD_INT 22
101045: PUSH
101046: LD_VAR 0 1
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: PUSH
101055: LD_INT 31
101057: PUSH
101058: LD_INT 25
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: PUSH
101065: EMPTY
101066: LIST
101067: LIST
101068: PPUSH
101069: CALL_OW 69
101073: ST_TO_ADDR
// end ;
101074: LD_VAR 0 2
101078: RET
// export function Shuffle ( array ) ; var i , index ; begin
101079: LD_INT 0
101081: PPUSH
101082: PPUSH
101083: PPUSH
// result := [ ] ;
101084: LD_ADDR_VAR 0 2
101088: PUSH
101089: EMPTY
101090: ST_TO_ADDR
// if not array then
101091: LD_VAR 0 1
101095: NOT
101096: IFFALSE 101100
// exit ;
101098: GO 101199
// Randomize ;
101100: CALL_OW 10
// for i = array downto 1 do
101104: LD_ADDR_VAR 0 3
101108: PUSH
101109: DOUBLE
101110: LD_VAR 0 1
101114: INC
101115: ST_TO_ADDR
101116: LD_INT 1
101118: PUSH
101119: FOR_DOWNTO
101120: IFFALSE 101197
// begin index := rand ( 1 , array ) ;
101122: LD_ADDR_VAR 0 4
101126: PUSH
101127: LD_INT 1
101129: PPUSH
101130: LD_VAR 0 1
101134: PPUSH
101135: CALL_OW 12
101139: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101140: LD_ADDR_VAR 0 2
101144: PUSH
101145: LD_VAR 0 2
101149: PPUSH
101150: LD_VAR 0 2
101154: PUSH
101155: LD_INT 1
101157: PLUS
101158: PPUSH
101159: LD_VAR 0 1
101163: PUSH
101164: LD_VAR 0 4
101168: ARRAY
101169: PPUSH
101170: CALL_OW 2
101174: ST_TO_ADDR
// array := Delete ( array , index ) ;
101175: LD_ADDR_VAR 0 1
101179: PUSH
101180: LD_VAR 0 1
101184: PPUSH
101185: LD_VAR 0 4
101189: PPUSH
101190: CALL_OW 3
101194: ST_TO_ADDR
// end ;
101195: GO 101119
101197: POP
101198: POP
// end ;
101199: LD_VAR 0 2
101203: RET
// export function GetBaseMaterials ( base ) ; begin
101204: LD_INT 0
101206: PPUSH
// result := [ 0 , 0 , 0 ] ;
101207: LD_ADDR_VAR 0 2
101211: PUSH
101212: LD_INT 0
101214: PUSH
101215: LD_INT 0
101217: PUSH
101218: LD_INT 0
101220: PUSH
101221: EMPTY
101222: LIST
101223: LIST
101224: LIST
101225: ST_TO_ADDR
// if not base then
101226: LD_VAR 0 1
101230: NOT
101231: IFFALSE 101235
// exit ;
101233: GO 101284
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
101235: LD_ADDR_VAR 0 2
101239: PUSH
101240: LD_VAR 0 1
101244: PPUSH
101245: LD_INT 1
101247: PPUSH
101248: CALL_OW 275
101252: PUSH
101253: LD_VAR 0 1
101257: PPUSH
101258: LD_INT 2
101260: PPUSH
101261: CALL_OW 275
101265: PUSH
101266: LD_VAR 0 1
101270: PPUSH
101271: LD_INT 3
101273: PPUSH
101274: CALL_OW 275
101278: PUSH
101279: EMPTY
101280: LIST
101281: LIST
101282: LIST
101283: ST_TO_ADDR
// end ;
101284: LD_VAR 0 2
101288: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
101289: LD_INT 0
101291: PPUSH
101292: PPUSH
// result := array ;
101293: LD_ADDR_VAR 0 3
101297: PUSH
101298: LD_VAR 0 1
101302: ST_TO_ADDR
// if size > 0 then
101303: LD_VAR 0 2
101307: PUSH
101308: LD_INT 0
101310: GREATER
101311: IFFALSE 101357
// for i := array downto size do
101313: LD_ADDR_VAR 0 4
101317: PUSH
101318: DOUBLE
101319: LD_VAR 0 1
101323: INC
101324: ST_TO_ADDR
101325: LD_VAR 0 2
101329: PUSH
101330: FOR_DOWNTO
101331: IFFALSE 101355
// result := Delete ( result , result ) ;
101333: LD_ADDR_VAR 0 3
101337: PUSH
101338: LD_VAR 0 3
101342: PPUSH
101343: LD_VAR 0 3
101347: PPUSH
101348: CALL_OW 3
101352: ST_TO_ADDR
101353: GO 101330
101355: POP
101356: POP
// end ;
101357: LD_VAR 0 3
101361: RET
// export function ComExit ( unit ) ; var tmp ; begin
101362: LD_INT 0
101364: PPUSH
101365: PPUSH
// if not IsInUnit ( unit ) then
101366: LD_VAR 0 1
101370: PPUSH
101371: CALL_OW 310
101375: NOT
101376: IFFALSE 101380
// exit ;
101378: GO 101440
// tmp := IsInUnit ( unit ) ;
101380: LD_ADDR_VAR 0 3
101384: PUSH
101385: LD_VAR 0 1
101389: PPUSH
101390: CALL_OW 310
101394: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
101395: LD_VAR 0 3
101399: PPUSH
101400: CALL_OW 247
101404: PUSH
101405: LD_INT 2
101407: EQUAL
101408: IFFALSE 101421
// ComExitVehicle ( unit ) else
101410: LD_VAR 0 1
101414: PPUSH
101415: CALL_OW 121
101419: GO 101430
// ComExitBuilding ( unit ) ;
101421: LD_VAR 0 1
101425: PPUSH
101426: CALL_OW 122
// result := tmp ;
101430: LD_ADDR_VAR 0 2
101434: PUSH
101435: LD_VAR 0 3
101439: ST_TO_ADDR
// end ;
101440: LD_VAR 0 2
101444: RET
// export function ResetHc ; begin
101445: LD_INT 0
101447: PPUSH
// InitHc ;
101448: CALL_OW 19
// hc_importance := 0 ;
101452: LD_ADDR_OWVAR 32
101456: PUSH
101457: LD_INT 0
101459: ST_TO_ADDR
// end ; end_of_file end_of_file
101460: LD_VAR 0 1
101464: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
101465: LD_VAR 0 2
101469: PUSH
101470: LD_INT 100
101472: EQUAL
101473: IFFALSE 102422
// begin if not StreamModeActive then
101475: LD_EXP 155
101479: NOT
101480: IFFALSE 101490
// StreamModeActive := true ;
101482: LD_ADDR_EXP 155
101486: PUSH
101487: LD_INT 1
101489: ST_TO_ADDR
// if p3 = 0 then
101490: LD_VAR 0 3
101494: PUSH
101495: LD_INT 0
101497: EQUAL
101498: IFFALSE 101504
// InitStreamMode ;
101500: CALL 102580 0 0
// if p3 = 1 then
101504: LD_VAR 0 3
101508: PUSH
101509: LD_INT 1
101511: EQUAL
101512: IFFALSE 101522
// sRocket := true ;
101514: LD_ADDR_EXP 160
101518: PUSH
101519: LD_INT 1
101521: ST_TO_ADDR
// if p3 = 2 then
101522: LD_VAR 0 3
101526: PUSH
101527: LD_INT 2
101529: EQUAL
101530: IFFALSE 101540
// sSpeed := true ;
101532: LD_ADDR_EXP 159
101536: PUSH
101537: LD_INT 1
101539: ST_TO_ADDR
// if p3 = 3 then
101540: LD_VAR 0 3
101544: PUSH
101545: LD_INT 3
101547: EQUAL
101548: IFFALSE 101558
// sEngine := true ;
101550: LD_ADDR_EXP 161
101554: PUSH
101555: LD_INT 1
101557: ST_TO_ADDR
// if p3 = 4 then
101558: LD_VAR 0 3
101562: PUSH
101563: LD_INT 4
101565: EQUAL
101566: IFFALSE 101576
// sSpec := true ;
101568: LD_ADDR_EXP 158
101572: PUSH
101573: LD_INT 1
101575: ST_TO_ADDR
// if p3 = 5 then
101576: LD_VAR 0 3
101580: PUSH
101581: LD_INT 5
101583: EQUAL
101584: IFFALSE 101594
// sLevel := true ;
101586: LD_ADDR_EXP 162
101590: PUSH
101591: LD_INT 1
101593: ST_TO_ADDR
// if p3 = 6 then
101594: LD_VAR 0 3
101598: PUSH
101599: LD_INT 6
101601: EQUAL
101602: IFFALSE 101612
// sArmoury := true ;
101604: LD_ADDR_EXP 163
101608: PUSH
101609: LD_INT 1
101611: ST_TO_ADDR
// if p3 = 7 then
101612: LD_VAR 0 3
101616: PUSH
101617: LD_INT 7
101619: EQUAL
101620: IFFALSE 101630
// sRadar := true ;
101622: LD_ADDR_EXP 164
101626: PUSH
101627: LD_INT 1
101629: ST_TO_ADDR
// if p3 = 8 then
101630: LD_VAR 0 3
101634: PUSH
101635: LD_INT 8
101637: EQUAL
101638: IFFALSE 101648
// sBunker := true ;
101640: LD_ADDR_EXP 165
101644: PUSH
101645: LD_INT 1
101647: ST_TO_ADDR
// if p3 = 9 then
101648: LD_VAR 0 3
101652: PUSH
101653: LD_INT 9
101655: EQUAL
101656: IFFALSE 101666
// sHack := true ;
101658: LD_ADDR_EXP 166
101662: PUSH
101663: LD_INT 1
101665: ST_TO_ADDR
// if p3 = 10 then
101666: LD_VAR 0 3
101670: PUSH
101671: LD_INT 10
101673: EQUAL
101674: IFFALSE 101684
// sFire := true ;
101676: LD_ADDR_EXP 167
101680: PUSH
101681: LD_INT 1
101683: ST_TO_ADDR
// if p3 = 11 then
101684: LD_VAR 0 3
101688: PUSH
101689: LD_INT 11
101691: EQUAL
101692: IFFALSE 101702
// sRefresh := true ;
101694: LD_ADDR_EXP 168
101698: PUSH
101699: LD_INT 1
101701: ST_TO_ADDR
// if p3 = 12 then
101702: LD_VAR 0 3
101706: PUSH
101707: LD_INT 12
101709: EQUAL
101710: IFFALSE 101720
// sExp := true ;
101712: LD_ADDR_EXP 169
101716: PUSH
101717: LD_INT 1
101719: ST_TO_ADDR
// if p3 = 13 then
101720: LD_VAR 0 3
101724: PUSH
101725: LD_INT 13
101727: EQUAL
101728: IFFALSE 101738
// sDepot := true ;
101730: LD_ADDR_EXP 170
101734: PUSH
101735: LD_INT 1
101737: ST_TO_ADDR
// if p3 = 14 then
101738: LD_VAR 0 3
101742: PUSH
101743: LD_INT 14
101745: EQUAL
101746: IFFALSE 101756
// sFlag := true ;
101748: LD_ADDR_EXP 171
101752: PUSH
101753: LD_INT 1
101755: ST_TO_ADDR
// if p3 = 15 then
101756: LD_VAR 0 3
101760: PUSH
101761: LD_INT 15
101763: EQUAL
101764: IFFALSE 101774
// sKamikadze := true ;
101766: LD_ADDR_EXP 179
101770: PUSH
101771: LD_INT 1
101773: ST_TO_ADDR
// if p3 = 16 then
101774: LD_VAR 0 3
101778: PUSH
101779: LD_INT 16
101781: EQUAL
101782: IFFALSE 101792
// sTroll := true ;
101784: LD_ADDR_EXP 180
101788: PUSH
101789: LD_INT 1
101791: ST_TO_ADDR
// if p3 = 17 then
101792: LD_VAR 0 3
101796: PUSH
101797: LD_INT 17
101799: EQUAL
101800: IFFALSE 101810
// sSlow := true ;
101802: LD_ADDR_EXP 181
101806: PUSH
101807: LD_INT 1
101809: ST_TO_ADDR
// if p3 = 18 then
101810: LD_VAR 0 3
101814: PUSH
101815: LD_INT 18
101817: EQUAL
101818: IFFALSE 101828
// sLack := true ;
101820: LD_ADDR_EXP 182
101824: PUSH
101825: LD_INT 1
101827: ST_TO_ADDR
// if p3 = 19 then
101828: LD_VAR 0 3
101832: PUSH
101833: LD_INT 19
101835: EQUAL
101836: IFFALSE 101846
// sTank := true ;
101838: LD_ADDR_EXP 184
101842: PUSH
101843: LD_INT 1
101845: ST_TO_ADDR
// if p3 = 20 then
101846: LD_VAR 0 3
101850: PUSH
101851: LD_INT 20
101853: EQUAL
101854: IFFALSE 101864
// sRemote := true ;
101856: LD_ADDR_EXP 185
101860: PUSH
101861: LD_INT 1
101863: ST_TO_ADDR
// if p3 = 21 then
101864: LD_VAR 0 3
101868: PUSH
101869: LD_INT 21
101871: EQUAL
101872: IFFALSE 101882
// sPowell := true ;
101874: LD_ADDR_EXP 186
101878: PUSH
101879: LD_INT 1
101881: ST_TO_ADDR
// if p3 = 22 then
101882: LD_VAR 0 3
101886: PUSH
101887: LD_INT 22
101889: EQUAL
101890: IFFALSE 101900
// sTeleport := true ;
101892: LD_ADDR_EXP 189
101896: PUSH
101897: LD_INT 1
101899: ST_TO_ADDR
// if p3 = 23 then
101900: LD_VAR 0 3
101904: PUSH
101905: LD_INT 23
101907: EQUAL
101908: IFFALSE 101918
// sOilTower := true ;
101910: LD_ADDR_EXP 191
101914: PUSH
101915: LD_INT 1
101917: ST_TO_ADDR
// if p3 = 24 then
101918: LD_VAR 0 3
101922: PUSH
101923: LD_INT 24
101925: EQUAL
101926: IFFALSE 101936
// sShovel := true ;
101928: LD_ADDR_EXP 192
101932: PUSH
101933: LD_INT 1
101935: ST_TO_ADDR
// if p3 = 25 then
101936: LD_VAR 0 3
101940: PUSH
101941: LD_INT 25
101943: EQUAL
101944: IFFALSE 101954
// sSheik := true ;
101946: LD_ADDR_EXP 193
101950: PUSH
101951: LD_INT 1
101953: ST_TO_ADDR
// if p3 = 26 then
101954: LD_VAR 0 3
101958: PUSH
101959: LD_INT 26
101961: EQUAL
101962: IFFALSE 101972
// sEarthquake := true ;
101964: LD_ADDR_EXP 195
101968: PUSH
101969: LD_INT 1
101971: ST_TO_ADDR
// if p3 = 27 then
101972: LD_VAR 0 3
101976: PUSH
101977: LD_INT 27
101979: EQUAL
101980: IFFALSE 101990
// sAI := true ;
101982: LD_ADDR_EXP 196
101986: PUSH
101987: LD_INT 1
101989: ST_TO_ADDR
// if p3 = 28 then
101990: LD_VAR 0 3
101994: PUSH
101995: LD_INT 28
101997: EQUAL
101998: IFFALSE 102008
// sCargo := true ;
102000: LD_ADDR_EXP 199
102004: PUSH
102005: LD_INT 1
102007: ST_TO_ADDR
// if p3 = 29 then
102008: LD_VAR 0 3
102012: PUSH
102013: LD_INT 29
102015: EQUAL
102016: IFFALSE 102026
// sDLaser := true ;
102018: LD_ADDR_EXP 200
102022: PUSH
102023: LD_INT 1
102025: ST_TO_ADDR
// if p3 = 30 then
102026: LD_VAR 0 3
102030: PUSH
102031: LD_INT 30
102033: EQUAL
102034: IFFALSE 102044
// sExchange := true ;
102036: LD_ADDR_EXP 201
102040: PUSH
102041: LD_INT 1
102043: ST_TO_ADDR
// if p3 = 31 then
102044: LD_VAR 0 3
102048: PUSH
102049: LD_INT 31
102051: EQUAL
102052: IFFALSE 102062
// sFac := true ;
102054: LD_ADDR_EXP 202
102058: PUSH
102059: LD_INT 1
102061: ST_TO_ADDR
// if p3 = 32 then
102062: LD_VAR 0 3
102066: PUSH
102067: LD_INT 32
102069: EQUAL
102070: IFFALSE 102080
// sPower := true ;
102072: LD_ADDR_EXP 203
102076: PUSH
102077: LD_INT 1
102079: ST_TO_ADDR
// if p3 = 33 then
102080: LD_VAR 0 3
102084: PUSH
102085: LD_INT 33
102087: EQUAL
102088: IFFALSE 102098
// sRandom := true ;
102090: LD_ADDR_EXP 204
102094: PUSH
102095: LD_INT 1
102097: ST_TO_ADDR
// if p3 = 34 then
102098: LD_VAR 0 3
102102: PUSH
102103: LD_INT 34
102105: EQUAL
102106: IFFALSE 102116
// sShield := true ;
102108: LD_ADDR_EXP 205
102112: PUSH
102113: LD_INT 1
102115: ST_TO_ADDR
// if p3 = 35 then
102116: LD_VAR 0 3
102120: PUSH
102121: LD_INT 35
102123: EQUAL
102124: IFFALSE 102134
// sTime := true ;
102126: LD_ADDR_EXP 206
102130: PUSH
102131: LD_INT 1
102133: ST_TO_ADDR
// if p3 = 36 then
102134: LD_VAR 0 3
102138: PUSH
102139: LD_INT 36
102141: EQUAL
102142: IFFALSE 102152
// sTools := true ;
102144: LD_ADDR_EXP 207
102148: PUSH
102149: LD_INT 1
102151: ST_TO_ADDR
// if p3 = 101 then
102152: LD_VAR 0 3
102156: PUSH
102157: LD_INT 101
102159: EQUAL
102160: IFFALSE 102170
// sSold := true ;
102162: LD_ADDR_EXP 172
102166: PUSH
102167: LD_INT 1
102169: ST_TO_ADDR
// if p3 = 102 then
102170: LD_VAR 0 3
102174: PUSH
102175: LD_INT 102
102177: EQUAL
102178: IFFALSE 102188
// sDiff := true ;
102180: LD_ADDR_EXP 173
102184: PUSH
102185: LD_INT 1
102187: ST_TO_ADDR
// if p3 = 103 then
102188: LD_VAR 0 3
102192: PUSH
102193: LD_INT 103
102195: EQUAL
102196: IFFALSE 102206
// sFog := true ;
102198: LD_ADDR_EXP 176
102202: PUSH
102203: LD_INT 1
102205: ST_TO_ADDR
// if p3 = 104 then
102206: LD_VAR 0 3
102210: PUSH
102211: LD_INT 104
102213: EQUAL
102214: IFFALSE 102224
// sReset := true ;
102216: LD_ADDR_EXP 177
102220: PUSH
102221: LD_INT 1
102223: ST_TO_ADDR
// if p3 = 105 then
102224: LD_VAR 0 3
102228: PUSH
102229: LD_INT 105
102231: EQUAL
102232: IFFALSE 102242
// sSun := true ;
102234: LD_ADDR_EXP 178
102238: PUSH
102239: LD_INT 1
102241: ST_TO_ADDR
// if p3 = 106 then
102242: LD_VAR 0 3
102246: PUSH
102247: LD_INT 106
102249: EQUAL
102250: IFFALSE 102260
// sTiger := true ;
102252: LD_ADDR_EXP 174
102256: PUSH
102257: LD_INT 1
102259: ST_TO_ADDR
// if p3 = 107 then
102260: LD_VAR 0 3
102264: PUSH
102265: LD_INT 107
102267: EQUAL
102268: IFFALSE 102278
// sBomb := true ;
102270: LD_ADDR_EXP 175
102274: PUSH
102275: LD_INT 1
102277: ST_TO_ADDR
// if p3 = 108 then
102278: LD_VAR 0 3
102282: PUSH
102283: LD_INT 108
102285: EQUAL
102286: IFFALSE 102296
// sWound := true ;
102288: LD_ADDR_EXP 183
102292: PUSH
102293: LD_INT 1
102295: ST_TO_ADDR
// if p3 = 109 then
102296: LD_VAR 0 3
102300: PUSH
102301: LD_INT 109
102303: EQUAL
102304: IFFALSE 102314
// sBetray := true ;
102306: LD_ADDR_EXP 187
102310: PUSH
102311: LD_INT 1
102313: ST_TO_ADDR
// if p3 = 110 then
102314: LD_VAR 0 3
102318: PUSH
102319: LD_INT 110
102321: EQUAL
102322: IFFALSE 102332
// sContamin := true ;
102324: LD_ADDR_EXP 188
102328: PUSH
102329: LD_INT 1
102331: ST_TO_ADDR
// if p3 = 111 then
102332: LD_VAR 0 3
102336: PUSH
102337: LD_INT 111
102339: EQUAL
102340: IFFALSE 102350
// sOil := true ;
102342: LD_ADDR_EXP 190
102346: PUSH
102347: LD_INT 1
102349: ST_TO_ADDR
// if p3 = 112 then
102350: LD_VAR 0 3
102354: PUSH
102355: LD_INT 112
102357: EQUAL
102358: IFFALSE 102368
// sStu := true ;
102360: LD_ADDR_EXP 194
102364: PUSH
102365: LD_INT 1
102367: ST_TO_ADDR
// if p3 = 113 then
102368: LD_VAR 0 3
102372: PUSH
102373: LD_INT 113
102375: EQUAL
102376: IFFALSE 102386
// sBazooka := true ;
102378: LD_ADDR_EXP 197
102382: PUSH
102383: LD_INT 1
102385: ST_TO_ADDR
// if p3 = 114 then
102386: LD_VAR 0 3
102390: PUSH
102391: LD_INT 114
102393: EQUAL
102394: IFFALSE 102404
// sMortar := true ;
102396: LD_ADDR_EXP 198
102400: PUSH
102401: LD_INT 1
102403: ST_TO_ADDR
// if p3 = 115 then
102404: LD_VAR 0 3
102408: PUSH
102409: LD_INT 115
102411: EQUAL
102412: IFFALSE 102422
// sRanger := true ;
102414: LD_ADDR_EXP 208
102418: PUSH
102419: LD_INT 1
102421: ST_TO_ADDR
// end ; if p2 = 101 then
102422: LD_VAR 0 2
102426: PUSH
102427: LD_INT 101
102429: EQUAL
102430: IFFALSE 102558
// begin case p3 of 1 :
102432: LD_VAR 0 3
102436: PUSH
102437: LD_INT 1
102439: DOUBLE
102440: EQUAL
102441: IFTRUE 102445
102443: GO 102452
102445: POP
// hHackUnlimitedResources ; 2 :
102446: CALL 113593 0 0
102450: GO 102558
102452: LD_INT 2
102454: DOUBLE
102455: EQUAL
102456: IFTRUE 102460
102458: GO 102467
102460: POP
// hHackSetLevel10 ; 3 :
102461: CALL 113726 0 0
102465: GO 102558
102467: LD_INT 3
102469: DOUBLE
102470: EQUAL
102471: IFTRUE 102475
102473: GO 102482
102475: POP
// hHackSetLevel10YourUnits ; 4 :
102476: CALL 113811 0 0
102480: GO 102558
102482: LD_INT 4
102484: DOUBLE
102485: EQUAL
102486: IFTRUE 102490
102488: GO 102497
102490: POP
// hHackInvincible ; 5 :
102491: CALL 114259 0 0
102495: GO 102558
102497: LD_INT 5
102499: DOUBLE
102500: EQUAL
102501: IFTRUE 102505
102503: GO 102512
102505: POP
// hHackInvisible ; 6 :
102506: CALL 114370 0 0
102510: GO 102558
102512: LD_INT 6
102514: DOUBLE
102515: EQUAL
102516: IFTRUE 102520
102518: GO 102527
102520: POP
// hHackChangeYourSide ; 7 :
102521: CALL 114427 0 0
102525: GO 102558
102527: LD_INT 7
102529: DOUBLE
102530: EQUAL
102531: IFTRUE 102535
102533: GO 102542
102535: POP
// hHackChangeUnitSide ; 8 :
102536: CALL 114469 0 0
102540: GO 102558
102542: LD_INT 8
102544: DOUBLE
102545: EQUAL
102546: IFTRUE 102550
102548: GO 102557
102550: POP
// hHackFog ; end ;
102551: CALL 114570 0 0
102555: GO 102558
102557: POP
// end ; end ;
102558: PPOPN 6
102560: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
102561: GO 102563
102563: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
102564: LD_STRING initStreamRollete();
102566: PPUSH
102567: CALL_OW 559
// InitStreamMode ;
102571: CALL 102580 0 0
// DefineStreamItems ( ) ;
102575: CALL 103020 0 0
// end ;
102579: END
// function InitStreamMode ; begin
102580: LD_INT 0
102582: PPUSH
// streamModeActive := false ;
102583: LD_ADDR_EXP 155
102587: PUSH
102588: LD_INT 0
102590: ST_TO_ADDR
// normalCounter := 36 ;
102591: LD_ADDR_EXP 156
102595: PUSH
102596: LD_INT 36
102598: ST_TO_ADDR
// hardcoreCounter := 16 ;
102599: LD_ADDR_EXP 157
102603: PUSH
102604: LD_INT 16
102606: ST_TO_ADDR
// sRocket := false ;
102607: LD_ADDR_EXP 160
102611: PUSH
102612: LD_INT 0
102614: ST_TO_ADDR
// sSpeed := false ;
102615: LD_ADDR_EXP 159
102619: PUSH
102620: LD_INT 0
102622: ST_TO_ADDR
// sEngine := false ;
102623: LD_ADDR_EXP 161
102627: PUSH
102628: LD_INT 0
102630: ST_TO_ADDR
// sSpec := false ;
102631: LD_ADDR_EXP 158
102635: PUSH
102636: LD_INT 0
102638: ST_TO_ADDR
// sLevel := false ;
102639: LD_ADDR_EXP 162
102643: PUSH
102644: LD_INT 0
102646: ST_TO_ADDR
// sArmoury := false ;
102647: LD_ADDR_EXP 163
102651: PUSH
102652: LD_INT 0
102654: ST_TO_ADDR
// sRadar := false ;
102655: LD_ADDR_EXP 164
102659: PUSH
102660: LD_INT 0
102662: ST_TO_ADDR
// sBunker := false ;
102663: LD_ADDR_EXP 165
102667: PUSH
102668: LD_INT 0
102670: ST_TO_ADDR
// sHack := false ;
102671: LD_ADDR_EXP 166
102675: PUSH
102676: LD_INT 0
102678: ST_TO_ADDR
// sFire := false ;
102679: LD_ADDR_EXP 167
102683: PUSH
102684: LD_INT 0
102686: ST_TO_ADDR
// sRefresh := false ;
102687: LD_ADDR_EXP 168
102691: PUSH
102692: LD_INT 0
102694: ST_TO_ADDR
// sExp := false ;
102695: LD_ADDR_EXP 169
102699: PUSH
102700: LD_INT 0
102702: ST_TO_ADDR
// sDepot := false ;
102703: LD_ADDR_EXP 170
102707: PUSH
102708: LD_INT 0
102710: ST_TO_ADDR
// sFlag := false ;
102711: LD_ADDR_EXP 171
102715: PUSH
102716: LD_INT 0
102718: ST_TO_ADDR
// sKamikadze := false ;
102719: LD_ADDR_EXP 179
102723: PUSH
102724: LD_INT 0
102726: ST_TO_ADDR
// sTroll := false ;
102727: LD_ADDR_EXP 180
102731: PUSH
102732: LD_INT 0
102734: ST_TO_ADDR
// sSlow := false ;
102735: LD_ADDR_EXP 181
102739: PUSH
102740: LD_INT 0
102742: ST_TO_ADDR
// sLack := false ;
102743: LD_ADDR_EXP 182
102747: PUSH
102748: LD_INT 0
102750: ST_TO_ADDR
// sTank := false ;
102751: LD_ADDR_EXP 184
102755: PUSH
102756: LD_INT 0
102758: ST_TO_ADDR
// sRemote := false ;
102759: LD_ADDR_EXP 185
102763: PUSH
102764: LD_INT 0
102766: ST_TO_ADDR
// sPowell := false ;
102767: LD_ADDR_EXP 186
102771: PUSH
102772: LD_INT 0
102774: ST_TO_ADDR
// sTeleport := false ;
102775: LD_ADDR_EXP 189
102779: PUSH
102780: LD_INT 0
102782: ST_TO_ADDR
// sOilTower := false ;
102783: LD_ADDR_EXP 191
102787: PUSH
102788: LD_INT 0
102790: ST_TO_ADDR
// sShovel := false ;
102791: LD_ADDR_EXP 192
102795: PUSH
102796: LD_INT 0
102798: ST_TO_ADDR
// sSheik := false ;
102799: LD_ADDR_EXP 193
102803: PUSH
102804: LD_INT 0
102806: ST_TO_ADDR
// sEarthquake := false ;
102807: LD_ADDR_EXP 195
102811: PUSH
102812: LD_INT 0
102814: ST_TO_ADDR
// sAI := false ;
102815: LD_ADDR_EXP 196
102819: PUSH
102820: LD_INT 0
102822: ST_TO_ADDR
// sCargo := false ;
102823: LD_ADDR_EXP 199
102827: PUSH
102828: LD_INT 0
102830: ST_TO_ADDR
// sDLaser := false ;
102831: LD_ADDR_EXP 200
102835: PUSH
102836: LD_INT 0
102838: ST_TO_ADDR
// sExchange := false ;
102839: LD_ADDR_EXP 201
102843: PUSH
102844: LD_INT 0
102846: ST_TO_ADDR
// sFac := false ;
102847: LD_ADDR_EXP 202
102851: PUSH
102852: LD_INT 0
102854: ST_TO_ADDR
// sPower := false ;
102855: LD_ADDR_EXP 203
102859: PUSH
102860: LD_INT 0
102862: ST_TO_ADDR
// sRandom := false ;
102863: LD_ADDR_EXP 204
102867: PUSH
102868: LD_INT 0
102870: ST_TO_ADDR
// sShield := false ;
102871: LD_ADDR_EXP 205
102875: PUSH
102876: LD_INT 0
102878: ST_TO_ADDR
// sTime := false ;
102879: LD_ADDR_EXP 206
102883: PUSH
102884: LD_INT 0
102886: ST_TO_ADDR
// sTools := false ;
102887: LD_ADDR_EXP 207
102891: PUSH
102892: LD_INT 0
102894: ST_TO_ADDR
// sSold := false ;
102895: LD_ADDR_EXP 172
102899: PUSH
102900: LD_INT 0
102902: ST_TO_ADDR
// sDiff := false ;
102903: LD_ADDR_EXP 173
102907: PUSH
102908: LD_INT 0
102910: ST_TO_ADDR
// sFog := false ;
102911: LD_ADDR_EXP 176
102915: PUSH
102916: LD_INT 0
102918: ST_TO_ADDR
// sReset := false ;
102919: LD_ADDR_EXP 177
102923: PUSH
102924: LD_INT 0
102926: ST_TO_ADDR
// sSun := false ;
102927: LD_ADDR_EXP 178
102931: PUSH
102932: LD_INT 0
102934: ST_TO_ADDR
// sTiger := false ;
102935: LD_ADDR_EXP 174
102939: PUSH
102940: LD_INT 0
102942: ST_TO_ADDR
// sBomb := false ;
102943: LD_ADDR_EXP 175
102947: PUSH
102948: LD_INT 0
102950: ST_TO_ADDR
// sWound := false ;
102951: LD_ADDR_EXP 183
102955: PUSH
102956: LD_INT 0
102958: ST_TO_ADDR
// sBetray := false ;
102959: LD_ADDR_EXP 187
102963: PUSH
102964: LD_INT 0
102966: ST_TO_ADDR
// sContamin := false ;
102967: LD_ADDR_EXP 188
102971: PUSH
102972: LD_INT 0
102974: ST_TO_ADDR
// sOil := false ;
102975: LD_ADDR_EXP 190
102979: PUSH
102980: LD_INT 0
102982: ST_TO_ADDR
// sStu := false ;
102983: LD_ADDR_EXP 194
102987: PUSH
102988: LD_INT 0
102990: ST_TO_ADDR
// sBazooka := false ;
102991: LD_ADDR_EXP 197
102995: PUSH
102996: LD_INT 0
102998: ST_TO_ADDR
// sMortar := false ;
102999: LD_ADDR_EXP 198
103003: PUSH
103004: LD_INT 0
103006: ST_TO_ADDR
// sRanger := false ;
103007: LD_ADDR_EXP 208
103011: PUSH
103012: LD_INT 0
103014: ST_TO_ADDR
// end ;
103015: LD_VAR 0 1
103019: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
103020: LD_INT 0
103022: PPUSH
103023: PPUSH
103024: PPUSH
103025: PPUSH
103026: PPUSH
// result := [ ] ;
103027: LD_ADDR_VAR 0 1
103031: PUSH
103032: EMPTY
103033: ST_TO_ADDR
// if campaign_id = 1 then
103034: LD_OWVAR 69
103038: PUSH
103039: LD_INT 1
103041: EQUAL
103042: IFFALSE 105980
// begin case mission_number of 1 :
103044: LD_OWVAR 70
103048: PUSH
103049: LD_INT 1
103051: DOUBLE
103052: EQUAL
103053: IFTRUE 103057
103055: GO 103121
103057: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
103058: LD_ADDR_VAR 0 1
103062: PUSH
103063: LD_INT 2
103065: PUSH
103066: LD_INT 4
103068: PUSH
103069: LD_INT 11
103071: PUSH
103072: LD_INT 12
103074: PUSH
103075: LD_INT 15
103077: PUSH
103078: LD_INT 16
103080: PUSH
103081: LD_INT 22
103083: PUSH
103084: LD_INT 23
103086: PUSH
103087: LD_INT 26
103089: PUSH
103090: EMPTY
103091: LIST
103092: LIST
103093: LIST
103094: LIST
103095: LIST
103096: LIST
103097: LIST
103098: LIST
103099: LIST
103100: PUSH
103101: LD_INT 101
103103: PUSH
103104: LD_INT 102
103106: PUSH
103107: LD_INT 106
103109: PUSH
103110: EMPTY
103111: LIST
103112: LIST
103113: LIST
103114: PUSH
103115: EMPTY
103116: LIST
103117: LIST
103118: ST_TO_ADDR
103119: GO 105978
103121: LD_INT 2
103123: DOUBLE
103124: EQUAL
103125: IFTRUE 103129
103127: GO 103201
103129: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
103130: LD_ADDR_VAR 0 1
103134: PUSH
103135: LD_INT 2
103137: PUSH
103138: LD_INT 4
103140: PUSH
103141: LD_INT 11
103143: PUSH
103144: LD_INT 12
103146: PUSH
103147: LD_INT 15
103149: PUSH
103150: LD_INT 16
103152: PUSH
103153: LD_INT 22
103155: PUSH
103156: LD_INT 23
103158: PUSH
103159: LD_INT 26
103161: PUSH
103162: EMPTY
103163: LIST
103164: LIST
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: PUSH
103173: LD_INT 101
103175: PUSH
103176: LD_INT 102
103178: PUSH
103179: LD_INT 105
103181: PUSH
103182: LD_INT 106
103184: PUSH
103185: LD_INT 108
103187: PUSH
103188: EMPTY
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: LIST
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: ST_TO_ADDR
103199: GO 105978
103201: LD_INT 3
103203: DOUBLE
103204: EQUAL
103205: IFTRUE 103209
103207: GO 103285
103209: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
103210: LD_ADDR_VAR 0 1
103214: PUSH
103215: LD_INT 2
103217: PUSH
103218: LD_INT 4
103220: PUSH
103221: LD_INT 5
103223: PUSH
103224: LD_INT 11
103226: PUSH
103227: LD_INT 12
103229: PUSH
103230: LD_INT 15
103232: PUSH
103233: LD_INT 16
103235: PUSH
103236: LD_INT 22
103238: PUSH
103239: LD_INT 26
103241: PUSH
103242: LD_INT 36
103244: PUSH
103245: EMPTY
103246: LIST
103247: LIST
103248: LIST
103249: LIST
103250: LIST
103251: LIST
103252: LIST
103253: LIST
103254: LIST
103255: LIST
103256: PUSH
103257: LD_INT 101
103259: PUSH
103260: LD_INT 102
103262: PUSH
103263: LD_INT 105
103265: PUSH
103266: LD_INT 106
103268: PUSH
103269: LD_INT 108
103271: PUSH
103272: EMPTY
103273: LIST
103274: LIST
103275: LIST
103276: LIST
103277: LIST
103278: PUSH
103279: EMPTY
103280: LIST
103281: LIST
103282: ST_TO_ADDR
103283: GO 105978
103285: LD_INT 4
103287: DOUBLE
103288: EQUAL
103289: IFTRUE 103293
103291: GO 103377
103293: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
103294: LD_ADDR_VAR 0 1
103298: PUSH
103299: LD_INT 2
103301: PUSH
103302: LD_INT 4
103304: PUSH
103305: LD_INT 5
103307: PUSH
103308: LD_INT 8
103310: PUSH
103311: LD_INT 11
103313: PUSH
103314: LD_INT 12
103316: PUSH
103317: LD_INT 15
103319: PUSH
103320: LD_INT 16
103322: PUSH
103323: LD_INT 22
103325: PUSH
103326: LD_INT 23
103328: PUSH
103329: LD_INT 26
103331: PUSH
103332: LD_INT 36
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: LIST
103339: LIST
103340: LIST
103341: LIST
103342: LIST
103343: LIST
103344: LIST
103345: LIST
103346: LIST
103347: LIST
103348: PUSH
103349: LD_INT 101
103351: PUSH
103352: LD_INT 102
103354: PUSH
103355: LD_INT 105
103357: PUSH
103358: LD_INT 106
103360: PUSH
103361: LD_INT 108
103363: PUSH
103364: EMPTY
103365: LIST
103366: LIST
103367: LIST
103368: LIST
103369: LIST
103370: PUSH
103371: EMPTY
103372: LIST
103373: LIST
103374: ST_TO_ADDR
103375: GO 105978
103377: LD_INT 5
103379: DOUBLE
103380: EQUAL
103381: IFTRUE 103385
103383: GO 103485
103385: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
103386: LD_ADDR_VAR 0 1
103390: PUSH
103391: LD_INT 2
103393: PUSH
103394: LD_INT 4
103396: PUSH
103397: LD_INT 5
103399: PUSH
103400: LD_INT 6
103402: PUSH
103403: LD_INT 8
103405: PUSH
103406: LD_INT 11
103408: PUSH
103409: LD_INT 12
103411: PUSH
103412: LD_INT 15
103414: PUSH
103415: LD_INT 16
103417: PUSH
103418: LD_INT 22
103420: PUSH
103421: LD_INT 23
103423: PUSH
103424: LD_INT 25
103426: PUSH
103427: LD_INT 26
103429: PUSH
103430: LD_INT 36
103432: PUSH
103433: EMPTY
103434: LIST
103435: LIST
103436: LIST
103437: LIST
103438: LIST
103439: LIST
103440: LIST
103441: LIST
103442: LIST
103443: LIST
103444: LIST
103445: LIST
103446: LIST
103447: LIST
103448: PUSH
103449: LD_INT 101
103451: PUSH
103452: LD_INT 102
103454: PUSH
103455: LD_INT 105
103457: PUSH
103458: LD_INT 106
103460: PUSH
103461: LD_INT 108
103463: PUSH
103464: LD_INT 109
103466: PUSH
103467: LD_INT 112
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: LIST
103474: LIST
103475: LIST
103476: LIST
103477: LIST
103478: PUSH
103479: EMPTY
103480: LIST
103481: LIST
103482: ST_TO_ADDR
103483: GO 105978
103485: LD_INT 6
103487: DOUBLE
103488: EQUAL
103489: IFTRUE 103493
103491: GO 103613
103493: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
103494: LD_ADDR_VAR 0 1
103498: PUSH
103499: LD_INT 2
103501: PUSH
103502: LD_INT 4
103504: PUSH
103505: LD_INT 5
103507: PUSH
103508: LD_INT 6
103510: PUSH
103511: LD_INT 8
103513: PUSH
103514: LD_INT 11
103516: PUSH
103517: LD_INT 12
103519: PUSH
103520: LD_INT 15
103522: PUSH
103523: LD_INT 16
103525: PUSH
103526: LD_INT 20
103528: PUSH
103529: LD_INT 21
103531: PUSH
103532: LD_INT 22
103534: PUSH
103535: LD_INT 23
103537: PUSH
103538: LD_INT 25
103540: PUSH
103541: LD_INT 26
103543: PUSH
103544: LD_INT 30
103546: PUSH
103547: LD_INT 31
103549: PUSH
103550: LD_INT 32
103552: PUSH
103553: LD_INT 36
103555: PUSH
103556: EMPTY
103557: LIST
103558: LIST
103559: LIST
103560: LIST
103561: LIST
103562: LIST
103563: LIST
103564: LIST
103565: LIST
103566: LIST
103567: LIST
103568: LIST
103569: LIST
103570: LIST
103571: LIST
103572: LIST
103573: LIST
103574: LIST
103575: LIST
103576: PUSH
103577: LD_INT 101
103579: PUSH
103580: LD_INT 102
103582: PUSH
103583: LD_INT 105
103585: PUSH
103586: LD_INT 106
103588: PUSH
103589: LD_INT 108
103591: PUSH
103592: LD_INT 109
103594: PUSH
103595: LD_INT 112
103597: PUSH
103598: EMPTY
103599: LIST
103600: LIST
103601: LIST
103602: LIST
103603: LIST
103604: LIST
103605: LIST
103606: PUSH
103607: EMPTY
103608: LIST
103609: LIST
103610: ST_TO_ADDR
103611: GO 105978
103613: LD_INT 7
103615: DOUBLE
103616: EQUAL
103617: IFTRUE 103621
103619: GO 103721
103621: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
103622: LD_ADDR_VAR 0 1
103626: PUSH
103627: LD_INT 2
103629: PUSH
103630: LD_INT 4
103632: PUSH
103633: LD_INT 5
103635: PUSH
103636: LD_INT 7
103638: PUSH
103639: LD_INT 11
103641: PUSH
103642: LD_INT 12
103644: PUSH
103645: LD_INT 15
103647: PUSH
103648: LD_INT 16
103650: PUSH
103651: LD_INT 20
103653: PUSH
103654: LD_INT 21
103656: PUSH
103657: LD_INT 22
103659: PUSH
103660: LD_INT 23
103662: PUSH
103663: LD_INT 25
103665: PUSH
103666: LD_INT 26
103668: PUSH
103669: EMPTY
103670: LIST
103671: LIST
103672: LIST
103673: LIST
103674: LIST
103675: LIST
103676: LIST
103677: LIST
103678: LIST
103679: LIST
103680: LIST
103681: LIST
103682: LIST
103683: LIST
103684: PUSH
103685: LD_INT 101
103687: PUSH
103688: LD_INT 102
103690: PUSH
103691: LD_INT 103
103693: PUSH
103694: LD_INT 105
103696: PUSH
103697: LD_INT 106
103699: PUSH
103700: LD_INT 108
103702: PUSH
103703: LD_INT 112
103705: PUSH
103706: EMPTY
103707: LIST
103708: LIST
103709: LIST
103710: LIST
103711: LIST
103712: LIST
103713: LIST
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: ST_TO_ADDR
103719: GO 105978
103721: LD_INT 8
103723: DOUBLE
103724: EQUAL
103725: IFTRUE 103729
103727: GO 103857
103729: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
103730: LD_ADDR_VAR 0 1
103734: PUSH
103735: LD_INT 2
103737: PUSH
103738: LD_INT 4
103740: PUSH
103741: LD_INT 5
103743: PUSH
103744: LD_INT 6
103746: PUSH
103747: LD_INT 7
103749: PUSH
103750: LD_INT 8
103752: PUSH
103753: LD_INT 11
103755: PUSH
103756: LD_INT 12
103758: PUSH
103759: LD_INT 15
103761: PUSH
103762: LD_INT 16
103764: PUSH
103765: LD_INT 20
103767: PUSH
103768: LD_INT 21
103770: PUSH
103771: LD_INT 22
103773: PUSH
103774: LD_INT 23
103776: PUSH
103777: LD_INT 25
103779: PUSH
103780: LD_INT 26
103782: PUSH
103783: LD_INT 30
103785: PUSH
103786: LD_INT 31
103788: PUSH
103789: LD_INT 32
103791: PUSH
103792: LD_INT 36
103794: PUSH
103795: EMPTY
103796: LIST
103797: LIST
103798: LIST
103799: LIST
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: LIST
103806: LIST
103807: LIST
103808: LIST
103809: LIST
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: LIST
103815: LIST
103816: PUSH
103817: LD_INT 101
103819: PUSH
103820: LD_INT 102
103822: PUSH
103823: LD_INT 103
103825: PUSH
103826: LD_INT 105
103828: PUSH
103829: LD_INT 106
103831: PUSH
103832: LD_INT 108
103834: PUSH
103835: LD_INT 109
103837: PUSH
103838: LD_INT 112
103840: PUSH
103841: EMPTY
103842: LIST
103843: LIST
103844: LIST
103845: LIST
103846: LIST
103847: LIST
103848: LIST
103849: LIST
103850: PUSH
103851: EMPTY
103852: LIST
103853: LIST
103854: ST_TO_ADDR
103855: GO 105978
103857: LD_INT 9
103859: DOUBLE
103860: EQUAL
103861: IFTRUE 103865
103863: GO 104001
103865: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
103866: LD_ADDR_VAR 0 1
103870: PUSH
103871: LD_INT 2
103873: PUSH
103874: LD_INT 4
103876: PUSH
103877: LD_INT 5
103879: PUSH
103880: LD_INT 6
103882: PUSH
103883: LD_INT 7
103885: PUSH
103886: LD_INT 8
103888: PUSH
103889: LD_INT 11
103891: PUSH
103892: LD_INT 12
103894: PUSH
103895: LD_INT 15
103897: PUSH
103898: LD_INT 16
103900: PUSH
103901: LD_INT 20
103903: PUSH
103904: LD_INT 21
103906: PUSH
103907: LD_INT 22
103909: PUSH
103910: LD_INT 23
103912: PUSH
103913: LD_INT 25
103915: PUSH
103916: LD_INT 26
103918: PUSH
103919: LD_INT 28
103921: PUSH
103922: LD_INT 30
103924: PUSH
103925: LD_INT 31
103927: PUSH
103928: LD_INT 32
103930: PUSH
103931: LD_INT 36
103933: PUSH
103934: EMPTY
103935: LIST
103936: LIST
103937: LIST
103938: LIST
103939: LIST
103940: LIST
103941: LIST
103942: LIST
103943: LIST
103944: LIST
103945: LIST
103946: LIST
103947: LIST
103948: LIST
103949: LIST
103950: LIST
103951: LIST
103952: LIST
103953: LIST
103954: LIST
103955: LIST
103956: PUSH
103957: LD_INT 101
103959: PUSH
103960: LD_INT 102
103962: PUSH
103963: LD_INT 103
103965: PUSH
103966: LD_INT 105
103968: PUSH
103969: LD_INT 106
103971: PUSH
103972: LD_INT 108
103974: PUSH
103975: LD_INT 109
103977: PUSH
103978: LD_INT 112
103980: PUSH
103981: LD_INT 114
103983: PUSH
103984: EMPTY
103985: LIST
103986: LIST
103987: LIST
103988: LIST
103989: LIST
103990: LIST
103991: LIST
103992: LIST
103993: LIST
103994: PUSH
103995: EMPTY
103996: LIST
103997: LIST
103998: ST_TO_ADDR
103999: GO 105978
104001: LD_INT 10
104003: DOUBLE
104004: EQUAL
104005: IFTRUE 104009
104007: GO 104193
104009: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
104010: LD_ADDR_VAR 0 1
104014: PUSH
104015: LD_INT 2
104017: PUSH
104018: LD_INT 4
104020: PUSH
104021: LD_INT 5
104023: PUSH
104024: LD_INT 6
104026: PUSH
104027: LD_INT 7
104029: PUSH
104030: LD_INT 8
104032: PUSH
104033: LD_INT 9
104035: PUSH
104036: LD_INT 10
104038: PUSH
104039: LD_INT 11
104041: PUSH
104042: LD_INT 12
104044: PUSH
104045: LD_INT 13
104047: PUSH
104048: LD_INT 14
104050: PUSH
104051: LD_INT 15
104053: PUSH
104054: LD_INT 16
104056: PUSH
104057: LD_INT 17
104059: PUSH
104060: LD_INT 18
104062: PUSH
104063: LD_INT 19
104065: PUSH
104066: LD_INT 20
104068: PUSH
104069: LD_INT 21
104071: PUSH
104072: LD_INT 22
104074: PUSH
104075: LD_INT 23
104077: PUSH
104078: LD_INT 24
104080: PUSH
104081: LD_INT 25
104083: PUSH
104084: LD_INT 26
104086: PUSH
104087: LD_INT 28
104089: PUSH
104090: LD_INT 30
104092: PUSH
104093: LD_INT 31
104095: PUSH
104096: LD_INT 32
104098: PUSH
104099: LD_INT 36
104101: PUSH
104102: EMPTY
104103: LIST
104104: LIST
104105: LIST
104106: LIST
104107: LIST
104108: LIST
104109: LIST
104110: LIST
104111: LIST
104112: LIST
104113: LIST
104114: LIST
104115: LIST
104116: LIST
104117: LIST
104118: LIST
104119: LIST
104120: LIST
104121: LIST
104122: LIST
104123: LIST
104124: LIST
104125: LIST
104126: LIST
104127: LIST
104128: LIST
104129: LIST
104130: LIST
104131: LIST
104132: PUSH
104133: LD_INT 101
104135: PUSH
104136: LD_INT 102
104138: PUSH
104139: LD_INT 103
104141: PUSH
104142: LD_INT 104
104144: PUSH
104145: LD_INT 105
104147: PUSH
104148: LD_INT 106
104150: PUSH
104151: LD_INT 107
104153: PUSH
104154: LD_INT 108
104156: PUSH
104157: LD_INT 109
104159: PUSH
104160: LD_INT 110
104162: PUSH
104163: LD_INT 111
104165: PUSH
104166: LD_INT 112
104168: PUSH
104169: LD_INT 114
104171: PUSH
104172: EMPTY
104173: LIST
104174: LIST
104175: LIST
104176: LIST
104177: LIST
104178: LIST
104179: LIST
104180: LIST
104181: LIST
104182: LIST
104183: LIST
104184: LIST
104185: LIST
104186: PUSH
104187: EMPTY
104188: LIST
104189: LIST
104190: ST_TO_ADDR
104191: GO 105978
104193: LD_INT 11
104195: DOUBLE
104196: EQUAL
104197: IFTRUE 104201
104199: GO 104393
104201: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
104202: LD_ADDR_VAR 0 1
104206: PUSH
104207: LD_INT 2
104209: PUSH
104210: LD_INT 3
104212: PUSH
104213: LD_INT 4
104215: PUSH
104216: LD_INT 5
104218: PUSH
104219: LD_INT 6
104221: PUSH
104222: LD_INT 7
104224: PUSH
104225: LD_INT 8
104227: PUSH
104228: LD_INT 9
104230: PUSH
104231: LD_INT 10
104233: PUSH
104234: LD_INT 11
104236: PUSH
104237: LD_INT 12
104239: PUSH
104240: LD_INT 13
104242: PUSH
104243: LD_INT 14
104245: PUSH
104246: LD_INT 15
104248: PUSH
104249: LD_INT 16
104251: PUSH
104252: LD_INT 17
104254: PUSH
104255: LD_INT 18
104257: PUSH
104258: LD_INT 19
104260: PUSH
104261: LD_INT 20
104263: PUSH
104264: LD_INT 21
104266: PUSH
104267: LD_INT 22
104269: PUSH
104270: LD_INT 23
104272: PUSH
104273: LD_INT 24
104275: PUSH
104276: LD_INT 25
104278: PUSH
104279: LD_INT 26
104281: PUSH
104282: LD_INT 28
104284: PUSH
104285: LD_INT 30
104287: PUSH
104288: LD_INT 31
104290: PUSH
104291: LD_INT 32
104293: PUSH
104294: LD_INT 34
104296: PUSH
104297: LD_INT 36
104299: PUSH
104300: EMPTY
104301: LIST
104302: LIST
104303: LIST
104304: LIST
104305: LIST
104306: LIST
104307: LIST
104308: LIST
104309: LIST
104310: LIST
104311: LIST
104312: LIST
104313: LIST
104314: LIST
104315: LIST
104316: LIST
104317: LIST
104318: LIST
104319: LIST
104320: LIST
104321: LIST
104322: LIST
104323: LIST
104324: LIST
104325: LIST
104326: LIST
104327: LIST
104328: LIST
104329: LIST
104330: LIST
104331: LIST
104332: PUSH
104333: LD_INT 101
104335: PUSH
104336: LD_INT 102
104338: PUSH
104339: LD_INT 103
104341: PUSH
104342: LD_INT 104
104344: PUSH
104345: LD_INT 105
104347: PUSH
104348: LD_INT 106
104350: PUSH
104351: LD_INT 107
104353: PUSH
104354: LD_INT 108
104356: PUSH
104357: LD_INT 109
104359: PUSH
104360: LD_INT 110
104362: PUSH
104363: LD_INT 111
104365: PUSH
104366: LD_INT 112
104368: PUSH
104369: LD_INT 114
104371: PUSH
104372: EMPTY
104373: LIST
104374: LIST
104375: LIST
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: PUSH
104387: EMPTY
104388: LIST
104389: LIST
104390: ST_TO_ADDR
104391: GO 105978
104393: LD_INT 12
104395: DOUBLE
104396: EQUAL
104397: IFTRUE 104401
104399: GO 104609
104401: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
104402: LD_ADDR_VAR 0 1
104406: PUSH
104407: LD_INT 1
104409: PUSH
104410: LD_INT 2
104412: PUSH
104413: LD_INT 3
104415: PUSH
104416: LD_INT 4
104418: PUSH
104419: LD_INT 5
104421: PUSH
104422: LD_INT 6
104424: PUSH
104425: LD_INT 7
104427: PUSH
104428: LD_INT 8
104430: PUSH
104431: LD_INT 9
104433: PUSH
104434: LD_INT 10
104436: PUSH
104437: LD_INT 11
104439: PUSH
104440: LD_INT 12
104442: PUSH
104443: LD_INT 13
104445: PUSH
104446: LD_INT 14
104448: PUSH
104449: LD_INT 15
104451: PUSH
104452: LD_INT 16
104454: PUSH
104455: LD_INT 17
104457: PUSH
104458: LD_INT 18
104460: PUSH
104461: LD_INT 19
104463: PUSH
104464: LD_INT 20
104466: PUSH
104467: LD_INT 21
104469: PUSH
104470: LD_INT 22
104472: PUSH
104473: LD_INT 23
104475: PUSH
104476: LD_INT 24
104478: PUSH
104479: LD_INT 25
104481: PUSH
104482: LD_INT 26
104484: PUSH
104485: LD_INT 27
104487: PUSH
104488: LD_INT 28
104490: PUSH
104491: LD_INT 30
104493: PUSH
104494: LD_INT 31
104496: PUSH
104497: LD_INT 32
104499: PUSH
104500: LD_INT 33
104502: PUSH
104503: LD_INT 34
104505: PUSH
104506: LD_INT 36
104508: PUSH
104509: EMPTY
104510: LIST
104511: LIST
104512: LIST
104513: LIST
104514: LIST
104515: LIST
104516: LIST
104517: LIST
104518: LIST
104519: LIST
104520: LIST
104521: LIST
104522: LIST
104523: LIST
104524: LIST
104525: LIST
104526: LIST
104527: LIST
104528: LIST
104529: LIST
104530: LIST
104531: LIST
104532: LIST
104533: LIST
104534: LIST
104535: LIST
104536: LIST
104537: LIST
104538: LIST
104539: LIST
104540: LIST
104541: LIST
104542: LIST
104543: LIST
104544: PUSH
104545: LD_INT 101
104547: PUSH
104548: LD_INT 102
104550: PUSH
104551: LD_INT 103
104553: PUSH
104554: LD_INT 104
104556: PUSH
104557: LD_INT 105
104559: PUSH
104560: LD_INT 106
104562: PUSH
104563: LD_INT 107
104565: PUSH
104566: LD_INT 108
104568: PUSH
104569: LD_INT 109
104571: PUSH
104572: LD_INT 110
104574: PUSH
104575: LD_INT 111
104577: PUSH
104578: LD_INT 112
104580: PUSH
104581: LD_INT 113
104583: PUSH
104584: LD_INT 114
104586: PUSH
104587: EMPTY
104588: LIST
104589: LIST
104590: LIST
104591: LIST
104592: LIST
104593: LIST
104594: LIST
104595: LIST
104596: LIST
104597: LIST
104598: LIST
104599: LIST
104600: LIST
104601: LIST
104602: PUSH
104603: EMPTY
104604: LIST
104605: LIST
104606: ST_TO_ADDR
104607: GO 105978
104609: LD_INT 13
104611: DOUBLE
104612: EQUAL
104613: IFTRUE 104617
104615: GO 104813
104617: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
104618: LD_ADDR_VAR 0 1
104622: PUSH
104623: LD_INT 1
104625: PUSH
104626: LD_INT 2
104628: PUSH
104629: LD_INT 3
104631: PUSH
104632: LD_INT 4
104634: PUSH
104635: LD_INT 5
104637: PUSH
104638: LD_INT 8
104640: PUSH
104641: LD_INT 9
104643: PUSH
104644: LD_INT 10
104646: PUSH
104647: LD_INT 11
104649: PUSH
104650: LD_INT 12
104652: PUSH
104653: LD_INT 14
104655: PUSH
104656: LD_INT 15
104658: PUSH
104659: LD_INT 16
104661: PUSH
104662: LD_INT 17
104664: PUSH
104665: LD_INT 18
104667: PUSH
104668: LD_INT 19
104670: PUSH
104671: LD_INT 20
104673: PUSH
104674: LD_INT 21
104676: PUSH
104677: LD_INT 22
104679: PUSH
104680: LD_INT 23
104682: PUSH
104683: LD_INT 24
104685: PUSH
104686: LD_INT 25
104688: PUSH
104689: LD_INT 26
104691: PUSH
104692: LD_INT 27
104694: PUSH
104695: LD_INT 28
104697: PUSH
104698: LD_INT 30
104700: PUSH
104701: LD_INT 31
104703: PUSH
104704: LD_INT 32
104706: PUSH
104707: LD_INT 33
104709: PUSH
104710: LD_INT 34
104712: PUSH
104713: LD_INT 36
104715: PUSH
104716: EMPTY
104717: LIST
104718: LIST
104719: LIST
104720: LIST
104721: LIST
104722: LIST
104723: LIST
104724: LIST
104725: LIST
104726: LIST
104727: LIST
104728: LIST
104729: LIST
104730: LIST
104731: LIST
104732: LIST
104733: LIST
104734: LIST
104735: LIST
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: LIST
104741: LIST
104742: LIST
104743: LIST
104744: LIST
104745: LIST
104746: LIST
104747: LIST
104748: PUSH
104749: LD_INT 101
104751: PUSH
104752: LD_INT 102
104754: PUSH
104755: LD_INT 103
104757: PUSH
104758: LD_INT 104
104760: PUSH
104761: LD_INT 105
104763: PUSH
104764: LD_INT 106
104766: PUSH
104767: LD_INT 107
104769: PUSH
104770: LD_INT 108
104772: PUSH
104773: LD_INT 109
104775: PUSH
104776: LD_INT 110
104778: PUSH
104779: LD_INT 111
104781: PUSH
104782: LD_INT 112
104784: PUSH
104785: LD_INT 113
104787: PUSH
104788: LD_INT 114
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: LIST
104795: LIST
104796: LIST
104797: LIST
104798: LIST
104799: LIST
104800: LIST
104801: LIST
104802: LIST
104803: LIST
104804: LIST
104805: LIST
104806: PUSH
104807: EMPTY
104808: LIST
104809: LIST
104810: ST_TO_ADDR
104811: GO 105978
104813: LD_INT 14
104815: DOUBLE
104816: EQUAL
104817: IFTRUE 104821
104819: GO 105033
104821: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
104822: LD_ADDR_VAR 0 1
104826: PUSH
104827: LD_INT 1
104829: PUSH
104830: LD_INT 2
104832: PUSH
104833: LD_INT 3
104835: PUSH
104836: LD_INT 4
104838: PUSH
104839: LD_INT 5
104841: PUSH
104842: LD_INT 6
104844: PUSH
104845: LD_INT 7
104847: PUSH
104848: LD_INT 8
104850: PUSH
104851: LD_INT 9
104853: PUSH
104854: LD_INT 10
104856: PUSH
104857: LD_INT 11
104859: PUSH
104860: LD_INT 12
104862: PUSH
104863: LD_INT 13
104865: PUSH
104866: LD_INT 14
104868: PUSH
104869: LD_INT 15
104871: PUSH
104872: LD_INT 16
104874: PUSH
104875: LD_INT 17
104877: PUSH
104878: LD_INT 18
104880: PUSH
104881: LD_INT 19
104883: PUSH
104884: LD_INT 20
104886: PUSH
104887: LD_INT 21
104889: PUSH
104890: LD_INT 22
104892: PUSH
104893: LD_INT 23
104895: PUSH
104896: LD_INT 24
104898: PUSH
104899: LD_INT 25
104901: PUSH
104902: LD_INT 26
104904: PUSH
104905: LD_INT 27
104907: PUSH
104908: LD_INT 28
104910: PUSH
104911: LD_INT 29
104913: PUSH
104914: LD_INT 30
104916: PUSH
104917: LD_INT 31
104919: PUSH
104920: LD_INT 32
104922: PUSH
104923: LD_INT 33
104925: PUSH
104926: LD_INT 34
104928: PUSH
104929: LD_INT 36
104931: PUSH
104932: EMPTY
104933: LIST
104934: LIST
104935: LIST
104936: LIST
104937: LIST
104938: LIST
104939: LIST
104940: LIST
104941: LIST
104942: LIST
104943: LIST
104944: LIST
104945: LIST
104946: LIST
104947: LIST
104948: LIST
104949: LIST
104950: LIST
104951: LIST
104952: LIST
104953: LIST
104954: LIST
104955: LIST
104956: LIST
104957: LIST
104958: LIST
104959: LIST
104960: LIST
104961: LIST
104962: LIST
104963: LIST
104964: LIST
104965: LIST
104966: LIST
104967: LIST
104968: PUSH
104969: LD_INT 101
104971: PUSH
104972: LD_INT 102
104974: PUSH
104975: LD_INT 103
104977: PUSH
104978: LD_INT 104
104980: PUSH
104981: LD_INT 105
104983: PUSH
104984: LD_INT 106
104986: PUSH
104987: LD_INT 107
104989: PUSH
104990: LD_INT 108
104992: PUSH
104993: LD_INT 109
104995: PUSH
104996: LD_INT 110
104998: PUSH
104999: LD_INT 111
105001: PUSH
105002: LD_INT 112
105004: PUSH
105005: LD_INT 113
105007: PUSH
105008: LD_INT 114
105010: PUSH
105011: EMPTY
105012: LIST
105013: LIST
105014: LIST
105015: LIST
105016: LIST
105017: LIST
105018: LIST
105019: LIST
105020: LIST
105021: LIST
105022: LIST
105023: LIST
105024: LIST
105025: LIST
105026: PUSH
105027: EMPTY
105028: LIST
105029: LIST
105030: ST_TO_ADDR
105031: GO 105978
105033: LD_INT 15
105035: DOUBLE
105036: EQUAL
105037: IFTRUE 105041
105039: GO 105253
105041: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
105042: LD_ADDR_VAR 0 1
105046: PUSH
105047: LD_INT 1
105049: PUSH
105050: LD_INT 2
105052: PUSH
105053: LD_INT 3
105055: PUSH
105056: LD_INT 4
105058: PUSH
105059: LD_INT 5
105061: PUSH
105062: LD_INT 6
105064: PUSH
105065: LD_INT 7
105067: PUSH
105068: LD_INT 8
105070: PUSH
105071: LD_INT 9
105073: PUSH
105074: LD_INT 10
105076: PUSH
105077: LD_INT 11
105079: PUSH
105080: LD_INT 12
105082: PUSH
105083: LD_INT 13
105085: PUSH
105086: LD_INT 14
105088: PUSH
105089: LD_INT 15
105091: PUSH
105092: LD_INT 16
105094: PUSH
105095: LD_INT 17
105097: PUSH
105098: LD_INT 18
105100: PUSH
105101: LD_INT 19
105103: PUSH
105104: LD_INT 20
105106: PUSH
105107: LD_INT 21
105109: PUSH
105110: LD_INT 22
105112: PUSH
105113: LD_INT 23
105115: PUSH
105116: LD_INT 24
105118: PUSH
105119: LD_INT 25
105121: PUSH
105122: LD_INT 26
105124: PUSH
105125: LD_INT 27
105127: PUSH
105128: LD_INT 28
105130: PUSH
105131: LD_INT 29
105133: PUSH
105134: LD_INT 30
105136: PUSH
105137: LD_INT 31
105139: PUSH
105140: LD_INT 32
105142: PUSH
105143: LD_INT 33
105145: PUSH
105146: LD_INT 34
105148: PUSH
105149: LD_INT 36
105151: PUSH
105152: EMPTY
105153: LIST
105154: LIST
105155: LIST
105156: LIST
105157: LIST
105158: LIST
105159: LIST
105160: LIST
105161: LIST
105162: LIST
105163: LIST
105164: LIST
105165: LIST
105166: LIST
105167: LIST
105168: LIST
105169: LIST
105170: LIST
105171: LIST
105172: LIST
105173: LIST
105174: LIST
105175: LIST
105176: LIST
105177: LIST
105178: LIST
105179: LIST
105180: LIST
105181: LIST
105182: LIST
105183: LIST
105184: LIST
105185: LIST
105186: LIST
105187: LIST
105188: PUSH
105189: LD_INT 101
105191: PUSH
105192: LD_INT 102
105194: PUSH
105195: LD_INT 103
105197: PUSH
105198: LD_INT 104
105200: PUSH
105201: LD_INT 105
105203: PUSH
105204: LD_INT 106
105206: PUSH
105207: LD_INT 107
105209: PUSH
105210: LD_INT 108
105212: PUSH
105213: LD_INT 109
105215: PUSH
105216: LD_INT 110
105218: PUSH
105219: LD_INT 111
105221: PUSH
105222: LD_INT 112
105224: PUSH
105225: LD_INT 113
105227: PUSH
105228: LD_INT 114
105230: PUSH
105231: EMPTY
105232: LIST
105233: LIST
105234: LIST
105235: LIST
105236: LIST
105237: LIST
105238: LIST
105239: LIST
105240: LIST
105241: LIST
105242: LIST
105243: LIST
105244: LIST
105245: LIST
105246: PUSH
105247: EMPTY
105248: LIST
105249: LIST
105250: ST_TO_ADDR
105251: GO 105978
105253: LD_INT 16
105255: DOUBLE
105256: EQUAL
105257: IFTRUE 105261
105259: GO 105385
105261: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
105262: LD_ADDR_VAR 0 1
105266: PUSH
105267: LD_INT 2
105269: PUSH
105270: LD_INT 4
105272: PUSH
105273: LD_INT 5
105275: PUSH
105276: LD_INT 7
105278: PUSH
105279: LD_INT 11
105281: PUSH
105282: LD_INT 12
105284: PUSH
105285: LD_INT 15
105287: PUSH
105288: LD_INT 16
105290: PUSH
105291: LD_INT 20
105293: PUSH
105294: LD_INT 21
105296: PUSH
105297: LD_INT 22
105299: PUSH
105300: LD_INT 23
105302: PUSH
105303: LD_INT 25
105305: PUSH
105306: LD_INT 26
105308: PUSH
105309: LD_INT 30
105311: PUSH
105312: LD_INT 31
105314: PUSH
105315: LD_INT 32
105317: PUSH
105318: LD_INT 33
105320: PUSH
105321: LD_INT 34
105323: PUSH
105324: EMPTY
105325: LIST
105326: LIST
105327: LIST
105328: LIST
105329: LIST
105330: LIST
105331: LIST
105332: LIST
105333: LIST
105334: LIST
105335: LIST
105336: LIST
105337: LIST
105338: LIST
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: LIST
105344: PUSH
105345: LD_INT 101
105347: PUSH
105348: LD_INT 102
105350: PUSH
105351: LD_INT 103
105353: PUSH
105354: LD_INT 106
105356: PUSH
105357: LD_INT 108
105359: PUSH
105360: LD_INT 112
105362: PUSH
105363: LD_INT 113
105365: PUSH
105366: LD_INT 114
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: LIST
105373: LIST
105374: LIST
105375: LIST
105376: LIST
105377: LIST
105378: PUSH
105379: EMPTY
105380: LIST
105381: LIST
105382: ST_TO_ADDR
105383: GO 105978
105385: LD_INT 17
105387: DOUBLE
105388: EQUAL
105389: IFTRUE 105393
105391: GO 105605
105393: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
105394: LD_ADDR_VAR 0 1
105398: PUSH
105399: LD_INT 1
105401: PUSH
105402: LD_INT 2
105404: PUSH
105405: LD_INT 3
105407: PUSH
105408: LD_INT 4
105410: PUSH
105411: LD_INT 5
105413: PUSH
105414: LD_INT 6
105416: PUSH
105417: LD_INT 7
105419: PUSH
105420: LD_INT 8
105422: PUSH
105423: LD_INT 9
105425: PUSH
105426: LD_INT 10
105428: PUSH
105429: LD_INT 11
105431: PUSH
105432: LD_INT 12
105434: PUSH
105435: LD_INT 13
105437: PUSH
105438: LD_INT 14
105440: PUSH
105441: LD_INT 15
105443: PUSH
105444: LD_INT 16
105446: PUSH
105447: LD_INT 17
105449: PUSH
105450: LD_INT 18
105452: PUSH
105453: LD_INT 19
105455: PUSH
105456: LD_INT 20
105458: PUSH
105459: LD_INT 21
105461: PUSH
105462: LD_INT 22
105464: PUSH
105465: LD_INT 23
105467: PUSH
105468: LD_INT 24
105470: PUSH
105471: LD_INT 25
105473: PUSH
105474: LD_INT 26
105476: PUSH
105477: LD_INT 27
105479: PUSH
105480: LD_INT 28
105482: PUSH
105483: LD_INT 29
105485: PUSH
105486: LD_INT 30
105488: PUSH
105489: LD_INT 31
105491: PUSH
105492: LD_INT 32
105494: PUSH
105495: LD_INT 33
105497: PUSH
105498: LD_INT 34
105500: PUSH
105501: LD_INT 36
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: LIST
105508: LIST
105509: LIST
105510: LIST
105511: LIST
105512: LIST
105513: LIST
105514: LIST
105515: LIST
105516: LIST
105517: LIST
105518: LIST
105519: LIST
105520: LIST
105521: LIST
105522: LIST
105523: LIST
105524: LIST
105525: LIST
105526: LIST
105527: LIST
105528: LIST
105529: LIST
105530: LIST
105531: LIST
105532: LIST
105533: LIST
105534: LIST
105535: LIST
105536: LIST
105537: LIST
105538: LIST
105539: LIST
105540: PUSH
105541: LD_INT 101
105543: PUSH
105544: LD_INT 102
105546: PUSH
105547: LD_INT 103
105549: PUSH
105550: LD_INT 104
105552: PUSH
105553: LD_INT 105
105555: PUSH
105556: LD_INT 106
105558: PUSH
105559: LD_INT 107
105561: PUSH
105562: LD_INT 108
105564: PUSH
105565: LD_INT 109
105567: PUSH
105568: LD_INT 110
105570: PUSH
105571: LD_INT 111
105573: PUSH
105574: LD_INT 112
105576: PUSH
105577: LD_INT 113
105579: PUSH
105580: LD_INT 114
105582: PUSH
105583: EMPTY
105584: LIST
105585: LIST
105586: LIST
105587: LIST
105588: LIST
105589: LIST
105590: LIST
105591: LIST
105592: LIST
105593: LIST
105594: LIST
105595: LIST
105596: LIST
105597: LIST
105598: PUSH
105599: EMPTY
105600: LIST
105601: LIST
105602: ST_TO_ADDR
105603: GO 105978
105605: LD_INT 18
105607: DOUBLE
105608: EQUAL
105609: IFTRUE 105613
105611: GO 105749
105613: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
105614: LD_ADDR_VAR 0 1
105618: PUSH
105619: LD_INT 2
105621: PUSH
105622: LD_INT 4
105624: PUSH
105625: LD_INT 5
105627: PUSH
105628: LD_INT 7
105630: PUSH
105631: LD_INT 11
105633: PUSH
105634: LD_INT 12
105636: PUSH
105637: LD_INT 15
105639: PUSH
105640: LD_INT 16
105642: PUSH
105643: LD_INT 20
105645: PUSH
105646: LD_INT 21
105648: PUSH
105649: LD_INT 22
105651: PUSH
105652: LD_INT 23
105654: PUSH
105655: LD_INT 25
105657: PUSH
105658: LD_INT 26
105660: PUSH
105661: LD_INT 30
105663: PUSH
105664: LD_INT 31
105666: PUSH
105667: LD_INT 32
105669: PUSH
105670: LD_INT 33
105672: PUSH
105673: LD_INT 34
105675: PUSH
105676: LD_INT 35
105678: PUSH
105679: LD_INT 36
105681: PUSH
105682: EMPTY
105683: LIST
105684: LIST
105685: LIST
105686: LIST
105687: LIST
105688: LIST
105689: LIST
105690: LIST
105691: LIST
105692: LIST
105693: LIST
105694: LIST
105695: LIST
105696: LIST
105697: LIST
105698: LIST
105699: LIST
105700: LIST
105701: LIST
105702: LIST
105703: LIST
105704: PUSH
105705: LD_INT 101
105707: PUSH
105708: LD_INT 102
105710: PUSH
105711: LD_INT 103
105713: PUSH
105714: LD_INT 106
105716: PUSH
105717: LD_INT 108
105719: PUSH
105720: LD_INT 112
105722: PUSH
105723: LD_INT 113
105725: PUSH
105726: LD_INT 114
105728: PUSH
105729: LD_INT 115
105731: PUSH
105732: EMPTY
105733: LIST
105734: LIST
105735: LIST
105736: LIST
105737: LIST
105738: LIST
105739: LIST
105740: LIST
105741: LIST
105742: PUSH
105743: EMPTY
105744: LIST
105745: LIST
105746: ST_TO_ADDR
105747: GO 105978
105749: LD_INT 19
105751: DOUBLE
105752: EQUAL
105753: IFTRUE 105757
105755: GO 105977
105757: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
105758: LD_ADDR_VAR 0 1
105762: PUSH
105763: LD_INT 1
105765: PUSH
105766: LD_INT 2
105768: PUSH
105769: LD_INT 3
105771: PUSH
105772: LD_INT 4
105774: PUSH
105775: LD_INT 5
105777: PUSH
105778: LD_INT 6
105780: PUSH
105781: LD_INT 7
105783: PUSH
105784: LD_INT 8
105786: PUSH
105787: LD_INT 9
105789: PUSH
105790: LD_INT 10
105792: PUSH
105793: LD_INT 11
105795: PUSH
105796: LD_INT 12
105798: PUSH
105799: LD_INT 13
105801: PUSH
105802: LD_INT 14
105804: PUSH
105805: LD_INT 15
105807: PUSH
105808: LD_INT 16
105810: PUSH
105811: LD_INT 17
105813: PUSH
105814: LD_INT 18
105816: PUSH
105817: LD_INT 19
105819: PUSH
105820: LD_INT 20
105822: PUSH
105823: LD_INT 21
105825: PUSH
105826: LD_INT 22
105828: PUSH
105829: LD_INT 23
105831: PUSH
105832: LD_INT 24
105834: PUSH
105835: LD_INT 25
105837: PUSH
105838: LD_INT 26
105840: PUSH
105841: LD_INT 27
105843: PUSH
105844: LD_INT 28
105846: PUSH
105847: LD_INT 29
105849: PUSH
105850: LD_INT 30
105852: PUSH
105853: LD_INT 31
105855: PUSH
105856: LD_INT 32
105858: PUSH
105859: LD_INT 33
105861: PUSH
105862: LD_INT 34
105864: PUSH
105865: LD_INT 35
105867: PUSH
105868: LD_INT 36
105870: PUSH
105871: EMPTY
105872: LIST
105873: LIST
105874: LIST
105875: LIST
105876: LIST
105877: LIST
105878: LIST
105879: LIST
105880: LIST
105881: LIST
105882: LIST
105883: LIST
105884: LIST
105885: LIST
105886: LIST
105887: LIST
105888: LIST
105889: LIST
105890: LIST
105891: LIST
105892: LIST
105893: LIST
105894: LIST
105895: LIST
105896: LIST
105897: LIST
105898: LIST
105899: LIST
105900: LIST
105901: LIST
105902: LIST
105903: LIST
105904: LIST
105905: LIST
105906: LIST
105907: LIST
105908: PUSH
105909: LD_INT 101
105911: PUSH
105912: LD_INT 102
105914: PUSH
105915: LD_INT 103
105917: PUSH
105918: LD_INT 104
105920: PUSH
105921: LD_INT 105
105923: PUSH
105924: LD_INT 106
105926: PUSH
105927: LD_INT 107
105929: PUSH
105930: LD_INT 108
105932: PUSH
105933: LD_INT 109
105935: PUSH
105936: LD_INT 110
105938: PUSH
105939: LD_INT 111
105941: PUSH
105942: LD_INT 112
105944: PUSH
105945: LD_INT 113
105947: PUSH
105948: LD_INT 114
105950: PUSH
105951: LD_INT 115
105953: PUSH
105954: EMPTY
105955: LIST
105956: LIST
105957: LIST
105958: LIST
105959: LIST
105960: LIST
105961: LIST
105962: LIST
105963: LIST
105964: LIST
105965: LIST
105966: LIST
105967: LIST
105968: LIST
105969: LIST
105970: PUSH
105971: EMPTY
105972: LIST
105973: LIST
105974: ST_TO_ADDR
105975: GO 105978
105977: POP
// end else
105978: GO 106197
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
105980: LD_ADDR_VAR 0 1
105984: PUSH
105985: LD_INT 1
105987: PUSH
105988: LD_INT 2
105990: PUSH
105991: LD_INT 3
105993: PUSH
105994: LD_INT 4
105996: PUSH
105997: LD_INT 5
105999: PUSH
106000: LD_INT 6
106002: PUSH
106003: LD_INT 7
106005: PUSH
106006: LD_INT 8
106008: PUSH
106009: LD_INT 9
106011: PUSH
106012: LD_INT 10
106014: PUSH
106015: LD_INT 11
106017: PUSH
106018: LD_INT 12
106020: PUSH
106021: LD_INT 13
106023: PUSH
106024: LD_INT 14
106026: PUSH
106027: LD_INT 15
106029: PUSH
106030: LD_INT 16
106032: PUSH
106033: LD_INT 17
106035: PUSH
106036: LD_INT 18
106038: PUSH
106039: LD_INT 19
106041: PUSH
106042: LD_INT 20
106044: PUSH
106045: LD_INT 21
106047: PUSH
106048: LD_INT 22
106050: PUSH
106051: LD_INT 23
106053: PUSH
106054: LD_INT 24
106056: PUSH
106057: LD_INT 25
106059: PUSH
106060: LD_INT 26
106062: PUSH
106063: LD_INT 27
106065: PUSH
106066: LD_INT 28
106068: PUSH
106069: LD_INT 29
106071: PUSH
106072: LD_INT 30
106074: PUSH
106075: LD_INT 31
106077: PUSH
106078: LD_INT 32
106080: PUSH
106081: LD_INT 33
106083: PUSH
106084: LD_INT 34
106086: PUSH
106087: LD_INT 35
106089: PUSH
106090: LD_INT 36
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: LIST
106097: LIST
106098: LIST
106099: LIST
106100: LIST
106101: LIST
106102: LIST
106103: LIST
106104: LIST
106105: LIST
106106: LIST
106107: LIST
106108: LIST
106109: LIST
106110: LIST
106111: LIST
106112: LIST
106113: LIST
106114: LIST
106115: LIST
106116: LIST
106117: LIST
106118: LIST
106119: LIST
106120: LIST
106121: LIST
106122: LIST
106123: LIST
106124: LIST
106125: LIST
106126: LIST
106127: LIST
106128: LIST
106129: LIST
106130: PUSH
106131: LD_INT 101
106133: PUSH
106134: LD_INT 102
106136: PUSH
106137: LD_INT 103
106139: PUSH
106140: LD_INT 104
106142: PUSH
106143: LD_INT 105
106145: PUSH
106146: LD_INT 106
106148: PUSH
106149: LD_INT 107
106151: PUSH
106152: LD_INT 108
106154: PUSH
106155: LD_INT 109
106157: PUSH
106158: LD_INT 110
106160: PUSH
106161: LD_INT 111
106163: PUSH
106164: LD_INT 112
106166: PUSH
106167: LD_INT 113
106169: PUSH
106170: LD_INT 114
106172: PUSH
106173: LD_INT 115
106175: PUSH
106176: EMPTY
106177: LIST
106178: LIST
106179: LIST
106180: LIST
106181: LIST
106182: LIST
106183: LIST
106184: LIST
106185: LIST
106186: LIST
106187: LIST
106188: LIST
106189: LIST
106190: LIST
106191: LIST
106192: PUSH
106193: EMPTY
106194: LIST
106195: LIST
106196: ST_TO_ADDR
// if result then
106197: LD_VAR 0 1
106201: IFFALSE 106490
// begin normal :=  ;
106203: LD_ADDR_VAR 0 3
106207: PUSH
106208: LD_STRING 
106210: ST_TO_ADDR
// hardcore :=  ;
106211: LD_ADDR_VAR 0 4
106215: PUSH
106216: LD_STRING 
106218: ST_TO_ADDR
// for i = 1 to normalCounter do
106219: LD_ADDR_VAR 0 5
106223: PUSH
106224: DOUBLE
106225: LD_INT 1
106227: DEC
106228: ST_TO_ADDR
106229: LD_EXP 156
106233: PUSH
106234: FOR_TO
106235: IFFALSE 106336
// begin tmp := 0 ;
106237: LD_ADDR_VAR 0 2
106241: PUSH
106242: LD_STRING 0
106244: ST_TO_ADDR
// if result [ 1 ] then
106245: LD_VAR 0 1
106249: PUSH
106250: LD_INT 1
106252: ARRAY
106253: IFFALSE 106318
// if result [ 1 ] [ 1 ] = i then
106255: LD_VAR 0 1
106259: PUSH
106260: LD_INT 1
106262: ARRAY
106263: PUSH
106264: LD_INT 1
106266: ARRAY
106267: PUSH
106268: LD_VAR 0 5
106272: EQUAL
106273: IFFALSE 106318
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
106275: LD_ADDR_VAR 0 1
106279: PUSH
106280: LD_VAR 0 1
106284: PPUSH
106285: LD_INT 1
106287: PPUSH
106288: LD_VAR 0 1
106292: PUSH
106293: LD_INT 1
106295: ARRAY
106296: PPUSH
106297: LD_INT 1
106299: PPUSH
106300: CALL_OW 3
106304: PPUSH
106305: CALL_OW 1
106309: ST_TO_ADDR
// tmp := 1 ;
106310: LD_ADDR_VAR 0 2
106314: PUSH
106315: LD_STRING 1
106317: ST_TO_ADDR
// end ; normal := normal & tmp ;
106318: LD_ADDR_VAR 0 3
106322: PUSH
106323: LD_VAR 0 3
106327: PUSH
106328: LD_VAR 0 2
106332: STR
106333: ST_TO_ADDR
// end ;
106334: GO 106234
106336: POP
106337: POP
// for i = 1 to hardcoreCounter do
106338: LD_ADDR_VAR 0 5
106342: PUSH
106343: DOUBLE
106344: LD_INT 1
106346: DEC
106347: ST_TO_ADDR
106348: LD_EXP 157
106352: PUSH
106353: FOR_TO
106354: IFFALSE 106459
// begin tmp := 0 ;
106356: LD_ADDR_VAR 0 2
106360: PUSH
106361: LD_STRING 0
106363: ST_TO_ADDR
// if result [ 2 ] then
106364: LD_VAR 0 1
106368: PUSH
106369: LD_INT 2
106371: ARRAY
106372: IFFALSE 106441
// if result [ 2 ] [ 1 ] = 100 + i then
106374: LD_VAR 0 1
106378: PUSH
106379: LD_INT 2
106381: ARRAY
106382: PUSH
106383: LD_INT 1
106385: ARRAY
106386: PUSH
106387: LD_INT 100
106389: PUSH
106390: LD_VAR 0 5
106394: PLUS
106395: EQUAL
106396: IFFALSE 106441
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
106398: LD_ADDR_VAR 0 1
106402: PUSH
106403: LD_VAR 0 1
106407: PPUSH
106408: LD_INT 2
106410: PPUSH
106411: LD_VAR 0 1
106415: PUSH
106416: LD_INT 2
106418: ARRAY
106419: PPUSH
106420: LD_INT 1
106422: PPUSH
106423: CALL_OW 3
106427: PPUSH
106428: CALL_OW 1
106432: ST_TO_ADDR
// tmp := 1 ;
106433: LD_ADDR_VAR 0 2
106437: PUSH
106438: LD_STRING 1
106440: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
106441: LD_ADDR_VAR 0 4
106445: PUSH
106446: LD_VAR 0 4
106450: PUSH
106451: LD_VAR 0 2
106455: STR
106456: ST_TO_ADDR
// end ;
106457: GO 106353
106459: POP
106460: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
106461: LD_STRING getStreamItemsFromMission("
106463: PUSH
106464: LD_VAR 0 3
106468: STR
106469: PUSH
106470: LD_STRING ","
106472: STR
106473: PUSH
106474: LD_VAR 0 4
106478: STR
106479: PUSH
106480: LD_STRING ")
106482: STR
106483: PPUSH
106484: CALL_OW 559
// end else
106488: GO 106497
// ToLua ( getStreamItemsFromMission("","") ) ;
106490: LD_STRING getStreamItemsFromMission("","")
106492: PPUSH
106493: CALL_OW 559
// end ;
106497: LD_VAR 0 1
106501: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
106502: LD_EXP 155
106506: PUSH
106507: LD_EXP 160
106511: AND
106512: IFFALSE 106636
106514: GO 106516
106516: DISABLE
106517: LD_INT 0
106519: PPUSH
106520: PPUSH
// begin enable ;
106521: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
106522: LD_ADDR_VAR 0 2
106526: PUSH
106527: LD_INT 22
106529: PUSH
106530: LD_OWVAR 2
106534: PUSH
106535: EMPTY
106536: LIST
106537: LIST
106538: PUSH
106539: LD_INT 2
106541: PUSH
106542: LD_INT 34
106544: PUSH
106545: LD_INT 7
106547: PUSH
106548: EMPTY
106549: LIST
106550: LIST
106551: PUSH
106552: LD_INT 34
106554: PUSH
106555: LD_INT 45
106557: PUSH
106558: EMPTY
106559: LIST
106560: LIST
106561: PUSH
106562: LD_INT 34
106564: PUSH
106565: LD_INT 28
106567: PUSH
106568: EMPTY
106569: LIST
106570: LIST
106571: PUSH
106572: LD_INT 34
106574: PUSH
106575: LD_INT 47
106577: PUSH
106578: EMPTY
106579: LIST
106580: LIST
106581: PUSH
106582: EMPTY
106583: LIST
106584: LIST
106585: LIST
106586: LIST
106587: LIST
106588: PUSH
106589: EMPTY
106590: LIST
106591: LIST
106592: PPUSH
106593: CALL_OW 69
106597: ST_TO_ADDR
// if not tmp then
106598: LD_VAR 0 2
106602: NOT
106603: IFFALSE 106607
// exit ;
106605: GO 106636
// for i in tmp do
106607: LD_ADDR_VAR 0 1
106611: PUSH
106612: LD_VAR 0 2
106616: PUSH
106617: FOR_IN
106618: IFFALSE 106634
// begin SetLives ( i , 0 ) ;
106620: LD_VAR 0 1
106624: PPUSH
106625: LD_INT 0
106627: PPUSH
106628: CALL_OW 234
// end ;
106632: GO 106617
106634: POP
106635: POP
// end ;
106636: PPOPN 2
106638: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106639: LD_EXP 155
106643: PUSH
106644: LD_EXP 161
106648: AND
106649: IFFALSE 106733
106651: GO 106653
106653: DISABLE
106654: LD_INT 0
106656: PPUSH
106657: PPUSH
// begin enable ;
106658: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106659: LD_ADDR_VAR 0 2
106663: PUSH
106664: LD_INT 22
106666: PUSH
106667: LD_OWVAR 2
106671: PUSH
106672: EMPTY
106673: LIST
106674: LIST
106675: PUSH
106676: LD_INT 32
106678: PUSH
106679: LD_INT 3
106681: PUSH
106682: EMPTY
106683: LIST
106684: LIST
106685: PUSH
106686: EMPTY
106687: LIST
106688: LIST
106689: PPUSH
106690: CALL_OW 69
106694: ST_TO_ADDR
// if not tmp then
106695: LD_VAR 0 2
106699: NOT
106700: IFFALSE 106704
// exit ;
106702: GO 106733
// for i in tmp do
106704: LD_ADDR_VAR 0 1
106708: PUSH
106709: LD_VAR 0 2
106713: PUSH
106714: FOR_IN
106715: IFFALSE 106731
// begin SetLives ( i , 0 ) ;
106717: LD_VAR 0 1
106721: PPUSH
106722: LD_INT 0
106724: PPUSH
106725: CALL_OW 234
// end ;
106729: GO 106714
106731: POP
106732: POP
// end ;
106733: PPOPN 2
106735: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106736: LD_EXP 155
106740: PUSH
106741: LD_EXP 158
106745: AND
106746: IFFALSE 106839
106748: GO 106750
106750: DISABLE
106751: LD_INT 0
106753: PPUSH
// begin enable ;
106754: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106755: LD_ADDR_VAR 0 1
106759: PUSH
106760: LD_INT 22
106762: PUSH
106763: LD_OWVAR 2
106767: PUSH
106768: EMPTY
106769: LIST
106770: LIST
106771: PUSH
106772: LD_INT 2
106774: PUSH
106775: LD_INT 25
106777: PUSH
106778: LD_INT 5
106780: PUSH
106781: EMPTY
106782: LIST
106783: LIST
106784: PUSH
106785: LD_INT 25
106787: PUSH
106788: LD_INT 9
106790: PUSH
106791: EMPTY
106792: LIST
106793: LIST
106794: PUSH
106795: LD_INT 25
106797: PUSH
106798: LD_INT 8
106800: PUSH
106801: EMPTY
106802: LIST
106803: LIST
106804: PUSH
106805: EMPTY
106806: LIST
106807: LIST
106808: LIST
106809: LIST
106810: PUSH
106811: EMPTY
106812: LIST
106813: LIST
106814: PPUSH
106815: CALL_OW 69
106819: PUSH
106820: FOR_IN
106821: IFFALSE 106837
// begin SetClass ( i , 1 ) ;
106823: LD_VAR 0 1
106827: PPUSH
106828: LD_INT 1
106830: PPUSH
106831: CALL_OW 336
// end ;
106835: GO 106820
106837: POP
106838: POP
// end ;
106839: PPOPN 1
106841: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106842: LD_EXP 155
106846: PUSH
106847: LD_EXP 159
106851: AND
106852: PUSH
106853: LD_OWVAR 65
106857: PUSH
106858: LD_INT 7
106860: LESS
106861: AND
106862: IFFALSE 106876
106864: GO 106866
106866: DISABLE
// begin enable ;
106867: ENABLE
// game_speed := 7 ;
106868: LD_ADDR_OWVAR 65
106872: PUSH
106873: LD_INT 7
106875: ST_TO_ADDR
// end ;
106876: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106877: LD_EXP 155
106881: PUSH
106882: LD_EXP 162
106886: AND
106887: IFFALSE 107089
106889: GO 106891
106891: DISABLE
106892: LD_INT 0
106894: PPUSH
106895: PPUSH
106896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106897: LD_ADDR_VAR 0 3
106901: PUSH
106902: LD_INT 81
106904: PUSH
106905: LD_OWVAR 2
106909: PUSH
106910: EMPTY
106911: LIST
106912: LIST
106913: PUSH
106914: LD_INT 21
106916: PUSH
106917: LD_INT 1
106919: PUSH
106920: EMPTY
106921: LIST
106922: LIST
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: PPUSH
106928: CALL_OW 69
106932: ST_TO_ADDR
// if not tmp then
106933: LD_VAR 0 3
106937: NOT
106938: IFFALSE 106942
// exit ;
106940: GO 107089
// if tmp > 5 then
106942: LD_VAR 0 3
106946: PUSH
106947: LD_INT 5
106949: GREATER
106950: IFFALSE 106962
// k := 5 else
106952: LD_ADDR_VAR 0 2
106956: PUSH
106957: LD_INT 5
106959: ST_TO_ADDR
106960: GO 106972
// k := tmp ;
106962: LD_ADDR_VAR 0 2
106966: PUSH
106967: LD_VAR 0 3
106971: ST_TO_ADDR
// for i := 1 to k do
106972: LD_ADDR_VAR 0 1
106976: PUSH
106977: DOUBLE
106978: LD_INT 1
106980: DEC
106981: ST_TO_ADDR
106982: LD_VAR 0 2
106986: PUSH
106987: FOR_TO
106988: IFFALSE 107087
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106990: LD_VAR 0 3
106994: PUSH
106995: LD_VAR 0 1
106999: ARRAY
107000: PPUSH
107001: LD_VAR 0 1
107005: PUSH
107006: LD_INT 4
107008: MOD
107009: PUSH
107010: LD_INT 1
107012: PLUS
107013: PPUSH
107014: CALL_OW 259
107018: PUSH
107019: LD_INT 10
107021: LESS
107022: IFFALSE 107085
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
107024: LD_VAR 0 3
107028: PUSH
107029: LD_VAR 0 1
107033: ARRAY
107034: PPUSH
107035: LD_VAR 0 1
107039: PUSH
107040: LD_INT 4
107042: MOD
107043: PUSH
107044: LD_INT 1
107046: PLUS
107047: PPUSH
107048: LD_VAR 0 3
107052: PUSH
107053: LD_VAR 0 1
107057: ARRAY
107058: PPUSH
107059: LD_VAR 0 1
107063: PUSH
107064: LD_INT 4
107066: MOD
107067: PUSH
107068: LD_INT 1
107070: PLUS
107071: PPUSH
107072: CALL_OW 259
107076: PUSH
107077: LD_INT 1
107079: PLUS
107080: PPUSH
107081: CALL_OW 237
107085: GO 106987
107087: POP
107088: POP
// end ;
107089: PPOPN 3
107091: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
107092: LD_EXP 155
107096: PUSH
107097: LD_EXP 163
107101: AND
107102: IFFALSE 107122
107104: GO 107106
107106: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
107107: LD_INT 4
107109: PPUSH
107110: LD_OWVAR 2
107114: PPUSH
107115: LD_INT 0
107117: PPUSH
107118: CALL_OW 324
107122: END
// every 0 0$1 trigger StreamModeActive and sShovel do
107123: LD_EXP 155
107127: PUSH
107128: LD_EXP 192
107132: AND
107133: IFFALSE 107153
107135: GO 107137
107137: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
107138: LD_INT 19
107140: PPUSH
107141: LD_OWVAR 2
107145: PPUSH
107146: LD_INT 0
107148: PPUSH
107149: CALL_OW 324
107153: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
107154: LD_EXP 155
107158: PUSH
107159: LD_EXP 164
107163: AND
107164: IFFALSE 107266
107166: GO 107168
107168: DISABLE
107169: LD_INT 0
107171: PPUSH
107172: PPUSH
// begin enable ;
107173: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
107174: LD_ADDR_VAR 0 2
107178: PUSH
107179: LD_INT 22
107181: PUSH
107182: LD_OWVAR 2
107186: PUSH
107187: EMPTY
107188: LIST
107189: LIST
107190: PUSH
107191: LD_INT 2
107193: PUSH
107194: LD_INT 34
107196: PUSH
107197: LD_INT 11
107199: PUSH
107200: EMPTY
107201: LIST
107202: LIST
107203: PUSH
107204: LD_INT 34
107206: PUSH
107207: LD_INT 30
107209: PUSH
107210: EMPTY
107211: LIST
107212: LIST
107213: PUSH
107214: EMPTY
107215: LIST
107216: LIST
107217: LIST
107218: PUSH
107219: EMPTY
107220: LIST
107221: LIST
107222: PPUSH
107223: CALL_OW 69
107227: ST_TO_ADDR
// if not tmp then
107228: LD_VAR 0 2
107232: NOT
107233: IFFALSE 107237
// exit ;
107235: GO 107266
// for i in tmp do
107237: LD_ADDR_VAR 0 1
107241: PUSH
107242: LD_VAR 0 2
107246: PUSH
107247: FOR_IN
107248: IFFALSE 107264
// begin SetLives ( i , 0 ) ;
107250: LD_VAR 0 1
107254: PPUSH
107255: LD_INT 0
107257: PPUSH
107258: CALL_OW 234
// end ;
107262: GO 107247
107264: POP
107265: POP
// end ;
107266: PPOPN 2
107268: END
// every 0 0$1 trigger StreamModeActive and sBunker do
107269: LD_EXP 155
107273: PUSH
107274: LD_EXP 165
107278: AND
107279: IFFALSE 107299
107281: GO 107283
107283: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
107284: LD_INT 32
107286: PPUSH
107287: LD_OWVAR 2
107291: PPUSH
107292: LD_INT 0
107294: PPUSH
107295: CALL_OW 324
107299: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
107300: LD_EXP 155
107304: PUSH
107305: LD_EXP 166
107309: AND
107310: IFFALSE 107491
107312: GO 107314
107314: DISABLE
107315: LD_INT 0
107317: PPUSH
107318: PPUSH
107319: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
107320: LD_ADDR_VAR 0 2
107324: PUSH
107325: LD_INT 22
107327: PUSH
107328: LD_OWVAR 2
107332: PUSH
107333: EMPTY
107334: LIST
107335: LIST
107336: PUSH
107337: LD_INT 33
107339: PUSH
107340: LD_INT 3
107342: PUSH
107343: EMPTY
107344: LIST
107345: LIST
107346: PUSH
107347: EMPTY
107348: LIST
107349: LIST
107350: PPUSH
107351: CALL_OW 69
107355: ST_TO_ADDR
// if not tmp then
107356: LD_VAR 0 2
107360: NOT
107361: IFFALSE 107365
// exit ;
107363: GO 107491
// side := 0 ;
107365: LD_ADDR_VAR 0 3
107369: PUSH
107370: LD_INT 0
107372: ST_TO_ADDR
// for i := 1 to 8 do
107373: LD_ADDR_VAR 0 1
107377: PUSH
107378: DOUBLE
107379: LD_INT 1
107381: DEC
107382: ST_TO_ADDR
107383: LD_INT 8
107385: PUSH
107386: FOR_TO
107387: IFFALSE 107435
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
107389: LD_OWVAR 2
107393: PUSH
107394: LD_VAR 0 1
107398: NONEQUAL
107399: PUSH
107400: LD_OWVAR 2
107404: PPUSH
107405: LD_VAR 0 1
107409: PPUSH
107410: CALL_OW 81
107414: PUSH
107415: LD_INT 2
107417: EQUAL
107418: AND
107419: IFFALSE 107433
// begin side := i ;
107421: LD_ADDR_VAR 0 3
107425: PUSH
107426: LD_VAR 0 1
107430: ST_TO_ADDR
// break ;
107431: GO 107435
// end ;
107433: GO 107386
107435: POP
107436: POP
// if not side then
107437: LD_VAR 0 3
107441: NOT
107442: IFFALSE 107446
// exit ;
107444: GO 107491
// for i := 1 to tmp do
107446: LD_ADDR_VAR 0 1
107450: PUSH
107451: DOUBLE
107452: LD_INT 1
107454: DEC
107455: ST_TO_ADDR
107456: LD_VAR 0 2
107460: PUSH
107461: FOR_TO
107462: IFFALSE 107489
// if Prob ( 60 ) then
107464: LD_INT 60
107466: PPUSH
107467: CALL_OW 13
107471: IFFALSE 107487
// SetSide ( i , side ) ;
107473: LD_VAR 0 1
107477: PPUSH
107478: LD_VAR 0 3
107482: PPUSH
107483: CALL_OW 235
107487: GO 107461
107489: POP
107490: POP
// end ;
107491: PPOPN 3
107493: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
107494: LD_EXP 155
107498: PUSH
107499: LD_EXP 168
107503: AND
107504: IFFALSE 107623
107506: GO 107508
107508: DISABLE
107509: LD_INT 0
107511: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
107512: LD_ADDR_VAR 0 1
107516: PUSH
107517: LD_INT 22
107519: PUSH
107520: LD_OWVAR 2
107524: PUSH
107525: EMPTY
107526: LIST
107527: LIST
107528: PUSH
107529: LD_INT 21
107531: PUSH
107532: LD_INT 1
107534: PUSH
107535: EMPTY
107536: LIST
107537: LIST
107538: PUSH
107539: LD_INT 3
107541: PUSH
107542: LD_INT 23
107544: PUSH
107545: LD_INT 0
107547: PUSH
107548: EMPTY
107549: LIST
107550: LIST
107551: PUSH
107552: EMPTY
107553: LIST
107554: LIST
107555: PUSH
107556: EMPTY
107557: LIST
107558: LIST
107559: LIST
107560: PPUSH
107561: CALL_OW 69
107565: PUSH
107566: FOR_IN
107567: IFFALSE 107621
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107569: LD_VAR 0 1
107573: PPUSH
107574: CALL_OW 257
107578: PUSH
107579: LD_INT 1
107581: PUSH
107582: LD_INT 2
107584: PUSH
107585: LD_INT 3
107587: PUSH
107588: LD_INT 4
107590: PUSH
107591: EMPTY
107592: LIST
107593: LIST
107594: LIST
107595: LIST
107596: IN
107597: IFFALSE 107619
// SetClass ( un , rand ( 1 , 4 ) ) ;
107599: LD_VAR 0 1
107603: PPUSH
107604: LD_INT 1
107606: PPUSH
107607: LD_INT 4
107609: PPUSH
107610: CALL_OW 12
107614: PPUSH
107615: CALL_OW 336
107619: GO 107566
107621: POP
107622: POP
// end ;
107623: PPOPN 1
107625: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107626: LD_EXP 155
107630: PUSH
107631: LD_EXP 167
107635: AND
107636: IFFALSE 107715
107638: GO 107640
107640: DISABLE
107641: LD_INT 0
107643: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107644: LD_ADDR_VAR 0 1
107648: PUSH
107649: LD_INT 22
107651: PUSH
107652: LD_OWVAR 2
107656: PUSH
107657: EMPTY
107658: LIST
107659: LIST
107660: PUSH
107661: LD_INT 21
107663: PUSH
107664: LD_INT 3
107666: PUSH
107667: EMPTY
107668: LIST
107669: LIST
107670: PUSH
107671: EMPTY
107672: LIST
107673: LIST
107674: PPUSH
107675: CALL_OW 69
107679: ST_TO_ADDR
// if not tmp then
107680: LD_VAR 0 1
107684: NOT
107685: IFFALSE 107689
// exit ;
107687: GO 107715
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107689: LD_VAR 0 1
107693: PUSH
107694: LD_INT 1
107696: PPUSH
107697: LD_VAR 0 1
107701: PPUSH
107702: CALL_OW 12
107706: ARRAY
107707: PPUSH
107708: LD_INT 100
107710: PPUSH
107711: CALL_OW 234
// end ;
107715: PPOPN 1
107717: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107718: LD_EXP 155
107722: PUSH
107723: LD_EXP 169
107727: AND
107728: IFFALSE 107826
107730: GO 107732
107732: DISABLE
107733: LD_INT 0
107735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107736: LD_ADDR_VAR 0 1
107740: PUSH
107741: LD_INT 22
107743: PUSH
107744: LD_OWVAR 2
107748: PUSH
107749: EMPTY
107750: LIST
107751: LIST
107752: PUSH
107753: LD_INT 21
107755: PUSH
107756: LD_INT 1
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: PUSH
107763: EMPTY
107764: LIST
107765: LIST
107766: PPUSH
107767: CALL_OW 69
107771: ST_TO_ADDR
// if not tmp then
107772: LD_VAR 0 1
107776: NOT
107777: IFFALSE 107781
// exit ;
107779: GO 107826
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107781: LD_VAR 0 1
107785: PUSH
107786: LD_INT 1
107788: PPUSH
107789: LD_VAR 0 1
107793: PPUSH
107794: CALL_OW 12
107798: ARRAY
107799: PPUSH
107800: LD_INT 1
107802: PPUSH
107803: LD_INT 4
107805: PPUSH
107806: CALL_OW 12
107810: PPUSH
107811: LD_INT 3000
107813: PPUSH
107814: LD_INT 9000
107816: PPUSH
107817: CALL_OW 12
107821: PPUSH
107822: CALL_OW 492
// end ;
107826: PPOPN 1
107828: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107829: LD_EXP 155
107833: PUSH
107834: LD_EXP 170
107838: AND
107839: IFFALSE 107859
107841: GO 107843
107843: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107844: LD_INT 1
107846: PPUSH
107847: LD_OWVAR 2
107851: PPUSH
107852: LD_INT 0
107854: PPUSH
107855: CALL_OW 324
107859: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107860: LD_EXP 155
107864: PUSH
107865: LD_EXP 171
107869: AND
107870: IFFALSE 107953
107872: GO 107874
107874: DISABLE
107875: LD_INT 0
107877: PPUSH
107878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107879: LD_ADDR_VAR 0 2
107883: PUSH
107884: LD_INT 22
107886: PUSH
107887: LD_OWVAR 2
107891: PUSH
107892: EMPTY
107893: LIST
107894: LIST
107895: PUSH
107896: LD_INT 21
107898: PUSH
107899: LD_INT 3
107901: PUSH
107902: EMPTY
107903: LIST
107904: LIST
107905: PUSH
107906: EMPTY
107907: LIST
107908: LIST
107909: PPUSH
107910: CALL_OW 69
107914: ST_TO_ADDR
// if not tmp then
107915: LD_VAR 0 2
107919: NOT
107920: IFFALSE 107924
// exit ;
107922: GO 107953
// for i in tmp do
107924: LD_ADDR_VAR 0 1
107928: PUSH
107929: LD_VAR 0 2
107933: PUSH
107934: FOR_IN
107935: IFFALSE 107951
// SetBLevel ( i , 10 ) ;
107937: LD_VAR 0 1
107941: PPUSH
107942: LD_INT 10
107944: PPUSH
107945: CALL_OW 241
107949: GO 107934
107951: POP
107952: POP
// end ;
107953: PPOPN 2
107955: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107956: LD_EXP 155
107960: PUSH
107961: LD_EXP 172
107965: AND
107966: IFFALSE 108077
107968: GO 107970
107970: DISABLE
107971: LD_INT 0
107973: PPUSH
107974: PPUSH
107975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107976: LD_ADDR_VAR 0 3
107980: PUSH
107981: LD_INT 22
107983: PUSH
107984: LD_OWVAR 2
107988: PUSH
107989: EMPTY
107990: LIST
107991: LIST
107992: PUSH
107993: LD_INT 25
107995: PUSH
107996: LD_INT 1
107998: PUSH
107999: EMPTY
108000: LIST
108001: LIST
108002: PUSH
108003: EMPTY
108004: LIST
108005: LIST
108006: PPUSH
108007: CALL_OW 69
108011: ST_TO_ADDR
// if not tmp then
108012: LD_VAR 0 3
108016: NOT
108017: IFFALSE 108021
// exit ;
108019: GO 108077
// un := tmp [ rand ( 1 , tmp ) ] ;
108021: LD_ADDR_VAR 0 2
108025: PUSH
108026: LD_VAR 0 3
108030: PUSH
108031: LD_INT 1
108033: PPUSH
108034: LD_VAR 0 3
108038: PPUSH
108039: CALL_OW 12
108043: ARRAY
108044: ST_TO_ADDR
// if Crawls ( un ) then
108045: LD_VAR 0 2
108049: PPUSH
108050: CALL_OW 318
108054: IFFALSE 108065
// ComWalk ( un ) ;
108056: LD_VAR 0 2
108060: PPUSH
108061: CALL_OW 138
// SetClass ( un , class_sniper ) ;
108065: LD_VAR 0 2
108069: PPUSH
108070: LD_INT 5
108072: PPUSH
108073: CALL_OW 336
// end ;
108077: PPOPN 3
108079: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
108080: LD_EXP 155
108084: PUSH
108085: LD_EXP 173
108089: AND
108090: PUSH
108091: LD_OWVAR 67
108095: PUSH
108096: LD_INT 3
108098: LESS
108099: AND
108100: IFFALSE 108119
108102: GO 108104
108104: DISABLE
// Difficulty := Difficulty + 1 ;
108105: LD_ADDR_OWVAR 67
108109: PUSH
108110: LD_OWVAR 67
108114: PUSH
108115: LD_INT 1
108117: PLUS
108118: ST_TO_ADDR
108119: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
108120: LD_EXP 155
108124: PUSH
108125: LD_EXP 174
108129: AND
108130: IFFALSE 108233
108132: GO 108134
108134: DISABLE
108135: LD_INT 0
108137: PPUSH
// begin for i := 1 to 5 do
108138: LD_ADDR_VAR 0 1
108142: PUSH
108143: DOUBLE
108144: LD_INT 1
108146: DEC
108147: ST_TO_ADDR
108148: LD_INT 5
108150: PUSH
108151: FOR_TO
108152: IFFALSE 108231
// begin uc_nation := nation_nature ;
108154: LD_ADDR_OWVAR 21
108158: PUSH
108159: LD_INT 0
108161: ST_TO_ADDR
// uc_side := 0 ;
108162: LD_ADDR_OWVAR 20
108166: PUSH
108167: LD_INT 0
108169: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108170: LD_ADDR_OWVAR 29
108174: PUSH
108175: LD_INT 12
108177: PUSH
108178: LD_INT 12
108180: PUSH
108181: EMPTY
108182: LIST
108183: LIST
108184: ST_TO_ADDR
// hc_agressivity := 20 ;
108185: LD_ADDR_OWVAR 35
108189: PUSH
108190: LD_INT 20
108192: ST_TO_ADDR
// hc_class := class_tiger ;
108193: LD_ADDR_OWVAR 28
108197: PUSH
108198: LD_INT 14
108200: ST_TO_ADDR
// hc_gallery :=  ;
108201: LD_ADDR_OWVAR 33
108205: PUSH
108206: LD_STRING 
108208: ST_TO_ADDR
// hc_name :=  ;
108209: LD_ADDR_OWVAR 26
108213: PUSH
108214: LD_STRING 
108216: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
108217: CALL_OW 44
108221: PPUSH
108222: LD_INT 0
108224: PPUSH
108225: CALL_OW 51
// end ;
108229: GO 108151
108231: POP
108232: POP
// end ;
108233: PPOPN 1
108235: END
// every 0 0$1 trigger StreamModeActive and sBomb do
108236: LD_EXP 155
108240: PUSH
108241: LD_EXP 175
108245: AND
108246: IFFALSE 108255
108248: GO 108250
108250: DISABLE
// StreamSibBomb ;
108251: CALL 108256 0 0
108255: END
// export function StreamSibBomb ; var i , x , y ; begin
108256: LD_INT 0
108258: PPUSH
108259: PPUSH
108260: PPUSH
108261: PPUSH
// result := false ;
108262: LD_ADDR_VAR 0 1
108266: PUSH
108267: LD_INT 0
108269: ST_TO_ADDR
// for i := 1 to 16 do
108270: LD_ADDR_VAR 0 2
108274: PUSH
108275: DOUBLE
108276: LD_INT 1
108278: DEC
108279: ST_TO_ADDR
108280: LD_INT 16
108282: PUSH
108283: FOR_TO
108284: IFFALSE 108483
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108286: LD_ADDR_VAR 0 3
108290: PUSH
108291: LD_INT 10
108293: PUSH
108294: LD_INT 20
108296: PUSH
108297: LD_INT 30
108299: PUSH
108300: LD_INT 40
108302: PUSH
108303: LD_INT 50
108305: PUSH
108306: LD_INT 60
108308: PUSH
108309: LD_INT 70
108311: PUSH
108312: LD_INT 80
108314: PUSH
108315: LD_INT 90
108317: PUSH
108318: LD_INT 100
108320: PUSH
108321: LD_INT 110
108323: PUSH
108324: LD_INT 120
108326: PUSH
108327: LD_INT 130
108329: PUSH
108330: LD_INT 140
108332: PUSH
108333: LD_INT 150
108335: PUSH
108336: EMPTY
108337: LIST
108338: LIST
108339: LIST
108340: LIST
108341: LIST
108342: LIST
108343: LIST
108344: LIST
108345: LIST
108346: LIST
108347: LIST
108348: LIST
108349: LIST
108350: LIST
108351: LIST
108352: PUSH
108353: LD_INT 1
108355: PPUSH
108356: LD_INT 15
108358: PPUSH
108359: CALL_OW 12
108363: ARRAY
108364: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
108365: LD_ADDR_VAR 0 4
108369: PUSH
108370: LD_INT 10
108372: PUSH
108373: LD_INT 20
108375: PUSH
108376: LD_INT 30
108378: PUSH
108379: LD_INT 40
108381: PUSH
108382: LD_INT 50
108384: PUSH
108385: LD_INT 60
108387: PUSH
108388: LD_INT 70
108390: PUSH
108391: LD_INT 80
108393: PUSH
108394: LD_INT 90
108396: PUSH
108397: LD_INT 100
108399: PUSH
108400: LD_INT 110
108402: PUSH
108403: LD_INT 120
108405: PUSH
108406: LD_INT 130
108408: PUSH
108409: LD_INT 140
108411: PUSH
108412: LD_INT 150
108414: PUSH
108415: EMPTY
108416: LIST
108417: LIST
108418: LIST
108419: LIST
108420: LIST
108421: LIST
108422: LIST
108423: LIST
108424: LIST
108425: LIST
108426: LIST
108427: LIST
108428: LIST
108429: LIST
108430: LIST
108431: PUSH
108432: LD_INT 1
108434: PPUSH
108435: LD_INT 15
108437: PPUSH
108438: CALL_OW 12
108442: ARRAY
108443: ST_TO_ADDR
// if ValidHex ( x , y ) then
108444: LD_VAR 0 3
108448: PPUSH
108449: LD_VAR 0 4
108453: PPUSH
108454: CALL_OW 488
108458: IFFALSE 108481
// begin result := [ x , y ] ;
108460: LD_ADDR_VAR 0 1
108464: PUSH
108465: LD_VAR 0 3
108469: PUSH
108470: LD_VAR 0 4
108474: PUSH
108475: EMPTY
108476: LIST
108477: LIST
108478: ST_TO_ADDR
// break ;
108479: GO 108483
// end ; end ;
108481: GO 108283
108483: POP
108484: POP
// if result then
108485: LD_VAR 0 1
108489: IFFALSE 108549
// begin ToLua ( playSibBomb() ) ;
108491: LD_STRING playSibBomb()
108493: PPUSH
108494: CALL_OW 559
// wait ( 0 0$14 ) ;
108498: LD_INT 490
108500: PPUSH
108501: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
108505: LD_VAR 0 1
108509: PUSH
108510: LD_INT 1
108512: ARRAY
108513: PPUSH
108514: LD_VAR 0 1
108518: PUSH
108519: LD_INT 2
108521: ARRAY
108522: PPUSH
108523: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
108527: LD_VAR 0 1
108531: PUSH
108532: LD_INT 1
108534: ARRAY
108535: PPUSH
108536: LD_VAR 0 1
108540: PUSH
108541: LD_INT 2
108543: ARRAY
108544: PPUSH
108545: CALL_OW 429
// end ; end ;
108549: LD_VAR 0 1
108553: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108554: LD_EXP 155
108558: PUSH
108559: LD_EXP 177
108563: AND
108564: IFFALSE 108576
108566: GO 108568
108568: DISABLE
// YouLost (  ) ;
108569: LD_STRING 
108571: PPUSH
108572: CALL_OW 104
108576: END
// every 0 0$1 trigger StreamModeActive and sFog do
108577: LD_EXP 155
108581: PUSH
108582: LD_EXP 176
108586: AND
108587: IFFALSE 108601
108589: GO 108591
108591: DISABLE
// FogOff ( your_side ) ;
108592: LD_OWVAR 2
108596: PPUSH
108597: CALL_OW 344
108601: END
// every 0 0$1 trigger StreamModeActive and sSun do
108602: LD_EXP 155
108606: PUSH
108607: LD_EXP 178
108611: AND
108612: IFFALSE 108640
108614: GO 108616
108616: DISABLE
// begin solar_recharge_percent := 0 ;
108617: LD_ADDR_OWVAR 79
108621: PUSH
108622: LD_INT 0
108624: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108625: LD_INT 10500
108627: PPUSH
108628: CALL_OW 67
// solar_recharge_percent := 100 ;
108632: LD_ADDR_OWVAR 79
108636: PUSH
108637: LD_INT 100
108639: ST_TO_ADDR
// end ;
108640: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108641: LD_EXP 155
108645: PUSH
108646: LD_EXP 179
108650: AND
108651: IFFALSE 108890
108653: GO 108655
108655: DISABLE
108656: LD_INT 0
108658: PPUSH
108659: PPUSH
108660: PPUSH
// begin tmp := [ ] ;
108661: LD_ADDR_VAR 0 3
108665: PUSH
108666: EMPTY
108667: ST_TO_ADDR
// for i := 1 to 6 do
108668: LD_ADDR_VAR 0 1
108672: PUSH
108673: DOUBLE
108674: LD_INT 1
108676: DEC
108677: ST_TO_ADDR
108678: LD_INT 6
108680: PUSH
108681: FOR_TO
108682: IFFALSE 108787
// begin uc_nation := nation_nature ;
108684: LD_ADDR_OWVAR 21
108688: PUSH
108689: LD_INT 0
108691: ST_TO_ADDR
// uc_side := 0 ;
108692: LD_ADDR_OWVAR 20
108696: PUSH
108697: LD_INT 0
108699: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108700: LD_ADDR_OWVAR 29
108704: PUSH
108705: LD_INT 12
108707: PUSH
108708: LD_INT 12
108710: PUSH
108711: EMPTY
108712: LIST
108713: LIST
108714: ST_TO_ADDR
// hc_agressivity := 20 ;
108715: LD_ADDR_OWVAR 35
108719: PUSH
108720: LD_INT 20
108722: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108723: LD_ADDR_OWVAR 28
108727: PUSH
108728: LD_INT 17
108730: ST_TO_ADDR
// hc_gallery :=  ;
108731: LD_ADDR_OWVAR 33
108735: PUSH
108736: LD_STRING 
108738: ST_TO_ADDR
// hc_name :=  ;
108739: LD_ADDR_OWVAR 26
108743: PUSH
108744: LD_STRING 
108746: ST_TO_ADDR
// un := CreateHuman ;
108747: LD_ADDR_VAR 0 2
108751: PUSH
108752: CALL_OW 44
108756: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108757: LD_VAR 0 2
108761: PPUSH
108762: LD_INT 1
108764: PPUSH
108765: CALL_OW 51
// tmp := tmp ^ un ;
108769: LD_ADDR_VAR 0 3
108773: PUSH
108774: LD_VAR 0 3
108778: PUSH
108779: LD_VAR 0 2
108783: ADD
108784: ST_TO_ADDR
// end ;
108785: GO 108681
108787: POP
108788: POP
// repeat wait ( 0 0$1 ) ;
108789: LD_INT 35
108791: PPUSH
108792: CALL_OW 67
// for un in tmp do
108796: LD_ADDR_VAR 0 2
108800: PUSH
108801: LD_VAR 0 3
108805: PUSH
108806: FOR_IN
108807: IFFALSE 108881
// begin if IsDead ( un ) then
108809: LD_VAR 0 2
108813: PPUSH
108814: CALL_OW 301
108818: IFFALSE 108838
// begin tmp := tmp diff un ;
108820: LD_ADDR_VAR 0 3
108824: PUSH
108825: LD_VAR 0 3
108829: PUSH
108830: LD_VAR 0 2
108834: DIFF
108835: ST_TO_ADDR
// continue ;
108836: GO 108806
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108838: LD_VAR 0 2
108842: PPUSH
108843: LD_INT 3
108845: PUSH
108846: LD_INT 22
108848: PUSH
108849: LD_INT 0
108851: PUSH
108852: EMPTY
108853: LIST
108854: LIST
108855: PUSH
108856: EMPTY
108857: LIST
108858: LIST
108859: PPUSH
108860: CALL_OW 69
108864: PPUSH
108865: LD_VAR 0 2
108869: PPUSH
108870: CALL_OW 74
108874: PPUSH
108875: CALL_OW 115
// end ;
108879: GO 108806
108881: POP
108882: POP
// until not tmp ;
108883: LD_VAR 0 3
108887: NOT
108888: IFFALSE 108789
// end ;
108890: PPOPN 3
108892: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108893: LD_EXP 155
108897: PUSH
108898: LD_EXP 180
108902: AND
108903: IFFALSE 108957
108905: GO 108907
108907: DISABLE
// begin ToLua ( displayTroll(); ) ;
108908: LD_STRING displayTroll();
108910: PPUSH
108911: CALL_OW 559
// wait ( 3 3$00 ) ;
108915: LD_INT 6300
108917: PPUSH
108918: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108922: LD_STRING hideTroll();
108924: PPUSH
108925: CALL_OW 559
// wait ( 1 1$00 ) ;
108929: LD_INT 2100
108931: PPUSH
108932: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108936: LD_STRING displayTroll();
108938: PPUSH
108939: CALL_OW 559
// wait ( 1 1$00 ) ;
108943: LD_INT 2100
108945: PPUSH
108946: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108950: LD_STRING hideTroll();
108952: PPUSH
108953: CALL_OW 559
// end ;
108957: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108958: LD_EXP 155
108962: PUSH
108963: LD_EXP 181
108967: AND
108968: IFFALSE 109031
108970: GO 108972
108972: DISABLE
108973: LD_INT 0
108975: PPUSH
// begin p := 0 ;
108976: LD_ADDR_VAR 0 1
108980: PUSH
108981: LD_INT 0
108983: ST_TO_ADDR
// repeat game_speed := 1 ;
108984: LD_ADDR_OWVAR 65
108988: PUSH
108989: LD_INT 1
108991: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108992: LD_INT 35
108994: PPUSH
108995: CALL_OW 67
// p := p + 1 ;
108999: LD_ADDR_VAR 0 1
109003: PUSH
109004: LD_VAR 0 1
109008: PUSH
109009: LD_INT 1
109011: PLUS
109012: ST_TO_ADDR
// until p >= 60 ;
109013: LD_VAR 0 1
109017: PUSH
109018: LD_INT 60
109020: GREATEREQUAL
109021: IFFALSE 108984
// game_speed := 4 ;
109023: LD_ADDR_OWVAR 65
109027: PUSH
109028: LD_INT 4
109030: ST_TO_ADDR
// end ;
109031: PPOPN 1
109033: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
109034: LD_EXP 155
109038: PUSH
109039: LD_EXP 182
109043: AND
109044: IFFALSE 109190
109046: GO 109048
109048: DISABLE
109049: LD_INT 0
109051: PPUSH
109052: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109053: LD_ADDR_VAR 0 1
109057: PUSH
109058: LD_INT 22
109060: PUSH
109061: LD_OWVAR 2
109065: PUSH
109066: EMPTY
109067: LIST
109068: LIST
109069: PUSH
109070: LD_INT 2
109072: PUSH
109073: LD_INT 30
109075: PUSH
109076: LD_INT 0
109078: PUSH
109079: EMPTY
109080: LIST
109081: LIST
109082: PUSH
109083: LD_INT 30
109085: PUSH
109086: LD_INT 1
109088: PUSH
109089: EMPTY
109090: LIST
109091: LIST
109092: PUSH
109093: EMPTY
109094: LIST
109095: LIST
109096: LIST
109097: PUSH
109098: EMPTY
109099: LIST
109100: LIST
109101: PPUSH
109102: CALL_OW 69
109106: ST_TO_ADDR
// if not depot then
109107: LD_VAR 0 1
109111: NOT
109112: IFFALSE 109116
// exit ;
109114: GO 109190
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
109116: LD_ADDR_VAR 0 2
109120: PUSH
109121: LD_VAR 0 1
109125: PUSH
109126: LD_INT 1
109128: PPUSH
109129: LD_VAR 0 1
109133: PPUSH
109134: CALL_OW 12
109138: ARRAY
109139: PPUSH
109140: CALL_OW 274
109144: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
109145: LD_VAR 0 2
109149: PPUSH
109150: LD_INT 1
109152: PPUSH
109153: LD_INT 0
109155: PPUSH
109156: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
109160: LD_VAR 0 2
109164: PPUSH
109165: LD_INT 2
109167: PPUSH
109168: LD_INT 0
109170: PPUSH
109171: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
109175: LD_VAR 0 2
109179: PPUSH
109180: LD_INT 3
109182: PPUSH
109183: LD_INT 0
109185: PPUSH
109186: CALL_OW 277
// end ;
109190: PPOPN 2
109192: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
109193: LD_EXP 155
109197: PUSH
109198: LD_EXP 183
109202: AND
109203: IFFALSE 109300
109205: GO 109207
109207: DISABLE
109208: LD_INT 0
109210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
109211: LD_ADDR_VAR 0 1
109215: PUSH
109216: LD_INT 22
109218: PUSH
109219: LD_OWVAR 2
109223: PUSH
109224: EMPTY
109225: LIST
109226: LIST
109227: PUSH
109228: LD_INT 21
109230: PUSH
109231: LD_INT 1
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: PUSH
109238: LD_INT 3
109240: PUSH
109241: LD_INT 23
109243: PUSH
109244: LD_INT 0
109246: PUSH
109247: EMPTY
109248: LIST
109249: LIST
109250: PUSH
109251: EMPTY
109252: LIST
109253: LIST
109254: PUSH
109255: EMPTY
109256: LIST
109257: LIST
109258: LIST
109259: PPUSH
109260: CALL_OW 69
109264: ST_TO_ADDR
// if not tmp then
109265: LD_VAR 0 1
109269: NOT
109270: IFFALSE 109274
// exit ;
109272: GO 109300
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
109274: LD_VAR 0 1
109278: PUSH
109279: LD_INT 1
109281: PPUSH
109282: LD_VAR 0 1
109286: PPUSH
109287: CALL_OW 12
109291: ARRAY
109292: PPUSH
109293: LD_INT 200
109295: PPUSH
109296: CALL_OW 234
// end ;
109300: PPOPN 1
109302: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
109303: LD_EXP 155
109307: PUSH
109308: LD_EXP 184
109312: AND
109313: IFFALSE 109392
109315: GO 109317
109317: DISABLE
109318: LD_INT 0
109320: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
109321: LD_ADDR_VAR 0 1
109325: PUSH
109326: LD_INT 22
109328: PUSH
109329: LD_OWVAR 2
109333: PUSH
109334: EMPTY
109335: LIST
109336: LIST
109337: PUSH
109338: LD_INT 21
109340: PUSH
109341: LD_INT 2
109343: PUSH
109344: EMPTY
109345: LIST
109346: LIST
109347: PUSH
109348: EMPTY
109349: LIST
109350: LIST
109351: PPUSH
109352: CALL_OW 69
109356: ST_TO_ADDR
// if not tmp then
109357: LD_VAR 0 1
109361: NOT
109362: IFFALSE 109366
// exit ;
109364: GO 109392
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
109366: LD_VAR 0 1
109370: PUSH
109371: LD_INT 1
109373: PPUSH
109374: LD_VAR 0 1
109378: PPUSH
109379: CALL_OW 12
109383: ARRAY
109384: PPUSH
109385: LD_INT 60
109387: PPUSH
109388: CALL_OW 234
// end ;
109392: PPOPN 1
109394: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
109395: LD_EXP 155
109399: PUSH
109400: LD_EXP 185
109404: AND
109405: IFFALSE 109504
109407: GO 109409
109409: DISABLE
109410: LD_INT 0
109412: PPUSH
109413: PPUSH
// begin enable ;
109414: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
109415: LD_ADDR_VAR 0 1
109419: PUSH
109420: LD_INT 22
109422: PUSH
109423: LD_OWVAR 2
109427: PUSH
109428: EMPTY
109429: LIST
109430: LIST
109431: PUSH
109432: LD_INT 61
109434: PUSH
109435: EMPTY
109436: LIST
109437: PUSH
109438: LD_INT 33
109440: PUSH
109441: LD_INT 2
109443: PUSH
109444: EMPTY
109445: LIST
109446: LIST
109447: PUSH
109448: EMPTY
109449: LIST
109450: LIST
109451: LIST
109452: PPUSH
109453: CALL_OW 69
109457: ST_TO_ADDR
// if not tmp then
109458: LD_VAR 0 1
109462: NOT
109463: IFFALSE 109467
// exit ;
109465: GO 109504
// for i in tmp do
109467: LD_ADDR_VAR 0 2
109471: PUSH
109472: LD_VAR 0 1
109476: PUSH
109477: FOR_IN
109478: IFFALSE 109502
// if IsControledBy ( i ) then
109480: LD_VAR 0 2
109484: PPUSH
109485: CALL_OW 312
109489: IFFALSE 109500
// ComUnlink ( i ) ;
109491: LD_VAR 0 2
109495: PPUSH
109496: CALL_OW 136
109500: GO 109477
109502: POP
109503: POP
// end ;
109504: PPOPN 2
109506: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
109507: LD_EXP 155
109511: PUSH
109512: LD_EXP 186
109516: AND
109517: IFFALSE 109657
109519: GO 109521
109521: DISABLE
109522: LD_INT 0
109524: PPUSH
109525: PPUSH
// begin ToLua ( displayPowell(); ) ;
109526: LD_STRING displayPowell();
109528: PPUSH
109529: CALL_OW 559
// uc_side := 0 ;
109533: LD_ADDR_OWVAR 20
109537: PUSH
109538: LD_INT 0
109540: ST_TO_ADDR
// uc_nation := 2 ;
109541: LD_ADDR_OWVAR 21
109545: PUSH
109546: LD_INT 2
109548: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109549: LD_ADDR_OWVAR 37
109553: PUSH
109554: LD_INT 14
109556: ST_TO_ADDR
// vc_engine := engine_siberite ;
109557: LD_ADDR_OWVAR 39
109561: PUSH
109562: LD_INT 3
109564: ST_TO_ADDR
// vc_control := control_apeman ;
109565: LD_ADDR_OWVAR 38
109569: PUSH
109570: LD_INT 5
109572: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109573: LD_ADDR_OWVAR 40
109577: PUSH
109578: LD_INT 29
109580: ST_TO_ADDR
// un := CreateVehicle ;
109581: LD_ADDR_VAR 0 2
109585: PUSH
109586: CALL_OW 45
109590: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109591: LD_VAR 0 2
109595: PPUSH
109596: LD_INT 1
109598: PPUSH
109599: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109603: LD_INT 35
109605: PPUSH
109606: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109610: LD_VAR 0 2
109614: PPUSH
109615: LD_INT 22
109617: PUSH
109618: LD_OWVAR 2
109622: PUSH
109623: EMPTY
109624: LIST
109625: LIST
109626: PPUSH
109627: CALL_OW 69
109631: PPUSH
109632: LD_VAR 0 2
109636: PPUSH
109637: CALL_OW 74
109641: PPUSH
109642: CALL_OW 115
// until IsDead ( un ) ;
109646: LD_VAR 0 2
109650: PPUSH
109651: CALL_OW 301
109655: IFFALSE 109603
// end ;
109657: PPOPN 2
109659: END
// every 0 0$1 trigger StreamModeActive and sStu do
109660: LD_EXP 155
109664: PUSH
109665: LD_EXP 194
109669: AND
109670: IFFALSE 109686
109672: GO 109674
109674: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109675: LD_STRING displayStucuk();
109677: PPUSH
109678: CALL_OW 559
// ResetFog ;
109682: CALL_OW 335
// end ;
109686: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109687: LD_EXP 155
109691: PUSH
109692: LD_EXP 187
109696: AND
109697: IFFALSE 109838
109699: GO 109701
109701: DISABLE
109702: LD_INT 0
109704: PPUSH
109705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109706: LD_ADDR_VAR 0 2
109710: PUSH
109711: LD_INT 22
109713: PUSH
109714: LD_OWVAR 2
109718: PUSH
109719: EMPTY
109720: LIST
109721: LIST
109722: PUSH
109723: LD_INT 21
109725: PUSH
109726: LD_INT 1
109728: PUSH
109729: EMPTY
109730: LIST
109731: LIST
109732: PUSH
109733: EMPTY
109734: LIST
109735: LIST
109736: PPUSH
109737: CALL_OW 69
109741: ST_TO_ADDR
// if not tmp then
109742: LD_VAR 0 2
109746: NOT
109747: IFFALSE 109751
// exit ;
109749: GO 109838
// un := tmp [ rand ( 1 , tmp ) ] ;
109751: LD_ADDR_VAR 0 1
109755: PUSH
109756: LD_VAR 0 2
109760: PUSH
109761: LD_INT 1
109763: PPUSH
109764: LD_VAR 0 2
109768: PPUSH
109769: CALL_OW 12
109773: ARRAY
109774: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109775: LD_VAR 0 1
109779: PPUSH
109780: LD_INT 0
109782: PPUSH
109783: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109787: LD_VAR 0 1
109791: PPUSH
109792: LD_OWVAR 3
109796: PUSH
109797: LD_VAR 0 1
109801: DIFF
109802: PPUSH
109803: LD_VAR 0 1
109807: PPUSH
109808: CALL_OW 74
109812: PPUSH
109813: CALL_OW 115
// wait ( 0 0$20 ) ;
109817: LD_INT 700
109819: PPUSH
109820: CALL_OW 67
// SetSide ( un , your_side ) ;
109824: LD_VAR 0 1
109828: PPUSH
109829: LD_OWVAR 2
109833: PPUSH
109834: CALL_OW 235
// end ;
109838: PPOPN 2
109840: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109841: LD_EXP 155
109845: PUSH
109846: LD_EXP 188
109850: AND
109851: IFFALSE 109957
109853: GO 109855
109855: DISABLE
109856: LD_INT 0
109858: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109859: LD_ADDR_VAR 0 1
109863: PUSH
109864: LD_INT 22
109866: PUSH
109867: LD_OWVAR 2
109871: PUSH
109872: EMPTY
109873: LIST
109874: LIST
109875: PUSH
109876: LD_INT 2
109878: PUSH
109879: LD_INT 30
109881: PUSH
109882: LD_INT 0
109884: PUSH
109885: EMPTY
109886: LIST
109887: LIST
109888: PUSH
109889: LD_INT 30
109891: PUSH
109892: LD_INT 1
109894: PUSH
109895: EMPTY
109896: LIST
109897: LIST
109898: PUSH
109899: EMPTY
109900: LIST
109901: LIST
109902: LIST
109903: PUSH
109904: EMPTY
109905: LIST
109906: LIST
109907: PPUSH
109908: CALL_OW 69
109912: ST_TO_ADDR
// if not depot then
109913: LD_VAR 0 1
109917: NOT
109918: IFFALSE 109922
// exit ;
109920: GO 109957
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109922: LD_VAR 0 1
109926: PUSH
109927: LD_INT 1
109929: ARRAY
109930: PPUSH
109931: CALL_OW 250
109935: PPUSH
109936: LD_VAR 0 1
109940: PUSH
109941: LD_INT 1
109943: ARRAY
109944: PPUSH
109945: CALL_OW 251
109949: PPUSH
109950: LD_INT 70
109952: PPUSH
109953: CALL_OW 495
// end ;
109957: PPOPN 1
109959: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109960: LD_EXP 155
109964: PUSH
109965: LD_EXP 189
109969: AND
109970: IFFALSE 110181
109972: GO 109974
109974: DISABLE
109975: LD_INT 0
109977: PPUSH
109978: PPUSH
109979: PPUSH
109980: PPUSH
109981: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109982: LD_ADDR_VAR 0 5
109986: PUSH
109987: LD_INT 22
109989: PUSH
109990: LD_OWVAR 2
109994: PUSH
109995: EMPTY
109996: LIST
109997: LIST
109998: PUSH
109999: LD_INT 21
110001: PUSH
110002: LD_INT 1
110004: PUSH
110005: EMPTY
110006: LIST
110007: LIST
110008: PUSH
110009: EMPTY
110010: LIST
110011: LIST
110012: PPUSH
110013: CALL_OW 69
110017: ST_TO_ADDR
// if not tmp then
110018: LD_VAR 0 5
110022: NOT
110023: IFFALSE 110027
// exit ;
110025: GO 110181
// for i in tmp do
110027: LD_ADDR_VAR 0 1
110031: PUSH
110032: LD_VAR 0 5
110036: PUSH
110037: FOR_IN
110038: IFFALSE 110179
// begin d := rand ( 0 , 5 ) ;
110040: LD_ADDR_VAR 0 4
110044: PUSH
110045: LD_INT 0
110047: PPUSH
110048: LD_INT 5
110050: PPUSH
110051: CALL_OW 12
110055: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
110056: LD_ADDR_VAR 0 2
110060: PUSH
110061: LD_VAR 0 1
110065: PPUSH
110066: CALL_OW 250
110070: PPUSH
110071: LD_VAR 0 4
110075: PPUSH
110076: LD_INT 3
110078: PPUSH
110079: LD_INT 12
110081: PPUSH
110082: CALL_OW 12
110086: PPUSH
110087: CALL_OW 272
110091: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
110092: LD_ADDR_VAR 0 3
110096: PUSH
110097: LD_VAR 0 1
110101: PPUSH
110102: CALL_OW 251
110106: PPUSH
110107: LD_VAR 0 4
110111: PPUSH
110112: LD_INT 3
110114: PPUSH
110115: LD_INT 12
110117: PPUSH
110118: CALL_OW 12
110122: PPUSH
110123: CALL_OW 273
110127: ST_TO_ADDR
// if ValidHex ( x , y ) then
110128: LD_VAR 0 2
110132: PPUSH
110133: LD_VAR 0 3
110137: PPUSH
110138: CALL_OW 488
110142: IFFALSE 110177
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
110144: LD_VAR 0 1
110148: PPUSH
110149: LD_VAR 0 2
110153: PPUSH
110154: LD_VAR 0 3
110158: PPUSH
110159: LD_INT 3
110161: PPUSH
110162: LD_INT 6
110164: PPUSH
110165: CALL_OW 12
110169: PPUSH
110170: LD_INT 1
110172: PPUSH
110173: CALL_OW 483
// end ;
110177: GO 110037
110179: POP
110180: POP
// end ;
110181: PPOPN 5
110183: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
110184: LD_EXP 155
110188: PUSH
110189: LD_EXP 190
110193: AND
110194: IFFALSE 110288
110196: GO 110198
110198: DISABLE
110199: LD_INT 0
110201: PPUSH
110202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
110203: LD_ADDR_VAR 0 2
110207: PUSH
110208: LD_INT 22
110210: PUSH
110211: LD_OWVAR 2
110215: PUSH
110216: EMPTY
110217: LIST
110218: LIST
110219: PUSH
110220: LD_INT 32
110222: PUSH
110223: LD_INT 1
110225: PUSH
110226: EMPTY
110227: LIST
110228: LIST
110229: PUSH
110230: LD_INT 21
110232: PUSH
110233: LD_INT 2
110235: PUSH
110236: EMPTY
110237: LIST
110238: LIST
110239: PUSH
110240: EMPTY
110241: LIST
110242: LIST
110243: LIST
110244: PPUSH
110245: CALL_OW 69
110249: ST_TO_ADDR
// if not tmp then
110250: LD_VAR 0 2
110254: NOT
110255: IFFALSE 110259
// exit ;
110257: GO 110288
// for i in tmp do
110259: LD_ADDR_VAR 0 1
110263: PUSH
110264: LD_VAR 0 2
110268: PUSH
110269: FOR_IN
110270: IFFALSE 110286
// SetFuel ( i , 0 ) ;
110272: LD_VAR 0 1
110276: PPUSH
110277: LD_INT 0
110279: PPUSH
110280: CALL_OW 240
110284: GO 110269
110286: POP
110287: POP
// end ;
110288: PPOPN 2
110290: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
110291: LD_EXP 155
110295: PUSH
110296: LD_EXP 191
110300: AND
110301: IFFALSE 110367
110303: GO 110305
110305: DISABLE
110306: LD_INT 0
110308: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
110309: LD_ADDR_VAR 0 1
110313: PUSH
110314: LD_INT 22
110316: PUSH
110317: LD_OWVAR 2
110321: PUSH
110322: EMPTY
110323: LIST
110324: LIST
110325: PUSH
110326: LD_INT 30
110328: PUSH
110329: LD_INT 29
110331: PUSH
110332: EMPTY
110333: LIST
110334: LIST
110335: PUSH
110336: EMPTY
110337: LIST
110338: LIST
110339: PPUSH
110340: CALL_OW 69
110344: ST_TO_ADDR
// if not tmp then
110345: LD_VAR 0 1
110349: NOT
110350: IFFALSE 110354
// exit ;
110352: GO 110367
// DestroyUnit ( tmp [ 1 ] ) ;
110354: LD_VAR 0 1
110358: PUSH
110359: LD_INT 1
110361: ARRAY
110362: PPUSH
110363: CALL_OW 65
// end ;
110367: PPOPN 1
110369: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
110370: LD_EXP 155
110374: PUSH
110375: LD_EXP 193
110379: AND
110380: IFFALSE 110509
110382: GO 110384
110384: DISABLE
110385: LD_INT 0
110387: PPUSH
// begin uc_side := 0 ;
110388: LD_ADDR_OWVAR 20
110392: PUSH
110393: LD_INT 0
110395: ST_TO_ADDR
// uc_nation := nation_arabian ;
110396: LD_ADDR_OWVAR 21
110400: PUSH
110401: LD_INT 2
110403: ST_TO_ADDR
// hc_gallery :=  ;
110404: LD_ADDR_OWVAR 33
110408: PUSH
110409: LD_STRING 
110411: ST_TO_ADDR
// hc_name :=  ;
110412: LD_ADDR_OWVAR 26
110416: PUSH
110417: LD_STRING 
110419: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
110420: LD_INT 1
110422: PPUSH
110423: LD_INT 11
110425: PPUSH
110426: LD_INT 10
110428: PPUSH
110429: CALL_OW 380
// un := CreateHuman ;
110433: LD_ADDR_VAR 0 1
110437: PUSH
110438: CALL_OW 44
110442: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
110443: LD_VAR 0 1
110447: PPUSH
110448: LD_INT 1
110450: PPUSH
110451: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
110455: LD_INT 35
110457: PPUSH
110458: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
110462: LD_VAR 0 1
110466: PPUSH
110467: LD_INT 22
110469: PUSH
110470: LD_OWVAR 2
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PPUSH
110479: CALL_OW 69
110483: PPUSH
110484: LD_VAR 0 1
110488: PPUSH
110489: CALL_OW 74
110493: PPUSH
110494: CALL_OW 115
// until IsDead ( un ) ;
110498: LD_VAR 0 1
110502: PPUSH
110503: CALL_OW 301
110507: IFFALSE 110455
// end ;
110509: PPOPN 1
110511: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
110512: LD_EXP 155
110516: PUSH
110517: LD_EXP 195
110521: AND
110522: IFFALSE 110534
110524: GO 110526
110526: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110527: LD_STRING earthquake(getX(game), 0, 32)
110529: PPUSH
110530: CALL_OW 559
110534: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110535: LD_EXP 155
110539: PUSH
110540: LD_EXP 196
110544: AND
110545: IFFALSE 110636
110547: GO 110549
110549: DISABLE
110550: LD_INT 0
110552: PPUSH
// begin enable ;
110553: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110554: LD_ADDR_VAR 0 1
110558: PUSH
110559: LD_INT 22
110561: PUSH
110562: LD_OWVAR 2
110566: PUSH
110567: EMPTY
110568: LIST
110569: LIST
110570: PUSH
110571: LD_INT 21
110573: PUSH
110574: LD_INT 2
110576: PUSH
110577: EMPTY
110578: LIST
110579: LIST
110580: PUSH
110581: LD_INT 33
110583: PUSH
110584: LD_INT 3
110586: PUSH
110587: EMPTY
110588: LIST
110589: LIST
110590: PUSH
110591: EMPTY
110592: LIST
110593: LIST
110594: LIST
110595: PPUSH
110596: CALL_OW 69
110600: ST_TO_ADDR
// if not tmp then
110601: LD_VAR 0 1
110605: NOT
110606: IFFALSE 110610
// exit ;
110608: GO 110636
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110610: LD_VAR 0 1
110614: PUSH
110615: LD_INT 1
110617: PPUSH
110618: LD_VAR 0 1
110622: PPUSH
110623: CALL_OW 12
110627: ARRAY
110628: PPUSH
110629: LD_INT 1
110631: PPUSH
110632: CALL_OW 234
// end ;
110636: PPOPN 1
110638: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110639: LD_EXP 155
110643: PUSH
110644: LD_EXP 197
110648: AND
110649: IFFALSE 110790
110651: GO 110653
110653: DISABLE
110654: LD_INT 0
110656: PPUSH
110657: PPUSH
110658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110659: LD_ADDR_VAR 0 3
110663: PUSH
110664: LD_INT 22
110666: PUSH
110667: LD_OWVAR 2
110671: PUSH
110672: EMPTY
110673: LIST
110674: LIST
110675: PUSH
110676: LD_INT 25
110678: PUSH
110679: LD_INT 1
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: PUSH
110686: EMPTY
110687: LIST
110688: LIST
110689: PPUSH
110690: CALL_OW 69
110694: ST_TO_ADDR
// if not tmp then
110695: LD_VAR 0 3
110699: NOT
110700: IFFALSE 110704
// exit ;
110702: GO 110790
// un := tmp [ rand ( 1 , tmp ) ] ;
110704: LD_ADDR_VAR 0 2
110708: PUSH
110709: LD_VAR 0 3
110713: PUSH
110714: LD_INT 1
110716: PPUSH
110717: LD_VAR 0 3
110721: PPUSH
110722: CALL_OW 12
110726: ARRAY
110727: ST_TO_ADDR
// if Crawls ( un ) then
110728: LD_VAR 0 2
110732: PPUSH
110733: CALL_OW 318
110737: IFFALSE 110748
// ComWalk ( un ) ;
110739: LD_VAR 0 2
110743: PPUSH
110744: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110748: LD_VAR 0 2
110752: PPUSH
110753: LD_INT 9
110755: PPUSH
110756: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110760: LD_INT 28
110762: PPUSH
110763: LD_OWVAR 2
110767: PPUSH
110768: LD_INT 2
110770: PPUSH
110771: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110775: LD_INT 29
110777: PPUSH
110778: LD_OWVAR 2
110782: PPUSH
110783: LD_INT 2
110785: PPUSH
110786: CALL_OW 322
// end ;
110790: PPOPN 3
110792: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110793: LD_EXP 155
110797: PUSH
110798: LD_EXP 198
110802: AND
110803: IFFALSE 110914
110805: GO 110807
110807: DISABLE
110808: LD_INT 0
110810: PPUSH
110811: PPUSH
110812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110813: LD_ADDR_VAR 0 3
110817: PUSH
110818: LD_INT 22
110820: PUSH
110821: LD_OWVAR 2
110825: PUSH
110826: EMPTY
110827: LIST
110828: LIST
110829: PUSH
110830: LD_INT 25
110832: PUSH
110833: LD_INT 1
110835: PUSH
110836: EMPTY
110837: LIST
110838: LIST
110839: PUSH
110840: EMPTY
110841: LIST
110842: LIST
110843: PPUSH
110844: CALL_OW 69
110848: ST_TO_ADDR
// if not tmp then
110849: LD_VAR 0 3
110853: NOT
110854: IFFALSE 110858
// exit ;
110856: GO 110914
// un := tmp [ rand ( 1 , tmp ) ] ;
110858: LD_ADDR_VAR 0 2
110862: PUSH
110863: LD_VAR 0 3
110867: PUSH
110868: LD_INT 1
110870: PPUSH
110871: LD_VAR 0 3
110875: PPUSH
110876: CALL_OW 12
110880: ARRAY
110881: ST_TO_ADDR
// if Crawls ( un ) then
110882: LD_VAR 0 2
110886: PPUSH
110887: CALL_OW 318
110891: IFFALSE 110902
// ComWalk ( un ) ;
110893: LD_VAR 0 2
110897: PPUSH
110898: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110902: LD_VAR 0 2
110906: PPUSH
110907: LD_INT 8
110909: PPUSH
110910: CALL_OW 336
// end ;
110914: PPOPN 3
110916: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110917: LD_EXP 155
110921: PUSH
110922: LD_EXP 199
110926: AND
110927: IFFALSE 111071
110929: GO 110931
110931: DISABLE
110932: LD_INT 0
110934: PPUSH
110935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110936: LD_ADDR_VAR 0 2
110940: PUSH
110941: LD_INT 22
110943: PUSH
110944: LD_OWVAR 2
110948: PUSH
110949: EMPTY
110950: LIST
110951: LIST
110952: PUSH
110953: LD_INT 21
110955: PUSH
110956: LD_INT 2
110958: PUSH
110959: EMPTY
110960: LIST
110961: LIST
110962: PUSH
110963: LD_INT 2
110965: PUSH
110966: LD_INT 34
110968: PUSH
110969: LD_INT 12
110971: PUSH
110972: EMPTY
110973: LIST
110974: LIST
110975: PUSH
110976: LD_INT 34
110978: PUSH
110979: LD_INT 51
110981: PUSH
110982: EMPTY
110983: LIST
110984: LIST
110985: PUSH
110986: LD_INT 34
110988: PUSH
110989: LD_INT 32
110991: PUSH
110992: EMPTY
110993: LIST
110994: LIST
110995: PUSH
110996: EMPTY
110997: LIST
110998: LIST
110999: LIST
111000: LIST
111001: PUSH
111002: EMPTY
111003: LIST
111004: LIST
111005: LIST
111006: PPUSH
111007: CALL_OW 69
111011: ST_TO_ADDR
// if not tmp then
111012: LD_VAR 0 2
111016: NOT
111017: IFFALSE 111021
// exit ;
111019: GO 111071
// for i in tmp do
111021: LD_ADDR_VAR 0 1
111025: PUSH
111026: LD_VAR 0 2
111030: PUSH
111031: FOR_IN
111032: IFFALSE 111069
// if GetCargo ( i , mat_artifact ) = 0 then
111034: LD_VAR 0 1
111038: PPUSH
111039: LD_INT 4
111041: PPUSH
111042: CALL_OW 289
111046: PUSH
111047: LD_INT 0
111049: EQUAL
111050: IFFALSE 111067
// SetCargo ( i , mat_siberit , 100 ) ;
111052: LD_VAR 0 1
111056: PPUSH
111057: LD_INT 3
111059: PPUSH
111060: LD_INT 100
111062: PPUSH
111063: CALL_OW 290
111067: GO 111031
111069: POP
111070: POP
// end ;
111071: PPOPN 2
111073: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
111074: LD_EXP 155
111078: PUSH
111079: LD_EXP 200
111083: AND
111084: IFFALSE 111267
111086: GO 111088
111088: DISABLE
111089: LD_INT 0
111091: PPUSH
111092: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
111093: LD_ADDR_VAR 0 2
111097: PUSH
111098: LD_INT 22
111100: PUSH
111101: LD_OWVAR 2
111105: PUSH
111106: EMPTY
111107: LIST
111108: LIST
111109: PPUSH
111110: CALL_OW 69
111114: ST_TO_ADDR
// if not tmp then
111115: LD_VAR 0 2
111119: NOT
111120: IFFALSE 111124
// exit ;
111122: GO 111267
// for i := 1 to 2 do
111124: LD_ADDR_VAR 0 1
111128: PUSH
111129: DOUBLE
111130: LD_INT 1
111132: DEC
111133: ST_TO_ADDR
111134: LD_INT 2
111136: PUSH
111137: FOR_TO
111138: IFFALSE 111265
// begin uc_side := your_side ;
111140: LD_ADDR_OWVAR 20
111144: PUSH
111145: LD_OWVAR 2
111149: ST_TO_ADDR
// uc_nation := nation_american ;
111150: LD_ADDR_OWVAR 21
111154: PUSH
111155: LD_INT 1
111157: ST_TO_ADDR
// vc_chassis := us_morphling ;
111158: LD_ADDR_OWVAR 37
111162: PUSH
111163: LD_INT 5
111165: ST_TO_ADDR
// vc_engine := engine_siberite ;
111166: LD_ADDR_OWVAR 39
111170: PUSH
111171: LD_INT 3
111173: ST_TO_ADDR
// vc_control := control_computer ;
111174: LD_ADDR_OWVAR 38
111178: PUSH
111179: LD_INT 3
111181: ST_TO_ADDR
// vc_weapon := us_double_laser ;
111182: LD_ADDR_OWVAR 40
111186: PUSH
111187: LD_INT 10
111189: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
111190: LD_VAR 0 2
111194: PUSH
111195: LD_INT 1
111197: ARRAY
111198: PPUSH
111199: CALL_OW 310
111203: NOT
111204: IFFALSE 111251
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
111206: CALL_OW 45
111210: PPUSH
111211: LD_VAR 0 2
111215: PUSH
111216: LD_INT 1
111218: ARRAY
111219: PPUSH
111220: CALL_OW 250
111224: PPUSH
111225: LD_VAR 0 2
111229: PUSH
111230: LD_INT 1
111232: ARRAY
111233: PPUSH
111234: CALL_OW 251
111238: PPUSH
111239: LD_INT 12
111241: PPUSH
111242: LD_INT 1
111244: PPUSH
111245: CALL_OW 50
111249: GO 111263
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
111251: CALL_OW 45
111255: PPUSH
111256: LD_INT 1
111258: PPUSH
111259: CALL_OW 51
// end ;
111263: GO 111137
111265: POP
111266: POP
// end ;
111267: PPOPN 2
111269: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
111270: LD_EXP 155
111274: PUSH
111275: LD_EXP 201
111279: AND
111280: IFFALSE 111502
111282: GO 111284
111284: DISABLE
111285: LD_INT 0
111287: PPUSH
111288: PPUSH
111289: PPUSH
111290: PPUSH
111291: PPUSH
111292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111293: LD_ADDR_VAR 0 6
111297: PUSH
111298: LD_INT 22
111300: PUSH
111301: LD_OWVAR 2
111305: PUSH
111306: EMPTY
111307: LIST
111308: LIST
111309: PUSH
111310: LD_INT 21
111312: PUSH
111313: LD_INT 1
111315: PUSH
111316: EMPTY
111317: LIST
111318: LIST
111319: PUSH
111320: LD_INT 3
111322: PUSH
111323: LD_INT 23
111325: PUSH
111326: LD_INT 0
111328: PUSH
111329: EMPTY
111330: LIST
111331: LIST
111332: PUSH
111333: EMPTY
111334: LIST
111335: LIST
111336: PUSH
111337: EMPTY
111338: LIST
111339: LIST
111340: LIST
111341: PPUSH
111342: CALL_OW 69
111346: ST_TO_ADDR
// if not tmp then
111347: LD_VAR 0 6
111351: NOT
111352: IFFALSE 111356
// exit ;
111354: GO 111502
// s1 := rand ( 1 , 4 ) ;
111356: LD_ADDR_VAR 0 2
111360: PUSH
111361: LD_INT 1
111363: PPUSH
111364: LD_INT 4
111366: PPUSH
111367: CALL_OW 12
111371: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
111372: LD_ADDR_VAR 0 4
111376: PUSH
111377: LD_VAR 0 6
111381: PUSH
111382: LD_INT 1
111384: ARRAY
111385: PPUSH
111386: LD_VAR 0 2
111390: PPUSH
111391: CALL_OW 259
111395: ST_TO_ADDR
// if s1 = 1 then
111396: LD_VAR 0 2
111400: PUSH
111401: LD_INT 1
111403: EQUAL
111404: IFFALSE 111424
// s2 := rand ( 2 , 4 ) else
111406: LD_ADDR_VAR 0 3
111410: PUSH
111411: LD_INT 2
111413: PPUSH
111414: LD_INT 4
111416: PPUSH
111417: CALL_OW 12
111421: ST_TO_ADDR
111422: GO 111432
// s2 := 1 ;
111424: LD_ADDR_VAR 0 3
111428: PUSH
111429: LD_INT 1
111431: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
111432: LD_ADDR_VAR 0 5
111436: PUSH
111437: LD_VAR 0 6
111441: PUSH
111442: LD_INT 1
111444: ARRAY
111445: PPUSH
111446: LD_VAR 0 3
111450: PPUSH
111451: CALL_OW 259
111455: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
111456: LD_VAR 0 6
111460: PUSH
111461: LD_INT 1
111463: ARRAY
111464: PPUSH
111465: LD_VAR 0 2
111469: PPUSH
111470: LD_VAR 0 5
111474: PPUSH
111475: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
111479: LD_VAR 0 6
111483: PUSH
111484: LD_INT 1
111486: ARRAY
111487: PPUSH
111488: LD_VAR 0 3
111492: PPUSH
111493: LD_VAR 0 4
111497: PPUSH
111498: CALL_OW 237
// end ;
111502: PPOPN 6
111504: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111505: LD_EXP 155
111509: PUSH
111510: LD_EXP 202
111514: AND
111515: IFFALSE 111594
111517: GO 111519
111519: DISABLE
111520: LD_INT 0
111522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111523: LD_ADDR_VAR 0 1
111527: PUSH
111528: LD_INT 22
111530: PUSH
111531: LD_OWVAR 2
111535: PUSH
111536: EMPTY
111537: LIST
111538: LIST
111539: PUSH
111540: LD_INT 30
111542: PUSH
111543: LD_INT 3
111545: PUSH
111546: EMPTY
111547: LIST
111548: LIST
111549: PUSH
111550: EMPTY
111551: LIST
111552: LIST
111553: PPUSH
111554: CALL_OW 69
111558: ST_TO_ADDR
// if not tmp then
111559: LD_VAR 0 1
111563: NOT
111564: IFFALSE 111568
// exit ;
111566: GO 111594
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111568: LD_VAR 0 1
111572: PUSH
111573: LD_INT 1
111575: PPUSH
111576: LD_VAR 0 1
111580: PPUSH
111581: CALL_OW 12
111585: ARRAY
111586: PPUSH
111587: LD_INT 1
111589: PPUSH
111590: CALL_OW 234
// end ;
111594: PPOPN 1
111596: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111597: LD_EXP 155
111601: PUSH
111602: LD_EXP 203
111606: AND
111607: IFFALSE 111719
111609: GO 111611
111611: DISABLE
111612: LD_INT 0
111614: PPUSH
111615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111616: LD_ADDR_VAR 0 2
111620: PUSH
111621: LD_INT 22
111623: PUSH
111624: LD_OWVAR 2
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: PUSH
111633: LD_INT 2
111635: PUSH
111636: LD_INT 30
111638: PUSH
111639: LD_INT 27
111641: PUSH
111642: EMPTY
111643: LIST
111644: LIST
111645: PUSH
111646: LD_INT 30
111648: PUSH
111649: LD_INT 26
111651: PUSH
111652: EMPTY
111653: LIST
111654: LIST
111655: PUSH
111656: LD_INT 30
111658: PUSH
111659: LD_INT 28
111661: PUSH
111662: EMPTY
111663: LIST
111664: LIST
111665: PUSH
111666: EMPTY
111667: LIST
111668: LIST
111669: LIST
111670: LIST
111671: PUSH
111672: EMPTY
111673: LIST
111674: LIST
111675: PPUSH
111676: CALL_OW 69
111680: ST_TO_ADDR
// if not tmp then
111681: LD_VAR 0 2
111685: NOT
111686: IFFALSE 111690
// exit ;
111688: GO 111719
// for i in tmp do
111690: LD_ADDR_VAR 0 1
111694: PUSH
111695: LD_VAR 0 2
111699: PUSH
111700: FOR_IN
111701: IFFALSE 111717
// SetLives ( i , 1 ) ;
111703: LD_VAR 0 1
111707: PPUSH
111708: LD_INT 1
111710: PPUSH
111711: CALL_OW 234
111715: GO 111700
111717: POP
111718: POP
// end ;
111719: PPOPN 2
111721: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111722: LD_EXP 155
111726: PUSH
111727: LD_EXP 204
111731: AND
111732: IFFALSE 112006
111734: GO 111736
111736: DISABLE
111737: LD_INT 0
111739: PPUSH
111740: PPUSH
111741: PPUSH
// begin i := rand ( 1 , 7 ) ;
111742: LD_ADDR_VAR 0 1
111746: PUSH
111747: LD_INT 1
111749: PPUSH
111750: LD_INT 7
111752: PPUSH
111753: CALL_OW 12
111757: ST_TO_ADDR
// case i of 1 :
111758: LD_VAR 0 1
111762: PUSH
111763: LD_INT 1
111765: DOUBLE
111766: EQUAL
111767: IFTRUE 111771
111769: GO 111781
111771: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111772: LD_STRING earthquake(getX(game), 0, 32)
111774: PPUSH
111775: CALL_OW 559
111779: GO 112006
111781: LD_INT 2
111783: DOUBLE
111784: EQUAL
111785: IFTRUE 111789
111787: GO 111803
111789: POP
// begin ToLua ( displayStucuk(); ) ;
111790: LD_STRING displayStucuk();
111792: PPUSH
111793: CALL_OW 559
// ResetFog ;
111797: CALL_OW 335
// end ; 3 :
111801: GO 112006
111803: LD_INT 3
111805: DOUBLE
111806: EQUAL
111807: IFTRUE 111811
111809: GO 111915
111811: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111812: LD_ADDR_VAR 0 2
111816: PUSH
111817: LD_INT 22
111819: PUSH
111820: LD_OWVAR 2
111824: PUSH
111825: EMPTY
111826: LIST
111827: LIST
111828: PUSH
111829: LD_INT 25
111831: PUSH
111832: LD_INT 1
111834: PUSH
111835: EMPTY
111836: LIST
111837: LIST
111838: PUSH
111839: EMPTY
111840: LIST
111841: LIST
111842: PPUSH
111843: CALL_OW 69
111847: ST_TO_ADDR
// if not tmp then
111848: LD_VAR 0 2
111852: NOT
111853: IFFALSE 111857
// exit ;
111855: GO 112006
// un := tmp [ rand ( 1 , tmp ) ] ;
111857: LD_ADDR_VAR 0 3
111861: PUSH
111862: LD_VAR 0 2
111866: PUSH
111867: LD_INT 1
111869: PPUSH
111870: LD_VAR 0 2
111874: PPUSH
111875: CALL_OW 12
111879: ARRAY
111880: ST_TO_ADDR
// if Crawls ( un ) then
111881: LD_VAR 0 3
111885: PPUSH
111886: CALL_OW 318
111890: IFFALSE 111901
// ComWalk ( un ) ;
111892: LD_VAR 0 3
111896: PPUSH
111897: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111901: LD_VAR 0 3
111905: PPUSH
111906: LD_INT 8
111908: PPUSH
111909: CALL_OW 336
// end ; 4 :
111913: GO 112006
111915: LD_INT 4
111917: DOUBLE
111918: EQUAL
111919: IFTRUE 111923
111921: GO 111984
111923: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111924: LD_ADDR_VAR 0 2
111928: PUSH
111929: LD_INT 22
111931: PUSH
111932: LD_OWVAR 2
111936: PUSH
111937: EMPTY
111938: LIST
111939: LIST
111940: PUSH
111941: LD_INT 30
111943: PUSH
111944: LD_INT 29
111946: PUSH
111947: EMPTY
111948: LIST
111949: LIST
111950: PUSH
111951: EMPTY
111952: LIST
111953: LIST
111954: PPUSH
111955: CALL_OW 69
111959: ST_TO_ADDR
// if not tmp then
111960: LD_VAR 0 2
111964: NOT
111965: IFFALSE 111969
// exit ;
111967: GO 112006
// DestroyUnit ( tmp [ 1 ] ) ;
111969: LD_VAR 0 2
111973: PUSH
111974: LD_INT 1
111976: ARRAY
111977: PPUSH
111978: CALL_OW 65
// end ; 5 .. 7 :
111982: GO 112006
111984: LD_INT 5
111986: DOUBLE
111987: GREATEREQUAL
111988: IFFALSE 111996
111990: LD_INT 7
111992: DOUBLE
111993: LESSEQUAL
111994: IFTRUE 111998
111996: GO 112005
111998: POP
// StreamSibBomb ; end ;
111999: CALL 108256 0 0
112003: GO 112006
112005: POP
// end ;
112006: PPOPN 3
112008: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
112009: LD_EXP 155
112013: PUSH
112014: LD_EXP 205
112018: AND
112019: IFFALSE 112175
112021: GO 112023
112023: DISABLE
112024: LD_INT 0
112026: PPUSH
112027: PPUSH
112028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
112029: LD_ADDR_VAR 0 2
112033: PUSH
112034: LD_INT 81
112036: PUSH
112037: LD_OWVAR 2
112041: PUSH
112042: EMPTY
112043: LIST
112044: LIST
112045: PUSH
112046: LD_INT 2
112048: PUSH
112049: LD_INT 21
112051: PUSH
112052: LD_INT 1
112054: PUSH
112055: EMPTY
112056: LIST
112057: LIST
112058: PUSH
112059: LD_INT 21
112061: PUSH
112062: LD_INT 2
112064: PUSH
112065: EMPTY
112066: LIST
112067: LIST
112068: PUSH
112069: EMPTY
112070: LIST
112071: LIST
112072: LIST
112073: PUSH
112074: EMPTY
112075: LIST
112076: LIST
112077: PPUSH
112078: CALL_OW 69
112082: ST_TO_ADDR
// if not tmp then
112083: LD_VAR 0 2
112087: NOT
112088: IFFALSE 112092
// exit ;
112090: GO 112175
// p := 0 ;
112092: LD_ADDR_VAR 0 3
112096: PUSH
112097: LD_INT 0
112099: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112100: LD_INT 35
112102: PPUSH
112103: CALL_OW 67
// p := p + 1 ;
112107: LD_ADDR_VAR 0 3
112111: PUSH
112112: LD_VAR 0 3
112116: PUSH
112117: LD_INT 1
112119: PLUS
112120: ST_TO_ADDR
// for i in tmp do
112121: LD_ADDR_VAR 0 1
112125: PUSH
112126: LD_VAR 0 2
112130: PUSH
112131: FOR_IN
112132: IFFALSE 112163
// if GetLives ( i ) < 1000 then
112134: LD_VAR 0 1
112138: PPUSH
112139: CALL_OW 256
112143: PUSH
112144: LD_INT 1000
112146: LESS
112147: IFFALSE 112161
// SetLives ( i , 1000 ) ;
112149: LD_VAR 0 1
112153: PPUSH
112154: LD_INT 1000
112156: PPUSH
112157: CALL_OW 234
112161: GO 112131
112163: POP
112164: POP
// until p > 20 ;
112165: LD_VAR 0 3
112169: PUSH
112170: LD_INT 20
112172: GREATER
112173: IFFALSE 112100
// end ;
112175: PPOPN 3
112177: END
// every 0 0$1 trigger StreamModeActive and sTime do
112178: LD_EXP 155
112182: PUSH
112183: LD_EXP 206
112187: AND
112188: IFFALSE 112223
112190: GO 112192
112192: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
112193: LD_INT 28
112195: PPUSH
112196: LD_OWVAR 2
112200: PPUSH
112201: LD_INT 2
112203: PPUSH
112204: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
112208: LD_INT 30
112210: PPUSH
112211: LD_OWVAR 2
112215: PPUSH
112216: LD_INT 2
112218: PPUSH
112219: CALL_OW 322
// end ;
112223: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
112224: LD_EXP 155
112228: PUSH
112229: LD_EXP 207
112233: AND
112234: IFFALSE 112355
112236: GO 112238
112238: DISABLE
112239: LD_INT 0
112241: PPUSH
112242: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
112243: LD_ADDR_VAR 0 2
112247: PUSH
112248: LD_INT 22
112250: PUSH
112251: LD_OWVAR 2
112255: PUSH
112256: EMPTY
112257: LIST
112258: LIST
112259: PUSH
112260: LD_INT 21
112262: PUSH
112263: LD_INT 1
112265: PUSH
112266: EMPTY
112267: LIST
112268: LIST
112269: PUSH
112270: LD_INT 3
112272: PUSH
112273: LD_INT 23
112275: PUSH
112276: LD_INT 0
112278: PUSH
112279: EMPTY
112280: LIST
112281: LIST
112282: PUSH
112283: EMPTY
112284: LIST
112285: LIST
112286: PUSH
112287: EMPTY
112288: LIST
112289: LIST
112290: LIST
112291: PPUSH
112292: CALL_OW 69
112296: ST_TO_ADDR
// if not tmp then
112297: LD_VAR 0 2
112301: NOT
112302: IFFALSE 112306
// exit ;
112304: GO 112355
// for i in tmp do
112306: LD_ADDR_VAR 0 1
112310: PUSH
112311: LD_VAR 0 2
112315: PUSH
112316: FOR_IN
112317: IFFALSE 112353
// begin if Crawls ( i ) then
112319: LD_VAR 0 1
112323: PPUSH
112324: CALL_OW 318
112328: IFFALSE 112339
// ComWalk ( i ) ;
112330: LD_VAR 0 1
112334: PPUSH
112335: CALL_OW 138
// SetClass ( i , 2 ) ;
112339: LD_VAR 0 1
112343: PPUSH
112344: LD_INT 2
112346: PPUSH
112347: CALL_OW 336
// end ;
112351: GO 112316
112353: POP
112354: POP
// end ;
112355: PPOPN 2
112357: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
112358: LD_EXP 155
112362: PUSH
112363: LD_EXP 208
112367: AND
112368: IFFALSE 112649
112370: GO 112372
112372: DISABLE
112373: LD_INT 0
112375: PPUSH
112376: PPUSH
112377: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
112378: LD_OWVAR 2
112382: PPUSH
112383: LD_INT 9
112385: PPUSH
112386: LD_INT 1
112388: PPUSH
112389: LD_INT 1
112391: PPUSH
112392: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
112396: LD_INT 9
112398: PPUSH
112399: LD_OWVAR 2
112403: PPUSH
112404: CALL_OW 343
// uc_side := 9 ;
112408: LD_ADDR_OWVAR 20
112412: PUSH
112413: LD_INT 9
112415: ST_TO_ADDR
// uc_nation := 2 ;
112416: LD_ADDR_OWVAR 21
112420: PUSH
112421: LD_INT 2
112423: ST_TO_ADDR
// hc_name := Dark Warrior ;
112424: LD_ADDR_OWVAR 26
112428: PUSH
112429: LD_STRING Dark Warrior
112431: ST_TO_ADDR
// hc_gallery :=  ;
112432: LD_ADDR_OWVAR 33
112436: PUSH
112437: LD_STRING 
112439: ST_TO_ADDR
// hc_noskilllimit := true ;
112440: LD_ADDR_OWVAR 76
112444: PUSH
112445: LD_INT 1
112447: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
112448: LD_ADDR_OWVAR 31
112452: PUSH
112453: LD_INT 30
112455: PUSH
112456: LD_INT 30
112458: PUSH
112459: LD_INT 30
112461: PUSH
112462: LD_INT 30
112464: PUSH
112465: EMPTY
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: ST_TO_ADDR
// un := CreateHuman ;
112471: LD_ADDR_VAR 0 3
112475: PUSH
112476: CALL_OW 44
112480: ST_TO_ADDR
// hc_noskilllimit := false ;
112481: LD_ADDR_OWVAR 76
112485: PUSH
112486: LD_INT 0
112488: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112489: LD_VAR 0 3
112493: PPUSH
112494: LD_INT 1
112496: PPUSH
112497: CALL_OW 51
// p := 0 ;
112501: LD_ADDR_VAR 0 2
112505: PUSH
112506: LD_INT 0
112508: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112509: LD_INT 35
112511: PPUSH
112512: CALL_OW 67
// p := p + 1 ;
112516: LD_ADDR_VAR 0 2
112520: PUSH
112521: LD_VAR 0 2
112525: PUSH
112526: LD_INT 1
112528: PLUS
112529: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112530: LD_VAR 0 3
112534: PPUSH
112535: CALL_OW 256
112539: PUSH
112540: LD_INT 1000
112542: LESS
112543: IFFALSE 112557
// SetLives ( un , 1000 ) ;
112545: LD_VAR 0 3
112549: PPUSH
112550: LD_INT 1000
112552: PPUSH
112553: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112557: LD_VAR 0 3
112561: PPUSH
112562: LD_INT 81
112564: PUSH
112565: LD_OWVAR 2
112569: PUSH
112570: EMPTY
112571: LIST
112572: LIST
112573: PUSH
112574: LD_INT 91
112576: PUSH
112577: LD_VAR 0 3
112581: PUSH
112582: LD_INT 30
112584: PUSH
112585: EMPTY
112586: LIST
112587: LIST
112588: LIST
112589: PUSH
112590: EMPTY
112591: LIST
112592: LIST
112593: PPUSH
112594: CALL_OW 69
112598: PPUSH
112599: LD_VAR 0 3
112603: PPUSH
112604: CALL_OW 74
112608: PPUSH
112609: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
112613: LD_VAR 0 2
112617: PUSH
112618: LD_INT 60
112620: GREATER
112621: PUSH
112622: LD_VAR 0 3
112626: PPUSH
112627: CALL_OW 301
112631: OR
112632: IFFALSE 112509
// if un then
112634: LD_VAR 0 3
112638: IFFALSE 112649
// RemoveUnit ( un ) ;
112640: LD_VAR 0 3
112644: PPUSH
112645: CALL_OW 64
// end ;
112649: PPOPN 3
112651: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112652: LD_INT 0
112654: PPUSH
// case cmd of 301 :
112655: LD_VAR 0 1
112659: PUSH
112660: LD_INT 301
112662: DOUBLE
112663: EQUAL
112664: IFTRUE 112668
112666: GO 112700
112668: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
112669: LD_VAR 0 6
112673: PPUSH
112674: LD_VAR 0 7
112678: PPUSH
112679: LD_VAR 0 8
112683: PPUSH
112684: LD_VAR 0 4
112688: PPUSH
112689: LD_VAR 0 5
112693: PPUSH
112694: CALL 113901 0 5
112698: GO 112821
112700: LD_INT 302
112702: DOUBLE
112703: EQUAL
112704: IFTRUE 112708
112706: GO 112745
112708: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
112709: LD_VAR 0 6
112713: PPUSH
112714: LD_VAR 0 7
112718: PPUSH
112719: LD_VAR 0 8
112723: PPUSH
112724: LD_VAR 0 9
112728: PPUSH
112729: LD_VAR 0 4
112733: PPUSH
112734: LD_VAR 0 5
112738: PPUSH
112739: CALL 113992 0 6
112743: GO 112821
112745: LD_INT 303
112747: DOUBLE
112748: EQUAL
112749: IFTRUE 112753
112751: GO 112790
112753: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
112754: LD_VAR 0 6
112758: PPUSH
112759: LD_VAR 0 7
112763: PPUSH
112764: LD_VAR 0 8
112768: PPUSH
112769: LD_VAR 0 9
112773: PPUSH
112774: LD_VAR 0 4
112778: PPUSH
112779: LD_VAR 0 5
112783: PPUSH
112784: CALL 112826 0 6
112788: GO 112821
112790: LD_INT 304
112792: DOUBLE
112793: EQUAL
112794: IFTRUE 112798
112796: GO 112820
112798: POP
// hHackTeleport ( unit , x , y ) ; end ;
112799: LD_VAR 0 2
112803: PPUSH
112804: LD_VAR 0 4
112808: PPUSH
112809: LD_VAR 0 5
112813: PPUSH
112814: CALL 114585 0 3
112818: GO 112821
112820: POP
// end ;
112821: LD_VAR 0 12
112825: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
112826: LD_INT 0
112828: PPUSH
112829: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
112830: LD_VAR 0 1
112834: PUSH
112835: LD_INT 1
112837: LESS
112838: PUSH
112839: LD_VAR 0 1
112843: PUSH
112844: LD_INT 3
112846: GREATER
112847: OR
112848: PUSH
112849: LD_VAR 0 5
112853: PPUSH
112854: LD_VAR 0 6
112858: PPUSH
112859: CALL_OW 428
112863: OR
112864: IFFALSE 112868
// exit ;
112866: GO 113588
// uc_side := your_side ;
112868: LD_ADDR_OWVAR 20
112872: PUSH
112873: LD_OWVAR 2
112877: ST_TO_ADDR
// uc_nation := nation ;
112878: LD_ADDR_OWVAR 21
112882: PUSH
112883: LD_VAR 0 1
112887: ST_TO_ADDR
// bc_level = 1 ;
112888: LD_ADDR_OWVAR 43
112892: PUSH
112893: LD_INT 1
112895: ST_TO_ADDR
// case btype of 1 :
112896: LD_VAR 0 2
112900: PUSH
112901: LD_INT 1
112903: DOUBLE
112904: EQUAL
112905: IFTRUE 112909
112907: GO 112920
112909: POP
// bc_type := b_depot ; 2 :
112910: LD_ADDR_OWVAR 42
112914: PUSH
112915: LD_INT 0
112917: ST_TO_ADDR
112918: GO 113532
112920: LD_INT 2
112922: DOUBLE
112923: EQUAL
112924: IFTRUE 112928
112926: GO 112939
112928: POP
// bc_type := b_warehouse ; 3 :
112929: LD_ADDR_OWVAR 42
112933: PUSH
112934: LD_INT 1
112936: ST_TO_ADDR
112937: GO 113532
112939: LD_INT 3
112941: DOUBLE
112942: EQUAL
112943: IFTRUE 112947
112945: GO 112958
112947: POP
// bc_type := b_lab ; 4 .. 9 :
112948: LD_ADDR_OWVAR 42
112952: PUSH
112953: LD_INT 6
112955: ST_TO_ADDR
112956: GO 113532
112958: LD_INT 4
112960: DOUBLE
112961: GREATEREQUAL
112962: IFFALSE 112970
112964: LD_INT 9
112966: DOUBLE
112967: LESSEQUAL
112968: IFTRUE 112972
112970: GO 113024
112972: POP
// begin bc_type := b_lab_half ;
112973: LD_ADDR_OWVAR 42
112977: PUSH
112978: LD_INT 7
112980: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
112981: LD_ADDR_OWVAR 44
112985: PUSH
112986: LD_INT 10
112988: PUSH
112989: LD_INT 11
112991: PUSH
112992: LD_INT 12
112994: PUSH
112995: LD_INT 15
112997: PUSH
112998: LD_INT 14
113000: PUSH
113001: LD_INT 13
113003: PUSH
113004: EMPTY
113005: LIST
113006: LIST
113007: LIST
113008: LIST
113009: LIST
113010: LIST
113011: PUSH
113012: LD_VAR 0 2
113016: PUSH
113017: LD_INT 3
113019: MINUS
113020: ARRAY
113021: ST_TO_ADDR
// end ; 10 .. 13 :
113022: GO 113532
113024: LD_INT 10
113026: DOUBLE
113027: GREATEREQUAL
113028: IFFALSE 113036
113030: LD_INT 13
113032: DOUBLE
113033: LESSEQUAL
113034: IFTRUE 113038
113036: GO 113115
113038: POP
// begin bc_type := b_lab_full ;
113039: LD_ADDR_OWVAR 42
113043: PUSH
113044: LD_INT 8
113046: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
113047: LD_ADDR_OWVAR 44
113051: PUSH
113052: LD_INT 10
113054: PUSH
113055: LD_INT 12
113057: PUSH
113058: LD_INT 14
113060: PUSH
113061: LD_INT 13
113063: PUSH
113064: EMPTY
113065: LIST
113066: LIST
113067: LIST
113068: LIST
113069: PUSH
113070: LD_VAR 0 2
113074: PUSH
113075: LD_INT 9
113077: MINUS
113078: ARRAY
113079: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
113080: LD_ADDR_OWVAR 45
113084: PUSH
113085: LD_INT 11
113087: PUSH
113088: LD_INT 15
113090: PUSH
113091: LD_INT 12
113093: PUSH
113094: LD_INT 15
113096: PUSH
113097: EMPTY
113098: LIST
113099: LIST
113100: LIST
113101: LIST
113102: PUSH
113103: LD_VAR 0 2
113107: PUSH
113108: LD_INT 9
113110: MINUS
113111: ARRAY
113112: ST_TO_ADDR
// end ; 14 :
113113: GO 113532
113115: LD_INT 14
113117: DOUBLE
113118: EQUAL
113119: IFTRUE 113123
113121: GO 113134
113123: POP
// bc_type := b_workshop ; 15 :
113124: LD_ADDR_OWVAR 42
113128: PUSH
113129: LD_INT 2
113131: ST_TO_ADDR
113132: GO 113532
113134: LD_INT 15
113136: DOUBLE
113137: EQUAL
113138: IFTRUE 113142
113140: GO 113153
113142: POP
// bc_type := b_factory ; 16 :
113143: LD_ADDR_OWVAR 42
113147: PUSH
113148: LD_INT 3
113150: ST_TO_ADDR
113151: GO 113532
113153: LD_INT 16
113155: DOUBLE
113156: EQUAL
113157: IFTRUE 113161
113159: GO 113172
113161: POP
// bc_type := b_ext_gun ; 17 :
113162: LD_ADDR_OWVAR 42
113166: PUSH
113167: LD_INT 17
113169: ST_TO_ADDR
113170: GO 113532
113172: LD_INT 17
113174: DOUBLE
113175: EQUAL
113176: IFTRUE 113180
113178: GO 113208
113180: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113181: LD_ADDR_OWVAR 42
113185: PUSH
113186: LD_INT 19
113188: PUSH
113189: LD_INT 23
113191: PUSH
113192: LD_INT 19
113194: PUSH
113195: EMPTY
113196: LIST
113197: LIST
113198: LIST
113199: PUSH
113200: LD_VAR 0 1
113204: ARRAY
113205: ST_TO_ADDR
113206: GO 113532
113208: LD_INT 18
113210: DOUBLE
113211: EQUAL
113212: IFTRUE 113216
113214: GO 113227
113216: POP
// bc_type := b_ext_radar ; 19 :
113217: LD_ADDR_OWVAR 42
113221: PUSH
113222: LD_INT 20
113224: ST_TO_ADDR
113225: GO 113532
113227: LD_INT 19
113229: DOUBLE
113230: EQUAL
113231: IFTRUE 113235
113233: GO 113246
113235: POP
// bc_type := b_ext_radio ; 20 :
113236: LD_ADDR_OWVAR 42
113240: PUSH
113241: LD_INT 22
113243: ST_TO_ADDR
113244: GO 113532
113246: LD_INT 20
113248: DOUBLE
113249: EQUAL
113250: IFTRUE 113254
113252: GO 113265
113254: POP
// bc_type := b_ext_siberium ; 21 :
113255: LD_ADDR_OWVAR 42
113259: PUSH
113260: LD_INT 21
113262: ST_TO_ADDR
113263: GO 113532
113265: LD_INT 21
113267: DOUBLE
113268: EQUAL
113269: IFTRUE 113273
113271: GO 113284
113273: POP
// bc_type := b_ext_computer ; 22 :
113274: LD_ADDR_OWVAR 42
113278: PUSH
113279: LD_INT 24
113281: ST_TO_ADDR
113282: GO 113532
113284: LD_INT 22
113286: DOUBLE
113287: EQUAL
113288: IFTRUE 113292
113290: GO 113303
113292: POP
// bc_type := b_ext_track ; 23 :
113293: LD_ADDR_OWVAR 42
113297: PUSH
113298: LD_INT 16
113300: ST_TO_ADDR
113301: GO 113532
113303: LD_INT 23
113305: DOUBLE
113306: EQUAL
113307: IFTRUE 113311
113309: GO 113322
113311: POP
// bc_type := b_ext_laser ; 24 :
113312: LD_ADDR_OWVAR 42
113316: PUSH
113317: LD_INT 25
113319: ST_TO_ADDR
113320: GO 113532
113322: LD_INT 24
113324: DOUBLE
113325: EQUAL
113326: IFTRUE 113330
113328: GO 113341
113330: POP
// bc_type := b_control_tower ; 25 :
113331: LD_ADDR_OWVAR 42
113335: PUSH
113336: LD_INT 36
113338: ST_TO_ADDR
113339: GO 113532
113341: LD_INT 25
113343: DOUBLE
113344: EQUAL
113345: IFTRUE 113349
113347: GO 113360
113349: POP
// bc_type := b_breastwork ; 26 :
113350: LD_ADDR_OWVAR 42
113354: PUSH
113355: LD_INT 31
113357: ST_TO_ADDR
113358: GO 113532
113360: LD_INT 26
113362: DOUBLE
113363: EQUAL
113364: IFTRUE 113368
113366: GO 113379
113368: POP
// bc_type := b_bunker ; 27 :
113369: LD_ADDR_OWVAR 42
113373: PUSH
113374: LD_INT 32
113376: ST_TO_ADDR
113377: GO 113532
113379: LD_INT 27
113381: DOUBLE
113382: EQUAL
113383: IFTRUE 113387
113385: GO 113398
113387: POP
// bc_type := b_turret ; 28 :
113388: LD_ADDR_OWVAR 42
113392: PUSH
113393: LD_INT 33
113395: ST_TO_ADDR
113396: GO 113532
113398: LD_INT 28
113400: DOUBLE
113401: EQUAL
113402: IFTRUE 113406
113404: GO 113417
113406: POP
// bc_type := b_armoury ; 29 :
113407: LD_ADDR_OWVAR 42
113411: PUSH
113412: LD_INT 4
113414: ST_TO_ADDR
113415: GO 113532
113417: LD_INT 29
113419: DOUBLE
113420: EQUAL
113421: IFTRUE 113425
113423: GO 113436
113425: POP
// bc_type := b_barracks ; 30 :
113426: LD_ADDR_OWVAR 42
113430: PUSH
113431: LD_INT 5
113433: ST_TO_ADDR
113434: GO 113532
113436: LD_INT 30
113438: DOUBLE
113439: EQUAL
113440: IFTRUE 113444
113442: GO 113455
113444: POP
// bc_type := b_solar_power ; 31 :
113445: LD_ADDR_OWVAR 42
113449: PUSH
113450: LD_INT 27
113452: ST_TO_ADDR
113453: GO 113532
113455: LD_INT 31
113457: DOUBLE
113458: EQUAL
113459: IFTRUE 113463
113461: GO 113474
113463: POP
// bc_type := b_oil_power ; 32 :
113464: LD_ADDR_OWVAR 42
113468: PUSH
113469: LD_INT 26
113471: ST_TO_ADDR
113472: GO 113532
113474: LD_INT 32
113476: DOUBLE
113477: EQUAL
113478: IFTRUE 113482
113480: GO 113493
113482: POP
// bc_type := b_siberite_power ; 33 :
113483: LD_ADDR_OWVAR 42
113487: PUSH
113488: LD_INT 28
113490: ST_TO_ADDR
113491: GO 113532
113493: LD_INT 33
113495: DOUBLE
113496: EQUAL
113497: IFTRUE 113501
113499: GO 113512
113501: POP
// bc_type := b_oil_mine ; 34 :
113502: LD_ADDR_OWVAR 42
113506: PUSH
113507: LD_INT 29
113509: ST_TO_ADDR
113510: GO 113532
113512: LD_INT 34
113514: DOUBLE
113515: EQUAL
113516: IFTRUE 113520
113518: GO 113531
113520: POP
// bc_type := b_siberite_mine ; end ;
113521: LD_ADDR_OWVAR 42
113525: PUSH
113526: LD_INT 30
113528: ST_TO_ADDR
113529: GO 113532
113531: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
113532: LD_ADDR_VAR 0 8
113536: PUSH
113537: LD_VAR 0 5
113541: PPUSH
113542: LD_VAR 0 6
113546: PPUSH
113547: LD_VAR 0 3
113551: PPUSH
113552: CALL_OW 47
113556: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
113557: LD_OWVAR 42
113561: PUSH
113562: LD_INT 32
113564: PUSH
113565: LD_INT 33
113567: PUSH
113568: EMPTY
113569: LIST
113570: LIST
113571: IN
113572: IFFALSE 113588
// PlaceWeaponTurret ( b , weapon ) ;
113574: LD_VAR 0 8
113578: PPUSH
113579: LD_VAR 0 4
113583: PPUSH
113584: CALL_OW 431
// end ;
113588: LD_VAR 0 7
113592: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
113593: LD_INT 0
113595: PPUSH
113596: PPUSH
113597: PPUSH
113598: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113599: LD_ADDR_VAR 0 4
113603: PUSH
113604: LD_INT 22
113606: PUSH
113607: LD_OWVAR 2
113611: PUSH
113612: EMPTY
113613: LIST
113614: LIST
113615: PUSH
113616: LD_INT 2
113618: PUSH
113619: LD_INT 30
113621: PUSH
113622: LD_INT 0
113624: PUSH
113625: EMPTY
113626: LIST
113627: LIST
113628: PUSH
113629: LD_INT 30
113631: PUSH
113632: LD_INT 1
113634: PUSH
113635: EMPTY
113636: LIST
113637: LIST
113638: PUSH
113639: EMPTY
113640: LIST
113641: LIST
113642: LIST
113643: PUSH
113644: EMPTY
113645: LIST
113646: LIST
113647: PPUSH
113648: CALL_OW 69
113652: ST_TO_ADDR
// if not tmp then
113653: LD_VAR 0 4
113657: NOT
113658: IFFALSE 113662
// exit ;
113660: GO 113721
// for i in tmp do
113662: LD_ADDR_VAR 0 2
113666: PUSH
113667: LD_VAR 0 4
113671: PUSH
113672: FOR_IN
113673: IFFALSE 113719
// for j = 1 to 3 do
113675: LD_ADDR_VAR 0 3
113679: PUSH
113680: DOUBLE
113681: LD_INT 1
113683: DEC
113684: ST_TO_ADDR
113685: LD_INT 3
113687: PUSH
113688: FOR_TO
113689: IFFALSE 113715
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
113691: LD_VAR 0 2
113695: PPUSH
113696: CALL_OW 274
113700: PPUSH
113701: LD_VAR 0 3
113705: PPUSH
113706: LD_INT 99999
113708: PPUSH
113709: CALL_OW 277
113713: GO 113688
113715: POP
113716: POP
113717: GO 113672
113719: POP
113720: POP
// end ;
113721: LD_VAR 0 1
113725: RET
// export function hHackSetLevel10 ; var i , j ; begin
113726: LD_INT 0
113728: PPUSH
113729: PPUSH
113730: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
113731: LD_ADDR_VAR 0 2
113735: PUSH
113736: LD_INT 21
113738: PUSH
113739: LD_INT 1
113741: PUSH
113742: EMPTY
113743: LIST
113744: LIST
113745: PPUSH
113746: CALL_OW 69
113750: PUSH
113751: FOR_IN
113752: IFFALSE 113804
// if IsSelected ( i ) then
113754: LD_VAR 0 2
113758: PPUSH
113759: CALL_OW 306
113763: IFFALSE 113802
// begin for j := 1 to 4 do
113765: LD_ADDR_VAR 0 3
113769: PUSH
113770: DOUBLE
113771: LD_INT 1
113773: DEC
113774: ST_TO_ADDR
113775: LD_INT 4
113777: PUSH
113778: FOR_TO
113779: IFFALSE 113800
// SetSkill ( i , j , 10 ) ;
113781: LD_VAR 0 2
113785: PPUSH
113786: LD_VAR 0 3
113790: PPUSH
113791: LD_INT 10
113793: PPUSH
113794: CALL_OW 237
113798: GO 113778
113800: POP
113801: POP
// end ;
113802: GO 113751
113804: POP
113805: POP
// end ;
113806: LD_VAR 0 1
113810: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
113811: LD_INT 0
113813: PPUSH
113814: PPUSH
113815: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
113816: LD_ADDR_VAR 0 2
113820: PUSH
113821: LD_INT 22
113823: PUSH
113824: LD_OWVAR 2
113828: PUSH
113829: EMPTY
113830: LIST
113831: LIST
113832: PUSH
113833: LD_INT 21
113835: PUSH
113836: LD_INT 1
113838: PUSH
113839: EMPTY
113840: LIST
113841: LIST
113842: PUSH
113843: EMPTY
113844: LIST
113845: LIST
113846: PPUSH
113847: CALL_OW 69
113851: PUSH
113852: FOR_IN
113853: IFFALSE 113894
// begin for j := 1 to 4 do
113855: LD_ADDR_VAR 0 3
113859: PUSH
113860: DOUBLE
113861: LD_INT 1
113863: DEC
113864: ST_TO_ADDR
113865: LD_INT 4
113867: PUSH
113868: FOR_TO
113869: IFFALSE 113890
// SetSkill ( i , j , 10 ) ;
113871: LD_VAR 0 2
113875: PPUSH
113876: LD_VAR 0 3
113880: PPUSH
113881: LD_INT 10
113883: PPUSH
113884: CALL_OW 237
113888: GO 113868
113890: POP
113891: POP
// end ;
113892: GO 113852
113894: POP
113895: POP
// end ;
113896: LD_VAR 0 1
113900: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
113901: LD_INT 0
113903: PPUSH
// uc_side := your_side ;
113904: LD_ADDR_OWVAR 20
113908: PUSH
113909: LD_OWVAR 2
113913: ST_TO_ADDR
// uc_nation := nation ;
113914: LD_ADDR_OWVAR 21
113918: PUSH
113919: LD_VAR 0 1
113923: ST_TO_ADDR
// InitHc ;
113924: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
113928: LD_INT 0
113930: PPUSH
113931: LD_VAR 0 2
113935: PPUSH
113936: LD_VAR 0 3
113940: PPUSH
113941: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
113945: LD_VAR 0 4
113949: PPUSH
113950: LD_VAR 0 5
113954: PPUSH
113955: CALL_OW 428
113959: PUSH
113960: LD_INT 0
113962: EQUAL
113963: IFFALSE 113987
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
113965: CALL_OW 44
113969: PPUSH
113970: LD_VAR 0 4
113974: PPUSH
113975: LD_VAR 0 5
113979: PPUSH
113980: LD_INT 1
113982: PPUSH
113983: CALL_OW 48
// end ;
113987: LD_VAR 0 6
113991: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
113992: LD_INT 0
113994: PPUSH
113995: PPUSH
// uc_side := your_side ;
113996: LD_ADDR_OWVAR 20
114000: PUSH
114001: LD_OWVAR 2
114005: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
114006: LD_VAR 0 1
114010: PUSH
114011: LD_INT 1
114013: PUSH
114014: LD_INT 2
114016: PUSH
114017: LD_INT 3
114019: PUSH
114020: LD_INT 4
114022: PUSH
114023: LD_INT 5
114025: PUSH
114026: EMPTY
114027: LIST
114028: LIST
114029: LIST
114030: LIST
114031: LIST
114032: IN
114033: IFFALSE 114045
// uc_nation := nation_american else
114035: LD_ADDR_OWVAR 21
114039: PUSH
114040: LD_INT 1
114042: ST_TO_ADDR
114043: GO 114088
// if chassis in [ 11 , 12 , 13 , 14 ] then
114045: LD_VAR 0 1
114049: PUSH
114050: LD_INT 11
114052: PUSH
114053: LD_INT 12
114055: PUSH
114056: LD_INT 13
114058: PUSH
114059: LD_INT 14
114061: PUSH
114062: EMPTY
114063: LIST
114064: LIST
114065: LIST
114066: LIST
114067: IN
114068: IFFALSE 114080
// uc_nation := nation_arabian else
114070: LD_ADDR_OWVAR 21
114074: PUSH
114075: LD_INT 2
114077: ST_TO_ADDR
114078: GO 114088
// uc_nation := nation_russian ;
114080: LD_ADDR_OWVAR 21
114084: PUSH
114085: LD_INT 3
114087: ST_TO_ADDR
// vc_chassis := chassis ;
114088: LD_ADDR_OWVAR 37
114092: PUSH
114093: LD_VAR 0 1
114097: ST_TO_ADDR
// vc_engine := engine ;
114098: LD_ADDR_OWVAR 39
114102: PUSH
114103: LD_VAR 0 2
114107: ST_TO_ADDR
// vc_control := control ;
114108: LD_ADDR_OWVAR 38
114112: PUSH
114113: LD_VAR 0 3
114117: ST_TO_ADDR
// vc_weapon := weapon ;
114118: LD_ADDR_OWVAR 40
114122: PUSH
114123: LD_VAR 0 4
114127: ST_TO_ADDR
// un := CreateVehicle ;
114128: LD_ADDR_VAR 0 8
114132: PUSH
114133: CALL_OW 45
114137: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
114138: LD_VAR 0 8
114142: PPUSH
114143: LD_INT 0
114145: PPUSH
114146: LD_INT 5
114148: PPUSH
114149: CALL_OW 12
114153: PPUSH
114154: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
114158: LD_VAR 0 8
114162: PPUSH
114163: LD_VAR 0 5
114167: PPUSH
114168: LD_VAR 0 6
114172: PPUSH
114173: LD_INT 1
114175: PPUSH
114176: CALL_OW 48
// end ;
114180: LD_VAR 0 7
114184: RET
// export hInvincible ; every 1 do
114185: GO 114187
114187: DISABLE
// hInvincible := [ ] ;
114188: LD_ADDR_EXP 209
114192: PUSH
114193: EMPTY
114194: ST_TO_ADDR
114195: END
// every 10 do var i ;
114196: GO 114198
114198: DISABLE
114199: LD_INT 0
114201: PPUSH
// begin enable ;
114202: ENABLE
// if not hInvincible then
114203: LD_EXP 209
114207: NOT
114208: IFFALSE 114212
// exit ;
114210: GO 114256
// for i in hInvincible do
114212: LD_ADDR_VAR 0 1
114216: PUSH
114217: LD_EXP 209
114221: PUSH
114222: FOR_IN
114223: IFFALSE 114254
// if GetLives ( i ) < 1000 then
114225: LD_VAR 0 1
114229: PPUSH
114230: CALL_OW 256
114234: PUSH
114235: LD_INT 1000
114237: LESS
114238: IFFALSE 114252
// SetLives ( i , 1000 ) ;
114240: LD_VAR 0 1
114244: PPUSH
114245: LD_INT 1000
114247: PPUSH
114248: CALL_OW 234
114252: GO 114222
114254: POP
114255: POP
// end ;
114256: PPOPN 1
114258: END
// export function hHackInvincible ; var i ; begin
114259: LD_INT 0
114261: PPUSH
114262: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
114263: LD_ADDR_VAR 0 2
114267: PUSH
114268: LD_INT 2
114270: PUSH
114271: LD_INT 21
114273: PUSH
114274: LD_INT 1
114276: PUSH
114277: EMPTY
114278: LIST
114279: LIST
114280: PUSH
114281: LD_INT 21
114283: PUSH
114284: LD_INT 2
114286: PUSH
114287: EMPTY
114288: LIST
114289: LIST
114290: PUSH
114291: EMPTY
114292: LIST
114293: LIST
114294: LIST
114295: PPUSH
114296: CALL_OW 69
114300: PUSH
114301: FOR_IN
114302: IFFALSE 114363
// if IsSelected ( i ) then
114304: LD_VAR 0 2
114308: PPUSH
114309: CALL_OW 306
114313: IFFALSE 114361
// begin if i in hInvincible then
114315: LD_VAR 0 2
114319: PUSH
114320: LD_EXP 209
114324: IN
114325: IFFALSE 114345
// hInvincible := hInvincible diff i else
114327: LD_ADDR_EXP 209
114331: PUSH
114332: LD_EXP 209
114336: PUSH
114337: LD_VAR 0 2
114341: DIFF
114342: ST_TO_ADDR
114343: GO 114361
// hInvincible := hInvincible union i ;
114345: LD_ADDR_EXP 209
114349: PUSH
114350: LD_EXP 209
114354: PUSH
114355: LD_VAR 0 2
114359: UNION
114360: ST_TO_ADDR
// end ;
114361: GO 114301
114363: POP
114364: POP
// end ;
114365: LD_VAR 0 1
114369: RET
// export function hHackInvisible ; var i , j ; begin
114370: LD_INT 0
114372: PPUSH
114373: PPUSH
114374: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114375: LD_ADDR_VAR 0 2
114379: PUSH
114380: LD_INT 21
114382: PUSH
114383: LD_INT 1
114385: PUSH
114386: EMPTY
114387: LIST
114388: LIST
114389: PPUSH
114390: CALL_OW 69
114394: PUSH
114395: FOR_IN
114396: IFFALSE 114420
// if IsSelected ( i ) then
114398: LD_VAR 0 2
114402: PPUSH
114403: CALL_OW 306
114407: IFFALSE 114418
// ComForceInvisible ( i ) ;
114409: LD_VAR 0 2
114413: PPUSH
114414: CALL_OW 496
114418: GO 114395
114420: POP
114421: POP
// end ;
114422: LD_VAR 0 1
114426: RET
// export function hHackChangeYourSide ; begin
114427: LD_INT 0
114429: PPUSH
// if your_side = 8 then
114430: LD_OWVAR 2
114434: PUSH
114435: LD_INT 8
114437: EQUAL
114438: IFFALSE 114450
// your_side := 0 else
114440: LD_ADDR_OWVAR 2
114444: PUSH
114445: LD_INT 0
114447: ST_TO_ADDR
114448: GO 114464
// your_side := your_side + 1 ;
114450: LD_ADDR_OWVAR 2
114454: PUSH
114455: LD_OWVAR 2
114459: PUSH
114460: LD_INT 1
114462: PLUS
114463: ST_TO_ADDR
// end ;
114464: LD_VAR 0 1
114468: RET
// export function hHackChangeUnitSide ; var i , j ; begin
114469: LD_INT 0
114471: PPUSH
114472: PPUSH
114473: PPUSH
// for i in all_units do
114474: LD_ADDR_VAR 0 2
114478: PUSH
114479: LD_OWVAR 3
114483: PUSH
114484: FOR_IN
114485: IFFALSE 114563
// if IsSelected ( i ) then
114487: LD_VAR 0 2
114491: PPUSH
114492: CALL_OW 306
114496: IFFALSE 114561
// begin j := GetSide ( i ) ;
114498: LD_ADDR_VAR 0 3
114502: PUSH
114503: LD_VAR 0 2
114507: PPUSH
114508: CALL_OW 255
114512: ST_TO_ADDR
// if j = 8 then
114513: LD_VAR 0 3
114517: PUSH
114518: LD_INT 8
114520: EQUAL
114521: IFFALSE 114533
// j := 0 else
114523: LD_ADDR_VAR 0 3
114527: PUSH
114528: LD_INT 0
114530: ST_TO_ADDR
114531: GO 114547
// j := j + 1 ;
114533: LD_ADDR_VAR 0 3
114537: PUSH
114538: LD_VAR 0 3
114542: PUSH
114543: LD_INT 1
114545: PLUS
114546: ST_TO_ADDR
// SetSide ( i , j ) ;
114547: LD_VAR 0 2
114551: PPUSH
114552: LD_VAR 0 3
114556: PPUSH
114557: CALL_OW 235
// end ;
114561: GO 114484
114563: POP
114564: POP
// end ;
114565: LD_VAR 0 1
114569: RET
// export function hHackFog ; begin
114570: LD_INT 0
114572: PPUSH
// FogOff ( true ) ;
114573: LD_INT 1
114575: PPUSH
114576: CALL_OW 344
// end ;
114580: LD_VAR 0 1
114584: RET
// export function hHackTeleport ( unit , x , y ) ; begin
114585: LD_INT 0
114587: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
114588: LD_VAR 0 1
114592: PPUSH
114593: LD_VAR 0 2
114597: PPUSH
114598: LD_VAR 0 3
114602: PPUSH
114603: LD_INT 1
114605: PPUSH
114606: LD_INT 1
114608: PPUSH
114609: CALL_OW 483
// CenterOnXY ( x , y ) ;
114613: LD_VAR 0 2
114617: PPUSH
114618: LD_VAR 0 3
114622: PPUSH
114623: CALL_OW 84
// end ; end_of_file
114627: LD_VAR 0 4
114631: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
114632: LD_INT 0
114634: PPUSH
114635: PPUSH
114636: PPUSH
114637: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
114638: LD_VAR 0 1
114642: PPUSH
114643: CALL_OW 264
114647: PUSH
114648: LD_EXP 99
114652: EQUAL
114653: IFFALSE 114725
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
114655: LD_INT 68
114657: PPUSH
114658: LD_VAR 0 1
114662: PPUSH
114663: CALL_OW 255
114667: PPUSH
114668: CALL_OW 321
114672: PUSH
114673: LD_INT 2
114675: EQUAL
114676: IFFALSE 114688
// eff := 70 else
114678: LD_ADDR_VAR 0 4
114682: PUSH
114683: LD_INT 70
114685: ST_TO_ADDR
114686: GO 114696
// eff := 30 ;
114688: LD_ADDR_VAR 0 4
114692: PUSH
114693: LD_INT 30
114695: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
114696: LD_VAR 0 1
114700: PPUSH
114701: CALL_OW 250
114705: PPUSH
114706: LD_VAR 0 1
114710: PPUSH
114711: CALL_OW 251
114715: PPUSH
114716: LD_VAR 0 4
114720: PPUSH
114721: CALL_OW 495
// end ; end ;
114725: LD_VAR 0 2
114729: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
114730: LD_INT 0
114732: PPUSH
// end ;
114733: LD_VAR 0 4
114737: RET
// export function SOS_Command ( cmd ) ; begin
114738: LD_INT 0
114740: PPUSH
// end ;
114741: LD_VAR 0 2
114745: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
114746: LD_INT 0
114748: PPUSH
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
114749: LD_VAR 0 1
114753: PUSH
114754: LD_INT 254
114756: EQUAL
114757: PUSH
114758: LD_VAR 0 2
114762: PPUSH
114763: CALL_OW 264
114767: PUSH
114768: LD_EXP 97
114772: EQUAL
114773: AND
114774: PUSH
114775: LD_VAR 0 3
114779: PPUSH
114780: CALL_OW 263
114784: PUSH
114785: LD_INT 3
114787: EQUAL
114788: AND
114789: IFFALSE 114805
// HackDestroyVehicle ( unit , selectedUnit ) ;
114791: LD_VAR 0 2
114795: PPUSH
114796: LD_VAR 0 3
114800: PPUSH
114801: CALL 116314 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
114805: LD_VAR 0 1
114809: PUSH
114810: LD_INT 255
114812: EQUAL
114813: PUSH
114814: LD_VAR 0 2
114818: PPUSH
114819: CALL_OW 264
114823: PUSH
114824: LD_INT 14
114826: PUSH
114827: LD_INT 53
114829: PUSH
114830: EMPTY
114831: LIST
114832: LIST
114833: IN
114834: AND
114835: PUSH
114836: LD_VAR 0 4
114840: PPUSH
114841: LD_VAR 0 5
114845: PPUSH
114846: CALL_OW 488
114850: AND
114851: IFFALSE 114875
// CutTreeXYR ( unit , x , y , 12 ) ;
114853: LD_VAR 0 2
114857: PPUSH
114858: LD_VAR 0 4
114862: PPUSH
114863: LD_VAR 0 5
114867: PPUSH
114868: LD_INT 12
114870: PPUSH
114871: CALL 114880 0 4
// end ;
114875: LD_VAR 0 6
114879: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
114880: LD_INT 0
114882: PPUSH
114883: PPUSH
114884: PPUSH
114885: PPUSH
114886: PPUSH
114887: PPUSH
114888: PPUSH
114889: PPUSH
114890: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
114891: LD_VAR 0 1
114895: NOT
114896: PUSH
114897: LD_VAR 0 2
114901: PPUSH
114902: LD_VAR 0 3
114906: PPUSH
114907: CALL_OW 488
114911: NOT
114912: OR
114913: PUSH
114914: LD_VAR 0 4
114918: NOT
114919: OR
114920: IFFALSE 114924
// exit ;
114922: GO 115264
// list := [ ] ;
114924: LD_ADDR_VAR 0 13
114928: PUSH
114929: EMPTY
114930: ST_TO_ADDR
// if x - r < 0 then
114931: LD_VAR 0 2
114935: PUSH
114936: LD_VAR 0 4
114940: MINUS
114941: PUSH
114942: LD_INT 0
114944: LESS
114945: IFFALSE 114957
// min_x := 0 else
114947: LD_ADDR_VAR 0 7
114951: PUSH
114952: LD_INT 0
114954: ST_TO_ADDR
114955: GO 114973
// min_x := x - r ;
114957: LD_ADDR_VAR 0 7
114961: PUSH
114962: LD_VAR 0 2
114966: PUSH
114967: LD_VAR 0 4
114971: MINUS
114972: ST_TO_ADDR
// if y - r < 0 then
114973: LD_VAR 0 3
114977: PUSH
114978: LD_VAR 0 4
114982: MINUS
114983: PUSH
114984: LD_INT 0
114986: LESS
114987: IFFALSE 114999
// min_y := 0 else
114989: LD_ADDR_VAR 0 8
114993: PUSH
114994: LD_INT 0
114996: ST_TO_ADDR
114997: GO 115015
// min_y := y - r ;
114999: LD_ADDR_VAR 0 8
115003: PUSH
115004: LD_VAR 0 3
115008: PUSH
115009: LD_VAR 0 4
115013: MINUS
115014: ST_TO_ADDR
// max_x := x + r ;
115015: LD_ADDR_VAR 0 9
115019: PUSH
115020: LD_VAR 0 2
115024: PUSH
115025: LD_VAR 0 4
115029: PLUS
115030: ST_TO_ADDR
// max_y := y + r ;
115031: LD_ADDR_VAR 0 10
115035: PUSH
115036: LD_VAR 0 3
115040: PUSH
115041: LD_VAR 0 4
115045: PLUS
115046: ST_TO_ADDR
// for _x = min_x to max_x do
115047: LD_ADDR_VAR 0 11
115051: PUSH
115052: DOUBLE
115053: LD_VAR 0 7
115057: DEC
115058: ST_TO_ADDR
115059: LD_VAR 0 9
115063: PUSH
115064: FOR_TO
115065: IFFALSE 115182
// for _y = min_y to max_y do
115067: LD_ADDR_VAR 0 12
115071: PUSH
115072: DOUBLE
115073: LD_VAR 0 8
115077: DEC
115078: ST_TO_ADDR
115079: LD_VAR 0 10
115083: PUSH
115084: FOR_TO
115085: IFFALSE 115178
// begin if not ValidHex ( _x , _y ) then
115087: LD_VAR 0 11
115091: PPUSH
115092: LD_VAR 0 12
115096: PPUSH
115097: CALL_OW 488
115101: NOT
115102: IFFALSE 115106
// continue ;
115104: GO 115084
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
115106: LD_VAR 0 11
115110: PPUSH
115111: LD_VAR 0 12
115115: PPUSH
115116: CALL_OW 351
115120: PUSH
115121: LD_VAR 0 11
115125: PPUSH
115126: LD_VAR 0 12
115130: PPUSH
115131: CALL_OW 554
115135: AND
115136: IFFALSE 115176
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
115138: LD_ADDR_VAR 0 13
115142: PUSH
115143: LD_VAR 0 13
115147: PPUSH
115148: LD_VAR 0 13
115152: PUSH
115153: LD_INT 1
115155: PLUS
115156: PPUSH
115157: LD_VAR 0 11
115161: PUSH
115162: LD_VAR 0 12
115166: PUSH
115167: EMPTY
115168: LIST
115169: LIST
115170: PPUSH
115171: CALL_OW 2
115175: ST_TO_ADDR
// end ;
115176: GO 115084
115178: POP
115179: POP
115180: GO 115064
115182: POP
115183: POP
// if not list then
115184: LD_VAR 0 13
115188: NOT
115189: IFFALSE 115193
// exit ;
115191: GO 115264
// for i in list do
115193: LD_ADDR_VAR 0 6
115197: PUSH
115198: LD_VAR 0 13
115202: PUSH
115203: FOR_IN
115204: IFFALSE 115262
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
115206: LD_VAR 0 1
115210: PPUSH
115211: LD_STRING M
115213: PUSH
115214: LD_VAR 0 6
115218: PUSH
115219: LD_INT 1
115221: ARRAY
115222: PUSH
115223: LD_VAR 0 6
115227: PUSH
115228: LD_INT 2
115230: ARRAY
115231: PUSH
115232: LD_INT 0
115234: PUSH
115235: LD_INT 0
115237: PUSH
115238: LD_INT 0
115240: PUSH
115241: LD_INT 0
115243: PUSH
115244: EMPTY
115245: LIST
115246: LIST
115247: LIST
115248: LIST
115249: LIST
115250: LIST
115251: LIST
115252: PUSH
115253: EMPTY
115254: LIST
115255: PPUSH
115256: CALL_OW 447
115260: GO 115203
115262: POP
115263: POP
// end ;
115264: LD_VAR 0 5
115268: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
115269: LD_EXP 210
115273: NOT
115274: IFFALSE 115324
115276: GO 115278
115278: DISABLE
// begin initHack := true ;
115279: LD_ADDR_EXP 210
115283: PUSH
115284: LD_INT 1
115286: ST_TO_ADDR
// hackTanks := [ ] ;
115287: LD_ADDR_EXP 211
115291: PUSH
115292: EMPTY
115293: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
115294: LD_ADDR_EXP 212
115298: PUSH
115299: EMPTY
115300: ST_TO_ADDR
// hackLimit := 3 ;
115301: LD_ADDR_EXP 213
115305: PUSH
115306: LD_INT 3
115308: ST_TO_ADDR
// hackDist := 12 ;
115309: LD_ADDR_EXP 214
115313: PUSH
115314: LD_INT 12
115316: ST_TO_ADDR
// hackCounter := [ ] ;
115317: LD_ADDR_EXP 215
115321: PUSH
115322: EMPTY
115323: ST_TO_ADDR
// end ;
115324: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
115325: LD_EXP 210
115329: PUSH
115330: LD_INT 34
115332: PUSH
115333: LD_EXP 97
115337: PUSH
115338: EMPTY
115339: LIST
115340: LIST
115341: PPUSH
115342: CALL_OW 69
115346: AND
115347: IFFALSE 115602
115349: GO 115351
115351: DISABLE
115352: LD_INT 0
115354: PPUSH
115355: PPUSH
// begin enable ;
115356: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
115357: LD_ADDR_VAR 0 1
115361: PUSH
115362: LD_INT 34
115364: PUSH
115365: LD_EXP 97
115369: PUSH
115370: EMPTY
115371: LIST
115372: LIST
115373: PPUSH
115374: CALL_OW 69
115378: PUSH
115379: FOR_IN
115380: IFFALSE 115600
// begin if not i in hackTanks then
115382: LD_VAR 0 1
115386: PUSH
115387: LD_EXP 211
115391: IN
115392: NOT
115393: IFFALSE 115476
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
115395: LD_ADDR_EXP 211
115399: PUSH
115400: LD_EXP 211
115404: PPUSH
115405: LD_EXP 211
115409: PUSH
115410: LD_INT 1
115412: PLUS
115413: PPUSH
115414: LD_VAR 0 1
115418: PPUSH
115419: CALL_OW 1
115423: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
115424: LD_ADDR_EXP 212
115428: PUSH
115429: LD_EXP 212
115433: PPUSH
115434: LD_EXP 212
115438: PUSH
115439: LD_INT 1
115441: PLUS
115442: PPUSH
115443: EMPTY
115444: PPUSH
115445: CALL_OW 1
115449: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
115450: LD_ADDR_EXP 215
115454: PUSH
115455: LD_EXP 215
115459: PPUSH
115460: LD_EXP 215
115464: PUSH
115465: LD_INT 1
115467: PLUS
115468: PPUSH
115469: EMPTY
115470: PPUSH
115471: CALL_OW 1
115475: ST_TO_ADDR
// end ; if not IsOk ( i ) then
115476: LD_VAR 0 1
115480: PPUSH
115481: CALL_OW 302
115485: NOT
115486: IFFALSE 115499
// begin HackUnlinkAll ( i ) ;
115488: LD_VAR 0 1
115492: PPUSH
115493: CALL 115605 0 1
// continue ;
115497: GO 115379
// end ; HackCheckCapturedStatus ( i ) ;
115499: LD_VAR 0 1
115503: PPUSH
115504: CALL 116048 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
115508: LD_ADDR_VAR 0 2
115512: PUSH
115513: LD_INT 81
115515: PUSH
115516: LD_VAR 0 1
115520: PPUSH
115521: CALL_OW 255
115525: PUSH
115526: EMPTY
115527: LIST
115528: LIST
115529: PUSH
115530: LD_INT 33
115532: PUSH
115533: LD_INT 3
115535: PUSH
115536: EMPTY
115537: LIST
115538: LIST
115539: PUSH
115540: LD_INT 91
115542: PUSH
115543: LD_VAR 0 1
115547: PUSH
115548: LD_EXP 214
115552: PUSH
115553: EMPTY
115554: LIST
115555: LIST
115556: LIST
115557: PUSH
115558: LD_INT 50
115560: PUSH
115561: EMPTY
115562: LIST
115563: PUSH
115564: EMPTY
115565: LIST
115566: LIST
115567: LIST
115568: LIST
115569: PPUSH
115570: CALL_OW 69
115574: ST_TO_ADDR
// if not tmp then
115575: LD_VAR 0 2
115579: NOT
115580: IFFALSE 115584
// continue ;
115582: GO 115379
// HackLink ( i , tmp ) ;
115584: LD_VAR 0 1
115588: PPUSH
115589: LD_VAR 0 2
115593: PPUSH
115594: CALL 115741 0 2
// end ;
115598: GO 115379
115600: POP
115601: POP
// end ;
115602: PPOPN 2
115604: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
115605: LD_INT 0
115607: PPUSH
115608: PPUSH
115609: PPUSH
// if not hack in hackTanks then
115610: LD_VAR 0 1
115614: PUSH
115615: LD_EXP 211
115619: IN
115620: NOT
115621: IFFALSE 115625
// exit ;
115623: GO 115736
// index := GetElementIndex ( hackTanks , hack ) ;
115625: LD_ADDR_VAR 0 4
115629: PUSH
115630: LD_EXP 211
115634: PPUSH
115635: LD_VAR 0 1
115639: PPUSH
115640: CALL 69835 0 2
115644: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
115645: LD_EXP 212
115649: PUSH
115650: LD_VAR 0 4
115654: ARRAY
115655: IFFALSE 115736
// begin for i in hackTanksCaptured [ index ] do
115657: LD_ADDR_VAR 0 3
115661: PUSH
115662: LD_EXP 212
115666: PUSH
115667: LD_VAR 0 4
115671: ARRAY
115672: PUSH
115673: FOR_IN
115674: IFFALSE 115700
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
115676: LD_VAR 0 3
115680: PUSH
115681: LD_INT 1
115683: ARRAY
115684: PPUSH
115685: LD_VAR 0 3
115689: PUSH
115690: LD_INT 2
115692: ARRAY
115693: PPUSH
115694: CALL_OW 235
115698: GO 115673
115700: POP
115701: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
115702: LD_ADDR_EXP 212
115706: PUSH
115707: LD_EXP 212
115711: PPUSH
115712: LD_VAR 0 4
115716: PPUSH
115717: EMPTY
115718: PPUSH
115719: CALL_OW 1
115723: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
115724: LD_VAR 0 1
115728: PPUSH
115729: LD_INT 0
115731: PPUSH
115732: CALL_OW 505
// end ; end ;
115736: LD_VAR 0 2
115740: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
115741: LD_INT 0
115743: PPUSH
115744: PPUSH
115745: PPUSH
// if not hack in hackTanks or not vehicles then
115746: LD_VAR 0 1
115750: PUSH
115751: LD_EXP 211
115755: IN
115756: NOT
115757: PUSH
115758: LD_VAR 0 2
115762: NOT
115763: OR
115764: IFFALSE 115768
// exit ;
115766: GO 116043
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
115768: LD_ADDR_VAR 0 2
115772: PUSH
115773: LD_VAR 0 1
115777: PPUSH
115778: LD_VAR 0 2
115782: PPUSH
115783: LD_INT 1
115785: PPUSH
115786: LD_INT 1
115788: PPUSH
115789: CALL 70485 0 4
115793: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
115794: LD_ADDR_VAR 0 5
115798: PUSH
115799: LD_EXP 211
115803: PPUSH
115804: LD_VAR 0 1
115808: PPUSH
115809: CALL 69835 0 2
115813: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
115814: LD_EXP 212
115818: PUSH
115819: LD_VAR 0 5
115823: ARRAY
115824: PUSH
115825: LD_EXP 213
115829: LESS
115830: IFFALSE 116019
// begin for i := 1 to vehicles do
115832: LD_ADDR_VAR 0 4
115836: PUSH
115837: DOUBLE
115838: LD_INT 1
115840: DEC
115841: ST_TO_ADDR
115842: LD_VAR 0 2
115846: PUSH
115847: FOR_TO
115848: IFFALSE 116017
// begin if hackTanksCaptured [ index ] = hackLimit then
115850: LD_EXP 212
115854: PUSH
115855: LD_VAR 0 5
115859: ARRAY
115860: PUSH
115861: LD_EXP 213
115865: EQUAL
115866: IFFALSE 115870
// break ;
115868: GO 116017
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
115870: LD_ADDR_EXP 215
115874: PUSH
115875: LD_EXP 215
115879: PPUSH
115880: LD_VAR 0 5
115884: PPUSH
115885: LD_EXP 215
115889: PUSH
115890: LD_VAR 0 5
115894: ARRAY
115895: PUSH
115896: LD_INT 1
115898: PLUS
115899: PPUSH
115900: CALL_OW 1
115904: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
115905: LD_ADDR_EXP 212
115909: PUSH
115910: LD_EXP 212
115914: PPUSH
115915: LD_VAR 0 5
115919: PUSH
115920: LD_EXP 212
115924: PUSH
115925: LD_VAR 0 5
115929: ARRAY
115930: PUSH
115931: LD_INT 1
115933: PLUS
115934: PUSH
115935: EMPTY
115936: LIST
115937: LIST
115938: PPUSH
115939: LD_VAR 0 2
115943: PUSH
115944: LD_VAR 0 4
115948: ARRAY
115949: PUSH
115950: LD_VAR 0 2
115954: PUSH
115955: LD_VAR 0 4
115959: ARRAY
115960: PPUSH
115961: CALL_OW 255
115965: PUSH
115966: EMPTY
115967: LIST
115968: LIST
115969: PPUSH
115970: CALL 70050 0 3
115974: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
115975: LD_VAR 0 2
115979: PUSH
115980: LD_VAR 0 4
115984: ARRAY
115985: PPUSH
115986: LD_VAR 0 1
115990: PPUSH
115991: CALL_OW 255
115995: PPUSH
115996: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
116000: LD_VAR 0 2
116004: PUSH
116005: LD_VAR 0 4
116009: ARRAY
116010: PPUSH
116011: CALL_OW 141
// end ;
116015: GO 115847
116017: POP
116018: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
116019: LD_VAR 0 1
116023: PPUSH
116024: LD_EXP 212
116028: PUSH
116029: LD_VAR 0 5
116033: ARRAY
116034: PUSH
116035: LD_INT 0
116037: PLUS
116038: PPUSH
116039: CALL_OW 505
// end ;
116043: LD_VAR 0 3
116047: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
116048: LD_INT 0
116050: PPUSH
116051: PPUSH
116052: PPUSH
116053: PPUSH
// if not hack in hackTanks then
116054: LD_VAR 0 1
116058: PUSH
116059: LD_EXP 211
116063: IN
116064: NOT
116065: IFFALSE 116069
// exit ;
116067: GO 116309
// index := GetElementIndex ( hackTanks , hack ) ;
116069: LD_ADDR_VAR 0 4
116073: PUSH
116074: LD_EXP 211
116078: PPUSH
116079: LD_VAR 0 1
116083: PPUSH
116084: CALL 69835 0 2
116088: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
116089: LD_ADDR_VAR 0 3
116093: PUSH
116094: DOUBLE
116095: LD_EXP 212
116099: PUSH
116100: LD_VAR 0 4
116104: ARRAY
116105: INC
116106: ST_TO_ADDR
116107: LD_INT 1
116109: PUSH
116110: FOR_DOWNTO
116111: IFFALSE 116283
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
116113: LD_ADDR_VAR 0 5
116117: PUSH
116118: LD_EXP 212
116122: PUSH
116123: LD_VAR 0 4
116127: ARRAY
116128: PUSH
116129: LD_VAR 0 3
116133: ARRAY
116134: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
116135: LD_VAR 0 5
116139: PUSH
116140: LD_INT 1
116142: ARRAY
116143: PPUSH
116144: CALL_OW 302
116148: NOT
116149: PUSH
116150: LD_VAR 0 5
116154: PUSH
116155: LD_INT 1
116157: ARRAY
116158: PPUSH
116159: CALL_OW 255
116163: PUSH
116164: LD_VAR 0 1
116168: PPUSH
116169: CALL_OW 255
116173: NONEQUAL
116174: OR
116175: IFFALSE 116281
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
116177: LD_VAR 0 5
116181: PUSH
116182: LD_INT 1
116184: ARRAY
116185: PPUSH
116186: CALL_OW 305
116190: PUSH
116191: LD_VAR 0 5
116195: PUSH
116196: LD_INT 1
116198: ARRAY
116199: PPUSH
116200: CALL_OW 255
116204: PUSH
116205: LD_VAR 0 1
116209: PPUSH
116210: CALL_OW 255
116214: EQUAL
116215: AND
116216: IFFALSE 116240
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
116218: LD_VAR 0 5
116222: PUSH
116223: LD_INT 1
116225: ARRAY
116226: PPUSH
116227: LD_VAR 0 5
116231: PUSH
116232: LD_INT 2
116234: ARRAY
116235: PPUSH
116236: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
116240: LD_ADDR_EXP 212
116244: PUSH
116245: LD_EXP 212
116249: PPUSH
116250: LD_VAR 0 4
116254: PPUSH
116255: LD_EXP 212
116259: PUSH
116260: LD_VAR 0 4
116264: ARRAY
116265: PPUSH
116266: LD_VAR 0 3
116270: PPUSH
116271: CALL_OW 3
116275: PPUSH
116276: CALL_OW 1
116280: ST_TO_ADDR
// end ; end ;
116281: GO 116110
116283: POP
116284: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
116285: LD_VAR 0 1
116289: PPUSH
116290: LD_EXP 212
116294: PUSH
116295: LD_VAR 0 4
116299: ARRAY
116300: PUSH
116301: LD_INT 0
116303: PLUS
116304: PPUSH
116305: CALL_OW 505
// end ;
116309: LD_VAR 0 2
116313: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
116314: LD_INT 0
116316: PPUSH
116317: PPUSH
116318: PPUSH
116319: PPUSH
// if not hack in hackTanks then
116320: LD_VAR 0 1
116324: PUSH
116325: LD_EXP 211
116329: IN
116330: NOT
116331: IFFALSE 116335
// exit ;
116333: GO 116420
// index := GetElementIndex ( hackTanks , hack ) ;
116335: LD_ADDR_VAR 0 5
116339: PUSH
116340: LD_EXP 211
116344: PPUSH
116345: LD_VAR 0 1
116349: PPUSH
116350: CALL 69835 0 2
116354: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
116355: LD_ADDR_VAR 0 4
116359: PUSH
116360: DOUBLE
116361: LD_INT 1
116363: DEC
116364: ST_TO_ADDR
116365: LD_EXP 212
116369: PUSH
116370: LD_VAR 0 5
116374: ARRAY
116375: PUSH
116376: FOR_TO
116377: IFFALSE 116418
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
116379: LD_EXP 212
116383: PUSH
116384: LD_VAR 0 5
116388: ARRAY
116389: PUSH
116390: LD_VAR 0 4
116394: ARRAY
116395: PUSH
116396: LD_INT 1
116398: ARRAY
116399: PUSH
116400: LD_VAR 0 2
116404: EQUAL
116405: IFFALSE 116416
// KillUnit ( vehicle ) ;
116407: LD_VAR 0 2
116411: PPUSH
116412: CALL_OW 66
116416: GO 116376
116418: POP
116419: POP
// end ; end_of_file
116420: LD_VAR 0 3
116424: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
116425: LD_INT 0
116427: PPUSH
116428: PPUSH
116429: PPUSH
116430: PPUSH
116431: PPUSH
116432: PPUSH
116433: PPUSH
116434: PPUSH
116435: PPUSH
116436: PPUSH
116437: PPUSH
116438: PPUSH
116439: PPUSH
116440: PPUSH
116441: PPUSH
116442: PPUSH
116443: PPUSH
116444: PPUSH
116445: PPUSH
116446: PPUSH
116447: PPUSH
116448: PPUSH
116449: PPUSH
116450: PPUSH
116451: PPUSH
116452: PPUSH
116453: PPUSH
116454: PPUSH
116455: PPUSH
116456: PPUSH
116457: PPUSH
116458: PPUSH
116459: PPUSH
116460: PPUSH
// if not list then
116461: LD_VAR 0 1
116465: NOT
116466: IFFALSE 116470
// exit ;
116468: GO 121129
// base := list [ 1 ] ;
116470: LD_ADDR_VAR 0 3
116474: PUSH
116475: LD_VAR 0 1
116479: PUSH
116480: LD_INT 1
116482: ARRAY
116483: ST_TO_ADDR
// group := list [ 2 ] ;
116484: LD_ADDR_VAR 0 4
116488: PUSH
116489: LD_VAR 0 1
116493: PUSH
116494: LD_INT 2
116496: ARRAY
116497: ST_TO_ADDR
// path := list [ 3 ] ;
116498: LD_ADDR_VAR 0 5
116502: PUSH
116503: LD_VAR 0 1
116507: PUSH
116508: LD_INT 3
116510: ARRAY
116511: ST_TO_ADDR
// flags := list [ 4 ] ;
116512: LD_ADDR_VAR 0 6
116516: PUSH
116517: LD_VAR 0 1
116521: PUSH
116522: LD_INT 4
116524: ARRAY
116525: ST_TO_ADDR
// mined := [ ] ;
116526: LD_ADDR_VAR 0 27
116530: PUSH
116531: EMPTY
116532: ST_TO_ADDR
// bombed := [ ] ;
116533: LD_ADDR_VAR 0 28
116537: PUSH
116538: EMPTY
116539: ST_TO_ADDR
// healers := [ ] ;
116540: LD_ADDR_VAR 0 31
116544: PUSH
116545: EMPTY
116546: ST_TO_ADDR
// to_heal := [ ] ;
116547: LD_ADDR_VAR 0 30
116551: PUSH
116552: EMPTY
116553: ST_TO_ADDR
// repairs := [ ] ;
116554: LD_ADDR_VAR 0 33
116558: PUSH
116559: EMPTY
116560: ST_TO_ADDR
// to_repair := [ ] ;
116561: LD_ADDR_VAR 0 32
116565: PUSH
116566: EMPTY
116567: ST_TO_ADDR
// if not group or not path then
116568: LD_VAR 0 4
116572: NOT
116573: PUSH
116574: LD_VAR 0 5
116578: NOT
116579: OR
116580: IFFALSE 116584
// exit ;
116582: GO 121129
// side := GetSide ( group [ 1 ] ) ;
116584: LD_ADDR_VAR 0 35
116588: PUSH
116589: LD_VAR 0 4
116593: PUSH
116594: LD_INT 1
116596: ARRAY
116597: PPUSH
116598: CALL_OW 255
116602: ST_TO_ADDR
// if flags then
116603: LD_VAR 0 6
116607: IFFALSE 116751
// begin f_ignore_area := flags [ 1 ] ;
116609: LD_ADDR_VAR 0 17
116613: PUSH
116614: LD_VAR 0 6
116618: PUSH
116619: LD_INT 1
116621: ARRAY
116622: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
116623: LD_ADDR_VAR 0 18
116627: PUSH
116628: LD_VAR 0 6
116632: PUSH
116633: LD_INT 2
116635: ARRAY
116636: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
116637: LD_ADDR_VAR 0 19
116641: PUSH
116642: LD_VAR 0 6
116646: PUSH
116647: LD_INT 3
116649: ARRAY
116650: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
116651: LD_ADDR_VAR 0 20
116655: PUSH
116656: LD_VAR 0 6
116660: PUSH
116661: LD_INT 4
116663: ARRAY
116664: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
116665: LD_ADDR_VAR 0 21
116669: PUSH
116670: LD_VAR 0 6
116674: PUSH
116675: LD_INT 5
116677: ARRAY
116678: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
116679: LD_ADDR_VAR 0 22
116683: PUSH
116684: LD_VAR 0 6
116688: PUSH
116689: LD_INT 6
116691: ARRAY
116692: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
116693: LD_ADDR_VAR 0 23
116697: PUSH
116698: LD_VAR 0 6
116702: PUSH
116703: LD_INT 7
116705: ARRAY
116706: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
116707: LD_ADDR_VAR 0 24
116711: PUSH
116712: LD_VAR 0 6
116716: PUSH
116717: LD_INT 8
116719: ARRAY
116720: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
116721: LD_ADDR_VAR 0 25
116725: PUSH
116726: LD_VAR 0 6
116730: PUSH
116731: LD_INT 9
116733: ARRAY
116734: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
116735: LD_ADDR_VAR 0 26
116739: PUSH
116740: LD_VAR 0 6
116744: PUSH
116745: LD_INT 10
116747: ARRAY
116748: ST_TO_ADDR
// end else
116749: GO 116831
// begin f_ignore_area := false ;
116751: LD_ADDR_VAR 0 17
116755: PUSH
116756: LD_INT 0
116758: ST_TO_ADDR
// f_capture := false ;
116759: LD_ADDR_VAR 0 18
116763: PUSH
116764: LD_INT 0
116766: ST_TO_ADDR
// f_ignore_civ := false ;
116767: LD_ADDR_VAR 0 19
116771: PUSH
116772: LD_INT 0
116774: ST_TO_ADDR
// f_murder := false ;
116775: LD_ADDR_VAR 0 20
116779: PUSH
116780: LD_INT 0
116782: ST_TO_ADDR
// f_mines := false ;
116783: LD_ADDR_VAR 0 21
116787: PUSH
116788: LD_INT 0
116790: ST_TO_ADDR
// f_repair := false ;
116791: LD_ADDR_VAR 0 22
116795: PUSH
116796: LD_INT 0
116798: ST_TO_ADDR
// f_heal := false ;
116799: LD_ADDR_VAR 0 23
116803: PUSH
116804: LD_INT 0
116806: ST_TO_ADDR
// f_spacetime := false ;
116807: LD_ADDR_VAR 0 24
116811: PUSH
116812: LD_INT 0
116814: ST_TO_ADDR
// f_attack_depot := false ;
116815: LD_ADDR_VAR 0 25
116819: PUSH
116820: LD_INT 0
116822: ST_TO_ADDR
// f_crawl := false ;
116823: LD_ADDR_VAR 0 26
116827: PUSH
116828: LD_INT 0
116830: ST_TO_ADDR
// end ; if f_heal then
116831: LD_VAR 0 23
116835: IFFALSE 116862
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
116837: LD_ADDR_VAR 0 31
116841: PUSH
116842: LD_VAR 0 4
116846: PPUSH
116847: LD_INT 25
116849: PUSH
116850: LD_INT 4
116852: PUSH
116853: EMPTY
116854: LIST
116855: LIST
116856: PPUSH
116857: CALL_OW 72
116861: ST_TO_ADDR
// if f_repair then
116862: LD_VAR 0 22
116866: IFFALSE 116893
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
116868: LD_ADDR_VAR 0 33
116872: PUSH
116873: LD_VAR 0 4
116877: PPUSH
116878: LD_INT 25
116880: PUSH
116881: LD_INT 3
116883: PUSH
116884: EMPTY
116885: LIST
116886: LIST
116887: PPUSH
116888: CALL_OW 72
116892: ST_TO_ADDR
// units_path := [ ] ;
116893: LD_ADDR_VAR 0 16
116897: PUSH
116898: EMPTY
116899: ST_TO_ADDR
// for i = 1 to group do
116900: LD_ADDR_VAR 0 7
116904: PUSH
116905: DOUBLE
116906: LD_INT 1
116908: DEC
116909: ST_TO_ADDR
116910: LD_VAR 0 4
116914: PUSH
116915: FOR_TO
116916: IFFALSE 116945
// units_path := Replace ( units_path , i , path ) ;
116918: LD_ADDR_VAR 0 16
116922: PUSH
116923: LD_VAR 0 16
116927: PPUSH
116928: LD_VAR 0 7
116932: PPUSH
116933: LD_VAR 0 5
116937: PPUSH
116938: CALL_OW 1
116942: ST_TO_ADDR
116943: GO 116915
116945: POP
116946: POP
// repeat for i = group downto 1 do
116947: LD_ADDR_VAR 0 7
116951: PUSH
116952: DOUBLE
116953: LD_VAR 0 4
116957: INC
116958: ST_TO_ADDR
116959: LD_INT 1
116961: PUSH
116962: FOR_DOWNTO
116963: IFFALSE 121085
// begin wait ( 5 ) ;
116965: LD_INT 5
116967: PPUSH
116968: CALL_OW 67
// tmp := [ ] ;
116972: LD_ADDR_VAR 0 14
116976: PUSH
116977: EMPTY
116978: ST_TO_ADDR
// attacking := false ;
116979: LD_ADDR_VAR 0 29
116983: PUSH
116984: LD_INT 0
116986: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
116987: LD_VAR 0 4
116991: PUSH
116992: LD_VAR 0 7
116996: ARRAY
116997: PPUSH
116998: CALL_OW 301
117002: PUSH
117003: LD_VAR 0 4
117007: PUSH
117008: LD_VAR 0 7
117012: ARRAY
117013: NOT
117014: OR
117015: IFFALSE 117124
// begin if GetType ( group [ i ] ) = unit_human then
117017: LD_VAR 0 4
117021: PUSH
117022: LD_VAR 0 7
117026: ARRAY
117027: PPUSH
117028: CALL_OW 247
117032: PUSH
117033: LD_INT 1
117035: EQUAL
117036: IFFALSE 117082
// begin to_heal := to_heal diff group [ i ] ;
117038: LD_ADDR_VAR 0 30
117042: PUSH
117043: LD_VAR 0 30
117047: PUSH
117048: LD_VAR 0 4
117052: PUSH
117053: LD_VAR 0 7
117057: ARRAY
117058: DIFF
117059: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117060: LD_ADDR_VAR 0 31
117064: PUSH
117065: LD_VAR 0 31
117069: PUSH
117070: LD_VAR 0 4
117074: PUSH
117075: LD_VAR 0 7
117079: ARRAY
117080: DIFF
117081: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117082: LD_ADDR_VAR 0 4
117086: PUSH
117087: LD_VAR 0 4
117091: PPUSH
117092: LD_VAR 0 7
117096: PPUSH
117097: CALL_OW 3
117101: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117102: LD_ADDR_VAR 0 16
117106: PUSH
117107: LD_VAR 0 16
117111: PPUSH
117112: LD_VAR 0 7
117116: PPUSH
117117: CALL_OW 3
117121: ST_TO_ADDR
// continue ;
117122: GO 116962
// end ; if f_repair then
117124: LD_VAR 0 22
117128: IFFALSE 117617
// begin if GetType ( group [ i ] ) = unit_vehicle then
117130: LD_VAR 0 4
117134: PUSH
117135: LD_VAR 0 7
117139: ARRAY
117140: PPUSH
117141: CALL_OW 247
117145: PUSH
117146: LD_INT 2
117148: EQUAL
117149: IFFALSE 117339
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117151: LD_VAR 0 4
117155: PUSH
117156: LD_VAR 0 7
117160: ARRAY
117161: PPUSH
117162: CALL_OW 256
117166: PUSH
117167: LD_INT 700
117169: LESS
117170: PUSH
117171: LD_VAR 0 4
117175: PUSH
117176: LD_VAR 0 7
117180: ARRAY
117181: PUSH
117182: LD_VAR 0 32
117186: IN
117187: NOT
117188: AND
117189: IFFALSE 117213
// to_repair := to_repair union group [ i ] ;
117191: LD_ADDR_VAR 0 32
117195: PUSH
117196: LD_VAR 0 32
117200: PUSH
117201: LD_VAR 0 4
117205: PUSH
117206: LD_VAR 0 7
117210: ARRAY
117211: UNION
117212: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117213: LD_VAR 0 4
117217: PUSH
117218: LD_VAR 0 7
117222: ARRAY
117223: PPUSH
117224: CALL_OW 256
117228: PUSH
117229: LD_INT 1000
117231: EQUAL
117232: PUSH
117233: LD_VAR 0 4
117237: PUSH
117238: LD_VAR 0 7
117242: ARRAY
117243: PUSH
117244: LD_VAR 0 32
117248: IN
117249: AND
117250: IFFALSE 117274
// to_repair := to_repair diff group [ i ] ;
117252: LD_ADDR_VAR 0 32
117256: PUSH
117257: LD_VAR 0 32
117261: PUSH
117262: LD_VAR 0 4
117266: PUSH
117267: LD_VAR 0 7
117271: ARRAY
117272: DIFF
117273: ST_TO_ADDR
// if group [ i ] in to_repair then
117274: LD_VAR 0 4
117278: PUSH
117279: LD_VAR 0 7
117283: ARRAY
117284: PUSH
117285: LD_VAR 0 32
117289: IN
117290: IFFALSE 117337
// begin if not IsInArea ( group [ i ] , f_repair ) then
117292: LD_VAR 0 4
117296: PUSH
117297: LD_VAR 0 7
117301: ARRAY
117302: PPUSH
117303: LD_VAR 0 22
117307: PPUSH
117308: CALL_OW 308
117312: NOT
117313: IFFALSE 117335
// ComMoveToArea ( group [ i ] , f_repair ) ;
117315: LD_VAR 0 4
117319: PUSH
117320: LD_VAR 0 7
117324: ARRAY
117325: PPUSH
117326: LD_VAR 0 22
117330: PPUSH
117331: CALL_OW 113
// continue ;
117335: GO 116962
// end ; end else
117337: GO 117617
// if group [ i ] in repairs then
117339: LD_VAR 0 4
117343: PUSH
117344: LD_VAR 0 7
117348: ARRAY
117349: PUSH
117350: LD_VAR 0 33
117354: IN
117355: IFFALSE 117617
// begin if IsInUnit ( group [ i ] ) then
117357: LD_VAR 0 4
117361: PUSH
117362: LD_VAR 0 7
117366: ARRAY
117367: PPUSH
117368: CALL_OW 310
117372: IFFALSE 117440
// begin z := IsInUnit ( group [ i ] ) ;
117374: LD_ADDR_VAR 0 13
117378: PUSH
117379: LD_VAR 0 4
117383: PUSH
117384: LD_VAR 0 7
117388: ARRAY
117389: PPUSH
117390: CALL_OW 310
117394: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
117395: LD_VAR 0 13
117399: PUSH
117400: LD_VAR 0 32
117404: IN
117405: PUSH
117406: LD_VAR 0 13
117410: PPUSH
117411: LD_VAR 0 22
117415: PPUSH
117416: CALL_OW 308
117420: AND
117421: IFFALSE 117438
// ComExitVehicle ( group [ i ] ) ;
117423: LD_VAR 0 4
117427: PUSH
117428: LD_VAR 0 7
117432: ARRAY
117433: PPUSH
117434: CALL_OW 121
// end else
117438: GO 117617
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
117440: LD_ADDR_VAR 0 13
117444: PUSH
117445: LD_VAR 0 4
117449: PPUSH
117450: LD_INT 95
117452: PUSH
117453: LD_VAR 0 22
117457: PUSH
117458: EMPTY
117459: LIST
117460: LIST
117461: PUSH
117462: LD_INT 58
117464: PUSH
117465: EMPTY
117466: LIST
117467: PUSH
117468: EMPTY
117469: LIST
117470: LIST
117471: PPUSH
117472: CALL_OW 72
117476: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
117477: LD_VAR 0 4
117481: PUSH
117482: LD_VAR 0 7
117486: ARRAY
117487: PPUSH
117488: CALL_OW 314
117492: NOT
117493: IFFALSE 117615
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
117495: LD_ADDR_VAR 0 10
117499: PUSH
117500: LD_VAR 0 13
117504: PPUSH
117505: LD_VAR 0 4
117509: PUSH
117510: LD_VAR 0 7
117514: ARRAY
117515: PPUSH
117516: CALL_OW 74
117520: ST_TO_ADDR
// if not x then
117521: LD_VAR 0 10
117525: NOT
117526: IFFALSE 117530
// continue ;
117528: GO 116962
// if GetLives ( x ) < 1000 then
117530: LD_VAR 0 10
117534: PPUSH
117535: CALL_OW 256
117539: PUSH
117540: LD_INT 1000
117542: LESS
117543: IFFALSE 117567
// ComRepairVehicle ( group [ i ] , x ) else
117545: LD_VAR 0 4
117549: PUSH
117550: LD_VAR 0 7
117554: ARRAY
117555: PPUSH
117556: LD_VAR 0 10
117560: PPUSH
117561: CALL_OW 129
117565: GO 117615
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
117567: LD_VAR 0 23
117571: PUSH
117572: LD_VAR 0 4
117576: PUSH
117577: LD_VAR 0 7
117581: ARRAY
117582: PPUSH
117583: CALL_OW 256
117587: PUSH
117588: LD_INT 1000
117590: LESS
117591: AND
117592: NOT
117593: IFFALSE 117615
// ComEnterUnit ( group [ i ] , x ) ;
117595: LD_VAR 0 4
117599: PUSH
117600: LD_VAR 0 7
117604: ARRAY
117605: PPUSH
117606: LD_VAR 0 10
117610: PPUSH
117611: CALL_OW 120
// end ; continue ;
117615: GO 116962
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
117617: LD_VAR 0 23
117621: PUSH
117622: LD_VAR 0 4
117626: PUSH
117627: LD_VAR 0 7
117631: ARRAY
117632: PPUSH
117633: CALL_OW 247
117637: PUSH
117638: LD_INT 1
117640: EQUAL
117641: AND
117642: IFFALSE 118120
// begin if group [ i ] in healers then
117644: LD_VAR 0 4
117648: PUSH
117649: LD_VAR 0 7
117653: ARRAY
117654: PUSH
117655: LD_VAR 0 31
117659: IN
117660: IFFALSE 117933
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
117662: LD_VAR 0 4
117666: PUSH
117667: LD_VAR 0 7
117671: ARRAY
117672: PPUSH
117673: LD_VAR 0 23
117677: PPUSH
117678: CALL_OW 308
117682: NOT
117683: PUSH
117684: LD_VAR 0 4
117688: PUSH
117689: LD_VAR 0 7
117693: ARRAY
117694: PPUSH
117695: CALL_OW 314
117699: NOT
117700: AND
117701: IFFALSE 117725
// ComMoveToArea ( group [ i ] , f_heal ) else
117703: LD_VAR 0 4
117707: PUSH
117708: LD_VAR 0 7
117712: ARRAY
117713: PPUSH
117714: LD_VAR 0 23
117718: PPUSH
117719: CALL_OW 113
117723: GO 117931
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
117725: LD_VAR 0 4
117729: PUSH
117730: LD_VAR 0 7
117734: ARRAY
117735: PPUSH
117736: CALL 98422 0 1
117740: PPUSH
117741: CALL_OW 256
117745: PUSH
117746: LD_INT 1000
117748: EQUAL
117749: IFFALSE 117768
// ComStop ( group [ i ] ) else
117751: LD_VAR 0 4
117755: PUSH
117756: LD_VAR 0 7
117760: ARRAY
117761: PPUSH
117762: CALL_OW 141
117766: GO 117931
// if not HasTask ( group [ i ] ) and to_heal then
117768: LD_VAR 0 4
117772: PUSH
117773: LD_VAR 0 7
117777: ARRAY
117778: PPUSH
117779: CALL_OW 314
117783: NOT
117784: PUSH
117785: LD_VAR 0 30
117789: AND
117790: IFFALSE 117931
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
117792: LD_ADDR_VAR 0 13
117796: PUSH
117797: LD_VAR 0 30
117801: PPUSH
117802: LD_INT 3
117804: PUSH
117805: LD_INT 54
117807: PUSH
117808: EMPTY
117809: LIST
117810: PUSH
117811: EMPTY
117812: LIST
117813: LIST
117814: PPUSH
117815: CALL_OW 72
117819: PPUSH
117820: LD_VAR 0 4
117824: PUSH
117825: LD_VAR 0 7
117829: ARRAY
117830: PPUSH
117831: CALL_OW 74
117835: ST_TO_ADDR
// if z then
117836: LD_VAR 0 13
117840: IFFALSE 117931
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
117842: LD_INT 91
117844: PUSH
117845: LD_VAR 0 13
117849: PUSH
117850: LD_INT 10
117852: PUSH
117853: EMPTY
117854: LIST
117855: LIST
117856: LIST
117857: PUSH
117858: LD_INT 81
117860: PUSH
117861: LD_VAR 0 13
117865: PPUSH
117866: CALL_OW 255
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: PUSH
117875: EMPTY
117876: LIST
117877: LIST
117878: PPUSH
117879: CALL_OW 69
117883: PUSH
117884: LD_INT 0
117886: EQUAL
117887: IFFALSE 117911
// ComHeal ( group [ i ] , z ) else
117889: LD_VAR 0 4
117893: PUSH
117894: LD_VAR 0 7
117898: ARRAY
117899: PPUSH
117900: LD_VAR 0 13
117904: PPUSH
117905: CALL_OW 128
117909: GO 117931
// ComMoveToArea ( group [ i ] , f_heal ) ;
117911: LD_VAR 0 4
117915: PUSH
117916: LD_VAR 0 7
117920: ARRAY
117921: PPUSH
117922: LD_VAR 0 23
117926: PPUSH
117927: CALL_OW 113
// end ; continue ;
117931: GO 116962
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
117933: LD_VAR 0 4
117937: PUSH
117938: LD_VAR 0 7
117942: ARRAY
117943: PPUSH
117944: CALL_OW 256
117948: PUSH
117949: LD_INT 700
117951: LESS
117952: PUSH
117953: LD_VAR 0 4
117957: PUSH
117958: LD_VAR 0 7
117962: ARRAY
117963: PUSH
117964: LD_VAR 0 30
117968: IN
117969: NOT
117970: AND
117971: IFFALSE 117995
// to_heal := to_heal union group [ i ] ;
117973: LD_ADDR_VAR 0 30
117977: PUSH
117978: LD_VAR 0 30
117982: PUSH
117983: LD_VAR 0 4
117987: PUSH
117988: LD_VAR 0 7
117992: ARRAY
117993: UNION
117994: ST_TO_ADDR
// if group [ i ] in to_heal then
117995: LD_VAR 0 4
117999: PUSH
118000: LD_VAR 0 7
118004: ARRAY
118005: PUSH
118006: LD_VAR 0 30
118010: IN
118011: IFFALSE 118120
// begin if GetLives ( group [ i ] ) = 1000 then
118013: LD_VAR 0 4
118017: PUSH
118018: LD_VAR 0 7
118022: ARRAY
118023: PPUSH
118024: CALL_OW 256
118028: PUSH
118029: LD_INT 1000
118031: EQUAL
118032: IFFALSE 118058
// to_heal := to_heal diff group [ i ] else
118034: LD_ADDR_VAR 0 30
118038: PUSH
118039: LD_VAR 0 30
118043: PUSH
118044: LD_VAR 0 4
118048: PUSH
118049: LD_VAR 0 7
118053: ARRAY
118054: DIFF
118055: ST_TO_ADDR
118056: GO 118120
// begin if not IsInArea ( group [ i ] , to_heal ) then
118058: LD_VAR 0 4
118062: PUSH
118063: LD_VAR 0 7
118067: ARRAY
118068: PPUSH
118069: LD_VAR 0 30
118073: PPUSH
118074: CALL_OW 308
118078: NOT
118079: IFFALSE 118103
// ComMoveToArea ( group [ i ] , f_heal ) else
118081: LD_VAR 0 4
118085: PUSH
118086: LD_VAR 0 7
118090: ARRAY
118091: PPUSH
118092: LD_VAR 0 23
118096: PPUSH
118097: CALL_OW 113
118101: GO 118118
// ComHold ( group [ i ] ) ;
118103: LD_VAR 0 4
118107: PUSH
118108: LD_VAR 0 7
118112: ARRAY
118113: PPUSH
118114: CALL_OW 140
// continue ;
118118: GO 116962
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118120: LD_VAR 0 4
118124: PUSH
118125: LD_VAR 0 7
118129: ARRAY
118130: PPUSH
118131: LD_INT 10
118133: PPUSH
118134: CALL 96842 0 2
118138: NOT
118139: PUSH
118140: LD_VAR 0 16
118144: PUSH
118145: LD_VAR 0 7
118149: ARRAY
118150: PUSH
118151: EMPTY
118152: EQUAL
118153: NOT
118154: AND
118155: IFFALSE 118421
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118157: LD_VAR 0 4
118161: PUSH
118162: LD_VAR 0 7
118166: ARRAY
118167: PPUSH
118168: CALL_OW 262
118172: PUSH
118173: LD_INT 1
118175: PUSH
118176: LD_INT 2
118178: PUSH
118179: EMPTY
118180: LIST
118181: LIST
118182: IN
118183: IFFALSE 118224
// if GetFuel ( group [ i ] ) < 10 then
118185: LD_VAR 0 4
118189: PUSH
118190: LD_VAR 0 7
118194: ARRAY
118195: PPUSH
118196: CALL_OW 261
118200: PUSH
118201: LD_INT 10
118203: LESS
118204: IFFALSE 118224
// SetFuel ( group [ i ] , 12 ) ;
118206: LD_VAR 0 4
118210: PUSH
118211: LD_VAR 0 7
118215: ARRAY
118216: PPUSH
118217: LD_INT 12
118219: PPUSH
118220: CALL_OW 240
// if units_path [ i ] then
118224: LD_VAR 0 16
118228: PUSH
118229: LD_VAR 0 7
118233: ARRAY
118234: IFFALSE 118419
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118236: LD_VAR 0 4
118240: PUSH
118241: LD_VAR 0 7
118245: ARRAY
118246: PPUSH
118247: LD_VAR 0 16
118251: PUSH
118252: LD_VAR 0 7
118256: ARRAY
118257: PUSH
118258: LD_INT 1
118260: ARRAY
118261: PUSH
118262: LD_INT 1
118264: ARRAY
118265: PPUSH
118266: LD_VAR 0 16
118270: PUSH
118271: LD_VAR 0 7
118275: ARRAY
118276: PUSH
118277: LD_INT 1
118279: ARRAY
118280: PUSH
118281: LD_INT 2
118283: ARRAY
118284: PPUSH
118285: CALL_OW 297
118289: PUSH
118290: LD_INT 6
118292: GREATER
118293: IFFALSE 118368
// begin if not HasTask ( group [ i ] ) then
118295: LD_VAR 0 4
118299: PUSH
118300: LD_VAR 0 7
118304: ARRAY
118305: PPUSH
118306: CALL_OW 314
118310: NOT
118311: IFFALSE 118366
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
118313: LD_VAR 0 4
118317: PUSH
118318: LD_VAR 0 7
118322: ARRAY
118323: PPUSH
118324: LD_VAR 0 16
118328: PUSH
118329: LD_VAR 0 7
118333: ARRAY
118334: PUSH
118335: LD_INT 1
118337: ARRAY
118338: PUSH
118339: LD_INT 1
118341: ARRAY
118342: PPUSH
118343: LD_VAR 0 16
118347: PUSH
118348: LD_VAR 0 7
118352: ARRAY
118353: PUSH
118354: LD_INT 1
118356: ARRAY
118357: PUSH
118358: LD_INT 2
118360: ARRAY
118361: PPUSH
118362: CALL_OW 114
// end else
118366: GO 118419
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
118368: LD_ADDR_VAR 0 15
118372: PUSH
118373: LD_VAR 0 16
118377: PUSH
118378: LD_VAR 0 7
118382: ARRAY
118383: PPUSH
118384: LD_INT 1
118386: PPUSH
118387: CALL_OW 3
118391: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
118392: LD_ADDR_VAR 0 16
118396: PUSH
118397: LD_VAR 0 16
118401: PPUSH
118402: LD_VAR 0 7
118406: PPUSH
118407: LD_VAR 0 15
118411: PPUSH
118412: CALL_OW 1
118416: ST_TO_ADDR
// continue ;
118417: GO 116962
// end ; end ; end else
118419: GO 121083
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
118421: LD_ADDR_VAR 0 14
118425: PUSH
118426: LD_INT 81
118428: PUSH
118429: LD_VAR 0 4
118433: PUSH
118434: LD_VAR 0 7
118438: ARRAY
118439: PPUSH
118440: CALL_OW 255
118444: PUSH
118445: EMPTY
118446: LIST
118447: LIST
118448: PPUSH
118449: CALL_OW 69
118453: ST_TO_ADDR
// if not tmp then
118454: LD_VAR 0 14
118458: NOT
118459: IFFALSE 118463
// continue ;
118461: GO 116962
// if f_ignore_area then
118463: LD_VAR 0 17
118467: IFFALSE 118555
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
118469: LD_ADDR_VAR 0 15
118473: PUSH
118474: LD_VAR 0 14
118478: PPUSH
118479: LD_INT 3
118481: PUSH
118482: LD_INT 92
118484: PUSH
118485: LD_VAR 0 17
118489: PUSH
118490: LD_INT 1
118492: ARRAY
118493: PUSH
118494: LD_VAR 0 17
118498: PUSH
118499: LD_INT 2
118501: ARRAY
118502: PUSH
118503: LD_VAR 0 17
118507: PUSH
118508: LD_INT 3
118510: ARRAY
118511: PUSH
118512: EMPTY
118513: LIST
118514: LIST
118515: LIST
118516: LIST
118517: PUSH
118518: EMPTY
118519: LIST
118520: LIST
118521: PPUSH
118522: CALL_OW 72
118526: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118527: LD_VAR 0 14
118531: PUSH
118532: LD_VAR 0 15
118536: DIFF
118537: IFFALSE 118555
// tmp := tmp diff tmp2 ;
118539: LD_ADDR_VAR 0 14
118543: PUSH
118544: LD_VAR 0 14
118548: PUSH
118549: LD_VAR 0 15
118553: DIFF
118554: ST_TO_ADDR
// end ; if not f_murder then
118555: LD_VAR 0 20
118559: NOT
118560: IFFALSE 118618
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
118562: LD_ADDR_VAR 0 15
118566: PUSH
118567: LD_VAR 0 14
118571: PPUSH
118572: LD_INT 3
118574: PUSH
118575: LD_INT 50
118577: PUSH
118578: EMPTY
118579: LIST
118580: PUSH
118581: EMPTY
118582: LIST
118583: LIST
118584: PPUSH
118585: CALL_OW 72
118589: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
118590: LD_VAR 0 14
118594: PUSH
118595: LD_VAR 0 15
118599: DIFF
118600: IFFALSE 118618
// tmp := tmp diff tmp2 ;
118602: LD_ADDR_VAR 0 14
118606: PUSH
118607: LD_VAR 0 14
118611: PUSH
118612: LD_VAR 0 15
118616: DIFF
118617: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
118618: LD_ADDR_VAR 0 14
118622: PUSH
118623: LD_VAR 0 4
118627: PUSH
118628: LD_VAR 0 7
118632: ARRAY
118633: PPUSH
118634: LD_VAR 0 14
118638: PPUSH
118639: LD_INT 1
118641: PPUSH
118642: LD_INT 1
118644: PPUSH
118645: CALL 70485 0 4
118649: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
118650: LD_VAR 0 4
118654: PUSH
118655: LD_VAR 0 7
118659: ARRAY
118660: PPUSH
118661: CALL_OW 257
118665: PUSH
118666: LD_INT 1
118668: EQUAL
118669: IFFALSE 119117
// begin if WantPlant ( group [ i ] ) then
118671: LD_VAR 0 4
118675: PUSH
118676: LD_VAR 0 7
118680: ARRAY
118681: PPUSH
118682: CALL 69986 0 1
118686: IFFALSE 118690
// continue ;
118688: GO 116962
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
118690: LD_VAR 0 18
118694: PUSH
118695: LD_VAR 0 4
118699: PUSH
118700: LD_VAR 0 7
118704: ARRAY
118705: PPUSH
118706: CALL_OW 310
118710: NOT
118711: AND
118712: PUSH
118713: LD_VAR 0 14
118717: PUSH
118718: LD_INT 1
118720: ARRAY
118721: PUSH
118722: LD_VAR 0 14
118726: PPUSH
118727: LD_INT 21
118729: PUSH
118730: LD_INT 2
118732: PUSH
118733: EMPTY
118734: LIST
118735: LIST
118736: PUSH
118737: LD_INT 58
118739: PUSH
118740: EMPTY
118741: LIST
118742: PUSH
118743: EMPTY
118744: LIST
118745: LIST
118746: PPUSH
118747: CALL_OW 72
118751: IN
118752: AND
118753: IFFALSE 118789
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
118755: LD_VAR 0 4
118759: PUSH
118760: LD_VAR 0 7
118764: ARRAY
118765: PPUSH
118766: LD_VAR 0 14
118770: PUSH
118771: LD_INT 1
118773: ARRAY
118774: PPUSH
118775: CALL_OW 120
// attacking := true ;
118779: LD_ADDR_VAR 0 29
118783: PUSH
118784: LD_INT 1
118786: ST_TO_ADDR
// continue ;
118787: GO 116962
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
118789: LD_VAR 0 26
118793: PUSH
118794: LD_VAR 0 4
118798: PUSH
118799: LD_VAR 0 7
118803: ARRAY
118804: PPUSH
118805: CALL_OW 257
118809: PUSH
118810: LD_INT 1
118812: EQUAL
118813: AND
118814: PUSH
118815: LD_VAR 0 4
118819: PUSH
118820: LD_VAR 0 7
118824: ARRAY
118825: PPUSH
118826: CALL_OW 256
118830: PUSH
118831: LD_INT 800
118833: LESS
118834: AND
118835: PUSH
118836: LD_VAR 0 4
118840: PUSH
118841: LD_VAR 0 7
118845: ARRAY
118846: PPUSH
118847: CALL_OW 318
118851: NOT
118852: AND
118853: IFFALSE 118870
// ComCrawl ( group [ i ] ) ;
118855: LD_VAR 0 4
118859: PUSH
118860: LD_VAR 0 7
118864: ARRAY
118865: PPUSH
118866: CALL_OW 137
// if f_mines then
118870: LD_VAR 0 21
118874: IFFALSE 119117
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
118876: LD_VAR 0 14
118880: PUSH
118881: LD_INT 1
118883: ARRAY
118884: PPUSH
118885: CALL_OW 247
118889: PUSH
118890: LD_INT 3
118892: EQUAL
118893: PUSH
118894: LD_VAR 0 14
118898: PUSH
118899: LD_INT 1
118901: ARRAY
118902: PUSH
118903: LD_VAR 0 27
118907: IN
118908: NOT
118909: AND
118910: IFFALSE 119117
// begin x := GetX ( tmp [ 1 ] ) ;
118912: LD_ADDR_VAR 0 10
118916: PUSH
118917: LD_VAR 0 14
118921: PUSH
118922: LD_INT 1
118924: ARRAY
118925: PPUSH
118926: CALL_OW 250
118930: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
118931: LD_ADDR_VAR 0 11
118935: PUSH
118936: LD_VAR 0 14
118940: PUSH
118941: LD_INT 1
118943: ARRAY
118944: PPUSH
118945: CALL_OW 251
118949: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
118950: LD_ADDR_VAR 0 12
118954: PUSH
118955: LD_VAR 0 4
118959: PUSH
118960: LD_VAR 0 7
118964: ARRAY
118965: PPUSH
118966: CALL 96927 0 1
118970: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
118971: LD_VAR 0 4
118975: PUSH
118976: LD_VAR 0 7
118980: ARRAY
118981: PPUSH
118982: LD_VAR 0 10
118986: PPUSH
118987: LD_VAR 0 11
118991: PPUSH
118992: LD_VAR 0 14
118996: PUSH
118997: LD_INT 1
118999: ARRAY
119000: PPUSH
119001: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119005: LD_VAR 0 4
119009: PUSH
119010: LD_VAR 0 7
119014: ARRAY
119015: PPUSH
119016: LD_VAR 0 10
119020: PPUSH
119021: LD_VAR 0 12
119025: PPUSH
119026: LD_INT 7
119028: PPUSH
119029: CALL_OW 272
119033: PPUSH
119034: LD_VAR 0 11
119038: PPUSH
119039: LD_VAR 0 12
119043: PPUSH
119044: LD_INT 7
119046: PPUSH
119047: CALL_OW 273
119051: PPUSH
119052: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119056: LD_VAR 0 4
119060: PUSH
119061: LD_VAR 0 7
119065: ARRAY
119066: PPUSH
119067: LD_INT 71
119069: PPUSH
119070: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119074: LD_ADDR_VAR 0 27
119078: PUSH
119079: LD_VAR 0 27
119083: PPUSH
119084: LD_VAR 0 27
119088: PUSH
119089: LD_INT 1
119091: PLUS
119092: PPUSH
119093: LD_VAR 0 14
119097: PUSH
119098: LD_INT 1
119100: ARRAY
119101: PPUSH
119102: CALL_OW 1
119106: ST_TO_ADDR
// attacking := true ;
119107: LD_ADDR_VAR 0 29
119111: PUSH
119112: LD_INT 1
119114: ST_TO_ADDR
// continue ;
119115: GO 116962
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119117: LD_VAR 0 4
119121: PUSH
119122: LD_VAR 0 7
119126: ARRAY
119127: PPUSH
119128: CALL_OW 257
119132: PUSH
119133: LD_INT 17
119135: EQUAL
119136: PUSH
119137: LD_VAR 0 4
119141: PUSH
119142: LD_VAR 0 7
119146: ARRAY
119147: PPUSH
119148: CALL_OW 110
119152: PUSH
119153: LD_INT 71
119155: EQUAL
119156: NOT
119157: AND
119158: IFFALSE 119304
// begin attacking := false ;
119160: LD_ADDR_VAR 0 29
119164: PUSH
119165: LD_INT 0
119167: ST_TO_ADDR
// k := 5 ;
119168: LD_ADDR_VAR 0 9
119172: PUSH
119173: LD_INT 5
119175: ST_TO_ADDR
// if tmp < k then
119176: LD_VAR 0 14
119180: PUSH
119181: LD_VAR 0 9
119185: LESS
119186: IFFALSE 119198
// k := tmp ;
119188: LD_ADDR_VAR 0 9
119192: PUSH
119193: LD_VAR 0 14
119197: ST_TO_ADDR
// for j = 1 to k do
119198: LD_ADDR_VAR 0 8
119202: PUSH
119203: DOUBLE
119204: LD_INT 1
119206: DEC
119207: ST_TO_ADDR
119208: LD_VAR 0 9
119212: PUSH
119213: FOR_TO
119214: IFFALSE 119302
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119216: LD_VAR 0 14
119220: PUSH
119221: LD_VAR 0 8
119225: ARRAY
119226: PUSH
119227: LD_VAR 0 14
119231: PPUSH
119232: LD_INT 58
119234: PUSH
119235: EMPTY
119236: LIST
119237: PPUSH
119238: CALL_OW 72
119242: IN
119243: NOT
119244: IFFALSE 119300
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119246: LD_VAR 0 4
119250: PUSH
119251: LD_VAR 0 7
119255: ARRAY
119256: PPUSH
119257: LD_VAR 0 14
119261: PUSH
119262: LD_VAR 0 8
119266: ARRAY
119267: PPUSH
119268: CALL_OW 115
// attacking := true ;
119272: LD_ADDR_VAR 0 29
119276: PUSH
119277: LD_INT 1
119279: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119280: LD_VAR 0 4
119284: PUSH
119285: LD_VAR 0 7
119289: ARRAY
119290: PPUSH
119291: LD_INT 71
119293: PPUSH
119294: CALL_OW 109
// continue ;
119298: GO 119213
// end ; end ;
119300: GO 119213
119302: POP
119303: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
119304: LD_VAR 0 4
119308: PUSH
119309: LD_VAR 0 7
119313: ARRAY
119314: PPUSH
119315: CALL_OW 257
119319: PUSH
119320: LD_INT 8
119322: EQUAL
119323: PUSH
119324: LD_VAR 0 4
119328: PUSH
119329: LD_VAR 0 7
119333: ARRAY
119334: PPUSH
119335: CALL_OW 264
119339: PUSH
119340: LD_INT 28
119342: PUSH
119343: LD_INT 45
119345: PUSH
119346: LD_INT 7
119348: PUSH
119349: LD_INT 47
119351: PUSH
119352: EMPTY
119353: LIST
119354: LIST
119355: LIST
119356: LIST
119357: IN
119358: OR
119359: IFFALSE 119615
// begin attacking := false ;
119361: LD_ADDR_VAR 0 29
119365: PUSH
119366: LD_INT 0
119368: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
119369: LD_VAR 0 14
119373: PUSH
119374: LD_INT 1
119376: ARRAY
119377: PPUSH
119378: CALL_OW 266
119382: PUSH
119383: LD_INT 32
119385: PUSH
119386: LD_INT 31
119388: PUSH
119389: LD_INT 33
119391: PUSH
119392: LD_INT 4
119394: PUSH
119395: LD_INT 5
119397: PUSH
119398: EMPTY
119399: LIST
119400: LIST
119401: LIST
119402: LIST
119403: LIST
119404: IN
119405: IFFALSE 119591
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
119407: LD_ADDR_VAR 0 9
119411: PUSH
119412: LD_VAR 0 14
119416: PUSH
119417: LD_INT 1
119419: ARRAY
119420: PPUSH
119421: CALL_OW 266
119425: PPUSH
119426: LD_VAR 0 14
119430: PUSH
119431: LD_INT 1
119433: ARRAY
119434: PPUSH
119435: CALL_OW 250
119439: PPUSH
119440: LD_VAR 0 14
119444: PUSH
119445: LD_INT 1
119447: ARRAY
119448: PPUSH
119449: CALL_OW 251
119453: PPUSH
119454: LD_VAR 0 14
119458: PUSH
119459: LD_INT 1
119461: ARRAY
119462: PPUSH
119463: CALL_OW 254
119467: PPUSH
119468: LD_VAR 0 14
119472: PUSH
119473: LD_INT 1
119475: ARRAY
119476: PPUSH
119477: CALL_OW 248
119481: PPUSH
119482: LD_INT 0
119484: PPUSH
119485: CALL 78297 0 6
119489: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
119490: LD_ADDR_VAR 0 8
119494: PUSH
119495: LD_VAR 0 4
119499: PUSH
119500: LD_VAR 0 7
119504: ARRAY
119505: PPUSH
119506: LD_VAR 0 9
119510: PPUSH
119511: CALL 96967 0 2
119515: ST_TO_ADDR
// if j then
119516: LD_VAR 0 8
119520: IFFALSE 119589
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
119522: LD_VAR 0 8
119526: PUSH
119527: LD_INT 1
119529: ARRAY
119530: PPUSH
119531: LD_VAR 0 8
119535: PUSH
119536: LD_INT 2
119538: ARRAY
119539: PPUSH
119540: CALL_OW 488
119544: IFFALSE 119589
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
119546: LD_VAR 0 4
119550: PUSH
119551: LD_VAR 0 7
119555: ARRAY
119556: PPUSH
119557: LD_VAR 0 8
119561: PUSH
119562: LD_INT 1
119564: ARRAY
119565: PPUSH
119566: LD_VAR 0 8
119570: PUSH
119571: LD_INT 2
119573: ARRAY
119574: PPUSH
119575: CALL_OW 116
// attacking := true ;
119579: LD_ADDR_VAR 0 29
119583: PUSH
119584: LD_INT 1
119586: ST_TO_ADDR
// continue ;
119587: GO 116962
// end ; end else
119589: GO 119615
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119591: LD_VAR 0 4
119595: PUSH
119596: LD_VAR 0 7
119600: ARRAY
119601: PPUSH
119602: LD_VAR 0 14
119606: PUSH
119607: LD_INT 1
119609: ARRAY
119610: PPUSH
119611: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
119615: LD_VAR 0 4
119619: PUSH
119620: LD_VAR 0 7
119624: ARRAY
119625: PPUSH
119626: CALL_OW 265
119630: PUSH
119631: LD_INT 11
119633: EQUAL
119634: IFFALSE 119912
// begin k := 10 ;
119636: LD_ADDR_VAR 0 9
119640: PUSH
119641: LD_INT 10
119643: ST_TO_ADDR
// x := 0 ;
119644: LD_ADDR_VAR 0 10
119648: PUSH
119649: LD_INT 0
119651: ST_TO_ADDR
// if tmp < k then
119652: LD_VAR 0 14
119656: PUSH
119657: LD_VAR 0 9
119661: LESS
119662: IFFALSE 119674
// k := tmp ;
119664: LD_ADDR_VAR 0 9
119668: PUSH
119669: LD_VAR 0 14
119673: ST_TO_ADDR
// for j = k downto 1 do
119674: LD_ADDR_VAR 0 8
119678: PUSH
119679: DOUBLE
119680: LD_VAR 0 9
119684: INC
119685: ST_TO_ADDR
119686: LD_INT 1
119688: PUSH
119689: FOR_DOWNTO
119690: IFFALSE 119765
// begin if GetType ( tmp [ j ] ) = unit_human then
119692: LD_VAR 0 14
119696: PUSH
119697: LD_VAR 0 8
119701: ARRAY
119702: PPUSH
119703: CALL_OW 247
119707: PUSH
119708: LD_INT 1
119710: EQUAL
119711: IFFALSE 119763
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
119713: LD_VAR 0 4
119717: PUSH
119718: LD_VAR 0 7
119722: ARRAY
119723: PPUSH
119724: LD_VAR 0 14
119728: PUSH
119729: LD_VAR 0 8
119733: ARRAY
119734: PPUSH
119735: CALL 97238 0 2
// x := tmp [ j ] ;
119739: LD_ADDR_VAR 0 10
119743: PUSH
119744: LD_VAR 0 14
119748: PUSH
119749: LD_VAR 0 8
119753: ARRAY
119754: ST_TO_ADDR
// attacking := true ;
119755: LD_ADDR_VAR 0 29
119759: PUSH
119760: LD_INT 1
119762: ST_TO_ADDR
// end ; end ;
119763: GO 119689
119765: POP
119766: POP
// if not x then
119767: LD_VAR 0 10
119771: NOT
119772: IFFALSE 119912
// begin attacking := true ;
119774: LD_ADDR_VAR 0 29
119778: PUSH
119779: LD_INT 1
119781: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
119782: LD_VAR 0 4
119786: PUSH
119787: LD_VAR 0 7
119791: ARRAY
119792: PPUSH
119793: CALL_OW 250
119797: PPUSH
119798: LD_VAR 0 4
119802: PUSH
119803: LD_VAR 0 7
119807: ARRAY
119808: PPUSH
119809: CALL_OW 251
119813: PPUSH
119814: CALL_OW 546
119818: PUSH
119819: LD_INT 2
119821: ARRAY
119822: PUSH
119823: LD_VAR 0 14
119827: PUSH
119828: LD_INT 1
119830: ARRAY
119831: PPUSH
119832: CALL_OW 250
119836: PPUSH
119837: LD_VAR 0 14
119841: PUSH
119842: LD_INT 1
119844: ARRAY
119845: PPUSH
119846: CALL_OW 251
119850: PPUSH
119851: CALL_OW 546
119855: PUSH
119856: LD_INT 2
119858: ARRAY
119859: EQUAL
119860: IFFALSE 119888
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
119862: LD_VAR 0 4
119866: PUSH
119867: LD_VAR 0 7
119871: ARRAY
119872: PPUSH
119873: LD_VAR 0 14
119877: PUSH
119878: LD_INT 1
119880: ARRAY
119881: PPUSH
119882: CALL 97238 0 2
119886: GO 119912
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119888: LD_VAR 0 4
119892: PUSH
119893: LD_VAR 0 7
119897: ARRAY
119898: PPUSH
119899: LD_VAR 0 14
119903: PUSH
119904: LD_INT 1
119906: ARRAY
119907: PPUSH
119908: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
119912: LD_VAR 0 4
119916: PUSH
119917: LD_VAR 0 7
119921: ARRAY
119922: PPUSH
119923: CALL_OW 264
119927: PUSH
119928: LD_INT 29
119930: EQUAL
119931: IFFALSE 120297
// begin if WantsToAttack ( group [ i ] ) in bombed then
119933: LD_VAR 0 4
119937: PUSH
119938: LD_VAR 0 7
119942: ARRAY
119943: PPUSH
119944: CALL_OW 319
119948: PUSH
119949: LD_VAR 0 28
119953: IN
119954: IFFALSE 119958
// continue ;
119956: GO 116962
// k := 8 ;
119958: LD_ADDR_VAR 0 9
119962: PUSH
119963: LD_INT 8
119965: ST_TO_ADDR
// x := 0 ;
119966: LD_ADDR_VAR 0 10
119970: PUSH
119971: LD_INT 0
119973: ST_TO_ADDR
// if tmp < k then
119974: LD_VAR 0 14
119978: PUSH
119979: LD_VAR 0 9
119983: LESS
119984: IFFALSE 119996
// k := tmp ;
119986: LD_ADDR_VAR 0 9
119990: PUSH
119991: LD_VAR 0 14
119995: ST_TO_ADDR
// for j = 1 to k do
119996: LD_ADDR_VAR 0 8
120000: PUSH
120001: DOUBLE
120002: LD_INT 1
120004: DEC
120005: ST_TO_ADDR
120006: LD_VAR 0 9
120010: PUSH
120011: FOR_TO
120012: IFFALSE 120144
// begin if GetType ( tmp [ j ] ) = unit_building then
120014: LD_VAR 0 14
120018: PUSH
120019: LD_VAR 0 8
120023: ARRAY
120024: PPUSH
120025: CALL_OW 247
120029: PUSH
120030: LD_INT 3
120032: EQUAL
120033: IFFALSE 120142
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120035: LD_VAR 0 14
120039: PUSH
120040: LD_VAR 0 8
120044: ARRAY
120045: PUSH
120046: LD_VAR 0 28
120050: IN
120051: NOT
120052: PUSH
120053: LD_VAR 0 14
120057: PUSH
120058: LD_VAR 0 8
120062: ARRAY
120063: PPUSH
120064: CALL_OW 313
120068: AND
120069: IFFALSE 120142
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120071: LD_VAR 0 4
120075: PUSH
120076: LD_VAR 0 7
120080: ARRAY
120081: PPUSH
120082: LD_VAR 0 14
120086: PUSH
120087: LD_VAR 0 8
120091: ARRAY
120092: PPUSH
120093: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120097: LD_ADDR_VAR 0 28
120101: PUSH
120102: LD_VAR 0 28
120106: PPUSH
120107: LD_VAR 0 28
120111: PUSH
120112: LD_INT 1
120114: PLUS
120115: PPUSH
120116: LD_VAR 0 14
120120: PUSH
120121: LD_VAR 0 8
120125: ARRAY
120126: PPUSH
120127: CALL_OW 1
120131: ST_TO_ADDR
// attacking := true ;
120132: LD_ADDR_VAR 0 29
120136: PUSH
120137: LD_INT 1
120139: ST_TO_ADDR
// break ;
120140: GO 120144
// end ; end ;
120142: GO 120011
120144: POP
120145: POP
// if not attacking and f_attack_depot then
120146: LD_VAR 0 29
120150: NOT
120151: PUSH
120152: LD_VAR 0 25
120156: AND
120157: IFFALSE 120252
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120159: LD_ADDR_VAR 0 13
120163: PUSH
120164: LD_VAR 0 14
120168: PPUSH
120169: LD_INT 2
120171: PUSH
120172: LD_INT 30
120174: PUSH
120175: LD_INT 0
120177: PUSH
120178: EMPTY
120179: LIST
120180: LIST
120181: PUSH
120182: LD_INT 30
120184: PUSH
120185: LD_INT 1
120187: PUSH
120188: EMPTY
120189: LIST
120190: LIST
120191: PUSH
120192: EMPTY
120193: LIST
120194: LIST
120195: LIST
120196: PPUSH
120197: CALL_OW 72
120201: ST_TO_ADDR
// if z then
120202: LD_VAR 0 13
120206: IFFALSE 120252
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120208: LD_VAR 0 4
120212: PUSH
120213: LD_VAR 0 7
120217: ARRAY
120218: PPUSH
120219: LD_VAR 0 13
120223: PPUSH
120224: LD_VAR 0 4
120228: PUSH
120229: LD_VAR 0 7
120233: ARRAY
120234: PPUSH
120235: CALL_OW 74
120239: PPUSH
120240: CALL_OW 115
// attacking := true ;
120244: LD_ADDR_VAR 0 29
120248: PUSH
120249: LD_INT 1
120251: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120252: LD_VAR 0 4
120256: PUSH
120257: LD_VAR 0 7
120261: ARRAY
120262: PPUSH
120263: CALL_OW 256
120267: PUSH
120268: LD_INT 500
120270: LESS
120271: IFFALSE 120297
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120273: LD_VAR 0 4
120277: PUSH
120278: LD_VAR 0 7
120282: ARRAY
120283: PPUSH
120284: LD_VAR 0 14
120288: PUSH
120289: LD_INT 1
120291: ARRAY
120292: PPUSH
120293: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
120297: LD_VAR 0 4
120301: PUSH
120302: LD_VAR 0 7
120306: ARRAY
120307: PPUSH
120308: CALL_OW 264
120312: PUSH
120313: LD_INT 49
120315: EQUAL
120316: IFFALSE 120437
// begin if not HasTask ( group [ i ] ) then
120318: LD_VAR 0 4
120322: PUSH
120323: LD_VAR 0 7
120327: ARRAY
120328: PPUSH
120329: CALL_OW 314
120333: NOT
120334: IFFALSE 120437
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
120336: LD_ADDR_VAR 0 9
120340: PUSH
120341: LD_INT 81
120343: PUSH
120344: LD_VAR 0 4
120348: PUSH
120349: LD_VAR 0 7
120353: ARRAY
120354: PPUSH
120355: CALL_OW 255
120359: PUSH
120360: EMPTY
120361: LIST
120362: LIST
120363: PPUSH
120364: CALL_OW 69
120368: PPUSH
120369: LD_VAR 0 4
120373: PUSH
120374: LD_VAR 0 7
120378: ARRAY
120379: PPUSH
120380: CALL_OW 74
120384: ST_TO_ADDR
// if k then
120385: LD_VAR 0 9
120389: IFFALSE 120437
// if GetDistUnits ( group [ i ] , k ) > 10 then
120391: LD_VAR 0 4
120395: PUSH
120396: LD_VAR 0 7
120400: ARRAY
120401: PPUSH
120402: LD_VAR 0 9
120406: PPUSH
120407: CALL_OW 296
120411: PUSH
120412: LD_INT 10
120414: GREATER
120415: IFFALSE 120437
// ComMoveUnit ( group [ i ] , k ) ;
120417: LD_VAR 0 4
120421: PUSH
120422: LD_VAR 0 7
120426: ARRAY
120427: PPUSH
120428: LD_VAR 0 9
120432: PPUSH
120433: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
120437: LD_VAR 0 4
120441: PUSH
120442: LD_VAR 0 7
120446: ARRAY
120447: PPUSH
120448: CALL_OW 256
120452: PUSH
120453: LD_INT 250
120455: LESS
120456: PUSH
120457: LD_VAR 0 4
120461: PUSH
120462: LD_VAR 0 7
120466: ARRAY
120467: PUSH
120468: LD_INT 21
120470: PUSH
120471: LD_INT 2
120473: PUSH
120474: EMPTY
120475: LIST
120476: LIST
120477: PUSH
120478: LD_INT 23
120480: PUSH
120481: LD_INT 2
120483: PUSH
120484: EMPTY
120485: LIST
120486: LIST
120487: PUSH
120488: EMPTY
120489: LIST
120490: LIST
120491: PPUSH
120492: CALL_OW 69
120496: IN
120497: AND
120498: IFFALSE 120623
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
120500: LD_ADDR_VAR 0 9
120504: PUSH
120505: LD_OWVAR 3
120509: PUSH
120510: LD_VAR 0 4
120514: PUSH
120515: LD_VAR 0 7
120519: ARRAY
120520: DIFF
120521: PPUSH
120522: LD_VAR 0 4
120526: PUSH
120527: LD_VAR 0 7
120531: ARRAY
120532: PPUSH
120533: CALL_OW 74
120537: ST_TO_ADDR
// if not k then
120538: LD_VAR 0 9
120542: NOT
120543: IFFALSE 120547
// continue ;
120545: GO 116962
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
120547: LD_VAR 0 9
120551: PUSH
120552: LD_INT 81
120554: PUSH
120555: LD_VAR 0 4
120559: PUSH
120560: LD_VAR 0 7
120564: ARRAY
120565: PPUSH
120566: CALL_OW 255
120570: PUSH
120571: EMPTY
120572: LIST
120573: LIST
120574: PPUSH
120575: CALL_OW 69
120579: IN
120580: PUSH
120581: LD_VAR 0 9
120585: PPUSH
120586: LD_VAR 0 4
120590: PUSH
120591: LD_VAR 0 7
120595: ARRAY
120596: PPUSH
120597: CALL_OW 296
120601: PUSH
120602: LD_INT 5
120604: LESS
120605: AND
120606: IFFALSE 120623
// ComAutodestruct ( group [ i ] ) ;
120608: LD_VAR 0 4
120612: PUSH
120613: LD_VAR 0 7
120617: ARRAY
120618: PPUSH
120619: CALL 97136 0 1
// end ; if f_attack_depot then
120623: LD_VAR 0 25
120627: IFFALSE 120739
// begin k := 6 ;
120629: LD_ADDR_VAR 0 9
120633: PUSH
120634: LD_INT 6
120636: ST_TO_ADDR
// if tmp < k then
120637: LD_VAR 0 14
120641: PUSH
120642: LD_VAR 0 9
120646: LESS
120647: IFFALSE 120659
// k := tmp ;
120649: LD_ADDR_VAR 0 9
120653: PUSH
120654: LD_VAR 0 14
120658: ST_TO_ADDR
// for j = 1 to k do
120659: LD_ADDR_VAR 0 8
120663: PUSH
120664: DOUBLE
120665: LD_INT 1
120667: DEC
120668: ST_TO_ADDR
120669: LD_VAR 0 9
120673: PUSH
120674: FOR_TO
120675: IFFALSE 120737
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
120677: LD_VAR 0 8
120681: PPUSH
120682: CALL_OW 266
120686: PUSH
120687: LD_INT 0
120689: PUSH
120690: LD_INT 1
120692: PUSH
120693: EMPTY
120694: LIST
120695: LIST
120696: IN
120697: IFFALSE 120735
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120699: LD_VAR 0 4
120703: PUSH
120704: LD_VAR 0 7
120708: ARRAY
120709: PPUSH
120710: LD_VAR 0 14
120714: PUSH
120715: LD_VAR 0 8
120719: ARRAY
120720: PPUSH
120721: CALL_OW 115
// attacking := true ;
120725: LD_ADDR_VAR 0 29
120729: PUSH
120730: LD_INT 1
120732: ST_TO_ADDR
// break ;
120733: GO 120737
// end ;
120735: GO 120674
120737: POP
120738: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
120739: LD_VAR 0 4
120743: PUSH
120744: LD_VAR 0 7
120748: ARRAY
120749: PPUSH
120750: CALL_OW 302
120754: PUSH
120755: LD_VAR 0 29
120759: NOT
120760: AND
120761: IFFALSE 121083
// begin if GetTag ( group [ i ] ) = 71 then
120763: LD_VAR 0 4
120767: PUSH
120768: LD_VAR 0 7
120772: ARRAY
120773: PPUSH
120774: CALL_OW 110
120778: PUSH
120779: LD_INT 71
120781: EQUAL
120782: IFFALSE 120823
// begin if HasTask ( group [ i ] ) then
120784: LD_VAR 0 4
120788: PUSH
120789: LD_VAR 0 7
120793: ARRAY
120794: PPUSH
120795: CALL_OW 314
120799: IFFALSE 120805
// continue else
120801: GO 116962
120803: GO 120823
// SetTag ( group [ i ] , 0 ) ;
120805: LD_VAR 0 4
120809: PUSH
120810: LD_VAR 0 7
120814: ARRAY
120815: PPUSH
120816: LD_INT 0
120818: PPUSH
120819: CALL_OW 109
// end ; k := 8 ;
120823: LD_ADDR_VAR 0 9
120827: PUSH
120828: LD_INT 8
120830: ST_TO_ADDR
// x := 0 ;
120831: LD_ADDR_VAR 0 10
120835: PUSH
120836: LD_INT 0
120838: ST_TO_ADDR
// if tmp < k then
120839: LD_VAR 0 14
120843: PUSH
120844: LD_VAR 0 9
120848: LESS
120849: IFFALSE 120861
// k := tmp ;
120851: LD_ADDR_VAR 0 9
120855: PUSH
120856: LD_VAR 0 14
120860: ST_TO_ADDR
// for j = 1 to k do
120861: LD_ADDR_VAR 0 8
120865: PUSH
120866: DOUBLE
120867: LD_INT 1
120869: DEC
120870: ST_TO_ADDR
120871: LD_VAR 0 9
120875: PUSH
120876: FOR_TO
120877: IFFALSE 120975
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
120879: LD_VAR 0 14
120883: PUSH
120884: LD_VAR 0 8
120888: ARRAY
120889: PPUSH
120890: CALL_OW 247
120894: PUSH
120895: LD_INT 1
120897: EQUAL
120898: PUSH
120899: LD_VAR 0 14
120903: PUSH
120904: LD_VAR 0 8
120908: ARRAY
120909: PPUSH
120910: CALL_OW 256
120914: PUSH
120915: LD_INT 250
120917: LESS
120918: PUSH
120919: LD_VAR 0 20
120923: AND
120924: PUSH
120925: LD_VAR 0 20
120929: NOT
120930: PUSH
120931: LD_VAR 0 14
120935: PUSH
120936: LD_VAR 0 8
120940: ARRAY
120941: PPUSH
120942: CALL_OW 256
120946: PUSH
120947: LD_INT 250
120949: GREATEREQUAL
120950: AND
120951: OR
120952: AND
120953: IFFALSE 120973
// begin x := tmp [ j ] ;
120955: LD_ADDR_VAR 0 10
120959: PUSH
120960: LD_VAR 0 14
120964: PUSH
120965: LD_VAR 0 8
120969: ARRAY
120970: ST_TO_ADDR
// break ;
120971: GO 120975
// end ;
120973: GO 120876
120975: POP
120976: POP
// if x then
120977: LD_VAR 0 10
120981: IFFALSE 121005
// ComAttackUnit ( group [ i ] , x ) else
120983: LD_VAR 0 4
120987: PUSH
120988: LD_VAR 0 7
120992: ARRAY
120993: PPUSH
120994: LD_VAR 0 10
120998: PPUSH
120999: CALL_OW 115
121003: GO 121029
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121005: LD_VAR 0 4
121009: PUSH
121010: LD_VAR 0 7
121014: ARRAY
121015: PPUSH
121016: LD_VAR 0 14
121020: PUSH
121021: LD_INT 1
121023: ARRAY
121024: PPUSH
121025: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121029: LD_VAR 0 4
121033: PUSH
121034: LD_VAR 0 7
121038: ARRAY
121039: PPUSH
121040: CALL_OW 314
121044: NOT
121045: IFFALSE 121083
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121047: LD_VAR 0 4
121051: PUSH
121052: LD_VAR 0 7
121056: ARRAY
121057: PPUSH
121058: LD_VAR 0 14
121062: PPUSH
121063: LD_VAR 0 4
121067: PUSH
121068: LD_VAR 0 7
121072: ARRAY
121073: PPUSH
121074: CALL_OW 74
121078: PPUSH
121079: CALL_OW 115
// end ; end ; end ;
121083: GO 116962
121085: POP
121086: POP
// wait ( 0 0$2 ) ;
121087: LD_INT 70
121089: PPUSH
121090: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121094: LD_VAR 0 4
121098: NOT
121099: PUSH
121100: LD_VAR 0 4
121104: PUSH
121105: EMPTY
121106: EQUAL
121107: OR
121108: PUSH
121109: LD_INT 81
121111: PUSH
121112: LD_VAR 0 35
121116: PUSH
121117: EMPTY
121118: LIST
121119: LIST
121120: PPUSH
121121: CALL_OW 69
121125: NOT
121126: OR
121127: IFFALSE 116947
// end ;
121129: LD_VAR 0 2
121133: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
121134: LD_INT 0
121136: PPUSH
121137: PPUSH
121138: PPUSH
121139: PPUSH
121140: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
121141: LD_VAR 0 1
121145: NOT
121146: PUSH
121147: LD_EXP 112
121151: PUSH
121152: LD_VAR 0 1
121156: ARRAY
121157: NOT
121158: OR
121159: PUSH
121160: LD_VAR 0 2
121164: NOT
121165: OR
121166: PUSH
121167: LD_VAR 0 3
121171: NOT
121172: OR
121173: IFFALSE 121177
// exit ;
121175: GO 121690
// side := mc_sides [ base ] ;
121177: LD_ADDR_VAR 0 6
121181: PUSH
121182: LD_EXP 138
121186: PUSH
121187: LD_VAR 0 1
121191: ARRAY
121192: ST_TO_ADDR
// if not side then
121193: LD_VAR 0 6
121197: NOT
121198: IFFALSE 121202
// exit ;
121200: GO 121690
// for i in solds do
121202: LD_ADDR_VAR 0 7
121206: PUSH
121207: LD_VAR 0 2
121211: PUSH
121212: FOR_IN
121213: IFFALSE 121274
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121215: LD_VAR 0 7
121219: PPUSH
121220: CALL_OW 310
121224: PPUSH
121225: CALL_OW 266
121229: PUSH
121230: LD_INT 32
121232: PUSH
121233: LD_INT 31
121235: PUSH
121236: EMPTY
121237: LIST
121238: LIST
121239: IN
121240: IFFALSE 121260
// solds := solds diff i else
121242: LD_ADDR_VAR 0 2
121246: PUSH
121247: LD_VAR 0 2
121251: PUSH
121252: LD_VAR 0 7
121256: DIFF
121257: ST_TO_ADDR
121258: GO 121272
// SetTag ( i , 18 ) ;
121260: LD_VAR 0 7
121264: PPUSH
121265: LD_INT 18
121267: PPUSH
121268: CALL_OW 109
121272: GO 121212
121274: POP
121275: POP
// if not solds then
121276: LD_VAR 0 2
121280: NOT
121281: IFFALSE 121285
// exit ;
121283: GO 121690
// repeat wait ( 0 0$1 ) ;
121285: LD_INT 35
121287: PPUSH
121288: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
121292: LD_ADDR_VAR 0 5
121296: PUSH
121297: LD_VAR 0 6
121301: PPUSH
121302: LD_VAR 0 3
121306: PPUSH
121307: CALL 66851 0 2
121311: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121312: LD_EXP 112
121316: PUSH
121317: LD_VAR 0 1
121321: ARRAY
121322: NOT
121323: PUSH
121324: LD_EXP 112
121328: PUSH
121329: LD_VAR 0 1
121333: ARRAY
121334: PUSH
121335: EMPTY
121336: EQUAL
121337: OR
121338: IFFALSE 121375
// begin for i in solds do
121340: LD_ADDR_VAR 0 7
121344: PUSH
121345: LD_VAR 0 2
121349: PUSH
121350: FOR_IN
121351: IFFALSE 121364
// ComStop ( i ) ;
121353: LD_VAR 0 7
121357: PPUSH
121358: CALL_OW 141
121362: GO 121350
121364: POP
121365: POP
// solds := [ ] ;
121366: LD_ADDR_VAR 0 2
121370: PUSH
121371: EMPTY
121372: ST_TO_ADDR
// exit ;
121373: GO 121690
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
121375: LD_VAR 0 5
121379: NOT
121380: PUSH
121381: LD_VAR 0 5
121385: PUSH
121386: LD_INT 3
121388: GREATER
121389: OR
121390: PUSH
121391: LD_EXP 134
121395: PUSH
121396: LD_VAR 0 1
121400: ARRAY
121401: OR
121402: IFFALSE 121443
// begin for i in solds do
121404: LD_ADDR_VAR 0 7
121408: PUSH
121409: LD_VAR 0 2
121413: PUSH
121414: FOR_IN
121415: IFFALSE 121439
// if HasTask ( i ) then
121417: LD_VAR 0 7
121421: PPUSH
121422: CALL_OW 314
121426: IFFALSE 121437
// ComStop ( i ) ;
121428: LD_VAR 0 7
121432: PPUSH
121433: CALL_OW 141
121437: GO 121414
121439: POP
121440: POP
// break ;
121441: GO 121678
// end ; for i in solds do
121443: LD_ADDR_VAR 0 7
121447: PUSH
121448: LD_VAR 0 2
121452: PUSH
121453: FOR_IN
121454: IFFALSE 121670
// begin if IsInUnit ( i ) then
121456: LD_VAR 0 7
121460: PPUSH
121461: CALL_OW 310
121465: IFFALSE 121476
// ComExitBuilding ( i ) ;
121467: LD_VAR 0 7
121471: PPUSH
121472: CALL_OW 122
// if GetLives ( i ) > 333 then
121476: LD_VAR 0 7
121480: PPUSH
121481: CALL_OW 256
121485: PUSH
121486: LD_INT 333
121488: GREATER
121489: IFFALSE 121517
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
121491: LD_VAR 0 7
121495: PPUSH
121496: LD_VAR 0 5
121500: PPUSH
121501: LD_VAR 0 7
121505: PPUSH
121506: CALL_OW 74
121510: PPUSH
121511: CALL_OW 115
121515: GO 121668
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
121517: LD_ADDR_VAR 0 8
121521: PUSH
121522: LD_EXP 112
121526: PUSH
121527: LD_VAR 0 1
121531: ARRAY
121532: PPUSH
121533: LD_INT 2
121535: PUSH
121536: LD_INT 30
121538: PUSH
121539: LD_INT 0
121541: PUSH
121542: EMPTY
121543: LIST
121544: LIST
121545: PUSH
121546: LD_INT 30
121548: PUSH
121549: LD_INT 1
121551: PUSH
121552: EMPTY
121553: LIST
121554: LIST
121555: PUSH
121556: LD_INT 30
121558: PUSH
121559: LD_INT 6
121561: PUSH
121562: EMPTY
121563: LIST
121564: LIST
121565: PUSH
121566: EMPTY
121567: LIST
121568: LIST
121569: LIST
121570: LIST
121571: PPUSH
121572: CALL_OW 72
121576: PPUSH
121577: LD_VAR 0 7
121581: PPUSH
121582: CALL_OW 74
121586: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
121587: LD_VAR 0 7
121591: PPUSH
121592: LD_VAR 0 8
121596: PPUSH
121597: CALL_OW 250
121601: PPUSH
121602: LD_INT 3
121604: PPUSH
121605: LD_INT 5
121607: PPUSH
121608: CALL_OW 272
121612: PPUSH
121613: LD_VAR 0 8
121617: PPUSH
121618: CALL_OW 251
121622: PPUSH
121623: LD_INT 3
121625: PPUSH
121626: LD_INT 5
121628: PPUSH
121629: CALL_OW 273
121633: PPUSH
121634: CALL_OW 111
// SetTag ( i , 0 ) ;
121638: LD_VAR 0 7
121642: PPUSH
121643: LD_INT 0
121645: PPUSH
121646: CALL_OW 109
// solds := solds diff i ;
121650: LD_ADDR_VAR 0 2
121654: PUSH
121655: LD_VAR 0 2
121659: PUSH
121660: LD_VAR 0 7
121664: DIFF
121665: ST_TO_ADDR
// continue ;
121666: GO 121453
// end ; end ;
121668: GO 121453
121670: POP
121671: POP
// until solds ;
121672: LD_VAR 0 2
121676: IFFALSE 121285
// MC_Reset ( base , 18 ) ;
121678: LD_VAR 0 1
121682: PPUSH
121683: LD_INT 18
121685: PPUSH
121686: CALL 39159 0 2
// end ;
121690: LD_VAR 0 4
121694: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
121695: LD_INT 0
121697: PPUSH
121698: PPUSH
121699: PPUSH
121700: PPUSH
121701: PPUSH
121702: PPUSH
121703: PPUSH
121704: PPUSH
121705: PPUSH
121706: PPUSH
121707: PPUSH
121708: PPUSH
121709: PPUSH
121710: PPUSH
121711: PPUSH
121712: PPUSH
121713: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
121714: LD_ADDR_VAR 0 13
121718: PUSH
121719: LD_EXP 112
121723: PUSH
121724: LD_VAR 0 1
121728: ARRAY
121729: PPUSH
121730: LD_INT 25
121732: PUSH
121733: LD_INT 3
121735: PUSH
121736: EMPTY
121737: LIST
121738: LIST
121739: PPUSH
121740: CALL_OW 72
121744: ST_TO_ADDR
// if mc_remote_driver [ base ] then
121745: LD_EXP 152
121749: PUSH
121750: LD_VAR 0 1
121754: ARRAY
121755: IFFALSE 121779
// mechs := mechs diff mc_remote_driver [ base ] ;
121757: LD_ADDR_VAR 0 13
121761: PUSH
121762: LD_VAR 0 13
121766: PUSH
121767: LD_EXP 152
121771: PUSH
121772: LD_VAR 0 1
121776: ARRAY
121777: DIFF
121778: ST_TO_ADDR
// for i in mechs do
121779: LD_ADDR_VAR 0 5
121783: PUSH
121784: LD_VAR 0 13
121788: PUSH
121789: FOR_IN
121790: IFFALSE 121825
// if GetTag ( i ) > 0 then
121792: LD_VAR 0 5
121796: PPUSH
121797: CALL_OW 110
121801: PUSH
121802: LD_INT 0
121804: GREATER
121805: IFFALSE 121823
// mechs := mechs diff i ;
121807: LD_ADDR_VAR 0 13
121811: PUSH
121812: LD_VAR 0 13
121816: PUSH
121817: LD_VAR 0 5
121821: DIFF
121822: ST_TO_ADDR
121823: GO 121789
121825: POP
121826: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121827: LD_ADDR_VAR 0 9
121831: PUSH
121832: LD_EXP 112
121836: PUSH
121837: LD_VAR 0 1
121841: ARRAY
121842: PPUSH
121843: LD_INT 2
121845: PUSH
121846: LD_INT 25
121848: PUSH
121849: LD_INT 1
121851: PUSH
121852: EMPTY
121853: LIST
121854: LIST
121855: PUSH
121856: LD_INT 25
121858: PUSH
121859: LD_INT 5
121861: PUSH
121862: EMPTY
121863: LIST
121864: LIST
121865: PUSH
121866: LD_INT 25
121868: PUSH
121869: LD_INT 8
121871: PUSH
121872: EMPTY
121873: LIST
121874: LIST
121875: PUSH
121876: LD_INT 25
121878: PUSH
121879: LD_INT 9
121881: PUSH
121882: EMPTY
121883: LIST
121884: LIST
121885: PUSH
121886: EMPTY
121887: LIST
121888: LIST
121889: LIST
121890: LIST
121891: LIST
121892: PPUSH
121893: CALL_OW 72
121897: ST_TO_ADDR
// if not defenders and not solds then
121898: LD_VAR 0 2
121902: NOT
121903: PUSH
121904: LD_VAR 0 9
121908: NOT
121909: AND
121910: IFFALSE 121914
// exit ;
121912: GO 123540
// depot_under_attack := false ;
121914: LD_ADDR_VAR 0 17
121918: PUSH
121919: LD_INT 0
121921: ST_TO_ADDR
// sold_defenders := [ ] ;
121922: LD_ADDR_VAR 0 18
121926: PUSH
121927: EMPTY
121928: ST_TO_ADDR
// if mechs then
121929: LD_VAR 0 13
121933: IFFALSE 122062
// for i in defenders do
121935: LD_ADDR_VAR 0 5
121939: PUSH
121940: LD_VAR 0 2
121944: PUSH
121945: FOR_IN
121946: IFFALSE 122060
// begin SetTag ( i , 20 ) ;
121948: LD_VAR 0 5
121952: PPUSH
121953: LD_INT 20
121955: PPUSH
121956: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
121960: LD_VAR 0 5
121964: PPUSH
121965: CALL_OW 263
121969: PUSH
121970: LD_INT 1
121972: EQUAL
121973: PUSH
121974: LD_VAR 0 5
121978: PPUSH
121979: CALL_OW 311
121983: NOT
121984: AND
121985: PUSH
121986: LD_VAR 0 13
121990: AND
121991: IFFALSE 122058
// begin un := mechs [ 1 ] ;
121993: LD_ADDR_VAR 0 11
121997: PUSH
121998: LD_VAR 0 13
122002: PUSH
122003: LD_INT 1
122005: ARRAY
122006: ST_TO_ADDR
// ComExitBuilding ( un ) ;
122007: LD_VAR 0 11
122011: PPUSH
122012: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
122016: LD_VAR 0 11
122020: PPUSH
122021: LD_VAR 0 5
122025: PPUSH
122026: CALL_OW 180
// SetTag ( un , 19 ) ;
122030: LD_VAR 0 11
122034: PPUSH
122035: LD_INT 19
122037: PPUSH
122038: CALL_OW 109
// mechs := mechs diff un ;
122042: LD_ADDR_VAR 0 13
122046: PUSH
122047: LD_VAR 0 13
122051: PUSH
122052: LD_VAR 0 11
122056: DIFF
122057: ST_TO_ADDR
// end ; end ;
122058: GO 121945
122060: POP
122061: POP
// if solds then
122062: LD_VAR 0 9
122066: IFFALSE 122125
// for i in solds do
122068: LD_ADDR_VAR 0 5
122072: PUSH
122073: LD_VAR 0 9
122077: PUSH
122078: FOR_IN
122079: IFFALSE 122123
// if not GetTag ( i ) then
122081: LD_VAR 0 5
122085: PPUSH
122086: CALL_OW 110
122090: NOT
122091: IFFALSE 122121
// begin defenders := defenders union i ;
122093: LD_ADDR_VAR 0 2
122097: PUSH
122098: LD_VAR 0 2
122102: PUSH
122103: LD_VAR 0 5
122107: UNION
122108: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122109: LD_VAR 0 5
122113: PPUSH
122114: LD_INT 18
122116: PPUSH
122117: CALL_OW 109
// end ;
122121: GO 122078
122123: POP
122124: POP
// repeat wait ( 0 0$1 ) ;
122125: LD_INT 35
122127: PPUSH
122128: CALL_OW 67
// enemy := mc_scan [ base ] ;
122132: LD_ADDR_VAR 0 3
122136: PUSH
122137: LD_EXP 135
122141: PUSH
122142: LD_VAR 0 1
122146: ARRAY
122147: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122148: LD_EXP 112
122152: PUSH
122153: LD_VAR 0 1
122157: ARRAY
122158: NOT
122159: PUSH
122160: LD_EXP 112
122164: PUSH
122165: LD_VAR 0 1
122169: ARRAY
122170: PUSH
122171: EMPTY
122172: EQUAL
122173: OR
122174: IFFALSE 122211
// begin for i in defenders do
122176: LD_ADDR_VAR 0 5
122180: PUSH
122181: LD_VAR 0 2
122185: PUSH
122186: FOR_IN
122187: IFFALSE 122200
// ComStop ( i ) ;
122189: LD_VAR 0 5
122193: PPUSH
122194: CALL_OW 141
122198: GO 122186
122200: POP
122201: POP
// defenders := [ ] ;
122202: LD_ADDR_VAR 0 2
122206: PUSH
122207: EMPTY
122208: ST_TO_ADDR
// exit ;
122209: GO 123540
// end ; for i in defenders do
122211: LD_ADDR_VAR 0 5
122215: PUSH
122216: LD_VAR 0 2
122220: PUSH
122221: FOR_IN
122222: IFFALSE 123040
// begin e := NearestUnitToUnit ( enemy , i ) ;
122224: LD_ADDR_VAR 0 14
122228: PUSH
122229: LD_VAR 0 3
122233: PPUSH
122234: LD_VAR 0 5
122238: PPUSH
122239: CALL_OW 74
122243: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122244: LD_ADDR_VAR 0 8
122248: PUSH
122249: LD_EXP 112
122253: PUSH
122254: LD_VAR 0 1
122258: ARRAY
122259: PPUSH
122260: LD_INT 2
122262: PUSH
122263: LD_INT 30
122265: PUSH
122266: LD_INT 0
122268: PUSH
122269: EMPTY
122270: LIST
122271: LIST
122272: PUSH
122273: LD_INT 30
122275: PUSH
122276: LD_INT 1
122278: PUSH
122279: EMPTY
122280: LIST
122281: LIST
122282: PUSH
122283: EMPTY
122284: LIST
122285: LIST
122286: LIST
122287: PPUSH
122288: CALL_OW 72
122292: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
122293: LD_ADDR_VAR 0 17
122297: PUSH
122298: LD_VAR 0 8
122302: NOT
122303: PUSH
122304: LD_VAR 0 8
122308: PPUSH
122309: LD_INT 3
122311: PUSH
122312: LD_INT 24
122314: PUSH
122315: LD_INT 600
122317: PUSH
122318: EMPTY
122319: LIST
122320: LIST
122321: PUSH
122322: EMPTY
122323: LIST
122324: LIST
122325: PPUSH
122326: CALL_OW 72
122330: OR
122331: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
122332: LD_VAR 0 5
122336: PPUSH
122337: CALL_OW 247
122341: PUSH
122342: LD_INT 2
122344: DOUBLE
122345: EQUAL
122346: IFTRUE 122350
122348: GO 122746
122350: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
122351: LD_VAR 0 5
122355: PPUSH
122356: CALL_OW 256
122360: PUSH
122361: LD_INT 650
122363: GREATER
122364: PUSH
122365: LD_VAR 0 5
122369: PPUSH
122370: LD_VAR 0 14
122374: PPUSH
122375: CALL_OW 296
122379: PUSH
122380: LD_INT 40
122382: LESS
122383: PUSH
122384: LD_VAR 0 14
122388: PPUSH
122389: LD_EXP 137
122393: PUSH
122394: LD_VAR 0 1
122398: ARRAY
122399: PPUSH
122400: CALL_OW 308
122404: OR
122405: AND
122406: IFFALSE 122528
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
122408: LD_VAR 0 5
122412: PPUSH
122413: CALL_OW 262
122417: PUSH
122418: LD_INT 1
122420: EQUAL
122421: PUSH
122422: LD_VAR 0 5
122426: PPUSH
122427: CALL_OW 261
122431: PUSH
122432: LD_INT 30
122434: LESS
122435: AND
122436: PUSH
122437: LD_VAR 0 8
122441: AND
122442: IFFALSE 122512
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
122444: LD_VAR 0 5
122448: PPUSH
122449: LD_VAR 0 8
122453: PPUSH
122454: LD_VAR 0 5
122458: PPUSH
122459: CALL_OW 74
122463: PPUSH
122464: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
122468: LD_VAR 0 5
122472: PPUSH
122473: LD_VAR 0 8
122477: PPUSH
122478: LD_VAR 0 5
122482: PPUSH
122483: CALL_OW 74
122487: PPUSH
122488: CALL_OW 296
122492: PUSH
122493: LD_INT 6
122495: LESS
122496: IFFALSE 122510
// SetFuel ( i , 100 ) ;
122498: LD_VAR 0 5
122502: PPUSH
122503: LD_INT 100
122505: PPUSH
122506: CALL_OW 240
// end else
122510: GO 122526
// ComAttackUnit ( i , e ) ;
122512: LD_VAR 0 5
122516: PPUSH
122517: LD_VAR 0 14
122521: PPUSH
122522: CALL_OW 115
// end else
122526: GO 122629
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
122528: LD_VAR 0 14
122532: PPUSH
122533: LD_EXP 137
122537: PUSH
122538: LD_VAR 0 1
122542: ARRAY
122543: PPUSH
122544: CALL_OW 308
122548: NOT
122549: PUSH
122550: LD_VAR 0 5
122554: PPUSH
122555: LD_VAR 0 14
122559: PPUSH
122560: CALL_OW 296
122564: PUSH
122565: LD_INT 40
122567: GREATEREQUAL
122568: AND
122569: PUSH
122570: LD_VAR 0 5
122574: PPUSH
122575: CALL_OW 256
122579: PUSH
122580: LD_INT 650
122582: LESSEQUAL
122583: OR
122584: PUSH
122585: LD_VAR 0 5
122589: PPUSH
122590: LD_EXP 136
122594: PUSH
122595: LD_VAR 0 1
122599: ARRAY
122600: PPUSH
122601: CALL_OW 308
122605: NOT
122606: AND
122607: IFFALSE 122629
// ComMoveToArea ( i , mc_parking [ base ] ) ;
122609: LD_VAR 0 5
122613: PPUSH
122614: LD_EXP 136
122618: PUSH
122619: LD_VAR 0 1
122623: ARRAY
122624: PPUSH
122625: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
122629: LD_VAR 0 5
122633: PPUSH
122634: CALL_OW 256
122638: PUSH
122639: LD_INT 998
122641: LESS
122642: PUSH
122643: LD_VAR 0 5
122647: PPUSH
122648: CALL_OW 263
122652: PUSH
122653: LD_INT 1
122655: EQUAL
122656: AND
122657: PUSH
122658: LD_VAR 0 5
122662: PPUSH
122663: CALL_OW 311
122667: AND
122668: PUSH
122669: LD_VAR 0 5
122673: PPUSH
122674: LD_EXP 136
122678: PUSH
122679: LD_VAR 0 1
122683: ARRAY
122684: PPUSH
122685: CALL_OW 308
122689: AND
122690: IFFALSE 122744
// begin mech := IsDrivenBy ( i ) ;
122692: LD_ADDR_VAR 0 10
122696: PUSH
122697: LD_VAR 0 5
122701: PPUSH
122702: CALL_OW 311
122706: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
122707: LD_VAR 0 10
122711: PPUSH
122712: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
122716: LD_VAR 0 10
122720: PPUSH
122721: LD_VAR 0 5
122725: PPUSH
122726: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
122730: LD_VAR 0 10
122734: PPUSH
122735: LD_VAR 0 5
122739: PPUSH
122740: CALL_OW 180
// end ; end ; unit_human :
122744: GO 123011
122746: LD_INT 1
122748: DOUBLE
122749: EQUAL
122750: IFTRUE 122754
122752: GO 123010
122754: POP
// begin b := IsInUnit ( i ) ;
122755: LD_ADDR_VAR 0 19
122759: PUSH
122760: LD_VAR 0 5
122764: PPUSH
122765: CALL_OW 310
122769: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
122770: LD_ADDR_VAR 0 20
122774: PUSH
122775: LD_VAR 0 19
122779: NOT
122780: PUSH
122781: LD_VAR 0 19
122785: PPUSH
122786: CALL_OW 266
122790: PUSH
122791: LD_INT 32
122793: PUSH
122794: LD_INT 31
122796: PUSH
122797: EMPTY
122798: LIST
122799: LIST
122800: IN
122801: OR
122802: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
122803: LD_VAR 0 17
122807: PUSH
122808: LD_VAR 0 2
122812: PPUSH
122813: LD_INT 21
122815: PUSH
122816: LD_INT 2
122818: PUSH
122819: EMPTY
122820: LIST
122821: LIST
122822: PPUSH
122823: CALL_OW 72
122827: PUSH
122828: LD_INT 1
122830: LESSEQUAL
122831: OR
122832: PUSH
122833: LD_VAR 0 20
122837: AND
122838: PUSH
122839: LD_VAR 0 5
122843: PUSH
122844: LD_VAR 0 18
122848: IN
122849: NOT
122850: AND
122851: IFFALSE 122944
// begin if b then
122853: LD_VAR 0 19
122857: IFFALSE 122906
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
122859: LD_VAR 0 19
122863: PPUSH
122864: LD_VAR 0 3
122868: PPUSH
122869: LD_VAR 0 19
122873: PPUSH
122874: CALL_OW 74
122878: PPUSH
122879: CALL_OW 296
122883: PUSH
122884: LD_INT 10
122886: LESS
122887: PUSH
122888: LD_VAR 0 19
122892: PPUSH
122893: CALL_OW 461
122897: PUSH
122898: LD_INT 7
122900: NONEQUAL
122901: AND
122902: IFFALSE 122906
// continue ;
122904: GO 122221
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
122906: LD_ADDR_VAR 0 18
122910: PUSH
122911: LD_VAR 0 18
122915: PPUSH
122916: LD_VAR 0 18
122920: PUSH
122921: LD_INT 1
122923: PLUS
122924: PPUSH
122925: LD_VAR 0 5
122929: PPUSH
122930: CALL_OW 1
122934: ST_TO_ADDR
// ComExitBuilding ( i ) ;
122935: LD_VAR 0 5
122939: PPUSH
122940: CALL_OW 122
// end ; if sold_defenders then
122944: LD_VAR 0 18
122948: IFFALSE 123008
// if i in sold_defenders then
122950: LD_VAR 0 5
122954: PUSH
122955: LD_VAR 0 18
122959: IN
122960: IFFALSE 123008
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
122962: LD_VAR 0 5
122966: PPUSH
122967: CALL_OW 314
122971: NOT
122972: PUSH
122973: LD_VAR 0 5
122977: PPUSH
122978: LD_VAR 0 14
122982: PPUSH
122983: CALL_OW 296
122987: PUSH
122988: LD_INT 30
122990: LESS
122991: AND
122992: IFFALSE 123008
// ComAttackUnit ( i , e ) ;
122994: LD_VAR 0 5
122998: PPUSH
122999: LD_VAR 0 14
123003: PPUSH
123004: CALL_OW 115
// end ; end ; end ;
123008: GO 123011
123010: POP
// if IsDead ( i ) then
123011: LD_VAR 0 5
123015: PPUSH
123016: CALL_OW 301
123020: IFFALSE 123038
// defenders := defenders diff i ;
123022: LD_ADDR_VAR 0 2
123026: PUSH
123027: LD_VAR 0 2
123031: PUSH
123032: LD_VAR 0 5
123036: DIFF
123037: ST_TO_ADDR
// end ;
123038: GO 122221
123040: POP
123041: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123042: LD_VAR 0 3
123046: NOT
123047: PUSH
123048: LD_VAR 0 2
123052: NOT
123053: OR
123054: PUSH
123055: LD_EXP 112
123059: PUSH
123060: LD_VAR 0 1
123064: ARRAY
123065: NOT
123066: OR
123067: IFFALSE 122125
// MC_Reset ( base , 18 ) ;
123069: LD_VAR 0 1
123073: PPUSH
123074: LD_INT 18
123076: PPUSH
123077: CALL 39159 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123081: LD_ADDR_VAR 0 2
123085: PUSH
123086: LD_VAR 0 2
123090: PUSH
123091: LD_VAR 0 2
123095: PPUSH
123096: LD_INT 2
123098: PUSH
123099: LD_INT 25
123101: PUSH
123102: LD_INT 1
123104: PUSH
123105: EMPTY
123106: LIST
123107: LIST
123108: PUSH
123109: LD_INT 25
123111: PUSH
123112: LD_INT 5
123114: PUSH
123115: EMPTY
123116: LIST
123117: LIST
123118: PUSH
123119: LD_INT 25
123121: PUSH
123122: LD_INT 8
123124: PUSH
123125: EMPTY
123126: LIST
123127: LIST
123128: PUSH
123129: LD_INT 25
123131: PUSH
123132: LD_INT 9
123134: PUSH
123135: EMPTY
123136: LIST
123137: LIST
123138: PUSH
123139: EMPTY
123140: LIST
123141: LIST
123142: LIST
123143: LIST
123144: LIST
123145: PPUSH
123146: CALL_OW 72
123150: DIFF
123151: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
123152: LD_VAR 0 3
123156: NOT
123157: PUSH
123158: LD_VAR 0 2
123162: PPUSH
123163: LD_INT 21
123165: PUSH
123166: LD_INT 2
123168: PUSH
123169: EMPTY
123170: LIST
123171: LIST
123172: PPUSH
123173: CALL_OW 72
123177: AND
123178: IFFALSE 123516
// begin tmp := FilterByTag ( defenders , 19 ) ;
123180: LD_ADDR_VAR 0 12
123184: PUSH
123185: LD_VAR 0 2
123189: PPUSH
123190: LD_INT 19
123192: PPUSH
123193: CALL 98611 0 2
123197: ST_TO_ADDR
// if tmp then
123198: LD_VAR 0 12
123202: IFFALSE 123272
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
123204: LD_ADDR_VAR 0 12
123208: PUSH
123209: LD_VAR 0 12
123213: PPUSH
123214: LD_INT 25
123216: PUSH
123217: LD_INT 3
123219: PUSH
123220: EMPTY
123221: LIST
123222: LIST
123223: PPUSH
123224: CALL_OW 72
123228: ST_TO_ADDR
// if tmp then
123229: LD_VAR 0 12
123233: IFFALSE 123272
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
123235: LD_ADDR_EXP 124
123239: PUSH
123240: LD_EXP 124
123244: PPUSH
123245: LD_VAR 0 1
123249: PPUSH
123250: LD_EXP 124
123254: PUSH
123255: LD_VAR 0 1
123259: ARRAY
123260: PUSH
123261: LD_VAR 0 12
123265: UNION
123266: PPUSH
123267: CALL_OW 1
123271: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
123272: LD_VAR 0 1
123276: PPUSH
123277: LD_INT 19
123279: PPUSH
123280: CALL 39159 0 2
// repeat wait ( 0 0$1 ) ;
123284: LD_INT 35
123286: PPUSH
123287: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123291: LD_EXP 112
123295: PUSH
123296: LD_VAR 0 1
123300: ARRAY
123301: NOT
123302: PUSH
123303: LD_EXP 112
123307: PUSH
123308: LD_VAR 0 1
123312: ARRAY
123313: PUSH
123314: EMPTY
123315: EQUAL
123316: OR
123317: IFFALSE 123354
// begin for i in defenders do
123319: LD_ADDR_VAR 0 5
123323: PUSH
123324: LD_VAR 0 2
123328: PUSH
123329: FOR_IN
123330: IFFALSE 123343
// ComStop ( i ) ;
123332: LD_VAR 0 5
123336: PPUSH
123337: CALL_OW 141
123341: GO 123329
123343: POP
123344: POP
// defenders := [ ] ;
123345: LD_ADDR_VAR 0 2
123349: PUSH
123350: EMPTY
123351: ST_TO_ADDR
// exit ;
123352: GO 123540
// end ; for i in defenders do
123354: LD_ADDR_VAR 0 5
123358: PUSH
123359: LD_VAR 0 2
123363: PUSH
123364: FOR_IN
123365: IFFALSE 123454
// begin if not IsInArea ( i , mc_parking [ base ] ) then
123367: LD_VAR 0 5
123371: PPUSH
123372: LD_EXP 136
123376: PUSH
123377: LD_VAR 0 1
123381: ARRAY
123382: PPUSH
123383: CALL_OW 308
123387: NOT
123388: IFFALSE 123412
// ComMoveToArea ( i , mc_parking [ base ] ) else
123390: LD_VAR 0 5
123394: PPUSH
123395: LD_EXP 136
123399: PUSH
123400: LD_VAR 0 1
123404: ARRAY
123405: PPUSH
123406: CALL_OW 113
123410: GO 123452
// if GetControl ( i ) = control_manual then
123412: LD_VAR 0 5
123416: PPUSH
123417: CALL_OW 263
123421: PUSH
123422: LD_INT 1
123424: EQUAL
123425: IFFALSE 123452
// if IsDrivenBy ( i ) then
123427: LD_VAR 0 5
123431: PPUSH
123432: CALL_OW 311
123436: IFFALSE 123452
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
123438: LD_VAR 0 5
123442: PPUSH
123443: CALL_OW 311
123447: PPUSH
123448: CALL_OW 121
// end ;
123452: GO 123364
123454: POP
123455: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
123456: LD_VAR 0 2
123460: PPUSH
123461: LD_INT 95
123463: PUSH
123464: LD_EXP 136
123468: PUSH
123469: LD_VAR 0 1
123473: ARRAY
123474: PUSH
123475: EMPTY
123476: LIST
123477: LIST
123478: PPUSH
123479: CALL_OW 72
123483: PUSH
123484: LD_VAR 0 2
123488: EQUAL
123489: PUSH
123490: LD_EXP 135
123494: PUSH
123495: LD_VAR 0 1
123499: ARRAY
123500: OR
123501: PUSH
123502: LD_EXP 112
123506: PUSH
123507: LD_VAR 0 1
123511: ARRAY
123512: NOT
123513: OR
123514: IFFALSE 123284
// end ; MC_Reset ( base , 19 ) ;
123516: LD_VAR 0 1
123520: PPUSH
123521: LD_INT 19
123523: PPUSH
123524: CALL 39159 0 2
// MC_Reset ( base , 20 ) ;
123528: LD_VAR 0 1
123532: PPUSH
123533: LD_INT 20
123535: PPUSH
123536: CALL 39159 0 2
// end ;
123540: LD_VAR 0 4
123544: RET
