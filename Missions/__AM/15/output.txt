// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 36531 0 0
// InitNature ;
  19: CALL 36399 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11799 0 0
// PrepareRussian ;
  40: CALL 7071 0 0
// PrepareLegion ;
  44: CALL 4242 0 0
// PreparePowell ;
  48: CALL 3044 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 15866 0 0
// MC_Start ( ) ;
  60: CALL 38703 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 123
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 124
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 61501 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 61594 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 60944 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 1
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 1
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 60759 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 61501 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 61594 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 60759 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 60944 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 61374 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 60441 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 61501 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 61594 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 128
 971: PUSH
 972: LD_EXP 128
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 60759 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 61501 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 61594 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 60651 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 61912 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 61083 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 61374 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 61374 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 61706 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 60759 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 61325 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 67195 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 72210 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 72210 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 57
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 57
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 72210 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 57
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 57
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 57
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 57
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 72210 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 72210 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 58
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 58
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 58
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 67195 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 58
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 67195 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 58
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 67195 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 58
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 67195 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2433
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery =  ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING 
2394: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2395: LD_INT 1
2397: PPUSH
2398: LD_INT 10
2400: PPUSH
2401: CALL_OW 384
// Baker = CreateHuman ;
2405: LD_ADDR_EXP 56
2409: PUSH
2410: CALL_OW 44
2414: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2415: LD_ADDR_VAR 0 2
2419: PUSH
2420: LD_VAR 0 2
2424: PUSH
2425: LD_EXP 56
2429: ADD
2430: ST_TO_ADDR
// end else
2431: GO 2449
// tmp := tmp ^ Stevens ;
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 2
2442: PUSH
2443: LD_EXP 42
2447: ADD
2448: ST_TO_ADDR
// if not Lisa then
2449: LD_EXP 43
2453: NOT
2454: IFFALSE 2500
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2456: LD_ADDR_EXP 43
2460: PUSH
2461: LD_STRING Lisa
2463: PPUSH
2464: LD_EXP 1
2468: NOT
2469: PPUSH
2470: LD_STRING 13f_
2472: PPUSH
2473: CALL 67195 0 3
2477: ST_TO_ADDR
// if Lisa then
2478: LD_EXP 43
2482: IFFALSE 2500
// tmp := tmp ^ Lisa ;
2484: LD_ADDR_VAR 0 2
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_EXP 43
2498: ADD
2499: ST_TO_ADDR
// end ; if not Donaldson then
2500: LD_EXP 44
2504: NOT
2505: IFFALSE 2551
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2507: LD_ADDR_EXP 44
2511: PUSH
2512: LD_STRING Donaldson
2514: PPUSH
2515: LD_EXP 1
2519: NOT
2520: PPUSH
2521: LD_STRING 13f_
2523: PPUSH
2524: CALL 67195 0 3
2528: ST_TO_ADDR
// if Donaldson then
2529: LD_EXP 44
2533: IFFALSE 2551
// tmp := tmp ^ Donaldson ;
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 2
2544: PUSH
2545: LD_EXP 44
2549: ADD
2550: ST_TO_ADDR
// end ; if not Bobby then
2551: LD_EXP 45
2555: NOT
2556: IFFALSE 2602
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2558: LD_ADDR_EXP 45
2562: PUSH
2563: LD_STRING Bobby
2565: PPUSH
2566: LD_EXP 1
2570: NOT
2571: PPUSH
2572: LD_STRING 13f_
2574: PPUSH
2575: CALL 67195 0 3
2579: ST_TO_ADDR
// if Bobby then
2580: LD_EXP 45
2584: IFFALSE 2602
// tmp := tmp ^ Bobby ;
2586: LD_ADDR_VAR 0 2
2590: PUSH
2591: LD_VAR 0 2
2595: PUSH
2596: LD_EXP 45
2600: ADD
2601: ST_TO_ADDR
// end ; if not Cyrus then
2602: LD_EXP 46
2606: NOT
2607: IFFALSE 2653
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2609: LD_ADDR_EXP 46
2613: PUSH
2614: LD_STRING Cyrus
2616: PPUSH
2617: LD_EXP 1
2621: NOT
2622: PPUSH
2623: LD_STRING 13f_
2625: PPUSH
2626: CALL 67195 0 3
2630: ST_TO_ADDR
// if Cyrus then
2631: LD_EXP 46
2635: IFFALSE 2653
// tmp := tmp ^ Cyrus ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_VAR 0 2
2646: PUSH
2647: LD_EXP 46
2651: ADD
2652: ST_TO_ADDR
// end ; if not Brown then
2653: LD_EXP 48
2657: NOT
2658: IFFALSE 2704
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2660: LD_ADDR_EXP 48
2664: PUSH
2665: LD_STRING Brown
2667: PPUSH
2668: LD_EXP 1
2672: NOT
2673: PPUSH
2674: LD_STRING 13f_
2676: PPUSH
2677: CALL 67195 0 3
2681: ST_TO_ADDR
// if Brown then
2682: LD_EXP 48
2686: IFFALSE 2704
// tmp := tmp ^ Brown ;
2688: LD_ADDR_VAR 0 2
2692: PUSH
2693: LD_VAR 0 2
2697: PUSH
2698: LD_EXP 48
2702: ADD
2703: ST_TO_ADDR
// end ; if not Gladstone then
2704: LD_EXP 49
2708: NOT
2709: IFFALSE 2755
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2711: LD_ADDR_EXP 49
2715: PUSH
2716: LD_STRING Gladstone
2718: PPUSH
2719: LD_EXP 1
2723: NOT
2724: PPUSH
2725: LD_STRING 13f_
2727: PPUSH
2728: CALL 67195 0 3
2732: ST_TO_ADDR
// if Gladstone then
2733: LD_EXP 49
2737: IFFALSE 2755
// tmp := tmp ^ Gladstone ;
2739: LD_ADDR_VAR 0 2
2743: PUSH
2744: LD_VAR 0 2
2748: PUSH
2749: LD_EXP 49
2753: ADD
2754: ST_TO_ADDR
// end ; if not Houten then
2755: LD_EXP 50
2759: NOT
2760: IFFALSE 2806
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2762: LD_ADDR_EXP 50
2766: PUSH
2767: LD_STRING Houten
2769: PPUSH
2770: LD_EXP 1
2774: NOT
2775: PPUSH
2776: LD_STRING 13f_
2778: PPUSH
2779: CALL 67195 0 3
2783: ST_TO_ADDR
// if Houten then
2784: LD_EXP 50
2788: IFFALSE 2806
// tmp := tmp ^ Houten ;
2790: LD_ADDR_VAR 0 2
2794: PUSH
2795: LD_VAR 0 2
2799: PUSH
2800: LD_EXP 50
2804: ADD
2805: ST_TO_ADDR
// end ; if not Cornel then
2806: LD_EXP 51
2810: NOT
2811: IFFALSE 2857
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2813: LD_ADDR_EXP 51
2817: PUSH
2818: LD_STRING Cornell
2820: PPUSH
2821: LD_EXP 1
2825: NOT
2826: PPUSH
2827: LD_STRING 13f_
2829: PPUSH
2830: CALL 67195 0 3
2834: ST_TO_ADDR
// if Cornel then
2835: LD_EXP 51
2839: IFFALSE 2857
// tmp := tmp ^ Cornel ;
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: LD_VAR 0 2
2850: PUSH
2851: LD_EXP 51
2855: ADD
2856: ST_TO_ADDR
// end ; if not Gary then
2857: LD_EXP 52
2861: NOT
2862: IFFALSE 2908
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2864: LD_ADDR_EXP 52
2868: PUSH
2869: LD_STRING Gary
2871: PPUSH
2872: LD_EXP 1
2876: NOT
2877: PPUSH
2878: LD_STRING 13f_
2880: PPUSH
2881: CALL 67195 0 3
2885: ST_TO_ADDR
// if Gary then
2886: LD_EXP 52
2890: IFFALSE 2908
// tmp := tmp ^ Gary ;
2892: LD_ADDR_VAR 0 2
2896: PUSH
2897: LD_VAR 0 2
2901: PUSH
2902: LD_EXP 52
2906: ADD
2907: ST_TO_ADDR
// end ; if not Frank then
2908: LD_EXP 53
2912: NOT
2913: IFFALSE 2959
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2915: LD_ADDR_EXP 53
2919: PUSH
2920: LD_STRING Frank
2922: PPUSH
2923: LD_EXP 1
2927: NOT
2928: PPUSH
2929: LD_STRING 13f_
2931: PPUSH
2932: CALL 67195 0 3
2936: ST_TO_ADDR
// if Frank then
2937: LD_EXP 53
2941: IFFALSE 2959
// tmp := tmp ^ Frank ;
2943: LD_ADDR_VAR 0 2
2947: PUSH
2948: LD_VAR 0 2
2952: PUSH
2953: LD_EXP 53
2957: ADD
2958: ST_TO_ADDR
// end ; if not Kikuchi then
2959: LD_EXP 54
2963: NOT
2964: IFFALSE 3010
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2966: LD_ADDR_EXP 54
2970: PUSH
2971: LD_STRING Kikuchi
2973: PPUSH
2974: LD_EXP 1
2978: NOT
2979: PPUSH
2980: LD_STRING 13f_
2982: PPUSH
2983: CALL 67195 0 3
2987: ST_TO_ADDR
// if Kikuchi then
2988: LD_EXP 54
2992: IFFALSE 3010
// tmp := tmp ^ Kikuchi ;
2994: LD_ADDR_VAR 0 2
2998: PUSH
2999: LD_VAR 0 2
3003: PUSH
3004: LD_EXP 54
3008: ADD
3009: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3010: LD_ADDR_VAR 0 2
3014: PUSH
3015: LD_VAR 0 2
3019: PUSH
3020: LD_STRING 13_other_survivors
3022: PPUSH
3023: CALL_OW 31
3027: UNION
3028: ST_TO_ADDR
// result := tmp ;
3029: LD_ADDR_VAR 0 1
3033: PUSH
3034: LD_VAR 0 2
3038: ST_TO_ADDR
// end ; end_of_file
3039: LD_VAR 0 1
3043: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3044: LD_INT 0
3046: PPUSH
3047: PPUSH
3048: PPUSH
3049: PPUSH
3050: PPUSH
3051: PPUSH
3052: PPUSH
3053: PPUSH
3054: PPUSH
3055: PPUSH
// uc_side := 4 ;
3056: LD_ADDR_OWVAR 20
3060: PUSH
3061: LD_INT 4
3063: ST_TO_ADDR
// uc_nation := 1 ;
3064: LD_ADDR_OWVAR 21
3068: PUSH
3069: LD_INT 1
3071: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3072: LD_INT 387
3074: PPUSH
3075: CALL_OW 274
3079: PPUSH
3080: LD_INT 1
3082: PPUSH
3083: LD_INT 3500
3085: PUSH
3086: LD_INT 3000
3088: PUSH
3089: LD_INT 2500
3091: PUSH
3092: LD_INT 2000
3094: PUSH
3095: EMPTY
3096: LIST
3097: LIST
3098: LIST
3099: LIST
3100: PUSH
3101: LD_OWVAR 67
3105: ARRAY
3106: PPUSH
3107: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3111: LD_INT 387
3113: PPUSH
3114: CALL_OW 274
3118: PPUSH
3119: LD_INT 2
3121: PPUSH
3122: LD_INT 400
3124: PPUSH
3125: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3129: LD_INT 387
3131: PPUSH
3132: CALL_OW 274
3136: PPUSH
3137: LD_INT 3
3139: PPUSH
3140: LD_INT 10
3142: PPUSH
3143: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3147: LD_ADDR_EXP 59
3151: PUSH
3152: LD_STRING Powell
3154: PPUSH
3155: CALL_OW 25
3159: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3160: LD_EXP 59
3164: PPUSH
3165: LD_INT 57
3167: PPUSH
3168: LD_INT 94
3170: PPUSH
3171: LD_INT 0
3173: PPUSH
3174: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3178: LD_EXP 59
3182: PPUSH
3183: LD_INT 58
3185: PPUSH
3186: LD_INT 94
3188: PPUSH
3189: CALL_OW 118
// vip := [ ] ;
3193: LD_ADDR_EXP 60
3197: PUSH
3198: EMPTY
3199: ST_TO_ADDR
// tmp := [ ] ;
3200: LD_ADDR_VAR 0 5
3204: PUSH
3205: EMPTY
3206: ST_TO_ADDR
// if JMMGirl <> 2 then
3207: LD_EXP 7
3211: PUSH
3212: LD_INT 2
3214: NONEQUAL
3215: IFFALSE 3239
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3217: LD_ADDR_EXP 43
3221: PUSH
3222: LD_STRING Lisa
3224: PPUSH
3225: LD_EXP 1
3229: NOT
3230: PPUSH
3231: LD_STRING 13s_
3233: PPUSH
3234: CALL 67195 0 3
3238: ST_TO_ADDR
// if Lisa then
3239: LD_EXP 43
3243: IFFALSE 3261
// tmp := tmp ^ Lisa ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_VAR 0 5
3254: PUSH
3255: LD_EXP 43
3259: ADD
3260: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3261: LD_ADDR_EXP 44
3265: PUSH
3266: LD_STRING Donaldson
3268: PPUSH
3269: LD_EXP 1
3273: NOT
3274: PPUSH
3275: LD_STRING 13s_
3277: PPUSH
3278: CALL 67195 0 3
3282: ST_TO_ADDR
// if Donaldson then
3283: LD_EXP 44
3287: IFFALSE 3305
// tmp := tmp ^ Donaldson ;
3289: LD_ADDR_VAR 0 5
3293: PUSH
3294: LD_VAR 0 5
3298: PUSH
3299: LD_EXP 44
3303: ADD
3304: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3305: LD_ADDR_EXP 45
3309: PUSH
3310: LD_STRING Bobby
3312: PPUSH
3313: LD_EXP 1
3317: NOT
3318: PPUSH
3319: LD_STRING 13s_
3321: PPUSH
3322: CALL 67195 0 3
3326: ST_TO_ADDR
// if Bobby then
3327: LD_EXP 45
3331: IFFALSE 3349
// tmp := tmp ^ Bobby ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: LD_EXP 45
3347: ADD
3348: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3349: LD_ADDR_EXP 46
3353: PUSH
3354: LD_STRING Cyrus
3356: PPUSH
3357: LD_EXP 1
3361: NOT
3362: PPUSH
3363: LD_STRING 13s_
3365: PPUSH
3366: CALL 67195 0 3
3370: ST_TO_ADDR
// if Cyrus then
3371: LD_EXP 46
3375: IFFALSE 3393
// tmp := tmp ^ Cyrus ;
3377: LD_ADDR_VAR 0 5
3381: PUSH
3382: LD_VAR 0 5
3386: PUSH
3387: LD_EXP 46
3391: ADD
3392: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3393: LD_ADDR_EXP 47
3397: PUSH
3398: LD_STRING Denis
3400: PPUSH
3401: LD_EXP 1
3405: NOT
3406: PPUSH
3407: LD_STRING 13s_
3409: PPUSH
3410: CALL 67195 0 3
3414: ST_TO_ADDR
// if not Denis then
3415: LD_EXP 47
3419: NOT
3420: IFFALSE 3444
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3422: LD_ADDR_EXP 47
3426: PUSH
3427: LD_STRING Denis
3429: PPUSH
3430: LD_EXP 1
3434: NOT
3435: PPUSH
3436: LD_STRING 13f_
3438: PPUSH
3439: CALL 67195 0 3
3443: ST_TO_ADDR
// if Denis then
3444: LD_EXP 47
3448: IFFALSE 3466
// tmp := tmp ^ Denis ;
3450: LD_ADDR_VAR 0 5
3454: PUSH
3455: LD_VAR 0 5
3459: PUSH
3460: LD_EXP 47
3464: ADD
3465: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3466: LD_ADDR_EXP 48
3470: PUSH
3471: LD_STRING Brown
3473: PPUSH
3474: LD_EXP 1
3478: NOT
3479: PPUSH
3480: LD_STRING 13s_
3482: PPUSH
3483: CALL 67195 0 3
3487: ST_TO_ADDR
// if Brown then
3488: LD_EXP 48
3492: IFFALSE 3510
// tmp := tmp ^ Brown ;
3494: LD_ADDR_VAR 0 5
3498: PUSH
3499: LD_VAR 0 5
3503: PUSH
3504: LD_EXP 48
3508: ADD
3509: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3510: LD_ADDR_EXP 49
3514: PUSH
3515: LD_STRING Gladstone
3517: PPUSH
3518: LD_EXP 1
3522: NOT
3523: PPUSH
3524: LD_STRING 13s_
3526: PPUSH
3527: CALL 67195 0 3
3531: ST_TO_ADDR
// if Gladstone then
3532: LD_EXP 49
3536: IFFALSE 3554
// tmp := tmp ^ Gladstone ;
3538: LD_ADDR_VAR 0 5
3542: PUSH
3543: LD_VAR 0 5
3547: PUSH
3548: LD_EXP 49
3552: ADD
3553: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3554: LD_ADDR_EXP 50
3558: PUSH
3559: LD_STRING Houten
3561: PPUSH
3562: LD_EXP 1
3566: NOT
3567: PPUSH
3568: LD_STRING 13s_
3570: PPUSH
3571: CALL 67195 0 3
3575: ST_TO_ADDR
// if Houten then
3576: LD_EXP 50
3580: IFFALSE 3598
// tmp := tmp ^ Houten ;
3582: LD_ADDR_VAR 0 5
3586: PUSH
3587: LD_VAR 0 5
3591: PUSH
3592: LD_EXP 50
3596: ADD
3597: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3598: LD_ADDR_EXP 51
3602: PUSH
3603: LD_STRING Cornel
3605: PPUSH
3606: LD_EXP 1
3610: NOT
3611: PPUSH
3612: LD_STRING 13s_
3614: PPUSH
3615: CALL 67195 0 3
3619: ST_TO_ADDR
// if Cornel then
3620: LD_EXP 51
3624: IFFALSE 3642
// tmp := tmp ^ Cornel ;
3626: LD_ADDR_VAR 0 5
3630: PUSH
3631: LD_VAR 0 5
3635: PUSH
3636: LD_EXP 51
3640: ADD
3641: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3642: LD_ADDR_EXP 52
3646: PUSH
3647: LD_STRING Gary
3649: PPUSH
3650: LD_EXP 1
3654: NOT
3655: PPUSH
3656: LD_STRING 13s_
3658: PPUSH
3659: CALL 67195 0 3
3663: ST_TO_ADDR
// if Gary then
3664: LD_EXP 52
3668: IFFALSE 3686
// tmp := tmp ^ Gary ;
3670: LD_ADDR_VAR 0 5
3674: PUSH
3675: LD_VAR 0 5
3679: PUSH
3680: LD_EXP 52
3684: ADD
3685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3686: LD_ADDR_EXP 53
3690: PUSH
3691: LD_STRING Frank
3693: PPUSH
3694: LD_EXP 1
3698: NOT
3699: PPUSH
3700: LD_STRING 13s_
3702: PPUSH
3703: CALL 67195 0 3
3707: ST_TO_ADDR
// if Frank then
3708: LD_EXP 53
3712: IFFALSE 3730
// tmp := tmp ^ Frank ;
3714: LD_ADDR_VAR 0 5
3718: PUSH
3719: LD_VAR 0 5
3723: PUSH
3724: LD_EXP 53
3728: ADD
3729: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3730: LD_ADDR_EXP 54
3734: PUSH
3735: LD_STRING Kikuchi
3737: PPUSH
3738: LD_EXP 1
3742: NOT
3743: PPUSH
3744: LD_STRING 13s_
3746: PPUSH
3747: CALL 67195 0 3
3751: ST_TO_ADDR
// if Kikuchi then
3752: LD_EXP 54
3756: IFFALSE 3774
// tmp := tmp ^ Kikuchi ;
3758: LD_ADDR_VAR 0 5
3762: PUSH
3763: LD_VAR 0 5
3767: PUSH
3768: LD_EXP 54
3772: ADD
3773: ST_TO_ADDR
// vip := tmp ;
3774: LD_ADDR_EXP 60
3778: PUSH
3779: LD_VAR 0 5
3783: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3784: LD_ADDR_VAR 0 5
3788: PUSH
3789: LD_VAR 0 5
3793: PUSH
3794: LD_STRING 13s_others
3796: PPUSH
3797: CALL_OW 31
3801: UNION
3802: ST_TO_ADDR
// if tmp < 18 then
3803: LD_VAR 0 5
3807: PUSH
3808: LD_INT 18
3810: LESS
3811: IFFALSE 3904
// for i = 1 to 18 - tmp do
3813: LD_ADDR_VAR 0 2
3817: PUSH
3818: DOUBLE
3819: LD_INT 1
3821: DEC
3822: ST_TO_ADDR
3823: LD_INT 18
3825: PUSH
3826: LD_VAR 0 5
3830: MINUS
3831: PUSH
3832: FOR_TO
3833: IFFALSE 3902
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3835: LD_INT 1
3837: PPUSH
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 4
3845: MOD
3846: PUSH
3847: LD_INT 1
3849: PLUS
3850: PPUSH
3851: LD_INT 4
3853: PPUSH
3854: CALL_OW 380
// un := CreateHuman ;
3858: LD_ADDR_VAR 0 10
3862: PUSH
3863: CALL_OW 44
3867: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3868: LD_ADDR_VAR 0 5
3872: PUSH
3873: LD_VAR 0 5
3877: PPUSH
3878: LD_VAR 0 10
3882: PPUSH
3883: CALL 104644 0 2
3887: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3888: LD_VAR 0 10
3892: PPUSH
3893: LD_INT 1
3895: PPUSH
3896: CALL_OW 109
// end ;
3900: GO 3832
3902: POP
3903: POP
// depot := HexInfo ( 53 , 94 ) ;
3904: LD_ADDR_VAR 0 6
3908: PUSH
3909: LD_INT 53
3911: PPUSH
3912: LD_INT 94
3914: PPUSH
3915: CALL_OW 428
3919: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
3920: LD_ADDR_VAR 0 7
3924: PUSH
3925: LD_INT 56
3927: PPUSH
3928: LD_INT 101
3930: PPUSH
3931: CALL_OW 428
3935: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
3936: LD_ADDR_VAR 0 8
3940: PUSH
3941: LD_INT 67
3943: PPUSH
3944: LD_INT 101
3946: PPUSH
3947: CALL_OW 428
3951: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
3952: LD_ADDR_VAR 0 9
3956: PUSH
3957: LD_INT 54
3959: PPUSH
3960: LD_INT 85
3962: PPUSH
3963: CALL_OW 428
3967: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
3968: LD_ADDR_VAR 0 3
3972: PUSH
3973: LD_VAR 0 8
3977: PUSH
3978: LD_VAR 0 6
3982: PUSH
3983: LD_VAR 0 9
3987: PUSH
3988: LD_VAR 0 7
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: LIST
3997: LIST
3998: ST_TO_ADDR
// for i in tmp do
3999: LD_ADDR_VAR 0 2
4003: PUSH
4004: LD_VAR 0 5
4008: PUSH
4009: FOR_IN
4010: IFFALSE 4098
// begin if UnitsInside ( b [ 1 ] ) = 6 then
4012: LD_VAR 0 3
4016: PUSH
4017: LD_INT 1
4019: ARRAY
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: EQUAL
4029: IFFALSE 4049
// b := Delete ( b , 1 ) ;
4031: LD_ADDR_VAR 0 3
4035: PUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: LD_INT 1
4043: PPUSH
4044: CALL_OW 3
4048: ST_TO_ADDR
// if b then
4049: LD_VAR 0 3
4053: IFFALSE 4075
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4055: LD_VAR 0 2
4059: PPUSH
4060: LD_VAR 0 3
4064: PUSH
4065: LD_INT 1
4067: ARRAY
4068: PPUSH
4069: CALL_OW 52
4073: GO 4096
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4075: LD_VAR 0 2
4079: PPUSH
4080: LD_INT 61
4082: PPUSH
4083: LD_INT 89
4085: PPUSH
4086: LD_INT 8
4088: PPUSH
4089: LD_INT 0
4091: PPUSH
4092: CALL_OW 50
// end ;
4096: GO 4009
4098: POP
4099: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4100: LD_INT 2
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 1
4108: PPUSH
4109: LD_INT 12
4111: PPUSH
4112: LD_INT 100
4114: PPUSH
4115: CALL 72210 0 5
// veh := CreateVehicle ;
4119: LD_ADDR_VAR 0 4
4123: PUSH
4124: CALL_OW 45
4128: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4129: LD_VAR 0 4
4133: PPUSH
4134: LD_INT 4
4136: PPUSH
4137: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4141: LD_VAR 0 4
4145: PPUSH
4146: LD_INT 49
4148: PPUSH
4149: LD_INT 88
4151: PPUSH
4152: LD_INT 0
4154: PPUSH
4155: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4159: LD_VAR 0 4
4163: PPUSH
4164: LD_INT 1
4166: PPUSH
4167: LD_INT 100
4169: PPUSH
4170: CALL_OW 290
// uc_side := 0 ;
4174: LD_ADDR_OWVAR 20
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// uc_nation := 0 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 0
4189: ST_TO_ADDR
// for i := 1 to 3 do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: DOUBLE
4196: LD_INT 1
4198: DEC
4199: ST_TO_ADDR
4200: LD_INT 3
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4235
// begin InitHc ;
4206: CALL_OW 19
// hc_class := class_apeman ;
4210: LD_ADDR_OWVAR 28
4214: PUSH
4215: LD_INT 12
4217: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4218: CALL_OW 44
4222: PPUSH
4223: LD_INT 13
4225: PPUSH
4226: LD_INT 0
4228: PPUSH
4229: CALL_OW 49
// end ;
4233: GO 4203
4235: POP
4236: POP
// end ; end_of_file
4237: LD_VAR 0 1
4241: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4242: LD_INT 0
4244: PPUSH
4245: PPUSH
4246: PPUSH
4247: PPUSH
4248: PPUSH
// side := 8 ;
4249: LD_ADDR_VAR 0 3
4253: PUSH
4254: LD_INT 8
4256: ST_TO_ADDR
// uc_side := side ;
4257: LD_ADDR_OWVAR 20
4261: PUSH
4262: LD_VAR 0 3
4266: ST_TO_ADDR
// uc_nation := 2 ;
4267: LD_ADDR_OWVAR 21
4271: PUSH
4272: LD_INT 2
4274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4275: LD_ADDR_VAR 0 2
4279: PUSH
4280: LD_INT 22
4282: PUSH
4283: LD_VAR 0 3
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: PUSH
4292: LD_INT 21
4294: PUSH
4295: LD_INT 3
4297: PUSH
4298: EMPTY
4299: LIST
4300: LIST
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PPUSH
4306: CALL_OW 69
4310: PUSH
4311: FOR_IN
4312: IFFALSE 4328
// SetBLevel ( i , 10 ) ;
4314: LD_VAR 0 2
4318: PPUSH
4319: LD_INT 10
4321: PPUSH
4322: CALL_OW 241
4326: GO 4311
4328: POP
4329: POP
// if KurtStatus then
4330: LD_EXP 3
4334: IFFALSE 4357
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4336: LD_ADDR_EXP 61
4340: PUSH
4341: LD_STRING Kurt
4343: PPUSH
4344: LD_INT 0
4346: PPUSH
4347: LD_STRING 
4349: PPUSH
4350: CALL 67195 0 3
4354: ST_TO_ADDR
4355: GO 4379
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4357: LD_ADDR_EXP 61
4361: PUSH
4362: LD_STRING AltKurt
4364: PPUSH
4365: LD_EXP 1
4369: NOT
4370: PPUSH
4371: LD_STRING 
4373: PPUSH
4374: CALL 67195 0 3
4378: ST_TO_ADDR
// if not Kurt then
4379: LD_EXP 61
4383: NOT
4384: IFFALSE 4410
// begin InitHc ;
4386: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4390: LD_INT 1
4392: PPUSH
4393: LD_INT 10
4395: PPUSH
4396: CALL_OW 381
// Kurt := CreateHuman ;
4400: LD_ADDR_EXP 61
4404: PUSH
4405: CALL_OW 44
4409: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4410: LD_EXP 61
4414: PPUSH
4415: LD_INT 324
4417: PPUSH
4418: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4422: LD_ADDR_EXP 62
4426: PUSH
4427: LD_STRING Kozlov
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: LD_STRING 
4435: PPUSH
4436: CALL 67195 0 3
4440: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4441: LD_EXP 62
4445: PPUSH
4446: LD_INT 22
4448: PUSH
4449: LD_INT 8
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: LD_INT 23
4458: PUSH
4459: LD_INT 3
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 30
4468: PUSH
4469: LD_INT 8
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: LIST
4480: PPUSH
4481: CALL_OW 69
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PPUSH
4490: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4494: LD_EXP 62
4498: PPUSH
4499: LD_INT 3
4501: PPUSH
4502: LD_INT 10
4504: PPUSH
4505: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4509: LD_EXP 62
4513: PPUSH
4514: LD_INT 4
4516: PPUSH
4517: LD_INT 10
4519: PPUSH
4520: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4524: LD_ADDR_VAR 0 5
4528: PUSH
4529: LD_INT 22
4531: PUSH
4532: LD_VAR 0 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 30
4543: PUSH
4544: LD_INT 32
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 58
4553: PUSH
4554: EMPTY
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 69
4566: ST_TO_ADDR
// for i = 1 to 10 do
4567: LD_ADDR_VAR 0 2
4571: PUSH
4572: DOUBLE
4573: LD_INT 1
4575: DEC
4576: ST_TO_ADDR
4577: LD_INT 10
4579: PUSH
4580: FOR_TO
4581: IFFALSE 4653
// begin uc_nation := nation_nature ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 0
4590: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4591: LD_ADDR_OWVAR 28
4595: PUSH
4596: LD_INT 15
4598: ST_TO_ADDR
// hc_gallery :=  ;
4599: LD_ADDR_OWVAR 33
4603: PUSH
4604: LD_STRING 
4606: ST_TO_ADDR
// hc_name :=  ;
4607: LD_ADDR_OWVAR 26
4611: PUSH
4612: LD_STRING 
4614: ST_TO_ADDR
// un := CreateHuman ;
4615: LD_ADDR_VAR 0 4
4619: PUSH
4620: CALL_OW 44
4624: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4625: LD_VAR 0 4
4629: PPUSH
4630: LD_VAR 0 5
4634: PUSH
4635: LD_VAR 0 5
4639: PUSH
4640: LD_VAR 0 2
4644: MINUS
4645: ARRAY
4646: PPUSH
4647: CALL_OW 52
// end ;
4651: GO 4580
4653: POP
4654: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4655: LD_ADDR_VAR 0 5
4659: PUSH
4660: LD_STRING 12_kurt_squad
4662: PPUSH
4663: CALL_OW 31
4667: ST_TO_ADDR
// if tmp then
4668: LD_VAR 0 5
4672: IFFALSE 4706
// for i in tmp do
4674: LD_ADDR_VAR 0 2
4678: PUSH
4679: LD_VAR 0 5
4683: PUSH
4684: FOR_IN
4685: IFFALSE 4704
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4687: LD_VAR 0 2
4691: PPUSH
4692: LD_INT 5
4694: PPUSH
4695: LD_INT 0
4697: PPUSH
4698: CALL_OW 49
4702: GO 4684
4704: POP
4705: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4706: LD_INT 324
4708: PPUSH
4709: LD_INT 5
4711: PPUSH
4712: LD_STRING 
4714: PPUSH
4715: LD_INT 8
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: LD_INT 10
4723: PUSH
4724: LD_INT 10
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_OWVAR 67
4737: ARRAY
4738: PPUSH
4739: LD_INT 3000
4741: PUSH
4742: LD_INT 500
4744: PUSH
4745: LD_INT 150
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: LIST
4752: PPUSH
4753: LD_INT 16
4755: PUSH
4756: LD_INT 6
4758: PUSH
4759: LD_INT 6
4761: PUSH
4762: LD_INT 8
4764: PUSH
4765: EMPTY
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: PPUSH
4771: CALL 75654 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4775: LD_ADDR_EXP 99
4779: PUSH
4780: LD_EXP 99
4784: PPUSH
4785: LD_INT 3
4787: PPUSH
4788: LD_INT 22
4790: PUSH
4791: LD_VAR 0 3
4795: PUSH
4796: EMPTY
4797: LIST
4798: LIST
4799: PUSH
4800: LD_INT 23
4802: PUSH
4803: LD_INT 2
4805: PUSH
4806: EMPTY
4807: LIST
4808: LIST
4809: PUSH
4810: LD_INT 3
4812: PUSH
4813: LD_INT 21
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: EMPTY
4824: LIST
4825: LIST
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 69
4836: PUSH
4837: LD_EXP 61
4841: DIFF
4842: PPUSH
4843: CALL_OW 1
4847: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4848: LD_INT 1
4850: PPUSH
4851: LD_INT 7
4853: PPUSH
4854: CALL_OW 383
// Friend := CreateHuman ;
4858: LD_ADDR_EXP 63
4862: PUSH
4863: CALL_OW 44
4867: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4868: LD_INT 14
4870: PPUSH
4871: LD_INT 3
4873: PPUSH
4874: LD_INT 1
4876: PPUSH
4877: LD_INT 29
4879: PPUSH
4880: LD_INT 100
4882: PPUSH
4883: CALL 72210 0 5
// powellBomb := CreateVehicle ;
4887: LD_ADDR_EXP 64
4891: PUSH
4892: CALL_OW 45
4896: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4897: LD_EXP 64
4901: PPUSH
4902: LD_INT 90
4904: PPUSH
4905: LD_INT 51
4907: PPUSH
4908: LD_INT 0
4910: PPUSH
4911: CALL_OW 48
// end ;
4915: LD_VAR 0 1
4919: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4920: LD_INT 0
4922: PPUSH
4923: PPUSH
4924: PPUSH
// if IsLive ( kozlov_fac ) then
4925: LD_INT 332
4927: PPUSH
4928: CALL_OW 300
4932: IFFALSE 4936
// exit ;
4934: GO 5503
// ComExitBuilding ( Kozlov ) ;
4936: LD_EXP 62
4940: PPUSH
4941: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4945: LD_EXP 62
4949: PPUSH
4950: CALL_OW 257
4954: PUSH
4955: LD_INT 2
4957: NONEQUAL
4958: IFFALSE 4993
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4960: LD_EXP 62
4964: PPUSH
4965: LD_INT 324
4967: PPUSH
4968: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4972: LD_EXP 62
4976: PPUSH
4977: LD_INT 2
4979: PPUSH
4980: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4984: LD_EXP 62
4988: PPUSH
4989: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4993: LD_EXP 62
4997: PPUSH
4998: LD_INT 2
5000: PPUSH
5001: LD_INT 93
5003: PPUSH
5004: LD_INT 32
5006: PPUSH
5007: LD_INT 3
5009: PPUSH
5010: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5014: LD_INT 35
5016: PPUSH
5017: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 30
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 23
5043: PUSH
5044: LD_INT 3
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 57
5053: PUSH
5054: EMPTY
5055: LIST
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 69
5067: IFFALSE 5014
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5069: LD_ADDR_VAR 0 2
5073: PUSH
5074: LD_INT 22
5076: PUSH
5077: LD_INT 8
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 30
5086: PUSH
5087: LD_INT 3
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 23
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 57
5106: PUSH
5107: EMPTY
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: PPUSH
5116: CALL_OW 69
5120: PUSH
5121: LD_INT 1
5123: ARRAY
5124: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5125: LD_INT 22
5127: PUSH
5128: LD_INT 8
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 23
5137: PUSH
5138: LD_INT 3
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 30
5147: PUSH
5148: LD_INT 21
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: PPUSH
5160: CALL_OW 69
5164: NOT
5165: IFFALSE 5243
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5167: LD_EXP 62
5171: PPUSH
5172: LD_INT 21
5174: PPUSH
5175: LD_INT 97
5177: PPUSH
5178: LD_INT 36
5180: PPUSH
5181: LD_INT 5
5183: PPUSH
5184: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5195: LD_INT 22
5197: PUSH
5198: LD_INT 8
5200: PUSH
5201: EMPTY
5202: LIST
5203: LIST
5204: PUSH
5205: LD_INT 23
5207: PUSH
5208: LD_INT 3
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PUSH
5215: LD_INT 30
5217: PUSH
5218: LD_INT 21
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 57
5227: PUSH
5228: EMPTY
5229: LIST
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 69
5241: IFFALSE 5188
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5243: LD_INT 22
5245: PUSH
5246: LD_INT 8
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 23
5255: PUSH
5256: LD_INT 3
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 30
5265: PUSH
5266: LD_INT 18
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PPUSH
5278: CALL_OW 69
5282: NOT
5283: IFFALSE 5361
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5285: LD_EXP 62
5289: PPUSH
5290: LD_INT 18
5292: PPUSH
5293: LD_INT 89
5295: PPUSH
5296: LD_INT 32
5298: PPUSH
5299: LD_INT 1
5301: PPUSH
5302: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5306: LD_INT 35
5308: PPUSH
5309: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5313: LD_INT 22
5315: PUSH
5316: LD_INT 8
5318: PUSH
5319: EMPTY
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 23
5325: PUSH
5326: LD_INT 3
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PUSH
5333: LD_INT 30
5335: PUSH
5336: LD_INT 18
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 57
5345: PUSH
5346: EMPTY
5347: LIST
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: PPUSH
5355: CALL_OW 69
5359: IFFALSE 5306
// end ; lab := kozlov_lab ;
5361: LD_ADDR_VAR 0 3
5365: PUSH
5366: LD_INT 336
5368: ST_TO_ADDR
// if not lab then
5369: LD_VAR 0 3
5373: NOT
5374: IFFALSE 5378
// exit ;
5376: GO 5503
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5378: LD_EXP 62
5382: PPUSH
5383: LD_VAR 0 3
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5396: LD_EXP 62
5400: PPUSH
5401: LD_INT 4
5403: PPUSH
5404: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5408: LD_VAR 0 3
5412: PUSH
5413: LD_INT 1
5415: ARRAY
5416: PPUSH
5417: LD_INT 25
5419: PPUSH
5420: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5424: LD_INT 35
5426: PPUSH
5427: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5431: LD_INT 25
5433: PPUSH
5434: LD_INT 8
5436: PPUSH
5437: CALL_OW 321
5441: PUSH
5442: LD_INT 2
5444: EQUAL
5445: IFFALSE 5424
// ComExitBuilding ( Kozlov ) ;
5447: LD_EXP 62
5451: PPUSH
5452: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5456: LD_EXP 62
5460: PPUSH
5461: LD_VAR 0 2
5465: PPUSH
5466: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5470: LD_EXP 62
5474: PPUSH
5475: LD_INT 3
5477: PPUSH
5478: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5482: LD_VAR 0 2
5486: PPUSH
5487: LD_INT 23
5489: PPUSH
5490: LD_INT 3
5492: PPUSH
5493: LD_INT 1
5495: PPUSH
5496: LD_INT 48
5498: PPUSH
5499: CALL_OW 125
// end ;
5503: LD_VAR 0 1
5507: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5508: LD_EXP 22
5512: NOT
5513: PUSH
5514: LD_EXP 15
5518: PUSH
5519: LD_INT 6
5521: GREATEREQUAL
5522: AND
5523: IFFALSE 5604
5525: GO 5527
5527: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5528: LD_INT 3
5530: PPUSH
5531: LD_INT 3
5533: PPUSH
5534: CALL 60944 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5538: LD_INT 3
5540: PPUSH
5541: LD_INT 14
5543: PUSH
5544: LD_INT 1
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: LD_INT 28
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 14
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: EMPTY
5572: LIST
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_INT 14
5579: PUSH
5580: LD_INT 1
5582: PUSH
5583: LD_INT 1
5585: PUSH
5586: LD_INT 28
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: LIST
5593: LIST
5594: PUSH
5595: EMPTY
5596: LIST
5597: LIST
5598: LIST
5599: PPUSH
5600: CALL 60807 0 2
// end ;
5604: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5605: LD_EXP 22
5609: NOT
5610: PUSH
5611: LD_EXP 15
5615: PUSH
5616: LD_INT 6
5618: GREATEREQUAL
5619: AND
5620: PUSH
5621: LD_INT 3
5623: PPUSH
5624: LD_INT 1
5626: PPUSH
5627: CALL 62225 0 2
5631: NOT
5632: AND
5633: IFFALSE 6507
5635: GO 5637
5637: DISABLE
5638: LD_INT 0
5640: PPUSH
5641: PPUSH
5642: PPUSH
// begin enable ;
5643: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5644: LD_INT 22
5646: PUSH
5647: LD_INT 8
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: LD_INT 23
5656: PUSH
5657: LD_INT 2
5659: PUSH
5660: EMPTY
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 30
5666: PUSH
5667: LD_INT 3
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: PPUSH
5679: CALL_OW 69
5683: NOT
5684: IFFALSE 5688
// exit ;
5686: GO 6507
// if Prob ( 40 ) then
5688: LD_INT 40
5690: PPUSH
5691: CALL_OW 13
5695: IFFALSE 5822
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5697: LD_INT 3
5699: PPUSH
5700: LD_INT 14
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: LD_INT 2
5708: PUSH
5709: LD_INT 28
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 14
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: LD_INT 2
5726: PUSH
5727: LD_INT 28
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_INT 14
5738: PUSH
5739: LD_INT 1
5741: PUSH
5742: LD_INT 2
5744: PUSH
5745: LD_INT 28
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: LIST
5753: PUSH
5754: LD_INT 14
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: LD_INT 2
5762: PUSH
5763: LD_INT 28
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 14
5774: PUSH
5775: LD_INT 1
5777: PUSH
5778: LD_INT 2
5780: PUSH
5781: LD_INT 28
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: PUSH
5790: LD_INT 14
5792: PUSH
5793: LD_INT 1
5795: PUSH
5796: LD_INT 2
5798: PUSH
5799: LD_INT 26
5801: PUSH
5802: EMPTY
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL 60807 0 2
// end else
5820: GO 6029
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5822: LD_INT 3
5824: PPUSH
5825: LD_INT 14
5827: PUSH
5828: LD_INT 1
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: LD_INT 27
5836: PUSH
5837: LD_INT 26
5839: PUSH
5840: LD_INT 26
5842: PUSH
5843: LD_INT 28
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: LIST
5850: LIST
5851: PUSH
5852: LD_OWVAR 67
5856: ARRAY
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: PUSH
5864: LD_INT 14
5866: PUSH
5867: LD_INT 1
5869: PUSH
5870: LD_INT 2
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: LD_INT 26
5878: PUSH
5879: LD_INT 26
5881: PUSH
5882: LD_INT 26
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: PUSH
5891: LD_OWVAR 67
5895: ARRAY
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: LD_INT 26
5917: PUSH
5918: LD_INT 29
5920: PUSH
5921: LD_INT 29
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: PUSH
5930: LD_OWVAR 67
5934: ARRAY
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_INT 13
5944: PUSH
5945: LD_INT 1
5947: PUSH
5948: LD_INT 2
5950: PUSH
5951: LD_INT 26
5953: PUSH
5954: LD_INT 29
5956: PUSH
5957: LD_INT 29
5959: PUSH
5960: LD_INT 29
5962: PUSH
5963: EMPTY
5964: LIST
5965: LIST
5966: LIST
5967: LIST
5968: PUSH
5969: LD_OWVAR 67
5973: ARRAY
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 13
5983: PUSH
5984: LD_INT 1
5986: PUSH
5987: LD_INT 2
5989: PUSH
5990: LD_INT 29
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 14
6001: PUSH
6002: LD_INT 1
6004: PUSH
6005: LD_INT 2
6007: PUSH
6008: LD_INT 26
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: LIST
6015: LIST
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL 60807 0 2
// end ; repeat wait ( 0 0$1 ) ;
6029: LD_INT 35
6031: PPUSH
6032: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 62225 0 2
6046: PUSH
6047: LD_INT 6
6049: GREATEREQUAL
6050: IFFALSE 6029
// wait ( 0 0$30 ) ;
6052: LD_INT 1050
6054: PPUSH
6055: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6059: LD_ADDR_VAR 0 2
6063: PUSH
6064: LD_INT 3
6066: PPUSH
6067: LD_INT 1
6069: PPUSH
6070: CALL 62225 0 2
6074: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6075: LD_ADDR_EXP 118
6079: PUSH
6080: LD_EXP 118
6084: PPUSH
6085: LD_INT 3
6087: PPUSH
6088: LD_EXP 118
6092: PUSH
6093: LD_INT 3
6095: ARRAY
6096: PUSH
6097: LD_VAR 0 2
6101: DIFF
6102: PPUSH
6103: CALL_OW 1
6107: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6108: LD_ADDR_VAR 0 3
6112: PUSH
6113: LD_INT 0
6115: PPUSH
6116: LD_INT 2
6118: PPUSH
6119: CALL_OW 12
6123: ST_TO_ADDR
// if target then
6124: LD_VAR 0 3
6128: IFFALSE 6265
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6130: LD_ADDR_VAR 0 2
6134: PUSH
6135: LD_VAR 0 2
6139: PPUSH
6140: LD_INT 24
6142: PUSH
6143: LD_INT 250
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL_OW 72
6154: ST_TO_ADDR
// if not tmp then
6155: LD_VAR 0 2
6159: NOT
6160: IFFALSE 6164
// break ;
6162: GO 6263
// for i in tmp do
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: LD_VAR 0 2
6173: PUSH
6174: FOR_IN
6175: IFFALSE 6215
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6177: LD_VAR 0 1
6181: PPUSH
6182: LD_INT 89
6184: PPUSH
6185: LD_INT 71
6187: PPUSH
6188: CALL_OW 297
6192: PUSH
6193: LD_INT 9
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 89 , 71 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 89
6205: PPUSH
6206: LD_INT 71
6208: PPUSH
6209: CALL_OW 111
6213: GO 6174
6215: POP
6216: POP
// wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6224: LD_VAR 0 2
6228: PPUSH
6229: LD_INT 92
6231: PUSH
6232: LD_INT 89
6234: PUSH
6235: LD_INT 71
6237: PUSH
6238: LD_INT 9
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PPUSH
6247: CALL_OW 72
6251: PUSH
6252: LD_VAR 0 2
6256: PUSH
6257: LD_INT 1
6259: MINUS
6260: GREATEREQUAL
6261: IFFALSE 6130
// end else
6263: GO 6398
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6265: LD_ADDR_VAR 0 2
6269: PUSH
6270: LD_VAR 0 2
6274: PPUSH
6275: LD_INT 24
6277: PUSH
6278: LD_INT 250
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PPUSH
6285: CALL_OW 72
6289: ST_TO_ADDR
// if not tmp then
6290: LD_VAR 0 2
6294: NOT
6295: IFFALSE 6299
// break ;
6297: GO 6398
// for i in tmp do
6299: LD_ADDR_VAR 0 1
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: FOR_IN
6310: IFFALSE 6350
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6312: LD_VAR 0 1
6316: PPUSH
6317: LD_INT 125
6319: PPUSH
6320: LD_INT 129
6322: PPUSH
6323: CALL_OW 297
6327: PUSH
6328: LD_INT 9
6330: GREATER
6331: IFFALSE 6348
// ComMoveXY ( i , 125 , 129 ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_INT 125
6340: PPUSH
6341: LD_INT 129
6343: PPUSH
6344: CALL_OW 111
6348: GO 6309
6350: POP
6351: POP
// wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6359: LD_VAR 0 2
6363: PPUSH
6364: LD_INT 92
6366: PUSH
6367: LD_INT 125
6369: PUSH
6370: LD_INT 129
6372: PUSH
6373: LD_INT 9
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: LIST
6380: LIST
6381: PPUSH
6382: CALL_OW 72
6386: PUSH
6387: LD_VAR 0 2
6391: PUSH
6392: LD_INT 1
6394: MINUS
6395: GREATEREQUAL
6396: IFFALSE 6265
// end ; repeat wait ( 0 0$1 ) ;
6398: LD_INT 35
6400: PPUSH
6401: CALL_OW 67
// for i in tmp do
6405: LD_ADDR_VAR 0 1
6409: PUSH
6410: LD_VAR 0 2
6414: PUSH
6415: FOR_IN
6416: IFFALSE 6498
// begin if GetLives ( i ) > 251 then
6418: LD_VAR 0 1
6422: PPUSH
6423: CALL_OW 256
6427: PUSH
6428: LD_INT 251
6430: GREATER
6431: IFFALSE 6469
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6433: LD_VAR 0 1
6437: PPUSH
6438: LD_INT 81
6440: PUSH
6441: LD_INT 8
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PPUSH
6448: CALL_OW 69
6452: PPUSH
6453: LD_VAR 0 1
6457: PPUSH
6458: CALL_OW 74
6462: PPUSH
6463: CALL_OW 115
6467: GO 6496
// if IsDead ( i ) then
6469: LD_VAR 0 1
6473: PPUSH
6474: CALL_OW 301
6478: IFFALSE 6496
// tmp := tmp diff i ;
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: LD_VAR 0 2
6489: PUSH
6490: LD_VAR 0 1
6494: DIFF
6495: ST_TO_ADDR
// end ;
6496: GO 6415
6498: POP
6499: POP
// until not tmp ;
6500: LD_VAR 0 2
6504: NOT
6505: IFFALSE 6398
// end ;
6507: PPOPN 3
6509: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6510: LD_EXP 22
6514: NOT
6515: PUSH
6516: LD_EXP 15
6520: PUSH
6521: LD_INT 6
6523: GREATEREQUAL
6524: AND
6525: PUSH
6526: LD_OWVAR 67
6530: PUSH
6531: LD_INT 1
6533: GREATER
6534: AND
6535: IFFALSE 7068
6537: GO 6539
6539: DISABLE
6540: LD_INT 0
6542: PPUSH
6543: PPUSH
6544: PPUSH
// begin enable ;
6545: ENABLE
// tmp := [ ] ;
6546: LD_ADDR_VAR 0 3
6550: PUSH
6551: EMPTY
6552: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: DOUBLE
6559: LD_INT 1
6561: DEC
6562: ST_TO_ADDR
6563: LD_INT 4
6565: PUSH
6566: LD_INT 6
6568: PUSH
6569: LD_INT 7
6571: PUSH
6572: LD_INT 8
6574: PUSH
6575: EMPTY
6576: LIST
6577: LIST
6578: LIST
6579: LIST
6580: PUSH
6581: LD_OWVAR 67
6585: ARRAY
6586: PUSH
6587: FOR_TO
6588: IFFALSE 6748
// begin uc_side := 8 ;
6590: LD_ADDR_OWVAR 20
6594: PUSH
6595: LD_INT 8
6597: ST_TO_ADDR
// uc_nation := 2 ;
6598: LD_ADDR_OWVAR 21
6602: PUSH
6603: LD_INT 2
6605: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6606: LD_INT 13
6608: PUSH
6609: LD_INT 14
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: PUSH
6616: LD_INT 1
6618: PPUSH
6619: LD_INT 2
6621: PPUSH
6622: CALL_OW 12
6626: ARRAY
6627: PPUSH
6628: LD_INT 1
6630: PPUSH
6631: LD_INT 5
6633: PPUSH
6634: LD_INT 27
6636: PUSH
6637: LD_INT 28
6639: PUSH
6640: LD_INT 26
6642: PUSH
6643: LD_INT 25
6645: PUSH
6646: EMPTY
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 1
6654: PPUSH
6655: LD_INT 4
6657: PPUSH
6658: CALL_OW 12
6662: ARRAY
6663: PPUSH
6664: LD_INT 88
6666: PPUSH
6667: CALL 72210 0 5
// un := CreateVehicle ;
6671: LD_ADDR_VAR 0 2
6675: PUSH
6676: CALL_OW 45
6680: ST_TO_ADDR
// tmp := tmp ^ un ;
6681: LD_ADDR_VAR 0 3
6685: PUSH
6686: LD_VAR 0 3
6690: PUSH
6691: LD_VAR 0 2
6695: ADD
6696: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 3
6704: PPUSH
6705: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6709: LD_VAR 0 2
6713: PPUSH
6714: LD_INT 30
6716: PPUSH
6717: LD_INT 0
6719: PPUSH
6720: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6724: LD_VAR 0 2
6728: PPUSH
6729: LD_INT 16
6731: PPUSH
6732: LD_INT 11
6734: PPUSH
6735: CALL_OW 111
// wait ( 0 0$2 ) ;
6739: LD_INT 70
6741: PPUSH
6742: CALL_OW 67
// end ;
6746: GO 6587
6748: POP
6749: POP
// for i = 1 to Difficulty do
6750: LD_ADDR_VAR 0 1
6754: PUSH
6755: DOUBLE
6756: LD_INT 1
6758: DEC
6759: ST_TO_ADDR
6760: LD_OWVAR 67
6764: PUSH
6765: FOR_TO
6766: IFFALSE 6895
// begin uc_side := 8 ;
6768: LD_ADDR_OWVAR 20
6772: PUSH
6773: LD_INT 8
6775: ST_TO_ADDR
// uc_nation := 2 ;
6776: LD_ADDR_OWVAR 21
6780: PUSH
6781: LD_INT 2
6783: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6784: LD_INT 0
6786: PPUSH
6787: LD_INT 8
6789: PPUSH
6790: LD_INT 8
6792: PUSH
6793: LD_INT 8
6795: PUSH
6796: LD_INT 9
6798: PUSH
6799: LD_INT 10
6801: PUSH
6802: EMPTY
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_OWVAR 67
6812: ARRAY
6813: PPUSH
6814: CALL_OW 380
// un := CreateHuman ;
6818: LD_ADDR_VAR 0 2
6822: PUSH
6823: CALL_OW 44
6827: ST_TO_ADDR
// tmp := tmp ^ un ;
6828: LD_ADDR_VAR 0 3
6832: PUSH
6833: LD_VAR 0 3
6837: PUSH
6838: LD_VAR 0 2
6842: ADD
6843: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6844: LD_VAR 0 2
6848: PPUSH
6849: LD_INT 3
6851: PPUSH
6852: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6856: LD_VAR 0 2
6860: PPUSH
6861: LD_INT 30
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 16
6878: PPUSH
6879: LD_INT 11
6881: PPUSH
6882: CALL_OW 111
// wait ( 0 0$2 ) ;
6886: LD_INT 70
6888: PPUSH
6889: CALL_OW 67
// end ;
6893: GO 6765
6895: POP
6896: POP
// repeat wait ( 0 0$1 ) ;
6897: LD_INT 35
6899: PPUSH
6900: CALL_OW 67
// if legionDestroyed then
6904: LD_EXP 22
6908: IFFALSE 6912
// exit ;
6910: GO 7068
// for i in tmp do
6912: LD_ADDR_VAR 0 1
6916: PUSH
6917: LD_VAR 0 3
6921: PUSH
6922: FOR_IN
6923: IFFALSE 7059
// begin if GetLives ( i ) > 250 then
6925: LD_VAR 0 1
6929: PPUSH
6930: CALL_OW 256
6934: PUSH
6935: LD_INT 250
6937: GREATER
6938: IFFALSE 7030
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6940: LD_INT 81
6942: PUSH
6943: LD_INT 8
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: PUSH
6950: LD_INT 91
6952: PUSH
6953: LD_VAR 0 1
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PPUSH
6970: CALL_OW 69
6974: NOT
6975: IFFALSE 6994
// ComAgressiveMove ( i , 67 , 110 ) else
6977: LD_VAR 0 1
6981: PPUSH
6982: LD_INT 67
6984: PPUSH
6985: LD_INT 110
6987: PPUSH
6988: CALL_OW 114
6992: GO 7028
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6994: LD_VAR 0 1
6998: PPUSH
6999: LD_INT 81
7001: PUSH
7002: LD_INT 8
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PPUSH
7014: LD_VAR 0 1
7018: PPUSH
7019: CALL_OW 74
7023: PPUSH
7024: CALL_OW 115
// end else
7028: GO 7057
// if IsDead ( i ) then
7030: LD_VAR 0 1
7034: PPUSH
7035: CALL_OW 301
7039: IFFALSE 7057
// tmp := tmp diff i ;
7041: LD_ADDR_VAR 0 3
7045: PUSH
7046: LD_VAR 0 3
7050: PUSH
7051: LD_VAR 0 1
7055: DIFF
7056: ST_TO_ADDR
// end ;
7057: GO 6922
7059: POP
7060: POP
// until not tmp ;
7061: LD_VAR 0 3
7065: NOT
7066: IFFALSE 6897
// end ; end_of_file
7068: PPOPN 3
7070: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7071: LD_INT 0
7073: PPUSH
7074: PPUSH
7075: PPUSH
7076: PPUSH
7077: PPUSH
7078: PPUSH
7079: PPUSH
7080: PPUSH
7081: PPUSH
// side := 3 ;
7082: LD_ADDR_VAR 0 6
7086: PUSH
7087: LD_INT 3
7089: ST_TO_ADDR
// uc_side := side ;
7090: LD_ADDR_OWVAR 20
7094: PUSH
7095: LD_VAR 0 6
7099: ST_TO_ADDR
// uc_nation := 3 ;
7100: LD_ADDR_OWVAR 21
7104: PUSH
7105: LD_INT 3
7107: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7108: LD_ADDR_VAR 0 2
7112: PUSH
7113: LD_INT 22
7115: PUSH
7116: LD_VAR 0 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 21
7127: PUSH
7128: LD_INT 3
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: PPUSH
7139: CALL_OW 69
7143: PUSH
7144: FOR_IN
7145: IFFALSE 7161
// SetBLevel ( i , 10 ) ;
7147: LD_VAR 0 2
7151: PPUSH
7152: LD_INT 10
7154: PPUSH
7155: CALL_OW 241
7159: GO 7144
7161: POP
7162: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7163: LD_ADDR_VAR 0 9
7167: PUSH
7168: LD_INT 22
7170: PUSH
7171: LD_VAR 0 6
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 30
7182: PUSH
7183: LD_INT 34
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: PPUSH
7194: CALL_OW 69
7198: ST_TO_ADDR
// if teleport then
7199: LD_VAR 0 9
7203: IFFALSE 7224
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7205: LD_VAR 0 9
7209: PUSH
7210: LD_INT 1
7212: ARRAY
7213: PPUSH
7214: LD_INT 123
7216: PPUSH
7217: LD_INT 122
7219: PPUSH
7220: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7224: LD_ADDR_EXP 65
7228: PUSH
7229: LD_STRING Platonov
7231: PPUSH
7232: CALL_OW 25
7236: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7237: LD_ADDR_EXP 66
7241: PUSH
7242: LD_STRING Kovalyuk
7244: PPUSH
7245: CALL_OW 25
7249: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7250: LD_ADDR_EXP 68
7254: PUSH
7255: LD_STRING Yakotich
7257: PPUSH
7258: LD_EXP 1
7262: NOT
7263: PPUSH
7264: LD_STRING 09_
7266: PPUSH
7267: CALL 67195 0 3
7271: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7272: LD_ADDR_EXP 67
7276: PUSH
7277: LD_STRING Bystrov
7279: PPUSH
7280: CALL_OW 25
7284: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7285: LD_ADDR_EXP 69
7289: PUSH
7290: LD_STRING Gleb
7292: PPUSH
7293: CALL_OW 25
7297: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7298: LD_STRING 03_Cornel
7300: PPUSH
7301: CALL_OW 28
7305: IFFALSE 7353
// begin Bierezov := NewCharacter ( Mikhail ) ;
7307: LD_ADDR_EXP 70
7311: PUSH
7312: LD_STRING Mikhail
7314: PPUSH
7315: CALL_OW 25
7319: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7320: LD_EXP 70
7324: PPUSH
7325: LD_INT 197
7327: PPUSH
7328: LD_INT 111
7330: PPUSH
7331: LD_INT 9
7333: PPUSH
7334: LD_INT 0
7336: PPUSH
7337: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7341: LD_EXP 70
7345: PPUSH
7346: LD_INT 3
7348: PPUSH
7349: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7353: LD_EXP 65
7357: PPUSH
7358: LD_INT 126
7360: PPUSH
7361: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7365: LD_EXP 66
7369: PPUSH
7370: LD_INT 134
7372: PPUSH
7373: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7377: LD_EXP 68
7381: PPUSH
7382: LD_INT 197
7384: PPUSH
7385: LD_INT 111
7387: PPUSH
7388: LD_INT 9
7390: PPUSH
7391: LD_INT 0
7393: PPUSH
7394: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7398: LD_EXP 67
7402: PPUSH
7403: LD_INT 197
7405: PPUSH
7406: LD_INT 111
7408: PPUSH
7409: LD_INT 9
7411: PPUSH
7412: LD_INT 0
7414: PPUSH
7415: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7419: LD_EXP 69
7423: PPUSH
7424: LD_INT 197
7426: PPUSH
7427: LD_INT 111
7429: PPUSH
7430: LD_INT 9
7432: PPUSH
7433: LD_INT 0
7435: PPUSH
7436: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7440: LD_ADDR_VAR 0 5
7444: PUSH
7445: LD_INT 126
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: LD_STRING zhukov
7453: PPUSH
7454: LD_INT 9
7456: PUSH
7457: LD_INT 10
7459: PUSH
7460: LD_INT 10
7462: PUSH
7463: LD_INT 10
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: LIST
7471: PUSH
7472: LD_OWVAR 67
7476: ARRAY
7477: PPUSH
7478: LD_INT 90000
7480: PUSH
7481: LD_INT 1000
7483: PUSH
7484: LD_INT 300
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: PPUSH
7492: LD_INT 18
7494: PUSH
7495: LD_INT 8
7497: PUSH
7498: LD_INT 13
7500: PUSH
7501: LD_INT 8
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: LIST
7508: LIST
7509: PPUSH
7510: CALL 75654 0 6
7514: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7515: LD_ADDR_VAR 0 4
7519: PUSH
7520: LD_INT 267
7522: PPUSH
7523: CALL_OW 274
7527: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7528: LD_VAR 0 4
7532: PPUSH
7533: LD_INT 1
7535: PPUSH
7536: LD_INT 5000
7538: PPUSH
7539: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7543: LD_VAR 0 4
7547: PPUSH
7548: LD_INT 2
7550: PPUSH
7551: LD_INT 200
7553: PPUSH
7554: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: LD_INT 200
7568: PPUSH
7569: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7573: LD_ADDR_EXP 99
7577: PUSH
7578: LD_EXP 99
7582: PPUSH
7583: LD_INT 2
7585: PPUSH
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_VAR 0 6
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: PUSH
7603: LD_INT 3
7605: PUSH
7606: LD_INT 21
7608: PUSH
7609: LD_INT 2
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PPUSH
7624: CALL_OW 69
7628: UNION
7629: PUSH
7630: LD_EXP 65
7634: DIFF
7635: PPUSH
7636: CALL_OW 1
7640: ST_TO_ADDR
// behemoths := [ ] ;
7641: LD_ADDR_EXP 73
7645: PUSH
7646: EMPTY
7647: ST_TO_ADDR
// behemothBuilders := [ ] ;
7648: LD_ADDR_EXP 74
7652: PUSH
7653: EMPTY
7654: ST_TO_ADDR
// if Kovalyuk then
7655: LD_EXP 66
7659: IFFALSE 7681
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7661: LD_ADDR_EXP 74
7665: PUSH
7666: LD_EXP 74
7670: PPUSH
7671: LD_EXP 66
7675: PPUSH
7676: CALL 104644 0 2
7680: ST_TO_ADDR
// j := 3 ;
7681: LD_ADDR_VAR 0 3
7685: PUSH
7686: LD_INT 3
7688: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7689: LD_ADDR_VAR 0 2
7693: PUSH
7694: LD_INT 22
7696: PUSH
7697: LD_INT 3
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 25
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL_OW 69
7722: PUSH
7723: LD_EXP 66
7727: DIFF
7728: PUSH
7729: FOR_IN
7730: IFFALSE 7780
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7732: LD_ADDR_EXP 74
7736: PUSH
7737: LD_EXP 74
7741: PPUSH
7742: LD_VAR 0 2
7746: PPUSH
7747: CALL 104644 0 2
7751: ST_TO_ADDR
// j := j - 1 ;
7752: LD_ADDR_VAR 0 3
7756: PUSH
7757: LD_VAR 0 3
7761: PUSH
7762: LD_INT 1
7764: MINUS
7765: ST_TO_ADDR
// if j = 0 then
7766: LD_VAR 0 3
7770: PUSH
7771: LD_INT 0
7773: EQUAL
7774: IFFALSE 7778
// break ;
7776: GO 7780
// end ;
7778: GO 7729
7780: POP
7781: POP
// end ;
7782: LD_VAR 0 1
7786: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7787: LD_INT 0
7789: PPUSH
7790: PPUSH
7791: PPUSH
7792: PPUSH
7793: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7794: LD_ADDR_VAR 0 4
7798: PUSH
7799: LD_INT 209
7801: PUSH
7802: LD_INT 149
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PUSH
7809: LD_INT 219
7811: PUSH
7812: LD_INT 154
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: PUSH
7819: LD_INT 223
7821: PUSH
7822: LD_INT 149
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 232
7831: PUSH
7832: LD_INT 155
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: ST_TO_ADDR
// if not behemothBuilders then
7845: LD_EXP 74
7849: NOT
7850: IFFALSE 7854
// exit ;
7852: GO 7985
// j := 1 ;
7854: LD_ADDR_VAR 0 3
7858: PUSH
7859: LD_INT 1
7861: ST_TO_ADDR
// for i in behemothBuilders do
7862: LD_ADDR_VAR 0 2
7866: PUSH
7867: LD_EXP 74
7871: PUSH
7872: FOR_IN
7873: IFFALSE 7983
// begin if GetClass ( i ) <> class_mechanic then
7875: LD_VAR 0 2
7879: PPUSH
7880: CALL_OW 257
7884: PUSH
7885: LD_INT 3
7887: NONEQUAL
7888: IFFALSE 7902
// SetClass ( i , class_mechanic ) ;
7890: LD_VAR 0 2
7894: PPUSH
7895: LD_INT 3
7897: PPUSH
7898: CALL_OW 336
// if IsInUnit ( i ) then
7902: LD_VAR 0 2
7906: PPUSH
7907: CALL_OW 310
7911: IFFALSE 7922
// ComExitBuilding ( i ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 37
7929: PPUSH
7930: LD_VAR 0 4
7934: PUSH
7935: LD_VAR 0 3
7939: ARRAY
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_VAR 0 4
7949: PUSH
7950: LD_VAR 0 3
7954: ARRAY
7955: PUSH
7956: LD_INT 2
7958: ARRAY
7959: PPUSH
7960: LD_INT 0
7962: PPUSH
7963: CALL_OW 230
// j := j + 1 ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: LD_VAR 0 3
7976: PUSH
7977: LD_INT 1
7979: PLUS
7980: ST_TO_ADDR
// end ;
7981: GO 7872
7983: POP
7984: POP
// end ;
7985: LD_VAR 0 1
7989: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7990: LD_INT 24
7992: PPUSH
7993: LD_INT 30
7995: PUSH
7996: LD_INT 37
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PPUSH
8003: CALL_OW 70
8007: IFFALSE 8020
8009: GO 8011
8011: DISABLE
// behemothUnderConstruct := true ;
8012: LD_ADDR_EXP 26
8016: PUSH
8017: LD_INT 1
8019: ST_TO_ADDR
8020: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8021: LD_INT 3
8023: PPUSH
8024: CALL 104705 0 1
8028: PUSH
8029: LD_INT 22
8031: PUSH
8032: LD_INT 3
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 30
8041: PUSH
8042: LD_INT 37
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: PPUSH
8053: CALL_OW 69
8057: NOT
8058: AND
8059: IFFALSE 8245
8061: GO 8063
8063: DISABLE
8064: LD_INT 0
8066: PPUSH
8067: PPUSH
// begin enable ;
8068: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8069: LD_ADDR_VAR 0 2
8073: PUSH
8074: LD_INT 3
8076: PPUSH
8077: CALL 104705 0 1
8081: ST_TO_ADDR
// for i in tmp do
8082: LD_ADDR_VAR 0 1
8086: PUSH
8087: LD_VAR 0 2
8091: PUSH
8092: FOR_IN
8093: IFFALSE 8243
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8095: LD_VAR 0 1
8099: PPUSH
8100: LD_INT 9
8102: PPUSH
8103: CALL_OW 308
8107: PUSH
8108: LD_VAR 0 1
8112: PPUSH
8113: CALL_OW 110
8117: PUSH
8118: LD_INT 2
8120: EQUAL
8121: NOT
8122: AND
8123: IFFALSE 8137
// SetTag ( i , 2 ) ;
8125: LD_VAR 0 1
8129: PPUSH
8130: LD_INT 2
8132: PPUSH
8133: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8137: LD_INT 81
8139: PUSH
8140: LD_INT 3
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: PUSH
8147: LD_INT 91
8149: PUSH
8150: LD_VAR 0 1
8154: PUSH
8155: LD_INT 12
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: LIST
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: NOT
8172: PUSH
8173: LD_VAR 0 1
8177: PPUSH
8178: CALL_OW 110
8182: PUSH
8183: LD_INT 2
8185: EQUAL
8186: NOT
8187: AND
8188: IFFALSE 8207
// ComAgressiveMove ( i , 64 , 93 ) else
8190: LD_VAR 0 1
8194: PPUSH
8195: LD_INT 64
8197: PPUSH
8198: LD_INT 93
8200: PPUSH
8201: CALL_OW 114
8205: GO 8241
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8207: LD_VAR 0 1
8211: PPUSH
8212: LD_INT 81
8214: PUSH
8215: LD_INT 3
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 69
8226: PPUSH
8227: LD_VAR 0 1
8231: PPUSH
8232: CALL_OW 74
8236: PPUSH
8237: CALL_OW 115
// end ;
8241: GO 8092
8243: POP
8244: POP
// end ;
8245: PPOPN 2
8247: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8248: LD_INT 0
8250: PPUSH
8251: PPUSH
8252: PPUSH
// result := [ ] ;
8253: LD_ADDR_VAR 0 2
8257: PUSH
8258: EMPTY
8259: ST_TO_ADDR
// uc_side := 6 ;
8260: LD_ADDR_OWVAR 20
8264: PUSH
8265: LD_INT 6
8267: ST_TO_ADDR
// uc_nation := 3 ;
8268: LD_ADDR_OWVAR 21
8272: PUSH
8273: LD_INT 3
8275: ST_TO_ADDR
// case strength of 1 :
8276: LD_VAR 0 1
8280: PUSH
8281: LD_INT 1
8283: DOUBLE
8284: EQUAL
8285: IFTRUE 8289
8287: GO 8431
8289: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8290: LD_ADDR_VAR 0 3
8294: PUSH
8295: DOUBLE
8296: LD_INT 1
8298: DEC
8299: ST_TO_ADDR
8300: LD_INT 4
8302: PUSH
8303: LD_INT 5
8305: PUSH
8306: LD_INT 6
8308: PUSH
8309: LD_INT 7
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: LIST
8317: PUSH
8318: LD_OWVAR 67
8322: ARRAY
8323: PUSH
8324: FOR_TO
8325: IFFALSE 8427
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8327: LD_INT 22
8329: PUSH
8330: LD_INT 24
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PUSH
8337: LD_VAR 0 3
8341: PUSH
8342: LD_INT 2
8344: MOD
8345: PUSH
8346: LD_INT 1
8348: PLUS
8349: ARRAY
8350: PPUSH
8351: LD_INT 1
8353: PUSH
8354: LD_INT 3
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PUSH
8361: LD_INT 1
8363: PPUSH
8364: LD_INT 2
8366: PPUSH
8367: CALL_OW 12
8371: ARRAY
8372: PPUSH
8373: LD_INT 3
8375: PPUSH
8376: LD_INT 43
8378: PUSH
8379: LD_INT 44
8381: PUSH
8382: LD_INT 45
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 1
8392: PPUSH
8393: LD_INT 3
8395: PPUSH
8396: CALL_OW 12
8400: ARRAY
8401: PPUSH
8402: LD_INT 80
8404: PPUSH
8405: CALL 72210 0 5
// result := result union CreateVehicle ;
8409: LD_ADDR_VAR 0 2
8413: PUSH
8414: LD_VAR 0 2
8418: PUSH
8419: CALL_OW 45
8423: UNION
8424: ST_TO_ADDR
// end ;
8425: GO 8324
8427: POP
8428: POP
// end ; 2 :
8429: GO 9426
8431: LD_INT 2
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8607
8439: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8440: LD_ADDR_VAR 0 3
8444: PUSH
8445: DOUBLE
8446: LD_INT 1
8448: DEC
8449: ST_TO_ADDR
8450: LD_INT 5
8452: PUSH
8453: LD_INT 6
8455: PUSH
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: EMPTY
8463: LIST
8464: LIST
8465: LIST
8466: LIST
8467: PUSH
8468: LD_OWVAR 67
8472: ARRAY
8473: PUSH
8474: FOR_TO
8475: IFFALSE 8603
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8477: LD_INT 22
8479: PUSH
8480: LD_INT 24
8482: PUSH
8483: LD_INT 24
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: LIST
8490: PUSH
8491: LD_VAR 0 3
8495: PUSH
8496: LD_INT 3
8498: MOD
8499: PUSH
8500: LD_INT 1
8502: PLUS
8503: ARRAY
8504: PPUSH
8505: LD_INT 1
8507: PUSH
8508: LD_INT 3
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: PUSH
8515: LD_INT 1
8517: PPUSH
8518: LD_INT 2
8520: PPUSH
8521: CALL_OW 12
8525: ARRAY
8526: PPUSH
8527: LD_INT 3
8529: PPUSH
8530: LD_INT 43
8532: PUSH
8533: LD_INT 44
8535: PUSH
8536: LD_INT 45
8538: PUSH
8539: LD_INT 44
8541: PUSH
8542: LD_INT 46
8544: PUSH
8545: LD_INT 46
8547: PUSH
8548: LD_INT 49
8550: PUSH
8551: LD_INT 49
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_VAR 0 3
8568: PUSH
8569: LD_INT 8
8571: MOD
8572: PUSH
8573: LD_INT 1
8575: PLUS
8576: ARRAY
8577: PPUSH
8578: LD_INT 80
8580: PPUSH
8581: CALL 72210 0 5
// result := result union CreateVehicle ;
8585: LD_ADDR_VAR 0 2
8589: PUSH
8590: LD_VAR 0 2
8594: PUSH
8595: CALL_OW 45
8599: UNION
8600: ST_TO_ADDR
// end ;
8601: GO 8474
8603: POP
8604: POP
// end ; 3 :
8605: GO 9426
8607: LD_INT 3
8609: DOUBLE
8610: EQUAL
8611: IFTRUE 8615
8613: GO 8787
8615: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8616: LD_ADDR_VAR 0 3
8620: PUSH
8621: DOUBLE
8622: LD_INT 1
8624: DEC
8625: ST_TO_ADDR
8626: LD_INT 6
8628: PUSH
8629: LD_INT 7
8631: PUSH
8632: LD_INT 8
8634: PUSH
8635: LD_INT 9
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: PUSH
8644: LD_OWVAR 67
8648: ARRAY
8649: PUSH
8650: FOR_TO
8651: IFFALSE 8783
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8653: LD_INT 22
8655: PUSH
8656: LD_INT 24
8658: PUSH
8659: LD_INT 24
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: LIST
8666: PUSH
8667: LD_VAR 0 3
8671: PUSH
8672: LD_INT 3
8674: MOD
8675: PUSH
8676: LD_INT 1
8678: PLUS
8679: ARRAY
8680: PPUSH
8681: LD_INT 1
8683: PUSH
8684: LD_INT 3
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PUSH
8691: LD_INT 1
8693: PPUSH
8694: LD_INT 2
8696: PPUSH
8697: CALL_OW 12
8701: ARRAY
8702: PPUSH
8703: LD_INT 3
8705: PPUSH
8706: LD_INT 43
8708: PUSH
8709: LD_INT 47
8711: PUSH
8712: LD_INT 45
8714: PUSH
8715: LD_INT 45
8717: PUSH
8718: LD_INT 46
8720: PUSH
8721: LD_INT 46
8723: PUSH
8724: LD_INT 49
8726: PUSH
8727: LD_INT 49
8729: PUSH
8730: LD_INT 49
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_VAR 0 3
8748: PUSH
8749: LD_INT 9
8751: MOD
8752: PUSH
8753: LD_INT 1
8755: PLUS
8756: ARRAY
8757: PPUSH
8758: LD_INT 80
8760: PPUSH
8761: CALL 72210 0 5
// result := result union CreateVehicle ;
8765: LD_ADDR_VAR 0 2
8769: PUSH
8770: LD_VAR 0 2
8774: PUSH
8775: CALL_OW 45
8779: UNION
8780: ST_TO_ADDR
// end ;
8781: GO 8650
8783: POP
8784: POP
// end ; 4 :
8785: GO 9426
8787: LD_INT 4
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 9425
8795: POP
// begin uc_nation := 3 ;
8796: LD_ADDR_OWVAR 21
8800: PUSH
8801: LD_INT 3
8803: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: DOUBLE
8810: LD_INT 1
8812: DEC
8813: ST_TO_ADDR
8814: LD_INT 6
8816: PUSH
8817: LD_INT 8
8819: PUSH
8820: LD_INT 9
8822: PUSH
8823: LD_INT 10
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_OWVAR 67
8836: ARRAY
8837: PUSH
8838: FOR_TO
8839: IFFALSE 8971
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8841: LD_INT 22
8843: PUSH
8844: LD_INT 24
8846: PUSH
8847: LD_INT 24
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_VAR 0 3
8859: PUSH
8860: LD_INT 3
8862: MOD
8863: PUSH
8864: LD_INT 1
8866: PLUS
8867: ARRAY
8868: PPUSH
8869: LD_INT 1
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 1
8881: PPUSH
8882: LD_INT 2
8884: PPUSH
8885: CALL_OW 12
8889: ARRAY
8890: PPUSH
8891: LD_INT 3
8893: PPUSH
8894: LD_INT 45
8896: PUSH
8897: LD_INT 47
8899: PUSH
8900: LD_INT 47
8902: PUSH
8903: LD_INT 45
8905: PUSH
8906: LD_INT 46
8908: PUSH
8909: LD_INT 46
8911: PUSH
8912: LD_INT 49
8914: PUSH
8915: LD_INT 49
8917: PUSH
8918: LD_INT 49
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: LD_INT 9
8939: MOD
8940: PUSH
8941: LD_INT 1
8943: PLUS
8944: ARRAY
8945: PPUSH
8946: LD_INT 80
8948: PPUSH
8949: CALL 72210 0 5
// result := result union CreateVehicle ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: CALL_OW 45
8967: UNION
8968: ST_TO_ADDR
// end ;
8969: GO 8838
8971: POP
8972: POP
// if not KappaStatus then
8973: LD_EXP 2
8977: NOT
8978: IFFALSE 9213
// begin uc_nation := 1 ;
8980: LD_ADDR_OWVAR 21
8984: PUSH
8985: LD_INT 1
8987: ST_TO_ADDR
// for i = 1 to 3 do
8988: LD_ADDR_VAR 0 3
8992: PUSH
8993: DOUBLE
8994: LD_INT 1
8996: DEC
8997: ST_TO_ADDR
8998: LD_INT 3
9000: PUSH
9001: FOR_TO
9002: IFFALSE 9138
// begin j := rand ( 0 , 1 ) ;
9004: LD_ADDR_VAR 0 4
9008: PUSH
9009: LD_INT 0
9011: PPUSH
9012: LD_INT 1
9014: PPUSH
9015: CALL_OW 12
9019: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9020: LD_INT 3
9022: PUSH
9023: LD_INT 5
9025: PUSH
9026: LD_INT 5
9028: PUSH
9029: LD_INT 4
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: LIST
9036: LIST
9037: PUSH
9038: LD_VAR 0 4
9042: PUSH
9043: LD_INT 1
9045: PPUSH
9046: LD_INT 3
9048: PPUSH
9049: CALL_OW 12
9053: PLUS
9054: ARRAY
9055: PPUSH
9056: LD_INT 1
9058: PUSH
9059: LD_INT 3
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 1
9068: PPUSH
9069: LD_INT 2
9071: PPUSH
9072: CALL_OW 12
9076: ARRAY
9077: PPUSH
9078: LD_INT 3
9080: PPUSH
9081: LD_INT 9
9083: PUSH
9084: LD_INT 7
9086: PUSH
9087: LD_INT 6
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_VAR 0 4
9099: PUSH
9100: LD_INT 1
9102: PPUSH
9103: LD_INT 2
9105: PPUSH
9106: CALL_OW 12
9110: PLUS
9111: ARRAY
9112: PPUSH
9113: LD_INT 85
9115: PPUSH
9116: CALL 72210 0 5
// result := result union CreateVehicle ;
9120: LD_ADDR_VAR 0 2
9124: PUSH
9125: LD_VAR 0 2
9129: PUSH
9130: CALL_OW 45
9134: UNION
9135: ST_TO_ADDR
// end ;
9136: GO 9001
9138: POP
9139: POP
// if vsevolodFirstAttack then
9140: LD_EXP 24
9144: IFFALSE 9211
// begin vsevolodFirstAttack := false ;
9146: LD_ADDR_EXP 24
9150: PUSH
9151: LD_INT 0
9153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9154: LD_INT 5
9156: PPUSH
9157: LD_INT 3
9159: PPUSH
9160: LD_INT 1
9162: PPUSH
9163: LD_INT 6
9165: PPUSH
9166: LD_INT 100
9168: PPUSH
9169: CALL 72210 0 5
// sewiVeh := CreateVehicle ;
9173: LD_ADDR_EXP 72
9177: PUSH
9178: CALL_OW 45
9182: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9183: LD_EXP 72
9187: PPUSH
9188: LD_INT 1
9190: PPUSH
9191: CALL_OW 242
// result := result union sewiVeh ;
9195: LD_ADDR_VAR 0 2
9199: PUSH
9200: LD_VAR 0 2
9204: PUSH
9205: LD_EXP 72
9209: UNION
9210: ST_TO_ADDR
// end ; end else
9211: GO 9423
// if vsevolodFirstAttack then
9213: LD_EXP 24
9217: IFFALSE 9423
// begin vsevolodFirstAttack := false ;
9219: LD_ADDR_EXP 24
9223: PUSH
9224: LD_INT 0
9226: ST_TO_ADDR
// uc_nation := 3 ;
9227: LD_ADDR_OWVAR 21
9231: PUSH
9232: LD_INT 3
9234: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9235: LD_ADDR_VAR 0 3
9239: PUSH
9240: DOUBLE
9241: LD_INT 1
9243: DEC
9244: ST_TO_ADDR
9245: LD_INT 2
9247: PUSH
9248: LD_OWVAR 67
9252: PLUS
9253: PUSH
9254: FOR_TO
9255: IFFALSE 9363
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9257: LD_INT 22
9259: PUSH
9260: LD_INT 24
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: EMPTY
9267: LIST
9268: LIST
9269: LIST
9270: PUSH
9271: LD_VAR 0 3
9275: PUSH
9276: LD_INT 3
9278: MOD
9279: PUSH
9280: LD_INT 1
9282: PLUS
9283: ARRAY
9284: PPUSH
9285: LD_INT 1
9287: PUSH
9288: LD_INT 3
9290: PUSH
9291: EMPTY
9292: LIST
9293: LIST
9294: PUSH
9295: LD_INT 1
9297: PPUSH
9298: LD_INT 2
9300: PPUSH
9301: CALL_OW 12
9305: ARRAY
9306: PPUSH
9307: LD_INT 1
9309: PPUSH
9310: LD_INT 45
9312: PUSH
9313: LD_INT 47
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: LD_VAR 0 3
9328: PUSH
9329: LD_INT 3
9331: MOD
9332: PUSH
9333: LD_INT 1
9335: PLUS
9336: ARRAY
9337: PPUSH
9338: LD_INT 80
9340: PPUSH
9341: CALL 72210 0 5
// result := result union CreateVehicle ;
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: LD_VAR 0 2
9354: PUSH
9355: CALL_OW 45
9359: UNION
9360: ST_TO_ADDR
// end ;
9361: GO 9254
9363: POP
9364: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9365: LD_INT 24
9367: PPUSH
9368: LD_INT 3
9370: PPUSH
9371: LD_INT 1
9373: PPUSH
9374: LD_INT 47
9376: PPUSH
9377: LD_INT 100
9379: PPUSH
9380: CALL 72210 0 5
// sewiVeh := CreateVehicle ;
9384: LD_ADDR_EXP 72
9388: PUSH
9389: CALL_OW 45
9393: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9394: LD_EXP 72
9398: PPUSH
9399: LD_INT 6
9401: NEG
9402: PPUSH
9403: CALL_OW 242
// result := result union sewiVeh ;
9407: LD_ADDR_VAR 0 2
9411: PUSH
9412: LD_VAR 0 2
9416: PUSH
9417: LD_EXP 72
9421: UNION
9422: ST_TO_ADDR
// end ; end ; end ;
9423: GO 9426
9425: POP
// end ;
9426: LD_VAR 0 2
9430: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9431: LD_EXP 16
9435: IFFALSE 10106
9437: GO 9439
9439: DISABLE
9440: LD_INT 0
9442: PPUSH
9443: PPUSH
9444: PPUSH
9445: PPUSH
9446: PPUSH
9447: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9448: LD_ADDR_VAR 0 4
9452: PUSH
9453: LD_INT 11
9455: PUSH
9456: LD_INT 12
9458: PUSH
9459: EMPTY
9460: LIST
9461: LIST
9462: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9463: LD_ADDR_VAR 0 3
9467: PUSH
9468: LD_INT 11550
9470: PUSH
9471: LD_INT 10150
9473: PUSH
9474: LD_INT 9800
9476: PUSH
9477: LD_INT 9450
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_OWVAR 67
9490: ARRAY
9491: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9492: LD_ADDR_VAR 0 6
9496: PUSH
9497: LD_INT 70
9499: PUSH
9500: LD_INT 118
9502: PUSH
9503: EMPTY
9504: LIST
9505: LIST
9506: PUSH
9507: LD_INT 78
9509: PUSH
9510: LD_INT 31
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: EMPTY
9518: LIST
9519: LIST
9520: ST_TO_ADDR
// repeat if missionStage = 2 then
9521: LD_EXP 15
9525: PUSH
9526: LD_INT 2
9528: EQUAL
9529: IFFALSE 9540
// wait ( 1 1$30 ) else
9531: LD_INT 3150
9533: PPUSH
9534: CALL_OW 67
9538: GO 9549
// wait ( time ) ;
9540: LD_VAR 0 3
9544: PPUSH
9545: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9549: LD_EXP 15
9553: PUSH
9554: LD_INT 6
9556: EQUAL
9557: PUSH
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 2
9565: GREATER
9566: OR
9567: IFFALSE 9595
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9569: LD_INT 51
9571: PPUSH
9572: LD_INT 6
9574: PPUSH
9575: LD_INT 2
9577: PPUSH
9578: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9582: LD_INT 57
9584: PPUSH
9585: LD_INT 6
9587: PPUSH
9588: LD_INT 2
9590: PPUSH
9591: CALL_OW 322
// end ; if missionStage = 8 then
9595: LD_EXP 15
9599: PUSH
9600: LD_INT 8
9602: EQUAL
9603: IFFALSE 9631
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9605: LD_INT 52
9607: PPUSH
9608: LD_INT 6
9610: PPUSH
9611: LD_INT 2
9613: PPUSH
9614: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9618: LD_INT 58
9620: PPUSH
9621: LD_INT 6
9623: PPUSH
9624: LD_INT 2
9626: PPUSH
9627: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9631: LD_EXP 15
9635: PUSH
9636: LD_INT 10
9638: EQUAL
9639: PUSH
9640: LD_OWVAR 67
9644: PUSH
9645: LD_INT 1
9647: GREATER
9648: AND
9649: IFFALSE 9677
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9651: LD_INT 53
9653: PPUSH
9654: LD_INT 6
9656: PPUSH
9657: LD_INT 2
9659: PPUSH
9660: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9664: LD_INT 59
9666: PPUSH
9667: LD_INT 6
9669: PPUSH
9670: LD_INT 2
9672: PPUSH
9673: CALL_OW 322
// end ; if activeAttacks then
9677: LD_EXP 16
9681: IFFALSE 10100
// begin if missionStage = 2 then
9683: LD_EXP 15
9687: PUSH
9688: LD_INT 2
9690: EQUAL
9691: IFFALSE 9701
// strength := 1 ;
9693: LD_ADDR_VAR 0 5
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// if missionStage > 2 then
9701: LD_EXP 15
9705: PUSH
9706: LD_INT 2
9708: GREATER
9709: IFFALSE 9719
// strength := 2 ;
9711: LD_ADDR_VAR 0 5
9715: PUSH
9716: LD_INT 2
9718: ST_TO_ADDR
// if missionStage > 6 then
9719: LD_EXP 15
9723: PUSH
9724: LD_INT 6
9726: GREATER
9727: IFFALSE 9737
// strength := 3 ;
9729: LD_ADDR_VAR 0 5
9733: PUSH
9734: LD_INT 3
9736: ST_TO_ADDR
// if missionStage > 10 then
9737: LD_EXP 15
9741: PUSH
9742: LD_INT 10
9744: GREATER
9745: IFFALSE 9755
// strength := 4 ;
9747: LD_ADDR_VAR 0 5
9751: PUSH
9752: LD_INT 4
9754: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9755: LD_ADDR_VAR 0 2
9759: PUSH
9760: LD_VAR 0 5
9764: PPUSH
9765: CALL 8248 0 1
9769: ST_TO_ADDR
// for i in tmp do
9770: LD_ADDR_VAR 0 1
9774: PUSH
9775: LD_VAR 0 2
9779: PUSH
9780: FOR_IN
9781: IFFALSE 9990
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_VAR 0 4
9792: PUSH
9793: LD_INT 1
9795: PPUSH
9796: LD_INT 2
9798: PPUSH
9799: CALL_OW 12
9803: ARRAY
9804: PPUSH
9805: LD_INT 0
9807: PPUSH
9808: CALL_OW 49
// if i = sewiVeh then
9812: LD_VAR 0 1
9816: PUSH
9817: LD_EXP 72
9821: EQUAL
9822: IFFALSE 9859
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9824: LD_ADDR_EXP 71
9828: PUSH
9829: LD_STRING Vsevolod
9831: PPUSH
9832: LD_INT 0
9834: PPUSH
9835: LD_STRING 
9837: PPUSH
9838: CALL 67195 0 3
9842: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9843: LD_EXP 71
9847: PPUSH
9848: LD_VAR 0 1
9852: PPUSH
9853: CALL_OW 52
// end else
9857: GO 9940
// if GetControl ( i ) = control_manual then
9859: LD_VAR 0 1
9863: PPUSH
9864: CALL_OW 263
9868: PUSH
9869: LD_INT 1
9871: EQUAL
9872: IFFALSE 9940
// begin uc_side := 6 ;
9874: LD_ADDR_OWVAR 20
9878: PUSH
9879: LD_INT 6
9881: ST_TO_ADDR
// uc_nation := 3 ;
9882: LD_ADDR_OWVAR 21
9886: PUSH
9887: LD_INT 3
9889: ST_TO_ADDR
// hc_gallery :=  ;
9890: LD_ADDR_OWVAR 33
9894: PUSH
9895: LD_STRING 
9897: ST_TO_ADDR
// hc_name :=  ;
9898: LD_ADDR_OWVAR 26
9902: PUSH
9903: LD_STRING 
9905: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9906: LD_INT 0
9908: PPUSH
9909: LD_INT 3
9911: PPUSH
9912: LD_INT 10
9914: PPUSH
9915: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9919: CALL_OW 44
9923: PPUSH
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9933: LD_INT 10
9935: PPUSH
9936: CALL_OW 67
// end ; if Prob ( 50 ) then
9940: LD_INT 50
9942: PPUSH
9943: CALL_OW 13
9947: IFFALSE 9966
// ComMoveXY ( i , 111 , 197 ) else
9949: LD_VAR 0 1
9953: PPUSH
9954: LD_INT 111
9956: PPUSH
9957: LD_INT 197
9959: PPUSH
9960: CALL_OW 111
9964: GO 9981
// ComMoveXY ( i , 91 , 165 ) ;
9966: LD_VAR 0 1
9970: PPUSH
9971: LD_INT 91
9973: PPUSH
9974: LD_INT 165
9976: PPUSH
9977: CALL_OW 111
// wait ( 0 0$2 ) ;
9981: LD_INT 70
9983: PPUSH
9984: CALL_OW 67
// end ;
9988: GO 9780
9990: POP
9991: POP
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
9999: LD_ADDR_VAR 0 1
10003: PUSH
10004: LD_VAR 0 2
10008: PPUSH
10009: LD_INT 50
10011: PUSH
10012: EMPTY
10013: LIST
10014: PPUSH
10015: CALL_OW 72
10019: PUSH
10020: FOR_IN
10021: IFFALSE 10080
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10023: LD_VAR 0 1
10027: PPUSH
10028: LD_INT 108
10030: PUSH
10031: LD_INT 153
10033: PUSH
10034: EMPTY
10035: LIST
10036: LIST
10037: PUSH
10038: LD_INT 105
10040: PUSH
10041: LD_INT 149
10043: PUSH
10044: EMPTY
10045: LIST
10046: LIST
10047: PUSH
10048: LD_INT 85
10050: PUSH
10051: LD_INT 131
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: PUSH
10058: LD_INT 64
10060: PUSH
10061: LD_INT 105
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: PPUSH
10074: CALL 107248 0 2
10078: GO 10020
10080: POP
10081: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
10082: LD_VAR 0 2
10086: PPUSH
10087: LD_INT 50
10089: PUSH
10090: EMPTY
10091: LIST
10092: PPUSH
10093: CALL_OW 72
10097: NOT
10098: IFFALSE 9992
// end ; until russianDestroyed ;
10100: LD_EXP 21
10104: IFFALSE 9521
// end ;
10106: PPOPN 6
10108: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10109: LD_EXP 21
10113: NOT
10114: PUSH
10115: LD_EXP 15
10119: PUSH
10120: LD_INT 6
10122: GREATEREQUAL
10123: AND
10124: PUSH
10125: LD_INT 2
10127: PPUSH
10128: LD_INT 1
10130: PPUSH
10131: CALL 62225 0 2
10135: NOT
10136: AND
10137: IFFALSE 11076
10139: GO 10141
10141: DISABLE
10142: LD_INT 0
10144: PPUSH
10145: PPUSH
10146: PPUSH
10147: PPUSH
// begin enable ;
10148: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10149: LD_INT 22
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: EMPTY
10156: LIST
10157: LIST
10158: PUSH
10159: LD_INT 30
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: EMPTY
10166: LIST
10167: LIST
10168: PUSH
10169: EMPTY
10170: LIST
10171: LIST
10172: PPUSH
10173: CALL_OW 69
10177: NOT
10178: IFFALSE 10182
// exit ;
10180: GO 11076
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10182: LD_ADDR_VAR 0 4
10186: PUSH
10187: LD_INT 22
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: PUSH
10197: LD_INT 30
10199: PUSH
10200: LD_INT 34
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: ST_TO_ADDR
// if Prob ( 40 ) then
10216: LD_INT 40
10218: PPUSH
10219: CALL_OW 13
10223: IFFALSE 10369
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10225: LD_INT 2
10227: PPUSH
10228: LD_INT 22
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 49
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 22
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 49
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: LD_INT 22
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 3
10272: PUSH
10273: LD_INT 49
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 24
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 3
10290: PUSH
10291: LD_INT 46
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 24
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 3
10308: PUSH
10309: LD_INT 46
10311: PUSH
10312: EMPTY
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: PUSH
10318: LD_INT 24
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 46
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: LD_INT 24
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 3
10344: PUSH
10345: LD_INT 46
10347: PUSH
10348: EMPTY
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PPUSH
10363: CALL 60807 0 2
// end else
10367: GO 10511
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10369: LD_INT 2
10371: PPUSH
10372: LD_INT 24
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 3
10380: PUSH
10381: LD_INT 47
10383: PUSH
10384: EMPTY
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 24
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 3
10398: PUSH
10399: LD_INT 47
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: LIST
10406: LIST
10407: PUSH
10408: LD_INT 24
10410: PUSH
10411: LD_INT 3
10413: PUSH
10414: LD_INT 3
10416: PUSH
10417: LD_INT 47
10419: PUSH
10420: EMPTY
10421: LIST
10422: LIST
10423: LIST
10424: LIST
10425: PUSH
10426: LD_INT 24
10428: PUSH
10429: LD_INT 3
10431: PUSH
10432: LD_INT 3
10434: PUSH
10435: LD_INT 46
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: PUSH
10444: LD_INT 24
10446: PUSH
10447: LD_INT 3
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 46
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 24
10464: PUSH
10465: LD_INT 3
10467: PUSH
10468: LD_INT 3
10470: PUSH
10471: LD_INT 46
10473: PUSH
10474: EMPTY
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: PUSH
10480: LD_INT 24
10482: PUSH
10483: LD_INT 3
10485: PUSH
10486: LD_INT 3
10488: PUSH
10489: LD_INT 46
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: LIST
10496: LIST
10497: PUSH
10498: EMPTY
10499: LIST
10500: LIST
10501: LIST
10502: LIST
10503: LIST
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL 60807 0 2
// end ; repeat wait ( 0 0$1 ) ;
10511: LD_INT 35
10513: PPUSH
10514: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10518: LD_INT 2
10520: PPUSH
10521: LD_INT 1
10523: PPUSH
10524: CALL 62225 0 2
10528: PUSH
10529: LD_INT 7
10531: GREATEREQUAL
10532: IFFALSE 10511
// wait ( 0 0$10 ) ;
10534: LD_INT 350
10536: PPUSH
10537: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_INT 2
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 62225 0 2
10556: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10557: LD_ADDR_EXP 118
10561: PUSH
10562: LD_EXP 118
10566: PPUSH
10567: LD_INT 2
10569: PPUSH
10570: LD_EXP 118
10574: PUSH
10575: LD_INT 2
10577: ARRAY
10578: PUSH
10579: LD_VAR 0 2
10583: DIFF
10584: PPUSH
10585: CALL_OW 1
10589: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10590: LD_ADDR_VAR 0 3
10594: PUSH
10595: LD_INT 0
10597: PPUSH
10598: LD_INT 1
10600: PPUSH
10601: CALL_OW 12
10605: ST_TO_ADDR
// if target then
10606: LD_VAR 0 3
10610: IFFALSE 10738
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10612: LD_ADDR_VAR 0 2
10616: PUSH
10617: LD_VAR 0 2
10621: PPUSH
10622: LD_INT 24
10624: PUSH
10625: LD_INT 250
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 72
10636: ST_TO_ADDR
// for i in tmp do
10637: LD_ADDR_VAR 0 1
10641: PUSH
10642: LD_VAR 0 2
10646: PUSH
10647: FOR_IN
10648: IFFALSE 10688
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10650: LD_VAR 0 1
10654: PPUSH
10655: LD_INT 139
10657: PPUSH
10658: LD_INT 89
10660: PPUSH
10661: CALL_OW 297
10665: PUSH
10666: LD_INT 9
10668: GREATER
10669: IFFALSE 10686
// ComMoveXY ( i , 139 , 89 ) ;
10671: LD_VAR 0 1
10675: PPUSH
10676: LD_INT 139
10678: PPUSH
10679: LD_INT 89
10681: PPUSH
10682: CALL_OW 111
10686: GO 10647
10688: POP
10689: POP
// wait ( 0 0$1 ) ;
10690: LD_INT 35
10692: PPUSH
10693: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10697: LD_VAR 0 2
10701: PPUSH
10702: LD_INT 92
10704: PUSH
10705: LD_INT 139
10707: PUSH
10708: LD_INT 89
10710: PUSH
10711: LD_INT 9
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PPUSH
10720: CALL_OW 72
10724: PUSH
10725: LD_VAR 0 2
10729: PUSH
10730: LD_INT 1
10732: MINUS
10733: GREATEREQUAL
10734: IFFALSE 10612
// end else
10736: GO 10880
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10738: LD_VAR 0 2
10742: PPUSH
10743: LD_VAR 0 4
10747: PUSH
10748: LD_INT 1
10750: ARRAY
10751: PPUSH
10752: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10756: LD_ADDR_VAR 0 2
10760: PUSH
10761: LD_VAR 0 2
10765: PPUSH
10766: LD_INT 24
10768: PUSH
10769: LD_INT 250
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PPUSH
10776: CALL_OW 72
10780: ST_TO_ADDR
// for i in tmp do
10781: LD_ADDR_VAR 0 1
10785: PUSH
10786: LD_VAR 0 2
10790: PUSH
10791: FOR_IN
10792: IFFALSE 10832
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10794: LD_VAR 0 1
10798: PPUSH
10799: LD_INT 124
10801: PPUSH
10802: LD_INT 139
10804: PPUSH
10805: CALL_OW 297
10809: PUSH
10810: LD_INT 9
10812: GREATER
10813: IFFALSE 10830
// ComMoveXY ( i , 124 , 139 ) ;
10815: LD_VAR 0 1
10819: PPUSH
10820: LD_INT 124
10822: PPUSH
10823: LD_INT 139
10825: PPUSH
10826: CALL_OW 111
10830: GO 10791
10832: POP
10833: POP
// wait ( 0 0$1 ) ;
10834: LD_INT 35
10836: PPUSH
10837: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10841: LD_VAR 0 2
10845: PPUSH
10846: LD_INT 92
10848: PUSH
10849: LD_INT 124
10851: PUSH
10852: LD_INT 139
10854: PUSH
10855: LD_INT 9
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PPUSH
10864: CALL_OW 72
10868: PUSH
10869: LD_VAR 0 2
10873: PUSH
10874: LD_INT 1
10876: MINUS
10877: GREATEREQUAL
10878: IFFALSE 10756
// end ; repeat wait ( 0 0$1 ) ;
10880: LD_INT 35
10882: PPUSH
10883: CALL_OW 67
// for i in tmp do
10887: LD_ADDR_VAR 0 1
10891: PUSH
10892: LD_VAR 0 2
10896: PUSH
10897: FOR_IN
10898: IFFALSE 11067
// begin if GetLives ( i ) > 251 then
10900: LD_VAR 0 1
10904: PPUSH
10905: CALL_OW 256
10909: PUSH
10910: LD_INT 251
10912: GREATER
10913: IFFALSE 11038
// begin if GetWeapon ( i ) = ru_time_lapser then
10915: LD_VAR 0 1
10919: PPUSH
10920: CALL_OW 264
10924: PUSH
10925: LD_INT 49
10927: EQUAL
10928: IFFALSE 10984
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_INT 2
10937: PUSH
10938: LD_INT 22
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 22
10950: PUSH
10951: LD_INT 8
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: PPUSH
10968: LD_VAR 0 1
10972: PPUSH
10973: CALL_OW 74
10977: PPUSH
10978: CALL_OW 112
10982: GO 11036
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10984: LD_VAR 0 1
10988: PPUSH
10989: LD_INT 2
10991: PUSH
10992: LD_INT 22
10994: PUSH
10995: LD_INT 1
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PUSH
11002: LD_INT 22
11004: PUSH
11005: LD_INT 8
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PUSH
11012: EMPTY
11013: LIST
11014: LIST
11015: LIST
11016: PPUSH
11017: CALL_OW 69
11021: PPUSH
11022: LD_VAR 0 1
11026: PPUSH
11027: CALL_OW 74
11031: PPUSH
11032: CALL_OW 115
// end else
11036: GO 11065
// if IsDead ( i ) then
11038: LD_VAR 0 1
11042: PPUSH
11043: CALL_OW 301
11047: IFFALSE 11065
// tmp := tmp diff i ;
11049: LD_ADDR_VAR 0 2
11053: PUSH
11054: LD_VAR 0 2
11058: PUSH
11059: LD_VAR 0 1
11063: DIFF
11064: ST_TO_ADDR
// end ;
11065: GO 10897
11067: POP
11068: POP
// until not tmp ;
11069: LD_VAR 0 2
11073: NOT
11074: IFFALSE 10880
// end ;
11076: PPOPN 4
11078: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 8 and Difficulty > 1 do var i , veh , un ;
11079: LD_EXP 15
11083: PUSH
11084: LD_INT 8
11086: GREATEREQUAL
11087: PUSH
11088: LD_OWVAR 67
11092: PUSH
11093: LD_INT 1
11095: GREATER
11096: AND
11097: IFFALSE 11281
11099: GO 11101
11101: DISABLE
11102: LD_INT 0
11104: PPUSH
11105: PPUSH
11106: PPUSH
// begin ruMobile := [ ] ;
11107: LD_ADDR_EXP 75
11111: PUSH
11112: EMPTY
11113: ST_TO_ADDR
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty - 1 ] do
11114: LD_ADDR_VAR 0 1
11118: PUSH
11119: DOUBLE
11120: LD_INT 1
11122: DEC
11123: ST_TO_ADDR
11124: LD_INT 3
11126: PUSH
11127: LD_INT 4
11129: PUSH
11130: LD_INT 5
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: LIST
11137: PUSH
11138: LD_OWVAR 67
11142: PUSH
11143: LD_INT 1
11145: MINUS
11146: ARRAY
11147: PUSH
11148: FOR_TO
11149: IFFALSE 11279
// begin uc_side := 3 ;
11151: LD_ADDR_OWVAR 20
11155: PUSH
11156: LD_INT 3
11158: ST_TO_ADDR
// uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
11167: LD_INT 21
11169: PPUSH
11170: LD_INT 3
11172: PPUSH
11173: LD_INT 1
11175: PPUSH
11176: LD_INT 45
11178: PPUSH
11179: LD_INT 100
11181: PPUSH
11182: CALL 72210 0 5
// veh := CreateVehicle ;
11186: LD_ADDR_VAR 0 2
11190: PUSH
11191: CALL_OW 45
11195: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11196: LD_VAR 0 2
11200: PPUSH
11201: LD_INT 3
11203: PPUSH
11204: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11208: LD_VAR 0 2
11212: PPUSH
11213: LD_INT 29
11215: PPUSH
11216: LD_INT 0
11218: PPUSH
11219: CALL_OW 49
// PrepareMechanic ( false , 10 ) ;
11223: LD_INT 0
11225: PPUSH
11226: LD_INT 10
11228: PPUSH
11229: CALL_OW 383
// un := CreateHuman ;
11233: LD_ADDR_VAR 0 3
11237: PUSH
11238: CALL_OW 44
11242: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
11243: LD_VAR 0 3
11247: PPUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11257: LD_ADDR_EXP 75
11261: PUSH
11262: LD_EXP 75
11266: PPUSH
11267: LD_VAR 0 2
11271: PPUSH
11272: CALL 104644 0 2
11276: ST_TO_ADDR
// end ;
11277: GO 11148
11279: POP
11280: POP
// end ;
11281: PPOPN 3
11283: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11284: LD_EXP 75
11288: IFFALSE 11796
11290: GO 11292
11292: DISABLE
11293: LD_INT 0
11295: PPUSH
11296: PPUSH
11297: PPUSH
// begin enable ;
11298: ENABLE
// if not ruMobile then
11299: LD_EXP 75
11303: NOT
11304: IFFALSE 11308
// exit ;
11306: GO 11796
// for i in ruMobile do
11308: LD_ADDR_VAR 0 1
11312: PUSH
11313: LD_EXP 75
11317: PUSH
11318: FOR_IN
11319: IFFALSE 11794
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11321: LD_VAR 0 1
11325: PPUSH
11326: CALL_OW 302
11330: NOT
11331: PUSH
11332: LD_VAR 0 1
11336: PPUSH
11337: CALL_OW 255
11341: PUSH
11342: LD_INT 3
11344: NONEQUAL
11345: OR
11346: IFFALSE 11366
// begin ruMobile := ruMobile diff i ;
11348: LD_ADDR_EXP 75
11352: PUSH
11353: LD_EXP 75
11357: PUSH
11358: LD_VAR 0 1
11362: DIFF
11363: ST_TO_ADDR
// continue ;
11364: GO 11318
// end ; if GetTag ( i ) = 300 then
11366: LD_VAR 0 1
11370: PPUSH
11371: CALL_OW 110
11375: PUSH
11376: LD_INT 300
11378: EQUAL
11379: IFFALSE 11429
// begin ComMoveXY ( i , 160 , 81 ) ;
11381: LD_VAR 0 1
11385: PPUSH
11386: LD_INT 160
11388: PPUSH
11389: LD_INT 81
11391: PPUSH
11392: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11396: LD_VAR 0 1
11400: PPUSH
11401: LD_INT 160
11403: PPUSH
11404: LD_INT 81
11406: PPUSH
11407: CALL_OW 297
11411: PUSH
11412: LD_INT 8
11414: LESS
11415: IFFALSE 11429
// SetTag ( i , 301 ) ;
11417: LD_VAR 0 1
11421: PPUSH
11422: LD_INT 301
11424: PPUSH
11425: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11429: LD_VAR 0 1
11433: PPUSH
11434: CALL_OW 110
11438: PUSH
11439: LD_INT 301
11441: EQUAL
11442: IFFALSE 11485
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11444: LD_VAR 0 1
11448: PPUSH
11449: LD_INT 33
11451: PPUSH
11452: CALL_OW 308
11456: NOT
11457: IFFALSE 11473
// ComMoveToArea ( i , ruMobileParkingArea ) else
11459: LD_VAR 0 1
11463: PPUSH
11464: LD_INT 33
11466: PPUSH
11467: CALL_OW 113
11471: GO 11485
// SetTag ( i , 302 ) ;
11473: LD_VAR 0 1
11477: PPUSH
11478: LD_INT 302
11480: PPUSH
11481: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11485: LD_VAR 0 1
11489: PPUSH
11490: CALL_OW 110
11494: PUSH
11495: LD_INT 302
11497: EQUAL
11498: IFFALSE 11628
// begin if GetLives ( i ) < 1000 then
11500: LD_VAR 0 1
11504: PPUSH
11505: CALL_OW 256
11509: PUSH
11510: LD_INT 1000
11512: LESS
11513: IFFALSE 11605
// begin if not IsDrivenBy ( i ) then
11515: LD_VAR 0 1
11519: PPUSH
11520: CALL_OW 311
11524: NOT
11525: IFFALSE 11529
// continue ;
11527: GO 11318
// mech := IsDrivenBy ( i ) ;
11529: LD_ADDR_VAR 0 2
11533: PUSH
11534: LD_VAR 0 1
11538: PPUSH
11539: CALL_OW 311
11543: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
11544: LD_VAR 0 2
11548: PPUSH
11549: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
11553: LD_VAR 0 2
11557: PPUSH
11558: LD_VAR 0 1
11562: PPUSH
11563: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
11567: LD_INT 35
11569: PPUSH
11570: CALL_OW 67
// until GetLives ( i ) = 1000 ;
11574: LD_VAR 0 1
11578: PPUSH
11579: CALL_OW 256
11583: PUSH
11584: LD_INT 1000
11586: EQUAL
11587: IFFALSE 11567
// ComEnterUnit ( mech , i ) ;
11589: LD_VAR 0 2
11593: PPUSH
11594: LD_VAR 0 1
11598: PPUSH
11599: CALL_OW 120
// end else
11603: GO 11628
// if IsDrivenBy ( i ) then
11605: LD_VAR 0 1
11609: PPUSH
11610: CALL_OW 311
11614: IFFALSE 11628
// SetTag ( i , 0 ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 0
11623: PPUSH
11624: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
11628: LD_VAR 0 1
11632: PPUSH
11633: CALL_OW 110
11637: PUSH
11638: LD_INT 300
11640: LESS
11641: IFFALSE 11792
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_INT 4
11650: PPUSH
11651: LD_INT 81
11653: PUSH
11654: LD_INT 3
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PPUSH
11661: CALL_OW 70
11665: ST_TO_ADDR
// if GetLives ( i ) < 650 then
11666: LD_VAR 0 1
11670: PPUSH
11671: CALL_OW 256
11675: PUSH
11676: LD_INT 650
11678: LESS
11679: IFFALSE 11704
// begin ComStop ( i ) ;
11681: LD_VAR 0 1
11685: PPUSH
11686: CALL_OW 141
// SetTag ( i , 300 ) ;
11690: LD_VAR 0 1
11694: PPUSH
11695: LD_INT 300
11697: PPUSH
11698: CALL_OW 109
// continue ;
11702: GO 11318
// end ; if enemy then
11704: LD_VAR 0 3
11708: IFFALSE 11748
// begin if not HasTask ( i ) then
11710: LD_VAR 0 1
11714: PPUSH
11715: CALL_OW 314
11719: NOT
11720: IFFALSE 11746
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
11722: LD_VAR 0 1
11726: PPUSH
11727: LD_VAR 0 3
11731: PPUSH
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 74
11741: PPUSH
11742: CALL_OW 115
// end else
11746: GO 11792
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
11748: LD_VAR 0 1
11752: PPUSH
11753: LD_INT 158
11755: PUSH
11756: LD_INT 61
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 98
11765: PUSH
11766: LD_INT 100
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 78
11775: PUSH
11776: LD_INT 93
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: PPUSH
11788: CALL 107248 0 2
// end ; end ;
11792: GO 11318
11794: POP
11795: POP
// end ; end_of_file
11796: PPOPN 3
11798: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11799: LD_INT 0
11801: PPUSH
11802: PPUSH
11803: PPUSH
11804: PPUSH
11805: PPUSH
11806: PPUSH
// side := 7 ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_INT 7
11814: ST_TO_ADDR
// uc_side := side ;
11815: LD_ADDR_OWVAR 20
11819: PUSH
11820: LD_VAR 0 5
11824: ST_TO_ADDR
// uc_nation := 1 ;
11825: LD_ADDR_OWVAR 21
11829: PUSH
11830: LD_INT 1
11832: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11833: LD_ADDR_VAR 0 2
11837: PUSH
11838: LD_INT 22
11840: PUSH
11841: LD_VAR 0 5
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 3
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: PPUSH
11864: CALL_OW 69
11868: PUSH
11869: FOR_IN
11870: IFFALSE 11886
// SetBLevel ( i , 10 ) ;
11872: LD_VAR 0 2
11876: PPUSH
11877: LD_INT 10
11879: PPUSH
11880: CALL_OW 241
11884: GO 11869
11886: POP
11887: POP
// base := GetBase ( al_depot ) ;
11888: LD_ADDR_VAR 0 4
11892: PUSH
11893: LD_INT 2
11895: PPUSH
11896: CALL_OW 274
11900: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11901: LD_ADDR_VAR 0 6
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_VAR 0 5
11913: PUSH
11914: EMPTY
11915: LIST
11916: LIST
11917: PUSH
11918: LD_INT 30
11920: PUSH
11921: LD_INT 34
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: EMPTY
11929: LIST
11930: LIST
11931: PPUSH
11932: CALL_OW 69
11936: ST_TO_ADDR
// if teleport then
11937: LD_VAR 0 6
11941: IFFALSE 11962
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11943: LD_VAR 0 6
11947: PUSH
11948: LD_INT 1
11950: ARRAY
11951: PPUSH
11952: LD_INT 262
11954: PPUSH
11955: LD_INT 119
11957: PPUSH
11958: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11962: LD_VAR 0 4
11966: PPUSH
11967: LD_INT 1
11969: PPUSH
11970: LD_INT 19500
11972: PPUSH
11973: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11977: LD_VAR 0 4
11981: PPUSH
11982: LD_INT 2
11984: PPUSH
11985: LD_INT 200
11987: PPUSH
11988: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11992: LD_VAR 0 4
11996: PPUSH
11997: LD_INT 3
11999: PPUSH
12000: LD_INT 650
12002: PPUSH
12003: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12007: LD_ADDR_EXP 76
12011: PUSH
12012: LD_STRING Roth
12014: PPUSH
12015: CALL_OW 25
12019: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12020: LD_ADDR_EXP 77
12024: PUSH
12025: LD_STRING Simms
12027: PPUSH
12028: LD_EXP 1
12032: NOT
12033: PPUSH
12034: LD_STRING 10c_
12036: PPUSH
12037: CALL 67195 0 3
12041: ST_TO_ADDR
// if not Simms then
12042: LD_EXP 77
12046: NOT
12047: IFFALSE 12077
// begin uc_nation := 1 ;
12049: LD_ADDR_OWVAR 21
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12057: LD_INT 2
12059: PPUSH
12060: LD_INT 10
12062: PPUSH
12063: CALL_OW 384
// Simms := CreateHuman ;
12067: LD_ADDR_EXP 77
12071: PUSH
12072: CALL_OW 44
12076: ST_TO_ADDR
// end ; uc_nation := 3 ;
12077: LD_ADDR_OWVAR 21
12081: PUSH
12082: LD_INT 3
12084: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12085: LD_ADDR_EXP 78
12089: PUSH
12090: LD_STRING Kirilenkova
12092: PPUSH
12093: CALL_OW 25
12097: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12098: LD_ADDR_EXP 92
12102: PUSH
12103: LD_STRING Oblukov
12105: PPUSH
12106: CALL_OW 25
12110: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12111: LD_ADDR_EXP 79
12115: PUSH
12116: LD_STRING Dolgov
12118: PPUSH
12119: CALL_OW 25
12123: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12124: LD_ADDR_EXP 80
12128: PUSH
12129: LD_STRING Petrosyan
12131: PPUSH
12132: CALL_OW 25
12136: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12137: LD_ADDR_EXP 91
12141: PUSH
12142: LD_STRING Scholtze
12144: PPUSH
12145: CALL_OW 25
12149: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12150: LD_ADDR_EXP 90
12154: PUSH
12155: LD_STRING Kapitsova
12157: PPUSH
12158: CALL_OW 25
12162: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12163: LD_ADDR_EXP 81
12167: PUSH
12168: LD_STRING Petrovova
12170: PPUSH
12171: CALL_OW 25
12175: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12176: LD_ADDR_EXP 82
12180: PUSH
12181: LD_STRING Kuzmov
12183: PPUSH
12184: CALL_OW 25
12188: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12189: LD_ADDR_EXP 89
12193: PUSH
12194: LD_STRING Karamazov
12196: PPUSH
12197: CALL_OW 25
12201: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12202: LD_STRING 13_Lipshchin_1
12204: PPUSH
12205: LD_INT 0
12207: PPUSH
12208: CALL_OW 30
12212: IFFALSE 12227
// Lipshchin := NewCharacter ( Lipshchin ) ;
12214: LD_ADDR_EXP 83
12218: PUSH
12219: LD_STRING Lipshchin
12221: PPUSH
12222: CALL_OW 25
12226: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12227: LD_STRING 13_Titov_1
12229: PPUSH
12230: LD_INT 0
12232: PPUSH
12233: CALL_OW 30
12237: IFFALSE 12252
// Titov := NewCharacter ( Titov ) ;
12239: LD_ADDR_EXP 85
12243: PUSH
12244: LD_STRING Titov
12246: PPUSH
12247: CALL_OW 25
12251: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12252: LD_STRING 13_Gnyevko_1
12254: PPUSH
12255: LD_INT 0
12257: PPUSH
12258: CALL_OW 30
12262: IFFALSE 12277
// Gnyevko := NewCharacter ( Gnyevko ) ;
12264: LD_ADDR_EXP 84
12268: PUSH
12269: LD_STRING Gnyevko
12271: PPUSH
12272: CALL_OW 25
12276: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12277: LD_STRING 13_Xavier_1
12279: PPUSH
12280: LD_INT 0
12282: PPUSH
12283: CALL_OW 30
12287: IFFALSE 12302
// Xavier := NewCharacter ( Xavier2 ) ;
12289: LD_ADDR_EXP 86
12293: PUSH
12294: LD_STRING Xavier2
12296: PPUSH
12297: CALL_OW 25
12301: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12302: LD_STRING 13_Belkov_1
12304: PPUSH
12305: LD_INT 0
12307: PPUSH
12308: CALL_OW 30
12312: IFFALSE 12327
// Belkov := NewCharacter ( Belkov ) ;
12314: LD_ADDR_EXP 87
12318: PUSH
12319: LD_STRING Belkov
12321: PPUSH
12322: CALL_OW 25
12326: ST_TO_ADDR
// if not BurlakStatus then
12327: LD_EXP 9
12331: NOT
12332: IFFALSE 12347
// Burlak = NewCharacter ( Burlak ) ;
12334: LD_ADDR_EXP 88
12338: PUSH
12339: LD_STRING Burlak
12341: PPUSH
12342: CALL_OW 25
12346: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12347: LD_ADDR_VAR 0 3
12351: PUSH
12352: LD_EXP 76
12356: PUSH
12357: LD_EXP 78
12361: PUSH
12362: LD_EXP 92
12366: PUSH
12367: LD_EXP 79
12371: PUSH
12372: LD_EXP 80
12376: PUSH
12377: LD_EXP 91
12381: PUSH
12382: LD_EXP 90
12386: PUSH
12387: LD_EXP 81
12391: PUSH
12392: LD_EXP 82
12396: PUSH
12397: LD_EXP 89
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: ST_TO_ADDR
// if Simms then
12414: LD_EXP 77
12418: IFFALSE 12436
// tmp := tmp ^ Simms ;
12420: LD_ADDR_VAR 0 3
12424: PUSH
12425: LD_VAR 0 3
12429: PUSH
12430: LD_EXP 77
12434: ADD
12435: ST_TO_ADDR
// if Titov then
12436: LD_EXP 85
12440: IFFALSE 12458
// tmp := tmp ^ Titov ;
12442: LD_ADDR_VAR 0 3
12446: PUSH
12447: LD_VAR 0 3
12451: PUSH
12452: LD_EXP 85
12456: ADD
12457: ST_TO_ADDR
// if Lipshchin then
12458: LD_EXP 83
12462: IFFALSE 12480
// tmp := tmp ^ Lipshchin ;
12464: LD_ADDR_VAR 0 3
12468: PUSH
12469: LD_VAR 0 3
12473: PUSH
12474: LD_EXP 83
12478: ADD
12479: ST_TO_ADDR
// if Gnyevko then
12480: LD_EXP 84
12484: IFFALSE 12502
// tmp := tmp ^ Gnyevko ;
12486: LD_ADDR_VAR 0 3
12490: PUSH
12491: LD_VAR 0 3
12495: PUSH
12496: LD_EXP 84
12500: ADD
12501: ST_TO_ADDR
// if Xavier then
12502: LD_EXP 86
12506: IFFALSE 12524
// tmp := tmp ^ Xavier ;
12508: LD_ADDR_VAR 0 3
12512: PUSH
12513: LD_VAR 0 3
12517: PUSH
12518: LD_EXP 86
12522: ADD
12523: ST_TO_ADDR
// if Belkov then
12524: LD_EXP 87
12528: IFFALSE 12546
// tmp := tmp ^ Belkov ;
12530: LD_ADDR_VAR 0 3
12534: PUSH
12535: LD_VAR 0 3
12539: PUSH
12540: LD_EXP 87
12544: ADD
12545: ST_TO_ADDR
// if Burlak then
12546: LD_EXP 88
12550: IFFALSE 12568
// tmp := tmp ^ Burlak ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_VAR 0 3
12561: PUSH
12562: LD_EXP 88
12566: ADD
12567: ST_TO_ADDR
// for i = 1 to 11 do
12568: LD_ADDR_VAR 0 2
12572: PUSH
12573: DOUBLE
12574: LD_INT 1
12576: DEC
12577: ST_TO_ADDR
12578: LD_INT 11
12580: PUSH
12581: FOR_TO
12582: IFFALSE 12648
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
12584: LD_ADDR_OWVAR 21
12588: PUSH
12589: LD_INT 1
12591: PUSH
12592: LD_INT 3
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 1
12601: PPUSH
12602: LD_INT 2
12604: PPUSH
12605: CALL_OW 12
12609: ARRAY
12610: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
12611: LD_INT 0
12613: PPUSH
12614: LD_VAR 0 2
12618: PUSH
12619: LD_INT 2
12621: DIV
12622: PPUSH
12623: LD_INT 10
12625: PPUSH
12626: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12630: LD_ADDR_VAR 0 3
12634: PUSH
12635: LD_VAR 0 3
12639: PUSH
12640: CALL_OW 44
12644: ADD
12645: ST_TO_ADDR
// end ;
12646: GO 12581
12648: POP
12649: POP
// for i in tmp do
12650: LD_ADDR_VAR 0 2
12654: PUSH
12655: LD_VAR 0 3
12659: PUSH
12660: FOR_IN
12661: IFFALSE 12686
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12663: LD_VAR 0 2
12667: PPUSH
12668: LD_INT 260
12670: PPUSH
12671: LD_INT 235
12673: PPUSH
12674: LD_INT 8
12676: PPUSH
12677: LD_INT 0
12679: PPUSH
12680: CALL_OW 50
12684: GO 12660
12686: POP
12687: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12688: LD_ADDR_EXP 99
12692: PUSH
12693: LD_EXP 99
12697: PPUSH
12698: LD_INT 1
12700: PPUSH
12701: LD_INT 22
12703: PUSH
12704: LD_VAR 0 5
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 3
12715: PUSH
12716: LD_INT 21
12718: PUSH
12719: LD_INT 2
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: PUSH
12739: LD_EXP 76
12743: PUSH
12744: LD_EXP 77
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: DIFF
12753: PPUSH
12754: CALL_OW 1
12758: ST_TO_ADDR
// uc_side := 0 ;
12759: LD_ADDR_OWVAR 20
12763: PUSH
12764: LD_INT 0
12766: ST_TO_ADDR
// uc_nation := 0 ;
12767: LD_ADDR_OWVAR 21
12771: PUSH
12772: LD_INT 0
12774: ST_TO_ADDR
// for i = 1 to 5 do
12775: LD_ADDR_VAR 0 2
12779: PUSH
12780: DOUBLE
12781: LD_INT 1
12783: DEC
12784: ST_TO_ADDR
12785: LD_INT 5
12787: PUSH
12788: FOR_TO
12789: IFFALSE 12826
// begin InitHc ;
12791: CALL_OW 19
// hc_class := class_apeman ;
12795: LD_ADDR_OWVAR 28
12799: PUSH
12800: LD_INT 12
12802: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12803: CALL_OW 44
12807: PPUSH
12808: LD_INT 299
12810: PPUSH
12811: LD_INT 229
12813: PPUSH
12814: LD_INT 10
12816: PPUSH
12817: LD_INT 0
12819: PPUSH
12820: CALL_OW 50
// end ;
12824: GO 12788
12826: POP
12827: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12828: LD_EXP 76
12832: PPUSH
12833: LD_INT 259
12835: PPUSH
12836: LD_INT 235
12838: PPUSH
12839: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12843: LD_EXP 76
12847: PPUSH
12848: LD_INT 262
12850: PPUSH
12851: LD_INT 235
12853: PPUSH
12854: CALL_OW 178
// if Simms then
12858: LD_EXP 77
12862: IFFALSE 12893
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12864: LD_EXP 77
12868: PPUSH
12869: LD_INT 262
12871: PPUSH
12872: LD_INT 235
12874: PPUSH
12875: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12879: LD_EXP 77
12883: PPUSH
12884: LD_EXP 76
12888: PPUSH
12889: CALL_OW 179
// end ; end ;
12893: LD_VAR 0 1
12897: RET
// every 5 5$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12898: LD_EXP 31
12902: PUSH
12903: LD_EXP 23
12907: NOT
12908: AND
12909: IFFALSE 13137
12911: GO 12913
12913: DISABLE
12914: LD_INT 0
12916: PPUSH
12917: PPUSH
12918: PPUSH
// begin enable ;
12919: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12920: LD_ADDR_VAR 0 2
12924: PUSH
12925: LD_INT 81
12927: PUSH
12928: LD_INT 7
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PUSH
12935: LD_INT 2
12937: PUSH
12938: LD_INT 32
12940: PUSH
12941: LD_INT 3
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: LD_INT 30
12950: PUSH
12951: LD_INT 30
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PUSH
12958: LD_INT 30
12960: PUSH
12961: LD_INT 28
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: PUSH
12968: LD_INT 34
12970: PUSH
12971: LD_INT 49
12973: PUSH
12974: EMPTY
12975: LIST
12976: LIST
12977: PUSH
12978: LD_INT 34
12980: PUSH
12981: LD_INT 10
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 34
12990: PUSH
12991: LD_INT 8
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: PPUSH
13011: CALL_OW 69
13015: ST_TO_ADDR
// if not tmp then
13016: LD_VAR 0 2
13020: NOT
13021: IFFALSE 13025
// exit ;
13023: GO 13137
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13025: LD_VAR 0 2
13029: PPUSH
13030: LD_INT 34
13032: PUSH
13033: LD_INT 8
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PPUSH
13040: CALL_OW 72
13044: IFFALSE 13077
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13046: LD_ADDR_VAR 0 3
13050: PUSH
13051: LD_VAR 0 2
13055: PPUSH
13056: LD_INT 34
13058: PUSH
13059: LD_INT 8
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: PPUSH
13066: CALL_OW 72
13070: PUSH
13071: LD_INT 1
13073: ARRAY
13074: ST_TO_ADDR
13075: GO 13101
// target := tmp [ rand ( 1 , tmp ) ] ;
13077: LD_ADDR_VAR 0 3
13081: PUSH
13082: LD_VAR 0 2
13086: PUSH
13087: LD_INT 1
13089: PPUSH
13090: LD_VAR 0 2
13094: PPUSH
13095: CALL_OW 12
13099: ARRAY
13100: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13101: LD_VAR 0 3
13105: PPUSH
13106: CALL_OW 255
13110: PUSH
13111: LD_INT 1
13113: EQUAL
13114: IFFALSE 13125
// CenterNowOnUnits ( target ) ;
13116: LD_VAR 0 3
13120: PPUSH
13121: CALL_OW 87
// SetLives ( target , 0 ) ;
13125: LD_VAR 0 3
13129: PPUSH
13130: LD_INT 0
13132: PPUSH
13133: CALL_OW 234
// end ;
13137: PPOPN 3
13139: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13140: LD_EXP 23
13144: NOT
13145: PUSH
13146: LD_EXP 31
13150: AND
13151: IFFALSE 13677
13153: GO 13155
13155: DISABLE
13156: LD_INT 0
13158: PPUSH
13159: PPUSH
13160: PPUSH
// begin uc_side := 7 ;
13161: LD_ADDR_OWVAR 20
13165: PUSH
13166: LD_INT 7
13168: ST_TO_ADDR
// uc_nation := 1 ;
13169: LD_ADDR_OWVAR 21
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
13177: LD_ADDR_VAR 0 3
13181: PUSH
13182: LD_INT 125
13184: PUSH
13185: LD_INT 163
13187: PUSH
13188: EMPTY
13189: LIST
13190: LIST
13191: PUSH
13192: LD_INT 185
13194: PUSH
13195: LD_INT 168
13197: PUSH
13198: EMPTY
13199: LIST
13200: LIST
13201: PUSH
13202: LD_INT 111
13204: PUSH
13205: LD_INT 97
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: EMPTY
13213: LIST
13214: LIST
13215: LIST
13216: PPUSH
13217: CALL 104749 0 1
13221: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13222: LD_ADDR_EXP 93
13226: PUSH
13227: EMPTY
13228: ST_TO_ADDR
// for i = 1 to Difficulty do
13229: LD_ADDR_VAR 0 1
13233: PUSH
13234: DOUBLE
13235: LD_INT 1
13237: DEC
13238: ST_TO_ADDR
13239: LD_OWVAR 67
13243: PUSH
13244: FOR_TO
13245: IFFALSE 13403
// begin InitHc ;
13247: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13251: LD_INT 0
13253: PPUSH
13254: LD_INT 8
13256: PPUSH
13257: CALL_OW 381
// un := CreateHuman ;
13261: LD_ADDR_VAR 0 2
13265: PUSH
13266: CALL_OW 44
13270: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13271: LD_VAR 0 2
13275: PPUSH
13276: LD_INT 258
13278: PPUSH
13279: LD_INT 267
13281: PPUSH
13282: LD_INT 4
13284: PPUSH
13285: LD_INT 0
13287: PPUSH
13288: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13292: LD_ADDR_EXP 93
13296: PUSH
13297: LD_EXP 93
13301: PUSH
13302: LD_VAR 0 2
13306: UNION
13307: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13308: LD_VAR 0 2
13312: PPUSH
13313: LD_VAR 0 3
13317: PUSH
13318: LD_VAR 0 1
13322: ARRAY
13323: PUSH
13324: LD_INT 1
13326: ARRAY
13327: PPUSH
13328: LD_VAR 0 3
13332: PUSH
13333: LD_VAR 0 1
13337: ARRAY
13338: PUSH
13339: LD_INT 2
13341: ARRAY
13342: PPUSH
13343: LD_INT 4
13345: PPUSH
13346: LD_INT 1
13348: PPUSH
13349: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13353: LD_VAR 0 2
13357: PPUSH
13358: LD_VAR 0 3
13362: PUSH
13363: LD_VAR 0 1
13367: ARRAY
13368: PUSH
13369: LD_INT 1
13371: ARRAY
13372: PPUSH
13373: LD_VAR 0 3
13377: PUSH
13378: LD_VAR 0 1
13382: ARRAY
13383: PUSH
13384: LD_INT 2
13386: ARRAY
13387: PPUSH
13388: CALL_OW 171
// AddComInvisible ( un ) ;
13392: LD_VAR 0 2
13396: PPUSH
13397: CALL_OW 212
// end ;
13401: GO 13244
13403: POP
13404: POP
// repeat wait ( 0 0$20 ) ;
13405: LD_INT 700
13407: PPUSH
13408: CALL_OW 67
// for i in allianceSpecialForce do
13412: LD_ADDR_VAR 0 1
13416: PUSH
13417: LD_EXP 93
13421: PUSH
13422: FOR_IN
13423: IFFALSE 13662
// begin if IsInvisible ( i ) then
13425: LD_VAR 0 1
13429: PPUSH
13430: CALL_OW 571
13434: IFFALSE 13631
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
13436: LD_ADDR_VAR 0 3
13440: PUSH
13441: LD_INT 22
13443: PUSH
13444: LD_INT 1
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: PUSH
13451: LD_INT 50
13453: PUSH
13454: EMPTY
13455: LIST
13456: PUSH
13457: LD_INT 56
13459: PUSH
13460: EMPTY
13461: LIST
13462: PUSH
13463: LD_INT 91
13465: PUSH
13466: LD_VAR 0 1
13470: PUSH
13471: LD_INT 25
13473: PUSH
13474: LD_INT 30
13476: PUSH
13477: LD_INT 35
13479: PUSH
13480: LD_INT 40
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: PUSH
13489: LD_OWVAR 67
13493: ARRAY
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 2
13502: PUSH
13503: LD_INT 25
13505: PUSH
13506: LD_INT 1
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: LD_INT 25
13515: PUSH
13516: LD_INT 2
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 25
13525: PUSH
13526: LD_INT 3
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: LD_INT 25
13535: PUSH
13536: LD_INT 4
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 25
13545: PUSH
13546: LD_INT 5
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 25
13555: PUSH
13556: LD_INT 8
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: PPUSH
13579: CALL_OW 69
13583: ST_TO_ADDR
// if not tmp then
13584: LD_VAR 0 3
13588: NOT
13589: IFFALSE 13593
// continue ;
13591: GO 13422
// if Prob ( 30 * Difficulty ) then
13593: LD_INT 30
13595: PUSH
13596: LD_OWVAR 67
13600: MUL
13601: PPUSH
13602: CALL_OW 13
13606: IFFALSE 13631
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
13608: LD_VAR 0 3
13612: PUSH
13613: LD_INT 1
13615: PPUSH
13616: LD_VAR 0 3
13620: PPUSH
13621: CALL_OW 12
13625: ARRAY
13626: PPUSH
13627: CALL 32605 0 1
// end ; if IsDead ( i ) then
13631: LD_VAR 0 1
13635: PPUSH
13636: CALL_OW 301
13640: IFFALSE 13660
// begin allianceSpecialForce := allianceSpecialForce diff i ;
13642: LD_ADDR_EXP 93
13646: PUSH
13647: LD_EXP 93
13651: PUSH
13652: LD_VAR 0 1
13656: DIFF
13657: ST_TO_ADDR
// continue ;
13658: GO 13422
// end ; end ;
13660: GO 13422
13662: POP
13663: POP
// until allianceDestroyed or not allianceSpecialForce ;
13664: LD_EXP 23
13668: PUSH
13669: LD_EXP 93
13673: NOT
13674: OR
13675: IFFALSE 13405
// end ;
13677: PPOPN 3
13679: END
// every 12 12$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
13680: LD_EXP 23
13684: NOT
13685: PUSH
13686: LD_EXP 31
13690: AND
13691: IFFALSE 14641
13693: GO 13695
13695: DISABLE
13696: LD_INT 0
13698: PPUSH
13699: PPUSH
13700: PPUSH
13701: PPUSH
// begin enable ;
13702: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13703: LD_INT 22
13705: PUSH
13706: LD_INT 7
13708: PUSH
13709: EMPTY
13710: LIST
13711: LIST
13712: PUSH
13713: LD_INT 30
13715: PUSH
13716: LD_INT 3
13718: PUSH
13719: EMPTY
13720: LIST
13721: LIST
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 69
13731: NOT
13732: IFFALSE 13736
// exit ;
13734: GO 14641
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13736: LD_ADDR_VAR 0 4
13740: PUSH
13741: LD_INT 22
13743: PUSH
13744: LD_INT 7
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: LD_INT 30
13753: PUSH
13754: LD_INT 34
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: PPUSH
13765: CALL_OW 69
13769: ST_TO_ADDR
// if Prob ( 40 ) then
13770: LD_INT 40
13772: PPUSH
13773: CALL_OW 13
13777: IFFALSE 13923
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13779: LD_INT 1
13781: PPUSH
13782: LD_INT 5
13784: PUSH
13785: LD_INT 3
13787: PUSH
13788: LD_INT 2
13790: PUSH
13791: LD_INT 6
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: PUSH
13800: LD_INT 5
13802: PUSH
13803: LD_INT 3
13805: PUSH
13806: LD_INT 2
13808: PUSH
13809: LD_INT 6
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: PUSH
13818: LD_INT 5
13820: PUSH
13821: LD_INT 3
13823: PUSH
13824: LD_INT 2
13826: PUSH
13827: LD_INT 6
13829: PUSH
13830: EMPTY
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 5
13838: PUSH
13839: LD_INT 3
13841: PUSH
13842: LD_INT 2
13844: PUSH
13845: LD_INT 9
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: PUSH
13854: LD_INT 24
13856: PUSH
13857: LD_INT 3
13859: PUSH
13860: LD_INT 3
13862: PUSH
13863: LD_INT 45
13865: PUSH
13866: EMPTY
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: PUSH
13872: LD_INT 24
13874: PUSH
13875: LD_INT 3
13877: PUSH
13878: LD_INT 3
13880: PUSH
13881: LD_INT 47
13883: PUSH
13884: EMPTY
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: PUSH
13890: LD_INT 24
13892: PUSH
13893: LD_INT 3
13895: PUSH
13896: LD_INT 3
13898: PUSH
13899: LD_INT 45
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: PPUSH
13917: CALL 60807 0 2
// end else
13921: GO 14065
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13923: LD_INT 1
13925: PPUSH
13926: LD_INT 24
13928: PUSH
13929: LD_INT 3
13931: PUSH
13932: LD_INT 3
13934: PUSH
13935: LD_INT 47
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: PUSH
13944: LD_INT 24
13946: PUSH
13947: LD_INT 3
13949: PUSH
13950: LD_INT 3
13952: PUSH
13953: LD_INT 47
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: PUSH
13962: LD_INT 5
13964: PUSH
13965: LD_INT 3
13967: PUSH
13968: LD_INT 2
13970: PUSH
13971: LD_INT 9
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: PUSH
13980: LD_INT 5
13982: PUSH
13983: LD_INT 3
13985: PUSH
13986: LD_INT 2
13988: PUSH
13989: LD_INT 9
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: PUSH
13998: LD_INT 5
14000: PUSH
14001: LD_INT 3
14003: PUSH
14004: LD_INT 2
14006: PUSH
14007: LD_INT 9
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: PUSH
14016: LD_INT 24
14018: PUSH
14019: LD_INT 1
14021: PUSH
14022: LD_INT 3
14024: PUSH
14025: LD_INT 45
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: PUSH
14034: LD_INT 24
14036: PUSH
14037: LD_INT 1
14039: PUSH
14040: LD_INT 3
14042: PUSH
14043: LD_INT 45
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: PPUSH
14061: CALL 60807 0 2
// end ; repeat wait ( 0 0$1 ) ;
14065: LD_INT 35
14067: PPUSH
14068: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
14072: LD_INT 1
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: CALL 62225 0 2
14082: PUSH
14083: LD_INT 7
14085: GREATEREQUAL
14086: IFFALSE 14065
// wait ( 0 0$10 ) ;
14088: LD_INT 350
14090: PPUSH
14091: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
14095: LD_ADDR_VAR 0 2
14099: PUSH
14100: LD_INT 1
14102: PPUSH
14103: LD_INT 1
14105: PPUSH
14106: CALL 62225 0 2
14110: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
14111: LD_ADDR_EXP 118
14115: PUSH
14116: LD_EXP 118
14120: PPUSH
14121: LD_INT 1
14123: PPUSH
14124: LD_EXP 118
14128: PUSH
14129: LD_INT 1
14131: ARRAY
14132: PUSH
14133: LD_VAR 0 2
14137: DIFF
14138: PPUSH
14139: CALL_OW 1
14143: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
14144: LD_ADDR_VAR 0 3
14148: PUSH
14149: LD_INT 0
14151: PPUSH
14152: LD_INT 1
14154: PPUSH
14155: CALL_OW 12
14159: ST_TO_ADDR
// if target then
14160: LD_VAR 0 3
14164: IFFALSE 14330
// begin for i in tmp do
14166: LD_ADDR_VAR 0 1
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: FOR_IN
14177: IFFALSE 14202
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
14179: LD_VAR 0 1
14183: PPUSH
14184: LD_INT 179
14186: PPUSH
14187: LD_INT 209
14189: PPUSH
14190: LD_INT 8
14192: PPUSH
14193: LD_INT 1
14195: PPUSH
14196: CALL_OW 483
14200: GO 14176
14202: POP
14203: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14204: LD_ADDR_VAR 0 2
14208: PUSH
14209: LD_VAR 0 2
14213: PPUSH
14214: LD_INT 24
14216: PUSH
14217: LD_INT 250
14219: PUSH
14220: EMPTY
14221: LIST
14222: LIST
14223: PPUSH
14224: CALL_OW 72
14228: ST_TO_ADDR
// for i in tmp do
14229: LD_ADDR_VAR 0 1
14233: PUSH
14234: LD_VAR 0 2
14238: PUSH
14239: FOR_IN
14240: IFFALSE 14280
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
14242: LD_VAR 0 1
14246: PPUSH
14247: LD_INT 179
14249: PPUSH
14250: LD_INT 209
14252: PPUSH
14253: CALL_OW 297
14257: PUSH
14258: LD_INT 9
14260: GREATER
14261: IFFALSE 14278
// ComMoveXY ( i , 179 , 209 ) ;
14263: LD_VAR 0 1
14267: PPUSH
14268: LD_INT 179
14270: PPUSH
14271: LD_INT 209
14273: PPUSH
14274: CALL_OW 111
14278: GO 14239
14280: POP
14281: POP
// wait ( 0 0$1 ) ;
14282: LD_INT 35
14284: PPUSH
14285: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
14289: LD_VAR 0 2
14293: PPUSH
14294: LD_INT 92
14296: PUSH
14297: LD_INT 179
14299: PUSH
14300: LD_INT 209
14302: PUSH
14303: LD_INT 9
14305: PUSH
14306: EMPTY
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: PPUSH
14312: CALL_OW 72
14316: PUSH
14317: LD_VAR 0 2
14321: PUSH
14322: LD_INT 1
14324: MINUS
14325: GREATEREQUAL
14326: IFFALSE 14204
// end else
14328: GO 14492
// begin for i in tmp do
14330: LD_ADDR_VAR 0 1
14334: PUSH
14335: LD_VAR 0 2
14339: PUSH
14340: FOR_IN
14341: IFFALSE 14366
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
14343: LD_VAR 0 1
14347: PPUSH
14348: LD_INT 285
14350: PPUSH
14351: LD_INT 163
14353: PPUSH
14354: LD_INT 8
14356: PPUSH
14357: LD_INT 1
14359: PPUSH
14360: CALL_OW 483
14364: GO 14340
14366: POP
14367: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
14368: LD_ADDR_VAR 0 2
14372: PUSH
14373: LD_VAR 0 2
14377: PPUSH
14378: LD_INT 24
14380: PUSH
14381: LD_INT 250
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PPUSH
14388: CALL_OW 72
14392: ST_TO_ADDR
// for i in tmp do
14393: LD_ADDR_VAR 0 1
14397: PUSH
14398: LD_VAR 0 2
14402: PUSH
14403: FOR_IN
14404: IFFALSE 14444
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
14406: LD_VAR 0 1
14410: PPUSH
14411: LD_INT 285
14413: PPUSH
14414: LD_INT 163
14416: PPUSH
14417: CALL_OW 297
14421: PUSH
14422: LD_INT 9
14424: GREATER
14425: IFFALSE 14442
// ComMoveXY ( i , 285 , 163 ) ;
14427: LD_VAR 0 1
14431: PPUSH
14432: LD_INT 285
14434: PPUSH
14435: LD_INT 163
14437: PPUSH
14438: CALL_OW 111
14442: GO 14403
14444: POP
14445: POP
// wait ( 0 0$1 ) ;
14446: LD_INT 35
14448: PPUSH
14449: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
14453: LD_VAR 0 2
14457: PPUSH
14458: LD_INT 92
14460: PUSH
14461: LD_INT 285
14463: PUSH
14464: LD_INT 163
14466: PUSH
14467: LD_INT 9
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: PPUSH
14476: CALL_OW 72
14480: PUSH
14481: LD_VAR 0 2
14485: PUSH
14486: LD_INT 1
14488: MINUS
14489: GREATEREQUAL
14490: IFFALSE 14368
// end ; repeat wait ( 0 0$1 ) ;
14492: LD_INT 35
14494: PPUSH
14495: CALL_OW 67
// for i in tmp do
14499: LD_ADDR_VAR 0 1
14503: PUSH
14504: LD_VAR 0 2
14508: PUSH
14509: FOR_IN
14510: IFFALSE 14632
// if GetLives ( i ) > 251 then
14512: LD_VAR 0 1
14516: PPUSH
14517: CALL_OW 256
14521: PUSH
14522: LD_INT 251
14524: GREATER
14525: IFFALSE 14614
// begin if GetWeapon ( i ) = ru_time_lapser then
14527: LD_VAR 0 1
14531: PPUSH
14532: CALL_OW 264
14536: PUSH
14537: LD_INT 49
14539: EQUAL
14540: IFFALSE 14578
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
14542: LD_VAR 0 1
14546: PPUSH
14547: LD_INT 81
14549: PUSH
14550: LD_INT 7
14552: PUSH
14553: EMPTY
14554: LIST
14555: LIST
14556: PPUSH
14557: CALL_OW 69
14561: PPUSH
14562: LD_VAR 0 1
14566: PPUSH
14567: CALL_OW 74
14571: PPUSH
14572: CALL_OW 112
14576: GO 14612
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
14578: LD_VAR 0 1
14582: PPUSH
14583: LD_INT 81
14585: PUSH
14586: LD_INT 7
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: PPUSH
14593: CALL_OW 69
14597: PPUSH
14598: LD_VAR 0 1
14602: PPUSH
14603: CALL_OW 74
14607: PPUSH
14608: CALL_OW 115
// end else
14612: GO 14630
// tmp := tmp diff i ;
14614: LD_ADDR_VAR 0 2
14618: PUSH
14619: LD_VAR 0 2
14623: PUSH
14624: LD_VAR 0 1
14628: DIFF
14629: ST_TO_ADDR
14630: GO 14509
14632: POP
14633: POP
// until not tmp ;
14634: LD_VAR 0 2
14638: NOT
14639: IFFALSE 14492
// end ; end_of_file
14641: PPOPN 4
14643: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
14644: LD_INT 0
14646: PPUSH
14647: PPUSH
14648: PPUSH
14649: PPUSH
// missionStage := 13 ;
14650: LD_ADDR_EXP 15
14654: PUSH
14655: LD_INT 13
14657: ST_TO_ADDR
// uc_side := 2 ;
14658: LD_ADDR_OWVAR 20
14662: PUSH
14663: LD_INT 2
14665: ST_TO_ADDR
// uc_nation := 2 ;
14666: LD_ADDR_OWVAR 21
14670: PUSH
14671: LD_INT 2
14673: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14674: LD_ADDR_EXP 94
14678: PUSH
14679: LD_STRING Omar
14681: PPUSH
14682: CALL_OW 25
14686: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14687: LD_EXP 94
14691: PPUSH
14692: LD_INT 4
14694: PPUSH
14695: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14699: LD_EXP 94
14703: PPUSH
14704: LD_INT 242
14706: PPUSH
14707: LD_INT 75
14709: PPUSH
14710: LD_INT 0
14712: PPUSH
14713: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14717: LD_ADDR_EXP 95
14721: PUSH
14722: LD_STRING Heike
14724: PPUSH
14725: CALL_OW 25
14729: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14730: LD_INT 14
14732: PPUSH
14733: LD_INT 3
14735: PPUSH
14736: LD_INT 1
14738: PPUSH
14739: LD_INT 27
14741: PPUSH
14742: LD_INT 100
14744: PPUSH
14745: CALL 72210 0 5
// veh := CreateVehicle ;
14749: LD_ADDR_VAR 0 3
14753: PUSH
14754: CALL_OW 45
14758: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
14759: LD_VAR 0 3
14763: PPUSH
14764: LD_INT 2
14766: NEG
14767: PPUSH
14768: CALL_OW 242
// SetDir ( veh , 4 ) ;
14772: LD_VAR 0 3
14776: PPUSH
14777: LD_INT 4
14779: PPUSH
14780: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14784: LD_VAR 0 3
14788: PPUSH
14789: LD_INT 241
14791: PPUSH
14792: LD_INT 72
14794: PPUSH
14795: LD_INT 0
14797: PPUSH
14798: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14802: LD_EXP 95
14806: PPUSH
14807: LD_VAR 0 3
14811: PPUSH
14812: CALL_OW 52
// if KhatamStatus then
14816: LD_EXP 8
14820: IFFALSE 14883
// begin Khatam := NewCharacter ( Khatam ) ;
14822: LD_ADDR_EXP 96
14826: PUSH
14827: LD_STRING Khatam
14829: PPUSH
14830: CALL_OW 25
14834: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14835: LD_EXP 96
14839: PPUSH
14840: LD_INT 245
14842: PPUSH
14843: LD_INT 78
14845: PPUSH
14846: LD_INT 3
14848: PPUSH
14849: LD_INT 0
14851: PPUSH
14852: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14856: LD_EXP 96
14860: PPUSH
14861: LD_INT 4
14863: PPUSH
14864: LD_INT 10
14866: PPUSH
14867: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
14871: LD_EXP 96
14875: PPUSH
14876: LD_INT 4
14878: PPUSH
14879: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
14883: LD_ADDR_VAR 0 2
14887: PUSH
14888: DOUBLE
14889: LD_INT 1
14891: DEC
14892: ST_TO_ADDR
14893: LD_INT 2
14895: PUSH
14896: LD_INT 2
14898: PUSH
14899: LD_INT 3
14901: PUSH
14902: LD_INT 3
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: PUSH
14911: LD_OWVAR 67
14915: ARRAY
14916: PUSH
14917: FOR_TO
14918: IFFALSE 14984
// begin PrepareScientist ( false , 6 + Difficulty ) ;
14920: LD_INT 0
14922: PPUSH
14923: LD_INT 6
14925: PUSH
14926: LD_OWVAR 67
14930: PLUS
14931: PPUSH
14932: CALL_OW 384
// un := CreateHuman ;
14936: LD_ADDR_VAR 0 4
14940: PUSH
14941: CALL_OW 44
14945: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14946: LD_VAR 0 4
14950: PPUSH
14951: LD_INT 28
14953: PUSH
14954: LD_INT 29
14956: PUSH
14957: EMPTY
14958: LIST
14959: LIST
14960: PUSH
14961: LD_VAR 0 2
14965: PUSH
14966: LD_INT 2
14968: MOD
14969: PUSH
14970: LD_INT 1
14972: PLUS
14973: ARRAY
14974: PPUSH
14975: LD_INT 0
14977: PPUSH
14978: CALL_OW 49
// end ;
14982: GO 14917
14984: POP
14985: POP
// for i = 1 to 6 do
14986: LD_ADDR_VAR 0 2
14990: PUSH
14991: DOUBLE
14992: LD_INT 1
14994: DEC
14995: ST_TO_ADDR
14996: LD_INT 6
14998: PUSH
14999: FOR_TO
15000: IFFALSE 15045
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
15002: LD_INT 0
15004: PPUSH
15005: LD_INT 6
15007: PUSH
15008: LD_OWVAR 67
15012: PLUS
15013: PPUSH
15014: CALL_OW 381
// un := CreateHuman ;
15018: LD_ADDR_VAR 0 4
15022: PUSH
15023: CALL_OW 44
15027: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15028: LD_VAR 0 4
15032: PPUSH
15033: LD_INT 32
15035: PPUSH
15036: LD_INT 0
15038: PPUSH
15039: CALL_OW 49
// end ;
15043: GO 14999
15045: POP
15046: POP
// for i = 1 to 3 do
15047: LD_ADDR_VAR 0 2
15051: PUSH
15052: DOUBLE
15053: LD_INT 1
15055: DEC
15056: ST_TO_ADDR
15057: LD_INT 3
15059: PUSH
15060: FOR_TO
15061: IFFALSE 15109
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
15063: LD_INT 0
15065: PPUSH
15066: LD_INT 8
15068: PPUSH
15069: LD_INT 6
15071: PUSH
15072: LD_OWVAR 67
15076: PLUS
15077: PPUSH
15078: CALL_OW 380
// un := CreateHuman ;
15082: LD_ADDR_VAR 0 4
15086: PUSH
15087: CALL_OW 44
15091: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
15092: LD_VAR 0 4
15096: PPUSH
15097: LD_INT 32
15099: PPUSH
15100: LD_INT 0
15102: PPUSH
15103: CALL_OW 49
// end ;
15107: GO 15060
15109: POP
15110: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
15111: LD_ADDR_VAR 0 2
15115: PUSH
15116: DOUBLE
15117: LD_INT 1
15119: DEC
15120: ST_TO_ADDR
15121: LD_INT 2
15123: PUSH
15124: LD_INT 3
15126: PUSH
15127: LD_INT 4
15129: PUSH
15130: LD_INT 4
15132: PUSH
15133: EMPTY
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: PUSH
15139: LD_OWVAR 67
15143: ARRAY
15144: PUSH
15145: FOR_TO
15146: IFFALSE 15236
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
15148: LD_INT 14
15150: PPUSH
15151: LD_INT 2
15153: PPUSH
15154: LD_INT 1
15156: PPUSH
15157: LD_INT 28
15159: PPUSH
15160: LD_INT 80
15162: PPUSH
15163: CALL 72210 0 5
// veh := CreateVehicle ;
15167: LD_ADDR_VAR 0 3
15171: PUSH
15172: CALL_OW 45
15176: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
15177: LD_VAR 0 3
15181: PPUSH
15182: LD_INT 3
15184: PPUSH
15185: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
15189: LD_VAR 0 3
15193: PPUSH
15194: LD_INT 29
15196: PPUSH
15197: LD_INT 0
15199: PPUSH
15200: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15204: LD_INT 0
15206: PPUSH
15207: LD_INT 6
15209: PUSH
15210: LD_OWVAR 67
15214: PLUS
15215: PPUSH
15216: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15220: CALL_OW 44
15224: PPUSH
15225: LD_VAR 0 3
15229: PPUSH
15230: CALL_OW 52
// end ;
15234: GO 15145
15236: POP
15237: POP
// for i = 1 to 5 + Difficulty do
15238: LD_ADDR_VAR 0 2
15242: PUSH
15243: DOUBLE
15244: LD_INT 1
15246: DEC
15247: ST_TO_ADDR
15248: LD_INT 5
15250: PUSH
15251: LD_OWVAR 67
15255: PLUS
15256: PUSH
15257: FOR_TO
15258: IFFALSE 15385
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
15260: LD_INT 14
15262: PPUSH
15263: LD_INT 1
15265: PPUSH
15266: LD_INT 3
15268: PPUSH
15269: CALL_OW 12
15273: PPUSH
15274: LD_INT 1
15276: PPUSH
15277: LD_INT 28
15279: PUSH
15280: LD_INT 26
15282: PUSH
15283: LD_INT 27
15285: PUSH
15286: LD_INT 25
15288: PUSH
15289: EMPTY
15290: LIST
15291: LIST
15292: LIST
15293: LIST
15294: PUSH
15295: LD_VAR 0 2
15299: PUSH
15300: LD_INT 4
15302: MOD
15303: PUSH
15304: LD_INT 1
15306: PLUS
15307: ARRAY
15308: PPUSH
15309: LD_INT 80
15311: PPUSH
15312: CALL 72210 0 5
// veh := CreateVehicle ;
15316: LD_ADDR_VAR 0 3
15320: PUSH
15321: CALL_OW 45
15325: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15326: LD_VAR 0 3
15330: PPUSH
15331: LD_INT 4
15333: PPUSH
15334: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15338: LD_VAR 0 3
15342: PPUSH
15343: LD_INT 28
15345: PPUSH
15346: LD_INT 0
15348: PPUSH
15349: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
15353: LD_INT 0
15355: PPUSH
15356: LD_INT 6
15358: PUSH
15359: LD_OWVAR 67
15363: PLUS
15364: PPUSH
15365: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
15369: CALL_OW 44
15373: PPUSH
15374: LD_VAR 0 3
15378: PPUSH
15379: CALL_OW 52
// end ;
15383: GO 15257
15385: POP
15386: POP
// for i = 1 to Difficulty do
15387: LD_ADDR_VAR 0 2
15391: PUSH
15392: DOUBLE
15393: LD_INT 1
15395: DEC
15396: ST_TO_ADDR
15397: LD_OWVAR 67
15401: PUSH
15402: FOR_TO
15403: IFFALSE 15463
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
15405: LD_INT 14
15407: PPUSH
15408: LD_INT 3
15410: PPUSH
15411: LD_INT 5
15413: PPUSH
15414: LD_INT 29
15416: PPUSH
15417: LD_INT 80
15419: PPUSH
15420: CALL 72210 0 5
// veh := CreateVehicle ;
15424: LD_ADDR_VAR 0 3
15428: PUSH
15429: CALL_OW 45
15433: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
15434: LD_VAR 0 3
15438: PPUSH
15439: LD_INT 4
15441: PPUSH
15442: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
15446: LD_VAR 0 3
15450: PPUSH
15451: LD_INT 28
15453: PPUSH
15454: LD_INT 0
15456: PPUSH
15457: CALL_OW 49
// end ;
15461: GO 15402
15463: POP
15464: POP
// end ;
15465: LD_VAR 0 1
15469: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
15470: LD_INT 22
15472: PUSH
15473: LD_INT 2
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: PPUSH
15480: CALL_OW 69
15484: IFFALSE 15863
15486: GO 15488
15488: DISABLE
15489: LD_INT 0
15491: PPUSH
15492: PPUSH
15493: PPUSH
15494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
15495: LD_ADDR_VAR 0 3
15499: PUSH
15500: LD_INT 22
15502: PUSH
15503: LD_INT 2
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 25
15512: PUSH
15513: LD_INT 4
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: EMPTY
15521: LIST
15522: LIST
15523: PPUSH
15524: CALL_OW 69
15528: PUSH
15529: LD_EXP 96
15533: DIFF
15534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
15535: LD_ADDR_VAR 0 2
15539: PUSH
15540: LD_INT 22
15542: PUSH
15543: LD_INT 2
15545: PUSH
15546: EMPTY
15547: LIST
15548: LIST
15549: PPUSH
15550: CALL_OW 69
15554: PUSH
15555: LD_EXP 96
15559: PUSH
15560: LD_VAR 0 3
15564: UNION
15565: DIFF
15566: ST_TO_ADDR
// if Khatam then
15567: LD_EXP 96
15571: IFFALSE 15588
// ComMoveXY ( Khatam , 211 , 92 ) ;
15573: LD_EXP 96
15577: PPUSH
15578: LD_INT 211
15580: PPUSH
15581: LD_INT 92
15583: PPUSH
15584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
15588: LD_INT 197
15590: PPUSH
15591: LD_INT 80
15593: PPUSH
15594: LD_INT 2
15596: PPUSH
15597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
15601: LD_INT 213
15603: PPUSH
15604: LD_INT 90
15606: PPUSH
15607: LD_INT 2
15609: PPUSH
15610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
15614: LD_INT 215
15616: PPUSH
15617: LD_INT 129
15619: PPUSH
15620: LD_INT 2
15622: PPUSH
15623: CALL_OW 441
// if sci then
15627: LD_VAR 0 3
15631: IFFALSE 15652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
15633: LD_VAR 0 3
15637: PUSH
15638: LD_INT 1
15640: ARRAY
15641: PPUSH
15642: LD_INT 197
15644: PPUSH
15645: LD_INT 80
15647: PPUSH
15648: CALL_OW 158
// if sci > 1 then
15652: LD_VAR 0 3
15656: PUSH
15657: LD_INT 1
15659: GREATER
15660: IFFALSE 15681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
15662: LD_VAR 0 3
15666: PUSH
15667: LD_INT 2
15669: ARRAY
15670: PPUSH
15671: LD_INT 213
15673: PPUSH
15674: LD_INT 90
15676: PPUSH
15677: CALL_OW 158
// if sci > 2 then
15681: LD_VAR 0 3
15685: PUSH
15686: LD_INT 2
15688: GREATER
15689: IFFALSE 15710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
15691: LD_VAR 0 3
15695: PUSH
15696: LD_INT 3
15698: ARRAY
15699: PPUSH
15700: LD_INT 215
15702: PPUSH
15703: LD_INT 129
15705: PPUSH
15706: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
15710: LD_VAR 0 2
15714: PPUSH
15715: LD_INT 195
15717: PPUSH
15718: LD_INT 102
15720: PPUSH
15721: CALL_OW 114
// wait ( 0 0$5 ) ;
15725: LD_INT 175
15727: PPUSH
15728: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
15732: LD_INT 70
15734: PPUSH
15735: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
15739: LD_ADDR_VAR 0 4
15743: PUSH
15744: LD_INT 92
15746: PUSH
15747: LD_INT 195
15749: PUSH
15750: LD_INT 102
15752: PUSH
15753: LD_INT 36
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 22
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: ST_TO_ADDR
// for i in tmp do
15781: LD_ADDR_VAR 0 1
15785: PUSH
15786: LD_VAR 0 2
15790: PUSH
15791: FOR_IN
15792: IFFALSE 15843
// if enemy then
15794: LD_VAR 0 4
15798: IFFALSE 15826
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15800: LD_VAR 0 1
15804: PPUSH
15805: LD_VAR 0 4
15809: PPUSH
15810: LD_VAR 0 1
15814: PPUSH
15815: CALL_OW 74
15819: PPUSH
15820: CALL_OW 115
15824: GO 15841
// ComAgressiveMove ( i , 195 , 102 ) ;
15826: LD_VAR 0 1
15830: PPUSH
15831: LD_INT 195
15833: PPUSH
15834: LD_INT 102
15836: PPUSH
15837: CALL_OW 114
15841: GO 15791
15843: POP
15844: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
15845: LD_VAR 0 2
15849: PPUSH
15850: LD_INT 50
15852: PUSH
15853: EMPTY
15854: LIST
15855: PPUSH
15856: CALL_OW 72
15860: NOT
15861: IFFALSE 15732
// end ; end_of_file
15863: PPOPN 4
15865: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15866: LD_INT 0
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
15872: PPUSH
15873: PPUSH
15874: PPUSH
15875: PPUSH
15876: PPUSH
// Video ( true ) ;
15877: LD_INT 1
15879: PPUSH
15880: CALL 104616 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15884: LD_ADDR_VAR 0 5
15888: PUSH
15889: LD_INT 7
15891: PPUSH
15892: LD_INT 0
15894: PPUSH
15895: CALL_OW 517
15899: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15900: LD_ADDR_VAR 0 2
15904: PUSH
15905: DOUBLE
15906: LD_INT 1
15908: DEC
15909: ST_TO_ADDR
15910: LD_VAR 0 5
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: PUSH
15919: FOR_TO
15920: IFFALSE 15965
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15922: LD_VAR 0 5
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PUSH
15931: LD_VAR 0 2
15935: ARRAY
15936: PPUSH
15937: LD_VAR 0 5
15941: PUSH
15942: LD_INT 2
15944: ARRAY
15945: PUSH
15946: LD_VAR 0 2
15950: ARRAY
15951: PPUSH
15952: LD_INT 1
15954: PPUSH
15955: LD_INT 15
15957: NEG
15958: PPUSH
15959: CALL 104530 0 4
15963: GO 15919
15965: POP
15966: POP
// CenterNowOnUnits ( Powell ) ;
15967: LD_EXP 59
15971: PPUSH
15972: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15976: LD_ADDR_VAR 0 5
15980: PUSH
15981: LD_EXP 57
15985: PUSH
15986: EMPTY
15987: LIST
15988: ST_TO_ADDR
// if GirlNewVeh then
15989: LD_EXP 58
15993: IFFALSE 16011
// tmp := tmp ^ GirlNewVeh ;
15995: LD_ADDR_VAR 0 5
15999: PUSH
16000: LD_VAR 0 5
16004: PUSH
16005: LD_EXP 58
16009: ADD
16010: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
16011: LD_VAR 0 5
16015: PPUSH
16016: LD_INT 60
16018: PPUSH
16019: LD_INT 109
16021: PPUSH
16022: CALL_OW 111
// if KappaStatus then
16026: LD_EXP 2
16030: IFFALSE 16082
// begin Say ( JMM , D1nT-JMM-1 ) ;
16032: LD_EXP 40
16036: PPUSH
16037: LD_STRING D1nT-JMM-1
16039: PPUSH
16040: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16044: LD_EXP 59
16048: PPUSH
16049: LD_STRING D1T-Pow-1
16051: PPUSH
16052: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
16056: LD_EXP 40
16060: PPUSH
16061: LD_STRING D1T-JMM-2
16063: PPUSH
16064: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
16068: LD_EXP 59
16072: PPUSH
16073: LD_STRING D1T-Pow-2
16075: PPUSH
16076: CALL_OW 88
// end else
16080: GO 16288
// if JMMGirlStatus then
16082: LD_EXP 6
16086: IFFALSE 16231
// begin Say ( JMM , D1T-JMM-1 ) ;
16088: LD_EXP 40
16092: PPUSH
16093: LD_STRING D1T-JMM-1
16095: PPUSH
16096: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
16100: LD_EXP 59
16104: PPUSH
16105: LD_STRING D1T-Pow-1
16107: PPUSH
16108: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
16112: LD_EXP 40
16116: PPUSH
16117: LD_STRING D1T-JMM-3
16119: PPUSH
16120: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
16124: LD_EXP 59
16128: PPUSH
16129: LD_STRING D1T-Pow-3
16131: PPUSH
16132: CALL_OW 88
// if JMMGirl then
16136: LD_EXP 7
16140: IFFALSE 16229
// begin case JMMGirl of 1 :
16142: LD_EXP 7
16146: PUSH
16147: LD_INT 1
16149: DOUBLE
16150: EQUAL
16151: IFTRUE 16155
16153: GO 16170
16155: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
16156: LD_EXP 41
16160: PPUSH
16161: LD_STRING D1T-Joan-3
16163: PPUSH
16164: CALL_OW 88
16168: GO 16217
16170: LD_INT 2
16172: DOUBLE
16173: EQUAL
16174: IFTRUE 16178
16176: GO 16193
16178: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
16179: LD_EXP 43
16183: PPUSH
16184: LD_STRING D1T-Lisa-3
16186: PPUSH
16187: CALL_OW 88
16191: GO 16217
16193: LD_INT 3
16195: DOUBLE
16196: EQUAL
16197: IFTRUE 16201
16199: GO 16216
16201: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
16202: LD_EXP 55
16206: PPUSH
16207: LD_STRING D1T-Con-3
16209: PPUSH
16210: CALL_OW 88
16214: GO 16217
16216: POP
// Say ( Powell , D1T-Pow-4 ) ;
16217: LD_EXP 59
16221: PPUSH
16222: LD_STRING D1T-Pow-4
16224: PPUSH
16225: CALL_OW 88
// end ; end else
16229: GO 16288
// if not FastEnd then
16231: LD_EXP 11
16235: NOT
16236: IFFALSE 16264
// begin Say ( JMM , D1T-JMM-4 ) ;
16238: LD_EXP 40
16242: PPUSH
16243: LD_STRING D1T-JMM-4
16245: PPUSH
16246: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
16250: LD_EXP 59
16254: PPUSH
16255: LD_STRING D1T-Pow-5
16257: PPUSH
16258: CALL_OW 88
// end else
16262: GO 16288
// begin Say ( JMM , D1nT-JMM-1 ) ;
16264: LD_EXP 40
16268: PPUSH
16269: LD_STRING D1nT-JMM-1
16271: PPUSH
16272: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
16276: LD_EXP 59
16280: PPUSH
16281: LD_STRING D1nT-Pow-1
16283: PPUSH
16284: CALL_OW 88
// end ; repeat wait ( 3 ) ;
16288: LD_INT 3
16290: PPUSH
16291: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
16295: LD_EXP 57
16299: PPUSH
16300: CALL_OW 314
16304: NOT
16305: IFFALSE 16288
// ComExitVehicle ( JMM ) ;
16307: LD_EXP 40
16311: PPUSH
16312: CALL_OW 121
// repeat wait ( 3 ) ;
16316: LD_INT 3
16318: PPUSH
16319: CALL_OW 67
// until not IsInUnit ( JMM ) ;
16323: LD_EXP 40
16327: PPUSH
16328: CALL_OW 310
16332: NOT
16333: IFFALSE 16316
// ComMoveXY ( JMM , 60 , 94 ) ;
16335: LD_EXP 40
16339: PPUSH
16340: LD_INT 60
16342: PPUSH
16343: LD_INT 94
16345: PPUSH
16346: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16350: LD_EXP 40
16354: PPUSH
16355: LD_EXP 59
16359: PPUSH
16360: CALL_OW 179
// if Joan then
16364: LD_EXP 41
16368: IFFALSE 16422
// begin ComExitVehicle ( Joan ) ;
16370: LD_EXP 41
16374: PPUSH
16375: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
16379: LD_EXP 41
16383: PPUSH
16384: LD_INT 35
16386: PPUSH
16387: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
16391: LD_EXP 41
16395: PPUSH
16396: LD_INT 65
16398: PPUSH
16399: LD_INT 104
16401: PPUSH
16402: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
16406: LD_EXP 41
16410: PPUSH
16411: LD_EXP 40
16415: PPUSH
16416: CALL_OW 179
// end else
16420: GO 16556
// if Lisa and JMMGirl = 2 then
16422: LD_EXP 43
16426: PUSH
16427: LD_EXP 7
16431: PUSH
16432: LD_INT 2
16434: EQUAL
16435: AND
16436: IFFALSE 16490
// begin ComExitVehicle ( Lisa ) ;
16438: LD_EXP 43
16442: PPUSH
16443: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
16447: LD_EXP 43
16451: PPUSH
16452: LD_INT 35
16454: PPUSH
16455: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
16459: LD_EXP 43
16463: PPUSH
16464: LD_INT 65
16466: PPUSH
16467: LD_INT 104
16469: PPUSH
16470: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
16474: LD_EXP 43
16478: PPUSH
16479: LD_EXP 40
16483: PPUSH
16484: CALL_OW 179
// end else
16488: GO 16556
// if Connie and JMMGirl = 3 then
16490: LD_EXP 55
16494: PUSH
16495: LD_EXP 7
16499: PUSH
16500: LD_INT 3
16502: EQUAL
16503: AND
16504: IFFALSE 16556
// begin ComExitVehicle ( Connie ) ;
16506: LD_EXP 55
16510: PPUSH
16511: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
16515: LD_EXP 55
16519: PPUSH
16520: LD_INT 35
16522: PPUSH
16523: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
16527: LD_EXP 55
16531: PPUSH
16532: LD_INT 65
16534: PPUSH
16535: LD_INT 104
16537: PPUSH
16538: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
16542: LD_EXP 55
16546: PPUSH
16547: LD_EXP 40
16551: PPUSH
16552: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
16556: LD_INT 35
16558: PPUSH
16559: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
16563: LD_EXP 40
16567: PPUSH
16568: LD_EXP 59
16572: PPUSH
16573: CALL_OW 296
16577: PUSH
16578: LD_INT 8
16580: LESS
16581: IFFALSE 16556
// wait ( 0 0$0.5 ) ;
16583: LD_INT 18
16585: PPUSH
16586: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
16590: LD_EXP 40
16594: PPUSH
16595: LD_STRING D1-JMM-1
16597: PPUSH
16598: CALL_OW 88
// async ;
16602: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
16603: LD_EXP 59
16607: PPUSH
16608: LD_STRING D1-Pow-1
16610: PPUSH
16611: CALL_OW 88
// if not dialogue_skipped then
16615: LD_OWVAR 59
16619: NOT
16620: IFFALSE 16629
// wait ( 0 0$2 ) ;
16622: LD_INT 70
16624: PPUSH
16625: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
16629: LD_INT 170
16631: PPUSH
16632: LD_INT 99
16634: PPUSH
16635: LD_INT 1
16637: PPUSH
16638: LD_INT 6
16640: NEG
16641: PPUSH
16642: CALL 104530 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
16646: LD_INT 174
16648: PPUSH
16649: LD_INT 115
16651: PPUSH
16652: LD_INT 1
16654: PPUSH
16655: LD_INT 6
16657: NEG
16658: PPUSH
16659: CALL 104530 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
16663: LD_INT 169
16665: PPUSH
16666: LD_INT 71
16668: PPUSH
16669: LD_INT 1
16671: PPUSH
16672: LD_INT 6
16674: NEG
16675: PPUSH
16676: CALL 104530 0 4
// if not dialogue_skipped then
16680: LD_OWVAR 59
16684: NOT
16685: IFFALSE 16704
// begin CenterOnXY ( 170 , 99 ) ;
16687: LD_INT 170
16689: PPUSH
16690: LD_INT 99
16692: PPUSH
16693: CALL_OW 84
// wait ( 0 0$2.3 ) ;
16697: LD_INT 80
16699: PPUSH
16700: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
16704: LD_INT 75
16706: PPUSH
16707: LD_INT 53
16709: PPUSH
16710: LD_INT 1
16712: PPUSH
16713: LD_INT 9
16715: NEG
16716: PPUSH
16717: CALL 104530 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
16721: LD_INT 54
16723: PPUSH
16724: LD_INT 42
16726: PPUSH
16727: LD_INT 1
16729: PPUSH
16730: LD_INT 9
16732: NEG
16733: PPUSH
16734: CALL 104530 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
16738: LD_INT 62
16740: PPUSH
16741: LD_INT 51
16743: PPUSH
16744: LD_INT 1
16746: PPUSH
16747: LD_INT 9
16749: NEG
16750: PPUSH
16751: CALL 104530 0 4
// if not dialogue_skipped then
16755: LD_OWVAR 59
16759: NOT
16760: IFFALSE 16779
// begin CenterOnXY ( 75 , 53 ) ;
16762: LD_INT 75
16764: PPUSH
16765: LD_INT 53
16767: PPUSH
16768: CALL_OW 84
// wait ( 0 0$4 ) ;
16772: LD_INT 140
16774: PPUSH
16775: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
16779: LD_EXP 59
16783: PPUSH
16784: CALL_OW 87
// if not dialogue_skipped then
16788: LD_OWVAR 59
16792: NOT
16793: IFFALSE 16802
// wait ( 0 0$2 ) ;
16795: LD_INT 70
16797: PPUSH
16798: CALL_OW 67
// sync ;
16802: SYNC
// Say ( JMM , D1-JMM-2 ) ;
16803: LD_EXP 40
16807: PPUSH
16808: LD_STRING D1-JMM-2
16810: PPUSH
16811: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16815: LD_EXP 59
16819: PPUSH
16820: LD_STRING D1-Pow-2
16822: PPUSH
16823: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16827: LD_EXP 40
16831: PPUSH
16832: LD_STRING D1-JMM-3
16834: PPUSH
16835: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16839: LD_EXP 59
16843: PPUSH
16844: LD_STRING D1-Pow-3
16846: PPUSH
16847: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16851: LD_EXP 40
16855: PPUSH
16856: LD_STRING D1-JMM-4
16858: PPUSH
16859: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16863: LD_EXP 59
16867: PPUSH
16868: LD_STRING D1-Pow-4
16870: PPUSH
16871: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16875: LD_EXP 40
16879: PPUSH
16880: LD_STRING D1-JMM-5
16882: PPUSH
16883: CALL_OW 88
// async ;
16887: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16888: LD_EXP 59
16892: PPUSH
16893: LD_STRING D1-Pow-5
16895: PPUSH
16896: CALL_OW 88
// if not dialogue_skipped then
16900: LD_OWVAR 59
16904: NOT
16905: IFFALSE 16914
// wait ( 0 0$3.6 ) ;
16907: LD_INT 126
16909: PPUSH
16910: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16914: LD_INT 134
16916: PPUSH
16917: LD_INT 210
16919: PPUSH
16920: LD_INT 1
16922: PPUSH
16923: LD_INT 11
16925: NEG
16926: PPUSH
16927: CALL 104530 0 4
// if not dialogue_skipped then
16931: LD_OWVAR 59
16935: NOT
16936: IFFALSE 16955
// begin CenterOnXY ( 134 , 210 ) ;
16938: LD_INT 134
16940: PPUSH
16941: LD_INT 210
16943: PPUSH
16944: CALL_OW 84
// wait ( 0 0$2 ) ;
16948: LD_INT 70
16950: PPUSH
16951: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16955: LD_INT 101
16957: PPUSH
16958: LD_INT 159
16960: PPUSH
16961: LD_INT 1
16963: PPUSH
16964: LD_INT 10
16966: NEG
16967: PPUSH
16968: CALL 104530 0 4
// if not dialogue_skipped then
16972: LD_OWVAR 59
16976: NOT
16977: IFFALSE 16996
// begin CenterOnXY ( 101 , 159 ) ;
16979: LD_INT 101
16981: PPUSH
16982: LD_INT 159
16984: PPUSH
16985: CALL_OW 84
// wait ( 0 0$2 ) ;
16989: LD_INT 70
16991: PPUSH
16992: CALL_OW 67
// end ; sync ;
16996: SYNC
// CenterNowOnUnits ( Powell ) ;
16997: LD_EXP 59
17001: PPUSH
17002: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
17006: LD_ADDR_VAR 0 6
17010: PUSH
17011: LD_INT 1
17013: PUSH
17014: LD_INT 2
17016: PUSH
17017: LD_INT 3
17019: PUSH
17020: LD_INT 4
17022: PUSH
17023: LD_INT 5
17025: PUSH
17026: LD_INT 6
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: LIST
17036: ST_TO_ADDR
// if not dialogue_skipped then
17037: LD_OWVAR 59
17041: NOT
17042: IFFALSE 17211
// begin game_speed := 4 ;
17044: LD_ADDR_OWVAR 65
17048: PUSH
17049: LD_INT 4
17051: ST_TO_ADDR
// wait ( 0 0$6 ) ;
17052: LD_INT 210
17054: PPUSH
17055: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
17059: LD_ADDR_VAR 0 7
17063: PUSH
17064: LD_STRING Q1
17066: PPUSH
17067: LD_VAR 0 6
17071: PPUSH
17072: CALL_OW 98
17076: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
17077: LD_ADDR_VAR 0 7
17081: PUSH
17082: LD_STRING Q1
17084: PPUSH
17085: LD_VAR 0 6
17089: PPUSH
17090: CALL_OW 98
17094: ST_TO_ADDR
// options := options diff dec ;
17095: LD_ADDR_VAR 0 6
17099: PUSH
17100: LD_VAR 0 6
17104: PUSH
17105: LD_VAR 0 7
17109: DIFF
17110: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
17111: LD_VAR 0 7
17115: PPUSH
17116: LD_VAR 0 6
17120: PPUSH
17121: CALL 18727 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
17125: LD_VAR 0 7
17129: PUSH
17130: LD_INT 5
17132: PUSH
17133: LD_INT 6
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: IN
17140: PUSH
17141: LD_VAR 0 6
17145: PUSH
17146: LD_INT 2
17148: EQUAL
17149: OR
17150: IFFALSE 17077
// if not ( dec in [ 5 , 6 ] ) then
17152: LD_VAR 0 7
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: IN
17167: NOT
17168: IFFALSE 17211
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
17170: LD_ADDR_VAR 0 7
17174: PUSH
17175: LD_STRING Q1a
17177: PPUSH
17178: LD_INT 1
17180: PUSH
17181: LD_INT 2
17183: PUSH
17184: EMPTY
17185: LIST
17186: LIST
17187: PPUSH
17188: CALL_OW 98
17192: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
17193: LD_VAR 0 7
17197: PUSH
17198: LD_INT 4
17200: PLUS
17201: PPUSH
17202: LD_VAR 0 6
17206: PPUSH
17207: CALL 18727 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
17211: LD_INT 81
17213: PPUSH
17214: LD_INT 127
17216: PPUSH
17217: CALL_OW 84
// amount := 8 ;
17221: LD_ADDR_VAR 0 8
17225: PUSH
17226: LD_INT 8
17228: ST_TO_ADDR
// macmilan_squad := [ ] ;
17229: LD_ADDR_VAR 0 9
17233: PUSH
17234: EMPTY
17235: ST_TO_ADDR
// if vip < amount then
17236: LD_EXP 60
17240: PUSH
17241: LD_VAR 0 8
17245: LESS
17246: IFFALSE 17290
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
17248: LD_ADDR_VAR 0 5
17252: PUSH
17253: LD_EXP 60
17257: PUSH
17258: LD_INT 22
17260: PUSH
17261: LD_INT 4
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: PUSH
17268: LD_INT 21
17270: PUSH
17271: LD_INT 1
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: PPUSH
17282: CALL_OW 69
17286: UNION
17287: ST_TO_ADDR
17288: GO 17300
// tmp := vip ;
17290: LD_ADDR_VAR 0 5
17294: PUSH
17295: LD_EXP 60
17299: ST_TO_ADDR
// tmp := tmp diff Powell ;
17300: LD_ADDR_VAR 0 5
17304: PUSH
17305: LD_VAR 0 5
17309: PUSH
17310: LD_EXP 59
17314: DIFF
17315: ST_TO_ADDR
// if tmp < amount then
17316: LD_VAR 0 5
17320: PUSH
17321: LD_VAR 0 8
17325: LESS
17326: IFFALSE 17338
// amount := tmp ;
17328: LD_ADDR_VAR 0 8
17332: PUSH
17333: LD_VAR 0 5
17337: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
17338: LD_VAR 0 5
17342: PUSH
17343: LD_INT 1
17345: ARRAY
17346: PPUSH
17347: CALL_OW 257
17351: PUSH
17352: LD_INT 2
17354: NONEQUAL
17355: IFFALSE 17453
// begin if IsInUnit ( tmp [ 1 ] ) then
17357: LD_VAR 0 5
17361: PUSH
17362: LD_INT 1
17364: ARRAY
17365: PPUSH
17366: CALL_OW 310
17370: IFFALSE 17385
// ComExitBuilding ( tmp [ 1 ] ) ;
17372: LD_VAR 0 5
17376: PUSH
17377: LD_INT 1
17379: ARRAY
17380: PPUSH
17381: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
17385: LD_INT 387
17387: PPUSH
17388: CALL_OW 313
17392: PUSH
17393: LD_INT 6
17395: EQUAL
17396: IFFALSE 17421
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
17398: LD_INT 387
17400: PPUSH
17401: CALL_OW 313
17405: PUSH
17406: LD_INT 1
17408: ARRAY
17409: PPUSH
17410: CALL_OW 122
// wait ( 3 ) ;
17414: LD_INT 3
17416: PPUSH
17417: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
17421: LD_VAR 0 5
17425: PUSH
17426: LD_INT 1
17428: ARRAY
17429: PPUSH
17430: LD_INT 387
17432: PPUSH
17433: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
17437: LD_VAR 0 5
17441: PUSH
17442: LD_INT 1
17444: ARRAY
17445: PPUSH
17446: LD_INT 2
17448: PPUSH
17449: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
17453: LD_EXP 40
17457: PPUSH
17458: LD_INT 82
17460: PPUSH
17461: LD_INT 129
17463: PPUSH
17464: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17468: LD_EXP 40
17472: PPUSH
17473: LD_EXP 59
17477: PPUSH
17478: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
17482: LD_INT 22
17484: PUSH
17485: LD_INT 1
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 69
17496: PUSH
17497: LD_EXP 40
17501: DIFF
17502: PPUSH
17503: LD_INT 84
17505: PPUSH
17506: LD_INT 128
17508: PPUSH
17509: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
17513: LD_INT 22
17515: PUSH
17516: LD_INT 1
17518: PUSH
17519: EMPTY
17520: LIST
17521: LIST
17522: PPUSH
17523: CALL_OW 69
17527: PUSH
17528: LD_EXP 40
17532: DIFF
17533: PPUSH
17534: LD_EXP 40
17538: PPUSH
17539: CALL_OW 179
// for i = 1 to amount do
17543: LD_ADDR_VAR 0 2
17547: PUSH
17548: DOUBLE
17549: LD_INT 1
17551: DEC
17552: ST_TO_ADDR
17553: LD_VAR 0 8
17557: PUSH
17558: FOR_TO
17559: IFFALSE 17727
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
17561: LD_ADDR_VAR 0 9
17565: PUSH
17566: LD_VAR 0 9
17570: PUSH
17571: LD_VAR 0 5
17575: PUSH
17576: LD_VAR 0 2
17580: ARRAY
17581: ADD
17582: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
17583: LD_VAR 0 5
17587: PUSH
17588: LD_VAR 0 2
17592: ARRAY
17593: PPUSH
17594: CALL_OW 310
17598: IFFALSE 17615
// AddComExitBuilding ( tmp [ i ] ) ;
17600: LD_VAR 0 5
17604: PUSH
17605: LD_VAR 0 2
17609: ARRAY
17610: PPUSH
17611: CALL_OW 182
// if i = 2 and JMMNewVeh then
17615: LD_VAR 0 2
17619: PUSH
17620: LD_INT 2
17622: EQUAL
17623: PUSH
17624: LD_EXP 57
17628: AND
17629: IFFALSE 17687
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
17631: LD_VAR 0 5
17635: PUSH
17636: LD_VAR 0 2
17640: ARRAY
17641: PPUSH
17642: LD_EXP 57
17646: PPUSH
17647: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
17651: LD_VAR 0 5
17655: PUSH
17656: LD_VAR 0 2
17660: ARRAY
17661: PPUSH
17662: LD_INT 86
17664: PPUSH
17665: LD_INT 133
17667: PPUSH
17668: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
17672: LD_VAR 0 5
17676: PUSH
17677: LD_VAR 0 2
17681: ARRAY
17682: PPUSH
17683: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
17687: LD_VAR 0 5
17691: PUSH
17692: LD_VAR 0 2
17696: ARRAY
17697: PPUSH
17698: LD_INT 8
17700: PPUSH
17701: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
17705: LD_VAR 0 5
17709: PUSH
17710: LD_VAR 0 2
17714: ARRAY
17715: PPUSH
17716: LD_EXP 40
17720: PPUSH
17721: CALL_OW 179
// end ;
17725: GO 17558
17727: POP
17728: POP
// if GirlNewVeh then
17729: LD_EXP 58
17733: IFFALSE 17747
// SetSide ( GirlNewVeh , 4 ) ;
17735: LD_EXP 58
17739: PPUSH
17740: LD_INT 4
17742: PPUSH
17743: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
17747: LD_INT 35
17749: PPUSH
17750: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
17754: LD_VAR 0 9
17758: PPUSH
17759: LD_INT 95
17761: PUSH
17762: LD_INT 9
17764: PUSH
17765: EMPTY
17766: LIST
17767: LIST
17768: PPUSH
17769: CALL_OW 72
17773: PUSH
17774: LD_INT 0
17776: EQUAL
17777: PUSH
17778: LD_EXP 40
17782: PPUSH
17783: LD_INT 9
17785: PPUSH
17786: CALL_OW 308
17790: NOT
17791: AND
17792: IFFALSE 17747
// wait ( 0 0$2 ) ;
17794: LD_INT 70
17796: PPUSH
17797: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
17801: LD_VAR 0 9
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
17813: LD_INT 21
17815: PUSH
17816: LD_INT 2
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: PUSH
17823: LD_INT 92
17825: PUSH
17826: LD_INT 83
17828: PUSH
17829: LD_INT 130
17831: PUSH
17832: LD_INT 10
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: LIST
17839: LIST
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: PPUSH
17845: CALL_OW 69
17849: PPUSH
17850: LD_INT 1
17852: PPUSH
17853: CALL_OW 235
// tick := 0 ;
17857: LD_ADDR_OWVAR 1
17861: PUSH
17862: LD_INT 0
17864: ST_TO_ADDR
// Video ( false ) ;
17865: LD_INT 0
17867: PPUSH
17868: CALL 104616 0 1
// ChangeMissionObjectives ( M1 ) ;
17872: LD_STRING M1
17874: PPUSH
17875: CALL_OW 337
// SaveForQuickRestart ;
17879: CALL_OW 22
// missionStart := true ;
17883: LD_ADDR_EXP 13
17887: PUSH
17888: LD_INT 1
17890: ST_TO_ADDR
// missionStage := 2 ;
17891: LD_ADDR_EXP 15
17895: PUSH
17896: LD_INT 2
17898: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17899: LD_INT 35
17901: PPUSH
17902: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17906: LD_ADDR_VAR 0 5
17910: PUSH
17911: LD_INT 22
17913: PUSH
17914: LD_INT 4
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: PUSH
17921: LD_INT 21
17923: PUSH
17924: LD_INT 1
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: PPUSH
17935: CALL_OW 69
17939: PUSH
17940: LD_EXP 59
17944: DIFF
17945: ST_TO_ADDR
// if not tmp then
17946: LD_VAR 0 5
17950: NOT
17951: IFFALSE 17966
// tmp := [ Powell ] ;
17953: LD_ADDR_VAR 0 5
17957: PUSH
17958: LD_EXP 59
17962: PUSH
17963: EMPTY
17964: LIST
17965: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17966: LD_ADDR_VAR 0 4
17970: PUSH
17971: LD_INT 22
17973: PUSH
17974: LD_INT 4
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: LD_INT 34
17983: PUSH
17984: LD_INT 12
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PPUSH
17995: CALL_OW 69
17999: PUSH
18000: LD_INT 1
18002: ARRAY
18003: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
18004: LD_VAR 0 5
18008: PUSH
18009: LD_INT 1
18011: ARRAY
18012: PPUSH
18013: CALL_OW 310
18017: IFFALSE 18032
// ComExitBuilding ( tmp [ 1 ] ) ;
18019: LD_VAR 0 5
18023: PUSH
18024: LD_INT 1
18026: ARRAY
18027: PPUSH
18028: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
18032: LD_VAR 0 5
18036: PUSH
18037: LD_INT 1
18039: ARRAY
18040: PPUSH
18041: LD_VAR 0 4
18045: PPUSH
18046: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
18050: LD_VAR 0 5
18054: PUSH
18055: LD_INT 1
18057: ARRAY
18058: PPUSH
18059: LD_INT 80
18061: PPUSH
18062: LD_INT 136
18064: PPUSH
18065: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
18069: LD_VAR 0 5
18073: PUSH
18074: LD_INT 1
18076: ARRAY
18077: PPUSH
18078: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
18082: LD_VAR 0 5
18086: PUSH
18087: LD_INT 1
18089: ARRAY
18090: PPUSH
18091: LD_INT 59
18093: PPUSH
18094: LD_INT 112
18096: PPUSH
18097: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
18101: LD_VAR 0 5
18105: PUSH
18106: LD_INT 1
18108: ARRAY
18109: PPUSH
18110: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
18114: LD_EXP 41
18118: PUSH
18119: LD_EXP 41
18123: PPUSH
18124: CALL_OW 255
18128: PUSH
18129: LD_INT 1
18131: EQUAL
18132: AND
18133: IFFALSE 18159
// begin Say ( Joan , D3W-Joan-1 ) ;
18135: LD_EXP 41
18139: PPUSH
18140: LD_STRING D3W-Joan-1
18142: PPUSH
18143: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18147: LD_EXP 40
18151: PPUSH
18152: LD_STRING D3W-JMM-1
18154: PPUSH
18155: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
18159: LD_EXP 43
18163: PUSH
18164: LD_EXP 43
18168: PPUSH
18169: CALL_OW 255
18173: PUSH
18174: LD_INT 1
18176: EQUAL
18177: AND
18178: PUSH
18179: LD_EXP 43
18183: PUSH
18184: LD_EXP 60
18188: IN
18189: NOT
18190: AND
18191: IFFALSE 18217
// begin Say ( Lisa , D3W-Lisa-1 ) ;
18193: LD_EXP 43
18197: PPUSH
18198: LD_STRING D3W-Lisa-1
18200: PPUSH
18201: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18205: LD_EXP 40
18209: PPUSH
18210: LD_STRING D3W-JMM-1
18212: PPUSH
18213: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
18217: LD_EXP 55
18221: PUSH
18222: LD_EXP 55
18226: PPUSH
18227: CALL_OW 255
18231: PUSH
18232: LD_INT 1
18234: EQUAL
18235: AND
18236: IFFALSE 18262
// begin Say ( Connie , D3W-Con-1 ) ;
18238: LD_EXP 55
18242: PPUSH
18243: LD_STRING D3W-Con-1
18245: PPUSH
18246: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
18250: LD_EXP 40
18254: PPUSH
18255: LD_STRING D3W-JMM-1
18257: PPUSH
18258: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
18262: LD_EXP 43
18266: PUSH
18267: LD_EXP 60
18271: IN
18272: PUSH
18273: LD_EXP 43
18277: PPUSH
18278: CALL_OW 255
18282: PUSH
18283: LD_INT 1
18285: EQUAL
18286: AND
18287: IFFALSE 18303
// Say ( Lisa , D3nW-Lisa-1 ) else
18289: LD_EXP 43
18293: PPUSH
18294: LD_STRING D3nW-Lisa-1
18296: PPUSH
18297: CALL_OW 88
18301: GO 18547
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
18303: LD_EXP 46
18307: PUSH
18308: LD_EXP 60
18312: IN
18313: PUSH
18314: LD_EXP 46
18318: PPUSH
18319: CALL_OW 255
18323: PUSH
18324: LD_INT 1
18326: EQUAL
18327: AND
18328: IFFALSE 18344
// Say ( Cyrus , D3nW-Cyrus-1 ) else
18330: LD_EXP 46
18334: PPUSH
18335: LD_STRING D3nW-Cyrus-1
18337: PPUSH
18338: CALL_OW 88
18342: GO 18547
// if Bobby in vip and GetSide ( Bobby ) = 1 then
18344: LD_EXP 45
18348: PUSH
18349: LD_EXP 60
18353: IN
18354: PUSH
18355: LD_EXP 45
18359: PPUSH
18360: CALL_OW 255
18364: PUSH
18365: LD_INT 1
18367: EQUAL
18368: AND
18369: IFFALSE 18385
// Say ( Bobby , D3nW-Bobby-1 ) else
18371: LD_EXP 45
18375: PPUSH
18376: LD_STRING D3nW-Bobby-1
18378: PPUSH
18379: CALL_OW 88
18383: GO 18547
// if Gary in vip and GetSide ( Gary ) = 1 then
18385: LD_EXP 52
18389: PUSH
18390: LD_EXP 60
18394: IN
18395: PUSH
18396: LD_EXP 52
18400: PPUSH
18401: CALL_OW 255
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: AND
18410: IFFALSE 18426
// Say ( Gary , D3nW-Gary-1 ) else
18412: LD_EXP 52
18416: PPUSH
18417: LD_STRING D3nW-Gary-1
18419: PPUSH
18420: CALL_OW 88
18424: GO 18547
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
18426: LD_EXP 44
18430: PUSH
18431: LD_EXP 60
18435: IN
18436: PUSH
18437: LD_EXP 44
18441: PPUSH
18442: CALL_OW 255
18446: PUSH
18447: LD_INT 1
18449: EQUAL
18450: AND
18451: IFFALSE 18467
// Say ( Donaldson , D3nW-Don-1 ) else
18453: LD_EXP 44
18457: PPUSH
18458: LD_STRING D3nW-Don-1
18460: PPUSH
18461: CALL_OW 88
18465: GO 18547
// if Cornel in vip and GetSide ( Cornel ) = 1 then
18467: LD_EXP 51
18471: PUSH
18472: LD_EXP 60
18476: IN
18477: PUSH
18478: LD_EXP 51
18482: PPUSH
18483: CALL_OW 255
18487: PUSH
18488: LD_INT 1
18490: EQUAL
18491: AND
18492: IFFALSE 18508
// Say ( Cornel , D3nW-Corn-1 ) else
18494: LD_EXP 51
18498: PPUSH
18499: LD_STRING D3nW-Corn-1
18501: PPUSH
18502: CALL_OW 88
18506: GO 18547
// if Frank in vip and GetSide ( Frank ) = 1 then
18508: LD_EXP 53
18512: PUSH
18513: LD_EXP 60
18517: IN
18518: PUSH
18519: LD_EXP 53
18523: PPUSH
18524: CALL_OW 255
18528: PUSH
18529: LD_INT 1
18531: EQUAL
18532: AND
18533: IFFALSE 18547
// Say ( Frank , D3nW-Frank-1 ) ;
18535: LD_EXP 53
18539: PPUSH
18540: LD_STRING D3nW-Frank-1
18542: PPUSH
18543: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
18547: LD_EXP 60
18551: PPUSH
18552: LD_INT 22
18554: PUSH
18555: LD_INT 1
18557: PUSH
18558: EMPTY
18559: LIST
18560: LIST
18561: PPUSH
18562: CALL_OW 72
18566: IFFALSE 18592
// begin Say ( JMM , D3nW-JMM-1 ) ;
18568: LD_EXP 40
18572: PPUSH
18573: LD_STRING D3nW-JMM-1
18575: PPUSH
18576: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
18580: LD_EXP 40
18584: PPUSH
18585: LD_STRING D3nW-JMM-1a
18587: PPUSH
18588: CALL_OW 88
// end ; t := 0 0$00 ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_INT 0
18599: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18600: LD_INT 35
18602: PPUSH
18603: CALL_OW 67
// t := t + 0 0$1 ;
18607: LD_ADDR_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: PUSH
18617: LD_INT 35
18619: PLUS
18620: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
18621: LD_INT 59
18623: PPUSH
18624: LD_INT 112
18626: PPUSH
18627: CALL_OW 428
18631: PUSH
18632: LD_VAR 0 3
18636: PUSH
18637: LD_INT 2100
18639: GREATER
18640: OR
18641: IFFALSE 18600
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
18643: LD_ADDR_EXP 99
18647: PUSH
18648: LD_EXP 99
18652: PPUSH
18653: LD_INT 4
18655: PPUSH
18656: LD_INT 22
18658: PUSH
18659: LD_INT 4
18661: PUSH
18662: EMPTY
18663: LIST
18664: LIST
18665: PUSH
18666: LD_INT 23
18668: PUSH
18669: LD_INT 1
18671: PUSH
18672: EMPTY
18673: LIST
18674: LIST
18675: PUSH
18676: LD_INT 3
18678: PUSH
18679: LD_INT 21
18681: PUSH
18682: LD_INT 2
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: LIST
18697: PPUSH
18698: CALL_OW 69
18702: PUSH
18703: LD_EXP 59
18707: DIFF
18708: PPUSH
18709: CALL_OW 1
18713: ST_TO_ADDR
// activeAttacks := true ;
18714: LD_ADDR_EXP 16
18718: PUSH
18719: LD_INT 1
18721: ST_TO_ADDR
// end ;
18722: LD_VAR 0 1
18726: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
18727: LD_INT 0
18729: PPUSH
// case question of 1 :
18730: LD_VAR 0 1
18734: PUSH
18735: LD_INT 1
18737: DOUBLE
18738: EQUAL
18739: IFTRUE 18743
18741: GO 18794
18743: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
18744: LD_EXP 40
18748: PPUSH
18749: LD_STRING D2Mot-JMM-1
18751: PPUSH
18752: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
18756: LD_EXP 59
18760: PPUSH
18761: LD_STRING D2Mot-Pow-1
18763: PPUSH
18764: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
18768: LD_EXP 40
18772: PPUSH
18773: LD_STRING D2Mot-JMM-2
18775: PPUSH
18776: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
18780: LD_EXP 59
18784: PPUSH
18785: LD_STRING D2Mot-Pow-2
18787: PPUSH
18788: CALL_OW 88
// end ; 2 :
18792: GO 19145
18794: LD_INT 2
18796: DOUBLE
18797: EQUAL
18798: IFTRUE 18802
18800: GO 18878
18802: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
18803: LD_EXP 40
18807: PPUSH
18808: LD_STRING D2Rus-JMM-1
18810: PPUSH
18811: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
18815: LD_EXP 59
18819: PPUSH
18820: LD_STRING D2Rus-Pow-1
18822: PPUSH
18823: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
18827: LD_EXP 40
18831: PPUSH
18832: LD_STRING D2Rus-JMM-2
18834: PPUSH
18835: CALL_OW 88
// if not ( 3 in list_of_q ) then
18839: LD_INT 3
18841: PUSH
18842: LD_VAR 0 2
18846: IN
18847: NOT
18848: IFFALSE 18864
// Say ( Powell , D2Rus-Pow-2 ) else
18850: LD_EXP 59
18854: PPUSH
18855: LD_STRING D2Rus-Pow-2
18857: PPUSH
18858: CALL_OW 88
18862: GO 18876
// Say ( Powell , D2Rus-Pow-2a ) ;
18864: LD_EXP 59
18868: PPUSH
18869: LD_STRING D2Rus-Pow-2a
18871: PPUSH
18872: CALL_OW 88
// end ; 3 :
18876: GO 19145
18878: LD_INT 3
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18971
18886: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18887: LD_EXP 40
18891: PPUSH
18892: LD_STRING D2Leg-JMM-1
18894: PPUSH
18895: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18899: LD_EXP 59
18903: PPUSH
18904: LD_STRING D2Leg-Pow-1
18906: PPUSH
18907: CALL_OW 88
// if 2 in list_of_q then
18911: LD_INT 2
18913: PUSH
18914: LD_VAR 0 2
18918: IN
18919: IFFALSE 18945
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18921: LD_EXP 40
18925: PPUSH
18926: LD_STRING D2Leg-JMM-2
18928: PPUSH
18929: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18933: LD_EXP 59
18937: PPUSH
18938: LD_STRING D2Leg-Pow-2
18940: PPUSH
18941: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18945: LD_EXP 40
18949: PPUSH
18950: LD_STRING D2Leg-JMM-3
18952: PPUSH
18953: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18957: LD_EXP 59
18961: PPUSH
18962: LD_STRING D2Leg-Pow-3
18964: PPUSH
18965: CALL_OW 88
// end ; 4 :
18969: GO 19145
18971: LD_INT 4
18973: DOUBLE
18974: EQUAL
18975: IFTRUE 18979
18977: GO 19054
18979: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18980: LD_EXP 40
18984: PPUSH
18985: LD_STRING D2Ar-JMM-1
18987: PPUSH
18988: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18992: LD_EXP 59
18996: PPUSH
18997: LD_STRING D2Ar-Pow-1
18999: PPUSH
19000: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
19004: LD_EXP 40
19008: PPUSH
19009: LD_STRING D2Ar-JMM-2
19011: PPUSH
19012: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
19016: LD_EXP 59
19020: PPUSH
19021: LD_STRING D2Ar-Pow-2
19023: PPUSH
19024: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
19028: LD_EXP 40
19032: PPUSH
19033: LD_STRING D2Ar-JMM-3
19035: PPUSH
19036: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
19040: LD_EXP 59
19044: PPUSH
19045: LD_STRING D2Ar-Pow-3
19047: PPUSH
19048: CALL_OW 88
// end ; 5 :
19052: GO 19145
19054: LD_INT 5
19056: DOUBLE
19057: EQUAL
19058: IFTRUE 19062
19060: GO 19077
19062: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
19063: LD_EXP 40
19067: PPUSH
19068: LD_STRING D2Conf-JMM-1
19070: PPUSH
19071: CALL_OW 88
19075: GO 19145
19077: LD_INT 6
19079: DOUBLE
19080: EQUAL
19081: IFTRUE 19085
19083: GO 19144
19085: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
19086: LD_EXP 40
19090: PPUSH
19091: LD_STRING D2Com-JMM-1
19093: PPUSH
19094: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
19098: LD_EXP 59
19102: PPUSH
19103: LD_STRING D2Com-Pow-1
19105: PPUSH
19106: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
19110: LD_EXP 40
19114: PPUSH
19115: LD_STRING D2Com-JMM-2
19117: PPUSH
19118: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
19122: LD_EXP 59
19126: PPUSH
19127: LD_STRING D2Com-Pow-2
19129: PPUSH
19130: CALL_OW 88
// powellAngerQuery := true ;
19134: LD_ADDR_EXP 36
19138: PUSH
19139: LD_INT 1
19141: ST_TO_ADDR
// end ; end ;
19142: GO 19145
19144: POP
// end ;
19145: LD_VAR 0 3
19149: RET
// every 0 0$5 trigger missionStart do var tmp ;
19150: LD_EXP 13
19154: IFFALSE 19437
19156: GO 19158
19158: DISABLE
19159: LD_INT 0
19161: PPUSH
// begin repeat wait ( 0 0$1 ) ;
19162: LD_INT 35
19164: PPUSH
19165: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
19169: LD_INT 14
19171: PPUSH
19172: LD_INT 22
19174: PUSH
19175: LD_INT 1
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: CALL_OW 70
19186: PUSH
19187: LD_EXP 15
19191: PUSH
19192: LD_INT 2
19194: PUSH
19195: LD_INT 3
19197: PUSH
19198: LD_INT 4
19200: PUSH
19201: LD_INT 5
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: LIST
19208: LIST
19209: IN
19210: AND
19211: IFFALSE 19427
// begin powellAnger := powellAnger + 1 ;
19213: LD_ADDR_EXP 17
19217: PUSH
19218: LD_EXP 17
19222: PUSH
19223: LD_INT 1
19225: PLUS
19226: ST_TO_ADDR
// Video ( true ) ;
19227: LD_INT 1
19229: PPUSH
19230: CALL 104616 0 1
// CenterNowOnUnits ( tmp ) ;
19234: LD_VAR 0 1
19238: PPUSH
19239: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19243: LD_INT 14
19245: PPUSH
19246: LD_INT 22
19248: PUSH
19249: LD_INT 1
19251: PUSH
19252: EMPTY
19253: LIST
19254: LIST
19255: PPUSH
19256: CALL_OW 70
19260: PPUSH
19261: LD_INT 86
19263: PPUSH
19264: LD_INT 133
19266: PPUSH
19267: CALL_OW 111
// async ;
19271: ASYNC
// case powellAnger of 1 :
19272: LD_EXP 17
19276: PUSH
19277: LD_INT 1
19279: DOUBLE
19280: EQUAL
19281: IFTRUE 19285
19283: GO 19300
19285: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
19286: LD_EXP 59
19290: PPUSH
19291: LD_STRING DBack1-Pow-1
19293: PPUSH
19294: CALL_OW 88
19298: GO 19347
19300: LD_INT 2
19302: DOUBLE
19303: EQUAL
19304: IFTRUE 19308
19306: GO 19323
19308: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
19309: LD_EXP 59
19313: PPUSH
19314: LD_STRING DBack2-Pow-1
19316: PPUSH
19317: CALL_OW 88
19321: GO 19347
19323: LD_INT 3
19325: DOUBLE
19326: EQUAL
19327: IFTRUE 19331
19329: GO 19346
19331: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
19332: LD_EXP 59
19336: PPUSH
19337: LD_STRING DBack3-Pow-1
19339: PPUSH
19340: CALL_OW 88
19344: GO 19347
19346: POP
// sync ;
19347: SYNC
// repeat wait ( 0 0$1 ) ;
19348: LD_INT 35
19350: PPUSH
19351: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
19355: LD_INT 14
19357: PPUSH
19358: LD_INT 22
19360: PUSH
19361: LD_INT 1
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: PPUSH
19368: CALL_OW 70
19372: PPUSH
19373: LD_INT 86
19375: PPUSH
19376: LD_INT 133
19378: PPUSH
19379: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
19383: LD_INT 14
19385: PPUSH
19386: LD_INT 22
19388: PUSH
19389: LD_INT 1
19391: PUSH
19392: EMPTY
19393: LIST
19394: LIST
19395: PPUSH
19396: CALL_OW 70
19400: NOT
19401: IFFALSE 19348
// if powellAnger >= 3 then
19403: LD_EXP 17
19407: PUSH
19408: LD_INT 3
19410: GREATEREQUAL
19411: IFFALSE 19420
// YouLost ( Dismissed ) ;
19413: LD_STRING Dismissed
19415: PPUSH
19416: CALL_OW 104
// Video ( false ) ;
19420: LD_INT 0
19422: PPUSH
19423: CALL 104616 0 1
// end ; until missionStage > 5 ;
19427: LD_EXP 15
19431: PUSH
19432: LD_INT 5
19434: GREATER
19435: IFFALSE 19162
// end ;
19437: PPOPN 1
19439: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
19440: LD_EXP 13
19444: PUSH
19445: LD_INT 22
19447: PUSH
19448: LD_INT 4
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 21
19457: PUSH
19458: LD_INT 2
19460: PUSH
19461: EMPTY
19462: LIST
19463: LIST
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: PPUSH
19469: CALL_OW 69
19473: PUSH
19474: LD_INT 4
19476: GREATEREQUAL
19477: AND
19478: PUSH
19479: LD_EXP 15
19483: PUSH
19484: LD_INT 2
19486: EQUAL
19487: AND
19488: IFFALSE 21678
19490: GO 19492
19492: DISABLE
19493: LD_INT 0
19495: PPUSH
19496: PPUSH
19497: PPUSH
19498: PPUSH
19499: PPUSH
19500: PPUSH
19501: PPUSH
19502: PPUSH
19503: PPUSH
19504: PPUSH
// begin missionStage := 3 ;
19505: LD_ADDR_EXP 15
19509: PUSH
19510: LD_INT 3
19512: ST_TO_ADDR
// retreat := false ;
19513: LD_ADDR_VAR 0 4
19517: PUSH
19518: LD_INT 0
19520: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
19521: LD_ADDR_VAR 0 5
19525: PUSH
19526: LD_INT 22
19528: PUSH
19529: LD_INT 4
19531: PUSH
19532: EMPTY
19533: LIST
19534: LIST
19535: PUSH
19536: LD_INT 30
19538: PUSH
19539: LD_INT 4
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 69
19554: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19555: LD_ADDR_VAR 0 6
19559: PUSH
19560: LD_INT 22
19562: PUSH
19563: LD_INT 4
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: PUSH
19570: LD_INT 30
19572: PUSH
19573: LD_INT 5
19575: PUSH
19576: EMPTY
19577: LIST
19578: LIST
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PPUSH
19584: CALL_OW 69
19588: ST_TO_ADDR
// if not bar then
19589: LD_VAR 0 6
19593: NOT
19594: IFFALSE 19647
// begin repeat wait ( 0 0$1 ) ;
19596: LD_INT 35
19598: PPUSH
19599: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
19603: LD_INT 22
19605: PUSH
19606: LD_INT 4
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PUSH
19613: LD_INT 3
19615: PUSH
19616: LD_INT 57
19618: PUSH
19619: EMPTY
19620: LIST
19621: PUSH
19622: EMPTY
19623: LIST
19624: LIST
19625: PUSH
19626: LD_INT 30
19628: PUSH
19629: LD_INT 5
19631: PUSH
19632: EMPTY
19633: LIST
19634: LIST
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: LIST
19640: PPUSH
19641: CALL_OW 69
19645: IFFALSE 19596
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
19647: LD_ADDR_VAR 0 6
19651: PUSH
19652: LD_INT 22
19654: PUSH
19655: LD_INT 4
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: PUSH
19662: LD_INT 30
19664: PUSH
19665: LD_INT 5
19667: PUSH
19668: EMPTY
19669: LIST
19670: LIST
19671: PUSH
19672: EMPTY
19673: LIST
19674: LIST
19675: PPUSH
19676: CALL_OW 69
19680: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19681: LD_INT 35
19683: PPUSH
19684: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
19688: LD_EXP 118
19692: PUSH
19693: LD_INT 4
19695: ARRAY
19696: PUSH
19697: LD_INT 4
19699: GREATEREQUAL
19700: IFFALSE 19681
// tmp := [ ] ;
19702: LD_ADDR_VAR 0 2
19706: PUSH
19707: EMPTY
19708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
19709: LD_ADDR_VAR 0 1
19713: PUSH
19714: LD_INT 22
19716: PUSH
19717: LD_INT 4
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: LD_INT 2
19726: PUSH
19727: LD_INT 25
19729: PUSH
19730: LD_INT 1
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: PUSH
19737: LD_INT 25
19739: PUSH
19740: LD_INT 2
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: PUSH
19747: LD_INT 25
19749: PUSH
19750: LD_INT 3
19752: PUSH
19753: EMPTY
19754: LIST
19755: LIST
19756: PUSH
19757: LD_INT 25
19759: PUSH
19760: LD_INT 4
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PUSH
19767: LD_INT 25
19769: PUSH
19770: LD_INT 5
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: LIST
19784: PUSH
19785: EMPTY
19786: LIST
19787: LIST
19788: PPUSH
19789: CALL_OW 69
19793: PUSH
19794: LD_EXP 59
19798: PUSH
19799: LD_EXP 60
19803: ADD
19804: DIFF
19805: PUSH
19806: FOR_IN
19807: IFFALSE 19871
// if GetTag ( i ) = 1 then
19809: LD_VAR 0 1
19813: PPUSH
19814: CALL_OW 110
19818: PUSH
19819: LD_INT 1
19821: EQUAL
19822: IFFALSE 19846
// tmp := Join ( tmp , i ) else
19824: LD_ADDR_VAR 0 2
19828: PUSH
19829: LD_VAR 0 2
19833: PPUSH
19834: LD_VAR 0 1
19838: PPUSH
19839: CALL 104644 0 2
19843: ST_TO_ADDR
19844: GO 19869
// tmp := Insert ( tmp , 1 , i ) ;
19846: LD_ADDR_VAR 0 2
19850: PUSH
19851: LD_VAR 0 2
19855: PPUSH
19856: LD_INT 1
19858: PPUSH
19859: LD_VAR 0 1
19863: PPUSH
19864: CALL_OW 2
19868: ST_TO_ADDR
19869: GO 19806
19871: POP
19872: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
19873: LD_ADDR_VAR 0 3
19877: PUSH
19878: LD_VAR 0 2
19882: PPUSH
19883: LD_INT 26
19885: PUSH
19886: LD_INT 1
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: PPUSH
19893: CALL_OW 72
19897: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
19898: LD_ADDR_VAR 0 2
19902: PUSH
19903: LD_VAR 0 2
19907: PUSH
19908: LD_VAR 0 3
19912: DIFF
19913: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
19914: LD_ADDR_VAR 0 2
19918: PUSH
19919: LD_VAR 0 2
19923: PPUSH
19924: LD_INT 3
19926: PPUSH
19927: CALL 103153 0 2
19931: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
19932: LD_ADDR_VAR 0 3
19936: PUSH
19937: LD_VAR 0 3
19941: PPUSH
19942: LD_INT 3
19944: PPUSH
19945: CALL 103153 0 2
19949: ST_TO_ADDR
// for i := 1 to 4 do
19950: LD_ADDR_VAR 0 1
19954: PUSH
19955: DOUBLE
19956: LD_INT 1
19958: DEC
19959: ST_TO_ADDR
19960: LD_INT 4
19962: PUSH
19963: FOR_TO
19964: IFFALSE 20117
// begin if tmp2 then
19966: LD_VAR 0 3
19970: IFFALSE 20038
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19972: LD_ADDR_EXP 18
19976: PUSH
19977: LD_EXP 18
19981: PPUSH
19982: LD_INT 1
19984: PPUSH
19985: LD_EXP 18
19989: PUSH
19990: LD_INT 1
19992: ARRAY
19993: PUSH
19994: LD_VAR 0 3
19998: PUSH
19999: LD_VAR 0 3
20003: ARRAY
20004: ADD
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
20011: LD_VAR 0 3
20015: PUSH
20016: LD_VAR 0 3
20020: ARRAY
20021: PPUSH
20022: LD_INT 1
20024: PPUSH
20025: CALL_OW 109
// tmp2 := [ ] ;
20029: LD_ADDR_VAR 0 3
20033: PUSH
20034: EMPTY
20035: ST_TO_ADDR
// end else
20036: GO 20115
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
20038: LD_ADDR_EXP 18
20042: PUSH
20043: LD_EXP 18
20047: PPUSH
20048: LD_INT 1
20050: PPUSH
20051: LD_EXP 18
20055: PUSH
20056: LD_INT 1
20058: ARRAY
20059: PUSH
20060: LD_VAR 0 2
20064: PUSH
20065: LD_VAR 0 2
20069: ARRAY
20070: ADD
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
20077: LD_VAR 0 2
20081: PUSH
20082: LD_VAR 0 2
20086: ARRAY
20087: PPUSH
20088: LD_INT 1
20090: PPUSH
20091: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
20095: LD_ADDR_VAR 0 2
20099: PUSH
20100: LD_VAR 0 2
20104: PPUSH
20105: LD_VAR 0 2
20109: PPUSH
20110: CALL_OW 3
20114: ST_TO_ADDR
// end ; end ;
20115: GO 19963
20117: POP
20118: POP
// if tmp2 then
20119: LD_VAR 0 3
20123: IFFALSE 20141
// tmp := tmp union tmp2 ;
20125: LD_ADDR_VAR 0 2
20129: PUSH
20130: LD_VAR 0 2
20134: PUSH
20135: LD_VAR 0 3
20139: UNION
20140: ST_TO_ADDR
// for i := 1 to 4 do
20141: LD_ADDR_VAR 0 1
20145: PUSH
20146: DOUBLE
20147: LD_INT 1
20149: DEC
20150: ST_TO_ADDR
20151: LD_INT 4
20153: PUSH
20154: FOR_TO
20155: IFFALSE 20204
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
20157: LD_ADDR_EXP 18
20161: PUSH
20162: LD_EXP 18
20166: PPUSH
20167: LD_INT 2
20169: PPUSH
20170: LD_EXP 18
20174: PUSH
20175: LD_INT 2
20177: ARRAY
20178: PUSH
20179: LD_VAR 0 2
20183: PUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_VAR 0 1
20193: MINUS
20194: ARRAY
20195: ADD
20196: PPUSH
20197: CALL_OW 1
20201: ST_TO_ADDR
20202: GO 20154
20204: POP
20205: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
20206: LD_ADDR_EXP 99
20210: PUSH
20211: LD_EXP 99
20215: PPUSH
20216: LD_INT 4
20218: PPUSH
20219: LD_EXP 99
20223: PUSH
20224: LD_INT 4
20226: ARRAY
20227: PUSH
20228: LD_EXP 18
20232: PUSH
20233: LD_INT 1
20235: ARRAY
20236: DIFF
20237: PPUSH
20238: CALL_OW 1
20242: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
20243: LD_VAR 0 5
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PPUSH
20252: CALL_OW 313
20256: IFFALSE 20311
// begin for i in UnitsInside ( arm [ 1 ] ) do
20258: LD_ADDR_VAR 0 1
20262: PUSH
20263: LD_VAR 0 5
20267: PUSH
20268: LD_INT 1
20270: ARRAY
20271: PPUSH
20272: CALL_OW 313
20276: PUSH
20277: FOR_IN
20278: IFFALSE 20309
// begin ComExitBuilding ( i ) ;
20280: LD_VAR 0 1
20284: PPUSH
20285: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
20289: LD_VAR 0 1
20293: PPUSH
20294: LD_VAR 0 6
20298: PUSH
20299: LD_INT 1
20301: ARRAY
20302: PPUSH
20303: CALL_OW 180
// end ;
20307: GO 20277
20309: POP
20310: POP
// end ; wait ( 0 0$3 ) ;
20311: LD_INT 105
20313: PPUSH
20314: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20318: LD_ADDR_VAR 0 1
20322: PUSH
20323: LD_EXP 18
20327: PUSH
20328: LD_INT 1
20330: ARRAY
20331: PUSH
20332: FOR_IN
20333: IFFALSE 20440
// begin if IsInUnit ( i ) then
20335: LD_VAR 0 1
20339: PPUSH
20340: CALL_OW 310
20344: IFFALSE 20355
// ComExitBuilding ( i ) ;
20346: LD_VAR 0 1
20350: PPUSH
20351: CALL_OW 122
// if GetClass ( i ) <> 1 then
20355: LD_VAR 0 1
20359: PPUSH
20360: CALL_OW 257
20364: PUSH
20365: LD_INT 1
20367: NONEQUAL
20368: IFFALSE 20409
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
20370: LD_VAR 0 1
20374: PPUSH
20375: LD_VAR 0 5
20379: PUSH
20380: LD_INT 1
20382: ARRAY
20383: PPUSH
20384: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
20388: LD_VAR 0 1
20392: PPUSH
20393: LD_INT 1
20395: PPUSH
20396: CALL_OW 183
// AddComExitBuilding ( i ) ;
20400: LD_VAR 0 1
20404: PPUSH
20405: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
20409: LD_VAR 0 1
20413: PPUSH
20414: LD_INT 60
20416: PPUSH
20417: LD_INT 94
20419: PPUSH
20420: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
20424: LD_VAR 0 1
20428: PPUSH
20429: LD_EXP 59
20433: PPUSH
20434: CALL_OW 179
// end ;
20438: GO 20332
20440: POP
20441: POP
// wait ( 0 0$10 ) ;
20442: LD_INT 350
20444: PPUSH
20445: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
20449: LD_EXP 59
20453: PPUSH
20454: LD_STRING D4-Pow-1
20456: PPUSH
20457: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
20461: LD_ADDR_VAR 0 2
20465: PUSH
20466: LD_EXP 18
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: LD_INT 26
20477: PUSH
20478: LD_INT 1
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PPUSH
20485: CALL_OW 72
20489: ST_TO_ADDR
// if tmp then
20490: LD_VAR 0 2
20494: IFFALSE 20512
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
20496: LD_VAR 0 2
20500: PUSH
20501: LD_INT 1
20503: ARRAY
20504: PPUSH
20505: LD_STRING D4-Sol1-1
20507: PPUSH
20508: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
20512: LD_EXP 59
20516: PPUSH
20517: LD_STRING D4-Pow-2
20519: PPUSH
20520: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
20524: LD_ADDR_VAR 0 1
20528: PUSH
20529: DOUBLE
20530: LD_INT 1
20532: DEC
20533: ST_TO_ADDR
20534: LD_EXP 18
20538: PUSH
20539: LD_INT 1
20541: ARRAY
20542: PUSH
20543: FOR_TO
20544: IFFALSE 20637
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
20546: LD_EXP 18
20550: PUSH
20551: LD_INT 1
20553: ARRAY
20554: PUSH
20555: LD_VAR 0 1
20559: ARRAY
20560: PPUSH
20561: LD_EXP 118
20565: PUSH
20566: LD_INT 4
20568: ARRAY
20569: PUSH
20570: LD_INT 1
20572: ARRAY
20573: PPUSH
20574: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
20578: LD_ADDR_EXP 118
20582: PUSH
20583: LD_EXP 118
20587: PPUSH
20588: LD_INT 4
20590: PPUSH
20591: LD_EXP 118
20595: PUSH
20596: LD_INT 4
20598: ARRAY
20599: PPUSH
20600: LD_INT 1
20602: PPUSH
20603: CALL_OW 3
20607: PPUSH
20608: CALL_OW 1
20612: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
20613: LD_INT 8
20615: PPUSH
20616: LD_EXP 18
20620: PUSH
20621: LD_INT 1
20623: ARRAY
20624: PUSH
20625: LD_VAR 0 1
20629: ARRAY
20630: PPUSH
20631: CALL_OW 471
// end ;
20635: GO 20543
20637: POP
20638: POP
// repeat wait ( 0 0$1 ) ;
20639: LD_INT 35
20641: PPUSH
20642: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
20646: LD_EXP 18
20650: PUSH
20651: LD_INT 1
20653: ARRAY
20654: PPUSH
20655: LD_INT 55
20657: PUSH
20658: EMPTY
20659: LIST
20660: PPUSH
20661: CALL_OW 72
20665: PUSH
20666: LD_INT 4
20668: GREATEREQUAL
20669: IFFALSE 20639
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
20671: LD_EXP 18
20675: PUSH
20676: LD_INT 1
20678: ARRAY
20679: PPUSH
20680: LD_INT 69
20682: PPUSH
20683: LD_INT 94
20685: PPUSH
20686: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
20690: LD_EXP 18
20694: PUSH
20695: LD_INT 1
20697: ARRAY
20698: PPUSH
20699: LD_INT 82
20701: PPUSH
20702: LD_INT 83
20704: PPUSH
20705: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
20709: LD_EXP 18
20713: PUSH
20714: LD_INT 1
20716: ARRAY
20717: PPUSH
20718: LD_INT 77
20720: PPUSH
20721: LD_INT 69
20723: PPUSH
20724: CALL_OW 174
// repeat wait ( 3 ) ;
20728: LD_INT 3
20730: PPUSH
20731: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
20735: LD_ADDR_VAR 0 1
20739: PUSH
20740: LD_EXP 18
20744: PUSH
20745: LD_INT 1
20747: ARRAY
20748: PUSH
20749: FOR_IN
20750: IFFALSE 20886
// begin if GetLives ( i ) < 990 then
20752: LD_VAR 0 1
20756: PPUSH
20757: CALL_OW 256
20761: PUSH
20762: LD_INT 990
20764: LESS
20765: IFFALSE 20779
// SetLives ( i , 1000 ) ;
20767: LD_VAR 0 1
20771: PPUSH
20772: LD_INT 1000
20774: PPUSH
20775: CALL_OW 234
// if not IsInUnit ( i ) then
20779: LD_VAR 0 1
20783: PPUSH
20784: CALL_OW 310
20788: NOT
20789: IFFALSE 20884
// begin if not HasTask ( i ) then
20791: LD_VAR 0 1
20795: PPUSH
20796: CALL_OW 314
20800: NOT
20801: IFFALSE 20818
// ComMoveXY ( i , 64 , 93 ) ;
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_INT 64
20810: PPUSH
20811: LD_INT 93
20813: PPUSH
20814: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
20818: LD_VAR 0 4
20822: NOT
20823: PUSH
20824: LD_VAR 0 1
20828: PPUSH
20829: CALL_OW 258
20833: PUSH
20834: LD_INT 1
20836: EQUAL
20837: AND
20838: IFFALSE 20884
// begin retreat := true ;
20840: LD_ADDR_VAR 0 4
20844: PUSH
20845: LD_INT 1
20847: ST_TO_ADDR
// SetTag ( i , 2 ) ;
20848: LD_VAR 0 1
20852: PPUSH
20853: LD_INT 2
20855: PPUSH
20856: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
20860: LD_VAR 0 1
20864: PPUSH
20865: LD_STRING D4a-Sol1-1
20867: PPUSH
20868: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
20872: LD_EXP 59
20876: PPUSH
20877: LD_STRING D4a-Pow-1
20879: PPUSH
20880: CALL_OW 88
// end ; end ; end ;
20884: GO 20749
20886: POP
20887: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
20888: LD_EXP 18
20892: PUSH
20893: LD_INT 1
20895: ARRAY
20896: PPUSH
20897: LD_INT 95
20899: PUSH
20900: LD_INT 9
20902: PUSH
20903: EMPTY
20904: LIST
20905: LIST
20906: PUSH
20907: LD_INT 3
20909: PUSH
20910: LD_INT 55
20912: PUSH
20913: EMPTY
20914: LIST
20915: PUSH
20916: EMPTY
20917: LIST
20918: LIST
20919: PUSH
20920: EMPTY
20921: LIST
20922: LIST
20923: PPUSH
20924: CALL_OW 72
20928: PUSH
20929: LD_INT 4
20931: GREATEREQUAL
20932: IFFALSE 20728
// for i in powellSquadAttack [ 1 ] do
20934: LD_ADDR_VAR 0 1
20938: PUSH
20939: LD_EXP 18
20943: PUSH
20944: LD_INT 1
20946: ARRAY
20947: PUSH
20948: FOR_IN
20949: IFFALSE 21085
// begin if GetTag ( i ) = 2 then
20951: LD_VAR 0 1
20955: PPUSH
20956: CALL_OW 110
20960: PUSH
20961: LD_INT 2
20963: EQUAL
20964: IFFALSE 21026
// begin ComMoveXY ( i , 60 , 94 ) ;
20966: LD_VAR 0 1
20970: PPUSH
20971: LD_INT 60
20973: PPUSH
20974: LD_INT 94
20976: PPUSH
20977: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20981: LD_VAR 0 1
20985: PPUSH
20986: LD_EXP 59
20990: PPUSH
20991: CALL_OW 179
// wait ( 0 0$3 ) ;
20995: LD_INT 105
20997: PPUSH
20998: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
21002: LD_VAR 0 1
21006: PPUSH
21007: LD_STRING D4a-Sol1-2
21009: PPUSH
21010: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
21014: LD_EXP 59
21018: PPUSH
21019: LD_STRING D4a-Pow-2
21021: PPUSH
21022: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
21026: LD_VAR 0 1
21030: PPUSH
21031: LD_INT 0
21033: PPUSH
21034: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
21038: LD_ADDR_EXP 99
21042: PUSH
21043: LD_EXP 99
21047: PPUSH
21048: LD_INT 4
21050: PPUSH
21051: LD_EXP 99
21055: PUSH
21056: LD_INT 4
21058: ARRAY
21059: PUSH
21060: LD_VAR 0 1
21064: UNION
21065: PPUSH
21066: CALL_OW 1
21070: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
21071: LD_INT 8
21073: PPUSH
21074: LD_VAR 0 1
21078: PPUSH
21079: CALL_OW 472
// end ;
21083: GO 20948
21085: POP
21086: POP
// wait ( 2 2$00 ) ;
21087: LD_INT 4200
21089: PPUSH
21090: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21094: LD_ADDR_VAR 0 9
21098: PUSH
21099: LD_INT 22
21101: PUSH
21102: LD_INT 4
21104: PUSH
21105: EMPTY
21106: LIST
21107: LIST
21108: PUSH
21109: LD_INT 30
21111: PUSH
21112: LD_INT 32
21114: PUSH
21115: EMPTY
21116: LIST
21117: LIST
21118: PUSH
21119: LD_INT 58
21121: PUSH
21122: EMPTY
21123: LIST
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: PPUSH
21130: CALL_OW 69
21134: ST_TO_ADDR
// if tmp then
21135: LD_VAR 0 2
21139: IFFALSE 21379
// begin for i := 1 to tmp do
21141: LD_ADDR_VAR 0 1
21145: PUSH
21146: DOUBLE
21147: LD_INT 1
21149: DEC
21150: ST_TO_ADDR
21151: LD_VAR 0 2
21155: PUSH
21156: FOR_TO
21157: IFFALSE 21370
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
21159: LD_ADDR_EXP 99
21163: PUSH
21164: LD_EXP 99
21168: PPUSH
21169: LD_INT 4
21171: PPUSH
21172: LD_EXP 99
21176: PUSH
21177: LD_INT 4
21179: ARRAY
21180: PUSH
21181: LD_VAR 0 2
21185: PUSH
21186: LD_VAR 0 1
21190: ARRAY
21191: DIFF
21192: PPUSH
21193: CALL_OW 1
21197: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
21198: LD_ADDR_VAR 0 10
21202: PUSH
21203: LD_VAR 0 2
21207: PUSH
21208: LD_VAR 0 1
21212: ARRAY
21213: PPUSH
21214: CALL_OW 310
21218: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
21219: LD_VAR 0 10
21223: PUSH
21224: LD_VAR 0 10
21228: PPUSH
21229: CALL_OW 266
21233: PUSH
21234: LD_INT 32
21236: EQUAL
21237: AND
21238: IFFALSE 21242
// continue ;
21240: GO 21156
// if t then
21242: LD_VAR 0 10
21246: IFFALSE 21263
// ComExitBuilding ( tmp [ i ] ) ;
21248: LD_VAR 0 2
21252: PUSH
21253: LD_VAR 0 1
21257: ARRAY
21258: PPUSH
21259: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21263: LD_VAR 0 2
21267: PUSH
21268: LD_VAR 0 1
21272: ARRAY
21273: PPUSH
21274: LD_VAR 0 5
21278: PUSH
21279: LD_INT 1
21281: ARRAY
21282: PPUSH
21283: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21287: LD_VAR 0 2
21291: PUSH
21292: LD_VAR 0 1
21296: ARRAY
21297: PPUSH
21298: LD_INT 1
21300: PPUSH
21301: CALL_OW 183
// if emptyTowers then
21305: LD_VAR 0 9
21309: IFFALSE 21368
// begin AddComExitBuilding ( tmp [ i ] ) ;
21311: LD_VAR 0 2
21315: PUSH
21316: LD_VAR 0 1
21320: ARRAY
21321: PPUSH
21322: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
21326: LD_VAR 0 2
21330: PUSH
21331: LD_VAR 0 1
21335: ARRAY
21336: PPUSH
21337: LD_VAR 0 9
21341: PUSH
21342: LD_INT 1
21344: ARRAY
21345: PPUSH
21346: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
21350: LD_ADDR_VAR 0 9
21354: PUSH
21355: LD_VAR 0 9
21359: PPUSH
21360: LD_INT 1
21362: PPUSH
21363: CALL_OW 3
21367: ST_TO_ADDR
// end ; end ;
21368: GO 21156
21370: POP
21371: POP
// wait ( 0 0$30 ) ;
21372: LD_INT 1050
21374: PPUSH
21375: CALL_OW 67
// end ; uc_side := 6 ;
21379: LD_ADDR_OWVAR 20
21383: PUSH
21384: LD_INT 6
21386: ST_TO_ADDR
// uc_nation := 3 ;
21387: LD_ADDR_OWVAR 21
21391: PUSH
21392: LD_INT 3
21394: ST_TO_ADDR
// ru := [ ] ;
21395: LD_ADDR_VAR 0 7
21399: PUSH
21400: EMPTY
21401: ST_TO_ADDR
// for i = 1 to 5 do
21402: LD_ADDR_VAR 0 1
21406: PUSH
21407: DOUBLE
21408: LD_INT 1
21410: DEC
21411: ST_TO_ADDR
21412: LD_INT 5
21414: PUSH
21415: FOR_TO
21416: IFFALSE 21536
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
21418: LD_INT 22
21420: PUSH
21421: LD_INT 23
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 1
21430: PPUSH
21431: LD_INT 2
21433: PPUSH
21434: CALL_OW 12
21438: ARRAY
21439: PPUSH
21440: LD_INT 1
21442: PPUSH
21443: LD_INT 3
21445: PPUSH
21446: LD_INT 43
21448: PUSH
21449: LD_INT 44
21451: PUSH
21452: EMPTY
21453: LIST
21454: LIST
21455: PUSH
21456: LD_INT 1
21458: PPUSH
21459: LD_INT 2
21461: PPUSH
21462: CALL_OW 12
21466: ARRAY
21467: PPUSH
21468: LD_INT 89
21470: PPUSH
21471: CALL 72210 0 5
// un := CreateVehicle ;
21475: LD_ADDR_VAR 0 8
21479: PUSH
21480: CALL_OW 45
21484: ST_TO_ADDR
// SetDir ( un , 4 ) ;
21485: LD_VAR 0 8
21489: PPUSH
21490: LD_INT 4
21492: PPUSH
21493: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
21497: LD_VAR 0 8
21501: PPUSH
21502: LD_INT 136
21504: PPUSH
21505: LD_INT 90
21507: PPUSH
21508: LD_INT 8
21510: PPUSH
21511: LD_INT 0
21513: PPUSH
21514: CALL_OW 50
// ru := ru ^ un ;
21518: LD_ADDR_VAR 0 7
21522: PUSH
21523: LD_VAR 0 7
21527: PUSH
21528: LD_VAR 0 8
21532: ADD
21533: ST_TO_ADDR
// end ;
21534: GO 21415
21536: POP
21537: POP
// if ru then
21538: LD_VAR 0 7
21542: IFFALSE 21559
// ComAgressiveMove ( ru , 57 , 94 ) ;
21544: LD_VAR 0 7
21548: PPUSH
21549: LD_INT 57
21551: PPUSH
21552: LD_INT 94
21554: PPUSH
21555: CALL_OW 114
// wait ( 3 3$00 ) ;
21559: LD_INT 6300
21561: PPUSH
21562: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21566: LD_INT 4
21568: PPUSH
21569: LD_INT 3
21571: PUSH
21572: LD_INT 1
21574: PUSH
21575: LD_INT 1
21577: PUSH
21578: LD_INT 5
21580: PUSH
21581: EMPTY
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 4
21589: PUSH
21590: LD_INT 1
21592: PUSH
21593: LD_INT 1
21595: PUSH
21596: LD_INT 6
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: LIST
21604: PUSH
21605: LD_INT 4
21607: PUSH
21608: LD_INT 1
21610: PUSH
21611: LD_INT 1
21613: PUSH
21614: LD_INT 7
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 3
21625: PUSH
21626: LD_INT 1
21628: PUSH
21629: LD_INT 1
21631: PUSH
21632: LD_INT 7
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: LIST
21639: LIST
21640: PUSH
21641: LD_INT 3
21643: PUSH
21644: LD_INT 1
21646: PUSH
21647: LD_INT 1
21649: PUSH
21650: LD_INT 5
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: PPUSH
21666: CALL 60759 0 2
// missionStage := 4 ;
21670: LD_ADDR_EXP 15
21674: PUSH
21675: LD_INT 4
21677: ST_TO_ADDR
// end ;
21678: PPOPN 10
21680: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
21681: LD_EXP 15
21685: PUSH
21686: LD_INT 4
21688: EQUAL
21689: PUSH
21690: LD_INT 22
21692: PUSH
21693: LD_INT 4
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PUSH
21700: LD_INT 21
21702: PUSH
21703: LD_INT 2
21705: PUSH
21706: EMPTY
21707: LIST
21708: LIST
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PPUSH
21714: CALL_OW 69
21718: PUSH
21719: LD_INT 5
21721: GREATEREQUAL
21722: AND
21723: IFFALSE 25936
21725: GO 21727
21727: DISABLE
21728: LD_INT 0
21730: PPUSH
21731: PPUSH
21732: PPUSH
21733: PPUSH
21734: PPUSH
21735: PPUSH
21736: PPUSH
21737: PPUSH
21738: PPUSH
21739: PPUSH
21740: PPUSH
21741: PPUSH
21742: PPUSH
// begin wait ( 0 0$10 ) ;
21743: LD_INT 350
21745: PPUSH
21746: CALL_OW 67
// missionStage := 5 ;
21750: LD_ADDR_EXP 15
21754: PUSH
21755: LD_INT 5
21757: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
21758: LD_ADDR_VAR 0 10
21762: PUSH
21763: LD_INT 22
21765: PUSH
21766: LD_INT 4
21768: PUSH
21769: EMPTY
21770: LIST
21771: LIST
21772: PUSH
21773: LD_INT 2
21775: PUSH
21776: LD_INT 30
21778: PUSH
21779: LD_INT 4
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 30
21788: PUSH
21789: LD_INT 5
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: PPUSH
21805: CALL_OW 69
21809: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
21810: LD_ADDR_VAR 0 6
21814: PUSH
21815: LD_INT 22
21817: PUSH
21818: LD_INT 4
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: PUSH
21825: LD_INT 21
21827: PUSH
21828: LD_INT 1
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: PUSH
21835: LD_INT 3
21837: PUSH
21838: LD_INT 25
21840: PUSH
21841: LD_INT 16
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: PUSH
21852: LD_INT 3
21854: PUSH
21855: LD_INT 25
21857: PUSH
21858: LD_INT 12
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: PUSH
21865: EMPTY
21866: LIST
21867: LIST
21868: PUSH
21869: EMPTY
21870: LIST
21871: LIST
21872: LIST
21873: LIST
21874: PPUSH
21875: CALL_OW 69
21879: PUSH
21880: LD_EXP 59
21884: DIFF
21885: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 22
21893: PUSH
21894: LD_INT 4
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: LD_INT 30
21903: PUSH
21904: LD_INT 3
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: EMPTY
21912: LIST
21913: LIST
21914: PPUSH
21915: CALL_OW 69
21919: PUSH
21920: LD_INT 1
21922: ARRAY
21923: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
21924: LD_INT 350
21926: PPUSH
21927: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
21931: LD_EXP 118
21935: PUSH
21936: LD_INT 4
21938: ARRAY
21939: PUSH
21940: LD_INT 5
21942: LESS
21943: PUSH
21944: LD_VAR 0 9
21948: PPUSH
21949: CALL_OW 461
21953: PUSH
21954: LD_INT 2
21956: EQUAL
21957: AND
21958: IFFALSE 21988
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
21960: LD_INT 4
21962: PPUSH
21963: LD_INT 3
21965: PUSH
21966: LD_INT 1
21968: PUSH
21969: LD_INT 1
21971: PUSH
21972: LD_INT 5
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: PUSH
21981: EMPTY
21982: LIST
21983: PPUSH
21984: CALL 60807 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
21988: LD_EXP 118
21992: PUSH
21993: LD_INT 4
21995: ARRAY
21996: PUSH
21997: LD_INT 5
21999: GREATEREQUAL
22000: PUSH
22001: LD_EXP 118
22005: PUSH
22006: LD_INT 4
22008: ARRAY
22009: PPUSH
22010: LD_INT 58
22012: PUSH
22013: EMPTY
22014: LIST
22015: PPUSH
22016: CALL_OW 72
22020: PUSH
22021: LD_INT 5
22023: GREATEREQUAL
22024: AND
22025: IFFALSE 21924
// powellAllowRetreat := false ;
22027: LD_ADDR_EXP 19
22031: PUSH
22032: LD_INT 0
22034: ST_TO_ADDR
// activeAttacks := false ;
22035: LD_ADDR_EXP 16
22039: PUSH
22040: LD_INT 0
22042: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22043: LD_INT 35
22045: PPUSH
22046: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
22050: LD_INT 22
22052: PUSH
22053: LD_INT 6
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: PPUSH
22060: CALL_OW 69
22064: PUSH
22065: LD_INT 0
22067: EQUAL
22068: IFFALSE 22043
// tmp := mc_vehicles [ 4 ] ;
22070: LD_ADDR_VAR 0 3
22074: PUSH
22075: LD_EXP 118
22079: PUSH
22080: LD_INT 4
22082: ARRAY
22083: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
22084: LD_ADDR_VAR 0 1
22088: PUSH
22089: DOUBLE
22090: LD_INT 1
22092: DEC
22093: ST_TO_ADDR
22094: LD_EXP 18
22098: PUSH
22099: FOR_TO
22100: IFFALSE 22361
// begin for j in powellSquadAttack [ i ] do
22102: LD_ADDR_VAR 0 2
22106: PUSH
22107: LD_EXP 18
22111: PUSH
22112: LD_VAR 0 1
22116: ARRAY
22117: PUSH
22118: FOR_IN
22119: IFFALSE 22357
// begin forces := forces diff j ;
22121: LD_ADDR_VAR 0 6
22125: PUSH
22126: LD_VAR 0 6
22130: PUSH
22131: LD_VAR 0 2
22135: DIFF
22136: ST_TO_ADDR
// SetTag ( j , 1 ) ;
22137: LD_VAR 0 2
22141: PPUSH
22142: LD_INT 1
22144: PPUSH
22145: CALL_OW 109
// wait ( 0 0$2 ) ;
22149: LD_INT 70
22151: PPUSH
22152: CALL_OW 67
// if IsInUnit ( j ) then
22156: LD_VAR 0 2
22160: PPUSH
22161: CALL_OW 310
22165: IFFALSE 22176
// ComExitBuilding ( j ) ;
22167: LD_VAR 0 2
22171: PPUSH
22172: CALL_OW 122
// if GetClass ( j ) <> 1 then
22176: LD_VAR 0 2
22180: PPUSH
22181: CALL_OW 257
22185: PUSH
22186: LD_INT 1
22188: NONEQUAL
22189: IFFALSE 22269
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
22191: LD_VAR 0 10
22195: PUSH
22196: LD_INT 1
22198: ARRAY
22199: PPUSH
22200: CALL_OW 313
22204: PUSH
22205: LD_INT 5
22207: GREATEREQUAL
22208: IFFALSE 22230
// AddComEnterUnit ( j , arm [ 2 ] ) else
22210: LD_VAR 0 2
22214: PPUSH
22215: LD_VAR 0 10
22219: PUSH
22220: LD_INT 2
22222: ARRAY
22223: PPUSH
22224: CALL_OW 180
22228: GO 22248
// AddComEnterUnit ( j , arm [ 1 ] ) ;
22230: LD_VAR 0 2
22234: PPUSH
22235: LD_VAR 0 10
22239: PUSH
22240: LD_INT 1
22242: ARRAY
22243: PPUSH
22244: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
22248: LD_VAR 0 2
22252: PPUSH
22253: LD_INT 1
22255: PPUSH
22256: CALL_OW 183
// AddComExitBuilding ( j ) ;
22260: LD_VAR 0 2
22264: PPUSH
22265: CALL_OW 182
// end ; if i = 2 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 2
22276: EQUAL
22277: IFFALSE 22294
// AddComMoveXY ( j , 61 , 93 ) ;
22279: LD_VAR 0 2
22283: PPUSH
22284: LD_INT 61
22286: PPUSH
22287: LD_INT 93
22289: PPUSH
22290: CALL_OW 171
// if i = 1 then
22294: LD_VAR 0 1
22298: PUSH
22299: LD_INT 1
22301: EQUAL
22302: IFFALSE 22355
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
22304: LD_VAR 0 2
22308: PPUSH
22309: LD_VAR 0 3
22313: PUSH
22314: LD_INT 1
22316: ARRAY
22317: PPUSH
22318: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
22322: LD_ADDR_VAR 0 3
22326: PUSH
22327: LD_VAR 0 3
22331: PPUSH
22332: LD_INT 1
22334: PPUSH
22335: CALL_OW 3
22339: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
22340: LD_VAR 0 2
22344: PPUSH
22345: LD_INT 69
22347: PPUSH
22348: LD_INT 94
22350: PPUSH
22351: CALL_OW 171
// end ; end ;
22355: GO 22118
22357: POP
22358: POP
// end ;
22359: GO 22099
22361: POP
22362: POP
// wait ( 0 0$30 ) ;
22363: LD_INT 1050
22365: PPUSH
22366: CALL_OW 67
// MC_Kill ( 4 ) ;
22370: LD_INT 4
22372: PPUSH
22373: CALL 36780 0 1
// tmp := UnitsInside ( fac ) ;
22377: LD_ADDR_VAR 0 3
22381: PUSH
22382: LD_VAR 0 9
22386: PPUSH
22387: CALL_OW 313
22391: ST_TO_ADDR
// if tmp then
22392: LD_VAR 0 3
22396: IFFALSE 22517
// for i in tmp do
22398: LD_ADDR_VAR 0 1
22402: PUSH
22403: LD_VAR 0 3
22407: PUSH
22408: FOR_IN
22409: IFFALSE 22515
// begin ComExitBuilding ( i ) ;
22411: LD_VAR 0 1
22415: PPUSH
22416: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
22420: LD_VAR 0 10
22424: PUSH
22425: LD_INT 2
22427: ARRAY
22428: PPUSH
22429: CALL_OW 313
22433: PUSH
22434: LD_INT 6
22436: LESS
22437: IFFALSE 22459
// AddComEnterUnit ( i , arm [ 2 ] ) else
22439: LD_VAR 0 1
22443: PPUSH
22444: LD_VAR 0 10
22448: PUSH
22449: LD_INT 2
22451: ARRAY
22452: PPUSH
22453: CALL_OW 180
22457: GO 22513
// if UnitsInside ( arm [ 1 ] ) < 6 then
22459: LD_VAR 0 10
22463: PUSH
22464: LD_INT 1
22466: ARRAY
22467: PPUSH
22468: CALL_OW 313
22472: PUSH
22473: LD_INT 6
22475: LESS
22476: IFFALSE 22498
// AddComEnterUnit ( i , arm [ 1 ] ) else
22478: LD_VAR 0 1
22482: PPUSH
22483: LD_VAR 0 10
22487: PUSH
22488: LD_INT 1
22490: ARRAY
22491: PPUSH
22492: CALL_OW 180
22496: GO 22513
// AddComMoveXY ( i , 37 , 68 ) ;
22498: LD_VAR 0 1
22502: PPUSH
22503: LD_INT 37
22505: PPUSH
22506: LD_INT 68
22508: PPUSH
22509: CALL_OW 171
// end ;
22513: GO 22408
22515: POP
22516: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
22517: LD_ADDR_VAR 0 11
22521: PUSH
22522: LD_VAR 0 6
22526: PPUSH
22527: LD_INT 26
22529: PUSH
22530: LD_INT 1
22532: PUSH
22533: EMPTY
22534: LIST
22535: LIST
22536: PPUSH
22537: CALL_OW 72
22541: PUSH
22542: LD_EXP 60
22546: DIFF
22547: ST_TO_ADDR
// if not speaker then
22548: LD_VAR 0 11
22552: NOT
22553: IFFALSE 22580
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
22555: LD_ADDR_VAR 0 11
22559: PUSH
22560: LD_VAR 0 6
22564: PPUSH
22565: LD_INT 26
22567: PUSH
22568: LD_INT 1
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PPUSH
22575: CALL_OW 72
22579: ST_TO_ADDR
// if speaker then
22580: LD_VAR 0 11
22584: IFFALSE 22600
// speaker := speaker [ 1 ] ;
22586: LD_ADDR_VAR 0 11
22590: PUSH
22591: LD_VAR 0 11
22595: PUSH
22596: LD_INT 1
22598: ARRAY
22599: ST_TO_ADDR
// Video ( true ) ;
22600: LD_INT 1
22602: PPUSH
22603: CALL 104616 0 1
// CenterNowOnUnits ( Powell ) ;
22607: LD_EXP 59
22611: PPUSH
22612: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
22616: LD_ADDR_VAR 0 3
22620: PUSH
22621: LD_VAR 0 6
22625: PPUSH
22626: LD_INT 3
22628: PUSH
22629: LD_INT 25
22631: PUSH
22632: LD_INT 1
22634: PUSH
22635: EMPTY
22636: LIST
22637: LIST
22638: PUSH
22639: EMPTY
22640: LIST
22641: LIST
22642: PPUSH
22643: CALL_OW 72
22647: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22648: LD_ADDR_VAR 0 12
22652: PUSH
22653: LD_INT 22
22655: PUSH
22656: LD_INT 4
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: PUSH
22663: LD_INT 30
22665: PUSH
22666: LD_INT 32
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: PUSH
22673: LD_INT 58
22675: PUSH
22676: EMPTY
22677: LIST
22678: PUSH
22679: EMPTY
22680: LIST
22681: LIST
22682: LIST
22683: PPUSH
22684: CALL_OW 69
22688: ST_TO_ADDR
// for i := 1 to 4 do
22689: LD_ADDR_VAR 0 1
22693: PUSH
22694: DOUBLE
22695: LD_INT 1
22697: DEC
22698: ST_TO_ADDR
22699: LD_INT 4
22701: PUSH
22702: FOR_TO
22703: IFFALSE 22844
// begin if IsInUnit ( tmp [ i ] ) then
22705: LD_VAR 0 3
22709: PUSH
22710: LD_VAR 0 1
22714: ARRAY
22715: PPUSH
22716: CALL_OW 310
22720: IFFALSE 22737
// ComExitBuilding ( tmp [ i ] ) ;
22722: LD_VAR 0 3
22726: PUSH
22727: LD_VAR 0 1
22731: ARRAY
22732: PPUSH
22733: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22737: LD_VAR 0 3
22741: PUSH
22742: LD_VAR 0 1
22746: ARRAY
22747: PPUSH
22748: LD_VAR 0 10
22752: PUSH
22753: LD_INT 1
22755: ARRAY
22756: PPUSH
22757: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22761: LD_VAR 0 3
22765: PUSH
22766: LD_VAR 0 1
22770: ARRAY
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 183
// if emp_towers then
22779: LD_VAR 0 12
22783: IFFALSE 22842
// begin AddComExitBuilding ( tmp [ i ] ) ;
22785: LD_VAR 0 3
22789: PUSH
22790: LD_VAR 0 1
22794: ARRAY
22795: PPUSH
22796: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
22800: LD_VAR 0 3
22804: PUSH
22805: LD_VAR 0 1
22809: ARRAY
22810: PPUSH
22811: LD_VAR 0 12
22815: PUSH
22816: LD_INT 1
22818: ARRAY
22819: PPUSH
22820: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
22824: LD_ADDR_VAR 0 12
22828: PUSH
22829: LD_VAR 0 12
22833: PPUSH
22834: LD_INT 1
22836: PPUSH
22837: CALL_OW 3
22841: ST_TO_ADDR
// end ; end ;
22842: GO 22702
22844: POP
22845: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
22846: LD_ADDR_VAR 0 3
22850: PUSH
22851: LD_EXP 18
22855: PUSH
22856: LD_INT 1
22858: ARRAY
22859: PUSH
22860: LD_EXP 18
22864: PUSH
22865: LD_INT 2
22867: ARRAY
22868: ADD
22869: PPUSH
22870: LD_INT 26
22872: PUSH
22873: LD_INT 1
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PPUSH
22880: CALL_OW 72
22884: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
22885: LD_ADDR_VAR 0 1
22889: PUSH
22890: LD_EXP 18
22894: PUSH
22895: LD_INT 2
22897: ARRAY
22898: PUSH
22899: FOR_IN
22900: IFFALSE 22918
// ComTurnUnit ( i , Powell ) ;
22902: LD_VAR 0 1
22906: PPUSH
22907: LD_EXP 59
22911: PPUSH
22912: CALL_OW 119
22916: GO 22899
22918: POP
22919: POP
// Say ( Powell , D5-Pow-1 ) ;
22920: LD_EXP 59
22924: PPUSH
22925: LD_STRING D5-Pow-1
22927: PPUSH
22928: CALL_OW 88
// if tmp then
22932: LD_VAR 0 3
22936: IFFALSE 22954
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
22938: LD_VAR 0 3
22942: PUSH
22943: LD_INT 1
22945: ARRAY
22946: PPUSH
22947: LD_STRING D5-Sol2-1
22949: PPUSH
22950: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
22954: LD_EXP 59
22958: PPUSH
22959: LD_STRING D5-Pow-2
22961: PPUSH
22962: CALL_OW 88
// if tmp > 1 then
22966: LD_VAR 0 3
22970: PUSH
22971: LD_INT 1
22973: GREATER
22974: IFFALSE 22992
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
22976: LD_VAR 0 3
22980: PUSH
22981: LD_INT 2
22983: ARRAY
22984: PPUSH
22985: LD_STRING D5-Sol2-2
22987: PPUSH
22988: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
22992: LD_EXP 59
22996: PPUSH
22997: LD_STRING D5-Pow-3
22999: PPUSH
23000: CALL_OW 88
// wait ( 0 0$1 ) ;
23004: LD_INT 35
23006: PPUSH
23007: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
23011: LD_ADDR_VAR 0 3
23015: PUSH
23016: LD_EXP 18
23020: PUSH
23021: LD_INT 1
23023: ARRAY
23024: PUSH
23025: LD_EXP 18
23029: PUSH
23030: LD_INT 2
23032: ARRAY
23033: UNION
23034: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
23035: LD_VAR 0 3
23039: PPUSH
23040: LD_INT 80
23042: PPUSH
23043: LD_INT 67
23045: PPUSH
23046: CALL_OW 114
// wait ( 0 0$2 ) ;
23050: LD_INT 70
23052: PPUSH
23053: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
23057: LD_INT 79
23059: PPUSH
23060: LD_INT 72
23062: PPUSH
23063: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
23067: LD_INT 70
23069: PPUSH
23070: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
23074: LD_VAR 0 3
23078: PPUSH
23079: LD_INT 3
23081: PUSH
23082: LD_INT 24
23084: PUSH
23085: LD_INT 1000
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: PPUSH
23096: CALL_OW 72
23100: IFFALSE 23067
// Say ( Powell , D5a-Pow-1 ) ;
23102: LD_EXP 59
23106: PPUSH
23107: LD_STRING D5a-Pow-1
23109: PPUSH
23110: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
23114: LD_EXP 59
23118: PPUSH
23119: LD_STRING D5a-Pow-1a
23121: PPUSH
23122: CALL_OW 88
// wait ( 0 0$0.7 ) ;
23126: LD_INT 24
23128: PPUSH
23129: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
23133: LD_EXP 59
23137: PPUSH
23138: LD_STRING D5a-Pow-1b
23140: PPUSH
23141: CALL_OW 88
// wait ( 0 0$0.3 ) ;
23145: LD_INT 10
23147: PPUSH
23148: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
23152: LD_EXP 59
23156: PPUSH
23157: LD_STRING D5a-Pow-1c
23159: PPUSH
23160: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
23164: LD_VAR 0 3
23168: PPUSH
23169: LD_INT 68
23171: PPUSH
23172: LD_INT 63
23174: PPUSH
23175: CALL_OW 111
// wait ( 0 0$0.5 ) ;
23179: LD_INT 18
23181: PPUSH
23182: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
23186: LD_EXP 59
23190: PPUSH
23191: LD_STRING D5a-Pow-1d
23193: PPUSH
23194: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
23198: LD_INT 35
23200: PPUSH
23201: CALL_OW 67
// if not HasTask ( tmp ) then
23205: LD_VAR 0 3
23209: PPUSH
23210: CALL_OW 314
23214: NOT
23215: IFFALSE 23232
// ComAgressiveMove ( tmp , 68 , 63 ) ;
23217: LD_VAR 0 3
23221: PPUSH
23222: LD_INT 68
23224: PPUSH
23225: LD_INT 63
23227: PPUSH
23228: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
23232: LD_VAR 0 3
23236: PPUSH
23237: LD_INT 24
23239: PUSH
23240: LD_INT 1
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: PPUSH
23247: CALL_OW 72
23251: NOT
23252: IFFALSE 23198
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
23254: LD_ADDR_VAR 0 3
23258: PUSH
23259: LD_INT 22
23261: PUSH
23262: LD_INT 4
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 92
23271: PUSH
23272: LD_INT 60
23274: PUSH
23275: LD_INT 93
23277: PUSH
23278: LD_INT 10
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: PUSH
23287: LD_INT 3
23289: PUSH
23290: LD_INT 54
23292: PUSH
23293: EMPTY
23294: LIST
23295: PUSH
23296: EMPTY
23297: LIST
23298: LIST
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: LIST
23304: PPUSH
23305: CALL_OW 69
23309: PUSH
23310: LD_EXP 59
23314: DIFF
23315: ST_TO_ADDR
// if tmp then
23316: LD_VAR 0 3
23320: IFFALSE 23354
// for i in tmp do
23322: LD_ADDR_VAR 0 1
23326: PUSH
23327: LD_VAR 0 3
23331: PUSH
23332: FOR_IN
23333: IFFALSE 23352
// ComMoveXY ( i , 36 , 67 ) ;
23335: LD_VAR 0 1
23339: PPUSH
23340: LD_INT 36
23342: PPUSH
23343: LD_INT 67
23345: PPUSH
23346: CALL_OW 111
23350: GO 23332
23352: POP
23353: POP
// wait ( 0 0$3 ) ;
23354: LD_INT 105
23356: PPUSH
23357: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
23361: LD_VAR 0 11
23365: PPUSH
23366: LD_STRING D6-Sol3-1
23368: PPUSH
23369: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
23373: LD_EXP 59
23377: PPUSH
23378: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
23382: LD_EXP 59
23386: PPUSH
23387: LD_STRING D6-Pow-1
23389: PPUSH
23390: CALL_OW 88
// tmp := [ ] ;
23394: LD_ADDR_VAR 0 3
23398: PUSH
23399: EMPTY
23400: ST_TO_ADDR
// for i = 1 to 2 do
23401: LD_ADDR_VAR 0 1
23405: PUSH
23406: DOUBLE
23407: LD_INT 1
23409: DEC
23410: ST_TO_ADDR
23411: LD_INT 2
23413: PUSH
23414: FOR_TO
23415: IFFALSE 23529
// begin uc_side := 8 ;
23417: LD_ADDR_OWVAR 20
23421: PUSH
23422: LD_INT 8
23424: ST_TO_ADDR
// uc_nation := 2 ;
23425: LD_ADDR_OWVAR 21
23429: PUSH
23430: LD_INT 2
23432: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
23433: LD_INT 14
23435: PPUSH
23436: LD_INT 3
23438: PPUSH
23439: LD_INT 2
23441: PPUSH
23442: LD_INT 29
23444: PPUSH
23445: LD_INT 100
23447: PPUSH
23448: CALL 72210 0 5
// veh := CreateVehicle ;
23452: LD_ADDR_VAR 0 13
23456: PUSH
23457: CALL_OW 45
23461: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
23462: LD_VAR 0 13
23466: PPUSH
23467: LD_INT 4
23469: PPUSH
23470: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
23474: LD_VAR 0 13
23478: PPUSH
23479: LD_INT 99
23481: PPUSH
23482: LD_INT 83
23484: PPUSH
23485: LD_INT 3
23487: PPUSH
23488: LD_INT 0
23490: PPUSH
23491: CALL_OW 50
// wait ( 3 ) ;
23495: LD_INT 3
23497: PPUSH
23498: CALL_OW 67
// Connect ( veh ) ;
23502: LD_VAR 0 13
23506: PPUSH
23507: CALL 75301 0 1
// tmp := tmp ^ veh ;
23511: LD_ADDR_VAR 0 3
23515: PUSH
23516: LD_VAR 0 3
23520: PUSH
23521: LD_VAR 0 13
23525: ADD
23526: ST_TO_ADDR
// end ;
23527: GO 23414
23529: POP
23530: POP
// wait ( 0 0$1 ) ;
23531: LD_INT 35
23533: PPUSH
23534: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
23538: LD_INT 99
23540: PPUSH
23541: LD_INT 83
23543: PPUSH
23544: LD_INT 1
23546: PPUSH
23547: LD_INT 10
23549: PPUSH
23550: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
23554: LD_INT 99
23556: PPUSH
23557: LD_INT 83
23559: PPUSH
23560: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
23564: LD_VAR 0 11
23568: PPUSH
23569: LD_STRING D6-Sol3-2
23571: PPUSH
23572: CALL_OW 88
// async ;
23576: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
23577: LD_EXP 59
23581: PPUSH
23582: LD_STRING D6-Pow-2
23584: PPUSH
23585: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
23589: LD_VAR 0 3
23593: PUSH
23594: LD_INT 1
23596: ARRAY
23597: PPUSH
23598: LD_VAR 0 9
23602: PPUSH
23603: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
23607: LD_VAR 0 3
23611: PUSH
23612: LD_INT 2
23614: ARRAY
23615: PPUSH
23616: LD_INT 22
23618: PUSH
23619: LD_INT 4
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 21
23628: PUSH
23629: LD_INT 3
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: PUSH
23636: EMPTY
23637: LIST
23638: LIST
23639: PPUSH
23640: CALL_OW 69
23644: PPUSH
23645: LD_VAR 0 3
23649: PUSH
23650: LD_INT 2
23652: ARRAY
23653: PPUSH
23654: CALL_OW 74
23658: PPUSH
23659: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
23663: LD_EXP 59
23667: PPUSH
23668: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
23672: LD_INT 99
23674: PPUSH
23675: LD_INT 83
23677: PPUSH
23678: LD_INT 1
23680: PPUSH
23681: CALL_OW 331
// repeat wait ( 4 ) ;
23685: LD_INT 4
23687: PPUSH
23688: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
23692: LD_VAR 0 3
23696: PUSH
23697: LD_INT 1
23699: ARRAY
23700: PPUSH
23701: CALL_OW 256
23705: PUSH
23706: LD_INT 1000
23708: LESS
23709: IFFALSE 23727
// SetLives ( tmp [ 1 ] , 1000 ) ;
23711: LD_VAR 0 3
23715: PUSH
23716: LD_INT 1
23718: ARRAY
23719: PPUSH
23720: LD_INT 1000
23722: PPUSH
23723: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
23727: LD_INT 22
23729: PUSH
23730: LD_INT 4
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: LD_INT 30
23739: PUSH
23740: LD_INT 3
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PPUSH
23751: CALL_OW 69
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23685
// skirmish := false ;
23761: LD_ADDR_EXP 97
23765: PUSH
23766: LD_INT 0
23768: ST_TO_ADDR
// sync ;
23769: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
23770: LD_EXP 59
23774: PPUSH
23775: LD_STRING D6a-Pow-1
23777: PPUSH
23778: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
23782: LD_VAR 0 11
23786: PPUSH
23787: LD_STRING D6a-Sol3-1
23789: PPUSH
23790: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
23794: LD_EXP 59
23798: PPUSH
23799: LD_STRING D6a-Pow-2
23801: PPUSH
23802: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
23806: LD_VAR 0 11
23810: PPUSH
23811: LD_STRING D6a-Sol3-2
23813: PPUSH
23814: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
23818: LD_EXP 59
23822: PPUSH
23823: LD_STRING D6a-Pow-3
23825: PPUSH
23826: CALL_OW 88
// powellCenterCameraMode := true ;
23830: LD_ADDR_EXP 20
23834: PUSH
23835: LD_INT 1
23837: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23838: LD_ADDR_VAR 0 1
23842: PUSH
23843: LD_INT 22
23845: PUSH
23846: LD_INT 8
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 25
23855: PUSH
23856: LD_INT 2
23858: PUSH
23859: EMPTY
23860: LIST
23861: LIST
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: PPUSH
23867: CALL_OW 69
23871: PUSH
23872: FOR_IN
23873: IFFALSE 23928
// begin SetTag ( i , 1 ) ;
23875: LD_VAR 0 1
23879: PPUSH
23880: LD_INT 1
23882: PPUSH
23883: CALL_OW 109
// ComExitBuilding ( i ) ;
23887: LD_VAR 0 1
23891: PPUSH
23892: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
23896: LD_VAR 0 1
23900: PPUSH
23901: LD_INT 35
23903: PPUSH
23904: LD_INT 6
23906: PPUSH
23907: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
23911: LD_VAR 0 1
23915: PPUSH
23916: LD_INT 53
23918: PPUSH
23919: LD_INT 4
23921: PPUSH
23922: CALL_OW 171
// end ;
23926: GO 23872
23928: POP
23929: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
23930: LD_ADDR_VAR 0 3
23934: PUSH
23935: LD_INT 22
23937: PUSH
23938: LD_INT 4
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: LD_INT 21
23947: PUSH
23948: LD_INT 2
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PUSH
23955: LD_INT 3
23957: PUSH
23958: LD_INT 34
23960: PUSH
23961: LD_INT 12
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: PUSH
23972: EMPTY
23973: LIST
23974: LIST
23975: LIST
23976: PPUSH
23977: CALL_OW 69
23981: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
23982: LD_EXP 59
23986: PPUSH
23987: LD_VAR 0 3
23991: PPUSH
23992: LD_EXP 59
23996: PPUSH
23997: CALL_OW 74
24001: PPUSH
24002: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
24006: LD_EXP 59
24010: PPUSH
24011: LD_INT 100
24013: PPUSH
24014: LD_INT 88
24016: PPUSH
24017: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
24021: LD_EXP 59
24025: PPUSH
24026: LD_INT 100
24028: PPUSH
24029: LD_INT 75
24031: PPUSH
24032: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
24036: LD_EXP 59
24040: PPUSH
24041: LD_INT 88
24043: PPUSH
24044: LD_INT 53
24046: PPUSH
24047: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
24051: LD_INT 8
24053: PPUSH
24054: LD_EXP 59
24058: PPUSH
24059: CALL_OW 471
// repeat wait ( 3 ) ;
24063: LD_INT 3
24065: PPUSH
24066: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
24070: LD_INT 22
24072: PUSH
24073: LD_INT 4
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: PUSH
24080: LD_INT 92
24082: PUSH
24083: LD_INT 100
24085: PUSH
24086: LD_INT 75
24088: PUSH
24089: LD_INT 6
24091: PUSH
24092: EMPTY
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 69
24106: IFFALSE 24063
// async ;
24108: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
24109: LD_EXP 59
24113: PPUSH
24114: LD_STRING D6b-Pow-1
24116: PPUSH
24117: CALL_OW 88
// repeat wait ( 3 ) ;
24121: LD_INT 3
24123: PPUSH
24124: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
24128: LD_EXP 59
24132: PPUSH
24133: CALL_OW 310
24137: PPUSH
24138: CALL_OW 256
24142: PUSH
24143: LD_INT 1000
24145: LESS
24146: IFFALSE 24165
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
24148: LD_EXP 59
24152: PPUSH
24153: CALL_OW 310
24157: PPUSH
24158: LD_INT 1000
24160: PPUSH
24161: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
24165: LD_EXP 59
24169: PPUSH
24170: CALL_OW 256
24174: PUSH
24175: LD_INT 1000
24177: LESS
24178: IFFALSE 24192
// SetLives ( Powell , 1000 ) ;
24180: LD_EXP 59
24184: PPUSH
24185: LD_INT 1000
24187: PPUSH
24188: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
24192: LD_EXP 59
24196: PPUSH
24197: LD_EXP 64
24201: PPUSH
24202: CALL_OW 296
24206: PUSH
24207: LD_INT 5
24209: LESS
24210: PUSH
24211: LD_EXP 59
24215: PPUSH
24216: CALL_OW 310
24220: PPUSH
24221: LD_EXP 64
24225: PPUSH
24226: CALL_OW 296
24230: PUSH
24231: LD_INT 5
24233: LESS
24234: OR
24235: IFFALSE 24254
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
24237: LD_EXP 59
24241: PPUSH
24242: CALL_OW 310
24246: PPUSH
24247: LD_INT 100
24249: PPUSH
24250: CALL_OW 234
// until not IsInUnit ( Powell ) ;
24254: LD_EXP 59
24258: PPUSH
24259: CALL_OW 310
24263: NOT
24264: IFFALSE 24121
// DoNotAttack ( 8 , powellBomb ) ;
24266: LD_INT 8
24268: PPUSH
24269: LD_EXP 64
24273: PPUSH
24274: CALL_OW 471
// game_speed := 4 ;
24278: LD_ADDR_OWVAR 65
24282: PUSH
24283: LD_INT 4
24285: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
24286: LD_EXP 59
24290: PPUSH
24291: LD_STRING D6b-Pow-1a
24293: PPUSH
24294: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
24298: LD_EXP 59
24302: PPUSH
24303: LD_EXP 64
24307: PPUSH
24308: CALL_OW 180
// sync ;
24312: SYNC
// repeat wait ( 0 0$1 ) ;
24313: LD_INT 35
24315: PPUSH
24316: CALL_OW 67
// until IsInUnit ( Powell ) ;
24320: LD_EXP 59
24324: PPUSH
24325: CALL_OW 310
24329: IFFALSE 24313
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
24331: LD_INT 8
24333: PPUSH
24334: LD_EXP 59
24338: PPUSH
24339: CALL_OW 310
24343: PPUSH
24344: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
24348: LD_EXP 59
24352: PPUSH
24353: LD_INT 91
24355: PPUSH
24356: LD_INT 44
24358: PPUSH
24359: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24363: LD_EXP 59
24367: PPUSH
24368: LD_INT 96
24370: PPUSH
24371: LD_INT 44
24373: PPUSH
24374: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24378: LD_EXP 59
24382: PPUSH
24383: LD_INT 96
24385: PPUSH
24386: LD_INT 41
24388: PPUSH
24389: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24393: LD_EXP 59
24397: PPUSH
24398: LD_INT 92
24400: PPUSH
24401: LD_INT 39
24403: PPUSH
24404: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24408: LD_EXP 59
24412: PPUSH
24413: LD_INT 88
24415: PPUSH
24416: LD_INT 41
24418: PPUSH
24419: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24423: LD_EXP 59
24427: PPUSH
24428: LD_INT 91
24430: PPUSH
24431: LD_INT 44
24433: PPUSH
24434: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
24438: LD_EXP 59
24442: PPUSH
24443: LD_INT 96
24445: PPUSH
24446: LD_INT 44
24448: PPUSH
24449: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
24453: LD_EXP 59
24457: PPUSH
24458: LD_INT 96
24460: PPUSH
24461: LD_INT 41
24463: PPUSH
24464: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
24468: LD_EXP 59
24472: PPUSH
24473: LD_INT 92
24475: PPUSH
24476: LD_INT 39
24478: PPUSH
24479: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
24483: LD_EXP 59
24487: PPUSH
24488: LD_INT 88
24490: PPUSH
24491: LD_INT 41
24493: PPUSH
24494: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
24498: LD_EXP 59
24502: PPUSH
24503: LD_INT 91
24505: PPUSH
24506: LD_INT 44
24508: PPUSH
24509: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
24513: LD_EXP 59
24517: PPUSH
24518: LD_INT 93
24520: PPUSH
24521: LD_INT 39
24523: PPUSH
24524: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
24528: LD_EXP 59
24532: PPUSH
24533: LD_INT 93
24535: PPUSH
24536: LD_INT 36
24538: PPUSH
24539: CALL_OW 171
// wait ( 0 0$3.5 ) ;
24543: LD_INT 122
24545: PPUSH
24546: CALL_OW 67
// game_speed := 4 ;
24550: LD_ADDR_OWVAR 65
24554: PUSH
24555: LD_INT 4
24557: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
24558: LD_EXP 59
24562: PPUSH
24563: LD_STRING D6b-Pow-1b
24565: PPUSH
24566: CALL_OW 88
// tmp := [ ] ;
24570: LD_ADDR_VAR 0 3
24574: PUSH
24575: EMPTY
24576: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
24577: LD_ADDR_VAR 0 5
24581: PUSH
24582: LD_INT 78
24584: PUSH
24585: LD_INT 47
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: PUSH
24592: LD_INT 106
24594: PUSH
24595: LD_INT 53
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 21
24623: PUSH
24624: LD_INT 3
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 92
24633: PUSH
24634: LD_INT 90
24636: PUSH
24637: LD_INT 52
24639: PUSH
24640: LD_INT 12
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: LIST
24653: PPUSH
24654: CALL_OW 69
24658: PUSH
24659: FOR_IN
24660: IFFALSE 24685
// tmp := tmp ^ UnitsInside ( i ) ;
24662: LD_ADDR_VAR 0 3
24666: PUSH
24667: LD_VAR 0 3
24671: PUSH
24672: LD_VAR 0 1
24676: PPUSH
24677: CALL_OW 313
24681: ADD
24682: ST_TO_ADDR
24683: GO 24659
24685: POP
24686: POP
// for i in tmp do
24687: LD_ADDR_VAR 0 1
24691: PUSH
24692: LD_VAR 0 3
24696: PUSH
24697: FOR_IN
24698: IFFALSE 24860
// begin dist := 9999 ;
24700: LD_ADDR_VAR 0 8
24704: PUSH
24705: LD_INT 9999
24707: ST_TO_ADDR
// _xy := [ ] ;
24708: LD_ADDR_VAR 0 7
24712: PUSH
24713: EMPTY
24714: ST_TO_ADDR
// SetTag ( i , 1 ) ;
24715: LD_VAR 0 1
24719: PPUSH
24720: LD_INT 1
24722: PPUSH
24723: CALL_OW 109
// ComExitBuilding ( i ) ;
24727: LD_VAR 0 1
24731: PPUSH
24732: CALL_OW 122
// for j in xy do
24736: LD_ADDR_VAR 0 2
24740: PUSH
24741: LD_VAR 0 5
24745: PUSH
24746: FOR_IN
24747: IFFALSE 24829
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
24749: LD_VAR 0 1
24753: PPUSH
24754: LD_VAR 0 2
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PPUSH
24763: LD_VAR 0 2
24767: PUSH
24768: LD_INT 2
24770: ARRAY
24771: PPUSH
24772: CALL_OW 297
24776: PUSH
24777: LD_VAR 0 8
24781: LESS
24782: IFFALSE 24827
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
24784: LD_ADDR_VAR 0 8
24788: PUSH
24789: LD_VAR 0 1
24793: PPUSH
24794: LD_VAR 0 2
24798: PUSH
24799: LD_INT 1
24801: ARRAY
24802: PPUSH
24803: LD_VAR 0 2
24807: PUSH
24808: LD_INT 2
24810: ARRAY
24811: PPUSH
24812: CALL_OW 297
24816: ST_TO_ADDR
// _xy := j ;
24817: LD_ADDR_VAR 0 7
24821: PUSH
24822: LD_VAR 0 2
24826: ST_TO_ADDR
// end ;
24827: GO 24746
24829: POP
24830: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
24831: LD_VAR 0 1
24835: PPUSH
24836: LD_VAR 0 7
24840: PUSH
24841: LD_INT 1
24843: ARRAY
24844: PPUSH
24845: LD_VAR 0 7
24849: PUSH
24850: LD_INT 2
24852: ARRAY
24853: PPUSH
24854: CALL_OW 171
// end ;
24858: GO 24697
24860: POP
24861: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
24862: LD_ADDR_VAR 0 4
24866: PUSH
24867: LD_VAR 0 3
24871: PPUSH
24872: LD_INT 26
24874: PUSH
24875: LD_INT 1
24877: PUSH
24878: EMPTY
24879: LIST
24880: LIST
24881: PUSH
24882: LD_INT 25
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: EMPTY
24889: LIST
24890: LIST
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PPUSH
24896: CALL_OW 72
24900: ST_TO_ADDR
// if tmp2 < 2 then
24901: LD_VAR 0 4
24905: PUSH
24906: LD_INT 2
24908: LESS
24909: IFFALSE 24978
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
24911: LD_ADDR_VAR 0 4
24915: PUSH
24916: LD_INT 22
24918: PUSH
24919: LD_INT 8
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 26
24928: PUSH
24929: LD_INT 1
24931: PUSH
24932: EMPTY
24933: LIST
24934: LIST
24935: PUSH
24936: LD_INT 3
24938: PUSH
24939: LD_INT 25
24941: PUSH
24942: LD_INT 15
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: EMPTY
24954: LIST
24955: LIST
24956: LIST
24957: PPUSH
24958: CALL_OW 69
24962: PUSH
24963: LD_EXP 61
24967: PUSH
24968: LD_EXP 62
24972: PUSH
24973: EMPTY
24974: LIST
24975: LIST
24976: DIFF
24977: ST_TO_ADDR
// if tmp2 then
24978: LD_VAR 0 4
24982: IFFALSE 25000
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
24984: LD_VAR 0 4
24988: PUSH
24989: LD_INT 1
24991: ARRAY
24992: PPUSH
24993: LD_STRING D6b-ArSol1-1
24995: PPUSH
24996: CALL_OW 88
// async ;
25000: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
25001: LD_EXP 59
25005: PPUSH
25006: LD_STRING D6b-Pow-2
25008: PPUSH
25009: CALL_OW 88
// wait ( 0 0$0.5 ) ;
25013: LD_INT 18
25015: PPUSH
25016: CALL_OW 67
// if tmp2 > 1 then
25020: LD_VAR 0 4
25024: PUSH
25025: LD_INT 1
25027: GREATER
25028: IFFALSE 25046
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
25030: LD_VAR 0 4
25034: PUSH
25035: LD_INT 2
25037: ARRAY
25038: PPUSH
25039: LD_STRING D6b-ArSol2-1
25041: PPUSH
25042: CALL_OW 88
// sync ;
25046: SYNC
// repeat wait ( 5 ) ;
25047: LD_INT 5
25049: PPUSH
25050: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
25054: LD_INT 93
25056: PPUSH
25057: LD_INT 36
25059: PPUSH
25060: CALL_OW 428
25064: PPUSH
25065: CALL_OW 255
25069: PUSH
25070: LD_INT 4
25072: EQUAL
25073: IFFALSE 25047
// DialogueOn ;
25075: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
25079: LD_INT 10
25081: PPUSH
25082: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
25086: LD_EXP 59
25090: PPUSH
25091: LD_STRING D6b-Pow-2a
25093: PPUSH
25094: CALL_OW 88
// DialogueOff ;
25098: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
25102: LD_EXP 59
25106: PPUSH
25107: CALL_OW 310
25111: PPUSH
25112: LD_INT 332
25114: PPUSH
25115: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
25119: LD_INT 93
25121: PPUSH
25122: LD_INT 35
25124: PPUSH
25125: LD_INT 1
25127: PPUSH
25128: LD_INT 6
25130: NEG
25131: PPUSH
25132: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
25136: LD_INT 35
25138: PPUSH
25139: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
25143: LD_INT 332
25145: PPUSH
25146: CALL_OW 256
25150: PUSH
25151: LD_INT 1000
25153: LESS
25154: PUSH
25155: LD_INT 332
25157: PPUSH
25158: CALL_OW 300
25162: AND
25163: IFFALSE 25175
// SetLives ( kozlov_fac , 0 ) ;
25165: LD_INT 332
25167: PPUSH
25168: LD_INT 0
25170: PPUSH
25171: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
25175: LD_INT 332
25177: PPUSH
25178: CALL_OW 301
25182: PUSH
25183: LD_EXP 59
25187: PPUSH
25188: CALL_OW 301
25192: OR
25193: IFFALSE 25136
// game_speed := 4 ;
25195: LD_ADDR_OWVAR 65
25199: PUSH
25200: LD_INT 4
25202: ST_TO_ADDR
// powellCenterCameraMode := false ;
25203: LD_ADDR_EXP 20
25207: PUSH
25208: LD_INT 0
25210: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25211: LD_ADDR_VAR 0 1
25215: PUSH
25216: LD_VAR 0 3
25220: PUSH
25221: LD_INT 22
25223: PUSH
25224: LD_INT 8
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: LD_INT 25
25233: PUSH
25234: LD_INT 2
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: PUSH
25241: EMPTY
25242: LIST
25243: LIST
25244: PPUSH
25245: CALL_OW 69
25249: UNION
25250: PUSH
25251: FOR_IN
25252: IFFALSE 25268
// SetTag ( i , 0 ) ;
25254: LD_VAR 0 1
25258: PPUSH
25259: LD_INT 0
25261: PPUSH
25262: CALL_OW 109
25266: GO 25251
25268: POP
25269: POP
// wait ( 0 0$3 ) ;
25270: LD_INT 105
25272: PPUSH
25273: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
25277: LD_INT 93
25279: PPUSH
25280: LD_INT 35
25282: PPUSH
25283: LD_INT 1
25285: PPUSH
25286: CALL_OW 331
// DialogueOn ;
25290: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
25294: LD_VAR 0 11
25298: PPUSH
25299: LD_STRING D6c-Sol3-1
25301: PPUSH
25302: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
25306: LD_INT 10
25308: PPUSH
25309: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
25313: LD_EXP 40
25317: PPUSH
25318: LD_STRING D6c-JMM-1
25320: PPUSH
25321: CALL_OW 88
// if Cyrus then
25325: LD_EXP 46
25329: IFFALSE 25343
// Say ( Cyrus , D6c-Cyrus-1 ) ;
25331: LD_EXP 46
25335: PPUSH
25336: LD_STRING D6c-Cyrus-1
25338: PPUSH
25339: CALL_OW 88
// if Bobby then
25343: LD_EXP 45
25347: IFFALSE 25361
// Say ( Bobby , D6c-Bobby-1 ) ;
25349: LD_EXP 45
25353: PPUSH
25354: LD_STRING D6c-Bobby-1
25356: PPUSH
25357: CALL_OW 88
// if Cornel then
25361: LD_EXP 51
25365: IFFALSE 25379
// Say ( Cornel , D6c-Corn-1 ) ;
25367: LD_EXP 51
25371: PPUSH
25372: LD_STRING D6c-Corn-1
25374: PPUSH
25375: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
25379: LD_ADDR_VAR 0 4
25383: PUSH
25384: LD_INT 2
25386: PUSH
25387: LD_INT 22
25389: PUSH
25390: LD_INT 1
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 22
25399: PUSH
25400: LD_INT 4
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 26
25414: PUSH
25415: LD_INT 1
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: LD_INT 23
25424: PUSH
25425: LD_INT 1
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: LIST
25436: PPUSH
25437: CALL_OW 69
25441: PUSH
25442: LD_VAR 0 11
25446: PUSH
25447: LD_EXP 40
25451: UNION
25452: PUSH
25453: LD_EXP 60
25457: UNION
25458: DIFF
25459: ST_TO_ADDR
// if tmp2 then
25460: LD_VAR 0 4
25464: IFFALSE 25482
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
25466: LD_VAR 0 4
25470: PUSH
25471: LD_INT 1
25473: ARRAY
25474: PPUSH
25475: LD_STRING D6c-Sol1-1
25477: PPUSH
25478: CALL_OW 88
// if Lisa then
25482: LD_EXP 43
25486: IFFALSE 25500
// Say ( Lisa , D6c-Lisa-1 ) ;
25488: LD_EXP 43
25492: PPUSH
25493: LD_STRING D6c-Lisa-1
25495: PPUSH
25496: CALL_OW 88
// if Gary then
25500: LD_EXP 52
25504: IFFALSE 25518
// Say ( Gary , D6c-Gary-1 ) ;
25506: LD_EXP 52
25510: PPUSH
25511: LD_STRING D6c-Gary-1
25513: PPUSH
25514: CALL_OW 88
// if Donaldson then
25518: LD_EXP 44
25522: IFFALSE 25536
// Say ( Donaldson , D6c-Don-1 ) ;
25524: LD_EXP 44
25528: PPUSH
25529: LD_STRING D6c-Don-1
25531: PPUSH
25532: CALL_OW 88
// if tmp2 > 1 then
25536: LD_VAR 0 4
25540: PUSH
25541: LD_INT 1
25543: GREATER
25544: IFFALSE 25562
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
25546: LD_VAR 0 4
25550: PUSH
25551: LD_INT 2
25553: ARRAY
25554: PPUSH
25555: LD_STRING D6c-Sol2-1
25557: PPUSH
25558: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
25562: LD_VAR 0 11
25566: PPUSH
25567: LD_STRING D6c-Sol3-2
25569: PPUSH
25570: CALL_OW 88
// if IsInUnit ( JMM ) then
25574: LD_EXP 40
25578: PPUSH
25579: CALL_OW 310
25583: IFFALSE 25601
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
25585: LD_EXP 40
25589: PPUSH
25590: CALL_OW 310
25594: PPUSH
25595: CALL_OW 87
25599: GO 25610
// CenterNowOnUnits ( JMM ) ;
25601: LD_EXP 40
25605: PPUSH
25606: CALL_OW 87
// dwait ( 0 0$2 ) ;
25610: LD_INT 70
25612: PPUSH
25613: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
25617: LD_EXP 40
25621: PPUSH
25622: LD_STRING D6c-JMM-2
25624: PPUSH
25625: CALL_OW 88
// DialogueOff ;
25629: CALL_OW 7
// Video ( false ) ;
25633: LD_INT 0
25635: PPUSH
25636: CALL 104616 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
25640: LD_INT 22
25642: PUSH
25643: LD_INT 4
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PPUSH
25650: CALL_OW 69
25654: PPUSH
25655: LD_INT 1
25657: PPUSH
25658: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
25662: LD_INT 4
25664: PPUSH
25665: LD_INT 4
25667: PPUSH
25668: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
25672: LD_ADDR_VAR 0 1
25676: PUSH
25677: LD_INT 4
25679: PPUSH
25680: LD_INT 1
25682: PPUSH
25683: LD_INT 2
25685: PPUSH
25686: CALL 67258 0 3
25690: PUSH
25691: FOR_IN
25692: IFFALSE 25729
// if GetTech ( i , 1 ) <> state_researched then
25694: LD_VAR 0 1
25698: PPUSH
25699: LD_INT 1
25701: PPUSH
25702: CALL_OW 321
25706: PUSH
25707: LD_INT 2
25709: NONEQUAL
25710: IFFALSE 25727
// SetTech ( i , 1 , state_researched ) ;
25712: LD_VAR 0 1
25716: PPUSH
25717: LD_INT 1
25719: PPUSH
25720: LD_INT 2
25722: PPUSH
25723: CALL_OW 322
25727: GO 25691
25729: POP
25730: POP
// missionStage := 6 ;
25731: LD_ADDR_EXP 15
25735: PUSH
25736: LD_INT 6
25738: ST_TO_ADDR
// activeAttacks := true ;
25739: LD_ADDR_EXP 16
25743: PUSH
25744: LD_INT 1
25746: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
25747: LD_STRING M2
25749: PPUSH
25750: CALL_OW 337
// SaveForQuickRestart ;
25754: CALL_OW 22
// wait ( 0 0$40 ) ;
25758: LD_INT 1400
25760: PPUSH
25761: CALL_OW 67
// DialogueOn ;
25765: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
25769: LD_EXP 63
25773: PPUSH
25774: LD_STRING D7-Friend-1
25776: PPUSH
25777: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
25781: LD_EXP 40
25785: PPUSH
25786: LD_STRING D7-JMM-1
25788: PPUSH
25789: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
25793: LD_EXP 63
25797: PPUSH
25798: LD_STRING D7-Friend-2
25800: PPUSH
25801: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
25805: LD_EXP 40
25809: PPUSH
25810: LD_STRING D7-JMM-2
25812: PPUSH
25813: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
25817: LD_EXP 63
25821: PPUSH
25822: LD_STRING D7-Friend-3
25824: PPUSH
25825: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
25829: LD_EXP 40
25833: PPUSH
25834: LD_STRING D7-JMM-3
25836: PPUSH
25837: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
25841: LD_EXP 63
25845: PPUSH
25846: LD_STRING D7-Friend-4
25848: PPUSH
25849: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
25853: LD_EXP 40
25857: PPUSH
25858: LD_STRING D7-JMM-4
25860: PPUSH
25861: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
25865: LD_EXP 63
25869: PPUSH
25870: LD_STRING D7-Friend-5
25872: PPUSH
25873: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
25877: LD_EXP 40
25881: PPUSH
25882: LD_STRING D7-JMM-5
25884: PPUSH
25885: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
25889: LD_EXP 63
25893: PPUSH
25894: LD_STRING D7-Friend-6
25896: PPUSH
25897: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
25901: LD_EXP 40
25905: PPUSH
25906: LD_STRING D7-JMM-6
25908: PPUSH
25909: CALL_OW 88
// DialogueOff ;
25913: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
25917: LD_STRING Mlegion
25919: PPUSH
25920: CALL_OW 337
// skirmish := true ;
25924: LD_ADDR_EXP 97
25928: PUSH
25929: LD_INT 1
25931: ST_TO_ADDR
// RebuildKozlovFactory ;
25932: CALL 4920 0 0
// end ;
25936: PPOPN 13
25938: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
25939: LD_EXP 20
25943: PUSH
25944: LD_EXP 59
25948: PPUSH
25949: CALL_OW 300
25953: AND
25954: IFFALSE 25996
25956: GO 25958
25958: DISABLE
// begin enable ;
25959: ENABLE
// if IsInUnit ( Powell ) then
25960: LD_EXP 59
25964: PPUSH
25965: CALL_OW 310
25969: IFFALSE 25987
// CenterOnUnits ( IsInUnit ( Powell ) ) else
25971: LD_EXP 59
25975: PPUSH
25976: CALL_OW 310
25980: PPUSH
25981: CALL_OW 85
25985: GO 25996
// CenterOnUnits ( Powell ) ;
25987: LD_EXP 59
25991: PPUSH
25992: CALL_OW 85
// end ;
25996: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
25997: LD_INT 22
25999: PUSH
26000: LD_INT 8
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 34
26009: PUSH
26010: LD_INT 48
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PPUSH
26021: CALL_OW 69
26025: IFFALSE 26299
26027: GO 26029
26029: DISABLE
26030: LD_INT 0
26032: PPUSH
26033: PPUSH
// begin if missionStage < 9 then
26034: LD_EXP 15
26038: PUSH
26039: LD_INT 9
26041: LESS
26042: IFFALSE 26052
// missionStage := 9 ;
26044: LD_ADDR_EXP 15
26048: PUSH
26049: LD_INT 9
26051: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
26052: LD_ADDR_VAR 0 1
26056: PUSH
26057: LD_INT 22
26059: PUSH
26060: LD_INT 8
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 34
26069: PUSH
26070: LD_INT 48
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PPUSH
26081: CALL_OW 69
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: ST_TO_ADDR
// wait ( 0 0$05 ) ;
26090: LD_INT 175
26092: PPUSH
26093: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
26097: LD_EXP 12
26101: PUSH
26102: LD_EXP 3
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 2
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: IN
26117: OR
26118: IFFALSE 26141
// target := [ 68 , 108 , 1 ] else
26120: LD_ADDR_VAR 0 2
26124: PUSH
26125: LD_INT 68
26127: PUSH
26128: LD_INT 108
26130: PUSH
26131: LD_INT 1
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: LIST
26138: ST_TO_ADDR
26139: GO 26160
// target := [ 181 , 88 , 2 ] ;
26141: LD_ADDR_VAR 0 2
26145: PUSH
26146: LD_INT 181
26148: PUSH
26149: LD_INT 88
26151: PUSH
26152: LD_INT 2
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: LIST
26159: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
26160: LD_VAR 0 1
26164: PPUSH
26165: LD_VAR 0 2
26169: PUSH
26170: LD_INT 1
26172: ARRAY
26173: PPUSH
26174: LD_VAR 0 2
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 176
// if target [ 3 ] = 1 then
26187: LD_VAR 0 2
26191: PUSH
26192: LD_INT 3
26194: ARRAY
26195: PUSH
26196: LD_INT 1
26198: EQUAL
26199: IFFALSE 26215
// SayRadio ( Kurt , D12-Kurt-1 ) else
26201: LD_EXP 61
26205: PPUSH
26206: LD_STRING D12-Kurt-1
26208: PPUSH
26209: CALL_OW 94
26213: GO 26239
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
26215: LD_EXP 61
26219: PPUSH
26220: LD_STRING D12a-Kurt-1
26222: PPUSH
26223: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
26227: LD_EXP 76
26231: PPUSH
26232: LD_STRING D12a-Roth-1
26234: PPUSH
26235: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
26239: LD_INT 350
26241: PPUSH
26242: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
26246: LD_VAR 0 1
26250: PPUSH
26251: LD_INT 22
26253: PUSH
26254: LD_INT 8
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 23
26263: PUSH
26264: LD_INT 2
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 3
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: LIST
26285: PPUSH
26286: CALL_OW 69
26290: PUSH
26291: LD_INT 1
26293: ARRAY
26294: PPUSH
26295: CALL_OW 228
// end ;
26299: PPOPN 2
26301: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
26302: LD_EXP 61
26306: PPUSH
26307: CALL_OW 256
26311: PUSH
26312: LD_INT 999
26314: LESS
26315: PUSH
26316: LD_INT 22
26318: PUSH
26319: LD_INT 8
26321: PUSH
26322: EMPTY
26323: LIST
26324: LIST
26325: PUSH
26326: LD_INT 21
26328: PUSH
26329: LD_INT 1
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 23
26338: PUSH
26339: LD_INT 2
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 69
26355: PUSH
26356: LD_INT 9
26358: PUSH
26359: LD_INT 8
26361: PUSH
26362: LD_INT 7
26364: PUSH
26365: LD_INT 6
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: PUSH
26374: LD_OWVAR 67
26378: ARRAY
26379: LESSEQUAL
26380: OR
26381: PUSH
26382: LD_INT 22
26384: PUSH
26385: LD_INT 8
26387: PUSH
26388: EMPTY
26389: LIST
26390: LIST
26391: PUSH
26392: LD_INT 34
26394: PUSH
26395: LD_INT 48
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PPUSH
26406: CALL_OW 69
26410: NOT
26411: AND
26412: PUSH
26413: LD_EXP 61
26417: PPUSH
26418: CALL_OW 302
26422: AND
26423: PUSH
26424: LD_INT 5
26426: PPUSH
26427: LD_INT 22
26429: PUSH
26430: LD_INT 1
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PPUSH
26437: CALL_OW 70
26441: AND
26442: IFFALSE 27186
26444: GO 26446
26446: DISABLE
26447: LD_INT 0
26449: PPUSH
26450: PPUSH
26451: PPUSH
// begin legionDestroyed := true ;
26452: LD_ADDR_EXP 22
26456: PUSH
26457: LD_INT 1
26459: ST_TO_ADDR
// DialogueOn ;
26460: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
26464: LD_EXP 40
26468: PPUSH
26469: LD_STRING D13-JMM-1
26471: PPUSH
26472: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
26476: LD_EXP 61
26480: PPUSH
26481: LD_STRING D13-Kurt-1
26483: PPUSH
26484: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
26488: LD_EXP 40
26492: PPUSH
26493: LD_STRING D13-JMM-2
26495: PPUSH
26496: CALL_OW 88
// if FakeInfo then
26500: LD_EXP 12
26504: IFFALSE 26524
// begin Say ( Kurt , D13-Kurt-2 ) ;
26506: LD_EXP 61
26510: PPUSH
26511: LD_STRING D13-Kurt-2
26513: PPUSH
26514: CALL_OW 88
// DialogueOff ;
26518: CALL_OW 7
// exit ;
26522: GO 27186
// end ; if not KurtStatus then
26524: LD_EXP 3
26528: NOT
26529: IFFALSE 26545
// Say ( Kurt , D13-Kurt-2b ) else
26531: LD_EXP 61
26535: PPUSH
26536: LD_STRING D13-Kurt-2b
26538: PPUSH
26539: CALL_OW 88
26543: GO 26557
// Say ( Kurt , D13-Kurt-2a ) ;
26545: LD_EXP 61
26549: PPUSH
26550: LD_STRING D13-Kurt-2a
26552: PPUSH
26553: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
26557: LD_EXP 40
26561: PPUSH
26562: LD_STRING D13-JMM-3
26564: PPUSH
26565: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
26569: LD_EXP 61
26573: PPUSH
26574: LD_STRING D13-Kurt-3
26576: PPUSH
26577: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
26581: LD_EXP 40
26585: PPUSH
26586: LD_STRING D13-JMM-4
26588: PPUSH
26589: CALL_OW 88
// DialogueOff ;
26593: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
26597: LD_STRING MlegionOut
26599: PPUSH
26600: CALL_OW 337
// MC_Kill ( 3 ) ;
26604: LD_INT 3
26606: PPUSH
26607: CALL 36780 0 1
// KillUnit ( Kozlov ) ;
26611: LD_EXP 62
26615: PPUSH
26616: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
26620: LD_ADDR_VAR 0 1
26624: PUSH
26625: LD_INT 22
26627: PUSH
26628: LD_INT 8
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 23
26637: PUSH
26638: LD_INT 3
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 3
26647: PUSH
26648: LD_INT 21
26650: PUSH
26651: LD_INT 33
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: PPUSH
26667: CALL_OW 69
26671: PUSH
26672: FOR_IN
26673: IFFALSE 26686
// KillUnit ( i ) ;
26675: LD_VAR 0 1
26679: PPUSH
26680: CALL_OW 66
26684: GO 26672
26686: POP
26687: POP
// ChangeSideFog ( 8 , 1 ) ;
26688: LD_INT 8
26690: PPUSH
26691: LD_INT 1
26693: PPUSH
26694: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
26698: LD_ADDR_VAR 0 2
26702: PUSH
26703: LD_INT 22
26705: PUSH
26706: LD_INT 8
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: PUSH
26713: LD_INT 21
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: EMPTY
26720: LIST
26721: LIST
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PPUSH
26727: CALL_OW 69
26731: PUSH
26732: LD_EXP 62
26736: PUSH
26737: LD_EXP 61
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: DIFF
26746: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
26747: LD_VAR 0 2
26751: PUSH
26752: LD_INT 6
26754: PUSH
26755: LD_INT 5
26757: PUSH
26758: LD_INT 4
26760: PUSH
26761: LD_INT 3
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: PUSH
26770: LD_OWVAR 67
26774: ARRAY
26775: GREATEREQUAL
26776: IFFALSE 26928
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
26778: LD_ADDR_VAR 0 3
26782: PUSH
26783: LD_INT 6
26785: PUSH
26786: LD_INT 5
26788: PUSH
26789: LD_INT 4
26791: PUSH
26792: LD_INT 3
26794: PUSH
26795: EMPTY
26796: LIST
26797: LIST
26798: LIST
26799: LIST
26800: PUSH
26801: LD_OWVAR 67
26805: ARRAY
26806: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
26807: LD_ADDR_VAR 0 1
26811: PUSH
26812: DOUBLE
26813: LD_VAR 0 2
26817: PUSH
26818: LD_VAR 0 3
26822: PUSH
26823: LD_INT 1
26825: PLUS
26826: MINUS
26827: INC
26828: ST_TO_ADDR
26829: LD_INT 1
26831: PUSH
26832: FOR_DOWNTO
26833: IFFALSE 26924
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
26835: LD_ADDR_EXP 38
26839: PUSH
26840: LD_EXP 38
26844: PUSH
26845: LD_VAR 0 2
26849: PUSH
26850: LD_VAR 0 1
26854: ARRAY
26855: ADD
26856: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
26857: LD_VAR 0 2
26861: PUSH
26862: LD_VAR 0 1
26866: ARRAY
26867: PPUSH
26868: CALL_OW 310
26872: IFFALSE 26889
// ComExit ( tmp [ i ] ) ;
26874: LD_VAR 0 2
26878: PUSH
26879: LD_VAR 0 1
26883: ARRAY
26884: PPUSH
26885: CALL 105042 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
26889: LD_VAR 0 2
26893: PUSH
26894: LD_VAR 0 1
26898: ARRAY
26899: PPUSH
26900: LD_INT 34
26902: PUSH
26903: LD_INT 0
26905: PPUSH
26906: LD_INT 6
26908: PPUSH
26909: CALL_OW 12
26913: PLUS
26914: PPUSH
26915: LD_INT 1
26917: PPUSH
26918: CALL_OW 171
// end ;
26922: GO 26832
26924: POP
26925: POP
// end else
26926: GO 26938
// x := tmp ;
26928: LD_ADDR_VAR 0 3
26932: PUSH
26933: LD_VAR 0 2
26937: ST_TO_ADDR
// for i := tmp downto tmp - x do
26938: LD_ADDR_VAR 0 1
26942: PUSH
26943: DOUBLE
26944: LD_VAR 0 2
26948: INC
26949: ST_TO_ADDR
26950: LD_VAR 0 2
26954: PUSH
26955: LD_VAR 0 3
26959: MINUS
26960: PUSH
26961: FOR_DOWNTO
26962: IFFALSE 27016
// begin if IsInUnit ( tmp [ i ] ) then
26964: LD_VAR 0 2
26968: PUSH
26969: LD_VAR 0 1
26973: ARRAY
26974: PPUSH
26975: CALL_OW 310
26979: IFFALSE 26996
// ComExit ( tmp [ i ] ) ;
26981: LD_VAR 0 2
26985: PUSH
26986: LD_VAR 0 1
26990: ARRAY
26991: PPUSH
26992: CALL 105042 0 1
// SetSide ( tmp [ i ] , 1 ) ;
26996: LD_VAR 0 2
27000: PUSH
27001: LD_VAR 0 1
27005: ARRAY
27006: PPUSH
27007: LD_INT 1
27009: PPUSH
27010: CALL_OW 235
// end ;
27014: GO 26961
27016: POP
27017: POP
// wait ( 0 0$0.3 ) ;
27018: LD_INT 10
27020: PPUSH
27021: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
27025: LD_ADDR_VAR 0 1
27029: PUSH
27030: LD_INT 22
27032: PUSH
27033: LD_INT 8
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 21
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PPUSH
27054: CALL_OW 69
27058: PUSH
27059: FOR_IN
27060: IFFALSE 27073
// KillUnit ( i ) ;
27062: LD_VAR 0 1
27066: PPUSH
27067: CALL_OW 66
27071: GO 27059
27073: POP
27074: POP
// SetSide ( Kurt , 1 ) ;
27075: LD_EXP 61
27079: PPUSH
27080: LD_INT 1
27082: PPUSH
27083: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
27087: LD_INT 22
27089: PUSH
27090: LD_INT 8
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PUSH
27097: LD_INT 21
27099: PUSH
27100: LD_INT 3
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PPUSH
27111: CALL_OW 69
27115: PPUSH
27116: LD_INT 1
27118: PPUSH
27119: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
27123: LD_INT 8
27125: PPUSH
27126: LD_INT 1
27128: PPUSH
27129: LD_INT 1
27131: PPUSH
27132: LD_INT 1
27134: PPUSH
27135: CALL_OW 80
// wait ( 1 1$20 ) ;
27139: LD_INT 2800
27141: PPUSH
27142: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
27146: LD_EXP 63
27150: PPUSH
27151: LD_INT 37
27153: PPUSH
27154: LD_INT 1
27156: PPUSH
27157: LD_INT 0
27159: PPUSH
27160: CALL_OW 48
// wait ( 0 0$1 ) ;
27164: LD_INT 35
27166: PPUSH
27167: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
27171: LD_EXP 63
27175: PPUSH
27176: LD_INT 60
27178: PPUSH
27179: LD_INT 95
27181: PPUSH
27182: CALL_OW 111
// end ;
27186: PPOPN 3
27188: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
27189: LD_EXP 22
27193: NOT
27194: PUSH
27195: LD_INT 22
27197: PUSH
27198: LD_INT 8
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 21
27207: PUSH
27208: LD_INT 1
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PPUSH
27219: CALL_OW 69
27223: PUSH
27224: LD_INT 0
27226: EQUAL
27227: AND
27228: IFFALSE 27248
27230: GO 27232
27232: DISABLE
// begin legionDestroyed := true ;
27233: LD_ADDR_EXP 22
27237: PUSH
27238: LD_INT 1
27240: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
27241: LD_STRING MlegionOut
27243: PPUSH
27244: CALL_OW 337
// end ;
27248: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
27249: LD_EXP 38
27253: IFFALSE 27328
27255: GO 27257
27257: DISABLE
27258: LD_INT 0
27260: PPUSH
// begin enable ;
27261: ENABLE
// for i in legionEscapeUnits do
27262: LD_ADDR_VAR 0 1
27266: PUSH
27267: LD_EXP 38
27271: PUSH
27272: FOR_IN
27273: IFFALSE 27326
// begin if IsInArea ( i , legionEscapeArea ) then
27275: LD_VAR 0 1
27279: PPUSH
27280: LD_INT 31
27282: PPUSH
27283: CALL_OW 308
27287: IFFALSE 27300
// RemoveUnit ( i ) else
27289: LD_VAR 0 1
27293: PPUSH
27294: CALL_OW 64
27298: GO 27324
// if not HasTask ( i ) then
27300: LD_VAR 0 1
27304: PPUSH
27305: CALL_OW 314
27309: NOT
27310: IFFALSE 27324
// ComMoveToArea ( i , legionEscapeArea ) ;
27312: LD_VAR 0 1
27316: PPUSH
27317: LD_INT 31
27319: PPUSH
27320: CALL_OW 113
// end ;
27324: GO 27272
27326: POP
27327: POP
// end ;
27328: PPOPN 1
27330: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
27331: LD_INT 1
27333: PPUSH
27334: LD_EXP 63
27338: PPUSH
27339: CALL_OW 292
27343: IFFALSE 27641
27345: GO 27347
27347: DISABLE
27348: LD_INT 0
27350: PPUSH
// begin wait ( 0 0$2 ) ;
27351: LD_INT 70
27353: PPUSH
27354: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27358: LD_EXP 63
27362: PPUSH
27363: CALL_OW 87
// DialogueOn ;
27367: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
27371: LD_EXP 40
27375: PPUSH
27376: LD_STRING D14-JMM-1
27378: PPUSH
27379: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
27383: LD_EXP 63
27387: PPUSH
27388: LD_STRING D14-Friend-1
27390: PPUSH
27391: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
27395: LD_EXP 40
27399: PPUSH
27400: LD_STRING D14-JMM-2
27402: PPUSH
27403: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
27407: LD_EXP 63
27411: PPUSH
27412: LD_STRING D14-Friend-2
27414: PPUSH
27415: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
27419: LD_EXP 40
27423: PPUSH
27424: LD_STRING D14-JMM-3
27426: PPUSH
27427: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
27431: LD_EXP 63
27435: PPUSH
27436: LD_STRING D14-Friend-3
27438: PPUSH
27439: CALL_OW 88
// DialogueOff ;
27443: CALL_OW 7
// dec = Query ( Q14 ) ;
27447: LD_ADDR_VAR 0 1
27451: PUSH
27452: LD_STRING Q14
27454: PPUSH
27455: CALL_OW 97
27459: ST_TO_ADDR
// if dec = 1 then
27460: LD_VAR 0 1
27464: PUSH
27465: LD_INT 1
27467: EQUAL
27468: IFFALSE 27502
// begin DialogueOn ;
27470: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
27474: LD_EXP 40
27478: PPUSH
27479: LD_STRING D14a-JMM-1
27481: PPUSH
27482: CALL_OW 88
// DialogueOff ;
27486: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27490: LD_EXP 63
27494: PPUSH
27495: LD_INT 1
27497: PPUSH
27498: CALL_OW 235
// end ; if dec = 2 then
27502: LD_VAR 0 1
27506: PUSH
27507: LD_INT 2
27509: EQUAL
27510: IFFALSE 27563
// begin DialogueOn ;
27512: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
27516: LD_EXP 40
27520: PPUSH
27521: LD_STRING D14b-JMM-1
27523: PPUSH
27524: CALL_OW 88
// DialogueOff ;
27528: CALL_OW 7
// wait ( 0 0$1 ) ;
27532: LD_INT 35
27534: PPUSH
27535: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
27539: LD_EXP 63
27543: PPUSH
27544: LD_INT 9
27546: PPUSH
27547: LD_INT 2
27549: PPUSH
27550: CALL_OW 111
// AddComHold ( Friend ) ;
27554: LD_EXP 63
27558: PPUSH
27559: CALL_OW 200
// end ; if dec = 3 then
27563: LD_VAR 0 1
27567: PUSH
27568: LD_INT 3
27570: EQUAL
27571: IFFALSE 27641
// begin DialogueOn ;
27573: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
27577: LD_EXP 40
27581: PPUSH
27582: LD_STRING D14c-JMM-1
27584: PPUSH
27585: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
27589: LD_EXP 63
27593: PPUSH
27594: LD_STRING D14c-Friend-1
27596: PPUSH
27597: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
27601: LD_EXP 40
27605: PPUSH
27606: LD_STRING D14c-JMM-2
27608: PPUSH
27609: CALL_OW 88
// DialogueOff ;
27613: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
27617: LD_EXP 63
27621: PPUSH
27622: LD_INT 9
27624: PPUSH
27625: LD_INT 2
27627: PPUSH
27628: CALL_OW 111
// AddComHold ( Friend ) ;
27632: LD_EXP 63
27636: PPUSH
27637: CALL_OW 200
// end ; end ;
27641: PPOPN 1
27643: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
27644: LD_INT 9
27646: PPUSH
27647: LD_INT 2
27649: PPUSH
27650: CALL_OW 428
27654: PUSH
27655: LD_EXP 63
27659: EQUAL
27660: PUSH
27661: LD_EXP 63
27665: PPUSH
27666: CALL_OW 255
27670: PUSH
27671: LD_INT 8
27673: EQUAL
27674: AND
27675: IFFALSE 27689
27677: GO 27679
27679: DISABLE
// RemoveUnit ( Friend ) ;
27680: LD_EXP 63
27684: PPUSH
27685: CALL_OW 64
27689: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
27690: LD_EXP 14
27694: PUSH
27695: LD_INT 31500
27697: GREATEREQUAL
27698: PUSH
27699: LD_EXP 7
27703: AND
27704: PUSH
27705: LD_EXP 2
27709: AND
27710: IFFALSE 28140
27712: GO 27714
27714: DISABLE
27715: LD_INT 0
27717: PPUSH
27718: PPUSH
27719: PPUSH
// begin missionStage := 7 ;
27720: LD_ADDR_EXP 15
27724: PUSH
27725: LD_INT 7
27727: ST_TO_ADDR
// uc_side = 1 ;
27728: LD_ADDR_OWVAR 20
27732: PUSH
27733: LD_INT 1
27735: ST_TO_ADDR
// uc_nation = 1 ;
27736: LD_ADDR_OWVAR 21
27740: PUSH
27741: LD_INT 1
27743: ST_TO_ADDR
// for i = 1 to 5 do
27744: LD_ADDR_VAR 0 1
27748: PUSH
27749: DOUBLE
27750: LD_INT 1
27752: DEC
27753: ST_TO_ADDR
27754: LD_INT 5
27756: PUSH
27757: FOR_TO
27758: IFFALSE 27854
// begin vc_engine = 3 ;
27760: LD_ADDR_OWVAR 39
27764: PUSH
27765: LD_INT 3
27767: ST_TO_ADDR
// vc_control = 3 ;
27768: LD_ADDR_OWVAR 38
27772: PUSH
27773: LD_INT 3
27775: ST_TO_ADDR
// vc_chassis = 3 ;
27776: LD_ADDR_OWVAR 37
27780: PUSH
27781: LD_INT 3
27783: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27784: LD_ADDR_OWVAR 40
27788: PUSH
27789: LD_INT 5
27791: PUSH
27792: LD_INT 9
27794: PUSH
27795: LD_INT 7
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: PPUSH
27806: LD_INT 3
27808: PPUSH
27809: CALL_OW 12
27813: ARRAY
27814: ST_TO_ADDR
// veh = CreateVehicle ;
27815: LD_ADDR_VAR 0 2
27819: PUSH
27820: CALL_OW 45
27824: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
27825: LD_VAR 0 2
27829: PPUSH
27830: LD_INT 1
27832: PPUSH
27833: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
27837: LD_VAR 0 2
27841: PPUSH
27842: LD_INT 19
27844: PPUSH
27845: LD_INT 0
27847: PPUSH
27848: CALL_OW 49
// end ;
27852: GO 27757
27854: POP
27855: POP
// vc_engine = 3 ;
27856: LD_ADDR_OWVAR 39
27860: PUSH
27861: LD_INT 3
27863: ST_TO_ADDR
// vc_control = 1 ;
27864: LD_ADDR_OWVAR 38
27868: PUSH
27869: LD_INT 1
27871: ST_TO_ADDR
// vc_chassis = 3 ;
27872: LD_ADDR_OWVAR 37
27876: PUSH
27877: LD_INT 3
27879: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
27880: LD_ADDR_OWVAR 40
27884: PUSH
27885: LD_INT 5
27887: PUSH
27888: LD_INT 9
27890: PUSH
27891: LD_INT 7
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 1
27901: PPUSH
27902: LD_INT 3
27904: PPUSH
27905: CALL_OW 12
27909: ARRAY
27910: ST_TO_ADDR
// vehG = CreateVehicle ;
27911: LD_ADDR_VAR 0 3
27915: PUSH
27916: CALL_OW 45
27920: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
27921: LD_VAR 0 3
27925: PPUSH
27926: LD_INT 1
27928: PPUSH
27929: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
27933: LD_VAR 0 3
27937: PPUSH
27938: LD_INT 19
27940: PPUSH
27941: LD_INT 0
27943: PPUSH
27944: CALL_OW 49
// if JMMGirl = 1 then
27948: LD_EXP 7
27952: PUSH
27953: LD_INT 1
27955: EQUAL
27956: IFFALSE 28012
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
27958: LD_ADDR_EXP 41
27962: PUSH
27963: LD_STRING Joan
27965: PPUSH
27966: LD_INT 1
27968: PPUSH
27969: LD_STRING 14_
27971: PPUSH
27972: CALL 67195 0 3
27976: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
27977: LD_EXP 41
27981: PPUSH
27982: LD_VAR 0 3
27986: PPUSH
27987: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
27991: LD_VAR 0 3
27995: PPUSH
27996: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
28000: LD_EXP 41
28004: PPUSH
28005: LD_STRING D10BW-Joan-1
28007: PPUSH
28008: CALL_OW 94
// end ; if JMMGirl = 2 then
28012: LD_EXP 7
28016: PUSH
28017: LD_INT 2
28019: EQUAL
28020: IFFALSE 28076
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
28022: LD_ADDR_EXP 43
28026: PUSH
28027: LD_STRING Lisa
28029: PPUSH
28030: LD_INT 1
28032: PPUSH
28033: LD_STRING 14_
28035: PPUSH
28036: CALL 67195 0 3
28040: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
28041: LD_EXP 43
28045: PPUSH
28046: LD_VAR 0 3
28050: PPUSH
28051: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28055: LD_VAR 0 3
28059: PPUSH
28060: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
28064: LD_EXP 43
28068: PPUSH
28069: LD_STRING D10BW-Lisa-1
28071: PPUSH
28072: CALL_OW 94
// end ; if JMMGirl = 3 then
28076: LD_EXP 7
28080: PUSH
28081: LD_INT 3
28083: EQUAL
28084: IFFALSE 28140
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
28086: LD_ADDR_EXP 55
28090: PUSH
28091: LD_STRING Connie
28093: PPUSH
28094: LD_INT 1
28096: PPUSH
28097: LD_STRING 14_
28099: PPUSH
28100: CALL 67195 0 3
28104: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
28105: LD_EXP 55
28109: PPUSH
28110: LD_VAR 0 3
28114: PPUSH
28115: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
28119: LD_VAR 0 3
28123: PPUSH
28124: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
28128: LD_EXP 55
28132: PPUSH
28133: LD_STRING D10BW-Con-1
28135: PPUSH
28136: CALL_OW 94
// end ; end ;
28140: PPOPN 3
28142: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
28143: LD_EXP 14
28147: PUSH
28148: LD_INT 94500
28150: GREATEREQUAL
28151: IFFALSE 28563
28153: GO 28155
28155: DISABLE
28156: LD_INT 0
28158: PPUSH
28159: PPUSH
28160: PPUSH
// begin tmp := PrepareStevensSquad ;
28161: LD_ADDR_VAR 0 3
28165: PUSH
28166: CALL 2323 0 0
28170: ST_TO_ADDR
// if not tmp then
28171: LD_VAR 0 3
28175: NOT
28176: IFFALSE 28180
// exit ;
28178: GO 28563
// uc_side := 1 ;
28180: LD_ADDR_OWVAR 20
28184: PUSH
28185: LD_INT 1
28187: ST_TO_ADDR
// uc_nation := 1 ;
28188: LD_ADDR_OWVAR 21
28192: PUSH
28193: LD_INT 1
28195: ST_TO_ADDR
// for i in tmp do
28196: LD_ADDR_VAR 0 1
28200: PUSH
28201: LD_VAR 0 3
28205: PUSH
28206: FOR_IN
28207: IFFALSE 28304
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
28209: LD_INT 3
28211: PPUSH
28212: LD_INT 3
28214: PPUSH
28215: LD_INT 1
28217: PPUSH
28218: LD_INT 5
28220: PUSH
28221: LD_INT 9
28223: PUSH
28224: LD_INT 7
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 1
28234: PPUSH
28235: LD_INT 3
28237: PPUSH
28238: CALL_OW 12
28242: ARRAY
28243: PPUSH
28244: LD_INT 40
28246: PPUSH
28247: CALL 72210 0 5
// veh := CreateVehicle ;
28251: LD_ADDR_VAR 0 2
28255: PUSH
28256: CALL_OW 45
28260: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
28261: LD_VAR 0 2
28265: PPUSH
28266: LD_INT 1
28268: PPUSH
28269: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
28273: LD_VAR 0 2
28277: PPUSH
28278: LD_INT 19
28280: PPUSH
28281: LD_INT 0
28283: PPUSH
28284: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
28288: LD_VAR 0 1
28292: PPUSH
28293: LD_VAR 0 2
28297: PPUSH
28298: CALL_OW 52
// end ;
28302: GO 28206
28304: POP
28305: POP
// missionStage := 8 ;
28306: LD_ADDR_EXP 15
28310: PUSH
28311: LD_INT 8
28313: ST_TO_ADDR
// DialogueOn ;
28314: CALL_OW 6
// if Stevens then
28318: LD_EXP 42
28322: IFFALSE 28436
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
28324: LD_EXP 42
28328: PPUSH
28329: CALL_OW 310
28333: PPUSH
28334: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
28338: LD_EXP 42
28342: PPUSH
28343: LD_STRING D8-Huck-1
28345: PPUSH
28346: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
28350: LD_EXP 40
28354: PPUSH
28355: LD_STRING D8-JMM-1
28357: PPUSH
28358: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
28362: LD_EXP 42
28366: PPUSH
28367: LD_STRING D8-Huck-2
28369: PPUSH
28370: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28374: LD_EXP 40
28378: PPUSH
28379: LD_STRING D8-JMM-2
28381: PPUSH
28382: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
28386: LD_EXP 42
28390: PPUSH
28391: LD_STRING D8-Huck-3
28393: PPUSH
28394: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28398: LD_EXP 40
28402: PPUSH
28403: LD_STRING D8-JMM-3
28405: PPUSH
28406: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
28410: LD_EXP 42
28414: PPUSH
28415: LD_STRING D8-Huck-4
28417: PPUSH
28418: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28422: LD_EXP 40
28426: PPUSH
28427: LD_STRING D8-JMM-4
28429: PPUSH
28430: CALL_OW 88
// end else
28434: GO 28546
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
28436: LD_EXP 56
28440: PPUSH
28441: CALL_OW 310
28445: PPUSH
28446: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
28450: LD_EXP 56
28454: PPUSH
28455: LD_STRING D8-Huck-1
28457: PPUSH
28458: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
28462: LD_EXP 40
28466: PPUSH
28467: LD_STRING D8-JMM-1a
28469: PPUSH
28470: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
28474: LD_EXP 56
28478: PPUSH
28479: LD_STRING D8-Huck-2
28481: PPUSH
28482: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
28486: LD_EXP 40
28490: PPUSH
28491: LD_STRING D8-JMM-2
28493: PPUSH
28494: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
28498: LD_EXP 56
28502: PPUSH
28503: LD_STRING D8-Huck-3
28505: PPUSH
28506: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
28510: LD_EXP 40
28514: PPUSH
28515: LD_STRING D8-JMM-3
28517: PPUSH
28518: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
28522: LD_EXP 56
28526: PPUSH
28527: LD_STRING D8-Huck-4
28529: PPUSH
28530: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
28534: LD_EXP 40
28538: PPUSH
28539: LD_STRING D8-JMM-4
28541: PPUSH
28542: CALL_OW 88
// end ; DialogueOff ;
28546: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
28550: LD_INT 25
28552: PPUSH
28553: LD_INT 1
28555: PPUSH
28556: LD_INT 1
28558: PPUSH
28559: CALL_OW 322
// end ;
28563: PPOPN 3
28565: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
28566: LD_INT 1
28568: PPUSH
28569: LD_EXP 72
28573: PPUSH
28574: CALL_OW 292
28578: IFFALSE 28829
28580: GO 28582
28582: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
28583: LD_EXP 72
28587: PPUSH
28588: CALL_OW 87
// DialogueOn ;
28592: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
28596: LD_EXP 40
28600: PPUSH
28601: LD_STRING D10nB-JMM-1
28603: PPUSH
28604: CALL_OW 88
// if BurlakStatus = 1 then
28608: LD_EXP 9
28612: PUSH
28613: LD_INT 1
28615: EQUAL
28616: IFFALSE 28630
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
28618: LD_EXP 71
28622: PPUSH
28623: LD_STRING D10nB-Vse-1a
28625: PPUSH
28626: CALL_OW 94
// end ; if BurlakStatus = 0 then
28630: LD_EXP 9
28634: PUSH
28635: LD_INT 0
28637: EQUAL
28638: IFFALSE 28652
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
28640: LD_EXP 71
28644: PPUSH
28645: LD_STRING D10nB-Vse-1
28647: PPUSH
28648: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
28652: LD_EXP 40
28656: PPUSH
28657: LD_STRING D10nB-JMM-2
28659: PPUSH
28660: CALL_OW 88
// if KappaStatus then
28664: LD_EXP 2
28668: IFFALSE 28682
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
28670: LD_EXP 71
28674: PPUSH
28675: LD_STRING D10nB-Vse-5a
28677: PPUSH
28678: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
28682: LD_EXP 2
28686: NOT
28687: PUSH
28688: LD_EXP 6
28692: PUSH
28693: LD_INT 0
28695: EQUAL
28696: AND
28697: IFFALSE 28825
// begin if JMMGirl = 1 then
28699: LD_EXP 7
28703: PUSH
28704: LD_INT 1
28706: EQUAL
28707: IFFALSE 28757
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
28709: LD_EXP 71
28713: PPUSH
28714: LD_STRING D10nB-Vse-2
28716: PPUSH
28717: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
28721: LD_EXP 40
28725: PPUSH
28726: LD_STRING D10nB-JMM-3
28728: PPUSH
28729: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
28733: LD_EXP 71
28737: PPUSH
28738: LD_STRING D10nB-Vse-3
28740: PPUSH
28741: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
28745: LD_EXP 40
28749: PPUSH
28750: LD_STRING D10nB-JMM-4
28752: PPUSH
28753: CALL_OW 88
// end ; if JMMGirl = 2 then
28757: LD_EXP 7
28761: PUSH
28762: LD_INT 2
28764: EQUAL
28765: IFFALSE 28791
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
28767: LD_EXP 71
28771: PPUSH
28772: LD_STRING D10nB-Vse-4
28774: PPUSH
28775: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
28779: LD_EXP 40
28783: PPUSH
28784: LD_STRING D10nB-JMM-5
28786: PPUSH
28787: CALL_OW 88
// end ; if JMMGirl = 3 then
28791: LD_EXP 7
28795: PUSH
28796: LD_INT 3
28798: EQUAL
28799: IFFALSE 28825
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
28801: LD_EXP 71
28805: PPUSH
28806: LD_STRING D10nB-Vse-5
28808: PPUSH
28809: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
28813: LD_EXP 40
28817: PPUSH
28818: LD_STRING D10nB-JMM-6
28820: PPUSH
28821: CALL_OW 88
// end ; end ; DialogueOff ;
28825: CALL_OW 7
// end ;
28829: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
28830: LD_EXP 14
28834: PUSH
28835: LD_INT 115500
28837: GREATEREQUAL
28838: IFFALSE 29214
28840: GO 28842
28842: DISABLE
28843: LD_INT 0
28845: PPUSH
// begin missionStage := 10 ;
28846: LD_ADDR_EXP 15
28850: PUSH
28851: LD_INT 10
28853: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28854: LD_ADDR_VAR 0 1
28858: PUSH
28859: LD_INT 22
28861: PUSH
28862: LD_INT 1
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PUSH
28869: LD_INT 23
28871: PUSH
28872: LD_INT 1
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 26
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 3
28891: PUSH
28892: LD_INT 25
28894: PUSH
28895: LD_INT 12
28897: PUSH
28898: EMPTY
28899: LIST
28900: LIST
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 3
28908: PUSH
28909: LD_INT 25
28911: PUSH
28912: LD_INT 16
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: PPUSH
28930: CALL_OW 69
28934: PUSH
28935: LD_EXP 40
28939: PUSH
28940: LD_EXP 61
28944: PUSH
28945: LD_EXP 42
28949: PUSH
28950: LD_EXP 56
28954: PUSH
28955: LD_EXP 43
28959: PUSH
28960: LD_EXP 44
28964: PUSH
28965: LD_EXP 45
28969: PUSH
28970: LD_EXP 46
28974: PUSH
28975: LD_EXP 47
28979: PUSH
28980: LD_EXP 48
28984: PUSH
28985: LD_EXP 49
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_EXP 51
28999: PUSH
29000: LD_EXP 52
29004: PUSH
29005: LD_EXP 53
29009: PUSH
29010: LD_EXP 54
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: DIFF
29033: ST_TO_ADDR
// if not tmp and Brown then
29034: LD_VAR 0 1
29038: NOT
29039: PUSH
29040: LD_EXP 48
29044: AND
29045: IFFALSE 29060
// tmp := [ Brown ] ;
29047: LD_ADDR_VAR 0 1
29051: PUSH
29052: LD_EXP 48
29056: PUSH
29057: EMPTY
29058: LIST
29059: ST_TO_ADDR
// DialogueOn ;
29060: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
29064: LD_VAR 0 1
29068: PUSH
29069: LD_INT 1
29071: ARRAY
29072: PPUSH
29073: LD_STRING D11-Sol1-1
29075: PPUSH
29076: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
29080: LD_EXP 65
29084: PPUSH
29085: LD_STRING D11-Pla-1
29087: PPUSH
29088: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
29092: LD_EXP 66
29096: PPUSH
29097: LD_STRING D11-Kov-1
29099: PPUSH
29100: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
29104: LD_EXP 65
29108: PPUSH
29109: LD_STRING D11-Pla-2
29111: PPUSH
29112: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
29116: LD_VAR 0 1
29120: PUSH
29121: LD_INT 1
29123: ARRAY
29124: PPUSH
29125: LD_STRING D11-Sol1-2
29127: PPUSH
29128: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
29132: LD_EXP 40
29136: PPUSH
29137: LD_STRING D11-JMM-2
29139: PPUSH
29140: CALL_OW 88
// DialogueOff ;
29144: CALL_OW 7
// allowBehemothConstruct := true ;
29148: LD_ADDR_EXP 25
29152: PUSH
29153: LD_INT 1
29155: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
29156: LD_STRING M4
29158: PPUSH
29159: CALL_OW 337
// BuildBehemoths ;
29163: CALL 7787 0 0
// repeat wait ( 15 15$00 ) ;
29167: LD_INT 31500
29169: PPUSH
29170: CALL_OW 67
// if behemothDestroyedBeforeFinish then
29174: LD_EXP 27
29178: IFFALSE 29182
// break ;
29180: GO 29214
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
29182: LD_INT 267
29184: PPUSH
29185: CALL_OW 274
29189: PPUSH
29190: LD_INT 1
29192: PPUSH
29193: CALL_OW 275
29197: PUSH
29198: LD_INT 1000
29200: GREATEREQUAL
29201: IFFALSE 29207
// BuildBehemoths ;
29203: CALL 7787 0 0
// until not behemothBuilders ;
29207: LD_EXP 74
29211: NOT
29212: IFFALSE 29167
// end ;
29214: PPOPN 1
29216: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
29217: LD_EXP 74
29221: NOT
29222: PUSH
29223: LD_EXP 28
29227: NOT
29228: AND
29229: PUSH
29230: LD_EXP 25
29234: AND
29235: IFFALSE 29255
29237: GO 29239
29239: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
29240: LD_STRING M4a
29242: PPUSH
29243: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
29247: LD_ADDR_EXP 27
29251: PUSH
29252: LD_INT 1
29254: ST_TO_ADDR
// end ;
29255: END
// every 0 0$1 trigger behemothDone do
29256: LD_EXP 28
29260: IFFALSE 29272
29262: GO 29264
29264: DISABLE
// ChangeMissionObjectives ( M4b ) ;
29265: LD_STRING M4b
29267: PPUSH
29268: CALL_OW 337
29272: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
29273: LD_EXP 29
29277: NOT
29278: IFFALSE 29474
29280: GO 29282
29282: DISABLE
29283: LD_INT 0
29285: PPUSH
29286: PPUSH
// begin enable ;
29287: ENABLE
// tmp := GetBehemoths ( 3 ) ;
29288: LD_ADDR_VAR 0 1
29292: PUSH
29293: LD_INT 3
29295: PPUSH
29296: CALL 104705 0 1
29300: ST_TO_ADDR
// if not tmp and not behemothDone then
29301: LD_VAR 0 1
29305: NOT
29306: PUSH
29307: LD_EXP 28
29311: NOT
29312: AND
29313: IFFALSE 29349
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
29315: LD_ADDR_VAR 0 1
29319: PUSH
29320: LD_INT 22
29322: PUSH
29323: LD_INT 3
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 30
29332: PUSH
29333: LD_INT 37
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PPUSH
29344: CALL_OW 69
29348: ST_TO_ADDR
// if not tmp then
29349: LD_VAR 0 1
29353: NOT
29354: IFFALSE 29358
// exit ;
29356: GO 29474
// for i in tmp do
29358: LD_ADDR_VAR 0 2
29362: PUSH
29363: LD_VAR 0 1
29367: PUSH
29368: FOR_IN
29369: IFFALSE 29472
// if See ( 1 , i ) then
29371: LD_INT 1
29373: PPUSH
29374: LD_VAR 0 2
29378: PPUSH
29379: CALL_OW 292
29383: IFFALSE 29470
// begin if GetType ( i ) = unit_building then
29385: LD_VAR 0 2
29389: PPUSH
29390: CALL_OW 247
29394: PUSH
29395: LD_INT 3
29397: EQUAL
29398: IFFALSE 29436
// begin CenterNowOnUnits ( i ) ;
29400: LD_VAR 0 2
29404: PPUSH
29405: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
29409: LD_EXP 40
29413: PPUSH
29414: LD_STRING D17a-JMM-1
29416: PPUSH
29417: CALL_OW 88
// seeBehemoth := true ;
29421: LD_ADDR_EXP 29
29425: PUSH
29426: LD_INT 1
29428: ST_TO_ADDR
// disable ;
29429: DISABLE
// exit ;
29430: POP
29431: POP
29432: GO 29474
// end else
29434: GO 29470
// begin CenterNowOnUnits ( i ) ;
29436: LD_VAR 0 2
29440: PPUSH
29441: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
29445: LD_EXP 40
29449: PPUSH
29450: LD_STRING D17b-JMM-1
29452: PPUSH
29453: CALL_OW 88
// seeBehemoth := true ;
29457: LD_ADDR_EXP 29
29461: PUSH
29462: LD_INT 1
29464: ST_TO_ADDR
// disable ;
29465: DISABLE
// exit ;
29466: POP
29467: POP
29468: GO 29474
// end ; end ;
29470: GO 29368
29472: POP
29473: POP
// end ;
29474: PPOPN 2
29476: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
29477: LD_EXP 14
29481: PUSH
29482: LD_INT 123200
29484: GREATEREQUAL
29485: IFFALSE 30661
29487: GO 29489
29489: DISABLE
29490: LD_INT 0
29492: PPUSH
29493: PPUSH
29494: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
29495: LD_INT 2
29497: PPUSH
29498: LD_INT 23
29500: PUSH
29501: LD_INT 3
29503: PUSH
29504: LD_INT 3
29506: PUSH
29507: LD_INT 48
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: LIST
29514: LIST
29515: PUSH
29516: EMPTY
29517: LIST
29518: PPUSH
29519: CALL 60807 0 2
// repeat wait ( 0 0$1 ) ;
29523: LD_INT 35
29525: PPUSH
29526: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
29530: LD_INT 22
29532: PUSH
29533: LD_INT 3
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 34
29542: PUSH
29543: LD_INT 48
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PPUSH
29554: CALL_OW 69
29558: IFFALSE 29523
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
29560: LD_ADDR_VAR 0 1
29564: PUSH
29565: LD_INT 22
29567: PUSH
29568: LD_INT 3
29570: PUSH
29571: EMPTY
29572: LIST
29573: LIST
29574: PUSH
29575: LD_INT 34
29577: PUSH
29578: LD_INT 48
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PPUSH
29589: CALL_OW 69
29593: PUSH
29594: LD_INT 1
29596: ARRAY
29597: ST_TO_ADDR
// missionStage := 12 ;
29598: LD_ADDR_EXP 15
29602: PUSH
29603: LD_INT 12
29605: ST_TO_ADDR
// platonovHasBomb := true ;
29606: LD_ADDR_EXP 30
29610: PUSH
29611: LD_INT 1
29613: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
29614: LD_VAR 0 1
29618: PPUSH
29619: LD_INT 181
29621: PPUSH
29622: LD_INT 86
29624: PPUSH
29625: CALL_OW 171
// AddComHold ( bomb ) ;
29629: LD_VAR 0 1
29633: PPUSH
29634: CALL_OW 200
// wait ( 0 0$10 ) ;
29638: LD_INT 350
29640: PPUSH
29641: CALL_OW 67
// DialogueOn ;
29645: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
29649: LD_EXP 65
29653: PPUSH
29654: LD_STRING D15-Pla-1
29656: PPUSH
29657: CALL_OW 94
// dec = Query ( Q15a ) ;
29661: LD_ADDR_VAR 0 2
29665: PUSH
29666: LD_STRING Q15a
29668: PPUSH
29669: CALL_OW 97
29673: ST_TO_ADDR
// if dec = 1 then
29674: LD_VAR 0 2
29678: PUSH
29679: LD_INT 1
29681: EQUAL
29682: IFFALSE 29705
// begin Say ( JMM , D15a-JMM-1 ) ;
29684: LD_EXP 40
29688: PPUSH
29689: LD_STRING D15a-JMM-1
29691: PPUSH
29692: CALL_OW 88
// YouLost ( Surrender ) ;
29696: LD_STRING Surrender
29698: PPUSH
29699: CALL_OW 104
// exit ;
29703: GO 30661
// end ; if dec = 2 then
29705: LD_VAR 0 2
29709: PUSH
29710: LD_INT 2
29712: EQUAL
29713: IFFALSE 29782
// begin Say ( JMM , D15b-JMM-1 ) ;
29715: LD_EXP 40
29719: PPUSH
29720: LD_STRING D15b-JMM-1
29722: PPUSH
29723: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
29727: LD_EXP 65
29731: PPUSH
29732: LD_STRING D15b-Pla-1
29734: PPUSH
29735: CALL_OW 94
// DialogueOff ;
29739: CALL_OW 7
// wait ( 3 3$00 ) ;
29743: LD_INT 6300
29745: PPUSH
29746: CALL_OW 67
// DialogueOn ;
29750: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
29754: LD_EXP 40
29758: PPUSH
29759: LD_STRING D15d-JMM-1a
29761: PPUSH
29762: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29766: LD_EXP 65
29770: PPUSH
29771: LD_STRING D15d-Pla-1
29773: PPUSH
29774: CALL_OW 94
// DialogueOff ;
29778: CALL_OW 7
// end ; if dec = 3 then
29782: LD_VAR 0 2
29786: PUSH
29787: LD_INT 3
29789: EQUAL
29790: IFFALSE 29844
// begin Say ( JMM , D15c-JMM-1 ) ;
29792: LD_EXP 40
29796: PPUSH
29797: LD_STRING D15c-JMM-1
29799: PPUSH
29800: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
29804: LD_EXP 65
29808: PPUSH
29809: LD_STRING D15c-Pla-1
29811: PPUSH
29812: CALL_OW 94
// DialogueOff ;
29816: CALL_OW 7
// wait ( 0 0$15 ) ;
29820: LD_INT 525
29822: PPUSH
29823: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
29827: LD_VAR 0 1
29831: PPUSH
29832: LD_INT 60
29834: PPUSH
29835: LD_INT 95
29837: PPUSH
29838: CALL_OW 116
// exit ;
29842: GO 30661
// end ; if dec = 4 then
29844: LD_VAR 0 2
29848: PUSH
29849: LD_INT 4
29851: EQUAL
29852: IFFALSE 29882
// begin Say ( JMM , D15d-JMM-1 ) ;
29854: LD_EXP 40
29858: PPUSH
29859: LD_STRING D15d-JMM-1
29861: PPUSH
29862: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
29866: LD_EXP 65
29870: PPUSH
29871: LD_STRING D15d-Pla-1
29873: PPUSH
29874: CALL_OW 94
// DialogueOff ;
29878: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29882: LD_EXP 63
29886: PPUSH
29887: CALL_OW 302
29891: PUSH
29892: LD_EXP 63
29896: PPUSH
29897: CALL_OW 255
29901: PUSH
29902: LD_INT 1
29904: EQUAL
29905: AND
29906: PUSH
29907: LD_INT 22
29909: PUSH
29910: LD_INT 1
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 34
29919: PUSH
29920: LD_INT 8
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PPUSH
29931: CALL_OW 69
29935: NOT
29936: AND
29937: IFFALSE 30562
// begin SetSide ( Friend , 8 ) ;
29939: LD_EXP 63
29943: PPUSH
29944: LD_INT 8
29946: PPUSH
29947: CALL_OW 235
// if IsInUnit ( Friend ) then
29951: LD_EXP 63
29955: PPUSH
29956: CALL_OW 310
29960: IFFALSE 29971
// ComExitBuilding ( Friend ) ;
29962: LD_EXP 63
29966: PPUSH
29967: CALL_OW 122
// if IsDriver ( Friend ) then
29971: LD_EXP 63
29975: PPUSH
29976: CALL 102253 0 1
29980: IFFALSE 29991
// ComExitVehicle ( Friend ) ;
29982: LD_EXP 63
29986: PPUSH
29987: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
29991: LD_EXP 63
29995: PPUSH
29996: LD_INT 9
29998: PPUSH
29999: LD_INT 2
30001: PPUSH
30002: CALL_OW 171
// wait ( 0 0$05 ) ;
30006: LD_INT 175
30008: PPUSH
30009: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30013: LD_EXP 63
30017: PPUSH
30018: CALL_OW 87
// DialogueOn ;
30022: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
30026: LD_EXP 40
30030: PPUSH
30031: LD_STRING D16-JMM-1
30033: PPUSH
30034: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
30038: LD_EXP 63
30042: PPUSH
30043: LD_STRING D16-Friend-1
30045: PPUSH
30046: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
30050: LD_EXP 40
30054: PPUSH
30055: LD_STRING D16-JMM-2
30057: PPUSH
30058: CALL_OW 88
// DialogueOff ;
30062: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30066: LD_EXP 63
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: CALL_OW 235
// ComHold ( Friend ) ;
30078: LD_EXP 63
30082: PPUSH
30083: CALL_OW 140
// wait ( 0 0$20 ) ;
30087: LD_INT 700
30089: PPUSH
30090: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
30094: LD_EXP 63
30098: PPUSH
30099: LD_INT 9
30101: PPUSH
30102: LD_INT 2
30104: PPUSH
30105: CALL_OW 297
30109: PUSH
30110: LD_INT 30
30112: LESS
30113: IFFALSE 30182
// begin SetSide ( Friend , 8 ) ;
30115: LD_EXP 63
30119: PPUSH
30120: LD_INT 8
30122: PPUSH
30123: CALL_OW 235
// if IsInUnit ( Friend ) then
30127: LD_EXP 63
30131: PPUSH
30132: CALL_OW 310
30136: IFFALSE 30147
// ComExitBuilding ( Friend ) ;
30138: LD_EXP 63
30142: PPUSH
30143: CALL_OW 122
// if IsDriver ( Friend ) then
30147: LD_EXP 63
30151: PPUSH
30152: CALL 102253 0 1
30156: IFFALSE 30167
// ComExitVehicle ( Friend ) ;
30158: LD_EXP 63
30162: PPUSH
30163: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
30167: LD_EXP 63
30171: PPUSH
30172: LD_INT 9
30174: PPUSH
30175: LD_INT 2
30177: PPUSH
30178: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
30182: LD_INT 1050
30184: PPUSH
30185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30189: LD_INT 22
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 34
30201: PUSH
30202: LD_INT 8
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: PPUSH
30213: CALL_OW 69
30217: NOT
30218: IFFALSE 30540
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30220: LD_ADDR_VAR 0 3
30224: PUSH
30225: LD_INT 22
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 26
30237: PUSH
30238: LD_INT 1
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 3
30247: PUSH
30248: LD_INT 25
30250: PUSH
30251: LD_INT 12
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 25
30260: PUSH
30261: LD_INT 16
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: LIST
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: LIST
30277: PPUSH
30278: CALL_OW 69
30282: PUSH
30283: LD_EXP 40
30287: PUSH
30288: LD_EXP 42
30292: PUSH
30293: LD_EXP 56
30297: PUSH
30298: LD_EXP 43
30302: PUSH
30303: LD_EXP 44
30307: PUSH
30308: LD_EXP 45
30312: PUSH
30313: LD_EXP 46
30317: PUSH
30318: LD_EXP 47
30322: PUSH
30323: LD_EXP 48
30327: PUSH
30328: LD_EXP 49
30332: PUSH
30333: LD_EXP 50
30337: PUSH
30338: LD_EXP 51
30342: PUSH
30343: LD_EXP 52
30347: PUSH
30348: LD_EXP 53
30352: PUSH
30353: LD_EXP 54
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: LIST
30373: LIST
30374: DIFF
30375: ST_TO_ADDR
// DialogueOn ;
30376: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
30380: LD_EXP 65
30384: PPUSH
30385: LD_STRING D16a-Pla-1
30387: PPUSH
30388: CALL_OW 94
// if Stevens then
30392: LD_EXP 42
30396: IFFALSE 30412
// Say ( Stevens , D16a-Huck-1 ) else
30398: LD_EXP 42
30402: PPUSH
30403: LD_STRING D16a-Huck-1
30405: PPUSH
30406: CALL_OW 88
30410: GO 30454
// if Baker then
30412: LD_EXP 56
30416: IFFALSE 30432
// Say ( Baker , D16a-Huck-1 ) else
30418: LD_EXP 56
30422: PPUSH
30423: LD_STRING D16a-Huck-1
30425: PPUSH
30426: CALL_OW 88
30430: GO 30454
// if tmp then
30432: LD_VAR 0 3
30436: IFFALSE 30454
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
30438: LD_VAR 0 3
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: PPUSH
30447: LD_STRING D16a-Sol1-1
30449: PPUSH
30450: CALL_OW 88
// if GetSide ( Friend ) = 8 then
30454: LD_EXP 63
30458: PPUSH
30459: CALL_OW 255
30463: PUSH
30464: LD_INT 8
30466: EQUAL
30467: IFFALSE 30483
// Say ( JMM , D16a-JMM-1 ) else
30469: LD_EXP 40
30473: PPUSH
30474: LD_STRING D16a-JMM-1
30476: PPUSH
30477: CALL_OW 88
30481: GO 30519
// begin Say ( JMM , D16a-JMM-1a ) ;
30483: LD_EXP 40
30487: PPUSH
30488: LD_STRING D16a-JMM-1a
30490: PPUSH
30491: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
30495: LD_EXP 63
30499: PPUSH
30500: LD_STRING D16a-Friend-1
30502: PPUSH
30503: CALL_OW 88
// SetSide ( Friend , 3 ) ;
30507: LD_EXP 63
30511: PPUSH
30512: LD_INT 3
30514: PPUSH
30515: CALL_OW 235
// end ; DialogueOff ;
30519: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
30523: LD_VAR 0 1
30527: PPUSH
30528: LD_INT 60
30530: PPUSH
30531: LD_INT 95
30533: PPUSH
30534: CALL_OW 116
// end else
30538: GO 30560
// begin DialogueOn ;
30540: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
30544: LD_EXP 65
30548: PPUSH
30549: LD_STRING D16c-Pla-
30551: PPUSH
30552: CALL_OW 94
// DialogueOff ;
30556: CALL_OW 7
// end ; end else
30560: GO 30661
// begin wait ( 3 3$00 ) ;
30562: LD_INT 6300
30564: PPUSH
30565: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
30569: LD_INT 22
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 34
30581: PUSH
30582: LD_INT 8
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PPUSH
30593: CALL_OW 69
30597: NOT
30598: IFFALSE 30641
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
30600: LD_EXP 65
30604: PPUSH
30605: LD_STRING D16b-Pla-1
30607: PPUSH
30608: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
30612: LD_EXP 40
30616: PPUSH
30617: LD_STRING D16b-JMM-
30619: PPUSH
30620: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
30624: LD_VAR 0 1
30628: PPUSH
30629: LD_INT 60
30631: PPUSH
30632: LD_INT 95
30634: PPUSH
30635: CALL_OW 116
// end else
30639: GO 30661
// begin DialogueOn ;
30641: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
30645: LD_EXP 65
30649: PPUSH
30650: LD_STRING D16c-Pla-1
30652: PPUSH
30653: CALL_OW 94
// DialogueOff ;
30657: CALL_OW 7
// end ; end ; end ;
30661: PPOPN 3
30663: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
30664: LD_EXP 14
30668: PUSH
30669: LD_INT 126000
30671: GREATEREQUAL
30672: PUSH
30673: LD_EXP 23
30677: NOT
30678: AND
30679: PUSH
30680: LD_EXP 76
30684: PPUSH
30685: CALL_OW 302
30689: AND
30690: IFFALSE 31048
30692: GO 30694
30694: DISABLE
30695: LD_INT 0
30697: PPUSH
// begin missionStage = 11 ;
30698: LD_ADDR_EXP 15
30702: PUSH
30703: LD_INT 11
30705: ST_TO_ADDR
// DialogueOn ;
30706: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
30710: LD_EXP 76
30714: PPUSH
30715: LD_STRING D9-Roth-1
30717: PPUSH
30718: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
30722: LD_EXP 40
30726: PPUSH
30727: LD_STRING D9-JMM-1
30729: PPUSH
30730: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
30734: LD_EXP 76
30738: PPUSH
30739: LD_STRING D9-Roth-2
30741: PPUSH
30742: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
30746: LD_EXP 76
30750: PPUSH
30751: LD_STRING D9-Roth-2a
30753: PPUSH
30754: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
30758: LD_EXP 65
30762: PPUSH
30763: LD_STRING D9-Pla-2
30765: PPUSH
30766: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
30770: LD_EXP 76
30774: PPUSH
30775: LD_STRING D9-Roth-3
30777: PPUSH
30778: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
30782: LD_EXP 65
30786: PPUSH
30787: LD_STRING D9-Pla-3
30789: PPUSH
30790: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
30794: LD_EXP 76
30798: PPUSH
30799: LD_STRING D9-Roth-4
30801: PPUSH
30802: CALL_OW 94
// dec = Query ( Q9 ) ;
30806: LD_ADDR_VAR 0 1
30810: PUSH
30811: LD_STRING Q9
30813: PPUSH
30814: CALL_OW 97
30818: ST_TO_ADDR
// if dec = 1 then
30819: LD_VAR 0 1
30823: PUSH
30824: LD_INT 1
30826: EQUAL
30827: IFFALSE 30841
// SayRadio ( Roth , D9a-Roth-1 ) ;
30829: LD_EXP 76
30833: PPUSH
30834: LD_STRING D9a-Roth-1
30836: PPUSH
30837: CALL_OW 94
// if dec = 2 then
30841: LD_VAR 0 1
30845: PUSH
30846: LD_INT 2
30848: EQUAL
30849: IFFALSE 30875
// begin Say ( JMM , D9b-JMM-1 ) ;
30851: LD_EXP 40
30855: PPUSH
30856: LD_STRING D9b-JMM-1
30858: PPUSH
30859: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
30863: LD_EXP 76
30867: PPUSH
30868: LD_STRING D9b-Roth-1
30870: PPUSH
30871: CALL_OW 94
// end ; if dec = 3 then
30875: LD_VAR 0 1
30879: PUSH
30880: LD_INT 3
30882: EQUAL
30883: IFFALSE 30945
// begin Say ( JMM , D9c-JMM-1 ) ;
30885: LD_EXP 40
30889: PPUSH
30890: LD_STRING D9c-JMM-1
30892: PPUSH
30893: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
30897: LD_EXP 76
30901: PPUSH
30902: LD_STRING D9c-Roth-1
30904: PPUSH
30905: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
30909: LD_EXP 40
30913: PPUSH
30914: LD_STRING D9c-JMM-2
30916: PPUSH
30917: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
30921: LD_EXP 76
30925: PPUSH
30926: LD_STRING D9c-Roth-2
30928: PPUSH
30929: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
30933: LD_EXP 40
30937: PPUSH
30938: LD_STRING D9c-JMM-3
30940: PPUSH
30941: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
30945: LD_EXP 76
30949: PPUSH
30950: LD_STRING D9c-Roth-3
30952: PPUSH
30953: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
30957: LD_EXP 76
30961: PPUSH
30962: LD_STRING D9cont-Roth-1
30964: PPUSH
30965: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
30969: LD_EXP 40
30973: PPUSH
30974: LD_STRING D9cont-JMM-1
30976: PPUSH
30977: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
30981: LD_EXP 76
30985: PPUSH
30986: LD_STRING D9cont-Roth-2
30988: PPUSH
30989: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
30993: LD_EXP 40
30997: PPUSH
30998: LD_STRING D9cont-JMM-2
31000: PPUSH
31001: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
31005: LD_EXP 76
31009: PPUSH
31010: LD_STRING D9cont-Roth-3
31012: PPUSH
31013: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
31017: LD_EXP 40
31021: PPUSH
31022: LD_STRING D9cont-JMM-3
31024: PPUSH
31025: CALL_OW 88
// DialogueOff ;
31029: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
31033: LD_STRING M3
31035: PPUSH
31036: CALL_OW 337
// allianceActive := true ;
31040: LD_ADDR_EXP 31
31044: PUSH
31045: LD_INT 1
31047: ST_TO_ADDR
// end ;
31048: PPOPN 1
31050: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
31051: LD_INT 1
31053: PPUSH
31054: LD_INT 126
31056: PPUSH
31057: CALL_OW 292
31061: PUSH
31062: LD_EXP 65
31066: PPUSH
31067: CALL_OW 310
31071: AND
31072: IFFALSE 31152
31074: GO 31076
31076: DISABLE
31077: LD_INT 0
31079: PPUSH
// begin ComExitBuilding ( Platonov ) ;
31080: LD_EXP 65
31084: PPUSH
31085: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
31089: LD_ADDR_VAR 0 1
31093: PUSH
31094: LD_INT 4
31096: PPUSH
31097: LD_INT 22
31099: PUSH
31100: LD_INT 1
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PPUSH
31107: CALL_OW 70
31111: PPUSH
31112: LD_EXP 65
31116: PPUSH
31117: CALL_OW 74
31121: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
31122: LD_EXP 65
31126: PPUSH
31127: LD_VAR 0 1
31131: PUSH
31132: LD_INT 1
31134: ARRAY
31135: PPUSH
31136: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
31140: LD_EXP 65
31144: PPUSH
31145: LD_STRING D18-Pla-1
31147: PPUSH
31148: CALL_OW 88
// end ;
31152: PPOPN 1
31154: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
31155: LD_EXP 65
31159: PPUSH
31160: CALL_OW 301
31164: PUSH
31165: LD_EXP 68
31169: PPUSH
31170: CALL_OW 301
31174: AND
31175: PUSH
31176: LD_INT 22
31178: PUSH
31179: LD_INT 3
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 21
31188: PUSH
31189: LD_INT 1
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 50
31198: PUSH
31199: EMPTY
31200: LIST
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: LIST
31206: PPUSH
31207: CALL_OW 69
31211: PUSH
31212: LD_INT 7
31214: PUSH
31215: LD_INT 8
31217: PUSH
31218: LD_INT 9
31220: PUSH
31221: LD_INT 10
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: LIST
31228: LIST
31229: PUSH
31230: LD_OWVAR 67
31234: ARRAY
31235: LESS
31236: AND
31237: IFFALSE 31994
31239: GO 31241
31241: DISABLE
31242: LD_INT 0
31244: PPUSH
31245: PPUSH
31246: PPUSH
31247: PPUSH
// begin MC_Kill ( 2 ) ;
31248: LD_INT 2
31250: PPUSH
31251: CALL 36780 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
31255: LD_INT 1
31257: PPUSH
31258: LD_INT 3
31260: PPUSH
31261: LD_INT 1
31263: PPUSH
31264: LD_INT 1
31266: PPUSH
31267: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
31271: LD_ADDR_VAR 0 2
31275: PUSH
31276: LD_INT 22
31278: PUSH
31279: LD_INT 3
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 21
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 50
31298: PUSH
31299: EMPTY
31300: LIST
31301: PUSH
31302: LD_INT 26
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: PPUSH
31318: CALL_OW 69
31322: ST_TO_ADDR
// if not tmp then
31323: LD_VAR 0 2
31327: NOT
31328: IFFALSE 31384
// begin uc_side = 3 ;
31330: LD_ADDR_OWVAR 20
31334: PUSH
31335: LD_INT 3
31337: ST_TO_ADDR
// uc_nation = 3 ;
31338: LD_ADDR_OWVAR 21
31342: PUSH
31343: LD_INT 3
31345: ST_TO_ADDR
// hc_name =  ;
31346: LD_ADDR_OWVAR 26
31350: PUSH
31351: LD_STRING 
31353: ST_TO_ADDR
// hc_gallery =  ;
31354: LD_ADDR_OWVAR 33
31358: PUSH
31359: LD_STRING 
31361: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
31362: LD_INT 1
31364: PPUSH
31365: LD_INT 10
31367: PPUSH
31368: CALL_OW 381
// tmp = CreateHuman ;
31372: LD_ADDR_VAR 0 2
31376: PUSH
31377: CALL_OW 44
31381: ST_TO_ADDR
// end else
31382: GO 31398
// tmp := tmp [ 1 ] ;
31384: LD_ADDR_VAR 0 2
31388: PUSH
31389: LD_VAR 0 2
31393: PUSH
31394: LD_INT 1
31396: ARRAY
31397: ST_TO_ADDR
// DialogueOn ;
31398: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
31402: LD_VAR 0 2
31406: PPUSH
31407: LD_STRING DSurrenderRussians-RSol1-1a
31409: PPUSH
31410: CALL_OW 94
// DialogueOff ;
31414: CALL_OW 7
// russianDestroyed := true ;
31418: LD_ADDR_EXP 21
31422: PUSH
31423: LD_INT 1
31425: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
31426: LD_INT 22
31428: PUSH
31429: LD_INT 3
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: LD_INT 21
31438: PUSH
31439: LD_INT 1
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PPUSH
31450: CALL_OW 69
31454: PPUSH
31455: CALL_OW 122
// wait ( 0 0$1 ) ;
31459: LD_INT 35
31461: PPUSH
31462: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
31466: LD_INT 22
31468: PUSH
31469: LD_INT 3
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 21
31478: PUSH
31479: LD_INT 1
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PPUSH
31490: CALL_OW 69
31494: PPUSH
31495: LD_INT 25
31497: PPUSH
31498: CALL_OW 173
// wait ( 0 0$35 ) ;
31502: LD_INT 1225
31504: PPUSH
31505: CALL_OW 67
// PrepareOmarInvasion ;
31509: CALL 14644 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
31513: LD_ADDR_VAR 0 2
31517: PUSH
31518: LD_EXP 94
31522: PPUSH
31523: CALL_OW 250
31527: PUSH
31528: LD_EXP 94
31532: PPUSH
31533: CALL_OW 251
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
31542: LD_VAR 0 2
31546: PUSH
31547: LD_INT 1
31549: ARRAY
31550: PPUSH
31551: LD_VAR 0 2
31555: PUSH
31556: LD_INT 2
31558: ARRAY
31559: PPUSH
31560: LD_INT 1
31562: PPUSH
31563: LD_INT 8
31565: NEG
31566: PPUSH
31567: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
31571: LD_EXP 94
31575: PPUSH
31576: CALL_OW 87
// DialogueOn ;
31580: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
31584: LD_EXP 40
31588: PPUSH
31589: LD_STRING D19-JMM-1
31591: PPUSH
31592: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
31596: LD_ADDR_VAR 0 3
31600: PUSH
31601: LD_INT 22
31603: PUSH
31604: LD_INT 1
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 26
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 2
31623: PUSH
31624: LD_INT 25
31626: PUSH
31627: LD_INT 1
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 25
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 25
31646: PUSH
31647: LD_INT 3
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 25
31656: PUSH
31657: LD_INT 4
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 25
31666: PUSH
31667: LD_INT 5
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: LD_INT 25
31676: PUSH
31677: LD_INT 8
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: LIST
31697: PPUSH
31698: CALL_OW 69
31702: PUSH
31703: LD_EXP 40
31707: PUSH
31708: LD_EXP 41
31712: PUSH
31713: LD_EXP 42
31717: PUSH
31718: LD_EXP 43
31722: PUSH
31723: LD_EXP 44
31727: PUSH
31728: LD_EXP 45
31732: PUSH
31733: LD_EXP 46
31737: PUSH
31738: LD_EXP 47
31742: PUSH
31743: LD_EXP 48
31747: PUSH
31748: LD_EXP 49
31752: PUSH
31753: LD_EXP 50
31757: PUSH
31758: LD_EXP 51
31762: PUSH
31763: LD_EXP 52
31767: PUSH
31768: LD_EXP 53
31772: PUSH
31773: LD_EXP 54
31777: PUSH
31778: LD_EXP 55
31782: PUSH
31783: LD_EXP 56
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: LIST
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: DIFF
31807: ST_TO_ADDR
// if tmp2 then
31808: LD_VAR 0 3
31812: IFFALSE 31830
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
31814: LD_VAR 0 3
31818: PUSH
31819: LD_INT 1
31821: ARRAY
31822: PPUSH
31823: LD_STRING D19-Sol1-1
31825: PPUSH
31826: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
31830: LD_EXP 40
31834: PPUSH
31835: LD_STRING D19-JMM-2
31837: PPUSH
31838: CALL_OW 88
// DialogueOff ;
31842: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
31846: LD_VAR 0 2
31850: PUSH
31851: LD_INT 1
31853: ARRAY
31854: PPUSH
31855: LD_VAR 0 2
31859: PUSH
31860: LD_INT 2
31862: ARRAY
31863: PPUSH
31864: LD_INT 1
31866: PPUSH
31867: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
31871: LD_STRING M5
31873: PPUSH
31874: CALL_OW 337
// omarOnMotherLode := false ;
31878: LD_ADDR_VAR 0 4
31882: PUSH
31883: LD_INT 0
31885: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31886: LD_INT 35
31888: PPUSH
31889: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
31893: LD_EXP 94
31897: PPUSH
31898: LD_INT 215
31900: PPUSH
31901: LD_INT 100
31903: PPUSH
31904: CALL_OW 297
31908: PUSH
31909: LD_INT 10
31911: LESS
31912: PUSH
31913: LD_VAR 0 4
31917: NOT
31918: AND
31919: IFFALSE 31953
// begin omarOnMotherLode := true ;
31921: LD_ADDR_VAR 0 4
31925: PUSH
31926: LD_INT 1
31928: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
31929: LD_EXP 40
31933: PPUSH
31934: LD_STRING D19b-JMM-1
31936: PPUSH
31937: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
31941: LD_EXP 94
31945: PPUSH
31946: LD_STRING DOmarContam-Omar-1
31948: PPUSH
31949: CALL_OW 88
// end ; until IsDead ( Omar ) ;
31953: LD_EXP 94
31957: PPUSH
31958: CALL_OW 301
31962: IFFALSE 31886
// Say ( JMM , D19a-JMM-1 ) ;
31964: LD_EXP 40
31968: PPUSH
31969: LD_STRING D19a-JMM-1
31971: PPUSH
31972: CALL_OW 88
// if Heike then
31976: LD_EXP 95
31980: IFFALSE 31994
// Say ( Heike , D19a-Hke-1 ) ;
31982: LD_EXP 95
31986: PPUSH
31987: LD_STRING D19a-Hke-1
31989: PPUSH
31990: CALL_OW 88
// end ;
31994: PPOPN 4
31996: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
31997: LD_INT 22
31999: PUSH
32000: LD_INT 3
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 21
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PPUSH
32021: CALL_OW 69
32025: PUSH
32026: LD_EXP 21
32030: AND
32031: IFFALSE 32099
32033: GO 32035
32035: DISABLE
32036: LD_INT 0
32038: PPUSH
32039: PPUSH
// begin enable ;
32040: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
32041: LD_ADDR_VAR 0 2
32045: PUSH
32046: LD_INT 25
32048: PPUSH
32049: LD_INT 22
32051: PUSH
32052: LD_INT 3
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PPUSH
32059: CALL_OW 70
32063: ST_TO_ADDR
// if not tmp then
32064: LD_VAR 0 2
32068: NOT
32069: IFFALSE 32073
// exit ;
32071: GO 32099
// for i in tmp do
32073: LD_ADDR_VAR 0 1
32077: PUSH
32078: LD_VAR 0 2
32082: PUSH
32083: FOR_IN
32084: IFFALSE 32097
// RemoveUnit ( i ) ;
32086: LD_VAR 0 1
32090: PPUSH
32091: CALL_OW 64
32095: GO 32083
32097: POP
32098: POP
// end ;
32099: PPOPN 2
32101: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
32102: LD_INT 22
32104: PUSH
32105: LD_INT 7
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 21
32114: PUSH
32115: LD_INT 1
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PPUSH
32126: CALL_OW 69
32130: PUSH
32131: LD_INT 6
32133: LESS
32134: IFFALSE 32602
32136: GO 32138
32138: DISABLE
32139: LD_INT 0
32141: PPUSH
32142: PPUSH
// begin MC_Kill ( 1 ) ;
32143: LD_INT 1
32145: PPUSH
32146: CALL 36780 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
32150: LD_INT 7
32152: PPUSH
32153: LD_INT 1
32155: PPUSH
32156: LD_INT 1
32158: PPUSH
32159: LD_INT 1
32161: PPUSH
32162: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
32166: LD_ADDR_VAR 0 1
32170: PUSH
32171: LD_INT 22
32173: PUSH
32174: LD_INT 7
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 26
32183: PUSH
32184: LD_INT 1
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PPUSH
32195: CALL_OW 69
32199: PUSH
32200: LD_EXP 76
32204: DIFF
32205: ST_TO_ADDR
// if tmp then
32206: LD_VAR 0 1
32210: IFFALSE 32228
// tmp := tmp [ 1 ] else
32212: LD_ADDR_VAR 0 1
32216: PUSH
32217: LD_VAR 0 1
32221: PUSH
32222: LD_INT 1
32224: ARRAY
32225: ST_TO_ADDR
32226: GO 32264
// begin uc_side := 7 ;
32228: LD_ADDR_OWVAR 20
32232: PUSH
32233: LD_INT 7
32235: ST_TO_ADDR
// uc_nation := 1 ;
32236: LD_ADDR_OWVAR 21
32240: PUSH
32241: LD_INT 1
32243: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
32244: LD_INT 1
32246: PPUSH
32247: LD_INT 8
32249: PPUSH
32250: CALL_OW 384
// tmp := CreateHuman ;
32254: LD_ADDR_VAR 0 1
32258: PUSH
32259: CALL_OW 44
32263: ST_TO_ADDR
// end ; DialogueOn ;
32264: CALL_OW 6
// if IsOK ( Roth ) then
32268: LD_EXP 76
32272: PPUSH
32273: CALL_OW 302
32277: IFFALSE 32291
// Say ( JMM , DAb-JMM-1 ) ;
32279: LD_EXP 40
32283: PPUSH
32284: LD_STRING DAb-JMM-1
32286: PPUSH
32287: CALL_OW 88
// if IsOK ( Roth ) then
32291: LD_EXP 76
32295: PPUSH
32296: CALL_OW 302
32300: IFFALSE 32324
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
32302: LD_EXP 76
32306: PPUSH
32307: LD_STRING DSurrenderAlliance-Roth-1
32309: PPUSH
32310: CALL_OW 88
// RothCaptured := true ;
32314: LD_ADDR_EXP 33
32318: PUSH
32319: LD_INT 1
32321: ST_TO_ADDR
// end else
32322: GO 32336
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
32324: LD_VAR 0 1
32328: PPUSH
32329: LD_STRING DSurrenderAlliance-Sci1-1
32331: PPUSH
32332: CALL_OW 88
// DialogueOff ;
32336: CALL_OW 7
// allianceDestroyed := true ;
32340: LD_ADDR_EXP 23
32344: PUSH
32345: LD_INT 1
32347: ST_TO_ADDR
// if capturedUnit = 0 then
32348: LD_EXP 34
32352: PUSH
32353: LD_INT 0
32355: EQUAL
32356: IFFALSE 32365
// SetAchievement ( ACH_ALLIANCE ) ;
32358: LD_STRING ACH_ALLIANCE
32360: PPUSH
32361: CALL_OW 543
// if trueAmericans then
32365: LD_EXP 35
32369: IFFALSE 32445
// begin if trueAmericans = 1 then
32371: LD_EXP 35
32375: PUSH
32376: LD_INT 1
32378: EQUAL
32379: IFFALSE 32395
// Say ( JMM , DAb-JMM-1a ) else
32381: LD_EXP 40
32385: PPUSH
32386: LD_STRING DAb-JMM-1a
32388: PPUSH
32389: CALL_OW 88
32393: GO 32407
// Say ( JMM , DAb-JMM-1b ) ;
32395: LD_EXP 40
32399: PPUSH
32400: LD_STRING DAb-JMM-1b
32402: PPUSH
32403: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
32407: LD_EXP 35
32411: PPUSH
32412: CALL_OW 87
// for i in trueAmericans do
32416: LD_ADDR_VAR 0 2
32420: PUSH
32421: LD_EXP 35
32425: PUSH
32426: FOR_IN
32427: IFFALSE 32443
// SetSide ( i , 1 ) ;
32429: LD_VAR 0 2
32433: PPUSH
32434: LD_INT 1
32436: PPUSH
32437: CALL_OW 235
32441: GO 32426
32443: POP
32444: POP
// end ; repeat wait ( 0 0$1 ) ;
32445: LD_INT 35
32447: PPUSH
32448: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
32452: LD_ADDR_VAR 0 2
32456: PUSH
32457: LD_INT 22
32459: PUSH
32460: LD_INT 7
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 21
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PPUSH
32481: CALL_OW 69
32485: PUSH
32486: FOR_IN
32487: IFFALSE 32569
// begin if IsInUnit ( i ) then
32489: LD_VAR 0 2
32493: PPUSH
32494: CALL_OW 310
32498: IFFALSE 32509
// ComExitBuilding ( i ) ;
32500: LD_VAR 0 2
32504: PPUSH
32505: CALL_OW 122
// if IsDriver ( i ) then
32509: LD_VAR 0 2
32513: PPUSH
32514: CALL 102253 0 1
32518: IFFALSE 32529
// ComExitVehicle ( i ) ;
32520: LD_VAR 0 2
32524: PPUSH
32525: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
32529: LD_VAR 0 2
32533: PPUSH
32534: LD_INT 26
32536: PPUSH
32537: CALL_OW 308
32541: NOT
32542: IFFALSE 32558
// AddComMoveToArea ( i , allianceEscapeArea ) else
32544: LD_VAR 0 2
32548: PPUSH
32549: LD_INT 26
32551: PPUSH
32552: CALL_OW 173
32556: GO 32567
// RemoveUnit ( i ) ;
32558: LD_VAR 0 2
32562: PPUSH
32563: CALL_OW 64
// end ;
32567: GO 32486
32569: POP
32570: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
32571: LD_INT 22
32573: PUSH
32574: LD_INT 7
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 21
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PPUSH
32595: CALL_OW 69
32599: NOT
32600: IFFALSE 32445
// end ;
32602: PPOPN 2
32604: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
32605: LD_INT 0
32607: PPUSH
32608: PPUSH
// if not unit then
32609: LD_VAR 0 1
32613: NOT
32614: IFFALSE 32618
// exit ;
32616: GO 34116
// DoNotAttack ( 7 , unit ) ;
32618: LD_INT 7
32620: PPUSH
32621: LD_VAR 0 1
32625: PPUSH
32626: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
32630: LD_VAR 0 1
32634: PPUSH
32635: LD_INT 260
32637: PPUSH
32638: LD_INT 235
32640: PPUSH
32641: LD_INT 3
32643: PPUSH
32644: LD_INT 1
32646: PPUSH
32647: CALL_OW 483
// SetSide ( unit , 4 ) ;
32651: LD_VAR 0 1
32655: PPUSH
32656: LD_INT 4
32658: PPUSH
32659: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
32663: LD_ADDR_EXP 34
32667: PUSH
32668: LD_EXP 34
32672: PUSH
32673: LD_INT 1
32675: PLUS
32676: ST_TO_ADDR
// wait ( 0 0$2 ) ;
32677: LD_INT 70
32679: PPUSH
32680: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
32684: LD_INT 260
32686: PPUSH
32687: LD_INT 235
32689: PPUSH
32690: LD_INT 1
32692: PPUSH
32693: LD_INT 8
32695: NEG
32696: PPUSH
32697: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
32701: LD_VAR 0 1
32705: PPUSH
32706: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
32710: LD_VAR 0 1
32714: PPUSH
32715: LD_EXP 76
32719: PPUSH
32720: CALL_OW 119
// DialogueOn ;
32724: CALL_OW 6
// case unit of JMM :
32728: LD_VAR 0 1
32732: PUSH
32733: LD_EXP 40
32737: DOUBLE
32738: EQUAL
32739: IFTRUE 32743
32741: GO 32758
32743: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
32744: LD_EXP 40
32748: PPUSH
32749: LD_STRING DA1-JMM-1
32751: PPUSH
32752: CALL_OW 91
32756: GO 33200
32758: LD_EXP 41
32762: DOUBLE
32763: EQUAL
32764: IFTRUE 32768
32766: GO 32783
32768: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
32769: LD_EXP 41
32773: PPUSH
32774: LD_STRING DA1-Joan-1
32776: PPUSH
32777: CALL_OW 91
32781: GO 33200
32783: LD_EXP 43
32787: DOUBLE
32788: EQUAL
32789: IFTRUE 32793
32791: GO 32808
32793: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
32794: LD_EXP 43
32798: PPUSH
32799: LD_STRING DA1-Lisa-1
32801: PPUSH
32802: CALL_OW 91
32806: GO 33200
32808: LD_EXP 44
32812: DOUBLE
32813: EQUAL
32814: IFTRUE 32818
32816: GO 32833
32818: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
32819: LD_EXP 44
32823: PPUSH
32824: LD_STRING DA1-Don-1
32826: PPUSH
32827: CALL_OW 91
32831: GO 33200
32833: LD_EXP 51
32837: DOUBLE
32838: EQUAL
32839: IFTRUE 32843
32841: GO 32858
32843: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
32844: LD_EXP 51
32848: PPUSH
32849: LD_STRING DA1-Corn-1
32851: PPUSH
32852: CALL_OW 91
32856: GO 33200
32858: LD_EXP 47
32862: DOUBLE
32863: EQUAL
32864: IFTRUE 32868
32866: GO 32883
32868: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
32869: LD_EXP 47
32873: PPUSH
32874: LD_STRING DA1-Den-1
32876: PPUSH
32877: CALL_OW 91
32881: GO 33200
32883: LD_EXP 45
32887: DOUBLE
32888: EQUAL
32889: IFTRUE 32893
32891: GO 32908
32893: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
32894: LD_EXP 45
32898: PPUSH
32899: LD_STRING DA1-Bobby-1
32901: PPUSH
32902: CALL_OW 91
32906: GO 33200
32908: LD_EXP 49
32912: DOUBLE
32913: EQUAL
32914: IFTRUE 32918
32916: GO 32933
32918: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
32919: LD_EXP 49
32923: PPUSH
32924: LD_STRING DA1-Glad-1
32926: PPUSH
32927: CALL_OW 91
32931: GO 33200
32933: LD_EXP 46
32937: DOUBLE
32938: EQUAL
32939: IFTRUE 32943
32941: GO 32958
32943: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
32944: LD_EXP 46
32948: PPUSH
32949: LD_STRING DA1-Cyrus-1
32951: PPUSH
32952: CALL_OW 91
32956: GO 33200
32958: LD_EXP 42
32962: DOUBLE
32963: EQUAL
32964: IFTRUE 32968
32966: GO 32983
32968: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
32969: LD_EXP 42
32973: PPUSH
32974: LD_STRING DA1-Huck-1
32976: PPUSH
32977: CALL_OW 91
32981: GO 33200
32983: LD_EXP 56
32987: DOUBLE
32988: EQUAL
32989: IFTRUE 32993
32991: GO 33008
32993: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
32994: LD_EXP 56
32998: PPUSH
32999: LD_STRING DA1-Huck-1
33001: PPUSH
33002: CALL_OW 91
33006: GO 33200
33008: LD_EXP 48
33012: DOUBLE
33013: EQUAL
33014: IFTRUE 33018
33016: GO 33033
33018: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
33019: LD_EXP 48
33023: PPUSH
33024: LD_STRING DA1-Brown-1
33026: PPUSH
33027: CALL_OW 91
33031: GO 33200
33033: LD_EXP 52
33037: DOUBLE
33038: EQUAL
33039: IFTRUE 33043
33041: GO 33058
33043: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
33044: LD_EXP 52
33048: PPUSH
33049: LD_STRING DA1-Gary-1
33051: PPUSH
33052: CALL_OW 91
33056: GO 33200
33058: LD_EXP 55
33062: DOUBLE
33063: EQUAL
33064: IFTRUE 33068
33066: GO 33083
33068: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
33069: LD_EXP 55
33073: PPUSH
33074: LD_STRING DA1-Con-1
33076: PPUSH
33077: CALL_OW 91
33081: GO 33200
33083: LD_EXP 61
33087: DOUBLE
33088: EQUAL
33089: IFTRUE 33093
33091: GO 33108
33093: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
33094: LD_EXP 61
33098: PPUSH
33099: LD_STRING DA1-Kurt-1
33101: PPUSH
33102: CALL_OW 91
33106: GO 33200
33108: LD_EXP 54
33112: DOUBLE
33113: EQUAL
33114: IFTRUE 33118
33116: GO 33133
33118: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
33119: LD_EXP 54
33123: PPUSH
33124: LD_STRING DA1-Yam-1
33126: PPUSH
33127: CALL_OW 91
33131: GO 33200
33133: LD_EXP 53
33137: DOUBLE
33138: EQUAL
33139: IFTRUE 33143
33141: GO 33158
33143: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
33144: LD_EXP 53
33148: PPUSH
33149: LD_STRING DA1-Frank-1
33151: PPUSH
33152: CALL_OW 91
33156: GO 33200
33158: POP
// begin if GetSex ( unit ) = sex_male then
33159: LD_VAR 0 1
33163: PPUSH
33164: CALL_OW 258
33168: PUSH
33169: LD_INT 1
33171: EQUAL
33172: IFFALSE 33188
// ForceSay ( unit , DA1-Sol1-1 ) else
33174: LD_VAR 0 1
33178: PPUSH
33179: LD_STRING DA1-Sol1-1
33181: PPUSH
33182: CALL_OW 91
33186: GO 33200
// ForceSay ( unit , DA1-FSol1-1 ) ;
33188: LD_VAR 0 1
33192: PPUSH
33193: LD_STRING DA1-FSol1-1
33195: PPUSH
33196: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
33200: LD_EXP 76
33204: PPUSH
33205: LD_STRING DA-Roth-1
33207: PPUSH
33208: CALL_OW 88
// if capturedUnit = 1 then
33212: LD_EXP 34
33216: PUSH
33217: LD_INT 1
33219: EQUAL
33220: IFFALSE 33248
// begin Say ( Simms , DA-Sim-1 ) ;
33222: LD_EXP 77
33226: PPUSH
33227: LD_STRING DA-Sim-1
33229: PPUSH
33230: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
33234: LD_EXP 76
33238: PPUSH
33239: LD_STRING DA-Roth-2
33241: PPUSH
33242: CALL_OW 88
// end else
33246: GO 33260
// Say ( Simms , DA-Sim-2 ) ;
33248: LD_EXP 77
33252: PPUSH
33253: LD_STRING DA-Sim-2
33255: PPUSH
33256: CALL_OW 88
// case unit of JMM :
33260: LD_VAR 0 1
33264: PUSH
33265: LD_EXP 40
33269: DOUBLE
33270: EQUAL
33271: IFTRUE 33275
33273: GO 33290
33275: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
33276: LD_EXP 40
33280: PPUSH
33281: LD_STRING DA1-JMM-1a
33283: PPUSH
33284: CALL_OW 91
33288: GO 33797
33290: LD_EXP 41
33294: DOUBLE
33295: EQUAL
33296: IFTRUE 33300
33298: GO 33315
33300: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
33301: LD_EXP 41
33305: PPUSH
33306: LD_STRING DA1-Joan-1a
33308: PPUSH
33309: CALL_OW 91
33313: GO 33797
33315: LD_EXP 43
33319: DOUBLE
33320: EQUAL
33321: IFTRUE 33325
33323: GO 33340
33325: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
33326: LD_EXP 43
33330: PPUSH
33331: LD_STRING DA1-Lisa-1a
33333: PPUSH
33334: CALL_OW 91
33338: GO 33797
33340: LD_EXP 44
33344: DOUBLE
33345: EQUAL
33346: IFTRUE 33350
33348: GO 33365
33350: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
33351: LD_EXP 44
33355: PPUSH
33356: LD_STRING DA1-Don-1a
33358: PPUSH
33359: CALL_OW 91
33363: GO 33797
33365: LD_EXP 51
33369: DOUBLE
33370: EQUAL
33371: IFTRUE 33375
33373: GO 33390
33375: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
33376: LD_EXP 51
33380: PPUSH
33381: LD_STRING DA1-Corn-1a
33383: PPUSH
33384: CALL_OW 91
33388: GO 33797
33390: LD_EXP 47
33394: DOUBLE
33395: EQUAL
33396: IFTRUE 33400
33398: GO 33415
33400: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
33401: LD_EXP 47
33405: PPUSH
33406: LD_STRING DA1-Den-1a
33408: PPUSH
33409: CALL_OW 91
33413: GO 33797
33415: LD_EXP 45
33419: DOUBLE
33420: EQUAL
33421: IFTRUE 33425
33423: GO 33440
33425: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
33426: LD_EXP 45
33430: PPUSH
33431: LD_STRING DA1-Bobby-1a
33433: PPUSH
33434: CALL_OW 91
33438: GO 33797
33440: LD_EXP 49
33444: DOUBLE
33445: EQUAL
33446: IFTRUE 33450
33448: GO 33465
33450: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
33451: LD_EXP 49
33455: PPUSH
33456: LD_STRING DA1-Glad-1a
33458: PPUSH
33459: CALL_OW 91
33463: GO 33797
33465: LD_EXP 46
33469: DOUBLE
33470: EQUAL
33471: IFTRUE 33475
33473: GO 33490
33475: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
33476: LD_EXP 46
33480: PPUSH
33481: LD_STRING DA1-Cyrus-1a
33483: PPUSH
33484: CALL_OW 91
33488: GO 33797
33490: LD_EXP 42
33494: DOUBLE
33495: EQUAL
33496: IFTRUE 33500
33498: GO 33515
33500: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
33501: LD_EXP 42
33505: PPUSH
33506: LD_STRING DA1-Huck-1a
33508: PPUSH
33509: CALL_OW 91
33513: GO 33797
33515: LD_EXP 56
33519: DOUBLE
33520: EQUAL
33521: IFTRUE 33525
33523: GO 33540
33525: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
33526: LD_EXP 56
33530: PPUSH
33531: LD_STRING DA1-Huck-1a
33533: PPUSH
33534: CALL_OW 91
33538: GO 33797
33540: LD_EXP 48
33544: DOUBLE
33545: EQUAL
33546: IFTRUE 33550
33548: GO 33565
33550: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
33551: LD_EXP 48
33555: PPUSH
33556: LD_STRING DA1-Brown-1a
33558: PPUSH
33559: CALL_OW 91
33563: GO 33797
33565: LD_EXP 52
33569: DOUBLE
33570: EQUAL
33571: IFTRUE 33575
33573: GO 33590
33575: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
33576: LD_EXP 52
33580: PPUSH
33581: LD_STRING DA1-Gary-1a
33583: PPUSH
33584: CALL_OW 91
33588: GO 33797
33590: LD_EXP 55
33594: DOUBLE
33595: EQUAL
33596: IFTRUE 33600
33598: GO 33615
33600: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
33601: LD_EXP 55
33605: PPUSH
33606: LD_STRING DA1-Con-1a
33608: PPUSH
33609: CALL_OW 91
33613: GO 33797
33615: LD_EXP 61
33619: DOUBLE
33620: EQUAL
33621: IFTRUE 33625
33623: GO 33640
33625: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
33626: LD_EXP 61
33630: PPUSH
33631: LD_STRING DA1-Kurt-1a
33633: PPUSH
33634: CALL_OW 91
33638: GO 33797
33640: LD_EXP 54
33644: DOUBLE
33645: EQUAL
33646: IFTRUE 33650
33648: GO 33665
33650: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
33651: LD_EXP 54
33655: PPUSH
33656: LD_STRING DA1-Yam-1a
33658: PPUSH
33659: CALL_OW 91
33663: GO 33797
33665: LD_EXP 53
33669: DOUBLE
33670: EQUAL
33671: IFTRUE 33675
33673: GO 33690
33675: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
33676: LD_EXP 53
33680: PPUSH
33681: LD_STRING DA1-Frank-1a
33683: PPUSH
33684: CALL_OW 91
33688: GO 33797
33690: POP
// begin join := rand ( 0 , 1 ) ;
33691: LD_ADDR_VAR 0 3
33695: PUSH
33696: LD_INT 0
33698: PPUSH
33699: LD_INT 1
33701: PPUSH
33702: CALL_OW 12
33706: ST_TO_ADDR
// if join then
33707: LD_VAR 0 3
33711: IFFALSE 33756
// begin if GetSex ( unit ) = sex_male then
33713: LD_VAR 0 1
33717: PPUSH
33718: CALL_OW 258
33722: PUSH
33723: LD_INT 1
33725: EQUAL
33726: IFFALSE 33742
// ForceSay ( unit , DA1-Sol1-1b ) else
33728: LD_VAR 0 1
33732: PPUSH
33733: LD_STRING DA1-Sol1-1b
33735: PPUSH
33736: CALL_OW 91
33740: GO 33754
// ForceSay ( unit , DA1-FSol1-1b ) ;
33742: LD_VAR 0 1
33746: PPUSH
33747: LD_STRING DA1-FSol1-1b
33749: PPUSH
33750: CALL_OW 91
// end else
33754: GO 33797
// begin if GetSex ( unit ) = sex_male then
33756: LD_VAR 0 1
33760: PPUSH
33761: CALL_OW 258
33765: PUSH
33766: LD_INT 1
33768: EQUAL
33769: IFFALSE 33785
// ForceSay ( unit , DA1-Sol1-1a ) else
33771: LD_VAR 0 1
33775: PPUSH
33776: LD_STRING DA1-Sol1-1a
33778: PPUSH
33779: CALL_OW 91
33783: GO 33797
// ForceSay ( unit , DA1-FSol1-1a ) ;
33785: LD_VAR 0 1
33789: PPUSH
33790: LD_STRING DA1-FSol1-1a
33792: PPUSH
33793: CALL_OW 91
// end ; end ; end ; if unit = JMM then
33797: LD_VAR 0 1
33801: PUSH
33802: LD_EXP 40
33806: EQUAL
33807: IFFALSE 33818
// begin YouLost ( JMMCaptured ) ;
33809: LD_STRING JMMCaptured
33811: PPUSH
33812: CALL_OW 104
// exit ;
33816: GO 34116
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
33818: LD_VAR 0 1
33822: PUSH
33823: LD_EXP 44
33827: PUSH
33828: LD_EXP 47
33832: PUSH
33833: LD_EXP 45
33837: PUSH
33838: LD_EXP 42
33842: PUSH
33843: LD_EXP 56
33847: PUSH
33848: LD_EXP 48
33852: PUSH
33853: LD_EXP 54
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: LIST
33866: IN
33867: PUSH
33868: LD_VAR 0 3
33872: OR
33873: IFFALSE 33972
// begin Say ( Roth , DA-Roth-3 ) ;
33875: LD_EXP 76
33879: PPUSH
33880: LD_STRING DA-Roth-3
33882: PPUSH
33883: CALL_OW 88
// SetSide ( unit , 7 ) ;
33887: LD_VAR 0 1
33891: PPUSH
33892: LD_INT 7
33894: PPUSH
33895: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
33899: LD_ADDR_EXP 99
33903: PUSH
33904: LD_EXP 99
33908: PPUSH
33909: LD_INT 1
33911: PPUSH
33912: LD_EXP 99
33916: PUSH
33917: LD_INT 1
33919: ARRAY
33920: PUSH
33921: LD_VAR 0 1
33925: ADD
33926: PPUSH
33927: CALL_OW 1
33931: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
33932: LD_INT 260
33934: PPUSH
33935: LD_INT 235
33937: PPUSH
33938: LD_INT 1
33940: PPUSH
33941: CALL_OW 331
// SetLives ( unit , 1000 ) ;
33945: LD_VAR 0 1
33949: PPUSH
33950: LD_INT 1000
33952: PPUSH
33953: CALL_OW 234
// DialogueOff ;
33957: CALL_OW 7
// ComFree ( unit ) ;
33961: LD_VAR 0 1
33965: PPUSH
33966: CALL_OW 139
// end else
33970: GO 34053
// begin Say ( Roth , DA-Roth-3a ) ;
33972: LD_EXP 76
33976: PPUSH
33977: LD_STRING DA-Roth-3a
33979: PPUSH
33980: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
33984: LD_ADDR_EXP 35
33988: PUSH
33989: LD_EXP 35
33993: PUSH
33994: LD_VAR 0 1
33998: ADD
33999: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
34000: LD_INT 260
34002: PPUSH
34003: LD_INT 235
34005: PPUSH
34006: LD_INT 1
34008: PPUSH
34009: CALL_OW 331
// SetLives ( unit , 1000 ) ;
34013: LD_VAR 0 1
34017: PPUSH
34018: LD_INT 1000
34020: PPUSH
34021: CALL_OW 234
// DialogueOff ;
34025: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: LD_INT 272
34036: PPUSH
34037: LD_INT 254
34039: PPUSH
34040: CALL_OW 111
// AddComHold ( unit ) ;
34044: LD_VAR 0 1
34048: PPUSH
34049: CALL_OW 200
// end ; if capturedUnit = 1 then
34053: LD_EXP 34
34057: PUSH
34058: LD_INT 1
34060: EQUAL
34061: IFFALSE 34116
// begin DialogueOn ;
34063: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
34067: LD_EXP 40
34071: PPUSH
34072: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
34076: LD_EXP 40
34080: PPUSH
34081: LD_STRING DAa-JMM-1
34083: PPUSH
34084: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
34088: LD_EXP 40
34092: PPUSH
34093: LD_STRING DAa-JMM-1a
34095: PPUSH
34096: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
34100: LD_EXP 40
34104: PPUSH
34105: LD_STRING DAa-JMM-1b
34107: PPUSH
34108: CALL_OW 88
// DialogueOff ;
34112: CALL_OW 7
// end ; end ;
34116: LD_VAR 0 2
34120: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
34121: LD_EXP 15
34125: PUSH
34126: LD_INT 13
34128: GREATEREQUAL
34129: PUSH
34130: LD_INT 22
34132: PUSH
34133: LD_INT 2
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 21
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PPUSH
34154: CALL_OW 69
34158: PUSH
34159: LD_INT 0
34161: EQUAL
34162: AND
34163: PUSH
34164: LD_INT 22
34166: PUSH
34167: LD_INT 2
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 33
34176: PUSH
34177: LD_INT 5
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 21
34186: PUSH
34187: LD_INT 2
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 50
34196: PUSH
34197: EMPTY
34198: LIST
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: PPUSH
34206: CALL_OW 69
34210: PUSH
34211: LD_INT 0
34213: EQUAL
34214: AND
34215: PUSH
34216: LD_EXP 21
34220: AND
34221: PUSH
34222: LD_EXP 22
34226: AND
34227: PUSH
34228: LD_EXP 23
34232: AND
34233: IFFALSE 34922
34235: GO 34237
34237: DISABLE
34238: LD_INT 0
34240: PPUSH
34241: PPUSH
34242: PPUSH
// begin m1 := false ;
34243: LD_ADDR_VAR 0 1
34247: PUSH
34248: LD_INT 0
34250: ST_TO_ADDR
// m2 := false ;
34251: LD_ADDR_VAR 0 2
34255: PUSH
34256: LD_INT 0
34258: ST_TO_ADDR
// m3 := false ;
34259: LD_ADDR_VAR 0 3
34263: PUSH
34264: LD_INT 0
34266: ST_TO_ADDR
// if not bombExploded then
34267: LD_EXP 37
34271: NOT
34272: IFFALSE 34281
// SetAchievement ( ACH_SIBROCKET ) ;
34274: LD_STRING ACH_SIBROCKET
34276: PPUSH
34277: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
34281: LD_EXP 63
34285: PPUSH
34286: CALL_OW 255
34290: PUSH
34291: LD_INT 1
34293: EQUAL
34294: PUSH
34295: LD_EXP 63
34299: PPUSH
34300: CALL_OW 302
34304: AND
34305: IFFALSE 34321
// begin wait ( 3 ) ;
34307: LD_INT 3
34309: PPUSH
34310: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
34314: LD_STRING ACH_OPO
34316: PPUSH
34317: CALL_OW 543
// end ; if tick <= 120 120$00 then
34321: LD_OWVAR 1
34325: PUSH
34326: LD_INT 252000
34328: LESSEQUAL
34329: IFFALSE 34345
// begin wait ( 3 ) ;
34331: LD_INT 3
34333: PPUSH
34334: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
34338: LD_STRING ACH_ASPEED_15
34340: PPUSH
34341: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
34345: LD_EXP 40
34349: PPUSH
34350: CALL_OW 87
// music_class := 5 ;
34354: LD_ADDR_OWVAR 72
34358: PUSH
34359: LD_INT 5
34361: ST_TO_ADDR
// music_nat := 5 ;
34362: LD_ADDR_OWVAR 71
34366: PUSH
34367: LD_INT 5
34369: ST_TO_ADDR
// DialogueOn ;
34370: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
34374: LD_EXP 40
34378: PPUSH
34379: LD_STRING D20-JMM-1
34381: PPUSH
34382: CALL_OW 88
// if IsOK ( Joan ) then
34386: LD_EXP 41
34390: PPUSH
34391: CALL_OW 302
34395: IFFALSE 34409
// Say ( Joan , D20-Joan-1 ) ;
34397: LD_EXP 41
34401: PPUSH
34402: LD_STRING D20-Joan-1
34404: PPUSH
34405: CALL_OW 88
// if IsOk ( Lisa ) then
34409: LD_EXP 43
34413: PPUSH
34414: CALL_OW 302
34418: IFFALSE 34432
// Say ( Lisa , D20-Lisa-1 ) ;
34420: LD_EXP 43
34424: PPUSH
34425: LD_STRING D20-Lisa-1
34427: PPUSH
34428: CALL_OW 88
// if IsOk ( Donaldson ) then
34432: LD_EXP 44
34436: PPUSH
34437: CALL_OW 302
34441: IFFALSE 34455
// Say ( Donaldson , D20-Don-1 ) ;
34443: LD_EXP 44
34447: PPUSH
34448: LD_STRING D20-Don-1
34450: PPUSH
34451: CALL_OW 88
// if IsOK ( Cornel ) then
34455: LD_EXP 51
34459: PPUSH
34460: CALL_OW 302
34464: IFFALSE 34478
// Say ( Cornel , D20-Corn-1 ) ;
34466: LD_EXP 51
34470: PPUSH
34471: LD_STRING D20-Corn-1
34473: PPUSH
34474: CALL_OW 88
// if IsOk ( Denis ) then
34478: LD_EXP 47
34482: PPUSH
34483: CALL_OW 302
34487: IFFALSE 34501
// Say ( Denis , D20-Den-1 ) ;
34489: LD_EXP 47
34493: PPUSH
34494: LD_STRING D20-Den-1
34496: PPUSH
34497: CALL_OW 88
// if IsOk ( Bobby ) then
34501: LD_EXP 45
34505: PPUSH
34506: CALL_OW 302
34510: IFFALSE 34524
// Say ( Bobby , D20-Bobby-1 ) ;
34512: LD_EXP 45
34516: PPUSH
34517: LD_STRING D20-Bobby-1
34519: PPUSH
34520: CALL_OW 88
// if IsOk ( Gladstone ) then
34524: LD_EXP 49
34528: PPUSH
34529: CALL_OW 302
34533: IFFALSE 34547
// Say ( Gladstone , D20-Glad-1 ) ;
34535: LD_EXP 49
34539: PPUSH
34540: LD_STRING D20-Glad-1
34542: PPUSH
34543: CALL_OW 88
// if IsOk ( Cyrus ) then
34547: LD_EXP 46
34551: PPUSH
34552: CALL_OW 302
34556: IFFALSE 34570
// Say ( Cyrus , D20-Cyrus-1 ) ;
34558: LD_EXP 46
34562: PPUSH
34563: LD_STRING D20-Cyrus-1
34565: PPUSH
34566: CALL_OW 88
// if IsOk ( Stevens ) then
34570: LD_EXP 42
34574: PPUSH
34575: CALL_OW 302
34579: IFFALSE 34593
// Say ( Stevens , D20-Huck-1 ) ;
34581: LD_EXP 42
34585: PPUSH
34586: LD_STRING D20-Huck-1
34588: PPUSH
34589: CALL_OW 88
// if IsOk ( Brown ) then
34593: LD_EXP 48
34597: PPUSH
34598: CALL_OW 302
34602: IFFALSE 34616
// Say ( Brown , D20-Brown-1 ) ;
34604: LD_EXP 48
34608: PPUSH
34609: LD_STRING D20-Brown-1
34611: PPUSH
34612: CALL_OW 88
// if IsOk ( Gary ) then
34616: LD_EXP 52
34620: PPUSH
34621: CALL_OW 302
34625: IFFALSE 34639
// Say ( Gary , D20-Gary-1 ) ;
34627: LD_EXP 52
34631: PPUSH
34632: LD_STRING D20-Gary-1
34634: PPUSH
34635: CALL_OW 88
// if IsOk ( Connie ) then
34639: LD_EXP 55
34643: PPUSH
34644: CALL_OW 302
34648: IFFALSE 34662
// Say ( Connie , D20-Con-1 ) ;
34650: LD_EXP 55
34654: PPUSH
34655: LD_STRING D20-Con-1
34657: PPUSH
34658: CALL_OW 88
// if IsOk ( Kurt ) then
34662: LD_EXP 61
34666: PPUSH
34667: CALL_OW 302
34671: IFFALSE 34685
// Say ( Kurt , D20-Kurt-1 ) ;
34673: LD_EXP 61
34677: PPUSH
34678: LD_STRING D20-Kurt-1
34680: PPUSH
34681: CALL_OW 88
// if IsOk ( Kikuchi ) then
34685: LD_EXP 54
34689: PPUSH
34690: CALL_OW 302
34694: IFFALSE 34708
// Say ( Kikuchi , D20-Yam-1 ) ;
34696: LD_EXP 54
34700: PPUSH
34701: LD_STRING D20-Yam-1
34703: PPUSH
34704: CALL_OW 88
// if IsOk ( Frank ) then
34708: LD_EXP 53
34712: PPUSH
34713: CALL_OW 302
34717: IFFALSE 34731
// Say ( Frank , D20-Frank-1 ) ;
34719: LD_EXP 53
34723: PPUSH
34724: LD_STRING D20-Frank-1
34726: PPUSH
34727: CALL_OW 88
// DialogueOff ;
34731: CALL_OW 7
// if RothCaptured then
34735: LD_EXP 33
34739: IFFALSE 34761
// begin m1 := true ;
34741: LD_ADDR_VAR 0 1
34745: PUSH
34746: LD_INT 1
34748: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
34749: LD_STRING Roth
34751: PPUSH
34752: LD_INT 1
34754: PPUSH
34755: CALL_OW 101
// end else
34759: GO 34772
// AddMedal ( Roth , - 1 ) ;
34761: LD_STRING Roth
34763: PPUSH
34764: LD_INT 1
34766: NEG
34767: PPUSH
34768: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
34772: LD_EXP 25
34776: NOT
34777: PUSH
34778: LD_EXP 27
34782: OR
34783: IFFALSE 34805
// begin m2 := true ;
34785: LD_ADDR_VAR 0 2
34789: PUSH
34790: LD_INT 1
34792: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
34793: LD_STRING Project
34795: PPUSH
34796: LD_INT 1
34798: PPUSH
34799: CALL_OW 101
// end else
34803: GO 34816
// AddMedal ( Project , - 1 ) ;
34805: LD_STRING Project
34807: PPUSH
34808: LD_INT 1
34810: NEG
34811: PPUSH
34812: CALL_OW 101
// if lostCounter = 0 then
34816: LD_EXP 32
34820: PUSH
34821: LD_INT 0
34823: EQUAL
34824: IFFALSE 34846
// begin m3 := true ;
34826: LD_ADDR_VAR 0 3
34830: PUSH
34831: LD_INT 1
34833: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
34834: LD_STRING NoLosses
34836: PPUSH
34837: LD_INT 1
34839: PPUSH
34840: CALL_OW 101
// end else
34844: GO 34857
// AddMedal ( NoLosses , - 1 ) ;
34846: LD_STRING NoLosses
34848: PPUSH
34849: LD_INT 1
34851: NEG
34852: PPUSH
34853: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
34857: LD_VAR 0 1
34861: PUSH
34862: LD_VAR 0 2
34866: AND
34867: PUSH
34868: LD_VAR 0 3
34872: AND
34873: PUSH
34874: LD_OWVAR 67
34878: PUSH
34879: LD_INT 3
34881: GREATEREQUAL
34882: AND
34883: IFFALSE 34895
// SetAchievementEX ( ACH_AMER , 15 ) ;
34885: LD_STRING ACH_AMER
34887: PPUSH
34888: LD_INT 15
34890: PPUSH
34891: CALL_OW 564
// GiveMedals ( MAIN ) ;
34895: LD_STRING MAIN
34897: PPUSH
34898: CALL_OW 102
// music_class := 4 ;
34902: LD_ADDR_OWVAR 72
34906: PUSH
34907: LD_INT 4
34909: ST_TO_ADDR
// music_nat := 1 ;
34910: LD_ADDR_OWVAR 71
34914: PUSH
34915: LD_INT 1
34917: ST_TO_ADDR
// YouWin ;
34918: CALL_OW 103
// end ; end_of_file
34922: PPOPN 3
34924: END
// export function CustomEvent ( event ) ; begin
34925: LD_INT 0
34927: PPUSH
// end ;
34928: LD_VAR 0 2
34932: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
34933: LD_VAR 0 1
34937: PUSH
34938: LD_INT 1
34940: EQUAL
34941: PUSH
34942: LD_VAR 0 2
34946: PUSH
34947: LD_INT 4
34949: EQUAL
34950: AND
34951: PUSH
34952: LD_EXP 59
34956: PPUSH
34957: CALL_OW 300
34961: AND
34962: IFFALSE 34978
// begin wait ( 0 0$2 ) ;
34964: LD_INT 70
34966: PPUSH
34967: CALL_OW 67
// YouLost ( Dismissed ) ;
34971: LD_STRING Dismissed
34973: PPUSH
34974: CALL_OW 104
// end ; end ;
34978: PPOPN 2
34980: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
34981: LD_VAR 0 2
34985: PPUSH
34986: LD_VAR 0 3
34990: PPUSH
34991: LD_INT 18
34993: PPUSH
34994: CALL_OW 309
34998: IFFALSE 35007
// YouLost ( Motherlode3 ) ;
35000: LD_STRING Motherlode3
35002: PPUSH
35003: CALL_OW 104
// end ;
35007: PPOPN 3
35009: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
35010: LD_EXP 27
35014: NOT
35015: IFFALSE 35025
// behemothDone := true ;
35017: LD_ADDR_EXP 28
35021: PUSH
35022: LD_INT 1
35024: ST_TO_ADDR
// end ;
35025: PPOPN 1
35027: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
35028: LD_VAR 0 1
35032: PPUSH
35033: CALL_OW 255
35037: PUSH
35038: LD_INT 1
35040: EQUAL
35041: IFFALSE 35051
// bombExploded := true ;
35043: LD_ADDR_EXP 37
35047: PUSH
35048: LD_INT 1
35050: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
35051: LD_VAR 0 1
35055: PPUSH
35056: CALL_OW 255
35060: PUSH
35061: LD_INT 1
35063: EQUAL
35064: PUSH
35065: LD_EXP 30
35069: AND
35070: PUSH
35071: LD_INT 22
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 34
35083: PUSH
35084: LD_INT 48
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PPUSH
35095: CALL_OW 69
35099: AND
35100: PUSH
35101: LD_INT 22
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 34
35113: PUSH
35114: LD_INT 8
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PPUSH
35125: CALL_OW 69
35129: NOT
35130: AND
35131: IFFALSE 35183
// begin wait ( 0 0$5 ) ;
35133: LD_INT 175
35135: PPUSH
35136: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
35140: LD_INT 22
35142: PUSH
35143: LD_INT 3
35145: PUSH
35146: EMPTY
35147: LIST
35148: LIST
35149: PUSH
35150: LD_INT 34
35152: PUSH
35153: LD_INT 48
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PPUSH
35164: CALL_OW 69
35168: PUSH
35169: LD_INT 1
35171: ARRAY
35172: PPUSH
35173: LD_INT 60
35175: PPUSH
35176: LD_INT 95
35178: PPUSH
35179: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
35183: LD_VAR 0 2
35187: PPUSH
35188: LD_VAR 0 3
35192: PPUSH
35193: LD_INT 18
35195: PPUSH
35196: CALL_OW 309
35200: IFFALSE 35247
// begin if GetSide ( unit ) = 1 then
35202: LD_VAR 0 1
35206: PPUSH
35207: CALL_OW 255
35211: PUSH
35212: LD_INT 1
35214: EQUAL
35215: IFFALSE 35233
// begin wait ( 0 0$6 ) ;
35217: LD_INT 210
35219: PPUSH
35220: CALL_OW 67
// YouLost ( Motherlode2 ) ;
35224: LD_STRING Motherlode2
35226: PPUSH
35227: CALL_OW 104
// end else
35231: GO 35247
// begin wait ( 0 0$6 ) ;
35233: LD_INT 210
35235: PPUSH
35236: CALL_OW 67
// YouLost ( Motherlode1 ) ;
35240: LD_STRING Motherlode1
35242: PPUSH
35243: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
35247: LD_VAR 0 1
35251: PPUSH
35252: CALL_OW 255
35256: PUSH
35257: LD_INT 3
35259: EQUAL
35260: IFFALSE 35281
// begin wait ( 0 0$5 ) ;
35262: LD_INT 175
35264: PPUSH
35265: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
35269: LD_EXP 65
35273: PPUSH
35274: LD_STRING D18-Pla-1
35276: PPUSH
35277: CALL_OW 94
// end ; end ;
35281: PPOPN 3
35283: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
35284: LD_VAR 0 1
35288: PPUSH
35289: CALL 124102 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
35293: LD_VAR 0 1
35297: PUSH
35298: LD_INT 22
35300: PUSH
35301: LD_INT 1
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 21
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 23
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: LIST
35332: PPUSH
35333: CALL_OW 69
35337: IN
35338: IFFALSE 35354
// lostCounter := lostCounter + 1 ;
35340: LD_ADDR_EXP 32
35344: PUSH
35345: LD_EXP 32
35349: PUSH
35350: LD_INT 1
35352: PLUS
35353: ST_TO_ADDR
// if un in behemothBuilders then
35354: LD_VAR 0 1
35358: PUSH
35359: LD_EXP 74
35363: IN
35364: IFFALSE 35384
// begin behemothBuilders := behemothBuilders diff un ;
35366: LD_ADDR_EXP 74
35370: PUSH
35371: LD_EXP 74
35375: PUSH
35376: LD_VAR 0 1
35380: DIFF
35381: ST_TO_ADDR
// exit ;
35382: GO 35414
// end ; if un = JMM then
35384: LD_VAR 0 1
35388: PUSH
35389: LD_EXP 40
35393: EQUAL
35394: IFFALSE 35405
// begin YouLost ( JMM ) ;
35396: LD_STRING JMM
35398: PPUSH
35399: CALL_OW 104
// exit ;
35403: GO 35414
// end ; MCE_UnitDestroyed ( un ) ;
35405: LD_VAR 0 1
35409: PPUSH
35410: CALL 64211 0 1
// end ;
35414: PPOPN 1
35416: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
35417: LD_VAR 0 1
35421: PPUSH
35422: LD_VAR 0 2
35426: PPUSH
35427: CALL 66543 0 2
// end ;
35431: PPOPN 2
35433: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
35434: LD_VAR 0 1
35438: PPUSH
35439: CALL 65611 0 1
// end ;
35443: PPOPN 1
35445: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
35446: LD_VAR 0 1
35450: PUSH
35451: LD_INT 22
35453: PUSH
35454: LD_INT 8
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 30
35463: PUSH
35464: LD_INT 2
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 23
35473: PUSH
35474: LD_INT 3
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: LIST
35485: PPUSH
35486: CALL_OW 69
35490: IN
35491: IFFALSE 35518
// begin ComUpgrade ( building ) ;
35493: LD_VAR 0 1
35497: PPUSH
35498: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
35502: LD_EXP 62
35506: PPUSH
35507: LD_VAR 0 1
35511: PPUSH
35512: CALL 75193 0 2
// exit ;
35516: GO 35527
// end ; MCE_BuildingComplete ( building ) ;
35518: LD_VAR 0 1
35522: PPUSH
35523: CALL 65852 0 1
// end ;
35527: PPOPN 1
35529: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
35530: LD_VAR 0 1
35534: PPUSH
35535: LD_VAR 0 2
35539: PPUSH
35540: CALL 63907 0 2
// end ;
35544: PPOPN 2
35546: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
35547: LD_VAR 0 1
35551: PPUSH
35552: LD_VAR 0 2
35556: PPUSH
35557: LD_VAR 0 3
35561: PPUSH
35562: LD_VAR 0 4
35566: PPUSH
35567: LD_VAR 0 5
35571: PPUSH
35572: CALL 63527 0 5
// end ;
35576: PPOPN 5
35578: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
35579: LD_VAR 0 1
35583: PPUSH
35584: CALL_OW 255
35588: PUSH
35589: LD_INT 1
35591: EQUAL
35592: IFFALSE 35609
// amConstructCounter := Inc ( amConstructCounter ) ;
35594: LD_ADDR_EXP 39
35598: PUSH
35599: LD_EXP 39
35603: PPUSH
35604: CALL 106005 0 1
35608: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
35609: LD_VAR 0 1
35613: PPUSH
35614: LD_VAR 0 2
35618: PPUSH
35619: CALL 124222 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
35623: LD_VAR 0 1
35627: PPUSH
35628: LD_VAR 0 2
35632: PPUSH
35633: CALL 63118 0 2
// end ;
35637: PPOPN 2
35639: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
35640: LD_VAR 0 1
35644: PPUSH
35645: LD_VAR 0 2
35649: PPUSH
35650: LD_VAR 0 3
35654: PPUSH
35655: LD_VAR 0 4
35659: PPUSH
35660: CALL 62956 0 4
// end ;
35664: PPOPN 4
35666: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
35667: LD_VAR 0 1
35671: PPUSH
35672: LD_VAR 0 2
35676: PPUSH
35677: LD_VAR 0 3
35681: PPUSH
35682: CALL 62731 0 3
// end ;
35686: PPOPN 3
35688: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
35689: LD_VAR 0 1
35693: PPUSH
35694: LD_VAR 0 2
35698: PPUSH
35699: CALL 62616 0 2
// end ;
35703: PPOPN 2
35705: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
35706: LD_VAR 0 1
35710: PPUSH
35711: LD_VAR 0 2
35715: PPUSH
35716: CALL 66838 0 2
// end ;
35720: PPOPN 2
35722: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
35723: LD_VAR 0 1
35727: PPUSH
35728: CALL_OW 255
35732: PUSH
35733: LD_INT 4
35735: EQUAL
35736: PUSH
35737: LD_VAR 0 1
35741: PUSH
35742: LD_EXP 18
35746: PUSH
35747: LD_INT 1
35749: ARRAY
35750: IN
35751: AND
35752: PUSH
35753: LD_EXP 19
35757: AND
35758: IFFALSE 35777
// begin ComMoveXY ( driver , 61 , 93 ) ;
35760: LD_VAR 0 1
35764: PPUSH
35765: LD_INT 61
35767: PPUSH
35768: LD_INT 93
35770: PPUSH
35771: CALL_OW 111
// exit ;
35775: GO 35801
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
35777: LD_VAR 0 1
35781: PPUSH
35782: LD_VAR 0 2
35786: PPUSH
35787: LD_VAR 0 3
35791: PPUSH
35792: LD_VAR 0 4
35796: PPUSH
35797: CALL 67054 0 4
// end ;
35801: PPOPN 4
35803: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
35804: LD_VAR 0 1
35808: PPUSH
35809: LD_VAR 0 2
35813: PPUSH
35814: CALL 62425 0 2
// end ;
35818: PPOPN 2
35820: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
35821: LD_VAR 0 1
35825: PPUSH
35826: CALL 124206 0 1
// end ; end_of_file
35830: PPOPN 1
35832: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
35833: LD_EXP 15
35837: PUSH
35838: LD_INT 2
35840: EQUAL
35841: IFFALSE 36344
35843: GO 35845
35845: DISABLE
35846: LD_INT 0
35848: PPUSH
35849: PPUSH
// begin time := 0 0$35 ;
35850: LD_ADDR_VAR 0 2
35854: PUSH
35855: LD_INT 1225
35857: ST_TO_ADDR
// repeat wait ( time ) ;
35858: LD_VAR 0 2
35862: PPUSH
35863: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
35867: LD_INT 1
35869: PPUSH
35870: LD_INT 5
35872: PPUSH
35873: CALL_OW 12
35877: PPUSH
35878: LD_INT 106
35880: PPUSH
35881: LD_INT 150
35883: PPUSH
35884: LD_INT 19
35886: PPUSH
35887: LD_INT 1
35889: PPUSH
35890: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
35894: LD_INT 455
35896: PPUSH
35897: LD_INT 770
35899: PPUSH
35900: CALL_OW 12
35904: PPUSH
35905: CALL_OW 67
// if Prob ( 50 ) then
35909: LD_INT 50
35911: PPUSH
35912: CALL_OW 13
35916: IFFALSE 35945
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
35918: LD_INT 1
35920: PPUSH
35921: LD_INT 5
35923: PPUSH
35924: CALL_OW 12
35928: PPUSH
35929: LD_INT 62
35931: PPUSH
35932: LD_INT 108
35934: PPUSH
35935: LD_INT 10
35937: PPUSH
35938: LD_INT 1
35940: PPUSH
35941: CALL_OW 56
// until missionStage > 4 ;
35945: LD_EXP 15
35949: PUSH
35950: LD_INT 4
35952: GREATER
35953: IFFALSE 35858
// repeat wait ( 0 0$1 ) ;
35955: LD_INT 35
35957: PPUSH
35958: CALL_OW 67
// until missionStage = 6 ;
35962: LD_EXP 15
35966: PUSH
35967: LD_INT 6
35969: EQUAL
35970: IFFALSE 35955
// time := 0 0$20 ;
35972: LD_ADDR_VAR 0 2
35976: PUSH
35977: LD_INT 700
35979: ST_TO_ADDR
// repeat wait ( time ) ;
35980: LD_VAR 0 2
35984: PPUSH
35985: CALL_OW 67
// if Prob ( 90 ) then
35989: LD_INT 90
35991: PPUSH
35992: CALL_OW 13
35996: IFFALSE 36039
// begin time := time + 0 0$2 ;
35998: LD_ADDR_VAR 0 2
36002: PUSH
36003: LD_VAR 0 2
36007: PUSH
36008: LD_INT 70
36010: PLUS
36011: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
36012: LD_INT 1
36014: PPUSH
36015: LD_INT 5
36017: PPUSH
36018: CALL_OW 12
36022: PPUSH
36023: LD_INT 106
36025: PPUSH
36026: LD_INT 89
36028: PPUSH
36029: LD_INT 45
36031: PPUSH
36032: LD_INT 1
36034: PPUSH
36035: CALL_OW 56
// end ; if Prob ( 45 ) then
36039: LD_INT 45
36041: PPUSH
36042: CALL_OW 13
36046: IFFALSE 36102
// begin for i := 1 to 4 do
36048: LD_ADDR_VAR 0 1
36052: PUSH
36053: DOUBLE
36054: LD_INT 1
36056: DEC
36057: ST_TO_ADDR
36058: LD_INT 4
36060: PUSH
36061: FOR_TO
36062: IFFALSE 36100
// begin wait ( 0 0$5 ) ;
36064: LD_INT 175
36066: PPUSH
36067: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
36071: LD_INT 1
36073: PPUSH
36074: LD_INT 5
36076: PPUSH
36077: CALL_OW 12
36081: PPUSH
36082: LD_INT 113
36084: PPUSH
36085: LD_INT 117
36087: PPUSH
36088: LD_INT 25
36090: PPUSH
36091: LD_INT 1
36093: PPUSH
36094: CALL_OW 56
// end ;
36098: GO 36061
36100: POP
36101: POP
// end ; if Prob ( 40 ) then
36102: LD_INT 40
36104: PPUSH
36105: CALL_OW 13
36109: IFFALSE 36155
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
36111: LD_INT 385
36113: PPUSH
36114: LD_INT 945
36116: PPUSH
36117: CALL_OW 12
36121: PPUSH
36122: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
36126: LD_INT 1
36128: PPUSH
36129: LD_INT 5
36131: PPUSH
36132: CALL_OW 12
36136: PPUSH
36137: LD_INT 21
36139: PPUSH
36140: LD_INT 26
36142: PPUSH
36143: LD_INT 12
36145: PPUSH
36146: LD_INT 1
36148: PPUSH
36149: CALL_OW 56
// end else
36153: GO 36191
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
36155: LD_INT 700
36157: PPUSH
36158: LD_INT 1225
36160: PPUSH
36161: CALL_OW 12
36165: PPUSH
36166: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
36170: LD_INT 1
36172: PPUSH
36173: LD_INT 5
36175: PPUSH
36176: CALL_OW 12
36180: PPUSH
36181: LD_INT 16
36183: PPUSH
36184: LD_INT 1
36186: PPUSH
36187: CALL_OW 55
// end ; if Prob ( 50 ) then
36191: LD_INT 50
36193: PPUSH
36194: CALL_OW 13
36198: IFFALSE 36244
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
36200: LD_INT 700
36202: PPUSH
36203: LD_INT 1050
36205: PPUSH
36206: CALL_OW 12
36210: PPUSH
36211: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
36215: LD_INT 1
36217: PPUSH
36218: LD_INT 5
36220: PPUSH
36221: CALL_OW 12
36225: PPUSH
36226: LD_INT 168
36228: PPUSH
36229: LD_INT 168
36231: PPUSH
36232: LD_INT 16
36234: PPUSH
36235: LD_INT 1
36237: PPUSH
36238: CALL_OW 56
// end else
36242: GO 36280
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
36244: LD_INT 350
36246: PPUSH
36247: LD_INT 525
36249: PPUSH
36250: CALL_OW 12
36254: PPUSH
36255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
36259: LD_INT 1
36261: PPUSH
36262: LD_INT 5
36264: PPUSH
36265: CALL_OW 12
36269: PPUSH
36270: LD_INT 15
36272: PPUSH
36273: LD_INT 1
36275: PPUSH
36276: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
36280: LD_INT 175
36282: PPUSH
36283: LD_INT 315
36285: PPUSH
36286: CALL_OW 12
36290: PPUSH
36291: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
36295: LD_INT 1
36297: PPUSH
36298: LD_INT 5
36300: PPUSH
36301: CALL_OW 12
36305: PPUSH
36306: LD_INT 103
36308: PPUSH
36309: LD_INT 140
36311: PPUSH
36312: LD_INT 20
36314: PPUSH
36315: LD_INT 1
36317: PPUSH
36318: CALL_OW 56
// if time > 1 1$10 then
36322: LD_VAR 0 2
36326: PUSH
36327: LD_INT 2450
36329: GREATER
36330: IFFALSE 36340
// time := 0 0$30 ;
36332: LD_ADDR_VAR 0 2
36336: PUSH
36337: LD_INT 1050
36339: ST_TO_ADDR
// until false ;
36340: LD_INT 0
36342: IFFALSE 35980
// end ; end_of_file
36344: PPOPN 2
36346: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
36347: LD_EXP 13
36351: PUSH
36352: LD_EXP 15
36356: PUSH
36357: LD_INT 6
36359: GREATEREQUAL
36360: AND
36361: IFFALSE 36398
36363: GO 36365
36365: DISABLE
// begin enable ;
36366: ENABLE
// missionTime := missionTime + 0 0$1 ;
36367: LD_ADDR_EXP 14
36371: PUSH
36372: LD_EXP 14
36376: PUSH
36377: LD_INT 35
36379: PLUS
36380: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
36381: LD_ADDR_OWVAR 47
36385: PUSH
36386: LD_STRING #Am15-1
36388: PUSH
36389: LD_EXP 14
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: ST_TO_ADDR
// end ; end_of_file
36398: END
// export function InitNature ; begin
36399: LD_INT 0
36401: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
36402: LD_INT 3
36404: PPUSH
36405: LD_INT 3
36407: PPUSH
36408: LD_INT 2
36410: PPUSH
36411: LD_INT 1
36413: PPUSH
36414: LD_INT 1
36416: PPUSH
36417: LD_INT 0
36419: PPUSH
36420: LD_INT 0
36422: PPUSH
36423: LD_INT 20
36425: PPUSH
36426: LD_INT 0
36428: PPUSH
36429: CALL 101326 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
36433: LD_INT 2
36435: PPUSH
36436: LD_INT 1
36438: PPUSH
36439: LD_INT 1
36441: PPUSH
36442: LD_INT 1
36444: PPUSH
36445: LD_INT 1
36447: PPUSH
36448: LD_INT 0
36450: PPUSH
36451: LD_INT 0
36453: PPUSH
36454: LD_INT 21
36456: PPUSH
36457: LD_INT 0
36459: PPUSH
36460: CALL 101326 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
36464: LD_INT 4
36466: PPUSH
36467: LD_INT 1
36469: PPUSH
36470: LD_INT 2
36472: PPUSH
36473: LD_INT 4
36475: PPUSH
36476: LD_INT 2
36478: PPUSH
36479: LD_INT 1
36481: PPUSH
36482: LD_INT 0
36484: PPUSH
36485: LD_INT 22
36487: PPUSH
36488: LD_INT 0
36490: PPUSH
36491: CALL 101326 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
36495: LD_INT 0
36497: PPUSH
36498: LD_INT 0
36500: PPUSH
36501: LD_INT 0
36503: PPUSH
36504: LD_INT 0
36506: PPUSH
36507: LD_INT 0
36509: PPUSH
36510: LD_INT 0
36512: PPUSH
36513: LD_INT 9
36515: PPUSH
36516: LD_INT 0
36518: PPUSH
36519: LD_INT 23
36521: PPUSH
36522: CALL 101326 0 9
// end ; end_of_file
36526: LD_VAR 0 1
36530: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
36531: LD_INT 0
36533: PPUSH
36534: PPUSH
// skirmish := false ;
36535: LD_ADDR_EXP 97
36539: PUSH
36540: LD_INT 0
36542: ST_TO_ADDR
// debug_mc := false ;
36543: LD_ADDR_EXP 98
36547: PUSH
36548: LD_INT 0
36550: ST_TO_ADDR
// mc_bases := [ ] ;
36551: LD_ADDR_EXP 99
36555: PUSH
36556: EMPTY
36557: ST_TO_ADDR
// mc_sides := [ ] ;
36558: LD_ADDR_EXP 125
36562: PUSH
36563: EMPTY
36564: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
36565: LD_ADDR_EXP 100
36569: PUSH
36570: EMPTY
36571: ST_TO_ADDR
// mc_building_repairs := [ ] ;
36572: LD_ADDR_EXP 101
36576: PUSH
36577: EMPTY
36578: ST_TO_ADDR
// mc_need_heal := [ ] ;
36579: LD_ADDR_EXP 102
36583: PUSH
36584: EMPTY
36585: ST_TO_ADDR
// mc_healers := [ ] ;
36586: LD_ADDR_EXP 103
36590: PUSH
36591: EMPTY
36592: ST_TO_ADDR
// mc_build_list := [ ] ;
36593: LD_ADDR_EXP 104
36597: PUSH
36598: EMPTY
36599: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
36600: LD_ADDR_EXP 131
36604: PUSH
36605: EMPTY
36606: ST_TO_ADDR
// mc_builders := [ ] ;
36607: LD_ADDR_EXP 105
36611: PUSH
36612: EMPTY
36613: ST_TO_ADDR
// mc_construct_list := [ ] ;
36614: LD_ADDR_EXP 106
36618: PUSH
36619: EMPTY
36620: ST_TO_ADDR
// mc_turret_list := [ ] ;
36621: LD_ADDR_EXP 107
36625: PUSH
36626: EMPTY
36627: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
36628: LD_ADDR_EXP 108
36632: PUSH
36633: EMPTY
36634: ST_TO_ADDR
// mc_miners := [ ] ;
36635: LD_ADDR_EXP 113
36639: PUSH
36640: EMPTY
36641: ST_TO_ADDR
// mc_mines := [ ] ;
36642: LD_ADDR_EXP 112
36646: PUSH
36647: EMPTY
36648: ST_TO_ADDR
// mc_minefields := [ ] ;
36649: LD_ADDR_EXP 114
36653: PUSH
36654: EMPTY
36655: ST_TO_ADDR
// mc_crates := [ ] ;
36656: LD_ADDR_EXP 115
36660: PUSH
36661: EMPTY
36662: ST_TO_ADDR
// mc_crates_collector := [ ] ;
36663: LD_ADDR_EXP 116
36667: PUSH
36668: EMPTY
36669: ST_TO_ADDR
// mc_crates_area := [ ] ;
36670: LD_ADDR_EXP 117
36674: PUSH
36675: EMPTY
36676: ST_TO_ADDR
// mc_vehicles := [ ] ;
36677: LD_ADDR_EXP 118
36681: PUSH
36682: EMPTY
36683: ST_TO_ADDR
// mc_attack := [ ] ;
36684: LD_ADDR_EXP 119
36688: PUSH
36689: EMPTY
36690: ST_TO_ADDR
// mc_produce := [ ] ;
36691: LD_ADDR_EXP 120
36695: PUSH
36696: EMPTY
36697: ST_TO_ADDR
// mc_defender := [ ] ;
36698: LD_ADDR_EXP 121
36702: PUSH
36703: EMPTY
36704: ST_TO_ADDR
// mc_parking := [ ] ;
36705: LD_ADDR_EXP 123
36709: PUSH
36710: EMPTY
36711: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
36712: LD_ADDR_EXP 109
36716: PUSH
36717: EMPTY
36718: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
36719: LD_ADDR_EXP 111
36723: PUSH
36724: EMPTY
36725: ST_TO_ADDR
// mc_scan := [ ] ;
36726: LD_ADDR_EXP 122
36730: PUSH
36731: EMPTY
36732: ST_TO_ADDR
// mc_scan_area := [ ] ;
36733: LD_ADDR_EXP 124
36737: PUSH
36738: EMPTY
36739: ST_TO_ADDR
// mc_tech := [ ] ;
36740: LD_ADDR_EXP 126
36744: PUSH
36745: EMPTY
36746: ST_TO_ADDR
// mc_class := [ ] ;
36747: LD_ADDR_EXP 140
36751: PUSH
36752: EMPTY
36753: ST_TO_ADDR
// mc_class_case_use := [ ] ;
36754: LD_ADDR_EXP 141
36758: PUSH
36759: EMPTY
36760: ST_TO_ADDR
// mc_is_defending := [ ] ;
36761: LD_ADDR_EXP 142
36765: PUSH
36766: EMPTY
36767: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
36768: LD_ADDR_EXP 133
36772: PUSH
36773: EMPTY
36774: ST_TO_ADDR
// end ;
36775: LD_VAR 0 1
36779: RET
// export function MC_Kill ( base ) ; begin
36780: LD_INT 0
36782: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
36783: LD_ADDR_EXP 99
36787: PUSH
36788: LD_EXP 99
36792: PPUSH
36793: LD_VAR 0 1
36797: PPUSH
36798: EMPTY
36799: PPUSH
36800: CALL_OW 1
36804: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36805: LD_ADDR_EXP 100
36809: PUSH
36810: LD_EXP 100
36814: PPUSH
36815: LD_VAR 0 1
36819: PPUSH
36820: EMPTY
36821: PPUSH
36822: CALL_OW 1
36826: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36827: LD_ADDR_EXP 101
36831: PUSH
36832: LD_EXP 101
36836: PPUSH
36837: LD_VAR 0 1
36841: PPUSH
36842: EMPTY
36843: PPUSH
36844: CALL_OW 1
36848: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36849: LD_ADDR_EXP 102
36853: PUSH
36854: LD_EXP 102
36858: PPUSH
36859: LD_VAR 0 1
36863: PPUSH
36864: EMPTY
36865: PPUSH
36866: CALL_OW 1
36870: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36871: LD_ADDR_EXP 103
36875: PUSH
36876: LD_EXP 103
36880: PPUSH
36881: LD_VAR 0 1
36885: PPUSH
36886: EMPTY
36887: PPUSH
36888: CALL_OW 1
36892: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36893: LD_ADDR_EXP 104
36897: PUSH
36898: LD_EXP 104
36902: PPUSH
36903: LD_VAR 0 1
36907: PPUSH
36908: EMPTY
36909: PPUSH
36910: CALL_OW 1
36914: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36915: LD_ADDR_EXP 105
36919: PUSH
36920: LD_EXP 105
36924: PPUSH
36925: LD_VAR 0 1
36929: PPUSH
36930: EMPTY
36931: PPUSH
36932: CALL_OW 1
36936: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36937: LD_ADDR_EXP 106
36941: PUSH
36942: LD_EXP 106
36946: PPUSH
36947: LD_VAR 0 1
36951: PPUSH
36952: EMPTY
36953: PPUSH
36954: CALL_OW 1
36958: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36959: LD_ADDR_EXP 107
36963: PUSH
36964: LD_EXP 107
36968: PPUSH
36969: LD_VAR 0 1
36973: PPUSH
36974: EMPTY
36975: PPUSH
36976: CALL_OW 1
36980: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36981: LD_ADDR_EXP 108
36985: PUSH
36986: LD_EXP 108
36990: PPUSH
36991: LD_VAR 0 1
36995: PPUSH
36996: EMPTY
36997: PPUSH
36998: CALL_OW 1
37002: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37003: LD_ADDR_EXP 109
37007: PUSH
37008: LD_EXP 109
37012: PPUSH
37013: LD_VAR 0 1
37017: PPUSH
37018: EMPTY
37019: PPUSH
37020: CALL_OW 1
37024: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
37025: LD_ADDR_EXP 110
37029: PUSH
37030: LD_EXP 110
37034: PPUSH
37035: LD_VAR 0 1
37039: PPUSH
37040: LD_INT 0
37042: PPUSH
37043: CALL_OW 1
37047: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
37048: LD_ADDR_EXP 111
37052: PUSH
37053: LD_EXP 111
37057: PPUSH
37058: LD_VAR 0 1
37062: PPUSH
37063: EMPTY
37064: PPUSH
37065: CALL_OW 1
37069: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
37070: LD_ADDR_EXP 112
37074: PUSH
37075: LD_EXP 112
37079: PPUSH
37080: LD_VAR 0 1
37084: PPUSH
37085: EMPTY
37086: PPUSH
37087: CALL_OW 1
37091: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
37092: LD_ADDR_EXP 113
37096: PUSH
37097: LD_EXP 113
37101: PPUSH
37102: LD_VAR 0 1
37106: PPUSH
37107: EMPTY
37108: PPUSH
37109: CALL_OW 1
37113: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
37114: LD_ADDR_EXP 114
37118: PUSH
37119: LD_EXP 114
37123: PPUSH
37124: LD_VAR 0 1
37128: PPUSH
37129: EMPTY
37130: PPUSH
37131: CALL_OW 1
37135: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
37136: LD_ADDR_EXP 115
37140: PUSH
37141: LD_EXP 115
37145: PPUSH
37146: LD_VAR 0 1
37150: PPUSH
37151: EMPTY
37152: PPUSH
37153: CALL_OW 1
37157: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
37158: LD_ADDR_EXP 116
37162: PUSH
37163: LD_EXP 116
37167: PPUSH
37168: LD_VAR 0 1
37172: PPUSH
37173: EMPTY
37174: PPUSH
37175: CALL_OW 1
37179: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
37180: LD_ADDR_EXP 117
37184: PUSH
37185: LD_EXP 117
37189: PPUSH
37190: LD_VAR 0 1
37194: PPUSH
37195: EMPTY
37196: PPUSH
37197: CALL_OW 1
37201: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
37202: LD_ADDR_EXP 118
37206: PUSH
37207: LD_EXP 118
37211: PPUSH
37212: LD_VAR 0 1
37216: PPUSH
37217: EMPTY
37218: PPUSH
37219: CALL_OW 1
37223: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
37224: LD_ADDR_EXP 119
37228: PUSH
37229: LD_EXP 119
37233: PPUSH
37234: LD_VAR 0 1
37238: PPUSH
37239: EMPTY
37240: PPUSH
37241: CALL_OW 1
37245: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
37246: LD_ADDR_EXP 120
37250: PUSH
37251: LD_EXP 120
37255: PPUSH
37256: LD_VAR 0 1
37260: PPUSH
37261: EMPTY
37262: PPUSH
37263: CALL_OW 1
37267: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
37268: LD_ADDR_EXP 121
37272: PUSH
37273: LD_EXP 121
37277: PPUSH
37278: LD_VAR 0 1
37282: PPUSH
37283: EMPTY
37284: PPUSH
37285: CALL_OW 1
37289: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
37290: LD_ADDR_EXP 122
37294: PUSH
37295: LD_EXP 122
37299: PPUSH
37300: LD_VAR 0 1
37304: PPUSH
37305: EMPTY
37306: PPUSH
37307: CALL_OW 1
37311: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37312: LD_ADDR_EXP 123
37316: PUSH
37317: LD_EXP 123
37321: PPUSH
37322: LD_VAR 0 1
37326: PPUSH
37327: EMPTY
37328: PPUSH
37329: CALL_OW 1
37333: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37334: LD_ADDR_EXP 124
37338: PUSH
37339: LD_EXP 124
37343: PPUSH
37344: LD_VAR 0 1
37348: PPUSH
37349: EMPTY
37350: PPUSH
37351: CALL_OW 1
37355: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37356: LD_ADDR_EXP 126
37360: PUSH
37361: LD_EXP 126
37365: PPUSH
37366: LD_VAR 0 1
37370: PPUSH
37371: EMPTY
37372: PPUSH
37373: CALL_OW 1
37377: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37378: LD_ADDR_EXP 128
37382: PUSH
37383: LD_EXP 128
37387: PPUSH
37388: LD_VAR 0 1
37392: PPUSH
37393: EMPTY
37394: PPUSH
37395: CALL_OW 1
37399: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37400: LD_ADDR_EXP 129
37404: PUSH
37405: LD_EXP 129
37409: PPUSH
37410: LD_VAR 0 1
37414: PPUSH
37415: EMPTY
37416: PPUSH
37417: CALL_OW 1
37421: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37422: LD_ADDR_EXP 130
37426: PUSH
37427: LD_EXP 130
37431: PPUSH
37432: LD_VAR 0 1
37436: PPUSH
37437: EMPTY
37438: PPUSH
37439: CALL_OW 1
37443: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37444: LD_ADDR_EXP 131
37448: PUSH
37449: LD_EXP 131
37453: PPUSH
37454: LD_VAR 0 1
37458: PPUSH
37459: EMPTY
37460: PPUSH
37461: CALL_OW 1
37465: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37466: LD_ADDR_EXP 132
37470: PUSH
37471: LD_EXP 132
37475: PPUSH
37476: LD_VAR 0 1
37480: PPUSH
37481: EMPTY
37482: PPUSH
37483: CALL_OW 1
37487: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37488: LD_ADDR_EXP 133
37492: PUSH
37493: LD_EXP 133
37497: PPUSH
37498: LD_VAR 0 1
37502: PPUSH
37503: EMPTY
37504: PPUSH
37505: CALL_OW 1
37509: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37510: LD_ADDR_EXP 134
37514: PUSH
37515: LD_EXP 134
37519: PPUSH
37520: LD_VAR 0 1
37524: PPUSH
37525: EMPTY
37526: PPUSH
37527: CALL_OW 1
37531: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37532: LD_ADDR_EXP 135
37536: PUSH
37537: LD_EXP 135
37541: PPUSH
37542: LD_VAR 0 1
37546: PPUSH
37547: EMPTY
37548: PPUSH
37549: CALL_OW 1
37553: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37554: LD_ADDR_EXP 136
37558: PUSH
37559: LD_EXP 136
37563: PPUSH
37564: LD_VAR 0 1
37568: PPUSH
37569: EMPTY
37570: PPUSH
37571: CALL_OW 1
37575: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37576: LD_ADDR_EXP 137
37580: PUSH
37581: LD_EXP 137
37585: PPUSH
37586: LD_VAR 0 1
37590: PPUSH
37591: EMPTY
37592: PPUSH
37593: CALL_OW 1
37597: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37598: LD_ADDR_EXP 138
37602: PUSH
37603: LD_EXP 138
37607: PPUSH
37608: LD_VAR 0 1
37612: PPUSH
37613: EMPTY
37614: PPUSH
37615: CALL_OW 1
37619: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37620: LD_ADDR_EXP 139
37624: PUSH
37625: LD_EXP 139
37629: PPUSH
37630: LD_VAR 0 1
37634: PPUSH
37635: EMPTY
37636: PPUSH
37637: CALL_OW 1
37641: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37642: LD_ADDR_EXP 140
37646: PUSH
37647: LD_EXP 140
37651: PPUSH
37652: LD_VAR 0 1
37656: PPUSH
37657: EMPTY
37658: PPUSH
37659: CALL_OW 1
37663: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37664: LD_ADDR_EXP 141
37668: PUSH
37669: LD_EXP 141
37673: PPUSH
37674: LD_VAR 0 1
37678: PPUSH
37679: LD_INT 0
37681: PPUSH
37682: CALL_OW 1
37686: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37687: LD_ADDR_EXP 142
37691: PUSH
37692: LD_EXP 142
37696: PPUSH
37697: LD_VAR 0 1
37701: PPUSH
37702: LD_INT 0
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// end ;
37710: LD_VAR 0 2
37714: RET
// export function MC_Add ( side , units ) ; var base ; begin
37715: LD_INT 0
37717: PPUSH
37718: PPUSH
// base := mc_bases + 1 ;
37719: LD_ADDR_VAR 0 4
37723: PUSH
37724: LD_EXP 99
37728: PUSH
37729: LD_INT 1
37731: PLUS
37732: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
37733: LD_ADDR_EXP 125
37737: PUSH
37738: LD_EXP 125
37742: PPUSH
37743: LD_VAR 0 4
37747: PPUSH
37748: LD_VAR 0 1
37752: PPUSH
37753: CALL_OW 1
37757: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
37758: LD_ADDR_EXP 99
37762: PUSH
37763: LD_EXP 99
37767: PPUSH
37768: LD_VAR 0 4
37772: PPUSH
37773: LD_VAR 0 2
37777: PPUSH
37778: CALL_OW 1
37782: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
37783: LD_ADDR_EXP 100
37787: PUSH
37788: LD_EXP 100
37792: PPUSH
37793: LD_VAR 0 4
37797: PPUSH
37798: EMPTY
37799: PPUSH
37800: CALL_OW 1
37804: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
37805: LD_ADDR_EXP 101
37809: PUSH
37810: LD_EXP 101
37814: PPUSH
37815: LD_VAR 0 4
37819: PPUSH
37820: EMPTY
37821: PPUSH
37822: CALL_OW 1
37826: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
37827: LD_ADDR_EXP 102
37831: PUSH
37832: LD_EXP 102
37836: PPUSH
37837: LD_VAR 0 4
37841: PPUSH
37842: EMPTY
37843: PPUSH
37844: CALL_OW 1
37848: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
37849: LD_ADDR_EXP 103
37853: PUSH
37854: LD_EXP 103
37858: PPUSH
37859: LD_VAR 0 4
37863: PPUSH
37864: EMPTY
37865: PPUSH
37866: CALL_OW 1
37870: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
37871: LD_ADDR_EXP 104
37875: PUSH
37876: LD_EXP 104
37880: PPUSH
37881: LD_VAR 0 4
37885: PPUSH
37886: EMPTY
37887: PPUSH
37888: CALL_OW 1
37892: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
37893: LD_ADDR_EXP 105
37897: PUSH
37898: LD_EXP 105
37902: PPUSH
37903: LD_VAR 0 4
37907: PPUSH
37908: EMPTY
37909: PPUSH
37910: CALL_OW 1
37914: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
37915: LD_ADDR_EXP 106
37919: PUSH
37920: LD_EXP 106
37924: PPUSH
37925: LD_VAR 0 4
37929: PPUSH
37930: EMPTY
37931: PPUSH
37932: CALL_OW 1
37936: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
37937: LD_ADDR_EXP 107
37941: PUSH
37942: LD_EXP 107
37946: PPUSH
37947: LD_VAR 0 4
37951: PPUSH
37952: EMPTY
37953: PPUSH
37954: CALL_OW 1
37958: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
37959: LD_ADDR_EXP 108
37963: PUSH
37964: LD_EXP 108
37968: PPUSH
37969: LD_VAR 0 4
37973: PPUSH
37974: EMPTY
37975: PPUSH
37976: CALL_OW 1
37980: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
37981: LD_ADDR_EXP 109
37985: PUSH
37986: LD_EXP 109
37990: PPUSH
37991: LD_VAR 0 4
37995: PPUSH
37996: EMPTY
37997: PPUSH
37998: CALL_OW 1
38002: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38003: LD_ADDR_EXP 110
38007: PUSH
38008: LD_EXP 110
38012: PPUSH
38013: LD_VAR 0 4
38017: PPUSH
38018: LD_INT 0
38020: PPUSH
38021: CALL_OW 1
38025: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38026: LD_ADDR_EXP 111
38030: PUSH
38031: LD_EXP 111
38035: PPUSH
38036: LD_VAR 0 4
38040: PPUSH
38041: EMPTY
38042: PPUSH
38043: CALL_OW 1
38047: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38048: LD_ADDR_EXP 112
38052: PUSH
38053: LD_EXP 112
38057: PPUSH
38058: LD_VAR 0 4
38062: PPUSH
38063: EMPTY
38064: PPUSH
38065: CALL_OW 1
38069: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38070: LD_ADDR_EXP 113
38074: PUSH
38075: LD_EXP 113
38079: PPUSH
38080: LD_VAR 0 4
38084: PPUSH
38085: EMPTY
38086: PPUSH
38087: CALL_OW 1
38091: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38092: LD_ADDR_EXP 114
38096: PUSH
38097: LD_EXP 114
38101: PPUSH
38102: LD_VAR 0 4
38106: PPUSH
38107: EMPTY
38108: PPUSH
38109: CALL_OW 1
38113: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38114: LD_ADDR_EXP 115
38118: PUSH
38119: LD_EXP 115
38123: PPUSH
38124: LD_VAR 0 4
38128: PPUSH
38129: EMPTY
38130: PPUSH
38131: CALL_OW 1
38135: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38136: LD_ADDR_EXP 116
38140: PUSH
38141: LD_EXP 116
38145: PPUSH
38146: LD_VAR 0 4
38150: PPUSH
38151: EMPTY
38152: PPUSH
38153: CALL_OW 1
38157: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38158: LD_ADDR_EXP 117
38162: PUSH
38163: LD_EXP 117
38167: PPUSH
38168: LD_VAR 0 4
38172: PPUSH
38173: EMPTY
38174: PPUSH
38175: CALL_OW 1
38179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38180: LD_ADDR_EXP 118
38184: PUSH
38185: LD_EXP 118
38189: PPUSH
38190: LD_VAR 0 4
38194: PPUSH
38195: EMPTY
38196: PPUSH
38197: CALL_OW 1
38201: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38202: LD_ADDR_EXP 119
38206: PUSH
38207: LD_EXP 119
38211: PPUSH
38212: LD_VAR 0 4
38216: PPUSH
38217: EMPTY
38218: PPUSH
38219: CALL_OW 1
38223: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38224: LD_ADDR_EXP 120
38228: PUSH
38229: LD_EXP 120
38233: PPUSH
38234: LD_VAR 0 4
38238: PPUSH
38239: EMPTY
38240: PPUSH
38241: CALL_OW 1
38245: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38246: LD_ADDR_EXP 121
38250: PUSH
38251: LD_EXP 121
38255: PPUSH
38256: LD_VAR 0 4
38260: PPUSH
38261: EMPTY
38262: PPUSH
38263: CALL_OW 1
38267: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38268: LD_ADDR_EXP 122
38272: PUSH
38273: LD_EXP 122
38277: PPUSH
38278: LD_VAR 0 4
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL_OW 1
38289: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38290: LD_ADDR_EXP 123
38294: PUSH
38295: LD_EXP 123
38299: PPUSH
38300: LD_VAR 0 4
38304: PPUSH
38305: EMPTY
38306: PPUSH
38307: CALL_OW 1
38311: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
38312: LD_ADDR_EXP 124
38316: PUSH
38317: LD_EXP 124
38321: PPUSH
38322: LD_VAR 0 4
38326: PPUSH
38327: EMPTY
38328: PPUSH
38329: CALL_OW 1
38333: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
38334: LD_ADDR_EXP 126
38338: PUSH
38339: LD_EXP 126
38343: PPUSH
38344: LD_VAR 0 4
38348: PPUSH
38349: EMPTY
38350: PPUSH
38351: CALL_OW 1
38355: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
38356: LD_ADDR_EXP 128
38360: PUSH
38361: LD_EXP 128
38365: PPUSH
38366: LD_VAR 0 4
38370: PPUSH
38371: EMPTY
38372: PPUSH
38373: CALL_OW 1
38377: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
38378: LD_ADDR_EXP 129
38382: PUSH
38383: LD_EXP 129
38387: PPUSH
38388: LD_VAR 0 4
38392: PPUSH
38393: EMPTY
38394: PPUSH
38395: CALL_OW 1
38399: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
38400: LD_ADDR_EXP 130
38404: PUSH
38405: LD_EXP 130
38409: PPUSH
38410: LD_VAR 0 4
38414: PPUSH
38415: EMPTY
38416: PPUSH
38417: CALL_OW 1
38421: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
38422: LD_ADDR_EXP 131
38426: PUSH
38427: LD_EXP 131
38431: PPUSH
38432: LD_VAR 0 4
38436: PPUSH
38437: EMPTY
38438: PPUSH
38439: CALL_OW 1
38443: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
38444: LD_ADDR_EXP 132
38448: PUSH
38449: LD_EXP 132
38453: PPUSH
38454: LD_VAR 0 4
38458: PPUSH
38459: EMPTY
38460: PPUSH
38461: CALL_OW 1
38465: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
38466: LD_ADDR_EXP 133
38470: PUSH
38471: LD_EXP 133
38475: PPUSH
38476: LD_VAR 0 4
38480: PPUSH
38481: EMPTY
38482: PPUSH
38483: CALL_OW 1
38487: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
38488: LD_ADDR_EXP 134
38492: PUSH
38493: LD_EXP 134
38497: PPUSH
38498: LD_VAR 0 4
38502: PPUSH
38503: EMPTY
38504: PPUSH
38505: CALL_OW 1
38509: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
38510: LD_ADDR_EXP 135
38514: PUSH
38515: LD_EXP 135
38519: PPUSH
38520: LD_VAR 0 4
38524: PPUSH
38525: EMPTY
38526: PPUSH
38527: CALL_OW 1
38531: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
38532: LD_ADDR_EXP 136
38536: PUSH
38537: LD_EXP 136
38541: PPUSH
38542: LD_VAR 0 4
38546: PPUSH
38547: EMPTY
38548: PPUSH
38549: CALL_OW 1
38553: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
38554: LD_ADDR_EXP 137
38558: PUSH
38559: LD_EXP 137
38563: PPUSH
38564: LD_VAR 0 4
38568: PPUSH
38569: EMPTY
38570: PPUSH
38571: CALL_OW 1
38575: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
38576: LD_ADDR_EXP 138
38580: PUSH
38581: LD_EXP 138
38585: PPUSH
38586: LD_VAR 0 4
38590: PPUSH
38591: EMPTY
38592: PPUSH
38593: CALL_OW 1
38597: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
38598: LD_ADDR_EXP 139
38602: PUSH
38603: LD_EXP 139
38607: PPUSH
38608: LD_VAR 0 4
38612: PPUSH
38613: EMPTY
38614: PPUSH
38615: CALL_OW 1
38619: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
38620: LD_ADDR_EXP 140
38624: PUSH
38625: LD_EXP 140
38629: PPUSH
38630: LD_VAR 0 4
38634: PPUSH
38635: EMPTY
38636: PPUSH
38637: CALL_OW 1
38641: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
38642: LD_ADDR_EXP 141
38646: PUSH
38647: LD_EXP 141
38651: PPUSH
38652: LD_VAR 0 4
38656: PPUSH
38657: LD_INT 0
38659: PPUSH
38660: CALL_OW 1
38664: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
38665: LD_ADDR_EXP 142
38669: PUSH
38670: LD_EXP 142
38674: PPUSH
38675: LD_VAR 0 4
38679: PPUSH
38680: LD_INT 0
38682: PPUSH
38683: CALL_OW 1
38687: ST_TO_ADDR
// result := base ;
38688: LD_ADDR_VAR 0 3
38692: PUSH
38693: LD_VAR 0 4
38697: ST_TO_ADDR
// end ;
38698: LD_VAR 0 3
38702: RET
// export function MC_Start ( ) ; var i ; begin
38703: LD_INT 0
38705: PPUSH
38706: PPUSH
// for i = 1 to mc_bases do
38707: LD_ADDR_VAR 0 2
38711: PUSH
38712: DOUBLE
38713: LD_INT 1
38715: DEC
38716: ST_TO_ADDR
38717: LD_EXP 99
38721: PUSH
38722: FOR_TO
38723: IFFALSE 39823
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
38725: LD_ADDR_EXP 99
38729: PUSH
38730: LD_EXP 99
38734: PPUSH
38735: LD_VAR 0 2
38739: PPUSH
38740: LD_EXP 99
38744: PUSH
38745: LD_VAR 0 2
38749: ARRAY
38750: PUSH
38751: LD_INT 0
38753: DIFF
38754: PPUSH
38755: CALL_OW 1
38759: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
38760: LD_ADDR_EXP 100
38764: PUSH
38765: LD_EXP 100
38769: PPUSH
38770: LD_VAR 0 2
38774: PPUSH
38775: EMPTY
38776: PPUSH
38777: CALL_OW 1
38781: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
38782: LD_ADDR_EXP 101
38786: PUSH
38787: LD_EXP 101
38791: PPUSH
38792: LD_VAR 0 2
38796: PPUSH
38797: EMPTY
38798: PPUSH
38799: CALL_OW 1
38803: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
38804: LD_ADDR_EXP 102
38808: PUSH
38809: LD_EXP 102
38813: PPUSH
38814: LD_VAR 0 2
38818: PPUSH
38819: EMPTY
38820: PPUSH
38821: CALL_OW 1
38825: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
38826: LD_ADDR_EXP 103
38830: PUSH
38831: LD_EXP 103
38835: PPUSH
38836: LD_VAR 0 2
38840: PPUSH
38841: EMPTY
38842: PUSH
38843: EMPTY
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PPUSH
38849: CALL_OW 1
38853: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
38854: LD_ADDR_EXP 104
38858: PUSH
38859: LD_EXP 104
38863: PPUSH
38864: LD_VAR 0 2
38868: PPUSH
38869: EMPTY
38870: PPUSH
38871: CALL_OW 1
38875: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
38876: LD_ADDR_EXP 131
38880: PUSH
38881: LD_EXP 131
38885: PPUSH
38886: LD_VAR 0 2
38890: PPUSH
38891: EMPTY
38892: PPUSH
38893: CALL_OW 1
38897: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
38898: LD_ADDR_EXP 105
38902: PUSH
38903: LD_EXP 105
38907: PPUSH
38908: LD_VAR 0 2
38912: PPUSH
38913: EMPTY
38914: PPUSH
38915: CALL_OW 1
38919: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
38920: LD_ADDR_EXP 106
38924: PUSH
38925: LD_EXP 106
38929: PPUSH
38930: LD_VAR 0 2
38934: PPUSH
38935: EMPTY
38936: PPUSH
38937: CALL_OW 1
38941: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
38942: LD_ADDR_EXP 107
38946: PUSH
38947: LD_EXP 107
38951: PPUSH
38952: LD_VAR 0 2
38956: PPUSH
38957: LD_EXP 99
38961: PUSH
38962: LD_VAR 0 2
38966: ARRAY
38967: PPUSH
38968: LD_INT 2
38970: PUSH
38971: LD_INT 30
38973: PUSH
38974: LD_INT 32
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 30
38983: PUSH
38984: LD_INT 33
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: LIST
38995: PPUSH
38996: CALL_OW 72
39000: PPUSH
39001: CALL_OW 1
39005: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
39006: LD_ADDR_EXP 108
39010: PUSH
39011: LD_EXP 108
39015: PPUSH
39016: LD_VAR 0 2
39020: PPUSH
39021: LD_EXP 99
39025: PUSH
39026: LD_VAR 0 2
39030: ARRAY
39031: PPUSH
39032: LD_INT 2
39034: PUSH
39035: LD_INT 30
39037: PUSH
39038: LD_INT 32
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 30
39047: PUSH
39048: LD_INT 31
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 58
39062: PUSH
39063: EMPTY
39064: LIST
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PPUSH
39070: CALL_OW 72
39074: PPUSH
39075: CALL_OW 1
39079: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
39080: LD_ADDR_EXP 109
39084: PUSH
39085: LD_EXP 109
39089: PPUSH
39090: LD_VAR 0 2
39094: PPUSH
39095: EMPTY
39096: PPUSH
39097: CALL_OW 1
39101: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
39102: LD_ADDR_EXP 113
39106: PUSH
39107: LD_EXP 113
39111: PPUSH
39112: LD_VAR 0 2
39116: PPUSH
39117: EMPTY
39118: PPUSH
39119: CALL_OW 1
39123: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
39124: LD_ADDR_EXP 112
39128: PUSH
39129: LD_EXP 112
39133: PPUSH
39134: LD_VAR 0 2
39138: PPUSH
39139: EMPTY
39140: PPUSH
39141: CALL_OW 1
39145: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
39146: LD_ADDR_EXP 114
39150: PUSH
39151: LD_EXP 114
39155: PPUSH
39156: LD_VAR 0 2
39160: PPUSH
39161: EMPTY
39162: PPUSH
39163: CALL_OW 1
39167: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
39168: LD_ADDR_EXP 115
39172: PUSH
39173: LD_EXP 115
39177: PPUSH
39178: LD_VAR 0 2
39182: PPUSH
39183: EMPTY
39184: PPUSH
39185: CALL_OW 1
39189: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
39190: LD_ADDR_EXP 116
39194: PUSH
39195: LD_EXP 116
39199: PPUSH
39200: LD_VAR 0 2
39204: PPUSH
39205: EMPTY
39206: PPUSH
39207: CALL_OW 1
39211: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
39212: LD_ADDR_EXP 117
39216: PUSH
39217: LD_EXP 117
39221: PPUSH
39222: LD_VAR 0 2
39226: PPUSH
39227: EMPTY
39228: PPUSH
39229: CALL_OW 1
39233: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
39234: LD_ADDR_EXP 118
39238: PUSH
39239: LD_EXP 118
39243: PPUSH
39244: LD_VAR 0 2
39248: PPUSH
39249: EMPTY
39250: PPUSH
39251: CALL_OW 1
39255: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
39256: LD_ADDR_EXP 119
39260: PUSH
39261: LD_EXP 119
39265: PPUSH
39266: LD_VAR 0 2
39270: PPUSH
39271: EMPTY
39272: PPUSH
39273: CALL_OW 1
39277: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
39278: LD_ADDR_EXP 120
39282: PUSH
39283: LD_EXP 120
39287: PPUSH
39288: LD_VAR 0 2
39292: PPUSH
39293: EMPTY
39294: PPUSH
39295: CALL_OW 1
39299: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39300: LD_ADDR_EXP 121
39304: PUSH
39305: LD_EXP 121
39309: PPUSH
39310: LD_VAR 0 2
39314: PPUSH
39315: EMPTY
39316: PPUSH
39317: CALL_OW 1
39321: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
39322: LD_ADDR_EXP 110
39326: PUSH
39327: LD_EXP 110
39331: PPUSH
39332: LD_VAR 0 2
39336: PPUSH
39337: LD_INT 0
39339: PPUSH
39340: CALL_OW 1
39344: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
39345: LD_ADDR_EXP 123
39349: PUSH
39350: LD_EXP 123
39354: PPUSH
39355: LD_VAR 0 2
39359: PPUSH
39360: LD_INT 0
39362: PPUSH
39363: CALL_OW 1
39367: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39368: LD_ADDR_EXP 111
39372: PUSH
39373: LD_EXP 111
39377: PPUSH
39378: LD_VAR 0 2
39382: PPUSH
39383: EMPTY
39384: PPUSH
39385: CALL_OW 1
39389: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
39390: LD_ADDR_EXP 122
39394: PUSH
39395: LD_EXP 122
39399: PPUSH
39400: LD_VAR 0 2
39404: PPUSH
39405: LD_INT 0
39407: PPUSH
39408: CALL_OW 1
39412: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
39413: LD_ADDR_EXP 124
39417: PUSH
39418: LD_EXP 124
39422: PPUSH
39423: LD_VAR 0 2
39427: PPUSH
39428: EMPTY
39429: PPUSH
39430: CALL_OW 1
39434: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
39435: LD_ADDR_EXP 127
39439: PUSH
39440: LD_EXP 127
39444: PPUSH
39445: LD_VAR 0 2
39449: PPUSH
39450: LD_INT 0
39452: PPUSH
39453: CALL_OW 1
39457: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
39458: LD_ADDR_EXP 128
39462: PUSH
39463: LD_EXP 128
39467: PPUSH
39468: LD_VAR 0 2
39472: PPUSH
39473: EMPTY
39474: PPUSH
39475: CALL_OW 1
39479: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
39480: LD_ADDR_EXP 129
39484: PUSH
39485: LD_EXP 129
39489: PPUSH
39490: LD_VAR 0 2
39494: PPUSH
39495: EMPTY
39496: PPUSH
39497: CALL_OW 1
39501: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39502: LD_ADDR_EXP 130
39506: PUSH
39507: LD_EXP 130
39511: PPUSH
39512: LD_VAR 0 2
39516: PPUSH
39517: EMPTY
39518: PPUSH
39519: CALL_OW 1
39523: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
39524: LD_ADDR_EXP 132
39528: PUSH
39529: LD_EXP 132
39533: PPUSH
39534: LD_VAR 0 2
39538: PPUSH
39539: LD_EXP 99
39543: PUSH
39544: LD_VAR 0 2
39548: ARRAY
39549: PPUSH
39550: LD_INT 2
39552: PUSH
39553: LD_INT 30
39555: PUSH
39556: LD_INT 6
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 30
39565: PUSH
39566: LD_INT 7
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 30
39575: PUSH
39576: LD_INT 8
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: PPUSH
39589: CALL_OW 72
39593: PPUSH
39594: CALL_OW 1
39598: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
39599: LD_ADDR_EXP 133
39603: PUSH
39604: LD_EXP 133
39608: PPUSH
39609: LD_VAR 0 2
39613: PPUSH
39614: EMPTY
39615: PPUSH
39616: CALL_OW 1
39620: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
39621: LD_ADDR_EXP 134
39625: PUSH
39626: LD_EXP 134
39630: PPUSH
39631: LD_VAR 0 2
39635: PPUSH
39636: EMPTY
39637: PPUSH
39638: CALL_OW 1
39642: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
39643: LD_ADDR_EXP 135
39647: PUSH
39648: LD_EXP 135
39652: PPUSH
39653: LD_VAR 0 2
39657: PPUSH
39658: EMPTY
39659: PPUSH
39660: CALL_OW 1
39664: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
39665: LD_ADDR_EXP 136
39669: PUSH
39670: LD_EXP 136
39674: PPUSH
39675: LD_VAR 0 2
39679: PPUSH
39680: EMPTY
39681: PPUSH
39682: CALL_OW 1
39686: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39687: LD_ADDR_EXP 137
39691: PUSH
39692: LD_EXP 137
39696: PPUSH
39697: LD_VAR 0 2
39701: PPUSH
39702: EMPTY
39703: PPUSH
39704: CALL_OW 1
39708: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
39709: LD_ADDR_EXP 138
39713: PUSH
39714: LD_EXP 138
39718: PPUSH
39719: LD_VAR 0 2
39723: PPUSH
39724: EMPTY
39725: PPUSH
39726: CALL_OW 1
39730: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
39731: LD_ADDR_EXP 139
39735: PUSH
39736: LD_EXP 139
39740: PPUSH
39741: LD_VAR 0 2
39745: PPUSH
39746: EMPTY
39747: PPUSH
39748: CALL_OW 1
39752: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
39753: LD_ADDR_EXP 140
39757: PUSH
39758: LD_EXP 140
39762: PPUSH
39763: LD_VAR 0 2
39767: PPUSH
39768: EMPTY
39769: PPUSH
39770: CALL_OW 1
39774: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
39775: LD_ADDR_EXP 141
39779: PUSH
39780: LD_EXP 141
39784: PPUSH
39785: LD_VAR 0 2
39789: PPUSH
39790: LD_INT 0
39792: PPUSH
39793: CALL_OW 1
39797: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
39798: LD_ADDR_EXP 142
39802: PUSH
39803: LD_EXP 142
39807: PPUSH
39808: LD_VAR 0 2
39812: PPUSH
39813: LD_INT 0
39815: PPUSH
39816: CALL_OW 1
39820: ST_TO_ADDR
// end ;
39821: GO 38722
39823: POP
39824: POP
// MC_InitSides ( ) ;
39825: CALL 40111 0 0
// MC_InitResearch ( ) ;
39829: CALL 39850 0 0
// CustomInitMacro ( ) ;
39833: CALL 475 0 0
// skirmish := true ;
39837: LD_ADDR_EXP 97
39841: PUSH
39842: LD_INT 1
39844: ST_TO_ADDR
// end ;
39845: LD_VAR 0 1
39849: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
39850: LD_INT 0
39852: PPUSH
39853: PPUSH
39854: PPUSH
39855: PPUSH
39856: PPUSH
39857: PPUSH
// if not mc_bases then
39858: LD_EXP 99
39862: NOT
39863: IFFALSE 39867
// exit ;
39865: GO 40106
// for i = 1 to 8 do
39867: LD_ADDR_VAR 0 2
39871: PUSH
39872: DOUBLE
39873: LD_INT 1
39875: DEC
39876: ST_TO_ADDR
39877: LD_INT 8
39879: PUSH
39880: FOR_TO
39881: IFFALSE 39907
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
39883: LD_ADDR_EXP 126
39887: PUSH
39888: LD_EXP 126
39892: PPUSH
39893: LD_VAR 0 2
39897: PPUSH
39898: EMPTY
39899: PPUSH
39900: CALL_OW 1
39904: ST_TO_ADDR
39905: GO 39880
39907: POP
39908: POP
// tmp := [ ] ;
39909: LD_ADDR_VAR 0 5
39913: PUSH
39914: EMPTY
39915: ST_TO_ADDR
// for i = 1 to mc_sides do
39916: LD_ADDR_VAR 0 2
39920: PUSH
39921: DOUBLE
39922: LD_INT 1
39924: DEC
39925: ST_TO_ADDR
39926: LD_EXP 125
39930: PUSH
39931: FOR_TO
39932: IFFALSE 39990
// if not mc_sides [ i ] in tmp then
39934: LD_EXP 125
39938: PUSH
39939: LD_VAR 0 2
39943: ARRAY
39944: PUSH
39945: LD_VAR 0 5
39949: IN
39950: NOT
39951: IFFALSE 39988
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
39953: LD_ADDR_VAR 0 5
39957: PUSH
39958: LD_VAR 0 5
39962: PPUSH
39963: LD_VAR 0 5
39967: PUSH
39968: LD_INT 1
39970: PLUS
39971: PPUSH
39972: LD_EXP 125
39976: PUSH
39977: LD_VAR 0 2
39981: ARRAY
39982: PPUSH
39983: CALL_OW 2
39987: ST_TO_ADDR
39988: GO 39931
39990: POP
39991: POP
// if not tmp then
39992: LD_VAR 0 5
39996: NOT
39997: IFFALSE 40001
// exit ;
39999: GO 40106
// for j in tmp do
40001: LD_ADDR_VAR 0 3
40005: PUSH
40006: LD_VAR 0 5
40010: PUSH
40011: FOR_IN
40012: IFFALSE 40104
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
40014: LD_ADDR_VAR 0 6
40018: PUSH
40019: LD_INT 22
40021: PUSH
40022: LD_VAR 0 3
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PPUSH
40031: CALL_OW 69
40035: ST_TO_ADDR
// if not un then
40036: LD_VAR 0 6
40040: NOT
40041: IFFALSE 40045
// continue ;
40043: GO 40011
// nation := GetNation ( un [ 1 ] ) ;
40045: LD_ADDR_VAR 0 4
40049: PUSH
40050: LD_VAR 0 6
40054: PUSH
40055: LD_INT 1
40057: ARRAY
40058: PPUSH
40059: CALL_OW 248
40063: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
40064: LD_ADDR_EXP 126
40068: PUSH
40069: LD_EXP 126
40073: PPUSH
40074: LD_VAR 0 3
40078: PPUSH
40079: LD_VAR 0 3
40083: PPUSH
40084: LD_VAR 0 4
40088: PPUSH
40089: LD_INT 1
40091: PPUSH
40092: CALL 67258 0 3
40096: PPUSH
40097: CALL_OW 1
40101: ST_TO_ADDR
// end ;
40102: GO 40011
40104: POP
40105: POP
// end ;
40106: LD_VAR 0 1
40110: RET
// export function MC_InitSides ( ) ; var i ; begin
40111: LD_INT 0
40113: PPUSH
40114: PPUSH
// if not mc_bases then
40115: LD_EXP 99
40119: NOT
40120: IFFALSE 40124
// exit ;
40122: GO 40198
// for i = 1 to mc_bases do
40124: LD_ADDR_VAR 0 2
40128: PUSH
40129: DOUBLE
40130: LD_INT 1
40132: DEC
40133: ST_TO_ADDR
40134: LD_EXP 99
40138: PUSH
40139: FOR_TO
40140: IFFALSE 40196
// if mc_bases [ i ] then
40142: LD_EXP 99
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: IFFALSE 40194
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
40154: LD_ADDR_EXP 125
40158: PUSH
40159: LD_EXP 125
40163: PPUSH
40164: LD_VAR 0 2
40168: PPUSH
40169: LD_EXP 99
40173: PUSH
40174: LD_VAR 0 2
40178: ARRAY
40179: PUSH
40180: LD_INT 1
40182: ARRAY
40183: PPUSH
40184: CALL_OW 255
40188: PPUSH
40189: CALL_OW 1
40193: ST_TO_ADDR
40194: GO 40139
40196: POP
40197: POP
// end ;
40198: LD_VAR 0 1
40202: RET
// every 0 0$03 trigger skirmish do
40203: LD_EXP 97
40207: IFFALSE 40361
40209: GO 40211
40211: DISABLE
// begin enable ;
40212: ENABLE
// MC_CheckBuildings ( ) ;
40213: CALL 44859 0 0
// MC_CheckPeopleLife ( ) ;
40217: CALL 45020 0 0
// RaiseSailEvent ( 100 ) ;
40221: LD_INT 100
40223: PPUSH
40224: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
40228: LD_INT 103
40230: PPUSH
40231: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
40235: LD_INT 104
40237: PPUSH
40238: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
40242: LD_INT 105
40244: PPUSH
40245: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
40249: LD_INT 106
40251: PPUSH
40252: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
40256: LD_INT 107
40258: PPUSH
40259: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
40263: LD_INT 108
40265: PPUSH
40266: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
40270: LD_INT 109
40272: PPUSH
40273: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
40277: LD_INT 110
40279: PPUSH
40280: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
40284: LD_INT 111
40286: PPUSH
40287: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
40291: LD_INT 112
40293: PPUSH
40294: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
40298: LD_INT 113
40300: PPUSH
40301: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
40305: LD_INT 120
40307: PPUSH
40308: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
40312: LD_INT 121
40314: PPUSH
40315: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
40319: LD_INT 122
40321: PPUSH
40322: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
40326: LD_INT 123
40328: PPUSH
40329: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
40333: LD_INT 124
40335: PPUSH
40336: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
40340: LD_INT 125
40342: PPUSH
40343: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
40347: LD_INT 126
40349: PPUSH
40350: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
40354: LD_INT 200
40356: PPUSH
40357: CALL_OW 427
// end ;
40361: END
// on SailEvent ( event ) do begin if event < 100 then
40362: LD_VAR 0 1
40366: PUSH
40367: LD_INT 100
40369: LESS
40370: IFFALSE 40381
// CustomEvent ( event ) ;
40372: LD_VAR 0 1
40376: PPUSH
40377: CALL 34925 0 1
// if event = 100 then
40381: LD_VAR 0 1
40385: PUSH
40386: LD_INT 100
40388: EQUAL
40389: IFFALSE 40395
// MC_ClassManager ( ) ;
40391: CALL 40787 0 0
// if event = 101 then
40395: LD_VAR 0 1
40399: PUSH
40400: LD_INT 101
40402: EQUAL
40403: IFFALSE 40409
// MC_RepairBuildings ( ) ;
40405: CALL 45605 0 0
// if event = 102 then
40409: LD_VAR 0 1
40413: PUSH
40414: LD_INT 102
40416: EQUAL
40417: IFFALSE 40423
// MC_Heal ( ) ;
40419: CALL 46540 0 0
// if event = 103 then
40423: LD_VAR 0 1
40427: PUSH
40428: LD_INT 103
40430: EQUAL
40431: IFFALSE 40437
// MC_Build ( ) ;
40433: CALL 46962 0 0
// if event = 104 then
40437: LD_VAR 0 1
40441: PUSH
40442: LD_INT 104
40444: EQUAL
40445: IFFALSE 40451
// MC_TurretWeapon ( ) ;
40447: CALL 48596 0 0
// if event = 105 then
40451: LD_VAR 0 1
40455: PUSH
40456: LD_INT 105
40458: EQUAL
40459: IFFALSE 40465
// MC_BuildUpgrade ( ) ;
40461: CALL 48147 0 0
// if event = 106 then
40465: LD_VAR 0 1
40469: PUSH
40470: LD_INT 106
40472: EQUAL
40473: IFFALSE 40479
// MC_PlantMines ( ) ;
40475: CALL 49026 0 0
// if event = 107 then
40479: LD_VAR 0 1
40483: PUSH
40484: LD_INT 107
40486: EQUAL
40487: IFFALSE 40493
// MC_CollectCrates ( ) ;
40489: CALL 49817 0 0
// if event = 108 then
40493: LD_VAR 0 1
40497: PUSH
40498: LD_INT 108
40500: EQUAL
40501: IFFALSE 40507
// MC_LinkRemoteControl ( ) ;
40503: CALL 51667 0 0
// if event = 109 then
40507: LD_VAR 0 1
40511: PUSH
40512: LD_INT 109
40514: EQUAL
40515: IFFALSE 40521
// MC_ProduceVehicle ( ) ;
40517: CALL 51848 0 0
// if event = 110 then
40521: LD_VAR 0 1
40525: PUSH
40526: LD_INT 110
40528: EQUAL
40529: IFFALSE 40535
// MC_SendAttack ( ) ;
40531: CALL 52314 0 0
// if event = 111 then
40535: LD_VAR 0 1
40539: PUSH
40540: LD_INT 111
40542: EQUAL
40543: IFFALSE 40549
// MC_Defend ( ) ;
40545: CALL 52422 0 0
// if event = 112 then
40549: LD_VAR 0 1
40553: PUSH
40554: LD_INT 112
40556: EQUAL
40557: IFFALSE 40563
// MC_Research ( ) ;
40559: CALL 53302 0 0
// if event = 113 then
40563: LD_VAR 0 1
40567: PUSH
40568: LD_INT 113
40570: EQUAL
40571: IFFALSE 40577
// MC_MinesTrigger ( ) ;
40573: CALL 54416 0 0
// if event = 120 then
40577: LD_VAR 0 1
40581: PUSH
40582: LD_INT 120
40584: EQUAL
40585: IFFALSE 40591
// MC_RepairVehicle ( ) ;
40587: CALL 54515 0 0
// if event = 121 then
40591: LD_VAR 0 1
40595: PUSH
40596: LD_INT 121
40598: EQUAL
40599: IFFALSE 40605
// MC_TameApe ( ) ;
40601: CALL 55284 0 0
// if event = 122 then
40605: LD_VAR 0 1
40609: PUSH
40610: LD_INT 122
40612: EQUAL
40613: IFFALSE 40619
// MC_ChangeApeClass ( ) ;
40615: CALL 56113 0 0
// if event = 123 then
40619: LD_VAR 0 1
40623: PUSH
40624: LD_INT 123
40626: EQUAL
40627: IFFALSE 40633
// MC_Bazooka ( ) ;
40629: CALL 56763 0 0
// if event = 124 then
40633: LD_VAR 0 1
40637: PUSH
40638: LD_INT 124
40640: EQUAL
40641: IFFALSE 40647
// MC_TeleportExit ( ) ;
40643: CALL 56961 0 0
// if event = 125 then
40647: LD_VAR 0 1
40651: PUSH
40652: LD_INT 125
40654: EQUAL
40655: IFFALSE 40661
// MC_Deposits ( ) ;
40657: CALL 57608 0 0
// if event = 126 then
40661: LD_VAR 0 1
40665: PUSH
40666: LD_INT 126
40668: EQUAL
40669: IFFALSE 40675
// MC_RemoteDriver ( ) ;
40671: CALL 58233 0 0
// if event = 200 then
40675: LD_VAR 0 1
40679: PUSH
40680: LD_INT 200
40682: EQUAL
40683: IFFALSE 40689
// MC_Idle ( ) ;
40685: CALL 60182 0 0
// end ;
40689: PPOPN 1
40691: END
// export function MC_Reset ( base , tag ) ; var i ; begin
40692: LD_INT 0
40694: PPUSH
40695: PPUSH
// if not mc_bases [ base ] or not tag then
40696: LD_EXP 99
40700: PUSH
40701: LD_VAR 0 1
40705: ARRAY
40706: NOT
40707: PUSH
40708: LD_VAR 0 2
40712: NOT
40713: OR
40714: IFFALSE 40718
// exit ;
40716: GO 40782
// for i in mc_bases [ base ] union mc_ape [ base ] do
40718: LD_ADDR_VAR 0 4
40722: PUSH
40723: LD_EXP 99
40727: PUSH
40728: LD_VAR 0 1
40732: ARRAY
40733: PUSH
40734: LD_EXP 128
40738: PUSH
40739: LD_VAR 0 1
40743: ARRAY
40744: UNION
40745: PUSH
40746: FOR_IN
40747: IFFALSE 40780
// if GetTag ( i ) = tag then
40749: LD_VAR 0 4
40753: PPUSH
40754: CALL_OW 110
40758: PUSH
40759: LD_VAR 0 2
40763: EQUAL
40764: IFFALSE 40778
// SetTag ( i , 0 ) ;
40766: LD_VAR 0 4
40770: PPUSH
40771: LD_INT 0
40773: PPUSH
40774: CALL_OW 109
40778: GO 40746
40780: POP
40781: POP
// end ;
40782: LD_VAR 0 3
40786: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
40787: LD_INT 0
40789: PPUSH
40790: PPUSH
40791: PPUSH
40792: PPUSH
40793: PPUSH
40794: PPUSH
40795: PPUSH
40796: PPUSH
// if not mc_bases then
40797: LD_EXP 99
40801: NOT
40802: IFFALSE 40806
// exit ;
40804: GO 41264
// for i = 1 to mc_bases do
40806: LD_ADDR_VAR 0 2
40810: PUSH
40811: DOUBLE
40812: LD_INT 1
40814: DEC
40815: ST_TO_ADDR
40816: LD_EXP 99
40820: PUSH
40821: FOR_TO
40822: IFFALSE 41262
// begin tmp := MC_ClassCheckReq ( i ) ;
40824: LD_ADDR_VAR 0 4
40828: PUSH
40829: LD_VAR 0 2
40833: PPUSH
40834: CALL 41269 0 1
40838: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
40839: LD_ADDR_EXP 140
40843: PUSH
40844: LD_EXP 140
40848: PPUSH
40849: LD_VAR 0 2
40853: PPUSH
40854: LD_VAR 0 4
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// if not tmp then
40864: LD_VAR 0 4
40868: NOT
40869: IFFALSE 40873
// continue ;
40871: GO 40821
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
40873: LD_ADDR_VAR 0 6
40877: PUSH
40878: LD_EXP 99
40882: PUSH
40883: LD_VAR 0 2
40887: ARRAY
40888: PPUSH
40889: LD_INT 2
40891: PUSH
40892: LD_INT 30
40894: PUSH
40895: LD_INT 4
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 30
40904: PUSH
40905: LD_INT 5
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: LIST
40916: PPUSH
40917: CALL_OW 72
40921: PUSH
40922: LD_EXP 99
40926: PUSH
40927: LD_VAR 0 2
40931: ARRAY
40932: PPUSH
40933: LD_INT 2
40935: PUSH
40936: LD_INT 30
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 30
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: LIST
40960: PPUSH
40961: CALL_OW 72
40965: PUSH
40966: LD_EXP 99
40970: PUSH
40971: LD_VAR 0 2
40975: ARRAY
40976: PPUSH
40977: LD_INT 30
40979: PUSH
40980: LD_INT 3
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PPUSH
40987: CALL_OW 72
40991: PUSH
40992: LD_EXP 99
40996: PUSH
40997: LD_VAR 0 2
41001: ARRAY
41002: PPUSH
41003: LD_INT 2
41005: PUSH
41006: LD_INT 30
41008: PUSH
41009: LD_INT 6
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 30
41018: PUSH
41019: LD_INT 7
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 30
41028: PUSH
41029: LD_INT 8
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: PPUSH
41042: CALL_OW 72
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: ST_TO_ADDR
// for j = 1 to 4 do
41053: LD_ADDR_VAR 0 3
41057: PUSH
41058: DOUBLE
41059: LD_INT 1
41061: DEC
41062: ST_TO_ADDR
41063: LD_INT 4
41065: PUSH
41066: FOR_TO
41067: IFFALSE 41258
// begin if not tmp [ j ] then
41069: LD_VAR 0 4
41073: PUSH
41074: LD_VAR 0 3
41078: ARRAY
41079: NOT
41080: IFFALSE 41084
// continue ;
41082: GO 41066
// for p in tmp [ j ] do
41084: LD_ADDR_VAR 0 5
41088: PUSH
41089: LD_VAR 0 4
41093: PUSH
41094: LD_VAR 0 3
41098: ARRAY
41099: PUSH
41100: FOR_IN
41101: IFFALSE 41254
// begin if not b [ j ] then
41103: LD_VAR 0 6
41107: PUSH
41108: LD_VAR 0 3
41112: ARRAY
41113: NOT
41114: IFFALSE 41118
// break ;
41116: GO 41254
// e := 0 ;
41118: LD_ADDR_VAR 0 7
41122: PUSH
41123: LD_INT 0
41125: ST_TO_ADDR
// for k in b [ j ] do
41126: LD_ADDR_VAR 0 8
41130: PUSH
41131: LD_VAR 0 6
41135: PUSH
41136: LD_VAR 0 3
41140: ARRAY
41141: PUSH
41142: FOR_IN
41143: IFFALSE 41170
// if IsNotFull ( k ) then
41145: LD_VAR 0 8
41149: PPUSH
41150: CALL 69411 0 1
41154: IFFALSE 41168
// begin e := k ;
41156: LD_ADDR_VAR 0 7
41160: PUSH
41161: LD_VAR 0 8
41165: ST_TO_ADDR
// break ;
41166: GO 41170
// end ;
41168: GO 41142
41170: POP
41171: POP
// if e and not UnitGoingToBuilding ( p , e ) then
41172: LD_VAR 0 7
41176: PUSH
41177: LD_VAR 0 5
41181: PPUSH
41182: LD_VAR 0 7
41186: PPUSH
41187: CALL 103290 0 2
41191: NOT
41192: AND
41193: IFFALSE 41252
// begin if IsInUnit ( p ) then
41195: LD_VAR 0 5
41199: PPUSH
41200: CALL_OW 310
41204: IFFALSE 41215
// ComExitBuilding ( p ) ;
41206: LD_VAR 0 5
41210: PPUSH
41211: CALL_OW 122
// ComEnterUnit ( p , e ) ;
41215: LD_VAR 0 5
41219: PPUSH
41220: LD_VAR 0 7
41224: PPUSH
41225: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
41229: LD_VAR 0 5
41233: PPUSH
41234: LD_VAR 0 3
41238: PPUSH
41239: CALL_OW 183
// AddComExitBuilding ( p ) ;
41243: LD_VAR 0 5
41247: PPUSH
41248: CALL_OW 182
// end ; end ;
41252: GO 41100
41254: POP
41255: POP
// end ;
41256: GO 41066
41258: POP
41259: POP
// end ;
41260: GO 40821
41262: POP
41263: POP
// end ;
41264: LD_VAR 0 1
41268: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
41269: LD_INT 0
41271: PPUSH
41272: PPUSH
41273: PPUSH
41274: PPUSH
41275: PPUSH
41276: PPUSH
41277: PPUSH
41278: PPUSH
41279: PPUSH
41280: PPUSH
41281: PPUSH
41282: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41283: LD_VAR 0 1
41287: NOT
41288: PUSH
41289: LD_EXP 99
41293: PUSH
41294: LD_VAR 0 1
41298: ARRAY
41299: NOT
41300: OR
41301: PUSH
41302: LD_EXP 99
41306: PUSH
41307: LD_VAR 0 1
41311: ARRAY
41312: PPUSH
41313: LD_INT 2
41315: PUSH
41316: LD_INT 30
41318: PUSH
41319: LD_INT 0
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 30
41328: PUSH
41329: LD_INT 1
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: LIST
41340: PPUSH
41341: CALL_OW 72
41345: NOT
41346: OR
41347: IFFALSE 41351
// exit ;
41349: GO 44854
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41351: LD_ADDR_VAR 0 4
41355: PUSH
41356: LD_EXP 99
41360: PUSH
41361: LD_VAR 0 1
41365: ARRAY
41366: PPUSH
41367: LD_INT 2
41369: PUSH
41370: LD_INT 25
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 25
41382: PUSH
41383: LD_INT 2
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 25
41392: PUSH
41393: LD_INT 3
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 25
41402: PUSH
41403: LD_INT 4
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 25
41412: PUSH
41413: LD_INT 5
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 25
41422: PUSH
41423: LD_INT 8
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 25
41432: PUSH
41433: LD_INT 9
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: PPUSH
41450: CALL_OW 72
41454: ST_TO_ADDR
// if not tmp then
41455: LD_VAR 0 4
41459: NOT
41460: IFFALSE 41464
// exit ;
41462: GO 44854
// for i in tmp do
41464: LD_ADDR_VAR 0 3
41468: PUSH
41469: LD_VAR 0 4
41473: PUSH
41474: FOR_IN
41475: IFFALSE 41506
// if GetTag ( i ) then
41477: LD_VAR 0 3
41481: PPUSH
41482: CALL_OW 110
41486: IFFALSE 41504
// tmp := tmp diff i ;
41488: LD_ADDR_VAR 0 4
41492: PUSH
41493: LD_VAR 0 4
41497: PUSH
41498: LD_VAR 0 3
41502: DIFF
41503: ST_TO_ADDR
41504: GO 41474
41506: POP
41507: POP
// if not tmp then
41508: LD_VAR 0 4
41512: NOT
41513: IFFALSE 41517
// exit ;
41515: GO 44854
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
41517: LD_ADDR_VAR 0 5
41521: PUSH
41522: LD_EXP 99
41526: PUSH
41527: LD_VAR 0 1
41531: ARRAY
41532: PPUSH
41533: LD_INT 2
41535: PUSH
41536: LD_INT 25
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 25
41548: PUSH
41549: LD_INT 5
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 25
41558: PUSH
41559: LD_INT 8
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 25
41568: PUSH
41569: LD_INT 9
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: PPUSH
41583: CALL_OW 72
41587: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
41588: LD_ADDR_VAR 0 6
41592: PUSH
41593: LD_EXP 99
41597: PUSH
41598: LD_VAR 0 1
41602: ARRAY
41603: PPUSH
41604: LD_INT 25
41606: PUSH
41607: LD_INT 2
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PPUSH
41614: CALL_OW 72
41618: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
41619: LD_ADDR_VAR 0 7
41623: PUSH
41624: LD_EXP 99
41628: PUSH
41629: LD_VAR 0 1
41633: ARRAY
41634: PPUSH
41635: LD_INT 25
41637: PUSH
41638: LD_INT 3
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PPUSH
41645: CALL_OW 72
41649: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
41650: LD_ADDR_VAR 0 8
41654: PUSH
41655: LD_EXP 99
41659: PUSH
41660: LD_VAR 0 1
41664: ARRAY
41665: PPUSH
41666: LD_INT 25
41668: PUSH
41669: LD_INT 4
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 24
41678: PUSH
41679: LD_INT 251
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PPUSH
41690: CALL_OW 72
41694: ST_TO_ADDR
// if mc_is_defending [ base ] then
41695: LD_EXP 142
41699: PUSH
41700: LD_VAR 0 1
41704: ARRAY
41705: IFFALSE 42166
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
41707: LD_ADDR_EXP 141
41711: PUSH
41712: LD_EXP 141
41716: PPUSH
41717: LD_VAR 0 1
41721: PPUSH
41722: LD_INT 4
41724: PPUSH
41725: CALL_OW 1
41729: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41730: LD_ADDR_VAR 0 12
41734: PUSH
41735: LD_EXP 99
41739: PUSH
41740: LD_VAR 0 1
41744: ARRAY
41745: PPUSH
41746: LD_INT 2
41748: PUSH
41749: LD_INT 30
41751: PUSH
41752: LD_INT 4
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 30
41761: PUSH
41762: LD_INT 5
41764: PUSH
41765: EMPTY
41766: LIST
41767: LIST
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: LIST
41773: PPUSH
41774: CALL_OW 72
41778: ST_TO_ADDR
// if not b then
41779: LD_VAR 0 12
41783: NOT
41784: IFFALSE 41788
// exit ;
41786: GO 44854
// p := [ ] ;
41788: LD_ADDR_VAR 0 11
41792: PUSH
41793: EMPTY
41794: ST_TO_ADDR
// if sci >= 2 then
41795: LD_VAR 0 8
41799: PUSH
41800: LD_INT 2
41802: GREATEREQUAL
41803: IFFALSE 41834
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
41805: LD_ADDR_VAR 0 8
41809: PUSH
41810: LD_VAR 0 8
41814: PUSH
41815: LD_INT 1
41817: ARRAY
41818: PUSH
41819: LD_VAR 0 8
41823: PUSH
41824: LD_INT 2
41826: ARRAY
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: ST_TO_ADDR
41832: GO 41895
// if sci = 1 then
41834: LD_VAR 0 8
41838: PUSH
41839: LD_INT 1
41841: EQUAL
41842: IFFALSE 41863
// sci := [ sci [ 1 ] ] else
41844: LD_ADDR_VAR 0 8
41848: PUSH
41849: LD_VAR 0 8
41853: PUSH
41854: LD_INT 1
41856: ARRAY
41857: PUSH
41858: EMPTY
41859: LIST
41860: ST_TO_ADDR
41861: GO 41895
// if sci = 0 then
41863: LD_VAR 0 8
41867: PUSH
41868: LD_INT 0
41870: EQUAL
41871: IFFALSE 41895
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
41873: LD_ADDR_VAR 0 11
41877: PUSH
41878: LD_VAR 0 4
41882: PPUSH
41883: LD_INT 4
41885: PPUSH
41886: CALL 103153 0 2
41890: PUSH
41891: LD_INT 1
41893: ARRAY
41894: ST_TO_ADDR
// if eng > 4 then
41895: LD_VAR 0 6
41899: PUSH
41900: LD_INT 4
41902: GREATER
41903: IFFALSE 41949
// for i = eng downto 4 do
41905: LD_ADDR_VAR 0 3
41909: PUSH
41910: DOUBLE
41911: LD_VAR 0 6
41915: INC
41916: ST_TO_ADDR
41917: LD_INT 4
41919: PUSH
41920: FOR_DOWNTO
41921: IFFALSE 41947
// eng := eng diff eng [ i ] ;
41923: LD_ADDR_VAR 0 6
41927: PUSH
41928: LD_VAR 0 6
41932: PUSH
41933: LD_VAR 0 6
41937: PUSH
41938: LD_VAR 0 3
41942: ARRAY
41943: DIFF
41944: ST_TO_ADDR
41945: GO 41920
41947: POP
41948: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
41949: LD_ADDR_VAR 0 4
41953: PUSH
41954: LD_VAR 0 4
41958: PUSH
41959: LD_VAR 0 5
41963: PUSH
41964: LD_VAR 0 6
41968: UNION
41969: PUSH
41970: LD_VAR 0 7
41974: UNION
41975: PUSH
41976: LD_VAR 0 8
41980: UNION
41981: DIFF
41982: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
41983: LD_ADDR_VAR 0 13
41987: PUSH
41988: LD_EXP 99
41992: PUSH
41993: LD_VAR 0 1
41997: ARRAY
41998: PPUSH
41999: LD_INT 2
42001: PUSH
42002: LD_INT 30
42004: PUSH
42005: LD_INT 32
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: LD_INT 30
42014: PUSH
42015: LD_INT 31
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: LIST
42026: PPUSH
42027: CALL_OW 72
42031: PUSH
42032: LD_EXP 99
42036: PUSH
42037: LD_VAR 0 1
42041: ARRAY
42042: PPUSH
42043: LD_INT 2
42045: PUSH
42046: LD_INT 30
42048: PUSH
42049: LD_INT 4
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PUSH
42056: LD_INT 30
42058: PUSH
42059: LD_INT 5
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: LIST
42070: PPUSH
42071: CALL_OW 72
42075: PUSH
42076: LD_INT 6
42078: MUL
42079: PLUS
42080: ST_TO_ADDR
// if bcount < tmp then
42081: LD_VAR 0 13
42085: PUSH
42086: LD_VAR 0 4
42090: LESS
42091: IFFALSE 42137
// for i = tmp downto bcount do
42093: LD_ADDR_VAR 0 3
42097: PUSH
42098: DOUBLE
42099: LD_VAR 0 4
42103: INC
42104: ST_TO_ADDR
42105: LD_VAR 0 13
42109: PUSH
42110: FOR_DOWNTO
42111: IFFALSE 42135
// tmp := Delete ( tmp , tmp ) ;
42113: LD_ADDR_VAR 0 4
42117: PUSH
42118: LD_VAR 0 4
42122: PPUSH
42123: LD_VAR 0 4
42127: PPUSH
42128: CALL_OW 3
42132: ST_TO_ADDR
42133: GO 42110
42135: POP
42136: POP
// result := [ tmp , 0 , 0 , p ] ;
42137: LD_ADDR_VAR 0 2
42141: PUSH
42142: LD_VAR 0 4
42146: PUSH
42147: LD_INT 0
42149: PUSH
42150: LD_INT 0
42152: PUSH
42153: LD_VAR 0 11
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: ST_TO_ADDR
// exit ;
42164: GO 44854
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42166: LD_EXP 99
42170: PUSH
42171: LD_VAR 0 1
42175: ARRAY
42176: PPUSH
42177: LD_INT 2
42179: PUSH
42180: LD_INT 30
42182: PUSH
42183: LD_INT 6
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 30
42192: PUSH
42193: LD_INT 7
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 30
42202: PUSH
42203: LD_INT 8
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: EMPTY
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: PPUSH
42216: CALL_OW 72
42220: NOT
42221: PUSH
42222: LD_EXP 99
42226: PUSH
42227: LD_VAR 0 1
42231: ARRAY
42232: PPUSH
42233: LD_INT 30
42235: PUSH
42236: LD_INT 3
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PPUSH
42243: CALL_OW 72
42247: NOT
42248: AND
42249: IFFALSE 42321
// begin if eng = tmp then
42251: LD_VAR 0 6
42255: PUSH
42256: LD_VAR 0 4
42260: EQUAL
42261: IFFALSE 42265
// exit ;
42263: GO 44854
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
42265: LD_ADDR_EXP 141
42269: PUSH
42270: LD_EXP 141
42274: PPUSH
42275: LD_VAR 0 1
42279: PPUSH
42280: LD_INT 1
42282: PPUSH
42283: CALL_OW 1
42287: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
42288: LD_ADDR_VAR 0 2
42292: PUSH
42293: LD_INT 0
42295: PUSH
42296: LD_VAR 0 4
42300: PUSH
42301: LD_VAR 0 6
42305: DIFF
42306: PUSH
42307: LD_INT 0
42309: PUSH
42310: LD_INT 0
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: ST_TO_ADDR
// exit ;
42319: GO 44854
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42321: LD_EXP 126
42325: PUSH
42326: LD_EXP 125
42330: PUSH
42331: LD_VAR 0 1
42335: ARRAY
42336: ARRAY
42337: PUSH
42338: LD_EXP 99
42342: PUSH
42343: LD_VAR 0 1
42347: ARRAY
42348: PPUSH
42349: LD_INT 2
42351: PUSH
42352: LD_INT 30
42354: PUSH
42355: LD_INT 6
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 30
42364: PUSH
42365: LD_INT 7
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 30
42374: PUSH
42375: LD_INT 8
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: PPUSH
42388: CALL_OW 72
42392: AND
42393: PUSH
42394: LD_EXP 99
42398: PUSH
42399: LD_VAR 0 1
42403: ARRAY
42404: PPUSH
42405: LD_INT 30
42407: PUSH
42408: LD_INT 3
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL_OW 72
42419: NOT
42420: AND
42421: IFFALSE 42635
// begin if sci >= 6 then
42423: LD_VAR 0 8
42427: PUSH
42428: LD_INT 6
42430: GREATEREQUAL
42431: IFFALSE 42435
// exit ;
42433: GO 44854
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
42435: LD_ADDR_EXP 141
42439: PUSH
42440: LD_EXP 141
42444: PPUSH
42445: LD_VAR 0 1
42449: PPUSH
42450: LD_INT 2
42452: PPUSH
42453: CALL_OW 1
42457: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
42458: LD_ADDR_VAR 0 9
42462: PUSH
42463: LD_VAR 0 4
42467: PUSH
42468: LD_VAR 0 8
42472: DIFF
42473: PPUSH
42474: LD_INT 4
42476: PPUSH
42477: CALL 103153 0 2
42481: ST_TO_ADDR
// p := [ ] ;
42482: LD_ADDR_VAR 0 11
42486: PUSH
42487: EMPTY
42488: ST_TO_ADDR
// if sci < 6 and sort > 6 then
42489: LD_VAR 0 8
42493: PUSH
42494: LD_INT 6
42496: LESS
42497: PUSH
42498: LD_VAR 0 9
42502: PUSH
42503: LD_INT 6
42505: GREATER
42506: AND
42507: IFFALSE 42588
// begin for i = 1 to 6 - sci do
42509: LD_ADDR_VAR 0 3
42513: PUSH
42514: DOUBLE
42515: LD_INT 1
42517: DEC
42518: ST_TO_ADDR
42519: LD_INT 6
42521: PUSH
42522: LD_VAR 0 8
42526: MINUS
42527: PUSH
42528: FOR_TO
42529: IFFALSE 42584
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
42531: LD_ADDR_VAR 0 11
42535: PUSH
42536: LD_VAR 0 11
42540: PPUSH
42541: LD_VAR 0 11
42545: PUSH
42546: LD_INT 1
42548: PLUS
42549: PPUSH
42550: LD_VAR 0 9
42554: PUSH
42555: LD_INT 1
42557: ARRAY
42558: PPUSH
42559: CALL_OW 2
42563: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
42564: LD_ADDR_VAR 0 9
42568: PUSH
42569: LD_VAR 0 9
42573: PPUSH
42574: LD_INT 1
42576: PPUSH
42577: CALL_OW 3
42581: ST_TO_ADDR
// end ;
42582: GO 42528
42584: POP
42585: POP
// end else
42586: GO 42608
// if sort then
42588: LD_VAR 0 9
42592: IFFALSE 42608
// p := sort [ 1 ] ;
42594: LD_ADDR_VAR 0 11
42598: PUSH
42599: LD_VAR 0 9
42603: PUSH
42604: LD_INT 1
42606: ARRAY
42607: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
42608: LD_ADDR_VAR 0 2
42612: PUSH
42613: LD_INT 0
42615: PUSH
42616: LD_INT 0
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: LD_VAR 0 11
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// exit ;
42633: GO 44854
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
42635: LD_EXP 126
42639: PUSH
42640: LD_EXP 125
42644: PUSH
42645: LD_VAR 0 1
42649: ARRAY
42650: ARRAY
42651: PUSH
42652: LD_EXP 99
42656: PUSH
42657: LD_VAR 0 1
42661: ARRAY
42662: PPUSH
42663: LD_INT 2
42665: PUSH
42666: LD_INT 30
42668: PUSH
42669: LD_INT 6
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: PUSH
42676: LD_INT 30
42678: PUSH
42679: LD_INT 7
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 30
42688: PUSH
42689: LD_INT 8
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: PPUSH
42702: CALL_OW 72
42706: AND
42707: PUSH
42708: LD_EXP 99
42712: PUSH
42713: LD_VAR 0 1
42717: ARRAY
42718: PPUSH
42719: LD_INT 30
42721: PUSH
42722: LD_INT 3
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PPUSH
42729: CALL_OW 72
42733: AND
42734: IFFALSE 43468
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
42736: LD_ADDR_EXP 141
42740: PUSH
42741: LD_EXP 141
42745: PPUSH
42746: LD_VAR 0 1
42750: PPUSH
42751: LD_INT 3
42753: PPUSH
42754: CALL_OW 1
42758: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42759: LD_ADDR_VAR 0 2
42763: PUSH
42764: LD_INT 0
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: LD_INT 0
42772: PUSH
42773: LD_INT 0
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: ST_TO_ADDR
// if not eng then
42782: LD_VAR 0 6
42786: NOT
42787: IFFALSE 42850
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
42789: LD_ADDR_VAR 0 11
42793: PUSH
42794: LD_VAR 0 4
42798: PPUSH
42799: LD_INT 2
42801: PPUSH
42802: CALL 103153 0 2
42806: PUSH
42807: LD_INT 1
42809: ARRAY
42810: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
42811: LD_ADDR_VAR 0 2
42815: PUSH
42816: LD_VAR 0 2
42820: PPUSH
42821: LD_INT 2
42823: PPUSH
42824: LD_VAR 0 11
42828: PPUSH
42829: CALL_OW 1
42833: ST_TO_ADDR
// tmp := tmp diff p ;
42834: LD_ADDR_VAR 0 4
42838: PUSH
42839: LD_VAR 0 4
42843: PUSH
42844: LD_VAR 0 11
42848: DIFF
42849: ST_TO_ADDR
// end ; if tmp and sci < 6 then
42850: LD_VAR 0 4
42854: PUSH
42855: LD_VAR 0 8
42859: PUSH
42860: LD_INT 6
42862: LESS
42863: AND
42864: IFFALSE 43052
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
42866: LD_ADDR_VAR 0 9
42870: PUSH
42871: LD_VAR 0 4
42875: PUSH
42876: LD_VAR 0 8
42880: PUSH
42881: LD_VAR 0 7
42885: UNION
42886: DIFF
42887: PPUSH
42888: LD_INT 4
42890: PPUSH
42891: CALL 103153 0 2
42895: ST_TO_ADDR
// p := [ ] ;
42896: LD_ADDR_VAR 0 11
42900: PUSH
42901: EMPTY
42902: ST_TO_ADDR
// if sort then
42903: LD_VAR 0 9
42907: IFFALSE 43023
// for i = 1 to 6 - sci do
42909: LD_ADDR_VAR 0 3
42913: PUSH
42914: DOUBLE
42915: LD_INT 1
42917: DEC
42918: ST_TO_ADDR
42919: LD_INT 6
42921: PUSH
42922: LD_VAR 0 8
42926: MINUS
42927: PUSH
42928: FOR_TO
42929: IFFALSE 43021
// begin if i = sort then
42931: LD_VAR 0 3
42935: PUSH
42936: LD_VAR 0 9
42940: EQUAL
42941: IFFALSE 42945
// break ;
42943: GO 43021
// if GetClass ( i ) = 4 then
42945: LD_VAR 0 3
42949: PPUSH
42950: CALL_OW 257
42954: PUSH
42955: LD_INT 4
42957: EQUAL
42958: IFFALSE 42962
// continue ;
42960: GO 42928
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42962: LD_ADDR_VAR 0 11
42966: PUSH
42967: LD_VAR 0 11
42971: PPUSH
42972: LD_VAR 0 11
42976: PUSH
42977: LD_INT 1
42979: PLUS
42980: PPUSH
42981: LD_VAR 0 9
42985: PUSH
42986: LD_VAR 0 3
42990: ARRAY
42991: PPUSH
42992: CALL_OW 2
42996: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42997: LD_ADDR_VAR 0 4
43001: PUSH
43002: LD_VAR 0 4
43006: PUSH
43007: LD_VAR 0 9
43011: PUSH
43012: LD_VAR 0 3
43016: ARRAY
43017: DIFF
43018: ST_TO_ADDR
// end ;
43019: GO 42928
43021: POP
43022: POP
// if p then
43023: LD_VAR 0 11
43027: IFFALSE 43052
// result := Replace ( result , 4 , p ) ;
43029: LD_ADDR_VAR 0 2
43033: PUSH
43034: LD_VAR 0 2
43038: PPUSH
43039: LD_INT 4
43041: PPUSH
43042: LD_VAR 0 11
43046: PPUSH
43047: CALL_OW 1
43051: ST_TO_ADDR
// end ; if tmp and mech < 6 then
43052: LD_VAR 0 4
43056: PUSH
43057: LD_VAR 0 7
43061: PUSH
43062: LD_INT 6
43064: LESS
43065: AND
43066: IFFALSE 43254
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43068: LD_ADDR_VAR 0 9
43072: PUSH
43073: LD_VAR 0 4
43077: PUSH
43078: LD_VAR 0 8
43082: PUSH
43083: LD_VAR 0 7
43087: UNION
43088: DIFF
43089: PPUSH
43090: LD_INT 3
43092: PPUSH
43093: CALL 103153 0 2
43097: ST_TO_ADDR
// p := [ ] ;
43098: LD_ADDR_VAR 0 11
43102: PUSH
43103: EMPTY
43104: ST_TO_ADDR
// if sort then
43105: LD_VAR 0 9
43109: IFFALSE 43225
// for i = 1 to 6 - mech do
43111: LD_ADDR_VAR 0 3
43115: PUSH
43116: DOUBLE
43117: LD_INT 1
43119: DEC
43120: ST_TO_ADDR
43121: LD_INT 6
43123: PUSH
43124: LD_VAR 0 7
43128: MINUS
43129: PUSH
43130: FOR_TO
43131: IFFALSE 43223
// begin if i = sort then
43133: LD_VAR 0 3
43137: PUSH
43138: LD_VAR 0 9
43142: EQUAL
43143: IFFALSE 43147
// break ;
43145: GO 43223
// if GetClass ( i ) = 3 then
43147: LD_VAR 0 3
43151: PPUSH
43152: CALL_OW 257
43156: PUSH
43157: LD_INT 3
43159: EQUAL
43160: IFFALSE 43164
// continue ;
43162: GO 43130
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43164: LD_ADDR_VAR 0 11
43168: PUSH
43169: LD_VAR 0 11
43173: PPUSH
43174: LD_VAR 0 11
43178: PUSH
43179: LD_INT 1
43181: PLUS
43182: PPUSH
43183: LD_VAR 0 9
43187: PUSH
43188: LD_VAR 0 3
43192: ARRAY
43193: PPUSH
43194: CALL_OW 2
43198: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43199: LD_ADDR_VAR 0 4
43203: PUSH
43204: LD_VAR 0 4
43208: PUSH
43209: LD_VAR 0 9
43213: PUSH
43214: LD_VAR 0 3
43218: ARRAY
43219: DIFF
43220: ST_TO_ADDR
// end ;
43221: GO 43130
43223: POP
43224: POP
// if p then
43225: LD_VAR 0 11
43229: IFFALSE 43254
// result := Replace ( result , 3 , p ) ;
43231: LD_ADDR_VAR 0 2
43235: PUSH
43236: LD_VAR 0 2
43240: PPUSH
43241: LD_INT 3
43243: PPUSH
43244: LD_VAR 0 11
43248: PPUSH
43249: CALL_OW 1
43253: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
43254: LD_VAR 0 4
43258: PUSH
43259: LD_INT 6
43261: GREATER
43262: PUSH
43263: LD_VAR 0 6
43267: PUSH
43268: LD_INT 6
43270: LESS
43271: AND
43272: IFFALSE 43466
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43274: LD_ADDR_VAR 0 9
43278: PUSH
43279: LD_VAR 0 4
43283: PUSH
43284: LD_VAR 0 8
43288: PUSH
43289: LD_VAR 0 7
43293: UNION
43294: PUSH
43295: LD_VAR 0 6
43299: UNION
43300: DIFF
43301: PPUSH
43302: LD_INT 2
43304: PPUSH
43305: CALL 103153 0 2
43309: ST_TO_ADDR
// p := [ ] ;
43310: LD_ADDR_VAR 0 11
43314: PUSH
43315: EMPTY
43316: ST_TO_ADDR
// if sort then
43317: LD_VAR 0 9
43321: IFFALSE 43437
// for i = 1 to 6 - eng do
43323: LD_ADDR_VAR 0 3
43327: PUSH
43328: DOUBLE
43329: LD_INT 1
43331: DEC
43332: ST_TO_ADDR
43333: LD_INT 6
43335: PUSH
43336: LD_VAR 0 6
43340: MINUS
43341: PUSH
43342: FOR_TO
43343: IFFALSE 43435
// begin if i = sort then
43345: LD_VAR 0 3
43349: PUSH
43350: LD_VAR 0 9
43354: EQUAL
43355: IFFALSE 43359
// break ;
43357: GO 43435
// if GetClass ( i ) = 2 then
43359: LD_VAR 0 3
43363: PPUSH
43364: CALL_OW 257
43368: PUSH
43369: LD_INT 2
43371: EQUAL
43372: IFFALSE 43376
// continue ;
43374: GO 43342
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43376: LD_ADDR_VAR 0 11
43380: PUSH
43381: LD_VAR 0 11
43385: PPUSH
43386: LD_VAR 0 11
43390: PUSH
43391: LD_INT 1
43393: PLUS
43394: PPUSH
43395: LD_VAR 0 9
43399: PUSH
43400: LD_VAR 0 3
43404: ARRAY
43405: PPUSH
43406: CALL_OW 2
43410: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43411: LD_ADDR_VAR 0 4
43415: PUSH
43416: LD_VAR 0 4
43420: PUSH
43421: LD_VAR 0 9
43425: PUSH
43426: LD_VAR 0 3
43430: ARRAY
43431: DIFF
43432: ST_TO_ADDR
// end ;
43433: GO 43342
43435: POP
43436: POP
// if p then
43437: LD_VAR 0 11
43441: IFFALSE 43466
// result := Replace ( result , 2 , p ) ;
43443: LD_ADDR_VAR 0 2
43447: PUSH
43448: LD_VAR 0 2
43452: PPUSH
43453: LD_INT 2
43455: PPUSH
43456: LD_VAR 0 11
43460: PPUSH
43461: CALL_OW 1
43465: ST_TO_ADDR
// end ; exit ;
43466: GO 44854
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
43468: LD_EXP 126
43472: PUSH
43473: LD_EXP 125
43477: PUSH
43478: LD_VAR 0 1
43482: ARRAY
43483: ARRAY
43484: NOT
43485: PUSH
43486: LD_EXP 99
43490: PUSH
43491: LD_VAR 0 1
43495: ARRAY
43496: PPUSH
43497: LD_INT 30
43499: PUSH
43500: LD_INT 3
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PPUSH
43507: CALL_OW 72
43511: AND
43512: PUSH
43513: LD_EXP 104
43517: PUSH
43518: LD_VAR 0 1
43522: ARRAY
43523: AND
43524: IFFALSE 44132
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
43526: LD_ADDR_EXP 141
43530: PUSH
43531: LD_EXP 141
43535: PPUSH
43536: LD_VAR 0 1
43540: PPUSH
43541: LD_INT 5
43543: PPUSH
43544: CALL_OW 1
43548: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
43549: LD_ADDR_VAR 0 2
43553: PUSH
43554: LD_INT 0
43556: PUSH
43557: LD_INT 0
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: LD_INT 0
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: ST_TO_ADDR
// if sci > 1 then
43572: LD_VAR 0 8
43576: PUSH
43577: LD_INT 1
43579: GREATER
43580: IFFALSE 43608
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
43582: LD_ADDR_VAR 0 4
43586: PUSH
43587: LD_VAR 0 4
43591: PUSH
43592: LD_VAR 0 8
43596: PUSH
43597: LD_VAR 0 8
43601: PUSH
43602: LD_INT 1
43604: ARRAY
43605: DIFF
43606: DIFF
43607: ST_TO_ADDR
// if tmp and not sci then
43608: LD_VAR 0 4
43612: PUSH
43613: LD_VAR 0 8
43617: NOT
43618: AND
43619: IFFALSE 43688
// begin sort := SortBySkill ( tmp , 4 ) ;
43621: LD_ADDR_VAR 0 9
43625: PUSH
43626: LD_VAR 0 4
43630: PPUSH
43631: LD_INT 4
43633: PPUSH
43634: CALL 103153 0 2
43638: ST_TO_ADDR
// if sort then
43639: LD_VAR 0 9
43643: IFFALSE 43659
// p := sort [ 1 ] ;
43645: LD_ADDR_VAR 0 11
43649: PUSH
43650: LD_VAR 0 9
43654: PUSH
43655: LD_INT 1
43657: ARRAY
43658: ST_TO_ADDR
// if p then
43659: LD_VAR 0 11
43663: IFFALSE 43688
// result := Replace ( result , 4 , p ) ;
43665: LD_ADDR_VAR 0 2
43669: PUSH
43670: LD_VAR 0 2
43674: PPUSH
43675: LD_INT 4
43677: PPUSH
43678: LD_VAR 0 11
43682: PPUSH
43683: CALL_OW 1
43687: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43688: LD_ADDR_VAR 0 4
43692: PUSH
43693: LD_VAR 0 4
43697: PUSH
43698: LD_VAR 0 7
43702: DIFF
43703: ST_TO_ADDR
// if tmp and mech < 6 then
43704: LD_VAR 0 4
43708: PUSH
43709: LD_VAR 0 7
43713: PUSH
43714: LD_INT 6
43716: LESS
43717: AND
43718: IFFALSE 43906
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
43720: LD_ADDR_VAR 0 9
43724: PUSH
43725: LD_VAR 0 4
43729: PUSH
43730: LD_VAR 0 8
43734: PUSH
43735: LD_VAR 0 7
43739: UNION
43740: DIFF
43741: PPUSH
43742: LD_INT 3
43744: PPUSH
43745: CALL 103153 0 2
43749: ST_TO_ADDR
// p := [ ] ;
43750: LD_ADDR_VAR 0 11
43754: PUSH
43755: EMPTY
43756: ST_TO_ADDR
// if sort then
43757: LD_VAR 0 9
43761: IFFALSE 43877
// for i = 1 to 6 - mech do
43763: LD_ADDR_VAR 0 3
43767: PUSH
43768: DOUBLE
43769: LD_INT 1
43771: DEC
43772: ST_TO_ADDR
43773: LD_INT 6
43775: PUSH
43776: LD_VAR 0 7
43780: MINUS
43781: PUSH
43782: FOR_TO
43783: IFFALSE 43875
// begin if i = sort then
43785: LD_VAR 0 3
43789: PUSH
43790: LD_VAR 0 9
43794: EQUAL
43795: IFFALSE 43799
// break ;
43797: GO 43875
// if GetClass ( i ) = 3 then
43799: LD_VAR 0 3
43803: PPUSH
43804: CALL_OW 257
43808: PUSH
43809: LD_INT 3
43811: EQUAL
43812: IFFALSE 43816
// continue ;
43814: GO 43782
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43816: LD_ADDR_VAR 0 11
43820: PUSH
43821: LD_VAR 0 11
43825: PPUSH
43826: LD_VAR 0 11
43830: PUSH
43831: LD_INT 1
43833: PLUS
43834: PPUSH
43835: LD_VAR 0 9
43839: PUSH
43840: LD_VAR 0 3
43844: ARRAY
43845: PPUSH
43846: CALL_OW 2
43850: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43851: LD_ADDR_VAR 0 4
43855: PUSH
43856: LD_VAR 0 4
43860: PUSH
43861: LD_VAR 0 9
43865: PUSH
43866: LD_VAR 0 3
43870: ARRAY
43871: DIFF
43872: ST_TO_ADDR
// end ;
43873: GO 43782
43875: POP
43876: POP
// if p then
43877: LD_VAR 0 11
43881: IFFALSE 43906
// result := Replace ( result , 3 , p ) ;
43883: LD_ADDR_VAR 0 2
43887: PUSH
43888: LD_VAR 0 2
43892: PPUSH
43893: LD_INT 3
43895: PPUSH
43896: LD_VAR 0 11
43900: PPUSH
43901: CALL_OW 1
43905: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43906: LD_ADDR_VAR 0 4
43910: PUSH
43911: LD_VAR 0 4
43915: PUSH
43916: LD_VAR 0 6
43920: DIFF
43921: ST_TO_ADDR
// if tmp and eng < 6 then
43922: LD_VAR 0 4
43926: PUSH
43927: LD_VAR 0 6
43931: PUSH
43932: LD_INT 6
43934: LESS
43935: AND
43936: IFFALSE 44130
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
43938: LD_ADDR_VAR 0 9
43942: PUSH
43943: LD_VAR 0 4
43947: PUSH
43948: LD_VAR 0 8
43952: PUSH
43953: LD_VAR 0 7
43957: UNION
43958: PUSH
43959: LD_VAR 0 6
43963: UNION
43964: DIFF
43965: PPUSH
43966: LD_INT 2
43968: PPUSH
43969: CALL 103153 0 2
43973: ST_TO_ADDR
// p := [ ] ;
43974: LD_ADDR_VAR 0 11
43978: PUSH
43979: EMPTY
43980: ST_TO_ADDR
// if sort then
43981: LD_VAR 0 9
43985: IFFALSE 44101
// for i = 1 to 6 - eng do
43987: LD_ADDR_VAR 0 3
43991: PUSH
43992: DOUBLE
43993: LD_INT 1
43995: DEC
43996: ST_TO_ADDR
43997: LD_INT 6
43999: PUSH
44000: LD_VAR 0 6
44004: MINUS
44005: PUSH
44006: FOR_TO
44007: IFFALSE 44099
// begin if i = sort then
44009: LD_VAR 0 3
44013: PUSH
44014: LD_VAR 0 9
44018: EQUAL
44019: IFFALSE 44023
// break ;
44021: GO 44099
// if GetClass ( i ) = 2 then
44023: LD_VAR 0 3
44027: PPUSH
44028: CALL_OW 257
44032: PUSH
44033: LD_INT 2
44035: EQUAL
44036: IFFALSE 44040
// continue ;
44038: GO 44006
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44040: LD_ADDR_VAR 0 11
44044: PUSH
44045: LD_VAR 0 11
44049: PPUSH
44050: LD_VAR 0 11
44054: PUSH
44055: LD_INT 1
44057: PLUS
44058: PPUSH
44059: LD_VAR 0 9
44063: PUSH
44064: LD_VAR 0 3
44068: ARRAY
44069: PPUSH
44070: CALL_OW 2
44074: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44075: LD_ADDR_VAR 0 4
44079: PUSH
44080: LD_VAR 0 4
44084: PUSH
44085: LD_VAR 0 9
44089: PUSH
44090: LD_VAR 0 3
44094: ARRAY
44095: DIFF
44096: ST_TO_ADDR
// end ;
44097: GO 44006
44099: POP
44100: POP
// if p then
44101: LD_VAR 0 11
44105: IFFALSE 44130
// result := Replace ( result , 2 , p ) ;
44107: LD_ADDR_VAR 0 2
44111: PUSH
44112: LD_VAR 0 2
44116: PPUSH
44117: LD_INT 2
44119: PPUSH
44120: LD_VAR 0 11
44124: PPUSH
44125: CALL_OW 1
44129: ST_TO_ADDR
// end ; exit ;
44130: GO 44854
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
44132: LD_EXP 126
44136: PUSH
44137: LD_EXP 125
44141: PUSH
44142: LD_VAR 0 1
44146: ARRAY
44147: ARRAY
44148: NOT
44149: PUSH
44150: LD_EXP 99
44154: PUSH
44155: LD_VAR 0 1
44159: ARRAY
44160: PPUSH
44161: LD_INT 30
44163: PUSH
44164: LD_INT 3
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PPUSH
44171: CALL_OW 72
44175: AND
44176: PUSH
44177: LD_EXP 104
44181: PUSH
44182: LD_VAR 0 1
44186: ARRAY
44187: NOT
44188: AND
44189: IFFALSE 44854
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
44191: LD_ADDR_EXP 141
44195: PUSH
44196: LD_EXP 141
44200: PPUSH
44201: LD_VAR 0 1
44205: PPUSH
44206: LD_INT 6
44208: PPUSH
44209: CALL_OW 1
44213: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44214: LD_ADDR_VAR 0 2
44218: PUSH
44219: LD_INT 0
44221: PUSH
44222: LD_INT 0
44224: PUSH
44225: LD_INT 0
44227: PUSH
44228: LD_INT 0
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: ST_TO_ADDR
// if sci >= 1 then
44237: LD_VAR 0 8
44241: PUSH
44242: LD_INT 1
44244: GREATEREQUAL
44245: IFFALSE 44267
// tmp := tmp diff sci [ 1 ] ;
44247: LD_ADDR_VAR 0 4
44251: PUSH
44252: LD_VAR 0 4
44256: PUSH
44257: LD_VAR 0 8
44261: PUSH
44262: LD_INT 1
44264: ARRAY
44265: DIFF
44266: ST_TO_ADDR
// if tmp and not sci then
44267: LD_VAR 0 4
44271: PUSH
44272: LD_VAR 0 8
44276: NOT
44277: AND
44278: IFFALSE 44347
// begin sort := SortBySkill ( tmp , 4 ) ;
44280: LD_ADDR_VAR 0 9
44284: PUSH
44285: LD_VAR 0 4
44289: PPUSH
44290: LD_INT 4
44292: PPUSH
44293: CALL 103153 0 2
44297: ST_TO_ADDR
// if sort then
44298: LD_VAR 0 9
44302: IFFALSE 44318
// p := sort [ 1 ] ;
44304: LD_ADDR_VAR 0 11
44308: PUSH
44309: LD_VAR 0 9
44313: PUSH
44314: LD_INT 1
44316: ARRAY
44317: ST_TO_ADDR
// if p then
44318: LD_VAR 0 11
44322: IFFALSE 44347
// result := Replace ( result , 4 , p ) ;
44324: LD_ADDR_VAR 0 2
44328: PUSH
44329: LD_VAR 0 2
44333: PPUSH
44334: LD_INT 4
44336: PPUSH
44337: LD_VAR 0 11
44341: PPUSH
44342: CALL_OW 1
44346: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
44347: LD_ADDR_VAR 0 4
44351: PUSH
44352: LD_VAR 0 4
44356: PUSH
44357: LD_VAR 0 7
44361: DIFF
44362: ST_TO_ADDR
// if tmp and mech < 6 then
44363: LD_VAR 0 4
44367: PUSH
44368: LD_VAR 0 7
44372: PUSH
44373: LD_INT 6
44375: LESS
44376: AND
44377: IFFALSE 44559
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
44379: LD_ADDR_VAR 0 9
44383: PUSH
44384: LD_VAR 0 4
44388: PUSH
44389: LD_VAR 0 7
44393: DIFF
44394: PPUSH
44395: LD_INT 3
44397: PPUSH
44398: CALL 103153 0 2
44402: ST_TO_ADDR
// p := [ ] ;
44403: LD_ADDR_VAR 0 11
44407: PUSH
44408: EMPTY
44409: ST_TO_ADDR
// if sort then
44410: LD_VAR 0 9
44414: IFFALSE 44530
// for i = 1 to 6 - mech do
44416: LD_ADDR_VAR 0 3
44420: PUSH
44421: DOUBLE
44422: LD_INT 1
44424: DEC
44425: ST_TO_ADDR
44426: LD_INT 6
44428: PUSH
44429: LD_VAR 0 7
44433: MINUS
44434: PUSH
44435: FOR_TO
44436: IFFALSE 44528
// begin if i = sort then
44438: LD_VAR 0 3
44442: PUSH
44443: LD_VAR 0 9
44447: EQUAL
44448: IFFALSE 44452
// break ;
44450: GO 44528
// if GetClass ( i ) = 3 then
44452: LD_VAR 0 3
44456: PPUSH
44457: CALL_OW 257
44461: PUSH
44462: LD_INT 3
44464: EQUAL
44465: IFFALSE 44469
// continue ;
44467: GO 44435
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44469: LD_ADDR_VAR 0 11
44473: PUSH
44474: LD_VAR 0 11
44478: PPUSH
44479: LD_VAR 0 11
44483: PUSH
44484: LD_INT 1
44486: PLUS
44487: PPUSH
44488: LD_VAR 0 9
44492: PUSH
44493: LD_VAR 0 3
44497: ARRAY
44498: PPUSH
44499: CALL_OW 2
44503: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44504: LD_ADDR_VAR 0 4
44508: PUSH
44509: LD_VAR 0 4
44513: PUSH
44514: LD_VAR 0 9
44518: PUSH
44519: LD_VAR 0 3
44523: ARRAY
44524: DIFF
44525: ST_TO_ADDR
// end ;
44526: GO 44435
44528: POP
44529: POP
// if p then
44530: LD_VAR 0 11
44534: IFFALSE 44559
// result := Replace ( result , 3 , p ) ;
44536: LD_ADDR_VAR 0 2
44540: PUSH
44541: LD_VAR 0 2
44545: PPUSH
44546: LD_INT 3
44548: PPUSH
44549: LD_VAR 0 11
44553: PPUSH
44554: CALL_OW 1
44558: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
44559: LD_ADDR_VAR 0 4
44563: PUSH
44564: LD_VAR 0 4
44568: PUSH
44569: LD_VAR 0 6
44573: DIFF
44574: ST_TO_ADDR
// if tmp and eng < 4 then
44575: LD_VAR 0 4
44579: PUSH
44580: LD_VAR 0 6
44584: PUSH
44585: LD_INT 4
44587: LESS
44588: AND
44589: IFFALSE 44779
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
44591: LD_ADDR_VAR 0 9
44595: PUSH
44596: LD_VAR 0 4
44600: PUSH
44601: LD_VAR 0 7
44605: PUSH
44606: LD_VAR 0 6
44610: UNION
44611: DIFF
44612: PPUSH
44613: LD_INT 2
44615: PPUSH
44616: CALL 103153 0 2
44620: ST_TO_ADDR
// p := [ ] ;
44621: LD_ADDR_VAR 0 11
44625: PUSH
44626: EMPTY
44627: ST_TO_ADDR
// if sort then
44628: LD_VAR 0 9
44632: IFFALSE 44748
// for i = 1 to 4 - eng do
44634: LD_ADDR_VAR 0 3
44638: PUSH
44639: DOUBLE
44640: LD_INT 1
44642: DEC
44643: ST_TO_ADDR
44644: LD_INT 4
44646: PUSH
44647: LD_VAR 0 6
44651: MINUS
44652: PUSH
44653: FOR_TO
44654: IFFALSE 44746
// begin if i = sort then
44656: LD_VAR 0 3
44660: PUSH
44661: LD_VAR 0 9
44665: EQUAL
44666: IFFALSE 44670
// break ;
44668: GO 44746
// if GetClass ( i ) = 2 then
44670: LD_VAR 0 3
44674: PPUSH
44675: CALL_OW 257
44679: PUSH
44680: LD_INT 2
44682: EQUAL
44683: IFFALSE 44687
// continue ;
44685: GO 44653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44687: LD_ADDR_VAR 0 11
44691: PUSH
44692: LD_VAR 0 11
44696: PPUSH
44697: LD_VAR 0 11
44701: PUSH
44702: LD_INT 1
44704: PLUS
44705: PPUSH
44706: LD_VAR 0 9
44710: PUSH
44711: LD_VAR 0 3
44715: ARRAY
44716: PPUSH
44717: CALL_OW 2
44721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44722: LD_ADDR_VAR 0 4
44726: PUSH
44727: LD_VAR 0 4
44731: PUSH
44732: LD_VAR 0 9
44736: PUSH
44737: LD_VAR 0 3
44741: ARRAY
44742: DIFF
44743: ST_TO_ADDR
// end ;
44744: GO 44653
44746: POP
44747: POP
// if p then
44748: LD_VAR 0 11
44752: IFFALSE 44777
// result := Replace ( result , 2 , p ) ;
44754: LD_ADDR_VAR 0 2
44758: PUSH
44759: LD_VAR 0 2
44763: PPUSH
44764: LD_INT 2
44766: PPUSH
44767: LD_VAR 0 11
44771: PPUSH
44772: CALL_OW 1
44776: ST_TO_ADDR
// end else
44777: GO 44823
// for i = eng downto 5 do
44779: LD_ADDR_VAR 0 3
44783: PUSH
44784: DOUBLE
44785: LD_VAR 0 6
44789: INC
44790: ST_TO_ADDR
44791: LD_INT 5
44793: PUSH
44794: FOR_DOWNTO
44795: IFFALSE 44821
// tmp := tmp union eng [ i ] ;
44797: LD_ADDR_VAR 0 4
44801: PUSH
44802: LD_VAR 0 4
44806: PUSH
44807: LD_VAR 0 6
44811: PUSH
44812: LD_VAR 0 3
44816: ARRAY
44817: UNION
44818: ST_TO_ADDR
44819: GO 44794
44821: POP
44822: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
44823: LD_ADDR_VAR 0 2
44827: PUSH
44828: LD_VAR 0 2
44832: PPUSH
44833: LD_INT 1
44835: PPUSH
44836: LD_VAR 0 4
44840: PUSH
44841: LD_VAR 0 5
44845: DIFF
44846: PPUSH
44847: CALL_OW 1
44851: ST_TO_ADDR
// exit ;
44852: GO 44854
// end ; end ;
44854: LD_VAR 0 2
44858: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
44859: LD_INT 0
44861: PPUSH
44862: PPUSH
44863: PPUSH
// if not mc_bases then
44864: LD_EXP 99
44868: NOT
44869: IFFALSE 44873
// exit ;
44871: GO 45015
// for i = 1 to mc_bases do
44873: LD_ADDR_VAR 0 2
44877: PUSH
44878: DOUBLE
44879: LD_INT 1
44881: DEC
44882: ST_TO_ADDR
44883: LD_EXP 99
44887: PUSH
44888: FOR_TO
44889: IFFALSE 45006
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
44891: LD_ADDR_VAR 0 3
44895: PUSH
44896: LD_EXP 99
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: PPUSH
44907: LD_INT 21
44909: PUSH
44910: LD_INT 3
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 3
44919: PUSH
44920: LD_INT 2
44922: PUSH
44923: LD_INT 30
44925: PUSH
44926: LD_INT 29
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 30
44935: PUSH
44936: LD_INT 30
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: LIST
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: LD_INT 3
44954: PUSH
44955: LD_INT 24
44957: PUSH
44958: LD_INT 1000
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: LIST
44973: PPUSH
44974: CALL_OW 72
44978: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
44979: LD_ADDR_EXP 100
44983: PUSH
44984: LD_EXP 100
44988: PPUSH
44989: LD_VAR 0 2
44993: PPUSH
44994: LD_VAR 0 3
44998: PPUSH
44999: CALL_OW 1
45003: ST_TO_ADDR
// end ;
45004: GO 44888
45006: POP
45007: POP
// RaiseSailEvent ( 101 ) ;
45008: LD_INT 101
45010: PPUSH
45011: CALL_OW 427
// end ;
45015: LD_VAR 0 1
45019: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
45020: LD_INT 0
45022: PPUSH
45023: PPUSH
45024: PPUSH
45025: PPUSH
45026: PPUSH
45027: PPUSH
45028: PPUSH
// if not mc_bases then
45029: LD_EXP 99
45033: NOT
45034: IFFALSE 45038
// exit ;
45036: GO 45600
// for i = 1 to mc_bases do
45038: LD_ADDR_VAR 0 2
45042: PUSH
45043: DOUBLE
45044: LD_INT 1
45046: DEC
45047: ST_TO_ADDR
45048: LD_EXP 99
45052: PUSH
45053: FOR_TO
45054: IFFALSE 45591
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
45056: LD_ADDR_VAR 0 5
45060: PUSH
45061: LD_EXP 99
45065: PUSH
45066: LD_VAR 0 2
45070: ARRAY
45071: PUSH
45072: LD_EXP 128
45076: PUSH
45077: LD_VAR 0 2
45081: ARRAY
45082: UNION
45083: PPUSH
45084: LD_INT 21
45086: PUSH
45087: LD_INT 1
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 1
45096: PUSH
45097: LD_INT 3
45099: PUSH
45100: LD_INT 54
45102: PUSH
45103: EMPTY
45104: LIST
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 3
45112: PUSH
45113: LD_INT 24
45115: PUSH
45116: LD_INT 1000
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: EMPTY
45128: LIST
45129: LIST
45130: LIST
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PPUSH
45136: CALL_OW 72
45140: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
45141: LD_ADDR_VAR 0 6
45145: PUSH
45146: LD_EXP 99
45150: PUSH
45151: LD_VAR 0 2
45155: ARRAY
45156: PPUSH
45157: LD_INT 21
45159: PUSH
45160: LD_INT 1
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 1
45169: PUSH
45170: LD_INT 3
45172: PUSH
45173: LD_INT 54
45175: PUSH
45176: EMPTY
45177: LIST
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: PUSH
45183: LD_INT 3
45185: PUSH
45186: LD_INT 24
45188: PUSH
45189: LD_INT 250
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: LIST
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PPUSH
45209: CALL_OW 72
45213: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
45214: LD_ADDR_VAR 0 7
45218: PUSH
45219: LD_VAR 0 5
45223: PUSH
45224: LD_VAR 0 6
45228: DIFF
45229: ST_TO_ADDR
// if not need_heal_1 then
45230: LD_VAR 0 6
45234: NOT
45235: IFFALSE 45268
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
45237: LD_ADDR_EXP 102
45241: PUSH
45242: LD_EXP 102
45246: PPUSH
45247: LD_VAR 0 2
45251: PUSH
45252: LD_INT 1
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: PPUSH
45259: EMPTY
45260: PPUSH
45261: CALL 72332 0 3
45265: ST_TO_ADDR
45266: GO 45338
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
45268: LD_ADDR_EXP 102
45272: PUSH
45273: LD_EXP 102
45277: PPUSH
45278: LD_VAR 0 2
45282: PUSH
45283: LD_INT 1
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PPUSH
45290: LD_EXP 102
45294: PUSH
45295: LD_VAR 0 2
45299: ARRAY
45300: PUSH
45301: LD_INT 1
45303: ARRAY
45304: PPUSH
45305: LD_INT 3
45307: PUSH
45308: LD_INT 24
45310: PUSH
45311: LD_INT 1000
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PPUSH
45322: CALL_OW 72
45326: PUSH
45327: LD_VAR 0 6
45331: UNION
45332: PPUSH
45333: CALL 72332 0 3
45337: ST_TO_ADDR
// if not need_heal_2 then
45338: LD_VAR 0 7
45342: NOT
45343: IFFALSE 45376
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
45345: LD_ADDR_EXP 102
45349: PUSH
45350: LD_EXP 102
45354: PPUSH
45355: LD_VAR 0 2
45359: PUSH
45360: LD_INT 2
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PPUSH
45367: EMPTY
45368: PPUSH
45369: CALL 72332 0 3
45373: ST_TO_ADDR
45374: GO 45408
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
45376: LD_ADDR_EXP 102
45380: PUSH
45381: LD_EXP 102
45385: PPUSH
45386: LD_VAR 0 2
45390: PUSH
45391: LD_INT 2
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PPUSH
45398: LD_VAR 0 7
45402: PPUSH
45403: CALL 72332 0 3
45407: ST_TO_ADDR
// if need_heal_2 then
45408: LD_VAR 0 7
45412: IFFALSE 45573
// for j in need_heal_2 do
45414: LD_ADDR_VAR 0 3
45418: PUSH
45419: LD_VAR 0 7
45423: PUSH
45424: FOR_IN
45425: IFFALSE 45571
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45427: LD_ADDR_VAR 0 5
45431: PUSH
45432: LD_EXP 99
45436: PUSH
45437: LD_VAR 0 2
45441: ARRAY
45442: PPUSH
45443: LD_INT 2
45445: PUSH
45446: LD_INT 30
45448: PUSH
45449: LD_INT 6
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 30
45458: PUSH
45459: LD_INT 7
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 30
45468: PUSH
45469: LD_INT 8
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 30
45478: PUSH
45479: LD_INT 0
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 30
45488: PUSH
45489: LD_INT 1
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: PPUSH
45504: CALL_OW 72
45508: ST_TO_ADDR
// if tmp then
45509: LD_VAR 0 5
45513: IFFALSE 45569
// begin k := NearestUnitToUnit ( tmp , j ) ;
45515: LD_ADDR_VAR 0 4
45519: PUSH
45520: LD_VAR 0 5
45524: PPUSH
45525: LD_VAR 0 3
45529: PPUSH
45530: CALL_OW 74
45534: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
45535: LD_VAR 0 3
45539: PPUSH
45540: LD_VAR 0 4
45544: PPUSH
45545: CALL_OW 296
45549: PUSH
45550: LD_INT 5
45552: GREATER
45553: IFFALSE 45569
// ComMoveToNearbyEntrance ( j , k ) ;
45555: LD_VAR 0 3
45559: PPUSH
45560: LD_VAR 0 4
45564: PPUSH
45565: CALL 105521 0 2
// end ; end ;
45569: GO 45424
45571: POP
45572: POP
// if not need_heal_1 and not need_heal_2 then
45573: LD_VAR 0 6
45577: NOT
45578: PUSH
45579: LD_VAR 0 7
45583: NOT
45584: AND
45585: IFFALSE 45589
// continue ;
45587: GO 45053
// end ;
45589: GO 45053
45591: POP
45592: POP
// RaiseSailEvent ( 102 ) ;
45593: LD_INT 102
45595: PPUSH
45596: CALL_OW 427
// end ;
45600: LD_VAR 0 1
45604: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
45605: LD_INT 0
45607: PPUSH
45608: PPUSH
45609: PPUSH
45610: PPUSH
45611: PPUSH
45612: PPUSH
45613: PPUSH
45614: PPUSH
// if not mc_bases then
45615: LD_EXP 99
45619: NOT
45620: IFFALSE 45624
// exit ;
45622: GO 46535
// for i = 1 to mc_bases do
45624: LD_ADDR_VAR 0 2
45628: PUSH
45629: DOUBLE
45630: LD_INT 1
45632: DEC
45633: ST_TO_ADDR
45634: LD_EXP 99
45638: PUSH
45639: FOR_TO
45640: IFFALSE 46533
// begin if not mc_building_need_repair [ i ] then
45642: LD_EXP 100
45646: PUSH
45647: LD_VAR 0 2
45651: ARRAY
45652: NOT
45653: IFFALSE 45838
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
45655: LD_ADDR_VAR 0 6
45659: PUSH
45660: LD_EXP 118
45664: PUSH
45665: LD_VAR 0 2
45669: ARRAY
45670: PPUSH
45671: LD_INT 3
45673: PUSH
45674: LD_INT 24
45676: PUSH
45677: LD_INT 1000
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PUSH
45688: LD_INT 2
45690: PUSH
45691: LD_INT 34
45693: PUSH
45694: LD_INT 13
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 34
45703: PUSH
45704: LD_INT 52
45706: PUSH
45707: EMPTY
45708: LIST
45709: LIST
45710: PUSH
45711: LD_INT 34
45713: PUSH
45714: LD_INT 88
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PPUSH
45731: CALL_OW 72
45735: ST_TO_ADDR
// if cranes then
45736: LD_VAR 0 6
45740: IFFALSE 45802
// for j in cranes do
45742: LD_ADDR_VAR 0 3
45746: PUSH
45747: LD_VAR 0 6
45751: PUSH
45752: FOR_IN
45753: IFFALSE 45800
// if not IsInArea ( j , mc_parking [ i ] ) then
45755: LD_VAR 0 3
45759: PPUSH
45760: LD_EXP 123
45764: PUSH
45765: LD_VAR 0 2
45769: ARRAY
45770: PPUSH
45771: CALL_OW 308
45775: NOT
45776: IFFALSE 45798
// ComMoveToArea ( j , mc_parking [ i ] ) ;
45778: LD_VAR 0 3
45782: PPUSH
45783: LD_EXP 123
45787: PUSH
45788: LD_VAR 0 2
45792: ARRAY
45793: PPUSH
45794: CALL_OW 113
45798: GO 45752
45800: POP
45801: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
45802: LD_ADDR_EXP 101
45806: PUSH
45807: LD_EXP 101
45811: PPUSH
45812: LD_VAR 0 2
45816: PPUSH
45817: EMPTY
45818: PPUSH
45819: CALL_OW 1
45823: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
45824: LD_VAR 0 2
45828: PPUSH
45829: LD_INT 101
45831: PPUSH
45832: CALL 40692 0 2
// continue ;
45836: GO 45639
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
45838: LD_ADDR_EXP 105
45842: PUSH
45843: LD_EXP 105
45847: PPUSH
45848: LD_VAR 0 2
45852: PPUSH
45853: EMPTY
45854: PPUSH
45855: CALL_OW 1
45859: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45860: LD_VAR 0 2
45864: PPUSH
45865: LD_INT 103
45867: PPUSH
45868: CALL 40692 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
45872: LD_ADDR_VAR 0 5
45876: PUSH
45877: LD_EXP 99
45881: PUSH
45882: LD_VAR 0 2
45886: ARRAY
45887: PUSH
45888: LD_EXP 128
45892: PUSH
45893: LD_VAR 0 2
45897: ARRAY
45898: UNION
45899: PPUSH
45900: LD_INT 2
45902: PUSH
45903: LD_INT 25
45905: PUSH
45906: LD_INT 2
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 25
45915: PUSH
45916: LD_INT 16
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: LIST
45927: PUSH
45928: EMPTY
45929: LIST
45930: PPUSH
45931: CALL_OW 72
45935: ST_TO_ADDR
// if mc_need_heal [ i ] then
45936: LD_EXP 102
45940: PUSH
45941: LD_VAR 0 2
45945: ARRAY
45946: IFFALSE 45990
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
45948: LD_ADDR_VAR 0 5
45952: PUSH
45953: LD_VAR 0 5
45957: PUSH
45958: LD_EXP 102
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: PUSH
45969: LD_INT 1
45971: ARRAY
45972: PUSH
45973: LD_EXP 102
45977: PUSH
45978: LD_VAR 0 2
45982: ARRAY
45983: PUSH
45984: LD_INT 2
45986: ARRAY
45987: UNION
45988: DIFF
45989: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
45990: LD_ADDR_VAR 0 6
45994: PUSH
45995: LD_EXP 118
45999: PUSH
46000: LD_VAR 0 2
46004: ARRAY
46005: PPUSH
46006: LD_INT 2
46008: PUSH
46009: LD_INT 34
46011: PUSH
46012: LD_INT 13
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 34
46021: PUSH
46022: LD_INT 52
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 34
46031: PUSH
46032: LD_INT 88
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL_OW 72
46049: ST_TO_ADDR
// if cranes then
46050: LD_VAR 0 6
46054: IFFALSE 46222
// begin for j in cranes do
46056: LD_ADDR_VAR 0 3
46060: PUSH
46061: LD_VAR 0 6
46065: PUSH
46066: FOR_IN
46067: IFFALSE 46220
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
46069: LD_VAR 0 3
46073: PPUSH
46074: CALL_OW 256
46078: PUSH
46079: LD_INT 1000
46081: EQUAL
46082: PUSH
46083: LD_VAR 0 3
46087: PPUSH
46088: CALL_OW 314
46092: NOT
46093: AND
46094: IFFALSE 46160
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
46096: LD_ADDR_VAR 0 8
46100: PUSH
46101: LD_EXP 100
46105: PUSH
46106: LD_VAR 0 2
46110: ARRAY
46111: PPUSH
46112: LD_VAR 0 3
46116: PPUSH
46117: CALL_OW 74
46121: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
46122: LD_VAR 0 8
46126: PPUSH
46127: LD_INT 16
46129: PPUSH
46130: CALL 74929 0 2
46134: PUSH
46135: LD_INT 4
46137: ARRAY
46138: PUSH
46139: LD_INT 10
46141: LESS
46142: IFFALSE 46158
// ComRepairBuilding ( j , to_repair ) ;
46144: LD_VAR 0 3
46148: PPUSH
46149: LD_VAR 0 8
46153: PPUSH
46154: CALL_OW 130
// end else
46158: GO 46218
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
46160: LD_VAR 0 3
46164: PPUSH
46165: CALL_OW 256
46169: PUSH
46170: LD_INT 500
46172: LESS
46173: PUSH
46174: LD_VAR 0 3
46178: PPUSH
46179: LD_EXP 123
46183: PUSH
46184: LD_VAR 0 2
46188: ARRAY
46189: PPUSH
46190: CALL_OW 308
46194: NOT
46195: AND
46196: IFFALSE 46218
// ComMoveToArea ( j , mc_parking [ i ] ) ;
46198: LD_VAR 0 3
46202: PPUSH
46203: LD_EXP 123
46207: PUSH
46208: LD_VAR 0 2
46212: ARRAY
46213: PPUSH
46214: CALL_OW 113
// end ;
46218: GO 46066
46220: POP
46221: POP
// end ; if tmp > 3 then
46222: LD_VAR 0 5
46226: PUSH
46227: LD_INT 3
46229: GREATER
46230: IFFALSE 46250
// tmp := ShrinkArray ( tmp , 4 ) ;
46232: LD_ADDR_VAR 0 5
46236: PUSH
46237: LD_VAR 0 5
46241: PPUSH
46242: LD_INT 4
46244: PPUSH
46245: CALL 104959 0 2
46249: ST_TO_ADDR
// if not tmp then
46250: LD_VAR 0 5
46254: NOT
46255: IFFALSE 46259
// continue ;
46257: GO 45639
// for j in tmp do
46259: LD_ADDR_VAR 0 3
46263: PUSH
46264: LD_VAR 0 5
46268: PUSH
46269: FOR_IN
46270: IFFALSE 46529
// begin if IsInUnit ( j ) then
46272: LD_VAR 0 3
46276: PPUSH
46277: CALL_OW 310
46281: IFFALSE 46292
// ComExitBuilding ( j ) ;
46283: LD_VAR 0 3
46287: PPUSH
46288: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
46292: LD_VAR 0 3
46296: PUSH
46297: LD_EXP 101
46301: PUSH
46302: LD_VAR 0 2
46306: ARRAY
46307: IN
46308: NOT
46309: IFFALSE 46367
// begin SetTag ( j , 101 ) ;
46311: LD_VAR 0 3
46315: PPUSH
46316: LD_INT 101
46318: PPUSH
46319: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
46323: LD_ADDR_EXP 101
46327: PUSH
46328: LD_EXP 101
46332: PPUSH
46333: LD_VAR 0 2
46337: PUSH
46338: LD_EXP 101
46342: PUSH
46343: LD_VAR 0 2
46347: ARRAY
46348: PUSH
46349: LD_INT 1
46351: PLUS
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PPUSH
46357: LD_VAR 0 3
46361: PPUSH
46362: CALL 72332 0 3
46366: ST_TO_ADDR
// end ; wait ( 1 ) ;
46367: LD_INT 1
46369: PPUSH
46370: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
46374: LD_ADDR_VAR 0 7
46378: PUSH
46379: LD_EXP 100
46383: PUSH
46384: LD_VAR 0 2
46388: ARRAY
46389: ST_TO_ADDR
// if mc_scan [ i ] then
46390: LD_EXP 122
46394: PUSH
46395: LD_VAR 0 2
46399: ARRAY
46400: IFFALSE 46462
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
46402: LD_ADDR_VAR 0 7
46406: PUSH
46407: LD_EXP 100
46411: PUSH
46412: LD_VAR 0 2
46416: ARRAY
46417: PPUSH
46418: LD_INT 3
46420: PUSH
46421: LD_INT 30
46423: PUSH
46424: LD_INT 32
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 30
46433: PUSH
46434: LD_INT 33
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 30
46443: PUSH
46444: LD_INT 31
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: PPUSH
46457: CALL_OW 72
46461: ST_TO_ADDR
// if not to_repair_tmp then
46462: LD_VAR 0 7
46466: NOT
46467: IFFALSE 46471
// continue ;
46469: GO 46269
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
46471: LD_ADDR_VAR 0 8
46475: PUSH
46476: LD_VAR 0 7
46480: PPUSH
46481: LD_VAR 0 3
46485: PPUSH
46486: CALL_OW 74
46490: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
46491: LD_VAR 0 8
46495: PPUSH
46496: LD_INT 16
46498: PPUSH
46499: CALL 74929 0 2
46503: PUSH
46504: LD_INT 4
46506: ARRAY
46507: PUSH
46508: LD_INT 14
46510: LESS
46511: IFFALSE 46527
// ComRepairBuilding ( j , to_repair ) ;
46513: LD_VAR 0 3
46517: PPUSH
46518: LD_VAR 0 8
46522: PPUSH
46523: CALL_OW 130
// end ;
46527: GO 46269
46529: POP
46530: POP
// end ;
46531: GO 45639
46533: POP
46534: POP
// end ;
46535: LD_VAR 0 1
46539: RET
// export function MC_Heal ; var i , j , tmp ; begin
46540: LD_INT 0
46542: PPUSH
46543: PPUSH
46544: PPUSH
46545: PPUSH
// if not mc_bases then
46546: LD_EXP 99
46550: NOT
46551: IFFALSE 46555
// exit ;
46553: GO 46957
// for i = 1 to mc_bases do
46555: LD_ADDR_VAR 0 2
46559: PUSH
46560: DOUBLE
46561: LD_INT 1
46563: DEC
46564: ST_TO_ADDR
46565: LD_EXP 99
46569: PUSH
46570: FOR_TO
46571: IFFALSE 46955
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
46573: LD_EXP 102
46577: PUSH
46578: LD_VAR 0 2
46582: ARRAY
46583: PUSH
46584: LD_INT 1
46586: ARRAY
46587: NOT
46588: PUSH
46589: LD_EXP 102
46593: PUSH
46594: LD_VAR 0 2
46598: ARRAY
46599: PUSH
46600: LD_INT 2
46602: ARRAY
46603: NOT
46604: AND
46605: IFFALSE 46643
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
46607: LD_ADDR_EXP 103
46611: PUSH
46612: LD_EXP 103
46616: PPUSH
46617: LD_VAR 0 2
46621: PPUSH
46622: EMPTY
46623: PPUSH
46624: CALL_OW 1
46628: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
46629: LD_VAR 0 2
46633: PPUSH
46634: LD_INT 102
46636: PPUSH
46637: CALL 40692 0 2
// continue ;
46641: GO 46570
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
46643: LD_ADDR_VAR 0 4
46647: PUSH
46648: LD_EXP 99
46652: PUSH
46653: LD_VAR 0 2
46657: ARRAY
46658: PPUSH
46659: LD_INT 25
46661: PUSH
46662: LD_INT 4
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PPUSH
46669: CALL_OW 72
46673: ST_TO_ADDR
// if not tmp then
46674: LD_VAR 0 4
46678: NOT
46679: IFFALSE 46683
// continue ;
46681: GO 46570
// if mc_taming [ i ] then
46683: LD_EXP 130
46687: PUSH
46688: LD_VAR 0 2
46692: ARRAY
46693: IFFALSE 46717
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
46695: LD_ADDR_EXP 130
46699: PUSH
46700: LD_EXP 130
46704: PPUSH
46705: LD_VAR 0 2
46709: PPUSH
46710: EMPTY
46711: PPUSH
46712: CALL_OW 1
46716: ST_TO_ADDR
// for j in tmp do
46717: LD_ADDR_VAR 0 3
46721: PUSH
46722: LD_VAR 0 4
46726: PUSH
46727: FOR_IN
46728: IFFALSE 46951
// begin if IsInUnit ( j ) then
46730: LD_VAR 0 3
46734: PPUSH
46735: CALL_OW 310
46739: IFFALSE 46750
// ComExitBuilding ( j ) ;
46741: LD_VAR 0 3
46745: PPUSH
46746: CALL_OW 122
// if not j in mc_healers [ i ] then
46750: LD_VAR 0 3
46754: PUSH
46755: LD_EXP 103
46759: PUSH
46760: LD_VAR 0 2
46764: ARRAY
46765: IN
46766: NOT
46767: IFFALSE 46813
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
46769: LD_ADDR_EXP 103
46773: PUSH
46774: LD_EXP 103
46778: PPUSH
46779: LD_VAR 0 2
46783: PUSH
46784: LD_EXP 103
46788: PUSH
46789: LD_VAR 0 2
46793: ARRAY
46794: PUSH
46795: LD_INT 1
46797: PLUS
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PPUSH
46803: LD_VAR 0 3
46807: PPUSH
46808: CALL 72332 0 3
46812: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
46813: LD_VAR 0 3
46817: PPUSH
46818: CALL_OW 110
46822: PUSH
46823: LD_INT 102
46825: NONEQUAL
46826: IFFALSE 46840
// SetTag ( j , 102 ) ;
46828: LD_VAR 0 3
46832: PPUSH
46833: LD_INT 102
46835: PPUSH
46836: CALL_OW 109
// Wait ( 3 ) ;
46840: LD_INT 3
46842: PPUSH
46843: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
46847: LD_EXP 102
46851: PUSH
46852: LD_VAR 0 2
46856: ARRAY
46857: PUSH
46858: LD_INT 1
46860: ARRAY
46861: IFFALSE 46893
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
46863: LD_VAR 0 3
46867: PPUSH
46868: LD_EXP 102
46872: PUSH
46873: LD_VAR 0 2
46877: ARRAY
46878: PUSH
46879: LD_INT 1
46881: ARRAY
46882: PUSH
46883: LD_INT 1
46885: ARRAY
46886: PPUSH
46887: CALL_OW 128
46891: GO 46949
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
46893: LD_VAR 0 3
46897: PPUSH
46898: CALL_OW 314
46902: NOT
46903: PUSH
46904: LD_EXP 102
46908: PUSH
46909: LD_VAR 0 2
46913: ARRAY
46914: PUSH
46915: LD_INT 2
46917: ARRAY
46918: AND
46919: IFFALSE 46949
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
46921: LD_VAR 0 3
46925: PPUSH
46926: LD_EXP 102
46930: PUSH
46931: LD_VAR 0 2
46935: ARRAY
46936: PUSH
46937: LD_INT 2
46939: ARRAY
46940: PUSH
46941: LD_INT 1
46943: ARRAY
46944: PPUSH
46945: CALL_OW 128
// end ;
46949: GO 46727
46951: POP
46952: POP
// end ;
46953: GO 46570
46955: POP
46956: POP
// end ;
46957: LD_VAR 0 1
46961: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
46962: LD_INT 0
46964: PPUSH
46965: PPUSH
46966: PPUSH
46967: PPUSH
46968: PPUSH
46969: PPUSH
// if not mc_bases then
46970: LD_EXP 99
46974: NOT
46975: IFFALSE 46979
// exit ;
46977: GO 48142
// for i = 1 to mc_bases do
46979: LD_ADDR_VAR 0 2
46983: PUSH
46984: DOUBLE
46985: LD_INT 1
46987: DEC
46988: ST_TO_ADDR
46989: LD_EXP 99
46993: PUSH
46994: FOR_TO
46995: IFFALSE 48140
// begin if mc_scan [ i ] then
46997: LD_EXP 122
47001: PUSH
47002: LD_VAR 0 2
47006: ARRAY
47007: IFFALSE 47011
// continue ;
47009: GO 46994
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
47011: LD_EXP 104
47015: PUSH
47016: LD_VAR 0 2
47020: ARRAY
47021: NOT
47022: PUSH
47023: LD_EXP 106
47027: PUSH
47028: LD_VAR 0 2
47032: ARRAY
47033: NOT
47034: AND
47035: PUSH
47036: LD_EXP 105
47040: PUSH
47041: LD_VAR 0 2
47045: ARRAY
47046: AND
47047: IFFALSE 47085
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
47049: LD_ADDR_EXP 105
47053: PUSH
47054: LD_EXP 105
47058: PPUSH
47059: LD_VAR 0 2
47063: PPUSH
47064: EMPTY
47065: PPUSH
47066: CALL_OW 1
47070: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47071: LD_VAR 0 2
47075: PPUSH
47076: LD_INT 103
47078: PPUSH
47079: CALL 40692 0 2
// continue ;
47083: GO 46994
// end ; if mc_construct_list [ i ] then
47085: LD_EXP 106
47089: PUSH
47090: LD_VAR 0 2
47094: ARRAY
47095: IFFALSE 47315
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47097: LD_ADDR_VAR 0 5
47101: PUSH
47102: LD_EXP 99
47106: PUSH
47107: LD_VAR 0 2
47111: ARRAY
47112: PPUSH
47113: LD_INT 25
47115: PUSH
47116: LD_INT 2
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PPUSH
47123: CALL_OW 72
47127: PUSH
47128: LD_EXP 101
47132: PUSH
47133: LD_VAR 0 2
47137: ARRAY
47138: DIFF
47139: ST_TO_ADDR
// if not tmp then
47140: LD_VAR 0 5
47144: NOT
47145: IFFALSE 47149
// continue ;
47147: GO 46994
// for j in tmp do
47149: LD_ADDR_VAR 0 3
47153: PUSH
47154: LD_VAR 0 5
47158: PUSH
47159: FOR_IN
47160: IFFALSE 47311
// begin if not mc_builders [ i ] then
47162: LD_EXP 105
47166: PUSH
47167: LD_VAR 0 2
47171: ARRAY
47172: NOT
47173: IFFALSE 47231
// begin SetTag ( j , 103 ) ;
47175: LD_VAR 0 3
47179: PPUSH
47180: LD_INT 103
47182: PPUSH
47183: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47187: LD_ADDR_EXP 105
47191: PUSH
47192: LD_EXP 105
47196: PPUSH
47197: LD_VAR 0 2
47201: PUSH
47202: LD_EXP 105
47206: PUSH
47207: LD_VAR 0 2
47211: ARRAY
47212: PUSH
47213: LD_INT 1
47215: PLUS
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PPUSH
47221: LD_VAR 0 3
47225: PPUSH
47226: CALL 72332 0 3
47230: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47231: LD_VAR 0 3
47235: PPUSH
47236: CALL_OW 310
47240: IFFALSE 47251
// ComExitBuilding ( j ) ;
47242: LD_VAR 0 3
47246: PPUSH
47247: CALL_OW 122
// wait ( 3 ) ;
47251: LD_INT 3
47253: PPUSH
47254: CALL_OW 67
// if not mc_construct_list [ i ] then
47258: LD_EXP 106
47262: PUSH
47263: LD_VAR 0 2
47267: ARRAY
47268: NOT
47269: IFFALSE 47273
// break ;
47271: GO 47311
// if not HasTask ( j ) then
47273: LD_VAR 0 3
47277: PPUSH
47278: CALL_OW 314
47282: NOT
47283: IFFALSE 47309
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
47285: LD_VAR 0 3
47289: PPUSH
47290: LD_EXP 106
47294: PUSH
47295: LD_VAR 0 2
47299: ARRAY
47300: PUSH
47301: LD_INT 1
47303: ARRAY
47304: PPUSH
47305: CALL 75193 0 2
// end ;
47309: GO 47159
47311: POP
47312: POP
// end else
47313: GO 48138
// if mc_build_list [ i ] then
47315: LD_EXP 104
47319: PUSH
47320: LD_VAR 0 2
47324: ARRAY
47325: IFFALSE 48138
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
47327: LD_EXP 104
47331: PUSH
47332: LD_VAR 0 2
47336: ARRAY
47337: PUSH
47338: LD_INT 1
47340: ARRAY
47341: PUSH
47342: LD_INT 1
47344: ARRAY
47345: PPUSH
47346: CALL 75017 0 1
47350: PUSH
47351: LD_EXP 99
47355: PUSH
47356: LD_VAR 0 2
47360: ARRAY
47361: PPUSH
47362: LD_INT 2
47364: PUSH
47365: LD_INT 30
47367: PUSH
47368: LD_INT 2
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: LD_INT 30
47377: PUSH
47378: LD_INT 3
47380: PUSH
47381: EMPTY
47382: LIST
47383: LIST
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: LIST
47389: PPUSH
47390: CALL_OW 72
47394: NOT
47395: AND
47396: IFFALSE 47501
// begin for j = 1 to mc_build_list [ i ] do
47398: LD_ADDR_VAR 0 3
47402: PUSH
47403: DOUBLE
47404: LD_INT 1
47406: DEC
47407: ST_TO_ADDR
47408: LD_EXP 104
47412: PUSH
47413: LD_VAR 0 2
47417: ARRAY
47418: PUSH
47419: FOR_TO
47420: IFFALSE 47499
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
47422: LD_EXP 104
47426: PUSH
47427: LD_VAR 0 2
47431: ARRAY
47432: PUSH
47433: LD_VAR 0 3
47437: ARRAY
47438: PUSH
47439: LD_INT 1
47441: ARRAY
47442: PUSH
47443: LD_INT 2
47445: EQUAL
47446: IFFALSE 47497
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
47448: LD_ADDR_EXP 104
47452: PUSH
47453: LD_EXP 104
47457: PPUSH
47458: LD_VAR 0 2
47462: PPUSH
47463: LD_EXP 104
47467: PUSH
47468: LD_VAR 0 2
47472: ARRAY
47473: PPUSH
47474: LD_VAR 0 3
47478: PPUSH
47479: LD_INT 1
47481: PPUSH
47482: LD_INT 0
47484: PPUSH
47485: CALL 71750 0 4
47489: PPUSH
47490: CALL_OW 1
47494: ST_TO_ADDR
// break ;
47495: GO 47499
// end ;
47497: GO 47419
47499: POP
47500: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47501: LD_ADDR_VAR 0 6
47505: PUSH
47506: LD_EXP 99
47510: PUSH
47511: LD_VAR 0 2
47515: ARRAY
47516: PPUSH
47517: LD_INT 2
47519: PUSH
47520: LD_INT 30
47522: PUSH
47523: LD_INT 0
47525: PUSH
47526: EMPTY
47527: LIST
47528: LIST
47529: PUSH
47530: LD_INT 30
47532: PUSH
47533: LD_INT 1
47535: PUSH
47536: EMPTY
47537: LIST
47538: LIST
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: LIST
47544: PPUSH
47545: CALL_OW 72
47549: ST_TO_ADDR
// for k := 1 to depot do
47550: LD_ADDR_VAR 0 4
47554: PUSH
47555: DOUBLE
47556: LD_INT 1
47558: DEC
47559: ST_TO_ADDR
47560: LD_VAR 0 6
47564: PUSH
47565: FOR_TO
47566: IFFALSE 48136
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
47568: LD_EXP 104
47572: PUSH
47573: LD_VAR 0 2
47577: ARRAY
47578: PUSH
47579: LD_INT 1
47581: ARRAY
47582: PUSH
47583: LD_INT 1
47585: ARRAY
47586: PUSH
47587: LD_INT 0
47589: EQUAL
47590: PUSH
47591: LD_VAR 0 6
47595: PUSH
47596: LD_VAR 0 4
47600: ARRAY
47601: PPUSH
47602: LD_EXP 104
47606: PUSH
47607: LD_VAR 0 2
47611: ARRAY
47612: PUSH
47613: LD_INT 1
47615: ARRAY
47616: PUSH
47617: LD_INT 1
47619: ARRAY
47620: PPUSH
47621: LD_EXP 104
47625: PUSH
47626: LD_VAR 0 2
47630: ARRAY
47631: PUSH
47632: LD_INT 1
47634: ARRAY
47635: PUSH
47636: LD_INT 2
47638: ARRAY
47639: PPUSH
47640: LD_EXP 104
47644: PUSH
47645: LD_VAR 0 2
47649: ARRAY
47650: PUSH
47651: LD_INT 1
47653: ARRAY
47654: PUSH
47655: LD_INT 3
47657: ARRAY
47658: PPUSH
47659: LD_EXP 104
47663: PUSH
47664: LD_VAR 0 2
47668: ARRAY
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: PUSH
47674: LD_INT 4
47676: ARRAY
47677: PPUSH
47678: CALL 80429 0 5
47682: OR
47683: IFFALSE 47964
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
47685: LD_ADDR_VAR 0 5
47689: PUSH
47690: LD_EXP 99
47694: PUSH
47695: LD_VAR 0 2
47699: ARRAY
47700: PPUSH
47701: LD_INT 25
47703: PUSH
47704: LD_INT 2
47706: PUSH
47707: EMPTY
47708: LIST
47709: LIST
47710: PPUSH
47711: CALL_OW 72
47715: PUSH
47716: LD_EXP 101
47720: PUSH
47721: LD_VAR 0 2
47725: ARRAY
47726: DIFF
47727: ST_TO_ADDR
// if not tmp then
47728: LD_VAR 0 5
47732: NOT
47733: IFFALSE 47737
// continue ;
47735: GO 47565
// for j in tmp do
47737: LD_ADDR_VAR 0 3
47741: PUSH
47742: LD_VAR 0 5
47746: PUSH
47747: FOR_IN
47748: IFFALSE 47960
// begin if not mc_builders [ i ] then
47750: LD_EXP 105
47754: PUSH
47755: LD_VAR 0 2
47759: ARRAY
47760: NOT
47761: IFFALSE 47819
// begin SetTag ( j , 103 ) ;
47763: LD_VAR 0 3
47767: PPUSH
47768: LD_INT 103
47770: PPUSH
47771: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
47775: LD_ADDR_EXP 105
47779: PUSH
47780: LD_EXP 105
47784: PPUSH
47785: LD_VAR 0 2
47789: PUSH
47790: LD_EXP 105
47794: PUSH
47795: LD_VAR 0 2
47799: ARRAY
47800: PUSH
47801: LD_INT 1
47803: PLUS
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PPUSH
47809: LD_VAR 0 3
47813: PPUSH
47814: CALL 72332 0 3
47818: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
47819: LD_VAR 0 3
47823: PPUSH
47824: CALL_OW 310
47828: IFFALSE 47839
// ComExitBuilding ( j ) ;
47830: LD_VAR 0 3
47834: PPUSH
47835: CALL_OW 122
// wait ( 3 ) ;
47839: LD_INT 3
47841: PPUSH
47842: CALL_OW 67
// if not mc_build_list [ i ] then
47846: LD_EXP 104
47850: PUSH
47851: LD_VAR 0 2
47855: ARRAY
47856: NOT
47857: IFFALSE 47861
// break ;
47859: GO 47960
// if not HasTask ( j ) then
47861: LD_VAR 0 3
47865: PPUSH
47866: CALL_OW 314
47870: NOT
47871: IFFALSE 47958
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
47873: LD_VAR 0 3
47877: PPUSH
47878: LD_EXP 104
47882: PUSH
47883: LD_VAR 0 2
47887: ARRAY
47888: PUSH
47889: LD_INT 1
47891: ARRAY
47892: PUSH
47893: LD_INT 1
47895: ARRAY
47896: PPUSH
47897: LD_EXP 104
47901: PUSH
47902: LD_VAR 0 2
47906: ARRAY
47907: PUSH
47908: LD_INT 1
47910: ARRAY
47911: PUSH
47912: LD_INT 2
47914: ARRAY
47915: PPUSH
47916: LD_EXP 104
47920: PUSH
47921: LD_VAR 0 2
47925: ARRAY
47926: PUSH
47927: LD_INT 1
47929: ARRAY
47930: PUSH
47931: LD_INT 3
47933: ARRAY
47934: PPUSH
47935: LD_EXP 104
47939: PUSH
47940: LD_VAR 0 2
47944: ARRAY
47945: PUSH
47946: LD_INT 1
47948: ARRAY
47949: PUSH
47950: LD_INT 4
47952: ARRAY
47953: PPUSH
47954: CALL_OW 145
// end ;
47958: GO 47747
47960: POP
47961: POP
// end else
47962: GO 48134
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
47964: LD_EXP 99
47968: PUSH
47969: LD_VAR 0 2
47973: ARRAY
47974: PPUSH
47975: LD_EXP 104
47979: PUSH
47980: LD_VAR 0 2
47984: ARRAY
47985: PUSH
47986: LD_INT 1
47988: ARRAY
47989: PUSH
47990: LD_INT 1
47992: ARRAY
47993: PPUSH
47994: LD_EXP 104
47998: PUSH
47999: LD_VAR 0 2
48003: ARRAY
48004: PUSH
48005: LD_INT 1
48007: ARRAY
48008: PUSH
48009: LD_INT 2
48011: ARRAY
48012: PPUSH
48013: LD_EXP 104
48017: PUSH
48018: LD_VAR 0 2
48022: ARRAY
48023: PUSH
48024: LD_INT 1
48026: ARRAY
48027: PUSH
48028: LD_INT 3
48030: ARRAY
48031: PPUSH
48032: LD_EXP 104
48036: PUSH
48037: LD_VAR 0 2
48041: ARRAY
48042: PUSH
48043: LD_INT 1
48045: ARRAY
48046: PUSH
48047: LD_INT 4
48049: ARRAY
48050: PPUSH
48051: LD_EXP 99
48055: PUSH
48056: LD_VAR 0 2
48060: ARRAY
48061: PPUSH
48062: LD_INT 21
48064: PUSH
48065: LD_INT 3
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PPUSH
48072: CALL_OW 72
48076: PPUSH
48077: EMPTY
48078: PPUSH
48079: CALL 79183 0 7
48083: NOT
48084: IFFALSE 48134
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
48086: LD_ADDR_EXP 104
48090: PUSH
48091: LD_EXP 104
48095: PPUSH
48096: LD_VAR 0 2
48100: PPUSH
48101: LD_EXP 104
48105: PUSH
48106: LD_VAR 0 2
48110: ARRAY
48111: PPUSH
48112: LD_INT 1
48114: PPUSH
48115: LD_INT 1
48117: NEG
48118: PPUSH
48119: LD_INT 0
48121: PPUSH
48122: CALL 71750 0 4
48126: PPUSH
48127: CALL_OW 1
48131: ST_TO_ADDR
// continue ;
48132: GO 47565
// end ; end ;
48134: GO 47565
48136: POP
48137: POP
// end ; end ;
48138: GO 46994
48140: POP
48141: POP
// end ;
48142: LD_VAR 0 1
48146: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
48147: LD_INT 0
48149: PPUSH
48150: PPUSH
48151: PPUSH
48152: PPUSH
48153: PPUSH
48154: PPUSH
// if not mc_bases then
48155: LD_EXP 99
48159: NOT
48160: IFFALSE 48164
// exit ;
48162: GO 48591
// for i = 1 to mc_bases do
48164: LD_ADDR_VAR 0 2
48168: PUSH
48169: DOUBLE
48170: LD_INT 1
48172: DEC
48173: ST_TO_ADDR
48174: LD_EXP 99
48178: PUSH
48179: FOR_TO
48180: IFFALSE 48589
// begin tmp := mc_build_upgrade [ i ] ;
48182: LD_ADDR_VAR 0 4
48186: PUSH
48187: LD_EXP 131
48191: PUSH
48192: LD_VAR 0 2
48196: ARRAY
48197: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
48198: LD_ADDR_VAR 0 6
48202: PUSH
48203: LD_EXP 132
48207: PUSH
48208: LD_VAR 0 2
48212: ARRAY
48213: PPUSH
48214: LD_INT 2
48216: PUSH
48217: LD_INT 30
48219: PUSH
48220: LD_INT 6
48222: PUSH
48223: EMPTY
48224: LIST
48225: LIST
48226: PUSH
48227: LD_INT 30
48229: PUSH
48230: LD_INT 7
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: LIST
48241: PPUSH
48242: CALL_OW 72
48246: ST_TO_ADDR
// if not tmp and not lab then
48247: LD_VAR 0 4
48251: NOT
48252: PUSH
48253: LD_VAR 0 6
48257: NOT
48258: AND
48259: IFFALSE 48263
// continue ;
48261: GO 48179
// if tmp then
48263: LD_VAR 0 4
48267: IFFALSE 48387
// for j in tmp do
48269: LD_ADDR_VAR 0 3
48273: PUSH
48274: LD_VAR 0 4
48278: PUSH
48279: FOR_IN
48280: IFFALSE 48385
// begin if UpgradeCost ( j ) then
48282: LD_VAR 0 3
48286: PPUSH
48287: CALL 78843 0 1
48291: IFFALSE 48383
// begin ComUpgrade ( j ) ;
48293: LD_VAR 0 3
48297: PPUSH
48298: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
48302: LD_ADDR_EXP 131
48306: PUSH
48307: LD_EXP 131
48311: PPUSH
48312: LD_VAR 0 2
48316: PPUSH
48317: LD_EXP 131
48321: PUSH
48322: LD_VAR 0 2
48326: ARRAY
48327: PUSH
48328: LD_VAR 0 3
48332: DIFF
48333: PPUSH
48334: CALL_OW 1
48338: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48339: LD_ADDR_EXP 106
48343: PUSH
48344: LD_EXP 106
48348: PPUSH
48349: LD_VAR 0 2
48353: PUSH
48354: LD_EXP 106
48358: PUSH
48359: LD_VAR 0 2
48363: ARRAY
48364: PUSH
48365: LD_INT 1
48367: PLUS
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PPUSH
48373: LD_VAR 0 3
48377: PPUSH
48378: CALL 72332 0 3
48382: ST_TO_ADDR
// end ; end ;
48383: GO 48279
48385: POP
48386: POP
// if not lab or not mc_lab_upgrade [ i ] then
48387: LD_VAR 0 6
48391: NOT
48392: PUSH
48393: LD_EXP 133
48397: PUSH
48398: LD_VAR 0 2
48402: ARRAY
48403: NOT
48404: OR
48405: IFFALSE 48409
// continue ;
48407: GO 48179
// for j in lab do
48409: LD_ADDR_VAR 0 3
48413: PUSH
48414: LD_VAR 0 6
48418: PUSH
48419: FOR_IN
48420: IFFALSE 48585
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
48422: LD_VAR 0 3
48426: PPUSH
48427: CALL_OW 266
48431: PUSH
48432: LD_INT 6
48434: PUSH
48435: LD_INT 7
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: IN
48442: PUSH
48443: LD_VAR 0 3
48447: PPUSH
48448: CALL_OW 461
48452: PUSH
48453: LD_INT 1
48455: NONEQUAL
48456: AND
48457: IFFALSE 48583
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
48459: LD_VAR 0 3
48463: PPUSH
48464: LD_EXP 133
48468: PUSH
48469: LD_VAR 0 2
48473: ARRAY
48474: PUSH
48475: LD_INT 1
48477: ARRAY
48478: PPUSH
48479: CALL 79048 0 2
48483: IFFALSE 48583
// begin ComCancel ( j ) ;
48485: LD_VAR 0 3
48489: PPUSH
48490: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
48494: LD_VAR 0 3
48498: PPUSH
48499: LD_EXP 133
48503: PUSH
48504: LD_VAR 0 2
48508: ARRAY
48509: PUSH
48510: LD_INT 1
48512: ARRAY
48513: PPUSH
48514: CALL_OW 207
// if not j in mc_construct_list [ i ] then
48518: LD_VAR 0 3
48522: PUSH
48523: LD_EXP 106
48527: PUSH
48528: LD_VAR 0 2
48532: ARRAY
48533: IN
48534: NOT
48535: IFFALSE 48581
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
48537: LD_ADDR_EXP 106
48541: PUSH
48542: LD_EXP 106
48546: PPUSH
48547: LD_VAR 0 2
48551: PUSH
48552: LD_EXP 106
48556: PUSH
48557: LD_VAR 0 2
48561: ARRAY
48562: PUSH
48563: LD_INT 1
48565: PLUS
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: PPUSH
48571: LD_VAR 0 3
48575: PPUSH
48576: CALL 72332 0 3
48580: ST_TO_ADDR
// break ;
48581: GO 48585
// end ; end ; end ;
48583: GO 48419
48585: POP
48586: POP
// end ;
48587: GO 48179
48589: POP
48590: POP
// end ;
48591: LD_VAR 0 1
48595: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
48596: LD_INT 0
48598: PPUSH
48599: PPUSH
48600: PPUSH
48601: PPUSH
48602: PPUSH
48603: PPUSH
48604: PPUSH
48605: PPUSH
48606: PPUSH
// if not mc_bases then
48607: LD_EXP 99
48611: NOT
48612: IFFALSE 48616
// exit ;
48614: GO 49021
// for i = 1 to mc_bases do
48616: LD_ADDR_VAR 0 2
48620: PUSH
48621: DOUBLE
48622: LD_INT 1
48624: DEC
48625: ST_TO_ADDR
48626: LD_EXP 99
48630: PUSH
48631: FOR_TO
48632: IFFALSE 49019
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
48634: LD_EXP 107
48638: PUSH
48639: LD_VAR 0 2
48643: ARRAY
48644: NOT
48645: PUSH
48646: LD_EXP 99
48650: PUSH
48651: LD_VAR 0 2
48655: ARRAY
48656: PPUSH
48657: LD_INT 30
48659: PUSH
48660: LD_INT 3
48662: PUSH
48663: EMPTY
48664: LIST
48665: LIST
48666: PPUSH
48667: CALL_OW 72
48671: NOT
48672: OR
48673: IFFALSE 48677
// continue ;
48675: GO 48631
// busy := false ;
48677: LD_ADDR_VAR 0 8
48681: PUSH
48682: LD_INT 0
48684: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48685: LD_ADDR_VAR 0 4
48689: PUSH
48690: LD_EXP 99
48694: PUSH
48695: LD_VAR 0 2
48699: ARRAY
48700: PPUSH
48701: LD_INT 30
48703: PUSH
48704: LD_INT 3
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PPUSH
48711: CALL_OW 72
48715: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
48716: LD_ADDR_VAR 0 6
48720: PUSH
48721: LD_EXP 107
48725: PUSH
48726: LD_VAR 0 2
48730: ARRAY
48731: PPUSH
48732: LD_INT 2
48734: PUSH
48735: LD_INT 30
48737: PUSH
48738: LD_INT 32
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PUSH
48745: LD_INT 30
48747: PUSH
48748: LD_INT 33
48750: PUSH
48751: EMPTY
48752: LIST
48753: LIST
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: LIST
48759: PPUSH
48760: CALL_OW 72
48764: ST_TO_ADDR
// if not t then
48765: LD_VAR 0 6
48769: NOT
48770: IFFALSE 48774
// continue ;
48772: GO 48631
// for j in tmp do
48774: LD_ADDR_VAR 0 3
48778: PUSH
48779: LD_VAR 0 4
48783: PUSH
48784: FOR_IN
48785: IFFALSE 48815
// if not BuildingStatus ( j ) = bs_idle then
48787: LD_VAR 0 3
48791: PPUSH
48792: CALL_OW 461
48796: PUSH
48797: LD_INT 2
48799: EQUAL
48800: NOT
48801: IFFALSE 48813
// begin busy := true ;
48803: LD_ADDR_VAR 0 8
48807: PUSH
48808: LD_INT 1
48810: ST_TO_ADDR
// break ;
48811: GO 48815
// end ;
48813: GO 48784
48815: POP
48816: POP
// if busy then
48817: LD_VAR 0 8
48821: IFFALSE 48825
// continue ;
48823: GO 48631
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
48825: LD_ADDR_VAR 0 7
48829: PUSH
48830: LD_VAR 0 6
48834: PPUSH
48835: LD_INT 35
48837: PUSH
48838: LD_INT 0
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PPUSH
48845: CALL_OW 72
48849: ST_TO_ADDR
// if tw then
48850: LD_VAR 0 7
48854: IFFALSE 48931
// begin tw := tw [ 1 ] ;
48856: LD_ADDR_VAR 0 7
48860: PUSH
48861: LD_VAR 0 7
48865: PUSH
48866: LD_INT 1
48868: ARRAY
48869: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
48870: LD_ADDR_VAR 0 9
48874: PUSH
48875: LD_VAR 0 7
48879: PPUSH
48880: LD_EXP 124
48884: PUSH
48885: LD_VAR 0 2
48889: ARRAY
48890: PPUSH
48891: CALL 77340 0 2
48895: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
48896: LD_EXP 138
48900: PUSH
48901: LD_VAR 0 2
48905: ARRAY
48906: IFFALSE 48929
// if not weapon in mc_allowed_tower_weapons [ i ] then
48908: LD_VAR 0 9
48912: PUSH
48913: LD_EXP 138
48917: PUSH
48918: LD_VAR 0 2
48922: ARRAY
48923: IN
48924: NOT
48925: IFFALSE 48929
// continue ;
48927: GO 48631
// end else
48929: GO 48994
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
48931: LD_ADDR_VAR 0 5
48935: PUSH
48936: LD_EXP 107
48940: PUSH
48941: LD_VAR 0 2
48945: ARRAY
48946: PPUSH
48947: LD_VAR 0 4
48951: PPUSH
48952: CALL 104192 0 2
48956: ST_TO_ADDR
// if not tmp2 then
48957: LD_VAR 0 5
48961: NOT
48962: IFFALSE 48966
// continue ;
48964: GO 48631
// tw := tmp2 [ 1 ] ;
48966: LD_ADDR_VAR 0 7
48970: PUSH
48971: LD_VAR 0 5
48975: PUSH
48976: LD_INT 1
48978: ARRAY
48979: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
48980: LD_ADDR_VAR 0 9
48984: PUSH
48985: LD_VAR 0 5
48989: PUSH
48990: LD_INT 2
48992: ARRAY
48993: ST_TO_ADDR
// end ; if not weapon then
48994: LD_VAR 0 9
48998: NOT
48999: IFFALSE 49003
// continue ;
49001: GO 48631
// ComPlaceWeapon ( tw , weapon ) ;
49003: LD_VAR 0 7
49007: PPUSH
49008: LD_VAR 0 9
49012: PPUSH
49013: CALL_OW 148
// end ;
49017: GO 48631
49019: POP
49020: POP
// end ;
49021: LD_VAR 0 1
49025: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
49026: LD_INT 0
49028: PPUSH
49029: PPUSH
49030: PPUSH
49031: PPUSH
49032: PPUSH
49033: PPUSH
49034: PPUSH
// if not mc_bases then
49035: LD_EXP 99
49039: NOT
49040: IFFALSE 49044
// exit ;
49042: GO 49812
// for i = 1 to mc_bases do
49044: LD_ADDR_VAR 0 2
49048: PUSH
49049: DOUBLE
49050: LD_INT 1
49052: DEC
49053: ST_TO_ADDR
49054: LD_EXP 99
49058: PUSH
49059: FOR_TO
49060: IFFALSE 49810
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
49062: LD_EXP 112
49066: PUSH
49067: LD_VAR 0 2
49071: ARRAY
49072: NOT
49073: PUSH
49074: LD_EXP 112
49078: PUSH
49079: LD_VAR 0 2
49083: ARRAY
49084: PUSH
49085: LD_EXP 113
49089: PUSH
49090: LD_VAR 0 2
49094: ARRAY
49095: EQUAL
49096: OR
49097: PUSH
49098: LD_EXP 122
49102: PUSH
49103: LD_VAR 0 2
49107: ARRAY
49108: OR
49109: IFFALSE 49113
// continue ;
49111: GO 49059
// if mc_miners [ i ] then
49113: LD_EXP 113
49117: PUSH
49118: LD_VAR 0 2
49122: ARRAY
49123: IFFALSE 49497
// begin for j = mc_miners [ i ] downto 1 do
49125: LD_ADDR_VAR 0 3
49129: PUSH
49130: DOUBLE
49131: LD_EXP 113
49135: PUSH
49136: LD_VAR 0 2
49140: ARRAY
49141: INC
49142: ST_TO_ADDR
49143: LD_INT 1
49145: PUSH
49146: FOR_DOWNTO
49147: IFFALSE 49495
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
49149: LD_EXP 113
49153: PUSH
49154: LD_VAR 0 2
49158: ARRAY
49159: PUSH
49160: LD_VAR 0 3
49164: ARRAY
49165: PPUSH
49166: CALL_OW 301
49170: PUSH
49171: LD_EXP 113
49175: PUSH
49176: LD_VAR 0 2
49180: ARRAY
49181: PUSH
49182: LD_VAR 0 3
49186: ARRAY
49187: PPUSH
49188: CALL_OW 257
49192: PUSH
49193: LD_INT 1
49195: NONEQUAL
49196: OR
49197: IFFALSE 49260
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
49199: LD_ADDR_VAR 0 5
49203: PUSH
49204: LD_EXP 113
49208: PUSH
49209: LD_VAR 0 2
49213: ARRAY
49214: PUSH
49215: LD_EXP 113
49219: PUSH
49220: LD_VAR 0 2
49224: ARRAY
49225: PUSH
49226: LD_VAR 0 3
49230: ARRAY
49231: DIFF
49232: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
49233: LD_ADDR_EXP 113
49237: PUSH
49238: LD_EXP 113
49242: PPUSH
49243: LD_VAR 0 2
49247: PPUSH
49248: LD_VAR 0 5
49252: PPUSH
49253: CALL_OW 1
49257: ST_TO_ADDR
// continue ;
49258: GO 49146
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
49260: LD_EXP 113
49264: PUSH
49265: LD_VAR 0 2
49269: ARRAY
49270: PUSH
49271: LD_VAR 0 3
49275: ARRAY
49276: PPUSH
49277: CALL_OW 257
49281: PUSH
49282: LD_INT 1
49284: EQUAL
49285: PUSH
49286: LD_EXP 113
49290: PUSH
49291: LD_VAR 0 2
49295: ARRAY
49296: PUSH
49297: LD_VAR 0 3
49301: ARRAY
49302: PPUSH
49303: CALL_OW 459
49307: NOT
49308: AND
49309: PUSH
49310: LD_EXP 113
49314: PUSH
49315: LD_VAR 0 2
49319: ARRAY
49320: PUSH
49321: LD_VAR 0 3
49325: ARRAY
49326: PPUSH
49327: CALL_OW 314
49331: NOT
49332: AND
49333: IFFALSE 49493
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
49335: LD_EXP 113
49339: PUSH
49340: LD_VAR 0 2
49344: ARRAY
49345: PUSH
49346: LD_VAR 0 3
49350: ARRAY
49351: PPUSH
49352: CALL_OW 310
49356: IFFALSE 49379
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
49358: LD_EXP 113
49362: PUSH
49363: LD_VAR 0 2
49367: ARRAY
49368: PUSH
49369: LD_VAR 0 3
49373: ARRAY
49374: PPUSH
49375: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
49379: LD_EXP 113
49383: PUSH
49384: LD_VAR 0 2
49388: ARRAY
49389: PUSH
49390: LD_VAR 0 3
49394: ARRAY
49395: PPUSH
49396: CALL_OW 314
49400: NOT
49401: IFFALSE 49493
// begin r := rand ( 1 , mc_mines [ i ] ) ;
49403: LD_ADDR_VAR 0 7
49407: PUSH
49408: LD_INT 1
49410: PPUSH
49411: LD_EXP 112
49415: PUSH
49416: LD_VAR 0 2
49420: ARRAY
49421: PPUSH
49422: CALL_OW 12
49426: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
49427: LD_EXP 113
49431: PUSH
49432: LD_VAR 0 2
49436: ARRAY
49437: PUSH
49438: LD_VAR 0 3
49442: ARRAY
49443: PPUSH
49444: LD_EXP 112
49448: PUSH
49449: LD_VAR 0 2
49453: ARRAY
49454: PUSH
49455: LD_VAR 0 7
49459: ARRAY
49460: PUSH
49461: LD_INT 1
49463: ARRAY
49464: PPUSH
49465: LD_EXP 112
49469: PUSH
49470: LD_VAR 0 2
49474: ARRAY
49475: PUSH
49476: LD_VAR 0 7
49480: ARRAY
49481: PUSH
49482: LD_INT 2
49484: ARRAY
49485: PPUSH
49486: LD_INT 0
49488: PPUSH
49489: CALL_OW 193
// end ; end ; end ;
49493: GO 49146
49495: POP
49496: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
49497: LD_ADDR_VAR 0 5
49501: PUSH
49502: LD_EXP 99
49506: PUSH
49507: LD_VAR 0 2
49511: ARRAY
49512: PPUSH
49513: LD_INT 2
49515: PUSH
49516: LD_INT 30
49518: PUSH
49519: LD_INT 4
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 30
49528: PUSH
49529: LD_INT 5
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PUSH
49536: LD_INT 30
49538: PUSH
49539: LD_INT 32
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: PPUSH
49552: CALL_OW 72
49556: ST_TO_ADDR
// if not tmp then
49557: LD_VAR 0 5
49561: NOT
49562: IFFALSE 49566
// continue ;
49564: GO 49059
// list := [ ] ;
49566: LD_ADDR_VAR 0 6
49570: PUSH
49571: EMPTY
49572: ST_TO_ADDR
// for j in tmp do
49573: LD_ADDR_VAR 0 3
49577: PUSH
49578: LD_VAR 0 5
49582: PUSH
49583: FOR_IN
49584: IFFALSE 49653
// begin for k in UnitsInside ( j ) do
49586: LD_ADDR_VAR 0 4
49590: PUSH
49591: LD_VAR 0 3
49595: PPUSH
49596: CALL_OW 313
49600: PUSH
49601: FOR_IN
49602: IFFALSE 49649
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
49604: LD_VAR 0 4
49608: PPUSH
49609: CALL_OW 257
49613: PUSH
49614: LD_INT 1
49616: EQUAL
49617: PUSH
49618: LD_VAR 0 4
49622: PPUSH
49623: CALL_OW 459
49627: NOT
49628: AND
49629: IFFALSE 49647
// list := list ^ k ;
49631: LD_ADDR_VAR 0 6
49635: PUSH
49636: LD_VAR 0 6
49640: PUSH
49641: LD_VAR 0 4
49645: ADD
49646: ST_TO_ADDR
49647: GO 49601
49649: POP
49650: POP
// end ;
49651: GO 49583
49653: POP
49654: POP
// list := list diff mc_miners [ i ] ;
49655: LD_ADDR_VAR 0 6
49659: PUSH
49660: LD_VAR 0 6
49664: PUSH
49665: LD_EXP 113
49669: PUSH
49670: LD_VAR 0 2
49674: ARRAY
49675: DIFF
49676: ST_TO_ADDR
// if not list then
49677: LD_VAR 0 6
49681: NOT
49682: IFFALSE 49686
// continue ;
49684: GO 49059
// k := mc_mines [ i ] - mc_miners [ i ] ;
49686: LD_ADDR_VAR 0 4
49690: PUSH
49691: LD_EXP 112
49695: PUSH
49696: LD_VAR 0 2
49700: ARRAY
49701: PUSH
49702: LD_EXP 113
49706: PUSH
49707: LD_VAR 0 2
49711: ARRAY
49712: MINUS
49713: ST_TO_ADDR
// if k > list then
49714: LD_VAR 0 4
49718: PUSH
49719: LD_VAR 0 6
49723: GREATER
49724: IFFALSE 49736
// k := list ;
49726: LD_ADDR_VAR 0 4
49730: PUSH
49731: LD_VAR 0 6
49735: ST_TO_ADDR
// for j = 1 to k do
49736: LD_ADDR_VAR 0 3
49740: PUSH
49741: DOUBLE
49742: LD_INT 1
49744: DEC
49745: ST_TO_ADDR
49746: LD_VAR 0 4
49750: PUSH
49751: FOR_TO
49752: IFFALSE 49806
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
49754: LD_ADDR_EXP 113
49758: PUSH
49759: LD_EXP 113
49763: PPUSH
49764: LD_VAR 0 2
49768: PUSH
49769: LD_EXP 113
49773: PUSH
49774: LD_VAR 0 2
49778: ARRAY
49779: PUSH
49780: LD_INT 1
49782: PLUS
49783: PUSH
49784: EMPTY
49785: LIST
49786: LIST
49787: PPUSH
49788: LD_VAR 0 6
49792: PUSH
49793: LD_VAR 0 3
49797: ARRAY
49798: PPUSH
49799: CALL 72332 0 3
49803: ST_TO_ADDR
49804: GO 49751
49806: POP
49807: POP
// end ;
49808: GO 49059
49810: POP
49811: POP
// end ;
49812: LD_VAR 0 1
49816: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
49817: LD_INT 0
49819: PPUSH
49820: PPUSH
49821: PPUSH
49822: PPUSH
49823: PPUSH
49824: PPUSH
49825: PPUSH
49826: PPUSH
49827: PPUSH
49828: PPUSH
49829: PPUSH
// if not mc_bases then
49830: LD_EXP 99
49834: NOT
49835: IFFALSE 49839
// exit ;
49837: GO 51662
// for i = 1 to mc_bases do
49839: LD_ADDR_VAR 0 2
49843: PUSH
49844: DOUBLE
49845: LD_INT 1
49847: DEC
49848: ST_TO_ADDR
49849: LD_EXP 99
49853: PUSH
49854: FOR_TO
49855: IFFALSE 51660
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
49857: LD_EXP 99
49861: PUSH
49862: LD_VAR 0 2
49866: ARRAY
49867: NOT
49868: PUSH
49869: LD_EXP 106
49873: PUSH
49874: LD_VAR 0 2
49878: ARRAY
49879: OR
49880: IFFALSE 49884
// continue ;
49882: GO 49854
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
49884: LD_EXP 115
49888: PUSH
49889: LD_VAR 0 2
49893: ARRAY
49894: NOT
49895: PUSH
49896: LD_EXP 116
49900: PUSH
49901: LD_VAR 0 2
49905: ARRAY
49906: AND
49907: IFFALSE 49945
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49909: LD_ADDR_EXP 116
49913: PUSH
49914: LD_EXP 116
49918: PPUSH
49919: LD_VAR 0 2
49923: PPUSH
49924: EMPTY
49925: PPUSH
49926: CALL_OW 1
49930: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
49931: LD_VAR 0 2
49935: PPUSH
49936: LD_INT 107
49938: PPUSH
49939: CALL 40692 0 2
// continue ;
49943: GO 49854
// end ; target := [ ] ;
49945: LD_ADDR_VAR 0 7
49949: PUSH
49950: EMPTY
49951: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
49952: LD_ADDR_VAR 0 6
49956: PUSH
49957: LD_EXP 99
49961: PUSH
49962: LD_VAR 0 2
49966: ARRAY
49967: PUSH
49968: LD_INT 1
49970: ARRAY
49971: PPUSH
49972: CALL_OW 255
49976: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49977: LD_ADDR_VAR 0 9
49981: PUSH
49982: LD_EXP 99
49986: PUSH
49987: LD_VAR 0 2
49991: ARRAY
49992: PPUSH
49993: LD_INT 2
49995: PUSH
49996: LD_INT 30
49998: PUSH
49999: LD_INT 0
50001: PUSH
50002: EMPTY
50003: LIST
50004: LIST
50005: PUSH
50006: LD_INT 30
50008: PUSH
50009: LD_INT 1
50011: PUSH
50012: EMPTY
50013: LIST
50014: LIST
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: LIST
50020: PPUSH
50021: CALL_OW 72
50025: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
50026: LD_ADDR_VAR 0 3
50030: PUSH
50031: DOUBLE
50032: LD_EXP 115
50036: PUSH
50037: LD_VAR 0 2
50041: ARRAY
50042: INC
50043: ST_TO_ADDR
50044: LD_INT 1
50046: PUSH
50047: FOR_DOWNTO
50048: IFFALSE 50293
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
50050: LD_EXP 115
50054: PUSH
50055: LD_VAR 0 2
50059: ARRAY
50060: PUSH
50061: LD_VAR 0 3
50065: ARRAY
50066: PUSH
50067: LD_INT 2
50069: ARRAY
50070: PPUSH
50071: LD_EXP 115
50075: PUSH
50076: LD_VAR 0 2
50080: ARRAY
50081: PUSH
50082: LD_VAR 0 3
50086: ARRAY
50087: PUSH
50088: LD_INT 3
50090: ARRAY
50091: PPUSH
50092: CALL_OW 488
50096: PUSH
50097: LD_EXP 115
50101: PUSH
50102: LD_VAR 0 2
50106: ARRAY
50107: PUSH
50108: LD_VAR 0 3
50112: ARRAY
50113: PUSH
50114: LD_INT 2
50116: ARRAY
50117: PPUSH
50118: LD_EXP 115
50122: PUSH
50123: LD_VAR 0 2
50127: ARRAY
50128: PUSH
50129: LD_VAR 0 3
50133: ARRAY
50134: PUSH
50135: LD_INT 3
50137: ARRAY
50138: PPUSH
50139: CALL_OW 284
50143: PUSH
50144: LD_INT 0
50146: EQUAL
50147: AND
50148: IFFALSE 50203
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
50150: LD_ADDR_VAR 0 5
50154: PUSH
50155: LD_EXP 115
50159: PUSH
50160: LD_VAR 0 2
50164: ARRAY
50165: PPUSH
50166: LD_VAR 0 3
50170: PPUSH
50171: CALL_OW 3
50175: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
50176: LD_ADDR_EXP 115
50180: PUSH
50181: LD_EXP 115
50185: PPUSH
50186: LD_VAR 0 2
50190: PPUSH
50191: LD_VAR 0 5
50195: PPUSH
50196: CALL_OW 1
50200: ST_TO_ADDR
// continue ;
50201: GO 50047
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
50203: LD_VAR 0 6
50207: PPUSH
50208: LD_EXP 115
50212: PUSH
50213: LD_VAR 0 2
50217: ARRAY
50218: PUSH
50219: LD_VAR 0 3
50223: ARRAY
50224: PUSH
50225: LD_INT 2
50227: ARRAY
50228: PPUSH
50229: LD_EXP 115
50233: PUSH
50234: LD_VAR 0 2
50238: ARRAY
50239: PUSH
50240: LD_VAR 0 3
50244: ARRAY
50245: PUSH
50246: LD_INT 3
50248: ARRAY
50249: PPUSH
50250: LD_INT 30
50252: PPUSH
50253: CALL 73228 0 4
50257: PUSH
50258: LD_INT 4
50260: ARRAY
50261: PUSH
50262: LD_INT 0
50264: EQUAL
50265: IFFALSE 50291
// begin target := mc_crates [ i ] [ j ] ;
50267: LD_ADDR_VAR 0 7
50271: PUSH
50272: LD_EXP 115
50276: PUSH
50277: LD_VAR 0 2
50281: ARRAY
50282: PUSH
50283: LD_VAR 0 3
50287: ARRAY
50288: ST_TO_ADDR
// break ;
50289: GO 50293
// end ; end ;
50291: GO 50047
50293: POP
50294: POP
// if not target then
50295: LD_VAR 0 7
50299: NOT
50300: IFFALSE 50304
// continue ;
50302: GO 49854
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
50304: LD_ADDR_VAR 0 8
50308: PUSH
50309: LD_EXP 118
50313: PUSH
50314: LD_VAR 0 2
50318: ARRAY
50319: PPUSH
50320: LD_INT 2
50322: PUSH
50323: LD_INT 3
50325: PUSH
50326: LD_INT 58
50328: PUSH
50329: EMPTY
50330: LIST
50331: PUSH
50332: EMPTY
50333: LIST
50334: LIST
50335: PUSH
50336: LD_INT 61
50338: PUSH
50339: EMPTY
50340: LIST
50341: PUSH
50342: LD_INT 33
50344: PUSH
50345: LD_INT 5
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 33
50354: PUSH
50355: LD_INT 3
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: EMPTY
50363: LIST
50364: LIST
50365: LIST
50366: LIST
50367: LIST
50368: PUSH
50369: LD_INT 2
50371: PUSH
50372: LD_INT 34
50374: PUSH
50375: LD_INT 32
50377: PUSH
50378: EMPTY
50379: LIST
50380: LIST
50381: PUSH
50382: LD_INT 34
50384: PUSH
50385: LD_INT 51
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: PUSH
50392: LD_INT 34
50394: PUSH
50395: LD_INT 12
50397: PUSH
50398: EMPTY
50399: LIST
50400: LIST
50401: PUSH
50402: EMPTY
50403: LIST
50404: LIST
50405: LIST
50406: LIST
50407: PUSH
50408: EMPTY
50409: LIST
50410: LIST
50411: PPUSH
50412: CALL_OW 72
50416: ST_TO_ADDR
// if not cargo then
50417: LD_VAR 0 8
50421: NOT
50422: IFFALSE 51128
// begin if mc_crates_collector [ i ] < 5 then
50424: LD_EXP 116
50428: PUSH
50429: LD_VAR 0 2
50433: ARRAY
50434: PUSH
50435: LD_INT 5
50437: LESS
50438: IFFALSE 50804
// begin if mc_ape [ i ] then
50440: LD_EXP 128
50444: PUSH
50445: LD_VAR 0 2
50449: ARRAY
50450: IFFALSE 50497
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
50452: LD_ADDR_VAR 0 5
50456: PUSH
50457: LD_EXP 128
50461: PUSH
50462: LD_VAR 0 2
50466: ARRAY
50467: PPUSH
50468: LD_INT 25
50470: PUSH
50471: LD_INT 16
50473: PUSH
50474: EMPTY
50475: LIST
50476: LIST
50477: PUSH
50478: LD_INT 24
50480: PUSH
50481: LD_INT 750
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PUSH
50488: EMPTY
50489: LIST
50490: LIST
50491: PPUSH
50492: CALL_OW 72
50496: ST_TO_ADDR
// if not tmp then
50497: LD_VAR 0 5
50501: NOT
50502: IFFALSE 50549
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
50504: LD_ADDR_VAR 0 5
50508: PUSH
50509: LD_EXP 99
50513: PUSH
50514: LD_VAR 0 2
50518: ARRAY
50519: PPUSH
50520: LD_INT 25
50522: PUSH
50523: LD_INT 2
50525: PUSH
50526: EMPTY
50527: LIST
50528: LIST
50529: PUSH
50530: LD_INT 24
50532: PUSH
50533: LD_INT 750
50535: PUSH
50536: EMPTY
50537: LIST
50538: LIST
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: PPUSH
50544: CALL_OW 72
50548: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
50549: LD_EXP 128
50553: PUSH
50554: LD_VAR 0 2
50558: ARRAY
50559: PUSH
50560: LD_EXP 99
50564: PUSH
50565: LD_VAR 0 2
50569: ARRAY
50570: PPUSH
50571: LD_INT 25
50573: PUSH
50574: LD_INT 2
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: LD_INT 24
50583: PUSH
50584: LD_INT 750
50586: PUSH
50587: EMPTY
50588: LIST
50589: LIST
50590: PUSH
50591: EMPTY
50592: LIST
50593: LIST
50594: PPUSH
50595: CALL_OW 72
50599: AND
50600: PUSH
50601: LD_VAR 0 5
50605: PUSH
50606: LD_INT 5
50608: LESS
50609: AND
50610: IFFALSE 50692
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
50612: LD_ADDR_VAR 0 3
50616: PUSH
50617: LD_EXP 99
50621: PUSH
50622: LD_VAR 0 2
50626: ARRAY
50627: PPUSH
50628: LD_INT 25
50630: PUSH
50631: LD_INT 2
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: PUSH
50638: LD_INT 24
50640: PUSH
50641: LD_INT 750
50643: PUSH
50644: EMPTY
50645: LIST
50646: LIST
50647: PUSH
50648: EMPTY
50649: LIST
50650: LIST
50651: PPUSH
50652: CALL_OW 72
50656: PUSH
50657: FOR_IN
50658: IFFALSE 50690
// begin tmp := tmp union j ;
50660: LD_ADDR_VAR 0 5
50664: PUSH
50665: LD_VAR 0 5
50669: PUSH
50670: LD_VAR 0 3
50674: UNION
50675: ST_TO_ADDR
// if tmp >= 5 then
50676: LD_VAR 0 5
50680: PUSH
50681: LD_INT 5
50683: GREATEREQUAL
50684: IFFALSE 50688
// break ;
50686: GO 50690
// end ;
50688: GO 50657
50690: POP
50691: POP
// end ; if not tmp then
50692: LD_VAR 0 5
50696: NOT
50697: IFFALSE 50701
// continue ;
50699: GO 49854
// for j in tmp do
50701: LD_ADDR_VAR 0 3
50705: PUSH
50706: LD_VAR 0 5
50710: PUSH
50711: FOR_IN
50712: IFFALSE 50802
// if not GetTag ( j ) then
50714: LD_VAR 0 3
50718: PPUSH
50719: CALL_OW 110
50723: NOT
50724: IFFALSE 50800
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
50726: LD_ADDR_EXP 116
50730: PUSH
50731: LD_EXP 116
50735: PPUSH
50736: LD_VAR 0 2
50740: PUSH
50741: LD_EXP 116
50745: PUSH
50746: LD_VAR 0 2
50750: ARRAY
50751: PUSH
50752: LD_INT 1
50754: PLUS
50755: PUSH
50756: EMPTY
50757: LIST
50758: LIST
50759: PPUSH
50760: LD_VAR 0 3
50764: PPUSH
50765: CALL 72332 0 3
50769: ST_TO_ADDR
// SetTag ( j , 107 ) ;
50770: LD_VAR 0 3
50774: PPUSH
50775: LD_INT 107
50777: PPUSH
50778: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
50782: LD_EXP 116
50786: PUSH
50787: LD_VAR 0 2
50791: ARRAY
50792: PUSH
50793: LD_INT 5
50795: GREATEREQUAL
50796: IFFALSE 50800
// break ;
50798: GO 50802
// end ;
50800: GO 50711
50802: POP
50803: POP
// end ; if mc_crates_collector [ i ] and target then
50804: LD_EXP 116
50808: PUSH
50809: LD_VAR 0 2
50813: ARRAY
50814: PUSH
50815: LD_VAR 0 7
50819: AND
50820: IFFALSE 51126
// begin if mc_crates_collector [ i ] < target [ 1 ] then
50822: LD_EXP 116
50826: PUSH
50827: LD_VAR 0 2
50831: ARRAY
50832: PUSH
50833: LD_VAR 0 7
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: LESS
50842: IFFALSE 50862
// tmp := mc_crates_collector [ i ] else
50844: LD_ADDR_VAR 0 5
50848: PUSH
50849: LD_EXP 116
50853: PUSH
50854: LD_VAR 0 2
50858: ARRAY
50859: ST_TO_ADDR
50860: GO 50876
// tmp := target [ 1 ] ;
50862: LD_ADDR_VAR 0 5
50866: PUSH
50867: LD_VAR 0 7
50871: PUSH
50872: LD_INT 1
50874: ARRAY
50875: ST_TO_ADDR
// k := 0 ;
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: LD_INT 0
50883: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
50884: LD_ADDR_VAR 0 3
50888: PUSH
50889: LD_EXP 116
50893: PUSH
50894: LD_VAR 0 2
50898: ARRAY
50899: PUSH
50900: FOR_IN
50901: IFFALSE 51124
// begin k := k + 1 ;
50903: LD_ADDR_VAR 0 4
50907: PUSH
50908: LD_VAR 0 4
50912: PUSH
50913: LD_INT 1
50915: PLUS
50916: ST_TO_ADDR
// if k > tmp then
50917: LD_VAR 0 4
50921: PUSH
50922: LD_VAR 0 5
50926: GREATER
50927: IFFALSE 50931
// break ;
50929: GO 51124
// if not GetClass ( j ) in [ 2 , 16 ] then
50931: LD_VAR 0 3
50935: PPUSH
50936: CALL_OW 257
50940: PUSH
50941: LD_INT 2
50943: PUSH
50944: LD_INT 16
50946: PUSH
50947: EMPTY
50948: LIST
50949: LIST
50950: IN
50951: NOT
50952: IFFALSE 51005
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
50954: LD_ADDR_EXP 116
50958: PUSH
50959: LD_EXP 116
50963: PPUSH
50964: LD_VAR 0 2
50968: PPUSH
50969: LD_EXP 116
50973: PUSH
50974: LD_VAR 0 2
50978: ARRAY
50979: PUSH
50980: LD_VAR 0 3
50984: DIFF
50985: PPUSH
50986: CALL_OW 1
50990: ST_TO_ADDR
// SetTag ( j , 0 ) ;
50991: LD_VAR 0 3
50995: PPUSH
50996: LD_INT 0
50998: PPUSH
50999: CALL_OW 109
// continue ;
51003: GO 50900
// end ; if IsInUnit ( j ) then
51005: LD_VAR 0 3
51009: PPUSH
51010: CALL_OW 310
51014: IFFALSE 51025
// ComExitBuilding ( j ) ;
51016: LD_VAR 0 3
51020: PPUSH
51021: CALL_OW 122
// wait ( 3 ) ;
51025: LD_INT 3
51027: PPUSH
51028: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
51032: LD_VAR 0 3
51036: PPUSH
51037: CALL_OW 314
51041: PUSH
51042: LD_VAR 0 6
51046: PPUSH
51047: LD_VAR 0 7
51051: PUSH
51052: LD_INT 2
51054: ARRAY
51055: PPUSH
51056: LD_VAR 0 7
51060: PUSH
51061: LD_INT 3
51063: ARRAY
51064: PPUSH
51065: LD_INT 30
51067: PPUSH
51068: CALL 73228 0 4
51072: PUSH
51073: LD_INT 4
51075: ARRAY
51076: AND
51077: IFFALSE 51095
// ComStandNearbyBuilding ( j , depot ) else
51079: LD_VAR 0 3
51083: PPUSH
51084: LD_VAR 0 9
51088: PPUSH
51089: CALL 68759 0 2
51093: GO 51122
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51095: LD_VAR 0 3
51099: PPUSH
51100: LD_VAR 0 7
51104: PUSH
51105: LD_INT 2
51107: ARRAY
51108: PPUSH
51109: LD_VAR 0 7
51113: PUSH
51114: LD_INT 3
51116: ARRAY
51117: PPUSH
51118: CALL_OW 117
// end ;
51122: GO 50900
51124: POP
51125: POP
// end ; end else
51126: GO 51658
// begin for j in cargo do
51128: LD_ADDR_VAR 0 3
51132: PUSH
51133: LD_VAR 0 8
51137: PUSH
51138: FOR_IN
51139: IFFALSE 51656
// begin if GetTag ( j ) <> 0 then
51141: LD_VAR 0 3
51145: PPUSH
51146: CALL_OW 110
51150: PUSH
51151: LD_INT 0
51153: NONEQUAL
51154: IFFALSE 51158
// continue ;
51156: GO 51138
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
51158: LD_VAR 0 3
51162: PPUSH
51163: CALL_OW 256
51167: PUSH
51168: LD_INT 1000
51170: LESS
51171: PUSH
51172: LD_VAR 0 3
51176: PPUSH
51177: LD_EXP 123
51181: PUSH
51182: LD_VAR 0 2
51186: ARRAY
51187: PPUSH
51188: CALL_OW 308
51192: NOT
51193: AND
51194: IFFALSE 51216
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51196: LD_VAR 0 3
51200: PPUSH
51201: LD_EXP 123
51205: PUSH
51206: LD_VAR 0 2
51210: ARRAY
51211: PPUSH
51212: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
51216: LD_VAR 0 3
51220: PPUSH
51221: CALL_OW 256
51225: PUSH
51226: LD_INT 1000
51228: LESS
51229: PUSH
51230: LD_VAR 0 3
51234: PPUSH
51235: LD_EXP 123
51239: PUSH
51240: LD_VAR 0 2
51244: ARRAY
51245: PPUSH
51246: CALL_OW 308
51250: AND
51251: IFFALSE 51255
// continue ;
51253: GO 51138
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
51255: LD_VAR 0 3
51259: PPUSH
51260: CALL_OW 262
51264: PUSH
51265: LD_INT 2
51267: EQUAL
51268: PUSH
51269: LD_VAR 0 3
51273: PPUSH
51274: CALL_OW 261
51278: PUSH
51279: LD_INT 15
51281: LESS
51282: AND
51283: IFFALSE 51287
// continue ;
51285: GO 51138
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
51287: LD_VAR 0 3
51291: PPUSH
51292: CALL_OW 262
51296: PUSH
51297: LD_INT 1
51299: EQUAL
51300: PUSH
51301: LD_VAR 0 3
51305: PPUSH
51306: CALL_OW 261
51310: PUSH
51311: LD_INT 10
51313: LESS
51314: AND
51315: IFFALSE 51595
// begin if not depot then
51317: LD_VAR 0 9
51321: NOT
51322: IFFALSE 51326
// continue ;
51324: GO 51138
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
51326: LD_VAR 0 3
51330: PPUSH
51331: LD_VAR 0 9
51335: PPUSH
51336: LD_VAR 0 3
51340: PPUSH
51341: CALL_OW 74
51345: PPUSH
51346: CALL_OW 296
51350: PUSH
51351: LD_INT 6
51353: LESS
51354: IFFALSE 51370
// SetFuel ( j , 100 ) else
51356: LD_VAR 0 3
51360: PPUSH
51361: LD_INT 100
51363: PPUSH
51364: CALL_OW 240
51368: GO 51595
// if GetFuel ( j ) = 0 then
51370: LD_VAR 0 3
51374: PPUSH
51375: CALL_OW 261
51379: PUSH
51380: LD_INT 0
51382: EQUAL
51383: IFFALSE 51595
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
51385: LD_ADDR_EXP 118
51389: PUSH
51390: LD_EXP 118
51394: PPUSH
51395: LD_VAR 0 2
51399: PPUSH
51400: LD_EXP 118
51404: PUSH
51405: LD_VAR 0 2
51409: ARRAY
51410: PUSH
51411: LD_VAR 0 3
51415: DIFF
51416: PPUSH
51417: CALL_OW 1
51421: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
51422: LD_VAR 0 3
51426: PPUSH
51427: CALL_OW 263
51431: PUSH
51432: LD_INT 1
51434: EQUAL
51435: IFFALSE 51451
// ComExitVehicle ( IsInUnit ( j ) ) ;
51437: LD_VAR 0 3
51441: PPUSH
51442: CALL_OW 310
51446: PPUSH
51447: CALL_OW 121
// if GetControl ( j ) = control_remote then
51451: LD_VAR 0 3
51455: PPUSH
51456: CALL_OW 263
51460: PUSH
51461: LD_INT 2
51463: EQUAL
51464: IFFALSE 51475
// ComUnlink ( j ) ;
51466: LD_VAR 0 3
51470: PPUSH
51471: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
51475: LD_ADDR_VAR 0 10
51479: PUSH
51480: LD_VAR 0 2
51484: PPUSH
51485: LD_INT 3
51487: PPUSH
51488: CALL 61262 0 2
51492: ST_TO_ADDR
// if fac then
51493: LD_VAR 0 10
51497: IFFALSE 51593
// begin for k in fac do
51499: LD_ADDR_VAR 0 4
51503: PUSH
51504: LD_VAR 0 10
51508: PUSH
51509: FOR_IN
51510: IFFALSE 51591
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
51512: LD_ADDR_VAR 0 11
51516: PUSH
51517: LD_VAR 0 10
51521: PPUSH
51522: LD_VAR 0 3
51526: PPUSH
51527: CALL_OW 265
51531: PPUSH
51532: LD_VAR 0 3
51536: PPUSH
51537: CALL_OW 262
51541: PPUSH
51542: LD_VAR 0 3
51546: PPUSH
51547: CALL_OW 263
51551: PPUSH
51552: LD_VAR 0 3
51556: PPUSH
51557: CALL_OW 264
51561: PPUSH
51562: CALL 69830 0 5
51566: ST_TO_ADDR
// if components then
51567: LD_VAR 0 11
51571: IFFALSE 51589
// begin MC_InsertProduceList ( i , components ) ;
51573: LD_VAR 0 2
51577: PPUSH
51578: LD_VAR 0 11
51582: PPUSH
51583: CALL 60807 0 2
// break ;
51587: GO 51591
// end ; end ;
51589: GO 51509
51591: POP
51592: POP
// end ; continue ;
51593: GO 51138
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
51595: LD_VAR 0 3
51599: PPUSH
51600: LD_INT 1
51602: PPUSH
51603: CALL_OW 289
51607: PUSH
51608: LD_INT 100
51610: LESS
51611: PUSH
51612: LD_VAR 0 3
51616: PPUSH
51617: CALL_OW 314
51621: NOT
51622: AND
51623: IFFALSE 51652
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
51625: LD_VAR 0 3
51629: PPUSH
51630: LD_VAR 0 7
51634: PUSH
51635: LD_INT 2
51637: ARRAY
51638: PPUSH
51639: LD_VAR 0 7
51643: PUSH
51644: LD_INT 3
51646: ARRAY
51647: PPUSH
51648: CALL_OW 117
// break ;
51652: GO 51656
// end ;
51654: GO 51138
51656: POP
51657: POP
// end ; end ;
51658: GO 49854
51660: POP
51661: POP
// end ;
51662: LD_VAR 0 1
51666: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
51667: LD_INT 0
51669: PPUSH
51670: PPUSH
51671: PPUSH
51672: PPUSH
// if not mc_bases then
51673: LD_EXP 99
51677: NOT
51678: IFFALSE 51682
// exit ;
51680: GO 51843
// for i = 1 to mc_bases do
51682: LD_ADDR_VAR 0 2
51686: PUSH
51687: DOUBLE
51688: LD_INT 1
51690: DEC
51691: ST_TO_ADDR
51692: LD_EXP 99
51696: PUSH
51697: FOR_TO
51698: IFFALSE 51841
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
51700: LD_ADDR_VAR 0 4
51704: PUSH
51705: LD_EXP 118
51709: PUSH
51710: LD_VAR 0 2
51714: ARRAY
51715: PUSH
51716: LD_EXP 121
51720: PUSH
51721: LD_VAR 0 2
51725: ARRAY
51726: UNION
51727: PPUSH
51728: LD_INT 33
51730: PUSH
51731: LD_INT 2
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: PPUSH
51738: CALL_OW 72
51742: ST_TO_ADDR
// if tmp then
51743: LD_VAR 0 4
51747: IFFALSE 51839
// for j in tmp do
51749: LD_ADDR_VAR 0 3
51753: PUSH
51754: LD_VAR 0 4
51758: PUSH
51759: FOR_IN
51760: IFFALSE 51837
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
51762: LD_VAR 0 3
51766: PPUSH
51767: CALL_OW 312
51771: NOT
51772: PUSH
51773: LD_VAR 0 3
51777: PPUSH
51778: CALL_OW 256
51782: PUSH
51783: LD_INT 250
51785: GREATEREQUAL
51786: AND
51787: IFFALSE 51800
// Connect ( j ) else
51789: LD_VAR 0 3
51793: PPUSH
51794: CALL 75301 0 1
51798: GO 51835
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
51800: LD_VAR 0 3
51804: PPUSH
51805: CALL_OW 256
51809: PUSH
51810: LD_INT 250
51812: LESS
51813: PUSH
51814: LD_VAR 0 3
51818: PPUSH
51819: CALL_OW 312
51823: AND
51824: IFFALSE 51835
// ComUnlink ( j ) ;
51826: LD_VAR 0 3
51830: PPUSH
51831: CALL_OW 136
51835: GO 51759
51837: POP
51838: POP
// end ;
51839: GO 51697
51841: POP
51842: POP
// end ;
51843: LD_VAR 0 1
51847: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
51848: LD_INT 0
51850: PPUSH
51851: PPUSH
51852: PPUSH
51853: PPUSH
51854: PPUSH
// if not mc_bases then
51855: LD_EXP 99
51859: NOT
51860: IFFALSE 51864
// exit ;
51862: GO 52309
// for i = 1 to mc_bases do
51864: LD_ADDR_VAR 0 2
51868: PUSH
51869: DOUBLE
51870: LD_INT 1
51872: DEC
51873: ST_TO_ADDR
51874: LD_EXP 99
51878: PUSH
51879: FOR_TO
51880: IFFALSE 52307
// begin if not mc_produce [ i ] then
51882: LD_EXP 120
51886: PUSH
51887: LD_VAR 0 2
51891: ARRAY
51892: NOT
51893: IFFALSE 51897
// continue ;
51895: GO 51879
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51897: LD_ADDR_VAR 0 5
51901: PUSH
51902: LD_EXP 99
51906: PUSH
51907: LD_VAR 0 2
51911: ARRAY
51912: PPUSH
51913: LD_INT 30
51915: PUSH
51916: LD_INT 3
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: PPUSH
51923: CALL_OW 72
51927: ST_TO_ADDR
// if not fac then
51928: LD_VAR 0 5
51932: NOT
51933: IFFALSE 51937
// continue ;
51935: GO 51879
// for j in fac do
51937: LD_ADDR_VAR 0 3
51941: PUSH
51942: LD_VAR 0 5
51946: PUSH
51947: FOR_IN
51948: IFFALSE 52303
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
51950: LD_VAR 0 3
51954: PPUSH
51955: CALL_OW 461
51959: PUSH
51960: LD_INT 2
51962: NONEQUAL
51963: PUSH
51964: LD_VAR 0 3
51968: PPUSH
51969: LD_INT 15
51971: PPUSH
51972: CALL 74929 0 2
51976: PUSH
51977: LD_INT 4
51979: ARRAY
51980: OR
51981: IFFALSE 51985
// continue ;
51983: GO 51947
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
51985: LD_VAR 0 3
51989: PPUSH
51990: LD_EXP 120
51994: PUSH
51995: LD_VAR 0 2
51999: ARRAY
52000: PUSH
52001: LD_INT 1
52003: ARRAY
52004: PUSH
52005: LD_INT 1
52007: ARRAY
52008: PPUSH
52009: LD_EXP 120
52013: PUSH
52014: LD_VAR 0 2
52018: ARRAY
52019: PUSH
52020: LD_INT 1
52022: ARRAY
52023: PUSH
52024: LD_INT 2
52026: ARRAY
52027: PPUSH
52028: LD_EXP 120
52032: PUSH
52033: LD_VAR 0 2
52037: ARRAY
52038: PUSH
52039: LD_INT 1
52041: ARRAY
52042: PUSH
52043: LD_INT 3
52045: ARRAY
52046: PPUSH
52047: LD_EXP 120
52051: PUSH
52052: LD_VAR 0 2
52056: ARRAY
52057: PUSH
52058: LD_INT 1
52060: ARRAY
52061: PUSH
52062: LD_INT 4
52064: ARRAY
52065: PPUSH
52066: CALL_OW 448
52070: PUSH
52071: LD_VAR 0 3
52075: PPUSH
52076: LD_EXP 120
52080: PUSH
52081: LD_VAR 0 2
52085: ARRAY
52086: PUSH
52087: LD_INT 1
52089: ARRAY
52090: PUSH
52091: LD_INT 1
52093: ARRAY
52094: PUSH
52095: LD_EXP 120
52099: PUSH
52100: LD_VAR 0 2
52104: ARRAY
52105: PUSH
52106: LD_INT 1
52108: ARRAY
52109: PUSH
52110: LD_INT 2
52112: ARRAY
52113: PUSH
52114: LD_EXP 120
52118: PUSH
52119: LD_VAR 0 2
52123: ARRAY
52124: PUSH
52125: LD_INT 1
52127: ARRAY
52128: PUSH
52129: LD_INT 3
52131: ARRAY
52132: PUSH
52133: LD_EXP 120
52137: PUSH
52138: LD_VAR 0 2
52142: ARRAY
52143: PUSH
52144: LD_INT 1
52146: ARRAY
52147: PUSH
52148: LD_INT 4
52150: ARRAY
52151: PUSH
52152: EMPTY
52153: LIST
52154: LIST
52155: LIST
52156: LIST
52157: PPUSH
52158: CALL 78696 0 2
52162: AND
52163: IFFALSE 52301
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
52165: LD_VAR 0 3
52169: PPUSH
52170: LD_EXP 120
52174: PUSH
52175: LD_VAR 0 2
52179: ARRAY
52180: PUSH
52181: LD_INT 1
52183: ARRAY
52184: PUSH
52185: LD_INT 1
52187: ARRAY
52188: PPUSH
52189: LD_EXP 120
52193: PUSH
52194: LD_VAR 0 2
52198: ARRAY
52199: PUSH
52200: LD_INT 1
52202: ARRAY
52203: PUSH
52204: LD_INT 2
52206: ARRAY
52207: PPUSH
52208: LD_EXP 120
52212: PUSH
52213: LD_VAR 0 2
52217: ARRAY
52218: PUSH
52219: LD_INT 1
52221: ARRAY
52222: PUSH
52223: LD_INT 3
52225: ARRAY
52226: PPUSH
52227: LD_EXP 120
52231: PUSH
52232: LD_VAR 0 2
52236: ARRAY
52237: PUSH
52238: LD_INT 1
52240: ARRAY
52241: PUSH
52242: LD_INT 4
52244: ARRAY
52245: PPUSH
52246: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
52250: LD_ADDR_VAR 0 4
52254: PUSH
52255: LD_EXP 120
52259: PUSH
52260: LD_VAR 0 2
52264: ARRAY
52265: PPUSH
52266: LD_INT 1
52268: PPUSH
52269: CALL_OW 3
52273: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
52274: LD_ADDR_EXP 120
52278: PUSH
52279: LD_EXP 120
52283: PPUSH
52284: LD_VAR 0 2
52288: PPUSH
52289: LD_VAR 0 4
52293: PPUSH
52294: CALL_OW 1
52298: ST_TO_ADDR
// break ;
52299: GO 52303
// end ; end ;
52301: GO 51947
52303: POP
52304: POP
// end ;
52305: GO 51879
52307: POP
52308: POP
// end ;
52309: LD_VAR 0 1
52313: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
52314: LD_INT 0
52316: PPUSH
52317: PPUSH
52318: PPUSH
// if not mc_bases then
52319: LD_EXP 99
52323: NOT
52324: IFFALSE 52328
// exit ;
52326: GO 52417
// for i = 1 to mc_bases do
52328: LD_ADDR_VAR 0 2
52332: PUSH
52333: DOUBLE
52334: LD_INT 1
52336: DEC
52337: ST_TO_ADDR
52338: LD_EXP 99
52342: PUSH
52343: FOR_TO
52344: IFFALSE 52415
// begin if mc_attack [ i ] then
52346: LD_EXP 119
52350: PUSH
52351: LD_VAR 0 2
52355: ARRAY
52356: IFFALSE 52413
// begin tmp := mc_attack [ i ] [ 1 ] ;
52358: LD_ADDR_VAR 0 3
52362: PUSH
52363: LD_EXP 119
52367: PUSH
52368: LD_VAR 0 2
52372: ARRAY
52373: PUSH
52374: LD_INT 1
52376: ARRAY
52377: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52378: LD_ADDR_EXP 119
52382: PUSH
52383: LD_EXP 119
52387: PPUSH
52388: LD_VAR 0 2
52392: PPUSH
52393: EMPTY
52394: PPUSH
52395: CALL_OW 1
52399: ST_TO_ADDR
// Attack ( tmp ) ;
52400: LD_VAR 0 3
52404: PPUSH
52405: CALL 128391 0 1
// exit ;
52409: POP
52410: POP
52411: GO 52417
// end ; end ;
52413: GO 52343
52415: POP
52416: POP
// end ;
52417: LD_VAR 0 1
52421: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
52422: LD_INT 0
52424: PPUSH
52425: PPUSH
52426: PPUSH
52427: PPUSH
52428: PPUSH
52429: PPUSH
52430: PPUSH
// if not mc_bases then
52431: LD_EXP 99
52435: NOT
52436: IFFALSE 52440
// exit ;
52438: GO 53297
// for i = 1 to mc_bases do
52440: LD_ADDR_VAR 0 2
52444: PUSH
52445: DOUBLE
52446: LD_INT 1
52448: DEC
52449: ST_TO_ADDR
52450: LD_EXP 99
52454: PUSH
52455: FOR_TO
52456: IFFALSE 53295
// begin if not mc_bases [ i ] then
52458: LD_EXP 99
52462: PUSH
52463: LD_VAR 0 2
52467: ARRAY
52468: NOT
52469: IFFALSE 52473
// continue ;
52471: GO 52455
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
52473: LD_ADDR_VAR 0 7
52477: PUSH
52478: LD_EXP 99
52482: PUSH
52483: LD_VAR 0 2
52487: ARRAY
52488: PUSH
52489: LD_INT 1
52491: ARRAY
52492: PPUSH
52493: CALL 68981 0 1
52497: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
52498: LD_ADDR_EXP 122
52502: PUSH
52503: LD_EXP 122
52507: PPUSH
52508: LD_VAR 0 2
52512: PPUSH
52513: LD_EXP 99
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: PUSH
52524: LD_INT 1
52526: ARRAY
52527: PPUSH
52528: CALL_OW 255
52532: PPUSH
52533: LD_EXP 124
52537: PUSH
52538: LD_VAR 0 2
52542: ARRAY
52543: PPUSH
52544: CALL 68946 0 2
52548: PPUSH
52549: CALL_OW 1
52553: ST_TO_ADDR
// if not mc_scan [ i ] then
52554: LD_EXP 122
52558: PUSH
52559: LD_VAR 0 2
52563: ARRAY
52564: NOT
52565: IFFALSE 52743
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52567: LD_ADDR_EXP 142
52571: PUSH
52572: LD_EXP 142
52576: PPUSH
52577: LD_VAR 0 2
52581: PPUSH
52582: LD_INT 0
52584: PPUSH
52585: CALL_OW 1
52589: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52590: LD_ADDR_VAR 0 4
52594: PUSH
52595: LD_EXP 99
52599: PUSH
52600: LD_VAR 0 2
52604: ARRAY
52605: PPUSH
52606: LD_INT 2
52608: PUSH
52609: LD_INT 25
52611: PUSH
52612: LD_INT 5
52614: PUSH
52615: EMPTY
52616: LIST
52617: LIST
52618: PUSH
52619: LD_INT 25
52621: PUSH
52622: LD_INT 8
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: PUSH
52629: LD_INT 25
52631: PUSH
52632: LD_INT 9
52634: PUSH
52635: EMPTY
52636: LIST
52637: LIST
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: LIST
52643: LIST
52644: PPUSH
52645: CALL_OW 72
52649: ST_TO_ADDR
// if not tmp then
52650: LD_VAR 0 4
52654: NOT
52655: IFFALSE 52659
// continue ;
52657: GO 52455
// for j in tmp do
52659: LD_ADDR_VAR 0 3
52663: PUSH
52664: LD_VAR 0 4
52668: PUSH
52669: FOR_IN
52670: IFFALSE 52741
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
52672: LD_VAR 0 3
52676: PPUSH
52677: CALL_OW 310
52681: PPUSH
52682: CALL_OW 266
52686: PUSH
52687: LD_INT 5
52689: EQUAL
52690: PUSH
52691: LD_VAR 0 3
52695: PPUSH
52696: CALL_OW 257
52700: PUSH
52701: LD_INT 1
52703: EQUAL
52704: AND
52705: PUSH
52706: LD_VAR 0 3
52710: PPUSH
52711: CALL_OW 459
52715: NOT
52716: AND
52717: PUSH
52718: LD_VAR 0 7
52722: AND
52723: IFFALSE 52739
// ComChangeProfession ( j , class ) ;
52725: LD_VAR 0 3
52729: PPUSH
52730: LD_VAR 0 7
52734: PPUSH
52735: CALL_OW 123
52739: GO 52669
52741: POP
52742: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
52743: LD_EXP 122
52747: PUSH
52748: LD_VAR 0 2
52752: ARRAY
52753: PUSH
52754: LD_EXP 142
52758: PUSH
52759: LD_VAR 0 2
52763: ARRAY
52764: NOT
52765: AND
52766: PUSH
52767: LD_EXP 121
52771: PUSH
52772: LD_VAR 0 2
52776: ARRAY
52777: NOT
52778: AND
52779: PUSH
52780: LD_EXP 99
52784: PUSH
52785: LD_VAR 0 2
52789: ARRAY
52790: PPUSH
52791: LD_INT 50
52793: PUSH
52794: EMPTY
52795: LIST
52796: PUSH
52797: LD_INT 2
52799: PUSH
52800: LD_INT 30
52802: PUSH
52803: LD_INT 32
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: PUSH
52810: LD_INT 30
52812: PUSH
52813: LD_INT 33
52815: PUSH
52816: EMPTY
52817: LIST
52818: LIST
52819: PUSH
52820: LD_INT 30
52822: PUSH
52823: LD_INT 4
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: PUSH
52830: LD_INT 30
52832: PUSH
52833: LD_INT 5
52835: PUSH
52836: EMPTY
52837: LIST
52838: LIST
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: LIST
52844: LIST
52845: LIST
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PPUSH
52851: CALL_OW 72
52855: PUSH
52856: LD_INT 4
52858: LESS
52859: PUSH
52860: LD_EXP 99
52864: PUSH
52865: LD_VAR 0 2
52869: ARRAY
52870: PPUSH
52871: LD_INT 3
52873: PUSH
52874: LD_INT 24
52876: PUSH
52877: LD_INT 1000
52879: PUSH
52880: EMPTY
52881: LIST
52882: LIST
52883: PUSH
52884: EMPTY
52885: LIST
52886: LIST
52887: PUSH
52888: LD_INT 2
52890: PUSH
52891: LD_INT 30
52893: PUSH
52894: LD_INT 0
52896: PUSH
52897: EMPTY
52898: LIST
52899: LIST
52900: PUSH
52901: LD_INT 30
52903: PUSH
52904: LD_INT 1
52906: PUSH
52907: EMPTY
52908: LIST
52909: LIST
52910: PUSH
52911: EMPTY
52912: LIST
52913: LIST
52914: LIST
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: PPUSH
52920: CALL_OW 72
52924: OR
52925: AND
52926: IFFALSE 53177
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
52928: LD_ADDR_EXP 142
52932: PUSH
52933: LD_EXP 142
52937: PPUSH
52938: LD_VAR 0 2
52942: PPUSH
52943: LD_INT 1
52945: PPUSH
52946: CALL_OW 1
52950: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52951: LD_ADDR_VAR 0 4
52955: PUSH
52956: LD_EXP 99
52960: PUSH
52961: LD_VAR 0 2
52965: ARRAY
52966: PPUSH
52967: LD_INT 2
52969: PUSH
52970: LD_INT 25
52972: PUSH
52973: LD_INT 1
52975: PUSH
52976: EMPTY
52977: LIST
52978: LIST
52979: PUSH
52980: LD_INT 25
52982: PUSH
52983: LD_INT 5
52985: PUSH
52986: EMPTY
52987: LIST
52988: LIST
52989: PUSH
52990: LD_INT 25
52992: PUSH
52993: LD_INT 8
52995: PUSH
52996: EMPTY
52997: LIST
52998: LIST
52999: PUSH
53000: LD_INT 25
53002: PUSH
53003: LD_INT 9
53005: PUSH
53006: EMPTY
53007: LIST
53008: LIST
53009: PUSH
53010: EMPTY
53011: LIST
53012: LIST
53013: LIST
53014: LIST
53015: LIST
53016: PPUSH
53017: CALL_OW 72
53021: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
53022: LD_ADDR_VAR 0 4
53026: PUSH
53027: LD_VAR 0 4
53031: PUSH
53032: LD_VAR 0 4
53036: PPUSH
53037: LD_INT 18
53039: PPUSH
53040: CALL 102218 0 2
53044: DIFF
53045: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
53046: LD_VAR 0 4
53050: NOT
53051: PUSH
53052: LD_EXP 99
53056: PUSH
53057: LD_VAR 0 2
53061: ARRAY
53062: PPUSH
53063: LD_INT 2
53065: PUSH
53066: LD_INT 30
53068: PUSH
53069: LD_INT 4
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: PUSH
53076: LD_INT 30
53078: PUSH
53079: LD_INT 5
53081: PUSH
53082: EMPTY
53083: LIST
53084: LIST
53085: PUSH
53086: EMPTY
53087: LIST
53088: LIST
53089: LIST
53090: PPUSH
53091: CALL_OW 72
53095: NOT
53096: AND
53097: IFFALSE 53159
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
53099: LD_ADDR_VAR 0 4
53103: PUSH
53104: LD_EXP 99
53108: PUSH
53109: LD_VAR 0 2
53113: ARRAY
53114: PPUSH
53115: LD_INT 2
53117: PUSH
53118: LD_INT 25
53120: PUSH
53121: LD_INT 2
53123: PUSH
53124: EMPTY
53125: LIST
53126: LIST
53127: PUSH
53128: LD_INT 25
53130: PUSH
53131: LD_INT 3
53133: PUSH
53134: EMPTY
53135: LIST
53136: LIST
53137: PUSH
53138: LD_INT 25
53140: PUSH
53141: LD_INT 4
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: PUSH
53148: EMPTY
53149: LIST
53150: LIST
53151: LIST
53152: LIST
53153: PPUSH
53154: CALL_OW 72
53158: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
53159: LD_VAR 0 2
53163: PPUSH
53164: LD_VAR 0 4
53168: PPUSH
53169: CALL 133100 0 2
// exit ;
53173: POP
53174: POP
53175: GO 53297
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
53177: LD_EXP 122
53181: PUSH
53182: LD_VAR 0 2
53186: ARRAY
53187: PUSH
53188: LD_EXP 142
53192: PUSH
53193: LD_VAR 0 2
53197: ARRAY
53198: NOT
53199: AND
53200: PUSH
53201: LD_EXP 121
53205: PUSH
53206: LD_VAR 0 2
53210: ARRAY
53211: AND
53212: IFFALSE 53293
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
53214: LD_ADDR_EXP 142
53218: PUSH
53219: LD_EXP 142
53223: PPUSH
53224: LD_VAR 0 2
53228: PPUSH
53229: LD_INT 1
53231: PPUSH
53232: CALL_OW 1
53236: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
53237: LD_ADDR_VAR 0 4
53241: PUSH
53242: LD_EXP 121
53246: PUSH
53247: LD_VAR 0 2
53251: ARRAY
53252: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53253: LD_ADDR_EXP 121
53257: PUSH
53258: LD_EXP 121
53262: PPUSH
53263: LD_VAR 0 2
53267: PPUSH
53268: EMPTY
53269: PPUSH
53270: CALL_OW 1
53274: ST_TO_ADDR
// Defend ( i , tmp ) ;
53275: LD_VAR 0 2
53279: PPUSH
53280: LD_VAR 0 4
53284: PPUSH
53285: CALL 133696 0 2
// exit ;
53289: POP
53290: POP
53291: GO 53297
// end ; end ;
53293: GO 52455
53295: POP
53296: POP
// end ;
53297: LD_VAR 0 1
53301: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
53302: LD_INT 0
53304: PPUSH
53305: PPUSH
53306: PPUSH
53307: PPUSH
53308: PPUSH
53309: PPUSH
53310: PPUSH
53311: PPUSH
53312: PPUSH
53313: PPUSH
53314: PPUSH
// if not mc_bases then
53315: LD_EXP 99
53319: NOT
53320: IFFALSE 53324
// exit ;
53322: GO 54411
// for i = 1 to mc_bases do
53324: LD_ADDR_VAR 0 2
53328: PUSH
53329: DOUBLE
53330: LD_INT 1
53332: DEC
53333: ST_TO_ADDR
53334: LD_EXP 99
53338: PUSH
53339: FOR_TO
53340: IFFALSE 54409
// begin tmp := mc_lab [ i ] ;
53342: LD_ADDR_VAR 0 6
53346: PUSH
53347: LD_EXP 132
53351: PUSH
53352: LD_VAR 0 2
53356: ARRAY
53357: ST_TO_ADDR
// if not tmp then
53358: LD_VAR 0 6
53362: NOT
53363: IFFALSE 53367
// continue ;
53365: GO 53339
// idle_lab := 0 ;
53367: LD_ADDR_VAR 0 11
53371: PUSH
53372: LD_INT 0
53374: ST_TO_ADDR
// for j in tmp do
53375: LD_ADDR_VAR 0 3
53379: PUSH
53380: LD_VAR 0 6
53384: PUSH
53385: FOR_IN
53386: IFFALSE 54405
// begin researching := false ;
53388: LD_ADDR_VAR 0 10
53392: PUSH
53393: LD_INT 0
53395: ST_TO_ADDR
// side := GetSide ( j ) ;
53396: LD_ADDR_VAR 0 4
53400: PUSH
53401: LD_VAR 0 3
53405: PPUSH
53406: CALL_OW 255
53410: ST_TO_ADDR
// if not mc_tech [ side ] then
53411: LD_EXP 126
53415: PUSH
53416: LD_VAR 0 4
53420: ARRAY
53421: NOT
53422: IFFALSE 53426
// continue ;
53424: GO 53385
// if BuildingStatus ( j ) = bs_idle then
53426: LD_VAR 0 3
53430: PPUSH
53431: CALL_OW 461
53435: PUSH
53436: LD_INT 2
53438: EQUAL
53439: IFFALSE 53627
// begin if idle_lab and UnitsInside ( j ) < 6 then
53441: LD_VAR 0 11
53445: PUSH
53446: LD_VAR 0 3
53450: PPUSH
53451: CALL_OW 313
53455: PUSH
53456: LD_INT 6
53458: LESS
53459: AND
53460: IFFALSE 53531
// begin tmp2 := UnitsInside ( idle_lab ) ;
53462: LD_ADDR_VAR 0 9
53466: PUSH
53467: LD_VAR 0 11
53471: PPUSH
53472: CALL_OW 313
53476: ST_TO_ADDR
// if tmp2 then
53477: LD_VAR 0 9
53481: IFFALSE 53523
// for x in tmp2 do
53483: LD_ADDR_VAR 0 7
53487: PUSH
53488: LD_VAR 0 9
53492: PUSH
53493: FOR_IN
53494: IFFALSE 53521
// begin ComExitBuilding ( x ) ;
53496: LD_VAR 0 7
53500: PPUSH
53501: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53505: LD_VAR 0 7
53509: PPUSH
53510: LD_VAR 0 3
53514: PPUSH
53515: CALL_OW 180
// end ;
53519: GO 53493
53521: POP
53522: POP
// idle_lab := 0 ;
53523: LD_ADDR_VAR 0 11
53527: PUSH
53528: LD_INT 0
53530: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
53531: LD_ADDR_VAR 0 5
53535: PUSH
53536: LD_EXP 126
53540: PUSH
53541: LD_VAR 0 4
53545: ARRAY
53546: PUSH
53547: FOR_IN
53548: IFFALSE 53608
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
53550: LD_VAR 0 3
53554: PPUSH
53555: LD_VAR 0 5
53559: PPUSH
53560: CALL_OW 430
53564: PUSH
53565: LD_VAR 0 4
53569: PPUSH
53570: LD_VAR 0 5
53574: PPUSH
53575: CALL 68051 0 2
53579: AND
53580: IFFALSE 53606
// begin researching := true ;
53582: LD_ADDR_VAR 0 10
53586: PUSH
53587: LD_INT 1
53589: ST_TO_ADDR
// ComResearch ( j , t ) ;
53590: LD_VAR 0 3
53594: PPUSH
53595: LD_VAR 0 5
53599: PPUSH
53600: CALL_OW 124
// break ;
53604: GO 53608
// end ;
53606: GO 53547
53608: POP
53609: POP
// if not researching then
53610: LD_VAR 0 10
53614: NOT
53615: IFFALSE 53627
// idle_lab := j ;
53617: LD_ADDR_VAR 0 11
53621: PUSH
53622: LD_VAR 0 3
53626: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
53627: LD_VAR 0 3
53631: PPUSH
53632: CALL_OW 461
53636: PUSH
53637: LD_INT 10
53639: EQUAL
53640: IFFALSE 54228
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
53642: LD_EXP 128
53646: PUSH
53647: LD_VAR 0 2
53651: ARRAY
53652: NOT
53653: PUSH
53654: LD_EXP 129
53658: PUSH
53659: LD_VAR 0 2
53663: ARRAY
53664: NOT
53665: AND
53666: PUSH
53667: LD_EXP 126
53671: PUSH
53672: LD_VAR 0 4
53676: ARRAY
53677: PUSH
53678: LD_INT 1
53680: GREATER
53681: AND
53682: IFFALSE 53813
// begin ComCancel ( j ) ;
53684: LD_VAR 0 3
53688: PPUSH
53689: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
53693: LD_ADDR_EXP 126
53697: PUSH
53698: LD_EXP 126
53702: PPUSH
53703: LD_VAR 0 4
53707: PPUSH
53708: LD_EXP 126
53712: PUSH
53713: LD_VAR 0 4
53717: ARRAY
53718: PPUSH
53719: LD_EXP 126
53723: PUSH
53724: LD_VAR 0 4
53728: ARRAY
53729: PUSH
53730: LD_INT 1
53732: MINUS
53733: PPUSH
53734: LD_EXP 126
53738: PUSH
53739: LD_VAR 0 4
53743: ARRAY
53744: PPUSH
53745: LD_INT 0
53747: PPUSH
53748: CALL 71750 0 4
53752: PPUSH
53753: CALL_OW 1
53757: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
53758: LD_ADDR_EXP 126
53762: PUSH
53763: LD_EXP 126
53767: PPUSH
53768: LD_VAR 0 4
53772: PPUSH
53773: LD_EXP 126
53777: PUSH
53778: LD_VAR 0 4
53782: ARRAY
53783: PPUSH
53784: LD_EXP 126
53788: PUSH
53789: LD_VAR 0 4
53793: ARRAY
53794: PPUSH
53795: LD_INT 1
53797: PPUSH
53798: LD_INT 0
53800: PPUSH
53801: CALL 71750 0 4
53805: PPUSH
53806: CALL_OW 1
53810: ST_TO_ADDR
// continue ;
53811: GO 53385
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
53813: LD_EXP 128
53817: PUSH
53818: LD_VAR 0 2
53822: ARRAY
53823: PUSH
53824: LD_EXP 129
53828: PUSH
53829: LD_VAR 0 2
53833: ARRAY
53834: NOT
53835: AND
53836: IFFALSE 53963
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
53838: LD_ADDR_EXP 129
53842: PUSH
53843: LD_EXP 129
53847: PPUSH
53848: LD_VAR 0 2
53852: PUSH
53853: LD_EXP 129
53857: PUSH
53858: LD_VAR 0 2
53862: ARRAY
53863: PUSH
53864: LD_INT 1
53866: PLUS
53867: PUSH
53868: EMPTY
53869: LIST
53870: LIST
53871: PPUSH
53872: LD_EXP 128
53876: PUSH
53877: LD_VAR 0 2
53881: ARRAY
53882: PUSH
53883: LD_INT 1
53885: ARRAY
53886: PPUSH
53887: CALL 72332 0 3
53891: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
53892: LD_EXP 128
53896: PUSH
53897: LD_VAR 0 2
53901: ARRAY
53902: PUSH
53903: LD_INT 1
53905: ARRAY
53906: PPUSH
53907: LD_INT 112
53909: PPUSH
53910: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
53914: LD_ADDR_VAR 0 9
53918: PUSH
53919: LD_EXP 128
53923: PUSH
53924: LD_VAR 0 2
53928: ARRAY
53929: PPUSH
53930: LD_INT 1
53932: PPUSH
53933: CALL_OW 3
53937: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
53938: LD_ADDR_EXP 128
53942: PUSH
53943: LD_EXP 128
53947: PPUSH
53948: LD_VAR 0 2
53952: PPUSH
53953: LD_VAR 0 9
53957: PPUSH
53958: CALL_OW 1
53962: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
53963: LD_EXP 128
53967: PUSH
53968: LD_VAR 0 2
53972: ARRAY
53973: PUSH
53974: LD_EXP 129
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: AND
53985: PUSH
53986: LD_EXP 129
53990: PUSH
53991: LD_VAR 0 2
53995: ARRAY
53996: PUSH
53997: LD_INT 1
53999: ARRAY
54000: PPUSH
54001: CALL_OW 310
54005: NOT
54006: AND
54007: PUSH
54008: LD_VAR 0 3
54012: PPUSH
54013: CALL_OW 313
54017: PUSH
54018: LD_INT 6
54020: EQUAL
54021: AND
54022: IFFALSE 54078
// begin tmp2 := UnitsInside ( j ) ;
54024: LD_ADDR_VAR 0 9
54028: PUSH
54029: LD_VAR 0 3
54033: PPUSH
54034: CALL_OW 313
54038: ST_TO_ADDR
// if tmp2 = 6 then
54039: LD_VAR 0 9
54043: PUSH
54044: LD_INT 6
54046: EQUAL
54047: IFFALSE 54078
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
54049: LD_VAR 0 9
54053: PUSH
54054: LD_INT 1
54056: ARRAY
54057: PPUSH
54058: LD_INT 112
54060: PPUSH
54061: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
54065: LD_VAR 0 9
54069: PUSH
54070: LD_INT 1
54072: ARRAY
54073: PPUSH
54074: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
54078: LD_EXP 129
54082: PUSH
54083: LD_VAR 0 2
54087: ARRAY
54088: PUSH
54089: LD_EXP 129
54093: PUSH
54094: LD_VAR 0 2
54098: ARRAY
54099: PUSH
54100: LD_INT 1
54102: ARRAY
54103: PPUSH
54104: CALL_OW 314
54108: NOT
54109: AND
54110: PUSH
54111: LD_EXP 129
54115: PUSH
54116: LD_VAR 0 2
54120: ARRAY
54121: PUSH
54122: LD_INT 1
54124: ARRAY
54125: PPUSH
54126: CALL_OW 310
54130: NOT
54131: AND
54132: IFFALSE 54158
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
54134: LD_EXP 129
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PUSH
54145: LD_INT 1
54147: ARRAY
54148: PPUSH
54149: LD_VAR 0 3
54153: PPUSH
54154: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
54158: LD_EXP 129
54162: PUSH
54163: LD_VAR 0 2
54167: ARRAY
54168: PUSH
54169: LD_INT 1
54171: ARRAY
54172: PPUSH
54173: CALL_OW 310
54177: PUSH
54178: LD_EXP 129
54182: PUSH
54183: LD_VAR 0 2
54187: ARRAY
54188: PUSH
54189: LD_INT 1
54191: ARRAY
54192: PPUSH
54193: CALL_OW 310
54197: PPUSH
54198: CALL_OW 461
54202: PUSH
54203: LD_INT 3
54205: NONEQUAL
54206: AND
54207: IFFALSE 54228
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
54209: LD_EXP 129
54213: PUSH
54214: LD_VAR 0 2
54218: ARRAY
54219: PUSH
54220: LD_INT 1
54222: ARRAY
54223: PPUSH
54224: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
54228: LD_VAR 0 3
54232: PPUSH
54233: CALL_OW 461
54237: PUSH
54238: LD_INT 6
54240: EQUAL
54241: PUSH
54242: LD_VAR 0 6
54246: PUSH
54247: LD_INT 1
54249: GREATER
54250: AND
54251: IFFALSE 54403
// begin sci := [ ] ;
54253: LD_ADDR_VAR 0 8
54257: PUSH
54258: EMPTY
54259: ST_TO_ADDR
// for x in ( tmp diff j ) do
54260: LD_ADDR_VAR 0 7
54264: PUSH
54265: LD_VAR 0 6
54269: PUSH
54270: LD_VAR 0 3
54274: DIFF
54275: PUSH
54276: FOR_IN
54277: IFFALSE 54329
// begin if sci = 6 then
54279: LD_VAR 0 8
54283: PUSH
54284: LD_INT 6
54286: EQUAL
54287: IFFALSE 54291
// break ;
54289: GO 54329
// if BuildingStatus ( x ) = bs_idle then
54291: LD_VAR 0 7
54295: PPUSH
54296: CALL_OW 461
54300: PUSH
54301: LD_INT 2
54303: EQUAL
54304: IFFALSE 54327
// sci := sci ^ UnitsInside ( x ) ;
54306: LD_ADDR_VAR 0 8
54310: PUSH
54311: LD_VAR 0 8
54315: PUSH
54316: LD_VAR 0 7
54320: PPUSH
54321: CALL_OW 313
54325: ADD
54326: ST_TO_ADDR
// end ;
54327: GO 54276
54329: POP
54330: POP
// if not sci then
54331: LD_VAR 0 8
54335: NOT
54336: IFFALSE 54340
// continue ;
54338: GO 53385
// for x in sci do
54340: LD_ADDR_VAR 0 7
54344: PUSH
54345: LD_VAR 0 8
54349: PUSH
54350: FOR_IN
54351: IFFALSE 54401
// if IsInUnit ( x ) and not HasTask ( x ) then
54353: LD_VAR 0 7
54357: PPUSH
54358: CALL_OW 310
54362: PUSH
54363: LD_VAR 0 7
54367: PPUSH
54368: CALL_OW 314
54372: NOT
54373: AND
54374: IFFALSE 54399
// begin ComExitBuilding ( x ) ;
54376: LD_VAR 0 7
54380: PPUSH
54381: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
54385: LD_VAR 0 7
54389: PPUSH
54390: LD_VAR 0 3
54394: PPUSH
54395: CALL_OW 180
// end ;
54399: GO 54350
54401: POP
54402: POP
// end ; end ;
54403: GO 53385
54405: POP
54406: POP
// end ;
54407: GO 53339
54409: POP
54410: POP
// end ;
54411: LD_VAR 0 1
54415: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
54416: LD_INT 0
54418: PPUSH
54419: PPUSH
// if not mc_bases then
54420: LD_EXP 99
54424: NOT
54425: IFFALSE 54429
// exit ;
54427: GO 54510
// for i = 1 to mc_bases do
54429: LD_ADDR_VAR 0 2
54433: PUSH
54434: DOUBLE
54435: LD_INT 1
54437: DEC
54438: ST_TO_ADDR
54439: LD_EXP 99
54443: PUSH
54444: FOR_TO
54445: IFFALSE 54508
// if mc_mines [ i ] and mc_miners [ i ] then
54447: LD_EXP 112
54451: PUSH
54452: LD_VAR 0 2
54456: ARRAY
54457: PUSH
54458: LD_EXP 113
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: AND
54469: IFFALSE 54506
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
54471: LD_EXP 113
54475: PUSH
54476: LD_VAR 0 2
54480: ARRAY
54481: PUSH
54482: LD_INT 1
54484: ARRAY
54485: PPUSH
54486: CALL_OW 255
54490: PPUSH
54491: LD_EXP 112
54495: PUSH
54496: LD_VAR 0 2
54500: ARRAY
54501: PPUSH
54502: CALL 69134 0 2
54506: GO 54444
54508: POP
54509: POP
// end ;
54510: LD_VAR 0 1
54514: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
54515: LD_INT 0
54517: PPUSH
54518: PPUSH
54519: PPUSH
54520: PPUSH
54521: PPUSH
54522: PPUSH
54523: PPUSH
54524: PPUSH
// if not mc_bases or not mc_parking then
54525: LD_EXP 99
54529: NOT
54530: PUSH
54531: LD_EXP 123
54535: NOT
54536: OR
54537: IFFALSE 54541
// exit ;
54539: GO 55279
// for i = 1 to mc_bases do
54541: LD_ADDR_VAR 0 2
54545: PUSH
54546: DOUBLE
54547: LD_INT 1
54549: DEC
54550: ST_TO_ADDR
54551: LD_EXP 99
54555: PUSH
54556: FOR_TO
54557: IFFALSE 55277
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
54559: LD_EXP 99
54563: PUSH
54564: LD_VAR 0 2
54568: ARRAY
54569: NOT
54570: PUSH
54571: LD_EXP 123
54575: PUSH
54576: LD_VAR 0 2
54580: ARRAY
54581: NOT
54582: OR
54583: IFFALSE 54587
// continue ;
54585: GO 54556
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
54587: LD_ADDR_VAR 0 5
54591: PUSH
54592: LD_EXP 99
54596: PUSH
54597: LD_VAR 0 2
54601: ARRAY
54602: PUSH
54603: LD_INT 1
54605: ARRAY
54606: PPUSH
54607: CALL_OW 255
54611: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54612: LD_ADDR_VAR 0 6
54616: PUSH
54617: LD_EXP 99
54621: PUSH
54622: LD_VAR 0 2
54626: ARRAY
54627: PPUSH
54628: LD_INT 30
54630: PUSH
54631: LD_INT 3
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: PPUSH
54638: CALL_OW 72
54642: ST_TO_ADDR
// if not fac then
54643: LD_VAR 0 6
54647: NOT
54648: IFFALSE 54699
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54650: LD_ADDR_VAR 0 6
54654: PUSH
54655: LD_EXP 99
54659: PUSH
54660: LD_VAR 0 2
54664: ARRAY
54665: PPUSH
54666: LD_INT 2
54668: PUSH
54669: LD_INT 30
54671: PUSH
54672: LD_INT 0
54674: PUSH
54675: EMPTY
54676: LIST
54677: LIST
54678: PUSH
54679: LD_INT 30
54681: PUSH
54682: LD_INT 1
54684: PUSH
54685: EMPTY
54686: LIST
54687: LIST
54688: PUSH
54689: EMPTY
54690: LIST
54691: LIST
54692: LIST
54693: PPUSH
54694: CALL_OW 72
54698: ST_TO_ADDR
// if not fac then
54699: LD_VAR 0 6
54703: NOT
54704: IFFALSE 54708
// continue ;
54706: GO 54556
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54708: LD_ADDR_VAR 0 7
54712: PUSH
54713: LD_EXP 123
54717: PUSH
54718: LD_VAR 0 2
54722: ARRAY
54723: PPUSH
54724: LD_INT 22
54726: PUSH
54727: LD_VAR 0 5
54731: PUSH
54732: EMPTY
54733: LIST
54734: LIST
54735: PUSH
54736: LD_INT 21
54738: PUSH
54739: LD_INT 2
54741: PUSH
54742: EMPTY
54743: LIST
54744: LIST
54745: PUSH
54746: LD_INT 3
54748: PUSH
54749: LD_INT 60
54751: PUSH
54752: EMPTY
54753: LIST
54754: PUSH
54755: EMPTY
54756: LIST
54757: LIST
54758: PUSH
54759: LD_INT 3
54761: PUSH
54762: LD_INT 24
54764: PUSH
54765: LD_INT 1000
54767: PUSH
54768: EMPTY
54769: LIST
54770: LIST
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: LIST
54781: PPUSH
54782: CALL_OW 70
54786: ST_TO_ADDR
// for j in fac do
54787: LD_ADDR_VAR 0 3
54791: PUSH
54792: LD_VAR 0 6
54796: PUSH
54797: FOR_IN
54798: IFFALSE 54893
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54800: LD_ADDR_VAR 0 7
54804: PUSH
54805: LD_VAR 0 7
54809: PUSH
54810: LD_INT 22
54812: PUSH
54813: LD_VAR 0 5
54817: PUSH
54818: EMPTY
54819: LIST
54820: LIST
54821: PUSH
54822: LD_INT 91
54824: PUSH
54825: LD_VAR 0 3
54829: PUSH
54830: LD_INT 15
54832: PUSH
54833: EMPTY
54834: LIST
54835: LIST
54836: LIST
54837: PUSH
54838: LD_INT 21
54840: PUSH
54841: LD_INT 2
54843: PUSH
54844: EMPTY
54845: LIST
54846: LIST
54847: PUSH
54848: LD_INT 3
54850: PUSH
54851: LD_INT 60
54853: PUSH
54854: EMPTY
54855: LIST
54856: PUSH
54857: EMPTY
54858: LIST
54859: LIST
54860: PUSH
54861: LD_INT 3
54863: PUSH
54864: LD_INT 24
54866: PUSH
54867: LD_INT 1000
54869: PUSH
54870: EMPTY
54871: LIST
54872: LIST
54873: PUSH
54874: EMPTY
54875: LIST
54876: LIST
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: LIST
54882: LIST
54883: LIST
54884: PPUSH
54885: CALL_OW 69
54889: UNION
54890: ST_TO_ADDR
54891: GO 54797
54893: POP
54894: POP
// if not vehs then
54895: LD_VAR 0 7
54899: NOT
54900: IFFALSE 54926
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54902: LD_ADDR_EXP 111
54906: PUSH
54907: LD_EXP 111
54911: PPUSH
54912: LD_VAR 0 2
54916: PPUSH
54917: EMPTY
54918: PPUSH
54919: CALL_OW 1
54923: ST_TO_ADDR
// continue ;
54924: GO 54556
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54926: LD_ADDR_VAR 0 8
54930: PUSH
54931: LD_EXP 99
54935: PUSH
54936: LD_VAR 0 2
54940: ARRAY
54941: PPUSH
54942: LD_INT 30
54944: PUSH
54945: LD_INT 3
54947: PUSH
54948: EMPTY
54949: LIST
54950: LIST
54951: PPUSH
54952: CALL_OW 72
54956: ST_TO_ADDR
// if tmp then
54957: LD_VAR 0 8
54961: IFFALSE 55064
// begin for j in tmp do
54963: LD_ADDR_VAR 0 3
54967: PUSH
54968: LD_VAR 0 8
54972: PUSH
54973: FOR_IN
54974: IFFALSE 55062
// for k in UnitsInside ( j ) do
54976: LD_ADDR_VAR 0 4
54980: PUSH
54981: LD_VAR 0 3
54985: PPUSH
54986: CALL_OW 313
54990: PUSH
54991: FOR_IN
54992: IFFALSE 55058
// if k then
54994: LD_VAR 0 4
54998: IFFALSE 55056
// if not k in mc_repair_vehicle [ i ] then
55000: LD_VAR 0 4
55004: PUSH
55005: LD_EXP 111
55009: PUSH
55010: LD_VAR 0 2
55014: ARRAY
55015: IN
55016: NOT
55017: IFFALSE 55056
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
55019: LD_ADDR_EXP 111
55023: PUSH
55024: LD_EXP 111
55028: PPUSH
55029: LD_VAR 0 2
55033: PPUSH
55034: LD_EXP 111
55038: PUSH
55039: LD_VAR 0 2
55043: ARRAY
55044: PUSH
55045: LD_VAR 0 4
55049: UNION
55050: PPUSH
55051: CALL_OW 1
55055: ST_TO_ADDR
55056: GO 54991
55058: POP
55059: POP
55060: GO 54973
55062: POP
55063: POP
// end ; if not mc_repair_vehicle [ i ] then
55064: LD_EXP 111
55068: PUSH
55069: LD_VAR 0 2
55073: ARRAY
55074: NOT
55075: IFFALSE 55079
// continue ;
55077: GO 54556
// for j in mc_repair_vehicle [ i ] do
55079: LD_ADDR_VAR 0 3
55083: PUSH
55084: LD_EXP 111
55088: PUSH
55089: LD_VAR 0 2
55093: ARRAY
55094: PUSH
55095: FOR_IN
55096: IFFALSE 55273
// begin if GetClass ( j ) <> 3 then
55098: LD_VAR 0 3
55102: PPUSH
55103: CALL_OW 257
55107: PUSH
55108: LD_INT 3
55110: NONEQUAL
55111: IFFALSE 55152
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
55113: LD_ADDR_EXP 111
55117: PUSH
55118: LD_EXP 111
55122: PPUSH
55123: LD_VAR 0 2
55127: PPUSH
55128: LD_EXP 111
55132: PUSH
55133: LD_VAR 0 2
55137: ARRAY
55138: PUSH
55139: LD_VAR 0 3
55143: DIFF
55144: PPUSH
55145: CALL_OW 1
55149: ST_TO_ADDR
// continue ;
55150: GO 55095
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55152: LD_VAR 0 3
55156: PPUSH
55157: CALL_OW 311
55161: NOT
55162: PUSH
55163: LD_VAR 0 3
55167: PUSH
55168: LD_EXP 102
55172: PUSH
55173: LD_VAR 0 2
55177: ARRAY
55178: PUSH
55179: LD_INT 1
55181: ARRAY
55182: IN
55183: NOT
55184: AND
55185: PUSH
55186: LD_VAR 0 3
55190: PUSH
55191: LD_EXP 102
55195: PUSH
55196: LD_VAR 0 2
55200: ARRAY
55201: PUSH
55202: LD_INT 2
55204: ARRAY
55205: IN
55206: NOT
55207: AND
55208: IFFALSE 55271
// begin if IsInUnit ( j ) then
55210: LD_VAR 0 3
55214: PPUSH
55215: CALL_OW 310
55219: IFFALSE 55232
// ComExitBuilding ( j ) else
55221: LD_VAR 0 3
55225: PPUSH
55226: CALL_OW 122
55230: GO 55271
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
55232: LD_VAR 0 3
55236: PPUSH
55237: LD_VAR 0 7
55241: PUSH
55242: LD_INT 1
55244: ARRAY
55245: PPUSH
55246: CALL 106709 0 2
55250: NOT
55251: IFFALSE 55271
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
55253: LD_VAR 0 3
55257: PPUSH
55258: LD_VAR 0 7
55262: PUSH
55263: LD_INT 1
55265: ARRAY
55266: PPUSH
55267: CALL_OW 129
// end ; end ;
55271: GO 55095
55273: POP
55274: POP
// end ;
55275: GO 54556
55277: POP
55278: POP
// end ;
55279: LD_VAR 0 1
55283: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
55284: LD_INT 0
55286: PPUSH
55287: PPUSH
55288: PPUSH
55289: PPUSH
55290: PPUSH
55291: PPUSH
55292: PPUSH
55293: PPUSH
55294: PPUSH
55295: PPUSH
55296: PPUSH
// if not mc_bases then
55297: LD_EXP 99
55301: NOT
55302: IFFALSE 55306
// exit ;
55304: GO 56108
// for i = 1 to mc_bases do
55306: LD_ADDR_VAR 0 2
55310: PUSH
55311: DOUBLE
55312: LD_INT 1
55314: DEC
55315: ST_TO_ADDR
55316: LD_EXP 99
55320: PUSH
55321: FOR_TO
55322: IFFALSE 56106
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
55324: LD_EXP 127
55328: PUSH
55329: LD_VAR 0 2
55333: ARRAY
55334: NOT
55335: PUSH
55336: LD_EXP 102
55340: PUSH
55341: LD_VAR 0 2
55345: ARRAY
55346: PUSH
55347: LD_INT 1
55349: ARRAY
55350: OR
55351: PUSH
55352: LD_EXP 102
55356: PUSH
55357: LD_VAR 0 2
55361: ARRAY
55362: PUSH
55363: LD_INT 2
55365: ARRAY
55366: OR
55367: PUSH
55368: LD_EXP 125
55372: PUSH
55373: LD_VAR 0 2
55377: ARRAY
55378: PPUSH
55379: LD_INT 1
55381: PPUSH
55382: CALL_OW 325
55386: NOT
55387: OR
55388: PUSH
55389: LD_EXP 122
55393: PUSH
55394: LD_VAR 0 2
55398: ARRAY
55399: OR
55400: IFFALSE 55404
// continue ;
55402: GO 55321
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
55404: LD_ADDR_VAR 0 8
55408: PUSH
55409: LD_EXP 99
55413: PUSH
55414: LD_VAR 0 2
55418: ARRAY
55419: PPUSH
55420: LD_INT 25
55422: PUSH
55423: LD_INT 4
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PUSH
55430: LD_INT 50
55432: PUSH
55433: EMPTY
55434: LIST
55435: PUSH
55436: LD_INT 3
55438: PUSH
55439: LD_INT 60
55441: PUSH
55442: EMPTY
55443: LIST
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: PUSH
55449: EMPTY
55450: LIST
55451: LIST
55452: LIST
55453: PPUSH
55454: CALL_OW 72
55458: PUSH
55459: LD_EXP 103
55463: PUSH
55464: LD_VAR 0 2
55468: ARRAY
55469: DIFF
55470: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55471: LD_ADDR_VAR 0 9
55475: PUSH
55476: LD_EXP 99
55480: PUSH
55481: LD_VAR 0 2
55485: ARRAY
55486: PPUSH
55487: LD_INT 2
55489: PUSH
55490: LD_INT 30
55492: PUSH
55493: LD_INT 0
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 30
55502: PUSH
55503: LD_INT 1
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PUSH
55510: EMPTY
55511: LIST
55512: LIST
55513: LIST
55514: PPUSH
55515: CALL_OW 72
55519: ST_TO_ADDR
// if not tmp or not dep then
55520: LD_VAR 0 8
55524: NOT
55525: PUSH
55526: LD_VAR 0 9
55530: NOT
55531: OR
55532: IFFALSE 55536
// continue ;
55534: GO 55321
// side := GetSide ( tmp [ 1 ] ) ;
55536: LD_ADDR_VAR 0 11
55540: PUSH
55541: LD_VAR 0 8
55545: PUSH
55546: LD_INT 1
55548: ARRAY
55549: PPUSH
55550: CALL_OW 255
55554: ST_TO_ADDR
// dep := dep [ 1 ] ;
55555: LD_ADDR_VAR 0 9
55559: PUSH
55560: LD_VAR 0 9
55564: PUSH
55565: LD_INT 1
55567: ARRAY
55568: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
55569: LD_ADDR_VAR 0 7
55573: PUSH
55574: LD_EXP 127
55578: PUSH
55579: LD_VAR 0 2
55583: ARRAY
55584: PPUSH
55585: LD_INT 22
55587: PUSH
55588: LD_INT 0
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: LD_INT 25
55597: PUSH
55598: LD_INT 12
55600: PUSH
55601: EMPTY
55602: LIST
55603: LIST
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PPUSH
55609: CALL_OW 70
55613: PUSH
55614: LD_INT 22
55616: PUSH
55617: LD_INT 0
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PUSH
55624: LD_INT 25
55626: PUSH
55627: LD_INT 12
55629: PUSH
55630: EMPTY
55631: LIST
55632: LIST
55633: PUSH
55634: LD_INT 91
55636: PUSH
55637: LD_VAR 0 9
55641: PUSH
55642: LD_INT 20
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: LIST
55649: PUSH
55650: EMPTY
55651: LIST
55652: LIST
55653: LIST
55654: PPUSH
55655: CALL_OW 69
55659: UNION
55660: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
55661: LD_ADDR_VAR 0 10
55665: PUSH
55666: LD_EXP 127
55670: PUSH
55671: LD_VAR 0 2
55675: ARRAY
55676: PPUSH
55677: LD_INT 81
55679: PUSH
55680: LD_VAR 0 11
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: PPUSH
55689: CALL_OW 70
55693: ST_TO_ADDR
// if not apes or danger_at_area then
55694: LD_VAR 0 7
55698: NOT
55699: PUSH
55700: LD_VAR 0 10
55704: OR
55705: IFFALSE 55755
// begin if mc_taming [ i ] then
55707: LD_EXP 130
55711: PUSH
55712: LD_VAR 0 2
55716: ARRAY
55717: IFFALSE 55753
// begin MC_Reset ( i , 121 ) ;
55719: LD_VAR 0 2
55723: PPUSH
55724: LD_INT 121
55726: PPUSH
55727: CALL 40692 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55731: LD_ADDR_EXP 130
55735: PUSH
55736: LD_EXP 130
55740: PPUSH
55741: LD_VAR 0 2
55745: PPUSH
55746: EMPTY
55747: PPUSH
55748: CALL_OW 1
55752: ST_TO_ADDR
// end ; continue ;
55753: GO 55321
// end ; for j in tmp do
55755: LD_ADDR_VAR 0 3
55759: PUSH
55760: LD_VAR 0 8
55764: PUSH
55765: FOR_IN
55766: IFFALSE 56102
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
55768: LD_VAR 0 3
55772: PUSH
55773: LD_EXP 130
55777: PUSH
55778: LD_VAR 0 2
55782: ARRAY
55783: IN
55784: NOT
55785: PUSH
55786: LD_EXP 130
55790: PUSH
55791: LD_VAR 0 2
55795: ARRAY
55796: PUSH
55797: LD_INT 3
55799: LESS
55800: AND
55801: IFFALSE 55859
// begin SetTag ( j , 121 ) ;
55803: LD_VAR 0 3
55807: PPUSH
55808: LD_INT 121
55810: PPUSH
55811: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
55815: LD_ADDR_EXP 130
55819: PUSH
55820: LD_EXP 130
55824: PPUSH
55825: LD_VAR 0 2
55829: PUSH
55830: LD_EXP 130
55834: PUSH
55835: LD_VAR 0 2
55839: ARRAY
55840: PUSH
55841: LD_INT 1
55843: PLUS
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PPUSH
55849: LD_VAR 0 3
55853: PPUSH
55854: CALL 72332 0 3
55858: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
55859: LD_VAR 0 3
55863: PUSH
55864: LD_EXP 130
55868: PUSH
55869: LD_VAR 0 2
55873: ARRAY
55874: IN
55875: IFFALSE 56100
// begin if GetClass ( j ) <> 4 then
55877: LD_VAR 0 3
55881: PPUSH
55882: CALL_OW 257
55886: PUSH
55887: LD_INT 4
55889: NONEQUAL
55890: IFFALSE 55943
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
55892: LD_ADDR_EXP 130
55896: PUSH
55897: LD_EXP 130
55901: PPUSH
55902: LD_VAR 0 2
55906: PPUSH
55907: LD_EXP 130
55911: PUSH
55912: LD_VAR 0 2
55916: ARRAY
55917: PUSH
55918: LD_VAR 0 3
55922: DIFF
55923: PPUSH
55924: CALL_OW 1
55928: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55929: LD_VAR 0 3
55933: PPUSH
55934: LD_INT 0
55936: PPUSH
55937: CALL_OW 109
// continue ;
55941: GO 55765
// end ; if IsInUnit ( j ) then
55943: LD_VAR 0 3
55947: PPUSH
55948: CALL_OW 310
55952: IFFALSE 55963
// ComExitBuilding ( j ) ;
55954: LD_VAR 0 3
55958: PPUSH
55959: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
55963: LD_ADDR_VAR 0 6
55967: PUSH
55968: LD_VAR 0 7
55972: PPUSH
55973: LD_VAR 0 3
55977: PPUSH
55978: CALL_OW 74
55982: ST_TO_ADDR
// if not ape then
55983: LD_VAR 0 6
55987: NOT
55988: IFFALSE 55992
// break ;
55990: GO 56102
// x := GetX ( ape ) ;
55992: LD_ADDR_VAR 0 4
55996: PUSH
55997: LD_VAR 0 6
56001: PPUSH
56002: CALL_OW 250
56006: ST_TO_ADDR
// y := GetY ( ape ) ;
56007: LD_ADDR_VAR 0 5
56011: PUSH
56012: LD_VAR 0 6
56016: PPUSH
56017: CALL_OW 251
56021: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
56022: LD_VAR 0 4
56026: PPUSH
56027: LD_VAR 0 5
56031: PPUSH
56032: CALL_OW 488
56036: NOT
56037: PUSH
56038: LD_VAR 0 11
56042: PPUSH
56043: LD_VAR 0 4
56047: PPUSH
56048: LD_VAR 0 5
56052: PPUSH
56053: LD_INT 20
56055: PPUSH
56056: CALL 73228 0 4
56060: PUSH
56061: LD_INT 4
56063: ARRAY
56064: OR
56065: IFFALSE 56069
// break ;
56067: GO 56102
// if not HasTask ( j ) then
56069: LD_VAR 0 3
56073: PPUSH
56074: CALL_OW 314
56078: NOT
56079: IFFALSE 56100
// ComTameXY ( j , x , y ) ;
56081: LD_VAR 0 3
56085: PPUSH
56086: LD_VAR 0 4
56090: PPUSH
56091: LD_VAR 0 5
56095: PPUSH
56096: CALL_OW 131
// end ; end ;
56100: GO 55765
56102: POP
56103: POP
// end ;
56104: GO 55321
56106: POP
56107: POP
// end ;
56108: LD_VAR 0 1
56112: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
56113: LD_INT 0
56115: PPUSH
56116: PPUSH
56117: PPUSH
56118: PPUSH
56119: PPUSH
56120: PPUSH
56121: PPUSH
56122: PPUSH
// if not mc_bases then
56123: LD_EXP 99
56127: NOT
56128: IFFALSE 56132
// exit ;
56130: GO 56758
// for i = 1 to mc_bases do
56132: LD_ADDR_VAR 0 2
56136: PUSH
56137: DOUBLE
56138: LD_INT 1
56140: DEC
56141: ST_TO_ADDR
56142: LD_EXP 99
56146: PUSH
56147: FOR_TO
56148: IFFALSE 56756
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
56150: LD_EXP 128
56154: PUSH
56155: LD_VAR 0 2
56159: ARRAY
56160: NOT
56161: PUSH
56162: LD_EXP 128
56166: PUSH
56167: LD_VAR 0 2
56171: ARRAY
56172: PPUSH
56173: LD_INT 25
56175: PUSH
56176: LD_INT 12
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: PPUSH
56183: CALL_OW 72
56187: NOT
56188: OR
56189: IFFALSE 56193
// continue ;
56191: GO 56147
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
56193: LD_ADDR_VAR 0 5
56197: PUSH
56198: LD_EXP 128
56202: PUSH
56203: LD_VAR 0 2
56207: ARRAY
56208: PUSH
56209: LD_INT 1
56211: ARRAY
56212: PPUSH
56213: CALL_OW 255
56217: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
56218: LD_VAR 0 5
56222: PPUSH
56223: LD_INT 2
56225: PPUSH
56226: CALL_OW 325
56230: IFFALSE 56483
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56232: LD_ADDR_VAR 0 4
56236: PUSH
56237: LD_EXP 128
56241: PUSH
56242: LD_VAR 0 2
56246: ARRAY
56247: PPUSH
56248: LD_INT 25
56250: PUSH
56251: LD_INT 16
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: PPUSH
56258: CALL_OW 72
56262: ST_TO_ADDR
// if tmp < 6 then
56263: LD_VAR 0 4
56267: PUSH
56268: LD_INT 6
56270: LESS
56271: IFFALSE 56483
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56273: LD_ADDR_VAR 0 6
56277: PUSH
56278: LD_EXP 99
56282: PUSH
56283: LD_VAR 0 2
56287: ARRAY
56288: PPUSH
56289: LD_INT 2
56291: PUSH
56292: LD_INT 30
56294: PUSH
56295: LD_INT 0
56297: PUSH
56298: EMPTY
56299: LIST
56300: LIST
56301: PUSH
56302: LD_INT 30
56304: PUSH
56305: LD_INT 1
56307: PUSH
56308: EMPTY
56309: LIST
56310: LIST
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: LIST
56316: PPUSH
56317: CALL_OW 72
56321: ST_TO_ADDR
// if depot then
56322: LD_VAR 0 6
56326: IFFALSE 56483
// begin selected := 0 ;
56328: LD_ADDR_VAR 0 7
56332: PUSH
56333: LD_INT 0
56335: ST_TO_ADDR
// for j in depot do
56336: LD_ADDR_VAR 0 3
56340: PUSH
56341: LD_VAR 0 6
56345: PUSH
56346: FOR_IN
56347: IFFALSE 56378
// begin if UnitsInside ( j ) < 6 then
56349: LD_VAR 0 3
56353: PPUSH
56354: CALL_OW 313
56358: PUSH
56359: LD_INT 6
56361: LESS
56362: IFFALSE 56376
// begin selected := j ;
56364: LD_ADDR_VAR 0 7
56368: PUSH
56369: LD_VAR 0 3
56373: ST_TO_ADDR
// break ;
56374: GO 56378
// end ; end ;
56376: GO 56346
56378: POP
56379: POP
// if selected then
56380: LD_VAR 0 7
56384: IFFALSE 56483
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56386: LD_ADDR_VAR 0 3
56390: PUSH
56391: LD_EXP 128
56395: PUSH
56396: LD_VAR 0 2
56400: ARRAY
56401: PPUSH
56402: LD_INT 25
56404: PUSH
56405: LD_INT 12
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PPUSH
56412: CALL_OW 72
56416: PUSH
56417: FOR_IN
56418: IFFALSE 56481
// if not HasTask ( j ) then
56420: LD_VAR 0 3
56424: PPUSH
56425: CALL_OW 314
56429: NOT
56430: IFFALSE 56479
// begin if not IsInUnit ( j ) then
56432: LD_VAR 0 3
56436: PPUSH
56437: CALL_OW 310
56441: NOT
56442: IFFALSE 56458
// ComEnterUnit ( j , selected ) ;
56444: LD_VAR 0 3
56448: PPUSH
56449: LD_VAR 0 7
56453: PPUSH
56454: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
56458: LD_VAR 0 3
56462: PPUSH
56463: LD_INT 16
56465: PPUSH
56466: CALL_OW 183
// AddComExitBuilding ( j ) ;
56470: LD_VAR 0 3
56474: PPUSH
56475: CALL_OW 182
// end ;
56479: GO 56417
56481: POP
56482: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
56483: LD_VAR 0 5
56487: PPUSH
56488: LD_INT 11
56490: PPUSH
56491: CALL_OW 325
56495: IFFALSE 56754
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
56497: LD_ADDR_VAR 0 4
56501: PUSH
56502: LD_EXP 128
56506: PUSH
56507: LD_VAR 0 2
56511: ARRAY
56512: PPUSH
56513: LD_INT 25
56515: PUSH
56516: LD_INT 16
56518: PUSH
56519: EMPTY
56520: LIST
56521: LIST
56522: PPUSH
56523: CALL_OW 72
56527: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
56528: LD_VAR 0 4
56532: PUSH
56533: LD_INT 6
56535: GREATEREQUAL
56536: PUSH
56537: LD_VAR 0 5
56541: PPUSH
56542: LD_INT 2
56544: PPUSH
56545: CALL_OW 325
56549: NOT
56550: OR
56551: IFFALSE 56754
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56553: LD_ADDR_VAR 0 8
56557: PUSH
56558: LD_EXP 99
56562: PUSH
56563: LD_VAR 0 2
56567: ARRAY
56568: PPUSH
56569: LD_INT 2
56571: PUSH
56572: LD_INT 30
56574: PUSH
56575: LD_INT 4
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: PUSH
56582: LD_INT 30
56584: PUSH
56585: LD_INT 5
56587: PUSH
56588: EMPTY
56589: LIST
56590: LIST
56591: PUSH
56592: EMPTY
56593: LIST
56594: LIST
56595: LIST
56596: PPUSH
56597: CALL_OW 72
56601: ST_TO_ADDR
// if barracks then
56602: LD_VAR 0 8
56606: IFFALSE 56754
// begin selected := 0 ;
56608: LD_ADDR_VAR 0 7
56612: PUSH
56613: LD_INT 0
56615: ST_TO_ADDR
// for j in barracks do
56616: LD_ADDR_VAR 0 3
56620: PUSH
56621: LD_VAR 0 8
56625: PUSH
56626: FOR_IN
56627: IFFALSE 56658
// begin if UnitsInside ( j ) < 6 then
56629: LD_VAR 0 3
56633: PPUSH
56634: CALL_OW 313
56638: PUSH
56639: LD_INT 6
56641: LESS
56642: IFFALSE 56656
// begin selected := j ;
56644: LD_ADDR_VAR 0 7
56648: PUSH
56649: LD_VAR 0 3
56653: ST_TO_ADDR
// break ;
56654: GO 56658
// end ; end ;
56656: GO 56626
56658: POP
56659: POP
// if selected then
56660: LD_VAR 0 7
56664: IFFALSE 56754
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
56666: LD_ADDR_VAR 0 3
56670: PUSH
56671: LD_EXP 128
56675: PUSH
56676: LD_VAR 0 2
56680: ARRAY
56681: PPUSH
56682: LD_INT 25
56684: PUSH
56685: LD_INT 12
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PPUSH
56692: CALL_OW 72
56696: PUSH
56697: FOR_IN
56698: IFFALSE 56752
// if not IsInUnit ( j ) and not HasTask ( j ) then
56700: LD_VAR 0 3
56704: PPUSH
56705: CALL_OW 310
56709: NOT
56710: PUSH
56711: LD_VAR 0 3
56715: PPUSH
56716: CALL_OW 314
56720: NOT
56721: AND
56722: IFFALSE 56750
// begin ComEnterUnit ( j , selected ) ;
56724: LD_VAR 0 3
56728: PPUSH
56729: LD_VAR 0 7
56733: PPUSH
56734: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
56738: LD_VAR 0 3
56742: PPUSH
56743: LD_INT 15
56745: PPUSH
56746: CALL_OW 183
// end ;
56750: GO 56697
56752: POP
56753: POP
// end ; end ; end ; end ; end ;
56754: GO 56147
56756: POP
56757: POP
// end ;
56758: LD_VAR 0 1
56762: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
56763: LD_INT 0
56765: PPUSH
56766: PPUSH
56767: PPUSH
56768: PPUSH
// if not mc_bases then
56769: LD_EXP 99
56773: NOT
56774: IFFALSE 56778
// exit ;
56776: GO 56956
// for i = 1 to mc_bases do
56778: LD_ADDR_VAR 0 2
56782: PUSH
56783: DOUBLE
56784: LD_INT 1
56786: DEC
56787: ST_TO_ADDR
56788: LD_EXP 99
56792: PUSH
56793: FOR_TO
56794: IFFALSE 56954
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
56796: LD_ADDR_VAR 0 4
56800: PUSH
56801: LD_EXP 99
56805: PUSH
56806: LD_VAR 0 2
56810: ARRAY
56811: PPUSH
56812: LD_INT 25
56814: PUSH
56815: LD_INT 9
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: PPUSH
56822: CALL_OW 72
56826: ST_TO_ADDR
// if not tmp then
56827: LD_VAR 0 4
56831: NOT
56832: IFFALSE 56836
// continue ;
56834: GO 56793
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
56836: LD_EXP 125
56840: PUSH
56841: LD_VAR 0 2
56845: ARRAY
56846: PPUSH
56847: LD_INT 29
56849: PPUSH
56850: CALL_OW 325
56854: NOT
56855: PUSH
56856: LD_EXP 125
56860: PUSH
56861: LD_VAR 0 2
56865: ARRAY
56866: PPUSH
56867: LD_INT 28
56869: PPUSH
56870: CALL_OW 325
56874: NOT
56875: AND
56876: IFFALSE 56880
// continue ;
56878: GO 56793
// for j in tmp do
56880: LD_ADDR_VAR 0 3
56884: PUSH
56885: LD_VAR 0 4
56889: PUSH
56890: FOR_IN
56891: IFFALSE 56950
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56893: LD_VAR 0 3
56897: PUSH
56898: LD_EXP 102
56902: PUSH
56903: LD_VAR 0 2
56907: ARRAY
56908: PUSH
56909: LD_INT 1
56911: ARRAY
56912: IN
56913: NOT
56914: PUSH
56915: LD_VAR 0 3
56919: PUSH
56920: LD_EXP 102
56924: PUSH
56925: LD_VAR 0 2
56929: ARRAY
56930: PUSH
56931: LD_INT 2
56933: ARRAY
56934: IN
56935: NOT
56936: AND
56937: IFFALSE 56948
// ComSpaceTimeShoot ( j ) ;
56939: LD_VAR 0 3
56943: PPUSH
56944: CALL 68142 0 1
56948: GO 56890
56950: POP
56951: POP
// end ;
56952: GO 56793
56954: POP
56955: POP
// end ;
56956: LD_VAR 0 1
56960: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
56961: LD_INT 0
56963: PPUSH
56964: PPUSH
56965: PPUSH
56966: PPUSH
56967: PPUSH
56968: PPUSH
56969: PPUSH
56970: PPUSH
56971: PPUSH
// if not mc_bases then
56972: LD_EXP 99
56976: NOT
56977: IFFALSE 56981
// exit ;
56979: GO 57603
// for i = 1 to mc_bases do
56981: LD_ADDR_VAR 0 2
56985: PUSH
56986: DOUBLE
56987: LD_INT 1
56989: DEC
56990: ST_TO_ADDR
56991: LD_EXP 99
56995: PUSH
56996: FOR_TO
56997: IFFALSE 57601
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
56999: LD_EXP 134
57003: PUSH
57004: LD_VAR 0 2
57008: ARRAY
57009: NOT
57010: PUSH
57011: LD_INT 38
57013: PPUSH
57014: LD_EXP 125
57018: PUSH
57019: LD_VAR 0 2
57023: ARRAY
57024: PPUSH
57025: CALL_OW 321
57029: PUSH
57030: LD_INT 2
57032: NONEQUAL
57033: OR
57034: IFFALSE 57038
// continue ;
57036: GO 56996
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
57038: LD_ADDR_VAR 0 8
57042: PUSH
57043: LD_EXP 99
57047: PUSH
57048: LD_VAR 0 2
57052: ARRAY
57053: PPUSH
57054: LD_INT 30
57056: PUSH
57057: LD_INT 34
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: PPUSH
57064: CALL_OW 72
57068: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
57069: LD_ADDR_VAR 0 9
57073: PUSH
57074: LD_EXP 99
57078: PUSH
57079: LD_VAR 0 2
57083: ARRAY
57084: PPUSH
57085: LD_INT 25
57087: PUSH
57088: LD_INT 4
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PPUSH
57095: CALL_OW 72
57099: PPUSH
57100: LD_INT 0
57102: PPUSH
57103: CALL 102218 0 2
57107: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
57108: LD_VAR 0 9
57112: NOT
57113: PUSH
57114: LD_VAR 0 8
57118: NOT
57119: OR
57120: PUSH
57121: LD_EXP 99
57125: PUSH
57126: LD_VAR 0 2
57130: ARRAY
57131: PPUSH
57132: LD_INT 124
57134: PPUSH
57135: CALL 102218 0 2
57139: OR
57140: IFFALSE 57144
// continue ;
57142: GO 56996
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
57144: LD_EXP 135
57148: PUSH
57149: LD_VAR 0 2
57153: ARRAY
57154: PUSH
57155: LD_EXP 134
57159: PUSH
57160: LD_VAR 0 2
57164: ARRAY
57165: LESS
57166: PUSH
57167: LD_EXP 135
57171: PUSH
57172: LD_VAR 0 2
57176: ARRAY
57177: PUSH
57178: LD_VAR 0 8
57182: LESS
57183: AND
57184: IFFALSE 57599
// begin tmp := sci [ 1 ] ;
57186: LD_ADDR_VAR 0 7
57190: PUSH
57191: LD_VAR 0 9
57195: PUSH
57196: LD_INT 1
57198: ARRAY
57199: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
57200: LD_VAR 0 7
57204: PPUSH
57205: LD_INT 124
57207: PPUSH
57208: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
57212: LD_ADDR_VAR 0 3
57216: PUSH
57217: DOUBLE
57218: LD_EXP 134
57222: PUSH
57223: LD_VAR 0 2
57227: ARRAY
57228: INC
57229: ST_TO_ADDR
57230: LD_EXP 134
57234: PUSH
57235: LD_VAR 0 2
57239: ARRAY
57240: PUSH
57241: FOR_DOWNTO
57242: IFFALSE 57585
// begin if IsInUnit ( tmp ) then
57244: LD_VAR 0 7
57248: PPUSH
57249: CALL_OW 310
57253: IFFALSE 57264
// ComExitBuilding ( tmp ) ;
57255: LD_VAR 0 7
57259: PPUSH
57260: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
57264: LD_INT 35
57266: PPUSH
57267: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
57271: LD_VAR 0 7
57275: PPUSH
57276: CALL_OW 310
57280: NOT
57281: PUSH
57282: LD_VAR 0 7
57286: PPUSH
57287: CALL_OW 314
57291: NOT
57292: AND
57293: IFFALSE 57264
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
57295: LD_ADDR_VAR 0 6
57299: PUSH
57300: LD_VAR 0 7
57304: PPUSH
57305: CALL_OW 250
57309: PUSH
57310: LD_VAR 0 7
57314: PPUSH
57315: CALL_OW 251
57319: PUSH
57320: EMPTY
57321: LIST
57322: LIST
57323: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
57324: LD_INT 35
57326: PPUSH
57327: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
57331: LD_ADDR_VAR 0 4
57335: PUSH
57336: LD_EXP 134
57340: PUSH
57341: LD_VAR 0 2
57345: ARRAY
57346: PUSH
57347: LD_VAR 0 3
57351: ARRAY
57352: PUSH
57353: LD_INT 1
57355: ARRAY
57356: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
57357: LD_ADDR_VAR 0 5
57361: PUSH
57362: LD_EXP 134
57366: PUSH
57367: LD_VAR 0 2
57371: ARRAY
57372: PUSH
57373: LD_VAR 0 3
57377: ARRAY
57378: PUSH
57379: LD_INT 2
57381: ARRAY
57382: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
57383: LD_VAR 0 7
57387: PPUSH
57388: LD_INT 10
57390: PPUSH
57391: CALL 74929 0 2
57395: PUSH
57396: LD_INT 4
57398: ARRAY
57399: IFFALSE 57437
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
57401: LD_VAR 0 7
57405: PPUSH
57406: LD_VAR 0 6
57410: PUSH
57411: LD_INT 1
57413: ARRAY
57414: PPUSH
57415: LD_VAR 0 6
57419: PUSH
57420: LD_INT 2
57422: ARRAY
57423: PPUSH
57424: CALL_OW 111
// wait ( 0 0$10 ) ;
57428: LD_INT 350
57430: PPUSH
57431: CALL_OW 67
// end else
57435: GO 57463
// begin ComMoveXY ( tmp , x , y ) ;
57437: LD_VAR 0 7
57441: PPUSH
57442: LD_VAR 0 4
57446: PPUSH
57447: LD_VAR 0 5
57451: PPUSH
57452: CALL_OW 111
// wait ( 0 0$3 ) ;
57456: LD_INT 105
57458: PPUSH
57459: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
57463: LD_VAR 0 7
57467: PPUSH
57468: LD_VAR 0 4
57472: PPUSH
57473: LD_VAR 0 5
57477: PPUSH
57478: CALL_OW 307
57482: IFFALSE 57324
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
57484: LD_VAR 0 7
57488: PPUSH
57489: LD_VAR 0 4
57493: PPUSH
57494: LD_VAR 0 5
57498: PPUSH
57499: LD_VAR 0 8
57503: PUSH
57504: LD_VAR 0 3
57508: ARRAY
57509: PPUSH
57510: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
57514: LD_INT 35
57516: PPUSH
57517: CALL_OW 67
// until not HasTask ( tmp ) ;
57521: LD_VAR 0 7
57525: PPUSH
57526: CALL_OW 314
57530: NOT
57531: IFFALSE 57514
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
57533: LD_ADDR_EXP 135
57537: PUSH
57538: LD_EXP 135
57542: PPUSH
57543: LD_VAR 0 2
57547: PUSH
57548: LD_EXP 135
57552: PUSH
57553: LD_VAR 0 2
57557: ARRAY
57558: PUSH
57559: LD_INT 1
57561: PLUS
57562: PUSH
57563: EMPTY
57564: LIST
57565: LIST
57566: PPUSH
57567: LD_VAR 0 8
57571: PUSH
57572: LD_VAR 0 3
57576: ARRAY
57577: PPUSH
57578: CALL 72332 0 3
57582: ST_TO_ADDR
// end ;
57583: GO 57241
57585: POP
57586: POP
// MC_Reset ( i , 124 ) ;
57587: LD_VAR 0 2
57591: PPUSH
57592: LD_INT 124
57594: PPUSH
57595: CALL 40692 0 2
// end ; end ;
57599: GO 56996
57601: POP
57602: POP
// end ;
57603: LD_VAR 0 1
57607: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
57608: LD_INT 0
57610: PPUSH
57611: PPUSH
57612: PPUSH
// if not mc_bases then
57613: LD_EXP 99
57617: NOT
57618: IFFALSE 57622
// exit ;
57620: GO 58228
// for i = 1 to mc_bases do
57622: LD_ADDR_VAR 0 2
57626: PUSH
57627: DOUBLE
57628: LD_INT 1
57630: DEC
57631: ST_TO_ADDR
57632: LD_EXP 99
57636: PUSH
57637: FOR_TO
57638: IFFALSE 58226
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57640: LD_ADDR_VAR 0 3
57644: PUSH
57645: LD_EXP 99
57649: PUSH
57650: LD_VAR 0 2
57654: ARRAY
57655: PPUSH
57656: LD_INT 25
57658: PUSH
57659: LD_INT 4
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: PPUSH
57666: CALL_OW 72
57670: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57671: LD_VAR 0 3
57675: NOT
57676: PUSH
57677: LD_EXP 136
57681: PUSH
57682: LD_VAR 0 2
57686: ARRAY
57687: NOT
57688: OR
57689: PUSH
57690: LD_EXP 99
57694: PUSH
57695: LD_VAR 0 2
57699: ARRAY
57700: PPUSH
57701: LD_INT 2
57703: PUSH
57704: LD_INT 30
57706: PUSH
57707: LD_INT 0
57709: PUSH
57710: EMPTY
57711: LIST
57712: LIST
57713: PUSH
57714: LD_INT 30
57716: PUSH
57717: LD_INT 1
57719: PUSH
57720: EMPTY
57721: LIST
57722: LIST
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: LIST
57728: PPUSH
57729: CALL_OW 72
57733: NOT
57734: OR
57735: IFFALSE 57785
// begin if mc_deposits_finder [ i ] then
57737: LD_EXP 137
57741: PUSH
57742: LD_VAR 0 2
57746: ARRAY
57747: IFFALSE 57783
// begin MC_Reset ( i , 125 ) ;
57749: LD_VAR 0 2
57753: PPUSH
57754: LD_INT 125
57756: PPUSH
57757: CALL 40692 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57761: LD_ADDR_EXP 137
57765: PUSH
57766: LD_EXP 137
57770: PPUSH
57771: LD_VAR 0 2
57775: PPUSH
57776: EMPTY
57777: PPUSH
57778: CALL_OW 1
57782: ST_TO_ADDR
// end ; continue ;
57783: GO 57637
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
57785: LD_EXP 136
57789: PUSH
57790: LD_VAR 0 2
57794: ARRAY
57795: PUSH
57796: LD_INT 1
57798: ARRAY
57799: PUSH
57800: LD_INT 3
57802: ARRAY
57803: PUSH
57804: LD_INT 1
57806: EQUAL
57807: PUSH
57808: LD_INT 20
57810: PPUSH
57811: LD_EXP 125
57815: PUSH
57816: LD_VAR 0 2
57820: ARRAY
57821: PPUSH
57822: CALL_OW 321
57826: PUSH
57827: LD_INT 2
57829: NONEQUAL
57830: AND
57831: IFFALSE 57881
// begin if mc_deposits_finder [ i ] then
57833: LD_EXP 137
57837: PUSH
57838: LD_VAR 0 2
57842: ARRAY
57843: IFFALSE 57879
// begin MC_Reset ( i , 125 ) ;
57845: LD_VAR 0 2
57849: PPUSH
57850: LD_INT 125
57852: PPUSH
57853: CALL 40692 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57857: LD_ADDR_EXP 137
57861: PUSH
57862: LD_EXP 137
57866: PPUSH
57867: LD_VAR 0 2
57871: PPUSH
57872: EMPTY
57873: PPUSH
57874: CALL_OW 1
57878: ST_TO_ADDR
// end ; continue ;
57879: GO 57637
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
57881: LD_EXP 136
57885: PUSH
57886: LD_VAR 0 2
57890: ARRAY
57891: PUSH
57892: LD_INT 1
57894: ARRAY
57895: PUSH
57896: LD_INT 1
57898: ARRAY
57899: PPUSH
57900: LD_EXP 136
57904: PUSH
57905: LD_VAR 0 2
57909: ARRAY
57910: PUSH
57911: LD_INT 1
57913: ARRAY
57914: PUSH
57915: LD_INT 2
57917: ARRAY
57918: PPUSH
57919: LD_EXP 125
57923: PUSH
57924: LD_VAR 0 2
57928: ARRAY
57929: PPUSH
57930: CALL_OW 440
57934: IFFALSE 57977
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
57936: LD_ADDR_EXP 136
57940: PUSH
57941: LD_EXP 136
57945: PPUSH
57946: LD_VAR 0 2
57950: PPUSH
57951: LD_EXP 136
57955: PUSH
57956: LD_VAR 0 2
57960: ARRAY
57961: PPUSH
57962: LD_INT 1
57964: PPUSH
57965: CALL_OW 3
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
57975: GO 58224
// begin if not mc_deposits_finder [ i ] then
57977: LD_EXP 137
57981: PUSH
57982: LD_VAR 0 2
57986: ARRAY
57987: NOT
57988: IFFALSE 58040
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
57990: LD_ADDR_EXP 137
57994: PUSH
57995: LD_EXP 137
57999: PPUSH
58000: LD_VAR 0 2
58004: PPUSH
58005: LD_VAR 0 3
58009: PUSH
58010: LD_INT 1
58012: ARRAY
58013: PUSH
58014: EMPTY
58015: LIST
58016: PPUSH
58017: CALL_OW 1
58021: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
58022: LD_VAR 0 3
58026: PUSH
58027: LD_INT 1
58029: ARRAY
58030: PPUSH
58031: LD_INT 125
58033: PPUSH
58034: CALL_OW 109
// end else
58038: GO 58224
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
58040: LD_EXP 137
58044: PUSH
58045: LD_VAR 0 2
58049: ARRAY
58050: PUSH
58051: LD_INT 1
58053: ARRAY
58054: PPUSH
58055: CALL_OW 310
58059: IFFALSE 58082
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
58061: LD_EXP 137
58065: PUSH
58066: LD_VAR 0 2
58070: ARRAY
58071: PUSH
58072: LD_INT 1
58074: ARRAY
58075: PPUSH
58076: CALL_OW 122
58080: GO 58224
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
58082: LD_EXP 137
58086: PUSH
58087: LD_VAR 0 2
58091: ARRAY
58092: PUSH
58093: LD_INT 1
58095: ARRAY
58096: PPUSH
58097: CALL_OW 314
58101: NOT
58102: PUSH
58103: LD_EXP 137
58107: PUSH
58108: LD_VAR 0 2
58112: ARRAY
58113: PUSH
58114: LD_INT 1
58116: ARRAY
58117: PPUSH
58118: LD_EXP 136
58122: PUSH
58123: LD_VAR 0 2
58127: ARRAY
58128: PUSH
58129: LD_INT 1
58131: ARRAY
58132: PUSH
58133: LD_INT 1
58135: ARRAY
58136: PPUSH
58137: LD_EXP 136
58141: PUSH
58142: LD_VAR 0 2
58146: ARRAY
58147: PUSH
58148: LD_INT 1
58150: ARRAY
58151: PUSH
58152: LD_INT 2
58154: ARRAY
58155: PPUSH
58156: CALL_OW 297
58160: PUSH
58161: LD_INT 6
58163: GREATER
58164: AND
58165: IFFALSE 58224
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
58167: LD_EXP 137
58171: PUSH
58172: LD_VAR 0 2
58176: ARRAY
58177: PUSH
58178: LD_INT 1
58180: ARRAY
58181: PPUSH
58182: LD_EXP 136
58186: PUSH
58187: LD_VAR 0 2
58191: ARRAY
58192: PUSH
58193: LD_INT 1
58195: ARRAY
58196: PUSH
58197: LD_INT 1
58199: ARRAY
58200: PPUSH
58201: LD_EXP 136
58205: PUSH
58206: LD_VAR 0 2
58210: ARRAY
58211: PUSH
58212: LD_INT 1
58214: ARRAY
58215: PUSH
58216: LD_INT 2
58218: ARRAY
58219: PPUSH
58220: CALL_OW 111
// end ; end ; end ;
58224: GO 57637
58226: POP
58227: POP
// end ;
58228: LD_VAR 0 1
58232: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
58233: LD_INT 0
58235: PPUSH
58236: PPUSH
58237: PPUSH
58238: PPUSH
58239: PPUSH
58240: PPUSH
58241: PPUSH
58242: PPUSH
58243: PPUSH
58244: PPUSH
58245: PPUSH
// if not mc_bases then
58246: LD_EXP 99
58250: NOT
58251: IFFALSE 58255
// exit ;
58253: GO 59195
// for i = 1 to mc_bases do
58255: LD_ADDR_VAR 0 2
58259: PUSH
58260: DOUBLE
58261: LD_INT 1
58263: DEC
58264: ST_TO_ADDR
58265: LD_EXP 99
58269: PUSH
58270: FOR_TO
58271: IFFALSE 59193
// begin if not mc_bases [ i ] or mc_scan [ i ] then
58273: LD_EXP 99
58277: PUSH
58278: LD_VAR 0 2
58282: ARRAY
58283: NOT
58284: PUSH
58285: LD_EXP 122
58289: PUSH
58290: LD_VAR 0 2
58294: ARRAY
58295: OR
58296: IFFALSE 58300
// continue ;
58298: GO 58270
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
58300: LD_ADDR_VAR 0 7
58304: PUSH
58305: LD_EXP 99
58309: PUSH
58310: LD_VAR 0 2
58314: ARRAY
58315: PUSH
58316: LD_INT 1
58318: ARRAY
58319: PPUSH
58320: CALL_OW 248
58324: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
58325: LD_VAR 0 7
58329: PUSH
58330: LD_INT 3
58332: EQUAL
58333: PUSH
58334: LD_EXP 118
58338: PUSH
58339: LD_VAR 0 2
58343: ARRAY
58344: PUSH
58345: LD_EXP 121
58349: PUSH
58350: LD_VAR 0 2
58354: ARRAY
58355: UNION
58356: PPUSH
58357: LD_INT 33
58359: PUSH
58360: LD_INT 2
58362: PUSH
58363: EMPTY
58364: LIST
58365: LIST
58366: PPUSH
58367: CALL_OW 72
58371: NOT
58372: OR
58373: IFFALSE 58377
// continue ;
58375: GO 58270
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
58377: LD_ADDR_VAR 0 9
58381: PUSH
58382: LD_EXP 99
58386: PUSH
58387: LD_VAR 0 2
58391: ARRAY
58392: PPUSH
58393: LD_INT 30
58395: PUSH
58396: LD_INT 36
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: PPUSH
58403: CALL_OW 72
58407: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
58408: LD_ADDR_VAR 0 10
58412: PUSH
58413: LD_EXP 118
58417: PUSH
58418: LD_VAR 0 2
58422: ARRAY
58423: PPUSH
58424: LD_INT 34
58426: PUSH
58427: LD_INT 31
58429: PUSH
58430: EMPTY
58431: LIST
58432: LIST
58433: PPUSH
58434: CALL_OW 72
58438: ST_TO_ADDR
// if not cts and not mcts then
58439: LD_VAR 0 9
58443: NOT
58444: PUSH
58445: LD_VAR 0 10
58449: NOT
58450: AND
58451: IFFALSE 58455
// continue ;
58453: GO 58270
// x := cts ;
58455: LD_ADDR_VAR 0 11
58459: PUSH
58460: LD_VAR 0 9
58464: ST_TO_ADDR
// if not x then
58465: LD_VAR 0 11
58469: NOT
58470: IFFALSE 58482
// x := mcts ;
58472: LD_ADDR_VAR 0 11
58476: PUSH
58477: LD_VAR 0 10
58481: ST_TO_ADDR
// if not x then
58482: LD_VAR 0 11
58486: NOT
58487: IFFALSE 58491
// continue ;
58489: GO 58270
// if mc_remote_driver [ i ] then
58491: LD_EXP 139
58495: PUSH
58496: LD_VAR 0 2
58500: ARRAY
58501: IFFALSE 58888
// for j in mc_remote_driver [ i ] do
58503: LD_ADDR_VAR 0 3
58507: PUSH
58508: LD_EXP 139
58512: PUSH
58513: LD_VAR 0 2
58517: ARRAY
58518: PUSH
58519: FOR_IN
58520: IFFALSE 58886
// begin if GetClass ( j ) <> 3 then
58522: LD_VAR 0 3
58526: PPUSH
58527: CALL_OW 257
58531: PUSH
58532: LD_INT 3
58534: NONEQUAL
58535: IFFALSE 58588
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
58537: LD_ADDR_EXP 139
58541: PUSH
58542: LD_EXP 139
58546: PPUSH
58547: LD_VAR 0 2
58551: PPUSH
58552: LD_EXP 139
58556: PUSH
58557: LD_VAR 0 2
58561: ARRAY
58562: PUSH
58563: LD_VAR 0 3
58567: DIFF
58568: PPUSH
58569: CALL_OW 1
58573: ST_TO_ADDR
// SetTag ( j , 0 ) ;
58574: LD_VAR 0 3
58578: PPUSH
58579: LD_INT 0
58581: PPUSH
58582: CALL_OW 109
// continue ;
58586: GO 58519
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
58588: LD_EXP 118
58592: PUSH
58593: LD_VAR 0 2
58597: ARRAY
58598: PPUSH
58599: LD_INT 34
58601: PUSH
58602: LD_INT 31
58604: PUSH
58605: EMPTY
58606: LIST
58607: LIST
58608: PUSH
58609: LD_INT 58
58611: PUSH
58612: EMPTY
58613: LIST
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PPUSH
58619: CALL_OW 72
58623: PUSH
58624: LD_VAR 0 3
58628: PPUSH
58629: CALL 102253 0 1
58633: NOT
58634: AND
58635: IFFALSE 58706
// begin if IsInUnit ( j ) then
58637: LD_VAR 0 3
58641: PPUSH
58642: CALL_OW 310
58646: IFFALSE 58657
// ComExitBuilding ( j ) ;
58648: LD_VAR 0 3
58652: PPUSH
58653: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
58657: LD_VAR 0 3
58661: PPUSH
58662: LD_EXP 118
58666: PUSH
58667: LD_VAR 0 2
58671: ARRAY
58672: PPUSH
58673: LD_INT 34
58675: PUSH
58676: LD_INT 31
58678: PUSH
58679: EMPTY
58680: LIST
58681: LIST
58682: PUSH
58683: LD_INT 58
58685: PUSH
58686: EMPTY
58687: LIST
58688: PUSH
58689: EMPTY
58690: LIST
58691: LIST
58692: PPUSH
58693: CALL_OW 72
58697: PUSH
58698: LD_INT 1
58700: ARRAY
58701: PPUSH
58702: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
58706: LD_VAR 0 3
58710: PPUSH
58711: CALL_OW 310
58715: NOT
58716: PUSH
58717: LD_VAR 0 3
58721: PPUSH
58722: CALL_OW 310
58726: PPUSH
58727: CALL_OW 266
58731: PUSH
58732: LD_INT 36
58734: NONEQUAL
58735: PUSH
58736: LD_VAR 0 3
58740: PPUSH
58741: CALL 102253 0 1
58745: NOT
58746: AND
58747: OR
58748: IFFALSE 58884
// begin if IsInUnit ( j ) then
58750: LD_VAR 0 3
58754: PPUSH
58755: CALL_OW 310
58759: IFFALSE 58770
// ComExitBuilding ( j ) ;
58761: LD_VAR 0 3
58765: PPUSH
58766: CALL_OW 122
// ct := 0 ;
58770: LD_ADDR_VAR 0 8
58774: PUSH
58775: LD_INT 0
58777: ST_TO_ADDR
// for k in x do
58778: LD_ADDR_VAR 0 4
58782: PUSH
58783: LD_VAR 0 11
58787: PUSH
58788: FOR_IN
58789: IFFALSE 58862
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
58791: LD_VAR 0 4
58795: PPUSH
58796: CALL_OW 264
58800: PUSH
58801: LD_INT 31
58803: EQUAL
58804: PUSH
58805: LD_VAR 0 4
58809: PPUSH
58810: CALL_OW 311
58814: NOT
58815: AND
58816: PUSH
58817: LD_VAR 0 4
58821: PPUSH
58822: CALL_OW 266
58826: PUSH
58827: LD_INT 36
58829: EQUAL
58830: PUSH
58831: LD_VAR 0 4
58835: PPUSH
58836: CALL_OW 313
58840: PUSH
58841: LD_INT 3
58843: LESS
58844: AND
58845: OR
58846: IFFALSE 58860
// begin ct := k ;
58848: LD_ADDR_VAR 0 8
58852: PUSH
58853: LD_VAR 0 4
58857: ST_TO_ADDR
// break ;
58858: GO 58862
// end ;
58860: GO 58788
58862: POP
58863: POP
// if ct then
58864: LD_VAR 0 8
58868: IFFALSE 58884
// ComEnterUnit ( j , ct ) ;
58870: LD_VAR 0 3
58874: PPUSH
58875: LD_VAR 0 8
58879: PPUSH
58880: CALL_OW 120
// end ; end ;
58884: GO 58519
58886: POP
58887: POP
// places := 0 ;
58888: LD_ADDR_VAR 0 5
58892: PUSH
58893: LD_INT 0
58895: ST_TO_ADDR
// for j = 1 to x do
58896: LD_ADDR_VAR 0 3
58900: PUSH
58901: DOUBLE
58902: LD_INT 1
58904: DEC
58905: ST_TO_ADDR
58906: LD_VAR 0 11
58910: PUSH
58911: FOR_TO
58912: IFFALSE 58988
// if GetWeapon ( x [ j ] ) = ar_control_tower then
58914: LD_VAR 0 11
58918: PUSH
58919: LD_VAR 0 3
58923: ARRAY
58924: PPUSH
58925: CALL_OW 264
58929: PUSH
58930: LD_INT 31
58932: EQUAL
58933: IFFALSE 58951
// places := places + 1 else
58935: LD_ADDR_VAR 0 5
58939: PUSH
58940: LD_VAR 0 5
58944: PUSH
58945: LD_INT 1
58947: PLUS
58948: ST_TO_ADDR
58949: GO 58986
// if GetBType ( x [ j ] ) = b_control_tower then
58951: LD_VAR 0 11
58955: PUSH
58956: LD_VAR 0 3
58960: ARRAY
58961: PPUSH
58962: CALL_OW 266
58966: PUSH
58967: LD_INT 36
58969: EQUAL
58970: IFFALSE 58986
// places := places + 3 ;
58972: LD_ADDR_VAR 0 5
58976: PUSH
58977: LD_VAR 0 5
58981: PUSH
58982: LD_INT 3
58984: PLUS
58985: ST_TO_ADDR
58986: GO 58911
58988: POP
58989: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
58990: LD_VAR 0 5
58994: PUSH
58995: LD_INT 0
58997: EQUAL
58998: PUSH
58999: LD_VAR 0 5
59003: PUSH
59004: LD_EXP 139
59008: PUSH
59009: LD_VAR 0 2
59013: ARRAY
59014: LESSEQUAL
59015: OR
59016: IFFALSE 59020
// continue ;
59018: GO 58270
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
59020: LD_ADDR_VAR 0 6
59024: PUSH
59025: LD_EXP 99
59029: PUSH
59030: LD_VAR 0 2
59034: ARRAY
59035: PPUSH
59036: LD_INT 25
59038: PUSH
59039: LD_INT 3
59041: PUSH
59042: EMPTY
59043: LIST
59044: LIST
59045: PPUSH
59046: CALL_OW 72
59050: PUSH
59051: LD_EXP 139
59055: PUSH
59056: LD_VAR 0 2
59060: ARRAY
59061: DIFF
59062: PPUSH
59063: LD_INT 3
59065: PPUSH
59066: CALL 103153 0 2
59070: ST_TO_ADDR
// for j in tmp do
59071: LD_ADDR_VAR 0 3
59075: PUSH
59076: LD_VAR 0 6
59080: PUSH
59081: FOR_IN
59082: IFFALSE 59117
// if GetTag ( j ) > 0 then
59084: LD_VAR 0 3
59088: PPUSH
59089: CALL_OW 110
59093: PUSH
59094: LD_INT 0
59096: GREATER
59097: IFFALSE 59115
// tmp := tmp diff j ;
59099: LD_ADDR_VAR 0 6
59103: PUSH
59104: LD_VAR 0 6
59108: PUSH
59109: LD_VAR 0 3
59113: DIFF
59114: ST_TO_ADDR
59115: GO 59081
59117: POP
59118: POP
// if not tmp then
59119: LD_VAR 0 6
59123: NOT
59124: IFFALSE 59128
// continue ;
59126: GO 58270
// if places then
59128: LD_VAR 0 5
59132: IFFALSE 59191
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
59134: LD_ADDR_EXP 139
59138: PUSH
59139: LD_EXP 139
59143: PPUSH
59144: LD_VAR 0 2
59148: PPUSH
59149: LD_EXP 139
59153: PUSH
59154: LD_VAR 0 2
59158: ARRAY
59159: PUSH
59160: LD_VAR 0 6
59164: PUSH
59165: LD_INT 1
59167: ARRAY
59168: UNION
59169: PPUSH
59170: CALL_OW 1
59174: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
59175: LD_VAR 0 6
59179: PUSH
59180: LD_INT 1
59182: ARRAY
59183: PPUSH
59184: LD_INT 126
59186: PPUSH
59187: CALL_OW 109
// end ; end ;
59191: GO 58270
59193: POP
59194: POP
// end ;
59195: LD_VAR 0 1
59199: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
59200: LD_INT 0
59202: PPUSH
59203: PPUSH
59204: PPUSH
59205: PPUSH
59206: PPUSH
59207: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
59208: LD_VAR 0 1
59212: NOT
59213: PUSH
59214: LD_VAR 0 2
59218: NOT
59219: OR
59220: PUSH
59221: LD_VAR 0 3
59225: NOT
59226: OR
59227: PUSH
59228: LD_VAR 0 4
59232: PUSH
59233: LD_INT 1
59235: PUSH
59236: LD_INT 2
59238: PUSH
59239: LD_INT 3
59241: PUSH
59242: LD_INT 4
59244: PUSH
59245: LD_INT 5
59247: PUSH
59248: LD_INT 8
59250: PUSH
59251: LD_INT 9
59253: PUSH
59254: LD_INT 15
59256: PUSH
59257: LD_INT 16
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: LIST
59264: LIST
59265: LIST
59266: LIST
59267: LIST
59268: LIST
59269: LIST
59270: IN
59271: NOT
59272: OR
59273: IFFALSE 59277
// exit ;
59275: GO 60177
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
59277: LD_ADDR_VAR 0 2
59281: PUSH
59282: LD_VAR 0 2
59286: PPUSH
59287: LD_INT 21
59289: PUSH
59290: LD_INT 3
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: PUSH
59297: LD_INT 24
59299: PUSH
59300: LD_INT 250
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PUSH
59307: EMPTY
59308: LIST
59309: LIST
59310: PPUSH
59311: CALL_OW 72
59315: ST_TO_ADDR
// case class of 1 , 15 :
59316: LD_VAR 0 4
59320: PUSH
59321: LD_INT 1
59323: DOUBLE
59324: EQUAL
59325: IFTRUE 59335
59327: LD_INT 15
59329: DOUBLE
59330: EQUAL
59331: IFTRUE 59335
59333: GO 59420
59335: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
59336: LD_ADDR_VAR 0 8
59340: PUSH
59341: LD_VAR 0 2
59345: PPUSH
59346: LD_INT 2
59348: PUSH
59349: LD_INT 30
59351: PUSH
59352: LD_INT 32
59354: PUSH
59355: EMPTY
59356: LIST
59357: LIST
59358: PUSH
59359: LD_INT 30
59361: PUSH
59362: LD_INT 31
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: LIST
59373: PPUSH
59374: CALL_OW 72
59378: PUSH
59379: LD_VAR 0 2
59383: PPUSH
59384: LD_INT 2
59386: PUSH
59387: LD_INT 30
59389: PUSH
59390: LD_INT 4
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PUSH
59397: LD_INT 30
59399: PUSH
59400: LD_INT 5
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: PUSH
59407: EMPTY
59408: LIST
59409: LIST
59410: LIST
59411: PPUSH
59412: CALL_OW 72
59416: ADD
59417: ST_TO_ADDR
59418: GO 59666
59420: LD_INT 2
59422: DOUBLE
59423: EQUAL
59424: IFTRUE 59434
59426: LD_INT 16
59428: DOUBLE
59429: EQUAL
59430: IFTRUE 59434
59432: GO 59480
59434: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
59435: LD_ADDR_VAR 0 8
59439: PUSH
59440: LD_VAR 0 2
59444: PPUSH
59445: LD_INT 2
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: LD_INT 0
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PUSH
59458: LD_INT 30
59460: PUSH
59461: LD_INT 1
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: LIST
59472: PPUSH
59473: CALL_OW 72
59477: ST_TO_ADDR
59478: GO 59666
59480: LD_INT 3
59482: DOUBLE
59483: EQUAL
59484: IFTRUE 59488
59486: GO 59534
59488: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
59489: LD_ADDR_VAR 0 8
59493: PUSH
59494: LD_VAR 0 2
59498: PPUSH
59499: LD_INT 2
59501: PUSH
59502: LD_INT 30
59504: PUSH
59505: LD_INT 2
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: PUSH
59512: LD_INT 30
59514: PUSH
59515: LD_INT 3
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: LIST
59526: PPUSH
59527: CALL_OW 72
59531: ST_TO_ADDR
59532: GO 59666
59534: LD_INT 4
59536: DOUBLE
59537: EQUAL
59538: IFTRUE 59542
59540: GO 59599
59542: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
59543: LD_ADDR_VAR 0 8
59547: PUSH
59548: LD_VAR 0 2
59552: PPUSH
59553: LD_INT 2
59555: PUSH
59556: LD_INT 30
59558: PUSH
59559: LD_INT 6
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PUSH
59566: LD_INT 30
59568: PUSH
59569: LD_INT 7
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: LD_INT 30
59578: PUSH
59579: LD_INT 8
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: LIST
59590: LIST
59591: PPUSH
59592: CALL_OW 72
59596: ST_TO_ADDR
59597: GO 59666
59599: LD_INT 5
59601: DOUBLE
59602: EQUAL
59603: IFTRUE 59619
59605: LD_INT 8
59607: DOUBLE
59608: EQUAL
59609: IFTRUE 59619
59611: LD_INT 9
59613: DOUBLE
59614: EQUAL
59615: IFTRUE 59619
59617: GO 59665
59619: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
59620: LD_ADDR_VAR 0 8
59624: PUSH
59625: LD_VAR 0 2
59629: PPUSH
59630: LD_INT 2
59632: PUSH
59633: LD_INT 30
59635: PUSH
59636: LD_INT 4
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 5
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: EMPTY
59654: LIST
59655: LIST
59656: LIST
59657: PPUSH
59658: CALL_OW 72
59662: ST_TO_ADDR
59663: GO 59666
59665: POP
// if not tmp then
59666: LD_VAR 0 8
59670: NOT
59671: IFFALSE 59675
// exit ;
59673: GO 60177
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
59675: LD_VAR 0 4
59679: PUSH
59680: LD_INT 1
59682: PUSH
59683: LD_INT 15
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: IN
59690: PUSH
59691: LD_EXP 108
59695: PUSH
59696: LD_VAR 0 1
59700: ARRAY
59701: AND
59702: IFFALSE 59858
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
59704: LD_ADDR_VAR 0 9
59708: PUSH
59709: LD_EXP 108
59713: PUSH
59714: LD_VAR 0 1
59718: ARRAY
59719: PUSH
59720: LD_INT 1
59722: ARRAY
59723: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
59724: LD_VAR 0 9
59728: PUSH
59729: LD_EXP 109
59733: PUSH
59734: LD_VAR 0 1
59738: ARRAY
59739: IN
59740: NOT
59741: IFFALSE 59856
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
59743: LD_ADDR_EXP 109
59747: PUSH
59748: LD_EXP 109
59752: PPUSH
59753: LD_VAR 0 1
59757: PUSH
59758: LD_EXP 109
59762: PUSH
59763: LD_VAR 0 1
59767: ARRAY
59768: PUSH
59769: LD_INT 1
59771: PLUS
59772: PUSH
59773: EMPTY
59774: LIST
59775: LIST
59776: PPUSH
59777: LD_VAR 0 9
59781: PPUSH
59782: CALL 72332 0 3
59786: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
59787: LD_ADDR_EXP 108
59791: PUSH
59792: LD_EXP 108
59796: PPUSH
59797: LD_VAR 0 1
59801: PPUSH
59802: LD_EXP 108
59806: PUSH
59807: LD_VAR 0 1
59811: ARRAY
59812: PUSH
59813: LD_VAR 0 9
59817: DIFF
59818: PPUSH
59819: CALL_OW 1
59823: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
59824: LD_VAR 0 3
59828: PPUSH
59829: LD_EXP 109
59833: PUSH
59834: LD_VAR 0 1
59838: ARRAY
59839: PUSH
59840: LD_EXP 109
59844: PUSH
59845: LD_VAR 0 1
59849: ARRAY
59850: ARRAY
59851: PPUSH
59852: CALL_OW 120
// end ; exit ;
59856: GO 60177
// end ; if tmp > 1 then
59858: LD_VAR 0 8
59862: PUSH
59863: LD_INT 1
59865: GREATER
59866: IFFALSE 59970
// for i = 2 to tmp do
59868: LD_ADDR_VAR 0 6
59872: PUSH
59873: DOUBLE
59874: LD_INT 2
59876: DEC
59877: ST_TO_ADDR
59878: LD_VAR 0 8
59882: PUSH
59883: FOR_TO
59884: IFFALSE 59968
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
59886: LD_VAR 0 8
59890: PUSH
59891: LD_VAR 0 6
59895: ARRAY
59896: PPUSH
59897: CALL_OW 461
59901: PUSH
59902: LD_INT 6
59904: EQUAL
59905: IFFALSE 59966
// begin x := tmp [ i ] ;
59907: LD_ADDR_VAR 0 9
59911: PUSH
59912: LD_VAR 0 8
59916: PUSH
59917: LD_VAR 0 6
59921: ARRAY
59922: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
59923: LD_ADDR_VAR 0 8
59927: PUSH
59928: LD_VAR 0 8
59932: PPUSH
59933: LD_VAR 0 6
59937: PPUSH
59938: CALL_OW 3
59942: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
59943: LD_ADDR_VAR 0 8
59947: PUSH
59948: LD_VAR 0 8
59952: PPUSH
59953: LD_INT 1
59955: PPUSH
59956: LD_VAR 0 9
59960: PPUSH
59961: CALL_OW 2
59965: ST_TO_ADDR
// end ;
59966: GO 59883
59968: POP
59969: POP
// for i in tmp do
59970: LD_ADDR_VAR 0 6
59974: PUSH
59975: LD_VAR 0 8
59979: PUSH
59980: FOR_IN
59981: IFFALSE 60050
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
59983: LD_VAR 0 6
59987: PPUSH
59988: CALL_OW 313
59992: PUSH
59993: LD_INT 6
59995: LESS
59996: PUSH
59997: LD_VAR 0 6
60001: PPUSH
60002: CALL_OW 266
60006: PUSH
60007: LD_INT 31
60009: PUSH
60010: LD_INT 32
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: IN
60017: NOT
60018: AND
60019: PUSH
60020: LD_VAR 0 6
60024: PPUSH
60025: CALL_OW 313
60029: PUSH
60030: LD_INT 0
60032: EQUAL
60033: OR
60034: IFFALSE 60048
// begin j := i ;
60036: LD_ADDR_VAR 0 7
60040: PUSH
60041: LD_VAR 0 6
60045: ST_TO_ADDR
// break ;
60046: GO 60050
// end ; end ;
60048: GO 59980
60050: POP
60051: POP
// if j then
60052: LD_VAR 0 7
60056: IFFALSE 60074
// ComEnterUnit ( unit , j ) else
60058: LD_VAR 0 3
60062: PPUSH
60063: LD_VAR 0 7
60067: PPUSH
60068: CALL_OW 120
60072: GO 60177
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60074: LD_ADDR_VAR 0 10
60078: PUSH
60079: LD_VAR 0 2
60083: PPUSH
60084: LD_INT 2
60086: PUSH
60087: LD_INT 30
60089: PUSH
60090: LD_INT 0
60092: PUSH
60093: EMPTY
60094: LIST
60095: LIST
60096: PUSH
60097: LD_INT 30
60099: PUSH
60100: LD_INT 1
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: PUSH
60107: EMPTY
60108: LIST
60109: LIST
60110: LIST
60111: PPUSH
60112: CALL_OW 72
60116: ST_TO_ADDR
// if depot then
60117: LD_VAR 0 10
60121: IFFALSE 60177
// begin depot := NearestUnitToUnit ( depot , unit ) ;
60123: LD_ADDR_VAR 0 10
60127: PUSH
60128: LD_VAR 0 10
60132: PPUSH
60133: LD_VAR 0 3
60137: PPUSH
60138: CALL_OW 74
60142: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
60143: LD_VAR 0 3
60147: PPUSH
60148: LD_VAR 0 10
60152: PPUSH
60153: CALL_OW 296
60157: PUSH
60158: LD_INT 10
60160: GREATER
60161: IFFALSE 60177
// ComStandNearbyBuilding ( unit , depot ) ;
60163: LD_VAR 0 3
60167: PPUSH
60168: LD_VAR 0 10
60172: PPUSH
60173: CALL 68759 0 2
// end ; end ; end ;
60177: LD_VAR 0 5
60181: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
60182: LD_INT 0
60184: PPUSH
60185: PPUSH
60186: PPUSH
60187: PPUSH
// if not mc_bases then
60188: LD_EXP 99
60192: NOT
60193: IFFALSE 60197
// exit ;
60195: GO 60436
// for i = 1 to mc_bases do
60197: LD_ADDR_VAR 0 2
60201: PUSH
60202: DOUBLE
60203: LD_INT 1
60205: DEC
60206: ST_TO_ADDR
60207: LD_EXP 99
60211: PUSH
60212: FOR_TO
60213: IFFALSE 60434
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
60215: LD_ADDR_VAR 0 4
60219: PUSH
60220: LD_EXP 99
60224: PUSH
60225: LD_VAR 0 2
60229: ARRAY
60230: PPUSH
60231: LD_INT 21
60233: PUSH
60234: LD_INT 1
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: PPUSH
60241: CALL_OW 72
60245: PUSH
60246: LD_EXP 128
60250: PUSH
60251: LD_VAR 0 2
60255: ARRAY
60256: UNION
60257: ST_TO_ADDR
// if not tmp then
60258: LD_VAR 0 4
60262: NOT
60263: IFFALSE 60267
// continue ;
60265: GO 60212
// for j in tmp do
60267: LD_ADDR_VAR 0 3
60271: PUSH
60272: LD_VAR 0 4
60276: PUSH
60277: FOR_IN
60278: IFFALSE 60430
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
60280: LD_VAR 0 3
60284: PPUSH
60285: CALL_OW 110
60289: NOT
60290: PUSH
60291: LD_VAR 0 3
60295: PPUSH
60296: CALL_OW 314
60300: NOT
60301: AND
60302: PUSH
60303: LD_VAR 0 3
60307: PPUSH
60308: CALL_OW 311
60312: NOT
60313: AND
60314: PUSH
60315: LD_VAR 0 3
60319: PPUSH
60320: CALL_OW 310
60324: NOT
60325: AND
60326: PUSH
60327: LD_VAR 0 3
60331: PUSH
60332: LD_EXP 102
60336: PUSH
60337: LD_VAR 0 2
60341: ARRAY
60342: PUSH
60343: LD_INT 1
60345: ARRAY
60346: IN
60347: NOT
60348: AND
60349: PUSH
60350: LD_VAR 0 3
60354: PUSH
60355: LD_EXP 102
60359: PUSH
60360: LD_VAR 0 2
60364: ARRAY
60365: PUSH
60366: LD_INT 2
60368: ARRAY
60369: IN
60370: NOT
60371: AND
60372: PUSH
60373: LD_VAR 0 3
60377: PUSH
60378: LD_EXP 111
60382: PUSH
60383: LD_VAR 0 2
60387: ARRAY
60388: IN
60389: NOT
60390: AND
60391: IFFALSE 60428
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
60393: LD_VAR 0 2
60397: PPUSH
60398: LD_EXP 99
60402: PUSH
60403: LD_VAR 0 2
60407: ARRAY
60408: PPUSH
60409: LD_VAR 0 3
60413: PPUSH
60414: LD_VAR 0 3
60418: PPUSH
60419: CALL_OW 257
60423: PPUSH
60424: CALL 59200 0 4
// end ;
60428: GO 60277
60430: POP
60431: POP
// end ;
60432: GO 60212
60434: POP
60435: POP
// end ;
60436: LD_VAR 0 1
60440: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
60441: LD_INT 0
60443: PPUSH
60444: PPUSH
60445: PPUSH
60446: PPUSH
60447: PPUSH
60448: PPUSH
// if not mc_bases [ base ] then
60449: LD_EXP 99
60453: PUSH
60454: LD_VAR 0 1
60458: ARRAY
60459: NOT
60460: IFFALSE 60464
// exit ;
60462: GO 60646
// tmp := [ ] ;
60464: LD_ADDR_VAR 0 6
60468: PUSH
60469: EMPTY
60470: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
60471: LD_ADDR_VAR 0 7
60475: PUSH
60476: LD_VAR 0 3
60480: PPUSH
60481: LD_INT 0
60483: PPUSH
60484: CALL_OW 517
60488: ST_TO_ADDR
// if not list then
60489: LD_VAR 0 7
60493: NOT
60494: IFFALSE 60498
// exit ;
60496: GO 60646
// for i = 1 to amount do
60498: LD_ADDR_VAR 0 5
60502: PUSH
60503: DOUBLE
60504: LD_INT 1
60506: DEC
60507: ST_TO_ADDR
60508: LD_VAR 0 2
60512: PUSH
60513: FOR_TO
60514: IFFALSE 60594
// begin x := rand ( 1 , list [ 1 ] ) ;
60516: LD_ADDR_VAR 0 8
60520: PUSH
60521: LD_INT 1
60523: PPUSH
60524: LD_VAR 0 7
60528: PUSH
60529: LD_INT 1
60531: ARRAY
60532: PPUSH
60533: CALL_OW 12
60537: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
60538: LD_ADDR_VAR 0 6
60542: PUSH
60543: LD_VAR 0 6
60547: PPUSH
60548: LD_VAR 0 5
60552: PPUSH
60553: LD_VAR 0 7
60557: PUSH
60558: LD_INT 1
60560: ARRAY
60561: PUSH
60562: LD_VAR 0 8
60566: ARRAY
60567: PUSH
60568: LD_VAR 0 7
60572: PUSH
60573: LD_INT 2
60575: ARRAY
60576: PUSH
60577: LD_VAR 0 8
60581: ARRAY
60582: PUSH
60583: EMPTY
60584: LIST
60585: LIST
60586: PPUSH
60587: CALL_OW 1
60591: ST_TO_ADDR
// end ;
60592: GO 60513
60594: POP
60595: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
60596: LD_ADDR_EXP 112
60600: PUSH
60601: LD_EXP 112
60605: PPUSH
60606: LD_VAR 0 1
60610: PPUSH
60611: LD_VAR 0 6
60615: PPUSH
60616: CALL_OW 1
60620: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
60621: LD_ADDR_EXP 114
60625: PUSH
60626: LD_EXP 114
60630: PPUSH
60631: LD_VAR 0 1
60635: PPUSH
60636: LD_VAR 0 3
60640: PPUSH
60641: CALL_OW 1
60645: ST_TO_ADDR
// end ;
60646: LD_VAR 0 4
60650: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
60651: LD_INT 0
60653: PPUSH
// if not mc_bases [ base ] then
60654: LD_EXP 99
60658: PUSH
60659: LD_VAR 0 1
60663: ARRAY
60664: NOT
60665: IFFALSE 60669
// exit ;
60667: GO 60694
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
60669: LD_ADDR_EXP 104
60673: PUSH
60674: LD_EXP 104
60678: PPUSH
60679: LD_VAR 0 1
60683: PPUSH
60684: LD_VAR 0 2
60688: PPUSH
60689: CALL_OW 1
60693: ST_TO_ADDR
// end ;
60694: LD_VAR 0 3
60698: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
60699: LD_INT 0
60701: PPUSH
// if not mc_bases [ base ] then
60702: LD_EXP 99
60706: PUSH
60707: LD_VAR 0 1
60711: ARRAY
60712: NOT
60713: IFFALSE 60717
// exit ;
60715: GO 60754
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
60717: LD_ADDR_EXP 104
60721: PUSH
60722: LD_EXP 104
60726: PPUSH
60727: LD_VAR 0 1
60731: PPUSH
60732: LD_EXP 104
60736: PUSH
60737: LD_VAR 0 1
60741: ARRAY
60742: PUSH
60743: LD_VAR 0 2
60747: UNION
60748: PPUSH
60749: CALL_OW 1
60753: ST_TO_ADDR
// end ;
60754: LD_VAR 0 3
60758: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
60759: LD_INT 0
60761: PPUSH
// if not mc_bases [ base ] then
60762: LD_EXP 99
60766: PUSH
60767: LD_VAR 0 1
60771: ARRAY
60772: NOT
60773: IFFALSE 60777
// exit ;
60775: GO 60802
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
60777: LD_ADDR_EXP 120
60781: PUSH
60782: LD_EXP 120
60786: PPUSH
60787: LD_VAR 0 1
60791: PPUSH
60792: LD_VAR 0 2
60796: PPUSH
60797: CALL_OW 1
60801: ST_TO_ADDR
// end ;
60802: LD_VAR 0 3
60806: RET
// export function MC_InsertProduceList ( base , components ) ; begin
60807: LD_INT 0
60809: PPUSH
// if not mc_bases [ base ] then
60810: LD_EXP 99
60814: PUSH
60815: LD_VAR 0 1
60819: ARRAY
60820: NOT
60821: IFFALSE 60825
// exit ;
60823: GO 60862
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
60825: LD_ADDR_EXP 120
60829: PUSH
60830: LD_EXP 120
60834: PPUSH
60835: LD_VAR 0 1
60839: PPUSH
60840: LD_EXP 120
60844: PUSH
60845: LD_VAR 0 1
60849: ARRAY
60850: PUSH
60851: LD_VAR 0 2
60855: ADD
60856: PPUSH
60857: CALL_OW 1
60861: ST_TO_ADDR
// end ;
60862: LD_VAR 0 3
60866: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
60867: LD_INT 0
60869: PPUSH
// if not mc_bases [ base ] then
60870: LD_EXP 99
60874: PUSH
60875: LD_VAR 0 1
60879: ARRAY
60880: NOT
60881: IFFALSE 60885
// exit ;
60883: GO 60939
// mc_defender := Replace ( mc_defender , base , deflist ) ;
60885: LD_ADDR_EXP 121
60889: PUSH
60890: LD_EXP 121
60894: PPUSH
60895: LD_VAR 0 1
60899: PPUSH
60900: LD_VAR 0 2
60904: PPUSH
60905: CALL_OW 1
60909: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
60910: LD_ADDR_EXP 110
60914: PUSH
60915: LD_EXP 110
60919: PPUSH
60920: LD_VAR 0 1
60924: PPUSH
60925: LD_VAR 0 2
60929: PUSH
60930: LD_INT 0
60932: PLUS
60933: PPUSH
60934: CALL_OW 1
60938: ST_TO_ADDR
// end ;
60939: LD_VAR 0 3
60943: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
60944: LD_INT 0
60946: PPUSH
// if not mc_bases [ base ] then
60947: LD_EXP 99
60951: PUSH
60952: LD_VAR 0 1
60956: ARRAY
60957: NOT
60958: IFFALSE 60962
// exit ;
60960: GO 60987
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
60962: LD_ADDR_EXP 110
60966: PUSH
60967: LD_EXP 110
60971: PPUSH
60972: LD_VAR 0 1
60976: PPUSH
60977: LD_VAR 0 2
60981: PPUSH
60982: CALL_OW 1
60986: ST_TO_ADDR
// end ;
60987: LD_VAR 0 3
60991: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
60992: LD_INT 0
60994: PPUSH
60995: PPUSH
60996: PPUSH
60997: PPUSH
// if not mc_bases [ base ] then
60998: LD_EXP 99
61002: PUSH
61003: LD_VAR 0 1
61007: ARRAY
61008: NOT
61009: IFFALSE 61013
// exit ;
61011: GO 61078
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
61013: LD_ADDR_EXP 119
61017: PUSH
61018: LD_EXP 119
61022: PPUSH
61023: LD_VAR 0 1
61027: PUSH
61028: LD_EXP 119
61032: PUSH
61033: LD_VAR 0 1
61037: ARRAY
61038: PUSH
61039: LD_INT 1
61041: PLUS
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PPUSH
61047: LD_VAR 0 1
61051: PUSH
61052: LD_VAR 0 2
61056: PUSH
61057: LD_VAR 0 3
61061: PUSH
61062: LD_VAR 0 4
61066: PUSH
61067: EMPTY
61068: LIST
61069: LIST
61070: LIST
61071: LIST
61072: PPUSH
61073: CALL 72332 0 3
61077: ST_TO_ADDR
// end ;
61078: LD_VAR 0 5
61082: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
61083: LD_INT 0
61085: PPUSH
// if not mc_bases [ base ] then
61086: LD_EXP 99
61090: PUSH
61091: LD_VAR 0 1
61095: ARRAY
61096: NOT
61097: IFFALSE 61101
// exit ;
61099: GO 61126
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
61101: LD_ADDR_EXP 136
61105: PUSH
61106: LD_EXP 136
61110: PPUSH
61111: LD_VAR 0 1
61115: PPUSH
61116: LD_VAR 0 2
61120: PPUSH
61121: CALL_OW 1
61125: ST_TO_ADDR
// end ;
61126: LD_VAR 0 3
61130: RET
// export function MC_GetMinesField ( base ) ; begin
61131: LD_INT 0
61133: PPUSH
// result := mc_mines [ base ] ;
61134: LD_ADDR_VAR 0 2
61138: PUSH
61139: LD_EXP 112
61143: PUSH
61144: LD_VAR 0 1
61148: ARRAY
61149: ST_TO_ADDR
// end ;
61150: LD_VAR 0 2
61154: RET
// export function MC_GetProduceList ( base ) ; begin
61155: LD_INT 0
61157: PPUSH
// result := mc_produce [ base ] ;
61158: LD_ADDR_VAR 0 2
61162: PUSH
61163: LD_EXP 120
61167: PUSH
61168: LD_VAR 0 1
61172: ARRAY
61173: ST_TO_ADDR
// end ;
61174: LD_VAR 0 2
61178: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
61179: LD_INT 0
61181: PPUSH
61182: PPUSH
// if not mc_bases then
61183: LD_EXP 99
61187: NOT
61188: IFFALSE 61192
// exit ;
61190: GO 61257
// if mc_bases [ base ] then
61192: LD_EXP 99
61196: PUSH
61197: LD_VAR 0 1
61201: ARRAY
61202: IFFALSE 61257
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61204: LD_ADDR_VAR 0 3
61208: PUSH
61209: LD_EXP 99
61213: PUSH
61214: LD_VAR 0 1
61218: ARRAY
61219: PPUSH
61220: LD_INT 30
61222: PUSH
61223: LD_VAR 0 2
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PPUSH
61232: CALL_OW 72
61236: ST_TO_ADDR
// if result then
61237: LD_VAR 0 3
61241: IFFALSE 61257
// result := result [ 1 ] ;
61243: LD_ADDR_VAR 0 3
61247: PUSH
61248: LD_VAR 0 3
61252: PUSH
61253: LD_INT 1
61255: ARRAY
61256: ST_TO_ADDR
// end ; end ;
61257: LD_VAR 0 3
61261: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
61262: LD_INT 0
61264: PPUSH
61265: PPUSH
// if not mc_bases then
61266: LD_EXP 99
61270: NOT
61271: IFFALSE 61275
// exit ;
61273: GO 61320
// if mc_bases [ base ] then
61275: LD_EXP 99
61279: PUSH
61280: LD_VAR 0 1
61284: ARRAY
61285: IFFALSE 61320
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61287: LD_ADDR_VAR 0 3
61291: PUSH
61292: LD_EXP 99
61296: PUSH
61297: LD_VAR 0 1
61301: ARRAY
61302: PPUSH
61303: LD_INT 30
61305: PUSH
61306: LD_VAR 0 2
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: PPUSH
61315: CALL_OW 72
61319: ST_TO_ADDR
// end ;
61320: LD_VAR 0 3
61324: RET
// export function MC_SetTame ( base , area ) ; begin
61325: LD_INT 0
61327: PPUSH
// if not mc_bases or not base then
61328: LD_EXP 99
61332: NOT
61333: PUSH
61334: LD_VAR 0 1
61338: NOT
61339: OR
61340: IFFALSE 61344
// exit ;
61342: GO 61369
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
61344: LD_ADDR_EXP 127
61348: PUSH
61349: LD_EXP 127
61353: PPUSH
61354: LD_VAR 0 1
61358: PPUSH
61359: LD_VAR 0 2
61363: PPUSH
61364: CALL_OW 1
61368: ST_TO_ADDR
// end ;
61369: LD_VAR 0 3
61373: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
61374: LD_INT 0
61376: PPUSH
61377: PPUSH
// if not mc_bases or not base then
61378: LD_EXP 99
61382: NOT
61383: PUSH
61384: LD_VAR 0 1
61388: NOT
61389: OR
61390: IFFALSE 61394
// exit ;
61392: GO 61496
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
61394: LD_ADDR_VAR 0 4
61398: PUSH
61399: LD_EXP 99
61403: PUSH
61404: LD_VAR 0 1
61408: ARRAY
61409: PPUSH
61410: LD_INT 30
61412: PUSH
61413: LD_VAR 0 2
61417: PUSH
61418: EMPTY
61419: LIST
61420: LIST
61421: PPUSH
61422: CALL_OW 72
61426: ST_TO_ADDR
// if not tmp then
61427: LD_VAR 0 4
61431: NOT
61432: IFFALSE 61436
// exit ;
61434: GO 61496
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
61436: LD_ADDR_EXP 131
61440: PUSH
61441: LD_EXP 131
61445: PPUSH
61446: LD_VAR 0 1
61450: PPUSH
61451: LD_EXP 131
61455: PUSH
61456: LD_VAR 0 1
61460: ARRAY
61461: PPUSH
61462: LD_EXP 131
61466: PUSH
61467: LD_VAR 0 1
61471: ARRAY
61472: PUSH
61473: LD_INT 1
61475: PLUS
61476: PPUSH
61477: LD_VAR 0 4
61481: PUSH
61482: LD_INT 1
61484: ARRAY
61485: PPUSH
61486: CALL_OW 2
61490: PPUSH
61491: CALL_OW 1
61495: ST_TO_ADDR
// end ;
61496: LD_VAR 0 3
61500: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
61501: LD_INT 0
61503: PPUSH
61504: PPUSH
// if not mc_bases or not base or not kinds then
61505: LD_EXP 99
61509: NOT
61510: PUSH
61511: LD_VAR 0 1
61515: NOT
61516: OR
61517: PUSH
61518: LD_VAR 0 2
61522: NOT
61523: OR
61524: IFFALSE 61528
// exit ;
61526: GO 61589
// for i in kinds do
61528: LD_ADDR_VAR 0 4
61532: PUSH
61533: LD_VAR 0 2
61537: PUSH
61538: FOR_IN
61539: IFFALSE 61587
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
61541: LD_ADDR_EXP 133
61545: PUSH
61546: LD_EXP 133
61550: PPUSH
61551: LD_VAR 0 1
61555: PUSH
61556: LD_EXP 133
61560: PUSH
61561: LD_VAR 0 1
61565: ARRAY
61566: PUSH
61567: LD_INT 1
61569: PLUS
61570: PUSH
61571: EMPTY
61572: LIST
61573: LIST
61574: PPUSH
61575: LD_VAR 0 4
61579: PPUSH
61580: CALL 72332 0 3
61584: ST_TO_ADDR
61585: GO 61538
61587: POP
61588: POP
// end ;
61589: LD_VAR 0 3
61593: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
61594: LD_INT 0
61596: PPUSH
// if not mc_bases or not base or not areas then
61597: LD_EXP 99
61601: NOT
61602: PUSH
61603: LD_VAR 0 1
61607: NOT
61608: OR
61609: PUSH
61610: LD_VAR 0 2
61614: NOT
61615: OR
61616: IFFALSE 61620
// exit ;
61618: GO 61645
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
61620: LD_ADDR_EXP 117
61624: PUSH
61625: LD_EXP 117
61629: PPUSH
61630: LD_VAR 0 1
61634: PPUSH
61635: LD_VAR 0 2
61639: PPUSH
61640: CALL_OW 1
61644: ST_TO_ADDR
// end ;
61645: LD_VAR 0 3
61649: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
61650: LD_INT 0
61652: PPUSH
// if not mc_bases or not base or not teleports_exit then
61653: LD_EXP 99
61657: NOT
61658: PUSH
61659: LD_VAR 0 1
61663: NOT
61664: OR
61665: PUSH
61666: LD_VAR 0 2
61670: NOT
61671: OR
61672: IFFALSE 61676
// exit ;
61674: GO 61701
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
61676: LD_ADDR_EXP 134
61680: PUSH
61681: LD_EXP 134
61685: PPUSH
61686: LD_VAR 0 1
61690: PPUSH
61691: LD_VAR 0 2
61695: PPUSH
61696: CALL_OW 1
61700: ST_TO_ADDR
// end ;
61701: LD_VAR 0 3
61705: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
61706: LD_INT 0
61708: PPUSH
61709: PPUSH
61710: PPUSH
// if not mc_bases or not base or not ext_list then
61711: LD_EXP 99
61715: NOT
61716: PUSH
61717: LD_VAR 0 1
61721: NOT
61722: OR
61723: PUSH
61724: LD_VAR 0 5
61728: NOT
61729: OR
61730: IFFALSE 61734
// exit ;
61732: GO 61907
// tmp := GetFacExtXYD ( x , y , d ) ;
61734: LD_ADDR_VAR 0 8
61738: PUSH
61739: LD_VAR 0 2
61743: PPUSH
61744: LD_VAR 0 3
61748: PPUSH
61749: LD_VAR 0 4
61753: PPUSH
61754: CALL 102283 0 3
61758: ST_TO_ADDR
// if not tmp then
61759: LD_VAR 0 8
61763: NOT
61764: IFFALSE 61768
// exit ;
61766: GO 61907
// for i in tmp do
61768: LD_ADDR_VAR 0 7
61772: PUSH
61773: LD_VAR 0 8
61777: PUSH
61778: FOR_IN
61779: IFFALSE 61905
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
61781: LD_ADDR_EXP 104
61785: PUSH
61786: LD_EXP 104
61790: PPUSH
61791: LD_VAR 0 1
61795: PPUSH
61796: LD_EXP 104
61800: PUSH
61801: LD_VAR 0 1
61805: ARRAY
61806: PPUSH
61807: LD_EXP 104
61811: PUSH
61812: LD_VAR 0 1
61816: ARRAY
61817: PUSH
61818: LD_INT 1
61820: PLUS
61821: PPUSH
61822: LD_VAR 0 5
61826: PUSH
61827: LD_INT 1
61829: ARRAY
61830: PUSH
61831: LD_VAR 0 7
61835: PUSH
61836: LD_INT 1
61838: ARRAY
61839: PUSH
61840: LD_VAR 0 7
61844: PUSH
61845: LD_INT 2
61847: ARRAY
61848: PUSH
61849: LD_VAR 0 7
61853: PUSH
61854: LD_INT 3
61856: ARRAY
61857: PUSH
61858: EMPTY
61859: LIST
61860: LIST
61861: LIST
61862: LIST
61863: PPUSH
61864: CALL_OW 2
61868: PPUSH
61869: CALL_OW 1
61873: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
61874: LD_ADDR_VAR 0 5
61878: PUSH
61879: LD_VAR 0 5
61883: PPUSH
61884: LD_INT 1
61886: PPUSH
61887: CALL_OW 3
61891: ST_TO_ADDR
// if not ext_list then
61892: LD_VAR 0 5
61896: NOT
61897: IFFALSE 61903
// exit ;
61899: POP
61900: POP
61901: GO 61907
// end ;
61903: GO 61778
61905: POP
61906: POP
// end ;
61907: LD_VAR 0 6
61911: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
61912: LD_INT 0
61914: PPUSH
// if not mc_bases or not base or not weapon_list then
61915: LD_EXP 99
61919: NOT
61920: PUSH
61921: LD_VAR 0 1
61925: NOT
61926: OR
61927: PUSH
61928: LD_VAR 0 2
61932: NOT
61933: OR
61934: IFFALSE 61938
// exit ;
61936: GO 61963
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
61938: LD_ADDR_EXP 138
61942: PUSH
61943: LD_EXP 138
61947: PPUSH
61948: LD_VAR 0 1
61952: PPUSH
61953: LD_VAR 0 2
61957: PPUSH
61958: CALL_OW 1
61962: ST_TO_ADDR
// end ;
61963: LD_VAR 0 3
61967: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
61968: LD_INT 0
61970: PPUSH
// if not mc_bases or not base or not tech_list then
61971: LD_EXP 99
61975: NOT
61976: PUSH
61977: LD_VAR 0 1
61981: NOT
61982: OR
61983: PUSH
61984: LD_VAR 0 2
61988: NOT
61989: OR
61990: IFFALSE 61994
// exit ;
61992: GO 62019
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
61994: LD_ADDR_EXP 126
61998: PUSH
61999: LD_EXP 126
62003: PPUSH
62004: LD_VAR 0 1
62008: PPUSH
62009: LD_VAR 0 2
62013: PPUSH
62014: CALL_OW 1
62018: ST_TO_ADDR
// end ;
62019: LD_VAR 0 3
62023: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
62024: LD_INT 0
62026: PPUSH
// if not mc_bases or not parking_area or not base then
62027: LD_EXP 99
62031: NOT
62032: PUSH
62033: LD_VAR 0 2
62037: NOT
62038: OR
62039: PUSH
62040: LD_VAR 0 1
62044: NOT
62045: OR
62046: IFFALSE 62050
// exit ;
62048: GO 62075
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
62050: LD_ADDR_EXP 123
62054: PUSH
62055: LD_EXP 123
62059: PPUSH
62060: LD_VAR 0 1
62064: PPUSH
62065: LD_VAR 0 2
62069: PPUSH
62070: CALL_OW 1
62074: ST_TO_ADDR
// end ;
62075: LD_VAR 0 3
62079: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
62080: LD_INT 0
62082: PPUSH
// if not mc_bases or not base or not scan_area then
62083: LD_EXP 99
62087: NOT
62088: PUSH
62089: LD_VAR 0 1
62093: NOT
62094: OR
62095: PUSH
62096: LD_VAR 0 2
62100: NOT
62101: OR
62102: IFFALSE 62106
// exit ;
62104: GO 62131
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
62106: LD_ADDR_EXP 124
62110: PUSH
62111: LD_EXP 124
62115: PPUSH
62116: LD_VAR 0 1
62120: PPUSH
62121: LD_VAR 0 2
62125: PPUSH
62126: CALL_OW 1
62130: ST_TO_ADDR
// end ;
62131: LD_VAR 0 3
62135: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
62136: LD_INT 0
62138: PPUSH
62139: PPUSH
// if not mc_bases or not base then
62140: LD_EXP 99
62144: NOT
62145: PUSH
62146: LD_VAR 0 1
62150: NOT
62151: OR
62152: IFFALSE 62156
// exit ;
62154: GO 62220
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
62156: LD_ADDR_VAR 0 3
62160: PUSH
62161: LD_INT 1
62163: PUSH
62164: LD_INT 2
62166: PUSH
62167: LD_INT 3
62169: PUSH
62170: LD_INT 4
62172: PUSH
62173: LD_INT 11
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: LIST
62180: LIST
62181: LIST
62182: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
62183: LD_ADDR_EXP 126
62187: PUSH
62188: LD_EXP 126
62192: PPUSH
62193: LD_VAR 0 1
62197: PPUSH
62198: LD_EXP 126
62202: PUSH
62203: LD_VAR 0 1
62207: ARRAY
62208: PUSH
62209: LD_VAR 0 3
62213: DIFF
62214: PPUSH
62215: CALL_OW 1
62219: ST_TO_ADDR
// end ;
62220: LD_VAR 0 2
62224: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
62225: LD_INT 0
62227: PPUSH
// result := mc_vehicles [ base ] ;
62228: LD_ADDR_VAR 0 3
62232: PUSH
62233: LD_EXP 118
62237: PUSH
62238: LD_VAR 0 1
62242: ARRAY
62243: ST_TO_ADDR
// if onlyCombat then
62244: LD_VAR 0 2
62248: IFFALSE 62420
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
62250: LD_ADDR_VAR 0 3
62254: PUSH
62255: LD_VAR 0 3
62259: PUSH
62260: LD_VAR 0 3
62264: PPUSH
62265: LD_INT 2
62267: PUSH
62268: LD_INT 34
62270: PUSH
62271: LD_INT 12
62273: PUSH
62274: EMPTY
62275: LIST
62276: LIST
62277: PUSH
62278: LD_INT 34
62280: PUSH
62281: LD_INT 51
62283: PUSH
62284: EMPTY
62285: LIST
62286: LIST
62287: PUSH
62288: LD_INT 34
62290: PUSH
62291: LD_INT 89
62293: PUSH
62294: EMPTY
62295: LIST
62296: LIST
62297: PUSH
62298: LD_INT 34
62300: PUSH
62301: LD_INT 32
62303: PUSH
62304: EMPTY
62305: LIST
62306: LIST
62307: PUSH
62308: LD_INT 34
62310: PUSH
62311: LD_INT 13
62313: PUSH
62314: EMPTY
62315: LIST
62316: LIST
62317: PUSH
62318: LD_INT 34
62320: PUSH
62321: LD_INT 52
62323: PUSH
62324: EMPTY
62325: LIST
62326: LIST
62327: PUSH
62328: LD_INT 34
62330: PUSH
62331: LD_INT 88
62333: PUSH
62334: EMPTY
62335: LIST
62336: LIST
62337: PUSH
62338: LD_INT 34
62340: PUSH
62341: LD_INT 14
62343: PUSH
62344: EMPTY
62345: LIST
62346: LIST
62347: PUSH
62348: LD_INT 34
62350: PUSH
62351: LD_INT 53
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: PUSH
62358: LD_INT 34
62360: PUSH
62361: LD_INT 98
62363: PUSH
62364: EMPTY
62365: LIST
62366: LIST
62367: PUSH
62368: LD_INT 34
62370: PUSH
62371: LD_INT 31
62373: PUSH
62374: EMPTY
62375: LIST
62376: LIST
62377: PUSH
62378: LD_INT 34
62380: PUSH
62381: LD_INT 48
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: PUSH
62388: LD_INT 34
62390: PUSH
62391: LD_INT 8
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PUSH
62398: EMPTY
62399: LIST
62400: LIST
62401: LIST
62402: LIST
62403: LIST
62404: LIST
62405: LIST
62406: LIST
62407: LIST
62408: LIST
62409: LIST
62410: LIST
62411: LIST
62412: LIST
62413: PPUSH
62414: CALL_OW 72
62418: DIFF
62419: ST_TO_ADDR
// end ; end_of_file
62420: LD_VAR 0 3
62424: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
62425: LD_INT 0
62427: PPUSH
62428: PPUSH
62429: PPUSH
// if not mc_bases or not skirmish then
62430: LD_EXP 99
62434: NOT
62435: PUSH
62436: LD_EXP 97
62440: NOT
62441: OR
62442: IFFALSE 62446
// exit ;
62444: GO 62611
// for i = 1 to mc_bases do
62446: LD_ADDR_VAR 0 4
62450: PUSH
62451: DOUBLE
62452: LD_INT 1
62454: DEC
62455: ST_TO_ADDR
62456: LD_EXP 99
62460: PUSH
62461: FOR_TO
62462: IFFALSE 62609
// begin if sci in mc_bases [ i ] then
62464: LD_VAR 0 2
62468: PUSH
62469: LD_EXP 99
62473: PUSH
62474: LD_VAR 0 4
62478: ARRAY
62479: IN
62480: IFFALSE 62607
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
62482: LD_ADDR_EXP 128
62486: PUSH
62487: LD_EXP 128
62491: PPUSH
62492: LD_VAR 0 4
62496: PUSH
62497: LD_EXP 128
62501: PUSH
62502: LD_VAR 0 4
62506: ARRAY
62507: PUSH
62508: LD_INT 1
62510: PLUS
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PPUSH
62516: LD_VAR 0 1
62520: PPUSH
62521: CALL 72332 0 3
62525: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
62526: LD_ADDR_VAR 0 5
62530: PUSH
62531: LD_EXP 99
62535: PUSH
62536: LD_VAR 0 4
62540: ARRAY
62541: PPUSH
62542: LD_INT 2
62544: PUSH
62545: LD_INT 30
62547: PUSH
62548: LD_INT 0
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 30
62557: PUSH
62558: LD_INT 1
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: LIST
62569: PPUSH
62570: CALL_OW 72
62574: PPUSH
62575: LD_VAR 0 1
62579: PPUSH
62580: CALL_OW 74
62584: ST_TO_ADDR
// if tmp then
62585: LD_VAR 0 5
62589: IFFALSE 62605
// ComStandNearbyBuilding ( ape , tmp ) ;
62591: LD_VAR 0 1
62595: PPUSH
62596: LD_VAR 0 5
62600: PPUSH
62601: CALL 68759 0 2
// break ;
62605: GO 62609
// end ; end ;
62607: GO 62461
62609: POP
62610: POP
// end ;
62611: LD_VAR 0 3
62615: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
62616: LD_INT 0
62618: PPUSH
62619: PPUSH
62620: PPUSH
// if not mc_bases or not skirmish then
62621: LD_EXP 99
62625: NOT
62626: PUSH
62627: LD_EXP 97
62631: NOT
62632: OR
62633: IFFALSE 62637
// exit ;
62635: GO 62726
// for i = 1 to mc_bases do
62637: LD_ADDR_VAR 0 4
62641: PUSH
62642: DOUBLE
62643: LD_INT 1
62645: DEC
62646: ST_TO_ADDR
62647: LD_EXP 99
62651: PUSH
62652: FOR_TO
62653: IFFALSE 62724
// begin if building in mc_busy_turret_list [ i ] then
62655: LD_VAR 0 1
62659: PUSH
62660: LD_EXP 109
62664: PUSH
62665: LD_VAR 0 4
62669: ARRAY
62670: IN
62671: IFFALSE 62722
// begin tmp := mc_busy_turret_list [ i ] diff building ;
62673: LD_ADDR_VAR 0 5
62677: PUSH
62678: LD_EXP 109
62682: PUSH
62683: LD_VAR 0 4
62687: ARRAY
62688: PUSH
62689: LD_VAR 0 1
62693: DIFF
62694: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
62695: LD_ADDR_EXP 109
62699: PUSH
62700: LD_EXP 109
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: LD_VAR 0 5
62714: PPUSH
62715: CALL_OW 1
62719: ST_TO_ADDR
// break ;
62720: GO 62724
// end ; end ;
62722: GO 62652
62724: POP
62725: POP
// end ;
62726: LD_VAR 0 3
62730: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
62731: LD_INT 0
62733: PPUSH
62734: PPUSH
62735: PPUSH
// if not mc_bases or not skirmish then
62736: LD_EXP 99
62740: NOT
62741: PUSH
62742: LD_EXP 97
62746: NOT
62747: OR
62748: IFFALSE 62752
// exit ;
62750: GO 62951
// for i = 1 to mc_bases do
62752: LD_ADDR_VAR 0 5
62756: PUSH
62757: DOUBLE
62758: LD_INT 1
62760: DEC
62761: ST_TO_ADDR
62762: LD_EXP 99
62766: PUSH
62767: FOR_TO
62768: IFFALSE 62949
// if building in mc_bases [ i ] then
62770: LD_VAR 0 1
62774: PUSH
62775: LD_EXP 99
62779: PUSH
62780: LD_VAR 0 5
62784: ARRAY
62785: IN
62786: IFFALSE 62947
// begin tmp := mc_bases [ i ] diff building ;
62788: LD_ADDR_VAR 0 6
62792: PUSH
62793: LD_EXP 99
62797: PUSH
62798: LD_VAR 0 5
62802: ARRAY
62803: PUSH
62804: LD_VAR 0 1
62808: DIFF
62809: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
62810: LD_ADDR_EXP 99
62814: PUSH
62815: LD_EXP 99
62819: PPUSH
62820: LD_VAR 0 5
62824: PPUSH
62825: LD_VAR 0 6
62829: PPUSH
62830: CALL_OW 1
62834: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
62835: LD_VAR 0 1
62839: PUSH
62840: LD_EXP 107
62844: PUSH
62845: LD_VAR 0 5
62849: ARRAY
62850: IN
62851: IFFALSE 62890
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
62853: LD_ADDR_EXP 107
62857: PUSH
62858: LD_EXP 107
62862: PPUSH
62863: LD_VAR 0 5
62867: PPUSH
62868: LD_EXP 107
62872: PUSH
62873: LD_VAR 0 5
62877: ARRAY
62878: PUSH
62879: LD_VAR 0 1
62883: DIFF
62884: PPUSH
62885: CALL_OW 1
62889: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
62890: LD_VAR 0 1
62894: PUSH
62895: LD_EXP 108
62899: PUSH
62900: LD_VAR 0 5
62904: ARRAY
62905: IN
62906: IFFALSE 62945
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
62908: LD_ADDR_EXP 108
62912: PUSH
62913: LD_EXP 108
62917: PPUSH
62918: LD_VAR 0 5
62922: PPUSH
62923: LD_EXP 108
62927: PUSH
62928: LD_VAR 0 5
62932: ARRAY
62933: PUSH
62934: LD_VAR 0 1
62938: DIFF
62939: PPUSH
62940: CALL_OW 1
62944: ST_TO_ADDR
// break ;
62945: GO 62949
// end ;
62947: GO 62767
62949: POP
62950: POP
// end ;
62951: LD_VAR 0 4
62955: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
62956: LD_INT 0
62958: PPUSH
62959: PPUSH
62960: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
62961: LD_EXP 99
62965: NOT
62966: PUSH
62967: LD_EXP 97
62971: NOT
62972: OR
62973: PUSH
62974: LD_VAR 0 3
62978: PUSH
62979: LD_EXP 125
62983: IN
62984: NOT
62985: OR
62986: IFFALSE 62990
// exit ;
62988: GO 63113
// for i = 1 to mc_vehicles do
62990: LD_ADDR_VAR 0 6
62994: PUSH
62995: DOUBLE
62996: LD_INT 1
62998: DEC
62999: ST_TO_ADDR
63000: LD_EXP 118
63004: PUSH
63005: FOR_TO
63006: IFFALSE 63111
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
63008: LD_VAR 0 2
63012: PUSH
63013: LD_EXP 118
63017: PUSH
63018: LD_VAR 0 6
63022: ARRAY
63023: IN
63024: PUSH
63025: LD_VAR 0 1
63029: PUSH
63030: LD_EXP 118
63034: PUSH
63035: LD_VAR 0 6
63039: ARRAY
63040: IN
63041: OR
63042: IFFALSE 63109
// begin tmp := mc_vehicles [ i ] diff old ;
63044: LD_ADDR_VAR 0 7
63048: PUSH
63049: LD_EXP 118
63053: PUSH
63054: LD_VAR 0 6
63058: ARRAY
63059: PUSH
63060: LD_VAR 0 2
63064: DIFF
63065: ST_TO_ADDR
// tmp := tmp diff new ;
63066: LD_ADDR_VAR 0 7
63070: PUSH
63071: LD_VAR 0 7
63075: PUSH
63076: LD_VAR 0 1
63080: DIFF
63081: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
63082: LD_ADDR_EXP 118
63086: PUSH
63087: LD_EXP 118
63091: PPUSH
63092: LD_VAR 0 6
63096: PPUSH
63097: LD_VAR 0 7
63101: PPUSH
63102: CALL_OW 1
63106: ST_TO_ADDR
// break ;
63107: GO 63111
// end ;
63109: GO 63005
63111: POP
63112: POP
// end ;
63113: LD_VAR 0 5
63117: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
63118: LD_INT 0
63120: PPUSH
63121: PPUSH
63122: PPUSH
63123: PPUSH
// if not mc_bases or not skirmish then
63124: LD_EXP 99
63128: NOT
63129: PUSH
63130: LD_EXP 97
63134: NOT
63135: OR
63136: IFFALSE 63140
// exit ;
63138: GO 63522
// side := GetSide ( vehicle ) ;
63140: LD_ADDR_VAR 0 5
63144: PUSH
63145: LD_VAR 0 1
63149: PPUSH
63150: CALL_OW 255
63154: ST_TO_ADDR
// for i = 1 to mc_bases do
63155: LD_ADDR_VAR 0 4
63159: PUSH
63160: DOUBLE
63161: LD_INT 1
63163: DEC
63164: ST_TO_ADDR
63165: LD_EXP 99
63169: PUSH
63170: FOR_TO
63171: IFFALSE 63520
// begin if factory in mc_bases [ i ] then
63173: LD_VAR 0 2
63177: PUSH
63178: LD_EXP 99
63182: PUSH
63183: LD_VAR 0 4
63187: ARRAY
63188: IN
63189: IFFALSE 63518
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
63191: LD_EXP 121
63195: PUSH
63196: LD_VAR 0 4
63200: ARRAY
63201: PUSH
63202: LD_EXP 110
63206: PUSH
63207: LD_VAR 0 4
63211: ARRAY
63212: LESS
63213: PUSH
63214: LD_VAR 0 1
63218: PPUSH
63219: CALL_OW 264
63223: PUSH
63224: LD_INT 31
63226: PUSH
63227: LD_INT 32
63229: PUSH
63230: LD_INT 51
63232: PUSH
63233: LD_INT 89
63235: PUSH
63236: LD_INT 12
63238: PUSH
63239: LD_INT 30
63241: PUSH
63242: LD_INT 98
63244: PUSH
63245: LD_INT 11
63247: PUSH
63248: LD_INT 53
63250: PUSH
63251: LD_INT 14
63253: PUSH
63254: LD_INT 91
63256: PUSH
63257: LD_INT 29
63259: PUSH
63260: LD_INT 99
63262: PUSH
63263: LD_INT 13
63265: PUSH
63266: LD_INT 52
63268: PUSH
63269: LD_INT 88
63271: PUSH
63272: LD_INT 48
63274: PUSH
63275: LD_INT 8
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: LIST
63282: LIST
63283: LIST
63284: LIST
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: LIST
63290: LIST
63291: LIST
63292: LIST
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: IN
63298: NOT
63299: AND
63300: IFFALSE 63348
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
63302: LD_ADDR_EXP 121
63306: PUSH
63307: LD_EXP 121
63311: PPUSH
63312: LD_VAR 0 4
63316: PUSH
63317: LD_EXP 121
63321: PUSH
63322: LD_VAR 0 4
63326: ARRAY
63327: PUSH
63328: LD_INT 1
63330: PLUS
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PPUSH
63336: LD_VAR 0 1
63340: PPUSH
63341: CALL 72332 0 3
63345: ST_TO_ADDR
63346: GO 63392
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
63348: LD_ADDR_EXP 118
63352: PUSH
63353: LD_EXP 118
63357: PPUSH
63358: LD_VAR 0 4
63362: PUSH
63363: LD_EXP 118
63367: PUSH
63368: LD_VAR 0 4
63372: ARRAY
63373: PUSH
63374: LD_INT 1
63376: PLUS
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PPUSH
63382: LD_VAR 0 1
63386: PPUSH
63387: CALL 72332 0 3
63391: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
63392: LD_VAR 0 1
63396: PPUSH
63397: CALL_OW 263
63401: PUSH
63402: LD_INT 2
63404: EQUAL
63405: IFFALSE 63434
// begin repeat wait ( 0 0$3 ) ;
63407: LD_INT 105
63409: PPUSH
63410: CALL_OW 67
// Connect ( vehicle ) ;
63414: LD_VAR 0 1
63418: PPUSH
63419: CALL 75301 0 1
// until IsControledBy ( vehicle ) ;
63423: LD_VAR 0 1
63427: PPUSH
63428: CALL_OW 312
63432: IFFALSE 63407
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
63434: LD_VAR 0 1
63438: PPUSH
63439: LD_EXP 123
63443: PUSH
63444: LD_VAR 0 4
63448: ARRAY
63449: PPUSH
63450: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
63454: LD_VAR 0 1
63458: PPUSH
63459: CALL_OW 263
63463: PUSH
63464: LD_INT 1
63466: NONEQUAL
63467: IFFALSE 63471
// break ;
63469: GO 63520
// repeat wait ( 0 0$1 ) ;
63471: LD_INT 35
63473: PPUSH
63474: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
63478: LD_VAR 0 1
63482: PPUSH
63483: LD_EXP 123
63487: PUSH
63488: LD_VAR 0 4
63492: ARRAY
63493: PPUSH
63494: CALL_OW 308
63498: IFFALSE 63471
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
63500: LD_VAR 0 1
63504: PPUSH
63505: CALL_OW 311
63509: PPUSH
63510: CALL_OW 121
// exit ;
63514: POP
63515: POP
63516: GO 63522
// end ; end ;
63518: GO 63170
63520: POP
63521: POP
// end ;
63522: LD_VAR 0 3
63526: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
63527: LD_INT 0
63529: PPUSH
63530: PPUSH
63531: PPUSH
63532: PPUSH
// if not mc_bases or not skirmish then
63533: LD_EXP 99
63537: NOT
63538: PUSH
63539: LD_EXP 97
63543: NOT
63544: OR
63545: IFFALSE 63549
// exit ;
63547: GO 63902
// repeat wait ( 0 0$1 ) ;
63549: LD_INT 35
63551: PPUSH
63552: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
63556: LD_VAR 0 2
63560: PPUSH
63561: LD_VAR 0 3
63565: PPUSH
63566: CALL_OW 284
63570: IFFALSE 63549
// if GetResourceTypeXY ( x , y ) = mat_artefact then
63572: LD_VAR 0 2
63576: PPUSH
63577: LD_VAR 0 3
63581: PPUSH
63582: CALL_OW 283
63586: PUSH
63587: LD_INT 4
63589: EQUAL
63590: IFFALSE 63594
// exit ;
63592: GO 63902
// for i = 1 to mc_bases do
63594: LD_ADDR_VAR 0 7
63598: PUSH
63599: DOUBLE
63600: LD_INT 1
63602: DEC
63603: ST_TO_ADDR
63604: LD_EXP 99
63608: PUSH
63609: FOR_TO
63610: IFFALSE 63900
// begin if mc_crates_area [ i ] then
63612: LD_EXP 117
63616: PUSH
63617: LD_VAR 0 7
63621: ARRAY
63622: IFFALSE 63733
// for j in mc_crates_area [ i ] do
63624: LD_ADDR_VAR 0 8
63628: PUSH
63629: LD_EXP 117
63633: PUSH
63634: LD_VAR 0 7
63638: ARRAY
63639: PUSH
63640: FOR_IN
63641: IFFALSE 63731
// if InArea ( x , y , j ) then
63643: LD_VAR 0 2
63647: PPUSH
63648: LD_VAR 0 3
63652: PPUSH
63653: LD_VAR 0 8
63657: PPUSH
63658: CALL_OW 309
63662: IFFALSE 63729
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63664: LD_ADDR_EXP 115
63668: PUSH
63669: LD_EXP 115
63673: PPUSH
63674: LD_VAR 0 7
63678: PUSH
63679: LD_EXP 115
63683: PUSH
63684: LD_VAR 0 7
63688: ARRAY
63689: PUSH
63690: LD_INT 1
63692: PLUS
63693: PUSH
63694: EMPTY
63695: LIST
63696: LIST
63697: PPUSH
63698: LD_VAR 0 4
63702: PUSH
63703: LD_VAR 0 2
63707: PUSH
63708: LD_VAR 0 3
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: LIST
63717: PPUSH
63718: CALL 72332 0 3
63722: ST_TO_ADDR
// exit ;
63723: POP
63724: POP
63725: POP
63726: POP
63727: GO 63902
// end ;
63729: GO 63640
63731: POP
63732: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63733: LD_ADDR_VAR 0 9
63737: PUSH
63738: LD_EXP 99
63742: PUSH
63743: LD_VAR 0 7
63747: ARRAY
63748: PPUSH
63749: LD_INT 2
63751: PUSH
63752: LD_INT 30
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: PUSH
63762: LD_INT 30
63764: PUSH
63765: LD_INT 1
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PUSH
63772: EMPTY
63773: LIST
63774: LIST
63775: LIST
63776: PPUSH
63777: CALL_OW 72
63781: ST_TO_ADDR
// if not depot then
63782: LD_VAR 0 9
63786: NOT
63787: IFFALSE 63791
// continue ;
63789: GO 63609
// for j in depot do
63791: LD_ADDR_VAR 0 8
63795: PUSH
63796: LD_VAR 0 9
63800: PUSH
63801: FOR_IN
63802: IFFALSE 63896
// if GetDistUnitXY ( j , x , y ) < 30 then
63804: LD_VAR 0 8
63808: PPUSH
63809: LD_VAR 0 2
63813: PPUSH
63814: LD_VAR 0 3
63818: PPUSH
63819: CALL_OW 297
63823: PUSH
63824: LD_INT 30
63826: LESS
63827: IFFALSE 63894
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
63829: LD_ADDR_EXP 115
63833: PUSH
63834: LD_EXP 115
63838: PPUSH
63839: LD_VAR 0 7
63843: PUSH
63844: LD_EXP 115
63848: PUSH
63849: LD_VAR 0 7
63853: ARRAY
63854: PUSH
63855: LD_INT 1
63857: PLUS
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PPUSH
63863: LD_VAR 0 4
63867: PUSH
63868: LD_VAR 0 2
63872: PUSH
63873: LD_VAR 0 3
63877: PUSH
63878: EMPTY
63879: LIST
63880: LIST
63881: LIST
63882: PPUSH
63883: CALL 72332 0 3
63887: ST_TO_ADDR
// exit ;
63888: POP
63889: POP
63890: POP
63891: POP
63892: GO 63902
// end ;
63894: GO 63801
63896: POP
63897: POP
// end ;
63898: GO 63609
63900: POP
63901: POP
// end ;
63902: LD_VAR 0 6
63906: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
63907: LD_INT 0
63909: PPUSH
63910: PPUSH
63911: PPUSH
63912: PPUSH
// if not mc_bases or not skirmish then
63913: LD_EXP 99
63917: NOT
63918: PUSH
63919: LD_EXP 97
63923: NOT
63924: OR
63925: IFFALSE 63929
// exit ;
63927: GO 64206
// side := GetSide ( lab ) ;
63929: LD_ADDR_VAR 0 4
63933: PUSH
63934: LD_VAR 0 2
63938: PPUSH
63939: CALL_OW 255
63943: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
63944: LD_VAR 0 4
63948: PUSH
63949: LD_EXP 125
63953: IN
63954: NOT
63955: PUSH
63956: LD_EXP 126
63960: NOT
63961: OR
63962: PUSH
63963: LD_EXP 99
63967: NOT
63968: OR
63969: IFFALSE 63973
// exit ;
63971: GO 64206
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
63973: LD_ADDR_EXP 126
63977: PUSH
63978: LD_EXP 126
63982: PPUSH
63983: LD_VAR 0 4
63987: PPUSH
63988: LD_EXP 126
63992: PUSH
63993: LD_VAR 0 4
63997: ARRAY
63998: PUSH
63999: LD_VAR 0 1
64003: DIFF
64004: PPUSH
64005: CALL_OW 1
64009: ST_TO_ADDR
// for i = 1 to mc_bases do
64010: LD_ADDR_VAR 0 5
64014: PUSH
64015: DOUBLE
64016: LD_INT 1
64018: DEC
64019: ST_TO_ADDR
64020: LD_EXP 99
64024: PUSH
64025: FOR_TO
64026: IFFALSE 64204
// begin if lab in mc_bases [ i ] then
64028: LD_VAR 0 2
64032: PUSH
64033: LD_EXP 99
64037: PUSH
64038: LD_VAR 0 5
64042: ARRAY
64043: IN
64044: IFFALSE 64202
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
64046: LD_VAR 0 1
64050: PUSH
64051: LD_INT 11
64053: PUSH
64054: LD_INT 4
64056: PUSH
64057: LD_INT 3
64059: PUSH
64060: LD_INT 2
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: LIST
64067: LIST
64068: IN
64069: PUSH
64070: LD_EXP 129
64074: PUSH
64075: LD_VAR 0 5
64079: ARRAY
64080: AND
64081: IFFALSE 64202
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
64083: LD_ADDR_VAR 0 6
64087: PUSH
64088: LD_EXP 129
64092: PUSH
64093: LD_VAR 0 5
64097: ARRAY
64098: PUSH
64099: LD_INT 1
64101: ARRAY
64102: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64103: LD_ADDR_EXP 129
64107: PUSH
64108: LD_EXP 129
64112: PPUSH
64113: LD_VAR 0 5
64117: PPUSH
64118: EMPTY
64119: PPUSH
64120: CALL_OW 1
64124: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
64125: LD_VAR 0 6
64129: PPUSH
64130: LD_INT 0
64132: PPUSH
64133: CALL_OW 109
// ComExitBuilding ( tmp ) ;
64137: LD_VAR 0 6
64141: PPUSH
64142: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
64146: LD_ADDR_EXP 128
64150: PUSH
64151: LD_EXP 128
64155: PPUSH
64156: LD_VAR 0 5
64160: PPUSH
64161: LD_EXP 128
64165: PUSH
64166: LD_VAR 0 5
64170: ARRAY
64171: PPUSH
64172: LD_INT 1
64174: PPUSH
64175: LD_VAR 0 6
64179: PPUSH
64180: CALL_OW 2
64184: PPUSH
64185: CALL_OW 1
64189: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
64190: LD_VAR 0 5
64194: PPUSH
64195: LD_INT 112
64197: PPUSH
64198: CALL 40692 0 2
// end ; end ; end ;
64202: GO 64025
64204: POP
64205: POP
// end ;
64206: LD_VAR 0 3
64210: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
64211: LD_INT 0
64213: PPUSH
64214: PPUSH
64215: PPUSH
64216: PPUSH
64217: PPUSH
64218: PPUSH
64219: PPUSH
64220: PPUSH
// if not mc_bases or not skirmish then
64221: LD_EXP 99
64225: NOT
64226: PUSH
64227: LD_EXP 97
64231: NOT
64232: OR
64233: IFFALSE 64237
// exit ;
64235: GO 65606
// for i = 1 to mc_bases do
64237: LD_ADDR_VAR 0 3
64241: PUSH
64242: DOUBLE
64243: LD_INT 1
64245: DEC
64246: ST_TO_ADDR
64247: LD_EXP 99
64251: PUSH
64252: FOR_TO
64253: IFFALSE 65604
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
64255: LD_VAR 0 1
64259: PUSH
64260: LD_EXP 99
64264: PUSH
64265: LD_VAR 0 3
64269: ARRAY
64270: IN
64271: PUSH
64272: LD_VAR 0 1
64276: PUSH
64277: LD_EXP 106
64281: PUSH
64282: LD_VAR 0 3
64286: ARRAY
64287: IN
64288: OR
64289: PUSH
64290: LD_VAR 0 1
64294: PUSH
64295: LD_EXP 121
64299: PUSH
64300: LD_VAR 0 3
64304: ARRAY
64305: IN
64306: OR
64307: PUSH
64308: LD_VAR 0 1
64312: PUSH
64313: LD_EXP 118
64317: PUSH
64318: LD_VAR 0 3
64322: ARRAY
64323: IN
64324: OR
64325: PUSH
64326: LD_VAR 0 1
64330: PUSH
64331: LD_EXP 128
64335: PUSH
64336: LD_VAR 0 3
64340: ARRAY
64341: IN
64342: OR
64343: PUSH
64344: LD_VAR 0 1
64348: PUSH
64349: LD_EXP 129
64353: PUSH
64354: LD_VAR 0 3
64358: ARRAY
64359: IN
64360: OR
64361: IFFALSE 65602
// begin if un in mc_ape [ i ] then
64363: LD_VAR 0 1
64367: PUSH
64368: LD_EXP 128
64372: PUSH
64373: LD_VAR 0 3
64377: ARRAY
64378: IN
64379: IFFALSE 64418
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
64381: LD_ADDR_EXP 128
64385: PUSH
64386: LD_EXP 128
64390: PPUSH
64391: LD_VAR 0 3
64395: PPUSH
64396: LD_EXP 128
64400: PUSH
64401: LD_VAR 0 3
64405: ARRAY
64406: PUSH
64407: LD_VAR 0 1
64411: DIFF
64412: PPUSH
64413: CALL_OW 1
64417: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
64418: LD_VAR 0 1
64422: PUSH
64423: LD_EXP 129
64427: PUSH
64428: LD_VAR 0 3
64432: ARRAY
64433: IN
64434: IFFALSE 64458
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64436: LD_ADDR_EXP 129
64440: PUSH
64441: LD_EXP 129
64445: PPUSH
64446: LD_VAR 0 3
64450: PPUSH
64451: EMPTY
64452: PPUSH
64453: CALL_OW 1
64457: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
64458: LD_VAR 0 1
64462: PPUSH
64463: CALL_OW 247
64467: PUSH
64468: LD_INT 2
64470: EQUAL
64471: PUSH
64472: LD_VAR 0 1
64476: PPUSH
64477: CALL_OW 110
64481: PUSH
64482: LD_INT 20
64484: EQUAL
64485: PUSH
64486: LD_VAR 0 1
64490: PUSH
64491: LD_EXP 121
64495: PUSH
64496: LD_VAR 0 3
64500: ARRAY
64501: IN
64502: OR
64503: PUSH
64504: LD_VAR 0 1
64508: PPUSH
64509: CALL_OW 264
64513: PUSH
64514: LD_INT 12
64516: PUSH
64517: LD_INT 51
64519: PUSH
64520: LD_INT 89
64522: PUSH
64523: LD_INT 32
64525: PUSH
64526: LD_INT 13
64528: PUSH
64529: LD_INT 52
64531: PUSH
64532: LD_INT 31
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: IN
64544: OR
64545: AND
64546: IFFALSE 64854
// begin if un in mc_defender [ i ] then
64548: LD_VAR 0 1
64552: PUSH
64553: LD_EXP 121
64557: PUSH
64558: LD_VAR 0 3
64562: ARRAY
64563: IN
64564: IFFALSE 64603
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64566: LD_ADDR_EXP 121
64570: PUSH
64571: LD_EXP 121
64575: PPUSH
64576: LD_VAR 0 3
64580: PPUSH
64581: LD_EXP 121
64585: PUSH
64586: LD_VAR 0 3
64590: ARRAY
64591: PUSH
64592: LD_VAR 0 1
64596: DIFF
64597: PPUSH
64598: CALL_OW 1
64602: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
64603: LD_ADDR_VAR 0 8
64607: PUSH
64608: LD_VAR 0 3
64612: PPUSH
64613: LD_INT 3
64615: PPUSH
64616: CALL 61262 0 2
64620: ST_TO_ADDR
// if fac then
64621: LD_VAR 0 8
64625: IFFALSE 64854
// begin for j in fac do
64627: LD_ADDR_VAR 0 4
64631: PUSH
64632: LD_VAR 0 8
64636: PUSH
64637: FOR_IN
64638: IFFALSE 64852
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
64640: LD_ADDR_VAR 0 9
64644: PUSH
64645: LD_VAR 0 8
64649: PPUSH
64650: LD_VAR 0 1
64654: PPUSH
64655: CALL_OW 265
64659: PPUSH
64660: LD_VAR 0 1
64664: PPUSH
64665: CALL_OW 262
64669: PPUSH
64670: LD_VAR 0 1
64674: PPUSH
64675: CALL_OW 263
64679: PPUSH
64680: LD_VAR 0 1
64684: PPUSH
64685: CALL_OW 264
64689: PPUSH
64690: CALL 69830 0 5
64694: ST_TO_ADDR
// if components then
64695: LD_VAR 0 9
64699: IFFALSE 64850
// begin if GetWeapon ( un ) = ar_control_tower then
64701: LD_VAR 0 1
64705: PPUSH
64706: CALL_OW 264
64710: PUSH
64711: LD_INT 31
64713: EQUAL
64714: IFFALSE 64831
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
64716: LD_VAR 0 1
64720: PPUSH
64721: CALL_OW 311
64725: PPUSH
64726: LD_INT 0
64728: PPUSH
64729: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
64733: LD_ADDR_EXP 139
64737: PUSH
64738: LD_EXP 139
64742: PPUSH
64743: LD_VAR 0 3
64747: PPUSH
64748: LD_EXP 139
64752: PUSH
64753: LD_VAR 0 3
64757: ARRAY
64758: PUSH
64759: LD_VAR 0 1
64763: PPUSH
64764: CALL_OW 311
64768: DIFF
64769: PPUSH
64770: CALL_OW 1
64774: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
64775: LD_ADDR_VAR 0 7
64779: PUSH
64780: LD_EXP 120
64784: PUSH
64785: LD_VAR 0 3
64789: ARRAY
64790: PPUSH
64791: LD_INT 1
64793: PPUSH
64794: LD_VAR 0 9
64798: PPUSH
64799: CALL_OW 2
64803: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
64804: LD_ADDR_EXP 120
64808: PUSH
64809: LD_EXP 120
64813: PPUSH
64814: LD_VAR 0 3
64818: PPUSH
64819: LD_VAR 0 7
64823: PPUSH
64824: CALL_OW 1
64828: ST_TO_ADDR
// end else
64829: GO 64848
// MC_InsertProduceList ( i , [ components ] ) ;
64831: LD_VAR 0 3
64835: PPUSH
64836: LD_VAR 0 9
64840: PUSH
64841: EMPTY
64842: LIST
64843: PPUSH
64844: CALL 60807 0 2
// break ;
64848: GO 64852
// end ; end ;
64850: GO 64637
64852: POP
64853: POP
// end ; end ; if GetType ( un ) = unit_building then
64854: LD_VAR 0 1
64858: PPUSH
64859: CALL_OW 247
64863: PUSH
64864: LD_INT 3
64866: EQUAL
64867: IFFALSE 65270
// begin btype := GetBType ( un ) ;
64869: LD_ADDR_VAR 0 5
64873: PUSH
64874: LD_VAR 0 1
64878: PPUSH
64879: CALL_OW 266
64883: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
64884: LD_VAR 0 5
64888: PUSH
64889: LD_INT 29
64891: PUSH
64892: LD_INT 30
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: IN
64899: IFFALSE 64972
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
64901: LD_VAR 0 1
64905: PPUSH
64906: CALL_OW 250
64910: PPUSH
64911: LD_VAR 0 1
64915: PPUSH
64916: CALL_OW 251
64920: PPUSH
64921: LD_VAR 0 1
64925: PPUSH
64926: CALL_OW 255
64930: PPUSH
64931: CALL_OW 440
64935: NOT
64936: IFFALSE 64972
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
64938: LD_VAR 0 1
64942: PPUSH
64943: CALL_OW 250
64947: PPUSH
64948: LD_VAR 0 1
64952: PPUSH
64953: CALL_OW 251
64957: PPUSH
64958: LD_VAR 0 1
64962: PPUSH
64963: CALL_OW 255
64967: PPUSH
64968: CALL_OW 441
// end ; if btype = b_warehouse then
64972: LD_VAR 0 5
64976: PUSH
64977: LD_INT 1
64979: EQUAL
64980: IFFALSE 64998
// begin btype := b_depot ;
64982: LD_ADDR_VAR 0 5
64986: PUSH
64987: LD_INT 0
64989: ST_TO_ADDR
// pos := 1 ;
64990: LD_ADDR_VAR 0 6
64994: PUSH
64995: LD_INT 1
64997: ST_TO_ADDR
// end ; if btype = b_factory then
64998: LD_VAR 0 5
65002: PUSH
65003: LD_INT 3
65005: EQUAL
65006: IFFALSE 65024
// begin btype := b_workshop ;
65008: LD_ADDR_VAR 0 5
65012: PUSH
65013: LD_INT 2
65015: ST_TO_ADDR
// pos := 1 ;
65016: LD_ADDR_VAR 0 6
65020: PUSH
65021: LD_INT 1
65023: ST_TO_ADDR
// end ; if btype = b_barracks then
65024: LD_VAR 0 5
65028: PUSH
65029: LD_INT 5
65031: EQUAL
65032: IFFALSE 65042
// btype := b_armoury ;
65034: LD_ADDR_VAR 0 5
65038: PUSH
65039: LD_INT 4
65041: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
65042: LD_VAR 0 5
65046: PUSH
65047: LD_INT 7
65049: PUSH
65050: LD_INT 8
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: IN
65057: IFFALSE 65067
// btype := b_lab ;
65059: LD_ADDR_VAR 0 5
65063: PUSH
65064: LD_INT 6
65066: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
65067: LD_ADDR_EXP 104
65071: PUSH
65072: LD_EXP 104
65076: PPUSH
65077: LD_VAR 0 3
65081: PUSH
65082: LD_EXP 104
65086: PUSH
65087: LD_VAR 0 3
65091: ARRAY
65092: PUSH
65093: LD_INT 1
65095: PLUS
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PPUSH
65101: LD_VAR 0 5
65105: PUSH
65106: LD_VAR 0 1
65110: PPUSH
65111: CALL_OW 250
65115: PUSH
65116: LD_VAR 0 1
65120: PPUSH
65121: CALL_OW 251
65125: PUSH
65126: LD_VAR 0 1
65130: PPUSH
65131: CALL_OW 254
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: PPUSH
65142: CALL 72332 0 3
65146: ST_TO_ADDR
// if pos = 1 then
65147: LD_VAR 0 6
65151: PUSH
65152: LD_INT 1
65154: EQUAL
65155: IFFALSE 65270
// begin tmp := mc_build_list [ i ] ;
65157: LD_ADDR_VAR 0 7
65161: PUSH
65162: LD_EXP 104
65166: PUSH
65167: LD_VAR 0 3
65171: ARRAY
65172: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65173: LD_VAR 0 7
65177: PPUSH
65178: LD_INT 2
65180: PUSH
65181: LD_INT 30
65183: PUSH
65184: LD_INT 0
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PUSH
65191: LD_INT 30
65193: PUSH
65194: LD_INT 1
65196: PUSH
65197: EMPTY
65198: LIST
65199: LIST
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: LIST
65205: PPUSH
65206: CALL_OW 72
65210: IFFALSE 65220
// pos := 2 ;
65212: LD_ADDR_VAR 0 6
65216: PUSH
65217: LD_INT 2
65219: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
65220: LD_ADDR_VAR 0 7
65224: PUSH
65225: LD_VAR 0 7
65229: PPUSH
65230: LD_VAR 0 6
65234: PPUSH
65235: LD_VAR 0 7
65239: PPUSH
65240: CALL 72658 0 3
65244: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
65245: LD_ADDR_EXP 104
65249: PUSH
65250: LD_EXP 104
65254: PPUSH
65255: LD_VAR 0 3
65259: PPUSH
65260: LD_VAR 0 7
65264: PPUSH
65265: CALL_OW 1
65269: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
65270: LD_VAR 0 1
65274: PUSH
65275: LD_EXP 99
65279: PUSH
65280: LD_VAR 0 3
65284: ARRAY
65285: IN
65286: IFFALSE 65325
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
65288: LD_ADDR_EXP 99
65292: PUSH
65293: LD_EXP 99
65297: PPUSH
65298: LD_VAR 0 3
65302: PPUSH
65303: LD_EXP 99
65307: PUSH
65308: LD_VAR 0 3
65312: ARRAY
65313: PUSH
65314: LD_VAR 0 1
65318: DIFF
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
65325: LD_VAR 0 1
65329: PUSH
65330: LD_EXP 106
65334: PUSH
65335: LD_VAR 0 3
65339: ARRAY
65340: IN
65341: IFFALSE 65380
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
65343: LD_ADDR_EXP 106
65347: PUSH
65348: LD_EXP 106
65352: PPUSH
65353: LD_VAR 0 3
65357: PPUSH
65358: LD_EXP 106
65362: PUSH
65363: LD_VAR 0 3
65367: ARRAY
65368: PUSH
65369: LD_VAR 0 1
65373: DIFF
65374: PPUSH
65375: CALL_OW 1
65379: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
65380: LD_VAR 0 1
65384: PUSH
65385: LD_EXP 118
65389: PUSH
65390: LD_VAR 0 3
65394: ARRAY
65395: IN
65396: IFFALSE 65435
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
65398: LD_ADDR_EXP 118
65402: PUSH
65403: LD_EXP 118
65407: PPUSH
65408: LD_VAR 0 3
65412: PPUSH
65413: LD_EXP 118
65417: PUSH
65418: LD_VAR 0 3
65422: ARRAY
65423: PUSH
65424: LD_VAR 0 1
65428: DIFF
65429: PPUSH
65430: CALL_OW 1
65434: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
65435: LD_VAR 0 1
65439: PUSH
65440: LD_EXP 121
65444: PUSH
65445: LD_VAR 0 3
65449: ARRAY
65450: IN
65451: IFFALSE 65490
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
65453: LD_ADDR_EXP 121
65457: PUSH
65458: LD_EXP 121
65462: PPUSH
65463: LD_VAR 0 3
65467: PPUSH
65468: LD_EXP 121
65472: PUSH
65473: LD_VAR 0 3
65477: ARRAY
65478: PUSH
65479: LD_VAR 0 1
65483: DIFF
65484: PPUSH
65485: CALL_OW 1
65489: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
65490: LD_VAR 0 1
65494: PUSH
65495: LD_EXP 108
65499: PUSH
65500: LD_VAR 0 3
65504: ARRAY
65505: IN
65506: IFFALSE 65545
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
65508: LD_ADDR_EXP 108
65512: PUSH
65513: LD_EXP 108
65517: PPUSH
65518: LD_VAR 0 3
65522: PPUSH
65523: LD_EXP 108
65527: PUSH
65528: LD_VAR 0 3
65532: ARRAY
65533: PUSH
65534: LD_VAR 0 1
65538: DIFF
65539: PPUSH
65540: CALL_OW 1
65544: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
65545: LD_VAR 0 1
65549: PUSH
65550: LD_EXP 107
65554: PUSH
65555: LD_VAR 0 3
65559: ARRAY
65560: IN
65561: IFFALSE 65600
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
65563: LD_ADDR_EXP 107
65567: PUSH
65568: LD_EXP 107
65572: PPUSH
65573: LD_VAR 0 3
65577: PPUSH
65578: LD_EXP 107
65582: PUSH
65583: LD_VAR 0 3
65587: ARRAY
65588: PUSH
65589: LD_VAR 0 1
65593: DIFF
65594: PPUSH
65595: CALL_OW 1
65599: ST_TO_ADDR
// end ; break ;
65600: GO 65604
// end ;
65602: GO 64252
65604: POP
65605: POP
// end ;
65606: LD_VAR 0 2
65610: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
65611: LD_INT 0
65613: PPUSH
65614: PPUSH
65615: PPUSH
// if not mc_bases or not skirmish then
65616: LD_EXP 99
65620: NOT
65621: PUSH
65622: LD_EXP 97
65626: NOT
65627: OR
65628: IFFALSE 65632
// exit ;
65630: GO 65847
// for i = 1 to mc_bases do
65632: LD_ADDR_VAR 0 3
65636: PUSH
65637: DOUBLE
65638: LD_INT 1
65640: DEC
65641: ST_TO_ADDR
65642: LD_EXP 99
65646: PUSH
65647: FOR_TO
65648: IFFALSE 65845
// begin if building in mc_construct_list [ i ] then
65650: LD_VAR 0 1
65654: PUSH
65655: LD_EXP 106
65659: PUSH
65660: LD_VAR 0 3
65664: ARRAY
65665: IN
65666: IFFALSE 65843
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65668: LD_ADDR_EXP 106
65672: PUSH
65673: LD_EXP 106
65677: PPUSH
65678: LD_VAR 0 3
65682: PPUSH
65683: LD_EXP 106
65687: PUSH
65688: LD_VAR 0 3
65692: ARRAY
65693: PUSH
65694: LD_VAR 0 1
65698: DIFF
65699: PPUSH
65700: CALL_OW 1
65704: ST_TO_ADDR
// if building in mc_lab [ i ] then
65705: LD_VAR 0 1
65709: PUSH
65710: LD_EXP 132
65714: PUSH
65715: LD_VAR 0 3
65719: ARRAY
65720: IN
65721: IFFALSE 65776
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
65723: LD_ADDR_EXP 133
65727: PUSH
65728: LD_EXP 133
65732: PPUSH
65733: LD_VAR 0 3
65737: PPUSH
65738: LD_EXP 133
65742: PUSH
65743: LD_VAR 0 3
65747: ARRAY
65748: PPUSH
65749: LD_INT 1
65751: PPUSH
65752: LD_EXP 133
65756: PUSH
65757: LD_VAR 0 3
65761: ARRAY
65762: PPUSH
65763: LD_INT 0
65765: PPUSH
65766: CALL 71750 0 4
65770: PPUSH
65771: CALL_OW 1
65775: ST_TO_ADDR
// if not building in mc_bases [ i ] then
65776: LD_VAR 0 1
65780: PUSH
65781: LD_EXP 99
65785: PUSH
65786: LD_VAR 0 3
65790: ARRAY
65791: IN
65792: NOT
65793: IFFALSE 65839
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65795: LD_ADDR_EXP 99
65799: PUSH
65800: LD_EXP 99
65804: PPUSH
65805: LD_VAR 0 3
65809: PUSH
65810: LD_EXP 99
65814: PUSH
65815: LD_VAR 0 3
65819: ARRAY
65820: PUSH
65821: LD_INT 1
65823: PLUS
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PPUSH
65829: LD_VAR 0 1
65833: PPUSH
65834: CALL 72332 0 3
65838: ST_TO_ADDR
// exit ;
65839: POP
65840: POP
65841: GO 65847
// end ; end ;
65843: GO 65647
65845: POP
65846: POP
// end ;
65847: LD_VAR 0 2
65851: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
65852: LD_INT 0
65854: PPUSH
65855: PPUSH
65856: PPUSH
65857: PPUSH
65858: PPUSH
65859: PPUSH
65860: PPUSH
// if not mc_bases or not skirmish then
65861: LD_EXP 99
65865: NOT
65866: PUSH
65867: LD_EXP 97
65871: NOT
65872: OR
65873: IFFALSE 65877
// exit ;
65875: GO 66538
// for i = 1 to mc_bases do
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: DOUBLE
65883: LD_INT 1
65885: DEC
65886: ST_TO_ADDR
65887: LD_EXP 99
65891: PUSH
65892: FOR_TO
65893: IFFALSE 66536
// begin if building in mc_construct_list [ i ] then
65895: LD_VAR 0 1
65899: PUSH
65900: LD_EXP 106
65904: PUSH
65905: LD_VAR 0 3
65909: ARRAY
65910: IN
65911: IFFALSE 66534
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
65913: LD_ADDR_EXP 106
65917: PUSH
65918: LD_EXP 106
65922: PPUSH
65923: LD_VAR 0 3
65927: PPUSH
65928: LD_EXP 106
65932: PUSH
65933: LD_VAR 0 3
65937: ARRAY
65938: PUSH
65939: LD_VAR 0 1
65943: DIFF
65944: PPUSH
65945: CALL_OW 1
65949: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
65950: LD_ADDR_EXP 99
65954: PUSH
65955: LD_EXP 99
65959: PPUSH
65960: LD_VAR 0 3
65964: PUSH
65965: LD_EXP 99
65969: PUSH
65970: LD_VAR 0 3
65974: ARRAY
65975: PUSH
65976: LD_INT 1
65978: PLUS
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PPUSH
65984: LD_VAR 0 1
65988: PPUSH
65989: CALL 72332 0 3
65993: ST_TO_ADDR
// btype := GetBType ( building ) ;
65994: LD_ADDR_VAR 0 5
65998: PUSH
65999: LD_VAR 0 1
66003: PPUSH
66004: CALL_OW 266
66008: ST_TO_ADDR
// side := GetSide ( building ) ;
66009: LD_ADDR_VAR 0 8
66013: PUSH
66014: LD_VAR 0 1
66018: PPUSH
66019: CALL_OW 255
66023: ST_TO_ADDR
// if btype = b_lab then
66024: LD_VAR 0 5
66028: PUSH
66029: LD_INT 6
66031: EQUAL
66032: IFFALSE 66082
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
66034: LD_ADDR_EXP 132
66038: PUSH
66039: LD_EXP 132
66043: PPUSH
66044: LD_VAR 0 3
66048: PUSH
66049: LD_EXP 132
66053: PUSH
66054: LD_VAR 0 3
66058: ARRAY
66059: PUSH
66060: LD_INT 1
66062: PLUS
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PPUSH
66068: LD_VAR 0 1
66072: PPUSH
66073: CALL 72332 0 3
66077: ST_TO_ADDR
// exit ;
66078: POP
66079: POP
66080: GO 66538
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
66082: LD_VAR 0 5
66086: PUSH
66087: LD_INT 0
66089: PUSH
66090: LD_INT 2
66092: PUSH
66093: LD_INT 4
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: LIST
66100: IN
66101: IFFALSE 66225
// begin if btype = b_armoury then
66103: LD_VAR 0 5
66107: PUSH
66108: LD_INT 4
66110: EQUAL
66111: IFFALSE 66121
// btype := b_barracks ;
66113: LD_ADDR_VAR 0 5
66117: PUSH
66118: LD_INT 5
66120: ST_TO_ADDR
// if btype = b_depot then
66121: LD_VAR 0 5
66125: PUSH
66126: LD_INT 0
66128: EQUAL
66129: IFFALSE 66139
// btype := b_warehouse ;
66131: LD_ADDR_VAR 0 5
66135: PUSH
66136: LD_INT 1
66138: ST_TO_ADDR
// if btype = b_workshop then
66139: LD_VAR 0 5
66143: PUSH
66144: LD_INT 2
66146: EQUAL
66147: IFFALSE 66157
// btype := b_factory ;
66149: LD_ADDR_VAR 0 5
66153: PUSH
66154: LD_INT 3
66156: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
66157: LD_VAR 0 5
66161: PPUSH
66162: LD_VAR 0 8
66166: PPUSH
66167: CALL_OW 323
66171: PUSH
66172: LD_INT 1
66174: EQUAL
66175: IFFALSE 66221
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
66177: LD_ADDR_EXP 131
66181: PUSH
66182: LD_EXP 131
66186: PPUSH
66187: LD_VAR 0 3
66191: PUSH
66192: LD_EXP 131
66196: PUSH
66197: LD_VAR 0 3
66201: ARRAY
66202: PUSH
66203: LD_INT 1
66205: PLUS
66206: PUSH
66207: EMPTY
66208: LIST
66209: LIST
66210: PPUSH
66211: LD_VAR 0 1
66215: PPUSH
66216: CALL 72332 0 3
66220: ST_TO_ADDR
// exit ;
66221: POP
66222: POP
66223: GO 66538
// end ; if btype in [ b_bunker , b_turret ] then
66225: LD_VAR 0 5
66229: PUSH
66230: LD_INT 32
66232: PUSH
66233: LD_INT 33
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: IN
66240: IFFALSE 66530
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
66242: LD_ADDR_EXP 107
66246: PUSH
66247: LD_EXP 107
66251: PPUSH
66252: LD_VAR 0 3
66256: PUSH
66257: LD_EXP 107
66261: PUSH
66262: LD_VAR 0 3
66266: ARRAY
66267: PUSH
66268: LD_INT 1
66270: PLUS
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: PPUSH
66276: LD_VAR 0 1
66280: PPUSH
66281: CALL 72332 0 3
66285: ST_TO_ADDR
// if btype = b_bunker then
66286: LD_VAR 0 5
66290: PUSH
66291: LD_INT 32
66293: EQUAL
66294: IFFALSE 66530
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66296: LD_ADDR_EXP 108
66300: PUSH
66301: LD_EXP 108
66305: PPUSH
66306: LD_VAR 0 3
66310: PUSH
66311: LD_EXP 108
66315: PUSH
66316: LD_VAR 0 3
66320: ARRAY
66321: PUSH
66322: LD_INT 1
66324: PLUS
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PPUSH
66330: LD_VAR 0 1
66334: PPUSH
66335: CALL 72332 0 3
66339: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
66340: LD_ADDR_VAR 0 6
66344: PUSH
66345: LD_EXP 99
66349: PUSH
66350: LD_VAR 0 3
66354: ARRAY
66355: PPUSH
66356: LD_INT 25
66358: PUSH
66359: LD_INT 1
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 3
66368: PUSH
66369: LD_INT 54
66371: PUSH
66372: EMPTY
66373: LIST
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PPUSH
66383: CALL_OW 72
66387: ST_TO_ADDR
// if tmp then
66388: LD_VAR 0 6
66392: IFFALSE 66398
// exit ;
66394: POP
66395: POP
66396: GO 66538
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66398: LD_ADDR_VAR 0 6
66402: PUSH
66403: LD_EXP 99
66407: PUSH
66408: LD_VAR 0 3
66412: ARRAY
66413: PPUSH
66414: LD_INT 2
66416: PUSH
66417: LD_INT 30
66419: PUSH
66420: LD_INT 4
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: LD_INT 30
66429: PUSH
66430: LD_INT 5
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: LIST
66441: PPUSH
66442: CALL_OW 72
66446: ST_TO_ADDR
// if not tmp then
66447: LD_VAR 0 6
66451: NOT
66452: IFFALSE 66458
// exit ;
66454: POP
66455: POP
66456: GO 66538
// for j in tmp do
66458: LD_ADDR_VAR 0 4
66462: PUSH
66463: LD_VAR 0 6
66467: PUSH
66468: FOR_IN
66469: IFFALSE 66528
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
66471: LD_ADDR_VAR 0 7
66475: PUSH
66476: LD_VAR 0 4
66480: PPUSH
66481: CALL_OW 313
66485: PPUSH
66486: LD_INT 25
66488: PUSH
66489: LD_INT 1
66491: PUSH
66492: EMPTY
66493: LIST
66494: LIST
66495: PPUSH
66496: CALL_OW 72
66500: ST_TO_ADDR
// if units then
66501: LD_VAR 0 7
66505: IFFALSE 66526
// begin ComExitBuilding ( units [ 1 ] ) ;
66507: LD_VAR 0 7
66511: PUSH
66512: LD_INT 1
66514: ARRAY
66515: PPUSH
66516: CALL_OW 122
// exit ;
66520: POP
66521: POP
66522: POP
66523: POP
66524: GO 66538
// end ; end ;
66526: GO 66468
66528: POP
66529: POP
// end ; end ; exit ;
66530: POP
66531: POP
66532: GO 66538
// end ; end ;
66534: GO 65892
66536: POP
66537: POP
// end ;
66538: LD_VAR 0 2
66542: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
66543: LD_INT 0
66545: PPUSH
66546: PPUSH
66547: PPUSH
66548: PPUSH
66549: PPUSH
66550: PPUSH
66551: PPUSH
// if not mc_bases or not skirmish then
66552: LD_EXP 99
66556: NOT
66557: PUSH
66558: LD_EXP 97
66562: NOT
66563: OR
66564: IFFALSE 66568
// exit ;
66566: GO 66833
// btype := GetBType ( building ) ;
66568: LD_ADDR_VAR 0 6
66572: PUSH
66573: LD_VAR 0 1
66577: PPUSH
66578: CALL_OW 266
66582: ST_TO_ADDR
// x := GetX ( building ) ;
66583: LD_ADDR_VAR 0 7
66587: PUSH
66588: LD_VAR 0 1
66592: PPUSH
66593: CALL_OW 250
66597: ST_TO_ADDR
// y := GetY ( building ) ;
66598: LD_ADDR_VAR 0 8
66602: PUSH
66603: LD_VAR 0 1
66607: PPUSH
66608: CALL_OW 251
66612: ST_TO_ADDR
// d := GetDir ( building ) ;
66613: LD_ADDR_VAR 0 9
66617: PUSH
66618: LD_VAR 0 1
66622: PPUSH
66623: CALL_OW 254
66627: ST_TO_ADDR
// for i = 1 to mc_bases do
66628: LD_ADDR_VAR 0 4
66632: PUSH
66633: DOUBLE
66634: LD_INT 1
66636: DEC
66637: ST_TO_ADDR
66638: LD_EXP 99
66642: PUSH
66643: FOR_TO
66644: IFFALSE 66831
// begin if not mc_build_list [ i ] then
66646: LD_EXP 104
66650: PUSH
66651: LD_VAR 0 4
66655: ARRAY
66656: NOT
66657: IFFALSE 66661
// continue ;
66659: GO 66643
// for j := 1 to mc_build_list [ i ] do
66661: LD_ADDR_VAR 0 5
66665: PUSH
66666: DOUBLE
66667: LD_INT 1
66669: DEC
66670: ST_TO_ADDR
66671: LD_EXP 104
66675: PUSH
66676: LD_VAR 0 4
66680: ARRAY
66681: PUSH
66682: FOR_TO
66683: IFFALSE 66827
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
66685: LD_VAR 0 6
66689: PUSH
66690: LD_VAR 0 7
66694: PUSH
66695: LD_VAR 0 8
66699: PUSH
66700: LD_VAR 0 9
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: PPUSH
66711: LD_EXP 104
66715: PUSH
66716: LD_VAR 0 4
66720: ARRAY
66721: PUSH
66722: LD_VAR 0 5
66726: ARRAY
66727: PPUSH
66728: CALL 78512 0 2
66732: IFFALSE 66825
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
66734: LD_ADDR_EXP 104
66738: PUSH
66739: LD_EXP 104
66743: PPUSH
66744: LD_VAR 0 4
66748: PPUSH
66749: LD_EXP 104
66753: PUSH
66754: LD_VAR 0 4
66758: ARRAY
66759: PPUSH
66760: LD_VAR 0 5
66764: PPUSH
66765: CALL_OW 3
66769: PPUSH
66770: CALL_OW 1
66774: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
66775: LD_ADDR_EXP 106
66779: PUSH
66780: LD_EXP 106
66784: PPUSH
66785: LD_VAR 0 4
66789: PUSH
66790: LD_EXP 106
66794: PUSH
66795: LD_VAR 0 4
66799: ARRAY
66800: PUSH
66801: LD_INT 1
66803: PLUS
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PPUSH
66809: LD_VAR 0 1
66813: PPUSH
66814: CALL 72332 0 3
66818: ST_TO_ADDR
// exit ;
66819: POP
66820: POP
66821: POP
66822: POP
66823: GO 66833
// end ;
66825: GO 66682
66827: POP
66828: POP
// end ;
66829: GO 66643
66831: POP
66832: POP
// end ;
66833: LD_VAR 0 3
66837: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
66838: LD_INT 0
66840: PPUSH
66841: PPUSH
66842: PPUSH
// if not mc_bases or not skirmish then
66843: LD_EXP 99
66847: NOT
66848: PUSH
66849: LD_EXP 97
66853: NOT
66854: OR
66855: IFFALSE 66859
// exit ;
66857: GO 67049
// for i = 1 to mc_bases do
66859: LD_ADDR_VAR 0 4
66863: PUSH
66864: DOUBLE
66865: LD_INT 1
66867: DEC
66868: ST_TO_ADDR
66869: LD_EXP 99
66873: PUSH
66874: FOR_TO
66875: IFFALSE 66962
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
66877: LD_VAR 0 1
66881: PUSH
66882: LD_EXP 107
66886: PUSH
66887: LD_VAR 0 4
66891: ARRAY
66892: IN
66893: PUSH
66894: LD_VAR 0 1
66898: PUSH
66899: LD_EXP 108
66903: PUSH
66904: LD_VAR 0 4
66908: ARRAY
66909: IN
66910: NOT
66911: AND
66912: IFFALSE 66960
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
66914: LD_ADDR_EXP 108
66918: PUSH
66919: LD_EXP 108
66923: PPUSH
66924: LD_VAR 0 4
66928: PUSH
66929: LD_EXP 108
66933: PUSH
66934: LD_VAR 0 4
66938: ARRAY
66939: PUSH
66940: LD_INT 1
66942: PLUS
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PPUSH
66948: LD_VAR 0 1
66952: PPUSH
66953: CALL 72332 0 3
66957: ST_TO_ADDR
// break ;
66958: GO 66962
// end ; end ;
66960: GO 66874
66962: POP
66963: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
66964: LD_VAR 0 1
66968: PPUSH
66969: CALL_OW 257
66973: PUSH
66974: LD_EXP 125
66978: IN
66979: PUSH
66980: LD_VAR 0 1
66984: PPUSH
66985: CALL_OW 266
66989: PUSH
66990: LD_INT 5
66992: EQUAL
66993: AND
66994: PUSH
66995: LD_VAR 0 2
66999: PPUSH
67000: CALL_OW 110
67004: PUSH
67005: LD_INT 18
67007: NONEQUAL
67008: AND
67009: IFFALSE 67049
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
67011: LD_VAR 0 2
67015: PPUSH
67016: CALL_OW 257
67020: PUSH
67021: LD_INT 5
67023: PUSH
67024: LD_INT 8
67026: PUSH
67027: LD_INT 9
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: LIST
67034: IN
67035: IFFALSE 67049
// SetClass ( unit , 1 ) ;
67037: LD_VAR 0 2
67041: PPUSH
67042: LD_INT 1
67044: PPUSH
67045: CALL_OW 336
// end ;
67049: LD_VAR 0 3
67053: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
67054: LD_INT 0
67056: PPUSH
67057: PPUSH
// if not mc_bases or not skirmish then
67058: LD_EXP 99
67062: NOT
67063: PUSH
67064: LD_EXP 97
67068: NOT
67069: OR
67070: IFFALSE 67074
// exit ;
67072: GO 67190
// if GetLives ( abandoned_vehicle ) > 250 then
67074: LD_VAR 0 2
67078: PPUSH
67079: CALL_OW 256
67083: PUSH
67084: LD_INT 250
67086: GREATER
67087: IFFALSE 67091
// exit ;
67089: GO 67190
// for i = 1 to mc_bases do
67091: LD_ADDR_VAR 0 6
67095: PUSH
67096: DOUBLE
67097: LD_INT 1
67099: DEC
67100: ST_TO_ADDR
67101: LD_EXP 99
67105: PUSH
67106: FOR_TO
67107: IFFALSE 67188
// begin if driver in mc_bases [ i ] then
67109: LD_VAR 0 1
67113: PUSH
67114: LD_EXP 99
67118: PUSH
67119: LD_VAR 0 6
67123: ARRAY
67124: IN
67125: IFFALSE 67186
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
67127: LD_VAR 0 1
67131: PPUSH
67132: LD_EXP 99
67136: PUSH
67137: LD_VAR 0 6
67141: ARRAY
67142: PPUSH
67143: LD_INT 2
67145: PUSH
67146: LD_INT 30
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 30
67158: PUSH
67159: LD_INT 1
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: EMPTY
67167: LIST
67168: LIST
67169: LIST
67170: PPUSH
67171: CALL_OW 72
67175: PUSH
67176: LD_INT 1
67178: ARRAY
67179: PPUSH
67180: CALL 105521 0 2
// break ;
67184: GO 67188
// end ; end ;
67186: GO 67106
67188: POP
67189: POP
// end ; end_of_file
67190: LD_VAR 0 5
67194: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
67195: LD_INT 0
67197: PPUSH
67198: PPUSH
// if exist_mode then
67199: LD_VAR 0 2
67203: IFFALSE 67228
// unit := CreateCharacter ( prefix & ident ) else
67205: LD_ADDR_VAR 0 5
67209: PUSH
67210: LD_VAR 0 3
67214: PUSH
67215: LD_VAR 0 1
67219: STR
67220: PPUSH
67221: CALL_OW 34
67225: ST_TO_ADDR
67226: GO 67243
// unit := NewCharacter ( ident ) ;
67228: LD_ADDR_VAR 0 5
67232: PUSH
67233: LD_VAR 0 1
67237: PPUSH
67238: CALL_OW 25
67242: ST_TO_ADDR
// result := unit ;
67243: LD_ADDR_VAR 0 4
67247: PUSH
67248: LD_VAR 0 5
67252: ST_TO_ADDR
// end ;
67253: LD_VAR 0 4
67257: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
67258: LD_INT 0
67260: PPUSH
67261: PPUSH
// if not side or not nation then
67262: LD_VAR 0 1
67266: NOT
67267: PUSH
67268: LD_VAR 0 2
67272: NOT
67273: OR
67274: IFFALSE 67278
// exit ;
67276: GO 68046
// case nation of nation_american :
67278: LD_VAR 0 2
67282: PUSH
67283: LD_INT 1
67285: DOUBLE
67286: EQUAL
67287: IFTRUE 67291
67289: GO 67505
67291: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
67292: LD_ADDR_VAR 0 4
67296: PUSH
67297: LD_INT 35
67299: PUSH
67300: LD_INT 45
67302: PUSH
67303: LD_INT 46
67305: PUSH
67306: LD_INT 47
67308: PUSH
67309: LD_INT 82
67311: PUSH
67312: LD_INT 83
67314: PUSH
67315: LD_INT 84
67317: PUSH
67318: LD_INT 85
67320: PUSH
67321: LD_INT 86
67323: PUSH
67324: LD_INT 1
67326: PUSH
67327: LD_INT 2
67329: PUSH
67330: LD_INT 6
67332: PUSH
67333: LD_INT 15
67335: PUSH
67336: LD_INT 16
67338: PUSH
67339: LD_INT 7
67341: PUSH
67342: LD_INT 12
67344: PUSH
67345: LD_INT 13
67347: PUSH
67348: LD_INT 10
67350: PUSH
67351: LD_INT 14
67353: PUSH
67354: LD_INT 20
67356: PUSH
67357: LD_INT 21
67359: PUSH
67360: LD_INT 22
67362: PUSH
67363: LD_INT 25
67365: PUSH
67366: LD_INT 32
67368: PUSH
67369: LD_INT 27
67371: PUSH
67372: LD_INT 36
67374: PUSH
67375: LD_INT 69
67377: PUSH
67378: LD_INT 39
67380: PUSH
67381: LD_INT 34
67383: PUSH
67384: LD_INT 40
67386: PUSH
67387: LD_INT 48
67389: PUSH
67390: LD_INT 49
67392: PUSH
67393: LD_INT 50
67395: PUSH
67396: LD_INT 51
67398: PUSH
67399: LD_INT 52
67401: PUSH
67402: LD_INT 53
67404: PUSH
67405: LD_INT 54
67407: PUSH
67408: LD_INT 55
67410: PUSH
67411: LD_INT 56
67413: PUSH
67414: LD_INT 57
67416: PUSH
67417: LD_INT 58
67419: PUSH
67420: LD_INT 59
67422: PUSH
67423: LD_INT 60
67425: PUSH
67426: LD_INT 61
67428: PUSH
67429: LD_INT 62
67431: PUSH
67432: LD_INT 80
67434: PUSH
67435: LD_INT 82
67437: PUSH
67438: LD_INT 83
67440: PUSH
67441: LD_INT 84
67443: PUSH
67444: LD_INT 85
67446: PUSH
67447: LD_INT 86
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: LIST
67502: ST_TO_ADDR
67503: GO 67970
67505: LD_INT 2
67507: DOUBLE
67508: EQUAL
67509: IFTRUE 67513
67511: GO 67739
67513: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
67514: LD_ADDR_VAR 0 4
67518: PUSH
67519: LD_INT 35
67521: PUSH
67522: LD_INT 45
67524: PUSH
67525: LD_INT 46
67527: PUSH
67528: LD_INT 47
67530: PUSH
67531: LD_INT 82
67533: PUSH
67534: LD_INT 83
67536: PUSH
67537: LD_INT 84
67539: PUSH
67540: LD_INT 85
67542: PUSH
67543: LD_INT 87
67545: PUSH
67546: LD_INT 70
67548: PUSH
67549: LD_INT 1
67551: PUSH
67552: LD_INT 11
67554: PUSH
67555: LD_INT 3
67557: PUSH
67558: LD_INT 4
67560: PUSH
67561: LD_INT 5
67563: PUSH
67564: LD_INT 6
67566: PUSH
67567: LD_INT 15
67569: PUSH
67570: LD_INT 18
67572: PUSH
67573: LD_INT 7
67575: PUSH
67576: LD_INT 17
67578: PUSH
67579: LD_INT 8
67581: PUSH
67582: LD_INT 20
67584: PUSH
67585: LD_INT 21
67587: PUSH
67588: LD_INT 22
67590: PUSH
67591: LD_INT 72
67593: PUSH
67594: LD_INT 26
67596: PUSH
67597: LD_INT 69
67599: PUSH
67600: LD_INT 39
67602: PUSH
67603: LD_INT 40
67605: PUSH
67606: LD_INT 41
67608: PUSH
67609: LD_INT 42
67611: PUSH
67612: LD_INT 43
67614: PUSH
67615: LD_INT 48
67617: PUSH
67618: LD_INT 49
67620: PUSH
67621: LD_INT 50
67623: PUSH
67624: LD_INT 51
67626: PUSH
67627: LD_INT 52
67629: PUSH
67630: LD_INT 53
67632: PUSH
67633: LD_INT 54
67635: PUSH
67636: LD_INT 55
67638: PUSH
67639: LD_INT 56
67641: PUSH
67642: LD_INT 60
67644: PUSH
67645: LD_INT 61
67647: PUSH
67648: LD_INT 62
67650: PUSH
67651: LD_INT 66
67653: PUSH
67654: LD_INT 67
67656: PUSH
67657: LD_INT 68
67659: PUSH
67660: LD_INT 81
67662: PUSH
67663: LD_INT 82
67665: PUSH
67666: LD_INT 83
67668: PUSH
67669: LD_INT 84
67671: PUSH
67672: LD_INT 85
67674: PUSH
67675: LD_INT 87
67677: PUSH
67678: LD_INT 88
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: LIST
67728: LIST
67729: LIST
67730: LIST
67731: LIST
67732: LIST
67733: LIST
67734: LIST
67735: LIST
67736: ST_TO_ADDR
67737: GO 67970
67739: LD_INT 3
67741: DOUBLE
67742: EQUAL
67743: IFTRUE 67747
67745: GO 67969
67747: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
67748: LD_ADDR_VAR 0 4
67752: PUSH
67753: LD_INT 46
67755: PUSH
67756: LD_INT 47
67758: PUSH
67759: LD_INT 1
67761: PUSH
67762: LD_INT 2
67764: PUSH
67765: LD_INT 82
67767: PUSH
67768: LD_INT 83
67770: PUSH
67771: LD_INT 84
67773: PUSH
67774: LD_INT 85
67776: PUSH
67777: LD_INT 86
67779: PUSH
67780: LD_INT 11
67782: PUSH
67783: LD_INT 9
67785: PUSH
67786: LD_INT 20
67788: PUSH
67789: LD_INT 19
67791: PUSH
67792: LD_INT 21
67794: PUSH
67795: LD_INT 24
67797: PUSH
67798: LD_INT 22
67800: PUSH
67801: LD_INT 25
67803: PUSH
67804: LD_INT 28
67806: PUSH
67807: LD_INT 29
67809: PUSH
67810: LD_INT 30
67812: PUSH
67813: LD_INT 31
67815: PUSH
67816: LD_INT 37
67818: PUSH
67819: LD_INT 38
67821: PUSH
67822: LD_INT 32
67824: PUSH
67825: LD_INT 27
67827: PUSH
67828: LD_INT 33
67830: PUSH
67831: LD_INT 69
67833: PUSH
67834: LD_INT 39
67836: PUSH
67837: LD_INT 34
67839: PUSH
67840: LD_INT 40
67842: PUSH
67843: LD_INT 71
67845: PUSH
67846: LD_INT 23
67848: PUSH
67849: LD_INT 44
67851: PUSH
67852: LD_INT 48
67854: PUSH
67855: LD_INT 49
67857: PUSH
67858: LD_INT 50
67860: PUSH
67861: LD_INT 51
67863: PUSH
67864: LD_INT 52
67866: PUSH
67867: LD_INT 53
67869: PUSH
67870: LD_INT 54
67872: PUSH
67873: LD_INT 55
67875: PUSH
67876: LD_INT 56
67878: PUSH
67879: LD_INT 57
67881: PUSH
67882: LD_INT 58
67884: PUSH
67885: LD_INT 59
67887: PUSH
67888: LD_INT 63
67890: PUSH
67891: LD_INT 64
67893: PUSH
67894: LD_INT 65
67896: PUSH
67897: LD_INT 82
67899: PUSH
67900: LD_INT 83
67902: PUSH
67903: LD_INT 84
67905: PUSH
67906: LD_INT 85
67908: PUSH
67909: LD_INT 86
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: LIST
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: LIST
67963: LIST
67964: LIST
67965: LIST
67966: ST_TO_ADDR
67967: GO 67970
67969: POP
// if state > - 1 and state < 3 then
67970: LD_VAR 0 3
67974: PUSH
67975: LD_INT 1
67977: NEG
67978: GREATER
67979: PUSH
67980: LD_VAR 0 3
67984: PUSH
67985: LD_INT 3
67987: LESS
67988: AND
67989: IFFALSE 68046
// for i in result do
67991: LD_ADDR_VAR 0 5
67995: PUSH
67996: LD_VAR 0 4
68000: PUSH
68001: FOR_IN
68002: IFFALSE 68044
// if GetTech ( i , side ) <> state then
68004: LD_VAR 0 5
68008: PPUSH
68009: LD_VAR 0 1
68013: PPUSH
68014: CALL_OW 321
68018: PUSH
68019: LD_VAR 0 3
68023: NONEQUAL
68024: IFFALSE 68042
// result := result diff i ;
68026: LD_ADDR_VAR 0 4
68030: PUSH
68031: LD_VAR 0 4
68035: PUSH
68036: LD_VAR 0 5
68040: DIFF
68041: ST_TO_ADDR
68042: GO 68001
68044: POP
68045: POP
// end ;
68046: LD_VAR 0 4
68050: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
68051: LD_INT 0
68053: PPUSH
68054: PPUSH
68055: PPUSH
// result := true ;
68056: LD_ADDR_VAR 0 3
68060: PUSH
68061: LD_INT 1
68063: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
68064: LD_ADDR_VAR 0 5
68068: PUSH
68069: LD_VAR 0 2
68073: PPUSH
68074: CALL_OW 480
68078: ST_TO_ADDR
// if not tmp then
68079: LD_VAR 0 5
68083: NOT
68084: IFFALSE 68088
// exit ;
68086: GO 68137
// for i in tmp do
68088: LD_ADDR_VAR 0 4
68092: PUSH
68093: LD_VAR 0 5
68097: PUSH
68098: FOR_IN
68099: IFFALSE 68135
// if GetTech ( i , side ) <> state_researched then
68101: LD_VAR 0 4
68105: PPUSH
68106: LD_VAR 0 1
68110: PPUSH
68111: CALL_OW 321
68115: PUSH
68116: LD_INT 2
68118: NONEQUAL
68119: IFFALSE 68133
// begin result := false ;
68121: LD_ADDR_VAR 0 3
68125: PUSH
68126: LD_INT 0
68128: ST_TO_ADDR
// exit ;
68129: POP
68130: POP
68131: GO 68137
// end ;
68133: GO 68098
68135: POP
68136: POP
// end ;
68137: LD_VAR 0 3
68141: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
68142: LD_INT 0
68144: PPUSH
68145: PPUSH
68146: PPUSH
68147: PPUSH
68148: PPUSH
68149: PPUSH
68150: PPUSH
68151: PPUSH
68152: PPUSH
68153: PPUSH
68154: PPUSH
68155: PPUSH
68156: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
68157: LD_VAR 0 1
68161: NOT
68162: PUSH
68163: LD_VAR 0 1
68167: PPUSH
68168: CALL_OW 257
68172: PUSH
68173: LD_INT 9
68175: NONEQUAL
68176: OR
68177: IFFALSE 68181
// exit ;
68179: GO 68754
// side := GetSide ( unit ) ;
68181: LD_ADDR_VAR 0 9
68185: PUSH
68186: LD_VAR 0 1
68190: PPUSH
68191: CALL_OW 255
68195: ST_TO_ADDR
// tech_space := tech_spacanom ;
68196: LD_ADDR_VAR 0 12
68200: PUSH
68201: LD_INT 29
68203: ST_TO_ADDR
// tech_time := tech_taurad ;
68204: LD_ADDR_VAR 0 13
68208: PUSH
68209: LD_INT 28
68211: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
68212: LD_ADDR_VAR 0 11
68216: PUSH
68217: LD_VAR 0 1
68221: PPUSH
68222: CALL_OW 310
68226: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
68227: LD_VAR 0 11
68231: PPUSH
68232: CALL_OW 247
68236: PUSH
68237: LD_INT 2
68239: EQUAL
68240: IFFALSE 68244
// exit ;
68242: GO 68754
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68244: LD_ADDR_VAR 0 8
68248: PUSH
68249: LD_INT 81
68251: PUSH
68252: LD_VAR 0 9
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 3
68263: PUSH
68264: LD_INT 21
68266: PUSH
68267: LD_INT 3
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PPUSH
68282: CALL_OW 69
68286: ST_TO_ADDR
// if not tmp then
68287: LD_VAR 0 8
68291: NOT
68292: IFFALSE 68296
// exit ;
68294: GO 68754
// if in_unit then
68296: LD_VAR 0 11
68300: IFFALSE 68324
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
68302: LD_ADDR_VAR 0 10
68306: PUSH
68307: LD_VAR 0 8
68311: PPUSH
68312: LD_VAR 0 11
68316: PPUSH
68317: CALL_OW 74
68321: ST_TO_ADDR
68322: GO 68344
// enemy := NearestUnitToUnit ( tmp , unit ) ;
68324: LD_ADDR_VAR 0 10
68328: PUSH
68329: LD_VAR 0 8
68333: PPUSH
68334: LD_VAR 0 1
68338: PPUSH
68339: CALL_OW 74
68343: ST_TO_ADDR
// if not enemy then
68344: LD_VAR 0 10
68348: NOT
68349: IFFALSE 68353
// exit ;
68351: GO 68754
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
68353: LD_VAR 0 11
68357: PUSH
68358: LD_VAR 0 11
68362: PPUSH
68363: LD_VAR 0 10
68367: PPUSH
68368: CALL_OW 296
68372: PUSH
68373: LD_INT 13
68375: GREATER
68376: AND
68377: PUSH
68378: LD_VAR 0 1
68382: PPUSH
68383: LD_VAR 0 10
68387: PPUSH
68388: CALL_OW 296
68392: PUSH
68393: LD_INT 12
68395: GREATER
68396: OR
68397: IFFALSE 68401
// exit ;
68399: GO 68754
// missile := [ 1 ] ;
68401: LD_ADDR_VAR 0 14
68405: PUSH
68406: LD_INT 1
68408: PUSH
68409: EMPTY
68410: LIST
68411: ST_TO_ADDR
// if Researched ( side , tech_space ) then
68412: LD_VAR 0 9
68416: PPUSH
68417: LD_VAR 0 12
68421: PPUSH
68422: CALL_OW 325
68426: IFFALSE 68455
// missile := Replace ( missile , missile + 1 , 2 ) ;
68428: LD_ADDR_VAR 0 14
68432: PUSH
68433: LD_VAR 0 14
68437: PPUSH
68438: LD_VAR 0 14
68442: PUSH
68443: LD_INT 1
68445: PLUS
68446: PPUSH
68447: LD_INT 2
68449: PPUSH
68450: CALL_OW 1
68454: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
68455: LD_VAR 0 9
68459: PPUSH
68460: LD_VAR 0 13
68464: PPUSH
68465: CALL_OW 325
68469: PUSH
68470: LD_VAR 0 10
68474: PPUSH
68475: CALL_OW 255
68479: PPUSH
68480: LD_VAR 0 13
68484: PPUSH
68485: CALL_OW 325
68489: NOT
68490: AND
68491: IFFALSE 68520
// missile := Replace ( missile , missile + 1 , 3 ) ;
68493: LD_ADDR_VAR 0 14
68497: PUSH
68498: LD_VAR 0 14
68502: PPUSH
68503: LD_VAR 0 14
68507: PUSH
68508: LD_INT 1
68510: PLUS
68511: PPUSH
68512: LD_INT 3
68514: PPUSH
68515: CALL_OW 1
68519: ST_TO_ADDR
// if missile < 2 then
68520: LD_VAR 0 14
68524: PUSH
68525: LD_INT 2
68527: LESS
68528: IFFALSE 68532
// exit ;
68530: GO 68754
// x := GetX ( enemy ) ;
68532: LD_ADDR_VAR 0 4
68536: PUSH
68537: LD_VAR 0 10
68541: PPUSH
68542: CALL_OW 250
68546: ST_TO_ADDR
// y := GetY ( enemy ) ;
68547: LD_ADDR_VAR 0 5
68551: PUSH
68552: LD_VAR 0 10
68556: PPUSH
68557: CALL_OW 251
68561: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
68562: LD_ADDR_VAR 0 6
68566: PUSH
68567: LD_VAR 0 4
68571: PUSH
68572: LD_INT 1
68574: NEG
68575: PPUSH
68576: LD_INT 1
68578: PPUSH
68579: CALL_OW 12
68583: PLUS
68584: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
68585: LD_ADDR_VAR 0 7
68589: PUSH
68590: LD_VAR 0 5
68594: PUSH
68595: LD_INT 1
68597: NEG
68598: PPUSH
68599: LD_INT 1
68601: PPUSH
68602: CALL_OW 12
68606: PLUS
68607: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68608: LD_VAR 0 6
68612: PPUSH
68613: LD_VAR 0 7
68617: PPUSH
68618: CALL_OW 488
68622: NOT
68623: IFFALSE 68645
// begin _x := x ;
68625: LD_ADDR_VAR 0 6
68629: PUSH
68630: LD_VAR 0 4
68634: ST_TO_ADDR
// _y := y ;
68635: LD_ADDR_VAR 0 7
68639: PUSH
68640: LD_VAR 0 5
68644: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
68645: LD_ADDR_VAR 0 3
68649: PUSH
68650: LD_INT 1
68652: PPUSH
68653: LD_VAR 0 14
68657: PPUSH
68658: CALL_OW 12
68662: ST_TO_ADDR
// case i of 1 :
68663: LD_VAR 0 3
68667: PUSH
68668: LD_INT 1
68670: DOUBLE
68671: EQUAL
68672: IFTRUE 68676
68674: GO 68693
68676: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
68677: LD_VAR 0 1
68681: PPUSH
68682: LD_VAR 0 10
68686: PPUSH
68687: CALL_OW 115
68691: GO 68754
68693: LD_INT 2
68695: DOUBLE
68696: EQUAL
68697: IFTRUE 68701
68699: GO 68723
68701: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
68702: LD_VAR 0 1
68706: PPUSH
68707: LD_VAR 0 6
68711: PPUSH
68712: LD_VAR 0 7
68716: PPUSH
68717: CALL_OW 153
68721: GO 68754
68723: LD_INT 3
68725: DOUBLE
68726: EQUAL
68727: IFTRUE 68731
68729: GO 68753
68731: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
68732: LD_VAR 0 1
68736: PPUSH
68737: LD_VAR 0 6
68741: PPUSH
68742: LD_VAR 0 7
68746: PPUSH
68747: CALL_OW 154
68751: GO 68754
68753: POP
// end ;
68754: LD_VAR 0 2
68758: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
68759: LD_INT 0
68761: PPUSH
68762: PPUSH
68763: PPUSH
68764: PPUSH
68765: PPUSH
68766: PPUSH
// if not unit or not building then
68767: LD_VAR 0 1
68771: NOT
68772: PUSH
68773: LD_VAR 0 2
68777: NOT
68778: OR
68779: IFFALSE 68783
// exit ;
68781: GO 68941
// x := GetX ( building ) ;
68783: LD_ADDR_VAR 0 5
68787: PUSH
68788: LD_VAR 0 2
68792: PPUSH
68793: CALL_OW 250
68797: ST_TO_ADDR
// y := GetY ( building ) ;
68798: LD_ADDR_VAR 0 6
68802: PUSH
68803: LD_VAR 0 2
68807: PPUSH
68808: CALL_OW 251
68812: ST_TO_ADDR
// for i = 0 to 5 do
68813: LD_ADDR_VAR 0 4
68817: PUSH
68818: DOUBLE
68819: LD_INT 0
68821: DEC
68822: ST_TO_ADDR
68823: LD_INT 5
68825: PUSH
68826: FOR_TO
68827: IFFALSE 68939
// begin _x := ShiftX ( x , i , 3 ) ;
68829: LD_ADDR_VAR 0 7
68833: PUSH
68834: LD_VAR 0 5
68838: PPUSH
68839: LD_VAR 0 4
68843: PPUSH
68844: LD_INT 3
68846: PPUSH
68847: CALL_OW 272
68851: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
68852: LD_ADDR_VAR 0 8
68856: PUSH
68857: LD_VAR 0 6
68861: PPUSH
68862: LD_VAR 0 4
68866: PPUSH
68867: LD_INT 3
68869: PPUSH
68870: CALL_OW 273
68874: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
68875: LD_VAR 0 7
68879: PPUSH
68880: LD_VAR 0 8
68884: PPUSH
68885: CALL_OW 488
68889: NOT
68890: IFFALSE 68894
// continue ;
68892: GO 68826
// if HexInfo ( _x , _y ) = 0 then
68894: LD_VAR 0 7
68898: PPUSH
68899: LD_VAR 0 8
68903: PPUSH
68904: CALL_OW 428
68908: PUSH
68909: LD_INT 0
68911: EQUAL
68912: IFFALSE 68937
// begin ComMoveXY ( unit , _x , _y ) ;
68914: LD_VAR 0 1
68918: PPUSH
68919: LD_VAR 0 7
68923: PPUSH
68924: LD_VAR 0 8
68928: PPUSH
68929: CALL_OW 111
// exit ;
68933: POP
68934: POP
68935: GO 68941
// end ; end ;
68937: GO 68826
68939: POP
68940: POP
// end ;
68941: LD_VAR 0 3
68945: RET
// export function ScanBase ( side , base_area ) ; begin
68946: LD_INT 0
68948: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
68949: LD_ADDR_VAR 0 3
68953: PUSH
68954: LD_VAR 0 2
68958: PPUSH
68959: LD_INT 81
68961: PUSH
68962: LD_VAR 0 1
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PPUSH
68971: CALL_OW 70
68975: ST_TO_ADDR
// end ;
68976: LD_VAR 0 3
68980: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68981: LD_INT 0
68983: PPUSH
68984: PPUSH
68985: PPUSH
68986: PPUSH
// result := false ;
68987: LD_ADDR_VAR 0 2
68991: PUSH
68992: LD_INT 0
68994: ST_TO_ADDR
// side := GetSide ( unit ) ;
68995: LD_ADDR_VAR 0 3
68999: PUSH
69000: LD_VAR 0 1
69004: PPUSH
69005: CALL_OW 255
69009: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69010: LD_ADDR_VAR 0 4
69014: PUSH
69015: LD_VAR 0 1
69019: PPUSH
69020: CALL_OW 248
69024: ST_TO_ADDR
// case nat of 1 :
69025: LD_VAR 0 4
69029: PUSH
69030: LD_INT 1
69032: DOUBLE
69033: EQUAL
69034: IFTRUE 69038
69036: GO 69049
69038: POP
// tech := tech_lassight ; 2 :
69039: LD_ADDR_VAR 0 5
69043: PUSH
69044: LD_INT 12
69046: ST_TO_ADDR
69047: GO 69088
69049: LD_INT 2
69051: DOUBLE
69052: EQUAL
69053: IFTRUE 69057
69055: GO 69068
69057: POP
// tech := tech_mortar ; 3 :
69058: LD_ADDR_VAR 0 5
69062: PUSH
69063: LD_INT 41
69065: ST_TO_ADDR
69066: GO 69088
69068: LD_INT 3
69070: DOUBLE
69071: EQUAL
69072: IFTRUE 69076
69074: GO 69087
69076: POP
// tech := tech_bazooka ; end ;
69077: LD_ADDR_VAR 0 5
69081: PUSH
69082: LD_INT 44
69084: ST_TO_ADDR
69085: GO 69088
69087: POP
// if Researched ( side , tech ) then
69088: LD_VAR 0 3
69092: PPUSH
69093: LD_VAR 0 5
69097: PPUSH
69098: CALL_OW 325
69102: IFFALSE 69129
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69104: LD_ADDR_VAR 0 2
69108: PUSH
69109: LD_INT 5
69111: PUSH
69112: LD_INT 8
69114: PUSH
69115: LD_INT 9
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: LIST
69122: PUSH
69123: LD_VAR 0 4
69127: ARRAY
69128: ST_TO_ADDR
// end ;
69129: LD_VAR 0 2
69133: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69134: LD_INT 0
69136: PPUSH
69137: PPUSH
69138: PPUSH
// if not mines then
69139: LD_VAR 0 2
69143: NOT
69144: IFFALSE 69148
// exit ;
69146: GO 69292
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69148: LD_ADDR_VAR 0 5
69152: PUSH
69153: LD_INT 81
69155: PUSH
69156: LD_VAR 0 1
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: PUSH
69165: LD_INT 3
69167: PUSH
69168: LD_INT 21
69170: PUSH
69171: LD_INT 3
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PPUSH
69186: CALL_OW 69
69190: ST_TO_ADDR
// for i in mines do
69191: LD_ADDR_VAR 0 4
69195: PUSH
69196: LD_VAR 0 2
69200: PUSH
69201: FOR_IN
69202: IFFALSE 69290
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69204: LD_VAR 0 4
69208: PUSH
69209: LD_INT 1
69211: ARRAY
69212: PPUSH
69213: LD_VAR 0 4
69217: PUSH
69218: LD_INT 2
69220: ARRAY
69221: PPUSH
69222: CALL_OW 458
69226: NOT
69227: IFFALSE 69231
// continue ;
69229: GO 69201
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69231: LD_VAR 0 4
69235: PUSH
69236: LD_INT 1
69238: ARRAY
69239: PPUSH
69240: LD_VAR 0 4
69244: PUSH
69245: LD_INT 2
69247: ARRAY
69248: PPUSH
69249: CALL_OW 428
69253: PUSH
69254: LD_VAR 0 5
69258: IN
69259: IFFALSE 69288
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69261: LD_VAR 0 4
69265: PUSH
69266: LD_INT 1
69268: ARRAY
69269: PPUSH
69270: LD_VAR 0 4
69274: PUSH
69275: LD_INT 2
69277: ARRAY
69278: PPUSH
69279: LD_VAR 0 1
69283: PPUSH
69284: CALL_OW 456
// end ;
69288: GO 69201
69290: POP
69291: POP
// end ;
69292: LD_VAR 0 3
69296: RET
// export function Count ( array ) ; var i ; begin
69297: LD_INT 0
69299: PPUSH
69300: PPUSH
// result := 0 ;
69301: LD_ADDR_VAR 0 2
69305: PUSH
69306: LD_INT 0
69308: ST_TO_ADDR
// for i in array do
69309: LD_ADDR_VAR 0 3
69313: PUSH
69314: LD_VAR 0 1
69318: PUSH
69319: FOR_IN
69320: IFFALSE 69344
// if i then
69322: LD_VAR 0 3
69326: IFFALSE 69342
// result := result + 1 ;
69328: LD_ADDR_VAR 0 2
69332: PUSH
69333: LD_VAR 0 2
69337: PUSH
69338: LD_INT 1
69340: PLUS
69341: ST_TO_ADDR
69342: GO 69319
69344: POP
69345: POP
// end ;
69346: LD_VAR 0 2
69350: RET
// export function IsEmpty ( building ) ; begin
69351: LD_INT 0
69353: PPUSH
// if not building then
69354: LD_VAR 0 1
69358: NOT
69359: IFFALSE 69363
// exit ;
69361: GO 69406
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69363: LD_ADDR_VAR 0 2
69367: PUSH
69368: LD_VAR 0 1
69372: PUSH
69373: LD_INT 22
69375: PUSH
69376: LD_VAR 0 1
69380: PPUSH
69381: CALL_OW 255
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 58
69392: PUSH
69393: EMPTY
69394: LIST
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PPUSH
69400: CALL_OW 69
69404: IN
69405: ST_TO_ADDR
// end ;
69406: LD_VAR 0 2
69410: RET
// export function IsNotFull ( building ) ; var places ; begin
69411: LD_INT 0
69413: PPUSH
69414: PPUSH
// if not building then
69415: LD_VAR 0 1
69419: NOT
69420: IFFALSE 69424
// exit ;
69422: GO 69595
// result := false ;
69424: LD_ADDR_VAR 0 2
69428: PUSH
69429: LD_INT 0
69431: ST_TO_ADDR
// places := 0 ;
69432: LD_ADDR_VAR 0 3
69436: PUSH
69437: LD_INT 0
69439: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
69440: LD_VAR 0 1
69444: PPUSH
69445: CALL_OW 266
69449: PUSH
69450: LD_INT 0
69452: DOUBLE
69453: EQUAL
69454: IFTRUE 69512
69456: LD_INT 1
69458: DOUBLE
69459: EQUAL
69460: IFTRUE 69512
69462: LD_INT 6
69464: DOUBLE
69465: EQUAL
69466: IFTRUE 69512
69468: LD_INT 7
69470: DOUBLE
69471: EQUAL
69472: IFTRUE 69512
69474: LD_INT 8
69476: DOUBLE
69477: EQUAL
69478: IFTRUE 69512
69480: LD_INT 4
69482: DOUBLE
69483: EQUAL
69484: IFTRUE 69512
69486: LD_INT 5
69488: DOUBLE
69489: EQUAL
69490: IFTRUE 69512
69492: LD_INT 2
69494: DOUBLE
69495: EQUAL
69496: IFTRUE 69512
69498: LD_INT 3
69500: DOUBLE
69501: EQUAL
69502: IFTRUE 69512
69504: LD_INT 35
69506: DOUBLE
69507: EQUAL
69508: IFTRUE 69512
69510: GO 69523
69512: POP
// places := 6 ; b_bunker , b_breastwork :
69513: LD_ADDR_VAR 0 3
69517: PUSH
69518: LD_INT 6
69520: ST_TO_ADDR
69521: GO 69568
69523: LD_INT 32
69525: DOUBLE
69526: EQUAL
69527: IFTRUE 69537
69529: LD_INT 31
69531: DOUBLE
69532: EQUAL
69533: IFTRUE 69537
69535: GO 69548
69537: POP
// places := 1 ; b_control_tower :
69538: LD_ADDR_VAR 0 3
69542: PUSH
69543: LD_INT 1
69545: ST_TO_ADDR
69546: GO 69568
69548: LD_INT 36
69550: DOUBLE
69551: EQUAL
69552: IFTRUE 69556
69554: GO 69567
69556: POP
// places := 3 ; end ;
69557: LD_ADDR_VAR 0 3
69561: PUSH
69562: LD_INT 3
69564: ST_TO_ADDR
69565: GO 69568
69567: POP
// if places then
69568: LD_VAR 0 3
69572: IFFALSE 69595
// result := UnitsInside ( building ) < places ;
69574: LD_ADDR_VAR 0 2
69578: PUSH
69579: LD_VAR 0 1
69583: PPUSH
69584: CALL_OW 313
69588: PUSH
69589: LD_VAR 0 3
69593: LESS
69594: ST_TO_ADDR
// end ;
69595: LD_VAR 0 2
69599: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69600: LD_INT 0
69602: PPUSH
69603: PPUSH
69604: PPUSH
69605: PPUSH
// tmp := [ ] ;
69606: LD_ADDR_VAR 0 3
69610: PUSH
69611: EMPTY
69612: ST_TO_ADDR
// list := [ ] ;
69613: LD_ADDR_VAR 0 5
69617: PUSH
69618: EMPTY
69619: ST_TO_ADDR
// for i = 16 to 25 do
69620: LD_ADDR_VAR 0 4
69624: PUSH
69625: DOUBLE
69626: LD_INT 16
69628: DEC
69629: ST_TO_ADDR
69630: LD_INT 25
69632: PUSH
69633: FOR_TO
69634: IFFALSE 69707
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69636: LD_ADDR_VAR 0 3
69640: PUSH
69641: LD_VAR 0 3
69645: PUSH
69646: LD_INT 22
69648: PUSH
69649: LD_VAR 0 1
69653: PPUSH
69654: CALL_OW 255
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 91
69665: PUSH
69666: LD_VAR 0 1
69670: PUSH
69671: LD_INT 6
69673: PUSH
69674: EMPTY
69675: LIST
69676: LIST
69677: LIST
69678: PUSH
69679: LD_INT 30
69681: PUSH
69682: LD_VAR 0 4
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: PUSH
69696: EMPTY
69697: LIST
69698: PPUSH
69699: CALL_OW 69
69703: ADD
69704: ST_TO_ADDR
69705: GO 69633
69707: POP
69708: POP
// for i = 1 to tmp do
69709: LD_ADDR_VAR 0 4
69713: PUSH
69714: DOUBLE
69715: LD_INT 1
69717: DEC
69718: ST_TO_ADDR
69719: LD_VAR 0 3
69723: PUSH
69724: FOR_TO
69725: IFFALSE 69813
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69727: LD_ADDR_VAR 0 5
69731: PUSH
69732: LD_VAR 0 5
69736: PUSH
69737: LD_VAR 0 3
69741: PUSH
69742: LD_VAR 0 4
69746: ARRAY
69747: PPUSH
69748: CALL_OW 266
69752: PUSH
69753: LD_VAR 0 3
69757: PUSH
69758: LD_VAR 0 4
69762: ARRAY
69763: PPUSH
69764: CALL_OW 250
69768: PUSH
69769: LD_VAR 0 3
69773: PUSH
69774: LD_VAR 0 4
69778: ARRAY
69779: PPUSH
69780: CALL_OW 251
69784: PUSH
69785: LD_VAR 0 3
69789: PUSH
69790: LD_VAR 0 4
69794: ARRAY
69795: PPUSH
69796: CALL_OW 254
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: LIST
69805: LIST
69806: PUSH
69807: EMPTY
69808: LIST
69809: ADD
69810: ST_TO_ADDR
69811: GO 69724
69813: POP
69814: POP
// result := list ;
69815: LD_ADDR_VAR 0 2
69819: PUSH
69820: LD_VAR 0 5
69824: ST_TO_ADDR
// end ;
69825: LD_VAR 0 2
69829: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69830: LD_INT 0
69832: PPUSH
69833: PPUSH
69834: PPUSH
69835: PPUSH
69836: PPUSH
69837: PPUSH
69838: PPUSH
// if not factory then
69839: LD_VAR 0 1
69843: NOT
69844: IFFALSE 69848
// exit ;
69846: GO 70441
// if control = control_apeman then
69848: LD_VAR 0 4
69852: PUSH
69853: LD_INT 5
69855: EQUAL
69856: IFFALSE 69965
// begin tmp := UnitsInside ( factory ) ;
69858: LD_ADDR_VAR 0 8
69862: PUSH
69863: LD_VAR 0 1
69867: PPUSH
69868: CALL_OW 313
69872: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69873: LD_VAR 0 8
69877: PPUSH
69878: LD_INT 25
69880: PUSH
69881: LD_INT 12
69883: PUSH
69884: EMPTY
69885: LIST
69886: LIST
69887: PPUSH
69888: CALL_OW 72
69892: NOT
69893: IFFALSE 69903
// control := control_manual ;
69895: LD_ADDR_VAR 0 4
69899: PUSH
69900: LD_INT 1
69902: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69903: LD_ADDR_VAR 0 8
69907: PUSH
69908: LD_VAR 0 1
69912: PPUSH
69913: CALL 69600 0 1
69917: ST_TO_ADDR
// if tmp then
69918: LD_VAR 0 8
69922: IFFALSE 69965
// begin for i in tmp do
69924: LD_ADDR_VAR 0 7
69928: PUSH
69929: LD_VAR 0 8
69933: PUSH
69934: FOR_IN
69935: IFFALSE 69963
// if i [ 1 ] = b_ext_radio then
69937: LD_VAR 0 7
69941: PUSH
69942: LD_INT 1
69944: ARRAY
69945: PUSH
69946: LD_INT 22
69948: EQUAL
69949: IFFALSE 69961
// begin control := control_remote ;
69951: LD_ADDR_VAR 0 4
69955: PUSH
69956: LD_INT 2
69958: ST_TO_ADDR
// break ;
69959: GO 69963
// end ;
69961: GO 69934
69963: POP
69964: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69965: LD_VAR 0 1
69969: PPUSH
69970: LD_VAR 0 2
69974: PPUSH
69975: LD_VAR 0 3
69979: PPUSH
69980: LD_VAR 0 4
69984: PPUSH
69985: LD_VAR 0 5
69989: PPUSH
69990: CALL_OW 448
69994: IFFALSE 70029
// begin result := [ chassis , engine , control , weapon ] ;
69996: LD_ADDR_VAR 0 6
70000: PUSH
70001: LD_VAR 0 2
70005: PUSH
70006: LD_VAR 0 3
70010: PUSH
70011: LD_VAR 0 4
70015: PUSH
70016: LD_VAR 0 5
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: ST_TO_ADDR
// exit ;
70027: GO 70441
// end ; _chassis := AvailableChassisList ( factory ) ;
70029: LD_ADDR_VAR 0 9
70033: PUSH
70034: LD_VAR 0 1
70038: PPUSH
70039: CALL_OW 475
70043: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
70044: LD_ADDR_VAR 0 11
70048: PUSH
70049: LD_VAR 0 1
70053: PPUSH
70054: CALL_OW 476
70058: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
70059: LD_ADDR_VAR 0 12
70063: PUSH
70064: LD_VAR 0 1
70068: PPUSH
70069: CALL_OW 477
70073: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
70074: LD_ADDR_VAR 0 10
70078: PUSH
70079: LD_VAR 0 1
70083: PPUSH
70084: CALL_OW 478
70088: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70089: LD_VAR 0 9
70093: NOT
70094: PUSH
70095: LD_VAR 0 11
70099: NOT
70100: OR
70101: PUSH
70102: LD_VAR 0 12
70106: NOT
70107: OR
70108: PUSH
70109: LD_VAR 0 10
70113: NOT
70114: OR
70115: IFFALSE 70150
// begin result := [ chassis , engine , control , weapon ] ;
70117: LD_ADDR_VAR 0 6
70121: PUSH
70122: LD_VAR 0 2
70126: PUSH
70127: LD_VAR 0 3
70131: PUSH
70132: LD_VAR 0 4
70136: PUSH
70137: LD_VAR 0 5
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: ST_TO_ADDR
// exit ;
70148: GO 70441
// end ; if not chassis in _chassis then
70150: LD_VAR 0 2
70154: PUSH
70155: LD_VAR 0 9
70159: IN
70160: NOT
70161: IFFALSE 70187
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70163: LD_ADDR_VAR 0 2
70167: PUSH
70168: LD_VAR 0 9
70172: PUSH
70173: LD_INT 1
70175: PPUSH
70176: LD_VAR 0 9
70180: PPUSH
70181: CALL_OW 12
70185: ARRAY
70186: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70187: LD_VAR 0 2
70191: PPUSH
70192: LD_VAR 0 3
70196: PPUSH
70197: CALL 70446 0 2
70201: NOT
70202: IFFALSE 70261
// repeat engine := _engine [ 1 ] ;
70204: LD_ADDR_VAR 0 3
70208: PUSH
70209: LD_VAR 0 11
70213: PUSH
70214: LD_INT 1
70216: ARRAY
70217: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70218: LD_ADDR_VAR 0 11
70222: PUSH
70223: LD_VAR 0 11
70227: PPUSH
70228: LD_INT 1
70230: PPUSH
70231: CALL_OW 3
70235: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70236: LD_VAR 0 2
70240: PPUSH
70241: LD_VAR 0 3
70245: PPUSH
70246: CALL 70446 0 2
70250: PUSH
70251: LD_VAR 0 11
70255: PUSH
70256: EMPTY
70257: EQUAL
70258: OR
70259: IFFALSE 70204
// if not control in _control then
70261: LD_VAR 0 4
70265: PUSH
70266: LD_VAR 0 12
70270: IN
70271: NOT
70272: IFFALSE 70298
// control := _control [ rand ( 1 , _control ) ] ;
70274: LD_ADDR_VAR 0 4
70278: PUSH
70279: LD_VAR 0 12
70283: PUSH
70284: LD_INT 1
70286: PPUSH
70287: LD_VAR 0 12
70291: PPUSH
70292: CALL_OW 12
70296: ARRAY
70297: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70298: LD_VAR 0 2
70302: PPUSH
70303: LD_VAR 0 5
70307: PPUSH
70308: CALL 70666 0 2
70312: NOT
70313: IFFALSE 70372
// repeat weapon := _weapon [ 1 ] ;
70315: LD_ADDR_VAR 0 5
70319: PUSH
70320: LD_VAR 0 10
70324: PUSH
70325: LD_INT 1
70327: ARRAY
70328: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70329: LD_ADDR_VAR 0 10
70333: PUSH
70334: LD_VAR 0 10
70338: PPUSH
70339: LD_INT 1
70341: PPUSH
70342: CALL_OW 3
70346: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70347: LD_VAR 0 2
70351: PPUSH
70352: LD_VAR 0 5
70356: PPUSH
70357: CALL 70666 0 2
70361: PUSH
70362: LD_VAR 0 10
70366: PUSH
70367: EMPTY
70368: EQUAL
70369: OR
70370: IFFALSE 70315
// result := [ ] ;
70372: LD_ADDR_VAR 0 6
70376: PUSH
70377: EMPTY
70378: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70379: LD_VAR 0 1
70383: PPUSH
70384: LD_VAR 0 2
70388: PPUSH
70389: LD_VAR 0 3
70393: PPUSH
70394: LD_VAR 0 4
70398: PPUSH
70399: LD_VAR 0 5
70403: PPUSH
70404: CALL_OW 448
70408: IFFALSE 70441
// result := [ chassis , engine , control , weapon ] ;
70410: LD_ADDR_VAR 0 6
70414: PUSH
70415: LD_VAR 0 2
70419: PUSH
70420: LD_VAR 0 3
70424: PUSH
70425: LD_VAR 0 4
70429: PUSH
70430: LD_VAR 0 5
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: ST_TO_ADDR
// end ;
70441: LD_VAR 0 6
70445: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70446: LD_INT 0
70448: PPUSH
// if not chassis or not engine then
70449: LD_VAR 0 1
70453: NOT
70454: PUSH
70455: LD_VAR 0 2
70459: NOT
70460: OR
70461: IFFALSE 70465
// exit ;
70463: GO 70661
// case engine of engine_solar :
70465: LD_VAR 0 2
70469: PUSH
70470: LD_INT 2
70472: DOUBLE
70473: EQUAL
70474: IFTRUE 70478
70476: GO 70516
70478: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70479: LD_ADDR_VAR 0 3
70483: PUSH
70484: LD_INT 11
70486: PUSH
70487: LD_INT 12
70489: PUSH
70490: LD_INT 13
70492: PUSH
70493: LD_INT 14
70495: PUSH
70496: LD_INT 1
70498: PUSH
70499: LD_INT 2
70501: PUSH
70502: LD_INT 3
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: ST_TO_ADDR
70514: GO 70645
70516: LD_INT 1
70518: DOUBLE
70519: EQUAL
70520: IFTRUE 70524
70522: GO 70586
70524: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70525: LD_ADDR_VAR 0 3
70529: PUSH
70530: LD_INT 11
70532: PUSH
70533: LD_INT 12
70535: PUSH
70536: LD_INT 13
70538: PUSH
70539: LD_INT 14
70541: PUSH
70542: LD_INT 1
70544: PUSH
70545: LD_INT 2
70547: PUSH
70548: LD_INT 3
70550: PUSH
70551: LD_INT 4
70553: PUSH
70554: LD_INT 5
70556: PUSH
70557: LD_INT 21
70559: PUSH
70560: LD_INT 23
70562: PUSH
70563: LD_INT 22
70565: PUSH
70566: LD_INT 24
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: ST_TO_ADDR
70584: GO 70645
70586: LD_INT 3
70588: DOUBLE
70589: EQUAL
70590: IFTRUE 70594
70592: GO 70644
70594: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70595: LD_ADDR_VAR 0 3
70599: PUSH
70600: LD_INT 13
70602: PUSH
70603: LD_INT 14
70605: PUSH
70606: LD_INT 2
70608: PUSH
70609: LD_INT 3
70611: PUSH
70612: LD_INT 4
70614: PUSH
70615: LD_INT 5
70617: PUSH
70618: LD_INT 21
70620: PUSH
70621: LD_INT 22
70623: PUSH
70624: LD_INT 23
70626: PUSH
70627: LD_INT 24
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: ST_TO_ADDR
70642: GO 70645
70644: POP
// result := ( chassis in result ) ;
70645: LD_ADDR_VAR 0 3
70649: PUSH
70650: LD_VAR 0 1
70654: PUSH
70655: LD_VAR 0 3
70659: IN
70660: ST_TO_ADDR
// end ;
70661: LD_VAR 0 3
70665: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70666: LD_INT 0
70668: PPUSH
// if not chassis or not weapon then
70669: LD_VAR 0 1
70673: NOT
70674: PUSH
70675: LD_VAR 0 2
70679: NOT
70680: OR
70681: IFFALSE 70685
// exit ;
70683: GO 71745
// case weapon of us_machine_gun :
70685: LD_VAR 0 2
70689: PUSH
70690: LD_INT 2
70692: DOUBLE
70693: EQUAL
70694: IFTRUE 70698
70696: GO 70728
70698: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70699: LD_ADDR_VAR 0 3
70703: PUSH
70704: LD_INT 1
70706: PUSH
70707: LD_INT 2
70709: PUSH
70710: LD_INT 3
70712: PUSH
70713: LD_INT 4
70715: PUSH
70716: LD_INT 5
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: ST_TO_ADDR
70726: GO 71729
70728: LD_INT 3
70730: DOUBLE
70731: EQUAL
70732: IFTRUE 70736
70734: GO 70766
70736: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70737: LD_ADDR_VAR 0 3
70741: PUSH
70742: LD_INT 1
70744: PUSH
70745: LD_INT 2
70747: PUSH
70748: LD_INT 3
70750: PUSH
70751: LD_INT 4
70753: PUSH
70754: LD_INT 5
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: LIST
70763: ST_TO_ADDR
70764: GO 71729
70766: LD_INT 11
70768: DOUBLE
70769: EQUAL
70770: IFTRUE 70774
70772: GO 70804
70774: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70775: LD_ADDR_VAR 0 3
70779: PUSH
70780: LD_INT 1
70782: PUSH
70783: LD_INT 2
70785: PUSH
70786: LD_INT 3
70788: PUSH
70789: LD_INT 4
70791: PUSH
70792: LD_INT 5
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: ST_TO_ADDR
70802: GO 71729
70804: LD_INT 4
70806: DOUBLE
70807: EQUAL
70808: IFTRUE 70812
70810: GO 70838
70812: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70813: LD_ADDR_VAR 0 3
70817: PUSH
70818: LD_INT 2
70820: PUSH
70821: LD_INT 3
70823: PUSH
70824: LD_INT 4
70826: PUSH
70827: LD_INT 5
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: LIST
70834: LIST
70835: ST_TO_ADDR
70836: GO 71729
70838: LD_INT 5
70840: DOUBLE
70841: EQUAL
70842: IFTRUE 70846
70844: GO 70872
70846: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70847: LD_ADDR_VAR 0 3
70851: PUSH
70852: LD_INT 2
70854: PUSH
70855: LD_INT 3
70857: PUSH
70858: LD_INT 4
70860: PUSH
70861: LD_INT 5
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: LIST
70868: LIST
70869: ST_TO_ADDR
70870: GO 71729
70872: LD_INT 9
70874: DOUBLE
70875: EQUAL
70876: IFTRUE 70880
70878: GO 70906
70880: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70881: LD_ADDR_VAR 0 3
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 3
70891: PUSH
70892: LD_INT 4
70894: PUSH
70895: LD_INT 5
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: ST_TO_ADDR
70904: GO 71729
70906: LD_INT 7
70908: DOUBLE
70909: EQUAL
70910: IFTRUE 70914
70912: GO 70940
70914: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70915: LD_ADDR_VAR 0 3
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: LD_INT 3
70925: PUSH
70926: LD_INT 4
70928: PUSH
70929: LD_INT 5
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: ST_TO_ADDR
70938: GO 71729
70940: LD_INT 12
70942: DOUBLE
70943: EQUAL
70944: IFTRUE 70948
70946: GO 70974
70948: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70949: LD_ADDR_VAR 0 3
70953: PUSH
70954: LD_INT 2
70956: PUSH
70957: LD_INT 3
70959: PUSH
70960: LD_INT 4
70962: PUSH
70963: LD_INT 5
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: ST_TO_ADDR
70972: GO 71729
70974: LD_INT 13
70976: DOUBLE
70977: EQUAL
70978: IFTRUE 70982
70980: GO 71008
70982: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70983: LD_ADDR_VAR 0 3
70987: PUSH
70988: LD_INT 2
70990: PUSH
70991: LD_INT 3
70993: PUSH
70994: LD_INT 4
70996: PUSH
70997: LD_INT 5
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: LIST
71004: LIST
71005: ST_TO_ADDR
71006: GO 71729
71008: LD_INT 14
71010: DOUBLE
71011: EQUAL
71012: IFTRUE 71016
71014: GO 71034
71016: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
71017: LD_ADDR_VAR 0 3
71021: PUSH
71022: LD_INT 4
71024: PUSH
71025: LD_INT 5
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: ST_TO_ADDR
71032: GO 71729
71034: LD_INT 6
71036: DOUBLE
71037: EQUAL
71038: IFTRUE 71042
71040: GO 71060
71042: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
71043: LD_ADDR_VAR 0 3
71047: PUSH
71048: LD_INT 4
71050: PUSH
71051: LD_INT 5
71053: PUSH
71054: EMPTY
71055: LIST
71056: LIST
71057: ST_TO_ADDR
71058: GO 71729
71060: LD_INT 10
71062: DOUBLE
71063: EQUAL
71064: IFTRUE 71068
71066: GO 71086
71068: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
71069: LD_ADDR_VAR 0 3
71073: PUSH
71074: LD_INT 4
71076: PUSH
71077: LD_INT 5
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: ST_TO_ADDR
71084: GO 71729
71086: LD_INT 22
71088: DOUBLE
71089: EQUAL
71090: IFTRUE 71094
71092: GO 71120
71094: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71095: LD_ADDR_VAR 0 3
71099: PUSH
71100: LD_INT 11
71102: PUSH
71103: LD_INT 12
71105: PUSH
71106: LD_INT 13
71108: PUSH
71109: LD_INT 14
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: LIST
71116: LIST
71117: ST_TO_ADDR
71118: GO 71729
71120: LD_INT 23
71122: DOUBLE
71123: EQUAL
71124: IFTRUE 71128
71126: GO 71154
71128: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71129: LD_ADDR_VAR 0 3
71133: PUSH
71134: LD_INT 11
71136: PUSH
71137: LD_INT 12
71139: PUSH
71140: LD_INT 13
71142: PUSH
71143: LD_INT 14
71145: PUSH
71146: EMPTY
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: ST_TO_ADDR
71152: GO 71729
71154: LD_INT 24
71156: DOUBLE
71157: EQUAL
71158: IFTRUE 71162
71160: GO 71188
71162: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71163: LD_ADDR_VAR 0 3
71167: PUSH
71168: LD_INT 11
71170: PUSH
71171: LD_INT 12
71173: PUSH
71174: LD_INT 13
71176: PUSH
71177: LD_INT 14
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: LIST
71184: LIST
71185: ST_TO_ADDR
71186: GO 71729
71188: LD_INT 30
71190: DOUBLE
71191: EQUAL
71192: IFTRUE 71196
71194: GO 71222
71196: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71197: LD_ADDR_VAR 0 3
71201: PUSH
71202: LD_INT 11
71204: PUSH
71205: LD_INT 12
71207: PUSH
71208: LD_INT 13
71210: PUSH
71211: LD_INT 14
71213: PUSH
71214: EMPTY
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: ST_TO_ADDR
71220: GO 71729
71222: LD_INT 25
71224: DOUBLE
71225: EQUAL
71226: IFTRUE 71230
71228: GO 71248
71230: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71231: LD_ADDR_VAR 0 3
71235: PUSH
71236: LD_INT 13
71238: PUSH
71239: LD_INT 14
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: ST_TO_ADDR
71246: GO 71729
71248: LD_INT 27
71250: DOUBLE
71251: EQUAL
71252: IFTRUE 71256
71254: GO 71274
71256: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
71257: LD_ADDR_VAR 0 3
71261: PUSH
71262: LD_INT 13
71264: PUSH
71265: LD_INT 14
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: ST_TO_ADDR
71272: GO 71729
71274: LD_INT 92
71276: DOUBLE
71277: EQUAL
71278: IFTRUE 71282
71280: GO 71308
71282: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71283: LD_ADDR_VAR 0 3
71287: PUSH
71288: LD_INT 11
71290: PUSH
71291: LD_INT 12
71293: PUSH
71294: LD_INT 13
71296: PUSH
71297: LD_INT 14
71299: PUSH
71300: EMPTY
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: ST_TO_ADDR
71306: GO 71729
71308: LD_INT 28
71310: DOUBLE
71311: EQUAL
71312: IFTRUE 71316
71314: GO 71334
71316: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71317: LD_ADDR_VAR 0 3
71321: PUSH
71322: LD_INT 13
71324: PUSH
71325: LD_INT 14
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: ST_TO_ADDR
71332: GO 71729
71334: LD_INT 29
71336: DOUBLE
71337: EQUAL
71338: IFTRUE 71342
71340: GO 71360
71342: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71343: LD_ADDR_VAR 0 3
71347: PUSH
71348: LD_INT 13
71350: PUSH
71351: LD_INT 14
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: ST_TO_ADDR
71358: GO 71729
71360: LD_INT 31
71362: DOUBLE
71363: EQUAL
71364: IFTRUE 71368
71366: GO 71386
71368: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71369: LD_ADDR_VAR 0 3
71373: PUSH
71374: LD_INT 13
71376: PUSH
71377: LD_INT 14
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: ST_TO_ADDR
71384: GO 71729
71386: LD_INT 26
71388: DOUBLE
71389: EQUAL
71390: IFTRUE 71394
71392: GO 71412
71394: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71395: LD_ADDR_VAR 0 3
71399: PUSH
71400: LD_INT 13
71402: PUSH
71403: LD_INT 14
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: ST_TO_ADDR
71410: GO 71729
71412: LD_INT 42
71414: DOUBLE
71415: EQUAL
71416: IFTRUE 71420
71418: GO 71446
71420: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71421: LD_ADDR_VAR 0 3
71425: PUSH
71426: LD_INT 21
71428: PUSH
71429: LD_INT 22
71431: PUSH
71432: LD_INT 23
71434: PUSH
71435: LD_INT 24
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: LIST
71442: LIST
71443: ST_TO_ADDR
71444: GO 71729
71446: LD_INT 43
71448: DOUBLE
71449: EQUAL
71450: IFTRUE 71454
71452: GO 71480
71454: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71455: LD_ADDR_VAR 0 3
71459: PUSH
71460: LD_INT 21
71462: PUSH
71463: LD_INT 22
71465: PUSH
71466: LD_INT 23
71468: PUSH
71469: LD_INT 24
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: LIST
71476: LIST
71477: ST_TO_ADDR
71478: GO 71729
71480: LD_INT 44
71482: DOUBLE
71483: EQUAL
71484: IFTRUE 71488
71486: GO 71514
71488: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71489: LD_ADDR_VAR 0 3
71493: PUSH
71494: LD_INT 21
71496: PUSH
71497: LD_INT 22
71499: PUSH
71500: LD_INT 23
71502: PUSH
71503: LD_INT 24
71505: PUSH
71506: EMPTY
71507: LIST
71508: LIST
71509: LIST
71510: LIST
71511: ST_TO_ADDR
71512: GO 71729
71514: LD_INT 45
71516: DOUBLE
71517: EQUAL
71518: IFTRUE 71522
71520: GO 71548
71522: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71523: LD_ADDR_VAR 0 3
71527: PUSH
71528: LD_INT 21
71530: PUSH
71531: LD_INT 22
71533: PUSH
71534: LD_INT 23
71536: PUSH
71537: LD_INT 24
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: ST_TO_ADDR
71546: GO 71729
71548: LD_INT 49
71550: DOUBLE
71551: EQUAL
71552: IFTRUE 71556
71554: GO 71582
71556: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71557: LD_ADDR_VAR 0 3
71561: PUSH
71562: LD_INT 21
71564: PUSH
71565: LD_INT 22
71567: PUSH
71568: LD_INT 23
71570: PUSH
71571: LD_INT 24
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: ST_TO_ADDR
71580: GO 71729
71582: LD_INT 51
71584: DOUBLE
71585: EQUAL
71586: IFTRUE 71590
71588: GO 71616
71590: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71591: LD_ADDR_VAR 0 3
71595: PUSH
71596: LD_INT 21
71598: PUSH
71599: LD_INT 22
71601: PUSH
71602: LD_INT 23
71604: PUSH
71605: LD_INT 24
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: ST_TO_ADDR
71614: GO 71729
71616: LD_INT 52
71618: DOUBLE
71619: EQUAL
71620: IFTRUE 71624
71622: GO 71650
71624: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71625: LD_ADDR_VAR 0 3
71629: PUSH
71630: LD_INT 21
71632: PUSH
71633: LD_INT 22
71635: PUSH
71636: LD_INT 23
71638: PUSH
71639: LD_INT 24
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: ST_TO_ADDR
71648: GO 71729
71650: LD_INT 53
71652: DOUBLE
71653: EQUAL
71654: IFTRUE 71658
71656: GO 71676
71658: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71659: LD_ADDR_VAR 0 3
71663: PUSH
71664: LD_INT 23
71666: PUSH
71667: LD_INT 24
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: ST_TO_ADDR
71674: GO 71729
71676: LD_INT 46
71678: DOUBLE
71679: EQUAL
71680: IFTRUE 71684
71682: GO 71702
71684: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71685: LD_ADDR_VAR 0 3
71689: PUSH
71690: LD_INT 23
71692: PUSH
71693: LD_INT 24
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: ST_TO_ADDR
71700: GO 71729
71702: LD_INT 47
71704: DOUBLE
71705: EQUAL
71706: IFTRUE 71710
71708: GO 71728
71710: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71711: LD_ADDR_VAR 0 3
71715: PUSH
71716: LD_INT 23
71718: PUSH
71719: LD_INT 24
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: ST_TO_ADDR
71726: GO 71729
71728: POP
// result := ( chassis in result ) ;
71729: LD_ADDR_VAR 0 3
71733: PUSH
71734: LD_VAR 0 1
71738: PUSH
71739: LD_VAR 0 3
71743: IN
71744: ST_TO_ADDR
// end ;
71745: LD_VAR 0 3
71749: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71750: LD_INT 0
71752: PPUSH
71753: PPUSH
71754: PPUSH
71755: PPUSH
71756: PPUSH
71757: PPUSH
71758: PPUSH
// result := array ;
71759: LD_ADDR_VAR 0 5
71763: PUSH
71764: LD_VAR 0 1
71768: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71769: LD_VAR 0 1
71773: NOT
71774: PUSH
71775: LD_VAR 0 2
71779: NOT
71780: OR
71781: PUSH
71782: LD_VAR 0 3
71786: NOT
71787: OR
71788: PUSH
71789: LD_VAR 0 2
71793: PUSH
71794: LD_VAR 0 1
71798: GREATER
71799: OR
71800: PUSH
71801: LD_VAR 0 3
71805: PUSH
71806: LD_VAR 0 1
71810: GREATER
71811: OR
71812: IFFALSE 71816
// exit ;
71814: GO 72112
// if direction then
71816: LD_VAR 0 4
71820: IFFALSE 71884
// begin d := 1 ;
71822: LD_ADDR_VAR 0 9
71826: PUSH
71827: LD_INT 1
71829: ST_TO_ADDR
// if i_from > i_to then
71830: LD_VAR 0 2
71834: PUSH
71835: LD_VAR 0 3
71839: GREATER
71840: IFFALSE 71866
// length := ( array - i_from ) + i_to else
71842: LD_ADDR_VAR 0 11
71846: PUSH
71847: LD_VAR 0 1
71851: PUSH
71852: LD_VAR 0 2
71856: MINUS
71857: PUSH
71858: LD_VAR 0 3
71862: PLUS
71863: ST_TO_ADDR
71864: GO 71882
// length := i_to - i_from ;
71866: LD_ADDR_VAR 0 11
71870: PUSH
71871: LD_VAR 0 3
71875: PUSH
71876: LD_VAR 0 2
71880: MINUS
71881: ST_TO_ADDR
// end else
71882: GO 71945
// begin d := - 1 ;
71884: LD_ADDR_VAR 0 9
71888: PUSH
71889: LD_INT 1
71891: NEG
71892: ST_TO_ADDR
// if i_from > i_to then
71893: LD_VAR 0 2
71897: PUSH
71898: LD_VAR 0 3
71902: GREATER
71903: IFFALSE 71923
// length := i_from - i_to else
71905: LD_ADDR_VAR 0 11
71909: PUSH
71910: LD_VAR 0 2
71914: PUSH
71915: LD_VAR 0 3
71919: MINUS
71920: ST_TO_ADDR
71921: GO 71945
// length := ( array - i_to ) + i_from ;
71923: LD_ADDR_VAR 0 11
71927: PUSH
71928: LD_VAR 0 1
71932: PUSH
71933: LD_VAR 0 3
71937: MINUS
71938: PUSH
71939: LD_VAR 0 2
71943: PLUS
71944: ST_TO_ADDR
// end ; if not length then
71945: LD_VAR 0 11
71949: NOT
71950: IFFALSE 71954
// exit ;
71952: GO 72112
// tmp := array ;
71954: LD_ADDR_VAR 0 10
71958: PUSH
71959: LD_VAR 0 1
71963: ST_TO_ADDR
// for i = 1 to length do
71964: LD_ADDR_VAR 0 6
71968: PUSH
71969: DOUBLE
71970: LD_INT 1
71972: DEC
71973: ST_TO_ADDR
71974: LD_VAR 0 11
71978: PUSH
71979: FOR_TO
71980: IFFALSE 72100
// begin for j = 1 to array do
71982: LD_ADDR_VAR 0 7
71986: PUSH
71987: DOUBLE
71988: LD_INT 1
71990: DEC
71991: ST_TO_ADDR
71992: LD_VAR 0 1
71996: PUSH
71997: FOR_TO
71998: IFFALSE 72086
// begin k := j + d ;
72000: LD_ADDR_VAR 0 8
72004: PUSH
72005: LD_VAR 0 7
72009: PUSH
72010: LD_VAR 0 9
72014: PLUS
72015: ST_TO_ADDR
// if k > array then
72016: LD_VAR 0 8
72020: PUSH
72021: LD_VAR 0 1
72025: GREATER
72026: IFFALSE 72036
// k := 1 ;
72028: LD_ADDR_VAR 0 8
72032: PUSH
72033: LD_INT 1
72035: ST_TO_ADDR
// if not k then
72036: LD_VAR 0 8
72040: NOT
72041: IFFALSE 72053
// k := array ;
72043: LD_ADDR_VAR 0 8
72047: PUSH
72048: LD_VAR 0 1
72052: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
72053: LD_ADDR_VAR 0 10
72057: PUSH
72058: LD_VAR 0 10
72062: PPUSH
72063: LD_VAR 0 8
72067: PPUSH
72068: LD_VAR 0 1
72072: PUSH
72073: LD_VAR 0 7
72077: ARRAY
72078: PPUSH
72079: CALL_OW 1
72083: ST_TO_ADDR
// end ;
72084: GO 71997
72086: POP
72087: POP
// array := tmp ;
72088: LD_ADDR_VAR 0 1
72092: PUSH
72093: LD_VAR 0 10
72097: ST_TO_ADDR
// end ;
72098: GO 71979
72100: POP
72101: POP
// result := array ;
72102: LD_ADDR_VAR 0 5
72106: PUSH
72107: LD_VAR 0 1
72111: ST_TO_ADDR
// end ;
72112: LD_VAR 0 5
72116: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
72117: LD_INT 0
72119: PPUSH
72120: PPUSH
// result := 0 ;
72121: LD_ADDR_VAR 0 3
72125: PUSH
72126: LD_INT 0
72128: ST_TO_ADDR
// if not array or not value in array then
72129: LD_VAR 0 1
72133: NOT
72134: PUSH
72135: LD_VAR 0 2
72139: PUSH
72140: LD_VAR 0 1
72144: IN
72145: NOT
72146: OR
72147: IFFALSE 72151
// exit ;
72149: GO 72205
// for i = 1 to array do
72151: LD_ADDR_VAR 0 4
72155: PUSH
72156: DOUBLE
72157: LD_INT 1
72159: DEC
72160: ST_TO_ADDR
72161: LD_VAR 0 1
72165: PUSH
72166: FOR_TO
72167: IFFALSE 72203
// if value = array [ i ] then
72169: LD_VAR 0 2
72173: PUSH
72174: LD_VAR 0 1
72178: PUSH
72179: LD_VAR 0 4
72183: ARRAY
72184: EQUAL
72185: IFFALSE 72201
// begin result := i ;
72187: LD_ADDR_VAR 0 3
72191: PUSH
72192: LD_VAR 0 4
72196: ST_TO_ADDR
// exit ;
72197: POP
72198: POP
72199: GO 72205
// end ;
72201: GO 72166
72203: POP
72204: POP
// end ;
72205: LD_VAR 0 3
72209: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72210: LD_INT 0
72212: PPUSH
// vc_chassis := chassis ;
72213: LD_ADDR_OWVAR 37
72217: PUSH
72218: LD_VAR 0 1
72222: ST_TO_ADDR
// vc_engine := engine ;
72223: LD_ADDR_OWVAR 39
72227: PUSH
72228: LD_VAR 0 2
72232: ST_TO_ADDR
// vc_control := control ;
72233: LD_ADDR_OWVAR 38
72237: PUSH
72238: LD_VAR 0 3
72242: ST_TO_ADDR
// vc_weapon := weapon ;
72243: LD_ADDR_OWVAR 40
72247: PUSH
72248: LD_VAR 0 4
72252: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72253: LD_ADDR_OWVAR 41
72257: PUSH
72258: LD_VAR 0 5
72262: ST_TO_ADDR
// end ;
72263: LD_VAR 0 6
72267: RET
// export function WantPlant ( unit ) ; var task ; begin
72268: LD_INT 0
72270: PPUSH
72271: PPUSH
// result := false ;
72272: LD_ADDR_VAR 0 2
72276: PUSH
72277: LD_INT 0
72279: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72280: LD_ADDR_VAR 0 3
72284: PUSH
72285: LD_VAR 0 1
72289: PPUSH
72290: CALL_OW 437
72294: ST_TO_ADDR
// if task then
72295: LD_VAR 0 3
72299: IFFALSE 72327
// if task [ 1 ] [ 1 ] = p then
72301: LD_VAR 0 3
72305: PUSH
72306: LD_INT 1
72308: ARRAY
72309: PUSH
72310: LD_INT 1
72312: ARRAY
72313: PUSH
72314: LD_STRING p
72316: EQUAL
72317: IFFALSE 72327
// result := true ;
72319: LD_ADDR_VAR 0 2
72323: PUSH
72324: LD_INT 1
72326: ST_TO_ADDR
// end ;
72327: LD_VAR 0 2
72331: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72332: LD_INT 0
72334: PPUSH
72335: PPUSH
72336: PPUSH
72337: PPUSH
// if pos < 1 then
72338: LD_VAR 0 2
72342: PUSH
72343: LD_INT 1
72345: LESS
72346: IFFALSE 72350
// exit ;
72348: GO 72653
// if pos = 1 then
72350: LD_VAR 0 2
72354: PUSH
72355: LD_INT 1
72357: EQUAL
72358: IFFALSE 72391
// result := Replace ( arr , pos [ 1 ] , value ) else
72360: LD_ADDR_VAR 0 4
72364: PUSH
72365: LD_VAR 0 1
72369: PPUSH
72370: LD_VAR 0 2
72374: PUSH
72375: LD_INT 1
72377: ARRAY
72378: PPUSH
72379: LD_VAR 0 3
72383: PPUSH
72384: CALL_OW 1
72388: ST_TO_ADDR
72389: GO 72653
// begin tmp := arr ;
72391: LD_ADDR_VAR 0 6
72395: PUSH
72396: LD_VAR 0 1
72400: ST_TO_ADDR
// s_arr := [ tmp ] ;
72401: LD_ADDR_VAR 0 7
72405: PUSH
72406: LD_VAR 0 6
72410: PUSH
72411: EMPTY
72412: LIST
72413: ST_TO_ADDR
// for i = 1 to pos - 1 do
72414: LD_ADDR_VAR 0 5
72418: PUSH
72419: DOUBLE
72420: LD_INT 1
72422: DEC
72423: ST_TO_ADDR
72424: LD_VAR 0 2
72428: PUSH
72429: LD_INT 1
72431: MINUS
72432: PUSH
72433: FOR_TO
72434: IFFALSE 72479
// begin tmp := tmp [ pos [ i ] ] ;
72436: LD_ADDR_VAR 0 6
72440: PUSH
72441: LD_VAR 0 6
72445: PUSH
72446: LD_VAR 0 2
72450: PUSH
72451: LD_VAR 0 5
72455: ARRAY
72456: ARRAY
72457: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72458: LD_ADDR_VAR 0 7
72462: PUSH
72463: LD_VAR 0 7
72467: PUSH
72468: LD_VAR 0 6
72472: PUSH
72473: EMPTY
72474: LIST
72475: ADD
72476: ST_TO_ADDR
// end ;
72477: GO 72433
72479: POP
72480: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72481: LD_ADDR_VAR 0 6
72485: PUSH
72486: LD_VAR 0 6
72490: PPUSH
72491: LD_VAR 0 2
72495: PUSH
72496: LD_VAR 0 2
72500: ARRAY
72501: PPUSH
72502: LD_VAR 0 3
72506: PPUSH
72507: CALL_OW 1
72511: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72512: LD_ADDR_VAR 0 7
72516: PUSH
72517: LD_VAR 0 7
72521: PPUSH
72522: LD_VAR 0 7
72526: PPUSH
72527: LD_VAR 0 6
72531: PPUSH
72532: CALL_OW 1
72536: ST_TO_ADDR
// for i = s_arr downto 2 do
72537: LD_ADDR_VAR 0 5
72541: PUSH
72542: DOUBLE
72543: LD_VAR 0 7
72547: INC
72548: ST_TO_ADDR
72549: LD_INT 2
72551: PUSH
72552: FOR_DOWNTO
72553: IFFALSE 72637
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72555: LD_ADDR_VAR 0 6
72559: PUSH
72560: LD_VAR 0 7
72564: PUSH
72565: LD_VAR 0 5
72569: PUSH
72570: LD_INT 1
72572: MINUS
72573: ARRAY
72574: PPUSH
72575: LD_VAR 0 2
72579: PUSH
72580: LD_VAR 0 5
72584: PUSH
72585: LD_INT 1
72587: MINUS
72588: ARRAY
72589: PPUSH
72590: LD_VAR 0 7
72594: PUSH
72595: LD_VAR 0 5
72599: ARRAY
72600: PPUSH
72601: CALL_OW 1
72605: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72606: LD_ADDR_VAR 0 7
72610: PUSH
72611: LD_VAR 0 7
72615: PPUSH
72616: LD_VAR 0 5
72620: PUSH
72621: LD_INT 1
72623: MINUS
72624: PPUSH
72625: LD_VAR 0 6
72629: PPUSH
72630: CALL_OW 1
72634: ST_TO_ADDR
// end ;
72635: GO 72552
72637: POP
72638: POP
// result := s_arr [ 1 ] ;
72639: LD_ADDR_VAR 0 4
72643: PUSH
72644: LD_VAR 0 7
72648: PUSH
72649: LD_INT 1
72651: ARRAY
72652: ST_TO_ADDR
// end ; end ;
72653: LD_VAR 0 4
72657: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72658: LD_INT 0
72660: PPUSH
72661: PPUSH
// if not list then
72662: LD_VAR 0 1
72666: NOT
72667: IFFALSE 72671
// exit ;
72669: GO 72762
// i := list [ pos1 ] ;
72671: LD_ADDR_VAR 0 5
72675: PUSH
72676: LD_VAR 0 1
72680: PUSH
72681: LD_VAR 0 2
72685: ARRAY
72686: ST_TO_ADDR
// if not i then
72687: LD_VAR 0 5
72691: NOT
72692: IFFALSE 72696
// exit ;
72694: GO 72762
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72696: LD_ADDR_VAR 0 1
72700: PUSH
72701: LD_VAR 0 1
72705: PPUSH
72706: LD_VAR 0 2
72710: PPUSH
72711: LD_VAR 0 1
72715: PUSH
72716: LD_VAR 0 3
72720: ARRAY
72721: PPUSH
72722: CALL_OW 1
72726: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72727: LD_ADDR_VAR 0 1
72731: PUSH
72732: LD_VAR 0 1
72736: PPUSH
72737: LD_VAR 0 3
72741: PPUSH
72742: LD_VAR 0 5
72746: PPUSH
72747: CALL_OW 1
72751: ST_TO_ADDR
// result := list ;
72752: LD_ADDR_VAR 0 4
72756: PUSH
72757: LD_VAR 0 1
72761: ST_TO_ADDR
// end ;
72762: LD_VAR 0 4
72766: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72767: LD_INT 0
72769: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72770: LD_ADDR_VAR 0 5
72774: PUSH
72775: LD_VAR 0 1
72779: PPUSH
72780: CALL_OW 250
72784: PPUSH
72785: LD_VAR 0 1
72789: PPUSH
72790: CALL_OW 251
72794: PPUSH
72795: LD_VAR 0 2
72799: PPUSH
72800: LD_VAR 0 3
72804: PPUSH
72805: LD_VAR 0 4
72809: PPUSH
72810: CALL 72820 0 5
72814: ST_TO_ADDR
// end ;
72815: LD_VAR 0 5
72819: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72820: LD_INT 0
72822: PPUSH
72823: PPUSH
72824: PPUSH
72825: PPUSH
// if not list then
72826: LD_VAR 0 3
72830: NOT
72831: IFFALSE 72835
// exit ;
72833: GO 73223
// result := [ ] ;
72835: LD_ADDR_VAR 0 6
72839: PUSH
72840: EMPTY
72841: ST_TO_ADDR
// for i in list do
72842: LD_ADDR_VAR 0 7
72846: PUSH
72847: LD_VAR 0 3
72851: PUSH
72852: FOR_IN
72853: IFFALSE 73055
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72855: LD_ADDR_VAR 0 9
72859: PUSH
72860: LD_VAR 0 7
72864: PPUSH
72865: LD_VAR 0 1
72869: PPUSH
72870: LD_VAR 0 2
72874: PPUSH
72875: CALL_OW 297
72879: ST_TO_ADDR
// if not result then
72880: LD_VAR 0 6
72884: NOT
72885: IFFALSE 72911
// result := [ [ i , tmp ] ] else
72887: LD_ADDR_VAR 0 6
72891: PUSH
72892: LD_VAR 0 7
72896: PUSH
72897: LD_VAR 0 9
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: EMPTY
72907: LIST
72908: ST_TO_ADDR
72909: GO 73053
// begin if result [ result ] [ 2 ] < tmp then
72911: LD_VAR 0 6
72915: PUSH
72916: LD_VAR 0 6
72920: ARRAY
72921: PUSH
72922: LD_INT 2
72924: ARRAY
72925: PUSH
72926: LD_VAR 0 9
72930: LESS
72931: IFFALSE 72973
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72933: LD_ADDR_VAR 0 6
72937: PUSH
72938: LD_VAR 0 6
72942: PPUSH
72943: LD_VAR 0 6
72947: PUSH
72948: LD_INT 1
72950: PLUS
72951: PPUSH
72952: LD_VAR 0 7
72956: PUSH
72957: LD_VAR 0 9
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PPUSH
72966: CALL_OW 2
72970: ST_TO_ADDR
72971: GO 73053
// for j = 1 to result do
72973: LD_ADDR_VAR 0 8
72977: PUSH
72978: DOUBLE
72979: LD_INT 1
72981: DEC
72982: ST_TO_ADDR
72983: LD_VAR 0 6
72987: PUSH
72988: FOR_TO
72989: IFFALSE 73051
// begin if tmp < result [ j ] [ 2 ] then
72991: LD_VAR 0 9
72995: PUSH
72996: LD_VAR 0 6
73000: PUSH
73001: LD_VAR 0 8
73005: ARRAY
73006: PUSH
73007: LD_INT 2
73009: ARRAY
73010: LESS
73011: IFFALSE 73049
// begin result := Insert ( result , j , [ i , tmp ] ) ;
73013: LD_ADDR_VAR 0 6
73017: PUSH
73018: LD_VAR 0 6
73022: PPUSH
73023: LD_VAR 0 8
73027: PPUSH
73028: LD_VAR 0 7
73032: PUSH
73033: LD_VAR 0 9
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PPUSH
73042: CALL_OW 2
73046: ST_TO_ADDR
// break ;
73047: GO 73051
// end ; end ;
73049: GO 72988
73051: POP
73052: POP
// end ; end ;
73053: GO 72852
73055: POP
73056: POP
// if result and not asc then
73057: LD_VAR 0 6
73061: PUSH
73062: LD_VAR 0 4
73066: NOT
73067: AND
73068: IFFALSE 73143
// begin tmp := result ;
73070: LD_ADDR_VAR 0 9
73074: PUSH
73075: LD_VAR 0 6
73079: ST_TO_ADDR
// for i = tmp downto 1 do
73080: LD_ADDR_VAR 0 7
73084: PUSH
73085: DOUBLE
73086: LD_VAR 0 9
73090: INC
73091: ST_TO_ADDR
73092: LD_INT 1
73094: PUSH
73095: FOR_DOWNTO
73096: IFFALSE 73141
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
73098: LD_ADDR_VAR 0 6
73102: PUSH
73103: LD_VAR 0 6
73107: PPUSH
73108: LD_VAR 0 9
73112: PUSH
73113: LD_VAR 0 7
73117: MINUS
73118: PUSH
73119: LD_INT 1
73121: PLUS
73122: PPUSH
73123: LD_VAR 0 9
73127: PUSH
73128: LD_VAR 0 7
73132: ARRAY
73133: PPUSH
73134: CALL_OW 1
73138: ST_TO_ADDR
73139: GO 73095
73141: POP
73142: POP
// end ; tmp := [ ] ;
73143: LD_ADDR_VAR 0 9
73147: PUSH
73148: EMPTY
73149: ST_TO_ADDR
// if mode then
73150: LD_VAR 0 5
73154: IFFALSE 73223
// begin for i = 1 to result do
73156: LD_ADDR_VAR 0 7
73160: PUSH
73161: DOUBLE
73162: LD_INT 1
73164: DEC
73165: ST_TO_ADDR
73166: LD_VAR 0 6
73170: PUSH
73171: FOR_TO
73172: IFFALSE 73211
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73174: LD_ADDR_VAR 0 9
73178: PUSH
73179: LD_VAR 0 9
73183: PPUSH
73184: LD_VAR 0 7
73188: PPUSH
73189: LD_VAR 0 6
73193: PUSH
73194: LD_VAR 0 7
73198: ARRAY
73199: PUSH
73200: LD_INT 1
73202: ARRAY
73203: PPUSH
73204: CALL_OW 1
73208: ST_TO_ADDR
73209: GO 73171
73211: POP
73212: POP
// result := tmp ;
73213: LD_ADDR_VAR 0 6
73217: PUSH
73218: LD_VAR 0 9
73222: ST_TO_ADDR
// end ; end ;
73223: LD_VAR 0 6
73227: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73228: LD_INT 0
73230: PPUSH
73231: PPUSH
73232: PPUSH
73233: PPUSH
73234: PPUSH
73235: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73236: LD_ADDR_VAR 0 5
73240: PUSH
73241: LD_INT 0
73243: PUSH
73244: LD_INT 0
73246: PUSH
73247: LD_INT 0
73249: PUSH
73250: EMPTY
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: LIST
73256: LIST
73257: ST_TO_ADDR
// if not x or not y then
73258: LD_VAR 0 2
73262: NOT
73263: PUSH
73264: LD_VAR 0 3
73268: NOT
73269: OR
73270: IFFALSE 73274
// exit ;
73272: GO 74924
// if not range then
73274: LD_VAR 0 4
73278: NOT
73279: IFFALSE 73289
// range := 10 ;
73281: LD_ADDR_VAR 0 4
73285: PUSH
73286: LD_INT 10
73288: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73289: LD_ADDR_VAR 0 8
73293: PUSH
73294: LD_INT 81
73296: PUSH
73297: LD_VAR 0 1
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 92
73308: PUSH
73309: LD_VAR 0 2
73313: PUSH
73314: LD_VAR 0 3
73318: PUSH
73319: LD_VAR 0 4
73323: PUSH
73324: EMPTY
73325: LIST
73326: LIST
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 3
73332: PUSH
73333: LD_INT 21
73335: PUSH
73336: LD_INT 3
73338: PUSH
73339: EMPTY
73340: LIST
73341: LIST
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: EMPTY
73348: LIST
73349: LIST
73350: LIST
73351: PPUSH
73352: CALL_OW 69
73356: ST_TO_ADDR
// if not tmp then
73357: LD_VAR 0 8
73361: NOT
73362: IFFALSE 73366
// exit ;
73364: GO 74924
// for i in tmp do
73366: LD_ADDR_VAR 0 6
73370: PUSH
73371: LD_VAR 0 8
73375: PUSH
73376: FOR_IN
73377: IFFALSE 74899
// begin points := [ 0 , 0 , 0 ] ;
73379: LD_ADDR_VAR 0 9
73383: PUSH
73384: LD_INT 0
73386: PUSH
73387: LD_INT 0
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: LIST
73397: ST_TO_ADDR
// bpoints := 1 ;
73398: LD_ADDR_VAR 0 10
73402: PUSH
73403: LD_INT 1
73405: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73406: LD_VAR 0 6
73410: PPUSH
73411: CALL_OW 247
73415: PUSH
73416: LD_INT 1
73418: DOUBLE
73419: EQUAL
73420: IFTRUE 73424
73422: GO 74002
73424: POP
// begin if GetClass ( i ) = 1 then
73425: LD_VAR 0 6
73429: PPUSH
73430: CALL_OW 257
73434: PUSH
73435: LD_INT 1
73437: EQUAL
73438: IFFALSE 73459
// points := [ 10 , 5 , 3 ] ;
73440: LD_ADDR_VAR 0 9
73444: PUSH
73445: LD_INT 10
73447: PUSH
73448: LD_INT 5
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: LIST
73458: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73459: LD_VAR 0 6
73463: PPUSH
73464: CALL_OW 257
73468: PUSH
73469: LD_INT 2
73471: PUSH
73472: LD_INT 3
73474: PUSH
73475: LD_INT 4
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: LIST
73482: IN
73483: IFFALSE 73504
// points := [ 3 , 2 , 1 ] ;
73485: LD_ADDR_VAR 0 9
73489: PUSH
73490: LD_INT 3
73492: PUSH
73493: LD_INT 2
73495: PUSH
73496: LD_INT 1
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: LIST
73503: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73504: LD_VAR 0 6
73508: PPUSH
73509: CALL_OW 257
73513: PUSH
73514: LD_INT 5
73516: EQUAL
73517: IFFALSE 73538
// points := [ 130 , 5 , 2 ] ;
73519: LD_ADDR_VAR 0 9
73523: PUSH
73524: LD_INT 130
73526: PUSH
73527: LD_INT 5
73529: PUSH
73530: LD_INT 2
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73538: LD_VAR 0 6
73542: PPUSH
73543: CALL_OW 257
73547: PUSH
73548: LD_INT 8
73550: EQUAL
73551: IFFALSE 73572
// points := [ 35 , 35 , 30 ] ;
73553: LD_ADDR_VAR 0 9
73557: PUSH
73558: LD_INT 35
73560: PUSH
73561: LD_INT 35
73563: PUSH
73564: LD_INT 30
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: LIST
73571: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73572: LD_VAR 0 6
73576: PPUSH
73577: CALL_OW 257
73581: PUSH
73582: LD_INT 9
73584: EQUAL
73585: IFFALSE 73606
// points := [ 20 , 55 , 40 ] ;
73587: LD_ADDR_VAR 0 9
73591: PUSH
73592: LD_INT 20
73594: PUSH
73595: LD_INT 55
73597: PUSH
73598: LD_INT 40
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: LIST
73605: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73606: LD_VAR 0 6
73610: PPUSH
73611: CALL_OW 257
73615: PUSH
73616: LD_INT 12
73618: PUSH
73619: LD_INT 16
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: IN
73626: IFFALSE 73647
// points := [ 5 , 3 , 2 ] ;
73628: LD_ADDR_VAR 0 9
73632: PUSH
73633: LD_INT 5
73635: PUSH
73636: LD_INT 3
73638: PUSH
73639: LD_INT 2
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: LIST
73646: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73647: LD_VAR 0 6
73651: PPUSH
73652: CALL_OW 257
73656: PUSH
73657: LD_INT 17
73659: EQUAL
73660: IFFALSE 73681
// points := [ 100 , 50 , 75 ] ;
73662: LD_ADDR_VAR 0 9
73666: PUSH
73667: LD_INT 100
73669: PUSH
73670: LD_INT 50
73672: PUSH
73673: LD_INT 75
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: LIST
73680: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73681: LD_VAR 0 6
73685: PPUSH
73686: CALL_OW 257
73690: PUSH
73691: LD_INT 15
73693: EQUAL
73694: IFFALSE 73715
// points := [ 10 , 5 , 3 ] ;
73696: LD_ADDR_VAR 0 9
73700: PUSH
73701: LD_INT 10
73703: PUSH
73704: LD_INT 5
73706: PUSH
73707: LD_INT 3
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: LIST
73714: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73715: LD_VAR 0 6
73719: PPUSH
73720: CALL_OW 257
73724: PUSH
73725: LD_INT 14
73727: EQUAL
73728: IFFALSE 73749
// points := [ 10 , 0 , 0 ] ;
73730: LD_ADDR_VAR 0 9
73734: PUSH
73735: LD_INT 10
73737: PUSH
73738: LD_INT 0
73740: PUSH
73741: LD_INT 0
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: LIST
73748: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73749: LD_VAR 0 6
73753: PPUSH
73754: CALL_OW 257
73758: PUSH
73759: LD_INT 11
73761: EQUAL
73762: IFFALSE 73783
// points := [ 30 , 10 , 5 ] ;
73764: LD_ADDR_VAR 0 9
73768: PUSH
73769: LD_INT 30
73771: PUSH
73772: LD_INT 10
73774: PUSH
73775: LD_INT 5
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: LIST
73782: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73783: LD_VAR 0 1
73787: PPUSH
73788: LD_INT 5
73790: PPUSH
73791: CALL_OW 321
73795: PUSH
73796: LD_INT 2
73798: EQUAL
73799: IFFALSE 73816
// bpoints := bpoints * 1.8 ;
73801: LD_ADDR_VAR 0 10
73805: PUSH
73806: LD_VAR 0 10
73810: PUSH
73811: LD_REAL  1.80000000000000E+0000
73814: MUL
73815: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73816: LD_VAR 0 6
73820: PPUSH
73821: CALL_OW 257
73825: PUSH
73826: LD_INT 1
73828: PUSH
73829: LD_INT 2
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: LD_INT 4
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: IN
73844: PUSH
73845: LD_VAR 0 1
73849: PPUSH
73850: LD_INT 51
73852: PPUSH
73853: CALL_OW 321
73857: PUSH
73858: LD_INT 2
73860: EQUAL
73861: AND
73862: IFFALSE 73879
// bpoints := bpoints * 1.2 ;
73864: LD_ADDR_VAR 0 10
73868: PUSH
73869: LD_VAR 0 10
73873: PUSH
73874: LD_REAL  1.20000000000000E+0000
73877: MUL
73878: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73879: LD_VAR 0 6
73883: PPUSH
73884: CALL_OW 257
73888: PUSH
73889: LD_INT 5
73891: PUSH
73892: LD_INT 7
73894: PUSH
73895: LD_INT 9
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: LIST
73902: IN
73903: PUSH
73904: LD_VAR 0 1
73908: PPUSH
73909: LD_INT 52
73911: PPUSH
73912: CALL_OW 321
73916: PUSH
73917: LD_INT 2
73919: EQUAL
73920: AND
73921: IFFALSE 73938
// bpoints := bpoints * 1.5 ;
73923: LD_ADDR_VAR 0 10
73927: PUSH
73928: LD_VAR 0 10
73932: PUSH
73933: LD_REAL  1.50000000000000E+0000
73936: MUL
73937: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73938: LD_VAR 0 1
73942: PPUSH
73943: LD_INT 66
73945: PPUSH
73946: CALL_OW 321
73950: PUSH
73951: LD_INT 2
73953: EQUAL
73954: IFFALSE 73971
// bpoints := bpoints * 1.1 ;
73956: LD_ADDR_VAR 0 10
73960: PUSH
73961: LD_VAR 0 10
73965: PUSH
73966: LD_REAL  1.10000000000000E+0000
73969: MUL
73970: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73971: LD_ADDR_VAR 0 10
73975: PUSH
73976: LD_VAR 0 10
73980: PUSH
73981: LD_VAR 0 6
73985: PPUSH
73986: LD_INT 1
73988: PPUSH
73989: CALL_OW 259
73993: PUSH
73994: LD_REAL  1.15000000000000E+0000
73997: MUL
73998: MUL
73999: ST_TO_ADDR
// end ; unit_vehicle :
74000: GO 74828
74002: LD_INT 2
74004: DOUBLE
74005: EQUAL
74006: IFTRUE 74010
74008: GO 74816
74010: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
74011: LD_VAR 0 6
74015: PPUSH
74016: CALL_OW 264
74020: PUSH
74021: LD_INT 2
74023: PUSH
74024: LD_INT 42
74026: PUSH
74027: LD_INT 24
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: LIST
74034: IN
74035: IFFALSE 74056
// points := [ 25 , 5 , 3 ] ;
74037: LD_ADDR_VAR 0 9
74041: PUSH
74042: LD_INT 25
74044: PUSH
74045: LD_INT 5
74047: PUSH
74048: LD_INT 3
74050: PUSH
74051: EMPTY
74052: LIST
74053: LIST
74054: LIST
74055: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
74056: LD_VAR 0 6
74060: PPUSH
74061: CALL_OW 264
74065: PUSH
74066: LD_INT 4
74068: PUSH
74069: LD_INT 43
74071: PUSH
74072: LD_INT 25
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: LIST
74079: IN
74080: IFFALSE 74101
// points := [ 40 , 15 , 5 ] ;
74082: LD_ADDR_VAR 0 9
74086: PUSH
74087: LD_INT 40
74089: PUSH
74090: LD_INT 15
74092: PUSH
74093: LD_INT 5
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: LIST
74100: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
74101: LD_VAR 0 6
74105: PPUSH
74106: CALL_OW 264
74110: PUSH
74111: LD_INT 3
74113: PUSH
74114: LD_INT 23
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: IN
74121: IFFALSE 74142
// points := [ 7 , 25 , 8 ] ;
74123: LD_ADDR_VAR 0 9
74127: PUSH
74128: LD_INT 7
74130: PUSH
74131: LD_INT 25
74133: PUSH
74134: LD_INT 8
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: LIST
74141: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74142: LD_VAR 0 6
74146: PPUSH
74147: CALL_OW 264
74151: PUSH
74152: LD_INT 5
74154: PUSH
74155: LD_INT 27
74157: PUSH
74158: LD_INT 44
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: LIST
74165: IN
74166: IFFALSE 74187
// points := [ 14 , 50 , 16 ] ;
74168: LD_ADDR_VAR 0 9
74172: PUSH
74173: LD_INT 14
74175: PUSH
74176: LD_INT 50
74178: PUSH
74179: LD_INT 16
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: LIST
74186: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74187: LD_VAR 0 6
74191: PPUSH
74192: CALL_OW 264
74196: PUSH
74197: LD_INT 6
74199: PUSH
74200: LD_INT 46
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: IN
74207: IFFALSE 74228
// points := [ 32 , 120 , 70 ] ;
74209: LD_ADDR_VAR 0 9
74213: PUSH
74214: LD_INT 32
74216: PUSH
74217: LD_INT 120
74219: PUSH
74220: LD_INT 70
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: LIST
74227: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
74228: LD_VAR 0 6
74232: PPUSH
74233: CALL_OW 264
74237: PUSH
74238: LD_INT 7
74240: PUSH
74241: LD_INT 28
74243: PUSH
74244: LD_INT 45
74246: PUSH
74247: LD_INT 92
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: IN
74256: IFFALSE 74277
// points := [ 35 , 20 , 45 ] ;
74258: LD_ADDR_VAR 0 9
74262: PUSH
74263: LD_INT 35
74265: PUSH
74266: LD_INT 20
74268: PUSH
74269: LD_INT 45
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: LIST
74276: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74277: LD_VAR 0 6
74281: PPUSH
74282: CALL_OW 264
74286: PUSH
74287: LD_INT 47
74289: PUSH
74290: EMPTY
74291: LIST
74292: IN
74293: IFFALSE 74314
// points := [ 67 , 45 , 75 ] ;
74295: LD_ADDR_VAR 0 9
74299: PUSH
74300: LD_INT 67
74302: PUSH
74303: LD_INT 45
74305: PUSH
74306: LD_INT 75
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: LIST
74313: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74314: LD_VAR 0 6
74318: PPUSH
74319: CALL_OW 264
74323: PUSH
74324: LD_INT 26
74326: PUSH
74327: EMPTY
74328: LIST
74329: IN
74330: IFFALSE 74351
// points := [ 120 , 30 , 80 ] ;
74332: LD_ADDR_VAR 0 9
74336: PUSH
74337: LD_INT 120
74339: PUSH
74340: LD_INT 30
74342: PUSH
74343: LD_INT 80
74345: PUSH
74346: EMPTY
74347: LIST
74348: LIST
74349: LIST
74350: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74351: LD_VAR 0 6
74355: PPUSH
74356: CALL_OW 264
74360: PUSH
74361: LD_INT 22
74363: PUSH
74364: EMPTY
74365: LIST
74366: IN
74367: IFFALSE 74388
// points := [ 40 , 1 , 1 ] ;
74369: LD_ADDR_VAR 0 9
74373: PUSH
74374: LD_INT 40
74376: PUSH
74377: LD_INT 1
74379: PUSH
74380: LD_INT 1
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: LIST
74387: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74388: LD_VAR 0 6
74392: PPUSH
74393: CALL_OW 264
74397: PUSH
74398: LD_INT 29
74400: PUSH
74401: EMPTY
74402: LIST
74403: IN
74404: IFFALSE 74425
// points := [ 70 , 200 , 400 ] ;
74406: LD_ADDR_VAR 0 9
74410: PUSH
74411: LD_INT 70
74413: PUSH
74414: LD_INT 200
74416: PUSH
74417: LD_INT 400
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: LIST
74424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74425: LD_VAR 0 6
74429: PPUSH
74430: CALL_OW 264
74434: PUSH
74435: LD_INT 14
74437: PUSH
74438: LD_INT 53
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: IN
74445: IFFALSE 74466
// points := [ 40 , 10 , 20 ] ;
74447: LD_ADDR_VAR 0 9
74451: PUSH
74452: LD_INT 40
74454: PUSH
74455: LD_INT 10
74457: PUSH
74458: LD_INT 20
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: LIST
74465: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74466: LD_VAR 0 6
74470: PPUSH
74471: CALL_OW 264
74475: PUSH
74476: LD_INT 9
74478: PUSH
74479: EMPTY
74480: LIST
74481: IN
74482: IFFALSE 74503
// points := [ 5 , 70 , 20 ] ;
74484: LD_ADDR_VAR 0 9
74488: PUSH
74489: LD_INT 5
74491: PUSH
74492: LD_INT 70
74494: PUSH
74495: LD_INT 20
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: LIST
74502: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74503: LD_VAR 0 6
74507: PPUSH
74508: CALL_OW 264
74512: PUSH
74513: LD_INT 10
74515: PUSH
74516: EMPTY
74517: LIST
74518: IN
74519: IFFALSE 74540
// points := [ 35 , 110 , 70 ] ;
74521: LD_ADDR_VAR 0 9
74525: PUSH
74526: LD_INT 35
74528: PUSH
74529: LD_INT 110
74531: PUSH
74532: LD_INT 70
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: LIST
74539: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74540: LD_VAR 0 6
74544: PPUSH
74545: CALL_OW 265
74549: PUSH
74550: LD_INT 25
74552: EQUAL
74553: IFFALSE 74574
// points := [ 80 , 65 , 100 ] ;
74555: LD_ADDR_VAR 0 9
74559: PUSH
74560: LD_INT 80
74562: PUSH
74563: LD_INT 65
74565: PUSH
74566: LD_INT 100
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74574: LD_VAR 0 6
74578: PPUSH
74579: CALL_OW 263
74583: PUSH
74584: LD_INT 1
74586: EQUAL
74587: IFFALSE 74622
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74589: LD_ADDR_VAR 0 10
74593: PUSH
74594: LD_VAR 0 10
74598: PUSH
74599: LD_VAR 0 6
74603: PPUSH
74604: CALL_OW 311
74608: PPUSH
74609: LD_INT 3
74611: PPUSH
74612: CALL_OW 259
74616: PUSH
74617: LD_INT 4
74619: MUL
74620: MUL
74621: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74622: LD_VAR 0 6
74626: PPUSH
74627: CALL_OW 263
74631: PUSH
74632: LD_INT 2
74634: EQUAL
74635: IFFALSE 74686
// begin j := IsControledBy ( i ) ;
74637: LD_ADDR_VAR 0 7
74641: PUSH
74642: LD_VAR 0 6
74646: PPUSH
74647: CALL_OW 312
74651: ST_TO_ADDR
// if j then
74652: LD_VAR 0 7
74656: IFFALSE 74686
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74658: LD_ADDR_VAR 0 10
74662: PUSH
74663: LD_VAR 0 10
74667: PUSH
74668: LD_VAR 0 7
74672: PPUSH
74673: LD_INT 3
74675: PPUSH
74676: CALL_OW 259
74680: PUSH
74681: LD_INT 3
74683: MUL
74684: MUL
74685: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74686: LD_VAR 0 6
74690: PPUSH
74691: CALL_OW 264
74695: PUSH
74696: LD_INT 5
74698: PUSH
74699: LD_INT 6
74701: PUSH
74702: LD_INT 46
74704: PUSH
74705: LD_INT 44
74707: PUSH
74708: LD_INT 47
74710: PUSH
74711: LD_INT 45
74713: PUSH
74714: LD_INT 28
74716: PUSH
74717: LD_INT 7
74719: PUSH
74720: LD_INT 27
74722: PUSH
74723: LD_INT 29
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: LIST
74730: LIST
74731: LIST
74732: LIST
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: IN
74738: PUSH
74739: LD_VAR 0 1
74743: PPUSH
74744: LD_INT 52
74746: PPUSH
74747: CALL_OW 321
74751: PUSH
74752: LD_INT 2
74754: EQUAL
74755: AND
74756: IFFALSE 74773
// bpoints := bpoints * 1.2 ;
74758: LD_ADDR_VAR 0 10
74762: PUSH
74763: LD_VAR 0 10
74767: PUSH
74768: LD_REAL  1.20000000000000E+0000
74771: MUL
74772: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74773: LD_VAR 0 6
74777: PPUSH
74778: CALL_OW 264
74782: PUSH
74783: LD_INT 6
74785: PUSH
74786: LD_INT 46
74788: PUSH
74789: LD_INT 47
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: LIST
74796: IN
74797: IFFALSE 74814
// bpoints := bpoints * 1.2 ;
74799: LD_ADDR_VAR 0 10
74803: PUSH
74804: LD_VAR 0 10
74808: PUSH
74809: LD_REAL  1.20000000000000E+0000
74812: MUL
74813: ST_TO_ADDR
// end ; unit_building :
74814: GO 74828
74816: LD_INT 3
74818: DOUBLE
74819: EQUAL
74820: IFTRUE 74824
74822: GO 74827
74824: POP
// ; end ;
74825: GO 74828
74827: POP
// for j = 1 to 3 do
74828: LD_ADDR_VAR 0 7
74832: PUSH
74833: DOUBLE
74834: LD_INT 1
74836: DEC
74837: ST_TO_ADDR
74838: LD_INT 3
74840: PUSH
74841: FOR_TO
74842: IFFALSE 74895
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74844: LD_ADDR_VAR 0 5
74848: PUSH
74849: LD_VAR 0 5
74853: PPUSH
74854: LD_VAR 0 7
74858: PPUSH
74859: LD_VAR 0 5
74863: PUSH
74864: LD_VAR 0 7
74868: ARRAY
74869: PUSH
74870: LD_VAR 0 9
74874: PUSH
74875: LD_VAR 0 7
74879: ARRAY
74880: PUSH
74881: LD_VAR 0 10
74885: MUL
74886: PLUS
74887: PPUSH
74888: CALL_OW 1
74892: ST_TO_ADDR
74893: GO 74841
74895: POP
74896: POP
// end ;
74897: GO 73376
74899: POP
74900: POP
// result := Replace ( result , 4 , tmp ) ;
74901: LD_ADDR_VAR 0 5
74905: PUSH
74906: LD_VAR 0 5
74910: PPUSH
74911: LD_INT 4
74913: PPUSH
74914: LD_VAR 0 8
74918: PPUSH
74919: CALL_OW 1
74923: ST_TO_ADDR
// end ;
74924: LD_VAR 0 5
74928: RET
// export function DangerAtRange ( unit , range ) ; begin
74929: LD_INT 0
74931: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74932: LD_ADDR_VAR 0 3
74936: PUSH
74937: LD_VAR 0 1
74941: PPUSH
74942: CALL_OW 255
74946: PPUSH
74947: LD_VAR 0 1
74951: PPUSH
74952: CALL_OW 250
74956: PPUSH
74957: LD_VAR 0 1
74961: PPUSH
74962: CALL_OW 251
74966: PPUSH
74967: LD_VAR 0 2
74971: PPUSH
74972: CALL 73228 0 4
74976: ST_TO_ADDR
// end ;
74977: LD_VAR 0 3
74981: RET
// export function DangerInArea ( side , area ) ; begin
74982: LD_INT 0
74984: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74985: LD_ADDR_VAR 0 3
74989: PUSH
74990: LD_VAR 0 2
74994: PPUSH
74995: LD_INT 81
74997: PUSH
74998: LD_VAR 0 1
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PPUSH
75007: CALL_OW 70
75011: ST_TO_ADDR
// end ;
75012: LD_VAR 0 3
75016: RET
// export function IsExtension ( b ) ; begin
75017: LD_INT 0
75019: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
75020: LD_ADDR_VAR 0 2
75024: PUSH
75025: LD_VAR 0 1
75029: PUSH
75030: LD_INT 23
75032: PUSH
75033: LD_INT 20
75035: PUSH
75036: LD_INT 22
75038: PUSH
75039: LD_INT 17
75041: PUSH
75042: LD_INT 24
75044: PUSH
75045: LD_INT 21
75047: PUSH
75048: LD_INT 19
75050: PUSH
75051: LD_INT 16
75053: PUSH
75054: LD_INT 25
75056: PUSH
75057: LD_INT 18
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: LIST
75064: LIST
75065: LIST
75066: LIST
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: IN
75072: ST_TO_ADDR
// end ;
75073: LD_VAR 0 2
75077: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
75078: LD_INT 0
75080: PPUSH
75081: PPUSH
75082: PPUSH
// result := [ ] ;
75083: LD_ADDR_VAR 0 4
75087: PUSH
75088: EMPTY
75089: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
75090: LD_ADDR_VAR 0 5
75094: PUSH
75095: LD_VAR 0 2
75099: PPUSH
75100: LD_INT 21
75102: PUSH
75103: LD_INT 3
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PPUSH
75110: CALL_OW 70
75114: ST_TO_ADDR
// if not tmp then
75115: LD_VAR 0 5
75119: NOT
75120: IFFALSE 75124
// exit ;
75122: GO 75188
// if checkLink then
75124: LD_VAR 0 3
75128: IFFALSE 75178
// begin for i in tmp do
75130: LD_ADDR_VAR 0 6
75134: PUSH
75135: LD_VAR 0 5
75139: PUSH
75140: FOR_IN
75141: IFFALSE 75176
// if GetBase ( i ) <> base then
75143: LD_VAR 0 6
75147: PPUSH
75148: CALL_OW 274
75152: PUSH
75153: LD_VAR 0 1
75157: NONEQUAL
75158: IFFALSE 75174
// ComLinkToBase ( base , i ) ;
75160: LD_VAR 0 1
75164: PPUSH
75165: LD_VAR 0 6
75169: PPUSH
75170: CALL_OW 169
75174: GO 75140
75176: POP
75177: POP
// end ; result := tmp ;
75178: LD_ADDR_VAR 0 4
75182: PUSH
75183: LD_VAR 0 5
75187: ST_TO_ADDR
// end ;
75188: LD_VAR 0 4
75192: RET
// export function ComComplete ( units , b ) ; var i ; begin
75193: LD_INT 0
75195: PPUSH
75196: PPUSH
// if not units then
75197: LD_VAR 0 1
75201: NOT
75202: IFFALSE 75206
// exit ;
75204: GO 75296
// for i in units do
75206: LD_ADDR_VAR 0 4
75210: PUSH
75211: LD_VAR 0 1
75215: PUSH
75216: FOR_IN
75217: IFFALSE 75294
// if BuildingStatus ( b ) = bs_build then
75219: LD_VAR 0 2
75223: PPUSH
75224: CALL_OW 461
75228: PUSH
75229: LD_INT 1
75231: EQUAL
75232: IFFALSE 75292
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75234: LD_VAR 0 4
75238: PPUSH
75239: LD_STRING h
75241: PUSH
75242: LD_VAR 0 2
75246: PPUSH
75247: CALL_OW 250
75251: PUSH
75252: LD_VAR 0 2
75256: PPUSH
75257: CALL_OW 251
75261: PUSH
75262: LD_VAR 0 2
75266: PUSH
75267: LD_INT 0
75269: PUSH
75270: LD_INT 0
75272: PUSH
75273: LD_INT 0
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: PUSH
75285: EMPTY
75286: LIST
75287: PPUSH
75288: CALL_OW 446
75292: GO 75216
75294: POP
75295: POP
// end ;
75296: LD_VAR 0 3
75300: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75301: LD_INT 0
75303: PPUSH
75304: PPUSH
75305: PPUSH
75306: PPUSH
75307: PPUSH
75308: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
75309: LD_VAR 0 1
75313: NOT
75314: PUSH
75315: LD_VAR 0 1
75319: PPUSH
75320: CALL_OW 263
75324: PUSH
75325: LD_INT 2
75327: NONEQUAL
75328: OR
75329: IFFALSE 75333
// exit ;
75331: GO 75649
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75333: LD_ADDR_VAR 0 6
75337: PUSH
75338: LD_INT 22
75340: PUSH
75341: LD_VAR 0 1
75345: PPUSH
75346: CALL_OW 255
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 2
75357: PUSH
75358: LD_INT 30
75360: PUSH
75361: LD_INT 36
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 34
75370: PUSH
75371: LD_INT 31
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: LIST
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: PPUSH
75387: CALL_OW 69
75391: ST_TO_ADDR
// if not tmp then
75392: LD_VAR 0 6
75396: NOT
75397: IFFALSE 75401
// exit ;
75399: GO 75649
// result := [ ] ;
75401: LD_ADDR_VAR 0 2
75405: PUSH
75406: EMPTY
75407: ST_TO_ADDR
// for i in tmp do
75408: LD_ADDR_VAR 0 3
75412: PUSH
75413: LD_VAR 0 6
75417: PUSH
75418: FOR_IN
75419: IFFALSE 75490
// begin t := UnitsInside ( i ) ;
75421: LD_ADDR_VAR 0 4
75425: PUSH
75426: LD_VAR 0 3
75430: PPUSH
75431: CALL_OW 313
75435: ST_TO_ADDR
// if t then
75436: LD_VAR 0 4
75440: IFFALSE 75488
// for j in t do
75442: LD_ADDR_VAR 0 7
75446: PUSH
75447: LD_VAR 0 4
75451: PUSH
75452: FOR_IN
75453: IFFALSE 75486
// result := Replace ( result , result + 1 , j ) ;
75455: LD_ADDR_VAR 0 2
75459: PUSH
75460: LD_VAR 0 2
75464: PPUSH
75465: LD_VAR 0 2
75469: PUSH
75470: LD_INT 1
75472: PLUS
75473: PPUSH
75474: LD_VAR 0 7
75478: PPUSH
75479: CALL_OW 1
75483: ST_TO_ADDR
75484: GO 75452
75486: POP
75487: POP
// end ;
75488: GO 75418
75490: POP
75491: POP
// if not result then
75492: LD_VAR 0 2
75496: NOT
75497: IFFALSE 75501
// exit ;
75499: GO 75649
// mech := result [ 1 ] ;
75501: LD_ADDR_VAR 0 5
75505: PUSH
75506: LD_VAR 0 2
75510: PUSH
75511: LD_INT 1
75513: ARRAY
75514: ST_TO_ADDR
// if result > 1 then
75515: LD_VAR 0 2
75519: PUSH
75520: LD_INT 1
75522: GREATER
75523: IFFALSE 75635
// begin for i = 2 to result do
75525: LD_ADDR_VAR 0 3
75529: PUSH
75530: DOUBLE
75531: LD_INT 2
75533: DEC
75534: ST_TO_ADDR
75535: LD_VAR 0 2
75539: PUSH
75540: FOR_TO
75541: IFFALSE 75633
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75543: LD_ADDR_VAR 0 4
75547: PUSH
75548: LD_VAR 0 2
75552: PUSH
75553: LD_VAR 0 3
75557: ARRAY
75558: PPUSH
75559: LD_INT 3
75561: PPUSH
75562: CALL_OW 259
75566: PUSH
75567: LD_VAR 0 2
75571: PUSH
75572: LD_VAR 0 3
75576: ARRAY
75577: PPUSH
75578: CALL_OW 432
75582: MINUS
75583: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75584: LD_VAR 0 4
75588: PUSH
75589: LD_VAR 0 5
75593: PPUSH
75594: LD_INT 3
75596: PPUSH
75597: CALL_OW 259
75601: PUSH
75602: LD_VAR 0 5
75606: PPUSH
75607: CALL_OW 432
75611: MINUS
75612: GREATEREQUAL
75613: IFFALSE 75631
// mech := result [ i ] ;
75615: LD_ADDR_VAR 0 5
75619: PUSH
75620: LD_VAR 0 2
75624: PUSH
75625: LD_VAR 0 3
75629: ARRAY
75630: ST_TO_ADDR
// end ;
75631: GO 75540
75633: POP
75634: POP
// end ; ComLinkTo ( vehicle , mech ) ;
75635: LD_VAR 0 1
75639: PPUSH
75640: LD_VAR 0 5
75644: PPUSH
75645: CALL_OW 135
// end ;
75649: LD_VAR 0 2
75653: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75654: LD_INT 0
75656: PPUSH
75657: PPUSH
75658: PPUSH
75659: PPUSH
75660: PPUSH
75661: PPUSH
75662: PPUSH
75663: PPUSH
75664: PPUSH
75665: PPUSH
75666: PPUSH
75667: PPUSH
75668: PPUSH
// result := [ ] ;
75669: LD_ADDR_VAR 0 7
75673: PUSH
75674: EMPTY
75675: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75676: LD_VAR 0 1
75680: PPUSH
75681: CALL_OW 266
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: LD_INT 1
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: IN
75696: NOT
75697: IFFALSE 75701
// exit ;
75699: GO 77335
// if name then
75701: LD_VAR 0 3
75705: IFFALSE 75721
// SetBName ( base_dep , name ) ;
75707: LD_VAR 0 1
75711: PPUSH
75712: LD_VAR 0 3
75716: PPUSH
75717: CALL_OW 500
// base := GetBase ( base_dep ) ;
75721: LD_ADDR_VAR 0 15
75725: PUSH
75726: LD_VAR 0 1
75730: PPUSH
75731: CALL_OW 274
75735: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75736: LD_ADDR_VAR 0 16
75740: PUSH
75741: LD_VAR 0 1
75745: PPUSH
75746: CALL_OW 255
75750: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75751: LD_ADDR_VAR 0 17
75755: PUSH
75756: LD_VAR 0 1
75760: PPUSH
75761: CALL_OW 248
75765: ST_TO_ADDR
// if sources then
75766: LD_VAR 0 5
75770: IFFALSE 75817
// for i = 1 to 3 do
75772: LD_ADDR_VAR 0 8
75776: PUSH
75777: DOUBLE
75778: LD_INT 1
75780: DEC
75781: ST_TO_ADDR
75782: LD_INT 3
75784: PUSH
75785: FOR_TO
75786: IFFALSE 75815
// AddResourceType ( base , i , sources [ i ] ) ;
75788: LD_VAR 0 15
75792: PPUSH
75793: LD_VAR 0 8
75797: PPUSH
75798: LD_VAR 0 5
75802: PUSH
75803: LD_VAR 0 8
75807: ARRAY
75808: PPUSH
75809: CALL_OW 276
75813: GO 75785
75815: POP
75816: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
75817: LD_ADDR_VAR 0 18
75821: PUSH
75822: LD_VAR 0 15
75826: PPUSH
75827: LD_VAR 0 2
75831: PPUSH
75832: LD_INT 1
75834: PPUSH
75835: CALL 75078 0 3
75839: ST_TO_ADDR
// InitHc ;
75840: CALL_OW 19
// InitUc ;
75844: CALL_OW 18
// uc_side := side ;
75848: LD_ADDR_OWVAR 20
75852: PUSH
75853: LD_VAR 0 16
75857: ST_TO_ADDR
// uc_nation := nation ;
75858: LD_ADDR_OWVAR 21
75862: PUSH
75863: LD_VAR 0 17
75867: ST_TO_ADDR
// if buildings then
75868: LD_VAR 0 18
75872: IFFALSE 77194
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75874: LD_ADDR_VAR 0 19
75878: PUSH
75879: LD_VAR 0 18
75883: PPUSH
75884: LD_INT 2
75886: PUSH
75887: LD_INT 30
75889: PUSH
75890: LD_INT 29
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 30
75899: PUSH
75900: LD_INT 30
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: LIST
75911: PPUSH
75912: CALL_OW 72
75916: ST_TO_ADDR
// if tmp then
75917: LD_VAR 0 19
75921: IFFALSE 75969
// for i in tmp do
75923: LD_ADDR_VAR 0 8
75927: PUSH
75928: LD_VAR 0 19
75932: PUSH
75933: FOR_IN
75934: IFFALSE 75967
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75936: LD_VAR 0 8
75940: PPUSH
75941: CALL_OW 250
75945: PPUSH
75946: LD_VAR 0 8
75950: PPUSH
75951: CALL_OW 251
75955: PPUSH
75956: LD_VAR 0 16
75960: PPUSH
75961: CALL_OW 441
75965: GO 75933
75967: POP
75968: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75969: LD_VAR 0 18
75973: PPUSH
75974: LD_INT 2
75976: PUSH
75977: LD_INT 30
75979: PUSH
75980: LD_INT 32
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 30
75989: PUSH
75990: LD_INT 33
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: LIST
76001: PPUSH
76002: CALL_OW 72
76006: IFFALSE 76094
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
76008: LD_ADDR_VAR 0 8
76012: PUSH
76013: LD_VAR 0 18
76017: PPUSH
76018: LD_INT 2
76020: PUSH
76021: LD_INT 30
76023: PUSH
76024: LD_INT 32
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 30
76033: PUSH
76034: LD_INT 33
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: EMPTY
76042: LIST
76043: LIST
76044: LIST
76045: PPUSH
76046: CALL_OW 72
76050: PUSH
76051: FOR_IN
76052: IFFALSE 76092
// begin if not GetBWeapon ( i ) then
76054: LD_VAR 0 8
76058: PPUSH
76059: CALL_OW 269
76063: NOT
76064: IFFALSE 76090
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
76066: LD_VAR 0 8
76070: PPUSH
76071: LD_VAR 0 8
76075: PPUSH
76076: LD_VAR 0 2
76080: PPUSH
76081: CALL 77340 0 2
76085: PPUSH
76086: CALL_OW 431
// end ;
76090: GO 76051
76092: POP
76093: POP
// end ; for i = 1 to personel do
76094: LD_ADDR_VAR 0 8
76098: PUSH
76099: DOUBLE
76100: LD_INT 1
76102: DEC
76103: ST_TO_ADDR
76104: LD_VAR 0 6
76108: PUSH
76109: FOR_TO
76110: IFFALSE 77174
// begin if i > 4 then
76112: LD_VAR 0 8
76116: PUSH
76117: LD_INT 4
76119: GREATER
76120: IFFALSE 76124
// break ;
76122: GO 77174
// case i of 1 :
76124: LD_VAR 0 8
76128: PUSH
76129: LD_INT 1
76131: DOUBLE
76132: EQUAL
76133: IFTRUE 76137
76135: GO 76217
76137: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
76138: LD_ADDR_VAR 0 12
76142: PUSH
76143: LD_VAR 0 18
76147: PPUSH
76148: LD_INT 22
76150: PUSH
76151: LD_VAR 0 16
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: PUSH
76160: LD_INT 58
76162: PUSH
76163: EMPTY
76164: LIST
76165: PUSH
76166: LD_INT 2
76168: PUSH
76169: LD_INT 30
76171: PUSH
76172: LD_INT 32
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 30
76181: PUSH
76182: LD_INT 4
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PUSH
76189: LD_INT 30
76191: PUSH
76192: LD_INT 5
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: LIST
76209: PPUSH
76210: CALL_OW 72
76214: ST_TO_ADDR
76215: GO 76439
76217: LD_INT 2
76219: DOUBLE
76220: EQUAL
76221: IFTRUE 76225
76223: GO 76287
76225: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76226: LD_ADDR_VAR 0 12
76230: PUSH
76231: LD_VAR 0 18
76235: PPUSH
76236: LD_INT 22
76238: PUSH
76239: LD_VAR 0 16
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 2
76250: PUSH
76251: LD_INT 30
76253: PUSH
76254: LD_INT 0
76256: PUSH
76257: EMPTY
76258: LIST
76259: LIST
76260: PUSH
76261: LD_INT 30
76263: PUSH
76264: LD_INT 1
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PUSH
76271: EMPTY
76272: LIST
76273: LIST
76274: LIST
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: PPUSH
76280: CALL_OW 72
76284: ST_TO_ADDR
76285: GO 76439
76287: LD_INT 3
76289: DOUBLE
76290: EQUAL
76291: IFTRUE 76295
76293: GO 76357
76295: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76296: LD_ADDR_VAR 0 12
76300: PUSH
76301: LD_VAR 0 18
76305: PPUSH
76306: LD_INT 22
76308: PUSH
76309: LD_VAR 0 16
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PUSH
76318: LD_INT 2
76320: PUSH
76321: LD_INT 30
76323: PUSH
76324: LD_INT 2
76326: PUSH
76327: EMPTY
76328: LIST
76329: LIST
76330: PUSH
76331: LD_INT 30
76333: PUSH
76334: LD_INT 3
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: LIST
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PPUSH
76350: CALL_OW 72
76354: ST_TO_ADDR
76355: GO 76439
76357: LD_INT 4
76359: DOUBLE
76360: EQUAL
76361: IFTRUE 76365
76363: GO 76438
76365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76366: LD_ADDR_VAR 0 12
76370: PUSH
76371: LD_VAR 0 18
76375: PPUSH
76376: LD_INT 22
76378: PUSH
76379: LD_VAR 0 16
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 2
76390: PUSH
76391: LD_INT 30
76393: PUSH
76394: LD_INT 6
76396: PUSH
76397: EMPTY
76398: LIST
76399: LIST
76400: PUSH
76401: LD_INT 30
76403: PUSH
76404: LD_INT 7
76406: PUSH
76407: EMPTY
76408: LIST
76409: LIST
76410: PUSH
76411: LD_INT 30
76413: PUSH
76414: LD_INT 8
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PPUSH
76431: CALL_OW 72
76435: ST_TO_ADDR
76436: GO 76439
76438: POP
// if i = 1 then
76439: LD_VAR 0 8
76443: PUSH
76444: LD_INT 1
76446: EQUAL
76447: IFFALSE 76558
// begin tmp := [ ] ;
76449: LD_ADDR_VAR 0 19
76453: PUSH
76454: EMPTY
76455: ST_TO_ADDR
// for j in f do
76456: LD_ADDR_VAR 0 9
76460: PUSH
76461: LD_VAR 0 12
76465: PUSH
76466: FOR_IN
76467: IFFALSE 76540
// if GetBType ( j ) = b_bunker then
76469: LD_VAR 0 9
76473: PPUSH
76474: CALL_OW 266
76478: PUSH
76479: LD_INT 32
76481: EQUAL
76482: IFFALSE 76509
// tmp := Insert ( tmp , 1 , j ) else
76484: LD_ADDR_VAR 0 19
76488: PUSH
76489: LD_VAR 0 19
76493: PPUSH
76494: LD_INT 1
76496: PPUSH
76497: LD_VAR 0 9
76501: PPUSH
76502: CALL_OW 2
76506: ST_TO_ADDR
76507: GO 76538
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76509: LD_ADDR_VAR 0 19
76513: PUSH
76514: LD_VAR 0 19
76518: PPUSH
76519: LD_VAR 0 19
76523: PUSH
76524: LD_INT 1
76526: PLUS
76527: PPUSH
76528: LD_VAR 0 9
76532: PPUSH
76533: CALL_OW 2
76537: ST_TO_ADDR
76538: GO 76466
76540: POP
76541: POP
// if tmp then
76542: LD_VAR 0 19
76546: IFFALSE 76558
// f := tmp ;
76548: LD_ADDR_VAR 0 12
76552: PUSH
76553: LD_VAR 0 19
76557: ST_TO_ADDR
// end ; x := personel [ i ] ;
76558: LD_ADDR_VAR 0 13
76562: PUSH
76563: LD_VAR 0 6
76567: PUSH
76568: LD_VAR 0 8
76572: ARRAY
76573: ST_TO_ADDR
// if x = - 1 then
76574: LD_VAR 0 13
76578: PUSH
76579: LD_INT 1
76581: NEG
76582: EQUAL
76583: IFFALSE 76792
// begin for j in f do
76585: LD_ADDR_VAR 0 9
76589: PUSH
76590: LD_VAR 0 12
76594: PUSH
76595: FOR_IN
76596: IFFALSE 76788
// repeat InitHc ;
76598: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76602: LD_VAR 0 9
76606: PPUSH
76607: CALL_OW 266
76611: PUSH
76612: LD_INT 5
76614: EQUAL
76615: IFFALSE 76685
// begin if UnitsInside ( j ) < 3 then
76617: LD_VAR 0 9
76621: PPUSH
76622: CALL_OW 313
76626: PUSH
76627: LD_INT 3
76629: LESS
76630: IFFALSE 76666
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76632: LD_INT 0
76634: PPUSH
76635: LD_INT 5
76637: PUSH
76638: LD_INT 8
76640: PUSH
76641: LD_INT 9
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: LIST
76648: PUSH
76649: LD_VAR 0 17
76653: ARRAY
76654: PPUSH
76655: LD_VAR 0 4
76659: PPUSH
76660: CALL_OW 380
76664: GO 76683
// PrepareHuman ( false , i , skill ) ;
76666: LD_INT 0
76668: PPUSH
76669: LD_VAR 0 8
76673: PPUSH
76674: LD_VAR 0 4
76678: PPUSH
76679: CALL_OW 380
// end else
76683: GO 76702
// PrepareHuman ( false , i , skill ) ;
76685: LD_INT 0
76687: PPUSH
76688: LD_VAR 0 8
76692: PPUSH
76693: LD_VAR 0 4
76697: PPUSH
76698: CALL_OW 380
// un := CreateHuman ;
76702: LD_ADDR_VAR 0 14
76706: PUSH
76707: CALL_OW 44
76711: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76712: LD_ADDR_VAR 0 7
76716: PUSH
76717: LD_VAR 0 7
76721: PPUSH
76722: LD_INT 1
76724: PPUSH
76725: LD_VAR 0 14
76729: PPUSH
76730: CALL_OW 2
76734: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76735: LD_VAR 0 14
76739: PPUSH
76740: LD_VAR 0 9
76744: PPUSH
76745: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76749: LD_VAR 0 9
76753: PPUSH
76754: CALL_OW 313
76758: PUSH
76759: LD_INT 6
76761: EQUAL
76762: PUSH
76763: LD_VAR 0 9
76767: PPUSH
76768: CALL_OW 266
76772: PUSH
76773: LD_INT 32
76775: PUSH
76776: LD_INT 31
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: IN
76783: OR
76784: IFFALSE 76598
76786: GO 76595
76788: POP
76789: POP
// end else
76790: GO 77172
// for j = 1 to x do
76792: LD_ADDR_VAR 0 9
76796: PUSH
76797: DOUBLE
76798: LD_INT 1
76800: DEC
76801: ST_TO_ADDR
76802: LD_VAR 0 13
76806: PUSH
76807: FOR_TO
76808: IFFALSE 77170
// begin InitHc ;
76810: CALL_OW 19
// if not f then
76814: LD_VAR 0 12
76818: NOT
76819: IFFALSE 76908
// begin PrepareHuman ( false , i , skill ) ;
76821: LD_INT 0
76823: PPUSH
76824: LD_VAR 0 8
76828: PPUSH
76829: LD_VAR 0 4
76833: PPUSH
76834: CALL_OW 380
// un := CreateHuman ;
76838: LD_ADDR_VAR 0 14
76842: PUSH
76843: CALL_OW 44
76847: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76848: LD_ADDR_VAR 0 7
76852: PUSH
76853: LD_VAR 0 7
76857: PPUSH
76858: LD_INT 1
76860: PPUSH
76861: LD_VAR 0 14
76865: PPUSH
76866: CALL_OW 2
76870: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76871: LD_VAR 0 14
76875: PPUSH
76876: LD_VAR 0 1
76880: PPUSH
76881: CALL_OW 250
76885: PPUSH
76886: LD_VAR 0 1
76890: PPUSH
76891: CALL_OW 251
76895: PPUSH
76896: LD_INT 10
76898: PPUSH
76899: LD_INT 0
76901: PPUSH
76902: CALL_OW 50
// continue ;
76906: GO 76807
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76908: LD_VAR 0 12
76912: PUSH
76913: LD_INT 1
76915: ARRAY
76916: PPUSH
76917: CALL_OW 313
76921: PUSH
76922: LD_VAR 0 12
76926: PUSH
76927: LD_INT 1
76929: ARRAY
76930: PPUSH
76931: CALL_OW 266
76935: PUSH
76936: LD_INT 32
76938: PUSH
76939: LD_INT 31
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: IN
76946: AND
76947: PUSH
76948: LD_VAR 0 12
76952: PUSH
76953: LD_INT 1
76955: ARRAY
76956: PPUSH
76957: CALL_OW 313
76961: PUSH
76962: LD_INT 6
76964: EQUAL
76965: OR
76966: IFFALSE 76986
// f := Delete ( f , 1 ) ;
76968: LD_ADDR_VAR 0 12
76972: PUSH
76973: LD_VAR 0 12
76977: PPUSH
76978: LD_INT 1
76980: PPUSH
76981: CALL_OW 3
76985: ST_TO_ADDR
// if not f then
76986: LD_VAR 0 12
76990: NOT
76991: IFFALSE 77009
// begin x := x + 2 ;
76993: LD_ADDR_VAR 0 13
76997: PUSH
76998: LD_VAR 0 13
77002: PUSH
77003: LD_INT 2
77005: PLUS
77006: ST_TO_ADDR
// continue ;
77007: GO 76807
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
77009: LD_VAR 0 12
77013: PUSH
77014: LD_INT 1
77016: ARRAY
77017: PPUSH
77018: CALL_OW 266
77022: PUSH
77023: LD_INT 5
77025: EQUAL
77026: IFFALSE 77100
// begin if UnitsInside ( f [ 1 ] ) < 3 then
77028: LD_VAR 0 12
77032: PUSH
77033: LD_INT 1
77035: ARRAY
77036: PPUSH
77037: CALL_OW 313
77041: PUSH
77042: LD_INT 3
77044: LESS
77045: IFFALSE 77081
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
77047: LD_INT 0
77049: PPUSH
77050: LD_INT 5
77052: PUSH
77053: LD_INT 8
77055: PUSH
77056: LD_INT 9
77058: PUSH
77059: EMPTY
77060: LIST
77061: LIST
77062: LIST
77063: PUSH
77064: LD_VAR 0 17
77068: ARRAY
77069: PPUSH
77070: LD_VAR 0 4
77074: PPUSH
77075: CALL_OW 380
77079: GO 77098
// PrepareHuman ( false , i , skill ) ;
77081: LD_INT 0
77083: PPUSH
77084: LD_VAR 0 8
77088: PPUSH
77089: LD_VAR 0 4
77093: PPUSH
77094: CALL_OW 380
// end else
77098: GO 77117
// PrepareHuman ( false , i , skill ) ;
77100: LD_INT 0
77102: PPUSH
77103: LD_VAR 0 8
77107: PPUSH
77108: LD_VAR 0 4
77112: PPUSH
77113: CALL_OW 380
// un := CreateHuman ;
77117: LD_ADDR_VAR 0 14
77121: PUSH
77122: CALL_OW 44
77126: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
77127: LD_ADDR_VAR 0 7
77131: PUSH
77132: LD_VAR 0 7
77136: PPUSH
77137: LD_INT 1
77139: PPUSH
77140: LD_VAR 0 14
77144: PPUSH
77145: CALL_OW 2
77149: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
77150: LD_VAR 0 14
77154: PPUSH
77155: LD_VAR 0 12
77159: PUSH
77160: LD_INT 1
77162: ARRAY
77163: PPUSH
77164: CALL_OW 52
// end ;
77168: GO 76807
77170: POP
77171: POP
// end ;
77172: GO 76109
77174: POP
77175: POP
// result := result ^ buildings ;
77176: LD_ADDR_VAR 0 7
77180: PUSH
77181: LD_VAR 0 7
77185: PUSH
77186: LD_VAR 0 18
77190: ADD
77191: ST_TO_ADDR
// end else
77192: GO 77335
// begin for i = 1 to personel do
77194: LD_ADDR_VAR 0 8
77198: PUSH
77199: DOUBLE
77200: LD_INT 1
77202: DEC
77203: ST_TO_ADDR
77204: LD_VAR 0 6
77208: PUSH
77209: FOR_TO
77210: IFFALSE 77333
// begin if i > 4 then
77212: LD_VAR 0 8
77216: PUSH
77217: LD_INT 4
77219: GREATER
77220: IFFALSE 77224
// break ;
77222: GO 77333
// x := personel [ i ] ;
77224: LD_ADDR_VAR 0 13
77228: PUSH
77229: LD_VAR 0 6
77233: PUSH
77234: LD_VAR 0 8
77238: ARRAY
77239: ST_TO_ADDR
// if x = - 1 then
77240: LD_VAR 0 13
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: EQUAL
77249: IFFALSE 77253
// continue ;
77251: GO 77209
// PrepareHuman ( false , i , skill ) ;
77253: LD_INT 0
77255: PPUSH
77256: LD_VAR 0 8
77260: PPUSH
77261: LD_VAR 0 4
77265: PPUSH
77266: CALL_OW 380
// un := CreateHuman ;
77270: LD_ADDR_VAR 0 14
77274: PUSH
77275: CALL_OW 44
77279: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77280: LD_VAR 0 14
77284: PPUSH
77285: LD_VAR 0 1
77289: PPUSH
77290: CALL_OW 250
77294: PPUSH
77295: LD_VAR 0 1
77299: PPUSH
77300: CALL_OW 251
77304: PPUSH
77305: LD_INT 10
77307: PPUSH
77308: LD_INT 0
77310: PPUSH
77311: CALL_OW 50
// result := result ^ un ;
77315: LD_ADDR_VAR 0 7
77319: PUSH
77320: LD_VAR 0 7
77324: PUSH
77325: LD_VAR 0 14
77329: ADD
77330: ST_TO_ADDR
// end ;
77331: GO 77209
77333: POP
77334: POP
// end ; end ;
77335: LD_VAR 0 7
77339: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77340: LD_INT 0
77342: PPUSH
77343: PPUSH
77344: PPUSH
77345: PPUSH
77346: PPUSH
77347: PPUSH
77348: PPUSH
77349: PPUSH
77350: PPUSH
77351: PPUSH
77352: PPUSH
77353: PPUSH
77354: PPUSH
77355: PPUSH
77356: PPUSH
77357: PPUSH
// result := false ;
77358: LD_ADDR_VAR 0 3
77362: PUSH
77363: LD_INT 0
77365: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77366: LD_VAR 0 1
77370: NOT
77371: PUSH
77372: LD_VAR 0 1
77376: PPUSH
77377: CALL_OW 266
77381: PUSH
77382: LD_INT 32
77384: PUSH
77385: LD_INT 33
77387: PUSH
77388: EMPTY
77389: LIST
77390: LIST
77391: IN
77392: NOT
77393: OR
77394: IFFALSE 77398
// exit ;
77396: GO 78507
// nat := GetNation ( tower ) ;
77398: LD_ADDR_VAR 0 12
77402: PUSH
77403: LD_VAR 0 1
77407: PPUSH
77408: CALL_OW 248
77412: ST_TO_ADDR
// side := GetSide ( tower ) ;
77413: LD_ADDR_VAR 0 16
77417: PUSH
77418: LD_VAR 0 1
77422: PPUSH
77423: CALL_OW 255
77427: ST_TO_ADDR
// x := GetX ( tower ) ;
77428: LD_ADDR_VAR 0 10
77432: PUSH
77433: LD_VAR 0 1
77437: PPUSH
77438: CALL_OW 250
77442: ST_TO_ADDR
// y := GetY ( tower ) ;
77443: LD_ADDR_VAR 0 11
77447: PUSH
77448: LD_VAR 0 1
77452: PPUSH
77453: CALL_OW 251
77457: ST_TO_ADDR
// if not x or not y then
77458: LD_VAR 0 10
77462: NOT
77463: PUSH
77464: LD_VAR 0 11
77468: NOT
77469: OR
77470: IFFALSE 77474
// exit ;
77472: GO 78507
// weapon := 0 ;
77474: LD_ADDR_VAR 0 18
77478: PUSH
77479: LD_INT 0
77481: ST_TO_ADDR
// fac_list := [ ] ;
77482: LD_ADDR_VAR 0 17
77486: PUSH
77487: EMPTY
77488: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
77489: LD_ADDR_VAR 0 6
77493: PUSH
77494: LD_VAR 0 1
77498: PPUSH
77499: CALL_OW 274
77503: PPUSH
77504: LD_VAR 0 2
77508: PPUSH
77509: LD_INT 0
77511: PPUSH
77512: CALL 75078 0 3
77516: PPUSH
77517: LD_INT 30
77519: PUSH
77520: LD_INT 3
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PPUSH
77527: CALL_OW 72
77531: ST_TO_ADDR
// if not factories then
77532: LD_VAR 0 6
77536: NOT
77537: IFFALSE 77541
// exit ;
77539: GO 78507
// for i in factories do
77541: LD_ADDR_VAR 0 8
77545: PUSH
77546: LD_VAR 0 6
77550: PUSH
77551: FOR_IN
77552: IFFALSE 77577
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77554: LD_ADDR_VAR 0 17
77558: PUSH
77559: LD_VAR 0 17
77563: PUSH
77564: LD_VAR 0 8
77568: PPUSH
77569: CALL_OW 478
77573: UNION
77574: ST_TO_ADDR
77575: GO 77551
77577: POP
77578: POP
// if not fac_list then
77579: LD_VAR 0 17
77583: NOT
77584: IFFALSE 77588
// exit ;
77586: GO 78507
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77588: LD_ADDR_VAR 0 5
77592: PUSH
77593: LD_INT 4
77595: PUSH
77596: LD_INT 5
77598: PUSH
77599: LD_INT 9
77601: PUSH
77602: LD_INT 10
77604: PUSH
77605: LD_INT 6
77607: PUSH
77608: LD_INT 7
77610: PUSH
77611: LD_INT 11
77613: PUSH
77614: EMPTY
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 27
77625: PUSH
77626: LD_INT 28
77628: PUSH
77629: LD_INT 26
77631: PUSH
77632: LD_INT 30
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: LIST
77639: LIST
77640: PUSH
77641: LD_INT 43
77643: PUSH
77644: LD_INT 44
77646: PUSH
77647: LD_INT 46
77649: PUSH
77650: LD_INT 45
77652: PUSH
77653: LD_INT 47
77655: PUSH
77656: LD_INT 49
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: PUSH
77667: EMPTY
77668: LIST
77669: LIST
77670: LIST
77671: PUSH
77672: LD_VAR 0 12
77676: ARRAY
77677: ST_TO_ADDR
// list := list isect fac_list ;
77678: LD_ADDR_VAR 0 5
77682: PUSH
77683: LD_VAR 0 5
77687: PUSH
77688: LD_VAR 0 17
77692: ISECT
77693: ST_TO_ADDR
// if not list then
77694: LD_VAR 0 5
77698: NOT
77699: IFFALSE 77703
// exit ;
77701: GO 78507
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77703: LD_VAR 0 12
77707: PUSH
77708: LD_INT 3
77710: EQUAL
77711: PUSH
77712: LD_INT 49
77714: PUSH
77715: LD_VAR 0 5
77719: IN
77720: AND
77721: PUSH
77722: LD_INT 31
77724: PPUSH
77725: LD_VAR 0 16
77729: PPUSH
77730: CALL_OW 321
77734: PUSH
77735: LD_INT 2
77737: EQUAL
77738: AND
77739: IFFALSE 77799
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77741: LD_INT 22
77743: PUSH
77744: LD_VAR 0 16
77748: PUSH
77749: EMPTY
77750: LIST
77751: LIST
77752: PUSH
77753: LD_INT 35
77755: PUSH
77756: LD_INT 49
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 91
77765: PUSH
77766: LD_VAR 0 1
77770: PUSH
77771: LD_INT 10
77773: PUSH
77774: EMPTY
77775: LIST
77776: LIST
77777: LIST
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: LIST
77783: PPUSH
77784: CALL_OW 69
77788: NOT
77789: IFFALSE 77799
// weapon := ru_time_lapser ;
77791: LD_ADDR_VAR 0 18
77795: PUSH
77796: LD_INT 49
77798: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77799: LD_VAR 0 12
77803: PUSH
77804: LD_INT 1
77806: PUSH
77807: LD_INT 2
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: IN
77814: PUSH
77815: LD_INT 11
77817: PUSH
77818: LD_VAR 0 5
77822: IN
77823: PUSH
77824: LD_INT 30
77826: PUSH
77827: LD_VAR 0 5
77831: IN
77832: OR
77833: AND
77834: PUSH
77835: LD_INT 6
77837: PPUSH
77838: LD_VAR 0 16
77842: PPUSH
77843: CALL_OW 321
77847: PUSH
77848: LD_INT 2
77850: EQUAL
77851: AND
77852: IFFALSE 78017
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77854: LD_INT 22
77856: PUSH
77857: LD_VAR 0 16
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 2
77868: PUSH
77869: LD_INT 35
77871: PUSH
77872: LD_INT 11
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 35
77881: PUSH
77882: LD_INT 30
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 91
77896: PUSH
77897: LD_VAR 0 1
77901: PUSH
77902: LD_INT 18
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: LIST
77914: PPUSH
77915: CALL_OW 69
77919: NOT
77920: PUSH
77921: LD_INT 22
77923: PUSH
77924: LD_VAR 0 16
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: PUSH
77933: LD_INT 2
77935: PUSH
77936: LD_INT 30
77938: PUSH
77939: LD_INT 32
77941: PUSH
77942: EMPTY
77943: LIST
77944: LIST
77945: PUSH
77946: LD_INT 30
77948: PUSH
77949: LD_INT 33
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 91
77963: PUSH
77964: LD_VAR 0 1
77968: PUSH
77969: LD_INT 12
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: LIST
77976: PUSH
77977: EMPTY
77978: LIST
77979: LIST
77980: LIST
77981: PUSH
77982: EMPTY
77983: LIST
77984: PPUSH
77985: CALL_OW 69
77989: PUSH
77990: LD_INT 2
77992: GREATER
77993: AND
77994: IFFALSE 78017
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77996: LD_ADDR_VAR 0 18
78000: PUSH
78001: LD_INT 11
78003: PUSH
78004: LD_INT 30
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_VAR 0 12
78015: ARRAY
78016: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
78017: LD_VAR 0 18
78021: NOT
78022: PUSH
78023: LD_INT 40
78025: PPUSH
78026: LD_VAR 0 16
78030: PPUSH
78031: CALL_OW 321
78035: PUSH
78036: LD_INT 2
78038: EQUAL
78039: AND
78040: PUSH
78041: LD_INT 7
78043: PUSH
78044: LD_VAR 0 5
78048: IN
78049: PUSH
78050: LD_INT 28
78052: PUSH
78053: LD_VAR 0 5
78057: IN
78058: OR
78059: PUSH
78060: LD_INT 45
78062: PUSH
78063: LD_VAR 0 5
78067: IN
78068: OR
78069: AND
78070: IFFALSE 78324
// begin hex := GetHexInfo ( x , y ) ;
78072: LD_ADDR_VAR 0 4
78076: PUSH
78077: LD_VAR 0 10
78081: PPUSH
78082: LD_VAR 0 11
78086: PPUSH
78087: CALL_OW 546
78091: ST_TO_ADDR
// if hex [ 1 ] then
78092: LD_VAR 0 4
78096: PUSH
78097: LD_INT 1
78099: ARRAY
78100: IFFALSE 78104
// exit ;
78102: GO 78507
// height := hex [ 2 ] ;
78104: LD_ADDR_VAR 0 15
78108: PUSH
78109: LD_VAR 0 4
78113: PUSH
78114: LD_INT 2
78116: ARRAY
78117: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
78118: LD_ADDR_VAR 0 14
78122: PUSH
78123: LD_INT 0
78125: PUSH
78126: LD_INT 2
78128: PUSH
78129: LD_INT 3
78131: PUSH
78132: LD_INT 5
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: ST_TO_ADDR
// for i in tmp do
78141: LD_ADDR_VAR 0 8
78145: PUSH
78146: LD_VAR 0 14
78150: PUSH
78151: FOR_IN
78152: IFFALSE 78322
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78154: LD_ADDR_VAR 0 9
78158: PUSH
78159: LD_VAR 0 10
78163: PPUSH
78164: LD_VAR 0 8
78168: PPUSH
78169: LD_INT 5
78171: PPUSH
78172: CALL_OW 272
78176: PUSH
78177: LD_VAR 0 11
78181: PPUSH
78182: LD_VAR 0 8
78186: PPUSH
78187: LD_INT 5
78189: PPUSH
78190: CALL_OW 273
78194: PUSH
78195: EMPTY
78196: LIST
78197: LIST
78198: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78199: LD_VAR 0 9
78203: PUSH
78204: LD_INT 1
78206: ARRAY
78207: PPUSH
78208: LD_VAR 0 9
78212: PUSH
78213: LD_INT 2
78215: ARRAY
78216: PPUSH
78217: CALL_OW 488
78221: IFFALSE 78320
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78223: LD_ADDR_VAR 0 4
78227: PUSH
78228: LD_VAR 0 9
78232: PUSH
78233: LD_INT 1
78235: ARRAY
78236: PPUSH
78237: LD_VAR 0 9
78241: PUSH
78242: LD_INT 2
78244: ARRAY
78245: PPUSH
78246: CALL_OW 546
78250: ST_TO_ADDR
// if hex [ 1 ] then
78251: LD_VAR 0 4
78255: PUSH
78256: LD_INT 1
78258: ARRAY
78259: IFFALSE 78263
// continue ;
78261: GO 78151
// h := hex [ 2 ] ;
78263: LD_ADDR_VAR 0 13
78267: PUSH
78268: LD_VAR 0 4
78272: PUSH
78273: LD_INT 2
78275: ARRAY
78276: ST_TO_ADDR
// if h + 7 < height then
78277: LD_VAR 0 13
78281: PUSH
78282: LD_INT 7
78284: PLUS
78285: PUSH
78286: LD_VAR 0 15
78290: LESS
78291: IFFALSE 78320
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78293: LD_ADDR_VAR 0 18
78297: PUSH
78298: LD_INT 7
78300: PUSH
78301: LD_INT 28
78303: PUSH
78304: LD_INT 45
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: LIST
78311: PUSH
78312: LD_VAR 0 12
78316: ARRAY
78317: ST_TO_ADDR
// break ;
78318: GO 78322
// end ; end ; end ;
78320: GO 78151
78322: POP
78323: POP
// end ; if not weapon then
78324: LD_VAR 0 18
78328: NOT
78329: IFFALSE 78389
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78331: LD_ADDR_VAR 0 5
78335: PUSH
78336: LD_VAR 0 5
78340: PUSH
78341: LD_INT 11
78343: PUSH
78344: LD_INT 30
78346: PUSH
78347: LD_INT 49
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: LIST
78354: DIFF
78355: ST_TO_ADDR
// if not list then
78356: LD_VAR 0 5
78360: NOT
78361: IFFALSE 78365
// exit ;
78363: GO 78507
// weapon := list [ rand ( 1 , list ) ] ;
78365: LD_ADDR_VAR 0 18
78369: PUSH
78370: LD_VAR 0 5
78374: PUSH
78375: LD_INT 1
78377: PPUSH
78378: LD_VAR 0 5
78382: PPUSH
78383: CALL_OW 12
78387: ARRAY
78388: ST_TO_ADDR
// end ; if weapon then
78389: LD_VAR 0 18
78393: IFFALSE 78507
// begin tmp := CostOfWeapon ( weapon ) ;
78395: LD_ADDR_VAR 0 14
78399: PUSH
78400: LD_VAR 0 18
78404: PPUSH
78405: CALL_OW 451
78409: ST_TO_ADDR
// j := GetBase ( tower ) ;
78410: LD_ADDR_VAR 0 9
78414: PUSH
78415: LD_VAR 0 1
78419: PPUSH
78420: CALL_OW 274
78424: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78425: LD_VAR 0 9
78429: PPUSH
78430: LD_INT 1
78432: PPUSH
78433: CALL_OW 275
78437: PUSH
78438: LD_VAR 0 14
78442: PUSH
78443: LD_INT 1
78445: ARRAY
78446: GREATEREQUAL
78447: PUSH
78448: LD_VAR 0 9
78452: PPUSH
78453: LD_INT 2
78455: PPUSH
78456: CALL_OW 275
78460: PUSH
78461: LD_VAR 0 14
78465: PUSH
78466: LD_INT 2
78468: ARRAY
78469: GREATEREQUAL
78470: AND
78471: PUSH
78472: LD_VAR 0 9
78476: PPUSH
78477: LD_INT 3
78479: PPUSH
78480: CALL_OW 275
78484: PUSH
78485: LD_VAR 0 14
78489: PUSH
78490: LD_INT 3
78492: ARRAY
78493: GREATEREQUAL
78494: AND
78495: IFFALSE 78507
// result := weapon ;
78497: LD_ADDR_VAR 0 3
78501: PUSH
78502: LD_VAR 0 18
78506: ST_TO_ADDR
// end ; end ;
78507: LD_VAR 0 3
78511: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78512: LD_INT 0
78514: PPUSH
78515: PPUSH
// result := true ;
78516: LD_ADDR_VAR 0 3
78520: PUSH
78521: LD_INT 1
78523: ST_TO_ADDR
// if array1 = array2 then
78524: LD_VAR 0 1
78528: PUSH
78529: LD_VAR 0 2
78533: EQUAL
78534: IFFALSE 78594
// begin for i = 1 to array1 do
78536: LD_ADDR_VAR 0 4
78540: PUSH
78541: DOUBLE
78542: LD_INT 1
78544: DEC
78545: ST_TO_ADDR
78546: LD_VAR 0 1
78550: PUSH
78551: FOR_TO
78552: IFFALSE 78590
// if array1 [ i ] <> array2 [ i ] then
78554: LD_VAR 0 1
78558: PUSH
78559: LD_VAR 0 4
78563: ARRAY
78564: PUSH
78565: LD_VAR 0 2
78569: PUSH
78570: LD_VAR 0 4
78574: ARRAY
78575: NONEQUAL
78576: IFFALSE 78588
// begin result := false ;
78578: LD_ADDR_VAR 0 3
78582: PUSH
78583: LD_INT 0
78585: ST_TO_ADDR
// break ;
78586: GO 78590
// end ;
78588: GO 78551
78590: POP
78591: POP
// end else
78592: GO 78602
// result := false ;
78594: LD_ADDR_VAR 0 3
78598: PUSH
78599: LD_INT 0
78601: ST_TO_ADDR
// end ;
78602: LD_VAR 0 3
78606: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
78607: LD_INT 0
78609: PPUSH
78610: PPUSH
// if not array1 or not array2 then
78611: LD_VAR 0 1
78615: NOT
78616: PUSH
78617: LD_VAR 0 2
78621: NOT
78622: OR
78623: IFFALSE 78627
// exit ;
78625: GO 78691
// result := true ;
78627: LD_ADDR_VAR 0 3
78631: PUSH
78632: LD_INT 1
78634: ST_TO_ADDR
// for i = 1 to array1 do
78635: LD_ADDR_VAR 0 4
78639: PUSH
78640: DOUBLE
78641: LD_INT 1
78643: DEC
78644: ST_TO_ADDR
78645: LD_VAR 0 1
78649: PUSH
78650: FOR_TO
78651: IFFALSE 78689
// if array1 [ i ] <> array2 [ i ] then
78653: LD_VAR 0 1
78657: PUSH
78658: LD_VAR 0 4
78662: ARRAY
78663: PUSH
78664: LD_VAR 0 2
78668: PUSH
78669: LD_VAR 0 4
78673: ARRAY
78674: NONEQUAL
78675: IFFALSE 78687
// begin result := false ;
78677: LD_ADDR_VAR 0 3
78681: PUSH
78682: LD_INT 0
78684: ST_TO_ADDR
// break ;
78685: GO 78689
// end ;
78687: GO 78650
78689: POP
78690: POP
// end ;
78691: LD_VAR 0 3
78695: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78696: LD_INT 0
78698: PPUSH
78699: PPUSH
78700: PPUSH
// pom := GetBase ( fac ) ;
78701: LD_ADDR_VAR 0 5
78705: PUSH
78706: LD_VAR 0 1
78710: PPUSH
78711: CALL_OW 274
78715: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78716: LD_ADDR_VAR 0 4
78720: PUSH
78721: LD_VAR 0 2
78725: PUSH
78726: LD_INT 1
78728: ARRAY
78729: PPUSH
78730: LD_VAR 0 2
78734: PUSH
78735: LD_INT 2
78737: ARRAY
78738: PPUSH
78739: LD_VAR 0 2
78743: PUSH
78744: LD_INT 3
78746: ARRAY
78747: PPUSH
78748: LD_VAR 0 2
78752: PUSH
78753: LD_INT 4
78755: ARRAY
78756: PPUSH
78757: CALL_OW 449
78761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78762: LD_ADDR_VAR 0 3
78766: PUSH
78767: LD_VAR 0 5
78771: PPUSH
78772: LD_INT 1
78774: PPUSH
78775: CALL_OW 275
78779: PUSH
78780: LD_VAR 0 4
78784: PUSH
78785: LD_INT 1
78787: ARRAY
78788: GREATEREQUAL
78789: PUSH
78790: LD_VAR 0 5
78794: PPUSH
78795: LD_INT 2
78797: PPUSH
78798: CALL_OW 275
78802: PUSH
78803: LD_VAR 0 4
78807: PUSH
78808: LD_INT 2
78810: ARRAY
78811: GREATEREQUAL
78812: AND
78813: PUSH
78814: LD_VAR 0 5
78818: PPUSH
78819: LD_INT 3
78821: PPUSH
78822: CALL_OW 275
78826: PUSH
78827: LD_VAR 0 4
78831: PUSH
78832: LD_INT 3
78834: ARRAY
78835: GREATEREQUAL
78836: AND
78837: ST_TO_ADDR
// end ;
78838: LD_VAR 0 3
78842: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78843: LD_INT 0
78845: PPUSH
78846: PPUSH
78847: PPUSH
78848: PPUSH
// pom := GetBase ( building ) ;
78849: LD_ADDR_VAR 0 3
78853: PUSH
78854: LD_VAR 0 1
78858: PPUSH
78859: CALL_OW 274
78863: ST_TO_ADDR
// if not pom then
78864: LD_VAR 0 3
78868: NOT
78869: IFFALSE 78873
// exit ;
78871: GO 79043
// btype := GetBType ( building ) ;
78873: LD_ADDR_VAR 0 5
78877: PUSH
78878: LD_VAR 0 1
78882: PPUSH
78883: CALL_OW 266
78887: ST_TO_ADDR
// if btype = b_armoury then
78888: LD_VAR 0 5
78892: PUSH
78893: LD_INT 4
78895: EQUAL
78896: IFFALSE 78906
// btype := b_barracks ;
78898: LD_ADDR_VAR 0 5
78902: PUSH
78903: LD_INT 5
78905: ST_TO_ADDR
// if btype = b_depot then
78906: LD_VAR 0 5
78910: PUSH
78911: LD_INT 0
78913: EQUAL
78914: IFFALSE 78924
// btype := b_warehouse ;
78916: LD_ADDR_VAR 0 5
78920: PUSH
78921: LD_INT 1
78923: ST_TO_ADDR
// if btype = b_workshop then
78924: LD_VAR 0 5
78928: PUSH
78929: LD_INT 2
78931: EQUAL
78932: IFFALSE 78942
// btype := b_factory ;
78934: LD_ADDR_VAR 0 5
78938: PUSH
78939: LD_INT 3
78941: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78942: LD_ADDR_VAR 0 4
78946: PUSH
78947: LD_VAR 0 5
78951: PPUSH
78952: LD_VAR 0 1
78956: PPUSH
78957: CALL_OW 248
78961: PPUSH
78962: CALL_OW 450
78966: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78967: LD_ADDR_VAR 0 2
78971: PUSH
78972: LD_VAR 0 3
78976: PPUSH
78977: LD_INT 1
78979: PPUSH
78980: CALL_OW 275
78984: PUSH
78985: LD_VAR 0 4
78989: PUSH
78990: LD_INT 1
78992: ARRAY
78993: GREATEREQUAL
78994: PUSH
78995: LD_VAR 0 3
78999: PPUSH
79000: LD_INT 2
79002: PPUSH
79003: CALL_OW 275
79007: PUSH
79008: LD_VAR 0 4
79012: PUSH
79013: LD_INT 2
79015: ARRAY
79016: GREATEREQUAL
79017: AND
79018: PUSH
79019: LD_VAR 0 3
79023: PPUSH
79024: LD_INT 3
79026: PPUSH
79027: CALL_OW 275
79031: PUSH
79032: LD_VAR 0 4
79036: PUSH
79037: LD_INT 3
79039: ARRAY
79040: GREATEREQUAL
79041: AND
79042: ST_TO_ADDR
// end ;
79043: LD_VAR 0 2
79047: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
79048: LD_INT 0
79050: PPUSH
79051: PPUSH
79052: PPUSH
// pom := GetBase ( building ) ;
79053: LD_ADDR_VAR 0 4
79057: PUSH
79058: LD_VAR 0 1
79062: PPUSH
79063: CALL_OW 274
79067: ST_TO_ADDR
// if not pom then
79068: LD_VAR 0 4
79072: NOT
79073: IFFALSE 79077
// exit ;
79075: GO 79178
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
79077: LD_ADDR_VAR 0 5
79081: PUSH
79082: LD_VAR 0 2
79086: PPUSH
79087: LD_VAR 0 1
79091: PPUSH
79092: CALL_OW 248
79096: PPUSH
79097: CALL_OW 450
79101: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
79102: LD_ADDR_VAR 0 3
79106: PUSH
79107: LD_VAR 0 4
79111: PPUSH
79112: LD_INT 1
79114: PPUSH
79115: CALL_OW 275
79119: PUSH
79120: LD_VAR 0 5
79124: PUSH
79125: LD_INT 1
79127: ARRAY
79128: GREATEREQUAL
79129: PUSH
79130: LD_VAR 0 4
79134: PPUSH
79135: LD_INT 2
79137: PPUSH
79138: CALL_OW 275
79142: PUSH
79143: LD_VAR 0 5
79147: PUSH
79148: LD_INT 2
79150: ARRAY
79151: GREATEREQUAL
79152: AND
79153: PUSH
79154: LD_VAR 0 4
79158: PPUSH
79159: LD_INT 3
79161: PPUSH
79162: CALL_OW 275
79166: PUSH
79167: LD_VAR 0 5
79171: PUSH
79172: LD_INT 3
79174: ARRAY
79175: GREATEREQUAL
79176: AND
79177: ST_TO_ADDR
// end ;
79178: LD_VAR 0 3
79182: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
79183: LD_INT 0
79185: PPUSH
79186: PPUSH
79187: PPUSH
79188: PPUSH
79189: PPUSH
79190: PPUSH
79191: PPUSH
79192: PPUSH
79193: PPUSH
79194: PPUSH
79195: PPUSH
// result := false ;
79196: LD_ADDR_VAR 0 8
79200: PUSH
79201: LD_INT 0
79203: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
79204: LD_VAR 0 5
79208: NOT
79209: PUSH
79210: LD_VAR 0 1
79214: NOT
79215: OR
79216: PUSH
79217: LD_VAR 0 2
79221: NOT
79222: OR
79223: PUSH
79224: LD_VAR 0 3
79228: NOT
79229: OR
79230: IFFALSE 79234
// exit ;
79232: GO 80048
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
79234: LD_ADDR_VAR 0 14
79238: PUSH
79239: LD_VAR 0 1
79243: PPUSH
79244: LD_VAR 0 2
79248: PPUSH
79249: LD_VAR 0 3
79253: PPUSH
79254: LD_VAR 0 4
79258: PPUSH
79259: LD_VAR 0 5
79263: PUSH
79264: LD_INT 1
79266: ARRAY
79267: PPUSH
79268: CALL_OW 248
79272: PPUSH
79273: LD_INT 0
79275: PPUSH
79276: CALL 81281 0 6
79280: ST_TO_ADDR
// if not hexes then
79281: LD_VAR 0 14
79285: NOT
79286: IFFALSE 79290
// exit ;
79288: GO 80048
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79290: LD_ADDR_VAR 0 17
79294: PUSH
79295: LD_VAR 0 5
79299: PPUSH
79300: LD_INT 22
79302: PUSH
79303: LD_VAR 0 13
79307: PPUSH
79308: CALL_OW 255
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 2
79319: PUSH
79320: LD_INT 30
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 30
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: LIST
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PPUSH
79349: CALL_OW 72
79353: ST_TO_ADDR
// for i = 1 to hexes do
79354: LD_ADDR_VAR 0 9
79358: PUSH
79359: DOUBLE
79360: LD_INT 1
79362: DEC
79363: ST_TO_ADDR
79364: LD_VAR 0 14
79368: PUSH
79369: FOR_TO
79370: IFFALSE 80046
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79372: LD_ADDR_VAR 0 13
79376: PUSH
79377: LD_VAR 0 14
79381: PUSH
79382: LD_VAR 0 9
79386: ARRAY
79387: PUSH
79388: LD_INT 1
79390: ARRAY
79391: PPUSH
79392: LD_VAR 0 14
79396: PUSH
79397: LD_VAR 0 9
79401: ARRAY
79402: PUSH
79403: LD_INT 2
79405: ARRAY
79406: PPUSH
79407: CALL_OW 428
79411: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79412: LD_VAR 0 14
79416: PUSH
79417: LD_VAR 0 9
79421: ARRAY
79422: PUSH
79423: LD_INT 1
79425: ARRAY
79426: PPUSH
79427: LD_VAR 0 14
79431: PUSH
79432: LD_VAR 0 9
79436: ARRAY
79437: PUSH
79438: LD_INT 2
79440: ARRAY
79441: PPUSH
79442: CALL_OW 351
79446: PUSH
79447: LD_VAR 0 14
79451: PUSH
79452: LD_VAR 0 9
79456: ARRAY
79457: PUSH
79458: LD_INT 1
79460: ARRAY
79461: PPUSH
79462: LD_VAR 0 14
79466: PUSH
79467: LD_VAR 0 9
79471: ARRAY
79472: PUSH
79473: LD_INT 2
79475: ARRAY
79476: PPUSH
79477: CALL_OW 488
79481: NOT
79482: OR
79483: PUSH
79484: LD_VAR 0 13
79488: PPUSH
79489: CALL_OW 247
79493: PUSH
79494: LD_INT 3
79496: EQUAL
79497: OR
79498: IFFALSE 79504
// exit ;
79500: POP
79501: POP
79502: GO 80048
// if not tmp then
79504: LD_VAR 0 13
79508: NOT
79509: IFFALSE 79513
// continue ;
79511: GO 79369
// result := true ;
79513: LD_ADDR_VAR 0 8
79517: PUSH
79518: LD_INT 1
79520: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
79521: LD_VAR 0 6
79525: PUSH
79526: LD_VAR 0 13
79530: PPUSH
79531: CALL_OW 247
79535: PUSH
79536: LD_INT 2
79538: EQUAL
79539: AND
79540: PUSH
79541: LD_VAR 0 13
79545: PPUSH
79546: CALL_OW 263
79550: PUSH
79551: LD_INT 1
79553: EQUAL
79554: AND
79555: IFFALSE 79719
// begin if IsDrivenBy ( tmp ) then
79557: LD_VAR 0 13
79561: PPUSH
79562: CALL_OW 311
79566: IFFALSE 79570
// continue ;
79568: GO 79369
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
79570: LD_VAR 0 6
79574: PPUSH
79575: LD_INT 3
79577: PUSH
79578: LD_INT 60
79580: PUSH
79581: EMPTY
79582: LIST
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PUSH
79588: LD_INT 3
79590: PUSH
79591: LD_INT 55
79593: PUSH
79594: EMPTY
79595: LIST
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PPUSH
79605: CALL_OW 72
79609: IFFALSE 79717
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
79611: LD_ADDR_VAR 0 18
79615: PUSH
79616: LD_VAR 0 6
79620: PPUSH
79621: LD_INT 3
79623: PUSH
79624: LD_INT 60
79626: PUSH
79627: EMPTY
79628: LIST
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 3
79636: PUSH
79637: LD_INT 55
79639: PUSH
79640: EMPTY
79641: LIST
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PPUSH
79651: CALL_OW 72
79655: PUSH
79656: LD_INT 1
79658: ARRAY
79659: ST_TO_ADDR
// if IsInUnit ( driver ) then
79660: LD_VAR 0 18
79664: PPUSH
79665: CALL_OW 310
79669: IFFALSE 79680
// ComExit ( driver ) ;
79671: LD_VAR 0 18
79675: PPUSH
79676: CALL 105042 0 1
// AddComEnterUnit ( driver , tmp ) ;
79680: LD_VAR 0 18
79684: PPUSH
79685: LD_VAR 0 13
79689: PPUSH
79690: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
79694: LD_VAR 0 18
79698: PPUSH
79699: LD_VAR 0 7
79703: PPUSH
79704: CALL_OW 173
// AddComExitVehicle ( driver ) ;
79708: LD_VAR 0 18
79712: PPUSH
79713: CALL_OW 181
// end ; continue ;
79717: GO 79369
// end ; if not cleaners or not tmp in cleaners then
79719: LD_VAR 0 6
79723: NOT
79724: PUSH
79725: LD_VAR 0 13
79729: PUSH
79730: LD_VAR 0 6
79734: IN
79735: NOT
79736: OR
79737: IFFALSE 80044
// begin if dep then
79739: LD_VAR 0 17
79743: IFFALSE 79879
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79745: LD_ADDR_VAR 0 16
79749: PUSH
79750: LD_VAR 0 17
79754: PUSH
79755: LD_INT 1
79757: ARRAY
79758: PPUSH
79759: CALL_OW 250
79763: PPUSH
79764: LD_VAR 0 17
79768: PUSH
79769: LD_INT 1
79771: ARRAY
79772: PPUSH
79773: CALL_OW 254
79777: PPUSH
79778: LD_INT 5
79780: PPUSH
79781: CALL_OW 272
79785: PUSH
79786: LD_VAR 0 17
79790: PUSH
79791: LD_INT 1
79793: ARRAY
79794: PPUSH
79795: CALL_OW 251
79799: PPUSH
79800: LD_VAR 0 17
79804: PUSH
79805: LD_INT 1
79807: ARRAY
79808: PPUSH
79809: CALL_OW 254
79813: PPUSH
79814: LD_INT 5
79816: PPUSH
79817: CALL_OW 273
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79826: LD_VAR 0 16
79830: PUSH
79831: LD_INT 1
79833: ARRAY
79834: PPUSH
79835: LD_VAR 0 16
79839: PUSH
79840: LD_INT 2
79842: ARRAY
79843: PPUSH
79844: CALL_OW 488
79848: IFFALSE 79879
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79850: LD_VAR 0 13
79854: PPUSH
79855: LD_VAR 0 16
79859: PUSH
79860: LD_INT 1
79862: ARRAY
79863: PPUSH
79864: LD_VAR 0 16
79868: PUSH
79869: LD_INT 2
79871: ARRAY
79872: PPUSH
79873: CALL_OW 111
// continue ;
79877: GO 79369
// end ; end ; r := GetDir ( tmp ) ;
79879: LD_ADDR_VAR 0 15
79883: PUSH
79884: LD_VAR 0 13
79888: PPUSH
79889: CALL_OW 254
79893: ST_TO_ADDR
// if r = 5 then
79894: LD_VAR 0 15
79898: PUSH
79899: LD_INT 5
79901: EQUAL
79902: IFFALSE 79912
// r := 0 ;
79904: LD_ADDR_VAR 0 15
79908: PUSH
79909: LD_INT 0
79911: ST_TO_ADDR
// for j = r to 5 do
79912: LD_ADDR_VAR 0 10
79916: PUSH
79917: DOUBLE
79918: LD_VAR 0 15
79922: DEC
79923: ST_TO_ADDR
79924: LD_INT 5
79926: PUSH
79927: FOR_TO
79928: IFFALSE 80042
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79930: LD_ADDR_VAR 0 11
79934: PUSH
79935: LD_VAR 0 13
79939: PPUSH
79940: CALL_OW 250
79944: PPUSH
79945: LD_VAR 0 10
79949: PPUSH
79950: LD_INT 2
79952: PPUSH
79953: CALL_OW 272
79957: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79958: LD_ADDR_VAR 0 12
79962: PUSH
79963: LD_VAR 0 13
79967: PPUSH
79968: CALL_OW 251
79972: PPUSH
79973: LD_VAR 0 10
79977: PPUSH
79978: LD_INT 2
79980: PPUSH
79981: CALL_OW 273
79985: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79986: LD_VAR 0 11
79990: PPUSH
79991: LD_VAR 0 12
79995: PPUSH
79996: CALL_OW 488
80000: PUSH
80001: LD_VAR 0 11
80005: PPUSH
80006: LD_VAR 0 12
80010: PPUSH
80011: CALL_OW 428
80015: NOT
80016: AND
80017: IFFALSE 80040
// begin ComMoveXY ( tmp , _x , _y ) ;
80019: LD_VAR 0 13
80023: PPUSH
80024: LD_VAR 0 11
80028: PPUSH
80029: LD_VAR 0 12
80033: PPUSH
80034: CALL_OW 111
// break ;
80038: GO 80042
// end ; end ;
80040: GO 79927
80042: POP
80043: POP
// end ; end ;
80044: GO 79369
80046: POP
80047: POP
// end ;
80048: LD_VAR 0 8
80052: RET
// export function BuildingTechInvented ( side , btype ) ; begin
80053: LD_INT 0
80055: PPUSH
// result := true ;
80056: LD_ADDR_VAR 0 3
80060: PUSH
80061: LD_INT 1
80063: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
80064: LD_VAR 0 2
80068: PUSH
80069: LD_INT 24
80071: DOUBLE
80072: EQUAL
80073: IFTRUE 80083
80075: LD_INT 33
80077: DOUBLE
80078: EQUAL
80079: IFTRUE 80083
80081: GO 80108
80083: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
80084: LD_ADDR_VAR 0 3
80088: PUSH
80089: LD_INT 32
80091: PPUSH
80092: LD_VAR 0 1
80096: PPUSH
80097: CALL_OW 321
80101: PUSH
80102: LD_INT 2
80104: EQUAL
80105: ST_TO_ADDR
80106: GO 80424
80108: LD_INT 20
80110: DOUBLE
80111: EQUAL
80112: IFTRUE 80116
80114: GO 80141
80116: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
80117: LD_ADDR_VAR 0 3
80121: PUSH
80122: LD_INT 6
80124: PPUSH
80125: LD_VAR 0 1
80129: PPUSH
80130: CALL_OW 321
80134: PUSH
80135: LD_INT 2
80137: EQUAL
80138: ST_TO_ADDR
80139: GO 80424
80141: LD_INT 22
80143: DOUBLE
80144: EQUAL
80145: IFTRUE 80155
80147: LD_INT 36
80149: DOUBLE
80150: EQUAL
80151: IFTRUE 80155
80153: GO 80180
80155: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
80156: LD_ADDR_VAR 0 3
80160: PUSH
80161: LD_INT 15
80163: PPUSH
80164: LD_VAR 0 1
80168: PPUSH
80169: CALL_OW 321
80173: PUSH
80174: LD_INT 2
80176: EQUAL
80177: ST_TO_ADDR
80178: GO 80424
80180: LD_INT 30
80182: DOUBLE
80183: EQUAL
80184: IFTRUE 80188
80186: GO 80213
80188: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
80189: LD_ADDR_VAR 0 3
80193: PUSH
80194: LD_INT 20
80196: PPUSH
80197: LD_VAR 0 1
80201: PPUSH
80202: CALL_OW 321
80206: PUSH
80207: LD_INT 2
80209: EQUAL
80210: ST_TO_ADDR
80211: GO 80424
80213: LD_INT 28
80215: DOUBLE
80216: EQUAL
80217: IFTRUE 80227
80219: LD_INT 21
80221: DOUBLE
80222: EQUAL
80223: IFTRUE 80227
80225: GO 80252
80227: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
80228: LD_ADDR_VAR 0 3
80232: PUSH
80233: LD_INT 21
80235: PPUSH
80236: LD_VAR 0 1
80240: PPUSH
80241: CALL_OW 321
80245: PUSH
80246: LD_INT 2
80248: EQUAL
80249: ST_TO_ADDR
80250: GO 80424
80252: LD_INT 16
80254: DOUBLE
80255: EQUAL
80256: IFTRUE 80260
80258: GO 80285
80260: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
80261: LD_ADDR_VAR 0 3
80265: PUSH
80266: LD_INT 84
80268: PPUSH
80269: LD_VAR 0 1
80273: PPUSH
80274: CALL_OW 321
80278: PUSH
80279: LD_INT 2
80281: EQUAL
80282: ST_TO_ADDR
80283: GO 80424
80285: LD_INT 19
80287: DOUBLE
80288: EQUAL
80289: IFTRUE 80299
80291: LD_INT 23
80293: DOUBLE
80294: EQUAL
80295: IFTRUE 80299
80297: GO 80324
80299: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
80300: LD_ADDR_VAR 0 3
80304: PUSH
80305: LD_INT 83
80307: PPUSH
80308: LD_VAR 0 1
80312: PPUSH
80313: CALL_OW 321
80317: PUSH
80318: LD_INT 2
80320: EQUAL
80321: ST_TO_ADDR
80322: GO 80424
80324: LD_INT 17
80326: DOUBLE
80327: EQUAL
80328: IFTRUE 80332
80330: GO 80357
80332: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
80333: LD_ADDR_VAR 0 3
80337: PUSH
80338: LD_INT 39
80340: PPUSH
80341: LD_VAR 0 1
80345: PPUSH
80346: CALL_OW 321
80350: PUSH
80351: LD_INT 2
80353: EQUAL
80354: ST_TO_ADDR
80355: GO 80424
80357: LD_INT 18
80359: DOUBLE
80360: EQUAL
80361: IFTRUE 80365
80363: GO 80390
80365: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
80366: LD_ADDR_VAR 0 3
80370: PUSH
80371: LD_INT 40
80373: PPUSH
80374: LD_VAR 0 1
80378: PPUSH
80379: CALL_OW 321
80383: PUSH
80384: LD_INT 2
80386: EQUAL
80387: ST_TO_ADDR
80388: GO 80424
80390: LD_INT 27
80392: DOUBLE
80393: EQUAL
80394: IFTRUE 80398
80396: GO 80423
80398: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
80399: LD_ADDR_VAR 0 3
80403: PUSH
80404: LD_INT 35
80406: PPUSH
80407: LD_VAR 0 1
80411: PPUSH
80412: CALL_OW 321
80416: PUSH
80417: LD_INT 2
80419: EQUAL
80420: ST_TO_ADDR
80421: GO 80424
80423: POP
// end ;
80424: LD_VAR 0 3
80428: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
80429: LD_INT 0
80431: PPUSH
80432: PPUSH
80433: PPUSH
80434: PPUSH
80435: PPUSH
80436: PPUSH
80437: PPUSH
80438: PPUSH
80439: PPUSH
80440: PPUSH
80441: PPUSH
// result := false ;
80442: LD_ADDR_VAR 0 6
80446: PUSH
80447: LD_INT 0
80449: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
80450: LD_VAR 0 1
80454: NOT
80455: PUSH
80456: LD_VAR 0 1
80460: PPUSH
80461: CALL_OW 266
80465: PUSH
80466: LD_INT 0
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: IN
80476: NOT
80477: OR
80478: PUSH
80479: LD_VAR 0 2
80483: NOT
80484: OR
80485: PUSH
80486: LD_VAR 0 5
80490: PUSH
80491: LD_INT 0
80493: PUSH
80494: LD_INT 1
80496: PUSH
80497: LD_INT 2
80499: PUSH
80500: LD_INT 3
80502: PUSH
80503: LD_INT 4
80505: PUSH
80506: LD_INT 5
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: LIST
80513: LIST
80514: LIST
80515: LIST
80516: IN
80517: NOT
80518: OR
80519: PUSH
80520: LD_VAR 0 3
80524: PPUSH
80525: LD_VAR 0 4
80529: PPUSH
80530: CALL_OW 488
80534: NOT
80535: OR
80536: IFFALSE 80540
// exit ;
80538: GO 81276
// side := GetSide ( depot ) ;
80540: LD_ADDR_VAR 0 9
80544: PUSH
80545: LD_VAR 0 1
80549: PPUSH
80550: CALL_OW 255
80554: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
80555: LD_VAR 0 9
80559: PPUSH
80560: LD_VAR 0 2
80564: PPUSH
80565: CALL 80053 0 2
80569: NOT
80570: IFFALSE 80574
// exit ;
80572: GO 81276
// pom := GetBase ( depot ) ;
80574: LD_ADDR_VAR 0 10
80578: PUSH
80579: LD_VAR 0 1
80583: PPUSH
80584: CALL_OW 274
80588: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
80589: LD_ADDR_VAR 0 11
80593: PUSH
80594: LD_VAR 0 2
80598: PPUSH
80599: LD_VAR 0 1
80603: PPUSH
80604: CALL_OW 248
80608: PPUSH
80609: CALL_OW 450
80613: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
80614: LD_VAR 0 10
80618: PPUSH
80619: LD_INT 1
80621: PPUSH
80622: CALL_OW 275
80626: PUSH
80627: LD_VAR 0 11
80631: PUSH
80632: LD_INT 1
80634: ARRAY
80635: GREATEREQUAL
80636: PUSH
80637: LD_VAR 0 10
80641: PPUSH
80642: LD_INT 2
80644: PPUSH
80645: CALL_OW 275
80649: PUSH
80650: LD_VAR 0 11
80654: PUSH
80655: LD_INT 2
80657: ARRAY
80658: GREATEREQUAL
80659: AND
80660: PUSH
80661: LD_VAR 0 10
80665: PPUSH
80666: LD_INT 3
80668: PPUSH
80669: CALL_OW 275
80673: PUSH
80674: LD_VAR 0 11
80678: PUSH
80679: LD_INT 3
80681: ARRAY
80682: GREATEREQUAL
80683: AND
80684: NOT
80685: IFFALSE 80689
// exit ;
80687: GO 81276
// if GetBType ( depot ) = b_depot then
80689: LD_VAR 0 1
80693: PPUSH
80694: CALL_OW 266
80698: PUSH
80699: LD_INT 0
80701: EQUAL
80702: IFFALSE 80714
// dist := 28 else
80704: LD_ADDR_VAR 0 14
80708: PUSH
80709: LD_INT 28
80711: ST_TO_ADDR
80712: GO 80722
// dist := 36 ;
80714: LD_ADDR_VAR 0 14
80718: PUSH
80719: LD_INT 36
80721: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
80722: LD_VAR 0 1
80726: PPUSH
80727: LD_VAR 0 3
80731: PPUSH
80732: LD_VAR 0 4
80736: PPUSH
80737: CALL_OW 297
80741: PUSH
80742: LD_VAR 0 14
80746: GREATER
80747: IFFALSE 80751
// exit ;
80749: GO 81276
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
80751: LD_ADDR_VAR 0 12
80755: PUSH
80756: LD_VAR 0 2
80760: PPUSH
80761: LD_VAR 0 3
80765: PPUSH
80766: LD_VAR 0 4
80770: PPUSH
80771: LD_VAR 0 5
80775: PPUSH
80776: LD_VAR 0 1
80780: PPUSH
80781: CALL_OW 248
80785: PPUSH
80786: LD_INT 0
80788: PPUSH
80789: CALL 81281 0 6
80793: ST_TO_ADDR
// if not hexes then
80794: LD_VAR 0 12
80798: NOT
80799: IFFALSE 80803
// exit ;
80801: GO 81276
// hex := GetHexInfo ( x , y ) ;
80803: LD_ADDR_VAR 0 15
80807: PUSH
80808: LD_VAR 0 3
80812: PPUSH
80813: LD_VAR 0 4
80817: PPUSH
80818: CALL_OW 546
80822: ST_TO_ADDR
// if hex [ 1 ] then
80823: LD_VAR 0 15
80827: PUSH
80828: LD_INT 1
80830: ARRAY
80831: IFFALSE 80835
// exit ;
80833: GO 81276
// height := hex [ 2 ] ;
80835: LD_ADDR_VAR 0 13
80839: PUSH
80840: LD_VAR 0 15
80844: PUSH
80845: LD_INT 2
80847: ARRAY
80848: ST_TO_ADDR
// for i = 1 to hexes do
80849: LD_ADDR_VAR 0 7
80853: PUSH
80854: DOUBLE
80855: LD_INT 1
80857: DEC
80858: ST_TO_ADDR
80859: LD_VAR 0 12
80863: PUSH
80864: FOR_TO
80865: IFFALSE 81195
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80867: LD_VAR 0 12
80871: PUSH
80872: LD_VAR 0 7
80876: ARRAY
80877: PUSH
80878: LD_INT 1
80880: ARRAY
80881: PPUSH
80882: LD_VAR 0 12
80886: PUSH
80887: LD_VAR 0 7
80891: ARRAY
80892: PUSH
80893: LD_INT 2
80895: ARRAY
80896: PPUSH
80897: CALL_OW 488
80901: NOT
80902: PUSH
80903: LD_VAR 0 12
80907: PUSH
80908: LD_VAR 0 7
80912: ARRAY
80913: PUSH
80914: LD_INT 1
80916: ARRAY
80917: PPUSH
80918: LD_VAR 0 12
80922: PUSH
80923: LD_VAR 0 7
80927: ARRAY
80928: PUSH
80929: LD_INT 2
80931: ARRAY
80932: PPUSH
80933: CALL_OW 428
80937: PUSH
80938: LD_INT 0
80940: GREATER
80941: OR
80942: PUSH
80943: LD_VAR 0 12
80947: PUSH
80948: LD_VAR 0 7
80952: ARRAY
80953: PUSH
80954: LD_INT 1
80956: ARRAY
80957: PPUSH
80958: LD_VAR 0 12
80962: PUSH
80963: LD_VAR 0 7
80967: ARRAY
80968: PUSH
80969: LD_INT 2
80971: ARRAY
80972: PPUSH
80973: CALL_OW 351
80977: OR
80978: IFFALSE 80984
// exit ;
80980: POP
80981: POP
80982: GO 81276
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80984: LD_ADDR_VAR 0 8
80988: PUSH
80989: LD_VAR 0 12
80993: PUSH
80994: LD_VAR 0 7
80998: ARRAY
80999: PUSH
81000: LD_INT 1
81002: ARRAY
81003: PPUSH
81004: LD_VAR 0 12
81008: PUSH
81009: LD_VAR 0 7
81013: ARRAY
81014: PUSH
81015: LD_INT 2
81017: ARRAY
81018: PPUSH
81019: CALL_OW 546
81023: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
81024: LD_VAR 0 8
81028: PUSH
81029: LD_INT 1
81031: ARRAY
81032: PUSH
81033: LD_VAR 0 8
81037: PUSH
81038: LD_INT 2
81040: ARRAY
81041: PUSH
81042: LD_VAR 0 13
81046: PUSH
81047: LD_INT 2
81049: PLUS
81050: GREATER
81051: OR
81052: PUSH
81053: LD_VAR 0 8
81057: PUSH
81058: LD_INT 2
81060: ARRAY
81061: PUSH
81062: LD_VAR 0 13
81066: PUSH
81067: LD_INT 2
81069: MINUS
81070: LESS
81071: OR
81072: PUSH
81073: LD_VAR 0 8
81077: PUSH
81078: LD_INT 3
81080: ARRAY
81081: PUSH
81082: LD_INT 0
81084: PUSH
81085: LD_INT 8
81087: PUSH
81088: LD_INT 9
81090: PUSH
81091: LD_INT 10
81093: PUSH
81094: LD_INT 11
81096: PUSH
81097: LD_INT 12
81099: PUSH
81100: LD_INT 13
81102: PUSH
81103: LD_INT 16
81105: PUSH
81106: LD_INT 17
81108: PUSH
81109: LD_INT 18
81111: PUSH
81112: LD_INT 19
81114: PUSH
81115: LD_INT 20
81117: PUSH
81118: LD_INT 21
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: IN
81136: NOT
81137: OR
81138: PUSH
81139: LD_VAR 0 8
81143: PUSH
81144: LD_INT 5
81146: ARRAY
81147: NOT
81148: OR
81149: PUSH
81150: LD_VAR 0 8
81154: PUSH
81155: LD_INT 6
81157: ARRAY
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: LD_INT 2
81164: PUSH
81165: LD_INT 7
81167: PUSH
81168: LD_INT 9
81170: PUSH
81171: LD_INT 10
81173: PUSH
81174: LD_INT 11
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: IN
81185: NOT
81186: OR
81187: IFFALSE 81193
// exit ;
81189: POP
81190: POP
81191: GO 81276
// end ;
81193: GO 80864
81195: POP
81196: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81197: LD_VAR 0 9
81201: PPUSH
81202: LD_VAR 0 3
81206: PPUSH
81207: LD_VAR 0 4
81211: PPUSH
81212: LD_INT 20
81214: PPUSH
81215: CALL 73228 0 4
81219: PUSH
81220: LD_INT 4
81222: ARRAY
81223: IFFALSE 81227
// exit ;
81225: GO 81276
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
81227: LD_VAR 0 2
81231: PUSH
81232: LD_INT 29
81234: PUSH
81235: LD_INT 30
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: IN
81242: PUSH
81243: LD_VAR 0 3
81247: PPUSH
81248: LD_VAR 0 4
81252: PPUSH
81253: LD_VAR 0 9
81257: PPUSH
81258: CALL_OW 440
81262: NOT
81263: AND
81264: IFFALSE 81268
// exit ;
81266: GO 81276
// result := true ;
81268: LD_ADDR_VAR 0 6
81272: PUSH
81273: LD_INT 1
81275: ST_TO_ADDR
// end ;
81276: LD_VAR 0 6
81280: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
81281: LD_INT 0
81283: PPUSH
81284: PPUSH
81285: PPUSH
81286: PPUSH
81287: PPUSH
81288: PPUSH
81289: PPUSH
81290: PPUSH
81291: PPUSH
81292: PPUSH
81293: PPUSH
81294: PPUSH
81295: PPUSH
81296: PPUSH
81297: PPUSH
81298: PPUSH
81299: PPUSH
81300: PPUSH
81301: PPUSH
81302: PPUSH
81303: PPUSH
81304: PPUSH
81305: PPUSH
81306: PPUSH
81307: PPUSH
81308: PPUSH
81309: PPUSH
81310: PPUSH
81311: PPUSH
81312: PPUSH
81313: PPUSH
81314: PPUSH
81315: PPUSH
81316: PPUSH
81317: PPUSH
81318: PPUSH
81319: PPUSH
81320: PPUSH
81321: PPUSH
81322: PPUSH
81323: PPUSH
81324: PPUSH
81325: PPUSH
81326: PPUSH
81327: PPUSH
81328: PPUSH
81329: PPUSH
81330: PPUSH
81331: PPUSH
81332: PPUSH
81333: PPUSH
81334: PPUSH
81335: PPUSH
81336: PPUSH
81337: PPUSH
81338: PPUSH
81339: PPUSH
81340: PPUSH
// result = [ ] ;
81341: LD_ADDR_VAR 0 7
81345: PUSH
81346: EMPTY
81347: ST_TO_ADDR
// temp_list = [ ] ;
81348: LD_ADDR_VAR 0 9
81352: PUSH
81353: EMPTY
81354: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
81355: LD_VAR 0 4
81359: PUSH
81360: LD_INT 0
81362: PUSH
81363: LD_INT 1
81365: PUSH
81366: LD_INT 2
81368: PUSH
81369: LD_INT 3
81371: PUSH
81372: LD_INT 4
81374: PUSH
81375: LD_INT 5
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: IN
81386: NOT
81387: PUSH
81388: LD_VAR 0 1
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: IN
81403: PUSH
81404: LD_VAR 0 5
81408: PUSH
81409: LD_INT 1
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 3
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: LIST
81422: IN
81423: NOT
81424: AND
81425: OR
81426: IFFALSE 81430
// exit ;
81428: GO 99821
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
81430: LD_VAR 0 1
81434: PUSH
81435: LD_INT 6
81437: PUSH
81438: LD_INT 7
81440: PUSH
81441: LD_INT 8
81443: PUSH
81444: LD_INT 13
81446: PUSH
81447: LD_INT 12
81449: PUSH
81450: LD_INT 15
81452: PUSH
81453: LD_INT 11
81455: PUSH
81456: LD_INT 14
81458: PUSH
81459: LD_INT 10
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: IN
81473: IFFALSE 81483
// btype = b_lab ;
81475: LD_ADDR_VAR 0 1
81479: PUSH
81480: LD_INT 6
81482: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
81483: LD_VAR 0 6
81487: PUSH
81488: LD_INT 0
81490: PUSH
81491: LD_INT 1
81493: PUSH
81494: LD_INT 2
81496: PUSH
81497: EMPTY
81498: LIST
81499: LIST
81500: LIST
81501: IN
81502: NOT
81503: PUSH
81504: LD_VAR 0 1
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: LD_INT 2
81517: PUSH
81518: LD_INT 3
81520: PUSH
81521: LD_INT 6
81523: PUSH
81524: LD_INT 36
81526: PUSH
81527: LD_INT 4
81529: PUSH
81530: LD_INT 5
81532: PUSH
81533: LD_INT 31
81535: PUSH
81536: LD_INT 32
81538: PUSH
81539: LD_INT 33
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: IN
81555: NOT
81556: PUSH
81557: LD_VAR 0 6
81561: PUSH
81562: LD_INT 1
81564: EQUAL
81565: AND
81566: OR
81567: PUSH
81568: LD_VAR 0 1
81572: PUSH
81573: LD_INT 2
81575: PUSH
81576: LD_INT 3
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: IN
81583: NOT
81584: PUSH
81585: LD_VAR 0 6
81589: PUSH
81590: LD_INT 2
81592: EQUAL
81593: AND
81594: OR
81595: IFFALSE 81605
// mode = 0 ;
81597: LD_ADDR_VAR 0 6
81601: PUSH
81602: LD_INT 0
81604: ST_TO_ADDR
// case mode of 0 :
81605: LD_VAR 0 6
81609: PUSH
81610: LD_INT 0
81612: DOUBLE
81613: EQUAL
81614: IFTRUE 81618
81616: GO 93071
81618: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81619: LD_ADDR_VAR 0 11
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: LD_INT 0
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: PUSH
81634: LD_INT 0
81636: PUSH
81637: LD_INT 1
81639: NEG
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 1
81647: PUSH
81648: LD_INT 0
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 1
81657: PUSH
81658: LD_INT 1
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 0
81667: PUSH
81668: LD_INT 1
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 1
81677: NEG
81678: PUSH
81679: LD_INT 0
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: LD_INT 1
81688: NEG
81689: PUSH
81690: LD_INT 1
81692: NEG
81693: PUSH
81694: EMPTY
81695: LIST
81696: LIST
81697: PUSH
81698: LD_INT 1
81700: NEG
81701: PUSH
81702: LD_INT 2
81704: NEG
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 0
81712: PUSH
81713: LD_INT 2
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 1
81723: PUSH
81724: LD_INT 1
81726: NEG
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: LD_INT 1
81734: PUSH
81735: LD_INT 2
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: LD_INT 2
81747: PUSH
81748: EMPTY
81749: LIST
81750: LIST
81751: PUSH
81752: LD_INT 1
81754: NEG
81755: PUSH
81756: LD_INT 1
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 1
81765: PUSH
81766: LD_INT 3
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 0
81775: PUSH
81776: LD_INT 3
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 1
81785: NEG
81786: PUSH
81787: LD_INT 2
81789: PUSH
81790: EMPTY
81791: LIST
81792: LIST
81793: PUSH
81794: EMPTY
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81812: LD_ADDR_VAR 0 12
81816: PUSH
81817: LD_INT 0
81819: PUSH
81820: LD_INT 0
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 0
81829: PUSH
81830: LD_INT 1
81832: NEG
81833: PUSH
81834: EMPTY
81835: LIST
81836: LIST
81837: PUSH
81838: LD_INT 1
81840: PUSH
81841: LD_INT 0
81843: PUSH
81844: EMPTY
81845: LIST
81846: LIST
81847: PUSH
81848: LD_INT 1
81850: PUSH
81851: LD_INT 1
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 0
81860: PUSH
81861: LD_INT 1
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 1
81870: NEG
81871: PUSH
81872: LD_INT 0
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 1
81881: NEG
81882: PUSH
81883: LD_INT 1
81885: NEG
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 1
81893: PUSH
81894: LD_INT 1
81896: NEG
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 2
81904: PUSH
81905: LD_INT 0
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 2
81914: PUSH
81915: LD_INT 1
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 2
81935: NEG
81936: PUSH
81937: LD_INT 0
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: LD_INT 2
81946: NEG
81947: PUSH
81948: LD_INT 1
81950: NEG
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 2
81958: NEG
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: EMPTY
81964: LIST
81965: LIST
81966: PUSH
81967: LD_INT 3
81969: NEG
81970: PUSH
81971: LD_INT 0
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: PUSH
81978: LD_INT 3
81980: NEG
81981: PUSH
81982: LD_INT 1
81984: NEG
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82008: LD_ADDR_VAR 0 13
82012: PUSH
82013: LD_INT 0
82015: PUSH
82016: LD_INT 0
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 0
82025: PUSH
82026: LD_INT 1
82028: NEG
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: LD_INT 1
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: EMPTY
82041: LIST
82042: LIST
82043: PUSH
82044: LD_INT 1
82046: PUSH
82047: LD_INT 1
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 0
82056: PUSH
82057: LD_INT 1
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 1
82066: NEG
82067: PUSH
82068: LD_INT 0
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: LD_INT 2
82093: NEG
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 2
82101: PUSH
82102: LD_INT 1
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 2
82111: PUSH
82112: LD_INT 2
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PUSH
82119: LD_INT 1
82121: PUSH
82122: LD_INT 2
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: NEG
82132: PUSH
82133: LD_INT 1
82135: NEG
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: PUSH
82141: LD_INT 2
82143: NEG
82144: PUSH
82145: LD_INT 2
82147: NEG
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 3
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 3
82167: NEG
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 3
82179: NEG
82180: PUSH
82181: LD_INT 3
82183: NEG
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: LIST
82204: LIST
82205: LIST
82206: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
82207: LD_ADDR_VAR 0 14
82211: PUSH
82212: LD_INT 0
82214: PUSH
82215: LD_INT 0
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: LD_INT 1
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: LD_INT 1
82235: PUSH
82236: LD_INT 0
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 1
82245: PUSH
82246: LD_INT 1
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: PUSH
82253: LD_INT 0
82255: PUSH
82256: LD_INT 1
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 1
82265: NEG
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 1
82276: NEG
82277: PUSH
82278: LD_INT 1
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 1
82288: NEG
82289: PUSH
82290: LD_INT 2
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 0
82300: PUSH
82301: LD_INT 2
82303: NEG
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 1
82311: PUSH
82312: LD_INT 1
82314: NEG
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PUSH
82320: LD_INT 1
82322: PUSH
82323: LD_INT 2
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: PUSH
82330: LD_INT 0
82332: PUSH
82333: LD_INT 2
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: PUSH
82340: LD_INT 1
82342: NEG
82343: PUSH
82344: LD_INT 1
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 1
82353: NEG
82354: PUSH
82355: LD_INT 3
82357: NEG
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 0
82365: PUSH
82366: LD_INT 3
82368: NEG
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 1
82376: PUSH
82377: LD_INT 2
82379: NEG
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
82403: LD_ADDR_VAR 0 15
82407: PUSH
82408: LD_INT 0
82410: PUSH
82411: LD_INT 0
82413: PUSH
82414: EMPTY
82415: LIST
82416: LIST
82417: PUSH
82418: LD_INT 0
82420: PUSH
82421: LD_INT 1
82423: NEG
82424: PUSH
82425: EMPTY
82426: LIST
82427: LIST
82428: PUSH
82429: LD_INT 1
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 1
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: EMPTY
82446: LIST
82447: LIST
82448: PUSH
82449: LD_INT 0
82451: PUSH
82452: LD_INT 1
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: PUSH
82459: LD_INT 1
82461: NEG
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: EMPTY
82467: LIST
82468: LIST
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: LD_INT 1
82476: NEG
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 1
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: EMPTY
82490: LIST
82491: LIST
82492: PUSH
82493: LD_INT 2
82495: PUSH
82496: LD_INT 0
82498: PUSH
82499: EMPTY
82500: LIST
82501: LIST
82502: PUSH
82503: LD_INT 2
82505: PUSH
82506: LD_INT 1
82508: PUSH
82509: EMPTY
82510: LIST
82511: LIST
82512: PUSH
82513: LD_INT 1
82515: NEG
82516: PUSH
82517: LD_INT 1
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 2
82526: NEG
82527: PUSH
82528: LD_INT 0
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 2
82537: NEG
82538: PUSH
82539: LD_INT 1
82541: NEG
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 2
82549: PUSH
82550: LD_INT 1
82552: NEG
82553: PUSH
82554: EMPTY
82555: LIST
82556: LIST
82557: PUSH
82558: LD_INT 3
82560: PUSH
82561: LD_INT 0
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 3
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: EMPTY
82575: LIST
82576: LIST
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
82596: LD_ADDR_VAR 0 16
82600: PUSH
82601: LD_INT 0
82603: PUSH
82604: LD_INT 0
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: LD_INT 1
82616: NEG
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PUSH
82622: LD_INT 1
82624: PUSH
82625: LD_INT 0
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 1
82634: PUSH
82635: LD_INT 1
82637: PUSH
82638: EMPTY
82639: LIST
82640: LIST
82641: PUSH
82642: LD_INT 0
82644: PUSH
82645: LD_INT 1
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 1
82654: NEG
82655: PUSH
82656: LD_INT 0
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 1
82665: NEG
82666: PUSH
82667: LD_INT 1
82669: NEG
82670: PUSH
82671: EMPTY
82672: LIST
82673: LIST
82674: PUSH
82675: LD_INT 1
82677: NEG
82678: PUSH
82679: LD_INT 2
82681: NEG
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: PUSH
82687: LD_INT 2
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 2
82699: PUSH
82700: LD_INT 2
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: LD_INT 2
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: PUSH
82717: LD_INT 2
82719: NEG
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 2
82731: NEG
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 3
82743: PUSH
82744: LD_INT 2
82746: PUSH
82747: EMPTY
82748: LIST
82749: LIST
82750: PUSH
82751: LD_INT 3
82753: PUSH
82754: LD_INT 3
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: PUSH
82761: LD_INT 2
82763: PUSH
82764: LD_INT 3
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: EMPTY
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82789: LD_ADDR_VAR 0 17
82793: PUSH
82794: LD_INT 0
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 0
82806: PUSH
82807: LD_INT 1
82809: NEG
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 1
82817: PUSH
82818: LD_INT 0
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 1
82827: PUSH
82828: LD_INT 1
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 0
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 1
82847: NEG
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 1
82858: NEG
82859: PUSH
82860: LD_INT 1
82862: NEG
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 1
82870: NEG
82871: PUSH
82872: LD_INT 2
82874: NEG
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 0
82882: PUSH
82883: LD_INT 2
82885: NEG
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 1
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 2
82904: PUSH
82905: LD_INT 0
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 2
82914: PUSH
82915: LD_INT 1
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 2
82924: PUSH
82925: LD_INT 2
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: LD_INT 1
82934: PUSH
82935: LD_INT 2
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 0
82944: PUSH
82945: LD_INT 2
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 1
82954: NEG
82955: PUSH
82956: LD_INT 1
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: NEG
82966: PUSH
82967: LD_INT 0
82969: PUSH
82970: EMPTY
82971: LIST
82972: LIST
82973: PUSH
82974: LD_INT 2
82976: NEG
82977: PUSH
82978: LD_INT 1
82980: NEG
82981: PUSH
82982: EMPTY
82983: LIST
82984: LIST
82985: PUSH
82986: LD_INT 2
82988: NEG
82989: PUSH
82990: LD_INT 2
82992: NEG
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83019: LD_ADDR_VAR 0 18
83023: PUSH
83024: LD_INT 0
83026: PUSH
83027: LD_INT 0
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: PUSH
83034: LD_INT 0
83036: PUSH
83037: LD_INT 1
83039: NEG
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: PUSH
83048: LD_INT 0
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: LD_INT 1
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 0
83067: PUSH
83068: LD_INT 1
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: LD_INT 1
83077: NEG
83078: PUSH
83079: LD_INT 0
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: NEG
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: EMPTY
83095: LIST
83096: LIST
83097: PUSH
83098: LD_INT 1
83100: NEG
83101: PUSH
83102: LD_INT 2
83104: NEG
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: LD_INT 2
83115: NEG
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 1
83123: PUSH
83124: LD_INT 1
83126: NEG
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 2
83134: PUSH
83135: LD_INT 0
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: PUSH
83142: LD_INT 2
83144: PUSH
83145: LD_INT 1
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 2
83154: PUSH
83155: LD_INT 2
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 1
83164: PUSH
83165: LD_INT 2
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: LD_INT 2
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 1
83184: NEG
83185: PUSH
83186: LD_INT 1
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 2
83195: NEG
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 2
83206: NEG
83207: PUSH
83208: LD_INT 1
83210: NEG
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: PUSH
83216: LD_INT 2
83218: NEG
83219: PUSH
83220: LD_INT 2
83222: NEG
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: EMPTY
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: LIST
83239: LIST
83240: LIST
83241: LIST
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: LIST
83247: LIST
83248: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83249: LD_ADDR_VAR 0 19
83253: PUSH
83254: LD_INT 0
83256: PUSH
83257: LD_INT 0
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 0
83266: PUSH
83267: LD_INT 1
83269: NEG
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 1
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: LD_INT 1
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 0
83297: PUSH
83298: LD_INT 1
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: LD_INT 1
83307: NEG
83308: PUSH
83309: LD_INT 0
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 1
83318: NEG
83319: PUSH
83320: LD_INT 1
83322: NEG
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 1
83330: NEG
83331: PUSH
83332: LD_INT 2
83334: NEG
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 0
83342: PUSH
83343: LD_INT 2
83345: NEG
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 2
83364: PUSH
83365: LD_INT 0
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 2
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 2
83384: PUSH
83385: LD_INT 2
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 1
83394: PUSH
83395: LD_INT 2
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 0
83404: PUSH
83405: LD_INT 2
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 1
83414: NEG
83415: PUSH
83416: LD_INT 1
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 2
83425: NEG
83426: PUSH
83427: LD_INT 0
83429: PUSH
83430: EMPTY
83431: LIST
83432: LIST
83433: PUSH
83434: LD_INT 2
83436: NEG
83437: PUSH
83438: LD_INT 1
83440: NEG
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 2
83448: NEG
83449: PUSH
83450: LD_INT 2
83452: NEG
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: LIST
83462: LIST
83463: LIST
83464: LIST
83465: LIST
83466: LIST
83467: LIST
83468: LIST
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83479: LD_ADDR_VAR 0 20
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: LD_INT 0
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 0
83496: PUSH
83497: LD_INT 1
83499: NEG
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 1
83507: PUSH
83508: LD_INT 0
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: LD_INT 1
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 0
83527: PUSH
83528: LD_INT 1
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 1
83537: NEG
83538: PUSH
83539: LD_INT 0
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 1
83548: NEG
83549: PUSH
83550: LD_INT 1
83552: NEG
83553: PUSH
83554: EMPTY
83555: LIST
83556: LIST
83557: PUSH
83558: LD_INT 1
83560: NEG
83561: PUSH
83562: LD_INT 2
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 0
83572: PUSH
83573: LD_INT 2
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 1
83583: PUSH
83584: LD_INT 1
83586: NEG
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 2
83594: PUSH
83595: LD_INT 0
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 2
83604: PUSH
83605: LD_INT 1
83607: PUSH
83608: EMPTY
83609: LIST
83610: LIST
83611: PUSH
83612: LD_INT 2
83614: PUSH
83615: LD_INT 2
83617: PUSH
83618: EMPTY
83619: LIST
83620: LIST
83621: PUSH
83622: LD_INT 1
83624: PUSH
83625: LD_INT 2
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 0
83634: PUSH
83635: LD_INT 2
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: LD_INT 1
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 2
83655: NEG
83656: PUSH
83657: LD_INT 0
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 2
83666: NEG
83667: PUSH
83668: LD_INT 1
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 2
83678: NEG
83679: PUSH
83680: LD_INT 2
83682: NEG
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83709: LD_ADDR_VAR 0 21
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: LD_INT 0
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: LD_INT 0
83726: PUSH
83727: LD_INT 1
83729: NEG
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 1
83737: PUSH
83738: LD_INT 0
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: LD_INT 1
83750: PUSH
83751: EMPTY
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 0
83757: PUSH
83758: LD_INT 1
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 1
83767: NEG
83768: PUSH
83769: LD_INT 0
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 1
83778: NEG
83779: PUSH
83780: LD_INT 1
83782: NEG
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: PUSH
83788: LD_INT 1
83790: NEG
83791: PUSH
83792: LD_INT 2
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 0
83802: PUSH
83803: LD_INT 2
83805: NEG
83806: PUSH
83807: EMPTY
83808: LIST
83809: LIST
83810: PUSH
83811: LD_INT 1
83813: PUSH
83814: LD_INT 1
83816: NEG
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: PUSH
83822: LD_INT 2
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 2
83834: PUSH
83835: LD_INT 1
83837: PUSH
83838: EMPTY
83839: LIST
83840: LIST
83841: PUSH
83842: LD_INT 2
83844: PUSH
83845: LD_INT 2
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: PUSH
83852: LD_INT 1
83854: PUSH
83855: LD_INT 2
83857: PUSH
83858: EMPTY
83859: LIST
83860: LIST
83861: PUSH
83862: LD_INT 0
83864: PUSH
83865: LD_INT 2
83867: PUSH
83868: EMPTY
83869: LIST
83870: LIST
83871: PUSH
83872: LD_INT 1
83874: NEG
83875: PUSH
83876: LD_INT 1
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 2
83885: NEG
83886: PUSH
83887: LD_INT 0
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 2
83896: NEG
83897: PUSH
83898: LD_INT 1
83900: NEG
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: LD_INT 2
83908: NEG
83909: PUSH
83910: LD_INT 2
83912: NEG
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83939: LD_ADDR_VAR 0 22
83943: PUSH
83944: LD_INT 0
83946: PUSH
83947: LD_INT 0
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 0
83956: PUSH
83957: LD_INT 1
83959: NEG
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: LD_INT 1
83967: PUSH
83968: LD_INT 0
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 1
83977: PUSH
83978: LD_INT 1
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: PUSH
83985: LD_INT 0
83987: PUSH
83988: LD_INT 1
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 1
83997: NEG
83998: PUSH
83999: LD_INT 0
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: LD_INT 1
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 1
84020: NEG
84021: PUSH
84022: LD_INT 2
84024: NEG
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 0
84032: PUSH
84033: LD_INT 2
84035: NEG
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 1
84043: PUSH
84044: LD_INT 1
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 0
84057: PUSH
84058: EMPTY
84059: LIST
84060: LIST
84061: PUSH
84062: LD_INT 2
84064: PUSH
84065: LD_INT 1
84067: PUSH
84068: EMPTY
84069: LIST
84070: LIST
84071: PUSH
84072: LD_INT 2
84074: PUSH
84075: LD_INT 2
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: PUSH
84082: LD_INT 1
84084: PUSH
84085: LD_INT 2
84087: PUSH
84088: EMPTY
84089: LIST
84090: LIST
84091: PUSH
84092: LD_INT 0
84094: PUSH
84095: LD_INT 2
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: PUSH
84102: LD_INT 1
84104: NEG
84105: PUSH
84106: LD_INT 1
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 2
84115: NEG
84116: PUSH
84117: LD_INT 0
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: LD_INT 2
84126: NEG
84127: PUSH
84128: LD_INT 1
84130: NEG
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 2
84138: NEG
84139: PUSH
84140: LD_INT 2
84142: NEG
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
84169: LD_ADDR_VAR 0 23
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: LD_INT 0
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: LD_INT 1
84189: NEG
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: LD_INT 0
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: LD_INT 1
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 0
84217: PUSH
84218: LD_INT 1
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 1
84227: NEG
84228: PUSH
84229: LD_INT 0
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: LD_INT 1
84242: NEG
84243: PUSH
84244: EMPTY
84245: LIST
84246: LIST
84247: PUSH
84248: LD_INT 1
84250: NEG
84251: PUSH
84252: LD_INT 2
84254: NEG
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 0
84262: PUSH
84263: LD_INT 2
84265: NEG
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 1
84273: PUSH
84274: LD_INT 1
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 2
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 2
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: LD_INT 2
84304: PUSH
84305: LD_INT 2
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 1
84314: PUSH
84315: LD_INT 2
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 0
84324: PUSH
84325: LD_INT 2
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: NEG
84335: PUSH
84336: LD_INT 1
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: PUSH
84343: LD_INT 2
84345: NEG
84346: PUSH
84347: LD_INT 0
84349: PUSH
84350: EMPTY
84351: LIST
84352: LIST
84353: PUSH
84354: LD_INT 2
84356: NEG
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: PUSH
84366: LD_INT 2
84368: NEG
84369: PUSH
84370: LD_INT 2
84372: NEG
84373: PUSH
84374: EMPTY
84375: LIST
84376: LIST
84377: PUSH
84378: LD_INT 2
84380: NEG
84381: PUSH
84382: LD_INT 3
84384: NEG
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 1
84392: NEG
84393: PUSH
84394: LD_INT 3
84396: NEG
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: LD_INT 1
84404: PUSH
84405: LD_INT 2
84407: NEG
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: LD_INT 2
84415: PUSH
84416: LD_INT 1
84418: NEG
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
84449: LD_ADDR_VAR 0 24
84453: PUSH
84454: LD_INT 0
84456: PUSH
84457: LD_INT 0
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: PUSH
84464: LD_INT 0
84466: PUSH
84467: LD_INT 1
84469: NEG
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 1
84477: PUSH
84478: LD_INT 0
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: LD_INT 1
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 0
84497: PUSH
84498: LD_INT 1
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 1
84507: NEG
84508: PUSH
84509: LD_INT 0
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 1
84518: NEG
84519: PUSH
84520: LD_INT 1
84522: NEG
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 1
84530: NEG
84531: PUSH
84532: LD_INT 2
84534: NEG
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 0
84542: PUSH
84543: LD_INT 2
84545: NEG
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 1
84553: PUSH
84554: LD_INT 1
84556: NEG
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 2
84564: PUSH
84565: LD_INT 0
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 2
84574: PUSH
84575: LD_INT 1
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: LD_INT 2
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PUSH
84592: LD_INT 1
84594: PUSH
84595: LD_INT 2
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 0
84604: PUSH
84605: LD_INT 2
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PUSH
84612: LD_INT 1
84614: NEG
84615: PUSH
84616: LD_INT 1
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 2
84625: NEG
84626: PUSH
84627: LD_INT 0
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 2
84636: NEG
84637: PUSH
84638: LD_INT 1
84640: NEG
84641: PUSH
84642: EMPTY
84643: LIST
84644: LIST
84645: PUSH
84646: LD_INT 2
84648: NEG
84649: PUSH
84650: LD_INT 2
84652: NEG
84653: PUSH
84654: EMPTY
84655: LIST
84656: LIST
84657: PUSH
84658: LD_INT 1
84660: PUSH
84661: LD_INT 2
84663: NEG
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 2
84671: PUSH
84672: LD_INT 1
84674: NEG
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 3
84682: PUSH
84683: LD_INT 1
84685: PUSH
84686: EMPTY
84687: LIST
84688: LIST
84689: PUSH
84690: LD_INT 3
84692: PUSH
84693: LD_INT 2
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
84725: LD_ADDR_VAR 0 25
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: LD_INT 0
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 0
84742: PUSH
84743: LD_INT 1
84745: NEG
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: LD_INT 0
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 1
84763: PUSH
84764: LD_INT 1
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 0
84773: PUSH
84774: LD_INT 1
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 1
84783: NEG
84784: PUSH
84785: LD_INT 0
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: NEG
84795: PUSH
84796: LD_INT 1
84798: NEG
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: NEG
84807: PUSH
84808: LD_INT 2
84810: NEG
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 0
84818: PUSH
84819: LD_INT 2
84821: NEG
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 1
84829: PUSH
84830: LD_INT 1
84832: NEG
84833: PUSH
84834: EMPTY
84835: LIST
84836: LIST
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: LD_INT 0
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 2
84850: PUSH
84851: LD_INT 1
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 2
84860: PUSH
84861: LD_INT 2
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 1
84870: PUSH
84871: LD_INT 2
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 0
84880: PUSH
84881: LD_INT 2
84883: PUSH
84884: EMPTY
84885: LIST
84886: LIST
84887: PUSH
84888: LD_INT 1
84890: NEG
84891: PUSH
84892: LD_INT 1
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 2
84901: NEG
84902: PUSH
84903: LD_INT 0
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 2
84912: NEG
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 2
84924: NEG
84925: PUSH
84926: LD_INT 2
84928: NEG
84929: PUSH
84930: EMPTY
84931: LIST
84932: LIST
84933: PUSH
84934: LD_INT 3
84936: PUSH
84937: LD_INT 1
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: PUSH
84944: LD_INT 3
84946: PUSH
84947: LD_INT 2
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 2
84956: PUSH
84957: LD_INT 3
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: PUSH
84964: LD_INT 1
84966: PUSH
84967: LD_INT 3
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: EMPTY
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84999: LD_ADDR_VAR 0 26
85003: PUSH
85004: LD_INT 0
85006: PUSH
85007: LD_INT 0
85009: PUSH
85010: EMPTY
85011: LIST
85012: LIST
85013: PUSH
85014: LD_INT 0
85016: PUSH
85017: LD_INT 1
85019: NEG
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: PUSH
85025: LD_INT 1
85027: PUSH
85028: LD_INT 0
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_INT 1
85037: PUSH
85038: LD_INT 1
85040: PUSH
85041: EMPTY
85042: LIST
85043: LIST
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: LD_INT 1
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PUSH
85055: LD_INT 1
85057: NEG
85058: PUSH
85059: LD_INT 0
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_INT 1
85068: NEG
85069: PUSH
85070: LD_INT 1
85072: NEG
85073: PUSH
85074: EMPTY
85075: LIST
85076: LIST
85077: PUSH
85078: LD_INT 1
85080: NEG
85081: PUSH
85082: LD_INT 2
85084: NEG
85085: PUSH
85086: EMPTY
85087: LIST
85088: LIST
85089: PUSH
85090: LD_INT 0
85092: PUSH
85093: LD_INT 2
85095: NEG
85096: PUSH
85097: EMPTY
85098: LIST
85099: LIST
85100: PUSH
85101: LD_INT 1
85103: PUSH
85104: LD_INT 1
85106: NEG
85107: PUSH
85108: EMPTY
85109: LIST
85110: LIST
85111: PUSH
85112: LD_INT 2
85114: PUSH
85115: LD_INT 0
85117: PUSH
85118: EMPTY
85119: LIST
85120: LIST
85121: PUSH
85122: LD_INT 2
85124: PUSH
85125: LD_INT 1
85127: PUSH
85128: EMPTY
85129: LIST
85130: LIST
85131: PUSH
85132: LD_INT 2
85134: PUSH
85135: LD_INT 2
85137: PUSH
85138: EMPTY
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 1
85144: PUSH
85145: LD_INT 2
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: PUSH
85152: LD_INT 0
85154: PUSH
85155: LD_INT 2
85157: PUSH
85158: EMPTY
85159: LIST
85160: LIST
85161: PUSH
85162: LD_INT 1
85164: NEG
85165: PUSH
85166: LD_INT 1
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 2
85175: NEG
85176: PUSH
85177: LD_INT 0
85179: PUSH
85180: EMPTY
85181: LIST
85182: LIST
85183: PUSH
85184: LD_INT 2
85186: NEG
85187: PUSH
85188: LD_INT 1
85190: NEG
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: LD_INT 2
85198: NEG
85199: PUSH
85200: LD_INT 2
85202: NEG
85203: PUSH
85204: EMPTY
85205: LIST
85206: LIST
85207: PUSH
85208: LD_INT 2
85210: PUSH
85211: LD_INT 3
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PUSH
85218: LD_INT 1
85220: PUSH
85221: LD_INT 3
85223: PUSH
85224: EMPTY
85225: LIST
85226: LIST
85227: PUSH
85228: LD_INT 1
85230: NEG
85231: PUSH
85232: LD_INT 2
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: LD_INT 2
85241: NEG
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: EMPTY
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: LIST
85273: LIST
85274: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85275: LD_ADDR_VAR 0 27
85279: PUSH
85280: LD_INT 0
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 0
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 1
85303: PUSH
85304: LD_INT 0
85306: PUSH
85307: EMPTY
85308: LIST
85309: LIST
85310: PUSH
85311: LD_INT 1
85313: PUSH
85314: LD_INT 1
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 0
85323: PUSH
85324: LD_INT 1
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: LD_INT 0
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: PUSH
85354: LD_INT 1
85356: NEG
85357: PUSH
85358: LD_INT 2
85360: NEG
85361: PUSH
85362: EMPTY
85363: LIST
85364: LIST
85365: PUSH
85366: LD_INT 0
85368: PUSH
85369: LD_INT 2
85371: NEG
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: PUSH
85377: LD_INT 1
85379: PUSH
85380: LD_INT 1
85382: NEG
85383: PUSH
85384: EMPTY
85385: LIST
85386: LIST
85387: PUSH
85388: LD_INT 2
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 2
85400: PUSH
85401: LD_INT 1
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: PUSH
85411: LD_INT 2
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 1
85420: PUSH
85421: LD_INT 2
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 0
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 1
85440: NEG
85441: PUSH
85442: LD_INT 1
85444: PUSH
85445: EMPTY
85446: LIST
85447: LIST
85448: PUSH
85449: LD_INT 2
85451: NEG
85452: PUSH
85453: LD_INT 0
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 2
85462: NEG
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 2
85474: NEG
85475: PUSH
85476: LD_INT 2
85478: NEG
85479: PUSH
85480: EMPTY
85481: LIST
85482: LIST
85483: PUSH
85484: LD_INT 1
85486: NEG
85487: PUSH
85488: LD_INT 2
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 2
85497: NEG
85498: PUSH
85499: LD_INT 1
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 3
85508: NEG
85509: PUSH
85510: LD_INT 1
85512: NEG
85513: PUSH
85514: EMPTY
85515: LIST
85516: LIST
85517: PUSH
85518: LD_INT 3
85520: NEG
85521: PUSH
85522: LD_INT 2
85524: NEG
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
85555: LD_ADDR_VAR 0 28
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: LD_INT 0
85565: PUSH
85566: EMPTY
85567: LIST
85568: LIST
85569: PUSH
85570: LD_INT 0
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 1
85583: PUSH
85584: LD_INT 0
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: PUSH
85591: LD_INT 1
85593: PUSH
85594: LD_INT 1
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: PUSH
85601: LD_INT 0
85603: PUSH
85604: LD_INT 1
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: PUSH
85611: LD_INT 1
85613: NEG
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 1
85624: NEG
85625: PUSH
85626: LD_INT 1
85628: NEG
85629: PUSH
85630: EMPTY
85631: LIST
85632: LIST
85633: PUSH
85634: LD_INT 1
85636: NEG
85637: PUSH
85638: LD_INT 2
85640: NEG
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: LD_INT 2
85651: NEG
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 1
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: PUSH
85668: LD_INT 2
85670: PUSH
85671: LD_INT 0
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 2
85680: PUSH
85681: LD_INT 1
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PUSH
85688: LD_INT 2
85690: PUSH
85691: LD_INT 2
85693: PUSH
85694: EMPTY
85695: LIST
85696: LIST
85697: PUSH
85698: LD_INT 1
85700: PUSH
85701: LD_INT 2
85703: PUSH
85704: EMPTY
85705: LIST
85706: LIST
85707: PUSH
85708: LD_INT 0
85710: PUSH
85711: LD_INT 2
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: LD_INT 1
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 2
85731: NEG
85732: PUSH
85733: LD_INT 0
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PUSH
85740: LD_INT 2
85742: NEG
85743: PUSH
85744: LD_INT 1
85746: NEG
85747: PUSH
85748: EMPTY
85749: LIST
85750: LIST
85751: PUSH
85752: LD_INT 2
85754: NEG
85755: PUSH
85756: LD_INT 2
85758: NEG
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 2
85766: NEG
85767: PUSH
85768: LD_INT 3
85770: NEG
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 1
85778: NEG
85779: PUSH
85780: LD_INT 3
85782: NEG
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 3
85790: NEG
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 3
85802: NEG
85803: PUSH
85804: LD_INT 2
85806: NEG
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85837: LD_ADDR_VAR 0 29
85841: PUSH
85842: LD_INT 0
85844: PUSH
85845: LD_INT 0
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 0
85854: PUSH
85855: LD_INT 1
85857: NEG
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 1
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: EMPTY
85870: LIST
85871: LIST
85872: PUSH
85873: LD_INT 1
85875: PUSH
85876: LD_INT 1
85878: PUSH
85879: EMPTY
85880: LIST
85881: LIST
85882: PUSH
85883: LD_INT 0
85885: PUSH
85886: LD_INT 1
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PUSH
85893: LD_INT 1
85895: NEG
85896: PUSH
85897: LD_INT 0
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: LD_INT 1
85906: NEG
85907: PUSH
85908: LD_INT 1
85910: NEG
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PUSH
85916: LD_INT 1
85918: NEG
85919: PUSH
85920: LD_INT 2
85922: NEG
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 0
85930: PUSH
85931: LD_INT 2
85933: NEG
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 1
85941: PUSH
85942: LD_INT 1
85944: NEG
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 2
85952: PUSH
85953: LD_INT 0
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: LD_INT 2
85962: PUSH
85963: LD_INT 1
85965: PUSH
85966: EMPTY
85967: LIST
85968: LIST
85969: PUSH
85970: LD_INT 1
85972: PUSH
85973: LD_INT 2
85975: PUSH
85976: EMPTY
85977: LIST
85978: LIST
85979: PUSH
85980: LD_INT 0
85982: PUSH
85983: LD_INT 2
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: LD_INT 1
85992: NEG
85993: PUSH
85994: LD_INT 1
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: PUSH
86001: LD_INT 2
86003: NEG
86004: PUSH
86005: LD_INT 1
86007: NEG
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 2
86015: NEG
86016: PUSH
86017: LD_INT 2
86019: NEG
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 2
86027: NEG
86028: PUSH
86029: LD_INT 3
86031: NEG
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 2
86039: PUSH
86040: LD_INT 1
86042: NEG
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 3
86050: PUSH
86051: LD_INT 1
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: PUSH
86061: LD_INT 3
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 1
86070: NEG
86071: PUSH
86072: LD_INT 2
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 3
86081: NEG
86082: PUSH
86083: LD_INT 2
86085: NEG
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86116: LD_ADDR_VAR 0 30
86120: PUSH
86121: LD_INT 0
86123: PUSH
86124: LD_INT 0
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 1
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 1
86144: PUSH
86145: LD_INT 0
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: PUSH
86155: LD_INT 1
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 0
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 1
86174: NEG
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: LD_INT 1
86189: NEG
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: LD_INT 1
86197: NEG
86198: PUSH
86199: LD_INT 2
86201: NEG
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 0
86209: PUSH
86210: LD_INT 2
86212: NEG
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 1
86220: PUSH
86221: LD_INT 1
86223: NEG
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 2
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 2
86241: PUSH
86242: LD_INT 1
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 2
86251: PUSH
86252: LD_INT 2
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 1
86261: PUSH
86262: LD_INT 2
86264: PUSH
86265: EMPTY
86266: LIST
86267: LIST
86268: PUSH
86269: LD_INT 1
86271: NEG
86272: PUSH
86273: LD_INT 1
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 2
86282: NEG
86283: PUSH
86284: LD_INT 0
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 2
86293: NEG
86294: PUSH
86295: LD_INT 1
86297: NEG
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PUSH
86303: LD_INT 1
86305: NEG
86306: PUSH
86307: LD_INT 3
86309: NEG
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 1
86317: PUSH
86318: LD_INT 2
86320: NEG
86321: PUSH
86322: EMPTY
86323: LIST
86324: LIST
86325: PUSH
86326: LD_INT 3
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 2
86338: PUSH
86339: LD_INT 3
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: LD_INT 2
86348: NEG
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 3
86359: NEG
86360: PUSH
86361: LD_INT 1
86363: NEG
86364: PUSH
86365: EMPTY
86366: LIST
86367: LIST
86368: PUSH
86369: EMPTY
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86394: LD_ADDR_VAR 0 31
86398: PUSH
86399: LD_INT 0
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 0
86411: PUSH
86412: LD_INT 1
86414: NEG
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: LD_INT 1
86422: PUSH
86423: LD_INT 0
86425: PUSH
86426: EMPTY
86427: LIST
86428: LIST
86429: PUSH
86430: LD_INT 1
86432: PUSH
86433: LD_INT 1
86435: PUSH
86436: EMPTY
86437: LIST
86438: LIST
86439: PUSH
86440: LD_INT 0
86442: PUSH
86443: LD_INT 1
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 1
86452: NEG
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PUSH
86461: LD_INT 1
86463: NEG
86464: PUSH
86465: LD_INT 1
86467: NEG
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 1
86475: NEG
86476: PUSH
86477: LD_INT 2
86479: NEG
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: LD_INT 1
86487: PUSH
86488: LD_INT 1
86490: NEG
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: LD_INT 2
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: PUSH
86506: LD_INT 2
86508: PUSH
86509: LD_INT 1
86511: PUSH
86512: EMPTY
86513: LIST
86514: LIST
86515: PUSH
86516: LD_INT 2
86518: PUSH
86519: LD_INT 2
86521: PUSH
86522: EMPTY
86523: LIST
86524: LIST
86525: PUSH
86526: LD_INT 1
86528: PUSH
86529: LD_INT 2
86531: PUSH
86532: EMPTY
86533: LIST
86534: LIST
86535: PUSH
86536: LD_INT 0
86538: PUSH
86539: LD_INT 2
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: LD_INT 1
86552: PUSH
86553: EMPTY
86554: LIST
86555: LIST
86556: PUSH
86557: LD_INT 2
86559: NEG
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 2
86571: NEG
86572: PUSH
86573: LD_INT 2
86575: NEG
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 2
86583: NEG
86584: PUSH
86585: LD_INT 3
86587: NEG
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 2
86595: PUSH
86596: LD_INT 1
86598: NEG
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 3
86606: PUSH
86607: LD_INT 1
86609: PUSH
86610: EMPTY
86611: LIST
86612: LIST
86613: PUSH
86614: LD_INT 1
86616: PUSH
86617: LD_INT 3
86619: PUSH
86620: EMPTY
86621: LIST
86622: LIST
86623: PUSH
86624: LD_INT 1
86626: NEG
86627: PUSH
86628: LD_INT 2
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 3
86637: NEG
86638: PUSH
86639: LD_INT 2
86641: NEG
86642: PUSH
86643: EMPTY
86644: LIST
86645: LIST
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86672: LD_ADDR_VAR 0 32
86676: PUSH
86677: LD_INT 0
86679: PUSH
86680: LD_INT 0
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 1
86692: NEG
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 1
86700: PUSH
86701: LD_INT 0
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: LD_INT 1
86713: PUSH
86714: EMPTY
86715: LIST
86716: LIST
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: LD_INT 1
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 1
86730: NEG
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: EMPTY
86736: LIST
86737: LIST
86738: PUSH
86739: LD_INT 1
86741: NEG
86742: PUSH
86743: LD_INT 1
86745: NEG
86746: PUSH
86747: EMPTY
86748: LIST
86749: LIST
86750: PUSH
86751: LD_INT 1
86753: NEG
86754: PUSH
86755: LD_INT 2
86757: NEG
86758: PUSH
86759: EMPTY
86760: LIST
86761: LIST
86762: PUSH
86763: LD_INT 0
86765: PUSH
86766: LD_INT 2
86768: NEG
86769: PUSH
86770: EMPTY
86771: LIST
86772: LIST
86773: PUSH
86774: LD_INT 1
86776: PUSH
86777: LD_INT 1
86779: NEG
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 2
86787: PUSH
86788: LD_INT 1
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 2
86797: PUSH
86798: LD_INT 2
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: PUSH
86808: LD_INT 2
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: LD_INT 2
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: LD_INT 1
86827: NEG
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 2
86838: NEG
86839: PUSH
86840: LD_INT 0
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: LD_INT 2
86849: NEG
86850: PUSH
86851: LD_INT 1
86853: NEG
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 3
86865: NEG
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 1
86873: PUSH
86874: LD_INT 2
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 3
86884: PUSH
86885: LD_INT 2
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: PUSH
86892: LD_INT 2
86894: PUSH
86895: LD_INT 3
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: LD_INT 1
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 3
86915: NEG
86916: PUSH
86917: LD_INT 1
86919: NEG
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: LIST
86929: LIST
86930: LIST
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86950: LD_ADDR_VAR 0 33
86954: PUSH
86955: LD_INT 0
86957: PUSH
86958: LD_INT 0
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 0
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: PUSH
86972: EMPTY
86973: LIST
86974: LIST
86975: PUSH
86976: LD_INT 1
86978: PUSH
86979: LD_INT 0
86981: PUSH
86982: EMPTY
86983: LIST
86984: LIST
86985: PUSH
86986: LD_INT 1
86988: PUSH
86989: LD_INT 1
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: PUSH
86996: LD_INT 0
86998: PUSH
86999: LD_INT 1
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: PUSH
87006: LD_INT 1
87008: NEG
87009: PUSH
87010: LD_INT 0
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 1
87019: NEG
87020: PUSH
87021: LD_INT 1
87023: NEG
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 1
87031: NEG
87032: PUSH
87033: LD_INT 2
87035: NEG
87036: PUSH
87037: EMPTY
87038: LIST
87039: LIST
87040: PUSH
87041: LD_INT 1
87043: PUSH
87044: LD_INT 1
87046: NEG
87047: PUSH
87048: EMPTY
87049: LIST
87050: LIST
87051: PUSH
87052: LD_INT 2
87054: PUSH
87055: LD_INT 0
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: PUSH
87062: LD_INT 2
87064: PUSH
87065: LD_INT 1
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 1
87074: PUSH
87075: LD_INT 2
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 0
87084: PUSH
87085: LD_INT 2
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: NEG
87095: PUSH
87096: LD_INT 1
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 2
87105: NEG
87106: PUSH
87107: LD_INT 0
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 2
87116: NEG
87117: PUSH
87118: LD_INT 1
87120: NEG
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 2
87128: NEG
87129: PUSH
87130: LD_INT 2
87132: NEG
87133: PUSH
87134: EMPTY
87135: LIST
87136: LIST
87137: PUSH
87138: LD_INT 2
87140: NEG
87141: PUSH
87142: LD_INT 3
87144: NEG
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 2
87152: PUSH
87153: LD_INT 1
87155: NEG
87156: PUSH
87157: EMPTY
87158: LIST
87159: LIST
87160: PUSH
87161: LD_INT 3
87163: PUSH
87164: LD_INT 1
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PUSH
87171: LD_INT 1
87173: PUSH
87174: LD_INT 3
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 2
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 3
87194: NEG
87195: PUSH
87196: LD_INT 2
87198: NEG
87199: PUSH
87200: EMPTY
87201: LIST
87202: LIST
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87229: LD_ADDR_VAR 0 34
87233: PUSH
87234: LD_INT 0
87236: PUSH
87237: LD_INT 0
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 0
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 0
87277: PUSH
87278: LD_INT 1
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 1
87287: NEG
87288: PUSH
87289: LD_INT 0
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: NEG
87299: PUSH
87300: LD_INT 1
87302: NEG
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 1
87310: NEG
87311: PUSH
87312: LD_INT 2
87314: NEG
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: LD_INT 2
87325: NEG
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: PUSH
87334: LD_INT 1
87336: NEG
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: LD_INT 1
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 2
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 1
87364: PUSH
87365: LD_INT 2
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 1
87374: NEG
87375: PUSH
87376: LD_INT 1
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 2
87385: NEG
87386: PUSH
87387: LD_INT 0
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 2
87396: NEG
87397: PUSH
87398: LD_INT 1
87400: NEG
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 2
87408: NEG
87409: PUSH
87410: LD_INT 2
87412: NEG
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: LD_INT 3
87424: NEG
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: PUSH
87433: LD_INT 2
87435: NEG
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 3
87443: PUSH
87444: LD_INT 2
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 2
87453: PUSH
87454: LD_INT 3
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 2
87463: NEG
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 3
87474: NEG
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87509: LD_ADDR_VAR 0 35
87513: PUSH
87514: LD_INT 0
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 0
87526: PUSH
87527: LD_INT 1
87529: NEG
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: PUSH
87535: LD_INT 1
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: PUSH
87548: LD_INT 1
87550: PUSH
87551: EMPTY
87552: LIST
87553: LIST
87554: PUSH
87555: LD_INT 0
87557: PUSH
87558: LD_INT 1
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 1
87567: NEG
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 1
87578: NEG
87579: PUSH
87580: LD_INT 1
87582: NEG
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 2
87590: PUSH
87591: LD_INT 1
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 2
87600: NEG
87601: PUSH
87602: LD_INT 1
87604: NEG
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87621: LD_ADDR_VAR 0 36
87625: PUSH
87626: LD_INT 0
87628: PUSH
87629: LD_INT 0
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: LD_INT 1
87641: NEG
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 1
87649: PUSH
87650: LD_INT 0
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: LD_INT 1
87659: PUSH
87660: LD_INT 1
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 0
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: EMPTY
87674: LIST
87675: LIST
87676: PUSH
87677: LD_INT 1
87679: NEG
87680: PUSH
87681: LD_INT 0
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 1
87690: NEG
87691: PUSH
87692: LD_INT 1
87694: NEG
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 1
87702: NEG
87703: PUSH
87704: LD_INT 2
87706: NEG
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 1
87714: PUSH
87715: LD_INT 2
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87733: LD_ADDR_VAR 0 37
87737: PUSH
87738: LD_INT 0
87740: PUSH
87741: LD_INT 0
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 0
87750: PUSH
87751: LD_INT 1
87753: NEG
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 1
87761: PUSH
87762: LD_INT 0
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 1
87771: PUSH
87772: LD_INT 1
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 1
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 1
87791: NEG
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: NEG
87803: PUSH
87804: LD_INT 1
87806: NEG
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 1
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: LD_INT 1
87829: PUSH
87830: EMPTY
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: LIST
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87845: LD_ADDR_VAR 0 38
87849: PUSH
87850: LD_INT 0
87852: PUSH
87853: LD_INT 0
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 0
87862: PUSH
87863: LD_INT 1
87865: NEG
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: PUSH
87874: LD_INT 0
87876: PUSH
87877: EMPTY
87878: LIST
87879: LIST
87880: PUSH
87881: LD_INT 1
87883: PUSH
87884: LD_INT 1
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 0
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: LD_INT 1
87903: NEG
87904: PUSH
87905: LD_INT 0
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 1
87914: NEG
87915: PUSH
87916: LD_INT 1
87918: NEG
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: PUSH
87924: LD_INT 2
87926: PUSH
87927: LD_INT 1
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 2
87936: NEG
87937: PUSH
87938: LD_INT 1
87940: NEG
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: LIST
87950: LIST
87951: LIST
87952: LIST
87953: LIST
87954: LIST
87955: LIST
87956: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87957: LD_ADDR_VAR 0 39
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: LD_INT 1
87977: NEG
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: PUSH
87983: LD_INT 1
87985: PUSH
87986: LD_INT 0
87988: PUSH
87989: EMPTY
87990: LIST
87991: LIST
87992: PUSH
87993: LD_INT 1
87995: PUSH
87996: LD_INT 1
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 0
88005: PUSH
88006: LD_INT 1
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 1
88015: NEG
88016: PUSH
88017: LD_INT 0
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: LD_INT 1
88030: NEG
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PUSH
88036: LD_INT 1
88038: NEG
88039: PUSH
88040: LD_INT 2
88042: NEG
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: PUSH
88048: LD_INT 1
88050: PUSH
88051: LD_INT 2
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
88069: LD_ADDR_VAR 0 40
88073: PUSH
88074: LD_INT 0
88076: PUSH
88077: LD_INT 0
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 0
88086: PUSH
88087: LD_INT 1
88089: NEG
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 1
88097: PUSH
88098: LD_INT 0
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: PUSH
88108: LD_INT 1
88110: PUSH
88111: EMPTY
88112: LIST
88113: LIST
88114: PUSH
88115: LD_INT 0
88117: PUSH
88118: LD_INT 1
88120: PUSH
88121: EMPTY
88122: LIST
88123: LIST
88124: PUSH
88125: LD_INT 1
88127: NEG
88128: PUSH
88129: LD_INT 0
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 1
88138: NEG
88139: PUSH
88140: LD_INT 1
88142: NEG
88143: PUSH
88144: EMPTY
88145: LIST
88146: LIST
88147: PUSH
88148: LD_INT 1
88150: PUSH
88151: LD_INT 1
88153: NEG
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 1
88161: NEG
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88181: LD_ADDR_VAR 0 41
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PUSH
88196: LD_INT 0
88198: PUSH
88199: LD_INT 1
88201: NEG
88202: PUSH
88203: EMPTY
88204: LIST
88205: LIST
88206: PUSH
88207: LD_INT 1
88209: PUSH
88210: LD_INT 0
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 1
88219: PUSH
88220: LD_INT 1
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 0
88229: PUSH
88230: LD_INT 1
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 1
88239: NEG
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 1
88250: NEG
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 1
88262: NEG
88263: PUSH
88264: LD_INT 2
88266: NEG
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: LD_INT 1
88277: NEG
88278: PUSH
88279: EMPTY
88280: LIST
88281: LIST
88282: PUSH
88283: LD_INT 2
88285: PUSH
88286: LD_INT 0
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PUSH
88293: LD_INT 2
88295: PUSH
88296: LD_INT 1
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 2
88305: PUSH
88306: LD_INT 2
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 1
88315: PUSH
88316: LD_INT 2
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 1
88325: NEG
88326: PUSH
88327: LD_INT 1
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 2
88336: NEG
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: LD_INT 2
88347: NEG
88348: PUSH
88349: LD_INT 1
88351: NEG
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PUSH
88357: LD_INT 2
88359: NEG
88360: PUSH
88361: LD_INT 2
88363: NEG
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: PUSH
88369: LD_INT 2
88371: NEG
88372: PUSH
88373: LD_INT 3
88375: NEG
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 2
88383: PUSH
88384: LD_INT 1
88386: NEG
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PUSH
88392: LD_INT 3
88394: PUSH
88395: LD_INT 0
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: LD_INT 3
88404: PUSH
88405: LD_INT 1
88407: PUSH
88408: EMPTY
88409: LIST
88410: LIST
88411: PUSH
88412: LD_INT 3
88414: PUSH
88415: LD_INT 2
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: PUSH
88422: LD_INT 3
88424: PUSH
88425: LD_INT 3
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 2
88434: PUSH
88435: LD_INT 3
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 2
88444: NEG
88445: PUSH
88446: LD_INT 1
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 3
88455: NEG
88456: PUSH
88457: LD_INT 0
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: LD_INT 3
88466: NEG
88467: PUSH
88468: LD_INT 1
88470: NEG
88471: PUSH
88472: EMPTY
88473: LIST
88474: LIST
88475: PUSH
88476: LD_INT 3
88478: NEG
88479: PUSH
88480: LD_INT 2
88482: NEG
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 3
88490: NEG
88491: PUSH
88492: LD_INT 3
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: LIST
88528: LIST
88529: LIST
88530: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88531: LD_ADDR_VAR 0 42
88535: PUSH
88536: LD_INT 0
88538: PUSH
88539: LD_INT 0
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 0
88548: PUSH
88549: LD_INT 1
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 1
88559: PUSH
88560: LD_INT 0
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: PUSH
88567: LD_INT 1
88569: PUSH
88570: LD_INT 1
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 0
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 1
88589: NEG
88590: PUSH
88591: LD_INT 0
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PUSH
88598: LD_INT 1
88600: NEG
88601: PUSH
88602: LD_INT 1
88604: NEG
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 1
88612: NEG
88613: PUSH
88614: LD_INT 2
88616: NEG
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: LD_INT 2
88627: NEG
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: LD_INT 1
88638: NEG
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 2
88646: PUSH
88647: LD_INT 1
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 2
88656: PUSH
88657: LD_INT 2
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 1
88666: PUSH
88667: LD_INT 2
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 0
88676: PUSH
88677: LD_INT 2
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: NEG
88687: PUSH
88688: LD_INT 1
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 2
88697: NEG
88698: PUSH
88699: LD_INT 1
88701: NEG
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 2
88709: NEG
88710: PUSH
88711: LD_INT 2
88713: NEG
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 2
88721: NEG
88722: PUSH
88723: LD_INT 3
88725: NEG
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: PUSH
88731: LD_INT 1
88733: NEG
88734: PUSH
88735: LD_INT 3
88737: NEG
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 0
88745: PUSH
88746: LD_INT 3
88748: NEG
88749: PUSH
88750: EMPTY
88751: LIST
88752: LIST
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: LD_INT 2
88759: NEG
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 3
88767: PUSH
88768: LD_INT 2
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 3
88777: PUSH
88778: LD_INT 3
88780: PUSH
88781: EMPTY
88782: LIST
88783: LIST
88784: PUSH
88785: LD_INT 2
88787: PUSH
88788: LD_INT 3
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: PUSH
88795: LD_INT 1
88797: PUSH
88798: LD_INT 3
88800: PUSH
88801: EMPTY
88802: LIST
88803: LIST
88804: PUSH
88805: LD_INT 0
88807: PUSH
88808: LD_INT 3
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: LD_INT 2
88821: PUSH
88822: EMPTY
88823: LIST
88824: LIST
88825: PUSH
88826: LD_INT 3
88828: NEG
88829: PUSH
88830: LD_INT 2
88832: NEG
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 3
88840: NEG
88841: PUSH
88842: LD_INT 3
88844: NEG
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: LIST
88860: LIST
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88881: LD_ADDR_VAR 0 43
88885: PUSH
88886: LD_INT 0
88888: PUSH
88889: LD_INT 0
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: PUSH
88896: LD_INT 0
88898: PUSH
88899: LD_INT 1
88901: NEG
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 1
88909: PUSH
88910: LD_INT 0
88912: PUSH
88913: EMPTY
88914: LIST
88915: LIST
88916: PUSH
88917: LD_INT 1
88919: PUSH
88920: LD_INT 1
88922: PUSH
88923: EMPTY
88924: LIST
88925: LIST
88926: PUSH
88927: LD_INT 0
88929: PUSH
88930: LD_INT 1
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: LD_INT 1
88939: NEG
88940: PUSH
88941: LD_INT 0
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 1
88950: NEG
88951: PUSH
88952: LD_INT 1
88954: NEG
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 1
88962: NEG
88963: PUSH
88964: LD_INT 2
88966: NEG
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 0
88974: PUSH
88975: LD_INT 2
88977: NEG
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: PUSH
88986: LD_INT 1
88988: NEG
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 2
88996: PUSH
88997: LD_INT 0
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 2
89006: PUSH
89007: LD_INT 1
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 1
89016: PUSH
89017: LD_INT 2
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 0
89026: PUSH
89027: LD_INT 2
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 1
89036: NEG
89037: PUSH
89038: LD_INT 1
89040: PUSH
89041: EMPTY
89042: LIST
89043: LIST
89044: PUSH
89045: LD_INT 2
89047: NEG
89048: PUSH
89049: LD_INT 0
89051: PUSH
89052: EMPTY
89053: LIST
89054: LIST
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 1
89070: NEG
89071: PUSH
89072: LD_INT 3
89074: NEG
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PUSH
89080: LD_INT 0
89082: PUSH
89083: LD_INT 3
89085: NEG
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: PUSH
89091: LD_INT 1
89093: PUSH
89094: LD_INT 2
89096: NEG
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: PUSH
89102: LD_INT 2
89104: PUSH
89105: LD_INT 1
89107: NEG
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 3
89115: PUSH
89116: LD_INT 0
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 3
89125: PUSH
89126: LD_INT 1
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 1
89135: PUSH
89136: LD_INT 3
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: PUSH
89143: LD_INT 0
89145: PUSH
89146: LD_INT 3
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 1
89155: NEG
89156: PUSH
89157: LD_INT 2
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 2
89166: NEG
89167: PUSH
89168: LD_INT 1
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 3
89177: NEG
89178: PUSH
89179: LD_INT 0
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: PUSH
89186: LD_INT 3
89188: NEG
89189: PUSH
89190: LD_INT 1
89192: NEG
89193: PUSH
89194: EMPTY
89195: LIST
89196: LIST
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: LIST
89220: LIST
89221: LIST
89222: LIST
89223: LIST
89224: LIST
89225: LIST
89226: LIST
89227: LIST
89228: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89229: LD_ADDR_VAR 0 44
89233: PUSH
89234: LD_INT 0
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PUSH
89244: LD_INT 0
89246: PUSH
89247: LD_INT 1
89249: NEG
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 1
89257: PUSH
89258: LD_INT 0
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 1
89267: PUSH
89268: LD_INT 1
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: LD_INT 1
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 1
89287: NEG
89288: PUSH
89289: LD_INT 0
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 1
89298: NEG
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: EMPTY
89305: LIST
89306: LIST
89307: PUSH
89308: LD_INT 1
89310: NEG
89311: PUSH
89312: LD_INT 2
89314: NEG
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 2
89333: PUSH
89334: LD_INT 0
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: PUSH
89341: LD_INT 2
89343: PUSH
89344: LD_INT 1
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 2
89353: PUSH
89354: LD_INT 2
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 1
89363: PUSH
89364: LD_INT 2
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 1
89373: NEG
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 2
89384: NEG
89385: PUSH
89386: LD_INT 0
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 2
89395: NEG
89396: PUSH
89397: LD_INT 1
89399: NEG
89400: PUSH
89401: EMPTY
89402: LIST
89403: LIST
89404: PUSH
89405: LD_INT 2
89407: NEG
89408: PUSH
89409: LD_INT 2
89411: NEG
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: LD_INT 2
89419: NEG
89420: PUSH
89421: LD_INT 3
89423: NEG
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 2
89431: PUSH
89432: LD_INT 1
89434: NEG
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 3
89442: PUSH
89443: LD_INT 0
89445: PUSH
89446: EMPTY
89447: LIST
89448: LIST
89449: PUSH
89450: LD_INT 3
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 3
89462: PUSH
89463: LD_INT 2
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 3
89472: PUSH
89473: LD_INT 3
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 2
89482: PUSH
89483: LD_INT 3
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 2
89492: NEG
89493: PUSH
89494: LD_INT 1
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 3
89503: NEG
89504: PUSH
89505: LD_INT 0
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 3
89514: NEG
89515: PUSH
89516: LD_INT 1
89518: NEG
89519: PUSH
89520: EMPTY
89521: LIST
89522: LIST
89523: PUSH
89524: LD_INT 3
89526: NEG
89527: PUSH
89528: LD_INT 2
89530: NEG
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 3
89538: NEG
89539: PUSH
89540: LD_INT 3
89542: NEG
89543: PUSH
89544: EMPTY
89545: LIST
89546: LIST
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89579: LD_ADDR_VAR 0 45
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: LD_INT 0
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PUSH
89594: LD_INT 0
89596: PUSH
89597: LD_INT 1
89599: NEG
89600: PUSH
89601: EMPTY
89602: LIST
89603: LIST
89604: PUSH
89605: LD_INT 1
89607: PUSH
89608: LD_INT 0
89610: PUSH
89611: EMPTY
89612: LIST
89613: LIST
89614: PUSH
89615: LD_INT 1
89617: PUSH
89618: LD_INT 1
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: LD_INT 1
89630: PUSH
89631: EMPTY
89632: LIST
89633: LIST
89634: PUSH
89635: LD_INT 1
89637: NEG
89638: PUSH
89639: LD_INT 0
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: NEG
89649: PUSH
89650: LD_INT 1
89652: NEG
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: LD_INT 1
89660: NEG
89661: PUSH
89662: LD_INT 2
89664: NEG
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 0
89672: PUSH
89673: LD_INT 2
89675: NEG
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PUSH
89681: LD_INT 1
89683: PUSH
89684: LD_INT 1
89686: NEG
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: LD_INT 2
89694: PUSH
89695: LD_INT 1
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: PUSH
89702: LD_INT 2
89704: PUSH
89705: LD_INT 2
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 1
89714: PUSH
89715: LD_INT 2
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: LD_INT 2
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 1
89734: NEG
89735: PUSH
89736: LD_INT 1
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 2
89745: NEG
89746: PUSH
89747: LD_INT 1
89749: NEG
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 2
89757: NEG
89758: PUSH
89759: LD_INT 2
89761: NEG
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: PUSH
89767: LD_INT 2
89769: NEG
89770: PUSH
89771: LD_INT 3
89773: NEG
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: PUSH
89779: LD_INT 1
89781: NEG
89782: PUSH
89783: LD_INT 3
89785: NEG
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 0
89793: PUSH
89794: LD_INT 3
89796: NEG
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: PUSH
89802: LD_INT 1
89804: PUSH
89805: LD_INT 2
89807: NEG
89808: PUSH
89809: EMPTY
89810: LIST
89811: LIST
89812: PUSH
89813: LD_INT 3
89815: PUSH
89816: LD_INT 2
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: PUSH
89823: LD_INT 3
89825: PUSH
89826: LD_INT 3
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 2
89835: PUSH
89836: LD_INT 3
89838: PUSH
89839: EMPTY
89840: LIST
89841: LIST
89842: PUSH
89843: LD_INT 1
89845: PUSH
89846: LD_INT 3
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: PUSH
89853: LD_INT 0
89855: PUSH
89856: LD_INT 3
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 3
89876: NEG
89877: PUSH
89878: LD_INT 2
89880: NEG
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PUSH
89886: LD_INT 3
89888: NEG
89889: PUSH
89890: LD_INT 3
89892: NEG
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89929: LD_ADDR_VAR 0 46
89933: PUSH
89934: LD_INT 0
89936: PUSH
89937: LD_INT 0
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 0
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 1
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 1
89967: PUSH
89968: LD_INT 1
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 0
89977: PUSH
89978: LD_INT 1
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 1
89987: NEG
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: EMPTY
89993: LIST
89994: LIST
89995: PUSH
89996: LD_INT 1
89998: NEG
89999: PUSH
90000: LD_INT 1
90002: NEG
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 1
90010: NEG
90011: PUSH
90012: LD_INT 2
90014: NEG
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 0
90022: PUSH
90023: LD_INT 2
90025: NEG
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: LD_INT 1
90033: PUSH
90034: LD_INT 1
90036: NEG
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: PUSH
90042: LD_INT 2
90044: PUSH
90045: LD_INT 0
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 2
90054: PUSH
90055: LD_INT 1
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: LD_INT 2
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 0
90074: PUSH
90075: LD_INT 2
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 1
90084: NEG
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 2
90095: NEG
90096: PUSH
90097: LD_INT 0
90099: PUSH
90100: EMPTY
90101: LIST
90102: LIST
90103: PUSH
90104: LD_INT 2
90106: NEG
90107: PUSH
90108: LD_INT 1
90110: NEG
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: PUSH
90116: LD_INT 1
90118: NEG
90119: PUSH
90120: LD_INT 3
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 0
90130: PUSH
90131: LD_INT 3
90133: NEG
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 1
90141: PUSH
90142: LD_INT 2
90144: NEG
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 2
90152: PUSH
90153: LD_INT 1
90155: NEG
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 3
90163: PUSH
90164: LD_INT 0
90166: PUSH
90167: EMPTY
90168: LIST
90169: LIST
90170: PUSH
90171: LD_INT 3
90173: PUSH
90174: LD_INT 1
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 1
90183: PUSH
90184: LD_INT 3
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 0
90193: PUSH
90194: LD_INT 3
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 1
90203: NEG
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 2
90214: NEG
90215: PUSH
90216: LD_INT 1
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 3
90225: NEG
90226: PUSH
90227: LD_INT 0
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 3
90236: NEG
90237: PUSH
90238: LD_INT 1
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90277: LD_ADDR_VAR 0 47
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 0
90294: PUSH
90295: LD_INT 1
90297: NEG
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 1
90305: PUSH
90306: LD_INT 0
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 1
90315: PUSH
90316: LD_INT 1
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: LD_INT 1
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 1
90335: NEG
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 1
90346: NEG
90347: PUSH
90348: LD_INT 1
90350: NEG
90351: PUSH
90352: EMPTY
90353: LIST
90354: LIST
90355: PUSH
90356: LD_INT 1
90358: NEG
90359: PUSH
90360: LD_INT 2
90362: NEG
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: LD_INT 0
90370: PUSH
90371: LD_INT 2
90373: NEG
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: LD_INT 1
90381: PUSH
90382: LD_INT 1
90384: NEG
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 2
90392: NEG
90393: PUSH
90394: LD_INT 1
90396: NEG
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 2
90404: NEG
90405: PUSH
90406: LD_INT 2
90408: NEG
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
90428: LD_ADDR_VAR 0 48
90432: PUSH
90433: LD_INT 0
90435: PUSH
90436: LD_INT 0
90438: PUSH
90439: EMPTY
90440: LIST
90441: LIST
90442: PUSH
90443: LD_INT 0
90445: PUSH
90446: LD_INT 1
90448: NEG
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: EMPTY
90461: LIST
90462: LIST
90463: PUSH
90464: LD_INT 1
90466: PUSH
90467: LD_INT 1
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PUSH
90474: LD_INT 0
90476: PUSH
90477: LD_INT 1
90479: PUSH
90480: EMPTY
90481: LIST
90482: LIST
90483: PUSH
90484: LD_INT 1
90486: NEG
90487: PUSH
90488: LD_INT 0
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: PUSH
90495: LD_INT 1
90497: NEG
90498: PUSH
90499: LD_INT 1
90501: NEG
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: PUSH
90511: LD_INT 2
90513: NEG
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 0
90521: PUSH
90522: LD_INT 2
90524: NEG
90525: PUSH
90526: EMPTY
90527: LIST
90528: LIST
90529: PUSH
90530: LD_INT 1
90532: PUSH
90533: LD_INT 1
90535: NEG
90536: PUSH
90537: EMPTY
90538: LIST
90539: LIST
90540: PUSH
90541: LD_INT 2
90543: PUSH
90544: LD_INT 0
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: LD_INT 2
90553: PUSH
90554: LD_INT 1
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: LIST
90570: LIST
90571: LIST
90572: LIST
90573: LIST
90574: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
90575: LD_ADDR_VAR 0 49
90579: PUSH
90580: LD_INT 0
90582: PUSH
90583: LD_INT 0
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PUSH
90590: LD_INT 0
90592: PUSH
90593: LD_INT 1
90595: NEG
90596: PUSH
90597: EMPTY
90598: LIST
90599: LIST
90600: PUSH
90601: LD_INT 1
90603: PUSH
90604: LD_INT 0
90606: PUSH
90607: EMPTY
90608: LIST
90609: LIST
90610: PUSH
90611: LD_INT 1
90613: PUSH
90614: LD_INT 1
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: PUSH
90621: LD_INT 0
90623: PUSH
90624: LD_INT 1
90626: PUSH
90627: EMPTY
90628: LIST
90629: LIST
90630: PUSH
90631: LD_INT 1
90633: NEG
90634: PUSH
90635: LD_INT 0
90637: PUSH
90638: EMPTY
90639: LIST
90640: LIST
90641: PUSH
90642: LD_INT 1
90644: NEG
90645: PUSH
90646: LD_INT 1
90648: NEG
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: LD_INT 1
90659: NEG
90660: PUSH
90661: EMPTY
90662: LIST
90663: LIST
90664: PUSH
90665: LD_INT 2
90667: PUSH
90668: LD_INT 0
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 2
90677: PUSH
90678: LD_INT 1
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 2
90687: PUSH
90688: LD_INT 2
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 1
90697: PUSH
90698: LD_INT 2
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
90719: LD_ADDR_VAR 0 50
90723: PUSH
90724: LD_INT 0
90726: PUSH
90727: LD_INT 0
90729: PUSH
90730: EMPTY
90731: LIST
90732: LIST
90733: PUSH
90734: LD_INT 0
90736: PUSH
90737: LD_INT 1
90739: NEG
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 1
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: LD_INT 1
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: LD_INT 1
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: PUSH
90775: LD_INT 1
90777: NEG
90778: PUSH
90779: LD_INT 0
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 1
90788: NEG
90789: PUSH
90790: LD_INT 1
90792: NEG
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 2
90800: PUSH
90801: LD_INT 1
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 2
90810: PUSH
90811: LD_INT 2
90813: PUSH
90814: EMPTY
90815: LIST
90816: LIST
90817: PUSH
90818: LD_INT 1
90820: PUSH
90821: LD_INT 2
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PUSH
90828: LD_INT 0
90830: PUSH
90831: LD_INT 2
90833: PUSH
90834: EMPTY
90835: LIST
90836: LIST
90837: PUSH
90838: LD_INT 1
90840: NEG
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90863: LD_ADDR_VAR 0 51
90867: PUSH
90868: LD_INT 0
90870: PUSH
90871: LD_INT 0
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: LD_INT 0
90880: PUSH
90881: LD_INT 1
90883: NEG
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 1
90891: PUSH
90892: LD_INT 0
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 1
90901: PUSH
90902: LD_INT 1
90904: PUSH
90905: EMPTY
90906: LIST
90907: LIST
90908: PUSH
90909: LD_INT 0
90911: PUSH
90912: LD_INT 1
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: PUSH
90919: LD_INT 1
90921: NEG
90922: PUSH
90923: LD_INT 0
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: PUSH
90930: LD_INT 1
90932: NEG
90933: PUSH
90934: LD_INT 1
90936: NEG
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 1
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: LD_INT 2
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 1
90964: NEG
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 2
90975: NEG
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 2
90986: NEG
90987: PUSH
90988: LD_INT 1
90990: NEG
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91010: LD_ADDR_VAR 0 52
91014: PUSH
91015: LD_INT 0
91017: PUSH
91018: LD_INT 0
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 0
91027: PUSH
91028: LD_INT 1
91030: NEG
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 1
91038: PUSH
91039: LD_INT 0
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 1
91048: PUSH
91049: LD_INT 1
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 0
91058: PUSH
91059: LD_INT 1
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 1
91068: NEG
91069: PUSH
91070: LD_INT 0
91072: PUSH
91073: EMPTY
91074: LIST
91075: LIST
91076: PUSH
91077: LD_INT 1
91079: NEG
91080: PUSH
91081: LD_INT 1
91083: NEG
91084: PUSH
91085: EMPTY
91086: LIST
91087: LIST
91088: PUSH
91089: LD_INT 1
91091: NEG
91092: PUSH
91093: LD_INT 2
91095: NEG
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 1
91103: NEG
91104: PUSH
91105: LD_INT 1
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 2
91114: NEG
91115: PUSH
91116: LD_INT 0
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 2
91125: NEG
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 2
91137: NEG
91138: PUSH
91139: LD_INT 2
91141: NEG
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: LIST
91160: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91161: LD_ADDR_VAR 0 53
91165: PUSH
91166: LD_INT 0
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 0
91178: PUSH
91179: LD_INT 1
91181: NEG
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 1
91189: PUSH
91190: LD_INT 0
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: PUSH
91197: LD_INT 1
91199: PUSH
91200: LD_INT 1
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 0
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: LD_INT 1
91219: NEG
91220: PUSH
91221: LD_INT 0
91223: PUSH
91224: EMPTY
91225: LIST
91226: LIST
91227: PUSH
91228: LD_INT 1
91230: NEG
91231: PUSH
91232: LD_INT 1
91234: NEG
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: NEG
91243: PUSH
91244: LD_INT 2
91246: NEG
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: LD_INT 0
91254: PUSH
91255: LD_INT 2
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 1
91265: PUSH
91266: LD_INT 1
91268: NEG
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 2
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 2
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: LD_INT 2
91296: PUSH
91297: LD_INT 2
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 1
91306: PUSH
91307: LD_INT 2
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: LD_INT 2
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 1
91326: NEG
91327: PUSH
91328: LD_INT 1
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 2
91337: NEG
91338: PUSH
91339: LD_INT 0
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 2
91348: NEG
91349: PUSH
91350: LD_INT 1
91352: NEG
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 2
91360: NEG
91361: PUSH
91362: LD_INT 2
91364: NEG
91365: PUSH
91366: EMPTY
91367: LIST
91368: LIST
91369: PUSH
91370: EMPTY
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91391: LD_ADDR_VAR 0 54
91395: PUSH
91396: LD_INT 0
91398: PUSH
91399: LD_INT 0
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 0
91408: PUSH
91409: LD_INT 1
91411: NEG
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: LD_INT 0
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: LD_INT 1
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 0
91439: PUSH
91440: LD_INT 1
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 1
91449: NEG
91450: PUSH
91451: LD_INT 0
91453: PUSH
91454: EMPTY
91455: LIST
91456: LIST
91457: PUSH
91458: LD_INT 1
91460: NEG
91461: PUSH
91462: LD_INT 1
91464: NEG
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: LD_INT 1
91472: NEG
91473: PUSH
91474: LD_INT 2
91476: NEG
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 0
91484: PUSH
91485: LD_INT 2
91487: NEG
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: LD_INT 1
91498: NEG
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 2
91506: PUSH
91507: LD_INT 0
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 2
91516: PUSH
91517: LD_INT 1
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 2
91526: PUSH
91527: LD_INT 2
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PUSH
91534: LD_INT 1
91536: PUSH
91537: LD_INT 2
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PUSH
91544: LD_INT 0
91546: PUSH
91547: LD_INT 2
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 1
91556: NEG
91557: PUSH
91558: LD_INT 1
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: PUSH
91565: LD_INT 2
91567: NEG
91568: PUSH
91569: LD_INT 0
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: LD_INT 1
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 2
91590: NEG
91591: PUSH
91592: LD_INT 2
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91621: LD_ADDR_VAR 0 55
91625: PUSH
91626: LD_INT 0
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 0
91638: PUSH
91639: LD_INT 1
91641: NEG
91642: PUSH
91643: EMPTY
91644: LIST
91645: LIST
91646: PUSH
91647: LD_INT 1
91649: PUSH
91650: LD_INT 0
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: PUSH
91657: LD_INT 1
91659: PUSH
91660: LD_INT 1
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PUSH
91667: LD_INT 0
91669: PUSH
91670: LD_INT 1
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: LD_INT 0
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 1
91690: NEG
91691: PUSH
91692: LD_INT 1
91694: NEG
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PUSH
91700: LD_INT 1
91702: NEG
91703: PUSH
91704: LD_INT 2
91706: NEG
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: LD_INT 0
91714: PUSH
91715: LD_INT 2
91717: NEG
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PUSH
91723: LD_INT 1
91725: PUSH
91726: LD_INT 1
91728: NEG
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 2
91736: PUSH
91737: LD_INT 0
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 2
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 2
91756: PUSH
91757: LD_INT 2
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: PUSH
91764: LD_INT 1
91766: PUSH
91767: LD_INT 2
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: LD_INT 0
91776: PUSH
91777: LD_INT 2
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 1
91786: NEG
91787: PUSH
91788: LD_INT 1
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 2
91797: NEG
91798: PUSH
91799: LD_INT 0
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 2
91808: NEG
91809: PUSH
91810: LD_INT 1
91812: NEG
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 2
91820: NEG
91821: PUSH
91822: LD_INT 2
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: LIST
91839: LIST
91840: LIST
91841: LIST
91842: LIST
91843: LIST
91844: LIST
91845: LIST
91846: LIST
91847: LIST
91848: LIST
91849: LIST
91850: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91851: LD_ADDR_VAR 0 56
91855: PUSH
91856: LD_INT 0
91858: PUSH
91859: LD_INT 0
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: LD_INT 1
91871: NEG
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 1
91879: PUSH
91880: LD_INT 0
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 1
91889: PUSH
91890: LD_INT 1
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: LD_INT 0
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 1
91920: NEG
91921: PUSH
91922: LD_INT 1
91924: NEG
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 1
91932: NEG
91933: PUSH
91934: LD_INT 2
91936: NEG
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 0
91944: PUSH
91945: LD_INT 2
91947: NEG
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 1
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 2
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: LD_INT 1
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: LD_INT 2
91986: PUSH
91987: LD_INT 2
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 1
91996: PUSH
91997: LD_INT 2
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 0
92006: PUSH
92007: LD_INT 2
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 1
92016: NEG
92017: PUSH
92018: LD_INT 1
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: PUSH
92025: LD_INT 2
92027: NEG
92028: PUSH
92029: LD_INT 0
92031: PUSH
92032: EMPTY
92033: LIST
92034: LIST
92035: PUSH
92036: LD_INT 2
92038: NEG
92039: PUSH
92040: LD_INT 1
92042: NEG
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: PUSH
92048: LD_INT 2
92050: NEG
92051: PUSH
92052: LD_INT 2
92054: NEG
92055: PUSH
92056: EMPTY
92057: LIST
92058: LIST
92059: PUSH
92060: EMPTY
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92081: LD_ADDR_VAR 0 57
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 0
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 1
92101: NEG
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 1
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 1
92119: PUSH
92120: LD_INT 1
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 0
92129: PUSH
92130: LD_INT 1
92132: PUSH
92133: EMPTY
92134: LIST
92135: LIST
92136: PUSH
92137: LD_INT 1
92139: NEG
92140: PUSH
92141: LD_INT 0
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 1
92150: NEG
92151: PUSH
92152: LD_INT 1
92154: NEG
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: PUSH
92160: LD_INT 1
92162: NEG
92163: PUSH
92164: LD_INT 2
92166: NEG
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 0
92174: PUSH
92175: LD_INT 2
92177: NEG
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: PUSH
92183: LD_INT 1
92185: PUSH
92186: LD_INT 1
92188: NEG
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 2
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 2
92206: PUSH
92207: LD_INT 1
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 2
92216: PUSH
92217: LD_INT 2
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 1
92226: PUSH
92227: LD_INT 2
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 0
92236: PUSH
92237: LD_INT 2
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: PUSH
92244: LD_INT 1
92246: NEG
92247: PUSH
92248: LD_INT 1
92250: PUSH
92251: EMPTY
92252: LIST
92253: LIST
92254: PUSH
92255: LD_INT 2
92257: NEG
92258: PUSH
92259: LD_INT 0
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 2
92268: NEG
92269: PUSH
92270: LD_INT 1
92272: NEG
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 2
92280: NEG
92281: PUSH
92282: LD_INT 2
92284: NEG
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92311: LD_ADDR_VAR 0 58
92315: PUSH
92316: LD_INT 0
92318: PUSH
92319: LD_INT 0
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 0
92328: PUSH
92329: LD_INT 1
92331: NEG
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 1
92339: PUSH
92340: LD_INT 0
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 1
92349: PUSH
92350: LD_INT 1
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: LD_INT 0
92359: PUSH
92360: LD_INT 1
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 1
92369: NEG
92370: PUSH
92371: LD_INT 0
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: PUSH
92378: LD_INT 1
92380: NEG
92381: PUSH
92382: LD_INT 1
92384: NEG
92385: PUSH
92386: EMPTY
92387: LIST
92388: LIST
92389: PUSH
92390: LD_INT 1
92392: NEG
92393: PUSH
92394: LD_INT 2
92396: NEG
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: LD_INT 0
92404: PUSH
92405: LD_INT 2
92407: NEG
92408: PUSH
92409: EMPTY
92410: LIST
92411: LIST
92412: PUSH
92413: LD_INT 1
92415: PUSH
92416: LD_INT 1
92418: NEG
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 2
92426: PUSH
92427: LD_INT 0
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 2
92436: PUSH
92437: LD_INT 1
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 2
92446: PUSH
92447: LD_INT 2
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: PUSH
92457: LD_INT 2
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: LD_INT 2
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 1
92476: NEG
92477: PUSH
92478: LD_INT 1
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 2
92487: NEG
92488: PUSH
92489: LD_INT 0
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 2
92498: NEG
92499: PUSH
92500: LD_INT 1
92502: NEG
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: PUSH
92508: LD_INT 2
92510: NEG
92511: PUSH
92512: LD_INT 2
92514: NEG
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92541: LD_ADDR_VAR 0 59
92545: PUSH
92546: LD_INT 0
92548: PUSH
92549: LD_INT 0
92551: PUSH
92552: EMPTY
92553: LIST
92554: LIST
92555: PUSH
92556: LD_INT 0
92558: PUSH
92559: LD_INT 1
92561: NEG
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: PUSH
92567: LD_INT 1
92569: PUSH
92570: LD_INT 0
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: LD_INT 1
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 0
92589: PUSH
92590: LD_INT 1
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 1
92599: NEG
92600: PUSH
92601: LD_INT 0
92603: PUSH
92604: EMPTY
92605: LIST
92606: LIST
92607: PUSH
92608: LD_INT 1
92610: NEG
92611: PUSH
92612: LD_INT 1
92614: NEG
92615: PUSH
92616: EMPTY
92617: LIST
92618: LIST
92619: PUSH
92620: EMPTY
92621: LIST
92622: LIST
92623: LIST
92624: LIST
92625: LIST
92626: LIST
92627: LIST
92628: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92629: LD_ADDR_VAR 0 60
92633: PUSH
92634: LD_INT 0
92636: PUSH
92637: LD_INT 0
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: PUSH
92644: LD_INT 0
92646: PUSH
92647: LD_INT 1
92649: NEG
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 1
92657: PUSH
92658: LD_INT 0
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: PUSH
92668: LD_INT 1
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 0
92677: PUSH
92678: LD_INT 1
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PUSH
92685: LD_INT 1
92687: NEG
92688: PUSH
92689: LD_INT 0
92691: PUSH
92692: EMPTY
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 1
92698: NEG
92699: PUSH
92700: LD_INT 1
92702: NEG
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92717: LD_ADDR_VAR 0 61
92721: PUSH
92722: LD_INT 0
92724: PUSH
92725: LD_INT 0
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 0
92734: PUSH
92735: LD_INT 1
92737: NEG
92738: PUSH
92739: EMPTY
92740: LIST
92741: LIST
92742: PUSH
92743: LD_INT 1
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: EMPTY
92750: LIST
92751: LIST
92752: PUSH
92753: LD_INT 1
92755: PUSH
92756: LD_INT 1
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 0
92765: PUSH
92766: LD_INT 1
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: LD_INT 1
92775: NEG
92776: PUSH
92777: LD_INT 0
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 1
92786: NEG
92787: PUSH
92788: LD_INT 1
92790: NEG
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: EMPTY
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92805: LD_ADDR_VAR 0 62
92809: PUSH
92810: LD_INT 0
92812: PUSH
92813: LD_INT 0
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: LD_INT 0
92822: PUSH
92823: LD_INT 1
92825: NEG
92826: PUSH
92827: EMPTY
92828: LIST
92829: LIST
92830: PUSH
92831: LD_INT 1
92833: PUSH
92834: LD_INT 0
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 1
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: LD_INT 0
92853: PUSH
92854: LD_INT 1
92856: PUSH
92857: EMPTY
92858: LIST
92859: LIST
92860: PUSH
92861: LD_INT 1
92863: NEG
92864: PUSH
92865: LD_INT 0
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: PUSH
92872: LD_INT 1
92874: NEG
92875: PUSH
92876: LD_INT 1
92878: NEG
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92893: LD_ADDR_VAR 0 63
92897: PUSH
92898: LD_INT 0
92900: PUSH
92901: LD_INT 0
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 0
92910: PUSH
92911: LD_INT 1
92913: NEG
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 1
92921: PUSH
92922: LD_INT 0
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 1
92931: PUSH
92932: LD_INT 1
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: LD_INT 0
92941: PUSH
92942: LD_INT 1
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 1
92951: NEG
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: LD_INT 1
92962: NEG
92963: PUSH
92964: LD_INT 1
92966: NEG
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92981: LD_ADDR_VAR 0 64
92985: PUSH
92986: LD_INT 0
92988: PUSH
92989: LD_INT 0
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: PUSH
92996: LD_INT 0
92998: PUSH
92999: LD_INT 1
93001: NEG
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: PUSH
93007: LD_INT 1
93009: PUSH
93010: LD_INT 0
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 1
93019: PUSH
93020: LD_INT 1
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 0
93029: PUSH
93030: LD_INT 1
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 1
93039: NEG
93040: PUSH
93041: LD_INT 0
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 1
93050: NEG
93051: PUSH
93052: LD_INT 1
93054: NEG
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: ST_TO_ADDR
// end ; 1 :
93069: GO 98966
93071: LD_INT 1
93073: DOUBLE
93074: EQUAL
93075: IFTRUE 93079
93077: GO 95702
93079: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93080: LD_ADDR_VAR 0 11
93084: PUSH
93085: LD_INT 1
93087: NEG
93088: PUSH
93089: LD_INT 3
93091: NEG
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 0
93099: PUSH
93100: LD_INT 3
93102: NEG
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: LD_INT 1
93110: PUSH
93111: LD_INT 2
93113: NEG
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: EMPTY
93120: LIST
93121: LIST
93122: LIST
93123: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93124: LD_ADDR_VAR 0 12
93128: PUSH
93129: LD_INT 2
93131: PUSH
93132: LD_INT 1
93134: NEG
93135: PUSH
93136: EMPTY
93137: LIST
93138: LIST
93139: PUSH
93140: LD_INT 3
93142: PUSH
93143: LD_INT 0
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: PUSH
93150: LD_INT 3
93152: PUSH
93153: LD_INT 1
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: LIST
93164: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93165: LD_ADDR_VAR 0 13
93169: PUSH
93170: LD_INT 3
93172: PUSH
93173: LD_INT 2
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 3
93182: PUSH
93183: LD_INT 3
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 2
93192: PUSH
93193: LD_INT 3
93195: PUSH
93196: EMPTY
93197: LIST
93198: LIST
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: LIST
93204: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93205: LD_ADDR_VAR 0 14
93209: PUSH
93210: LD_INT 1
93212: PUSH
93213: LD_INT 3
93215: PUSH
93216: EMPTY
93217: LIST
93218: LIST
93219: PUSH
93220: LD_INT 0
93222: PUSH
93223: LD_INT 3
93225: PUSH
93226: EMPTY
93227: LIST
93228: LIST
93229: PUSH
93230: LD_INT 1
93232: NEG
93233: PUSH
93234: LD_INT 2
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: EMPTY
93242: LIST
93243: LIST
93244: LIST
93245: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93246: LD_ADDR_VAR 0 15
93250: PUSH
93251: LD_INT 2
93253: NEG
93254: PUSH
93255: LD_INT 1
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 3
93264: NEG
93265: PUSH
93266: LD_INT 0
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 3
93275: NEG
93276: PUSH
93277: LD_INT 1
93279: NEG
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: LIST
93289: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93290: LD_ADDR_VAR 0 16
93294: PUSH
93295: LD_INT 2
93297: NEG
93298: PUSH
93299: LD_INT 3
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 3
93309: NEG
93310: PUSH
93311: LD_INT 2
93313: NEG
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 3
93321: NEG
93322: PUSH
93323: LD_INT 3
93325: NEG
93326: PUSH
93327: EMPTY
93328: LIST
93329: LIST
93330: PUSH
93331: EMPTY
93332: LIST
93333: LIST
93334: LIST
93335: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93336: LD_ADDR_VAR 0 17
93340: PUSH
93341: LD_INT 1
93343: NEG
93344: PUSH
93345: LD_INT 3
93347: NEG
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 0
93355: PUSH
93356: LD_INT 3
93358: NEG
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: LD_INT 1
93366: PUSH
93367: LD_INT 2
93369: NEG
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: PUSH
93375: EMPTY
93376: LIST
93377: LIST
93378: LIST
93379: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93380: LD_ADDR_VAR 0 18
93384: PUSH
93385: LD_INT 2
93387: PUSH
93388: LD_INT 1
93390: NEG
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 3
93398: PUSH
93399: LD_INT 0
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: PUSH
93406: LD_INT 3
93408: PUSH
93409: LD_INT 1
93411: PUSH
93412: EMPTY
93413: LIST
93414: LIST
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: LIST
93420: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93421: LD_ADDR_VAR 0 19
93425: PUSH
93426: LD_INT 3
93428: PUSH
93429: LD_INT 2
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 3
93438: PUSH
93439: LD_INT 3
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: PUSH
93446: LD_INT 2
93448: PUSH
93449: LD_INT 3
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: EMPTY
93457: LIST
93458: LIST
93459: LIST
93460: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93461: LD_ADDR_VAR 0 20
93465: PUSH
93466: LD_INT 1
93468: PUSH
93469: LD_INT 3
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: PUSH
93476: LD_INT 0
93478: PUSH
93479: LD_INT 3
93481: PUSH
93482: EMPTY
93483: LIST
93484: LIST
93485: PUSH
93486: LD_INT 1
93488: NEG
93489: PUSH
93490: LD_INT 2
93492: PUSH
93493: EMPTY
93494: LIST
93495: LIST
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: LIST
93501: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93502: LD_ADDR_VAR 0 21
93506: PUSH
93507: LD_INT 2
93509: NEG
93510: PUSH
93511: LD_INT 1
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 3
93520: NEG
93521: PUSH
93522: LD_INT 0
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: LD_INT 3
93531: NEG
93532: PUSH
93533: LD_INT 1
93535: NEG
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: LIST
93545: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93546: LD_ADDR_VAR 0 22
93550: PUSH
93551: LD_INT 2
93553: NEG
93554: PUSH
93555: LD_INT 3
93557: NEG
93558: PUSH
93559: EMPTY
93560: LIST
93561: LIST
93562: PUSH
93563: LD_INT 3
93565: NEG
93566: PUSH
93567: LD_INT 2
93569: NEG
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: PUSH
93575: LD_INT 3
93577: NEG
93578: PUSH
93579: LD_INT 3
93581: NEG
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: EMPTY
93588: LIST
93589: LIST
93590: LIST
93591: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
93592: LD_ADDR_VAR 0 23
93596: PUSH
93597: LD_INT 0
93599: PUSH
93600: LD_INT 3
93602: NEG
93603: PUSH
93604: EMPTY
93605: LIST
93606: LIST
93607: PUSH
93608: LD_INT 1
93610: NEG
93611: PUSH
93612: LD_INT 4
93614: NEG
93615: PUSH
93616: EMPTY
93617: LIST
93618: LIST
93619: PUSH
93620: LD_INT 1
93622: PUSH
93623: LD_INT 3
93625: NEG
93626: PUSH
93627: EMPTY
93628: LIST
93629: LIST
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: LIST
93635: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
93636: LD_ADDR_VAR 0 24
93640: PUSH
93641: LD_INT 3
93643: PUSH
93644: LD_INT 0
93646: PUSH
93647: EMPTY
93648: LIST
93649: LIST
93650: PUSH
93651: LD_INT 3
93653: PUSH
93654: LD_INT 1
93656: NEG
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: PUSH
93662: LD_INT 4
93664: PUSH
93665: LD_INT 1
93667: PUSH
93668: EMPTY
93669: LIST
93670: LIST
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: LIST
93676: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
93677: LD_ADDR_VAR 0 25
93681: PUSH
93682: LD_INT 3
93684: PUSH
93685: LD_INT 3
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 4
93694: PUSH
93695: LD_INT 3
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PUSH
93702: LD_INT 3
93704: PUSH
93705: LD_INT 4
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: LIST
93716: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
93717: LD_ADDR_VAR 0 26
93721: PUSH
93722: LD_INT 0
93724: PUSH
93725: LD_INT 3
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 1
93734: PUSH
93735: LD_INT 4
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 1
93744: NEG
93745: PUSH
93746: LD_INT 3
93748: PUSH
93749: EMPTY
93750: LIST
93751: LIST
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: LIST
93757: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
93758: LD_ADDR_VAR 0 27
93762: PUSH
93763: LD_INT 3
93765: NEG
93766: PUSH
93767: LD_INT 0
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 3
93776: NEG
93777: PUSH
93778: LD_INT 1
93780: PUSH
93781: EMPTY
93782: LIST
93783: LIST
93784: PUSH
93785: LD_INT 4
93787: NEG
93788: PUSH
93789: LD_INT 1
93791: NEG
93792: PUSH
93793: EMPTY
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: LIST
93801: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
93802: LD_ADDR_VAR 0 28
93806: PUSH
93807: LD_INT 3
93809: NEG
93810: PUSH
93811: LD_INT 3
93813: NEG
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 3
93821: NEG
93822: PUSH
93823: LD_INT 4
93825: NEG
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 4
93833: NEG
93834: PUSH
93835: LD_INT 3
93837: NEG
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: LIST
93847: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93848: LD_ADDR_VAR 0 29
93852: PUSH
93853: LD_INT 1
93855: NEG
93856: PUSH
93857: LD_INT 3
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 0
93867: PUSH
93868: LD_INT 3
93870: NEG
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: LD_INT 1
93878: PUSH
93879: LD_INT 2
93881: NEG
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: LD_INT 1
93889: NEG
93890: PUSH
93891: LD_INT 4
93893: NEG
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 0
93901: PUSH
93902: LD_INT 4
93904: NEG
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: LD_INT 1
93912: PUSH
93913: LD_INT 3
93915: NEG
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 1
93923: NEG
93924: PUSH
93925: LD_INT 5
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 0
93935: PUSH
93936: LD_INT 5
93938: NEG
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PUSH
93944: LD_INT 1
93946: PUSH
93947: LD_INT 4
93949: NEG
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: PUSH
93955: LD_INT 1
93957: NEG
93958: PUSH
93959: LD_INT 6
93961: NEG
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 0
93969: PUSH
93970: LD_INT 6
93972: NEG
93973: PUSH
93974: EMPTY
93975: LIST
93976: LIST
93977: PUSH
93978: LD_INT 1
93980: PUSH
93981: LD_INT 5
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: EMPTY
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
94003: LD_ADDR_VAR 0 30
94007: PUSH
94008: LD_INT 2
94010: PUSH
94011: LD_INT 1
94013: NEG
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 3
94021: PUSH
94022: LD_INT 0
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 3
94031: PUSH
94032: LD_INT 1
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 3
94041: PUSH
94042: LD_INT 1
94044: NEG
94045: PUSH
94046: EMPTY
94047: LIST
94048: LIST
94049: PUSH
94050: LD_INT 4
94052: PUSH
94053: LD_INT 0
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: PUSH
94060: LD_INT 4
94062: PUSH
94063: LD_INT 1
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 4
94072: PUSH
94073: LD_INT 1
94075: NEG
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 5
94083: PUSH
94084: LD_INT 0
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 5
94093: PUSH
94094: LD_INT 1
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 5
94103: PUSH
94104: LD_INT 1
94106: NEG
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 6
94114: PUSH
94115: LD_INT 0
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 6
94124: PUSH
94125: LD_INT 1
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
94146: LD_ADDR_VAR 0 31
94150: PUSH
94151: LD_INT 3
94153: PUSH
94154: LD_INT 2
94156: PUSH
94157: EMPTY
94158: LIST
94159: LIST
94160: PUSH
94161: LD_INT 3
94163: PUSH
94164: LD_INT 3
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: PUSH
94174: LD_INT 3
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 4
94183: PUSH
94184: LD_INT 3
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: PUSH
94191: LD_INT 4
94193: PUSH
94194: LD_INT 4
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 3
94203: PUSH
94204: LD_INT 4
94206: PUSH
94207: EMPTY
94208: LIST
94209: LIST
94210: PUSH
94211: LD_INT 5
94213: PUSH
94214: LD_INT 4
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: PUSH
94221: LD_INT 5
94223: PUSH
94224: LD_INT 5
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 4
94233: PUSH
94234: LD_INT 5
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 6
94243: PUSH
94244: LD_INT 5
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 6
94253: PUSH
94254: LD_INT 6
94256: PUSH
94257: EMPTY
94258: LIST
94259: LIST
94260: PUSH
94261: LD_INT 5
94263: PUSH
94264: LD_INT 6
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: EMPTY
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
94285: LD_ADDR_VAR 0 32
94289: PUSH
94290: LD_INT 1
94292: PUSH
94293: LD_INT 3
94295: PUSH
94296: EMPTY
94297: LIST
94298: LIST
94299: PUSH
94300: LD_INT 0
94302: PUSH
94303: LD_INT 3
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 1
94312: NEG
94313: PUSH
94314: LD_INT 2
94316: PUSH
94317: EMPTY
94318: LIST
94319: LIST
94320: PUSH
94321: LD_INT 1
94323: PUSH
94324: LD_INT 4
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: PUSH
94331: LD_INT 0
94333: PUSH
94334: LD_INT 4
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 1
94343: NEG
94344: PUSH
94345: LD_INT 3
94347: PUSH
94348: EMPTY
94349: LIST
94350: LIST
94351: PUSH
94352: LD_INT 1
94354: PUSH
94355: LD_INT 5
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 0
94364: PUSH
94365: LD_INT 5
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 1
94374: NEG
94375: PUSH
94376: LD_INT 4
94378: PUSH
94379: EMPTY
94380: LIST
94381: LIST
94382: PUSH
94383: LD_INT 1
94385: PUSH
94386: LD_INT 6
94388: PUSH
94389: EMPTY
94390: LIST
94391: LIST
94392: PUSH
94393: LD_INT 0
94395: PUSH
94396: LD_INT 6
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: LD_INT 1
94405: NEG
94406: PUSH
94407: LD_INT 5
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
94428: LD_ADDR_VAR 0 33
94432: PUSH
94433: LD_INT 2
94435: NEG
94436: PUSH
94437: LD_INT 1
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 3
94446: NEG
94447: PUSH
94448: LD_INT 0
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 3
94457: NEG
94458: PUSH
94459: LD_INT 1
94461: NEG
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 3
94469: NEG
94470: PUSH
94471: LD_INT 1
94473: PUSH
94474: EMPTY
94475: LIST
94476: LIST
94477: PUSH
94478: LD_INT 4
94480: NEG
94481: PUSH
94482: LD_INT 0
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 4
94491: NEG
94492: PUSH
94493: LD_INT 1
94495: NEG
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PUSH
94501: LD_INT 4
94503: NEG
94504: PUSH
94505: LD_INT 1
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 5
94514: NEG
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 5
94525: NEG
94526: PUSH
94527: LD_INT 1
94529: NEG
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 5
94537: NEG
94538: PUSH
94539: LD_INT 1
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: PUSH
94546: LD_INT 6
94548: NEG
94549: PUSH
94550: LD_INT 0
94552: PUSH
94553: EMPTY
94554: LIST
94555: LIST
94556: PUSH
94557: LD_INT 6
94559: NEG
94560: PUSH
94561: LD_INT 1
94563: NEG
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
94583: LD_ADDR_VAR 0 34
94587: PUSH
94588: LD_INT 2
94590: NEG
94591: PUSH
94592: LD_INT 3
94594: NEG
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: PUSH
94600: LD_INT 3
94602: NEG
94603: PUSH
94604: LD_INT 2
94606: NEG
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 3
94614: NEG
94615: PUSH
94616: LD_INT 3
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: LD_INT 4
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 4
94638: NEG
94639: PUSH
94640: LD_INT 3
94642: NEG
94643: PUSH
94644: EMPTY
94645: LIST
94646: LIST
94647: PUSH
94648: LD_INT 4
94650: NEG
94651: PUSH
94652: LD_INT 4
94654: NEG
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 4
94662: NEG
94663: PUSH
94664: LD_INT 5
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 5
94674: NEG
94675: PUSH
94676: LD_INT 4
94678: NEG
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 5
94686: NEG
94687: PUSH
94688: LD_INT 5
94690: NEG
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: PUSH
94696: LD_INT 5
94698: NEG
94699: PUSH
94700: LD_INT 6
94702: NEG
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 6
94710: NEG
94711: PUSH
94712: LD_INT 5
94714: NEG
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: PUSH
94720: LD_INT 6
94722: NEG
94723: PUSH
94724: LD_INT 6
94726: NEG
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: LIST
94739: LIST
94740: LIST
94741: LIST
94742: LIST
94743: LIST
94744: LIST
94745: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
94746: LD_ADDR_VAR 0 41
94750: PUSH
94751: LD_INT 0
94753: PUSH
94754: LD_INT 2
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 1
94764: NEG
94765: PUSH
94766: LD_INT 3
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 1
94776: PUSH
94777: LD_INT 2
94779: NEG
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: PUSH
94785: EMPTY
94786: LIST
94787: LIST
94788: LIST
94789: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
94790: LD_ADDR_VAR 0 42
94794: PUSH
94795: LD_INT 2
94797: PUSH
94798: LD_INT 0
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: LD_INT 2
94807: PUSH
94808: LD_INT 1
94810: NEG
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 3
94818: PUSH
94819: LD_INT 1
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: LIST
94830: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94831: LD_ADDR_VAR 0 43
94835: PUSH
94836: LD_INT 2
94838: PUSH
94839: LD_INT 2
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 3
94848: PUSH
94849: LD_INT 2
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 2
94858: PUSH
94859: LD_INT 3
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: LIST
94870: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94871: LD_ADDR_VAR 0 44
94875: PUSH
94876: LD_INT 0
94878: PUSH
94879: LD_INT 2
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 1
94888: PUSH
94889: LD_INT 3
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 1
94898: NEG
94899: PUSH
94900: LD_INT 2
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: PUSH
94907: EMPTY
94908: LIST
94909: LIST
94910: LIST
94911: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94912: LD_ADDR_VAR 0 45
94916: PUSH
94917: LD_INT 2
94919: NEG
94920: PUSH
94921: LD_INT 0
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: PUSH
94928: LD_INT 2
94930: NEG
94931: PUSH
94932: LD_INT 1
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 3
94941: NEG
94942: PUSH
94943: LD_INT 1
94945: NEG
94946: PUSH
94947: EMPTY
94948: LIST
94949: LIST
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: LIST
94955: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94956: LD_ADDR_VAR 0 46
94960: PUSH
94961: LD_INT 2
94963: NEG
94964: PUSH
94965: LD_INT 2
94967: NEG
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 2
94975: NEG
94976: PUSH
94977: LD_INT 3
94979: NEG
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 3
94987: NEG
94988: PUSH
94989: LD_INT 2
94991: NEG
94992: PUSH
94993: EMPTY
94994: LIST
94995: LIST
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: LIST
95001: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
95002: LD_ADDR_VAR 0 47
95006: PUSH
95007: LD_INT 2
95009: NEG
95010: PUSH
95011: LD_INT 3
95013: NEG
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: PUSH
95019: LD_INT 1
95021: NEG
95022: PUSH
95023: LD_INT 3
95025: NEG
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: PUSH
95031: EMPTY
95032: LIST
95033: LIST
95034: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
95035: LD_ADDR_VAR 0 48
95039: PUSH
95040: LD_INT 1
95042: PUSH
95043: LD_INT 2
95045: NEG
95046: PUSH
95047: EMPTY
95048: LIST
95049: LIST
95050: PUSH
95051: LD_INT 2
95053: PUSH
95054: LD_INT 1
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
95066: LD_ADDR_VAR 0 49
95070: PUSH
95071: LD_INT 3
95073: PUSH
95074: LD_INT 1
95076: PUSH
95077: EMPTY
95078: LIST
95079: LIST
95080: PUSH
95081: LD_INT 3
95083: PUSH
95084: LD_INT 2
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
95095: LD_ADDR_VAR 0 50
95099: PUSH
95100: LD_INT 2
95102: PUSH
95103: LD_INT 3
95105: PUSH
95106: EMPTY
95107: LIST
95108: LIST
95109: PUSH
95110: LD_INT 1
95112: PUSH
95113: LD_INT 3
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: EMPTY
95121: LIST
95122: LIST
95123: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
95124: LD_ADDR_VAR 0 51
95128: PUSH
95129: LD_INT 1
95131: NEG
95132: PUSH
95133: LD_INT 2
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: LD_INT 2
95142: NEG
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
95155: LD_ADDR_VAR 0 52
95159: PUSH
95160: LD_INT 3
95162: NEG
95163: PUSH
95164: LD_INT 1
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 3
95174: NEG
95175: PUSH
95176: LD_INT 2
95178: NEG
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: EMPTY
95185: LIST
95186: LIST
95187: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
95188: LD_ADDR_VAR 0 53
95192: PUSH
95193: LD_INT 1
95195: NEG
95196: PUSH
95197: LD_INT 3
95199: NEG
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 0
95207: PUSH
95208: LD_INT 3
95210: NEG
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 1
95218: PUSH
95219: LD_INT 2
95221: NEG
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: LIST
95231: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
95232: LD_ADDR_VAR 0 54
95236: PUSH
95237: LD_INT 2
95239: PUSH
95240: LD_INT 1
95242: NEG
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 3
95250: PUSH
95251: LD_INT 0
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: LD_INT 3
95260: PUSH
95261: LD_INT 1
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: EMPTY
95269: LIST
95270: LIST
95271: LIST
95272: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
95273: LD_ADDR_VAR 0 55
95277: PUSH
95278: LD_INT 3
95280: PUSH
95281: LD_INT 2
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PUSH
95288: LD_INT 3
95290: PUSH
95291: LD_INT 3
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: PUSH
95298: LD_INT 2
95300: PUSH
95301: LD_INT 3
95303: PUSH
95304: EMPTY
95305: LIST
95306: LIST
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: LIST
95312: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
95313: LD_ADDR_VAR 0 56
95317: PUSH
95318: LD_INT 1
95320: PUSH
95321: LD_INT 3
95323: PUSH
95324: EMPTY
95325: LIST
95326: LIST
95327: PUSH
95328: LD_INT 0
95330: PUSH
95331: LD_INT 3
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 1
95340: NEG
95341: PUSH
95342: LD_INT 2
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: EMPTY
95350: LIST
95351: LIST
95352: LIST
95353: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95354: LD_ADDR_VAR 0 57
95358: PUSH
95359: LD_INT 2
95361: NEG
95362: PUSH
95363: LD_INT 1
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: LD_INT 3
95372: NEG
95373: PUSH
95374: LD_INT 0
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 3
95383: NEG
95384: PUSH
95385: LD_INT 1
95387: NEG
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: LIST
95397: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95398: LD_ADDR_VAR 0 58
95402: PUSH
95403: LD_INT 2
95405: NEG
95406: PUSH
95407: LD_INT 3
95409: NEG
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 3
95417: NEG
95418: PUSH
95419: LD_INT 2
95421: NEG
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 3
95429: NEG
95430: PUSH
95431: LD_INT 3
95433: NEG
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: LIST
95443: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
95444: LD_ADDR_VAR 0 59
95448: PUSH
95449: LD_INT 1
95451: NEG
95452: PUSH
95453: LD_INT 2
95455: NEG
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 0
95463: PUSH
95464: LD_INT 2
95466: NEG
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 1
95474: PUSH
95475: LD_INT 1
95477: NEG
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: LIST
95487: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
95488: LD_ADDR_VAR 0 60
95492: PUSH
95493: LD_INT 1
95495: PUSH
95496: LD_INT 1
95498: NEG
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 2
95506: PUSH
95507: LD_INT 0
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 2
95516: PUSH
95517: LD_INT 1
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: LIST
95528: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
95529: LD_ADDR_VAR 0 61
95533: PUSH
95534: LD_INT 2
95536: PUSH
95537: LD_INT 1
95539: PUSH
95540: EMPTY
95541: LIST
95542: LIST
95543: PUSH
95544: LD_INT 2
95546: PUSH
95547: LD_INT 2
95549: PUSH
95550: EMPTY
95551: LIST
95552: LIST
95553: PUSH
95554: LD_INT 1
95556: PUSH
95557: LD_INT 2
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: LIST
95568: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
95569: LD_ADDR_VAR 0 62
95573: PUSH
95574: LD_INT 1
95576: PUSH
95577: LD_INT 2
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 0
95586: PUSH
95587: LD_INT 2
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: PUSH
95594: LD_INT 1
95596: NEG
95597: PUSH
95598: LD_INT 1
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: LIST
95609: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95610: LD_ADDR_VAR 0 63
95614: PUSH
95615: LD_INT 1
95617: NEG
95618: PUSH
95619: LD_INT 1
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 2
95628: NEG
95629: PUSH
95630: LD_INT 0
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 2
95639: NEG
95640: PUSH
95641: LD_INT 1
95643: NEG
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95654: LD_ADDR_VAR 0 64
95658: PUSH
95659: LD_INT 1
95661: NEG
95662: PUSH
95663: LD_INT 2
95665: NEG
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 2
95673: NEG
95674: PUSH
95675: LD_INT 1
95677: NEG
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 2
95685: NEG
95686: PUSH
95687: LD_INT 2
95689: NEG
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: LIST
95699: ST_TO_ADDR
// end ; 2 :
95700: GO 98966
95702: LD_INT 2
95704: DOUBLE
95705: EQUAL
95706: IFTRUE 95710
95708: GO 98965
95710: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
95711: LD_ADDR_VAR 0 29
95715: PUSH
95716: LD_INT 4
95718: PUSH
95719: LD_INT 0
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 4
95728: PUSH
95729: LD_INT 1
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 5
95739: PUSH
95740: LD_INT 0
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 5
95749: PUSH
95750: LD_INT 1
95752: PUSH
95753: EMPTY
95754: LIST
95755: LIST
95756: PUSH
95757: LD_INT 4
95759: PUSH
95760: LD_INT 1
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: PUSH
95767: LD_INT 3
95769: PUSH
95770: LD_INT 0
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: PUSH
95777: LD_INT 3
95779: PUSH
95780: LD_INT 1
95782: NEG
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: LD_INT 3
95790: PUSH
95791: LD_INT 2
95793: NEG
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 5
95801: PUSH
95802: LD_INT 2
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: PUSH
95809: LD_INT 3
95811: PUSH
95812: LD_INT 3
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: PUSH
95819: LD_INT 3
95821: PUSH
95822: LD_INT 2
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: LD_INT 4
95831: PUSH
95832: LD_INT 3
95834: PUSH
95835: EMPTY
95836: LIST
95837: LIST
95838: PUSH
95839: LD_INT 4
95841: PUSH
95842: LD_INT 4
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 3
95851: PUSH
95852: LD_INT 4
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 2
95861: PUSH
95862: LD_INT 3
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 2
95871: PUSH
95872: LD_INT 2
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 4
95881: PUSH
95882: LD_INT 2
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: PUSH
95889: LD_INT 2
95891: PUSH
95892: LD_INT 4
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 0
95901: PUSH
95902: LD_INT 4
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 0
95911: PUSH
95912: LD_INT 3
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 1
95921: PUSH
95922: LD_INT 4
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: PUSH
95929: LD_INT 1
95931: PUSH
95932: LD_INT 5
95934: PUSH
95935: EMPTY
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 0
95941: PUSH
95942: LD_INT 5
95944: PUSH
95945: EMPTY
95946: LIST
95947: LIST
95948: PUSH
95949: LD_INT 1
95951: NEG
95952: PUSH
95953: LD_INT 4
95955: PUSH
95956: EMPTY
95957: LIST
95958: LIST
95959: PUSH
95960: LD_INT 1
95962: NEG
95963: PUSH
95964: LD_INT 3
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 2
95973: PUSH
95974: LD_INT 5
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 2
95983: NEG
95984: PUSH
95985: LD_INT 3
95987: PUSH
95988: EMPTY
95989: LIST
95990: LIST
95991: PUSH
95992: LD_INT 3
95994: NEG
95995: PUSH
95996: LD_INT 0
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: LD_INT 3
96005: NEG
96006: PUSH
96007: LD_INT 1
96009: NEG
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: PUSH
96015: LD_INT 2
96017: NEG
96018: PUSH
96019: LD_INT 0
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 2
96028: NEG
96029: PUSH
96030: LD_INT 1
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PUSH
96037: LD_INT 3
96039: NEG
96040: PUSH
96041: LD_INT 1
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: PUSH
96048: LD_INT 4
96050: NEG
96051: PUSH
96052: LD_INT 0
96054: PUSH
96055: EMPTY
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 4
96061: NEG
96062: PUSH
96063: LD_INT 1
96065: NEG
96066: PUSH
96067: EMPTY
96068: LIST
96069: LIST
96070: PUSH
96071: LD_INT 4
96073: NEG
96074: PUSH
96075: LD_INT 2
96077: NEG
96078: PUSH
96079: EMPTY
96080: LIST
96081: LIST
96082: PUSH
96083: LD_INT 2
96085: NEG
96086: PUSH
96087: LD_INT 2
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 4
96096: NEG
96097: PUSH
96098: LD_INT 4
96100: NEG
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 4
96108: NEG
96109: PUSH
96110: LD_INT 5
96112: NEG
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: NEG
96121: PUSH
96122: LD_INT 4
96124: NEG
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 3
96132: NEG
96133: PUSH
96134: LD_INT 3
96136: NEG
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: PUSH
96142: LD_INT 4
96144: NEG
96145: PUSH
96146: LD_INT 3
96148: NEG
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: PUSH
96154: LD_INT 5
96156: NEG
96157: PUSH
96158: LD_INT 4
96160: NEG
96161: PUSH
96162: EMPTY
96163: LIST
96164: LIST
96165: PUSH
96166: LD_INT 5
96168: NEG
96169: PUSH
96170: LD_INT 5
96172: NEG
96173: PUSH
96174: EMPTY
96175: LIST
96176: LIST
96177: PUSH
96178: LD_INT 3
96180: NEG
96181: PUSH
96182: LD_INT 5
96184: NEG
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: PUSH
96190: LD_INT 5
96192: NEG
96193: PUSH
96194: LD_INT 3
96196: NEG
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PUSH
96202: EMPTY
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: LIST
96235: LIST
96236: LIST
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
96249: LD_ADDR_VAR 0 30
96253: PUSH
96254: LD_INT 4
96256: PUSH
96257: LD_INT 4
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: PUSH
96264: LD_INT 4
96266: PUSH
96267: LD_INT 3
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: PUSH
96274: LD_INT 5
96276: PUSH
96277: LD_INT 4
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: PUSH
96284: LD_INT 5
96286: PUSH
96287: LD_INT 5
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 4
96296: PUSH
96297: LD_INT 5
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: LD_INT 3
96306: PUSH
96307: LD_INT 4
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 3
96316: PUSH
96317: LD_INT 3
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 5
96326: PUSH
96327: LD_INT 3
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: LD_INT 5
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 0
96346: PUSH
96347: LD_INT 3
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 0
96356: PUSH
96357: LD_INT 2
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 1
96366: PUSH
96367: LD_INT 3
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 1
96376: PUSH
96377: LD_INT 4
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 0
96386: PUSH
96387: LD_INT 4
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 1
96396: NEG
96397: PUSH
96398: LD_INT 3
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 1
96407: NEG
96408: PUSH
96409: LD_INT 2
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 2
96418: PUSH
96419: LD_INT 4
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 2
96428: NEG
96429: PUSH
96430: LD_INT 2
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: PUSH
96437: LD_INT 4
96439: NEG
96440: PUSH
96441: LD_INT 0
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: PUSH
96448: LD_INT 4
96450: NEG
96451: PUSH
96452: LD_INT 1
96454: NEG
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: PUSH
96460: LD_INT 3
96462: NEG
96463: PUSH
96464: LD_INT 0
96466: PUSH
96467: EMPTY
96468: LIST
96469: LIST
96470: PUSH
96471: LD_INT 3
96473: NEG
96474: PUSH
96475: LD_INT 1
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 4
96484: NEG
96485: PUSH
96486: LD_INT 1
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: PUSH
96493: LD_INT 5
96495: NEG
96496: PUSH
96497: LD_INT 0
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: PUSH
96504: LD_INT 5
96506: NEG
96507: PUSH
96508: LD_INT 1
96510: NEG
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 5
96518: NEG
96519: PUSH
96520: LD_INT 2
96522: NEG
96523: PUSH
96524: EMPTY
96525: LIST
96526: LIST
96527: PUSH
96528: LD_INT 3
96530: NEG
96531: PUSH
96532: LD_INT 2
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 3
96541: NEG
96542: PUSH
96543: LD_INT 3
96545: NEG
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_INT 3
96553: NEG
96554: PUSH
96555: LD_INT 4
96557: NEG
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 2
96565: NEG
96566: PUSH
96567: LD_INT 3
96569: NEG
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 2
96577: NEG
96578: PUSH
96579: LD_INT 2
96581: NEG
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 3
96589: NEG
96590: PUSH
96591: LD_INT 2
96593: NEG
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: PUSH
96599: LD_INT 4
96601: NEG
96602: PUSH
96603: LD_INT 3
96605: NEG
96606: PUSH
96607: EMPTY
96608: LIST
96609: LIST
96610: PUSH
96611: LD_INT 4
96613: NEG
96614: PUSH
96615: LD_INT 4
96617: NEG
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: PUSH
96623: LD_INT 2
96625: NEG
96626: PUSH
96627: LD_INT 4
96629: NEG
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 4
96637: NEG
96638: PUSH
96639: LD_INT 2
96641: NEG
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: PUSH
96647: LD_INT 0
96649: PUSH
96650: LD_INT 4
96652: NEG
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 0
96660: PUSH
96661: LD_INT 5
96663: NEG
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: PUSH
96669: LD_INT 1
96671: PUSH
96672: LD_INT 4
96674: NEG
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 1
96682: PUSH
96683: LD_INT 3
96685: NEG
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 0
96693: PUSH
96694: LD_INT 3
96696: NEG
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 1
96704: NEG
96705: PUSH
96706: LD_INT 4
96708: NEG
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 1
96716: NEG
96717: PUSH
96718: LD_INT 5
96720: NEG
96721: PUSH
96722: EMPTY
96723: LIST
96724: LIST
96725: PUSH
96726: LD_INT 2
96728: PUSH
96729: LD_INT 3
96731: NEG
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 2
96739: NEG
96740: PUSH
96741: LD_INT 5
96743: NEG
96744: PUSH
96745: EMPTY
96746: LIST
96747: LIST
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
96796: LD_ADDR_VAR 0 31
96800: PUSH
96801: LD_INT 0
96803: PUSH
96804: LD_INT 4
96806: PUSH
96807: EMPTY
96808: LIST
96809: LIST
96810: PUSH
96811: LD_INT 0
96813: PUSH
96814: LD_INT 3
96816: PUSH
96817: EMPTY
96818: LIST
96819: LIST
96820: PUSH
96821: LD_INT 1
96823: PUSH
96824: LD_INT 4
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 1
96833: PUSH
96834: LD_INT 5
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 0
96843: PUSH
96844: LD_INT 5
96846: PUSH
96847: EMPTY
96848: LIST
96849: LIST
96850: PUSH
96851: LD_INT 1
96853: NEG
96854: PUSH
96855: LD_INT 4
96857: PUSH
96858: EMPTY
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 1
96864: NEG
96865: PUSH
96866: LD_INT 3
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 2
96875: PUSH
96876: LD_INT 5
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 2
96885: NEG
96886: PUSH
96887: LD_INT 3
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PUSH
96894: LD_INT 3
96896: NEG
96897: PUSH
96898: LD_INT 0
96900: PUSH
96901: EMPTY
96902: LIST
96903: LIST
96904: PUSH
96905: LD_INT 3
96907: NEG
96908: PUSH
96909: LD_INT 1
96911: NEG
96912: PUSH
96913: EMPTY
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 2
96919: NEG
96920: PUSH
96921: LD_INT 0
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: PUSH
96928: LD_INT 2
96930: NEG
96931: PUSH
96932: LD_INT 1
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: PUSH
96939: LD_INT 3
96941: NEG
96942: PUSH
96943: LD_INT 1
96945: PUSH
96946: EMPTY
96947: LIST
96948: LIST
96949: PUSH
96950: LD_INT 4
96952: NEG
96953: PUSH
96954: LD_INT 0
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PUSH
96961: LD_INT 4
96963: NEG
96964: PUSH
96965: LD_INT 1
96967: NEG
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 4
96975: NEG
96976: PUSH
96977: LD_INT 2
96979: NEG
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: PUSH
96985: LD_INT 2
96987: NEG
96988: PUSH
96989: LD_INT 2
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: PUSH
96996: LD_INT 4
96998: NEG
96999: PUSH
97000: LD_INT 4
97002: NEG
97003: PUSH
97004: EMPTY
97005: LIST
97006: LIST
97007: PUSH
97008: LD_INT 4
97010: NEG
97011: PUSH
97012: LD_INT 5
97014: NEG
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: PUSH
97020: LD_INT 3
97022: NEG
97023: PUSH
97024: LD_INT 4
97026: NEG
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: LD_INT 3
97034: NEG
97035: PUSH
97036: LD_INT 3
97038: NEG
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PUSH
97044: LD_INT 4
97046: NEG
97047: PUSH
97048: LD_INT 3
97050: NEG
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 5
97058: NEG
97059: PUSH
97060: LD_INT 4
97062: NEG
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 5
97070: NEG
97071: PUSH
97072: LD_INT 5
97074: NEG
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: PUSH
97080: LD_INT 3
97082: NEG
97083: PUSH
97084: LD_INT 5
97086: NEG
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 5
97094: NEG
97095: PUSH
97096: LD_INT 3
97098: NEG
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 0
97106: PUSH
97107: LD_INT 3
97109: NEG
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 0
97117: PUSH
97118: LD_INT 4
97120: NEG
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_INT 1
97128: PUSH
97129: LD_INT 3
97131: NEG
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 1
97139: PUSH
97140: LD_INT 2
97142: NEG
97143: PUSH
97144: EMPTY
97145: LIST
97146: LIST
97147: PUSH
97148: LD_INT 0
97150: PUSH
97151: LD_INT 2
97153: NEG
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 1
97161: NEG
97162: PUSH
97163: LD_INT 3
97165: NEG
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: PUSH
97171: LD_INT 1
97173: NEG
97174: PUSH
97175: LD_INT 4
97177: NEG
97178: PUSH
97179: EMPTY
97180: LIST
97181: LIST
97182: PUSH
97183: LD_INT 2
97185: PUSH
97186: LD_INT 2
97188: NEG
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: LD_INT 2
97196: NEG
97197: PUSH
97198: LD_INT 4
97200: NEG
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 4
97208: PUSH
97209: LD_INT 0
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 4
97218: PUSH
97219: LD_INT 1
97221: NEG
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 5
97229: PUSH
97230: LD_INT 0
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 5
97239: PUSH
97240: LD_INT 1
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_INT 4
97249: PUSH
97250: LD_INT 1
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PUSH
97257: LD_INT 3
97259: PUSH
97260: LD_INT 0
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: PUSH
97267: LD_INT 3
97269: PUSH
97270: LD_INT 1
97272: NEG
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: PUSH
97278: LD_INT 3
97280: PUSH
97281: LD_INT 2
97283: NEG
97284: PUSH
97285: EMPTY
97286: LIST
97287: LIST
97288: PUSH
97289: LD_INT 5
97291: PUSH
97292: LD_INT 2
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
97346: LD_ADDR_VAR 0 32
97350: PUSH
97351: LD_INT 4
97353: NEG
97354: PUSH
97355: LD_INT 0
97357: PUSH
97358: EMPTY
97359: LIST
97360: LIST
97361: PUSH
97362: LD_INT 4
97364: NEG
97365: PUSH
97366: LD_INT 1
97368: NEG
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: PUSH
97374: LD_INT 3
97376: NEG
97377: PUSH
97378: LD_INT 0
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 3
97387: NEG
97388: PUSH
97389: LD_INT 1
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 4
97398: NEG
97399: PUSH
97400: LD_INT 1
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 5
97409: NEG
97410: PUSH
97411: LD_INT 0
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 5
97420: NEG
97421: PUSH
97422: LD_INT 1
97424: NEG
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 5
97432: NEG
97433: PUSH
97434: LD_INT 2
97436: NEG
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: LD_INT 3
97444: NEG
97445: PUSH
97446: LD_INT 2
97448: PUSH
97449: EMPTY
97450: LIST
97451: LIST
97452: PUSH
97453: LD_INT 3
97455: NEG
97456: PUSH
97457: LD_INT 3
97459: NEG
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: PUSH
97465: LD_INT 3
97467: NEG
97468: PUSH
97469: LD_INT 4
97471: NEG
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 2
97479: NEG
97480: PUSH
97481: LD_INT 3
97483: NEG
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: PUSH
97489: LD_INT 2
97491: NEG
97492: PUSH
97493: LD_INT 2
97495: NEG
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 3
97503: NEG
97504: PUSH
97505: LD_INT 2
97507: NEG
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PUSH
97513: LD_INT 4
97515: NEG
97516: PUSH
97517: LD_INT 3
97519: NEG
97520: PUSH
97521: EMPTY
97522: LIST
97523: LIST
97524: PUSH
97525: LD_INT 4
97527: NEG
97528: PUSH
97529: LD_INT 4
97531: NEG
97532: PUSH
97533: EMPTY
97534: LIST
97535: LIST
97536: PUSH
97537: LD_INT 2
97539: NEG
97540: PUSH
97541: LD_INT 4
97543: NEG
97544: PUSH
97545: EMPTY
97546: LIST
97547: LIST
97548: PUSH
97549: LD_INT 4
97551: NEG
97552: PUSH
97553: LD_INT 2
97555: NEG
97556: PUSH
97557: EMPTY
97558: LIST
97559: LIST
97560: PUSH
97561: LD_INT 0
97563: PUSH
97564: LD_INT 4
97566: NEG
97567: PUSH
97568: EMPTY
97569: LIST
97570: LIST
97571: PUSH
97572: LD_INT 0
97574: PUSH
97575: LD_INT 5
97577: NEG
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: PUSH
97583: LD_INT 1
97585: PUSH
97586: LD_INT 4
97588: NEG
97589: PUSH
97590: EMPTY
97591: LIST
97592: LIST
97593: PUSH
97594: LD_INT 1
97596: PUSH
97597: LD_INT 3
97599: NEG
97600: PUSH
97601: EMPTY
97602: LIST
97603: LIST
97604: PUSH
97605: LD_INT 0
97607: PUSH
97608: LD_INT 3
97610: NEG
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 1
97618: NEG
97619: PUSH
97620: LD_INT 4
97622: NEG
97623: PUSH
97624: EMPTY
97625: LIST
97626: LIST
97627: PUSH
97628: LD_INT 1
97630: NEG
97631: PUSH
97632: LD_INT 5
97634: NEG
97635: PUSH
97636: EMPTY
97637: LIST
97638: LIST
97639: PUSH
97640: LD_INT 2
97642: PUSH
97643: LD_INT 3
97645: NEG
97646: PUSH
97647: EMPTY
97648: LIST
97649: LIST
97650: PUSH
97651: LD_INT 2
97653: NEG
97654: PUSH
97655: LD_INT 5
97657: NEG
97658: PUSH
97659: EMPTY
97660: LIST
97661: LIST
97662: PUSH
97663: LD_INT 3
97665: PUSH
97666: LD_INT 0
97668: PUSH
97669: EMPTY
97670: LIST
97671: LIST
97672: PUSH
97673: LD_INT 3
97675: PUSH
97676: LD_INT 1
97678: NEG
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: PUSH
97684: LD_INT 4
97686: PUSH
97687: LD_INT 0
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: PUSH
97694: LD_INT 4
97696: PUSH
97697: LD_INT 1
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: PUSH
97704: LD_INT 3
97706: PUSH
97707: LD_INT 1
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: PUSH
97714: LD_INT 2
97716: PUSH
97717: LD_INT 0
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PUSH
97724: LD_INT 2
97726: PUSH
97727: LD_INT 1
97729: NEG
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: PUSH
97735: LD_INT 2
97737: PUSH
97738: LD_INT 2
97740: NEG
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: PUSH
97746: LD_INT 4
97748: PUSH
97749: LD_INT 2
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 4
97758: PUSH
97759: LD_INT 4
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: PUSH
97766: LD_INT 4
97768: PUSH
97769: LD_INT 3
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: PUSH
97776: LD_INT 5
97778: PUSH
97779: LD_INT 4
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: PUSH
97786: LD_INT 5
97788: PUSH
97789: LD_INT 5
97791: PUSH
97792: EMPTY
97793: LIST
97794: LIST
97795: PUSH
97796: LD_INT 4
97798: PUSH
97799: LD_INT 5
97801: PUSH
97802: EMPTY
97803: LIST
97804: LIST
97805: PUSH
97806: LD_INT 3
97808: PUSH
97809: LD_INT 4
97811: PUSH
97812: EMPTY
97813: LIST
97814: LIST
97815: PUSH
97816: LD_INT 3
97818: PUSH
97819: LD_INT 3
97821: PUSH
97822: EMPTY
97823: LIST
97824: LIST
97825: PUSH
97826: LD_INT 5
97828: PUSH
97829: LD_INT 3
97831: PUSH
97832: EMPTY
97833: LIST
97834: LIST
97835: PUSH
97836: LD_INT 3
97838: PUSH
97839: LD_INT 5
97841: PUSH
97842: EMPTY
97843: LIST
97844: LIST
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97893: LD_ADDR_VAR 0 33
97897: PUSH
97898: LD_INT 4
97900: NEG
97901: PUSH
97902: LD_INT 4
97904: NEG
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 4
97912: NEG
97913: PUSH
97914: LD_INT 5
97916: NEG
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: LD_INT 3
97924: NEG
97925: PUSH
97926: LD_INT 4
97928: NEG
97929: PUSH
97930: EMPTY
97931: LIST
97932: LIST
97933: PUSH
97934: LD_INT 3
97936: NEG
97937: PUSH
97938: LD_INT 3
97940: NEG
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 4
97948: NEG
97949: PUSH
97950: LD_INT 3
97952: NEG
97953: PUSH
97954: EMPTY
97955: LIST
97956: LIST
97957: PUSH
97958: LD_INT 5
97960: NEG
97961: PUSH
97962: LD_INT 4
97964: NEG
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: PUSH
97970: LD_INT 5
97972: NEG
97973: PUSH
97974: LD_INT 5
97976: NEG
97977: PUSH
97978: EMPTY
97979: LIST
97980: LIST
97981: PUSH
97982: LD_INT 3
97984: NEG
97985: PUSH
97986: LD_INT 5
97988: NEG
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: LD_INT 5
97996: NEG
97997: PUSH
97998: LD_INT 3
98000: NEG
98001: PUSH
98002: EMPTY
98003: LIST
98004: LIST
98005: PUSH
98006: LD_INT 0
98008: PUSH
98009: LD_INT 3
98011: NEG
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: LD_INT 0
98019: PUSH
98020: LD_INT 4
98022: NEG
98023: PUSH
98024: EMPTY
98025: LIST
98026: LIST
98027: PUSH
98028: LD_INT 1
98030: PUSH
98031: LD_INT 3
98033: NEG
98034: PUSH
98035: EMPTY
98036: LIST
98037: LIST
98038: PUSH
98039: LD_INT 1
98041: PUSH
98042: LD_INT 2
98044: NEG
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 0
98052: PUSH
98053: LD_INT 2
98055: NEG
98056: PUSH
98057: EMPTY
98058: LIST
98059: LIST
98060: PUSH
98061: LD_INT 1
98063: NEG
98064: PUSH
98065: LD_INT 3
98067: NEG
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: LD_INT 1
98075: NEG
98076: PUSH
98077: LD_INT 4
98079: NEG
98080: PUSH
98081: EMPTY
98082: LIST
98083: LIST
98084: PUSH
98085: LD_INT 2
98087: PUSH
98088: LD_INT 2
98090: NEG
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: PUSH
98096: LD_INT 2
98098: NEG
98099: PUSH
98100: LD_INT 4
98102: NEG
98103: PUSH
98104: EMPTY
98105: LIST
98106: LIST
98107: PUSH
98108: LD_INT 4
98110: PUSH
98111: LD_INT 0
98113: PUSH
98114: EMPTY
98115: LIST
98116: LIST
98117: PUSH
98118: LD_INT 4
98120: PUSH
98121: LD_INT 1
98123: NEG
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: LD_INT 5
98131: PUSH
98132: LD_INT 0
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: PUSH
98139: LD_INT 5
98141: PUSH
98142: LD_INT 1
98144: PUSH
98145: EMPTY
98146: LIST
98147: LIST
98148: PUSH
98149: LD_INT 4
98151: PUSH
98152: LD_INT 1
98154: PUSH
98155: EMPTY
98156: LIST
98157: LIST
98158: PUSH
98159: LD_INT 3
98161: PUSH
98162: LD_INT 0
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PUSH
98169: LD_INT 3
98171: PUSH
98172: LD_INT 1
98174: NEG
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: PUSH
98180: LD_INT 3
98182: PUSH
98183: LD_INT 2
98185: NEG
98186: PUSH
98187: EMPTY
98188: LIST
98189: LIST
98190: PUSH
98191: LD_INT 5
98193: PUSH
98194: LD_INT 2
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 3
98203: PUSH
98204: LD_INT 3
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: PUSH
98211: LD_INT 3
98213: PUSH
98214: LD_INT 2
98216: PUSH
98217: EMPTY
98218: LIST
98219: LIST
98220: PUSH
98221: LD_INT 4
98223: PUSH
98224: LD_INT 3
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: PUSH
98231: LD_INT 4
98233: PUSH
98234: LD_INT 4
98236: PUSH
98237: EMPTY
98238: LIST
98239: LIST
98240: PUSH
98241: LD_INT 3
98243: PUSH
98244: LD_INT 4
98246: PUSH
98247: EMPTY
98248: LIST
98249: LIST
98250: PUSH
98251: LD_INT 2
98253: PUSH
98254: LD_INT 3
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: PUSH
98261: LD_INT 2
98263: PUSH
98264: LD_INT 2
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: PUSH
98271: LD_INT 4
98273: PUSH
98274: LD_INT 2
98276: PUSH
98277: EMPTY
98278: LIST
98279: LIST
98280: PUSH
98281: LD_INT 2
98283: PUSH
98284: LD_INT 4
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PUSH
98291: LD_INT 0
98293: PUSH
98294: LD_INT 4
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: PUSH
98301: LD_INT 0
98303: PUSH
98304: LD_INT 3
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PUSH
98311: LD_INT 1
98313: PUSH
98314: LD_INT 4
98316: PUSH
98317: EMPTY
98318: LIST
98319: LIST
98320: PUSH
98321: LD_INT 1
98323: PUSH
98324: LD_INT 5
98326: PUSH
98327: EMPTY
98328: LIST
98329: LIST
98330: PUSH
98331: LD_INT 0
98333: PUSH
98334: LD_INT 5
98336: PUSH
98337: EMPTY
98338: LIST
98339: LIST
98340: PUSH
98341: LD_INT 1
98343: NEG
98344: PUSH
98345: LD_INT 4
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: PUSH
98352: LD_INT 1
98354: NEG
98355: PUSH
98356: LD_INT 3
98358: PUSH
98359: EMPTY
98360: LIST
98361: LIST
98362: PUSH
98363: LD_INT 2
98365: PUSH
98366: LD_INT 5
98368: PUSH
98369: EMPTY
98370: LIST
98371: LIST
98372: PUSH
98373: LD_INT 2
98375: NEG
98376: PUSH
98377: LD_INT 3
98379: PUSH
98380: EMPTY
98381: LIST
98382: LIST
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: LIST
98388: LIST
98389: LIST
98390: LIST
98391: LIST
98392: LIST
98393: LIST
98394: LIST
98395: LIST
98396: LIST
98397: LIST
98398: LIST
98399: LIST
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
98431: LD_ADDR_VAR 0 34
98435: PUSH
98436: LD_INT 0
98438: PUSH
98439: LD_INT 4
98441: NEG
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PUSH
98447: LD_INT 0
98449: PUSH
98450: LD_INT 5
98452: NEG
98453: PUSH
98454: EMPTY
98455: LIST
98456: LIST
98457: PUSH
98458: LD_INT 1
98460: PUSH
98461: LD_INT 4
98463: NEG
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 1
98471: PUSH
98472: LD_INT 3
98474: NEG
98475: PUSH
98476: EMPTY
98477: LIST
98478: LIST
98479: PUSH
98480: LD_INT 0
98482: PUSH
98483: LD_INT 3
98485: NEG
98486: PUSH
98487: EMPTY
98488: LIST
98489: LIST
98490: PUSH
98491: LD_INT 1
98493: NEG
98494: PUSH
98495: LD_INT 4
98497: NEG
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: PUSH
98503: LD_INT 1
98505: NEG
98506: PUSH
98507: LD_INT 5
98509: NEG
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: PUSH
98515: LD_INT 2
98517: PUSH
98518: LD_INT 3
98520: NEG
98521: PUSH
98522: EMPTY
98523: LIST
98524: LIST
98525: PUSH
98526: LD_INT 2
98528: NEG
98529: PUSH
98530: LD_INT 5
98532: NEG
98533: PUSH
98534: EMPTY
98535: LIST
98536: LIST
98537: PUSH
98538: LD_INT 3
98540: PUSH
98541: LD_INT 0
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: PUSH
98548: LD_INT 3
98550: PUSH
98551: LD_INT 1
98553: NEG
98554: PUSH
98555: EMPTY
98556: LIST
98557: LIST
98558: PUSH
98559: LD_INT 4
98561: PUSH
98562: LD_INT 0
98564: PUSH
98565: EMPTY
98566: LIST
98567: LIST
98568: PUSH
98569: LD_INT 4
98571: PUSH
98572: LD_INT 1
98574: PUSH
98575: EMPTY
98576: LIST
98577: LIST
98578: PUSH
98579: LD_INT 3
98581: PUSH
98582: LD_INT 1
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: LD_INT 2
98591: PUSH
98592: LD_INT 0
98594: PUSH
98595: EMPTY
98596: LIST
98597: LIST
98598: PUSH
98599: LD_INT 2
98601: PUSH
98602: LD_INT 1
98604: NEG
98605: PUSH
98606: EMPTY
98607: LIST
98608: LIST
98609: PUSH
98610: LD_INT 2
98612: PUSH
98613: LD_INT 2
98615: NEG
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: LD_INT 4
98623: PUSH
98624: LD_INT 2
98626: PUSH
98627: EMPTY
98628: LIST
98629: LIST
98630: PUSH
98631: LD_INT 4
98633: PUSH
98634: LD_INT 4
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: PUSH
98641: LD_INT 4
98643: PUSH
98644: LD_INT 3
98646: PUSH
98647: EMPTY
98648: LIST
98649: LIST
98650: PUSH
98651: LD_INT 5
98653: PUSH
98654: LD_INT 4
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: PUSH
98661: LD_INT 5
98663: PUSH
98664: LD_INT 5
98666: PUSH
98667: EMPTY
98668: LIST
98669: LIST
98670: PUSH
98671: LD_INT 4
98673: PUSH
98674: LD_INT 5
98676: PUSH
98677: EMPTY
98678: LIST
98679: LIST
98680: PUSH
98681: LD_INT 3
98683: PUSH
98684: LD_INT 4
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: PUSH
98691: LD_INT 3
98693: PUSH
98694: LD_INT 3
98696: PUSH
98697: EMPTY
98698: LIST
98699: LIST
98700: PUSH
98701: LD_INT 5
98703: PUSH
98704: LD_INT 3
98706: PUSH
98707: EMPTY
98708: LIST
98709: LIST
98710: PUSH
98711: LD_INT 3
98713: PUSH
98714: LD_INT 5
98716: PUSH
98717: EMPTY
98718: LIST
98719: LIST
98720: PUSH
98721: LD_INT 0
98723: PUSH
98724: LD_INT 3
98726: PUSH
98727: EMPTY
98728: LIST
98729: LIST
98730: PUSH
98731: LD_INT 0
98733: PUSH
98734: LD_INT 2
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: PUSH
98741: LD_INT 1
98743: PUSH
98744: LD_INT 3
98746: PUSH
98747: EMPTY
98748: LIST
98749: LIST
98750: PUSH
98751: LD_INT 1
98753: PUSH
98754: LD_INT 4
98756: PUSH
98757: EMPTY
98758: LIST
98759: LIST
98760: PUSH
98761: LD_INT 0
98763: PUSH
98764: LD_INT 4
98766: PUSH
98767: EMPTY
98768: LIST
98769: LIST
98770: PUSH
98771: LD_INT 1
98773: NEG
98774: PUSH
98775: LD_INT 3
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: PUSH
98782: LD_INT 1
98784: NEG
98785: PUSH
98786: LD_INT 2
98788: PUSH
98789: EMPTY
98790: LIST
98791: LIST
98792: PUSH
98793: LD_INT 2
98795: PUSH
98796: LD_INT 4
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 2
98805: NEG
98806: PUSH
98807: LD_INT 2
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: PUSH
98814: LD_INT 4
98816: NEG
98817: PUSH
98818: LD_INT 0
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 4
98827: NEG
98828: PUSH
98829: LD_INT 1
98831: NEG
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: PUSH
98837: LD_INT 3
98839: NEG
98840: PUSH
98841: LD_INT 0
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: PUSH
98848: LD_INT 3
98850: NEG
98851: PUSH
98852: LD_INT 1
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: PUSH
98859: LD_INT 4
98861: NEG
98862: PUSH
98863: LD_INT 1
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: LD_INT 5
98872: NEG
98873: PUSH
98874: LD_INT 0
98876: PUSH
98877: EMPTY
98878: LIST
98879: LIST
98880: PUSH
98881: LD_INT 5
98883: NEG
98884: PUSH
98885: LD_INT 1
98887: NEG
98888: PUSH
98889: EMPTY
98890: LIST
98891: LIST
98892: PUSH
98893: LD_INT 5
98895: NEG
98896: PUSH
98897: LD_INT 2
98899: NEG
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: PUSH
98905: LD_INT 3
98907: NEG
98908: PUSH
98909: LD_INT 2
98911: PUSH
98912: EMPTY
98913: LIST
98914: LIST
98915: PUSH
98916: EMPTY
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: LIST
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: ST_TO_ADDR
// end ; end ;
98963: GO 98966
98965: POP
// case btype of b_depot , b_warehouse :
98966: LD_VAR 0 1
98970: PUSH
98971: LD_INT 0
98973: DOUBLE
98974: EQUAL
98975: IFTRUE 98985
98977: LD_INT 1
98979: DOUBLE
98980: EQUAL
98981: IFTRUE 98985
98983: GO 99186
98985: POP
// case nation of nation_american :
98986: LD_VAR 0 5
98990: PUSH
98991: LD_INT 1
98993: DOUBLE
98994: EQUAL
98995: IFTRUE 98999
98997: GO 99055
98999: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
99000: LD_ADDR_VAR 0 9
99004: PUSH
99005: LD_VAR 0 11
99009: PUSH
99010: LD_VAR 0 12
99014: PUSH
99015: LD_VAR 0 13
99019: PUSH
99020: LD_VAR 0 14
99024: PUSH
99025: LD_VAR 0 15
99029: PUSH
99030: LD_VAR 0 16
99034: PUSH
99035: EMPTY
99036: LIST
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: PUSH
99043: LD_VAR 0 4
99047: PUSH
99048: LD_INT 1
99050: PLUS
99051: ARRAY
99052: ST_TO_ADDR
99053: GO 99184
99055: LD_INT 2
99057: DOUBLE
99058: EQUAL
99059: IFTRUE 99063
99061: GO 99119
99063: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
99064: LD_ADDR_VAR 0 9
99068: PUSH
99069: LD_VAR 0 17
99073: PUSH
99074: LD_VAR 0 18
99078: PUSH
99079: LD_VAR 0 19
99083: PUSH
99084: LD_VAR 0 20
99088: PUSH
99089: LD_VAR 0 21
99093: PUSH
99094: LD_VAR 0 22
99098: PUSH
99099: EMPTY
99100: LIST
99101: LIST
99102: LIST
99103: LIST
99104: LIST
99105: LIST
99106: PUSH
99107: LD_VAR 0 4
99111: PUSH
99112: LD_INT 1
99114: PLUS
99115: ARRAY
99116: ST_TO_ADDR
99117: GO 99184
99119: LD_INT 3
99121: DOUBLE
99122: EQUAL
99123: IFTRUE 99127
99125: GO 99183
99127: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
99128: LD_ADDR_VAR 0 9
99132: PUSH
99133: LD_VAR 0 23
99137: PUSH
99138: LD_VAR 0 24
99142: PUSH
99143: LD_VAR 0 25
99147: PUSH
99148: LD_VAR 0 26
99152: PUSH
99153: LD_VAR 0 27
99157: PUSH
99158: LD_VAR 0 28
99162: PUSH
99163: EMPTY
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: PUSH
99171: LD_VAR 0 4
99175: PUSH
99176: LD_INT 1
99178: PLUS
99179: ARRAY
99180: ST_TO_ADDR
99181: GO 99184
99183: POP
99184: GO 99739
99186: LD_INT 2
99188: DOUBLE
99189: EQUAL
99190: IFTRUE 99200
99192: LD_INT 3
99194: DOUBLE
99195: EQUAL
99196: IFTRUE 99200
99198: GO 99256
99200: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
99201: LD_ADDR_VAR 0 9
99205: PUSH
99206: LD_VAR 0 29
99210: PUSH
99211: LD_VAR 0 30
99215: PUSH
99216: LD_VAR 0 31
99220: PUSH
99221: LD_VAR 0 32
99225: PUSH
99226: LD_VAR 0 33
99230: PUSH
99231: LD_VAR 0 34
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: PUSH
99244: LD_VAR 0 4
99248: PUSH
99249: LD_INT 1
99251: PLUS
99252: ARRAY
99253: ST_TO_ADDR
99254: GO 99739
99256: LD_INT 16
99258: DOUBLE
99259: EQUAL
99260: IFTRUE 99318
99262: LD_INT 17
99264: DOUBLE
99265: EQUAL
99266: IFTRUE 99318
99268: LD_INT 18
99270: DOUBLE
99271: EQUAL
99272: IFTRUE 99318
99274: LD_INT 19
99276: DOUBLE
99277: EQUAL
99278: IFTRUE 99318
99280: LD_INT 22
99282: DOUBLE
99283: EQUAL
99284: IFTRUE 99318
99286: LD_INT 20
99288: DOUBLE
99289: EQUAL
99290: IFTRUE 99318
99292: LD_INT 21
99294: DOUBLE
99295: EQUAL
99296: IFTRUE 99318
99298: LD_INT 23
99300: DOUBLE
99301: EQUAL
99302: IFTRUE 99318
99304: LD_INT 24
99306: DOUBLE
99307: EQUAL
99308: IFTRUE 99318
99310: LD_INT 25
99312: DOUBLE
99313: EQUAL
99314: IFTRUE 99318
99316: GO 99374
99318: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
99319: LD_ADDR_VAR 0 9
99323: PUSH
99324: LD_VAR 0 35
99328: PUSH
99329: LD_VAR 0 36
99333: PUSH
99334: LD_VAR 0 37
99338: PUSH
99339: LD_VAR 0 38
99343: PUSH
99344: LD_VAR 0 39
99348: PUSH
99349: LD_VAR 0 40
99353: PUSH
99354: EMPTY
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: PUSH
99362: LD_VAR 0 4
99366: PUSH
99367: LD_INT 1
99369: PLUS
99370: ARRAY
99371: ST_TO_ADDR
99372: GO 99739
99374: LD_INT 6
99376: DOUBLE
99377: EQUAL
99378: IFTRUE 99430
99380: LD_INT 7
99382: DOUBLE
99383: EQUAL
99384: IFTRUE 99430
99386: LD_INT 8
99388: DOUBLE
99389: EQUAL
99390: IFTRUE 99430
99392: LD_INT 13
99394: DOUBLE
99395: EQUAL
99396: IFTRUE 99430
99398: LD_INT 12
99400: DOUBLE
99401: EQUAL
99402: IFTRUE 99430
99404: LD_INT 15
99406: DOUBLE
99407: EQUAL
99408: IFTRUE 99430
99410: LD_INT 11
99412: DOUBLE
99413: EQUAL
99414: IFTRUE 99430
99416: LD_INT 14
99418: DOUBLE
99419: EQUAL
99420: IFTRUE 99430
99422: LD_INT 10
99424: DOUBLE
99425: EQUAL
99426: IFTRUE 99430
99428: GO 99486
99430: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
99431: LD_ADDR_VAR 0 9
99435: PUSH
99436: LD_VAR 0 41
99440: PUSH
99441: LD_VAR 0 42
99445: PUSH
99446: LD_VAR 0 43
99450: PUSH
99451: LD_VAR 0 44
99455: PUSH
99456: LD_VAR 0 45
99460: PUSH
99461: LD_VAR 0 46
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: PUSH
99474: LD_VAR 0 4
99478: PUSH
99479: LD_INT 1
99481: PLUS
99482: ARRAY
99483: ST_TO_ADDR
99484: GO 99739
99486: LD_INT 36
99488: DOUBLE
99489: EQUAL
99490: IFTRUE 99494
99492: GO 99550
99494: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
99495: LD_ADDR_VAR 0 9
99499: PUSH
99500: LD_VAR 0 47
99504: PUSH
99505: LD_VAR 0 48
99509: PUSH
99510: LD_VAR 0 49
99514: PUSH
99515: LD_VAR 0 50
99519: PUSH
99520: LD_VAR 0 51
99524: PUSH
99525: LD_VAR 0 52
99529: PUSH
99530: EMPTY
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: PUSH
99538: LD_VAR 0 4
99542: PUSH
99543: LD_INT 1
99545: PLUS
99546: ARRAY
99547: ST_TO_ADDR
99548: GO 99739
99550: LD_INT 4
99552: DOUBLE
99553: EQUAL
99554: IFTRUE 99576
99556: LD_INT 5
99558: DOUBLE
99559: EQUAL
99560: IFTRUE 99576
99562: LD_INT 34
99564: DOUBLE
99565: EQUAL
99566: IFTRUE 99576
99568: LD_INT 37
99570: DOUBLE
99571: EQUAL
99572: IFTRUE 99576
99574: GO 99632
99576: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
99577: LD_ADDR_VAR 0 9
99581: PUSH
99582: LD_VAR 0 53
99586: PUSH
99587: LD_VAR 0 54
99591: PUSH
99592: LD_VAR 0 55
99596: PUSH
99597: LD_VAR 0 56
99601: PUSH
99602: LD_VAR 0 57
99606: PUSH
99607: LD_VAR 0 58
99611: PUSH
99612: EMPTY
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: PUSH
99620: LD_VAR 0 4
99624: PUSH
99625: LD_INT 1
99627: PLUS
99628: ARRAY
99629: ST_TO_ADDR
99630: GO 99739
99632: LD_INT 31
99634: DOUBLE
99635: EQUAL
99636: IFTRUE 99682
99638: LD_INT 32
99640: DOUBLE
99641: EQUAL
99642: IFTRUE 99682
99644: LD_INT 33
99646: DOUBLE
99647: EQUAL
99648: IFTRUE 99682
99650: LD_INT 27
99652: DOUBLE
99653: EQUAL
99654: IFTRUE 99682
99656: LD_INT 26
99658: DOUBLE
99659: EQUAL
99660: IFTRUE 99682
99662: LD_INT 28
99664: DOUBLE
99665: EQUAL
99666: IFTRUE 99682
99668: LD_INT 29
99670: DOUBLE
99671: EQUAL
99672: IFTRUE 99682
99674: LD_INT 30
99676: DOUBLE
99677: EQUAL
99678: IFTRUE 99682
99680: GO 99738
99682: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
99683: LD_ADDR_VAR 0 9
99687: PUSH
99688: LD_VAR 0 59
99692: PUSH
99693: LD_VAR 0 60
99697: PUSH
99698: LD_VAR 0 61
99702: PUSH
99703: LD_VAR 0 62
99707: PUSH
99708: LD_VAR 0 63
99712: PUSH
99713: LD_VAR 0 64
99717: PUSH
99718: EMPTY
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: PUSH
99726: LD_VAR 0 4
99730: PUSH
99731: LD_INT 1
99733: PLUS
99734: ARRAY
99735: ST_TO_ADDR
99736: GO 99739
99738: POP
// temp_list2 = [ ] ;
99739: LD_ADDR_VAR 0 10
99743: PUSH
99744: EMPTY
99745: ST_TO_ADDR
// for i in temp_list do
99746: LD_ADDR_VAR 0 8
99750: PUSH
99751: LD_VAR 0 9
99755: PUSH
99756: FOR_IN
99757: IFFALSE 99809
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
99759: LD_ADDR_VAR 0 10
99763: PUSH
99764: LD_VAR 0 10
99768: PUSH
99769: LD_VAR 0 8
99773: PUSH
99774: LD_INT 1
99776: ARRAY
99777: PUSH
99778: LD_VAR 0 2
99782: PLUS
99783: PUSH
99784: LD_VAR 0 8
99788: PUSH
99789: LD_INT 2
99791: ARRAY
99792: PUSH
99793: LD_VAR 0 3
99797: PLUS
99798: PUSH
99799: EMPTY
99800: LIST
99801: LIST
99802: PUSH
99803: EMPTY
99804: LIST
99805: ADD
99806: ST_TO_ADDR
99807: GO 99756
99809: POP
99810: POP
// result = temp_list2 ;
99811: LD_ADDR_VAR 0 7
99815: PUSH
99816: LD_VAR 0 10
99820: ST_TO_ADDR
// end ;
99821: LD_VAR 0 7
99825: RET
// export function EnemyInRange ( unit , dist ) ; begin
99826: LD_INT 0
99828: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99829: LD_ADDR_VAR 0 3
99833: PUSH
99834: LD_VAR 0 1
99838: PPUSH
99839: CALL_OW 255
99843: PPUSH
99844: LD_VAR 0 1
99848: PPUSH
99849: CALL_OW 250
99853: PPUSH
99854: LD_VAR 0 1
99858: PPUSH
99859: CALL_OW 251
99863: PPUSH
99864: LD_VAR 0 2
99868: PPUSH
99869: CALL 73228 0 4
99873: PUSH
99874: LD_INT 4
99876: ARRAY
99877: ST_TO_ADDR
// end ;
99878: LD_VAR 0 3
99882: RET
// export function PlayerSeeMe ( unit ) ; begin
99883: LD_INT 0
99885: PPUSH
// result := See ( your_side , unit ) ;
99886: LD_ADDR_VAR 0 2
99890: PUSH
99891: LD_OWVAR 2
99895: PPUSH
99896: LD_VAR 0 1
99900: PPUSH
99901: CALL_OW 292
99905: ST_TO_ADDR
// end ;
99906: LD_VAR 0 2
99910: RET
// export function ReverseDir ( unit ) ; begin
99911: LD_INT 0
99913: PPUSH
// if not unit then
99914: LD_VAR 0 1
99918: NOT
99919: IFFALSE 99923
// exit ;
99921: GO 99946
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99923: LD_ADDR_VAR 0 2
99927: PUSH
99928: LD_VAR 0 1
99932: PPUSH
99933: CALL_OW 254
99937: PUSH
99938: LD_INT 3
99940: PLUS
99941: PUSH
99942: LD_INT 6
99944: MOD
99945: ST_TO_ADDR
// end ;
99946: LD_VAR 0 2
99950: RET
// export function ReverseArray ( array ) ; var i ; begin
99951: LD_INT 0
99953: PPUSH
99954: PPUSH
// if not array then
99955: LD_VAR 0 1
99959: NOT
99960: IFFALSE 99964
// exit ;
99962: GO 100019
// result := [ ] ;
99964: LD_ADDR_VAR 0 2
99968: PUSH
99969: EMPTY
99970: ST_TO_ADDR
// for i := array downto 1 do
99971: LD_ADDR_VAR 0 3
99975: PUSH
99976: DOUBLE
99977: LD_VAR 0 1
99981: INC
99982: ST_TO_ADDR
99983: LD_INT 1
99985: PUSH
99986: FOR_DOWNTO
99987: IFFALSE 100017
// result := Join ( result , array [ i ] ) ;
99989: LD_ADDR_VAR 0 2
99993: PUSH
99994: LD_VAR 0 2
99998: PPUSH
99999: LD_VAR 0 1
100003: PUSH
100004: LD_VAR 0 3
100008: ARRAY
100009: PPUSH
100010: CALL 104644 0 2
100014: ST_TO_ADDR
100015: GO 99986
100017: POP
100018: POP
// end ;
100019: LD_VAR 0 2
100023: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
100024: LD_INT 0
100026: PPUSH
100027: PPUSH
100028: PPUSH
100029: PPUSH
100030: PPUSH
100031: PPUSH
// if not unit or not hexes then
100032: LD_VAR 0 1
100036: NOT
100037: PUSH
100038: LD_VAR 0 2
100042: NOT
100043: OR
100044: IFFALSE 100048
// exit ;
100046: GO 100171
// dist := 9999 ;
100048: LD_ADDR_VAR 0 5
100052: PUSH
100053: LD_INT 9999
100055: ST_TO_ADDR
// for i = 1 to hexes do
100056: LD_ADDR_VAR 0 4
100060: PUSH
100061: DOUBLE
100062: LD_INT 1
100064: DEC
100065: ST_TO_ADDR
100066: LD_VAR 0 2
100070: PUSH
100071: FOR_TO
100072: IFFALSE 100159
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
100074: LD_ADDR_VAR 0 6
100078: PUSH
100079: LD_VAR 0 1
100083: PPUSH
100084: LD_VAR 0 2
100088: PUSH
100089: LD_VAR 0 4
100093: ARRAY
100094: PUSH
100095: LD_INT 1
100097: ARRAY
100098: PPUSH
100099: LD_VAR 0 2
100103: PUSH
100104: LD_VAR 0 4
100108: ARRAY
100109: PUSH
100110: LD_INT 2
100112: ARRAY
100113: PPUSH
100114: CALL_OW 297
100118: ST_TO_ADDR
// if tdist < dist then
100119: LD_VAR 0 6
100123: PUSH
100124: LD_VAR 0 5
100128: LESS
100129: IFFALSE 100157
// begin hex := hexes [ i ] ;
100131: LD_ADDR_VAR 0 8
100135: PUSH
100136: LD_VAR 0 2
100140: PUSH
100141: LD_VAR 0 4
100145: ARRAY
100146: ST_TO_ADDR
// dist := tdist ;
100147: LD_ADDR_VAR 0 5
100151: PUSH
100152: LD_VAR 0 6
100156: ST_TO_ADDR
// end ; end ;
100157: GO 100071
100159: POP
100160: POP
// result := hex ;
100161: LD_ADDR_VAR 0 3
100165: PUSH
100166: LD_VAR 0 8
100170: ST_TO_ADDR
// end ;
100171: LD_VAR 0 3
100175: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
100176: LD_INT 0
100178: PPUSH
100179: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
100180: LD_VAR 0 1
100184: NOT
100185: PUSH
100186: LD_VAR 0 1
100190: PUSH
100191: LD_INT 21
100193: PUSH
100194: LD_INT 2
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: LD_INT 23
100203: PUSH
100204: LD_INT 2
100206: PUSH
100207: EMPTY
100208: LIST
100209: LIST
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: PPUSH
100215: CALL_OW 69
100219: IN
100220: NOT
100221: OR
100222: IFFALSE 100226
// exit ;
100224: GO 100273
// for i = 1 to 3 do
100226: LD_ADDR_VAR 0 3
100230: PUSH
100231: DOUBLE
100232: LD_INT 1
100234: DEC
100235: ST_TO_ADDR
100236: LD_INT 3
100238: PUSH
100239: FOR_TO
100240: IFFALSE 100271
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
100242: LD_VAR 0 1
100246: PPUSH
100247: CALL_OW 250
100251: PPUSH
100252: LD_VAR 0 1
100256: PPUSH
100257: CALL_OW 251
100261: PPUSH
100262: LD_INT 1
100264: PPUSH
100265: CALL_OW 453
100269: GO 100239
100271: POP
100272: POP
// end ;
100273: LD_VAR 0 2
100277: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
100278: LD_INT 0
100280: PPUSH
100281: PPUSH
100282: PPUSH
100283: PPUSH
100284: PPUSH
100285: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
100286: LD_VAR 0 1
100290: NOT
100291: PUSH
100292: LD_VAR 0 2
100296: NOT
100297: OR
100298: PUSH
100299: LD_VAR 0 1
100303: PPUSH
100304: CALL_OW 314
100308: OR
100309: IFFALSE 100313
// exit ;
100311: GO 100754
// x := GetX ( enemy_unit ) ;
100313: LD_ADDR_VAR 0 7
100317: PUSH
100318: LD_VAR 0 2
100322: PPUSH
100323: CALL_OW 250
100327: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
100328: LD_ADDR_VAR 0 8
100332: PUSH
100333: LD_VAR 0 2
100337: PPUSH
100338: CALL_OW 251
100342: ST_TO_ADDR
// if not x or not y then
100343: LD_VAR 0 7
100347: NOT
100348: PUSH
100349: LD_VAR 0 8
100353: NOT
100354: OR
100355: IFFALSE 100359
// exit ;
100357: GO 100754
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
100359: LD_ADDR_VAR 0 6
100363: PUSH
100364: LD_VAR 0 7
100368: PPUSH
100369: LD_INT 0
100371: PPUSH
100372: LD_INT 4
100374: PPUSH
100375: CALL_OW 272
100379: PUSH
100380: LD_VAR 0 8
100384: PPUSH
100385: LD_INT 0
100387: PPUSH
100388: LD_INT 4
100390: PPUSH
100391: CALL_OW 273
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PUSH
100400: LD_VAR 0 7
100404: PPUSH
100405: LD_INT 1
100407: PPUSH
100408: LD_INT 4
100410: PPUSH
100411: CALL_OW 272
100415: PUSH
100416: LD_VAR 0 8
100420: PPUSH
100421: LD_INT 1
100423: PPUSH
100424: LD_INT 4
100426: PPUSH
100427: CALL_OW 273
100431: PUSH
100432: EMPTY
100433: LIST
100434: LIST
100435: PUSH
100436: LD_VAR 0 7
100440: PPUSH
100441: LD_INT 2
100443: PPUSH
100444: LD_INT 4
100446: PPUSH
100447: CALL_OW 272
100451: PUSH
100452: LD_VAR 0 8
100456: PPUSH
100457: LD_INT 2
100459: PPUSH
100460: LD_INT 4
100462: PPUSH
100463: CALL_OW 273
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: PUSH
100472: LD_VAR 0 7
100476: PPUSH
100477: LD_INT 3
100479: PPUSH
100480: LD_INT 4
100482: PPUSH
100483: CALL_OW 272
100487: PUSH
100488: LD_VAR 0 8
100492: PPUSH
100493: LD_INT 3
100495: PPUSH
100496: LD_INT 4
100498: PPUSH
100499: CALL_OW 273
100503: PUSH
100504: EMPTY
100505: LIST
100506: LIST
100507: PUSH
100508: LD_VAR 0 7
100512: PPUSH
100513: LD_INT 4
100515: PPUSH
100516: LD_INT 4
100518: PPUSH
100519: CALL_OW 272
100523: PUSH
100524: LD_VAR 0 8
100528: PPUSH
100529: LD_INT 4
100531: PPUSH
100532: LD_INT 4
100534: PPUSH
100535: CALL_OW 273
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: LD_VAR 0 7
100548: PPUSH
100549: LD_INT 5
100551: PPUSH
100552: LD_INT 4
100554: PPUSH
100555: CALL_OW 272
100559: PUSH
100560: LD_VAR 0 8
100564: PPUSH
100565: LD_INT 5
100567: PPUSH
100568: LD_INT 4
100570: PPUSH
100571: CALL_OW 273
100575: PUSH
100576: EMPTY
100577: LIST
100578: LIST
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: LIST
100587: ST_TO_ADDR
// for i = tmp downto 1 do
100588: LD_ADDR_VAR 0 4
100592: PUSH
100593: DOUBLE
100594: LD_VAR 0 6
100598: INC
100599: ST_TO_ADDR
100600: LD_INT 1
100602: PUSH
100603: FOR_DOWNTO
100604: IFFALSE 100705
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
100606: LD_VAR 0 6
100610: PUSH
100611: LD_VAR 0 4
100615: ARRAY
100616: PUSH
100617: LD_INT 1
100619: ARRAY
100620: PPUSH
100621: LD_VAR 0 6
100625: PUSH
100626: LD_VAR 0 4
100630: ARRAY
100631: PUSH
100632: LD_INT 2
100634: ARRAY
100635: PPUSH
100636: CALL_OW 488
100640: NOT
100641: PUSH
100642: LD_VAR 0 6
100646: PUSH
100647: LD_VAR 0 4
100651: ARRAY
100652: PUSH
100653: LD_INT 1
100655: ARRAY
100656: PPUSH
100657: LD_VAR 0 6
100661: PUSH
100662: LD_VAR 0 4
100666: ARRAY
100667: PUSH
100668: LD_INT 2
100670: ARRAY
100671: PPUSH
100672: CALL_OW 428
100676: PUSH
100677: LD_INT 0
100679: NONEQUAL
100680: OR
100681: IFFALSE 100703
// tmp := Delete ( tmp , i ) ;
100683: LD_ADDR_VAR 0 6
100687: PUSH
100688: LD_VAR 0 6
100692: PPUSH
100693: LD_VAR 0 4
100697: PPUSH
100698: CALL_OW 3
100702: ST_TO_ADDR
100703: GO 100603
100705: POP
100706: POP
// j := GetClosestHex ( unit , tmp ) ;
100707: LD_ADDR_VAR 0 5
100711: PUSH
100712: LD_VAR 0 1
100716: PPUSH
100717: LD_VAR 0 6
100721: PPUSH
100722: CALL 100024 0 2
100726: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
100727: LD_VAR 0 1
100731: PPUSH
100732: LD_VAR 0 5
100736: PUSH
100737: LD_INT 1
100739: ARRAY
100740: PPUSH
100741: LD_VAR 0 5
100745: PUSH
100746: LD_INT 2
100748: ARRAY
100749: PPUSH
100750: CALL_OW 111
// end ;
100754: LD_VAR 0 3
100758: RET
// export function PrepareApemanSoldier ( ) ; begin
100759: LD_INT 0
100761: PPUSH
// uc_nation := 0 ;
100762: LD_ADDR_OWVAR 21
100766: PUSH
100767: LD_INT 0
100769: ST_TO_ADDR
// hc_sex := sex_male ;
100770: LD_ADDR_OWVAR 27
100774: PUSH
100775: LD_INT 1
100777: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
100778: LD_ADDR_OWVAR 28
100782: PUSH
100783: LD_INT 15
100785: ST_TO_ADDR
// hc_gallery :=  ;
100786: LD_ADDR_OWVAR 33
100790: PUSH
100791: LD_STRING 
100793: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100794: LD_ADDR_OWVAR 31
100798: PUSH
100799: LD_INT 0
100801: PPUSH
100802: LD_INT 3
100804: PPUSH
100805: CALL_OW 12
100809: PUSH
100810: LD_INT 0
100812: PPUSH
100813: LD_INT 3
100815: PPUSH
100816: CALL_OW 12
100820: PUSH
100821: LD_INT 0
100823: PUSH
100824: LD_INT 0
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: LIST
100831: LIST
100832: ST_TO_ADDR
// end ;
100833: LD_VAR 0 1
100837: RET
// export function PrepareApemanEngineer ( ) ; begin
100838: LD_INT 0
100840: PPUSH
// uc_nation := 0 ;
100841: LD_ADDR_OWVAR 21
100845: PUSH
100846: LD_INT 0
100848: ST_TO_ADDR
// hc_sex := sex_male ;
100849: LD_ADDR_OWVAR 27
100853: PUSH
100854: LD_INT 1
100856: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
100857: LD_ADDR_OWVAR 28
100861: PUSH
100862: LD_INT 16
100864: ST_TO_ADDR
// hc_gallery :=  ;
100865: LD_ADDR_OWVAR 33
100869: PUSH
100870: LD_STRING 
100872: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100873: LD_ADDR_OWVAR 31
100877: PUSH
100878: LD_INT 0
100880: PPUSH
100881: LD_INT 3
100883: PPUSH
100884: CALL_OW 12
100888: PUSH
100889: LD_INT 0
100891: PPUSH
100892: LD_INT 3
100894: PPUSH
100895: CALL_OW 12
100899: PUSH
100900: LD_INT 0
100902: PUSH
100903: LD_INT 0
100905: PUSH
100906: EMPTY
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: ST_TO_ADDR
// end ;
100912: LD_VAR 0 1
100916: RET
// export function PrepareApeman ( agressivity ) ; begin
100917: LD_INT 0
100919: PPUSH
// uc_side := 0 ;
100920: LD_ADDR_OWVAR 20
100924: PUSH
100925: LD_INT 0
100927: ST_TO_ADDR
// uc_nation := 0 ;
100928: LD_ADDR_OWVAR 21
100932: PUSH
100933: LD_INT 0
100935: ST_TO_ADDR
// hc_sex := sex_male ;
100936: LD_ADDR_OWVAR 27
100940: PUSH
100941: LD_INT 1
100943: ST_TO_ADDR
// hc_class := class_apeman ;
100944: LD_ADDR_OWVAR 28
100948: PUSH
100949: LD_INT 12
100951: ST_TO_ADDR
// hc_gallery :=  ;
100952: LD_ADDR_OWVAR 33
100956: PUSH
100957: LD_STRING 
100959: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
100960: LD_ADDR_OWVAR 35
100964: PUSH
100965: LD_VAR 0 1
100969: NEG
100970: PPUSH
100971: LD_VAR 0 1
100975: PPUSH
100976: CALL_OW 12
100980: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
100981: LD_ADDR_OWVAR 31
100985: PUSH
100986: LD_INT 0
100988: PPUSH
100989: LD_INT 3
100991: PPUSH
100992: CALL_OW 12
100996: PUSH
100997: LD_INT 0
100999: PPUSH
101000: LD_INT 3
101002: PPUSH
101003: CALL_OW 12
101007: PUSH
101008: LD_INT 0
101010: PUSH
101011: LD_INT 0
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: LIST
101018: LIST
101019: ST_TO_ADDR
// end ;
101020: LD_VAR 0 2
101024: RET
// export function PrepareTiger ( agressivity ) ; begin
101025: LD_INT 0
101027: PPUSH
// uc_side := 0 ;
101028: LD_ADDR_OWVAR 20
101032: PUSH
101033: LD_INT 0
101035: ST_TO_ADDR
// uc_nation := 0 ;
101036: LD_ADDR_OWVAR 21
101040: PUSH
101041: LD_INT 0
101043: ST_TO_ADDR
// hc_class := class_tiger ;
101044: LD_ADDR_OWVAR 28
101048: PUSH
101049: LD_INT 14
101051: ST_TO_ADDR
// hc_gallery :=  ;
101052: LD_ADDR_OWVAR 33
101056: PUSH
101057: LD_STRING 
101059: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
101060: LD_ADDR_OWVAR 35
101064: PUSH
101065: LD_VAR 0 1
101069: NEG
101070: PPUSH
101071: LD_VAR 0 1
101075: PPUSH
101076: CALL_OW 12
101080: ST_TO_ADDR
// end ;
101081: LD_VAR 0 2
101085: RET
// export function PrepareEnchidna ( ) ; begin
101086: LD_INT 0
101088: PPUSH
// uc_side := 0 ;
101089: LD_ADDR_OWVAR 20
101093: PUSH
101094: LD_INT 0
101096: ST_TO_ADDR
// uc_nation := 0 ;
101097: LD_ADDR_OWVAR 21
101101: PUSH
101102: LD_INT 0
101104: ST_TO_ADDR
// hc_class := class_baggie ;
101105: LD_ADDR_OWVAR 28
101109: PUSH
101110: LD_INT 13
101112: ST_TO_ADDR
// hc_gallery :=  ;
101113: LD_ADDR_OWVAR 33
101117: PUSH
101118: LD_STRING 
101120: ST_TO_ADDR
// end ;
101121: LD_VAR 0 1
101125: RET
// export function PrepareFrog ( ) ; begin
101126: LD_INT 0
101128: PPUSH
// uc_side := 0 ;
101129: LD_ADDR_OWVAR 20
101133: PUSH
101134: LD_INT 0
101136: ST_TO_ADDR
// uc_nation := 0 ;
101137: LD_ADDR_OWVAR 21
101141: PUSH
101142: LD_INT 0
101144: ST_TO_ADDR
// hc_class := class_frog ;
101145: LD_ADDR_OWVAR 28
101149: PUSH
101150: LD_INT 19
101152: ST_TO_ADDR
// hc_gallery :=  ;
101153: LD_ADDR_OWVAR 33
101157: PUSH
101158: LD_STRING 
101160: ST_TO_ADDR
// end ;
101161: LD_VAR 0 1
101165: RET
// export function PrepareFish ( ) ; begin
101166: LD_INT 0
101168: PPUSH
// uc_side := 0 ;
101169: LD_ADDR_OWVAR 20
101173: PUSH
101174: LD_INT 0
101176: ST_TO_ADDR
// uc_nation := 0 ;
101177: LD_ADDR_OWVAR 21
101181: PUSH
101182: LD_INT 0
101184: ST_TO_ADDR
// hc_class := class_fish ;
101185: LD_ADDR_OWVAR 28
101189: PUSH
101190: LD_INT 20
101192: ST_TO_ADDR
// hc_gallery :=  ;
101193: LD_ADDR_OWVAR 33
101197: PUSH
101198: LD_STRING 
101200: ST_TO_ADDR
// end ;
101201: LD_VAR 0 1
101205: RET
// export function PrepareBird ( ) ; begin
101206: LD_INT 0
101208: PPUSH
// uc_side := 0 ;
101209: LD_ADDR_OWVAR 20
101213: PUSH
101214: LD_INT 0
101216: ST_TO_ADDR
// uc_nation := 0 ;
101217: LD_ADDR_OWVAR 21
101221: PUSH
101222: LD_INT 0
101224: ST_TO_ADDR
// hc_class := class_phororhacos ;
101225: LD_ADDR_OWVAR 28
101229: PUSH
101230: LD_INT 18
101232: ST_TO_ADDR
// hc_gallery :=  ;
101233: LD_ADDR_OWVAR 33
101237: PUSH
101238: LD_STRING 
101240: ST_TO_ADDR
// end ;
101241: LD_VAR 0 1
101245: RET
// export function PrepareHorse ( ) ; begin
101246: LD_INT 0
101248: PPUSH
// uc_side := 0 ;
101249: LD_ADDR_OWVAR 20
101253: PUSH
101254: LD_INT 0
101256: ST_TO_ADDR
// uc_nation := 0 ;
101257: LD_ADDR_OWVAR 21
101261: PUSH
101262: LD_INT 0
101264: ST_TO_ADDR
// hc_class := class_horse ;
101265: LD_ADDR_OWVAR 28
101269: PUSH
101270: LD_INT 21
101272: ST_TO_ADDR
// hc_gallery :=  ;
101273: LD_ADDR_OWVAR 33
101277: PUSH
101278: LD_STRING 
101280: ST_TO_ADDR
// end ;
101281: LD_VAR 0 1
101285: RET
// export function PrepareMastodont ( ) ; begin
101286: LD_INT 0
101288: PPUSH
// uc_side := 0 ;
101289: LD_ADDR_OWVAR 20
101293: PUSH
101294: LD_INT 0
101296: ST_TO_ADDR
// uc_nation := 0 ;
101297: LD_ADDR_OWVAR 21
101301: PUSH
101302: LD_INT 0
101304: ST_TO_ADDR
// vc_chassis := class_mastodont ;
101305: LD_ADDR_OWVAR 37
101309: PUSH
101310: LD_INT 31
101312: ST_TO_ADDR
// vc_control := control_rider ;
101313: LD_ADDR_OWVAR 38
101317: PUSH
101318: LD_INT 4
101320: ST_TO_ADDR
// end ;
101321: LD_VAR 0 1
101325: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
101326: LD_INT 0
101328: PPUSH
101329: PPUSH
101330: PPUSH
// uc_side = 0 ;
101331: LD_ADDR_OWVAR 20
101335: PUSH
101336: LD_INT 0
101338: ST_TO_ADDR
// uc_nation = 0 ;
101339: LD_ADDR_OWVAR 21
101343: PUSH
101344: LD_INT 0
101346: ST_TO_ADDR
// InitHc_All ( ) ;
101347: CALL_OW 584
// InitVc ;
101351: CALL_OW 20
// if mastodonts then
101355: LD_VAR 0 6
101359: IFFALSE 101426
// for i = 1 to mastodonts do
101361: LD_ADDR_VAR 0 11
101365: PUSH
101366: DOUBLE
101367: LD_INT 1
101369: DEC
101370: ST_TO_ADDR
101371: LD_VAR 0 6
101375: PUSH
101376: FOR_TO
101377: IFFALSE 101424
// begin vc_chassis := 31 ;
101379: LD_ADDR_OWVAR 37
101383: PUSH
101384: LD_INT 31
101386: ST_TO_ADDR
// vc_control := control_rider ;
101387: LD_ADDR_OWVAR 38
101391: PUSH
101392: LD_INT 4
101394: ST_TO_ADDR
// animal := CreateVehicle ;
101395: LD_ADDR_VAR 0 12
101399: PUSH
101400: CALL_OW 45
101404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101405: LD_VAR 0 12
101409: PPUSH
101410: LD_VAR 0 8
101414: PPUSH
101415: LD_INT 0
101417: PPUSH
101418: CALL 103561 0 3
// end ;
101422: GO 101376
101424: POP
101425: POP
// if horses then
101426: LD_VAR 0 5
101430: IFFALSE 101497
// for i = 1 to horses do
101432: LD_ADDR_VAR 0 11
101436: PUSH
101437: DOUBLE
101438: LD_INT 1
101440: DEC
101441: ST_TO_ADDR
101442: LD_VAR 0 5
101446: PUSH
101447: FOR_TO
101448: IFFALSE 101495
// begin hc_class := 21 ;
101450: LD_ADDR_OWVAR 28
101454: PUSH
101455: LD_INT 21
101457: ST_TO_ADDR
// hc_gallery :=  ;
101458: LD_ADDR_OWVAR 33
101462: PUSH
101463: LD_STRING 
101465: ST_TO_ADDR
// animal := CreateHuman ;
101466: LD_ADDR_VAR 0 12
101470: PUSH
101471: CALL_OW 44
101475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101476: LD_VAR 0 12
101480: PPUSH
101481: LD_VAR 0 8
101485: PPUSH
101486: LD_INT 0
101488: PPUSH
101489: CALL 103561 0 3
// end ;
101493: GO 101447
101495: POP
101496: POP
// if birds then
101497: LD_VAR 0 1
101501: IFFALSE 101568
// for i = 1 to birds do
101503: LD_ADDR_VAR 0 11
101507: PUSH
101508: DOUBLE
101509: LD_INT 1
101511: DEC
101512: ST_TO_ADDR
101513: LD_VAR 0 1
101517: PUSH
101518: FOR_TO
101519: IFFALSE 101566
// begin hc_class = 18 ;
101521: LD_ADDR_OWVAR 28
101525: PUSH
101526: LD_INT 18
101528: ST_TO_ADDR
// hc_gallery =  ;
101529: LD_ADDR_OWVAR 33
101533: PUSH
101534: LD_STRING 
101536: ST_TO_ADDR
// animal := CreateHuman ;
101537: LD_ADDR_VAR 0 12
101541: PUSH
101542: CALL_OW 44
101546: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101547: LD_VAR 0 12
101551: PPUSH
101552: LD_VAR 0 8
101556: PPUSH
101557: LD_INT 0
101559: PPUSH
101560: CALL 103561 0 3
// end ;
101564: GO 101518
101566: POP
101567: POP
// if tigers then
101568: LD_VAR 0 2
101572: IFFALSE 101656
// for i = 1 to tigers do
101574: LD_ADDR_VAR 0 11
101578: PUSH
101579: DOUBLE
101580: LD_INT 1
101582: DEC
101583: ST_TO_ADDR
101584: LD_VAR 0 2
101588: PUSH
101589: FOR_TO
101590: IFFALSE 101654
// begin hc_class = class_tiger ;
101592: LD_ADDR_OWVAR 28
101596: PUSH
101597: LD_INT 14
101599: ST_TO_ADDR
// hc_gallery =  ;
101600: LD_ADDR_OWVAR 33
101604: PUSH
101605: LD_STRING 
101607: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
101608: LD_ADDR_OWVAR 35
101612: PUSH
101613: LD_INT 7
101615: NEG
101616: PPUSH
101617: LD_INT 7
101619: PPUSH
101620: CALL_OW 12
101624: ST_TO_ADDR
// animal := CreateHuman ;
101625: LD_ADDR_VAR 0 12
101629: PUSH
101630: CALL_OW 44
101634: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101635: LD_VAR 0 12
101639: PPUSH
101640: LD_VAR 0 8
101644: PPUSH
101645: LD_INT 0
101647: PPUSH
101648: CALL 103561 0 3
// end ;
101652: GO 101589
101654: POP
101655: POP
// if apemans then
101656: LD_VAR 0 3
101660: IFFALSE 101783
// for i = 1 to apemans do
101662: LD_ADDR_VAR 0 11
101666: PUSH
101667: DOUBLE
101668: LD_INT 1
101670: DEC
101671: ST_TO_ADDR
101672: LD_VAR 0 3
101676: PUSH
101677: FOR_TO
101678: IFFALSE 101781
// begin hc_class = class_apeman ;
101680: LD_ADDR_OWVAR 28
101684: PUSH
101685: LD_INT 12
101687: ST_TO_ADDR
// hc_gallery =  ;
101688: LD_ADDR_OWVAR 33
101692: PUSH
101693: LD_STRING 
101695: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
101696: LD_ADDR_OWVAR 35
101700: PUSH
101701: LD_INT 2
101703: NEG
101704: PPUSH
101705: LD_INT 2
101707: PPUSH
101708: CALL_OW 12
101712: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
101713: LD_ADDR_OWVAR 31
101717: PUSH
101718: LD_INT 1
101720: PPUSH
101721: LD_INT 3
101723: PPUSH
101724: CALL_OW 12
101728: PUSH
101729: LD_INT 1
101731: PPUSH
101732: LD_INT 3
101734: PPUSH
101735: CALL_OW 12
101739: PUSH
101740: LD_INT 0
101742: PUSH
101743: LD_INT 0
101745: PUSH
101746: EMPTY
101747: LIST
101748: LIST
101749: LIST
101750: LIST
101751: ST_TO_ADDR
// animal := CreateHuman ;
101752: LD_ADDR_VAR 0 12
101756: PUSH
101757: CALL_OW 44
101761: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101762: LD_VAR 0 12
101766: PPUSH
101767: LD_VAR 0 8
101771: PPUSH
101772: LD_INT 0
101774: PPUSH
101775: CALL 103561 0 3
// end ;
101779: GO 101677
101781: POP
101782: POP
// if enchidnas then
101783: LD_VAR 0 4
101787: IFFALSE 101854
// for i = 1 to enchidnas do
101789: LD_ADDR_VAR 0 11
101793: PUSH
101794: DOUBLE
101795: LD_INT 1
101797: DEC
101798: ST_TO_ADDR
101799: LD_VAR 0 4
101803: PUSH
101804: FOR_TO
101805: IFFALSE 101852
// begin hc_class = 13 ;
101807: LD_ADDR_OWVAR 28
101811: PUSH
101812: LD_INT 13
101814: ST_TO_ADDR
// hc_gallery =  ;
101815: LD_ADDR_OWVAR 33
101819: PUSH
101820: LD_STRING 
101822: ST_TO_ADDR
// animal := CreateHuman ;
101823: LD_ADDR_VAR 0 12
101827: PUSH
101828: CALL_OW 44
101832: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
101833: LD_VAR 0 12
101837: PPUSH
101838: LD_VAR 0 8
101842: PPUSH
101843: LD_INT 0
101845: PPUSH
101846: CALL 103561 0 3
// end ;
101850: GO 101804
101852: POP
101853: POP
// if fishes then
101854: LD_VAR 0 7
101858: IFFALSE 101925
// for i = 1 to fishes do
101860: LD_ADDR_VAR 0 11
101864: PUSH
101865: DOUBLE
101866: LD_INT 1
101868: DEC
101869: ST_TO_ADDR
101870: LD_VAR 0 7
101874: PUSH
101875: FOR_TO
101876: IFFALSE 101923
// begin hc_class = 20 ;
101878: LD_ADDR_OWVAR 28
101882: PUSH
101883: LD_INT 20
101885: ST_TO_ADDR
// hc_gallery =  ;
101886: LD_ADDR_OWVAR 33
101890: PUSH
101891: LD_STRING 
101893: ST_TO_ADDR
// animal := CreateHuman ;
101894: LD_ADDR_VAR 0 12
101898: PUSH
101899: CALL_OW 44
101903: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
101904: LD_VAR 0 12
101908: PPUSH
101909: LD_VAR 0 9
101913: PPUSH
101914: LD_INT 0
101916: PPUSH
101917: CALL 103561 0 3
// end ;
101921: GO 101875
101923: POP
101924: POP
// end ;
101925: LD_VAR 0 10
101929: RET
// export function WantHeal ( sci , unit ) ; begin
101930: LD_INT 0
101932: PPUSH
// if GetTaskList ( sci ) > 0 then
101933: LD_VAR 0 1
101937: PPUSH
101938: CALL_OW 437
101942: PUSH
101943: LD_INT 0
101945: GREATER
101946: IFFALSE 102016
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
101948: LD_VAR 0 1
101952: PPUSH
101953: CALL_OW 437
101957: PUSH
101958: LD_INT 1
101960: ARRAY
101961: PUSH
101962: LD_INT 1
101964: ARRAY
101965: PUSH
101966: LD_STRING l
101968: EQUAL
101969: PUSH
101970: LD_VAR 0 1
101974: PPUSH
101975: CALL_OW 437
101979: PUSH
101980: LD_INT 1
101982: ARRAY
101983: PUSH
101984: LD_INT 4
101986: ARRAY
101987: PUSH
101988: LD_VAR 0 2
101992: EQUAL
101993: AND
101994: IFFALSE 102006
// result := true else
101996: LD_ADDR_VAR 0 3
102000: PUSH
102001: LD_INT 1
102003: ST_TO_ADDR
102004: GO 102014
// result := false ;
102006: LD_ADDR_VAR 0 3
102010: PUSH
102011: LD_INT 0
102013: ST_TO_ADDR
// end else
102014: GO 102024
// result := false ;
102016: LD_ADDR_VAR 0 3
102020: PUSH
102021: LD_INT 0
102023: ST_TO_ADDR
// end ;
102024: LD_VAR 0 3
102028: RET
// export function HealTarget ( sci ) ; begin
102029: LD_INT 0
102031: PPUSH
// if not sci then
102032: LD_VAR 0 1
102036: NOT
102037: IFFALSE 102041
// exit ;
102039: GO 102106
// result := 0 ;
102041: LD_ADDR_VAR 0 2
102045: PUSH
102046: LD_INT 0
102048: ST_TO_ADDR
// if GetTaskList ( sci ) then
102049: LD_VAR 0 1
102053: PPUSH
102054: CALL_OW 437
102058: IFFALSE 102106
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
102060: LD_VAR 0 1
102064: PPUSH
102065: CALL_OW 437
102069: PUSH
102070: LD_INT 1
102072: ARRAY
102073: PUSH
102074: LD_INT 1
102076: ARRAY
102077: PUSH
102078: LD_STRING l
102080: EQUAL
102081: IFFALSE 102106
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
102083: LD_ADDR_VAR 0 2
102087: PUSH
102088: LD_VAR 0 1
102092: PPUSH
102093: CALL_OW 437
102097: PUSH
102098: LD_INT 1
102100: ARRAY
102101: PUSH
102102: LD_INT 4
102104: ARRAY
102105: ST_TO_ADDR
// end ;
102106: LD_VAR 0 2
102110: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102111: LD_INT 0
102113: PPUSH
102114: PPUSH
102115: PPUSH
102116: PPUSH
// if not base_units then
102117: LD_VAR 0 1
102121: NOT
102122: IFFALSE 102126
// exit ;
102124: GO 102213
// result := false ;
102126: LD_ADDR_VAR 0 2
102130: PUSH
102131: LD_INT 0
102133: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102134: LD_ADDR_VAR 0 5
102138: PUSH
102139: LD_VAR 0 1
102143: PPUSH
102144: LD_INT 21
102146: PUSH
102147: LD_INT 3
102149: PUSH
102150: EMPTY
102151: LIST
102152: LIST
102153: PPUSH
102154: CALL_OW 72
102158: ST_TO_ADDR
// if not tmp then
102159: LD_VAR 0 5
102163: NOT
102164: IFFALSE 102168
// exit ;
102166: GO 102213
// for i in tmp do
102168: LD_ADDR_VAR 0 3
102172: PUSH
102173: LD_VAR 0 5
102177: PUSH
102178: FOR_IN
102179: IFFALSE 102211
// begin result := EnemyInRange ( i , 22 ) ;
102181: LD_ADDR_VAR 0 2
102185: PUSH
102186: LD_VAR 0 3
102190: PPUSH
102191: LD_INT 22
102193: PPUSH
102194: CALL 99826 0 2
102198: ST_TO_ADDR
// if result then
102199: LD_VAR 0 2
102203: IFFALSE 102209
// exit ;
102205: POP
102206: POP
102207: GO 102213
// end ;
102209: GO 102178
102211: POP
102212: POP
// end ;
102213: LD_VAR 0 2
102217: RET
// export function FilterByTag ( units , tag ) ; begin
102218: LD_INT 0
102220: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
102221: LD_ADDR_VAR 0 3
102225: PUSH
102226: LD_VAR 0 1
102230: PPUSH
102231: LD_INT 120
102233: PUSH
102234: LD_VAR 0 2
102238: PUSH
102239: EMPTY
102240: LIST
102241: LIST
102242: PPUSH
102243: CALL_OW 72
102247: ST_TO_ADDR
// end ;
102248: LD_VAR 0 3
102252: RET
// export function IsDriver ( un ) ; begin
102253: LD_INT 0
102255: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
102256: LD_ADDR_VAR 0 2
102260: PUSH
102261: LD_VAR 0 1
102265: PUSH
102266: LD_INT 55
102268: PUSH
102269: EMPTY
102270: LIST
102271: PPUSH
102272: CALL_OW 69
102276: IN
102277: ST_TO_ADDR
// end ;
102278: LD_VAR 0 2
102282: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
102283: LD_INT 0
102285: PPUSH
102286: PPUSH
// list := [ ] ;
102287: LD_ADDR_VAR 0 5
102291: PUSH
102292: EMPTY
102293: ST_TO_ADDR
// case d of 0 :
102294: LD_VAR 0 3
102298: PUSH
102299: LD_INT 0
102301: DOUBLE
102302: EQUAL
102303: IFTRUE 102307
102305: GO 102440
102307: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
102308: LD_ADDR_VAR 0 5
102312: PUSH
102313: LD_VAR 0 1
102317: PUSH
102318: LD_INT 4
102320: MINUS
102321: PUSH
102322: LD_VAR 0 2
102326: PUSH
102327: LD_INT 4
102329: MINUS
102330: PUSH
102331: LD_INT 2
102333: PUSH
102334: EMPTY
102335: LIST
102336: LIST
102337: LIST
102338: PUSH
102339: LD_VAR 0 1
102343: PUSH
102344: LD_INT 3
102346: MINUS
102347: PUSH
102348: LD_VAR 0 2
102352: PUSH
102353: LD_INT 1
102355: PUSH
102356: EMPTY
102357: LIST
102358: LIST
102359: LIST
102360: PUSH
102361: LD_VAR 0 1
102365: PUSH
102366: LD_INT 4
102368: PLUS
102369: PUSH
102370: LD_VAR 0 2
102374: PUSH
102375: LD_INT 4
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: LIST
102382: PUSH
102383: LD_VAR 0 1
102387: PUSH
102388: LD_INT 3
102390: PLUS
102391: PUSH
102392: LD_VAR 0 2
102396: PUSH
102397: LD_INT 3
102399: PLUS
102400: PUSH
102401: LD_INT 5
102403: PUSH
102404: EMPTY
102405: LIST
102406: LIST
102407: LIST
102408: PUSH
102409: LD_VAR 0 1
102413: PUSH
102414: LD_VAR 0 2
102418: PUSH
102419: LD_INT 4
102421: PLUS
102422: PUSH
102423: LD_INT 0
102425: PUSH
102426: EMPTY
102427: LIST
102428: LIST
102429: LIST
102430: PUSH
102431: EMPTY
102432: LIST
102433: LIST
102434: LIST
102435: LIST
102436: LIST
102437: ST_TO_ADDR
// end ; 1 :
102438: GO 103138
102440: LD_INT 1
102442: DOUBLE
102443: EQUAL
102444: IFTRUE 102448
102446: GO 102581
102448: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
102449: LD_ADDR_VAR 0 5
102453: PUSH
102454: LD_VAR 0 1
102458: PUSH
102459: LD_VAR 0 2
102463: PUSH
102464: LD_INT 4
102466: MINUS
102467: PUSH
102468: LD_INT 3
102470: PUSH
102471: EMPTY
102472: LIST
102473: LIST
102474: LIST
102475: PUSH
102476: LD_VAR 0 1
102480: PUSH
102481: LD_INT 3
102483: MINUS
102484: PUSH
102485: LD_VAR 0 2
102489: PUSH
102490: LD_INT 3
102492: MINUS
102493: PUSH
102494: LD_INT 2
102496: PUSH
102497: EMPTY
102498: LIST
102499: LIST
102500: LIST
102501: PUSH
102502: LD_VAR 0 1
102506: PUSH
102507: LD_INT 4
102509: MINUS
102510: PUSH
102511: LD_VAR 0 2
102515: PUSH
102516: LD_INT 1
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: LIST
102523: PUSH
102524: LD_VAR 0 1
102528: PUSH
102529: LD_VAR 0 2
102533: PUSH
102534: LD_INT 3
102536: PLUS
102537: PUSH
102538: LD_INT 0
102540: PUSH
102541: EMPTY
102542: LIST
102543: LIST
102544: LIST
102545: PUSH
102546: LD_VAR 0 1
102550: PUSH
102551: LD_INT 4
102553: PLUS
102554: PUSH
102555: LD_VAR 0 2
102559: PUSH
102560: LD_INT 4
102562: PLUS
102563: PUSH
102564: LD_INT 5
102566: PUSH
102567: EMPTY
102568: LIST
102569: LIST
102570: LIST
102571: PUSH
102572: EMPTY
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: ST_TO_ADDR
// end ; 2 :
102579: GO 103138
102581: LD_INT 2
102583: DOUBLE
102584: EQUAL
102585: IFTRUE 102589
102587: GO 102718
102589: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
102590: LD_ADDR_VAR 0 5
102594: PUSH
102595: LD_VAR 0 1
102599: PUSH
102600: LD_VAR 0 2
102604: PUSH
102605: LD_INT 3
102607: MINUS
102608: PUSH
102609: LD_INT 3
102611: PUSH
102612: EMPTY
102613: LIST
102614: LIST
102615: LIST
102616: PUSH
102617: LD_VAR 0 1
102621: PUSH
102622: LD_INT 4
102624: PLUS
102625: PUSH
102626: LD_VAR 0 2
102630: PUSH
102631: LD_INT 4
102633: PUSH
102634: EMPTY
102635: LIST
102636: LIST
102637: LIST
102638: PUSH
102639: LD_VAR 0 1
102643: PUSH
102644: LD_VAR 0 2
102648: PUSH
102649: LD_INT 4
102651: PLUS
102652: PUSH
102653: LD_INT 0
102655: PUSH
102656: EMPTY
102657: LIST
102658: LIST
102659: LIST
102660: PUSH
102661: LD_VAR 0 1
102665: PUSH
102666: LD_INT 3
102668: MINUS
102669: PUSH
102670: LD_VAR 0 2
102674: PUSH
102675: LD_INT 1
102677: PUSH
102678: EMPTY
102679: LIST
102680: LIST
102681: LIST
102682: PUSH
102683: LD_VAR 0 1
102687: PUSH
102688: LD_INT 4
102690: MINUS
102691: PUSH
102692: LD_VAR 0 2
102696: PUSH
102697: LD_INT 4
102699: MINUS
102700: PUSH
102701: LD_INT 2
102703: PUSH
102704: EMPTY
102705: LIST
102706: LIST
102707: LIST
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: LIST
102713: LIST
102714: LIST
102715: ST_TO_ADDR
// end ; 3 :
102716: GO 103138
102718: LD_INT 3
102720: DOUBLE
102721: EQUAL
102722: IFTRUE 102726
102724: GO 102859
102726: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
102727: LD_ADDR_VAR 0 5
102731: PUSH
102732: LD_VAR 0 1
102736: PUSH
102737: LD_INT 3
102739: PLUS
102740: PUSH
102741: LD_VAR 0 2
102745: PUSH
102746: LD_INT 4
102748: PUSH
102749: EMPTY
102750: LIST
102751: LIST
102752: LIST
102753: PUSH
102754: LD_VAR 0 1
102758: PUSH
102759: LD_INT 4
102761: PLUS
102762: PUSH
102763: LD_VAR 0 2
102767: PUSH
102768: LD_INT 4
102770: PLUS
102771: PUSH
102772: LD_INT 5
102774: PUSH
102775: EMPTY
102776: LIST
102777: LIST
102778: LIST
102779: PUSH
102780: LD_VAR 0 1
102784: PUSH
102785: LD_INT 4
102787: MINUS
102788: PUSH
102789: LD_VAR 0 2
102793: PUSH
102794: LD_INT 1
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: LIST
102801: PUSH
102802: LD_VAR 0 1
102806: PUSH
102807: LD_VAR 0 2
102811: PUSH
102812: LD_INT 4
102814: MINUS
102815: PUSH
102816: LD_INT 3
102818: PUSH
102819: EMPTY
102820: LIST
102821: LIST
102822: LIST
102823: PUSH
102824: LD_VAR 0 1
102828: PUSH
102829: LD_INT 3
102831: MINUS
102832: PUSH
102833: LD_VAR 0 2
102837: PUSH
102838: LD_INT 3
102840: MINUS
102841: PUSH
102842: LD_INT 2
102844: PUSH
102845: EMPTY
102846: LIST
102847: LIST
102848: LIST
102849: PUSH
102850: EMPTY
102851: LIST
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: ST_TO_ADDR
// end ; 4 :
102857: GO 103138
102859: LD_INT 4
102861: DOUBLE
102862: EQUAL
102863: IFTRUE 102867
102865: GO 103000
102867: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
102868: LD_ADDR_VAR 0 5
102872: PUSH
102873: LD_VAR 0 1
102877: PUSH
102878: LD_VAR 0 2
102882: PUSH
102883: LD_INT 4
102885: PLUS
102886: PUSH
102887: LD_INT 0
102889: PUSH
102890: EMPTY
102891: LIST
102892: LIST
102893: LIST
102894: PUSH
102895: LD_VAR 0 1
102899: PUSH
102900: LD_INT 3
102902: PLUS
102903: PUSH
102904: LD_VAR 0 2
102908: PUSH
102909: LD_INT 3
102911: PLUS
102912: PUSH
102913: LD_INT 5
102915: PUSH
102916: EMPTY
102917: LIST
102918: LIST
102919: LIST
102920: PUSH
102921: LD_VAR 0 1
102925: PUSH
102926: LD_INT 4
102928: PLUS
102929: PUSH
102930: LD_VAR 0 2
102934: PUSH
102935: LD_INT 4
102937: PUSH
102938: EMPTY
102939: LIST
102940: LIST
102941: LIST
102942: PUSH
102943: LD_VAR 0 1
102947: PUSH
102948: LD_VAR 0 2
102952: PUSH
102953: LD_INT 3
102955: MINUS
102956: PUSH
102957: LD_INT 3
102959: PUSH
102960: EMPTY
102961: LIST
102962: LIST
102963: LIST
102964: PUSH
102965: LD_VAR 0 1
102969: PUSH
102970: LD_INT 4
102972: MINUS
102973: PUSH
102974: LD_VAR 0 2
102978: PUSH
102979: LD_INT 4
102981: MINUS
102982: PUSH
102983: LD_INT 2
102985: PUSH
102986: EMPTY
102987: LIST
102988: LIST
102989: LIST
102990: PUSH
102991: EMPTY
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: LIST
102997: ST_TO_ADDR
// end ; 5 :
102998: GO 103138
103000: LD_INT 5
103002: DOUBLE
103003: EQUAL
103004: IFTRUE 103008
103006: GO 103137
103008: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103009: LD_ADDR_VAR 0 5
103013: PUSH
103014: LD_VAR 0 1
103018: PUSH
103019: LD_INT 4
103021: MINUS
103022: PUSH
103023: LD_VAR 0 2
103027: PUSH
103028: LD_INT 1
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: LIST
103035: PUSH
103036: LD_VAR 0 1
103040: PUSH
103041: LD_VAR 0 2
103045: PUSH
103046: LD_INT 4
103048: MINUS
103049: PUSH
103050: LD_INT 3
103052: PUSH
103053: EMPTY
103054: LIST
103055: LIST
103056: LIST
103057: PUSH
103058: LD_VAR 0 1
103062: PUSH
103063: LD_INT 4
103065: PLUS
103066: PUSH
103067: LD_VAR 0 2
103071: PUSH
103072: LD_INT 4
103074: PLUS
103075: PUSH
103076: LD_INT 5
103078: PUSH
103079: EMPTY
103080: LIST
103081: LIST
103082: LIST
103083: PUSH
103084: LD_VAR 0 1
103088: PUSH
103089: LD_INT 3
103091: PLUS
103092: PUSH
103093: LD_VAR 0 2
103097: PUSH
103098: LD_INT 4
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: LIST
103105: PUSH
103106: LD_VAR 0 1
103110: PUSH
103111: LD_VAR 0 2
103115: PUSH
103116: LD_INT 3
103118: PLUS
103119: PUSH
103120: LD_INT 0
103122: PUSH
103123: EMPTY
103124: LIST
103125: LIST
103126: LIST
103127: PUSH
103128: EMPTY
103129: LIST
103130: LIST
103131: LIST
103132: LIST
103133: LIST
103134: ST_TO_ADDR
// end ; end ;
103135: GO 103138
103137: POP
// result := list ;
103138: LD_ADDR_VAR 0 4
103142: PUSH
103143: LD_VAR 0 5
103147: ST_TO_ADDR
// end ;
103148: LD_VAR 0 4
103152: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103153: LD_INT 0
103155: PPUSH
103156: PPUSH
103157: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103158: LD_VAR 0 1
103162: NOT
103163: PUSH
103164: LD_VAR 0 2
103168: PUSH
103169: LD_INT 1
103171: PUSH
103172: LD_INT 2
103174: PUSH
103175: LD_INT 3
103177: PUSH
103178: LD_INT 4
103180: PUSH
103181: EMPTY
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: IN
103187: NOT
103188: OR
103189: IFFALSE 103193
// exit ;
103191: GO 103285
// tmp := [ ] ;
103193: LD_ADDR_VAR 0 5
103197: PUSH
103198: EMPTY
103199: ST_TO_ADDR
// for i in units do
103200: LD_ADDR_VAR 0 4
103204: PUSH
103205: LD_VAR 0 1
103209: PUSH
103210: FOR_IN
103211: IFFALSE 103254
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103213: LD_ADDR_VAR 0 5
103217: PUSH
103218: LD_VAR 0 5
103222: PPUSH
103223: LD_VAR 0 5
103227: PUSH
103228: LD_INT 1
103230: PLUS
103231: PPUSH
103232: LD_VAR 0 4
103236: PPUSH
103237: LD_VAR 0 2
103241: PPUSH
103242: CALL_OW 259
103246: PPUSH
103247: CALL_OW 2
103251: ST_TO_ADDR
103252: GO 103210
103254: POP
103255: POP
// if not tmp then
103256: LD_VAR 0 5
103260: NOT
103261: IFFALSE 103265
// exit ;
103263: GO 103285
// result := SortListByListDesc ( units , tmp ) ;
103265: LD_ADDR_VAR 0 3
103269: PUSH
103270: LD_VAR 0 1
103274: PPUSH
103275: LD_VAR 0 5
103279: PPUSH
103280: CALL_OW 77
103284: ST_TO_ADDR
// end ;
103285: LD_VAR 0 3
103289: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
103290: LD_INT 0
103292: PPUSH
103293: PPUSH
103294: PPUSH
// result := false ;
103295: LD_ADDR_VAR 0 3
103299: PUSH
103300: LD_INT 0
103302: ST_TO_ADDR
// x := GetX ( building ) ;
103303: LD_ADDR_VAR 0 4
103307: PUSH
103308: LD_VAR 0 2
103312: PPUSH
103313: CALL_OW 250
103317: ST_TO_ADDR
// y := GetY ( building ) ;
103318: LD_ADDR_VAR 0 5
103322: PUSH
103323: LD_VAR 0 2
103327: PPUSH
103328: CALL_OW 251
103332: ST_TO_ADDR
// if not building or not x or not y then
103333: LD_VAR 0 2
103337: NOT
103338: PUSH
103339: LD_VAR 0 4
103343: NOT
103344: OR
103345: PUSH
103346: LD_VAR 0 5
103350: NOT
103351: OR
103352: IFFALSE 103356
// exit ;
103354: GO 103448
// if GetTaskList ( unit ) then
103356: LD_VAR 0 1
103360: PPUSH
103361: CALL_OW 437
103365: IFFALSE 103448
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103367: LD_STRING e
103369: PUSH
103370: LD_VAR 0 1
103374: PPUSH
103375: CALL_OW 437
103379: PUSH
103380: LD_INT 1
103382: ARRAY
103383: PUSH
103384: LD_INT 1
103386: ARRAY
103387: EQUAL
103388: PUSH
103389: LD_VAR 0 4
103393: PUSH
103394: LD_VAR 0 1
103398: PPUSH
103399: CALL_OW 437
103403: PUSH
103404: LD_INT 1
103406: ARRAY
103407: PUSH
103408: LD_INT 2
103410: ARRAY
103411: EQUAL
103412: AND
103413: PUSH
103414: LD_VAR 0 5
103418: PUSH
103419: LD_VAR 0 1
103423: PPUSH
103424: CALL_OW 437
103428: PUSH
103429: LD_INT 1
103431: ARRAY
103432: PUSH
103433: LD_INT 3
103435: ARRAY
103436: EQUAL
103437: AND
103438: IFFALSE 103448
// result := true end ;
103440: LD_ADDR_VAR 0 3
103444: PUSH
103445: LD_INT 1
103447: ST_TO_ADDR
// end ;
103448: LD_VAR 0 3
103452: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
103453: LD_INT 0
103455: PPUSH
// result := false ;
103456: LD_ADDR_VAR 0 4
103460: PUSH
103461: LD_INT 0
103463: ST_TO_ADDR
// if GetTaskList ( unit ) then
103464: LD_VAR 0 1
103468: PPUSH
103469: CALL_OW 437
103473: IFFALSE 103556
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
103475: LD_STRING M
103477: PUSH
103478: LD_VAR 0 1
103482: PPUSH
103483: CALL_OW 437
103487: PUSH
103488: LD_INT 1
103490: ARRAY
103491: PUSH
103492: LD_INT 1
103494: ARRAY
103495: EQUAL
103496: PUSH
103497: LD_VAR 0 2
103501: PUSH
103502: LD_VAR 0 1
103506: PPUSH
103507: CALL_OW 437
103511: PUSH
103512: LD_INT 1
103514: ARRAY
103515: PUSH
103516: LD_INT 2
103518: ARRAY
103519: EQUAL
103520: AND
103521: PUSH
103522: LD_VAR 0 3
103526: PUSH
103527: LD_VAR 0 1
103531: PPUSH
103532: CALL_OW 437
103536: PUSH
103537: LD_INT 1
103539: ARRAY
103540: PUSH
103541: LD_INT 3
103543: ARRAY
103544: EQUAL
103545: AND
103546: IFFALSE 103556
// result := true ;
103548: LD_ADDR_VAR 0 4
103552: PUSH
103553: LD_INT 1
103555: ST_TO_ADDR
// end ; end ;
103556: LD_VAR 0 4
103560: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
103561: LD_INT 0
103563: PPUSH
103564: PPUSH
103565: PPUSH
103566: PPUSH
// if not unit or not area then
103567: LD_VAR 0 1
103571: NOT
103572: PUSH
103573: LD_VAR 0 2
103577: NOT
103578: OR
103579: IFFALSE 103583
// exit ;
103581: GO 103747
// tmp := AreaToList ( area , i ) ;
103583: LD_ADDR_VAR 0 6
103587: PUSH
103588: LD_VAR 0 2
103592: PPUSH
103593: LD_VAR 0 5
103597: PPUSH
103598: CALL_OW 517
103602: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
103603: LD_ADDR_VAR 0 5
103607: PUSH
103608: DOUBLE
103609: LD_INT 1
103611: DEC
103612: ST_TO_ADDR
103613: LD_VAR 0 6
103617: PUSH
103618: LD_INT 1
103620: ARRAY
103621: PUSH
103622: FOR_TO
103623: IFFALSE 103745
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
103625: LD_ADDR_VAR 0 7
103629: PUSH
103630: LD_VAR 0 6
103634: PUSH
103635: LD_INT 1
103637: ARRAY
103638: PUSH
103639: LD_VAR 0 5
103643: ARRAY
103644: PUSH
103645: LD_VAR 0 6
103649: PUSH
103650: LD_INT 2
103652: ARRAY
103653: PUSH
103654: LD_VAR 0 5
103658: ARRAY
103659: PUSH
103660: EMPTY
103661: LIST
103662: LIST
103663: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
103664: LD_VAR 0 7
103668: PUSH
103669: LD_INT 1
103671: ARRAY
103672: PPUSH
103673: LD_VAR 0 7
103677: PUSH
103678: LD_INT 2
103680: ARRAY
103681: PPUSH
103682: CALL_OW 428
103686: PUSH
103687: LD_INT 0
103689: EQUAL
103690: IFFALSE 103743
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
103692: LD_VAR 0 1
103696: PPUSH
103697: LD_VAR 0 7
103701: PUSH
103702: LD_INT 1
103704: ARRAY
103705: PPUSH
103706: LD_VAR 0 7
103710: PUSH
103711: LD_INT 2
103713: ARRAY
103714: PPUSH
103715: LD_VAR 0 3
103719: PPUSH
103720: CALL_OW 48
// result := IsPlaced ( unit ) ;
103724: LD_ADDR_VAR 0 4
103728: PUSH
103729: LD_VAR 0 1
103733: PPUSH
103734: CALL_OW 305
103738: ST_TO_ADDR
// exit ;
103739: POP
103740: POP
103741: GO 103747
// end ; end ;
103743: GO 103622
103745: POP
103746: POP
// end ;
103747: LD_VAR 0 4
103751: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
103752: LD_INT 0
103754: PPUSH
103755: PPUSH
103756: PPUSH
// if not side or side > 8 then
103757: LD_VAR 0 1
103761: NOT
103762: PUSH
103763: LD_VAR 0 1
103767: PUSH
103768: LD_INT 8
103770: GREATER
103771: OR
103772: IFFALSE 103776
// exit ;
103774: GO 103963
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
103776: LD_ADDR_VAR 0 4
103780: PUSH
103781: LD_INT 22
103783: PUSH
103784: LD_VAR 0 1
103788: PUSH
103789: EMPTY
103790: LIST
103791: LIST
103792: PUSH
103793: LD_INT 21
103795: PUSH
103796: LD_INT 3
103798: PUSH
103799: EMPTY
103800: LIST
103801: LIST
103802: PUSH
103803: EMPTY
103804: LIST
103805: LIST
103806: PPUSH
103807: CALL_OW 69
103811: ST_TO_ADDR
// if not tmp then
103812: LD_VAR 0 4
103816: NOT
103817: IFFALSE 103821
// exit ;
103819: GO 103963
// enable_addtolog := true ;
103821: LD_ADDR_OWVAR 81
103825: PUSH
103826: LD_INT 1
103828: ST_TO_ADDR
// AddToLog ( [ ) ;
103829: LD_STRING [
103831: PPUSH
103832: CALL_OW 561
// for i in tmp do
103836: LD_ADDR_VAR 0 3
103840: PUSH
103841: LD_VAR 0 4
103845: PUSH
103846: FOR_IN
103847: IFFALSE 103954
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
103849: LD_STRING [
103851: PUSH
103852: LD_VAR 0 3
103856: PPUSH
103857: CALL_OW 266
103861: STR
103862: PUSH
103863: LD_STRING , 
103865: STR
103866: PUSH
103867: LD_VAR 0 3
103871: PPUSH
103872: CALL_OW 250
103876: STR
103877: PUSH
103878: LD_STRING , 
103880: STR
103881: PUSH
103882: LD_VAR 0 3
103886: PPUSH
103887: CALL_OW 251
103891: STR
103892: PUSH
103893: LD_STRING , 
103895: STR
103896: PUSH
103897: LD_VAR 0 3
103901: PPUSH
103902: CALL_OW 254
103906: STR
103907: PUSH
103908: LD_STRING , 
103910: STR
103911: PUSH
103912: LD_VAR 0 3
103916: PPUSH
103917: LD_INT 1
103919: PPUSH
103920: CALL_OW 268
103924: STR
103925: PUSH
103926: LD_STRING , 
103928: STR
103929: PUSH
103930: LD_VAR 0 3
103934: PPUSH
103935: LD_INT 2
103937: PPUSH
103938: CALL_OW 268
103942: STR
103943: PUSH
103944: LD_STRING ],
103946: STR
103947: PPUSH
103948: CALL_OW 561
// end ;
103952: GO 103846
103954: POP
103955: POP
// AddToLog ( ]; ) ;
103956: LD_STRING ];
103958: PPUSH
103959: CALL_OW 561
// end ;
103963: LD_VAR 0 2
103967: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
103968: LD_INT 0
103970: PPUSH
103971: PPUSH
103972: PPUSH
103973: PPUSH
103974: PPUSH
// if not area or not rate or not max then
103975: LD_VAR 0 1
103979: NOT
103980: PUSH
103981: LD_VAR 0 2
103985: NOT
103986: OR
103987: PUSH
103988: LD_VAR 0 4
103992: NOT
103993: OR
103994: IFFALSE 103998
// exit ;
103996: GO 104187
// while 1 do
103998: LD_INT 1
104000: IFFALSE 104187
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104002: LD_ADDR_VAR 0 9
104006: PUSH
104007: LD_VAR 0 1
104011: PPUSH
104012: LD_INT 1
104014: PPUSH
104015: CALL_OW 287
104019: PUSH
104020: LD_INT 10
104022: MUL
104023: ST_TO_ADDR
// r := rate / 10 ;
104024: LD_ADDR_VAR 0 7
104028: PUSH
104029: LD_VAR 0 2
104033: PUSH
104034: LD_INT 10
104036: DIVREAL
104037: ST_TO_ADDR
// time := 1 1$00 ;
104038: LD_ADDR_VAR 0 8
104042: PUSH
104043: LD_INT 2100
104045: ST_TO_ADDR
// if amount < min then
104046: LD_VAR 0 9
104050: PUSH
104051: LD_VAR 0 3
104055: LESS
104056: IFFALSE 104074
// r := r * 2 else
104058: LD_ADDR_VAR 0 7
104062: PUSH
104063: LD_VAR 0 7
104067: PUSH
104068: LD_INT 2
104070: MUL
104071: ST_TO_ADDR
104072: GO 104100
// if amount > max then
104074: LD_VAR 0 9
104078: PUSH
104079: LD_VAR 0 4
104083: GREATER
104084: IFFALSE 104100
// r := r / 2 ;
104086: LD_ADDR_VAR 0 7
104090: PUSH
104091: LD_VAR 0 7
104095: PUSH
104096: LD_INT 2
104098: DIVREAL
104099: ST_TO_ADDR
// time := time / r ;
104100: LD_ADDR_VAR 0 8
104104: PUSH
104105: LD_VAR 0 8
104109: PUSH
104110: LD_VAR 0 7
104114: DIVREAL
104115: ST_TO_ADDR
// if time < 0 then
104116: LD_VAR 0 8
104120: PUSH
104121: LD_INT 0
104123: LESS
104124: IFFALSE 104141
// time := time * - 1 ;
104126: LD_ADDR_VAR 0 8
104130: PUSH
104131: LD_VAR 0 8
104135: PUSH
104136: LD_INT 1
104138: NEG
104139: MUL
104140: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
104141: LD_VAR 0 8
104145: PUSH
104146: LD_INT 35
104148: PPUSH
104149: LD_INT 875
104151: PPUSH
104152: CALL_OW 12
104156: PLUS
104157: PPUSH
104158: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104162: LD_INT 1
104164: PPUSH
104165: LD_INT 5
104167: PPUSH
104168: CALL_OW 12
104172: PPUSH
104173: LD_VAR 0 1
104177: PPUSH
104178: LD_INT 1
104180: PPUSH
104181: CALL_OW 55
// end ;
104185: GO 103998
// end ;
104187: LD_VAR 0 5
104191: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104192: LD_INT 0
104194: PPUSH
104195: PPUSH
104196: PPUSH
104197: PPUSH
104198: PPUSH
104199: PPUSH
104200: PPUSH
104201: PPUSH
// if not turrets or not factories then
104202: LD_VAR 0 1
104206: NOT
104207: PUSH
104208: LD_VAR 0 2
104212: NOT
104213: OR
104214: IFFALSE 104218
// exit ;
104216: GO 104525
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104218: LD_ADDR_VAR 0 10
104222: PUSH
104223: LD_INT 5
104225: PUSH
104226: LD_INT 6
104228: PUSH
104229: EMPTY
104230: LIST
104231: LIST
104232: PUSH
104233: LD_INT 2
104235: PUSH
104236: LD_INT 4
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: PUSH
104243: LD_INT 3
104245: PUSH
104246: LD_INT 5
104248: PUSH
104249: EMPTY
104250: LIST
104251: LIST
104252: PUSH
104253: EMPTY
104254: LIST
104255: LIST
104256: LIST
104257: PUSH
104258: LD_INT 24
104260: PUSH
104261: LD_INT 25
104263: PUSH
104264: EMPTY
104265: LIST
104266: LIST
104267: PUSH
104268: LD_INT 23
104270: PUSH
104271: LD_INT 27
104273: PUSH
104274: EMPTY
104275: LIST
104276: LIST
104277: PUSH
104278: EMPTY
104279: LIST
104280: LIST
104281: PUSH
104282: LD_INT 42
104284: PUSH
104285: LD_INT 43
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: PUSH
104292: LD_INT 44
104294: PUSH
104295: LD_INT 46
104297: PUSH
104298: EMPTY
104299: LIST
104300: LIST
104301: PUSH
104302: LD_INT 45
104304: PUSH
104305: LD_INT 47
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: PUSH
104312: EMPTY
104313: LIST
104314: LIST
104315: LIST
104316: PUSH
104317: EMPTY
104318: LIST
104319: LIST
104320: LIST
104321: ST_TO_ADDR
// result := [ ] ;
104322: LD_ADDR_VAR 0 3
104326: PUSH
104327: EMPTY
104328: ST_TO_ADDR
// for i in turrets do
104329: LD_ADDR_VAR 0 4
104333: PUSH
104334: LD_VAR 0 1
104338: PUSH
104339: FOR_IN
104340: IFFALSE 104523
// begin nat := GetNation ( i ) ;
104342: LD_ADDR_VAR 0 7
104346: PUSH
104347: LD_VAR 0 4
104351: PPUSH
104352: CALL_OW 248
104356: ST_TO_ADDR
// weapon := 0 ;
104357: LD_ADDR_VAR 0 8
104361: PUSH
104362: LD_INT 0
104364: ST_TO_ADDR
// if not nat then
104365: LD_VAR 0 7
104369: NOT
104370: IFFALSE 104374
// continue ;
104372: GO 104339
// for j in list [ nat ] do
104374: LD_ADDR_VAR 0 5
104378: PUSH
104379: LD_VAR 0 10
104383: PUSH
104384: LD_VAR 0 7
104388: ARRAY
104389: PUSH
104390: FOR_IN
104391: IFFALSE 104432
// if GetBWeapon ( i ) = j [ 1 ] then
104393: LD_VAR 0 4
104397: PPUSH
104398: CALL_OW 269
104402: PUSH
104403: LD_VAR 0 5
104407: PUSH
104408: LD_INT 1
104410: ARRAY
104411: EQUAL
104412: IFFALSE 104430
// begin weapon := j [ 2 ] ;
104414: LD_ADDR_VAR 0 8
104418: PUSH
104419: LD_VAR 0 5
104423: PUSH
104424: LD_INT 2
104426: ARRAY
104427: ST_TO_ADDR
// break ;
104428: GO 104432
// end ;
104430: GO 104390
104432: POP
104433: POP
// if not weapon then
104434: LD_VAR 0 8
104438: NOT
104439: IFFALSE 104443
// continue ;
104441: GO 104339
// for k in factories do
104443: LD_ADDR_VAR 0 6
104447: PUSH
104448: LD_VAR 0 2
104452: PUSH
104453: FOR_IN
104454: IFFALSE 104519
// begin weapons := AvailableWeaponList ( k ) ;
104456: LD_ADDR_VAR 0 9
104460: PUSH
104461: LD_VAR 0 6
104465: PPUSH
104466: CALL_OW 478
104470: ST_TO_ADDR
// if not weapons then
104471: LD_VAR 0 9
104475: NOT
104476: IFFALSE 104480
// continue ;
104478: GO 104453
// if weapon in weapons then
104480: LD_VAR 0 8
104484: PUSH
104485: LD_VAR 0 9
104489: IN
104490: IFFALSE 104517
// begin result := [ i , weapon ] ;
104492: LD_ADDR_VAR 0 3
104496: PUSH
104497: LD_VAR 0 4
104501: PUSH
104502: LD_VAR 0 8
104506: PUSH
104507: EMPTY
104508: LIST
104509: LIST
104510: ST_TO_ADDR
// exit ;
104511: POP
104512: POP
104513: POP
104514: POP
104515: GO 104525
// end ; end ;
104517: GO 104453
104519: POP
104520: POP
// end ;
104521: GO 104339
104523: POP
104524: POP
// end ;
104525: LD_VAR 0 3
104529: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
104530: LD_INT 0
104532: PPUSH
// if not side or side > 8 then
104533: LD_VAR 0 3
104537: NOT
104538: PUSH
104539: LD_VAR 0 3
104543: PUSH
104544: LD_INT 8
104546: GREATER
104547: OR
104548: IFFALSE 104552
// exit ;
104550: GO 104611
// if not range then
104552: LD_VAR 0 4
104556: NOT
104557: IFFALSE 104568
// range := - 12 ;
104559: LD_ADDR_VAR 0 4
104563: PUSH
104564: LD_INT 12
104566: NEG
104567: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
104568: LD_VAR 0 1
104572: PPUSH
104573: LD_VAR 0 2
104577: PPUSH
104578: LD_VAR 0 3
104582: PPUSH
104583: LD_VAR 0 4
104587: PPUSH
104588: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
104592: LD_VAR 0 1
104596: PPUSH
104597: LD_VAR 0 2
104601: PPUSH
104602: LD_VAR 0 3
104606: PPUSH
104607: CALL_OW 331
// end ;
104611: LD_VAR 0 5
104615: RET
// export function Video ( mode ) ; begin
104616: LD_INT 0
104618: PPUSH
// ingame_video = mode ;
104619: LD_ADDR_OWVAR 52
104623: PUSH
104624: LD_VAR 0 1
104628: ST_TO_ADDR
// interface_hidden = mode ;
104629: LD_ADDR_OWVAR 54
104633: PUSH
104634: LD_VAR 0 1
104638: ST_TO_ADDR
// end ;
104639: LD_VAR 0 2
104643: RET
// export function Join ( array , element ) ; begin
104644: LD_INT 0
104646: PPUSH
// result := Replace ( array , array + 1 , element ) ;
104647: LD_ADDR_VAR 0 3
104651: PUSH
104652: LD_VAR 0 1
104656: PPUSH
104657: LD_VAR 0 1
104661: PUSH
104662: LD_INT 1
104664: PLUS
104665: PPUSH
104666: LD_VAR 0 2
104670: PPUSH
104671: CALL_OW 1
104675: ST_TO_ADDR
// end ;
104676: LD_VAR 0 3
104680: RET
// export function JoinUnion ( array , element ) ; begin
104681: LD_INT 0
104683: PPUSH
// result := array union element ;
104684: LD_ADDR_VAR 0 3
104688: PUSH
104689: LD_VAR 0 1
104693: PUSH
104694: LD_VAR 0 2
104698: UNION
104699: ST_TO_ADDR
// end ;
104700: LD_VAR 0 3
104704: RET
// export function GetBehemoths ( side ) ; begin
104705: LD_INT 0
104707: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
104708: LD_ADDR_VAR 0 2
104712: PUSH
104713: LD_INT 22
104715: PUSH
104716: LD_VAR 0 1
104720: PUSH
104721: EMPTY
104722: LIST
104723: LIST
104724: PUSH
104725: LD_INT 31
104727: PUSH
104728: LD_INT 25
104730: PUSH
104731: EMPTY
104732: LIST
104733: LIST
104734: PUSH
104735: EMPTY
104736: LIST
104737: LIST
104738: PPUSH
104739: CALL_OW 69
104743: ST_TO_ADDR
// end ;
104744: LD_VAR 0 2
104748: RET
// export function Shuffle ( array ) ; var i , index ; begin
104749: LD_INT 0
104751: PPUSH
104752: PPUSH
104753: PPUSH
// result := [ ] ;
104754: LD_ADDR_VAR 0 2
104758: PUSH
104759: EMPTY
104760: ST_TO_ADDR
// if not array then
104761: LD_VAR 0 1
104765: NOT
104766: IFFALSE 104770
// exit ;
104768: GO 104869
// Randomize ;
104770: CALL_OW 10
// for i = array downto 1 do
104774: LD_ADDR_VAR 0 3
104778: PUSH
104779: DOUBLE
104780: LD_VAR 0 1
104784: INC
104785: ST_TO_ADDR
104786: LD_INT 1
104788: PUSH
104789: FOR_DOWNTO
104790: IFFALSE 104867
// begin index := rand ( 1 , array ) ;
104792: LD_ADDR_VAR 0 4
104796: PUSH
104797: LD_INT 1
104799: PPUSH
104800: LD_VAR 0 1
104804: PPUSH
104805: CALL_OW 12
104809: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
104810: LD_ADDR_VAR 0 2
104814: PUSH
104815: LD_VAR 0 2
104819: PPUSH
104820: LD_VAR 0 2
104824: PUSH
104825: LD_INT 1
104827: PLUS
104828: PPUSH
104829: LD_VAR 0 1
104833: PUSH
104834: LD_VAR 0 4
104838: ARRAY
104839: PPUSH
104840: CALL_OW 2
104844: ST_TO_ADDR
// array := Delete ( array , index ) ;
104845: LD_ADDR_VAR 0 1
104849: PUSH
104850: LD_VAR 0 1
104854: PPUSH
104855: LD_VAR 0 4
104859: PPUSH
104860: CALL_OW 3
104864: ST_TO_ADDR
// end ;
104865: GO 104789
104867: POP
104868: POP
// end ;
104869: LD_VAR 0 2
104873: RET
// export function GetBaseMaterials ( base ) ; begin
104874: LD_INT 0
104876: PPUSH
// result := [ 0 , 0 , 0 ] ;
104877: LD_ADDR_VAR 0 2
104881: PUSH
104882: LD_INT 0
104884: PUSH
104885: LD_INT 0
104887: PUSH
104888: LD_INT 0
104890: PUSH
104891: EMPTY
104892: LIST
104893: LIST
104894: LIST
104895: ST_TO_ADDR
// if not base then
104896: LD_VAR 0 1
104900: NOT
104901: IFFALSE 104905
// exit ;
104903: GO 104954
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
104905: LD_ADDR_VAR 0 2
104909: PUSH
104910: LD_VAR 0 1
104914: PPUSH
104915: LD_INT 1
104917: PPUSH
104918: CALL_OW 275
104922: PUSH
104923: LD_VAR 0 1
104927: PPUSH
104928: LD_INT 2
104930: PPUSH
104931: CALL_OW 275
104935: PUSH
104936: LD_VAR 0 1
104940: PPUSH
104941: LD_INT 3
104943: PPUSH
104944: CALL_OW 275
104948: PUSH
104949: EMPTY
104950: LIST
104951: LIST
104952: LIST
104953: ST_TO_ADDR
// end ;
104954: LD_VAR 0 2
104958: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
104959: LD_INT 0
104961: PPUSH
104962: PPUSH
// result := array ;
104963: LD_ADDR_VAR 0 3
104967: PUSH
104968: LD_VAR 0 1
104972: ST_TO_ADDR
// if size >= result then
104973: LD_VAR 0 2
104977: PUSH
104978: LD_VAR 0 3
104982: GREATEREQUAL
104983: IFFALSE 104987
// exit ;
104985: GO 105037
// if size then
104987: LD_VAR 0 2
104991: IFFALSE 105037
// for i := array downto size do
104993: LD_ADDR_VAR 0 4
104997: PUSH
104998: DOUBLE
104999: LD_VAR 0 1
105003: INC
105004: ST_TO_ADDR
105005: LD_VAR 0 2
105009: PUSH
105010: FOR_DOWNTO
105011: IFFALSE 105035
// result := Delete ( result , result ) ;
105013: LD_ADDR_VAR 0 3
105017: PUSH
105018: LD_VAR 0 3
105022: PPUSH
105023: LD_VAR 0 3
105027: PPUSH
105028: CALL_OW 3
105032: ST_TO_ADDR
105033: GO 105010
105035: POP
105036: POP
// end ;
105037: LD_VAR 0 3
105041: RET
// export function ComExit ( unit ) ; var tmp ; begin
105042: LD_INT 0
105044: PPUSH
105045: PPUSH
// if not IsInUnit ( unit ) then
105046: LD_VAR 0 1
105050: PPUSH
105051: CALL_OW 310
105055: NOT
105056: IFFALSE 105060
// exit ;
105058: GO 105120
// tmp := IsInUnit ( unit ) ;
105060: LD_ADDR_VAR 0 3
105064: PUSH
105065: LD_VAR 0 1
105069: PPUSH
105070: CALL_OW 310
105074: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
105075: LD_VAR 0 3
105079: PPUSH
105080: CALL_OW 247
105084: PUSH
105085: LD_INT 2
105087: EQUAL
105088: IFFALSE 105101
// ComExitVehicle ( unit ) else
105090: LD_VAR 0 1
105094: PPUSH
105095: CALL_OW 121
105099: GO 105110
// ComExitBuilding ( unit ) ;
105101: LD_VAR 0 1
105105: PPUSH
105106: CALL_OW 122
// result := tmp ;
105110: LD_ADDR_VAR 0 2
105114: PUSH
105115: LD_VAR 0 3
105119: ST_TO_ADDR
// end ;
105120: LD_VAR 0 2
105124: RET
// export function ComExitAll ( units ) ; var i ; begin
105125: LD_INT 0
105127: PPUSH
105128: PPUSH
// if not units then
105129: LD_VAR 0 1
105133: NOT
105134: IFFALSE 105138
// exit ;
105136: GO 105164
// for i in units do
105138: LD_ADDR_VAR 0 3
105142: PUSH
105143: LD_VAR 0 1
105147: PUSH
105148: FOR_IN
105149: IFFALSE 105162
// ComExit ( i ) ;
105151: LD_VAR 0 3
105155: PPUSH
105156: CALL 105042 0 1
105160: GO 105148
105162: POP
105163: POP
// end ;
105164: LD_VAR 0 2
105168: RET
// export function ResetHc ; begin
105169: LD_INT 0
105171: PPUSH
// InitHc ;
105172: CALL_OW 19
// hc_importance := 0 ;
105176: LD_ADDR_OWVAR 32
105180: PUSH
105181: LD_INT 0
105183: ST_TO_ADDR
// end ;
105184: LD_VAR 0 1
105188: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
105189: LD_INT 0
105191: PPUSH
105192: PPUSH
105193: PPUSH
// _x := ( x1 + x2 ) div 2 ;
105194: LD_ADDR_VAR 0 6
105198: PUSH
105199: LD_VAR 0 1
105203: PUSH
105204: LD_VAR 0 3
105208: PLUS
105209: PUSH
105210: LD_INT 2
105212: DIV
105213: ST_TO_ADDR
// if _x < 0 then
105214: LD_VAR 0 6
105218: PUSH
105219: LD_INT 0
105221: LESS
105222: IFFALSE 105239
// _x := _x * - 1 ;
105224: LD_ADDR_VAR 0 6
105228: PUSH
105229: LD_VAR 0 6
105233: PUSH
105234: LD_INT 1
105236: NEG
105237: MUL
105238: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
105239: LD_ADDR_VAR 0 7
105243: PUSH
105244: LD_VAR 0 2
105248: PUSH
105249: LD_VAR 0 4
105253: PLUS
105254: PUSH
105255: LD_INT 2
105257: DIV
105258: ST_TO_ADDR
// if _y < 0 then
105259: LD_VAR 0 7
105263: PUSH
105264: LD_INT 0
105266: LESS
105267: IFFALSE 105284
// _y := _y * - 1 ;
105269: LD_ADDR_VAR 0 7
105273: PUSH
105274: LD_VAR 0 7
105278: PUSH
105279: LD_INT 1
105281: NEG
105282: MUL
105283: ST_TO_ADDR
// result := [ _x , _y ] ;
105284: LD_ADDR_VAR 0 5
105288: PUSH
105289: LD_VAR 0 6
105293: PUSH
105294: LD_VAR 0 7
105298: PUSH
105299: EMPTY
105300: LIST
105301: LIST
105302: ST_TO_ADDR
// end ;
105303: LD_VAR 0 5
105307: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
105308: LD_INT 0
105310: PPUSH
105311: PPUSH
105312: PPUSH
105313: PPUSH
// task := GetTaskList ( unit ) ;
105314: LD_ADDR_VAR 0 7
105318: PUSH
105319: LD_VAR 0 1
105323: PPUSH
105324: CALL_OW 437
105328: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
105329: LD_VAR 0 7
105333: NOT
105334: PUSH
105335: LD_VAR 0 1
105339: PPUSH
105340: LD_VAR 0 2
105344: PPUSH
105345: CALL_OW 308
105349: NOT
105350: AND
105351: IFFALSE 105355
// exit ;
105353: GO 105473
// if IsInArea ( unit , area ) then
105355: LD_VAR 0 1
105359: PPUSH
105360: LD_VAR 0 2
105364: PPUSH
105365: CALL_OW 308
105369: IFFALSE 105387
// begin ComMoveToArea ( unit , goAway ) ;
105371: LD_VAR 0 1
105375: PPUSH
105376: LD_VAR 0 3
105380: PPUSH
105381: CALL_OW 113
// exit ;
105385: GO 105473
// end ; if task [ 1 ] [ 1 ] <> M then
105387: LD_VAR 0 7
105391: PUSH
105392: LD_INT 1
105394: ARRAY
105395: PUSH
105396: LD_INT 1
105398: ARRAY
105399: PUSH
105400: LD_STRING M
105402: NONEQUAL
105403: IFFALSE 105407
// exit ;
105405: GO 105473
// x := task [ 1 ] [ 2 ] ;
105407: LD_ADDR_VAR 0 5
105411: PUSH
105412: LD_VAR 0 7
105416: PUSH
105417: LD_INT 1
105419: ARRAY
105420: PUSH
105421: LD_INT 2
105423: ARRAY
105424: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
105425: LD_ADDR_VAR 0 6
105429: PUSH
105430: LD_VAR 0 7
105434: PUSH
105435: LD_INT 1
105437: ARRAY
105438: PUSH
105439: LD_INT 3
105441: ARRAY
105442: ST_TO_ADDR
// if InArea ( x , y , area ) then
105443: LD_VAR 0 5
105447: PPUSH
105448: LD_VAR 0 6
105452: PPUSH
105453: LD_VAR 0 2
105457: PPUSH
105458: CALL_OW 309
105462: IFFALSE 105473
// ComStop ( unit ) ;
105464: LD_VAR 0 1
105468: PPUSH
105469: CALL_OW 141
// end ;
105473: LD_VAR 0 4
105477: RET
// export function Abs ( value ) ; begin
105478: LD_INT 0
105480: PPUSH
// result := value ;
105481: LD_ADDR_VAR 0 2
105485: PUSH
105486: LD_VAR 0 1
105490: ST_TO_ADDR
// if value < 0 then
105491: LD_VAR 0 1
105495: PUSH
105496: LD_INT 0
105498: LESS
105499: IFFALSE 105516
// result := value * - 1 ;
105501: LD_ADDR_VAR 0 2
105505: PUSH
105506: LD_VAR 0 1
105510: PUSH
105511: LD_INT 1
105513: NEG
105514: MUL
105515: ST_TO_ADDR
// end ;
105516: LD_VAR 0 2
105520: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
105521: LD_INT 0
105523: PPUSH
105524: PPUSH
105525: PPUSH
105526: PPUSH
105527: PPUSH
105528: PPUSH
105529: PPUSH
105530: PPUSH
// if not unit or not building then
105531: LD_VAR 0 1
105535: NOT
105536: PUSH
105537: LD_VAR 0 2
105541: NOT
105542: OR
105543: IFFALSE 105547
// exit ;
105545: GO 105773
// x := GetX ( building ) ;
105547: LD_ADDR_VAR 0 4
105551: PUSH
105552: LD_VAR 0 2
105556: PPUSH
105557: CALL_OW 250
105561: ST_TO_ADDR
// y := GetY ( building ) ;
105562: LD_ADDR_VAR 0 6
105566: PUSH
105567: LD_VAR 0 2
105571: PPUSH
105572: CALL_OW 251
105576: ST_TO_ADDR
// d := GetDir ( building ) ;
105577: LD_ADDR_VAR 0 8
105581: PUSH
105582: LD_VAR 0 2
105586: PPUSH
105587: CALL_OW 254
105591: ST_TO_ADDR
// r := 4 ;
105592: LD_ADDR_VAR 0 9
105596: PUSH
105597: LD_INT 4
105599: ST_TO_ADDR
// for i := 1 to 5 do
105600: LD_ADDR_VAR 0 10
105604: PUSH
105605: DOUBLE
105606: LD_INT 1
105608: DEC
105609: ST_TO_ADDR
105610: LD_INT 5
105612: PUSH
105613: FOR_TO
105614: IFFALSE 105771
// begin _x := ShiftX ( x , d , r + i ) ;
105616: LD_ADDR_VAR 0 5
105620: PUSH
105621: LD_VAR 0 4
105625: PPUSH
105626: LD_VAR 0 8
105630: PPUSH
105631: LD_VAR 0 9
105635: PUSH
105636: LD_VAR 0 10
105640: PLUS
105641: PPUSH
105642: CALL_OW 272
105646: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
105647: LD_ADDR_VAR 0 7
105651: PUSH
105652: LD_VAR 0 6
105656: PPUSH
105657: LD_VAR 0 8
105661: PPUSH
105662: LD_VAR 0 9
105666: PUSH
105667: LD_VAR 0 10
105671: PLUS
105672: PPUSH
105673: CALL_OW 273
105677: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
105678: LD_VAR 0 5
105682: PPUSH
105683: LD_VAR 0 7
105687: PPUSH
105688: CALL_OW 488
105692: PUSH
105693: LD_VAR 0 5
105697: PPUSH
105698: LD_VAR 0 7
105702: PPUSH
105703: CALL_OW 428
105707: PPUSH
105708: CALL_OW 247
105712: PUSH
105713: LD_INT 3
105715: PUSH
105716: LD_INT 2
105718: PUSH
105719: EMPTY
105720: LIST
105721: LIST
105722: IN
105723: NOT
105724: AND
105725: IFFALSE 105769
// begin ComMoveXY ( unit , _x , _y ) ;
105727: LD_VAR 0 1
105731: PPUSH
105732: LD_VAR 0 5
105736: PPUSH
105737: LD_VAR 0 7
105741: PPUSH
105742: CALL_OW 111
// result := [ _x , _y ] ;
105746: LD_ADDR_VAR 0 3
105750: PUSH
105751: LD_VAR 0 5
105755: PUSH
105756: LD_VAR 0 7
105760: PUSH
105761: EMPTY
105762: LIST
105763: LIST
105764: ST_TO_ADDR
// exit ;
105765: POP
105766: POP
105767: GO 105773
// end ; end ;
105769: GO 105613
105771: POP
105772: POP
// end ;
105773: LD_VAR 0 3
105777: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
105778: LD_INT 0
105780: PPUSH
105781: PPUSH
105782: PPUSH
// result := 0 ;
105783: LD_ADDR_VAR 0 3
105787: PUSH
105788: LD_INT 0
105790: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
105791: LD_VAR 0 1
105795: PUSH
105796: LD_INT 0
105798: LESS
105799: PUSH
105800: LD_VAR 0 1
105804: PUSH
105805: LD_INT 8
105807: GREATER
105808: OR
105809: PUSH
105810: LD_VAR 0 2
105814: PUSH
105815: LD_INT 0
105817: LESS
105818: OR
105819: PUSH
105820: LD_VAR 0 2
105824: PUSH
105825: LD_INT 8
105827: GREATER
105828: OR
105829: IFFALSE 105833
// exit ;
105831: GO 105908
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
105833: LD_ADDR_VAR 0 4
105837: PUSH
105838: LD_INT 22
105840: PUSH
105841: LD_VAR 0 2
105845: PUSH
105846: EMPTY
105847: LIST
105848: LIST
105849: PPUSH
105850: CALL_OW 69
105854: PUSH
105855: FOR_IN
105856: IFFALSE 105906
// begin un := UnitShoot ( i ) ;
105858: LD_ADDR_VAR 0 5
105862: PUSH
105863: LD_VAR 0 4
105867: PPUSH
105868: CALL_OW 504
105872: ST_TO_ADDR
// if GetSide ( un ) = side1 then
105873: LD_VAR 0 5
105877: PPUSH
105878: CALL_OW 255
105882: PUSH
105883: LD_VAR 0 1
105887: EQUAL
105888: IFFALSE 105904
// begin result := un ;
105890: LD_ADDR_VAR 0 3
105894: PUSH
105895: LD_VAR 0 5
105899: ST_TO_ADDR
// exit ;
105900: POP
105901: POP
105902: GO 105908
// end ; end ;
105904: GO 105855
105906: POP
105907: POP
// end ;
105908: LD_VAR 0 3
105912: RET
// export function GetCargoBay ( units ) ; begin
105913: LD_INT 0
105915: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
105916: LD_ADDR_VAR 0 2
105920: PUSH
105921: LD_VAR 0 1
105925: PPUSH
105926: LD_INT 2
105928: PUSH
105929: LD_INT 34
105931: PUSH
105932: LD_INT 12
105934: PUSH
105935: EMPTY
105936: LIST
105937: LIST
105938: PUSH
105939: LD_INT 34
105941: PUSH
105942: LD_INT 51
105944: PUSH
105945: EMPTY
105946: LIST
105947: LIST
105948: PUSH
105949: LD_INT 34
105951: PUSH
105952: LD_INT 32
105954: PUSH
105955: EMPTY
105956: LIST
105957: LIST
105958: PUSH
105959: LD_INT 34
105961: PUSH
105962: LD_INT 89
105964: PUSH
105965: EMPTY
105966: LIST
105967: LIST
105968: PUSH
105969: EMPTY
105970: LIST
105971: LIST
105972: LIST
105973: LIST
105974: LIST
105975: PPUSH
105976: CALL_OW 72
105980: ST_TO_ADDR
// end ;
105981: LD_VAR 0 2
105985: RET
// export function Negate ( value ) ; begin
105986: LD_INT 0
105988: PPUSH
// result := not value ;
105989: LD_ADDR_VAR 0 2
105993: PUSH
105994: LD_VAR 0 1
105998: NOT
105999: ST_TO_ADDR
// end ;
106000: LD_VAR 0 2
106004: RET
// export function Inc ( value ) ; begin
106005: LD_INT 0
106007: PPUSH
// result := value + 1 ;
106008: LD_ADDR_VAR 0 2
106012: PUSH
106013: LD_VAR 0 1
106017: PUSH
106018: LD_INT 1
106020: PLUS
106021: ST_TO_ADDR
// end ;
106022: LD_VAR 0 2
106026: RET
// export function Dec ( value ) ; begin
106027: LD_INT 0
106029: PPUSH
// result := value - 1 ;
106030: LD_ADDR_VAR 0 2
106034: PUSH
106035: LD_VAR 0 1
106039: PUSH
106040: LD_INT 1
106042: MINUS
106043: ST_TO_ADDR
// end ;
106044: LD_VAR 0 2
106048: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
106049: LD_INT 0
106051: PPUSH
106052: PPUSH
106053: PPUSH
106054: PPUSH
106055: PPUSH
106056: PPUSH
106057: PPUSH
106058: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
106059: LD_VAR 0 1
106063: PPUSH
106064: LD_VAR 0 2
106068: PPUSH
106069: CALL_OW 488
106073: NOT
106074: PUSH
106075: LD_VAR 0 3
106079: PPUSH
106080: LD_VAR 0 4
106084: PPUSH
106085: CALL_OW 488
106089: NOT
106090: OR
106091: IFFALSE 106104
// begin result := - 1 ;
106093: LD_ADDR_VAR 0 5
106097: PUSH
106098: LD_INT 1
106100: NEG
106101: ST_TO_ADDR
// exit ;
106102: GO 106339
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
106104: LD_ADDR_VAR 0 12
106108: PUSH
106109: LD_VAR 0 1
106113: PPUSH
106114: LD_VAR 0 2
106118: PPUSH
106119: LD_VAR 0 3
106123: PPUSH
106124: LD_VAR 0 4
106128: PPUSH
106129: CALL 105189 0 4
106133: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
106134: LD_ADDR_VAR 0 11
106138: PUSH
106139: LD_VAR 0 1
106143: PPUSH
106144: LD_VAR 0 2
106148: PPUSH
106149: LD_VAR 0 12
106153: PUSH
106154: LD_INT 1
106156: ARRAY
106157: PPUSH
106158: LD_VAR 0 12
106162: PUSH
106163: LD_INT 2
106165: ARRAY
106166: PPUSH
106167: CALL_OW 298
106171: ST_TO_ADDR
// distance := 9999 ;
106172: LD_ADDR_VAR 0 10
106176: PUSH
106177: LD_INT 9999
106179: ST_TO_ADDR
// for i := 0 to 5 do
106180: LD_ADDR_VAR 0 6
106184: PUSH
106185: DOUBLE
106186: LD_INT 0
106188: DEC
106189: ST_TO_ADDR
106190: LD_INT 5
106192: PUSH
106193: FOR_TO
106194: IFFALSE 106337
// begin _x := ShiftX ( x1 , i , centerDist ) ;
106196: LD_ADDR_VAR 0 7
106200: PUSH
106201: LD_VAR 0 1
106205: PPUSH
106206: LD_VAR 0 6
106210: PPUSH
106211: LD_VAR 0 11
106215: PPUSH
106216: CALL_OW 272
106220: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
106221: LD_ADDR_VAR 0 8
106225: PUSH
106226: LD_VAR 0 2
106230: PPUSH
106231: LD_VAR 0 6
106235: PPUSH
106236: LD_VAR 0 11
106240: PPUSH
106241: CALL_OW 273
106245: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106246: LD_VAR 0 7
106250: PPUSH
106251: LD_VAR 0 8
106255: PPUSH
106256: CALL_OW 488
106260: NOT
106261: IFFALSE 106265
// continue ;
106263: GO 106193
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
106265: LD_ADDR_VAR 0 9
106269: PUSH
106270: LD_VAR 0 12
106274: PUSH
106275: LD_INT 1
106277: ARRAY
106278: PPUSH
106279: LD_VAR 0 12
106283: PUSH
106284: LD_INT 2
106286: ARRAY
106287: PPUSH
106288: LD_VAR 0 7
106292: PPUSH
106293: LD_VAR 0 8
106297: PPUSH
106298: CALL_OW 298
106302: ST_TO_ADDR
// if tmp < distance then
106303: LD_VAR 0 9
106307: PUSH
106308: LD_VAR 0 10
106312: LESS
106313: IFFALSE 106335
// begin result := i ;
106315: LD_ADDR_VAR 0 5
106319: PUSH
106320: LD_VAR 0 6
106324: ST_TO_ADDR
// distance := tmp ;
106325: LD_ADDR_VAR 0 10
106329: PUSH
106330: LD_VAR 0 9
106334: ST_TO_ADDR
// end ; end ;
106335: GO 106193
106337: POP
106338: POP
// end ;
106339: LD_VAR 0 5
106343: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106344: LD_INT 0
106346: PPUSH
106347: PPUSH
// if not driver or not IsInUnit ( driver ) then
106348: LD_VAR 0 1
106352: NOT
106353: PUSH
106354: LD_VAR 0 1
106358: PPUSH
106359: CALL_OW 310
106363: NOT
106364: OR
106365: IFFALSE 106369
// exit ;
106367: GO 106459
// vehicle := IsInUnit ( driver ) ;
106369: LD_ADDR_VAR 0 3
106373: PUSH
106374: LD_VAR 0 1
106378: PPUSH
106379: CALL_OW 310
106383: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106384: LD_VAR 0 1
106388: PPUSH
106389: LD_STRING \
106391: PUSH
106392: LD_INT 0
106394: PUSH
106395: LD_INT 0
106397: PUSH
106398: LD_INT 0
106400: PUSH
106401: LD_INT 0
106403: PUSH
106404: LD_INT 0
106406: PUSH
106407: LD_INT 0
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: LIST
106414: LIST
106415: LIST
106416: LIST
106417: LIST
106418: PUSH
106419: LD_STRING E
106421: PUSH
106422: LD_INT 0
106424: PUSH
106425: LD_INT 0
106427: PUSH
106428: LD_VAR 0 3
106432: PUSH
106433: LD_INT 0
106435: PUSH
106436: LD_INT 0
106438: PUSH
106439: LD_INT 0
106441: PUSH
106442: EMPTY
106443: LIST
106444: LIST
106445: LIST
106446: LIST
106447: LIST
106448: LIST
106449: LIST
106450: PUSH
106451: EMPTY
106452: LIST
106453: LIST
106454: PPUSH
106455: CALL_OW 446
// end ;
106459: LD_VAR 0 2
106463: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
106464: LD_INT 0
106466: PPUSH
106467: PPUSH
// if not driver or not IsInUnit ( driver ) then
106468: LD_VAR 0 1
106472: NOT
106473: PUSH
106474: LD_VAR 0 1
106478: PPUSH
106479: CALL_OW 310
106483: NOT
106484: OR
106485: IFFALSE 106489
// exit ;
106487: GO 106579
// vehicle := IsInUnit ( driver ) ;
106489: LD_ADDR_VAR 0 3
106493: PUSH
106494: LD_VAR 0 1
106498: PPUSH
106499: CALL_OW 310
106503: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
106504: LD_VAR 0 1
106508: PPUSH
106509: LD_STRING \
106511: PUSH
106512: LD_INT 0
106514: PUSH
106515: LD_INT 0
106517: PUSH
106518: LD_INT 0
106520: PUSH
106521: LD_INT 0
106523: PUSH
106524: LD_INT 0
106526: PUSH
106527: LD_INT 0
106529: PUSH
106530: EMPTY
106531: LIST
106532: LIST
106533: LIST
106534: LIST
106535: LIST
106536: LIST
106537: LIST
106538: PUSH
106539: LD_STRING E
106541: PUSH
106542: LD_INT 0
106544: PUSH
106545: LD_INT 0
106547: PUSH
106548: LD_VAR 0 3
106552: PUSH
106553: LD_INT 0
106555: PUSH
106556: LD_INT 0
106558: PUSH
106559: LD_INT 0
106561: PUSH
106562: EMPTY
106563: LIST
106564: LIST
106565: LIST
106566: LIST
106567: LIST
106568: LIST
106569: LIST
106570: PUSH
106571: EMPTY
106572: LIST
106573: LIST
106574: PPUSH
106575: CALL_OW 447
// end ;
106579: LD_VAR 0 2
106583: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
106584: LD_INT 0
106586: PPUSH
106587: PPUSH
106588: PPUSH
// tmp := [ ] ;
106589: LD_ADDR_VAR 0 5
106593: PUSH
106594: EMPTY
106595: ST_TO_ADDR
// for i in units do
106596: LD_ADDR_VAR 0 4
106600: PUSH
106601: LD_VAR 0 1
106605: PUSH
106606: FOR_IN
106607: IFFALSE 106645
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
106609: LD_ADDR_VAR 0 5
106613: PUSH
106614: LD_VAR 0 5
106618: PPUSH
106619: LD_VAR 0 5
106623: PUSH
106624: LD_INT 1
106626: PLUS
106627: PPUSH
106628: LD_VAR 0 4
106632: PPUSH
106633: CALL_OW 256
106637: PPUSH
106638: CALL_OW 2
106642: ST_TO_ADDR
106643: GO 106606
106645: POP
106646: POP
// if not tmp then
106647: LD_VAR 0 5
106651: NOT
106652: IFFALSE 106656
// exit ;
106654: GO 106704
// if asc then
106656: LD_VAR 0 2
106660: IFFALSE 106684
// result := SortListByListAsc ( units , tmp ) else
106662: LD_ADDR_VAR 0 3
106666: PUSH
106667: LD_VAR 0 1
106671: PPUSH
106672: LD_VAR 0 5
106676: PPUSH
106677: CALL_OW 76
106681: ST_TO_ADDR
106682: GO 106704
// result := SortListByListDesc ( units , tmp ) ;
106684: LD_ADDR_VAR 0 3
106688: PUSH
106689: LD_VAR 0 1
106693: PPUSH
106694: LD_VAR 0 5
106698: PPUSH
106699: CALL_OW 77
106703: ST_TO_ADDR
// end ;
106704: LD_VAR 0 3
106708: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
106709: LD_INT 0
106711: PPUSH
106712: PPUSH
// task := GetTaskList ( mech ) ;
106713: LD_ADDR_VAR 0 4
106717: PUSH
106718: LD_VAR 0 1
106722: PPUSH
106723: CALL_OW 437
106727: ST_TO_ADDR
// if not task then
106728: LD_VAR 0 4
106732: NOT
106733: IFFALSE 106737
// exit ;
106735: GO 106779
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
106737: LD_ADDR_VAR 0 3
106741: PUSH
106742: LD_VAR 0 4
106746: PUSH
106747: LD_INT 1
106749: ARRAY
106750: PUSH
106751: LD_INT 1
106753: ARRAY
106754: PUSH
106755: LD_STRING r
106757: EQUAL
106758: PUSH
106759: LD_VAR 0 4
106763: PUSH
106764: LD_INT 1
106766: ARRAY
106767: PUSH
106768: LD_INT 4
106770: ARRAY
106771: PUSH
106772: LD_VAR 0 2
106776: EQUAL
106777: AND
106778: ST_TO_ADDR
// end ;
106779: LD_VAR 0 3
106783: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
106784: LD_INT 0
106786: PPUSH
// SetDir ( unit , d ) ;
106787: LD_VAR 0 1
106791: PPUSH
106792: LD_VAR 0 4
106796: PPUSH
106797: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
106801: LD_VAR 0 1
106805: PPUSH
106806: LD_VAR 0 2
106810: PPUSH
106811: LD_VAR 0 3
106815: PPUSH
106816: LD_VAR 0 5
106820: PPUSH
106821: CALL_OW 48
// end ;
106825: LD_VAR 0 6
106829: RET
// export function ToNaturalNumber ( number ) ; begin
106830: LD_INT 0
106832: PPUSH
// result := number div 1 ;
106833: LD_ADDR_VAR 0 2
106837: PUSH
106838: LD_VAR 0 1
106842: PUSH
106843: LD_INT 1
106845: DIV
106846: ST_TO_ADDR
// if number < 0 then
106847: LD_VAR 0 1
106851: PUSH
106852: LD_INT 0
106854: LESS
106855: IFFALSE 106865
// result := 0 ;
106857: LD_ADDR_VAR 0 2
106861: PUSH
106862: LD_INT 0
106864: ST_TO_ADDR
// end ;
106865: LD_VAR 0 2
106869: RET
// export function SortByClass ( units , class ) ; var un ; begin
106870: LD_INT 0
106872: PPUSH
106873: PPUSH
// if not units or not class then
106874: LD_VAR 0 1
106878: NOT
106879: PUSH
106880: LD_VAR 0 2
106884: NOT
106885: OR
106886: IFFALSE 106890
// exit ;
106888: GO 106985
// result := [ ] ;
106890: LD_ADDR_VAR 0 3
106894: PUSH
106895: EMPTY
106896: ST_TO_ADDR
// for un in units do
106897: LD_ADDR_VAR 0 4
106901: PUSH
106902: LD_VAR 0 1
106906: PUSH
106907: FOR_IN
106908: IFFALSE 106983
// if GetClass ( un ) = class then
106910: LD_VAR 0 4
106914: PPUSH
106915: CALL_OW 257
106919: PUSH
106920: LD_VAR 0 2
106924: EQUAL
106925: IFFALSE 106952
// result := Insert ( result , 1 , un ) else
106927: LD_ADDR_VAR 0 3
106931: PUSH
106932: LD_VAR 0 3
106936: PPUSH
106937: LD_INT 1
106939: PPUSH
106940: LD_VAR 0 4
106944: PPUSH
106945: CALL_OW 2
106949: ST_TO_ADDR
106950: GO 106981
// result := Replace ( result , result + 1 , un ) ;
106952: LD_ADDR_VAR 0 3
106956: PUSH
106957: LD_VAR 0 3
106961: PPUSH
106962: LD_VAR 0 3
106966: PUSH
106967: LD_INT 1
106969: PLUS
106970: PPUSH
106971: LD_VAR 0 4
106975: PPUSH
106976: CALL_OW 1
106980: ST_TO_ADDR
106981: GO 106907
106983: POP
106984: POP
// end ;
106985: LD_VAR 0 3
106989: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
106990: LD_INT 0
106992: PPUSH
106993: PPUSH
106994: PPUSH
106995: PPUSH
106996: PPUSH
106997: PPUSH
106998: PPUSH
// result := [ ] ;
106999: LD_ADDR_VAR 0 4
107003: PUSH
107004: EMPTY
107005: ST_TO_ADDR
// if x - r < 0 then
107006: LD_VAR 0 1
107010: PUSH
107011: LD_VAR 0 3
107015: MINUS
107016: PUSH
107017: LD_INT 0
107019: LESS
107020: IFFALSE 107032
// min_x := 0 else
107022: LD_ADDR_VAR 0 8
107026: PUSH
107027: LD_INT 0
107029: ST_TO_ADDR
107030: GO 107048
// min_x := x - r ;
107032: LD_ADDR_VAR 0 8
107036: PUSH
107037: LD_VAR 0 1
107041: PUSH
107042: LD_VAR 0 3
107046: MINUS
107047: ST_TO_ADDR
// if y - r < 0 then
107048: LD_VAR 0 2
107052: PUSH
107053: LD_VAR 0 3
107057: MINUS
107058: PUSH
107059: LD_INT 0
107061: LESS
107062: IFFALSE 107074
// min_y := 0 else
107064: LD_ADDR_VAR 0 7
107068: PUSH
107069: LD_INT 0
107071: ST_TO_ADDR
107072: GO 107090
// min_y := y - r ;
107074: LD_ADDR_VAR 0 7
107078: PUSH
107079: LD_VAR 0 2
107083: PUSH
107084: LD_VAR 0 3
107088: MINUS
107089: ST_TO_ADDR
// max_x := x + r ;
107090: LD_ADDR_VAR 0 9
107094: PUSH
107095: LD_VAR 0 1
107099: PUSH
107100: LD_VAR 0 3
107104: PLUS
107105: ST_TO_ADDR
// max_y := y + r ;
107106: LD_ADDR_VAR 0 10
107110: PUSH
107111: LD_VAR 0 2
107115: PUSH
107116: LD_VAR 0 3
107120: PLUS
107121: ST_TO_ADDR
// for _x = min_x to max_x do
107122: LD_ADDR_VAR 0 5
107126: PUSH
107127: DOUBLE
107128: LD_VAR 0 8
107132: DEC
107133: ST_TO_ADDR
107134: LD_VAR 0 9
107138: PUSH
107139: FOR_TO
107140: IFFALSE 107241
// for _y = min_y to max_y do
107142: LD_ADDR_VAR 0 6
107146: PUSH
107147: DOUBLE
107148: LD_VAR 0 7
107152: DEC
107153: ST_TO_ADDR
107154: LD_VAR 0 10
107158: PUSH
107159: FOR_TO
107160: IFFALSE 107237
// begin if not ValidHex ( _x , _y ) then
107162: LD_VAR 0 5
107166: PPUSH
107167: LD_VAR 0 6
107171: PPUSH
107172: CALL_OW 488
107176: NOT
107177: IFFALSE 107181
// continue ;
107179: GO 107159
// if GetResourceTypeXY ( _x , _y ) then
107181: LD_VAR 0 5
107185: PPUSH
107186: LD_VAR 0 6
107190: PPUSH
107191: CALL_OW 283
107195: IFFALSE 107235
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
107197: LD_ADDR_VAR 0 4
107201: PUSH
107202: LD_VAR 0 4
107206: PPUSH
107207: LD_VAR 0 4
107211: PUSH
107212: LD_INT 1
107214: PLUS
107215: PPUSH
107216: LD_VAR 0 5
107220: PUSH
107221: LD_VAR 0 6
107225: PUSH
107226: EMPTY
107227: LIST
107228: LIST
107229: PPUSH
107230: CALL_OW 1
107234: ST_TO_ADDR
// end ;
107235: GO 107159
107237: POP
107238: POP
107239: GO 107139
107241: POP
107242: POP
// end ;
107243: LD_VAR 0 4
107247: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
107248: LD_INT 0
107250: PPUSH
107251: PPUSH
107252: PPUSH
107253: PPUSH
107254: PPUSH
107255: PPUSH
107256: PPUSH
107257: PPUSH
// if not units then
107258: LD_VAR 0 1
107262: NOT
107263: IFFALSE 107267
// exit ;
107265: GO 107791
// result := UnitFilter ( units , [ f_ok ] ) ;
107267: LD_ADDR_VAR 0 3
107271: PUSH
107272: LD_VAR 0 1
107276: PPUSH
107277: LD_INT 50
107279: PUSH
107280: EMPTY
107281: LIST
107282: PPUSH
107283: CALL_OW 72
107287: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
107288: LD_ADDR_VAR 0 8
107292: PUSH
107293: LD_VAR 0 1
107297: PUSH
107298: LD_INT 1
107300: ARRAY
107301: PPUSH
107302: CALL_OW 255
107306: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
107307: LD_ADDR_VAR 0 10
107311: PUSH
107312: LD_INT 29
107314: PUSH
107315: LD_INT 91
107317: PUSH
107318: LD_INT 49
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: LIST
107325: ST_TO_ADDR
// if not result then
107326: LD_VAR 0 3
107330: NOT
107331: IFFALSE 107335
// exit ;
107333: GO 107791
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
107335: LD_ADDR_VAR 0 5
107339: PUSH
107340: LD_INT 81
107342: PUSH
107343: LD_VAR 0 8
107347: PUSH
107348: EMPTY
107349: LIST
107350: LIST
107351: PPUSH
107352: CALL_OW 69
107356: ST_TO_ADDR
// for i in result do
107357: LD_ADDR_VAR 0 4
107361: PUSH
107362: LD_VAR 0 3
107366: PUSH
107367: FOR_IN
107368: IFFALSE 107789
// begin tag := GetTag ( i ) + 1 ;
107370: LD_ADDR_VAR 0 9
107374: PUSH
107375: LD_VAR 0 4
107379: PPUSH
107380: CALL_OW 110
107384: PUSH
107385: LD_INT 1
107387: PLUS
107388: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
107389: LD_ADDR_VAR 0 7
107393: PUSH
107394: LD_VAR 0 4
107398: PPUSH
107399: CALL_OW 250
107403: PPUSH
107404: LD_VAR 0 4
107408: PPUSH
107409: CALL_OW 251
107413: PPUSH
107414: LD_INT 6
107416: PPUSH
107417: CALL 106990 0 3
107421: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
107422: LD_VAR 0 4
107426: PPUSH
107427: CALL_OW 247
107431: PUSH
107432: LD_INT 2
107434: EQUAL
107435: PUSH
107436: LD_VAR 0 7
107440: AND
107441: PUSH
107442: LD_VAR 0 4
107446: PPUSH
107447: CALL_OW 264
107451: PUSH
107452: LD_VAR 0 10
107456: IN
107457: NOT
107458: AND
107459: IFFALSE 107498
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
107461: LD_VAR 0 4
107465: PPUSH
107466: LD_VAR 0 7
107470: PUSH
107471: LD_INT 1
107473: ARRAY
107474: PUSH
107475: LD_INT 1
107477: ARRAY
107478: PPUSH
107479: LD_VAR 0 7
107483: PUSH
107484: LD_INT 1
107486: ARRAY
107487: PUSH
107488: LD_INT 2
107490: ARRAY
107491: PPUSH
107492: CALL_OW 116
107496: GO 107787
// if path > tag then
107498: LD_VAR 0 2
107502: PUSH
107503: LD_VAR 0 9
107507: GREATER
107508: IFFALSE 107716
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
107510: LD_ADDR_VAR 0 6
107514: PUSH
107515: LD_VAR 0 5
107519: PPUSH
107520: LD_INT 91
107522: PUSH
107523: LD_VAR 0 4
107527: PUSH
107528: LD_INT 8
107530: PUSH
107531: EMPTY
107532: LIST
107533: LIST
107534: LIST
107535: PPUSH
107536: CALL_OW 72
107540: ST_TO_ADDR
// if nearEnemy then
107541: LD_VAR 0 6
107545: IFFALSE 107614
// begin if GetWeapon ( i ) = ru_time_lapser then
107547: LD_VAR 0 4
107551: PPUSH
107552: CALL_OW 264
107556: PUSH
107557: LD_INT 49
107559: EQUAL
107560: IFFALSE 107588
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
107562: LD_VAR 0 4
107566: PPUSH
107567: LD_VAR 0 6
107571: PPUSH
107572: LD_VAR 0 4
107576: PPUSH
107577: CALL_OW 74
107581: PPUSH
107582: CALL_OW 112
107586: GO 107612
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
107588: LD_VAR 0 4
107592: PPUSH
107593: LD_VAR 0 6
107597: PPUSH
107598: LD_VAR 0 4
107602: PPUSH
107603: CALL_OW 74
107607: PPUSH
107608: CALL_OW 115
// end else
107612: GO 107714
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
107614: LD_VAR 0 4
107618: PPUSH
107619: LD_VAR 0 2
107623: PUSH
107624: LD_VAR 0 9
107628: ARRAY
107629: PUSH
107630: LD_INT 1
107632: ARRAY
107633: PPUSH
107634: LD_VAR 0 2
107638: PUSH
107639: LD_VAR 0 9
107643: ARRAY
107644: PUSH
107645: LD_INT 2
107647: ARRAY
107648: PPUSH
107649: CALL_OW 297
107653: PUSH
107654: LD_INT 6
107656: GREATER
107657: IFFALSE 107700
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
107659: LD_VAR 0 4
107663: PPUSH
107664: LD_VAR 0 2
107668: PUSH
107669: LD_VAR 0 9
107673: ARRAY
107674: PUSH
107675: LD_INT 1
107677: ARRAY
107678: PPUSH
107679: LD_VAR 0 2
107683: PUSH
107684: LD_VAR 0 9
107688: ARRAY
107689: PUSH
107690: LD_INT 2
107692: ARRAY
107693: PPUSH
107694: CALL_OW 114
107698: GO 107714
// SetTag ( i , tag ) ;
107700: LD_VAR 0 4
107704: PPUSH
107705: LD_VAR 0 9
107709: PPUSH
107710: CALL_OW 109
// end else
107714: GO 107787
// if enemy then
107716: LD_VAR 0 5
107720: IFFALSE 107787
// begin if GetWeapon ( i ) = ru_time_lapser then
107722: LD_VAR 0 4
107726: PPUSH
107727: CALL_OW 264
107731: PUSH
107732: LD_INT 49
107734: EQUAL
107735: IFFALSE 107763
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107737: LD_VAR 0 4
107741: PPUSH
107742: LD_VAR 0 5
107746: PPUSH
107747: LD_VAR 0 4
107751: PPUSH
107752: CALL_OW 74
107756: PPUSH
107757: CALL_OW 112
107761: GO 107787
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
107763: LD_VAR 0 4
107767: PPUSH
107768: LD_VAR 0 5
107772: PPUSH
107773: LD_VAR 0 4
107777: PPUSH
107778: CALL_OW 74
107782: PPUSH
107783: CALL_OW 115
// end ; end ;
107787: GO 107367
107789: POP
107790: POP
// end ;
107791: LD_VAR 0 3
107795: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
107796: LD_INT 0
107798: PPUSH
107799: PPUSH
107800: PPUSH
// if not unit or IsInUnit ( unit ) then
107801: LD_VAR 0 1
107805: NOT
107806: PUSH
107807: LD_VAR 0 1
107811: PPUSH
107812: CALL_OW 310
107816: OR
107817: IFFALSE 107821
// exit ;
107819: GO 107912
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
107821: LD_ADDR_VAR 0 4
107825: PUSH
107826: LD_VAR 0 1
107830: PPUSH
107831: CALL_OW 250
107835: PPUSH
107836: LD_VAR 0 2
107840: PPUSH
107841: LD_INT 1
107843: PPUSH
107844: CALL_OW 272
107848: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
107849: LD_ADDR_VAR 0 5
107853: PUSH
107854: LD_VAR 0 1
107858: PPUSH
107859: CALL_OW 251
107863: PPUSH
107864: LD_VAR 0 2
107868: PPUSH
107869: LD_INT 1
107871: PPUSH
107872: CALL_OW 273
107876: ST_TO_ADDR
// if ValidHex ( x , y ) then
107877: LD_VAR 0 4
107881: PPUSH
107882: LD_VAR 0 5
107886: PPUSH
107887: CALL_OW 488
107891: IFFALSE 107912
// ComTurnXY ( unit , x , y ) ;
107893: LD_VAR 0 1
107897: PPUSH
107898: LD_VAR 0 4
107902: PPUSH
107903: LD_VAR 0 5
107907: PPUSH
107908: CALL_OW 118
// end ;
107912: LD_VAR 0 3
107916: RET
// export function SeeUnits ( side , units ) ; var i ; begin
107917: LD_INT 0
107919: PPUSH
107920: PPUSH
// result := false ;
107921: LD_ADDR_VAR 0 3
107925: PUSH
107926: LD_INT 0
107928: ST_TO_ADDR
// if not units then
107929: LD_VAR 0 2
107933: NOT
107934: IFFALSE 107938
// exit ;
107936: GO 107983
// for i in units do
107938: LD_ADDR_VAR 0 4
107942: PUSH
107943: LD_VAR 0 2
107947: PUSH
107948: FOR_IN
107949: IFFALSE 107981
// if See ( side , i ) then
107951: LD_VAR 0 1
107955: PPUSH
107956: LD_VAR 0 4
107960: PPUSH
107961: CALL_OW 292
107965: IFFALSE 107979
// begin result := true ;
107967: LD_ADDR_VAR 0 3
107971: PUSH
107972: LD_INT 1
107974: ST_TO_ADDR
// exit ;
107975: POP
107976: POP
107977: GO 107983
// end ;
107979: GO 107948
107981: POP
107982: POP
// end ;
107983: LD_VAR 0 3
107987: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
107988: LD_INT 0
107990: PPUSH
107991: PPUSH
107992: PPUSH
107993: PPUSH
// if not unit or not points then
107994: LD_VAR 0 1
107998: NOT
107999: PUSH
108000: LD_VAR 0 2
108004: NOT
108005: OR
108006: IFFALSE 108010
// exit ;
108008: GO 108100
// dist := 99999 ;
108010: LD_ADDR_VAR 0 5
108014: PUSH
108015: LD_INT 99999
108017: ST_TO_ADDR
// for i in points do
108018: LD_ADDR_VAR 0 4
108022: PUSH
108023: LD_VAR 0 2
108027: PUSH
108028: FOR_IN
108029: IFFALSE 108098
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
108031: LD_ADDR_VAR 0 6
108035: PUSH
108036: LD_VAR 0 1
108040: PPUSH
108041: LD_VAR 0 4
108045: PUSH
108046: LD_INT 1
108048: ARRAY
108049: PPUSH
108050: LD_VAR 0 4
108054: PUSH
108055: LD_INT 2
108057: ARRAY
108058: PPUSH
108059: CALL_OW 297
108063: ST_TO_ADDR
// if tmpDist < dist then
108064: LD_VAR 0 6
108068: PUSH
108069: LD_VAR 0 5
108073: LESS
108074: IFFALSE 108096
// begin result := i ;
108076: LD_ADDR_VAR 0 3
108080: PUSH
108081: LD_VAR 0 4
108085: ST_TO_ADDR
// dist := tmpDist ;
108086: LD_ADDR_VAR 0 5
108090: PUSH
108091: LD_VAR 0 6
108095: ST_TO_ADDR
// end ; end ;
108096: GO 108028
108098: POP
108099: POP
// end ;
108100: LD_VAR 0 3
108104: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
108105: LD_INT 0
108107: PPUSH
// uc_side := side ;
108108: LD_ADDR_OWVAR 20
108112: PUSH
108113: LD_VAR 0 1
108117: ST_TO_ADDR
// uc_nation := 3 ;
108118: LD_ADDR_OWVAR 21
108122: PUSH
108123: LD_INT 3
108125: ST_TO_ADDR
// vc_chassis := 25 ;
108126: LD_ADDR_OWVAR 37
108130: PUSH
108131: LD_INT 25
108133: ST_TO_ADDR
// vc_engine := engine_siberite ;
108134: LD_ADDR_OWVAR 39
108138: PUSH
108139: LD_INT 3
108141: ST_TO_ADDR
// vc_control := control_computer ;
108142: LD_ADDR_OWVAR 38
108146: PUSH
108147: LD_INT 3
108149: ST_TO_ADDR
// vc_weapon := 59 ;
108150: LD_ADDR_OWVAR 40
108154: PUSH
108155: LD_INT 59
108157: ST_TO_ADDR
// result := CreateVehicle ;
108158: LD_ADDR_VAR 0 5
108162: PUSH
108163: CALL_OW 45
108167: ST_TO_ADDR
// SetDir ( result , d ) ;
108168: LD_VAR 0 5
108172: PPUSH
108173: LD_VAR 0 4
108177: PPUSH
108178: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
108182: LD_VAR 0 5
108186: PPUSH
108187: LD_VAR 0 2
108191: PPUSH
108192: LD_VAR 0 3
108196: PPUSH
108197: LD_INT 0
108199: PPUSH
108200: CALL_OW 48
// end ;
108204: LD_VAR 0 5
108208: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
108209: LD_INT 0
108211: PPUSH
108212: PPUSH
108213: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
108214: LD_ADDR_VAR 0 2
108218: PUSH
108219: LD_INT 0
108221: PUSH
108222: LD_INT 0
108224: PUSH
108225: LD_INT 0
108227: PUSH
108228: LD_INT 0
108230: PUSH
108231: EMPTY
108232: LIST
108233: LIST
108234: LIST
108235: LIST
108236: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
108237: LD_VAR 0 1
108241: NOT
108242: PUSH
108243: LD_VAR 0 1
108247: PPUSH
108248: CALL_OW 264
108252: PUSH
108253: LD_INT 12
108255: PUSH
108256: LD_INT 51
108258: PUSH
108259: LD_INT 32
108261: PUSH
108262: LD_INT 89
108264: PUSH
108265: EMPTY
108266: LIST
108267: LIST
108268: LIST
108269: LIST
108270: IN
108271: NOT
108272: OR
108273: IFFALSE 108277
// exit ;
108275: GO 108375
// for i := 1 to 3 do
108277: LD_ADDR_VAR 0 3
108281: PUSH
108282: DOUBLE
108283: LD_INT 1
108285: DEC
108286: ST_TO_ADDR
108287: LD_INT 3
108289: PUSH
108290: FOR_TO
108291: IFFALSE 108373
// begin tmp := GetCargo ( cargo , i ) ;
108293: LD_ADDR_VAR 0 4
108297: PUSH
108298: LD_VAR 0 1
108302: PPUSH
108303: LD_VAR 0 3
108307: PPUSH
108308: CALL_OW 289
108312: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
108313: LD_ADDR_VAR 0 2
108317: PUSH
108318: LD_VAR 0 2
108322: PPUSH
108323: LD_VAR 0 3
108327: PPUSH
108328: LD_VAR 0 4
108332: PPUSH
108333: CALL_OW 1
108337: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
108338: LD_ADDR_VAR 0 2
108342: PUSH
108343: LD_VAR 0 2
108347: PPUSH
108348: LD_INT 4
108350: PPUSH
108351: LD_VAR 0 2
108355: PUSH
108356: LD_INT 4
108358: ARRAY
108359: PUSH
108360: LD_VAR 0 4
108364: PLUS
108365: PPUSH
108366: CALL_OW 1
108370: ST_TO_ADDR
// end ;
108371: GO 108290
108373: POP
108374: POP
// end ;
108375: LD_VAR 0 2
108379: RET
// export function Length ( array ) ; begin
108380: LD_INT 0
108382: PPUSH
// result := array + 0 ;
108383: LD_ADDR_VAR 0 2
108387: PUSH
108388: LD_VAR 0 1
108392: PUSH
108393: LD_INT 0
108395: PLUS
108396: ST_TO_ADDR
// end ;
108397: LD_VAR 0 2
108401: RET
// export function PrepareArray ( array ) ; begin
108402: LD_INT 0
108404: PPUSH
// result := array diff 0 ;
108405: LD_ADDR_VAR 0 2
108409: PUSH
108410: LD_VAR 0 1
108414: PUSH
108415: LD_INT 0
108417: DIFF
108418: ST_TO_ADDR
// if not result [ 1 ] then
108419: LD_VAR 0 2
108423: PUSH
108424: LD_INT 1
108426: ARRAY
108427: NOT
108428: IFFALSE 108448
// result := Delete ( result , 1 ) ;
108430: LD_ADDR_VAR 0 2
108434: PUSH
108435: LD_VAR 0 2
108439: PPUSH
108440: LD_INT 1
108442: PPUSH
108443: CALL_OW 3
108447: ST_TO_ADDR
// end ; end_of_file end_of_file
108448: LD_VAR 0 2
108452: RET
// every 0 0$1 do
108453: GO 108455
108455: DISABLE
// begin enable ;
108456: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
108457: LD_STRING updateTimer(
108459: PUSH
108460: LD_OWVAR 1
108464: STR
108465: PUSH
108466: LD_STRING );
108468: STR
108469: PPUSH
108470: CALL_OW 559
// end ;
108474: END
// export function SOS_MapStart ( ) ; begin
108475: LD_INT 0
108477: PPUSH
// if streamModeActive then
108478: LD_EXP 143
108482: IFFALSE 108491
// DefineStreamItems ( true ) ;
108484: LD_INT 1
108486: PPUSH
108487: CALL 110145 0 1
// UpdateFactoryWaypoints ( ) ;
108491: CALL 123006 0 0
// UpdateWarehouseGatheringPoints ( ) ;
108495: CALL 123263 0 0
// end ;
108499: LD_VAR 0 1
108503: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108504: LD_INT 0
108506: PPUSH
// if p2 = 100 then
108507: LD_VAR 0 2
108511: PUSH
108512: LD_INT 100
108514: EQUAL
108515: IFFALSE 109518
// begin if not StreamModeActive then
108517: LD_EXP 143
108521: NOT
108522: IFFALSE 108532
// StreamModeActive := true ;
108524: LD_ADDR_EXP 143
108528: PUSH
108529: LD_INT 1
108531: ST_TO_ADDR
// if p3 = 0 then
108532: LD_VAR 0 3
108536: PUSH
108537: LD_INT 0
108539: EQUAL
108540: IFFALSE 108546
// InitStreamMode ;
108542: CALL 109681 0 0
// if p3 = 1 then
108546: LD_VAR 0 3
108550: PUSH
108551: LD_INT 1
108553: EQUAL
108554: IFFALSE 108564
// sRocket := true ;
108556: LD_ADDR_EXP 148
108560: PUSH
108561: LD_INT 1
108563: ST_TO_ADDR
// if p3 = 2 then
108564: LD_VAR 0 3
108568: PUSH
108569: LD_INT 2
108571: EQUAL
108572: IFFALSE 108582
// sSpeed := true ;
108574: LD_ADDR_EXP 147
108578: PUSH
108579: LD_INT 1
108581: ST_TO_ADDR
// if p3 = 3 then
108582: LD_VAR 0 3
108586: PUSH
108587: LD_INT 3
108589: EQUAL
108590: IFFALSE 108600
// sEngine := true ;
108592: LD_ADDR_EXP 149
108596: PUSH
108597: LD_INT 1
108599: ST_TO_ADDR
// if p3 = 4 then
108600: LD_VAR 0 3
108604: PUSH
108605: LD_INT 4
108607: EQUAL
108608: IFFALSE 108618
// sSpec := true ;
108610: LD_ADDR_EXP 146
108614: PUSH
108615: LD_INT 1
108617: ST_TO_ADDR
// if p3 = 5 then
108618: LD_VAR 0 3
108622: PUSH
108623: LD_INT 5
108625: EQUAL
108626: IFFALSE 108636
// sLevel := true ;
108628: LD_ADDR_EXP 150
108632: PUSH
108633: LD_INT 1
108635: ST_TO_ADDR
// if p3 = 6 then
108636: LD_VAR 0 3
108640: PUSH
108641: LD_INT 6
108643: EQUAL
108644: IFFALSE 108654
// sArmoury := true ;
108646: LD_ADDR_EXP 151
108650: PUSH
108651: LD_INT 1
108653: ST_TO_ADDR
// if p3 = 7 then
108654: LD_VAR 0 3
108658: PUSH
108659: LD_INT 7
108661: EQUAL
108662: IFFALSE 108672
// sRadar := true ;
108664: LD_ADDR_EXP 152
108668: PUSH
108669: LD_INT 1
108671: ST_TO_ADDR
// if p3 = 8 then
108672: LD_VAR 0 3
108676: PUSH
108677: LD_INT 8
108679: EQUAL
108680: IFFALSE 108690
// sBunker := true ;
108682: LD_ADDR_EXP 153
108686: PUSH
108687: LD_INT 1
108689: ST_TO_ADDR
// if p3 = 9 then
108690: LD_VAR 0 3
108694: PUSH
108695: LD_INT 9
108697: EQUAL
108698: IFFALSE 108708
// sHack := true ;
108700: LD_ADDR_EXP 154
108704: PUSH
108705: LD_INT 1
108707: ST_TO_ADDR
// if p3 = 10 then
108708: LD_VAR 0 3
108712: PUSH
108713: LD_INT 10
108715: EQUAL
108716: IFFALSE 108726
// sFire := true ;
108718: LD_ADDR_EXP 155
108722: PUSH
108723: LD_INT 1
108725: ST_TO_ADDR
// if p3 = 11 then
108726: LD_VAR 0 3
108730: PUSH
108731: LD_INT 11
108733: EQUAL
108734: IFFALSE 108744
// sRefresh := true ;
108736: LD_ADDR_EXP 156
108740: PUSH
108741: LD_INT 1
108743: ST_TO_ADDR
// if p3 = 12 then
108744: LD_VAR 0 3
108748: PUSH
108749: LD_INT 12
108751: EQUAL
108752: IFFALSE 108762
// sExp := true ;
108754: LD_ADDR_EXP 157
108758: PUSH
108759: LD_INT 1
108761: ST_TO_ADDR
// if p3 = 13 then
108762: LD_VAR 0 3
108766: PUSH
108767: LD_INT 13
108769: EQUAL
108770: IFFALSE 108780
// sDepot := true ;
108772: LD_ADDR_EXP 158
108776: PUSH
108777: LD_INT 1
108779: ST_TO_ADDR
// if p3 = 14 then
108780: LD_VAR 0 3
108784: PUSH
108785: LD_INT 14
108787: EQUAL
108788: IFFALSE 108798
// sFlag := true ;
108790: LD_ADDR_EXP 159
108794: PUSH
108795: LD_INT 1
108797: ST_TO_ADDR
// if p3 = 15 then
108798: LD_VAR 0 3
108802: PUSH
108803: LD_INT 15
108805: EQUAL
108806: IFFALSE 108816
// sKamikadze := true ;
108808: LD_ADDR_EXP 167
108812: PUSH
108813: LD_INT 1
108815: ST_TO_ADDR
// if p3 = 16 then
108816: LD_VAR 0 3
108820: PUSH
108821: LD_INT 16
108823: EQUAL
108824: IFFALSE 108834
// sTroll := true ;
108826: LD_ADDR_EXP 168
108830: PUSH
108831: LD_INT 1
108833: ST_TO_ADDR
// if p3 = 17 then
108834: LD_VAR 0 3
108838: PUSH
108839: LD_INT 17
108841: EQUAL
108842: IFFALSE 108852
// sSlow := true ;
108844: LD_ADDR_EXP 169
108848: PUSH
108849: LD_INT 1
108851: ST_TO_ADDR
// if p3 = 18 then
108852: LD_VAR 0 3
108856: PUSH
108857: LD_INT 18
108859: EQUAL
108860: IFFALSE 108870
// sLack := true ;
108862: LD_ADDR_EXP 170
108866: PUSH
108867: LD_INT 1
108869: ST_TO_ADDR
// if p3 = 19 then
108870: LD_VAR 0 3
108874: PUSH
108875: LD_INT 19
108877: EQUAL
108878: IFFALSE 108888
// sTank := true ;
108880: LD_ADDR_EXP 172
108884: PUSH
108885: LD_INT 1
108887: ST_TO_ADDR
// if p3 = 20 then
108888: LD_VAR 0 3
108892: PUSH
108893: LD_INT 20
108895: EQUAL
108896: IFFALSE 108906
// sRemote := true ;
108898: LD_ADDR_EXP 173
108902: PUSH
108903: LD_INT 1
108905: ST_TO_ADDR
// if p3 = 21 then
108906: LD_VAR 0 3
108910: PUSH
108911: LD_INT 21
108913: EQUAL
108914: IFFALSE 108924
// sPowell := true ;
108916: LD_ADDR_EXP 174
108920: PUSH
108921: LD_INT 1
108923: ST_TO_ADDR
// if p3 = 22 then
108924: LD_VAR 0 3
108928: PUSH
108929: LD_INT 22
108931: EQUAL
108932: IFFALSE 108942
// sTeleport := true ;
108934: LD_ADDR_EXP 177
108938: PUSH
108939: LD_INT 1
108941: ST_TO_ADDR
// if p3 = 23 then
108942: LD_VAR 0 3
108946: PUSH
108947: LD_INT 23
108949: EQUAL
108950: IFFALSE 108960
// sOilTower := true ;
108952: LD_ADDR_EXP 179
108956: PUSH
108957: LD_INT 1
108959: ST_TO_ADDR
// if p3 = 24 then
108960: LD_VAR 0 3
108964: PUSH
108965: LD_INT 24
108967: EQUAL
108968: IFFALSE 108978
// sShovel := true ;
108970: LD_ADDR_EXP 180
108974: PUSH
108975: LD_INT 1
108977: ST_TO_ADDR
// if p3 = 25 then
108978: LD_VAR 0 3
108982: PUSH
108983: LD_INT 25
108985: EQUAL
108986: IFFALSE 108996
// sSheik := true ;
108988: LD_ADDR_EXP 181
108992: PUSH
108993: LD_INT 1
108995: ST_TO_ADDR
// if p3 = 26 then
108996: LD_VAR 0 3
109000: PUSH
109001: LD_INT 26
109003: EQUAL
109004: IFFALSE 109014
// sEarthquake := true ;
109006: LD_ADDR_EXP 183
109010: PUSH
109011: LD_INT 1
109013: ST_TO_ADDR
// if p3 = 27 then
109014: LD_VAR 0 3
109018: PUSH
109019: LD_INT 27
109021: EQUAL
109022: IFFALSE 109032
// sAI := true ;
109024: LD_ADDR_EXP 184
109028: PUSH
109029: LD_INT 1
109031: ST_TO_ADDR
// if p3 = 28 then
109032: LD_VAR 0 3
109036: PUSH
109037: LD_INT 28
109039: EQUAL
109040: IFFALSE 109050
// sCargo := true ;
109042: LD_ADDR_EXP 187
109046: PUSH
109047: LD_INT 1
109049: ST_TO_ADDR
// if p3 = 29 then
109050: LD_VAR 0 3
109054: PUSH
109055: LD_INT 29
109057: EQUAL
109058: IFFALSE 109068
// sDLaser := true ;
109060: LD_ADDR_EXP 188
109064: PUSH
109065: LD_INT 1
109067: ST_TO_ADDR
// if p3 = 30 then
109068: LD_VAR 0 3
109072: PUSH
109073: LD_INT 30
109075: EQUAL
109076: IFFALSE 109086
// sExchange := true ;
109078: LD_ADDR_EXP 189
109082: PUSH
109083: LD_INT 1
109085: ST_TO_ADDR
// if p3 = 31 then
109086: LD_VAR 0 3
109090: PUSH
109091: LD_INT 31
109093: EQUAL
109094: IFFALSE 109104
// sFac := true ;
109096: LD_ADDR_EXP 190
109100: PUSH
109101: LD_INT 1
109103: ST_TO_ADDR
// if p3 = 32 then
109104: LD_VAR 0 3
109108: PUSH
109109: LD_INT 32
109111: EQUAL
109112: IFFALSE 109122
// sPower := true ;
109114: LD_ADDR_EXP 191
109118: PUSH
109119: LD_INT 1
109121: ST_TO_ADDR
// if p3 = 33 then
109122: LD_VAR 0 3
109126: PUSH
109127: LD_INT 33
109129: EQUAL
109130: IFFALSE 109140
// sRandom := true ;
109132: LD_ADDR_EXP 192
109136: PUSH
109137: LD_INT 1
109139: ST_TO_ADDR
// if p3 = 34 then
109140: LD_VAR 0 3
109144: PUSH
109145: LD_INT 34
109147: EQUAL
109148: IFFALSE 109158
// sShield := true ;
109150: LD_ADDR_EXP 193
109154: PUSH
109155: LD_INT 1
109157: ST_TO_ADDR
// if p3 = 35 then
109158: LD_VAR 0 3
109162: PUSH
109163: LD_INT 35
109165: EQUAL
109166: IFFALSE 109176
// sTime := true ;
109168: LD_ADDR_EXP 194
109172: PUSH
109173: LD_INT 1
109175: ST_TO_ADDR
// if p3 = 36 then
109176: LD_VAR 0 3
109180: PUSH
109181: LD_INT 36
109183: EQUAL
109184: IFFALSE 109194
// sTools := true ;
109186: LD_ADDR_EXP 195
109190: PUSH
109191: LD_INT 1
109193: ST_TO_ADDR
// if p3 = 101 then
109194: LD_VAR 0 3
109198: PUSH
109199: LD_INT 101
109201: EQUAL
109202: IFFALSE 109212
// sSold := true ;
109204: LD_ADDR_EXP 160
109208: PUSH
109209: LD_INT 1
109211: ST_TO_ADDR
// if p3 = 102 then
109212: LD_VAR 0 3
109216: PUSH
109217: LD_INT 102
109219: EQUAL
109220: IFFALSE 109230
// sDiff := true ;
109222: LD_ADDR_EXP 161
109226: PUSH
109227: LD_INT 1
109229: ST_TO_ADDR
// if p3 = 103 then
109230: LD_VAR 0 3
109234: PUSH
109235: LD_INT 103
109237: EQUAL
109238: IFFALSE 109248
// sFog := true ;
109240: LD_ADDR_EXP 164
109244: PUSH
109245: LD_INT 1
109247: ST_TO_ADDR
// if p3 = 104 then
109248: LD_VAR 0 3
109252: PUSH
109253: LD_INT 104
109255: EQUAL
109256: IFFALSE 109266
// sReset := true ;
109258: LD_ADDR_EXP 165
109262: PUSH
109263: LD_INT 1
109265: ST_TO_ADDR
// if p3 = 105 then
109266: LD_VAR 0 3
109270: PUSH
109271: LD_INT 105
109273: EQUAL
109274: IFFALSE 109284
// sSun := true ;
109276: LD_ADDR_EXP 166
109280: PUSH
109281: LD_INT 1
109283: ST_TO_ADDR
// if p3 = 106 then
109284: LD_VAR 0 3
109288: PUSH
109289: LD_INT 106
109291: EQUAL
109292: IFFALSE 109302
// sTiger := true ;
109294: LD_ADDR_EXP 162
109298: PUSH
109299: LD_INT 1
109301: ST_TO_ADDR
// if p3 = 107 then
109302: LD_VAR 0 3
109306: PUSH
109307: LD_INT 107
109309: EQUAL
109310: IFFALSE 109320
// sBomb := true ;
109312: LD_ADDR_EXP 163
109316: PUSH
109317: LD_INT 1
109319: ST_TO_ADDR
// if p3 = 108 then
109320: LD_VAR 0 3
109324: PUSH
109325: LD_INT 108
109327: EQUAL
109328: IFFALSE 109338
// sWound := true ;
109330: LD_ADDR_EXP 171
109334: PUSH
109335: LD_INT 1
109337: ST_TO_ADDR
// if p3 = 109 then
109338: LD_VAR 0 3
109342: PUSH
109343: LD_INT 109
109345: EQUAL
109346: IFFALSE 109356
// sBetray := true ;
109348: LD_ADDR_EXP 175
109352: PUSH
109353: LD_INT 1
109355: ST_TO_ADDR
// if p3 = 110 then
109356: LD_VAR 0 3
109360: PUSH
109361: LD_INT 110
109363: EQUAL
109364: IFFALSE 109374
// sContamin := true ;
109366: LD_ADDR_EXP 176
109370: PUSH
109371: LD_INT 1
109373: ST_TO_ADDR
// if p3 = 111 then
109374: LD_VAR 0 3
109378: PUSH
109379: LD_INT 111
109381: EQUAL
109382: IFFALSE 109392
// sOil := true ;
109384: LD_ADDR_EXP 178
109388: PUSH
109389: LD_INT 1
109391: ST_TO_ADDR
// if p3 = 112 then
109392: LD_VAR 0 3
109396: PUSH
109397: LD_INT 112
109399: EQUAL
109400: IFFALSE 109410
// sStu := true ;
109402: LD_ADDR_EXP 182
109406: PUSH
109407: LD_INT 1
109409: ST_TO_ADDR
// if p3 = 113 then
109410: LD_VAR 0 3
109414: PUSH
109415: LD_INT 113
109417: EQUAL
109418: IFFALSE 109428
// sBazooka := true ;
109420: LD_ADDR_EXP 185
109424: PUSH
109425: LD_INT 1
109427: ST_TO_ADDR
// if p3 = 114 then
109428: LD_VAR 0 3
109432: PUSH
109433: LD_INT 114
109435: EQUAL
109436: IFFALSE 109446
// sMortar := true ;
109438: LD_ADDR_EXP 186
109442: PUSH
109443: LD_INT 1
109445: ST_TO_ADDR
// if p3 = 115 then
109446: LD_VAR 0 3
109450: PUSH
109451: LD_INT 115
109453: EQUAL
109454: IFFALSE 109464
// sRanger := true ;
109456: LD_ADDR_EXP 196
109460: PUSH
109461: LD_INT 1
109463: ST_TO_ADDR
// if p3 = 116 then
109464: LD_VAR 0 3
109468: PUSH
109469: LD_INT 116
109471: EQUAL
109472: IFFALSE 109482
// sComputer := true ;
109474: LD_ADDR_EXP 197
109478: PUSH
109479: LD_INT 1
109481: ST_TO_ADDR
// if p3 = 117 then
109482: LD_VAR 0 3
109486: PUSH
109487: LD_INT 117
109489: EQUAL
109490: IFFALSE 109500
// s30 := true ;
109492: LD_ADDR_EXP 198
109496: PUSH
109497: LD_INT 1
109499: ST_TO_ADDR
// if p3 = 118 then
109500: LD_VAR 0 3
109504: PUSH
109505: LD_INT 118
109507: EQUAL
109508: IFFALSE 109518
// s60 := true ;
109510: LD_ADDR_EXP 199
109514: PUSH
109515: LD_INT 1
109517: ST_TO_ADDR
// end ; if p2 = 101 then
109518: LD_VAR 0 2
109522: PUSH
109523: LD_INT 101
109525: EQUAL
109526: IFFALSE 109654
// begin case p3 of 1 :
109528: LD_VAR 0 3
109532: PUSH
109533: LD_INT 1
109535: DOUBLE
109536: EQUAL
109537: IFTRUE 109541
109539: GO 109548
109541: POP
// hHackUnlimitedResources ; 2 :
109542: CALL 121752 0 0
109546: GO 109654
109548: LD_INT 2
109550: DOUBLE
109551: EQUAL
109552: IFTRUE 109556
109554: GO 109563
109556: POP
// hHackSetLevel10 ; 3 :
109557: CALL 121885 0 0
109561: GO 109654
109563: LD_INT 3
109565: DOUBLE
109566: EQUAL
109567: IFTRUE 109571
109569: GO 109578
109571: POP
// hHackSetLevel10YourUnits ; 4 :
109572: CALL 121970 0 0
109576: GO 109654
109578: LD_INT 4
109580: DOUBLE
109581: EQUAL
109582: IFTRUE 109586
109584: GO 109593
109586: POP
// hHackInvincible ; 5 :
109587: CALL 122418 0 0
109591: GO 109654
109593: LD_INT 5
109595: DOUBLE
109596: EQUAL
109597: IFTRUE 109601
109599: GO 109608
109601: POP
// hHackInvisible ; 6 :
109602: CALL 122529 0 0
109606: GO 109654
109608: LD_INT 6
109610: DOUBLE
109611: EQUAL
109612: IFTRUE 109616
109614: GO 109623
109616: POP
// hHackChangeYourSide ; 7 :
109617: CALL 122586 0 0
109621: GO 109654
109623: LD_INT 7
109625: DOUBLE
109626: EQUAL
109627: IFTRUE 109631
109629: GO 109638
109631: POP
// hHackChangeUnitSide ; 8 :
109632: CALL 122628 0 0
109636: GO 109654
109638: LD_INT 8
109640: DOUBLE
109641: EQUAL
109642: IFTRUE 109646
109644: GO 109653
109646: POP
// hHackFog ; end ;
109647: CALL 122729 0 0
109651: GO 109654
109653: POP
// end ; end ;
109654: LD_VAR 0 7
109658: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
109659: GO 109661
109661: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
109662: LD_STRING initStreamRollete();
109664: PPUSH
109665: CALL_OW 559
// InitStreamMode ;
109669: CALL 109681 0 0
// DefineStreamItems ( false ) ;
109673: LD_INT 0
109675: PPUSH
109676: CALL 110145 0 1
// end ;
109680: END
// function InitStreamMode ; begin
109681: LD_INT 0
109683: PPUSH
// streamModeActive := false ;
109684: LD_ADDR_EXP 143
109688: PUSH
109689: LD_INT 0
109691: ST_TO_ADDR
// normalCounter := 36 ;
109692: LD_ADDR_EXP 144
109696: PUSH
109697: LD_INT 36
109699: ST_TO_ADDR
// hardcoreCounter := 18 ;
109700: LD_ADDR_EXP 145
109704: PUSH
109705: LD_INT 18
109707: ST_TO_ADDR
// sRocket := false ;
109708: LD_ADDR_EXP 148
109712: PUSH
109713: LD_INT 0
109715: ST_TO_ADDR
// sSpeed := false ;
109716: LD_ADDR_EXP 147
109720: PUSH
109721: LD_INT 0
109723: ST_TO_ADDR
// sEngine := false ;
109724: LD_ADDR_EXP 149
109728: PUSH
109729: LD_INT 0
109731: ST_TO_ADDR
// sSpec := false ;
109732: LD_ADDR_EXP 146
109736: PUSH
109737: LD_INT 0
109739: ST_TO_ADDR
// sLevel := false ;
109740: LD_ADDR_EXP 150
109744: PUSH
109745: LD_INT 0
109747: ST_TO_ADDR
// sArmoury := false ;
109748: LD_ADDR_EXP 151
109752: PUSH
109753: LD_INT 0
109755: ST_TO_ADDR
// sRadar := false ;
109756: LD_ADDR_EXP 152
109760: PUSH
109761: LD_INT 0
109763: ST_TO_ADDR
// sBunker := false ;
109764: LD_ADDR_EXP 153
109768: PUSH
109769: LD_INT 0
109771: ST_TO_ADDR
// sHack := false ;
109772: LD_ADDR_EXP 154
109776: PUSH
109777: LD_INT 0
109779: ST_TO_ADDR
// sFire := false ;
109780: LD_ADDR_EXP 155
109784: PUSH
109785: LD_INT 0
109787: ST_TO_ADDR
// sRefresh := false ;
109788: LD_ADDR_EXP 156
109792: PUSH
109793: LD_INT 0
109795: ST_TO_ADDR
// sExp := false ;
109796: LD_ADDR_EXP 157
109800: PUSH
109801: LD_INT 0
109803: ST_TO_ADDR
// sDepot := false ;
109804: LD_ADDR_EXP 158
109808: PUSH
109809: LD_INT 0
109811: ST_TO_ADDR
// sFlag := false ;
109812: LD_ADDR_EXP 159
109816: PUSH
109817: LD_INT 0
109819: ST_TO_ADDR
// sKamikadze := false ;
109820: LD_ADDR_EXP 167
109824: PUSH
109825: LD_INT 0
109827: ST_TO_ADDR
// sTroll := false ;
109828: LD_ADDR_EXP 168
109832: PUSH
109833: LD_INT 0
109835: ST_TO_ADDR
// sSlow := false ;
109836: LD_ADDR_EXP 169
109840: PUSH
109841: LD_INT 0
109843: ST_TO_ADDR
// sLack := false ;
109844: LD_ADDR_EXP 170
109848: PUSH
109849: LD_INT 0
109851: ST_TO_ADDR
// sTank := false ;
109852: LD_ADDR_EXP 172
109856: PUSH
109857: LD_INT 0
109859: ST_TO_ADDR
// sRemote := false ;
109860: LD_ADDR_EXP 173
109864: PUSH
109865: LD_INT 0
109867: ST_TO_ADDR
// sPowell := false ;
109868: LD_ADDR_EXP 174
109872: PUSH
109873: LD_INT 0
109875: ST_TO_ADDR
// sTeleport := false ;
109876: LD_ADDR_EXP 177
109880: PUSH
109881: LD_INT 0
109883: ST_TO_ADDR
// sOilTower := false ;
109884: LD_ADDR_EXP 179
109888: PUSH
109889: LD_INT 0
109891: ST_TO_ADDR
// sShovel := false ;
109892: LD_ADDR_EXP 180
109896: PUSH
109897: LD_INT 0
109899: ST_TO_ADDR
// sSheik := false ;
109900: LD_ADDR_EXP 181
109904: PUSH
109905: LD_INT 0
109907: ST_TO_ADDR
// sEarthquake := false ;
109908: LD_ADDR_EXP 183
109912: PUSH
109913: LD_INT 0
109915: ST_TO_ADDR
// sAI := false ;
109916: LD_ADDR_EXP 184
109920: PUSH
109921: LD_INT 0
109923: ST_TO_ADDR
// sCargo := false ;
109924: LD_ADDR_EXP 187
109928: PUSH
109929: LD_INT 0
109931: ST_TO_ADDR
// sDLaser := false ;
109932: LD_ADDR_EXP 188
109936: PUSH
109937: LD_INT 0
109939: ST_TO_ADDR
// sExchange := false ;
109940: LD_ADDR_EXP 189
109944: PUSH
109945: LD_INT 0
109947: ST_TO_ADDR
// sFac := false ;
109948: LD_ADDR_EXP 190
109952: PUSH
109953: LD_INT 0
109955: ST_TO_ADDR
// sPower := false ;
109956: LD_ADDR_EXP 191
109960: PUSH
109961: LD_INT 0
109963: ST_TO_ADDR
// sRandom := false ;
109964: LD_ADDR_EXP 192
109968: PUSH
109969: LD_INT 0
109971: ST_TO_ADDR
// sShield := false ;
109972: LD_ADDR_EXP 193
109976: PUSH
109977: LD_INT 0
109979: ST_TO_ADDR
// sTime := false ;
109980: LD_ADDR_EXP 194
109984: PUSH
109985: LD_INT 0
109987: ST_TO_ADDR
// sTools := false ;
109988: LD_ADDR_EXP 195
109992: PUSH
109993: LD_INT 0
109995: ST_TO_ADDR
// sSold := false ;
109996: LD_ADDR_EXP 160
110000: PUSH
110001: LD_INT 0
110003: ST_TO_ADDR
// sDiff := false ;
110004: LD_ADDR_EXP 161
110008: PUSH
110009: LD_INT 0
110011: ST_TO_ADDR
// sFog := false ;
110012: LD_ADDR_EXP 164
110016: PUSH
110017: LD_INT 0
110019: ST_TO_ADDR
// sReset := false ;
110020: LD_ADDR_EXP 165
110024: PUSH
110025: LD_INT 0
110027: ST_TO_ADDR
// sSun := false ;
110028: LD_ADDR_EXP 166
110032: PUSH
110033: LD_INT 0
110035: ST_TO_ADDR
// sTiger := false ;
110036: LD_ADDR_EXP 162
110040: PUSH
110041: LD_INT 0
110043: ST_TO_ADDR
// sBomb := false ;
110044: LD_ADDR_EXP 163
110048: PUSH
110049: LD_INT 0
110051: ST_TO_ADDR
// sWound := false ;
110052: LD_ADDR_EXP 171
110056: PUSH
110057: LD_INT 0
110059: ST_TO_ADDR
// sBetray := false ;
110060: LD_ADDR_EXP 175
110064: PUSH
110065: LD_INT 0
110067: ST_TO_ADDR
// sContamin := false ;
110068: LD_ADDR_EXP 176
110072: PUSH
110073: LD_INT 0
110075: ST_TO_ADDR
// sOil := false ;
110076: LD_ADDR_EXP 178
110080: PUSH
110081: LD_INT 0
110083: ST_TO_ADDR
// sStu := false ;
110084: LD_ADDR_EXP 182
110088: PUSH
110089: LD_INT 0
110091: ST_TO_ADDR
// sBazooka := false ;
110092: LD_ADDR_EXP 185
110096: PUSH
110097: LD_INT 0
110099: ST_TO_ADDR
// sMortar := false ;
110100: LD_ADDR_EXP 186
110104: PUSH
110105: LD_INT 0
110107: ST_TO_ADDR
// sRanger := false ;
110108: LD_ADDR_EXP 196
110112: PUSH
110113: LD_INT 0
110115: ST_TO_ADDR
// sComputer := false ;
110116: LD_ADDR_EXP 197
110120: PUSH
110121: LD_INT 0
110123: ST_TO_ADDR
// s30 := false ;
110124: LD_ADDR_EXP 198
110128: PUSH
110129: LD_INT 0
110131: ST_TO_ADDR
// s60 := false ;
110132: LD_ADDR_EXP 199
110136: PUSH
110137: LD_INT 0
110139: ST_TO_ADDR
// end ;
110140: LD_VAR 0 1
110144: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
110145: LD_INT 0
110147: PPUSH
110148: PPUSH
110149: PPUSH
110150: PPUSH
110151: PPUSH
110152: PPUSH
110153: PPUSH
// result := [ ] ;
110154: LD_ADDR_VAR 0 2
110158: PUSH
110159: EMPTY
110160: ST_TO_ADDR
// if campaign_id = 1 then
110161: LD_OWVAR 69
110165: PUSH
110166: LD_INT 1
110168: EQUAL
110169: IFFALSE 113335
// begin case mission_number of 1 :
110171: LD_OWVAR 70
110175: PUSH
110176: LD_INT 1
110178: DOUBLE
110179: EQUAL
110180: IFTRUE 110184
110182: GO 110260
110184: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
110185: LD_ADDR_VAR 0 2
110189: PUSH
110190: LD_INT 2
110192: PUSH
110193: LD_INT 4
110195: PUSH
110196: LD_INT 11
110198: PUSH
110199: LD_INT 12
110201: PUSH
110202: LD_INT 15
110204: PUSH
110205: LD_INT 16
110207: PUSH
110208: LD_INT 22
110210: PUSH
110211: LD_INT 23
110213: PUSH
110214: LD_INT 26
110216: PUSH
110217: EMPTY
110218: LIST
110219: LIST
110220: LIST
110221: LIST
110222: LIST
110223: LIST
110224: LIST
110225: LIST
110226: LIST
110227: PUSH
110228: LD_INT 101
110230: PUSH
110231: LD_INT 102
110233: PUSH
110234: LD_INT 106
110236: PUSH
110237: LD_INT 116
110239: PUSH
110240: LD_INT 117
110242: PUSH
110243: LD_INT 118
110245: PUSH
110246: EMPTY
110247: LIST
110248: LIST
110249: LIST
110250: LIST
110251: LIST
110252: LIST
110253: PUSH
110254: EMPTY
110255: LIST
110256: LIST
110257: ST_TO_ADDR
110258: GO 113333
110260: LD_INT 2
110262: DOUBLE
110263: EQUAL
110264: IFTRUE 110268
110266: GO 110352
110268: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
110269: LD_ADDR_VAR 0 2
110273: PUSH
110274: LD_INT 2
110276: PUSH
110277: LD_INT 4
110279: PUSH
110280: LD_INT 11
110282: PUSH
110283: LD_INT 12
110285: PUSH
110286: LD_INT 15
110288: PUSH
110289: LD_INT 16
110291: PUSH
110292: LD_INT 22
110294: PUSH
110295: LD_INT 23
110297: PUSH
110298: LD_INT 26
110300: PUSH
110301: EMPTY
110302: LIST
110303: LIST
110304: LIST
110305: LIST
110306: LIST
110307: LIST
110308: LIST
110309: LIST
110310: LIST
110311: PUSH
110312: LD_INT 101
110314: PUSH
110315: LD_INT 102
110317: PUSH
110318: LD_INT 105
110320: PUSH
110321: LD_INT 106
110323: PUSH
110324: LD_INT 108
110326: PUSH
110327: LD_INT 116
110329: PUSH
110330: LD_INT 117
110332: PUSH
110333: LD_INT 118
110335: PUSH
110336: EMPTY
110337: LIST
110338: LIST
110339: LIST
110340: LIST
110341: LIST
110342: LIST
110343: LIST
110344: LIST
110345: PUSH
110346: EMPTY
110347: LIST
110348: LIST
110349: ST_TO_ADDR
110350: GO 113333
110352: LD_INT 3
110354: DOUBLE
110355: EQUAL
110356: IFTRUE 110360
110358: GO 110448
110360: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
110361: LD_ADDR_VAR 0 2
110365: PUSH
110366: LD_INT 2
110368: PUSH
110369: LD_INT 4
110371: PUSH
110372: LD_INT 5
110374: PUSH
110375: LD_INT 11
110377: PUSH
110378: LD_INT 12
110380: PUSH
110381: LD_INT 15
110383: PUSH
110384: LD_INT 16
110386: PUSH
110387: LD_INT 22
110389: PUSH
110390: LD_INT 26
110392: PUSH
110393: LD_INT 36
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: LIST
110400: LIST
110401: LIST
110402: LIST
110403: LIST
110404: LIST
110405: LIST
110406: LIST
110407: PUSH
110408: LD_INT 101
110410: PUSH
110411: LD_INT 102
110413: PUSH
110414: LD_INT 105
110416: PUSH
110417: LD_INT 106
110419: PUSH
110420: LD_INT 108
110422: PUSH
110423: LD_INT 116
110425: PUSH
110426: LD_INT 117
110428: PUSH
110429: LD_INT 118
110431: PUSH
110432: EMPTY
110433: LIST
110434: LIST
110435: LIST
110436: LIST
110437: LIST
110438: LIST
110439: LIST
110440: LIST
110441: PUSH
110442: EMPTY
110443: LIST
110444: LIST
110445: ST_TO_ADDR
110446: GO 113333
110448: LD_INT 4
110450: DOUBLE
110451: EQUAL
110452: IFTRUE 110456
110454: GO 110552
110456: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
110457: LD_ADDR_VAR 0 2
110461: PUSH
110462: LD_INT 2
110464: PUSH
110465: LD_INT 4
110467: PUSH
110468: LD_INT 5
110470: PUSH
110471: LD_INT 8
110473: PUSH
110474: LD_INT 11
110476: PUSH
110477: LD_INT 12
110479: PUSH
110480: LD_INT 15
110482: PUSH
110483: LD_INT 16
110485: PUSH
110486: LD_INT 22
110488: PUSH
110489: LD_INT 23
110491: PUSH
110492: LD_INT 26
110494: PUSH
110495: LD_INT 36
110497: PUSH
110498: EMPTY
110499: LIST
110500: LIST
110501: LIST
110502: LIST
110503: LIST
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: LIST
110509: LIST
110510: LIST
110511: PUSH
110512: LD_INT 101
110514: PUSH
110515: LD_INT 102
110517: PUSH
110518: LD_INT 105
110520: PUSH
110521: LD_INT 106
110523: PUSH
110524: LD_INT 108
110526: PUSH
110527: LD_INT 116
110529: PUSH
110530: LD_INT 117
110532: PUSH
110533: LD_INT 118
110535: PUSH
110536: EMPTY
110537: LIST
110538: LIST
110539: LIST
110540: LIST
110541: LIST
110542: LIST
110543: LIST
110544: LIST
110545: PUSH
110546: EMPTY
110547: LIST
110548: LIST
110549: ST_TO_ADDR
110550: GO 113333
110552: LD_INT 5
110554: DOUBLE
110555: EQUAL
110556: IFTRUE 110560
110558: GO 110672
110560: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
110561: LD_ADDR_VAR 0 2
110565: PUSH
110566: LD_INT 2
110568: PUSH
110569: LD_INT 4
110571: PUSH
110572: LD_INT 5
110574: PUSH
110575: LD_INT 6
110577: PUSH
110578: LD_INT 8
110580: PUSH
110581: LD_INT 11
110583: PUSH
110584: LD_INT 12
110586: PUSH
110587: LD_INT 15
110589: PUSH
110590: LD_INT 16
110592: PUSH
110593: LD_INT 22
110595: PUSH
110596: LD_INT 23
110598: PUSH
110599: LD_INT 25
110601: PUSH
110602: LD_INT 26
110604: PUSH
110605: LD_INT 36
110607: PUSH
110608: EMPTY
110609: LIST
110610: LIST
110611: LIST
110612: LIST
110613: LIST
110614: LIST
110615: LIST
110616: LIST
110617: LIST
110618: LIST
110619: LIST
110620: LIST
110621: LIST
110622: LIST
110623: PUSH
110624: LD_INT 101
110626: PUSH
110627: LD_INT 102
110629: PUSH
110630: LD_INT 105
110632: PUSH
110633: LD_INT 106
110635: PUSH
110636: LD_INT 108
110638: PUSH
110639: LD_INT 109
110641: PUSH
110642: LD_INT 112
110644: PUSH
110645: LD_INT 116
110647: PUSH
110648: LD_INT 117
110650: PUSH
110651: LD_INT 118
110653: PUSH
110654: EMPTY
110655: LIST
110656: LIST
110657: LIST
110658: LIST
110659: LIST
110660: LIST
110661: LIST
110662: LIST
110663: LIST
110664: LIST
110665: PUSH
110666: EMPTY
110667: LIST
110668: LIST
110669: ST_TO_ADDR
110670: GO 113333
110672: LD_INT 6
110674: DOUBLE
110675: EQUAL
110676: IFTRUE 110680
110678: GO 110812
110680: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
110681: LD_ADDR_VAR 0 2
110685: PUSH
110686: LD_INT 2
110688: PUSH
110689: LD_INT 4
110691: PUSH
110692: LD_INT 5
110694: PUSH
110695: LD_INT 6
110697: PUSH
110698: LD_INT 8
110700: PUSH
110701: LD_INT 11
110703: PUSH
110704: LD_INT 12
110706: PUSH
110707: LD_INT 15
110709: PUSH
110710: LD_INT 16
110712: PUSH
110713: LD_INT 20
110715: PUSH
110716: LD_INT 21
110718: PUSH
110719: LD_INT 22
110721: PUSH
110722: LD_INT 23
110724: PUSH
110725: LD_INT 25
110727: PUSH
110728: LD_INT 26
110730: PUSH
110731: LD_INT 30
110733: PUSH
110734: LD_INT 31
110736: PUSH
110737: LD_INT 32
110739: PUSH
110740: LD_INT 36
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: LIST
110749: LIST
110750: LIST
110751: LIST
110752: LIST
110753: LIST
110754: LIST
110755: LIST
110756: LIST
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: LIST
110762: LIST
110763: PUSH
110764: LD_INT 101
110766: PUSH
110767: LD_INT 102
110769: PUSH
110770: LD_INT 105
110772: PUSH
110773: LD_INT 106
110775: PUSH
110776: LD_INT 108
110778: PUSH
110779: LD_INT 109
110781: PUSH
110782: LD_INT 112
110784: PUSH
110785: LD_INT 116
110787: PUSH
110788: LD_INT 117
110790: PUSH
110791: LD_INT 118
110793: PUSH
110794: EMPTY
110795: LIST
110796: LIST
110797: LIST
110798: LIST
110799: LIST
110800: LIST
110801: LIST
110802: LIST
110803: LIST
110804: LIST
110805: PUSH
110806: EMPTY
110807: LIST
110808: LIST
110809: ST_TO_ADDR
110810: GO 113333
110812: LD_INT 7
110814: DOUBLE
110815: EQUAL
110816: IFTRUE 110820
110818: GO 110932
110820: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
110821: LD_ADDR_VAR 0 2
110825: PUSH
110826: LD_INT 2
110828: PUSH
110829: LD_INT 4
110831: PUSH
110832: LD_INT 5
110834: PUSH
110835: LD_INT 7
110837: PUSH
110838: LD_INT 11
110840: PUSH
110841: LD_INT 12
110843: PUSH
110844: LD_INT 15
110846: PUSH
110847: LD_INT 16
110849: PUSH
110850: LD_INT 20
110852: PUSH
110853: LD_INT 21
110855: PUSH
110856: LD_INT 22
110858: PUSH
110859: LD_INT 23
110861: PUSH
110862: LD_INT 25
110864: PUSH
110865: LD_INT 26
110867: PUSH
110868: EMPTY
110869: LIST
110870: LIST
110871: LIST
110872: LIST
110873: LIST
110874: LIST
110875: LIST
110876: LIST
110877: LIST
110878: LIST
110879: LIST
110880: LIST
110881: LIST
110882: LIST
110883: PUSH
110884: LD_INT 101
110886: PUSH
110887: LD_INT 102
110889: PUSH
110890: LD_INT 103
110892: PUSH
110893: LD_INT 105
110895: PUSH
110896: LD_INT 106
110898: PUSH
110899: LD_INT 108
110901: PUSH
110902: LD_INT 112
110904: PUSH
110905: LD_INT 116
110907: PUSH
110908: LD_INT 117
110910: PUSH
110911: LD_INT 118
110913: PUSH
110914: EMPTY
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: PUSH
110926: EMPTY
110927: LIST
110928: LIST
110929: ST_TO_ADDR
110930: GO 113333
110932: LD_INT 8
110934: DOUBLE
110935: EQUAL
110936: IFTRUE 110940
110938: GO 111080
110940: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
110941: LD_ADDR_VAR 0 2
110945: PUSH
110946: LD_INT 2
110948: PUSH
110949: LD_INT 4
110951: PUSH
110952: LD_INT 5
110954: PUSH
110955: LD_INT 6
110957: PUSH
110958: LD_INT 7
110960: PUSH
110961: LD_INT 8
110963: PUSH
110964: LD_INT 11
110966: PUSH
110967: LD_INT 12
110969: PUSH
110970: LD_INT 15
110972: PUSH
110973: LD_INT 16
110975: PUSH
110976: LD_INT 20
110978: PUSH
110979: LD_INT 21
110981: PUSH
110982: LD_INT 22
110984: PUSH
110985: LD_INT 23
110987: PUSH
110988: LD_INT 25
110990: PUSH
110991: LD_INT 26
110993: PUSH
110994: LD_INT 30
110996: PUSH
110997: LD_INT 31
110999: PUSH
111000: LD_INT 32
111002: PUSH
111003: LD_INT 36
111005: PUSH
111006: EMPTY
111007: LIST
111008: LIST
111009: LIST
111010: LIST
111011: LIST
111012: LIST
111013: LIST
111014: LIST
111015: LIST
111016: LIST
111017: LIST
111018: LIST
111019: LIST
111020: LIST
111021: LIST
111022: LIST
111023: LIST
111024: LIST
111025: LIST
111026: LIST
111027: PUSH
111028: LD_INT 101
111030: PUSH
111031: LD_INT 102
111033: PUSH
111034: LD_INT 103
111036: PUSH
111037: LD_INT 105
111039: PUSH
111040: LD_INT 106
111042: PUSH
111043: LD_INT 108
111045: PUSH
111046: LD_INT 109
111048: PUSH
111049: LD_INT 112
111051: PUSH
111052: LD_INT 116
111054: PUSH
111055: LD_INT 117
111057: PUSH
111058: LD_INT 118
111060: PUSH
111061: EMPTY
111062: LIST
111063: LIST
111064: LIST
111065: LIST
111066: LIST
111067: LIST
111068: LIST
111069: LIST
111070: LIST
111071: LIST
111072: LIST
111073: PUSH
111074: EMPTY
111075: LIST
111076: LIST
111077: ST_TO_ADDR
111078: GO 113333
111080: LD_INT 9
111082: DOUBLE
111083: EQUAL
111084: IFTRUE 111088
111086: GO 111236
111088: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
111089: LD_ADDR_VAR 0 2
111093: PUSH
111094: LD_INT 2
111096: PUSH
111097: LD_INT 4
111099: PUSH
111100: LD_INT 5
111102: PUSH
111103: LD_INT 6
111105: PUSH
111106: LD_INT 7
111108: PUSH
111109: LD_INT 8
111111: PUSH
111112: LD_INT 11
111114: PUSH
111115: LD_INT 12
111117: PUSH
111118: LD_INT 15
111120: PUSH
111121: LD_INT 16
111123: PUSH
111124: LD_INT 20
111126: PUSH
111127: LD_INT 21
111129: PUSH
111130: LD_INT 22
111132: PUSH
111133: LD_INT 23
111135: PUSH
111136: LD_INT 25
111138: PUSH
111139: LD_INT 26
111141: PUSH
111142: LD_INT 28
111144: PUSH
111145: LD_INT 30
111147: PUSH
111148: LD_INT 31
111150: PUSH
111151: LD_INT 32
111153: PUSH
111154: LD_INT 36
111156: PUSH
111157: EMPTY
111158: LIST
111159: LIST
111160: LIST
111161: LIST
111162: LIST
111163: LIST
111164: LIST
111165: LIST
111166: LIST
111167: LIST
111168: LIST
111169: LIST
111170: LIST
111171: LIST
111172: LIST
111173: LIST
111174: LIST
111175: LIST
111176: LIST
111177: LIST
111178: LIST
111179: PUSH
111180: LD_INT 101
111182: PUSH
111183: LD_INT 102
111185: PUSH
111186: LD_INT 103
111188: PUSH
111189: LD_INT 105
111191: PUSH
111192: LD_INT 106
111194: PUSH
111195: LD_INT 108
111197: PUSH
111198: LD_INT 109
111200: PUSH
111201: LD_INT 112
111203: PUSH
111204: LD_INT 114
111206: PUSH
111207: LD_INT 116
111209: PUSH
111210: LD_INT 117
111212: PUSH
111213: LD_INT 118
111215: PUSH
111216: EMPTY
111217: LIST
111218: LIST
111219: LIST
111220: LIST
111221: LIST
111222: LIST
111223: LIST
111224: LIST
111225: LIST
111226: LIST
111227: LIST
111228: LIST
111229: PUSH
111230: EMPTY
111231: LIST
111232: LIST
111233: ST_TO_ADDR
111234: GO 113333
111236: LD_INT 10
111238: DOUBLE
111239: EQUAL
111240: IFTRUE 111244
111242: GO 111440
111244: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
111245: LD_ADDR_VAR 0 2
111249: PUSH
111250: LD_INT 2
111252: PUSH
111253: LD_INT 4
111255: PUSH
111256: LD_INT 5
111258: PUSH
111259: LD_INT 6
111261: PUSH
111262: LD_INT 7
111264: PUSH
111265: LD_INT 8
111267: PUSH
111268: LD_INT 9
111270: PUSH
111271: LD_INT 10
111273: PUSH
111274: LD_INT 11
111276: PUSH
111277: LD_INT 12
111279: PUSH
111280: LD_INT 13
111282: PUSH
111283: LD_INT 14
111285: PUSH
111286: LD_INT 15
111288: PUSH
111289: LD_INT 16
111291: PUSH
111292: LD_INT 17
111294: PUSH
111295: LD_INT 18
111297: PUSH
111298: LD_INT 19
111300: PUSH
111301: LD_INT 20
111303: PUSH
111304: LD_INT 21
111306: PUSH
111307: LD_INT 22
111309: PUSH
111310: LD_INT 23
111312: PUSH
111313: LD_INT 24
111315: PUSH
111316: LD_INT 25
111318: PUSH
111319: LD_INT 26
111321: PUSH
111322: LD_INT 28
111324: PUSH
111325: LD_INT 30
111327: PUSH
111328: LD_INT 31
111330: PUSH
111331: LD_INT 32
111333: PUSH
111334: LD_INT 36
111336: PUSH
111337: EMPTY
111338: LIST
111339: LIST
111340: LIST
111341: LIST
111342: LIST
111343: LIST
111344: LIST
111345: LIST
111346: LIST
111347: LIST
111348: LIST
111349: LIST
111350: LIST
111351: LIST
111352: LIST
111353: LIST
111354: LIST
111355: LIST
111356: LIST
111357: LIST
111358: LIST
111359: LIST
111360: LIST
111361: LIST
111362: LIST
111363: LIST
111364: LIST
111365: LIST
111366: LIST
111367: PUSH
111368: LD_INT 101
111370: PUSH
111371: LD_INT 102
111373: PUSH
111374: LD_INT 103
111376: PUSH
111377: LD_INT 104
111379: PUSH
111380: LD_INT 105
111382: PUSH
111383: LD_INT 106
111385: PUSH
111386: LD_INT 107
111388: PUSH
111389: LD_INT 108
111391: PUSH
111392: LD_INT 109
111394: PUSH
111395: LD_INT 110
111397: PUSH
111398: LD_INT 111
111400: PUSH
111401: LD_INT 112
111403: PUSH
111404: LD_INT 114
111406: PUSH
111407: LD_INT 116
111409: PUSH
111410: LD_INT 117
111412: PUSH
111413: LD_INT 118
111415: PUSH
111416: EMPTY
111417: LIST
111418: LIST
111419: LIST
111420: LIST
111421: LIST
111422: LIST
111423: LIST
111424: LIST
111425: LIST
111426: LIST
111427: LIST
111428: LIST
111429: LIST
111430: LIST
111431: LIST
111432: LIST
111433: PUSH
111434: EMPTY
111435: LIST
111436: LIST
111437: ST_TO_ADDR
111438: GO 113333
111440: LD_INT 11
111442: DOUBLE
111443: EQUAL
111444: IFTRUE 111448
111446: GO 111652
111448: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
111449: LD_ADDR_VAR 0 2
111453: PUSH
111454: LD_INT 2
111456: PUSH
111457: LD_INT 3
111459: PUSH
111460: LD_INT 4
111462: PUSH
111463: LD_INT 5
111465: PUSH
111466: LD_INT 6
111468: PUSH
111469: LD_INT 7
111471: PUSH
111472: LD_INT 8
111474: PUSH
111475: LD_INT 9
111477: PUSH
111478: LD_INT 10
111480: PUSH
111481: LD_INT 11
111483: PUSH
111484: LD_INT 12
111486: PUSH
111487: LD_INT 13
111489: PUSH
111490: LD_INT 14
111492: PUSH
111493: LD_INT 15
111495: PUSH
111496: LD_INT 16
111498: PUSH
111499: LD_INT 17
111501: PUSH
111502: LD_INT 18
111504: PUSH
111505: LD_INT 19
111507: PUSH
111508: LD_INT 20
111510: PUSH
111511: LD_INT 21
111513: PUSH
111514: LD_INT 22
111516: PUSH
111517: LD_INT 23
111519: PUSH
111520: LD_INT 24
111522: PUSH
111523: LD_INT 25
111525: PUSH
111526: LD_INT 26
111528: PUSH
111529: LD_INT 28
111531: PUSH
111532: LD_INT 30
111534: PUSH
111535: LD_INT 31
111537: PUSH
111538: LD_INT 32
111540: PUSH
111541: LD_INT 34
111543: PUSH
111544: LD_INT 36
111546: PUSH
111547: EMPTY
111548: LIST
111549: LIST
111550: LIST
111551: LIST
111552: LIST
111553: LIST
111554: LIST
111555: LIST
111556: LIST
111557: LIST
111558: LIST
111559: LIST
111560: LIST
111561: LIST
111562: LIST
111563: LIST
111564: LIST
111565: LIST
111566: LIST
111567: LIST
111568: LIST
111569: LIST
111570: LIST
111571: LIST
111572: LIST
111573: LIST
111574: LIST
111575: LIST
111576: LIST
111577: LIST
111578: LIST
111579: PUSH
111580: LD_INT 101
111582: PUSH
111583: LD_INT 102
111585: PUSH
111586: LD_INT 103
111588: PUSH
111589: LD_INT 104
111591: PUSH
111592: LD_INT 105
111594: PUSH
111595: LD_INT 106
111597: PUSH
111598: LD_INT 107
111600: PUSH
111601: LD_INT 108
111603: PUSH
111604: LD_INT 109
111606: PUSH
111607: LD_INT 110
111609: PUSH
111610: LD_INT 111
111612: PUSH
111613: LD_INT 112
111615: PUSH
111616: LD_INT 114
111618: PUSH
111619: LD_INT 116
111621: PUSH
111622: LD_INT 117
111624: PUSH
111625: LD_INT 118
111627: PUSH
111628: EMPTY
111629: LIST
111630: LIST
111631: LIST
111632: LIST
111633: LIST
111634: LIST
111635: LIST
111636: LIST
111637: LIST
111638: LIST
111639: LIST
111640: LIST
111641: LIST
111642: LIST
111643: LIST
111644: LIST
111645: PUSH
111646: EMPTY
111647: LIST
111648: LIST
111649: ST_TO_ADDR
111650: GO 113333
111652: LD_INT 12
111654: DOUBLE
111655: EQUAL
111656: IFTRUE 111660
111658: GO 111880
111660: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
111661: LD_ADDR_VAR 0 2
111665: PUSH
111666: LD_INT 1
111668: PUSH
111669: LD_INT 2
111671: PUSH
111672: LD_INT 3
111674: PUSH
111675: LD_INT 4
111677: PUSH
111678: LD_INT 5
111680: PUSH
111681: LD_INT 6
111683: PUSH
111684: LD_INT 7
111686: PUSH
111687: LD_INT 8
111689: PUSH
111690: LD_INT 9
111692: PUSH
111693: LD_INT 10
111695: PUSH
111696: LD_INT 11
111698: PUSH
111699: LD_INT 12
111701: PUSH
111702: LD_INT 13
111704: PUSH
111705: LD_INT 14
111707: PUSH
111708: LD_INT 15
111710: PUSH
111711: LD_INT 16
111713: PUSH
111714: LD_INT 17
111716: PUSH
111717: LD_INT 18
111719: PUSH
111720: LD_INT 19
111722: PUSH
111723: LD_INT 20
111725: PUSH
111726: LD_INT 21
111728: PUSH
111729: LD_INT 22
111731: PUSH
111732: LD_INT 23
111734: PUSH
111735: LD_INT 24
111737: PUSH
111738: LD_INT 25
111740: PUSH
111741: LD_INT 26
111743: PUSH
111744: LD_INT 27
111746: PUSH
111747: LD_INT 28
111749: PUSH
111750: LD_INT 30
111752: PUSH
111753: LD_INT 31
111755: PUSH
111756: LD_INT 32
111758: PUSH
111759: LD_INT 33
111761: PUSH
111762: LD_INT 34
111764: PUSH
111765: LD_INT 36
111767: PUSH
111768: EMPTY
111769: LIST
111770: LIST
111771: LIST
111772: LIST
111773: LIST
111774: LIST
111775: LIST
111776: LIST
111777: LIST
111778: LIST
111779: LIST
111780: LIST
111781: LIST
111782: LIST
111783: LIST
111784: LIST
111785: LIST
111786: LIST
111787: LIST
111788: LIST
111789: LIST
111790: LIST
111791: LIST
111792: LIST
111793: LIST
111794: LIST
111795: LIST
111796: LIST
111797: LIST
111798: LIST
111799: LIST
111800: LIST
111801: LIST
111802: LIST
111803: PUSH
111804: LD_INT 101
111806: PUSH
111807: LD_INT 102
111809: PUSH
111810: LD_INT 103
111812: PUSH
111813: LD_INT 104
111815: PUSH
111816: LD_INT 105
111818: PUSH
111819: LD_INT 106
111821: PUSH
111822: LD_INT 107
111824: PUSH
111825: LD_INT 108
111827: PUSH
111828: LD_INT 109
111830: PUSH
111831: LD_INT 110
111833: PUSH
111834: LD_INT 111
111836: PUSH
111837: LD_INT 112
111839: PUSH
111840: LD_INT 113
111842: PUSH
111843: LD_INT 114
111845: PUSH
111846: LD_INT 116
111848: PUSH
111849: LD_INT 117
111851: PUSH
111852: LD_INT 118
111854: PUSH
111855: EMPTY
111856: LIST
111857: LIST
111858: LIST
111859: LIST
111860: LIST
111861: LIST
111862: LIST
111863: LIST
111864: LIST
111865: LIST
111866: LIST
111867: LIST
111868: LIST
111869: LIST
111870: LIST
111871: LIST
111872: LIST
111873: PUSH
111874: EMPTY
111875: LIST
111876: LIST
111877: ST_TO_ADDR
111878: GO 113333
111880: LD_INT 13
111882: DOUBLE
111883: EQUAL
111884: IFTRUE 111888
111886: GO 112096
111888: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
111889: LD_ADDR_VAR 0 2
111893: PUSH
111894: LD_INT 1
111896: PUSH
111897: LD_INT 2
111899: PUSH
111900: LD_INT 3
111902: PUSH
111903: LD_INT 4
111905: PUSH
111906: LD_INT 5
111908: PUSH
111909: LD_INT 8
111911: PUSH
111912: LD_INT 9
111914: PUSH
111915: LD_INT 10
111917: PUSH
111918: LD_INT 11
111920: PUSH
111921: LD_INT 12
111923: PUSH
111924: LD_INT 14
111926: PUSH
111927: LD_INT 15
111929: PUSH
111930: LD_INT 16
111932: PUSH
111933: LD_INT 17
111935: PUSH
111936: LD_INT 18
111938: PUSH
111939: LD_INT 19
111941: PUSH
111942: LD_INT 20
111944: PUSH
111945: LD_INT 21
111947: PUSH
111948: LD_INT 22
111950: PUSH
111951: LD_INT 23
111953: PUSH
111954: LD_INT 24
111956: PUSH
111957: LD_INT 25
111959: PUSH
111960: LD_INT 26
111962: PUSH
111963: LD_INT 27
111965: PUSH
111966: LD_INT 28
111968: PUSH
111969: LD_INT 30
111971: PUSH
111972: LD_INT 31
111974: PUSH
111975: LD_INT 32
111977: PUSH
111978: LD_INT 33
111980: PUSH
111981: LD_INT 34
111983: PUSH
111984: LD_INT 36
111986: PUSH
111987: EMPTY
111988: LIST
111989: LIST
111990: LIST
111991: LIST
111992: LIST
111993: LIST
111994: LIST
111995: LIST
111996: LIST
111997: LIST
111998: LIST
111999: LIST
112000: LIST
112001: LIST
112002: LIST
112003: LIST
112004: LIST
112005: LIST
112006: LIST
112007: LIST
112008: LIST
112009: LIST
112010: LIST
112011: LIST
112012: LIST
112013: LIST
112014: LIST
112015: LIST
112016: LIST
112017: LIST
112018: LIST
112019: PUSH
112020: LD_INT 101
112022: PUSH
112023: LD_INT 102
112025: PUSH
112026: LD_INT 103
112028: PUSH
112029: LD_INT 104
112031: PUSH
112032: LD_INT 105
112034: PUSH
112035: LD_INT 106
112037: PUSH
112038: LD_INT 107
112040: PUSH
112041: LD_INT 108
112043: PUSH
112044: LD_INT 109
112046: PUSH
112047: LD_INT 110
112049: PUSH
112050: LD_INT 111
112052: PUSH
112053: LD_INT 112
112055: PUSH
112056: LD_INT 113
112058: PUSH
112059: LD_INT 114
112061: PUSH
112062: LD_INT 116
112064: PUSH
112065: LD_INT 117
112067: PUSH
112068: LD_INT 118
112070: PUSH
112071: EMPTY
112072: LIST
112073: LIST
112074: LIST
112075: LIST
112076: LIST
112077: LIST
112078: LIST
112079: LIST
112080: LIST
112081: LIST
112082: LIST
112083: LIST
112084: LIST
112085: LIST
112086: LIST
112087: LIST
112088: LIST
112089: PUSH
112090: EMPTY
112091: LIST
112092: LIST
112093: ST_TO_ADDR
112094: GO 113333
112096: LD_INT 14
112098: DOUBLE
112099: EQUAL
112100: IFTRUE 112104
112102: GO 112328
112104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
112105: LD_ADDR_VAR 0 2
112109: PUSH
112110: LD_INT 1
112112: PUSH
112113: LD_INT 2
112115: PUSH
112116: LD_INT 3
112118: PUSH
112119: LD_INT 4
112121: PUSH
112122: LD_INT 5
112124: PUSH
112125: LD_INT 6
112127: PUSH
112128: LD_INT 7
112130: PUSH
112131: LD_INT 8
112133: PUSH
112134: LD_INT 9
112136: PUSH
112137: LD_INT 10
112139: PUSH
112140: LD_INT 11
112142: PUSH
112143: LD_INT 12
112145: PUSH
112146: LD_INT 13
112148: PUSH
112149: LD_INT 14
112151: PUSH
112152: LD_INT 15
112154: PUSH
112155: LD_INT 16
112157: PUSH
112158: LD_INT 17
112160: PUSH
112161: LD_INT 18
112163: PUSH
112164: LD_INT 19
112166: PUSH
112167: LD_INT 20
112169: PUSH
112170: LD_INT 21
112172: PUSH
112173: LD_INT 22
112175: PUSH
112176: LD_INT 23
112178: PUSH
112179: LD_INT 24
112181: PUSH
112182: LD_INT 25
112184: PUSH
112185: LD_INT 26
112187: PUSH
112188: LD_INT 27
112190: PUSH
112191: LD_INT 28
112193: PUSH
112194: LD_INT 29
112196: PUSH
112197: LD_INT 30
112199: PUSH
112200: LD_INT 31
112202: PUSH
112203: LD_INT 32
112205: PUSH
112206: LD_INT 33
112208: PUSH
112209: LD_INT 34
112211: PUSH
112212: LD_INT 36
112214: PUSH
112215: EMPTY
112216: LIST
112217: LIST
112218: LIST
112219: LIST
112220: LIST
112221: LIST
112222: LIST
112223: LIST
112224: LIST
112225: LIST
112226: LIST
112227: LIST
112228: LIST
112229: LIST
112230: LIST
112231: LIST
112232: LIST
112233: LIST
112234: LIST
112235: LIST
112236: LIST
112237: LIST
112238: LIST
112239: LIST
112240: LIST
112241: LIST
112242: LIST
112243: LIST
112244: LIST
112245: LIST
112246: LIST
112247: LIST
112248: LIST
112249: LIST
112250: LIST
112251: PUSH
112252: LD_INT 101
112254: PUSH
112255: LD_INT 102
112257: PUSH
112258: LD_INT 103
112260: PUSH
112261: LD_INT 104
112263: PUSH
112264: LD_INT 105
112266: PUSH
112267: LD_INT 106
112269: PUSH
112270: LD_INT 107
112272: PUSH
112273: LD_INT 108
112275: PUSH
112276: LD_INT 109
112278: PUSH
112279: LD_INT 110
112281: PUSH
112282: LD_INT 111
112284: PUSH
112285: LD_INT 112
112287: PUSH
112288: LD_INT 113
112290: PUSH
112291: LD_INT 114
112293: PUSH
112294: LD_INT 116
112296: PUSH
112297: LD_INT 117
112299: PUSH
112300: LD_INT 118
112302: PUSH
112303: EMPTY
112304: LIST
112305: LIST
112306: LIST
112307: LIST
112308: LIST
112309: LIST
112310: LIST
112311: LIST
112312: LIST
112313: LIST
112314: LIST
112315: LIST
112316: LIST
112317: LIST
112318: LIST
112319: LIST
112320: LIST
112321: PUSH
112322: EMPTY
112323: LIST
112324: LIST
112325: ST_TO_ADDR
112326: GO 113333
112328: LD_INT 15
112330: DOUBLE
112331: EQUAL
112332: IFTRUE 112336
112334: GO 112560
112336: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
112337: LD_ADDR_VAR 0 2
112341: PUSH
112342: LD_INT 1
112344: PUSH
112345: LD_INT 2
112347: PUSH
112348: LD_INT 3
112350: PUSH
112351: LD_INT 4
112353: PUSH
112354: LD_INT 5
112356: PUSH
112357: LD_INT 6
112359: PUSH
112360: LD_INT 7
112362: PUSH
112363: LD_INT 8
112365: PUSH
112366: LD_INT 9
112368: PUSH
112369: LD_INT 10
112371: PUSH
112372: LD_INT 11
112374: PUSH
112375: LD_INT 12
112377: PUSH
112378: LD_INT 13
112380: PUSH
112381: LD_INT 14
112383: PUSH
112384: LD_INT 15
112386: PUSH
112387: LD_INT 16
112389: PUSH
112390: LD_INT 17
112392: PUSH
112393: LD_INT 18
112395: PUSH
112396: LD_INT 19
112398: PUSH
112399: LD_INT 20
112401: PUSH
112402: LD_INT 21
112404: PUSH
112405: LD_INT 22
112407: PUSH
112408: LD_INT 23
112410: PUSH
112411: LD_INT 24
112413: PUSH
112414: LD_INT 25
112416: PUSH
112417: LD_INT 26
112419: PUSH
112420: LD_INT 27
112422: PUSH
112423: LD_INT 28
112425: PUSH
112426: LD_INT 29
112428: PUSH
112429: LD_INT 30
112431: PUSH
112432: LD_INT 31
112434: PUSH
112435: LD_INT 32
112437: PUSH
112438: LD_INT 33
112440: PUSH
112441: LD_INT 34
112443: PUSH
112444: LD_INT 36
112446: PUSH
112447: EMPTY
112448: LIST
112449: LIST
112450: LIST
112451: LIST
112452: LIST
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: LIST
112458: LIST
112459: LIST
112460: LIST
112461: LIST
112462: LIST
112463: LIST
112464: LIST
112465: LIST
112466: LIST
112467: LIST
112468: LIST
112469: LIST
112470: LIST
112471: LIST
112472: LIST
112473: LIST
112474: LIST
112475: LIST
112476: LIST
112477: LIST
112478: LIST
112479: LIST
112480: LIST
112481: LIST
112482: LIST
112483: PUSH
112484: LD_INT 101
112486: PUSH
112487: LD_INT 102
112489: PUSH
112490: LD_INT 103
112492: PUSH
112493: LD_INT 104
112495: PUSH
112496: LD_INT 105
112498: PUSH
112499: LD_INT 106
112501: PUSH
112502: LD_INT 107
112504: PUSH
112505: LD_INT 108
112507: PUSH
112508: LD_INT 109
112510: PUSH
112511: LD_INT 110
112513: PUSH
112514: LD_INT 111
112516: PUSH
112517: LD_INT 112
112519: PUSH
112520: LD_INT 113
112522: PUSH
112523: LD_INT 114
112525: PUSH
112526: LD_INT 116
112528: PUSH
112529: LD_INT 117
112531: PUSH
112532: LD_INT 118
112534: PUSH
112535: EMPTY
112536: LIST
112537: LIST
112538: LIST
112539: LIST
112540: LIST
112541: LIST
112542: LIST
112543: LIST
112544: LIST
112545: LIST
112546: LIST
112547: LIST
112548: LIST
112549: LIST
112550: LIST
112551: LIST
112552: LIST
112553: PUSH
112554: EMPTY
112555: LIST
112556: LIST
112557: ST_TO_ADDR
112558: GO 113333
112560: LD_INT 16
112562: DOUBLE
112563: EQUAL
112564: IFTRUE 112568
112566: GO 112704
112568: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
112569: LD_ADDR_VAR 0 2
112573: PUSH
112574: LD_INT 2
112576: PUSH
112577: LD_INT 4
112579: PUSH
112580: LD_INT 5
112582: PUSH
112583: LD_INT 7
112585: PUSH
112586: LD_INT 11
112588: PUSH
112589: LD_INT 12
112591: PUSH
112592: LD_INT 15
112594: PUSH
112595: LD_INT 16
112597: PUSH
112598: LD_INT 20
112600: PUSH
112601: LD_INT 21
112603: PUSH
112604: LD_INT 22
112606: PUSH
112607: LD_INT 23
112609: PUSH
112610: LD_INT 25
112612: PUSH
112613: LD_INT 26
112615: PUSH
112616: LD_INT 30
112618: PUSH
112619: LD_INT 31
112621: PUSH
112622: LD_INT 32
112624: PUSH
112625: LD_INT 33
112627: PUSH
112628: LD_INT 34
112630: PUSH
112631: EMPTY
112632: LIST
112633: LIST
112634: LIST
112635: LIST
112636: LIST
112637: LIST
112638: LIST
112639: LIST
112640: LIST
112641: LIST
112642: LIST
112643: LIST
112644: LIST
112645: LIST
112646: LIST
112647: LIST
112648: LIST
112649: LIST
112650: LIST
112651: PUSH
112652: LD_INT 101
112654: PUSH
112655: LD_INT 102
112657: PUSH
112658: LD_INT 103
112660: PUSH
112661: LD_INT 106
112663: PUSH
112664: LD_INT 108
112666: PUSH
112667: LD_INT 112
112669: PUSH
112670: LD_INT 113
112672: PUSH
112673: LD_INT 114
112675: PUSH
112676: LD_INT 116
112678: PUSH
112679: LD_INT 117
112681: PUSH
112682: LD_INT 118
112684: PUSH
112685: EMPTY
112686: LIST
112687: LIST
112688: LIST
112689: LIST
112690: LIST
112691: LIST
112692: LIST
112693: LIST
112694: LIST
112695: LIST
112696: LIST
112697: PUSH
112698: EMPTY
112699: LIST
112700: LIST
112701: ST_TO_ADDR
112702: GO 113333
112704: LD_INT 17
112706: DOUBLE
112707: EQUAL
112708: IFTRUE 112712
112710: GO 112936
112712: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
112713: LD_ADDR_VAR 0 2
112717: PUSH
112718: LD_INT 1
112720: PUSH
112721: LD_INT 2
112723: PUSH
112724: LD_INT 3
112726: PUSH
112727: LD_INT 4
112729: PUSH
112730: LD_INT 5
112732: PUSH
112733: LD_INT 6
112735: PUSH
112736: LD_INT 7
112738: PUSH
112739: LD_INT 8
112741: PUSH
112742: LD_INT 9
112744: PUSH
112745: LD_INT 10
112747: PUSH
112748: LD_INT 11
112750: PUSH
112751: LD_INT 12
112753: PUSH
112754: LD_INT 13
112756: PUSH
112757: LD_INT 14
112759: PUSH
112760: LD_INT 15
112762: PUSH
112763: LD_INT 16
112765: PUSH
112766: LD_INT 17
112768: PUSH
112769: LD_INT 18
112771: PUSH
112772: LD_INT 19
112774: PUSH
112775: LD_INT 20
112777: PUSH
112778: LD_INT 21
112780: PUSH
112781: LD_INT 22
112783: PUSH
112784: LD_INT 23
112786: PUSH
112787: LD_INT 24
112789: PUSH
112790: LD_INT 25
112792: PUSH
112793: LD_INT 26
112795: PUSH
112796: LD_INT 27
112798: PUSH
112799: LD_INT 28
112801: PUSH
112802: LD_INT 29
112804: PUSH
112805: LD_INT 30
112807: PUSH
112808: LD_INT 31
112810: PUSH
112811: LD_INT 32
112813: PUSH
112814: LD_INT 33
112816: PUSH
112817: LD_INT 34
112819: PUSH
112820: LD_INT 36
112822: PUSH
112823: EMPTY
112824: LIST
112825: LIST
112826: LIST
112827: LIST
112828: LIST
112829: LIST
112830: LIST
112831: LIST
112832: LIST
112833: LIST
112834: LIST
112835: LIST
112836: LIST
112837: LIST
112838: LIST
112839: LIST
112840: LIST
112841: LIST
112842: LIST
112843: LIST
112844: LIST
112845: LIST
112846: LIST
112847: LIST
112848: LIST
112849: LIST
112850: LIST
112851: LIST
112852: LIST
112853: LIST
112854: LIST
112855: LIST
112856: LIST
112857: LIST
112858: LIST
112859: PUSH
112860: LD_INT 101
112862: PUSH
112863: LD_INT 102
112865: PUSH
112866: LD_INT 103
112868: PUSH
112869: LD_INT 104
112871: PUSH
112872: LD_INT 105
112874: PUSH
112875: LD_INT 106
112877: PUSH
112878: LD_INT 107
112880: PUSH
112881: LD_INT 108
112883: PUSH
112884: LD_INT 109
112886: PUSH
112887: LD_INT 110
112889: PUSH
112890: LD_INT 111
112892: PUSH
112893: LD_INT 112
112895: PUSH
112896: LD_INT 113
112898: PUSH
112899: LD_INT 114
112901: PUSH
112902: LD_INT 116
112904: PUSH
112905: LD_INT 117
112907: PUSH
112908: LD_INT 118
112910: PUSH
112911: EMPTY
112912: LIST
112913: LIST
112914: LIST
112915: LIST
112916: LIST
112917: LIST
112918: LIST
112919: LIST
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: LIST
112925: LIST
112926: LIST
112927: LIST
112928: LIST
112929: PUSH
112930: EMPTY
112931: LIST
112932: LIST
112933: ST_TO_ADDR
112934: GO 113333
112936: LD_INT 18
112938: DOUBLE
112939: EQUAL
112940: IFTRUE 112944
112942: GO 113092
112944: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
112945: LD_ADDR_VAR 0 2
112949: PUSH
112950: LD_INT 2
112952: PUSH
112953: LD_INT 4
112955: PUSH
112956: LD_INT 5
112958: PUSH
112959: LD_INT 7
112961: PUSH
112962: LD_INT 11
112964: PUSH
112965: LD_INT 12
112967: PUSH
112968: LD_INT 15
112970: PUSH
112971: LD_INT 16
112973: PUSH
112974: LD_INT 20
112976: PUSH
112977: LD_INT 21
112979: PUSH
112980: LD_INT 22
112982: PUSH
112983: LD_INT 23
112985: PUSH
112986: LD_INT 25
112988: PUSH
112989: LD_INT 26
112991: PUSH
112992: LD_INT 30
112994: PUSH
112995: LD_INT 31
112997: PUSH
112998: LD_INT 32
113000: PUSH
113001: LD_INT 33
113003: PUSH
113004: LD_INT 34
113006: PUSH
113007: LD_INT 35
113009: PUSH
113010: LD_INT 36
113012: PUSH
113013: EMPTY
113014: LIST
113015: LIST
113016: LIST
113017: LIST
113018: LIST
113019: LIST
113020: LIST
113021: LIST
113022: LIST
113023: LIST
113024: LIST
113025: LIST
113026: LIST
113027: LIST
113028: LIST
113029: LIST
113030: LIST
113031: LIST
113032: LIST
113033: LIST
113034: LIST
113035: PUSH
113036: LD_INT 101
113038: PUSH
113039: LD_INT 102
113041: PUSH
113042: LD_INT 103
113044: PUSH
113045: LD_INT 106
113047: PUSH
113048: LD_INT 108
113050: PUSH
113051: LD_INT 112
113053: PUSH
113054: LD_INT 113
113056: PUSH
113057: LD_INT 114
113059: PUSH
113060: LD_INT 115
113062: PUSH
113063: LD_INT 116
113065: PUSH
113066: LD_INT 117
113068: PUSH
113069: LD_INT 118
113071: PUSH
113072: EMPTY
113073: LIST
113074: LIST
113075: LIST
113076: LIST
113077: LIST
113078: LIST
113079: LIST
113080: LIST
113081: LIST
113082: LIST
113083: LIST
113084: LIST
113085: PUSH
113086: EMPTY
113087: LIST
113088: LIST
113089: ST_TO_ADDR
113090: GO 113333
113092: LD_INT 19
113094: DOUBLE
113095: EQUAL
113096: IFTRUE 113100
113098: GO 113332
113100: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
113101: LD_ADDR_VAR 0 2
113105: PUSH
113106: LD_INT 1
113108: PUSH
113109: LD_INT 2
113111: PUSH
113112: LD_INT 3
113114: PUSH
113115: LD_INT 4
113117: PUSH
113118: LD_INT 5
113120: PUSH
113121: LD_INT 6
113123: PUSH
113124: LD_INT 7
113126: PUSH
113127: LD_INT 8
113129: PUSH
113130: LD_INT 9
113132: PUSH
113133: LD_INT 10
113135: PUSH
113136: LD_INT 11
113138: PUSH
113139: LD_INT 12
113141: PUSH
113142: LD_INT 13
113144: PUSH
113145: LD_INT 14
113147: PUSH
113148: LD_INT 15
113150: PUSH
113151: LD_INT 16
113153: PUSH
113154: LD_INT 17
113156: PUSH
113157: LD_INT 18
113159: PUSH
113160: LD_INT 19
113162: PUSH
113163: LD_INT 20
113165: PUSH
113166: LD_INT 21
113168: PUSH
113169: LD_INT 22
113171: PUSH
113172: LD_INT 23
113174: PUSH
113175: LD_INT 24
113177: PUSH
113178: LD_INT 25
113180: PUSH
113181: LD_INT 26
113183: PUSH
113184: LD_INT 27
113186: PUSH
113187: LD_INT 28
113189: PUSH
113190: LD_INT 29
113192: PUSH
113193: LD_INT 30
113195: PUSH
113196: LD_INT 31
113198: PUSH
113199: LD_INT 32
113201: PUSH
113202: LD_INT 33
113204: PUSH
113205: LD_INT 34
113207: PUSH
113208: LD_INT 35
113210: PUSH
113211: LD_INT 36
113213: PUSH
113214: EMPTY
113215: LIST
113216: LIST
113217: LIST
113218: LIST
113219: LIST
113220: LIST
113221: LIST
113222: LIST
113223: LIST
113224: LIST
113225: LIST
113226: LIST
113227: LIST
113228: LIST
113229: LIST
113230: LIST
113231: LIST
113232: LIST
113233: LIST
113234: LIST
113235: LIST
113236: LIST
113237: LIST
113238: LIST
113239: LIST
113240: LIST
113241: LIST
113242: LIST
113243: LIST
113244: LIST
113245: LIST
113246: LIST
113247: LIST
113248: LIST
113249: LIST
113250: LIST
113251: PUSH
113252: LD_INT 101
113254: PUSH
113255: LD_INT 102
113257: PUSH
113258: LD_INT 103
113260: PUSH
113261: LD_INT 104
113263: PUSH
113264: LD_INT 105
113266: PUSH
113267: LD_INT 106
113269: PUSH
113270: LD_INT 107
113272: PUSH
113273: LD_INT 108
113275: PUSH
113276: LD_INT 109
113278: PUSH
113279: LD_INT 110
113281: PUSH
113282: LD_INT 111
113284: PUSH
113285: LD_INT 112
113287: PUSH
113288: LD_INT 113
113290: PUSH
113291: LD_INT 114
113293: PUSH
113294: LD_INT 115
113296: PUSH
113297: LD_INT 116
113299: PUSH
113300: LD_INT 117
113302: PUSH
113303: LD_INT 118
113305: PUSH
113306: EMPTY
113307: LIST
113308: LIST
113309: LIST
113310: LIST
113311: LIST
113312: LIST
113313: LIST
113314: LIST
113315: LIST
113316: LIST
113317: LIST
113318: LIST
113319: LIST
113320: LIST
113321: LIST
113322: LIST
113323: LIST
113324: LIST
113325: PUSH
113326: EMPTY
113327: LIST
113328: LIST
113329: ST_TO_ADDR
113330: GO 113333
113332: POP
// end else
113333: GO 113564
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
113335: LD_ADDR_VAR 0 2
113339: PUSH
113340: LD_INT 1
113342: PUSH
113343: LD_INT 2
113345: PUSH
113346: LD_INT 3
113348: PUSH
113349: LD_INT 4
113351: PUSH
113352: LD_INT 5
113354: PUSH
113355: LD_INT 6
113357: PUSH
113358: LD_INT 7
113360: PUSH
113361: LD_INT 8
113363: PUSH
113364: LD_INT 9
113366: PUSH
113367: LD_INT 10
113369: PUSH
113370: LD_INT 11
113372: PUSH
113373: LD_INT 12
113375: PUSH
113376: LD_INT 13
113378: PUSH
113379: LD_INT 14
113381: PUSH
113382: LD_INT 15
113384: PUSH
113385: LD_INT 16
113387: PUSH
113388: LD_INT 17
113390: PUSH
113391: LD_INT 18
113393: PUSH
113394: LD_INT 19
113396: PUSH
113397: LD_INT 20
113399: PUSH
113400: LD_INT 21
113402: PUSH
113403: LD_INT 22
113405: PUSH
113406: LD_INT 23
113408: PUSH
113409: LD_INT 24
113411: PUSH
113412: LD_INT 25
113414: PUSH
113415: LD_INT 26
113417: PUSH
113418: LD_INT 27
113420: PUSH
113421: LD_INT 28
113423: PUSH
113424: LD_INT 29
113426: PUSH
113427: LD_INT 30
113429: PUSH
113430: LD_INT 31
113432: PUSH
113433: LD_INT 32
113435: PUSH
113436: LD_INT 33
113438: PUSH
113439: LD_INT 34
113441: PUSH
113442: LD_INT 35
113444: PUSH
113445: LD_INT 36
113447: PUSH
113448: EMPTY
113449: LIST
113450: LIST
113451: LIST
113452: LIST
113453: LIST
113454: LIST
113455: LIST
113456: LIST
113457: LIST
113458: LIST
113459: LIST
113460: LIST
113461: LIST
113462: LIST
113463: LIST
113464: LIST
113465: LIST
113466: LIST
113467: LIST
113468: LIST
113469: LIST
113470: LIST
113471: LIST
113472: LIST
113473: LIST
113474: LIST
113475: LIST
113476: LIST
113477: LIST
113478: LIST
113479: LIST
113480: LIST
113481: LIST
113482: LIST
113483: LIST
113484: LIST
113485: PUSH
113486: LD_INT 101
113488: PUSH
113489: LD_INT 102
113491: PUSH
113492: LD_INT 103
113494: PUSH
113495: LD_INT 104
113497: PUSH
113498: LD_INT 105
113500: PUSH
113501: LD_INT 106
113503: PUSH
113504: LD_INT 107
113506: PUSH
113507: LD_INT 108
113509: PUSH
113510: LD_INT 109
113512: PUSH
113513: LD_INT 110
113515: PUSH
113516: LD_INT 111
113518: PUSH
113519: LD_INT 112
113521: PUSH
113522: LD_INT 113
113524: PUSH
113525: LD_INT 114
113527: PUSH
113528: LD_INT 115
113530: PUSH
113531: LD_INT 116
113533: PUSH
113534: LD_INT 117
113536: PUSH
113537: LD_INT 118
113539: PUSH
113540: EMPTY
113541: LIST
113542: LIST
113543: LIST
113544: LIST
113545: LIST
113546: LIST
113547: LIST
113548: LIST
113549: LIST
113550: LIST
113551: LIST
113552: LIST
113553: LIST
113554: LIST
113555: LIST
113556: LIST
113557: LIST
113558: LIST
113559: PUSH
113560: EMPTY
113561: LIST
113562: LIST
113563: ST_TO_ADDR
// if result then
113564: LD_VAR 0 2
113568: IFFALSE 114354
// begin normal :=  ;
113570: LD_ADDR_VAR 0 5
113574: PUSH
113575: LD_STRING 
113577: ST_TO_ADDR
// hardcore :=  ;
113578: LD_ADDR_VAR 0 6
113582: PUSH
113583: LD_STRING 
113585: ST_TO_ADDR
// active :=  ;
113586: LD_ADDR_VAR 0 7
113590: PUSH
113591: LD_STRING 
113593: ST_TO_ADDR
// for i = 1 to normalCounter do
113594: LD_ADDR_VAR 0 8
113598: PUSH
113599: DOUBLE
113600: LD_INT 1
113602: DEC
113603: ST_TO_ADDR
113604: LD_EXP 144
113608: PUSH
113609: FOR_TO
113610: IFFALSE 113711
// begin tmp := 0 ;
113612: LD_ADDR_VAR 0 3
113616: PUSH
113617: LD_STRING 0
113619: ST_TO_ADDR
// if result [ 1 ] then
113620: LD_VAR 0 2
113624: PUSH
113625: LD_INT 1
113627: ARRAY
113628: IFFALSE 113693
// if result [ 1 ] [ 1 ] = i then
113630: LD_VAR 0 2
113634: PUSH
113635: LD_INT 1
113637: ARRAY
113638: PUSH
113639: LD_INT 1
113641: ARRAY
113642: PUSH
113643: LD_VAR 0 8
113647: EQUAL
113648: IFFALSE 113693
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
113650: LD_ADDR_VAR 0 2
113654: PUSH
113655: LD_VAR 0 2
113659: PPUSH
113660: LD_INT 1
113662: PPUSH
113663: LD_VAR 0 2
113667: PUSH
113668: LD_INT 1
113670: ARRAY
113671: PPUSH
113672: LD_INT 1
113674: PPUSH
113675: CALL_OW 3
113679: PPUSH
113680: CALL_OW 1
113684: ST_TO_ADDR
// tmp := 1 ;
113685: LD_ADDR_VAR 0 3
113689: PUSH
113690: LD_STRING 1
113692: ST_TO_ADDR
// end ; normal := normal & tmp ;
113693: LD_ADDR_VAR 0 5
113697: PUSH
113698: LD_VAR 0 5
113702: PUSH
113703: LD_VAR 0 3
113707: STR
113708: ST_TO_ADDR
// end ;
113709: GO 113609
113711: POP
113712: POP
// for i = 1 to hardcoreCounter do
113713: LD_ADDR_VAR 0 8
113717: PUSH
113718: DOUBLE
113719: LD_INT 1
113721: DEC
113722: ST_TO_ADDR
113723: LD_EXP 145
113727: PUSH
113728: FOR_TO
113729: IFFALSE 113834
// begin tmp := 0 ;
113731: LD_ADDR_VAR 0 3
113735: PUSH
113736: LD_STRING 0
113738: ST_TO_ADDR
// if result [ 2 ] then
113739: LD_VAR 0 2
113743: PUSH
113744: LD_INT 2
113746: ARRAY
113747: IFFALSE 113816
// if result [ 2 ] [ 1 ] = 100 + i then
113749: LD_VAR 0 2
113753: PUSH
113754: LD_INT 2
113756: ARRAY
113757: PUSH
113758: LD_INT 1
113760: ARRAY
113761: PUSH
113762: LD_INT 100
113764: PUSH
113765: LD_VAR 0 8
113769: PLUS
113770: EQUAL
113771: IFFALSE 113816
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
113773: LD_ADDR_VAR 0 2
113777: PUSH
113778: LD_VAR 0 2
113782: PPUSH
113783: LD_INT 2
113785: PPUSH
113786: LD_VAR 0 2
113790: PUSH
113791: LD_INT 2
113793: ARRAY
113794: PPUSH
113795: LD_INT 1
113797: PPUSH
113798: CALL_OW 3
113802: PPUSH
113803: CALL_OW 1
113807: ST_TO_ADDR
// tmp := 1 ;
113808: LD_ADDR_VAR 0 3
113812: PUSH
113813: LD_STRING 1
113815: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
113816: LD_ADDR_VAR 0 6
113820: PUSH
113821: LD_VAR 0 6
113825: PUSH
113826: LD_VAR 0 3
113830: STR
113831: ST_TO_ADDR
// end ;
113832: GO 113728
113834: POP
113835: POP
// if isGameLoad then
113836: LD_VAR 0 1
113840: IFFALSE 114315
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
113842: LD_ADDR_VAR 0 4
113846: PUSH
113847: LD_EXP 148
113851: PUSH
113852: LD_EXP 147
113856: PUSH
113857: LD_EXP 149
113861: PUSH
113862: LD_EXP 146
113866: PUSH
113867: LD_EXP 150
113871: PUSH
113872: LD_EXP 151
113876: PUSH
113877: LD_EXP 152
113881: PUSH
113882: LD_EXP 153
113886: PUSH
113887: LD_EXP 154
113891: PUSH
113892: LD_EXP 155
113896: PUSH
113897: LD_EXP 156
113901: PUSH
113902: LD_EXP 157
113906: PUSH
113907: LD_EXP 158
113911: PUSH
113912: LD_EXP 159
113916: PUSH
113917: LD_EXP 167
113921: PUSH
113922: LD_EXP 168
113926: PUSH
113927: LD_EXP 169
113931: PUSH
113932: LD_EXP 170
113936: PUSH
113937: LD_EXP 172
113941: PUSH
113942: LD_EXP 173
113946: PUSH
113947: LD_EXP 174
113951: PUSH
113952: LD_EXP 177
113956: PUSH
113957: LD_EXP 179
113961: PUSH
113962: LD_EXP 180
113966: PUSH
113967: LD_EXP 181
113971: PUSH
113972: LD_EXP 183
113976: PUSH
113977: LD_EXP 184
113981: PUSH
113982: LD_EXP 187
113986: PUSH
113987: LD_EXP 188
113991: PUSH
113992: LD_EXP 189
113996: PUSH
113997: LD_EXP 190
114001: PUSH
114002: LD_EXP 191
114006: PUSH
114007: LD_EXP 192
114011: PUSH
114012: LD_EXP 193
114016: PUSH
114017: LD_EXP 194
114021: PUSH
114022: LD_EXP 195
114026: PUSH
114027: LD_EXP 160
114031: PUSH
114032: LD_EXP 161
114036: PUSH
114037: LD_EXP 164
114041: PUSH
114042: LD_EXP 165
114046: PUSH
114047: LD_EXP 166
114051: PUSH
114052: LD_EXP 162
114056: PUSH
114057: LD_EXP 163
114061: PUSH
114062: LD_EXP 171
114066: PUSH
114067: LD_EXP 175
114071: PUSH
114072: LD_EXP 176
114076: PUSH
114077: LD_EXP 178
114081: PUSH
114082: LD_EXP 182
114086: PUSH
114087: LD_EXP 185
114091: PUSH
114092: LD_EXP 186
114096: PUSH
114097: LD_EXP 196
114101: PUSH
114102: LD_EXP 197
114106: PUSH
114107: LD_EXP 198
114111: PUSH
114112: LD_EXP 199
114116: PUSH
114117: EMPTY
114118: LIST
114119: LIST
114120: LIST
114121: LIST
114122: LIST
114123: LIST
114124: LIST
114125: LIST
114126: LIST
114127: LIST
114128: LIST
114129: LIST
114130: LIST
114131: LIST
114132: LIST
114133: LIST
114134: LIST
114135: LIST
114136: LIST
114137: LIST
114138: LIST
114139: LIST
114140: LIST
114141: LIST
114142: LIST
114143: LIST
114144: LIST
114145: LIST
114146: LIST
114147: LIST
114148: LIST
114149: LIST
114150: LIST
114151: LIST
114152: LIST
114153: LIST
114154: LIST
114155: LIST
114156: LIST
114157: LIST
114158: LIST
114159: LIST
114160: LIST
114161: LIST
114162: LIST
114163: LIST
114164: LIST
114165: LIST
114166: LIST
114167: LIST
114168: LIST
114169: LIST
114170: LIST
114171: LIST
114172: ST_TO_ADDR
// tmp :=  ;
114173: LD_ADDR_VAR 0 3
114177: PUSH
114178: LD_STRING 
114180: ST_TO_ADDR
// for i = 1 to normalCounter do
114181: LD_ADDR_VAR 0 8
114185: PUSH
114186: DOUBLE
114187: LD_INT 1
114189: DEC
114190: ST_TO_ADDR
114191: LD_EXP 144
114195: PUSH
114196: FOR_TO
114197: IFFALSE 114233
// begin if flags [ i ] then
114199: LD_VAR 0 4
114203: PUSH
114204: LD_VAR 0 8
114208: ARRAY
114209: IFFALSE 114231
// tmp := tmp & i & ; ;
114211: LD_ADDR_VAR 0 3
114215: PUSH
114216: LD_VAR 0 3
114220: PUSH
114221: LD_VAR 0 8
114225: STR
114226: PUSH
114227: LD_STRING ;
114229: STR
114230: ST_TO_ADDR
// end ;
114231: GO 114196
114233: POP
114234: POP
// for i = 1 to hardcoreCounter do
114235: LD_ADDR_VAR 0 8
114239: PUSH
114240: DOUBLE
114241: LD_INT 1
114243: DEC
114244: ST_TO_ADDR
114245: LD_EXP 145
114249: PUSH
114250: FOR_TO
114251: IFFALSE 114297
// begin if flags [ normalCounter + i ] then
114253: LD_VAR 0 4
114257: PUSH
114258: LD_EXP 144
114262: PUSH
114263: LD_VAR 0 8
114267: PLUS
114268: ARRAY
114269: IFFALSE 114295
// tmp := tmp & ( 100 + i ) & ; ;
114271: LD_ADDR_VAR 0 3
114275: PUSH
114276: LD_VAR 0 3
114280: PUSH
114281: LD_INT 100
114283: PUSH
114284: LD_VAR 0 8
114288: PLUS
114289: STR
114290: PUSH
114291: LD_STRING ;
114293: STR
114294: ST_TO_ADDR
// end ;
114295: GO 114250
114297: POP
114298: POP
// if tmp then
114299: LD_VAR 0 3
114303: IFFALSE 114315
// active := tmp ;
114305: LD_ADDR_VAR 0 7
114309: PUSH
114310: LD_VAR 0 3
114314: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
114315: LD_STRING getStreamItemsFromMission("
114317: PUSH
114318: LD_VAR 0 5
114322: STR
114323: PUSH
114324: LD_STRING ","
114326: STR
114327: PUSH
114328: LD_VAR 0 6
114332: STR
114333: PUSH
114334: LD_STRING ","
114336: STR
114337: PUSH
114338: LD_VAR 0 7
114342: STR
114343: PUSH
114344: LD_STRING ")
114346: STR
114347: PPUSH
114348: CALL_OW 559
// end else
114352: GO 114361
// ToLua ( getStreamItemsFromMission("","","") ) ;
114354: LD_STRING getStreamItemsFromMission("","","")
114356: PPUSH
114357: CALL_OW 559
// end ;
114361: LD_VAR 0 2
114365: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
114366: LD_EXP 143
114370: PUSH
114371: LD_EXP 148
114375: AND
114376: IFFALSE 114500
114378: GO 114380
114380: DISABLE
114381: LD_INT 0
114383: PPUSH
114384: PPUSH
// begin enable ;
114385: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
114386: LD_ADDR_VAR 0 2
114390: PUSH
114391: LD_INT 22
114393: PUSH
114394: LD_OWVAR 2
114398: PUSH
114399: EMPTY
114400: LIST
114401: LIST
114402: PUSH
114403: LD_INT 2
114405: PUSH
114406: LD_INT 34
114408: PUSH
114409: LD_INT 7
114411: PUSH
114412: EMPTY
114413: LIST
114414: LIST
114415: PUSH
114416: LD_INT 34
114418: PUSH
114419: LD_INT 45
114421: PUSH
114422: EMPTY
114423: LIST
114424: LIST
114425: PUSH
114426: LD_INT 34
114428: PUSH
114429: LD_INT 28
114431: PUSH
114432: EMPTY
114433: LIST
114434: LIST
114435: PUSH
114436: LD_INT 34
114438: PUSH
114439: LD_INT 47
114441: PUSH
114442: EMPTY
114443: LIST
114444: LIST
114445: PUSH
114446: EMPTY
114447: LIST
114448: LIST
114449: LIST
114450: LIST
114451: LIST
114452: PUSH
114453: EMPTY
114454: LIST
114455: LIST
114456: PPUSH
114457: CALL_OW 69
114461: ST_TO_ADDR
// if not tmp then
114462: LD_VAR 0 2
114466: NOT
114467: IFFALSE 114471
// exit ;
114469: GO 114500
// for i in tmp do
114471: LD_ADDR_VAR 0 1
114475: PUSH
114476: LD_VAR 0 2
114480: PUSH
114481: FOR_IN
114482: IFFALSE 114498
// begin SetLives ( i , 0 ) ;
114484: LD_VAR 0 1
114488: PPUSH
114489: LD_INT 0
114491: PPUSH
114492: CALL_OW 234
// end ;
114496: GO 114481
114498: POP
114499: POP
// end ;
114500: PPOPN 2
114502: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
114503: LD_EXP 143
114507: PUSH
114508: LD_EXP 149
114512: AND
114513: IFFALSE 114597
114515: GO 114517
114517: DISABLE
114518: LD_INT 0
114520: PPUSH
114521: PPUSH
// begin enable ;
114522: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
114523: LD_ADDR_VAR 0 2
114527: PUSH
114528: LD_INT 22
114530: PUSH
114531: LD_OWVAR 2
114535: PUSH
114536: EMPTY
114537: LIST
114538: LIST
114539: PUSH
114540: LD_INT 32
114542: PUSH
114543: LD_INT 3
114545: PUSH
114546: EMPTY
114547: LIST
114548: LIST
114549: PUSH
114550: EMPTY
114551: LIST
114552: LIST
114553: PPUSH
114554: CALL_OW 69
114558: ST_TO_ADDR
// if not tmp then
114559: LD_VAR 0 2
114563: NOT
114564: IFFALSE 114568
// exit ;
114566: GO 114597
// for i in tmp do
114568: LD_ADDR_VAR 0 1
114572: PUSH
114573: LD_VAR 0 2
114577: PUSH
114578: FOR_IN
114579: IFFALSE 114595
// begin SetLives ( i , 0 ) ;
114581: LD_VAR 0 1
114585: PPUSH
114586: LD_INT 0
114588: PPUSH
114589: CALL_OW 234
// end ;
114593: GO 114578
114595: POP
114596: POP
// end ;
114597: PPOPN 2
114599: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
114600: LD_EXP 143
114604: PUSH
114605: LD_EXP 146
114609: AND
114610: IFFALSE 114703
114612: GO 114614
114614: DISABLE
114615: LD_INT 0
114617: PPUSH
// begin enable ;
114618: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
114619: LD_ADDR_VAR 0 1
114623: PUSH
114624: LD_INT 22
114626: PUSH
114627: LD_OWVAR 2
114631: PUSH
114632: EMPTY
114633: LIST
114634: LIST
114635: PUSH
114636: LD_INT 2
114638: PUSH
114639: LD_INT 25
114641: PUSH
114642: LD_INT 5
114644: PUSH
114645: EMPTY
114646: LIST
114647: LIST
114648: PUSH
114649: LD_INT 25
114651: PUSH
114652: LD_INT 9
114654: PUSH
114655: EMPTY
114656: LIST
114657: LIST
114658: PUSH
114659: LD_INT 25
114661: PUSH
114662: LD_INT 8
114664: PUSH
114665: EMPTY
114666: LIST
114667: LIST
114668: PUSH
114669: EMPTY
114670: LIST
114671: LIST
114672: LIST
114673: LIST
114674: PUSH
114675: EMPTY
114676: LIST
114677: LIST
114678: PPUSH
114679: CALL_OW 69
114683: PUSH
114684: FOR_IN
114685: IFFALSE 114701
// begin SetClass ( i , 1 ) ;
114687: LD_VAR 0 1
114691: PPUSH
114692: LD_INT 1
114694: PPUSH
114695: CALL_OW 336
// end ;
114699: GO 114684
114701: POP
114702: POP
// end ;
114703: PPOPN 1
114705: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
114706: LD_EXP 143
114710: PUSH
114711: LD_EXP 147
114715: AND
114716: PUSH
114717: LD_OWVAR 65
114721: PUSH
114722: LD_INT 7
114724: LESS
114725: AND
114726: IFFALSE 114740
114728: GO 114730
114730: DISABLE
// begin enable ;
114731: ENABLE
// game_speed := 7 ;
114732: LD_ADDR_OWVAR 65
114736: PUSH
114737: LD_INT 7
114739: ST_TO_ADDR
// end ;
114740: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
114741: LD_EXP 143
114745: PUSH
114746: LD_EXP 150
114750: AND
114751: IFFALSE 114953
114753: GO 114755
114755: DISABLE
114756: LD_INT 0
114758: PPUSH
114759: PPUSH
114760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
114761: LD_ADDR_VAR 0 3
114765: PUSH
114766: LD_INT 81
114768: PUSH
114769: LD_OWVAR 2
114773: PUSH
114774: EMPTY
114775: LIST
114776: LIST
114777: PUSH
114778: LD_INT 21
114780: PUSH
114781: LD_INT 1
114783: PUSH
114784: EMPTY
114785: LIST
114786: LIST
114787: PUSH
114788: EMPTY
114789: LIST
114790: LIST
114791: PPUSH
114792: CALL_OW 69
114796: ST_TO_ADDR
// if not tmp then
114797: LD_VAR 0 3
114801: NOT
114802: IFFALSE 114806
// exit ;
114804: GO 114953
// if tmp > 5 then
114806: LD_VAR 0 3
114810: PUSH
114811: LD_INT 5
114813: GREATER
114814: IFFALSE 114826
// k := 5 else
114816: LD_ADDR_VAR 0 2
114820: PUSH
114821: LD_INT 5
114823: ST_TO_ADDR
114824: GO 114836
// k := tmp ;
114826: LD_ADDR_VAR 0 2
114830: PUSH
114831: LD_VAR 0 3
114835: ST_TO_ADDR
// for i := 1 to k do
114836: LD_ADDR_VAR 0 1
114840: PUSH
114841: DOUBLE
114842: LD_INT 1
114844: DEC
114845: ST_TO_ADDR
114846: LD_VAR 0 2
114850: PUSH
114851: FOR_TO
114852: IFFALSE 114951
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
114854: LD_VAR 0 3
114858: PUSH
114859: LD_VAR 0 1
114863: ARRAY
114864: PPUSH
114865: LD_VAR 0 1
114869: PUSH
114870: LD_INT 4
114872: MOD
114873: PUSH
114874: LD_INT 1
114876: PLUS
114877: PPUSH
114878: CALL_OW 259
114882: PUSH
114883: LD_INT 10
114885: LESS
114886: IFFALSE 114949
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
114888: LD_VAR 0 3
114892: PUSH
114893: LD_VAR 0 1
114897: ARRAY
114898: PPUSH
114899: LD_VAR 0 1
114903: PUSH
114904: LD_INT 4
114906: MOD
114907: PUSH
114908: LD_INT 1
114910: PLUS
114911: PPUSH
114912: LD_VAR 0 3
114916: PUSH
114917: LD_VAR 0 1
114921: ARRAY
114922: PPUSH
114923: LD_VAR 0 1
114927: PUSH
114928: LD_INT 4
114930: MOD
114931: PUSH
114932: LD_INT 1
114934: PLUS
114935: PPUSH
114936: CALL_OW 259
114940: PUSH
114941: LD_INT 1
114943: PLUS
114944: PPUSH
114945: CALL_OW 237
114949: GO 114851
114951: POP
114952: POP
// end ;
114953: PPOPN 3
114955: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
114956: LD_EXP 143
114960: PUSH
114961: LD_EXP 151
114965: AND
114966: IFFALSE 114986
114968: GO 114970
114970: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
114971: LD_INT 4
114973: PPUSH
114974: LD_OWVAR 2
114978: PPUSH
114979: LD_INT 0
114981: PPUSH
114982: CALL_OW 324
114986: END
// every 0 0$1 trigger StreamModeActive and sShovel do
114987: LD_EXP 143
114991: PUSH
114992: LD_EXP 180
114996: AND
114997: IFFALSE 115017
114999: GO 115001
115001: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
115002: LD_INT 19
115004: PPUSH
115005: LD_OWVAR 2
115009: PPUSH
115010: LD_INT 0
115012: PPUSH
115013: CALL_OW 324
115017: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
115018: LD_EXP 143
115022: PUSH
115023: LD_EXP 152
115027: AND
115028: IFFALSE 115130
115030: GO 115032
115032: DISABLE
115033: LD_INT 0
115035: PPUSH
115036: PPUSH
// begin enable ;
115037: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
115038: LD_ADDR_VAR 0 2
115042: PUSH
115043: LD_INT 22
115045: PUSH
115046: LD_OWVAR 2
115050: PUSH
115051: EMPTY
115052: LIST
115053: LIST
115054: PUSH
115055: LD_INT 2
115057: PUSH
115058: LD_INT 34
115060: PUSH
115061: LD_INT 11
115063: PUSH
115064: EMPTY
115065: LIST
115066: LIST
115067: PUSH
115068: LD_INT 34
115070: PUSH
115071: LD_INT 30
115073: PUSH
115074: EMPTY
115075: LIST
115076: LIST
115077: PUSH
115078: EMPTY
115079: LIST
115080: LIST
115081: LIST
115082: PUSH
115083: EMPTY
115084: LIST
115085: LIST
115086: PPUSH
115087: CALL_OW 69
115091: ST_TO_ADDR
// if not tmp then
115092: LD_VAR 0 2
115096: NOT
115097: IFFALSE 115101
// exit ;
115099: GO 115130
// for i in tmp do
115101: LD_ADDR_VAR 0 1
115105: PUSH
115106: LD_VAR 0 2
115110: PUSH
115111: FOR_IN
115112: IFFALSE 115128
// begin SetLives ( i , 0 ) ;
115114: LD_VAR 0 1
115118: PPUSH
115119: LD_INT 0
115121: PPUSH
115122: CALL_OW 234
// end ;
115126: GO 115111
115128: POP
115129: POP
// end ;
115130: PPOPN 2
115132: END
// every 0 0$1 trigger StreamModeActive and sBunker do
115133: LD_EXP 143
115137: PUSH
115138: LD_EXP 153
115142: AND
115143: IFFALSE 115163
115145: GO 115147
115147: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
115148: LD_INT 32
115150: PPUSH
115151: LD_OWVAR 2
115155: PPUSH
115156: LD_INT 0
115158: PPUSH
115159: CALL_OW 324
115163: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
115164: LD_EXP 143
115168: PUSH
115169: LD_EXP 154
115173: AND
115174: IFFALSE 115355
115176: GO 115178
115178: DISABLE
115179: LD_INT 0
115181: PPUSH
115182: PPUSH
115183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
115184: LD_ADDR_VAR 0 2
115188: PUSH
115189: LD_INT 22
115191: PUSH
115192: LD_OWVAR 2
115196: PUSH
115197: EMPTY
115198: LIST
115199: LIST
115200: PUSH
115201: LD_INT 33
115203: PUSH
115204: LD_INT 3
115206: PUSH
115207: EMPTY
115208: LIST
115209: LIST
115210: PUSH
115211: EMPTY
115212: LIST
115213: LIST
115214: PPUSH
115215: CALL_OW 69
115219: ST_TO_ADDR
// if not tmp then
115220: LD_VAR 0 2
115224: NOT
115225: IFFALSE 115229
// exit ;
115227: GO 115355
// side := 0 ;
115229: LD_ADDR_VAR 0 3
115233: PUSH
115234: LD_INT 0
115236: ST_TO_ADDR
// for i := 1 to 8 do
115237: LD_ADDR_VAR 0 1
115241: PUSH
115242: DOUBLE
115243: LD_INT 1
115245: DEC
115246: ST_TO_ADDR
115247: LD_INT 8
115249: PUSH
115250: FOR_TO
115251: IFFALSE 115299
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
115253: LD_OWVAR 2
115257: PUSH
115258: LD_VAR 0 1
115262: NONEQUAL
115263: PUSH
115264: LD_OWVAR 2
115268: PPUSH
115269: LD_VAR 0 1
115273: PPUSH
115274: CALL_OW 81
115278: PUSH
115279: LD_INT 2
115281: EQUAL
115282: AND
115283: IFFALSE 115297
// begin side := i ;
115285: LD_ADDR_VAR 0 3
115289: PUSH
115290: LD_VAR 0 1
115294: ST_TO_ADDR
// break ;
115295: GO 115299
// end ;
115297: GO 115250
115299: POP
115300: POP
// if not side then
115301: LD_VAR 0 3
115305: NOT
115306: IFFALSE 115310
// exit ;
115308: GO 115355
// for i := 1 to tmp do
115310: LD_ADDR_VAR 0 1
115314: PUSH
115315: DOUBLE
115316: LD_INT 1
115318: DEC
115319: ST_TO_ADDR
115320: LD_VAR 0 2
115324: PUSH
115325: FOR_TO
115326: IFFALSE 115353
// if Prob ( 60 ) then
115328: LD_INT 60
115330: PPUSH
115331: CALL_OW 13
115335: IFFALSE 115351
// SetSide ( i , side ) ;
115337: LD_VAR 0 1
115341: PPUSH
115342: LD_VAR 0 3
115346: PPUSH
115347: CALL_OW 235
115351: GO 115325
115353: POP
115354: POP
// end ;
115355: PPOPN 3
115357: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
115358: LD_EXP 143
115362: PUSH
115363: LD_EXP 156
115367: AND
115368: IFFALSE 115487
115370: GO 115372
115372: DISABLE
115373: LD_INT 0
115375: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
115376: LD_ADDR_VAR 0 1
115380: PUSH
115381: LD_INT 22
115383: PUSH
115384: LD_OWVAR 2
115388: PUSH
115389: EMPTY
115390: LIST
115391: LIST
115392: PUSH
115393: LD_INT 21
115395: PUSH
115396: LD_INT 1
115398: PUSH
115399: EMPTY
115400: LIST
115401: LIST
115402: PUSH
115403: LD_INT 3
115405: PUSH
115406: LD_INT 23
115408: PUSH
115409: LD_INT 0
115411: PUSH
115412: EMPTY
115413: LIST
115414: LIST
115415: PUSH
115416: EMPTY
115417: LIST
115418: LIST
115419: PUSH
115420: EMPTY
115421: LIST
115422: LIST
115423: LIST
115424: PPUSH
115425: CALL_OW 69
115429: PUSH
115430: FOR_IN
115431: IFFALSE 115485
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
115433: LD_VAR 0 1
115437: PPUSH
115438: CALL_OW 257
115442: PUSH
115443: LD_INT 1
115445: PUSH
115446: LD_INT 2
115448: PUSH
115449: LD_INT 3
115451: PUSH
115452: LD_INT 4
115454: PUSH
115455: EMPTY
115456: LIST
115457: LIST
115458: LIST
115459: LIST
115460: IN
115461: IFFALSE 115483
// SetClass ( un , rand ( 1 , 4 ) ) ;
115463: LD_VAR 0 1
115467: PPUSH
115468: LD_INT 1
115470: PPUSH
115471: LD_INT 4
115473: PPUSH
115474: CALL_OW 12
115478: PPUSH
115479: CALL_OW 336
115483: GO 115430
115485: POP
115486: POP
// end ;
115487: PPOPN 1
115489: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
115490: LD_EXP 143
115494: PUSH
115495: LD_EXP 155
115499: AND
115500: IFFALSE 115579
115502: GO 115504
115504: DISABLE
115505: LD_INT 0
115507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115508: LD_ADDR_VAR 0 1
115512: PUSH
115513: LD_INT 22
115515: PUSH
115516: LD_OWVAR 2
115520: PUSH
115521: EMPTY
115522: LIST
115523: LIST
115524: PUSH
115525: LD_INT 21
115527: PUSH
115528: LD_INT 3
115530: PUSH
115531: EMPTY
115532: LIST
115533: LIST
115534: PUSH
115535: EMPTY
115536: LIST
115537: LIST
115538: PPUSH
115539: CALL_OW 69
115543: ST_TO_ADDR
// if not tmp then
115544: LD_VAR 0 1
115548: NOT
115549: IFFALSE 115553
// exit ;
115551: GO 115579
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
115553: LD_VAR 0 1
115557: PUSH
115558: LD_INT 1
115560: PPUSH
115561: LD_VAR 0 1
115565: PPUSH
115566: CALL_OW 12
115570: ARRAY
115571: PPUSH
115572: LD_INT 100
115574: PPUSH
115575: CALL_OW 234
// end ;
115579: PPOPN 1
115581: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
115582: LD_EXP 143
115586: PUSH
115587: LD_EXP 157
115591: AND
115592: IFFALSE 115690
115594: GO 115596
115596: DISABLE
115597: LD_INT 0
115599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
115600: LD_ADDR_VAR 0 1
115604: PUSH
115605: LD_INT 22
115607: PUSH
115608: LD_OWVAR 2
115612: PUSH
115613: EMPTY
115614: LIST
115615: LIST
115616: PUSH
115617: LD_INT 21
115619: PUSH
115620: LD_INT 1
115622: PUSH
115623: EMPTY
115624: LIST
115625: LIST
115626: PUSH
115627: EMPTY
115628: LIST
115629: LIST
115630: PPUSH
115631: CALL_OW 69
115635: ST_TO_ADDR
// if not tmp then
115636: LD_VAR 0 1
115640: NOT
115641: IFFALSE 115645
// exit ;
115643: GO 115690
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
115645: LD_VAR 0 1
115649: PUSH
115650: LD_INT 1
115652: PPUSH
115653: LD_VAR 0 1
115657: PPUSH
115658: CALL_OW 12
115662: ARRAY
115663: PPUSH
115664: LD_INT 1
115666: PPUSH
115667: LD_INT 4
115669: PPUSH
115670: CALL_OW 12
115674: PPUSH
115675: LD_INT 3000
115677: PPUSH
115678: LD_INT 9000
115680: PPUSH
115681: CALL_OW 12
115685: PPUSH
115686: CALL_OW 492
// end ;
115690: PPOPN 1
115692: END
// every 0 0$1 trigger StreamModeActive and sDepot do
115693: LD_EXP 143
115697: PUSH
115698: LD_EXP 158
115702: AND
115703: IFFALSE 115723
115705: GO 115707
115707: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
115708: LD_INT 1
115710: PPUSH
115711: LD_OWVAR 2
115715: PPUSH
115716: LD_INT 0
115718: PPUSH
115719: CALL_OW 324
115723: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
115724: LD_EXP 143
115728: PUSH
115729: LD_EXP 159
115733: AND
115734: IFFALSE 115817
115736: GO 115738
115738: DISABLE
115739: LD_INT 0
115741: PPUSH
115742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
115743: LD_ADDR_VAR 0 2
115747: PUSH
115748: LD_INT 22
115750: PUSH
115751: LD_OWVAR 2
115755: PUSH
115756: EMPTY
115757: LIST
115758: LIST
115759: PUSH
115760: LD_INT 21
115762: PUSH
115763: LD_INT 3
115765: PUSH
115766: EMPTY
115767: LIST
115768: LIST
115769: PUSH
115770: EMPTY
115771: LIST
115772: LIST
115773: PPUSH
115774: CALL_OW 69
115778: ST_TO_ADDR
// if not tmp then
115779: LD_VAR 0 2
115783: NOT
115784: IFFALSE 115788
// exit ;
115786: GO 115817
// for i in tmp do
115788: LD_ADDR_VAR 0 1
115792: PUSH
115793: LD_VAR 0 2
115797: PUSH
115798: FOR_IN
115799: IFFALSE 115815
// SetBLevel ( i , 10 ) ;
115801: LD_VAR 0 1
115805: PPUSH
115806: LD_INT 10
115808: PPUSH
115809: CALL_OW 241
115813: GO 115798
115815: POP
115816: POP
// end ;
115817: PPOPN 2
115819: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
115820: LD_EXP 143
115824: PUSH
115825: LD_EXP 160
115829: AND
115830: IFFALSE 115941
115832: GO 115834
115834: DISABLE
115835: LD_INT 0
115837: PPUSH
115838: PPUSH
115839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115840: LD_ADDR_VAR 0 3
115844: PUSH
115845: LD_INT 22
115847: PUSH
115848: LD_OWVAR 2
115852: PUSH
115853: EMPTY
115854: LIST
115855: LIST
115856: PUSH
115857: LD_INT 25
115859: PUSH
115860: LD_INT 1
115862: PUSH
115863: EMPTY
115864: LIST
115865: LIST
115866: PUSH
115867: EMPTY
115868: LIST
115869: LIST
115870: PPUSH
115871: CALL_OW 69
115875: ST_TO_ADDR
// if not tmp then
115876: LD_VAR 0 3
115880: NOT
115881: IFFALSE 115885
// exit ;
115883: GO 115941
// un := tmp [ rand ( 1 , tmp ) ] ;
115885: LD_ADDR_VAR 0 2
115889: PUSH
115890: LD_VAR 0 3
115894: PUSH
115895: LD_INT 1
115897: PPUSH
115898: LD_VAR 0 3
115902: PPUSH
115903: CALL_OW 12
115907: ARRAY
115908: ST_TO_ADDR
// if Crawls ( un ) then
115909: LD_VAR 0 2
115913: PPUSH
115914: CALL_OW 318
115918: IFFALSE 115929
// ComWalk ( un ) ;
115920: LD_VAR 0 2
115924: PPUSH
115925: CALL_OW 138
// SetClass ( un , class_sniper ) ;
115929: LD_VAR 0 2
115933: PPUSH
115934: LD_INT 5
115936: PPUSH
115937: CALL_OW 336
// end ;
115941: PPOPN 3
115943: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
115944: LD_EXP 143
115948: PUSH
115949: LD_EXP 161
115953: AND
115954: PUSH
115955: LD_OWVAR 67
115959: PUSH
115960: LD_INT 4
115962: LESS
115963: AND
115964: IFFALSE 115983
115966: GO 115968
115968: DISABLE
// begin Difficulty := Difficulty + 1 ;
115969: LD_ADDR_OWVAR 67
115973: PUSH
115974: LD_OWVAR 67
115978: PUSH
115979: LD_INT 1
115981: PLUS
115982: ST_TO_ADDR
// end ;
115983: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
115984: LD_EXP 143
115988: PUSH
115989: LD_EXP 162
115993: AND
115994: IFFALSE 116097
115996: GO 115998
115998: DISABLE
115999: LD_INT 0
116001: PPUSH
// begin for i := 1 to 5 do
116002: LD_ADDR_VAR 0 1
116006: PUSH
116007: DOUBLE
116008: LD_INT 1
116010: DEC
116011: ST_TO_ADDR
116012: LD_INT 5
116014: PUSH
116015: FOR_TO
116016: IFFALSE 116095
// begin uc_nation := nation_nature ;
116018: LD_ADDR_OWVAR 21
116022: PUSH
116023: LD_INT 0
116025: ST_TO_ADDR
// uc_side := 0 ;
116026: LD_ADDR_OWVAR 20
116030: PUSH
116031: LD_INT 0
116033: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116034: LD_ADDR_OWVAR 29
116038: PUSH
116039: LD_INT 12
116041: PUSH
116042: LD_INT 12
116044: PUSH
116045: EMPTY
116046: LIST
116047: LIST
116048: ST_TO_ADDR
// hc_agressivity := 20 ;
116049: LD_ADDR_OWVAR 35
116053: PUSH
116054: LD_INT 20
116056: ST_TO_ADDR
// hc_class := class_tiger ;
116057: LD_ADDR_OWVAR 28
116061: PUSH
116062: LD_INT 14
116064: ST_TO_ADDR
// hc_gallery :=  ;
116065: LD_ADDR_OWVAR 33
116069: PUSH
116070: LD_STRING 
116072: ST_TO_ADDR
// hc_name :=  ;
116073: LD_ADDR_OWVAR 26
116077: PUSH
116078: LD_STRING 
116080: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
116081: CALL_OW 44
116085: PPUSH
116086: LD_INT 0
116088: PPUSH
116089: CALL_OW 51
// end ;
116093: GO 116015
116095: POP
116096: POP
// end ;
116097: PPOPN 1
116099: END
// every 0 0$1 trigger StreamModeActive and sBomb do
116100: LD_EXP 143
116104: PUSH
116105: LD_EXP 163
116109: AND
116110: IFFALSE 116119
116112: GO 116114
116114: DISABLE
// StreamSibBomb ;
116115: CALL 116120 0 0
116119: END
// export function StreamSibBomb ; var i , x , y ; begin
116120: LD_INT 0
116122: PPUSH
116123: PPUSH
116124: PPUSH
116125: PPUSH
// result := false ;
116126: LD_ADDR_VAR 0 1
116130: PUSH
116131: LD_INT 0
116133: ST_TO_ADDR
// for i := 1 to 16 do
116134: LD_ADDR_VAR 0 2
116138: PUSH
116139: DOUBLE
116140: LD_INT 1
116142: DEC
116143: ST_TO_ADDR
116144: LD_INT 16
116146: PUSH
116147: FOR_TO
116148: IFFALSE 116347
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116150: LD_ADDR_VAR 0 3
116154: PUSH
116155: LD_INT 10
116157: PUSH
116158: LD_INT 20
116160: PUSH
116161: LD_INT 30
116163: PUSH
116164: LD_INT 40
116166: PUSH
116167: LD_INT 50
116169: PUSH
116170: LD_INT 60
116172: PUSH
116173: LD_INT 70
116175: PUSH
116176: LD_INT 80
116178: PUSH
116179: LD_INT 90
116181: PUSH
116182: LD_INT 100
116184: PUSH
116185: LD_INT 110
116187: PUSH
116188: LD_INT 120
116190: PUSH
116191: LD_INT 130
116193: PUSH
116194: LD_INT 140
116196: PUSH
116197: LD_INT 150
116199: PUSH
116200: EMPTY
116201: LIST
116202: LIST
116203: LIST
116204: LIST
116205: LIST
116206: LIST
116207: LIST
116208: LIST
116209: LIST
116210: LIST
116211: LIST
116212: LIST
116213: LIST
116214: LIST
116215: LIST
116216: PUSH
116217: LD_INT 1
116219: PPUSH
116220: LD_INT 15
116222: PPUSH
116223: CALL_OW 12
116227: ARRAY
116228: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
116229: LD_ADDR_VAR 0 4
116233: PUSH
116234: LD_INT 10
116236: PUSH
116237: LD_INT 20
116239: PUSH
116240: LD_INT 30
116242: PUSH
116243: LD_INT 40
116245: PUSH
116246: LD_INT 50
116248: PUSH
116249: LD_INT 60
116251: PUSH
116252: LD_INT 70
116254: PUSH
116255: LD_INT 80
116257: PUSH
116258: LD_INT 90
116260: PUSH
116261: LD_INT 100
116263: PUSH
116264: LD_INT 110
116266: PUSH
116267: LD_INT 120
116269: PUSH
116270: LD_INT 130
116272: PUSH
116273: LD_INT 140
116275: PUSH
116276: LD_INT 150
116278: PUSH
116279: EMPTY
116280: LIST
116281: LIST
116282: LIST
116283: LIST
116284: LIST
116285: LIST
116286: LIST
116287: LIST
116288: LIST
116289: LIST
116290: LIST
116291: LIST
116292: LIST
116293: LIST
116294: LIST
116295: PUSH
116296: LD_INT 1
116298: PPUSH
116299: LD_INT 15
116301: PPUSH
116302: CALL_OW 12
116306: ARRAY
116307: ST_TO_ADDR
// if ValidHex ( x , y ) then
116308: LD_VAR 0 3
116312: PPUSH
116313: LD_VAR 0 4
116317: PPUSH
116318: CALL_OW 488
116322: IFFALSE 116345
// begin result := [ x , y ] ;
116324: LD_ADDR_VAR 0 1
116328: PUSH
116329: LD_VAR 0 3
116333: PUSH
116334: LD_VAR 0 4
116338: PUSH
116339: EMPTY
116340: LIST
116341: LIST
116342: ST_TO_ADDR
// break ;
116343: GO 116347
// end ; end ;
116345: GO 116147
116347: POP
116348: POP
// if result then
116349: LD_VAR 0 1
116353: IFFALSE 116413
// begin ToLua ( playSibBomb() ) ;
116355: LD_STRING playSibBomb()
116357: PPUSH
116358: CALL_OW 559
// wait ( 0 0$14 ) ;
116362: LD_INT 490
116364: PPUSH
116365: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
116369: LD_VAR 0 1
116373: PUSH
116374: LD_INT 1
116376: ARRAY
116377: PPUSH
116378: LD_VAR 0 1
116382: PUSH
116383: LD_INT 2
116385: ARRAY
116386: PPUSH
116387: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
116391: LD_VAR 0 1
116395: PUSH
116396: LD_INT 1
116398: ARRAY
116399: PPUSH
116400: LD_VAR 0 1
116404: PUSH
116405: LD_INT 2
116407: ARRAY
116408: PPUSH
116409: CALL_OW 429
// end ; end ;
116413: LD_VAR 0 1
116417: RET
// every 0 0$1 trigger StreamModeActive and sReset do
116418: LD_EXP 143
116422: PUSH
116423: LD_EXP 165
116427: AND
116428: IFFALSE 116440
116430: GO 116432
116432: DISABLE
// YouLost (  ) ;
116433: LD_STRING 
116435: PPUSH
116436: CALL_OW 104
116440: END
// every 0 0$1 trigger StreamModeActive and sFog do
116441: LD_EXP 143
116445: PUSH
116446: LD_EXP 164
116450: AND
116451: IFFALSE 116465
116453: GO 116455
116455: DISABLE
// FogOff ( your_side ) ;
116456: LD_OWVAR 2
116460: PPUSH
116461: CALL_OW 344
116465: END
// every 0 0$1 trigger StreamModeActive and sSun do
116466: LD_EXP 143
116470: PUSH
116471: LD_EXP 166
116475: AND
116476: IFFALSE 116504
116478: GO 116480
116480: DISABLE
// begin solar_recharge_percent := 0 ;
116481: LD_ADDR_OWVAR 79
116485: PUSH
116486: LD_INT 0
116488: ST_TO_ADDR
// wait ( 5 5$00 ) ;
116489: LD_INT 10500
116491: PPUSH
116492: CALL_OW 67
// solar_recharge_percent := 100 ;
116496: LD_ADDR_OWVAR 79
116500: PUSH
116501: LD_INT 100
116503: ST_TO_ADDR
// end ;
116504: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
116505: LD_EXP 143
116509: PUSH
116510: LD_EXP 167
116514: AND
116515: IFFALSE 116754
116517: GO 116519
116519: DISABLE
116520: LD_INT 0
116522: PPUSH
116523: PPUSH
116524: PPUSH
// begin tmp := [ ] ;
116525: LD_ADDR_VAR 0 3
116529: PUSH
116530: EMPTY
116531: ST_TO_ADDR
// for i := 1 to 6 do
116532: LD_ADDR_VAR 0 1
116536: PUSH
116537: DOUBLE
116538: LD_INT 1
116540: DEC
116541: ST_TO_ADDR
116542: LD_INT 6
116544: PUSH
116545: FOR_TO
116546: IFFALSE 116651
// begin uc_nation := nation_nature ;
116548: LD_ADDR_OWVAR 21
116552: PUSH
116553: LD_INT 0
116555: ST_TO_ADDR
// uc_side := 0 ;
116556: LD_ADDR_OWVAR 20
116560: PUSH
116561: LD_INT 0
116563: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
116564: LD_ADDR_OWVAR 29
116568: PUSH
116569: LD_INT 12
116571: PUSH
116572: LD_INT 12
116574: PUSH
116575: EMPTY
116576: LIST
116577: LIST
116578: ST_TO_ADDR
// hc_agressivity := 20 ;
116579: LD_ADDR_OWVAR 35
116583: PUSH
116584: LD_INT 20
116586: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
116587: LD_ADDR_OWVAR 28
116591: PUSH
116592: LD_INT 17
116594: ST_TO_ADDR
// hc_gallery :=  ;
116595: LD_ADDR_OWVAR 33
116599: PUSH
116600: LD_STRING 
116602: ST_TO_ADDR
// hc_name :=  ;
116603: LD_ADDR_OWVAR 26
116607: PUSH
116608: LD_STRING 
116610: ST_TO_ADDR
// un := CreateHuman ;
116611: LD_ADDR_VAR 0 2
116615: PUSH
116616: CALL_OW 44
116620: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
116621: LD_VAR 0 2
116625: PPUSH
116626: LD_INT 1
116628: PPUSH
116629: CALL_OW 51
// tmp := tmp ^ un ;
116633: LD_ADDR_VAR 0 3
116637: PUSH
116638: LD_VAR 0 3
116642: PUSH
116643: LD_VAR 0 2
116647: ADD
116648: ST_TO_ADDR
// end ;
116649: GO 116545
116651: POP
116652: POP
// repeat wait ( 0 0$1 ) ;
116653: LD_INT 35
116655: PPUSH
116656: CALL_OW 67
// for un in tmp do
116660: LD_ADDR_VAR 0 2
116664: PUSH
116665: LD_VAR 0 3
116669: PUSH
116670: FOR_IN
116671: IFFALSE 116745
// begin if IsDead ( un ) then
116673: LD_VAR 0 2
116677: PPUSH
116678: CALL_OW 301
116682: IFFALSE 116702
// begin tmp := tmp diff un ;
116684: LD_ADDR_VAR 0 3
116688: PUSH
116689: LD_VAR 0 3
116693: PUSH
116694: LD_VAR 0 2
116698: DIFF
116699: ST_TO_ADDR
// continue ;
116700: GO 116670
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
116702: LD_VAR 0 2
116706: PPUSH
116707: LD_INT 3
116709: PUSH
116710: LD_INT 22
116712: PUSH
116713: LD_INT 0
116715: PUSH
116716: EMPTY
116717: LIST
116718: LIST
116719: PUSH
116720: EMPTY
116721: LIST
116722: LIST
116723: PPUSH
116724: CALL_OW 69
116728: PPUSH
116729: LD_VAR 0 2
116733: PPUSH
116734: CALL_OW 74
116738: PPUSH
116739: CALL_OW 115
// end ;
116743: GO 116670
116745: POP
116746: POP
// until not tmp ;
116747: LD_VAR 0 3
116751: NOT
116752: IFFALSE 116653
// end ;
116754: PPOPN 3
116756: END
// every 0 0$1 trigger StreamModeActive and sTroll do
116757: LD_EXP 143
116761: PUSH
116762: LD_EXP 168
116766: AND
116767: IFFALSE 116821
116769: GO 116771
116771: DISABLE
// begin ToLua ( displayTroll(); ) ;
116772: LD_STRING displayTroll();
116774: PPUSH
116775: CALL_OW 559
// wait ( 3 3$00 ) ;
116779: LD_INT 6300
116781: PPUSH
116782: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116786: LD_STRING hideTroll();
116788: PPUSH
116789: CALL_OW 559
// wait ( 1 1$00 ) ;
116793: LD_INT 2100
116795: PPUSH
116796: CALL_OW 67
// ToLua ( displayTroll(); ) ;
116800: LD_STRING displayTroll();
116802: PPUSH
116803: CALL_OW 559
// wait ( 1 1$00 ) ;
116807: LD_INT 2100
116809: PPUSH
116810: CALL_OW 67
// ToLua ( hideTroll(); ) ;
116814: LD_STRING hideTroll();
116816: PPUSH
116817: CALL_OW 559
// end ;
116821: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
116822: LD_EXP 143
116826: PUSH
116827: LD_EXP 169
116831: AND
116832: IFFALSE 116895
116834: GO 116836
116836: DISABLE
116837: LD_INT 0
116839: PPUSH
// begin p := 0 ;
116840: LD_ADDR_VAR 0 1
116844: PUSH
116845: LD_INT 0
116847: ST_TO_ADDR
// repeat game_speed := 1 ;
116848: LD_ADDR_OWVAR 65
116852: PUSH
116853: LD_INT 1
116855: ST_TO_ADDR
// wait ( 0 0$1 ) ;
116856: LD_INT 35
116858: PPUSH
116859: CALL_OW 67
// p := p + 1 ;
116863: LD_ADDR_VAR 0 1
116867: PUSH
116868: LD_VAR 0 1
116872: PUSH
116873: LD_INT 1
116875: PLUS
116876: ST_TO_ADDR
// until p >= 60 ;
116877: LD_VAR 0 1
116881: PUSH
116882: LD_INT 60
116884: GREATEREQUAL
116885: IFFALSE 116848
// game_speed := 4 ;
116887: LD_ADDR_OWVAR 65
116891: PUSH
116892: LD_INT 4
116894: ST_TO_ADDR
// end ;
116895: PPOPN 1
116897: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
116898: LD_EXP 143
116902: PUSH
116903: LD_EXP 170
116907: AND
116908: IFFALSE 117054
116910: GO 116912
116912: DISABLE
116913: LD_INT 0
116915: PPUSH
116916: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116917: LD_ADDR_VAR 0 1
116921: PUSH
116922: LD_INT 22
116924: PUSH
116925: LD_OWVAR 2
116929: PUSH
116930: EMPTY
116931: LIST
116932: LIST
116933: PUSH
116934: LD_INT 2
116936: PUSH
116937: LD_INT 30
116939: PUSH
116940: LD_INT 0
116942: PUSH
116943: EMPTY
116944: LIST
116945: LIST
116946: PUSH
116947: LD_INT 30
116949: PUSH
116950: LD_INT 1
116952: PUSH
116953: EMPTY
116954: LIST
116955: LIST
116956: PUSH
116957: EMPTY
116958: LIST
116959: LIST
116960: LIST
116961: PUSH
116962: EMPTY
116963: LIST
116964: LIST
116965: PPUSH
116966: CALL_OW 69
116970: ST_TO_ADDR
// if not depot then
116971: LD_VAR 0 1
116975: NOT
116976: IFFALSE 116980
// exit ;
116978: GO 117054
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
116980: LD_ADDR_VAR 0 2
116984: PUSH
116985: LD_VAR 0 1
116989: PUSH
116990: LD_INT 1
116992: PPUSH
116993: LD_VAR 0 1
116997: PPUSH
116998: CALL_OW 12
117002: ARRAY
117003: PPUSH
117004: CALL_OW 274
117008: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
117009: LD_VAR 0 2
117013: PPUSH
117014: LD_INT 1
117016: PPUSH
117017: LD_INT 0
117019: PPUSH
117020: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
117024: LD_VAR 0 2
117028: PPUSH
117029: LD_INT 2
117031: PPUSH
117032: LD_INT 0
117034: PPUSH
117035: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
117039: LD_VAR 0 2
117043: PPUSH
117044: LD_INT 3
117046: PPUSH
117047: LD_INT 0
117049: PPUSH
117050: CALL_OW 277
// end ;
117054: PPOPN 2
117056: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
117057: LD_EXP 143
117061: PUSH
117062: LD_EXP 171
117066: AND
117067: IFFALSE 117164
117069: GO 117071
117071: DISABLE
117072: LD_INT 0
117074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117075: LD_ADDR_VAR 0 1
117079: PUSH
117080: LD_INT 22
117082: PUSH
117083: LD_OWVAR 2
117087: PUSH
117088: EMPTY
117089: LIST
117090: LIST
117091: PUSH
117092: LD_INT 21
117094: PUSH
117095: LD_INT 1
117097: PUSH
117098: EMPTY
117099: LIST
117100: LIST
117101: PUSH
117102: LD_INT 3
117104: PUSH
117105: LD_INT 23
117107: PUSH
117108: LD_INT 0
117110: PUSH
117111: EMPTY
117112: LIST
117113: LIST
117114: PUSH
117115: EMPTY
117116: LIST
117117: LIST
117118: PUSH
117119: EMPTY
117120: LIST
117121: LIST
117122: LIST
117123: PPUSH
117124: CALL_OW 69
117128: ST_TO_ADDR
// if not tmp then
117129: LD_VAR 0 1
117133: NOT
117134: IFFALSE 117138
// exit ;
117136: GO 117164
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
117138: LD_VAR 0 1
117142: PUSH
117143: LD_INT 1
117145: PPUSH
117146: LD_VAR 0 1
117150: PPUSH
117151: CALL_OW 12
117155: ARRAY
117156: PPUSH
117157: LD_INT 200
117159: PPUSH
117160: CALL_OW 234
// end ;
117164: PPOPN 1
117166: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
117167: LD_EXP 143
117171: PUSH
117172: LD_EXP 172
117176: AND
117177: IFFALSE 117256
117179: GO 117181
117181: DISABLE
117182: LD_INT 0
117184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
117185: LD_ADDR_VAR 0 1
117189: PUSH
117190: LD_INT 22
117192: PUSH
117193: LD_OWVAR 2
117197: PUSH
117198: EMPTY
117199: LIST
117200: LIST
117201: PUSH
117202: LD_INT 21
117204: PUSH
117205: LD_INT 2
117207: PUSH
117208: EMPTY
117209: LIST
117210: LIST
117211: PUSH
117212: EMPTY
117213: LIST
117214: LIST
117215: PPUSH
117216: CALL_OW 69
117220: ST_TO_ADDR
// if not tmp then
117221: LD_VAR 0 1
117225: NOT
117226: IFFALSE 117230
// exit ;
117228: GO 117256
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
117230: LD_VAR 0 1
117234: PUSH
117235: LD_INT 1
117237: PPUSH
117238: LD_VAR 0 1
117242: PPUSH
117243: CALL_OW 12
117247: ARRAY
117248: PPUSH
117249: LD_INT 60
117251: PPUSH
117252: CALL_OW 234
// end ;
117256: PPOPN 1
117258: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
117259: LD_EXP 143
117263: PUSH
117264: LD_EXP 173
117268: AND
117269: IFFALSE 117368
117271: GO 117273
117273: DISABLE
117274: LD_INT 0
117276: PPUSH
117277: PPUSH
// begin enable ;
117278: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
117279: LD_ADDR_VAR 0 1
117283: PUSH
117284: LD_INT 22
117286: PUSH
117287: LD_OWVAR 2
117291: PUSH
117292: EMPTY
117293: LIST
117294: LIST
117295: PUSH
117296: LD_INT 61
117298: PUSH
117299: EMPTY
117300: LIST
117301: PUSH
117302: LD_INT 33
117304: PUSH
117305: LD_INT 2
117307: PUSH
117308: EMPTY
117309: LIST
117310: LIST
117311: PUSH
117312: EMPTY
117313: LIST
117314: LIST
117315: LIST
117316: PPUSH
117317: CALL_OW 69
117321: ST_TO_ADDR
// if not tmp then
117322: LD_VAR 0 1
117326: NOT
117327: IFFALSE 117331
// exit ;
117329: GO 117368
// for i in tmp do
117331: LD_ADDR_VAR 0 2
117335: PUSH
117336: LD_VAR 0 1
117340: PUSH
117341: FOR_IN
117342: IFFALSE 117366
// if IsControledBy ( i ) then
117344: LD_VAR 0 2
117348: PPUSH
117349: CALL_OW 312
117353: IFFALSE 117364
// ComUnlink ( i ) ;
117355: LD_VAR 0 2
117359: PPUSH
117360: CALL_OW 136
117364: GO 117341
117366: POP
117367: POP
// end ;
117368: PPOPN 2
117370: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
117371: LD_EXP 143
117375: PUSH
117376: LD_EXP 174
117380: AND
117381: IFFALSE 117521
117383: GO 117385
117385: DISABLE
117386: LD_INT 0
117388: PPUSH
117389: PPUSH
// begin ToLua ( displayPowell(); ) ;
117390: LD_STRING displayPowell();
117392: PPUSH
117393: CALL_OW 559
// uc_side := 0 ;
117397: LD_ADDR_OWVAR 20
117401: PUSH
117402: LD_INT 0
117404: ST_TO_ADDR
// uc_nation := 2 ;
117405: LD_ADDR_OWVAR 21
117409: PUSH
117410: LD_INT 2
117412: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
117413: LD_ADDR_OWVAR 37
117417: PUSH
117418: LD_INT 14
117420: ST_TO_ADDR
// vc_engine := engine_siberite ;
117421: LD_ADDR_OWVAR 39
117425: PUSH
117426: LD_INT 3
117428: ST_TO_ADDR
// vc_control := control_apeman ;
117429: LD_ADDR_OWVAR 38
117433: PUSH
117434: LD_INT 5
117436: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
117437: LD_ADDR_OWVAR 40
117441: PUSH
117442: LD_INT 29
117444: ST_TO_ADDR
// un := CreateVehicle ;
117445: LD_ADDR_VAR 0 2
117449: PUSH
117450: CALL_OW 45
117454: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117455: LD_VAR 0 2
117459: PPUSH
117460: LD_INT 1
117462: PPUSH
117463: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
117467: LD_INT 35
117469: PPUSH
117470: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
117474: LD_VAR 0 2
117478: PPUSH
117479: LD_INT 22
117481: PUSH
117482: LD_OWVAR 2
117486: PUSH
117487: EMPTY
117488: LIST
117489: LIST
117490: PPUSH
117491: CALL_OW 69
117495: PPUSH
117496: LD_VAR 0 2
117500: PPUSH
117501: CALL_OW 74
117505: PPUSH
117506: CALL_OW 115
// until IsDead ( un ) ;
117510: LD_VAR 0 2
117514: PPUSH
117515: CALL_OW 301
117519: IFFALSE 117467
// end ;
117521: PPOPN 2
117523: END
// every 0 0$1 trigger StreamModeActive and sStu do
117524: LD_EXP 143
117528: PUSH
117529: LD_EXP 182
117533: AND
117534: IFFALSE 117550
117536: GO 117538
117538: DISABLE
// begin ToLua ( displayStucuk(); ) ;
117539: LD_STRING displayStucuk();
117541: PPUSH
117542: CALL_OW 559
// ResetFog ;
117546: CALL_OW 335
// end ;
117550: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
117551: LD_EXP 143
117555: PUSH
117556: LD_EXP 175
117560: AND
117561: IFFALSE 117702
117563: GO 117565
117565: DISABLE
117566: LD_INT 0
117568: PPUSH
117569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117570: LD_ADDR_VAR 0 2
117574: PUSH
117575: LD_INT 22
117577: PUSH
117578: LD_OWVAR 2
117582: PUSH
117583: EMPTY
117584: LIST
117585: LIST
117586: PUSH
117587: LD_INT 21
117589: PUSH
117590: LD_INT 1
117592: PUSH
117593: EMPTY
117594: LIST
117595: LIST
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: PPUSH
117601: CALL_OW 69
117605: ST_TO_ADDR
// if not tmp then
117606: LD_VAR 0 2
117610: NOT
117611: IFFALSE 117615
// exit ;
117613: GO 117702
// un := tmp [ rand ( 1 , tmp ) ] ;
117615: LD_ADDR_VAR 0 1
117619: PUSH
117620: LD_VAR 0 2
117624: PUSH
117625: LD_INT 1
117627: PPUSH
117628: LD_VAR 0 2
117632: PPUSH
117633: CALL_OW 12
117637: ARRAY
117638: ST_TO_ADDR
// SetSide ( un , 0 ) ;
117639: LD_VAR 0 1
117643: PPUSH
117644: LD_INT 0
117646: PPUSH
117647: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
117651: LD_VAR 0 1
117655: PPUSH
117656: LD_OWVAR 3
117660: PUSH
117661: LD_VAR 0 1
117665: DIFF
117666: PPUSH
117667: LD_VAR 0 1
117671: PPUSH
117672: CALL_OW 74
117676: PPUSH
117677: CALL_OW 115
// wait ( 0 0$20 ) ;
117681: LD_INT 700
117683: PPUSH
117684: CALL_OW 67
// SetSide ( un , your_side ) ;
117688: LD_VAR 0 1
117692: PPUSH
117693: LD_OWVAR 2
117697: PPUSH
117698: CALL_OW 235
// end ;
117702: PPOPN 2
117704: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
117705: LD_EXP 143
117709: PUSH
117710: LD_EXP 176
117714: AND
117715: IFFALSE 117821
117717: GO 117719
117719: DISABLE
117720: LD_INT 0
117722: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
117723: LD_ADDR_VAR 0 1
117727: PUSH
117728: LD_INT 22
117730: PUSH
117731: LD_OWVAR 2
117735: PUSH
117736: EMPTY
117737: LIST
117738: LIST
117739: PUSH
117740: LD_INT 2
117742: PUSH
117743: LD_INT 30
117745: PUSH
117746: LD_INT 0
117748: PUSH
117749: EMPTY
117750: LIST
117751: LIST
117752: PUSH
117753: LD_INT 30
117755: PUSH
117756: LD_INT 1
117758: PUSH
117759: EMPTY
117760: LIST
117761: LIST
117762: PUSH
117763: EMPTY
117764: LIST
117765: LIST
117766: LIST
117767: PUSH
117768: EMPTY
117769: LIST
117770: LIST
117771: PPUSH
117772: CALL_OW 69
117776: ST_TO_ADDR
// if not depot then
117777: LD_VAR 0 1
117781: NOT
117782: IFFALSE 117786
// exit ;
117784: GO 117821
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
117786: LD_VAR 0 1
117790: PUSH
117791: LD_INT 1
117793: ARRAY
117794: PPUSH
117795: CALL_OW 250
117799: PPUSH
117800: LD_VAR 0 1
117804: PUSH
117805: LD_INT 1
117807: ARRAY
117808: PPUSH
117809: CALL_OW 251
117813: PPUSH
117814: LD_INT 70
117816: PPUSH
117817: CALL_OW 495
// end ;
117821: PPOPN 1
117823: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
117824: LD_EXP 143
117828: PUSH
117829: LD_EXP 177
117833: AND
117834: IFFALSE 118045
117836: GO 117838
117838: DISABLE
117839: LD_INT 0
117841: PPUSH
117842: PPUSH
117843: PPUSH
117844: PPUSH
117845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117846: LD_ADDR_VAR 0 5
117850: PUSH
117851: LD_INT 22
117853: PUSH
117854: LD_OWVAR 2
117858: PUSH
117859: EMPTY
117860: LIST
117861: LIST
117862: PUSH
117863: LD_INT 21
117865: PUSH
117866: LD_INT 1
117868: PUSH
117869: EMPTY
117870: LIST
117871: LIST
117872: PUSH
117873: EMPTY
117874: LIST
117875: LIST
117876: PPUSH
117877: CALL_OW 69
117881: ST_TO_ADDR
// if not tmp then
117882: LD_VAR 0 5
117886: NOT
117887: IFFALSE 117891
// exit ;
117889: GO 118045
// for i in tmp do
117891: LD_ADDR_VAR 0 1
117895: PUSH
117896: LD_VAR 0 5
117900: PUSH
117901: FOR_IN
117902: IFFALSE 118043
// begin d := rand ( 0 , 5 ) ;
117904: LD_ADDR_VAR 0 4
117908: PUSH
117909: LD_INT 0
117911: PPUSH
117912: LD_INT 5
117914: PPUSH
117915: CALL_OW 12
117919: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
117920: LD_ADDR_VAR 0 2
117924: PUSH
117925: LD_VAR 0 1
117929: PPUSH
117930: CALL_OW 250
117934: PPUSH
117935: LD_VAR 0 4
117939: PPUSH
117940: LD_INT 3
117942: PPUSH
117943: LD_INT 12
117945: PPUSH
117946: CALL_OW 12
117950: PPUSH
117951: CALL_OW 272
117955: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
117956: LD_ADDR_VAR 0 3
117960: PUSH
117961: LD_VAR 0 1
117965: PPUSH
117966: CALL_OW 251
117970: PPUSH
117971: LD_VAR 0 4
117975: PPUSH
117976: LD_INT 3
117978: PPUSH
117979: LD_INT 12
117981: PPUSH
117982: CALL_OW 12
117986: PPUSH
117987: CALL_OW 273
117991: ST_TO_ADDR
// if ValidHex ( x , y ) then
117992: LD_VAR 0 2
117996: PPUSH
117997: LD_VAR 0 3
118001: PPUSH
118002: CALL_OW 488
118006: IFFALSE 118041
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
118008: LD_VAR 0 1
118012: PPUSH
118013: LD_VAR 0 2
118017: PPUSH
118018: LD_VAR 0 3
118022: PPUSH
118023: LD_INT 3
118025: PPUSH
118026: LD_INT 6
118028: PPUSH
118029: CALL_OW 12
118033: PPUSH
118034: LD_INT 1
118036: PPUSH
118037: CALL_OW 483
// end ;
118041: GO 117901
118043: POP
118044: POP
// end ;
118045: PPOPN 5
118047: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
118048: LD_EXP 143
118052: PUSH
118053: LD_EXP 178
118057: AND
118058: IFFALSE 118152
118060: GO 118062
118062: DISABLE
118063: LD_INT 0
118065: PPUSH
118066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
118067: LD_ADDR_VAR 0 2
118071: PUSH
118072: LD_INT 22
118074: PUSH
118075: LD_OWVAR 2
118079: PUSH
118080: EMPTY
118081: LIST
118082: LIST
118083: PUSH
118084: LD_INT 32
118086: PUSH
118087: LD_INT 1
118089: PUSH
118090: EMPTY
118091: LIST
118092: LIST
118093: PUSH
118094: LD_INT 21
118096: PUSH
118097: LD_INT 2
118099: PUSH
118100: EMPTY
118101: LIST
118102: LIST
118103: PUSH
118104: EMPTY
118105: LIST
118106: LIST
118107: LIST
118108: PPUSH
118109: CALL_OW 69
118113: ST_TO_ADDR
// if not tmp then
118114: LD_VAR 0 2
118118: NOT
118119: IFFALSE 118123
// exit ;
118121: GO 118152
// for i in tmp do
118123: LD_ADDR_VAR 0 1
118127: PUSH
118128: LD_VAR 0 2
118132: PUSH
118133: FOR_IN
118134: IFFALSE 118150
// SetFuel ( i , 0 ) ;
118136: LD_VAR 0 1
118140: PPUSH
118141: LD_INT 0
118143: PPUSH
118144: CALL_OW 240
118148: GO 118133
118150: POP
118151: POP
// end ;
118152: PPOPN 2
118154: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
118155: LD_EXP 143
118159: PUSH
118160: LD_EXP 179
118164: AND
118165: IFFALSE 118231
118167: GO 118169
118169: DISABLE
118170: LD_INT 0
118172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118173: LD_ADDR_VAR 0 1
118177: PUSH
118178: LD_INT 22
118180: PUSH
118181: LD_OWVAR 2
118185: PUSH
118186: EMPTY
118187: LIST
118188: LIST
118189: PUSH
118190: LD_INT 30
118192: PUSH
118193: LD_INT 29
118195: PUSH
118196: EMPTY
118197: LIST
118198: LIST
118199: PUSH
118200: EMPTY
118201: LIST
118202: LIST
118203: PPUSH
118204: CALL_OW 69
118208: ST_TO_ADDR
// if not tmp then
118209: LD_VAR 0 1
118213: NOT
118214: IFFALSE 118218
// exit ;
118216: GO 118231
// DestroyUnit ( tmp [ 1 ] ) ;
118218: LD_VAR 0 1
118222: PUSH
118223: LD_INT 1
118225: ARRAY
118226: PPUSH
118227: CALL_OW 65
// end ;
118231: PPOPN 1
118233: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
118234: LD_EXP 143
118238: PUSH
118239: LD_EXP 181
118243: AND
118244: IFFALSE 118373
118246: GO 118248
118248: DISABLE
118249: LD_INT 0
118251: PPUSH
// begin uc_side := 0 ;
118252: LD_ADDR_OWVAR 20
118256: PUSH
118257: LD_INT 0
118259: ST_TO_ADDR
// uc_nation := nation_arabian ;
118260: LD_ADDR_OWVAR 21
118264: PUSH
118265: LD_INT 2
118267: ST_TO_ADDR
// hc_gallery :=  ;
118268: LD_ADDR_OWVAR 33
118272: PUSH
118273: LD_STRING 
118275: ST_TO_ADDR
// hc_name :=  ;
118276: LD_ADDR_OWVAR 26
118280: PUSH
118281: LD_STRING 
118283: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
118284: LD_INT 1
118286: PPUSH
118287: LD_INT 11
118289: PPUSH
118290: LD_INT 10
118292: PPUSH
118293: CALL_OW 380
// un := CreateHuman ;
118297: LD_ADDR_VAR 0 1
118301: PUSH
118302: CALL_OW 44
118306: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118307: LD_VAR 0 1
118311: PPUSH
118312: LD_INT 1
118314: PPUSH
118315: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
118319: LD_INT 35
118321: PPUSH
118322: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
118326: LD_VAR 0 1
118330: PPUSH
118331: LD_INT 22
118333: PUSH
118334: LD_OWVAR 2
118338: PUSH
118339: EMPTY
118340: LIST
118341: LIST
118342: PPUSH
118343: CALL_OW 69
118347: PPUSH
118348: LD_VAR 0 1
118352: PPUSH
118353: CALL_OW 74
118357: PPUSH
118358: CALL_OW 115
// until IsDead ( un ) ;
118362: LD_VAR 0 1
118366: PPUSH
118367: CALL_OW 301
118371: IFFALSE 118319
// end ;
118373: PPOPN 1
118375: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
118376: LD_EXP 143
118380: PUSH
118381: LD_EXP 183
118385: AND
118386: IFFALSE 118398
118388: GO 118390
118390: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
118391: LD_STRING earthquake(getX(game), 0, 32)
118393: PPUSH
118394: CALL_OW 559
118398: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
118399: LD_EXP 143
118403: PUSH
118404: LD_EXP 184
118408: AND
118409: IFFALSE 118500
118411: GO 118413
118413: DISABLE
118414: LD_INT 0
118416: PPUSH
// begin enable ;
118417: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
118418: LD_ADDR_VAR 0 1
118422: PUSH
118423: LD_INT 22
118425: PUSH
118426: LD_OWVAR 2
118430: PUSH
118431: EMPTY
118432: LIST
118433: LIST
118434: PUSH
118435: LD_INT 21
118437: PUSH
118438: LD_INT 2
118440: PUSH
118441: EMPTY
118442: LIST
118443: LIST
118444: PUSH
118445: LD_INT 33
118447: PUSH
118448: LD_INT 3
118450: PUSH
118451: EMPTY
118452: LIST
118453: LIST
118454: PUSH
118455: EMPTY
118456: LIST
118457: LIST
118458: LIST
118459: PPUSH
118460: CALL_OW 69
118464: ST_TO_ADDR
// if not tmp then
118465: LD_VAR 0 1
118469: NOT
118470: IFFALSE 118474
// exit ;
118472: GO 118500
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
118474: LD_VAR 0 1
118478: PUSH
118479: LD_INT 1
118481: PPUSH
118482: LD_VAR 0 1
118486: PPUSH
118487: CALL_OW 12
118491: ARRAY
118492: PPUSH
118493: LD_INT 1
118495: PPUSH
118496: CALL_OW 234
// end ;
118500: PPOPN 1
118502: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
118503: LD_EXP 143
118507: PUSH
118508: LD_EXP 185
118512: AND
118513: IFFALSE 118654
118515: GO 118517
118517: DISABLE
118518: LD_INT 0
118520: PPUSH
118521: PPUSH
118522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118523: LD_ADDR_VAR 0 3
118527: PUSH
118528: LD_INT 22
118530: PUSH
118531: LD_OWVAR 2
118535: PUSH
118536: EMPTY
118537: LIST
118538: LIST
118539: PUSH
118540: LD_INT 25
118542: PUSH
118543: LD_INT 1
118545: PUSH
118546: EMPTY
118547: LIST
118548: LIST
118549: PUSH
118550: EMPTY
118551: LIST
118552: LIST
118553: PPUSH
118554: CALL_OW 69
118558: ST_TO_ADDR
// if not tmp then
118559: LD_VAR 0 3
118563: NOT
118564: IFFALSE 118568
// exit ;
118566: GO 118654
// un := tmp [ rand ( 1 , tmp ) ] ;
118568: LD_ADDR_VAR 0 2
118572: PUSH
118573: LD_VAR 0 3
118577: PUSH
118578: LD_INT 1
118580: PPUSH
118581: LD_VAR 0 3
118585: PPUSH
118586: CALL_OW 12
118590: ARRAY
118591: ST_TO_ADDR
// if Crawls ( un ) then
118592: LD_VAR 0 2
118596: PPUSH
118597: CALL_OW 318
118601: IFFALSE 118612
// ComWalk ( un ) ;
118603: LD_VAR 0 2
118607: PPUSH
118608: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
118612: LD_VAR 0 2
118616: PPUSH
118617: LD_INT 9
118619: PPUSH
118620: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
118624: LD_INT 28
118626: PPUSH
118627: LD_OWVAR 2
118631: PPUSH
118632: LD_INT 2
118634: PPUSH
118635: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
118639: LD_INT 29
118641: PPUSH
118642: LD_OWVAR 2
118646: PPUSH
118647: LD_INT 2
118649: PPUSH
118650: CALL_OW 322
// end ;
118654: PPOPN 3
118656: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
118657: LD_EXP 143
118661: PUSH
118662: LD_EXP 186
118666: AND
118667: IFFALSE 118778
118669: GO 118671
118671: DISABLE
118672: LD_INT 0
118674: PPUSH
118675: PPUSH
118676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118677: LD_ADDR_VAR 0 3
118681: PUSH
118682: LD_INT 22
118684: PUSH
118685: LD_OWVAR 2
118689: PUSH
118690: EMPTY
118691: LIST
118692: LIST
118693: PUSH
118694: LD_INT 25
118696: PUSH
118697: LD_INT 1
118699: PUSH
118700: EMPTY
118701: LIST
118702: LIST
118703: PUSH
118704: EMPTY
118705: LIST
118706: LIST
118707: PPUSH
118708: CALL_OW 69
118712: ST_TO_ADDR
// if not tmp then
118713: LD_VAR 0 3
118717: NOT
118718: IFFALSE 118722
// exit ;
118720: GO 118778
// un := tmp [ rand ( 1 , tmp ) ] ;
118722: LD_ADDR_VAR 0 2
118726: PUSH
118727: LD_VAR 0 3
118731: PUSH
118732: LD_INT 1
118734: PPUSH
118735: LD_VAR 0 3
118739: PPUSH
118740: CALL_OW 12
118744: ARRAY
118745: ST_TO_ADDR
// if Crawls ( un ) then
118746: LD_VAR 0 2
118750: PPUSH
118751: CALL_OW 318
118755: IFFALSE 118766
// ComWalk ( un ) ;
118757: LD_VAR 0 2
118761: PPUSH
118762: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118766: LD_VAR 0 2
118770: PPUSH
118771: LD_INT 8
118773: PPUSH
118774: CALL_OW 336
// end ;
118778: PPOPN 3
118780: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
118781: LD_EXP 143
118785: PUSH
118786: LD_EXP 187
118790: AND
118791: IFFALSE 118935
118793: GO 118795
118795: DISABLE
118796: LD_INT 0
118798: PPUSH
118799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
118800: LD_ADDR_VAR 0 2
118804: PUSH
118805: LD_INT 22
118807: PUSH
118808: LD_OWVAR 2
118812: PUSH
118813: EMPTY
118814: LIST
118815: LIST
118816: PUSH
118817: LD_INT 21
118819: PUSH
118820: LD_INT 2
118822: PUSH
118823: EMPTY
118824: LIST
118825: LIST
118826: PUSH
118827: LD_INT 2
118829: PUSH
118830: LD_INT 34
118832: PUSH
118833: LD_INT 12
118835: PUSH
118836: EMPTY
118837: LIST
118838: LIST
118839: PUSH
118840: LD_INT 34
118842: PUSH
118843: LD_INT 51
118845: PUSH
118846: EMPTY
118847: LIST
118848: LIST
118849: PUSH
118850: LD_INT 34
118852: PUSH
118853: LD_INT 32
118855: PUSH
118856: EMPTY
118857: LIST
118858: LIST
118859: PUSH
118860: EMPTY
118861: LIST
118862: LIST
118863: LIST
118864: LIST
118865: PUSH
118866: EMPTY
118867: LIST
118868: LIST
118869: LIST
118870: PPUSH
118871: CALL_OW 69
118875: ST_TO_ADDR
// if not tmp then
118876: LD_VAR 0 2
118880: NOT
118881: IFFALSE 118885
// exit ;
118883: GO 118935
// for i in tmp do
118885: LD_ADDR_VAR 0 1
118889: PUSH
118890: LD_VAR 0 2
118894: PUSH
118895: FOR_IN
118896: IFFALSE 118933
// if GetCargo ( i , mat_artifact ) = 0 then
118898: LD_VAR 0 1
118902: PPUSH
118903: LD_INT 4
118905: PPUSH
118906: CALL_OW 289
118910: PUSH
118911: LD_INT 0
118913: EQUAL
118914: IFFALSE 118931
// SetCargo ( i , mat_siberit , 100 ) ;
118916: LD_VAR 0 1
118920: PPUSH
118921: LD_INT 3
118923: PPUSH
118924: LD_INT 100
118926: PPUSH
118927: CALL_OW 290
118931: GO 118895
118933: POP
118934: POP
// end ;
118935: PPOPN 2
118937: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
118938: LD_EXP 143
118942: PUSH
118943: LD_EXP 188
118947: AND
118948: IFFALSE 119131
118950: GO 118952
118952: DISABLE
118953: LD_INT 0
118955: PPUSH
118956: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
118957: LD_ADDR_VAR 0 2
118961: PUSH
118962: LD_INT 22
118964: PUSH
118965: LD_OWVAR 2
118969: PUSH
118970: EMPTY
118971: LIST
118972: LIST
118973: PPUSH
118974: CALL_OW 69
118978: ST_TO_ADDR
// if not tmp then
118979: LD_VAR 0 2
118983: NOT
118984: IFFALSE 118988
// exit ;
118986: GO 119131
// for i := 1 to 2 do
118988: LD_ADDR_VAR 0 1
118992: PUSH
118993: DOUBLE
118994: LD_INT 1
118996: DEC
118997: ST_TO_ADDR
118998: LD_INT 2
119000: PUSH
119001: FOR_TO
119002: IFFALSE 119129
// begin uc_side := your_side ;
119004: LD_ADDR_OWVAR 20
119008: PUSH
119009: LD_OWVAR 2
119013: ST_TO_ADDR
// uc_nation := nation_american ;
119014: LD_ADDR_OWVAR 21
119018: PUSH
119019: LD_INT 1
119021: ST_TO_ADDR
// vc_chassis := us_morphling ;
119022: LD_ADDR_OWVAR 37
119026: PUSH
119027: LD_INT 5
119029: ST_TO_ADDR
// vc_engine := engine_siberite ;
119030: LD_ADDR_OWVAR 39
119034: PUSH
119035: LD_INT 3
119037: ST_TO_ADDR
// vc_control := control_computer ;
119038: LD_ADDR_OWVAR 38
119042: PUSH
119043: LD_INT 3
119045: ST_TO_ADDR
// vc_weapon := us_double_laser ;
119046: LD_ADDR_OWVAR 40
119050: PUSH
119051: LD_INT 10
119053: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
119054: LD_VAR 0 2
119058: PUSH
119059: LD_INT 1
119061: ARRAY
119062: PPUSH
119063: CALL_OW 310
119067: NOT
119068: IFFALSE 119115
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
119070: CALL_OW 45
119074: PPUSH
119075: LD_VAR 0 2
119079: PUSH
119080: LD_INT 1
119082: ARRAY
119083: PPUSH
119084: CALL_OW 250
119088: PPUSH
119089: LD_VAR 0 2
119093: PUSH
119094: LD_INT 1
119096: ARRAY
119097: PPUSH
119098: CALL_OW 251
119102: PPUSH
119103: LD_INT 12
119105: PPUSH
119106: LD_INT 1
119108: PPUSH
119109: CALL_OW 50
119113: GO 119127
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
119115: CALL_OW 45
119119: PPUSH
119120: LD_INT 1
119122: PPUSH
119123: CALL_OW 51
// end ;
119127: GO 119001
119129: POP
119130: POP
// end ;
119131: PPOPN 2
119133: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
119134: LD_EXP 143
119138: PUSH
119139: LD_EXP 189
119143: AND
119144: IFFALSE 119366
119146: GO 119148
119148: DISABLE
119149: LD_INT 0
119151: PPUSH
119152: PPUSH
119153: PPUSH
119154: PPUSH
119155: PPUSH
119156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119157: LD_ADDR_VAR 0 6
119161: PUSH
119162: LD_INT 22
119164: PUSH
119165: LD_OWVAR 2
119169: PUSH
119170: EMPTY
119171: LIST
119172: LIST
119173: PUSH
119174: LD_INT 21
119176: PUSH
119177: LD_INT 1
119179: PUSH
119180: EMPTY
119181: LIST
119182: LIST
119183: PUSH
119184: LD_INT 3
119186: PUSH
119187: LD_INT 23
119189: PUSH
119190: LD_INT 0
119192: PUSH
119193: EMPTY
119194: LIST
119195: LIST
119196: PUSH
119197: EMPTY
119198: LIST
119199: LIST
119200: PUSH
119201: EMPTY
119202: LIST
119203: LIST
119204: LIST
119205: PPUSH
119206: CALL_OW 69
119210: ST_TO_ADDR
// if not tmp then
119211: LD_VAR 0 6
119215: NOT
119216: IFFALSE 119220
// exit ;
119218: GO 119366
// s1 := rand ( 1 , 4 ) ;
119220: LD_ADDR_VAR 0 2
119224: PUSH
119225: LD_INT 1
119227: PPUSH
119228: LD_INT 4
119230: PPUSH
119231: CALL_OW 12
119235: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
119236: LD_ADDR_VAR 0 4
119240: PUSH
119241: LD_VAR 0 6
119245: PUSH
119246: LD_INT 1
119248: ARRAY
119249: PPUSH
119250: LD_VAR 0 2
119254: PPUSH
119255: CALL_OW 259
119259: ST_TO_ADDR
// if s1 = 1 then
119260: LD_VAR 0 2
119264: PUSH
119265: LD_INT 1
119267: EQUAL
119268: IFFALSE 119288
// s2 := rand ( 2 , 4 ) else
119270: LD_ADDR_VAR 0 3
119274: PUSH
119275: LD_INT 2
119277: PPUSH
119278: LD_INT 4
119280: PPUSH
119281: CALL_OW 12
119285: ST_TO_ADDR
119286: GO 119296
// s2 := 1 ;
119288: LD_ADDR_VAR 0 3
119292: PUSH
119293: LD_INT 1
119295: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
119296: LD_ADDR_VAR 0 5
119300: PUSH
119301: LD_VAR 0 6
119305: PUSH
119306: LD_INT 1
119308: ARRAY
119309: PPUSH
119310: LD_VAR 0 3
119314: PPUSH
119315: CALL_OW 259
119319: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
119320: LD_VAR 0 6
119324: PUSH
119325: LD_INT 1
119327: ARRAY
119328: PPUSH
119329: LD_VAR 0 2
119333: PPUSH
119334: LD_VAR 0 5
119338: PPUSH
119339: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
119343: LD_VAR 0 6
119347: PUSH
119348: LD_INT 1
119350: ARRAY
119351: PPUSH
119352: LD_VAR 0 3
119356: PPUSH
119357: LD_VAR 0 4
119361: PPUSH
119362: CALL_OW 237
// end ;
119366: PPOPN 6
119368: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
119369: LD_EXP 143
119373: PUSH
119374: LD_EXP 190
119378: AND
119379: IFFALSE 119458
119381: GO 119383
119383: DISABLE
119384: LD_INT 0
119386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
119387: LD_ADDR_VAR 0 1
119391: PUSH
119392: LD_INT 22
119394: PUSH
119395: LD_OWVAR 2
119399: PUSH
119400: EMPTY
119401: LIST
119402: LIST
119403: PUSH
119404: LD_INT 30
119406: PUSH
119407: LD_INT 3
119409: PUSH
119410: EMPTY
119411: LIST
119412: LIST
119413: PUSH
119414: EMPTY
119415: LIST
119416: LIST
119417: PPUSH
119418: CALL_OW 69
119422: ST_TO_ADDR
// if not tmp then
119423: LD_VAR 0 1
119427: NOT
119428: IFFALSE 119432
// exit ;
119430: GO 119458
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
119432: LD_VAR 0 1
119436: PUSH
119437: LD_INT 1
119439: PPUSH
119440: LD_VAR 0 1
119444: PPUSH
119445: CALL_OW 12
119449: ARRAY
119450: PPUSH
119451: LD_INT 1
119453: PPUSH
119454: CALL_OW 234
// end ;
119458: PPOPN 1
119460: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
119461: LD_EXP 143
119465: PUSH
119466: LD_EXP 191
119470: AND
119471: IFFALSE 119583
119473: GO 119475
119475: DISABLE
119476: LD_INT 0
119478: PPUSH
119479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
119480: LD_ADDR_VAR 0 2
119484: PUSH
119485: LD_INT 22
119487: PUSH
119488: LD_OWVAR 2
119492: PUSH
119493: EMPTY
119494: LIST
119495: LIST
119496: PUSH
119497: LD_INT 2
119499: PUSH
119500: LD_INT 30
119502: PUSH
119503: LD_INT 27
119505: PUSH
119506: EMPTY
119507: LIST
119508: LIST
119509: PUSH
119510: LD_INT 30
119512: PUSH
119513: LD_INT 26
119515: PUSH
119516: EMPTY
119517: LIST
119518: LIST
119519: PUSH
119520: LD_INT 30
119522: PUSH
119523: LD_INT 28
119525: PUSH
119526: EMPTY
119527: LIST
119528: LIST
119529: PUSH
119530: EMPTY
119531: LIST
119532: LIST
119533: LIST
119534: LIST
119535: PUSH
119536: EMPTY
119537: LIST
119538: LIST
119539: PPUSH
119540: CALL_OW 69
119544: ST_TO_ADDR
// if not tmp then
119545: LD_VAR 0 2
119549: NOT
119550: IFFALSE 119554
// exit ;
119552: GO 119583
// for i in tmp do
119554: LD_ADDR_VAR 0 1
119558: PUSH
119559: LD_VAR 0 2
119563: PUSH
119564: FOR_IN
119565: IFFALSE 119581
// SetLives ( i , 1 ) ;
119567: LD_VAR 0 1
119571: PPUSH
119572: LD_INT 1
119574: PPUSH
119575: CALL_OW 234
119579: GO 119564
119581: POP
119582: POP
// end ;
119583: PPOPN 2
119585: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
119586: LD_EXP 143
119590: PUSH
119591: LD_EXP 192
119595: AND
119596: IFFALSE 119883
119598: GO 119600
119600: DISABLE
119601: LD_INT 0
119603: PPUSH
119604: PPUSH
119605: PPUSH
// begin i := rand ( 1 , 7 ) ;
119606: LD_ADDR_VAR 0 1
119610: PUSH
119611: LD_INT 1
119613: PPUSH
119614: LD_INT 7
119616: PPUSH
119617: CALL_OW 12
119621: ST_TO_ADDR
// case i of 1 :
119622: LD_VAR 0 1
119626: PUSH
119627: LD_INT 1
119629: DOUBLE
119630: EQUAL
119631: IFTRUE 119635
119633: GO 119645
119635: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
119636: LD_STRING earthquake(getX(game), 0, 32)
119638: PPUSH
119639: CALL_OW 559
119643: GO 119883
119645: LD_INT 2
119647: DOUBLE
119648: EQUAL
119649: IFTRUE 119653
119651: GO 119667
119653: POP
// begin ToLua ( displayStucuk(); ) ;
119654: LD_STRING displayStucuk();
119656: PPUSH
119657: CALL_OW 559
// ResetFog ;
119661: CALL_OW 335
// end ; 3 :
119665: GO 119883
119667: LD_INT 3
119669: DOUBLE
119670: EQUAL
119671: IFTRUE 119675
119673: GO 119779
119675: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
119676: LD_ADDR_VAR 0 2
119680: PUSH
119681: LD_INT 22
119683: PUSH
119684: LD_OWVAR 2
119688: PUSH
119689: EMPTY
119690: LIST
119691: LIST
119692: PUSH
119693: LD_INT 25
119695: PUSH
119696: LD_INT 1
119698: PUSH
119699: EMPTY
119700: LIST
119701: LIST
119702: PUSH
119703: EMPTY
119704: LIST
119705: LIST
119706: PPUSH
119707: CALL_OW 69
119711: ST_TO_ADDR
// if not tmp then
119712: LD_VAR 0 2
119716: NOT
119717: IFFALSE 119721
// exit ;
119719: GO 119883
// un := tmp [ rand ( 1 , tmp ) ] ;
119721: LD_ADDR_VAR 0 3
119725: PUSH
119726: LD_VAR 0 2
119730: PUSH
119731: LD_INT 1
119733: PPUSH
119734: LD_VAR 0 2
119738: PPUSH
119739: CALL_OW 12
119743: ARRAY
119744: ST_TO_ADDR
// if Crawls ( un ) then
119745: LD_VAR 0 3
119749: PPUSH
119750: CALL_OW 318
119754: IFFALSE 119765
// ComWalk ( un ) ;
119756: LD_VAR 0 3
119760: PPUSH
119761: CALL_OW 138
// SetClass ( un , class_mortar ) ;
119765: LD_VAR 0 3
119769: PPUSH
119770: LD_INT 8
119772: PPUSH
119773: CALL_OW 336
// end ; 4 :
119777: GO 119883
119779: LD_INT 4
119781: DOUBLE
119782: EQUAL
119783: IFTRUE 119787
119785: GO 119861
119787: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
119788: LD_ADDR_VAR 0 2
119792: PUSH
119793: LD_INT 22
119795: PUSH
119796: LD_OWVAR 2
119800: PUSH
119801: EMPTY
119802: LIST
119803: LIST
119804: PUSH
119805: LD_INT 30
119807: PUSH
119808: LD_INT 29
119810: PUSH
119811: EMPTY
119812: LIST
119813: LIST
119814: PUSH
119815: EMPTY
119816: LIST
119817: LIST
119818: PPUSH
119819: CALL_OW 69
119823: ST_TO_ADDR
// if not tmp then
119824: LD_VAR 0 2
119828: NOT
119829: IFFALSE 119833
// exit ;
119831: GO 119883
// CenterNowOnUnits ( tmp [ 1 ] ) ;
119833: LD_VAR 0 2
119837: PUSH
119838: LD_INT 1
119840: ARRAY
119841: PPUSH
119842: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
119846: LD_VAR 0 2
119850: PUSH
119851: LD_INT 1
119853: ARRAY
119854: PPUSH
119855: CALL_OW 65
// end ; 5 .. 7 :
119859: GO 119883
119861: LD_INT 5
119863: DOUBLE
119864: GREATEREQUAL
119865: IFFALSE 119873
119867: LD_INT 7
119869: DOUBLE
119870: LESSEQUAL
119871: IFTRUE 119875
119873: GO 119882
119875: POP
// StreamSibBomb ; end ;
119876: CALL 116120 0 0
119880: GO 119883
119882: POP
// end ;
119883: PPOPN 3
119885: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
119886: LD_EXP 143
119890: PUSH
119891: LD_EXP 193
119895: AND
119896: IFFALSE 120052
119898: GO 119900
119900: DISABLE
119901: LD_INT 0
119903: PPUSH
119904: PPUSH
119905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
119906: LD_ADDR_VAR 0 2
119910: PUSH
119911: LD_INT 81
119913: PUSH
119914: LD_OWVAR 2
119918: PUSH
119919: EMPTY
119920: LIST
119921: LIST
119922: PUSH
119923: LD_INT 2
119925: PUSH
119926: LD_INT 21
119928: PUSH
119929: LD_INT 1
119931: PUSH
119932: EMPTY
119933: LIST
119934: LIST
119935: PUSH
119936: LD_INT 21
119938: PUSH
119939: LD_INT 2
119941: PUSH
119942: EMPTY
119943: LIST
119944: LIST
119945: PUSH
119946: EMPTY
119947: LIST
119948: LIST
119949: LIST
119950: PUSH
119951: EMPTY
119952: LIST
119953: LIST
119954: PPUSH
119955: CALL_OW 69
119959: ST_TO_ADDR
// if not tmp then
119960: LD_VAR 0 2
119964: NOT
119965: IFFALSE 119969
// exit ;
119967: GO 120052
// p := 0 ;
119969: LD_ADDR_VAR 0 3
119973: PUSH
119974: LD_INT 0
119976: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
119977: LD_INT 35
119979: PPUSH
119980: CALL_OW 67
// p := p + 1 ;
119984: LD_ADDR_VAR 0 3
119988: PUSH
119989: LD_VAR 0 3
119993: PUSH
119994: LD_INT 1
119996: PLUS
119997: ST_TO_ADDR
// for i in tmp do
119998: LD_ADDR_VAR 0 1
120002: PUSH
120003: LD_VAR 0 2
120007: PUSH
120008: FOR_IN
120009: IFFALSE 120040
// if GetLives ( i ) < 1000 then
120011: LD_VAR 0 1
120015: PPUSH
120016: CALL_OW 256
120020: PUSH
120021: LD_INT 1000
120023: LESS
120024: IFFALSE 120038
// SetLives ( i , 1000 ) ;
120026: LD_VAR 0 1
120030: PPUSH
120031: LD_INT 1000
120033: PPUSH
120034: CALL_OW 234
120038: GO 120008
120040: POP
120041: POP
// until p > 20 ;
120042: LD_VAR 0 3
120046: PUSH
120047: LD_INT 20
120049: GREATER
120050: IFFALSE 119977
// end ;
120052: PPOPN 3
120054: END
// every 0 0$1 trigger StreamModeActive and sTime do
120055: LD_EXP 143
120059: PUSH
120060: LD_EXP 194
120064: AND
120065: IFFALSE 120100
120067: GO 120069
120069: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
120070: LD_INT 28
120072: PPUSH
120073: LD_OWVAR 2
120077: PPUSH
120078: LD_INT 2
120080: PPUSH
120081: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
120085: LD_INT 30
120087: PPUSH
120088: LD_OWVAR 2
120092: PPUSH
120093: LD_INT 2
120095: PPUSH
120096: CALL_OW 322
// end ;
120100: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
120101: LD_EXP 143
120105: PUSH
120106: LD_EXP 195
120110: AND
120111: IFFALSE 120232
120113: GO 120115
120115: DISABLE
120116: LD_INT 0
120118: PPUSH
120119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
120120: LD_ADDR_VAR 0 2
120124: PUSH
120125: LD_INT 22
120127: PUSH
120128: LD_OWVAR 2
120132: PUSH
120133: EMPTY
120134: LIST
120135: LIST
120136: PUSH
120137: LD_INT 21
120139: PUSH
120140: LD_INT 1
120142: PUSH
120143: EMPTY
120144: LIST
120145: LIST
120146: PUSH
120147: LD_INT 3
120149: PUSH
120150: LD_INT 23
120152: PUSH
120153: LD_INT 0
120155: PUSH
120156: EMPTY
120157: LIST
120158: LIST
120159: PUSH
120160: EMPTY
120161: LIST
120162: LIST
120163: PUSH
120164: EMPTY
120165: LIST
120166: LIST
120167: LIST
120168: PPUSH
120169: CALL_OW 69
120173: ST_TO_ADDR
// if not tmp then
120174: LD_VAR 0 2
120178: NOT
120179: IFFALSE 120183
// exit ;
120181: GO 120232
// for i in tmp do
120183: LD_ADDR_VAR 0 1
120187: PUSH
120188: LD_VAR 0 2
120192: PUSH
120193: FOR_IN
120194: IFFALSE 120230
// begin if Crawls ( i ) then
120196: LD_VAR 0 1
120200: PPUSH
120201: CALL_OW 318
120205: IFFALSE 120216
// ComWalk ( i ) ;
120207: LD_VAR 0 1
120211: PPUSH
120212: CALL_OW 138
// SetClass ( i , 2 ) ;
120216: LD_VAR 0 1
120220: PPUSH
120221: LD_INT 2
120223: PPUSH
120224: CALL_OW 336
// end ;
120228: GO 120193
120230: POP
120231: POP
// end ;
120232: PPOPN 2
120234: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
120235: LD_EXP 143
120239: PUSH
120240: LD_EXP 196
120244: AND
120245: IFFALSE 120533
120247: GO 120249
120249: DISABLE
120250: LD_INT 0
120252: PPUSH
120253: PPUSH
120254: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
120255: LD_OWVAR 2
120259: PPUSH
120260: LD_INT 9
120262: PPUSH
120263: LD_INT 1
120265: PPUSH
120266: LD_INT 1
120268: PPUSH
120269: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
120273: LD_INT 9
120275: PPUSH
120276: LD_OWVAR 2
120280: PPUSH
120281: CALL_OW 343
// uc_side := 9 ;
120285: LD_ADDR_OWVAR 20
120289: PUSH
120290: LD_INT 9
120292: ST_TO_ADDR
// uc_nation := 2 ;
120293: LD_ADDR_OWVAR 21
120297: PUSH
120298: LD_INT 2
120300: ST_TO_ADDR
// hc_name := Dark Warrior ;
120301: LD_ADDR_OWVAR 26
120305: PUSH
120306: LD_STRING Dark Warrior
120308: ST_TO_ADDR
// hc_gallery :=  ;
120309: LD_ADDR_OWVAR 33
120313: PUSH
120314: LD_STRING 
120316: ST_TO_ADDR
// hc_noskilllimit := true ;
120317: LD_ADDR_OWVAR 76
120321: PUSH
120322: LD_INT 1
120324: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
120325: LD_ADDR_OWVAR 31
120329: PUSH
120330: LD_INT 30
120332: PUSH
120333: LD_INT 30
120335: PUSH
120336: LD_INT 30
120338: PUSH
120339: LD_INT 30
120341: PUSH
120342: EMPTY
120343: LIST
120344: LIST
120345: LIST
120346: LIST
120347: ST_TO_ADDR
// un := CreateHuman ;
120348: LD_ADDR_VAR 0 3
120352: PUSH
120353: CALL_OW 44
120357: ST_TO_ADDR
// hc_noskilllimit := false ;
120358: LD_ADDR_OWVAR 76
120362: PUSH
120363: LD_INT 0
120365: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120366: LD_VAR 0 3
120370: PPUSH
120371: LD_INT 1
120373: PPUSH
120374: CALL_OW 51
// ToLua ( playRanger() ) ;
120378: LD_STRING playRanger()
120380: PPUSH
120381: CALL_OW 559
// p := 0 ;
120385: LD_ADDR_VAR 0 2
120389: PUSH
120390: LD_INT 0
120392: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
120393: LD_INT 35
120395: PPUSH
120396: CALL_OW 67
// p := p + 1 ;
120400: LD_ADDR_VAR 0 2
120404: PUSH
120405: LD_VAR 0 2
120409: PUSH
120410: LD_INT 1
120412: PLUS
120413: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
120414: LD_VAR 0 3
120418: PPUSH
120419: CALL_OW 256
120423: PUSH
120424: LD_INT 1000
120426: LESS
120427: IFFALSE 120441
// SetLives ( un , 1000 ) ;
120429: LD_VAR 0 3
120433: PPUSH
120434: LD_INT 1000
120436: PPUSH
120437: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
120441: LD_VAR 0 3
120445: PPUSH
120446: LD_INT 81
120448: PUSH
120449: LD_OWVAR 2
120453: PUSH
120454: EMPTY
120455: LIST
120456: LIST
120457: PUSH
120458: LD_INT 91
120460: PUSH
120461: LD_VAR 0 3
120465: PUSH
120466: LD_INT 30
120468: PUSH
120469: EMPTY
120470: LIST
120471: LIST
120472: LIST
120473: PUSH
120474: EMPTY
120475: LIST
120476: LIST
120477: PPUSH
120478: CALL_OW 69
120482: PPUSH
120483: LD_VAR 0 3
120487: PPUSH
120488: CALL_OW 74
120492: PPUSH
120493: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
120497: LD_VAR 0 2
120501: PUSH
120502: LD_INT 80
120504: GREATER
120505: PUSH
120506: LD_VAR 0 3
120510: PPUSH
120511: CALL_OW 301
120515: OR
120516: IFFALSE 120393
// if un then
120518: LD_VAR 0 3
120522: IFFALSE 120533
// RemoveUnit ( un ) ;
120524: LD_VAR 0 3
120528: PPUSH
120529: CALL_OW 64
// end ;
120533: PPOPN 3
120535: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
120536: LD_EXP 197
120540: IFFALSE 120656
120542: GO 120544
120544: DISABLE
120545: LD_INT 0
120547: PPUSH
120548: PPUSH
120549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120550: LD_ADDR_VAR 0 2
120554: PUSH
120555: LD_INT 81
120557: PUSH
120558: LD_OWVAR 2
120562: PUSH
120563: EMPTY
120564: LIST
120565: LIST
120566: PUSH
120567: LD_INT 21
120569: PUSH
120570: LD_INT 1
120572: PUSH
120573: EMPTY
120574: LIST
120575: LIST
120576: PUSH
120577: EMPTY
120578: LIST
120579: LIST
120580: PPUSH
120581: CALL_OW 69
120585: ST_TO_ADDR
// ToLua ( playComputer() ) ;
120586: LD_STRING playComputer()
120588: PPUSH
120589: CALL_OW 559
// if not tmp then
120593: LD_VAR 0 2
120597: NOT
120598: IFFALSE 120602
// exit ;
120600: GO 120656
// for i in tmp do
120602: LD_ADDR_VAR 0 1
120606: PUSH
120607: LD_VAR 0 2
120611: PUSH
120612: FOR_IN
120613: IFFALSE 120654
// for j := 1 to 4 do
120615: LD_ADDR_VAR 0 3
120619: PUSH
120620: DOUBLE
120621: LD_INT 1
120623: DEC
120624: ST_TO_ADDR
120625: LD_INT 4
120627: PUSH
120628: FOR_TO
120629: IFFALSE 120650
// SetSkill ( i , j , 10 ) ;
120631: LD_VAR 0 1
120635: PPUSH
120636: LD_VAR 0 3
120640: PPUSH
120641: LD_INT 10
120643: PPUSH
120644: CALL_OW 237
120648: GO 120628
120650: POP
120651: POP
120652: GO 120612
120654: POP
120655: POP
// end ;
120656: PPOPN 3
120658: END
// every 0 0$1 trigger s30 do var i , tmp ;
120659: LD_EXP 198
120663: IFFALSE 120732
120665: GO 120667
120667: DISABLE
120668: LD_INT 0
120670: PPUSH
120671: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120672: LD_ADDR_VAR 0 2
120676: PUSH
120677: LD_INT 22
120679: PUSH
120680: LD_OWVAR 2
120684: PUSH
120685: EMPTY
120686: LIST
120687: LIST
120688: PPUSH
120689: CALL_OW 69
120693: ST_TO_ADDR
// if not tmp then
120694: LD_VAR 0 2
120698: NOT
120699: IFFALSE 120703
// exit ;
120701: GO 120732
// for i in tmp do
120703: LD_ADDR_VAR 0 1
120707: PUSH
120708: LD_VAR 0 2
120712: PUSH
120713: FOR_IN
120714: IFFALSE 120730
// SetLives ( i , 300 ) ;
120716: LD_VAR 0 1
120720: PPUSH
120721: LD_INT 300
120723: PPUSH
120724: CALL_OW 234
120728: GO 120713
120730: POP
120731: POP
// end ;
120732: PPOPN 2
120734: END
// every 0 0$1 trigger s60 do var i , tmp ;
120735: LD_EXP 199
120739: IFFALSE 120808
120741: GO 120743
120743: DISABLE
120744: LD_INT 0
120746: PPUSH
120747: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120748: LD_ADDR_VAR 0 2
120752: PUSH
120753: LD_INT 22
120755: PUSH
120756: LD_OWVAR 2
120760: PUSH
120761: EMPTY
120762: LIST
120763: LIST
120764: PPUSH
120765: CALL_OW 69
120769: ST_TO_ADDR
// if not tmp then
120770: LD_VAR 0 2
120774: NOT
120775: IFFALSE 120779
// exit ;
120777: GO 120808
// for i in tmp do
120779: LD_ADDR_VAR 0 1
120783: PUSH
120784: LD_VAR 0 2
120788: PUSH
120789: FOR_IN
120790: IFFALSE 120806
// SetLives ( i , 600 ) ;
120792: LD_VAR 0 1
120796: PPUSH
120797: LD_INT 600
120799: PPUSH
120800: CALL_OW 234
120804: GO 120789
120806: POP
120807: POP
// end ;
120808: PPOPN 2
120810: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
120811: LD_INT 0
120813: PPUSH
// case cmd of 301 :
120814: LD_VAR 0 1
120818: PUSH
120819: LD_INT 301
120821: DOUBLE
120822: EQUAL
120823: IFTRUE 120827
120825: GO 120859
120827: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
120828: LD_VAR 0 6
120832: PPUSH
120833: LD_VAR 0 7
120837: PPUSH
120838: LD_VAR 0 8
120842: PPUSH
120843: LD_VAR 0 4
120847: PPUSH
120848: LD_VAR 0 5
120852: PPUSH
120853: CALL 122060 0 5
120857: GO 120980
120859: LD_INT 302
120861: DOUBLE
120862: EQUAL
120863: IFTRUE 120867
120865: GO 120904
120867: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
120868: LD_VAR 0 6
120872: PPUSH
120873: LD_VAR 0 7
120877: PPUSH
120878: LD_VAR 0 8
120882: PPUSH
120883: LD_VAR 0 9
120887: PPUSH
120888: LD_VAR 0 4
120892: PPUSH
120893: LD_VAR 0 5
120897: PPUSH
120898: CALL 122151 0 6
120902: GO 120980
120904: LD_INT 303
120906: DOUBLE
120907: EQUAL
120908: IFTRUE 120912
120910: GO 120949
120912: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
120913: LD_VAR 0 6
120917: PPUSH
120918: LD_VAR 0 7
120922: PPUSH
120923: LD_VAR 0 8
120927: PPUSH
120928: LD_VAR 0 9
120932: PPUSH
120933: LD_VAR 0 4
120937: PPUSH
120938: LD_VAR 0 5
120942: PPUSH
120943: CALL 120985 0 6
120947: GO 120980
120949: LD_INT 304
120951: DOUBLE
120952: EQUAL
120953: IFTRUE 120957
120955: GO 120979
120957: POP
// hHackTeleport ( unit , x , y ) ; end ;
120958: LD_VAR 0 2
120962: PPUSH
120963: LD_VAR 0 4
120967: PPUSH
120968: LD_VAR 0 5
120972: PPUSH
120973: CALL 122744 0 3
120977: GO 120980
120979: POP
// end ;
120980: LD_VAR 0 12
120984: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
120985: LD_INT 0
120987: PPUSH
120988: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
120989: LD_VAR 0 1
120993: PUSH
120994: LD_INT 1
120996: LESS
120997: PUSH
120998: LD_VAR 0 1
121002: PUSH
121003: LD_INT 3
121005: GREATER
121006: OR
121007: PUSH
121008: LD_VAR 0 5
121012: PPUSH
121013: LD_VAR 0 6
121017: PPUSH
121018: CALL_OW 428
121022: OR
121023: IFFALSE 121027
// exit ;
121025: GO 121747
// uc_side := your_side ;
121027: LD_ADDR_OWVAR 20
121031: PUSH
121032: LD_OWVAR 2
121036: ST_TO_ADDR
// uc_nation := nation ;
121037: LD_ADDR_OWVAR 21
121041: PUSH
121042: LD_VAR 0 1
121046: ST_TO_ADDR
// bc_level = 1 ;
121047: LD_ADDR_OWVAR 43
121051: PUSH
121052: LD_INT 1
121054: ST_TO_ADDR
// case btype of 1 :
121055: LD_VAR 0 2
121059: PUSH
121060: LD_INT 1
121062: DOUBLE
121063: EQUAL
121064: IFTRUE 121068
121066: GO 121079
121068: POP
// bc_type := b_depot ; 2 :
121069: LD_ADDR_OWVAR 42
121073: PUSH
121074: LD_INT 0
121076: ST_TO_ADDR
121077: GO 121691
121079: LD_INT 2
121081: DOUBLE
121082: EQUAL
121083: IFTRUE 121087
121085: GO 121098
121087: POP
// bc_type := b_warehouse ; 3 :
121088: LD_ADDR_OWVAR 42
121092: PUSH
121093: LD_INT 1
121095: ST_TO_ADDR
121096: GO 121691
121098: LD_INT 3
121100: DOUBLE
121101: EQUAL
121102: IFTRUE 121106
121104: GO 121117
121106: POP
// bc_type := b_lab ; 4 .. 9 :
121107: LD_ADDR_OWVAR 42
121111: PUSH
121112: LD_INT 6
121114: ST_TO_ADDR
121115: GO 121691
121117: LD_INT 4
121119: DOUBLE
121120: GREATEREQUAL
121121: IFFALSE 121129
121123: LD_INT 9
121125: DOUBLE
121126: LESSEQUAL
121127: IFTRUE 121131
121129: GO 121183
121131: POP
// begin bc_type := b_lab_half ;
121132: LD_ADDR_OWVAR 42
121136: PUSH
121137: LD_INT 7
121139: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
121140: LD_ADDR_OWVAR 44
121144: PUSH
121145: LD_INT 10
121147: PUSH
121148: LD_INT 11
121150: PUSH
121151: LD_INT 12
121153: PUSH
121154: LD_INT 15
121156: PUSH
121157: LD_INT 14
121159: PUSH
121160: LD_INT 13
121162: PUSH
121163: EMPTY
121164: LIST
121165: LIST
121166: LIST
121167: LIST
121168: LIST
121169: LIST
121170: PUSH
121171: LD_VAR 0 2
121175: PUSH
121176: LD_INT 3
121178: MINUS
121179: ARRAY
121180: ST_TO_ADDR
// end ; 10 .. 13 :
121181: GO 121691
121183: LD_INT 10
121185: DOUBLE
121186: GREATEREQUAL
121187: IFFALSE 121195
121189: LD_INT 13
121191: DOUBLE
121192: LESSEQUAL
121193: IFTRUE 121197
121195: GO 121274
121197: POP
// begin bc_type := b_lab_full ;
121198: LD_ADDR_OWVAR 42
121202: PUSH
121203: LD_INT 8
121205: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
121206: LD_ADDR_OWVAR 44
121210: PUSH
121211: LD_INT 10
121213: PUSH
121214: LD_INT 12
121216: PUSH
121217: LD_INT 14
121219: PUSH
121220: LD_INT 13
121222: PUSH
121223: EMPTY
121224: LIST
121225: LIST
121226: LIST
121227: LIST
121228: PUSH
121229: LD_VAR 0 2
121233: PUSH
121234: LD_INT 9
121236: MINUS
121237: ARRAY
121238: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
121239: LD_ADDR_OWVAR 45
121243: PUSH
121244: LD_INT 11
121246: PUSH
121247: LD_INT 15
121249: PUSH
121250: LD_INT 12
121252: PUSH
121253: LD_INT 15
121255: PUSH
121256: EMPTY
121257: LIST
121258: LIST
121259: LIST
121260: LIST
121261: PUSH
121262: LD_VAR 0 2
121266: PUSH
121267: LD_INT 9
121269: MINUS
121270: ARRAY
121271: ST_TO_ADDR
// end ; 14 :
121272: GO 121691
121274: LD_INT 14
121276: DOUBLE
121277: EQUAL
121278: IFTRUE 121282
121280: GO 121293
121282: POP
// bc_type := b_workshop ; 15 :
121283: LD_ADDR_OWVAR 42
121287: PUSH
121288: LD_INT 2
121290: ST_TO_ADDR
121291: GO 121691
121293: LD_INT 15
121295: DOUBLE
121296: EQUAL
121297: IFTRUE 121301
121299: GO 121312
121301: POP
// bc_type := b_factory ; 16 :
121302: LD_ADDR_OWVAR 42
121306: PUSH
121307: LD_INT 3
121309: ST_TO_ADDR
121310: GO 121691
121312: LD_INT 16
121314: DOUBLE
121315: EQUAL
121316: IFTRUE 121320
121318: GO 121331
121320: POP
// bc_type := b_ext_gun ; 17 :
121321: LD_ADDR_OWVAR 42
121325: PUSH
121326: LD_INT 17
121328: ST_TO_ADDR
121329: GO 121691
121331: LD_INT 17
121333: DOUBLE
121334: EQUAL
121335: IFTRUE 121339
121337: GO 121367
121339: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
121340: LD_ADDR_OWVAR 42
121344: PUSH
121345: LD_INT 19
121347: PUSH
121348: LD_INT 23
121350: PUSH
121351: LD_INT 19
121353: PUSH
121354: EMPTY
121355: LIST
121356: LIST
121357: LIST
121358: PUSH
121359: LD_VAR 0 1
121363: ARRAY
121364: ST_TO_ADDR
121365: GO 121691
121367: LD_INT 18
121369: DOUBLE
121370: EQUAL
121371: IFTRUE 121375
121373: GO 121386
121375: POP
// bc_type := b_ext_radar ; 19 :
121376: LD_ADDR_OWVAR 42
121380: PUSH
121381: LD_INT 20
121383: ST_TO_ADDR
121384: GO 121691
121386: LD_INT 19
121388: DOUBLE
121389: EQUAL
121390: IFTRUE 121394
121392: GO 121405
121394: POP
// bc_type := b_ext_radio ; 20 :
121395: LD_ADDR_OWVAR 42
121399: PUSH
121400: LD_INT 22
121402: ST_TO_ADDR
121403: GO 121691
121405: LD_INT 20
121407: DOUBLE
121408: EQUAL
121409: IFTRUE 121413
121411: GO 121424
121413: POP
// bc_type := b_ext_siberium ; 21 :
121414: LD_ADDR_OWVAR 42
121418: PUSH
121419: LD_INT 21
121421: ST_TO_ADDR
121422: GO 121691
121424: LD_INT 21
121426: DOUBLE
121427: EQUAL
121428: IFTRUE 121432
121430: GO 121443
121432: POP
// bc_type := b_ext_computer ; 22 :
121433: LD_ADDR_OWVAR 42
121437: PUSH
121438: LD_INT 24
121440: ST_TO_ADDR
121441: GO 121691
121443: LD_INT 22
121445: DOUBLE
121446: EQUAL
121447: IFTRUE 121451
121449: GO 121462
121451: POP
// bc_type := b_ext_track ; 23 :
121452: LD_ADDR_OWVAR 42
121456: PUSH
121457: LD_INT 16
121459: ST_TO_ADDR
121460: GO 121691
121462: LD_INT 23
121464: DOUBLE
121465: EQUAL
121466: IFTRUE 121470
121468: GO 121481
121470: POP
// bc_type := b_ext_laser ; 24 :
121471: LD_ADDR_OWVAR 42
121475: PUSH
121476: LD_INT 25
121478: ST_TO_ADDR
121479: GO 121691
121481: LD_INT 24
121483: DOUBLE
121484: EQUAL
121485: IFTRUE 121489
121487: GO 121500
121489: POP
// bc_type := b_control_tower ; 25 :
121490: LD_ADDR_OWVAR 42
121494: PUSH
121495: LD_INT 36
121497: ST_TO_ADDR
121498: GO 121691
121500: LD_INT 25
121502: DOUBLE
121503: EQUAL
121504: IFTRUE 121508
121506: GO 121519
121508: POP
// bc_type := b_breastwork ; 26 :
121509: LD_ADDR_OWVAR 42
121513: PUSH
121514: LD_INT 31
121516: ST_TO_ADDR
121517: GO 121691
121519: LD_INT 26
121521: DOUBLE
121522: EQUAL
121523: IFTRUE 121527
121525: GO 121538
121527: POP
// bc_type := b_bunker ; 27 :
121528: LD_ADDR_OWVAR 42
121532: PUSH
121533: LD_INT 32
121535: ST_TO_ADDR
121536: GO 121691
121538: LD_INT 27
121540: DOUBLE
121541: EQUAL
121542: IFTRUE 121546
121544: GO 121557
121546: POP
// bc_type := b_turret ; 28 :
121547: LD_ADDR_OWVAR 42
121551: PUSH
121552: LD_INT 33
121554: ST_TO_ADDR
121555: GO 121691
121557: LD_INT 28
121559: DOUBLE
121560: EQUAL
121561: IFTRUE 121565
121563: GO 121576
121565: POP
// bc_type := b_armoury ; 29 :
121566: LD_ADDR_OWVAR 42
121570: PUSH
121571: LD_INT 4
121573: ST_TO_ADDR
121574: GO 121691
121576: LD_INT 29
121578: DOUBLE
121579: EQUAL
121580: IFTRUE 121584
121582: GO 121595
121584: POP
// bc_type := b_barracks ; 30 :
121585: LD_ADDR_OWVAR 42
121589: PUSH
121590: LD_INT 5
121592: ST_TO_ADDR
121593: GO 121691
121595: LD_INT 30
121597: DOUBLE
121598: EQUAL
121599: IFTRUE 121603
121601: GO 121614
121603: POP
// bc_type := b_solar_power ; 31 :
121604: LD_ADDR_OWVAR 42
121608: PUSH
121609: LD_INT 27
121611: ST_TO_ADDR
121612: GO 121691
121614: LD_INT 31
121616: DOUBLE
121617: EQUAL
121618: IFTRUE 121622
121620: GO 121633
121622: POP
// bc_type := b_oil_power ; 32 :
121623: LD_ADDR_OWVAR 42
121627: PUSH
121628: LD_INT 26
121630: ST_TO_ADDR
121631: GO 121691
121633: LD_INT 32
121635: DOUBLE
121636: EQUAL
121637: IFTRUE 121641
121639: GO 121652
121641: POP
// bc_type := b_siberite_power ; 33 :
121642: LD_ADDR_OWVAR 42
121646: PUSH
121647: LD_INT 28
121649: ST_TO_ADDR
121650: GO 121691
121652: LD_INT 33
121654: DOUBLE
121655: EQUAL
121656: IFTRUE 121660
121658: GO 121671
121660: POP
// bc_type := b_oil_mine ; 34 :
121661: LD_ADDR_OWVAR 42
121665: PUSH
121666: LD_INT 29
121668: ST_TO_ADDR
121669: GO 121691
121671: LD_INT 34
121673: DOUBLE
121674: EQUAL
121675: IFTRUE 121679
121677: GO 121690
121679: POP
// bc_type := b_siberite_mine ; end ;
121680: LD_ADDR_OWVAR 42
121684: PUSH
121685: LD_INT 30
121687: ST_TO_ADDR
121688: GO 121691
121690: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
121691: LD_ADDR_VAR 0 8
121695: PUSH
121696: LD_VAR 0 5
121700: PPUSH
121701: LD_VAR 0 6
121705: PPUSH
121706: LD_VAR 0 3
121710: PPUSH
121711: CALL_OW 47
121715: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
121716: LD_OWVAR 42
121720: PUSH
121721: LD_INT 32
121723: PUSH
121724: LD_INT 33
121726: PUSH
121727: EMPTY
121728: LIST
121729: LIST
121730: IN
121731: IFFALSE 121747
// PlaceWeaponTurret ( b , weapon ) ;
121733: LD_VAR 0 8
121737: PPUSH
121738: LD_VAR 0 4
121742: PPUSH
121743: CALL_OW 431
// end ;
121747: LD_VAR 0 7
121751: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
121752: LD_INT 0
121754: PPUSH
121755: PPUSH
121756: PPUSH
121757: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
121758: LD_ADDR_VAR 0 4
121762: PUSH
121763: LD_INT 22
121765: PUSH
121766: LD_OWVAR 2
121770: PUSH
121771: EMPTY
121772: LIST
121773: LIST
121774: PUSH
121775: LD_INT 2
121777: PUSH
121778: LD_INT 30
121780: PUSH
121781: LD_INT 0
121783: PUSH
121784: EMPTY
121785: LIST
121786: LIST
121787: PUSH
121788: LD_INT 30
121790: PUSH
121791: LD_INT 1
121793: PUSH
121794: EMPTY
121795: LIST
121796: LIST
121797: PUSH
121798: EMPTY
121799: LIST
121800: LIST
121801: LIST
121802: PUSH
121803: EMPTY
121804: LIST
121805: LIST
121806: PPUSH
121807: CALL_OW 69
121811: ST_TO_ADDR
// if not tmp then
121812: LD_VAR 0 4
121816: NOT
121817: IFFALSE 121821
// exit ;
121819: GO 121880
// for i in tmp do
121821: LD_ADDR_VAR 0 2
121825: PUSH
121826: LD_VAR 0 4
121830: PUSH
121831: FOR_IN
121832: IFFALSE 121878
// for j = 1 to 3 do
121834: LD_ADDR_VAR 0 3
121838: PUSH
121839: DOUBLE
121840: LD_INT 1
121842: DEC
121843: ST_TO_ADDR
121844: LD_INT 3
121846: PUSH
121847: FOR_TO
121848: IFFALSE 121874
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
121850: LD_VAR 0 2
121854: PPUSH
121855: CALL_OW 274
121859: PPUSH
121860: LD_VAR 0 3
121864: PPUSH
121865: LD_INT 99999
121867: PPUSH
121868: CALL_OW 277
121872: GO 121847
121874: POP
121875: POP
121876: GO 121831
121878: POP
121879: POP
// end ;
121880: LD_VAR 0 1
121884: RET
// export function hHackSetLevel10 ; var i , j ; begin
121885: LD_INT 0
121887: PPUSH
121888: PPUSH
121889: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
121890: LD_ADDR_VAR 0 2
121894: PUSH
121895: LD_INT 21
121897: PUSH
121898: LD_INT 1
121900: PUSH
121901: EMPTY
121902: LIST
121903: LIST
121904: PPUSH
121905: CALL_OW 69
121909: PUSH
121910: FOR_IN
121911: IFFALSE 121963
// if IsSelected ( i ) then
121913: LD_VAR 0 2
121917: PPUSH
121918: CALL_OW 306
121922: IFFALSE 121961
// begin for j := 1 to 4 do
121924: LD_ADDR_VAR 0 3
121928: PUSH
121929: DOUBLE
121930: LD_INT 1
121932: DEC
121933: ST_TO_ADDR
121934: LD_INT 4
121936: PUSH
121937: FOR_TO
121938: IFFALSE 121959
// SetSkill ( i , j , 10 ) ;
121940: LD_VAR 0 2
121944: PPUSH
121945: LD_VAR 0 3
121949: PPUSH
121950: LD_INT 10
121952: PPUSH
121953: CALL_OW 237
121957: GO 121937
121959: POP
121960: POP
// end ;
121961: GO 121910
121963: POP
121964: POP
// end ;
121965: LD_VAR 0 1
121969: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
121970: LD_INT 0
121972: PPUSH
121973: PPUSH
121974: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
121975: LD_ADDR_VAR 0 2
121979: PUSH
121980: LD_INT 22
121982: PUSH
121983: LD_OWVAR 2
121987: PUSH
121988: EMPTY
121989: LIST
121990: LIST
121991: PUSH
121992: LD_INT 21
121994: PUSH
121995: LD_INT 1
121997: PUSH
121998: EMPTY
121999: LIST
122000: LIST
122001: PUSH
122002: EMPTY
122003: LIST
122004: LIST
122005: PPUSH
122006: CALL_OW 69
122010: PUSH
122011: FOR_IN
122012: IFFALSE 122053
// begin for j := 1 to 4 do
122014: LD_ADDR_VAR 0 3
122018: PUSH
122019: DOUBLE
122020: LD_INT 1
122022: DEC
122023: ST_TO_ADDR
122024: LD_INT 4
122026: PUSH
122027: FOR_TO
122028: IFFALSE 122049
// SetSkill ( i , j , 10 ) ;
122030: LD_VAR 0 2
122034: PPUSH
122035: LD_VAR 0 3
122039: PPUSH
122040: LD_INT 10
122042: PPUSH
122043: CALL_OW 237
122047: GO 122027
122049: POP
122050: POP
// end ;
122051: GO 122011
122053: POP
122054: POP
// end ;
122055: LD_VAR 0 1
122059: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
122060: LD_INT 0
122062: PPUSH
// uc_side := your_side ;
122063: LD_ADDR_OWVAR 20
122067: PUSH
122068: LD_OWVAR 2
122072: ST_TO_ADDR
// uc_nation := nation ;
122073: LD_ADDR_OWVAR 21
122077: PUSH
122078: LD_VAR 0 1
122082: ST_TO_ADDR
// InitHc ;
122083: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
122087: LD_INT 0
122089: PPUSH
122090: LD_VAR 0 2
122094: PPUSH
122095: LD_VAR 0 3
122099: PPUSH
122100: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
122104: LD_VAR 0 4
122108: PPUSH
122109: LD_VAR 0 5
122113: PPUSH
122114: CALL_OW 428
122118: PUSH
122119: LD_INT 0
122121: EQUAL
122122: IFFALSE 122146
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
122124: CALL_OW 44
122128: PPUSH
122129: LD_VAR 0 4
122133: PPUSH
122134: LD_VAR 0 5
122138: PPUSH
122139: LD_INT 1
122141: PPUSH
122142: CALL_OW 48
// end ;
122146: LD_VAR 0 6
122150: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
122151: LD_INT 0
122153: PPUSH
122154: PPUSH
// uc_side := your_side ;
122155: LD_ADDR_OWVAR 20
122159: PUSH
122160: LD_OWVAR 2
122164: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
122165: LD_VAR 0 1
122169: PUSH
122170: LD_INT 1
122172: PUSH
122173: LD_INT 2
122175: PUSH
122176: LD_INT 3
122178: PUSH
122179: LD_INT 4
122181: PUSH
122182: LD_INT 5
122184: PUSH
122185: EMPTY
122186: LIST
122187: LIST
122188: LIST
122189: LIST
122190: LIST
122191: IN
122192: IFFALSE 122204
// uc_nation := nation_american else
122194: LD_ADDR_OWVAR 21
122198: PUSH
122199: LD_INT 1
122201: ST_TO_ADDR
122202: GO 122247
// if chassis in [ 11 , 12 , 13 , 14 ] then
122204: LD_VAR 0 1
122208: PUSH
122209: LD_INT 11
122211: PUSH
122212: LD_INT 12
122214: PUSH
122215: LD_INT 13
122217: PUSH
122218: LD_INT 14
122220: PUSH
122221: EMPTY
122222: LIST
122223: LIST
122224: LIST
122225: LIST
122226: IN
122227: IFFALSE 122239
// uc_nation := nation_arabian else
122229: LD_ADDR_OWVAR 21
122233: PUSH
122234: LD_INT 2
122236: ST_TO_ADDR
122237: GO 122247
// uc_nation := nation_russian ;
122239: LD_ADDR_OWVAR 21
122243: PUSH
122244: LD_INT 3
122246: ST_TO_ADDR
// vc_chassis := chassis ;
122247: LD_ADDR_OWVAR 37
122251: PUSH
122252: LD_VAR 0 1
122256: ST_TO_ADDR
// vc_engine := engine ;
122257: LD_ADDR_OWVAR 39
122261: PUSH
122262: LD_VAR 0 2
122266: ST_TO_ADDR
// vc_control := control ;
122267: LD_ADDR_OWVAR 38
122271: PUSH
122272: LD_VAR 0 3
122276: ST_TO_ADDR
// vc_weapon := weapon ;
122277: LD_ADDR_OWVAR 40
122281: PUSH
122282: LD_VAR 0 4
122286: ST_TO_ADDR
// un := CreateVehicle ;
122287: LD_ADDR_VAR 0 8
122291: PUSH
122292: CALL_OW 45
122296: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
122297: LD_VAR 0 8
122301: PPUSH
122302: LD_INT 0
122304: PPUSH
122305: LD_INT 5
122307: PPUSH
122308: CALL_OW 12
122312: PPUSH
122313: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
122317: LD_VAR 0 8
122321: PPUSH
122322: LD_VAR 0 5
122326: PPUSH
122327: LD_VAR 0 6
122331: PPUSH
122332: LD_INT 1
122334: PPUSH
122335: CALL_OW 48
// end ;
122339: LD_VAR 0 7
122343: RET
// export hInvincible ; every 1 do
122344: GO 122346
122346: DISABLE
// hInvincible := [ ] ;
122347: LD_ADDR_EXP 200
122351: PUSH
122352: EMPTY
122353: ST_TO_ADDR
122354: END
// every 10 do var i ;
122355: GO 122357
122357: DISABLE
122358: LD_INT 0
122360: PPUSH
// begin enable ;
122361: ENABLE
// if not hInvincible then
122362: LD_EXP 200
122366: NOT
122367: IFFALSE 122371
// exit ;
122369: GO 122415
// for i in hInvincible do
122371: LD_ADDR_VAR 0 1
122375: PUSH
122376: LD_EXP 200
122380: PUSH
122381: FOR_IN
122382: IFFALSE 122413
// if GetLives ( i ) < 1000 then
122384: LD_VAR 0 1
122388: PPUSH
122389: CALL_OW 256
122393: PUSH
122394: LD_INT 1000
122396: LESS
122397: IFFALSE 122411
// SetLives ( i , 1000 ) ;
122399: LD_VAR 0 1
122403: PPUSH
122404: LD_INT 1000
122406: PPUSH
122407: CALL_OW 234
122411: GO 122381
122413: POP
122414: POP
// end ;
122415: PPOPN 1
122417: END
// export function hHackInvincible ; var i ; begin
122418: LD_INT 0
122420: PPUSH
122421: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
122422: LD_ADDR_VAR 0 2
122426: PUSH
122427: LD_INT 2
122429: PUSH
122430: LD_INT 21
122432: PUSH
122433: LD_INT 1
122435: PUSH
122436: EMPTY
122437: LIST
122438: LIST
122439: PUSH
122440: LD_INT 21
122442: PUSH
122443: LD_INT 2
122445: PUSH
122446: EMPTY
122447: LIST
122448: LIST
122449: PUSH
122450: EMPTY
122451: LIST
122452: LIST
122453: LIST
122454: PPUSH
122455: CALL_OW 69
122459: PUSH
122460: FOR_IN
122461: IFFALSE 122522
// if IsSelected ( i ) then
122463: LD_VAR 0 2
122467: PPUSH
122468: CALL_OW 306
122472: IFFALSE 122520
// begin if i in hInvincible then
122474: LD_VAR 0 2
122478: PUSH
122479: LD_EXP 200
122483: IN
122484: IFFALSE 122504
// hInvincible := hInvincible diff i else
122486: LD_ADDR_EXP 200
122490: PUSH
122491: LD_EXP 200
122495: PUSH
122496: LD_VAR 0 2
122500: DIFF
122501: ST_TO_ADDR
122502: GO 122520
// hInvincible := hInvincible union i ;
122504: LD_ADDR_EXP 200
122508: PUSH
122509: LD_EXP 200
122513: PUSH
122514: LD_VAR 0 2
122518: UNION
122519: ST_TO_ADDR
// end ;
122520: GO 122460
122522: POP
122523: POP
// end ;
122524: LD_VAR 0 1
122528: RET
// export function hHackInvisible ; var i , j ; begin
122529: LD_INT 0
122531: PPUSH
122532: PPUSH
122533: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
122534: LD_ADDR_VAR 0 2
122538: PUSH
122539: LD_INT 21
122541: PUSH
122542: LD_INT 1
122544: PUSH
122545: EMPTY
122546: LIST
122547: LIST
122548: PPUSH
122549: CALL_OW 69
122553: PUSH
122554: FOR_IN
122555: IFFALSE 122579
// if IsSelected ( i ) then
122557: LD_VAR 0 2
122561: PPUSH
122562: CALL_OW 306
122566: IFFALSE 122577
// ComForceInvisible ( i ) ;
122568: LD_VAR 0 2
122572: PPUSH
122573: CALL_OW 496
122577: GO 122554
122579: POP
122580: POP
// end ;
122581: LD_VAR 0 1
122585: RET
// export function hHackChangeYourSide ; begin
122586: LD_INT 0
122588: PPUSH
// if your_side = 8 then
122589: LD_OWVAR 2
122593: PUSH
122594: LD_INT 8
122596: EQUAL
122597: IFFALSE 122609
// your_side := 0 else
122599: LD_ADDR_OWVAR 2
122603: PUSH
122604: LD_INT 0
122606: ST_TO_ADDR
122607: GO 122623
// your_side := your_side + 1 ;
122609: LD_ADDR_OWVAR 2
122613: PUSH
122614: LD_OWVAR 2
122618: PUSH
122619: LD_INT 1
122621: PLUS
122622: ST_TO_ADDR
// end ;
122623: LD_VAR 0 1
122627: RET
// export function hHackChangeUnitSide ; var i , j ; begin
122628: LD_INT 0
122630: PPUSH
122631: PPUSH
122632: PPUSH
// for i in all_units do
122633: LD_ADDR_VAR 0 2
122637: PUSH
122638: LD_OWVAR 3
122642: PUSH
122643: FOR_IN
122644: IFFALSE 122722
// if IsSelected ( i ) then
122646: LD_VAR 0 2
122650: PPUSH
122651: CALL_OW 306
122655: IFFALSE 122720
// begin j := GetSide ( i ) ;
122657: LD_ADDR_VAR 0 3
122661: PUSH
122662: LD_VAR 0 2
122666: PPUSH
122667: CALL_OW 255
122671: ST_TO_ADDR
// if j = 8 then
122672: LD_VAR 0 3
122676: PUSH
122677: LD_INT 8
122679: EQUAL
122680: IFFALSE 122692
// j := 0 else
122682: LD_ADDR_VAR 0 3
122686: PUSH
122687: LD_INT 0
122689: ST_TO_ADDR
122690: GO 122706
// j := j + 1 ;
122692: LD_ADDR_VAR 0 3
122696: PUSH
122697: LD_VAR 0 3
122701: PUSH
122702: LD_INT 1
122704: PLUS
122705: ST_TO_ADDR
// SetSide ( i , j ) ;
122706: LD_VAR 0 2
122710: PPUSH
122711: LD_VAR 0 3
122715: PPUSH
122716: CALL_OW 235
// end ;
122720: GO 122643
122722: POP
122723: POP
// end ;
122724: LD_VAR 0 1
122728: RET
// export function hHackFog ; begin
122729: LD_INT 0
122731: PPUSH
// FogOff ( true ) ;
122732: LD_INT 1
122734: PPUSH
122735: CALL_OW 344
// end ;
122739: LD_VAR 0 1
122743: RET
// export function hHackTeleport ( unit , x , y ) ; begin
122744: LD_INT 0
122746: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
122747: LD_VAR 0 1
122751: PPUSH
122752: LD_VAR 0 2
122756: PPUSH
122757: LD_VAR 0 3
122761: PPUSH
122762: LD_INT 1
122764: PPUSH
122765: LD_INT 1
122767: PPUSH
122768: CALL_OW 483
// CenterOnXY ( x , y ) ;
122772: LD_VAR 0 2
122776: PPUSH
122777: LD_VAR 0 3
122781: PPUSH
122782: CALL_OW 84
// end ;
122786: LD_VAR 0 4
122790: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
122791: LD_INT 0
122793: PPUSH
122794: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
122795: LD_VAR 0 1
122799: NOT
122800: PUSH
122801: LD_VAR 0 2
122805: PPUSH
122806: LD_VAR 0 3
122810: PPUSH
122811: CALL_OW 488
122815: NOT
122816: OR
122817: PUSH
122818: LD_VAR 0 1
122822: PPUSH
122823: CALL_OW 266
122827: PUSH
122828: LD_INT 3
122830: NONEQUAL
122831: PUSH
122832: LD_VAR 0 1
122836: PPUSH
122837: CALL_OW 247
122841: PUSH
122842: LD_INT 1
122844: EQUAL
122845: NOT
122846: AND
122847: OR
122848: IFFALSE 122852
// exit ;
122850: GO 123001
// if GetType ( factory ) = unit_human then
122852: LD_VAR 0 1
122856: PPUSH
122857: CALL_OW 247
122861: PUSH
122862: LD_INT 1
122864: EQUAL
122865: IFFALSE 122882
// factory := IsInUnit ( factory ) ;
122867: LD_ADDR_VAR 0 1
122871: PUSH
122872: LD_VAR 0 1
122876: PPUSH
122877: CALL_OW 310
122881: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
122882: LD_VAR 0 1
122886: PPUSH
122887: CALL_OW 266
122891: PUSH
122892: LD_INT 3
122894: NONEQUAL
122895: IFFALSE 122899
// exit ;
122897: GO 123001
// if HexInfo ( x , y ) = factory then
122899: LD_VAR 0 2
122903: PPUSH
122904: LD_VAR 0 3
122908: PPUSH
122909: CALL_OW 428
122913: PUSH
122914: LD_VAR 0 1
122918: EQUAL
122919: IFFALSE 122946
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
122921: LD_ADDR_EXP 201
122925: PUSH
122926: LD_EXP 201
122930: PPUSH
122931: LD_VAR 0 1
122935: PPUSH
122936: LD_INT 0
122938: PPUSH
122939: CALL_OW 1
122943: ST_TO_ADDR
122944: GO 122997
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
122946: LD_ADDR_EXP 201
122950: PUSH
122951: LD_EXP 201
122955: PPUSH
122956: LD_VAR 0 1
122960: PPUSH
122961: LD_VAR 0 1
122965: PPUSH
122966: CALL_OW 255
122970: PUSH
122971: LD_VAR 0 1
122975: PUSH
122976: LD_VAR 0 2
122980: PUSH
122981: LD_VAR 0 3
122985: PUSH
122986: EMPTY
122987: LIST
122988: LIST
122989: LIST
122990: LIST
122991: PPUSH
122992: CALL_OW 1
122996: ST_TO_ADDR
// UpdateFactoryWaypoints ;
122997: CALL 123006 0 0
// end ;
123001: LD_VAR 0 4
123005: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
123006: LD_INT 0
123008: PPUSH
123009: PPUSH
123010: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
123011: LD_STRING resetFactoryWaypoint();
123013: PPUSH
123014: CALL_OW 559
// if factoryWaypoints then
123018: LD_EXP 201
123022: IFFALSE 123148
// begin list := PrepareArray ( factoryWaypoints ) ;
123024: LD_ADDR_VAR 0 3
123028: PUSH
123029: LD_EXP 201
123033: PPUSH
123034: CALL 108402 0 1
123038: ST_TO_ADDR
// for i := 1 to list do
123039: LD_ADDR_VAR 0 2
123043: PUSH
123044: DOUBLE
123045: LD_INT 1
123047: DEC
123048: ST_TO_ADDR
123049: LD_VAR 0 3
123053: PUSH
123054: FOR_TO
123055: IFFALSE 123146
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123057: LD_STRING setFactoryWaypointXY(
123059: PUSH
123060: LD_VAR 0 3
123064: PUSH
123065: LD_VAR 0 2
123069: ARRAY
123070: PUSH
123071: LD_INT 1
123073: ARRAY
123074: STR
123075: PUSH
123076: LD_STRING ,
123078: STR
123079: PUSH
123080: LD_VAR 0 3
123084: PUSH
123085: LD_VAR 0 2
123089: ARRAY
123090: PUSH
123091: LD_INT 2
123093: ARRAY
123094: STR
123095: PUSH
123096: LD_STRING ,
123098: STR
123099: PUSH
123100: LD_VAR 0 3
123104: PUSH
123105: LD_VAR 0 2
123109: ARRAY
123110: PUSH
123111: LD_INT 3
123113: ARRAY
123114: STR
123115: PUSH
123116: LD_STRING ,
123118: STR
123119: PUSH
123120: LD_VAR 0 3
123124: PUSH
123125: LD_VAR 0 2
123129: ARRAY
123130: PUSH
123131: LD_INT 4
123133: ARRAY
123134: STR
123135: PUSH
123136: LD_STRING )
123138: STR
123139: PPUSH
123140: CALL_OW 559
123144: GO 123054
123146: POP
123147: POP
// end ; end ;
123148: LD_VAR 0 1
123152: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
123153: LD_INT 0
123155: PPUSH
// if HexInfo ( x , y ) = warehouse then
123156: LD_VAR 0 2
123160: PPUSH
123161: LD_VAR 0 3
123165: PPUSH
123166: CALL_OW 428
123170: PUSH
123171: LD_VAR 0 1
123175: EQUAL
123176: IFFALSE 123203
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
123178: LD_ADDR_EXP 202
123182: PUSH
123183: LD_EXP 202
123187: PPUSH
123188: LD_VAR 0 1
123192: PPUSH
123193: LD_INT 0
123195: PPUSH
123196: CALL_OW 1
123200: ST_TO_ADDR
123201: GO 123254
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
123203: LD_ADDR_EXP 202
123207: PUSH
123208: LD_EXP 202
123212: PPUSH
123213: LD_VAR 0 1
123217: PPUSH
123218: LD_VAR 0 1
123222: PPUSH
123223: CALL_OW 255
123227: PUSH
123228: LD_VAR 0 1
123232: PUSH
123233: LD_VAR 0 2
123237: PUSH
123238: LD_VAR 0 3
123242: PUSH
123243: EMPTY
123244: LIST
123245: LIST
123246: LIST
123247: LIST
123248: PPUSH
123249: CALL_OW 1
123253: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
123254: CALL 123263 0 0
// end ;
123258: LD_VAR 0 4
123262: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
123263: LD_INT 0
123265: PPUSH
123266: PPUSH
123267: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
123268: LD_STRING resetWarehouseGatheringPoints();
123270: PPUSH
123271: CALL_OW 559
// if warehouseGatheringPoints then
123275: LD_EXP 202
123279: IFFALSE 123405
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
123281: LD_ADDR_VAR 0 3
123285: PUSH
123286: LD_EXP 202
123290: PPUSH
123291: CALL 108402 0 1
123295: ST_TO_ADDR
// for i := 1 to list do
123296: LD_ADDR_VAR 0 2
123300: PUSH
123301: DOUBLE
123302: LD_INT 1
123304: DEC
123305: ST_TO_ADDR
123306: LD_VAR 0 3
123310: PUSH
123311: FOR_TO
123312: IFFALSE 123403
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
123314: LD_STRING setWarehouseGatheringPointXY(
123316: PUSH
123317: LD_VAR 0 3
123321: PUSH
123322: LD_VAR 0 2
123326: ARRAY
123327: PUSH
123328: LD_INT 1
123330: ARRAY
123331: STR
123332: PUSH
123333: LD_STRING ,
123335: STR
123336: PUSH
123337: LD_VAR 0 3
123341: PUSH
123342: LD_VAR 0 2
123346: ARRAY
123347: PUSH
123348: LD_INT 2
123350: ARRAY
123351: STR
123352: PUSH
123353: LD_STRING ,
123355: STR
123356: PUSH
123357: LD_VAR 0 3
123361: PUSH
123362: LD_VAR 0 2
123366: ARRAY
123367: PUSH
123368: LD_INT 3
123370: ARRAY
123371: STR
123372: PUSH
123373: LD_STRING ,
123375: STR
123376: PUSH
123377: LD_VAR 0 3
123381: PUSH
123382: LD_VAR 0 2
123386: ARRAY
123387: PUSH
123388: LD_INT 4
123390: ARRAY
123391: STR
123392: PUSH
123393: LD_STRING )
123395: STR
123396: PPUSH
123397: CALL_OW 559
123401: GO 123311
123403: POP
123404: POP
// end ; end ;
123405: LD_VAR 0 1
123409: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
123410: LD_EXP 202
123414: IFFALSE 124099
123416: GO 123418
123418: DISABLE
123419: LD_INT 0
123421: PPUSH
123422: PPUSH
123423: PPUSH
123424: PPUSH
123425: PPUSH
123426: PPUSH
123427: PPUSH
123428: PPUSH
123429: PPUSH
// begin enable ;
123430: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
123431: LD_ADDR_VAR 0 3
123435: PUSH
123436: LD_EXP 202
123440: PPUSH
123441: CALL 108402 0 1
123445: ST_TO_ADDR
// if not list then
123446: LD_VAR 0 3
123450: NOT
123451: IFFALSE 123455
// exit ;
123453: GO 124099
// for i := 1 to list do
123455: LD_ADDR_VAR 0 1
123459: PUSH
123460: DOUBLE
123461: LD_INT 1
123463: DEC
123464: ST_TO_ADDR
123465: LD_VAR 0 3
123469: PUSH
123470: FOR_TO
123471: IFFALSE 124097
// begin depot := list [ i ] [ 2 ] ;
123473: LD_ADDR_VAR 0 8
123477: PUSH
123478: LD_VAR 0 3
123482: PUSH
123483: LD_VAR 0 1
123487: ARRAY
123488: PUSH
123489: LD_INT 2
123491: ARRAY
123492: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
123493: LD_ADDR_VAR 0 5
123497: PUSH
123498: LD_VAR 0 3
123502: PUSH
123503: LD_VAR 0 1
123507: ARRAY
123508: PUSH
123509: LD_INT 1
123511: ARRAY
123512: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
123513: LD_VAR 0 8
123517: PPUSH
123518: CALL_OW 301
123522: PUSH
123523: LD_VAR 0 5
123527: PUSH
123528: LD_VAR 0 8
123532: PPUSH
123533: CALL_OW 255
123537: NONEQUAL
123538: OR
123539: IFFALSE 123568
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
123541: LD_ADDR_EXP 202
123545: PUSH
123546: LD_EXP 202
123550: PPUSH
123551: LD_VAR 0 8
123555: PPUSH
123556: LD_INT 0
123558: PPUSH
123559: CALL_OW 1
123563: ST_TO_ADDR
// exit ;
123564: POP
123565: POP
123566: GO 124099
// end ; x := list [ i ] [ 3 ] ;
123568: LD_ADDR_VAR 0 6
123572: PUSH
123573: LD_VAR 0 3
123577: PUSH
123578: LD_VAR 0 1
123582: ARRAY
123583: PUSH
123584: LD_INT 3
123586: ARRAY
123587: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
123588: LD_ADDR_VAR 0 7
123592: PUSH
123593: LD_VAR 0 3
123597: PUSH
123598: LD_VAR 0 1
123602: ARRAY
123603: PUSH
123604: LD_INT 4
123606: ARRAY
123607: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
123608: LD_ADDR_VAR 0 9
123612: PUSH
123613: LD_VAR 0 6
123617: PPUSH
123618: LD_VAR 0 7
123622: PPUSH
123623: LD_INT 16
123625: PPUSH
123626: CALL 106990 0 3
123630: ST_TO_ADDR
// if not cratesNearbyPoint then
123631: LD_VAR 0 9
123635: NOT
123636: IFFALSE 123642
// exit ;
123638: POP
123639: POP
123640: GO 124099
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
123642: LD_ADDR_VAR 0 4
123646: PUSH
123647: LD_INT 22
123649: PUSH
123650: LD_VAR 0 5
123654: PUSH
123655: EMPTY
123656: LIST
123657: LIST
123658: PUSH
123659: LD_INT 3
123661: PUSH
123662: LD_INT 60
123664: PUSH
123665: EMPTY
123666: LIST
123667: PUSH
123668: EMPTY
123669: LIST
123670: LIST
123671: PUSH
123672: LD_INT 91
123674: PUSH
123675: LD_VAR 0 8
123679: PUSH
123680: LD_INT 6
123682: PUSH
123683: EMPTY
123684: LIST
123685: LIST
123686: LIST
123687: PUSH
123688: LD_INT 2
123690: PUSH
123691: LD_INT 25
123693: PUSH
123694: LD_INT 2
123696: PUSH
123697: EMPTY
123698: LIST
123699: LIST
123700: PUSH
123701: LD_INT 25
123703: PUSH
123704: LD_INT 16
123706: PUSH
123707: EMPTY
123708: LIST
123709: LIST
123710: PUSH
123711: EMPTY
123712: LIST
123713: LIST
123714: LIST
123715: PUSH
123716: EMPTY
123717: LIST
123718: LIST
123719: LIST
123720: LIST
123721: PPUSH
123722: CALL_OW 69
123726: PUSH
123727: LD_VAR 0 8
123731: PPUSH
123732: CALL_OW 313
123736: PPUSH
123737: LD_INT 3
123739: PUSH
123740: LD_INT 60
123742: PUSH
123743: EMPTY
123744: LIST
123745: PUSH
123746: EMPTY
123747: LIST
123748: LIST
123749: PUSH
123750: LD_INT 2
123752: PUSH
123753: LD_INT 25
123755: PUSH
123756: LD_INT 2
123758: PUSH
123759: EMPTY
123760: LIST
123761: LIST
123762: PUSH
123763: LD_INT 25
123765: PUSH
123766: LD_INT 16
123768: PUSH
123769: EMPTY
123770: LIST
123771: LIST
123772: PUSH
123773: EMPTY
123774: LIST
123775: LIST
123776: LIST
123777: PUSH
123778: EMPTY
123779: LIST
123780: LIST
123781: PPUSH
123782: CALL_OW 72
123786: UNION
123787: ST_TO_ADDR
// if tmp then
123788: LD_VAR 0 4
123792: IFFALSE 123872
// begin tmp := ShrinkArray ( tmp , 3 ) ;
123794: LD_ADDR_VAR 0 4
123798: PUSH
123799: LD_VAR 0 4
123803: PPUSH
123804: LD_INT 3
123806: PPUSH
123807: CALL 104959 0 2
123811: ST_TO_ADDR
// for j in tmp do
123812: LD_ADDR_VAR 0 2
123816: PUSH
123817: LD_VAR 0 4
123821: PUSH
123822: FOR_IN
123823: IFFALSE 123866
// begin if IsInUnit ( j ) then
123825: LD_VAR 0 2
123829: PPUSH
123830: CALL_OW 310
123834: IFFALSE 123845
// ComExit ( j ) ;
123836: LD_VAR 0 2
123840: PPUSH
123841: CALL 105042 0 1
// AddComCollect ( j , x , y ) ;
123845: LD_VAR 0 2
123849: PPUSH
123850: LD_VAR 0 6
123854: PPUSH
123855: LD_VAR 0 7
123859: PPUSH
123860: CALL_OW 177
// end ;
123864: GO 123822
123866: POP
123867: POP
// exit ;
123868: POP
123869: POP
123870: GO 124099
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
123872: LD_ADDR_VAR 0 4
123876: PUSH
123877: LD_INT 22
123879: PUSH
123880: LD_VAR 0 5
123884: PUSH
123885: EMPTY
123886: LIST
123887: LIST
123888: PUSH
123889: LD_INT 91
123891: PUSH
123892: LD_VAR 0 8
123896: PUSH
123897: LD_INT 8
123899: PUSH
123900: EMPTY
123901: LIST
123902: LIST
123903: LIST
123904: PUSH
123905: LD_INT 2
123907: PUSH
123908: LD_INT 34
123910: PUSH
123911: LD_INT 12
123913: PUSH
123914: EMPTY
123915: LIST
123916: LIST
123917: PUSH
123918: LD_INT 34
123920: PUSH
123921: LD_INT 51
123923: PUSH
123924: EMPTY
123925: LIST
123926: LIST
123927: PUSH
123928: LD_INT 34
123930: PUSH
123931: LD_INT 32
123933: PUSH
123934: EMPTY
123935: LIST
123936: LIST
123937: PUSH
123938: LD_INT 34
123940: PUSH
123941: LD_INT 89
123943: PUSH
123944: EMPTY
123945: LIST
123946: LIST
123947: PUSH
123948: EMPTY
123949: LIST
123950: LIST
123951: LIST
123952: LIST
123953: LIST
123954: PUSH
123955: EMPTY
123956: LIST
123957: LIST
123958: LIST
123959: PPUSH
123960: CALL_OW 69
123964: ST_TO_ADDR
// if tmp then
123965: LD_VAR 0 4
123969: IFFALSE 124095
// begin for j in tmp do
123971: LD_ADDR_VAR 0 2
123975: PUSH
123976: LD_VAR 0 4
123980: PUSH
123981: FOR_IN
123982: IFFALSE 124093
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
123984: LD_VAR 0 2
123988: PPUSH
123989: CALL_OW 262
123993: PUSH
123994: LD_INT 3
123996: EQUAL
123997: PUSH
123998: LD_VAR 0 2
124002: PPUSH
124003: CALL_OW 261
124007: PUSH
124008: LD_INT 20
124010: GREATER
124011: OR
124012: PUSH
124013: LD_VAR 0 2
124017: PPUSH
124018: CALL_OW 314
124022: NOT
124023: AND
124024: PUSH
124025: LD_VAR 0 2
124029: PPUSH
124030: CALL_OW 263
124034: PUSH
124035: LD_INT 1
124037: NONEQUAL
124038: PUSH
124039: LD_VAR 0 2
124043: PPUSH
124044: CALL_OW 311
124048: OR
124049: AND
124050: IFFALSE 124091
// begin ComCollect ( j , x , y ) ;
124052: LD_VAR 0 2
124056: PPUSH
124057: LD_VAR 0 6
124061: PPUSH
124062: LD_VAR 0 7
124066: PPUSH
124067: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
124071: LD_VAR 0 2
124075: PPUSH
124076: LD_VAR 0 8
124080: PPUSH
124081: CALL_OW 172
// exit ;
124085: POP
124086: POP
124087: POP
124088: POP
124089: GO 124099
// end ;
124091: GO 123981
124093: POP
124094: POP
// end ; end ;
124095: GO 123470
124097: POP
124098: POP
// end ; end_of_file
124099: PPOPN 9
124101: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
124102: LD_INT 0
124104: PPUSH
124105: PPUSH
124106: PPUSH
124107: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
124108: LD_VAR 0 1
124112: PPUSH
124113: CALL_OW 264
124117: PUSH
124118: LD_INT 91
124120: EQUAL
124121: IFFALSE 124193
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
124123: LD_INT 68
124125: PPUSH
124126: LD_VAR 0 1
124130: PPUSH
124131: CALL_OW 255
124135: PPUSH
124136: CALL_OW 321
124140: PUSH
124141: LD_INT 2
124143: EQUAL
124144: IFFALSE 124156
// eff := 70 else
124146: LD_ADDR_VAR 0 4
124150: PUSH
124151: LD_INT 70
124153: ST_TO_ADDR
124154: GO 124164
// eff := 30 ;
124156: LD_ADDR_VAR 0 4
124160: PUSH
124161: LD_INT 30
124163: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
124164: LD_VAR 0 1
124168: PPUSH
124169: CALL_OW 250
124173: PPUSH
124174: LD_VAR 0 1
124178: PPUSH
124179: CALL_OW 251
124183: PPUSH
124184: LD_VAR 0 4
124188: PPUSH
124189: CALL_OW 495
// end ; end ;
124193: LD_VAR 0 2
124197: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
124198: LD_INT 0
124200: PPUSH
// end ;
124201: LD_VAR 0 4
124205: RET
// export function SOS_Command ( cmd ) ; begin
124206: LD_INT 0
124208: PPUSH
// end ;
124209: LD_VAR 0 2
124213: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
124214: LD_INT 0
124216: PPUSH
// end ;
124217: LD_VAR 0 6
124221: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
124222: LD_INT 0
124224: PPUSH
124225: PPUSH
// if not vehicle or not factory then
124226: LD_VAR 0 1
124230: NOT
124231: PUSH
124232: LD_VAR 0 2
124236: NOT
124237: OR
124238: IFFALSE 124242
// exit ;
124240: GO 124473
// if factoryWaypoints >= factory then
124242: LD_EXP 201
124246: PUSH
124247: LD_VAR 0 2
124251: GREATEREQUAL
124252: IFFALSE 124473
// if factoryWaypoints [ factory ] then
124254: LD_EXP 201
124258: PUSH
124259: LD_VAR 0 2
124263: ARRAY
124264: IFFALSE 124473
// begin if GetControl ( vehicle ) = control_manual then
124266: LD_VAR 0 1
124270: PPUSH
124271: CALL_OW 263
124275: PUSH
124276: LD_INT 1
124278: EQUAL
124279: IFFALSE 124360
// begin driver := IsDrivenBy ( vehicle ) ;
124281: LD_ADDR_VAR 0 4
124285: PUSH
124286: LD_VAR 0 1
124290: PPUSH
124291: CALL_OW 311
124295: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124296: LD_VAR 0 4
124300: PPUSH
124301: LD_EXP 201
124305: PUSH
124306: LD_VAR 0 2
124310: ARRAY
124311: PUSH
124312: LD_INT 3
124314: ARRAY
124315: PPUSH
124316: LD_EXP 201
124320: PUSH
124321: LD_VAR 0 2
124325: ARRAY
124326: PUSH
124327: LD_INT 4
124329: ARRAY
124330: PPUSH
124331: CALL_OW 171
// AddComExitVehicle ( driver ) ;
124335: LD_VAR 0 4
124339: PPUSH
124340: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
124344: LD_VAR 0 4
124348: PPUSH
124349: LD_VAR 0 2
124353: PPUSH
124354: CALL_OW 180
// end else
124358: GO 124473
// if GetControl ( vehicle ) = control_remote then
124360: LD_VAR 0 1
124364: PPUSH
124365: CALL_OW 263
124369: PUSH
124370: LD_INT 2
124372: EQUAL
124373: IFFALSE 124434
// begin wait ( 0 0$2 ) ;
124375: LD_INT 70
124377: PPUSH
124378: CALL_OW 67
// if Connect ( vehicle ) then
124382: LD_VAR 0 1
124386: PPUSH
124387: CALL 75301 0 1
124391: IFFALSE 124432
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124393: LD_VAR 0 1
124397: PPUSH
124398: LD_EXP 201
124402: PUSH
124403: LD_VAR 0 2
124407: ARRAY
124408: PUSH
124409: LD_INT 3
124411: ARRAY
124412: PPUSH
124413: LD_EXP 201
124417: PUSH
124418: LD_VAR 0 2
124422: ARRAY
124423: PUSH
124424: LD_INT 4
124426: ARRAY
124427: PPUSH
124428: CALL_OW 171
// end else
124432: GO 124473
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
124434: LD_VAR 0 1
124438: PPUSH
124439: LD_EXP 201
124443: PUSH
124444: LD_VAR 0 2
124448: ARRAY
124449: PUSH
124450: LD_INT 3
124452: ARRAY
124453: PPUSH
124454: LD_EXP 201
124458: PUSH
124459: LD_VAR 0 2
124463: ARRAY
124464: PUSH
124465: LD_INT 4
124467: ARRAY
124468: PPUSH
124469: CALL_OW 171
// end ; end ;
124473: LD_VAR 0 3
124477: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
124478: LD_INT 0
124480: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
124481: LD_VAR 0 1
124485: PUSH
124486: LD_INT 250
124488: EQUAL
124489: PUSH
124490: LD_VAR 0 2
124494: PPUSH
124495: CALL_OW 264
124499: PUSH
124500: LD_INT 81
124502: EQUAL
124503: AND
124504: IFFALSE 124525
// MinerPlaceMine ( unit , x , y ) ;
124506: LD_VAR 0 2
124510: PPUSH
124511: LD_VAR 0 4
124515: PPUSH
124516: LD_VAR 0 5
124520: PPUSH
124521: CALL 126910 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
124525: LD_VAR 0 1
124529: PUSH
124530: LD_INT 251
124532: EQUAL
124533: PUSH
124534: LD_VAR 0 2
124538: PPUSH
124539: CALL_OW 264
124543: PUSH
124544: LD_INT 81
124546: EQUAL
124547: AND
124548: IFFALSE 124569
// MinerDetonateMine ( unit , x , y ) ;
124550: LD_VAR 0 2
124554: PPUSH
124555: LD_VAR 0 4
124559: PPUSH
124560: LD_VAR 0 5
124564: PPUSH
124565: CALL 127185 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
124569: LD_VAR 0 1
124573: PUSH
124574: LD_INT 252
124576: EQUAL
124577: PUSH
124578: LD_VAR 0 2
124582: PPUSH
124583: CALL_OW 264
124587: PUSH
124588: LD_INT 81
124590: EQUAL
124591: AND
124592: IFFALSE 124613
// MinerCreateMinefield ( unit , x , y ) ;
124594: LD_VAR 0 2
124598: PPUSH
124599: LD_VAR 0 4
124603: PPUSH
124604: LD_VAR 0 5
124608: PPUSH
124609: CALL 127602 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
124613: LD_VAR 0 1
124617: PUSH
124618: LD_INT 253
124620: EQUAL
124621: PUSH
124622: LD_VAR 0 2
124626: PPUSH
124627: CALL_OW 257
124631: PUSH
124632: LD_INT 5
124634: EQUAL
124635: AND
124636: IFFALSE 124657
// ComBinocular ( unit , x , y ) ;
124638: LD_VAR 0 2
124642: PPUSH
124643: LD_VAR 0 4
124647: PPUSH
124648: LD_VAR 0 5
124652: PPUSH
124653: CALL 127971 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
124657: LD_VAR 0 1
124661: PUSH
124662: LD_INT 254
124664: EQUAL
124665: PUSH
124666: LD_VAR 0 2
124670: PPUSH
124671: CALL_OW 264
124675: PUSH
124676: LD_INT 99
124678: EQUAL
124679: AND
124680: PUSH
124681: LD_VAR 0 3
124685: PPUSH
124686: CALL_OW 263
124690: PUSH
124691: LD_INT 3
124693: EQUAL
124694: AND
124695: IFFALSE 124711
// HackDestroyVehicle ( unit , selectedUnit ) ;
124697: LD_VAR 0 2
124701: PPUSH
124702: LD_VAR 0 3
124706: PPUSH
124707: CALL 126274 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
124711: LD_VAR 0 1
124715: PUSH
124716: LD_INT 255
124718: EQUAL
124719: PUSH
124720: LD_VAR 0 2
124724: PPUSH
124725: CALL_OW 264
124729: PUSH
124730: LD_INT 14
124732: PUSH
124733: LD_INT 53
124735: PUSH
124736: EMPTY
124737: LIST
124738: LIST
124739: IN
124740: AND
124741: PUSH
124742: LD_VAR 0 4
124746: PPUSH
124747: LD_VAR 0 5
124751: PPUSH
124752: CALL_OW 488
124756: AND
124757: IFFALSE 124781
// CutTreeXYR ( unit , x , y , 12 ) ;
124759: LD_VAR 0 2
124763: PPUSH
124764: LD_VAR 0 4
124768: PPUSH
124769: LD_VAR 0 5
124773: PPUSH
124774: LD_INT 12
124776: PPUSH
124777: CALL 124844 0 4
// if cmd = 256 then
124781: LD_VAR 0 1
124785: PUSH
124786: LD_INT 256
124788: EQUAL
124789: IFFALSE 124810
// SetFactoryWaypoint ( unit , x , y ) ;
124791: LD_VAR 0 2
124795: PPUSH
124796: LD_VAR 0 4
124800: PPUSH
124801: LD_VAR 0 5
124805: PPUSH
124806: CALL 122791 0 3
// if cmd = 257 then
124810: LD_VAR 0 1
124814: PUSH
124815: LD_INT 257
124817: EQUAL
124818: IFFALSE 124839
// SetWarehouseGatheringPoint ( unit , x , y ) ;
124820: LD_VAR 0 2
124824: PPUSH
124825: LD_VAR 0 4
124829: PPUSH
124830: LD_VAR 0 5
124834: PPUSH
124835: CALL 123153 0 3
// end ;
124839: LD_VAR 0 6
124843: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
124844: LD_INT 0
124846: PPUSH
124847: PPUSH
124848: PPUSH
124849: PPUSH
124850: PPUSH
124851: PPUSH
124852: PPUSH
124853: PPUSH
124854: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
124855: LD_VAR 0 1
124859: NOT
124860: PUSH
124861: LD_VAR 0 2
124865: PPUSH
124866: LD_VAR 0 3
124870: PPUSH
124871: CALL_OW 488
124875: NOT
124876: OR
124877: PUSH
124878: LD_VAR 0 4
124882: NOT
124883: OR
124884: IFFALSE 124888
// exit ;
124886: GO 125228
// list := [ ] ;
124888: LD_ADDR_VAR 0 13
124892: PUSH
124893: EMPTY
124894: ST_TO_ADDR
// if x - r < 0 then
124895: LD_VAR 0 2
124899: PUSH
124900: LD_VAR 0 4
124904: MINUS
124905: PUSH
124906: LD_INT 0
124908: LESS
124909: IFFALSE 124921
// min_x := 0 else
124911: LD_ADDR_VAR 0 7
124915: PUSH
124916: LD_INT 0
124918: ST_TO_ADDR
124919: GO 124937
// min_x := x - r ;
124921: LD_ADDR_VAR 0 7
124925: PUSH
124926: LD_VAR 0 2
124930: PUSH
124931: LD_VAR 0 4
124935: MINUS
124936: ST_TO_ADDR
// if y - r < 0 then
124937: LD_VAR 0 3
124941: PUSH
124942: LD_VAR 0 4
124946: MINUS
124947: PUSH
124948: LD_INT 0
124950: LESS
124951: IFFALSE 124963
// min_y := 0 else
124953: LD_ADDR_VAR 0 8
124957: PUSH
124958: LD_INT 0
124960: ST_TO_ADDR
124961: GO 124979
// min_y := y - r ;
124963: LD_ADDR_VAR 0 8
124967: PUSH
124968: LD_VAR 0 3
124972: PUSH
124973: LD_VAR 0 4
124977: MINUS
124978: ST_TO_ADDR
// max_x := x + r ;
124979: LD_ADDR_VAR 0 9
124983: PUSH
124984: LD_VAR 0 2
124988: PUSH
124989: LD_VAR 0 4
124993: PLUS
124994: ST_TO_ADDR
// max_y := y + r ;
124995: LD_ADDR_VAR 0 10
124999: PUSH
125000: LD_VAR 0 3
125004: PUSH
125005: LD_VAR 0 4
125009: PLUS
125010: ST_TO_ADDR
// for _x = min_x to max_x do
125011: LD_ADDR_VAR 0 11
125015: PUSH
125016: DOUBLE
125017: LD_VAR 0 7
125021: DEC
125022: ST_TO_ADDR
125023: LD_VAR 0 9
125027: PUSH
125028: FOR_TO
125029: IFFALSE 125146
// for _y = min_y to max_y do
125031: LD_ADDR_VAR 0 12
125035: PUSH
125036: DOUBLE
125037: LD_VAR 0 8
125041: DEC
125042: ST_TO_ADDR
125043: LD_VAR 0 10
125047: PUSH
125048: FOR_TO
125049: IFFALSE 125142
// begin if not ValidHex ( _x , _y ) then
125051: LD_VAR 0 11
125055: PPUSH
125056: LD_VAR 0 12
125060: PPUSH
125061: CALL_OW 488
125065: NOT
125066: IFFALSE 125070
// continue ;
125068: GO 125048
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
125070: LD_VAR 0 11
125074: PPUSH
125075: LD_VAR 0 12
125079: PPUSH
125080: CALL_OW 351
125084: PUSH
125085: LD_VAR 0 11
125089: PPUSH
125090: LD_VAR 0 12
125094: PPUSH
125095: CALL_OW 554
125099: AND
125100: IFFALSE 125140
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
125102: LD_ADDR_VAR 0 13
125106: PUSH
125107: LD_VAR 0 13
125111: PPUSH
125112: LD_VAR 0 13
125116: PUSH
125117: LD_INT 1
125119: PLUS
125120: PPUSH
125121: LD_VAR 0 11
125125: PUSH
125126: LD_VAR 0 12
125130: PUSH
125131: EMPTY
125132: LIST
125133: LIST
125134: PPUSH
125135: CALL_OW 2
125139: ST_TO_ADDR
// end ;
125140: GO 125048
125142: POP
125143: POP
125144: GO 125028
125146: POP
125147: POP
// if not list then
125148: LD_VAR 0 13
125152: NOT
125153: IFFALSE 125157
// exit ;
125155: GO 125228
// for i in list do
125157: LD_ADDR_VAR 0 6
125161: PUSH
125162: LD_VAR 0 13
125166: PUSH
125167: FOR_IN
125168: IFFALSE 125226
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
125170: LD_VAR 0 1
125174: PPUSH
125175: LD_STRING M
125177: PUSH
125178: LD_VAR 0 6
125182: PUSH
125183: LD_INT 1
125185: ARRAY
125186: PUSH
125187: LD_VAR 0 6
125191: PUSH
125192: LD_INT 2
125194: ARRAY
125195: PUSH
125196: LD_INT 0
125198: PUSH
125199: LD_INT 0
125201: PUSH
125202: LD_INT 0
125204: PUSH
125205: LD_INT 0
125207: PUSH
125208: EMPTY
125209: LIST
125210: LIST
125211: LIST
125212: LIST
125213: LIST
125214: LIST
125215: LIST
125216: PUSH
125217: EMPTY
125218: LIST
125219: PPUSH
125220: CALL_OW 447
125224: GO 125167
125226: POP
125227: POP
// end ;
125228: LD_VAR 0 5
125232: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
125233: LD_EXP 204
125237: NOT
125238: IFFALSE 125288
125240: GO 125242
125242: DISABLE
// begin initHack := true ;
125243: LD_ADDR_EXP 204
125247: PUSH
125248: LD_INT 1
125250: ST_TO_ADDR
// hackTanks := [ ] ;
125251: LD_ADDR_EXP 205
125255: PUSH
125256: EMPTY
125257: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
125258: LD_ADDR_EXP 206
125262: PUSH
125263: EMPTY
125264: ST_TO_ADDR
// hackLimit := 3 ;
125265: LD_ADDR_EXP 207
125269: PUSH
125270: LD_INT 3
125272: ST_TO_ADDR
// hackDist := 12 ;
125273: LD_ADDR_EXP 208
125277: PUSH
125278: LD_INT 12
125280: ST_TO_ADDR
// hackCounter := [ ] ;
125281: LD_ADDR_EXP 209
125285: PUSH
125286: EMPTY
125287: ST_TO_ADDR
// end ;
125288: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
125289: LD_EXP 204
125293: PUSH
125294: LD_INT 34
125296: PUSH
125297: LD_INT 99
125299: PUSH
125300: EMPTY
125301: LIST
125302: LIST
125303: PPUSH
125304: CALL_OW 69
125308: AND
125309: IFFALSE 125562
125311: GO 125313
125313: DISABLE
125314: LD_INT 0
125316: PPUSH
125317: PPUSH
// begin enable ;
125318: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
125319: LD_ADDR_VAR 0 1
125323: PUSH
125324: LD_INT 34
125326: PUSH
125327: LD_INT 99
125329: PUSH
125330: EMPTY
125331: LIST
125332: LIST
125333: PPUSH
125334: CALL_OW 69
125338: PUSH
125339: FOR_IN
125340: IFFALSE 125560
// begin if not i in hackTanks then
125342: LD_VAR 0 1
125346: PUSH
125347: LD_EXP 205
125351: IN
125352: NOT
125353: IFFALSE 125436
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
125355: LD_ADDR_EXP 205
125359: PUSH
125360: LD_EXP 205
125364: PPUSH
125365: LD_EXP 205
125369: PUSH
125370: LD_INT 1
125372: PLUS
125373: PPUSH
125374: LD_VAR 0 1
125378: PPUSH
125379: CALL_OW 1
125383: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
125384: LD_ADDR_EXP 206
125388: PUSH
125389: LD_EXP 206
125393: PPUSH
125394: LD_EXP 206
125398: PUSH
125399: LD_INT 1
125401: PLUS
125402: PPUSH
125403: EMPTY
125404: PPUSH
125405: CALL_OW 1
125409: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
125410: LD_ADDR_EXP 209
125414: PUSH
125415: LD_EXP 209
125419: PPUSH
125420: LD_EXP 209
125424: PUSH
125425: LD_INT 1
125427: PLUS
125428: PPUSH
125429: EMPTY
125430: PPUSH
125431: CALL_OW 1
125435: ST_TO_ADDR
// end ; if not IsOk ( i ) then
125436: LD_VAR 0 1
125440: PPUSH
125441: CALL_OW 302
125445: NOT
125446: IFFALSE 125459
// begin HackUnlinkAll ( i ) ;
125448: LD_VAR 0 1
125452: PPUSH
125453: CALL 125565 0 1
// continue ;
125457: GO 125339
// end ; HackCheckCapturedStatus ( i ) ;
125459: LD_VAR 0 1
125463: PPUSH
125464: CALL 126008 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
125468: LD_ADDR_VAR 0 2
125472: PUSH
125473: LD_INT 81
125475: PUSH
125476: LD_VAR 0 1
125480: PPUSH
125481: CALL_OW 255
125485: PUSH
125486: EMPTY
125487: LIST
125488: LIST
125489: PUSH
125490: LD_INT 33
125492: PUSH
125493: LD_INT 3
125495: PUSH
125496: EMPTY
125497: LIST
125498: LIST
125499: PUSH
125500: LD_INT 91
125502: PUSH
125503: LD_VAR 0 1
125507: PUSH
125508: LD_EXP 208
125512: PUSH
125513: EMPTY
125514: LIST
125515: LIST
125516: LIST
125517: PUSH
125518: LD_INT 50
125520: PUSH
125521: EMPTY
125522: LIST
125523: PUSH
125524: EMPTY
125525: LIST
125526: LIST
125527: LIST
125528: LIST
125529: PPUSH
125530: CALL_OW 69
125534: ST_TO_ADDR
// if not tmp then
125535: LD_VAR 0 2
125539: NOT
125540: IFFALSE 125544
// continue ;
125542: GO 125339
// HackLink ( i , tmp ) ;
125544: LD_VAR 0 1
125548: PPUSH
125549: LD_VAR 0 2
125553: PPUSH
125554: CALL 125701 0 2
// end ;
125558: GO 125339
125560: POP
125561: POP
// end ;
125562: PPOPN 2
125564: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
125565: LD_INT 0
125567: PPUSH
125568: PPUSH
125569: PPUSH
// if not hack in hackTanks then
125570: LD_VAR 0 1
125574: PUSH
125575: LD_EXP 205
125579: IN
125580: NOT
125581: IFFALSE 125585
// exit ;
125583: GO 125696
// index := GetElementIndex ( hackTanks , hack ) ;
125585: LD_ADDR_VAR 0 4
125589: PUSH
125590: LD_EXP 205
125594: PPUSH
125595: LD_VAR 0 1
125599: PPUSH
125600: CALL 72117 0 2
125604: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
125605: LD_EXP 206
125609: PUSH
125610: LD_VAR 0 4
125614: ARRAY
125615: IFFALSE 125696
// begin for i in hackTanksCaptured [ index ] do
125617: LD_ADDR_VAR 0 3
125621: PUSH
125622: LD_EXP 206
125626: PUSH
125627: LD_VAR 0 4
125631: ARRAY
125632: PUSH
125633: FOR_IN
125634: IFFALSE 125660
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
125636: LD_VAR 0 3
125640: PUSH
125641: LD_INT 1
125643: ARRAY
125644: PPUSH
125645: LD_VAR 0 3
125649: PUSH
125650: LD_INT 2
125652: ARRAY
125653: PPUSH
125654: CALL_OW 235
125658: GO 125633
125660: POP
125661: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
125662: LD_ADDR_EXP 206
125666: PUSH
125667: LD_EXP 206
125671: PPUSH
125672: LD_VAR 0 4
125676: PPUSH
125677: EMPTY
125678: PPUSH
125679: CALL_OW 1
125683: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
125684: LD_VAR 0 1
125688: PPUSH
125689: LD_INT 0
125691: PPUSH
125692: CALL_OW 505
// end ; end ;
125696: LD_VAR 0 2
125700: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
125701: LD_INT 0
125703: PPUSH
125704: PPUSH
125705: PPUSH
// if not hack in hackTanks or not vehicles then
125706: LD_VAR 0 1
125710: PUSH
125711: LD_EXP 205
125715: IN
125716: NOT
125717: PUSH
125718: LD_VAR 0 2
125722: NOT
125723: OR
125724: IFFALSE 125728
// exit ;
125726: GO 126003
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
125728: LD_ADDR_VAR 0 2
125732: PUSH
125733: LD_VAR 0 1
125737: PPUSH
125738: LD_VAR 0 2
125742: PPUSH
125743: LD_INT 1
125745: PPUSH
125746: LD_INT 1
125748: PPUSH
125749: CALL 72767 0 4
125753: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
125754: LD_ADDR_VAR 0 5
125758: PUSH
125759: LD_EXP 205
125763: PPUSH
125764: LD_VAR 0 1
125768: PPUSH
125769: CALL 72117 0 2
125773: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
125774: LD_EXP 206
125778: PUSH
125779: LD_VAR 0 5
125783: ARRAY
125784: PUSH
125785: LD_EXP 207
125789: LESS
125790: IFFALSE 125979
// begin for i := 1 to vehicles do
125792: LD_ADDR_VAR 0 4
125796: PUSH
125797: DOUBLE
125798: LD_INT 1
125800: DEC
125801: ST_TO_ADDR
125802: LD_VAR 0 2
125806: PUSH
125807: FOR_TO
125808: IFFALSE 125977
// begin if hackTanksCaptured [ index ] = hackLimit then
125810: LD_EXP 206
125814: PUSH
125815: LD_VAR 0 5
125819: ARRAY
125820: PUSH
125821: LD_EXP 207
125825: EQUAL
125826: IFFALSE 125830
// break ;
125828: GO 125977
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
125830: LD_ADDR_EXP 209
125834: PUSH
125835: LD_EXP 209
125839: PPUSH
125840: LD_VAR 0 5
125844: PPUSH
125845: LD_EXP 209
125849: PUSH
125850: LD_VAR 0 5
125854: ARRAY
125855: PUSH
125856: LD_INT 1
125858: PLUS
125859: PPUSH
125860: CALL_OW 1
125864: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
125865: LD_ADDR_EXP 206
125869: PUSH
125870: LD_EXP 206
125874: PPUSH
125875: LD_VAR 0 5
125879: PUSH
125880: LD_EXP 206
125884: PUSH
125885: LD_VAR 0 5
125889: ARRAY
125890: PUSH
125891: LD_INT 1
125893: PLUS
125894: PUSH
125895: EMPTY
125896: LIST
125897: LIST
125898: PPUSH
125899: LD_VAR 0 2
125903: PUSH
125904: LD_VAR 0 4
125908: ARRAY
125909: PUSH
125910: LD_VAR 0 2
125914: PUSH
125915: LD_VAR 0 4
125919: ARRAY
125920: PPUSH
125921: CALL_OW 255
125925: PUSH
125926: EMPTY
125927: LIST
125928: LIST
125929: PPUSH
125930: CALL 72332 0 3
125934: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
125935: LD_VAR 0 2
125939: PUSH
125940: LD_VAR 0 4
125944: ARRAY
125945: PPUSH
125946: LD_VAR 0 1
125950: PPUSH
125951: CALL_OW 255
125955: PPUSH
125956: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
125960: LD_VAR 0 2
125964: PUSH
125965: LD_VAR 0 4
125969: ARRAY
125970: PPUSH
125971: CALL_OW 141
// end ;
125975: GO 125807
125977: POP
125978: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
125979: LD_VAR 0 1
125983: PPUSH
125984: LD_EXP 206
125988: PUSH
125989: LD_VAR 0 5
125993: ARRAY
125994: PUSH
125995: LD_INT 0
125997: PLUS
125998: PPUSH
125999: CALL_OW 505
// end ;
126003: LD_VAR 0 3
126007: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
126008: LD_INT 0
126010: PPUSH
126011: PPUSH
126012: PPUSH
126013: PPUSH
// if not hack in hackTanks then
126014: LD_VAR 0 1
126018: PUSH
126019: LD_EXP 205
126023: IN
126024: NOT
126025: IFFALSE 126029
// exit ;
126027: GO 126269
// index := GetElementIndex ( hackTanks , hack ) ;
126029: LD_ADDR_VAR 0 4
126033: PUSH
126034: LD_EXP 205
126038: PPUSH
126039: LD_VAR 0 1
126043: PPUSH
126044: CALL 72117 0 2
126048: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
126049: LD_ADDR_VAR 0 3
126053: PUSH
126054: DOUBLE
126055: LD_EXP 206
126059: PUSH
126060: LD_VAR 0 4
126064: ARRAY
126065: INC
126066: ST_TO_ADDR
126067: LD_INT 1
126069: PUSH
126070: FOR_DOWNTO
126071: IFFALSE 126243
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
126073: LD_ADDR_VAR 0 5
126077: PUSH
126078: LD_EXP 206
126082: PUSH
126083: LD_VAR 0 4
126087: ARRAY
126088: PUSH
126089: LD_VAR 0 3
126093: ARRAY
126094: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
126095: LD_VAR 0 5
126099: PUSH
126100: LD_INT 1
126102: ARRAY
126103: PPUSH
126104: CALL_OW 302
126108: NOT
126109: PUSH
126110: LD_VAR 0 5
126114: PUSH
126115: LD_INT 1
126117: ARRAY
126118: PPUSH
126119: CALL_OW 255
126123: PUSH
126124: LD_VAR 0 1
126128: PPUSH
126129: CALL_OW 255
126133: NONEQUAL
126134: OR
126135: IFFALSE 126241
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
126137: LD_VAR 0 5
126141: PUSH
126142: LD_INT 1
126144: ARRAY
126145: PPUSH
126146: CALL_OW 305
126150: PUSH
126151: LD_VAR 0 5
126155: PUSH
126156: LD_INT 1
126158: ARRAY
126159: PPUSH
126160: CALL_OW 255
126164: PUSH
126165: LD_VAR 0 1
126169: PPUSH
126170: CALL_OW 255
126174: EQUAL
126175: AND
126176: IFFALSE 126200
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
126178: LD_VAR 0 5
126182: PUSH
126183: LD_INT 1
126185: ARRAY
126186: PPUSH
126187: LD_VAR 0 5
126191: PUSH
126192: LD_INT 2
126194: ARRAY
126195: PPUSH
126196: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
126200: LD_ADDR_EXP 206
126204: PUSH
126205: LD_EXP 206
126209: PPUSH
126210: LD_VAR 0 4
126214: PPUSH
126215: LD_EXP 206
126219: PUSH
126220: LD_VAR 0 4
126224: ARRAY
126225: PPUSH
126226: LD_VAR 0 3
126230: PPUSH
126231: CALL_OW 3
126235: PPUSH
126236: CALL_OW 1
126240: ST_TO_ADDR
// end ; end ;
126241: GO 126070
126243: POP
126244: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
126245: LD_VAR 0 1
126249: PPUSH
126250: LD_EXP 206
126254: PUSH
126255: LD_VAR 0 4
126259: ARRAY
126260: PUSH
126261: LD_INT 0
126263: PLUS
126264: PPUSH
126265: CALL_OW 505
// end ;
126269: LD_VAR 0 2
126273: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
126274: LD_INT 0
126276: PPUSH
126277: PPUSH
126278: PPUSH
126279: PPUSH
// if not hack in hackTanks then
126280: LD_VAR 0 1
126284: PUSH
126285: LD_EXP 205
126289: IN
126290: NOT
126291: IFFALSE 126295
// exit ;
126293: GO 126380
// index := GetElementIndex ( hackTanks , hack ) ;
126295: LD_ADDR_VAR 0 5
126299: PUSH
126300: LD_EXP 205
126304: PPUSH
126305: LD_VAR 0 1
126309: PPUSH
126310: CALL 72117 0 2
126314: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
126315: LD_ADDR_VAR 0 4
126319: PUSH
126320: DOUBLE
126321: LD_INT 1
126323: DEC
126324: ST_TO_ADDR
126325: LD_EXP 206
126329: PUSH
126330: LD_VAR 0 5
126334: ARRAY
126335: PUSH
126336: FOR_TO
126337: IFFALSE 126378
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
126339: LD_EXP 206
126343: PUSH
126344: LD_VAR 0 5
126348: ARRAY
126349: PUSH
126350: LD_VAR 0 4
126354: ARRAY
126355: PUSH
126356: LD_INT 1
126358: ARRAY
126359: PUSH
126360: LD_VAR 0 2
126364: EQUAL
126365: IFFALSE 126376
// KillUnit ( vehicle ) ;
126367: LD_VAR 0 2
126371: PPUSH
126372: CALL_OW 66
126376: GO 126336
126378: POP
126379: POP
// end ;
126380: LD_VAR 0 3
126384: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
126385: LD_EXP 210
126389: NOT
126390: IFFALSE 126425
126392: GO 126394
126394: DISABLE
// begin initMiner := true ;
126395: LD_ADDR_EXP 210
126399: PUSH
126400: LD_INT 1
126402: ST_TO_ADDR
// minersList := [ ] ;
126403: LD_ADDR_EXP 211
126407: PUSH
126408: EMPTY
126409: ST_TO_ADDR
// minerMinesList := [ ] ;
126410: LD_ADDR_EXP 212
126414: PUSH
126415: EMPTY
126416: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
126417: LD_ADDR_EXP 213
126421: PUSH
126422: LD_INT 5
126424: ST_TO_ADDR
// end ;
126425: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
126426: LD_EXP 210
126430: PUSH
126431: LD_INT 34
126433: PUSH
126434: LD_INT 81
126436: PUSH
126437: EMPTY
126438: LIST
126439: LIST
126440: PPUSH
126441: CALL_OW 69
126445: AND
126446: IFFALSE 126907
126448: GO 126450
126450: DISABLE
126451: LD_INT 0
126453: PPUSH
126454: PPUSH
126455: PPUSH
126456: PPUSH
// begin enable ;
126457: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
126458: LD_ADDR_VAR 0 1
126462: PUSH
126463: LD_INT 34
126465: PUSH
126466: LD_INT 81
126468: PUSH
126469: EMPTY
126470: LIST
126471: LIST
126472: PPUSH
126473: CALL_OW 69
126477: PUSH
126478: FOR_IN
126479: IFFALSE 126551
// begin if not i in minersList then
126481: LD_VAR 0 1
126485: PUSH
126486: LD_EXP 211
126490: IN
126491: NOT
126492: IFFALSE 126549
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
126494: LD_ADDR_EXP 211
126498: PUSH
126499: LD_EXP 211
126503: PPUSH
126504: LD_EXP 211
126508: PUSH
126509: LD_INT 1
126511: PLUS
126512: PPUSH
126513: LD_VAR 0 1
126517: PPUSH
126518: CALL_OW 1
126522: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
126523: LD_ADDR_EXP 212
126527: PUSH
126528: LD_EXP 212
126532: PPUSH
126533: LD_EXP 212
126537: PUSH
126538: LD_INT 1
126540: PLUS
126541: PPUSH
126542: EMPTY
126543: PPUSH
126544: CALL_OW 1
126548: ST_TO_ADDR
// end end ;
126549: GO 126478
126551: POP
126552: POP
// for i := minerMinesList downto 1 do
126553: LD_ADDR_VAR 0 1
126557: PUSH
126558: DOUBLE
126559: LD_EXP 212
126563: INC
126564: ST_TO_ADDR
126565: LD_INT 1
126567: PUSH
126568: FOR_DOWNTO
126569: IFFALSE 126905
// begin if IsLive ( minersList [ i ] ) then
126571: LD_EXP 211
126575: PUSH
126576: LD_VAR 0 1
126580: ARRAY
126581: PPUSH
126582: CALL_OW 300
126586: IFFALSE 126614
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
126588: LD_EXP 211
126592: PUSH
126593: LD_VAR 0 1
126597: ARRAY
126598: PPUSH
126599: LD_EXP 212
126603: PUSH
126604: LD_VAR 0 1
126608: ARRAY
126609: PPUSH
126610: CALL_OW 505
// if not minerMinesList [ i ] then
126614: LD_EXP 212
126618: PUSH
126619: LD_VAR 0 1
126623: ARRAY
126624: NOT
126625: IFFALSE 126629
// continue ;
126627: GO 126568
// for j := minerMinesList [ i ] downto 1 do
126629: LD_ADDR_VAR 0 2
126633: PUSH
126634: DOUBLE
126635: LD_EXP 212
126639: PUSH
126640: LD_VAR 0 1
126644: ARRAY
126645: INC
126646: ST_TO_ADDR
126647: LD_INT 1
126649: PUSH
126650: FOR_DOWNTO
126651: IFFALSE 126901
// begin side := GetSide ( minersList [ i ] ) ;
126653: LD_ADDR_VAR 0 3
126657: PUSH
126658: LD_EXP 211
126662: PUSH
126663: LD_VAR 0 1
126667: ARRAY
126668: PPUSH
126669: CALL_OW 255
126673: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
126674: LD_ADDR_VAR 0 4
126678: PUSH
126679: LD_EXP 212
126683: PUSH
126684: LD_VAR 0 1
126688: ARRAY
126689: PUSH
126690: LD_VAR 0 2
126694: ARRAY
126695: PUSH
126696: LD_INT 1
126698: ARRAY
126699: PPUSH
126700: LD_EXP 212
126704: PUSH
126705: LD_VAR 0 1
126709: ARRAY
126710: PUSH
126711: LD_VAR 0 2
126715: ARRAY
126716: PUSH
126717: LD_INT 2
126719: ARRAY
126720: PPUSH
126721: CALL_OW 428
126725: ST_TO_ADDR
// if not tmp then
126726: LD_VAR 0 4
126730: NOT
126731: IFFALSE 126735
// continue ;
126733: GO 126650
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
126735: LD_VAR 0 4
126739: PUSH
126740: LD_INT 81
126742: PUSH
126743: LD_VAR 0 3
126747: PUSH
126748: EMPTY
126749: LIST
126750: LIST
126751: PPUSH
126752: CALL_OW 69
126756: IN
126757: PUSH
126758: LD_EXP 212
126762: PUSH
126763: LD_VAR 0 1
126767: ARRAY
126768: PUSH
126769: LD_VAR 0 2
126773: ARRAY
126774: PUSH
126775: LD_INT 1
126777: ARRAY
126778: PPUSH
126779: LD_EXP 212
126783: PUSH
126784: LD_VAR 0 1
126788: ARRAY
126789: PUSH
126790: LD_VAR 0 2
126794: ARRAY
126795: PUSH
126796: LD_INT 2
126798: ARRAY
126799: PPUSH
126800: CALL_OW 458
126804: AND
126805: IFFALSE 126899
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
126807: LD_EXP 212
126811: PUSH
126812: LD_VAR 0 1
126816: ARRAY
126817: PUSH
126818: LD_VAR 0 2
126822: ARRAY
126823: PUSH
126824: LD_INT 1
126826: ARRAY
126827: PPUSH
126828: LD_EXP 212
126832: PUSH
126833: LD_VAR 0 1
126837: ARRAY
126838: PUSH
126839: LD_VAR 0 2
126843: ARRAY
126844: PUSH
126845: LD_INT 2
126847: ARRAY
126848: PPUSH
126849: LD_VAR 0 3
126853: PPUSH
126854: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
126858: LD_ADDR_EXP 212
126862: PUSH
126863: LD_EXP 212
126867: PPUSH
126868: LD_VAR 0 1
126872: PPUSH
126873: LD_EXP 212
126877: PUSH
126878: LD_VAR 0 1
126882: ARRAY
126883: PPUSH
126884: LD_VAR 0 2
126888: PPUSH
126889: CALL_OW 3
126893: PPUSH
126894: CALL_OW 1
126898: ST_TO_ADDR
// end ; end ;
126899: GO 126650
126901: POP
126902: POP
// end ;
126903: GO 126568
126905: POP
126906: POP
// end ;
126907: PPOPN 4
126909: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
126910: LD_INT 0
126912: PPUSH
126913: PPUSH
// result := false ;
126914: LD_ADDR_VAR 0 4
126918: PUSH
126919: LD_INT 0
126921: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
126922: LD_VAR 0 1
126926: PPUSH
126927: CALL_OW 264
126931: PUSH
126932: LD_INT 81
126934: EQUAL
126935: NOT
126936: IFFALSE 126940
// exit ;
126938: GO 127180
// index := GetElementIndex ( minersList , unit ) ;
126940: LD_ADDR_VAR 0 5
126944: PUSH
126945: LD_EXP 211
126949: PPUSH
126950: LD_VAR 0 1
126954: PPUSH
126955: CALL 72117 0 2
126959: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
126960: LD_EXP 212
126964: PUSH
126965: LD_VAR 0 5
126969: ARRAY
126970: PUSH
126971: LD_EXP 213
126975: GREATEREQUAL
126976: IFFALSE 126980
// exit ;
126978: GO 127180
// ComMoveXY ( unit , x , y ) ;
126980: LD_VAR 0 1
126984: PPUSH
126985: LD_VAR 0 2
126989: PPUSH
126990: LD_VAR 0 3
126994: PPUSH
126995: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
126999: LD_INT 35
127001: PPUSH
127002: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
127006: LD_VAR 0 1
127010: PPUSH
127011: LD_VAR 0 2
127015: PPUSH
127016: LD_VAR 0 3
127020: PPUSH
127021: CALL 103453 0 3
127025: NOT
127026: PUSH
127027: LD_VAR 0 1
127031: PPUSH
127032: CALL_OW 314
127036: AND
127037: IFFALSE 127041
// exit ;
127039: GO 127180
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
127041: LD_VAR 0 2
127045: PPUSH
127046: LD_VAR 0 3
127050: PPUSH
127051: CALL_OW 428
127055: PUSH
127056: LD_VAR 0 1
127060: EQUAL
127061: PUSH
127062: LD_VAR 0 1
127066: PPUSH
127067: CALL_OW 314
127071: NOT
127072: AND
127073: IFFALSE 126999
// PlaySoundXY ( x , y , PlantMine ) ;
127075: LD_VAR 0 2
127079: PPUSH
127080: LD_VAR 0 3
127084: PPUSH
127085: LD_STRING PlantMine
127087: PPUSH
127088: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
127092: LD_VAR 0 2
127096: PPUSH
127097: LD_VAR 0 3
127101: PPUSH
127102: LD_VAR 0 1
127106: PPUSH
127107: CALL_OW 255
127111: PPUSH
127112: LD_INT 0
127114: PPUSH
127115: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
127119: LD_ADDR_EXP 212
127123: PUSH
127124: LD_EXP 212
127128: PPUSH
127129: LD_VAR 0 5
127133: PUSH
127134: LD_EXP 212
127138: PUSH
127139: LD_VAR 0 5
127143: ARRAY
127144: PUSH
127145: LD_INT 1
127147: PLUS
127148: PUSH
127149: EMPTY
127150: LIST
127151: LIST
127152: PPUSH
127153: LD_VAR 0 2
127157: PUSH
127158: LD_VAR 0 3
127162: PUSH
127163: EMPTY
127164: LIST
127165: LIST
127166: PPUSH
127167: CALL 72332 0 3
127171: ST_TO_ADDR
// result := true ;
127172: LD_ADDR_VAR 0 4
127176: PUSH
127177: LD_INT 1
127179: ST_TO_ADDR
// end ;
127180: LD_VAR 0 4
127184: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
127185: LD_INT 0
127187: PPUSH
127188: PPUSH
127189: PPUSH
// if not unit in minersList then
127190: LD_VAR 0 1
127194: PUSH
127195: LD_EXP 211
127199: IN
127200: NOT
127201: IFFALSE 127205
// exit ;
127203: GO 127597
// index := GetElementIndex ( minersList , unit ) ;
127205: LD_ADDR_VAR 0 6
127209: PUSH
127210: LD_EXP 211
127214: PPUSH
127215: LD_VAR 0 1
127219: PPUSH
127220: CALL 72117 0 2
127224: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
127225: LD_ADDR_VAR 0 5
127229: PUSH
127230: DOUBLE
127231: LD_EXP 212
127235: PUSH
127236: LD_VAR 0 6
127240: ARRAY
127241: INC
127242: ST_TO_ADDR
127243: LD_INT 1
127245: PUSH
127246: FOR_DOWNTO
127247: IFFALSE 127408
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
127249: LD_EXP 212
127253: PUSH
127254: LD_VAR 0 6
127258: ARRAY
127259: PUSH
127260: LD_VAR 0 5
127264: ARRAY
127265: PUSH
127266: LD_INT 1
127268: ARRAY
127269: PUSH
127270: LD_VAR 0 2
127274: EQUAL
127275: PUSH
127276: LD_EXP 212
127280: PUSH
127281: LD_VAR 0 6
127285: ARRAY
127286: PUSH
127287: LD_VAR 0 5
127291: ARRAY
127292: PUSH
127293: LD_INT 2
127295: ARRAY
127296: PUSH
127297: LD_VAR 0 3
127301: EQUAL
127302: AND
127303: IFFALSE 127406
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127305: LD_EXP 212
127309: PUSH
127310: LD_VAR 0 6
127314: ARRAY
127315: PUSH
127316: LD_VAR 0 5
127320: ARRAY
127321: PUSH
127322: LD_INT 1
127324: ARRAY
127325: PPUSH
127326: LD_EXP 212
127330: PUSH
127331: LD_VAR 0 6
127335: ARRAY
127336: PUSH
127337: LD_VAR 0 5
127341: ARRAY
127342: PUSH
127343: LD_INT 2
127345: ARRAY
127346: PPUSH
127347: LD_VAR 0 1
127351: PPUSH
127352: CALL_OW 255
127356: PPUSH
127357: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127361: LD_ADDR_EXP 212
127365: PUSH
127366: LD_EXP 212
127370: PPUSH
127371: LD_VAR 0 6
127375: PPUSH
127376: LD_EXP 212
127380: PUSH
127381: LD_VAR 0 6
127385: ARRAY
127386: PPUSH
127387: LD_VAR 0 5
127391: PPUSH
127392: CALL_OW 3
127396: PPUSH
127397: CALL_OW 1
127401: ST_TO_ADDR
// exit ;
127402: POP
127403: POP
127404: GO 127597
// end ; end ;
127406: GO 127246
127408: POP
127409: POP
// for i := minerMinesList [ index ] downto 1 do
127410: LD_ADDR_VAR 0 5
127414: PUSH
127415: DOUBLE
127416: LD_EXP 212
127420: PUSH
127421: LD_VAR 0 6
127425: ARRAY
127426: INC
127427: ST_TO_ADDR
127428: LD_INT 1
127430: PUSH
127431: FOR_DOWNTO
127432: IFFALSE 127595
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
127434: LD_EXP 212
127438: PUSH
127439: LD_VAR 0 6
127443: ARRAY
127444: PUSH
127445: LD_VAR 0 5
127449: ARRAY
127450: PUSH
127451: LD_INT 1
127453: ARRAY
127454: PPUSH
127455: LD_EXP 212
127459: PUSH
127460: LD_VAR 0 6
127464: ARRAY
127465: PUSH
127466: LD_VAR 0 5
127470: ARRAY
127471: PUSH
127472: LD_INT 2
127474: ARRAY
127475: PPUSH
127476: LD_VAR 0 2
127480: PPUSH
127481: LD_VAR 0 3
127485: PPUSH
127486: CALL_OW 298
127490: PUSH
127491: LD_INT 6
127493: LESS
127494: IFFALSE 127593
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
127496: LD_EXP 212
127500: PUSH
127501: LD_VAR 0 6
127505: ARRAY
127506: PUSH
127507: LD_VAR 0 5
127511: ARRAY
127512: PUSH
127513: LD_INT 1
127515: ARRAY
127516: PPUSH
127517: LD_EXP 212
127521: PUSH
127522: LD_VAR 0 6
127526: ARRAY
127527: PUSH
127528: LD_VAR 0 5
127532: ARRAY
127533: PUSH
127534: LD_INT 2
127536: ARRAY
127537: PPUSH
127538: LD_VAR 0 1
127542: PPUSH
127543: CALL_OW 255
127547: PPUSH
127548: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
127552: LD_ADDR_EXP 212
127556: PUSH
127557: LD_EXP 212
127561: PPUSH
127562: LD_VAR 0 6
127566: PPUSH
127567: LD_EXP 212
127571: PUSH
127572: LD_VAR 0 6
127576: ARRAY
127577: PPUSH
127578: LD_VAR 0 5
127582: PPUSH
127583: CALL_OW 3
127587: PPUSH
127588: CALL_OW 1
127592: ST_TO_ADDR
// end ; end ;
127593: GO 127431
127595: POP
127596: POP
// end ;
127597: LD_VAR 0 4
127601: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
127602: LD_INT 0
127604: PPUSH
127605: PPUSH
127606: PPUSH
127607: PPUSH
127608: PPUSH
127609: PPUSH
127610: PPUSH
127611: PPUSH
127612: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
127613: LD_VAR 0 1
127617: PPUSH
127618: CALL_OW 264
127622: PUSH
127623: LD_INT 81
127625: EQUAL
127626: NOT
127627: PUSH
127628: LD_VAR 0 1
127632: PUSH
127633: LD_EXP 211
127637: IN
127638: NOT
127639: OR
127640: IFFALSE 127644
// exit ;
127642: GO 127966
// index := GetElementIndex ( minersList , unit ) ;
127644: LD_ADDR_VAR 0 6
127648: PUSH
127649: LD_EXP 211
127653: PPUSH
127654: LD_VAR 0 1
127658: PPUSH
127659: CALL 72117 0 2
127663: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
127664: LD_ADDR_VAR 0 8
127668: PUSH
127669: LD_EXP 213
127673: PUSH
127674: LD_EXP 212
127678: PUSH
127679: LD_VAR 0 6
127683: ARRAY
127684: MINUS
127685: ST_TO_ADDR
// if not minesFreeAmount then
127686: LD_VAR 0 8
127690: NOT
127691: IFFALSE 127695
// exit ;
127693: GO 127966
// tmp := [ ] ;
127695: LD_ADDR_VAR 0 7
127699: PUSH
127700: EMPTY
127701: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
127702: LD_ADDR_VAR 0 5
127706: PUSH
127707: DOUBLE
127708: LD_INT 1
127710: DEC
127711: ST_TO_ADDR
127712: LD_VAR 0 8
127716: PUSH
127717: FOR_TO
127718: IFFALSE 127913
// begin _d := rand ( 0 , 5 ) ;
127720: LD_ADDR_VAR 0 11
127724: PUSH
127725: LD_INT 0
127727: PPUSH
127728: LD_INT 5
127730: PPUSH
127731: CALL_OW 12
127735: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
127736: LD_ADDR_VAR 0 12
127740: PUSH
127741: LD_INT 2
127743: PPUSH
127744: LD_INT 6
127746: PPUSH
127747: CALL_OW 12
127751: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
127752: LD_ADDR_VAR 0 9
127756: PUSH
127757: LD_VAR 0 2
127761: PPUSH
127762: LD_VAR 0 11
127766: PPUSH
127767: LD_VAR 0 12
127771: PPUSH
127772: CALL_OW 272
127776: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
127777: LD_ADDR_VAR 0 10
127781: PUSH
127782: LD_VAR 0 3
127786: PPUSH
127787: LD_VAR 0 11
127791: PPUSH
127792: LD_VAR 0 12
127796: PPUSH
127797: CALL_OW 273
127801: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
127802: LD_VAR 0 9
127806: PPUSH
127807: LD_VAR 0 10
127811: PPUSH
127812: CALL_OW 488
127816: PUSH
127817: LD_VAR 0 9
127821: PUSH
127822: LD_VAR 0 10
127826: PUSH
127827: EMPTY
127828: LIST
127829: LIST
127830: PUSH
127831: LD_VAR 0 7
127835: IN
127836: NOT
127837: AND
127838: PUSH
127839: LD_VAR 0 9
127843: PPUSH
127844: LD_VAR 0 10
127848: PPUSH
127849: CALL_OW 458
127853: NOT
127854: AND
127855: IFFALSE 127897
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
127857: LD_ADDR_VAR 0 7
127861: PUSH
127862: LD_VAR 0 7
127866: PPUSH
127867: LD_VAR 0 7
127871: PUSH
127872: LD_INT 1
127874: PLUS
127875: PPUSH
127876: LD_VAR 0 9
127880: PUSH
127881: LD_VAR 0 10
127885: PUSH
127886: EMPTY
127887: LIST
127888: LIST
127889: PPUSH
127890: CALL_OW 1
127894: ST_TO_ADDR
127895: GO 127911
// i := i - 1 ;
127897: LD_ADDR_VAR 0 5
127901: PUSH
127902: LD_VAR 0 5
127906: PUSH
127907: LD_INT 1
127909: MINUS
127910: ST_TO_ADDR
// end ;
127911: GO 127717
127913: POP
127914: POP
// for i in tmp do
127915: LD_ADDR_VAR 0 5
127919: PUSH
127920: LD_VAR 0 7
127924: PUSH
127925: FOR_IN
127926: IFFALSE 127964
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
127928: LD_VAR 0 1
127932: PPUSH
127933: LD_VAR 0 5
127937: PUSH
127938: LD_INT 1
127940: ARRAY
127941: PPUSH
127942: LD_VAR 0 5
127946: PUSH
127947: LD_INT 2
127949: ARRAY
127950: PPUSH
127951: CALL 126910 0 3
127955: NOT
127956: IFFALSE 127962
// exit ;
127958: POP
127959: POP
127960: GO 127966
127962: GO 127925
127964: POP
127965: POP
// end ;
127966: LD_VAR 0 4
127970: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
127971: LD_INT 0
127973: PPUSH
127974: PPUSH
127975: PPUSH
127976: PPUSH
127977: PPUSH
127978: PPUSH
127979: PPUSH
// if not GetClass ( unit ) = class_sniper then
127980: LD_VAR 0 1
127984: PPUSH
127985: CALL_OW 257
127989: PUSH
127990: LD_INT 5
127992: EQUAL
127993: NOT
127994: IFFALSE 127998
// exit ;
127996: GO 128386
// dist := 8 ;
127998: LD_ADDR_VAR 0 5
128002: PUSH
128003: LD_INT 8
128005: ST_TO_ADDR
// viewRange := 12 ;
128006: LD_ADDR_VAR 0 7
128010: PUSH
128011: LD_INT 12
128013: ST_TO_ADDR
// side := GetSide ( unit ) ;
128014: LD_ADDR_VAR 0 6
128018: PUSH
128019: LD_VAR 0 1
128023: PPUSH
128024: CALL_OW 255
128028: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
128029: LD_INT 61
128031: PPUSH
128032: LD_VAR 0 6
128036: PPUSH
128037: CALL_OW 321
128041: PUSH
128042: LD_INT 2
128044: EQUAL
128045: IFFALSE 128055
// viewRange := 16 ;
128047: LD_ADDR_VAR 0 7
128051: PUSH
128052: LD_INT 16
128054: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
128055: LD_VAR 0 1
128059: PPUSH
128060: LD_VAR 0 2
128064: PPUSH
128065: LD_VAR 0 3
128069: PPUSH
128070: CALL_OW 297
128074: PUSH
128075: LD_VAR 0 5
128079: GREATER
128080: IFFALSE 128159
// begin ComMoveXY ( unit , x , y ) ;
128082: LD_VAR 0 1
128086: PPUSH
128087: LD_VAR 0 2
128091: PPUSH
128092: LD_VAR 0 3
128096: PPUSH
128097: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128101: LD_INT 35
128103: PPUSH
128104: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
128108: LD_VAR 0 1
128112: PPUSH
128113: LD_VAR 0 2
128117: PPUSH
128118: LD_VAR 0 3
128122: PPUSH
128123: CALL 103453 0 3
128127: NOT
128128: IFFALSE 128132
// exit ;
128130: GO 128386
// until GetDistUnitXY ( unit , x , y ) < dist ;
128132: LD_VAR 0 1
128136: PPUSH
128137: LD_VAR 0 2
128141: PPUSH
128142: LD_VAR 0 3
128146: PPUSH
128147: CALL_OW 297
128151: PUSH
128152: LD_VAR 0 5
128156: LESS
128157: IFFALSE 128101
// end ; ComTurnXY ( unit , x , y ) ;
128159: LD_VAR 0 1
128163: PPUSH
128164: LD_VAR 0 2
128168: PPUSH
128169: LD_VAR 0 3
128173: PPUSH
128174: CALL_OW 118
// wait ( 5 ) ;
128178: LD_INT 5
128180: PPUSH
128181: CALL_OW 67
// _d := GetDir ( unit ) ;
128185: LD_ADDR_VAR 0 10
128189: PUSH
128190: LD_VAR 0 1
128194: PPUSH
128195: CALL_OW 254
128199: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
128200: LD_ADDR_VAR 0 8
128204: PUSH
128205: LD_VAR 0 1
128209: PPUSH
128210: CALL_OW 250
128214: PPUSH
128215: LD_VAR 0 10
128219: PPUSH
128220: LD_VAR 0 5
128224: PPUSH
128225: CALL_OW 272
128229: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
128230: LD_ADDR_VAR 0 9
128234: PUSH
128235: LD_VAR 0 1
128239: PPUSH
128240: CALL_OW 251
128244: PPUSH
128245: LD_VAR 0 10
128249: PPUSH
128250: LD_VAR 0 5
128254: PPUSH
128255: CALL_OW 273
128259: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
128260: LD_VAR 0 8
128264: PPUSH
128265: LD_VAR 0 9
128269: PPUSH
128270: CALL_OW 488
128274: NOT
128275: IFFALSE 128279
// exit ;
128277: GO 128386
// ComAnimCustom ( unit , 1 ) ;
128279: LD_VAR 0 1
128283: PPUSH
128284: LD_INT 1
128286: PPUSH
128287: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
128291: LD_VAR 0 8
128295: PPUSH
128296: LD_VAR 0 9
128300: PPUSH
128301: LD_VAR 0 6
128305: PPUSH
128306: LD_VAR 0 7
128310: PPUSH
128311: CALL_OW 330
// repeat wait ( 1 ) ;
128315: LD_INT 1
128317: PPUSH
128318: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
128322: LD_VAR 0 1
128326: PPUSH
128327: CALL_OW 316
128331: PUSH
128332: LD_VAR 0 1
128336: PPUSH
128337: CALL_OW 314
128341: OR
128342: PUSH
128343: LD_VAR 0 1
128347: PPUSH
128348: CALL_OW 302
128352: NOT
128353: OR
128354: PUSH
128355: LD_VAR 0 1
128359: PPUSH
128360: CALL_OW 301
128364: OR
128365: IFFALSE 128315
// RemoveSeeing ( _x , _y , side ) ;
128367: LD_VAR 0 8
128371: PPUSH
128372: LD_VAR 0 9
128376: PPUSH
128377: LD_VAR 0 6
128381: PPUSH
128382: CALL_OW 331
// end ; end_of_file
128386: LD_VAR 0 4
128390: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
128391: LD_INT 0
128393: PPUSH
128394: PPUSH
128395: PPUSH
128396: PPUSH
128397: PPUSH
128398: PPUSH
128399: PPUSH
128400: PPUSH
128401: PPUSH
128402: PPUSH
128403: PPUSH
128404: PPUSH
128405: PPUSH
128406: PPUSH
128407: PPUSH
128408: PPUSH
128409: PPUSH
128410: PPUSH
128411: PPUSH
128412: PPUSH
128413: PPUSH
128414: PPUSH
128415: PPUSH
128416: PPUSH
128417: PPUSH
128418: PPUSH
128419: PPUSH
128420: PPUSH
128421: PPUSH
128422: PPUSH
128423: PPUSH
128424: PPUSH
128425: PPUSH
128426: PPUSH
// if not list then
128427: LD_VAR 0 1
128431: NOT
128432: IFFALSE 128436
// exit ;
128434: GO 133095
// base := list [ 1 ] ;
128436: LD_ADDR_VAR 0 3
128440: PUSH
128441: LD_VAR 0 1
128445: PUSH
128446: LD_INT 1
128448: ARRAY
128449: ST_TO_ADDR
// group := list [ 2 ] ;
128450: LD_ADDR_VAR 0 4
128454: PUSH
128455: LD_VAR 0 1
128459: PUSH
128460: LD_INT 2
128462: ARRAY
128463: ST_TO_ADDR
// path := list [ 3 ] ;
128464: LD_ADDR_VAR 0 5
128468: PUSH
128469: LD_VAR 0 1
128473: PUSH
128474: LD_INT 3
128476: ARRAY
128477: ST_TO_ADDR
// flags := list [ 4 ] ;
128478: LD_ADDR_VAR 0 6
128482: PUSH
128483: LD_VAR 0 1
128487: PUSH
128488: LD_INT 4
128490: ARRAY
128491: ST_TO_ADDR
// mined := [ ] ;
128492: LD_ADDR_VAR 0 27
128496: PUSH
128497: EMPTY
128498: ST_TO_ADDR
// bombed := [ ] ;
128499: LD_ADDR_VAR 0 28
128503: PUSH
128504: EMPTY
128505: ST_TO_ADDR
// healers := [ ] ;
128506: LD_ADDR_VAR 0 31
128510: PUSH
128511: EMPTY
128512: ST_TO_ADDR
// to_heal := [ ] ;
128513: LD_ADDR_VAR 0 30
128517: PUSH
128518: EMPTY
128519: ST_TO_ADDR
// repairs := [ ] ;
128520: LD_ADDR_VAR 0 33
128524: PUSH
128525: EMPTY
128526: ST_TO_ADDR
// to_repair := [ ] ;
128527: LD_ADDR_VAR 0 32
128531: PUSH
128532: EMPTY
128533: ST_TO_ADDR
// if not group or not path then
128534: LD_VAR 0 4
128538: NOT
128539: PUSH
128540: LD_VAR 0 5
128544: NOT
128545: OR
128546: IFFALSE 128550
// exit ;
128548: GO 133095
// side := GetSide ( group [ 1 ] ) ;
128550: LD_ADDR_VAR 0 35
128554: PUSH
128555: LD_VAR 0 4
128559: PUSH
128560: LD_INT 1
128562: ARRAY
128563: PPUSH
128564: CALL_OW 255
128568: ST_TO_ADDR
// if flags then
128569: LD_VAR 0 6
128573: IFFALSE 128717
// begin f_ignore_area := flags [ 1 ] ;
128575: LD_ADDR_VAR 0 17
128579: PUSH
128580: LD_VAR 0 6
128584: PUSH
128585: LD_INT 1
128587: ARRAY
128588: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
128589: LD_ADDR_VAR 0 18
128593: PUSH
128594: LD_VAR 0 6
128598: PUSH
128599: LD_INT 2
128601: ARRAY
128602: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
128603: LD_ADDR_VAR 0 19
128607: PUSH
128608: LD_VAR 0 6
128612: PUSH
128613: LD_INT 3
128615: ARRAY
128616: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
128617: LD_ADDR_VAR 0 20
128621: PUSH
128622: LD_VAR 0 6
128626: PUSH
128627: LD_INT 4
128629: ARRAY
128630: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
128631: LD_ADDR_VAR 0 21
128635: PUSH
128636: LD_VAR 0 6
128640: PUSH
128641: LD_INT 5
128643: ARRAY
128644: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
128645: LD_ADDR_VAR 0 22
128649: PUSH
128650: LD_VAR 0 6
128654: PUSH
128655: LD_INT 6
128657: ARRAY
128658: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
128659: LD_ADDR_VAR 0 23
128663: PUSH
128664: LD_VAR 0 6
128668: PUSH
128669: LD_INT 7
128671: ARRAY
128672: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
128673: LD_ADDR_VAR 0 24
128677: PUSH
128678: LD_VAR 0 6
128682: PUSH
128683: LD_INT 8
128685: ARRAY
128686: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
128687: LD_ADDR_VAR 0 25
128691: PUSH
128692: LD_VAR 0 6
128696: PUSH
128697: LD_INT 9
128699: ARRAY
128700: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
128701: LD_ADDR_VAR 0 26
128705: PUSH
128706: LD_VAR 0 6
128710: PUSH
128711: LD_INT 10
128713: ARRAY
128714: ST_TO_ADDR
// end else
128715: GO 128797
// begin f_ignore_area := false ;
128717: LD_ADDR_VAR 0 17
128721: PUSH
128722: LD_INT 0
128724: ST_TO_ADDR
// f_capture := false ;
128725: LD_ADDR_VAR 0 18
128729: PUSH
128730: LD_INT 0
128732: ST_TO_ADDR
// f_ignore_civ := false ;
128733: LD_ADDR_VAR 0 19
128737: PUSH
128738: LD_INT 0
128740: ST_TO_ADDR
// f_murder := false ;
128741: LD_ADDR_VAR 0 20
128745: PUSH
128746: LD_INT 0
128748: ST_TO_ADDR
// f_mines := false ;
128749: LD_ADDR_VAR 0 21
128753: PUSH
128754: LD_INT 0
128756: ST_TO_ADDR
// f_repair := false ;
128757: LD_ADDR_VAR 0 22
128761: PUSH
128762: LD_INT 0
128764: ST_TO_ADDR
// f_heal := false ;
128765: LD_ADDR_VAR 0 23
128769: PUSH
128770: LD_INT 0
128772: ST_TO_ADDR
// f_spacetime := false ;
128773: LD_ADDR_VAR 0 24
128777: PUSH
128778: LD_INT 0
128780: ST_TO_ADDR
// f_attack_depot := false ;
128781: LD_ADDR_VAR 0 25
128785: PUSH
128786: LD_INT 0
128788: ST_TO_ADDR
// f_crawl := false ;
128789: LD_ADDR_VAR 0 26
128793: PUSH
128794: LD_INT 0
128796: ST_TO_ADDR
// end ; if f_heal then
128797: LD_VAR 0 23
128801: IFFALSE 128828
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
128803: LD_ADDR_VAR 0 31
128807: PUSH
128808: LD_VAR 0 4
128812: PPUSH
128813: LD_INT 25
128815: PUSH
128816: LD_INT 4
128818: PUSH
128819: EMPTY
128820: LIST
128821: LIST
128822: PPUSH
128823: CALL_OW 72
128827: ST_TO_ADDR
// if f_repair then
128828: LD_VAR 0 22
128832: IFFALSE 128859
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
128834: LD_ADDR_VAR 0 33
128838: PUSH
128839: LD_VAR 0 4
128843: PPUSH
128844: LD_INT 25
128846: PUSH
128847: LD_INT 3
128849: PUSH
128850: EMPTY
128851: LIST
128852: LIST
128853: PPUSH
128854: CALL_OW 72
128858: ST_TO_ADDR
// units_path := [ ] ;
128859: LD_ADDR_VAR 0 16
128863: PUSH
128864: EMPTY
128865: ST_TO_ADDR
// for i = 1 to group do
128866: LD_ADDR_VAR 0 7
128870: PUSH
128871: DOUBLE
128872: LD_INT 1
128874: DEC
128875: ST_TO_ADDR
128876: LD_VAR 0 4
128880: PUSH
128881: FOR_TO
128882: IFFALSE 128911
// units_path := Replace ( units_path , i , path ) ;
128884: LD_ADDR_VAR 0 16
128888: PUSH
128889: LD_VAR 0 16
128893: PPUSH
128894: LD_VAR 0 7
128898: PPUSH
128899: LD_VAR 0 5
128903: PPUSH
128904: CALL_OW 1
128908: ST_TO_ADDR
128909: GO 128881
128911: POP
128912: POP
// repeat for i = group downto 1 do
128913: LD_ADDR_VAR 0 7
128917: PUSH
128918: DOUBLE
128919: LD_VAR 0 4
128923: INC
128924: ST_TO_ADDR
128925: LD_INT 1
128927: PUSH
128928: FOR_DOWNTO
128929: IFFALSE 133051
// begin wait ( 5 ) ;
128931: LD_INT 5
128933: PPUSH
128934: CALL_OW 67
// tmp := [ ] ;
128938: LD_ADDR_VAR 0 14
128942: PUSH
128943: EMPTY
128944: ST_TO_ADDR
// attacking := false ;
128945: LD_ADDR_VAR 0 29
128949: PUSH
128950: LD_INT 0
128952: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
128953: LD_VAR 0 4
128957: PUSH
128958: LD_VAR 0 7
128962: ARRAY
128963: PPUSH
128964: CALL_OW 301
128968: PUSH
128969: LD_VAR 0 4
128973: PUSH
128974: LD_VAR 0 7
128978: ARRAY
128979: NOT
128980: OR
128981: IFFALSE 129090
// begin if GetType ( group [ i ] ) = unit_human then
128983: LD_VAR 0 4
128987: PUSH
128988: LD_VAR 0 7
128992: ARRAY
128993: PPUSH
128994: CALL_OW 247
128998: PUSH
128999: LD_INT 1
129001: EQUAL
129002: IFFALSE 129048
// begin to_heal := to_heal diff group [ i ] ;
129004: LD_ADDR_VAR 0 30
129008: PUSH
129009: LD_VAR 0 30
129013: PUSH
129014: LD_VAR 0 4
129018: PUSH
129019: LD_VAR 0 7
129023: ARRAY
129024: DIFF
129025: ST_TO_ADDR
// healers := healers diff group [ i ] ;
129026: LD_ADDR_VAR 0 31
129030: PUSH
129031: LD_VAR 0 31
129035: PUSH
129036: LD_VAR 0 4
129040: PUSH
129041: LD_VAR 0 7
129045: ARRAY
129046: DIFF
129047: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
129048: LD_ADDR_VAR 0 4
129052: PUSH
129053: LD_VAR 0 4
129057: PPUSH
129058: LD_VAR 0 7
129062: PPUSH
129063: CALL_OW 3
129067: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
129068: LD_ADDR_VAR 0 16
129072: PUSH
129073: LD_VAR 0 16
129077: PPUSH
129078: LD_VAR 0 7
129082: PPUSH
129083: CALL_OW 3
129087: ST_TO_ADDR
// continue ;
129088: GO 128928
// end ; if f_repair then
129090: LD_VAR 0 22
129094: IFFALSE 129583
// begin if GetType ( group [ i ] ) = unit_vehicle then
129096: LD_VAR 0 4
129100: PUSH
129101: LD_VAR 0 7
129105: ARRAY
129106: PPUSH
129107: CALL_OW 247
129111: PUSH
129112: LD_INT 2
129114: EQUAL
129115: IFFALSE 129305
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
129117: LD_VAR 0 4
129121: PUSH
129122: LD_VAR 0 7
129126: ARRAY
129127: PPUSH
129128: CALL_OW 256
129132: PUSH
129133: LD_INT 700
129135: LESS
129136: PUSH
129137: LD_VAR 0 4
129141: PUSH
129142: LD_VAR 0 7
129146: ARRAY
129147: PUSH
129148: LD_VAR 0 32
129152: IN
129153: NOT
129154: AND
129155: IFFALSE 129179
// to_repair := to_repair union group [ i ] ;
129157: LD_ADDR_VAR 0 32
129161: PUSH
129162: LD_VAR 0 32
129166: PUSH
129167: LD_VAR 0 4
129171: PUSH
129172: LD_VAR 0 7
129176: ARRAY
129177: UNION
129178: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
129179: LD_VAR 0 4
129183: PUSH
129184: LD_VAR 0 7
129188: ARRAY
129189: PPUSH
129190: CALL_OW 256
129194: PUSH
129195: LD_INT 1000
129197: EQUAL
129198: PUSH
129199: LD_VAR 0 4
129203: PUSH
129204: LD_VAR 0 7
129208: ARRAY
129209: PUSH
129210: LD_VAR 0 32
129214: IN
129215: AND
129216: IFFALSE 129240
// to_repair := to_repair diff group [ i ] ;
129218: LD_ADDR_VAR 0 32
129222: PUSH
129223: LD_VAR 0 32
129227: PUSH
129228: LD_VAR 0 4
129232: PUSH
129233: LD_VAR 0 7
129237: ARRAY
129238: DIFF
129239: ST_TO_ADDR
// if group [ i ] in to_repair then
129240: LD_VAR 0 4
129244: PUSH
129245: LD_VAR 0 7
129249: ARRAY
129250: PUSH
129251: LD_VAR 0 32
129255: IN
129256: IFFALSE 129303
// begin if not IsInArea ( group [ i ] , f_repair ) then
129258: LD_VAR 0 4
129262: PUSH
129263: LD_VAR 0 7
129267: ARRAY
129268: PPUSH
129269: LD_VAR 0 22
129273: PPUSH
129274: CALL_OW 308
129278: NOT
129279: IFFALSE 129301
// ComMoveToArea ( group [ i ] , f_repair ) ;
129281: LD_VAR 0 4
129285: PUSH
129286: LD_VAR 0 7
129290: ARRAY
129291: PPUSH
129292: LD_VAR 0 22
129296: PPUSH
129297: CALL_OW 113
// continue ;
129301: GO 128928
// end ; end else
129303: GO 129583
// if group [ i ] in repairs then
129305: LD_VAR 0 4
129309: PUSH
129310: LD_VAR 0 7
129314: ARRAY
129315: PUSH
129316: LD_VAR 0 33
129320: IN
129321: IFFALSE 129583
// begin if IsInUnit ( group [ i ] ) then
129323: LD_VAR 0 4
129327: PUSH
129328: LD_VAR 0 7
129332: ARRAY
129333: PPUSH
129334: CALL_OW 310
129338: IFFALSE 129406
// begin z := IsInUnit ( group [ i ] ) ;
129340: LD_ADDR_VAR 0 13
129344: PUSH
129345: LD_VAR 0 4
129349: PUSH
129350: LD_VAR 0 7
129354: ARRAY
129355: PPUSH
129356: CALL_OW 310
129360: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
129361: LD_VAR 0 13
129365: PUSH
129366: LD_VAR 0 32
129370: IN
129371: PUSH
129372: LD_VAR 0 13
129376: PPUSH
129377: LD_VAR 0 22
129381: PPUSH
129382: CALL_OW 308
129386: AND
129387: IFFALSE 129404
// ComExitVehicle ( group [ i ] ) ;
129389: LD_VAR 0 4
129393: PUSH
129394: LD_VAR 0 7
129398: ARRAY
129399: PPUSH
129400: CALL_OW 121
// end else
129404: GO 129583
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
129406: LD_ADDR_VAR 0 13
129410: PUSH
129411: LD_VAR 0 4
129415: PPUSH
129416: LD_INT 95
129418: PUSH
129419: LD_VAR 0 22
129423: PUSH
129424: EMPTY
129425: LIST
129426: LIST
129427: PUSH
129428: LD_INT 58
129430: PUSH
129431: EMPTY
129432: LIST
129433: PUSH
129434: EMPTY
129435: LIST
129436: LIST
129437: PPUSH
129438: CALL_OW 72
129442: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
129443: LD_VAR 0 4
129447: PUSH
129448: LD_VAR 0 7
129452: ARRAY
129453: PPUSH
129454: CALL_OW 314
129458: NOT
129459: IFFALSE 129581
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
129461: LD_ADDR_VAR 0 10
129465: PUSH
129466: LD_VAR 0 13
129470: PPUSH
129471: LD_VAR 0 4
129475: PUSH
129476: LD_VAR 0 7
129480: ARRAY
129481: PPUSH
129482: CALL_OW 74
129486: ST_TO_ADDR
// if not x then
129487: LD_VAR 0 10
129491: NOT
129492: IFFALSE 129496
// continue ;
129494: GO 128928
// if GetLives ( x ) < 1000 then
129496: LD_VAR 0 10
129500: PPUSH
129501: CALL_OW 256
129505: PUSH
129506: LD_INT 1000
129508: LESS
129509: IFFALSE 129533
// ComRepairVehicle ( group [ i ] , x ) else
129511: LD_VAR 0 4
129515: PUSH
129516: LD_VAR 0 7
129520: ARRAY
129521: PPUSH
129522: LD_VAR 0 10
129526: PPUSH
129527: CALL_OW 129
129531: GO 129581
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
129533: LD_VAR 0 23
129537: PUSH
129538: LD_VAR 0 4
129542: PUSH
129543: LD_VAR 0 7
129547: ARRAY
129548: PPUSH
129549: CALL_OW 256
129553: PUSH
129554: LD_INT 1000
129556: LESS
129557: AND
129558: NOT
129559: IFFALSE 129581
// ComEnterUnit ( group [ i ] , x ) ;
129561: LD_VAR 0 4
129565: PUSH
129566: LD_VAR 0 7
129570: ARRAY
129571: PPUSH
129572: LD_VAR 0 10
129576: PPUSH
129577: CALL_OW 120
// end ; continue ;
129581: GO 128928
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
129583: LD_VAR 0 23
129587: PUSH
129588: LD_VAR 0 4
129592: PUSH
129593: LD_VAR 0 7
129597: ARRAY
129598: PPUSH
129599: CALL_OW 247
129603: PUSH
129604: LD_INT 1
129606: EQUAL
129607: AND
129608: IFFALSE 130086
// begin if group [ i ] in healers then
129610: LD_VAR 0 4
129614: PUSH
129615: LD_VAR 0 7
129619: ARRAY
129620: PUSH
129621: LD_VAR 0 31
129625: IN
129626: IFFALSE 129899
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
129628: LD_VAR 0 4
129632: PUSH
129633: LD_VAR 0 7
129637: ARRAY
129638: PPUSH
129639: LD_VAR 0 23
129643: PPUSH
129644: CALL_OW 308
129648: NOT
129649: PUSH
129650: LD_VAR 0 4
129654: PUSH
129655: LD_VAR 0 7
129659: ARRAY
129660: PPUSH
129661: CALL_OW 314
129665: NOT
129666: AND
129667: IFFALSE 129691
// ComMoveToArea ( group [ i ] , f_heal ) else
129669: LD_VAR 0 4
129673: PUSH
129674: LD_VAR 0 7
129678: ARRAY
129679: PPUSH
129680: LD_VAR 0 23
129684: PPUSH
129685: CALL_OW 113
129689: GO 129897
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
129691: LD_VAR 0 4
129695: PUSH
129696: LD_VAR 0 7
129700: ARRAY
129701: PPUSH
129702: CALL 102029 0 1
129706: PPUSH
129707: CALL_OW 256
129711: PUSH
129712: LD_INT 1000
129714: EQUAL
129715: IFFALSE 129734
// ComStop ( group [ i ] ) else
129717: LD_VAR 0 4
129721: PUSH
129722: LD_VAR 0 7
129726: ARRAY
129727: PPUSH
129728: CALL_OW 141
129732: GO 129897
// if not HasTask ( group [ i ] ) and to_heal then
129734: LD_VAR 0 4
129738: PUSH
129739: LD_VAR 0 7
129743: ARRAY
129744: PPUSH
129745: CALL_OW 314
129749: NOT
129750: PUSH
129751: LD_VAR 0 30
129755: AND
129756: IFFALSE 129897
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
129758: LD_ADDR_VAR 0 13
129762: PUSH
129763: LD_VAR 0 30
129767: PPUSH
129768: LD_INT 3
129770: PUSH
129771: LD_INT 54
129773: PUSH
129774: EMPTY
129775: LIST
129776: PUSH
129777: EMPTY
129778: LIST
129779: LIST
129780: PPUSH
129781: CALL_OW 72
129785: PPUSH
129786: LD_VAR 0 4
129790: PUSH
129791: LD_VAR 0 7
129795: ARRAY
129796: PPUSH
129797: CALL_OW 74
129801: ST_TO_ADDR
// if z then
129802: LD_VAR 0 13
129806: IFFALSE 129897
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
129808: LD_INT 91
129810: PUSH
129811: LD_VAR 0 13
129815: PUSH
129816: LD_INT 10
129818: PUSH
129819: EMPTY
129820: LIST
129821: LIST
129822: LIST
129823: PUSH
129824: LD_INT 81
129826: PUSH
129827: LD_VAR 0 13
129831: PPUSH
129832: CALL_OW 255
129836: PUSH
129837: EMPTY
129838: LIST
129839: LIST
129840: PUSH
129841: EMPTY
129842: LIST
129843: LIST
129844: PPUSH
129845: CALL_OW 69
129849: PUSH
129850: LD_INT 0
129852: EQUAL
129853: IFFALSE 129877
// ComHeal ( group [ i ] , z ) else
129855: LD_VAR 0 4
129859: PUSH
129860: LD_VAR 0 7
129864: ARRAY
129865: PPUSH
129866: LD_VAR 0 13
129870: PPUSH
129871: CALL_OW 128
129875: GO 129897
// ComMoveToArea ( group [ i ] , f_heal ) ;
129877: LD_VAR 0 4
129881: PUSH
129882: LD_VAR 0 7
129886: ARRAY
129887: PPUSH
129888: LD_VAR 0 23
129892: PPUSH
129893: CALL_OW 113
// end ; continue ;
129897: GO 128928
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
129899: LD_VAR 0 4
129903: PUSH
129904: LD_VAR 0 7
129908: ARRAY
129909: PPUSH
129910: CALL_OW 256
129914: PUSH
129915: LD_INT 700
129917: LESS
129918: PUSH
129919: LD_VAR 0 4
129923: PUSH
129924: LD_VAR 0 7
129928: ARRAY
129929: PUSH
129930: LD_VAR 0 30
129934: IN
129935: NOT
129936: AND
129937: IFFALSE 129961
// to_heal := to_heal union group [ i ] ;
129939: LD_ADDR_VAR 0 30
129943: PUSH
129944: LD_VAR 0 30
129948: PUSH
129949: LD_VAR 0 4
129953: PUSH
129954: LD_VAR 0 7
129958: ARRAY
129959: UNION
129960: ST_TO_ADDR
// if group [ i ] in to_heal then
129961: LD_VAR 0 4
129965: PUSH
129966: LD_VAR 0 7
129970: ARRAY
129971: PUSH
129972: LD_VAR 0 30
129976: IN
129977: IFFALSE 130086
// begin if GetLives ( group [ i ] ) = 1000 then
129979: LD_VAR 0 4
129983: PUSH
129984: LD_VAR 0 7
129988: ARRAY
129989: PPUSH
129990: CALL_OW 256
129994: PUSH
129995: LD_INT 1000
129997: EQUAL
129998: IFFALSE 130024
// to_heal := to_heal diff group [ i ] else
130000: LD_ADDR_VAR 0 30
130004: PUSH
130005: LD_VAR 0 30
130009: PUSH
130010: LD_VAR 0 4
130014: PUSH
130015: LD_VAR 0 7
130019: ARRAY
130020: DIFF
130021: ST_TO_ADDR
130022: GO 130086
// begin if not IsInArea ( group [ i ] , to_heal ) then
130024: LD_VAR 0 4
130028: PUSH
130029: LD_VAR 0 7
130033: ARRAY
130034: PPUSH
130035: LD_VAR 0 30
130039: PPUSH
130040: CALL_OW 308
130044: NOT
130045: IFFALSE 130069
// ComMoveToArea ( group [ i ] , f_heal ) else
130047: LD_VAR 0 4
130051: PUSH
130052: LD_VAR 0 7
130056: ARRAY
130057: PPUSH
130058: LD_VAR 0 23
130062: PPUSH
130063: CALL_OW 113
130067: GO 130084
// ComHold ( group [ i ] ) ;
130069: LD_VAR 0 4
130073: PUSH
130074: LD_VAR 0 7
130078: ARRAY
130079: PPUSH
130080: CALL_OW 140
// continue ;
130084: GO 128928
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
130086: LD_VAR 0 4
130090: PUSH
130091: LD_VAR 0 7
130095: ARRAY
130096: PPUSH
130097: LD_INT 10
130099: PPUSH
130100: CALL 99826 0 2
130104: NOT
130105: PUSH
130106: LD_VAR 0 16
130110: PUSH
130111: LD_VAR 0 7
130115: ARRAY
130116: PUSH
130117: EMPTY
130118: EQUAL
130119: NOT
130120: AND
130121: IFFALSE 130387
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
130123: LD_VAR 0 4
130127: PUSH
130128: LD_VAR 0 7
130132: ARRAY
130133: PPUSH
130134: CALL_OW 262
130138: PUSH
130139: LD_INT 1
130141: PUSH
130142: LD_INT 2
130144: PUSH
130145: EMPTY
130146: LIST
130147: LIST
130148: IN
130149: IFFALSE 130190
// if GetFuel ( group [ i ] ) < 10 then
130151: LD_VAR 0 4
130155: PUSH
130156: LD_VAR 0 7
130160: ARRAY
130161: PPUSH
130162: CALL_OW 261
130166: PUSH
130167: LD_INT 10
130169: LESS
130170: IFFALSE 130190
// SetFuel ( group [ i ] , 12 ) ;
130172: LD_VAR 0 4
130176: PUSH
130177: LD_VAR 0 7
130181: ARRAY
130182: PPUSH
130183: LD_INT 12
130185: PPUSH
130186: CALL_OW 240
// if units_path [ i ] then
130190: LD_VAR 0 16
130194: PUSH
130195: LD_VAR 0 7
130199: ARRAY
130200: IFFALSE 130385
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
130202: LD_VAR 0 4
130206: PUSH
130207: LD_VAR 0 7
130211: ARRAY
130212: PPUSH
130213: LD_VAR 0 16
130217: PUSH
130218: LD_VAR 0 7
130222: ARRAY
130223: PUSH
130224: LD_INT 1
130226: ARRAY
130227: PUSH
130228: LD_INT 1
130230: ARRAY
130231: PPUSH
130232: LD_VAR 0 16
130236: PUSH
130237: LD_VAR 0 7
130241: ARRAY
130242: PUSH
130243: LD_INT 1
130245: ARRAY
130246: PUSH
130247: LD_INT 2
130249: ARRAY
130250: PPUSH
130251: CALL_OW 297
130255: PUSH
130256: LD_INT 6
130258: GREATER
130259: IFFALSE 130334
// begin if not HasTask ( group [ i ] ) then
130261: LD_VAR 0 4
130265: PUSH
130266: LD_VAR 0 7
130270: ARRAY
130271: PPUSH
130272: CALL_OW 314
130276: NOT
130277: IFFALSE 130332
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
130279: LD_VAR 0 4
130283: PUSH
130284: LD_VAR 0 7
130288: ARRAY
130289: PPUSH
130290: LD_VAR 0 16
130294: PUSH
130295: LD_VAR 0 7
130299: ARRAY
130300: PUSH
130301: LD_INT 1
130303: ARRAY
130304: PUSH
130305: LD_INT 1
130307: ARRAY
130308: PPUSH
130309: LD_VAR 0 16
130313: PUSH
130314: LD_VAR 0 7
130318: ARRAY
130319: PUSH
130320: LD_INT 1
130322: ARRAY
130323: PUSH
130324: LD_INT 2
130326: ARRAY
130327: PPUSH
130328: CALL_OW 114
// end else
130332: GO 130385
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
130334: LD_ADDR_VAR 0 15
130338: PUSH
130339: LD_VAR 0 16
130343: PUSH
130344: LD_VAR 0 7
130348: ARRAY
130349: PPUSH
130350: LD_INT 1
130352: PPUSH
130353: CALL_OW 3
130357: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
130358: LD_ADDR_VAR 0 16
130362: PUSH
130363: LD_VAR 0 16
130367: PPUSH
130368: LD_VAR 0 7
130372: PPUSH
130373: LD_VAR 0 15
130377: PPUSH
130378: CALL_OW 1
130382: ST_TO_ADDR
// continue ;
130383: GO 128928
// end ; end ; end else
130385: GO 133049
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
130387: LD_ADDR_VAR 0 14
130391: PUSH
130392: LD_INT 81
130394: PUSH
130395: LD_VAR 0 4
130399: PUSH
130400: LD_VAR 0 7
130404: ARRAY
130405: PPUSH
130406: CALL_OW 255
130410: PUSH
130411: EMPTY
130412: LIST
130413: LIST
130414: PPUSH
130415: CALL_OW 69
130419: ST_TO_ADDR
// if not tmp then
130420: LD_VAR 0 14
130424: NOT
130425: IFFALSE 130429
// continue ;
130427: GO 128928
// if f_ignore_area then
130429: LD_VAR 0 17
130433: IFFALSE 130521
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
130435: LD_ADDR_VAR 0 15
130439: PUSH
130440: LD_VAR 0 14
130444: PPUSH
130445: LD_INT 3
130447: PUSH
130448: LD_INT 92
130450: PUSH
130451: LD_VAR 0 17
130455: PUSH
130456: LD_INT 1
130458: ARRAY
130459: PUSH
130460: LD_VAR 0 17
130464: PUSH
130465: LD_INT 2
130467: ARRAY
130468: PUSH
130469: LD_VAR 0 17
130473: PUSH
130474: LD_INT 3
130476: ARRAY
130477: PUSH
130478: EMPTY
130479: LIST
130480: LIST
130481: LIST
130482: LIST
130483: PUSH
130484: EMPTY
130485: LIST
130486: LIST
130487: PPUSH
130488: CALL_OW 72
130492: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130493: LD_VAR 0 14
130497: PUSH
130498: LD_VAR 0 15
130502: DIFF
130503: IFFALSE 130521
// tmp := tmp diff tmp2 ;
130505: LD_ADDR_VAR 0 14
130509: PUSH
130510: LD_VAR 0 14
130514: PUSH
130515: LD_VAR 0 15
130519: DIFF
130520: ST_TO_ADDR
// end ; if not f_murder then
130521: LD_VAR 0 20
130525: NOT
130526: IFFALSE 130584
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
130528: LD_ADDR_VAR 0 15
130532: PUSH
130533: LD_VAR 0 14
130537: PPUSH
130538: LD_INT 3
130540: PUSH
130541: LD_INT 50
130543: PUSH
130544: EMPTY
130545: LIST
130546: PUSH
130547: EMPTY
130548: LIST
130549: LIST
130550: PPUSH
130551: CALL_OW 72
130555: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
130556: LD_VAR 0 14
130560: PUSH
130561: LD_VAR 0 15
130565: DIFF
130566: IFFALSE 130584
// tmp := tmp diff tmp2 ;
130568: LD_ADDR_VAR 0 14
130572: PUSH
130573: LD_VAR 0 14
130577: PUSH
130578: LD_VAR 0 15
130582: DIFF
130583: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
130584: LD_ADDR_VAR 0 14
130588: PUSH
130589: LD_VAR 0 4
130593: PUSH
130594: LD_VAR 0 7
130598: ARRAY
130599: PPUSH
130600: LD_VAR 0 14
130604: PPUSH
130605: LD_INT 1
130607: PPUSH
130608: LD_INT 1
130610: PPUSH
130611: CALL 72767 0 4
130615: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
130616: LD_VAR 0 4
130620: PUSH
130621: LD_VAR 0 7
130625: ARRAY
130626: PPUSH
130627: CALL_OW 257
130631: PUSH
130632: LD_INT 1
130634: EQUAL
130635: IFFALSE 131083
// begin if WantPlant ( group [ i ] ) then
130637: LD_VAR 0 4
130641: PUSH
130642: LD_VAR 0 7
130646: ARRAY
130647: PPUSH
130648: CALL 72268 0 1
130652: IFFALSE 130656
// continue ;
130654: GO 128928
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
130656: LD_VAR 0 18
130660: PUSH
130661: LD_VAR 0 4
130665: PUSH
130666: LD_VAR 0 7
130670: ARRAY
130671: PPUSH
130672: CALL_OW 310
130676: NOT
130677: AND
130678: PUSH
130679: LD_VAR 0 14
130683: PUSH
130684: LD_INT 1
130686: ARRAY
130687: PUSH
130688: LD_VAR 0 14
130692: PPUSH
130693: LD_INT 21
130695: PUSH
130696: LD_INT 2
130698: PUSH
130699: EMPTY
130700: LIST
130701: LIST
130702: PUSH
130703: LD_INT 58
130705: PUSH
130706: EMPTY
130707: LIST
130708: PUSH
130709: EMPTY
130710: LIST
130711: LIST
130712: PPUSH
130713: CALL_OW 72
130717: IN
130718: AND
130719: IFFALSE 130755
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
130721: LD_VAR 0 4
130725: PUSH
130726: LD_VAR 0 7
130730: ARRAY
130731: PPUSH
130732: LD_VAR 0 14
130736: PUSH
130737: LD_INT 1
130739: ARRAY
130740: PPUSH
130741: CALL_OW 120
// attacking := true ;
130745: LD_ADDR_VAR 0 29
130749: PUSH
130750: LD_INT 1
130752: ST_TO_ADDR
// continue ;
130753: GO 128928
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
130755: LD_VAR 0 26
130759: PUSH
130760: LD_VAR 0 4
130764: PUSH
130765: LD_VAR 0 7
130769: ARRAY
130770: PPUSH
130771: CALL_OW 257
130775: PUSH
130776: LD_INT 1
130778: EQUAL
130779: AND
130780: PUSH
130781: LD_VAR 0 4
130785: PUSH
130786: LD_VAR 0 7
130790: ARRAY
130791: PPUSH
130792: CALL_OW 256
130796: PUSH
130797: LD_INT 800
130799: LESS
130800: AND
130801: PUSH
130802: LD_VAR 0 4
130806: PUSH
130807: LD_VAR 0 7
130811: ARRAY
130812: PPUSH
130813: CALL_OW 318
130817: NOT
130818: AND
130819: IFFALSE 130836
// ComCrawl ( group [ i ] ) ;
130821: LD_VAR 0 4
130825: PUSH
130826: LD_VAR 0 7
130830: ARRAY
130831: PPUSH
130832: CALL_OW 137
// if f_mines then
130836: LD_VAR 0 21
130840: IFFALSE 131083
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
130842: LD_VAR 0 14
130846: PUSH
130847: LD_INT 1
130849: ARRAY
130850: PPUSH
130851: CALL_OW 247
130855: PUSH
130856: LD_INT 3
130858: EQUAL
130859: PUSH
130860: LD_VAR 0 14
130864: PUSH
130865: LD_INT 1
130867: ARRAY
130868: PUSH
130869: LD_VAR 0 27
130873: IN
130874: NOT
130875: AND
130876: IFFALSE 131083
// begin x := GetX ( tmp [ 1 ] ) ;
130878: LD_ADDR_VAR 0 10
130882: PUSH
130883: LD_VAR 0 14
130887: PUSH
130888: LD_INT 1
130890: ARRAY
130891: PPUSH
130892: CALL_OW 250
130896: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
130897: LD_ADDR_VAR 0 11
130901: PUSH
130902: LD_VAR 0 14
130906: PUSH
130907: LD_INT 1
130909: ARRAY
130910: PPUSH
130911: CALL_OW 251
130915: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
130916: LD_ADDR_VAR 0 12
130920: PUSH
130921: LD_VAR 0 4
130925: PUSH
130926: LD_VAR 0 7
130930: ARRAY
130931: PPUSH
130932: CALL 99911 0 1
130936: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
130937: LD_VAR 0 4
130941: PUSH
130942: LD_VAR 0 7
130946: ARRAY
130947: PPUSH
130948: LD_VAR 0 10
130952: PPUSH
130953: LD_VAR 0 11
130957: PPUSH
130958: LD_VAR 0 14
130962: PUSH
130963: LD_INT 1
130965: ARRAY
130966: PPUSH
130967: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
130971: LD_VAR 0 4
130975: PUSH
130976: LD_VAR 0 7
130980: ARRAY
130981: PPUSH
130982: LD_VAR 0 10
130986: PPUSH
130987: LD_VAR 0 12
130991: PPUSH
130992: LD_INT 7
130994: PPUSH
130995: CALL_OW 272
130999: PPUSH
131000: LD_VAR 0 11
131004: PPUSH
131005: LD_VAR 0 12
131009: PPUSH
131010: LD_INT 7
131012: PPUSH
131013: CALL_OW 273
131017: PPUSH
131018: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
131022: LD_VAR 0 4
131026: PUSH
131027: LD_VAR 0 7
131031: ARRAY
131032: PPUSH
131033: LD_INT 71
131035: PPUSH
131036: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
131040: LD_ADDR_VAR 0 27
131044: PUSH
131045: LD_VAR 0 27
131049: PPUSH
131050: LD_VAR 0 27
131054: PUSH
131055: LD_INT 1
131057: PLUS
131058: PPUSH
131059: LD_VAR 0 14
131063: PUSH
131064: LD_INT 1
131066: ARRAY
131067: PPUSH
131068: CALL_OW 1
131072: ST_TO_ADDR
// attacking := true ;
131073: LD_ADDR_VAR 0 29
131077: PUSH
131078: LD_INT 1
131080: ST_TO_ADDR
// continue ;
131081: GO 128928
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
131083: LD_VAR 0 4
131087: PUSH
131088: LD_VAR 0 7
131092: ARRAY
131093: PPUSH
131094: CALL_OW 257
131098: PUSH
131099: LD_INT 17
131101: EQUAL
131102: PUSH
131103: LD_VAR 0 4
131107: PUSH
131108: LD_VAR 0 7
131112: ARRAY
131113: PPUSH
131114: CALL_OW 110
131118: PUSH
131119: LD_INT 71
131121: EQUAL
131122: NOT
131123: AND
131124: IFFALSE 131270
// begin attacking := false ;
131126: LD_ADDR_VAR 0 29
131130: PUSH
131131: LD_INT 0
131133: ST_TO_ADDR
// k := 5 ;
131134: LD_ADDR_VAR 0 9
131138: PUSH
131139: LD_INT 5
131141: ST_TO_ADDR
// if tmp < k then
131142: LD_VAR 0 14
131146: PUSH
131147: LD_VAR 0 9
131151: LESS
131152: IFFALSE 131164
// k := tmp ;
131154: LD_ADDR_VAR 0 9
131158: PUSH
131159: LD_VAR 0 14
131163: ST_TO_ADDR
// for j = 1 to k do
131164: LD_ADDR_VAR 0 8
131168: PUSH
131169: DOUBLE
131170: LD_INT 1
131172: DEC
131173: ST_TO_ADDR
131174: LD_VAR 0 9
131178: PUSH
131179: FOR_TO
131180: IFFALSE 131268
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
131182: LD_VAR 0 14
131186: PUSH
131187: LD_VAR 0 8
131191: ARRAY
131192: PUSH
131193: LD_VAR 0 14
131197: PPUSH
131198: LD_INT 58
131200: PUSH
131201: EMPTY
131202: LIST
131203: PPUSH
131204: CALL_OW 72
131208: IN
131209: NOT
131210: IFFALSE 131266
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
131212: LD_VAR 0 4
131216: PUSH
131217: LD_VAR 0 7
131221: ARRAY
131222: PPUSH
131223: LD_VAR 0 14
131227: PUSH
131228: LD_VAR 0 8
131232: ARRAY
131233: PPUSH
131234: CALL_OW 115
// attacking := true ;
131238: LD_ADDR_VAR 0 29
131242: PUSH
131243: LD_INT 1
131245: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
131246: LD_VAR 0 4
131250: PUSH
131251: LD_VAR 0 7
131255: ARRAY
131256: PPUSH
131257: LD_INT 71
131259: PPUSH
131260: CALL_OW 109
// continue ;
131264: GO 131179
// end ; end ;
131266: GO 131179
131268: POP
131269: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
131270: LD_VAR 0 4
131274: PUSH
131275: LD_VAR 0 7
131279: ARRAY
131280: PPUSH
131281: CALL_OW 257
131285: PUSH
131286: LD_INT 8
131288: EQUAL
131289: PUSH
131290: LD_VAR 0 4
131294: PUSH
131295: LD_VAR 0 7
131299: ARRAY
131300: PPUSH
131301: CALL_OW 264
131305: PUSH
131306: LD_INT 28
131308: PUSH
131309: LD_INT 45
131311: PUSH
131312: LD_INT 7
131314: PUSH
131315: LD_INT 47
131317: PUSH
131318: EMPTY
131319: LIST
131320: LIST
131321: LIST
131322: LIST
131323: IN
131324: OR
131325: IFFALSE 131581
// begin attacking := false ;
131327: LD_ADDR_VAR 0 29
131331: PUSH
131332: LD_INT 0
131334: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
131335: LD_VAR 0 14
131339: PUSH
131340: LD_INT 1
131342: ARRAY
131343: PPUSH
131344: CALL_OW 266
131348: PUSH
131349: LD_INT 32
131351: PUSH
131352: LD_INT 31
131354: PUSH
131355: LD_INT 33
131357: PUSH
131358: LD_INT 4
131360: PUSH
131361: LD_INT 5
131363: PUSH
131364: EMPTY
131365: LIST
131366: LIST
131367: LIST
131368: LIST
131369: LIST
131370: IN
131371: IFFALSE 131557
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
131373: LD_ADDR_VAR 0 9
131377: PUSH
131378: LD_VAR 0 14
131382: PUSH
131383: LD_INT 1
131385: ARRAY
131386: PPUSH
131387: CALL_OW 266
131391: PPUSH
131392: LD_VAR 0 14
131396: PUSH
131397: LD_INT 1
131399: ARRAY
131400: PPUSH
131401: CALL_OW 250
131405: PPUSH
131406: LD_VAR 0 14
131410: PUSH
131411: LD_INT 1
131413: ARRAY
131414: PPUSH
131415: CALL_OW 251
131419: PPUSH
131420: LD_VAR 0 14
131424: PUSH
131425: LD_INT 1
131427: ARRAY
131428: PPUSH
131429: CALL_OW 254
131433: PPUSH
131434: LD_VAR 0 14
131438: PUSH
131439: LD_INT 1
131441: ARRAY
131442: PPUSH
131443: CALL_OW 248
131447: PPUSH
131448: LD_INT 0
131450: PPUSH
131451: CALL 81281 0 6
131455: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
131456: LD_ADDR_VAR 0 8
131460: PUSH
131461: LD_VAR 0 4
131465: PUSH
131466: LD_VAR 0 7
131470: ARRAY
131471: PPUSH
131472: LD_VAR 0 9
131476: PPUSH
131477: CALL 100024 0 2
131481: ST_TO_ADDR
// if j then
131482: LD_VAR 0 8
131486: IFFALSE 131555
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
131488: LD_VAR 0 8
131492: PUSH
131493: LD_INT 1
131495: ARRAY
131496: PPUSH
131497: LD_VAR 0 8
131501: PUSH
131502: LD_INT 2
131504: ARRAY
131505: PPUSH
131506: CALL_OW 488
131510: IFFALSE 131555
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
131512: LD_VAR 0 4
131516: PUSH
131517: LD_VAR 0 7
131521: ARRAY
131522: PPUSH
131523: LD_VAR 0 8
131527: PUSH
131528: LD_INT 1
131530: ARRAY
131531: PPUSH
131532: LD_VAR 0 8
131536: PUSH
131537: LD_INT 2
131539: ARRAY
131540: PPUSH
131541: CALL_OW 116
// attacking := true ;
131545: LD_ADDR_VAR 0 29
131549: PUSH
131550: LD_INT 1
131552: ST_TO_ADDR
// continue ;
131553: GO 128928
// end ; end else
131555: GO 131581
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131557: LD_VAR 0 4
131561: PUSH
131562: LD_VAR 0 7
131566: ARRAY
131567: PPUSH
131568: LD_VAR 0 14
131572: PUSH
131573: LD_INT 1
131575: ARRAY
131576: PPUSH
131577: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
131581: LD_VAR 0 4
131585: PUSH
131586: LD_VAR 0 7
131590: ARRAY
131591: PPUSH
131592: CALL_OW 265
131596: PUSH
131597: LD_INT 11
131599: EQUAL
131600: IFFALSE 131878
// begin k := 10 ;
131602: LD_ADDR_VAR 0 9
131606: PUSH
131607: LD_INT 10
131609: ST_TO_ADDR
// x := 0 ;
131610: LD_ADDR_VAR 0 10
131614: PUSH
131615: LD_INT 0
131617: ST_TO_ADDR
// if tmp < k then
131618: LD_VAR 0 14
131622: PUSH
131623: LD_VAR 0 9
131627: LESS
131628: IFFALSE 131640
// k := tmp ;
131630: LD_ADDR_VAR 0 9
131634: PUSH
131635: LD_VAR 0 14
131639: ST_TO_ADDR
// for j = k downto 1 do
131640: LD_ADDR_VAR 0 8
131644: PUSH
131645: DOUBLE
131646: LD_VAR 0 9
131650: INC
131651: ST_TO_ADDR
131652: LD_INT 1
131654: PUSH
131655: FOR_DOWNTO
131656: IFFALSE 131731
// begin if GetType ( tmp [ j ] ) = unit_human then
131658: LD_VAR 0 14
131662: PUSH
131663: LD_VAR 0 8
131667: ARRAY
131668: PPUSH
131669: CALL_OW 247
131673: PUSH
131674: LD_INT 1
131676: EQUAL
131677: IFFALSE 131729
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
131679: LD_VAR 0 4
131683: PUSH
131684: LD_VAR 0 7
131688: ARRAY
131689: PPUSH
131690: LD_VAR 0 14
131694: PUSH
131695: LD_VAR 0 8
131699: ARRAY
131700: PPUSH
131701: CALL 100278 0 2
// x := tmp [ j ] ;
131705: LD_ADDR_VAR 0 10
131709: PUSH
131710: LD_VAR 0 14
131714: PUSH
131715: LD_VAR 0 8
131719: ARRAY
131720: ST_TO_ADDR
// attacking := true ;
131721: LD_ADDR_VAR 0 29
131725: PUSH
131726: LD_INT 1
131728: ST_TO_ADDR
// end ; end ;
131729: GO 131655
131731: POP
131732: POP
// if not x then
131733: LD_VAR 0 10
131737: NOT
131738: IFFALSE 131878
// begin attacking := true ;
131740: LD_ADDR_VAR 0 29
131744: PUSH
131745: LD_INT 1
131747: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
131748: LD_VAR 0 4
131752: PUSH
131753: LD_VAR 0 7
131757: ARRAY
131758: PPUSH
131759: CALL_OW 250
131763: PPUSH
131764: LD_VAR 0 4
131768: PUSH
131769: LD_VAR 0 7
131773: ARRAY
131774: PPUSH
131775: CALL_OW 251
131779: PPUSH
131780: CALL_OW 546
131784: PUSH
131785: LD_INT 2
131787: ARRAY
131788: PUSH
131789: LD_VAR 0 14
131793: PUSH
131794: LD_INT 1
131796: ARRAY
131797: PPUSH
131798: CALL_OW 250
131802: PPUSH
131803: LD_VAR 0 14
131807: PUSH
131808: LD_INT 1
131810: ARRAY
131811: PPUSH
131812: CALL_OW 251
131816: PPUSH
131817: CALL_OW 546
131821: PUSH
131822: LD_INT 2
131824: ARRAY
131825: EQUAL
131826: IFFALSE 131854
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
131828: LD_VAR 0 4
131832: PUSH
131833: LD_VAR 0 7
131837: ARRAY
131838: PPUSH
131839: LD_VAR 0 14
131843: PUSH
131844: LD_INT 1
131846: ARRAY
131847: PPUSH
131848: CALL 100278 0 2
131852: GO 131878
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
131854: LD_VAR 0 4
131858: PUSH
131859: LD_VAR 0 7
131863: ARRAY
131864: PPUSH
131865: LD_VAR 0 14
131869: PUSH
131870: LD_INT 1
131872: ARRAY
131873: PPUSH
131874: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
131878: LD_VAR 0 4
131882: PUSH
131883: LD_VAR 0 7
131887: ARRAY
131888: PPUSH
131889: CALL_OW 264
131893: PUSH
131894: LD_INT 29
131896: EQUAL
131897: IFFALSE 132263
// begin if WantsToAttack ( group [ i ] ) in bombed then
131899: LD_VAR 0 4
131903: PUSH
131904: LD_VAR 0 7
131908: ARRAY
131909: PPUSH
131910: CALL_OW 319
131914: PUSH
131915: LD_VAR 0 28
131919: IN
131920: IFFALSE 131924
// continue ;
131922: GO 128928
// k := 8 ;
131924: LD_ADDR_VAR 0 9
131928: PUSH
131929: LD_INT 8
131931: ST_TO_ADDR
// x := 0 ;
131932: LD_ADDR_VAR 0 10
131936: PUSH
131937: LD_INT 0
131939: ST_TO_ADDR
// if tmp < k then
131940: LD_VAR 0 14
131944: PUSH
131945: LD_VAR 0 9
131949: LESS
131950: IFFALSE 131962
// k := tmp ;
131952: LD_ADDR_VAR 0 9
131956: PUSH
131957: LD_VAR 0 14
131961: ST_TO_ADDR
// for j = 1 to k do
131962: LD_ADDR_VAR 0 8
131966: PUSH
131967: DOUBLE
131968: LD_INT 1
131970: DEC
131971: ST_TO_ADDR
131972: LD_VAR 0 9
131976: PUSH
131977: FOR_TO
131978: IFFALSE 132110
// begin if GetType ( tmp [ j ] ) = unit_building then
131980: LD_VAR 0 14
131984: PUSH
131985: LD_VAR 0 8
131989: ARRAY
131990: PPUSH
131991: CALL_OW 247
131995: PUSH
131996: LD_INT 3
131998: EQUAL
131999: IFFALSE 132108
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
132001: LD_VAR 0 14
132005: PUSH
132006: LD_VAR 0 8
132010: ARRAY
132011: PUSH
132012: LD_VAR 0 28
132016: IN
132017: NOT
132018: PUSH
132019: LD_VAR 0 14
132023: PUSH
132024: LD_VAR 0 8
132028: ARRAY
132029: PPUSH
132030: CALL_OW 313
132034: AND
132035: IFFALSE 132108
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132037: LD_VAR 0 4
132041: PUSH
132042: LD_VAR 0 7
132046: ARRAY
132047: PPUSH
132048: LD_VAR 0 14
132052: PUSH
132053: LD_VAR 0 8
132057: ARRAY
132058: PPUSH
132059: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
132063: LD_ADDR_VAR 0 28
132067: PUSH
132068: LD_VAR 0 28
132072: PPUSH
132073: LD_VAR 0 28
132077: PUSH
132078: LD_INT 1
132080: PLUS
132081: PPUSH
132082: LD_VAR 0 14
132086: PUSH
132087: LD_VAR 0 8
132091: ARRAY
132092: PPUSH
132093: CALL_OW 1
132097: ST_TO_ADDR
// attacking := true ;
132098: LD_ADDR_VAR 0 29
132102: PUSH
132103: LD_INT 1
132105: ST_TO_ADDR
// break ;
132106: GO 132110
// end ; end ;
132108: GO 131977
132110: POP
132111: POP
// if not attacking and f_attack_depot then
132112: LD_VAR 0 29
132116: NOT
132117: PUSH
132118: LD_VAR 0 25
132122: AND
132123: IFFALSE 132218
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
132125: LD_ADDR_VAR 0 13
132129: PUSH
132130: LD_VAR 0 14
132134: PPUSH
132135: LD_INT 2
132137: PUSH
132138: LD_INT 30
132140: PUSH
132141: LD_INT 0
132143: PUSH
132144: EMPTY
132145: LIST
132146: LIST
132147: PUSH
132148: LD_INT 30
132150: PUSH
132151: LD_INT 1
132153: PUSH
132154: EMPTY
132155: LIST
132156: LIST
132157: PUSH
132158: EMPTY
132159: LIST
132160: LIST
132161: LIST
132162: PPUSH
132163: CALL_OW 72
132167: ST_TO_ADDR
// if z then
132168: LD_VAR 0 13
132172: IFFALSE 132218
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
132174: LD_VAR 0 4
132178: PUSH
132179: LD_VAR 0 7
132183: ARRAY
132184: PPUSH
132185: LD_VAR 0 13
132189: PPUSH
132190: LD_VAR 0 4
132194: PUSH
132195: LD_VAR 0 7
132199: ARRAY
132200: PPUSH
132201: CALL_OW 74
132205: PPUSH
132206: CALL_OW 115
// attacking := true ;
132210: LD_ADDR_VAR 0 29
132214: PUSH
132215: LD_INT 1
132217: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
132218: LD_VAR 0 4
132222: PUSH
132223: LD_VAR 0 7
132227: ARRAY
132228: PPUSH
132229: CALL_OW 256
132233: PUSH
132234: LD_INT 500
132236: LESS
132237: IFFALSE 132263
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132239: LD_VAR 0 4
132243: PUSH
132244: LD_VAR 0 7
132248: ARRAY
132249: PPUSH
132250: LD_VAR 0 14
132254: PUSH
132255: LD_INT 1
132257: ARRAY
132258: PPUSH
132259: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
132263: LD_VAR 0 4
132267: PUSH
132268: LD_VAR 0 7
132272: ARRAY
132273: PPUSH
132274: CALL_OW 264
132278: PUSH
132279: LD_INT 49
132281: EQUAL
132282: IFFALSE 132403
// begin if not HasTask ( group [ i ] ) then
132284: LD_VAR 0 4
132288: PUSH
132289: LD_VAR 0 7
132293: ARRAY
132294: PPUSH
132295: CALL_OW 314
132299: NOT
132300: IFFALSE 132403
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
132302: LD_ADDR_VAR 0 9
132306: PUSH
132307: LD_INT 81
132309: PUSH
132310: LD_VAR 0 4
132314: PUSH
132315: LD_VAR 0 7
132319: ARRAY
132320: PPUSH
132321: CALL_OW 255
132325: PUSH
132326: EMPTY
132327: LIST
132328: LIST
132329: PPUSH
132330: CALL_OW 69
132334: PPUSH
132335: LD_VAR 0 4
132339: PUSH
132340: LD_VAR 0 7
132344: ARRAY
132345: PPUSH
132346: CALL_OW 74
132350: ST_TO_ADDR
// if k then
132351: LD_VAR 0 9
132355: IFFALSE 132403
// if GetDistUnits ( group [ i ] , k ) > 10 then
132357: LD_VAR 0 4
132361: PUSH
132362: LD_VAR 0 7
132366: ARRAY
132367: PPUSH
132368: LD_VAR 0 9
132372: PPUSH
132373: CALL_OW 296
132377: PUSH
132378: LD_INT 10
132380: GREATER
132381: IFFALSE 132403
// ComMoveUnit ( group [ i ] , k ) ;
132383: LD_VAR 0 4
132387: PUSH
132388: LD_VAR 0 7
132392: ARRAY
132393: PPUSH
132394: LD_VAR 0 9
132398: PPUSH
132399: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
132403: LD_VAR 0 4
132407: PUSH
132408: LD_VAR 0 7
132412: ARRAY
132413: PPUSH
132414: CALL_OW 256
132418: PUSH
132419: LD_INT 250
132421: LESS
132422: PUSH
132423: LD_VAR 0 4
132427: PUSH
132428: LD_VAR 0 7
132432: ARRAY
132433: PUSH
132434: LD_INT 21
132436: PUSH
132437: LD_INT 2
132439: PUSH
132440: EMPTY
132441: LIST
132442: LIST
132443: PUSH
132444: LD_INT 23
132446: PUSH
132447: LD_INT 2
132449: PUSH
132450: EMPTY
132451: LIST
132452: LIST
132453: PUSH
132454: EMPTY
132455: LIST
132456: LIST
132457: PPUSH
132458: CALL_OW 69
132462: IN
132463: AND
132464: IFFALSE 132589
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
132466: LD_ADDR_VAR 0 9
132470: PUSH
132471: LD_OWVAR 3
132475: PUSH
132476: LD_VAR 0 4
132480: PUSH
132481: LD_VAR 0 7
132485: ARRAY
132486: DIFF
132487: PPUSH
132488: LD_VAR 0 4
132492: PUSH
132493: LD_VAR 0 7
132497: ARRAY
132498: PPUSH
132499: CALL_OW 74
132503: ST_TO_ADDR
// if not k then
132504: LD_VAR 0 9
132508: NOT
132509: IFFALSE 132513
// continue ;
132511: GO 128928
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
132513: LD_VAR 0 9
132517: PUSH
132518: LD_INT 81
132520: PUSH
132521: LD_VAR 0 4
132525: PUSH
132526: LD_VAR 0 7
132530: ARRAY
132531: PPUSH
132532: CALL_OW 255
132536: PUSH
132537: EMPTY
132538: LIST
132539: LIST
132540: PPUSH
132541: CALL_OW 69
132545: IN
132546: PUSH
132547: LD_VAR 0 9
132551: PPUSH
132552: LD_VAR 0 4
132556: PUSH
132557: LD_VAR 0 7
132561: ARRAY
132562: PPUSH
132563: CALL_OW 296
132567: PUSH
132568: LD_INT 5
132570: LESS
132571: AND
132572: IFFALSE 132589
// ComAutodestruct ( group [ i ] ) ;
132574: LD_VAR 0 4
132578: PUSH
132579: LD_VAR 0 7
132583: ARRAY
132584: PPUSH
132585: CALL 100176 0 1
// end ; if f_attack_depot then
132589: LD_VAR 0 25
132593: IFFALSE 132705
// begin k := 6 ;
132595: LD_ADDR_VAR 0 9
132599: PUSH
132600: LD_INT 6
132602: ST_TO_ADDR
// if tmp < k then
132603: LD_VAR 0 14
132607: PUSH
132608: LD_VAR 0 9
132612: LESS
132613: IFFALSE 132625
// k := tmp ;
132615: LD_ADDR_VAR 0 9
132619: PUSH
132620: LD_VAR 0 14
132624: ST_TO_ADDR
// for j = 1 to k do
132625: LD_ADDR_VAR 0 8
132629: PUSH
132630: DOUBLE
132631: LD_INT 1
132633: DEC
132634: ST_TO_ADDR
132635: LD_VAR 0 9
132639: PUSH
132640: FOR_TO
132641: IFFALSE 132703
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
132643: LD_VAR 0 8
132647: PPUSH
132648: CALL_OW 266
132652: PUSH
132653: LD_INT 0
132655: PUSH
132656: LD_INT 1
132658: PUSH
132659: EMPTY
132660: LIST
132661: LIST
132662: IN
132663: IFFALSE 132701
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
132665: LD_VAR 0 4
132669: PUSH
132670: LD_VAR 0 7
132674: ARRAY
132675: PPUSH
132676: LD_VAR 0 14
132680: PUSH
132681: LD_VAR 0 8
132685: ARRAY
132686: PPUSH
132687: CALL_OW 115
// attacking := true ;
132691: LD_ADDR_VAR 0 29
132695: PUSH
132696: LD_INT 1
132698: ST_TO_ADDR
// break ;
132699: GO 132703
// end ;
132701: GO 132640
132703: POP
132704: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
132705: LD_VAR 0 4
132709: PUSH
132710: LD_VAR 0 7
132714: ARRAY
132715: PPUSH
132716: CALL_OW 302
132720: PUSH
132721: LD_VAR 0 29
132725: NOT
132726: AND
132727: IFFALSE 133049
// begin if GetTag ( group [ i ] ) = 71 then
132729: LD_VAR 0 4
132733: PUSH
132734: LD_VAR 0 7
132738: ARRAY
132739: PPUSH
132740: CALL_OW 110
132744: PUSH
132745: LD_INT 71
132747: EQUAL
132748: IFFALSE 132789
// begin if HasTask ( group [ i ] ) then
132750: LD_VAR 0 4
132754: PUSH
132755: LD_VAR 0 7
132759: ARRAY
132760: PPUSH
132761: CALL_OW 314
132765: IFFALSE 132771
// continue else
132767: GO 128928
132769: GO 132789
// SetTag ( group [ i ] , 0 ) ;
132771: LD_VAR 0 4
132775: PUSH
132776: LD_VAR 0 7
132780: ARRAY
132781: PPUSH
132782: LD_INT 0
132784: PPUSH
132785: CALL_OW 109
// end ; k := 8 ;
132789: LD_ADDR_VAR 0 9
132793: PUSH
132794: LD_INT 8
132796: ST_TO_ADDR
// x := 0 ;
132797: LD_ADDR_VAR 0 10
132801: PUSH
132802: LD_INT 0
132804: ST_TO_ADDR
// if tmp < k then
132805: LD_VAR 0 14
132809: PUSH
132810: LD_VAR 0 9
132814: LESS
132815: IFFALSE 132827
// k := tmp ;
132817: LD_ADDR_VAR 0 9
132821: PUSH
132822: LD_VAR 0 14
132826: ST_TO_ADDR
// for j = 1 to k do
132827: LD_ADDR_VAR 0 8
132831: PUSH
132832: DOUBLE
132833: LD_INT 1
132835: DEC
132836: ST_TO_ADDR
132837: LD_VAR 0 9
132841: PUSH
132842: FOR_TO
132843: IFFALSE 132941
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
132845: LD_VAR 0 14
132849: PUSH
132850: LD_VAR 0 8
132854: ARRAY
132855: PPUSH
132856: CALL_OW 247
132860: PUSH
132861: LD_INT 1
132863: EQUAL
132864: PUSH
132865: LD_VAR 0 14
132869: PUSH
132870: LD_VAR 0 8
132874: ARRAY
132875: PPUSH
132876: CALL_OW 256
132880: PUSH
132881: LD_INT 250
132883: LESS
132884: PUSH
132885: LD_VAR 0 20
132889: AND
132890: PUSH
132891: LD_VAR 0 20
132895: NOT
132896: PUSH
132897: LD_VAR 0 14
132901: PUSH
132902: LD_VAR 0 8
132906: ARRAY
132907: PPUSH
132908: CALL_OW 256
132912: PUSH
132913: LD_INT 250
132915: GREATEREQUAL
132916: AND
132917: OR
132918: AND
132919: IFFALSE 132939
// begin x := tmp [ j ] ;
132921: LD_ADDR_VAR 0 10
132925: PUSH
132926: LD_VAR 0 14
132930: PUSH
132931: LD_VAR 0 8
132935: ARRAY
132936: ST_TO_ADDR
// break ;
132937: GO 132941
// end ;
132939: GO 132842
132941: POP
132942: POP
// if x then
132943: LD_VAR 0 10
132947: IFFALSE 132971
// ComAttackUnit ( group [ i ] , x ) else
132949: LD_VAR 0 4
132953: PUSH
132954: LD_VAR 0 7
132958: ARRAY
132959: PPUSH
132960: LD_VAR 0 10
132964: PPUSH
132965: CALL_OW 115
132969: GO 132995
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
132971: LD_VAR 0 4
132975: PUSH
132976: LD_VAR 0 7
132980: ARRAY
132981: PPUSH
132982: LD_VAR 0 14
132986: PUSH
132987: LD_INT 1
132989: ARRAY
132990: PPUSH
132991: CALL_OW 115
// if not HasTask ( group [ i ] ) then
132995: LD_VAR 0 4
132999: PUSH
133000: LD_VAR 0 7
133004: ARRAY
133005: PPUSH
133006: CALL_OW 314
133010: NOT
133011: IFFALSE 133049
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
133013: LD_VAR 0 4
133017: PUSH
133018: LD_VAR 0 7
133022: ARRAY
133023: PPUSH
133024: LD_VAR 0 14
133028: PPUSH
133029: LD_VAR 0 4
133033: PUSH
133034: LD_VAR 0 7
133038: ARRAY
133039: PPUSH
133040: CALL_OW 74
133044: PPUSH
133045: CALL_OW 115
// end ; end ; end ;
133049: GO 128928
133051: POP
133052: POP
// wait ( 0 0$2 ) ;
133053: LD_INT 70
133055: PPUSH
133056: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
133060: LD_VAR 0 4
133064: NOT
133065: PUSH
133066: LD_VAR 0 4
133070: PUSH
133071: EMPTY
133072: EQUAL
133073: OR
133074: PUSH
133075: LD_INT 81
133077: PUSH
133078: LD_VAR 0 35
133082: PUSH
133083: EMPTY
133084: LIST
133085: LIST
133086: PPUSH
133087: CALL_OW 69
133091: NOT
133092: OR
133093: IFFALSE 128913
// end ;
133095: LD_VAR 0 2
133099: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
133100: LD_INT 0
133102: PPUSH
133103: PPUSH
133104: PPUSH
133105: PPUSH
133106: PPUSH
133107: PPUSH
// if not base or not mc_bases [ base ] or not solds then
133108: LD_VAR 0 1
133112: NOT
133113: PUSH
133114: LD_EXP 99
133118: PUSH
133119: LD_VAR 0 1
133123: ARRAY
133124: NOT
133125: OR
133126: PUSH
133127: LD_VAR 0 2
133131: NOT
133132: OR
133133: IFFALSE 133137
// exit ;
133135: GO 133691
// side := mc_sides [ base ] ;
133137: LD_ADDR_VAR 0 6
133141: PUSH
133142: LD_EXP 125
133146: PUSH
133147: LD_VAR 0 1
133151: ARRAY
133152: ST_TO_ADDR
// if not side then
133153: LD_VAR 0 6
133157: NOT
133158: IFFALSE 133162
// exit ;
133160: GO 133691
// for i in solds do
133162: LD_ADDR_VAR 0 7
133166: PUSH
133167: LD_VAR 0 2
133171: PUSH
133172: FOR_IN
133173: IFFALSE 133234
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
133175: LD_VAR 0 7
133179: PPUSH
133180: CALL_OW 310
133184: PPUSH
133185: CALL_OW 266
133189: PUSH
133190: LD_INT 32
133192: PUSH
133193: LD_INT 31
133195: PUSH
133196: EMPTY
133197: LIST
133198: LIST
133199: IN
133200: IFFALSE 133220
// solds := solds diff i else
133202: LD_ADDR_VAR 0 2
133206: PUSH
133207: LD_VAR 0 2
133211: PUSH
133212: LD_VAR 0 7
133216: DIFF
133217: ST_TO_ADDR
133218: GO 133232
// SetTag ( i , 18 ) ;
133220: LD_VAR 0 7
133224: PPUSH
133225: LD_INT 18
133227: PPUSH
133228: CALL_OW 109
133232: GO 133172
133234: POP
133235: POP
// if not solds then
133236: LD_VAR 0 2
133240: NOT
133241: IFFALSE 133245
// exit ;
133243: GO 133691
// repeat wait ( 0 0$2 ) ;
133245: LD_INT 70
133247: PPUSH
133248: CALL_OW 67
// enemy := mc_scan [ base ] ;
133252: LD_ADDR_VAR 0 4
133256: PUSH
133257: LD_EXP 122
133261: PUSH
133262: LD_VAR 0 1
133266: ARRAY
133267: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
133268: LD_EXP 99
133272: PUSH
133273: LD_VAR 0 1
133277: ARRAY
133278: NOT
133279: PUSH
133280: LD_EXP 99
133284: PUSH
133285: LD_VAR 0 1
133289: ARRAY
133290: PUSH
133291: EMPTY
133292: EQUAL
133293: OR
133294: IFFALSE 133331
// begin for i in solds do
133296: LD_ADDR_VAR 0 7
133300: PUSH
133301: LD_VAR 0 2
133305: PUSH
133306: FOR_IN
133307: IFFALSE 133320
// ComStop ( i ) ;
133309: LD_VAR 0 7
133313: PPUSH
133314: CALL_OW 141
133318: GO 133306
133320: POP
133321: POP
// solds := [ ] ;
133322: LD_ADDR_VAR 0 2
133326: PUSH
133327: EMPTY
133328: ST_TO_ADDR
// exit ;
133329: GO 133691
// end ; for i in solds do
133331: LD_ADDR_VAR 0 7
133335: PUSH
133336: LD_VAR 0 2
133340: PUSH
133341: FOR_IN
133342: IFFALSE 133663
// begin if IsInUnit ( i ) then
133344: LD_VAR 0 7
133348: PPUSH
133349: CALL_OW 310
133353: IFFALSE 133364
// ComExitBuilding ( i ) ;
133355: LD_VAR 0 7
133359: PPUSH
133360: CALL_OW 122
// if GetLives ( i ) > 500 then
133364: LD_VAR 0 7
133368: PPUSH
133369: CALL_OW 256
133373: PUSH
133374: LD_INT 500
133376: GREATER
133377: IFFALSE 133430
// begin e := NearestUnitToUnit ( enemy , i ) ;
133379: LD_ADDR_VAR 0 5
133383: PUSH
133384: LD_VAR 0 4
133388: PPUSH
133389: LD_VAR 0 7
133393: PPUSH
133394: CALL_OW 74
133398: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
133399: LD_VAR 0 7
133403: PPUSH
133404: LD_VAR 0 5
133408: PPUSH
133409: CALL_OW 250
133413: PPUSH
133414: LD_VAR 0 5
133418: PPUSH
133419: CALL_OW 251
133423: PPUSH
133424: CALL_OW 114
// end else
133428: GO 133661
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
133430: LD_VAR 0 7
133434: PPUSH
133435: LD_EXP 99
133439: PUSH
133440: LD_VAR 0 1
133444: ARRAY
133445: PPUSH
133446: LD_INT 2
133448: PUSH
133449: LD_INT 30
133451: PUSH
133452: LD_INT 0
133454: PUSH
133455: EMPTY
133456: LIST
133457: LIST
133458: PUSH
133459: LD_INT 30
133461: PUSH
133462: LD_INT 1
133464: PUSH
133465: EMPTY
133466: LIST
133467: LIST
133468: PUSH
133469: LD_INT 30
133471: PUSH
133472: LD_INT 6
133474: PUSH
133475: EMPTY
133476: LIST
133477: LIST
133478: PUSH
133479: EMPTY
133480: LIST
133481: LIST
133482: LIST
133483: LIST
133484: PPUSH
133485: CALL_OW 72
133489: PPUSH
133490: LD_VAR 0 7
133494: PPUSH
133495: CALL_OW 74
133499: PPUSH
133500: CALL_OW 296
133504: PUSH
133505: LD_INT 10
133507: GREATER
133508: IFFALSE 133661
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
133510: LD_ADDR_VAR 0 8
133514: PUSH
133515: LD_EXP 99
133519: PUSH
133520: LD_VAR 0 1
133524: ARRAY
133525: PPUSH
133526: LD_INT 2
133528: PUSH
133529: LD_INT 30
133531: PUSH
133532: LD_INT 0
133534: PUSH
133535: EMPTY
133536: LIST
133537: LIST
133538: PUSH
133539: LD_INT 30
133541: PUSH
133542: LD_INT 1
133544: PUSH
133545: EMPTY
133546: LIST
133547: LIST
133548: PUSH
133549: LD_INT 30
133551: PUSH
133552: LD_INT 6
133554: PUSH
133555: EMPTY
133556: LIST
133557: LIST
133558: PUSH
133559: EMPTY
133560: LIST
133561: LIST
133562: LIST
133563: LIST
133564: PPUSH
133565: CALL_OW 72
133569: PPUSH
133570: LD_VAR 0 7
133574: PPUSH
133575: CALL_OW 74
133579: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
133580: LD_VAR 0 7
133584: PPUSH
133585: LD_VAR 0 8
133589: PPUSH
133590: CALL_OW 250
133594: PPUSH
133595: LD_INT 3
133597: PPUSH
133598: LD_INT 5
133600: PPUSH
133601: CALL_OW 272
133605: PPUSH
133606: LD_VAR 0 8
133610: PPUSH
133611: CALL_OW 251
133615: PPUSH
133616: LD_INT 3
133618: PPUSH
133619: LD_INT 5
133621: PPUSH
133622: CALL_OW 273
133626: PPUSH
133627: CALL_OW 111
// SetTag ( i , 0 ) ;
133631: LD_VAR 0 7
133635: PPUSH
133636: LD_INT 0
133638: PPUSH
133639: CALL_OW 109
// solds := solds diff i ;
133643: LD_ADDR_VAR 0 2
133647: PUSH
133648: LD_VAR 0 2
133652: PUSH
133653: LD_VAR 0 7
133657: DIFF
133658: ST_TO_ADDR
// continue ;
133659: GO 133341
// end ; end ;
133661: GO 133341
133663: POP
133664: POP
// until not solds or not enemy ;
133665: LD_VAR 0 2
133669: NOT
133670: PUSH
133671: LD_VAR 0 4
133675: NOT
133676: OR
133677: IFFALSE 133245
// MC_Reset ( base , 18 ) ;
133679: LD_VAR 0 1
133683: PPUSH
133684: LD_INT 18
133686: PPUSH
133687: CALL 40692 0 2
// end ;
133691: LD_VAR 0 3
133695: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
133696: LD_INT 0
133698: PPUSH
133699: PPUSH
133700: PPUSH
133701: PPUSH
133702: PPUSH
133703: PPUSH
133704: PPUSH
133705: PPUSH
133706: PPUSH
133707: PPUSH
133708: PPUSH
133709: PPUSH
133710: PPUSH
133711: PPUSH
133712: PPUSH
133713: PPUSH
133714: PPUSH
133715: PPUSH
133716: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
133717: LD_ADDR_VAR 0 12
133721: PUSH
133722: LD_EXP 99
133726: PUSH
133727: LD_VAR 0 1
133731: ARRAY
133732: PPUSH
133733: LD_INT 25
133735: PUSH
133736: LD_INT 3
133738: PUSH
133739: EMPTY
133740: LIST
133741: LIST
133742: PPUSH
133743: CALL_OW 72
133747: ST_TO_ADDR
// if mc_remote_driver [ base ] then
133748: LD_EXP 139
133752: PUSH
133753: LD_VAR 0 1
133757: ARRAY
133758: IFFALSE 133782
// mechs := mechs diff mc_remote_driver [ base ] ;
133760: LD_ADDR_VAR 0 12
133764: PUSH
133765: LD_VAR 0 12
133769: PUSH
133770: LD_EXP 139
133774: PUSH
133775: LD_VAR 0 1
133779: ARRAY
133780: DIFF
133781: ST_TO_ADDR
// for i in mechs do
133782: LD_ADDR_VAR 0 4
133786: PUSH
133787: LD_VAR 0 12
133791: PUSH
133792: FOR_IN
133793: IFFALSE 133828
// if GetTag ( i ) > 0 then
133795: LD_VAR 0 4
133799: PPUSH
133800: CALL_OW 110
133804: PUSH
133805: LD_INT 0
133807: GREATER
133808: IFFALSE 133826
// mechs := mechs diff i ;
133810: LD_ADDR_VAR 0 12
133814: PUSH
133815: LD_VAR 0 12
133819: PUSH
133820: LD_VAR 0 4
133824: DIFF
133825: ST_TO_ADDR
133826: GO 133792
133828: POP
133829: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
133830: LD_ADDR_VAR 0 8
133834: PUSH
133835: LD_EXP 99
133839: PUSH
133840: LD_VAR 0 1
133844: ARRAY
133845: PPUSH
133846: LD_INT 2
133848: PUSH
133849: LD_INT 25
133851: PUSH
133852: LD_INT 1
133854: PUSH
133855: EMPTY
133856: LIST
133857: LIST
133858: PUSH
133859: LD_INT 25
133861: PUSH
133862: LD_INT 5
133864: PUSH
133865: EMPTY
133866: LIST
133867: LIST
133868: PUSH
133869: LD_INT 25
133871: PUSH
133872: LD_INT 8
133874: PUSH
133875: EMPTY
133876: LIST
133877: LIST
133878: PUSH
133879: LD_INT 25
133881: PUSH
133882: LD_INT 9
133884: PUSH
133885: EMPTY
133886: LIST
133887: LIST
133888: PUSH
133889: EMPTY
133890: LIST
133891: LIST
133892: LIST
133893: LIST
133894: LIST
133895: PPUSH
133896: CALL_OW 72
133900: ST_TO_ADDR
// if not defenders and not solds then
133901: LD_VAR 0 2
133905: NOT
133906: PUSH
133907: LD_VAR 0 8
133911: NOT
133912: AND
133913: IFFALSE 133917
// exit ;
133915: GO 135687
// depot_under_attack := false ;
133917: LD_ADDR_VAR 0 16
133921: PUSH
133922: LD_INT 0
133924: ST_TO_ADDR
// sold_defenders := [ ] ;
133925: LD_ADDR_VAR 0 17
133929: PUSH
133930: EMPTY
133931: ST_TO_ADDR
// if mechs then
133932: LD_VAR 0 12
133936: IFFALSE 134089
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
133938: LD_ADDR_VAR 0 4
133942: PUSH
133943: LD_VAR 0 2
133947: PPUSH
133948: LD_INT 21
133950: PUSH
133951: LD_INT 2
133953: PUSH
133954: EMPTY
133955: LIST
133956: LIST
133957: PPUSH
133958: CALL_OW 72
133962: PUSH
133963: FOR_IN
133964: IFFALSE 134087
// begin if GetTag ( i ) <> 20 then
133966: LD_VAR 0 4
133970: PPUSH
133971: CALL_OW 110
133975: PUSH
133976: LD_INT 20
133978: NONEQUAL
133979: IFFALSE 133993
// SetTag ( i , 20 ) ;
133981: LD_VAR 0 4
133985: PPUSH
133986: LD_INT 20
133988: PPUSH
133989: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
133993: LD_VAR 0 4
133997: PPUSH
133998: CALL_OW 263
134002: PUSH
134003: LD_INT 1
134005: EQUAL
134006: PUSH
134007: LD_VAR 0 4
134011: PPUSH
134012: CALL_OW 311
134016: NOT
134017: AND
134018: IFFALSE 134085
// begin un := mechs [ 1 ] ;
134020: LD_ADDR_VAR 0 10
134024: PUSH
134025: LD_VAR 0 12
134029: PUSH
134030: LD_INT 1
134032: ARRAY
134033: ST_TO_ADDR
// ComExit ( un ) ;
134034: LD_VAR 0 10
134038: PPUSH
134039: CALL 105042 0 1
// AddComEnterUnit ( un , i ) ;
134043: LD_VAR 0 10
134047: PPUSH
134048: LD_VAR 0 4
134052: PPUSH
134053: CALL_OW 180
// SetTag ( un , 19 ) ;
134057: LD_VAR 0 10
134061: PPUSH
134062: LD_INT 19
134064: PPUSH
134065: CALL_OW 109
// mechs := mechs diff un ;
134069: LD_ADDR_VAR 0 12
134073: PUSH
134074: LD_VAR 0 12
134078: PUSH
134079: LD_VAR 0 10
134083: DIFF
134084: ST_TO_ADDR
// end ; end ;
134085: GO 133963
134087: POP
134088: POP
// if solds then
134089: LD_VAR 0 8
134093: IFFALSE 134152
// for i in solds do
134095: LD_ADDR_VAR 0 4
134099: PUSH
134100: LD_VAR 0 8
134104: PUSH
134105: FOR_IN
134106: IFFALSE 134150
// if not GetTag ( i ) then
134108: LD_VAR 0 4
134112: PPUSH
134113: CALL_OW 110
134117: NOT
134118: IFFALSE 134148
// begin defenders := defenders union i ;
134120: LD_ADDR_VAR 0 2
134124: PUSH
134125: LD_VAR 0 2
134129: PUSH
134130: LD_VAR 0 4
134134: UNION
134135: ST_TO_ADDR
// SetTag ( i , 18 ) ;
134136: LD_VAR 0 4
134140: PPUSH
134141: LD_INT 18
134143: PPUSH
134144: CALL_OW 109
// end ;
134148: GO 134105
134150: POP
134151: POP
// repeat wait ( 0 0$2 ) ;
134152: LD_INT 70
134154: PPUSH
134155: CALL_OW 67
// enemy := mc_scan [ base ] ;
134159: LD_ADDR_VAR 0 21
134163: PUSH
134164: LD_EXP 122
134168: PUSH
134169: LD_VAR 0 1
134173: ARRAY
134174: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
134175: LD_EXP 99
134179: PUSH
134180: LD_VAR 0 1
134184: ARRAY
134185: NOT
134186: PUSH
134187: LD_EXP 99
134191: PUSH
134192: LD_VAR 0 1
134196: ARRAY
134197: PUSH
134198: EMPTY
134199: EQUAL
134200: OR
134201: IFFALSE 134238
// begin for i in defenders do
134203: LD_ADDR_VAR 0 4
134207: PUSH
134208: LD_VAR 0 2
134212: PUSH
134213: FOR_IN
134214: IFFALSE 134227
// ComStop ( i ) ;
134216: LD_VAR 0 4
134220: PPUSH
134221: CALL_OW 141
134225: GO 134213
134227: POP
134228: POP
// defenders := [ ] ;
134229: LD_ADDR_VAR 0 2
134233: PUSH
134234: EMPTY
134235: ST_TO_ADDR
// exit ;
134236: GO 135687
// end ; for i in defenders do
134238: LD_ADDR_VAR 0 4
134242: PUSH
134243: LD_VAR 0 2
134247: PUSH
134248: FOR_IN
134249: IFFALSE 135147
// begin e := NearestUnitToUnit ( enemy , i ) ;
134251: LD_ADDR_VAR 0 13
134255: PUSH
134256: LD_VAR 0 21
134260: PPUSH
134261: LD_VAR 0 4
134265: PPUSH
134266: CALL_OW 74
134270: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134271: LD_ADDR_VAR 0 7
134275: PUSH
134276: LD_EXP 99
134280: PUSH
134281: LD_VAR 0 1
134285: ARRAY
134286: PPUSH
134287: LD_INT 2
134289: PUSH
134290: LD_INT 30
134292: PUSH
134293: LD_INT 0
134295: PUSH
134296: EMPTY
134297: LIST
134298: LIST
134299: PUSH
134300: LD_INT 30
134302: PUSH
134303: LD_INT 1
134305: PUSH
134306: EMPTY
134307: LIST
134308: LIST
134309: PUSH
134310: EMPTY
134311: LIST
134312: LIST
134313: LIST
134314: PPUSH
134315: CALL_OW 72
134319: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
134320: LD_ADDR_VAR 0 16
134324: PUSH
134325: LD_VAR 0 7
134329: NOT
134330: PUSH
134331: LD_VAR 0 7
134335: PPUSH
134336: LD_INT 3
134338: PUSH
134339: LD_INT 24
134341: PUSH
134342: LD_INT 600
134344: PUSH
134345: EMPTY
134346: LIST
134347: LIST
134348: PUSH
134349: EMPTY
134350: LIST
134351: LIST
134352: PPUSH
134353: CALL_OW 72
134357: OR
134358: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
134359: LD_VAR 0 4
134363: PPUSH
134364: CALL_OW 247
134368: PUSH
134369: LD_INT 2
134371: DOUBLE
134372: EQUAL
134373: IFTRUE 134377
134375: GO 134773
134377: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
134378: LD_VAR 0 4
134382: PPUSH
134383: CALL_OW 256
134387: PUSH
134388: LD_INT 1000
134390: EQUAL
134391: PUSH
134392: LD_VAR 0 4
134396: PPUSH
134397: LD_VAR 0 13
134401: PPUSH
134402: CALL_OW 296
134406: PUSH
134407: LD_INT 40
134409: LESS
134410: PUSH
134411: LD_VAR 0 13
134415: PPUSH
134416: LD_EXP 124
134420: PUSH
134421: LD_VAR 0 1
134425: ARRAY
134426: PPUSH
134427: CALL_OW 308
134431: OR
134432: AND
134433: IFFALSE 134555
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
134435: LD_VAR 0 4
134439: PPUSH
134440: CALL_OW 262
134444: PUSH
134445: LD_INT 1
134447: EQUAL
134448: PUSH
134449: LD_VAR 0 4
134453: PPUSH
134454: CALL_OW 261
134458: PUSH
134459: LD_INT 30
134461: LESS
134462: AND
134463: PUSH
134464: LD_VAR 0 7
134468: AND
134469: IFFALSE 134539
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
134471: LD_VAR 0 4
134475: PPUSH
134476: LD_VAR 0 7
134480: PPUSH
134481: LD_VAR 0 4
134485: PPUSH
134486: CALL_OW 74
134490: PPUSH
134491: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
134495: LD_VAR 0 4
134499: PPUSH
134500: LD_VAR 0 7
134504: PPUSH
134505: LD_VAR 0 4
134509: PPUSH
134510: CALL_OW 74
134514: PPUSH
134515: CALL_OW 296
134519: PUSH
134520: LD_INT 6
134522: LESS
134523: IFFALSE 134537
// SetFuel ( i , 100 ) ;
134525: LD_VAR 0 4
134529: PPUSH
134530: LD_INT 100
134532: PPUSH
134533: CALL_OW 240
// end else
134537: GO 134553
// ComAttackUnit ( i , e ) ;
134539: LD_VAR 0 4
134543: PPUSH
134544: LD_VAR 0 13
134548: PPUSH
134549: CALL_OW 115
// end else
134553: GO 134656
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
134555: LD_VAR 0 13
134559: PPUSH
134560: LD_EXP 124
134564: PUSH
134565: LD_VAR 0 1
134569: ARRAY
134570: PPUSH
134571: CALL_OW 308
134575: NOT
134576: PUSH
134577: LD_VAR 0 4
134581: PPUSH
134582: LD_VAR 0 13
134586: PPUSH
134587: CALL_OW 296
134591: PUSH
134592: LD_INT 40
134594: GREATEREQUAL
134595: AND
134596: PUSH
134597: LD_VAR 0 4
134601: PPUSH
134602: CALL_OW 256
134606: PUSH
134607: LD_INT 650
134609: LESSEQUAL
134610: OR
134611: PUSH
134612: LD_VAR 0 4
134616: PPUSH
134617: LD_EXP 123
134621: PUSH
134622: LD_VAR 0 1
134626: ARRAY
134627: PPUSH
134628: CALL_OW 308
134632: NOT
134633: AND
134634: IFFALSE 134656
// ComMoveToArea ( i , mc_parking [ base ] ) ;
134636: LD_VAR 0 4
134640: PPUSH
134641: LD_EXP 123
134645: PUSH
134646: LD_VAR 0 1
134650: ARRAY
134651: PPUSH
134652: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
134656: LD_VAR 0 4
134660: PPUSH
134661: CALL_OW 256
134665: PUSH
134666: LD_INT 1000
134668: LESS
134669: PUSH
134670: LD_VAR 0 4
134674: PPUSH
134675: CALL_OW 263
134679: PUSH
134680: LD_INT 1
134682: EQUAL
134683: AND
134684: PUSH
134685: LD_VAR 0 4
134689: PPUSH
134690: CALL_OW 311
134694: AND
134695: PUSH
134696: LD_VAR 0 4
134700: PPUSH
134701: LD_EXP 123
134705: PUSH
134706: LD_VAR 0 1
134710: ARRAY
134711: PPUSH
134712: CALL_OW 308
134716: AND
134717: IFFALSE 134771
// begin mech := IsDrivenBy ( i ) ;
134719: LD_ADDR_VAR 0 9
134723: PUSH
134724: LD_VAR 0 4
134728: PPUSH
134729: CALL_OW 311
134733: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
134734: LD_VAR 0 9
134738: PPUSH
134739: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
134743: LD_VAR 0 9
134747: PPUSH
134748: LD_VAR 0 4
134752: PPUSH
134753: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
134757: LD_VAR 0 9
134761: PPUSH
134762: LD_VAR 0 4
134766: PPUSH
134767: CALL_OW 180
// end ; end ; unit_human :
134771: GO 135118
134773: LD_INT 1
134775: DOUBLE
134776: EQUAL
134777: IFTRUE 134781
134779: GO 135117
134781: POP
// begin b := IsInUnit ( i ) ;
134782: LD_ADDR_VAR 0 18
134786: PUSH
134787: LD_VAR 0 4
134791: PPUSH
134792: CALL_OW 310
134796: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
134797: LD_ADDR_VAR 0 19
134801: PUSH
134802: LD_VAR 0 18
134806: NOT
134807: PUSH
134808: LD_VAR 0 18
134812: PPUSH
134813: CALL_OW 266
134817: PUSH
134818: LD_INT 32
134820: PUSH
134821: LD_INT 31
134823: PUSH
134824: EMPTY
134825: LIST
134826: LIST
134827: IN
134828: OR
134829: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
134830: LD_VAR 0 18
134834: PPUSH
134835: CALL_OW 266
134839: PUSH
134840: LD_INT 5
134842: EQUAL
134843: PUSH
134844: LD_VAR 0 4
134848: PPUSH
134849: CALL_OW 257
134853: PUSH
134854: LD_INT 1
134856: PUSH
134857: LD_INT 2
134859: PUSH
134860: LD_INT 3
134862: PUSH
134863: LD_INT 4
134865: PUSH
134866: EMPTY
134867: LIST
134868: LIST
134869: LIST
134870: LIST
134871: IN
134872: AND
134873: IFFALSE 134910
// begin class := AllowSpecClass ( i ) ;
134875: LD_ADDR_VAR 0 20
134879: PUSH
134880: LD_VAR 0 4
134884: PPUSH
134885: CALL 68981 0 1
134889: ST_TO_ADDR
// if class then
134890: LD_VAR 0 20
134894: IFFALSE 134910
// ComChangeProfession ( i , class ) ;
134896: LD_VAR 0 4
134900: PPUSH
134901: LD_VAR 0 20
134905: PPUSH
134906: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
134910: LD_VAR 0 16
134914: PUSH
134915: LD_VAR 0 2
134919: PPUSH
134920: LD_INT 21
134922: PUSH
134923: LD_INT 2
134925: PUSH
134926: EMPTY
134927: LIST
134928: LIST
134929: PPUSH
134930: CALL_OW 72
134934: PUSH
134935: LD_INT 1
134937: LESSEQUAL
134938: OR
134939: PUSH
134940: LD_VAR 0 19
134944: AND
134945: PUSH
134946: LD_VAR 0 4
134950: PUSH
134951: LD_VAR 0 17
134955: IN
134956: NOT
134957: AND
134958: IFFALSE 135051
// begin if b then
134960: LD_VAR 0 18
134964: IFFALSE 135013
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
134966: LD_VAR 0 18
134970: PPUSH
134971: LD_VAR 0 21
134975: PPUSH
134976: LD_VAR 0 18
134980: PPUSH
134981: CALL_OW 74
134985: PPUSH
134986: CALL_OW 296
134990: PUSH
134991: LD_INT 10
134993: LESS
134994: PUSH
134995: LD_VAR 0 18
134999: PPUSH
135000: CALL_OW 461
135004: PUSH
135005: LD_INT 7
135007: NONEQUAL
135008: AND
135009: IFFALSE 135013
// continue ;
135011: GO 134248
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
135013: LD_ADDR_VAR 0 17
135017: PUSH
135018: LD_VAR 0 17
135022: PPUSH
135023: LD_VAR 0 17
135027: PUSH
135028: LD_INT 1
135030: PLUS
135031: PPUSH
135032: LD_VAR 0 4
135036: PPUSH
135037: CALL_OW 1
135041: ST_TO_ADDR
// ComExitBuilding ( i ) ;
135042: LD_VAR 0 4
135046: PPUSH
135047: CALL_OW 122
// end ; if sold_defenders then
135051: LD_VAR 0 17
135055: IFFALSE 135115
// if i in sold_defenders then
135057: LD_VAR 0 4
135061: PUSH
135062: LD_VAR 0 17
135066: IN
135067: IFFALSE 135115
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
135069: LD_VAR 0 4
135073: PPUSH
135074: CALL_OW 314
135078: NOT
135079: PUSH
135080: LD_VAR 0 4
135084: PPUSH
135085: LD_VAR 0 13
135089: PPUSH
135090: CALL_OW 296
135094: PUSH
135095: LD_INT 30
135097: LESS
135098: AND
135099: IFFALSE 135115
// ComAttackUnit ( i , e ) ;
135101: LD_VAR 0 4
135105: PPUSH
135106: LD_VAR 0 13
135110: PPUSH
135111: CALL_OW 115
// end ; end ; end ;
135115: GO 135118
135117: POP
// if IsDead ( i ) then
135118: LD_VAR 0 4
135122: PPUSH
135123: CALL_OW 301
135127: IFFALSE 135145
// defenders := defenders diff i ;
135129: LD_ADDR_VAR 0 2
135133: PUSH
135134: LD_VAR 0 2
135138: PUSH
135139: LD_VAR 0 4
135143: DIFF
135144: ST_TO_ADDR
// end ;
135145: GO 134248
135147: POP
135148: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
135149: LD_VAR 0 21
135153: NOT
135154: PUSH
135155: LD_VAR 0 2
135159: NOT
135160: OR
135161: PUSH
135162: LD_EXP 99
135166: PUSH
135167: LD_VAR 0 1
135171: ARRAY
135172: NOT
135173: OR
135174: IFFALSE 134152
// MC_Reset ( base , 18 ) ;
135176: LD_VAR 0 1
135180: PPUSH
135181: LD_INT 18
135183: PPUSH
135184: CALL 40692 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135188: LD_ADDR_VAR 0 2
135192: PUSH
135193: LD_VAR 0 2
135197: PUSH
135198: LD_VAR 0 2
135202: PPUSH
135203: LD_INT 2
135205: PUSH
135206: LD_INT 25
135208: PUSH
135209: LD_INT 1
135211: PUSH
135212: EMPTY
135213: LIST
135214: LIST
135215: PUSH
135216: LD_INT 25
135218: PUSH
135219: LD_INT 5
135221: PUSH
135222: EMPTY
135223: LIST
135224: LIST
135225: PUSH
135226: LD_INT 25
135228: PUSH
135229: LD_INT 8
135231: PUSH
135232: EMPTY
135233: LIST
135234: LIST
135235: PUSH
135236: LD_INT 25
135238: PUSH
135239: LD_INT 9
135241: PUSH
135242: EMPTY
135243: LIST
135244: LIST
135245: PUSH
135246: EMPTY
135247: LIST
135248: LIST
135249: LIST
135250: LIST
135251: LIST
135252: PPUSH
135253: CALL_OW 72
135257: DIFF
135258: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
135259: LD_VAR 0 21
135263: NOT
135264: PUSH
135265: LD_VAR 0 2
135269: PPUSH
135270: LD_INT 21
135272: PUSH
135273: LD_INT 2
135275: PUSH
135276: EMPTY
135277: LIST
135278: LIST
135279: PPUSH
135280: CALL_OW 72
135284: AND
135285: IFFALSE 135623
// begin tmp := FilterByTag ( defenders , 19 ) ;
135287: LD_ADDR_VAR 0 11
135291: PUSH
135292: LD_VAR 0 2
135296: PPUSH
135297: LD_INT 19
135299: PPUSH
135300: CALL 102218 0 2
135304: ST_TO_ADDR
// if tmp then
135305: LD_VAR 0 11
135309: IFFALSE 135379
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
135311: LD_ADDR_VAR 0 11
135315: PUSH
135316: LD_VAR 0 11
135320: PPUSH
135321: LD_INT 25
135323: PUSH
135324: LD_INT 3
135326: PUSH
135327: EMPTY
135328: LIST
135329: LIST
135330: PPUSH
135331: CALL_OW 72
135335: ST_TO_ADDR
// if tmp then
135336: LD_VAR 0 11
135340: IFFALSE 135379
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
135342: LD_ADDR_EXP 111
135346: PUSH
135347: LD_EXP 111
135351: PPUSH
135352: LD_VAR 0 1
135356: PPUSH
135357: LD_EXP 111
135361: PUSH
135362: LD_VAR 0 1
135366: ARRAY
135367: PUSH
135368: LD_VAR 0 11
135372: UNION
135373: PPUSH
135374: CALL_OW 1
135378: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
135379: LD_VAR 0 1
135383: PPUSH
135384: LD_INT 19
135386: PPUSH
135387: CALL 40692 0 2
// repeat wait ( 0 0$1 ) ;
135391: LD_INT 35
135393: PPUSH
135394: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135398: LD_EXP 99
135402: PUSH
135403: LD_VAR 0 1
135407: ARRAY
135408: NOT
135409: PUSH
135410: LD_EXP 99
135414: PUSH
135415: LD_VAR 0 1
135419: ARRAY
135420: PUSH
135421: EMPTY
135422: EQUAL
135423: OR
135424: IFFALSE 135461
// begin for i in defenders do
135426: LD_ADDR_VAR 0 4
135430: PUSH
135431: LD_VAR 0 2
135435: PUSH
135436: FOR_IN
135437: IFFALSE 135450
// ComStop ( i ) ;
135439: LD_VAR 0 4
135443: PPUSH
135444: CALL_OW 141
135448: GO 135436
135450: POP
135451: POP
// defenders := [ ] ;
135452: LD_ADDR_VAR 0 2
135456: PUSH
135457: EMPTY
135458: ST_TO_ADDR
// exit ;
135459: GO 135687
// end ; for i in defenders do
135461: LD_ADDR_VAR 0 4
135465: PUSH
135466: LD_VAR 0 2
135470: PUSH
135471: FOR_IN
135472: IFFALSE 135561
// begin if not IsInArea ( i , mc_parking [ base ] ) then
135474: LD_VAR 0 4
135478: PPUSH
135479: LD_EXP 123
135483: PUSH
135484: LD_VAR 0 1
135488: ARRAY
135489: PPUSH
135490: CALL_OW 308
135494: NOT
135495: IFFALSE 135519
// ComMoveToArea ( i , mc_parking [ base ] ) else
135497: LD_VAR 0 4
135501: PPUSH
135502: LD_EXP 123
135506: PUSH
135507: LD_VAR 0 1
135511: ARRAY
135512: PPUSH
135513: CALL_OW 113
135517: GO 135559
// if GetControl ( i ) = control_manual then
135519: LD_VAR 0 4
135523: PPUSH
135524: CALL_OW 263
135528: PUSH
135529: LD_INT 1
135531: EQUAL
135532: IFFALSE 135559
// if IsDrivenBy ( i ) then
135534: LD_VAR 0 4
135538: PPUSH
135539: CALL_OW 311
135543: IFFALSE 135559
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
135545: LD_VAR 0 4
135549: PPUSH
135550: CALL_OW 311
135554: PPUSH
135555: CALL_OW 121
// end ;
135559: GO 135471
135561: POP
135562: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
135563: LD_VAR 0 2
135567: PPUSH
135568: LD_INT 95
135570: PUSH
135571: LD_EXP 123
135575: PUSH
135576: LD_VAR 0 1
135580: ARRAY
135581: PUSH
135582: EMPTY
135583: LIST
135584: LIST
135585: PPUSH
135586: CALL_OW 72
135590: PUSH
135591: LD_VAR 0 2
135595: EQUAL
135596: PUSH
135597: LD_EXP 122
135601: PUSH
135602: LD_VAR 0 1
135606: ARRAY
135607: OR
135608: PUSH
135609: LD_EXP 99
135613: PUSH
135614: LD_VAR 0 1
135618: ARRAY
135619: NOT
135620: OR
135621: IFFALSE 135391
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
135623: LD_ADDR_EXP 121
135627: PUSH
135628: LD_EXP 121
135632: PPUSH
135633: LD_VAR 0 1
135637: PPUSH
135638: LD_VAR 0 2
135642: PPUSH
135643: LD_INT 21
135645: PUSH
135646: LD_INT 2
135648: PUSH
135649: EMPTY
135650: LIST
135651: LIST
135652: PPUSH
135653: CALL_OW 72
135657: PPUSH
135658: CALL_OW 1
135662: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
135663: LD_VAR 0 1
135667: PPUSH
135668: LD_INT 19
135670: PPUSH
135671: CALL 40692 0 2
// MC_Reset ( base , 20 ) ;
135675: LD_VAR 0 1
135679: PPUSH
135680: LD_INT 20
135682: PPUSH
135683: CALL 40692 0 2
// end ; end_of_file
135687: LD_VAR 0 3
135691: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
135692: LD_VAR 0 1
135696: PUSH
135697: LD_INT 200
135699: DOUBLE
135700: GREATEREQUAL
135701: IFFALSE 135709
135703: LD_INT 299
135705: DOUBLE
135706: LESSEQUAL
135707: IFTRUE 135711
135709: GO 135743
135711: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
135712: LD_VAR 0 1
135716: PPUSH
135717: LD_VAR 0 2
135721: PPUSH
135722: LD_VAR 0 3
135726: PPUSH
135727: LD_VAR 0 4
135731: PPUSH
135732: LD_VAR 0 5
135736: PPUSH
135737: CALL 124478 0 5
135741: GO 135820
135743: LD_INT 300
135745: DOUBLE
135746: GREATEREQUAL
135747: IFFALSE 135755
135749: LD_INT 399
135751: DOUBLE
135752: LESSEQUAL
135753: IFTRUE 135757
135755: GO 135819
135757: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
135758: LD_VAR 0 1
135762: PPUSH
135763: LD_VAR 0 2
135767: PPUSH
135768: LD_VAR 0 3
135772: PPUSH
135773: LD_VAR 0 4
135777: PPUSH
135778: LD_VAR 0 5
135782: PPUSH
135783: LD_VAR 0 6
135787: PPUSH
135788: LD_VAR 0 7
135792: PPUSH
135793: LD_VAR 0 8
135797: PPUSH
135798: LD_VAR 0 9
135802: PPUSH
135803: LD_VAR 0 10
135807: PPUSH
135808: LD_VAR 0 11
135812: PPUSH
135813: CALL 120811 0 11
135817: GO 135820
135819: POP
// end ;
135820: PPOPN 11
135822: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
135823: LD_VAR 0 1
135827: PPUSH
135828: LD_VAR 0 2
135832: PPUSH
135833: LD_VAR 0 3
135837: PPUSH
135838: LD_VAR 0 4
135842: PPUSH
135843: LD_VAR 0 5
135847: PPUSH
135848: CALL 124214 0 5
// end ; end_of_file
135852: PPOPN 5
135854: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
135855: LD_VAR 0 1
135859: PPUSH
135860: LD_VAR 0 2
135864: PPUSH
135865: LD_VAR 0 3
135869: PPUSH
135870: LD_VAR 0 4
135874: PPUSH
135875: LD_VAR 0 5
135879: PPUSH
135880: LD_VAR 0 6
135884: PPUSH
135885: CALL 108504 0 6
// end ;
135889: PPOPN 6
135891: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
135892: LD_INT 0
135894: PPUSH
// begin if not units then
135895: LD_VAR 0 1
135899: NOT
135900: IFFALSE 135904
// exit ;
135902: GO 135904
// end ;
135904: PPOPN 7
135906: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
135907: CALL 108475 0 0
// end ;
135911: PPOPN 1
135913: END
