// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34877 0 0
// InitNature ;
  19: CALL 34701 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11057 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14951 0 0
// MC_Start ( ) ;
  60: CALL 36989 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 126
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 127
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59266 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59359 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58709 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58524 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59266 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59359 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58524 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58709 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59139 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58206 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59266 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59359 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 131
 955: PUSH
 956: LD_EXP 131
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58524 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59266 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59359 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58416 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59677 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58848 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59139 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59139 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59471 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58524 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59090 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64916 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 72091 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 72091 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 72091 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 72091 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 72091 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64916 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64916 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64916 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64916 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64916 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64916 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64916 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64916 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64916 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64916 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64916 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64916 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64916 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64916 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64916 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64916 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64916 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64916 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64916 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64916 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64916 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64916 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64916 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64916 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64916 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64916 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64916 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64916 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 72091 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64916 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64916 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64916 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 75500 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 102
4699: PUSH
4700: LD_EXP 102
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 60
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 62
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 72091 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 63
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 63
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 61
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 61
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 61
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 61
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 61
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 61
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 61
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 61
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 61
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 61
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 61
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 61
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58709 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58572 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 59990 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58572 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58572 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 59990 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 59990 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 121
5983: PUSH
5984: LD_EXP 121
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 121
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 72091 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 64
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 65
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7120: LD_ADDR_EXP 67
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: LD_EXP 1
7132: NOT
7133: PPUSH
7134: LD_STRING 09_
7136: PPUSH
7137: CALL 64916 0 3
7141: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7142: LD_ADDR_EXP 66
7146: PUSH
7147: LD_STRING Bystrov
7149: PPUSH
7150: CALL_OW 25
7154: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7155: LD_ADDR_EXP 68
7159: PUSH
7160: LD_STRING Gleb
7162: PPUSH
7163: CALL_OW 25
7167: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7168: LD_STRING 03_Cornel
7170: PPUSH
7171: CALL_OW 28
7175: IFFALSE 7223
// begin Bierezov := NewCharacter ( Mikhail ) ;
7177: LD_ADDR_EXP 69
7181: PUSH
7182: LD_STRING Mikhail
7184: PPUSH
7185: CALL_OW 25
7189: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 197
7197: PPUSH
7198: LD_INT 111
7200: PPUSH
7201: LD_INT 9
7203: PPUSH
7204: LD_INT 0
7206: PPUSH
7207: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7211: LD_EXP 69
7215: PPUSH
7216: LD_INT 3
7218: PPUSH
7219: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7223: LD_EXP 64
7227: PPUSH
7228: LD_INT 126
7230: PPUSH
7231: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 134
7242: PPUSH
7243: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7247: LD_EXP 67
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 66
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7289: LD_EXP 68
7293: PPUSH
7294: LD_INT 197
7296: PPUSH
7297: LD_INT 111
7299: PPUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: LD_INT 126
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_STRING zhukov
7323: PPUSH
7324: LD_INT 9
7326: PUSH
7327: LD_INT 10
7329: PUSH
7330: LD_INT 10
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: PUSH
7338: LD_OWVAR 67
7342: ARRAY
7343: PPUSH
7344: LD_INT 90000
7346: PUSH
7347: LD_INT 1000
7349: PUSH
7350: LD_INT 300
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: LD_INT 18
7360: PUSH
7361: LD_INT 8
7363: PUSH
7364: LD_INT 13
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL 75500 0 6
7380: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7381: LD_ADDR_VAR 0 4
7385: PUSH
7386: LD_INT 267
7388: PPUSH
7389: CALL_OW 274
7393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 5000
7404: PPUSH
7405: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 200
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 3
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7439: LD_ADDR_EXP 102
7443: PUSH
7444: LD_EXP 102
7448: PPUSH
7449: LD_INT 2
7451: PPUSH
7452: LD_VAR 0 5
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_VAR 0 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: LD_INT 3
7471: PUSH
7472: LD_INT 21
7474: PUSH
7475: LD_INT 2
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: UNION
7495: PUSH
7496: LD_EXP 64
7500: DIFF
7501: PPUSH
7502: CALL_OW 1
7506: ST_TO_ADDR
// behemoths := [ ] ;
7507: LD_ADDR_EXP 72
7511: PUSH
7512: EMPTY
7513: ST_TO_ADDR
// behemothBuilders := [ ] ;
7514: LD_ADDR_EXP 73
7518: PUSH
7519: EMPTY
7520: ST_TO_ADDR
// if Kovalyuk then
7521: LD_EXP 65
7525: IFFALSE 7547
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7527: LD_ADDR_EXP 73
7531: PUSH
7532: LD_EXP 73
7536: PPUSH
7537: LD_EXP 65
7541: PPUSH
7542: CALL 107846 0 2
7546: ST_TO_ADDR
// j := 3 ;
7547: LD_ADDR_VAR 0 3
7551: PUSH
7552: LD_INT 3
7554: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_INT 22
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 25
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: PUSH
7589: LD_EXP 65
7593: DIFF
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7646
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7598: LD_ADDR_EXP 73
7602: PUSH
7603: LD_EXP 73
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: CALL 107846 0 2
7617: ST_TO_ADDR
// j := j - 1 ;
7618: LD_ADDR_VAR 0 3
7622: PUSH
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 1
7630: MINUS
7631: ST_TO_ADDR
// if j = 0 then
7632: LD_VAR 0 3
7636: PUSH
7637: LD_INT 0
7639: EQUAL
7640: IFFALSE 7644
// break ;
7642: GO 7646
// end ;
7644: GO 7595
7646: POP
7647: POP
// end ;
7648: LD_VAR 0 1
7652: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
7657: PPUSH
7658: PPUSH
7659: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7660: LD_ADDR_VAR 0 4
7664: PUSH
7665: LD_INT 209
7667: PUSH
7668: LD_INT 149
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 219
7677: PUSH
7678: LD_INT 154
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 223
7687: PUSH
7688: LD_INT 149
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 232
7697: PUSH
7698: LD_INT 155
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: ST_TO_ADDR
// if not behemothBuilders then
7711: LD_EXP 73
7715: NOT
7716: IFFALSE 7720
// exit ;
7718: GO 7824
// j := 1 ;
7720: LD_ADDR_VAR 0 3
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// for i in behemothBuilders do
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_EXP 73
7737: PUSH
7738: FOR_IN
7739: IFFALSE 7822
// begin if IsInUnit ( i ) then
7741: LD_VAR 0 2
7745: PPUSH
7746: CALL_OW 310
7750: IFFALSE 7761
// ComExitBuilding ( i ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7761: LD_VAR 0 2
7765: PPUSH
7766: LD_INT 37
7768: PPUSH
7769: LD_VAR 0 4
7773: PUSH
7774: LD_VAR 0 3
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 2
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 230
// j := j + 1 ;
7806: LD_ADDR_VAR 0 3
7810: PUSH
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 1
7818: PLUS
7819: ST_TO_ADDR
// end ;
7820: GO 7738
7822: POP
7823: POP
// end ;
7824: LD_VAR 0 1
7828: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7829: LD_INT 24
7831: PPUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 37
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 70
7846: IFFALSE 7859
7848: GO 7850
7850: DISABLE
// behemothUnderConstruct := true ;
7851: LD_ADDR_EXP 26
7855: PUSH
7856: LD_INT 1
7858: ST_TO_ADDR
7859: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7860: LD_INT 3
7862: PPUSH
7863: CALL 107894 0 1
7867: PUSH
7868: LD_INT 22
7870: PUSH
7871: LD_INT 3
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 30
7880: PUSH
7881: LD_INT 37
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: AND
7898: IFFALSE 8084
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: PPUSH
7916: CALL 107894 0 1
7920: ST_TO_ADDR
// for i in tmp do
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_IN
7932: IFFALSE 8082
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_INT 9
7941: PPUSH
7942: CALL_OW 308
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 110
7956: PUSH
7957: LD_INT 2
7959: EQUAL
7960: NOT
7961: AND
7962: IFFALSE 7976
// SetTag ( i , 2 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7976: LD_INT 81
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 91
7988: PUSH
7989: LD_VAR 0 1
7993: PUSH
7994: LD_INT 12
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PPUSH
8006: CALL_OW 69
8010: NOT
8011: PUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 110
8021: PUSH
8022: LD_INT 2
8024: EQUAL
8025: NOT
8026: AND
8027: IFFALSE 8046
// ComAgressiveMove ( i , 64 , 93 ) else
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 64
8036: PPUSH
8037: LD_INT 93
8039: PPUSH
8040: CALL_OW 114
8044: GO 8080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 81
8053: PUSH
8054: LD_INT 3
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL_OW 69
8065: PPUSH
8066: LD_VAR 0 1
8070: PPUSH
8071: CALL_OW 74
8075: PPUSH
8076: CALL_OW 115
// end ;
8080: GO 7931
8082: POP
8083: POP
// end ;
8084: PPOPN 2
8086: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8087: LD_INT 0
8089: PPUSH
8090: PPUSH
8091: PPUSH
// result := [ ] ;
8092: LD_ADDR_VAR 0 2
8096: PUSH
8097: EMPTY
8098: ST_TO_ADDR
// uc_side := 6 ;
8099: LD_ADDR_OWVAR 20
8103: PUSH
8104: LD_INT 6
8106: ST_TO_ADDR
// uc_nation := 3 ;
8107: LD_ADDR_OWVAR 21
8111: PUSH
8112: LD_INT 3
8114: ST_TO_ADDR
// case strength of 1 :
8115: LD_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: DOUBLE
8123: EQUAL
8124: IFTRUE 8128
8126: GO 8266
8128: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8129: LD_ADDR_VAR 0 3
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_INT 4
8141: PUSH
8142: LD_INT 5
8144: PUSH
8145: LD_INT 6
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: PUSH
8159: FOR_TO
8160: IFFALSE 8262
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8162: LD_INT 22
8164: PUSH
8165: LD_INT 24
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_VAR 0 3
8176: PUSH
8177: LD_INT 2
8179: MOD
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: ARRAY
8185: PPUSH
8186: LD_INT 1
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: CALL_OW 12
8206: ARRAY
8207: PPUSH
8208: LD_INT 3
8210: PPUSH
8211: LD_INT 43
8213: PUSH
8214: LD_INT 44
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 1
8227: PPUSH
8228: LD_INT 3
8230: PPUSH
8231: CALL_OW 12
8235: ARRAY
8236: PPUSH
8237: LD_INT 80
8239: PPUSH
8240: CALL 72091 0 5
// result := result union CreateVehicle ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_VAR 0 2
8253: PUSH
8254: CALL_OW 45
8258: UNION
8259: ST_TO_ADDR
// end ;
8260: GO 8159
8262: POP
8263: POP
// end ; 2 :
8264: GO 9217
8266: LD_INT 2
8268: DOUBLE
8269: EQUAL
8270: IFTRUE 8274
8272: GO 8430
8274: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8275: LD_ADDR_VAR 0 3
8279: PUSH
8280: DOUBLE
8281: LD_INT 1
8283: DEC
8284: ST_TO_ADDR
8285: LD_INT 5
8287: PUSH
8288: LD_INT 6
8290: PUSH
8291: LD_INT 7
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PUSH
8299: LD_OWVAR 67
8303: ARRAY
8304: PUSH
8305: FOR_TO
8306: IFFALSE 8426
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8308: LD_INT 22
8310: PUSH
8311: LD_INT 24
8313: PUSH
8314: LD_INT 24
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_VAR 0 3
8326: PUSH
8327: LD_INT 3
8329: MOD
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ARRAY
8335: PPUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 3
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 1
8348: PPUSH
8349: LD_INT 2
8351: PPUSH
8352: CALL_OW 12
8356: ARRAY
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 43
8363: PUSH
8364: LD_INT 44
8366: PUSH
8367: LD_INT 45
8369: PUSH
8370: LD_INT 44
8372: PUSH
8373: LD_INT 46
8375: PUSH
8376: LD_INT 46
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_VAR 0 3
8391: PUSH
8392: LD_INT 6
8394: MOD
8395: PUSH
8396: LD_INT 1
8398: PLUS
8399: ARRAY
8400: PPUSH
8401: LD_INT 80
8403: PPUSH
8404: CALL 72091 0 5
// result := result union CreateVehicle ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: CALL_OW 45
8422: UNION
8423: ST_TO_ADDR
// end ;
8424: GO 8305
8426: POP
8427: POP
// end ; 3 :
8428: GO 9217
8430: LD_INT 3
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8594
8438: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 5
8451: PUSH
8452: LD_INT 7
8454: PUSH
8455: LD_INT 8
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 43
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 72091 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// end ; 4 :
8592: GO 9217
8594: LD_INT 4
8596: DOUBLE
8597: EQUAL
8598: IFTRUE 8602
8600: GO 9216
8602: POP
// begin uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8611: LD_ADDR_VAR 0 3
8615: PUSH
8616: DOUBLE
8617: LD_INT 1
8619: DEC
8620: ST_TO_ADDR
8621: LD_INT 6
8623: PUSH
8624: LD_INT 8
8626: PUSH
8627: LD_INT 9
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: FOR_TO
8642: IFFALSE 8762
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8644: LD_INT 22
8646: PUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 3
8665: MOD
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_INT 1
8674: PUSH
8675: LD_INT 3
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ARRAY
8693: PPUSH
8694: LD_INT 3
8696: PPUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 47
8702: PUSH
8703: LD_INT 47
8705: PUSH
8706: LD_INT 45
8708: PUSH
8709: LD_INT 46
8711: PUSH
8712: LD_INT 46
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: PUSH
8723: LD_VAR 0 3
8727: PUSH
8728: LD_INT 6
8730: MOD
8731: PUSH
8732: LD_INT 1
8734: PLUS
8735: ARRAY
8736: PPUSH
8737: LD_INT 80
8739: PPUSH
8740: CALL 72091 0 5
// result := result union CreateVehicle ;
8744: LD_ADDR_VAR 0 2
8748: PUSH
8749: LD_VAR 0 2
8753: PUSH
8754: CALL_OW 45
8758: UNION
8759: ST_TO_ADDR
// end ;
8760: GO 8641
8762: POP
8763: POP
// if not KappaStatus then
8764: LD_EXP 2
8768: NOT
8769: IFFALSE 9004
// begin uc_nation := 1 ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// for i = 1 to 3 do
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: DOUBLE
8785: LD_INT 1
8787: DEC
8788: ST_TO_ADDR
8789: LD_INT 3
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8929
// begin j := rand ( 0 , 1 ) ;
8795: LD_ADDR_VAR 0 4
8799: PUSH
8800: LD_INT 0
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL_OW 12
8810: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8811: LD_INT 3
8813: PUSH
8814: LD_INT 5
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 4
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 1
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 2
8862: PPUSH
8863: CALL_OW 12
8867: ARRAY
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 9
8874: PUSH
8875: LD_INT 7
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: PPUSH
8894: LD_INT 2
8896: PPUSH
8897: CALL_OW 12
8901: PLUS
8902: ARRAY
8903: PPUSH
8904: LD_INT 85
8906: PPUSH
8907: CALL 72091 0 5
// result := result union CreateVehicle ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_VAR 0 2
8920: PUSH
8921: CALL_OW 45
8925: UNION
8926: ST_TO_ADDR
// end ;
8927: GO 8792
8929: POP
8930: POP
// if vsevolodFirstAttack then
8931: LD_EXP 24
8935: IFFALSE 9002
// begin vsevolodFirstAttack := false ;
8937: LD_ADDR_EXP 24
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8945: LD_INT 5
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 6
8956: PPUSH
8957: LD_INT 100
8959: PPUSH
8960: CALL 72091 0 5
// sewiVeh := CreateVehicle ;
8964: LD_ADDR_EXP 71
8968: PUSH
8969: CALL_OW 45
8973: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8974: LD_EXP 71
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 242
// result := result union sewiVeh ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 2
8995: PUSH
8996: LD_EXP 71
9000: UNION
9001: ST_TO_ADDR
// end ; end else
9002: GO 9214
// if vsevolodFirstAttack then
9004: LD_EXP 24
9008: IFFALSE 9214
// begin vsevolodFirstAttack := false ;
9010: LD_ADDR_EXP 24
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9026: LD_ADDR_VAR 0 3
9030: PUSH
9031: DOUBLE
9032: LD_INT 1
9034: DEC
9035: ST_TO_ADDR
9036: LD_INT 2
9038: PUSH
9039: LD_OWVAR 67
9043: PLUS
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9154
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 45
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 47
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_INT 3
9122: MOD
9123: PUSH
9124: LD_INT 1
9126: PLUS
9127: ARRAY
9128: PPUSH
9129: LD_INT 80
9131: PPUSH
9132: CALL 72091 0 5
// result := result union CreateVehicle ;
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: LD_VAR 0 2
9145: PUSH
9146: CALL_OW 45
9150: UNION
9151: ST_TO_ADDR
// end ;
9152: GO 9045
9154: POP
9155: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9156: LD_INT 24
9158: PPUSH
9159: LD_INT 3
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 47
9167: PPUSH
9168: LD_INT 100
9170: PPUSH
9171: CALL 72091 0 5
// sewiVeh := CreateVehicle ;
9175: LD_ADDR_EXP 71
9179: PUSH
9180: CALL_OW 45
9184: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9185: LD_EXP 71
9189: PPUSH
9190: LD_INT 6
9192: NEG
9193: PPUSH
9194: CALL_OW 242
// result := result union sewiVeh ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: LD_EXP 71
9212: UNION
9213: ST_TO_ADDR
// end ; end ; end ;
9214: GO 9217
9216: POP
// end ;
9217: LD_VAR 0 2
9221: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9222: LD_EXP 16
9226: IFFALSE 10067
9228: GO 9230
9230: DISABLE
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9239: LD_ADDR_VAR 0 4
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 12
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9254: LD_ADDR_VAR 0 3
9258: PUSH
9259: LD_INT 11550
9261: PUSH
9262: LD_INT 10150
9264: PUSH
9265: LD_INT 9800
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_OWVAR 67
9277: ARRAY
9278: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9279: LD_ADDR_VAR 0 6
9283: PUSH
9284: LD_INT 70
9286: PUSH
9287: LD_INT 118
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 78
9296: PUSH
9297: LD_INT 31
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: ST_TO_ADDR
// repeat if missionStage = 2 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: IFFALSE 9327
// wait ( 1 1$30 ) else
9318: LD_INT 3150
9320: PPUSH
9321: CALL_OW 67
9325: GO 9336
// wait ( time ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: CALL_OW 67
// if missionStage = 6 then
9336: LD_EXP 15
9340: PUSH
9341: LD_INT 6
9343: EQUAL
9344: IFFALSE 9372
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9346: LD_INT 51
9348: PPUSH
9349: LD_INT 6
9351: PPUSH
9352: LD_INT 2
9354: PPUSH
9355: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9359: LD_INT 57
9361: PPUSH
9362: LD_INT 6
9364: PPUSH
9365: LD_INT 2
9367: PPUSH
9368: CALL_OW 322
// end ; if missionStage = 8 then
9372: LD_EXP 15
9376: PUSH
9377: LD_INT 8
9379: EQUAL
9380: IFFALSE 9408
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9382: LD_INT 52
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9395: LD_INT 58
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 10
9415: EQUAL
9416: PUSH
9417: LD_OWVAR 67
9421: PUSH
9422: LD_INT 1
9424: GREATER
9425: AND
9426: IFFALSE 9454
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9428: LD_INT 53
9430: PPUSH
9431: LD_INT 6
9433: PPUSH
9434: LD_INT 2
9436: PPUSH
9437: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9441: LD_INT 59
9443: PPUSH
9444: LD_INT 6
9446: PPUSH
9447: LD_INT 2
9449: PPUSH
9450: CALL_OW 322
// end ; if activeAttacks then
9454: LD_EXP 16
9458: IFFALSE 10061
// begin if missionStage = 2 then
9460: LD_EXP 15
9464: PUSH
9465: LD_INT 2
9467: EQUAL
9468: IFFALSE 9478
// strength := 1 ;
9470: LD_ADDR_VAR 0 5
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// if missionStage > 2 then
9478: LD_EXP 15
9482: PUSH
9483: LD_INT 2
9485: GREATER
9486: IFFALSE 9496
// strength := 2 ;
9488: LD_ADDR_VAR 0 5
9492: PUSH
9493: LD_INT 2
9495: ST_TO_ADDR
// if missionStage > 6 then
9496: LD_EXP 15
9500: PUSH
9501: LD_INT 6
9503: GREATER
9504: IFFALSE 9514
// strength := 3 ;
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: LD_INT 3
9513: ST_TO_ADDR
// if missionStage > 10 then
9514: LD_EXP 15
9518: PUSH
9519: LD_INT 10
9521: GREATER
9522: IFFALSE 9532
// strength := 4 ;
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_INT 4
9531: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9532: LD_ADDR_VAR 0 2
9536: PUSH
9537: LD_VAR 0 5
9541: PPUSH
9542: CALL 8087 0 1
9546: ST_TO_ADDR
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9741
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9560: LD_VAR 0 1
9564: PPUSH
9565: LD_VAR 0 4
9569: PUSH
9570: LD_INT 1
9572: PPUSH
9573: LD_INT 2
9575: PPUSH
9576: CALL_OW 12
9580: ARRAY
9581: PPUSH
9582: LD_INT 0
9584: PPUSH
9585: CALL_OW 49
// if i = sewiVeh then
9589: LD_VAR 0 1
9593: PUSH
9594: LD_EXP 71
9598: EQUAL
9599: IFFALSE 9636
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9601: LD_ADDR_EXP 70
9605: PUSH
9606: LD_STRING Vsevolod
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: LD_STRING 
9614: PPUSH
9615: CALL 64916 0 3
9619: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9620: LD_EXP 70
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 52
// end else
9634: GO 9717
// if GetControl ( i ) = control_manual then
9636: LD_VAR 0 1
9640: PPUSH
9641: CALL_OW 263
9645: PUSH
9646: LD_INT 1
9648: EQUAL
9649: IFFALSE 9717
// begin uc_side := 6 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 6
9658: ST_TO_ADDR
// uc_nation := 3 ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// hc_gallery :=  ;
9667: LD_ADDR_OWVAR 33
9671: PUSH
9672: LD_STRING 
9674: ST_TO_ADDR
// hc_name :=  ;
9675: LD_ADDR_OWVAR 26
9679: PUSH
9680: LD_STRING 
9682: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9683: LD_INT 0
9685: PPUSH
9686: LD_INT 3
9688: PPUSH
9689: LD_INT 10
9691: PPUSH
9692: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9696: CALL_OW 44
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9710: LD_INT 10
9712: PPUSH
9713: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: LD_INT 111
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: CALL_OW 111
// wait ( 0 0$2 ) ;
9732: LD_INT 70
9734: PPUSH
9735: CALL_OW 67
// end ;
9739: GO 9557
9741: POP
9742: POP
// repeat wait ( 0 0$1 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 10042
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9763: LD_INT 81
9765: PUSH
9766: LD_INT 6
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 91
9775: PUSH
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 12
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: IFFALSE 9855
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 81
9806: PUSH
9807: LD_INT 6
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: LD_INT 91
9816: PUSH
9817: LD_VAR 0 1
9821: PUSH
9822: LD_INT 12
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 74
9848: PPUSH
9849: CALL_OW 115
9853: GO 10040
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9855: LD_INT 9
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 6
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 70
9872: IFFALSE 10006
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_VAR 0 6
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: PPUSH
9892: LD_VAR 0 6
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PUSH
9901: LD_INT 2
9903: ARRAY
9904: PPUSH
9905: CALL_OW 297
9909: PUSH
9910: LD_INT 10
9912: GREATER
9913: PUSH
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 9
9921: PPUSH
9922: CALL_OW 308
9926: NOT
9927: AND
9928: IFFALSE 9967
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 6
9939: PUSH
9940: LD_INT 1
9942: ARRAY
9943: PUSH
9944: LD_INT 1
9946: ARRAY
9947: PPUSH
9948: LD_VAR 0 6
9952: PUSH
9953: LD_INT 1
9955: ARRAY
9956: PUSH
9957: LD_INT 2
9959: ARRAY
9960: PPUSH
9961: CALL_OW 114
9965: GO 10004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9967: LD_VAR 0 1
9971: PPUSH
9972: LD_INT 9
9974: PPUSH
9975: LD_INT 81
9977: PUSH
9978: LD_INT 6
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PPUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: CALL_OW 74
9999: PPUSH
10000: CALL_OW 115
// end else
10004: GO 10040
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: LD_INT 81
10013: PUSH
10014: LD_INT 6
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: PPUSH
10036: CALL_OW 115
// end ;
10040: GO 9760
10042: POP
10043: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10044: LD_INT 22
10046: PUSH
10047: LD_INT 6
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: NOT
10059: IFFALSE 9743
// end ; until russianDestroyed ;
10061: LD_EXP 21
10065: IFFALSE 9308
// end ;
10067: PPOPN 6
10069: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10070: LD_EXP 21
10074: NOT
10075: PUSH
10076: LD_EXP 15
10080: PUSH
10081: LD_INT 6
10083: GREATEREQUAL
10084: AND
10085: PUSH
10086: LD_INT 2
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL 59990 0 2
10096: NOT
10097: AND
10098: IFFALSE 11054
10100: GO 10102
10102: DISABLE
10103: LD_INT 0
10105: PPUSH
10106: PPUSH
10107: PPUSH
10108: PPUSH
// begin enable ;
10109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10110: LD_INT 22
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 30
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PPUSH
10134: CALL_OW 69
10138: NOT
10139: IFFALSE 10143
// exit ;
10141: GO 11054
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10143: LD_ADDR_VAR 0 4
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 30
10160: PUSH
10161: LD_INT 34
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PPUSH
10172: CALL_OW 69
10176: ST_TO_ADDR
// if Prob ( 40 ) then
10177: LD_INT 40
10179: PPUSH
10180: CALL_OW 13
10184: IFFALSE 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 49
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 22
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 49
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL 58572 0 2
// end else
10309: GO 10434
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10311: LD_INT 2
10313: PPUSH
10314: LD_INT 24
10316: PUSH
10317: LD_INT 3
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: LD_INT 47
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 24
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 3
10340: PUSH
10341: LD_INT 47
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 24
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 3
10358: PUSH
10359: LD_INT 47
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: PUSH
10368: LD_INT 24
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 3
10376: PUSH
10377: LD_INT 46
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 24
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 3
10412: PUSH
10413: LD_INT 46
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL 58572 0 2
// end ; if Difficulty > 1 then
10434: LD_OWVAR 67
10438: PUSH
10439: LD_INT 1
10441: GREATER
10442: IFFALSE 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 47
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 58572 0 2
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10479: LD_INT 2
10481: PPUSH
10482: LD_INT 1
10484: PPUSH
10485: CALL 59990 0 2
10489: PUSH
10490: LD_INT 6
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: LD_INT 7
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_OWVAR 67
10508: ARRAY
10509: GREATEREQUAL
10510: IFFALSE 10472
// wait ( 0 0$30 ) ;
10512: LD_INT 1050
10514: PPUSH
10515: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_INT 2
10526: PPUSH
10527: LD_INT 1
10529: PPUSH
10530: CALL 59990 0 2
10534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10535: LD_ADDR_EXP 121
10539: PUSH
10540: LD_EXP 121
10544: PPUSH
10545: LD_INT 2
10547: PPUSH
10548: LD_EXP 121
10552: PUSH
10553: LD_INT 2
10555: ARRAY
10556: PUSH
10557: LD_VAR 0 2
10561: DIFF
10562: PPUSH
10563: CALL_OW 1
10567: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10568: LD_ADDR_VAR 0 3
10572: PUSH
10573: LD_INT 0
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 12
10583: ST_TO_ADDR
// if target then
10584: LD_VAR 0 3
10588: IFFALSE 10716
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10590: LD_ADDR_VAR 0 2
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_INT 24
10602: PUSH
10603: LD_INT 250
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 72
10614: ST_TO_ADDR
// for i in tmp do
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 2
10624: PUSH
10625: FOR_IN
10626: IFFALSE 10666
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: LD_INT 89
10638: PPUSH
10639: CALL_OW 297
10643: PUSH
10644: LD_INT 9
10646: GREATER
10647: IFFALSE 10664
// ComMoveXY ( i , 139 , 89 ) ;
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: LD_INT 89
10659: PPUSH
10660: CALL_OW 111
10664: GO 10625
10666: POP
10667: POP
// wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_INT 92
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 89
10688: PUSH
10689: LD_INT 9
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 72
10702: PUSH
10703: LD_VAR 0 2
10707: PUSH
10708: LD_INT 1
10710: MINUS
10711: GREATEREQUAL
10712: IFFALSE 10590
// end else
10714: GO 10858
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10716: LD_VAR 0 2
10720: PPUSH
10721: LD_VAR 0 4
10725: PUSH
10726: LD_INT 1
10728: ARRAY
10729: PPUSH
10730: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: LD_INT 24
10746: PUSH
10747: LD_INT 250
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 72
10758: ST_TO_ADDR
// for i in tmp do
10759: LD_ADDR_VAR 0 1
10763: PUSH
10764: LD_VAR 0 2
10768: PUSH
10769: FOR_IN
10770: IFFALSE 10810
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 124
10779: PPUSH
10780: LD_INT 139
10782: PPUSH
10783: CALL_OW 297
10787: PUSH
10788: LD_INT 9
10790: GREATER
10791: IFFALSE 10808
// ComMoveXY ( i , 124 , 139 ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_INT 124
10800: PPUSH
10801: LD_INT 139
10803: PPUSH
10804: CALL_OW 111
10808: GO 10769
10810: POP
10811: POP
// wait ( 0 0$1 ) ;
10812: LD_INT 35
10814: PPUSH
10815: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_INT 92
10826: PUSH
10827: LD_INT 124
10829: PUSH
10830: LD_INT 139
10832: PUSH
10833: LD_INT 9
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 72
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 1
10854: MINUS
10855: GREATEREQUAL
10856: IFFALSE 10734
// end ; repeat wait ( 0 0$1 ) ;
10858: LD_INT 35
10860: PPUSH
10861: CALL_OW 67
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 11045
// begin if GetLives ( i ) > 251 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 256
10887: PUSH
10888: LD_INT 251
10890: GREATER
10891: IFFALSE 11016
// begin if GetWeapon ( i ) = ru_time_lapser then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 264
10902: PUSH
10903: LD_INT 49
10905: EQUAL
10906: IFFALSE 10962
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 2
10915: PUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 8
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: PPUSH
10946: LD_VAR 0 1
10950: PPUSH
10951: CALL_OW 74
10955: PPUSH
10956: CALL_OW 112
10960: GO 11014
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10962: LD_VAR 0 1
10966: PPUSH
10967: LD_INT 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 8
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 69
10999: PPUSH
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 74
11009: PPUSH
11010: CALL_OW 115
// end else
11014: GO 11043
// if IsDead ( i ) then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 301
11025: IFFALSE 11043
// tmp := tmp diff i ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 1
11041: DIFF
11042: ST_TO_ADDR
// end ;
11043: GO 10875
11045: POP
11046: POP
// until not tmp ;
11047: LD_VAR 0 2
11051: NOT
11052: IFFALSE 10858
// end ; end_of_file
11054: PPOPN 4
11056: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11057: LD_INT 0
11059: PPUSH
11060: PPUSH
11061: PPUSH
11062: PPUSH
11063: PPUSH
11064: PPUSH
// side := 7 ;
11065: LD_ADDR_VAR 0 5
11069: PUSH
11070: LD_INT 7
11072: ST_TO_ADDR
// uc_side := side ;
11073: LD_ADDR_OWVAR 20
11077: PUSH
11078: LD_VAR 0 5
11082: ST_TO_ADDR
// uc_nation := 1 ;
11083: LD_ADDR_OWVAR 21
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11091: LD_ADDR_VAR 0 2
11095: PUSH
11096: LD_INT 22
11098: PUSH
11099: LD_VAR 0 5
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 3
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PPUSH
11122: CALL_OW 69
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11144
// SetBLevel ( i , 10 ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: LD_INT 10
11137: PPUSH
11138: CALL_OW 241
11142: GO 11127
11144: POP
11145: POP
// base := GetBase ( al_depot ) ;
11146: LD_ADDR_VAR 0 4
11150: PUSH
11151: LD_INT 2
11153: PPUSH
11154: CALL_OW 274
11158: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11159: LD_ADDR_VAR 0 6
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_VAR 0 5
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: LD_INT 30
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 69
11194: ST_TO_ADDR
// if teleport then
11195: LD_VAR 0 6
11199: IFFALSE 11220
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11201: LD_VAR 0 6
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_INT 262
11212: PPUSH
11213: LD_INT 119
11215: PPUSH
11216: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11220: LD_VAR 0 4
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 19500
11230: PPUSH
11231: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 2
11242: PPUSH
11243: LD_INT 200
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 3
11257: PPUSH
11258: LD_INT 650
11260: PPUSH
11261: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11265: LD_ADDR_EXP 74
11269: PUSH
11270: LD_STRING Roth
11272: PPUSH
11273: CALL_OW 25
11277: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_STRING Simms
11285: PPUSH
11286: LD_EXP 1
11290: NOT
11291: PPUSH
11292: LD_STRING 10c_
11294: PPUSH
11295: CALL 64916 0 3
11299: ST_TO_ADDR
// if not Simms then
11300: LD_EXP 75
11304: NOT
11305: IFFALSE 11335
// begin uc_nation := 1 ;
11307: LD_ADDR_OWVAR 21
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11315: LD_INT 2
11317: PPUSH
11318: LD_INT 10
11320: PPUSH
11321: CALL_OW 384
// Simms := CreateHuman ;
11325: LD_ADDR_EXP 75
11329: PUSH
11330: CALL_OW 44
11334: ST_TO_ADDR
// end ; uc_nation := 3 ;
11335: LD_ADDR_OWVAR 21
11339: PUSH
11340: LD_INT 3
11342: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11343: LD_ADDR_EXP 76
11347: PUSH
11348: LD_STRING Kirilenkova
11350: PPUSH
11351: CALL_OW 25
11355: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11356: LD_ADDR_EXP 90
11360: PUSH
11361: LD_STRING Oblukov
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11369: LD_ADDR_EXP 77
11373: PUSH
11374: LD_STRING Dolgov
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11382: LD_ADDR_EXP 78
11386: PUSH
11387: LD_STRING Petrosyan
11389: PPUSH
11390: CALL_OW 25
11394: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11395: LD_ADDR_EXP 89
11399: PUSH
11400: LD_STRING Scholtze
11402: PPUSH
11403: CALL_OW 25
11407: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11408: LD_ADDR_EXP 88
11412: PUSH
11413: LD_STRING Kapitsova
11415: PPUSH
11416: CALL_OW 25
11420: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11421: LD_ADDR_EXP 79
11425: PUSH
11426: LD_STRING Petrovova
11428: PPUSH
11429: CALL_OW 25
11433: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11434: LD_ADDR_EXP 80
11438: PUSH
11439: LD_STRING Kuzmov
11441: PPUSH
11442: CALL_OW 25
11446: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11447: LD_ADDR_EXP 87
11451: PUSH
11452: LD_STRING Karamazov
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11460: LD_STRING 13_Lipshchin_1
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 30
11470: IFFALSE 11485
// Lipshchin := NewCharacter ( Lipshchin ) ;
11472: LD_ADDR_EXP 81
11476: PUSH
11477: LD_STRING Lipshchin
11479: PPUSH
11480: CALL_OW 25
11484: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11485: LD_STRING 13_Titov_1
11487: PPUSH
11488: LD_INT 0
11490: PPUSH
11491: CALL_OW 30
11495: IFFALSE 11510
// Titov := NewCharacter ( Titov ) ;
11497: LD_ADDR_EXP 83
11501: PUSH
11502: LD_STRING Titov
11504: PPUSH
11505: CALL_OW 25
11509: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11510: LD_STRING 13_Gnyevko_1
11512: PPUSH
11513: LD_INT 0
11515: PPUSH
11516: CALL_OW 30
11520: IFFALSE 11535
// Gnyevko := NewCharacter ( Gnyevko ) ;
11522: LD_ADDR_EXP 82
11526: PUSH
11527: LD_STRING Gnyevko
11529: PPUSH
11530: CALL_OW 25
11534: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11535: LD_STRING 13_Xavier_1
11537: PPUSH
11538: LD_INT 0
11540: PPUSH
11541: CALL_OW 30
11545: IFFALSE 11560
// Xavier := NewCharacter ( Xavier2 ) ;
11547: LD_ADDR_EXP 84
11551: PUSH
11552: LD_STRING Xavier2
11554: PPUSH
11555: CALL_OW 25
11559: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11560: LD_STRING 13_Belkov_1
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 30
11570: IFFALSE 11585
// Belkov := NewCharacter ( Belkov ) ;
11572: LD_ADDR_EXP 85
11576: PUSH
11577: LD_STRING Belkov
11579: PPUSH
11580: CALL_OW 25
11584: ST_TO_ADDR
// if not BurlakStatus then
11585: LD_EXP 9
11589: NOT
11590: IFFALSE 11605
// Burlak = NewCharacter ( Burlak ) ;
11592: LD_ADDR_EXP 86
11596: PUSH
11597: LD_STRING Burlak
11599: PPUSH
11600: CALL_OW 25
11604: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_EXP 74
11614: PUSH
11615: LD_EXP 76
11619: PUSH
11620: LD_EXP 90
11624: PUSH
11625: LD_EXP 77
11629: PUSH
11630: LD_EXP 78
11634: PUSH
11635: LD_EXP 89
11639: PUSH
11640: LD_EXP 88
11644: PUSH
11645: LD_EXP 79
11649: PUSH
11650: LD_EXP 80
11654: PUSH
11655: LD_EXP 87
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: ST_TO_ADDR
// if Simms then
11672: LD_EXP 75
11676: IFFALSE 11694
// tmp := tmp ^ Simms ;
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_EXP 75
11692: ADD
11693: ST_TO_ADDR
// if Titov then
11694: LD_EXP 83
11698: IFFALSE 11716
// tmp := tmp ^ Titov ;
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_EXP 83
11714: ADD
11715: ST_TO_ADDR
// if Lipshchin then
11716: LD_EXP 81
11720: IFFALSE 11738
// tmp := tmp ^ Lipshchin ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_EXP 81
11736: ADD
11737: ST_TO_ADDR
// if Gnyevko then
11738: LD_EXP 82
11742: IFFALSE 11760
// tmp := tmp ^ Gnyevko ;
11744: LD_ADDR_VAR 0 3
11748: PUSH
11749: LD_VAR 0 3
11753: PUSH
11754: LD_EXP 82
11758: ADD
11759: ST_TO_ADDR
// if Xavier then
11760: LD_EXP 84
11764: IFFALSE 11782
// tmp := tmp ^ Xavier ;
11766: LD_ADDR_VAR 0 3
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_EXP 84
11780: ADD
11781: ST_TO_ADDR
// if Belkov then
11782: LD_EXP 85
11786: IFFALSE 11804
// tmp := tmp ^ Belkov ;
11788: LD_ADDR_VAR 0 3
11792: PUSH
11793: LD_VAR 0 3
11797: PUSH
11798: LD_EXP 85
11802: ADD
11803: ST_TO_ADDR
// if Burlak then
11804: LD_EXP 86
11808: IFFALSE 11826
// tmp := tmp ^ Burlak ;
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_VAR 0 3
11819: PUSH
11820: LD_EXP 86
11824: ADD
11825: ST_TO_ADDR
// for i = 1 to 11 do
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: DOUBLE
11832: LD_INT 1
11834: DEC
11835: ST_TO_ADDR
11836: LD_INT 11
11838: PUSH
11839: FOR_TO
11840: IFFALSE 11906
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11842: LD_ADDR_OWVAR 21
11846: PUSH
11847: LD_INT 1
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: CALL_OW 12
11867: ARRAY
11868: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11869: LD_INT 0
11871: PPUSH
11872: LD_VAR 0 2
11876: PUSH
11877: LD_INT 2
11879: DIV
11880: PPUSH
11881: LD_INT 10
11883: PPUSH
11884: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: CALL_OW 44
11902: ADD
11903: ST_TO_ADDR
// end ;
11904: GO 11839
11906: POP
11907: POP
// for i in tmp do
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: LD_VAR 0 3
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11944
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11921: LD_VAR 0 2
11925: PPUSH
11926: LD_INT 260
11928: PPUSH
11929: LD_INT 235
11931: PPUSH
11932: LD_INT 8
11934: PPUSH
11935: LD_INT 0
11937: PPUSH
11938: CALL_OW 50
11942: GO 11918
11944: POP
11945: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11946: LD_ADDR_EXP 102
11950: PUSH
11951: LD_EXP 102
11955: PPUSH
11956: LD_INT 1
11958: PPUSH
11959: LD_INT 22
11961: PUSH
11962: LD_VAR 0 5
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 21
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: PUSH
11997: LD_EXP 74
12001: PUSH
12002: LD_EXP 75
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: DIFF
12011: PPUSH
12012: CALL_OW 1
12016: ST_TO_ADDR
// uc_side := 0 ;
12017: LD_ADDR_OWVAR 20
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// uc_nation := 0 ;
12025: LD_ADDR_OWVAR 21
12029: PUSH
12030: LD_INT 0
12032: ST_TO_ADDR
// for i = 1 to 5 do
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: DOUBLE
12039: LD_INT 1
12041: DEC
12042: ST_TO_ADDR
12043: LD_INT 5
12045: PUSH
12046: FOR_TO
12047: IFFALSE 12084
// begin InitHc ;
12049: CALL_OW 19
// hc_class := class_apeman ;
12053: LD_ADDR_OWVAR 28
12057: PUSH
12058: LD_INT 12
12060: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12061: CALL_OW 44
12065: PPUSH
12066: LD_INT 299
12068: PPUSH
12069: LD_INT 229
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 50
// end ;
12082: GO 12046
12084: POP
12085: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12086: LD_EXP 74
12090: PPUSH
12091: LD_INT 259
12093: PPUSH
12094: LD_INT 235
12096: PPUSH
12097: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 262
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 178
// if Simms then
12116: LD_EXP 75
12120: IFFALSE 12151
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12122: LD_EXP 75
12126: PPUSH
12127: LD_INT 262
12129: PPUSH
12130: LD_INT 235
12132: PPUSH
12133: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_EXP 74
12146: PPUSH
12147: CALL_OW 179
// end ; end ;
12151: LD_VAR 0 1
12155: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12156: LD_EXP 31
12160: PUSH
12161: LD_EXP 23
12165: NOT
12166: AND
12167: IFFALSE 12343
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
12175: PPUSH
12176: PPUSH
// begin enable ;
12177: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12178: LD_ADDR_VAR 0 2
12182: PUSH
12183: LD_INT 81
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 3
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 30
12208: PUSH
12209: LD_INT 30
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PUSH
12216: LD_INT 30
12218: PUSH
12219: LD_INT 28
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: PUSH
12226: LD_INT 34
12228: PUSH
12229: LD_INT 49
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 34
12238: PUSH
12239: LD_INT 10
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 34
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PPUSH
12269: CALL_OW 69
12273: ST_TO_ADDR
// if not tmp then
12274: LD_VAR 0 2
12278: NOT
12279: IFFALSE 12283
// exit ;
12281: GO 12343
// target := tmp [ rand ( 1 , tmp ) ] ;
12283: LD_ADDR_VAR 0 3
12287: PUSH
12288: LD_VAR 0 2
12292: PUSH
12293: LD_INT 1
12295: PPUSH
12296: LD_VAR 0 2
12300: PPUSH
12301: CALL_OW 12
12305: ARRAY
12306: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 255
12316: PUSH
12317: LD_INT 1
12319: EQUAL
12320: IFFALSE 12331
// CenterNowOnUnits ( target ) ;
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 87
// SetLives ( target , 0 ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 234
// end ;
12343: PPOPN 3
12345: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12346: LD_EXP 23
12350: NOT
12351: PUSH
12352: LD_EXP 31
12356: AND
12357: IFFALSE 12879
12359: GO 12361
12361: DISABLE
12362: LD_INT 0
12364: PPUSH
12365: PPUSH
12366: PPUSH
// begin uc_side := 7 ;
12367: LD_ADDR_OWVAR 20
12371: PUSH
12372: LD_INT 7
12374: ST_TO_ADDR
// uc_nation := 1 ;
12375: LD_ADDR_OWVAR 21
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12383: LD_ADDR_VAR 0 3
12387: PUSH
12388: LD_INT 125
12390: PUSH
12391: LD_INT 163
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 185
12400: PUSH
12401: LD_INT 168
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 111
12410: PUSH
12411: LD_INT 97
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL 107938 0 1
12427: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12428: LD_ADDR_EXP 91
12432: PUSH
12433: EMPTY
12434: ST_TO_ADDR
// for i = 1 to Difficulty do
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: DOUBLE
12441: LD_INT 1
12443: DEC
12444: ST_TO_ADDR
12445: LD_OWVAR 67
12449: PUSH
12450: FOR_TO
12451: IFFALSE 12609
// begin InitHc ;
12453: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12457: LD_INT 0
12459: PPUSH
12460: LD_INT 8
12462: PPUSH
12463: CALL_OW 381
// un := CreateHuman ;
12467: LD_ADDR_VAR 0 2
12471: PUSH
12472: CALL_OW 44
12476: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 258
12484: PPUSH
12485: LD_INT 267
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: LD_INT 0
12493: PPUSH
12494: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12498: LD_ADDR_EXP 91
12502: PUSH
12503: LD_EXP 91
12507: PUSH
12508: LD_VAR 0 2
12512: UNION
12513: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12514: LD_VAR 0 2
12518: PPUSH
12519: LD_VAR 0 3
12523: PUSH
12524: LD_VAR 0 1
12528: ARRAY
12529: PUSH
12530: LD_INT 1
12532: ARRAY
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 2
12547: ARRAY
12548: PPUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 1
12554: PPUSH
12555: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_VAR 0 1
12573: ARRAY
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 2
12592: ARRAY
12593: PPUSH
12594: CALL_OW 171
// AddComInvisible ( un ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 212
// end ;
12607: GO 12450
12609: POP
12610: POP
// repeat wait ( 0 0$20 ) ;
12611: LD_INT 700
12613: PPUSH
12614: CALL_OW 67
// for i in allianceSpecialForce do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_EXP 91
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12864
// begin if IsInvisible ( i ) then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 571
12640: IFFALSE 12833
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 50
12659: PUSH
12660: EMPTY
12661: LIST
12662: PUSH
12663: LD_INT 56
12665: PUSH
12666: EMPTY
12667: LIST
12668: PUSH
12669: LD_INT 91
12671: PUSH
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 25
12679: PUSH
12680: LD_INT 30
12682: PUSH
12683: LD_INT 35
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: PUSH
12691: LD_OWVAR 67
12695: ARRAY
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: LIST
12701: PUSH
12702: LD_INT 2
12704: PUSH
12705: LD_INT 25
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 25
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 5
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 8
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PPUSH
12781: CALL_OW 69
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 3
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12628
// if Prob ( 30 * Difficulty ) then
12795: LD_INT 30
12797: PUSH
12798: LD_OWVAR 67
12802: MUL
12803: PPUSH
12804: CALL_OW 13
12808: IFFALSE 12833
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12810: LD_VAR 0 3
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_VAR 0 3
12822: PPUSH
12823: CALL_OW 12
12827: ARRAY
12828: PPUSH
12829: CALL 31022 0 1
// end ; if IsDead ( i ) then
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 301
12842: IFFALSE 12862
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12844: LD_ADDR_EXP 91
12848: PUSH
12849: LD_EXP 91
12853: PUSH
12854: LD_VAR 0 1
12858: DIFF
12859: ST_TO_ADDR
// continue ;
12860: GO 12628
// end ; end ;
12862: GO 12628
12864: POP
12865: POP
// until allianceDestroyed or not allianceSpecialForce ;
12866: LD_EXP 23
12870: PUSH
12871: LD_EXP 91
12875: NOT
12876: OR
12877: IFFALSE 12611
// end ;
12879: PPOPN 3
12881: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12882: LD_EXP 23
12886: NOT
12887: PUSH
12888: LD_EXP 31
12892: AND
12893: IFFALSE 13860
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
12901: PPUSH
12902: PPUSH
12903: PPUSH
// begin enable ;
12904: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12905: LD_INT 22
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 30
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: NOT
12934: IFFALSE 12938
// exit ;
12936: GO 13860
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12938: LD_ADDR_VAR 0 4
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 30
12955: PUSH
12956: LD_INT 34
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// if Prob ( 40 ) then
12972: LD_INT 40
12974: PPUSH
12975: CALL_OW 13
12979: IFFALSE 13106
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12981: LD_INT 1
12983: PPUSH
12984: LD_INT 5
12986: PUSH
12987: LD_INT 3
12989: PUSH
12990: LD_INT 2
12992: PUSH
12993: LD_INT 6
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 5
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: LD_INT 6
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 5
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 2
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 24
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 45
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 24
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 47
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL 58572 0 2
// end else
13104: GO 13229
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13106: LD_INT 1
13108: PPUSH
13109: LD_INT 24
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 47
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 47
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 5
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 2
13153: PUSH
13154: LD_INT 9
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 5
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: LD_INT 2
13171: PUSH
13172: LD_INT 9
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: PUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 45
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 24
13201: PUSH
13202: LD_INT 1
13204: PUSH
13205: LD_INT 3
13207: PUSH
13208: LD_INT 45
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL 58572 0 2
// end ; if Difficulty > 1 then
13229: LD_OWVAR 67
13233: PUSH
13234: LD_INT 1
13236: GREATER
13237: IFFALSE 13267
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 24
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 3
13250: PUSH
13251: LD_INT 47
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: PPUSH
13263: CALL 58572 0 2
// repeat wait ( 0 0$1 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL 59990 0 2
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 7
13290: PUSH
13291: LD_INT 7
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: GREATEREQUAL
13305: IFFALSE 13267
// wait ( 0 0$40 ) ;
13307: LD_INT 1400
13309: PPUSH
13310: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13314: LD_ADDR_VAR 0 2
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 1
13324: PPUSH
13325: CALL 59990 0 2
13329: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13330: LD_ADDR_EXP 121
13334: PUSH
13335: LD_EXP 121
13339: PPUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_EXP 121
13347: PUSH
13348: LD_INT 1
13350: ARRAY
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: PPUSH
13358: CALL_OW 1
13362: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: CALL_OW 12
13378: ST_TO_ADDR
// if target then
13379: LD_VAR 0 3
13383: IFFALSE 13549
// begin for i in tmp do
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: FOR_IN
13396: IFFALSE 13421
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_INT 179
13405: PPUSH
13406: LD_INT 209
13408: PPUSH
13409: LD_INT 8
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 483
13419: GO 13395
13421: POP
13422: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_VAR 0 2
13432: PPUSH
13433: LD_INT 24
13435: PUSH
13436: LD_INT 250
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: ST_TO_ADDR
// for i in tmp do
13448: LD_ADDR_VAR 0 1
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: FOR_IN
13459: IFFALSE 13499
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13461: LD_VAR 0 1
13465: PPUSH
13466: LD_INT 179
13468: PPUSH
13469: LD_INT 209
13471: PPUSH
13472: CALL_OW 297
13476: PUSH
13477: LD_INT 9
13479: GREATER
13480: IFFALSE 13497
// ComMoveXY ( i , 179 , 209 ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_INT 179
13489: PPUSH
13490: LD_INT 209
13492: PPUSH
13493: CALL_OW 111
13497: GO 13458
13499: POP
13500: POP
// wait ( 0 0$1 ) ;
13501: LD_INT 35
13503: PPUSH
13504: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_INT 92
13515: PUSH
13516: LD_INT 179
13518: PUSH
13519: LD_INT 209
13521: PUSH
13522: LD_INT 9
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 1
13543: MINUS
13544: GREATEREQUAL
13545: IFFALSE 13423
// end else
13547: GO 13711
// begin for i in tmp do
13549: LD_ADDR_VAR 0 1
13553: PUSH
13554: LD_VAR 0 2
13558: PUSH
13559: FOR_IN
13560: IFFALSE 13585
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13562: LD_VAR 0 1
13566: PPUSH
13567: LD_INT 285
13569: PPUSH
13570: LD_INT 163
13572: PPUSH
13573: LD_INT 8
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 483
13583: GO 13559
13585: POP
13586: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_INT 24
13599: PUSH
13600: LD_INT 250
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 72
13611: ST_TO_ADDR
// for i in tmp do
13612: LD_ADDR_VAR 0 1
13616: PUSH
13617: LD_VAR 0 2
13621: PUSH
13622: FOR_IN
13623: IFFALSE 13663
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13625: LD_VAR 0 1
13629: PPUSH
13630: LD_INT 285
13632: PPUSH
13633: LD_INT 163
13635: PPUSH
13636: CALL_OW 297
13640: PUSH
13641: LD_INT 9
13643: GREATER
13644: IFFALSE 13661
// ComMoveXY ( i , 285 , 163 ) ;
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 285
13653: PPUSH
13654: LD_INT 163
13656: PPUSH
13657: CALL_OW 111
13661: GO 13622
13663: POP
13664: POP
// wait ( 0 0$1 ) ;
13665: LD_INT 35
13667: PPUSH
13668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13672: LD_VAR 0 2
13676: PPUSH
13677: LD_INT 92
13679: PUSH
13680: LD_INT 285
13682: PUSH
13683: LD_INT 163
13685: PUSH
13686: LD_INT 9
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 72
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: MINUS
13708: GREATEREQUAL
13709: IFFALSE 13587
// end ; repeat wait ( 0 0$1 ) ;
13711: LD_INT 35
13713: PPUSH
13714: CALL_OW 67
// for i in tmp do
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: FOR_IN
13729: IFFALSE 13851
// if GetLives ( i ) > 251 then
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 256
13740: PUSH
13741: LD_INT 251
13743: GREATER
13744: IFFALSE 13833
// begin if GetWeapon ( i ) = ru_time_lapser then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 264
13755: PUSH
13756: LD_INT 49
13758: EQUAL
13759: IFFALSE 13797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13761: LD_VAR 0 1
13765: PPUSH
13766: LD_INT 81
13768: PUSH
13769: LD_INT 7
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: CALL_OW 74
13790: PPUSH
13791: CALL_OW 112
13795: GO 13831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 81
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PPUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: CALL_OW 74
13826: PPUSH
13827: CALL_OW 115
// end else
13831: GO 13849
// tmp := tmp diff i ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: DIFF
13848: ST_TO_ADDR
13849: GO 13728
13851: POP
13852: POP
// until not tmp ;
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13711
// end ; end_of_file
13860: PPOPN 4
13862: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// missionStage := 13 ;
13869: LD_ADDR_EXP 15
13873: PUSH
13874: LD_INT 13
13876: ST_TO_ADDR
// uc_side := 2 ;
13877: LD_ADDR_OWVAR 20
13881: PUSH
13882: LD_INT 2
13884: ST_TO_ADDR
// uc_nation := 2 ;
13885: LD_ADDR_OWVAR 21
13889: PUSH
13890: LD_INT 2
13892: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13893: LD_ADDR_EXP 92
13897: PUSH
13898: LD_STRING Omar
13900: PPUSH
13901: CALL_OW 25
13905: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13906: LD_EXP 92
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13918: LD_EXP 92
13922: PPUSH
13923: LD_INT 242
13925: PPUSH
13926: LD_INT 75
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13936: LD_ADDR_EXP 93
13940: PUSH
13941: LD_STRING Heike
13943: PPUSH
13944: CALL_OW 25
13948: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13949: LD_INT 14
13951: PPUSH
13952: LD_INT 3
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: LD_INT 27
13960: PPUSH
13961: LD_INT 100
13963: PPUSH
13964: CALL 72091 0 5
// veh := CreateVehicle ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: CALL_OW 45
13977: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13978: LD_VAR 0 3
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 242
// SetDir ( veh , 4 ) ;
13990: LD_VAR 0 3
13994: PPUSH
13995: LD_INT 4
13997: PPUSH
13998: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 241
14009: PPUSH
14010: LD_INT 72
14012: PPUSH
14013: LD_INT 0
14015: PPUSH
14016: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14020: LD_EXP 93
14024: PPUSH
14025: LD_VAR 0 3
14029: PPUSH
14030: CALL_OW 52
// if KhatamStatus then
14034: LD_EXP 8
14038: IFFALSE 14089
// begin Khatam := NewCharacter ( Khatam ) ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_STRING Khatam
14047: PPUSH
14048: CALL_OW 25
14052: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14053: LD_EXP 94
14057: PPUSH
14058: LD_INT 245
14060: PPUSH
14061: LD_INT 78
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 0
14069: PPUSH
14070: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14074: LD_EXP 94
14078: PPUSH
14079: LD_INT 4
14081: PPUSH
14082: LD_INT 10
14084: PPUSH
14085: CALL_OW 237
// end ; for i = 1 to Difficulty do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_OWVAR 67
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14171
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14107: LD_INT 0
14109: PPUSH
14110: LD_INT 7
14112: PUSH
14113: LD_OWVAR 67
14117: PLUS
14118: PPUSH
14119: CALL_OW 384
// un := CreateHuman ;
14123: LD_ADDR_VAR 0 4
14127: PUSH
14128: CALL_OW 44
14132: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14133: LD_VAR 0 4
14137: PPUSH
14138: LD_INT 28
14140: PUSH
14141: LD_INT 29
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: MOD
14156: PUSH
14157: LD_INT 1
14159: PLUS
14160: ARRAY
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// end ;
14169: GO 14104
14171: POP
14172: POP
// for i = 1 to 6 do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_INT 6
14185: PUSH
14186: FOR_TO
14187: IFFALSE 14232
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14189: LD_INT 0
14191: PPUSH
14192: LD_INT 7
14194: PUSH
14195: LD_OWVAR 67
14199: PLUS
14200: PPUSH
14201: CALL_OW 381
// un := CreateHuman ;
14205: LD_ADDR_VAR 0 4
14209: PUSH
14210: CALL_OW 44
14214: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14215: LD_VAR 0 4
14219: PPUSH
14220: LD_INT 28
14222: PPUSH
14223: LD_INT 0
14225: PPUSH
14226: CALL_OW 49
// end ;
14230: GO 14186
14232: POP
14233: POP
// for i = 1 to 3 do
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: DOUBLE
14240: LD_INT 1
14242: DEC
14243: ST_TO_ADDR
14244: LD_INT 3
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14296
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14250: LD_INT 0
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: LD_INT 7
14258: PUSH
14259: LD_OWVAR 67
14263: PLUS
14264: PPUSH
14265: CALL_OW 380
// un := CreateHuman ;
14269: LD_ADDR_VAR 0 4
14273: PUSH
14274: CALL_OW 44
14278: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14279: LD_VAR 0 4
14283: PPUSH
14284: LD_INT 28
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 49
// end ;
14294: GO 14247
14296: POP
14297: POP
// for i = 1 to 3 do
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: DOUBLE
14304: LD_INT 1
14306: DEC
14307: ST_TO_ADDR
14308: LD_INT 3
14310: PUSH
14311: FOR_TO
14312: IFFALSE 14402
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14314: LD_INT 14
14316: PPUSH
14317: LD_INT 2
14319: PPUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 28
14325: PPUSH
14326: LD_INT 80
14328: PPUSH
14329: CALL 72091 0 5
// veh := CreateVehicle ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: CALL_OW 45
14342: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14343: LD_VAR 0 3
14347: PPUSH
14348: LD_INT 3
14350: PPUSH
14351: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14355: LD_VAR 0 3
14359: PPUSH
14360: LD_INT 29
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 7
14375: PUSH
14376: LD_OWVAR 67
14380: PLUS
14381: PPUSH
14382: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14386: CALL_OW 44
14390: PPUSH
14391: LD_VAR 0 3
14395: PPUSH
14396: CALL_OW 52
// end ;
14400: GO 14311
14402: POP
14403: POP
// for i = 1 to 5 + Difficulty do
14404: LD_ADDR_VAR 0 2
14408: PUSH
14409: DOUBLE
14410: LD_INT 1
14412: DEC
14413: ST_TO_ADDR
14414: LD_INT 5
14416: PUSH
14417: LD_OWVAR 67
14421: PLUS
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14551
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: CALL_OW 12
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PUSH
14446: LD_INT 26
14448: PUSH
14449: LD_INT 27
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_VAR 0 2
14465: PUSH
14466: LD_INT 4
14468: MOD
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ARRAY
14474: PPUSH
14475: LD_INT 80
14477: PPUSH
14478: CALL 72091 0 5
// veh := CreateVehicle ;
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: CALL_OW 45
14491: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_INT 4
14499: PPUSH
14500: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14504: LD_VAR 0 3
14508: PPUSH
14509: LD_INT 28
14511: PPUSH
14512: LD_INT 0
14514: PPUSH
14515: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14519: LD_INT 0
14521: PPUSH
14522: LD_INT 7
14524: PUSH
14525: LD_OWVAR 67
14529: PLUS
14530: PPUSH
14531: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14535: CALL_OW 44
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: CALL_OW 52
// end ;
14549: GO 14423
14551: POP
14552: POP
// for i = 1 to 3 do
14553: LD_ADDR_VAR 0 2
14557: PUSH
14558: DOUBLE
14559: LD_INT 1
14561: DEC
14562: ST_TO_ADDR
14563: LD_INT 3
14565: PUSH
14566: FOR_TO
14567: IFFALSE 14627
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14569: LD_INT 14
14571: PPUSH
14572: LD_INT 3
14574: PPUSH
14575: LD_INT 5
14577: PPUSH
14578: LD_INT 29
14580: PPUSH
14581: LD_INT 80
14583: PPUSH
14584: CALL 72091 0 5
// veh := CreateVehicle ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: CALL_OW 45
14597: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 4
14605: PPUSH
14606: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 28
14617: PPUSH
14618: LD_INT 0
14620: PPUSH
14621: CALL_OW 49
// end ;
14625: GO 14566
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 1
14633: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14634: LD_INT 22
14636: PUSH
14637: LD_INT 2
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: IFFALSE 14948
14650: GO 14652
14652: DISABLE
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 22
14665: PUSH
14666: LD_INT 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 4
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_EXP 94
14696: DIFF
14697: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PPUSH
14713: CALL_OW 69
14717: PUSH
14718: LD_EXP 94
14722: PUSH
14723: LD_VAR 0 3
14727: UNION
14728: DIFF
14729: ST_TO_ADDR
// if Khatam then
14730: LD_EXP 94
14734: IFFALSE 14751
// ComMoveXY ( Khatam , 211 , 92 ) ;
14736: LD_EXP 94
14740: PPUSH
14741: LD_INT 211
14743: PPUSH
14744: LD_INT 92
14746: PPUSH
14747: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14751: LD_INT 197
14753: PPUSH
14754: LD_INT 80
14756: PPUSH
14757: LD_INT 2
14759: PPUSH
14760: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14764: LD_INT 213
14766: PPUSH
14767: LD_INT 90
14769: PPUSH
14770: LD_INT 2
14772: PPUSH
14773: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 441
// if sci then
14790: LD_VAR 0 3
14794: IFFALSE 14815
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 1
14803: ARRAY
14804: PPUSH
14805: LD_INT 197
14807: PPUSH
14808: LD_INT 80
14810: PPUSH
14811: CALL_OW 158
// if sci > 1 then
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: GREATER
14823: IFFALSE 14844
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 2
14832: ARRAY
14833: PPUSH
14834: LD_INT 213
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 158
// if sci > 2 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: GREATER
14852: IFFALSE 14873
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14854: LD_VAR 0 3
14858: PUSH
14859: LD_INT 3
14861: ARRAY
14862: PPUSH
14863: LD_INT 215
14865: PPUSH
14866: LD_INT 129
14868: PPUSH
14869: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14873: LD_INT 35
14875: PPUSH
14876: CALL_OW 67
// for i in tmp do
14880: LD_ADDR_VAR 0 1
14884: PUSH
14885: LD_VAR 0 2
14889: PUSH
14890: FOR_IN
14891: IFFALSE 14929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: LD_INT 81
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PPUSH
14908: CALL_OW 69
14912: PPUSH
14913: LD_VAR 0 1
14917: PPUSH
14918: CALL_OW 74
14922: PPUSH
14923: CALL_OW 115
14927: GO 14890
14929: POP
14930: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14931: LD_INT 22
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: NOT
14946: IFFALSE 14873
// end ; end_of_file
14948: PPOPN 3
14950: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14951: LD_INT 0
14953: PPUSH
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
// Video ( true ) ;
14962: LD_INT 1
14964: PPUSH
14965: CALL 107818 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_INT 7
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 517
14984: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: DOUBLE
14991: LD_INT 1
14993: DEC
14994: ST_TO_ADDR
14995: LD_VAR 0 5
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PUSH
15004: FOR_TO
15005: IFFALSE 15050
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: ARRAY
15021: PPUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 2
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_INT 1
15039: PPUSH
15040: LD_INT 15
15042: NEG
15043: PPUSH
15044: CALL 107732 0 4
15048: GO 15004
15050: POP
15051: POP
// CenterNowOnUnits ( Powell ) ;
15052: LD_EXP 58
15056: PPUSH
15057: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15061: LD_ADDR_VAR 0 5
15065: PUSH
15066: LD_EXP 56
15070: PUSH
15071: EMPTY
15072: LIST
15073: ST_TO_ADDR
// if GirlNewVeh then
15074: LD_EXP 57
15078: IFFALSE 15096
// tmp := tmp ^ GirlNewVeh ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_VAR 0 5
15089: PUSH
15090: LD_EXP 57
15094: ADD
15095: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15096: LD_VAR 0 5
15100: PPUSH
15101: LD_INT 60
15103: PPUSH
15104: LD_INT 109
15106: PPUSH
15107: CALL_OW 111
// if KappaStatus then
15111: LD_EXP 2
15115: IFFALSE 15167
// begin Say ( JMM , D1nT-JMM-1 ) ;
15117: LD_EXP 39
15121: PPUSH
15122: LD_STRING D1nT-JMM-1
15124: PPUSH
15125: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15129: LD_EXP 58
15133: PPUSH
15134: LD_STRING D1T-Pow-1
15136: PPUSH
15137: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15141: LD_EXP 39
15145: PPUSH
15146: LD_STRING D1T-JMM-2
15148: PPUSH
15149: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15153: LD_EXP 58
15157: PPUSH
15158: LD_STRING D1T-Pow-2
15160: PPUSH
15161: CALL_OW 88
// end else
15165: GO 15373
// if JMMGirlStatus then
15167: LD_EXP 6
15171: IFFALSE 15316
// begin Say ( JMM , D1T-JMM-1 ) ;
15173: LD_EXP 39
15177: PPUSH
15178: LD_STRING D1T-JMM-1
15180: PPUSH
15181: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15185: LD_EXP 58
15189: PPUSH
15190: LD_STRING D1T-Pow-1
15192: PPUSH
15193: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15197: LD_EXP 39
15201: PPUSH
15202: LD_STRING D1T-JMM-3
15204: PPUSH
15205: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15209: LD_EXP 58
15213: PPUSH
15214: LD_STRING D1T-Pow-3
15216: PPUSH
15217: CALL_OW 88
// if JMMGirl then
15221: LD_EXP 7
15225: IFFALSE 15314
// begin case JMMGirl of 1 :
15227: LD_EXP 7
15231: PUSH
15232: LD_INT 1
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15255
15240: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15241: LD_EXP 40
15245: PPUSH
15246: LD_STRING D1T-Joan-3
15248: PPUSH
15249: CALL_OW 88
15253: GO 15302
15255: LD_INT 2
15257: DOUBLE
15258: EQUAL
15259: IFTRUE 15263
15261: GO 15278
15263: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15264: LD_EXP 42
15268: PPUSH
15269: LD_STRING D1T-Lisa-3
15271: PPUSH
15272: CALL_OW 88
15276: GO 15302
15278: LD_INT 3
15280: DOUBLE
15281: EQUAL
15282: IFTRUE 15286
15284: GO 15301
15286: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15287: LD_EXP 54
15291: PPUSH
15292: LD_STRING D1T-Con-3
15294: PPUSH
15295: CALL_OW 88
15299: GO 15302
15301: POP
// Say ( Powell , D1T-Pow-4 ) ;
15302: LD_EXP 58
15306: PPUSH
15307: LD_STRING D1T-Pow-4
15309: PPUSH
15310: CALL_OW 88
// end ; end else
15314: GO 15373
// if not FastEnd then
15316: LD_EXP 11
15320: NOT
15321: IFFALSE 15349
// begin Say ( JMM , D1T-JMM-4 ) ;
15323: LD_EXP 39
15327: PPUSH
15328: LD_STRING D1T-JMM-4
15330: PPUSH
15331: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15335: LD_EXP 58
15339: PPUSH
15340: LD_STRING D1T-Pow-5
15342: PPUSH
15343: CALL_OW 88
// end else
15347: GO 15373
// begin Say ( JMM , D1nT-JMM-1 ) ;
15349: LD_EXP 39
15353: PPUSH
15354: LD_STRING D1nT-JMM-1
15356: PPUSH
15357: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15361: LD_EXP 58
15365: PPUSH
15366: LD_STRING D1nT-Pow-1
15368: PPUSH
15369: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15373: LD_INT 35
15375: PPUSH
15376: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15380: LD_EXP 56
15384: PPUSH
15385: CALL_OW 314
15389: NOT
15390: IFFALSE 15373
// ComExitVehicle ( JMM ) ;
15392: LD_EXP 39
15396: PPUSH
15397: CALL_OW 121
// wait ( 3 ) ;
15401: LD_INT 3
15403: PPUSH
15404: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15408: LD_EXP 39
15412: PPUSH
15413: LD_INT 60
15415: PPUSH
15416: LD_INT 94
15418: PPUSH
15419: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_EXP 58
15432: PPUSH
15433: CALL_OW 179
// if Joan then
15437: LD_EXP 40
15441: IFFALSE 15495
// begin ComExitVehicle ( Joan ) ;
15443: LD_EXP 40
15447: PPUSH
15448: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15452: LD_EXP 40
15456: PPUSH
15457: LD_INT 35
15459: PPUSH
15460: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15464: LD_EXP 40
15468: PPUSH
15469: LD_INT 65
15471: PPUSH
15472: LD_INT 104
15474: PPUSH
15475: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_EXP 39
15488: PPUSH
15489: CALL_OW 179
// end else
15493: GO 15629
// if Lisa and JMMGirl = 2 then
15495: LD_EXP 42
15499: PUSH
15500: LD_EXP 7
15504: PUSH
15505: LD_INT 2
15507: EQUAL
15508: AND
15509: IFFALSE 15563
// begin ComExitVehicle ( Lisa ) ;
15511: LD_EXP 42
15515: PPUSH
15516: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15520: LD_EXP 42
15524: PPUSH
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15532: LD_EXP 42
15536: PPUSH
15537: LD_INT 65
15539: PPUSH
15540: LD_INT 104
15542: PPUSH
15543: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_EXP 39
15556: PPUSH
15557: CALL_OW 179
// end else
15561: GO 15629
// if Connie and JMMGirl = 3 then
15563: LD_EXP 54
15567: PUSH
15568: LD_EXP 7
15572: PUSH
15573: LD_INT 3
15575: EQUAL
15576: AND
15577: IFFALSE 15629
// begin ComExitVehicle ( Connie ) ;
15579: LD_EXP 54
15583: PPUSH
15584: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15588: LD_EXP 54
15592: PPUSH
15593: LD_INT 35
15595: PPUSH
15596: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15600: LD_EXP 54
15604: PPUSH
15605: LD_INT 65
15607: PPUSH
15608: LD_INT 104
15610: PPUSH
15611: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_EXP 39
15624: PPUSH
15625: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15636: LD_EXP 39
15640: PPUSH
15641: LD_EXP 58
15645: PPUSH
15646: CALL_OW 296
15650: PUSH
15651: LD_INT 6
15653: LESS
15654: IFFALSE 15629
// wait ( 0 0$0.5 ) ;
15656: LD_INT 18
15658: PPUSH
15659: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15663: LD_EXP 39
15667: PPUSH
15668: LD_STRING D1-JMM-1
15670: PPUSH
15671: CALL_OW 88
// async ;
15675: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15676: LD_EXP 58
15680: PPUSH
15681: LD_STRING D1-Pow-1
15683: PPUSH
15684: CALL_OW 88
// if not dialogue_skipped then
15688: LD_OWVAR 59
15692: NOT
15693: IFFALSE 15702
// wait ( 0 0$2 ) ;
15695: LD_INT 70
15697: PPUSH
15698: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15702: LD_INT 170
15704: PPUSH
15705: LD_INT 99
15707: PPUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_INT 6
15713: NEG
15714: PPUSH
15715: CALL 107732 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15719: LD_INT 174
15721: PPUSH
15722: LD_INT 115
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_INT 6
15730: NEG
15731: PPUSH
15732: CALL 107732 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15736: LD_INT 169
15738: PPUSH
15739: LD_INT 71
15741: PPUSH
15742: LD_INT 1
15744: PPUSH
15745: LD_INT 6
15747: NEG
15748: PPUSH
15749: CALL 107732 0 4
// if not dialogue_skipped then
15753: LD_OWVAR 59
15757: NOT
15758: IFFALSE 15777
// begin CenterOnXY ( 170 , 99 ) ;
15760: LD_INT 170
15762: PPUSH
15763: LD_INT 99
15765: PPUSH
15766: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15770: LD_INT 80
15772: PPUSH
15773: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15777: LD_INT 75
15779: PPUSH
15780: LD_INT 53
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: LD_INT 9
15788: NEG
15789: PPUSH
15790: CALL 107732 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15794: LD_INT 54
15796: PPUSH
15797: LD_INT 42
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: LD_INT 9
15805: NEG
15806: PPUSH
15807: CALL 107732 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15811: LD_INT 62
15813: PPUSH
15814: LD_INT 51
15816: PPUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 9
15822: NEG
15823: PPUSH
15824: CALL 107732 0 4
// if not dialogue_skipped then
15828: LD_OWVAR 59
15832: NOT
15833: IFFALSE 15852
// begin CenterOnXY ( 75 , 53 ) ;
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 53
15840: PPUSH
15841: CALL_OW 84
// wait ( 0 0$4 ) ;
15845: LD_INT 140
15847: PPUSH
15848: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15852: LD_EXP 58
15856: PPUSH
15857: CALL_OW 87
// if not dialogue_skipped then
15861: LD_OWVAR 59
15865: NOT
15866: IFFALSE 15875
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// sync ;
15875: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15876: LD_EXP 39
15880: PPUSH
15881: LD_STRING D1-JMM-2
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15888: LD_EXP 58
15892: PPUSH
15893: LD_STRING D1-Pow-2
15895: PPUSH
15896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15900: LD_EXP 39
15904: PPUSH
15905: LD_STRING D1-JMM-3
15907: PPUSH
15908: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15912: LD_EXP 58
15916: PPUSH
15917: LD_STRING D1-Pow-3
15919: PPUSH
15920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15924: LD_EXP 39
15928: PPUSH
15929: LD_STRING D1-JMM-4
15931: PPUSH
15932: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15936: LD_EXP 58
15940: PPUSH
15941: LD_STRING D1-Pow-4
15943: PPUSH
15944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15948: LD_EXP 39
15952: PPUSH
15953: LD_STRING D1-JMM-5
15955: PPUSH
15956: CALL_OW 88
// async ;
15960: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15961: LD_EXP 58
15965: PPUSH
15966: LD_STRING D1-Pow-5
15968: PPUSH
15969: CALL_OW 88
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$3.6 ) ;
15980: LD_INT 126
15982: PPUSH
15983: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15987: LD_INT 134
15989: PPUSH
15990: LD_INT 210
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_INT 11
15998: NEG
15999: PPUSH
16000: CALL 107732 0 4
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16028
// begin CenterOnXY ( 134 , 210 ) ;
16011: LD_INT 134
16013: PPUSH
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 84
// wait ( 0 0$2 ) ;
16021: LD_INT 70
16023: PPUSH
16024: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16028: LD_INT 101
16030: PPUSH
16031: LD_INT 159
16033: PPUSH
16034: LD_INT 1
16036: PPUSH
16037: LD_INT 10
16039: NEG
16040: PPUSH
16041: CALL 107732 0 4
// if not dialogue_skipped then
16045: LD_OWVAR 59
16049: NOT
16050: IFFALSE 16069
// begin CenterOnXY ( 101 , 159 ) ;
16052: LD_INT 101
16054: PPUSH
16055: LD_INT 159
16057: PPUSH
16058: CALL_OW 84
// wait ( 0 0$2 ) ;
16062: LD_INT 70
16064: PPUSH
16065: CALL_OW 67
// end ; sync ;
16069: SYNC
// CenterNowOnUnits ( Powell ) ;
16070: LD_EXP 58
16074: PPUSH
16075: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: LD_INT 2
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: LD_INT 4
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if not dialogue_skipped then
16110: LD_OWVAR 59
16114: NOT
16115: IFFALSE 16284
// begin game_speed := 4 ;
16117: LD_ADDR_OWVAR 65
16121: PUSH
16122: LD_INT 4
16124: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16125: LD_INT 210
16127: PPUSH
16128: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1
16139: PPUSH
16140: LD_VAR 0 6
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_STRING Q1
16157: PPUSH
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 98
16167: ST_TO_ADDR
// options = options diff dec ;
16168: LD_ADDR_VAR 0 6
16172: PUSH
16173: LD_VAR 0 6
16177: PUSH
16178: LD_VAR 0 7
16182: DIFF
16183: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16184: LD_VAR 0 7
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17756 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16198: LD_VAR 0 7
16202: PUSH
16203: LD_INT 5
16205: PUSH
16206: LD_INT 6
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: IN
16213: PUSH
16214: LD_VAR 0 6
16218: PUSH
16219: LD_INT 2
16221: EQUAL
16222: OR
16223: IFFALSE 16150
// if not ( dec in [ 5 , 6 ] ) then
16225: LD_VAR 0 7
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 6
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: IN
16240: NOT
16241: IFFALSE 16284
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_STRING Q1a
16250: PPUSH
16251: LD_INT 1
16253: PUSH
16254: LD_INT 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PPUSH
16261: CALL_OW 98
16265: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16266: LD_VAR 0 7
16270: PUSH
16271: LD_INT 4
16273: PLUS
16274: PPUSH
16275: LD_VAR 0 6
16279: PPUSH
16280: CALL 17756 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16284: LD_INT 81
16286: PPUSH
16287: LD_INT 127
16289: PPUSH
16290: CALL_OW 84
// amount := 5 ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_INT 5
16301: ST_TO_ADDR
// macmilan_squad := [ ] ;
16302: LD_ADDR_VAR 0 9
16306: PUSH
16307: EMPTY
16308: ST_TO_ADDR
// if vip < amount then
16309: LD_EXP 59
16313: PUSH
16314: LD_VAR 0 8
16318: LESS
16319: IFFALSE 16363
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16321: LD_ADDR_VAR 0 5
16325: PUSH
16326: LD_EXP 59
16330: PUSH
16331: LD_INT 22
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: LD_INT 21
16343: PUSH
16344: LD_INT 1
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 69
16359: UNION
16360: ST_TO_ADDR
16361: GO 16373
// tmp := vip ;
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: LD_EXP 59
16372: ST_TO_ADDR
// tmp := tmp diff Powell ;
16373: LD_ADDR_VAR 0 5
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: LD_EXP 58
16387: DIFF
16388: ST_TO_ADDR
// if tmp < amount then
16389: LD_VAR 0 5
16393: PUSH
16394: LD_VAR 0 8
16398: LESS
16399: IFFALSE 16411
// amount := tmp ;
16401: LD_ADDR_VAR 0 8
16405: PUSH
16406: LD_VAR 0 5
16410: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16411: LD_VAR 0 5
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: PPUSH
16420: CALL_OW 257
16424: PUSH
16425: LD_INT 2
16427: NONEQUAL
16428: IFFALSE 16490
// begin if IsInUnit ( tmp [ 1 ] ) then
16430: LD_VAR 0 5
16434: PUSH
16435: LD_INT 1
16437: ARRAY
16438: PPUSH
16439: CALL_OW 310
16443: IFFALSE 16458
// ComExitBuilding ( tmp [ 1 ] ) ;
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: PPUSH
16467: LD_INT 387
16469: PPUSH
16470: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_INT 1
16481: ARRAY
16482: PPUSH
16483: LD_INT 2
16485: PPUSH
16486: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16490: LD_EXP 39
16494: PPUSH
16495: LD_INT 82
16497: PPUSH
16498: LD_INT 129
16500: PPUSH
16501: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_EXP 58
16514: PPUSH
16515: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16519: LD_INT 22
16521: PUSH
16522: LD_INT 1
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 39
16538: DIFF
16539: PPUSH
16540: LD_INT 84
16542: PPUSH
16543: LD_INT 128
16545: PPUSH
16546: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16550: LD_INT 22
16552: PUSH
16553: LD_INT 1
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_EXP 39
16569: DIFF
16570: PPUSH
16571: LD_EXP 39
16575: PPUSH
16576: CALL_OW 179
// for i = 1 to amount do
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: DOUBLE
16586: LD_INT 1
16588: DEC
16589: ST_TO_ADDR
16590: LD_VAR 0 8
16594: PUSH
16595: FOR_TO
16596: IFFALSE 16764
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16598: LD_ADDR_VAR 0 9
16602: PUSH
16603: LD_VAR 0 9
16607: PUSH
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: ADD
16619: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16620: LD_VAR 0 5
16624: PUSH
16625: LD_VAR 0 2
16629: ARRAY
16630: PPUSH
16631: CALL_OW 310
16635: IFFALSE 16652
// AddComExitBuilding ( tmp [ i ] ) ;
16637: LD_VAR 0 5
16641: PUSH
16642: LD_VAR 0 2
16646: ARRAY
16647: PPUSH
16648: CALL_OW 182
// if i = 2 and JMMNewVeh then
16652: LD_VAR 0 2
16656: PUSH
16657: LD_INT 2
16659: EQUAL
16660: PUSH
16661: LD_EXP 56
16665: AND
16666: IFFALSE 16724
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16668: LD_VAR 0 5
16672: PUSH
16673: LD_VAR 0 2
16677: ARRAY
16678: PPUSH
16679: LD_EXP 56
16683: PPUSH
16684: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16688: LD_VAR 0 5
16692: PUSH
16693: LD_VAR 0 2
16697: ARRAY
16698: PPUSH
16699: LD_INT 86
16701: PPUSH
16702: LD_INT 133
16704: PPUSH
16705: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16709: LD_VAR 0 5
16713: PUSH
16714: LD_VAR 0 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: LD_INT 8
16737: PPUSH
16738: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16742: LD_VAR 0 5
16746: PUSH
16747: LD_VAR 0 2
16751: ARRAY
16752: PPUSH
16753: LD_EXP 39
16757: PPUSH
16758: CALL_OW 179
// end ;
16762: GO 16595
16764: POP
16765: POP
// if GirlNewVeh then
16766: LD_EXP 57
16770: IFFALSE 16784
// SetSide ( GirlNewVeh , 4 ) ;
16772: LD_EXP 57
16776: PPUSH
16777: LD_INT 4
16779: PPUSH
16780: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16784: LD_INT 35
16786: PPUSH
16787: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16791: LD_VAR 0 9
16795: PPUSH
16796: LD_INT 95
16798: PUSH
16799: LD_INT 9
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: PUSH
16811: LD_INT 0
16813: EQUAL
16814: PUSH
16815: LD_EXP 39
16819: PPUSH
16820: LD_INT 9
16822: PPUSH
16823: CALL_OW 308
16827: NOT
16828: AND
16829: IFFALSE 16784
// wait ( 0 0$2 ) ;
16831: LD_INT 70
16833: PPUSH
16834: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16838: LD_VAR 0 9
16842: PPUSH
16843: LD_INT 1
16845: PPUSH
16846: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16850: LD_INT 21
16852: PUSH
16853: LD_INT 2
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 92
16862: PUSH
16863: LD_INT 83
16865: PUSH
16866: LD_INT 130
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PPUSH
16882: CALL_OW 69
16886: PPUSH
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 235
// Video ( false ) ;
16894: LD_INT 0
16896: PPUSH
16897: CALL 107818 0 1
// ChangeMissionObjectives ( M1 ) ;
16901: LD_STRING M1
16903: PPUSH
16904: CALL_OW 337
// SaveForQuickRestart ;
16908: CALL_OW 22
// missionStart := true ;
16912: LD_ADDR_EXP 13
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// missionStage := 2 ;
16920: LD_ADDR_EXP 15
16924: PUSH
16925: LD_INT 2
16927: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16928: LD_INT 105
16930: PPUSH
16931: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16935: LD_ADDR_VAR 0 5
16939: PUSH
16940: LD_INT 22
16942: PUSH
16943: LD_INT 4
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: LD_INT 21
16952: PUSH
16953: LD_INT 1
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 58
16973: DIFF
16974: ST_TO_ADDR
// if not tmp then
16975: LD_VAR 0 5
16979: NOT
16980: IFFALSE 16995
// tmp := [ Powell ] ;
16982: LD_ADDR_VAR 0 5
16986: PUSH
16987: LD_EXP 58
16991: PUSH
16992: EMPTY
16993: LIST
16994: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16995: LD_ADDR_EXP 102
16999: PUSH
17000: LD_EXP 102
17004: PPUSH
17005: LD_INT 4
17007: PPUSH
17008: LD_INT 22
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: LD_INT 21
17033: PUSH
17034: LD_INT 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PPUSH
17050: CALL_OW 69
17054: PUSH
17055: LD_EXP 58
17059: DIFF
17060: PPUSH
17061: CALL_OW 1
17065: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17066: LD_ADDR_VAR 0 4
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 34
17083: PUSH
17084: LD_INT 12
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17104: LD_VAR 0 5
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PPUSH
17113: CALL_OW 310
17117: IFFALSE 17132
// ComExitBuilding ( tmp [ 1 ] ) ;
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17132: LD_VAR 0 5
17136: PUSH
17137: LD_INT 1
17139: ARRAY
17140: PPUSH
17141: LD_VAR 0 4
17145: PPUSH
17146: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17150: LD_VAR 0 5
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_INT 80
17161: PPUSH
17162: LD_INT 136
17164: PPUSH
17165: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17169: LD_VAR 0 5
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PPUSH
17178: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17182: LD_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_INT 59
17193: PPUSH
17194: LD_INT 112
17196: PPUSH
17197: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17201: LD_VAR 0 5
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17214: LD_EXP 40
17218: PUSH
17219: LD_EXP 40
17223: PPUSH
17224: CALL_OW 255
17228: PUSH
17229: LD_INT 1
17231: EQUAL
17232: AND
17233: IFFALSE 17259
// begin Say ( Joan , D3W-Joan-1 ) ;
17235: LD_EXP 40
17239: PPUSH
17240: LD_STRING D3W-Joan-1
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17247: LD_EXP 39
17251: PPUSH
17252: LD_STRING D3W-JMM-1
17254: PPUSH
17255: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17259: LD_EXP 42
17263: PUSH
17264: LD_EXP 42
17268: PPUSH
17269: CALL_OW 255
17273: PUSH
17274: LD_INT 1
17276: EQUAL
17277: AND
17278: PUSH
17279: LD_EXP 42
17283: PUSH
17284: LD_EXP 59
17288: IN
17289: NOT
17290: AND
17291: IFFALSE 17317
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17293: LD_EXP 42
17297: PPUSH
17298: LD_STRING D3W-Lisa-1
17300: PPUSH
17301: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17305: LD_EXP 39
17309: PPUSH
17310: LD_STRING D3W-JMM-1
17312: PPUSH
17313: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17317: LD_EXP 54
17321: PUSH
17322: LD_EXP 54
17326: PPUSH
17327: CALL_OW 255
17331: PUSH
17332: LD_INT 1
17334: EQUAL
17335: AND
17336: IFFALSE 17362
// begin Say ( Connie , D3W-Con-1 ) ;
17338: LD_EXP 54
17342: PPUSH
17343: LD_STRING D3W-Con-1
17345: PPUSH
17346: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING D3W-JMM-1
17357: PPUSH
17358: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17362: LD_EXP 42
17366: PUSH
17367: LD_EXP 59
17371: IN
17372: PUSH
17373: LD_EXP 42
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Lisa , D3nW-Lisa-1 ) else
17389: LD_EXP 42
17393: PPUSH
17394: LD_STRING D3nW-Lisa-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17647
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17403: LD_EXP 45
17407: PUSH
17408: LD_EXP 59
17412: IN
17413: PUSH
17414: LD_EXP 45
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17430: LD_EXP 45
17434: PPUSH
17435: LD_STRING D3nW-Cyrus-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17647
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17444: LD_EXP 44
17448: PUSH
17449: LD_EXP 59
17453: IN
17454: PUSH
17455: LD_EXP 44
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Bobby , D3nW-Bobby-1 ) else
17471: LD_EXP 44
17475: PPUSH
17476: LD_STRING D3nW-Bobby-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17647
// if Gary in vip and GetSide ( Gary ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 59
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17526
// Say ( Gary , D3nW-Gary-1 ) else
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Gary-1
17519: PPUSH
17520: CALL_OW 88
17524: GO 17647
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17526: LD_EXP 43
17530: PUSH
17531: LD_EXP 59
17535: IN
17536: PUSH
17537: LD_EXP 43
17541: PPUSH
17542: CALL_OW 255
17546: PUSH
17547: LD_INT 1
17549: EQUAL
17550: AND
17551: IFFALSE 17567
// Say ( Donaldson , D3nW-Don-1 ) else
17553: LD_EXP 43
17557: PPUSH
17558: LD_STRING D3nW-Don-1
17560: PPUSH
17561: CALL_OW 88
17565: GO 17647
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17567: LD_EXP 50
17571: PUSH
17572: LD_EXP 59
17576: IN
17577: PUSH
17578: LD_EXP 50
17582: PPUSH
17583: CALL_OW 255
17587: PUSH
17588: LD_INT 1
17590: EQUAL
17591: AND
17592: IFFALSE 17608
// Say ( Cornel , D3nW-Corn-1 ) else
17594: LD_EXP 50
17598: PPUSH
17599: LD_STRING D3nW-Corn-1
17601: PPUSH
17602: CALL_OW 88
17606: GO 17647
// if Frank in vip and GetSide ( Frank ) = 1 then
17608: LD_EXP 52
17612: PUSH
17613: LD_EXP 59
17617: IN
17618: PUSH
17619: LD_EXP 52
17623: PPUSH
17624: CALL_OW 255
17628: PUSH
17629: LD_INT 1
17631: EQUAL
17632: AND
17633: IFFALSE 17647
// Say ( Frank , D3nW-Frank-1 ) ;
17635: LD_EXP 52
17639: PPUSH
17640: LD_STRING D3nW-Frank-1
17642: PPUSH
17643: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17647: LD_EXP 59
17651: PPUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 72
17666: IFFALSE 17692
// begin Say ( JMM , D3nW-JMM-1 ) ;
17668: LD_EXP 39
17672: PPUSH
17673: LD_STRING D3nW-JMM-1
17675: PPUSH
17676: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17680: LD_EXP 39
17684: PPUSH
17685: LD_STRING D3nW-JMM-1a
17687: PPUSH
17688: CALL_OW 88
// end ; t := 0 0$00 ;
17692: LD_ADDR_VAR 0 3
17696: PUSH
17697: LD_INT 0
17699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17700: LD_INT 35
17702: PPUSH
17703: CALL_OW 67
// t := t + 0 0$1 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 3
17716: PUSH
17717: LD_INT 35
17719: PLUS
17720: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17721: LD_INT 59
17723: PPUSH
17724: LD_INT 112
17726: PPUSH
17727: CALL_OW 428
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_INT 2100
17739: GREATER
17740: OR
17741: IFFALSE 17700
// activeAttacks := true ;
17743: LD_ADDR_EXP 16
17747: PUSH
17748: LD_INT 1
17750: ST_TO_ADDR
// end ;
17751: LD_VAR 0 1
17755: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17756: LD_INT 0
17758: PPUSH
// case question of 1 :
17759: LD_VAR 0 1
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17823
17772: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17773: LD_EXP 39
17777: PPUSH
17778: LD_STRING D2Mot-JMM-1
17780: PPUSH
17781: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17785: LD_EXP 58
17789: PPUSH
17790: LD_STRING D2Mot-Pow-1
17792: PPUSH
17793: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17797: LD_EXP 39
17801: PPUSH
17802: LD_STRING D2Mot-JMM-2
17804: PPUSH
17805: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17809: LD_EXP 58
17813: PPUSH
17814: LD_STRING D2Mot-Pow-2
17816: PPUSH
17817: CALL_OW 88
// end ; 2 :
17821: GO 18174
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17907
17831: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17832: LD_EXP 39
17836: PPUSH
17837: LD_STRING D2Rus-JMM-1
17839: PPUSH
17840: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17844: LD_EXP 58
17848: PPUSH
17849: LD_STRING D2Rus-Pow-1
17851: PPUSH
17852: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17856: LD_EXP 39
17860: PPUSH
17861: LD_STRING D2Rus-JMM-2
17863: PPUSH
17864: CALL_OW 88
// if not ( 3 in list_of_q ) then
17868: LD_INT 3
17870: PUSH
17871: LD_VAR 0 2
17875: IN
17876: NOT
17877: IFFALSE 17893
// Say ( Powell , D2Rus-Pow-2 ) else
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Rus-Pow-2
17886: PPUSH
17887: CALL_OW 88
17891: GO 17905
// Say ( Powell , D2Rus-Pow-2a ) ;
17893: LD_EXP 58
17897: PPUSH
17898: LD_STRING D2Rus-Pow-2a
17900: PPUSH
17901: CALL_OW 88
// end ; 3 :
17905: GO 18174
17907: LD_INT 3
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 18000
17915: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17916: LD_EXP 39
17920: PPUSH
17921: LD_STRING D2Leg-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17928: LD_EXP 58
17932: PPUSH
17933: LD_STRING D2Leg-Pow-1
17935: PPUSH
17936: CALL_OW 88
// if 2 in list_of_q then
17940: LD_INT 2
17942: PUSH
17943: LD_VAR 0 2
17947: IN
17948: IFFALSE 17974
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Leg-JMM-2
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Leg-Pow-2
17969: PPUSH
17970: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17974: LD_EXP 39
17978: PPUSH
17979: LD_STRING D2Leg-JMM-3
17981: PPUSH
17982: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17986: LD_EXP 58
17990: PPUSH
17991: LD_STRING D2Leg-Pow-3
17993: PPUSH
17994: CALL_OW 88
// end ; 4 :
17998: GO 18174
18000: LD_INT 4
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18083
18008: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18009: LD_EXP 39
18013: PPUSH
18014: LD_STRING D2Ar-JMM-1
18016: PPUSH
18017: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18021: LD_EXP 58
18025: PPUSH
18026: LD_STRING D2Ar-Pow-1
18028: PPUSH
18029: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18033: LD_EXP 39
18037: PPUSH
18038: LD_STRING D2Ar-JMM-2
18040: PPUSH
18041: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18045: LD_EXP 58
18049: PPUSH
18050: LD_STRING D2Ar-Pow-2
18052: PPUSH
18053: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18057: LD_EXP 39
18061: PPUSH
18062: LD_STRING D2Ar-JMM-3
18064: PPUSH
18065: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18069: LD_EXP 58
18073: PPUSH
18074: LD_STRING D2Ar-Pow-3
18076: PPUSH
18077: CALL_OW 88
// end ; 5 :
18081: GO 18174
18083: LD_INT 5
18085: DOUBLE
18086: EQUAL
18087: IFTRUE 18091
18089: GO 18106
18091: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18092: LD_EXP 39
18096: PPUSH
18097: LD_STRING D2Conf-JMM-1
18099: PPUSH
18100: CALL_OW 88
18104: GO 18174
18106: LD_INT 6
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18173
18114: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18115: LD_EXP 39
18119: PPUSH
18120: LD_STRING D2Com-JMM-1
18122: PPUSH
18123: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18127: LD_EXP 58
18131: PPUSH
18132: LD_STRING D2Com-Pow-1
18134: PPUSH
18135: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18139: LD_EXP 39
18143: PPUSH
18144: LD_STRING D2Com-JMM-2
18146: PPUSH
18147: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18151: LD_EXP 58
18155: PPUSH
18156: LD_STRING D2Com-Pow-2
18158: PPUSH
18159: CALL_OW 88
// powellAngerQuery := true ;
18163: LD_ADDR_EXP 36
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// end ;
18174: LD_VAR 0 3
18178: RET
// every 0 0$5 trigger missionStart do var tmp ;
18179: LD_EXP 13
18183: IFFALSE 18466
18185: GO 18187
18187: DISABLE
18188: LD_INT 0
18190: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18191: LD_INT 35
18193: PPUSH
18194: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18198: LD_INT 14
18200: PPUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: PUSH
18216: LD_EXP 15
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 4
18229: PUSH
18230: LD_INT 5
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: IN
18239: AND
18240: IFFALSE 18456
// begin powellAnger := powellAnger + 1 ;
18242: LD_ADDR_EXP 17
18246: PUSH
18247: LD_EXP 17
18251: PUSH
18252: LD_INT 1
18254: PLUS
18255: ST_TO_ADDR
// Video ( true ) ;
18256: LD_INT 1
18258: PPUSH
18259: CALL 107818 0 1
// CenterNowOnUnits ( tmp ) ;
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18272: LD_INT 14
18274: PPUSH
18275: LD_INT 22
18277: PUSH
18278: LD_INT 1
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 70
18289: PPUSH
18290: LD_INT 86
18292: PPUSH
18293: LD_INT 133
18295: PPUSH
18296: CALL_OW 111
// async ;
18300: ASYNC
// case powellAnger of 1 :
18301: LD_EXP 17
18305: PUSH
18306: LD_INT 1
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18329
18314: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18315: LD_EXP 58
18319: PPUSH
18320: LD_STRING DBack1-Pow-1
18322: PPUSH
18323: CALL_OW 88
18327: GO 18376
18329: LD_INT 2
18331: DOUBLE
18332: EQUAL
18333: IFTRUE 18337
18335: GO 18352
18337: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18338: LD_EXP 58
18342: PPUSH
18343: LD_STRING DBack2-Pow-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18376
18352: LD_INT 3
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18375
18360: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18361: LD_EXP 58
18365: PPUSH
18366: LD_STRING DBack3-Pow-1
18368: PPUSH
18369: CALL_OW 88
18373: GO 18376
18375: POP
// sync ;
18376: SYNC
// repeat wait ( 0 0$1 ) ;
18377: LD_INT 35
18379: PPUSH
18380: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18412: LD_INT 14
18414: PPUSH
18415: LD_INT 22
18417: PUSH
18418: LD_INT 1
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PPUSH
18425: CALL_OW 70
18429: NOT
18430: IFFALSE 18377
// if powellAnger >= 3 then
18432: LD_EXP 17
18436: PUSH
18437: LD_INT 3
18439: GREATEREQUAL
18440: IFFALSE 18449
// YouLost ( Dismissed ) ;
18442: LD_STRING Dismissed
18444: PPUSH
18445: CALL_OW 104
// Video ( false ) ;
18449: LD_INT 0
18451: PPUSH
18452: CALL 107818 0 1
// end ; until missionStage > 5 ;
18456: LD_EXP 15
18460: PUSH
18461: LD_INT 5
18463: GREATER
18464: IFFALSE 18191
// end ;
18466: PPOPN 1
18468: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18469: LD_EXP 13
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: LD_INT 4
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 21
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 69
18502: PUSH
18503: LD_INT 4
18505: GREATEREQUAL
18506: AND
18507: PUSH
18508: LD_EXP 15
18512: PUSH
18513: LD_INT 2
18515: EQUAL
18516: AND
18517: IFFALSE 20340
18519: GO 18521
18521: DISABLE
18522: LD_INT 0
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin missionStage := 3 ;
18532: LD_ADDR_EXP 15
18536: PUSH
18537: LD_INT 3
18539: ST_TO_ADDR
// retreat := false ;
18540: LD_ADDR_VAR 0 4
18544: PUSH
18545: LD_INT 0
18547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18548: LD_ADDR_VAR 0 5
18552: PUSH
18553: LD_INT 22
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_INT 22
18589: PUSH
18590: LD_INT 4
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: LD_INT 30
18599: PUSH
18600: LD_INT 5
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PPUSH
18611: CALL_OW 69
18615: ST_TO_ADDR
// if not bar then
18616: LD_VAR 0 6
18620: NOT
18621: IFFALSE 18674
// begin repeat wait ( 0 0$1 ) ;
18623: LD_INT 35
18625: PPUSH
18626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 3
18642: PUSH
18643: LD_INT 57
18645: PUSH
18646: EMPTY
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 30
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: LIST
18667: PPUSH
18668: CALL_OW 69
18672: IFFALSE 18623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18674: LD_ADDR_VAR 0 6
18678: PUSH
18679: LD_INT 22
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: LD_INT 30
18691: PUSH
18692: LD_INT 5
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PPUSH
18703: CALL_OW 69
18707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18708: LD_INT 35
18710: PPUSH
18711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18715: LD_EXP 121
18719: PUSH
18720: LD_INT 4
18722: ARRAY
18723: PUSH
18724: LD_INT 4
18726: GREATEREQUAL
18727: IFFALSE 18708
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18729: LD_ADDR_VAR 0 2
18733: PUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 25
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 25
18779: PUSH
18780: LD_INT 4
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 5
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PUSH
18814: LD_EXP 58
18818: PUSH
18819: LD_EXP 59
18823: ADD
18824: DIFF
18825: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_VAR 0 2
18835: PPUSH
18836: LD_INT 26
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 72
18850: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18851: LD_ADDR_VAR 0 2
18855: PUSH
18856: LD_VAR 0 2
18860: PUSH
18861: LD_VAR 0 3
18865: DIFF
18866: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 2
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL 106471 0 2
18884: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18885: LD_ADDR_VAR 0 3
18889: PUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_INT 1
18897: PPUSH
18898: CALL 106471 0 2
18902: ST_TO_ADDR
// for i = 1 to 4 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 4
18915: PUSH
18916: FOR_TO
18917: IFFALSE 19083
// begin if tmp2 then
18919: LD_VAR 0 3
18923: IFFALSE 19004
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18925: LD_ADDR_EXP 18
18929: PUSH
18930: LD_EXP 18
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: LD_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ARRAY
18946: PUSH
18947: LD_VAR 0 3
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: ADD
18958: PPUSH
18959: CALL_OW 1
18963: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 3
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_VAR 0 3
18991: PPUSH
18992: LD_VAR 0 3
18996: PPUSH
18997: CALL_OW 3
19001: ST_TO_ADDR
// end else
19002: GO 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19004: LD_ADDR_EXP 18
19008: PUSH
19009: LD_EXP 18
19013: PPUSH
19014: LD_INT 1
19016: PPUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PUSH
19026: LD_VAR 0 2
19030: PUSH
19031: LD_VAR 0 2
19035: ARRAY
19036: ADD
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 2
19052: ARRAY
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: LD_VAR 0 2
19075: PPUSH
19076: CALL_OW 3
19080: ST_TO_ADDR
// end ; end ;
19081: GO 18916
19083: POP
19084: POP
// if tmp2 then
19085: LD_VAR 0 3
19089: IFFALSE 19107
// tmp := tmp union tmp2 ;
19091: LD_ADDR_VAR 0 2
19095: PUSH
19096: LD_VAR 0 2
19100: PUSH
19101: LD_VAR 0 3
19105: UNION
19106: ST_TO_ADDR
// for i = 1 to 4 do
19107: LD_ADDR_VAR 0 1
19111: PUSH
19112: DOUBLE
19113: LD_INT 1
19115: DEC
19116: ST_TO_ADDR
19117: LD_INT 4
19119: PUSH
19120: FOR_TO
19121: IFFALSE 19170
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19123: LD_ADDR_EXP 18
19127: PUSH
19128: LD_EXP 18
19132: PPUSH
19133: LD_INT 2
19135: PPUSH
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PUSH
19145: LD_VAR 0 2
19149: PUSH
19150: LD_VAR 0 2
19154: PUSH
19155: LD_VAR 0 1
19159: MINUS
19160: ARRAY
19161: ADD
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
19168: GO 19120
19170: POP
19171: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19172: LD_ADDR_EXP 102
19176: PUSH
19177: LD_EXP 102
19181: PPUSH
19182: LD_INT 4
19184: PPUSH
19185: LD_EXP 102
19189: PUSH
19190: LD_INT 4
19192: ARRAY
19193: PUSH
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: DIFF
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 313
19222: IFFALSE 19277
// begin for i in UnitsInside ( arm [ 1 ] ) do
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_VAR 0 5
19233: PUSH
19234: LD_INT 1
19236: ARRAY
19237: PPUSH
19238: CALL_OW 313
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19275
// begin ComExitBuilding ( i ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_VAR 0 6
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: CALL_OW 180
// end ;
19273: GO 19243
19275: POP
19276: POP
// end ; wait ( 0 0$3 ) ;
19277: LD_INT 105
19279: PPUSH
19280: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19284: LD_ADDR_VAR 0 1
19288: PUSH
19289: LD_EXP 18
19293: PUSH
19294: LD_INT 1
19296: ARRAY
19297: PUSH
19298: FOR_IN
19299: IFFALSE 19406
// begin if IsInUnit ( i ) then
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 310
19310: IFFALSE 19321
// ComExitBuilding ( i ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 122
// if GetClass ( i ) <> 1 then
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 257
19330: PUSH
19331: LD_INT 1
19333: NONEQUAL
19334: IFFALSE 19375
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 1
19361: PPUSH
19362: CALL_OW 183
// AddComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 60
19382: PPUSH
19383: LD_INT 94
19385: PPUSH
19386: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_EXP 58
19399: PPUSH
19400: CALL_OW 179
// end ;
19404: GO 19298
19406: POP
19407: POP
// wait ( 0 0$15 ) ;
19408: LD_INT 525
19410: PPUSH
19411: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19415: LD_EXP 58
19419: PPUSH
19420: LD_STRING D4-Pow-1
19422: PPUSH
19423: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19427: LD_ADDR_VAR 0 2
19431: PUSH
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 26
19443: PUSH
19444: LD_INT 1
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: ST_TO_ADDR
// if tmp then
19456: LD_VAR 0 2
19460: IFFALSE 19478
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19462: LD_VAR 0 2
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: LD_STRING D4-Sol1-1
19473: PPUSH
19474: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19478: LD_EXP 58
19482: PPUSH
19483: LD_STRING D4-Pow-2
19485: PPUSH
19486: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: DOUBLE
19496: LD_INT 1
19498: DEC
19499: ST_TO_ADDR
19500: LD_EXP 18
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19603
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19512: LD_EXP 18
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PPUSH
19527: LD_EXP 121
19531: PUSH
19532: LD_INT 4
19534: ARRAY
19535: PUSH
19536: LD_INT 1
19538: ARRAY
19539: PPUSH
19540: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19544: LD_ADDR_EXP 121
19548: PUSH
19549: LD_EXP 121
19553: PPUSH
19554: LD_INT 4
19556: PPUSH
19557: LD_EXP 121
19561: PUSH
19562: LD_INT 4
19564: ARRAY
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19579: LD_INT 8
19581: PPUSH
19582: LD_EXP 18
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 471
// end ;
19601: GO 19509
19603: POP
19604: POP
// repeat wait ( 0 0$1 ) ;
19605: LD_INT 35
19607: PPUSH
19608: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PPUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PPUSH
19627: CALL_OW 72
19631: PUSH
19632: LD_INT 4
19634: GREATEREQUAL
19635: IFFALSE 19605
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19637: LD_EXP 18
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 69
19648: PPUSH
19649: LD_INT 94
19651: PPUSH
19652: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19656: LD_EXP 18
19660: PUSH
19661: LD_INT 1
19663: ARRAY
19664: PPUSH
19665: LD_INT 82
19667: PPUSH
19668: LD_INT 83
19670: PPUSH
19671: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19675: LD_EXP 18
19679: PUSH
19680: LD_INT 1
19682: ARRAY
19683: PPUSH
19684: LD_INT 77
19686: PPUSH
19687: LD_INT 69
19689: PPUSH
19690: CALL_OW 174
// repeat wait ( 3 ) ;
19694: LD_INT 3
19696: PPUSH
19697: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19701: LD_ADDR_VAR 0 1
19705: PUSH
19706: LD_EXP 18
19710: PUSH
19711: LD_INT 1
19713: ARRAY
19714: PUSH
19715: FOR_IN
19716: IFFALSE 19852
// begin if GetLives ( i ) < 990 then
19718: LD_VAR 0 1
19722: PPUSH
19723: CALL_OW 256
19727: PUSH
19728: LD_INT 990
19730: LESS
19731: IFFALSE 19745
// SetLives ( i , 1000 ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_INT 1000
19740: PPUSH
19741: CALL_OW 234
// if not IsInUnit ( i ) then
19745: LD_VAR 0 1
19749: PPUSH
19750: CALL_OW 310
19754: NOT
19755: IFFALSE 19850
// begin if not HasTask ( i ) then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 314
19766: NOT
19767: IFFALSE 19784
// ComMoveXY ( i , 64 , 93 ) ;
19769: LD_VAR 0 1
19773: PPUSH
19774: LD_INT 64
19776: PPUSH
19777: LD_INT 93
19779: PPUSH
19780: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19784: LD_VAR 0 4
19788: NOT
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 258
19799: PUSH
19800: LD_INT 1
19802: EQUAL
19803: AND
19804: IFFALSE 19850
// begin retreat := true ;
19806: LD_ADDR_VAR 0 4
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19814: LD_VAR 0 1
19818: PPUSH
19819: LD_INT 2
19821: PPUSH
19822: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_STRING D4a-Sol1-1
19833: PPUSH
19834: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19838: LD_EXP 58
19842: PPUSH
19843: LD_STRING D4a-Pow-1
19845: PPUSH
19846: CALL_OW 88
// end ; end ; end ;
19850: GO 19715
19852: POP
19853: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19854: LD_EXP 18
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 95
19865: PUSH
19866: LD_INT 9
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: PUSH
19873: LD_INT 3
19875: PUSH
19876: LD_INT 55
19878: PUSH
19879: EMPTY
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PPUSH
19890: CALL_OW 72
19894: PUSH
19895: LD_INT 4
19897: GREATEREQUAL
19898: IFFALSE 19694
// for i in powellSquadAttack [ 1 ] do
19900: LD_ADDR_VAR 0 1
19904: PUSH
19905: LD_EXP 18
19909: PUSH
19910: LD_INT 1
19912: ARRAY
19913: PUSH
19914: FOR_IN
19915: IFFALSE 20051
// begin if GetTag ( i ) = 2 then
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 110
19926: PUSH
19927: LD_INT 2
19929: EQUAL
19930: IFFALSE 19992
// begin ComMoveXY ( i , 60 , 94 ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 60
19939: PPUSH
19940: LD_INT 94
19942: PPUSH
19943: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_EXP 58
19956: PPUSH
19957: CALL_OW 179
// wait ( 0 0$3 ) ;
19961: LD_INT 105
19963: PPUSH
19964: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19968: LD_VAR 0 1
19972: PPUSH
19973: LD_STRING D4a-Sol1-2
19975: PPUSH
19976: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19980: LD_EXP 58
19984: PPUSH
19985: LD_STRING D4a-Pow-2
19987: PPUSH
19988: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 0
19999: PPUSH
20000: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20004: LD_ADDR_EXP 102
20008: PUSH
20009: LD_EXP 102
20013: PPUSH
20014: LD_INT 4
20016: PPUSH
20017: LD_EXP 102
20021: PUSH
20022: LD_INT 4
20024: ARRAY
20025: PUSH
20026: LD_VAR 0 1
20030: UNION
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20037: LD_INT 8
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 472
// end ;
20049: GO 19914
20051: POP
20052: POP
// wait ( 4 4$00 ) ;
20053: LD_INT 8400
20055: PPUSH
20056: CALL_OW 67
// uc_side := 6 ;
20060: LD_ADDR_OWVAR 20
20064: PUSH
20065: LD_INT 6
20067: ST_TO_ADDR
// uc_nation := 3 ;
20068: LD_ADDR_OWVAR 21
20072: PUSH
20073: LD_INT 3
20075: ST_TO_ADDR
// ru := [ ] ;
20076: LD_ADDR_VAR 0 7
20080: PUSH
20081: EMPTY
20082: ST_TO_ADDR
// for i = 1 to 4 do
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_INT 4
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20198
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20099: LD_INT 22
20101: PPUSH
20102: LD_INT 1
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 43
20110: PUSH
20111: LD_INT 44
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: CALL_OW 12
20128: ARRAY
20129: PPUSH
20130: LD_INT 89
20132: PPUSH
20133: CALL 72091 0 5
// un := CreateVehicle ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: CALL_OW 45
20146: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20147: LD_VAR 0 8
20151: PPUSH
20152: LD_INT 4
20154: PPUSH
20155: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20159: LD_VAR 0 8
20163: PPUSH
20164: LD_INT 136
20166: PPUSH
20167: LD_INT 90
20169: PPUSH
20170: LD_INT 8
20172: PPUSH
20173: LD_INT 0
20175: PPUSH
20176: CALL_OW 50
// ru := ru ^ un ;
20180: LD_ADDR_VAR 0 7
20184: PUSH
20185: LD_VAR 0 7
20189: PUSH
20190: LD_VAR 0 8
20194: ADD
20195: ST_TO_ADDR
// end ;
20196: GO 20096
20198: POP
20199: POP
// if ru then
20200: LD_VAR 0 7
20204: IFFALSE 20221
// ComAgressiveMove ( ru , 80 , 92 ) ;
20206: LD_VAR 0 7
20210: PPUSH
20211: LD_INT 80
20213: PPUSH
20214: LD_INT 92
20216: PPUSH
20217: CALL_OW 114
// wait ( 8 8$00 ) ;
20221: LD_INT 16800
20223: PPUSH
20224: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20228: LD_INT 4
20230: PPUSH
20231: LD_INT 3
20233: PUSH
20234: LD_INT 1
20236: PUSH
20237: LD_INT 1
20239: PUSH
20240: LD_INT 5
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 6
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: PUSH
20267: LD_INT 4
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 1
20275: PUSH
20276: LD_INT 7
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: PUSH
20285: LD_INT 3
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 1
20293: PUSH
20294: LD_INT 7
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 3
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 1
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL 58524 0 2
// missionStage := 4 ;
20332: LD_ADDR_EXP 15
20336: PUSH
20337: LD_INT 4
20339: ST_TO_ADDR
// end ;
20340: PPOPN 8
20342: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20343: LD_EXP 15
20347: PUSH
20348: LD_INT 4
20350: EQUAL
20351: PUSH
20352: LD_INT 22
20354: PUSH
20355: LD_INT 4
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: PUSH
20362: LD_INT 21
20364: PUSH
20365: LD_INT 2
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: PUSH
20381: LD_INT 5
20383: GREATEREQUAL
20384: AND
20385: IFFALSE 24490
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
20394: PPUSH
20395: PPUSH
20396: PPUSH
20397: PPUSH
20398: PPUSH
20399: PPUSH
20400: PPUSH
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
// begin missionStage := 5 ;
20405: LD_ADDR_EXP 15
20409: PUSH
20410: LD_INT 5
20412: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20413: LD_ADDR_VAR 0 10
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 4
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 4
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 5
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20465: LD_ADDR_VAR 0 6
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 4
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 21
20482: PUSH
20483: LD_INT 1
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: LD_INT 25
20495: PUSH
20496: LD_INT 16
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 3
20509: PUSH
20510: LD_INT 25
20512: PUSH
20513: LD_INT 12
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 69
20534: PUSH
20535: LD_EXP 58
20539: DIFF
20540: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 22
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 3
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20579: LD_INT 35
20581: PPUSH
20582: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20586: LD_EXP 121
20590: PUSH
20591: LD_INT 4
20593: ARRAY
20594: PUSH
20595: LD_INT 5
20597: GREATEREQUAL
20598: PUSH
20599: LD_EXP 121
20603: PUSH
20604: LD_INT 4
20606: ARRAY
20607: PPUSH
20608: LD_INT 58
20610: PUSH
20611: EMPTY
20612: LIST
20613: PPUSH
20614: CALL_OW 72
20618: PUSH
20619: LD_INT 5
20621: GREATEREQUAL
20622: AND
20623: IFFALSE 20579
// powellAllowRetreat := false ;
20625: LD_ADDR_EXP 19
20629: PUSH
20630: LD_INT 0
20632: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20633: LD_INT 700
20635: PPUSH
20636: CALL_OW 67
// activeAttacks := false ;
20640: LD_ADDR_EXP 16
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20648: LD_INT 35
20650: PPUSH
20651: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20655: LD_INT 22
20657: PUSH
20658: LD_INT 6
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 0
20672: EQUAL
20673: IFFALSE 20648
// tmp := mc_vehicles [ 4 ] ;
20675: LD_ADDR_VAR 0 3
20679: PUSH
20680: LD_EXP 121
20684: PUSH
20685: LD_INT 4
20687: ARRAY
20688: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20689: LD_ADDR_VAR 0 1
20693: PUSH
20694: DOUBLE
20695: LD_INT 1
20697: DEC
20698: ST_TO_ADDR
20699: LD_EXP 18
20703: PUSH
20704: FOR_TO
20705: IFFALSE 20966
// begin for j in powellSquadAttack [ i ] do
20707: LD_ADDR_VAR 0 2
20711: PUSH
20712: LD_EXP 18
20716: PUSH
20717: LD_VAR 0 1
20721: ARRAY
20722: PUSH
20723: FOR_IN
20724: IFFALSE 20962
// begin forces := forces diff j ;
20726: LD_ADDR_VAR 0 6
20730: PUSH
20731: LD_VAR 0 6
20735: PUSH
20736: LD_VAR 0 2
20740: DIFF
20741: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 109
// wait ( 0 0$2 ) ;
20754: LD_INT 70
20756: PPUSH
20757: CALL_OW 67
// if IsInUnit ( j ) then
20761: LD_VAR 0 2
20765: PPUSH
20766: CALL_OW 310
20770: IFFALSE 20781
// ComExitBuilding ( j ) ;
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL_OW 122
// if GetClass ( j ) <> 1 then
20781: LD_VAR 0 2
20785: PPUSH
20786: CALL_OW 257
20790: PUSH
20791: LD_INT 1
20793: NONEQUAL
20794: IFFALSE 20874
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20796: LD_VAR 0 10
20800: PUSH
20801: LD_INT 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 313
20809: PUSH
20810: LD_INT 5
20812: GREATEREQUAL
20813: IFFALSE 20835
// AddComEnterUnit ( j , arm [ 2 ] ) else
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: CALL_OW 180
20833: GO 20853
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 10
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: CALL_OW 183
// AddComExitBuilding ( j ) ;
20865: LD_VAR 0 2
20869: PPUSH
20870: CALL_OW 182
// end ; if i = 2 then
20874: LD_VAR 0 1
20878: PUSH
20879: LD_INT 2
20881: EQUAL
20882: IFFALSE 20899
// AddComMoveXY ( j , 61 , 93 ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: LD_INT 61
20891: PPUSH
20892: LD_INT 93
20894: PPUSH
20895: CALL_OW 171
// if i = 1 then
20899: LD_VAR 0 1
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20960
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 3
20918: PUSH
20919: LD_INT 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20927: LD_ADDR_VAR 0 3
20931: PUSH
20932: LD_VAR 0 3
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 3
20944: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 69
20952: PPUSH
20953: LD_INT 94
20955: PPUSH
20956: CALL_OW 171
// end ; end ;
20960: GO 20723
20962: POP
20963: POP
// end ;
20964: GO 20704
20966: POP
20967: POP
// wait ( 0 0$55 ) ;
20968: LD_INT 1925
20970: PPUSH
20971: CALL_OW 67
// MC_Kill ( 4 ) ;
20975: LD_INT 4
20977: PPUSH
20978: CALL 35112 0 1
// tmp := UnitsInside ( fac ) ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_VAR 0 9
20991: PPUSH
20992: CALL_OW 313
20996: ST_TO_ADDR
// if tmp then
20997: LD_VAR 0 3
21001: IFFALSE 21122
// for i in tmp do
21003: LD_ADDR_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: PUSH
21013: FOR_IN
21014: IFFALSE 21120
// begin ComExitBuilding ( i ) ;
21016: LD_VAR 0 1
21020: PPUSH
21021: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21025: LD_VAR 0 10
21029: PUSH
21030: LD_INT 2
21032: ARRAY
21033: PPUSH
21034: CALL_OW 313
21038: PUSH
21039: LD_INT 6
21041: LESS
21042: IFFALSE 21064
// AddComEnterUnit ( i , arm [ 2 ] ) else
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_VAR 0 10
21053: PUSH
21054: LD_INT 2
21056: ARRAY
21057: PPUSH
21058: CALL_OW 180
21062: GO 21118
// if UnitsInside ( arm [ 1 ] ) < 6 then
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: CALL_OW 313
21077: PUSH
21078: LD_INT 6
21080: LESS
21081: IFFALSE 21103
// AddComEnterUnit ( i , arm [ 1 ] ) else
21083: LD_VAR 0 1
21087: PPUSH
21088: LD_VAR 0 10
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PPUSH
21097: CALL_OW 180
21101: GO 21118
// AddComMoveXY ( i , 37 , 68 ) ;
21103: LD_VAR 0 1
21107: PPUSH
21108: LD_INT 37
21110: PPUSH
21111: LD_INT 68
21113: PPUSH
21114: CALL_OW 171
// end ;
21118: GO 21013
21120: POP
21121: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21122: LD_ADDR_VAR 0 11
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_INT 26
21134: PUSH
21135: LD_INT 1
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 72
21146: PUSH
21147: LD_EXP 59
21151: DIFF
21152: ST_TO_ADDR
// if not speaker then
21153: LD_VAR 0 11
21157: NOT
21158: IFFALSE 21185
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21160: LD_ADDR_VAR 0 11
21164: PUSH
21165: LD_VAR 0 6
21169: PPUSH
21170: LD_INT 26
21172: PUSH
21173: LD_INT 1
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// if speaker then
21185: LD_VAR 0 11
21189: IFFALSE 21205
// speaker := speaker [ 1 ] ;
21191: LD_ADDR_VAR 0 11
21195: PUSH
21196: LD_VAR 0 11
21200: PUSH
21201: LD_INT 1
21203: ARRAY
21204: ST_TO_ADDR
// Video ( true ) ;
21205: LD_INT 1
21207: PPUSH
21208: CALL 107818 0 1
// CenterNowOnUnits ( Powell ) ;
21212: LD_EXP 58
21216: PPUSH
21217: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 6
21230: PPUSH
21231: LD_INT 3
21233: PUSH
21234: LD_INT 25
21236: PUSH
21237: LD_INT 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PPUSH
21248: CALL_OW 72
21252: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21253: LD_ADDR_VAR 0 12
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 32
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 58
21280: PUSH
21281: EMPTY
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// for i = 1 to 6 do
21294: LD_ADDR_VAR 0 1
21298: PUSH
21299: DOUBLE
21300: LD_INT 1
21302: DEC
21303: ST_TO_ADDR
21304: LD_INT 6
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21449
// begin if IsInUnit ( tmp [ i ] ) then
21310: LD_VAR 0 3
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: CALL_OW 310
21325: IFFALSE 21342
// ComExitBuilding ( tmp [ i ] ) ;
21327: LD_VAR 0 3
21331: PUSH
21332: LD_VAR 0 1
21336: ARRAY
21337: PPUSH
21338: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: LD_VAR 0 10
21357: PUSH
21358: LD_INT 1
21360: ARRAY
21361: PPUSH
21362: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 1
21375: ARRAY
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL_OW 183
// if emp_towers then
21384: LD_VAR 0 12
21388: IFFALSE 21447
// begin AddComExitBuilding ( tmp [ i ] ) ;
21390: LD_VAR 0 3
21394: PUSH
21395: LD_VAR 0 1
21399: ARRAY
21400: PPUSH
21401: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 12
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21429: LD_ADDR_VAR 0 12
21433: PUSH
21434: LD_VAR 0 12
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 3
21446: ST_TO_ADDR
// end ; end ;
21447: GO 21307
21449: POP
21450: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21451: LD_ADDR_VAR 0 3
21455: PUSH
21456: LD_EXP 18
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PUSH
21465: LD_EXP 18
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: ADD
21474: PPUSH
21475: LD_INT 26
21477: PUSH
21478: LD_INT 1
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: PPUSH
21485: CALL_OW 72
21489: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_EXP 18
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21523
// ComTurnUnit ( i , Powell ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_EXP 58
21516: PPUSH
21517: CALL_OW 119
21521: GO 21504
21523: POP
21524: POP
// Say ( Powell , D5-Pow-1 ) ;
21525: LD_EXP 58
21529: PPUSH
21530: LD_STRING D5-Pow-1
21532: PPUSH
21533: CALL_OW 88
// if tmp then
21537: LD_VAR 0 3
21541: IFFALSE 21559
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: ARRAY
21551: PPUSH
21552: LD_STRING D5-Sol2-1
21554: PPUSH
21555: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21559: LD_EXP 58
21563: PPUSH
21564: LD_STRING D5-Pow-2
21566: PPUSH
21567: CALL_OW 88
// if tmp > 1 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 1
21578: GREATER
21579: IFFALSE 21597
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21581: LD_VAR 0 3
21585: PUSH
21586: LD_INT 2
21588: ARRAY
21589: PPUSH
21590: LD_STRING D5-Sol2-2
21592: PPUSH
21593: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21597: LD_EXP 58
21601: PPUSH
21602: LD_STRING D5-Pow-3
21604: PPUSH
21605: CALL_OW 88
// wait ( 0 0$1 ) ;
21609: LD_INT 35
21611: PPUSH
21612: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21616: LD_ADDR_VAR 0 3
21620: PUSH
21621: LD_EXP 18
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PUSH
21630: LD_EXP 18
21634: PUSH
21635: LD_INT 2
21637: ARRAY
21638: UNION
21639: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21640: LD_VAR 0 3
21644: PPUSH
21645: LD_INT 80
21647: PPUSH
21648: LD_INT 67
21650: PPUSH
21651: CALL_OW 114
// wait ( 0 0$2 ) ;
21655: LD_INT 70
21657: PPUSH
21658: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21662: LD_INT 79
21664: PPUSH
21665: LD_INT 72
21667: PPUSH
21668: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21672: LD_INT 35
21674: PPUSH
21675: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_INT 3
21686: PUSH
21687: LD_INT 24
21689: PUSH
21690: LD_INT 1000
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PPUSH
21701: CALL_OW 72
21705: IFFALSE 21672
// Say ( Powell , D5a-Pow-1 ) ;
21707: LD_EXP 58
21711: PPUSH
21712: LD_STRING D5a-Pow-1
21714: PPUSH
21715: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21719: LD_EXP 58
21723: PPUSH
21724: LD_STRING D5a-Pow-1a
21726: PPUSH
21727: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21731: LD_INT 10
21733: PPUSH
21734: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21738: LD_EXP 58
21742: PPUSH
21743: LD_STRING D5a-Pow-1b
21745: PPUSH
21746: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21750: LD_EXP 58
21754: PPUSH
21755: LD_STRING D5a-Pow-1c
21757: PPUSH
21758: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21762: LD_EXP 58
21766: PPUSH
21767: LD_STRING D5a-Pow-1d
21769: PPUSH
21770: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21774: LD_INT 35
21776: PPUSH
21777: CALL_OW 67
// if not HasTask ( tmp ) then
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 314
21790: NOT
21791: IFFALSE 21808
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_INT 80
21800: PPUSH
21801: LD_INT 67
21803: PPUSH
21804: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 24
21815: PUSH
21816: LD_INT 1
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: IFFALSE 21774
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 22
21837: PUSH
21838: LD_INT 4
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PUSH
21845: LD_INT 92
21847: PUSH
21848: LD_INT 60
21850: PUSH
21851: LD_INT 93
21853: PUSH
21854: LD_INT 10
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: LIST
21862: PUSH
21863: LD_INT 3
21865: PUSH
21866: LD_INT 54
21868: PUSH
21869: EMPTY
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 69
21885: PUSH
21886: LD_EXP 58
21890: DIFF
21891: ST_TO_ADDR
// if tmp then
21892: LD_VAR 0 3
21896: IFFALSE 21930
// for i in tmp do
21898: LD_ADDR_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: PUSH
21908: FOR_IN
21909: IFFALSE 21928
// ComMoveXY ( i , 36 , 67 ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: LD_INT 36
21918: PPUSH
21919: LD_INT 67
21921: PPUSH
21922: CALL_OW 111
21926: GO 21908
21928: POP
21929: POP
// wait ( 0 0$3 ) ;
21930: LD_INT 105
21932: PPUSH
21933: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21937: LD_VAR 0 11
21941: PPUSH
21942: LD_STRING D6-Sol3-1
21944: PPUSH
21945: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21949: LD_EXP 58
21953: PPUSH
21954: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21958: LD_EXP 58
21962: PPUSH
21963: LD_STRING D6-Pow-1
21965: PPUSH
21966: CALL_OW 88
// tmp := [ ] ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: EMPTY
21976: ST_TO_ADDR
// for i = 1 to 2 do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: DOUBLE
21983: LD_INT 1
21985: DEC
21986: ST_TO_ADDR
21987: LD_INT 2
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22105
// begin uc_side := 8 ;
21993: LD_ADDR_OWVAR 20
21997: PUSH
21998: LD_INT 8
22000: ST_TO_ADDR
// uc_nation := 2 ;
22001: LD_ADDR_OWVAR 21
22005: PUSH
22006: LD_INT 2
22008: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22009: LD_INT 14
22011: PPUSH
22012: LD_INT 3
22014: PPUSH
22015: LD_INT 2
22017: PPUSH
22018: LD_INT 29
22020: PPUSH
22021: LD_INT 100
22023: PPUSH
22024: CALL 72091 0 5
// veh := CreateVehicle ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: CALL_OW 45
22037: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22038: LD_VAR 0 13
22042: PPUSH
22043: LD_INT 4
22045: PPUSH
22046: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22050: LD_VAR 0 13
22054: PPUSH
22055: LD_INT 99
22057: PPUSH
22058: LD_INT 83
22060: PPUSH
22061: LD_INT 6
22063: PPUSH
22064: LD_INT 0
22066: PPUSH
22067: CALL_OW 50
// wait ( 3 ) ;
22071: LD_INT 3
22073: PPUSH
22074: CALL_OW 67
// Connect ( veh ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: CALL 75146 0 1
// tmp := tmp ^ veh ;
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: PUSH
22097: LD_VAR 0 13
22101: ADD
22102: ST_TO_ADDR
// end ;
22103: GO 21990
22105: POP
22106: POP
// wait ( 0 0$1 ) ;
22107: LD_INT 35
22109: PPUSH
22110: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22114: LD_INT 99
22116: PPUSH
22117: LD_INT 83
22119: PPUSH
22120: LD_INT 1
22122: PPUSH
22123: LD_INT 10
22125: PPUSH
22126: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22130: LD_INT 99
22132: PPUSH
22133: LD_INT 83
22135: PPUSH
22136: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_STRING D6-Sol3-2
22147: PPUSH
22148: CALL_OW 88
// async ;
22152: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22153: LD_EXP 58
22157: PPUSH
22158: LD_STRING D6-Pow-2
22160: PPUSH
22161: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: PPUSH
22174: LD_VAR 0 9
22178: PPUSH
22179: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: ARRAY
22191: PPUSH
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 21
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PPUSH
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 2
22228: ARRAY
22229: PPUSH
22230: CALL_OW 74
22234: PPUSH
22235: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22239: LD_EXP 58
22243: PPUSH
22244: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 331
// repeat wait ( 4 ) ;
22261: LD_INT 4
22263: PPUSH
22264: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22268: LD_VAR 0 3
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22303
// SetLives ( tmp [ 1 ] , 1000 ) ;
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_INT 1000
22298: PPUSH
22299: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22303: LD_INT 22
22305: PUSH
22306: LD_INT 4
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 3
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PPUSH
22327: CALL_OW 69
22331: PUSH
22332: LD_INT 0
22334: EQUAL
22335: IFFALSE 22261
// sync ;
22337: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22338: LD_EXP 58
22342: PPUSH
22343: LD_STRING D6a-Pow-1
22345: PPUSH
22346: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22350: LD_VAR 0 11
22354: PPUSH
22355: LD_STRING D6a-Sol3-1
22357: PPUSH
22358: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22362: LD_EXP 58
22366: PPUSH
22367: LD_STRING D6a-Pow-2
22369: PPUSH
22370: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22374: LD_VAR 0 11
22378: PPUSH
22379: LD_STRING D6a-Sol3-2
22381: PPUSH
22382: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22386: LD_EXP 58
22390: PPUSH
22391: LD_STRING D6a-Pow-3
22393: PPUSH
22394: CALL_OW 88
// powellCenterCameraMode := true ;
22398: LD_ADDR_EXP 20
22402: PUSH
22403: LD_INT 1
22405: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22406: LD_ADDR_VAR 0 1
22410: PUSH
22411: LD_INT 22
22413: PUSH
22414: LD_INT 8
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 25
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: PUSH
22440: FOR_IN
22441: IFFALSE 22496
// begin SetTag ( i , 1 ) ;
22443: LD_VAR 0 1
22447: PPUSH
22448: LD_INT 1
22450: PPUSH
22451: CALL_OW 109
// ComExitBuilding ( i ) ;
22455: LD_VAR 0 1
22459: PPUSH
22460: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 35
22471: PPUSH
22472: LD_INT 6
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 53
22486: PPUSH
22487: LD_INT 4
22489: PPUSH
22490: CALL_OW 171
// end ;
22494: GO 22440
22496: POP
22497: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_INT 4
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: PUSH
22513: LD_INT 21
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 34
22528: PUSH
22529: LD_INT 12
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22550: LD_EXP 58
22554: PPUSH
22555: LD_VAR 0 3
22559: PPUSH
22560: LD_EXP 58
22564: PPUSH
22565: CALL_OW 74
22569: PPUSH
22570: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22574: LD_EXP 58
22578: PPUSH
22579: LD_INT 100
22581: PPUSH
22582: LD_INT 88
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 75
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 88
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22619: LD_INT 8
22621: PPUSH
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 471
// repeat wait ( 3 ) ;
22631: LD_INT 3
22633: PPUSH
22634: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22638: LD_INT 22
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: LD_INT 92
22650: PUSH
22651: LD_INT 100
22653: PUSH
22654: LD_INT 75
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PPUSH
22670: CALL_OW 69
22674: IFFALSE 22631
// async ;
22676: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22677: LD_EXP 58
22681: PPUSH
22682: LD_STRING D6b-Pow-1
22684: PPUSH
22685: CALL_OW 88
// repeat wait ( 3 ) ;
22689: LD_INT 3
22691: PPUSH
22692: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22696: LD_EXP 58
22700: PPUSH
22701: CALL_OW 310
22705: PPUSH
22706: CALL_OW 256
22710: PUSH
22711: LD_INT 1000
22713: LESS
22714: IFFALSE 22733
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: CALL_OW 310
22725: PPUSH
22726: LD_INT 1000
22728: PPUSH
22729: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22733: LD_EXP 58
22737: PPUSH
22738: CALL_OW 256
22742: PUSH
22743: LD_INT 1000
22745: LESS
22746: IFFALSE 22760
// SetLives ( Powell , 1000 ) ;
22748: LD_EXP 58
22752: PPUSH
22753: LD_INT 1000
22755: PPUSH
22756: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22760: LD_EXP 58
22764: PPUSH
22765: LD_EXP 63
22769: PPUSH
22770: CALL_OW 296
22774: PUSH
22775: LD_INT 5
22777: LESS
22778: PUSH
22779: LD_EXP 58
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: LD_EXP 63
22793: PPUSH
22794: CALL_OW 296
22798: PUSH
22799: LD_INT 5
22801: LESS
22802: OR
22803: IFFALSE 22822
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: CALL_OW 310
22814: PPUSH
22815: LD_INT 100
22817: PPUSH
22818: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22822: LD_EXP 58
22826: PPUSH
22827: CALL_OW 310
22831: NOT
22832: IFFALSE 22689
// DoNotAttack ( 8 , powellBomb ) ;
22834: LD_INT 8
22836: PPUSH
22837: LD_EXP 63
22841: PPUSH
22842: CALL_OW 471
// game_speed := 4 ;
22846: LD_ADDR_OWVAR 65
22850: PUSH
22851: LD_INT 4
22853: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_STRING D6b-Pow-1a
22861: PPUSH
22862: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22866: LD_EXP 58
22870: PPUSH
22871: LD_EXP 63
22875: PPUSH
22876: CALL_OW 180
// sync ;
22880: SYNC
// repeat wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// until IsInUnit ( Powell ) ;
22888: LD_EXP 58
22892: PPUSH
22893: CALL_OW 310
22897: IFFALSE 22881
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22899: LD_INT 8
22901: PPUSH
22902: LD_EXP 58
22906: PPUSH
22907: CALL_OW 310
22911: PPUSH
22912: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22916: LD_EXP 58
22920: PPUSH
22921: LD_INT 91
22923: PPUSH
22924: LD_INT 44
22926: PPUSH
22927: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 96
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 41
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 92
22968: PPUSH
22969: LD_INT 39
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 88
22983: PPUSH
22984: LD_INT 41
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 91
22998: PPUSH
22999: LD_INT 44
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 96
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 41
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 92
23043: PPUSH
23044: LD_INT 39
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 88
23058: PPUSH
23059: LD_INT 41
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 91
23073: PPUSH
23074: LD_INT 44
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 93
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 36
23106: PPUSH
23107: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23111: LD_INT 122
23113: PPUSH
23114: CALL_OW 67
// game_speed := 4 ;
23118: LD_ADDR_OWVAR 65
23122: PUSH
23123: LD_INT 4
23125: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_STRING D6b-Pow-1b
23133: PPUSH
23134: CALL_OW 88
// tmp := [ ] ;
23138: LD_ADDR_VAR 0 3
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23145: LD_ADDR_VAR 0 5
23149: PUSH
23150: LD_INT 78
23152: PUSH
23153: LD_INT 47
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: LD_INT 106
23162: PUSH
23163: LD_INT 53
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23174: LD_ADDR_VAR 0 1
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 8
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 3
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 92
23201: PUSH
23202: LD_INT 90
23204: PUSH
23205: LD_INT 52
23207: PUSH
23208: LD_INT 12
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: LIST
23221: PPUSH
23222: CALL_OW 69
23226: PUSH
23227: FOR_IN
23228: IFFALSE 23253
// tmp := tmp ^ UnitsInside ( i ) ;
23230: LD_ADDR_VAR 0 3
23234: PUSH
23235: LD_VAR 0 3
23239: PUSH
23240: LD_VAR 0 1
23244: PPUSH
23245: CALL_OW 313
23249: ADD
23250: ST_TO_ADDR
23251: GO 23227
23253: POP
23254: POP
// for i in tmp do
23255: LD_ADDR_VAR 0 1
23259: PUSH
23260: LD_VAR 0 3
23264: PUSH
23265: FOR_IN
23266: IFFALSE 23428
// begin dist := 9999 ;
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: LD_INT 9999
23275: ST_TO_ADDR
// _xy := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_INT 1
23290: PPUSH
23291: CALL_OW 109
// ComExitBuilding ( i ) ;
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 122
// for j in xy do
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_IN
23315: IFFALSE 23397
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23317: LD_VAR 0 1
23321: PPUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_INT 1
23329: ARRAY
23330: PPUSH
23331: LD_VAR 0 2
23335: PUSH
23336: LD_INT 2
23338: ARRAY
23339: PPUSH
23340: CALL_OW 297
23344: PUSH
23345: LD_VAR 0 8
23349: LESS
23350: IFFALSE 23395
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: ST_TO_ADDR
// _xy := j ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 2
23394: ST_TO_ADDR
// end ;
23395: GO 23314
23397: POP
23398: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PPUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 2
23420: ARRAY
23421: PPUSH
23422: CALL_OW 171
// end ;
23426: GO 23265
23428: POP
23429: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23430: LD_ADDR_VAR 0 4
23434: PUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 25
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PPUSH
23464: CALL_OW 72
23468: ST_TO_ADDR
// if tmp2 < 2 then
23469: LD_VAR 0 4
23473: PUSH
23474: LD_INT 2
23476: LESS
23477: IFFALSE 23546
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_INT 22
23486: PUSH
23487: LD_INT 8
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 26
23496: PUSH
23497: LD_INT 1
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 25
23509: PUSH
23510: LD_INT 15
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 69
23530: PUSH
23531: LD_EXP 60
23535: PUSH
23536: LD_EXP 61
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: DIFF
23545: ST_TO_ADDR
// if tmp2 then
23546: LD_VAR 0 4
23550: IFFALSE 23568
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23552: LD_VAR 0 4
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_STRING D6b-ArSol1-1
23563: PPUSH
23564: CALL_OW 88
// async ;
23568: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23569: LD_EXP 58
23573: PPUSH
23574: LD_STRING D6b-Pow-2
23576: PPUSH
23577: CALL_OW 88
// wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if tmp2 > 1 then
23588: LD_VAR 0 4
23592: PUSH
23593: LD_INT 1
23595: GREATER
23596: IFFALSE 23614
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23598: LD_VAR 0 4
23602: PUSH
23603: LD_INT 2
23605: ARRAY
23606: PPUSH
23607: LD_STRING D6b-ArSol2-1
23609: PPUSH
23610: CALL_OW 88
// sync ;
23614: SYNC
// repeat wait ( 5 ) ;
23615: LD_INT 5
23617: PPUSH
23618: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23622: LD_INT 93
23624: PPUSH
23625: LD_INT 36
23627: PPUSH
23628: CALL_OW 428
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: LD_INT 4
23640: EQUAL
23641: IFFALSE 23615
// DialogueOn ;
23643: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23647: LD_INT 10
23649: PPUSH
23650: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23654: LD_EXP 58
23658: PPUSH
23659: LD_STRING D6b-Pow-2a
23661: PPUSH
23662: CALL_OW 88
// DialogueOff ;
23666: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23670: LD_EXP 58
23674: PPUSH
23675: CALL_OW 310
23679: PPUSH
23680: LD_INT 332
23682: PPUSH
23683: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23687: LD_INT 93
23689: PPUSH
23690: LD_INT 35
23692: PPUSH
23693: LD_INT 1
23695: PPUSH
23696: LD_INT 6
23698: NEG
23699: PPUSH
23700: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23711: LD_INT 332
23713: PPUSH
23714: CALL_OW 256
23718: PUSH
23719: LD_INT 1000
23721: LESS
23722: PUSH
23723: LD_INT 332
23725: PPUSH
23726: CALL_OW 300
23730: AND
23731: IFFALSE 23743
// SetLives ( kozlov_fac , 0 ) ;
23733: LD_INT 332
23735: PPUSH
23736: LD_INT 0
23738: PPUSH
23739: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23743: LD_INT 332
23745: PPUSH
23746: CALL_OW 301
23750: PUSH
23751: LD_EXP 58
23755: PPUSH
23756: CALL_OW 301
23760: OR
23761: IFFALSE 23704
// game_speed := 4 ;
23763: LD_ADDR_OWVAR 65
23767: PUSH
23768: LD_INT 4
23770: ST_TO_ADDR
// powellCenterCameraMode := false ;
23771: LD_ADDR_EXP 20
23775: PUSH
23776: LD_INT 0
23778: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23779: LD_ADDR_VAR 0 1
23783: PUSH
23784: LD_VAR 0 3
23788: PUSH
23789: LD_INT 22
23791: PUSH
23792: LD_INT 8
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 25
23801: PUSH
23802: LD_INT 2
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: PPUSH
23813: CALL_OW 69
23817: UNION
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23836
// SetTag ( i , 0 ) ;
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 0
23829: PPUSH
23830: CALL_OW 109
23834: GO 23819
23836: POP
23837: POP
// wait ( 0 0$3 ) ;
23838: LD_INT 105
23840: PPUSH
23841: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23845: LD_INT 93
23847: PPUSH
23848: LD_INT 35
23850: PPUSH
23851: LD_INT 1
23853: PPUSH
23854: CALL_OW 331
// DialogueOn ;
23858: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23862: LD_VAR 0 11
23866: PPUSH
23867: LD_STRING D6c-Sol3-1
23869: PPUSH
23870: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23874: LD_INT 10
23876: PPUSH
23877: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23881: LD_EXP 39
23885: PPUSH
23886: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23890: LD_EXP 39
23894: PPUSH
23895: LD_STRING D6c-JMM-1
23897: PPUSH
23898: CALL_OW 88
// if Cyrus then
23902: LD_EXP 45
23906: IFFALSE 23920
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23908: LD_EXP 45
23912: PPUSH
23913: LD_STRING D6c-Cyrus-1
23915: PPUSH
23916: CALL_OW 88
// if Bobby then
23920: LD_EXP 44
23924: IFFALSE 23938
// Say ( Bobby , D6c-Bobby-1 ) ;
23926: LD_EXP 44
23930: PPUSH
23931: LD_STRING D6c-Bobby-1
23933: PPUSH
23934: CALL_OW 88
// if Cornel then
23938: LD_EXP 50
23942: IFFALSE 23956
// Say ( Cornel , D6c-Corn-1 ) ;
23944: LD_EXP 50
23948: PPUSH
23949: LD_STRING D6c-Corn-1
23951: PPUSH
23952: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 22
23966: PUSH
23967: LD_INT 1
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 22
23976: PUSH
23977: LD_INT 4
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 26
23991: PUSH
23992: LD_INT 1
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 25
24004: PUSH
24005: LD_INT 16
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 25
24014: PUSH
24015: LD_INT 12
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PPUSH
24032: CALL_OW 69
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: LD_EXP 39
24046: UNION
24047: PUSH
24048: LD_EXP 59
24052: UNION
24053: PUSH
24054: EMPTY
24055: LIST
24056: DIFF
24057: ST_TO_ADDR
// if tmp2 then
24058: LD_VAR 0 4
24062: IFFALSE 24080
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24064: LD_VAR 0 4
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_STRING D6c-Sol1-1
24075: PPUSH
24076: CALL_OW 88
// if Lisa then
24080: LD_EXP 42
24084: IFFALSE 24098
// Say ( Lisa , D6c-Lisa-1 ) ;
24086: LD_EXP 42
24090: PPUSH
24091: LD_STRING D6c-Lisa-1
24093: PPUSH
24094: CALL_OW 88
// if Gary then
24098: LD_EXP 51
24102: IFFALSE 24116
// Say ( Gary , D6c-Gary-1 ) ;
24104: LD_EXP 51
24108: PPUSH
24109: LD_STRING D6c-Gary-1
24111: PPUSH
24112: CALL_OW 88
// if Donaldson then
24116: LD_EXP 43
24120: IFFALSE 24134
// Say ( Donaldson , D6c-Don-1 ) ;
24122: LD_EXP 43
24126: PPUSH
24127: LD_STRING D6c-Don-1
24129: PPUSH
24130: CALL_OW 88
// if tmp2 > 1 then
24134: LD_VAR 0 4
24138: PUSH
24139: LD_INT 1
24141: GREATER
24142: IFFALSE 24160
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24144: LD_VAR 0 4
24148: PUSH
24149: LD_INT 2
24151: ARRAY
24152: PPUSH
24153: LD_STRING D6c-Sol2-1
24155: PPUSH
24156: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24160: LD_VAR 0 11
24164: PPUSH
24165: LD_STRING D6c-Sol3-2
24167: PPUSH
24168: CALL_OW 88
// dwait ( 0 0$1 ) ;
24172: LD_INT 35
24174: PPUSH
24175: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24179: LD_EXP 39
24183: PPUSH
24184: LD_STRING D6c-JMM-2
24186: PPUSH
24187: CALL_OW 88
// DialogueOff ;
24191: CALL_OW 7
// Video ( false ) ;
24195: LD_INT 0
24197: PPUSH
24198: CALL 107818 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24202: LD_INT 22
24204: PUSH
24205: LD_INT 4
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PPUSH
24212: CALL_OW 69
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24224: LD_INT 4
24226: PPUSH
24227: LD_INT 4
24229: PPUSH
24230: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24234: LD_ADDR_VAR 0 1
24238: PUSH
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 1
24244: PPUSH
24245: LD_INT 2
24247: PPUSH
24248: CALL 64979 0 3
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24291
// if GetTech ( i , 1 ) <> state_researched then
24256: LD_VAR 0 1
24260: PPUSH
24261: LD_INT 1
24263: PPUSH
24264: CALL_OW 321
24268: PUSH
24269: LD_INT 2
24271: NONEQUAL
24272: IFFALSE 24289
// SetTech ( i , 1 , state_researched ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_INT 1
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: CALL_OW 322
24289: GO 24253
24291: POP
24292: POP
// missionStage := 6 ;
24293: LD_ADDR_EXP 15
24297: PUSH
24298: LD_INT 6
24300: ST_TO_ADDR
// activeAttacks := true ;
24301: LD_ADDR_EXP 16
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24309: LD_STRING M2
24311: PPUSH
24312: CALL_OW 337
// SaveForQuickRestart ;
24316: CALL_OW 22
// wait ( 0 0$40 ) ;
24320: LD_INT 1400
24322: PPUSH
24323: CALL_OW 67
// DialogueOn ;
24327: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24331: LD_EXP 62
24335: PPUSH
24336: LD_STRING D7-Friend-1
24338: PPUSH
24339: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24343: LD_EXP 39
24347: PPUSH
24348: LD_STRING D7-JMM-1
24350: PPUSH
24351: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24355: LD_EXP 62
24359: PPUSH
24360: LD_STRING D7-Friend-2
24362: PPUSH
24363: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24367: LD_EXP 39
24371: PPUSH
24372: LD_STRING D7-JMM-2
24374: PPUSH
24375: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24379: LD_EXP 62
24383: PPUSH
24384: LD_STRING D7-Friend-3
24386: PPUSH
24387: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24391: LD_EXP 39
24395: PPUSH
24396: LD_STRING D7-JMM-3
24398: PPUSH
24399: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24403: LD_EXP 62
24407: PPUSH
24408: LD_STRING D7-Friend-4
24410: PPUSH
24411: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24415: LD_EXP 39
24419: PPUSH
24420: LD_STRING D7-JMM-4
24422: PPUSH
24423: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24427: LD_EXP 62
24431: PPUSH
24432: LD_STRING D7-Friend-5
24434: PPUSH
24435: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24439: LD_EXP 39
24443: PPUSH
24444: LD_STRING D7-JMM-5
24446: PPUSH
24447: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-6
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-6
24470: PPUSH
24471: CALL_OW 88
// DialogueOff ;
24475: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24479: LD_STRING Mlegion
24481: PPUSH
24482: CALL_OW 337
// RebuildKozlovFactory ;
24486: CALL 4840 0 0
// end ;
24490: PPOPN 13
24492: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24493: LD_EXP 20
24497: PUSH
24498: LD_EXP 58
24502: PPUSH
24503: CALL_OW 300
24507: AND
24508: IFFALSE 24550
24510: GO 24512
24512: DISABLE
// begin enable ;
24513: ENABLE
// if IsInUnit ( Powell ) then
24514: LD_EXP 58
24518: PPUSH
24519: CALL_OW 310
24523: IFFALSE 24541
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24525: LD_EXP 58
24529: PPUSH
24530: CALL_OW 310
24534: PPUSH
24535: CALL_OW 85
24539: GO 24550
// CenterOnUnits ( Powell ) ;
24541: LD_EXP 58
24545: PPUSH
24546: CALL_OW 85
// end ;
24550: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24551: LD_INT 22
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 34
24563: PUSH
24564: LD_INT 48
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 69
24579: IFFALSE 24853
24581: GO 24583
24583: DISABLE
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
// begin if missionStage < 9 then
24588: LD_EXP 15
24592: PUSH
24593: LD_INT 9
24595: LESS
24596: IFFALSE 24606
// missionStage := 9 ;
24598: LD_ADDR_EXP 15
24602: PUSH
24603: LD_INT 9
24605: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 34
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PPUSH
24635: CALL_OW 69
24639: PUSH
24640: LD_INT 1
24642: ARRAY
24643: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24644: LD_INT 175
24646: PPUSH
24647: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24651: LD_EXP 12
24655: PUSH
24656: LD_EXP 3
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: LD_INT 2
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: IN
24671: OR
24672: IFFALSE 24695
// target := [ 68 , 108 , 1 ] else
24674: LD_ADDR_VAR 0 2
24678: PUSH
24679: LD_INT 68
24681: PUSH
24682: LD_INT 108
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: ST_TO_ADDR
24693: GO 24714
// target := [ 181 , 88 , 2 ] ;
24695: LD_ADDR_VAR 0 2
24699: PUSH
24700: LD_INT 181
24702: PUSH
24703: LD_INT 88
24705: PUSH
24706: LD_INT 2
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: LIST
24713: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_VAR 0 2
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 176
// if target [ 3 ] = 1 then
24741: LD_VAR 0 2
24745: PUSH
24746: LD_INT 3
24748: ARRAY
24749: PUSH
24750: LD_INT 1
24752: EQUAL
24753: IFFALSE 24769
// SayRadio ( Kurt , D12-Kurt-1 ) else
24755: LD_EXP 60
24759: PPUSH
24760: LD_STRING D12-Kurt-1
24762: PPUSH
24763: CALL_OW 94
24767: GO 24793
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24769: LD_EXP 60
24773: PPUSH
24774: LD_STRING D12a-Kurt-1
24776: PPUSH
24777: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24781: LD_EXP 74
24785: PPUSH
24786: LD_STRING D12a-Roth-1
24788: PPUSH
24789: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24793: LD_INT 350
24795: PPUSH
24796: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24800: LD_VAR 0 1
24804: PPUSH
24805: LD_INT 22
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 23
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 30
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: PUSH
24845: LD_INT 1
24847: ARRAY
24848: PPUSH
24849: CALL_OW 228
// end ;
24853: PPOPN 2
24855: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 999
24868: LESS
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 8
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 23
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 9
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: LD_INT 7
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: LD_OWVAR 67
24928: ARRAY
24929: LESSEQUAL
24930: OR
24931: PUSH
24932: LD_INT 22
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 34
24944: PUSH
24945: LD_INT 48
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: NOT
24961: AND
24962: PUSH
24963: LD_EXP 60
24967: PPUSH
24968: CALL_OW 302
24972: AND
24973: PUSH
24974: LD_INT 5
24976: PPUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 1
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 70
24991: AND
24992: IFFALSE 25697
24994: GO 24996
24996: DISABLE
24997: LD_INT 0
24999: PPUSH
25000: PPUSH
25001: PPUSH
// begin DialogueOn ;
25002: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25006: LD_EXP 39
25010: PPUSH
25011: LD_STRING D13-JMM-1
25013: PPUSH
25014: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25018: LD_EXP 60
25022: PPUSH
25023: LD_STRING D13-Kurt-1
25025: PPUSH
25026: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25030: LD_EXP 39
25034: PPUSH
25035: LD_STRING D13-JMM-2
25037: PPUSH
25038: CALL_OW 88
// if FakeInfo then
25042: LD_EXP 12
25046: IFFALSE 25066
// begin Say ( Kurt , D13-Kurt-2 ) ;
25048: LD_EXP 60
25052: PPUSH
25053: LD_STRING D13-Kurt-2
25055: PPUSH
25056: CALL_OW 88
// DialogueOff ;
25060: CALL_OW 7
// exit ;
25064: GO 25697
// end ; if not KurtStatus then
25066: LD_EXP 3
25070: NOT
25071: IFFALSE 25087
// Say ( Kurt , D13-Kurt-2b ) else
25073: LD_EXP 60
25077: PPUSH
25078: LD_STRING D13-Kurt-2b
25080: PPUSH
25081: CALL_OW 88
25085: GO 25099
// Say ( Kurt , D13-Kurt-2a ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_STRING D13-Kurt-2a
25094: PPUSH
25095: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25099: LD_EXP 39
25103: PPUSH
25104: LD_STRING D13-JMM-3
25106: PPUSH
25107: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25111: LD_EXP 60
25115: PPUSH
25116: LD_STRING D13-Kurt-3
25118: PPUSH
25119: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25123: LD_EXP 39
25127: PPUSH
25128: LD_STRING D13-JMM-4
25130: PPUSH
25131: CALL_OW 88
// DialogueOff ;
25135: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25139: LD_STRING MlegionOut
25141: PPUSH
25142: CALL_OW 337
// legionDestroyed := true ;
25146: LD_ADDR_EXP 22
25150: PUSH
25151: LD_INT 1
25153: ST_TO_ADDR
// MC_Kill ( 3 ) ;
25154: LD_INT 3
25156: PPUSH
25157: CALL 35112 0 1
// KillUnit ( Kozlov ) ;
25161: LD_EXP 61
25165: PPUSH
25166: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25170: LD_ADDR_VAR 0 1
25174: PUSH
25175: LD_INT 22
25177: PUSH
25178: LD_INT 8
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PUSH
25185: LD_INT 23
25187: PUSH
25188: LD_INT 3
25190: PUSH
25191: EMPTY
25192: LIST
25193: LIST
25194: PUSH
25195: LD_INT 3
25197: PUSH
25198: LD_INT 21
25200: PUSH
25201: LD_INT 33
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: LIST
25216: PPUSH
25217: CALL_OW 69
25221: PUSH
25222: FOR_IN
25223: IFFALSE 25236
// KillUnit ( i ) ;
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 66
25234: GO 25222
25236: POP
25237: POP
// ChangeSideFog ( 8 , 1 ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25248: LD_ADDR_VAR 0 2
25252: PUSH
25253: LD_INT 22
25255: PUSH
25256: LD_INT 8
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 21
25265: PUSH
25266: LD_INT 1
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: EMPTY
25274: LIST
25275: LIST
25276: PPUSH
25277: CALL_OW 69
25281: PUSH
25282: LD_EXP 61
25286: PUSH
25287: LD_EXP 60
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: DIFF
25296: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25297: LD_VAR 0 2
25301: PUSH
25302: LD_INT 6
25304: PUSH
25305: LD_INT 5
25307: PUSH
25308: LD_INT 4
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: LIST
25315: PUSH
25316: LD_OWVAR 67
25320: ARRAY
25321: GREATEREQUAL
25322: IFFALSE 25496
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25324: LD_ADDR_VAR 0 3
25328: PUSH
25329: LD_INT 6
25331: PUSH
25332: LD_INT 5
25334: PUSH
25335: LD_INT 4
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: LIST
25342: PUSH
25343: LD_OWVAR 67
25347: ARRAY
25348: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25349: LD_ADDR_VAR 0 1
25353: PUSH
25354: DOUBLE
25355: LD_VAR 0 2
25359: PUSH
25360: LD_VAR 0 3
25364: PUSH
25365: LD_INT 1
25367: PLUS
25368: MINUS
25369: INC
25370: ST_TO_ADDR
25371: LD_INT 1
25373: PUSH
25374: FOR_DOWNTO
25375: IFFALSE 25492
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25377: LD_ADDR_EXP 38
25381: PUSH
25382: LD_EXP 38
25386: PUSH
25387: LD_VAR 0 2
25391: PUSH
25392: LD_VAR 0 1
25396: ARRAY
25397: ADD
25398: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25399: LD_VAR 0 2
25403: PUSH
25404: LD_VAR 0 1
25408: ARRAY
25409: PPUSH
25410: CALL_OW 310
25414: IFFALSE 25431
// ComExitBuilding ( tmp [ i ] ) ;
25416: LD_VAR 0 2
25420: PUSH
25421: LD_VAR 0 1
25425: ARRAY
25426: PPUSH
25427: CALL_OW 122
// if IsInUnit ( i ) then
25431: LD_VAR 0 1
25435: PPUSH
25436: CALL_OW 310
25440: IFFALSE 25457
// ComExitVehicle ( tmp [ i ] ) ;
25442: LD_VAR 0 2
25446: PUSH
25447: LD_VAR 0 1
25451: ARRAY
25452: PPUSH
25453: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25457: LD_VAR 0 2
25461: PUSH
25462: LD_VAR 0 1
25466: ARRAY
25467: PPUSH
25468: LD_INT 34
25470: PUSH
25471: LD_INT 0
25473: PPUSH
25474: LD_INT 6
25476: PPUSH
25477: CALL_OW 12
25481: PLUS
25482: PPUSH
25483: LD_INT 1
25485: PPUSH
25486: CALL_OW 171
// end ;
25490: GO 25374
25492: POP
25493: POP
// end else
25494: GO 25506
// x := tmp ;
25496: LD_ADDR_VAR 0 3
25500: PUSH
25501: LD_VAR 0 2
25505: ST_TO_ADDR
// for i := tmp downto tmp - x do
25506: LD_ADDR_VAR 0 1
25510: PUSH
25511: DOUBLE
25512: LD_VAR 0 2
25516: INC
25517: ST_TO_ADDR
25518: LD_VAR 0 2
25522: PUSH
25523: LD_VAR 0 3
25527: MINUS
25528: PUSH
25529: FOR_DOWNTO
25530: IFFALSE 25584
// begin if IsInUnit ( tmp [ i ] ) then
25532: LD_VAR 0 2
25536: PUSH
25537: LD_VAR 0 1
25541: ARRAY
25542: PPUSH
25543: CALL_OW 310
25547: IFFALSE 25564
// ComExitVehicle ( tmp [ i ] ) ;
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: LD_INT 1
25577: PPUSH
25578: CALL_OW 235
// end ;
25582: GO 25529
25584: POP
25585: POP
// SetSide ( Kurt , 1 ) ;
25586: LD_EXP 60
25590: PPUSH
25591: LD_INT 1
25593: PPUSH
25594: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25598: LD_INT 22
25600: PUSH
25601: LD_INT 8
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 21
25610: PUSH
25611: LD_INT 3
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PPUSH
25622: CALL_OW 69
25626: PPUSH
25627: LD_INT 1
25629: PPUSH
25630: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25634: LD_INT 8
25636: PPUSH
25637: LD_INT 1
25639: PPUSH
25640: LD_INT 1
25642: PPUSH
25643: LD_INT 1
25645: PPUSH
25646: CALL_OW 80
// wait ( 1 1$20 ) ;
25650: LD_INT 2800
25652: PPUSH
25653: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25657: LD_EXP 62
25661: PPUSH
25662: LD_INT 37
25664: PPUSH
25665: LD_INT 1
25667: PPUSH
25668: LD_INT 0
25670: PPUSH
25671: CALL_OW 48
// wait ( 0 0$1 ) ;
25675: LD_INT 35
25677: PPUSH
25678: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25682: LD_EXP 62
25686: PPUSH
25687: LD_INT 60
25689: PPUSH
25690: LD_INT 95
25692: PPUSH
25693: CALL_OW 111
// end ;
25697: PPOPN 3
25699: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25700: LD_EXP 22
25704: NOT
25705: PUSH
25706: LD_INT 22
25708: PUSH
25709: LD_INT 8
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 21
25718: PUSH
25719: LD_INT 1
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PPUSH
25730: CALL_OW 69
25734: PUSH
25735: LD_INT 0
25737: EQUAL
25738: AND
25739: IFFALSE 25759
25741: GO 25743
25743: DISABLE
// begin legionDestroyed := true ;
25744: LD_ADDR_EXP 22
25748: PUSH
25749: LD_INT 1
25751: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25752: LD_STRING MlegionOut
25754: PPUSH
25755: CALL_OW 337
// end ;
25759: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25760: LD_EXP 38
25764: IFFALSE 25839
25766: GO 25768
25768: DISABLE
25769: LD_INT 0
25771: PPUSH
// begin enable ;
25772: ENABLE
// for i in legionEscapeUnits do
25773: LD_ADDR_VAR 0 1
25777: PUSH
25778: LD_EXP 38
25782: PUSH
25783: FOR_IN
25784: IFFALSE 25837
// begin if IsInArea ( i , legionEscapeArea ) then
25786: LD_VAR 0 1
25790: PPUSH
25791: LD_INT 31
25793: PPUSH
25794: CALL_OW 308
25798: IFFALSE 25811
// RemoveUnit ( i ) else
25800: LD_VAR 0 1
25804: PPUSH
25805: CALL_OW 64
25809: GO 25835
// if not HasTask ( i ) then
25811: LD_VAR 0 1
25815: PPUSH
25816: CALL_OW 314
25820: NOT
25821: IFFALSE 25835
// ComMoveToArea ( i , legionEscapeArea ) ;
25823: LD_VAR 0 1
25827: PPUSH
25828: LD_INT 31
25830: PPUSH
25831: CALL_OW 113
// end ;
25835: GO 25783
25837: POP
25838: POP
// end ;
25839: PPOPN 1
25841: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25842: LD_INT 1
25844: PPUSH
25845: LD_EXP 62
25849: PPUSH
25850: CALL_OW 292
25854: IFFALSE 26152
25856: GO 25858
25858: DISABLE
25859: LD_INT 0
25861: PPUSH
// begin wait ( 0 0$2 ) ;
25862: LD_INT 70
25864: PPUSH
25865: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25869: LD_EXP 62
25873: PPUSH
25874: CALL_OW 87
// DialogueOn ;
25878: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25882: LD_EXP 39
25886: PPUSH
25887: LD_STRING D14-JMM-1
25889: PPUSH
25890: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25894: LD_EXP 62
25898: PPUSH
25899: LD_STRING D14-Friend-1
25901: PPUSH
25902: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25906: LD_EXP 39
25910: PPUSH
25911: LD_STRING D14-JMM-2
25913: PPUSH
25914: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25918: LD_EXP 62
25922: PPUSH
25923: LD_STRING D14-Friend-2
25925: PPUSH
25926: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25930: LD_EXP 39
25934: PPUSH
25935: LD_STRING D14-JMM-3
25937: PPUSH
25938: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25942: LD_EXP 62
25946: PPUSH
25947: LD_STRING D14-Friend-3
25949: PPUSH
25950: CALL_OW 88
// DialogueOff ;
25954: CALL_OW 7
// dec = Query ( Q14 ) ;
25958: LD_ADDR_VAR 0 1
25962: PUSH
25963: LD_STRING Q14
25965: PPUSH
25966: CALL_OW 97
25970: ST_TO_ADDR
// if dec = 1 then
25971: LD_VAR 0 1
25975: PUSH
25976: LD_INT 1
25978: EQUAL
25979: IFFALSE 26013
// begin DialogueOn ;
25981: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25985: LD_EXP 39
25989: PPUSH
25990: LD_STRING D14a-JMM-1
25992: PPUSH
25993: CALL_OW 88
// DialogueOff ;
25997: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26001: LD_EXP 62
26005: PPUSH
26006: LD_INT 1
26008: PPUSH
26009: CALL_OW 235
// end ; if dec = 2 then
26013: LD_VAR 0 1
26017: PUSH
26018: LD_INT 2
26020: EQUAL
26021: IFFALSE 26074
// begin DialogueOn ;
26023: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26027: LD_EXP 39
26031: PPUSH
26032: LD_STRING D14b-JMM-1
26034: PPUSH
26035: CALL_OW 88
// DialogueOff ;
26039: CALL_OW 7
// wait ( 0 0$1 ) ;
26043: LD_INT 35
26045: PPUSH
26046: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26050: LD_EXP 62
26054: PPUSH
26055: LD_INT 9
26057: PPUSH
26058: LD_INT 2
26060: PPUSH
26061: CALL_OW 111
// AddComHold ( Friend ) ;
26065: LD_EXP 62
26069: PPUSH
26070: CALL_OW 200
// end ; if dec = 3 then
26074: LD_VAR 0 1
26078: PUSH
26079: LD_INT 3
26081: EQUAL
26082: IFFALSE 26152
// begin DialogueOn ;
26084: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26088: LD_EXP 39
26092: PPUSH
26093: LD_STRING D14c-JMM-1
26095: PPUSH
26096: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26100: LD_EXP 62
26104: PPUSH
26105: LD_STRING D14c-Friend-1
26107: PPUSH
26108: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26112: LD_EXP 39
26116: PPUSH
26117: LD_STRING D14c-JMM-2
26119: PPUSH
26120: CALL_OW 88
// DialogueOff ;
26124: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26128: LD_EXP 62
26132: PPUSH
26133: LD_INT 9
26135: PPUSH
26136: LD_INT 2
26138: PPUSH
26139: CALL_OW 111
// AddComHold ( Friend ) ;
26143: LD_EXP 62
26147: PPUSH
26148: CALL_OW 200
// end ; end ;
26152: PPOPN 1
26154: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26155: LD_INT 9
26157: PPUSH
26158: LD_INT 2
26160: PPUSH
26161: CALL_OW 428
26165: PUSH
26166: LD_EXP 62
26170: EQUAL
26171: PUSH
26172: LD_EXP 62
26176: PPUSH
26177: CALL_OW 255
26181: PUSH
26182: LD_INT 8
26184: EQUAL
26185: AND
26186: IFFALSE 26200
26188: GO 26190
26190: DISABLE
// RemoveUnit ( Friend ) ;
26191: LD_EXP 62
26195: PPUSH
26196: CALL_OW 64
26200: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26201: LD_EXP 14
26205: PUSH
26206: LD_INT 31500
26208: GREATEREQUAL
26209: PUSH
26210: LD_EXP 7
26214: AND
26215: PUSH
26216: LD_EXP 2
26220: AND
26221: IFFALSE 26651
26223: GO 26225
26225: DISABLE
26226: LD_INT 0
26228: PPUSH
26229: PPUSH
26230: PPUSH
// begin missionStage := 7 ;
26231: LD_ADDR_EXP 15
26235: PUSH
26236: LD_INT 7
26238: ST_TO_ADDR
// uc_side = 1 ;
26239: LD_ADDR_OWVAR 20
26243: PUSH
26244: LD_INT 1
26246: ST_TO_ADDR
// uc_nation = 1 ;
26247: LD_ADDR_OWVAR 21
26251: PUSH
26252: LD_INT 1
26254: ST_TO_ADDR
// for i = 1 to 5 do
26255: LD_ADDR_VAR 0 1
26259: PUSH
26260: DOUBLE
26261: LD_INT 1
26263: DEC
26264: ST_TO_ADDR
26265: LD_INT 5
26267: PUSH
26268: FOR_TO
26269: IFFALSE 26365
// begin vc_engine = 3 ;
26271: LD_ADDR_OWVAR 39
26275: PUSH
26276: LD_INT 3
26278: ST_TO_ADDR
// vc_control = 3 ;
26279: LD_ADDR_OWVAR 38
26283: PUSH
26284: LD_INT 3
26286: ST_TO_ADDR
// vc_chassis = 3 ;
26287: LD_ADDR_OWVAR 37
26291: PUSH
26292: LD_INT 3
26294: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26295: LD_ADDR_OWVAR 40
26299: PUSH
26300: LD_INT 5
26302: PUSH
26303: LD_INT 9
26305: PUSH
26306: LD_INT 7
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 1
26316: PPUSH
26317: LD_INT 3
26319: PPUSH
26320: CALL_OW 12
26324: ARRAY
26325: ST_TO_ADDR
// veh = CreateVehicle ;
26326: LD_ADDR_VAR 0 2
26330: PUSH
26331: CALL_OW 45
26335: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26336: LD_VAR 0 2
26340: PPUSH
26341: LD_INT 1
26343: PPUSH
26344: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26348: LD_VAR 0 2
26352: PPUSH
26353: LD_INT 19
26355: PPUSH
26356: LD_INT 0
26358: PPUSH
26359: CALL_OW 49
// end ;
26363: GO 26268
26365: POP
26366: POP
// vc_engine = 3 ;
26367: LD_ADDR_OWVAR 39
26371: PUSH
26372: LD_INT 3
26374: ST_TO_ADDR
// vc_control = 1 ;
26375: LD_ADDR_OWVAR 38
26379: PUSH
26380: LD_INT 1
26382: ST_TO_ADDR
// vc_chassis = 3 ;
26383: LD_ADDR_OWVAR 37
26387: PUSH
26388: LD_INT 3
26390: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26391: LD_ADDR_OWVAR 40
26395: PUSH
26396: LD_INT 5
26398: PUSH
26399: LD_INT 9
26401: PUSH
26402: LD_INT 7
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 1
26412: PPUSH
26413: LD_INT 3
26415: PPUSH
26416: CALL_OW 12
26420: ARRAY
26421: ST_TO_ADDR
// vehG = CreateVehicle ;
26422: LD_ADDR_VAR 0 3
26426: PUSH
26427: CALL_OW 45
26431: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26432: LD_VAR 0 3
26436: PPUSH
26437: LD_INT 1
26439: PPUSH
26440: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26444: LD_VAR 0 3
26448: PPUSH
26449: LD_INT 19
26451: PPUSH
26452: LD_INT 0
26454: PPUSH
26455: CALL_OW 49
// if JMMGirl = 1 then
26459: LD_EXP 7
26463: PUSH
26464: LD_INT 1
26466: EQUAL
26467: IFFALSE 26523
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26469: LD_ADDR_EXP 40
26473: PUSH
26474: LD_STRING Joan
26476: PPUSH
26477: LD_INT 1
26479: PPUSH
26480: LD_STRING 14_
26482: PPUSH
26483: CALL 64916 0 3
26487: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26488: LD_EXP 40
26492: PPUSH
26493: LD_VAR 0 3
26497: PPUSH
26498: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26502: LD_VAR 0 3
26506: PPUSH
26507: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26511: LD_EXP 40
26515: PPUSH
26516: LD_STRING D10BW-Joan-1
26518: PPUSH
26519: CALL_OW 94
// end ; if JMMGirl = 2 then
26523: LD_EXP 7
26527: PUSH
26528: LD_INT 2
26530: EQUAL
26531: IFFALSE 26587
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26533: LD_ADDR_EXP 42
26537: PUSH
26538: LD_STRING Lisa
26540: PPUSH
26541: LD_INT 1
26543: PPUSH
26544: LD_STRING 14_
26546: PPUSH
26547: CALL 64916 0 3
26551: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26552: LD_EXP 42
26556: PPUSH
26557: LD_VAR 0 3
26561: PPUSH
26562: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26566: LD_VAR 0 3
26570: PPUSH
26571: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26575: LD_EXP 42
26579: PPUSH
26580: LD_STRING D10BW-Lisa-1
26582: PPUSH
26583: CALL_OW 94
// end ; if JMMGirl = 3 then
26587: LD_EXP 7
26591: PUSH
26592: LD_INT 3
26594: EQUAL
26595: IFFALSE 26651
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26597: LD_ADDR_EXP 54
26601: PUSH
26602: LD_STRING Connie
26604: PPUSH
26605: LD_INT 1
26607: PPUSH
26608: LD_STRING 14_
26610: PPUSH
26611: CALL 64916 0 3
26615: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26616: LD_EXP 54
26620: PPUSH
26621: LD_VAR 0 3
26625: PPUSH
26626: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26630: LD_VAR 0 3
26634: PPUSH
26635: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26639: LD_EXP 54
26643: PPUSH
26644: LD_STRING D10BW-Con-1
26646: PPUSH
26647: CALL_OW 94
// end ; end ;
26651: PPOPN 3
26653: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26654: LD_EXP 14
26658: PUSH
26659: LD_INT 94500
26661: GREATEREQUAL
26662: IFFALSE 27074
26664: GO 26666
26666: DISABLE
26667: LD_INT 0
26669: PPUSH
26670: PPUSH
26671: PPUSH
// begin tmp := PrepareStevensSquad ;
26672: LD_ADDR_VAR 0 3
26676: PUSH
26677: CALL 2197 0 0
26681: ST_TO_ADDR
// if not tmp then
26682: LD_VAR 0 3
26686: NOT
26687: IFFALSE 26691
// exit ;
26689: GO 27074
// uc_side := 1 ;
26691: LD_ADDR_OWVAR 20
26695: PUSH
26696: LD_INT 1
26698: ST_TO_ADDR
// uc_nation := 1 ;
26699: LD_ADDR_OWVAR 21
26703: PUSH
26704: LD_INT 1
26706: ST_TO_ADDR
// for i in tmp do
26707: LD_ADDR_VAR 0 1
26711: PUSH
26712: LD_VAR 0 3
26716: PUSH
26717: FOR_IN
26718: IFFALSE 26815
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26720: LD_INT 3
26722: PPUSH
26723: LD_INT 3
26725: PPUSH
26726: LD_INT 1
26728: PPUSH
26729: LD_INT 5
26731: PUSH
26732: LD_INT 9
26734: PUSH
26735: LD_INT 7
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: LIST
26742: PUSH
26743: LD_INT 1
26745: PPUSH
26746: LD_INT 3
26748: PPUSH
26749: CALL_OW 12
26753: ARRAY
26754: PPUSH
26755: LD_INT 40
26757: PPUSH
26758: CALL 72091 0 5
// veh := CreateVehicle ;
26762: LD_ADDR_VAR 0 2
26766: PUSH
26767: CALL_OW 45
26771: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26772: LD_VAR 0 2
26776: PPUSH
26777: LD_INT 1
26779: PPUSH
26780: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26784: LD_VAR 0 2
26788: PPUSH
26789: LD_INT 19
26791: PPUSH
26792: LD_INT 0
26794: PPUSH
26795: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26799: LD_VAR 0 1
26803: PPUSH
26804: LD_VAR 0 2
26808: PPUSH
26809: CALL_OW 52
// end ;
26813: GO 26717
26815: POP
26816: POP
// missionStage := 8 ;
26817: LD_ADDR_EXP 15
26821: PUSH
26822: LD_INT 8
26824: ST_TO_ADDR
// DialogueOn ;
26825: CALL_OW 6
// if Stevens then
26829: LD_EXP 41
26833: IFFALSE 26947
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26835: LD_EXP 41
26839: PPUSH
26840: CALL_OW 310
26844: PPUSH
26845: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26849: LD_EXP 41
26853: PPUSH
26854: LD_STRING D8-Huck-1
26856: PPUSH
26857: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26861: LD_EXP 39
26865: PPUSH
26866: LD_STRING D8-JMM-1
26868: PPUSH
26869: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26873: LD_EXP 41
26877: PPUSH
26878: LD_STRING D8-Huck-2
26880: PPUSH
26881: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26885: LD_EXP 39
26889: PPUSH
26890: LD_STRING D8-JMM-2
26892: PPUSH
26893: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26897: LD_EXP 41
26901: PPUSH
26902: LD_STRING D8-Huck-3
26904: PPUSH
26905: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26909: LD_EXP 39
26913: PPUSH
26914: LD_STRING D8-JMM-3
26916: PPUSH
26917: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26921: LD_EXP 41
26925: PPUSH
26926: LD_STRING D8-Huck-4
26928: PPUSH
26929: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26933: LD_EXP 39
26937: PPUSH
26938: LD_STRING D8-JMM-4
26940: PPUSH
26941: CALL_OW 88
// end else
26945: GO 27057
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26947: LD_EXP 55
26951: PPUSH
26952: CALL_OW 310
26956: PPUSH
26957: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26961: LD_EXP 55
26965: PPUSH
26966: LD_STRING D8-Huck-1
26968: PPUSH
26969: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26973: LD_EXP 39
26977: PPUSH
26978: LD_STRING D8-JMM-1a
26980: PPUSH
26981: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26985: LD_EXP 55
26989: PPUSH
26990: LD_STRING D8-Huck-2
26992: PPUSH
26993: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26997: LD_EXP 39
27001: PPUSH
27002: LD_STRING D8-JMM-2
27004: PPUSH
27005: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27009: LD_EXP 55
27013: PPUSH
27014: LD_STRING D8-Huck-3
27016: PPUSH
27017: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27021: LD_EXP 39
27025: PPUSH
27026: LD_STRING D8-JMM-3
27028: PPUSH
27029: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27033: LD_EXP 55
27037: PPUSH
27038: LD_STRING D8-Huck-4
27040: PPUSH
27041: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27045: LD_EXP 39
27049: PPUSH
27050: LD_STRING D8-JMM-4
27052: PPUSH
27053: CALL_OW 88
// end ; DialogueOff ;
27057: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27061: LD_INT 25
27063: PPUSH
27064: LD_INT 1
27066: PPUSH
27067: LD_INT 1
27069: PPUSH
27070: CALL_OW 322
// end ;
27074: PPOPN 3
27076: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27077: LD_INT 1
27079: PPUSH
27080: LD_EXP 71
27084: PPUSH
27085: CALL_OW 292
27089: IFFALSE 27340
27091: GO 27093
27093: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27094: LD_EXP 71
27098: PPUSH
27099: CALL_OW 87
// DialogueOn ;
27103: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27107: LD_EXP 39
27111: PPUSH
27112: LD_STRING D10nB-JMM-1
27114: PPUSH
27115: CALL_OW 88
// if BurlakStatus = 1 then
27119: LD_EXP 9
27123: PUSH
27124: LD_INT 1
27126: EQUAL
27127: IFFALSE 27141
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27129: LD_EXP 70
27133: PPUSH
27134: LD_STRING D10nB-Vse-1a
27136: PPUSH
27137: CALL_OW 94
// end ; if BurlakStatus = 0 then
27141: LD_EXP 9
27145: PUSH
27146: LD_INT 0
27148: EQUAL
27149: IFFALSE 27163
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27151: LD_EXP 70
27155: PPUSH
27156: LD_STRING D10nB-Vse-1
27158: PPUSH
27159: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27163: LD_EXP 39
27167: PPUSH
27168: LD_STRING D10nB-JMM-2
27170: PPUSH
27171: CALL_OW 88
// if KappaStatus then
27175: LD_EXP 2
27179: IFFALSE 27193
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27181: LD_EXP 70
27185: PPUSH
27186: LD_STRING D10nB-Vse-5a
27188: PPUSH
27189: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27193: LD_EXP 2
27197: NOT
27198: PUSH
27199: LD_EXP 6
27203: PUSH
27204: LD_INT 0
27206: EQUAL
27207: AND
27208: IFFALSE 27336
// begin if JMMGirl = 1 then
27210: LD_EXP 7
27214: PUSH
27215: LD_INT 1
27217: EQUAL
27218: IFFALSE 27268
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27220: LD_EXP 70
27224: PPUSH
27225: LD_STRING D10nB-Vse-2
27227: PPUSH
27228: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27232: LD_EXP 39
27236: PPUSH
27237: LD_STRING D10nB-JMM-3
27239: PPUSH
27240: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27244: LD_EXP 70
27248: PPUSH
27249: LD_STRING D10nB-Vse-3
27251: PPUSH
27252: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27256: LD_EXP 39
27260: PPUSH
27261: LD_STRING D10nB-JMM-4
27263: PPUSH
27264: CALL_OW 88
// end ; if JMMGirl = 2 then
27268: LD_EXP 7
27272: PUSH
27273: LD_INT 2
27275: EQUAL
27276: IFFALSE 27302
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27278: LD_EXP 70
27282: PPUSH
27283: LD_STRING D10nB-Vse-4
27285: PPUSH
27286: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27290: LD_EXP 39
27294: PPUSH
27295: LD_STRING D10nB-JMM-5
27297: PPUSH
27298: CALL_OW 88
// end ; if JMMGirl = 3 then
27302: LD_EXP 7
27306: PUSH
27307: LD_INT 3
27309: EQUAL
27310: IFFALSE 27336
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27312: LD_EXP 70
27316: PPUSH
27317: LD_STRING D10nB-Vse-5
27319: PPUSH
27320: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27324: LD_EXP 39
27328: PPUSH
27329: LD_STRING D10nB-JMM-6
27331: PPUSH
27332: CALL_OW 88
// end ; end ; DialogueOff ;
27336: CALL_OW 7
// end ;
27340: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27341: LD_EXP 14
27345: PUSH
27346: LD_INT 115500
27348: GREATEREQUAL
27349: IFFALSE 27725
27351: GO 27353
27353: DISABLE
27354: LD_INT 0
27356: PPUSH
// begin missionStage := 10 ;
27357: LD_ADDR_EXP 15
27361: PUSH
27362: LD_INT 10
27364: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27365: LD_ADDR_VAR 0 1
27369: PUSH
27370: LD_INT 22
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 23
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 26
27392: PUSH
27393: LD_INT 1
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: LD_INT 3
27402: PUSH
27403: LD_INT 25
27405: PUSH
27406: LD_INT 12
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 3
27419: PUSH
27420: LD_INT 25
27422: PUSH
27423: LD_INT 16
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: LIST
27440: PPUSH
27441: CALL_OW 69
27445: PUSH
27446: LD_EXP 39
27450: PUSH
27451: LD_EXP 60
27455: PUSH
27456: LD_EXP 41
27460: PUSH
27461: LD_EXP 55
27465: PUSH
27466: LD_EXP 42
27470: PUSH
27471: LD_EXP 43
27475: PUSH
27476: LD_EXP 44
27480: PUSH
27481: LD_EXP 45
27485: PUSH
27486: LD_EXP 46
27490: PUSH
27491: LD_EXP 47
27495: PUSH
27496: LD_EXP 48
27500: PUSH
27501: LD_EXP 49
27505: PUSH
27506: LD_EXP 50
27510: PUSH
27511: LD_EXP 51
27515: PUSH
27516: LD_EXP 52
27520: PUSH
27521: LD_EXP 53
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: DIFF
27544: ST_TO_ADDR
// if not tmp and Brown then
27545: LD_VAR 0 1
27549: NOT
27550: PUSH
27551: LD_EXP 47
27555: AND
27556: IFFALSE 27571
// tmp := [ Brown ] ;
27558: LD_ADDR_VAR 0 1
27562: PUSH
27563: LD_EXP 47
27567: PUSH
27568: EMPTY
27569: LIST
27570: ST_TO_ADDR
// DialogueOn ;
27571: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27575: LD_VAR 0 1
27579: PUSH
27580: LD_INT 1
27582: ARRAY
27583: PPUSH
27584: LD_STRING D11-Sol1-1
27586: PPUSH
27587: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27591: LD_EXP 64
27595: PPUSH
27596: LD_STRING D11-Pla-1
27598: PPUSH
27599: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27603: LD_EXP 65
27607: PPUSH
27608: LD_STRING D11-Kov-1
27610: PPUSH
27611: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27615: LD_EXP 64
27619: PPUSH
27620: LD_STRING D11-Pla-2
27622: PPUSH
27623: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27627: LD_VAR 0 1
27631: PUSH
27632: LD_INT 1
27634: ARRAY
27635: PPUSH
27636: LD_STRING D11-Sol1-2
27638: PPUSH
27639: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27643: LD_EXP 39
27647: PPUSH
27648: LD_STRING D11-JMM-2
27650: PPUSH
27651: CALL_OW 88
// DialogueOff ;
27655: CALL_OW 7
// allowBehemothConstruct := true ;
27659: LD_ADDR_EXP 25
27663: PUSH
27664: LD_INT 1
27666: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27667: LD_STRING M4
27669: PPUSH
27670: CALL_OW 337
// BuildBehemoths ;
27674: CALL 7653 0 0
// repeat wait ( 15 15$00 ) ;
27678: LD_INT 31500
27680: PPUSH
27681: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27685: LD_EXP 27
27689: IFFALSE 27693
// break ;
27691: GO 27725
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27693: LD_INT 267
27695: PPUSH
27696: CALL_OW 274
27700: PPUSH
27701: LD_INT 1
27703: PPUSH
27704: CALL_OW 275
27708: PUSH
27709: LD_INT 1000
27711: GREATEREQUAL
27712: IFFALSE 27718
// BuildBehemoths ;
27714: CALL 7653 0 0
// until not behemothBuilders ;
27718: LD_EXP 73
27722: NOT
27723: IFFALSE 27678
// end ;
27725: PPOPN 1
27727: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27728: LD_EXP 73
27732: NOT
27733: PUSH
27734: LD_EXP 28
27738: NOT
27739: AND
27740: PUSH
27741: LD_EXP 25
27745: AND
27746: IFFALSE 27766
27748: GO 27750
27750: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27751: LD_STRING M4a
27753: PPUSH
27754: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27758: LD_ADDR_EXP 27
27762: PUSH
27763: LD_INT 1
27765: ST_TO_ADDR
// end ;
27766: END
// every 0 0$1 trigger behemothDone do
27767: LD_EXP 28
27771: IFFALSE 27783
27773: GO 27775
27775: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27776: LD_STRING M4b
27778: PPUSH
27779: CALL_OW 337
27783: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27784: LD_EXP 29
27788: NOT
27789: IFFALSE 27985
27791: GO 27793
27793: DISABLE
27794: LD_INT 0
27796: PPUSH
27797: PPUSH
// begin enable ;
27798: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27799: LD_ADDR_VAR 0 1
27803: PUSH
27804: LD_INT 3
27806: PPUSH
27807: CALL 107894 0 1
27811: ST_TO_ADDR
// if not tmp and not behemothDone then
27812: LD_VAR 0 1
27816: NOT
27817: PUSH
27818: LD_EXP 28
27822: NOT
27823: AND
27824: IFFALSE 27860
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27826: LD_ADDR_VAR 0 1
27830: PUSH
27831: LD_INT 22
27833: PUSH
27834: LD_INT 3
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: PUSH
27841: LD_INT 30
27843: PUSH
27844: LD_INT 37
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PPUSH
27855: CALL_OW 69
27859: ST_TO_ADDR
// if not tmp then
27860: LD_VAR 0 1
27864: NOT
27865: IFFALSE 27869
// exit ;
27867: GO 27985
// for i in tmp do
27869: LD_ADDR_VAR 0 2
27873: PUSH
27874: LD_VAR 0 1
27878: PUSH
27879: FOR_IN
27880: IFFALSE 27983
// if See ( 1 , i ) then
27882: LD_INT 1
27884: PPUSH
27885: LD_VAR 0 2
27889: PPUSH
27890: CALL_OW 292
27894: IFFALSE 27981
// begin if GetType ( i ) = unit_building then
27896: LD_VAR 0 2
27900: PPUSH
27901: CALL_OW 247
27905: PUSH
27906: LD_INT 3
27908: EQUAL
27909: IFFALSE 27947
// begin CenterNowOnUnits ( i ) ;
27911: LD_VAR 0 2
27915: PPUSH
27916: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27920: LD_EXP 39
27924: PPUSH
27925: LD_STRING D17a-JMM-1
27927: PPUSH
27928: CALL_OW 88
// seeBehemoth := true ;
27932: LD_ADDR_EXP 29
27936: PUSH
27937: LD_INT 1
27939: ST_TO_ADDR
// disable ;
27940: DISABLE
// exit ;
27941: POP
27942: POP
27943: GO 27985
// end else
27945: GO 27981
// begin CenterNowOnUnits ( i ) ;
27947: LD_VAR 0 2
27951: PPUSH
27952: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27956: LD_EXP 39
27960: PPUSH
27961: LD_STRING D17b-JMM-1
27963: PPUSH
27964: CALL_OW 88
// seeBehemoth := true ;
27968: LD_ADDR_EXP 29
27972: PUSH
27973: LD_INT 1
27975: ST_TO_ADDR
// disable ;
27976: DISABLE
// exit ;
27977: POP
27978: POP
27979: GO 27985
// end ; end ;
27981: GO 27879
27983: POP
27984: POP
// end ;
27985: PPOPN 2
27987: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27988: LD_EXP 14
27992: PUSH
27993: LD_INT 116550
27995: GREATEREQUAL
27996: IFFALSE 29172
27998: GO 28000
28000: DISABLE
28001: LD_INT 0
28003: PPUSH
28004: PPUSH
28005: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28006: LD_INT 2
28008: PPUSH
28009: LD_INT 23
28011: PUSH
28012: LD_INT 3
28014: PUSH
28015: LD_INT 3
28017: PUSH
28018: LD_INT 48
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: LIST
28026: PUSH
28027: EMPTY
28028: LIST
28029: PPUSH
28030: CALL 58572 0 2
// repeat wait ( 0 0$1 ) ;
28034: LD_INT 35
28036: PPUSH
28037: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28041: LD_INT 22
28043: PUSH
28044: LD_INT 3
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 34
28053: PUSH
28054: LD_INT 48
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PPUSH
28065: CALL_OW 69
28069: IFFALSE 28034
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28071: LD_ADDR_VAR 0 1
28075: PUSH
28076: LD_INT 22
28078: PUSH
28079: LD_INT 3
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 34
28088: PUSH
28089: LD_INT 48
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PPUSH
28100: CALL_OW 69
28104: PUSH
28105: LD_INT 1
28107: ARRAY
28108: ST_TO_ADDR
// missionStage := 12 ;
28109: LD_ADDR_EXP 15
28113: PUSH
28114: LD_INT 12
28116: ST_TO_ADDR
// platonovHasBomb := true ;
28117: LD_ADDR_EXP 30
28121: PUSH
28122: LD_INT 1
28124: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28125: LD_VAR 0 1
28129: PPUSH
28130: LD_INT 181
28132: PPUSH
28133: LD_INT 86
28135: PPUSH
28136: CALL_OW 171
// AddComHold ( bomb ) ;
28140: LD_VAR 0 1
28144: PPUSH
28145: CALL_OW 200
// wait ( 0 0$10 ) ;
28149: LD_INT 350
28151: PPUSH
28152: CALL_OW 67
// DialogueOn ;
28156: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28160: LD_EXP 64
28164: PPUSH
28165: LD_STRING D15-Pla-1
28167: PPUSH
28168: CALL_OW 94
// dec = Query ( Q15a ) ;
28172: LD_ADDR_VAR 0 2
28176: PUSH
28177: LD_STRING Q15a
28179: PPUSH
28180: CALL_OW 97
28184: ST_TO_ADDR
// if dec = 1 then
28185: LD_VAR 0 2
28189: PUSH
28190: LD_INT 1
28192: EQUAL
28193: IFFALSE 28216
// begin Say ( JMM , D15a-JMM-1 ) ;
28195: LD_EXP 39
28199: PPUSH
28200: LD_STRING D15a-JMM-1
28202: PPUSH
28203: CALL_OW 88
// YouLost ( Surrender ) ;
28207: LD_STRING Surrender
28209: PPUSH
28210: CALL_OW 104
// exit ;
28214: GO 29172
// end ; if dec = 2 then
28216: LD_VAR 0 2
28220: PUSH
28221: LD_INT 2
28223: EQUAL
28224: IFFALSE 28293
// begin Say ( JMM , D15b-JMM-1 ) ;
28226: LD_EXP 39
28230: PPUSH
28231: LD_STRING D15b-JMM-1
28233: PPUSH
28234: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28238: LD_EXP 64
28242: PPUSH
28243: LD_STRING D15b-Pla-1
28245: PPUSH
28246: CALL_OW 94
// DialogueOff ;
28250: CALL_OW 7
// wait ( 3 3$00 ) ;
28254: LD_INT 6300
28256: PPUSH
28257: CALL_OW 67
// DialogueOn ;
28261: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28265: LD_EXP 39
28269: PPUSH
28270: LD_STRING D15d-JMM-1a
28272: PPUSH
28273: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28277: LD_EXP 64
28281: PPUSH
28282: LD_STRING D15d-Pla-1
28284: PPUSH
28285: CALL_OW 94
// DialogueOff ;
28289: CALL_OW 7
// end ; if dec = 3 then
28293: LD_VAR 0 2
28297: PUSH
28298: LD_INT 3
28300: EQUAL
28301: IFFALSE 28355
// begin Say ( JMM , D15c-JMM-1 ) ;
28303: LD_EXP 39
28307: PPUSH
28308: LD_STRING D15c-JMM-1
28310: PPUSH
28311: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28315: LD_EXP 64
28319: PPUSH
28320: LD_STRING D15c-Pla-1
28322: PPUSH
28323: CALL_OW 94
// DialogueOff ;
28327: CALL_OW 7
// wait ( 0 0$15 ) ;
28331: LD_INT 525
28333: PPUSH
28334: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28338: LD_VAR 0 1
28342: PPUSH
28343: LD_INT 60
28345: PPUSH
28346: LD_INT 95
28348: PPUSH
28349: CALL_OW 116
// exit ;
28353: GO 29172
// end ; if dec = 4 then
28355: LD_VAR 0 2
28359: PUSH
28360: LD_INT 4
28362: EQUAL
28363: IFFALSE 28393
// begin Say ( JMM , D15d-JMM-1 ) ;
28365: LD_EXP 39
28369: PPUSH
28370: LD_STRING D15d-JMM-1
28372: PPUSH
28373: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28377: LD_EXP 64
28381: PPUSH
28382: LD_STRING D15d-Pla-1
28384: PPUSH
28385: CALL_OW 94
// DialogueOff ;
28389: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28393: LD_EXP 62
28397: PPUSH
28398: CALL_OW 302
28402: PUSH
28403: LD_EXP 62
28407: PPUSH
28408: CALL_OW 255
28412: PUSH
28413: LD_INT 1
28415: EQUAL
28416: AND
28417: PUSH
28418: LD_INT 22
28420: PUSH
28421: LD_INT 1
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 34
28430: PUSH
28431: LD_INT 8
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PPUSH
28442: CALL_OW 69
28446: NOT
28447: AND
28448: IFFALSE 29073
// begin SetSide ( Friend , 8 ) ;
28450: LD_EXP 62
28454: PPUSH
28455: LD_INT 8
28457: PPUSH
28458: CALL_OW 235
// if IsInUnit ( Friend ) then
28462: LD_EXP 62
28466: PPUSH
28467: CALL_OW 310
28471: IFFALSE 28482
// ComExitBuilding ( Friend ) ;
28473: LD_EXP 62
28477: PPUSH
28478: CALL_OW 122
// if IsDriver ( Friend ) then
28482: LD_EXP 62
28486: PPUSH
28487: CALL 105571 0 1
28491: IFFALSE 28502
// ComExitVehicle ( Friend ) ;
28493: LD_EXP 62
28497: PPUSH
28498: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28502: LD_EXP 62
28506: PPUSH
28507: LD_INT 9
28509: PPUSH
28510: LD_INT 2
28512: PPUSH
28513: CALL_OW 171
// wait ( 0 0$05 ) ;
28517: LD_INT 175
28519: PPUSH
28520: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28524: LD_EXP 62
28528: PPUSH
28529: CALL_OW 87
// DialogueOn ;
28533: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28537: LD_EXP 39
28541: PPUSH
28542: LD_STRING D16-JMM-1
28544: PPUSH
28545: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28549: LD_EXP 62
28553: PPUSH
28554: LD_STRING D16-Friend-1
28556: PPUSH
28557: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28561: LD_EXP 39
28565: PPUSH
28566: LD_STRING D16-JMM-2
28568: PPUSH
28569: CALL_OW 88
// DialogueOff ;
28573: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28577: LD_EXP 62
28581: PPUSH
28582: LD_INT 1
28584: PPUSH
28585: CALL_OW 235
// ComHold ( Friend ) ;
28589: LD_EXP 62
28593: PPUSH
28594: CALL_OW 140
// wait ( 0 0$20 ) ;
28598: LD_INT 700
28600: PPUSH
28601: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28605: LD_EXP 62
28609: PPUSH
28610: LD_INT 9
28612: PPUSH
28613: LD_INT 2
28615: PPUSH
28616: CALL_OW 297
28620: PUSH
28621: LD_INT 30
28623: LESS
28624: IFFALSE 28693
// begin SetSide ( Friend , 8 ) ;
28626: LD_EXP 62
28630: PPUSH
28631: LD_INT 8
28633: PPUSH
28634: CALL_OW 235
// if IsInUnit ( Friend ) then
28638: LD_EXP 62
28642: PPUSH
28643: CALL_OW 310
28647: IFFALSE 28658
// ComExitBuilding ( Friend ) ;
28649: LD_EXP 62
28653: PPUSH
28654: CALL_OW 122
// if IsDriver ( Friend ) then
28658: LD_EXP 62
28662: PPUSH
28663: CALL 105571 0 1
28667: IFFALSE 28678
// ComExitVehicle ( Friend ) ;
28669: LD_EXP 62
28673: PPUSH
28674: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28678: LD_EXP 62
28682: PPUSH
28683: LD_INT 9
28685: PPUSH
28686: LD_INT 2
28688: PPUSH
28689: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28693: LD_INT 1050
28695: PPUSH
28696: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28700: LD_INT 22
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 34
28712: PUSH
28713: LD_INT 8
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PPUSH
28724: CALL_OW 69
28728: NOT
28729: IFFALSE 29051
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28731: LD_ADDR_VAR 0 3
28735: PUSH
28736: LD_INT 22
28738: PUSH
28739: LD_INT 1
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 26
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 3
28758: PUSH
28759: LD_INT 25
28761: PUSH
28762: LD_INT 12
28764: PUSH
28765: EMPTY
28766: LIST
28767: LIST
28768: PUSH
28769: LD_INT 25
28771: PUSH
28772: LD_INT 16
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: LIST
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: LIST
28788: PPUSH
28789: CALL_OW 69
28793: PUSH
28794: LD_EXP 39
28798: PUSH
28799: LD_EXP 41
28803: PUSH
28804: LD_EXP 55
28808: PUSH
28809: LD_EXP 42
28813: PUSH
28814: LD_EXP 43
28818: PUSH
28819: LD_EXP 44
28823: PUSH
28824: LD_EXP 45
28828: PUSH
28829: LD_EXP 46
28833: PUSH
28834: LD_EXP 47
28838: PUSH
28839: LD_EXP 48
28843: PUSH
28844: LD_EXP 49
28848: PUSH
28849: LD_EXP 50
28853: PUSH
28854: LD_EXP 51
28858: PUSH
28859: LD_EXP 52
28863: PUSH
28864: LD_EXP 53
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: LIST
28873: LIST
28874: LIST
28875: LIST
28876: LIST
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: DIFF
28886: ST_TO_ADDR
// DialogueOn ;
28887: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28891: LD_EXP 64
28895: PPUSH
28896: LD_STRING D16a-Pla-1
28898: PPUSH
28899: CALL_OW 94
// if Stevens then
28903: LD_EXP 41
28907: IFFALSE 28923
// Say ( Stevens , D16a-Huck-1 ) else
28909: LD_EXP 41
28913: PPUSH
28914: LD_STRING D16a-Huck-1
28916: PPUSH
28917: CALL_OW 88
28921: GO 28965
// if Baker then
28923: LD_EXP 55
28927: IFFALSE 28943
// Say ( Baker , D16a-Huck-1 ) else
28929: LD_EXP 55
28933: PPUSH
28934: LD_STRING D16a-Huck-1
28936: PPUSH
28937: CALL_OW 88
28941: GO 28965
// if tmp then
28943: LD_VAR 0 3
28947: IFFALSE 28965
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28949: LD_VAR 0 3
28953: PUSH
28954: LD_INT 1
28956: ARRAY
28957: PPUSH
28958: LD_STRING D16a-Sol1-1
28960: PPUSH
28961: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28965: LD_EXP 62
28969: PPUSH
28970: CALL_OW 255
28974: PUSH
28975: LD_INT 8
28977: EQUAL
28978: IFFALSE 28994
// Say ( JMM , D16a-JMM-1 ) else
28980: LD_EXP 39
28984: PPUSH
28985: LD_STRING D16a-JMM-1
28987: PPUSH
28988: CALL_OW 88
28992: GO 29030
// begin Say ( JMM , D16a-JMM-1a ) ;
28994: LD_EXP 39
28998: PPUSH
28999: LD_STRING D16a-JMM-1a
29001: PPUSH
29002: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29006: LD_EXP 62
29010: PPUSH
29011: LD_STRING D16a-Friend-1
29013: PPUSH
29014: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29018: LD_EXP 62
29022: PPUSH
29023: LD_INT 3
29025: PPUSH
29026: CALL_OW 235
// end ; DialogueOff ;
29030: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29034: LD_VAR 0 1
29038: PPUSH
29039: LD_INT 60
29041: PPUSH
29042: LD_INT 95
29044: PPUSH
29045: CALL_OW 116
// end else
29049: GO 29071
// begin DialogueOn ;
29051: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29055: LD_EXP 64
29059: PPUSH
29060: LD_STRING D16c-Pla-
29062: PPUSH
29063: CALL_OW 94
// DialogueOff ;
29067: CALL_OW 7
// end ; end else
29071: GO 29172
// begin wait ( 3 3$00 ) ;
29073: LD_INT 6300
29075: PPUSH
29076: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29080: LD_INT 22
29082: PUSH
29083: LD_INT 1
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 34
29092: PUSH
29093: LD_INT 8
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PPUSH
29104: CALL_OW 69
29108: NOT
29109: IFFALSE 29152
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29111: LD_EXP 64
29115: PPUSH
29116: LD_STRING D16b-Pla-1
29118: PPUSH
29119: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29123: LD_EXP 39
29127: PPUSH
29128: LD_STRING D16b-JMM-
29130: PPUSH
29131: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29135: LD_VAR 0 1
29139: PPUSH
29140: LD_INT 60
29142: PPUSH
29143: LD_INT 95
29145: PPUSH
29146: CALL_OW 116
// end else
29150: GO 29172
// begin DialogueOn ;
29152: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29156: LD_EXP 64
29160: PPUSH
29161: LD_STRING D16c-Pla-
29163: PPUSH
29164: CALL_OW 94
// DialogueOff ;
29168: CALL_OW 7
// end ; end ; end ;
29172: PPOPN 3
29174: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29175: LD_EXP 14
29179: PUSH
29180: LD_INT 126000
29182: GREATEREQUAL
29183: PUSH
29184: LD_EXP 23
29188: NOT
29189: AND
29190: PUSH
29191: LD_EXP 74
29195: PPUSH
29196: CALL_OW 302
29200: AND
29201: IFFALSE 29559
29203: GO 29205
29205: DISABLE
29206: LD_INT 0
29208: PPUSH
// begin missionStage = 11 ;
29209: LD_ADDR_EXP 15
29213: PUSH
29214: LD_INT 11
29216: ST_TO_ADDR
// DialogueOn ;
29217: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29221: LD_EXP 74
29225: PPUSH
29226: LD_STRING D9-Roth-1
29228: PPUSH
29229: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29233: LD_EXP 39
29237: PPUSH
29238: LD_STRING D9-JMM-1
29240: PPUSH
29241: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29245: LD_EXP 74
29249: PPUSH
29250: LD_STRING D9-Roth-2
29252: PPUSH
29253: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29257: LD_EXP 74
29261: PPUSH
29262: LD_STRING D9-Roth-2a
29264: PPUSH
29265: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29269: LD_EXP 64
29273: PPUSH
29274: LD_STRING D9-Pla-2
29276: PPUSH
29277: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29281: LD_EXP 74
29285: PPUSH
29286: LD_STRING D9-Roth-3
29288: PPUSH
29289: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29293: LD_EXP 64
29297: PPUSH
29298: LD_STRING D9-Pla-3
29300: PPUSH
29301: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29305: LD_EXP 74
29309: PPUSH
29310: LD_STRING D9-Roth-4
29312: PPUSH
29313: CALL_OW 94
// dec = Query ( Q9 ) ;
29317: LD_ADDR_VAR 0 1
29321: PUSH
29322: LD_STRING Q9
29324: PPUSH
29325: CALL_OW 97
29329: ST_TO_ADDR
// if dec = 1 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 1
29337: EQUAL
29338: IFFALSE 29352
// SayRadio ( Roth , D9a-Roth-1 ) ;
29340: LD_EXP 74
29344: PPUSH
29345: LD_STRING D9a-Roth-1
29347: PPUSH
29348: CALL_OW 94
// if dec = 2 then
29352: LD_VAR 0 1
29356: PUSH
29357: LD_INT 2
29359: EQUAL
29360: IFFALSE 29386
// begin Say ( JMM , D9b-JMM-1 ) ;
29362: LD_EXP 39
29366: PPUSH
29367: LD_STRING D9b-JMM-1
29369: PPUSH
29370: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29374: LD_EXP 74
29378: PPUSH
29379: LD_STRING D9b-Roth-1
29381: PPUSH
29382: CALL_OW 94
// end ; if dec = 3 then
29386: LD_VAR 0 1
29390: PUSH
29391: LD_INT 3
29393: EQUAL
29394: IFFALSE 29456
// begin Say ( JMM , D9c-JMM-1 ) ;
29396: LD_EXP 39
29400: PPUSH
29401: LD_STRING D9c-JMM-1
29403: PPUSH
29404: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29408: LD_EXP 74
29412: PPUSH
29413: LD_STRING D9c-Roth-1
29415: PPUSH
29416: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29420: LD_EXP 39
29424: PPUSH
29425: LD_STRING D9c-JMM-2
29427: PPUSH
29428: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29432: LD_EXP 74
29436: PPUSH
29437: LD_STRING D9c-Roth-2
29439: PPUSH
29440: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29444: LD_EXP 39
29448: PPUSH
29449: LD_STRING D9c-JMM-3
29451: PPUSH
29452: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29456: LD_EXP 74
29460: PPUSH
29461: LD_STRING D9c-Roth-3
29463: PPUSH
29464: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29468: LD_EXP 74
29472: PPUSH
29473: LD_STRING D9cont-Roth-1
29475: PPUSH
29476: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29480: LD_EXP 39
29484: PPUSH
29485: LD_STRING D9cont-JMM-1
29487: PPUSH
29488: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29492: LD_EXP 74
29496: PPUSH
29497: LD_STRING D9cont-Roth-2
29499: PPUSH
29500: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29504: LD_EXP 39
29508: PPUSH
29509: LD_STRING D9cont-JMM-2
29511: PPUSH
29512: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29516: LD_EXP 74
29520: PPUSH
29521: LD_STRING D9cont-Roth-3
29523: PPUSH
29524: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29528: LD_EXP 39
29532: PPUSH
29533: LD_STRING D9cont-JMM-3
29535: PPUSH
29536: CALL_OW 88
// DialogueOff ;
29540: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29544: LD_STRING M3
29546: PPUSH
29547: CALL_OW 337
// allianceActive := true ;
29551: LD_ADDR_EXP 31
29555: PUSH
29556: LD_INT 1
29558: ST_TO_ADDR
// end ;
29559: PPOPN 1
29561: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29562: LD_EXP 64
29566: PPUSH
29567: CALL_OW 301
29571: PUSH
29572: LD_EXP 67
29576: PPUSH
29577: CALL_OW 301
29581: AND
29582: PUSH
29583: LD_INT 22
29585: PUSH
29586: LD_INT 3
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 21
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 50
29605: PUSH
29606: EMPTY
29607: LIST
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: LIST
29613: PPUSH
29614: CALL_OW 69
29618: PUSH
29619: LD_INT 7
29621: PUSH
29622: LD_INT 8
29624: PUSH
29625: LD_INT 9
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: LIST
29632: PUSH
29633: LD_OWVAR 67
29637: ARRAY
29638: LESS
29639: AND
29640: IFFALSE 30411
29642: GO 29644
29644: DISABLE
29645: LD_INT 0
29647: PPUSH
29648: PPUSH
29649: PPUSH
29650: PPUSH
// begin MC_Kill ( 1 ) ;
29651: LD_INT 1
29653: PPUSH
29654: CALL 35112 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29658: LD_INT 1
29660: PPUSH
29661: LD_INT 3
29663: PPUSH
29664: LD_INT 1
29666: PPUSH
29667: LD_INT 1
29669: PPUSH
29670: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29674: LD_ADDR_VAR 0 1
29678: PUSH
29679: LD_INT 22
29681: PUSH
29682: LD_INT 3
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 21
29691: PUSH
29692: LD_INT 1
29694: PUSH
29695: EMPTY
29696: LIST
29697: LIST
29698: PUSH
29699: LD_INT 24
29701: PUSH
29702: LD_INT 900
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: LIST
29713: PPUSH
29714: CALL_OW 69
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29751
// if GetSex ( i ) = sex_male then
29722: LD_VAR 0 1
29726: PPUSH
29727: CALL_OW 258
29731: PUSH
29732: LD_INT 1
29734: EQUAL
29735: IFFALSE 29749
// begin tmp = i ;
29737: LD_ADDR_VAR 0 2
29741: PUSH
29742: LD_VAR 0 1
29746: ST_TO_ADDR
// break ;
29747: GO 29751
// end ;
29749: GO 29719
29751: POP
29752: POP
// if tmp = 0 then
29753: LD_VAR 0 2
29757: PUSH
29758: LD_INT 0
29760: EQUAL
29761: IFFALSE 29815
// begin uc_side = 3 ;
29763: LD_ADDR_OWVAR 20
29767: PUSH
29768: LD_INT 3
29770: ST_TO_ADDR
// uc_nation = 3 ;
29771: LD_ADDR_OWVAR 21
29775: PUSH
29776: LD_INT 3
29778: ST_TO_ADDR
// hc_name =  ;
29779: LD_ADDR_OWVAR 26
29783: PUSH
29784: LD_STRING 
29786: ST_TO_ADDR
// hc_gallery =  ;
29787: LD_ADDR_OWVAR 33
29791: PUSH
29792: LD_STRING 
29794: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29795: LD_INT 1
29797: PPUSH
29798: LD_INT 10
29800: PPUSH
29801: CALL_OW 381
// tmp = CreateHuman ;
29805: LD_ADDR_VAR 0 2
29809: PUSH
29810: CALL_OW 44
29814: ST_TO_ADDR
// end ; DialogueOn ;
29815: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29819: LD_VAR 0 2
29823: PPUSH
29824: LD_STRING DSurrenderRussians-RSol1-1a
29826: PPUSH
29827: CALL_OW 94
// DialogueOff ;
29831: CALL_OW 7
// russianDestroyed := true ;
29835: LD_ADDR_EXP 21
29839: PUSH
29840: LD_INT 1
29842: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29843: LD_INT 22
29845: PUSH
29846: LD_INT 3
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 21
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PPUSH
29867: CALL_OW 69
29871: PPUSH
29872: CALL_OW 122
// wait ( 0 0$1 ) ;
29876: LD_INT 35
29878: PPUSH
29879: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29883: LD_INT 22
29885: PUSH
29886: LD_INT 3
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 21
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: PPUSH
29907: CALL_OW 69
29911: PPUSH
29912: LD_INT 25
29914: PPUSH
29915: CALL_OW 173
// wait ( 0 0$10 ) ;
29919: LD_INT 350
29921: PPUSH
29922: CALL_OW 67
// PrepareOmarInvasion ;
29926: CALL 13863 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29930: LD_ADDR_VAR 0 2
29934: PUSH
29935: LD_EXP 92
29939: PPUSH
29940: CALL_OW 250
29944: PUSH
29945: LD_EXP 92
29949: PPUSH
29950: CALL_OW 251
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29959: LD_VAR 0 2
29963: PUSH
29964: LD_INT 1
29966: ARRAY
29967: PPUSH
29968: LD_VAR 0 2
29972: PUSH
29973: LD_INT 2
29975: ARRAY
29976: PPUSH
29977: LD_INT 1
29979: PPUSH
29980: LD_INT 8
29982: NEG
29983: PPUSH
29984: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29988: LD_EXP 92
29992: PPUSH
29993: CALL_OW 87
// DialogueOn ;
29997: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30001: LD_EXP 39
30005: PPUSH
30006: LD_STRING D19-JMM-1
30008: PPUSH
30009: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30013: LD_ADDR_VAR 0 3
30017: PUSH
30018: LD_INT 22
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 26
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 2
30040: PUSH
30041: LD_INT 25
30043: PUSH
30044: LD_INT 1
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 25
30053: PUSH
30054: LD_INT 2
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 25
30063: PUSH
30064: LD_INT 3
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 25
30073: PUSH
30074: LD_INT 4
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 25
30083: PUSH
30084: LD_INT 5
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 25
30093: PUSH
30094: LD_INT 8
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: LIST
30106: LIST
30107: LIST
30108: LIST
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: LIST
30114: PPUSH
30115: CALL_OW 69
30119: PUSH
30120: LD_EXP 39
30124: PUSH
30125: LD_EXP 40
30129: PUSH
30130: LD_EXP 41
30134: PUSH
30135: LD_EXP 42
30139: PUSH
30140: LD_EXP 43
30144: PUSH
30145: LD_EXP 44
30149: PUSH
30150: LD_EXP 45
30154: PUSH
30155: LD_EXP 46
30159: PUSH
30160: LD_EXP 47
30164: PUSH
30165: LD_EXP 48
30169: PUSH
30170: LD_EXP 49
30174: PUSH
30175: LD_EXP 50
30179: PUSH
30180: LD_EXP 51
30184: PUSH
30185: LD_EXP 52
30189: PUSH
30190: LD_EXP 53
30194: PUSH
30195: LD_EXP 54
30199: PUSH
30200: LD_EXP 55
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: DIFF
30224: ST_TO_ADDR
// if tmp2 then
30225: LD_VAR 0 3
30229: IFFALSE 30247
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30231: LD_VAR 0 3
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: PPUSH
30240: LD_STRING D19-Sol1-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30247: LD_EXP 39
30251: PPUSH
30252: LD_STRING D19-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30263: LD_VAR 0 2
30267: PUSH
30268: LD_INT 1
30270: ARRAY
30271: PPUSH
30272: LD_VAR 0 2
30276: PUSH
30277: LD_INT 2
30279: ARRAY
30280: PPUSH
30281: LD_INT 1
30283: PPUSH
30284: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30288: LD_STRING M5
30290: PPUSH
30291: CALL_OW 337
// omarOnMotherLode := false ;
30295: LD_ADDR_VAR 0 4
30299: PUSH
30300: LD_INT 0
30302: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30303: LD_INT 35
30305: PPUSH
30306: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30310: LD_EXP 92
30314: PPUSH
30315: LD_INT 215
30317: PPUSH
30318: LD_INT 100
30320: PPUSH
30321: CALL_OW 297
30325: PUSH
30326: LD_INT 10
30328: LESS
30329: PUSH
30330: LD_VAR 0 4
30334: NOT
30335: AND
30336: IFFALSE 30370
// begin omarOnMotherLode := true ;
30338: LD_ADDR_VAR 0 4
30342: PUSH
30343: LD_INT 1
30345: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30346: LD_EXP 39
30350: PPUSH
30351: LD_STRING D19b-JMM-1
30353: PPUSH
30354: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30358: LD_EXP 92
30362: PPUSH
30363: LD_STRING DOmarContam-Omar-1
30365: PPUSH
30366: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30370: LD_EXP 92
30374: PPUSH
30375: CALL_OW 301
30379: IFFALSE 30303
// Say ( JMM , D19a-JMM-1 ) ;
30381: LD_EXP 39
30385: PPUSH
30386: LD_STRING D19a-JMM-1
30388: PPUSH
30389: CALL_OW 88
// if Heike then
30393: LD_EXP 93
30397: IFFALSE 30411
// Say ( Heike , D19a-Hke-1 ) ;
30399: LD_EXP 93
30403: PPUSH
30404: LD_STRING D19a-Hke-1
30406: PPUSH
30407: CALL_OW 88
// end ;
30411: PPOPN 4
30413: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30414: LD_INT 22
30416: PUSH
30417: LD_INT 3
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 21
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PPUSH
30438: CALL_OW 69
30442: PUSH
30443: LD_EXP 21
30447: AND
30448: IFFALSE 30516
30450: GO 30452
30452: DISABLE
30453: LD_INT 0
30455: PPUSH
30456: PPUSH
// begin enable ;
30457: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30458: LD_ADDR_VAR 0 2
30462: PUSH
30463: LD_INT 25
30465: PPUSH
30466: LD_INT 22
30468: PUSH
30469: LD_INT 3
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PPUSH
30476: CALL_OW 70
30480: ST_TO_ADDR
// if not tmp then
30481: LD_VAR 0 2
30485: NOT
30486: IFFALSE 30490
// exit ;
30488: GO 30516
// for i in tmp do
30490: LD_ADDR_VAR 0 1
30494: PUSH
30495: LD_VAR 0 2
30499: PUSH
30500: FOR_IN
30501: IFFALSE 30514
// RemoveUnit ( i ) ;
30503: LD_VAR 0 1
30507: PPUSH
30508: CALL_OW 64
30512: GO 30500
30514: POP
30515: POP
// end ;
30516: PPOPN 2
30518: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30519: LD_INT 22
30521: PUSH
30522: LD_INT 7
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 21
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PPUSH
30543: CALL_OW 69
30547: PUSH
30548: LD_INT 6
30550: LESS
30551: IFFALSE 31019
30553: GO 30555
30555: DISABLE
30556: LD_INT 0
30558: PPUSH
30559: PPUSH
// begin MC_Kill ( 1 ) ;
30560: LD_INT 1
30562: PPUSH
30563: CALL 35112 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30567: LD_INT 7
30569: PPUSH
30570: LD_INT 1
30572: PPUSH
30573: LD_INT 1
30575: PPUSH
30576: LD_INT 1
30578: PPUSH
30579: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30583: LD_ADDR_VAR 0 1
30587: PUSH
30588: LD_INT 22
30590: PUSH
30591: LD_INT 7
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 26
30600: PUSH
30601: LD_INT 1
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PPUSH
30612: CALL_OW 69
30616: PUSH
30617: LD_EXP 74
30621: DIFF
30622: ST_TO_ADDR
// if tmp then
30623: LD_VAR 0 1
30627: IFFALSE 30645
// tmp := tmp [ 1 ] else
30629: LD_ADDR_VAR 0 1
30633: PUSH
30634: LD_VAR 0 1
30638: PUSH
30639: LD_INT 1
30641: ARRAY
30642: ST_TO_ADDR
30643: GO 30681
// begin uc_side := 7 ;
30645: LD_ADDR_OWVAR 20
30649: PUSH
30650: LD_INT 7
30652: ST_TO_ADDR
// uc_nation := 1 ;
30653: LD_ADDR_OWVAR 21
30657: PUSH
30658: LD_INT 1
30660: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30661: LD_INT 1
30663: PPUSH
30664: LD_INT 8
30666: PPUSH
30667: CALL_OW 384
// tmp := CreateHuman ;
30671: LD_ADDR_VAR 0 1
30675: PUSH
30676: CALL_OW 44
30680: ST_TO_ADDR
// end ; DialogueOn ;
30681: CALL_OW 6
// if IsOK ( Roth ) then
30685: LD_EXP 74
30689: PPUSH
30690: CALL_OW 302
30694: IFFALSE 30708
// Say ( JMM , DAb-JMM-1 ) ;
30696: LD_EXP 39
30700: PPUSH
30701: LD_STRING DAb-JMM-1
30703: PPUSH
30704: CALL_OW 88
// if IsOK ( Roth ) then
30708: LD_EXP 74
30712: PPUSH
30713: CALL_OW 302
30717: IFFALSE 30741
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30719: LD_EXP 74
30723: PPUSH
30724: LD_STRING DSurrenderAlliance-Roth-1
30726: PPUSH
30727: CALL_OW 88
// RothCaptured := true ;
30731: LD_ADDR_EXP 33
30735: PUSH
30736: LD_INT 1
30738: ST_TO_ADDR
// end else
30739: GO 30753
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30741: LD_VAR 0 1
30745: PPUSH
30746: LD_STRING DSurrenderAlliance-Sci1-1
30748: PPUSH
30749: CALL_OW 88
// DialogueOff ;
30753: CALL_OW 7
// allianceDestroyed := true ;
30757: LD_ADDR_EXP 23
30761: PUSH
30762: LD_INT 1
30764: ST_TO_ADDR
// if capturedUnit = 0 then
30765: LD_EXP 34
30769: PUSH
30770: LD_INT 0
30772: EQUAL
30773: IFFALSE 30782
// SetAchievement ( ACH_ALLIANCE ) ;
30775: LD_STRING ACH_ALLIANCE
30777: PPUSH
30778: CALL_OW 543
// if trueAmericans then
30782: LD_EXP 35
30786: IFFALSE 30862
// begin if trueAmericans = 1 then
30788: LD_EXP 35
30792: PUSH
30793: LD_INT 1
30795: EQUAL
30796: IFFALSE 30812
// Say ( JMM , DAb-JMM-1a ) else
30798: LD_EXP 39
30802: PPUSH
30803: LD_STRING DAb-JMM-1a
30805: PPUSH
30806: CALL_OW 88
30810: GO 30824
// Say ( JMM , DAb-JMM-1b ) ;
30812: LD_EXP 39
30816: PPUSH
30817: LD_STRING DAb-JMM-1b
30819: PPUSH
30820: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30824: LD_EXP 35
30828: PPUSH
30829: CALL_OW 87
// for i in trueAmericans do
30833: LD_ADDR_VAR 0 2
30837: PUSH
30838: LD_EXP 35
30842: PUSH
30843: FOR_IN
30844: IFFALSE 30860
// SetSide ( i , 1 ) ;
30846: LD_VAR 0 2
30850: PPUSH
30851: LD_INT 1
30853: PPUSH
30854: CALL_OW 235
30858: GO 30843
30860: POP
30861: POP
// end ; repeat wait ( 0 0$1 ) ;
30862: LD_INT 35
30864: PPUSH
30865: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30869: LD_ADDR_VAR 0 2
30873: PUSH
30874: LD_INT 22
30876: PUSH
30877: LD_INT 7
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 21
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PPUSH
30898: CALL_OW 69
30902: PUSH
30903: FOR_IN
30904: IFFALSE 30986
// begin if IsInUnit ( i ) then
30906: LD_VAR 0 2
30910: PPUSH
30911: CALL_OW 310
30915: IFFALSE 30926
// ComExitBuilding ( i ) ;
30917: LD_VAR 0 2
30921: PPUSH
30922: CALL_OW 122
// if IsDriver ( i ) then
30926: LD_VAR 0 2
30930: PPUSH
30931: CALL 105571 0 1
30935: IFFALSE 30946
// ComExitVehicle ( i ) ;
30937: LD_VAR 0 2
30941: PPUSH
30942: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30946: LD_VAR 0 2
30950: PPUSH
30951: LD_INT 26
30953: PPUSH
30954: CALL_OW 308
30958: NOT
30959: IFFALSE 30975
// AddComMoveToArea ( i , allianceEscapeArea ) else
30961: LD_VAR 0 2
30965: PPUSH
30966: LD_INT 26
30968: PPUSH
30969: CALL_OW 173
30973: GO 30984
// RemoveUnit ( i ) ;
30975: LD_VAR 0 2
30979: PPUSH
30980: CALL_OW 64
// end ;
30984: GO 30903
30986: POP
30987: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30988: LD_INT 22
30990: PUSH
30991: LD_INT 7
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 21
31000: PUSH
31001: LD_INT 1
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PPUSH
31012: CALL_OW 69
31016: NOT
31017: IFFALSE 30862
// end ;
31019: PPOPN 2
31021: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31022: LD_INT 0
31024: PPUSH
31025: PPUSH
// if not unit then
31026: LD_VAR 0 1
31030: NOT
31031: IFFALSE 31035
// exit ;
31033: GO 32533
// DoNotAttack ( 7 , unit ) ;
31035: LD_INT 7
31037: PPUSH
31038: LD_VAR 0 1
31042: PPUSH
31043: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31047: LD_VAR 0 1
31051: PPUSH
31052: LD_INT 260
31054: PPUSH
31055: LD_INT 235
31057: PPUSH
31058: LD_INT 3
31060: PPUSH
31061: LD_INT 1
31063: PPUSH
31064: CALL_OW 483
// SetSide ( unit , 4 ) ;
31068: LD_VAR 0 1
31072: PPUSH
31073: LD_INT 4
31075: PPUSH
31076: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31080: LD_ADDR_EXP 34
31084: PUSH
31085: LD_EXP 34
31089: PUSH
31090: LD_INT 1
31092: PLUS
31093: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31094: LD_INT 70
31096: PPUSH
31097: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31101: LD_INT 260
31103: PPUSH
31104: LD_INT 235
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: LD_INT 8
31112: NEG
31113: PPUSH
31114: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31118: LD_VAR 0 1
31122: PPUSH
31123: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31127: LD_VAR 0 1
31131: PPUSH
31132: LD_EXP 74
31136: PPUSH
31137: CALL_OW 119
// DialogueOn ;
31141: CALL_OW 6
// case unit of JMM :
31145: LD_VAR 0 1
31149: PUSH
31150: LD_EXP 39
31154: DOUBLE
31155: EQUAL
31156: IFTRUE 31160
31158: GO 31175
31160: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31161: LD_EXP 39
31165: PPUSH
31166: LD_STRING DA1-JMM-1
31168: PPUSH
31169: CALL_OW 91
31173: GO 31617
31175: LD_EXP 40
31179: DOUBLE
31180: EQUAL
31181: IFTRUE 31185
31183: GO 31200
31185: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31186: LD_EXP 40
31190: PPUSH
31191: LD_STRING DA1-Joan-1
31193: PPUSH
31194: CALL_OW 91
31198: GO 31617
31200: LD_EXP 42
31204: DOUBLE
31205: EQUAL
31206: IFTRUE 31210
31208: GO 31225
31210: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31211: LD_EXP 42
31215: PPUSH
31216: LD_STRING DA1-Lisa-1
31218: PPUSH
31219: CALL_OW 91
31223: GO 31617
31225: LD_EXP 43
31229: DOUBLE
31230: EQUAL
31231: IFTRUE 31235
31233: GO 31250
31235: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31236: LD_EXP 43
31240: PPUSH
31241: LD_STRING DA1-Don-1
31243: PPUSH
31244: CALL_OW 91
31248: GO 31617
31250: LD_EXP 50
31254: DOUBLE
31255: EQUAL
31256: IFTRUE 31260
31258: GO 31275
31260: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31261: LD_EXP 50
31265: PPUSH
31266: LD_STRING DA1-Corn-1
31268: PPUSH
31269: CALL_OW 91
31273: GO 31617
31275: LD_EXP 46
31279: DOUBLE
31280: EQUAL
31281: IFTRUE 31285
31283: GO 31300
31285: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31286: LD_EXP 46
31290: PPUSH
31291: LD_STRING DA1-Den-1
31293: PPUSH
31294: CALL_OW 91
31298: GO 31617
31300: LD_EXP 44
31304: DOUBLE
31305: EQUAL
31306: IFTRUE 31310
31308: GO 31325
31310: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31311: LD_EXP 44
31315: PPUSH
31316: LD_STRING DA1-Bobby-1
31318: PPUSH
31319: CALL_OW 91
31323: GO 31617
31325: LD_EXP 48
31329: DOUBLE
31330: EQUAL
31331: IFTRUE 31335
31333: GO 31350
31335: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31336: LD_EXP 48
31340: PPUSH
31341: LD_STRING DA1-Glad-1
31343: PPUSH
31344: CALL_OW 91
31348: GO 31617
31350: LD_EXP 45
31354: DOUBLE
31355: EQUAL
31356: IFTRUE 31360
31358: GO 31375
31360: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31361: LD_EXP 45
31365: PPUSH
31366: LD_STRING DA1-Cyrus-1
31368: PPUSH
31369: CALL_OW 91
31373: GO 31617
31375: LD_EXP 41
31379: DOUBLE
31380: EQUAL
31381: IFTRUE 31385
31383: GO 31400
31385: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31386: LD_EXP 41
31390: PPUSH
31391: LD_STRING DA1-Huck-1
31393: PPUSH
31394: CALL_OW 91
31398: GO 31617
31400: LD_EXP 55
31404: DOUBLE
31405: EQUAL
31406: IFTRUE 31410
31408: GO 31425
31410: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31411: LD_EXP 55
31415: PPUSH
31416: LD_STRING DA1-Huck-1
31418: PPUSH
31419: CALL_OW 91
31423: GO 31617
31425: LD_EXP 47
31429: DOUBLE
31430: EQUAL
31431: IFTRUE 31435
31433: GO 31450
31435: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31436: LD_EXP 47
31440: PPUSH
31441: LD_STRING DA1-Brown-1
31443: PPUSH
31444: CALL_OW 91
31448: GO 31617
31450: LD_EXP 51
31454: DOUBLE
31455: EQUAL
31456: IFTRUE 31460
31458: GO 31475
31460: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31461: LD_EXP 51
31465: PPUSH
31466: LD_STRING DA1-Gary-1
31468: PPUSH
31469: CALL_OW 91
31473: GO 31617
31475: LD_EXP 54
31479: DOUBLE
31480: EQUAL
31481: IFTRUE 31485
31483: GO 31500
31485: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31486: LD_EXP 54
31490: PPUSH
31491: LD_STRING DA1-Con-1
31493: PPUSH
31494: CALL_OW 91
31498: GO 31617
31500: LD_EXP 60
31504: DOUBLE
31505: EQUAL
31506: IFTRUE 31510
31508: GO 31525
31510: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31511: LD_EXP 60
31515: PPUSH
31516: LD_STRING DA1-Kurt-1
31518: PPUSH
31519: CALL_OW 91
31523: GO 31617
31525: LD_EXP 53
31529: DOUBLE
31530: EQUAL
31531: IFTRUE 31535
31533: GO 31550
31535: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31536: LD_EXP 53
31540: PPUSH
31541: LD_STRING DA1-Yam-1
31543: PPUSH
31544: CALL_OW 91
31548: GO 31617
31550: LD_EXP 52
31554: DOUBLE
31555: EQUAL
31556: IFTRUE 31560
31558: GO 31575
31560: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31561: LD_EXP 52
31565: PPUSH
31566: LD_STRING DA1-Frank-1
31568: PPUSH
31569: CALL_OW 91
31573: GO 31617
31575: POP
// begin if GetSex ( unit ) = sex_male then
31576: LD_VAR 0 1
31580: PPUSH
31581: CALL_OW 258
31585: PUSH
31586: LD_INT 1
31588: EQUAL
31589: IFFALSE 31605
// ForceSay ( unit , DA1-Sol1-1 ) else
31591: LD_VAR 0 1
31595: PPUSH
31596: LD_STRING DA1-Sol1-1
31598: PPUSH
31599: CALL_OW 91
31603: GO 31617
// ForceSay ( unit , DA1-FSol1-1 ) ;
31605: LD_VAR 0 1
31609: PPUSH
31610: LD_STRING DA1-FSol1-1
31612: PPUSH
31613: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31617: LD_EXP 74
31621: PPUSH
31622: LD_STRING DA-Roth-1
31624: PPUSH
31625: CALL_OW 88
// if capturedUnit = 1 then
31629: LD_EXP 34
31633: PUSH
31634: LD_INT 1
31636: EQUAL
31637: IFFALSE 31665
// begin Say ( Simms , DA-Sim-1 ) ;
31639: LD_EXP 75
31643: PPUSH
31644: LD_STRING DA-Sim-1
31646: PPUSH
31647: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31651: LD_EXP 74
31655: PPUSH
31656: LD_STRING DA-Roth-2
31658: PPUSH
31659: CALL_OW 88
// end else
31663: GO 31677
// Say ( Simms , DA-Sim-2 ) ;
31665: LD_EXP 75
31669: PPUSH
31670: LD_STRING DA-Sim-2
31672: PPUSH
31673: CALL_OW 88
// case unit of JMM :
31677: LD_VAR 0 1
31681: PUSH
31682: LD_EXP 39
31686: DOUBLE
31687: EQUAL
31688: IFTRUE 31692
31690: GO 31707
31692: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31693: LD_EXP 39
31697: PPUSH
31698: LD_STRING DA1-JMM-1a
31700: PPUSH
31701: CALL_OW 91
31705: GO 32214
31707: LD_EXP 40
31711: DOUBLE
31712: EQUAL
31713: IFTRUE 31717
31715: GO 31732
31717: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31718: LD_EXP 40
31722: PPUSH
31723: LD_STRING DA1-Joan-1a
31725: PPUSH
31726: CALL_OW 91
31730: GO 32214
31732: LD_EXP 42
31736: DOUBLE
31737: EQUAL
31738: IFTRUE 31742
31740: GO 31757
31742: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31743: LD_EXP 42
31747: PPUSH
31748: LD_STRING DA1-Lisa-1a
31750: PPUSH
31751: CALL_OW 91
31755: GO 32214
31757: LD_EXP 43
31761: DOUBLE
31762: EQUAL
31763: IFTRUE 31767
31765: GO 31782
31767: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31768: LD_EXP 43
31772: PPUSH
31773: LD_STRING DA1-Don-1a
31775: PPUSH
31776: CALL_OW 91
31780: GO 32214
31782: LD_EXP 50
31786: DOUBLE
31787: EQUAL
31788: IFTRUE 31792
31790: GO 31807
31792: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31793: LD_EXP 50
31797: PPUSH
31798: LD_STRING DA1-Corn-1a
31800: PPUSH
31801: CALL_OW 91
31805: GO 32214
31807: LD_EXP 46
31811: DOUBLE
31812: EQUAL
31813: IFTRUE 31817
31815: GO 31832
31817: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31818: LD_EXP 46
31822: PPUSH
31823: LD_STRING DA1-Den-1a
31825: PPUSH
31826: CALL_OW 91
31830: GO 32214
31832: LD_EXP 44
31836: DOUBLE
31837: EQUAL
31838: IFTRUE 31842
31840: GO 31857
31842: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31843: LD_EXP 44
31847: PPUSH
31848: LD_STRING DA1-Bobby-1a
31850: PPUSH
31851: CALL_OW 91
31855: GO 32214
31857: LD_EXP 48
31861: DOUBLE
31862: EQUAL
31863: IFTRUE 31867
31865: GO 31882
31867: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31868: LD_EXP 48
31872: PPUSH
31873: LD_STRING DA1-Glad-1a
31875: PPUSH
31876: CALL_OW 91
31880: GO 32214
31882: LD_EXP 45
31886: DOUBLE
31887: EQUAL
31888: IFTRUE 31892
31890: GO 31907
31892: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31893: LD_EXP 45
31897: PPUSH
31898: LD_STRING DA1-Cyrus-1a
31900: PPUSH
31901: CALL_OW 91
31905: GO 32214
31907: LD_EXP 41
31911: DOUBLE
31912: EQUAL
31913: IFTRUE 31917
31915: GO 31932
31917: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31918: LD_EXP 41
31922: PPUSH
31923: LD_STRING DA1-Huck-1a
31925: PPUSH
31926: CALL_OW 91
31930: GO 32214
31932: LD_EXP 55
31936: DOUBLE
31937: EQUAL
31938: IFTRUE 31942
31940: GO 31957
31942: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31943: LD_EXP 55
31947: PPUSH
31948: LD_STRING DA1-Huck-1a
31950: PPUSH
31951: CALL_OW 91
31955: GO 32214
31957: LD_EXP 47
31961: DOUBLE
31962: EQUAL
31963: IFTRUE 31967
31965: GO 31982
31967: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31968: LD_EXP 47
31972: PPUSH
31973: LD_STRING DA1-Brown-1a
31975: PPUSH
31976: CALL_OW 91
31980: GO 32214
31982: LD_EXP 51
31986: DOUBLE
31987: EQUAL
31988: IFTRUE 31992
31990: GO 32007
31992: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31993: LD_EXP 51
31997: PPUSH
31998: LD_STRING DA1-Gary-1a
32000: PPUSH
32001: CALL_OW 91
32005: GO 32214
32007: LD_EXP 54
32011: DOUBLE
32012: EQUAL
32013: IFTRUE 32017
32015: GO 32032
32017: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32018: LD_EXP 54
32022: PPUSH
32023: LD_STRING DA1-Con-1a
32025: PPUSH
32026: CALL_OW 91
32030: GO 32214
32032: LD_EXP 60
32036: DOUBLE
32037: EQUAL
32038: IFTRUE 32042
32040: GO 32057
32042: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32043: LD_EXP 60
32047: PPUSH
32048: LD_STRING DA1-Kurt-1a
32050: PPUSH
32051: CALL_OW 91
32055: GO 32214
32057: LD_EXP 53
32061: DOUBLE
32062: EQUAL
32063: IFTRUE 32067
32065: GO 32082
32067: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32068: LD_EXP 53
32072: PPUSH
32073: LD_STRING DA1-Yam-1a
32075: PPUSH
32076: CALL_OW 91
32080: GO 32214
32082: LD_EXP 52
32086: DOUBLE
32087: EQUAL
32088: IFTRUE 32092
32090: GO 32107
32092: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32093: LD_EXP 52
32097: PPUSH
32098: LD_STRING DA1-Frank-1a
32100: PPUSH
32101: CALL_OW 91
32105: GO 32214
32107: POP
// begin join := rand ( 0 , 1 ) ;
32108: LD_ADDR_VAR 0 3
32112: PUSH
32113: LD_INT 0
32115: PPUSH
32116: LD_INT 1
32118: PPUSH
32119: CALL_OW 12
32123: ST_TO_ADDR
// if join then
32124: LD_VAR 0 3
32128: IFFALSE 32173
// begin if GetSex ( unit ) = sex_male then
32130: LD_VAR 0 1
32134: PPUSH
32135: CALL_OW 258
32139: PUSH
32140: LD_INT 1
32142: EQUAL
32143: IFFALSE 32159
// ForceSay ( unit , DA1-Sol1-1b ) else
32145: LD_VAR 0 1
32149: PPUSH
32150: LD_STRING DA1-Sol1-1b
32152: PPUSH
32153: CALL_OW 91
32157: GO 32171
// ForceSay ( unit , DA1-FSol1-1b ) ;
32159: LD_VAR 0 1
32163: PPUSH
32164: LD_STRING DA1-FSol1-1b
32166: PPUSH
32167: CALL_OW 91
// end else
32171: GO 32214
// begin if GetSex ( unit ) = sex_male then
32173: LD_VAR 0 1
32177: PPUSH
32178: CALL_OW 258
32182: PUSH
32183: LD_INT 1
32185: EQUAL
32186: IFFALSE 32202
// ForceSay ( unit , DA1-Sol1-1a ) else
32188: LD_VAR 0 1
32192: PPUSH
32193: LD_STRING DA1-Sol1-1a
32195: PPUSH
32196: CALL_OW 91
32200: GO 32214
// ForceSay ( unit , DA1-FSol1-1a ) ;
32202: LD_VAR 0 1
32206: PPUSH
32207: LD_STRING DA1-FSol1-1a
32209: PPUSH
32210: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32214: LD_VAR 0 1
32218: PUSH
32219: LD_EXP 39
32223: EQUAL
32224: IFFALSE 32235
// begin YouLost ( JMMCaptured ) ;
32226: LD_STRING JMMCaptured
32228: PPUSH
32229: CALL_OW 104
// exit ;
32233: GO 32533
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32235: LD_VAR 0 1
32239: PUSH
32240: LD_EXP 43
32244: PUSH
32245: LD_EXP 46
32249: PUSH
32250: LD_EXP 44
32254: PUSH
32255: LD_EXP 41
32259: PUSH
32260: LD_EXP 55
32264: PUSH
32265: LD_EXP 47
32269: PUSH
32270: LD_EXP 53
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: IN
32284: PUSH
32285: LD_VAR 0 3
32289: OR
32290: IFFALSE 32389
// begin Say ( Roth , DA-Roth-3 ) ;
32292: LD_EXP 74
32296: PPUSH
32297: LD_STRING DA-Roth-3
32299: PPUSH
32300: CALL_OW 88
// SetSide ( unit , 7 ) ;
32304: LD_VAR 0 1
32308: PPUSH
32309: LD_INT 7
32311: PPUSH
32312: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32316: LD_ADDR_EXP 102
32320: PUSH
32321: LD_EXP 102
32325: PPUSH
32326: LD_INT 1
32328: PPUSH
32329: LD_EXP 102
32333: PUSH
32334: LD_INT 1
32336: ARRAY
32337: PUSH
32338: LD_VAR 0 1
32342: ADD
32343: PPUSH
32344: CALL_OW 1
32348: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32349: LD_INT 260
32351: PPUSH
32352: LD_INT 235
32354: PPUSH
32355: LD_INT 1
32357: PPUSH
32358: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32362: LD_VAR 0 1
32366: PPUSH
32367: LD_INT 1000
32369: PPUSH
32370: CALL_OW 234
// DialogueOff ;
32374: CALL_OW 7
// ComFree ( unit ) ;
32378: LD_VAR 0 1
32382: PPUSH
32383: CALL_OW 139
// end else
32387: GO 32470
// begin Say ( Roth , DA-Roth-3a ) ;
32389: LD_EXP 74
32393: PPUSH
32394: LD_STRING DA-Roth-3a
32396: PPUSH
32397: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32401: LD_ADDR_EXP 35
32405: PUSH
32406: LD_EXP 35
32410: PUSH
32411: LD_VAR 0 1
32415: ADD
32416: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32417: LD_INT 260
32419: PPUSH
32420: LD_INT 235
32422: PPUSH
32423: LD_INT 1
32425: PPUSH
32426: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32430: LD_VAR 0 1
32434: PPUSH
32435: LD_INT 1000
32437: PPUSH
32438: CALL_OW 234
// DialogueOff ;
32442: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32446: LD_VAR 0 1
32450: PPUSH
32451: LD_INT 272
32453: PPUSH
32454: LD_INT 254
32456: PPUSH
32457: CALL_OW 111
// AddComHold ( unit ) ;
32461: LD_VAR 0 1
32465: PPUSH
32466: CALL_OW 200
// end ; if capturedUnit = 1 then
32470: LD_EXP 34
32474: PUSH
32475: LD_INT 1
32477: EQUAL
32478: IFFALSE 32533
// begin DialogueOn ;
32480: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32484: LD_EXP 39
32488: PPUSH
32489: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32493: LD_EXP 39
32497: PPUSH
32498: LD_STRING DAa-JMM-1
32500: PPUSH
32501: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32505: LD_EXP 39
32509: PPUSH
32510: LD_STRING DAa-JMM-1a
32512: PPUSH
32513: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32517: LD_EXP 39
32521: PPUSH
32522: LD_STRING DAa-JMM-1b
32524: PPUSH
32525: CALL_OW 88
// DialogueOff ;
32529: CALL_OW 7
// end ; end ;
32533: LD_VAR 0 2
32537: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32538: LD_EXP 15
32542: PUSH
32543: LD_INT 13
32545: GREATEREQUAL
32546: PUSH
32547: LD_INT 22
32549: PUSH
32550: LD_INT 2
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 21
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PPUSH
32571: CALL_OW 69
32575: PUSH
32576: LD_INT 0
32578: EQUAL
32579: AND
32580: PUSH
32581: LD_INT 22
32583: PUSH
32584: LD_INT 2
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 21
32593: PUSH
32594: LD_INT 2
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 50
32603: PUSH
32604: EMPTY
32605: LIST
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: LIST
32611: PPUSH
32612: CALL_OW 69
32616: PUSH
32617: LD_INT 0
32619: EQUAL
32620: AND
32621: PUSH
32622: LD_EXP 21
32626: AND
32627: PUSH
32628: LD_EXP 22
32632: AND
32633: PUSH
32634: LD_EXP 23
32638: AND
32639: IFFALSE 33281
32641: GO 32643
32643: DISABLE
32644: LD_INT 0
32646: PPUSH
32647: PPUSH
32648: PPUSH
// begin m1 := false ;
32649: LD_ADDR_VAR 0 1
32653: PUSH
32654: LD_INT 0
32656: ST_TO_ADDR
// m2 := false ;
32657: LD_ADDR_VAR 0 2
32661: PUSH
32662: LD_INT 0
32664: ST_TO_ADDR
// m3 := false ;
32665: LD_ADDR_VAR 0 3
32669: PUSH
32670: LD_INT 0
32672: ST_TO_ADDR
// if not bombExploded then
32673: LD_EXP 37
32677: NOT
32678: IFFALSE 32687
// SetAchievement ( ACH_SIBROCKET ) ;
32680: LD_STRING ACH_SIBROCKET
32682: PPUSH
32683: CALL_OW 543
// if tick <= 120 120$00 then
32687: LD_OWVAR 1
32691: PUSH
32692: LD_INT 252000
32694: LESSEQUAL
32695: IFFALSE 32711
// begin wait ( 3 ) ;
32697: LD_INT 3
32699: PPUSH
32700: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32704: LD_STRING ACH_ASPEED_15
32706: PPUSH
32707: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32711: LD_EXP 39
32715: PPUSH
32716: CALL_OW 87
// music_class := 5 ;
32720: LD_ADDR_OWVAR 72
32724: PUSH
32725: LD_INT 5
32727: ST_TO_ADDR
// music_nat := 5 ;
32728: LD_ADDR_OWVAR 71
32732: PUSH
32733: LD_INT 5
32735: ST_TO_ADDR
// DialogueOn ;
32736: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32740: LD_EXP 39
32744: PPUSH
32745: LD_STRING D20-JMM-1
32747: PPUSH
32748: CALL_OW 88
// if IsOK ( Joan ) then
32752: LD_EXP 40
32756: PPUSH
32757: CALL_OW 302
32761: IFFALSE 32775
// Say ( Joan , D20-Joan-1 ) ;
32763: LD_EXP 40
32767: PPUSH
32768: LD_STRING D20-Joan-1
32770: PPUSH
32771: CALL_OW 88
// if IsOk ( Lisa ) then
32775: LD_EXP 42
32779: PPUSH
32780: CALL_OW 302
32784: IFFALSE 32798
// Say ( Lisa , D20-Lisa-1 ) ;
32786: LD_EXP 42
32790: PPUSH
32791: LD_STRING D20-Lisa-1
32793: PPUSH
32794: CALL_OW 88
// if IsOk ( Donaldson ) then
32798: LD_EXP 43
32802: PPUSH
32803: CALL_OW 302
32807: IFFALSE 32821
// Say ( Donaldson , D20-Don-1 ) ;
32809: LD_EXP 43
32813: PPUSH
32814: LD_STRING D20-Don-1
32816: PPUSH
32817: CALL_OW 88
// if IsOK ( Cornel ) then
32821: LD_EXP 50
32825: PPUSH
32826: CALL_OW 302
32830: IFFALSE 32844
// Say ( Cornel , D20-Corn-1 ) ;
32832: LD_EXP 50
32836: PPUSH
32837: LD_STRING D20-Corn-1
32839: PPUSH
32840: CALL_OW 88
// if IsOk ( Denis ) then
32844: LD_EXP 46
32848: PPUSH
32849: CALL_OW 302
32853: IFFALSE 32867
// Say ( Denis , D20-Den-1 ) ;
32855: LD_EXP 46
32859: PPUSH
32860: LD_STRING D20-Den-1
32862: PPUSH
32863: CALL_OW 88
// if IsOk ( Bobby ) then
32867: LD_EXP 44
32871: PPUSH
32872: CALL_OW 302
32876: IFFALSE 32890
// Say ( Bobby , D20-Bobby-1 ) ;
32878: LD_EXP 44
32882: PPUSH
32883: LD_STRING D20-Bobby-1
32885: PPUSH
32886: CALL_OW 88
// if IsOk ( Gladstone ) then
32890: LD_EXP 48
32894: PPUSH
32895: CALL_OW 302
32899: IFFALSE 32913
// Say ( Gladstone , D20-Glad-1 ) ;
32901: LD_EXP 48
32905: PPUSH
32906: LD_STRING D20-Glad-1
32908: PPUSH
32909: CALL_OW 88
// if IsOk ( Cyrus ) then
32913: LD_EXP 45
32917: PPUSH
32918: CALL_OW 302
32922: IFFALSE 32936
// Say ( Cyrus , D20-Cyrus-1 ) ;
32924: LD_EXP 45
32928: PPUSH
32929: LD_STRING D20-Cyrus-1
32931: PPUSH
32932: CALL_OW 88
// if IsOk ( Stevens ) then
32936: LD_EXP 41
32940: PPUSH
32941: CALL_OW 302
32945: IFFALSE 32959
// Say ( Stevens , D20-Huck-1 ) ;
32947: LD_EXP 41
32951: PPUSH
32952: LD_STRING D20-Huck-1
32954: PPUSH
32955: CALL_OW 88
// if IsOk ( Brown ) then
32959: LD_EXP 47
32963: PPUSH
32964: CALL_OW 302
32968: IFFALSE 32982
// Say ( Brown , D20-Brown-1 ) ;
32970: LD_EXP 47
32974: PPUSH
32975: LD_STRING D20-Brown-1
32977: PPUSH
32978: CALL_OW 88
// if IsOk ( Gary ) then
32982: LD_EXP 51
32986: PPUSH
32987: CALL_OW 302
32991: IFFALSE 33005
// Say ( Gary , D20-Gary-1 ) ;
32993: LD_EXP 51
32997: PPUSH
32998: LD_STRING D20-Gary-1
33000: PPUSH
33001: CALL_OW 88
// if IsOk ( Connie ) then
33005: LD_EXP 54
33009: PPUSH
33010: CALL_OW 302
33014: IFFALSE 33028
// Say ( Connie , D20-Con-1 ) ;
33016: LD_EXP 54
33020: PPUSH
33021: LD_STRING D20-Con-1
33023: PPUSH
33024: CALL_OW 88
// if IsOk ( Kurt ) then
33028: LD_EXP 60
33032: PPUSH
33033: CALL_OW 302
33037: IFFALSE 33051
// Say ( Kurt , D20-Kurt-1 ) ;
33039: LD_EXP 60
33043: PPUSH
33044: LD_STRING D20-Kurt-1
33046: PPUSH
33047: CALL_OW 88
// if IsOk ( Kikuchi ) then
33051: LD_EXP 53
33055: PPUSH
33056: CALL_OW 302
33060: IFFALSE 33074
// Say ( Kikuchi , D20-Yam-1 ) ;
33062: LD_EXP 53
33066: PPUSH
33067: LD_STRING D20-Yam-1
33069: PPUSH
33070: CALL_OW 88
// if IsOk ( Frank ) then
33074: LD_EXP 52
33078: PPUSH
33079: CALL_OW 302
33083: IFFALSE 33097
// Say ( Frank , D20-Frank-1 ) ;
33085: LD_EXP 52
33089: PPUSH
33090: LD_STRING D20-Frank-1
33092: PPUSH
33093: CALL_OW 88
// DialogueOff ;
33097: CALL_OW 7
// if RothCaptured then
33101: LD_EXP 33
33105: IFFALSE 33127
// begin m1 := true ;
33107: LD_ADDR_VAR 0 1
33111: PUSH
33112: LD_INT 1
33114: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33115: LD_STRING Roth
33117: PPUSH
33118: LD_INT 1
33120: PPUSH
33121: CALL_OW 101
// end else
33125: GO 33138
// AddMedal ( Roth , - 1 ) ;
33127: LD_STRING Roth
33129: PPUSH
33130: LD_INT 1
33132: NEG
33133: PPUSH
33134: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33138: LD_EXP 27
33142: IFFALSE 33164
// begin m2 := true ;
33144: LD_ADDR_VAR 0 2
33148: PUSH
33149: LD_INT 1
33151: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33152: LD_STRING Project
33154: PPUSH
33155: LD_INT 1
33157: PPUSH
33158: CALL_OW 101
// end else
33162: GO 33175
// AddMedal ( Project , - 1 ) ;
33164: LD_STRING Project
33166: PPUSH
33167: LD_INT 1
33169: NEG
33170: PPUSH
33171: CALL_OW 101
// if lostCounter = 0 then
33175: LD_EXP 32
33179: PUSH
33180: LD_INT 0
33182: EQUAL
33183: IFFALSE 33205
// begin m3 := true ;
33185: LD_ADDR_VAR 0 3
33189: PUSH
33190: LD_INT 1
33192: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33193: LD_STRING NoLosses
33195: PPUSH
33196: LD_INT 1
33198: PPUSH
33199: CALL_OW 101
// end else
33203: GO 33216
// AddMedal ( NoLosses , - 1 ) ;
33205: LD_STRING NoLosses
33207: PPUSH
33208: LD_INT 1
33210: NEG
33211: PPUSH
33212: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33216: LD_VAR 0 1
33220: PUSH
33221: LD_VAR 0 2
33225: AND
33226: PUSH
33227: LD_VAR 0 3
33231: AND
33232: PUSH
33233: LD_OWVAR 67
33237: PUSH
33238: LD_INT 3
33240: EQUAL
33241: AND
33242: IFFALSE 33254
// SetAchievementEX ( ACH_AMER , 15 ) ;
33244: LD_STRING ACH_AMER
33246: PPUSH
33247: LD_INT 15
33249: PPUSH
33250: CALL_OW 564
// GiveMedals ( MAIN ) ;
33254: LD_STRING MAIN
33256: PPUSH
33257: CALL_OW 102
// music_class := 4 ;
33261: LD_ADDR_OWVAR 72
33265: PUSH
33266: LD_INT 4
33268: ST_TO_ADDR
// music_nat := 1 ;
33269: LD_ADDR_OWVAR 71
33273: PUSH
33274: LD_INT 1
33276: ST_TO_ADDR
// YouWin ;
33277: CALL_OW 103
// end ; end_of_file
33281: PPOPN 3
33283: END
// export function CustomEvent ( event ) ; begin
33284: LD_INT 0
33286: PPUSH
// end ;
33287: LD_VAR 0 2
33291: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33292: LD_VAR 0 1
33296: PUSH
33297: LD_INT 1
33299: EQUAL
33300: PUSH
33301: LD_VAR 0 2
33305: PUSH
33306: LD_INT 4
33308: EQUAL
33309: AND
33310: PUSH
33311: LD_EXP 58
33315: PPUSH
33316: CALL_OW 300
33320: AND
33321: IFFALSE 33337
// begin wait ( 0 0$2 ) ;
33323: LD_INT 70
33325: PPUSH
33326: CALL_OW 67
// YouLost ( Dismissed ) ;
33330: LD_STRING Dismissed
33332: PPUSH
33333: CALL_OW 104
// end ; end ;
33337: PPOPN 2
33339: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33340: LD_VAR 0 2
33344: PPUSH
33345: LD_VAR 0 3
33349: PPUSH
33350: LD_INT 18
33352: PPUSH
33353: CALL_OW 309
33357: IFFALSE 33366
// YouLost ( Motherlode3 ) ;
33359: LD_STRING Motherlode3
33361: PPUSH
33362: CALL_OW 104
// end ;
33366: PPOPN 3
33368: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33369: LD_EXP 27
33373: NOT
33374: IFFALSE 33384
// behemothDone := true ;
33376: LD_ADDR_EXP 28
33380: PUSH
33381: LD_INT 1
33383: ST_TO_ADDR
// end ;
33384: PPOPN 1
33386: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33387: LD_VAR 0 1
33391: PPUSH
33392: CALL_OW 255
33396: PUSH
33397: LD_INT 1
33399: EQUAL
33400: IFFALSE 33410
// bombExploded := true ;
33402: LD_ADDR_EXP 37
33406: PUSH
33407: LD_INT 1
33409: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33410: LD_VAR 0 1
33414: PPUSH
33415: CALL_OW 255
33419: PUSH
33420: LD_INT 1
33422: EQUAL
33423: PUSH
33424: LD_EXP 30
33428: AND
33429: PUSH
33430: LD_INT 22
33432: PUSH
33433: LD_INT 3
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 34
33442: PUSH
33443: LD_INT 48
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PPUSH
33454: CALL_OW 69
33458: AND
33459: PUSH
33460: LD_INT 22
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 34
33472: PUSH
33473: LD_INT 8
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PPUSH
33484: CALL_OW 69
33488: NOT
33489: AND
33490: IFFALSE 33542
// begin wait ( 0 0$5 ) ;
33492: LD_INT 175
33494: PPUSH
33495: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33499: LD_INT 22
33501: PUSH
33502: LD_INT 3
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 34
33511: PUSH
33512: LD_INT 48
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PPUSH
33523: CALL_OW 69
33527: PUSH
33528: LD_INT 1
33530: ARRAY
33531: PPUSH
33532: LD_INT 60
33534: PPUSH
33535: LD_INT 95
33537: PPUSH
33538: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33542: LD_VAR 0 2
33546: PPUSH
33547: LD_VAR 0 3
33551: PPUSH
33552: LD_INT 18
33554: PPUSH
33555: CALL_OW 309
33559: IFFALSE 33619
// begin if GetSide ( unit ) = 1 then
33561: LD_VAR 0 1
33565: PPUSH
33566: CALL_OW 255
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: IFFALSE 33590
// begin wait ( 0 0$6 ) ;
33576: LD_INT 210
33578: PPUSH
33579: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33583: LD_STRING Motherlode2
33585: PPUSH
33586: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33590: LD_VAR 0 1
33594: PPUSH
33595: CALL_OW 255
33599: PUSH
33600: LD_INT 8
33602: EQUAL
33603: IFFALSE 33619
// begin wait ( 0 0$6 ) ;
33605: LD_INT 210
33607: PPUSH
33608: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33612: LD_STRING Motherlode1
33614: PPUSH
33615: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33619: LD_VAR 0 1
33623: PPUSH
33624: CALL_OW 255
33628: PUSH
33629: LD_INT 3
33631: EQUAL
33632: IFFALSE 33653
// begin wait ( 0 0$5 ) ;
33634: LD_INT 175
33636: PPUSH
33637: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33641: LD_EXP 64
33645: PPUSH
33646: LD_STRING D18-Pla-1
33648: PPUSH
33649: CALL_OW 94
// end ; end ;
33653: PPOPN 3
33655: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33656: LD_VAR 0 1
33660: PUSH
33661: LD_EXP 73
33665: IN
33666: IFFALSE 33686
// begin behemothBuilders := behemothBuilders diff un ;
33668: LD_ADDR_EXP 73
33672: PUSH
33673: LD_EXP 73
33677: PUSH
33678: LD_VAR 0 1
33682: DIFF
33683: ST_TO_ADDR
// exit ;
33684: GO 33784
// end ; if un = JMM then
33686: LD_VAR 0 1
33690: PUSH
33691: LD_EXP 39
33695: EQUAL
33696: IFFALSE 33707
// begin YouLost ( JMM ) ;
33698: LD_STRING JMM
33700: PPUSH
33701: CALL_OW 104
// exit ;
33705: GO 33784
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33707: LD_VAR 0 1
33711: PUSH
33712: LD_INT 22
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 3
33724: PUSH
33725: LD_INT 25
33727: PUSH
33728: LD_INT 16
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 25
33737: PUSH
33738: LD_INT 12
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: LIST
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PPUSH
33754: CALL_OW 69
33758: IN
33759: IFFALSE 33775
// lostCounter := lostCounter + 1 ;
33761: LD_ADDR_EXP 32
33765: PUSH
33766: LD_EXP 32
33770: PUSH
33771: LD_INT 1
33773: PLUS
33774: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33775: LD_VAR 0 1
33779: PPUSH
33780: CALL 61964 0 1
// end ;
33784: PPOPN 1
33786: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33787: LD_VAR 0 1
33791: PPUSH
33792: LD_VAR 0 2
33796: PPUSH
33797: CALL 64298 0 2
// end ;
33801: PPOPN 2
33803: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33804: LD_VAR 0 1
33808: PPUSH
33809: CALL 63366 0 1
// end ;
33813: PPOPN 1
33815: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33816: LD_VAR 0 1
33820: PUSH
33821: LD_INT 22
33823: PUSH
33824: LD_INT 8
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 30
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 23
33843: PUSH
33844: LD_INT 3
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: LIST
33855: PPUSH
33856: CALL_OW 69
33860: IN
33861: IFFALSE 33888
// begin ComUpgrade ( building ) ;
33863: LD_VAR 0 1
33867: PPUSH
33868: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33872: LD_EXP 61
33876: PPUSH
33877: LD_VAR 0 1
33881: PPUSH
33882: CALL 75064 0 2
// exit ;
33886: GO 33897
// end ; MCE_BuildingComplete ( building ) ;
33888: LD_VAR 0 1
33892: PPUSH
33893: CALL 63607 0 1
// end ;
33897: PPOPN 1
33899: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33900: LD_VAR 0 1
33904: PPUSH
33905: LD_VAR 0 2
33909: PPUSH
33910: CALL 61660 0 2
// end ;
33914: PPOPN 2
33916: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33917: LD_VAR 0 1
33921: PPUSH
33922: LD_VAR 0 2
33926: PPUSH
33927: LD_VAR 0 3
33931: PPUSH
33932: LD_VAR 0 4
33936: PPUSH
33937: LD_VAR 0 5
33941: PPUSH
33942: CALL 61280 0 5
// end ;
33946: PPOPN 5
33948: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33949: LD_VAR 0 1
33953: PPUSH
33954: LD_VAR 0 2
33958: PPUSH
33959: CALL 60876 0 2
// end ;
33963: PPOPN 2
33965: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33966: LD_VAR 0 1
33970: PPUSH
33971: LD_VAR 0 2
33975: PPUSH
33976: LD_VAR 0 3
33980: PPUSH
33981: LD_VAR 0 4
33985: PPUSH
33986: CALL 60714 0 4
// end ;
33990: PPOPN 4
33992: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: LD_VAR 0 3
34007: PPUSH
34008: CALL 60489 0 3
// end ;
34012: PPOPN 3
34014: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34015: LD_VAR 0 1
34019: PPUSH
34020: LD_VAR 0 2
34024: PPUSH
34025: CALL 60374 0 2
// end ;
34029: PPOPN 2
34031: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34032: LD_VAR 0 1
34036: PPUSH
34037: LD_VAR 0 2
34041: PPUSH
34042: CALL 64559 0 2
// end ;
34046: PPOPN 2
34048: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34049: LD_VAR 0 1
34053: PPUSH
34054: CALL_OW 255
34058: PUSH
34059: LD_INT 4
34061: EQUAL
34062: PUSH
34063: LD_VAR 0 1
34067: PUSH
34068: LD_EXP 18
34072: PUSH
34073: LD_INT 1
34075: ARRAY
34076: IN
34077: AND
34078: PUSH
34079: LD_EXP 19
34083: AND
34084: IFFALSE 34103
// begin ComMoveXY ( driver , 61 , 93 ) ;
34086: LD_VAR 0 1
34090: PPUSH
34091: LD_INT 61
34093: PPUSH
34094: LD_INT 93
34096: PPUSH
34097: CALL_OW 111
// exit ;
34101: GO 34127
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34103: LD_VAR 0 1
34107: PPUSH
34108: LD_VAR 0 2
34112: PPUSH
34113: LD_VAR 0 3
34117: PPUSH
34118: LD_VAR 0 4
34122: PPUSH
34123: CALL 64775 0 4
// end ;
34127: PPOPN 4
34129: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34130: LD_VAR 0 1
34134: PPUSH
34135: LD_VAR 0 2
34139: PPUSH
34140: CALL 60183 0 2
// end ;
34144: PPOPN 2
34146: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34147: LD_VAR 0 1
34151: PPUSH
34152: CALL 119093 0 1
// end ; end_of_file
34156: PPOPN 1
34158: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34159: LD_EXP 15
34163: PUSH
34164: LD_INT 2
34166: EQUAL
34167: IFFALSE 34646
34169: GO 34171
34171: DISABLE
34172: LD_INT 0
34174: PPUSH
// begin time := 0 0$40 ;
34175: LD_ADDR_VAR 0 1
34179: PUSH
34180: LD_INT 1400
34182: ST_TO_ADDR
// repeat wait ( time ) ;
34183: LD_VAR 0 1
34187: PPUSH
34188: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34192: LD_INT 1
34194: PPUSH
34195: LD_INT 5
34197: PPUSH
34198: CALL_OW 12
34202: PPUSH
34203: LD_INT 106
34205: PPUSH
34206: LD_INT 150
34208: PPUSH
34209: LD_INT 19
34211: PPUSH
34212: LD_INT 1
34214: PPUSH
34215: CALL_OW 56
// time := time + 0 0$9 ;
34219: LD_ADDR_VAR 0 1
34223: PUSH
34224: LD_VAR 0 1
34228: PUSH
34229: LD_INT 315
34231: PLUS
34232: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34233: LD_INT 455
34235: PPUSH
34236: LD_INT 840
34238: PPUSH
34239: CALL_OW 12
34243: PPUSH
34244: CALL_OW 67
// if Prob ( 50 ) then
34248: LD_INT 50
34250: PPUSH
34251: CALL_OW 13
34255: IFFALSE 34284
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34257: LD_INT 1
34259: PPUSH
34260: LD_INT 5
34262: PPUSH
34263: CALL_OW 12
34267: PPUSH
34268: LD_INT 62
34270: PPUSH
34271: LD_INT 108
34273: PPUSH
34274: LD_INT 10
34276: PPUSH
34277: LD_INT 1
34279: PPUSH
34280: CALL_OW 56
// until missionStage > 4 ;
34284: LD_EXP 15
34288: PUSH
34289: LD_INT 4
34291: GREATER
34292: IFFALSE 34183
// repeat wait ( 0 0$1 ) ;
34294: LD_INT 35
34296: PPUSH
34297: CALL_OW 67
// until missionStage = 6 ;
34301: LD_EXP 15
34305: PUSH
34306: LD_INT 6
34308: EQUAL
34309: IFFALSE 34294
// time := 0 0$50 ;
34311: LD_ADDR_VAR 0 1
34315: PUSH
34316: LD_INT 1750
34318: ST_TO_ADDR
// repeat wait ( time ) ;
34319: LD_VAR 0 1
34323: PPUSH
34324: CALL_OW 67
// if Prob ( 50 ) then
34328: LD_INT 50
34330: PPUSH
34331: CALL_OW 13
34335: IFFALSE 34364
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34337: LD_INT 1
34339: PPUSH
34340: LD_INT 5
34342: PPUSH
34343: CALL_OW 12
34347: PPUSH
34348: LD_INT 106
34350: PPUSH
34351: LD_INT 89
34353: PPUSH
34354: LD_INT 45
34356: PPUSH
34357: LD_INT 1
34359: PPUSH
34360: CALL_OW 56
// time := time + 0 0$2 ;
34364: LD_ADDR_VAR 0 1
34368: PUSH
34369: LD_VAR 0 1
34373: PUSH
34374: LD_INT 70
34376: PLUS
34377: ST_TO_ADDR
// if Prob ( 30 ) then
34378: LD_INT 30
34380: PPUSH
34381: CALL_OW 13
34385: IFFALSE 34431
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34387: LD_INT 385
34389: PPUSH
34390: LD_INT 945
34392: PPUSH
34393: CALL_OW 12
34397: PPUSH
34398: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34402: LD_INT 1
34404: PPUSH
34405: LD_INT 5
34407: PPUSH
34408: CALL_OW 12
34412: PPUSH
34413: LD_INT 21
34415: PPUSH
34416: LD_INT 26
34418: PPUSH
34419: LD_INT 12
34421: PPUSH
34422: LD_INT 1
34424: PPUSH
34425: CALL_OW 56
// end else
34429: GO 34467
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34431: LD_INT 700
34433: PPUSH
34434: LD_INT 1225
34436: PPUSH
34437: CALL_OW 12
34441: PPUSH
34442: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34446: LD_INT 1
34448: PPUSH
34449: LD_INT 5
34451: PPUSH
34452: CALL_OW 12
34456: PPUSH
34457: LD_INT 16
34459: PPUSH
34460: LD_INT 1
34462: PPUSH
34463: CALL_OW 55
// end ; if Prob ( 50 ) then
34467: LD_INT 50
34469: PPUSH
34470: CALL_OW 13
34474: IFFALSE 34520
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34476: LD_INT 700
34478: PPUSH
34479: LD_INT 1050
34481: PPUSH
34482: CALL_OW 12
34486: PPUSH
34487: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34491: LD_INT 1
34493: PPUSH
34494: LD_INT 5
34496: PPUSH
34497: CALL_OW 12
34501: PPUSH
34502: LD_INT 181
34504: PPUSH
34505: LD_INT 218
34507: PPUSH
34508: LD_INT 16
34510: PPUSH
34511: LD_INT 1
34513: PPUSH
34514: CALL_OW 56
// end else
34518: GO 34556
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34520: LD_INT 350
34522: PPUSH
34523: LD_INT 525
34525: PPUSH
34526: CALL_OW 12
34530: PPUSH
34531: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34535: LD_INT 1
34537: PPUSH
34538: LD_INT 5
34540: PPUSH
34541: CALL_OW 12
34545: PPUSH
34546: LD_INT 15
34548: PPUSH
34549: LD_INT 1
34551: PPUSH
34552: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34556: LD_INT 45
34558: PUSH
34559: LD_INT 32
34561: PUSH
34562: LD_INT 25
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: LIST
34569: PUSH
34570: LD_OWVAR 67
34574: ARRAY
34575: PPUSH
34576: CALL_OW 13
34580: IFFALSE 34624
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34582: LD_INT 175
34584: PPUSH
34585: LD_INT 315
34587: PPUSH
34588: CALL_OW 12
34592: PPUSH
34593: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34597: LD_INT 1
34599: PPUSH
34600: LD_INT 5
34602: PPUSH
34603: CALL_OW 12
34607: PPUSH
34608: LD_INT 103
34610: PPUSH
34611: LD_INT 140
34613: PPUSH
34614: LD_INT 20
34616: PPUSH
34617: LD_INT 1
34619: PPUSH
34620: CALL_OW 56
// end ; if time > 1 1$20 then
34624: LD_VAR 0 1
34628: PUSH
34629: LD_INT 2800
34631: GREATER
34632: IFFALSE 34642
// time := 0 0$30 ;
34634: LD_ADDR_VAR 0 1
34638: PUSH
34639: LD_INT 1050
34641: ST_TO_ADDR
// until false ;
34642: LD_INT 0
34644: IFFALSE 34319
// end ; end_of_file
34646: PPOPN 1
34648: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34649: LD_EXP 13
34653: PUSH
34654: LD_EXP 15
34658: PUSH
34659: LD_INT 6
34661: GREATEREQUAL
34662: AND
34663: IFFALSE 34700
34665: GO 34667
34667: DISABLE
// begin enable ;
34668: ENABLE
// missionTime := missionTime + 0 0$1 ;
34669: LD_ADDR_EXP 14
34673: PUSH
34674: LD_EXP 14
34678: PUSH
34679: LD_INT 35
34681: PLUS
34682: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34683: LD_ADDR_OWVAR 47
34687: PUSH
34688: LD_STRING #Am15-1
34690: PUSH
34691: LD_EXP 14
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: ST_TO_ADDR
// end ; end_of_file
34700: END
// export function InitNature ; begin
34701: LD_INT 0
34703: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34704: LD_INT 3
34706: PPUSH
34707: LD_INT 3
34709: PPUSH
34710: LD_INT 2
34712: PPUSH
34713: LD_INT 1
34715: PPUSH
34716: LD_INT 1
34718: PPUSH
34719: LD_INT 0
34721: PPUSH
34722: LD_INT 0
34724: PPUSH
34725: LD_INT 20
34727: PPUSH
34728: LD_INT 0
34730: PPUSH
34731: CALL 99882 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34735: LD_INT 2
34737: PPUSH
34738: LD_INT 1
34740: PPUSH
34741: LD_INT 1
34743: PPUSH
34744: LD_INT 1
34746: PPUSH
34747: LD_INT 1
34749: PPUSH
34750: LD_INT 0
34752: PPUSH
34753: LD_INT 0
34755: PPUSH
34756: LD_INT 21
34758: PPUSH
34759: LD_INT 0
34761: PPUSH
34762: CALL 99882 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34766: LD_INT 4
34768: PPUSH
34769: LD_INT 1
34771: PPUSH
34772: LD_INT 2
34774: PPUSH
34775: LD_INT 4
34777: PPUSH
34778: LD_INT 2
34780: PPUSH
34781: LD_INT 1
34783: PPUSH
34784: LD_INT 0
34786: PPUSH
34787: LD_INT 22
34789: PPUSH
34790: LD_INT 0
34792: PPUSH
34793: CALL 99882 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34797: LD_INT 0
34799: PPUSH
34800: LD_INT 0
34802: PPUSH
34803: LD_INT 0
34805: PPUSH
34806: LD_INT 0
34808: PPUSH
34809: LD_INT 0
34811: PPUSH
34812: LD_INT 0
34814: PPUSH
34815: LD_INT 9
34817: PPUSH
34818: LD_INT 0
34820: PPUSH
34821: LD_INT 23
34823: PPUSH
34824: CALL 99882 0 9
// end ; end_of_file
34828: LD_VAR 0 1
34832: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34833: GO 34835
34835: DISABLE
// begin ru_radar := 98 ;
34836: LD_ADDR_EXP 95
34840: PUSH
34841: LD_INT 98
34843: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34844: LD_ADDR_EXP 96
34848: PUSH
34849: LD_INT 89
34851: ST_TO_ADDR
// us_hack := 99 ;
34852: LD_ADDR_EXP 97
34856: PUSH
34857: LD_INT 99
34859: ST_TO_ADDR
// us_artillery := 97 ;
34860: LD_ADDR_EXP 98
34864: PUSH
34865: LD_INT 97
34867: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34868: LD_ADDR_EXP 99
34872: PUSH
34873: LD_INT 91
34875: ST_TO_ADDR
// end ; end_of_file
34876: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34877: LD_INT 0
34879: PPUSH
34880: PPUSH
// skirmish := false ;
34881: LD_ADDR_EXP 100
34885: PUSH
34886: LD_INT 0
34888: ST_TO_ADDR
// debug_mc := false ;
34889: LD_ADDR_EXP 101
34893: PUSH
34894: LD_INT 0
34896: ST_TO_ADDR
// mc_bases := [ ] ;
34897: LD_ADDR_EXP 102
34901: PUSH
34902: EMPTY
34903: ST_TO_ADDR
// mc_sides := [ ] ;
34904: LD_ADDR_EXP 128
34908: PUSH
34909: EMPTY
34910: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34911: LD_ADDR_EXP 103
34915: PUSH
34916: EMPTY
34917: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34918: LD_ADDR_EXP 104
34922: PUSH
34923: EMPTY
34924: ST_TO_ADDR
// mc_need_heal := [ ] ;
34925: LD_ADDR_EXP 105
34929: PUSH
34930: EMPTY
34931: ST_TO_ADDR
// mc_healers := [ ] ;
34932: LD_ADDR_EXP 106
34936: PUSH
34937: EMPTY
34938: ST_TO_ADDR
// mc_build_list := [ ] ;
34939: LD_ADDR_EXP 107
34943: PUSH
34944: EMPTY
34945: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34946: LD_ADDR_EXP 134
34950: PUSH
34951: EMPTY
34952: ST_TO_ADDR
// mc_builders := [ ] ;
34953: LD_ADDR_EXP 108
34957: PUSH
34958: EMPTY
34959: ST_TO_ADDR
// mc_construct_list := [ ] ;
34960: LD_ADDR_EXP 109
34964: PUSH
34965: EMPTY
34966: ST_TO_ADDR
// mc_turret_list := [ ] ;
34967: LD_ADDR_EXP 110
34971: PUSH
34972: EMPTY
34973: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34974: LD_ADDR_EXP 111
34978: PUSH
34979: EMPTY
34980: ST_TO_ADDR
// mc_miners := [ ] ;
34981: LD_ADDR_EXP 116
34985: PUSH
34986: EMPTY
34987: ST_TO_ADDR
// mc_mines := [ ] ;
34988: LD_ADDR_EXP 115
34992: PUSH
34993: EMPTY
34994: ST_TO_ADDR
// mc_minefields := [ ] ;
34995: LD_ADDR_EXP 117
34999: PUSH
35000: EMPTY
35001: ST_TO_ADDR
// mc_crates := [ ] ;
35002: LD_ADDR_EXP 118
35006: PUSH
35007: EMPTY
35008: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35009: LD_ADDR_EXP 119
35013: PUSH
35014: EMPTY
35015: ST_TO_ADDR
// mc_crates_area := [ ] ;
35016: LD_ADDR_EXP 120
35020: PUSH
35021: EMPTY
35022: ST_TO_ADDR
// mc_vehicles := [ ] ;
35023: LD_ADDR_EXP 121
35027: PUSH
35028: EMPTY
35029: ST_TO_ADDR
// mc_attack := [ ] ;
35030: LD_ADDR_EXP 122
35034: PUSH
35035: EMPTY
35036: ST_TO_ADDR
// mc_produce := [ ] ;
35037: LD_ADDR_EXP 123
35041: PUSH
35042: EMPTY
35043: ST_TO_ADDR
// mc_defender := [ ] ;
35044: LD_ADDR_EXP 124
35048: PUSH
35049: EMPTY
35050: ST_TO_ADDR
// mc_parking := [ ] ;
35051: LD_ADDR_EXP 126
35055: PUSH
35056: EMPTY
35057: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35058: LD_ADDR_EXP 112
35062: PUSH
35063: EMPTY
35064: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35065: LD_ADDR_EXP 114
35069: PUSH
35070: EMPTY
35071: ST_TO_ADDR
// mc_scan := [ ] ;
35072: LD_ADDR_EXP 125
35076: PUSH
35077: EMPTY
35078: ST_TO_ADDR
// mc_scan_area := [ ] ;
35079: LD_ADDR_EXP 127
35083: PUSH
35084: EMPTY
35085: ST_TO_ADDR
// mc_tech := [ ] ;
35086: LD_ADDR_EXP 129
35090: PUSH
35091: EMPTY
35092: ST_TO_ADDR
// mc_class := [ ] ;
35093: LD_ADDR_EXP 143
35097: PUSH
35098: EMPTY
35099: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35100: LD_ADDR_EXP 144
35104: PUSH
35105: EMPTY
35106: ST_TO_ADDR
// end ;
35107: LD_VAR 0 1
35111: RET
// export function MC_Kill ( base ) ; begin
35112: LD_INT 0
35114: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35115: LD_ADDR_EXP 102
35119: PUSH
35120: LD_EXP 102
35124: PPUSH
35125: LD_VAR 0 1
35129: PPUSH
35130: EMPTY
35131: PPUSH
35132: CALL_OW 1
35136: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35137: LD_ADDR_EXP 103
35141: PUSH
35142: LD_EXP 103
35146: PPUSH
35147: LD_VAR 0 1
35151: PPUSH
35152: EMPTY
35153: PPUSH
35154: CALL_OW 1
35158: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35159: LD_ADDR_EXP 104
35163: PUSH
35164: LD_EXP 104
35168: PPUSH
35169: LD_VAR 0 1
35173: PPUSH
35174: EMPTY
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35181: LD_ADDR_EXP 105
35185: PUSH
35186: LD_EXP 105
35190: PPUSH
35191: LD_VAR 0 1
35195: PPUSH
35196: EMPTY
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35203: LD_ADDR_EXP 106
35207: PUSH
35208: LD_EXP 106
35212: PPUSH
35213: LD_VAR 0 1
35217: PPUSH
35218: EMPTY
35219: PPUSH
35220: CALL_OW 1
35224: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35225: LD_ADDR_EXP 107
35229: PUSH
35230: LD_EXP 107
35234: PPUSH
35235: LD_VAR 0 1
35239: PPUSH
35240: EMPTY
35241: PPUSH
35242: CALL_OW 1
35246: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35247: LD_ADDR_EXP 108
35251: PUSH
35252: LD_EXP 108
35256: PPUSH
35257: LD_VAR 0 1
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35269: LD_ADDR_EXP 109
35273: PUSH
35274: LD_EXP 109
35278: PPUSH
35279: LD_VAR 0 1
35283: PPUSH
35284: EMPTY
35285: PPUSH
35286: CALL_OW 1
35290: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35291: LD_ADDR_EXP 110
35295: PUSH
35296: LD_EXP 110
35300: PPUSH
35301: LD_VAR 0 1
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35313: LD_ADDR_EXP 111
35317: PUSH
35318: LD_EXP 111
35322: PPUSH
35323: LD_VAR 0 1
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35335: LD_ADDR_EXP 112
35339: PUSH
35340: LD_EXP 112
35344: PPUSH
35345: LD_VAR 0 1
35349: PPUSH
35350: EMPTY
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35357: LD_ADDR_EXP 113
35361: PUSH
35362: LD_EXP 113
35366: PPUSH
35367: LD_VAR 0 1
35371: PPUSH
35372: LD_INT 0
35374: PPUSH
35375: CALL_OW 1
35379: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35380: LD_ADDR_EXP 114
35384: PUSH
35385: LD_EXP 114
35389: PPUSH
35390: LD_VAR 0 1
35394: PPUSH
35395: EMPTY
35396: PPUSH
35397: CALL_OW 1
35401: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35402: LD_ADDR_EXP 115
35406: PUSH
35407: LD_EXP 115
35411: PPUSH
35412: LD_VAR 0 1
35416: PPUSH
35417: EMPTY
35418: PPUSH
35419: CALL_OW 1
35423: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35424: LD_ADDR_EXP 116
35428: PUSH
35429: LD_EXP 116
35433: PPUSH
35434: LD_VAR 0 1
35438: PPUSH
35439: EMPTY
35440: PPUSH
35441: CALL_OW 1
35445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35446: LD_ADDR_EXP 117
35450: PUSH
35451: LD_EXP 117
35455: PPUSH
35456: LD_VAR 0 1
35460: PPUSH
35461: EMPTY
35462: PPUSH
35463: CALL_OW 1
35467: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35468: LD_ADDR_EXP 118
35472: PUSH
35473: LD_EXP 118
35477: PPUSH
35478: LD_VAR 0 1
35482: PPUSH
35483: EMPTY
35484: PPUSH
35485: CALL_OW 1
35489: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35490: LD_ADDR_EXP 119
35494: PUSH
35495: LD_EXP 119
35499: PPUSH
35500: LD_VAR 0 1
35504: PPUSH
35505: EMPTY
35506: PPUSH
35507: CALL_OW 1
35511: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35512: LD_ADDR_EXP 120
35516: PUSH
35517: LD_EXP 120
35521: PPUSH
35522: LD_VAR 0 1
35526: PPUSH
35527: EMPTY
35528: PPUSH
35529: CALL_OW 1
35533: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35534: LD_ADDR_EXP 121
35538: PUSH
35539: LD_EXP 121
35543: PPUSH
35544: LD_VAR 0 1
35548: PPUSH
35549: EMPTY
35550: PPUSH
35551: CALL_OW 1
35555: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35556: LD_ADDR_EXP 122
35560: PUSH
35561: LD_EXP 122
35565: PPUSH
35566: LD_VAR 0 1
35570: PPUSH
35571: EMPTY
35572: PPUSH
35573: CALL_OW 1
35577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35578: LD_ADDR_EXP 123
35582: PUSH
35583: LD_EXP 123
35587: PPUSH
35588: LD_VAR 0 1
35592: PPUSH
35593: EMPTY
35594: PPUSH
35595: CALL_OW 1
35599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35600: LD_ADDR_EXP 124
35604: PUSH
35605: LD_EXP 124
35609: PPUSH
35610: LD_VAR 0 1
35614: PPUSH
35615: EMPTY
35616: PPUSH
35617: CALL_OW 1
35621: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35622: LD_ADDR_EXP 125
35626: PUSH
35627: LD_EXP 125
35631: PPUSH
35632: LD_VAR 0 1
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35644: LD_ADDR_EXP 126
35648: PUSH
35649: LD_EXP 126
35653: PPUSH
35654: LD_VAR 0 1
35658: PPUSH
35659: EMPTY
35660: PPUSH
35661: CALL_OW 1
35665: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35666: LD_ADDR_EXP 127
35670: PUSH
35671: LD_EXP 127
35675: PPUSH
35676: LD_VAR 0 1
35680: PPUSH
35681: EMPTY
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35688: LD_ADDR_EXP 129
35692: PUSH
35693: LD_EXP 129
35697: PPUSH
35698: LD_VAR 0 1
35702: PPUSH
35703: EMPTY
35704: PPUSH
35705: CALL_OW 1
35709: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35710: LD_ADDR_EXP 131
35714: PUSH
35715: LD_EXP 131
35719: PPUSH
35720: LD_VAR 0 1
35724: PPUSH
35725: EMPTY
35726: PPUSH
35727: CALL_OW 1
35731: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35732: LD_ADDR_EXP 132
35736: PUSH
35737: LD_EXP 132
35741: PPUSH
35742: LD_VAR 0 1
35746: PPUSH
35747: EMPTY
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35754: LD_ADDR_EXP 133
35758: PUSH
35759: LD_EXP 133
35763: PPUSH
35764: LD_VAR 0 1
35768: PPUSH
35769: EMPTY
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35776: LD_ADDR_EXP 134
35780: PUSH
35781: LD_EXP 134
35785: PPUSH
35786: LD_VAR 0 1
35790: PPUSH
35791: EMPTY
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35798: LD_ADDR_EXP 135
35802: PUSH
35803: LD_EXP 135
35807: PPUSH
35808: LD_VAR 0 1
35812: PPUSH
35813: EMPTY
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35820: LD_ADDR_EXP 136
35824: PUSH
35825: LD_EXP 136
35829: PPUSH
35830: LD_VAR 0 1
35834: PPUSH
35835: EMPTY
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35842: LD_ADDR_EXP 137
35846: PUSH
35847: LD_EXP 137
35851: PPUSH
35852: LD_VAR 0 1
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35864: LD_ADDR_EXP 138
35868: PUSH
35869: LD_EXP 138
35873: PPUSH
35874: LD_VAR 0 1
35878: PPUSH
35879: EMPTY
35880: PPUSH
35881: CALL_OW 1
35885: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35886: LD_ADDR_EXP 139
35890: PUSH
35891: LD_EXP 139
35895: PPUSH
35896: LD_VAR 0 1
35900: PPUSH
35901: EMPTY
35902: PPUSH
35903: CALL_OW 1
35907: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35908: LD_ADDR_EXP 140
35912: PUSH
35913: LD_EXP 140
35917: PPUSH
35918: LD_VAR 0 1
35922: PPUSH
35923: EMPTY
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35930: LD_ADDR_EXP 141
35934: PUSH
35935: LD_EXP 141
35939: PPUSH
35940: LD_VAR 0 1
35944: PPUSH
35945: EMPTY
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35952: LD_ADDR_EXP 142
35956: PUSH
35957: LD_EXP 142
35961: PPUSH
35962: LD_VAR 0 1
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35974: LD_ADDR_EXP 143
35978: PUSH
35979: LD_EXP 143
35983: PPUSH
35984: LD_VAR 0 1
35988: PPUSH
35989: EMPTY
35990: PPUSH
35991: CALL_OW 1
35995: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35996: LD_ADDR_EXP 144
36000: PUSH
36001: LD_EXP 144
36005: PPUSH
36006: LD_VAR 0 1
36010: PPUSH
36011: LD_INT 0
36013: PPUSH
36014: CALL_OW 1
36018: ST_TO_ADDR
// end ;
36019: LD_VAR 0 2
36023: RET
// export function MC_Add ( side , units ) ; var base ; begin
36024: LD_INT 0
36026: PPUSH
36027: PPUSH
// base := mc_bases + 1 ;
36028: LD_ADDR_VAR 0 4
36032: PUSH
36033: LD_EXP 102
36037: PUSH
36038: LD_INT 1
36040: PLUS
36041: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36042: LD_ADDR_EXP 128
36046: PUSH
36047: LD_EXP 128
36051: PPUSH
36052: LD_VAR 0 4
36056: PPUSH
36057: LD_VAR 0 1
36061: PPUSH
36062: CALL_OW 1
36066: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36067: LD_ADDR_EXP 102
36071: PUSH
36072: LD_EXP 102
36076: PPUSH
36077: LD_VAR 0 4
36081: PPUSH
36082: LD_VAR 0 2
36086: PPUSH
36087: CALL_OW 1
36091: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36092: LD_ADDR_EXP 103
36096: PUSH
36097: LD_EXP 103
36101: PPUSH
36102: LD_VAR 0 4
36106: PPUSH
36107: EMPTY
36108: PPUSH
36109: CALL_OW 1
36113: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36114: LD_ADDR_EXP 104
36118: PUSH
36119: LD_EXP 104
36123: PPUSH
36124: LD_VAR 0 4
36128: PPUSH
36129: EMPTY
36130: PPUSH
36131: CALL_OW 1
36135: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36136: LD_ADDR_EXP 105
36140: PUSH
36141: LD_EXP 105
36145: PPUSH
36146: LD_VAR 0 4
36150: PPUSH
36151: EMPTY
36152: PPUSH
36153: CALL_OW 1
36157: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36158: LD_ADDR_EXP 106
36162: PUSH
36163: LD_EXP 106
36167: PPUSH
36168: LD_VAR 0 4
36172: PPUSH
36173: EMPTY
36174: PPUSH
36175: CALL_OW 1
36179: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36180: LD_ADDR_EXP 107
36184: PUSH
36185: LD_EXP 107
36189: PPUSH
36190: LD_VAR 0 4
36194: PPUSH
36195: EMPTY
36196: PPUSH
36197: CALL_OW 1
36201: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36202: LD_ADDR_EXP 108
36206: PUSH
36207: LD_EXP 108
36211: PPUSH
36212: LD_VAR 0 4
36216: PPUSH
36217: EMPTY
36218: PPUSH
36219: CALL_OW 1
36223: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36224: LD_ADDR_EXP 109
36228: PUSH
36229: LD_EXP 109
36233: PPUSH
36234: LD_VAR 0 4
36238: PPUSH
36239: EMPTY
36240: PPUSH
36241: CALL_OW 1
36245: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36246: LD_ADDR_EXP 110
36250: PUSH
36251: LD_EXP 110
36255: PPUSH
36256: LD_VAR 0 4
36260: PPUSH
36261: EMPTY
36262: PPUSH
36263: CALL_OW 1
36267: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36268: LD_ADDR_EXP 111
36272: PUSH
36273: LD_EXP 111
36277: PPUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36290: LD_ADDR_EXP 112
36294: PUSH
36295: LD_EXP 112
36299: PPUSH
36300: LD_VAR 0 4
36304: PPUSH
36305: EMPTY
36306: PPUSH
36307: CALL_OW 1
36311: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36312: LD_ADDR_EXP 113
36316: PUSH
36317: LD_EXP 113
36321: PPUSH
36322: LD_VAR 0 4
36326: PPUSH
36327: LD_INT 0
36329: PPUSH
36330: CALL_OW 1
36334: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36335: LD_ADDR_EXP 114
36339: PUSH
36340: LD_EXP 114
36344: PPUSH
36345: LD_VAR 0 4
36349: PPUSH
36350: EMPTY
36351: PPUSH
36352: CALL_OW 1
36356: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36357: LD_ADDR_EXP 115
36361: PUSH
36362: LD_EXP 115
36366: PPUSH
36367: LD_VAR 0 4
36371: PPUSH
36372: EMPTY
36373: PPUSH
36374: CALL_OW 1
36378: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36379: LD_ADDR_EXP 116
36383: PUSH
36384: LD_EXP 116
36388: PPUSH
36389: LD_VAR 0 4
36393: PPUSH
36394: EMPTY
36395: PPUSH
36396: CALL_OW 1
36400: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36401: LD_ADDR_EXP 117
36405: PUSH
36406: LD_EXP 117
36410: PPUSH
36411: LD_VAR 0 4
36415: PPUSH
36416: EMPTY
36417: PPUSH
36418: CALL_OW 1
36422: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36423: LD_ADDR_EXP 118
36427: PUSH
36428: LD_EXP 118
36432: PPUSH
36433: LD_VAR 0 4
36437: PPUSH
36438: EMPTY
36439: PPUSH
36440: CALL_OW 1
36444: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36445: LD_ADDR_EXP 119
36449: PUSH
36450: LD_EXP 119
36454: PPUSH
36455: LD_VAR 0 4
36459: PPUSH
36460: EMPTY
36461: PPUSH
36462: CALL_OW 1
36466: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36467: LD_ADDR_EXP 120
36471: PUSH
36472: LD_EXP 120
36476: PPUSH
36477: LD_VAR 0 4
36481: PPUSH
36482: EMPTY
36483: PPUSH
36484: CALL_OW 1
36488: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36489: LD_ADDR_EXP 121
36493: PUSH
36494: LD_EXP 121
36498: PPUSH
36499: LD_VAR 0 4
36503: PPUSH
36504: EMPTY
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36511: LD_ADDR_EXP 122
36515: PUSH
36516: LD_EXP 122
36520: PPUSH
36521: LD_VAR 0 4
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36533: LD_ADDR_EXP 123
36537: PUSH
36538: LD_EXP 123
36542: PPUSH
36543: LD_VAR 0 4
36547: PPUSH
36548: EMPTY
36549: PPUSH
36550: CALL_OW 1
36554: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36555: LD_ADDR_EXP 124
36559: PUSH
36560: LD_EXP 124
36564: PPUSH
36565: LD_VAR 0 4
36569: PPUSH
36570: EMPTY
36571: PPUSH
36572: CALL_OW 1
36576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36577: LD_ADDR_EXP 125
36581: PUSH
36582: LD_EXP 125
36586: PPUSH
36587: LD_VAR 0 4
36591: PPUSH
36592: EMPTY
36593: PPUSH
36594: CALL_OW 1
36598: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36599: LD_ADDR_EXP 126
36603: PUSH
36604: LD_EXP 126
36608: PPUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: EMPTY
36615: PPUSH
36616: CALL_OW 1
36620: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36621: LD_ADDR_EXP 127
36625: PUSH
36626: LD_EXP 127
36630: PPUSH
36631: LD_VAR 0 4
36635: PPUSH
36636: EMPTY
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36643: LD_ADDR_EXP 129
36647: PUSH
36648: LD_EXP 129
36652: PPUSH
36653: LD_VAR 0 4
36657: PPUSH
36658: EMPTY
36659: PPUSH
36660: CALL_OW 1
36664: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36665: LD_ADDR_EXP 131
36669: PUSH
36670: LD_EXP 131
36674: PPUSH
36675: LD_VAR 0 4
36679: PPUSH
36680: EMPTY
36681: PPUSH
36682: CALL_OW 1
36686: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36687: LD_ADDR_EXP 132
36691: PUSH
36692: LD_EXP 132
36696: PPUSH
36697: LD_VAR 0 4
36701: PPUSH
36702: EMPTY
36703: PPUSH
36704: CALL_OW 1
36708: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36709: LD_ADDR_EXP 133
36713: PUSH
36714: LD_EXP 133
36718: PPUSH
36719: LD_VAR 0 4
36723: PPUSH
36724: EMPTY
36725: PPUSH
36726: CALL_OW 1
36730: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36731: LD_ADDR_EXP 134
36735: PUSH
36736: LD_EXP 134
36740: PPUSH
36741: LD_VAR 0 4
36745: PPUSH
36746: EMPTY
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36753: LD_ADDR_EXP 135
36757: PUSH
36758: LD_EXP 135
36762: PPUSH
36763: LD_VAR 0 4
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36775: LD_ADDR_EXP 136
36779: PUSH
36780: LD_EXP 136
36784: PPUSH
36785: LD_VAR 0 4
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36797: LD_ADDR_EXP 137
36801: PUSH
36802: LD_EXP 137
36806: PPUSH
36807: LD_VAR 0 4
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36819: LD_ADDR_EXP 138
36823: PUSH
36824: LD_EXP 138
36828: PPUSH
36829: LD_VAR 0 4
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36841: LD_ADDR_EXP 139
36845: PUSH
36846: LD_EXP 139
36850: PPUSH
36851: LD_VAR 0 4
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36863: LD_ADDR_EXP 140
36867: PUSH
36868: LD_EXP 140
36872: PPUSH
36873: LD_VAR 0 4
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36885: LD_ADDR_EXP 141
36889: PUSH
36890: LD_EXP 141
36894: PPUSH
36895: LD_VAR 0 4
36899: PPUSH
36900: EMPTY
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36907: LD_ADDR_EXP 142
36911: PUSH
36912: LD_EXP 142
36916: PPUSH
36917: LD_VAR 0 4
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36929: LD_ADDR_EXP 143
36933: PUSH
36934: LD_EXP 143
36938: PPUSH
36939: LD_VAR 0 4
36943: PPUSH
36944: EMPTY
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36951: LD_ADDR_EXP 144
36955: PUSH
36956: LD_EXP 144
36960: PPUSH
36961: LD_VAR 0 4
36965: PPUSH
36966: LD_INT 0
36968: PPUSH
36969: CALL_OW 1
36973: ST_TO_ADDR
// result := base ;
36974: LD_ADDR_VAR 0 3
36978: PUSH
36979: LD_VAR 0 4
36983: ST_TO_ADDR
// end ;
36984: LD_VAR 0 3
36988: RET
// export function MC_Start ( ) ; var i ; begin
36989: LD_INT 0
36991: PPUSH
36992: PPUSH
// for i = 1 to mc_bases do
36993: LD_ADDR_VAR 0 2
36997: PUSH
36998: DOUBLE
36999: LD_INT 1
37001: DEC
37002: ST_TO_ADDR
37003: LD_EXP 102
37007: PUSH
37008: FOR_TO
37009: IFFALSE 38086
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37011: LD_ADDR_EXP 102
37015: PUSH
37016: LD_EXP 102
37020: PPUSH
37021: LD_VAR 0 2
37025: PPUSH
37026: LD_EXP 102
37030: PUSH
37031: LD_VAR 0 2
37035: ARRAY
37036: PUSH
37037: LD_INT 0
37039: DIFF
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37046: LD_ADDR_EXP 103
37050: PUSH
37051: LD_EXP 103
37055: PPUSH
37056: LD_VAR 0 2
37060: PPUSH
37061: EMPTY
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37068: LD_ADDR_EXP 104
37072: PUSH
37073: LD_EXP 104
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37090: LD_ADDR_EXP 105
37094: PUSH
37095: LD_EXP 105
37099: PPUSH
37100: LD_VAR 0 2
37104: PPUSH
37105: EMPTY
37106: PPUSH
37107: CALL_OW 1
37111: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37112: LD_ADDR_EXP 106
37116: PUSH
37117: LD_EXP 106
37121: PPUSH
37122: LD_VAR 0 2
37126: PPUSH
37127: EMPTY
37128: PUSH
37129: EMPTY
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37140: LD_ADDR_EXP 107
37144: PUSH
37145: LD_EXP 107
37149: PPUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: EMPTY
37156: PPUSH
37157: CALL_OW 1
37161: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37162: LD_ADDR_EXP 134
37166: PUSH
37167: LD_EXP 134
37171: PPUSH
37172: LD_VAR 0 2
37176: PPUSH
37177: EMPTY
37178: PPUSH
37179: CALL_OW 1
37183: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37184: LD_ADDR_EXP 108
37188: PUSH
37189: LD_EXP 108
37193: PPUSH
37194: LD_VAR 0 2
37198: PPUSH
37199: EMPTY
37200: PPUSH
37201: CALL_OW 1
37205: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37206: LD_ADDR_EXP 109
37210: PUSH
37211: LD_EXP 109
37215: PPUSH
37216: LD_VAR 0 2
37220: PPUSH
37221: EMPTY
37222: PPUSH
37223: CALL_OW 1
37227: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37228: LD_ADDR_EXP 110
37232: PUSH
37233: LD_EXP 110
37237: PPUSH
37238: LD_VAR 0 2
37242: PPUSH
37243: LD_EXP 102
37247: PUSH
37248: LD_VAR 0 2
37252: ARRAY
37253: PPUSH
37254: LD_INT 2
37256: PUSH
37257: LD_INT 30
37259: PUSH
37260: LD_INT 32
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 30
37269: PUSH
37270: LD_INT 33
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: LIST
37281: PPUSH
37282: CALL_OW 72
37286: PPUSH
37287: CALL_OW 1
37291: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37292: LD_ADDR_EXP 111
37296: PUSH
37297: LD_EXP 111
37301: PPUSH
37302: LD_VAR 0 2
37306: PPUSH
37307: LD_EXP 102
37311: PUSH
37312: LD_VAR 0 2
37316: ARRAY
37317: PPUSH
37318: LD_INT 2
37320: PUSH
37321: LD_INT 30
37323: PUSH
37324: LD_INT 32
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 30
37333: PUSH
37334: LD_INT 31
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 58
37348: PUSH
37349: EMPTY
37350: LIST
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PPUSH
37356: CALL_OW 72
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37366: LD_ADDR_EXP 112
37370: PUSH
37371: LD_EXP 112
37375: PPUSH
37376: LD_VAR 0 2
37380: PPUSH
37381: EMPTY
37382: PPUSH
37383: CALL_OW 1
37387: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37388: LD_ADDR_EXP 116
37392: PUSH
37393: LD_EXP 116
37397: PPUSH
37398: LD_VAR 0 2
37402: PPUSH
37403: EMPTY
37404: PPUSH
37405: CALL_OW 1
37409: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37410: LD_ADDR_EXP 115
37414: PUSH
37415: LD_EXP 115
37419: PPUSH
37420: LD_VAR 0 2
37424: PPUSH
37425: EMPTY
37426: PPUSH
37427: CALL_OW 1
37431: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37432: LD_ADDR_EXP 117
37436: PUSH
37437: LD_EXP 117
37441: PPUSH
37442: LD_VAR 0 2
37446: PPUSH
37447: EMPTY
37448: PPUSH
37449: CALL_OW 1
37453: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37454: LD_ADDR_EXP 118
37458: PUSH
37459: LD_EXP 118
37463: PPUSH
37464: LD_VAR 0 2
37468: PPUSH
37469: EMPTY
37470: PPUSH
37471: CALL_OW 1
37475: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37476: LD_ADDR_EXP 119
37480: PUSH
37481: LD_EXP 119
37485: PPUSH
37486: LD_VAR 0 2
37490: PPUSH
37491: EMPTY
37492: PPUSH
37493: CALL_OW 1
37497: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37498: LD_ADDR_EXP 120
37502: PUSH
37503: LD_EXP 120
37507: PPUSH
37508: LD_VAR 0 2
37512: PPUSH
37513: EMPTY
37514: PPUSH
37515: CALL_OW 1
37519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37520: LD_ADDR_EXP 121
37524: PUSH
37525: LD_EXP 121
37529: PPUSH
37530: LD_VAR 0 2
37534: PPUSH
37535: EMPTY
37536: PPUSH
37537: CALL_OW 1
37541: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37542: LD_ADDR_EXP 122
37546: PUSH
37547: LD_EXP 122
37551: PPUSH
37552: LD_VAR 0 2
37556: PPUSH
37557: EMPTY
37558: PPUSH
37559: CALL_OW 1
37563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37564: LD_ADDR_EXP 123
37568: PUSH
37569: LD_EXP 123
37573: PPUSH
37574: LD_VAR 0 2
37578: PPUSH
37579: EMPTY
37580: PPUSH
37581: CALL_OW 1
37585: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37586: LD_ADDR_EXP 124
37590: PUSH
37591: LD_EXP 124
37595: PPUSH
37596: LD_VAR 0 2
37600: PPUSH
37601: EMPTY
37602: PPUSH
37603: CALL_OW 1
37607: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37608: LD_ADDR_EXP 113
37612: PUSH
37613: LD_EXP 113
37617: PPUSH
37618: LD_VAR 0 2
37622: PPUSH
37623: LD_INT 0
37625: PPUSH
37626: CALL_OW 1
37630: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37631: LD_ADDR_EXP 126
37635: PUSH
37636: LD_EXP 126
37640: PPUSH
37641: LD_VAR 0 2
37645: PPUSH
37646: LD_INT 0
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37654: LD_ADDR_EXP 114
37658: PUSH
37659: LD_EXP 114
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: EMPTY
37670: PPUSH
37671: CALL_OW 1
37675: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37676: LD_ADDR_EXP 125
37680: PUSH
37681: LD_EXP 125
37685: PPUSH
37686: LD_VAR 0 2
37690: PPUSH
37691: LD_INT 0
37693: PPUSH
37694: CALL_OW 1
37698: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37699: LD_ADDR_EXP 127
37703: PUSH
37704: LD_EXP 127
37708: PPUSH
37709: LD_VAR 0 2
37713: PPUSH
37714: EMPTY
37715: PPUSH
37716: CALL_OW 1
37720: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37721: LD_ADDR_EXP 130
37725: PUSH
37726: LD_EXP 130
37730: PPUSH
37731: LD_VAR 0 2
37735: PPUSH
37736: LD_INT 0
37738: PPUSH
37739: CALL_OW 1
37743: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37744: LD_ADDR_EXP 131
37748: PUSH
37749: LD_EXP 131
37753: PPUSH
37754: LD_VAR 0 2
37758: PPUSH
37759: EMPTY
37760: PPUSH
37761: CALL_OW 1
37765: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37766: LD_ADDR_EXP 132
37770: PUSH
37771: LD_EXP 132
37775: PPUSH
37776: LD_VAR 0 2
37780: PPUSH
37781: EMPTY
37782: PPUSH
37783: CALL_OW 1
37787: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37788: LD_ADDR_EXP 133
37792: PUSH
37793: LD_EXP 133
37797: PPUSH
37798: LD_VAR 0 2
37802: PPUSH
37803: EMPTY
37804: PPUSH
37805: CALL_OW 1
37809: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37810: LD_ADDR_EXP 135
37814: PUSH
37815: LD_EXP 135
37819: PPUSH
37820: LD_VAR 0 2
37824: PPUSH
37825: LD_EXP 102
37829: PUSH
37830: LD_VAR 0 2
37834: ARRAY
37835: PPUSH
37836: LD_INT 2
37838: PUSH
37839: LD_INT 30
37841: PUSH
37842: LD_INT 6
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 30
37851: PUSH
37852: LD_INT 7
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 30
37861: PUSH
37862: LD_INT 8
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: PPUSH
37875: CALL_OW 72
37879: PPUSH
37880: CALL_OW 1
37884: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37885: LD_ADDR_EXP 136
37889: PUSH
37890: LD_EXP 136
37894: PPUSH
37895: LD_VAR 0 2
37899: PPUSH
37900: EMPTY
37901: PPUSH
37902: CALL_OW 1
37906: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37907: LD_ADDR_EXP 137
37911: PUSH
37912: LD_EXP 137
37916: PPUSH
37917: LD_VAR 0 2
37921: PPUSH
37922: EMPTY
37923: PPUSH
37924: CALL_OW 1
37928: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37929: LD_ADDR_EXP 138
37933: PUSH
37934: LD_EXP 138
37938: PPUSH
37939: LD_VAR 0 2
37943: PPUSH
37944: EMPTY
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37951: LD_ADDR_EXP 139
37955: PUSH
37956: LD_EXP 139
37960: PPUSH
37961: LD_VAR 0 2
37965: PPUSH
37966: EMPTY
37967: PPUSH
37968: CALL_OW 1
37972: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37973: LD_ADDR_EXP 140
37977: PUSH
37978: LD_EXP 140
37982: PPUSH
37983: LD_VAR 0 2
37987: PPUSH
37988: EMPTY
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37995: LD_ADDR_EXP 141
37999: PUSH
38000: LD_EXP 141
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: EMPTY
38011: PPUSH
38012: CALL_OW 1
38016: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38017: LD_ADDR_EXP 142
38021: PUSH
38022: LD_EXP 142
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: EMPTY
38033: PPUSH
38034: CALL_OW 1
38038: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38039: LD_ADDR_EXP 143
38043: PUSH
38044: LD_EXP 143
38048: PPUSH
38049: LD_VAR 0 2
38053: PPUSH
38054: EMPTY
38055: PPUSH
38056: CALL_OW 1
38060: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38061: LD_ADDR_EXP 144
38065: PUSH
38066: LD_EXP 144
38070: PPUSH
38071: LD_VAR 0 2
38075: PPUSH
38076: LD_INT 0
38078: PPUSH
38079: CALL_OW 1
38083: ST_TO_ADDR
// end ;
38084: GO 37008
38086: POP
38087: POP
// MC_InitSides ( ) ;
38088: CALL 38374 0 0
// MC_InitResearch ( ) ;
38092: CALL 38113 0 0
// CustomInitMacro ( ) ;
38096: CALL 467 0 0
// skirmish := true ;
38100: LD_ADDR_EXP 100
38104: PUSH
38105: LD_INT 1
38107: ST_TO_ADDR
// end ;
38108: LD_VAR 0 1
38112: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38113: LD_INT 0
38115: PPUSH
38116: PPUSH
38117: PPUSH
38118: PPUSH
38119: PPUSH
38120: PPUSH
// if not mc_bases then
38121: LD_EXP 102
38125: NOT
38126: IFFALSE 38130
// exit ;
38128: GO 38369
// for i = 1 to 8 do
38130: LD_ADDR_VAR 0 2
38134: PUSH
38135: DOUBLE
38136: LD_INT 1
38138: DEC
38139: ST_TO_ADDR
38140: LD_INT 8
38142: PUSH
38143: FOR_TO
38144: IFFALSE 38170
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38146: LD_ADDR_EXP 129
38150: PUSH
38151: LD_EXP 129
38155: PPUSH
38156: LD_VAR 0 2
38160: PPUSH
38161: EMPTY
38162: PPUSH
38163: CALL_OW 1
38167: ST_TO_ADDR
38168: GO 38143
38170: POP
38171: POP
// tmp := [ ] ;
38172: LD_ADDR_VAR 0 5
38176: PUSH
38177: EMPTY
38178: ST_TO_ADDR
// for i = 1 to mc_sides do
38179: LD_ADDR_VAR 0 2
38183: PUSH
38184: DOUBLE
38185: LD_INT 1
38187: DEC
38188: ST_TO_ADDR
38189: LD_EXP 128
38193: PUSH
38194: FOR_TO
38195: IFFALSE 38253
// if not mc_sides [ i ] in tmp then
38197: LD_EXP 128
38201: PUSH
38202: LD_VAR 0 2
38206: ARRAY
38207: PUSH
38208: LD_VAR 0 5
38212: IN
38213: NOT
38214: IFFALSE 38251
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38216: LD_ADDR_VAR 0 5
38220: PUSH
38221: LD_VAR 0 5
38225: PPUSH
38226: LD_VAR 0 5
38230: PUSH
38231: LD_INT 1
38233: PLUS
38234: PPUSH
38235: LD_EXP 128
38239: PUSH
38240: LD_VAR 0 2
38244: ARRAY
38245: PPUSH
38246: CALL_OW 2
38250: ST_TO_ADDR
38251: GO 38194
38253: POP
38254: POP
// if not tmp then
38255: LD_VAR 0 5
38259: NOT
38260: IFFALSE 38264
// exit ;
38262: GO 38369
// for j in tmp do
38264: LD_ADDR_VAR 0 3
38268: PUSH
38269: LD_VAR 0 5
38273: PUSH
38274: FOR_IN
38275: IFFALSE 38367
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38277: LD_ADDR_VAR 0 6
38281: PUSH
38282: LD_INT 22
38284: PUSH
38285: LD_VAR 0 3
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PPUSH
38294: CALL_OW 69
38298: ST_TO_ADDR
// if not un then
38299: LD_VAR 0 6
38303: NOT
38304: IFFALSE 38308
// continue ;
38306: GO 38274
// nation := GetNation ( un [ 1 ] ) ;
38308: LD_ADDR_VAR 0 4
38312: PUSH
38313: LD_VAR 0 6
38317: PUSH
38318: LD_INT 1
38320: ARRAY
38321: PPUSH
38322: CALL_OW 248
38326: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38327: LD_ADDR_EXP 129
38331: PUSH
38332: LD_EXP 129
38336: PPUSH
38337: LD_VAR 0 3
38341: PPUSH
38342: LD_VAR 0 3
38346: PPUSH
38347: LD_VAR 0 4
38351: PPUSH
38352: LD_INT 1
38354: PPUSH
38355: CALL 64979 0 3
38359: PPUSH
38360: CALL_OW 1
38364: ST_TO_ADDR
// end ;
38365: GO 38274
38367: POP
38368: POP
// end ;
38369: LD_VAR 0 1
38373: RET
// export function MC_InitSides ( ) ; var i ; begin
38374: LD_INT 0
38376: PPUSH
38377: PPUSH
// if not mc_bases then
38378: LD_EXP 102
38382: NOT
38383: IFFALSE 38387
// exit ;
38385: GO 38461
// for i = 1 to mc_bases do
38387: LD_ADDR_VAR 0 2
38391: PUSH
38392: DOUBLE
38393: LD_INT 1
38395: DEC
38396: ST_TO_ADDR
38397: LD_EXP 102
38401: PUSH
38402: FOR_TO
38403: IFFALSE 38459
// if mc_bases [ i ] then
38405: LD_EXP 102
38409: PUSH
38410: LD_VAR 0 2
38414: ARRAY
38415: IFFALSE 38457
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38417: LD_ADDR_EXP 128
38421: PUSH
38422: LD_EXP 128
38426: PPUSH
38427: LD_VAR 0 2
38431: PPUSH
38432: LD_EXP 102
38436: PUSH
38437: LD_VAR 0 2
38441: ARRAY
38442: PUSH
38443: LD_INT 1
38445: ARRAY
38446: PPUSH
38447: CALL_OW 255
38451: PPUSH
38452: CALL_OW 1
38456: ST_TO_ADDR
38457: GO 38402
38459: POP
38460: POP
// end ;
38461: LD_VAR 0 1
38465: RET
// every 0 0$01 trigger skirmish do
38466: LD_EXP 100
38470: IFFALSE 38624
38472: GO 38474
38474: DISABLE
// begin enable ;
38475: ENABLE
// MC_CheckBuildings ( ) ;
38476: CALL 43122 0 0
// MC_CheckPeopleLife ( ) ;
38480: CALL 43247 0 0
// RaiseSailEvent ( 100 ) ;
38484: LD_INT 100
38486: PPUSH
38487: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38491: LD_INT 103
38493: PPUSH
38494: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38498: LD_INT 104
38500: PPUSH
38501: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38505: LD_INT 105
38507: PPUSH
38508: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38512: LD_INT 106
38514: PPUSH
38515: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38519: LD_INT 107
38521: PPUSH
38522: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38526: LD_INT 108
38528: PPUSH
38529: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38533: LD_INT 109
38535: PPUSH
38536: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38540: LD_INT 110
38542: PPUSH
38543: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38547: LD_INT 111
38549: PPUSH
38550: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38554: LD_INT 112
38556: PPUSH
38557: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38561: LD_INT 113
38563: PPUSH
38564: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38568: LD_INT 120
38570: PPUSH
38571: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38575: LD_INT 121
38577: PPUSH
38578: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38582: LD_INT 122
38584: PPUSH
38585: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38589: LD_INT 123
38591: PPUSH
38592: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38596: LD_INT 124
38598: PPUSH
38599: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38603: LD_INT 125
38605: PPUSH
38606: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38610: LD_INT 126
38612: PPUSH
38613: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38617: LD_INT 200
38619: PPUSH
38620: CALL_OW 427
// end ;
38624: END
// on SailEvent ( event ) do begin if event < 100 then
38625: LD_VAR 0 1
38629: PUSH
38630: LD_INT 100
38632: LESS
38633: IFFALSE 38644
// CustomEvent ( event ) ;
38635: LD_VAR 0 1
38639: PPUSH
38640: CALL 33284 0 1
// if event = 100 then
38644: LD_VAR 0 1
38648: PUSH
38649: LD_INT 100
38651: EQUAL
38652: IFFALSE 38658
// MC_ClassManager ( ) ;
38654: CALL 39050 0 0
// if event = 101 then
38658: LD_VAR 0 1
38662: PUSH
38663: LD_INT 101
38665: EQUAL
38666: IFFALSE 38672
// MC_RepairBuildings ( ) ;
38668: CALL 43843 0 0
// if event = 102 then
38672: LD_VAR 0 1
38676: PUSH
38677: LD_INT 102
38679: EQUAL
38680: IFFALSE 38686
// MC_Heal ( ) ;
38682: CALL 44707 0 0
// if event = 103 then
38686: LD_VAR 0 1
38690: PUSH
38691: LD_INT 103
38693: EQUAL
38694: IFFALSE 38700
// MC_Build ( ) ;
38696: CALL 45129 0 0
// if event = 104 then
38700: LD_VAR 0 1
38704: PUSH
38705: LD_INT 104
38707: EQUAL
38708: IFFALSE 38714
// MC_TurretWeapon ( ) ;
38710: CALL 46742 0 0
// if event = 105 then
38714: LD_VAR 0 1
38718: PUSH
38719: LD_INT 105
38721: EQUAL
38722: IFFALSE 38728
// MC_BuildUpgrade ( ) ;
38724: CALL 46293 0 0
// if event = 106 then
38728: LD_VAR 0 1
38732: PUSH
38733: LD_INT 106
38735: EQUAL
38736: IFFALSE 38742
// MC_PlantMines ( ) ;
38738: CALL 47172 0 0
// if event = 107 then
38742: LD_VAR 0 1
38746: PUSH
38747: LD_INT 107
38749: EQUAL
38750: IFFALSE 38756
// MC_CollectCrates ( ) ;
38752: CALL 47970 0 0
// if event = 108 then
38756: LD_VAR 0 1
38760: PUSH
38761: LD_INT 108
38763: EQUAL
38764: IFFALSE 38770
// MC_LinkRemoteControl ( ) ;
38766: CALL 49746 0 0
// if event = 109 then
38770: LD_VAR 0 1
38774: PUSH
38775: LD_INT 109
38777: EQUAL
38778: IFFALSE 38784
// MC_ProduceVehicle ( ) ;
38780: CALL 49927 0 0
// if event = 110 then
38784: LD_VAR 0 1
38788: PUSH
38789: LD_INT 110
38791: EQUAL
38792: IFFALSE 38798
// MC_SendAttack ( ) ;
38794: CALL 50393 0 0
// if event = 111 then
38798: LD_VAR 0 1
38802: PUSH
38803: LD_INT 111
38805: EQUAL
38806: IFFALSE 38812
// MC_Defend ( ) ;
38808: CALL 50501 0 0
// if event = 112 then
38812: LD_VAR 0 1
38816: PUSH
38817: LD_INT 112
38819: EQUAL
38820: IFFALSE 38826
// MC_Research ( ) ;
38822: CALL 51106 0 0
// if event = 113 then
38826: LD_VAR 0 1
38830: PUSH
38831: LD_INT 113
38833: EQUAL
38834: IFFALSE 38840
// MC_MinesTrigger ( ) ;
38836: CALL 52220 0 0
// if event = 120 then
38840: LD_VAR 0 1
38844: PUSH
38845: LD_INT 120
38847: EQUAL
38848: IFFALSE 38854
// MC_RepairVehicle ( ) ;
38850: CALL 52319 0 0
// if event = 121 then
38854: LD_VAR 0 1
38858: PUSH
38859: LD_INT 121
38861: EQUAL
38862: IFFALSE 38868
// MC_TameApe ( ) ;
38864: CALL 53049 0 0
// if event = 122 then
38868: LD_VAR 0 1
38872: PUSH
38873: LD_INT 122
38875: EQUAL
38876: IFFALSE 38882
// MC_ChangeApeClass ( ) ;
38878: CALL 53878 0 0
// if event = 123 then
38882: LD_VAR 0 1
38886: PUSH
38887: LD_INT 123
38889: EQUAL
38890: IFFALSE 38896
// MC_Bazooka ( ) ;
38892: CALL 54528 0 0
// if event = 124 then
38896: LD_VAR 0 1
38900: PUSH
38901: LD_INT 124
38903: EQUAL
38904: IFFALSE 38910
// MC_TeleportExit ( ) ;
38906: CALL 54726 0 0
// if event = 125 then
38910: LD_VAR 0 1
38914: PUSH
38915: LD_INT 125
38917: EQUAL
38918: IFFALSE 38924
// MC_Deposits ( ) ;
38920: CALL 55373 0 0
// if event = 126 then
38924: LD_VAR 0 1
38928: PUSH
38929: LD_INT 126
38931: EQUAL
38932: IFFALSE 38938
// MC_RemoteDriver ( ) ;
38934: CALL 55998 0 0
// if event = 200 then
38938: LD_VAR 0 1
38942: PUSH
38943: LD_INT 200
38945: EQUAL
38946: IFFALSE 38952
// MC_Idle ( ) ;
38948: CALL 57947 0 0
// end ;
38952: PPOPN 1
38954: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38955: LD_INT 0
38957: PPUSH
38958: PPUSH
// if not mc_bases [ base ] or not tag then
38959: LD_EXP 102
38963: PUSH
38964: LD_VAR 0 1
38968: ARRAY
38969: NOT
38970: PUSH
38971: LD_VAR 0 2
38975: NOT
38976: OR
38977: IFFALSE 38981
// exit ;
38979: GO 39045
// for i in mc_bases [ base ] union mc_ape [ base ] do
38981: LD_ADDR_VAR 0 4
38985: PUSH
38986: LD_EXP 102
38990: PUSH
38991: LD_VAR 0 1
38995: ARRAY
38996: PUSH
38997: LD_EXP 131
39001: PUSH
39002: LD_VAR 0 1
39006: ARRAY
39007: UNION
39008: PUSH
39009: FOR_IN
39010: IFFALSE 39043
// if GetTag ( i ) = tag then
39012: LD_VAR 0 4
39016: PPUSH
39017: CALL_OW 110
39021: PUSH
39022: LD_VAR 0 2
39026: EQUAL
39027: IFFALSE 39041
// SetTag ( i , 0 ) ;
39029: LD_VAR 0 4
39033: PPUSH
39034: LD_INT 0
39036: PPUSH
39037: CALL_OW 109
39041: GO 39009
39043: POP
39044: POP
// end ;
39045: LD_VAR 0 3
39049: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39050: LD_INT 0
39052: PPUSH
39053: PPUSH
39054: PPUSH
39055: PPUSH
39056: PPUSH
39057: PPUSH
39058: PPUSH
39059: PPUSH
// if not mc_bases then
39060: LD_EXP 102
39064: NOT
39065: IFFALSE 39069
// exit ;
39067: GO 39527
// for i = 1 to mc_bases do
39069: LD_ADDR_VAR 0 2
39073: PUSH
39074: DOUBLE
39075: LD_INT 1
39077: DEC
39078: ST_TO_ADDR
39079: LD_EXP 102
39083: PUSH
39084: FOR_TO
39085: IFFALSE 39525
// begin tmp := MC_ClassCheckReq ( i ) ;
39087: LD_ADDR_VAR 0 4
39091: PUSH
39092: LD_VAR 0 2
39096: PPUSH
39097: CALL 39532 0 1
39101: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39102: LD_ADDR_EXP 143
39106: PUSH
39107: LD_EXP 143
39111: PPUSH
39112: LD_VAR 0 2
39116: PPUSH
39117: LD_VAR 0 4
39121: PPUSH
39122: CALL_OW 1
39126: ST_TO_ADDR
// if not tmp then
39127: LD_VAR 0 4
39131: NOT
39132: IFFALSE 39136
// continue ;
39134: GO 39084
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39136: LD_ADDR_VAR 0 6
39140: PUSH
39141: LD_EXP 102
39145: PUSH
39146: LD_VAR 0 2
39150: ARRAY
39151: PPUSH
39152: LD_INT 2
39154: PUSH
39155: LD_INT 30
39157: PUSH
39158: LD_INT 4
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 30
39167: PUSH
39168: LD_INT 5
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: LIST
39179: PPUSH
39180: CALL_OW 72
39184: PUSH
39185: LD_EXP 102
39189: PUSH
39190: LD_VAR 0 2
39194: ARRAY
39195: PPUSH
39196: LD_INT 2
39198: PUSH
39199: LD_INT 30
39201: PUSH
39202: LD_INT 0
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 30
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: LIST
39223: PPUSH
39224: CALL_OW 72
39228: PUSH
39229: LD_EXP 102
39233: PUSH
39234: LD_VAR 0 2
39238: ARRAY
39239: PPUSH
39240: LD_INT 30
39242: PUSH
39243: LD_INT 3
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PPUSH
39250: CALL_OW 72
39254: PUSH
39255: LD_EXP 102
39259: PUSH
39260: LD_VAR 0 2
39264: ARRAY
39265: PPUSH
39266: LD_INT 2
39268: PUSH
39269: LD_INT 30
39271: PUSH
39272: LD_INT 6
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 30
39281: PUSH
39282: LD_INT 7
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 30
39291: PUSH
39292: LD_INT 8
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: PPUSH
39305: CALL_OW 72
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: ST_TO_ADDR
// for j = 1 to 4 do
39316: LD_ADDR_VAR 0 3
39320: PUSH
39321: DOUBLE
39322: LD_INT 1
39324: DEC
39325: ST_TO_ADDR
39326: LD_INT 4
39328: PUSH
39329: FOR_TO
39330: IFFALSE 39521
// begin if not tmp [ j ] then
39332: LD_VAR 0 4
39336: PUSH
39337: LD_VAR 0 3
39341: ARRAY
39342: NOT
39343: IFFALSE 39347
// continue ;
39345: GO 39329
// for p in tmp [ j ] do
39347: LD_ADDR_VAR 0 5
39351: PUSH
39352: LD_VAR 0 4
39356: PUSH
39357: LD_VAR 0 3
39361: ARRAY
39362: PUSH
39363: FOR_IN
39364: IFFALSE 39517
// begin if not b [ j ] then
39366: LD_VAR 0 6
39370: PUSH
39371: LD_VAR 0 3
39375: ARRAY
39376: NOT
39377: IFFALSE 39381
// break ;
39379: GO 39517
// e := 0 ;
39381: LD_ADDR_VAR 0 7
39385: PUSH
39386: LD_INT 0
39388: ST_TO_ADDR
// for k in b [ j ] do
39389: LD_ADDR_VAR 0 8
39393: PUSH
39394: LD_VAR 0 6
39398: PUSH
39399: LD_VAR 0 3
39403: ARRAY
39404: PUSH
39405: FOR_IN
39406: IFFALSE 39433
// if IsNotFull ( k ) then
39408: LD_VAR 0 8
39412: PPUSH
39413: CALL 69479 0 1
39417: IFFALSE 39431
// begin e := k ;
39419: LD_ADDR_VAR 0 7
39423: PUSH
39424: LD_VAR 0 8
39428: ST_TO_ADDR
// break ;
39429: GO 39433
// end ;
39431: GO 39405
39433: POP
39434: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39435: LD_VAR 0 7
39439: PUSH
39440: LD_VAR 0 5
39444: PPUSH
39445: LD_VAR 0 7
39449: PPUSH
39450: CALL 106608 0 2
39454: NOT
39455: AND
39456: IFFALSE 39515
// begin if IsInUnit ( p ) then
39458: LD_VAR 0 5
39462: PPUSH
39463: CALL_OW 310
39467: IFFALSE 39478
// ComExitBuilding ( p ) ;
39469: LD_VAR 0 5
39473: PPUSH
39474: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39478: LD_VAR 0 5
39482: PPUSH
39483: LD_VAR 0 7
39487: PPUSH
39488: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39492: LD_VAR 0 5
39496: PPUSH
39497: LD_VAR 0 3
39501: PPUSH
39502: CALL_OW 183
// AddComExitBuilding ( p ) ;
39506: LD_VAR 0 5
39510: PPUSH
39511: CALL_OW 182
// end ; end ;
39515: GO 39363
39517: POP
39518: POP
// end ;
39519: GO 39329
39521: POP
39522: POP
// end ;
39523: GO 39084
39525: POP
39526: POP
// end ;
39527: LD_VAR 0 1
39531: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39532: LD_INT 0
39534: PPUSH
39535: PPUSH
39536: PPUSH
39537: PPUSH
39538: PPUSH
39539: PPUSH
39540: PPUSH
39541: PPUSH
39542: PPUSH
39543: PPUSH
39544: PPUSH
39545: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39546: LD_VAR 0 1
39550: NOT
39551: PUSH
39552: LD_EXP 102
39556: PUSH
39557: LD_VAR 0 1
39561: ARRAY
39562: NOT
39563: OR
39564: PUSH
39565: LD_EXP 102
39569: PUSH
39570: LD_VAR 0 1
39574: ARRAY
39575: PPUSH
39576: LD_INT 2
39578: PUSH
39579: LD_INT 30
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 30
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: LIST
39603: PPUSH
39604: CALL_OW 72
39608: NOT
39609: OR
39610: IFFALSE 39614
// exit ;
39612: GO 43117
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39614: LD_ADDR_VAR 0 4
39618: PUSH
39619: LD_EXP 102
39623: PUSH
39624: LD_VAR 0 1
39628: ARRAY
39629: PPUSH
39630: LD_INT 2
39632: PUSH
39633: LD_INT 25
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 25
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 25
39655: PUSH
39656: LD_INT 3
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 25
39665: PUSH
39666: LD_INT 4
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 25
39675: PUSH
39676: LD_INT 5
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 25
39685: PUSH
39686: LD_INT 8
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 25
39695: PUSH
39696: LD_INT 9
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: PPUSH
39713: CALL_OW 72
39717: ST_TO_ADDR
// if not tmp then
39718: LD_VAR 0 4
39722: NOT
39723: IFFALSE 39727
// exit ;
39725: GO 43117
// for i in tmp do
39727: LD_ADDR_VAR 0 3
39731: PUSH
39732: LD_VAR 0 4
39736: PUSH
39737: FOR_IN
39738: IFFALSE 39769
// if GetTag ( i ) then
39740: LD_VAR 0 3
39744: PPUSH
39745: CALL_OW 110
39749: IFFALSE 39767
// tmp := tmp diff i ;
39751: LD_ADDR_VAR 0 4
39755: PUSH
39756: LD_VAR 0 4
39760: PUSH
39761: LD_VAR 0 3
39765: DIFF
39766: ST_TO_ADDR
39767: GO 39737
39769: POP
39770: POP
// if not tmp then
39771: LD_VAR 0 4
39775: NOT
39776: IFFALSE 39780
// exit ;
39778: GO 43117
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39780: LD_ADDR_VAR 0 5
39784: PUSH
39785: LD_EXP 102
39789: PUSH
39790: LD_VAR 0 1
39794: ARRAY
39795: PPUSH
39796: LD_INT 2
39798: PUSH
39799: LD_INT 25
39801: PUSH
39802: LD_INT 1
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 25
39811: PUSH
39812: LD_INT 5
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 25
39821: PUSH
39822: LD_INT 8
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 25
39831: PUSH
39832: LD_INT 9
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: PPUSH
39846: CALL_OW 72
39850: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39851: LD_ADDR_VAR 0 6
39855: PUSH
39856: LD_EXP 102
39860: PUSH
39861: LD_VAR 0 1
39865: ARRAY
39866: PPUSH
39867: LD_INT 25
39869: PUSH
39870: LD_INT 2
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PPUSH
39877: CALL_OW 72
39881: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39882: LD_ADDR_VAR 0 7
39886: PUSH
39887: LD_EXP 102
39891: PUSH
39892: LD_VAR 0 1
39896: ARRAY
39897: PPUSH
39898: LD_INT 25
39900: PUSH
39901: LD_INT 3
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PPUSH
39908: CALL_OW 72
39912: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39913: LD_ADDR_VAR 0 8
39917: PUSH
39918: LD_EXP 102
39922: PUSH
39923: LD_VAR 0 1
39927: ARRAY
39928: PPUSH
39929: LD_INT 25
39931: PUSH
39932: LD_INT 4
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 24
39941: PUSH
39942: LD_INT 251
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PPUSH
39953: CALL_OW 72
39957: ST_TO_ADDR
// if mc_scan [ base ] then
39958: LD_EXP 125
39962: PUSH
39963: LD_VAR 0 1
39967: ARRAY
39968: IFFALSE 40429
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39970: LD_ADDR_EXP 144
39974: PUSH
39975: LD_EXP 144
39979: PPUSH
39980: LD_VAR 0 1
39984: PPUSH
39985: LD_INT 4
39987: PPUSH
39988: CALL_OW 1
39992: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39993: LD_ADDR_VAR 0 12
39997: PUSH
39998: LD_EXP 102
40002: PUSH
40003: LD_VAR 0 1
40007: ARRAY
40008: PPUSH
40009: LD_INT 2
40011: PUSH
40012: LD_INT 30
40014: PUSH
40015: LD_INT 4
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 30
40024: PUSH
40025: LD_INT 5
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: LIST
40036: PPUSH
40037: CALL_OW 72
40041: ST_TO_ADDR
// if not b then
40042: LD_VAR 0 12
40046: NOT
40047: IFFALSE 40051
// exit ;
40049: GO 43117
// p := [ ] ;
40051: LD_ADDR_VAR 0 11
40055: PUSH
40056: EMPTY
40057: ST_TO_ADDR
// if sci >= 2 then
40058: LD_VAR 0 8
40062: PUSH
40063: LD_INT 2
40065: GREATEREQUAL
40066: IFFALSE 40097
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40068: LD_ADDR_VAR 0 8
40072: PUSH
40073: LD_VAR 0 8
40077: PUSH
40078: LD_INT 1
40080: ARRAY
40081: PUSH
40082: LD_VAR 0 8
40086: PUSH
40087: LD_INT 2
40089: ARRAY
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: ST_TO_ADDR
40095: GO 40158
// if sci = 1 then
40097: LD_VAR 0 8
40101: PUSH
40102: LD_INT 1
40104: EQUAL
40105: IFFALSE 40126
// sci := [ sci [ 1 ] ] else
40107: LD_ADDR_VAR 0 8
40111: PUSH
40112: LD_VAR 0 8
40116: PUSH
40117: LD_INT 1
40119: ARRAY
40120: PUSH
40121: EMPTY
40122: LIST
40123: ST_TO_ADDR
40124: GO 40158
// if sci = 0 then
40126: LD_VAR 0 8
40130: PUSH
40131: LD_INT 0
40133: EQUAL
40134: IFFALSE 40158
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40136: LD_ADDR_VAR 0 11
40140: PUSH
40141: LD_VAR 0 4
40145: PPUSH
40146: LD_INT 4
40148: PPUSH
40149: CALL 106471 0 2
40153: PUSH
40154: LD_INT 1
40156: ARRAY
40157: ST_TO_ADDR
// if eng > 4 then
40158: LD_VAR 0 6
40162: PUSH
40163: LD_INT 4
40165: GREATER
40166: IFFALSE 40212
// for i = eng downto 4 do
40168: LD_ADDR_VAR 0 3
40172: PUSH
40173: DOUBLE
40174: LD_VAR 0 6
40178: INC
40179: ST_TO_ADDR
40180: LD_INT 4
40182: PUSH
40183: FOR_DOWNTO
40184: IFFALSE 40210
// eng := eng diff eng [ i ] ;
40186: LD_ADDR_VAR 0 6
40190: PUSH
40191: LD_VAR 0 6
40195: PUSH
40196: LD_VAR 0 6
40200: PUSH
40201: LD_VAR 0 3
40205: ARRAY
40206: DIFF
40207: ST_TO_ADDR
40208: GO 40183
40210: POP
40211: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40212: LD_ADDR_VAR 0 4
40216: PUSH
40217: LD_VAR 0 4
40221: PUSH
40222: LD_VAR 0 5
40226: PUSH
40227: LD_VAR 0 6
40231: UNION
40232: PUSH
40233: LD_VAR 0 7
40237: UNION
40238: PUSH
40239: LD_VAR 0 8
40243: UNION
40244: DIFF
40245: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40246: LD_ADDR_VAR 0 13
40250: PUSH
40251: LD_EXP 102
40255: PUSH
40256: LD_VAR 0 1
40260: ARRAY
40261: PPUSH
40262: LD_INT 2
40264: PUSH
40265: LD_INT 30
40267: PUSH
40268: LD_INT 32
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 30
40277: PUSH
40278: LD_INT 31
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: LIST
40289: PPUSH
40290: CALL_OW 72
40294: PUSH
40295: LD_EXP 102
40299: PUSH
40300: LD_VAR 0 1
40304: ARRAY
40305: PPUSH
40306: LD_INT 2
40308: PUSH
40309: LD_INT 30
40311: PUSH
40312: LD_INT 4
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 30
40321: PUSH
40322: LD_INT 5
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: LIST
40333: PPUSH
40334: CALL_OW 72
40338: PUSH
40339: LD_INT 6
40341: MUL
40342: PLUS
40343: ST_TO_ADDR
// if bcount < tmp then
40344: LD_VAR 0 13
40348: PUSH
40349: LD_VAR 0 4
40353: LESS
40354: IFFALSE 40400
// for i = tmp downto bcount do
40356: LD_ADDR_VAR 0 3
40360: PUSH
40361: DOUBLE
40362: LD_VAR 0 4
40366: INC
40367: ST_TO_ADDR
40368: LD_VAR 0 13
40372: PUSH
40373: FOR_DOWNTO
40374: IFFALSE 40398
// tmp := Delete ( tmp , tmp ) ;
40376: LD_ADDR_VAR 0 4
40380: PUSH
40381: LD_VAR 0 4
40385: PPUSH
40386: LD_VAR 0 4
40390: PPUSH
40391: CALL_OW 3
40395: ST_TO_ADDR
40396: GO 40373
40398: POP
40399: POP
// result := [ tmp , 0 , 0 , p ] ;
40400: LD_ADDR_VAR 0 2
40404: PUSH
40405: LD_VAR 0 4
40409: PUSH
40410: LD_INT 0
40412: PUSH
40413: LD_INT 0
40415: PUSH
40416: LD_VAR 0 11
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: ST_TO_ADDR
// exit ;
40427: GO 43117
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40429: LD_EXP 102
40433: PUSH
40434: LD_VAR 0 1
40438: ARRAY
40439: PPUSH
40440: LD_INT 2
40442: PUSH
40443: LD_INT 30
40445: PUSH
40446: LD_INT 6
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 30
40455: PUSH
40456: LD_INT 7
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 30
40465: PUSH
40466: LD_INT 8
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: PPUSH
40479: CALL_OW 72
40483: NOT
40484: PUSH
40485: LD_EXP 102
40489: PUSH
40490: LD_VAR 0 1
40494: ARRAY
40495: PPUSH
40496: LD_INT 30
40498: PUSH
40499: LD_INT 3
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PPUSH
40506: CALL_OW 72
40510: NOT
40511: AND
40512: IFFALSE 40584
// begin if eng = tmp then
40514: LD_VAR 0 6
40518: PUSH
40519: LD_VAR 0 4
40523: EQUAL
40524: IFFALSE 40528
// exit ;
40526: GO 43117
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40528: LD_ADDR_EXP 144
40532: PUSH
40533: LD_EXP 144
40537: PPUSH
40538: LD_VAR 0 1
40542: PPUSH
40543: LD_INT 1
40545: PPUSH
40546: CALL_OW 1
40550: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40551: LD_ADDR_VAR 0 2
40555: PUSH
40556: LD_INT 0
40558: PUSH
40559: LD_VAR 0 4
40563: PUSH
40564: LD_VAR 0 6
40568: DIFF
40569: PUSH
40570: LD_INT 0
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: ST_TO_ADDR
// exit ;
40582: GO 43117
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40584: LD_EXP 129
40588: PUSH
40589: LD_EXP 128
40593: PUSH
40594: LD_VAR 0 1
40598: ARRAY
40599: ARRAY
40600: PUSH
40601: LD_EXP 102
40605: PUSH
40606: LD_VAR 0 1
40610: ARRAY
40611: PPUSH
40612: LD_INT 2
40614: PUSH
40615: LD_INT 30
40617: PUSH
40618: LD_INT 6
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 30
40627: PUSH
40628: LD_INT 7
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 30
40637: PUSH
40638: LD_INT 8
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: PPUSH
40651: CALL_OW 72
40655: AND
40656: PUSH
40657: LD_EXP 102
40661: PUSH
40662: LD_VAR 0 1
40666: ARRAY
40667: PPUSH
40668: LD_INT 30
40670: PUSH
40671: LD_INT 3
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PPUSH
40678: CALL_OW 72
40682: NOT
40683: AND
40684: IFFALSE 40898
// begin if sci >= 6 then
40686: LD_VAR 0 8
40690: PUSH
40691: LD_INT 6
40693: GREATEREQUAL
40694: IFFALSE 40698
// exit ;
40696: GO 43117
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40698: LD_ADDR_EXP 144
40702: PUSH
40703: LD_EXP 144
40707: PPUSH
40708: LD_VAR 0 1
40712: PPUSH
40713: LD_INT 2
40715: PPUSH
40716: CALL_OW 1
40720: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40721: LD_ADDR_VAR 0 9
40725: PUSH
40726: LD_VAR 0 4
40730: PUSH
40731: LD_VAR 0 8
40735: DIFF
40736: PPUSH
40737: LD_INT 4
40739: PPUSH
40740: CALL 106471 0 2
40744: ST_TO_ADDR
// p := [ ] ;
40745: LD_ADDR_VAR 0 11
40749: PUSH
40750: EMPTY
40751: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40752: LD_VAR 0 8
40756: PUSH
40757: LD_INT 6
40759: LESS
40760: PUSH
40761: LD_VAR 0 9
40765: PUSH
40766: LD_INT 6
40768: GREATER
40769: AND
40770: IFFALSE 40851
// begin for i = 1 to 6 - sci do
40772: LD_ADDR_VAR 0 3
40776: PUSH
40777: DOUBLE
40778: LD_INT 1
40780: DEC
40781: ST_TO_ADDR
40782: LD_INT 6
40784: PUSH
40785: LD_VAR 0 8
40789: MINUS
40790: PUSH
40791: FOR_TO
40792: IFFALSE 40847
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40794: LD_ADDR_VAR 0 11
40798: PUSH
40799: LD_VAR 0 11
40803: PPUSH
40804: LD_VAR 0 11
40808: PUSH
40809: LD_INT 1
40811: PLUS
40812: PPUSH
40813: LD_VAR 0 9
40817: PUSH
40818: LD_INT 1
40820: ARRAY
40821: PPUSH
40822: CALL_OW 2
40826: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40827: LD_ADDR_VAR 0 9
40831: PUSH
40832: LD_VAR 0 9
40836: PPUSH
40837: LD_INT 1
40839: PPUSH
40840: CALL_OW 3
40844: ST_TO_ADDR
// end ;
40845: GO 40791
40847: POP
40848: POP
// end else
40849: GO 40871
// if sort then
40851: LD_VAR 0 9
40855: IFFALSE 40871
// p := sort [ 1 ] ;
40857: LD_ADDR_VAR 0 11
40861: PUSH
40862: LD_VAR 0 9
40866: PUSH
40867: LD_INT 1
40869: ARRAY
40870: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40871: LD_ADDR_VAR 0 2
40875: PUSH
40876: LD_INT 0
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: LD_VAR 0 11
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: ST_TO_ADDR
// exit ;
40896: GO 43117
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40898: LD_EXP 129
40902: PUSH
40903: LD_EXP 128
40907: PUSH
40908: LD_VAR 0 1
40912: ARRAY
40913: ARRAY
40914: PUSH
40915: LD_EXP 102
40919: PUSH
40920: LD_VAR 0 1
40924: ARRAY
40925: PPUSH
40926: LD_INT 2
40928: PUSH
40929: LD_INT 30
40931: PUSH
40932: LD_INT 6
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 30
40941: PUSH
40942: LD_INT 7
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 30
40951: PUSH
40952: LD_INT 8
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: LIST
40963: LIST
40964: PPUSH
40965: CALL_OW 72
40969: AND
40970: PUSH
40971: LD_EXP 102
40975: PUSH
40976: LD_VAR 0 1
40980: ARRAY
40981: PPUSH
40982: LD_INT 30
40984: PUSH
40985: LD_INT 3
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PPUSH
40992: CALL_OW 72
40996: AND
40997: IFFALSE 41731
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40999: LD_ADDR_EXP 144
41003: PUSH
41004: LD_EXP 144
41008: PPUSH
41009: LD_VAR 0 1
41013: PPUSH
41014: LD_INT 3
41016: PPUSH
41017: CALL_OW 1
41021: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41022: LD_ADDR_VAR 0 2
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: LD_INT 0
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: ST_TO_ADDR
// if not eng then
41045: LD_VAR 0 6
41049: NOT
41050: IFFALSE 41113
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41052: LD_ADDR_VAR 0 11
41056: PUSH
41057: LD_VAR 0 4
41061: PPUSH
41062: LD_INT 2
41064: PPUSH
41065: CALL 106471 0 2
41069: PUSH
41070: LD_INT 1
41072: ARRAY
41073: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41074: LD_ADDR_VAR 0 2
41078: PUSH
41079: LD_VAR 0 2
41083: PPUSH
41084: LD_INT 2
41086: PPUSH
41087: LD_VAR 0 11
41091: PPUSH
41092: CALL_OW 1
41096: ST_TO_ADDR
// tmp := tmp diff p ;
41097: LD_ADDR_VAR 0 4
41101: PUSH
41102: LD_VAR 0 4
41106: PUSH
41107: LD_VAR 0 11
41111: DIFF
41112: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41113: LD_VAR 0 4
41117: PUSH
41118: LD_VAR 0 8
41122: PUSH
41123: LD_INT 6
41125: LESS
41126: AND
41127: IFFALSE 41315
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41129: LD_ADDR_VAR 0 9
41133: PUSH
41134: LD_VAR 0 4
41138: PUSH
41139: LD_VAR 0 8
41143: PUSH
41144: LD_VAR 0 7
41148: UNION
41149: DIFF
41150: PPUSH
41151: LD_INT 4
41153: PPUSH
41154: CALL 106471 0 2
41158: ST_TO_ADDR
// p := [ ] ;
41159: LD_ADDR_VAR 0 11
41163: PUSH
41164: EMPTY
41165: ST_TO_ADDR
// if sort then
41166: LD_VAR 0 9
41170: IFFALSE 41286
// for i = 1 to 6 - sci do
41172: LD_ADDR_VAR 0 3
41176: PUSH
41177: DOUBLE
41178: LD_INT 1
41180: DEC
41181: ST_TO_ADDR
41182: LD_INT 6
41184: PUSH
41185: LD_VAR 0 8
41189: MINUS
41190: PUSH
41191: FOR_TO
41192: IFFALSE 41284
// begin if i = sort then
41194: LD_VAR 0 3
41198: PUSH
41199: LD_VAR 0 9
41203: EQUAL
41204: IFFALSE 41208
// break ;
41206: GO 41284
// if GetClass ( i ) = 4 then
41208: LD_VAR 0 3
41212: PPUSH
41213: CALL_OW 257
41217: PUSH
41218: LD_INT 4
41220: EQUAL
41221: IFFALSE 41225
// continue ;
41223: GO 41191
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41225: LD_ADDR_VAR 0 11
41229: PUSH
41230: LD_VAR 0 11
41234: PPUSH
41235: LD_VAR 0 11
41239: PUSH
41240: LD_INT 1
41242: PLUS
41243: PPUSH
41244: LD_VAR 0 9
41248: PUSH
41249: LD_VAR 0 3
41253: ARRAY
41254: PPUSH
41255: CALL_OW 2
41259: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41260: LD_ADDR_VAR 0 4
41264: PUSH
41265: LD_VAR 0 4
41269: PUSH
41270: LD_VAR 0 9
41274: PUSH
41275: LD_VAR 0 3
41279: ARRAY
41280: DIFF
41281: ST_TO_ADDR
// end ;
41282: GO 41191
41284: POP
41285: POP
// if p then
41286: LD_VAR 0 11
41290: IFFALSE 41315
// result := Replace ( result , 4 , p ) ;
41292: LD_ADDR_VAR 0 2
41296: PUSH
41297: LD_VAR 0 2
41301: PPUSH
41302: LD_INT 4
41304: PPUSH
41305: LD_VAR 0 11
41309: PPUSH
41310: CALL_OW 1
41314: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41315: LD_VAR 0 4
41319: PUSH
41320: LD_VAR 0 7
41324: PUSH
41325: LD_INT 6
41327: LESS
41328: AND
41329: IFFALSE 41517
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41331: LD_ADDR_VAR 0 9
41335: PUSH
41336: LD_VAR 0 4
41340: PUSH
41341: LD_VAR 0 8
41345: PUSH
41346: LD_VAR 0 7
41350: UNION
41351: DIFF
41352: PPUSH
41353: LD_INT 3
41355: PPUSH
41356: CALL 106471 0 2
41360: ST_TO_ADDR
// p := [ ] ;
41361: LD_ADDR_VAR 0 11
41365: PUSH
41366: EMPTY
41367: ST_TO_ADDR
// if sort then
41368: LD_VAR 0 9
41372: IFFALSE 41488
// for i = 1 to 6 - mech do
41374: LD_ADDR_VAR 0 3
41378: PUSH
41379: DOUBLE
41380: LD_INT 1
41382: DEC
41383: ST_TO_ADDR
41384: LD_INT 6
41386: PUSH
41387: LD_VAR 0 7
41391: MINUS
41392: PUSH
41393: FOR_TO
41394: IFFALSE 41486
// begin if i = sort then
41396: LD_VAR 0 3
41400: PUSH
41401: LD_VAR 0 9
41405: EQUAL
41406: IFFALSE 41410
// break ;
41408: GO 41486
// if GetClass ( i ) = 3 then
41410: LD_VAR 0 3
41414: PPUSH
41415: CALL_OW 257
41419: PUSH
41420: LD_INT 3
41422: EQUAL
41423: IFFALSE 41427
// continue ;
41425: GO 41393
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41427: LD_ADDR_VAR 0 11
41431: PUSH
41432: LD_VAR 0 11
41436: PPUSH
41437: LD_VAR 0 11
41441: PUSH
41442: LD_INT 1
41444: PLUS
41445: PPUSH
41446: LD_VAR 0 9
41450: PUSH
41451: LD_VAR 0 3
41455: ARRAY
41456: PPUSH
41457: CALL_OW 2
41461: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41462: LD_ADDR_VAR 0 4
41466: PUSH
41467: LD_VAR 0 4
41471: PUSH
41472: LD_VAR 0 9
41476: PUSH
41477: LD_VAR 0 3
41481: ARRAY
41482: DIFF
41483: ST_TO_ADDR
// end ;
41484: GO 41393
41486: POP
41487: POP
// if p then
41488: LD_VAR 0 11
41492: IFFALSE 41517
// result := Replace ( result , 3 , p ) ;
41494: LD_ADDR_VAR 0 2
41498: PUSH
41499: LD_VAR 0 2
41503: PPUSH
41504: LD_INT 3
41506: PPUSH
41507: LD_VAR 0 11
41511: PPUSH
41512: CALL_OW 1
41516: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41517: LD_VAR 0 4
41521: PUSH
41522: LD_INT 6
41524: GREATER
41525: PUSH
41526: LD_VAR 0 6
41530: PUSH
41531: LD_INT 6
41533: LESS
41534: AND
41535: IFFALSE 41729
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41537: LD_ADDR_VAR 0 9
41541: PUSH
41542: LD_VAR 0 4
41546: PUSH
41547: LD_VAR 0 8
41551: PUSH
41552: LD_VAR 0 7
41556: UNION
41557: PUSH
41558: LD_VAR 0 6
41562: UNION
41563: DIFF
41564: PPUSH
41565: LD_INT 2
41567: PPUSH
41568: CALL 106471 0 2
41572: ST_TO_ADDR
// p := [ ] ;
41573: LD_ADDR_VAR 0 11
41577: PUSH
41578: EMPTY
41579: ST_TO_ADDR
// if sort then
41580: LD_VAR 0 9
41584: IFFALSE 41700
// for i = 1 to 6 - eng do
41586: LD_ADDR_VAR 0 3
41590: PUSH
41591: DOUBLE
41592: LD_INT 1
41594: DEC
41595: ST_TO_ADDR
41596: LD_INT 6
41598: PUSH
41599: LD_VAR 0 6
41603: MINUS
41604: PUSH
41605: FOR_TO
41606: IFFALSE 41698
// begin if i = sort then
41608: LD_VAR 0 3
41612: PUSH
41613: LD_VAR 0 9
41617: EQUAL
41618: IFFALSE 41622
// break ;
41620: GO 41698
// if GetClass ( i ) = 2 then
41622: LD_VAR 0 3
41626: PPUSH
41627: CALL_OW 257
41631: PUSH
41632: LD_INT 2
41634: EQUAL
41635: IFFALSE 41639
// continue ;
41637: GO 41605
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41639: LD_ADDR_VAR 0 11
41643: PUSH
41644: LD_VAR 0 11
41648: PPUSH
41649: LD_VAR 0 11
41653: PUSH
41654: LD_INT 1
41656: PLUS
41657: PPUSH
41658: LD_VAR 0 9
41662: PUSH
41663: LD_VAR 0 3
41667: ARRAY
41668: PPUSH
41669: CALL_OW 2
41673: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41674: LD_ADDR_VAR 0 4
41678: PUSH
41679: LD_VAR 0 4
41683: PUSH
41684: LD_VAR 0 9
41688: PUSH
41689: LD_VAR 0 3
41693: ARRAY
41694: DIFF
41695: ST_TO_ADDR
// end ;
41696: GO 41605
41698: POP
41699: POP
// if p then
41700: LD_VAR 0 11
41704: IFFALSE 41729
// result := Replace ( result , 2 , p ) ;
41706: LD_ADDR_VAR 0 2
41710: PUSH
41711: LD_VAR 0 2
41715: PPUSH
41716: LD_INT 2
41718: PPUSH
41719: LD_VAR 0 11
41723: PPUSH
41724: CALL_OW 1
41728: ST_TO_ADDR
// end ; exit ;
41729: GO 43117
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41731: LD_EXP 129
41735: PUSH
41736: LD_EXP 128
41740: PUSH
41741: LD_VAR 0 1
41745: ARRAY
41746: ARRAY
41747: NOT
41748: PUSH
41749: LD_EXP 102
41753: PUSH
41754: LD_VAR 0 1
41758: ARRAY
41759: PPUSH
41760: LD_INT 30
41762: PUSH
41763: LD_INT 3
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PPUSH
41770: CALL_OW 72
41774: AND
41775: PUSH
41776: LD_EXP 107
41780: PUSH
41781: LD_VAR 0 1
41785: ARRAY
41786: AND
41787: IFFALSE 42395
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41789: LD_ADDR_EXP 144
41793: PUSH
41794: LD_EXP 144
41798: PPUSH
41799: LD_VAR 0 1
41803: PPUSH
41804: LD_INT 5
41806: PPUSH
41807: CALL_OW 1
41811: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41812: LD_ADDR_VAR 0 2
41816: PUSH
41817: LD_INT 0
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: LD_INT 0
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: LIST
41833: LIST
41834: ST_TO_ADDR
// if sci > 1 then
41835: LD_VAR 0 8
41839: PUSH
41840: LD_INT 1
41842: GREATER
41843: IFFALSE 41871
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41845: LD_ADDR_VAR 0 4
41849: PUSH
41850: LD_VAR 0 4
41854: PUSH
41855: LD_VAR 0 8
41859: PUSH
41860: LD_VAR 0 8
41864: PUSH
41865: LD_INT 1
41867: ARRAY
41868: DIFF
41869: DIFF
41870: ST_TO_ADDR
// if tmp and not sci then
41871: LD_VAR 0 4
41875: PUSH
41876: LD_VAR 0 8
41880: NOT
41881: AND
41882: IFFALSE 41951
// begin sort := SortBySkill ( tmp , 4 ) ;
41884: LD_ADDR_VAR 0 9
41888: PUSH
41889: LD_VAR 0 4
41893: PPUSH
41894: LD_INT 4
41896: PPUSH
41897: CALL 106471 0 2
41901: ST_TO_ADDR
// if sort then
41902: LD_VAR 0 9
41906: IFFALSE 41922
// p := sort [ 1 ] ;
41908: LD_ADDR_VAR 0 11
41912: PUSH
41913: LD_VAR 0 9
41917: PUSH
41918: LD_INT 1
41920: ARRAY
41921: ST_TO_ADDR
// if p then
41922: LD_VAR 0 11
41926: IFFALSE 41951
// result := Replace ( result , 4 , p ) ;
41928: LD_ADDR_VAR 0 2
41932: PUSH
41933: LD_VAR 0 2
41937: PPUSH
41938: LD_INT 4
41940: PPUSH
41941: LD_VAR 0 11
41945: PPUSH
41946: CALL_OW 1
41950: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41951: LD_ADDR_VAR 0 4
41955: PUSH
41956: LD_VAR 0 4
41960: PUSH
41961: LD_VAR 0 7
41965: DIFF
41966: ST_TO_ADDR
// if tmp and mech < 6 then
41967: LD_VAR 0 4
41971: PUSH
41972: LD_VAR 0 7
41976: PUSH
41977: LD_INT 6
41979: LESS
41980: AND
41981: IFFALSE 42169
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41983: LD_ADDR_VAR 0 9
41987: PUSH
41988: LD_VAR 0 4
41992: PUSH
41993: LD_VAR 0 8
41997: PUSH
41998: LD_VAR 0 7
42002: UNION
42003: DIFF
42004: PPUSH
42005: LD_INT 3
42007: PPUSH
42008: CALL 106471 0 2
42012: ST_TO_ADDR
// p := [ ] ;
42013: LD_ADDR_VAR 0 11
42017: PUSH
42018: EMPTY
42019: ST_TO_ADDR
// if sort then
42020: LD_VAR 0 9
42024: IFFALSE 42140
// for i = 1 to 6 - mech do
42026: LD_ADDR_VAR 0 3
42030: PUSH
42031: DOUBLE
42032: LD_INT 1
42034: DEC
42035: ST_TO_ADDR
42036: LD_INT 6
42038: PUSH
42039: LD_VAR 0 7
42043: MINUS
42044: PUSH
42045: FOR_TO
42046: IFFALSE 42138
// begin if i = sort then
42048: LD_VAR 0 3
42052: PUSH
42053: LD_VAR 0 9
42057: EQUAL
42058: IFFALSE 42062
// break ;
42060: GO 42138
// if GetClass ( i ) = 3 then
42062: LD_VAR 0 3
42066: PPUSH
42067: CALL_OW 257
42071: PUSH
42072: LD_INT 3
42074: EQUAL
42075: IFFALSE 42079
// continue ;
42077: GO 42045
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42079: LD_ADDR_VAR 0 11
42083: PUSH
42084: LD_VAR 0 11
42088: PPUSH
42089: LD_VAR 0 11
42093: PUSH
42094: LD_INT 1
42096: PLUS
42097: PPUSH
42098: LD_VAR 0 9
42102: PUSH
42103: LD_VAR 0 3
42107: ARRAY
42108: PPUSH
42109: CALL_OW 2
42113: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42114: LD_ADDR_VAR 0 4
42118: PUSH
42119: LD_VAR 0 4
42123: PUSH
42124: LD_VAR 0 9
42128: PUSH
42129: LD_VAR 0 3
42133: ARRAY
42134: DIFF
42135: ST_TO_ADDR
// end ;
42136: GO 42045
42138: POP
42139: POP
// if p then
42140: LD_VAR 0 11
42144: IFFALSE 42169
// result := Replace ( result , 3 , p ) ;
42146: LD_ADDR_VAR 0 2
42150: PUSH
42151: LD_VAR 0 2
42155: PPUSH
42156: LD_INT 3
42158: PPUSH
42159: LD_VAR 0 11
42163: PPUSH
42164: CALL_OW 1
42168: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42169: LD_ADDR_VAR 0 4
42173: PUSH
42174: LD_VAR 0 4
42178: PUSH
42179: LD_VAR 0 6
42183: DIFF
42184: ST_TO_ADDR
// if tmp and eng < 6 then
42185: LD_VAR 0 4
42189: PUSH
42190: LD_VAR 0 6
42194: PUSH
42195: LD_INT 6
42197: LESS
42198: AND
42199: IFFALSE 42393
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42201: LD_ADDR_VAR 0 9
42205: PUSH
42206: LD_VAR 0 4
42210: PUSH
42211: LD_VAR 0 8
42215: PUSH
42216: LD_VAR 0 7
42220: UNION
42221: PUSH
42222: LD_VAR 0 6
42226: UNION
42227: DIFF
42228: PPUSH
42229: LD_INT 2
42231: PPUSH
42232: CALL 106471 0 2
42236: ST_TO_ADDR
// p := [ ] ;
42237: LD_ADDR_VAR 0 11
42241: PUSH
42242: EMPTY
42243: ST_TO_ADDR
// if sort then
42244: LD_VAR 0 9
42248: IFFALSE 42364
// for i = 1 to 6 - eng do
42250: LD_ADDR_VAR 0 3
42254: PUSH
42255: DOUBLE
42256: LD_INT 1
42258: DEC
42259: ST_TO_ADDR
42260: LD_INT 6
42262: PUSH
42263: LD_VAR 0 6
42267: MINUS
42268: PUSH
42269: FOR_TO
42270: IFFALSE 42362
// begin if i = sort then
42272: LD_VAR 0 3
42276: PUSH
42277: LD_VAR 0 9
42281: EQUAL
42282: IFFALSE 42286
// break ;
42284: GO 42362
// if GetClass ( i ) = 2 then
42286: LD_VAR 0 3
42290: PPUSH
42291: CALL_OW 257
42295: PUSH
42296: LD_INT 2
42298: EQUAL
42299: IFFALSE 42303
// continue ;
42301: GO 42269
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42303: LD_ADDR_VAR 0 11
42307: PUSH
42308: LD_VAR 0 11
42312: PPUSH
42313: LD_VAR 0 11
42317: PUSH
42318: LD_INT 1
42320: PLUS
42321: PPUSH
42322: LD_VAR 0 9
42326: PUSH
42327: LD_VAR 0 3
42331: ARRAY
42332: PPUSH
42333: CALL_OW 2
42337: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42338: LD_ADDR_VAR 0 4
42342: PUSH
42343: LD_VAR 0 4
42347: PUSH
42348: LD_VAR 0 9
42352: PUSH
42353: LD_VAR 0 3
42357: ARRAY
42358: DIFF
42359: ST_TO_ADDR
// end ;
42360: GO 42269
42362: POP
42363: POP
// if p then
42364: LD_VAR 0 11
42368: IFFALSE 42393
// result := Replace ( result , 2 , p ) ;
42370: LD_ADDR_VAR 0 2
42374: PUSH
42375: LD_VAR 0 2
42379: PPUSH
42380: LD_INT 2
42382: PPUSH
42383: LD_VAR 0 11
42387: PPUSH
42388: CALL_OW 1
42392: ST_TO_ADDR
// end ; exit ;
42393: GO 43117
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42395: LD_EXP 129
42399: PUSH
42400: LD_EXP 128
42404: PUSH
42405: LD_VAR 0 1
42409: ARRAY
42410: ARRAY
42411: NOT
42412: PUSH
42413: LD_EXP 102
42417: PUSH
42418: LD_VAR 0 1
42422: ARRAY
42423: PPUSH
42424: LD_INT 30
42426: PUSH
42427: LD_INT 3
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PPUSH
42434: CALL_OW 72
42438: AND
42439: PUSH
42440: LD_EXP 107
42444: PUSH
42445: LD_VAR 0 1
42449: ARRAY
42450: NOT
42451: AND
42452: IFFALSE 43117
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42454: LD_ADDR_EXP 144
42458: PUSH
42459: LD_EXP 144
42463: PPUSH
42464: LD_VAR 0 1
42468: PPUSH
42469: LD_INT 6
42471: PPUSH
42472: CALL_OW 1
42476: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42477: LD_ADDR_VAR 0 2
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: LD_INT 0
42487: PUSH
42488: LD_INT 0
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: LIST
42498: LIST
42499: ST_TO_ADDR
// if sci >= 1 then
42500: LD_VAR 0 8
42504: PUSH
42505: LD_INT 1
42507: GREATEREQUAL
42508: IFFALSE 42530
// tmp := tmp diff sci [ 1 ] ;
42510: LD_ADDR_VAR 0 4
42514: PUSH
42515: LD_VAR 0 4
42519: PUSH
42520: LD_VAR 0 8
42524: PUSH
42525: LD_INT 1
42527: ARRAY
42528: DIFF
42529: ST_TO_ADDR
// if tmp and not sci then
42530: LD_VAR 0 4
42534: PUSH
42535: LD_VAR 0 8
42539: NOT
42540: AND
42541: IFFALSE 42610
// begin sort := SortBySkill ( tmp , 4 ) ;
42543: LD_ADDR_VAR 0 9
42547: PUSH
42548: LD_VAR 0 4
42552: PPUSH
42553: LD_INT 4
42555: PPUSH
42556: CALL 106471 0 2
42560: ST_TO_ADDR
// if sort then
42561: LD_VAR 0 9
42565: IFFALSE 42581
// p := sort [ 1 ] ;
42567: LD_ADDR_VAR 0 11
42571: PUSH
42572: LD_VAR 0 9
42576: PUSH
42577: LD_INT 1
42579: ARRAY
42580: ST_TO_ADDR
// if p then
42581: LD_VAR 0 11
42585: IFFALSE 42610
// result := Replace ( result , 4 , p ) ;
42587: LD_ADDR_VAR 0 2
42591: PUSH
42592: LD_VAR 0 2
42596: PPUSH
42597: LD_INT 4
42599: PPUSH
42600: LD_VAR 0 11
42604: PPUSH
42605: CALL_OW 1
42609: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42610: LD_ADDR_VAR 0 4
42614: PUSH
42615: LD_VAR 0 4
42619: PUSH
42620: LD_VAR 0 7
42624: DIFF
42625: ST_TO_ADDR
// if tmp and mech < 6 then
42626: LD_VAR 0 4
42630: PUSH
42631: LD_VAR 0 7
42635: PUSH
42636: LD_INT 6
42638: LESS
42639: AND
42640: IFFALSE 42822
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42642: LD_ADDR_VAR 0 9
42646: PUSH
42647: LD_VAR 0 4
42651: PUSH
42652: LD_VAR 0 7
42656: DIFF
42657: PPUSH
42658: LD_INT 3
42660: PPUSH
42661: CALL 106471 0 2
42665: ST_TO_ADDR
// p := [ ] ;
42666: LD_ADDR_VAR 0 11
42670: PUSH
42671: EMPTY
42672: ST_TO_ADDR
// if sort then
42673: LD_VAR 0 9
42677: IFFALSE 42793
// for i = 1 to 6 - mech do
42679: LD_ADDR_VAR 0 3
42683: PUSH
42684: DOUBLE
42685: LD_INT 1
42687: DEC
42688: ST_TO_ADDR
42689: LD_INT 6
42691: PUSH
42692: LD_VAR 0 7
42696: MINUS
42697: PUSH
42698: FOR_TO
42699: IFFALSE 42791
// begin if i = sort then
42701: LD_VAR 0 3
42705: PUSH
42706: LD_VAR 0 9
42710: EQUAL
42711: IFFALSE 42715
// break ;
42713: GO 42791
// if GetClass ( i ) = 3 then
42715: LD_VAR 0 3
42719: PPUSH
42720: CALL_OW 257
42724: PUSH
42725: LD_INT 3
42727: EQUAL
42728: IFFALSE 42732
// continue ;
42730: GO 42698
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42732: LD_ADDR_VAR 0 11
42736: PUSH
42737: LD_VAR 0 11
42741: PPUSH
42742: LD_VAR 0 11
42746: PUSH
42747: LD_INT 1
42749: PLUS
42750: PPUSH
42751: LD_VAR 0 9
42755: PUSH
42756: LD_VAR 0 3
42760: ARRAY
42761: PPUSH
42762: CALL_OW 2
42766: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42767: LD_ADDR_VAR 0 4
42771: PUSH
42772: LD_VAR 0 4
42776: PUSH
42777: LD_VAR 0 9
42781: PUSH
42782: LD_VAR 0 3
42786: ARRAY
42787: DIFF
42788: ST_TO_ADDR
// end ;
42789: GO 42698
42791: POP
42792: POP
// if p then
42793: LD_VAR 0 11
42797: IFFALSE 42822
// result := Replace ( result , 3 , p ) ;
42799: LD_ADDR_VAR 0 2
42803: PUSH
42804: LD_VAR 0 2
42808: PPUSH
42809: LD_INT 3
42811: PPUSH
42812: LD_VAR 0 11
42816: PPUSH
42817: CALL_OW 1
42821: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42822: LD_ADDR_VAR 0 4
42826: PUSH
42827: LD_VAR 0 4
42831: PUSH
42832: LD_VAR 0 6
42836: DIFF
42837: ST_TO_ADDR
// if tmp and eng < 4 then
42838: LD_VAR 0 4
42842: PUSH
42843: LD_VAR 0 6
42847: PUSH
42848: LD_INT 4
42850: LESS
42851: AND
42852: IFFALSE 43042
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42854: LD_ADDR_VAR 0 9
42858: PUSH
42859: LD_VAR 0 4
42863: PUSH
42864: LD_VAR 0 7
42868: PUSH
42869: LD_VAR 0 6
42873: UNION
42874: DIFF
42875: PPUSH
42876: LD_INT 2
42878: PPUSH
42879: CALL 106471 0 2
42883: ST_TO_ADDR
// p := [ ] ;
42884: LD_ADDR_VAR 0 11
42888: PUSH
42889: EMPTY
42890: ST_TO_ADDR
// if sort then
42891: LD_VAR 0 9
42895: IFFALSE 43011
// for i = 1 to 4 - eng do
42897: LD_ADDR_VAR 0 3
42901: PUSH
42902: DOUBLE
42903: LD_INT 1
42905: DEC
42906: ST_TO_ADDR
42907: LD_INT 4
42909: PUSH
42910: LD_VAR 0 6
42914: MINUS
42915: PUSH
42916: FOR_TO
42917: IFFALSE 43009
// begin if i = sort then
42919: LD_VAR 0 3
42923: PUSH
42924: LD_VAR 0 9
42928: EQUAL
42929: IFFALSE 42933
// break ;
42931: GO 43009
// if GetClass ( i ) = 2 then
42933: LD_VAR 0 3
42937: PPUSH
42938: CALL_OW 257
42942: PUSH
42943: LD_INT 2
42945: EQUAL
42946: IFFALSE 42950
// continue ;
42948: GO 42916
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42950: LD_ADDR_VAR 0 11
42954: PUSH
42955: LD_VAR 0 11
42959: PPUSH
42960: LD_VAR 0 11
42964: PUSH
42965: LD_INT 1
42967: PLUS
42968: PPUSH
42969: LD_VAR 0 9
42973: PUSH
42974: LD_VAR 0 3
42978: ARRAY
42979: PPUSH
42980: CALL_OW 2
42984: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42985: LD_ADDR_VAR 0 4
42989: PUSH
42990: LD_VAR 0 4
42994: PUSH
42995: LD_VAR 0 9
42999: PUSH
43000: LD_VAR 0 3
43004: ARRAY
43005: DIFF
43006: ST_TO_ADDR
// end ;
43007: GO 42916
43009: POP
43010: POP
// if p then
43011: LD_VAR 0 11
43015: IFFALSE 43040
// result := Replace ( result , 2 , p ) ;
43017: LD_ADDR_VAR 0 2
43021: PUSH
43022: LD_VAR 0 2
43026: PPUSH
43027: LD_INT 2
43029: PPUSH
43030: LD_VAR 0 11
43034: PPUSH
43035: CALL_OW 1
43039: ST_TO_ADDR
// end else
43040: GO 43086
// for i = eng downto 5 do
43042: LD_ADDR_VAR 0 3
43046: PUSH
43047: DOUBLE
43048: LD_VAR 0 6
43052: INC
43053: ST_TO_ADDR
43054: LD_INT 5
43056: PUSH
43057: FOR_DOWNTO
43058: IFFALSE 43084
// tmp := tmp union eng [ i ] ;
43060: LD_ADDR_VAR 0 4
43064: PUSH
43065: LD_VAR 0 4
43069: PUSH
43070: LD_VAR 0 6
43074: PUSH
43075: LD_VAR 0 3
43079: ARRAY
43080: UNION
43081: ST_TO_ADDR
43082: GO 43057
43084: POP
43085: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43086: LD_ADDR_VAR 0 2
43090: PUSH
43091: LD_VAR 0 2
43095: PPUSH
43096: LD_INT 1
43098: PPUSH
43099: LD_VAR 0 4
43103: PUSH
43104: LD_VAR 0 5
43108: DIFF
43109: PPUSH
43110: CALL_OW 1
43114: ST_TO_ADDR
// exit ;
43115: GO 43117
// end ; end ;
43117: LD_VAR 0 2
43121: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43122: LD_INT 0
43124: PPUSH
43125: PPUSH
43126: PPUSH
// if not mc_bases then
43127: LD_EXP 102
43131: NOT
43132: IFFALSE 43136
// exit ;
43134: GO 43242
// for i = 1 to mc_bases do
43136: LD_ADDR_VAR 0 2
43140: PUSH
43141: DOUBLE
43142: LD_INT 1
43144: DEC
43145: ST_TO_ADDR
43146: LD_EXP 102
43150: PUSH
43151: FOR_TO
43152: IFFALSE 43233
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43154: LD_ADDR_VAR 0 3
43158: PUSH
43159: LD_EXP 102
43163: PUSH
43164: LD_VAR 0 2
43168: ARRAY
43169: PPUSH
43170: LD_INT 21
43172: PUSH
43173: LD_INT 3
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PUSH
43180: LD_INT 3
43182: PUSH
43183: LD_INT 24
43185: PUSH
43186: LD_INT 1000
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PPUSH
43201: CALL_OW 72
43205: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43206: LD_ADDR_EXP 103
43210: PUSH
43211: LD_EXP 103
43215: PPUSH
43216: LD_VAR 0 2
43220: PPUSH
43221: LD_VAR 0 3
43225: PPUSH
43226: CALL_OW 1
43230: ST_TO_ADDR
// end ;
43231: GO 43151
43233: POP
43234: POP
// RaiseSailEvent ( 101 ) ;
43235: LD_INT 101
43237: PPUSH
43238: CALL_OW 427
// end ;
43242: LD_VAR 0 1
43246: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43247: LD_INT 0
43249: PPUSH
43250: PPUSH
43251: PPUSH
43252: PPUSH
43253: PPUSH
43254: PPUSH
43255: PPUSH
// if not mc_bases then
43256: LD_EXP 102
43260: NOT
43261: IFFALSE 43265
// exit ;
43263: GO 43838
// for i = 1 to mc_bases do
43265: LD_ADDR_VAR 0 2
43269: PUSH
43270: DOUBLE
43271: LD_INT 1
43273: DEC
43274: ST_TO_ADDR
43275: LD_EXP 102
43279: PUSH
43280: FOR_TO
43281: IFFALSE 43829
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43283: LD_ADDR_VAR 0 5
43287: PUSH
43288: LD_EXP 102
43292: PUSH
43293: LD_VAR 0 2
43297: ARRAY
43298: PUSH
43299: LD_EXP 131
43303: PUSH
43304: LD_VAR 0 2
43308: ARRAY
43309: UNION
43310: PPUSH
43311: LD_INT 21
43313: PUSH
43314: LD_INT 1
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 1
43323: PUSH
43324: LD_INT 3
43326: PUSH
43327: LD_INT 54
43329: PUSH
43330: EMPTY
43331: LIST
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 3
43339: PUSH
43340: LD_INT 24
43342: PUSH
43343: LD_INT 800
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: LIST
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PPUSH
43363: CALL_OW 72
43367: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43368: LD_ADDR_VAR 0 6
43372: PUSH
43373: LD_EXP 102
43377: PUSH
43378: LD_VAR 0 2
43382: ARRAY
43383: PPUSH
43384: LD_INT 21
43386: PUSH
43387: LD_INT 1
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: PUSH
43397: LD_INT 3
43399: PUSH
43400: LD_INT 54
43402: PUSH
43403: EMPTY
43404: LIST
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 3
43412: PUSH
43413: LD_INT 24
43415: PUSH
43416: LD_INT 250
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: LIST
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PPUSH
43436: CALL_OW 72
43440: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43441: LD_ADDR_VAR 0 7
43445: PUSH
43446: LD_VAR 0 5
43450: PUSH
43451: LD_VAR 0 6
43455: DIFF
43456: ST_TO_ADDR
// if not need_heal_1 then
43457: LD_VAR 0 6
43461: NOT
43462: IFFALSE 43495
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43464: LD_ADDR_EXP 105
43468: PUSH
43469: LD_EXP 105
43473: PPUSH
43474: LD_VAR 0 2
43478: PUSH
43479: LD_INT 1
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PPUSH
43486: EMPTY
43487: PPUSH
43488: CALL 72213 0 3
43492: ST_TO_ADDR
43493: GO 43565
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43495: LD_ADDR_EXP 105
43499: PUSH
43500: LD_EXP 105
43504: PPUSH
43505: LD_VAR 0 2
43509: PUSH
43510: LD_INT 1
43512: PUSH
43513: EMPTY
43514: LIST
43515: LIST
43516: PPUSH
43517: LD_EXP 105
43521: PUSH
43522: LD_VAR 0 2
43526: ARRAY
43527: PUSH
43528: LD_INT 1
43530: ARRAY
43531: PPUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 24
43537: PUSH
43538: LD_INT 1000
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PPUSH
43549: CALL_OW 72
43553: PUSH
43554: LD_VAR 0 6
43558: UNION
43559: PPUSH
43560: CALL 72213 0 3
43564: ST_TO_ADDR
// if not need_heal_2 then
43565: LD_VAR 0 7
43569: NOT
43570: IFFALSE 43603
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43572: LD_ADDR_EXP 105
43576: PUSH
43577: LD_EXP 105
43581: PPUSH
43582: LD_VAR 0 2
43586: PUSH
43587: LD_INT 2
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PPUSH
43594: EMPTY
43595: PPUSH
43596: CALL 72213 0 3
43600: ST_TO_ADDR
43601: GO 43635
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43603: LD_ADDR_EXP 105
43607: PUSH
43608: LD_EXP 105
43612: PPUSH
43613: LD_VAR 0 2
43617: PUSH
43618: LD_INT 2
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PPUSH
43625: LD_VAR 0 7
43629: PPUSH
43630: CALL 72213 0 3
43634: ST_TO_ADDR
// if need_heal_2 then
43635: LD_VAR 0 7
43639: IFFALSE 43811
// for j in need_heal_2 do
43641: LD_ADDR_VAR 0 3
43645: PUSH
43646: LD_VAR 0 7
43650: PUSH
43651: FOR_IN
43652: IFFALSE 43809
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43654: LD_ADDR_VAR 0 5
43658: PUSH
43659: LD_EXP 102
43663: PUSH
43664: LD_VAR 0 2
43668: ARRAY
43669: PPUSH
43670: LD_INT 2
43672: PUSH
43673: LD_INT 30
43675: PUSH
43676: LD_INT 6
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 30
43685: PUSH
43686: LD_INT 7
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 30
43695: PUSH
43696: LD_INT 8
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 30
43705: PUSH
43706: LD_INT 0
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: LD_INT 30
43715: PUSH
43716: LD_INT 1
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 25
43725: PUSH
43726: LD_INT 4
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: PPUSH
43742: CALL_OW 72
43746: ST_TO_ADDR
// if tmp then
43747: LD_VAR 0 5
43751: IFFALSE 43807
// begin k := NearestUnitToUnit ( tmp , j ) ;
43753: LD_ADDR_VAR 0 4
43757: PUSH
43758: LD_VAR 0 5
43762: PPUSH
43763: LD_VAR 0 3
43767: PPUSH
43768: CALL_OW 74
43772: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43773: LD_VAR 0 3
43777: PPUSH
43778: LD_VAR 0 4
43782: PPUSH
43783: CALL_OW 296
43787: PUSH
43788: LD_INT 7
43790: GREATER
43791: IFFALSE 43807
// ComMoveUnit ( j , k ) ;
43793: LD_VAR 0 3
43797: PPUSH
43798: LD_VAR 0 4
43802: PPUSH
43803: CALL_OW 112
// end ; end ;
43807: GO 43651
43809: POP
43810: POP
// if not need_heal_1 and not need_heal_2 then
43811: LD_VAR 0 6
43815: NOT
43816: PUSH
43817: LD_VAR 0 7
43821: NOT
43822: AND
43823: IFFALSE 43827
// continue ;
43825: GO 43280
// end ;
43827: GO 43280
43829: POP
43830: POP
// RaiseSailEvent ( 102 ) ;
43831: LD_INT 102
43833: PPUSH
43834: CALL_OW 427
// end ;
43838: LD_VAR 0 1
43842: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43843: LD_INT 0
43845: PPUSH
43846: PPUSH
43847: PPUSH
43848: PPUSH
43849: PPUSH
43850: PPUSH
43851: PPUSH
43852: PPUSH
// if not mc_bases then
43853: LD_EXP 102
43857: NOT
43858: IFFALSE 43862
// exit ;
43860: GO 44702
// for i = 1 to mc_bases do
43862: LD_ADDR_VAR 0 2
43866: PUSH
43867: DOUBLE
43868: LD_INT 1
43870: DEC
43871: ST_TO_ADDR
43872: LD_EXP 102
43876: PUSH
43877: FOR_TO
43878: IFFALSE 44700
// begin if not mc_building_need_repair [ i ] then
43880: LD_EXP 103
43884: PUSH
43885: LD_VAR 0 2
43889: ARRAY
43890: NOT
43891: IFFALSE 44065
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43893: LD_ADDR_VAR 0 6
43897: PUSH
43898: LD_EXP 121
43902: PUSH
43903: LD_VAR 0 2
43907: ARRAY
43908: PPUSH
43909: LD_INT 3
43911: PUSH
43912: LD_INT 24
43914: PUSH
43915: LD_INT 1000
43917: PUSH
43918: EMPTY
43919: LIST
43920: LIST
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 2
43928: PUSH
43929: LD_INT 34
43931: PUSH
43932: LD_INT 13
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 34
43941: PUSH
43942: LD_INT 52
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: LIST
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PPUSH
43958: CALL_OW 72
43962: ST_TO_ADDR
// if cranes then
43963: LD_VAR 0 6
43967: IFFALSE 44029
// for j in cranes do
43969: LD_ADDR_VAR 0 3
43973: PUSH
43974: LD_VAR 0 6
43978: PUSH
43979: FOR_IN
43980: IFFALSE 44027
// if not IsInArea ( j , mc_parking [ i ] ) then
43982: LD_VAR 0 3
43986: PPUSH
43987: LD_EXP 126
43991: PUSH
43992: LD_VAR 0 2
43996: ARRAY
43997: PPUSH
43998: CALL_OW 308
44002: NOT
44003: IFFALSE 44025
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44005: LD_VAR 0 3
44009: PPUSH
44010: LD_EXP 126
44014: PUSH
44015: LD_VAR 0 2
44019: ARRAY
44020: PPUSH
44021: CALL_OW 113
44025: GO 43979
44027: POP
44028: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44029: LD_ADDR_EXP 104
44033: PUSH
44034: LD_EXP 104
44038: PPUSH
44039: LD_VAR 0 2
44043: PPUSH
44044: EMPTY
44045: PPUSH
44046: CALL_OW 1
44050: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44051: LD_VAR 0 2
44055: PPUSH
44056: LD_INT 101
44058: PPUSH
44059: CALL 38955 0 2
// continue ;
44063: GO 43877
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44065: LD_ADDR_EXP 108
44069: PUSH
44070: LD_EXP 108
44074: PPUSH
44075: LD_VAR 0 2
44079: PPUSH
44080: EMPTY
44081: PPUSH
44082: CALL_OW 1
44086: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44087: LD_VAR 0 2
44091: PPUSH
44092: LD_INT 103
44094: PPUSH
44095: CALL 38955 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44099: LD_ADDR_VAR 0 5
44103: PUSH
44104: LD_EXP 102
44108: PUSH
44109: LD_VAR 0 2
44113: ARRAY
44114: PUSH
44115: LD_EXP 131
44119: PUSH
44120: LD_VAR 0 2
44124: ARRAY
44125: UNION
44126: PPUSH
44127: LD_INT 2
44129: PUSH
44130: LD_INT 25
44132: PUSH
44133: LD_INT 2
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 25
44142: PUSH
44143: LD_INT 16
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: LIST
44154: PUSH
44155: EMPTY
44156: LIST
44157: PPUSH
44158: CALL_OW 72
44162: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44163: LD_ADDR_VAR 0 6
44167: PUSH
44168: LD_EXP 121
44172: PUSH
44173: LD_VAR 0 2
44177: ARRAY
44178: PPUSH
44179: LD_INT 2
44181: PUSH
44182: LD_INT 34
44184: PUSH
44185: LD_INT 13
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 34
44194: PUSH
44195: LD_INT 52
44197: PUSH
44198: EMPTY
44199: LIST
44200: LIST
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: LIST
44206: PPUSH
44207: CALL_OW 72
44211: ST_TO_ADDR
// if cranes then
44212: LD_VAR 0 6
44216: IFFALSE 44352
// begin for j in cranes do
44218: LD_ADDR_VAR 0 3
44222: PUSH
44223: LD_VAR 0 6
44227: PUSH
44228: FOR_IN
44229: IFFALSE 44350
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44231: LD_VAR 0 3
44235: PPUSH
44236: CALL_OW 256
44240: PUSH
44241: LD_INT 500
44243: GREATEREQUAL
44244: PUSH
44245: LD_VAR 0 3
44249: PPUSH
44250: CALL_OW 314
44254: NOT
44255: AND
44256: IFFALSE 44290
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44258: LD_VAR 0 3
44262: PPUSH
44263: LD_EXP 103
44267: PUSH
44268: LD_VAR 0 2
44272: ARRAY
44273: PPUSH
44274: LD_VAR 0 3
44278: PPUSH
44279: CALL_OW 74
44283: PPUSH
44284: CALL_OW 130
44288: GO 44348
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44290: LD_VAR 0 3
44294: PPUSH
44295: CALL_OW 256
44299: PUSH
44300: LD_INT 500
44302: LESS
44303: PUSH
44304: LD_VAR 0 3
44308: PPUSH
44309: LD_EXP 126
44313: PUSH
44314: LD_VAR 0 2
44318: ARRAY
44319: PPUSH
44320: CALL_OW 308
44324: NOT
44325: AND
44326: IFFALSE 44348
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44328: LD_VAR 0 3
44332: PPUSH
44333: LD_EXP 126
44337: PUSH
44338: LD_VAR 0 2
44342: ARRAY
44343: PPUSH
44344: CALL_OW 113
44348: GO 44228
44350: POP
44351: POP
// end ; if not tmp then
44352: LD_VAR 0 5
44356: NOT
44357: IFFALSE 44361
// continue ;
44359: GO 43877
// for j in tmp do
44361: LD_ADDR_VAR 0 3
44365: PUSH
44366: LD_VAR 0 5
44370: PUSH
44371: FOR_IN
44372: IFFALSE 44696
// begin if mc_need_heal [ i ] then
44374: LD_EXP 105
44378: PUSH
44379: LD_VAR 0 2
44383: ARRAY
44384: IFFALSE 44432
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44386: LD_VAR 0 3
44390: PUSH
44391: LD_EXP 105
44395: PUSH
44396: LD_VAR 0 2
44400: ARRAY
44401: PUSH
44402: LD_INT 1
44404: ARRAY
44405: IN
44406: PUSH
44407: LD_VAR 0 3
44411: PUSH
44412: LD_EXP 105
44416: PUSH
44417: LD_VAR 0 2
44421: ARRAY
44422: PUSH
44423: LD_INT 2
44425: ARRAY
44426: IN
44427: OR
44428: IFFALSE 44432
// continue ;
44430: GO 44371
// if IsInUnit ( j ) then
44432: LD_VAR 0 3
44436: PPUSH
44437: CALL_OW 310
44441: IFFALSE 44452
// ComExitBuilding ( j ) ;
44443: LD_VAR 0 3
44447: PPUSH
44448: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44452: LD_VAR 0 3
44456: PUSH
44457: LD_EXP 104
44461: PUSH
44462: LD_VAR 0 2
44466: ARRAY
44467: IN
44468: NOT
44469: IFFALSE 44527
// begin SetTag ( j , 101 ) ;
44471: LD_VAR 0 3
44475: PPUSH
44476: LD_INT 101
44478: PPUSH
44479: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44483: LD_ADDR_EXP 104
44487: PUSH
44488: LD_EXP 104
44492: PPUSH
44493: LD_VAR 0 2
44497: PUSH
44498: LD_EXP 104
44502: PUSH
44503: LD_VAR 0 2
44507: ARRAY
44508: PUSH
44509: LD_INT 1
44511: PLUS
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PPUSH
44517: LD_VAR 0 3
44521: PPUSH
44522: CALL 72213 0 3
44526: ST_TO_ADDR
// end ; wait ( 1 ) ;
44527: LD_INT 1
44529: PPUSH
44530: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44534: LD_ADDR_VAR 0 7
44538: PUSH
44539: LD_EXP 103
44543: PUSH
44544: LD_VAR 0 2
44548: ARRAY
44549: ST_TO_ADDR
// if mc_scan [ i ] then
44550: LD_EXP 125
44554: PUSH
44555: LD_VAR 0 2
44559: ARRAY
44560: IFFALSE 44629
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44562: LD_ADDR_VAR 0 7
44566: PUSH
44567: LD_EXP 103
44571: PUSH
44572: LD_VAR 0 2
44576: ARRAY
44577: PPUSH
44578: LD_INT 3
44580: PUSH
44581: LD_INT 2
44583: PUSH
44584: LD_INT 30
44586: PUSH
44587: LD_INT 32
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: PUSH
44594: LD_INT 30
44596: PUSH
44597: LD_INT 33
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 30
44606: PUSH
44607: LD_INT 31
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: PUSH
44620: EMPTY
44621: LIST
44622: LIST
44623: PPUSH
44624: CALL_OW 72
44628: ST_TO_ADDR
// if not to_repair_tmp then
44629: LD_VAR 0 7
44633: NOT
44634: IFFALSE 44638
// continue ;
44636: GO 44371
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44638: LD_ADDR_VAR 0 8
44642: PUSH
44643: LD_VAR 0 7
44647: PPUSH
44648: LD_VAR 0 3
44652: PPUSH
44653: CALL_OW 74
44657: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44658: LD_VAR 0 8
44662: PPUSH
44663: LD_INT 14
44665: PPUSH
44666: CALL 74806 0 2
44670: PUSH
44671: LD_INT 4
44673: ARRAY
44674: PUSH
44675: LD_INT 5
44677: LESS
44678: IFFALSE 44694
// ComRepairBuilding ( j , to_repair ) ;
44680: LD_VAR 0 3
44684: PPUSH
44685: LD_VAR 0 8
44689: PPUSH
44690: CALL_OW 130
// end ;
44694: GO 44371
44696: POP
44697: POP
// end ;
44698: GO 43877
44700: POP
44701: POP
// end ;
44702: LD_VAR 0 1
44706: RET
// export function MC_Heal ; var i , j , tmp ; begin
44707: LD_INT 0
44709: PPUSH
44710: PPUSH
44711: PPUSH
44712: PPUSH
// if not mc_bases then
44713: LD_EXP 102
44717: NOT
44718: IFFALSE 44722
// exit ;
44720: GO 45124
// for i = 1 to mc_bases do
44722: LD_ADDR_VAR 0 2
44726: PUSH
44727: DOUBLE
44728: LD_INT 1
44730: DEC
44731: ST_TO_ADDR
44732: LD_EXP 102
44736: PUSH
44737: FOR_TO
44738: IFFALSE 45122
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44740: LD_EXP 105
44744: PUSH
44745: LD_VAR 0 2
44749: ARRAY
44750: PUSH
44751: LD_INT 1
44753: ARRAY
44754: NOT
44755: PUSH
44756: LD_EXP 105
44760: PUSH
44761: LD_VAR 0 2
44765: ARRAY
44766: PUSH
44767: LD_INT 2
44769: ARRAY
44770: NOT
44771: AND
44772: IFFALSE 44810
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44774: LD_ADDR_EXP 106
44778: PUSH
44779: LD_EXP 106
44783: PPUSH
44784: LD_VAR 0 2
44788: PPUSH
44789: EMPTY
44790: PPUSH
44791: CALL_OW 1
44795: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44796: LD_VAR 0 2
44800: PPUSH
44801: LD_INT 102
44803: PPUSH
44804: CALL 38955 0 2
// continue ;
44808: GO 44737
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44810: LD_ADDR_VAR 0 4
44814: PUSH
44815: LD_EXP 102
44819: PUSH
44820: LD_VAR 0 2
44824: ARRAY
44825: PPUSH
44826: LD_INT 25
44828: PUSH
44829: LD_INT 4
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PPUSH
44836: CALL_OW 72
44840: ST_TO_ADDR
// if not tmp then
44841: LD_VAR 0 4
44845: NOT
44846: IFFALSE 44850
// continue ;
44848: GO 44737
// if mc_taming [ i ] then
44850: LD_EXP 133
44854: PUSH
44855: LD_VAR 0 2
44859: ARRAY
44860: IFFALSE 44884
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44862: LD_ADDR_EXP 133
44866: PUSH
44867: LD_EXP 133
44871: PPUSH
44872: LD_VAR 0 2
44876: PPUSH
44877: EMPTY
44878: PPUSH
44879: CALL_OW 1
44883: ST_TO_ADDR
// for j in tmp do
44884: LD_ADDR_VAR 0 3
44888: PUSH
44889: LD_VAR 0 4
44893: PUSH
44894: FOR_IN
44895: IFFALSE 45118
// begin if IsInUnit ( j ) then
44897: LD_VAR 0 3
44901: PPUSH
44902: CALL_OW 310
44906: IFFALSE 44917
// ComExitBuilding ( j ) ;
44908: LD_VAR 0 3
44912: PPUSH
44913: CALL_OW 122
// if not j in mc_healers [ i ] then
44917: LD_VAR 0 3
44921: PUSH
44922: LD_EXP 106
44926: PUSH
44927: LD_VAR 0 2
44931: ARRAY
44932: IN
44933: NOT
44934: IFFALSE 44980
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44936: LD_ADDR_EXP 106
44940: PUSH
44941: LD_EXP 106
44945: PPUSH
44946: LD_VAR 0 2
44950: PUSH
44951: LD_EXP 106
44955: PUSH
44956: LD_VAR 0 2
44960: ARRAY
44961: PUSH
44962: LD_INT 1
44964: PLUS
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PPUSH
44970: LD_VAR 0 3
44974: PPUSH
44975: CALL 72213 0 3
44979: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44980: LD_VAR 0 3
44984: PPUSH
44985: CALL_OW 110
44989: PUSH
44990: LD_INT 102
44992: NONEQUAL
44993: IFFALSE 45007
// SetTag ( j , 102 ) ;
44995: LD_VAR 0 3
44999: PPUSH
45000: LD_INT 102
45002: PPUSH
45003: CALL_OW 109
// Wait ( 3 ) ;
45007: LD_INT 3
45009: PPUSH
45010: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45014: LD_EXP 105
45018: PUSH
45019: LD_VAR 0 2
45023: ARRAY
45024: PUSH
45025: LD_INT 1
45027: ARRAY
45028: IFFALSE 45060
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45030: LD_VAR 0 3
45034: PPUSH
45035: LD_EXP 105
45039: PUSH
45040: LD_VAR 0 2
45044: ARRAY
45045: PUSH
45046: LD_INT 1
45048: ARRAY
45049: PUSH
45050: LD_INT 1
45052: ARRAY
45053: PPUSH
45054: CALL_OW 128
45058: GO 45116
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45060: LD_VAR 0 3
45064: PPUSH
45065: CALL_OW 314
45069: NOT
45070: PUSH
45071: LD_EXP 105
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: PUSH
45082: LD_INT 2
45084: ARRAY
45085: AND
45086: IFFALSE 45116
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45088: LD_VAR 0 3
45092: PPUSH
45093: LD_EXP 105
45097: PUSH
45098: LD_VAR 0 2
45102: ARRAY
45103: PUSH
45104: LD_INT 2
45106: ARRAY
45107: PUSH
45108: LD_INT 1
45110: ARRAY
45111: PPUSH
45112: CALL_OW 128
// end ;
45116: GO 44894
45118: POP
45119: POP
// end ;
45120: GO 44737
45122: POP
45123: POP
// end ;
45124: LD_VAR 0 1
45128: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45129: LD_INT 0
45131: PPUSH
45132: PPUSH
45133: PPUSH
45134: PPUSH
45135: PPUSH
// if not mc_bases then
45136: LD_EXP 102
45140: NOT
45141: IFFALSE 45145
// exit ;
45143: GO 46288
// for i = 1 to mc_bases do
45145: LD_ADDR_VAR 0 2
45149: PUSH
45150: DOUBLE
45151: LD_INT 1
45153: DEC
45154: ST_TO_ADDR
45155: LD_EXP 102
45159: PUSH
45160: FOR_TO
45161: IFFALSE 46286
// begin if mc_scan [ i ] then
45163: LD_EXP 125
45167: PUSH
45168: LD_VAR 0 2
45172: ARRAY
45173: IFFALSE 45177
// continue ;
45175: GO 45160
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45177: LD_EXP 107
45181: PUSH
45182: LD_VAR 0 2
45186: ARRAY
45187: NOT
45188: PUSH
45189: LD_EXP 109
45193: PUSH
45194: LD_VAR 0 2
45198: ARRAY
45199: NOT
45200: AND
45201: PUSH
45202: LD_EXP 108
45206: PUSH
45207: LD_VAR 0 2
45211: ARRAY
45212: AND
45213: IFFALSE 45251
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45215: LD_ADDR_EXP 108
45219: PUSH
45220: LD_EXP 108
45224: PPUSH
45225: LD_VAR 0 2
45229: PPUSH
45230: EMPTY
45231: PPUSH
45232: CALL_OW 1
45236: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45237: LD_VAR 0 2
45241: PPUSH
45242: LD_INT 103
45244: PPUSH
45245: CALL 38955 0 2
// continue ;
45249: GO 45160
// end ; if mc_construct_list [ i ] then
45251: LD_EXP 109
45255: PUSH
45256: LD_VAR 0 2
45260: ARRAY
45261: IFFALSE 45481
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45263: LD_ADDR_VAR 0 4
45267: PUSH
45268: LD_EXP 102
45272: PUSH
45273: LD_VAR 0 2
45277: ARRAY
45278: PPUSH
45279: LD_INT 25
45281: PUSH
45282: LD_INT 2
45284: PUSH
45285: EMPTY
45286: LIST
45287: LIST
45288: PPUSH
45289: CALL_OW 72
45293: PUSH
45294: LD_EXP 104
45298: PUSH
45299: LD_VAR 0 2
45303: ARRAY
45304: DIFF
45305: ST_TO_ADDR
// if not tmp then
45306: LD_VAR 0 4
45310: NOT
45311: IFFALSE 45315
// continue ;
45313: GO 45160
// for j in tmp do
45315: LD_ADDR_VAR 0 3
45319: PUSH
45320: LD_VAR 0 4
45324: PUSH
45325: FOR_IN
45326: IFFALSE 45477
// begin if not mc_builders [ i ] then
45328: LD_EXP 108
45332: PUSH
45333: LD_VAR 0 2
45337: ARRAY
45338: NOT
45339: IFFALSE 45397
// begin SetTag ( j , 103 ) ;
45341: LD_VAR 0 3
45345: PPUSH
45346: LD_INT 103
45348: PPUSH
45349: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45353: LD_ADDR_EXP 108
45357: PUSH
45358: LD_EXP 108
45362: PPUSH
45363: LD_VAR 0 2
45367: PUSH
45368: LD_EXP 108
45372: PUSH
45373: LD_VAR 0 2
45377: ARRAY
45378: PUSH
45379: LD_INT 1
45381: PLUS
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PPUSH
45387: LD_VAR 0 3
45391: PPUSH
45392: CALL 72213 0 3
45396: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45397: LD_VAR 0 3
45401: PPUSH
45402: CALL_OW 310
45406: IFFALSE 45417
// ComExitBuilding ( j ) ;
45408: LD_VAR 0 3
45412: PPUSH
45413: CALL_OW 122
// wait ( 3 ) ;
45417: LD_INT 3
45419: PPUSH
45420: CALL_OW 67
// if not mc_construct_list [ i ] then
45424: LD_EXP 109
45428: PUSH
45429: LD_VAR 0 2
45433: ARRAY
45434: NOT
45435: IFFALSE 45439
// break ;
45437: GO 45477
// if not HasTask ( j ) then
45439: LD_VAR 0 3
45443: PPUSH
45444: CALL_OW 314
45448: NOT
45449: IFFALSE 45475
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45451: LD_VAR 0 3
45455: PPUSH
45456: LD_EXP 109
45460: PUSH
45461: LD_VAR 0 2
45465: ARRAY
45466: PUSH
45467: LD_INT 1
45469: ARRAY
45470: PPUSH
45471: CALL 75064 0 2
// end ;
45475: GO 45325
45477: POP
45478: POP
// end else
45479: GO 46284
// if mc_build_list [ i ] then
45481: LD_EXP 107
45485: PUSH
45486: LD_VAR 0 2
45490: ARRAY
45491: IFFALSE 46284
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45493: LD_ADDR_VAR 0 5
45497: PUSH
45498: LD_EXP 102
45502: PUSH
45503: LD_VAR 0 2
45507: ARRAY
45508: PPUSH
45509: LD_INT 2
45511: PUSH
45512: LD_INT 30
45514: PUSH
45515: LD_INT 0
45517: PUSH
45518: EMPTY
45519: LIST
45520: LIST
45521: PUSH
45522: LD_INT 30
45524: PUSH
45525: LD_INT 1
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: LIST
45536: PPUSH
45537: CALL_OW 72
45541: ST_TO_ADDR
// if depot then
45542: LD_VAR 0 5
45546: IFFALSE 45564
// depot := depot [ 1 ] else
45548: LD_ADDR_VAR 0 5
45552: PUSH
45553: LD_VAR 0 5
45557: PUSH
45558: LD_INT 1
45560: ARRAY
45561: ST_TO_ADDR
45562: GO 45572
// depot := 0 ;
45564: LD_ADDR_VAR 0 5
45568: PUSH
45569: LD_INT 0
45571: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45572: LD_EXP 107
45576: PUSH
45577: LD_VAR 0 2
45581: ARRAY
45582: PUSH
45583: LD_INT 1
45585: ARRAY
45586: PUSH
45587: LD_INT 1
45589: ARRAY
45590: PPUSH
45591: CALL 74894 0 1
45595: PUSH
45596: LD_EXP 102
45600: PUSH
45601: LD_VAR 0 2
45605: ARRAY
45606: PPUSH
45607: LD_INT 2
45609: PUSH
45610: LD_INT 30
45612: PUSH
45613: LD_INT 2
45615: PUSH
45616: EMPTY
45617: LIST
45618: LIST
45619: PUSH
45620: LD_INT 30
45622: PUSH
45623: LD_INT 3
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: LIST
45634: PPUSH
45635: CALL_OW 72
45639: NOT
45640: AND
45641: IFFALSE 45746
// begin for j = 1 to mc_build_list [ i ] do
45643: LD_ADDR_VAR 0 3
45647: PUSH
45648: DOUBLE
45649: LD_INT 1
45651: DEC
45652: ST_TO_ADDR
45653: LD_EXP 107
45657: PUSH
45658: LD_VAR 0 2
45662: ARRAY
45663: PUSH
45664: FOR_TO
45665: IFFALSE 45744
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45667: LD_EXP 107
45671: PUSH
45672: LD_VAR 0 2
45676: ARRAY
45677: PUSH
45678: LD_VAR 0 3
45682: ARRAY
45683: PUSH
45684: LD_INT 1
45686: ARRAY
45687: PUSH
45688: LD_INT 2
45690: EQUAL
45691: IFFALSE 45742
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45693: LD_ADDR_EXP 107
45697: PUSH
45698: LD_EXP 107
45702: PPUSH
45703: LD_VAR 0 2
45707: PPUSH
45708: LD_EXP 107
45712: PUSH
45713: LD_VAR 0 2
45717: ARRAY
45718: PPUSH
45719: LD_VAR 0 3
45723: PPUSH
45724: LD_INT 1
45726: PPUSH
45727: LD_INT 0
45729: PPUSH
45730: CALL 71631 0 4
45734: PPUSH
45735: CALL_OW 1
45739: ST_TO_ADDR
// break ;
45740: GO 45744
// end ;
45742: GO 45664
45744: POP
45745: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45746: LD_EXP 107
45750: PUSH
45751: LD_VAR 0 2
45755: ARRAY
45756: PUSH
45757: LD_INT 1
45759: ARRAY
45760: PUSH
45761: LD_INT 1
45763: ARRAY
45764: PUSH
45765: LD_INT 0
45767: EQUAL
45768: PUSH
45769: LD_VAR 0 5
45773: PUSH
45774: LD_VAR 0 5
45778: PPUSH
45779: LD_EXP 107
45783: PUSH
45784: LD_VAR 0 2
45788: ARRAY
45789: PUSH
45790: LD_INT 1
45792: ARRAY
45793: PUSH
45794: LD_INT 1
45796: ARRAY
45797: PPUSH
45798: LD_EXP 107
45802: PUSH
45803: LD_VAR 0 2
45807: ARRAY
45808: PUSH
45809: LD_INT 1
45811: ARRAY
45812: PUSH
45813: LD_INT 2
45815: ARRAY
45816: PPUSH
45817: LD_EXP 107
45821: PUSH
45822: LD_VAR 0 2
45826: ARRAY
45827: PUSH
45828: LD_INT 1
45830: ARRAY
45831: PUSH
45832: LD_INT 3
45834: ARRAY
45835: PPUSH
45836: LD_EXP 107
45840: PUSH
45841: LD_VAR 0 2
45845: ARRAY
45846: PUSH
45847: LD_INT 1
45849: ARRAY
45850: PUSH
45851: LD_INT 4
45853: ARRAY
45854: PPUSH
45855: CALL 79628 0 5
45859: AND
45860: OR
45861: IFFALSE 46142
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45863: LD_ADDR_VAR 0 4
45867: PUSH
45868: LD_EXP 102
45872: PUSH
45873: LD_VAR 0 2
45877: ARRAY
45878: PPUSH
45879: LD_INT 25
45881: PUSH
45882: LD_INT 2
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PPUSH
45889: CALL_OW 72
45893: PUSH
45894: LD_EXP 104
45898: PUSH
45899: LD_VAR 0 2
45903: ARRAY
45904: DIFF
45905: ST_TO_ADDR
// if not tmp then
45906: LD_VAR 0 4
45910: NOT
45911: IFFALSE 45915
// continue ;
45913: GO 45160
// for j in tmp do
45915: LD_ADDR_VAR 0 3
45919: PUSH
45920: LD_VAR 0 4
45924: PUSH
45925: FOR_IN
45926: IFFALSE 46138
// begin if not mc_builders [ i ] then
45928: LD_EXP 108
45932: PUSH
45933: LD_VAR 0 2
45937: ARRAY
45938: NOT
45939: IFFALSE 45997
// begin SetTag ( j , 103 ) ;
45941: LD_VAR 0 3
45945: PPUSH
45946: LD_INT 103
45948: PPUSH
45949: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45953: LD_ADDR_EXP 108
45957: PUSH
45958: LD_EXP 108
45962: PPUSH
45963: LD_VAR 0 2
45967: PUSH
45968: LD_EXP 108
45972: PUSH
45973: LD_VAR 0 2
45977: ARRAY
45978: PUSH
45979: LD_INT 1
45981: PLUS
45982: PUSH
45983: EMPTY
45984: LIST
45985: LIST
45986: PPUSH
45987: LD_VAR 0 3
45991: PPUSH
45992: CALL 72213 0 3
45996: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45997: LD_VAR 0 3
46001: PPUSH
46002: CALL_OW 310
46006: IFFALSE 46017
// ComExitBuilding ( j ) ;
46008: LD_VAR 0 3
46012: PPUSH
46013: CALL_OW 122
// wait ( 3 ) ;
46017: LD_INT 3
46019: PPUSH
46020: CALL_OW 67
// if not mc_build_list [ i ] then
46024: LD_EXP 107
46028: PUSH
46029: LD_VAR 0 2
46033: ARRAY
46034: NOT
46035: IFFALSE 46039
// break ;
46037: GO 46138
// if not HasTask ( j ) then
46039: LD_VAR 0 3
46043: PPUSH
46044: CALL_OW 314
46048: NOT
46049: IFFALSE 46136
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46051: LD_VAR 0 3
46055: PPUSH
46056: LD_EXP 107
46060: PUSH
46061: LD_VAR 0 2
46065: ARRAY
46066: PUSH
46067: LD_INT 1
46069: ARRAY
46070: PUSH
46071: LD_INT 1
46073: ARRAY
46074: PPUSH
46075: LD_EXP 107
46079: PUSH
46080: LD_VAR 0 2
46084: ARRAY
46085: PUSH
46086: LD_INT 1
46088: ARRAY
46089: PUSH
46090: LD_INT 2
46092: ARRAY
46093: PPUSH
46094: LD_EXP 107
46098: PUSH
46099: LD_VAR 0 2
46103: ARRAY
46104: PUSH
46105: LD_INT 1
46107: ARRAY
46108: PUSH
46109: LD_INT 3
46111: ARRAY
46112: PPUSH
46113: LD_EXP 107
46117: PUSH
46118: LD_VAR 0 2
46122: ARRAY
46123: PUSH
46124: LD_INT 1
46126: ARRAY
46127: PUSH
46128: LD_INT 4
46130: ARRAY
46131: PPUSH
46132: CALL_OW 145
// end ;
46136: GO 45925
46138: POP
46139: POP
// end else
46140: GO 46284
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46142: LD_EXP 102
46146: PUSH
46147: LD_VAR 0 2
46151: ARRAY
46152: PPUSH
46153: LD_EXP 107
46157: PUSH
46158: LD_VAR 0 2
46162: ARRAY
46163: PUSH
46164: LD_INT 1
46166: ARRAY
46167: PUSH
46168: LD_INT 1
46170: ARRAY
46171: PPUSH
46172: LD_EXP 107
46176: PUSH
46177: LD_VAR 0 2
46181: ARRAY
46182: PUSH
46183: LD_INT 1
46185: ARRAY
46186: PUSH
46187: LD_INT 2
46189: ARRAY
46190: PPUSH
46191: LD_EXP 107
46195: PUSH
46196: LD_VAR 0 2
46200: ARRAY
46201: PUSH
46202: LD_INT 1
46204: ARRAY
46205: PUSH
46206: LD_INT 3
46208: ARRAY
46209: PPUSH
46210: LD_EXP 107
46214: PUSH
46215: LD_VAR 0 2
46219: ARRAY
46220: PUSH
46221: LD_INT 1
46223: ARRAY
46224: PUSH
46225: LD_INT 4
46227: ARRAY
46228: PPUSH
46229: CALL 78964 0 5
46233: NOT
46234: IFFALSE 46284
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46236: LD_ADDR_EXP 107
46240: PUSH
46241: LD_EXP 107
46245: PPUSH
46246: LD_VAR 0 2
46250: PPUSH
46251: LD_EXP 107
46255: PUSH
46256: LD_VAR 0 2
46260: ARRAY
46261: PPUSH
46262: LD_INT 1
46264: PPUSH
46265: LD_INT 1
46267: NEG
46268: PPUSH
46269: LD_INT 0
46271: PPUSH
46272: CALL 71631 0 4
46276: PPUSH
46277: CALL_OW 1
46281: ST_TO_ADDR
// continue ;
46282: GO 45160
// end ; end ; end ;
46284: GO 45160
46286: POP
46287: POP
// end ;
46288: LD_VAR 0 1
46292: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46293: LD_INT 0
46295: PPUSH
46296: PPUSH
46297: PPUSH
46298: PPUSH
46299: PPUSH
46300: PPUSH
// if not mc_bases then
46301: LD_EXP 102
46305: NOT
46306: IFFALSE 46310
// exit ;
46308: GO 46737
// for i = 1 to mc_bases do
46310: LD_ADDR_VAR 0 2
46314: PUSH
46315: DOUBLE
46316: LD_INT 1
46318: DEC
46319: ST_TO_ADDR
46320: LD_EXP 102
46324: PUSH
46325: FOR_TO
46326: IFFALSE 46735
// begin tmp := mc_build_upgrade [ i ] ;
46328: LD_ADDR_VAR 0 4
46332: PUSH
46333: LD_EXP 134
46337: PUSH
46338: LD_VAR 0 2
46342: ARRAY
46343: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46344: LD_ADDR_VAR 0 6
46348: PUSH
46349: LD_EXP 135
46353: PUSH
46354: LD_VAR 0 2
46358: ARRAY
46359: PPUSH
46360: LD_INT 2
46362: PUSH
46363: LD_INT 30
46365: PUSH
46366: LD_INT 6
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 30
46375: PUSH
46376: LD_INT 7
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: EMPTY
46384: LIST
46385: LIST
46386: LIST
46387: PPUSH
46388: CALL_OW 72
46392: ST_TO_ADDR
// if not tmp and not lab then
46393: LD_VAR 0 4
46397: NOT
46398: PUSH
46399: LD_VAR 0 6
46403: NOT
46404: AND
46405: IFFALSE 46409
// continue ;
46407: GO 46325
// if tmp then
46409: LD_VAR 0 4
46413: IFFALSE 46533
// for j in tmp do
46415: LD_ADDR_VAR 0 3
46419: PUSH
46420: LD_VAR 0 4
46424: PUSH
46425: FOR_IN
46426: IFFALSE 46531
// begin if UpgradeCost ( j ) then
46428: LD_VAR 0 3
46432: PPUSH
46433: CALL 78624 0 1
46437: IFFALSE 46529
// begin ComUpgrade ( j ) ;
46439: LD_VAR 0 3
46443: PPUSH
46444: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46448: LD_ADDR_EXP 134
46452: PUSH
46453: LD_EXP 134
46457: PPUSH
46458: LD_VAR 0 2
46462: PPUSH
46463: LD_EXP 134
46467: PUSH
46468: LD_VAR 0 2
46472: ARRAY
46473: PUSH
46474: LD_VAR 0 3
46478: DIFF
46479: PPUSH
46480: CALL_OW 1
46484: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46485: LD_ADDR_EXP 109
46489: PUSH
46490: LD_EXP 109
46494: PPUSH
46495: LD_VAR 0 2
46499: PUSH
46500: LD_EXP 109
46504: PUSH
46505: LD_VAR 0 2
46509: ARRAY
46510: PUSH
46511: LD_INT 1
46513: PLUS
46514: PUSH
46515: EMPTY
46516: LIST
46517: LIST
46518: PPUSH
46519: LD_VAR 0 3
46523: PPUSH
46524: CALL 72213 0 3
46528: ST_TO_ADDR
// end ; end ;
46529: GO 46425
46531: POP
46532: POP
// if not lab or not mc_lab_upgrade [ i ] then
46533: LD_VAR 0 6
46537: NOT
46538: PUSH
46539: LD_EXP 136
46543: PUSH
46544: LD_VAR 0 2
46548: ARRAY
46549: NOT
46550: OR
46551: IFFALSE 46555
// continue ;
46553: GO 46325
// for j in lab do
46555: LD_ADDR_VAR 0 3
46559: PUSH
46560: LD_VAR 0 6
46564: PUSH
46565: FOR_IN
46566: IFFALSE 46731
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46568: LD_VAR 0 3
46572: PPUSH
46573: CALL_OW 266
46577: PUSH
46578: LD_INT 6
46580: PUSH
46581: LD_INT 7
46583: PUSH
46584: EMPTY
46585: LIST
46586: LIST
46587: IN
46588: PUSH
46589: LD_VAR 0 3
46593: PPUSH
46594: CALL_OW 461
46598: PUSH
46599: LD_INT 1
46601: NONEQUAL
46602: AND
46603: IFFALSE 46729
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46605: LD_VAR 0 3
46609: PPUSH
46610: LD_EXP 136
46614: PUSH
46615: LD_VAR 0 2
46619: ARRAY
46620: PUSH
46621: LD_INT 1
46623: ARRAY
46624: PPUSH
46625: CALL 78829 0 2
46629: IFFALSE 46729
// begin ComCancel ( j ) ;
46631: LD_VAR 0 3
46635: PPUSH
46636: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46640: LD_VAR 0 3
46644: PPUSH
46645: LD_EXP 136
46649: PUSH
46650: LD_VAR 0 2
46654: ARRAY
46655: PUSH
46656: LD_INT 1
46658: ARRAY
46659: PPUSH
46660: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46664: LD_VAR 0 3
46668: PUSH
46669: LD_EXP 109
46673: PUSH
46674: LD_VAR 0 2
46678: ARRAY
46679: IN
46680: NOT
46681: IFFALSE 46727
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46683: LD_ADDR_EXP 109
46687: PUSH
46688: LD_EXP 109
46692: PPUSH
46693: LD_VAR 0 2
46697: PUSH
46698: LD_EXP 109
46702: PUSH
46703: LD_VAR 0 2
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: PLUS
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PPUSH
46717: LD_VAR 0 3
46721: PPUSH
46722: CALL 72213 0 3
46726: ST_TO_ADDR
// break ;
46727: GO 46731
// end ; end ; end ;
46729: GO 46565
46731: POP
46732: POP
// end ;
46733: GO 46325
46735: POP
46736: POP
// end ;
46737: LD_VAR 0 1
46741: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46742: LD_INT 0
46744: PPUSH
46745: PPUSH
46746: PPUSH
46747: PPUSH
46748: PPUSH
46749: PPUSH
46750: PPUSH
46751: PPUSH
46752: PPUSH
// if not mc_bases then
46753: LD_EXP 102
46757: NOT
46758: IFFALSE 46762
// exit ;
46760: GO 47167
// for i = 1 to mc_bases do
46762: LD_ADDR_VAR 0 2
46766: PUSH
46767: DOUBLE
46768: LD_INT 1
46770: DEC
46771: ST_TO_ADDR
46772: LD_EXP 102
46776: PUSH
46777: FOR_TO
46778: IFFALSE 47165
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46780: LD_EXP 110
46784: PUSH
46785: LD_VAR 0 2
46789: ARRAY
46790: NOT
46791: PUSH
46792: LD_EXP 102
46796: PUSH
46797: LD_VAR 0 2
46801: ARRAY
46802: PPUSH
46803: LD_INT 30
46805: PUSH
46806: LD_INT 3
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PPUSH
46813: CALL_OW 72
46817: NOT
46818: OR
46819: IFFALSE 46823
// continue ;
46821: GO 46777
// busy := false ;
46823: LD_ADDR_VAR 0 8
46827: PUSH
46828: LD_INT 0
46830: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46831: LD_ADDR_VAR 0 4
46835: PUSH
46836: LD_EXP 102
46840: PUSH
46841: LD_VAR 0 2
46845: ARRAY
46846: PPUSH
46847: LD_INT 30
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PPUSH
46857: CALL_OW 72
46861: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46862: LD_ADDR_VAR 0 6
46866: PUSH
46867: LD_EXP 110
46871: PUSH
46872: LD_VAR 0 2
46876: ARRAY
46877: PPUSH
46878: LD_INT 2
46880: PUSH
46881: LD_INT 30
46883: PUSH
46884: LD_INT 32
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 30
46893: PUSH
46894: LD_INT 33
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: LIST
46905: PPUSH
46906: CALL_OW 72
46910: ST_TO_ADDR
// if not t then
46911: LD_VAR 0 6
46915: NOT
46916: IFFALSE 46920
// continue ;
46918: GO 46777
// for j in tmp do
46920: LD_ADDR_VAR 0 3
46924: PUSH
46925: LD_VAR 0 4
46929: PUSH
46930: FOR_IN
46931: IFFALSE 46961
// if not BuildingStatus ( j ) = bs_idle then
46933: LD_VAR 0 3
46937: PPUSH
46938: CALL_OW 461
46942: PUSH
46943: LD_INT 2
46945: EQUAL
46946: NOT
46947: IFFALSE 46959
// begin busy := true ;
46949: LD_ADDR_VAR 0 8
46953: PUSH
46954: LD_INT 1
46956: ST_TO_ADDR
// break ;
46957: GO 46961
// end ;
46959: GO 46930
46961: POP
46962: POP
// if busy then
46963: LD_VAR 0 8
46967: IFFALSE 46971
// continue ;
46969: GO 46777
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46971: LD_ADDR_VAR 0 7
46975: PUSH
46976: LD_VAR 0 6
46980: PPUSH
46981: LD_INT 35
46983: PUSH
46984: LD_INT 0
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: PPUSH
46991: CALL_OW 72
46995: ST_TO_ADDR
// if tw then
46996: LD_VAR 0 7
47000: IFFALSE 47077
// begin tw := tw [ 1 ] ;
47002: LD_ADDR_VAR 0 7
47006: PUSH
47007: LD_VAR 0 7
47011: PUSH
47012: LD_INT 1
47014: ARRAY
47015: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47016: LD_ADDR_VAR 0 9
47020: PUSH
47021: LD_VAR 0 7
47025: PPUSH
47026: LD_EXP 127
47030: PUSH
47031: LD_VAR 0 2
47035: ARRAY
47036: PPUSH
47037: CALL 77183 0 2
47041: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47042: LD_EXP 141
47046: PUSH
47047: LD_VAR 0 2
47051: ARRAY
47052: IFFALSE 47075
// if not weapon in mc_allowed_tower_weapons [ i ] then
47054: LD_VAR 0 9
47058: PUSH
47059: LD_EXP 141
47063: PUSH
47064: LD_VAR 0 2
47068: ARRAY
47069: IN
47070: NOT
47071: IFFALSE 47075
// continue ;
47073: GO 46777
// end else
47075: GO 47140
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47077: LD_ADDR_VAR 0 5
47081: PUSH
47082: LD_EXP 110
47086: PUSH
47087: LD_VAR 0 2
47091: ARRAY
47092: PPUSH
47093: LD_VAR 0 4
47097: PPUSH
47098: CALL 107394 0 2
47102: ST_TO_ADDR
// if not tmp2 then
47103: LD_VAR 0 5
47107: NOT
47108: IFFALSE 47112
// continue ;
47110: GO 46777
// tw := tmp2 [ 1 ] ;
47112: LD_ADDR_VAR 0 7
47116: PUSH
47117: LD_VAR 0 5
47121: PUSH
47122: LD_INT 1
47124: ARRAY
47125: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47126: LD_ADDR_VAR 0 9
47130: PUSH
47131: LD_VAR 0 5
47135: PUSH
47136: LD_INT 2
47138: ARRAY
47139: ST_TO_ADDR
// end ; if not weapon then
47140: LD_VAR 0 9
47144: NOT
47145: IFFALSE 47149
// continue ;
47147: GO 46777
// ComPlaceWeapon ( tw , weapon ) ;
47149: LD_VAR 0 7
47153: PPUSH
47154: LD_VAR 0 9
47158: PPUSH
47159: CALL_OW 148
// end ;
47163: GO 46777
47165: POP
47166: POP
// end ;
47167: LD_VAR 0 1
47171: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47172: LD_INT 0
47174: PPUSH
47175: PPUSH
47176: PPUSH
47177: PPUSH
47178: PPUSH
47179: PPUSH
// if not mc_bases then
47180: LD_EXP 102
47184: NOT
47185: IFFALSE 47189
// exit ;
47187: GO 47965
// for i = 1 to mc_bases do
47189: LD_ADDR_VAR 0 2
47193: PUSH
47194: DOUBLE
47195: LD_INT 1
47197: DEC
47198: ST_TO_ADDR
47199: LD_EXP 102
47203: PUSH
47204: FOR_TO
47205: IFFALSE 47963
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47207: LD_EXP 115
47211: PUSH
47212: LD_VAR 0 2
47216: ARRAY
47217: NOT
47218: PUSH
47219: LD_EXP 115
47223: PUSH
47224: LD_VAR 0 2
47228: ARRAY
47229: PUSH
47230: LD_EXP 116
47234: PUSH
47235: LD_VAR 0 2
47239: ARRAY
47240: EQUAL
47241: OR
47242: PUSH
47243: LD_EXP 125
47247: PUSH
47248: LD_VAR 0 2
47252: ARRAY
47253: OR
47254: IFFALSE 47258
// continue ;
47256: GO 47204
// if mc_miners [ i ] then
47258: LD_EXP 116
47262: PUSH
47263: LD_VAR 0 2
47267: ARRAY
47268: IFFALSE 47650
// begin for j = mc_miners [ i ] downto 1 do
47270: LD_ADDR_VAR 0 3
47274: PUSH
47275: DOUBLE
47276: LD_EXP 116
47280: PUSH
47281: LD_VAR 0 2
47285: ARRAY
47286: INC
47287: ST_TO_ADDR
47288: LD_INT 1
47290: PUSH
47291: FOR_DOWNTO
47292: IFFALSE 47648
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47294: LD_EXP 116
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: PUSH
47305: LD_VAR 0 3
47309: ARRAY
47310: PPUSH
47311: CALL_OW 301
47315: PUSH
47316: LD_EXP 116
47320: PUSH
47321: LD_VAR 0 2
47325: ARRAY
47326: PUSH
47327: LD_VAR 0 3
47331: ARRAY
47332: PPUSH
47333: CALL_OW 257
47337: PUSH
47338: LD_INT 1
47340: NONEQUAL
47341: OR
47342: IFFALSE 47405
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47344: LD_ADDR_VAR 0 5
47348: PUSH
47349: LD_EXP 116
47353: PUSH
47354: LD_VAR 0 2
47358: ARRAY
47359: PUSH
47360: LD_EXP 116
47364: PUSH
47365: LD_VAR 0 2
47369: ARRAY
47370: PUSH
47371: LD_VAR 0 3
47375: ARRAY
47376: DIFF
47377: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47378: LD_ADDR_EXP 116
47382: PUSH
47383: LD_EXP 116
47387: PPUSH
47388: LD_VAR 0 2
47392: PPUSH
47393: LD_VAR 0 5
47397: PPUSH
47398: CALL_OW 1
47402: ST_TO_ADDR
// continue ;
47403: GO 47291
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47405: LD_EXP 116
47409: PUSH
47410: LD_VAR 0 2
47414: ARRAY
47415: PUSH
47416: LD_VAR 0 3
47420: ARRAY
47421: PPUSH
47422: CALL_OW 257
47426: PUSH
47427: LD_INT 1
47429: EQUAL
47430: PUSH
47431: LD_EXP 116
47435: PUSH
47436: LD_VAR 0 2
47440: ARRAY
47441: PUSH
47442: LD_VAR 0 3
47446: ARRAY
47447: PPUSH
47448: CALL_OW 459
47452: NOT
47453: AND
47454: PUSH
47455: LD_EXP 116
47459: PUSH
47460: LD_VAR 0 2
47464: ARRAY
47465: PUSH
47466: LD_VAR 0 3
47470: ARRAY
47471: PPUSH
47472: CALL_OW 314
47476: NOT
47477: AND
47478: IFFALSE 47646
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47480: LD_EXP 116
47484: PUSH
47485: LD_VAR 0 2
47489: ARRAY
47490: PUSH
47491: LD_VAR 0 3
47495: ARRAY
47496: PPUSH
47497: CALL_OW 310
47501: IFFALSE 47524
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47503: LD_EXP 116
47507: PUSH
47508: LD_VAR 0 2
47512: ARRAY
47513: PUSH
47514: LD_VAR 0 3
47518: ARRAY
47519: PPUSH
47520: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47524: LD_EXP 116
47528: PUSH
47529: LD_VAR 0 2
47533: ARRAY
47534: PUSH
47535: LD_VAR 0 3
47539: ARRAY
47540: PPUSH
47541: CALL_OW 314
47545: NOT
47546: IFFALSE 47646
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47548: LD_EXP 116
47552: PUSH
47553: LD_VAR 0 2
47557: ARRAY
47558: PUSH
47559: LD_VAR 0 3
47563: ARRAY
47564: PPUSH
47565: LD_EXP 115
47569: PUSH
47570: LD_VAR 0 2
47574: ARRAY
47575: PUSH
47576: LD_VAR 0 3
47580: PUSH
47581: LD_EXP 115
47585: PUSH
47586: LD_VAR 0 2
47590: ARRAY
47591: MOD
47592: PUSH
47593: LD_INT 1
47595: PLUS
47596: ARRAY
47597: PUSH
47598: LD_INT 1
47600: ARRAY
47601: PPUSH
47602: LD_EXP 115
47606: PUSH
47607: LD_VAR 0 2
47611: ARRAY
47612: PUSH
47613: LD_VAR 0 3
47617: PUSH
47618: LD_EXP 115
47622: PUSH
47623: LD_VAR 0 2
47627: ARRAY
47628: MOD
47629: PUSH
47630: LD_INT 1
47632: PLUS
47633: ARRAY
47634: PUSH
47635: LD_INT 2
47637: ARRAY
47638: PPUSH
47639: LD_INT 0
47641: PPUSH
47642: CALL_OW 193
// end ; end ;
47646: GO 47291
47648: POP
47649: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47650: LD_ADDR_VAR 0 5
47654: PUSH
47655: LD_EXP 102
47659: PUSH
47660: LD_VAR 0 2
47664: ARRAY
47665: PPUSH
47666: LD_INT 2
47668: PUSH
47669: LD_INT 30
47671: PUSH
47672: LD_INT 4
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: PUSH
47679: LD_INT 30
47681: PUSH
47682: LD_INT 5
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: PUSH
47689: LD_INT 30
47691: PUSH
47692: LD_INT 32
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: PUSH
47699: EMPTY
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: PPUSH
47705: CALL_OW 72
47709: ST_TO_ADDR
// if not tmp then
47710: LD_VAR 0 5
47714: NOT
47715: IFFALSE 47719
// continue ;
47717: GO 47204
// list := [ ] ;
47719: LD_ADDR_VAR 0 6
47723: PUSH
47724: EMPTY
47725: ST_TO_ADDR
// for j in tmp do
47726: LD_ADDR_VAR 0 3
47730: PUSH
47731: LD_VAR 0 5
47735: PUSH
47736: FOR_IN
47737: IFFALSE 47806
// begin for k in UnitsInside ( j ) do
47739: LD_ADDR_VAR 0 4
47743: PUSH
47744: LD_VAR 0 3
47748: PPUSH
47749: CALL_OW 313
47753: PUSH
47754: FOR_IN
47755: IFFALSE 47802
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47757: LD_VAR 0 4
47761: PPUSH
47762: CALL_OW 257
47766: PUSH
47767: LD_INT 1
47769: EQUAL
47770: PUSH
47771: LD_VAR 0 4
47775: PPUSH
47776: CALL_OW 459
47780: NOT
47781: AND
47782: IFFALSE 47800
// list := list ^ k ;
47784: LD_ADDR_VAR 0 6
47788: PUSH
47789: LD_VAR 0 6
47793: PUSH
47794: LD_VAR 0 4
47798: ADD
47799: ST_TO_ADDR
47800: GO 47754
47802: POP
47803: POP
// end ;
47804: GO 47736
47806: POP
47807: POP
// list := list diff mc_miners [ i ] ;
47808: LD_ADDR_VAR 0 6
47812: PUSH
47813: LD_VAR 0 6
47817: PUSH
47818: LD_EXP 116
47822: PUSH
47823: LD_VAR 0 2
47827: ARRAY
47828: DIFF
47829: ST_TO_ADDR
// if not list then
47830: LD_VAR 0 6
47834: NOT
47835: IFFALSE 47839
// continue ;
47837: GO 47204
// k := mc_mines [ i ] - mc_miners [ i ] ;
47839: LD_ADDR_VAR 0 4
47843: PUSH
47844: LD_EXP 115
47848: PUSH
47849: LD_VAR 0 2
47853: ARRAY
47854: PUSH
47855: LD_EXP 116
47859: PUSH
47860: LD_VAR 0 2
47864: ARRAY
47865: MINUS
47866: ST_TO_ADDR
// if k > list then
47867: LD_VAR 0 4
47871: PUSH
47872: LD_VAR 0 6
47876: GREATER
47877: IFFALSE 47889
// k := list ;
47879: LD_ADDR_VAR 0 4
47883: PUSH
47884: LD_VAR 0 6
47888: ST_TO_ADDR
// for j = 1 to k do
47889: LD_ADDR_VAR 0 3
47893: PUSH
47894: DOUBLE
47895: LD_INT 1
47897: DEC
47898: ST_TO_ADDR
47899: LD_VAR 0 4
47903: PUSH
47904: FOR_TO
47905: IFFALSE 47959
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47907: LD_ADDR_EXP 116
47911: PUSH
47912: LD_EXP 116
47916: PPUSH
47917: LD_VAR 0 2
47921: PUSH
47922: LD_EXP 116
47926: PUSH
47927: LD_VAR 0 2
47931: ARRAY
47932: PUSH
47933: LD_INT 1
47935: PLUS
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PPUSH
47941: LD_VAR 0 6
47945: PUSH
47946: LD_VAR 0 3
47950: ARRAY
47951: PPUSH
47952: CALL 72213 0 3
47956: ST_TO_ADDR
47957: GO 47904
47959: POP
47960: POP
// end ;
47961: GO 47204
47963: POP
47964: POP
// end ;
47965: LD_VAR 0 1
47969: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47970: LD_INT 0
47972: PPUSH
47973: PPUSH
47974: PPUSH
47975: PPUSH
47976: PPUSH
47977: PPUSH
47978: PPUSH
47979: PPUSH
47980: PPUSH
47981: PPUSH
// if not mc_bases then
47982: LD_EXP 102
47986: NOT
47987: IFFALSE 47991
// exit ;
47989: GO 49741
// for i = 1 to mc_bases do
47991: LD_ADDR_VAR 0 2
47995: PUSH
47996: DOUBLE
47997: LD_INT 1
47999: DEC
48000: ST_TO_ADDR
48001: LD_EXP 102
48005: PUSH
48006: FOR_TO
48007: IFFALSE 49739
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48009: LD_EXP 102
48013: PUSH
48014: LD_VAR 0 2
48018: ARRAY
48019: NOT
48020: PUSH
48021: LD_EXP 109
48025: PUSH
48026: LD_VAR 0 2
48030: ARRAY
48031: OR
48032: IFFALSE 48036
// continue ;
48034: GO 48006
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48036: LD_EXP 118
48040: PUSH
48041: LD_VAR 0 2
48045: ARRAY
48046: NOT
48047: PUSH
48048: LD_EXP 119
48052: PUSH
48053: LD_VAR 0 2
48057: ARRAY
48058: AND
48059: IFFALSE 48097
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48061: LD_ADDR_EXP 119
48065: PUSH
48066: LD_EXP 119
48070: PPUSH
48071: LD_VAR 0 2
48075: PPUSH
48076: EMPTY
48077: PPUSH
48078: CALL_OW 1
48082: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48083: LD_VAR 0 2
48087: PPUSH
48088: LD_INT 107
48090: PPUSH
48091: CALL 38955 0 2
// continue ;
48095: GO 48006
// end ; target := [ ] ;
48097: LD_ADDR_VAR 0 6
48101: PUSH
48102: EMPTY
48103: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48104: LD_ADDR_VAR 0 3
48108: PUSH
48109: DOUBLE
48110: LD_EXP 118
48114: PUSH
48115: LD_VAR 0 2
48119: ARRAY
48120: INC
48121: ST_TO_ADDR
48122: LD_INT 1
48124: PUSH
48125: FOR_DOWNTO
48126: IFFALSE 48386
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48128: LD_EXP 118
48132: PUSH
48133: LD_VAR 0 2
48137: ARRAY
48138: PUSH
48139: LD_VAR 0 3
48143: ARRAY
48144: PUSH
48145: LD_INT 2
48147: ARRAY
48148: PPUSH
48149: LD_EXP 118
48153: PUSH
48154: LD_VAR 0 2
48158: ARRAY
48159: PUSH
48160: LD_VAR 0 3
48164: ARRAY
48165: PUSH
48166: LD_INT 3
48168: ARRAY
48169: PPUSH
48170: CALL_OW 488
48174: PUSH
48175: LD_EXP 118
48179: PUSH
48180: LD_VAR 0 2
48184: ARRAY
48185: PUSH
48186: LD_VAR 0 3
48190: ARRAY
48191: PUSH
48192: LD_INT 2
48194: ARRAY
48195: PPUSH
48196: LD_EXP 118
48200: PUSH
48201: LD_VAR 0 2
48205: ARRAY
48206: PUSH
48207: LD_VAR 0 3
48211: ARRAY
48212: PUSH
48213: LD_INT 3
48215: ARRAY
48216: PPUSH
48217: CALL_OW 284
48221: PUSH
48222: LD_INT 0
48224: EQUAL
48225: AND
48226: IFFALSE 48281
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48228: LD_ADDR_VAR 0 5
48232: PUSH
48233: LD_EXP 118
48237: PUSH
48238: LD_VAR 0 2
48242: ARRAY
48243: PPUSH
48244: LD_VAR 0 3
48248: PPUSH
48249: CALL_OW 3
48253: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48254: LD_ADDR_EXP 118
48258: PUSH
48259: LD_EXP 118
48263: PPUSH
48264: LD_VAR 0 2
48268: PPUSH
48269: LD_VAR 0 5
48273: PPUSH
48274: CALL_OW 1
48278: ST_TO_ADDR
// continue ;
48279: GO 48125
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48281: LD_EXP 102
48285: PUSH
48286: LD_VAR 0 2
48290: ARRAY
48291: PUSH
48292: LD_INT 1
48294: ARRAY
48295: PPUSH
48296: CALL_OW 255
48300: PPUSH
48301: LD_EXP 118
48305: PUSH
48306: LD_VAR 0 2
48310: ARRAY
48311: PUSH
48312: LD_VAR 0 3
48316: ARRAY
48317: PUSH
48318: LD_INT 2
48320: ARRAY
48321: PPUSH
48322: LD_EXP 118
48326: PUSH
48327: LD_VAR 0 2
48331: ARRAY
48332: PUSH
48333: LD_VAR 0 3
48337: ARRAY
48338: PUSH
48339: LD_INT 3
48341: ARRAY
48342: PPUSH
48343: LD_INT 30
48345: PPUSH
48346: CALL 73109 0 4
48350: PUSH
48351: LD_INT 4
48353: ARRAY
48354: PUSH
48355: LD_INT 0
48357: EQUAL
48358: IFFALSE 48384
// begin target := mc_crates [ i ] [ j ] ;
48360: LD_ADDR_VAR 0 6
48364: PUSH
48365: LD_EXP 118
48369: PUSH
48370: LD_VAR 0 2
48374: ARRAY
48375: PUSH
48376: LD_VAR 0 3
48380: ARRAY
48381: ST_TO_ADDR
// break ;
48382: GO 48386
// end ; end ;
48384: GO 48125
48386: POP
48387: POP
// if not target then
48388: LD_VAR 0 6
48392: NOT
48393: IFFALSE 48397
// continue ;
48395: GO 48006
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48397: LD_ADDR_VAR 0 7
48401: PUSH
48402: LD_EXP 121
48406: PUSH
48407: LD_VAR 0 2
48411: ARRAY
48412: PPUSH
48413: LD_INT 2
48415: PUSH
48416: LD_INT 3
48418: PUSH
48419: LD_INT 58
48421: PUSH
48422: EMPTY
48423: LIST
48424: PUSH
48425: EMPTY
48426: LIST
48427: LIST
48428: PUSH
48429: LD_INT 61
48431: PUSH
48432: EMPTY
48433: LIST
48434: PUSH
48435: LD_INT 33
48437: PUSH
48438: LD_INT 5
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: PUSH
48445: LD_INT 33
48447: PUSH
48448: LD_INT 3
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: PUSH
48462: LD_INT 2
48464: PUSH
48465: LD_INT 34
48467: PUSH
48468: LD_INT 32
48470: PUSH
48471: EMPTY
48472: LIST
48473: LIST
48474: PUSH
48475: LD_INT 34
48477: PUSH
48478: LD_INT 51
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: PUSH
48485: LD_INT 34
48487: PUSH
48488: LD_INT 12
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: LIST
48499: LIST
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PPUSH
48505: CALL_OW 72
48509: ST_TO_ADDR
// if not cargo then
48510: LD_VAR 0 7
48514: NOT
48515: IFFALSE 49158
// begin if mc_crates_collector [ i ] < 5 then
48517: LD_EXP 119
48521: PUSH
48522: LD_VAR 0 2
48526: ARRAY
48527: PUSH
48528: LD_INT 5
48530: LESS
48531: IFFALSE 48897
// begin if mc_ape [ i ] then
48533: LD_EXP 131
48537: PUSH
48538: LD_VAR 0 2
48542: ARRAY
48543: IFFALSE 48590
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48545: LD_ADDR_VAR 0 5
48549: PUSH
48550: LD_EXP 131
48554: PUSH
48555: LD_VAR 0 2
48559: ARRAY
48560: PPUSH
48561: LD_INT 25
48563: PUSH
48564: LD_INT 16
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: PUSH
48571: LD_INT 24
48573: PUSH
48574: LD_INT 750
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: PUSH
48581: EMPTY
48582: LIST
48583: LIST
48584: PPUSH
48585: CALL_OW 72
48589: ST_TO_ADDR
// if not tmp then
48590: LD_VAR 0 5
48594: NOT
48595: IFFALSE 48642
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48597: LD_ADDR_VAR 0 5
48601: PUSH
48602: LD_EXP 102
48606: PUSH
48607: LD_VAR 0 2
48611: ARRAY
48612: PPUSH
48613: LD_INT 25
48615: PUSH
48616: LD_INT 2
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: LD_INT 24
48625: PUSH
48626: LD_INT 750
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: EMPTY
48634: LIST
48635: LIST
48636: PPUSH
48637: CALL_OW 72
48641: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48642: LD_EXP 131
48646: PUSH
48647: LD_VAR 0 2
48651: ARRAY
48652: PUSH
48653: LD_EXP 102
48657: PUSH
48658: LD_VAR 0 2
48662: ARRAY
48663: PPUSH
48664: LD_INT 25
48666: PUSH
48667: LD_INT 2
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: PUSH
48674: LD_INT 24
48676: PUSH
48677: LD_INT 750
48679: PUSH
48680: EMPTY
48681: LIST
48682: LIST
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PPUSH
48688: CALL_OW 72
48692: AND
48693: PUSH
48694: LD_VAR 0 5
48698: PUSH
48699: LD_INT 5
48701: LESS
48702: AND
48703: IFFALSE 48785
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48705: LD_ADDR_VAR 0 3
48709: PUSH
48710: LD_EXP 102
48714: PUSH
48715: LD_VAR 0 2
48719: ARRAY
48720: PPUSH
48721: LD_INT 25
48723: PUSH
48724: LD_INT 2
48726: PUSH
48727: EMPTY
48728: LIST
48729: LIST
48730: PUSH
48731: LD_INT 24
48733: PUSH
48734: LD_INT 750
48736: PUSH
48737: EMPTY
48738: LIST
48739: LIST
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: PPUSH
48745: CALL_OW 72
48749: PUSH
48750: FOR_IN
48751: IFFALSE 48783
// begin tmp := tmp union j ;
48753: LD_ADDR_VAR 0 5
48757: PUSH
48758: LD_VAR 0 5
48762: PUSH
48763: LD_VAR 0 3
48767: UNION
48768: ST_TO_ADDR
// if tmp >= 5 then
48769: LD_VAR 0 5
48773: PUSH
48774: LD_INT 5
48776: GREATEREQUAL
48777: IFFALSE 48781
// break ;
48779: GO 48783
// end ;
48781: GO 48750
48783: POP
48784: POP
// end ; if not tmp then
48785: LD_VAR 0 5
48789: NOT
48790: IFFALSE 48794
// continue ;
48792: GO 48006
// for j in tmp do
48794: LD_ADDR_VAR 0 3
48798: PUSH
48799: LD_VAR 0 5
48803: PUSH
48804: FOR_IN
48805: IFFALSE 48895
// if not GetTag ( j ) then
48807: LD_VAR 0 3
48811: PPUSH
48812: CALL_OW 110
48816: NOT
48817: IFFALSE 48893
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48819: LD_ADDR_EXP 119
48823: PUSH
48824: LD_EXP 119
48828: PPUSH
48829: LD_VAR 0 2
48833: PUSH
48834: LD_EXP 119
48838: PUSH
48839: LD_VAR 0 2
48843: ARRAY
48844: PUSH
48845: LD_INT 1
48847: PLUS
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: PPUSH
48853: LD_VAR 0 3
48857: PPUSH
48858: CALL 72213 0 3
48862: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48863: LD_VAR 0 3
48867: PPUSH
48868: LD_INT 107
48870: PPUSH
48871: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48875: LD_EXP 119
48879: PUSH
48880: LD_VAR 0 2
48884: ARRAY
48885: PUSH
48886: LD_INT 5
48888: GREATEREQUAL
48889: IFFALSE 48893
// break ;
48891: GO 48895
// end ;
48893: GO 48804
48895: POP
48896: POP
// end ; if mc_crates_collector [ i ] and target then
48897: LD_EXP 119
48901: PUSH
48902: LD_VAR 0 2
48906: ARRAY
48907: PUSH
48908: LD_VAR 0 6
48912: AND
48913: IFFALSE 49156
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48915: LD_EXP 119
48919: PUSH
48920: LD_VAR 0 2
48924: ARRAY
48925: PUSH
48926: LD_VAR 0 6
48930: PUSH
48931: LD_INT 1
48933: ARRAY
48934: LESS
48935: IFFALSE 48955
// tmp := mc_crates_collector [ i ] else
48937: LD_ADDR_VAR 0 5
48941: PUSH
48942: LD_EXP 119
48946: PUSH
48947: LD_VAR 0 2
48951: ARRAY
48952: ST_TO_ADDR
48953: GO 48969
// tmp := target [ 1 ] ;
48955: LD_ADDR_VAR 0 5
48959: PUSH
48960: LD_VAR 0 6
48964: PUSH
48965: LD_INT 1
48967: ARRAY
48968: ST_TO_ADDR
// k := 0 ;
48969: LD_ADDR_VAR 0 4
48973: PUSH
48974: LD_INT 0
48976: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: LD_EXP 119
48986: PUSH
48987: LD_VAR 0 2
48991: ARRAY
48992: PUSH
48993: FOR_IN
48994: IFFALSE 49154
// begin k := k + 1 ;
48996: LD_ADDR_VAR 0 4
49000: PUSH
49001: LD_VAR 0 4
49005: PUSH
49006: LD_INT 1
49008: PLUS
49009: ST_TO_ADDR
// if k > tmp then
49010: LD_VAR 0 4
49014: PUSH
49015: LD_VAR 0 5
49019: GREATER
49020: IFFALSE 49024
// break ;
49022: GO 49154
// if not GetClass ( j ) in [ 2 , 16 ] then
49024: LD_VAR 0 3
49028: PPUSH
49029: CALL_OW 257
49033: PUSH
49034: LD_INT 2
49036: PUSH
49037: LD_INT 16
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: IN
49044: NOT
49045: IFFALSE 49098
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49047: LD_ADDR_EXP 119
49051: PUSH
49052: LD_EXP 119
49056: PPUSH
49057: LD_VAR 0 2
49061: PPUSH
49062: LD_EXP 119
49066: PUSH
49067: LD_VAR 0 2
49071: ARRAY
49072: PUSH
49073: LD_VAR 0 3
49077: DIFF
49078: PPUSH
49079: CALL_OW 1
49083: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49084: LD_VAR 0 3
49088: PPUSH
49089: LD_INT 0
49091: PPUSH
49092: CALL_OW 109
// continue ;
49096: GO 48993
// end ; if IsInUnit ( j ) then
49098: LD_VAR 0 3
49102: PPUSH
49103: CALL_OW 310
49107: IFFALSE 49118
// ComExitBuilding ( j ) ;
49109: LD_VAR 0 3
49113: PPUSH
49114: CALL_OW 122
// wait ( 3 ) ;
49118: LD_INT 3
49120: PPUSH
49121: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49125: LD_VAR 0 3
49129: PPUSH
49130: LD_VAR 0 6
49134: PUSH
49135: LD_INT 2
49137: ARRAY
49138: PPUSH
49139: LD_VAR 0 6
49143: PUSH
49144: LD_INT 3
49146: ARRAY
49147: PPUSH
49148: CALL_OW 117
// end ;
49152: GO 48993
49154: POP
49155: POP
// end ; end else
49156: GO 49737
// begin for j in cargo do
49158: LD_ADDR_VAR 0 3
49162: PUSH
49163: LD_VAR 0 7
49167: PUSH
49168: FOR_IN
49169: IFFALSE 49735
// begin if GetTag ( j ) <> 0 then
49171: LD_VAR 0 3
49175: PPUSH
49176: CALL_OW 110
49180: PUSH
49181: LD_INT 0
49183: NONEQUAL
49184: IFFALSE 49188
// continue ;
49186: GO 49168
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49188: LD_VAR 0 3
49192: PPUSH
49193: CALL_OW 256
49197: PUSH
49198: LD_INT 1000
49200: LESS
49201: PUSH
49202: LD_VAR 0 3
49206: PPUSH
49207: LD_EXP 126
49211: PUSH
49212: LD_VAR 0 2
49216: ARRAY
49217: PPUSH
49218: CALL_OW 308
49222: NOT
49223: AND
49224: IFFALSE 49246
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49226: LD_VAR 0 3
49230: PPUSH
49231: LD_EXP 126
49235: PUSH
49236: LD_VAR 0 2
49240: ARRAY
49241: PPUSH
49242: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49246: LD_VAR 0 3
49250: PPUSH
49251: CALL_OW 256
49255: PUSH
49256: LD_INT 1000
49258: LESS
49259: PUSH
49260: LD_VAR 0 3
49264: PPUSH
49265: LD_EXP 126
49269: PUSH
49270: LD_VAR 0 2
49274: ARRAY
49275: PPUSH
49276: CALL_OW 308
49280: AND
49281: IFFALSE 49285
// continue ;
49283: GO 49168
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49285: LD_VAR 0 3
49289: PPUSH
49290: CALL_OW 262
49294: PUSH
49295: LD_INT 2
49297: EQUAL
49298: PUSH
49299: LD_VAR 0 3
49303: PPUSH
49304: CALL_OW 261
49308: PUSH
49309: LD_INT 15
49311: LESS
49312: AND
49313: IFFALSE 49317
// continue ;
49315: GO 49168
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49317: LD_VAR 0 3
49321: PPUSH
49322: CALL_OW 262
49326: PUSH
49327: LD_INT 1
49329: EQUAL
49330: PUSH
49331: LD_VAR 0 3
49335: PPUSH
49336: CALL_OW 261
49340: PUSH
49341: LD_INT 10
49343: LESS
49344: AND
49345: IFFALSE 49674
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49347: LD_ADDR_VAR 0 8
49351: PUSH
49352: LD_EXP 102
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: PPUSH
49363: LD_INT 2
49365: PUSH
49366: LD_INT 30
49368: PUSH
49369: LD_INT 0
49371: PUSH
49372: EMPTY
49373: LIST
49374: LIST
49375: PUSH
49376: LD_INT 30
49378: PUSH
49379: LD_INT 1
49381: PUSH
49382: EMPTY
49383: LIST
49384: LIST
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: LIST
49390: PPUSH
49391: CALL_OW 72
49395: ST_TO_ADDR
// if not depot then
49396: LD_VAR 0 8
49400: NOT
49401: IFFALSE 49405
// continue ;
49403: GO 49168
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49405: LD_VAR 0 3
49409: PPUSH
49410: LD_VAR 0 8
49414: PPUSH
49415: LD_VAR 0 3
49419: PPUSH
49420: CALL_OW 74
49424: PPUSH
49425: CALL_OW 296
49429: PUSH
49430: LD_INT 6
49432: LESS
49433: IFFALSE 49449
// SetFuel ( j , 100 ) else
49435: LD_VAR 0 3
49439: PPUSH
49440: LD_INT 100
49442: PPUSH
49443: CALL_OW 240
49447: GO 49674
// if GetFuel ( j ) = 0 then
49449: LD_VAR 0 3
49453: PPUSH
49454: CALL_OW 261
49458: PUSH
49459: LD_INT 0
49461: EQUAL
49462: IFFALSE 49674
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49464: LD_ADDR_EXP 121
49468: PUSH
49469: LD_EXP 121
49473: PPUSH
49474: LD_VAR 0 2
49478: PPUSH
49479: LD_EXP 121
49483: PUSH
49484: LD_VAR 0 2
49488: ARRAY
49489: PUSH
49490: LD_VAR 0 3
49494: DIFF
49495: PPUSH
49496: CALL_OW 1
49500: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49501: LD_VAR 0 3
49505: PPUSH
49506: CALL_OW 263
49510: PUSH
49511: LD_INT 1
49513: EQUAL
49514: IFFALSE 49530
// ComExitVehicle ( IsInUnit ( j ) ) ;
49516: LD_VAR 0 3
49520: PPUSH
49521: CALL_OW 310
49525: PPUSH
49526: CALL_OW 121
// if GetControl ( j ) = control_remote then
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 263
49539: PUSH
49540: LD_INT 2
49542: EQUAL
49543: IFFALSE 49554
// ComUnlink ( j ) ;
49545: LD_VAR 0 3
49549: PPUSH
49550: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49554: LD_ADDR_VAR 0 9
49558: PUSH
49559: LD_VAR 0 2
49563: PPUSH
49564: LD_INT 3
49566: PPUSH
49567: CALL 59027 0 2
49571: ST_TO_ADDR
// if fac then
49572: LD_VAR 0 9
49576: IFFALSE 49672
// begin for k in fac do
49578: LD_ADDR_VAR 0 4
49582: PUSH
49583: LD_VAR 0 9
49587: PUSH
49588: FOR_IN
49589: IFFALSE 49670
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49591: LD_ADDR_VAR 0 10
49595: PUSH
49596: LD_VAR 0 9
49600: PPUSH
49601: LD_VAR 0 3
49605: PPUSH
49606: CALL_OW 265
49610: PPUSH
49611: LD_VAR 0 3
49615: PPUSH
49616: CALL_OW 262
49620: PPUSH
49621: LD_VAR 0 3
49625: PPUSH
49626: CALL_OW 263
49630: PPUSH
49631: LD_VAR 0 3
49635: PPUSH
49636: CALL_OW 264
49640: PPUSH
49641: CALL 69745 0 5
49645: ST_TO_ADDR
// if components then
49646: LD_VAR 0 10
49650: IFFALSE 49668
// begin MC_InsertProduceList ( i , components ) ;
49652: LD_VAR 0 2
49656: PPUSH
49657: LD_VAR 0 10
49661: PPUSH
49662: CALL 58572 0 2
// break ;
49666: GO 49670
// end ; end ;
49668: GO 49588
49670: POP
49671: POP
// end ; continue ;
49672: GO 49168
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49674: LD_VAR 0 3
49678: PPUSH
49679: LD_INT 1
49681: PPUSH
49682: CALL_OW 289
49686: PUSH
49687: LD_INT 100
49689: LESS
49690: PUSH
49691: LD_VAR 0 3
49695: PPUSH
49696: CALL_OW 314
49700: NOT
49701: AND
49702: IFFALSE 49731
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49704: LD_VAR 0 3
49708: PPUSH
49709: LD_VAR 0 6
49713: PUSH
49714: LD_INT 2
49716: ARRAY
49717: PPUSH
49718: LD_VAR 0 6
49722: PUSH
49723: LD_INT 3
49725: ARRAY
49726: PPUSH
49727: CALL_OW 117
// break ;
49731: GO 49735
// end ;
49733: GO 49168
49735: POP
49736: POP
// end ; end ;
49737: GO 48006
49739: POP
49740: POP
// end ;
49741: LD_VAR 0 1
49745: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49746: LD_INT 0
49748: PPUSH
49749: PPUSH
49750: PPUSH
49751: PPUSH
// if not mc_bases then
49752: LD_EXP 102
49756: NOT
49757: IFFALSE 49761
// exit ;
49759: GO 49922
// for i = 1 to mc_bases do
49761: LD_ADDR_VAR 0 2
49765: PUSH
49766: DOUBLE
49767: LD_INT 1
49769: DEC
49770: ST_TO_ADDR
49771: LD_EXP 102
49775: PUSH
49776: FOR_TO
49777: IFFALSE 49920
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49779: LD_ADDR_VAR 0 4
49783: PUSH
49784: LD_EXP 121
49788: PUSH
49789: LD_VAR 0 2
49793: ARRAY
49794: PUSH
49795: LD_EXP 124
49799: PUSH
49800: LD_VAR 0 2
49804: ARRAY
49805: UNION
49806: PPUSH
49807: LD_INT 33
49809: PUSH
49810: LD_INT 2
49812: PUSH
49813: EMPTY
49814: LIST
49815: LIST
49816: PPUSH
49817: CALL_OW 72
49821: ST_TO_ADDR
// if tmp then
49822: LD_VAR 0 4
49826: IFFALSE 49918
// for j in tmp do
49828: LD_ADDR_VAR 0 3
49832: PUSH
49833: LD_VAR 0 4
49837: PUSH
49838: FOR_IN
49839: IFFALSE 49916
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49841: LD_VAR 0 3
49845: PPUSH
49846: CALL_OW 312
49850: NOT
49851: PUSH
49852: LD_VAR 0 3
49856: PPUSH
49857: CALL_OW 256
49861: PUSH
49862: LD_INT 250
49864: GREATEREQUAL
49865: AND
49866: IFFALSE 49879
// Connect ( j ) else
49868: LD_VAR 0 3
49872: PPUSH
49873: CALL 75146 0 1
49877: GO 49914
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49879: LD_VAR 0 3
49883: PPUSH
49884: CALL_OW 256
49888: PUSH
49889: LD_INT 250
49891: LESS
49892: PUSH
49893: LD_VAR 0 3
49897: PPUSH
49898: CALL_OW 312
49902: AND
49903: IFFALSE 49914
// ComUnlink ( j ) ;
49905: LD_VAR 0 3
49909: PPUSH
49910: CALL_OW 136
49914: GO 49838
49916: POP
49917: POP
// end ;
49918: GO 49776
49920: POP
49921: POP
// end ;
49922: LD_VAR 0 1
49926: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49927: LD_INT 0
49929: PPUSH
49930: PPUSH
49931: PPUSH
49932: PPUSH
49933: PPUSH
// if not mc_bases then
49934: LD_EXP 102
49938: NOT
49939: IFFALSE 49943
// exit ;
49941: GO 50388
// for i = 1 to mc_bases do
49943: LD_ADDR_VAR 0 2
49947: PUSH
49948: DOUBLE
49949: LD_INT 1
49951: DEC
49952: ST_TO_ADDR
49953: LD_EXP 102
49957: PUSH
49958: FOR_TO
49959: IFFALSE 50386
// begin if not mc_produce [ i ] then
49961: LD_EXP 123
49965: PUSH
49966: LD_VAR 0 2
49970: ARRAY
49971: NOT
49972: IFFALSE 49976
// continue ;
49974: GO 49958
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49976: LD_ADDR_VAR 0 5
49980: PUSH
49981: LD_EXP 102
49985: PUSH
49986: LD_VAR 0 2
49990: ARRAY
49991: PPUSH
49992: LD_INT 30
49994: PUSH
49995: LD_INT 3
49997: PUSH
49998: EMPTY
49999: LIST
50000: LIST
50001: PPUSH
50002: CALL_OW 72
50006: ST_TO_ADDR
// if not fac then
50007: LD_VAR 0 5
50011: NOT
50012: IFFALSE 50016
// continue ;
50014: GO 49958
// for j in fac do
50016: LD_ADDR_VAR 0 3
50020: PUSH
50021: LD_VAR 0 5
50025: PUSH
50026: FOR_IN
50027: IFFALSE 50382
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50029: LD_VAR 0 3
50033: PPUSH
50034: CALL_OW 461
50038: PUSH
50039: LD_INT 2
50041: NONEQUAL
50042: PUSH
50043: LD_VAR 0 3
50047: PPUSH
50048: LD_INT 15
50050: PPUSH
50051: CALL 74806 0 2
50055: PUSH
50056: LD_INT 4
50058: ARRAY
50059: OR
50060: IFFALSE 50064
// continue ;
50062: GO 50026
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50064: LD_VAR 0 3
50068: PPUSH
50069: LD_EXP 123
50073: PUSH
50074: LD_VAR 0 2
50078: ARRAY
50079: PUSH
50080: LD_INT 1
50082: ARRAY
50083: PUSH
50084: LD_INT 1
50086: ARRAY
50087: PPUSH
50088: LD_EXP 123
50092: PUSH
50093: LD_VAR 0 2
50097: ARRAY
50098: PUSH
50099: LD_INT 1
50101: ARRAY
50102: PUSH
50103: LD_INT 2
50105: ARRAY
50106: PPUSH
50107: LD_EXP 123
50111: PUSH
50112: LD_VAR 0 2
50116: ARRAY
50117: PUSH
50118: LD_INT 1
50120: ARRAY
50121: PUSH
50122: LD_INT 3
50124: ARRAY
50125: PPUSH
50126: LD_EXP 123
50130: PUSH
50131: LD_VAR 0 2
50135: ARRAY
50136: PUSH
50137: LD_INT 1
50139: ARRAY
50140: PUSH
50141: LD_INT 4
50143: ARRAY
50144: PPUSH
50145: CALL_OW 448
50149: PUSH
50150: LD_VAR 0 3
50154: PPUSH
50155: LD_EXP 123
50159: PUSH
50160: LD_VAR 0 2
50164: ARRAY
50165: PUSH
50166: LD_INT 1
50168: ARRAY
50169: PUSH
50170: LD_INT 1
50172: ARRAY
50173: PUSH
50174: LD_EXP 123
50178: PUSH
50179: LD_VAR 0 2
50183: ARRAY
50184: PUSH
50185: LD_INT 1
50187: ARRAY
50188: PUSH
50189: LD_INT 2
50191: ARRAY
50192: PUSH
50193: LD_EXP 123
50197: PUSH
50198: LD_VAR 0 2
50202: ARRAY
50203: PUSH
50204: LD_INT 1
50206: ARRAY
50207: PUSH
50208: LD_INT 3
50210: ARRAY
50211: PUSH
50212: LD_EXP 123
50216: PUSH
50217: LD_VAR 0 2
50221: ARRAY
50222: PUSH
50223: LD_INT 1
50225: ARRAY
50226: PUSH
50227: LD_INT 4
50229: ARRAY
50230: PUSH
50231: EMPTY
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: PPUSH
50237: CALL 78477 0 2
50241: AND
50242: IFFALSE 50380
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50244: LD_VAR 0 3
50248: PPUSH
50249: LD_EXP 123
50253: PUSH
50254: LD_VAR 0 2
50258: ARRAY
50259: PUSH
50260: LD_INT 1
50262: ARRAY
50263: PUSH
50264: LD_INT 1
50266: ARRAY
50267: PPUSH
50268: LD_EXP 123
50272: PUSH
50273: LD_VAR 0 2
50277: ARRAY
50278: PUSH
50279: LD_INT 1
50281: ARRAY
50282: PUSH
50283: LD_INT 2
50285: ARRAY
50286: PPUSH
50287: LD_EXP 123
50291: PUSH
50292: LD_VAR 0 2
50296: ARRAY
50297: PUSH
50298: LD_INT 1
50300: ARRAY
50301: PUSH
50302: LD_INT 3
50304: ARRAY
50305: PPUSH
50306: LD_EXP 123
50310: PUSH
50311: LD_VAR 0 2
50315: ARRAY
50316: PUSH
50317: LD_INT 1
50319: ARRAY
50320: PUSH
50321: LD_INT 4
50323: ARRAY
50324: PPUSH
50325: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50329: LD_ADDR_VAR 0 4
50333: PUSH
50334: LD_EXP 123
50338: PUSH
50339: LD_VAR 0 2
50343: ARRAY
50344: PPUSH
50345: LD_INT 1
50347: PPUSH
50348: CALL_OW 3
50352: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50353: LD_ADDR_EXP 123
50357: PUSH
50358: LD_EXP 123
50362: PPUSH
50363: LD_VAR 0 2
50367: PPUSH
50368: LD_VAR 0 4
50372: PPUSH
50373: CALL_OW 1
50377: ST_TO_ADDR
// break ;
50378: GO 50382
// end ; end ;
50380: GO 50026
50382: POP
50383: POP
// end ;
50384: GO 49958
50386: POP
50387: POP
// end ;
50388: LD_VAR 0 1
50392: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50393: LD_INT 0
50395: PPUSH
50396: PPUSH
50397: PPUSH
// if not mc_bases then
50398: LD_EXP 102
50402: NOT
50403: IFFALSE 50407
// exit ;
50405: GO 50496
// for i = 1 to mc_bases do
50407: LD_ADDR_VAR 0 2
50411: PUSH
50412: DOUBLE
50413: LD_INT 1
50415: DEC
50416: ST_TO_ADDR
50417: LD_EXP 102
50421: PUSH
50422: FOR_TO
50423: IFFALSE 50494
// begin if mc_attack [ i ] then
50425: LD_EXP 122
50429: PUSH
50430: LD_VAR 0 2
50434: ARRAY
50435: IFFALSE 50492
// begin tmp := mc_attack [ i ] [ 1 ] ;
50437: LD_ADDR_VAR 0 3
50441: PUSH
50442: LD_EXP 122
50446: PUSH
50447: LD_VAR 0 2
50451: ARRAY
50452: PUSH
50453: LD_INT 1
50455: ARRAY
50456: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50457: LD_ADDR_EXP 122
50461: PUSH
50462: LD_EXP 122
50466: PPUSH
50467: LD_VAR 0 2
50471: PPUSH
50472: EMPTY
50473: PPUSH
50474: CALL_OW 1
50478: ST_TO_ADDR
// Attack ( tmp ) ;
50479: LD_VAR 0 3
50483: PPUSH
50484: CALL 100667 0 1
// exit ;
50488: POP
50489: POP
50490: GO 50496
// end ; end ;
50492: GO 50422
50494: POP
50495: POP
// end ;
50496: LD_VAR 0 1
50500: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50501: LD_INT 0
50503: PPUSH
50504: PPUSH
50505: PPUSH
50506: PPUSH
50507: PPUSH
50508: PPUSH
50509: PPUSH
// if not mc_bases then
50510: LD_EXP 102
50514: NOT
50515: IFFALSE 50519
// exit ;
50517: GO 51101
// for i = 1 to mc_bases do
50519: LD_ADDR_VAR 0 2
50523: PUSH
50524: DOUBLE
50525: LD_INT 1
50527: DEC
50528: ST_TO_ADDR
50529: LD_EXP 102
50533: PUSH
50534: FOR_TO
50535: IFFALSE 51099
// begin if not mc_bases [ i ] then
50537: LD_EXP 102
50541: PUSH
50542: LD_VAR 0 2
50546: ARRAY
50547: NOT
50548: IFFALSE 50552
// continue ;
50550: GO 50534
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50552: LD_ADDR_VAR 0 7
50556: PUSH
50557: LD_EXP 102
50561: PUSH
50562: LD_VAR 0 2
50566: ARRAY
50567: PUSH
50568: LD_INT 1
50570: ARRAY
50571: PPUSH
50572: CALL 69049 0 1
50576: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50577: LD_ADDR_EXP 125
50581: PUSH
50582: LD_EXP 125
50586: PPUSH
50587: LD_VAR 0 2
50591: PPUSH
50592: LD_EXP 102
50596: PUSH
50597: LD_VAR 0 2
50601: ARRAY
50602: PUSH
50603: LD_INT 1
50605: ARRAY
50606: PPUSH
50607: CALL_OW 255
50611: PPUSH
50612: LD_EXP 127
50616: PUSH
50617: LD_VAR 0 2
50621: ARRAY
50622: PPUSH
50623: CALL 66603 0 2
50627: PPUSH
50628: CALL_OW 1
50632: ST_TO_ADDR
// if not mc_scan [ i ] then
50633: LD_EXP 125
50637: PUSH
50638: LD_VAR 0 2
50642: ARRAY
50643: NOT
50644: IFFALSE 50799
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50646: LD_ADDR_VAR 0 4
50650: PUSH
50651: LD_EXP 102
50655: PUSH
50656: LD_VAR 0 2
50660: ARRAY
50661: PPUSH
50662: LD_INT 2
50664: PUSH
50665: LD_INT 25
50667: PUSH
50668: LD_INT 5
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: PUSH
50675: LD_INT 25
50677: PUSH
50678: LD_INT 8
50680: PUSH
50681: EMPTY
50682: LIST
50683: LIST
50684: PUSH
50685: LD_INT 25
50687: PUSH
50688: LD_INT 9
50690: PUSH
50691: EMPTY
50692: LIST
50693: LIST
50694: PUSH
50695: EMPTY
50696: LIST
50697: LIST
50698: LIST
50699: LIST
50700: PPUSH
50701: CALL_OW 72
50705: ST_TO_ADDR
// if not tmp then
50706: LD_VAR 0 4
50710: NOT
50711: IFFALSE 50715
// continue ;
50713: GO 50534
// for j in tmp do
50715: LD_ADDR_VAR 0 3
50719: PUSH
50720: LD_VAR 0 4
50724: PUSH
50725: FOR_IN
50726: IFFALSE 50797
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50728: LD_VAR 0 3
50732: PPUSH
50733: CALL_OW 310
50737: PPUSH
50738: CALL_OW 266
50742: PUSH
50743: LD_INT 5
50745: EQUAL
50746: PUSH
50747: LD_VAR 0 3
50751: PPUSH
50752: CALL_OW 257
50756: PUSH
50757: LD_INT 1
50759: EQUAL
50760: AND
50761: PUSH
50762: LD_VAR 0 3
50766: PPUSH
50767: CALL_OW 459
50771: NOT
50772: AND
50773: PUSH
50774: LD_VAR 0 7
50778: AND
50779: IFFALSE 50795
// ComChangeProfession ( j , class ) ;
50781: LD_VAR 0 3
50785: PPUSH
50786: LD_VAR 0 7
50790: PPUSH
50791: CALL_OW 123
50795: GO 50725
50797: POP
50798: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50799: LD_EXP 125
50803: PUSH
50804: LD_VAR 0 2
50808: ARRAY
50809: PUSH
50810: LD_EXP 124
50814: PUSH
50815: LD_VAR 0 2
50819: ARRAY
50820: NOT
50821: AND
50822: PUSH
50823: LD_EXP 102
50827: PUSH
50828: LD_VAR 0 2
50832: ARRAY
50833: PPUSH
50834: LD_INT 30
50836: PUSH
50837: LD_INT 32
50839: PUSH
50840: EMPTY
50841: LIST
50842: LIST
50843: PPUSH
50844: CALL_OW 72
50848: NOT
50849: AND
50850: PUSH
50851: LD_EXP 102
50855: PUSH
50856: LD_VAR 0 2
50860: ARRAY
50861: PPUSH
50862: LD_INT 2
50864: PUSH
50865: LD_INT 30
50867: PUSH
50868: LD_INT 4
50870: PUSH
50871: EMPTY
50872: LIST
50873: LIST
50874: PUSH
50875: LD_INT 30
50877: PUSH
50878: LD_INT 5
50880: PUSH
50881: EMPTY
50882: LIST
50883: LIST
50884: PUSH
50885: EMPTY
50886: LIST
50887: LIST
50888: LIST
50889: PPUSH
50890: CALL_OW 72
50894: NOT
50895: AND
50896: IFFALSE 51028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50898: LD_ADDR_VAR 0 4
50902: PUSH
50903: LD_EXP 102
50907: PUSH
50908: LD_VAR 0 2
50912: ARRAY
50913: PPUSH
50914: LD_INT 2
50916: PUSH
50917: LD_INT 25
50919: PUSH
50920: LD_INT 1
50922: PUSH
50923: EMPTY
50924: LIST
50925: LIST
50926: PUSH
50927: LD_INT 25
50929: PUSH
50930: LD_INT 5
50932: PUSH
50933: EMPTY
50934: LIST
50935: LIST
50936: PUSH
50937: LD_INT 25
50939: PUSH
50940: LD_INT 8
50942: PUSH
50943: EMPTY
50944: LIST
50945: LIST
50946: PUSH
50947: LD_INT 25
50949: PUSH
50950: LD_INT 9
50952: PUSH
50953: EMPTY
50954: LIST
50955: LIST
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: PPUSH
50964: CALL_OW 72
50968: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50969: LD_ADDR_VAR 0 4
50973: PUSH
50974: LD_VAR 0 4
50978: PUSH
50979: LD_VAR 0 4
50983: PPUSH
50984: LD_INT 18
50986: PPUSH
50987: CALL 105483 0 2
50991: DIFF
50992: ST_TO_ADDR
// if tmp then
50993: LD_VAR 0 4
50997: IFFALSE 51028
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50999: LD_VAR 0 2
51003: PPUSH
51004: LD_VAR 0 4
51008: PPUSH
51009: LD_EXP 127
51013: PUSH
51014: LD_VAR 0 2
51018: ARRAY
51019: PPUSH
51020: CALL 66638 0 3
// exit ;
51024: POP
51025: POP
51026: GO 51101
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51028: LD_EXP 125
51032: PUSH
51033: LD_VAR 0 2
51037: ARRAY
51038: PUSH
51039: LD_EXP 124
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: AND
51050: IFFALSE 51097
// begin tmp := mc_defender [ i ] ;
51052: LD_ADDR_VAR 0 4
51056: PUSH
51057: LD_EXP 124
51061: PUSH
51062: LD_VAR 0 2
51066: ARRAY
51067: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51068: LD_VAR 0 2
51072: PPUSH
51073: LD_VAR 0 4
51077: PPUSH
51078: LD_EXP 125
51082: PUSH
51083: LD_VAR 0 2
51087: ARRAY
51088: PPUSH
51089: CALL 67199 0 3
// exit ;
51093: POP
51094: POP
51095: GO 51101
// end ; end ;
51097: GO 50534
51099: POP
51100: POP
// end ;
51101: LD_VAR 0 1
51105: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51106: LD_INT 0
51108: PPUSH
51109: PPUSH
51110: PPUSH
51111: PPUSH
51112: PPUSH
51113: PPUSH
51114: PPUSH
51115: PPUSH
51116: PPUSH
51117: PPUSH
51118: PPUSH
// if not mc_bases then
51119: LD_EXP 102
51123: NOT
51124: IFFALSE 51128
// exit ;
51126: GO 52215
// for i = 1 to mc_bases do
51128: LD_ADDR_VAR 0 2
51132: PUSH
51133: DOUBLE
51134: LD_INT 1
51136: DEC
51137: ST_TO_ADDR
51138: LD_EXP 102
51142: PUSH
51143: FOR_TO
51144: IFFALSE 52213
// begin tmp := mc_lab [ i ] ;
51146: LD_ADDR_VAR 0 6
51150: PUSH
51151: LD_EXP 135
51155: PUSH
51156: LD_VAR 0 2
51160: ARRAY
51161: ST_TO_ADDR
// if not tmp then
51162: LD_VAR 0 6
51166: NOT
51167: IFFALSE 51171
// continue ;
51169: GO 51143
// idle_lab := 0 ;
51171: LD_ADDR_VAR 0 11
51175: PUSH
51176: LD_INT 0
51178: ST_TO_ADDR
// for j in tmp do
51179: LD_ADDR_VAR 0 3
51183: PUSH
51184: LD_VAR 0 6
51188: PUSH
51189: FOR_IN
51190: IFFALSE 52209
// begin researching := false ;
51192: LD_ADDR_VAR 0 10
51196: PUSH
51197: LD_INT 0
51199: ST_TO_ADDR
// side := GetSide ( j ) ;
51200: LD_ADDR_VAR 0 4
51204: PUSH
51205: LD_VAR 0 3
51209: PPUSH
51210: CALL_OW 255
51214: ST_TO_ADDR
// if not mc_tech [ side ] then
51215: LD_EXP 129
51219: PUSH
51220: LD_VAR 0 4
51224: ARRAY
51225: NOT
51226: IFFALSE 51230
// continue ;
51228: GO 51189
// if BuildingStatus ( j ) = bs_idle then
51230: LD_VAR 0 3
51234: PPUSH
51235: CALL_OW 461
51239: PUSH
51240: LD_INT 2
51242: EQUAL
51243: IFFALSE 51431
// begin if idle_lab and UnitsInside ( j ) < 6 then
51245: LD_VAR 0 11
51249: PUSH
51250: LD_VAR 0 3
51254: PPUSH
51255: CALL_OW 313
51259: PUSH
51260: LD_INT 6
51262: LESS
51263: AND
51264: IFFALSE 51335
// begin tmp2 := UnitsInside ( idle_lab ) ;
51266: LD_ADDR_VAR 0 9
51270: PUSH
51271: LD_VAR 0 11
51275: PPUSH
51276: CALL_OW 313
51280: ST_TO_ADDR
// if tmp2 then
51281: LD_VAR 0 9
51285: IFFALSE 51327
// for x in tmp2 do
51287: LD_ADDR_VAR 0 7
51291: PUSH
51292: LD_VAR 0 9
51296: PUSH
51297: FOR_IN
51298: IFFALSE 51325
// begin ComExitBuilding ( x ) ;
51300: LD_VAR 0 7
51304: PPUSH
51305: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51309: LD_VAR 0 7
51313: PPUSH
51314: LD_VAR 0 3
51318: PPUSH
51319: CALL_OW 180
// end ;
51323: GO 51297
51325: POP
51326: POP
// idle_lab := 0 ;
51327: LD_ADDR_VAR 0 11
51331: PUSH
51332: LD_INT 0
51334: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51335: LD_ADDR_VAR 0 5
51339: PUSH
51340: LD_EXP 129
51344: PUSH
51345: LD_VAR 0 4
51349: ARRAY
51350: PUSH
51351: FOR_IN
51352: IFFALSE 51412
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51354: LD_VAR 0 3
51358: PPUSH
51359: LD_VAR 0 5
51363: PPUSH
51364: CALL_OW 430
51368: PUSH
51369: LD_VAR 0 4
51373: PPUSH
51374: LD_VAR 0 5
51378: PPUSH
51379: CALL 65708 0 2
51383: AND
51384: IFFALSE 51410
// begin researching := true ;
51386: LD_ADDR_VAR 0 10
51390: PUSH
51391: LD_INT 1
51393: ST_TO_ADDR
// ComResearch ( j , t ) ;
51394: LD_VAR 0 3
51398: PPUSH
51399: LD_VAR 0 5
51403: PPUSH
51404: CALL_OW 124
// break ;
51408: GO 51412
// end ;
51410: GO 51351
51412: POP
51413: POP
// if not researching then
51414: LD_VAR 0 10
51418: NOT
51419: IFFALSE 51431
// idle_lab := j ;
51421: LD_ADDR_VAR 0 11
51425: PUSH
51426: LD_VAR 0 3
51430: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51431: LD_VAR 0 3
51435: PPUSH
51436: CALL_OW 461
51440: PUSH
51441: LD_INT 10
51443: EQUAL
51444: IFFALSE 52032
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51446: LD_EXP 131
51450: PUSH
51451: LD_VAR 0 2
51455: ARRAY
51456: NOT
51457: PUSH
51458: LD_EXP 132
51462: PUSH
51463: LD_VAR 0 2
51467: ARRAY
51468: NOT
51469: AND
51470: PUSH
51471: LD_EXP 129
51475: PUSH
51476: LD_VAR 0 4
51480: ARRAY
51481: PUSH
51482: LD_INT 1
51484: GREATER
51485: AND
51486: IFFALSE 51617
// begin ComCancel ( j ) ;
51488: LD_VAR 0 3
51492: PPUSH
51493: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51497: LD_ADDR_EXP 129
51501: PUSH
51502: LD_EXP 129
51506: PPUSH
51507: LD_VAR 0 4
51511: PPUSH
51512: LD_EXP 129
51516: PUSH
51517: LD_VAR 0 4
51521: ARRAY
51522: PPUSH
51523: LD_EXP 129
51527: PUSH
51528: LD_VAR 0 4
51532: ARRAY
51533: PUSH
51534: LD_INT 1
51536: MINUS
51537: PPUSH
51538: LD_EXP 129
51542: PUSH
51543: LD_VAR 0 4
51547: ARRAY
51548: PPUSH
51549: LD_INT 0
51551: PPUSH
51552: CALL 71631 0 4
51556: PPUSH
51557: CALL_OW 1
51561: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51562: LD_ADDR_EXP 129
51566: PUSH
51567: LD_EXP 129
51571: PPUSH
51572: LD_VAR 0 4
51576: PPUSH
51577: LD_EXP 129
51581: PUSH
51582: LD_VAR 0 4
51586: ARRAY
51587: PPUSH
51588: LD_EXP 129
51592: PUSH
51593: LD_VAR 0 4
51597: ARRAY
51598: PPUSH
51599: LD_INT 1
51601: PPUSH
51602: LD_INT 0
51604: PPUSH
51605: CALL 71631 0 4
51609: PPUSH
51610: CALL_OW 1
51614: ST_TO_ADDR
// continue ;
51615: GO 51189
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51617: LD_EXP 131
51621: PUSH
51622: LD_VAR 0 2
51626: ARRAY
51627: PUSH
51628: LD_EXP 132
51632: PUSH
51633: LD_VAR 0 2
51637: ARRAY
51638: NOT
51639: AND
51640: IFFALSE 51767
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51642: LD_ADDR_EXP 132
51646: PUSH
51647: LD_EXP 132
51651: PPUSH
51652: LD_VAR 0 2
51656: PUSH
51657: LD_EXP 132
51661: PUSH
51662: LD_VAR 0 2
51666: ARRAY
51667: PUSH
51668: LD_INT 1
51670: PLUS
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: PPUSH
51676: LD_EXP 131
51680: PUSH
51681: LD_VAR 0 2
51685: ARRAY
51686: PUSH
51687: LD_INT 1
51689: ARRAY
51690: PPUSH
51691: CALL 72213 0 3
51695: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51696: LD_EXP 131
51700: PUSH
51701: LD_VAR 0 2
51705: ARRAY
51706: PUSH
51707: LD_INT 1
51709: ARRAY
51710: PPUSH
51711: LD_INT 112
51713: PPUSH
51714: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51718: LD_ADDR_VAR 0 9
51722: PUSH
51723: LD_EXP 131
51727: PUSH
51728: LD_VAR 0 2
51732: ARRAY
51733: PPUSH
51734: LD_INT 1
51736: PPUSH
51737: CALL_OW 3
51741: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51742: LD_ADDR_EXP 131
51746: PUSH
51747: LD_EXP 131
51751: PPUSH
51752: LD_VAR 0 2
51756: PPUSH
51757: LD_VAR 0 9
51761: PPUSH
51762: CALL_OW 1
51766: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51767: LD_EXP 131
51771: PUSH
51772: LD_VAR 0 2
51776: ARRAY
51777: PUSH
51778: LD_EXP 132
51782: PUSH
51783: LD_VAR 0 2
51787: ARRAY
51788: AND
51789: PUSH
51790: LD_EXP 132
51794: PUSH
51795: LD_VAR 0 2
51799: ARRAY
51800: PUSH
51801: LD_INT 1
51803: ARRAY
51804: PPUSH
51805: CALL_OW 310
51809: NOT
51810: AND
51811: PUSH
51812: LD_VAR 0 3
51816: PPUSH
51817: CALL_OW 313
51821: PUSH
51822: LD_INT 6
51824: EQUAL
51825: AND
51826: IFFALSE 51882
// begin tmp2 := UnitsInside ( j ) ;
51828: LD_ADDR_VAR 0 9
51832: PUSH
51833: LD_VAR 0 3
51837: PPUSH
51838: CALL_OW 313
51842: ST_TO_ADDR
// if tmp2 = 6 then
51843: LD_VAR 0 9
51847: PUSH
51848: LD_INT 6
51850: EQUAL
51851: IFFALSE 51882
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51853: LD_VAR 0 9
51857: PUSH
51858: LD_INT 1
51860: ARRAY
51861: PPUSH
51862: LD_INT 112
51864: PPUSH
51865: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51869: LD_VAR 0 9
51873: PUSH
51874: LD_INT 1
51876: ARRAY
51877: PPUSH
51878: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51882: LD_EXP 132
51886: PUSH
51887: LD_VAR 0 2
51891: ARRAY
51892: PUSH
51893: LD_EXP 132
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: PUSH
51904: LD_INT 1
51906: ARRAY
51907: PPUSH
51908: CALL_OW 314
51912: NOT
51913: AND
51914: PUSH
51915: LD_EXP 132
51919: PUSH
51920: LD_VAR 0 2
51924: ARRAY
51925: PUSH
51926: LD_INT 1
51928: ARRAY
51929: PPUSH
51930: CALL_OW 310
51934: NOT
51935: AND
51936: IFFALSE 51962
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51938: LD_EXP 132
51942: PUSH
51943: LD_VAR 0 2
51947: ARRAY
51948: PUSH
51949: LD_INT 1
51951: ARRAY
51952: PPUSH
51953: LD_VAR 0 3
51957: PPUSH
51958: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51962: LD_EXP 132
51966: PUSH
51967: LD_VAR 0 2
51971: ARRAY
51972: PUSH
51973: LD_INT 1
51975: ARRAY
51976: PPUSH
51977: CALL_OW 310
51981: PUSH
51982: LD_EXP 132
51986: PUSH
51987: LD_VAR 0 2
51991: ARRAY
51992: PUSH
51993: LD_INT 1
51995: ARRAY
51996: PPUSH
51997: CALL_OW 310
52001: PPUSH
52002: CALL_OW 461
52006: PUSH
52007: LD_INT 3
52009: NONEQUAL
52010: AND
52011: IFFALSE 52032
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52013: LD_EXP 132
52017: PUSH
52018: LD_VAR 0 2
52022: ARRAY
52023: PUSH
52024: LD_INT 1
52026: ARRAY
52027: PPUSH
52028: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52032: LD_VAR 0 3
52036: PPUSH
52037: CALL_OW 461
52041: PUSH
52042: LD_INT 6
52044: EQUAL
52045: PUSH
52046: LD_VAR 0 6
52050: PUSH
52051: LD_INT 1
52053: GREATER
52054: AND
52055: IFFALSE 52207
// begin sci := [ ] ;
52057: LD_ADDR_VAR 0 8
52061: PUSH
52062: EMPTY
52063: ST_TO_ADDR
// for x in ( tmp diff j ) do
52064: LD_ADDR_VAR 0 7
52068: PUSH
52069: LD_VAR 0 6
52073: PUSH
52074: LD_VAR 0 3
52078: DIFF
52079: PUSH
52080: FOR_IN
52081: IFFALSE 52133
// begin if sci = 6 then
52083: LD_VAR 0 8
52087: PUSH
52088: LD_INT 6
52090: EQUAL
52091: IFFALSE 52095
// break ;
52093: GO 52133
// if BuildingStatus ( x ) = bs_idle then
52095: LD_VAR 0 7
52099: PPUSH
52100: CALL_OW 461
52104: PUSH
52105: LD_INT 2
52107: EQUAL
52108: IFFALSE 52131
// sci := sci ^ UnitsInside ( x ) ;
52110: LD_ADDR_VAR 0 8
52114: PUSH
52115: LD_VAR 0 8
52119: PUSH
52120: LD_VAR 0 7
52124: PPUSH
52125: CALL_OW 313
52129: ADD
52130: ST_TO_ADDR
// end ;
52131: GO 52080
52133: POP
52134: POP
// if not sci then
52135: LD_VAR 0 8
52139: NOT
52140: IFFALSE 52144
// continue ;
52142: GO 51189
// for x in sci do
52144: LD_ADDR_VAR 0 7
52148: PUSH
52149: LD_VAR 0 8
52153: PUSH
52154: FOR_IN
52155: IFFALSE 52205
// if IsInUnit ( x ) and not HasTask ( x ) then
52157: LD_VAR 0 7
52161: PPUSH
52162: CALL_OW 310
52166: PUSH
52167: LD_VAR 0 7
52171: PPUSH
52172: CALL_OW 314
52176: NOT
52177: AND
52178: IFFALSE 52203
// begin ComExitBuilding ( x ) ;
52180: LD_VAR 0 7
52184: PPUSH
52185: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52189: LD_VAR 0 7
52193: PPUSH
52194: LD_VAR 0 3
52198: PPUSH
52199: CALL_OW 180
// end ;
52203: GO 52154
52205: POP
52206: POP
// end ; end ;
52207: GO 51189
52209: POP
52210: POP
// end ;
52211: GO 51143
52213: POP
52214: POP
// end ;
52215: LD_VAR 0 1
52219: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52220: LD_INT 0
52222: PPUSH
52223: PPUSH
// if not mc_bases then
52224: LD_EXP 102
52228: NOT
52229: IFFALSE 52233
// exit ;
52231: GO 52314
// for i = 1 to mc_bases do
52233: LD_ADDR_VAR 0 2
52237: PUSH
52238: DOUBLE
52239: LD_INT 1
52241: DEC
52242: ST_TO_ADDR
52243: LD_EXP 102
52247: PUSH
52248: FOR_TO
52249: IFFALSE 52312
// if mc_mines [ i ] and mc_miners [ i ] then
52251: LD_EXP 115
52255: PUSH
52256: LD_VAR 0 2
52260: ARRAY
52261: PUSH
52262: LD_EXP 116
52266: PUSH
52267: LD_VAR 0 2
52271: ARRAY
52272: AND
52273: IFFALSE 52310
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52275: LD_EXP 116
52279: PUSH
52280: LD_VAR 0 2
52284: ARRAY
52285: PUSH
52286: LD_INT 1
52288: ARRAY
52289: PPUSH
52290: CALL_OW 255
52294: PPUSH
52295: LD_EXP 115
52299: PUSH
52300: LD_VAR 0 2
52304: ARRAY
52305: PPUSH
52306: CALL 69202 0 2
52310: GO 52248
52312: POP
52313: POP
// end ;
52314: LD_VAR 0 1
52318: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52319: LD_INT 0
52321: PPUSH
52322: PPUSH
52323: PPUSH
52324: PPUSH
52325: PPUSH
52326: PPUSH
52327: PPUSH
52328: PPUSH
// if not mc_bases or not mc_parking then
52329: LD_EXP 102
52333: NOT
52334: PUSH
52335: LD_EXP 126
52339: NOT
52340: OR
52341: IFFALSE 52345
// exit ;
52343: GO 53044
// for i = 1 to mc_bases do
52345: LD_ADDR_VAR 0 2
52349: PUSH
52350: DOUBLE
52351: LD_INT 1
52353: DEC
52354: ST_TO_ADDR
52355: LD_EXP 102
52359: PUSH
52360: FOR_TO
52361: IFFALSE 53042
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52363: LD_EXP 102
52367: PUSH
52368: LD_VAR 0 2
52372: ARRAY
52373: NOT
52374: PUSH
52375: LD_EXP 126
52379: PUSH
52380: LD_VAR 0 2
52384: ARRAY
52385: NOT
52386: OR
52387: IFFALSE 52391
// continue ;
52389: GO 52360
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52391: LD_ADDR_VAR 0 5
52395: PUSH
52396: LD_EXP 102
52400: PUSH
52401: LD_VAR 0 2
52405: ARRAY
52406: PUSH
52407: LD_INT 1
52409: ARRAY
52410: PPUSH
52411: CALL_OW 255
52415: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52416: LD_ADDR_VAR 0 6
52420: PUSH
52421: LD_EXP 102
52425: PUSH
52426: LD_VAR 0 2
52430: ARRAY
52431: PPUSH
52432: LD_INT 30
52434: PUSH
52435: LD_INT 3
52437: PUSH
52438: EMPTY
52439: LIST
52440: LIST
52441: PPUSH
52442: CALL_OW 72
52446: ST_TO_ADDR
// if not fac then
52447: LD_VAR 0 6
52451: NOT
52452: IFFALSE 52503
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52454: LD_ADDR_VAR 0 6
52458: PUSH
52459: LD_EXP 102
52463: PUSH
52464: LD_VAR 0 2
52468: ARRAY
52469: PPUSH
52470: LD_INT 2
52472: PUSH
52473: LD_INT 30
52475: PUSH
52476: LD_INT 0
52478: PUSH
52479: EMPTY
52480: LIST
52481: LIST
52482: PUSH
52483: LD_INT 30
52485: PUSH
52486: LD_INT 1
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: LIST
52497: PPUSH
52498: CALL_OW 72
52502: ST_TO_ADDR
// if not fac then
52503: LD_VAR 0 6
52507: NOT
52508: IFFALSE 52512
// continue ;
52510: GO 52360
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52512: LD_ADDR_VAR 0 7
52516: PUSH
52517: LD_EXP 126
52521: PUSH
52522: LD_VAR 0 2
52526: ARRAY
52527: PPUSH
52528: LD_INT 22
52530: PUSH
52531: LD_VAR 0 5
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 21
52542: PUSH
52543: LD_INT 2
52545: PUSH
52546: EMPTY
52547: LIST
52548: LIST
52549: PUSH
52550: LD_INT 3
52552: PUSH
52553: LD_INT 24
52555: PUSH
52556: LD_INT 1000
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: PUSH
52567: EMPTY
52568: LIST
52569: LIST
52570: LIST
52571: PPUSH
52572: CALL_OW 70
52576: ST_TO_ADDR
// for j in fac do
52577: LD_ADDR_VAR 0 3
52581: PUSH
52582: LD_VAR 0 6
52586: PUSH
52587: FOR_IN
52588: IFFALSE 52669
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52590: LD_ADDR_VAR 0 7
52594: PUSH
52595: LD_VAR 0 7
52599: PUSH
52600: LD_INT 22
52602: PUSH
52603: LD_VAR 0 5
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: PUSH
52612: LD_INT 91
52614: PUSH
52615: LD_VAR 0 3
52619: PUSH
52620: LD_INT 15
52622: PUSH
52623: EMPTY
52624: LIST
52625: LIST
52626: LIST
52627: PUSH
52628: LD_INT 21
52630: PUSH
52631: LD_INT 2
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: PUSH
52638: LD_INT 3
52640: PUSH
52641: LD_INT 24
52643: PUSH
52644: LD_INT 1000
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: PUSH
52651: EMPTY
52652: LIST
52653: LIST
52654: PUSH
52655: EMPTY
52656: LIST
52657: LIST
52658: LIST
52659: LIST
52660: PPUSH
52661: CALL_OW 69
52665: UNION
52666: ST_TO_ADDR
52667: GO 52587
52669: POP
52670: POP
// if not vehs then
52671: LD_VAR 0 7
52675: NOT
52676: IFFALSE 52702
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52678: LD_ADDR_EXP 114
52682: PUSH
52683: LD_EXP 114
52687: PPUSH
52688: LD_VAR 0 2
52692: PPUSH
52693: EMPTY
52694: PPUSH
52695: CALL_OW 1
52699: ST_TO_ADDR
// continue ;
52700: GO 52360
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52702: LD_ADDR_VAR 0 8
52706: PUSH
52707: LD_EXP 102
52711: PUSH
52712: LD_VAR 0 2
52716: ARRAY
52717: PPUSH
52718: LD_INT 30
52720: PUSH
52721: LD_INT 3
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: PPUSH
52728: CALL_OW 72
52732: ST_TO_ADDR
// if tmp then
52733: LD_VAR 0 8
52737: IFFALSE 52840
// begin for j in tmp do
52739: LD_ADDR_VAR 0 3
52743: PUSH
52744: LD_VAR 0 8
52748: PUSH
52749: FOR_IN
52750: IFFALSE 52838
// for k in UnitsInside ( j ) do
52752: LD_ADDR_VAR 0 4
52756: PUSH
52757: LD_VAR 0 3
52761: PPUSH
52762: CALL_OW 313
52766: PUSH
52767: FOR_IN
52768: IFFALSE 52834
// if k then
52770: LD_VAR 0 4
52774: IFFALSE 52832
// if not k in mc_repair_vehicle [ i ] then
52776: LD_VAR 0 4
52780: PUSH
52781: LD_EXP 114
52785: PUSH
52786: LD_VAR 0 2
52790: ARRAY
52791: IN
52792: NOT
52793: IFFALSE 52832
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52795: LD_ADDR_EXP 114
52799: PUSH
52800: LD_EXP 114
52804: PPUSH
52805: LD_VAR 0 2
52809: PPUSH
52810: LD_EXP 114
52814: PUSH
52815: LD_VAR 0 2
52819: ARRAY
52820: PUSH
52821: LD_VAR 0 4
52825: UNION
52826: PPUSH
52827: CALL_OW 1
52831: ST_TO_ADDR
52832: GO 52767
52834: POP
52835: POP
52836: GO 52749
52838: POP
52839: POP
// end ; if not mc_repair_vehicle [ i ] then
52840: LD_EXP 114
52844: PUSH
52845: LD_VAR 0 2
52849: ARRAY
52850: NOT
52851: IFFALSE 52855
// continue ;
52853: GO 52360
// for j in mc_repair_vehicle [ i ] do
52855: LD_ADDR_VAR 0 3
52859: PUSH
52860: LD_EXP 114
52864: PUSH
52865: LD_VAR 0 2
52869: ARRAY
52870: PUSH
52871: FOR_IN
52872: IFFALSE 53038
// begin if GetClass ( j ) <> 3 then
52874: LD_VAR 0 3
52878: PPUSH
52879: CALL_OW 257
52883: PUSH
52884: LD_INT 3
52886: NONEQUAL
52887: IFFALSE 52928
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52889: LD_ADDR_EXP 114
52893: PUSH
52894: LD_EXP 114
52898: PPUSH
52899: LD_VAR 0 2
52903: PPUSH
52904: LD_EXP 114
52908: PUSH
52909: LD_VAR 0 2
52913: ARRAY
52914: PUSH
52915: LD_VAR 0 3
52919: DIFF
52920: PPUSH
52921: CALL_OW 1
52925: ST_TO_ADDR
// continue ;
52926: GO 52871
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52928: LD_VAR 0 3
52932: PPUSH
52933: CALL_OW 311
52937: NOT
52938: PUSH
52939: LD_VAR 0 3
52943: PUSH
52944: LD_EXP 105
52948: PUSH
52949: LD_VAR 0 2
52953: ARRAY
52954: PUSH
52955: LD_INT 1
52957: ARRAY
52958: IN
52959: NOT
52960: AND
52961: PUSH
52962: LD_VAR 0 3
52966: PUSH
52967: LD_EXP 105
52971: PUSH
52972: LD_VAR 0 2
52976: ARRAY
52977: PUSH
52978: LD_INT 2
52980: ARRAY
52981: IN
52982: NOT
52983: AND
52984: IFFALSE 53036
// begin if IsInUnit ( j ) then
52986: LD_VAR 0 3
52990: PPUSH
52991: CALL_OW 310
52995: IFFALSE 53006
// ComExitBuilding ( j ) ;
52997: LD_VAR 0 3
53001: PPUSH
53002: CALL_OW 122
// if not HasTask ( j ) then
53006: LD_VAR 0 3
53010: PPUSH
53011: CALL_OW 314
53015: NOT
53016: IFFALSE 53036
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
53018: LD_VAR 0 3
53022: PPUSH
53023: LD_VAR 0 7
53027: PUSH
53028: LD_INT 1
53030: ARRAY
53031: PPUSH
53032: CALL_OW 189
// end ; end ;
53036: GO 52871
53038: POP
53039: POP
// end ;
53040: GO 52360
53042: POP
53043: POP
// end ;
53044: LD_VAR 0 1
53048: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53049: LD_INT 0
53051: PPUSH
53052: PPUSH
53053: PPUSH
53054: PPUSH
53055: PPUSH
53056: PPUSH
53057: PPUSH
53058: PPUSH
53059: PPUSH
53060: PPUSH
53061: PPUSH
// if not mc_bases then
53062: LD_EXP 102
53066: NOT
53067: IFFALSE 53071
// exit ;
53069: GO 53873
// for i = 1 to mc_bases do
53071: LD_ADDR_VAR 0 2
53075: PUSH
53076: DOUBLE
53077: LD_INT 1
53079: DEC
53080: ST_TO_ADDR
53081: LD_EXP 102
53085: PUSH
53086: FOR_TO
53087: IFFALSE 53871
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53089: LD_EXP 130
53093: PUSH
53094: LD_VAR 0 2
53098: ARRAY
53099: NOT
53100: PUSH
53101: LD_EXP 105
53105: PUSH
53106: LD_VAR 0 2
53110: ARRAY
53111: PUSH
53112: LD_INT 1
53114: ARRAY
53115: OR
53116: PUSH
53117: LD_EXP 105
53121: PUSH
53122: LD_VAR 0 2
53126: ARRAY
53127: PUSH
53128: LD_INT 2
53130: ARRAY
53131: OR
53132: PUSH
53133: LD_EXP 128
53137: PUSH
53138: LD_VAR 0 2
53142: ARRAY
53143: PPUSH
53144: LD_INT 1
53146: PPUSH
53147: CALL_OW 325
53151: NOT
53152: OR
53153: PUSH
53154: LD_EXP 125
53158: PUSH
53159: LD_VAR 0 2
53163: ARRAY
53164: OR
53165: IFFALSE 53169
// continue ;
53167: GO 53086
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53169: LD_ADDR_VAR 0 8
53173: PUSH
53174: LD_EXP 102
53178: PUSH
53179: LD_VAR 0 2
53183: ARRAY
53184: PPUSH
53185: LD_INT 25
53187: PUSH
53188: LD_INT 4
53190: PUSH
53191: EMPTY
53192: LIST
53193: LIST
53194: PUSH
53195: LD_INT 50
53197: PUSH
53198: EMPTY
53199: LIST
53200: PUSH
53201: LD_INT 3
53203: PUSH
53204: LD_INT 60
53206: PUSH
53207: EMPTY
53208: LIST
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: LIST
53218: PPUSH
53219: CALL_OW 72
53223: PUSH
53224: LD_EXP 106
53228: PUSH
53229: LD_VAR 0 2
53233: ARRAY
53234: DIFF
53235: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53236: LD_ADDR_VAR 0 9
53240: PUSH
53241: LD_EXP 102
53245: PUSH
53246: LD_VAR 0 2
53250: ARRAY
53251: PPUSH
53252: LD_INT 2
53254: PUSH
53255: LD_INT 30
53257: PUSH
53258: LD_INT 0
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PUSH
53265: LD_INT 30
53267: PUSH
53268: LD_INT 1
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: PPUSH
53280: CALL_OW 72
53284: ST_TO_ADDR
// if not tmp or not dep then
53285: LD_VAR 0 8
53289: NOT
53290: PUSH
53291: LD_VAR 0 9
53295: NOT
53296: OR
53297: IFFALSE 53301
// continue ;
53299: GO 53086
// side := GetSide ( tmp [ 1 ] ) ;
53301: LD_ADDR_VAR 0 11
53305: PUSH
53306: LD_VAR 0 8
53310: PUSH
53311: LD_INT 1
53313: ARRAY
53314: PPUSH
53315: CALL_OW 255
53319: ST_TO_ADDR
// dep := dep [ 1 ] ;
53320: LD_ADDR_VAR 0 9
53324: PUSH
53325: LD_VAR 0 9
53329: PUSH
53330: LD_INT 1
53332: ARRAY
53333: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53334: LD_ADDR_VAR 0 7
53338: PUSH
53339: LD_EXP 130
53343: PUSH
53344: LD_VAR 0 2
53348: ARRAY
53349: PPUSH
53350: LD_INT 22
53352: PUSH
53353: LD_INT 0
53355: PUSH
53356: EMPTY
53357: LIST
53358: LIST
53359: PUSH
53360: LD_INT 25
53362: PUSH
53363: LD_INT 12
53365: PUSH
53366: EMPTY
53367: LIST
53368: LIST
53369: PUSH
53370: EMPTY
53371: LIST
53372: LIST
53373: PPUSH
53374: CALL_OW 70
53378: PUSH
53379: LD_INT 22
53381: PUSH
53382: LD_INT 0
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: LD_INT 25
53391: PUSH
53392: LD_INT 12
53394: PUSH
53395: EMPTY
53396: LIST
53397: LIST
53398: PUSH
53399: LD_INT 91
53401: PUSH
53402: LD_VAR 0 9
53406: PUSH
53407: LD_INT 20
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: LIST
53414: PUSH
53415: EMPTY
53416: LIST
53417: LIST
53418: LIST
53419: PPUSH
53420: CALL_OW 69
53424: UNION
53425: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53426: LD_ADDR_VAR 0 10
53430: PUSH
53431: LD_EXP 130
53435: PUSH
53436: LD_VAR 0 2
53440: ARRAY
53441: PPUSH
53442: LD_INT 81
53444: PUSH
53445: LD_VAR 0 11
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: PPUSH
53454: CALL_OW 70
53458: ST_TO_ADDR
// if not apes or danger_at_area then
53459: LD_VAR 0 7
53463: NOT
53464: PUSH
53465: LD_VAR 0 10
53469: OR
53470: IFFALSE 53520
// begin if mc_taming [ i ] then
53472: LD_EXP 133
53476: PUSH
53477: LD_VAR 0 2
53481: ARRAY
53482: IFFALSE 53518
// begin MC_Reset ( i , 121 ) ;
53484: LD_VAR 0 2
53488: PPUSH
53489: LD_INT 121
53491: PPUSH
53492: CALL 38955 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53496: LD_ADDR_EXP 133
53500: PUSH
53501: LD_EXP 133
53505: PPUSH
53506: LD_VAR 0 2
53510: PPUSH
53511: EMPTY
53512: PPUSH
53513: CALL_OW 1
53517: ST_TO_ADDR
// end ; continue ;
53518: GO 53086
// end ; for j in tmp do
53520: LD_ADDR_VAR 0 3
53524: PUSH
53525: LD_VAR 0 8
53529: PUSH
53530: FOR_IN
53531: IFFALSE 53867
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53533: LD_VAR 0 3
53537: PUSH
53538: LD_EXP 133
53542: PUSH
53543: LD_VAR 0 2
53547: ARRAY
53548: IN
53549: NOT
53550: PUSH
53551: LD_EXP 133
53555: PUSH
53556: LD_VAR 0 2
53560: ARRAY
53561: PUSH
53562: LD_INT 3
53564: LESS
53565: AND
53566: IFFALSE 53624
// begin SetTag ( j , 121 ) ;
53568: LD_VAR 0 3
53572: PPUSH
53573: LD_INT 121
53575: PPUSH
53576: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53580: LD_ADDR_EXP 133
53584: PUSH
53585: LD_EXP 133
53589: PPUSH
53590: LD_VAR 0 2
53594: PUSH
53595: LD_EXP 133
53599: PUSH
53600: LD_VAR 0 2
53604: ARRAY
53605: PUSH
53606: LD_INT 1
53608: PLUS
53609: PUSH
53610: EMPTY
53611: LIST
53612: LIST
53613: PPUSH
53614: LD_VAR 0 3
53618: PPUSH
53619: CALL 72213 0 3
53623: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53624: LD_VAR 0 3
53628: PUSH
53629: LD_EXP 133
53633: PUSH
53634: LD_VAR 0 2
53638: ARRAY
53639: IN
53640: IFFALSE 53865
// begin if GetClass ( j ) <> 4 then
53642: LD_VAR 0 3
53646: PPUSH
53647: CALL_OW 257
53651: PUSH
53652: LD_INT 4
53654: NONEQUAL
53655: IFFALSE 53708
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53657: LD_ADDR_EXP 133
53661: PUSH
53662: LD_EXP 133
53666: PPUSH
53667: LD_VAR 0 2
53671: PPUSH
53672: LD_EXP 133
53676: PUSH
53677: LD_VAR 0 2
53681: ARRAY
53682: PUSH
53683: LD_VAR 0 3
53687: DIFF
53688: PPUSH
53689: CALL_OW 1
53693: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53694: LD_VAR 0 3
53698: PPUSH
53699: LD_INT 0
53701: PPUSH
53702: CALL_OW 109
// continue ;
53706: GO 53530
// end ; if IsInUnit ( j ) then
53708: LD_VAR 0 3
53712: PPUSH
53713: CALL_OW 310
53717: IFFALSE 53728
// ComExitBuilding ( j ) ;
53719: LD_VAR 0 3
53723: PPUSH
53724: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53728: LD_ADDR_VAR 0 6
53732: PUSH
53733: LD_VAR 0 7
53737: PPUSH
53738: LD_VAR 0 3
53742: PPUSH
53743: CALL_OW 74
53747: ST_TO_ADDR
// if not ape then
53748: LD_VAR 0 6
53752: NOT
53753: IFFALSE 53757
// break ;
53755: GO 53867
// x := GetX ( ape ) ;
53757: LD_ADDR_VAR 0 4
53761: PUSH
53762: LD_VAR 0 6
53766: PPUSH
53767: CALL_OW 250
53771: ST_TO_ADDR
// y := GetY ( ape ) ;
53772: LD_ADDR_VAR 0 5
53776: PUSH
53777: LD_VAR 0 6
53781: PPUSH
53782: CALL_OW 251
53786: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53787: LD_VAR 0 4
53791: PPUSH
53792: LD_VAR 0 5
53796: PPUSH
53797: CALL_OW 488
53801: NOT
53802: PUSH
53803: LD_VAR 0 11
53807: PPUSH
53808: LD_VAR 0 4
53812: PPUSH
53813: LD_VAR 0 5
53817: PPUSH
53818: LD_INT 20
53820: PPUSH
53821: CALL 73109 0 4
53825: PUSH
53826: LD_INT 4
53828: ARRAY
53829: OR
53830: IFFALSE 53834
// break ;
53832: GO 53867
// if not HasTask ( j ) then
53834: LD_VAR 0 3
53838: PPUSH
53839: CALL_OW 314
53843: NOT
53844: IFFALSE 53865
// ComTameXY ( j , x , y ) ;
53846: LD_VAR 0 3
53850: PPUSH
53851: LD_VAR 0 4
53855: PPUSH
53856: LD_VAR 0 5
53860: PPUSH
53861: CALL_OW 131
// end ; end ;
53865: GO 53530
53867: POP
53868: POP
// end ;
53869: GO 53086
53871: POP
53872: POP
// end ;
53873: LD_VAR 0 1
53877: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53878: LD_INT 0
53880: PPUSH
53881: PPUSH
53882: PPUSH
53883: PPUSH
53884: PPUSH
53885: PPUSH
53886: PPUSH
53887: PPUSH
// if not mc_bases then
53888: LD_EXP 102
53892: NOT
53893: IFFALSE 53897
// exit ;
53895: GO 54523
// for i = 1 to mc_bases do
53897: LD_ADDR_VAR 0 2
53901: PUSH
53902: DOUBLE
53903: LD_INT 1
53905: DEC
53906: ST_TO_ADDR
53907: LD_EXP 102
53911: PUSH
53912: FOR_TO
53913: IFFALSE 54521
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53915: LD_EXP 131
53919: PUSH
53920: LD_VAR 0 2
53924: ARRAY
53925: NOT
53926: PUSH
53927: LD_EXP 131
53931: PUSH
53932: LD_VAR 0 2
53936: ARRAY
53937: PPUSH
53938: LD_INT 25
53940: PUSH
53941: LD_INT 12
53943: PUSH
53944: EMPTY
53945: LIST
53946: LIST
53947: PPUSH
53948: CALL_OW 72
53952: NOT
53953: OR
53954: IFFALSE 53958
// continue ;
53956: GO 53912
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53958: LD_ADDR_VAR 0 5
53962: PUSH
53963: LD_EXP 131
53967: PUSH
53968: LD_VAR 0 2
53972: ARRAY
53973: PUSH
53974: LD_INT 1
53976: ARRAY
53977: PPUSH
53978: CALL_OW 255
53982: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53983: LD_VAR 0 5
53987: PPUSH
53988: LD_INT 2
53990: PPUSH
53991: CALL_OW 325
53995: IFFALSE 54248
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53997: LD_ADDR_VAR 0 4
54001: PUSH
54002: LD_EXP 131
54006: PUSH
54007: LD_VAR 0 2
54011: ARRAY
54012: PPUSH
54013: LD_INT 25
54015: PUSH
54016: LD_INT 16
54018: PUSH
54019: EMPTY
54020: LIST
54021: LIST
54022: PPUSH
54023: CALL_OW 72
54027: ST_TO_ADDR
// if tmp < 6 then
54028: LD_VAR 0 4
54032: PUSH
54033: LD_INT 6
54035: LESS
54036: IFFALSE 54248
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54038: LD_ADDR_VAR 0 6
54042: PUSH
54043: LD_EXP 102
54047: PUSH
54048: LD_VAR 0 2
54052: ARRAY
54053: PPUSH
54054: LD_INT 2
54056: PUSH
54057: LD_INT 30
54059: PUSH
54060: LD_INT 0
54062: PUSH
54063: EMPTY
54064: LIST
54065: LIST
54066: PUSH
54067: LD_INT 30
54069: PUSH
54070: LD_INT 1
54072: PUSH
54073: EMPTY
54074: LIST
54075: LIST
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: LIST
54081: PPUSH
54082: CALL_OW 72
54086: ST_TO_ADDR
// if depot then
54087: LD_VAR 0 6
54091: IFFALSE 54248
// begin selected := 0 ;
54093: LD_ADDR_VAR 0 7
54097: PUSH
54098: LD_INT 0
54100: ST_TO_ADDR
// for j in depot do
54101: LD_ADDR_VAR 0 3
54105: PUSH
54106: LD_VAR 0 6
54110: PUSH
54111: FOR_IN
54112: IFFALSE 54143
// begin if UnitsInside ( j ) < 6 then
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 313
54123: PUSH
54124: LD_INT 6
54126: LESS
54127: IFFALSE 54141
// begin selected := j ;
54129: LD_ADDR_VAR 0 7
54133: PUSH
54134: LD_VAR 0 3
54138: ST_TO_ADDR
// break ;
54139: GO 54143
// end ; end ;
54141: GO 54111
54143: POP
54144: POP
// if selected then
54145: LD_VAR 0 7
54149: IFFALSE 54248
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54151: LD_ADDR_VAR 0 3
54155: PUSH
54156: LD_EXP 131
54160: PUSH
54161: LD_VAR 0 2
54165: ARRAY
54166: PPUSH
54167: LD_INT 25
54169: PUSH
54170: LD_INT 12
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: PPUSH
54177: CALL_OW 72
54181: PUSH
54182: FOR_IN
54183: IFFALSE 54246
// if not HasTask ( j ) then
54185: LD_VAR 0 3
54189: PPUSH
54190: CALL_OW 314
54194: NOT
54195: IFFALSE 54244
// begin if not IsInUnit ( j ) then
54197: LD_VAR 0 3
54201: PPUSH
54202: CALL_OW 310
54206: NOT
54207: IFFALSE 54223
// ComEnterUnit ( j , selected ) ;
54209: LD_VAR 0 3
54213: PPUSH
54214: LD_VAR 0 7
54218: PPUSH
54219: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54223: LD_VAR 0 3
54227: PPUSH
54228: LD_INT 16
54230: PPUSH
54231: CALL_OW 183
// AddComExitBuilding ( j ) ;
54235: LD_VAR 0 3
54239: PPUSH
54240: CALL_OW 182
// end ;
54244: GO 54182
54246: POP
54247: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54248: LD_VAR 0 5
54252: PPUSH
54253: LD_INT 11
54255: PPUSH
54256: CALL_OW 325
54260: IFFALSE 54519
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54262: LD_ADDR_VAR 0 4
54266: PUSH
54267: LD_EXP 131
54271: PUSH
54272: LD_VAR 0 2
54276: ARRAY
54277: PPUSH
54278: LD_INT 25
54280: PUSH
54281: LD_INT 16
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: PPUSH
54288: CALL_OW 72
54292: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54293: LD_VAR 0 4
54297: PUSH
54298: LD_INT 6
54300: GREATEREQUAL
54301: PUSH
54302: LD_VAR 0 5
54306: PPUSH
54307: LD_INT 2
54309: PPUSH
54310: CALL_OW 325
54314: NOT
54315: OR
54316: IFFALSE 54519
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54318: LD_ADDR_VAR 0 8
54322: PUSH
54323: LD_EXP 102
54327: PUSH
54328: LD_VAR 0 2
54332: ARRAY
54333: PPUSH
54334: LD_INT 2
54336: PUSH
54337: LD_INT 30
54339: PUSH
54340: LD_INT 4
54342: PUSH
54343: EMPTY
54344: LIST
54345: LIST
54346: PUSH
54347: LD_INT 30
54349: PUSH
54350: LD_INT 5
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: PPUSH
54362: CALL_OW 72
54366: ST_TO_ADDR
// if barracks then
54367: LD_VAR 0 8
54371: IFFALSE 54519
// begin selected := 0 ;
54373: LD_ADDR_VAR 0 7
54377: PUSH
54378: LD_INT 0
54380: ST_TO_ADDR
// for j in barracks do
54381: LD_ADDR_VAR 0 3
54385: PUSH
54386: LD_VAR 0 8
54390: PUSH
54391: FOR_IN
54392: IFFALSE 54423
// begin if UnitsInside ( j ) < 6 then
54394: LD_VAR 0 3
54398: PPUSH
54399: CALL_OW 313
54403: PUSH
54404: LD_INT 6
54406: LESS
54407: IFFALSE 54421
// begin selected := j ;
54409: LD_ADDR_VAR 0 7
54413: PUSH
54414: LD_VAR 0 3
54418: ST_TO_ADDR
// break ;
54419: GO 54423
// end ; end ;
54421: GO 54391
54423: POP
54424: POP
// if selected then
54425: LD_VAR 0 7
54429: IFFALSE 54519
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54431: LD_ADDR_VAR 0 3
54435: PUSH
54436: LD_EXP 131
54440: PUSH
54441: LD_VAR 0 2
54445: ARRAY
54446: PPUSH
54447: LD_INT 25
54449: PUSH
54450: LD_INT 12
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: PPUSH
54457: CALL_OW 72
54461: PUSH
54462: FOR_IN
54463: IFFALSE 54517
// if not IsInUnit ( j ) and not HasTask ( j ) then
54465: LD_VAR 0 3
54469: PPUSH
54470: CALL_OW 310
54474: NOT
54475: PUSH
54476: LD_VAR 0 3
54480: PPUSH
54481: CALL_OW 314
54485: NOT
54486: AND
54487: IFFALSE 54515
// begin ComEnterUnit ( j , selected ) ;
54489: LD_VAR 0 3
54493: PPUSH
54494: LD_VAR 0 7
54498: PPUSH
54499: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54503: LD_VAR 0 3
54507: PPUSH
54508: LD_INT 15
54510: PPUSH
54511: CALL_OW 183
// end ;
54515: GO 54462
54517: POP
54518: POP
// end ; end ; end ; end ; end ;
54519: GO 53912
54521: POP
54522: POP
// end ;
54523: LD_VAR 0 1
54527: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54528: LD_INT 0
54530: PPUSH
54531: PPUSH
54532: PPUSH
54533: PPUSH
// if not mc_bases then
54534: LD_EXP 102
54538: NOT
54539: IFFALSE 54543
// exit ;
54541: GO 54721
// for i = 1 to mc_bases do
54543: LD_ADDR_VAR 0 2
54547: PUSH
54548: DOUBLE
54549: LD_INT 1
54551: DEC
54552: ST_TO_ADDR
54553: LD_EXP 102
54557: PUSH
54558: FOR_TO
54559: IFFALSE 54719
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54561: LD_ADDR_VAR 0 4
54565: PUSH
54566: LD_EXP 102
54570: PUSH
54571: LD_VAR 0 2
54575: ARRAY
54576: PPUSH
54577: LD_INT 25
54579: PUSH
54580: LD_INT 9
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: PPUSH
54587: CALL_OW 72
54591: ST_TO_ADDR
// if not tmp then
54592: LD_VAR 0 4
54596: NOT
54597: IFFALSE 54601
// continue ;
54599: GO 54558
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54601: LD_EXP 128
54605: PUSH
54606: LD_VAR 0 2
54610: ARRAY
54611: PPUSH
54612: LD_INT 29
54614: PPUSH
54615: CALL_OW 325
54619: NOT
54620: PUSH
54621: LD_EXP 128
54625: PUSH
54626: LD_VAR 0 2
54630: ARRAY
54631: PPUSH
54632: LD_INT 28
54634: PPUSH
54635: CALL_OW 325
54639: NOT
54640: AND
54641: IFFALSE 54645
// continue ;
54643: GO 54558
// for j in tmp do
54645: LD_ADDR_VAR 0 3
54649: PUSH
54650: LD_VAR 0 4
54654: PUSH
54655: FOR_IN
54656: IFFALSE 54715
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54658: LD_VAR 0 3
54662: PUSH
54663: LD_EXP 105
54667: PUSH
54668: LD_VAR 0 2
54672: ARRAY
54673: PUSH
54674: LD_INT 1
54676: ARRAY
54677: IN
54678: NOT
54679: PUSH
54680: LD_VAR 0 3
54684: PUSH
54685: LD_EXP 105
54689: PUSH
54690: LD_VAR 0 2
54694: ARRAY
54695: PUSH
54696: LD_INT 2
54698: ARRAY
54699: IN
54700: NOT
54701: AND
54702: IFFALSE 54713
// ComSpaceTimeShoot ( j ) ;
54704: LD_VAR 0 3
54708: PPUSH
54709: CALL 65799 0 1
54713: GO 54655
54715: POP
54716: POP
// end ;
54717: GO 54558
54719: POP
54720: POP
// end ;
54721: LD_VAR 0 1
54725: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54726: LD_INT 0
54728: PPUSH
54729: PPUSH
54730: PPUSH
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
54735: PPUSH
54736: PPUSH
// if not mc_bases then
54737: LD_EXP 102
54741: NOT
54742: IFFALSE 54746
// exit ;
54744: GO 55368
// for i = 1 to mc_bases do
54746: LD_ADDR_VAR 0 2
54750: PUSH
54751: DOUBLE
54752: LD_INT 1
54754: DEC
54755: ST_TO_ADDR
54756: LD_EXP 102
54760: PUSH
54761: FOR_TO
54762: IFFALSE 55366
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54764: LD_EXP 137
54768: PUSH
54769: LD_VAR 0 2
54773: ARRAY
54774: NOT
54775: PUSH
54776: LD_INT 38
54778: PPUSH
54779: LD_EXP 128
54783: PUSH
54784: LD_VAR 0 2
54788: ARRAY
54789: PPUSH
54790: CALL_OW 321
54794: PUSH
54795: LD_INT 2
54797: NONEQUAL
54798: OR
54799: IFFALSE 54803
// continue ;
54801: GO 54761
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54803: LD_ADDR_VAR 0 8
54807: PUSH
54808: LD_EXP 102
54812: PUSH
54813: LD_VAR 0 2
54817: ARRAY
54818: PPUSH
54819: LD_INT 30
54821: PUSH
54822: LD_INT 34
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PPUSH
54829: CALL_OW 72
54833: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54834: LD_ADDR_VAR 0 9
54838: PUSH
54839: LD_EXP 102
54843: PUSH
54844: LD_VAR 0 2
54848: ARRAY
54849: PPUSH
54850: LD_INT 25
54852: PUSH
54853: LD_INT 4
54855: PUSH
54856: EMPTY
54857: LIST
54858: LIST
54859: PPUSH
54860: CALL_OW 72
54864: PPUSH
54865: LD_INT 0
54867: PPUSH
54868: CALL 105483 0 2
54872: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54873: LD_VAR 0 9
54877: NOT
54878: PUSH
54879: LD_VAR 0 8
54883: NOT
54884: OR
54885: PUSH
54886: LD_EXP 102
54890: PUSH
54891: LD_VAR 0 2
54895: ARRAY
54896: PPUSH
54897: LD_INT 124
54899: PPUSH
54900: CALL 105483 0 2
54904: OR
54905: IFFALSE 54909
// continue ;
54907: GO 54761
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54909: LD_EXP 138
54913: PUSH
54914: LD_VAR 0 2
54918: ARRAY
54919: PUSH
54920: LD_EXP 137
54924: PUSH
54925: LD_VAR 0 2
54929: ARRAY
54930: LESS
54931: PUSH
54932: LD_EXP 138
54936: PUSH
54937: LD_VAR 0 2
54941: ARRAY
54942: PUSH
54943: LD_VAR 0 8
54947: LESS
54948: AND
54949: IFFALSE 55364
// begin tmp := sci [ 1 ] ;
54951: LD_ADDR_VAR 0 7
54955: PUSH
54956: LD_VAR 0 9
54960: PUSH
54961: LD_INT 1
54963: ARRAY
54964: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54965: LD_VAR 0 7
54969: PPUSH
54970: LD_INT 124
54972: PPUSH
54973: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54977: LD_ADDR_VAR 0 3
54981: PUSH
54982: DOUBLE
54983: LD_EXP 137
54987: PUSH
54988: LD_VAR 0 2
54992: ARRAY
54993: INC
54994: ST_TO_ADDR
54995: LD_EXP 137
54999: PUSH
55000: LD_VAR 0 2
55004: ARRAY
55005: PUSH
55006: FOR_DOWNTO
55007: IFFALSE 55350
// begin if IsInUnit ( tmp ) then
55009: LD_VAR 0 7
55013: PPUSH
55014: CALL_OW 310
55018: IFFALSE 55029
// ComExitBuilding ( tmp ) ;
55020: LD_VAR 0 7
55024: PPUSH
55025: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55029: LD_INT 35
55031: PPUSH
55032: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55036: LD_VAR 0 7
55040: PPUSH
55041: CALL_OW 310
55045: NOT
55046: PUSH
55047: LD_VAR 0 7
55051: PPUSH
55052: CALL_OW 314
55056: NOT
55057: AND
55058: IFFALSE 55029
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55060: LD_ADDR_VAR 0 6
55064: PUSH
55065: LD_VAR 0 7
55069: PPUSH
55070: CALL_OW 250
55074: PUSH
55075: LD_VAR 0 7
55079: PPUSH
55080: CALL_OW 251
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55089: LD_INT 35
55091: PPUSH
55092: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55096: LD_ADDR_VAR 0 4
55100: PUSH
55101: LD_EXP 137
55105: PUSH
55106: LD_VAR 0 2
55110: ARRAY
55111: PUSH
55112: LD_VAR 0 3
55116: ARRAY
55117: PUSH
55118: LD_INT 1
55120: ARRAY
55121: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55122: LD_ADDR_VAR 0 5
55126: PUSH
55127: LD_EXP 137
55131: PUSH
55132: LD_VAR 0 2
55136: ARRAY
55137: PUSH
55138: LD_VAR 0 3
55142: ARRAY
55143: PUSH
55144: LD_INT 2
55146: ARRAY
55147: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55148: LD_VAR 0 7
55152: PPUSH
55153: LD_INT 10
55155: PPUSH
55156: CALL 74806 0 2
55160: PUSH
55161: LD_INT 4
55163: ARRAY
55164: IFFALSE 55202
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55166: LD_VAR 0 7
55170: PPUSH
55171: LD_VAR 0 6
55175: PUSH
55176: LD_INT 1
55178: ARRAY
55179: PPUSH
55180: LD_VAR 0 6
55184: PUSH
55185: LD_INT 2
55187: ARRAY
55188: PPUSH
55189: CALL_OW 111
// wait ( 0 0$10 ) ;
55193: LD_INT 350
55195: PPUSH
55196: CALL_OW 67
// end else
55200: GO 55228
// begin ComMoveXY ( tmp , x , y ) ;
55202: LD_VAR 0 7
55206: PPUSH
55207: LD_VAR 0 4
55211: PPUSH
55212: LD_VAR 0 5
55216: PPUSH
55217: CALL_OW 111
// wait ( 0 0$3 ) ;
55221: LD_INT 105
55223: PPUSH
55224: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55228: LD_VAR 0 7
55232: PPUSH
55233: LD_VAR 0 4
55237: PPUSH
55238: LD_VAR 0 5
55242: PPUSH
55243: CALL_OW 307
55247: IFFALSE 55089
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55249: LD_VAR 0 7
55253: PPUSH
55254: LD_VAR 0 4
55258: PPUSH
55259: LD_VAR 0 5
55263: PPUSH
55264: LD_VAR 0 8
55268: PUSH
55269: LD_VAR 0 3
55273: ARRAY
55274: PPUSH
55275: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55279: LD_INT 35
55281: PPUSH
55282: CALL_OW 67
// until not HasTask ( tmp ) ;
55286: LD_VAR 0 7
55290: PPUSH
55291: CALL_OW 314
55295: NOT
55296: IFFALSE 55279
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55298: LD_ADDR_EXP 138
55302: PUSH
55303: LD_EXP 138
55307: PPUSH
55308: LD_VAR 0 2
55312: PUSH
55313: LD_EXP 138
55317: PUSH
55318: LD_VAR 0 2
55322: ARRAY
55323: PUSH
55324: LD_INT 1
55326: PLUS
55327: PUSH
55328: EMPTY
55329: LIST
55330: LIST
55331: PPUSH
55332: LD_VAR 0 8
55336: PUSH
55337: LD_VAR 0 3
55341: ARRAY
55342: PPUSH
55343: CALL 72213 0 3
55347: ST_TO_ADDR
// end ;
55348: GO 55006
55350: POP
55351: POP
// MC_Reset ( i , 124 ) ;
55352: LD_VAR 0 2
55356: PPUSH
55357: LD_INT 124
55359: PPUSH
55360: CALL 38955 0 2
// end ; end ;
55364: GO 54761
55366: POP
55367: POP
// end ;
55368: LD_VAR 0 1
55372: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55373: LD_INT 0
55375: PPUSH
55376: PPUSH
55377: PPUSH
// if not mc_bases then
55378: LD_EXP 102
55382: NOT
55383: IFFALSE 55387
// exit ;
55385: GO 55993
// for i = 1 to mc_bases do
55387: LD_ADDR_VAR 0 2
55391: PUSH
55392: DOUBLE
55393: LD_INT 1
55395: DEC
55396: ST_TO_ADDR
55397: LD_EXP 102
55401: PUSH
55402: FOR_TO
55403: IFFALSE 55991
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55405: LD_ADDR_VAR 0 3
55409: PUSH
55410: LD_EXP 102
55414: PUSH
55415: LD_VAR 0 2
55419: ARRAY
55420: PPUSH
55421: LD_INT 25
55423: PUSH
55424: LD_INT 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PPUSH
55431: CALL_OW 72
55435: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55436: LD_VAR 0 3
55440: NOT
55441: PUSH
55442: LD_EXP 139
55446: PUSH
55447: LD_VAR 0 2
55451: ARRAY
55452: NOT
55453: OR
55454: PUSH
55455: LD_EXP 102
55459: PUSH
55460: LD_VAR 0 2
55464: ARRAY
55465: PPUSH
55466: LD_INT 2
55468: PUSH
55469: LD_INT 30
55471: PUSH
55472: LD_INT 0
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: LD_INT 30
55481: PUSH
55482: LD_INT 1
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: EMPTY
55490: LIST
55491: LIST
55492: LIST
55493: PPUSH
55494: CALL_OW 72
55498: NOT
55499: OR
55500: IFFALSE 55550
// begin if mc_deposits_finder [ i ] then
55502: LD_EXP 140
55506: PUSH
55507: LD_VAR 0 2
55511: ARRAY
55512: IFFALSE 55548
// begin MC_Reset ( i , 125 ) ;
55514: LD_VAR 0 2
55518: PPUSH
55519: LD_INT 125
55521: PPUSH
55522: CALL 38955 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55526: LD_ADDR_EXP 140
55530: PUSH
55531: LD_EXP 140
55535: PPUSH
55536: LD_VAR 0 2
55540: PPUSH
55541: EMPTY
55542: PPUSH
55543: CALL_OW 1
55547: ST_TO_ADDR
// end ; continue ;
55548: GO 55402
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55550: LD_EXP 139
55554: PUSH
55555: LD_VAR 0 2
55559: ARRAY
55560: PUSH
55561: LD_INT 1
55563: ARRAY
55564: PUSH
55565: LD_INT 3
55567: ARRAY
55568: PUSH
55569: LD_INT 1
55571: EQUAL
55572: PUSH
55573: LD_INT 20
55575: PPUSH
55576: LD_EXP 128
55580: PUSH
55581: LD_VAR 0 2
55585: ARRAY
55586: PPUSH
55587: CALL_OW 321
55591: PUSH
55592: LD_INT 2
55594: NONEQUAL
55595: AND
55596: IFFALSE 55646
// begin if mc_deposits_finder [ i ] then
55598: LD_EXP 140
55602: PUSH
55603: LD_VAR 0 2
55607: ARRAY
55608: IFFALSE 55644
// begin MC_Reset ( i , 125 ) ;
55610: LD_VAR 0 2
55614: PPUSH
55615: LD_INT 125
55617: PPUSH
55618: CALL 38955 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55622: LD_ADDR_EXP 140
55626: PUSH
55627: LD_EXP 140
55631: PPUSH
55632: LD_VAR 0 2
55636: PPUSH
55637: EMPTY
55638: PPUSH
55639: CALL_OW 1
55643: ST_TO_ADDR
// end ; continue ;
55644: GO 55402
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55646: LD_EXP 139
55650: PUSH
55651: LD_VAR 0 2
55655: ARRAY
55656: PUSH
55657: LD_INT 1
55659: ARRAY
55660: PUSH
55661: LD_INT 1
55663: ARRAY
55664: PPUSH
55665: LD_EXP 139
55669: PUSH
55670: LD_VAR 0 2
55674: ARRAY
55675: PUSH
55676: LD_INT 1
55678: ARRAY
55679: PUSH
55680: LD_INT 2
55682: ARRAY
55683: PPUSH
55684: LD_EXP 128
55688: PUSH
55689: LD_VAR 0 2
55693: ARRAY
55694: PPUSH
55695: CALL_OW 440
55699: IFFALSE 55742
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55701: LD_ADDR_EXP 139
55705: PUSH
55706: LD_EXP 139
55710: PPUSH
55711: LD_VAR 0 2
55715: PPUSH
55716: LD_EXP 139
55720: PUSH
55721: LD_VAR 0 2
55725: ARRAY
55726: PPUSH
55727: LD_INT 1
55729: PPUSH
55730: CALL_OW 3
55734: PPUSH
55735: CALL_OW 1
55739: ST_TO_ADDR
55740: GO 55989
// begin if not mc_deposits_finder [ i ] then
55742: LD_EXP 140
55746: PUSH
55747: LD_VAR 0 2
55751: ARRAY
55752: NOT
55753: IFFALSE 55805
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55755: LD_ADDR_EXP 140
55759: PUSH
55760: LD_EXP 140
55764: PPUSH
55765: LD_VAR 0 2
55769: PPUSH
55770: LD_VAR 0 3
55774: PUSH
55775: LD_INT 1
55777: ARRAY
55778: PUSH
55779: EMPTY
55780: LIST
55781: PPUSH
55782: CALL_OW 1
55786: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55787: LD_VAR 0 3
55791: PUSH
55792: LD_INT 1
55794: ARRAY
55795: PPUSH
55796: LD_INT 125
55798: PPUSH
55799: CALL_OW 109
// end else
55803: GO 55989
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55805: LD_EXP 140
55809: PUSH
55810: LD_VAR 0 2
55814: ARRAY
55815: PUSH
55816: LD_INT 1
55818: ARRAY
55819: PPUSH
55820: CALL_OW 310
55824: IFFALSE 55847
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55826: LD_EXP 140
55830: PUSH
55831: LD_VAR 0 2
55835: ARRAY
55836: PUSH
55837: LD_INT 1
55839: ARRAY
55840: PPUSH
55841: CALL_OW 122
55845: GO 55989
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55847: LD_EXP 140
55851: PUSH
55852: LD_VAR 0 2
55856: ARRAY
55857: PUSH
55858: LD_INT 1
55860: ARRAY
55861: PPUSH
55862: CALL_OW 314
55866: NOT
55867: PUSH
55868: LD_EXP 140
55872: PUSH
55873: LD_VAR 0 2
55877: ARRAY
55878: PUSH
55879: LD_INT 1
55881: ARRAY
55882: PPUSH
55883: LD_EXP 139
55887: PUSH
55888: LD_VAR 0 2
55892: ARRAY
55893: PUSH
55894: LD_INT 1
55896: ARRAY
55897: PUSH
55898: LD_INT 1
55900: ARRAY
55901: PPUSH
55902: LD_EXP 139
55906: PUSH
55907: LD_VAR 0 2
55911: ARRAY
55912: PUSH
55913: LD_INT 1
55915: ARRAY
55916: PUSH
55917: LD_INT 2
55919: ARRAY
55920: PPUSH
55921: CALL_OW 297
55925: PUSH
55926: LD_INT 6
55928: GREATER
55929: AND
55930: IFFALSE 55989
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55932: LD_EXP 140
55936: PUSH
55937: LD_VAR 0 2
55941: ARRAY
55942: PUSH
55943: LD_INT 1
55945: ARRAY
55946: PPUSH
55947: LD_EXP 139
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: PUSH
55958: LD_INT 1
55960: ARRAY
55961: PUSH
55962: LD_INT 1
55964: ARRAY
55965: PPUSH
55966: LD_EXP 139
55970: PUSH
55971: LD_VAR 0 2
55975: ARRAY
55976: PUSH
55977: LD_INT 1
55979: ARRAY
55980: PUSH
55981: LD_INT 2
55983: ARRAY
55984: PPUSH
55985: CALL_OW 111
// end ; end ; end ;
55989: GO 55402
55991: POP
55992: POP
// end ;
55993: LD_VAR 0 1
55997: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55998: LD_INT 0
56000: PPUSH
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
56005: PPUSH
56006: PPUSH
56007: PPUSH
56008: PPUSH
56009: PPUSH
56010: PPUSH
// if not mc_bases then
56011: LD_EXP 102
56015: NOT
56016: IFFALSE 56020
// exit ;
56018: GO 56960
// for i = 1 to mc_bases do
56020: LD_ADDR_VAR 0 2
56024: PUSH
56025: DOUBLE
56026: LD_INT 1
56028: DEC
56029: ST_TO_ADDR
56030: LD_EXP 102
56034: PUSH
56035: FOR_TO
56036: IFFALSE 56958
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56038: LD_EXP 102
56042: PUSH
56043: LD_VAR 0 2
56047: ARRAY
56048: NOT
56049: PUSH
56050: LD_EXP 125
56054: PUSH
56055: LD_VAR 0 2
56059: ARRAY
56060: OR
56061: IFFALSE 56065
// continue ;
56063: GO 56035
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56065: LD_ADDR_VAR 0 7
56069: PUSH
56070: LD_EXP 102
56074: PUSH
56075: LD_VAR 0 2
56079: ARRAY
56080: PUSH
56081: LD_INT 1
56083: ARRAY
56084: PPUSH
56085: CALL_OW 248
56089: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56090: LD_VAR 0 7
56094: PUSH
56095: LD_INT 3
56097: EQUAL
56098: PUSH
56099: LD_EXP 121
56103: PUSH
56104: LD_VAR 0 2
56108: ARRAY
56109: PUSH
56110: LD_EXP 124
56114: PUSH
56115: LD_VAR 0 2
56119: ARRAY
56120: UNION
56121: PPUSH
56122: LD_INT 33
56124: PUSH
56125: LD_INT 2
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: PPUSH
56132: CALL_OW 72
56136: NOT
56137: OR
56138: IFFALSE 56142
// continue ;
56140: GO 56035
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56142: LD_ADDR_VAR 0 9
56146: PUSH
56147: LD_EXP 102
56151: PUSH
56152: LD_VAR 0 2
56156: ARRAY
56157: PPUSH
56158: LD_INT 30
56160: PUSH
56161: LD_INT 36
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: PPUSH
56168: CALL_OW 72
56172: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56173: LD_ADDR_VAR 0 10
56177: PUSH
56178: LD_EXP 121
56182: PUSH
56183: LD_VAR 0 2
56187: ARRAY
56188: PPUSH
56189: LD_INT 34
56191: PUSH
56192: LD_INT 31
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: PPUSH
56199: CALL_OW 72
56203: ST_TO_ADDR
// if not cts and not mcts then
56204: LD_VAR 0 9
56208: NOT
56209: PUSH
56210: LD_VAR 0 10
56214: NOT
56215: AND
56216: IFFALSE 56220
// continue ;
56218: GO 56035
// x := cts ;
56220: LD_ADDR_VAR 0 11
56224: PUSH
56225: LD_VAR 0 9
56229: ST_TO_ADDR
// if not x then
56230: LD_VAR 0 11
56234: NOT
56235: IFFALSE 56247
// x := mcts ;
56237: LD_ADDR_VAR 0 11
56241: PUSH
56242: LD_VAR 0 10
56246: ST_TO_ADDR
// if not x then
56247: LD_VAR 0 11
56251: NOT
56252: IFFALSE 56256
// continue ;
56254: GO 56035
// if mc_remote_driver [ i ] then
56256: LD_EXP 142
56260: PUSH
56261: LD_VAR 0 2
56265: ARRAY
56266: IFFALSE 56653
// for j in mc_remote_driver [ i ] do
56268: LD_ADDR_VAR 0 3
56272: PUSH
56273: LD_EXP 142
56277: PUSH
56278: LD_VAR 0 2
56282: ARRAY
56283: PUSH
56284: FOR_IN
56285: IFFALSE 56651
// begin if GetClass ( j ) <> 3 then
56287: LD_VAR 0 3
56291: PPUSH
56292: CALL_OW 257
56296: PUSH
56297: LD_INT 3
56299: NONEQUAL
56300: IFFALSE 56353
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56302: LD_ADDR_EXP 142
56306: PUSH
56307: LD_EXP 142
56311: PPUSH
56312: LD_VAR 0 2
56316: PPUSH
56317: LD_EXP 142
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: PUSH
56328: LD_VAR 0 3
56332: DIFF
56333: PPUSH
56334: CALL_OW 1
56338: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56339: LD_VAR 0 3
56343: PPUSH
56344: LD_INT 0
56346: PPUSH
56347: CALL_OW 109
// continue ;
56351: GO 56284
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56353: LD_EXP 121
56357: PUSH
56358: LD_VAR 0 2
56362: ARRAY
56363: PPUSH
56364: LD_INT 34
56366: PUSH
56367: LD_INT 31
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: PUSH
56374: LD_INT 58
56376: PUSH
56377: EMPTY
56378: LIST
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: PPUSH
56384: CALL_OW 72
56388: PUSH
56389: LD_VAR 0 3
56393: PPUSH
56394: CALL 105571 0 1
56398: NOT
56399: AND
56400: IFFALSE 56471
// begin if IsInUnit ( j ) then
56402: LD_VAR 0 3
56406: PPUSH
56407: CALL_OW 310
56411: IFFALSE 56422
// ComExitBuilding ( j ) ;
56413: LD_VAR 0 3
56417: PPUSH
56418: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56422: LD_VAR 0 3
56426: PPUSH
56427: LD_EXP 121
56431: PUSH
56432: LD_VAR 0 2
56436: ARRAY
56437: PPUSH
56438: LD_INT 34
56440: PUSH
56441: LD_INT 31
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 58
56450: PUSH
56451: EMPTY
56452: LIST
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PPUSH
56458: CALL_OW 72
56462: PUSH
56463: LD_INT 1
56465: ARRAY
56466: PPUSH
56467: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56471: LD_VAR 0 3
56475: PPUSH
56476: CALL_OW 310
56480: NOT
56481: PUSH
56482: LD_VAR 0 3
56486: PPUSH
56487: CALL_OW 310
56491: PPUSH
56492: CALL_OW 266
56496: PUSH
56497: LD_INT 36
56499: NONEQUAL
56500: PUSH
56501: LD_VAR 0 3
56505: PPUSH
56506: CALL 105571 0 1
56510: NOT
56511: AND
56512: OR
56513: IFFALSE 56649
// begin if IsInUnit ( j ) then
56515: LD_VAR 0 3
56519: PPUSH
56520: CALL_OW 310
56524: IFFALSE 56535
// ComExitBuilding ( j ) ;
56526: LD_VAR 0 3
56530: PPUSH
56531: CALL_OW 122
// ct := 0 ;
56535: LD_ADDR_VAR 0 8
56539: PUSH
56540: LD_INT 0
56542: ST_TO_ADDR
// for k in x do
56543: LD_ADDR_VAR 0 4
56547: PUSH
56548: LD_VAR 0 11
56552: PUSH
56553: FOR_IN
56554: IFFALSE 56627
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56556: LD_VAR 0 4
56560: PPUSH
56561: CALL_OW 264
56565: PUSH
56566: LD_INT 31
56568: EQUAL
56569: PUSH
56570: LD_VAR 0 4
56574: PPUSH
56575: CALL_OW 311
56579: NOT
56580: AND
56581: PUSH
56582: LD_VAR 0 4
56586: PPUSH
56587: CALL_OW 266
56591: PUSH
56592: LD_INT 36
56594: EQUAL
56595: PUSH
56596: LD_VAR 0 4
56600: PPUSH
56601: CALL_OW 313
56605: PUSH
56606: LD_INT 3
56608: LESS
56609: AND
56610: OR
56611: IFFALSE 56625
// begin ct := k ;
56613: LD_ADDR_VAR 0 8
56617: PUSH
56618: LD_VAR 0 4
56622: ST_TO_ADDR
// break ;
56623: GO 56627
// end ;
56625: GO 56553
56627: POP
56628: POP
// if ct then
56629: LD_VAR 0 8
56633: IFFALSE 56649
// ComEnterUnit ( j , ct ) ;
56635: LD_VAR 0 3
56639: PPUSH
56640: LD_VAR 0 8
56644: PPUSH
56645: CALL_OW 120
// end ; end ;
56649: GO 56284
56651: POP
56652: POP
// places := 0 ;
56653: LD_ADDR_VAR 0 5
56657: PUSH
56658: LD_INT 0
56660: ST_TO_ADDR
// for j = 1 to x do
56661: LD_ADDR_VAR 0 3
56665: PUSH
56666: DOUBLE
56667: LD_INT 1
56669: DEC
56670: ST_TO_ADDR
56671: LD_VAR 0 11
56675: PUSH
56676: FOR_TO
56677: IFFALSE 56753
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56679: LD_VAR 0 11
56683: PUSH
56684: LD_VAR 0 3
56688: ARRAY
56689: PPUSH
56690: CALL_OW 264
56694: PUSH
56695: LD_INT 31
56697: EQUAL
56698: IFFALSE 56716
// places := places + 1 else
56700: LD_ADDR_VAR 0 5
56704: PUSH
56705: LD_VAR 0 5
56709: PUSH
56710: LD_INT 1
56712: PLUS
56713: ST_TO_ADDR
56714: GO 56751
// if GetBType ( x [ j ] ) = b_control_tower then
56716: LD_VAR 0 11
56720: PUSH
56721: LD_VAR 0 3
56725: ARRAY
56726: PPUSH
56727: CALL_OW 266
56731: PUSH
56732: LD_INT 36
56734: EQUAL
56735: IFFALSE 56751
// places := places + 3 ;
56737: LD_ADDR_VAR 0 5
56741: PUSH
56742: LD_VAR 0 5
56746: PUSH
56747: LD_INT 3
56749: PLUS
56750: ST_TO_ADDR
56751: GO 56676
56753: POP
56754: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56755: LD_VAR 0 5
56759: PUSH
56760: LD_INT 0
56762: EQUAL
56763: PUSH
56764: LD_VAR 0 5
56768: PUSH
56769: LD_EXP 142
56773: PUSH
56774: LD_VAR 0 2
56778: ARRAY
56779: LESSEQUAL
56780: OR
56781: IFFALSE 56785
// continue ;
56783: GO 56035
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56785: LD_ADDR_VAR 0 6
56789: PUSH
56790: LD_EXP 102
56794: PUSH
56795: LD_VAR 0 2
56799: ARRAY
56800: PPUSH
56801: LD_INT 25
56803: PUSH
56804: LD_INT 3
56806: PUSH
56807: EMPTY
56808: LIST
56809: LIST
56810: PPUSH
56811: CALL_OW 72
56815: PUSH
56816: LD_EXP 142
56820: PUSH
56821: LD_VAR 0 2
56825: ARRAY
56826: DIFF
56827: PPUSH
56828: LD_INT 3
56830: PPUSH
56831: CALL 106471 0 2
56835: ST_TO_ADDR
// for j in tmp do
56836: LD_ADDR_VAR 0 3
56840: PUSH
56841: LD_VAR 0 6
56845: PUSH
56846: FOR_IN
56847: IFFALSE 56882
// if GetTag ( j ) > 0 then
56849: LD_VAR 0 3
56853: PPUSH
56854: CALL_OW 110
56858: PUSH
56859: LD_INT 0
56861: GREATER
56862: IFFALSE 56880
// tmp := tmp diff j ;
56864: LD_ADDR_VAR 0 6
56868: PUSH
56869: LD_VAR 0 6
56873: PUSH
56874: LD_VAR 0 3
56878: DIFF
56879: ST_TO_ADDR
56880: GO 56846
56882: POP
56883: POP
// if not tmp then
56884: LD_VAR 0 6
56888: NOT
56889: IFFALSE 56893
// continue ;
56891: GO 56035
// if places then
56893: LD_VAR 0 5
56897: IFFALSE 56956
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56899: LD_ADDR_EXP 142
56903: PUSH
56904: LD_EXP 142
56908: PPUSH
56909: LD_VAR 0 2
56913: PPUSH
56914: LD_EXP 142
56918: PUSH
56919: LD_VAR 0 2
56923: ARRAY
56924: PUSH
56925: LD_VAR 0 6
56929: PUSH
56930: LD_INT 1
56932: ARRAY
56933: UNION
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56940: LD_VAR 0 6
56944: PUSH
56945: LD_INT 1
56947: ARRAY
56948: PPUSH
56949: LD_INT 126
56951: PPUSH
56952: CALL_OW 109
// end ; end ;
56956: GO 56035
56958: POP
56959: POP
// end ;
56960: LD_VAR 0 1
56964: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56965: LD_INT 0
56967: PPUSH
56968: PPUSH
56969: PPUSH
56970: PPUSH
56971: PPUSH
56972: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56973: LD_VAR 0 1
56977: NOT
56978: PUSH
56979: LD_VAR 0 2
56983: NOT
56984: OR
56985: PUSH
56986: LD_VAR 0 3
56990: NOT
56991: OR
56992: PUSH
56993: LD_VAR 0 4
56997: PUSH
56998: LD_INT 1
57000: PUSH
57001: LD_INT 2
57003: PUSH
57004: LD_INT 3
57006: PUSH
57007: LD_INT 4
57009: PUSH
57010: LD_INT 5
57012: PUSH
57013: LD_INT 8
57015: PUSH
57016: LD_INT 9
57018: PUSH
57019: LD_INT 15
57021: PUSH
57022: LD_INT 16
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: LIST
57029: LIST
57030: LIST
57031: LIST
57032: LIST
57033: LIST
57034: LIST
57035: IN
57036: NOT
57037: OR
57038: IFFALSE 57042
// exit ;
57040: GO 57942
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57042: LD_ADDR_VAR 0 2
57046: PUSH
57047: LD_VAR 0 2
57051: PPUSH
57052: LD_INT 21
57054: PUSH
57055: LD_INT 3
57057: PUSH
57058: EMPTY
57059: LIST
57060: LIST
57061: PUSH
57062: LD_INT 24
57064: PUSH
57065: LD_INT 250
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: PUSH
57072: EMPTY
57073: LIST
57074: LIST
57075: PPUSH
57076: CALL_OW 72
57080: ST_TO_ADDR
// case class of 1 , 15 :
57081: LD_VAR 0 4
57085: PUSH
57086: LD_INT 1
57088: DOUBLE
57089: EQUAL
57090: IFTRUE 57100
57092: LD_INT 15
57094: DOUBLE
57095: EQUAL
57096: IFTRUE 57100
57098: GO 57185
57100: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57101: LD_ADDR_VAR 0 8
57105: PUSH
57106: LD_VAR 0 2
57110: PPUSH
57111: LD_INT 2
57113: PUSH
57114: LD_INT 30
57116: PUSH
57117: LD_INT 32
57119: PUSH
57120: EMPTY
57121: LIST
57122: LIST
57123: PUSH
57124: LD_INT 30
57126: PUSH
57127: LD_INT 31
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: LIST
57138: PPUSH
57139: CALL_OW 72
57143: PUSH
57144: LD_VAR 0 2
57148: PPUSH
57149: LD_INT 2
57151: PUSH
57152: LD_INT 30
57154: PUSH
57155: LD_INT 4
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: PUSH
57162: LD_INT 30
57164: PUSH
57165: LD_INT 5
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: LIST
57176: PPUSH
57177: CALL_OW 72
57181: ADD
57182: ST_TO_ADDR
57183: GO 57431
57185: LD_INT 2
57187: DOUBLE
57188: EQUAL
57189: IFTRUE 57199
57191: LD_INT 16
57193: DOUBLE
57194: EQUAL
57195: IFTRUE 57199
57197: GO 57245
57199: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57200: LD_ADDR_VAR 0 8
57204: PUSH
57205: LD_VAR 0 2
57209: PPUSH
57210: LD_INT 2
57212: PUSH
57213: LD_INT 30
57215: PUSH
57216: LD_INT 0
57218: PUSH
57219: EMPTY
57220: LIST
57221: LIST
57222: PUSH
57223: LD_INT 30
57225: PUSH
57226: LD_INT 1
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: EMPTY
57234: LIST
57235: LIST
57236: LIST
57237: PPUSH
57238: CALL_OW 72
57242: ST_TO_ADDR
57243: GO 57431
57245: LD_INT 3
57247: DOUBLE
57248: EQUAL
57249: IFTRUE 57253
57251: GO 57299
57253: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57254: LD_ADDR_VAR 0 8
57258: PUSH
57259: LD_VAR 0 2
57263: PPUSH
57264: LD_INT 2
57266: PUSH
57267: LD_INT 30
57269: PUSH
57270: LD_INT 2
57272: PUSH
57273: EMPTY
57274: LIST
57275: LIST
57276: PUSH
57277: LD_INT 30
57279: PUSH
57280: LD_INT 3
57282: PUSH
57283: EMPTY
57284: LIST
57285: LIST
57286: PUSH
57287: EMPTY
57288: LIST
57289: LIST
57290: LIST
57291: PPUSH
57292: CALL_OW 72
57296: ST_TO_ADDR
57297: GO 57431
57299: LD_INT 4
57301: DOUBLE
57302: EQUAL
57303: IFTRUE 57307
57305: GO 57364
57307: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57308: LD_ADDR_VAR 0 8
57312: PUSH
57313: LD_VAR 0 2
57317: PPUSH
57318: LD_INT 2
57320: PUSH
57321: LD_INT 30
57323: PUSH
57324: LD_INT 6
57326: PUSH
57327: EMPTY
57328: LIST
57329: LIST
57330: PUSH
57331: LD_INT 30
57333: PUSH
57334: LD_INT 7
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PUSH
57341: LD_INT 30
57343: PUSH
57344: LD_INT 8
57346: PUSH
57347: EMPTY
57348: LIST
57349: LIST
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: LIST
57355: LIST
57356: PPUSH
57357: CALL_OW 72
57361: ST_TO_ADDR
57362: GO 57431
57364: LD_INT 5
57366: DOUBLE
57367: EQUAL
57368: IFTRUE 57384
57370: LD_INT 8
57372: DOUBLE
57373: EQUAL
57374: IFTRUE 57384
57376: LD_INT 9
57378: DOUBLE
57379: EQUAL
57380: IFTRUE 57384
57382: GO 57430
57384: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57385: LD_ADDR_VAR 0 8
57389: PUSH
57390: LD_VAR 0 2
57394: PPUSH
57395: LD_INT 2
57397: PUSH
57398: LD_INT 30
57400: PUSH
57401: LD_INT 4
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: PUSH
57408: LD_INT 30
57410: PUSH
57411: LD_INT 5
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: PUSH
57418: EMPTY
57419: LIST
57420: LIST
57421: LIST
57422: PPUSH
57423: CALL_OW 72
57427: ST_TO_ADDR
57428: GO 57431
57430: POP
// if not tmp then
57431: LD_VAR 0 8
57435: NOT
57436: IFFALSE 57440
// exit ;
57438: GO 57942
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57440: LD_VAR 0 4
57444: PUSH
57445: LD_INT 1
57447: PUSH
57448: LD_INT 15
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: IN
57455: PUSH
57456: LD_EXP 111
57460: PUSH
57461: LD_VAR 0 1
57465: ARRAY
57466: AND
57467: IFFALSE 57623
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57469: LD_ADDR_VAR 0 9
57473: PUSH
57474: LD_EXP 111
57478: PUSH
57479: LD_VAR 0 1
57483: ARRAY
57484: PUSH
57485: LD_INT 1
57487: ARRAY
57488: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57489: LD_VAR 0 9
57493: PUSH
57494: LD_EXP 112
57498: PUSH
57499: LD_VAR 0 1
57503: ARRAY
57504: IN
57505: NOT
57506: IFFALSE 57621
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57508: LD_ADDR_EXP 112
57512: PUSH
57513: LD_EXP 112
57517: PPUSH
57518: LD_VAR 0 1
57522: PUSH
57523: LD_EXP 112
57527: PUSH
57528: LD_VAR 0 1
57532: ARRAY
57533: PUSH
57534: LD_INT 1
57536: PLUS
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PPUSH
57542: LD_VAR 0 9
57546: PPUSH
57547: CALL 72213 0 3
57551: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57552: LD_ADDR_EXP 111
57556: PUSH
57557: LD_EXP 111
57561: PPUSH
57562: LD_VAR 0 1
57566: PPUSH
57567: LD_EXP 111
57571: PUSH
57572: LD_VAR 0 1
57576: ARRAY
57577: PUSH
57578: LD_VAR 0 9
57582: DIFF
57583: PPUSH
57584: CALL_OW 1
57588: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57589: LD_VAR 0 3
57593: PPUSH
57594: LD_EXP 112
57598: PUSH
57599: LD_VAR 0 1
57603: ARRAY
57604: PUSH
57605: LD_EXP 112
57609: PUSH
57610: LD_VAR 0 1
57614: ARRAY
57615: ARRAY
57616: PPUSH
57617: CALL_OW 120
// end ; exit ;
57621: GO 57942
// end ; if tmp > 1 then
57623: LD_VAR 0 8
57627: PUSH
57628: LD_INT 1
57630: GREATER
57631: IFFALSE 57735
// for i = 2 to tmp do
57633: LD_ADDR_VAR 0 6
57637: PUSH
57638: DOUBLE
57639: LD_INT 2
57641: DEC
57642: ST_TO_ADDR
57643: LD_VAR 0 8
57647: PUSH
57648: FOR_TO
57649: IFFALSE 57733
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57651: LD_VAR 0 8
57655: PUSH
57656: LD_VAR 0 6
57660: ARRAY
57661: PPUSH
57662: CALL_OW 461
57666: PUSH
57667: LD_INT 6
57669: EQUAL
57670: IFFALSE 57731
// begin x := tmp [ i ] ;
57672: LD_ADDR_VAR 0 9
57676: PUSH
57677: LD_VAR 0 8
57681: PUSH
57682: LD_VAR 0 6
57686: ARRAY
57687: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57688: LD_ADDR_VAR 0 8
57692: PUSH
57693: LD_VAR 0 8
57697: PPUSH
57698: LD_VAR 0 6
57702: PPUSH
57703: CALL_OW 3
57707: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57708: LD_ADDR_VAR 0 8
57712: PUSH
57713: LD_VAR 0 8
57717: PPUSH
57718: LD_INT 1
57720: PPUSH
57721: LD_VAR 0 9
57725: PPUSH
57726: CALL_OW 2
57730: ST_TO_ADDR
// end ;
57731: GO 57648
57733: POP
57734: POP
// for i in tmp do
57735: LD_ADDR_VAR 0 6
57739: PUSH
57740: LD_VAR 0 8
57744: PUSH
57745: FOR_IN
57746: IFFALSE 57815
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57748: LD_VAR 0 6
57752: PPUSH
57753: CALL_OW 313
57757: PUSH
57758: LD_INT 6
57760: LESS
57761: PUSH
57762: LD_VAR 0 6
57766: PPUSH
57767: CALL_OW 266
57771: PUSH
57772: LD_INT 31
57774: PUSH
57775: LD_INT 32
57777: PUSH
57778: EMPTY
57779: LIST
57780: LIST
57781: IN
57782: NOT
57783: AND
57784: PUSH
57785: LD_VAR 0 6
57789: PPUSH
57790: CALL_OW 313
57794: PUSH
57795: LD_INT 0
57797: EQUAL
57798: OR
57799: IFFALSE 57813
// begin j := i ;
57801: LD_ADDR_VAR 0 7
57805: PUSH
57806: LD_VAR 0 6
57810: ST_TO_ADDR
// break ;
57811: GO 57815
// end ; end ;
57813: GO 57745
57815: POP
57816: POP
// if j then
57817: LD_VAR 0 7
57821: IFFALSE 57839
// ComEnterUnit ( unit , j ) else
57823: LD_VAR 0 3
57827: PPUSH
57828: LD_VAR 0 7
57832: PPUSH
57833: CALL_OW 120
57837: GO 57942
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57839: LD_ADDR_VAR 0 10
57843: PUSH
57844: LD_VAR 0 2
57848: PPUSH
57849: LD_INT 2
57851: PUSH
57852: LD_INT 30
57854: PUSH
57855: LD_INT 0
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: LD_INT 30
57864: PUSH
57865: LD_INT 1
57867: PUSH
57868: EMPTY
57869: LIST
57870: LIST
57871: PUSH
57872: EMPTY
57873: LIST
57874: LIST
57875: LIST
57876: PPUSH
57877: CALL_OW 72
57881: ST_TO_ADDR
// if depot then
57882: LD_VAR 0 10
57886: IFFALSE 57942
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57888: LD_ADDR_VAR 0 10
57892: PUSH
57893: LD_VAR 0 10
57897: PPUSH
57898: LD_VAR 0 3
57902: PPUSH
57903: CALL_OW 74
57907: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57908: LD_VAR 0 3
57912: PPUSH
57913: LD_VAR 0 10
57917: PPUSH
57918: CALL_OW 296
57922: PUSH
57923: LD_INT 10
57925: GREATER
57926: IFFALSE 57942
// ComStandNearbyBuilding ( unit , depot ) ;
57928: LD_VAR 0 3
57932: PPUSH
57933: LD_VAR 0 10
57937: PPUSH
57938: CALL 66416 0 2
// end ; end ; end ;
57942: LD_VAR 0 5
57946: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57947: LD_INT 0
57949: PPUSH
57950: PPUSH
57951: PPUSH
57952: PPUSH
// if not mc_bases then
57953: LD_EXP 102
57957: NOT
57958: IFFALSE 57962
// exit ;
57960: GO 58201
// for i = 1 to mc_bases do
57962: LD_ADDR_VAR 0 2
57966: PUSH
57967: DOUBLE
57968: LD_INT 1
57970: DEC
57971: ST_TO_ADDR
57972: LD_EXP 102
57976: PUSH
57977: FOR_TO
57978: IFFALSE 58199
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57980: LD_ADDR_VAR 0 4
57984: PUSH
57985: LD_EXP 102
57989: PUSH
57990: LD_VAR 0 2
57994: ARRAY
57995: PPUSH
57996: LD_INT 21
57998: PUSH
57999: LD_INT 1
58001: PUSH
58002: EMPTY
58003: LIST
58004: LIST
58005: PPUSH
58006: CALL_OW 72
58010: PUSH
58011: LD_EXP 131
58015: PUSH
58016: LD_VAR 0 2
58020: ARRAY
58021: UNION
58022: ST_TO_ADDR
// if not tmp then
58023: LD_VAR 0 4
58027: NOT
58028: IFFALSE 58032
// continue ;
58030: GO 57977
// for j in tmp do
58032: LD_ADDR_VAR 0 3
58036: PUSH
58037: LD_VAR 0 4
58041: PUSH
58042: FOR_IN
58043: IFFALSE 58195
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58045: LD_VAR 0 3
58049: PPUSH
58050: CALL_OW 110
58054: NOT
58055: PUSH
58056: LD_VAR 0 3
58060: PPUSH
58061: CALL_OW 314
58065: NOT
58066: AND
58067: PUSH
58068: LD_VAR 0 3
58072: PPUSH
58073: CALL_OW 311
58077: NOT
58078: AND
58079: PUSH
58080: LD_VAR 0 3
58084: PPUSH
58085: CALL_OW 310
58089: NOT
58090: AND
58091: PUSH
58092: LD_VAR 0 3
58096: PUSH
58097: LD_EXP 105
58101: PUSH
58102: LD_VAR 0 2
58106: ARRAY
58107: PUSH
58108: LD_INT 1
58110: ARRAY
58111: IN
58112: NOT
58113: AND
58114: PUSH
58115: LD_VAR 0 3
58119: PUSH
58120: LD_EXP 105
58124: PUSH
58125: LD_VAR 0 2
58129: ARRAY
58130: PUSH
58131: LD_INT 2
58133: ARRAY
58134: IN
58135: NOT
58136: AND
58137: PUSH
58138: LD_VAR 0 3
58142: PUSH
58143: LD_EXP 114
58147: PUSH
58148: LD_VAR 0 2
58152: ARRAY
58153: IN
58154: NOT
58155: AND
58156: IFFALSE 58193
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58158: LD_VAR 0 2
58162: PPUSH
58163: LD_EXP 102
58167: PUSH
58168: LD_VAR 0 2
58172: ARRAY
58173: PPUSH
58174: LD_VAR 0 3
58178: PPUSH
58179: LD_VAR 0 3
58183: PPUSH
58184: CALL_OW 257
58188: PPUSH
58189: CALL 56965 0 4
// end ;
58193: GO 58042
58195: POP
58196: POP
// end ;
58197: GO 57977
58199: POP
58200: POP
// end ;
58201: LD_VAR 0 1
58205: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58206: LD_INT 0
58208: PPUSH
58209: PPUSH
58210: PPUSH
58211: PPUSH
58212: PPUSH
58213: PPUSH
// if not mc_bases [ base ] then
58214: LD_EXP 102
58218: PUSH
58219: LD_VAR 0 1
58223: ARRAY
58224: NOT
58225: IFFALSE 58229
// exit ;
58227: GO 58411
// tmp := [ ] ;
58229: LD_ADDR_VAR 0 6
58233: PUSH
58234: EMPTY
58235: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58236: LD_ADDR_VAR 0 7
58240: PUSH
58241: LD_VAR 0 3
58245: PPUSH
58246: LD_INT 0
58248: PPUSH
58249: CALL_OW 517
58253: ST_TO_ADDR
// if not list then
58254: LD_VAR 0 7
58258: NOT
58259: IFFALSE 58263
// exit ;
58261: GO 58411
// for i = 1 to amount do
58263: LD_ADDR_VAR 0 5
58267: PUSH
58268: DOUBLE
58269: LD_INT 1
58271: DEC
58272: ST_TO_ADDR
58273: LD_VAR 0 2
58277: PUSH
58278: FOR_TO
58279: IFFALSE 58359
// begin x := rand ( 1 , list [ 1 ] ) ;
58281: LD_ADDR_VAR 0 8
58285: PUSH
58286: LD_INT 1
58288: PPUSH
58289: LD_VAR 0 7
58293: PUSH
58294: LD_INT 1
58296: ARRAY
58297: PPUSH
58298: CALL_OW 12
58302: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58303: LD_ADDR_VAR 0 6
58307: PUSH
58308: LD_VAR 0 6
58312: PPUSH
58313: LD_VAR 0 5
58317: PPUSH
58318: LD_VAR 0 7
58322: PUSH
58323: LD_INT 1
58325: ARRAY
58326: PUSH
58327: LD_VAR 0 8
58331: ARRAY
58332: PUSH
58333: LD_VAR 0 7
58337: PUSH
58338: LD_INT 2
58340: ARRAY
58341: PUSH
58342: LD_VAR 0 8
58346: ARRAY
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PPUSH
58352: CALL_OW 1
58356: ST_TO_ADDR
// end ;
58357: GO 58278
58359: POP
58360: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58361: LD_ADDR_EXP 115
58365: PUSH
58366: LD_EXP 115
58370: PPUSH
58371: LD_VAR 0 1
58375: PPUSH
58376: LD_VAR 0 6
58380: PPUSH
58381: CALL_OW 1
58385: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58386: LD_ADDR_EXP 117
58390: PUSH
58391: LD_EXP 117
58395: PPUSH
58396: LD_VAR 0 1
58400: PPUSH
58401: LD_VAR 0 3
58405: PPUSH
58406: CALL_OW 1
58410: ST_TO_ADDR
// end ;
58411: LD_VAR 0 4
58415: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58416: LD_INT 0
58418: PPUSH
// if not mc_bases [ base ] then
58419: LD_EXP 102
58423: PUSH
58424: LD_VAR 0 1
58428: ARRAY
58429: NOT
58430: IFFALSE 58434
// exit ;
58432: GO 58459
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58434: LD_ADDR_EXP 107
58438: PUSH
58439: LD_EXP 107
58443: PPUSH
58444: LD_VAR 0 1
58448: PPUSH
58449: LD_VAR 0 2
58453: PPUSH
58454: CALL_OW 1
58458: ST_TO_ADDR
// end ;
58459: LD_VAR 0 3
58463: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58464: LD_INT 0
58466: PPUSH
// if not mc_bases [ base ] then
58467: LD_EXP 102
58471: PUSH
58472: LD_VAR 0 1
58476: ARRAY
58477: NOT
58478: IFFALSE 58482
// exit ;
58480: GO 58519
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58482: LD_ADDR_EXP 107
58486: PUSH
58487: LD_EXP 107
58491: PPUSH
58492: LD_VAR 0 1
58496: PPUSH
58497: LD_EXP 107
58501: PUSH
58502: LD_VAR 0 1
58506: ARRAY
58507: PUSH
58508: LD_VAR 0 2
58512: UNION
58513: PPUSH
58514: CALL_OW 1
58518: ST_TO_ADDR
// end ;
58519: LD_VAR 0 3
58523: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58524: LD_INT 0
58526: PPUSH
// if not mc_bases [ base ] then
58527: LD_EXP 102
58531: PUSH
58532: LD_VAR 0 1
58536: ARRAY
58537: NOT
58538: IFFALSE 58542
// exit ;
58540: GO 58567
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58542: LD_ADDR_EXP 123
58546: PUSH
58547: LD_EXP 123
58551: PPUSH
58552: LD_VAR 0 1
58556: PPUSH
58557: LD_VAR 0 2
58561: PPUSH
58562: CALL_OW 1
58566: ST_TO_ADDR
// end ;
58567: LD_VAR 0 3
58571: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58572: LD_INT 0
58574: PPUSH
// if not mc_bases [ base ] then
58575: LD_EXP 102
58579: PUSH
58580: LD_VAR 0 1
58584: ARRAY
58585: NOT
58586: IFFALSE 58590
// exit ;
58588: GO 58627
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58590: LD_ADDR_EXP 123
58594: PUSH
58595: LD_EXP 123
58599: PPUSH
58600: LD_VAR 0 1
58604: PPUSH
58605: LD_EXP 123
58609: PUSH
58610: LD_VAR 0 1
58614: ARRAY
58615: PUSH
58616: LD_VAR 0 2
58620: ADD
58621: PPUSH
58622: CALL_OW 1
58626: ST_TO_ADDR
// end ;
58627: LD_VAR 0 3
58631: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58632: LD_INT 0
58634: PPUSH
// if not mc_bases [ base ] then
58635: LD_EXP 102
58639: PUSH
58640: LD_VAR 0 1
58644: ARRAY
58645: NOT
58646: IFFALSE 58650
// exit ;
58648: GO 58704
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58650: LD_ADDR_EXP 124
58654: PUSH
58655: LD_EXP 124
58659: PPUSH
58660: LD_VAR 0 1
58664: PPUSH
58665: LD_VAR 0 2
58669: PPUSH
58670: CALL_OW 1
58674: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58675: LD_ADDR_EXP 113
58679: PUSH
58680: LD_EXP 113
58684: PPUSH
58685: LD_VAR 0 1
58689: PPUSH
58690: LD_VAR 0 2
58694: PUSH
58695: LD_INT 0
58697: PLUS
58698: PPUSH
58699: CALL_OW 1
58703: ST_TO_ADDR
// end ;
58704: LD_VAR 0 3
58708: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58709: LD_INT 0
58711: PPUSH
// if not mc_bases [ base ] then
58712: LD_EXP 102
58716: PUSH
58717: LD_VAR 0 1
58721: ARRAY
58722: NOT
58723: IFFALSE 58727
// exit ;
58725: GO 58752
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58727: LD_ADDR_EXP 113
58731: PUSH
58732: LD_EXP 113
58736: PPUSH
58737: LD_VAR 0 1
58741: PPUSH
58742: LD_VAR 0 2
58746: PPUSH
58747: CALL_OW 1
58751: ST_TO_ADDR
// end ;
58752: LD_VAR 0 3
58756: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58757: LD_INT 0
58759: PPUSH
58760: PPUSH
58761: PPUSH
58762: PPUSH
// if not mc_bases [ base ] then
58763: LD_EXP 102
58767: PUSH
58768: LD_VAR 0 1
58772: ARRAY
58773: NOT
58774: IFFALSE 58778
// exit ;
58776: GO 58843
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58778: LD_ADDR_EXP 122
58782: PUSH
58783: LD_EXP 122
58787: PPUSH
58788: LD_VAR 0 1
58792: PUSH
58793: LD_EXP 122
58797: PUSH
58798: LD_VAR 0 1
58802: ARRAY
58803: PUSH
58804: LD_INT 1
58806: PLUS
58807: PUSH
58808: EMPTY
58809: LIST
58810: LIST
58811: PPUSH
58812: LD_VAR 0 1
58816: PUSH
58817: LD_VAR 0 2
58821: PUSH
58822: LD_VAR 0 3
58826: PUSH
58827: LD_VAR 0 4
58831: PUSH
58832: EMPTY
58833: LIST
58834: LIST
58835: LIST
58836: LIST
58837: PPUSH
58838: CALL 72213 0 3
58842: ST_TO_ADDR
// end ;
58843: LD_VAR 0 5
58847: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58848: LD_INT 0
58850: PPUSH
// if not mc_bases [ base ] then
58851: LD_EXP 102
58855: PUSH
58856: LD_VAR 0 1
58860: ARRAY
58861: NOT
58862: IFFALSE 58866
// exit ;
58864: GO 58891
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58866: LD_ADDR_EXP 139
58870: PUSH
58871: LD_EXP 139
58875: PPUSH
58876: LD_VAR 0 1
58880: PPUSH
58881: LD_VAR 0 2
58885: PPUSH
58886: CALL_OW 1
58890: ST_TO_ADDR
// end ;
58891: LD_VAR 0 3
58895: RET
// export function MC_GetMinesField ( base ) ; begin
58896: LD_INT 0
58898: PPUSH
// result := mc_mines [ base ] ;
58899: LD_ADDR_VAR 0 2
58903: PUSH
58904: LD_EXP 115
58908: PUSH
58909: LD_VAR 0 1
58913: ARRAY
58914: ST_TO_ADDR
// end ;
58915: LD_VAR 0 2
58919: RET
// export function MC_GetProduceList ( base ) ; begin
58920: LD_INT 0
58922: PPUSH
// result := mc_produce [ base ] ;
58923: LD_ADDR_VAR 0 2
58927: PUSH
58928: LD_EXP 123
58932: PUSH
58933: LD_VAR 0 1
58937: ARRAY
58938: ST_TO_ADDR
// end ;
58939: LD_VAR 0 2
58943: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58944: LD_INT 0
58946: PPUSH
58947: PPUSH
// if not mc_bases then
58948: LD_EXP 102
58952: NOT
58953: IFFALSE 58957
// exit ;
58955: GO 59022
// if mc_bases [ base ] then
58957: LD_EXP 102
58961: PUSH
58962: LD_VAR 0 1
58966: ARRAY
58967: IFFALSE 59022
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58969: LD_ADDR_VAR 0 3
58973: PUSH
58974: LD_EXP 102
58978: PUSH
58979: LD_VAR 0 1
58983: ARRAY
58984: PPUSH
58985: LD_INT 30
58987: PUSH
58988: LD_VAR 0 2
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PPUSH
58997: CALL_OW 72
59001: ST_TO_ADDR
// if result then
59002: LD_VAR 0 3
59006: IFFALSE 59022
// result := result [ 1 ] ;
59008: LD_ADDR_VAR 0 3
59012: PUSH
59013: LD_VAR 0 3
59017: PUSH
59018: LD_INT 1
59020: ARRAY
59021: ST_TO_ADDR
// end ; end ;
59022: LD_VAR 0 3
59026: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59027: LD_INT 0
59029: PPUSH
59030: PPUSH
// if not mc_bases then
59031: LD_EXP 102
59035: NOT
59036: IFFALSE 59040
// exit ;
59038: GO 59085
// if mc_bases [ base ] then
59040: LD_EXP 102
59044: PUSH
59045: LD_VAR 0 1
59049: ARRAY
59050: IFFALSE 59085
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59052: LD_ADDR_VAR 0 3
59056: PUSH
59057: LD_EXP 102
59061: PUSH
59062: LD_VAR 0 1
59066: ARRAY
59067: PPUSH
59068: LD_INT 30
59070: PUSH
59071: LD_VAR 0 2
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: PPUSH
59080: CALL_OW 72
59084: ST_TO_ADDR
// end ;
59085: LD_VAR 0 3
59089: RET
// export function MC_SetTame ( base , area ) ; begin
59090: LD_INT 0
59092: PPUSH
// if not mc_bases or not base then
59093: LD_EXP 102
59097: NOT
59098: PUSH
59099: LD_VAR 0 1
59103: NOT
59104: OR
59105: IFFALSE 59109
// exit ;
59107: GO 59134
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59109: LD_ADDR_EXP 130
59113: PUSH
59114: LD_EXP 130
59118: PPUSH
59119: LD_VAR 0 1
59123: PPUSH
59124: LD_VAR 0 2
59128: PPUSH
59129: CALL_OW 1
59133: ST_TO_ADDR
// end ;
59134: LD_VAR 0 3
59138: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59139: LD_INT 0
59141: PPUSH
59142: PPUSH
// if not mc_bases or not base then
59143: LD_EXP 102
59147: NOT
59148: PUSH
59149: LD_VAR 0 1
59153: NOT
59154: OR
59155: IFFALSE 59159
// exit ;
59157: GO 59261
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59159: LD_ADDR_VAR 0 4
59163: PUSH
59164: LD_EXP 102
59168: PUSH
59169: LD_VAR 0 1
59173: ARRAY
59174: PPUSH
59175: LD_INT 30
59177: PUSH
59178: LD_VAR 0 2
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: PPUSH
59187: CALL_OW 72
59191: ST_TO_ADDR
// if not tmp then
59192: LD_VAR 0 4
59196: NOT
59197: IFFALSE 59201
// exit ;
59199: GO 59261
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59201: LD_ADDR_EXP 134
59205: PUSH
59206: LD_EXP 134
59210: PPUSH
59211: LD_VAR 0 1
59215: PPUSH
59216: LD_EXP 134
59220: PUSH
59221: LD_VAR 0 1
59225: ARRAY
59226: PPUSH
59227: LD_EXP 134
59231: PUSH
59232: LD_VAR 0 1
59236: ARRAY
59237: PUSH
59238: LD_INT 1
59240: PLUS
59241: PPUSH
59242: LD_VAR 0 4
59246: PUSH
59247: LD_INT 1
59249: ARRAY
59250: PPUSH
59251: CALL_OW 2
59255: PPUSH
59256: CALL_OW 1
59260: ST_TO_ADDR
// end ;
59261: LD_VAR 0 3
59265: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59266: LD_INT 0
59268: PPUSH
59269: PPUSH
// if not mc_bases or not base or not kinds then
59270: LD_EXP 102
59274: NOT
59275: PUSH
59276: LD_VAR 0 1
59280: NOT
59281: OR
59282: PUSH
59283: LD_VAR 0 2
59287: NOT
59288: OR
59289: IFFALSE 59293
// exit ;
59291: GO 59354
// for i in kinds do
59293: LD_ADDR_VAR 0 4
59297: PUSH
59298: LD_VAR 0 2
59302: PUSH
59303: FOR_IN
59304: IFFALSE 59352
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59306: LD_ADDR_EXP 136
59310: PUSH
59311: LD_EXP 136
59315: PPUSH
59316: LD_VAR 0 1
59320: PUSH
59321: LD_EXP 136
59325: PUSH
59326: LD_VAR 0 1
59330: ARRAY
59331: PUSH
59332: LD_INT 1
59334: PLUS
59335: PUSH
59336: EMPTY
59337: LIST
59338: LIST
59339: PPUSH
59340: LD_VAR 0 4
59344: PPUSH
59345: CALL 72213 0 3
59349: ST_TO_ADDR
59350: GO 59303
59352: POP
59353: POP
// end ;
59354: LD_VAR 0 3
59358: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59359: LD_INT 0
59361: PPUSH
// if not mc_bases or not base or not areas then
59362: LD_EXP 102
59366: NOT
59367: PUSH
59368: LD_VAR 0 1
59372: NOT
59373: OR
59374: PUSH
59375: LD_VAR 0 2
59379: NOT
59380: OR
59381: IFFALSE 59385
// exit ;
59383: GO 59410
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59385: LD_ADDR_EXP 120
59389: PUSH
59390: LD_EXP 120
59394: PPUSH
59395: LD_VAR 0 1
59399: PPUSH
59400: LD_VAR 0 2
59404: PPUSH
59405: CALL_OW 1
59409: ST_TO_ADDR
// end ;
59410: LD_VAR 0 3
59414: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59415: LD_INT 0
59417: PPUSH
// if not mc_bases or not base or not teleports_exit then
59418: LD_EXP 102
59422: NOT
59423: PUSH
59424: LD_VAR 0 1
59428: NOT
59429: OR
59430: PUSH
59431: LD_VAR 0 2
59435: NOT
59436: OR
59437: IFFALSE 59441
// exit ;
59439: GO 59466
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59441: LD_ADDR_EXP 137
59445: PUSH
59446: LD_EXP 137
59450: PPUSH
59451: LD_VAR 0 1
59455: PPUSH
59456: LD_VAR 0 2
59460: PPUSH
59461: CALL_OW 1
59465: ST_TO_ADDR
// end ;
59466: LD_VAR 0 3
59470: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59471: LD_INT 0
59473: PPUSH
59474: PPUSH
59475: PPUSH
// if not mc_bases or not base or not ext_list then
59476: LD_EXP 102
59480: NOT
59481: PUSH
59482: LD_VAR 0 1
59486: NOT
59487: OR
59488: PUSH
59489: LD_VAR 0 5
59493: NOT
59494: OR
59495: IFFALSE 59499
// exit ;
59497: GO 59672
// tmp := GetFacExtXYD ( x , y , d ) ;
59499: LD_ADDR_VAR 0 8
59503: PUSH
59504: LD_VAR 0 2
59508: PPUSH
59509: LD_VAR 0 3
59513: PPUSH
59514: LD_VAR 0 4
59518: PPUSH
59519: CALL 105601 0 3
59523: ST_TO_ADDR
// if not tmp then
59524: LD_VAR 0 8
59528: NOT
59529: IFFALSE 59533
// exit ;
59531: GO 59672
// for i in tmp do
59533: LD_ADDR_VAR 0 7
59537: PUSH
59538: LD_VAR 0 8
59542: PUSH
59543: FOR_IN
59544: IFFALSE 59670
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59546: LD_ADDR_EXP 107
59550: PUSH
59551: LD_EXP 107
59555: PPUSH
59556: LD_VAR 0 1
59560: PPUSH
59561: LD_EXP 107
59565: PUSH
59566: LD_VAR 0 1
59570: ARRAY
59571: PPUSH
59572: LD_EXP 107
59576: PUSH
59577: LD_VAR 0 1
59581: ARRAY
59582: PUSH
59583: LD_INT 1
59585: PLUS
59586: PPUSH
59587: LD_VAR 0 5
59591: PUSH
59592: LD_INT 1
59594: ARRAY
59595: PUSH
59596: LD_VAR 0 7
59600: PUSH
59601: LD_INT 1
59603: ARRAY
59604: PUSH
59605: LD_VAR 0 7
59609: PUSH
59610: LD_INT 2
59612: ARRAY
59613: PUSH
59614: LD_VAR 0 7
59618: PUSH
59619: LD_INT 3
59621: ARRAY
59622: PUSH
59623: EMPTY
59624: LIST
59625: LIST
59626: LIST
59627: LIST
59628: PPUSH
59629: CALL_OW 2
59633: PPUSH
59634: CALL_OW 1
59638: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59639: LD_ADDR_VAR 0 5
59643: PUSH
59644: LD_VAR 0 5
59648: PPUSH
59649: LD_INT 1
59651: PPUSH
59652: CALL_OW 3
59656: ST_TO_ADDR
// if not ext_list then
59657: LD_VAR 0 5
59661: NOT
59662: IFFALSE 59668
// exit ;
59664: POP
59665: POP
59666: GO 59672
// end ;
59668: GO 59543
59670: POP
59671: POP
// end ;
59672: LD_VAR 0 6
59676: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59677: LD_INT 0
59679: PPUSH
// if not mc_bases or not base or not weapon_list then
59680: LD_EXP 102
59684: NOT
59685: PUSH
59686: LD_VAR 0 1
59690: NOT
59691: OR
59692: PUSH
59693: LD_VAR 0 2
59697: NOT
59698: OR
59699: IFFALSE 59703
// exit ;
59701: GO 59728
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59703: LD_ADDR_EXP 141
59707: PUSH
59708: LD_EXP 141
59712: PPUSH
59713: LD_VAR 0 1
59717: PPUSH
59718: LD_VAR 0 2
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// end ;
59728: LD_VAR 0 3
59732: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59733: LD_INT 0
59735: PPUSH
// if not mc_bases or not base or not tech_list then
59736: LD_EXP 102
59740: NOT
59741: PUSH
59742: LD_VAR 0 1
59746: NOT
59747: OR
59748: PUSH
59749: LD_VAR 0 2
59753: NOT
59754: OR
59755: IFFALSE 59759
// exit ;
59757: GO 59784
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59759: LD_ADDR_EXP 129
59763: PUSH
59764: LD_EXP 129
59768: PPUSH
59769: LD_VAR 0 1
59773: PPUSH
59774: LD_VAR 0 2
59778: PPUSH
59779: CALL_OW 1
59783: ST_TO_ADDR
// end ;
59784: LD_VAR 0 3
59788: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59789: LD_INT 0
59791: PPUSH
// if not mc_bases or not parking_area or not base then
59792: LD_EXP 102
59796: NOT
59797: PUSH
59798: LD_VAR 0 2
59802: NOT
59803: OR
59804: PUSH
59805: LD_VAR 0 1
59809: NOT
59810: OR
59811: IFFALSE 59815
// exit ;
59813: GO 59840
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59815: LD_ADDR_EXP 126
59819: PUSH
59820: LD_EXP 126
59824: PPUSH
59825: LD_VAR 0 1
59829: PPUSH
59830: LD_VAR 0 2
59834: PPUSH
59835: CALL_OW 1
59839: ST_TO_ADDR
// end ;
59840: LD_VAR 0 3
59844: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59845: LD_INT 0
59847: PPUSH
// if not mc_bases or not base or not scan_area then
59848: LD_EXP 102
59852: NOT
59853: PUSH
59854: LD_VAR 0 1
59858: NOT
59859: OR
59860: PUSH
59861: LD_VAR 0 2
59865: NOT
59866: OR
59867: IFFALSE 59871
// exit ;
59869: GO 59896
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59871: LD_ADDR_EXP 127
59875: PUSH
59876: LD_EXP 127
59880: PPUSH
59881: LD_VAR 0 1
59885: PPUSH
59886: LD_VAR 0 2
59890: PPUSH
59891: CALL_OW 1
59895: ST_TO_ADDR
// end ;
59896: LD_VAR 0 3
59900: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59901: LD_INT 0
59903: PPUSH
59904: PPUSH
// if not mc_bases or not base then
59905: LD_EXP 102
59909: NOT
59910: PUSH
59911: LD_VAR 0 1
59915: NOT
59916: OR
59917: IFFALSE 59921
// exit ;
59919: GO 59985
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59921: LD_ADDR_VAR 0 3
59925: PUSH
59926: LD_INT 1
59928: PUSH
59929: LD_INT 2
59931: PUSH
59932: LD_INT 3
59934: PUSH
59935: LD_INT 4
59937: PUSH
59938: LD_INT 11
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: LIST
59945: LIST
59946: LIST
59947: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59948: LD_ADDR_EXP 129
59952: PUSH
59953: LD_EXP 129
59957: PPUSH
59958: LD_VAR 0 1
59962: PPUSH
59963: LD_EXP 129
59967: PUSH
59968: LD_VAR 0 1
59972: ARRAY
59973: PUSH
59974: LD_VAR 0 3
59978: DIFF
59979: PPUSH
59980: CALL_OW 1
59984: ST_TO_ADDR
// end ;
59985: LD_VAR 0 2
59989: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59990: LD_INT 0
59992: PPUSH
// result := mc_vehicles [ base ] ;
59993: LD_ADDR_VAR 0 3
59997: PUSH
59998: LD_EXP 121
60002: PUSH
60003: LD_VAR 0 1
60007: ARRAY
60008: ST_TO_ADDR
// if onlyCombat then
60009: LD_VAR 0 2
60013: IFFALSE 60178
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_VAR 0 3
60024: PUSH
60025: LD_VAR 0 3
60029: PPUSH
60030: LD_INT 2
60032: PUSH
60033: LD_INT 34
60035: PUSH
60036: LD_INT 12
60038: PUSH
60039: EMPTY
60040: LIST
60041: LIST
60042: PUSH
60043: LD_INT 34
60045: PUSH
60046: LD_INT 51
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 34
60055: PUSH
60056: LD_EXP 96
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: PUSH
60065: LD_INT 34
60067: PUSH
60068: LD_INT 32
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PUSH
60075: LD_INT 34
60077: PUSH
60078: LD_INT 13
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: PUSH
60085: LD_INT 34
60087: PUSH
60088: LD_INT 52
60090: PUSH
60091: EMPTY
60092: LIST
60093: LIST
60094: PUSH
60095: LD_INT 34
60097: PUSH
60098: LD_INT 14
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PUSH
60105: LD_INT 34
60107: PUSH
60108: LD_INT 53
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PUSH
60115: LD_INT 34
60117: PUSH
60118: LD_EXP 95
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: PUSH
60127: LD_INT 34
60129: PUSH
60130: LD_INT 31
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: LD_INT 34
60139: PUSH
60140: LD_INT 48
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: PUSH
60147: LD_INT 34
60149: PUSH
60150: LD_INT 8
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: PUSH
60157: EMPTY
60158: LIST
60159: LIST
60160: LIST
60161: LIST
60162: LIST
60163: LIST
60164: LIST
60165: LIST
60166: LIST
60167: LIST
60168: LIST
60169: LIST
60170: LIST
60171: PPUSH
60172: CALL_OW 72
60176: DIFF
60177: ST_TO_ADDR
// end ; end_of_file
60178: LD_VAR 0 3
60182: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60183: LD_INT 0
60185: PPUSH
60186: PPUSH
60187: PPUSH
// if not mc_bases or not skirmish then
60188: LD_EXP 102
60192: NOT
60193: PUSH
60194: LD_EXP 100
60198: NOT
60199: OR
60200: IFFALSE 60204
// exit ;
60202: GO 60369
// for i = 1 to mc_bases do
60204: LD_ADDR_VAR 0 4
60208: PUSH
60209: DOUBLE
60210: LD_INT 1
60212: DEC
60213: ST_TO_ADDR
60214: LD_EXP 102
60218: PUSH
60219: FOR_TO
60220: IFFALSE 60367
// begin if sci in mc_bases [ i ] then
60222: LD_VAR 0 2
60226: PUSH
60227: LD_EXP 102
60231: PUSH
60232: LD_VAR 0 4
60236: ARRAY
60237: IN
60238: IFFALSE 60365
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60240: LD_ADDR_EXP 131
60244: PUSH
60245: LD_EXP 131
60249: PPUSH
60250: LD_VAR 0 4
60254: PUSH
60255: LD_EXP 131
60259: PUSH
60260: LD_VAR 0 4
60264: ARRAY
60265: PUSH
60266: LD_INT 1
60268: PLUS
60269: PUSH
60270: EMPTY
60271: LIST
60272: LIST
60273: PPUSH
60274: LD_VAR 0 1
60278: PPUSH
60279: CALL 72213 0 3
60283: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60284: LD_ADDR_VAR 0 5
60288: PUSH
60289: LD_EXP 102
60293: PUSH
60294: LD_VAR 0 4
60298: ARRAY
60299: PPUSH
60300: LD_INT 2
60302: PUSH
60303: LD_INT 30
60305: PUSH
60306: LD_INT 0
60308: PUSH
60309: EMPTY
60310: LIST
60311: LIST
60312: PUSH
60313: LD_INT 30
60315: PUSH
60316: LD_INT 1
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: PUSH
60323: EMPTY
60324: LIST
60325: LIST
60326: LIST
60327: PPUSH
60328: CALL_OW 72
60332: PPUSH
60333: LD_VAR 0 1
60337: PPUSH
60338: CALL_OW 74
60342: ST_TO_ADDR
// if tmp then
60343: LD_VAR 0 5
60347: IFFALSE 60363
// ComStandNearbyBuilding ( ape , tmp ) ;
60349: LD_VAR 0 1
60353: PPUSH
60354: LD_VAR 0 5
60358: PPUSH
60359: CALL 66416 0 2
// break ;
60363: GO 60367
// end ; end ;
60365: GO 60219
60367: POP
60368: POP
// end ;
60369: LD_VAR 0 3
60373: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60374: LD_INT 0
60376: PPUSH
60377: PPUSH
60378: PPUSH
// if not mc_bases or not skirmish then
60379: LD_EXP 102
60383: NOT
60384: PUSH
60385: LD_EXP 100
60389: NOT
60390: OR
60391: IFFALSE 60395
// exit ;
60393: GO 60484
// for i = 1 to mc_bases do
60395: LD_ADDR_VAR 0 4
60399: PUSH
60400: DOUBLE
60401: LD_INT 1
60403: DEC
60404: ST_TO_ADDR
60405: LD_EXP 102
60409: PUSH
60410: FOR_TO
60411: IFFALSE 60482
// begin if building in mc_busy_turret_list [ i ] then
60413: LD_VAR 0 1
60417: PUSH
60418: LD_EXP 112
60422: PUSH
60423: LD_VAR 0 4
60427: ARRAY
60428: IN
60429: IFFALSE 60480
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60431: LD_ADDR_VAR 0 5
60435: PUSH
60436: LD_EXP 112
60440: PUSH
60441: LD_VAR 0 4
60445: ARRAY
60446: PUSH
60447: LD_VAR 0 1
60451: DIFF
60452: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60453: LD_ADDR_EXP 112
60457: PUSH
60458: LD_EXP 112
60462: PPUSH
60463: LD_VAR 0 4
60467: PPUSH
60468: LD_VAR 0 5
60472: PPUSH
60473: CALL_OW 1
60477: ST_TO_ADDR
// break ;
60478: GO 60482
// end ; end ;
60480: GO 60410
60482: POP
60483: POP
// end ;
60484: LD_VAR 0 3
60488: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60489: LD_INT 0
60491: PPUSH
60492: PPUSH
60493: PPUSH
// if not mc_bases or not skirmish then
60494: LD_EXP 102
60498: NOT
60499: PUSH
60500: LD_EXP 100
60504: NOT
60505: OR
60506: IFFALSE 60510
// exit ;
60508: GO 60709
// for i = 1 to mc_bases do
60510: LD_ADDR_VAR 0 5
60514: PUSH
60515: DOUBLE
60516: LD_INT 1
60518: DEC
60519: ST_TO_ADDR
60520: LD_EXP 102
60524: PUSH
60525: FOR_TO
60526: IFFALSE 60707
// if building in mc_bases [ i ] then
60528: LD_VAR 0 1
60532: PUSH
60533: LD_EXP 102
60537: PUSH
60538: LD_VAR 0 5
60542: ARRAY
60543: IN
60544: IFFALSE 60705
// begin tmp := mc_bases [ i ] diff building ;
60546: LD_ADDR_VAR 0 6
60550: PUSH
60551: LD_EXP 102
60555: PUSH
60556: LD_VAR 0 5
60560: ARRAY
60561: PUSH
60562: LD_VAR 0 1
60566: DIFF
60567: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60568: LD_ADDR_EXP 102
60572: PUSH
60573: LD_EXP 102
60577: PPUSH
60578: LD_VAR 0 5
60582: PPUSH
60583: LD_VAR 0 6
60587: PPUSH
60588: CALL_OW 1
60592: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60593: LD_VAR 0 1
60597: PUSH
60598: LD_EXP 110
60602: PUSH
60603: LD_VAR 0 5
60607: ARRAY
60608: IN
60609: IFFALSE 60648
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60611: LD_ADDR_EXP 110
60615: PUSH
60616: LD_EXP 110
60620: PPUSH
60621: LD_VAR 0 5
60625: PPUSH
60626: LD_EXP 110
60630: PUSH
60631: LD_VAR 0 5
60635: ARRAY
60636: PUSH
60637: LD_VAR 0 1
60641: DIFF
60642: PPUSH
60643: CALL_OW 1
60647: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60648: LD_VAR 0 1
60652: PUSH
60653: LD_EXP 111
60657: PUSH
60658: LD_VAR 0 5
60662: ARRAY
60663: IN
60664: IFFALSE 60703
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60666: LD_ADDR_EXP 111
60670: PUSH
60671: LD_EXP 111
60675: PPUSH
60676: LD_VAR 0 5
60680: PPUSH
60681: LD_EXP 111
60685: PUSH
60686: LD_VAR 0 5
60690: ARRAY
60691: PUSH
60692: LD_VAR 0 1
60696: DIFF
60697: PPUSH
60698: CALL_OW 1
60702: ST_TO_ADDR
// break ;
60703: GO 60707
// end ;
60705: GO 60525
60707: POP
60708: POP
// end ;
60709: LD_VAR 0 4
60713: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60714: LD_INT 0
60716: PPUSH
60717: PPUSH
60718: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60719: LD_EXP 102
60723: NOT
60724: PUSH
60725: LD_EXP 100
60729: NOT
60730: OR
60731: PUSH
60732: LD_VAR 0 3
60736: PUSH
60737: LD_EXP 128
60741: IN
60742: NOT
60743: OR
60744: IFFALSE 60748
// exit ;
60746: GO 60871
// for i = 1 to mc_vehicles do
60748: LD_ADDR_VAR 0 6
60752: PUSH
60753: DOUBLE
60754: LD_INT 1
60756: DEC
60757: ST_TO_ADDR
60758: LD_EXP 121
60762: PUSH
60763: FOR_TO
60764: IFFALSE 60869
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60766: LD_VAR 0 2
60770: PUSH
60771: LD_EXP 121
60775: PUSH
60776: LD_VAR 0 6
60780: ARRAY
60781: IN
60782: PUSH
60783: LD_VAR 0 1
60787: PUSH
60788: LD_EXP 121
60792: PUSH
60793: LD_VAR 0 6
60797: ARRAY
60798: IN
60799: OR
60800: IFFALSE 60867
// begin tmp := mc_vehicles [ i ] diff old ;
60802: LD_ADDR_VAR 0 7
60806: PUSH
60807: LD_EXP 121
60811: PUSH
60812: LD_VAR 0 6
60816: ARRAY
60817: PUSH
60818: LD_VAR 0 2
60822: DIFF
60823: ST_TO_ADDR
// tmp := tmp diff new ;
60824: LD_ADDR_VAR 0 7
60828: PUSH
60829: LD_VAR 0 7
60833: PUSH
60834: LD_VAR 0 1
60838: DIFF
60839: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60840: LD_ADDR_EXP 121
60844: PUSH
60845: LD_EXP 121
60849: PPUSH
60850: LD_VAR 0 6
60854: PPUSH
60855: LD_VAR 0 7
60859: PPUSH
60860: CALL_OW 1
60864: ST_TO_ADDR
// break ;
60865: GO 60869
// end ;
60867: GO 60763
60869: POP
60870: POP
// end ;
60871: LD_VAR 0 5
60875: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60876: LD_INT 0
60878: PPUSH
60879: PPUSH
60880: PPUSH
60881: PPUSH
// if not mc_bases or not skirmish then
60882: LD_EXP 102
60886: NOT
60887: PUSH
60888: LD_EXP 100
60892: NOT
60893: OR
60894: IFFALSE 60898
// exit ;
60896: GO 61275
// side := GetSide ( vehicle ) ;
60898: LD_ADDR_VAR 0 5
60902: PUSH
60903: LD_VAR 0 1
60907: PPUSH
60908: CALL_OW 255
60912: ST_TO_ADDR
// for i = 1 to mc_bases do
60913: LD_ADDR_VAR 0 4
60917: PUSH
60918: DOUBLE
60919: LD_INT 1
60921: DEC
60922: ST_TO_ADDR
60923: LD_EXP 102
60927: PUSH
60928: FOR_TO
60929: IFFALSE 61273
// begin if factory in mc_bases [ i ] then
60931: LD_VAR 0 2
60935: PUSH
60936: LD_EXP 102
60940: PUSH
60941: LD_VAR 0 4
60945: ARRAY
60946: IN
60947: IFFALSE 61271
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60949: LD_EXP 124
60953: PUSH
60954: LD_VAR 0 4
60958: ARRAY
60959: PUSH
60960: LD_EXP 113
60964: PUSH
60965: LD_VAR 0 4
60969: ARRAY
60970: LESS
60971: PUSH
60972: LD_VAR 0 1
60976: PPUSH
60977: CALL_OW 264
60981: PUSH
60982: LD_INT 31
60984: PUSH
60985: LD_INT 32
60987: PUSH
60988: LD_INT 51
60990: PUSH
60991: LD_EXP 96
60995: PUSH
60996: LD_INT 12
60998: PUSH
60999: LD_INT 30
61001: PUSH
61002: LD_EXP 95
61006: PUSH
61007: LD_INT 11
61009: PUSH
61010: LD_INT 53
61012: PUSH
61013: LD_INT 14
61015: PUSH
61016: LD_EXP 99
61020: PUSH
61021: LD_INT 29
61023: PUSH
61024: LD_EXP 97
61028: PUSH
61029: LD_INT 13
61031: PUSH
61032: LD_INT 52
61034: PUSH
61035: LD_INT 48
61037: PUSH
61038: LD_INT 8
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: LIST
61045: LIST
61046: LIST
61047: LIST
61048: LIST
61049: LIST
61050: LIST
61051: LIST
61052: LIST
61053: LIST
61054: LIST
61055: LIST
61056: LIST
61057: LIST
61058: LIST
61059: IN
61060: NOT
61061: AND
61062: IFFALSE 61110
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61064: LD_ADDR_EXP 124
61068: PUSH
61069: LD_EXP 124
61073: PPUSH
61074: LD_VAR 0 4
61078: PUSH
61079: LD_EXP 124
61083: PUSH
61084: LD_VAR 0 4
61088: ARRAY
61089: PUSH
61090: LD_INT 1
61092: PLUS
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PPUSH
61098: LD_VAR 0 1
61102: PPUSH
61103: CALL 72213 0 3
61107: ST_TO_ADDR
61108: GO 61154
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61110: LD_ADDR_EXP 121
61114: PUSH
61115: LD_EXP 121
61119: PPUSH
61120: LD_VAR 0 4
61124: PUSH
61125: LD_EXP 121
61129: PUSH
61130: LD_VAR 0 4
61134: ARRAY
61135: PUSH
61136: LD_INT 1
61138: PLUS
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: PPUSH
61144: LD_VAR 0 1
61148: PPUSH
61149: CALL 72213 0 3
61153: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 263
61163: PUSH
61164: LD_INT 2
61166: EQUAL
61167: IFFALSE 61187
// begin repeat wait ( 0 0$1 ) ;
61169: LD_INT 35
61171: PPUSH
61172: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61176: LD_VAR 0 1
61180: PPUSH
61181: CALL_OW 312
61185: IFFALSE 61169
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61187: LD_VAR 0 1
61191: PPUSH
61192: LD_EXP 126
61196: PUSH
61197: LD_VAR 0 4
61201: ARRAY
61202: PPUSH
61203: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61207: LD_VAR 0 1
61211: PPUSH
61212: CALL_OW 263
61216: PUSH
61217: LD_INT 1
61219: NONEQUAL
61220: IFFALSE 61224
// break ;
61222: GO 61273
// repeat wait ( 0 0$1 ) ;
61224: LD_INT 35
61226: PPUSH
61227: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61231: LD_VAR 0 1
61235: PPUSH
61236: LD_EXP 126
61240: PUSH
61241: LD_VAR 0 4
61245: ARRAY
61246: PPUSH
61247: CALL_OW 308
61251: IFFALSE 61224
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61253: LD_VAR 0 1
61257: PPUSH
61258: CALL_OW 311
61262: PPUSH
61263: CALL_OW 121
// exit ;
61267: POP
61268: POP
61269: GO 61275
// end ; end ;
61271: GO 60928
61273: POP
61274: POP
// end ;
61275: LD_VAR 0 3
61279: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61280: LD_INT 0
61282: PPUSH
61283: PPUSH
61284: PPUSH
61285: PPUSH
// if not mc_bases or not skirmish then
61286: LD_EXP 102
61290: NOT
61291: PUSH
61292: LD_EXP 100
61296: NOT
61297: OR
61298: IFFALSE 61302
// exit ;
61300: GO 61655
// repeat wait ( 0 0$1 ) ;
61302: LD_INT 35
61304: PPUSH
61305: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61309: LD_VAR 0 2
61313: PPUSH
61314: LD_VAR 0 3
61318: PPUSH
61319: CALL_OW 284
61323: IFFALSE 61302
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61325: LD_VAR 0 2
61329: PPUSH
61330: LD_VAR 0 3
61334: PPUSH
61335: CALL_OW 283
61339: PUSH
61340: LD_INT 4
61342: EQUAL
61343: IFFALSE 61347
// exit ;
61345: GO 61655
// for i = 1 to mc_bases do
61347: LD_ADDR_VAR 0 7
61351: PUSH
61352: DOUBLE
61353: LD_INT 1
61355: DEC
61356: ST_TO_ADDR
61357: LD_EXP 102
61361: PUSH
61362: FOR_TO
61363: IFFALSE 61653
// begin if mc_crates_area [ i ] then
61365: LD_EXP 120
61369: PUSH
61370: LD_VAR 0 7
61374: ARRAY
61375: IFFALSE 61486
// for j in mc_crates_area [ i ] do
61377: LD_ADDR_VAR 0 8
61381: PUSH
61382: LD_EXP 120
61386: PUSH
61387: LD_VAR 0 7
61391: ARRAY
61392: PUSH
61393: FOR_IN
61394: IFFALSE 61484
// if InArea ( x , y , j ) then
61396: LD_VAR 0 2
61400: PPUSH
61401: LD_VAR 0 3
61405: PPUSH
61406: LD_VAR 0 8
61410: PPUSH
61411: CALL_OW 309
61415: IFFALSE 61482
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61417: LD_ADDR_EXP 118
61421: PUSH
61422: LD_EXP 118
61426: PPUSH
61427: LD_VAR 0 7
61431: PUSH
61432: LD_EXP 118
61436: PUSH
61437: LD_VAR 0 7
61441: ARRAY
61442: PUSH
61443: LD_INT 1
61445: PLUS
61446: PUSH
61447: EMPTY
61448: LIST
61449: LIST
61450: PPUSH
61451: LD_VAR 0 4
61455: PUSH
61456: LD_VAR 0 2
61460: PUSH
61461: LD_VAR 0 3
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: LIST
61470: PPUSH
61471: CALL 72213 0 3
61475: ST_TO_ADDR
// exit ;
61476: POP
61477: POP
61478: POP
61479: POP
61480: GO 61655
// end ;
61482: GO 61393
61484: POP
61485: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61486: LD_ADDR_VAR 0 9
61490: PUSH
61491: LD_EXP 102
61495: PUSH
61496: LD_VAR 0 7
61500: ARRAY
61501: PPUSH
61502: LD_INT 2
61504: PUSH
61505: LD_INT 30
61507: PUSH
61508: LD_INT 0
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: PUSH
61515: LD_INT 30
61517: PUSH
61518: LD_INT 1
61520: PUSH
61521: EMPTY
61522: LIST
61523: LIST
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: LIST
61529: PPUSH
61530: CALL_OW 72
61534: ST_TO_ADDR
// if not depot then
61535: LD_VAR 0 9
61539: NOT
61540: IFFALSE 61544
// continue ;
61542: GO 61362
// for j in depot do
61544: LD_ADDR_VAR 0 8
61548: PUSH
61549: LD_VAR 0 9
61553: PUSH
61554: FOR_IN
61555: IFFALSE 61649
// if GetDistUnitXY ( j , x , y ) < 30 then
61557: LD_VAR 0 8
61561: PPUSH
61562: LD_VAR 0 2
61566: PPUSH
61567: LD_VAR 0 3
61571: PPUSH
61572: CALL_OW 297
61576: PUSH
61577: LD_INT 30
61579: LESS
61580: IFFALSE 61647
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61582: LD_ADDR_EXP 118
61586: PUSH
61587: LD_EXP 118
61591: PPUSH
61592: LD_VAR 0 7
61596: PUSH
61597: LD_EXP 118
61601: PUSH
61602: LD_VAR 0 7
61606: ARRAY
61607: PUSH
61608: LD_INT 1
61610: PLUS
61611: PUSH
61612: EMPTY
61613: LIST
61614: LIST
61615: PPUSH
61616: LD_VAR 0 4
61620: PUSH
61621: LD_VAR 0 2
61625: PUSH
61626: LD_VAR 0 3
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: LIST
61635: PPUSH
61636: CALL 72213 0 3
61640: ST_TO_ADDR
// exit ;
61641: POP
61642: POP
61643: POP
61644: POP
61645: GO 61655
// end ;
61647: GO 61554
61649: POP
61650: POP
// end ;
61651: GO 61362
61653: POP
61654: POP
// end ;
61655: LD_VAR 0 6
61659: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61660: LD_INT 0
61662: PPUSH
61663: PPUSH
61664: PPUSH
61665: PPUSH
// if not mc_bases or not skirmish then
61666: LD_EXP 102
61670: NOT
61671: PUSH
61672: LD_EXP 100
61676: NOT
61677: OR
61678: IFFALSE 61682
// exit ;
61680: GO 61959
// side := GetSide ( lab ) ;
61682: LD_ADDR_VAR 0 4
61686: PUSH
61687: LD_VAR 0 2
61691: PPUSH
61692: CALL_OW 255
61696: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61697: LD_VAR 0 4
61701: PUSH
61702: LD_EXP 128
61706: IN
61707: NOT
61708: PUSH
61709: LD_EXP 129
61713: NOT
61714: OR
61715: PUSH
61716: LD_EXP 102
61720: NOT
61721: OR
61722: IFFALSE 61726
// exit ;
61724: GO 61959
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61726: LD_ADDR_EXP 129
61730: PUSH
61731: LD_EXP 129
61735: PPUSH
61736: LD_VAR 0 4
61740: PPUSH
61741: LD_EXP 129
61745: PUSH
61746: LD_VAR 0 4
61750: ARRAY
61751: PUSH
61752: LD_VAR 0 1
61756: DIFF
61757: PPUSH
61758: CALL_OW 1
61762: ST_TO_ADDR
// for i = 1 to mc_bases do
61763: LD_ADDR_VAR 0 5
61767: PUSH
61768: DOUBLE
61769: LD_INT 1
61771: DEC
61772: ST_TO_ADDR
61773: LD_EXP 102
61777: PUSH
61778: FOR_TO
61779: IFFALSE 61957
// begin if lab in mc_bases [ i ] then
61781: LD_VAR 0 2
61785: PUSH
61786: LD_EXP 102
61790: PUSH
61791: LD_VAR 0 5
61795: ARRAY
61796: IN
61797: IFFALSE 61955
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61799: LD_VAR 0 1
61803: PUSH
61804: LD_INT 11
61806: PUSH
61807: LD_INT 4
61809: PUSH
61810: LD_INT 3
61812: PUSH
61813: LD_INT 2
61815: PUSH
61816: EMPTY
61817: LIST
61818: LIST
61819: LIST
61820: LIST
61821: IN
61822: PUSH
61823: LD_EXP 132
61827: PUSH
61828: LD_VAR 0 5
61832: ARRAY
61833: AND
61834: IFFALSE 61955
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61836: LD_ADDR_VAR 0 6
61840: PUSH
61841: LD_EXP 132
61845: PUSH
61846: LD_VAR 0 5
61850: ARRAY
61851: PUSH
61852: LD_INT 1
61854: ARRAY
61855: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61856: LD_ADDR_EXP 132
61860: PUSH
61861: LD_EXP 132
61865: PPUSH
61866: LD_VAR 0 5
61870: PPUSH
61871: EMPTY
61872: PPUSH
61873: CALL_OW 1
61877: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61878: LD_VAR 0 6
61882: PPUSH
61883: LD_INT 0
61885: PPUSH
61886: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61890: LD_VAR 0 6
61894: PPUSH
61895: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61899: LD_ADDR_EXP 131
61903: PUSH
61904: LD_EXP 131
61908: PPUSH
61909: LD_VAR 0 5
61913: PPUSH
61914: LD_EXP 131
61918: PUSH
61919: LD_VAR 0 5
61923: ARRAY
61924: PPUSH
61925: LD_INT 1
61927: PPUSH
61928: LD_VAR 0 6
61932: PPUSH
61933: CALL_OW 2
61937: PPUSH
61938: CALL_OW 1
61942: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61943: LD_VAR 0 5
61947: PPUSH
61948: LD_INT 112
61950: PPUSH
61951: CALL 38955 0 2
// end ; end ; end ;
61955: GO 61778
61957: POP
61958: POP
// end ;
61959: LD_VAR 0 3
61963: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61964: LD_INT 0
61966: PPUSH
61967: PPUSH
61968: PPUSH
61969: PPUSH
61970: PPUSH
61971: PPUSH
61972: PPUSH
61973: PPUSH
// if not mc_bases or not skirmish then
61974: LD_EXP 102
61978: NOT
61979: PUSH
61980: LD_EXP 100
61984: NOT
61985: OR
61986: IFFALSE 61990
// exit ;
61988: GO 63361
// for i = 1 to mc_bases do
61990: LD_ADDR_VAR 0 3
61994: PUSH
61995: DOUBLE
61996: LD_INT 1
61998: DEC
61999: ST_TO_ADDR
62000: LD_EXP 102
62004: PUSH
62005: FOR_TO
62006: IFFALSE 63359
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62008: LD_VAR 0 1
62012: PUSH
62013: LD_EXP 102
62017: PUSH
62018: LD_VAR 0 3
62022: ARRAY
62023: IN
62024: PUSH
62025: LD_VAR 0 1
62029: PUSH
62030: LD_EXP 109
62034: PUSH
62035: LD_VAR 0 3
62039: ARRAY
62040: IN
62041: OR
62042: PUSH
62043: LD_VAR 0 1
62047: PUSH
62048: LD_EXP 124
62052: PUSH
62053: LD_VAR 0 3
62057: ARRAY
62058: IN
62059: OR
62060: PUSH
62061: LD_VAR 0 1
62065: PUSH
62066: LD_EXP 121
62070: PUSH
62071: LD_VAR 0 3
62075: ARRAY
62076: IN
62077: OR
62078: PUSH
62079: LD_VAR 0 1
62083: PUSH
62084: LD_EXP 131
62088: PUSH
62089: LD_VAR 0 3
62093: ARRAY
62094: IN
62095: OR
62096: PUSH
62097: LD_VAR 0 1
62101: PUSH
62102: LD_EXP 132
62106: PUSH
62107: LD_VAR 0 3
62111: ARRAY
62112: IN
62113: OR
62114: IFFALSE 63357
// begin if un in mc_ape [ i ] then
62116: LD_VAR 0 1
62120: PUSH
62121: LD_EXP 131
62125: PUSH
62126: LD_VAR 0 3
62130: ARRAY
62131: IN
62132: IFFALSE 62171
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62134: LD_ADDR_EXP 131
62138: PUSH
62139: LD_EXP 131
62143: PPUSH
62144: LD_VAR 0 3
62148: PPUSH
62149: LD_EXP 131
62153: PUSH
62154: LD_VAR 0 3
62158: ARRAY
62159: PUSH
62160: LD_VAR 0 1
62164: DIFF
62165: PPUSH
62166: CALL_OW 1
62170: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62171: LD_VAR 0 1
62175: PUSH
62176: LD_EXP 132
62180: PUSH
62181: LD_VAR 0 3
62185: ARRAY
62186: IN
62187: IFFALSE 62211
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62189: LD_ADDR_EXP 132
62193: PUSH
62194: LD_EXP 132
62198: PPUSH
62199: LD_VAR 0 3
62203: PPUSH
62204: EMPTY
62205: PPUSH
62206: CALL_OW 1
62210: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62211: LD_VAR 0 1
62215: PPUSH
62216: CALL_OW 247
62220: PUSH
62221: LD_INT 2
62223: EQUAL
62224: PUSH
62225: LD_VAR 0 1
62229: PPUSH
62230: CALL_OW 110
62234: PUSH
62235: LD_INT 20
62237: EQUAL
62238: PUSH
62239: LD_VAR 0 1
62243: PUSH
62244: LD_EXP 124
62248: PUSH
62249: LD_VAR 0 3
62253: ARRAY
62254: IN
62255: OR
62256: PUSH
62257: LD_VAR 0 1
62261: PPUSH
62262: CALL_OW 264
62266: PUSH
62267: LD_INT 12
62269: PUSH
62270: LD_INT 51
62272: PUSH
62273: LD_EXP 96
62277: PUSH
62278: LD_INT 32
62280: PUSH
62281: LD_INT 13
62283: PUSH
62284: LD_INT 52
62286: PUSH
62287: LD_INT 31
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: LIST
62294: LIST
62295: LIST
62296: LIST
62297: LIST
62298: IN
62299: OR
62300: AND
62301: IFFALSE 62609
// begin if un in mc_defender [ i ] then
62303: LD_VAR 0 1
62307: PUSH
62308: LD_EXP 124
62312: PUSH
62313: LD_VAR 0 3
62317: ARRAY
62318: IN
62319: IFFALSE 62358
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62321: LD_ADDR_EXP 124
62325: PUSH
62326: LD_EXP 124
62330: PPUSH
62331: LD_VAR 0 3
62335: PPUSH
62336: LD_EXP 124
62340: PUSH
62341: LD_VAR 0 3
62345: ARRAY
62346: PUSH
62347: LD_VAR 0 1
62351: DIFF
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62358: LD_ADDR_VAR 0 8
62362: PUSH
62363: LD_VAR 0 3
62367: PPUSH
62368: LD_INT 3
62370: PPUSH
62371: CALL 59027 0 2
62375: ST_TO_ADDR
// if fac then
62376: LD_VAR 0 8
62380: IFFALSE 62609
// begin for j in fac do
62382: LD_ADDR_VAR 0 4
62386: PUSH
62387: LD_VAR 0 8
62391: PUSH
62392: FOR_IN
62393: IFFALSE 62607
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62395: LD_ADDR_VAR 0 9
62399: PUSH
62400: LD_VAR 0 8
62404: PPUSH
62405: LD_VAR 0 1
62409: PPUSH
62410: CALL_OW 265
62414: PPUSH
62415: LD_VAR 0 1
62419: PPUSH
62420: CALL_OW 262
62424: PPUSH
62425: LD_VAR 0 1
62429: PPUSH
62430: CALL_OW 263
62434: PPUSH
62435: LD_VAR 0 1
62439: PPUSH
62440: CALL_OW 264
62444: PPUSH
62445: CALL 69745 0 5
62449: ST_TO_ADDR
// if components then
62450: LD_VAR 0 9
62454: IFFALSE 62605
// begin if GetWeapon ( un ) = ar_control_tower then
62456: LD_VAR 0 1
62460: PPUSH
62461: CALL_OW 264
62465: PUSH
62466: LD_INT 31
62468: EQUAL
62469: IFFALSE 62586
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62471: LD_VAR 0 1
62475: PPUSH
62476: CALL_OW 311
62480: PPUSH
62481: LD_INT 0
62483: PPUSH
62484: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62488: LD_ADDR_EXP 142
62492: PUSH
62493: LD_EXP 142
62497: PPUSH
62498: LD_VAR 0 3
62502: PPUSH
62503: LD_EXP 142
62507: PUSH
62508: LD_VAR 0 3
62512: ARRAY
62513: PUSH
62514: LD_VAR 0 1
62518: PPUSH
62519: CALL_OW 311
62523: DIFF
62524: PPUSH
62525: CALL_OW 1
62529: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62530: LD_ADDR_VAR 0 7
62534: PUSH
62535: LD_EXP 123
62539: PUSH
62540: LD_VAR 0 3
62544: ARRAY
62545: PPUSH
62546: LD_INT 1
62548: PPUSH
62549: LD_VAR 0 9
62553: PPUSH
62554: CALL_OW 2
62558: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62559: LD_ADDR_EXP 123
62563: PUSH
62564: LD_EXP 123
62568: PPUSH
62569: LD_VAR 0 3
62573: PPUSH
62574: LD_VAR 0 7
62578: PPUSH
62579: CALL_OW 1
62583: ST_TO_ADDR
// end else
62584: GO 62603
// MC_InsertProduceList ( i , [ components ] ) ;
62586: LD_VAR 0 3
62590: PPUSH
62591: LD_VAR 0 9
62595: PUSH
62596: EMPTY
62597: LIST
62598: PPUSH
62599: CALL 58572 0 2
// break ;
62603: GO 62607
// end ; end ;
62605: GO 62392
62607: POP
62608: POP
// end ; end ; if GetType ( un ) = unit_building then
62609: LD_VAR 0 1
62613: PPUSH
62614: CALL_OW 247
62618: PUSH
62619: LD_INT 3
62621: EQUAL
62622: IFFALSE 63025
// begin btype := GetBType ( un ) ;
62624: LD_ADDR_VAR 0 5
62628: PUSH
62629: LD_VAR 0 1
62633: PPUSH
62634: CALL_OW 266
62638: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62639: LD_VAR 0 5
62643: PUSH
62644: LD_INT 29
62646: PUSH
62647: LD_INT 30
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: IN
62654: IFFALSE 62727
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62656: LD_VAR 0 1
62660: PPUSH
62661: CALL_OW 250
62665: PPUSH
62666: LD_VAR 0 1
62670: PPUSH
62671: CALL_OW 251
62675: PPUSH
62676: LD_VAR 0 1
62680: PPUSH
62681: CALL_OW 255
62685: PPUSH
62686: CALL_OW 440
62690: NOT
62691: IFFALSE 62727
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 250
62702: PPUSH
62703: LD_VAR 0 1
62707: PPUSH
62708: CALL_OW 251
62712: PPUSH
62713: LD_VAR 0 1
62717: PPUSH
62718: CALL_OW 255
62722: PPUSH
62723: CALL_OW 441
// end ; if btype = b_warehouse then
62727: LD_VAR 0 5
62731: PUSH
62732: LD_INT 1
62734: EQUAL
62735: IFFALSE 62753
// begin btype := b_depot ;
62737: LD_ADDR_VAR 0 5
62741: PUSH
62742: LD_INT 0
62744: ST_TO_ADDR
// pos := 1 ;
62745: LD_ADDR_VAR 0 6
62749: PUSH
62750: LD_INT 1
62752: ST_TO_ADDR
// end ; if btype = b_factory then
62753: LD_VAR 0 5
62757: PUSH
62758: LD_INT 3
62760: EQUAL
62761: IFFALSE 62779
// begin btype := b_workshop ;
62763: LD_ADDR_VAR 0 5
62767: PUSH
62768: LD_INT 2
62770: ST_TO_ADDR
// pos := 1 ;
62771: LD_ADDR_VAR 0 6
62775: PUSH
62776: LD_INT 1
62778: ST_TO_ADDR
// end ; if btype = b_barracks then
62779: LD_VAR 0 5
62783: PUSH
62784: LD_INT 5
62786: EQUAL
62787: IFFALSE 62797
// btype := b_armoury ;
62789: LD_ADDR_VAR 0 5
62793: PUSH
62794: LD_INT 4
62796: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62797: LD_VAR 0 5
62801: PUSH
62802: LD_INT 7
62804: PUSH
62805: LD_INT 8
62807: PUSH
62808: EMPTY
62809: LIST
62810: LIST
62811: IN
62812: IFFALSE 62822
// btype := b_lab ;
62814: LD_ADDR_VAR 0 5
62818: PUSH
62819: LD_INT 6
62821: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62822: LD_ADDR_EXP 107
62826: PUSH
62827: LD_EXP 107
62831: PPUSH
62832: LD_VAR 0 3
62836: PUSH
62837: LD_EXP 107
62841: PUSH
62842: LD_VAR 0 3
62846: ARRAY
62847: PUSH
62848: LD_INT 1
62850: PLUS
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PPUSH
62856: LD_VAR 0 5
62860: PUSH
62861: LD_VAR 0 1
62865: PPUSH
62866: CALL_OW 250
62870: PUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: CALL_OW 251
62880: PUSH
62881: LD_VAR 0 1
62885: PPUSH
62886: CALL_OW 254
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: PPUSH
62897: CALL 72213 0 3
62901: ST_TO_ADDR
// if pos = 1 then
62902: LD_VAR 0 6
62906: PUSH
62907: LD_INT 1
62909: EQUAL
62910: IFFALSE 63025
// begin tmp := mc_build_list [ i ] ;
62912: LD_ADDR_VAR 0 7
62916: PUSH
62917: LD_EXP 107
62921: PUSH
62922: LD_VAR 0 3
62926: ARRAY
62927: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62928: LD_VAR 0 7
62932: PPUSH
62933: LD_INT 2
62935: PUSH
62936: LD_INT 30
62938: PUSH
62939: LD_INT 0
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: LD_INT 30
62948: PUSH
62949: LD_INT 1
62951: PUSH
62952: EMPTY
62953: LIST
62954: LIST
62955: PUSH
62956: EMPTY
62957: LIST
62958: LIST
62959: LIST
62960: PPUSH
62961: CALL_OW 72
62965: IFFALSE 62975
// pos := 2 ;
62967: LD_ADDR_VAR 0 6
62971: PUSH
62972: LD_INT 2
62974: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62975: LD_ADDR_VAR 0 7
62979: PUSH
62980: LD_VAR 0 7
62984: PPUSH
62985: LD_VAR 0 6
62989: PPUSH
62990: LD_VAR 0 7
62994: PPUSH
62995: CALL 72539 0 3
62999: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63000: LD_ADDR_EXP 107
63004: PUSH
63005: LD_EXP 107
63009: PPUSH
63010: LD_VAR 0 3
63014: PPUSH
63015: LD_VAR 0 7
63019: PPUSH
63020: CALL_OW 1
63024: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63025: LD_VAR 0 1
63029: PUSH
63030: LD_EXP 102
63034: PUSH
63035: LD_VAR 0 3
63039: ARRAY
63040: IN
63041: IFFALSE 63080
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63043: LD_ADDR_EXP 102
63047: PUSH
63048: LD_EXP 102
63052: PPUSH
63053: LD_VAR 0 3
63057: PPUSH
63058: LD_EXP 102
63062: PUSH
63063: LD_VAR 0 3
63067: ARRAY
63068: PUSH
63069: LD_VAR 0 1
63073: DIFF
63074: PPUSH
63075: CALL_OW 1
63079: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63080: LD_VAR 0 1
63084: PUSH
63085: LD_EXP 109
63089: PUSH
63090: LD_VAR 0 3
63094: ARRAY
63095: IN
63096: IFFALSE 63135
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63098: LD_ADDR_EXP 109
63102: PUSH
63103: LD_EXP 109
63107: PPUSH
63108: LD_VAR 0 3
63112: PPUSH
63113: LD_EXP 109
63117: PUSH
63118: LD_VAR 0 3
63122: ARRAY
63123: PUSH
63124: LD_VAR 0 1
63128: DIFF
63129: PPUSH
63130: CALL_OW 1
63134: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63135: LD_VAR 0 1
63139: PUSH
63140: LD_EXP 121
63144: PUSH
63145: LD_VAR 0 3
63149: ARRAY
63150: IN
63151: IFFALSE 63190
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63153: LD_ADDR_EXP 121
63157: PUSH
63158: LD_EXP 121
63162: PPUSH
63163: LD_VAR 0 3
63167: PPUSH
63168: LD_EXP 121
63172: PUSH
63173: LD_VAR 0 3
63177: ARRAY
63178: PUSH
63179: LD_VAR 0 1
63183: DIFF
63184: PPUSH
63185: CALL_OW 1
63189: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63190: LD_VAR 0 1
63194: PUSH
63195: LD_EXP 124
63199: PUSH
63200: LD_VAR 0 3
63204: ARRAY
63205: IN
63206: IFFALSE 63245
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63208: LD_ADDR_EXP 124
63212: PUSH
63213: LD_EXP 124
63217: PPUSH
63218: LD_VAR 0 3
63222: PPUSH
63223: LD_EXP 124
63227: PUSH
63228: LD_VAR 0 3
63232: ARRAY
63233: PUSH
63234: LD_VAR 0 1
63238: DIFF
63239: PPUSH
63240: CALL_OW 1
63244: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63245: LD_VAR 0 1
63249: PUSH
63250: LD_EXP 111
63254: PUSH
63255: LD_VAR 0 3
63259: ARRAY
63260: IN
63261: IFFALSE 63300
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63263: LD_ADDR_EXP 111
63267: PUSH
63268: LD_EXP 111
63272: PPUSH
63273: LD_VAR 0 3
63277: PPUSH
63278: LD_EXP 111
63282: PUSH
63283: LD_VAR 0 3
63287: ARRAY
63288: PUSH
63289: LD_VAR 0 1
63293: DIFF
63294: PPUSH
63295: CALL_OW 1
63299: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63300: LD_VAR 0 1
63304: PUSH
63305: LD_EXP 110
63309: PUSH
63310: LD_VAR 0 3
63314: ARRAY
63315: IN
63316: IFFALSE 63355
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63318: LD_ADDR_EXP 110
63322: PUSH
63323: LD_EXP 110
63327: PPUSH
63328: LD_VAR 0 3
63332: PPUSH
63333: LD_EXP 110
63337: PUSH
63338: LD_VAR 0 3
63342: ARRAY
63343: PUSH
63344: LD_VAR 0 1
63348: DIFF
63349: PPUSH
63350: CALL_OW 1
63354: ST_TO_ADDR
// end ; break ;
63355: GO 63359
// end ;
63357: GO 62005
63359: POP
63360: POP
// end ;
63361: LD_VAR 0 2
63365: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63366: LD_INT 0
63368: PPUSH
63369: PPUSH
63370: PPUSH
// if not mc_bases or not skirmish then
63371: LD_EXP 102
63375: NOT
63376: PUSH
63377: LD_EXP 100
63381: NOT
63382: OR
63383: IFFALSE 63387
// exit ;
63385: GO 63602
// for i = 1 to mc_bases do
63387: LD_ADDR_VAR 0 3
63391: PUSH
63392: DOUBLE
63393: LD_INT 1
63395: DEC
63396: ST_TO_ADDR
63397: LD_EXP 102
63401: PUSH
63402: FOR_TO
63403: IFFALSE 63600
// begin if building in mc_construct_list [ i ] then
63405: LD_VAR 0 1
63409: PUSH
63410: LD_EXP 109
63414: PUSH
63415: LD_VAR 0 3
63419: ARRAY
63420: IN
63421: IFFALSE 63598
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63423: LD_ADDR_EXP 109
63427: PUSH
63428: LD_EXP 109
63432: PPUSH
63433: LD_VAR 0 3
63437: PPUSH
63438: LD_EXP 109
63442: PUSH
63443: LD_VAR 0 3
63447: ARRAY
63448: PUSH
63449: LD_VAR 0 1
63453: DIFF
63454: PPUSH
63455: CALL_OW 1
63459: ST_TO_ADDR
// if building in mc_lab [ i ] then
63460: LD_VAR 0 1
63464: PUSH
63465: LD_EXP 135
63469: PUSH
63470: LD_VAR 0 3
63474: ARRAY
63475: IN
63476: IFFALSE 63531
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63478: LD_ADDR_EXP 136
63482: PUSH
63483: LD_EXP 136
63487: PPUSH
63488: LD_VAR 0 3
63492: PPUSH
63493: LD_EXP 136
63497: PUSH
63498: LD_VAR 0 3
63502: ARRAY
63503: PPUSH
63504: LD_INT 1
63506: PPUSH
63507: LD_EXP 136
63511: PUSH
63512: LD_VAR 0 3
63516: ARRAY
63517: PPUSH
63518: LD_INT 0
63520: PPUSH
63521: CALL 71631 0 4
63525: PPUSH
63526: CALL_OW 1
63530: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63531: LD_VAR 0 1
63535: PUSH
63536: LD_EXP 102
63540: PUSH
63541: LD_VAR 0 3
63545: ARRAY
63546: IN
63547: NOT
63548: IFFALSE 63594
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63550: LD_ADDR_EXP 102
63554: PUSH
63555: LD_EXP 102
63559: PPUSH
63560: LD_VAR 0 3
63564: PUSH
63565: LD_EXP 102
63569: PUSH
63570: LD_VAR 0 3
63574: ARRAY
63575: PUSH
63576: LD_INT 1
63578: PLUS
63579: PUSH
63580: EMPTY
63581: LIST
63582: LIST
63583: PPUSH
63584: LD_VAR 0 1
63588: PPUSH
63589: CALL 72213 0 3
63593: ST_TO_ADDR
// exit ;
63594: POP
63595: POP
63596: GO 63602
// end ; end ;
63598: GO 63402
63600: POP
63601: POP
// end ;
63602: LD_VAR 0 2
63606: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63607: LD_INT 0
63609: PPUSH
63610: PPUSH
63611: PPUSH
63612: PPUSH
63613: PPUSH
63614: PPUSH
63615: PPUSH
// if not mc_bases or not skirmish then
63616: LD_EXP 102
63620: NOT
63621: PUSH
63622: LD_EXP 100
63626: NOT
63627: OR
63628: IFFALSE 63632
// exit ;
63630: GO 64293
// for i = 1 to mc_bases do
63632: LD_ADDR_VAR 0 3
63636: PUSH
63637: DOUBLE
63638: LD_INT 1
63640: DEC
63641: ST_TO_ADDR
63642: LD_EXP 102
63646: PUSH
63647: FOR_TO
63648: IFFALSE 64291
// begin if building in mc_construct_list [ i ] then
63650: LD_VAR 0 1
63654: PUSH
63655: LD_EXP 109
63659: PUSH
63660: LD_VAR 0 3
63664: ARRAY
63665: IN
63666: IFFALSE 64289
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63668: LD_ADDR_EXP 109
63672: PUSH
63673: LD_EXP 109
63677: PPUSH
63678: LD_VAR 0 3
63682: PPUSH
63683: LD_EXP 109
63687: PUSH
63688: LD_VAR 0 3
63692: ARRAY
63693: PUSH
63694: LD_VAR 0 1
63698: DIFF
63699: PPUSH
63700: CALL_OW 1
63704: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63705: LD_ADDR_EXP 102
63709: PUSH
63710: LD_EXP 102
63714: PPUSH
63715: LD_VAR 0 3
63719: PUSH
63720: LD_EXP 102
63724: PUSH
63725: LD_VAR 0 3
63729: ARRAY
63730: PUSH
63731: LD_INT 1
63733: PLUS
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PPUSH
63739: LD_VAR 0 1
63743: PPUSH
63744: CALL 72213 0 3
63748: ST_TO_ADDR
// btype := GetBType ( building ) ;
63749: LD_ADDR_VAR 0 5
63753: PUSH
63754: LD_VAR 0 1
63758: PPUSH
63759: CALL_OW 266
63763: ST_TO_ADDR
// side := GetSide ( building ) ;
63764: LD_ADDR_VAR 0 8
63768: PUSH
63769: LD_VAR 0 1
63773: PPUSH
63774: CALL_OW 255
63778: ST_TO_ADDR
// if btype = b_lab then
63779: LD_VAR 0 5
63783: PUSH
63784: LD_INT 6
63786: EQUAL
63787: IFFALSE 63837
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63789: LD_ADDR_EXP 135
63793: PUSH
63794: LD_EXP 135
63798: PPUSH
63799: LD_VAR 0 3
63803: PUSH
63804: LD_EXP 135
63808: PUSH
63809: LD_VAR 0 3
63813: ARRAY
63814: PUSH
63815: LD_INT 1
63817: PLUS
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PPUSH
63823: LD_VAR 0 1
63827: PPUSH
63828: CALL 72213 0 3
63832: ST_TO_ADDR
// exit ;
63833: POP
63834: POP
63835: GO 64293
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63837: LD_VAR 0 5
63841: PUSH
63842: LD_INT 0
63844: PUSH
63845: LD_INT 2
63847: PUSH
63848: LD_INT 4
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: LIST
63855: IN
63856: IFFALSE 63980
// begin if btype = b_armoury then
63858: LD_VAR 0 5
63862: PUSH
63863: LD_INT 4
63865: EQUAL
63866: IFFALSE 63876
// btype := b_barracks ;
63868: LD_ADDR_VAR 0 5
63872: PUSH
63873: LD_INT 5
63875: ST_TO_ADDR
// if btype = b_depot then
63876: LD_VAR 0 5
63880: PUSH
63881: LD_INT 0
63883: EQUAL
63884: IFFALSE 63894
// btype := b_warehouse ;
63886: LD_ADDR_VAR 0 5
63890: PUSH
63891: LD_INT 1
63893: ST_TO_ADDR
// if btype = b_workshop then
63894: LD_VAR 0 5
63898: PUSH
63899: LD_INT 2
63901: EQUAL
63902: IFFALSE 63912
// btype := b_factory ;
63904: LD_ADDR_VAR 0 5
63908: PUSH
63909: LD_INT 3
63911: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63912: LD_VAR 0 5
63916: PPUSH
63917: LD_VAR 0 8
63921: PPUSH
63922: CALL_OW 323
63926: PUSH
63927: LD_INT 1
63929: EQUAL
63930: IFFALSE 63976
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63932: LD_ADDR_EXP 134
63936: PUSH
63937: LD_EXP 134
63941: PPUSH
63942: LD_VAR 0 3
63946: PUSH
63947: LD_EXP 134
63951: PUSH
63952: LD_VAR 0 3
63956: ARRAY
63957: PUSH
63958: LD_INT 1
63960: PLUS
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PPUSH
63966: LD_VAR 0 1
63970: PPUSH
63971: CALL 72213 0 3
63975: ST_TO_ADDR
// exit ;
63976: POP
63977: POP
63978: GO 64293
// end ; if btype in [ b_bunker , b_turret ] then
63980: LD_VAR 0 5
63984: PUSH
63985: LD_INT 32
63987: PUSH
63988: LD_INT 33
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: IN
63995: IFFALSE 64285
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63997: LD_ADDR_EXP 110
64001: PUSH
64002: LD_EXP 110
64006: PPUSH
64007: LD_VAR 0 3
64011: PUSH
64012: LD_EXP 110
64016: PUSH
64017: LD_VAR 0 3
64021: ARRAY
64022: PUSH
64023: LD_INT 1
64025: PLUS
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PPUSH
64031: LD_VAR 0 1
64035: PPUSH
64036: CALL 72213 0 3
64040: ST_TO_ADDR
// if btype = b_bunker then
64041: LD_VAR 0 5
64045: PUSH
64046: LD_INT 32
64048: EQUAL
64049: IFFALSE 64285
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64051: LD_ADDR_EXP 111
64055: PUSH
64056: LD_EXP 111
64060: PPUSH
64061: LD_VAR 0 3
64065: PUSH
64066: LD_EXP 111
64070: PUSH
64071: LD_VAR 0 3
64075: ARRAY
64076: PUSH
64077: LD_INT 1
64079: PLUS
64080: PUSH
64081: EMPTY
64082: LIST
64083: LIST
64084: PPUSH
64085: LD_VAR 0 1
64089: PPUSH
64090: CALL 72213 0 3
64094: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64095: LD_ADDR_VAR 0 6
64099: PUSH
64100: LD_EXP 102
64104: PUSH
64105: LD_VAR 0 3
64109: ARRAY
64110: PPUSH
64111: LD_INT 25
64113: PUSH
64114: LD_INT 1
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 3
64123: PUSH
64124: LD_INT 54
64126: PUSH
64127: EMPTY
64128: LIST
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: PUSH
64134: EMPTY
64135: LIST
64136: LIST
64137: PPUSH
64138: CALL_OW 72
64142: ST_TO_ADDR
// if tmp then
64143: LD_VAR 0 6
64147: IFFALSE 64153
// exit ;
64149: POP
64150: POP
64151: GO 64293
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64153: LD_ADDR_VAR 0 6
64157: PUSH
64158: LD_EXP 102
64162: PUSH
64163: LD_VAR 0 3
64167: ARRAY
64168: PPUSH
64169: LD_INT 2
64171: PUSH
64172: LD_INT 30
64174: PUSH
64175: LD_INT 4
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 30
64184: PUSH
64185: LD_INT 5
64187: PUSH
64188: EMPTY
64189: LIST
64190: LIST
64191: PUSH
64192: EMPTY
64193: LIST
64194: LIST
64195: LIST
64196: PPUSH
64197: CALL_OW 72
64201: ST_TO_ADDR
// if not tmp then
64202: LD_VAR 0 6
64206: NOT
64207: IFFALSE 64213
// exit ;
64209: POP
64210: POP
64211: GO 64293
// for j in tmp do
64213: LD_ADDR_VAR 0 4
64217: PUSH
64218: LD_VAR 0 6
64222: PUSH
64223: FOR_IN
64224: IFFALSE 64283
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64226: LD_ADDR_VAR 0 7
64230: PUSH
64231: LD_VAR 0 4
64235: PPUSH
64236: CALL_OW 313
64240: PPUSH
64241: LD_INT 25
64243: PUSH
64244: LD_INT 1
64246: PUSH
64247: EMPTY
64248: LIST
64249: LIST
64250: PPUSH
64251: CALL_OW 72
64255: ST_TO_ADDR
// if units then
64256: LD_VAR 0 7
64260: IFFALSE 64281
// begin ComExitBuilding ( units [ 1 ] ) ;
64262: LD_VAR 0 7
64266: PUSH
64267: LD_INT 1
64269: ARRAY
64270: PPUSH
64271: CALL_OW 122
// exit ;
64275: POP
64276: POP
64277: POP
64278: POP
64279: GO 64293
// end ; end ;
64281: GO 64223
64283: POP
64284: POP
// end ; end ; exit ;
64285: POP
64286: POP
64287: GO 64293
// end ; end ;
64289: GO 63647
64291: POP
64292: POP
// end ;
64293: LD_VAR 0 2
64297: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64298: LD_INT 0
64300: PPUSH
64301: PPUSH
64302: PPUSH
64303: PPUSH
64304: PPUSH
64305: PPUSH
64306: PPUSH
// if not mc_bases or not skirmish then
64307: LD_EXP 102
64311: NOT
64312: PUSH
64313: LD_EXP 100
64317: NOT
64318: OR
64319: IFFALSE 64323
// exit ;
64321: GO 64554
// btype := GetBType ( building ) ;
64323: LD_ADDR_VAR 0 6
64327: PUSH
64328: LD_VAR 0 1
64332: PPUSH
64333: CALL_OW 266
64337: ST_TO_ADDR
// x := GetX ( building ) ;
64338: LD_ADDR_VAR 0 7
64342: PUSH
64343: LD_VAR 0 1
64347: PPUSH
64348: CALL_OW 250
64352: ST_TO_ADDR
// y := GetY ( building ) ;
64353: LD_ADDR_VAR 0 8
64357: PUSH
64358: LD_VAR 0 1
64362: PPUSH
64363: CALL_OW 251
64367: ST_TO_ADDR
// d := GetDir ( building ) ;
64368: LD_ADDR_VAR 0 9
64372: PUSH
64373: LD_VAR 0 1
64377: PPUSH
64378: CALL_OW 254
64382: ST_TO_ADDR
// for i = 1 to mc_bases do
64383: LD_ADDR_VAR 0 4
64387: PUSH
64388: DOUBLE
64389: LD_INT 1
64391: DEC
64392: ST_TO_ADDR
64393: LD_EXP 102
64397: PUSH
64398: FOR_TO
64399: IFFALSE 64552
// begin if not mc_build_list [ i ] then
64401: LD_EXP 107
64405: PUSH
64406: LD_VAR 0 4
64410: ARRAY
64411: NOT
64412: IFFALSE 64416
// continue ;
64414: GO 64398
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64416: LD_VAR 0 6
64420: PUSH
64421: LD_VAR 0 7
64425: PUSH
64426: LD_VAR 0 8
64430: PUSH
64431: LD_VAR 0 9
64435: PUSH
64436: EMPTY
64437: LIST
64438: LIST
64439: LIST
64440: LIST
64441: PPUSH
64442: LD_EXP 107
64446: PUSH
64447: LD_VAR 0 4
64451: ARRAY
64452: PUSH
64453: LD_INT 1
64455: ARRAY
64456: PPUSH
64457: CALL 78382 0 2
64461: IFFALSE 64550
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64463: LD_ADDR_EXP 107
64467: PUSH
64468: LD_EXP 107
64472: PPUSH
64473: LD_VAR 0 4
64477: PPUSH
64478: LD_EXP 107
64482: PUSH
64483: LD_VAR 0 4
64487: ARRAY
64488: PPUSH
64489: LD_INT 1
64491: PPUSH
64492: CALL_OW 3
64496: PPUSH
64497: CALL_OW 1
64501: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64502: LD_ADDR_EXP 109
64506: PUSH
64507: LD_EXP 109
64511: PPUSH
64512: LD_VAR 0 4
64516: PUSH
64517: LD_EXP 109
64521: PUSH
64522: LD_VAR 0 4
64526: ARRAY
64527: PUSH
64528: LD_INT 1
64530: PLUS
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PPUSH
64536: LD_VAR 0 1
64540: PPUSH
64541: CALL 72213 0 3
64545: ST_TO_ADDR
// exit ;
64546: POP
64547: POP
64548: GO 64554
// end ; end ;
64550: GO 64398
64552: POP
64553: POP
// end ;
64554: LD_VAR 0 3
64558: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64559: LD_INT 0
64561: PPUSH
64562: PPUSH
64563: PPUSH
// if not mc_bases or not skirmish then
64564: LD_EXP 102
64568: NOT
64569: PUSH
64570: LD_EXP 100
64574: NOT
64575: OR
64576: IFFALSE 64580
// exit ;
64578: GO 64770
// for i = 1 to mc_bases do
64580: LD_ADDR_VAR 0 4
64584: PUSH
64585: DOUBLE
64586: LD_INT 1
64588: DEC
64589: ST_TO_ADDR
64590: LD_EXP 102
64594: PUSH
64595: FOR_TO
64596: IFFALSE 64683
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64598: LD_VAR 0 1
64602: PUSH
64603: LD_EXP 110
64607: PUSH
64608: LD_VAR 0 4
64612: ARRAY
64613: IN
64614: PUSH
64615: LD_VAR 0 1
64619: PUSH
64620: LD_EXP 111
64624: PUSH
64625: LD_VAR 0 4
64629: ARRAY
64630: IN
64631: NOT
64632: AND
64633: IFFALSE 64681
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64635: LD_ADDR_EXP 111
64639: PUSH
64640: LD_EXP 111
64644: PPUSH
64645: LD_VAR 0 4
64649: PUSH
64650: LD_EXP 111
64654: PUSH
64655: LD_VAR 0 4
64659: ARRAY
64660: PUSH
64661: LD_INT 1
64663: PLUS
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PPUSH
64669: LD_VAR 0 1
64673: PPUSH
64674: CALL 72213 0 3
64678: ST_TO_ADDR
// break ;
64679: GO 64683
// end ; end ;
64681: GO 64595
64683: POP
64684: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64685: LD_VAR 0 1
64689: PPUSH
64690: CALL_OW 257
64694: PUSH
64695: LD_EXP 128
64699: IN
64700: PUSH
64701: LD_VAR 0 1
64705: PPUSH
64706: CALL_OW 266
64710: PUSH
64711: LD_INT 5
64713: EQUAL
64714: AND
64715: PUSH
64716: LD_VAR 0 2
64720: PPUSH
64721: CALL_OW 110
64725: PUSH
64726: LD_INT 18
64728: NONEQUAL
64729: AND
64730: IFFALSE 64770
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64732: LD_VAR 0 2
64736: PPUSH
64737: CALL_OW 257
64741: PUSH
64742: LD_INT 5
64744: PUSH
64745: LD_INT 8
64747: PUSH
64748: LD_INT 9
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: LIST
64755: IN
64756: IFFALSE 64770
// SetClass ( unit , 1 ) ;
64758: LD_VAR 0 2
64762: PPUSH
64763: LD_INT 1
64765: PPUSH
64766: CALL_OW 336
// end ;
64770: LD_VAR 0 3
64774: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64775: LD_INT 0
64777: PPUSH
64778: PPUSH
// if not mc_bases or not skirmish then
64779: LD_EXP 102
64783: NOT
64784: PUSH
64785: LD_EXP 100
64789: NOT
64790: OR
64791: IFFALSE 64795
// exit ;
64793: GO 64911
// if GetLives ( abandoned_vehicle ) > 250 then
64795: LD_VAR 0 2
64799: PPUSH
64800: CALL_OW 256
64804: PUSH
64805: LD_INT 250
64807: GREATER
64808: IFFALSE 64812
// exit ;
64810: GO 64911
// for i = 1 to mc_bases do
64812: LD_ADDR_VAR 0 6
64816: PUSH
64817: DOUBLE
64818: LD_INT 1
64820: DEC
64821: ST_TO_ADDR
64822: LD_EXP 102
64826: PUSH
64827: FOR_TO
64828: IFFALSE 64909
// begin if driver in mc_bases [ i ] then
64830: LD_VAR 0 1
64834: PUSH
64835: LD_EXP 102
64839: PUSH
64840: LD_VAR 0 6
64844: ARRAY
64845: IN
64846: IFFALSE 64907
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64848: LD_VAR 0 1
64852: PPUSH
64853: LD_EXP 102
64857: PUSH
64858: LD_VAR 0 6
64862: ARRAY
64863: PPUSH
64864: LD_INT 2
64866: PUSH
64867: LD_INT 30
64869: PUSH
64870: LD_INT 0
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PUSH
64877: LD_INT 30
64879: PUSH
64880: LD_INT 1
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: LIST
64891: PPUSH
64892: CALL_OW 72
64896: PUSH
64897: LD_INT 1
64899: ARRAY
64900: PPUSH
64901: CALL_OW 112
// break ;
64905: GO 64909
// end ; end ;
64907: GO 64827
64909: POP
64910: POP
// end ; end_of_file
64911: LD_VAR 0 5
64915: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64916: LD_INT 0
64918: PPUSH
64919: PPUSH
// if exist_mode then
64920: LD_VAR 0 2
64924: IFFALSE 64949
// unit := CreateCharacter ( prefix & ident ) else
64926: LD_ADDR_VAR 0 5
64930: PUSH
64931: LD_VAR 0 3
64935: PUSH
64936: LD_VAR 0 1
64940: STR
64941: PPUSH
64942: CALL_OW 34
64946: ST_TO_ADDR
64947: GO 64964
// unit := NewCharacter ( ident ) ;
64949: LD_ADDR_VAR 0 5
64953: PUSH
64954: LD_VAR 0 1
64958: PPUSH
64959: CALL_OW 25
64963: ST_TO_ADDR
// result := unit ;
64964: LD_ADDR_VAR 0 4
64968: PUSH
64969: LD_VAR 0 5
64973: ST_TO_ADDR
// end ;
64974: LD_VAR 0 4
64978: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64979: LD_INT 0
64981: PPUSH
64982: PPUSH
// if not side or not nation then
64983: LD_VAR 0 1
64987: NOT
64988: PUSH
64989: LD_VAR 0 2
64993: NOT
64994: OR
64995: IFFALSE 64999
// exit ;
64997: GO 65703
// case nation of nation_american :
64999: LD_VAR 0 2
65003: PUSH
65004: LD_INT 1
65006: DOUBLE
65007: EQUAL
65008: IFTRUE 65012
65010: GO 65206
65012: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
65013: LD_ADDR_VAR 0 4
65017: PUSH
65018: LD_INT 35
65020: PUSH
65021: LD_INT 45
65023: PUSH
65024: LD_INT 46
65026: PUSH
65027: LD_INT 47
65029: PUSH
65030: LD_INT 82
65032: PUSH
65033: LD_INT 83
65035: PUSH
65036: LD_INT 84
65038: PUSH
65039: LD_INT 85
65041: PUSH
65042: LD_INT 86
65044: PUSH
65045: LD_INT 1
65047: PUSH
65048: LD_INT 2
65050: PUSH
65051: LD_INT 6
65053: PUSH
65054: LD_INT 15
65056: PUSH
65057: LD_INT 16
65059: PUSH
65060: LD_INT 7
65062: PUSH
65063: LD_INT 12
65065: PUSH
65066: LD_INT 13
65068: PUSH
65069: LD_INT 10
65071: PUSH
65072: LD_INT 14
65074: PUSH
65075: LD_INT 20
65077: PUSH
65078: LD_INT 21
65080: PUSH
65081: LD_INT 22
65083: PUSH
65084: LD_INT 25
65086: PUSH
65087: LD_INT 32
65089: PUSH
65090: LD_INT 27
65092: PUSH
65093: LD_INT 36
65095: PUSH
65096: LD_INT 69
65098: PUSH
65099: LD_INT 39
65101: PUSH
65102: LD_INT 34
65104: PUSH
65105: LD_INT 40
65107: PUSH
65108: LD_INT 48
65110: PUSH
65111: LD_INT 49
65113: PUSH
65114: LD_INT 50
65116: PUSH
65117: LD_INT 51
65119: PUSH
65120: LD_INT 52
65122: PUSH
65123: LD_INT 53
65125: PUSH
65126: LD_INT 54
65128: PUSH
65129: LD_INT 55
65131: PUSH
65132: LD_INT 56
65134: PUSH
65135: LD_INT 57
65137: PUSH
65138: LD_INT 58
65140: PUSH
65141: LD_INT 59
65143: PUSH
65144: LD_INT 60
65146: PUSH
65147: LD_INT 61
65149: PUSH
65150: LD_INT 62
65152: PUSH
65153: LD_INT 80
65155: PUSH
65156: EMPTY
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: LIST
65182: LIST
65183: LIST
65184: LIST
65185: LIST
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: LIST
65191: LIST
65192: LIST
65193: LIST
65194: LIST
65195: LIST
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: LIST
65203: ST_TO_ADDR
65204: GO 65627
65206: LD_INT 2
65208: DOUBLE
65209: EQUAL
65210: IFTRUE 65214
65212: GO 65416
65214: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65215: LD_ADDR_VAR 0 4
65219: PUSH
65220: LD_INT 35
65222: PUSH
65223: LD_INT 45
65225: PUSH
65226: LD_INT 46
65228: PUSH
65229: LD_INT 47
65231: PUSH
65232: LD_INT 82
65234: PUSH
65235: LD_INT 83
65237: PUSH
65238: LD_INT 84
65240: PUSH
65241: LD_INT 85
65243: PUSH
65244: LD_INT 87
65246: PUSH
65247: LD_INT 70
65249: PUSH
65250: LD_INT 1
65252: PUSH
65253: LD_INT 11
65255: PUSH
65256: LD_INT 3
65258: PUSH
65259: LD_INT 4
65261: PUSH
65262: LD_INT 5
65264: PUSH
65265: LD_INT 6
65267: PUSH
65268: LD_INT 15
65270: PUSH
65271: LD_INT 18
65273: PUSH
65274: LD_INT 7
65276: PUSH
65277: LD_INT 17
65279: PUSH
65280: LD_INT 8
65282: PUSH
65283: LD_INT 20
65285: PUSH
65286: LD_INT 21
65288: PUSH
65289: LD_INT 22
65291: PUSH
65292: LD_INT 72
65294: PUSH
65295: LD_INT 26
65297: PUSH
65298: LD_INT 69
65300: PUSH
65301: LD_INT 39
65303: PUSH
65304: LD_INT 40
65306: PUSH
65307: LD_INT 41
65309: PUSH
65310: LD_INT 42
65312: PUSH
65313: LD_INT 43
65315: PUSH
65316: LD_INT 48
65318: PUSH
65319: LD_INT 49
65321: PUSH
65322: LD_INT 50
65324: PUSH
65325: LD_INT 51
65327: PUSH
65328: LD_INT 52
65330: PUSH
65331: LD_INT 53
65333: PUSH
65334: LD_INT 54
65336: PUSH
65337: LD_INT 55
65339: PUSH
65340: LD_INT 56
65342: PUSH
65343: LD_INT 60
65345: PUSH
65346: LD_INT 61
65348: PUSH
65349: LD_INT 62
65351: PUSH
65352: LD_INT 66
65354: PUSH
65355: LD_INT 67
65357: PUSH
65358: LD_INT 68
65360: PUSH
65361: LD_INT 81
65363: PUSH
65364: EMPTY
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: LIST
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: LIST
65401: LIST
65402: LIST
65403: LIST
65404: LIST
65405: LIST
65406: LIST
65407: LIST
65408: LIST
65409: LIST
65410: LIST
65411: LIST
65412: LIST
65413: ST_TO_ADDR
65414: GO 65627
65416: LD_INT 3
65418: DOUBLE
65419: EQUAL
65420: IFTRUE 65424
65422: GO 65626
65424: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65425: LD_ADDR_VAR 0 4
65429: PUSH
65430: LD_INT 46
65432: PUSH
65433: LD_INT 47
65435: PUSH
65436: LD_INT 1
65438: PUSH
65439: LD_INT 2
65441: PUSH
65442: LD_INT 82
65444: PUSH
65445: LD_INT 83
65447: PUSH
65448: LD_INT 84
65450: PUSH
65451: LD_INT 85
65453: PUSH
65454: LD_INT 86
65456: PUSH
65457: LD_INT 11
65459: PUSH
65460: LD_INT 9
65462: PUSH
65463: LD_INT 20
65465: PUSH
65466: LD_INT 19
65468: PUSH
65469: LD_INT 21
65471: PUSH
65472: LD_INT 24
65474: PUSH
65475: LD_INT 22
65477: PUSH
65478: LD_INT 25
65480: PUSH
65481: LD_INT 28
65483: PUSH
65484: LD_INT 29
65486: PUSH
65487: LD_INT 30
65489: PUSH
65490: LD_INT 31
65492: PUSH
65493: LD_INT 37
65495: PUSH
65496: LD_INT 38
65498: PUSH
65499: LD_INT 32
65501: PUSH
65502: LD_INT 27
65504: PUSH
65505: LD_INT 33
65507: PUSH
65508: LD_INT 69
65510: PUSH
65511: LD_INT 39
65513: PUSH
65514: LD_INT 34
65516: PUSH
65517: LD_INT 40
65519: PUSH
65520: LD_INT 71
65522: PUSH
65523: LD_INT 23
65525: PUSH
65526: LD_INT 44
65528: PUSH
65529: LD_INT 48
65531: PUSH
65532: LD_INT 49
65534: PUSH
65535: LD_INT 50
65537: PUSH
65538: LD_INT 51
65540: PUSH
65541: LD_INT 52
65543: PUSH
65544: LD_INT 53
65546: PUSH
65547: LD_INT 54
65549: PUSH
65550: LD_INT 55
65552: PUSH
65553: LD_INT 56
65555: PUSH
65556: LD_INT 57
65558: PUSH
65559: LD_INT 58
65561: PUSH
65562: LD_INT 59
65564: PUSH
65565: LD_INT 63
65567: PUSH
65568: LD_INT 64
65570: PUSH
65571: LD_INT 65
65573: PUSH
65574: EMPTY
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: LIST
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: ST_TO_ADDR
65624: GO 65627
65626: POP
// if state > - 1 and state < 3 then
65627: LD_VAR 0 3
65631: PUSH
65632: LD_INT 1
65634: NEG
65635: GREATER
65636: PUSH
65637: LD_VAR 0 3
65641: PUSH
65642: LD_INT 3
65644: LESS
65645: AND
65646: IFFALSE 65703
// for i in result do
65648: LD_ADDR_VAR 0 5
65652: PUSH
65653: LD_VAR 0 4
65657: PUSH
65658: FOR_IN
65659: IFFALSE 65701
// if GetTech ( i , side ) <> state then
65661: LD_VAR 0 5
65665: PPUSH
65666: LD_VAR 0 1
65670: PPUSH
65671: CALL_OW 321
65675: PUSH
65676: LD_VAR 0 3
65680: NONEQUAL
65681: IFFALSE 65699
// result := result diff i ;
65683: LD_ADDR_VAR 0 4
65687: PUSH
65688: LD_VAR 0 4
65692: PUSH
65693: LD_VAR 0 5
65697: DIFF
65698: ST_TO_ADDR
65699: GO 65658
65701: POP
65702: POP
// end ;
65703: LD_VAR 0 4
65707: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65708: LD_INT 0
65710: PPUSH
65711: PPUSH
65712: PPUSH
// result := true ;
65713: LD_ADDR_VAR 0 3
65717: PUSH
65718: LD_INT 1
65720: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65721: LD_ADDR_VAR 0 5
65725: PUSH
65726: LD_VAR 0 2
65730: PPUSH
65731: CALL_OW 480
65735: ST_TO_ADDR
// if not tmp then
65736: LD_VAR 0 5
65740: NOT
65741: IFFALSE 65745
// exit ;
65743: GO 65794
// for i in tmp do
65745: LD_ADDR_VAR 0 4
65749: PUSH
65750: LD_VAR 0 5
65754: PUSH
65755: FOR_IN
65756: IFFALSE 65792
// if GetTech ( i , side ) <> state_researched then
65758: LD_VAR 0 4
65762: PPUSH
65763: LD_VAR 0 1
65767: PPUSH
65768: CALL_OW 321
65772: PUSH
65773: LD_INT 2
65775: NONEQUAL
65776: IFFALSE 65790
// begin result := false ;
65778: LD_ADDR_VAR 0 3
65782: PUSH
65783: LD_INT 0
65785: ST_TO_ADDR
// exit ;
65786: POP
65787: POP
65788: GO 65794
// end ;
65790: GO 65755
65792: POP
65793: POP
// end ;
65794: LD_VAR 0 3
65798: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65799: LD_INT 0
65801: PPUSH
65802: PPUSH
65803: PPUSH
65804: PPUSH
65805: PPUSH
65806: PPUSH
65807: PPUSH
65808: PPUSH
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
65813: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65814: LD_VAR 0 1
65818: NOT
65819: PUSH
65820: LD_VAR 0 1
65824: PPUSH
65825: CALL_OW 257
65829: PUSH
65830: LD_INT 9
65832: NONEQUAL
65833: OR
65834: IFFALSE 65838
// exit ;
65836: GO 66411
// side := GetSide ( unit ) ;
65838: LD_ADDR_VAR 0 9
65842: PUSH
65843: LD_VAR 0 1
65847: PPUSH
65848: CALL_OW 255
65852: ST_TO_ADDR
// tech_space := tech_spacanom ;
65853: LD_ADDR_VAR 0 12
65857: PUSH
65858: LD_INT 29
65860: ST_TO_ADDR
// tech_time := tech_taurad ;
65861: LD_ADDR_VAR 0 13
65865: PUSH
65866: LD_INT 28
65868: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65869: LD_ADDR_VAR 0 11
65873: PUSH
65874: LD_VAR 0 1
65878: PPUSH
65879: CALL_OW 310
65883: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65884: LD_VAR 0 11
65888: PPUSH
65889: CALL_OW 247
65893: PUSH
65894: LD_INT 2
65896: EQUAL
65897: IFFALSE 65901
// exit ;
65899: GO 66411
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65901: LD_ADDR_VAR 0 8
65905: PUSH
65906: LD_INT 81
65908: PUSH
65909: LD_VAR 0 9
65913: PUSH
65914: EMPTY
65915: LIST
65916: LIST
65917: PUSH
65918: LD_INT 3
65920: PUSH
65921: LD_INT 21
65923: PUSH
65924: LD_INT 3
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PUSH
65935: EMPTY
65936: LIST
65937: LIST
65938: PPUSH
65939: CALL_OW 69
65943: ST_TO_ADDR
// if not tmp then
65944: LD_VAR 0 8
65948: NOT
65949: IFFALSE 65953
// exit ;
65951: GO 66411
// if in_unit then
65953: LD_VAR 0 11
65957: IFFALSE 65981
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65959: LD_ADDR_VAR 0 10
65963: PUSH
65964: LD_VAR 0 8
65968: PPUSH
65969: LD_VAR 0 11
65973: PPUSH
65974: CALL_OW 74
65978: ST_TO_ADDR
65979: GO 66001
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65981: LD_ADDR_VAR 0 10
65985: PUSH
65986: LD_VAR 0 8
65990: PPUSH
65991: LD_VAR 0 1
65995: PPUSH
65996: CALL_OW 74
66000: ST_TO_ADDR
// if not enemy then
66001: LD_VAR 0 10
66005: NOT
66006: IFFALSE 66010
// exit ;
66008: GO 66411
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
66010: LD_VAR 0 11
66014: PUSH
66015: LD_VAR 0 11
66019: PPUSH
66020: LD_VAR 0 10
66024: PPUSH
66025: CALL_OW 296
66029: PUSH
66030: LD_INT 13
66032: GREATER
66033: AND
66034: PUSH
66035: LD_VAR 0 1
66039: PPUSH
66040: LD_VAR 0 10
66044: PPUSH
66045: CALL_OW 296
66049: PUSH
66050: LD_INT 12
66052: GREATER
66053: OR
66054: IFFALSE 66058
// exit ;
66056: GO 66411
// missile := [ 1 ] ;
66058: LD_ADDR_VAR 0 14
66062: PUSH
66063: LD_INT 1
66065: PUSH
66066: EMPTY
66067: LIST
66068: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66069: LD_VAR 0 9
66073: PPUSH
66074: LD_VAR 0 12
66078: PPUSH
66079: CALL_OW 325
66083: IFFALSE 66112
// missile := Insert ( missile , missile + 1 , 2 ) ;
66085: LD_ADDR_VAR 0 14
66089: PUSH
66090: LD_VAR 0 14
66094: PPUSH
66095: LD_VAR 0 14
66099: PUSH
66100: LD_INT 1
66102: PLUS
66103: PPUSH
66104: LD_INT 2
66106: PPUSH
66107: CALL_OW 2
66111: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66112: LD_VAR 0 9
66116: PPUSH
66117: LD_VAR 0 13
66121: PPUSH
66122: CALL_OW 325
66126: PUSH
66127: LD_VAR 0 10
66131: PPUSH
66132: CALL_OW 255
66136: PPUSH
66137: LD_VAR 0 13
66141: PPUSH
66142: CALL_OW 325
66146: NOT
66147: AND
66148: IFFALSE 66177
// missile := Insert ( missile , missile + 1 , 3 ) ;
66150: LD_ADDR_VAR 0 14
66154: PUSH
66155: LD_VAR 0 14
66159: PPUSH
66160: LD_VAR 0 14
66164: PUSH
66165: LD_INT 1
66167: PLUS
66168: PPUSH
66169: LD_INT 3
66171: PPUSH
66172: CALL_OW 2
66176: ST_TO_ADDR
// if missile < 2 then
66177: LD_VAR 0 14
66181: PUSH
66182: LD_INT 2
66184: LESS
66185: IFFALSE 66189
// exit ;
66187: GO 66411
// x := GetX ( enemy ) ;
66189: LD_ADDR_VAR 0 4
66193: PUSH
66194: LD_VAR 0 10
66198: PPUSH
66199: CALL_OW 250
66203: ST_TO_ADDR
// y := GetY ( enemy ) ;
66204: LD_ADDR_VAR 0 5
66208: PUSH
66209: LD_VAR 0 10
66213: PPUSH
66214: CALL_OW 251
66218: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66219: LD_ADDR_VAR 0 6
66223: PUSH
66224: LD_VAR 0 4
66228: PUSH
66229: LD_INT 1
66231: NEG
66232: PPUSH
66233: LD_INT 1
66235: PPUSH
66236: CALL_OW 12
66240: PLUS
66241: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66242: LD_ADDR_VAR 0 7
66246: PUSH
66247: LD_VAR 0 5
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: PPUSH
66256: LD_INT 1
66258: PPUSH
66259: CALL_OW 12
66263: PLUS
66264: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66265: LD_VAR 0 6
66269: PPUSH
66270: LD_VAR 0 7
66274: PPUSH
66275: CALL_OW 488
66279: NOT
66280: IFFALSE 66302
// begin _x := x ;
66282: LD_ADDR_VAR 0 6
66286: PUSH
66287: LD_VAR 0 4
66291: ST_TO_ADDR
// _y := y ;
66292: LD_ADDR_VAR 0 7
66296: PUSH
66297: LD_VAR 0 5
66301: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66302: LD_ADDR_VAR 0 3
66306: PUSH
66307: LD_INT 1
66309: PPUSH
66310: LD_VAR 0 14
66314: PPUSH
66315: CALL_OW 12
66319: ST_TO_ADDR
// case i of 1 :
66320: LD_VAR 0 3
66324: PUSH
66325: LD_INT 1
66327: DOUBLE
66328: EQUAL
66329: IFTRUE 66333
66331: GO 66350
66333: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66334: LD_VAR 0 1
66338: PPUSH
66339: LD_VAR 0 10
66343: PPUSH
66344: CALL_OW 115
66348: GO 66411
66350: LD_INT 2
66352: DOUBLE
66353: EQUAL
66354: IFTRUE 66358
66356: GO 66380
66358: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66359: LD_VAR 0 1
66363: PPUSH
66364: LD_VAR 0 6
66368: PPUSH
66369: LD_VAR 0 7
66373: PPUSH
66374: CALL_OW 153
66378: GO 66411
66380: LD_INT 3
66382: DOUBLE
66383: EQUAL
66384: IFTRUE 66388
66386: GO 66410
66388: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66389: LD_VAR 0 1
66393: PPUSH
66394: LD_VAR 0 6
66398: PPUSH
66399: LD_VAR 0 7
66403: PPUSH
66404: CALL_OW 154
66408: GO 66411
66410: POP
// end ;
66411: LD_VAR 0 2
66415: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66416: LD_INT 0
66418: PPUSH
66419: PPUSH
66420: PPUSH
66421: PPUSH
66422: PPUSH
66423: PPUSH
// if not unit or not building then
66424: LD_VAR 0 1
66428: NOT
66429: PUSH
66430: LD_VAR 0 2
66434: NOT
66435: OR
66436: IFFALSE 66440
// exit ;
66438: GO 66598
// x := GetX ( building ) ;
66440: LD_ADDR_VAR 0 5
66444: PUSH
66445: LD_VAR 0 2
66449: PPUSH
66450: CALL_OW 250
66454: ST_TO_ADDR
// y := GetY ( building ) ;
66455: LD_ADDR_VAR 0 6
66459: PUSH
66460: LD_VAR 0 2
66464: PPUSH
66465: CALL_OW 251
66469: ST_TO_ADDR
// for i = 0 to 5 do
66470: LD_ADDR_VAR 0 4
66474: PUSH
66475: DOUBLE
66476: LD_INT 0
66478: DEC
66479: ST_TO_ADDR
66480: LD_INT 5
66482: PUSH
66483: FOR_TO
66484: IFFALSE 66596
// begin _x := ShiftX ( x , i , 3 ) ;
66486: LD_ADDR_VAR 0 7
66490: PUSH
66491: LD_VAR 0 5
66495: PPUSH
66496: LD_VAR 0 4
66500: PPUSH
66501: LD_INT 3
66503: PPUSH
66504: CALL_OW 272
66508: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66509: LD_ADDR_VAR 0 8
66513: PUSH
66514: LD_VAR 0 6
66518: PPUSH
66519: LD_VAR 0 4
66523: PPUSH
66524: LD_INT 3
66526: PPUSH
66527: CALL_OW 273
66531: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66532: LD_VAR 0 7
66536: PPUSH
66537: LD_VAR 0 8
66541: PPUSH
66542: CALL_OW 488
66546: NOT
66547: IFFALSE 66551
// continue ;
66549: GO 66483
// if HexInfo ( _x , _y ) = 0 then
66551: LD_VAR 0 7
66555: PPUSH
66556: LD_VAR 0 8
66560: PPUSH
66561: CALL_OW 428
66565: PUSH
66566: LD_INT 0
66568: EQUAL
66569: IFFALSE 66594
// begin ComMoveXY ( unit , _x , _y ) ;
66571: LD_VAR 0 1
66575: PPUSH
66576: LD_VAR 0 7
66580: PPUSH
66581: LD_VAR 0 8
66585: PPUSH
66586: CALL_OW 111
// exit ;
66590: POP
66591: POP
66592: GO 66598
// end ; end ;
66594: GO 66483
66596: POP
66597: POP
// end ;
66598: LD_VAR 0 3
66602: RET
// export function ScanBase ( side , base_area ) ; begin
66603: LD_INT 0
66605: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66606: LD_ADDR_VAR 0 3
66610: PUSH
66611: LD_VAR 0 2
66615: PPUSH
66616: LD_INT 81
66618: PUSH
66619: LD_VAR 0 1
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PPUSH
66628: CALL_OW 70
66632: ST_TO_ADDR
// end ;
66633: LD_VAR 0 3
66637: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66638: LD_INT 0
66640: PPUSH
66641: PPUSH
66642: PPUSH
66643: PPUSH
66644: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66645: LD_VAR 0 1
66649: NOT
66650: PUSH
66651: LD_EXP 102
66655: PUSH
66656: LD_VAR 0 1
66660: ARRAY
66661: NOT
66662: OR
66663: PUSH
66664: LD_VAR 0 2
66668: NOT
66669: OR
66670: PUSH
66671: LD_VAR 0 3
66675: NOT
66676: OR
66677: IFFALSE 66681
// exit ;
66679: GO 67194
// side := mc_sides [ base ] ;
66681: LD_ADDR_VAR 0 6
66685: PUSH
66686: LD_EXP 128
66690: PUSH
66691: LD_VAR 0 1
66695: ARRAY
66696: ST_TO_ADDR
// if not side then
66697: LD_VAR 0 6
66701: NOT
66702: IFFALSE 66706
// exit ;
66704: GO 67194
// for i in solds do
66706: LD_ADDR_VAR 0 7
66710: PUSH
66711: LD_VAR 0 2
66715: PUSH
66716: FOR_IN
66717: IFFALSE 66778
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66719: LD_VAR 0 7
66723: PPUSH
66724: CALL_OW 310
66728: PPUSH
66729: CALL_OW 266
66733: PUSH
66734: LD_INT 32
66736: PUSH
66737: LD_INT 31
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: IN
66744: IFFALSE 66764
// solds := solds diff i else
66746: LD_ADDR_VAR 0 2
66750: PUSH
66751: LD_VAR 0 2
66755: PUSH
66756: LD_VAR 0 7
66760: DIFF
66761: ST_TO_ADDR
66762: GO 66776
// SetTag ( i , 18 ) ;
66764: LD_VAR 0 7
66768: PPUSH
66769: LD_INT 18
66771: PPUSH
66772: CALL_OW 109
66776: GO 66716
66778: POP
66779: POP
// if not solds then
66780: LD_VAR 0 2
66784: NOT
66785: IFFALSE 66789
// exit ;
66787: GO 67194
// repeat wait ( 0 0$1 ) ;
66789: LD_INT 35
66791: PPUSH
66792: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66796: LD_ADDR_VAR 0 5
66800: PUSH
66801: LD_VAR 0 6
66805: PPUSH
66806: LD_VAR 0 3
66810: PPUSH
66811: CALL 66603 0 2
66815: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66816: LD_EXP 102
66820: PUSH
66821: LD_VAR 0 1
66825: ARRAY
66826: NOT
66827: PUSH
66828: LD_EXP 102
66832: PUSH
66833: LD_VAR 0 1
66837: ARRAY
66838: PUSH
66839: EMPTY
66840: EQUAL
66841: OR
66842: IFFALSE 66879
// begin for i in solds do
66844: LD_ADDR_VAR 0 7
66848: PUSH
66849: LD_VAR 0 2
66853: PUSH
66854: FOR_IN
66855: IFFALSE 66868
// ComStop ( i ) ;
66857: LD_VAR 0 7
66861: PPUSH
66862: CALL_OW 141
66866: GO 66854
66868: POP
66869: POP
// solds := [ ] ;
66870: LD_ADDR_VAR 0 2
66874: PUSH
66875: EMPTY
66876: ST_TO_ADDR
// exit ;
66877: GO 67194
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66879: LD_VAR 0 5
66883: NOT
66884: PUSH
66885: LD_VAR 0 5
66889: PUSH
66890: LD_INT 3
66892: GREATER
66893: OR
66894: PUSH
66895: LD_EXP 124
66899: PUSH
66900: LD_VAR 0 1
66904: ARRAY
66905: OR
66906: IFFALSE 66947
// begin for i in solds do
66908: LD_ADDR_VAR 0 7
66912: PUSH
66913: LD_VAR 0 2
66917: PUSH
66918: FOR_IN
66919: IFFALSE 66943
// if HasTask ( i ) then
66921: LD_VAR 0 7
66925: PPUSH
66926: CALL_OW 314
66930: IFFALSE 66941
// ComStop ( i ) ;
66932: LD_VAR 0 7
66936: PPUSH
66937: CALL_OW 141
66941: GO 66918
66943: POP
66944: POP
// break ;
66945: GO 67182
// end ; for i in solds do
66947: LD_ADDR_VAR 0 7
66951: PUSH
66952: LD_VAR 0 2
66956: PUSH
66957: FOR_IN
66958: IFFALSE 67174
// begin if IsInUnit ( i ) then
66960: LD_VAR 0 7
66964: PPUSH
66965: CALL_OW 310
66969: IFFALSE 66980
// ComExitBuilding ( i ) ;
66971: LD_VAR 0 7
66975: PPUSH
66976: CALL_OW 122
// if GetLives ( i ) > 333 then
66980: LD_VAR 0 7
66984: PPUSH
66985: CALL_OW 256
66989: PUSH
66990: LD_INT 333
66992: GREATER
66993: IFFALSE 67021
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66995: LD_VAR 0 7
66999: PPUSH
67000: LD_VAR 0 5
67004: PPUSH
67005: LD_VAR 0 7
67009: PPUSH
67010: CALL_OW 74
67014: PPUSH
67015: CALL_OW 115
67019: GO 67172
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
67021: LD_ADDR_VAR 0 8
67025: PUSH
67026: LD_EXP 102
67030: PUSH
67031: LD_VAR 0 1
67035: ARRAY
67036: PPUSH
67037: LD_INT 2
67039: PUSH
67040: LD_INT 30
67042: PUSH
67043: LD_INT 0
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 30
67052: PUSH
67053: LD_INT 1
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 30
67062: PUSH
67063: LD_INT 6
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: EMPTY
67071: LIST
67072: LIST
67073: LIST
67074: LIST
67075: PPUSH
67076: CALL_OW 72
67080: PPUSH
67081: LD_VAR 0 7
67085: PPUSH
67086: CALL_OW 74
67090: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
67091: LD_VAR 0 7
67095: PPUSH
67096: LD_VAR 0 8
67100: PPUSH
67101: CALL_OW 250
67105: PPUSH
67106: LD_INT 3
67108: PPUSH
67109: LD_INT 5
67111: PPUSH
67112: CALL_OW 272
67116: PPUSH
67117: LD_VAR 0 8
67121: PPUSH
67122: CALL_OW 251
67126: PPUSH
67127: LD_INT 3
67129: PPUSH
67130: LD_INT 5
67132: PPUSH
67133: CALL_OW 273
67137: PPUSH
67138: CALL_OW 111
// SetTag ( i , 0 ) ;
67142: LD_VAR 0 7
67146: PPUSH
67147: LD_INT 0
67149: PPUSH
67150: CALL_OW 109
// solds := solds diff i ;
67154: LD_ADDR_VAR 0 2
67158: PUSH
67159: LD_VAR 0 2
67163: PUSH
67164: LD_VAR 0 7
67168: DIFF
67169: ST_TO_ADDR
// continue ;
67170: GO 66957
// end ; end ;
67172: GO 66957
67174: POP
67175: POP
// until solds ;
67176: LD_VAR 0 2
67180: IFFALSE 66789
// MC_Reset ( base , 18 ) ;
67182: LD_VAR 0 1
67186: PPUSH
67187: LD_INT 18
67189: PPUSH
67190: CALL 38955 0 2
// end ;
67194: LD_VAR 0 4
67198: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67199: LD_INT 0
67201: PPUSH
67202: PPUSH
67203: PPUSH
67204: PPUSH
67205: PPUSH
67206: PPUSH
67207: PPUSH
67208: PPUSH
67209: PPUSH
67210: PPUSH
67211: PPUSH
67212: PPUSH
67213: PPUSH
67214: PPUSH
67215: PPUSH
67216: PPUSH
67217: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67218: LD_ADDR_VAR 0 13
67222: PUSH
67223: LD_EXP 102
67227: PUSH
67228: LD_VAR 0 1
67232: ARRAY
67233: PPUSH
67234: LD_INT 25
67236: PUSH
67237: LD_INT 3
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PPUSH
67244: CALL_OW 72
67248: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67249: LD_EXP 142
67253: PUSH
67254: LD_VAR 0 1
67258: ARRAY
67259: IFFALSE 67283
// mechs := mechs diff mc_remote_driver [ base ] ;
67261: LD_ADDR_VAR 0 13
67265: PUSH
67266: LD_VAR 0 13
67270: PUSH
67271: LD_EXP 142
67275: PUSH
67276: LD_VAR 0 1
67280: ARRAY
67281: DIFF
67282: ST_TO_ADDR
// for i in mechs do
67283: LD_ADDR_VAR 0 5
67287: PUSH
67288: LD_VAR 0 13
67292: PUSH
67293: FOR_IN
67294: IFFALSE 67329
// if GetTag ( i ) > 0 then
67296: LD_VAR 0 5
67300: PPUSH
67301: CALL_OW 110
67305: PUSH
67306: LD_INT 0
67308: GREATER
67309: IFFALSE 67327
// mechs := mechs diff i ;
67311: LD_ADDR_VAR 0 13
67315: PUSH
67316: LD_VAR 0 13
67320: PUSH
67321: LD_VAR 0 5
67325: DIFF
67326: ST_TO_ADDR
67327: GO 67293
67329: POP
67330: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67331: LD_ADDR_VAR 0 9
67335: PUSH
67336: LD_EXP 102
67340: PUSH
67341: LD_VAR 0 1
67345: ARRAY
67346: PPUSH
67347: LD_INT 2
67349: PUSH
67350: LD_INT 25
67352: PUSH
67353: LD_INT 1
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 25
67362: PUSH
67363: LD_INT 5
67365: PUSH
67366: EMPTY
67367: LIST
67368: LIST
67369: PUSH
67370: LD_INT 25
67372: PUSH
67373: LD_INT 8
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 25
67382: PUSH
67383: LD_INT 9
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: PPUSH
67397: CALL_OW 72
67401: ST_TO_ADDR
// if not defenders and not solds then
67402: LD_VAR 0 2
67406: NOT
67407: PUSH
67408: LD_VAR 0 9
67412: NOT
67413: AND
67414: IFFALSE 67418
// exit ;
67416: GO 69044
// depot_under_attack := false ;
67418: LD_ADDR_VAR 0 17
67422: PUSH
67423: LD_INT 0
67425: ST_TO_ADDR
// sold_defenders := [ ] ;
67426: LD_ADDR_VAR 0 18
67430: PUSH
67431: EMPTY
67432: ST_TO_ADDR
// if mechs then
67433: LD_VAR 0 13
67437: IFFALSE 67566
// for i in defenders do
67439: LD_ADDR_VAR 0 5
67443: PUSH
67444: LD_VAR 0 2
67448: PUSH
67449: FOR_IN
67450: IFFALSE 67564
// begin SetTag ( i , 20 ) ;
67452: LD_VAR 0 5
67456: PPUSH
67457: LD_INT 20
67459: PPUSH
67460: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67464: LD_VAR 0 5
67468: PPUSH
67469: CALL_OW 263
67473: PUSH
67474: LD_INT 1
67476: EQUAL
67477: PUSH
67478: LD_VAR 0 5
67482: PPUSH
67483: CALL_OW 311
67487: NOT
67488: AND
67489: PUSH
67490: LD_VAR 0 13
67494: AND
67495: IFFALSE 67562
// begin un := mechs [ 1 ] ;
67497: LD_ADDR_VAR 0 11
67501: PUSH
67502: LD_VAR 0 13
67506: PUSH
67507: LD_INT 1
67509: ARRAY
67510: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67511: LD_VAR 0 11
67515: PPUSH
67516: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67520: LD_VAR 0 11
67524: PPUSH
67525: LD_VAR 0 5
67529: PPUSH
67530: CALL_OW 180
// SetTag ( un , 19 ) ;
67534: LD_VAR 0 11
67538: PPUSH
67539: LD_INT 19
67541: PPUSH
67542: CALL_OW 109
// mechs := mechs diff un ;
67546: LD_ADDR_VAR 0 13
67550: PUSH
67551: LD_VAR 0 13
67555: PUSH
67556: LD_VAR 0 11
67560: DIFF
67561: ST_TO_ADDR
// end ; end ;
67562: GO 67449
67564: POP
67565: POP
// if solds then
67566: LD_VAR 0 9
67570: IFFALSE 67629
// for i in solds do
67572: LD_ADDR_VAR 0 5
67576: PUSH
67577: LD_VAR 0 9
67581: PUSH
67582: FOR_IN
67583: IFFALSE 67627
// if not GetTag ( i ) then
67585: LD_VAR 0 5
67589: PPUSH
67590: CALL_OW 110
67594: NOT
67595: IFFALSE 67625
// begin defenders := defenders union i ;
67597: LD_ADDR_VAR 0 2
67601: PUSH
67602: LD_VAR 0 2
67606: PUSH
67607: LD_VAR 0 5
67611: UNION
67612: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67613: LD_VAR 0 5
67617: PPUSH
67618: LD_INT 18
67620: PPUSH
67621: CALL_OW 109
// end ;
67625: GO 67582
67627: POP
67628: POP
// repeat wait ( 0 0$1 ) ;
67629: LD_INT 35
67631: PPUSH
67632: CALL_OW 67
// enemy := mc_scan [ base ] ;
67636: LD_ADDR_VAR 0 3
67640: PUSH
67641: LD_EXP 125
67645: PUSH
67646: LD_VAR 0 1
67650: ARRAY
67651: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67652: LD_EXP 102
67656: PUSH
67657: LD_VAR 0 1
67661: ARRAY
67662: NOT
67663: PUSH
67664: LD_EXP 102
67668: PUSH
67669: LD_VAR 0 1
67673: ARRAY
67674: PUSH
67675: EMPTY
67676: EQUAL
67677: OR
67678: IFFALSE 67715
// begin for i in defenders do
67680: LD_ADDR_VAR 0 5
67684: PUSH
67685: LD_VAR 0 2
67689: PUSH
67690: FOR_IN
67691: IFFALSE 67704
// ComStop ( i ) ;
67693: LD_VAR 0 5
67697: PPUSH
67698: CALL_OW 141
67702: GO 67690
67704: POP
67705: POP
// defenders := [ ] ;
67706: LD_ADDR_VAR 0 2
67710: PUSH
67711: EMPTY
67712: ST_TO_ADDR
// exit ;
67713: GO 69044
// end ; for i in defenders do
67715: LD_ADDR_VAR 0 5
67719: PUSH
67720: LD_VAR 0 2
67724: PUSH
67725: FOR_IN
67726: IFFALSE 68544
// begin e := NearestUnitToUnit ( enemy , i ) ;
67728: LD_ADDR_VAR 0 14
67732: PUSH
67733: LD_VAR 0 3
67737: PPUSH
67738: LD_VAR 0 5
67742: PPUSH
67743: CALL_OW 74
67747: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67748: LD_ADDR_VAR 0 8
67752: PUSH
67753: LD_EXP 102
67757: PUSH
67758: LD_VAR 0 1
67762: ARRAY
67763: PPUSH
67764: LD_INT 2
67766: PUSH
67767: LD_INT 30
67769: PUSH
67770: LD_INT 0
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 30
67779: PUSH
67780: LD_INT 1
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: LIST
67791: PPUSH
67792: CALL_OW 72
67796: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67797: LD_ADDR_VAR 0 17
67801: PUSH
67802: LD_VAR 0 8
67806: NOT
67807: PUSH
67808: LD_VAR 0 8
67812: PPUSH
67813: LD_INT 3
67815: PUSH
67816: LD_INT 24
67818: PUSH
67819: LD_INT 600
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PPUSH
67830: CALL_OW 72
67834: OR
67835: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67836: LD_VAR 0 5
67840: PPUSH
67841: CALL_OW 247
67845: PUSH
67846: LD_INT 2
67848: DOUBLE
67849: EQUAL
67850: IFTRUE 67854
67852: GO 68250
67854: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67855: LD_VAR 0 5
67859: PPUSH
67860: CALL_OW 256
67864: PUSH
67865: LD_INT 650
67867: GREATER
67868: PUSH
67869: LD_VAR 0 5
67873: PPUSH
67874: LD_VAR 0 14
67878: PPUSH
67879: CALL_OW 296
67883: PUSH
67884: LD_INT 40
67886: LESS
67887: PUSH
67888: LD_VAR 0 14
67892: PPUSH
67893: LD_EXP 127
67897: PUSH
67898: LD_VAR 0 1
67902: ARRAY
67903: PPUSH
67904: CALL_OW 308
67908: OR
67909: AND
67910: IFFALSE 68032
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67912: LD_VAR 0 5
67916: PPUSH
67917: CALL_OW 262
67921: PUSH
67922: LD_INT 1
67924: EQUAL
67925: PUSH
67926: LD_VAR 0 5
67930: PPUSH
67931: CALL_OW 261
67935: PUSH
67936: LD_INT 30
67938: LESS
67939: AND
67940: PUSH
67941: LD_VAR 0 8
67945: AND
67946: IFFALSE 68016
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67948: LD_VAR 0 5
67952: PPUSH
67953: LD_VAR 0 8
67957: PPUSH
67958: LD_VAR 0 5
67962: PPUSH
67963: CALL_OW 74
67967: PPUSH
67968: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67972: LD_VAR 0 5
67976: PPUSH
67977: LD_VAR 0 8
67981: PPUSH
67982: LD_VAR 0 5
67986: PPUSH
67987: CALL_OW 74
67991: PPUSH
67992: CALL_OW 296
67996: PUSH
67997: LD_INT 6
67999: LESS
68000: IFFALSE 68014
// SetFuel ( i , 100 ) ;
68002: LD_VAR 0 5
68006: PPUSH
68007: LD_INT 100
68009: PPUSH
68010: CALL_OW 240
// end else
68014: GO 68030
// ComAttackUnit ( i , e ) ;
68016: LD_VAR 0 5
68020: PPUSH
68021: LD_VAR 0 14
68025: PPUSH
68026: CALL_OW 115
// end else
68030: GO 68133
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
68032: LD_VAR 0 14
68036: PPUSH
68037: LD_EXP 127
68041: PUSH
68042: LD_VAR 0 1
68046: ARRAY
68047: PPUSH
68048: CALL_OW 308
68052: NOT
68053: PUSH
68054: LD_VAR 0 5
68058: PPUSH
68059: LD_VAR 0 14
68063: PPUSH
68064: CALL_OW 296
68068: PUSH
68069: LD_INT 40
68071: GREATEREQUAL
68072: AND
68073: PUSH
68074: LD_VAR 0 5
68078: PPUSH
68079: CALL_OW 256
68083: PUSH
68084: LD_INT 650
68086: LESSEQUAL
68087: OR
68088: PUSH
68089: LD_VAR 0 5
68093: PPUSH
68094: LD_EXP 126
68098: PUSH
68099: LD_VAR 0 1
68103: ARRAY
68104: PPUSH
68105: CALL_OW 308
68109: NOT
68110: AND
68111: IFFALSE 68133
// ComMoveToArea ( i , mc_parking [ base ] ) ;
68113: LD_VAR 0 5
68117: PPUSH
68118: LD_EXP 126
68122: PUSH
68123: LD_VAR 0 1
68127: ARRAY
68128: PPUSH
68129: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
68133: LD_VAR 0 5
68137: PPUSH
68138: CALL_OW 256
68142: PUSH
68143: LD_INT 998
68145: LESS
68146: PUSH
68147: LD_VAR 0 5
68151: PPUSH
68152: CALL_OW 263
68156: PUSH
68157: LD_INT 1
68159: EQUAL
68160: AND
68161: PUSH
68162: LD_VAR 0 5
68166: PPUSH
68167: CALL_OW 311
68171: AND
68172: PUSH
68173: LD_VAR 0 5
68177: PPUSH
68178: LD_EXP 126
68182: PUSH
68183: LD_VAR 0 1
68187: ARRAY
68188: PPUSH
68189: CALL_OW 308
68193: AND
68194: IFFALSE 68248
// begin mech := IsDrivenBy ( i ) ;
68196: LD_ADDR_VAR 0 10
68200: PUSH
68201: LD_VAR 0 5
68205: PPUSH
68206: CALL_OW 311
68210: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68211: LD_VAR 0 10
68215: PPUSH
68216: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68220: LD_VAR 0 10
68224: PPUSH
68225: LD_VAR 0 5
68229: PPUSH
68230: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68234: LD_VAR 0 10
68238: PPUSH
68239: LD_VAR 0 5
68243: PPUSH
68244: CALL_OW 180
// end ; end ; unit_human :
68248: GO 68515
68250: LD_INT 1
68252: DOUBLE
68253: EQUAL
68254: IFTRUE 68258
68256: GO 68514
68258: POP
// begin b := IsInUnit ( i ) ;
68259: LD_ADDR_VAR 0 19
68263: PUSH
68264: LD_VAR 0 5
68268: PPUSH
68269: CALL_OW 310
68273: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68274: LD_ADDR_VAR 0 20
68278: PUSH
68279: LD_VAR 0 19
68283: NOT
68284: PUSH
68285: LD_VAR 0 19
68289: PPUSH
68290: CALL_OW 266
68294: PUSH
68295: LD_INT 32
68297: PUSH
68298: LD_INT 31
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: IN
68305: OR
68306: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68307: LD_VAR 0 17
68311: PUSH
68312: LD_VAR 0 2
68316: PPUSH
68317: LD_INT 21
68319: PUSH
68320: LD_INT 2
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PPUSH
68327: CALL_OW 72
68331: PUSH
68332: LD_INT 1
68334: LESSEQUAL
68335: OR
68336: PUSH
68337: LD_VAR 0 20
68341: AND
68342: PUSH
68343: LD_VAR 0 5
68347: PUSH
68348: LD_VAR 0 18
68352: IN
68353: NOT
68354: AND
68355: IFFALSE 68448
// begin if b then
68357: LD_VAR 0 19
68361: IFFALSE 68410
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68363: LD_VAR 0 19
68367: PPUSH
68368: LD_VAR 0 3
68372: PPUSH
68373: LD_VAR 0 19
68377: PPUSH
68378: CALL_OW 74
68382: PPUSH
68383: CALL_OW 296
68387: PUSH
68388: LD_INT 10
68390: LESS
68391: PUSH
68392: LD_VAR 0 19
68396: PPUSH
68397: CALL_OW 461
68401: PUSH
68402: LD_INT 7
68404: NONEQUAL
68405: AND
68406: IFFALSE 68410
// continue ;
68408: GO 67725
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68410: LD_ADDR_VAR 0 18
68414: PUSH
68415: LD_VAR 0 18
68419: PPUSH
68420: LD_VAR 0 18
68424: PUSH
68425: LD_INT 1
68427: PLUS
68428: PPUSH
68429: LD_VAR 0 5
68433: PPUSH
68434: CALL_OW 1
68438: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68439: LD_VAR 0 5
68443: PPUSH
68444: CALL_OW 122
// end ; if sold_defenders then
68448: LD_VAR 0 18
68452: IFFALSE 68512
// if i in sold_defenders then
68454: LD_VAR 0 5
68458: PUSH
68459: LD_VAR 0 18
68463: IN
68464: IFFALSE 68512
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68466: LD_VAR 0 5
68470: PPUSH
68471: CALL_OW 314
68475: NOT
68476: PUSH
68477: LD_VAR 0 5
68481: PPUSH
68482: LD_VAR 0 14
68486: PPUSH
68487: CALL_OW 296
68491: PUSH
68492: LD_INT 30
68494: LESS
68495: AND
68496: IFFALSE 68512
// ComAttackUnit ( i , e ) ;
68498: LD_VAR 0 5
68502: PPUSH
68503: LD_VAR 0 14
68507: PPUSH
68508: CALL_OW 115
// end ; end ; end ;
68512: GO 68515
68514: POP
// if IsDead ( i ) then
68515: LD_VAR 0 5
68519: PPUSH
68520: CALL_OW 301
68524: IFFALSE 68542
// defenders := defenders diff i ;
68526: LD_ADDR_VAR 0 2
68530: PUSH
68531: LD_VAR 0 2
68535: PUSH
68536: LD_VAR 0 5
68540: DIFF
68541: ST_TO_ADDR
// end ;
68542: GO 67725
68544: POP
68545: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68546: LD_VAR 0 3
68550: NOT
68551: PUSH
68552: LD_VAR 0 2
68556: NOT
68557: OR
68558: PUSH
68559: LD_EXP 102
68563: PUSH
68564: LD_VAR 0 1
68568: ARRAY
68569: NOT
68570: OR
68571: IFFALSE 67629
// MC_Reset ( base , 18 ) ;
68573: LD_VAR 0 1
68577: PPUSH
68578: LD_INT 18
68580: PPUSH
68581: CALL 38955 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68585: LD_ADDR_VAR 0 2
68589: PUSH
68590: LD_VAR 0 2
68594: PUSH
68595: LD_VAR 0 2
68599: PPUSH
68600: LD_INT 2
68602: PUSH
68603: LD_INT 25
68605: PUSH
68606: LD_INT 1
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: PUSH
68613: LD_INT 25
68615: PUSH
68616: LD_INT 5
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 25
68625: PUSH
68626: LD_INT 8
68628: PUSH
68629: EMPTY
68630: LIST
68631: LIST
68632: PUSH
68633: LD_INT 25
68635: PUSH
68636: LD_INT 9
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: PPUSH
68650: CALL_OW 72
68654: DIFF
68655: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68656: LD_VAR 0 3
68660: NOT
68661: PUSH
68662: LD_VAR 0 2
68666: PPUSH
68667: LD_INT 21
68669: PUSH
68670: LD_INT 2
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PPUSH
68677: CALL_OW 72
68681: AND
68682: IFFALSE 69020
// begin tmp := FilterByTag ( defenders , 19 ) ;
68684: LD_ADDR_VAR 0 12
68688: PUSH
68689: LD_VAR 0 2
68693: PPUSH
68694: LD_INT 19
68696: PPUSH
68697: CALL 105483 0 2
68701: ST_TO_ADDR
// if tmp then
68702: LD_VAR 0 12
68706: IFFALSE 68776
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68708: LD_ADDR_VAR 0 12
68712: PUSH
68713: LD_VAR 0 12
68717: PPUSH
68718: LD_INT 25
68720: PUSH
68721: LD_INT 3
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: PPUSH
68728: CALL_OW 72
68732: ST_TO_ADDR
// if tmp then
68733: LD_VAR 0 12
68737: IFFALSE 68776
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68739: LD_ADDR_EXP 114
68743: PUSH
68744: LD_EXP 114
68748: PPUSH
68749: LD_VAR 0 1
68753: PPUSH
68754: LD_EXP 114
68758: PUSH
68759: LD_VAR 0 1
68763: ARRAY
68764: PUSH
68765: LD_VAR 0 12
68769: UNION
68770: PPUSH
68771: CALL_OW 1
68775: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68776: LD_VAR 0 1
68780: PPUSH
68781: LD_INT 19
68783: PPUSH
68784: CALL 38955 0 2
// repeat wait ( 0 0$1 ) ;
68788: LD_INT 35
68790: PPUSH
68791: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68795: LD_EXP 102
68799: PUSH
68800: LD_VAR 0 1
68804: ARRAY
68805: NOT
68806: PUSH
68807: LD_EXP 102
68811: PUSH
68812: LD_VAR 0 1
68816: ARRAY
68817: PUSH
68818: EMPTY
68819: EQUAL
68820: OR
68821: IFFALSE 68858
// begin for i in defenders do
68823: LD_ADDR_VAR 0 5
68827: PUSH
68828: LD_VAR 0 2
68832: PUSH
68833: FOR_IN
68834: IFFALSE 68847
// ComStop ( i ) ;
68836: LD_VAR 0 5
68840: PPUSH
68841: CALL_OW 141
68845: GO 68833
68847: POP
68848: POP
// defenders := [ ] ;
68849: LD_ADDR_VAR 0 2
68853: PUSH
68854: EMPTY
68855: ST_TO_ADDR
// exit ;
68856: GO 69044
// end ; for i in defenders do
68858: LD_ADDR_VAR 0 5
68862: PUSH
68863: LD_VAR 0 2
68867: PUSH
68868: FOR_IN
68869: IFFALSE 68958
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68871: LD_VAR 0 5
68875: PPUSH
68876: LD_EXP 126
68880: PUSH
68881: LD_VAR 0 1
68885: ARRAY
68886: PPUSH
68887: CALL_OW 308
68891: NOT
68892: IFFALSE 68916
// ComMoveToArea ( i , mc_parking [ base ] ) else
68894: LD_VAR 0 5
68898: PPUSH
68899: LD_EXP 126
68903: PUSH
68904: LD_VAR 0 1
68908: ARRAY
68909: PPUSH
68910: CALL_OW 113
68914: GO 68956
// if GetControl ( i ) = control_manual then
68916: LD_VAR 0 5
68920: PPUSH
68921: CALL_OW 263
68925: PUSH
68926: LD_INT 1
68928: EQUAL
68929: IFFALSE 68956
// if IsDrivenBy ( i ) then
68931: LD_VAR 0 5
68935: PPUSH
68936: CALL_OW 311
68940: IFFALSE 68956
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68942: LD_VAR 0 5
68946: PPUSH
68947: CALL_OW 311
68951: PPUSH
68952: CALL_OW 121
// end ;
68956: GO 68868
68958: POP
68959: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68960: LD_VAR 0 2
68964: PPUSH
68965: LD_INT 95
68967: PUSH
68968: LD_EXP 126
68972: PUSH
68973: LD_VAR 0 1
68977: ARRAY
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PPUSH
68983: CALL_OW 72
68987: PUSH
68988: LD_VAR 0 2
68992: EQUAL
68993: PUSH
68994: LD_EXP 125
68998: PUSH
68999: LD_VAR 0 1
69003: ARRAY
69004: OR
69005: PUSH
69006: LD_EXP 102
69010: PUSH
69011: LD_VAR 0 1
69015: ARRAY
69016: NOT
69017: OR
69018: IFFALSE 68788
// end ; MC_Reset ( base , 19 ) ;
69020: LD_VAR 0 1
69024: PPUSH
69025: LD_INT 19
69027: PPUSH
69028: CALL 38955 0 2
// MC_Reset ( base , 20 ) ;
69032: LD_VAR 0 1
69036: PPUSH
69037: LD_INT 20
69039: PPUSH
69040: CALL 38955 0 2
// end ;
69044: LD_VAR 0 4
69048: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69049: LD_INT 0
69051: PPUSH
69052: PPUSH
69053: PPUSH
69054: PPUSH
// result := false ;
69055: LD_ADDR_VAR 0 2
69059: PUSH
69060: LD_INT 0
69062: ST_TO_ADDR
// side := GetSide ( unit ) ;
69063: LD_ADDR_VAR 0 3
69067: PUSH
69068: LD_VAR 0 1
69072: PPUSH
69073: CALL_OW 255
69077: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69078: LD_ADDR_VAR 0 4
69082: PUSH
69083: LD_VAR 0 1
69087: PPUSH
69088: CALL_OW 248
69092: ST_TO_ADDR
// case nat of 1 :
69093: LD_VAR 0 4
69097: PUSH
69098: LD_INT 1
69100: DOUBLE
69101: EQUAL
69102: IFTRUE 69106
69104: GO 69117
69106: POP
// tech := tech_lassight ; 2 :
69107: LD_ADDR_VAR 0 5
69111: PUSH
69112: LD_INT 12
69114: ST_TO_ADDR
69115: GO 69156
69117: LD_INT 2
69119: DOUBLE
69120: EQUAL
69121: IFTRUE 69125
69123: GO 69136
69125: POP
// tech := tech_mortar ; 3 :
69126: LD_ADDR_VAR 0 5
69130: PUSH
69131: LD_INT 41
69133: ST_TO_ADDR
69134: GO 69156
69136: LD_INT 3
69138: DOUBLE
69139: EQUAL
69140: IFTRUE 69144
69142: GO 69155
69144: POP
// tech := tech_bazooka ; end ;
69145: LD_ADDR_VAR 0 5
69149: PUSH
69150: LD_INT 44
69152: ST_TO_ADDR
69153: GO 69156
69155: POP
// if Researched ( side , tech ) then
69156: LD_VAR 0 3
69160: PPUSH
69161: LD_VAR 0 5
69165: PPUSH
69166: CALL_OW 325
69170: IFFALSE 69197
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69172: LD_ADDR_VAR 0 2
69176: PUSH
69177: LD_INT 5
69179: PUSH
69180: LD_INT 8
69182: PUSH
69183: LD_INT 9
69185: PUSH
69186: EMPTY
69187: LIST
69188: LIST
69189: LIST
69190: PUSH
69191: LD_VAR 0 4
69195: ARRAY
69196: ST_TO_ADDR
// end ;
69197: LD_VAR 0 2
69201: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69202: LD_INT 0
69204: PPUSH
69205: PPUSH
69206: PPUSH
// if not mines then
69207: LD_VAR 0 2
69211: NOT
69212: IFFALSE 69216
// exit ;
69214: GO 69360
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69216: LD_ADDR_VAR 0 5
69220: PUSH
69221: LD_INT 81
69223: PUSH
69224: LD_VAR 0 1
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 3
69235: PUSH
69236: LD_INT 21
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PPUSH
69254: CALL_OW 69
69258: ST_TO_ADDR
// for i in mines do
69259: LD_ADDR_VAR 0 4
69263: PUSH
69264: LD_VAR 0 2
69268: PUSH
69269: FOR_IN
69270: IFFALSE 69358
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69272: LD_VAR 0 4
69276: PUSH
69277: LD_INT 1
69279: ARRAY
69280: PPUSH
69281: LD_VAR 0 4
69285: PUSH
69286: LD_INT 2
69288: ARRAY
69289: PPUSH
69290: CALL_OW 458
69294: NOT
69295: IFFALSE 69299
// continue ;
69297: GO 69269
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69299: LD_VAR 0 4
69303: PUSH
69304: LD_INT 1
69306: ARRAY
69307: PPUSH
69308: LD_VAR 0 4
69312: PUSH
69313: LD_INT 2
69315: ARRAY
69316: PPUSH
69317: CALL_OW 428
69321: PUSH
69322: LD_VAR 0 5
69326: IN
69327: IFFALSE 69356
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69329: LD_VAR 0 4
69333: PUSH
69334: LD_INT 1
69336: ARRAY
69337: PPUSH
69338: LD_VAR 0 4
69342: PUSH
69343: LD_INT 2
69345: ARRAY
69346: PPUSH
69347: LD_VAR 0 1
69351: PPUSH
69352: CALL_OW 456
// end ;
69356: GO 69269
69358: POP
69359: POP
// end ;
69360: LD_VAR 0 3
69364: RET
// export function Count ( array ) ; var i ; begin
69365: LD_INT 0
69367: PPUSH
69368: PPUSH
// result := 0 ;
69369: LD_ADDR_VAR 0 2
69373: PUSH
69374: LD_INT 0
69376: ST_TO_ADDR
// for i in array do
69377: LD_ADDR_VAR 0 3
69381: PUSH
69382: LD_VAR 0 1
69386: PUSH
69387: FOR_IN
69388: IFFALSE 69412
// if i then
69390: LD_VAR 0 3
69394: IFFALSE 69410
// result := result + 1 ;
69396: LD_ADDR_VAR 0 2
69400: PUSH
69401: LD_VAR 0 2
69405: PUSH
69406: LD_INT 1
69408: PLUS
69409: ST_TO_ADDR
69410: GO 69387
69412: POP
69413: POP
// end ;
69414: LD_VAR 0 2
69418: RET
// export function IsEmpty ( building ) ; begin
69419: LD_INT 0
69421: PPUSH
// if not building then
69422: LD_VAR 0 1
69426: NOT
69427: IFFALSE 69431
// exit ;
69429: GO 69474
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69431: LD_ADDR_VAR 0 2
69435: PUSH
69436: LD_VAR 0 1
69440: PUSH
69441: LD_INT 22
69443: PUSH
69444: LD_VAR 0 1
69448: PPUSH
69449: CALL_OW 255
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 58
69460: PUSH
69461: EMPTY
69462: LIST
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PPUSH
69468: CALL_OW 69
69472: IN
69473: ST_TO_ADDR
// end ;
69474: LD_VAR 0 2
69478: RET
// export function IsNotFull ( building ) ; begin
69479: LD_INT 0
69481: PPUSH
// if not building then
69482: LD_VAR 0 1
69486: NOT
69487: IFFALSE 69491
// exit ;
69489: GO 69510
// result := UnitsInside ( building ) < 6 ;
69491: LD_ADDR_VAR 0 2
69495: PUSH
69496: LD_VAR 0 1
69500: PPUSH
69501: CALL_OW 313
69505: PUSH
69506: LD_INT 6
69508: LESS
69509: ST_TO_ADDR
// end ;
69510: LD_VAR 0 2
69514: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69515: LD_INT 0
69517: PPUSH
69518: PPUSH
69519: PPUSH
69520: PPUSH
// tmp := [ ] ;
69521: LD_ADDR_VAR 0 3
69525: PUSH
69526: EMPTY
69527: ST_TO_ADDR
// list := [ ] ;
69528: LD_ADDR_VAR 0 5
69532: PUSH
69533: EMPTY
69534: ST_TO_ADDR
// for i = 16 to 25 do
69535: LD_ADDR_VAR 0 4
69539: PUSH
69540: DOUBLE
69541: LD_INT 16
69543: DEC
69544: ST_TO_ADDR
69545: LD_INT 25
69547: PUSH
69548: FOR_TO
69549: IFFALSE 69622
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69551: LD_ADDR_VAR 0 3
69555: PUSH
69556: LD_VAR 0 3
69560: PUSH
69561: LD_INT 22
69563: PUSH
69564: LD_VAR 0 1
69568: PPUSH
69569: CALL_OW 255
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 91
69580: PUSH
69581: LD_VAR 0 1
69585: PUSH
69586: LD_INT 6
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: LIST
69593: PUSH
69594: LD_INT 30
69596: PUSH
69597: LD_VAR 0 4
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: LIST
69610: PUSH
69611: EMPTY
69612: LIST
69613: PPUSH
69614: CALL_OW 69
69618: ADD
69619: ST_TO_ADDR
69620: GO 69548
69622: POP
69623: POP
// for i = 1 to tmp do
69624: LD_ADDR_VAR 0 4
69628: PUSH
69629: DOUBLE
69630: LD_INT 1
69632: DEC
69633: ST_TO_ADDR
69634: LD_VAR 0 3
69638: PUSH
69639: FOR_TO
69640: IFFALSE 69728
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69642: LD_ADDR_VAR 0 5
69646: PUSH
69647: LD_VAR 0 5
69651: PUSH
69652: LD_VAR 0 3
69656: PUSH
69657: LD_VAR 0 4
69661: ARRAY
69662: PPUSH
69663: CALL_OW 266
69667: PUSH
69668: LD_VAR 0 3
69672: PUSH
69673: LD_VAR 0 4
69677: ARRAY
69678: PPUSH
69679: CALL_OW 250
69683: PUSH
69684: LD_VAR 0 3
69688: PUSH
69689: LD_VAR 0 4
69693: ARRAY
69694: PPUSH
69695: CALL_OW 251
69699: PUSH
69700: LD_VAR 0 3
69704: PUSH
69705: LD_VAR 0 4
69709: ARRAY
69710: PPUSH
69711: CALL_OW 254
69715: PUSH
69716: EMPTY
69717: LIST
69718: LIST
69719: LIST
69720: LIST
69721: PUSH
69722: EMPTY
69723: LIST
69724: ADD
69725: ST_TO_ADDR
69726: GO 69639
69728: POP
69729: POP
// result := list ;
69730: LD_ADDR_VAR 0 2
69734: PUSH
69735: LD_VAR 0 5
69739: ST_TO_ADDR
// end ;
69740: LD_VAR 0 2
69744: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69745: LD_INT 0
69747: PPUSH
69748: PPUSH
69749: PPUSH
69750: PPUSH
69751: PPUSH
69752: PPUSH
69753: PPUSH
// if not factory then
69754: LD_VAR 0 1
69758: NOT
69759: IFFALSE 69763
// exit ;
69761: GO 70356
// if control = control_apeman then
69763: LD_VAR 0 4
69767: PUSH
69768: LD_INT 5
69770: EQUAL
69771: IFFALSE 69880
// begin tmp := UnitsInside ( factory ) ;
69773: LD_ADDR_VAR 0 8
69777: PUSH
69778: LD_VAR 0 1
69782: PPUSH
69783: CALL_OW 313
69787: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69788: LD_VAR 0 8
69792: PPUSH
69793: LD_INT 25
69795: PUSH
69796: LD_INT 12
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PPUSH
69803: CALL_OW 72
69807: NOT
69808: IFFALSE 69818
// control := control_manual ;
69810: LD_ADDR_VAR 0 4
69814: PUSH
69815: LD_INT 1
69817: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69818: LD_ADDR_VAR 0 8
69822: PUSH
69823: LD_VAR 0 1
69827: PPUSH
69828: CALL 69515 0 1
69832: ST_TO_ADDR
// if tmp then
69833: LD_VAR 0 8
69837: IFFALSE 69880
// begin for i in tmp do
69839: LD_ADDR_VAR 0 7
69843: PUSH
69844: LD_VAR 0 8
69848: PUSH
69849: FOR_IN
69850: IFFALSE 69878
// if i [ 1 ] = b_ext_radio then
69852: LD_VAR 0 7
69856: PUSH
69857: LD_INT 1
69859: ARRAY
69860: PUSH
69861: LD_INT 22
69863: EQUAL
69864: IFFALSE 69876
// begin control := control_remote ;
69866: LD_ADDR_VAR 0 4
69870: PUSH
69871: LD_INT 2
69873: ST_TO_ADDR
// break ;
69874: GO 69878
// end ;
69876: GO 69849
69878: POP
69879: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69880: LD_VAR 0 1
69884: PPUSH
69885: LD_VAR 0 2
69889: PPUSH
69890: LD_VAR 0 3
69894: PPUSH
69895: LD_VAR 0 4
69899: PPUSH
69900: LD_VAR 0 5
69904: PPUSH
69905: CALL_OW 448
69909: IFFALSE 69944
// begin result := [ chassis , engine , control , weapon ] ;
69911: LD_ADDR_VAR 0 6
69915: PUSH
69916: LD_VAR 0 2
69920: PUSH
69921: LD_VAR 0 3
69925: PUSH
69926: LD_VAR 0 4
69930: PUSH
69931: LD_VAR 0 5
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: ST_TO_ADDR
// exit ;
69942: GO 70356
// end ; _chassis := AvailableChassisList ( factory ) ;
69944: LD_ADDR_VAR 0 9
69948: PUSH
69949: LD_VAR 0 1
69953: PPUSH
69954: CALL_OW 475
69958: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69959: LD_ADDR_VAR 0 11
69963: PUSH
69964: LD_VAR 0 1
69968: PPUSH
69969: CALL_OW 476
69973: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69974: LD_ADDR_VAR 0 12
69978: PUSH
69979: LD_VAR 0 1
69983: PPUSH
69984: CALL_OW 477
69988: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69989: LD_ADDR_VAR 0 10
69993: PUSH
69994: LD_VAR 0 1
69998: PPUSH
69999: CALL_OW 478
70003: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
70004: LD_VAR 0 9
70008: NOT
70009: PUSH
70010: LD_VAR 0 11
70014: NOT
70015: OR
70016: PUSH
70017: LD_VAR 0 12
70021: NOT
70022: OR
70023: PUSH
70024: LD_VAR 0 10
70028: NOT
70029: OR
70030: IFFALSE 70065
// begin result := [ chassis , engine , control , weapon ] ;
70032: LD_ADDR_VAR 0 6
70036: PUSH
70037: LD_VAR 0 2
70041: PUSH
70042: LD_VAR 0 3
70046: PUSH
70047: LD_VAR 0 4
70051: PUSH
70052: LD_VAR 0 5
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: ST_TO_ADDR
// exit ;
70063: GO 70356
// end ; if not chassis in _chassis then
70065: LD_VAR 0 2
70069: PUSH
70070: LD_VAR 0 9
70074: IN
70075: NOT
70076: IFFALSE 70102
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70078: LD_ADDR_VAR 0 2
70082: PUSH
70083: LD_VAR 0 9
70087: PUSH
70088: LD_INT 1
70090: PPUSH
70091: LD_VAR 0 9
70095: PPUSH
70096: CALL_OW 12
70100: ARRAY
70101: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70102: LD_VAR 0 2
70106: PPUSH
70107: LD_VAR 0 3
70111: PPUSH
70112: CALL 70361 0 2
70116: NOT
70117: IFFALSE 70176
// repeat engine := _engine [ 1 ] ;
70119: LD_ADDR_VAR 0 3
70123: PUSH
70124: LD_VAR 0 11
70128: PUSH
70129: LD_INT 1
70131: ARRAY
70132: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70133: LD_ADDR_VAR 0 11
70137: PUSH
70138: LD_VAR 0 11
70142: PPUSH
70143: LD_INT 1
70145: PPUSH
70146: CALL_OW 3
70150: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70151: LD_VAR 0 2
70155: PPUSH
70156: LD_VAR 0 3
70160: PPUSH
70161: CALL 70361 0 2
70165: PUSH
70166: LD_VAR 0 11
70170: PUSH
70171: EMPTY
70172: EQUAL
70173: OR
70174: IFFALSE 70119
// if not control in _control then
70176: LD_VAR 0 4
70180: PUSH
70181: LD_VAR 0 12
70185: IN
70186: NOT
70187: IFFALSE 70213
// control := _control [ rand ( 1 , _control ) ] ;
70189: LD_ADDR_VAR 0 4
70193: PUSH
70194: LD_VAR 0 12
70198: PUSH
70199: LD_INT 1
70201: PPUSH
70202: LD_VAR 0 12
70206: PPUSH
70207: CALL_OW 12
70211: ARRAY
70212: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70213: LD_VAR 0 2
70217: PPUSH
70218: LD_VAR 0 5
70222: PPUSH
70223: CALL 70581 0 2
70227: NOT
70228: IFFALSE 70287
// repeat weapon := _weapon [ 1 ] ;
70230: LD_ADDR_VAR 0 5
70234: PUSH
70235: LD_VAR 0 10
70239: PUSH
70240: LD_INT 1
70242: ARRAY
70243: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70244: LD_ADDR_VAR 0 10
70248: PUSH
70249: LD_VAR 0 10
70253: PPUSH
70254: LD_INT 1
70256: PPUSH
70257: CALL_OW 3
70261: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70262: LD_VAR 0 2
70266: PPUSH
70267: LD_VAR 0 5
70271: PPUSH
70272: CALL 70581 0 2
70276: PUSH
70277: LD_VAR 0 10
70281: PUSH
70282: EMPTY
70283: EQUAL
70284: OR
70285: IFFALSE 70230
// result := [ ] ;
70287: LD_ADDR_VAR 0 6
70291: PUSH
70292: EMPTY
70293: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70294: LD_VAR 0 1
70298: PPUSH
70299: LD_VAR 0 2
70303: PPUSH
70304: LD_VAR 0 3
70308: PPUSH
70309: LD_VAR 0 4
70313: PPUSH
70314: LD_VAR 0 5
70318: PPUSH
70319: CALL_OW 448
70323: IFFALSE 70356
// result := [ chassis , engine , control , weapon ] ;
70325: LD_ADDR_VAR 0 6
70329: PUSH
70330: LD_VAR 0 2
70334: PUSH
70335: LD_VAR 0 3
70339: PUSH
70340: LD_VAR 0 4
70344: PUSH
70345: LD_VAR 0 5
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: LIST
70354: LIST
70355: ST_TO_ADDR
// end ;
70356: LD_VAR 0 6
70360: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70361: LD_INT 0
70363: PPUSH
// if not chassis or not engine then
70364: LD_VAR 0 1
70368: NOT
70369: PUSH
70370: LD_VAR 0 2
70374: NOT
70375: OR
70376: IFFALSE 70380
// exit ;
70378: GO 70576
// case engine of engine_solar :
70380: LD_VAR 0 2
70384: PUSH
70385: LD_INT 2
70387: DOUBLE
70388: EQUAL
70389: IFTRUE 70393
70391: GO 70431
70393: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70394: LD_ADDR_VAR 0 3
70398: PUSH
70399: LD_INT 11
70401: PUSH
70402: LD_INT 12
70404: PUSH
70405: LD_INT 13
70407: PUSH
70408: LD_INT 14
70410: PUSH
70411: LD_INT 1
70413: PUSH
70414: LD_INT 2
70416: PUSH
70417: LD_INT 3
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: ST_TO_ADDR
70429: GO 70560
70431: LD_INT 1
70433: DOUBLE
70434: EQUAL
70435: IFTRUE 70439
70437: GO 70501
70439: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70440: LD_ADDR_VAR 0 3
70444: PUSH
70445: LD_INT 11
70447: PUSH
70448: LD_INT 12
70450: PUSH
70451: LD_INT 13
70453: PUSH
70454: LD_INT 14
70456: PUSH
70457: LD_INT 1
70459: PUSH
70460: LD_INT 2
70462: PUSH
70463: LD_INT 3
70465: PUSH
70466: LD_INT 4
70468: PUSH
70469: LD_INT 5
70471: PUSH
70472: LD_INT 21
70474: PUSH
70475: LD_INT 23
70477: PUSH
70478: LD_INT 22
70480: PUSH
70481: LD_INT 24
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: LIST
70490: LIST
70491: LIST
70492: LIST
70493: LIST
70494: LIST
70495: LIST
70496: LIST
70497: LIST
70498: ST_TO_ADDR
70499: GO 70560
70501: LD_INT 3
70503: DOUBLE
70504: EQUAL
70505: IFTRUE 70509
70507: GO 70559
70509: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70510: LD_ADDR_VAR 0 3
70514: PUSH
70515: LD_INT 13
70517: PUSH
70518: LD_INT 14
70520: PUSH
70521: LD_INT 2
70523: PUSH
70524: LD_INT 3
70526: PUSH
70527: LD_INT 4
70529: PUSH
70530: LD_INT 5
70532: PUSH
70533: LD_INT 21
70535: PUSH
70536: LD_INT 22
70538: PUSH
70539: LD_INT 23
70541: PUSH
70542: LD_INT 24
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: ST_TO_ADDR
70557: GO 70560
70559: POP
// result := ( chassis in result ) ;
70560: LD_ADDR_VAR 0 3
70564: PUSH
70565: LD_VAR 0 1
70569: PUSH
70570: LD_VAR 0 3
70574: IN
70575: ST_TO_ADDR
// end ;
70576: LD_VAR 0 3
70580: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70581: LD_INT 0
70583: PPUSH
// if not chassis or not weapon then
70584: LD_VAR 0 1
70588: NOT
70589: PUSH
70590: LD_VAR 0 2
70594: NOT
70595: OR
70596: IFFALSE 70600
// exit ;
70598: GO 71626
// case weapon of us_machine_gun :
70600: LD_VAR 0 2
70604: PUSH
70605: LD_INT 2
70607: DOUBLE
70608: EQUAL
70609: IFTRUE 70613
70611: GO 70643
70613: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70614: LD_ADDR_VAR 0 3
70618: PUSH
70619: LD_INT 1
70621: PUSH
70622: LD_INT 2
70624: PUSH
70625: LD_INT 3
70627: PUSH
70628: LD_INT 4
70630: PUSH
70631: LD_INT 5
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: ST_TO_ADDR
70641: GO 71610
70643: LD_INT 3
70645: DOUBLE
70646: EQUAL
70647: IFTRUE 70651
70649: GO 70681
70651: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70652: LD_ADDR_VAR 0 3
70656: PUSH
70657: LD_INT 1
70659: PUSH
70660: LD_INT 2
70662: PUSH
70663: LD_INT 3
70665: PUSH
70666: LD_INT 4
70668: PUSH
70669: LD_INT 5
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: ST_TO_ADDR
70679: GO 71610
70681: LD_INT 11
70683: DOUBLE
70684: EQUAL
70685: IFTRUE 70689
70687: GO 70719
70689: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70690: LD_ADDR_VAR 0 3
70694: PUSH
70695: LD_INT 1
70697: PUSH
70698: LD_INT 2
70700: PUSH
70701: LD_INT 3
70703: PUSH
70704: LD_INT 4
70706: PUSH
70707: LD_INT 5
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: ST_TO_ADDR
70717: GO 71610
70719: LD_INT 4
70721: DOUBLE
70722: EQUAL
70723: IFTRUE 70727
70725: GO 70753
70727: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70728: LD_ADDR_VAR 0 3
70732: PUSH
70733: LD_INT 2
70735: PUSH
70736: LD_INT 3
70738: PUSH
70739: LD_INT 4
70741: PUSH
70742: LD_INT 5
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: ST_TO_ADDR
70751: GO 71610
70753: LD_INT 5
70755: DOUBLE
70756: EQUAL
70757: IFTRUE 70761
70759: GO 70787
70761: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70762: LD_ADDR_VAR 0 3
70766: PUSH
70767: LD_INT 2
70769: PUSH
70770: LD_INT 3
70772: PUSH
70773: LD_INT 4
70775: PUSH
70776: LD_INT 5
70778: PUSH
70779: EMPTY
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: ST_TO_ADDR
70785: GO 71610
70787: LD_INT 9
70789: DOUBLE
70790: EQUAL
70791: IFTRUE 70795
70793: GO 70821
70795: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70796: LD_ADDR_VAR 0 3
70800: PUSH
70801: LD_INT 2
70803: PUSH
70804: LD_INT 3
70806: PUSH
70807: LD_INT 4
70809: PUSH
70810: LD_INT 5
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: ST_TO_ADDR
70819: GO 71610
70821: LD_INT 7
70823: DOUBLE
70824: EQUAL
70825: IFTRUE 70829
70827: GO 70855
70829: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70830: LD_ADDR_VAR 0 3
70834: PUSH
70835: LD_INT 2
70837: PUSH
70838: LD_INT 3
70840: PUSH
70841: LD_INT 4
70843: PUSH
70844: LD_INT 5
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: ST_TO_ADDR
70853: GO 71610
70855: LD_INT 12
70857: DOUBLE
70858: EQUAL
70859: IFTRUE 70863
70861: GO 70889
70863: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70864: LD_ADDR_VAR 0 3
70868: PUSH
70869: LD_INT 2
70871: PUSH
70872: LD_INT 3
70874: PUSH
70875: LD_INT 4
70877: PUSH
70878: LD_INT 5
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: LIST
70885: LIST
70886: ST_TO_ADDR
70887: GO 71610
70889: LD_INT 13
70891: DOUBLE
70892: EQUAL
70893: IFTRUE 70897
70895: GO 70923
70897: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70898: LD_ADDR_VAR 0 3
70902: PUSH
70903: LD_INT 2
70905: PUSH
70906: LD_INT 3
70908: PUSH
70909: LD_INT 4
70911: PUSH
70912: LD_INT 5
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: LIST
70919: LIST
70920: ST_TO_ADDR
70921: GO 71610
70923: LD_INT 14
70925: DOUBLE
70926: EQUAL
70927: IFTRUE 70931
70929: GO 70949
70931: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70932: LD_ADDR_VAR 0 3
70936: PUSH
70937: LD_INT 4
70939: PUSH
70940: LD_INT 5
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: ST_TO_ADDR
70947: GO 71610
70949: LD_INT 6
70951: DOUBLE
70952: EQUAL
70953: IFTRUE 70957
70955: GO 70975
70957: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70958: LD_ADDR_VAR 0 3
70962: PUSH
70963: LD_INT 4
70965: PUSH
70966: LD_INT 5
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: ST_TO_ADDR
70973: GO 71610
70975: LD_INT 10
70977: DOUBLE
70978: EQUAL
70979: IFTRUE 70983
70981: GO 71001
70983: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70984: LD_ADDR_VAR 0 3
70988: PUSH
70989: LD_INT 4
70991: PUSH
70992: LD_INT 5
70994: PUSH
70995: EMPTY
70996: LIST
70997: LIST
70998: ST_TO_ADDR
70999: GO 71610
71001: LD_INT 22
71003: DOUBLE
71004: EQUAL
71005: IFTRUE 71009
71007: GO 71035
71009: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
71010: LD_ADDR_VAR 0 3
71014: PUSH
71015: LD_INT 11
71017: PUSH
71018: LD_INT 12
71020: PUSH
71021: LD_INT 13
71023: PUSH
71024: LD_INT 14
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: ST_TO_ADDR
71033: GO 71610
71035: LD_INT 23
71037: DOUBLE
71038: EQUAL
71039: IFTRUE 71043
71041: GO 71069
71043: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71044: LD_ADDR_VAR 0 3
71048: PUSH
71049: LD_INT 11
71051: PUSH
71052: LD_INT 12
71054: PUSH
71055: LD_INT 13
71057: PUSH
71058: LD_INT 14
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: ST_TO_ADDR
71067: GO 71610
71069: LD_INT 24
71071: DOUBLE
71072: EQUAL
71073: IFTRUE 71077
71075: GO 71103
71077: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71078: LD_ADDR_VAR 0 3
71082: PUSH
71083: LD_INT 11
71085: PUSH
71086: LD_INT 12
71088: PUSH
71089: LD_INT 13
71091: PUSH
71092: LD_INT 14
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: ST_TO_ADDR
71101: GO 71610
71103: LD_INT 30
71105: DOUBLE
71106: EQUAL
71107: IFTRUE 71111
71109: GO 71137
71111: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71112: LD_ADDR_VAR 0 3
71116: PUSH
71117: LD_INT 11
71119: PUSH
71120: LD_INT 12
71122: PUSH
71123: LD_INT 13
71125: PUSH
71126: LD_INT 14
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: ST_TO_ADDR
71135: GO 71610
71137: LD_INT 25
71139: DOUBLE
71140: EQUAL
71141: IFTRUE 71145
71143: GO 71163
71145: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71146: LD_ADDR_VAR 0 3
71150: PUSH
71151: LD_INT 13
71153: PUSH
71154: LD_INT 14
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: ST_TO_ADDR
71161: GO 71610
71163: LD_INT 27
71165: DOUBLE
71166: EQUAL
71167: IFTRUE 71171
71169: GO 71189
71171: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71172: LD_ADDR_VAR 0 3
71176: PUSH
71177: LD_INT 13
71179: PUSH
71180: LD_INT 14
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: ST_TO_ADDR
71187: GO 71610
71189: LD_INT 28
71191: DOUBLE
71192: EQUAL
71193: IFTRUE 71197
71195: GO 71215
71197: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71198: LD_ADDR_VAR 0 3
71202: PUSH
71203: LD_INT 13
71205: PUSH
71206: LD_INT 14
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: ST_TO_ADDR
71213: GO 71610
71215: LD_INT 29
71217: DOUBLE
71218: EQUAL
71219: IFTRUE 71223
71221: GO 71241
71223: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71224: LD_ADDR_VAR 0 3
71228: PUSH
71229: LD_INT 13
71231: PUSH
71232: LD_INT 14
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: ST_TO_ADDR
71239: GO 71610
71241: LD_INT 31
71243: DOUBLE
71244: EQUAL
71245: IFTRUE 71249
71247: GO 71267
71249: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71250: LD_ADDR_VAR 0 3
71254: PUSH
71255: LD_INT 13
71257: PUSH
71258: LD_INT 14
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: ST_TO_ADDR
71265: GO 71610
71267: LD_INT 26
71269: DOUBLE
71270: EQUAL
71271: IFTRUE 71275
71273: GO 71293
71275: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71276: LD_ADDR_VAR 0 3
71280: PUSH
71281: LD_INT 13
71283: PUSH
71284: LD_INT 14
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: ST_TO_ADDR
71291: GO 71610
71293: LD_INT 42
71295: DOUBLE
71296: EQUAL
71297: IFTRUE 71301
71299: GO 71327
71301: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71302: LD_ADDR_VAR 0 3
71306: PUSH
71307: LD_INT 21
71309: PUSH
71310: LD_INT 22
71312: PUSH
71313: LD_INT 23
71315: PUSH
71316: LD_INT 24
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: ST_TO_ADDR
71325: GO 71610
71327: LD_INT 43
71329: DOUBLE
71330: EQUAL
71331: IFTRUE 71335
71333: GO 71361
71335: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71336: LD_ADDR_VAR 0 3
71340: PUSH
71341: LD_INT 21
71343: PUSH
71344: LD_INT 22
71346: PUSH
71347: LD_INT 23
71349: PUSH
71350: LD_INT 24
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: ST_TO_ADDR
71359: GO 71610
71361: LD_INT 44
71363: DOUBLE
71364: EQUAL
71365: IFTRUE 71369
71367: GO 71395
71369: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71370: LD_ADDR_VAR 0 3
71374: PUSH
71375: LD_INT 21
71377: PUSH
71378: LD_INT 22
71380: PUSH
71381: LD_INT 23
71383: PUSH
71384: LD_INT 24
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: ST_TO_ADDR
71393: GO 71610
71395: LD_INT 45
71397: DOUBLE
71398: EQUAL
71399: IFTRUE 71403
71401: GO 71429
71403: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71404: LD_ADDR_VAR 0 3
71408: PUSH
71409: LD_INT 21
71411: PUSH
71412: LD_INT 22
71414: PUSH
71415: LD_INT 23
71417: PUSH
71418: LD_INT 24
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: ST_TO_ADDR
71427: GO 71610
71429: LD_INT 49
71431: DOUBLE
71432: EQUAL
71433: IFTRUE 71437
71435: GO 71463
71437: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71438: LD_ADDR_VAR 0 3
71442: PUSH
71443: LD_INT 21
71445: PUSH
71446: LD_INT 22
71448: PUSH
71449: LD_INT 23
71451: PUSH
71452: LD_INT 24
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: LIST
71459: LIST
71460: ST_TO_ADDR
71461: GO 71610
71463: LD_INT 51
71465: DOUBLE
71466: EQUAL
71467: IFTRUE 71471
71469: GO 71497
71471: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71472: LD_ADDR_VAR 0 3
71476: PUSH
71477: LD_INT 21
71479: PUSH
71480: LD_INT 22
71482: PUSH
71483: LD_INT 23
71485: PUSH
71486: LD_INT 24
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: ST_TO_ADDR
71495: GO 71610
71497: LD_INT 52
71499: DOUBLE
71500: EQUAL
71501: IFTRUE 71505
71503: GO 71531
71505: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71506: LD_ADDR_VAR 0 3
71510: PUSH
71511: LD_INT 21
71513: PUSH
71514: LD_INT 22
71516: PUSH
71517: LD_INT 23
71519: PUSH
71520: LD_INT 24
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: ST_TO_ADDR
71529: GO 71610
71531: LD_INT 53
71533: DOUBLE
71534: EQUAL
71535: IFTRUE 71539
71537: GO 71557
71539: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71540: LD_ADDR_VAR 0 3
71544: PUSH
71545: LD_INT 23
71547: PUSH
71548: LD_INT 24
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: ST_TO_ADDR
71555: GO 71610
71557: LD_INT 46
71559: DOUBLE
71560: EQUAL
71561: IFTRUE 71565
71563: GO 71583
71565: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71566: LD_ADDR_VAR 0 3
71570: PUSH
71571: LD_INT 23
71573: PUSH
71574: LD_INT 24
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: ST_TO_ADDR
71581: GO 71610
71583: LD_INT 47
71585: DOUBLE
71586: EQUAL
71587: IFTRUE 71591
71589: GO 71609
71591: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71592: LD_ADDR_VAR 0 3
71596: PUSH
71597: LD_INT 23
71599: PUSH
71600: LD_INT 24
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: ST_TO_ADDR
71607: GO 71610
71609: POP
// result := ( chassis in result ) ;
71610: LD_ADDR_VAR 0 3
71614: PUSH
71615: LD_VAR 0 1
71619: PUSH
71620: LD_VAR 0 3
71624: IN
71625: ST_TO_ADDR
// end ;
71626: LD_VAR 0 3
71630: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71631: LD_INT 0
71633: PPUSH
71634: PPUSH
71635: PPUSH
71636: PPUSH
71637: PPUSH
71638: PPUSH
71639: PPUSH
// result := array ;
71640: LD_ADDR_VAR 0 5
71644: PUSH
71645: LD_VAR 0 1
71649: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71650: LD_VAR 0 1
71654: NOT
71655: PUSH
71656: LD_VAR 0 2
71660: NOT
71661: OR
71662: PUSH
71663: LD_VAR 0 3
71667: NOT
71668: OR
71669: PUSH
71670: LD_VAR 0 2
71674: PUSH
71675: LD_VAR 0 1
71679: GREATER
71680: OR
71681: PUSH
71682: LD_VAR 0 3
71686: PUSH
71687: LD_VAR 0 1
71691: GREATER
71692: OR
71693: IFFALSE 71697
// exit ;
71695: GO 71993
// if direction then
71697: LD_VAR 0 4
71701: IFFALSE 71765
// begin d := 1 ;
71703: LD_ADDR_VAR 0 9
71707: PUSH
71708: LD_INT 1
71710: ST_TO_ADDR
// if i_from > i_to then
71711: LD_VAR 0 2
71715: PUSH
71716: LD_VAR 0 3
71720: GREATER
71721: IFFALSE 71747
// length := ( array - i_from ) + i_to else
71723: LD_ADDR_VAR 0 11
71727: PUSH
71728: LD_VAR 0 1
71732: PUSH
71733: LD_VAR 0 2
71737: MINUS
71738: PUSH
71739: LD_VAR 0 3
71743: PLUS
71744: ST_TO_ADDR
71745: GO 71763
// length := i_to - i_from ;
71747: LD_ADDR_VAR 0 11
71751: PUSH
71752: LD_VAR 0 3
71756: PUSH
71757: LD_VAR 0 2
71761: MINUS
71762: ST_TO_ADDR
// end else
71763: GO 71826
// begin d := - 1 ;
71765: LD_ADDR_VAR 0 9
71769: PUSH
71770: LD_INT 1
71772: NEG
71773: ST_TO_ADDR
// if i_from > i_to then
71774: LD_VAR 0 2
71778: PUSH
71779: LD_VAR 0 3
71783: GREATER
71784: IFFALSE 71804
// length := i_from - i_to else
71786: LD_ADDR_VAR 0 11
71790: PUSH
71791: LD_VAR 0 2
71795: PUSH
71796: LD_VAR 0 3
71800: MINUS
71801: ST_TO_ADDR
71802: GO 71826
// length := ( array - i_to ) + i_from ;
71804: LD_ADDR_VAR 0 11
71808: PUSH
71809: LD_VAR 0 1
71813: PUSH
71814: LD_VAR 0 3
71818: MINUS
71819: PUSH
71820: LD_VAR 0 2
71824: PLUS
71825: ST_TO_ADDR
// end ; if not length then
71826: LD_VAR 0 11
71830: NOT
71831: IFFALSE 71835
// exit ;
71833: GO 71993
// tmp := array ;
71835: LD_ADDR_VAR 0 10
71839: PUSH
71840: LD_VAR 0 1
71844: ST_TO_ADDR
// for i = 1 to length do
71845: LD_ADDR_VAR 0 6
71849: PUSH
71850: DOUBLE
71851: LD_INT 1
71853: DEC
71854: ST_TO_ADDR
71855: LD_VAR 0 11
71859: PUSH
71860: FOR_TO
71861: IFFALSE 71981
// begin for j = 1 to array do
71863: LD_ADDR_VAR 0 7
71867: PUSH
71868: DOUBLE
71869: LD_INT 1
71871: DEC
71872: ST_TO_ADDR
71873: LD_VAR 0 1
71877: PUSH
71878: FOR_TO
71879: IFFALSE 71967
// begin k := j + d ;
71881: LD_ADDR_VAR 0 8
71885: PUSH
71886: LD_VAR 0 7
71890: PUSH
71891: LD_VAR 0 9
71895: PLUS
71896: ST_TO_ADDR
// if k > array then
71897: LD_VAR 0 8
71901: PUSH
71902: LD_VAR 0 1
71906: GREATER
71907: IFFALSE 71917
// k := 1 ;
71909: LD_ADDR_VAR 0 8
71913: PUSH
71914: LD_INT 1
71916: ST_TO_ADDR
// if not k then
71917: LD_VAR 0 8
71921: NOT
71922: IFFALSE 71934
// k := array ;
71924: LD_ADDR_VAR 0 8
71928: PUSH
71929: LD_VAR 0 1
71933: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71934: LD_ADDR_VAR 0 10
71938: PUSH
71939: LD_VAR 0 10
71943: PPUSH
71944: LD_VAR 0 8
71948: PPUSH
71949: LD_VAR 0 1
71953: PUSH
71954: LD_VAR 0 7
71958: ARRAY
71959: PPUSH
71960: CALL_OW 1
71964: ST_TO_ADDR
// end ;
71965: GO 71878
71967: POP
71968: POP
// array := tmp ;
71969: LD_ADDR_VAR 0 1
71973: PUSH
71974: LD_VAR 0 10
71978: ST_TO_ADDR
// end ;
71979: GO 71860
71981: POP
71982: POP
// result := array ;
71983: LD_ADDR_VAR 0 5
71987: PUSH
71988: LD_VAR 0 1
71992: ST_TO_ADDR
// end ;
71993: LD_VAR 0 5
71997: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71998: LD_INT 0
72000: PPUSH
72001: PPUSH
// result := 0 ;
72002: LD_ADDR_VAR 0 3
72006: PUSH
72007: LD_INT 0
72009: ST_TO_ADDR
// if not array or not value in array then
72010: LD_VAR 0 1
72014: NOT
72015: PUSH
72016: LD_VAR 0 2
72020: PUSH
72021: LD_VAR 0 1
72025: IN
72026: NOT
72027: OR
72028: IFFALSE 72032
// exit ;
72030: GO 72086
// for i = 1 to array do
72032: LD_ADDR_VAR 0 4
72036: PUSH
72037: DOUBLE
72038: LD_INT 1
72040: DEC
72041: ST_TO_ADDR
72042: LD_VAR 0 1
72046: PUSH
72047: FOR_TO
72048: IFFALSE 72084
// if value = array [ i ] then
72050: LD_VAR 0 2
72054: PUSH
72055: LD_VAR 0 1
72059: PUSH
72060: LD_VAR 0 4
72064: ARRAY
72065: EQUAL
72066: IFFALSE 72082
// begin result := i ;
72068: LD_ADDR_VAR 0 3
72072: PUSH
72073: LD_VAR 0 4
72077: ST_TO_ADDR
// exit ;
72078: POP
72079: POP
72080: GO 72086
// end ;
72082: GO 72047
72084: POP
72085: POP
// end ;
72086: LD_VAR 0 3
72090: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72091: LD_INT 0
72093: PPUSH
// vc_chassis := chassis ;
72094: LD_ADDR_OWVAR 37
72098: PUSH
72099: LD_VAR 0 1
72103: ST_TO_ADDR
// vc_engine := engine ;
72104: LD_ADDR_OWVAR 39
72108: PUSH
72109: LD_VAR 0 2
72113: ST_TO_ADDR
// vc_control := control ;
72114: LD_ADDR_OWVAR 38
72118: PUSH
72119: LD_VAR 0 3
72123: ST_TO_ADDR
// vc_weapon := weapon ;
72124: LD_ADDR_OWVAR 40
72128: PUSH
72129: LD_VAR 0 4
72133: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72134: LD_ADDR_OWVAR 41
72138: PUSH
72139: LD_VAR 0 5
72143: ST_TO_ADDR
// end ;
72144: LD_VAR 0 6
72148: RET
// export function WantPlant ( unit ) ; var task ; begin
72149: LD_INT 0
72151: PPUSH
72152: PPUSH
// result := false ;
72153: LD_ADDR_VAR 0 2
72157: PUSH
72158: LD_INT 0
72160: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72161: LD_ADDR_VAR 0 3
72165: PUSH
72166: LD_VAR 0 1
72170: PPUSH
72171: CALL_OW 437
72175: ST_TO_ADDR
// if task then
72176: LD_VAR 0 3
72180: IFFALSE 72208
// if task [ 1 ] [ 1 ] = p then
72182: LD_VAR 0 3
72186: PUSH
72187: LD_INT 1
72189: ARRAY
72190: PUSH
72191: LD_INT 1
72193: ARRAY
72194: PUSH
72195: LD_STRING p
72197: EQUAL
72198: IFFALSE 72208
// result := true ;
72200: LD_ADDR_VAR 0 2
72204: PUSH
72205: LD_INT 1
72207: ST_TO_ADDR
// end ;
72208: LD_VAR 0 2
72212: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72213: LD_INT 0
72215: PPUSH
72216: PPUSH
72217: PPUSH
72218: PPUSH
// if pos < 1 then
72219: LD_VAR 0 2
72223: PUSH
72224: LD_INT 1
72226: LESS
72227: IFFALSE 72231
// exit ;
72229: GO 72534
// if pos = 1 then
72231: LD_VAR 0 2
72235: PUSH
72236: LD_INT 1
72238: EQUAL
72239: IFFALSE 72272
// result := Replace ( arr , pos [ 1 ] , value ) else
72241: LD_ADDR_VAR 0 4
72245: PUSH
72246: LD_VAR 0 1
72250: PPUSH
72251: LD_VAR 0 2
72255: PUSH
72256: LD_INT 1
72258: ARRAY
72259: PPUSH
72260: LD_VAR 0 3
72264: PPUSH
72265: CALL_OW 1
72269: ST_TO_ADDR
72270: GO 72534
// begin tmp := arr ;
72272: LD_ADDR_VAR 0 6
72276: PUSH
72277: LD_VAR 0 1
72281: ST_TO_ADDR
// s_arr := [ tmp ] ;
72282: LD_ADDR_VAR 0 7
72286: PUSH
72287: LD_VAR 0 6
72291: PUSH
72292: EMPTY
72293: LIST
72294: ST_TO_ADDR
// for i = 1 to pos - 1 do
72295: LD_ADDR_VAR 0 5
72299: PUSH
72300: DOUBLE
72301: LD_INT 1
72303: DEC
72304: ST_TO_ADDR
72305: LD_VAR 0 2
72309: PUSH
72310: LD_INT 1
72312: MINUS
72313: PUSH
72314: FOR_TO
72315: IFFALSE 72360
// begin tmp := tmp [ pos [ i ] ] ;
72317: LD_ADDR_VAR 0 6
72321: PUSH
72322: LD_VAR 0 6
72326: PUSH
72327: LD_VAR 0 2
72331: PUSH
72332: LD_VAR 0 5
72336: ARRAY
72337: ARRAY
72338: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72339: LD_ADDR_VAR 0 7
72343: PUSH
72344: LD_VAR 0 7
72348: PUSH
72349: LD_VAR 0 6
72353: PUSH
72354: EMPTY
72355: LIST
72356: ADD
72357: ST_TO_ADDR
// end ;
72358: GO 72314
72360: POP
72361: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72362: LD_ADDR_VAR 0 6
72366: PUSH
72367: LD_VAR 0 6
72371: PPUSH
72372: LD_VAR 0 2
72376: PUSH
72377: LD_VAR 0 2
72381: ARRAY
72382: PPUSH
72383: LD_VAR 0 3
72387: PPUSH
72388: CALL_OW 1
72392: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72393: LD_ADDR_VAR 0 7
72397: PUSH
72398: LD_VAR 0 7
72402: PPUSH
72403: LD_VAR 0 7
72407: PPUSH
72408: LD_VAR 0 6
72412: PPUSH
72413: CALL_OW 1
72417: ST_TO_ADDR
// for i = s_arr downto 2 do
72418: LD_ADDR_VAR 0 5
72422: PUSH
72423: DOUBLE
72424: LD_VAR 0 7
72428: INC
72429: ST_TO_ADDR
72430: LD_INT 2
72432: PUSH
72433: FOR_DOWNTO
72434: IFFALSE 72518
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72436: LD_ADDR_VAR 0 6
72440: PUSH
72441: LD_VAR 0 7
72445: PUSH
72446: LD_VAR 0 5
72450: PUSH
72451: LD_INT 1
72453: MINUS
72454: ARRAY
72455: PPUSH
72456: LD_VAR 0 2
72460: PUSH
72461: LD_VAR 0 5
72465: PUSH
72466: LD_INT 1
72468: MINUS
72469: ARRAY
72470: PPUSH
72471: LD_VAR 0 7
72475: PUSH
72476: LD_VAR 0 5
72480: ARRAY
72481: PPUSH
72482: CALL_OW 1
72486: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72487: LD_ADDR_VAR 0 7
72491: PUSH
72492: LD_VAR 0 7
72496: PPUSH
72497: LD_VAR 0 5
72501: PUSH
72502: LD_INT 1
72504: MINUS
72505: PPUSH
72506: LD_VAR 0 6
72510: PPUSH
72511: CALL_OW 1
72515: ST_TO_ADDR
// end ;
72516: GO 72433
72518: POP
72519: POP
// result := s_arr [ 1 ] ;
72520: LD_ADDR_VAR 0 4
72524: PUSH
72525: LD_VAR 0 7
72529: PUSH
72530: LD_INT 1
72532: ARRAY
72533: ST_TO_ADDR
// end ; end ;
72534: LD_VAR 0 4
72538: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72539: LD_INT 0
72541: PPUSH
72542: PPUSH
// if not list then
72543: LD_VAR 0 1
72547: NOT
72548: IFFALSE 72552
// exit ;
72550: GO 72643
// i := list [ pos1 ] ;
72552: LD_ADDR_VAR 0 5
72556: PUSH
72557: LD_VAR 0 1
72561: PUSH
72562: LD_VAR 0 2
72566: ARRAY
72567: ST_TO_ADDR
// if not i then
72568: LD_VAR 0 5
72572: NOT
72573: IFFALSE 72577
// exit ;
72575: GO 72643
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72577: LD_ADDR_VAR 0 1
72581: PUSH
72582: LD_VAR 0 1
72586: PPUSH
72587: LD_VAR 0 2
72591: PPUSH
72592: LD_VAR 0 1
72596: PUSH
72597: LD_VAR 0 3
72601: ARRAY
72602: PPUSH
72603: CALL_OW 1
72607: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72608: LD_ADDR_VAR 0 1
72612: PUSH
72613: LD_VAR 0 1
72617: PPUSH
72618: LD_VAR 0 3
72622: PPUSH
72623: LD_VAR 0 5
72627: PPUSH
72628: CALL_OW 1
72632: ST_TO_ADDR
// result := list ;
72633: LD_ADDR_VAR 0 4
72637: PUSH
72638: LD_VAR 0 1
72642: ST_TO_ADDR
// end ;
72643: LD_VAR 0 4
72647: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72648: LD_INT 0
72650: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72651: LD_ADDR_VAR 0 5
72655: PUSH
72656: LD_VAR 0 1
72660: PPUSH
72661: CALL_OW 250
72665: PPUSH
72666: LD_VAR 0 1
72670: PPUSH
72671: CALL_OW 251
72675: PPUSH
72676: LD_VAR 0 2
72680: PPUSH
72681: LD_VAR 0 3
72685: PPUSH
72686: LD_VAR 0 4
72690: PPUSH
72691: CALL 72701 0 5
72695: ST_TO_ADDR
// end ;
72696: LD_VAR 0 5
72700: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72701: LD_INT 0
72703: PPUSH
72704: PPUSH
72705: PPUSH
72706: PPUSH
// if not list then
72707: LD_VAR 0 3
72711: NOT
72712: IFFALSE 72716
// exit ;
72714: GO 73104
// result := [ ] ;
72716: LD_ADDR_VAR 0 6
72720: PUSH
72721: EMPTY
72722: ST_TO_ADDR
// for i in list do
72723: LD_ADDR_VAR 0 7
72727: PUSH
72728: LD_VAR 0 3
72732: PUSH
72733: FOR_IN
72734: IFFALSE 72936
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72736: LD_ADDR_VAR 0 9
72740: PUSH
72741: LD_VAR 0 7
72745: PPUSH
72746: LD_VAR 0 1
72750: PPUSH
72751: LD_VAR 0 2
72755: PPUSH
72756: CALL_OW 297
72760: ST_TO_ADDR
// if not result then
72761: LD_VAR 0 6
72765: NOT
72766: IFFALSE 72792
// result := [ [ i , tmp ] ] else
72768: LD_ADDR_VAR 0 6
72772: PUSH
72773: LD_VAR 0 7
72777: PUSH
72778: LD_VAR 0 9
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: EMPTY
72788: LIST
72789: ST_TO_ADDR
72790: GO 72934
// begin if result [ result ] [ 2 ] < tmp then
72792: LD_VAR 0 6
72796: PUSH
72797: LD_VAR 0 6
72801: ARRAY
72802: PUSH
72803: LD_INT 2
72805: ARRAY
72806: PUSH
72807: LD_VAR 0 9
72811: LESS
72812: IFFALSE 72854
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72814: LD_ADDR_VAR 0 6
72818: PUSH
72819: LD_VAR 0 6
72823: PPUSH
72824: LD_VAR 0 6
72828: PUSH
72829: LD_INT 1
72831: PLUS
72832: PPUSH
72833: LD_VAR 0 7
72837: PUSH
72838: LD_VAR 0 9
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PPUSH
72847: CALL_OW 2
72851: ST_TO_ADDR
72852: GO 72934
// for j = 1 to result do
72854: LD_ADDR_VAR 0 8
72858: PUSH
72859: DOUBLE
72860: LD_INT 1
72862: DEC
72863: ST_TO_ADDR
72864: LD_VAR 0 6
72868: PUSH
72869: FOR_TO
72870: IFFALSE 72932
// begin if tmp < result [ j ] [ 2 ] then
72872: LD_VAR 0 9
72876: PUSH
72877: LD_VAR 0 6
72881: PUSH
72882: LD_VAR 0 8
72886: ARRAY
72887: PUSH
72888: LD_INT 2
72890: ARRAY
72891: LESS
72892: IFFALSE 72930
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72894: LD_ADDR_VAR 0 6
72898: PUSH
72899: LD_VAR 0 6
72903: PPUSH
72904: LD_VAR 0 8
72908: PPUSH
72909: LD_VAR 0 7
72913: PUSH
72914: LD_VAR 0 9
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PPUSH
72923: CALL_OW 2
72927: ST_TO_ADDR
// break ;
72928: GO 72932
// end ; end ;
72930: GO 72869
72932: POP
72933: POP
// end ; end ;
72934: GO 72733
72936: POP
72937: POP
// if result and not asc then
72938: LD_VAR 0 6
72942: PUSH
72943: LD_VAR 0 4
72947: NOT
72948: AND
72949: IFFALSE 73024
// begin tmp := result ;
72951: LD_ADDR_VAR 0 9
72955: PUSH
72956: LD_VAR 0 6
72960: ST_TO_ADDR
// for i = tmp downto 1 do
72961: LD_ADDR_VAR 0 7
72965: PUSH
72966: DOUBLE
72967: LD_VAR 0 9
72971: INC
72972: ST_TO_ADDR
72973: LD_INT 1
72975: PUSH
72976: FOR_DOWNTO
72977: IFFALSE 73022
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72979: LD_ADDR_VAR 0 6
72983: PUSH
72984: LD_VAR 0 6
72988: PPUSH
72989: LD_VAR 0 9
72993: PUSH
72994: LD_VAR 0 7
72998: MINUS
72999: PUSH
73000: LD_INT 1
73002: PLUS
73003: PPUSH
73004: LD_VAR 0 9
73008: PUSH
73009: LD_VAR 0 7
73013: ARRAY
73014: PPUSH
73015: CALL_OW 1
73019: ST_TO_ADDR
73020: GO 72976
73022: POP
73023: POP
// end ; tmp := [ ] ;
73024: LD_ADDR_VAR 0 9
73028: PUSH
73029: EMPTY
73030: ST_TO_ADDR
// if mode then
73031: LD_VAR 0 5
73035: IFFALSE 73104
// begin for i = 1 to result do
73037: LD_ADDR_VAR 0 7
73041: PUSH
73042: DOUBLE
73043: LD_INT 1
73045: DEC
73046: ST_TO_ADDR
73047: LD_VAR 0 6
73051: PUSH
73052: FOR_TO
73053: IFFALSE 73092
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73055: LD_ADDR_VAR 0 9
73059: PUSH
73060: LD_VAR 0 9
73064: PPUSH
73065: LD_VAR 0 7
73069: PPUSH
73070: LD_VAR 0 6
73074: PUSH
73075: LD_VAR 0 7
73079: ARRAY
73080: PUSH
73081: LD_INT 1
73083: ARRAY
73084: PPUSH
73085: CALL_OW 1
73089: ST_TO_ADDR
73090: GO 73052
73092: POP
73093: POP
// result := tmp ;
73094: LD_ADDR_VAR 0 6
73098: PUSH
73099: LD_VAR 0 9
73103: ST_TO_ADDR
// end ; end ;
73104: LD_VAR 0 6
73108: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73109: LD_INT 0
73111: PPUSH
73112: PPUSH
73113: PPUSH
73114: PPUSH
73115: PPUSH
73116: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73117: LD_ADDR_VAR 0 5
73121: PUSH
73122: LD_INT 0
73124: PUSH
73125: LD_INT 0
73127: PUSH
73128: LD_INT 0
73130: PUSH
73131: EMPTY
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: ST_TO_ADDR
// if not x or not y then
73139: LD_VAR 0 2
73143: NOT
73144: PUSH
73145: LD_VAR 0 3
73149: NOT
73150: OR
73151: IFFALSE 73155
// exit ;
73153: GO 74801
// if not range then
73155: LD_VAR 0 4
73159: NOT
73160: IFFALSE 73170
// range := 10 ;
73162: LD_ADDR_VAR 0 4
73166: PUSH
73167: LD_INT 10
73169: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73170: LD_ADDR_VAR 0 8
73174: PUSH
73175: LD_INT 81
73177: PUSH
73178: LD_VAR 0 1
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 92
73189: PUSH
73190: LD_VAR 0 2
73194: PUSH
73195: LD_VAR 0 3
73199: PUSH
73200: LD_VAR 0 4
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 3
73213: PUSH
73214: LD_INT 21
73216: PUSH
73217: LD_INT 3
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: LIST
73232: PPUSH
73233: CALL_OW 69
73237: ST_TO_ADDR
// if not tmp then
73238: LD_VAR 0 8
73242: NOT
73243: IFFALSE 73247
// exit ;
73245: GO 74801
// for i in tmp do
73247: LD_ADDR_VAR 0 6
73251: PUSH
73252: LD_VAR 0 8
73256: PUSH
73257: FOR_IN
73258: IFFALSE 74776
// begin points := [ 0 , 0 , 0 ] ;
73260: LD_ADDR_VAR 0 9
73264: PUSH
73265: LD_INT 0
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: LIST
73278: ST_TO_ADDR
// bpoints := 1 ;
73279: LD_ADDR_VAR 0 10
73283: PUSH
73284: LD_INT 1
73286: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73287: LD_VAR 0 6
73291: PPUSH
73292: CALL_OW 247
73296: PUSH
73297: LD_INT 1
73299: DOUBLE
73300: EQUAL
73301: IFTRUE 73305
73303: GO 73883
73305: POP
// begin if GetClass ( i ) = 1 then
73306: LD_VAR 0 6
73310: PPUSH
73311: CALL_OW 257
73315: PUSH
73316: LD_INT 1
73318: EQUAL
73319: IFFALSE 73340
// points := [ 10 , 5 , 3 ] ;
73321: LD_ADDR_VAR 0 9
73325: PUSH
73326: LD_INT 10
73328: PUSH
73329: LD_INT 5
73331: PUSH
73332: LD_INT 3
73334: PUSH
73335: EMPTY
73336: LIST
73337: LIST
73338: LIST
73339: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73340: LD_VAR 0 6
73344: PPUSH
73345: CALL_OW 257
73349: PUSH
73350: LD_INT 2
73352: PUSH
73353: LD_INT 3
73355: PUSH
73356: LD_INT 4
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: LIST
73363: IN
73364: IFFALSE 73385
// points := [ 3 , 2 , 1 ] ;
73366: LD_ADDR_VAR 0 9
73370: PUSH
73371: LD_INT 3
73373: PUSH
73374: LD_INT 2
73376: PUSH
73377: LD_INT 1
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: LIST
73384: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73385: LD_VAR 0 6
73389: PPUSH
73390: CALL_OW 257
73394: PUSH
73395: LD_INT 5
73397: EQUAL
73398: IFFALSE 73419
// points := [ 130 , 5 , 2 ] ;
73400: LD_ADDR_VAR 0 9
73404: PUSH
73405: LD_INT 130
73407: PUSH
73408: LD_INT 5
73410: PUSH
73411: LD_INT 2
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: LIST
73418: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73419: LD_VAR 0 6
73423: PPUSH
73424: CALL_OW 257
73428: PUSH
73429: LD_INT 8
73431: EQUAL
73432: IFFALSE 73453
// points := [ 35 , 35 , 30 ] ;
73434: LD_ADDR_VAR 0 9
73438: PUSH
73439: LD_INT 35
73441: PUSH
73442: LD_INT 35
73444: PUSH
73445: LD_INT 30
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: LIST
73452: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73453: LD_VAR 0 6
73457: PPUSH
73458: CALL_OW 257
73462: PUSH
73463: LD_INT 9
73465: EQUAL
73466: IFFALSE 73487
// points := [ 20 , 55 , 40 ] ;
73468: LD_ADDR_VAR 0 9
73472: PUSH
73473: LD_INT 20
73475: PUSH
73476: LD_INT 55
73478: PUSH
73479: LD_INT 40
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: LIST
73486: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73487: LD_VAR 0 6
73491: PPUSH
73492: CALL_OW 257
73496: PUSH
73497: LD_INT 12
73499: PUSH
73500: LD_INT 16
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: IN
73507: IFFALSE 73528
// points := [ 5 , 3 , 2 ] ;
73509: LD_ADDR_VAR 0 9
73513: PUSH
73514: LD_INT 5
73516: PUSH
73517: LD_INT 3
73519: PUSH
73520: LD_INT 2
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: LIST
73527: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73528: LD_VAR 0 6
73532: PPUSH
73533: CALL_OW 257
73537: PUSH
73538: LD_INT 17
73540: EQUAL
73541: IFFALSE 73562
// points := [ 100 , 50 , 75 ] ;
73543: LD_ADDR_VAR 0 9
73547: PUSH
73548: LD_INT 100
73550: PUSH
73551: LD_INT 50
73553: PUSH
73554: LD_INT 75
73556: PUSH
73557: EMPTY
73558: LIST
73559: LIST
73560: LIST
73561: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73562: LD_VAR 0 6
73566: PPUSH
73567: CALL_OW 257
73571: PUSH
73572: LD_INT 15
73574: EQUAL
73575: IFFALSE 73596
// points := [ 10 , 5 , 3 ] ;
73577: LD_ADDR_VAR 0 9
73581: PUSH
73582: LD_INT 10
73584: PUSH
73585: LD_INT 5
73587: PUSH
73588: LD_INT 3
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: LIST
73595: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73596: LD_VAR 0 6
73600: PPUSH
73601: CALL_OW 257
73605: PUSH
73606: LD_INT 14
73608: EQUAL
73609: IFFALSE 73630
// points := [ 10 , 0 , 0 ] ;
73611: LD_ADDR_VAR 0 9
73615: PUSH
73616: LD_INT 10
73618: PUSH
73619: LD_INT 0
73621: PUSH
73622: LD_INT 0
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: LIST
73629: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73630: LD_VAR 0 6
73634: PPUSH
73635: CALL_OW 257
73639: PUSH
73640: LD_INT 11
73642: EQUAL
73643: IFFALSE 73664
// points := [ 30 , 10 , 5 ] ;
73645: LD_ADDR_VAR 0 9
73649: PUSH
73650: LD_INT 30
73652: PUSH
73653: LD_INT 10
73655: PUSH
73656: LD_INT 5
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: LIST
73663: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73664: LD_VAR 0 1
73668: PPUSH
73669: LD_INT 5
73671: PPUSH
73672: CALL_OW 321
73676: PUSH
73677: LD_INT 2
73679: EQUAL
73680: IFFALSE 73697
// bpoints := bpoints * 1.8 ;
73682: LD_ADDR_VAR 0 10
73686: PUSH
73687: LD_VAR 0 10
73691: PUSH
73692: LD_REAL  1.80000000000000E+0000
73695: MUL
73696: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73697: LD_VAR 0 6
73701: PPUSH
73702: CALL_OW 257
73706: PUSH
73707: LD_INT 1
73709: PUSH
73710: LD_INT 2
73712: PUSH
73713: LD_INT 3
73715: PUSH
73716: LD_INT 4
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: IN
73725: PUSH
73726: LD_VAR 0 1
73730: PPUSH
73731: LD_INT 51
73733: PPUSH
73734: CALL_OW 321
73738: PUSH
73739: LD_INT 2
73741: EQUAL
73742: AND
73743: IFFALSE 73760
// bpoints := bpoints * 1.2 ;
73745: LD_ADDR_VAR 0 10
73749: PUSH
73750: LD_VAR 0 10
73754: PUSH
73755: LD_REAL  1.20000000000000E+0000
73758: MUL
73759: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73760: LD_VAR 0 6
73764: PPUSH
73765: CALL_OW 257
73769: PUSH
73770: LD_INT 5
73772: PUSH
73773: LD_INT 7
73775: PUSH
73776: LD_INT 9
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: LIST
73783: IN
73784: PUSH
73785: LD_VAR 0 1
73789: PPUSH
73790: LD_INT 52
73792: PPUSH
73793: CALL_OW 321
73797: PUSH
73798: LD_INT 2
73800: EQUAL
73801: AND
73802: IFFALSE 73819
// bpoints := bpoints * 1.5 ;
73804: LD_ADDR_VAR 0 10
73808: PUSH
73809: LD_VAR 0 10
73813: PUSH
73814: LD_REAL  1.50000000000000E+0000
73817: MUL
73818: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73819: LD_VAR 0 1
73823: PPUSH
73824: LD_INT 66
73826: PPUSH
73827: CALL_OW 321
73831: PUSH
73832: LD_INT 2
73834: EQUAL
73835: IFFALSE 73852
// bpoints := bpoints * 1.1 ;
73837: LD_ADDR_VAR 0 10
73841: PUSH
73842: LD_VAR 0 10
73846: PUSH
73847: LD_REAL  1.10000000000000E+0000
73850: MUL
73851: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73852: LD_ADDR_VAR 0 10
73856: PUSH
73857: LD_VAR 0 10
73861: PUSH
73862: LD_VAR 0 6
73866: PPUSH
73867: LD_INT 1
73869: PPUSH
73870: CALL_OW 259
73874: PUSH
73875: LD_REAL  1.15000000000000E+0000
73878: MUL
73879: MUL
73880: ST_TO_ADDR
// end ; unit_vehicle :
73881: GO 74705
73883: LD_INT 2
73885: DOUBLE
73886: EQUAL
73887: IFTRUE 73891
73889: GO 74693
73891: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73892: LD_VAR 0 6
73896: PPUSH
73897: CALL_OW 264
73901: PUSH
73902: LD_INT 2
73904: PUSH
73905: LD_INT 42
73907: PUSH
73908: LD_INT 24
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: LIST
73915: IN
73916: IFFALSE 73937
// points := [ 25 , 5 , 3 ] ;
73918: LD_ADDR_VAR 0 9
73922: PUSH
73923: LD_INT 25
73925: PUSH
73926: LD_INT 5
73928: PUSH
73929: LD_INT 3
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: LIST
73936: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73937: LD_VAR 0 6
73941: PPUSH
73942: CALL_OW 264
73946: PUSH
73947: LD_INT 4
73949: PUSH
73950: LD_INT 43
73952: PUSH
73953: LD_INT 25
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: LIST
73960: IN
73961: IFFALSE 73982
// points := [ 40 , 15 , 5 ] ;
73963: LD_ADDR_VAR 0 9
73967: PUSH
73968: LD_INT 40
73970: PUSH
73971: LD_INT 15
73973: PUSH
73974: LD_INT 5
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: LIST
73981: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73982: LD_VAR 0 6
73986: PPUSH
73987: CALL_OW 264
73991: PUSH
73992: LD_INT 3
73994: PUSH
73995: LD_INT 23
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: IN
74002: IFFALSE 74023
// points := [ 7 , 25 , 8 ] ;
74004: LD_ADDR_VAR 0 9
74008: PUSH
74009: LD_INT 7
74011: PUSH
74012: LD_INT 25
74014: PUSH
74015: LD_INT 8
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: LIST
74022: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74023: LD_VAR 0 6
74027: PPUSH
74028: CALL_OW 264
74032: PUSH
74033: LD_INT 5
74035: PUSH
74036: LD_INT 27
74038: PUSH
74039: LD_INT 44
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: LIST
74046: IN
74047: IFFALSE 74068
// points := [ 14 , 50 , 16 ] ;
74049: LD_ADDR_VAR 0 9
74053: PUSH
74054: LD_INT 14
74056: PUSH
74057: LD_INT 50
74059: PUSH
74060: LD_INT 16
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: LIST
74067: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74068: LD_VAR 0 6
74072: PPUSH
74073: CALL_OW 264
74077: PUSH
74078: LD_INT 6
74080: PUSH
74081: LD_INT 46
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: IN
74088: IFFALSE 74109
// points := [ 32 , 120 , 70 ] ;
74090: LD_ADDR_VAR 0 9
74094: PUSH
74095: LD_INT 32
74097: PUSH
74098: LD_INT 120
74100: PUSH
74101: LD_INT 70
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: LIST
74108: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
74109: LD_VAR 0 6
74113: PPUSH
74114: CALL_OW 264
74118: PUSH
74119: LD_INT 7
74121: PUSH
74122: LD_INT 28
74124: PUSH
74125: LD_INT 45
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: LIST
74132: IN
74133: IFFALSE 74154
// points := [ 35 , 20 , 45 ] ;
74135: LD_ADDR_VAR 0 9
74139: PUSH
74140: LD_INT 35
74142: PUSH
74143: LD_INT 20
74145: PUSH
74146: LD_INT 45
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: LIST
74153: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74154: LD_VAR 0 6
74158: PPUSH
74159: CALL_OW 264
74163: PUSH
74164: LD_INT 47
74166: PUSH
74167: EMPTY
74168: LIST
74169: IN
74170: IFFALSE 74191
// points := [ 67 , 45 , 75 ] ;
74172: LD_ADDR_VAR 0 9
74176: PUSH
74177: LD_INT 67
74179: PUSH
74180: LD_INT 45
74182: PUSH
74183: LD_INT 75
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: LIST
74190: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74191: LD_VAR 0 6
74195: PPUSH
74196: CALL_OW 264
74200: PUSH
74201: LD_INT 26
74203: PUSH
74204: EMPTY
74205: LIST
74206: IN
74207: IFFALSE 74228
// points := [ 120 , 30 , 80 ] ;
74209: LD_ADDR_VAR 0 9
74213: PUSH
74214: LD_INT 120
74216: PUSH
74217: LD_INT 30
74219: PUSH
74220: LD_INT 80
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: LIST
74227: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74228: LD_VAR 0 6
74232: PPUSH
74233: CALL_OW 264
74237: PUSH
74238: LD_INT 22
74240: PUSH
74241: EMPTY
74242: LIST
74243: IN
74244: IFFALSE 74265
// points := [ 40 , 1 , 1 ] ;
74246: LD_ADDR_VAR 0 9
74250: PUSH
74251: LD_INT 40
74253: PUSH
74254: LD_INT 1
74256: PUSH
74257: LD_INT 1
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: LIST
74264: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74265: LD_VAR 0 6
74269: PPUSH
74270: CALL_OW 264
74274: PUSH
74275: LD_INT 29
74277: PUSH
74278: EMPTY
74279: LIST
74280: IN
74281: IFFALSE 74302
// points := [ 70 , 200 , 400 ] ;
74283: LD_ADDR_VAR 0 9
74287: PUSH
74288: LD_INT 70
74290: PUSH
74291: LD_INT 200
74293: PUSH
74294: LD_INT 400
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74302: LD_VAR 0 6
74306: PPUSH
74307: CALL_OW 264
74311: PUSH
74312: LD_INT 14
74314: PUSH
74315: LD_INT 53
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: IN
74322: IFFALSE 74343
// points := [ 40 , 10 , 20 ] ;
74324: LD_ADDR_VAR 0 9
74328: PUSH
74329: LD_INT 40
74331: PUSH
74332: LD_INT 10
74334: PUSH
74335: LD_INT 20
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74343: LD_VAR 0 6
74347: PPUSH
74348: CALL_OW 264
74352: PUSH
74353: LD_INT 9
74355: PUSH
74356: EMPTY
74357: LIST
74358: IN
74359: IFFALSE 74380
// points := [ 5 , 70 , 20 ] ;
74361: LD_ADDR_VAR 0 9
74365: PUSH
74366: LD_INT 5
74368: PUSH
74369: LD_INT 70
74371: PUSH
74372: LD_INT 20
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74380: LD_VAR 0 6
74384: PPUSH
74385: CALL_OW 264
74389: PUSH
74390: LD_INT 10
74392: PUSH
74393: EMPTY
74394: LIST
74395: IN
74396: IFFALSE 74417
// points := [ 35 , 110 , 70 ] ;
74398: LD_ADDR_VAR 0 9
74402: PUSH
74403: LD_INT 35
74405: PUSH
74406: LD_INT 110
74408: PUSH
74409: LD_INT 70
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: LIST
74416: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74417: LD_VAR 0 6
74421: PPUSH
74422: CALL_OW 265
74426: PUSH
74427: LD_INT 25
74429: EQUAL
74430: IFFALSE 74451
// points := [ 80 , 65 , 100 ] ;
74432: LD_ADDR_VAR 0 9
74436: PUSH
74437: LD_INT 80
74439: PUSH
74440: LD_INT 65
74442: PUSH
74443: LD_INT 100
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: LIST
74450: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74451: LD_VAR 0 6
74455: PPUSH
74456: CALL_OW 263
74460: PUSH
74461: LD_INT 1
74463: EQUAL
74464: IFFALSE 74499
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74466: LD_ADDR_VAR 0 10
74470: PUSH
74471: LD_VAR 0 10
74475: PUSH
74476: LD_VAR 0 6
74480: PPUSH
74481: CALL_OW 311
74485: PPUSH
74486: LD_INT 3
74488: PPUSH
74489: CALL_OW 259
74493: PUSH
74494: LD_INT 4
74496: MUL
74497: MUL
74498: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74499: LD_VAR 0 6
74503: PPUSH
74504: CALL_OW 263
74508: PUSH
74509: LD_INT 2
74511: EQUAL
74512: IFFALSE 74563
// begin j := IsControledBy ( i ) ;
74514: LD_ADDR_VAR 0 7
74518: PUSH
74519: LD_VAR 0 6
74523: PPUSH
74524: CALL_OW 312
74528: ST_TO_ADDR
// if j then
74529: LD_VAR 0 7
74533: IFFALSE 74563
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74535: LD_ADDR_VAR 0 10
74539: PUSH
74540: LD_VAR 0 10
74544: PUSH
74545: LD_VAR 0 7
74549: PPUSH
74550: LD_INT 3
74552: PPUSH
74553: CALL_OW 259
74557: PUSH
74558: LD_INT 3
74560: MUL
74561: MUL
74562: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74563: LD_VAR 0 6
74567: PPUSH
74568: CALL_OW 264
74572: PUSH
74573: LD_INT 5
74575: PUSH
74576: LD_INT 6
74578: PUSH
74579: LD_INT 46
74581: PUSH
74582: LD_INT 44
74584: PUSH
74585: LD_INT 47
74587: PUSH
74588: LD_INT 45
74590: PUSH
74591: LD_INT 28
74593: PUSH
74594: LD_INT 7
74596: PUSH
74597: LD_INT 27
74599: PUSH
74600: LD_INT 29
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: IN
74615: PUSH
74616: LD_VAR 0 1
74620: PPUSH
74621: LD_INT 52
74623: PPUSH
74624: CALL_OW 321
74628: PUSH
74629: LD_INT 2
74631: EQUAL
74632: AND
74633: IFFALSE 74650
// bpoints := bpoints * 1.2 ;
74635: LD_ADDR_VAR 0 10
74639: PUSH
74640: LD_VAR 0 10
74644: PUSH
74645: LD_REAL  1.20000000000000E+0000
74648: MUL
74649: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74650: LD_VAR 0 6
74654: PPUSH
74655: CALL_OW 264
74659: PUSH
74660: LD_INT 6
74662: PUSH
74663: LD_INT 46
74665: PUSH
74666: LD_INT 47
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: LIST
74673: IN
74674: IFFALSE 74691
// bpoints := bpoints * 1.2 ;
74676: LD_ADDR_VAR 0 10
74680: PUSH
74681: LD_VAR 0 10
74685: PUSH
74686: LD_REAL  1.20000000000000E+0000
74689: MUL
74690: ST_TO_ADDR
// end ; unit_building :
74691: GO 74705
74693: LD_INT 3
74695: DOUBLE
74696: EQUAL
74697: IFTRUE 74701
74699: GO 74704
74701: POP
// ; end ;
74702: GO 74705
74704: POP
// for j = 1 to 3 do
74705: LD_ADDR_VAR 0 7
74709: PUSH
74710: DOUBLE
74711: LD_INT 1
74713: DEC
74714: ST_TO_ADDR
74715: LD_INT 3
74717: PUSH
74718: FOR_TO
74719: IFFALSE 74772
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74721: LD_ADDR_VAR 0 5
74725: PUSH
74726: LD_VAR 0 5
74730: PPUSH
74731: LD_VAR 0 7
74735: PPUSH
74736: LD_VAR 0 5
74740: PUSH
74741: LD_VAR 0 7
74745: ARRAY
74746: PUSH
74747: LD_VAR 0 9
74751: PUSH
74752: LD_VAR 0 7
74756: ARRAY
74757: PUSH
74758: LD_VAR 0 10
74762: MUL
74763: PLUS
74764: PPUSH
74765: CALL_OW 1
74769: ST_TO_ADDR
74770: GO 74718
74772: POP
74773: POP
// end ;
74774: GO 73257
74776: POP
74777: POP
// result := Replace ( result , 4 , tmp ) ;
74778: LD_ADDR_VAR 0 5
74782: PUSH
74783: LD_VAR 0 5
74787: PPUSH
74788: LD_INT 4
74790: PPUSH
74791: LD_VAR 0 8
74795: PPUSH
74796: CALL_OW 1
74800: ST_TO_ADDR
// end ;
74801: LD_VAR 0 5
74805: RET
// export function DangerAtRange ( unit , range ) ; begin
74806: LD_INT 0
74808: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74809: LD_ADDR_VAR 0 3
74813: PUSH
74814: LD_VAR 0 1
74818: PPUSH
74819: CALL_OW 255
74823: PPUSH
74824: LD_VAR 0 1
74828: PPUSH
74829: CALL_OW 250
74833: PPUSH
74834: LD_VAR 0 1
74838: PPUSH
74839: CALL_OW 251
74843: PPUSH
74844: LD_VAR 0 2
74848: PPUSH
74849: CALL 73109 0 4
74853: ST_TO_ADDR
// end ;
74854: LD_VAR 0 3
74858: RET
// export function DangerInArea ( side , area ) ; begin
74859: LD_INT 0
74861: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74862: LD_ADDR_VAR 0 3
74866: PUSH
74867: LD_VAR 0 2
74871: PPUSH
74872: LD_INT 81
74874: PUSH
74875: LD_VAR 0 1
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: PPUSH
74884: CALL_OW 70
74888: ST_TO_ADDR
// end ;
74889: LD_VAR 0 3
74893: RET
// export function IsExtension ( b ) ; begin
74894: LD_INT 0
74896: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74897: LD_ADDR_VAR 0 2
74901: PUSH
74902: LD_VAR 0 1
74906: PUSH
74907: LD_INT 23
74909: PUSH
74910: LD_INT 20
74912: PUSH
74913: LD_INT 22
74915: PUSH
74916: LD_INT 17
74918: PUSH
74919: LD_INT 24
74921: PUSH
74922: LD_INT 21
74924: PUSH
74925: LD_INT 19
74927: PUSH
74928: LD_INT 16
74930: PUSH
74931: LD_INT 25
74933: PUSH
74934: LD_INT 18
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: IN
74949: ST_TO_ADDR
// end ;
74950: LD_VAR 0 2
74954: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74955: LD_INT 0
74957: PPUSH
74958: PPUSH
74959: PPUSH
// result := [ ] ;
74960: LD_ADDR_VAR 0 3
74964: PUSH
74965: EMPTY
74966: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74967: LD_ADDR_VAR 0 4
74971: PUSH
74972: LD_VAR 0 2
74976: PPUSH
74977: LD_INT 21
74979: PUSH
74980: LD_INT 3
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PPUSH
74987: CALL_OW 70
74991: ST_TO_ADDR
// if not tmp then
74992: LD_VAR 0 4
74996: NOT
74997: IFFALSE 75001
// exit ;
74999: GO 75059
// for i in tmp do
75001: LD_ADDR_VAR 0 5
75005: PUSH
75006: LD_VAR 0 4
75010: PUSH
75011: FOR_IN
75012: IFFALSE 75047
// if GetBase ( i ) <> base then
75014: LD_VAR 0 5
75018: PPUSH
75019: CALL_OW 274
75023: PUSH
75024: LD_VAR 0 1
75028: NONEQUAL
75029: IFFALSE 75045
// ComLinkToBase ( base , i ) ;
75031: LD_VAR 0 1
75035: PPUSH
75036: LD_VAR 0 5
75040: PPUSH
75041: CALL_OW 169
75045: GO 75011
75047: POP
75048: POP
// result := tmp ;
75049: LD_ADDR_VAR 0 3
75053: PUSH
75054: LD_VAR 0 4
75058: ST_TO_ADDR
// end ;
75059: LD_VAR 0 3
75063: RET
// export function ComComplete ( unit , b ) ; var i ; begin
75064: LD_INT 0
75066: PPUSH
75067: PPUSH
// if BuildingStatus ( b ) = bs_build then
75068: LD_VAR 0 2
75072: PPUSH
75073: CALL_OW 461
75077: PUSH
75078: LD_INT 1
75080: EQUAL
75081: IFFALSE 75141
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75083: LD_VAR 0 1
75087: PPUSH
75088: LD_STRING h
75090: PUSH
75091: LD_VAR 0 2
75095: PPUSH
75096: CALL_OW 250
75100: PUSH
75101: LD_VAR 0 2
75105: PPUSH
75106: CALL_OW 251
75110: PUSH
75111: LD_VAR 0 2
75115: PUSH
75116: LD_INT 0
75118: PUSH
75119: LD_INT 0
75121: PUSH
75122: LD_INT 0
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: PUSH
75134: EMPTY
75135: LIST
75136: PPUSH
75137: CALL_OW 446
// end ;
75141: LD_VAR 0 3
75145: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75146: LD_INT 0
75148: PPUSH
75149: PPUSH
75150: PPUSH
75151: PPUSH
75152: PPUSH
75153: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
75154: LD_VAR 0 1
75158: NOT
75159: PUSH
75160: LD_VAR 0 1
75164: PPUSH
75165: CALL_OW 263
75169: PUSH
75170: LD_INT 2
75172: EQUAL
75173: NOT
75174: OR
75175: IFFALSE 75179
// exit ;
75177: GO 75495
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75179: LD_ADDR_VAR 0 6
75183: PUSH
75184: LD_INT 22
75186: PUSH
75187: LD_VAR 0 1
75191: PPUSH
75192: CALL_OW 255
75196: PUSH
75197: EMPTY
75198: LIST
75199: LIST
75200: PUSH
75201: LD_INT 2
75203: PUSH
75204: LD_INT 30
75206: PUSH
75207: LD_INT 36
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: PUSH
75214: LD_INT 34
75216: PUSH
75217: LD_INT 31
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: LIST
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PPUSH
75233: CALL_OW 69
75237: ST_TO_ADDR
// if not tmp then
75238: LD_VAR 0 6
75242: NOT
75243: IFFALSE 75247
// exit ;
75245: GO 75495
// result := [ ] ;
75247: LD_ADDR_VAR 0 2
75251: PUSH
75252: EMPTY
75253: ST_TO_ADDR
// for i in tmp do
75254: LD_ADDR_VAR 0 3
75258: PUSH
75259: LD_VAR 0 6
75263: PUSH
75264: FOR_IN
75265: IFFALSE 75336
// begin t := UnitsInside ( i ) ;
75267: LD_ADDR_VAR 0 4
75271: PUSH
75272: LD_VAR 0 3
75276: PPUSH
75277: CALL_OW 313
75281: ST_TO_ADDR
// if t then
75282: LD_VAR 0 4
75286: IFFALSE 75334
// for j in t do
75288: LD_ADDR_VAR 0 7
75292: PUSH
75293: LD_VAR 0 4
75297: PUSH
75298: FOR_IN
75299: IFFALSE 75332
// result := Insert ( result , result + 1 , j ) ;
75301: LD_ADDR_VAR 0 2
75305: PUSH
75306: LD_VAR 0 2
75310: PPUSH
75311: LD_VAR 0 2
75315: PUSH
75316: LD_INT 1
75318: PLUS
75319: PPUSH
75320: LD_VAR 0 7
75324: PPUSH
75325: CALL_OW 2
75329: ST_TO_ADDR
75330: GO 75298
75332: POP
75333: POP
// end ;
75334: GO 75264
75336: POP
75337: POP
// if not result then
75338: LD_VAR 0 2
75342: NOT
75343: IFFALSE 75347
// exit ;
75345: GO 75495
// mech := result [ 1 ] ;
75347: LD_ADDR_VAR 0 5
75351: PUSH
75352: LD_VAR 0 2
75356: PUSH
75357: LD_INT 1
75359: ARRAY
75360: ST_TO_ADDR
// if result > 1 then
75361: LD_VAR 0 2
75365: PUSH
75366: LD_INT 1
75368: GREATER
75369: IFFALSE 75481
// for i = 2 to result do
75371: LD_ADDR_VAR 0 3
75375: PUSH
75376: DOUBLE
75377: LD_INT 2
75379: DEC
75380: ST_TO_ADDR
75381: LD_VAR 0 2
75385: PUSH
75386: FOR_TO
75387: IFFALSE 75479
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75389: LD_ADDR_VAR 0 4
75393: PUSH
75394: LD_VAR 0 2
75398: PUSH
75399: LD_VAR 0 3
75403: ARRAY
75404: PPUSH
75405: LD_INT 3
75407: PPUSH
75408: CALL_OW 259
75412: PUSH
75413: LD_VAR 0 2
75417: PUSH
75418: LD_VAR 0 3
75422: ARRAY
75423: PPUSH
75424: CALL_OW 432
75428: MINUS
75429: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75430: LD_VAR 0 4
75434: PUSH
75435: LD_VAR 0 5
75439: PPUSH
75440: LD_INT 3
75442: PPUSH
75443: CALL_OW 259
75447: PUSH
75448: LD_VAR 0 5
75452: PPUSH
75453: CALL_OW 432
75457: MINUS
75458: GREATEREQUAL
75459: IFFALSE 75477
// mech := result [ i ] ;
75461: LD_ADDR_VAR 0 5
75465: PUSH
75466: LD_VAR 0 2
75470: PUSH
75471: LD_VAR 0 3
75475: ARRAY
75476: ST_TO_ADDR
// end ;
75477: GO 75386
75479: POP
75480: POP
// ComLinkTo ( vehicle , mech ) ;
75481: LD_VAR 0 1
75485: PPUSH
75486: LD_VAR 0 5
75490: PPUSH
75491: CALL_OW 135
// end ;
75495: LD_VAR 0 2
75499: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75500: LD_INT 0
75502: PPUSH
75503: PPUSH
75504: PPUSH
75505: PPUSH
75506: PPUSH
75507: PPUSH
75508: PPUSH
75509: PPUSH
75510: PPUSH
75511: PPUSH
75512: PPUSH
75513: PPUSH
75514: PPUSH
// result := [ ] ;
75515: LD_ADDR_VAR 0 7
75519: PUSH
75520: EMPTY
75521: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75522: LD_VAR 0 1
75526: PPUSH
75527: CALL_OW 266
75531: PUSH
75532: LD_INT 0
75534: PUSH
75535: LD_INT 1
75537: PUSH
75538: EMPTY
75539: LIST
75540: LIST
75541: IN
75542: NOT
75543: IFFALSE 75547
// exit ;
75545: GO 77178
// if name then
75547: LD_VAR 0 3
75551: IFFALSE 75567
// SetBName ( base_dep , name ) ;
75553: LD_VAR 0 1
75557: PPUSH
75558: LD_VAR 0 3
75562: PPUSH
75563: CALL_OW 500
// base := GetBase ( base_dep ) ;
75567: LD_ADDR_VAR 0 15
75571: PUSH
75572: LD_VAR 0 1
75576: PPUSH
75577: CALL_OW 274
75581: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75582: LD_ADDR_VAR 0 16
75586: PUSH
75587: LD_VAR 0 1
75591: PPUSH
75592: CALL_OW 255
75596: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75597: LD_ADDR_VAR 0 17
75601: PUSH
75602: LD_VAR 0 1
75606: PPUSH
75607: CALL_OW 248
75611: ST_TO_ADDR
// if sources then
75612: LD_VAR 0 5
75616: IFFALSE 75663
// for i = 1 to 3 do
75618: LD_ADDR_VAR 0 8
75622: PUSH
75623: DOUBLE
75624: LD_INT 1
75626: DEC
75627: ST_TO_ADDR
75628: LD_INT 3
75630: PUSH
75631: FOR_TO
75632: IFFALSE 75661
// AddResourceType ( base , i , sources [ i ] ) ;
75634: LD_VAR 0 15
75638: PPUSH
75639: LD_VAR 0 8
75643: PPUSH
75644: LD_VAR 0 5
75648: PUSH
75649: LD_VAR 0 8
75653: ARRAY
75654: PPUSH
75655: CALL_OW 276
75659: GO 75631
75661: POP
75662: POP
// buildings := GetBaseBuildings ( base , area ) ;
75663: LD_ADDR_VAR 0 18
75667: PUSH
75668: LD_VAR 0 15
75672: PPUSH
75673: LD_VAR 0 2
75677: PPUSH
75678: CALL 74955 0 2
75682: ST_TO_ADDR
// InitHc ;
75683: CALL_OW 19
// InitUc ;
75687: CALL_OW 18
// uc_side := side ;
75691: LD_ADDR_OWVAR 20
75695: PUSH
75696: LD_VAR 0 16
75700: ST_TO_ADDR
// uc_nation := nation ;
75701: LD_ADDR_OWVAR 21
75705: PUSH
75706: LD_VAR 0 17
75710: ST_TO_ADDR
// if buildings then
75711: LD_VAR 0 18
75715: IFFALSE 77037
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75717: LD_ADDR_VAR 0 19
75721: PUSH
75722: LD_VAR 0 18
75726: PPUSH
75727: LD_INT 2
75729: PUSH
75730: LD_INT 30
75732: PUSH
75733: LD_INT 29
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 30
75742: PUSH
75743: LD_INT 30
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: LIST
75754: PPUSH
75755: CALL_OW 72
75759: ST_TO_ADDR
// if tmp then
75760: LD_VAR 0 19
75764: IFFALSE 75812
// for i in tmp do
75766: LD_ADDR_VAR 0 8
75770: PUSH
75771: LD_VAR 0 19
75775: PUSH
75776: FOR_IN
75777: IFFALSE 75810
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75779: LD_VAR 0 8
75783: PPUSH
75784: CALL_OW 250
75788: PPUSH
75789: LD_VAR 0 8
75793: PPUSH
75794: CALL_OW 251
75798: PPUSH
75799: LD_VAR 0 16
75803: PPUSH
75804: CALL_OW 441
75808: GO 75776
75810: POP
75811: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75812: LD_VAR 0 18
75816: PPUSH
75817: LD_INT 2
75819: PUSH
75820: LD_INT 30
75822: PUSH
75823: LD_INT 32
75825: PUSH
75826: EMPTY
75827: LIST
75828: LIST
75829: PUSH
75830: LD_INT 30
75832: PUSH
75833: LD_INT 33
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: LIST
75844: PPUSH
75845: CALL_OW 72
75849: IFFALSE 75937
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75851: LD_ADDR_VAR 0 8
75855: PUSH
75856: LD_VAR 0 18
75860: PPUSH
75861: LD_INT 2
75863: PUSH
75864: LD_INT 30
75866: PUSH
75867: LD_INT 32
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 30
75876: PUSH
75877: LD_INT 33
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: LIST
75888: PPUSH
75889: CALL_OW 72
75893: PUSH
75894: FOR_IN
75895: IFFALSE 75935
// begin if not GetBWeapon ( i ) then
75897: LD_VAR 0 8
75901: PPUSH
75902: CALL_OW 269
75906: NOT
75907: IFFALSE 75933
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75909: LD_VAR 0 8
75913: PPUSH
75914: LD_VAR 0 8
75918: PPUSH
75919: LD_VAR 0 2
75923: PPUSH
75924: CALL 77183 0 2
75928: PPUSH
75929: CALL_OW 431
// end ;
75933: GO 75894
75935: POP
75936: POP
// end ; for i = 1 to personel do
75937: LD_ADDR_VAR 0 8
75941: PUSH
75942: DOUBLE
75943: LD_INT 1
75945: DEC
75946: ST_TO_ADDR
75947: LD_VAR 0 6
75951: PUSH
75952: FOR_TO
75953: IFFALSE 77017
// begin if i > 4 then
75955: LD_VAR 0 8
75959: PUSH
75960: LD_INT 4
75962: GREATER
75963: IFFALSE 75967
// break ;
75965: GO 77017
// case i of 1 :
75967: LD_VAR 0 8
75971: PUSH
75972: LD_INT 1
75974: DOUBLE
75975: EQUAL
75976: IFTRUE 75980
75978: GO 76060
75980: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75981: LD_ADDR_VAR 0 12
75985: PUSH
75986: LD_VAR 0 18
75990: PPUSH
75991: LD_INT 22
75993: PUSH
75994: LD_VAR 0 16
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 58
76005: PUSH
76006: EMPTY
76007: LIST
76008: PUSH
76009: LD_INT 2
76011: PUSH
76012: LD_INT 30
76014: PUSH
76015: LD_INT 32
76017: PUSH
76018: EMPTY
76019: LIST
76020: LIST
76021: PUSH
76022: LD_INT 30
76024: PUSH
76025: LD_INT 4
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 30
76034: PUSH
76035: LD_INT 5
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: LIST
76052: PPUSH
76053: CALL_OW 72
76057: ST_TO_ADDR
76058: GO 76282
76060: LD_INT 2
76062: DOUBLE
76063: EQUAL
76064: IFTRUE 76068
76066: GO 76130
76068: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76069: LD_ADDR_VAR 0 12
76073: PUSH
76074: LD_VAR 0 18
76078: PPUSH
76079: LD_INT 22
76081: PUSH
76082: LD_VAR 0 16
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 2
76093: PUSH
76094: LD_INT 30
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PUSH
76104: LD_INT 30
76106: PUSH
76107: LD_INT 1
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: LIST
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PPUSH
76123: CALL_OW 72
76127: ST_TO_ADDR
76128: GO 76282
76130: LD_INT 3
76132: DOUBLE
76133: EQUAL
76134: IFTRUE 76138
76136: GO 76200
76138: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76139: LD_ADDR_VAR 0 12
76143: PUSH
76144: LD_VAR 0 18
76148: PPUSH
76149: LD_INT 22
76151: PUSH
76152: LD_VAR 0 16
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 2
76163: PUSH
76164: LD_INT 30
76166: PUSH
76167: LD_INT 2
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 30
76176: PUSH
76177: LD_INT 3
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: EMPTY
76185: LIST
76186: LIST
76187: LIST
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PPUSH
76193: CALL_OW 72
76197: ST_TO_ADDR
76198: GO 76282
76200: LD_INT 4
76202: DOUBLE
76203: EQUAL
76204: IFTRUE 76208
76206: GO 76281
76208: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76209: LD_ADDR_VAR 0 12
76213: PUSH
76214: LD_VAR 0 18
76218: PPUSH
76219: LD_INT 22
76221: PUSH
76222: LD_VAR 0 16
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 2
76233: PUSH
76234: LD_INT 30
76236: PUSH
76237: LD_INT 6
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PUSH
76244: LD_INT 30
76246: PUSH
76247: LD_INT 7
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PUSH
76254: LD_INT 30
76256: PUSH
76257: LD_INT 8
76259: PUSH
76260: EMPTY
76261: LIST
76262: LIST
76263: PUSH
76264: EMPTY
76265: LIST
76266: LIST
76267: LIST
76268: LIST
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PPUSH
76274: CALL_OW 72
76278: ST_TO_ADDR
76279: GO 76282
76281: POP
// if i = 1 then
76282: LD_VAR 0 8
76286: PUSH
76287: LD_INT 1
76289: EQUAL
76290: IFFALSE 76401
// begin tmp := [ ] ;
76292: LD_ADDR_VAR 0 19
76296: PUSH
76297: EMPTY
76298: ST_TO_ADDR
// for j in f do
76299: LD_ADDR_VAR 0 9
76303: PUSH
76304: LD_VAR 0 12
76308: PUSH
76309: FOR_IN
76310: IFFALSE 76383
// if GetBType ( j ) = b_bunker then
76312: LD_VAR 0 9
76316: PPUSH
76317: CALL_OW 266
76321: PUSH
76322: LD_INT 32
76324: EQUAL
76325: IFFALSE 76352
// tmp := Insert ( tmp , 1 , j ) else
76327: LD_ADDR_VAR 0 19
76331: PUSH
76332: LD_VAR 0 19
76336: PPUSH
76337: LD_INT 1
76339: PPUSH
76340: LD_VAR 0 9
76344: PPUSH
76345: CALL_OW 2
76349: ST_TO_ADDR
76350: GO 76381
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76352: LD_ADDR_VAR 0 19
76356: PUSH
76357: LD_VAR 0 19
76361: PPUSH
76362: LD_VAR 0 19
76366: PUSH
76367: LD_INT 1
76369: PLUS
76370: PPUSH
76371: LD_VAR 0 9
76375: PPUSH
76376: CALL_OW 2
76380: ST_TO_ADDR
76381: GO 76309
76383: POP
76384: POP
// if tmp then
76385: LD_VAR 0 19
76389: IFFALSE 76401
// f := tmp ;
76391: LD_ADDR_VAR 0 12
76395: PUSH
76396: LD_VAR 0 19
76400: ST_TO_ADDR
// end ; x := personel [ i ] ;
76401: LD_ADDR_VAR 0 13
76405: PUSH
76406: LD_VAR 0 6
76410: PUSH
76411: LD_VAR 0 8
76415: ARRAY
76416: ST_TO_ADDR
// if x = - 1 then
76417: LD_VAR 0 13
76421: PUSH
76422: LD_INT 1
76424: NEG
76425: EQUAL
76426: IFFALSE 76635
// begin for j in f do
76428: LD_ADDR_VAR 0 9
76432: PUSH
76433: LD_VAR 0 12
76437: PUSH
76438: FOR_IN
76439: IFFALSE 76631
// repeat InitHc ;
76441: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76445: LD_VAR 0 9
76449: PPUSH
76450: CALL_OW 266
76454: PUSH
76455: LD_INT 5
76457: EQUAL
76458: IFFALSE 76528
// begin if UnitsInside ( j ) < 3 then
76460: LD_VAR 0 9
76464: PPUSH
76465: CALL_OW 313
76469: PUSH
76470: LD_INT 3
76472: LESS
76473: IFFALSE 76509
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76475: LD_INT 0
76477: PPUSH
76478: LD_INT 5
76480: PUSH
76481: LD_INT 8
76483: PUSH
76484: LD_INT 9
76486: PUSH
76487: EMPTY
76488: LIST
76489: LIST
76490: LIST
76491: PUSH
76492: LD_VAR 0 17
76496: ARRAY
76497: PPUSH
76498: LD_VAR 0 4
76502: PPUSH
76503: CALL_OW 380
76507: GO 76526
// PrepareHuman ( false , i , skill ) ;
76509: LD_INT 0
76511: PPUSH
76512: LD_VAR 0 8
76516: PPUSH
76517: LD_VAR 0 4
76521: PPUSH
76522: CALL_OW 380
// end else
76526: GO 76545
// PrepareHuman ( false , i , skill ) ;
76528: LD_INT 0
76530: PPUSH
76531: LD_VAR 0 8
76535: PPUSH
76536: LD_VAR 0 4
76540: PPUSH
76541: CALL_OW 380
// un := CreateHuman ;
76545: LD_ADDR_VAR 0 14
76549: PUSH
76550: CALL_OW 44
76554: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76555: LD_ADDR_VAR 0 7
76559: PUSH
76560: LD_VAR 0 7
76564: PPUSH
76565: LD_INT 1
76567: PPUSH
76568: LD_VAR 0 14
76572: PPUSH
76573: CALL_OW 2
76577: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76578: LD_VAR 0 14
76582: PPUSH
76583: LD_VAR 0 9
76587: PPUSH
76588: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76592: LD_VAR 0 9
76596: PPUSH
76597: CALL_OW 313
76601: PUSH
76602: LD_INT 6
76604: EQUAL
76605: PUSH
76606: LD_VAR 0 9
76610: PPUSH
76611: CALL_OW 266
76615: PUSH
76616: LD_INT 32
76618: PUSH
76619: LD_INT 31
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: IN
76626: OR
76627: IFFALSE 76441
76629: GO 76438
76631: POP
76632: POP
// end else
76633: GO 77015
// for j = 1 to x do
76635: LD_ADDR_VAR 0 9
76639: PUSH
76640: DOUBLE
76641: LD_INT 1
76643: DEC
76644: ST_TO_ADDR
76645: LD_VAR 0 13
76649: PUSH
76650: FOR_TO
76651: IFFALSE 77013
// begin InitHc ;
76653: CALL_OW 19
// if not f then
76657: LD_VAR 0 12
76661: NOT
76662: IFFALSE 76751
// begin PrepareHuman ( false , i , skill ) ;
76664: LD_INT 0
76666: PPUSH
76667: LD_VAR 0 8
76671: PPUSH
76672: LD_VAR 0 4
76676: PPUSH
76677: CALL_OW 380
// un := CreateHuman ;
76681: LD_ADDR_VAR 0 14
76685: PUSH
76686: CALL_OW 44
76690: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76691: LD_ADDR_VAR 0 7
76695: PUSH
76696: LD_VAR 0 7
76700: PPUSH
76701: LD_INT 1
76703: PPUSH
76704: LD_VAR 0 14
76708: PPUSH
76709: CALL_OW 2
76713: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76714: LD_VAR 0 14
76718: PPUSH
76719: LD_VAR 0 1
76723: PPUSH
76724: CALL_OW 250
76728: PPUSH
76729: LD_VAR 0 1
76733: PPUSH
76734: CALL_OW 251
76738: PPUSH
76739: LD_INT 10
76741: PPUSH
76742: LD_INT 0
76744: PPUSH
76745: CALL_OW 50
// continue ;
76749: GO 76650
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76751: LD_VAR 0 12
76755: PUSH
76756: LD_INT 1
76758: ARRAY
76759: PPUSH
76760: CALL_OW 313
76764: PUSH
76765: LD_VAR 0 12
76769: PUSH
76770: LD_INT 1
76772: ARRAY
76773: PPUSH
76774: CALL_OW 266
76778: PUSH
76779: LD_INT 32
76781: PUSH
76782: LD_INT 31
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: IN
76789: AND
76790: PUSH
76791: LD_VAR 0 12
76795: PUSH
76796: LD_INT 1
76798: ARRAY
76799: PPUSH
76800: CALL_OW 313
76804: PUSH
76805: LD_INT 6
76807: EQUAL
76808: OR
76809: IFFALSE 76829
// f := Delete ( f , 1 ) ;
76811: LD_ADDR_VAR 0 12
76815: PUSH
76816: LD_VAR 0 12
76820: PPUSH
76821: LD_INT 1
76823: PPUSH
76824: CALL_OW 3
76828: ST_TO_ADDR
// if not f then
76829: LD_VAR 0 12
76833: NOT
76834: IFFALSE 76852
// begin x := x + 2 ;
76836: LD_ADDR_VAR 0 13
76840: PUSH
76841: LD_VAR 0 13
76845: PUSH
76846: LD_INT 2
76848: PLUS
76849: ST_TO_ADDR
// continue ;
76850: GO 76650
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76852: LD_VAR 0 12
76856: PUSH
76857: LD_INT 1
76859: ARRAY
76860: PPUSH
76861: CALL_OW 266
76865: PUSH
76866: LD_INT 5
76868: EQUAL
76869: IFFALSE 76943
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76871: LD_VAR 0 12
76875: PUSH
76876: LD_INT 1
76878: ARRAY
76879: PPUSH
76880: CALL_OW 313
76884: PUSH
76885: LD_INT 3
76887: LESS
76888: IFFALSE 76924
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76890: LD_INT 0
76892: PPUSH
76893: LD_INT 5
76895: PUSH
76896: LD_INT 8
76898: PUSH
76899: LD_INT 9
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: LIST
76906: PUSH
76907: LD_VAR 0 17
76911: ARRAY
76912: PPUSH
76913: LD_VAR 0 4
76917: PPUSH
76918: CALL_OW 380
76922: GO 76941
// PrepareHuman ( false , i , skill ) ;
76924: LD_INT 0
76926: PPUSH
76927: LD_VAR 0 8
76931: PPUSH
76932: LD_VAR 0 4
76936: PPUSH
76937: CALL_OW 380
// end else
76941: GO 76960
// PrepareHuman ( false , i , skill ) ;
76943: LD_INT 0
76945: PPUSH
76946: LD_VAR 0 8
76950: PPUSH
76951: LD_VAR 0 4
76955: PPUSH
76956: CALL_OW 380
// un := CreateHuman ;
76960: LD_ADDR_VAR 0 14
76964: PUSH
76965: CALL_OW 44
76969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76970: LD_ADDR_VAR 0 7
76974: PUSH
76975: LD_VAR 0 7
76979: PPUSH
76980: LD_INT 1
76982: PPUSH
76983: LD_VAR 0 14
76987: PPUSH
76988: CALL_OW 2
76992: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76993: LD_VAR 0 14
76997: PPUSH
76998: LD_VAR 0 12
77002: PUSH
77003: LD_INT 1
77005: ARRAY
77006: PPUSH
77007: CALL_OW 52
// end ;
77011: GO 76650
77013: POP
77014: POP
// end ;
77015: GO 75952
77017: POP
77018: POP
// result := result ^ buildings ;
77019: LD_ADDR_VAR 0 7
77023: PUSH
77024: LD_VAR 0 7
77028: PUSH
77029: LD_VAR 0 18
77033: ADD
77034: ST_TO_ADDR
// end else
77035: GO 77178
// begin for i = 1 to personel do
77037: LD_ADDR_VAR 0 8
77041: PUSH
77042: DOUBLE
77043: LD_INT 1
77045: DEC
77046: ST_TO_ADDR
77047: LD_VAR 0 6
77051: PUSH
77052: FOR_TO
77053: IFFALSE 77176
// begin if i > 4 then
77055: LD_VAR 0 8
77059: PUSH
77060: LD_INT 4
77062: GREATER
77063: IFFALSE 77067
// break ;
77065: GO 77176
// x := personel [ i ] ;
77067: LD_ADDR_VAR 0 13
77071: PUSH
77072: LD_VAR 0 6
77076: PUSH
77077: LD_VAR 0 8
77081: ARRAY
77082: ST_TO_ADDR
// if x = - 1 then
77083: LD_VAR 0 13
77087: PUSH
77088: LD_INT 1
77090: NEG
77091: EQUAL
77092: IFFALSE 77096
// continue ;
77094: GO 77052
// PrepareHuman ( false , i , skill ) ;
77096: LD_INT 0
77098: PPUSH
77099: LD_VAR 0 8
77103: PPUSH
77104: LD_VAR 0 4
77108: PPUSH
77109: CALL_OW 380
// un := CreateHuman ;
77113: LD_ADDR_VAR 0 14
77117: PUSH
77118: CALL_OW 44
77122: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77123: LD_VAR 0 14
77127: PPUSH
77128: LD_VAR 0 1
77132: PPUSH
77133: CALL_OW 250
77137: PPUSH
77138: LD_VAR 0 1
77142: PPUSH
77143: CALL_OW 251
77147: PPUSH
77148: LD_INT 10
77150: PPUSH
77151: LD_INT 0
77153: PPUSH
77154: CALL_OW 50
// result := result ^ un ;
77158: LD_ADDR_VAR 0 7
77162: PUSH
77163: LD_VAR 0 7
77167: PUSH
77168: LD_VAR 0 14
77172: ADD
77173: ST_TO_ADDR
// end ;
77174: GO 77052
77176: POP
77177: POP
// end ; end ;
77178: LD_VAR 0 7
77182: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77183: LD_INT 0
77185: PPUSH
77186: PPUSH
77187: PPUSH
77188: PPUSH
77189: PPUSH
77190: PPUSH
77191: PPUSH
77192: PPUSH
77193: PPUSH
77194: PPUSH
77195: PPUSH
77196: PPUSH
77197: PPUSH
77198: PPUSH
77199: PPUSH
77200: PPUSH
// result := false ;
77201: LD_ADDR_VAR 0 3
77205: PUSH
77206: LD_INT 0
77208: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77209: LD_VAR 0 1
77213: NOT
77214: PUSH
77215: LD_VAR 0 1
77219: PPUSH
77220: CALL_OW 266
77224: PUSH
77225: LD_INT 32
77227: PUSH
77228: LD_INT 33
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: IN
77235: NOT
77236: OR
77237: IFFALSE 77241
// exit ;
77239: GO 78377
// nat := GetNation ( tower ) ;
77241: LD_ADDR_VAR 0 12
77245: PUSH
77246: LD_VAR 0 1
77250: PPUSH
77251: CALL_OW 248
77255: ST_TO_ADDR
// side := GetSide ( tower ) ;
77256: LD_ADDR_VAR 0 16
77260: PUSH
77261: LD_VAR 0 1
77265: PPUSH
77266: CALL_OW 255
77270: ST_TO_ADDR
// x := GetX ( tower ) ;
77271: LD_ADDR_VAR 0 10
77275: PUSH
77276: LD_VAR 0 1
77280: PPUSH
77281: CALL_OW 250
77285: ST_TO_ADDR
// y := GetY ( tower ) ;
77286: LD_ADDR_VAR 0 11
77290: PUSH
77291: LD_VAR 0 1
77295: PPUSH
77296: CALL_OW 251
77300: ST_TO_ADDR
// if not x or not y then
77301: LD_VAR 0 10
77305: NOT
77306: PUSH
77307: LD_VAR 0 11
77311: NOT
77312: OR
77313: IFFALSE 77317
// exit ;
77315: GO 78377
// weapon := 0 ;
77317: LD_ADDR_VAR 0 18
77321: PUSH
77322: LD_INT 0
77324: ST_TO_ADDR
// fac_list := [ ] ;
77325: LD_ADDR_VAR 0 17
77329: PUSH
77330: EMPTY
77331: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77332: LD_ADDR_VAR 0 6
77336: PUSH
77337: LD_VAR 0 1
77341: PPUSH
77342: CALL_OW 274
77346: PPUSH
77347: LD_VAR 0 2
77351: PPUSH
77352: CALL 74955 0 2
77356: PPUSH
77357: LD_INT 30
77359: PUSH
77360: LD_INT 3
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: PPUSH
77367: CALL_OW 72
77371: ST_TO_ADDR
// if not factories then
77372: LD_VAR 0 6
77376: NOT
77377: IFFALSE 77381
// exit ;
77379: GO 78377
// for i in factories do
77381: LD_ADDR_VAR 0 8
77385: PUSH
77386: LD_VAR 0 6
77390: PUSH
77391: FOR_IN
77392: IFFALSE 77417
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77394: LD_ADDR_VAR 0 17
77398: PUSH
77399: LD_VAR 0 17
77403: PUSH
77404: LD_VAR 0 8
77408: PPUSH
77409: CALL_OW 478
77413: UNION
77414: ST_TO_ADDR
77415: GO 77391
77417: POP
77418: POP
// if not fac_list then
77419: LD_VAR 0 17
77423: NOT
77424: IFFALSE 77428
// exit ;
77426: GO 78377
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77428: LD_ADDR_VAR 0 5
77432: PUSH
77433: LD_INT 4
77435: PUSH
77436: LD_INT 5
77438: PUSH
77439: LD_INT 9
77441: PUSH
77442: LD_INT 10
77444: PUSH
77445: LD_INT 6
77447: PUSH
77448: LD_INT 7
77450: PUSH
77451: LD_INT 11
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: LIST
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 27
77465: PUSH
77466: LD_INT 28
77468: PUSH
77469: LD_INT 26
77471: PUSH
77472: LD_INT 30
77474: PUSH
77475: EMPTY
77476: LIST
77477: LIST
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 43
77483: PUSH
77484: LD_INT 44
77486: PUSH
77487: LD_INT 46
77489: PUSH
77490: LD_INT 45
77492: PUSH
77493: LD_INT 47
77495: PUSH
77496: LD_INT 49
77498: PUSH
77499: EMPTY
77500: LIST
77501: LIST
77502: LIST
77503: LIST
77504: LIST
77505: LIST
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: LIST
77511: PUSH
77512: LD_VAR 0 12
77516: ARRAY
77517: ST_TO_ADDR
// for i in list do
77518: LD_ADDR_VAR 0 8
77522: PUSH
77523: LD_VAR 0 5
77527: PUSH
77528: FOR_IN
77529: IFFALSE 77562
// if not i in fac_list then
77531: LD_VAR 0 8
77535: PUSH
77536: LD_VAR 0 17
77540: IN
77541: NOT
77542: IFFALSE 77560
// list := list diff i ;
77544: LD_ADDR_VAR 0 5
77548: PUSH
77549: LD_VAR 0 5
77553: PUSH
77554: LD_VAR 0 8
77558: DIFF
77559: ST_TO_ADDR
77560: GO 77528
77562: POP
77563: POP
// if not list then
77564: LD_VAR 0 5
77568: NOT
77569: IFFALSE 77573
// exit ;
77571: GO 78377
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77573: LD_VAR 0 12
77577: PUSH
77578: LD_INT 3
77580: EQUAL
77581: PUSH
77582: LD_INT 49
77584: PUSH
77585: LD_VAR 0 5
77589: IN
77590: AND
77591: PUSH
77592: LD_INT 31
77594: PPUSH
77595: LD_VAR 0 16
77599: PPUSH
77600: CALL_OW 321
77604: PUSH
77605: LD_INT 2
77607: EQUAL
77608: AND
77609: IFFALSE 77669
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77611: LD_INT 22
77613: PUSH
77614: LD_VAR 0 16
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 35
77625: PUSH
77626: LD_INT 49
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 91
77635: PUSH
77636: LD_VAR 0 1
77640: PUSH
77641: LD_INT 10
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: LIST
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: LIST
77653: PPUSH
77654: CALL_OW 69
77658: NOT
77659: IFFALSE 77669
// weapon := ru_time_lapser ;
77661: LD_ADDR_VAR 0 18
77665: PUSH
77666: LD_INT 49
77668: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77669: LD_VAR 0 12
77673: PUSH
77674: LD_INT 1
77676: PUSH
77677: LD_INT 2
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: IN
77684: PUSH
77685: LD_INT 11
77687: PUSH
77688: LD_VAR 0 5
77692: IN
77693: PUSH
77694: LD_INT 30
77696: PUSH
77697: LD_VAR 0 5
77701: IN
77702: OR
77703: AND
77704: PUSH
77705: LD_INT 6
77707: PPUSH
77708: LD_VAR 0 16
77712: PPUSH
77713: CALL_OW 321
77717: PUSH
77718: LD_INT 2
77720: EQUAL
77721: AND
77722: IFFALSE 77887
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77724: LD_INT 22
77726: PUSH
77727: LD_VAR 0 16
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 2
77738: PUSH
77739: LD_INT 35
77741: PUSH
77742: LD_INT 11
77744: PUSH
77745: EMPTY
77746: LIST
77747: LIST
77748: PUSH
77749: LD_INT 35
77751: PUSH
77752: LD_INT 30
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: LIST
77763: PUSH
77764: LD_INT 91
77766: PUSH
77767: LD_VAR 0 1
77771: PUSH
77772: LD_INT 18
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: LIST
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: LIST
77784: PPUSH
77785: CALL_OW 69
77789: NOT
77790: PUSH
77791: LD_INT 22
77793: PUSH
77794: LD_VAR 0 16
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: PUSH
77803: LD_INT 2
77805: PUSH
77806: LD_INT 30
77808: PUSH
77809: LD_INT 32
77811: PUSH
77812: EMPTY
77813: LIST
77814: LIST
77815: PUSH
77816: LD_INT 30
77818: PUSH
77819: LD_INT 33
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 91
77833: PUSH
77834: LD_VAR 0 1
77838: PUSH
77839: LD_INT 12
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: LIST
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: LIST
77851: PUSH
77852: EMPTY
77853: LIST
77854: PPUSH
77855: CALL_OW 69
77859: PUSH
77860: LD_INT 2
77862: GREATER
77863: AND
77864: IFFALSE 77887
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77866: LD_ADDR_VAR 0 18
77870: PUSH
77871: LD_INT 11
77873: PUSH
77874: LD_INT 30
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_VAR 0 12
77885: ARRAY
77886: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77887: LD_VAR 0 18
77891: NOT
77892: PUSH
77893: LD_INT 40
77895: PPUSH
77896: LD_VAR 0 16
77900: PPUSH
77901: CALL_OW 321
77905: PUSH
77906: LD_INT 2
77908: EQUAL
77909: AND
77910: PUSH
77911: LD_INT 7
77913: PUSH
77914: LD_VAR 0 5
77918: IN
77919: PUSH
77920: LD_INT 28
77922: PUSH
77923: LD_VAR 0 5
77927: IN
77928: OR
77929: PUSH
77930: LD_INT 45
77932: PUSH
77933: LD_VAR 0 5
77937: IN
77938: OR
77939: AND
77940: IFFALSE 78194
// begin hex := GetHexInfo ( x , y ) ;
77942: LD_ADDR_VAR 0 4
77946: PUSH
77947: LD_VAR 0 10
77951: PPUSH
77952: LD_VAR 0 11
77956: PPUSH
77957: CALL_OW 546
77961: ST_TO_ADDR
// if hex [ 1 ] then
77962: LD_VAR 0 4
77966: PUSH
77967: LD_INT 1
77969: ARRAY
77970: IFFALSE 77974
// exit ;
77972: GO 78377
// height := hex [ 2 ] ;
77974: LD_ADDR_VAR 0 15
77978: PUSH
77979: LD_VAR 0 4
77983: PUSH
77984: LD_INT 2
77986: ARRAY
77987: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77988: LD_ADDR_VAR 0 14
77992: PUSH
77993: LD_INT 0
77995: PUSH
77996: LD_INT 2
77998: PUSH
77999: LD_INT 3
78001: PUSH
78002: LD_INT 5
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: ST_TO_ADDR
// for i in tmp do
78011: LD_ADDR_VAR 0 8
78015: PUSH
78016: LD_VAR 0 14
78020: PUSH
78021: FOR_IN
78022: IFFALSE 78192
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78024: LD_ADDR_VAR 0 9
78028: PUSH
78029: LD_VAR 0 10
78033: PPUSH
78034: LD_VAR 0 8
78038: PPUSH
78039: LD_INT 5
78041: PPUSH
78042: CALL_OW 272
78046: PUSH
78047: LD_VAR 0 11
78051: PPUSH
78052: LD_VAR 0 8
78056: PPUSH
78057: LD_INT 5
78059: PPUSH
78060: CALL_OW 273
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78069: LD_VAR 0 9
78073: PUSH
78074: LD_INT 1
78076: ARRAY
78077: PPUSH
78078: LD_VAR 0 9
78082: PUSH
78083: LD_INT 2
78085: ARRAY
78086: PPUSH
78087: CALL_OW 488
78091: IFFALSE 78190
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78093: LD_ADDR_VAR 0 4
78097: PUSH
78098: LD_VAR 0 9
78102: PUSH
78103: LD_INT 1
78105: ARRAY
78106: PPUSH
78107: LD_VAR 0 9
78111: PUSH
78112: LD_INT 2
78114: ARRAY
78115: PPUSH
78116: CALL_OW 546
78120: ST_TO_ADDR
// if hex [ 1 ] then
78121: LD_VAR 0 4
78125: PUSH
78126: LD_INT 1
78128: ARRAY
78129: IFFALSE 78133
// continue ;
78131: GO 78021
// h := hex [ 2 ] ;
78133: LD_ADDR_VAR 0 13
78137: PUSH
78138: LD_VAR 0 4
78142: PUSH
78143: LD_INT 2
78145: ARRAY
78146: ST_TO_ADDR
// if h + 7 < height then
78147: LD_VAR 0 13
78151: PUSH
78152: LD_INT 7
78154: PLUS
78155: PUSH
78156: LD_VAR 0 15
78160: LESS
78161: IFFALSE 78190
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78163: LD_ADDR_VAR 0 18
78167: PUSH
78168: LD_INT 7
78170: PUSH
78171: LD_INT 28
78173: PUSH
78174: LD_INT 45
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: LIST
78181: PUSH
78182: LD_VAR 0 12
78186: ARRAY
78187: ST_TO_ADDR
// break ;
78188: GO 78192
// end ; end ; end ;
78190: GO 78021
78192: POP
78193: POP
// end ; if not weapon then
78194: LD_VAR 0 18
78198: NOT
78199: IFFALSE 78259
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78201: LD_ADDR_VAR 0 5
78205: PUSH
78206: LD_VAR 0 5
78210: PUSH
78211: LD_INT 11
78213: PUSH
78214: LD_INT 30
78216: PUSH
78217: LD_INT 49
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: LIST
78224: DIFF
78225: ST_TO_ADDR
// if not list then
78226: LD_VAR 0 5
78230: NOT
78231: IFFALSE 78235
// exit ;
78233: GO 78377
// weapon := list [ rand ( 1 , list ) ] ;
78235: LD_ADDR_VAR 0 18
78239: PUSH
78240: LD_VAR 0 5
78244: PUSH
78245: LD_INT 1
78247: PPUSH
78248: LD_VAR 0 5
78252: PPUSH
78253: CALL_OW 12
78257: ARRAY
78258: ST_TO_ADDR
// end ; if weapon then
78259: LD_VAR 0 18
78263: IFFALSE 78377
// begin tmp := CostOfWeapon ( weapon ) ;
78265: LD_ADDR_VAR 0 14
78269: PUSH
78270: LD_VAR 0 18
78274: PPUSH
78275: CALL_OW 451
78279: ST_TO_ADDR
// j := GetBase ( tower ) ;
78280: LD_ADDR_VAR 0 9
78284: PUSH
78285: LD_VAR 0 1
78289: PPUSH
78290: CALL_OW 274
78294: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78295: LD_VAR 0 9
78299: PPUSH
78300: LD_INT 1
78302: PPUSH
78303: CALL_OW 275
78307: PUSH
78308: LD_VAR 0 14
78312: PUSH
78313: LD_INT 1
78315: ARRAY
78316: GREATEREQUAL
78317: PUSH
78318: LD_VAR 0 9
78322: PPUSH
78323: LD_INT 2
78325: PPUSH
78326: CALL_OW 275
78330: PUSH
78331: LD_VAR 0 14
78335: PUSH
78336: LD_INT 2
78338: ARRAY
78339: GREATEREQUAL
78340: AND
78341: PUSH
78342: LD_VAR 0 9
78346: PPUSH
78347: LD_INT 3
78349: PPUSH
78350: CALL_OW 275
78354: PUSH
78355: LD_VAR 0 14
78359: PUSH
78360: LD_INT 3
78362: ARRAY
78363: GREATEREQUAL
78364: AND
78365: IFFALSE 78377
// result := weapon ;
78367: LD_ADDR_VAR 0 3
78371: PUSH
78372: LD_VAR 0 18
78376: ST_TO_ADDR
// end ; end ;
78377: LD_VAR 0 3
78381: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78382: LD_INT 0
78384: PPUSH
78385: PPUSH
// result := true ;
78386: LD_ADDR_VAR 0 3
78390: PUSH
78391: LD_INT 1
78393: ST_TO_ADDR
// if array1 = array2 then
78394: LD_VAR 0 1
78398: PUSH
78399: LD_VAR 0 2
78403: EQUAL
78404: IFFALSE 78464
// begin for i = 1 to array1 do
78406: LD_ADDR_VAR 0 4
78410: PUSH
78411: DOUBLE
78412: LD_INT 1
78414: DEC
78415: ST_TO_ADDR
78416: LD_VAR 0 1
78420: PUSH
78421: FOR_TO
78422: IFFALSE 78460
// if array1 [ i ] <> array2 [ i ] then
78424: LD_VAR 0 1
78428: PUSH
78429: LD_VAR 0 4
78433: ARRAY
78434: PUSH
78435: LD_VAR 0 2
78439: PUSH
78440: LD_VAR 0 4
78444: ARRAY
78445: NONEQUAL
78446: IFFALSE 78458
// begin result := false ;
78448: LD_ADDR_VAR 0 3
78452: PUSH
78453: LD_INT 0
78455: ST_TO_ADDR
// break ;
78456: GO 78460
// end ;
78458: GO 78421
78460: POP
78461: POP
// end else
78462: GO 78472
// result := false ;
78464: LD_ADDR_VAR 0 3
78468: PUSH
78469: LD_INT 0
78471: ST_TO_ADDR
// end ;
78472: LD_VAR 0 3
78476: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78477: LD_INT 0
78479: PPUSH
78480: PPUSH
78481: PPUSH
// pom := GetBase ( fac ) ;
78482: LD_ADDR_VAR 0 5
78486: PUSH
78487: LD_VAR 0 1
78491: PPUSH
78492: CALL_OW 274
78496: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78497: LD_ADDR_VAR 0 4
78501: PUSH
78502: LD_VAR 0 2
78506: PUSH
78507: LD_INT 1
78509: ARRAY
78510: PPUSH
78511: LD_VAR 0 2
78515: PUSH
78516: LD_INT 2
78518: ARRAY
78519: PPUSH
78520: LD_VAR 0 2
78524: PUSH
78525: LD_INT 3
78527: ARRAY
78528: PPUSH
78529: LD_VAR 0 2
78533: PUSH
78534: LD_INT 4
78536: ARRAY
78537: PPUSH
78538: CALL_OW 449
78542: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78543: LD_ADDR_VAR 0 3
78547: PUSH
78548: LD_VAR 0 5
78552: PPUSH
78553: LD_INT 1
78555: PPUSH
78556: CALL_OW 275
78560: PUSH
78561: LD_VAR 0 4
78565: PUSH
78566: LD_INT 1
78568: ARRAY
78569: GREATEREQUAL
78570: PUSH
78571: LD_VAR 0 5
78575: PPUSH
78576: LD_INT 2
78578: PPUSH
78579: CALL_OW 275
78583: PUSH
78584: LD_VAR 0 4
78588: PUSH
78589: LD_INT 2
78591: ARRAY
78592: GREATEREQUAL
78593: AND
78594: PUSH
78595: LD_VAR 0 5
78599: PPUSH
78600: LD_INT 3
78602: PPUSH
78603: CALL_OW 275
78607: PUSH
78608: LD_VAR 0 4
78612: PUSH
78613: LD_INT 3
78615: ARRAY
78616: GREATEREQUAL
78617: AND
78618: ST_TO_ADDR
// end ;
78619: LD_VAR 0 3
78623: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78624: LD_INT 0
78626: PPUSH
78627: PPUSH
78628: PPUSH
78629: PPUSH
// pom := GetBase ( building ) ;
78630: LD_ADDR_VAR 0 3
78634: PUSH
78635: LD_VAR 0 1
78639: PPUSH
78640: CALL_OW 274
78644: ST_TO_ADDR
// if not pom then
78645: LD_VAR 0 3
78649: NOT
78650: IFFALSE 78654
// exit ;
78652: GO 78824
// btype := GetBType ( building ) ;
78654: LD_ADDR_VAR 0 5
78658: PUSH
78659: LD_VAR 0 1
78663: PPUSH
78664: CALL_OW 266
78668: ST_TO_ADDR
// if btype = b_armoury then
78669: LD_VAR 0 5
78673: PUSH
78674: LD_INT 4
78676: EQUAL
78677: IFFALSE 78687
// btype := b_barracks ;
78679: LD_ADDR_VAR 0 5
78683: PUSH
78684: LD_INT 5
78686: ST_TO_ADDR
// if btype = b_depot then
78687: LD_VAR 0 5
78691: PUSH
78692: LD_INT 0
78694: EQUAL
78695: IFFALSE 78705
// btype := b_warehouse ;
78697: LD_ADDR_VAR 0 5
78701: PUSH
78702: LD_INT 1
78704: ST_TO_ADDR
// if btype = b_workshop then
78705: LD_VAR 0 5
78709: PUSH
78710: LD_INT 2
78712: EQUAL
78713: IFFALSE 78723
// btype := b_factory ;
78715: LD_ADDR_VAR 0 5
78719: PUSH
78720: LD_INT 3
78722: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78723: LD_ADDR_VAR 0 4
78727: PUSH
78728: LD_VAR 0 5
78732: PPUSH
78733: LD_VAR 0 1
78737: PPUSH
78738: CALL_OW 248
78742: PPUSH
78743: CALL_OW 450
78747: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78748: LD_ADDR_VAR 0 2
78752: PUSH
78753: LD_VAR 0 3
78757: PPUSH
78758: LD_INT 1
78760: PPUSH
78761: CALL_OW 275
78765: PUSH
78766: LD_VAR 0 4
78770: PUSH
78771: LD_INT 1
78773: ARRAY
78774: GREATEREQUAL
78775: PUSH
78776: LD_VAR 0 3
78780: PPUSH
78781: LD_INT 2
78783: PPUSH
78784: CALL_OW 275
78788: PUSH
78789: LD_VAR 0 4
78793: PUSH
78794: LD_INT 2
78796: ARRAY
78797: GREATEREQUAL
78798: AND
78799: PUSH
78800: LD_VAR 0 3
78804: PPUSH
78805: LD_INT 3
78807: PPUSH
78808: CALL_OW 275
78812: PUSH
78813: LD_VAR 0 4
78817: PUSH
78818: LD_INT 3
78820: ARRAY
78821: GREATEREQUAL
78822: AND
78823: ST_TO_ADDR
// end ;
78824: LD_VAR 0 2
78828: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78829: LD_INT 0
78831: PPUSH
78832: PPUSH
78833: PPUSH
// pom := GetBase ( building ) ;
78834: LD_ADDR_VAR 0 4
78838: PUSH
78839: LD_VAR 0 1
78843: PPUSH
78844: CALL_OW 274
78848: ST_TO_ADDR
// if not pom then
78849: LD_VAR 0 4
78853: NOT
78854: IFFALSE 78858
// exit ;
78856: GO 78959
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78858: LD_ADDR_VAR 0 5
78862: PUSH
78863: LD_VAR 0 2
78867: PPUSH
78868: LD_VAR 0 1
78872: PPUSH
78873: CALL_OW 248
78877: PPUSH
78878: CALL_OW 450
78882: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78883: LD_ADDR_VAR 0 3
78887: PUSH
78888: LD_VAR 0 4
78892: PPUSH
78893: LD_INT 1
78895: PPUSH
78896: CALL_OW 275
78900: PUSH
78901: LD_VAR 0 5
78905: PUSH
78906: LD_INT 1
78908: ARRAY
78909: GREATEREQUAL
78910: PUSH
78911: LD_VAR 0 4
78915: PPUSH
78916: LD_INT 2
78918: PPUSH
78919: CALL_OW 275
78923: PUSH
78924: LD_VAR 0 5
78928: PUSH
78929: LD_INT 2
78931: ARRAY
78932: GREATEREQUAL
78933: AND
78934: PUSH
78935: LD_VAR 0 4
78939: PPUSH
78940: LD_INT 3
78942: PPUSH
78943: CALL_OW 275
78947: PUSH
78948: LD_VAR 0 5
78952: PUSH
78953: LD_INT 3
78955: ARRAY
78956: GREATEREQUAL
78957: AND
78958: ST_TO_ADDR
// end ;
78959: LD_VAR 0 3
78963: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78964: LD_INT 0
78966: PPUSH
78967: PPUSH
78968: PPUSH
78969: PPUSH
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
78974: PPUSH
78975: PPUSH
// result := false ;
78976: LD_ADDR_VAR 0 6
78980: PUSH
78981: LD_INT 0
78983: ST_TO_ADDR
// if not base or not btype or not x or not y then
78984: LD_VAR 0 1
78988: NOT
78989: PUSH
78990: LD_VAR 0 2
78994: NOT
78995: OR
78996: PUSH
78997: LD_VAR 0 3
79001: NOT
79002: OR
79003: PUSH
79004: LD_VAR 0 4
79008: NOT
79009: OR
79010: IFFALSE 79014
// exit ;
79012: GO 79623
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
79014: LD_ADDR_VAR 0 12
79018: PUSH
79019: LD_VAR 0 2
79023: PPUSH
79024: LD_VAR 0 3
79028: PPUSH
79029: LD_VAR 0 4
79033: PPUSH
79034: LD_VAR 0 5
79038: PPUSH
79039: LD_VAR 0 1
79043: PUSH
79044: LD_INT 1
79046: ARRAY
79047: PPUSH
79048: CALL_OW 248
79052: PPUSH
79053: LD_INT 0
79055: PPUSH
79056: CALL 80460 0 6
79060: ST_TO_ADDR
// if not hexes then
79061: LD_VAR 0 12
79065: NOT
79066: IFFALSE 79070
// exit ;
79068: GO 79623
// for i = 1 to hexes do
79070: LD_ADDR_VAR 0 7
79074: PUSH
79075: DOUBLE
79076: LD_INT 1
79078: DEC
79079: ST_TO_ADDR
79080: LD_VAR 0 12
79084: PUSH
79085: FOR_TO
79086: IFFALSE 79621
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79088: LD_ADDR_VAR 0 11
79092: PUSH
79093: LD_VAR 0 12
79097: PUSH
79098: LD_VAR 0 7
79102: ARRAY
79103: PUSH
79104: LD_INT 1
79106: ARRAY
79107: PPUSH
79108: LD_VAR 0 12
79112: PUSH
79113: LD_VAR 0 7
79117: ARRAY
79118: PUSH
79119: LD_INT 2
79121: ARRAY
79122: PPUSH
79123: CALL_OW 428
79127: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79128: LD_VAR 0 12
79132: PUSH
79133: LD_VAR 0 7
79137: ARRAY
79138: PUSH
79139: LD_INT 1
79141: ARRAY
79142: PPUSH
79143: LD_VAR 0 12
79147: PUSH
79148: LD_VAR 0 7
79152: ARRAY
79153: PUSH
79154: LD_INT 2
79156: ARRAY
79157: PPUSH
79158: CALL_OW 351
79162: PUSH
79163: LD_VAR 0 12
79167: PUSH
79168: LD_VAR 0 7
79172: ARRAY
79173: PUSH
79174: LD_INT 1
79176: ARRAY
79177: PPUSH
79178: LD_VAR 0 12
79182: PUSH
79183: LD_VAR 0 7
79187: ARRAY
79188: PUSH
79189: LD_INT 2
79191: ARRAY
79192: PPUSH
79193: CALL_OW 488
79197: NOT
79198: OR
79199: PUSH
79200: LD_VAR 0 11
79204: PPUSH
79205: CALL_OW 247
79209: PUSH
79210: LD_INT 3
79212: EQUAL
79213: OR
79214: IFFALSE 79220
// exit ;
79216: POP
79217: POP
79218: GO 79623
// if not tmp or not tmp in base then
79220: LD_VAR 0 11
79224: NOT
79225: PUSH
79226: LD_VAR 0 11
79230: PUSH
79231: LD_VAR 0 1
79235: IN
79236: NOT
79237: OR
79238: IFFALSE 79242
// continue ;
79240: GO 79085
// result := true ;
79242: LD_ADDR_VAR 0 6
79246: PUSH
79247: LD_INT 1
79249: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79250: LD_ADDR_VAR 0 15
79254: PUSH
79255: LD_VAR 0 1
79259: PPUSH
79260: LD_INT 22
79262: PUSH
79263: LD_VAR 0 11
79267: PPUSH
79268: CALL_OW 255
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 2
79279: PUSH
79280: LD_INT 30
79282: PUSH
79283: LD_INT 0
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 30
79292: PUSH
79293: LD_INT 1
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: LIST
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PPUSH
79309: CALL_OW 72
79313: ST_TO_ADDR
// if dep then
79314: LD_VAR 0 15
79318: IFFALSE 79454
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79320: LD_ADDR_VAR 0 14
79324: PUSH
79325: LD_VAR 0 15
79329: PUSH
79330: LD_INT 1
79332: ARRAY
79333: PPUSH
79334: CALL_OW 250
79338: PPUSH
79339: LD_VAR 0 15
79343: PUSH
79344: LD_INT 1
79346: ARRAY
79347: PPUSH
79348: CALL_OW 254
79352: PPUSH
79353: LD_INT 5
79355: PPUSH
79356: CALL_OW 272
79360: PUSH
79361: LD_VAR 0 15
79365: PUSH
79366: LD_INT 1
79368: ARRAY
79369: PPUSH
79370: CALL_OW 251
79374: PPUSH
79375: LD_VAR 0 15
79379: PUSH
79380: LD_INT 1
79382: ARRAY
79383: PPUSH
79384: CALL_OW 254
79388: PPUSH
79389: LD_INT 5
79391: PPUSH
79392: CALL_OW 273
79396: PUSH
79397: EMPTY
79398: LIST
79399: LIST
79400: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79401: LD_VAR 0 14
79405: PUSH
79406: LD_INT 1
79408: ARRAY
79409: PPUSH
79410: LD_VAR 0 14
79414: PUSH
79415: LD_INT 2
79417: ARRAY
79418: PPUSH
79419: CALL_OW 488
79423: IFFALSE 79454
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79425: LD_VAR 0 11
79429: PPUSH
79430: LD_VAR 0 14
79434: PUSH
79435: LD_INT 1
79437: ARRAY
79438: PPUSH
79439: LD_VAR 0 14
79443: PUSH
79444: LD_INT 2
79446: ARRAY
79447: PPUSH
79448: CALL_OW 111
// continue ;
79452: GO 79085
// end ; end ; r := GetDir ( tmp ) ;
79454: LD_ADDR_VAR 0 13
79458: PUSH
79459: LD_VAR 0 11
79463: PPUSH
79464: CALL_OW 254
79468: ST_TO_ADDR
// if r = 5 then
79469: LD_VAR 0 13
79473: PUSH
79474: LD_INT 5
79476: EQUAL
79477: IFFALSE 79487
// r := 0 ;
79479: LD_ADDR_VAR 0 13
79483: PUSH
79484: LD_INT 0
79486: ST_TO_ADDR
// for j = r to 5 do
79487: LD_ADDR_VAR 0 8
79491: PUSH
79492: DOUBLE
79493: LD_VAR 0 13
79497: DEC
79498: ST_TO_ADDR
79499: LD_INT 5
79501: PUSH
79502: FOR_TO
79503: IFFALSE 79617
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79505: LD_ADDR_VAR 0 9
79509: PUSH
79510: LD_VAR 0 11
79514: PPUSH
79515: CALL_OW 250
79519: PPUSH
79520: LD_VAR 0 8
79524: PPUSH
79525: LD_INT 2
79527: PPUSH
79528: CALL_OW 272
79532: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79533: LD_ADDR_VAR 0 10
79537: PUSH
79538: LD_VAR 0 11
79542: PPUSH
79543: CALL_OW 251
79547: PPUSH
79548: LD_VAR 0 8
79552: PPUSH
79553: LD_INT 2
79555: PPUSH
79556: CALL_OW 273
79560: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79561: LD_VAR 0 9
79565: PPUSH
79566: LD_VAR 0 10
79570: PPUSH
79571: CALL_OW 488
79575: PUSH
79576: LD_VAR 0 9
79580: PPUSH
79581: LD_VAR 0 10
79585: PPUSH
79586: CALL_OW 428
79590: NOT
79591: AND
79592: IFFALSE 79615
// begin ComMoveXY ( tmp , _x , _y ) ;
79594: LD_VAR 0 11
79598: PPUSH
79599: LD_VAR 0 9
79603: PPUSH
79604: LD_VAR 0 10
79608: PPUSH
79609: CALL_OW 111
// break ;
79613: GO 79617
// end ; end ;
79615: GO 79502
79617: POP
79618: POP
// end ;
79619: GO 79085
79621: POP
79622: POP
// end ;
79623: LD_VAR 0 6
79627: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79628: LD_INT 0
79630: PPUSH
79631: PPUSH
79632: PPUSH
79633: PPUSH
79634: PPUSH
79635: PPUSH
79636: PPUSH
79637: PPUSH
79638: PPUSH
79639: PPUSH
// result := false ;
79640: LD_ADDR_VAR 0 6
79644: PUSH
79645: LD_INT 0
79647: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79648: LD_VAR 0 1
79652: NOT
79653: PUSH
79654: LD_VAR 0 1
79658: PPUSH
79659: CALL_OW 266
79663: PUSH
79664: LD_INT 0
79666: PUSH
79667: LD_INT 1
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: IN
79674: NOT
79675: OR
79676: PUSH
79677: LD_VAR 0 2
79681: NOT
79682: OR
79683: PUSH
79684: LD_VAR 0 5
79688: PUSH
79689: LD_INT 0
79691: PUSH
79692: LD_INT 1
79694: PUSH
79695: LD_INT 2
79697: PUSH
79698: LD_INT 3
79700: PUSH
79701: LD_INT 4
79703: PUSH
79704: LD_INT 5
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: IN
79715: NOT
79716: OR
79717: PUSH
79718: LD_VAR 0 3
79722: PPUSH
79723: LD_VAR 0 4
79727: PPUSH
79728: CALL_OW 488
79732: NOT
79733: OR
79734: IFFALSE 79738
// exit ;
79736: GO 80455
// pom := GetBase ( depot ) ;
79738: LD_ADDR_VAR 0 10
79742: PUSH
79743: LD_VAR 0 1
79747: PPUSH
79748: CALL_OW 274
79752: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79753: LD_ADDR_VAR 0 11
79757: PUSH
79758: LD_VAR 0 2
79762: PPUSH
79763: LD_VAR 0 1
79767: PPUSH
79768: CALL_OW 248
79772: PPUSH
79773: CALL_OW 450
79777: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79778: LD_VAR 0 10
79782: PPUSH
79783: LD_INT 1
79785: PPUSH
79786: CALL_OW 275
79790: PUSH
79791: LD_VAR 0 11
79795: PUSH
79796: LD_INT 1
79798: ARRAY
79799: GREATEREQUAL
79800: PUSH
79801: LD_VAR 0 10
79805: PPUSH
79806: LD_INT 2
79808: PPUSH
79809: CALL_OW 275
79813: PUSH
79814: LD_VAR 0 11
79818: PUSH
79819: LD_INT 2
79821: ARRAY
79822: GREATEREQUAL
79823: AND
79824: PUSH
79825: LD_VAR 0 10
79829: PPUSH
79830: LD_INT 3
79832: PPUSH
79833: CALL_OW 275
79837: PUSH
79838: LD_VAR 0 11
79842: PUSH
79843: LD_INT 3
79845: ARRAY
79846: GREATEREQUAL
79847: AND
79848: NOT
79849: IFFALSE 79853
// exit ;
79851: GO 80455
// if GetBType ( depot ) = b_depot then
79853: LD_VAR 0 1
79857: PPUSH
79858: CALL_OW 266
79862: PUSH
79863: LD_INT 0
79865: EQUAL
79866: IFFALSE 79878
// dist := 28 else
79868: LD_ADDR_VAR 0 14
79872: PUSH
79873: LD_INT 28
79875: ST_TO_ADDR
79876: GO 79886
// dist := 36 ;
79878: LD_ADDR_VAR 0 14
79882: PUSH
79883: LD_INT 36
79885: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79886: LD_VAR 0 1
79890: PPUSH
79891: LD_VAR 0 3
79895: PPUSH
79896: LD_VAR 0 4
79900: PPUSH
79901: CALL_OW 297
79905: PUSH
79906: LD_VAR 0 14
79910: GREATER
79911: IFFALSE 79915
// exit ;
79913: GO 80455
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79915: LD_ADDR_VAR 0 12
79919: PUSH
79920: LD_VAR 0 2
79924: PPUSH
79925: LD_VAR 0 3
79929: PPUSH
79930: LD_VAR 0 4
79934: PPUSH
79935: LD_VAR 0 5
79939: PPUSH
79940: LD_VAR 0 1
79944: PPUSH
79945: CALL_OW 248
79949: PPUSH
79950: LD_INT 0
79952: PPUSH
79953: CALL 80460 0 6
79957: ST_TO_ADDR
// if not hexes then
79958: LD_VAR 0 12
79962: NOT
79963: IFFALSE 79967
// exit ;
79965: GO 80455
// hex := GetHexInfo ( x , y ) ;
79967: LD_ADDR_VAR 0 15
79971: PUSH
79972: LD_VAR 0 3
79976: PPUSH
79977: LD_VAR 0 4
79981: PPUSH
79982: CALL_OW 546
79986: ST_TO_ADDR
// if hex [ 1 ] then
79987: LD_VAR 0 15
79991: PUSH
79992: LD_INT 1
79994: ARRAY
79995: IFFALSE 79999
// exit ;
79997: GO 80455
// height := hex [ 2 ] ;
79999: LD_ADDR_VAR 0 13
80003: PUSH
80004: LD_VAR 0 15
80008: PUSH
80009: LD_INT 2
80011: ARRAY
80012: ST_TO_ADDR
// for i = 1 to hexes do
80013: LD_ADDR_VAR 0 7
80017: PUSH
80018: DOUBLE
80019: LD_INT 1
80021: DEC
80022: ST_TO_ADDR
80023: LD_VAR 0 12
80027: PUSH
80028: FOR_TO
80029: IFFALSE 80359
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80031: LD_VAR 0 12
80035: PUSH
80036: LD_VAR 0 7
80040: ARRAY
80041: PUSH
80042: LD_INT 1
80044: ARRAY
80045: PPUSH
80046: LD_VAR 0 12
80050: PUSH
80051: LD_VAR 0 7
80055: ARRAY
80056: PUSH
80057: LD_INT 2
80059: ARRAY
80060: PPUSH
80061: CALL_OW 488
80065: NOT
80066: PUSH
80067: LD_VAR 0 12
80071: PUSH
80072: LD_VAR 0 7
80076: ARRAY
80077: PUSH
80078: LD_INT 1
80080: ARRAY
80081: PPUSH
80082: LD_VAR 0 12
80086: PUSH
80087: LD_VAR 0 7
80091: ARRAY
80092: PUSH
80093: LD_INT 2
80095: ARRAY
80096: PPUSH
80097: CALL_OW 428
80101: PUSH
80102: LD_INT 0
80104: GREATER
80105: OR
80106: PUSH
80107: LD_VAR 0 12
80111: PUSH
80112: LD_VAR 0 7
80116: ARRAY
80117: PUSH
80118: LD_INT 1
80120: ARRAY
80121: PPUSH
80122: LD_VAR 0 12
80126: PUSH
80127: LD_VAR 0 7
80131: ARRAY
80132: PUSH
80133: LD_INT 2
80135: ARRAY
80136: PPUSH
80137: CALL_OW 351
80141: OR
80142: IFFALSE 80148
// exit ;
80144: POP
80145: POP
80146: GO 80455
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80148: LD_ADDR_VAR 0 8
80152: PUSH
80153: LD_VAR 0 12
80157: PUSH
80158: LD_VAR 0 7
80162: ARRAY
80163: PUSH
80164: LD_INT 1
80166: ARRAY
80167: PPUSH
80168: LD_VAR 0 12
80172: PUSH
80173: LD_VAR 0 7
80177: ARRAY
80178: PUSH
80179: LD_INT 2
80181: ARRAY
80182: PPUSH
80183: CALL_OW 546
80187: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
80188: LD_VAR 0 8
80192: PUSH
80193: LD_INT 1
80195: ARRAY
80196: PUSH
80197: LD_VAR 0 8
80201: PUSH
80202: LD_INT 2
80204: ARRAY
80205: PUSH
80206: LD_VAR 0 13
80210: PUSH
80211: LD_INT 2
80213: PLUS
80214: GREATER
80215: OR
80216: PUSH
80217: LD_VAR 0 8
80221: PUSH
80222: LD_INT 2
80224: ARRAY
80225: PUSH
80226: LD_VAR 0 13
80230: PUSH
80231: LD_INT 2
80233: MINUS
80234: LESS
80235: OR
80236: PUSH
80237: LD_VAR 0 8
80241: PUSH
80242: LD_INT 3
80244: ARRAY
80245: PUSH
80246: LD_INT 0
80248: PUSH
80249: LD_INT 8
80251: PUSH
80252: LD_INT 9
80254: PUSH
80255: LD_INT 10
80257: PUSH
80258: LD_INT 11
80260: PUSH
80261: LD_INT 12
80263: PUSH
80264: LD_INT 13
80266: PUSH
80267: LD_INT 16
80269: PUSH
80270: LD_INT 17
80272: PUSH
80273: LD_INT 18
80275: PUSH
80276: LD_INT 19
80278: PUSH
80279: LD_INT 20
80281: PUSH
80282: LD_INT 21
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: IN
80300: NOT
80301: OR
80302: PUSH
80303: LD_VAR 0 8
80307: PUSH
80308: LD_INT 5
80310: ARRAY
80311: NOT
80312: OR
80313: PUSH
80314: LD_VAR 0 8
80318: PUSH
80319: LD_INT 6
80321: ARRAY
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: LD_INT 7
80331: PUSH
80332: LD_INT 9
80334: PUSH
80335: LD_INT 10
80337: PUSH
80338: LD_INT 11
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: IN
80349: NOT
80350: OR
80351: IFFALSE 80357
// exit ;
80353: POP
80354: POP
80355: GO 80455
// end ;
80357: GO 80028
80359: POP
80360: POP
// side := GetSide ( depot ) ;
80361: LD_ADDR_VAR 0 9
80365: PUSH
80366: LD_VAR 0 1
80370: PPUSH
80371: CALL_OW 255
80375: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80376: LD_VAR 0 9
80380: PPUSH
80381: LD_VAR 0 3
80385: PPUSH
80386: LD_VAR 0 4
80390: PPUSH
80391: LD_INT 20
80393: PPUSH
80394: CALL 73109 0 4
80398: PUSH
80399: LD_INT 4
80401: ARRAY
80402: IFFALSE 80406
// exit ;
80404: GO 80455
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80406: LD_VAR 0 2
80410: PUSH
80411: LD_INT 29
80413: PUSH
80414: LD_INT 30
80416: PUSH
80417: EMPTY
80418: LIST
80419: LIST
80420: IN
80421: PUSH
80422: LD_VAR 0 3
80426: PPUSH
80427: LD_VAR 0 4
80431: PPUSH
80432: LD_VAR 0 9
80436: PPUSH
80437: CALL_OW 440
80441: NOT
80442: AND
80443: IFFALSE 80447
// exit ;
80445: GO 80455
// result := true ;
80447: LD_ADDR_VAR 0 6
80451: PUSH
80452: LD_INT 1
80454: ST_TO_ADDR
// end ;
80455: LD_VAR 0 6
80459: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80460: LD_INT 0
80462: PPUSH
80463: PPUSH
80464: PPUSH
80465: PPUSH
80466: PPUSH
80467: PPUSH
80468: PPUSH
80469: PPUSH
80470: PPUSH
80471: PPUSH
80472: PPUSH
80473: PPUSH
80474: PPUSH
80475: PPUSH
80476: PPUSH
80477: PPUSH
80478: PPUSH
80479: PPUSH
80480: PPUSH
80481: PPUSH
80482: PPUSH
80483: PPUSH
80484: PPUSH
80485: PPUSH
80486: PPUSH
80487: PPUSH
80488: PPUSH
80489: PPUSH
80490: PPUSH
80491: PPUSH
80492: PPUSH
80493: PPUSH
80494: PPUSH
80495: PPUSH
80496: PPUSH
80497: PPUSH
80498: PPUSH
80499: PPUSH
80500: PPUSH
80501: PPUSH
80502: PPUSH
80503: PPUSH
80504: PPUSH
80505: PPUSH
80506: PPUSH
80507: PPUSH
80508: PPUSH
80509: PPUSH
80510: PPUSH
80511: PPUSH
80512: PPUSH
80513: PPUSH
80514: PPUSH
80515: PPUSH
80516: PPUSH
80517: PPUSH
80518: PPUSH
80519: PPUSH
// result = [ ] ;
80520: LD_ADDR_VAR 0 7
80524: PUSH
80525: EMPTY
80526: ST_TO_ADDR
// temp_list = [ ] ;
80527: LD_ADDR_VAR 0 9
80531: PUSH
80532: EMPTY
80533: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80534: LD_VAR 0 4
80538: PUSH
80539: LD_INT 0
80541: PUSH
80542: LD_INT 1
80544: PUSH
80545: LD_INT 2
80547: PUSH
80548: LD_INT 3
80550: PUSH
80551: LD_INT 4
80553: PUSH
80554: LD_INT 5
80556: PUSH
80557: EMPTY
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: IN
80565: NOT
80566: PUSH
80567: LD_VAR 0 1
80571: PUSH
80572: LD_INT 0
80574: PUSH
80575: LD_INT 1
80577: PUSH
80578: EMPTY
80579: LIST
80580: LIST
80581: IN
80582: PUSH
80583: LD_VAR 0 5
80587: PUSH
80588: LD_INT 1
80590: PUSH
80591: LD_INT 2
80593: PUSH
80594: LD_INT 3
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: LIST
80601: IN
80602: NOT
80603: AND
80604: OR
80605: IFFALSE 80609
// exit ;
80607: GO 99000
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80609: LD_VAR 0 1
80613: PUSH
80614: LD_INT 6
80616: PUSH
80617: LD_INT 7
80619: PUSH
80620: LD_INT 8
80622: PUSH
80623: LD_INT 13
80625: PUSH
80626: LD_INT 12
80628: PUSH
80629: LD_INT 15
80631: PUSH
80632: LD_INT 11
80634: PUSH
80635: LD_INT 14
80637: PUSH
80638: LD_INT 10
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: IN
80652: IFFALSE 80662
// btype = b_lab ;
80654: LD_ADDR_VAR 0 1
80658: PUSH
80659: LD_INT 6
80661: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80662: LD_VAR 0 6
80666: PUSH
80667: LD_INT 0
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 2
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: LIST
80680: IN
80681: NOT
80682: PUSH
80683: LD_VAR 0 1
80687: PUSH
80688: LD_INT 0
80690: PUSH
80691: LD_INT 1
80693: PUSH
80694: LD_INT 2
80696: PUSH
80697: LD_INT 3
80699: PUSH
80700: LD_INT 6
80702: PUSH
80703: LD_INT 36
80705: PUSH
80706: LD_INT 4
80708: PUSH
80709: LD_INT 5
80711: PUSH
80712: LD_INT 31
80714: PUSH
80715: LD_INT 32
80717: PUSH
80718: LD_INT 33
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: IN
80734: NOT
80735: PUSH
80736: LD_VAR 0 6
80740: PUSH
80741: LD_INT 1
80743: EQUAL
80744: AND
80745: OR
80746: PUSH
80747: LD_VAR 0 1
80751: PUSH
80752: LD_INT 2
80754: PUSH
80755: LD_INT 3
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: IN
80762: NOT
80763: PUSH
80764: LD_VAR 0 6
80768: PUSH
80769: LD_INT 2
80771: EQUAL
80772: AND
80773: OR
80774: IFFALSE 80784
// mode = 0 ;
80776: LD_ADDR_VAR 0 6
80780: PUSH
80781: LD_INT 0
80783: ST_TO_ADDR
// case mode of 0 :
80784: LD_VAR 0 6
80788: PUSH
80789: LD_INT 0
80791: DOUBLE
80792: EQUAL
80793: IFTRUE 80797
80795: GO 92250
80797: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80798: LD_ADDR_VAR 0 11
80802: PUSH
80803: LD_INT 0
80805: PUSH
80806: LD_INT 0
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 0
80815: PUSH
80816: LD_INT 1
80818: NEG
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 1
80826: PUSH
80827: LD_INT 0
80829: PUSH
80830: EMPTY
80831: LIST
80832: LIST
80833: PUSH
80834: LD_INT 1
80836: PUSH
80837: LD_INT 1
80839: PUSH
80840: EMPTY
80841: LIST
80842: LIST
80843: PUSH
80844: LD_INT 0
80846: PUSH
80847: LD_INT 1
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: LD_INT 0
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: NEG
80868: PUSH
80869: LD_INT 1
80871: NEG
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: LD_INT 2
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 0
80891: PUSH
80892: LD_INT 2
80894: NEG
80895: PUSH
80896: EMPTY
80897: LIST
80898: LIST
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: LD_INT 1
80905: NEG
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: LD_INT 1
80913: PUSH
80914: LD_INT 2
80916: PUSH
80917: EMPTY
80918: LIST
80919: LIST
80920: PUSH
80921: LD_INT 0
80923: PUSH
80924: LD_INT 2
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 1
80933: NEG
80934: PUSH
80935: LD_INT 1
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: LD_INT 3
80947: PUSH
80948: EMPTY
80949: LIST
80950: LIST
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: LD_INT 3
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PUSH
80962: LD_INT 1
80964: NEG
80965: PUSH
80966: LD_INT 2
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80991: LD_ADDR_VAR 0 12
80995: PUSH
80996: LD_INT 0
80998: PUSH
80999: LD_INT 0
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 0
81008: PUSH
81009: LD_INT 1
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 1
81019: PUSH
81020: LD_INT 0
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: LD_INT 1
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 0
81039: PUSH
81040: LD_INT 1
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 1
81049: NEG
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: NEG
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 1
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 2
81083: PUSH
81084: LD_INT 0
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 2
81093: PUSH
81094: LD_INT 1
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 1
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: NEG
81115: PUSH
81116: LD_INT 0
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 2
81125: NEG
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: LD_INT 1
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: NEG
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 3
81159: NEG
81160: PUSH
81161: LD_INT 1
81163: NEG
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81187: LD_ADDR_VAR 0 13
81191: PUSH
81192: LD_INT 0
81194: PUSH
81195: LD_INT 0
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: LD_INT 1
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 1
81215: PUSH
81216: LD_INT 0
81218: PUSH
81219: EMPTY
81220: LIST
81221: LIST
81222: PUSH
81223: LD_INT 1
81225: PUSH
81226: LD_INT 1
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: LD_INT 1
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 1
81245: NEG
81246: PUSH
81247: LD_INT 0
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 1
81256: NEG
81257: PUSH
81258: LD_INT 1
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 1
81268: NEG
81269: PUSH
81270: LD_INT 2
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 2
81280: PUSH
81281: LD_INT 1
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 2
81290: PUSH
81291: LD_INT 2
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 1
81300: PUSH
81301: LD_INT 2
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 2
81310: NEG
81311: PUSH
81312: LD_INT 1
81314: NEG
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 2
81322: NEG
81323: PUSH
81324: LD_INT 2
81326: NEG
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 2
81334: NEG
81335: PUSH
81336: LD_INT 3
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 3
81346: NEG
81347: PUSH
81348: LD_INT 2
81350: NEG
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 3
81358: NEG
81359: PUSH
81360: LD_INT 3
81362: NEG
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81386: LD_ADDR_VAR 0 14
81390: PUSH
81391: LD_INT 0
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 0
81403: PUSH
81404: LD_INT 1
81406: NEG
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 1
81414: PUSH
81415: LD_INT 0
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PUSH
81422: LD_INT 1
81424: PUSH
81425: LD_INT 1
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: LD_INT 1
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 1
81444: NEG
81445: PUSH
81446: LD_INT 0
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 1
81455: NEG
81456: PUSH
81457: LD_INT 1
81459: NEG
81460: PUSH
81461: EMPTY
81462: LIST
81463: LIST
81464: PUSH
81465: LD_INT 1
81467: NEG
81468: PUSH
81469: LD_INT 2
81471: NEG
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 0
81479: PUSH
81480: LD_INT 2
81482: NEG
81483: PUSH
81484: EMPTY
81485: LIST
81486: LIST
81487: PUSH
81488: LD_INT 1
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: EMPTY
81496: LIST
81497: LIST
81498: PUSH
81499: LD_INT 1
81501: PUSH
81502: LD_INT 2
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PUSH
81509: LD_INT 0
81511: PUSH
81512: LD_INT 2
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: LD_INT 1
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 1
81532: NEG
81533: PUSH
81534: LD_INT 3
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 0
81544: PUSH
81545: LD_INT 3
81547: NEG
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: LD_INT 2
81558: NEG
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81582: LD_ADDR_VAR 0 15
81586: PUSH
81587: LD_INT 0
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 0
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: LD_INT 0
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 1
81620: PUSH
81621: LD_INT 1
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: LD_INT 0
81630: PUSH
81631: LD_INT 1
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 1
81640: NEG
81641: PUSH
81642: LD_INT 0
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 1
81651: NEG
81652: PUSH
81653: LD_INT 1
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 1
81663: PUSH
81664: LD_INT 1
81666: NEG
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 2
81674: PUSH
81675: LD_INT 0
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 2
81684: PUSH
81685: LD_INT 1
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 1
81694: NEG
81695: PUSH
81696: LD_INT 1
81698: PUSH
81699: EMPTY
81700: LIST
81701: LIST
81702: PUSH
81703: LD_INT 2
81705: NEG
81706: PUSH
81707: LD_INT 0
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 2
81716: NEG
81717: PUSH
81718: LD_INT 1
81720: NEG
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PUSH
81726: LD_INT 2
81728: PUSH
81729: LD_INT 1
81731: NEG
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 3
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 3
81749: PUSH
81750: LD_INT 1
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: LIST
81761: LIST
81762: LIST
81763: LIST
81764: LIST
81765: LIST
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81775: LD_ADDR_VAR 0 16
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: LD_INT 0
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 0
81792: PUSH
81793: LD_INT 1
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 1
81803: PUSH
81804: LD_INT 0
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 1
81813: PUSH
81814: LD_INT 1
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: PUSH
81821: LD_INT 0
81823: PUSH
81824: LD_INT 1
81826: PUSH
81827: EMPTY
81828: LIST
81829: LIST
81830: PUSH
81831: LD_INT 1
81833: NEG
81834: PUSH
81835: LD_INT 0
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 1
81844: NEG
81845: PUSH
81846: LD_INT 1
81848: NEG
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 1
81856: NEG
81857: PUSH
81858: LD_INT 2
81860: NEG
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 2
81868: PUSH
81869: LD_INT 1
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: PUSH
81876: LD_INT 2
81878: PUSH
81879: LD_INT 2
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 1
81888: PUSH
81889: LD_INT 2
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 2
81898: NEG
81899: PUSH
81900: LD_INT 1
81902: NEG
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 2
81910: NEG
81911: PUSH
81912: LD_INT 2
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 3
81922: PUSH
81923: LD_INT 2
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 3
81932: PUSH
81933: LD_INT 3
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: LD_INT 3
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: EMPTY
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: LIST
81960: LIST
81961: LIST
81962: LIST
81963: LIST
81964: LIST
81965: LIST
81966: LIST
81967: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81968: LD_ADDR_VAR 0 17
81972: PUSH
81973: LD_INT 0
81975: PUSH
81976: LD_INT 0
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 0
81985: PUSH
81986: LD_INT 1
81988: NEG
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: PUSH
81994: LD_INT 1
81996: PUSH
81997: LD_INT 0
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 1
82006: PUSH
82007: LD_INT 1
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 0
82016: PUSH
82017: LD_INT 1
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 1
82026: NEG
82027: PUSH
82028: LD_INT 0
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PUSH
82035: LD_INT 1
82037: NEG
82038: PUSH
82039: LD_INT 1
82041: NEG
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: LD_INT 2
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 0
82061: PUSH
82062: LD_INT 2
82064: NEG
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 1
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 2
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 2
82093: PUSH
82094: LD_INT 1
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 2
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 1
82113: PUSH
82114: LD_INT 2
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 0
82123: PUSH
82124: LD_INT 2
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: LD_INT 0
82148: PUSH
82149: EMPTY
82150: LIST
82151: LIST
82152: PUSH
82153: LD_INT 2
82155: NEG
82156: PUSH
82157: LD_INT 1
82159: NEG
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 2
82167: NEG
82168: PUSH
82169: LD_INT 2
82171: NEG
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82198: LD_ADDR_VAR 0 18
82202: PUSH
82203: LD_INT 0
82205: PUSH
82206: LD_INT 0
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: PUSH
82213: LD_INT 0
82215: PUSH
82216: LD_INT 1
82218: NEG
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PUSH
82224: LD_INT 1
82226: PUSH
82227: LD_INT 0
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 1
82236: PUSH
82237: LD_INT 1
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 0
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 1
82256: NEG
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 1
82267: NEG
82268: PUSH
82269: LD_INT 1
82271: NEG
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 2
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 0
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 1
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 2
82323: PUSH
82324: LD_INT 1
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: EMPTY
82338: LIST
82339: LIST
82340: PUSH
82341: LD_INT 1
82343: PUSH
82344: LD_INT 2
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 0
82353: PUSH
82354: LD_INT 2
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 1
82363: NEG
82364: PUSH
82365: LD_INT 1
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 2
82374: NEG
82375: PUSH
82376: LD_INT 0
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: LD_INT 2
82385: NEG
82386: PUSH
82387: LD_INT 1
82389: NEG
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 2
82397: NEG
82398: PUSH
82399: LD_INT 2
82401: NEG
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82428: LD_ADDR_VAR 0 19
82432: PUSH
82433: LD_INT 0
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 0
82445: PUSH
82446: LD_INT 1
82448: NEG
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: EMPTY
82461: LIST
82462: LIST
82463: PUSH
82464: LD_INT 1
82466: PUSH
82467: LD_INT 1
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 0
82476: PUSH
82477: LD_INT 1
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 1
82486: NEG
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 1
82497: NEG
82498: PUSH
82499: LD_INT 1
82501: NEG
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 2
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 0
82521: PUSH
82522: LD_INT 2
82524: NEG
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: LD_INT 1
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 2
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 2
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: LD_INT 2
82563: PUSH
82564: LD_INT 2
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 1
82573: PUSH
82574: LD_INT 2
82576: PUSH
82577: EMPTY
82578: LIST
82579: LIST
82580: PUSH
82581: LD_INT 0
82583: PUSH
82584: LD_INT 2
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 1
82593: NEG
82594: PUSH
82595: LD_INT 1
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PUSH
82602: LD_INT 2
82604: NEG
82605: PUSH
82606: LD_INT 0
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: NEG
82616: PUSH
82617: LD_INT 1
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 2
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: EMPTY
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82658: LD_ADDR_VAR 0 20
82662: PUSH
82663: LD_INT 0
82665: PUSH
82666: LD_INT 0
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 0
82675: PUSH
82676: LD_INT 1
82678: NEG
82679: PUSH
82680: EMPTY
82681: LIST
82682: LIST
82683: PUSH
82684: LD_INT 1
82686: PUSH
82687: LD_INT 0
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 1
82696: PUSH
82697: LD_INT 1
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 0
82706: PUSH
82707: LD_INT 1
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: NEG
82717: PUSH
82718: LD_INT 0
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: NEG
82728: PUSH
82729: LD_INT 1
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 1
82739: NEG
82740: PUSH
82741: LD_INT 2
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 0
82751: PUSH
82752: LD_INT 2
82754: NEG
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 1
82762: PUSH
82763: LD_INT 1
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 2
82783: PUSH
82784: LD_INT 1
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: PUSH
82791: LD_INT 2
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 1
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 0
82813: PUSH
82814: LD_INT 2
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: PUSH
82832: LD_INT 2
82834: NEG
82835: PUSH
82836: LD_INT 0
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 2
82845: NEG
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 2
82857: NEG
82858: PUSH
82859: LD_INT 2
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82888: LD_ADDR_VAR 0 21
82892: PUSH
82893: LD_INT 0
82895: PUSH
82896: LD_INT 0
82898: PUSH
82899: EMPTY
82900: LIST
82901: LIST
82902: PUSH
82903: LD_INT 0
82905: PUSH
82906: LD_INT 1
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 1
82916: PUSH
82917: LD_INT 0
82919: PUSH
82920: EMPTY
82921: LIST
82922: LIST
82923: PUSH
82924: LD_INT 1
82926: PUSH
82927: LD_INT 1
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 0
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: EMPTY
82941: LIST
82942: LIST
82943: PUSH
82944: LD_INT 1
82946: NEG
82947: PUSH
82948: LD_INT 0
82950: PUSH
82951: EMPTY
82952: LIST
82953: LIST
82954: PUSH
82955: LD_INT 1
82957: NEG
82958: PUSH
82959: LD_INT 1
82961: NEG
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 2
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 0
82981: PUSH
82982: LD_INT 2
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 1
82992: PUSH
82993: LD_INT 1
82995: NEG
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PUSH
83001: LD_INT 2
83003: PUSH
83004: LD_INT 0
83006: PUSH
83007: EMPTY
83008: LIST
83009: LIST
83010: PUSH
83011: LD_INT 2
83013: PUSH
83014: LD_INT 1
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 2
83023: PUSH
83024: LD_INT 2
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 1
83033: PUSH
83034: LD_INT 2
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 0
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 1
83053: NEG
83054: PUSH
83055: LD_INT 1
83057: PUSH
83058: EMPTY
83059: LIST
83060: LIST
83061: PUSH
83062: LD_INT 2
83064: NEG
83065: PUSH
83066: LD_INT 0
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 2
83075: NEG
83076: PUSH
83077: LD_INT 1
83079: NEG
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 2
83087: NEG
83088: PUSH
83089: LD_INT 2
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83118: LD_ADDR_VAR 0 22
83122: PUSH
83123: LD_INT 0
83125: PUSH
83126: LD_INT 0
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 1
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: EMPTY
83151: LIST
83152: LIST
83153: PUSH
83154: LD_INT 1
83156: PUSH
83157: LD_INT 1
83159: PUSH
83160: EMPTY
83161: LIST
83162: LIST
83163: PUSH
83164: LD_INT 0
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: NEG
83177: PUSH
83178: LD_INT 0
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: LD_INT 1
83187: NEG
83188: PUSH
83189: LD_INT 1
83191: NEG
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 1
83199: NEG
83200: PUSH
83201: LD_INT 2
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 0
83211: PUSH
83212: LD_INT 2
83214: NEG
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 1
83222: PUSH
83223: LD_INT 1
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 2
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 2
83243: PUSH
83244: LD_INT 1
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 2
83253: PUSH
83254: LD_INT 2
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 1
83263: PUSH
83264: LD_INT 2
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: LD_INT 2
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 1
83283: NEG
83284: PUSH
83285: LD_INT 1
83287: PUSH
83288: EMPTY
83289: LIST
83290: LIST
83291: PUSH
83292: LD_INT 2
83294: NEG
83295: PUSH
83296: LD_INT 0
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PUSH
83303: LD_INT 2
83305: NEG
83306: PUSH
83307: LD_INT 1
83309: NEG
83310: PUSH
83311: EMPTY
83312: LIST
83313: LIST
83314: PUSH
83315: LD_INT 2
83317: NEG
83318: PUSH
83319: LD_INT 2
83321: NEG
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83348: LD_ADDR_VAR 0 23
83352: PUSH
83353: LD_INT 0
83355: PUSH
83356: LD_INT 0
83358: PUSH
83359: EMPTY
83360: LIST
83361: LIST
83362: PUSH
83363: LD_INT 0
83365: PUSH
83366: LD_INT 1
83368: NEG
83369: PUSH
83370: EMPTY
83371: LIST
83372: LIST
83373: PUSH
83374: LD_INT 1
83376: PUSH
83377: LD_INT 0
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 1
83386: PUSH
83387: LD_INT 1
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: PUSH
83394: LD_INT 0
83396: PUSH
83397: LD_INT 1
83399: PUSH
83400: EMPTY
83401: LIST
83402: LIST
83403: PUSH
83404: LD_INT 1
83406: NEG
83407: PUSH
83408: LD_INT 0
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 1
83417: NEG
83418: PUSH
83419: LD_INT 1
83421: NEG
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: NEG
83430: PUSH
83431: LD_INT 2
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 0
83441: PUSH
83442: LD_INT 2
83444: NEG
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: PUSH
83453: LD_INT 1
83455: NEG
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 2
83463: PUSH
83464: LD_INT 0
83466: PUSH
83467: EMPTY
83468: LIST
83469: LIST
83470: PUSH
83471: LD_INT 2
83473: PUSH
83474: LD_INT 1
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 2
83483: PUSH
83484: LD_INT 2
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 1
83493: PUSH
83494: LD_INT 2
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 0
83503: PUSH
83504: LD_INT 2
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 1
83513: NEG
83514: PUSH
83515: LD_INT 1
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 2
83524: NEG
83525: PUSH
83526: LD_INT 0
83528: PUSH
83529: EMPTY
83530: LIST
83531: LIST
83532: PUSH
83533: LD_INT 2
83535: NEG
83536: PUSH
83537: LD_INT 1
83539: NEG
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 2
83547: NEG
83548: PUSH
83549: LD_INT 2
83551: NEG
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 2
83559: NEG
83560: PUSH
83561: LD_INT 3
83563: NEG
83564: PUSH
83565: EMPTY
83566: LIST
83567: LIST
83568: PUSH
83569: LD_INT 1
83571: NEG
83572: PUSH
83573: LD_INT 3
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: LD_INT 1
83583: PUSH
83584: LD_INT 2
83586: NEG
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 2
83594: PUSH
83595: LD_INT 1
83597: NEG
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83628: LD_ADDR_VAR 0 24
83632: PUSH
83633: LD_INT 0
83635: PUSH
83636: LD_INT 0
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 0
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 1
83656: PUSH
83657: LD_INT 0
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 1
83666: PUSH
83667: LD_INT 1
83669: PUSH
83670: EMPTY
83671: LIST
83672: LIST
83673: PUSH
83674: LD_INT 0
83676: PUSH
83677: LD_INT 1
83679: PUSH
83680: EMPTY
83681: LIST
83682: LIST
83683: PUSH
83684: LD_INT 1
83686: NEG
83687: PUSH
83688: LD_INT 0
83690: PUSH
83691: EMPTY
83692: LIST
83693: LIST
83694: PUSH
83695: LD_INT 1
83697: NEG
83698: PUSH
83699: LD_INT 1
83701: NEG
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: LD_INT 2
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 0
83721: PUSH
83722: LD_INT 2
83724: NEG
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 1
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: PUSH
83744: LD_INT 0
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PUSH
83751: LD_INT 2
83753: PUSH
83754: LD_INT 1
83756: PUSH
83757: EMPTY
83758: LIST
83759: LIST
83760: PUSH
83761: LD_INT 2
83763: PUSH
83764: LD_INT 2
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 1
83773: PUSH
83774: LD_INT 2
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: LD_INT 2
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: LD_INT 1
83793: NEG
83794: PUSH
83795: LD_INT 1
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 2
83804: NEG
83805: PUSH
83806: LD_INT 0
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 2
83815: NEG
83816: PUSH
83817: LD_INT 1
83819: NEG
83820: PUSH
83821: EMPTY
83822: LIST
83823: LIST
83824: PUSH
83825: LD_INT 2
83827: NEG
83828: PUSH
83829: LD_INT 2
83831: NEG
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: LD_INT 2
83842: NEG
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 2
83850: PUSH
83851: LD_INT 1
83853: NEG
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 3
83861: PUSH
83862: LD_INT 1
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 3
83871: PUSH
83872: LD_INT 2
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: LIST
83883: LIST
83884: LIST
83885: LIST
83886: LIST
83887: LIST
83888: LIST
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: LIST
83895: LIST
83896: LIST
83897: LIST
83898: LIST
83899: LIST
83900: LIST
83901: LIST
83902: LIST
83903: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83904: LD_ADDR_VAR 0 25
83908: PUSH
83909: LD_INT 0
83911: PUSH
83912: LD_INT 0
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PUSH
83919: LD_INT 0
83921: PUSH
83922: LD_INT 1
83924: NEG
83925: PUSH
83926: EMPTY
83927: LIST
83928: LIST
83929: PUSH
83930: LD_INT 1
83932: PUSH
83933: LD_INT 0
83935: PUSH
83936: EMPTY
83937: LIST
83938: LIST
83939: PUSH
83940: LD_INT 1
83942: PUSH
83943: LD_INT 1
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 0
83952: PUSH
83953: LD_INT 1
83955: PUSH
83956: EMPTY
83957: LIST
83958: LIST
83959: PUSH
83960: LD_INT 1
83962: NEG
83963: PUSH
83964: LD_INT 0
83966: PUSH
83967: EMPTY
83968: LIST
83969: LIST
83970: PUSH
83971: LD_INT 1
83973: NEG
83974: PUSH
83975: LD_INT 1
83977: NEG
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 2
83989: NEG
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: LD_INT 2
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: PUSH
84020: LD_INT 0
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 2
84029: PUSH
84030: LD_INT 1
84032: PUSH
84033: EMPTY
84034: LIST
84035: LIST
84036: PUSH
84037: LD_INT 2
84039: PUSH
84040: LD_INT 2
84042: PUSH
84043: EMPTY
84044: LIST
84045: LIST
84046: PUSH
84047: LD_INT 1
84049: PUSH
84050: LD_INT 2
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: PUSH
84057: LD_INT 0
84059: PUSH
84060: LD_INT 2
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 1
84069: NEG
84070: PUSH
84071: LD_INT 1
84073: PUSH
84074: EMPTY
84075: LIST
84076: LIST
84077: PUSH
84078: LD_INT 2
84080: NEG
84081: PUSH
84082: LD_INT 0
84084: PUSH
84085: EMPTY
84086: LIST
84087: LIST
84088: PUSH
84089: LD_INT 2
84091: NEG
84092: PUSH
84093: LD_INT 1
84095: NEG
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 2
84103: NEG
84104: PUSH
84105: LD_INT 2
84107: NEG
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: LD_INT 3
84115: PUSH
84116: LD_INT 1
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: LD_INT 3
84125: PUSH
84126: LD_INT 2
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 2
84135: PUSH
84136: LD_INT 3
84138: PUSH
84139: EMPTY
84140: LIST
84141: LIST
84142: PUSH
84143: LD_INT 1
84145: PUSH
84146: LD_INT 3
84148: PUSH
84149: EMPTY
84150: LIST
84151: LIST
84152: PUSH
84153: EMPTY
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: LIST
84173: LIST
84174: LIST
84175: LIST
84176: LIST
84177: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84178: LD_ADDR_VAR 0 26
84182: PUSH
84183: LD_INT 0
84185: PUSH
84186: LD_INT 0
84188: PUSH
84189: EMPTY
84190: LIST
84191: LIST
84192: PUSH
84193: LD_INT 0
84195: PUSH
84196: LD_INT 1
84198: NEG
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: PUSH
84204: LD_INT 1
84206: PUSH
84207: LD_INT 0
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 1
84216: PUSH
84217: LD_INT 1
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 0
84226: PUSH
84227: LD_INT 1
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: LD_INT 1
84236: NEG
84237: PUSH
84238: LD_INT 0
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 1
84247: NEG
84248: PUSH
84249: LD_INT 1
84251: NEG
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 1
84259: NEG
84260: PUSH
84261: LD_INT 2
84263: NEG
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 0
84271: PUSH
84272: LD_INT 2
84274: NEG
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: PUSH
84280: LD_INT 1
84282: PUSH
84283: LD_INT 1
84285: NEG
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 2
84293: PUSH
84294: LD_INT 0
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 2
84303: PUSH
84304: LD_INT 1
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PUSH
84311: LD_INT 2
84313: PUSH
84314: LD_INT 2
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: PUSH
84324: LD_INT 2
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: PUSH
84331: LD_INT 0
84333: PUSH
84334: LD_INT 2
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 1
84343: NEG
84344: PUSH
84345: LD_INT 1
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 2
84354: NEG
84355: PUSH
84356: LD_INT 0
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 2
84365: NEG
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 2
84377: NEG
84378: PUSH
84379: LD_INT 2
84381: NEG
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 2
84389: PUSH
84390: LD_INT 3
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 1
84399: PUSH
84400: LD_INT 3
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: LD_INT 1
84409: NEG
84410: PUSH
84411: LD_INT 2
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 2
84420: NEG
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84454: LD_ADDR_VAR 0 27
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: LD_INT 0
84464: PUSH
84465: EMPTY
84466: LIST
84467: LIST
84468: PUSH
84469: LD_INT 0
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: PUSH
84483: LD_INT 0
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 1
84492: PUSH
84493: LD_INT 1
84495: PUSH
84496: EMPTY
84497: LIST
84498: LIST
84499: PUSH
84500: LD_INT 0
84502: PUSH
84503: LD_INT 1
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: PUSH
84510: LD_INT 1
84512: NEG
84513: PUSH
84514: LD_INT 0
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 1
84523: NEG
84524: PUSH
84525: LD_INT 1
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 1
84535: NEG
84536: PUSH
84537: LD_INT 2
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 0
84547: PUSH
84548: LD_INT 2
84550: NEG
84551: PUSH
84552: EMPTY
84553: LIST
84554: LIST
84555: PUSH
84556: LD_INT 1
84558: PUSH
84559: LD_INT 1
84561: NEG
84562: PUSH
84563: EMPTY
84564: LIST
84565: LIST
84566: PUSH
84567: LD_INT 2
84569: PUSH
84570: LD_INT 0
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: PUSH
84577: LD_INT 2
84579: PUSH
84580: LD_INT 1
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 2
84589: PUSH
84590: LD_INT 2
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: LD_INT 1
84599: PUSH
84600: LD_INT 2
84602: PUSH
84603: EMPTY
84604: LIST
84605: LIST
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: LD_INT 2
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 1
84619: NEG
84620: PUSH
84621: LD_INT 1
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 2
84641: NEG
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 2
84653: NEG
84654: PUSH
84655: LD_INT 2
84657: NEG
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 1
84665: NEG
84666: PUSH
84667: LD_INT 2
84669: PUSH
84670: EMPTY
84671: LIST
84672: LIST
84673: PUSH
84674: LD_INT 2
84676: NEG
84677: PUSH
84678: LD_INT 1
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 3
84687: NEG
84688: PUSH
84689: LD_INT 1
84691: NEG
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 3
84699: NEG
84700: PUSH
84701: LD_INT 2
84703: NEG
84704: PUSH
84705: EMPTY
84706: LIST
84707: LIST
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: LIST
84713: LIST
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84734: LD_ADDR_VAR 0 28
84738: PUSH
84739: LD_INT 0
84741: PUSH
84742: LD_INT 0
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PUSH
84749: LD_INT 0
84751: PUSH
84752: LD_INT 1
84754: NEG
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: PUSH
84760: LD_INT 1
84762: PUSH
84763: LD_INT 0
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: PUSH
84770: LD_INT 1
84772: PUSH
84773: LD_INT 1
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: PUSH
84780: LD_INT 0
84782: PUSH
84783: LD_INT 1
84785: PUSH
84786: EMPTY
84787: LIST
84788: LIST
84789: PUSH
84790: LD_INT 1
84792: NEG
84793: PUSH
84794: LD_INT 0
84796: PUSH
84797: EMPTY
84798: LIST
84799: LIST
84800: PUSH
84801: LD_INT 1
84803: NEG
84804: PUSH
84805: LD_INT 1
84807: NEG
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 1
84815: NEG
84816: PUSH
84817: LD_INT 2
84819: NEG
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: LD_INT 2
84830: NEG
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 1
84838: PUSH
84839: LD_INT 1
84841: NEG
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 2
84849: PUSH
84850: LD_INT 0
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 2
84859: PUSH
84860: LD_INT 1
84862: PUSH
84863: EMPTY
84864: LIST
84865: LIST
84866: PUSH
84867: LD_INT 2
84869: PUSH
84870: LD_INT 2
84872: PUSH
84873: EMPTY
84874: LIST
84875: LIST
84876: PUSH
84877: LD_INT 1
84879: PUSH
84880: LD_INT 2
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 0
84889: PUSH
84890: LD_INT 2
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 1
84899: NEG
84900: PUSH
84901: LD_INT 1
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 2
84910: NEG
84911: PUSH
84912: LD_INT 0
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 2
84921: NEG
84922: PUSH
84923: LD_INT 1
84925: NEG
84926: PUSH
84927: EMPTY
84928: LIST
84929: LIST
84930: PUSH
84931: LD_INT 2
84933: NEG
84934: PUSH
84935: LD_INT 2
84937: NEG
84938: PUSH
84939: EMPTY
84940: LIST
84941: LIST
84942: PUSH
84943: LD_INT 2
84945: NEG
84946: PUSH
84947: LD_INT 3
84949: NEG
84950: PUSH
84951: EMPTY
84952: LIST
84953: LIST
84954: PUSH
84955: LD_INT 1
84957: NEG
84958: PUSH
84959: LD_INT 3
84961: NEG
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: LD_INT 3
84969: NEG
84970: PUSH
84971: LD_INT 1
84973: NEG
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: PUSH
84979: LD_INT 3
84981: NEG
84982: PUSH
84983: LD_INT 2
84985: NEG
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85016: LD_ADDR_VAR 0 29
85020: PUSH
85021: LD_INT 0
85023: PUSH
85024: LD_INT 0
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 0
85033: PUSH
85034: LD_INT 1
85036: NEG
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 1
85044: PUSH
85045: LD_INT 0
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PUSH
85052: LD_INT 1
85054: PUSH
85055: LD_INT 1
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: LD_INT 1
85067: PUSH
85068: EMPTY
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 1
85074: NEG
85075: PUSH
85076: LD_INT 0
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: LD_INT 1
85089: NEG
85090: PUSH
85091: EMPTY
85092: LIST
85093: LIST
85094: PUSH
85095: LD_INT 1
85097: NEG
85098: PUSH
85099: LD_INT 2
85101: NEG
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 0
85109: PUSH
85110: LD_INT 2
85112: NEG
85113: PUSH
85114: EMPTY
85115: LIST
85116: LIST
85117: PUSH
85118: LD_INT 1
85120: PUSH
85121: LD_INT 1
85123: NEG
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 2
85131: PUSH
85132: LD_INT 0
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 2
85141: PUSH
85142: LD_INT 1
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 1
85151: PUSH
85152: LD_INT 2
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 0
85161: PUSH
85162: LD_INT 2
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: NEG
85172: PUSH
85173: LD_INT 1
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 2
85182: NEG
85183: PUSH
85184: LD_INT 1
85186: NEG
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 2
85194: NEG
85195: PUSH
85196: LD_INT 2
85198: NEG
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 2
85206: NEG
85207: PUSH
85208: LD_INT 3
85210: NEG
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 2
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 3
85229: PUSH
85230: LD_INT 1
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 1
85239: PUSH
85240: LD_INT 3
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 1
85249: NEG
85250: PUSH
85251: LD_INT 2
85253: PUSH
85254: EMPTY
85255: LIST
85256: LIST
85257: PUSH
85258: LD_INT 3
85260: NEG
85261: PUSH
85262: LD_INT 2
85264: NEG
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PUSH
85270: EMPTY
85271: LIST
85272: LIST
85273: LIST
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85295: LD_ADDR_VAR 0 30
85299: PUSH
85300: LD_INT 0
85302: PUSH
85303: LD_INT 0
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 0
85312: PUSH
85313: LD_INT 1
85315: NEG
85316: PUSH
85317: EMPTY
85318: LIST
85319: LIST
85320: PUSH
85321: LD_INT 1
85323: PUSH
85324: LD_INT 0
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: PUSH
85334: LD_INT 1
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 0
85343: PUSH
85344: LD_INT 1
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PUSH
85351: LD_INT 1
85353: NEG
85354: PUSH
85355: LD_INT 0
85357: PUSH
85358: EMPTY
85359: LIST
85360: LIST
85361: PUSH
85362: LD_INT 1
85364: NEG
85365: PUSH
85366: LD_INT 1
85368: NEG
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: PUSH
85374: LD_INT 1
85376: NEG
85377: PUSH
85378: LD_INT 2
85380: NEG
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 0
85388: PUSH
85389: LD_INT 2
85391: NEG
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: PUSH
85397: LD_INT 1
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: EMPTY
85405: LIST
85406: LIST
85407: PUSH
85408: LD_INT 2
85410: PUSH
85411: LD_INT 0
85413: PUSH
85414: EMPTY
85415: LIST
85416: LIST
85417: PUSH
85418: LD_INT 2
85420: PUSH
85421: LD_INT 1
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: PUSH
85428: LD_INT 2
85430: PUSH
85431: LD_INT 2
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: PUSH
85438: LD_INT 1
85440: PUSH
85441: LD_INT 2
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 1
85450: NEG
85451: PUSH
85452: LD_INT 1
85454: PUSH
85455: EMPTY
85456: LIST
85457: LIST
85458: PUSH
85459: LD_INT 2
85461: NEG
85462: PUSH
85463: LD_INT 0
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 2
85472: NEG
85473: PUSH
85474: LD_INT 1
85476: NEG
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: NEG
85485: PUSH
85486: LD_INT 3
85488: NEG
85489: PUSH
85490: EMPTY
85491: LIST
85492: LIST
85493: PUSH
85494: LD_INT 1
85496: PUSH
85497: LD_INT 2
85499: NEG
85500: PUSH
85501: EMPTY
85502: LIST
85503: LIST
85504: PUSH
85505: LD_INT 3
85507: PUSH
85508: LD_INT 2
85510: PUSH
85511: EMPTY
85512: LIST
85513: LIST
85514: PUSH
85515: LD_INT 2
85517: PUSH
85518: LD_INT 3
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 2
85527: NEG
85528: PUSH
85529: LD_INT 1
85531: PUSH
85532: EMPTY
85533: LIST
85534: LIST
85535: PUSH
85536: LD_INT 3
85538: NEG
85539: PUSH
85540: LD_INT 1
85542: NEG
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85573: LD_ADDR_VAR 0 31
85577: PUSH
85578: LD_INT 0
85580: PUSH
85581: LD_INT 0
85583: PUSH
85584: EMPTY
85585: LIST
85586: LIST
85587: PUSH
85588: LD_INT 0
85590: PUSH
85591: LD_INT 1
85593: NEG
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 1
85601: PUSH
85602: LD_INT 0
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: LD_INT 1
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 0
85621: PUSH
85622: LD_INT 1
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: NEG
85632: PUSH
85633: LD_INT 0
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 1
85642: NEG
85643: PUSH
85644: LD_INT 1
85646: NEG
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 1
85654: NEG
85655: PUSH
85656: LD_INT 2
85658: NEG
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 1
85666: PUSH
85667: LD_INT 1
85669: NEG
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PUSH
85675: LD_INT 2
85677: PUSH
85678: LD_INT 0
85680: PUSH
85681: EMPTY
85682: LIST
85683: LIST
85684: PUSH
85685: LD_INT 2
85687: PUSH
85688: LD_INT 1
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 2
85697: PUSH
85698: LD_INT 2
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: PUSH
85705: LD_INT 1
85707: PUSH
85708: LD_INT 2
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 0
85717: PUSH
85718: LD_INT 2
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 1
85727: NEG
85728: PUSH
85729: LD_INT 1
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: PUSH
85736: LD_INT 2
85738: NEG
85739: PUSH
85740: LD_INT 1
85742: NEG
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 2
85750: NEG
85751: PUSH
85752: LD_INT 2
85754: NEG
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 2
85762: NEG
85763: PUSH
85764: LD_INT 3
85766: NEG
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: LD_INT 1
85777: NEG
85778: PUSH
85779: EMPTY
85780: LIST
85781: LIST
85782: PUSH
85783: LD_INT 3
85785: PUSH
85786: LD_INT 1
85788: PUSH
85789: EMPTY
85790: LIST
85791: LIST
85792: PUSH
85793: LD_INT 1
85795: PUSH
85796: LD_INT 3
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 1
85805: NEG
85806: PUSH
85807: LD_INT 2
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 3
85816: NEG
85817: PUSH
85818: LD_INT 2
85820: NEG
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: LIST
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85851: LD_ADDR_VAR 0 32
85855: PUSH
85856: LD_INT 0
85858: PUSH
85859: LD_INT 0
85861: PUSH
85862: EMPTY
85863: LIST
85864: LIST
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: LD_INT 1
85871: NEG
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 1
85879: PUSH
85880: LD_INT 0
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: LD_INT 1
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 0
85899: PUSH
85900: LD_INT 1
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: NEG
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 1
85920: NEG
85921: PUSH
85922: LD_INT 1
85924: NEG
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 1
85932: NEG
85933: PUSH
85934: LD_INT 2
85936: NEG
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 0
85944: PUSH
85945: LD_INT 2
85947: NEG
85948: PUSH
85949: EMPTY
85950: LIST
85951: LIST
85952: PUSH
85953: LD_INT 1
85955: PUSH
85956: LD_INT 1
85958: NEG
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 2
85966: PUSH
85967: LD_INT 1
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 2
85976: PUSH
85977: LD_INT 2
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: LD_INT 2
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 0
85996: PUSH
85997: LD_INT 2
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 1
86006: NEG
86007: PUSH
86008: LD_INT 1
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 2
86017: NEG
86018: PUSH
86019: LD_INT 0
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: PUSH
86026: LD_INT 2
86028: NEG
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 1
86040: NEG
86041: PUSH
86042: LD_INT 3
86044: NEG
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 1
86052: PUSH
86053: LD_INT 2
86055: NEG
86056: PUSH
86057: EMPTY
86058: LIST
86059: LIST
86060: PUSH
86061: LD_INT 3
86063: PUSH
86064: LD_INT 2
86066: PUSH
86067: EMPTY
86068: LIST
86069: LIST
86070: PUSH
86071: LD_INT 2
86073: PUSH
86074: LD_INT 3
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: PUSH
86081: LD_INT 2
86083: NEG
86084: PUSH
86085: LD_INT 1
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 3
86094: NEG
86095: PUSH
86096: LD_INT 1
86098: NEG
86099: PUSH
86100: EMPTY
86101: LIST
86102: LIST
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: LIST
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: LIST
86116: LIST
86117: LIST
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86129: LD_ADDR_VAR 0 33
86133: PUSH
86134: LD_INT 0
86136: PUSH
86137: LD_INT 0
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 0
86146: PUSH
86147: LD_INT 1
86149: NEG
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: LD_INT 1
86157: PUSH
86158: LD_INT 0
86160: PUSH
86161: EMPTY
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: LD_INT 1
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PUSH
86175: LD_INT 0
86177: PUSH
86178: LD_INT 1
86180: PUSH
86181: EMPTY
86182: LIST
86183: LIST
86184: PUSH
86185: LD_INT 1
86187: NEG
86188: PUSH
86189: LD_INT 0
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PUSH
86196: LD_INT 1
86198: NEG
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 1
86210: NEG
86211: PUSH
86212: LD_INT 2
86214: NEG
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: LD_INT 1
86222: PUSH
86223: LD_INT 1
86225: NEG
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 2
86233: PUSH
86234: LD_INT 0
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: LD_INT 2
86243: PUSH
86244: LD_INT 1
86246: PUSH
86247: EMPTY
86248: LIST
86249: LIST
86250: PUSH
86251: LD_INT 1
86253: PUSH
86254: LD_INT 2
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: LD_INT 2
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 1
86273: NEG
86274: PUSH
86275: LD_INT 1
86277: PUSH
86278: EMPTY
86279: LIST
86280: LIST
86281: PUSH
86282: LD_INT 2
86284: NEG
86285: PUSH
86286: LD_INT 0
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 2
86295: NEG
86296: PUSH
86297: LD_INT 1
86299: NEG
86300: PUSH
86301: EMPTY
86302: LIST
86303: LIST
86304: PUSH
86305: LD_INT 2
86307: NEG
86308: PUSH
86309: LD_INT 2
86311: NEG
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 2
86319: NEG
86320: PUSH
86321: LD_INT 3
86323: NEG
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: EMPTY
86337: LIST
86338: LIST
86339: PUSH
86340: LD_INT 3
86342: PUSH
86343: LD_INT 1
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: LD_INT 3
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: LD_INT 2
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 3
86373: NEG
86374: PUSH
86375: LD_INT 2
86377: NEG
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: LIST
86390: LIST
86391: LIST
86392: LIST
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86408: LD_ADDR_VAR 0 34
86412: PUSH
86413: LD_INT 0
86415: PUSH
86416: LD_INT 0
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 0
86425: PUSH
86426: LD_INT 1
86428: NEG
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: PUSH
86434: LD_INT 1
86436: PUSH
86437: LD_INT 0
86439: PUSH
86440: EMPTY
86441: LIST
86442: LIST
86443: PUSH
86444: LD_INT 1
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 1
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: PUSH
86464: LD_INT 1
86466: NEG
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 1
86477: NEG
86478: PUSH
86479: LD_INT 1
86481: NEG
86482: PUSH
86483: EMPTY
86484: LIST
86485: LIST
86486: PUSH
86487: LD_INT 1
86489: NEG
86490: PUSH
86491: LD_INT 2
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 0
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: LD_INT 1
86512: PUSH
86513: LD_INT 1
86515: NEG
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 2
86523: PUSH
86524: LD_INT 1
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 2
86533: PUSH
86534: LD_INT 2
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: LD_INT 2
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 1
86553: NEG
86554: PUSH
86555: LD_INT 1
86557: PUSH
86558: EMPTY
86559: LIST
86560: LIST
86561: PUSH
86562: LD_INT 2
86564: NEG
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 2
86575: NEG
86576: PUSH
86577: LD_INT 1
86579: NEG
86580: PUSH
86581: EMPTY
86582: LIST
86583: LIST
86584: PUSH
86585: LD_INT 2
86587: NEG
86588: PUSH
86589: LD_INT 2
86591: NEG
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 1
86599: NEG
86600: PUSH
86601: LD_INT 3
86603: NEG
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PUSH
86609: LD_INT 1
86611: PUSH
86612: LD_INT 2
86614: NEG
86615: PUSH
86616: EMPTY
86617: LIST
86618: LIST
86619: PUSH
86620: LD_INT 3
86622: PUSH
86623: LD_INT 2
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: PUSH
86630: LD_INT 2
86632: PUSH
86633: LD_INT 3
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 2
86642: NEG
86643: PUSH
86644: LD_INT 1
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 3
86653: NEG
86654: PUSH
86655: LD_INT 1
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86688: LD_ADDR_VAR 0 35
86692: PUSH
86693: LD_INT 0
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 0
86705: PUSH
86706: LD_INT 1
86708: NEG
86709: PUSH
86710: EMPTY
86711: LIST
86712: LIST
86713: PUSH
86714: LD_INT 1
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 1
86726: PUSH
86727: LD_INT 1
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: LD_INT 1
86739: PUSH
86740: EMPTY
86741: LIST
86742: LIST
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: LD_INT 0
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 1
86757: NEG
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 2
86769: PUSH
86770: LD_INT 1
86772: PUSH
86773: EMPTY
86774: LIST
86775: LIST
86776: PUSH
86777: LD_INT 2
86779: NEG
86780: PUSH
86781: LD_INT 1
86783: NEG
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86800: LD_ADDR_VAR 0 36
86804: PUSH
86805: LD_INT 0
86807: PUSH
86808: LD_INT 0
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 0
86817: PUSH
86818: LD_INT 1
86820: NEG
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 1
86828: PUSH
86829: LD_INT 0
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 1
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 0
86848: PUSH
86849: LD_INT 1
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PUSH
86856: LD_INT 1
86858: NEG
86859: PUSH
86860: LD_INT 0
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: NEG
86870: PUSH
86871: LD_INT 1
86873: NEG
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 1
86881: NEG
86882: PUSH
86883: LD_INT 2
86885: NEG
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 1
86893: PUSH
86894: LD_INT 2
86896: PUSH
86897: EMPTY
86898: LIST
86899: LIST
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: LIST
86909: LIST
86910: LIST
86911: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86912: LD_ADDR_VAR 0 37
86916: PUSH
86917: LD_INT 0
86919: PUSH
86920: LD_INT 0
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 0
86929: PUSH
86930: LD_INT 1
86932: NEG
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 1
86940: PUSH
86941: LD_INT 0
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 1
86950: PUSH
86951: LD_INT 1
86953: PUSH
86954: EMPTY
86955: LIST
86956: LIST
86957: PUSH
86958: LD_INT 0
86960: PUSH
86961: LD_INT 1
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: PUSH
86972: LD_INT 0
86974: PUSH
86975: EMPTY
86976: LIST
86977: LIST
86978: PUSH
86979: LD_INT 1
86981: NEG
86982: PUSH
86983: LD_INT 1
86985: NEG
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: LD_INT 1
86996: NEG
86997: PUSH
86998: EMPTY
86999: LIST
87000: LIST
87001: PUSH
87002: LD_INT 1
87004: NEG
87005: PUSH
87006: LD_INT 1
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87024: LD_ADDR_VAR 0 38
87028: PUSH
87029: LD_INT 0
87031: PUSH
87032: LD_INT 0
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: LD_INT 0
87041: PUSH
87042: LD_INT 1
87044: NEG
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: LD_INT 0
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 1
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: LD_INT 0
87072: PUSH
87073: LD_INT 1
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: PUSH
87080: LD_INT 1
87082: NEG
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 1
87093: NEG
87094: PUSH
87095: LD_INT 1
87097: NEG
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 2
87105: PUSH
87106: LD_INT 1
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 2
87115: NEG
87116: PUSH
87117: LD_INT 1
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87136: LD_ADDR_VAR 0 39
87140: PUSH
87141: LD_INT 0
87143: PUSH
87144: LD_INT 0
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: LD_INT 0
87153: PUSH
87154: LD_INT 1
87156: NEG
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: PUSH
87165: LD_INT 0
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 1
87174: PUSH
87175: LD_INT 1
87177: PUSH
87178: EMPTY
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 0
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: EMPTY
87189: LIST
87190: LIST
87191: PUSH
87192: LD_INT 1
87194: NEG
87195: PUSH
87196: LD_INT 0
87198: PUSH
87199: EMPTY
87200: LIST
87201: LIST
87202: PUSH
87203: LD_INT 1
87205: NEG
87206: PUSH
87207: LD_INT 1
87209: NEG
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 1
87217: NEG
87218: PUSH
87219: LD_INT 2
87221: NEG
87222: PUSH
87223: EMPTY
87224: LIST
87225: LIST
87226: PUSH
87227: LD_INT 1
87229: PUSH
87230: LD_INT 2
87232: PUSH
87233: EMPTY
87234: LIST
87235: LIST
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: LIST
87241: LIST
87242: LIST
87243: LIST
87244: LIST
87245: LIST
87246: LIST
87247: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87248: LD_ADDR_VAR 0 40
87252: PUSH
87253: LD_INT 0
87255: PUSH
87256: LD_INT 0
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: PUSH
87263: LD_INT 0
87265: PUSH
87266: LD_INT 1
87268: NEG
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 1
87276: PUSH
87277: LD_INT 0
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PUSH
87284: LD_INT 1
87286: PUSH
87287: LD_INT 1
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: PUSH
87294: LD_INT 0
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 0
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PUSH
87315: LD_INT 1
87317: NEG
87318: PUSH
87319: LD_INT 1
87321: NEG
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: LD_INT 1
87329: PUSH
87330: LD_INT 1
87332: NEG
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: PUSH
87338: LD_INT 1
87340: NEG
87341: PUSH
87342: LD_INT 1
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87360: LD_ADDR_VAR 0 41
87364: PUSH
87365: LD_INT 0
87367: PUSH
87368: LD_INT 0
87370: PUSH
87371: EMPTY
87372: LIST
87373: LIST
87374: PUSH
87375: LD_INT 0
87377: PUSH
87378: LD_INT 1
87380: NEG
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: LD_INT 0
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: LD_INT 1
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 0
87408: PUSH
87409: LD_INT 1
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 1
87418: NEG
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: EMPTY
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 1
87429: NEG
87430: PUSH
87431: LD_INT 1
87433: NEG
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: PUSH
87443: LD_INT 2
87445: NEG
87446: PUSH
87447: EMPTY
87448: LIST
87449: LIST
87450: PUSH
87451: LD_INT 1
87453: PUSH
87454: LD_INT 1
87456: NEG
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 2
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 2
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 2
87484: PUSH
87485: LD_INT 2
87487: PUSH
87488: EMPTY
87489: LIST
87490: LIST
87491: PUSH
87492: LD_INT 1
87494: PUSH
87495: LD_INT 2
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 1
87504: NEG
87505: PUSH
87506: LD_INT 1
87508: PUSH
87509: EMPTY
87510: LIST
87511: LIST
87512: PUSH
87513: LD_INT 2
87515: NEG
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 2
87526: NEG
87527: PUSH
87528: LD_INT 1
87530: NEG
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 2
87538: NEG
87539: PUSH
87540: LD_INT 2
87542: NEG
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 2
87550: NEG
87551: PUSH
87552: LD_INT 3
87554: NEG
87555: PUSH
87556: EMPTY
87557: LIST
87558: LIST
87559: PUSH
87560: LD_INT 2
87562: PUSH
87563: LD_INT 1
87565: NEG
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 3
87573: PUSH
87574: LD_INT 0
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 3
87583: PUSH
87584: LD_INT 1
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: LD_INT 3
87593: PUSH
87594: LD_INT 2
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 3
87603: PUSH
87604: LD_INT 3
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: LD_INT 2
87613: PUSH
87614: LD_INT 3
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 2
87623: NEG
87624: PUSH
87625: LD_INT 1
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PUSH
87632: LD_INT 3
87634: NEG
87635: PUSH
87636: LD_INT 0
87638: PUSH
87639: EMPTY
87640: LIST
87641: LIST
87642: PUSH
87643: LD_INT 3
87645: NEG
87646: PUSH
87647: LD_INT 1
87649: NEG
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 3
87657: NEG
87658: PUSH
87659: LD_INT 2
87661: NEG
87662: PUSH
87663: EMPTY
87664: LIST
87665: LIST
87666: PUSH
87667: LD_INT 3
87669: NEG
87670: PUSH
87671: LD_INT 3
87673: NEG
87674: PUSH
87675: EMPTY
87676: LIST
87677: LIST
87678: PUSH
87679: EMPTY
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: LIST
87689: LIST
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: LIST
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87710: LD_ADDR_VAR 0 42
87714: PUSH
87715: LD_INT 0
87717: PUSH
87718: LD_INT 0
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 0
87727: PUSH
87728: LD_INT 1
87730: NEG
87731: PUSH
87732: EMPTY
87733: LIST
87734: LIST
87735: PUSH
87736: LD_INT 1
87738: PUSH
87739: LD_INT 0
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 1
87748: PUSH
87749: LD_INT 1
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 0
87758: PUSH
87759: LD_INT 1
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: PUSH
87766: LD_INT 1
87768: NEG
87769: PUSH
87770: LD_INT 0
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 1
87779: NEG
87780: PUSH
87781: LD_INT 1
87783: NEG
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 1
87791: NEG
87792: PUSH
87793: LD_INT 2
87795: NEG
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 0
87803: PUSH
87804: LD_INT 2
87806: NEG
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 1
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 2
87825: PUSH
87826: LD_INT 1
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 2
87835: PUSH
87836: LD_INT 2
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 1
87845: PUSH
87846: LD_INT 2
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 0
87855: PUSH
87856: LD_INT 2
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: PUSH
87863: LD_INT 1
87865: NEG
87866: PUSH
87867: LD_INT 1
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 2
87876: NEG
87877: PUSH
87878: LD_INT 1
87880: NEG
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: NEG
87889: PUSH
87890: LD_INT 2
87892: NEG
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: LD_INT 2
87900: NEG
87901: PUSH
87902: LD_INT 3
87904: NEG
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: NEG
87913: PUSH
87914: LD_INT 3
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 0
87924: PUSH
87925: LD_INT 3
87927: NEG
87928: PUSH
87929: EMPTY
87930: LIST
87931: LIST
87932: PUSH
87933: LD_INT 1
87935: PUSH
87936: LD_INT 2
87938: NEG
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 3
87946: PUSH
87947: LD_INT 2
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 3
87956: PUSH
87957: LD_INT 3
87959: PUSH
87960: EMPTY
87961: LIST
87962: LIST
87963: PUSH
87964: LD_INT 2
87966: PUSH
87967: LD_INT 3
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 1
87976: PUSH
87977: LD_INT 3
87979: PUSH
87980: EMPTY
87981: LIST
87982: LIST
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: LD_INT 3
87989: PUSH
87990: EMPTY
87991: LIST
87992: LIST
87993: PUSH
87994: LD_INT 1
87996: NEG
87997: PUSH
87998: LD_INT 2
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 3
88007: NEG
88008: PUSH
88009: LD_INT 2
88011: NEG
88012: PUSH
88013: EMPTY
88014: LIST
88015: LIST
88016: PUSH
88017: LD_INT 3
88019: NEG
88020: PUSH
88021: LD_INT 3
88023: NEG
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88060: LD_ADDR_VAR 0 43
88064: PUSH
88065: LD_INT 0
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: PUSH
88075: LD_INT 0
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: LD_INT 1
88088: PUSH
88089: LD_INT 0
88091: PUSH
88092: EMPTY
88093: LIST
88094: LIST
88095: PUSH
88096: LD_INT 1
88098: PUSH
88099: LD_INT 1
88101: PUSH
88102: EMPTY
88103: LIST
88104: LIST
88105: PUSH
88106: LD_INT 0
88108: PUSH
88109: LD_INT 1
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 1
88118: NEG
88119: PUSH
88120: LD_INT 0
88122: PUSH
88123: EMPTY
88124: LIST
88125: LIST
88126: PUSH
88127: LD_INT 1
88129: NEG
88130: PUSH
88131: LD_INT 1
88133: NEG
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 1
88141: NEG
88142: PUSH
88143: LD_INT 2
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 0
88153: PUSH
88154: LD_INT 2
88156: NEG
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 1
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 2
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 2
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 1
88195: PUSH
88196: LD_INT 2
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 0
88205: PUSH
88206: LD_INT 2
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 1
88215: NEG
88216: PUSH
88217: LD_INT 1
88219: PUSH
88220: EMPTY
88221: LIST
88222: LIST
88223: PUSH
88224: LD_INT 2
88226: NEG
88227: PUSH
88228: LD_INT 0
88230: PUSH
88231: EMPTY
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 2
88237: NEG
88238: PUSH
88239: LD_INT 1
88241: NEG
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 1
88249: NEG
88250: PUSH
88251: LD_INT 3
88253: NEG
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 0
88261: PUSH
88262: LD_INT 3
88264: NEG
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 1
88272: PUSH
88273: LD_INT 2
88275: NEG
88276: PUSH
88277: EMPTY
88278: LIST
88279: LIST
88280: PUSH
88281: LD_INT 2
88283: PUSH
88284: LD_INT 1
88286: NEG
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 3
88294: PUSH
88295: LD_INT 0
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 3
88304: PUSH
88305: LD_INT 1
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 1
88314: PUSH
88315: LD_INT 3
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: LD_INT 0
88324: PUSH
88325: LD_INT 3
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 1
88334: NEG
88335: PUSH
88336: LD_INT 2
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 2
88345: NEG
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: EMPTY
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 3
88356: NEG
88357: PUSH
88358: LD_INT 0
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: PUSH
88365: LD_INT 3
88367: NEG
88368: PUSH
88369: LD_INT 1
88371: NEG
88372: PUSH
88373: EMPTY
88374: LIST
88375: LIST
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: LIST
88386: LIST
88387: LIST
88388: LIST
88389: LIST
88390: LIST
88391: LIST
88392: LIST
88393: LIST
88394: LIST
88395: LIST
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88408: LD_ADDR_VAR 0 44
88412: PUSH
88413: LD_INT 0
88415: PUSH
88416: LD_INT 0
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 0
88425: PUSH
88426: LD_INT 1
88428: NEG
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: LD_INT 0
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: PUSH
88444: LD_INT 1
88446: PUSH
88447: LD_INT 1
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 0
88456: PUSH
88457: LD_INT 1
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PUSH
88464: LD_INT 1
88466: NEG
88467: PUSH
88468: LD_INT 0
88470: PUSH
88471: EMPTY
88472: LIST
88473: LIST
88474: PUSH
88475: LD_INT 1
88477: NEG
88478: PUSH
88479: LD_INT 1
88481: NEG
88482: PUSH
88483: EMPTY
88484: LIST
88485: LIST
88486: PUSH
88487: LD_INT 1
88489: NEG
88490: PUSH
88491: LD_INT 2
88493: NEG
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 1
88501: PUSH
88502: LD_INT 1
88504: NEG
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 2
88512: PUSH
88513: LD_INT 0
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 2
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 2
88532: PUSH
88533: LD_INT 2
88535: PUSH
88536: EMPTY
88537: LIST
88538: LIST
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: LD_INT 2
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 1
88552: NEG
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: PUSH
88561: LD_INT 2
88563: NEG
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: EMPTY
88569: LIST
88570: LIST
88571: PUSH
88572: LD_INT 2
88574: NEG
88575: PUSH
88576: LD_INT 1
88578: NEG
88579: PUSH
88580: EMPTY
88581: LIST
88582: LIST
88583: PUSH
88584: LD_INT 2
88586: NEG
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 2
88598: NEG
88599: PUSH
88600: LD_INT 3
88602: NEG
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PUSH
88608: LD_INT 2
88610: PUSH
88611: LD_INT 1
88613: NEG
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 3
88621: PUSH
88622: LD_INT 0
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 3
88631: PUSH
88632: LD_INT 1
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 3
88641: PUSH
88642: LD_INT 2
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 3
88651: PUSH
88652: LD_INT 3
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 2
88661: PUSH
88662: LD_INT 3
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 2
88671: NEG
88672: PUSH
88673: LD_INT 1
88675: PUSH
88676: EMPTY
88677: LIST
88678: LIST
88679: PUSH
88680: LD_INT 3
88682: NEG
88683: PUSH
88684: LD_INT 0
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: LD_INT 3
88693: NEG
88694: PUSH
88695: LD_INT 1
88697: NEG
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: PUSH
88703: LD_INT 3
88705: NEG
88706: PUSH
88707: LD_INT 2
88709: NEG
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 3
88717: NEG
88718: PUSH
88719: LD_INT 3
88721: NEG
88722: PUSH
88723: EMPTY
88724: LIST
88725: LIST
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88758: LD_ADDR_VAR 0 45
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: LD_INT 0
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 0
88775: PUSH
88776: LD_INT 1
88778: NEG
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: EMPTY
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 1
88796: PUSH
88797: LD_INT 1
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PUSH
88804: LD_INT 0
88806: PUSH
88807: LD_INT 1
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 1
88816: NEG
88817: PUSH
88818: LD_INT 0
88820: PUSH
88821: EMPTY
88822: LIST
88823: LIST
88824: PUSH
88825: LD_INT 1
88827: NEG
88828: PUSH
88829: LD_INT 1
88831: NEG
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 1
88839: NEG
88840: PUSH
88841: LD_INT 2
88843: NEG
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: LD_INT 2
88854: NEG
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: LD_INT 1
88865: NEG
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 2
88873: PUSH
88874: LD_INT 1
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 2
88883: PUSH
88884: LD_INT 2
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 1
88893: PUSH
88894: LD_INT 2
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 0
88903: PUSH
88904: LD_INT 2
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 1
88913: NEG
88914: PUSH
88915: LD_INT 1
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 2
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 2
88948: NEG
88949: PUSH
88950: LD_INT 3
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 1
88960: NEG
88961: PUSH
88962: LD_INT 3
88964: NEG
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 0
88972: PUSH
88973: LD_INT 3
88975: NEG
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 1
88983: PUSH
88984: LD_INT 2
88986: NEG
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: PUSH
88992: LD_INT 3
88994: PUSH
88995: LD_INT 2
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PUSH
89002: LD_INT 3
89004: PUSH
89005: LD_INT 3
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: LD_INT 2
89014: PUSH
89015: LD_INT 3
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: LD_INT 3
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 0
89034: PUSH
89035: LD_INT 3
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 1
89044: NEG
89045: PUSH
89046: LD_INT 2
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 3
89055: NEG
89056: PUSH
89057: LD_INT 2
89059: NEG
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: PUSH
89065: LD_INT 3
89067: NEG
89068: PUSH
89069: LD_INT 3
89071: NEG
89072: PUSH
89073: EMPTY
89074: LIST
89075: LIST
89076: PUSH
89077: EMPTY
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: LIST
89092: LIST
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89108: LD_ADDR_VAR 0 46
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: LD_INT 0
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 0
89125: PUSH
89126: LD_INT 1
89128: NEG
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 1
89136: PUSH
89137: LD_INT 0
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 1
89146: PUSH
89147: LD_INT 1
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: LD_INT 1
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: LD_INT 0
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 1
89177: NEG
89178: PUSH
89179: LD_INT 1
89181: NEG
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: NEG
89190: PUSH
89191: LD_INT 2
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 0
89201: PUSH
89202: LD_INT 2
89204: NEG
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 1
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 2
89223: PUSH
89224: LD_INT 0
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 2
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 1
89243: PUSH
89244: LD_INT 2
89246: PUSH
89247: EMPTY
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 0
89253: PUSH
89254: LD_INT 2
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 1
89263: NEG
89264: PUSH
89265: LD_INT 1
89267: PUSH
89268: EMPTY
89269: LIST
89270: LIST
89271: PUSH
89272: LD_INT 2
89274: NEG
89275: PUSH
89276: LD_INT 0
89278: PUSH
89279: EMPTY
89280: LIST
89281: LIST
89282: PUSH
89283: LD_INT 2
89285: NEG
89286: PUSH
89287: LD_INT 1
89289: NEG
89290: PUSH
89291: EMPTY
89292: LIST
89293: LIST
89294: PUSH
89295: LD_INT 1
89297: NEG
89298: PUSH
89299: LD_INT 3
89301: NEG
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 0
89309: PUSH
89310: LD_INT 3
89312: NEG
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 1
89320: PUSH
89321: LD_INT 2
89323: NEG
89324: PUSH
89325: EMPTY
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 2
89331: PUSH
89332: LD_INT 1
89334: NEG
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 3
89342: PUSH
89343: LD_INT 0
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: PUSH
89350: LD_INT 3
89352: PUSH
89353: LD_INT 1
89355: PUSH
89356: EMPTY
89357: LIST
89358: LIST
89359: PUSH
89360: LD_INT 1
89362: PUSH
89363: LD_INT 3
89365: PUSH
89366: EMPTY
89367: LIST
89368: LIST
89369: PUSH
89370: LD_INT 0
89372: PUSH
89373: LD_INT 3
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 1
89382: NEG
89383: PUSH
89384: LD_INT 2
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 2
89393: NEG
89394: PUSH
89395: LD_INT 1
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: PUSH
89402: LD_INT 3
89404: NEG
89405: PUSH
89406: LD_INT 0
89408: PUSH
89409: EMPTY
89410: LIST
89411: LIST
89412: PUSH
89413: LD_INT 3
89415: NEG
89416: PUSH
89417: LD_INT 1
89419: NEG
89420: PUSH
89421: EMPTY
89422: LIST
89423: LIST
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89456: LD_ADDR_VAR 0 47
89460: PUSH
89461: LD_INT 0
89463: PUSH
89464: LD_INT 0
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 0
89473: PUSH
89474: LD_INT 1
89476: NEG
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: PUSH
89482: LD_INT 1
89484: PUSH
89485: LD_INT 0
89487: PUSH
89488: EMPTY
89489: LIST
89490: LIST
89491: PUSH
89492: LD_INT 1
89494: PUSH
89495: LD_INT 1
89497: PUSH
89498: EMPTY
89499: LIST
89500: LIST
89501: PUSH
89502: LD_INT 0
89504: PUSH
89505: LD_INT 1
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: PUSH
89512: LD_INT 1
89514: NEG
89515: PUSH
89516: LD_INT 0
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: PUSH
89523: LD_INT 1
89525: NEG
89526: PUSH
89527: LD_INT 1
89529: NEG
89530: PUSH
89531: EMPTY
89532: LIST
89533: LIST
89534: PUSH
89535: LD_INT 1
89537: NEG
89538: PUSH
89539: LD_INT 2
89541: NEG
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: PUSH
89547: LD_INT 0
89549: PUSH
89550: LD_INT 2
89552: NEG
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 1
89560: PUSH
89561: LD_INT 1
89563: NEG
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 2
89571: NEG
89572: PUSH
89573: LD_INT 1
89575: NEG
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 2
89583: NEG
89584: PUSH
89585: LD_INT 2
89587: NEG
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: LIST
89606: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89607: LD_ADDR_VAR 0 48
89611: PUSH
89612: LD_INT 0
89614: PUSH
89615: LD_INT 0
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 0
89624: PUSH
89625: LD_INT 1
89627: NEG
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: LD_INT 0
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 1
89645: PUSH
89646: LD_INT 1
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 0
89655: PUSH
89656: LD_INT 1
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 1
89665: NEG
89666: PUSH
89667: LD_INT 0
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 1
89676: NEG
89677: PUSH
89678: LD_INT 1
89680: NEG
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 1
89688: NEG
89689: PUSH
89690: LD_INT 2
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 0
89700: PUSH
89701: LD_INT 2
89703: NEG
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: LD_INT 1
89714: NEG
89715: PUSH
89716: EMPTY
89717: LIST
89718: LIST
89719: PUSH
89720: LD_INT 2
89722: PUSH
89723: LD_INT 0
89725: PUSH
89726: EMPTY
89727: LIST
89728: LIST
89729: PUSH
89730: LD_INT 2
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89754: LD_ADDR_VAR 0 49
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 0
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 0
89771: PUSH
89772: LD_INT 1
89774: NEG
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 1
89782: PUSH
89783: LD_INT 0
89785: PUSH
89786: EMPTY
89787: LIST
89788: LIST
89789: PUSH
89790: LD_INT 1
89792: PUSH
89793: LD_INT 1
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 0
89802: PUSH
89803: LD_INT 1
89805: PUSH
89806: EMPTY
89807: LIST
89808: LIST
89809: PUSH
89810: LD_INT 1
89812: NEG
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: NEG
89824: PUSH
89825: LD_INT 1
89827: NEG
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: PUSH
89833: LD_INT 1
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: LD_INT 0
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 2
89856: PUSH
89857: LD_INT 1
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 2
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 1
89876: PUSH
89877: LD_INT 2
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89898: LD_ADDR_VAR 0 50
89902: PUSH
89903: LD_INT 0
89905: PUSH
89906: LD_INT 0
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: LD_INT 0
89915: PUSH
89916: LD_INT 1
89918: NEG
89919: PUSH
89920: EMPTY
89921: LIST
89922: LIST
89923: PUSH
89924: LD_INT 1
89926: PUSH
89927: LD_INT 0
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 1
89936: PUSH
89937: LD_INT 1
89939: PUSH
89940: EMPTY
89941: LIST
89942: LIST
89943: PUSH
89944: LD_INT 0
89946: PUSH
89947: LD_INT 1
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 1
89956: NEG
89957: PUSH
89958: LD_INT 0
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 1
89967: NEG
89968: PUSH
89969: LD_INT 1
89971: NEG
89972: PUSH
89973: EMPTY
89974: LIST
89975: LIST
89976: PUSH
89977: LD_INT 2
89979: PUSH
89980: LD_INT 1
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 2
89989: PUSH
89990: LD_INT 2
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: LD_INT 2
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 1
90019: NEG
90020: PUSH
90021: LD_INT 1
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90042: LD_ADDR_VAR 0 51
90046: PUSH
90047: LD_INT 0
90049: PUSH
90050: LD_INT 0
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PUSH
90057: LD_INT 0
90059: PUSH
90060: LD_INT 1
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 1
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PUSH
90078: LD_INT 1
90080: PUSH
90081: LD_INT 1
90083: PUSH
90084: EMPTY
90085: LIST
90086: LIST
90087: PUSH
90088: LD_INT 0
90090: PUSH
90091: LD_INT 1
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 1
90100: NEG
90101: PUSH
90102: LD_INT 0
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 1
90111: NEG
90112: PUSH
90113: LD_INT 1
90115: NEG
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 1
90123: PUSH
90124: LD_INT 2
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 0
90133: PUSH
90134: LD_INT 2
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 1
90143: NEG
90144: PUSH
90145: LD_INT 1
90147: PUSH
90148: EMPTY
90149: LIST
90150: LIST
90151: PUSH
90152: LD_INT 2
90154: NEG
90155: PUSH
90156: LD_INT 0
90158: PUSH
90159: EMPTY
90160: LIST
90161: LIST
90162: PUSH
90163: LD_INT 2
90165: NEG
90166: PUSH
90167: LD_INT 1
90169: NEG
90170: PUSH
90171: EMPTY
90172: LIST
90173: LIST
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90189: LD_ADDR_VAR 0 52
90193: PUSH
90194: LD_INT 0
90196: PUSH
90197: LD_INT 0
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: LD_INT 1
90209: NEG
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: LD_INT 0
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: LD_INT 1
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: NEG
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: NEG
90271: PUSH
90272: LD_INT 2
90274: NEG
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 1
90282: NEG
90283: PUSH
90284: LD_INT 1
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 2
90293: NEG
90294: PUSH
90295: LD_INT 0
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 2
90304: NEG
90305: PUSH
90306: LD_INT 1
90308: NEG
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 2
90316: NEG
90317: PUSH
90318: LD_INT 2
90320: NEG
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: EMPTY
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90340: LD_ADDR_VAR 0 53
90344: PUSH
90345: LD_INT 0
90347: PUSH
90348: LD_INT 0
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: LD_INT 1
90360: NEG
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 1
90368: PUSH
90369: LD_INT 0
90371: PUSH
90372: EMPTY
90373: LIST
90374: LIST
90375: PUSH
90376: LD_INT 1
90378: PUSH
90379: LD_INT 1
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: LD_INT 1
90391: PUSH
90392: EMPTY
90393: LIST
90394: LIST
90395: PUSH
90396: LD_INT 1
90398: NEG
90399: PUSH
90400: LD_INT 0
90402: PUSH
90403: EMPTY
90404: LIST
90405: LIST
90406: PUSH
90407: LD_INT 1
90409: NEG
90410: PUSH
90411: LD_INT 1
90413: NEG
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: NEG
90422: PUSH
90423: LD_INT 2
90425: NEG
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 0
90433: PUSH
90434: LD_INT 2
90436: NEG
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 1
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 2
90465: PUSH
90466: LD_INT 1
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PUSH
90473: LD_INT 2
90475: PUSH
90476: LD_INT 2
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: EMPTY
90490: LIST
90491: LIST
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 2
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 1
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 2
90516: NEG
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 2
90527: NEG
90528: PUSH
90529: LD_INT 1
90531: NEG
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 2
90539: NEG
90540: PUSH
90541: LD_INT 2
90543: NEG
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: LIST
90566: LIST
90567: LIST
90568: LIST
90569: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90570: LD_ADDR_VAR 0 54
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: PUSH
90585: LD_INT 0
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: PUSH
90599: LD_INT 0
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 1
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: PUSH
90626: LD_INT 1
90628: NEG
90629: PUSH
90630: LD_INT 0
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: LD_INT 1
90639: NEG
90640: PUSH
90641: LD_INT 1
90643: NEG
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: LD_INT 2
90655: NEG
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 0
90663: PUSH
90664: LD_INT 2
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 1
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 2
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 2
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 2
90705: PUSH
90706: LD_INT 2
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PUSH
90713: LD_INT 1
90715: PUSH
90716: LD_INT 2
90718: PUSH
90719: EMPTY
90720: LIST
90721: LIST
90722: PUSH
90723: LD_INT 0
90725: PUSH
90726: LD_INT 2
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: EMPTY
90741: LIST
90742: LIST
90743: PUSH
90744: LD_INT 2
90746: NEG
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: LD_INT 2
90757: NEG
90758: PUSH
90759: LD_INT 1
90761: NEG
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 2
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90800: LD_ADDR_VAR 0 55
90804: PUSH
90805: LD_INT 0
90807: PUSH
90808: LD_INT 0
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: LD_INT 0
90817: PUSH
90818: LD_INT 1
90820: NEG
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 1
90828: PUSH
90829: LD_INT 0
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: PUSH
90839: LD_INT 1
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: PUSH
90846: LD_INT 0
90848: PUSH
90849: LD_INT 1
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 1
90858: NEG
90859: PUSH
90860: LD_INT 0
90862: PUSH
90863: EMPTY
90864: LIST
90865: LIST
90866: PUSH
90867: LD_INT 1
90869: NEG
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 1
90881: NEG
90882: PUSH
90883: LD_INT 2
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 0
90893: PUSH
90894: LD_INT 2
90896: NEG
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 1
90904: PUSH
90905: LD_INT 1
90907: NEG
90908: PUSH
90909: EMPTY
90910: LIST
90911: LIST
90912: PUSH
90913: LD_INT 2
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 2
90925: PUSH
90926: LD_INT 1
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 2
90935: PUSH
90936: LD_INT 2
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 1
90945: PUSH
90946: LD_INT 2
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: LD_INT 0
90955: PUSH
90956: LD_INT 2
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 1
90965: NEG
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PUSH
90974: LD_INT 2
90976: NEG
90977: PUSH
90978: LD_INT 0
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 2
90987: NEG
90988: PUSH
90989: LD_INT 1
90991: NEG
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 2
90999: NEG
91000: PUSH
91001: LD_INT 2
91003: NEG
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: EMPTY
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91030: LD_ADDR_VAR 0 56
91034: PUSH
91035: LD_INT 0
91037: PUSH
91038: LD_INT 0
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 0
91047: PUSH
91048: LD_INT 1
91050: NEG
91051: PUSH
91052: EMPTY
91053: LIST
91054: LIST
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: LD_INT 0
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: PUSH
91066: LD_INT 1
91068: PUSH
91069: LD_INT 1
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 0
91078: PUSH
91079: LD_INT 1
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: LD_INT 0
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PUSH
91097: LD_INT 1
91099: NEG
91100: PUSH
91101: LD_INT 1
91103: NEG
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 1
91111: NEG
91112: PUSH
91113: LD_INT 2
91115: NEG
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 0
91123: PUSH
91124: LD_INT 2
91126: NEG
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 1
91134: PUSH
91135: LD_INT 1
91137: NEG
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 2
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 2
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 2
91165: PUSH
91166: LD_INT 2
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: PUSH
91173: LD_INT 1
91175: PUSH
91176: LD_INT 2
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PUSH
91183: LD_INT 0
91185: PUSH
91186: LD_INT 2
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 1
91195: NEG
91196: PUSH
91197: LD_INT 1
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PUSH
91204: LD_INT 2
91206: NEG
91207: PUSH
91208: LD_INT 0
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 2
91217: NEG
91218: PUSH
91219: LD_INT 1
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 2
91229: NEG
91230: PUSH
91231: LD_INT 2
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91260: LD_ADDR_VAR 0 57
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: LD_INT 0
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 0
91277: PUSH
91278: LD_INT 1
91280: NEG
91281: PUSH
91282: EMPTY
91283: LIST
91284: LIST
91285: PUSH
91286: LD_INT 1
91288: PUSH
91289: LD_INT 0
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: LD_INT 1
91298: PUSH
91299: LD_INT 1
91301: PUSH
91302: EMPTY
91303: LIST
91304: LIST
91305: PUSH
91306: LD_INT 0
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PUSH
91316: LD_INT 1
91318: NEG
91319: PUSH
91320: LD_INT 0
91322: PUSH
91323: EMPTY
91324: LIST
91325: LIST
91326: PUSH
91327: LD_INT 1
91329: NEG
91330: PUSH
91331: LD_INT 1
91333: NEG
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: PUSH
91339: LD_INT 1
91341: NEG
91342: PUSH
91343: LD_INT 2
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 0
91353: PUSH
91354: LD_INT 2
91356: NEG
91357: PUSH
91358: EMPTY
91359: LIST
91360: LIST
91361: PUSH
91362: LD_INT 1
91364: PUSH
91365: LD_INT 1
91367: NEG
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: LD_INT 2
91375: PUSH
91376: LD_INT 0
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: PUSH
91383: LD_INT 2
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: EMPTY
91390: LIST
91391: LIST
91392: PUSH
91393: LD_INT 2
91395: PUSH
91396: LD_INT 2
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: LD_INT 1
91405: PUSH
91406: LD_INT 2
91408: PUSH
91409: EMPTY
91410: LIST
91411: LIST
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: LD_INT 2
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 1
91425: NEG
91426: PUSH
91427: LD_INT 1
91429: PUSH
91430: EMPTY
91431: LIST
91432: LIST
91433: PUSH
91434: LD_INT 2
91436: NEG
91437: PUSH
91438: LD_INT 0
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: PUSH
91445: LD_INT 2
91447: NEG
91448: PUSH
91449: LD_INT 1
91451: NEG
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 2
91459: NEG
91460: PUSH
91461: LD_INT 2
91463: NEG
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: PUSH
91469: EMPTY
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91490: LD_ADDR_VAR 0 58
91494: PUSH
91495: LD_INT 0
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: LD_INT 1
91510: NEG
91511: PUSH
91512: EMPTY
91513: LIST
91514: LIST
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: LD_INT 0
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PUSH
91526: LD_INT 1
91528: PUSH
91529: LD_INT 1
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: LD_INT 1
91541: PUSH
91542: EMPTY
91543: LIST
91544: LIST
91545: PUSH
91546: LD_INT 1
91548: NEG
91549: PUSH
91550: LD_INT 0
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 1
91559: NEG
91560: PUSH
91561: LD_INT 1
91563: NEG
91564: PUSH
91565: EMPTY
91566: LIST
91567: LIST
91568: PUSH
91569: LD_INT 1
91571: NEG
91572: PUSH
91573: LD_INT 2
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 0
91583: PUSH
91584: LD_INT 2
91586: NEG
91587: PUSH
91588: EMPTY
91589: LIST
91590: LIST
91591: PUSH
91592: LD_INT 1
91594: PUSH
91595: LD_INT 1
91597: NEG
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: PUSH
91603: LD_INT 2
91605: PUSH
91606: LD_INT 0
91608: PUSH
91609: EMPTY
91610: LIST
91611: LIST
91612: PUSH
91613: LD_INT 2
91615: PUSH
91616: LD_INT 1
91618: PUSH
91619: EMPTY
91620: LIST
91621: LIST
91622: PUSH
91623: LD_INT 2
91625: PUSH
91626: LD_INT 2
91628: PUSH
91629: EMPTY
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 1
91635: PUSH
91636: LD_INT 2
91638: PUSH
91639: EMPTY
91640: LIST
91641: LIST
91642: PUSH
91643: LD_INT 0
91645: PUSH
91646: LD_INT 2
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: PUSH
91653: LD_INT 1
91655: NEG
91656: PUSH
91657: LD_INT 1
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 2
91666: NEG
91667: PUSH
91668: LD_INT 0
91670: PUSH
91671: EMPTY
91672: LIST
91673: LIST
91674: PUSH
91675: LD_INT 2
91677: NEG
91678: PUSH
91679: LD_INT 1
91681: NEG
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: LD_INT 2
91689: NEG
91690: PUSH
91691: LD_INT 2
91693: NEG
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: EMPTY
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91720: LD_ADDR_VAR 0 59
91724: PUSH
91725: LD_INT 0
91727: PUSH
91728: LD_INT 0
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: LD_INT 0
91737: PUSH
91738: LD_INT 1
91740: NEG
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 1
91748: PUSH
91749: LD_INT 0
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: LD_INT 1
91758: PUSH
91759: LD_INT 1
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 0
91768: PUSH
91769: LD_INT 1
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 1
91778: NEG
91779: PUSH
91780: LD_INT 0
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: LD_INT 1
91789: NEG
91790: PUSH
91791: LD_INT 1
91793: NEG
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91808: LD_ADDR_VAR 0 60
91812: PUSH
91813: LD_INT 0
91815: PUSH
91816: LD_INT 0
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 0
91825: PUSH
91826: LD_INT 1
91828: NEG
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: PUSH
91834: LD_INT 1
91836: PUSH
91837: LD_INT 0
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 1
91846: PUSH
91847: LD_INT 1
91849: PUSH
91850: EMPTY
91851: LIST
91852: LIST
91853: PUSH
91854: LD_INT 0
91856: PUSH
91857: LD_INT 1
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 1
91866: NEG
91867: PUSH
91868: LD_INT 0
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: LD_INT 1
91877: NEG
91878: PUSH
91879: LD_INT 1
91881: NEG
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91896: LD_ADDR_VAR 0 61
91900: PUSH
91901: LD_INT 0
91903: PUSH
91904: LD_INT 0
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: PUSH
91911: LD_INT 0
91913: PUSH
91914: LD_INT 1
91916: NEG
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 1
91924: PUSH
91925: LD_INT 0
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 1
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: LD_INT 0
91944: PUSH
91945: LD_INT 1
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 1
91954: NEG
91955: PUSH
91956: LD_INT 0
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 1
91965: NEG
91966: PUSH
91967: LD_INT 1
91969: NEG
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: LIST
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91984: LD_ADDR_VAR 0 62
91988: PUSH
91989: LD_INT 0
91991: PUSH
91992: LD_INT 0
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 0
92001: PUSH
92002: LD_INT 1
92004: NEG
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 1
92012: PUSH
92013: LD_INT 0
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: PUSH
92020: LD_INT 1
92022: PUSH
92023: LD_INT 1
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 0
92032: PUSH
92033: LD_INT 1
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 1
92042: NEG
92043: PUSH
92044: LD_INT 0
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 1
92053: NEG
92054: PUSH
92055: LD_INT 1
92057: NEG
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: EMPTY
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92072: LD_ADDR_VAR 0 63
92076: PUSH
92077: LD_INT 0
92079: PUSH
92080: LD_INT 0
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 0
92089: PUSH
92090: LD_INT 1
92092: NEG
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: LD_INT 1
92100: PUSH
92101: LD_INT 0
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 1
92110: PUSH
92111: LD_INT 1
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: LD_INT 0
92120: PUSH
92121: LD_INT 1
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 1
92130: NEG
92131: PUSH
92132: LD_INT 0
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 1
92141: NEG
92142: PUSH
92143: LD_INT 1
92145: NEG
92146: PUSH
92147: EMPTY
92148: LIST
92149: LIST
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: LIST
92158: LIST
92159: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92160: LD_ADDR_VAR 0 64
92164: PUSH
92165: LD_INT 0
92167: PUSH
92168: LD_INT 0
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 0
92177: PUSH
92178: LD_INT 1
92180: NEG
92181: PUSH
92182: EMPTY
92183: LIST
92184: LIST
92185: PUSH
92186: LD_INT 1
92188: PUSH
92189: LD_INT 0
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 1
92198: PUSH
92199: LD_INT 1
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: PUSH
92206: LD_INT 0
92208: PUSH
92209: LD_INT 1
92211: PUSH
92212: EMPTY
92213: LIST
92214: LIST
92215: PUSH
92216: LD_INT 1
92218: NEG
92219: PUSH
92220: LD_INT 0
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PUSH
92227: LD_INT 1
92229: NEG
92230: PUSH
92231: LD_INT 1
92233: NEG
92234: PUSH
92235: EMPTY
92236: LIST
92237: LIST
92238: PUSH
92239: EMPTY
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: ST_TO_ADDR
// end ; 1 :
92248: GO 98145
92250: LD_INT 1
92252: DOUBLE
92253: EQUAL
92254: IFTRUE 92258
92256: GO 94881
92258: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92259: LD_ADDR_VAR 0 11
92263: PUSH
92264: LD_INT 1
92266: NEG
92267: PUSH
92268: LD_INT 3
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 0
92278: PUSH
92279: LD_INT 3
92281: NEG
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 1
92289: PUSH
92290: LD_INT 2
92292: NEG
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92303: LD_ADDR_VAR 0 12
92307: PUSH
92308: LD_INT 2
92310: PUSH
92311: LD_INT 1
92313: NEG
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: PUSH
92322: LD_INT 0
92324: PUSH
92325: EMPTY
92326: LIST
92327: LIST
92328: PUSH
92329: LD_INT 3
92331: PUSH
92332: LD_INT 1
92334: PUSH
92335: EMPTY
92336: LIST
92337: LIST
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: LIST
92343: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92344: LD_ADDR_VAR 0 13
92348: PUSH
92349: LD_INT 3
92351: PUSH
92352: LD_INT 2
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: PUSH
92359: LD_INT 3
92361: PUSH
92362: LD_INT 3
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: LD_INT 2
92371: PUSH
92372: LD_INT 3
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: PUSH
92379: EMPTY
92380: LIST
92381: LIST
92382: LIST
92383: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92384: LD_ADDR_VAR 0 14
92388: PUSH
92389: LD_INT 1
92391: PUSH
92392: LD_INT 3
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 0
92401: PUSH
92402: LD_INT 3
92404: PUSH
92405: EMPTY
92406: LIST
92407: LIST
92408: PUSH
92409: LD_INT 1
92411: NEG
92412: PUSH
92413: LD_INT 2
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: LIST
92424: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92425: LD_ADDR_VAR 0 15
92429: PUSH
92430: LD_INT 2
92432: NEG
92433: PUSH
92434: LD_INT 1
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: PUSH
92441: LD_INT 3
92443: NEG
92444: PUSH
92445: LD_INT 0
92447: PUSH
92448: EMPTY
92449: LIST
92450: LIST
92451: PUSH
92452: LD_INT 3
92454: NEG
92455: PUSH
92456: LD_INT 1
92458: NEG
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: EMPTY
92465: LIST
92466: LIST
92467: LIST
92468: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92469: LD_ADDR_VAR 0 16
92473: PUSH
92474: LD_INT 2
92476: NEG
92477: PUSH
92478: LD_INT 3
92480: NEG
92481: PUSH
92482: EMPTY
92483: LIST
92484: LIST
92485: PUSH
92486: LD_INT 3
92488: NEG
92489: PUSH
92490: LD_INT 2
92492: NEG
92493: PUSH
92494: EMPTY
92495: LIST
92496: LIST
92497: PUSH
92498: LD_INT 3
92500: NEG
92501: PUSH
92502: LD_INT 3
92504: NEG
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: LIST
92514: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92515: LD_ADDR_VAR 0 17
92519: PUSH
92520: LD_INT 1
92522: NEG
92523: PUSH
92524: LD_INT 3
92526: NEG
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 0
92534: PUSH
92535: LD_INT 3
92537: NEG
92538: PUSH
92539: EMPTY
92540: LIST
92541: LIST
92542: PUSH
92543: LD_INT 1
92545: PUSH
92546: LD_INT 2
92548: NEG
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: LIST
92558: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92559: LD_ADDR_VAR 0 18
92563: PUSH
92564: LD_INT 2
92566: PUSH
92567: LD_INT 1
92569: NEG
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 3
92577: PUSH
92578: LD_INT 0
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: PUSH
92585: LD_INT 3
92587: PUSH
92588: LD_INT 1
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: LIST
92599: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92600: LD_ADDR_VAR 0 19
92604: PUSH
92605: LD_INT 3
92607: PUSH
92608: LD_INT 2
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 3
92617: PUSH
92618: LD_INT 3
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: PUSH
92628: LD_INT 3
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: LIST
92639: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92640: LD_ADDR_VAR 0 20
92644: PUSH
92645: LD_INT 1
92647: PUSH
92648: LD_INT 3
92650: PUSH
92651: EMPTY
92652: LIST
92653: LIST
92654: PUSH
92655: LD_INT 0
92657: PUSH
92658: LD_INT 3
92660: PUSH
92661: EMPTY
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: NEG
92668: PUSH
92669: LD_INT 2
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: LIST
92680: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92681: LD_ADDR_VAR 0 21
92685: PUSH
92686: LD_INT 2
92688: NEG
92689: PUSH
92690: LD_INT 1
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PUSH
92697: LD_INT 3
92699: NEG
92700: PUSH
92701: LD_INT 0
92703: PUSH
92704: EMPTY
92705: LIST
92706: LIST
92707: PUSH
92708: LD_INT 3
92710: NEG
92711: PUSH
92712: LD_INT 1
92714: NEG
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: LIST
92724: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92725: LD_ADDR_VAR 0 22
92729: PUSH
92730: LD_INT 2
92732: NEG
92733: PUSH
92734: LD_INT 3
92736: NEG
92737: PUSH
92738: EMPTY
92739: LIST
92740: LIST
92741: PUSH
92742: LD_INT 3
92744: NEG
92745: PUSH
92746: LD_INT 2
92748: NEG
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: PUSH
92754: LD_INT 3
92756: NEG
92757: PUSH
92758: LD_INT 3
92760: NEG
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: EMPTY
92767: LIST
92768: LIST
92769: LIST
92770: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92771: LD_ADDR_VAR 0 23
92775: PUSH
92776: LD_INT 0
92778: PUSH
92779: LD_INT 3
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 1
92789: NEG
92790: PUSH
92791: LD_INT 4
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 1
92801: PUSH
92802: LD_INT 3
92804: NEG
92805: PUSH
92806: EMPTY
92807: LIST
92808: LIST
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: LIST
92814: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92815: LD_ADDR_VAR 0 24
92819: PUSH
92820: LD_INT 3
92822: PUSH
92823: LD_INT 0
92825: PUSH
92826: EMPTY
92827: LIST
92828: LIST
92829: PUSH
92830: LD_INT 3
92832: PUSH
92833: LD_INT 1
92835: NEG
92836: PUSH
92837: EMPTY
92838: LIST
92839: LIST
92840: PUSH
92841: LD_INT 4
92843: PUSH
92844: LD_INT 1
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: LIST
92855: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92856: LD_ADDR_VAR 0 25
92860: PUSH
92861: LD_INT 3
92863: PUSH
92864: LD_INT 3
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 4
92873: PUSH
92874: LD_INT 3
92876: PUSH
92877: EMPTY
92878: LIST
92879: LIST
92880: PUSH
92881: LD_INT 3
92883: PUSH
92884: LD_INT 4
92886: PUSH
92887: EMPTY
92888: LIST
92889: LIST
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: LIST
92895: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92896: LD_ADDR_VAR 0 26
92900: PUSH
92901: LD_INT 0
92903: PUSH
92904: LD_INT 3
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: PUSH
92911: LD_INT 1
92913: PUSH
92914: LD_INT 4
92916: PUSH
92917: EMPTY
92918: LIST
92919: LIST
92920: PUSH
92921: LD_INT 1
92923: NEG
92924: PUSH
92925: LD_INT 3
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: EMPTY
92933: LIST
92934: LIST
92935: LIST
92936: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92937: LD_ADDR_VAR 0 27
92941: PUSH
92942: LD_INT 3
92944: NEG
92945: PUSH
92946: LD_INT 0
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 3
92955: NEG
92956: PUSH
92957: LD_INT 1
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 4
92966: NEG
92967: PUSH
92968: LD_INT 1
92970: NEG
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: LIST
92980: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92981: LD_ADDR_VAR 0 28
92985: PUSH
92986: LD_INT 3
92988: NEG
92989: PUSH
92990: LD_INT 3
92992: NEG
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 3
93000: NEG
93001: PUSH
93002: LD_INT 4
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 4
93012: NEG
93013: PUSH
93014: LD_INT 3
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: LIST
93026: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93027: LD_ADDR_VAR 0 29
93031: PUSH
93032: LD_INT 1
93034: NEG
93035: PUSH
93036: LD_INT 3
93038: NEG
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 0
93046: PUSH
93047: LD_INT 3
93049: NEG
93050: PUSH
93051: EMPTY
93052: LIST
93053: LIST
93054: PUSH
93055: LD_INT 1
93057: PUSH
93058: LD_INT 2
93060: NEG
93061: PUSH
93062: EMPTY
93063: LIST
93064: LIST
93065: PUSH
93066: LD_INT 1
93068: NEG
93069: PUSH
93070: LD_INT 4
93072: NEG
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 0
93080: PUSH
93081: LD_INT 4
93083: NEG
93084: PUSH
93085: EMPTY
93086: LIST
93087: LIST
93088: PUSH
93089: LD_INT 1
93091: PUSH
93092: LD_INT 3
93094: NEG
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 1
93102: NEG
93103: PUSH
93104: LD_INT 5
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 0
93114: PUSH
93115: LD_INT 5
93117: NEG
93118: PUSH
93119: EMPTY
93120: LIST
93121: LIST
93122: PUSH
93123: LD_INT 1
93125: PUSH
93126: LD_INT 4
93128: NEG
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 1
93136: NEG
93137: PUSH
93138: LD_INT 6
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: LD_INT 0
93148: PUSH
93149: LD_INT 6
93151: NEG
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 1
93159: PUSH
93160: LD_INT 5
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: LIST
93172: LIST
93173: LIST
93174: LIST
93175: LIST
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
93182: LD_ADDR_VAR 0 30
93186: PUSH
93187: LD_INT 2
93189: PUSH
93190: LD_INT 1
93192: NEG
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: PUSH
93198: LD_INT 3
93200: PUSH
93201: LD_INT 0
93203: PUSH
93204: EMPTY
93205: LIST
93206: LIST
93207: PUSH
93208: LD_INT 3
93210: PUSH
93211: LD_INT 1
93213: PUSH
93214: EMPTY
93215: LIST
93216: LIST
93217: PUSH
93218: LD_INT 3
93220: PUSH
93221: LD_INT 1
93223: NEG
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 4
93231: PUSH
93232: LD_INT 0
93234: PUSH
93235: EMPTY
93236: LIST
93237: LIST
93238: PUSH
93239: LD_INT 4
93241: PUSH
93242: LD_INT 1
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PUSH
93249: LD_INT 4
93251: PUSH
93252: LD_INT 1
93254: NEG
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 5
93262: PUSH
93263: LD_INT 0
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: PUSH
93270: LD_INT 5
93272: PUSH
93273: LD_INT 1
93275: PUSH
93276: EMPTY
93277: LIST
93278: LIST
93279: PUSH
93280: LD_INT 5
93282: PUSH
93283: LD_INT 1
93285: NEG
93286: PUSH
93287: EMPTY
93288: LIST
93289: LIST
93290: PUSH
93291: LD_INT 6
93293: PUSH
93294: LD_INT 0
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 6
93303: PUSH
93304: LD_INT 1
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: LIST
93318: LIST
93319: LIST
93320: LIST
93321: LIST
93322: LIST
93323: LIST
93324: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93325: LD_ADDR_VAR 0 31
93329: PUSH
93330: LD_INT 3
93332: PUSH
93333: LD_INT 2
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 3
93342: PUSH
93343: LD_INT 3
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 2
93352: PUSH
93353: LD_INT 3
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 4
93362: PUSH
93363: LD_INT 3
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 4
93372: PUSH
93373: LD_INT 4
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 3
93382: PUSH
93383: LD_INT 4
93385: PUSH
93386: EMPTY
93387: LIST
93388: LIST
93389: PUSH
93390: LD_INT 5
93392: PUSH
93393: LD_INT 4
93395: PUSH
93396: EMPTY
93397: LIST
93398: LIST
93399: PUSH
93400: LD_INT 5
93402: PUSH
93403: LD_INT 5
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PUSH
93410: LD_INT 4
93412: PUSH
93413: LD_INT 5
93415: PUSH
93416: EMPTY
93417: LIST
93418: LIST
93419: PUSH
93420: LD_INT 6
93422: PUSH
93423: LD_INT 5
93425: PUSH
93426: EMPTY
93427: LIST
93428: LIST
93429: PUSH
93430: LD_INT 6
93432: PUSH
93433: LD_INT 6
93435: PUSH
93436: EMPTY
93437: LIST
93438: LIST
93439: PUSH
93440: LD_INT 5
93442: PUSH
93443: LD_INT 6
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93464: LD_ADDR_VAR 0 32
93468: PUSH
93469: LD_INT 1
93471: PUSH
93472: LD_INT 3
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: PUSH
93479: LD_INT 0
93481: PUSH
93482: LD_INT 3
93484: PUSH
93485: EMPTY
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 1
93491: NEG
93492: PUSH
93493: LD_INT 2
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PUSH
93500: LD_INT 1
93502: PUSH
93503: LD_INT 4
93505: PUSH
93506: EMPTY
93507: LIST
93508: LIST
93509: PUSH
93510: LD_INT 0
93512: PUSH
93513: LD_INT 4
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 1
93522: NEG
93523: PUSH
93524: LD_INT 3
93526: PUSH
93527: EMPTY
93528: LIST
93529: LIST
93530: PUSH
93531: LD_INT 1
93533: PUSH
93534: LD_INT 5
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 0
93543: PUSH
93544: LD_INT 5
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 1
93553: NEG
93554: PUSH
93555: LD_INT 4
93557: PUSH
93558: EMPTY
93559: LIST
93560: LIST
93561: PUSH
93562: LD_INT 1
93564: PUSH
93565: LD_INT 6
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: PUSH
93572: LD_INT 0
93574: PUSH
93575: LD_INT 6
93577: PUSH
93578: EMPTY
93579: LIST
93580: LIST
93581: PUSH
93582: LD_INT 1
93584: NEG
93585: PUSH
93586: LD_INT 5
93588: PUSH
93589: EMPTY
93590: LIST
93591: LIST
93592: PUSH
93593: EMPTY
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93607: LD_ADDR_VAR 0 33
93611: PUSH
93612: LD_INT 2
93614: NEG
93615: PUSH
93616: LD_INT 1
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 3
93625: NEG
93626: PUSH
93627: LD_INT 0
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 3
93636: NEG
93637: PUSH
93638: LD_INT 1
93640: NEG
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 3
93648: NEG
93649: PUSH
93650: LD_INT 1
93652: PUSH
93653: EMPTY
93654: LIST
93655: LIST
93656: PUSH
93657: LD_INT 4
93659: NEG
93660: PUSH
93661: LD_INT 0
93663: PUSH
93664: EMPTY
93665: LIST
93666: LIST
93667: PUSH
93668: LD_INT 4
93670: NEG
93671: PUSH
93672: LD_INT 1
93674: NEG
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 4
93682: NEG
93683: PUSH
93684: LD_INT 1
93686: PUSH
93687: EMPTY
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 5
93693: NEG
93694: PUSH
93695: LD_INT 0
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PUSH
93702: LD_INT 5
93704: NEG
93705: PUSH
93706: LD_INT 1
93708: NEG
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 5
93716: NEG
93717: PUSH
93718: LD_INT 1
93720: PUSH
93721: EMPTY
93722: LIST
93723: LIST
93724: PUSH
93725: LD_INT 6
93727: NEG
93728: PUSH
93729: LD_INT 0
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: PUSH
93736: LD_INT 6
93738: NEG
93739: PUSH
93740: LD_INT 1
93742: NEG
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93762: LD_ADDR_VAR 0 34
93766: PUSH
93767: LD_INT 2
93769: NEG
93770: PUSH
93771: LD_INT 3
93773: NEG
93774: PUSH
93775: EMPTY
93776: LIST
93777: LIST
93778: PUSH
93779: LD_INT 3
93781: NEG
93782: PUSH
93783: LD_INT 2
93785: NEG
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: LD_INT 3
93793: NEG
93794: PUSH
93795: LD_INT 3
93797: NEG
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 3
93805: NEG
93806: PUSH
93807: LD_INT 4
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 4
93817: NEG
93818: PUSH
93819: LD_INT 3
93821: NEG
93822: PUSH
93823: EMPTY
93824: LIST
93825: LIST
93826: PUSH
93827: LD_INT 4
93829: NEG
93830: PUSH
93831: LD_INT 4
93833: NEG
93834: PUSH
93835: EMPTY
93836: LIST
93837: LIST
93838: PUSH
93839: LD_INT 4
93841: NEG
93842: PUSH
93843: LD_INT 5
93845: NEG
93846: PUSH
93847: EMPTY
93848: LIST
93849: LIST
93850: PUSH
93851: LD_INT 5
93853: NEG
93854: PUSH
93855: LD_INT 4
93857: NEG
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: LD_INT 5
93865: NEG
93866: PUSH
93867: LD_INT 5
93869: NEG
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 5
93877: NEG
93878: PUSH
93879: LD_INT 6
93881: NEG
93882: PUSH
93883: EMPTY
93884: LIST
93885: LIST
93886: PUSH
93887: LD_INT 6
93889: NEG
93890: PUSH
93891: LD_INT 5
93893: NEG
93894: PUSH
93895: EMPTY
93896: LIST
93897: LIST
93898: PUSH
93899: LD_INT 6
93901: NEG
93902: PUSH
93903: LD_INT 6
93905: NEG
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93925: LD_ADDR_VAR 0 41
93929: PUSH
93930: LD_INT 0
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 1
93943: NEG
93944: PUSH
93945: LD_INT 3
93947: NEG
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 1
93955: PUSH
93956: LD_INT 2
93958: NEG
93959: PUSH
93960: EMPTY
93961: LIST
93962: LIST
93963: PUSH
93964: EMPTY
93965: LIST
93966: LIST
93967: LIST
93968: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93969: LD_ADDR_VAR 0 42
93973: PUSH
93974: LD_INT 2
93976: PUSH
93977: LD_INT 0
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 2
93986: PUSH
93987: LD_INT 1
93989: NEG
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 3
93997: PUSH
93998: LD_INT 1
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: LIST
94009: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
94010: LD_ADDR_VAR 0 43
94014: PUSH
94015: LD_INT 2
94017: PUSH
94018: LD_INT 2
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PUSH
94025: LD_INT 3
94027: PUSH
94028: LD_INT 2
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: LD_INT 2
94037: PUSH
94038: LD_INT 3
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: LIST
94049: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94050: LD_ADDR_VAR 0 44
94054: PUSH
94055: LD_INT 0
94057: PUSH
94058: LD_INT 2
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 1
94067: PUSH
94068: LD_INT 3
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: PUSH
94075: LD_INT 1
94077: NEG
94078: PUSH
94079: LD_INT 2
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: LIST
94090: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94091: LD_ADDR_VAR 0 45
94095: PUSH
94096: LD_INT 2
94098: NEG
94099: PUSH
94100: LD_INT 0
94102: PUSH
94103: EMPTY
94104: LIST
94105: LIST
94106: PUSH
94107: LD_INT 2
94109: NEG
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: EMPTY
94115: LIST
94116: LIST
94117: PUSH
94118: LD_INT 3
94120: NEG
94121: PUSH
94122: LD_INT 1
94124: NEG
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: LIST
94134: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94135: LD_ADDR_VAR 0 46
94139: PUSH
94140: LD_INT 2
94142: NEG
94143: PUSH
94144: LD_INT 2
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 2
94154: NEG
94155: PUSH
94156: LD_INT 3
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 3
94166: NEG
94167: PUSH
94168: LD_INT 2
94170: NEG
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: EMPTY
94177: LIST
94178: LIST
94179: LIST
94180: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
94181: LD_ADDR_VAR 0 47
94185: PUSH
94186: LD_INT 2
94188: NEG
94189: PUSH
94190: LD_INT 3
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 1
94200: NEG
94201: PUSH
94202: LD_INT 3
94204: NEG
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: PUSH
94210: EMPTY
94211: LIST
94212: LIST
94213: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94214: LD_ADDR_VAR 0 48
94218: PUSH
94219: LD_INT 1
94221: PUSH
94222: LD_INT 2
94224: NEG
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 2
94232: PUSH
94233: LD_INT 1
94235: NEG
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: EMPTY
94242: LIST
94243: LIST
94244: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94245: LD_ADDR_VAR 0 49
94249: PUSH
94250: LD_INT 3
94252: PUSH
94253: LD_INT 1
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 3
94262: PUSH
94263: LD_INT 2
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: EMPTY
94271: LIST
94272: LIST
94273: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94274: LD_ADDR_VAR 0 50
94278: PUSH
94279: LD_INT 2
94281: PUSH
94282: LD_INT 3
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 1
94291: PUSH
94292: LD_INT 3
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94303: LD_ADDR_VAR 0 51
94307: PUSH
94308: LD_INT 1
94310: NEG
94311: PUSH
94312: LD_INT 2
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 2
94321: NEG
94322: PUSH
94323: LD_INT 1
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: EMPTY
94331: LIST
94332: LIST
94333: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94334: LD_ADDR_VAR 0 52
94338: PUSH
94339: LD_INT 3
94341: NEG
94342: PUSH
94343: LD_INT 1
94345: NEG
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: PUSH
94351: LD_INT 3
94353: NEG
94354: PUSH
94355: LD_INT 2
94357: NEG
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94367: LD_ADDR_VAR 0 53
94371: PUSH
94372: LD_INT 1
94374: NEG
94375: PUSH
94376: LD_INT 3
94378: NEG
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 0
94386: PUSH
94387: LD_INT 3
94389: NEG
94390: PUSH
94391: EMPTY
94392: LIST
94393: LIST
94394: PUSH
94395: LD_INT 1
94397: PUSH
94398: LD_INT 2
94400: NEG
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: PUSH
94406: EMPTY
94407: LIST
94408: LIST
94409: LIST
94410: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94411: LD_ADDR_VAR 0 54
94415: PUSH
94416: LD_INT 2
94418: PUSH
94419: LD_INT 1
94421: NEG
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 3
94429: PUSH
94430: LD_INT 0
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 3
94439: PUSH
94440: LD_INT 1
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: LIST
94451: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94452: LD_ADDR_VAR 0 55
94456: PUSH
94457: LD_INT 3
94459: PUSH
94460: LD_INT 2
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 3
94469: PUSH
94470: LD_INT 3
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 2
94479: PUSH
94480: LD_INT 3
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: LIST
94491: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94492: LD_ADDR_VAR 0 56
94496: PUSH
94497: LD_INT 1
94499: PUSH
94500: LD_INT 3
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 0
94509: PUSH
94510: LD_INT 3
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 1
94519: NEG
94520: PUSH
94521: LD_INT 2
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: LIST
94532: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94533: LD_ADDR_VAR 0 57
94537: PUSH
94538: LD_INT 2
94540: NEG
94541: PUSH
94542: LD_INT 1
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 3
94551: NEG
94552: PUSH
94553: LD_INT 0
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 3
94562: NEG
94563: PUSH
94564: LD_INT 1
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: LIST
94576: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94577: LD_ADDR_VAR 0 58
94581: PUSH
94582: LD_INT 2
94584: NEG
94585: PUSH
94586: LD_INT 3
94588: NEG
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 3
94596: NEG
94597: PUSH
94598: LD_INT 2
94600: NEG
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 3
94608: NEG
94609: PUSH
94610: LD_INT 3
94612: NEG
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: EMPTY
94619: LIST
94620: LIST
94621: LIST
94622: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94623: LD_ADDR_VAR 0 59
94627: PUSH
94628: LD_INT 1
94630: NEG
94631: PUSH
94632: LD_INT 2
94634: NEG
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: LD_INT 0
94642: PUSH
94643: LD_INT 2
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 1
94653: PUSH
94654: LD_INT 1
94656: NEG
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: LIST
94666: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94667: LD_ADDR_VAR 0 60
94671: PUSH
94672: LD_INT 1
94674: PUSH
94675: LD_INT 1
94677: NEG
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 2
94685: PUSH
94686: LD_INT 0
94688: PUSH
94689: EMPTY
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 2
94695: PUSH
94696: LD_INT 1
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: LIST
94707: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94708: LD_ADDR_VAR 0 61
94712: PUSH
94713: LD_INT 2
94715: PUSH
94716: LD_INT 1
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 2
94725: PUSH
94726: LD_INT 2
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PUSH
94733: LD_INT 1
94735: PUSH
94736: LD_INT 2
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: LIST
94747: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94748: LD_ADDR_VAR 0 62
94752: PUSH
94753: LD_INT 1
94755: PUSH
94756: LD_INT 2
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 0
94765: PUSH
94766: LD_INT 2
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: PUSH
94773: LD_INT 1
94775: NEG
94776: PUSH
94777: LD_INT 1
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: EMPTY
94785: LIST
94786: LIST
94787: LIST
94788: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94789: LD_ADDR_VAR 0 63
94793: PUSH
94794: LD_INT 1
94796: NEG
94797: PUSH
94798: LD_INT 1
94800: PUSH
94801: EMPTY
94802: LIST
94803: LIST
94804: PUSH
94805: LD_INT 2
94807: NEG
94808: PUSH
94809: LD_INT 0
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 2
94818: NEG
94819: PUSH
94820: LD_INT 1
94822: NEG
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: LIST
94832: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94833: LD_ADDR_VAR 0 64
94837: PUSH
94838: LD_INT 1
94840: NEG
94841: PUSH
94842: LD_INT 2
94844: NEG
94845: PUSH
94846: EMPTY
94847: LIST
94848: LIST
94849: PUSH
94850: LD_INT 2
94852: NEG
94853: PUSH
94854: LD_INT 1
94856: NEG
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 2
94864: NEG
94865: PUSH
94866: LD_INT 2
94868: NEG
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PUSH
94874: EMPTY
94875: LIST
94876: LIST
94877: LIST
94878: ST_TO_ADDR
// end ; 2 :
94879: GO 98145
94881: LD_INT 2
94883: DOUBLE
94884: EQUAL
94885: IFTRUE 94889
94887: GO 98144
94889: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94890: LD_ADDR_VAR 0 29
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: LD_INT 0
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 4
94907: PUSH
94908: LD_INT 1
94910: NEG
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 5
94918: PUSH
94919: LD_INT 0
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 5
94928: PUSH
94929: LD_INT 1
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 4
94938: PUSH
94939: LD_INT 1
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 3
94948: PUSH
94949: LD_INT 0
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 3
94958: PUSH
94959: LD_INT 1
94961: NEG
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 3
94969: PUSH
94970: LD_INT 2
94972: NEG
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 5
94980: PUSH
94981: LD_INT 2
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 3
94990: PUSH
94991: LD_INT 3
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 3
95000: PUSH
95001: LD_INT 2
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 4
95010: PUSH
95011: LD_INT 3
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 4
95020: PUSH
95021: LD_INT 4
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 3
95030: PUSH
95031: LD_INT 4
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 2
95040: PUSH
95041: LD_INT 3
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 2
95050: PUSH
95051: LD_INT 2
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: LD_INT 4
95060: PUSH
95061: LD_INT 2
95063: PUSH
95064: EMPTY
95065: LIST
95066: LIST
95067: PUSH
95068: LD_INT 2
95070: PUSH
95071: LD_INT 4
95073: PUSH
95074: EMPTY
95075: LIST
95076: LIST
95077: PUSH
95078: LD_INT 0
95080: PUSH
95081: LD_INT 4
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 0
95090: PUSH
95091: LD_INT 3
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: LD_INT 1
95100: PUSH
95101: LD_INT 4
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 1
95110: PUSH
95111: LD_INT 5
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: PUSH
95118: LD_INT 0
95120: PUSH
95121: LD_INT 5
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: PUSH
95128: LD_INT 1
95130: NEG
95131: PUSH
95132: LD_INT 4
95134: PUSH
95135: EMPTY
95136: LIST
95137: LIST
95138: PUSH
95139: LD_INT 1
95141: NEG
95142: PUSH
95143: LD_INT 3
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PUSH
95150: LD_INT 2
95152: PUSH
95153: LD_INT 5
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 2
95162: NEG
95163: PUSH
95164: LD_INT 3
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 3
95173: NEG
95174: PUSH
95175: LD_INT 0
95177: PUSH
95178: EMPTY
95179: LIST
95180: LIST
95181: PUSH
95182: LD_INT 3
95184: NEG
95185: PUSH
95186: LD_INT 1
95188: NEG
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 2
95196: NEG
95197: PUSH
95198: LD_INT 0
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 2
95207: NEG
95208: PUSH
95209: LD_INT 1
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 3
95218: NEG
95219: PUSH
95220: LD_INT 1
95222: PUSH
95223: EMPTY
95224: LIST
95225: LIST
95226: PUSH
95227: LD_INT 4
95229: NEG
95230: PUSH
95231: LD_INT 0
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 4
95240: NEG
95241: PUSH
95242: LD_INT 1
95244: NEG
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: PUSH
95250: LD_INT 4
95252: NEG
95253: PUSH
95254: LD_INT 2
95256: NEG
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: LD_INT 2
95264: NEG
95265: PUSH
95266: LD_INT 2
95268: PUSH
95269: EMPTY
95270: LIST
95271: LIST
95272: PUSH
95273: LD_INT 4
95275: NEG
95276: PUSH
95277: LD_INT 4
95279: NEG
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: PUSH
95285: LD_INT 4
95287: NEG
95288: PUSH
95289: LD_INT 5
95291: NEG
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: PUSH
95297: LD_INT 3
95299: NEG
95300: PUSH
95301: LD_INT 4
95303: NEG
95304: PUSH
95305: EMPTY
95306: LIST
95307: LIST
95308: PUSH
95309: LD_INT 3
95311: NEG
95312: PUSH
95313: LD_INT 3
95315: NEG
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: PUSH
95321: LD_INT 4
95323: NEG
95324: PUSH
95325: LD_INT 3
95327: NEG
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: PUSH
95333: LD_INT 5
95335: NEG
95336: PUSH
95337: LD_INT 4
95339: NEG
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 5
95347: NEG
95348: PUSH
95349: LD_INT 5
95351: NEG
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 3
95359: NEG
95360: PUSH
95361: LD_INT 5
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 5
95371: NEG
95372: PUSH
95373: LD_INT 3
95375: NEG
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95428: LD_ADDR_VAR 0 30
95432: PUSH
95433: LD_INT 4
95435: PUSH
95436: LD_INT 4
95438: PUSH
95439: EMPTY
95440: LIST
95441: LIST
95442: PUSH
95443: LD_INT 4
95445: PUSH
95446: LD_INT 3
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: LD_INT 5
95455: PUSH
95456: LD_INT 4
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: PUSH
95463: LD_INT 5
95465: PUSH
95466: LD_INT 5
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 4
95475: PUSH
95476: LD_INT 5
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: LD_INT 3
95485: PUSH
95486: LD_INT 4
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 3
95495: PUSH
95496: LD_INT 3
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: LD_INT 5
95505: PUSH
95506: LD_INT 3
95508: PUSH
95509: EMPTY
95510: LIST
95511: LIST
95512: PUSH
95513: LD_INT 3
95515: PUSH
95516: LD_INT 5
95518: PUSH
95519: EMPTY
95520: LIST
95521: LIST
95522: PUSH
95523: LD_INT 0
95525: PUSH
95526: LD_INT 3
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: PUSH
95533: LD_INT 0
95535: PUSH
95536: LD_INT 2
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: PUSH
95543: LD_INT 1
95545: PUSH
95546: LD_INT 3
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 1
95555: PUSH
95556: LD_INT 4
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: PUSH
95563: LD_INT 0
95565: PUSH
95566: LD_INT 4
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: LD_INT 1
95575: NEG
95576: PUSH
95577: LD_INT 3
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: PUSH
95584: LD_INT 1
95586: NEG
95587: PUSH
95588: LD_INT 2
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: PUSH
95595: LD_INT 2
95597: PUSH
95598: LD_INT 4
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 2
95607: NEG
95608: PUSH
95609: LD_INT 2
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 4
95618: NEG
95619: PUSH
95620: LD_INT 0
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: PUSH
95627: LD_INT 4
95629: NEG
95630: PUSH
95631: LD_INT 1
95633: NEG
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 3
95641: NEG
95642: PUSH
95643: LD_INT 0
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 3
95652: NEG
95653: PUSH
95654: LD_INT 1
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 4
95663: NEG
95664: PUSH
95665: LD_INT 1
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 5
95674: NEG
95675: PUSH
95676: LD_INT 0
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 5
95685: NEG
95686: PUSH
95687: LD_INT 1
95689: NEG
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 5
95697: NEG
95698: PUSH
95699: LD_INT 2
95701: NEG
95702: PUSH
95703: EMPTY
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 3
95709: NEG
95710: PUSH
95711: LD_INT 2
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: PUSH
95718: LD_INT 3
95720: NEG
95721: PUSH
95722: LD_INT 3
95724: NEG
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: PUSH
95730: LD_INT 3
95732: NEG
95733: PUSH
95734: LD_INT 4
95736: NEG
95737: PUSH
95738: EMPTY
95739: LIST
95740: LIST
95741: PUSH
95742: LD_INT 2
95744: NEG
95745: PUSH
95746: LD_INT 3
95748: NEG
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 2
95756: NEG
95757: PUSH
95758: LD_INT 2
95760: NEG
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: PUSH
95766: LD_INT 3
95768: NEG
95769: PUSH
95770: LD_INT 2
95772: NEG
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 4
95780: NEG
95781: PUSH
95782: LD_INT 3
95784: NEG
95785: PUSH
95786: EMPTY
95787: LIST
95788: LIST
95789: PUSH
95790: LD_INT 4
95792: NEG
95793: PUSH
95794: LD_INT 4
95796: NEG
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 2
95804: NEG
95805: PUSH
95806: LD_INT 4
95808: NEG
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: PUSH
95814: LD_INT 4
95816: NEG
95817: PUSH
95818: LD_INT 2
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 0
95828: PUSH
95829: LD_INT 4
95831: NEG
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: LD_INT 5
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 1
95850: PUSH
95851: LD_INT 4
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 1
95861: PUSH
95862: LD_INT 3
95864: NEG
95865: PUSH
95866: EMPTY
95867: LIST
95868: LIST
95869: PUSH
95870: LD_INT 0
95872: PUSH
95873: LD_INT 3
95875: NEG
95876: PUSH
95877: EMPTY
95878: LIST
95879: LIST
95880: PUSH
95881: LD_INT 1
95883: NEG
95884: PUSH
95885: LD_INT 4
95887: NEG
95888: PUSH
95889: EMPTY
95890: LIST
95891: LIST
95892: PUSH
95893: LD_INT 1
95895: NEG
95896: PUSH
95897: LD_INT 5
95899: NEG
95900: PUSH
95901: EMPTY
95902: LIST
95903: LIST
95904: PUSH
95905: LD_INT 2
95907: PUSH
95908: LD_INT 3
95910: NEG
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 2
95918: NEG
95919: PUSH
95920: LD_INT 5
95922: NEG
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95975: LD_ADDR_VAR 0 31
95979: PUSH
95980: LD_INT 0
95982: PUSH
95983: LD_INT 4
95985: PUSH
95986: EMPTY
95987: LIST
95988: LIST
95989: PUSH
95990: LD_INT 0
95992: PUSH
95993: LD_INT 3
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 1
96002: PUSH
96003: LD_INT 4
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 1
96012: PUSH
96013: LD_INT 5
96015: PUSH
96016: EMPTY
96017: LIST
96018: LIST
96019: PUSH
96020: LD_INT 0
96022: PUSH
96023: LD_INT 5
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: PUSH
96030: LD_INT 1
96032: NEG
96033: PUSH
96034: LD_INT 4
96036: PUSH
96037: EMPTY
96038: LIST
96039: LIST
96040: PUSH
96041: LD_INT 1
96043: NEG
96044: PUSH
96045: LD_INT 3
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 2
96054: PUSH
96055: LD_INT 5
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 2
96064: NEG
96065: PUSH
96066: LD_INT 3
96068: PUSH
96069: EMPTY
96070: LIST
96071: LIST
96072: PUSH
96073: LD_INT 3
96075: NEG
96076: PUSH
96077: LD_INT 0
96079: PUSH
96080: EMPTY
96081: LIST
96082: LIST
96083: PUSH
96084: LD_INT 3
96086: NEG
96087: PUSH
96088: LD_INT 1
96090: NEG
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 2
96098: NEG
96099: PUSH
96100: LD_INT 0
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 2
96109: NEG
96110: PUSH
96111: LD_INT 1
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 3
96120: NEG
96121: PUSH
96122: LD_INT 1
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 4
96131: NEG
96132: PUSH
96133: LD_INT 0
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 4
96142: NEG
96143: PUSH
96144: LD_INT 1
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 4
96154: NEG
96155: PUSH
96156: LD_INT 2
96158: NEG
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 2
96166: NEG
96167: PUSH
96168: LD_INT 2
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 4
96177: NEG
96178: PUSH
96179: LD_INT 4
96181: NEG
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: LD_INT 4
96189: NEG
96190: PUSH
96191: LD_INT 5
96193: NEG
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: PUSH
96199: LD_INT 3
96201: NEG
96202: PUSH
96203: LD_INT 4
96205: NEG
96206: PUSH
96207: EMPTY
96208: LIST
96209: LIST
96210: PUSH
96211: LD_INT 3
96213: NEG
96214: PUSH
96215: LD_INT 3
96217: NEG
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 4
96225: NEG
96226: PUSH
96227: LD_INT 3
96229: NEG
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PUSH
96235: LD_INT 5
96237: NEG
96238: PUSH
96239: LD_INT 4
96241: NEG
96242: PUSH
96243: EMPTY
96244: LIST
96245: LIST
96246: PUSH
96247: LD_INT 5
96249: NEG
96250: PUSH
96251: LD_INT 5
96253: NEG
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 3
96261: NEG
96262: PUSH
96263: LD_INT 5
96265: NEG
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: LD_INT 5
96273: NEG
96274: PUSH
96275: LD_INT 3
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 0
96285: PUSH
96286: LD_INT 3
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 0
96296: PUSH
96297: LD_INT 4
96299: NEG
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 1
96307: PUSH
96308: LD_INT 3
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: PUSH
96319: LD_INT 2
96321: NEG
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 0
96329: PUSH
96330: LD_INT 2
96332: NEG
96333: PUSH
96334: EMPTY
96335: LIST
96336: LIST
96337: PUSH
96338: LD_INT 1
96340: NEG
96341: PUSH
96342: LD_INT 3
96344: NEG
96345: PUSH
96346: EMPTY
96347: LIST
96348: LIST
96349: PUSH
96350: LD_INT 1
96352: NEG
96353: PUSH
96354: LD_INT 4
96356: NEG
96357: PUSH
96358: EMPTY
96359: LIST
96360: LIST
96361: PUSH
96362: LD_INT 2
96364: PUSH
96365: LD_INT 2
96367: NEG
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 2
96375: NEG
96376: PUSH
96377: LD_INT 4
96379: NEG
96380: PUSH
96381: EMPTY
96382: LIST
96383: LIST
96384: PUSH
96385: LD_INT 4
96387: PUSH
96388: LD_INT 0
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 4
96397: PUSH
96398: LD_INT 1
96400: NEG
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 5
96408: PUSH
96409: LD_INT 0
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 5
96418: PUSH
96419: LD_INT 1
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 4
96428: PUSH
96429: LD_INT 1
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: LD_INT 3
96438: PUSH
96439: LD_INT 0
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 3
96448: PUSH
96449: LD_INT 1
96451: NEG
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PUSH
96457: LD_INT 3
96459: PUSH
96460: LD_INT 2
96462: NEG
96463: PUSH
96464: EMPTY
96465: LIST
96466: LIST
96467: PUSH
96468: LD_INT 5
96470: PUSH
96471: LD_INT 2
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96525: LD_ADDR_VAR 0 32
96529: PUSH
96530: LD_INT 4
96532: NEG
96533: PUSH
96534: LD_INT 0
96536: PUSH
96537: EMPTY
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 4
96543: NEG
96544: PUSH
96545: LD_INT 1
96547: NEG
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 3
96555: NEG
96556: PUSH
96557: LD_INT 0
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 3
96566: NEG
96567: PUSH
96568: LD_INT 1
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 4
96577: NEG
96578: PUSH
96579: LD_INT 1
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 5
96588: NEG
96589: PUSH
96590: LD_INT 0
96592: PUSH
96593: EMPTY
96594: LIST
96595: LIST
96596: PUSH
96597: LD_INT 5
96599: NEG
96600: PUSH
96601: LD_INT 1
96603: NEG
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: LD_INT 5
96611: NEG
96612: PUSH
96613: LD_INT 2
96615: NEG
96616: PUSH
96617: EMPTY
96618: LIST
96619: LIST
96620: PUSH
96621: LD_INT 3
96623: NEG
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: EMPTY
96629: LIST
96630: LIST
96631: PUSH
96632: LD_INT 3
96634: NEG
96635: PUSH
96636: LD_INT 3
96638: NEG
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 3
96646: NEG
96647: PUSH
96648: LD_INT 4
96650: NEG
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: LD_INT 2
96658: NEG
96659: PUSH
96660: LD_INT 3
96662: NEG
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 2
96670: NEG
96671: PUSH
96672: LD_INT 2
96674: NEG
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: LD_INT 3
96682: NEG
96683: PUSH
96684: LD_INT 2
96686: NEG
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 4
96694: NEG
96695: PUSH
96696: LD_INT 3
96698: NEG
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: PUSH
96704: LD_INT 4
96706: NEG
96707: PUSH
96708: LD_INT 4
96710: NEG
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: PUSH
96716: LD_INT 2
96718: NEG
96719: PUSH
96720: LD_INT 4
96722: NEG
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: PUSH
96728: LD_INT 4
96730: NEG
96731: PUSH
96732: LD_INT 2
96734: NEG
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 0
96742: PUSH
96743: LD_INT 4
96745: NEG
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 0
96753: PUSH
96754: LD_INT 5
96756: NEG
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: PUSH
96762: LD_INT 1
96764: PUSH
96765: LD_INT 4
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 1
96775: PUSH
96776: LD_INT 3
96778: NEG
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 0
96786: PUSH
96787: LD_INT 3
96789: NEG
96790: PUSH
96791: EMPTY
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 1
96797: NEG
96798: PUSH
96799: LD_INT 4
96801: NEG
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: LD_INT 1
96809: NEG
96810: PUSH
96811: LD_INT 5
96813: NEG
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: LD_INT 2
96821: PUSH
96822: LD_INT 3
96824: NEG
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PUSH
96830: LD_INT 2
96832: NEG
96833: PUSH
96834: LD_INT 5
96836: NEG
96837: PUSH
96838: EMPTY
96839: LIST
96840: LIST
96841: PUSH
96842: LD_INT 3
96844: PUSH
96845: LD_INT 0
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: PUSH
96852: LD_INT 3
96854: PUSH
96855: LD_INT 1
96857: NEG
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 4
96865: PUSH
96866: LD_INT 0
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 4
96875: PUSH
96876: LD_INT 1
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: PUSH
96883: LD_INT 3
96885: PUSH
96886: LD_INT 1
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: PUSH
96893: LD_INT 2
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 2
96905: PUSH
96906: LD_INT 1
96908: NEG
96909: PUSH
96910: EMPTY
96911: LIST
96912: LIST
96913: PUSH
96914: LD_INT 2
96916: PUSH
96917: LD_INT 2
96919: NEG
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: LD_INT 4
96927: PUSH
96928: LD_INT 2
96930: PUSH
96931: EMPTY
96932: LIST
96933: LIST
96934: PUSH
96935: LD_INT 4
96937: PUSH
96938: LD_INT 4
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PUSH
96945: LD_INT 4
96947: PUSH
96948: LD_INT 3
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 5
96957: PUSH
96958: LD_INT 4
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 5
96967: PUSH
96968: LD_INT 5
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 4
96977: PUSH
96978: LD_INT 5
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: PUSH
96985: LD_INT 3
96987: PUSH
96988: LD_INT 4
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: PUSH
96995: LD_INT 3
96997: PUSH
96998: LD_INT 3
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: PUSH
97005: LD_INT 5
97007: PUSH
97008: LD_INT 3
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 3
97017: PUSH
97018: LD_INT 5
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: EMPTY
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97072: LD_ADDR_VAR 0 33
97076: PUSH
97077: LD_INT 4
97079: NEG
97080: PUSH
97081: LD_INT 4
97083: NEG
97084: PUSH
97085: EMPTY
97086: LIST
97087: LIST
97088: PUSH
97089: LD_INT 4
97091: NEG
97092: PUSH
97093: LD_INT 5
97095: NEG
97096: PUSH
97097: EMPTY
97098: LIST
97099: LIST
97100: PUSH
97101: LD_INT 3
97103: NEG
97104: PUSH
97105: LD_INT 4
97107: NEG
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: PUSH
97113: LD_INT 3
97115: NEG
97116: PUSH
97117: LD_INT 3
97119: NEG
97120: PUSH
97121: EMPTY
97122: LIST
97123: LIST
97124: PUSH
97125: LD_INT 4
97127: NEG
97128: PUSH
97129: LD_INT 3
97131: NEG
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 5
97139: NEG
97140: PUSH
97141: LD_INT 4
97143: NEG
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: LD_INT 5
97151: NEG
97152: PUSH
97153: LD_INT 5
97155: NEG
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: PUSH
97161: LD_INT 3
97163: NEG
97164: PUSH
97165: LD_INT 5
97167: NEG
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: PUSH
97173: LD_INT 5
97175: NEG
97176: PUSH
97177: LD_INT 3
97179: NEG
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 0
97187: PUSH
97188: LD_INT 3
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 0
97198: PUSH
97199: LD_INT 4
97201: NEG
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 1
97209: PUSH
97210: LD_INT 3
97212: NEG
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 1
97220: PUSH
97221: LD_INT 2
97223: NEG
97224: PUSH
97225: EMPTY
97226: LIST
97227: LIST
97228: PUSH
97229: LD_INT 0
97231: PUSH
97232: LD_INT 2
97234: NEG
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 1
97242: NEG
97243: PUSH
97244: LD_INT 3
97246: NEG
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: PUSH
97252: LD_INT 1
97254: NEG
97255: PUSH
97256: LD_INT 4
97258: NEG
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PUSH
97264: LD_INT 2
97266: PUSH
97267: LD_INT 2
97269: NEG
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 2
97277: NEG
97278: PUSH
97279: LD_INT 4
97281: NEG
97282: PUSH
97283: EMPTY
97284: LIST
97285: LIST
97286: PUSH
97287: LD_INT 4
97289: PUSH
97290: LD_INT 0
97292: PUSH
97293: EMPTY
97294: LIST
97295: LIST
97296: PUSH
97297: LD_INT 4
97299: PUSH
97300: LD_INT 1
97302: NEG
97303: PUSH
97304: EMPTY
97305: LIST
97306: LIST
97307: PUSH
97308: LD_INT 5
97310: PUSH
97311: LD_INT 0
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 5
97320: PUSH
97321: LD_INT 1
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: LD_INT 4
97330: PUSH
97331: LD_INT 1
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 3
97340: PUSH
97341: LD_INT 0
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 3
97350: PUSH
97351: LD_INT 1
97353: NEG
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 3
97361: PUSH
97362: LD_INT 2
97364: NEG
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 5
97372: PUSH
97373: LD_INT 2
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: PUSH
97380: LD_INT 3
97382: PUSH
97383: LD_INT 3
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 3
97392: PUSH
97393: LD_INT 2
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PUSH
97400: LD_INT 4
97402: PUSH
97403: LD_INT 3
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: PUSH
97410: LD_INT 4
97412: PUSH
97413: LD_INT 4
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: PUSH
97420: LD_INT 3
97422: PUSH
97423: LD_INT 4
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 2
97432: PUSH
97433: LD_INT 3
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 2
97442: PUSH
97443: LD_INT 2
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 4
97452: PUSH
97453: LD_INT 2
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: LD_INT 2
97462: PUSH
97463: LD_INT 4
97465: PUSH
97466: EMPTY
97467: LIST
97468: LIST
97469: PUSH
97470: LD_INT 0
97472: PUSH
97473: LD_INT 4
97475: PUSH
97476: EMPTY
97477: LIST
97478: LIST
97479: PUSH
97480: LD_INT 0
97482: PUSH
97483: LD_INT 3
97485: PUSH
97486: EMPTY
97487: LIST
97488: LIST
97489: PUSH
97490: LD_INT 1
97492: PUSH
97493: LD_INT 4
97495: PUSH
97496: EMPTY
97497: LIST
97498: LIST
97499: PUSH
97500: LD_INT 1
97502: PUSH
97503: LD_INT 5
97505: PUSH
97506: EMPTY
97507: LIST
97508: LIST
97509: PUSH
97510: LD_INT 0
97512: PUSH
97513: LD_INT 5
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 1
97522: NEG
97523: PUSH
97524: LD_INT 4
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 1
97533: NEG
97534: PUSH
97535: LD_INT 3
97537: PUSH
97538: EMPTY
97539: LIST
97540: LIST
97541: PUSH
97542: LD_INT 2
97544: PUSH
97545: LD_INT 5
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: PUSH
97552: LD_INT 2
97554: NEG
97555: PUSH
97556: LD_INT 3
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: PUSH
97563: EMPTY
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: LIST
97605: LIST
97606: LIST
97607: LIST
97608: LIST
97609: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97610: LD_ADDR_VAR 0 34
97614: PUSH
97615: LD_INT 0
97617: PUSH
97618: LD_INT 4
97620: NEG
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: PUSH
97626: LD_INT 0
97628: PUSH
97629: LD_INT 5
97631: NEG
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: PUSH
97637: LD_INT 1
97639: PUSH
97640: LD_INT 4
97642: NEG
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 1
97650: PUSH
97651: LD_INT 3
97653: NEG
97654: PUSH
97655: EMPTY
97656: LIST
97657: LIST
97658: PUSH
97659: LD_INT 0
97661: PUSH
97662: LD_INT 3
97664: NEG
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: PUSH
97670: LD_INT 1
97672: NEG
97673: PUSH
97674: LD_INT 4
97676: NEG
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 1
97684: NEG
97685: PUSH
97686: LD_INT 5
97688: NEG
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: PUSH
97694: LD_INT 2
97696: PUSH
97697: LD_INT 3
97699: NEG
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: PUSH
97705: LD_INT 2
97707: NEG
97708: PUSH
97709: LD_INT 5
97711: NEG
97712: PUSH
97713: EMPTY
97714: LIST
97715: LIST
97716: PUSH
97717: LD_INT 3
97719: PUSH
97720: LD_INT 0
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: PUSH
97727: LD_INT 3
97729: PUSH
97730: LD_INT 1
97732: NEG
97733: PUSH
97734: EMPTY
97735: LIST
97736: LIST
97737: PUSH
97738: LD_INT 4
97740: PUSH
97741: LD_INT 0
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: PUSH
97748: LD_INT 4
97750: PUSH
97751: LD_INT 1
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 3
97760: PUSH
97761: LD_INT 1
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 2
97770: PUSH
97771: LD_INT 0
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 2
97780: PUSH
97781: LD_INT 1
97783: NEG
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: LD_INT 2
97791: PUSH
97792: LD_INT 2
97794: NEG
97795: PUSH
97796: EMPTY
97797: LIST
97798: LIST
97799: PUSH
97800: LD_INT 4
97802: PUSH
97803: LD_INT 2
97805: PUSH
97806: EMPTY
97807: LIST
97808: LIST
97809: PUSH
97810: LD_INT 4
97812: PUSH
97813: LD_INT 4
97815: PUSH
97816: EMPTY
97817: LIST
97818: LIST
97819: PUSH
97820: LD_INT 4
97822: PUSH
97823: LD_INT 3
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 5
97832: PUSH
97833: LD_INT 4
97835: PUSH
97836: EMPTY
97837: LIST
97838: LIST
97839: PUSH
97840: LD_INT 5
97842: PUSH
97843: LD_INT 5
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: PUSH
97850: LD_INT 4
97852: PUSH
97853: LD_INT 5
97855: PUSH
97856: EMPTY
97857: LIST
97858: LIST
97859: PUSH
97860: LD_INT 3
97862: PUSH
97863: LD_INT 4
97865: PUSH
97866: EMPTY
97867: LIST
97868: LIST
97869: PUSH
97870: LD_INT 3
97872: PUSH
97873: LD_INT 3
97875: PUSH
97876: EMPTY
97877: LIST
97878: LIST
97879: PUSH
97880: LD_INT 5
97882: PUSH
97883: LD_INT 3
97885: PUSH
97886: EMPTY
97887: LIST
97888: LIST
97889: PUSH
97890: LD_INT 3
97892: PUSH
97893: LD_INT 5
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: PUSH
97900: LD_INT 0
97902: PUSH
97903: LD_INT 3
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 0
97912: PUSH
97913: LD_INT 2
97915: PUSH
97916: EMPTY
97917: LIST
97918: LIST
97919: PUSH
97920: LD_INT 1
97922: PUSH
97923: LD_INT 3
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 1
97932: PUSH
97933: LD_INT 4
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: PUSH
97940: LD_INT 0
97942: PUSH
97943: LD_INT 4
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 1
97952: NEG
97953: PUSH
97954: LD_INT 3
97956: PUSH
97957: EMPTY
97958: LIST
97959: LIST
97960: PUSH
97961: LD_INT 1
97963: NEG
97964: PUSH
97965: LD_INT 2
97967: PUSH
97968: EMPTY
97969: LIST
97970: LIST
97971: PUSH
97972: LD_INT 2
97974: PUSH
97975: LD_INT 4
97977: PUSH
97978: EMPTY
97979: LIST
97980: LIST
97981: PUSH
97982: LD_INT 2
97984: NEG
97985: PUSH
97986: LD_INT 2
97988: PUSH
97989: EMPTY
97990: LIST
97991: LIST
97992: PUSH
97993: LD_INT 4
97995: NEG
97996: PUSH
97997: LD_INT 0
97999: PUSH
98000: EMPTY
98001: LIST
98002: LIST
98003: PUSH
98004: LD_INT 4
98006: NEG
98007: PUSH
98008: LD_INT 1
98010: NEG
98011: PUSH
98012: EMPTY
98013: LIST
98014: LIST
98015: PUSH
98016: LD_INT 3
98018: NEG
98019: PUSH
98020: LD_INT 0
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: PUSH
98027: LD_INT 3
98029: NEG
98030: PUSH
98031: LD_INT 1
98033: PUSH
98034: EMPTY
98035: LIST
98036: LIST
98037: PUSH
98038: LD_INT 4
98040: NEG
98041: PUSH
98042: LD_INT 1
98044: PUSH
98045: EMPTY
98046: LIST
98047: LIST
98048: PUSH
98049: LD_INT 5
98051: NEG
98052: PUSH
98053: LD_INT 0
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 5
98062: NEG
98063: PUSH
98064: LD_INT 1
98066: NEG
98067: PUSH
98068: EMPTY
98069: LIST
98070: LIST
98071: PUSH
98072: LD_INT 5
98074: NEG
98075: PUSH
98076: LD_INT 2
98078: NEG
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: PUSH
98084: LD_INT 3
98086: NEG
98087: PUSH
98088: LD_INT 2
98090: PUSH
98091: EMPTY
98092: LIST
98093: LIST
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: ST_TO_ADDR
// end ; end ;
98142: GO 98145
98144: POP
// case btype of b_depot , b_warehouse :
98145: LD_VAR 0 1
98149: PUSH
98150: LD_INT 0
98152: DOUBLE
98153: EQUAL
98154: IFTRUE 98164
98156: LD_INT 1
98158: DOUBLE
98159: EQUAL
98160: IFTRUE 98164
98162: GO 98365
98164: POP
// case nation of nation_american :
98165: LD_VAR 0 5
98169: PUSH
98170: LD_INT 1
98172: DOUBLE
98173: EQUAL
98174: IFTRUE 98178
98176: GO 98234
98178: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
98179: LD_ADDR_VAR 0 9
98183: PUSH
98184: LD_VAR 0 11
98188: PUSH
98189: LD_VAR 0 12
98193: PUSH
98194: LD_VAR 0 13
98198: PUSH
98199: LD_VAR 0 14
98203: PUSH
98204: LD_VAR 0 15
98208: PUSH
98209: LD_VAR 0 16
98213: PUSH
98214: EMPTY
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: PUSH
98222: LD_VAR 0 4
98226: PUSH
98227: LD_INT 1
98229: PLUS
98230: ARRAY
98231: ST_TO_ADDR
98232: GO 98363
98234: LD_INT 2
98236: DOUBLE
98237: EQUAL
98238: IFTRUE 98242
98240: GO 98298
98242: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98243: LD_ADDR_VAR 0 9
98247: PUSH
98248: LD_VAR 0 17
98252: PUSH
98253: LD_VAR 0 18
98257: PUSH
98258: LD_VAR 0 19
98262: PUSH
98263: LD_VAR 0 20
98267: PUSH
98268: LD_VAR 0 21
98272: PUSH
98273: LD_VAR 0 22
98277: PUSH
98278: EMPTY
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: PUSH
98286: LD_VAR 0 4
98290: PUSH
98291: LD_INT 1
98293: PLUS
98294: ARRAY
98295: ST_TO_ADDR
98296: GO 98363
98298: LD_INT 3
98300: DOUBLE
98301: EQUAL
98302: IFTRUE 98306
98304: GO 98362
98306: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98307: LD_ADDR_VAR 0 9
98311: PUSH
98312: LD_VAR 0 23
98316: PUSH
98317: LD_VAR 0 24
98321: PUSH
98322: LD_VAR 0 25
98326: PUSH
98327: LD_VAR 0 26
98331: PUSH
98332: LD_VAR 0 27
98336: PUSH
98337: LD_VAR 0 28
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: PUSH
98350: LD_VAR 0 4
98354: PUSH
98355: LD_INT 1
98357: PLUS
98358: ARRAY
98359: ST_TO_ADDR
98360: GO 98363
98362: POP
98363: GO 98918
98365: LD_INT 2
98367: DOUBLE
98368: EQUAL
98369: IFTRUE 98379
98371: LD_INT 3
98373: DOUBLE
98374: EQUAL
98375: IFTRUE 98379
98377: GO 98435
98379: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98380: LD_ADDR_VAR 0 9
98384: PUSH
98385: LD_VAR 0 29
98389: PUSH
98390: LD_VAR 0 30
98394: PUSH
98395: LD_VAR 0 31
98399: PUSH
98400: LD_VAR 0 32
98404: PUSH
98405: LD_VAR 0 33
98409: PUSH
98410: LD_VAR 0 34
98414: PUSH
98415: EMPTY
98416: LIST
98417: LIST
98418: LIST
98419: LIST
98420: LIST
98421: LIST
98422: PUSH
98423: LD_VAR 0 4
98427: PUSH
98428: LD_INT 1
98430: PLUS
98431: ARRAY
98432: ST_TO_ADDR
98433: GO 98918
98435: LD_INT 16
98437: DOUBLE
98438: EQUAL
98439: IFTRUE 98497
98441: LD_INT 17
98443: DOUBLE
98444: EQUAL
98445: IFTRUE 98497
98447: LD_INT 18
98449: DOUBLE
98450: EQUAL
98451: IFTRUE 98497
98453: LD_INT 19
98455: DOUBLE
98456: EQUAL
98457: IFTRUE 98497
98459: LD_INT 22
98461: DOUBLE
98462: EQUAL
98463: IFTRUE 98497
98465: LD_INT 20
98467: DOUBLE
98468: EQUAL
98469: IFTRUE 98497
98471: LD_INT 21
98473: DOUBLE
98474: EQUAL
98475: IFTRUE 98497
98477: LD_INT 23
98479: DOUBLE
98480: EQUAL
98481: IFTRUE 98497
98483: LD_INT 24
98485: DOUBLE
98486: EQUAL
98487: IFTRUE 98497
98489: LD_INT 25
98491: DOUBLE
98492: EQUAL
98493: IFTRUE 98497
98495: GO 98553
98497: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98498: LD_ADDR_VAR 0 9
98502: PUSH
98503: LD_VAR 0 35
98507: PUSH
98508: LD_VAR 0 36
98512: PUSH
98513: LD_VAR 0 37
98517: PUSH
98518: LD_VAR 0 38
98522: PUSH
98523: LD_VAR 0 39
98527: PUSH
98528: LD_VAR 0 40
98532: PUSH
98533: EMPTY
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: PUSH
98541: LD_VAR 0 4
98545: PUSH
98546: LD_INT 1
98548: PLUS
98549: ARRAY
98550: ST_TO_ADDR
98551: GO 98918
98553: LD_INT 6
98555: DOUBLE
98556: EQUAL
98557: IFTRUE 98609
98559: LD_INT 7
98561: DOUBLE
98562: EQUAL
98563: IFTRUE 98609
98565: LD_INT 8
98567: DOUBLE
98568: EQUAL
98569: IFTRUE 98609
98571: LD_INT 13
98573: DOUBLE
98574: EQUAL
98575: IFTRUE 98609
98577: LD_INT 12
98579: DOUBLE
98580: EQUAL
98581: IFTRUE 98609
98583: LD_INT 15
98585: DOUBLE
98586: EQUAL
98587: IFTRUE 98609
98589: LD_INT 11
98591: DOUBLE
98592: EQUAL
98593: IFTRUE 98609
98595: LD_INT 14
98597: DOUBLE
98598: EQUAL
98599: IFTRUE 98609
98601: LD_INT 10
98603: DOUBLE
98604: EQUAL
98605: IFTRUE 98609
98607: GO 98665
98609: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98610: LD_ADDR_VAR 0 9
98614: PUSH
98615: LD_VAR 0 41
98619: PUSH
98620: LD_VAR 0 42
98624: PUSH
98625: LD_VAR 0 43
98629: PUSH
98630: LD_VAR 0 44
98634: PUSH
98635: LD_VAR 0 45
98639: PUSH
98640: LD_VAR 0 46
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: PUSH
98653: LD_VAR 0 4
98657: PUSH
98658: LD_INT 1
98660: PLUS
98661: ARRAY
98662: ST_TO_ADDR
98663: GO 98918
98665: LD_INT 36
98667: DOUBLE
98668: EQUAL
98669: IFTRUE 98673
98671: GO 98729
98673: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98674: LD_ADDR_VAR 0 9
98678: PUSH
98679: LD_VAR 0 47
98683: PUSH
98684: LD_VAR 0 48
98688: PUSH
98689: LD_VAR 0 49
98693: PUSH
98694: LD_VAR 0 50
98698: PUSH
98699: LD_VAR 0 51
98703: PUSH
98704: LD_VAR 0 52
98708: PUSH
98709: EMPTY
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: PUSH
98717: LD_VAR 0 4
98721: PUSH
98722: LD_INT 1
98724: PLUS
98725: ARRAY
98726: ST_TO_ADDR
98727: GO 98918
98729: LD_INT 4
98731: DOUBLE
98732: EQUAL
98733: IFTRUE 98755
98735: LD_INT 5
98737: DOUBLE
98738: EQUAL
98739: IFTRUE 98755
98741: LD_INT 34
98743: DOUBLE
98744: EQUAL
98745: IFTRUE 98755
98747: LD_INT 37
98749: DOUBLE
98750: EQUAL
98751: IFTRUE 98755
98753: GO 98811
98755: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98756: LD_ADDR_VAR 0 9
98760: PUSH
98761: LD_VAR 0 53
98765: PUSH
98766: LD_VAR 0 54
98770: PUSH
98771: LD_VAR 0 55
98775: PUSH
98776: LD_VAR 0 56
98780: PUSH
98781: LD_VAR 0 57
98785: PUSH
98786: LD_VAR 0 58
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: PUSH
98799: LD_VAR 0 4
98803: PUSH
98804: LD_INT 1
98806: PLUS
98807: ARRAY
98808: ST_TO_ADDR
98809: GO 98918
98811: LD_INT 31
98813: DOUBLE
98814: EQUAL
98815: IFTRUE 98861
98817: LD_INT 32
98819: DOUBLE
98820: EQUAL
98821: IFTRUE 98861
98823: LD_INT 33
98825: DOUBLE
98826: EQUAL
98827: IFTRUE 98861
98829: LD_INT 27
98831: DOUBLE
98832: EQUAL
98833: IFTRUE 98861
98835: LD_INT 26
98837: DOUBLE
98838: EQUAL
98839: IFTRUE 98861
98841: LD_INT 28
98843: DOUBLE
98844: EQUAL
98845: IFTRUE 98861
98847: LD_INT 29
98849: DOUBLE
98850: EQUAL
98851: IFTRUE 98861
98853: LD_INT 30
98855: DOUBLE
98856: EQUAL
98857: IFTRUE 98861
98859: GO 98917
98861: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98862: LD_ADDR_VAR 0 9
98866: PUSH
98867: LD_VAR 0 59
98871: PUSH
98872: LD_VAR 0 60
98876: PUSH
98877: LD_VAR 0 61
98881: PUSH
98882: LD_VAR 0 62
98886: PUSH
98887: LD_VAR 0 63
98891: PUSH
98892: LD_VAR 0 64
98896: PUSH
98897: EMPTY
98898: LIST
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: PUSH
98905: LD_VAR 0 4
98909: PUSH
98910: LD_INT 1
98912: PLUS
98913: ARRAY
98914: ST_TO_ADDR
98915: GO 98918
98917: POP
// temp_list2 = [ ] ;
98918: LD_ADDR_VAR 0 10
98922: PUSH
98923: EMPTY
98924: ST_TO_ADDR
// for i in temp_list do
98925: LD_ADDR_VAR 0 8
98929: PUSH
98930: LD_VAR 0 9
98934: PUSH
98935: FOR_IN
98936: IFFALSE 98988
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98938: LD_ADDR_VAR 0 10
98942: PUSH
98943: LD_VAR 0 10
98947: PUSH
98948: LD_VAR 0 8
98952: PUSH
98953: LD_INT 1
98955: ARRAY
98956: PUSH
98957: LD_VAR 0 2
98961: PLUS
98962: PUSH
98963: LD_VAR 0 8
98967: PUSH
98968: LD_INT 2
98970: ARRAY
98971: PUSH
98972: LD_VAR 0 3
98976: PLUS
98977: PUSH
98978: EMPTY
98979: LIST
98980: LIST
98981: PUSH
98982: EMPTY
98983: LIST
98984: ADD
98985: ST_TO_ADDR
98986: GO 98935
98988: POP
98989: POP
// result = temp_list2 ;
98990: LD_ADDR_VAR 0 7
98994: PUSH
98995: LD_VAR 0 10
98999: ST_TO_ADDR
// end ;
99000: LD_VAR 0 7
99004: RET
// export function EnemyInRange ( unit , dist ) ; begin
99005: LD_INT 0
99007: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
99008: LD_ADDR_VAR 0 3
99012: PUSH
99013: LD_VAR 0 1
99017: PPUSH
99018: CALL_OW 255
99022: PPUSH
99023: LD_VAR 0 1
99027: PPUSH
99028: CALL_OW 250
99032: PPUSH
99033: LD_VAR 0 1
99037: PPUSH
99038: CALL_OW 251
99042: PPUSH
99043: LD_VAR 0 2
99047: PPUSH
99048: CALL 73109 0 4
99052: PUSH
99053: LD_INT 4
99055: ARRAY
99056: ST_TO_ADDR
// end ;
99057: LD_VAR 0 3
99061: RET
// export function PlayerSeeMe ( unit ) ; begin
99062: LD_INT 0
99064: PPUSH
// result := See ( your_side , unit ) ;
99065: LD_ADDR_VAR 0 2
99069: PUSH
99070: LD_OWVAR 2
99074: PPUSH
99075: LD_VAR 0 1
99079: PPUSH
99080: CALL_OW 292
99084: ST_TO_ADDR
// end ;
99085: LD_VAR 0 2
99089: RET
// export function ReverseDir ( unit ) ; begin
99090: LD_INT 0
99092: PPUSH
// if not unit then
99093: LD_VAR 0 1
99097: NOT
99098: IFFALSE 99102
// exit ;
99100: GO 99125
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99102: LD_ADDR_VAR 0 2
99106: PUSH
99107: LD_VAR 0 1
99111: PPUSH
99112: CALL_OW 254
99116: PUSH
99117: LD_INT 3
99119: PLUS
99120: PUSH
99121: LD_INT 6
99123: MOD
99124: ST_TO_ADDR
// end ;
99125: LD_VAR 0 2
99129: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
99130: LD_INT 0
99132: PPUSH
99133: PPUSH
99134: PPUSH
99135: PPUSH
99136: PPUSH
// if not hexes then
99137: LD_VAR 0 2
99141: NOT
99142: IFFALSE 99146
// exit ;
99144: GO 99294
// dist := 9999 ;
99146: LD_ADDR_VAR 0 5
99150: PUSH
99151: LD_INT 9999
99153: ST_TO_ADDR
// for i = 1 to hexes do
99154: LD_ADDR_VAR 0 4
99158: PUSH
99159: DOUBLE
99160: LD_INT 1
99162: DEC
99163: ST_TO_ADDR
99164: LD_VAR 0 2
99168: PUSH
99169: FOR_TO
99170: IFFALSE 99282
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
99172: LD_VAR 0 1
99176: PPUSH
99177: LD_VAR 0 2
99181: PUSH
99182: LD_VAR 0 4
99186: ARRAY
99187: PUSH
99188: LD_INT 1
99190: ARRAY
99191: PPUSH
99192: LD_VAR 0 2
99196: PUSH
99197: LD_VAR 0 4
99201: ARRAY
99202: PUSH
99203: LD_INT 2
99205: ARRAY
99206: PPUSH
99207: CALL_OW 297
99211: PUSH
99212: LD_VAR 0 5
99216: LESS
99217: IFFALSE 99280
// begin hex := hexes [ i ] ;
99219: LD_ADDR_VAR 0 7
99223: PUSH
99224: LD_VAR 0 2
99228: PUSH
99229: LD_VAR 0 4
99233: ARRAY
99234: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99235: LD_ADDR_VAR 0 5
99239: PUSH
99240: LD_VAR 0 1
99244: PPUSH
99245: LD_VAR 0 2
99249: PUSH
99250: LD_VAR 0 4
99254: ARRAY
99255: PUSH
99256: LD_INT 1
99258: ARRAY
99259: PPUSH
99260: LD_VAR 0 2
99264: PUSH
99265: LD_VAR 0 4
99269: ARRAY
99270: PUSH
99271: LD_INT 2
99273: ARRAY
99274: PPUSH
99275: CALL_OW 297
99279: ST_TO_ADDR
// end ; end ;
99280: GO 99169
99282: POP
99283: POP
// result := hex ;
99284: LD_ADDR_VAR 0 3
99288: PUSH
99289: LD_VAR 0 7
99293: ST_TO_ADDR
// end ;
99294: LD_VAR 0 3
99298: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99299: LD_INT 0
99301: PPUSH
99302: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99303: LD_VAR 0 1
99307: NOT
99308: PUSH
99309: LD_VAR 0 1
99313: PUSH
99314: LD_INT 21
99316: PUSH
99317: LD_INT 2
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_INT 23
99326: PUSH
99327: LD_INT 2
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PUSH
99334: EMPTY
99335: LIST
99336: LIST
99337: PPUSH
99338: CALL_OW 69
99342: IN
99343: NOT
99344: OR
99345: IFFALSE 99349
// exit ;
99347: GO 99396
// for i = 1 to 3 do
99349: LD_ADDR_VAR 0 3
99353: PUSH
99354: DOUBLE
99355: LD_INT 1
99357: DEC
99358: ST_TO_ADDR
99359: LD_INT 3
99361: PUSH
99362: FOR_TO
99363: IFFALSE 99394
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99365: LD_VAR 0 1
99369: PPUSH
99370: CALL_OW 250
99374: PPUSH
99375: LD_VAR 0 1
99379: PPUSH
99380: CALL_OW 251
99384: PPUSH
99385: LD_INT 1
99387: PPUSH
99388: CALL_OW 453
99392: GO 99362
99394: POP
99395: POP
// end ;
99396: LD_VAR 0 2
99400: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99401: LD_INT 0
99403: PPUSH
99404: PPUSH
99405: PPUSH
99406: PPUSH
99407: PPUSH
99408: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99409: LD_VAR 0 1
99413: NOT
99414: PUSH
99415: LD_VAR 0 2
99419: NOT
99420: OR
99421: PUSH
99422: LD_VAR 0 1
99426: PPUSH
99427: CALL_OW 314
99431: OR
99432: IFFALSE 99436
// exit ;
99434: GO 99877
// x := GetX ( enemy_unit ) ;
99436: LD_ADDR_VAR 0 7
99440: PUSH
99441: LD_VAR 0 2
99445: PPUSH
99446: CALL_OW 250
99450: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99451: LD_ADDR_VAR 0 8
99455: PUSH
99456: LD_VAR 0 2
99460: PPUSH
99461: CALL_OW 251
99465: ST_TO_ADDR
// if not x or not y then
99466: LD_VAR 0 7
99470: NOT
99471: PUSH
99472: LD_VAR 0 8
99476: NOT
99477: OR
99478: IFFALSE 99482
// exit ;
99480: GO 99877
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99482: LD_ADDR_VAR 0 6
99486: PUSH
99487: LD_VAR 0 7
99491: PPUSH
99492: LD_INT 0
99494: PPUSH
99495: LD_INT 4
99497: PPUSH
99498: CALL_OW 272
99502: PUSH
99503: LD_VAR 0 8
99507: PPUSH
99508: LD_INT 0
99510: PPUSH
99511: LD_INT 4
99513: PPUSH
99514: CALL_OW 273
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: PUSH
99523: LD_VAR 0 7
99527: PPUSH
99528: LD_INT 1
99530: PPUSH
99531: LD_INT 4
99533: PPUSH
99534: CALL_OW 272
99538: PUSH
99539: LD_VAR 0 8
99543: PPUSH
99544: LD_INT 1
99546: PPUSH
99547: LD_INT 4
99549: PPUSH
99550: CALL_OW 273
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: PUSH
99559: LD_VAR 0 7
99563: PPUSH
99564: LD_INT 2
99566: PPUSH
99567: LD_INT 4
99569: PPUSH
99570: CALL_OW 272
99574: PUSH
99575: LD_VAR 0 8
99579: PPUSH
99580: LD_INT 2
99582: PPUSH
99583: LD_INT 4
99585: PPUSH
99586: CALL_OW 273
99590: PUSH
99591: EMPTY
99592: LIST
99593: LIST
99594: PUSH
99595: LD_VAR 0 7
99599: PPUSH
99600: LD_INT 3
99602: PPUSH
99603: LD_INT 4
99605: PPUSH
99606: CALL_OW 272
99610: PUSH
99611: LD_VAR 0 8
99615: PPUSH
99616: LD_INT 3
99618: PPUSH
99619: LD_INT 4
99621: PPUSH
99622: CALL_OW 273
99626: PUSH
99627: EMPTY
99628: LIST
99629: LIST
99630: PUSH
99631: LD_VAR 0 7
99635: PPUSH
99636: LD_INT 4
99638: PPUSH
99639: LD_INT 4
99641: PPUSH
99642: CALL_OW 272
99646: PUSH
99647: LD_VAR 0 8
99651: PPUSH
99652: LD_INT 4
99654: PPUSH
99655: LD_INT 4
99657: PPUSH
99658: CALL_OW 273
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: PUSH
99667: LD_VAR 0 7
99671: PPUSH
99672: LD_INT 5
99674: PPUSH
99675: LD_INT 4
99677: PPUSH
99678: CALL_OW 272
99682: PUSH
99683: LD_VAR 0 8
99687: PPUSH
99688: LD_INT 5
99690: PPUSH
99691: LD_INT 4
99693: PPUSH
99694: CALL_OW 273
99698: PUSH
99699: EMPTY
99700: LIST
99701: LIST
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: ST_TO_ADDR
// for i = tmp downto 1 do
99711: LD_ADDR_VAR 0 4
99715: PUSH
99716: DOUBLE
99717: LD_VAR 0 6
99721: INC
99722: ST_TO_ADDR
99723: LD_INT 1
99725: PUSH
99726: FOR_DOWNTO
99727: IFFALSE 99828
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99729: LD_VAR 0 6
99733: PUSH
99734: LD_VAR 0 4
99738: ARRAY
99739: PUSH
99740: LD_INT 1
99742: ARRAY
99743: PPUSH
99744: LD_VAR 0 6
99748: PUSH
99749: LD_VAR 0 4
99753: ARRAY
99754: PUSH
99755: LD_INT 2
99757: ARRAY
99758: PPUSH
99759: CALL_OW 488
99763: NOT
99764: PUSH
99765: LD_VAR 0 6
99769: PUSH
99770: LD_VAR 0 4
99774: ARRAY
99775: PUSH
99776: LD_INT 1
99778: ARRAY
99779: PPUSH
99780: LD_VAR 0 6
99784: PUSH
99785: LD_VAR 0 4
99789: ARRAY
99790: PUSH
99791: LD_INT 2
99793: ARRAY
99794: PPUSH
99795: CALL_OW 428
99799: PUSH
99800: LD_INT 0
99802: NONEQUAL
99803: OR
99804: IFFALSE 99826
// tmp := Delete ( tmp , i ) ;
99806: LD_ADDR_VAR 0 6
99810: PUSH
99811: LD_VAR 0 6
99815: PPUSH
99816: LD_VAR 0 4
99820: PPUSH
99821: CALL_OW 3
99825: ST_TO_ADDR
99826: GO 99726
99828: POP
99829: POP
// j := GetClosestHex ( unit , tmp ) ;
99830: LD_ADDR_VAR 0 5
99834: PUSH
99835: LD_VAR 0 1
99839: PPUSH
99840: LD_VAR 0 6
99844: PPUSH
99845: CALL 99130 0 2
99849: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99850: LD_VAR 0 1
99854: PPUSH
99855: LD_VAR 0 5
99859: PUSH
99860: LD_INT 1
99862: ARRAY
99863: PPUSH
99864: LD_VAR 0 5
99868: PUSH
99869: LD_INT 2
99871: ARRAY
99872: PPUSH
99873: CALL_OW 111
// end ;
99877: LD_VAR 0 3
99881: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99882: LD_INT 0
99884: PPUSH
99885: PPUSH
99886: PPUSH
// uc_side = 0 ;
99887: LD_ADDR_OWVAR 20
99891: PUSH
99892: LD_INT 0
99894: ST_TO_ADDR
// uc_nation = 0 ;
99895: LD_ADDR_OWVAR 21
99899: PUSH
99900: LD_INT 0
99902: ST_TO_ADDR
// InitHc ;
99903: CALL_OW 19
// InitVc ;
99907: CALL_OW 20
// if mastodonts then
99911: LD_VAR 0 6
99915: IFFALSE 99982
// for i = 1 to mastodonts do
99917: LD_ADDR_VAR 0 11
99921: PUSH
99922: DOUBLE
99923: LD_INT 1
99925: DEC
99926: ST_TO_ADDR
99927: LD_VAR 0 6
99931: PUSH
99932: FOR_TO
99933: IFFALSE 99980
// begin vc_chassis := 31 ;
99935: LD_ADDR_OWVAR 37
99939: PUSH
99940: LD_INT 31
99942: ST_TO_ADDR
// vc_control := control_rider ;
99943: LD_ADDR_OWVAR 38
99947: PUSH
99948: LD_INT 4
99950: ST_TO_ADDR
// animal := CreateVehicle ;
99951: LD_ADDR_VAR 0 12
99955: PUSH
99956: CALL_OW 45
99960: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99961: LD_VAR 0 12
99965: PPUSH
99966: LD_VAR 0 8
99970: PPUSH
99971: LD_INT 0
99973: PPUSH
99974: CALL 106760 0 3
// end ;
99978: GO 99932
99980: POP
99981: POP
// if horses then
99982: LD_VAR 0 5
99986: IFFALSE 100053
// for i = 1 to horses do
99988: LD_ADDR_VAR 0 11
99992: PUSH
99993: DOUBLE
99994: LD_INT 1
99996: DEC
99997: ST_TO_ADDR
99998: LD_VAR 0 5
100002: PUSH
100003: FOR_TO
100004: IFFALSE 100051
// begin hc_class := 21 ;
100006: LD_ADDR_OWVAR 28
100010: PUSH
100011: LD_INT 21
100013: ST_TO_ADDR
// hc_gallery :=  ;
100014: LD_ADDR_OWVAR 33
100018: PUSH
100019: LD_STRING 
100021: ST_TO_ADDR
// animal := CreateHuman ;
100022: LD_ADDR_VAR 0 12
100026: PUSH
100027: CALL_OW 44
100031: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100032: LD_VAR 0 12
100036: PPUSH
100037: LD_VAR 0 8
100041: PPUSH
100042: LD_INT 0
100044: PPUSH
100045: CALL 106760 0 3
// end ;
100049: GO 100003
100051: POP
100052: POP
// if birds then
100053: LD_VAR 0 1
100057: IFFALSE 100124
// for i = 1 to birds do
100059: LD_ADDR_VAR 0 11
100063: PUSH
100064: DOUBLE
100065: LD_INT 1
100067: DEC
100068: ST_TO_ADDR
100069: LD_VAR 0 1
100073: PUSH
100074: FOR_TO
100075: IFFALSE 100122
// begin hc_class = 18 ;
100077: LD_ADDR_OWVAR 28
100081: PUSH
100082: LD_INT 18
100084: ST_TO_ADDR
// hc_gallery =  ;
100085: LD_ADDR_OWVAR 33
100089: PUSH
100090: LD_STRING 
100092: ST_TO_ADDR
// animal := CreateHuman ;
100093: LD_ADDR_VAR 0 12
100097: PUSH
100098: CALL_OW 44
100102: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100103: LD_VAR 0 12
100107: PPUSH
100108: LD_VAR 0 8
100112: PPUSH
100113: LD_INT 0
100115: PPUSH
100116: CALL 106760 0 3
// end ;
100120: GO 100074
100122: POP
100123: POP
// if tigers then
100124: LD_VAR 0 2
100128: IFFALSE 100212
// for i = 1 to tigers do
100130: LD_ADDR_VAR 0 11
100134: PUSH
100135: DOUBLE
100136: LD_INT 1
100138: DEC
100139: ST_TO_ADDR
100140: LD_VAR 0 2
100144: PUSH
100145: FOR_TO
100146: IFFALSE 100210
// begin hc_class = class_tiger ;
100148: LD_ADDR_OWVAR 28
100152: PUSH
100153: LD_INT 14
100155: ST_TO_ADDR
// hc_gallery =  ;
100156: LD_ADDR_OWVAR 33
100160: PUSH
100161: LD_STRING 
100163: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100164: LD_ADDR_OWVAR 35
100168: PUSH
100169: LD_INT 7
100171: NEG
100172: PPUSH
100173: LD_INT 7
100175: PPUSH
100176: CALL_OW 12
100180: ST_TO_ADDR
// animal := CreateHuman ;
100181: LD_ADDR_VAR 0 12
100185: PUSH
100186: CALL_OW 44
100190: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100191: LD_VAR 0 12
100195: PPUSH
100196: LD_VAR 0 8
100200: PPUSH
100201: LD_INT 0
100203: PPUSH
100204: CALL 106760 0 3
// end ;
100208: GO 100145
100210: POP
100211: POP
// if apemans then
100212: LD_VAR 0 3
100216: IFFALSE 100339
// for i = 1 to apemans do
100218: LD_ADDR_VAR 0 11
100222: PUSH
100223: DOUBLE
100224: LD_INT 1
100226: DEC
100227: ST_TO_ADDR
100228: LD_VAR 0 3
100232: PUSH
100233: FOR_TO
100234: IFFALSE 100337
// begin hc_class = class_apeman ;
100236: LD_ADDR_OWVAR 28
100240: PUSH
100241: LD_INT 12
100243: ST_TO_ADDR
// hc_gallery =  ;
100244: LD_ADDR_OWVAR 33
100248: PUSH
100249: LD_STRING 
100251: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100252: LD_ADDR_OWVAR 35
100256: PUSH
100257: LD_INT 5
100259: NEG
100260: PPUSH
100261: LD_INT 5
100263: PPUSH
100264: CALL_OW 12
100268: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100269: LD_ADDR_OWVAR 31
100273: PUSH
100274: LD_INT 1
100276: PPUSH
100277: LD_INT 3
100279: PPUSH
100280: CALL_OW 12
100284: PUSH
100285: LD_INT 1
100287: PPUSH
100288: LD_INT 3
100290: PPUSH
100291: CALL_OW 12
100295: PUSH
100296: LD_INT 0
100298: PUSH
100299: LD_INT 0
100301: PUSH
100302: EMPTY
100303: LIST
100304: LIST
100305: LIST
100306: LIST
100307: ST_TO_ADDR
// animal := CreateHuman ;
100308: LD_ADDR_VAR 0 12
100312: PUSH
100313: CALL_OW 44
100317: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100318: LD_VAR 0 12
100322: PPUSH
100323: LD_VAR 0 8
100327: PPUSH
100328: LD_INT 0
100330: PPUSH
100331: CALL 106760 0 3
// end ;
100335: GO 100233
100337: POP
100338: POP
// if enchidnas then
100339: LD_VAR 0 4
100343: IFFALSE 100410
// for i = 1 to enchidnas do
100345: LD_ADDR_VAR 0 11
100349: PUSH
100350: DOUBLE
100351: LD_INT 1
100353: DEC
100354: ST_TO_ADDR
100355: LD_VAR 0 4
100359: PUSH
100360: FOR_TO
100361: IFFALSE 100408
// begin hc_class = 13 ;
100363: LD_ADDR_OWVAR 28
100367: PUSH
100368: LD_INT 13
100370: ST_TO_ADDR
// hc_gallery =  ;
100371: LD_ADDR_OWVAR 33
100375: PUSH
100376: LD_STRING 
100378: ST_TO_ADDR
// animal := CreateHuman ;
100379: LD_ADDR_VAR 0 12
100383: PUSH
100384: CALL_OW 44
100388: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100389: LD_VAR 0 12
100393: PPUSH
100394: LD_VAR 0 8
100398: PPUSH
100399: LD_INT 0
100401: PPUSH
100402: CALL 106760 0 3
// end ;
100406: GO 100360
100408: POP
100409: POP
// if fishes then
100410: LD_VAR 0 7
100414: IFFALSE 100481
// for i = 1 to fishes do
100416: LD_ADDR_VAR 0 11
100420: PUSH
100421: DOUBLE
100422: LD_INT 1
100424: DEC
100425: ST_TO_ADDR
100426: LD_VAR 0 7
100430: PUSH
100431: FOR_TO
100432: IFFALSE 100479
// begin hc_class = 20 ;
100434: LD_ADDR_OWVAR 28
100438: PUSH
100439: LD_INT 20
100441: ST_TO_ADDR
// hc_gallery =  ;
100442: LD_ADDR_OWVAR 33
100446: PUSH
100447: LD_STRING 
100449: ST_TO_ADDR
// animal := CreateHuman ;
100450: LD_ADDR_VAR 0 12
100454: PUSH
100455: CALL_OW 44
100459: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100460: LD_VAR 0 12
100464: PPUSH
100465: LD_VAR 0 9
100469: PPUSH
100470: LD_INT 0
100472: PPUSH
100473: CALL 106760 0 3
// end ;
100477: GO 100431
100479: POP
100480: POP
// end ;
100481: LD_VAR 0 10
100485: RET
// export function WantHeal ( sci , unit ) ; begin
100486: LD_INT 0
100488: PPUSH
// if GetTaskList ( sci ) > 0 then
100489: LD_VAR 0 1
100493: PPUSH
100494: CALL_OW 437
100498: PUSH
100499: LD_INT 0
100501: GREATER
100502: IFFALSE 100572
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100504: LD_VAR 0 1
100508: PPUSH
100509: CALL_OW 437
100513: PUSH
100514: LD_INT 1
100516: ARRAY
100517: PUSH
100518: LD_INT 1
100520: ARRAY
100521: PUSH
100522: LD_STRING l
100524: EQUAL
100525: PUSH
100526: LD_VAR 0 1
100530: PPUSH
100531: CALL_OW 437
100535: PUSH
100536: LD_INT 1
100538: ARRAY
100539: PUSH
100540: LD_INT 4
100542: ARRAY
100543: PUSH
100544: LD_VAR 0 2
100548: EQUAL
100549: AND
100550: IFFALSE 100562
// result := true else
100552: LD_ADDR_VAR 0 3
100556: PUSH
100557: LD_INT 1
100559: ST_TO_ADDR
100560: GO 100570
// result := false ;
100562: LD_ADDR_VAR 0 3
100566: PUSH
100567: LD_INT 0
100569: ST_TO_ADDR
// end else
100570: GO 100580
// result := false ;
100572: LD_ADDR_VAR 0 3
100576: PUSH
100577: LD_INT 0
100579: ST_TO_ADDR
// end ;
100580: LD_VAR 0 3
100584: RET
// export function HealTarget ( sci ) ; begin
100585: LD_INT 0
100587: PPUSH
// if not sci then
100588: LD_VAR 0 1
100592: NOT
100593: IFFALSE 100597
// exit ;
100595: GO 100662
// result := 0 ;
100597: LD_ADDR_VAR 0 2
100601: PUSH
100602: LD_INT 0
100604: ST_TO_ADDR
// if GetTaskList ( sci ) then
100605: LD_VAR 0 1
100609: PPUSH
100610: CALL_OW 437
100614: IFFALSE 100662
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100616: LD_VAR 0 1
100620: PPUSH
100621: CALL_OW 437
100625: PUSH
100626: LD_INT 1
100628: ARRAY
100629: PUSH
100630: LD_INT 1
100632: ARRAY
100633: PUSH
100634: LD_STRING l
100636: EQUAL
100637: IFFALSE 100662
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100639: LD_ADDR_VAR 0 2
100643: PUSH
100644: LD_VAR 0 1
100648: PPUSH
100649: CALL_OW 437
100653: PUSH
100654: LD_INT 1
100656: ARRAY
100657: PUSH
100658: LD_INT 4
100660: ARRAY
100661: ST_TO_ADDR
// end ;
100662: LD_VAR 0 2
100666: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100667: LD_INT 0
100669: PPUSH
100670: PPUSH
100671: PPUSH
100672: PPUSH
100673: PPUSH
100674: PPUSH
100675: PPUSH
100676: PPUSH
100677: PPUSH
100678: PPUSH
100679: PPUSH
100680: PPUSH
100681: PPUSH
100682: PPUSH
100683: PPUSH
100684: PPUSH
100685: PPUSH
100686: PPUSH
100687: PPUSH
100688: PPUSH
100689: PPUSH
100690: PPUSH
100691: PPUSH
100692: PPUSH
100693: PPUSH
100694: PPUSH
100695: PPUSH
100696: PPUSH
100697: PPUSH
100698: PPUSH
100699: PPUSH
100700: PPUSH
100701: PPUSH
100702: PPUSH
// if not list then
100703: LD_VAR 0 1
100707: NOT
100708: IFFALSE 100712
// exit ;
100710: GO 105371
// base := list [ 1 ] ;
100712: LD_ADDR_VAR 0 3
100716: PUSH
100717: LD_VAR 0 1
100721: PUSH
100722: LD_INT 1
100724: ARRAY
100725: ST_TO_ADDR
// group := list [ 2 ] ;
100726: LD_ADDR_VAR 0 4
100730: PUSH
100731: LD_VAR 0 1
100735: PUSH
100736: LD_INT 2
100738: ARRAY
100739: ST_TO_ADDR
// path := list [ 3 ] ;
100740: LD_ADDR_VAR 0 5
100744: PUSH
100745: LD_VAR 0 1
100749: PUSH
100750: LD_INT 3
100752: ARRAY
100753: ST_TO_ADDR
// flags := list [ 4 ] ;
100754: LD_ADDR_VAR 0 6
100758: PUSH
100759: LD_VAR 0 1
100763: PUSH
100764: LD_INT 4
100766: ARRAY
100767: ST_TO_ADDR
// mined := [ ] ;
100768: LD_ADDR_VAR 0 27
100772: PUSH
100773: EMPTY
100774: ST_TO_ADDR
// bombed := [ ] ;
100775: LD_ADDR_VAR 0 28
100779: PUSH
100780: EMPTY
100781: ST_TO_ADDR
// healers := [ ] ;
100782: LD_ADDR_VAR 0 31
100786: PUSH
100787: EMPTY
100788: ST_TO_ADDR
// to_heal := [ ] ;
100789: LD_ADDR_VAR 0 30
100793: PUSH
100794: EMPTY
100795: ST_TO_ADDR
// repairs := [ ] ;
100796: LD_ADDR_VAR 0 33
100800: PUSH
100801: EMPTY
100802: ST_TO_ADDR
// to_repair := [ ] ;
100803: LD_ADDR_VAR 0 32
100807: PUSH
100808: EMPTY
100809: ST_TO_ADDR
// if not group or not path then
100810: LD_VAR 0 4
100814: NOT
100815: PUSH
100816: LD_VAR 0 5
100820: NOT
100821: OR
100822: IFFALSE 100826
// exit ;
100824: GO 105371
// side := GetSide ( group [ 1 ] ) ;
100826: LD_ADDR_VAR 0 35
100830: PUSH
100831: LD_VAR 0 4
100835: PUSH
100836: LD_INT 1
100838: ARRAY
100839: PPUSH
100840: CALL_OW 255
100844: ST_TO_ADDR
// if flags then
100845: LD_VAR 0 6
100849: IFFALSE 100993
// begin f_ignore_area := flags [ 1 ] ;
100851: LD_ADDR_VAR 0 17
100855: PUSH
100856: LD_VAR 0 6
100860: PUSH
100861: LD_INT 1
100863: ARRAY
100864: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100865: LD_ADDR_VAR 0 18
100869: PUSH
100870: LD_VAR 0 6
100874: PUSH
100875: LD_INT 2
100877: ARRAY
100878: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100879: LD_ADDR_VAR 0 19
100883: PUSH
100884: LD_VAR 0 6
100888: PUSH
100889: LD_INT 3
100891: ARRAY
100892: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100893: LD_ADDR_VAR 0 20
100897: PUSH
100898: LD_VAR 0 6
100902: PUSH
100903: LD_INT 4
100905: ARRAY
100906: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100907: LD_ADDR_VAR 0 21
100911: PUSH
100912: LD_VAR 0 6
100916: PUSH
100917: LD_INT 5
100919: ARRAY
100920: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100921: LD_ADDR_VAR 0 22
100925: PUSH
100926: LD_VAR 0 6
100930: PUSH
100931: LD_INT 6
100933: ARRAY
100934: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100935: LD_ADDR_VAR 0 23
100939: PUSH
100940: LD_VAR 0 6
100944: PUSH
100945: LD_INT 7
100947: ARRAY
100948: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100949: LD_ADDR_VAR 0 24
100953: PUSH
100954: LD_VAR 0 6
100958: PUSH
100959: LD_INT 8
100961: ARRAY
100962: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100963: LD_ADDR_VAR 0 25
100967: PUSH
100968: LD_VAR 0 6
100972: PUSH
100973: LD_INT 9
100975: ARRAY
100976: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100977: LD_ADDR_VAR 0 26
100981: PUSH
100982: LD_VAR 0 6
100986: PUSH
100987: LD_INT 10
100989: ARRAY
100990: ST_TO_ADDR
// end else
100991: GO 101073
// begin f_ignore_area := false ;
100993: LD_ADDR_VAR 0 17
100997: PUSH
100998: LD_INT 0
101000: ST_TO_ADDR
// f_capture := false ;
101001: LD_ADDR_VAR 0 18
101005: PUSH
101006: LD_INT 0
101008: ST_TO_ADDR
// f_ignore_civ := false ;
101009: LD_ADDR_VAR 0 19
101013: PUSH
101014: LD_INT 0
101016: ST_TO_ADDR
// f_murder := false ;
101017: LD_ADDR_VAR 0 20
101021: PUSH
101022: LD_INT 0
101024: ST_TO_ADDR
// f_mines := false ;
101025: LD_ADDR_VAR 0 21
101029: PUSH
101030: LD_INT 0
101032: ST_TO_ADDR
// f_repair := false ;
101033: LD_ADDR_VAR 0 22
101037: PUSH
101038: LD_INT 0
101040: ST_TO_ADDR
// f_heal := false ;
101041: LD_ADDR_VAR 0 23
101045: PUSH
101046: LD_INT 0
101048: ST_TO_ADDR
// f_spacetime := false ;
101049: LD_ADDR_VAR 0 24
101053: PUSH
101054: LD_INT 0
101056: ST_TO_ADDR
// f_attack_depot := false ;
101057: LD_ADDR_VAR 0 25
101061: PUSH
101062: LD_INT 0
101064: ST_TO_ADDR
// f_crawl := false ;
101065: LD_ADDR_VAR 0 26
101069: PUSH
101070: LD_INT 0
101072: ST_TO_ADDR
// end ; if f_heal then
101073: LD_VAR 0 23
101077: IFFALSE 101104
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101079: LD_ADDR_VAR 0 31
101083: PUSH
101084: LD_VAR 0 4
101088: PPUSH
101089: LD_INT 25
101091: PUSH
101092: LD_INT 4
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: PPUSH
101099: CALL_OW 72
101103: ST_TO_ADDR
// if f_repair then
101104: LD_VAR 0 22
101108: IFFALSE 101135
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101110: LD_ADDR_VAR 0 33
101114: PUSH
101115: LD_VAR 0 4
101119: PPUSH
101120: LD_INT 25
101122: PUSH
101123: LD_INT 3
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PPUSH
101130: CALL_OW 72
101134: ST_TO_ADDR
// units_path := [ ] ;
101135: LD_ADDR_VAR 0 16
101139: PUSH
101140: EMPTY
101141: ST_TO_ADDR
// for i = 1 to group do
101142: LD_ADDR_VAR 0 7
101146: PUSH
101147: DOUBLE
101148: LD_INT 1
101150: DEC
101151: ST_TO_ADDR
101152: LD_VAR 0 4
101156: PUSH
101157: FOR_TO
101158: IFFALSE 101187
// units_path := Replace ( units_path , i , path ) ;
101160: LD_ADDR_VAR 0 16
101164: PUSH
101165: LD_VAR 0 16
101169: PPUSH
101170: LD_VAR 0 7
101174: PPUSH
101175: LD_VAR 0 5
101179: PPUSH
101180: CALL_OW 1
101184: ST_TO_ADDR
101185: GO 101157
101187: POP
101188: POP
// repeat for i = group downto 1 do
101189: LD_ADDR_VAR 0 7
101193: PUSH
101194: DOUBLE
101195: LD_VAR 0 4
101199: INC
101200: ST_TO_ADDR
101201: LD_INT 1
101203: PUSH
101204: FOR_DOWNTO
101205: IFFALSE 105327
// begin wait ( 5 ) ;
101207: LD_INT 5
101209: PPUSH
101210: CALL_OW 67
// tmp := [ ] ;
101214: LD_ADDR_VAR 0 14
101218: PUSH
101219: EMPTY
101220: ST_TO_ADDR
// attacking := false ;
101221: LD_ADDR_VAR 0 29
101225: PUSH
101226: LD_INT 0
101228: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101229: LD_VAR 0 4
101233: PUSH
101234: LD_VAR 0 7
101238: ARRAY
101239: PPUSH
101240: CALL_OW 301
101244: PUSH
101245: LD_VAR 0 4
101249: PUSH
101250: LD_VAR 0 7
101254: ARRAY
101255: NOT
101256: OR
101257: IFFALSE 101366
// begin if GetType ( group [ i ] ) = unit_human then
101259: LD_VAR 0 4
101263: PUSH
101264: LD_VAR 0 7
101268: ARRAY
101269: PPUSH
101270: CALL_OW 247
101274: PUSH
101275: LD_INT 1
101277: EQUAL
101278: IFFALSE 101324
// begin to_heal := to_heal diff group [ i ] ;
101280: LD_ADDR_VAR 0 30
101284: PUSH
101285: LD_VAR 0 30
101289: PUSH
101290: LD_VAR 0 4
101294: PUSH
101295: LD_VAR 0 7
101299: ARRAY
101300: DIFF
101301: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101302: LD_ADDR_VAR 0 31
101306: PUSH
101307: LD_VAR 0 31
101311: PUSH
101312: LD_VAR 0 4
101316: PUSH
101317: LD_VAR 0 7
101321: ARRAY
101322: DIFF
101323: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101324: LD_ADDR_VAR 0 4
101328: PUSH
101329: LD_VAR 0 4
101333: PPUSH
101334: LD_VAR 0 7
101338: PPUSH
101339: CALL_OW 3
101343: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101344: LD_ADDR_VAR 0 16
101348: PUSH
101349: LD_VAR 0 16
101353: PPUSH
101354: LD_VAR 0 7
101358: PPUSH
101359: CALL_OW 3
101363: ST_TO_ADDR
// continue ;
101364: GO 101204
// end ; if f_repair then
101366: LD_VAR 0 22
101370: IFFALSE 101859
// begin if GetType ( group [ i ] ) = unit_vehicle then
101372: LD_VAR 0 4
101376: PUSH
101377: LD_VAR 0 7
101381: ARRAY
101382: PPUSH
101383: CALL_OW 247
101387: PUSH
101388: LD_INT 2
101390: EQUAL
101391: IFFALSE 101581
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101393: LD_VAR 0 4
101397: PUSH
101398: LD_VAR 0 7
101402: ARRAY
101403: PPUSH
101404: CALL_OW 256
101408: PUSH
101409: LD_INT 700
101411: LESS
101412: PUSH
101413: LD_VAR 0 4
101417: PUSH
101418: LD_VAR 0 7
101422: ARRAY
101423: PUSH
101424: LD_VAR 0 32
101428: IN
101429: NOT
101430: AND
101431: IFFALSE 101455
// to_repair := to_repair union group [ i ] ;
101433: LD_ADDR_VAR 0 32
101437: PUSH
101438: LD_VAR 0 32
101442: PUSH
101443: LD_VAR 0 4
101447: PUSH
101448: LD_VAR 0 7
101452: ARRAY
101453: UNION
101454: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101455: LD_VAR 0 4
101459: PUSH
101460: LD_VAR 0 7
101464: ARRAY
101465: PPUSH
101466: CALL_OW 256
101470: PUSH
101471: LD_INT 1000
101473: EQUAL
101474: PUSH
101475: LD_VAR 0 4
101479: PUSH
101480: LD_VAR 0 7
101484: ARRAY
101485: PUSH
101486: LD_VAR 0 32
101490: IN
101491: AND
101492: IFFALSE 101516
// to_repair := to_repair diff group [ i ] ;
101494: LD_ADDR_VAR 0 32
101498: PUSH
101499: LD_VAR 0 32
101503: PUSH
101504: LD_VAR 0 4
101508: PUSH
101509: LD_VAR 0 7
101513: ARRAY
101514: DIFF
101515: ST_TO_ADDR
// if group [ i ] in to_repair then
101516: LD_VAR 0 4
101520: PUSH
101521: LD_VAR 0 7
101525: ARRAY
101526: PUSH
101527: LD_VAR 0 32
101531: IN
101532: IFFALSE 101579
// begin if not IsInArea ( group [ i ] , f_repair ) then
101534: LD_VAR 0 4
101538: PUSH
101539: LD_VAR 0 7
101543: ARRAY
101544: PPUSH
101545: LD_VAR 0 22
101549: PPUSH
101550: CALL_OW 308
101554: NOT
101555: IFFALSE 101577
// ComMoveToArea ( group [ i ] , f_repair ) ;
101557: LD_VAR 0 4
101561: PUSH
101562: LD_VAR 0 7
101566: ARRAY
101567: PPUSH
101568: LD_VAR 0 22
101572: PPUSH
101573: CALL_OW 113
// continue ;
101577: GO 101204
// end ; end else
101579: GO 101859
// if group [ i ] in repairs then
101581: LD_VAR 0 4
101585: PUSH
101586: LD_VAR 0 7
101590: ARRAY
101591: PUSH
101592: LD_VAR 0 33
101596: IN
101597: IFFALSE 101859
// begin if IsInUnit ( group [ i ] ) then
101599: LD_VAR 0 4
101603: PUSH
101604: LD_VAR 0 7
101608: ARRAY
101609: PPUSH
101610: CALL_OW 310
101614: IFFALSE 101682
// begin z := IsInUnit ( group [ i ] ) ;
101616: LD_ADDR_VAR 0 13
101620: PUSH
101621: LD_VAR 0 4
101625: PUSH
101626: LD_VAR 0 7
101630: ARRAY
101631: PPUSH
101632: CALL_OW 310
101636: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101637: LD_VAR 0 13
101641: PUSH
101642: LD_VAR 0 32
101646: IN
101647: PUSH
101648: LD_VAR 0 13
101652: PPUSH
101653: LD_VAR 0 22
101657: PPUSH
101658: CALL_OW 308
101662: AND
101663: IFFALSE 101680
// ComExitVehicle ( group [ i ] ) ;
101665: LD_VAR 0 4
101669: PUSH
101670: LD_VAR 0 7
101674: ARRAY
101675: PPUSH
101676: CALL_OW 121
// end else
101680: GO 101859
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101682: LD_ADDR_VAR 0 13
101686: PUSH
101687: LD_VAR 0 4
101691: PPUSH
101692: LD_INT 95
101694: PUSH
101695: LD_VAR 0 22
101699: PUSH
101700: EMPTY
101701: LIST
101702: LIST
101703: PUSH
101704: LD_INT 58
101706: PUSH
101707: EMPTY
101708: LIST
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: PPUSH
101714: CALL_OW 72
101718: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101719: LD_VAR 0 4
101723: PUSH
101724: LD_VAR 0 7
101728: ARRAY
101729: PPUSH
101730: CALL_OW 314
101734: NOT
101735: IFFALSE 101857
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101737: LD_ADDR_VAR 0 10
101741: PUSH
101742: LD_VAR 0 13
101746: PPUSH
101747: LD_VAR 0 4
101751: PUSH
101752: LD_VAR 0 7
101756: ARRAY
101757: PPUSH
101758: CALL_OW 74
101762: ST_TO_ADDR
// if not x then
101763: LD_VAR 0 10
101767: NOT
101768: IFFALSE 101772
// continue ;
101770: GO 101204
// if GetLives ( x ) < 1000 then
101772: LD_VAR 0 10
101776: PPUSH
101777: CALL_OW 256
101781: PUSH
101782: LD_INT 1000
101784: LESS
101785: IFFALSE 101809
// ComRepairVehicle ( group [ i ] , x ) else
101787: LD_VAR 0 4
101791: PUSH
101792: LD_VAR 0 7
101796: ARRAY
101797: PPUSH
101798: LD_VAR 0 10
101802: PPUSH
101803: CALL_OW 129
101807: GO 101857
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101809: LD_VAR 0 23
101813: PUSH
101814: LD_VAR 0 4
101818: PUSH
101819: LD_VAR 0 7
101823: ARRAY
101824: PPUSH
101825: CALL_OW 256
101829: PUSH
101830: LD_INT 1000
101832: LESS
101833: AND
101834: NOT
101835: IFFALSE 101857
// ComEnterUnit ( group [ i ] , x ) ;
101837: LD_VAR 0 4
101841: PUSH
101842: LD_VAR 0 7
101846: ARRAY
101847: PPUSH
101848: LD_VAR 0 10
101852: PPUSH
101853: CALL_OW 120
// end ; continue ;
101857: GO 101204
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101859: LD_VAR 0 23
101863: PUSH
101864: LD_VAR 0 4
101868: PUSH
101869: LD_VAR 0 7
101873: ARRAY
101874: PPUSH
101875: CALL_OW 247
101879: PUSH
101880: LD_INT 1
101882: EQUAL
101883: AND
101884: IFFALSE 102362
// begin if group [ i ] in healers then
101886: LD_VAR 0 4
101890: PUSH
101891: LD_VAR 0 7
101895: ARRAY
101896: PUSH
101897: LD_VAR 0 31
101901: IN
101902: IFFALSE 102175
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101904: LD_VAR 0 4
101908: PUSH
101909: LD_VAR 0 7
101913: ARRAY
101914: PPUSH
101915: LD_VAR 0 23
101919: PPUSH
101920: CALL_OW 308
101924: NOT
101925: PUSH
101926: LD_VAR 0 4
101930: PUSH
101931: LD_VAR 0 7
101935: ARRAY
101936: PPUSH
101937: CALL_OW 314
101941: NOT
101942: AND
101943: IFFALSE 101967
// ComMoveToArea ( group [ i ] , f_heal ) else
101945: LD_VAR 0 4
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PPUSH
101956: LD_VAR 0 23
101960: PPUSH
101961: CALL_OW 113
101965: GO 102173
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101967: LD_VAR 0 4
101971: PUSH
101972: LD_VAR 0 7
101976: ARRAY
101977: PPUSH
101978: CALL 100585 0 1
101982: PPUSH
101983: CALL_OW 256
101987: PUSH
101988: LD_INT 1000
101990: EQUAL
101991: IFFALSE 102010
// ComStop ( group [ i ] ) else
101993: LD_VAR 0 4
101997: PUSH
101998: LD_VAR 0 7
102002: ARRAY
102003: PPUSH
102004: CALL_OW 141
102008: GO 102173
// if not HasTask ( group [ i ] ) and to_heal then
102010: LD_VAR 0 4
102014: PUSH
102015: LD_VAR 0 7
102019: ARRAY
102020: PPUSH
102021: CALL_OW 314
102025: NOT
102026: PUSH
102027: LD_VAR 0 30
102031: AND
102032: IFFALSE 102173
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102034: LD_ADDR_VAR 0 13
102038: PUSH
102039: LD_VAR 0 30
102043: PPUSH
102044: LD_INT 3
102046: PUSH
102047: LD_INT 54
102049: PUSH
102050: EMPTY
102051: LIST
102052: PUSH
102053: EMPTY
102054: LIST
102055: LIST
102056: PPUSH
102057: CALL_OW 72
102061: PPUSH
102062: LD_VAR 0 4
102066: PUSH
102067: LD_VAR 0 7
102071: ARRAY
102072: PPUSH
102073: CALL_OW 74
102077: ST_TO_ADDR
// if z then
102078: LD_VAR 0 13
102082: IFFALSE 102173
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102084: LD_INT 91
102086: PUSH
102087: LD_VAR 0 13
102091: PUSH
102092: LD_INT 10
102094: PUSH
102095: EMPTY
102096: LIST
102097: LIST
102098: LIST
102099: PUSH
102100: LD_INT 81
102102: PUSH
102103: LD_VAR 0 13
102107: PPUSH
102108: CALL_OW 255
102112: PUSH
102113: EMPTY
102114: LIST
102115: LIST
102116: PUSH
102117: EMPTY
102118: LIST
102119: LIST
102120: PPUSH
102121: CALL_OW 69
102125: PUSH
102126: LD_INT 0
102128: EQUAL
102129: IFFALSE 102153
// ComHeal ( group [ i ] , z ) else
102131: LD_VAR 0 4
102135: PUSH
102136: LD_VAR 0 7
102140: ARRAY
102141: PPUSH
102142: LD_VAR 0 13
102146: PPUSH
102147: CALL_OW 128
102151: GO 102173
// ComMoveToArea ( group [ i ] , f_heal ) ;
102153: LD_VAR 0 4
102157: PUSH
102158: LD_VAR 0 7
102162: ARRAY
102163: PPUSH
102164: LD_VAR 0 23
102168: PPUSH
102169: CALL_OW 113
// end ; continue ;
102173: GO 101204
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102175: LD_VAR 0 4
102179: PUSH
102180: LD_VAR 0 7
102184: ARRAY
102185: PPUSH
102186: CALL_OW 256
102190: PUSH
102191: LD_INT 700
102193: LESS
102194: PUSH
102195: LD_VAR 0 4
102199: PUSH
102200: LD_VAR 0 7
102204: ARRAY
102205: PUSH
102206: LD_VAR 0 30
102210: IN
102211: NOT
102212: AND
102213: IFFALSE 102237
// to_heal := to_heal union group [ i ] ;
102215: LD_ADDR_VAR 0 30
102219: PUSH
102220: LD_VAR 0 30
102224: PUSH
102225: LD_VAR 0 4
102229: PUSH
102230: LD_VAR 0 7
102234: ARRAY
102235: UNION
102236: ST_TO_ADDR
// if group [ i ] in to_heal then
102237: LD_VAR 0 4
102241: PUSH
102242: LD_VAR 0 7
102246: ARRAY
102247: PUSH
102248: LD_VAR 0 30
102252: IN
102253: IFFALSE 102362
// begin if GetLives ( group [ i ] ) = 1000 then
102255: LD_VAR 0 4
102259: PUSH
102260: LD_VAR 0 7
102264: ARRAY
102265: PPUSH
102266: CALL_OW 256
102270: PUSH
102271: LD_INT 1000
102273: EQUAL
102274: IFFALSE 102300
// to_heal := to_heal diff group [ i ] else
102276: LD_ADDR_VAR 0 30
102280: PUSH
102281: LD_VAR 0 30
102285: PUSH
102286: LD_VAR 0 4
102290: PUSH
102291: LD_VAR 0 7
102295: ARRAY
102296: DIFF
102297: ST_TO_ADDR
102298: GO 102362
// begin if not IsInArea ( group [ i ] , to_heal ) then
102300: LD_VAR 0 4
102304: PUSH
102305: LD_VAR 0 7
102309: ARRAY
102310: PPUSH
102311: LD_VAR 0 30
102315: PPUSH
102316: CALL_OW 308
102320: NOT
102321: IFFALSE 102345
// ComMoveToArea ( group [ i ] , f_heal ) else
102323: LD_VAR 0 4
102327: PUSH
102328: LD_VAR 0 7
102332: ARRAY
102333: PPUSH
102334: LD_VAR 0 23
102338: PPUSH
102339: CALL_OW 113
102343: GO 102360
// ComHold ( group [ i ] ) ;
102345: LD_VAR 0 4
102349: PUSH
102350: LD_VAR 0 7
102354: ARRAY
102355: PPUSH
102356: CALL_OW 140
// continue ;
102360: GO 101204
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102362: LD_VAR 0 4
102366: PUSH
102367: LD_VAR 0 7
102371: ARRAY
102372: PPUSH
102373: LD_INT 10
102375: PPUSH
102376: CALL 99005 0 2
102380: NOT
102381: PUSH
102382: LD_VAR 0 16
102386: PUSH
102387: LD_VAR 0 7
102391: ARRAY
102392: PUSH
102393: EMPTY
102394: EQUAL
102395: NOT
102396: AND
102397: IFFALSE 102663
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102399: LD_VAR 0 4
102403: PUSH
102404: LD_VAR 0 7
102408: ARRAY
102409: PPUSH
102410: CALL_OW 262
102414: PUSH
102415: LD_INT 1
102417: PUSH
102418: LD_INT 2
102420: PUSH
102421: EMPTY
102422: LIST
102423: LIST
102424: IN
102425: IFFALSE 102466
// if GetFuel ( group [ i ] ) < 10 then
102427: LD_VAR 0 4
102431: PUSH
102432: LD_VAR 0 7
102436: ARRAY
102437: PPUSH
102438: CALL_OW 261
102442: PUSH
102443: LD_INT 10
102445: LESS
102446: IFFALSE 102466
// SetFuel ( group [ i ] , 12 ) ;
102448: LD_VAR 0 4
102452: PUSH
102453: LD_VAR 0 7
102457: ARRAY
102458: PPUSH
102459: LD_INT 12
102461: PPUSH
102462: CALL_OW 240
// if units_path [ i ] then
102466: LD_VAR 0 16
102470: PUSH
102471: LD_VAR 0 7
102475: ARRAY
102476: IFFALSE 102661
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102478: LD_VAR 0 4
102482: PUSH
102483: LD_VAR 0 7
102487: ARRAY
102488: PPUSH
102489: LD_VAR 0 16
102493: PUSH
102494: LD_VAR 0 7
102498: ARRAY
102499: PUSH
102500: LD_INT 1
102502: ARRAY
102503: PUSH
102504: LD_INT 1
102506: ARRAY
102507: PPUSH
102508: LD_VAR 0 16
102512: PUSH
102513: LD_VAR 0 7
102517: ARRAY
102518: PUSH
102519: LD_INT 1
102521: ARRAY
102522: PUSH
102523: LD_INT 2
102525: ARRAY
102526: PPUSH
102527: CALL_OW 297
102531: PUSH
102532: LD_INT 6
102534: GREATER
102535: IFFALSE 102610
// begin if not HasTask ( group [ i ] ) then
102537: LD_VAR 0 4
102541: PUSH
102542: LD_VAR 0 7
102546: ARRAY
102547: PPUSH
102548: CALL_OW 314
102552: NOT
102553: IFFALSE 102608
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102555: LD_VAR 0 4
102559: PUSH
102560: LD_VAR 0 7
102564: ARRAY
102565: PPUSH
102566: LD_VAR 0 16
102570: PUSH
102571: LD_VAR 0 7
102575: ARRAY
102576: PUSH
102577: LD_INT 1
102579: ARRAY
102580: PUSH
102581: LD_INT 1
102583: ARRAY
102584: PPUSH
102585: LD_VAR 0 16
102589: PUSH
102590: LD_VAR 0 7
102594: ARRAY
102595: PUSH
102596: LD_INT 1
102598: ARRAY
102599: PUSH
102600: LD_INT 2
102602: ARRAY
102603: PPUSH
102604: CALL_OW 114
// end else
102608: GO 102661
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102610: LD_ADDR_VAR 0 15
102614: PUSH
102615: LD_VAR 0 16
102619: PUSH
102620: LD_VAR 0 7
102624: ARRAY
102625: PPUSH
102626: LD_INT 1
102628: PPUSH
102629: CALL_OW 3
102633: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102634: LD_ADDR_VAR 0 16
102638: PUSH
102639: LD_VAR 0 16
102643: PPUSH
102644: LD_VAR 0 7
102648: PPUSH
102649: LD_VAR 0 15
102653: PPUSH
102654: CALL_OW 1
102658: ST_TO_ADDR
// continue ;
102659: GO 101204
// end ; end ; end else
102661: GO 105325
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102663: LD_ADDR_VAR 0 14
102667: PUSH
102668: LD_INT 81
102670: PUSH
102671: LD_VAR 0 4
102675: PUSH
102676: LD_VAR 0 7
102680: ARRAY
102681: PPUSH
102682: CALL_OW 255
102686: PUSH
102687: EMPTY
102688: LIST
102689: LIST
102690: PPUSH
102691: CALL_OW 69
102695: ST_TO_ADDR
// if not tmp then
102696: LD_VAR 0 14
102700: NOT
102701: IFFALSE 102705
// continue ;
102703: GO 101204
// if f_ignore_area then
102705: LD_VAR 0 17
102709: IFFALSE 102797
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102711: LD_ADDR_VAR 0 15
102715: PUSH
102716: LD_VAR 0 14
102720: PPUSH
102721: LD_INT 3
102723: PUSH
102724: LD_INT 92
102726: PUSH
102727: LD_VAR 0 17
102731: PUSH
102732: LD_INT 1
102734: ARRAY
102735: PUSH
102736: LD_VAR 0 17
102740: PUSH
102741: LD_INT 2
102743: ARRAY
102744: PUSH
102745: LD_VAR 0 17
102749: PUSH
102750: LD_INT 3
102752: ARRAY
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: LIST
102758: LIST
102759: PUSH
102760: EMPTY
102761: LIST
102762: LIST
102763: PPUSH
102764: CALL_OW 72
102768: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102769: LD_VAR 0 14
102773: PUSH
102774: LD_VAR 0 15
102778: DIFF
102779: IFFALSE 102797
// tmp := tmp diff tmp2 ;
102781: LD_ADDR_VAR 0 14
102785: PUSH
102786: LD_VAR 0 14
102790: PUSH
102791: LD_VAR 0 15
102795: DIFF
102796: ST_TO_ADDR
// end ; if not f_murder then
102797: LD_VAR 0 20
102801: NOT
102802: IFFALSE 102860
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102804: LD_ADDR_VAR 0 15
102808: PUSH
102809: LD_VAR 0 14
102813: PPUSH
102814: LD_INT 3
102816: PUSH
102817: LD_INT 50
102819: PUSH
102820: EMPTY
102821: LIST
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: PPUSH
102827: CALL_OW 72
102831: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102832: LD_VAR 0 14
102836: PUSH
102837: LD_VAR 0 15
102841: DIFF
102842: IFFALSE 102860
// tmp := tmp diff tmp2 ;
102844: LD_ADDR_VAR 0 14
102848: PUSH
102849: LD_VAR 0 14
102853: PUSH
102854: LD_VAR 0 15
102858: DIFF
102859: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102860: LD_ADDR_VAR 0 14
102864: PUSH
102865: LD_VAR 0 4
102869: PUSH
102870: LD_VAR 0 7
102874: ARRAY
102875: PPUSH
102876: LD_VAR 0 14
102880: PPUSH
102881: LD_INT 1
102883: PPUSH
102884: LD_INT 1
102886: PPUSH
102887: CALL 72648 0 4
102891: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102892: LD_VAR 0 4
102896: PUSH
102897: LD_VAR 0 7
102901: ARRAY
102902: PPUSH
102903: CALL_OW 257
102907: PUSH
102908: LD_INT 1
102910: EQUAL
102911: IFFALSE 103359
// begin if WantPlant ( group [ i ] ) then
102913: LD_VAR 0 4
102917: PUSH
102918: LD_VAR 0 7
102922: ARRAY
102923: PPUSH
102924: CALL 72149 0 1
102928: IFFALSE 102932
// continue ;
102930: GO 101204
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102932: LD_VAR 0 18
102936: PUSH
102937: LD_VAR 0 4
102941: PUSH
102942: LD_VAR 0 7
102946: ARRAY
102947: PPUSH
102948: CALL_OW 310
102952: NOT
102953: AND
102954: PUSH
102955: LD_VAR 0 14
102959: PUSH
102960: LD_INT 1
102962: ARRAY
102963: PUSH
102964: LD_VAR 0 14
102968: PPUSH
102969: LD_INT 21
102971: PUSH
102972: LD_INT 2
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: PUSH
102979: LD_INT 58
102981: PUSH
102982: EMPTY
102983: LIST
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: PPUSH
102989: CALL_OW 72
102993: IN
102994: AND
102995: IFFALSE 103031
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102997: LD_VAR 0 4
103001: PUSH
103002: LD_VAR 0 7
103006: ARRAY
103007: PPUSH
103008: LD_VAR 0 14
103012: PUSH
103013: LD_INT 1
103015: ARRAY
103016: PPUSH
103017: CALL_OW 120
// attacking := true ;
103021: LD_ADDR_VAR 0 29
103025: PUSH
103026: LD_INT 1
103028: ST_TO_ADDR
// continue ;
103029: GO 101204
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103031: LD_VAR 0 26
103035: PUSH
103036: LD_VAR 0 4
103040: PUSH
103041: LD_VAR 0 7
103045: ARRAY
103046: PPUSH
103047: CALL_OW 257
103051: PUSH
103052: LD_INT 1
103054: EQUAL
103055: AND
103056: PUSH
103057: LD_VAR 0 4
103061: PUSH
103062: LD_VAR 0 7
103066: ARRAY
103067: PPUSH
103068: CALL_OW 256
103072: PUSH
103073: LD_INT 800
103075: LESS
103076: AND
103077: PUSH
103078: LD_VAR 0 4
103082: PUSH
103083: LD_VAR 0 7
103087: ARRAY
103088: PPUSH
103089: CALL_OW 318
103093: NOT
103094: AND
103095: IFFALSE 103112
// ComCrawl ( group [ i ] ) ;
103097: LD_VAR 0 4
103101: PUSH
103102: LD_VAR 0 7
103106: ARRAY
103107: PPUSH
103108: CALL_OW 137
// if f_mines then
103112: LD_VAR 0 21
103116: IFFALSE 103359
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103118: LD_VAR 0 14
103122: PUSH
103123: LD_INT 1
103125: ARRAY
103126: PPUSH
103127: CALL_OW 247
103131: PUSH
103132: LD_INT 3
103134: EQUAL
103135: PUSH
103136: LD_VAR 0 14
103140: PUSH
103141: LD_INT 1
103143: ARRAY
103144: PUSH
103145: LD_VAR 0 27
103149: IN
103150: NOT
103151: AND
103152: IFFALSE 103359
// begin x := GetX ( tmp [ 1 ] ) ;
103154: LD_ADDR_VAR 0 10
103158: PUSH
103159: LD_VAR 0 14
103163: PUSH
103164: LD_INT 1
103166: ARRAY
103167: PPUSH
103168: CALL_OW 250
103172: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103173: LD_ADDR_VAR 0 11
103177: PUSH
103178: LD_VAR 0 14
103182: PUSH
103183: LD_INT 1
103185: ARRAY
103186: PPUSH
103187: CALL_OW 251
103191: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103192: LD_ADDR_VAR 0 12
103196: PUSH
103197: LD_VAR 0 4
103201: PUSH
103202: LD_VAR 0 7
103206: ARRAY
103207: PPUSH
103208: CALL 99090 0 1
103212: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103213: LD_VAR 0 4
103217: PUSH
103218: LD_VAR 0 7
103222: ARRAY
103223: PPUSH
103224: LD_VAR 0 10
103228: PPUSH
103229: LD_VAR 0 11
103233: PPUSH
103234: LD_VAR 0 14
103238: PUSH
103239: LD_INT 1
103241: ARRAY
103242: PPUSH
103243: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103247: LD_VAR 0 4
103251: PUSH
103252: LD_VAR 0 7
103256: ARRAY
103257: PPUSH
103258: LD_VAR 0 10
103262: PPUSH
103263: LD_VAR 0 12
103267: PPUSH
103268: LD_INT 7
103270: PPUSH
103271: CALL_OW 272
103275: PPUSH
103276: LD_VAR 0 11
103280: PPUSH
103281: LD_VAR 0 12
103285: PPUSH
103286: LD_INT 7
103288: PPUSH
103289: CALL_OW 273
103293: PPUSH
103294: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103298: LD_VAR 0 4
103302: PUSH
103303: LD_VAR 0 7
103307: ARRAY
103308: PPUSH
103309: LD_INT 71
103311: PPUSH
103312: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103316: LD_ADDR_VAR 0 27
103320: PUSH
103321: LD_VAR 0 27
103325: PPUSH
103326: LD_VAR 0 27
103330: PUSH
103331: LD_INT 1
103333: PLUS
103334: PPUSH
103335: LD_VAR 0 14
103339: PUSH
103340: LD_INT 1
103342: ARRAY
103343: PPUSH
103344: CALL_OW 1
103348: ST_TO_ADDR
// attacking := true ;
103349: LD_ADDR_VAR 0 29
103353: PUSH
103354: LD_INT 1
103356: ST_TO_ADDR
// continue ;
103357: GO 101204
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103359: LD_VAR 0 4
103363: PUSH
103364: LD_VAR 0 7
103368: ARRAY
103369: PPUSH
103370: CALL_OW 257
103374: PUSH
103375: LD_INT 17
103377: EQUAL
103378: PUSH
103379: LD_VAR 0 4
103383: PUSH
103384: LD_VAR 0 7
103388: ARRAY
103389: PPUSH
103390: CALL_OW 110
103394: PUSH
103395: LD_INT 71
103397: EQUAL
103398: NOT
103399: AND
103400: IFFALSE 103546
// begin attacking := false ;
103402: LD_ADDR_VAR 0 29
103406: PUSH
103407: LD_INT 0
103409: ST_TO_ADDR
// k := 5 ;
103410: LD_ADDR_VAR 0 9
103414: PUSH
103415: LD_INT 5
103417: ST_TO_ADDR
// if tmp < k then
103418: LD_VAR 0 14
103422: PUSH
103423: LD_VAR 0 9
103427: LESS
103428: IFFALSE 103440
// k := tmp ;
103430: LD_ADDR_VAR 0 9
103434: PUSH
103435: LD_VAR 0 14
103439: ST_TO_ADDR
// for j = 1 to k do
103440: LD_ADDR_VAR 0 8
103444: PUSH
103445: DOUBLE
103446: LD_INT 1
103448: DEC
103449: ST_TO_ADDR
103450: LD_VAR 0 9
103454: PUSH
103455: FOR_TO
103456: IFFALSE 103544
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103458: LD_VAR 0 14
103462: PUSH
103463: LD_VAR 0 8
103467: ARRAY
103468: PUSH
103469: LD_VAR 0 14
103473: PPUSH
103474: LD_INT 58
103476: PUSH
103477: EMPTY
103478: LIST
103479: PPUSH
103480: CALL_OW 72
103484: IN
103485: NOT
103486: IFFALSE 103542
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103488: LD_VAR 0 4
103492: PUSH
103493: LD_VAR 0 7
103497: ARRAY
103498: PPUSH
103499: LD_VAR 0 14
103503: PUSH
103504: LD_VAR 0 8
103508: ARRAY
103509: PPUSH
103510: CALL_OW 115
// attacking := true ;
103514: LD_ADDR_VAR 0 29
103518: PUSH
103519: LD_INT 1
103521: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103522: LD_VAR 0 4
103526: PUSH
103527: LD_VAR 0 7
103531: ARRAY
103532: PPUSH
103533: LD_INT 71
103535: PPUSH
103536: CALL_OW 109
// continue ;
103540: GO 103455
// end ; end ;
103542: GO 103455
103544: POP
103545: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103546: LD_VAR 0 4
103550: PUSH
103551: LD_VAR 0 7
103555: ARRAY
103556: PPUSH
103557: CALL_OW 257
103561: PUSH
103562: LD_INT 8
103564: EQUAL
103565: PUSH
103566: LD_VAR 0 4
103570: PUSH
103571: LD_VAR 0 7
103575: ARRAY
103576: PPUSH
103577: CALL_OW 264
103581: PUSH
103582: LD_INT 28
103584: PUSH
103585: LD_INT 45
103587: PUSH
103588: LD_INT 7
103590: PUSH
103591: LD_INT 47
103593: PUSH
103594: EMPTY
103595: LIST
103596: LIST
103597: LIST
103598: LIST
103599: IN
103600: OR
103601: IFFALSE 103857
// begin attacking := false ;
103603: LD_ADDR_VAR 0 29
103607: PUSH
103608: LD_INT 0
103610: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103611: LD_VAR 0 14
103615: PUSH
103616: LD_INT 1
103618: ARRAY
103619: PPUSH
103620: CALL_OW 266
103624: PUSH
103625: LD_INT 32
103627: PUSH
103628: LD_INT 31
103630: PUSH
103631: LD_INT 33
103633: PUSH
103634: LD_INT 4
103636: PUSH
103637: LD_INT 5
103639: PUSH
103640: EMPTY
103641: LIST
103642: LIST
103643: LIST
103644: LIST
103645: LIST
103646: IN
103647: IFFALSE 103833
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103649: LD_ADDR_VAR 0 9
103653: PUSH
103654: LD_VAR 0 14
103658: PUSH
103659: LD_INT 1
103661: ARRAY
103662: PPUSH
103663: CALL_OW 266
103667: PPUSH
103668: LD_VAR 0 14
103672: PUSH
103673: LD_INT 1
103675: ARRAY
103676: PPUSH
103677: CALL_OW 250
103681: PPUSH
103682: LD_VAR 0 14
103686: PUSH
103687: LD_INT 1
103689: ARRAY
103690: PPUSH
103691: CALL_OW 251
103695: PPUSH
103696: LD_VAR 0 14
103700: PUSH
103701: LD_INT 1
103703: ARRAY
103704: PPUSH
103705: CALL_OW 254
103709: PPUSH
103710: LD_VAR 0 14
103714: PUSH
103715: LD_INT 1
103717: ARRAY
103718: PPUSH
103719: CALL_OW 248
103723: PPUSH
103724: LD_INT 0
103726: PPUSH
103727: CALL 80460 0 6
103731: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103732: LD_ADDR_VAR 0 8
103736: PUSH
103737: LD_VAR 0 4
103741: PUSH
103742: LD_VAR 0 7
103746: ARRAY
103747: PPUSH
103748: LD_VAR 0 9
103752: PPUSH
103753: CALL 99130 0 2
103757: ST_TO_ADDR
// if j then
103758: LD_VAR 0 8
103762: IFFALSE 103831
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103764: LD_VAR 0 8
103768: PUSH
103769: LD_INT 1
103771: ARRAY
103772: PPUSH
103773: LD_VAR 0 8
103777: PUSH
103778: LD_INT 2
103780: ARRAY
103781: PPUSH
103782: CALL_OW 488
103786: IFFALSE 103831
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103788: LD_VAR 0 4
103792: PUSH
103793: LD_VAR 0 7
103797: ARRAY
103798: PPUSH
103799: LD_VAR 0 8
103803: PUSH
103804: LD_INT 1
103806: ARRAY
103807: PPUSH
103808: LD_VAR 0 8
103812: PUSH
103813: LD_INT 2
103815: ARRAY
103816: PPUSH
103817: CALL_OW 116
// attacking := true ;
103821: LD_ADDR_VAR 0 29
103825: PUSH
103826: LD_INT 1
103828: ST_TO_ADDR
// continue ;
103829: GO 101204
// end ; end else
103831: GO 103857
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103833: LD_VAR 0 4
103837: PUSH
103838: LD_VAR 0 7
103842: ARRAY
103843: PPUSH
103844: LD_VAR 0 14
103848: PUSH
103849: LD_INT 1
103851: ARRAY
103852: PPUSH
103853: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103857: LD_VAR 0 4
103861: PUSH
103862: LD_VAR 0 7
103866: ARRAY
103867: PPUSH
103868: CALL_OW 265
103872: PUSH
103873: LD_INT 11
103875: EQUAL
103876: IFFALSE 104154
// begin k := 10 ;
103878: LD_ADDR_VAR 0 9
103882: PUSH
103883: LD_INT 10
103885: ST_TO_ADDR
// x := 0 ;
103886: LD_ADDR_VAR 0 10
103890: PUSH
103891: LD_INT 0
103893: ST_TO_ADDR
// if tmp < k then
103894: LD_VAR 0 14
103898: PUSH
103899: LD_VAR 0 9
103903: LESS
103904: IFFALSE 103916
// k := tmp ;
103906: LD_ADDR_VAR 0 9
103910: PUSH
103911: LD_VAR 0 14
103915: ST_TO_ADDR
// for j = k downto 1 do
103916: LD_ADDR_VAR 0 8
103920: PUSH
103921: DOUBLE
103922: LD_VAR 0 9
103926: INC
103927: ST_TO_ADDR
103928: LD_INT 1
103930: PUSH
103931: FOR_DOWNTO
103932: IFFALSE 104007
// begin if GetType ( tmp [ j ] ) = unit_human then
103934: LD_VAR 0 14
103938: PUSH
103939: LD_VAR 0 8
103943: ARRAY
103944: PPUSH
103945: CALL_OW 247
103949: PUSH
103950: LD_INT 1
103952: EQUAL
103953: IFFALSE 104005
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103955: LD_VAR 0 4
103959: PUSH
103960: LD_VAR 0 7
103964: ARRAY
103965: PPUSH
103966: LD_VAR 0 14
103970: PUSH
103971: LD_VAR 0 8
103975: ARRAY
103976: PPUSH
103977: CALL 99401 0 2
// x := tmp [ j ] ;
103981: LD_ADDR_VAR 0 10
103985: PUSH
103986: LD_VAR 0 14
103990: PUSH
103991: LD_VAR 0 8
103995: ARRAY
103996: ST_TO_ADDR
// attacking := true ;
103997: LD_ADDR_VAR 0 29
104001: PUSH
104002: LD_INT 1
104004: ST_TO_ADDR
// end ; end ;
104005: GO 103931
104007: POP
104008: POP
// if not x then
104009: LD_VAR 0 10
104013: NOT
104014: IFFALSE 104154
// begin attacking := true ;
104016: LD_ADDR_VAR 0 29
104020: PUSH
104021: LD_INT 1
104023: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104024: LD_VAR 0 4
104028: PUSH
104029: LD_VAR 0 7
104033: ARRAY
104034: PPUSH
104035: CALL_OW 250
104039: PPUSH
104040: LD_VAR 0 4
104044: PUSH
104045: LD_VAR 0 7
104049: ARRAY
104050: PPUSH
104051: CALL_OW 251
104055: PPUSH
104056: CALL_OW 546
104060: PUSH
104061: LD_INT 2
104063: ARRAY
104064: PUSH
104065: LD_VAR 0 14
104069: PUSH
104070: LD_INT 1
104072: ARRAY
104073: PPUSH
104074: CALL_OW 250
104078: PPUSH
104079: LD_VAR 0 14
104083: PUSH
104084: LD_INT 1
104086: ARRAY
104087: PPUSH
104088: CALL_OW 251
104092: PPUSH
104093: CALL_OW 546
104097: PUSH
104098: LD_INT 2
104100: ARRAY
104101: EQUAL
104102: IFFALSE 104130
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104104: LD_VAR 0 4
104108: PUSH
104109: LD_VAR 0 7
104113: ARRAY
104114: PPUSH
104115: LD_VAR 0 14
104119: PUSH
104120: LD_INT 1
104122: ARRAY
104123: PPUSH
104124: CALL 99401 0 2
104128: GO 104154
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104130: LD_VAR 0 4
104134: PUSH
104135: LD_VAR 0 7
104139: ARRAY
104140: PPUSH
104141: LD_VAR 0 14
104145: PUSH
104146: LD_INT 1
104148: ARRAY
104149: PPUSH
104150: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104154: LD_VAR 0 4
104158: PUSH
104159: LD_VAR 0 7
104163: ARRAY
104164: PPUSH
104165: CALL_OW 264
104169: PUSH
104170: LD_INT 29
104172: EQUAL
104173: IFFALSE 104539
// begin if WantsToAttack ( group [ i ] ) in bombed then
104175: LD_VAR 0 4
104179: PUSH
104180: LD_VAR 0 7
104184: ARRAY
104185: PPUSH
104186: CALL_OW 319
104190: PUSH
104191: LD_VAR 0 28
104195: IN
104196: IFFALSE 104200
// continue ;
104198: GO 101204
// k := 8 ;
104200: LD_ADDR_VAR 0 9
104204: PUSH
104205: LD_INT 8
104207: ST_TO_ADDR
// x := 0 ;
104208: LD_ADDR_VAR 0 10
104212: PUSH
104213: LD_INT 0
104215: ST_TO_ADDR
// if tmp < k then
104216: LD_VAR 0 14
104220: PUSH
104221: LD_VAR 0 9
104225: LESS
104226: IFFALSE 104238
// k := tmp ;
104228: LD_ADDR_VAR 0 9
104232: PUSH
104233: LD_VAR 0 14
104237: ST_TO_ADDR
// for j = 1 to k do
104238: LD_ADDR_VAR 0 8
104242: PUSH
104243: DOUBLE
104244: LD_INT 1
104246: DEC
104247: ST_TO_ADDR
104248: LD_VAR 0 9
104252: PUSH
104253: FOR_TO
104254: IFFALSE 104386
// begin if GetType ( tmp [ j ] ) = unit_building then
104256: LD_VAR 0 14
104260: PUSH
104261: LD_VAR 0 8
104265: ARRAY
104266: PPUSH
104267: CALL_OW 247
104271: PUSH
104272: LD_INT 3
104274: EQUAL
104275: IFFALSE 104384
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104277: LD_VAR 0 14
104281: PUSH
104282: LD_VAR 0 8
104286: ARRAY
104287: PUSH
104288: LD_VAR 0 28
104292: IN
104293: NOT
104294: PUSH
104295: LD_VAR 0 14
104299: PUSH
104300: LD_VAR 0 8
104304: ARRAY
104305: PPUSH
104306: CALL_OW 313
104310: AND
104311: IFFALSE 104384
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104313: LD_VAR 0 4
104317: PUSH
104318: LD_VAR 0 7
104322: ARRAY
104323: PPUSH
104324: LD_VAR 0 14
104328: PUSH
104329: LD_VAR 0 8
104333: ARRAY
104334: PPUSH
104335: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104339: LD_ADDR_VAR 0 28
104343: PUSH
104344: LD_VAR 0 28
104348: PPUSH
104349: LD_VAR 0 28
104353: PUSH
104354: LD_INT 1
104356: PLUS
104357: PPUSH
104358: LD_VAR 0 14
104362: PUSH
104363: LD_VAR 0 8
104367: ARRAY
104368: PPUSH
104369: CALL_OW 1
104373: ST_TO_ADDR
// attacking := true ;
104374: LD_ADDR_VAR 0 29
104378: PUSH
104379: LD_INT 1
104381: ST_TO_ADDR
// break ;
104382: GO 104386
// end ; end ;
104384: GO 104253
104386: POP
104387: POP
// if not attacking and f_attack_depot then
104388: LD_VAR 0 29
104392: NOT
104393: PUSH
104394: LD_VAR 0 25
104398: AND
104399: IFFALSE 104494
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104401: LD_ADDR_VAR 0 13
104405: PUSH
104406: LD_VAR 0 14
104410: PPUSH
104411: LD_INT 2
104413: PUSH
104414: LD_INT 30
104416: PUSH
104417: LD_INT 0
104419: PUSH
104420: EMPTY
104421: LIST
104422: LIST
104423: PUSH
104424: LD_INT 30
104426: PUSH
104427: LD_INT 1
104429: PUSH
104430: EMPTY
104431: LIST
104432: LIST
104433: PUSH
104434: EMPTY
104435: LIST
104436: LIST
104437: LIST
104438: PPUSH
104439: CALL_OW 72
104443: ST_TO_ADDR
// if z then
104444: LD_VAR 0 13
104448: IFFALSE 104494
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104450: LD_VAR 0 4
104454: PUSH
104455: LD_VAR 0 7
104459: ARRAY
104460: PPUSH
104461: LD_VAR 0 13
104465: PPUSH
104466: LD_VAR 0 4
104470: PUSH
104471: LD_VAR 0 7
104475: ARRAY
104476: PPUSH
104477: CALL_OW 74
104481: PPUSH
104482: CALL_OW 115
// attacking := true ;
104486: LD_ADDR_VAR 0 29
104490: PUSH
104491: LD_INT 1
104493: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104494: LD_VAR 0 4
104498: PUSH
104499: LD_VAR 0 7
104503: ARRAY
104504: PPUSH
104505: CALL_OW 256
104509: PUSH
104510: LD_INT 500
104512: LESS
104513: IFFALSE 104539
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104515: LD_VAR 0 4
104519: PUSH
104520: LD_VAR 0 7
104524: ARRAY
104525: PPUSH
104526: LD_VAR 0 14
104530: PUSH
104531: LD_INT 1
104533: ARRAY
104534: PPUSH
104535: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104539: LD_VAR 0 4
104543: PUSH
104544: LD_VAR 0 7
104548: ARRAY
104549: PPUSH
104550: CALL_OW 264
104554: PUSH
104555: LD_INT 49
104557: EQUAL
104558: IFFALSE 104679
// begin if not HasTask ( group [ i ] ) then
104560: LD_VAR 0 4
104564: PUSH
104565: LD_VAR 0 7
104569: ARRAY
104570: PPUSH
104571: CALL_OW 314
104575: NOT
104576: IFFALSE 104679
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104578: LD_ADDR_VAR 0 9
104582: PUSH
104583: LD_INT 81
104585: PUSH
104586: LD_VAR 0 4
104590: PUSH
104591: LD_VAR 0 7
104595: ARRAY
104596: PPUSH
104597: CALL_OW 255
104601: PUSH
104602: EMPTY
104603: LIST
104604: LIST
104605: PPUSH
104606: CALL_OW 69
104610: PPUSH
104611: LD_VAR 0 4
104615: PUSH
104616: LD_VAR 0 7
104620: ARRAY
104621: PPUSH
104622: CALL_OW 74
104626: ST_TO_ADDR
// if k then
104627: LD_VAR 0 9
104631: IFFALSE 104679
// if GetDistUnits ( group [ i ] , k ) > 10 then
104633: LD_VAR 0 4
104637: PUSH
104638: LD_VAR 0 7
104642: ARRAY
104643: PPUSH
104644: LD_VAR 0 9
104648: PPUSH
104649: CALL_OW 296
104653: PUSH
104654: LD_INT 10
104656: GREATER
104657: IFFALSE 104679
// ComMoveUnit ( group [ i ] , k ) ;
104659: LD_VAR 0 4
104663: PUSH
104664: LD_VAR 0 7
104668: ARRAY
104669: PPUSH
104670: LD_VAR 0 9
104674: PPUSH
104675: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104679: LD_VAR 0 4
104683: PUSH
104684: LD_VAR 0 7
104688: ARRAY
104689: PPUSH
104690: CALL_OW 256
104694: PUSH
104695: LD_INT 250
104697: LESS
104698: PUSH
104699: LD_VAR 0 4
104703: PUSH
104704: LD_VAR 0 7
104708: ARRAY
104709: PUSH
104710: LD_INT 21
104712: PUSH
104713: LD_INT 2
104715: PUSH
104716: EMPTY
104717: LIST
104718: LIST
104719: PUSH
104720: LD_INT 23
104722: PUSH
104723: LD_INT 2
104725: PUSH
104726: EMPTY
104727: LIST
104728: LIST
104729: PUSH
104730: EMPTY
104731: LIST
104732: LIST
104733: PPUSH
104734: CALL_OW 69
104738: IN
104739: AND
104740: IFFALSE 104865
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104742: LD_ADDR_VAR 0 9
104746: PUSH
104747: LD_OWVAR 3
104751: PUSH
104752: LD_VAR 0 4
104756: PUSH
104757: LD_VAR 0 7
104761: ARRAY
104762: DIFF
104763: PPUSH
104764: LD_VAR 0 4
104768: PUSH
104769: LD_VAR 0 7
104773: ARRAY
104774: PPUSH
104775: CALL_OW 74
104779: ST_TO_ADDR
// if not k then
104780: LD_VAR 0 9
104784: NOT
104785: IFFALSE 104789
// continue ;
104787: GO 101204
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104789: LD_VAR 0 9
104793: PUSH
104794: LD_INT 81
104796: PUSH
104797: LD_VAR 0 4
104801: PUSH
104802: LD_VAR 0 7
104806: ARRAY
104807: PPUSH
104808: CALL_OW 255
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: PPUSH
104817: CALL_OW 69
104821: IN
104822: PUSH
104823: LD_VAR 0 9
104827: PPUSH
104828: LD_VAR 0 4
104832: PUSH
104833: LD_VAR 0 7
104837: ARRAY
104838: PPUSH
104839: CALL_OW 296
104843: PUSH
104844: LD_INT 5
104846: LESS
104847: AND
104848: IFFALSE 104865
// ComAutodestruct ( group [ i ] ) ;
104850: LD_VAR 0 4
104854: PUSH
104855: LD_VAR 0 7
104859: ARRAY
104860: PPUSH
104861: CALL 99299 0 1
// end ; if f_attack_depot then
104865: LD_VAR 0 25
104869: IFFALSE 104981
// begin k := 6 ;
104871: LD_ADDR_VAR 0 9
104875: PUSH
104876: LD_INT 6
104878: ST_TO_ADDR
// if tmp < k then
104879: LD_VAR 0 14
104883: PUSH
104884: LD_VAR 0 9
104888: LESS
104889: IFFALSE 104901
// k := tmp ;
104891: LD_ADDR_VAR 0 9
104895: PUSH
104896: LD_VAR 0 14
104900: ST_TO_ADDR
// for j = 1 to k do
104901: LD_ADDR_VAR 0 8
104905: PUSH
104906: DOUBLE
104907: LD_INT 1
104909: DEC
104910: ST_TO_ADDR
104911: LD_VAR 0 9
104915: PUSH
104916: FOR_TO
104917: IFFALSE 104979
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104919: LD_VAR 0 8
104923: PPUSH
104924: CALL_OW 266
104928: PUSH
104929: LD_INT 0
104931: PUSH
104932: LD_INT 1
104934: PUSH
104935: EMPTY
104936: LIST
104937: LIST
104938: IN
104939: IFFALSE 104977
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104941: LD_VAR 0 4
104945: PUSH
104946: LD_VAR 0 7
104950: ARRAY
104951: PPUSH
104952: LD_VAR 0 14
104956: PUSH
104957: LD_VAR 0 8
104961: ARRAY
104962: PPUSH
104963: CALL_OW 115
// attacking := true ;
104967: LD_ADDR_VAR 0 29
104971: PUSH
104972: LD_INT 1
104974: ST_TO_ADDR
// break ;
104975: GO 104979
// end ;
104977: GO 104916
104979: POP
104980: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104981: LD_VAR 0 4
104985: PUSH
104986: LD_VAR 0 7
104990: ARRAY
104991: PPUSH
104992: CALL_OW 302
104996: PUSH
104997: LD_VAR 0 29
105001: NOT
105002: AND
105003: IFFALSE 105325
// begin if GetTag ( group [ i ] ) = 71 then
105005: LD_VAR 0 4
105009: PUSH
105010: LD_VAR 0 7
105014: ARRAY
105015: PPUSH
105016: CALL_OW 110
105020: PUSH
105021: LD_INT 71
105023: EQUAL
105024: IFFALSE 105065
// begin if HasTask ( group [ i ] ) then
105026: LD_VAR 0 4
105030: PUSH
105031: LD_VAR 0 7
105035: ARRAY
105036: PPUSH
105037: CALL_OW 314
105041: IFFALSE 105047
// continue else
105043: GO 101204
105045: GO 105065
// SetTag ( group [ i ] , 0 ) ;
105047: LD_VAR 0 4
105051: PUSH
105052: LD_VAR 0 7
105056: ARRAY
105057: PPUSH
105058: LD_INT 0
105060: PPUSH
105061: CALL_OW 109
// end ; k := 8 ;
105065: LD_ADDR_VAR 0 9
105069: PUSH
105070: LD_INT 8
105072: ST_TO_ADDR
// x := 0 ;
105073: LD_ADDR_VAR 0 10
105077: PUSH
105078: LD_INT 0
105080: ST_TO_ADDR
// if tmp < k then
105081: LD_VAR 0 14
105085: PUSH
105086: LD_VAR 0 9
105090: LESS
105091: IFFALSE 105103
// k := tmp ;
105093: LD_ADDR_VAR 0 9
105097: PUSH
105098: LD_VAR 0 14
105102: ST_TO_ADDR
// for j = 1 to k do
105103: LD_ADDR_VAR 0 8
105107: PUSH
105108: DOUBLE
105109: LD_INT 1
105111: DEC
105112: ST_TO_ADDR
105113: LD_VAR 0 9
105117: PUSH
105118: FOR_TO
105119: IFFALSE 105217
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105121: LD_VAR 0 14
105125: PUSH
105126: LD_VAR 0 8
105130: ARRAY
105131: PPUSH
105132: CALL_OW 247
105136: PUSH
105137: LD_INT 1
105139: EQUAL
105140: PUSH
105141: LD_VAR 0 14
105145: PUSH
105146: LD_VAR 0 8
105150: ARRAY
105151: PPUSH
105152: CALL_OW 256
105156: PUSH
105157: LD_INT 250
105159: LESS
105160: PUSH
105161: LD_VAR 0 20
105165: AND
105166: PUSH
105167: LD_VAR 0 20
105171: NOT
105172: PUSH
105173: LD_VAR 0 14
105177: PUSH
105178: LD_VAR 0 8
105182: ARRAY
105183: PPUSH
105184: CALL_OW 256
105188: PUSH
105189: LD_INT 250
105191: GREATEREQUAL
105192: AND
105193: OR
105194: AND
105195: IFFALSE 105215
// begin x := tmp [ j ] ;
105197: LD_ADDR_VAR 0 10
105201: PUSH
105202: LD_VAR 0 14
105206: PUSH
105207: LD_VAR 0 8
105211: ARRAY
105212: ST_TO_ADDR
// break ;
105213: GO 105217
// end ;
105215: GO 105118
105217: POP
105218: POP
// if x then
105219: LD_VAR 0 10
105223: IFFALSE 105247
// ComAttackUnit ( group [ i ] , x ) else
105225: LD_VAR 0 4
105229: PUSH
105230: LD_VAR 0 7
105234: ARRAY
105235: PPUSH
105236: LD_VAR 0 10
105240: PPUSH
105241: CALL_OW 115
105245: GO 105271
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105247: LD_VAR 0 4
105251: PUSH
105252: LD_VAR 0 7
105256: ARRAY
105257: PPUSH
105258: LD_VAR 0 14
105262: PUSH
105263: LD_INT 1
105265: ARRAY
105266: PPUSH
105267: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105271: LD_VAR 0 4
105275: PUSH
105276: LD_VAR 0 7
105280: ARRAY
105281: PPUSH
105282: CALL_OW 314
105286: NOT
105287: IFFALSE 105325
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105289: LD_VAR 0 4
105293: PUSH
105294: LD_VAR 0 7
105298: ARRAY
105299: PPUSH
105300: LD_VAR 0 14
105304: PPUSH
105305: LD_VAR 0 4
105309: PUSH
105310: LD_VAR 0 7
105314: ARRAY
105315: PPUSH
105316: CALL_OW 74
105320: PPUSH
105321: CALL_OW 115
// end ; end ; end ;
105325: GO 101204
105327: POP
105328: POP
// wait ( 0 0$2 ) ;
105329: LD_INT 70
105331: PPUSH
105332: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105336: LD_VAR 0 4
105340: NOT
105341: PUSH
105342: LD_VAR 0 4
105346: PUSH
105347: EMPTY
105348: EQUAL
105349: OR
105350: PUSH
105351: LD_INT 81
105353: PUSH
105354: LD_VAR 0 35
105358: PUSH
105359: EMPTY
105360: LIST
105361: LIST
105362: PPUSH
105363: CALL_OW 69
105367: NOT
105368: OR
105369: IFFALSE 101189
// end ;
105371: LD_VAR 0 2
105375: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105376: LD_INT 0
105378: PPUSH
105379: PPUSH
105380: PPUSH
105381: PPUSH
// if not base_units then
105382: LD_VAR 0 1
105386: NOT
105387: IFFALSE 105391
// exit ;
105389: GO 105478
// result := false ;
105391: LD_ADDR_VAR 0 2
105395: PUSH
105396: LD_INT 0
105398: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105399: LD_ADDR_VAR 0 5
105403: PUSH
105404: LD_VAR 0 1
105408: PPUSH
105409: LD_INT 21
105411: PUSH
105412: LD_INT 3
105414: PUSH
105415: EMPTY
105416: LIST
105417: LIST
105418: PPUSH
105419: CALL_OW 72
105423: ST_TO_ADDR
// if not tmp then
105424: LD_VAR 0 5
105428: NOT
105429: IFFALSE 105433
// exit ;
105431: GO 105478
// for i in tmp do
105433: LD_ADDR_VAR 0 3
105437: PUSH
105438: LD_VAR 0 5
105442: PUSH
105443: FOR_IN
105444: IFFALSE 105476
// begin result := EnemyInRange ( i , 22 ) ;
105446: LD_ADDR_VAR 0 2
105450: PUSH
105451: LD_VAR 0 3
105455: PPUSH
105456: LD_INT 22
105458: PPUSH
105459: CALL 99005 0 2
105463: ST_TO_ADDR
// if result then
105464: LD_VAR 0 2
105468: IFFALSE 105474
// exit ;
105470: POP
105471: POP
105472: GO 105478
// end ;
105474: GO 105443
105476: POP
105477: POP
// end ;
105478: LD_VAR 0 2
105482: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105483: LD_INT 0
105485: PPUSH
105486: PPUSH
// if not units then
105487: LD_VAR 0 1
105491: NOT
105492: IFFALSE 105496
// exit ;
105494: GO 105566
// result := [ ] ;
105496: LD_ADDR_VAR 0 3
105500: PUSH
105501: EMPTY
105502: ST_TO_ADDR
// for i in units do
105503: LD_ADDR_VAR 0 4
105507: PUSH
105508: LD_VAR 0 1
105512: PUSH
105513: FOR_IN
105514: IFFALSE 105564
// if GetTag ( i ) = tag then
105516: LD_VAR 0 4
105520: PPUSH
105521: CALL_OW 110
105525: PUSH
105526: LD_VAR 0 2
105530: EQUAL
105531: IFFALSE 105562
// result := Insert ( result , result + 1 , i ) ;
105533: LD_ADDR_VAR 0 3
105537: PUSH
105538: LD_VAR 0 3
105542: PPUSH
105543: LD_VAR 0 3
105547: PUSH
105548: LD_INT 1
105550: PLUS
105551: PPUSH
105552: LD_VAR 0 4
105556: PPUSH
105557: CALL_OW 2
105561: ST_TO_ADDR
105562: GO 105513
105564: POP
105565: POP
// end ;
105566: LD_VAR 0 3
105570: RET
// export function IsDriver ( un ) ; begin
105571: LD_INT 0
105573: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105574: LD_ADDR_VAR 0 2
105578: PUSH
105579: LD_VAR 0 1
105583: PUSH
105584: LD_INT 55
105586: PUSH
105587: EMPTY
105588: LIST
105589: PPUSH
105590: CALL_OW 69
105594: IN
105595: ST_TO_ADDR
// end ;
105596: LD_VAR 0 2
105600: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105601: LD_INT 0
105603: PPUSH
105604: PPUSH
// list := [ ] ;
105605: LD_ADDR_VAR 0 5
105609: PUSH
105610: EMPTY
105611: ST_TO_ADDR
// case d of 0 :
105612: LD_VAR 0 3
105616: PUSH
105617: LD_INT 0
105619: DOUBLE
105620: EQUAL
105621: IFTRUE 105625
105623: GO 105758
105625: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105626: LD_ADDR_VAR 0 5
105630: PUSH
105631: LD_VAR 0 1
105635: PUSH
105636: LD_INT 4
105638: MINUS
105639: PUSH
105640: LD_VAR 0 2
105644: PUSH
105645: LD_INT 4
105647: MINUS
105648: PUSH
105649: LD_INT 2
105651: PUSH
105652: EMPTY
105653: LIST
105654: LIST
105655: LIST
105656: PUSH
105657: LD_VAR 0 1
105661: PUSH
105662: LD_INT 3
105664: MINUS
105665: PUSH
105666: LD_VAR 0 2
105670: PUSH
105671: LD_INT 1
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: LIST
105678: PUSH
105679: LD_VAR 0 1
105683: PUSH
105684: LD_INT 4
105686: PLUS
105687: PUSH
105688: LD_VAR 0 2
105692: PUSH
105693: LD_INT 4
105695: PUSH
105696: EMPTY
105697: LIST
105698: LIST
105699: LIST
105700: PUSH
105701: LD_VAR 0 1
105705: PUSH
105706: LD_INT 3
105708: PLUS
105709: PUSH
105710: LD_VAR 0 2
105714: PUSH
105715: LD_INT 3
105717: PLUS
105718: PUSH
105719: LD_INT 5
105721: PUSH
105722: EMPTY
105723: LIST
105724: LIST
105725: LIST
105726: PUSH
105727: LD_VAR 0 1
105731: PUSH
105732: LD_VAR 0 2
105736: PUSH
105737: LD_INT 4
105739: PLUS
105740: PUSH
105741: LD_INT 0
105743: PUSH
105744: EMPTY
105745: LIST
105746: LIST
105747: LIST
105748: PUSH
105749: EMPTY
105750: LIST
105751: LIST
105752: LIST
105753: LIST
105754: LIST
105755: ST_TO_ADDR
// end ; 1 :
105756: GO 106456
105758: LD_INT 1
105760: DOUBLE
105761: EQUAL
105762: IFTRUE 105766
105764: GO 105899
105766: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105767: LD_ADDR_VAR 0 5
105771: PUSH
105772: LD_VAR 0 1
105776: PUSH
105777: LD_VAR 0 2
105781: PUSH
105782: LD_INT 4
105784: MINUS
105785: PUSH
105786: LD_INT 3
105788: PUSH
105789: EMPTY
105790: LIST
105791: LIST
105792: LIST
105793: PUSH
105794: LD_VAR 0 1
105798: PUSH
105799: LD_INT 3
105801: MINUS
105802: PUSH
105803: LD_VAR 0 2
105807: PUSH
105808: LD_INT 3
105810: MINUS
105811: PUSH
105812: LD_INT 2
105814: PUSH
105815: EMPTY
105816: LIST
105817: LIST
105818: LIST
105819: PUSH
105820: LD_VAR 0 1
105824: PUSH
105825: LD_INT 4
105827: MINUS
105828: PUSH
105829: LD_VAR 0 2
105833: PUSH
105834: LD_INT 1
105836: PUSH
105837: EMPTY
105838: LIST
105839: LIST
105840: LIST
105841: PUSH
105842: LD_VAR 0 1
105846: PUSH
105847: LD_VAR 0 2
105851: PUSH
105852: LD_INT 3
105854: PLUS
105855: PUSH
105856: LD_INT 0
105858: PUSH
105859: EMPTY
105860: LIST
105861: LIST
105862: LIST
105863: PUSH
105864: LD_VAR 0 1
105868: PUSH
105869: LD_INT 4
105871: PLUS
105872: PUSH
105873: LD_VAR 0 2
105877: PUSH
105878: LD_INT 4
105880: PLUS
105881: PUSH
105882: LD_INT 5
105884: PUSH
105885: EMPTY
105886: LIST
105887: LIST
105888: LIST
105889: PUSH
105890: EMPTY
105891: LIST
105892: LIST
105893: LIST
105894: LIST
105895: LIST
105896: ST_TO_ADDR
// end ; 2 :
105897: GO 106456
105899: LD_INT 2
105901: DOUBLE
105902: EQUAL
105903: IFTRUE 105907
105905: GO 106036
105907: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105908: LD_ADDR_VAR 0 5
105912: PUSH
105913: LD_VAR 0 1
105917: PUSH
105918: LD_VAR 0 2
105922: PUSH
105923: LD_INT 3
105925: MINUS
105926: PUSH
105927: LD_INT 3
105929: PUSH
105930: EMPTY
105931: LIST
105932: LIST
105933: LIST
105934: PUSH
105935: LD_VAR 0 1
105939: PUSH
105940: LD_INT 4
105942: PLUS
105943: PUSH
105944: LD_VAR 0 2
105948: PUSH
105949: LD_INT 4
105951: PUSH
105952: EMPTY
105953: LIST
105954: LIST
105955: LIST
105956: PUSH
105957: LD_VAR 0 1
105961: PUSH
105962: LD_VAR 0 2
105966: PUSH
105967: LD_INT 4
105969: PLUS
105970: PUSH
105971: LD_INT 0
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: LIST
105978: PUSH
105979: LD_VAR 0 1
105983: PUSH
105984: LD_INT 3
105986: MINUS
105987: PUSH
105988: LD_VAR 0 2
105992: PUSH
105993: LD_INT 1
105995: PUSH
105996: EMPTY
105997: LIST
105998: LIST
105999: LIST
106000: PUSH
106001: LD_VAR 0 1
106005: PUSH
106006: LD_INT 4
106008: MINUS
106009: PUSH
106010: LD_VAR 0 2
106014: PUSH
106015: LD_INT 4
106017: MINUS
106018: PUSH
106019: LD_INT 2
106021: PUSH
106022: EMPTY
106023: LIST
106024: LIST
106025: LIST
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: LIST
106031: LIST
106032: LIST
106033: ST_TO_ADDR
// end ; 3 :
106034: GO 106456
106036: LD_INT 3
106038: DOUBLE
106039: EQUAL
106040: IFTRUE 106044
106042: GO 106177
106044: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106045: LD_ADDR_VAR 0 5
106049: PUSH
106050: LD_VAR 0 1
106054: PUSH
106055: LD_INT 3
106057: PLUS
106058: PUSH
106059: LD_VAR 0 2
106063: PUSH
106064: LD_INT 4
106066: PUSH
106067: EMPTY
106068: LIST
106069: LIST
106070: LIST
106071: PUSH
106072: LD_VAR 0 1
106076: PUSH
106077: LD_INT 4
106079: PLUS
106080: PUSH
106081: LD_VAR 0 2
106085: PUSH
106086: LD_INT 4
106088: PLUS
106089: PUSH
106090: LD_INT 5
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: LIST
106097: PUSH
106098: LD_VAR 0 1
106102: PUSH
106103: LD_INT 4
106105: MINUS
106106: PUSH
106107: LD_VAR 0 2
106111: PUSH
106112: LD_INT 1
106114: PUSH
106115: EMPTY
106116: LIST
106117: LIST
106118: LIST
106119: PUSH
106120: LD_VAR 0 1
106124: PUSH
106125: LD_VAR 0 2
106129: PUSH
106130: LD_INT 4
106132: MINUS
106133: PUSH
106134: LD_INT 3
106136: PUSH
106137: EMPTY
106138: LIST
106139: LIST
106140: LIST
106141: PUSH
106142: LD_VAR 0 1
106146: PUSH
106147: LD_INT 3
106149: MINUS
106150: PUSH
106151: LD_VAR 0 2
106155: PUSH
106156: LD_INT 3
106158: MINUS
106159: PUSH
106160: LD_INT 2
106162: PUSH
106163: EMPTY
106164: LIST
106165: LIST
106166: LIST
106167: PUSH
106168: EMPTY
106169: LIST
106170: LIST
106171: LIST
106172: LIST
106173: LIST
106174: ST_TO_ADDR
// end ; 4 :
106175: GO 106456
106177: LD_INT 4
106179: DOUBLE
106180: EQUAL
106181: IFTRUE 106185
106183: GO 106318
106185: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106186: LD_ADDR_VAR 0 5
106190: PUSH
106191: LD_VAR 0 1
106195: PUSH
106196: LD_VAR 0 2
106200: PUSH
106201: LD_INT 4
106203: PLUS
106204: PUSH
106205: LD_INT 0
106207: PUSH
106208: EMPTY
106209: LIST
106210: LIST
106211: LIST
106212: PUSH
106213: LD_VAR 0 1
106217: PUSH
106218: LD_INT 3
106220: PLUS
106221: PUSH
106222: LD_VAR 0 2
106226: PUSH
106227: LD_INT 3
106229: PLUS
106230: PUSH
106231: LD_INT 5
106233: PUSH
106234: EMPTY
106235: LIST
106236: LIST
106237: LIST
106238: PUSH
106239: LD_VAR 0 1
106243: PUSH
106244: LD_INT 4
106246: PLUS
106247: PUSH
106248: LD_VAR 0 2
106252: PUSH
106253: LD_INT 4
106255: PUSH
106256: EMPTY
106257: LIST
106258: LIST
106259: LIST
106260: PUSH
106261: LD_VAR 0 1
106265: PUSH
106266: LD_VAR 0 2
106270: PUSH
106271: LD_INT 3
106273: MINUS
106274: PUSH
106275: LD_INT 3
106277: PUSH
106278: EMPTY
106279: LIST
106280: LIST
106281: LIST
106282: PUSH
106283: LD_VAR 0 1
106287: PUSH
106288: LD_INT 4
106290: MINUS
106291: PUSH
106292: LD_VAR 0 2
106296: PUSH
106297: LD_INT 4
106299: MINUS
106300: PUSH
106301: LD_INT 2
106303: PUSH
106304: EMPTY
106305: LIST
106306: LIST
106307: LIST
106308: PUSH
106309: EMPTY
106310: LIST
106311: LIST
106312: LIST
106313: LIST
106314: LIST
106315: ST_TO_ADDR
// end ; 5 :
106316: GO 106456
106318: LD_INT 5
106320: DOUBLE
106321: EQUAL
106322: IFTRUE 106326
106324: GO 106455
106326: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106327: LD_ADDR_VAR 0 5
106331: PUSH
106332: LD_VAR 0 1
106336: PUSH
106337: LD_INT 4
106339: MINUS
106340: PUSH
106341: LD_VAR 0 2
106345: PUSH
106346: LD_INT 1
106348: PUSH
106349: EMPTY
106350: LIST
106351: LIST
106352: LIST
106353: PUSH
106354: LD_VAR 0 1
106358: PUSH
106359: LD_VAR 0 2
106363: PUSH
106364: LD_INT 4
106366: MINUS
106367: PUSH
106368: LD_INT 3
106370: PUSH
106371: EMPTY
106372: LIST
106373: LIST
106374: LIST
106375: PUSH
106376: LD_VAR 0 1
106380: PUSH
106381: LD_INT 4
106383: PLUS
106384: PUSH
106385: LD_VAR 0 2
106389: PUSH
106390: LD_INT 4
106392: PLUS
106393: PUSH
106394: LD_INT 5
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: LIST
106401: PUSH
106402: LD_VAR 0 1
106406: PUSH
106407: LD_INT 3
106409: PLUS
106410: PUSH
106411: LD_VAR 0 2
106415: PUSH
106416: LD_INT 4
106418: PUSH
106419: EMPTY
106420: LIST
106421: LIST
106422: LIST
106423: PUSH
106424: LD_VAR 0 1
106428: PUSH
106429: LD_VAR 0 2
106433: PUSH
106434: LD_INT 3
106436: PLUS
106437: PUSH
106438: LD_INT 0
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: LIST
106445: PUSH
106446: EMPTY
106447: LIST
106448: LIST
106449: LIST
106450: LIST
106451: LIST
106452: ST_TO_ADDR
// end ; end ;
106453: GO 106456
106455: POP
// result := list ;
106456: LD_ADDR_VAR 0 4
106460: PUSH
106461: LD_VAR 0 5
106465: ST_TO_ADDR
// end ;
106466: LD_VAR 0 4
106470: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106471: LD_INT 0
106473: PPUSH
106474: PPUSH
106475: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106476: LD_VAR 0 1
106480: NOT
106481: PUSH
106482: LD_VAR 0 2
106486: PUSH
106487: LD_INT 1
106489: PUSH
106490: LD_INT 2
106492: PUSH
106493: LD_INT 3
106495: PUSH
106496: LD_INT 4
106498: PUSH
106499: EMPTY
106500: LIST
106501: LIST
106502: LIST
106503: LIST
106504: IN
106505: NOT
106506: OR
106507: IFFALSE 106511
// exit ;
106509: GO 106603
// tmp := [ ] ;
106511: LD_ADDR_VAR 0 5
106515: PUSH
106516: EMPTY
106517: ST_TO_ADDR
// for i in units do
106518: LD_ADDR_VAR 0 4
106522: PUSH
106523: LD_VAR 0 1
106527: PUSH
106528: FOR_IN
106529: IFFALSE 106572
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106531: LD_ADDR_VAR 0 5
106535: PUSH
106536: LD_VAR 0 5
106540: PPUSH
106541: LD_VAR 0 5
106545: PUSH
106546: LD_INT 1
106548: PLUS
106549: PPUSH
106550: LD_VAR 0 4
106554: PPUSH
106555: LD_VAR 0 2
106559: PPUSH
106560: CALL_OW 259
106564: PPUSH
106565: CALL_OW 2
106569: ST_TO_ADDR
106570: GO 106528
106572: POP
106573: POP
// if not tmp then
106574: LD_VAR 0 5
106578: NOT
106579: IFFALSE 106583
// exit ;
106581: GO 106603
// result := SortListByListDesc ( units , tmp ) ;
106583: LD_ADDR_VAR 0 3
106587: PUSH
106588: LD_VAR 0 1
106592: PPUSH
106593: LD_VAR 0 5
106597: PPUSH
106598: CALL_OW 77
106602: ST_TO_ADDR
// end ;
106603: LD_VAR 0 3
106607: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106608: LD_INT 0
106610: PPUSH
106611: PPUSH
106612: PPUSH
// x := GetX ( building ) ;
106613: LD_ADDR_VAR 0 4
106617: PUSH
106618: LD_VAR 0 2
106622: PPUSH
106623: CALL_OW 250
106627: ST_TO_ADDR
// y := GetY ( building ) ;
106628: LD_ADDR_VAR 0 5
106632: PUSH
106633: LD_VAR 0 2
106637: PPUSH
106638: CALL_OW 251
106642: ST_TO_ADDR
// if GetTaskList ( unit ) then
106643: LD_VAR 0 1
106647: PPUSH
106648: CALL_OW 437
106652: IFFALSE 106747
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106654: LD_STRING e
106656: PUSH
106657: LD_VAR 0 1
106661: PPUSH
106662: CALL_OW 437
106666: PUSH
106667: LD_INT 1
106669: ARRAY
106670: PUSH
106671: LD_INT 1
106673: ARRAY
106674: EQUAL
106675: PUSH
106676: LD_VAR 0 4
106680: PUSH
106681: LD_VAR 0 1
106685: PPUSH
106686: CALL_OW 437
106690: PUSH
106691: LD_INT 1
106693: ARRAY
106694: PUSH
106695: LD_INT 2
106697: ARRAY
106698: EQUAL
106699: AND
106700: PUSH
106701: LD_VAR 0 5
106705: PUSH
106706: LD_VAR 0 1
106710: PPUSH
106711: CALL_OW 437
106715: PUSH
106716: LD_INT 1
106718: ARRAY
106719: PUSH
106720: LD_INT 3
106722: ARRAY
106723: EQUAL
106724: AND
106725: IFFALSE 106737
// result := true else
106727: LD_ADDR_VAR 0 3
106731: PUSH
106732: LD_INT 1
106734: ST_TO_ADDR
106735: GO 106745
// result := false ;
106737: LD_ADDR_VAR 0 3
106741: PUSH
106742: LD_INT 0
106744: ST_TO_ADDR
// end else
106745: GO 106755
// result := false ;
106747: LD_ADDR_VAR 0 3
106751: PUSH
106752: LD_INT 0
106754: ST_TO_ADDR
// end ;
106755: LD_VAR 0 3
106759: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106760: LD_INT 0
106762: PPUSH
106763: PPUSH
106764: PPUSH
106765: PPUSH
// if not unit or not area then
106766: LD_VAR 0 1
106770: NOT
106771: PUSH
106772: LD_VAR 0 2
106776: NOT
106777: OR
106778: IFFALSE 106782
// exit ;
106780: GO 106946
// tmp := AreaToList ( area , i ) ;
106782: LD_ADDR_VAR 0 6
106786: PUSH
106787: LD_VAR 0 2
106791: PPUSH
106792: LD_VAR 0 5
106796: PPUSH
106797: CALL_OW 517
106801: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106802: LD_ADDR_VAR 0 5
106806: PUSH
106807: DOUBLE
106808: LD_INT 1
106810: DEC
106811: ST_TO_ADDR
106812: LD_VAR 0 6
106816: PUSH
106817: LD_INT 1
106819: ARRAY
106820: PUSH
106821: FOR_TO
106822: IFFALSE 106944
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106824: LD_ADDR_VAR 0 7
106828: PUSH
106829: LD_VAR 0 6
106833: PUSH
106834: LD_INT 1
106836: ARRAY
106837: PUSH
106838: LD_VAR 0 5
106842: ARRAY
106843: PUSH
106844: LD_VAR 0 6
106848: PUSH
106849: LD_INT 2
106851: ARRAY
106852: PUSH
106853: LD_VAR 0 5
106857: ARRAY
106858: PUSH
106859: EMPTY
106860: LIST
106861: LIST
106862: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106863: LD_VAR 0 7
106867: PUSH
106868: LD_INT 1
106870: ARRAY
106871: PPUSH
106872: LD_VAR 0 7
106876: PUSH
106877: LD_INT 2
106879: ARRAY
106880: PPUSH
106881: CALL_OW 428
106885: PUSH
106886: LD_INT 0
106888: EQUAL
106889: IFFALSE 106942
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106891: LD_VAR 0 1
106895: PPUSH
106896: LD_VAR 0 7
106900: PUSH
106901: LD_INT 1
106903: ARRAY
106904: PPUSH
106905: LD_VAR 0 7
106909: PUSH
106910: LD_INT 2
106912: ARRAY
106913: PPUSH
106914: LD_VAR 0 3
106918: PPUSH
106919: CALL_OW 48
// result := IsPlaced ( unit ) ;
106923: LD_ADDR_VAR 0 4
106927: PUSH
106928: LD_VAR 0 1
106932: PPUSH
106933: CALL_OW 305
106937: ST_TO_ADDR
// exit ;
106938: POP
106939: POP
106940: GO 106946
// end ; end ;
106942: GO 106821
106944: POP
106945: POP
// end ;
106946: LD_VAR 0 4
106950: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106951: LD_INT 0
106953: PPUSH
106954: PPUSH
106955: PPUSH
// if not side or side > 8 then
106956: LD_VAR 0 1
106960: NOT
106961: PUSH
106962: LD_VAR 0 1
106966: PUSH
106967: LD_INT 8
106969: GREATER
106970: OR
106971: IFFALSE 106975
// exit ;
106973: GO 107162
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106975: LD_ADDR_VAR 0 4
106979: PUSH
106980: LD_INT 22
106982: PUSH
106983: LD_VAR 0 1
106987: PUSH
106988: EMPTY
106989: LIST
106990: LIST
106991: PUSH
106992: LD_INT 21
106994: PUSH
106995: LD_INT 3
106997: PUSH
106998: EMPTY
106999: LIST
107000: LIST
107001: PUSH
107002: EMPTY
107003: LIST
107004: LIST
107005: PPUSH
107006: CALL_OW 69
107010: ST_TO_ADDR
// if not tmp then
107011: LD_VAR 0 4
107015: NOT
107016: IFFALSE 107020
// exit ;
107018: GO 107162
// enable_addtolog := true ;
107020: LD_ADDR_OWVAR 81
107024: PUSH
107025: LD_INT 1
107027: ST_TO_ADDR
// AddToLog ( [ ) ;
107028: LD_STRING [
107030: PPUSH
107031: CALL_OW 561
// for i in tmp do
107035: LD_ADDR_VAR 0 3
107039: PUSH
107040: LD_VAR 0 4
107044: PUSH
107045: FOR_IN
107046: IFFALSE 107153
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107048: LD_STRING [
107050: PUSH
107051: LD_VAR 0 3
107055: PPUSH
107056: CALL_OW 266
107060: STR
107061: PUSH
107062: LD_STRING , 
107064: STR
107065: PUSH
107066: LD_VAR 0 3
107070: PPUSH
107071: CALL_OW 250
107075: STR
107076: PUSH
107077: LD_STRING , 
107079: STR
107080: PUSH
107081: LD_VAR 0 3
107085: PPUSH
107086: CALL_OW 251
107090: STR
107091: PUSH
107092: LD_STRING , 
107094: STR
107095: PUSH
107096: LD_VAR 0 3
107100: PPUSH
107101: CALL_OW 254
107105: STR
107106: PUSH
107107: LD_STRING , 
107109: STR
107110: PUSH
107111: LD_VAR 0 3
107115: PPUSH
107116: LD_INT 1
107118: PPUSH
107119: CALL_OW 268
107123: STR
107124: PUSH
107125: LD_STRING , 
107127: STR
107128: PUSH
107129: LD_VAR 0 3
107133: PPUSH
107134: LD_INT 2
107136: PPUSH
107137: CALL_OW 268
107141: STR
107142: PUSH
107143: LD_STRING ],
107145: STR
107146: PPUSH
107147: CALL_OW 561
// end ;
107151: GO 107045
107153: POP
107154: POP
// AddToLog ( ]; ) ;
107155: LD_STRING ];
107157: PPUSH
107158: CALL_OW 561
// end ;
107162: LD_VAR 0 2
107166: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107167: LD_INT 0
107169: PPUSH
107170: PPUSH
107171: PPUSH
107172: PPUSH
107173: PPUSH
// if not area or not rate or not max then
107174: LD_VAR 0 1
107178: NOT
107179: PUSH
107180: LD_VAR 0 2
107184: NOT
107185: OR
107186: PUSH
107187: LD_VAR 0 4
107191: NOT
107192: OR
107193: IFFALSE 107197
// exit ;
107195: GO 107389
// while 1 do
107197: LD_INT 1
107199: IFFALSE 107389
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107201: LD_ADDR_VAR 0 9
107205: PUSH
107206: LD_VAR 0 1
107210: PPUSH
107211: LD_INT 1
107213: PPUSH
107214: CALL_OW 287
107218: PUSH
107219: LD_INT 10
107221: MUL
107222: ST_TO_ADDR
// r := rate / 10 ;
107223: LD_ADDR_VAR 0 7
107227: PUSH
107228: LD_VAR 0 2
107232: PUSH
107233: LD_INT 10
107235: DIVREAL
107236: ST_TO_ADDR
// time := 1 1$00 ;
107237: LD_ADDR_VAR 0 8
107241: PUSH
107242: LD_INT 2100
107244: ST_TO_ADDR
// if amount < min then
107245: LD_VAR 0 9
107249: PUSH
107250: LD_VAR 0 3
107254: LESS
107255: IFFALSE 107273
// r := r * 2 else
107257: LD_ADDR_VAR 0 7
107261: PUSH
107262: LD_VAR 0 7
107266: PUSH
107267: LD_INT 2
107269: MUL
107270: ST_TO_ADDR
107271: GO 107299
// if amount > max then
107273: LD_VAR 0 9
107277: PUSH
107278: LD_VAR 0 4
107282: GREATER
107283: IFFALSE 107299
// r := r / 2 ;
107285: LD_ADDR_VAR 0 7
107289: PUSH
107290: LD_VAR 0 7
107294: PUSH
107295: LD_INT 2
107297: DIVREAL
107298: ST_TO_ADDR
// time := time / r ;
107299: LD_ADDR_VAR 0 8
107303: PUSH
107304: LD_VAR 0 8
107308: PUSH
107309: LD_VAR 0 7
107313: DIVREAL
107314: ST_TO_ADDR
// if time < 0 then
107315: LD_VAR 0 8
107319: PUSH
107320: LD_INT 0
107322: LESS
107323: IFFALSE 107340
// time := time * - 1 ;
107325: LD_ADDR_VAR 0 8
107329: PUSH
107330: LD_VAR 0 8
107334: PUSH
107335: LD_INT 1
107337: NEG
107338: MUL
107339: ST_TO_ADDR
// wait ( time ) ;
107340: LD_VAR 0 8
107344: PPUSH
107345: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107349: LD_INT 35
107351: PPUSH
107352: LD_INT 875
107354: PPUSH
107355: CALL_OW 12
107359: PPUSH
107360: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107364: LD_INT 1
107366: PPUSH
107367: LD_INT 5
107369: PPUSH
107370: CALL_OW 12
107374: PPUSH
107375: LD_VAR 0 1
107379: PPUSH
107380: LD_INT 1
107382: PPUSH
107383: CALL_OW 55
// end ;
107387: GO 107197
// end ;
107389: LD_VAR 0 5
107393: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107394: LD_INT 0
107396: PPUSH
107397: PPUSH
107398: PPUSH
107399: PPUSH
107400: PPUSH
107401: PPUSH
107402: PPUSH
107403: PPUSH
// if not turrets or not factories then
107404: LD_VAR 0 1
107408: NOT
107409: PUSH
107410: LD_VAR 0 2
107414: NOT
107415: OR
107416: IFFALSE 107420
// exit ;
107418: GO 107727
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107420: LD_ADDR_VAR 0 10
107424: PUSH
107425: LD_INT 5
107427: PUSH
107428: LD_INT 6
107430: PUSH
107431: EMPTY
107432: LIST
107433: LIST
107434: PUSH
107435: LD_INT 2
107437: PUSH
107438: LD_INT 4
107440: PUSH
107441: EMPTY
107442: LIST
107443: LIST
107444: PUSH
107445: LD_INT 3
107447: PUSH
107448: LD_INT 5
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: PUSH
107455: EMPTY
107456: LIST
107457: LIST
107458: LIST
107459: PUSH
107460: LD_INT 24
107462: PUSH
107463: LD_INT 25
107465: PUSH
107466: EMPTY
107467: LIST
107468: LIST
107469: PUSH
107470: LD_INT 23
107472: PUSH
107473: LD_INT 27
107475: PUSH
107476: EMPTY
107477: LIST
107478: LIST
107479: PUSH
107480: EMPTY
107481: LIST
107482: LIST
107483: PUSH
107484: LD_INT 42
107486: PUSH
107487: LD_INT 43
107489: PUSH
107490: EMPTY
107491: LIST
107492: LIST
107493: PUSH
107494: LD_INT 44
107496: PUSH
107497: LD_INT 46
107499: PUSH
107500: EMPTY
107501: LIST
107502: LIST
107503: PUSH
107504: LD_INT 45
107506: PUSH
107507: LD_INT 47
107509: PUSH
107510: EMPTY
107511: LIST
107512: LIST
107513: PUSH
107514: EMPTY
107515: LIST
107516: LIST
107517: LIST
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: LIST
107523: ST_TO_ADDR
// result := [ ] ;
107524: LD_ADDR_VAR 0 3
107528: PUSH
107529: EMPTY
107530: ST_TO_ADDR
// for i in turrets do
107531: LD_ADDR_VAR 0 4
107535: PUSH
107536: LD_VAR 0 1
107540: PUSH
107541: FOR_IN
107542: IFFALSE 107725
// begin nat := GetNation ( i ) ;
107544: LD_ADDR_VAR 0 7
107548: PUSH
107549: LD_VAR 0 4
107553: PPUSH
107554: CALL_OW 248
107558: ST_TO_ADDR
// weapon := 0 ;
107559: LD_ADDR_VAR 0 8
107563: PUSH
107564: LD_INT 0
107566: ST_TO_ADDR
// if not nat then
107567: LD_VAR 0 7
107571: NOT
107572: IFFALSE 107576
// continue ;
107574: GO 107541
// for j in list [ nat ] do
107576: LD_ADDR_VAR 0 5
107580: PUSH
107581: LD_VAR 0 10
107585: PUSH
107586: LD_VAR 0 7
107590: ARRAY
107591: PUSH
107592: FOR_IN
107593: IFFALSE 107634
// if GetBWeapon ( i ) = j [ 1 ] then
107595: LD_VAR 0 4
107599: PPUSH
107600: CALL_OW 269
107604: PUSH
107605: LD_VAR 0 5
107609: PUSH
107610: LD_INT 1
107612: ARRAY
107613: EQUAL
107614: IFFALSE 107632
// begin weapon := j [ 2 ] ;
107616: LD_ADDR_VAR 0 8
107620: PUSH
107621: LD_VAR 0 5
107625: PUSH
107626: LD_INT 2
107628: ARRAY
107629: ST_TO_ADDR
// break ;
107630: GO 107634
// end ;
107632: GO 107592
107634: POP
107635: POP
// if not weapon then
107636: LD_VAR 0 8
107640: NOT
107641: IFFALSE 107645
// continue ;
107643: GO 107541
// for k in factories do
107645: LD_ADDR_VAR 0 6
107649: PUSH
107650: LD_VAR 0 2
107654: PUSH
107655: FOR_IN
107656: IFFALSE 107721
// begin weapons := AvailableWeaponList ( k ) ;
107658: LD_ADDR_VAR 0 9
107662: PUSH
107663: LD_VAR 0 6
107667: PPUSH
107668: CALL_OW 478
107672: ST_TO_ADDR
// if not weapons then
107673: LD_VAR 0 9
107677: NOT
107678: IFFALSE 107682
// continue ;
107680: GO 107655
// if weapon in weapons then
107682: LD_VAR 0 8
107686: PUSH
107687: LD_VAR 0 9
107691: IN
107692: IFFALSE 107719
// begin result := [ i , weapon ] ;
107694: LD_ADDR_VAR 0 3
107698: PUSH
107699: LD_VAR 0 4
107703: PUSH
107704: LD_VAR 0 8
107708: PUSH
107709: EMPTY
107710: LIST
107711: LIST
107712: ST_TO_ADDR
// exit ;
107713: POP
107714: POP
107715: POP
107716: POP
107717: GO 107727
// end ; end ;
107719: GO 107655
107721: POP
107722: POP
// end ;
107723: GO 107541
107725: POP
107726: POP
// end ;
107727: LD_VAR 0 3
107731: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107732: LD_INT 0
107734: PPUSH
// if not side or side > 8 then
107735: LD_VAR 0 3
107739: NOT
107740: PUSH
107741: LD_VAR 0 3
107745: PUSH
107746: LD_INT 8
107748: GREATER
107749: OR
107750: IFFALSE 107754
// exit ;
107752: GO 107813
// if not range then
107754: LD_VAR 0 4
107758: NOT
107759: IFFALSE 107770
// range := - 12 ;
107761: LD_ADDR_VAR 0 4
107765: PUSH
107766: LD_INT 12
107768: NEG
107769: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107770: LD_VAR 0 1
107774: PPUSH
107775: LD_VAR 0 2
107779: PPUSH
107780: LD_VAR 0 3
107784: PPUSH
107785: LD_VAR 0 4
107789: PPUSH
107790: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107794: LD_VAR 0 1
107798: PPUSH
107799: LD_VAR 0 2
107803: PPUSH
107804: LD_VAR 0 3
107808: PPUSH
107809: CALL_OW 331
// end ;
107813: LD_VAR 0 5
107817: RET
// export function Video ( mode ) ; begin
107818: LD_INT 0
107820: PPUSH
// ingame_video = mode ;
107821: LD_ADDR_OWVAR 52
107825: PUSH
107826: LD_VAR 0 1
107830: ST_TO_ADDR
// interface_hidden = mode ;
107831: LD_ADDR_OWVAR 54
107835: PUSH
107836: LD_VAR 0 1
107840: ST_TO_ADDR
// end ;
107841: LD_VAR 0 2
107845: RET
// export function Join ( array , element ) ; begin
107846: LD_INT 0
107848: PPUSH
// result := array ^ element ;
107849: LD_ADDR_VAR 0 3
107853: PUSH
107854: LD_VAR 0 1
107858: PUSH
107859: LD_VAR 0 2
107863: ADD
107864: ST_TO_ADDR
// end ;
107865: LD_VAR 0 3
107869: RET
// export function JoinUnion ( array , element ) ; begin
107870: LD_INT 0
107872: PPUSH
// result := array union element ;
107873: LD_ADDR_VAR 0 3
107877: PUSH
107878: LD_VAR 0 1
107882: PUSH
107883: LD_VAR 0 2
107887: UNION
107888: ST_TO_ADDR
// end ;
107889: LD_VAR 0 3
107893: RET
// export function GetBehemoths ( side ) ; begin
107894: LD_INT 0
107896: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107897: LD_ADDR_VAR 0 2
107901: PUSH
107902: LD_INT 22
107904: PUSH
107905: LD_VAR 0 1
107909: PUSH
107910: EMPTY
107911: LIST
107912: LIST
107913: PUSH
107914: LD_INT 31
107916: PUSH
107917: LD_INT 25
107919: PUSH
107920: EMPTY
107921: LIST
107922: LIST
107923: PUSH
107924: EMPTY
107925: LIST
107926: LIST
107927: PPUSH
107928: CALL_OW 69
107932: ST_TO_ADDR
// end ;
107933: LD_VAR 0 2
107937: RET
// export function Shuffle ( array ) ; var i , index ; begin
107938: LD_INT 0
107940: PPUSH
107941: PPUSH
107942: PPUSH
// result := [ ] ;
107943: LD_ADDR_VAR 0 2
107947: PUSH
107948: EMPTY
107949: ST_TO_ADDR
// if not array then
107950: LD_VAR 0 1
107954: NOT
107955: IFFALSE 107959
// exit ;
107957: GO 108058
// Randomize ;
107959: CALL_OW 10
// for i = array downto 1 do
107963: LD_ADDR_VAR 0 3
107967: PUSH
107968: DOUBLE
107969: LD_VAR 0 1
107973: INC
107974: ST_TO_ADDR
107975: LD_INT 1
107977: PUSH
107978: FOR_DOWNTO
107979: IFFALSE 108056
// begin index := rand ( 1 , array ) ;
107981: LD_ADDR_VAR 0 4
107985: PUSH
107986: LD_INT 1
107988: PPUSH
107989: LD_VAR 0 1
107993: PPUSH
107994: CALL_OW 12
107998: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107999: LD_ADDR_VAR 0 2
108003: PUSH
108004: LD_VAR 0 2
108008: PPUSH
108009: LD_VAR 0 2
108013: PUSH
108014: LD_INT 1
108016: PLUS
108017: PPUSH
108018: LD_VAR 0 1
108022: PUSH
108023: LD_VAR 0 4
108027: ARRAY
108028: PPUSH
108029: CALL_OW 2
108033: ST_TO_ADDR
// array := Delete ( array , index ) ;
108034: LD_ADDR_VAR 0 1
108038: PUSH
108039: LD_VAR 0 1
108043: PPUSH
108044: LD_VAR 0 4
108048: PPUSH
108049: CALL_OW 3
108053: ST_TO_ADDR
// end ;
108054: GO 107978
108056: POP
108057: POP
// end ;
108058: LD_VAR 0 2
108062: RET
// export function GetBaseMaterials ( base ) ; begin
108063: LD_INT 0
108065: PPUSH
// result := [ 0 , 0 , 0 ] ;
108066: LD_ADDR_VAR 0 2
108070: PUSH
108071: LD_INT 0
108073: PUSH
108074: LD_INT 0
108076: PUSH
108077: LD_INT 0
108079: PUSH
108080: EMPTY
108081: LIST
108082: LIST
108083: LIST
108084: ST_TO_ADDR
// if not base then
108085: LD_VAR 0 1
108089: NOT
108090: IFFALSE 108094
// exit ;
108092: GO 108143
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108094: LD_ADDR_VAR 0 2
108098: PUSH
108099: LD_VAR 0 1
108103: PPUSH
108104: LD_INT 1
108106: PPUSH
108107: CALL_OW 275
108111: PUSH
108112: LD_VAR 0 1
108116: PPUSH
108117: LD_INT 2
108119: PPUSH
108120: CALL_OW 275
108124: PUSH
108125: LD_VAR 0 1
108129: PPUSH
108130: LD_INT 3
108132: PPUSH
108133: CALL_OW 275
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: LIST
108142: ST_TO_ADDR
// end ; end_of_file end_of_file
108143: LD_VAR 0 2
108147: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
108148: GO 108150
108150: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108151: LD_STRING initStreamRollete();
108153: PPUSH
108154: CALL_OW 559
// InitStreamMode ;
108158: CALL 108167 0 0
// DefineStreamItems ( ) ;
108162: CALL 108607 0 0
// end ;
108166: END
// function InitStreamMode ; begin
108167: LD_INT 0
108169: PPUSH
// streamModeActive := false ;
108170: LD_ADDR_EXP 145
108174: PUSH
108175: LD_INT 0
108177: ST_TO_ADDR
// normalCounter := 36 ;
108178: LD_ADDR_EXP 146
108182: PUSH
108183: LD_INT 36
108185: ST_TO_ADDR
// hardcoreCounter := 16 ;
108186: LD_ADDR_EXP 147
108190: PUSH
108191: LD_INT 16
108193: ST_TO_ADDR
// sRocket := false ;
108194: LD_ADDR_EXP 150
108198: PUSH
108199: LD_INT 0
108201: ST_TO_ADDR
// sSpeed := false ;
108202: LD_ADDR_EXP 149
108206: PUSH
108207: LD_INT 0
108209: ST_TO_ADDR
// sEngine := false ;
108210: LD_ADDR_EXP 151
108214: PUSH
108215: LD_INT 0
108217: ST_TO_ADDR
// sSpec := false ;
108218: LD_ADDR_EXP 148
108222: PUSH
108223: LD_INT 0
108225: ST_TO_ADDR
// sLevel := false ;
108226: LD_ADDR_EXP 152
108230: PUSH
108231: LD_INT 0
108233: ST_TO_ADDR
// sArmoury := false ;
108234: LD_ADDR_EXP 153
108238: PUSH
108239: LD_INT 0
108241: ST_TO_ADDR
// sRadar := false ;
108242: LD_ADDR_EXP 154
108246: PUSH
108247: LD_INT 0
108249: ST_TO_ADDR
// sBunker := false ;
108250: LD_ADDR_EXP 155
108254: PUSH
108255: LD_INT 0
108257: ST_TO_ADDR
// sHack := false ;
108258: LD_ADDR_EXP 156
108262: PUSH
108263: LD_INT 0
108265: ST_TO_ADDR
// sFire := false ;
108266: LD_ADDR_EXP 157
108270: PUSH
108271: LD_INT 0
108273: ST_TO_ADDR
// sRefresh := false ;
108274: LD_ADDR_EXP 158
108278: PUSH
108279: LD_INT 0
108281: ST_TO_ADDR
// sExp := false ;
108282: LD_ADDR_EXP 159
108286: PUSH
108287: LD_INT 0
108289: ST_TO_ADDR
// sDepot := false ;
108290: LD_ADDR_EXP 160
108294: PUSH
108295: LD_INT 0
108297: ST_TO_ADDR
// sFlag := false ;
108298: LD_ADDR_EXP 161
108302: PUSH
108303: LD_INT 0
108305: ST_TO_ADDR
// sKamikadze := false ;
108306: LD_ADDR_EXP 169
108310: PUSH
108311: LD_INT 0
108313: ST_TO_ADDR
// sTroll := false ;
108314: LD_ADDR_EXP 170
108318: PUSH
108319: LD_INT 0
108321: ST_TO_ADDR
// sSlow := false ;
108322: LD_ADDR_EXP 171
108326: PUSH
108327: LD_INT 0
108329: ST_TO_ADDR
// sLack := false ;
108330: LD_ADDR_EXP 172
108334: PUSH
108335: LD_INT 0
108337: ST_TO_ADDR
// sTank := false ;
108338: LD_ADDR_EXP 174
108342: PUSH
108343: LD_INT 0
108345: ST_TO_ADDR
// sRemote := false ;
108346: LD_ADDR_EXP 175
108350: PUSH
108351: LD_INT 0
108353: ST_TO_ADDR
// sPowell := false ;
108354: LD_ADDR_EXP 176
108358: PUSH
108359: LD_INT 0
108361: ST_TO_ADDR
// sTeleport := false ;
108362: LD_ADDR_EXP 179
108366: PUSH
108367: LD_INT 0
108369: ST_TO_ADDR
// sOilTower := false ;
108370: LD_ADDR_EXP 181
108374: PUSH
108375: LD_INT 0
108377: ST_TO_ADDR
// sShovel := false ;
108378: LD_ADDR_EXP 182
108382: PUSH
108383: LD_INT 0
108385: ST_TO_ADDR
// sSheik := false ;
108386: LD_ADDR_EXP 183
108390: PUSH
108391: LD_INT 0
108393: ST_TO_ADDR
// sEarthquake := false ;
108394: LD_ADDR_EXP 185
108398: PUSH
108399: LD_INT 0
108401: ST_TO_ADDR
// sAI := false ;
108402: LD_ADDR_EXP 186
108406: PUSH
108407: LD_INT 0
108409: ST_TO_ADDR
// sCargo := false ;
108410: LD_ADDR_EXP 189
108414: PUSH
108415: LD_INT 0
108417: ST_TO_ADDR
// sDLaser := false ;
108418: LD_ADDR_EXP 190
108422: PUSH
108423: LD_INT 0
108425: ST_TO_ADDR
// sExchange := false ;
108426: LD_ADDR_EXP 191
108430: PUSH
108431: LD_INT 0
108433: ST_TO_ADDR
// sFac := false ;
108434: LD_ADDR_EXP 192
108438: PUSH
108439: LD_INT 0
108441: ST_TO_ADDR
// sPower := false ;
108442: LD_ADDR_EXP 193
108446: PUSH
108447: LD_INT 0
108449: ST_TO_ADDR
// sRandom := false ;
108450: LD_ADDR_EXP 194
108454: PUSH
108455: LD_INT 0
108457: ST_TO_ADDR
// sShield := false ;
108458: LD_ADDR_EXP 195
108462: PUSH
108463: LD_INT 0
108465: ST_TO_ADDR
// sTime := false ;
108466: LD_ADDR_EXP 196
108470: PUSH
108471: LD_INT 0
108473: ST_TO_ADDR
// sTools := false ;
108474: LD_ADDR_EXP 197
108478: PUSH
108479: LD_INT 0
108481: ST_TO_ADDR
// sSold := false ;
108482: LD_ADDR_EXP 162
108486: PUSH
108487: LD_INT 0
108489: ST_TO_ADDR
// sDiff := false ;
108490: LD_ADDR_EXP 163
108494: PUSH
108495: LD_INT 0
108497: ST_TO_ADDR
// sFog := false ;
108498: LD_ADDR_EXP 166
108502: PUSH
108503: LD_INT 0
108505: ST_TO_ADDR
// sReset := false ;
108506: LD_ADDR_EXP 167
108510: PUSH
108511: LD_INT 0
108513: ST_TO_ADDR
// sSun := false ;
108514: LD_ADDR_EXP 168
108518: PUSH
108519: LD_INT 0
108521: ST_TO_ADDR
// sTiger := false ;
108522: LD_ADDR_EXP 164
108526: PUSH
108527: LD_INT 0
108529: ST_TO_ADDR
// sBomb := false ;
108530: LD_ADDR_EXP 165
108534: PUSH
108535: LD_INT 0
108537: ST_TO_ADDR
// sWound := false ;
108538: LD_ADDR_EXP 173
108542: PUSH
108543: LD_INT 0
108545: ST_TO_ADDR
// sBetray := false ;
108546: LD_ADDR_EXP 177
108550: PUSH
108551: LD_INT 0
108553: ST_TO_ADDR
// sContamin := false ;
108554: LD_ADDR_EXP 178
108558: PUSH
108559: LD_INT 0
108561: ST_TO_ADDR
// sOil := false ;
108562: LD_ADDR_EXP 180
108566: PUSH
108567: LD_INT 0
108569: ST_TO_ADDR
// sStu := false ;
108570: LD_ADDR_EXP 184
108574: PUSH
108575: LD_INT 0
108577: ST_TO_ADDR
// sBazooka := false ;
108578: LD_ADDR_EXP 187
108582: PUSH
108583: LD_INT 0
108585: ST_TO_ADDR
// sMortar := false ;
108586: LD_ADDR_EXP 188
108590: PUSH
108591: LD_INT 0
108593: ST_TO_ADDR
// sRanger := false ;
108594: LD_ADDR_EXP 198
108598: PUSH
108599: LD_INT 0
108601: ST_TO_ADDR
// end ;
108602: LD_VAR 0 1
108606: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
108607: LD_INT 0
108609: PPUSH
108610: PPUSH
108611: PPUSH
108612: PPUSH
108613: PPUSH
// result := [ ] ;
108614: LD_ADDR_VAR 0 1
108618: PUSH
108619: EMPTY
108620: ST_TO_ADDR
// if campaign_id = 1 then
108621: LD_OWVAR 69
108625: PUSH
108626: LD_INT 1
108628: EQUAL
108629: IFFALSE 111567
// begin case mission_number of 1 :
108631: LD_OWVAR 70
108635: PUSH
108636: LD_INT 1
108638: DOUBLE
108639: EQUAL
108640: IFTRUE 108644
108642: GO 108708
108644: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
108645: LD_ADDR_VAR 0 1
108649: PUSH
108650: LD_INT 2
108652: PUSH
108653: LD_INT 4
108655: PUSH
108656: LD_INT 11
108658: PUSH
108659: LD_INT 12
108661: PUSH
108662: LD_INT 15
108664: PUSH
108665: LD_INT 16
108667: PUSH
108668: LD_INT 22
108670: PUSH
108671: LD_INT 23
108673: PUSH
108674: LD_INT 26
108676: PUSH
108677: EMPTY
108678: LIST
108679: LIST
108680: LIST
108681: LIST
108682: LIST
108683: LIST
108684: LIST
108685: LIST
108686: LIST
108687: PUSH
108688: LD_INT 101
108690: PUSH
108691: LD_INT 102
108693: PUSH
108694: LD_INT 106
108696: PUSH
108697: EMPTY
108698: LIST
108699: LIST
108700: LIST
108701: PUSH
108702: EMPTY
108703: LIST
108704: LIST
108705: ST_TO_ADDR
108706: GO 111565
108708: LD_INT 2
108710: DOUBLE
108711: EQUAL
108712: IFTRUE 108716
108714: GO 108788
108716: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
108717: LD_ADDR_VAR 0 1
108721: PUSH
108722: LD_INT 2
108724: PUSH
108725: LD_INT 4
108727: PUSH
108728: LD_INT 11
108730: PUSH
108731: LD_INT 12
108733: PUSH
108734: LD_INT 15
108736: PUSH
108737: LD_INT 16
108739: PUSH
108740: LD_INT 22
108742: PUSH
108743: LD_INT 23
108745: PUSH
108746: LD_INT 26
108748: PUSH
108749: EMPTY
108750: LIST
108751: LIST
108752: LIST
108753: LIST
108754: LIST
108755: LIST
108756: LIST
108757: LIST
108758: LIST
108759: PUSH
108760: LD_INT 101
108762: PUSH
108763: LD_INT 102
108765: PUSH
108766: LD_INT 105
108768: PUSH
108769: LD_INT 106
108771: PUSH
108772: LD_INT 108
108774: PUSH
108775: EMPTY
108776: LIST
108777: LIST
108778: LIST
108779: LIST
108780: LIST
108781: PUSH
108782: EMPTY
108783: LIST
108784: LIST
108785: ST_TO_ADDR
108786: GO 111565
108788: LD_INT 3
108790: DOUBLE
108791: EQUAL
108792: IFTRUE 108796
108794: GO 108872
108796: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
108797: LD_ADDR_VAR 0 1
108801: PUSH
108802: LD_INT 2
108804: PUSH
108805: LD_INT 4
108807: PUSH
108808: LD_INT 5
108810: PUSH
108811: LD_INT 11
108813: PUSH
108814: LD_INT 12
108816: PUSH
108817: LD_INT 15
108819: PUSH
108820: LD_INT 16
108822: PUSH
108823: LD_INT 22
108825: PUSH
108826: LD_INT 26
108828: PUSH
108829: LD_INT 36
108831: PUSH
108832: EMPTY
108833: LIST
108834: LIST
108835: LIST
108836: LIST
108837: LIST
108838: LIST
108839: LIST
108840: LIST
108841: LIST
108842: LIST
108843: PUSH
108844: LD_INT 101
108846: PUSH
108847: LD_INT 102
108849: PUSH
108850: LD_INT 105
108852: PUSH
108853: LD_INT 106
108855: PUSH
108856: LD_INT 108
108858: PUSH
108859: EMPTY
108860: LIST
108861: LIST
108862: LIST
108863: LIST
108864: LIST
108865: PUSH
108866: EMPTY
108867: LIST
108868: LIST
108869: ST_TO_ADDR
108870: GO 111565
108872: LD_INT 4
108874: DOUBLE
108875: EQUAL
108876: IFTRUE 108880
108878: GO 108964
108880: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
108881: LD_ADDR_VAR 0 1
108885: PUSH
108886: LD_INT 2
108888: PUSH
108889: LD_INT 4
108891: PUSH
108892: LD_INT 5
108894: PUSH
108895: LD_INT 8
108897: PUSH
108898: LD_INT 11
108900: PUSH
108901: LD_INT 12
108903: PUSH
108904: LD_INT 15
108906: PUSH
108907: LD_INT 16
108909: PUSH
108910: LD_INT 22
108912: PUSH
108913: LD_INT 23
108915: PUSH
108916: LD_INT 26
108918: PUSH
108919: LD_INT 36
108921: PUSH
108922: EMPTY
108923: LIST
108924: LIST
108925: LIST
108926: LIST
108927: LIST
108928: LIST
108929: LIST
108930: LIST
108931: LIST
108932: LIST
108933: LIST
108934: LIST
108935: PUSH
108936: LD_INT 101
108938: PUSH
108939: LD_INT 102
108941: PUSH
108942: LD_INT 105
108944: PUSH
108945: LD_INT 106
108947: PUSH
108948: LD_INT 108
108950: PUSH
108951: EMPTY
108952: LIST
108953: LIST
108954: LIST
108955: LIST
108956: LIST
108957: PUSH
108958: EMPTY
108959: LIST
108960: LIST
108961: ST_TO_ADDR
108962: GO 111565
108964: LD_INT 5
108966: DOUBLE
108967: EQUAL
108968: IFTRUE 108972
108970: GO 109072
108972: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
108973: LD_ADDR_VAR 0 1
108977: PUSH
108978: LD_INT 2
108980: PUSH
108981: LD_INT 4
108983: PUSH
108984: LD_INT 5
108986: PUSH
108987: LD_INT 6
108989: PUSH
108990: LD_INT 8
108992: PUSH
108993: LD_INT 11
108995: PUSH
108996: LD_INT 12
108998: PUSH
108999: LD_INT 15
109001: PUSH
109002: LD_INT 16
109004: PUSH
109005: LD_INT 22
109007: PUSH
109008: LD_INT 23
109010: PUSH
109011: LD_INT 25
109013: PUSH
109014: LD_INT 26
109016: PUSH
109017: LD_INT 36
109019: PUSH
109020: EMPTY
109021: LIST
109022: LIST
109023: LIST
109024: LIST
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: LIST
109030: LIST
109031: LIST
109032: LIST
109033: LIST
109034: LIST
109035: PUSH
109036: LD_INT 101
109038: PUSH
109039: LD_INT 102
109041: PUSH
109042: LD_INT 105
109044: PUSH
109045: LD_INT 106
109047: PUSH
109048: LD_INT 108
109050: PUSH
109051: LD_INT 109
109053: PUSH
109054: LD_INT 112
109056: PUSH
109057: EMPTY
109058: LIST
109059: LIST
109060: LIST
109061: LIST
109062: LIST
109063: LIST
109064: LIST
109065: PUSH
109066: EMPTY
109067: LIST
109068: LIST
109069: ST_TO_ADDR
109070: GO 111565
109072: LD_INT 6
109074: DOUBLE
109075: EQUAL
109076: IFTRUE 109080
109078: GO 109200
109080: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
109081: LD_ADDR_VAR 0 1
109085: PUSH
109086: LD_INT 2
109088: PUSH
109089: LD_INT 4
109091: PUSH
109092: LD_INT 5
109094: PUSH
109095: LD_INT 6
109097: PUSH
109098: LD_INT 8
109100: PUSH
109101: LD_INT 11
109103: PUSH
109104: LD_INT 12
109106: PUSH
109107: LD_INT 15
109109: PUSH
109110: LD_INT 16
109112: PUSH
109113: LD_INT 20
109115: PUSH
109116: LD_INT 21
109118: PUSH
109119: LD_INT 22
109121: PUSH
109122: LD_INT 23
109124: PUSH
109125: LD_INT 25
109127: PUSH
109128: LD_INT 26
109130: PUSH
109131: LD_INT 30
109133: PUSH
109134: LD_INT 31
109136: PUSH
109137: LD_INT 32
109139: PUSH
109140: LD_INT 36
109142: PUSH
109143: EMPTY
109144: LIST
109145: LIST
109146: LIST
109147: LIST
109148: LIST
109149: LIST
109150: LIST
109151: LIST
109152: LIST
109153: LIST
109154: LIST
109155: LIST
109156: LIST
109157: LIST
109158: LIST
109159: LIST
109160: LIST
109161: LIST
109162: LIST
109163: PUSH
109164: LD_INT 101
109166: PUSH
109167: LD_INT 102
109169: PUSH
109170: LD_INT 105
109172: PUSH
109173: LD_INT 106
109175: PUSH
109176: LD_INT 108
109178: PUSH
109179: LD_INT 109
109181: PUSH
109182: LD_INT 112
109184: PUSH
109185: EMPTY
109186: LIST
109187: LIST
109188: LIST
109189: LIST
109190: LIST
109191: LIST
109192: LIST
109193: PUSH
109194: EMPTY
109195: LIST
109196: LIST
109197: ST_TO_ADDR
109198: GO 111565
109200: LD_INT 7
109202: DOUBLE
109203: EQUAL
109204: IFTRUE 109208
109206: GO 109308
109208: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
109209: LD_ADDR_VAR 0 1
109213: PUSH
109214: LD_INT 2
109216: PUSH
109217: LD_INT 4
109219: PUSH
109220: LD_INT 5
109222: PUSH
109223: LD_INT 7
109225: PUSH
109226: LD_INT 11
109228: PUSH
109229: LD_INT 12
109231: PUSH
109232: LD_INT 15
109234: PUSH
109235: LD_INT 16
109237: PUSH
109238: LD_INT 20
109240: PUSH
109241: LD_INT 21
109243: PUSH
109244: LD_INT 22
109246: PUSH
109247: LD_INT 23
109249: PUSH
109250: LD_INT 25
109252: PUSH
109253: LD_INT 26
109255: PUSH
109256: EMPTY
109257: LIST
109258: LIST
109259: LIST
109260: LIST
109261: LIST
109262: LIST
109263: LIST
109264: LIST
109265: LIST
109266: LIST
109267: LIST
109268: LIST
109269: LIST
109270: LIST
109271: PUSH
109272: LD_INT 101
109274: PUSH
109275: LD_INT 102
109277: PUSH
109278: LD_INT 103
109280: PUSH
109281: LD_INT 105
109283: PUSH
109284: LD_INT 106
109286: PUSH
109287: LD_INT 108
109289: PUSH
109290: LD_INT 112
109292: PUSH
109293: EMPTY
109294: LIST
109295: LIST
109296: LIST
109297: LIST
109298: LIST
109299: LIST
109300: LIST
109301: PUSH
109302: EMPTY
109303: LIST
109304: LIST
109305: ST_TO_ADDR
109306: GO 111565
109308: LD_INT 8
109310: DOUBLE
109311: EQUAL
109312: IFTRUE 109316
109314: GO 109444
109316: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
109317: LD_ADDR_VAR 0 1
109321: PUSH
109322: LD_INT 2
109324: PUSH
109325: LD_INT 4
109327: PUSH
109328: LD_INT 5
109330: PUSH
109331: LD_INT 6
109333: PUSH
109334: LD_INT 7
109336: PUSH
109337: LD_INT 8
109339: PUSH
109340: LD_INT 11
109342: PUSH
109343: LD_INT 12
109345: PUSH
109346: LD_INT 15
109348: PUSH
109349: LD_INT 16
109351: PUSH
109352: LD_INT 20
109354: PUSH
109355: LD_INT 21
109357: PUSH
109358: LD_INT 22
109360: PUSH
109361: LD_INT 23
109363: PUSH
109364: LD_INT 25
109366: PUSH
109367: LD_INT 26
109369: PUSH
109370: LD_INT 30
109372: PUSH
109373: LD_INT 31
109375: PUSH
109376: LD_INT 32
109378: PUSH
109379: LD_INT 36
109381: PUSH
109382: EMPTY
109383: LIST
109384: LIST
109385: LIST
109386: LIST
109387: LIST
109388: LIST
109389: LIST
109390: LIST
109391: LIST
109392: LIST
109393: LIST
109394: LIST
109395: LIST
109396: LIST
109397: LIST
109398: LIST
109399: LIST
109400: LIST
109401: LIST
109402: LIST
109403: PUSH
109404: LD_INT 101
109406: PUSH
109407: LD_INT 102
109409: PUSH
109410: LD_INT 103
109412: PUSH
109413: LD_INT 105
109415: PUSH
109416: LD_INT 106
109418: PUSH
109419: LD_INT 108
109421: PUSH
109422: LD_INT 109
109424: PUSH
109425: LD_INT 112
109427: PUSH
109428: EMPTY
109429: LIST
109430: LIST
109431: LIST
109432: LIST
109433: LIST
109434: LIST
109435: LIST
109436: LIST
109437: PUSH
109438: EMPTY
109439: LIST
109440: LIST
109441: ST_TO_ADDR
109442: GO 111565
109444: LD_INT 9
109446: DOUBLE
109447: EQUAL
109448: IFTRUE 109452
109450: GO 109588
109452: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
109453: LD_ADDR_VAR 0 1
109457: PUSH
109458: LD_INT 2
109460: PUSH
109461: LD_INT 4
109463: PUSH
109464: LD_INT 5
109466: PUSH
109467: LD_INT 6
109469: PUSH
109470: LD_INT 7
109472: PUSH
109473: LD_INT 8
109475: PUSH
109476: LD_INT 11
109478: PUSH
109479: LD_INT 12
109481: PUSH
109482: LD_INT 15
109484: PUSH
109485: LD_INT 16
109487: PUSH
109488: LD_INT 20
109490: PUSH
109491: LD_INT 21
109493: PUSH
109494: LD_INT 22
109496: PUSH
109497: LD_INT 23
109499: PUSH
109500: LD_INT 25
109502: PUSH
109503: LD_INT 26
109505: PUSH
109506: LD_INT 28
109508: PUSH
109509: LD_INT 30
109511: PUSH
109512: LD_INT 31
109514: PUSH
109515: LD_INT 32
109517: PUSH
109518: LD_INT 36
109520: PUSH
109521: EMPTY
109522: LIST
109523: LIST
109524: LIST
109525: LIST
109526: LIST
109527: LIST
109528: LIST
109529: LIST
109530: LIST
109531: LIST
109532: LIST
109533: LIST
109534: LIST
109535: LIST
109536: LIST
109537: LIST
109538: LIST
109539: LIST
109540: LIST
109541: LIST
109542: LIST
109543: PUSH
109544: LD_INT 101
109546: PUSH
109547: LD_INT 102
109549: PUSH
109550: LD_INT 103
109552: PUSH
109553: LD_INT 105
109555: PUSH
109556: LD_INT 106
109558: PUSH
109559: LD_INT 108
109561: PUSH
109562: LD_INT 109
109564: PUSH
109565: LD_INT 112
109567: PUSH
109568: LD_INT 114
109570: PUSH
109571: EMPTY
109572: LIST
109573: LIST
109574: LIST
109575: LIST
109576: LIST
109577: LIST
109578: LIST
109579: LIST
109580: LIST
109581: PUSH
109582: EMPTY
109583: LIST
109584: LIST
109585: ST_TO_ADDR
109586: GO 111565
109588: LD_INT 10
109590: DOUBLE
109591: EQUAL
109592: IFTRUE 109596
109594: GO 109780
109596: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
109597: LD_ADDR_VAR 0 1
109601: PUSH
109602: LD_INT 2
109604: PUSH
109605: LD_INT 4
109607: PUSH
109608: LD_INT 5
109610: PUSH
109611: LD_INT 6
109613: PUSH
109614: LD_INT 7
109616: PUSH
109617: LD_INT 8
109619: PUSH
109620: LD_INT 9
109622: PUSH
109623: LD_INT 10
109625: PUSH
109626: LD_INT 11
109628: PUSH
109629: LD_INT 12
109631: PUSH
109632: LD_INT 13
109634: PUSH
109635: LD_INT 14
109637: PUSH
109638: LD_INT 15
109640: PUSH
109641: LD_INT 16
109643: PUSH
109644: LD_INT 17
109646: PUSH
109647: LD_INT 18
109649: PUSH
109650: LD_INT 19
109652: PUSH
109653: LD_INT 20
109655: PUSH
109656: LD_INT 21
109658: PUSH
109659: LD_INT 22
109661: PUSH
109662: LD_INT 23
109664: PUSH
109665: LD_INT 24
109667: PUSH
109668: LD_INT 25
109670: PUSH
109671: LD_INT 26
109673: PUSH
109674: LD_INT 28
109676: PUSH
109677: LD_INT 30
109679: PUSH
109680: LD_INT 31
109682: PUSH
109683: LD_INT 32
109685: PUSH
109686: LD_INT 36
109688: PUSH
109689: EMPTY
109690: LIST
109691: LIST
109692: LIST
109693: LIST
109694: LIST
109695: LIST
109696: LIST
109697: LIST
109698: LIST
109699: LIST
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: LIST
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: LIST
109712: LIST
109713: LIST
109714: LIST
109715: LIST
109716: LIST
109717: LIST
109718: LIST
109719: PUSH
109720: LD_INT 101
109722: PUSH
109723: LD_INT 102
109725: PUSH
109726: LD_INT 103
109728: PUSH
109729: LD_INT 104
109731: PUSH
109732: LD_INT 105
109734: PUSH
109735: LD_INT 106
109737: PUSH
109738: LD_INT 107
109740: PUSH
109741: LD_INT 108
109743: PUSH
109744: LD_INT 109
109746: PUSH
109747: LD_INT 110
109749: PUSH
109750: LD_INT 111
109752: PUSH
109753: LD_INT 112
109755: PUSH
109756: LD_INT 114
109758: PUSH
109759: EMPTY
109760: LIST
109761: LIST
109762: LIST
109763: LIST
109764: LIST
109765: LIST
109766: LIST
109767: LIST
109768: LIST
109769: LIST
109770: LIST
109771: LIST
109772: LIST
109773: PUSH
109774: EMPTY
109775: LIST
109776: LIST
109777: ST_TO_ADDR
109778: GO 111565
109780: LD_INT 11
109782: DOUBLE
109783: EQUAL
109784: IFTRUE 109788
109786: GO 109980
109788: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
109789: LD_ADDR_VAR 0 1
109793: PUSH
109794: LD_INT 2
109796: PUSH
109797: LD_INT 3
109799: PUSH
109800: LD_INT 4
109802: PUSH
109803: LD_INT 5
109805: PUSH
109806: LD_INT 6
109808: PUSH
109809: LD_INT 7
109811: PUSH
109812: LD_INT 8
109814: PUSH
109815: LD_INT 9
109817: PUSH
109818: LD_INT 10
109820: PUSH
109821: LD_INT 11
109823: PUSH
109824: LD_INT 12
109826: PUSH
109827: LD_INT 13
109829: PUSH
109830: LD_INT 14
109832: PUSH
109833: LD_INT 15
109835: PUSH
109836: LD_INT 16
109838: PUSH
109839: LD_INT 17
109841: PUSH
109842: LD_INT 18
109844: PUSH
109845: LD_INT 19
109847: PUSH
109848: LD_INT 20
109850: PUSH
109851: LD_INT 21
109853: PUSH
109854: LD_INT 22
109856: PUSH
109857: LD_INT 23
109859: PUSH
109860: LD_INT 24
109862: PUSH
109863: LD_INT 25
109865: PUSH
109866: LD_INT 26
109868: PUSH
109869: LD_INT 28
109871: PUSH
109872: LD_INT 30
109874: PUSH
109875: LD_INT 31
109877: PUSH
109878: LD_INT 32
109880: PUSH
109881: LD_INT 34
109883: PUSH
109884: LD_INT 36
109886: PUSH
109887: EMPTY
109888: LIST
109889: LIST
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: LIST
109898: LIST
109899: LIST
109900: LIST
109901: LIST
109902: LIST
109903: LIST
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: LIST
109909: LIST
109910: LIST
109911: LIST
109912: LIST
109913: LIST
109914: LIST
109915: LIST
109916: LIST
109917: LIST
109918: LIST
109919: PUSH
109920: LD_INT 101
109922: PUSH
109923: LD_INT 102
109925: PUSH
109926: LD_INT 103
109928: PUSH
109929: LD_INT 104
109931: PUSH
109932: LD_INT 105
109934: PUSH
109935: LD_INT 106
109937: PUSH
109938: LD_INT 107
109940: PUSH
109941: LD_INT 108
109943: PUSH
109944: LD_INT 109
109946: PUSH
109947: LD_INT 110
109949: PUSH
109950: LD_INT 111
109952: PUSH
109953: LD_INT 112
109955: PUSH
109956: LD_INT 114
109958: PUSH
109959: EMPTY
109960: LIST
109961: LIST
109962: LIST
109963: LIST
109964: LIST
109965: LIST
109966: LIST
109967: LIST
109968: LIST
109969: LIST
109970: LIST
109971: LIST
109972: LIST
109973: PUSH
109974: EMPTY
109975: LIST
109976: LIST
109977: ST_TO_ADDR
109978: GO 111565
109980: LD_INT 12
109982: DOUBLE
109983: EQUAL
109984: IFTRUE 109988
109986: GO 110196
109988: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
109989: LD_ADDR_VAR 0 1
109993: PUSH
109994: LD_INT 1
109996: PUSH
109997: LD_INT 2
109999: PUSH
110000: LD_INT 3
110002: PUSH
110003: LD_INT 4
110005: PUSH
110006: LD_INT 5
110008: PUSH
110009: LD_INT 6
110011: PUSH
110012: LD_INT 7
110014: PUSH
110015: LD_INT 8
110017: PUSH
110018: LD_INT 9
110020: PUSH
110021: LD_INT 10
110023: PUSH
110024: LD_INT 11
110026: PUSH
110027: LD_INT 12
110029: PUSH
110030: LD_INT 13
110032: PUSH
110033: LD_INT 14
110035: PUSH
110036: LD_INT 15
110038: PUSH
110039: LD_INT 16
110041: PUSH
110042: LD_INT 17
110044: PUSH
110045: LD_INT 18
110047: PUSH
110048: LD_INT 19
110050: PUSH
110051: LD_INT 20
110053: PUSH
110054: LD_INT 21
110056: PUSH
110057: LD_INT 22
110059: PUSH
110060: LD_INT 23
110062: PUSH
110063: LD_INT 24
110065: PUSH
110066: LD_INT 25
110068: PUSH
110069: LD_INT 26
110071: PUSH
110072: LD_INT 27
110074: PUSH
110075: LD_INT 28
110077: PUSH
110078: LD_INT 30
110080: PUSH
110081: LD_INT 31
110083: PUSH
110084: LD_INT 32
110086: PUSH
110087: LD_INT 33
110089: PUSH
110090: LD_INT 34
110092: PUSH
110093: LD_INT 36
110095: PUSH
110096: EMPTY
110097: LIST
110098: LIST
110099: LIST
110100: LIST
110101: LIST
110102: LIST
110103: LIST
110104: LIST
110105: LIST
110106: LIST
110107: LIST
110108: LIST
110109: LIST
110110: LIST
110111: LIST
110112: LIST
110113: LIST
110114: LIST
110115: LIST
110116: LIST
110117: LIST
110118: LIST
110119: LIST
110120: LIST
110121: LIST
110122: LIST
110123: LIST
110124: LIST
110125: LIST
110126: LIST
110127: LIST
110128: LIST
110129: LIST
110130: LIST
110131: PUSH
110132: LD_INT 101
110134: PUSH
110135: LD_INT 102
110137: PUSH
110138: LD_INT 103
110140: PUSH
110141: LD_INT 104
110143: PUSH
110144: LD_INT 105
110146: PUSH
110147: LD_INT 106
110149: PUSH
110150: LD_INT 107
110152: PUSH
110153: LD_INT 108
110155: PUSH
110156: LD_INT 109
110158: PUSH
110159: LD_INT 110
110161: PUSH
110162: LD_INT 111
110164: PUSH
110165: LD_INT 112
110167: PUSH
110168: LD_INT 113
110170: PUSH
110171: LD_INT 114
110173: PUSH
110174: EMPTY
110175: LIST
110176: LIST
110177: LIST
110178: LIST
110179: LIST
110180: LIST
110181: LIST
110182: LIST
110183: LIST
110184: LIST
110185: LIST
110186: LIST
110187: LIST
110188: LIST
110189: PUSH
110190: EMPTY
110191: LIST
110192: LIST
110193: ST_TO_ADDR
110194: GO 111565
110196: LD_INT 13
110198: DOUBLE
110199: EQUAL
110200: IFTRUE 110204
110202: GO 110400
110204: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
110205: LD_ADDR_VAR 0 1
110209: PUSH
110210: LD_INT 1
110212: PUSH
110213: LD_INT 2
110215: PUSH
110216: LD_INT 3
110218: PUSH
110219: LD_INT 4
110221: PUSH
110222: LD_INT 5
110224: PUSH
110225: LD_INT 8
110227: PUSH
110228: LD_INT 9
110230: PUSH
110231: LD_INT 10
110233: PUSH
110234: LD_INT 11
110236: PUSH
110237: LD_INT 12
110239: PUSH
110240: LD_INT 14
110242: PUSH
110243: LD_INT 15
110245: PUSH
110246: LD_INT 16
110248: PUSH
110249: LD_INT 17
110251: PUSH
110252: LD_INT 18
110254: PUSH
110255: LD_INT 19
110257: PUSH
110258: LD_INT 20
110260: PUSH
110261: LD_INT 21
110263: PUSH
110264: LD_INT 22
110266: PUSH
110267: LD_INT 23
110269: PUSH
110270: LD_INT 24
110272: PUSH
110273: LD_INT 25
110275: PUSH
110276: LD_INT 26
110278: PUSH
110279: LD_INT 27
110281: PUSH
110282: LD_INT 28
110284: PUSH
110285: LD_INT 30
110287: PUSH
110288: LD_INT 31
110290: PUSH
110291: LD_INT 32
110293: PUSH
110294: LD_INT 33
110296: PUSH
110297: LD_INT 34
110299: PUSH
110300: LD_INT 36
110302: PUSH
110303: EMPTY
110304: LIST
110305: LIST
110306: LIST
110307: LIST
110308: LIST
110309: LIST
110310: LIST
110311: LIST
110312: LIST
110313: LIST
110314: LIST
110315: LIST
110316: LIST
110317: LIST
110318: LIST
110319: LIST
110320: LIST
110321: LIST
110322: LIST
110323: LIST
110324: LIST
110325: LIST
110326: LIST
110327: LIST
110328: LIST
110329: LIST
110330: LIST
110331: LIST
110332: LIST
110333: LIST
110334: LIST
110335: PUSH
110336: LD_INT 101
110338: PUSH
110339: LD_INT 102
110341: PUSH
110342: LD_INT 103
110344: PUSH
110345: LD_INT 104
110347: PUSH
110348: LD_INT 105
110350: PUSH
110351: LD_INT 106
110353: PUSH
110354: LD_INT 107
110356: PUSH
110357: LD_INT 108
110359: PUSH
110360: LD_INT 109
110362: PUSH
110363: LD_INT 110
110365: PUSH
110366: LD_INT 111
110368: PUSH
110369: LD_INT 112
110371: PUSH
110372: LD_INT 113
110374: PUSH
110375: LD_INT 114
110377: PUSH
110378: EMPTY
110379: LIST
110380: LIST
110381: LIST
110382: LIST
110383: LIST
110384: LIST
110385: LIST
110386: LIST
110387: LIST
110388: LIST
110389: LIST
110390: LIST
110391: LIST
110392: LIST
110393: PUSH
110394: EMPTY
110395: LIST
110396: LIST
110397: ST_TO_ADDR
110398: GO 111565
110400: LD_INT 14
110402: DOUBLE
110403: EQUAL
110404: IFTRUE 110408
110406: GO 110620
110408: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
110409: LD_ADDR_VAR 0 1
110413: PUSH
110414: LD_INT 1
110416: PUSH
110417: LD_INT 2
110419: PUSH
110420: LD_INT 3
110422: PUSH
110423: LD_INT 4
110425: PUSH
110426: LD_INT 5
110428: PUSH
110429: LD_INT 6
110431: PUSH
110432: LD_INT 7
110434: PUSH
110435: LD_INT 8
110437: PUSH
110438: LD_INT 9
110440: PUSH
110441: LD_INT 10
110443: PUSH
110444: LD_INT 11
110446: PUSH
110447: LD_INT 12
110449: PUSH
110450: LD_INT 13
110452: PUSH
110453: LD_INT 14
110455: PUSH
110456: LD_INT 15
110458: PUSH
110459: LD_INT 16
110461: PUSH
110462: LD_INT 17
110464: PUSH
110465: LD_INT 18
110467: PUSH
110468: LD_INT 19
110470: PUSH
110471: LD_INT 20
110473: PUSH
110474: LD_INT 21
110476: PUSH
110477: LD_INT 22
110479: PUSH
110480: LD_INT 23
110482: PUSH
110483: LD_INT 24
110485: PUSH
110486: LD_INT 25
110488: PUSH
110489: LD_INT 26
110491: PUSH
110492: LD_INT 27
110494: PUSH
110495: LD_INT 28
110497: PUSH
110498: LD_INT 29
110500: PUSH
110501: LD_INT 30
110503: PUSH
110504: LD_INT 31
110506: PUSH
110507: LD_INT 32
110509: PUSH
110510: LD_INT 33
110512: PUSH
110513: LD_INT 34
110515: PUSH
110516: LD_INT 36
110518: PUSH
110519: EMPTY
110520: LIST
110521: LIST
110522: LIST
110523: LIST
110524: LIST
110525: LIST
110526: LIST
110527: LIST
110528: LIST
110529: LIST
110530: LIST
110531: LIST
110532: LIST
110533: LIST
110534: LIST
110535: LIST
110536: LIST
110537: LIST
110538: LIST
110539: LIST
110540: LIST
110541: LIST
110542: LIST
110543: LIST
110544: LIST
110545: LIST
110546: LIST
110547: LIST
110548: LIST
110549: LIST
110550: LIST
110551: LIST
110552: LIST
110553: LIST
110554: LIST
110555: PUSH
110556: LD_INT 101
110558: PUSH
110559: LD_INT 102
110561: PUSH
110562: LD_INT 103
110564: PUSH
110565: LD_INT 104
110567: PUSH
110568: LD_INT 105
110570: PUSH
110571: LD_INT 106
110573: PUSH
110574: LD_INT 107
110576: PUSH
110577: LD_INT 108
110579: PUSH
110580: LD_INT 109
110582: PUSH
110583: LD_INT 110
110585: PUSH
110586: LD_INT 111
110588: PUSH
110589: LD_INT 112
110591: PUSH
110592: LD_INT 113
110594: PUSH
110595: LD_INT 114
110597: PUSH
110598: EMPTY
110599: LIST
110600: LIST
110601: LIST
110602: LIST
110603: LIST
110604: LIST
110605: LIST
110606: LIST
110607: LIST
110608: LIST
110609: LIST
110610: LIST
110611: LIST
110612: LIST
110613: PUSH
110614: EMPTY
110615: LIST
110616: LIST
110617: ST_TO_ADDR
110618: GO 111565
110620: LD_INT 15
110622: DOUBLE
110623: EQUAL
110624: IFTRUE 110628
110626: GO 110840
110628: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
110629: LD_ADDR_VAR 0 1
110633: PUSH
110634: LD_INT 1
110636: PUSH
110637: LD_INT 2
110639: PUSH
110640: LD_INT 3
110642: PUSH
110643: LD_INT 4
110645: PUSH
110646: LD_INT 5
110648: PUSH
110649: LD_INT 6
110651: PUSH
110652: LD_INT 7
110654: PUSH
110655: LD_INT 8
110657: PUSH
110658: LD_INT 9
110660: PUSH
110661: LD_INT 10
110663: PUSH
110664: LD_INT 11
110666: PUSH
110667: LD_INT 12
110669: PUSH
110670: LD_INT 13
110672: PUSH
110673: LD_INT 14
110675: PUSH
110676: LD_INT 15
110678: PUSH
110679: LD_INT 16
110681: PUSH
110682: LD_INT 17
110684: PUSH
110685: LD_INT 18
110687: PUSH
110688: LD_INT 19
110690: PUSH
110691: LD_INT 20
110693: PUSH
110694: LD_INT 21
110696: PUSH
110697: LD_INT 22
110699: PUSH
110700: LD_INT 23
110702: PUSH
110703: LD_INT 24
110705: PUSH
110706: LD_INT 25
110708: PUSH
110709: LD_INT 26
110711: PUSH
110712: LD_INT 27
110714: PUSH
110715: LD_INT 28
110717: PUSH
110718: LD_INT 29
110720: PUSH
110721: LD_INT 30
110723: PUSH
110724: LD_INT 31
110726: PUSH
110727: LD_INT 32
110729: PUSH
110730: LD_INT 33
110732: PUSH
110733: LD_INT 34
110735: PUSH
110736: LD_INT 36
110738: PUSH
110739: EMPTY
110740: LIST
110741: LIST
110742: LIST
110743: LIST
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: LIST
110749: LIST
110750: LIST
110751: LIST
110752: LIST
110753: LIST
110754: LIST
110755: LIST
110756: LIST
110757: LIST
110758: LIST
110759: LIST
110760: LIST
110761: LIST
110762: LIST
110763: LIST
110764: LIST
110765: LIST
110766: LIST
110767: LIST
110768: LIST
110769: LIST
110770: LIST
110771: LIST
110772: LIST
110773: LIST
110774: LIST
110775: PUSH
110776: LD_INT 101
110778: PUSH
110779: LD_INT 102
110781: PUSH
110782: LD_INT 103
110784: PUSH
110785: LD_INT 104
110787: PUSH
110788: LD_INT 105
110790: PUSH
110791: LD_INT 106
110793: PUSH
110794: LD_INT 107
110796: PUSH
110797: LD_INT 108
110799: PUSH
110800: LD_INT 109
110802: PUSH
110803: LD_INT 110
110805: PUSH
110806: LD_INT 111
110808: PUSH
110809: LD_INT 112
110811: PUSH
110812: LD_INT 113
110814: PUSH
110815: LD_INT 114
110817: PUSH
110818: EMPTY
110819: LIST
110820: LIST
110821: LIST
110822: LIST
110823: LIST
110824: LIST
110825: LIST
110826: LIST
110827: LIST
110828: LIST
110829: LIST
110830: LIST
110831: LIST
110832: LIST
110833: PUSH
110834: EMPTY
110835: LIST
110836: LIST
110837: ST_TO_ADDR
110838: GO 111565
110840: LD_INT 16
110842: DOUBLE
110843: EQUAL
110844: IFTRUE 110848
110846: GO 110972
110848: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
110849: LD_ADDR_VAR 0 1
110853: PUSH
110854: LD_INT 2
110856: PUSH
110857: LD_INT 4
110859: PUSH
110860: LD_INT 5
110862: PUSH
110863: LD_INT 7
110865: PUSH
110866: LD_INT 11
110868: PUSH
110869: LD_INT 12
110871: PUSH
110872: LD_INT 15
110874: PUSH
110875: LD_INT 16
110877: PUSH
110878: LD_INT 20
110880: PUSH
110881: LD_INT 21
110883: PUSH
110884: LD_INT 22
110886: PUSH
110887: LD_INT 23
110889: PUSH
110890: LD_INT 25
110892: PUSH
110893: LD_INT 26
110895: PUSH
110896: LD_INT 30
110898: PUSH
110899: LD_INT 31
110901: PUSH
110902: LD_INT 32
110904: PUSH
110905: LD_INT 33
110907: PUSH
110908: LD_INT 34
110910: PUSH
110911: EMPTY
110912: LIST
110913: LIST
110914: LIST
110915: LIST
110916: LIST
110917: LIST
110918: LIST
110919: LIST
110920: LIST
110921: LIST
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: LIST
110929: LIST
110930: LIST
110931: PUSH
110932: LD_INT 101
110934: PUSH
110935: LD_INT 102
110937: PUSH
110938: LD_INT 103
110940: PUSH
110941: LD_INT 106
110943: PUSH
110944: LD_INT 108
110946: PUSH
110947: LD_INT 112
110949: PUSH
110950: LD_INT 113
110952: PUSH
110953: LD_INT 114
110955: PUSH
110956: EMPTY
110957: LIST
110958: LIST
110959: LIST
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: LIST
110965: PUSH
110966: EMPTY
110967: LIST
110968: LIST
110969: ST_TO_ADDR
110970: GO 111565
110972: LD_INT 17
110974: DOUBLE
110975: EQUAL
110976: IFTRUE 110980
110978: GO 111192
110980: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
110981: LD_ADDR_VAR 0 1
110985: PUSH
110986: LD_INT 1
110988: PUSH
110989: LD_INT 2
110991: PUSH
110992: LD_INT 3
110994: PUSH
110995: LD_INT 4
110997: PUSH
110998: LD_INT 5
111000: PUSH
111001: LD_INT 6
111003: PUSH
111004: LD_INT 7
111006: PUSH
111007: LD_INT 8
111009: PUSH
111010: LD_INT 9
111012: PUSH
111013: LD_INT 10
111015: PUSH
111016: LD_INT 11
111018: PUSH
111019: LD_INT 12
111021: PUSH
111022: LD_INT 13
111024: PUSH
111025: LD_INT 14
111027: PUSH
111028: LD_INT 15
111030: PUSH
111031: LD_INT 16
111033: PUSH
111034: LD_INT 17
111036: PUSH
111037: LD_INT 18
111039: PUSH
111040: LD_INT 19
111042: PUSH
111043: LD_INT 20
111045: PUSH
111046: LD_INT 21
111048: PUSH
111049: LD_INT 22
111051: PUSH
111052: LD_INT 23
111054: PUSH
111055: LD_INT 24
111057: PUSH
111058: LD_INT 25
111060: PUSH
111061: LD_INT 26
111063: PUSH
111064: LD_INT 27
111066: PUSH
111067: LD_INT 28
111069: PUSH
111070: LD_INT 29
111072: PUSH
111073: LD_INT 30
111075: PUSH
111076: LD_INT 31
111078: PUSH
111079: LD_INT 32
111081: PUSH
111082: LD_INT 33
111084: PUSH
111085: LD_INT 34
111087: PUSH
111088: LD_INT 36
111090: PUSH
111091: EMPTY
111092: LIST
111093: LIST
111094: LIST
111095: LIST
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: LIST
111106: LIST
111107: LIST
111108: LIST
111109: LIST
111110: LIST
111111: LIST
111112: LIST
111113: LIST
111114: LIST
111115: LIST
111116: LIST
111117: LIST
111118: LIST
111119: LIST
111120: LIST
111121: LIST
111122: LIST
111123: LIST
111124: LIST
111125: LIST
111126: LIST
111127: PUSH
111128: LD_INT 101
111130: PUSH
111131: LD_INT 102
111133: PUSH
111134: LD_INT 103
111136: PUSH
111137: LD_INT 104
111139: PUSH
111140: LD_INT 105
111142: PUSH
111143: LD_INT 106
111145: PUSH
111146: LD_INT 107
111148: PUSH
111149: LD_INT 108
111151: PUSH
111152: LD_INT 109
111154: PUSH
111155: LD_INT 110
111157: PUSH
111158: LD_INT 111
111160: PUSH
111161: LD_INT 112
111163: PUSH
111164: LD_INT 113
111166: PUSH
111167: LD_INT 114
111169: PUSH
111170: EMPTY
111171: LIST
111172: LIST
111173: LIST
111174: LIST
111175: LIST
111176: LIST
111177: LIST
111178: LIST
111179: LIST
111180: LIST
111181: LIST
111182: LIST
111183: LIST
111184: LIST
111185: PUSH
111186: EMPTY
111187: LIST
111188: LIST
111189: ST_TO_ADDR
111190: GO 111565
111192: LD_INT 18
111194: DOUBLE
111195: EQUAL
111196: IFTRUE 111200
111198: GO 111336
111200: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
111201: LD_ADDR_VAR 0 1
111205: PUSH
111206: LD_INT 2
111208: PUSH
111209: LD_INT 4
111211: PUSH
111212: LD_INT 5
111214: PUSH
111215: LD_INT 7
111217: PUSH
111218: LD_INT 11
111220: PUSH
111221: LD_INT 12
111223: PUSH
111224: LD_INT 15
111226: PUSH
111227: LD_INT 16
111229: PUSH
111230: LD_INT 20
111232: PUSH
111233: LD_INT 21
111235: PUSH
111236: LD_INT 22
111238: PUSH
111239: LD_INT 23
111241: PUSH
111242: LD_INT 25
111244: PUSH
111245: LD_INT 26
111247: PUSH
111248: LD_INT 30
111250: PUSH
111251: LD_INT 31
111253: PUSH
111254: LD_INT 32
111256: PUSH
111257: LD_INT 33
111259: PUSH
111260: LD_INT 34
111262: PUSH
111263: LD_INT 35
111265: PUSH
111266: LD_INT 36
111268: PUSH
111269: EMPTY
111270: LIST
111271: LIST
111272: LIST
111273: LIST
111274: LIST
111275: LIST
111276: LIST
111277: LIST
111278: LIST
111279: LIST
111280: LIST
111281: LIST
111282: LIST
111283: LIST
111284: LIST
111285: LIST
111286: LIST
111287: LIST
111288: LIST
111289: LIST
111290: LIST
111291: PUSH
111292: LD_INT 101
111294: PUSH
111295: LD_INT 102
111297: PUSH
111298: LD_INT 103
111300: PUSH
111301: LD_INT 106
111303: PUSH
111304: LD_INT 108
111306: PUSH
111307: LD_INT 112
111309: PUSH
111310: LD_INT 113
111312: PUSH
111313: LD_INT 114
111315: PUSH
111316: LD_INT 115
111318: PUSH
111319: EMPTY
111320: LIST
111321: LIST
111322: LIST
111323: LIST
111324: LIST
111325: LIST
111326: LIST
111327: LIST
111328: LIST
111329: PUSH
111330: EMPTY
111331: LIST
111332: LIST
111333: ST_TO_ADDR
111334: GO 111565
111336: LD_INT 19
111338: DOUBLE
111339: EQUAL
111340: IFTRUE 111344
111342: GO 111564
111344: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
111345: LD_ADDR_VAR 0 1
111349: PUSH
111350: LD_INT 1
111352: PUSH
111353: LD_INT 2
111355: PUSH
111356: LD_INT 3
111358: PUSH
111359: LD_INT 4
111361: PUSH
111362: LD_INT 5
111364: PUSH
111365: LD_INT 6
111367: PUSH
111368: LD_INT 7
111370: PUSH
111371: LD_INT 8
111373: PUSH
111374: LD_INT 9
111376: PUSH
111377: LD_INT 10
111379: PUSH
111380: LD_INT 11
111382: PUSH
111383: LD_INT 12
111385: PUSH
111386: LD_INT 13
111388: PUSH
111389: LD_INT 14
111391: PUSH
111392: LD_INT 15
111394: PUSH
111395: LD_INT 16
111397: PUSH
111398: LD_INT 17
111400: PUSH
111401: LD_INT 18
111403: PUSH
111404: LD_INT 19
111406: PUSH
111407: LD_INT 20
111409: PUSH
111410: LD_INT 21
111412: PUSH
111413: LD_INT 22
111415: PUSH
111416: LD_INT 23
111418: PUSH
111419: LD_INT 24
111421: PUSH
111422: LD_INT 25
111424: PUSH
111425: LD_INT 26
111427: PUSH
111428: LD_INT 27
111430: PUSH
111431: LD_INT 28
111433: PUSH
111434: LD_INT 29
111436: PUSH
111437: LD_INT 30
111439: PUSH
111440: LD_INT 31
111442: PUSH
111443: LD_INT 32
111445: PUSH
111446: LD_INT 33
111448: PUSH
111449: LD_INT 34
111451: PUSH
111452: LD_INT 35
111454: PUSH
111455: LD_INT 36
111457: PUSH
111458: EMPTY
111459: LIST
111460: LIST
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: LIST
111474: LIST
111475: LIST
111476: LIST
111477: LIST
111478: LIST
111479: LIST
111480: LIST
111481: LIST
111482: LIST
111483: LIST
111484: LIST
111485: LIST
111486: LIST
111487: LIST
111488: LIST
111489: LIST
111490: LIST
111491: LIST
111492: LIST
111493: LIST
111494: LIST
111495: PUSH
111496: LD_INT 101
111498: PUSH
111499: LD_INT 102
111501: PUSH
111502: LD_INT 103
111504: PUSH
111505: LD_INT 104
111507: PUSH
111508: LD_INT 105
111510: PUSH
111511: LD_INT 106
111513: PUSH
111514: LD_INT 107
111516: PUSH
111517: LD_INT 108
111519: PUSH
111520: LD_INT 109
111522: PUSH
111523: LD_INT 110
111525: PUSH
111526: LD_INT 111
111528: PUSH
111529: LD_INT 112
111531: PUSH
111532: LD_INT 113
111534: PUSH
111535: LD_INT 114
111537: PUSH
111538: LD_INT 115
111540: PUSH
111541: EMPTY
111542: LIST
111543: LIST
111544: LIST
111545: LIST
111546: LIST
111547: LIST
111548: LIST
111549: LIST
111550: LIST
111551: LIST
111552: LIST
111553: LIST
111554: LIST
111555: LIST
111556: LIST
111557: PUSH
111558: EMPTY
111559: LIST
111560: LIST
111561: ST_TO_ADDR
111562: GO 111565
111564: POP
// end else
111565: GO 111602
// if campaign_id = 5 then
111567: LD_OWVAR 69
111571: PUSH
111572: LD_INT 5
111574: EQUAL
111575: IFFALSE 111602
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
111577: LD_ADDR_VAR 0 1
111581: PUSH
111582: LD_INT 1
111584: PUSH
111585: LD_INT 2
111587: PUSH
111588: EMPTY
111589: LIST
111590: LIST
111591: PUSH
111592: LD_INT 100
111594: PUSH
111595: EMPTY
111596: LIST
111597: PUSH
111598: EMPTY
111599: LIST
111600: LIST
111601: ST_TO_ADDR
// end ; if result then
111602: LD_VAR 0 1
111606: IFFALSE 111895
// begin normal :=  ;
111608: LD_ADDR_VAR 0 3
111612: PUSH
111613: LD_STRING 
111615: ST_TO_ADDR
// hardcore :=  ;
111616: LD_ADDR_VAR 0 4
111620: PUSH
111621: LD_STRING 
111623: ST_TO_ADDR
// for i = 1 to normalCounter do
111624: LD_ADDR_VAR 0 5
111628: PUSH
111629: DOUBLE
111630: LD_INT 1
111632: DEC
111633: ST_TO_ADDR
111634: LD_EXP 146
111638: PUSH
111639: FOR_TO
111640: IFFALSE 111741
// begin tmp := 0 ;
111642: LD_ADDR_VAR 0 2
111646: PUSH
111647: LD_STRING 0
111649: ST_TO_ADDR
// if result [ 1 ] then
111650: LD_VAR 0 1
111654: PUSH
111655: LD_INT 1
111657: ARRAY
111658: IFFALSE 111723
// if result [ 1 ] [ 1 ] = i then
111660: LD_VAR 0 1
111664: PUSH
111665: LD_INT 1
111667: ARRAY
111668: PUSH
111669: LD_INT 1
111671: ARRAY
111672: PUSH
111673: LD_VAR 0 5
111677: EQUAL
111678: IFFALSE 111723
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111680: LD_ADDR_VAR 0 1
111684: PUSH
111685: LD_VAR 0 1
111689: PPUSH
111690: LD_INT 1
111692: PPUSH
111693: LD_VAR 0 1
111697: PUSH
111698: LD_INT 1
111700: ARRAY
111701: PPUSH
111702: LD_INT 1
111704: PPUSH
111705: CALL_OW 3
111709: PPUSH
111710: CALL_OW 1
111714: ST_TO_ADDR
// tmp := 1 ;
111715: LD_ADDR_VAR 0 2
111719: PUSH
111720: LD_STRING 1
111722: ST_TO_ADDR
// end ; normal := normal & tmp ;
111723: LD_ADDR_VAR 0 3
111727: PUSH
111728: LD_VAR 0 3
111732: PUSH
111733: LD_VAR 0 2
111737: STR
111738: ST_TO_ADDR
// end ;
111739: GO 111639
111741: POP
111742: POP
// for i = 1 to hardcoreCounter do
111743: LD_ADDR_VAR 0 5
111747: PUSH
111748: DOUBLE
111749: LD_INT 1
111751: DEC
111752: ST_TO_ADDR
111753: LD_EXP 147
111757: PUSH
111758: FOR_TO
111759: IFFALSE 111864
// begin tmp := 0 ;
111761: LD_ADDR_VAR 0 2
111765: PUSH
111766: LD_STRING 0
111768: ST_TO_ADDR
// if result [ 2 ] then
111769: LD_VAR 0 1
111773: PUSH
111774: LD_INT 2
111776: ARRAY
111777: IFFALSE 111846
// if result [ 2 ] [ 1 ] = 100 + i then
111779: LD_VAR 0 1
111783: PUSH
111784: LD_INT 2
111786: ARRAY
111787: PUSH
111788: LD_INT 1
111790: ARRAY
111791: PUSH
111792: LD_INT 100
111794: PUSH
111795: LD_VAR 0 5
111799: PLUS
111800: EQUAL
111801: IFFALSE 111846
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111803: LD_ADDR_VAR 0 1
111807: PUSH
111808: LD_VAR 0 1
111812: PPUSH
111813: LD_INT 2
111815: PPUSH
111816: LD_VAR 0 1
111820: PUSH
111821: LD_INT 2
111823: ARRAY
111824: PPUSH
111825: LD_INT 1
111827: PPUSH
111828: CALL_OW 3
111832: PPUSH
111833: CALL_OW 1
111837: ST_TO_ADDR
// tmp := 1 ;
111838: LD_ADDR_VAR 0 2
111842: PUSH
111843: LD_STRING 1
111845: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111846: LD_ADDR_VAR 0 4
111850: PUSH
111851: LD_VAR 0 4
111855: PUSH
111856: LD_VAR 0 2
111860: STR
111861: ST_TO_ADDR
// end ;
111862: GO 111758
111864: POP
111865: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
111866: LD_STRING getStreamItemsFromMission("
111868: PUSH
111869: LD_VAR 0 3
111873: STR
111874: PUSH
111875: LD_STRING ","
111877: STR
111878: PUSH
111879: LD_VAR 0 4
111883: STR
111884: PUSH
111885: LD_STRING ")
111887: STR
111888: PPUSH
111889: CALL_OW 559
// end else
111893: GO 111902
// ToLua ( getStreamItemsFromMission("","") ) ;
111895: LD_STRING getStreamItemsFromMission("","")
111897: PPUSH
111898: CALL_OW 559
// end ;
111902: LD_VAR 0 1
111906: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
111907: LD_VAR 0 2
111911: PUSH
111912: LD_INT 100
111914: EQUAL
111915: IFFALSE 112864
// begin if not StreamModeActive then
111917: LD_EXP 145
111921: NOT
111922: IFFALSE 111932
// StreamModeActive := true ;
111924: LD_ADDR_EXP 145
111928: PUSH
111929: LD_INT 1
111931: ST_TO_ADDR
// if p3 = 0 then
111932: LD_VAR 0 3
111936: PUSH
111937: LD_INT 0
111939: EQUAL
111940: IFFALSE 111946
// InitStreamMode ;
111942: CALL 108167 0 0
// if p3 = 1 then
111946: LD_VAR 0 3
111950: PUSH
111951: LD_INT 1
111953: EQUAL
111954: IFFALSE 111964
// sRocket := true ;
111956: LD_ADDR_EXP 150
111960: PUSH
111961: LD_INT 1
111963: ST_TO_ADDR
// if p3 = 2 then
111964: LD_VAR 0 3
111968: PUSH
111969: LD_INT 2
111971: EQUAL
111972: IFFALSE 111982
// sSpeed := true ;
111974: LD_ADDR_EXP 149
111978: PUSH
111979: LD_INT 1
111981: ST_TO_ADDR
// if p3 = 3 then
111982: LD_VAR 0 3
111986: PUSH
111987: LD_INT 3
111989: EQUAL
111990: IFFALSE 112000
// sEngine := true ;
111992: LD_ADDR_EXP 151
111996: PUSH
111997: LD_INT 1
111999: ST_TO_ADDR
// if p3 = 4 then
112000: LD_VAR 0 3
112004: PUSH
112005: LD_INT 4
112007: EQUAL
112008: IFFALSE 112018
// sSpec := true ;
112010: LD_ADDR_EXP 148
112014: PUSH
112015: LD_INT 1
112017: ST_TO_ADDR
// if p3 = 5 then
112018: LD_VAR 0 3
112022: PUSH
112023: LD_INT 5
112025: EQUAL
112026: IFFALSE 112036
// sLevel := true ;
112028: LD_ADDR_EXP 152
112032: PUSH
112033: LD_INT 1
112035: ST_TO_ADDR
// if p3 = 6 then
112036: LD_VAR 0 3
112040: PUSH
112041: LD_INT 6
112043: EQUAL
112044: IFFALSE 112054
// sArmoury := true ;
112046: LD_ADDR_EXP 153
112050: PUSH
112051: LD_INT 1
112053: ST_TO_ADDR
// if p3 = 7 then
112054: LD_VAR 0 3
112058: PUSH
112059: LD_INT 7
112061: EQUAL
112062: IFFALSE 112072
// sRadar := true ;
112064: LD_ADDR_EXP 154
112068: PUSH
112069: LD_INT 1
112071: ST_TO_ADDR
// if p3 = 8 then
112072: LD_VAR 0 3
112076: PUSH
112077: LD_INT 8
112079: EQUAL
112080: IFFALSE 112090
// sBunker := true ;
112082: LD_ADDR_EXP 155
112086: PUSH
112087: LD_INT 1
112089: ST_TO_ADDR
// if p3 = 9 then
112090: LD_VAR 0 3
112094: PUSH
112095: LD_INT 9
112097: EQUAL
112098: IFFALSE 112108
// sHack := true ;
112100: LD_ADDR_EXP 156
112104: PUSH
112105: LD_INT 1
112107: ST_TO_ADDR
// if p3 = 10 then
112108: LD_VAR 0 3
112112: PUSH
112113: LD_INT 10
112115: EQUAL
112116: IFFALSE 112126
// sFire := true ;
112118: LD_ADDR_EXP 157
112122: PUSH
112123: LD_INT 1
112125: ST_TO_ADDR
// if p3 = 11 then
112126: LD_VAR 0 3
112130: PUSH
112131: LD_INT 11
112133: EQUAL
112134: IFFALSE 112144
// sRefresh := true ;
112136: LD_ADDR_EXP 158
112140: PUSH
112141: LD_INT 1
112143: ST_TO_ADDR
// if p3 = 12 then
112144: LD_VAR 0 3
112148: PUSH
112149: LD_INT 12
112151: EQUAL
112152: IFFALSE 112162
// sExp := true ;
112154: LD_ADDR_EXP 159
112158: PUSH
112159: LD_INT 1
112161: ST_TO_ADDR
// if p3 = 13 then
112162: LD_VAR 0 3
112166: PUSH
112167: LD_INT 13
112169: EQUAL
112170: IFFALSE 112180
// sDepot := true ;
112172: LD_ADDR_EXP 160
112176: PUSH
112177: LD_INT 1
112179: ST_TO_ADDR
// if p3 = 14 then
112180: LD_VAR 0 3
112184: PUSH
112185: LD_INT 14
112187: EQUAL
112188: IFFALSE 112198
// sFlag := true ;
112190: LD_ADDR_EXP 161
112194: PUSH
112195: LD_INT 1
112197: ST_TO_ADDR
// if p3 = 15 then
112198: LD_VAR 0 3
112202: PUSH
112203: LD_INT 15
112205: EQUAL
112206: IFFALSE 112216
// sKamikadze := true ;
112208: LD_ADDR_EXP 169
112212: PUSH
112213: LD_INT 1
112215: ST_TO_ADDR
// if p3 = 16 then
112216: LD_VAR 0 3
112220: PUSH
112221: LD_INT 16
112223: EQUAL
112224: IFFALSE 112234
// sTroll := true ;
112226: LD_ADDR_EXP 170
112230: PUSH
112231: LD_INT 1
112233: ST_TO_ADDR
// if p3 = 17 then
112234: LD_VAR 0 3
112238: PUSH
112239: LD_INT 17
112241: EQUAL
112242: IFFALSE 112252
// sSlow := true ;
112244: LD_ADDR_EXP 171
112248: PUSH
112249: LD_INT 1
112251: ST_TO_ADDR
// if p3 = 18 then
112252: LD_VAR 0 3
112256: PUSH
112257: LD_INT 18
112259: EQUAL
112260: IFFALSE 112270
// sLack := true ;
112262: LD_ADDR_EXP 172
112266: PUSH
112267: LD_INT 1
112269: ST_TO_ADDR
// if p3 = 19 then
112270: LD_VAR 0 3
112274: PUSH
112275: LD_INT 19
112277: EQUAL
112278: IFFALSE 112288
// sTank := true ;
112280: LD_ADDR_EXP 174
112284: PUSH
112285: LD_INT 1
112287: ST_TO_ADDR
// if p3 = 20 then
112288: LD_VAR 0 3
112292: PUSH
112293: LD_INT 20
112295: EQUAL
112296: IFFALSE 112306
// sRemote := true ;
112298: LD_ADDR_EXP 175
112302: PUSH
112303: LD_INT 1
112305: ST_TO_ADDR
// if p3 = 21 then
112306: LD_VAR 0 3
112310: PUSH
112311: LD_INT 21
112313: EQUAL
112314: IFFALSE 112324
// sPowell := true ;
112316: LD_ADDR_EXP 176
112320: PUSH
112321: LD_INT 1
112323: ST_TO_ADDR
// if p3 = 22 then
112324: LD_VAR 0 3
112328: PUSH
112329: LD_INT 22
112331: EQUAL
112332: IFFALSE 112342
// sTeleport := true ;
112334: LD_ADDR_EXP 179
112338: PUSH
112339: LD_INT 1
112341: ST_TO_ADDR
// if p3 = 23 then
112342: LD_VAR 0 3
112346: PUSH
112347: LD_INT 23
112349: EQUAL
112350: IFFALSE 112360
// sOilTower := true ;
112352: LD_ADDR_EXP 181
112356: PUSH
112357: LD_INT 1
112359: ST_TO_ADDR
// if p3 = 24 then
112360: LD_VAR 0 3
112364: PUSH
112365: LD_INT 24
112367: EQUAL
112368: IFFALSE 112378
// sShovel := true ;
112370: LD_ADDR_EXP 182
112374: PUSH
112375: LD_INT 1
112377: ST_TO_ADDR
// if p3 = 25 then
112378: LD_VAR 0 3
112382: PUSH
112383: LD_INT 25
112385: EQUAL
112386: IFFALSE 112396
// sSheik := true ;
112388: LD_ADDR_EXP 183
112392: PUSH
112393: LD_INT 1
112395: ST_TO_ADDR
// if p3 = 26 then
112396: LD_VAR 0 3
112400: PUSH
112401: LD_INT 26
112403: EQUAL
112404: IFFALSE 112414
// sEarthquake := true ;
112406: LD_ADDR_EXP 185
112410: PUSH
112411: LD_INT 1
112413: ST_TO_ADDR
// if p3 = 27 then
112414: LD_VAR 0 3
112418: PUSH
112419: LD_INT 27
112421: EQUAL
112422: IFFALSE 112432
// sAI := true ;
112424: LD_ADDR_EXP 186
112428: PUSH
112429: LD_INT 1
112431: ST_TO_ADDR
// if p3 = 28 then
112432: LD_VAR 0 3
112436: PUSH
112437: LD_INT 28
112439: EQUAL
112440: IFFALSE 112450
// sCargo := true ;
112442: LD_ADDR_EXP 189
112446: PUSH
112447: LD_INT 1
112449: ST_TO_ADDR
// if p3 = 29 then
112450: LD_VAR 0 3
112454: PUSH
112455: LD_INT 29
112457: EQUAL
112458: IFFALSE 112468
// sDLaser := true ;
112460: LD_ADDR_EXP 190
112464: PUSH
112465: LD_INT 1
112467: ST_TO_ADDR
// if p3 = 30 then
112468: LD_VAR 0 3
112472: PUSH
112473: LD_INT 30
112475: EQUAL
112476: IFFALSE 112486
// sExchange := true ;
112478: LD_ADDR_EXP 191
112482: PUSH
112483: LD_INT 1
112485: ST_TO_ADDR
// if p3 = 31 then
112486: LD_VAR 0 3
112490: PUSH
112491: LD_INT 31
112493: EQUAL
112494: IFFALSE 112504
// sFac := true ;
112496: LD_ADDR_EXP 192
112500: PUSH
112501: LD_INT 1
112503: ST_TO_ADDR
// if p3 = 32 then
112504: LD_VAR 0 3
112508: PUSH
112509: LD_INT 32
112511: EQUAL
112512: IFFALSE 112522
// sPower := true ;
112514: LD_ADDR_EXP 193
112518: PUSH
112519: LD_INT 1
112521: ST_TO_ADDR
// if p3 = 33 then
112522: LD_VAR 0 3
112526: PUSH
112527: LD_INT 33
112529: EQUAL
112530: IFFALSE 112540
// sRandom := true ;
112532: LD_ADDR_EXP 194
112536: PUSH
112537: LD_INT 1
112539: ST_TO_ADDR
// if p3 = 34 then
112540: LD_VAR 0 3
112544: PUSH
112545: LD_INT 34
112547: EQUAL
112548: IFFALSE 112558
// sShield := true ;
112550: LD_ADDR_EXP 195
112554: PUSH
112555: LD_INT 1
112557: ST_TO_ADDR
// if p3 = 35 then
112558: LD_VAR 0 3
112562: PUSH
112563: LD_INT 35
112565: EQUAL
112566: IFFALSE 112576
// sTime := true ;
112568: LD_ADDR_EXP 196
112572: PUSH
112573: LD_INT 1
112575: ST_TO_ADDR
// if p3 = 36 then
112576: LD_VAR 0 3
112580: PUSH
112581: LD_INT 36
112583: EQUAL
112584: IFFALSE 112594
// sTools := true ;
112586: LD_ADDR_EXP 197
112590: PUSH
112591: LD_INT 1
112593: ST_TO_ADDR
// if p3 = 101 then
112594: LD_VAR 0 3
112598: PUSH
112599: LD_INT 101
112601: EQUAL
112602: IFFALSE 112612
// sSold := true ;
112604: LD_ADDR_EXP 162
112608: PUSH
112609: LD_INT 1
112611: ST_TO_ADDR
// if p3 = 102 then
112612: LD_VAR 0 3
112616: PUSH
112617: LD_INT 102
112619: EQUAL
112620: IFFALSE 112630
// sDiff := true ;
112622: LD_ADDR_EXP 163
112626: PUSH
112627: LD_INT 1
112629: ST_TO_ADDR
// if p3 = 103 then
112630: LD_VAR 0 3
112634: PUSH
112635: LD_INT 103
112637: EQUAL
112638: IFFALSE 112648
// sFog := true ;
112640: LD_ADDR_EXP 166
112644: PUSH
112645: LD_INT 1
112647: ST_TO_ADDR
// if p3 = 104 then
112648: LD_VAR 0 3
112652: PUSH
112653: LD_INT 104
112655: EQUAL
112656: IFFALSE 112666
// sReset := true ;
112658: LD_ADDR_EXP 167
112662: PUSH
112663: LD_INT 1
112665: ST_TO_ADDR
// if p3 = 105 then
112666: LD_VAR 0 3
112670: PUSH
112671: LD_INT 105
112673: EQUAL
112674: IFFALSE 112684
// sSun := true ;
112676: LD_ADDR_EXP 168
112680: PUSH
112681: LD_INT 1
112683: ST_TO_ADDR
// if p3 = 106 then
112684: LD_VAR 0 3
112688: PUSH
112689: LD_INT 106
112691: EQUAL
112692: IFFALSE 112702
// sTiger := true ;
112694: LD_ADDR_EXP 164
112698: PUSH
112699: LD_INT 1
112701: ST_TO_ADDR
// if p3 = 107 then
112702: LD_VAR 0 3
112706: PUSH
112707: LD_INT 107
112709: EQUAL
112710: IFFALSE 112720
// sBomb := true ;
112712: LD_ADDR_EXP 165
112716: PUSH
112717: LD_INT 1
112719: ST_TO_ADDR
// if p3 = 108 then
112720: LD_VAR 0 3
112724: PUSH
112725: LD_INT 108
112727: EQUAL
112728: IFFALSE 112738
// sWound := true ;
112730: LD_ADDR_EXP 173
112734: PUSH
112735: LD_INT 1
112737: ST_TO_ADDR
// if p3 = 109 then
112738: LD_VAR 0 3
112742: PUSH
112743: LD_INT 109
112745: EQUAL
112746: IFFALSE 112756
// sBetray := true ;
112748: LD_ADDR_EXP 177
112752: PUSH
112753: LD_INT 1
112755: ST_TO_ADDR
// if p3 = 110 then
112756: LD_VAR 0 3
112760: PUSH
112761: LD_INT 110
112763: EQUAL
112764: IFFALSE 112774
// sContamin := true ;
112766: LD_ADDR_EXP 178
112770: PUSH
112771: LD_INT 1
112773: ST_TO_ADDR
// if p3 = 111 then
112774: LD_VAR 0 3
112778: PUSH
112779: LD_INT 111
112781: EQUAL
112782: IFFALSE 112792
// sOil := true ;
112784: LD_ADDR_EXP 180
112788: PUSH
112789: LD_INT 1
112791: ST_TO_ADDR
// if p3 = 112 then
112792: LD_VAR 0 3
112796: PUSH
112797: LD_INT 112
112799: EQUAL
112800: IFFALSE 112810
// sStu := true ;
112802: LD_ADDR_EXP 184
112806: PUSH
112807: LD_INT 1
112809: ST_TO_ADDR
// if p3 = 113 then
112810: LD_VAR 0 3
112814: PUSH
112815: LD_INT 113
112817: EQUAL
112818: IFFALSE 112828
// sBazooka := true ;
112820: LD_ADDR_EXP 187
112824: PUSH
112825: LD_INT 1
112827: ST_TO_ADDR
// if p3 = 114 then
112828: LD_VAR 0 3
112832: PUSH
112833: LD_INT 114
112835: EQUAL
112836: IFFALSE 112846
// sMortar := true ;
112838: LD_ADDR_EXP 188
112842: PUSH
112843: LD_INT 1
112845: ST_TO_ADDR
// if p3 = 115 then
112846: LD_VAR 0 3
112850: PUSH
112851: LD_INT 115
112853: EQUAL
112854: IFFALSE 112864
// sRanger := true ;
112856: LD_ADDR_EXP 198
112860: PUSH
112861: LD_INT 1
112863: ST_TO_ADDR
// end ; end ;
112864: PPOPN 6
112866: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
112867: LD_EXP 145
112871: PUSH
112872: LD_EXP 150
112876: AND
112877: IFFALSE 113001
112879: GO 112881
112881: DISABLE
112882: LD_INT 0
112884: PPUSH
112885: PPUSH
// begin enable ;
112886: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
112887: LD_ADDR_VAR 0 2
112891: PUSH
112892: LD_INT 22
112894: PUSH
112895: LD_OWVAR 2
112899: PUSH
112900: EMPTY
112901: LIST
112902: LIST
112903: PUSH
112904: LD_INT 2
112906: PUSH
112907: LD_INT 34
112909: PUSH
112910: LD_INT 7
112912: PUSH
112913: EMPTY
112914: LIST
112915: LIST
112916: PUSH
112917: LD_INT 34
112919: PUSH
112920: LD_INT 45
112922: PUSH
112923: EMPTY
112924: LIST
112925: LIST
112926: PUSH
112927: LD_INT 34
112929: PUSH
112930: LD_INT 28
112932: PUSH
112933: EMPTY
112934: LIST
112935: LIST
112936: PUSH
112937: LD_INT 34
112939: PUSH
112940: LD_INT 47
112942: PUSH
112943: EMPTY
112944: LIST
112945: LIST
112946: PUSH
112947: EMPTY
112948: LIST
112949: LIST
112950: LIST
112951: LIST
112952: LIST
112953: PUSH
112954: EMPTY
112955: LIST
112956: LIST
112957: PPUSH
112958: CALL_OW 69
112962: ST_TO_ADDR
// if not tmp then
112963: LD_VAR 0 2
112967: NOT
112968: IFFALSE 112972
// exit ;
112970: GO 113001
// for i in tmp do
112972: LD_ADDR_VAR 0 1
112976: PUSH
112977: LD_VAR 0 2
112981: PUSH
112982: FOR_IN
112983: IFFALSE 112999
// begin SetLives ( i , 0 ) ;
112985: LD_VAR 0 1
112989: PPUSH
112990: LD_INT 0
112992: PPUSH
112993: CALL_OW 234
// end ;
112997: GO 112982
112999: POP
113000: POP
// end ;
113001: PPOPN 2
113003: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
113004: LD_EXP 145
113008: PUSH
113009: LD_EXP 151
113013: AND
113014: IFFALSE 113098
113016: GO 113018
113018: DISABLE
113019: LD_INT 0
113021: PPUSH
113022: PPUSH
// begin enable ;
113023: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
113024: LD_ADDR_VAR 0 2
113028: PUSH
113029: LD_INT 22
113031: PUSH
113032: LD_OWVAR 2
113036: PUSH
113037: EMPTY
113038: LIST
113039: LIST
113040: PUSH
113041: LD_INT 32
113043: PUSH
113044: LD_INT 3
113046: PUSH
113047: EMPTY
113048: LIST
113049: LIST
113050: PUSH
113051: EMPTY
113052: LIST
113053: LIST
113054: PPUSH
113055: CALL_OW 69
113059: ST_TO_ADDR
// if not tmp then
113060: LD_VAR 0 2
113064: NOT
113065: IFFALSE 113069
// exit ;
113067: GO 113098
// for i in tmp do
113069: LD_ADDR_VAR 0 1
113073: PUSH
113074: LD_VAR 0 2
113078: PUSH
113079: FOR_IN
113080: IFFALSE 113096
// begin SetLives ( i , 0 ) ;
113082: LD_VAR 0 1
113086: PPUSH
113087: LD_INT 0
113089: PPUSH
113090: CALL_OW 234
// end ;
113094: GO 113079
113096: POP
113097: POP
// end ;
113098: PPOPN 2
113100: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113101: LD_EXP 145
113105: PUSH
113106: LD_EXP 148
113110: AND
113111: IFFALSE 113204
113113: GO 113115
113115: DISABLE
113116: LD_INT 0
113118: PPUSH
// begin enable ;
113119: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113120: LD_ADDR_VAR 0 1
113124: PUSH
113125: LD_INT 22
113127: PUSH
113128: LD_OWVAR 2
113132: PUSH
113133: EMPTY
113134: LIST
113135: LIST
113136: PUSH
113137: LD_INT 2
113139: PUSH
113140: LD_INT 25
113142: PUSH
113143: LD_INT 5
113145: PUSH
113146: EMPTY
113147: LIST
113148: LIST
113149: PUSH
113150: LD_INT 25
113152: PUSH
113153: LD_INT 9
113155: PUSH
113156: EMPTY
113157: LIST
113158: LIST
113159: PUSH
113160: LD_INT 25
113162: PUSH
113163: LD_INT 8
113165: PUSH
113166: EMPTY
113167: LIST
113168: LIST
113169: PUSH
113170: EMPTY
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: PUSH
113176: EMPTY
113177: LIST
113178: LIST
113179: PPUSH
113180: CALL_OW 69
113184: PUSH
113185: FOR_IN
113186: IFFALSE 113202
// begin SetClass ( i , 1 ) ;
113188: LD_VAR 0 1
113192: PPUSH
113193: LD_INT 1
113195: PPUSH
113196: CALL_OW 336
// end ;
113200: GO 113185
113202: POP
113203: POP
// end ;
113204: PPOPN 1
113206: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113207: LD_EXP 145
113211: PUSH
113212: LD_EXP 149
113216: AND
113217: PUSH
113218: LD_OWVAR 65
113222: PUSH
113223: LD_INT 7
113225: LESS
113226: AND
113227: IFFALSE 113241
113229: GO 113231
113231: DISABLE
// begin enable ;
113232: ENABLE
// game_speed := 7 ;
113233: LD_ADDR_OWVAR 65
113237: PUSH
113238: LD_INT 7
113240: ST_TO_ADDR
// end ;
113241: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113242: LD_EXP 145
113246: PUSH
113247: LD_EXP 152
113251: AND
113252: IFFALSE 113454
113254: GO 113256
113256: DISABLE
113257: LD_INT 0
113259: PPUSH
113260: PPUSH
113261: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113262: LD_ADDR_VAR 0 3
113266: PUSH
113267: LD_INT 81
113269: PUSH
113270: LD_OWVAR 2
113274: PUSH
113275: EMPTY
113276: LIST
113277: LIST
113278: PUSH
113279: LD_INT 21
113281: PUSH
113282: LD_INT 1
113284: PUSH
113285: EMPTY
113286: LIST
113287: LIST
113288: PUSH
113289: EMPTY
113290: LIST
113291: LIST
113292: PPUSH
113293: CALL_OW 69
113297: ST_TO_ADDR
// if not tmp then
113298: LD_VAR 0 3
113302: NOT
113303: IFFALSE 113307
// exit ;
113305: GO 113454
// if tmp > 5 then
113307: LD_VAR 0 3
113311: PUSH
113312: LD_INT 5
113314: GREATER
113315: IFFALSE 113327
// k := 5 else
113317: LD_ADDR_VAR 0 2
113321: PUSH
113322: LD_INT 5
113324: ST_TO_ADDR
113325: GO 113337
// k := tmp ;
113327: LD_ADDR_VAR 0 2
113331: PUSH
113332: LD_VAR 0 3
113336: ST_TO_ADDR
// for i := 1 to k do
113337: LD_ADDR_VAR 0 1
113341: PUSH
113342: DOUBLE
113343: LD_INT 1
113345: DEC
113346: ST_TO_ADDR
113347: LD_VAR 0 2
113351: PUSH
113352: FOR_TO
113353: IFFALSE 113452
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113355: LD_VAR 0 3
113359: PUSH
113360: LD_VAR 0 1
113364: ARRAY
113365: PPUSH
113366: LD_VAR 0 1
113370: PUSH
113371: LD_INT 4
113373: MOD
113374: PUSH
113375: LD_INT 1
113377: PLUS
113378: PPUSH
113379: CALL_OW 259
113383: PUSH
113384: LD_INT 10
113386: LESS
113387: IFFALSE 113450
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113389: LD_VAR 0 3
113393: PUSH
113394: LD_VAR 0 1
113398: ARRAY
113399: PPUSH
113400: LD_VAR 0 1
113404: PUSH
113405: LD_INT 4
113407: MOD
113408: PUSH
113409: LD_INT 1
113411: PLUS
113412: PPUSH
113413: LD_VAR 0 3
113417: PUSH
113418: LD_VAR 0 1
113422: ARRAY
113423: PPUSH
113424: LD_VAR 0 1
113428: PUSH
113429: LD_INT 4
113431: MOD
113432: PUSH
113433: LD_INT 1
113435: PLUS
113436: PPUSH
113437: CALL_OW 259
113441: PUSH
113442: LD_INT 1
113444: PLUS
113445: PPUSH
113446: CALL_OW 237
113450: GO 113352
113452: POP
113453: POP
// end ;
113454: PPOPN 3
113456: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113457: LD_EXP 145
113461: PUSH
113462: LD_EXP 153
113466: AND
113467: IFFALSE 113487
113469: GO 113471
113471: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113472: LD_INT 4
113474: PPUSH
113475: LD_OWVAR 2
113479: PPUSH
113480: LD_INT 0
113482: PPUSH
113483: CALL_OW 324
113487: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113488: LD_EXP 145
113492: PUSH
113493: LD_EXP 182
113497: AND
113498: IFFALSE 113518
113500: GO 113502
113502: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113503: LD_INT 19
113505: PPUSH
113506: LD_OWVAR 2
113510: PPUSH
113511: LD_INT 0
113513: PPUSH
113514: CALL_OW 324
113518: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113519: LD_EXP 145
113523: PUSH
113524: LD_EXP 154
113528: AND
113529: IFFALSE 113631
113531: GO 113533
113533: DISABLE
113534: LD_INT 0
113536: PPUSH
113537: PPUSH
// begin enable ;
113538: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113539: LD_ADDR_VAR 0 2
113543: PUSH
113544: LD_INT 22
113546: PUSH
113547: LD_OWVAR 2
113551: PUSH
113552: EMPTY
113553: LIST
113554: LIST
113555: PUSH
113556: LD_INT 2
113558: PUSH
113559: LD_INT 34
113561: PUSH
113562: LD_INT 11
113564: PUSH
113565: EMPTY
113566: LIST
113567: LIST
113568: PUSH
113569: LD_INT 34
113571: PUSH
113572: LD_INT 30
113574: PUSH
113575: EMPTY
113576: LIST
113577: LIST
113578: PUSH
113579: EMPTY
113580: LIST
113581: LIST
113582: LIST
113583: PUSH
113584: EMPTY
113585: LIST
113586: LIST
113587: PPUSH
113588: CALL_OW 69
113592: ST_TO_ADDR
// if not tmp then
113593: LD_VAR 0 2
113597: NOT
113598: IFFALSE 113602
// exit ;
113600: GO 113631
// for i in tmp do
113602: LD_ADDR_VAR 0 1
113606: PUSH
113607: LD_VAR 0 2
113611: PUSH
113612: FOR_IN
113613: IFFALSE 113629
// begin SetLives ( i , 0 ) ;
113615: LD_VAR 0 1
113619: PPUSH
113620: LD_INT 0
113622: PPUSH
113623: CALL_OW 234
// end ;
113627: GO 113612
113629: POP
113630: POP
// end ;
113631: PPOPN 2
113633: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113634: LD_EXP 145
113638: PUSH
113639: LD_EXP 155
113643: AND
113644: IFFALSE 113664
113646: GO 113648
113648: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113649: LD_INT 32
113651: PPUSH
113652: LD_OWVAR 2
113656: PPUSH
113657: LD_INT 0
113659: PPUSH
113660: CALL_OW 324
113664: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113665: LD_EXP 145
113669: PUSH
113670: LD_EXP 156
113674: AND
113675: IFFALSE 113856
113677: GO 113679
113679: DISABLE
113680: LD_INT 0
113682: PPUSH
113683: PPUSH
113684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113685: LD_ADDR_VAR 0 2
113689: PUSH
113690: LD_INT 22
113692: PUSH
113693: LD_OWVAR 2
113697: PUSH
113698: EMPTY
113699: LIST
113700: LIST
113701: PUSH
113702: LD_INT 33
113704: PUSH
113705: LD_INT 3
113707: PUSH
113708: EMPTY
113709: LIST
113710: LIST
113711: PUSH
113712: EMPTY
113713: LIST
113714: LIST
113715: PPUSH
113716: CALL_OW 69
113720: ST_TO_ADDR
// if not tmp then
113721: LD_VAR 0 2
113725: NOT
113726: IFFALSE 113730
// exit ;
113728: GO 113856
// side := 0 ;
113730: LD_ADDR_VAR 0 3
113734: PUSH
113735: LD_INT 0
113737: ST_TO_ADDR
// for i := 1 to 8 do
113738: LD_ADDR_VAR 0 1
113742: PUSH
113743: DOUBLE
113744: LD_INT 1
113746: DEC
113747: ST_TO_ADDR
113748: LD_INT 8
113750: PUSH
113751: FOR_TO
113752: IFFALSE 113800
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113754: LD_OWVAR 2
113758: PUSH
113759: LD_VAR 0 1
113763: NONEQUAL
113764: PUSH
113765: LD_OWVAR 2
113769: PPUSH
113770: LD_VAR 0 1
113774: PPUSH
113775: CALL_OW 81
113779: PUSH
113780: LD_INT 2
113782: EQUAL
113783: AND
113784: IFFALSE 113798
// begin side := i ;
113786: LD_ADDR_VAR 0 3
113790: PUSH
113791: LD_VAR 0 1
113795: ST_TO_ADDR
// break ;
113796: GO 113800
// end ;
113798: GO 113751
113800: POP
113801: POP
// if not side then
113802: LD_VAR 0 3
113806: NOT
113807: IFFALSE 113811
// exit ;
113809: GO 113856
// for i := 1 to tmp do
113811: LD_ADDR_VAR 0 1
113815: PUSH
113816: DOUBLE
113817: LD_INT 1
113819: DEC
113820: ST_TO_ADDR
113821: LD_VAR 0 2
113825: PUSH
113826: FOR_TO
113827: IFFALSE 113854
// if Prob ( 60 ) then
113829: LD_INT 60
113831: PPUSH
113832: CALL_OW 13
113836: IFFALSE 113852
// SetSide ( i , side ) ;
113838: LD_VAR 0 1
113842: PPUSH
113843: LD_VAR 0 3
113847: PPUSH
113848: CALL_OW 235
113852: GO 113826
113854: POP
113855: POP
// end ;
113856: PPOPN 3
113858: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
113859: LD_EXP 145
113863: PUSH
113864: LD_EXP 158
113868: AND
113869: IFFALSE 113988
113871: GO 113873
113873: DISABLE
113874: LD_INT 0
113876: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
113877: LD_ADDR_VAR 0 1
113881: PUSH
113882: LD_INT 22
113884: PUSH
113885: LD_OWVAR 2
113889: PUSH
113890: EMPTY
113891: LIST
113892: LIST
113893: PUSH
113894: LD_INT 21
113896: PUSH
113897: LD_INT 1
113899: PUSH
113900: EMPTY
113901: LIST
113902: LIST
113903: PUSH
113904: LD_INT 3
113906: PUSH
113907: LD_INT 23
113909: PUSH
113910: LD_INT 0
113912: PUSH
113913: EMPTY
113914: LIST
113915: LIST
113916: PUSH
113917: EMPTY
113918: LIST
113919: LIST
113920: PUSH
113921: EMPTY
113922: LIST
113923: LIST
113924: LIST
113925: PPUSH
113926: CALL_OW 69
113930: PUSH
113931: FOR_IN
113932: IFFALSE 113986
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
113934: LD_VAR 0 1
113938: PPUSH
113939: CALL_OW 257
113943: PUSH
113944: LD_INT 1
113946: PUSH
113947: LD_INT 2
113949: PUSH
113950: LD_INT 3
113952: PUSH
113953: LD_INT 4
113955: PUSH
113956: EMPTY
113957: LIST
113958: LIST
113959: LIST
113960: LIST
113961: IN
113962: IFFALSE 113984
// SetClass ( un , rand ( 1 , 4 ) ) ;
113964: LD_VAR 0 1
113968: PPUSH
113969: LD_INT 1
113971: PPUSH
113972: LD_INT 4
113974: PPUSH
113975: CALL_OW 12
113979: PPUSH
113980: CALL_OW 336
113984: GO 113931
113986: POP
113987: POP
// end ;
113988: PPOPN 1
113990: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
113991: LD_EXP 145
113995: PUSH
113996: LD_EXP 157
114000: AND
114001: IFFALSE 114080
114003: GO 114005
114005: DISABLE
114006: LD_INT 0
114008: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114009: LD_ADDR_VAR 0 1
114013: PUSH
114014: LD_INT 22
114016: PUSH
114017: LD_OWVAR 2
114021: PUSH
114022: EMPTY
114023: LIST
114024: LIST
114025: PUSH
114026: LD_INT 21
114028: PUSH
114029: LD_INT 3
114031: PUSH
114032: EMPTY
114033: LIST
114034: LIST
114035: PUSH
114036: EMPTY
114037: LIST
114038: LIST
114039: PPUSH
114040: CALL_OW 69
114044: ST_TO_ADDR
// if not tmp then
114045: LD_VAR 0 1
114049: NOT
114050: IFFALSE 114054
// exit ;
114052: GO 114080
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114054: LD_VAR 0 1
114058: PUSH
114059: LD_INT 1
114061: PPUSH
114062: LD_VAR 0 1
114066: PPUSH
114067: CALL_OW 12
114071: ARRAY
114072: PPUSH
114073: LD_INT 100
114075: PPUSH
114076: CALL_OW 234
// end ;
114080: PPOPN 1
114082: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114083: LD_EXP 145
114087: PUSH
114088: LD_EXP 159
114092: AND
114093: IFFALSE 114191
114095: GO 114097
114097: DISABLE
114098: LD_INT 0
114100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114101: LD_ADDR_VAR 0 1
114105: PUSH
114106: LD_INT 22
114108: PUSH
114109: LD_OWVAR 2
114113: PUSH
114114: EMPTY
114115: LIST
114116: LIST
114117: PUSH
114118: LD_INT 21
114120: PUSH
114121: LD_INT 1
114123: PUSH
114124: EMPTY
114125: LIST
114126: LIST
114127: PUSH
114128: EMPTY
114129: LIST
114130: LIST
114131: PPUSH
114132: CALL_OW 69
114136: ST_TO_ADDR
// if not tmp then
114137: LD_VAR 0 1
114141: NOT
114142: IFFALSE 114146
// exit ;
114144: GO 114191
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114146: LD_VAR 0 1
114150: PUSH
114151: LD_INT 1
114153: PPUSH
114154: LD_VAR 0 1
114158: PPUSH
114159: CALL_OW 12
114163: ARRAY
114164: PPUSH
114165: LD_INT 1
114167: PPUSH
114168: LD_INT 4
114170: PPUSH
114171: CALL_OW 12
114175: PPUSH
114176: LD_INT 3000
114178: PPUSH
114179: LD_INT 9000
114181: PPUSH
114182: CALL_OW 12
114186: PPUSH
114187: CALL_OW 492
// end ;
114191: PPOPN 1
114193: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114194: LD_EXP 145
114198: PUSH
114199: LD_EXP 160
114203: AND
114204: IFFALSE 114224
114206: GO 114208
114208: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114209: LD_INT 1
114211: PPUSH
114212: LD_OWVAR 2
114216: PPUSH
114217: LD_INT 0
114219: PPUSH
114220: CALL_OW 324
114224: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114225: LD_EXP 145
114229: PUSH
114230: LD_EXP 161
114234: AND
114235: IFFALSE 114318
114237: GO 114239
114239: DISABLE
114240: LD_INT 0
114242: PPUSH
114243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114244: LD_ADDR_VAR 0 2
114248: PUSH
114249: LD_INT 22
114251: PUSH
114252: LD_OWVAR 2
114256: PUSH
114257: EMPTY
114258: LIST
114259: LIST
114260: PUSH
114261: LD_INT 21
114263: PUSH
114264: LD_INT 3
114266: PUSH
114267: EMPTY
114268: LIST
114269: LIST
114270: PUSH
114271: EMPTY
114272: LIST
114273: LIST
114274: PPUSH
114275: CALL_OW 69
114279: ST_TO_ADDR
// if not tmp then
114280: LD_VAR 0 2
114284: NOT
114285: IFFALSE 114289
// exit ;
114287: GO 114318
// for i in tmp do
114289: LD_ADDR_VAR 0 1
114293: PUSH
114294: LD_VAR 0 2
114298: PUSH
114299: FOR_IN
114300: IFFALSE 114316
// SetBLevel ( i , 10 ) ;
114302: LD_VAR 0 1
114306: PPUSH
114307: LD_INT 10
114309: PPUSH
114310: CALL_OW 241
114314: GO 114299
114316: POP
114317: POP
// end ;
114318: PPOPN 2
114320: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114321: LD_EXP 145
114325: PUSH
114326: LD_EXP 162
114330: AND
114331: IFFALSE 114442
114333: GO 114335
114335: DISABLE
114336: LD_INT 0
114338: PPUSH
114339: PPUSH
114340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114341: LD_ADDR_VAR 0 3
114345: PUSH
114346: LD_INT 22
114348: PUSH
114349: LD_OWVAR 2
114353: PUSH
114354: EMPTY
114355: LIST
114356: LIST
114357: PUSH
114358: LD_INT 25
114360: PUSH
114361: LD_INT 1
114363: PUSH
114364: EMPTY
114365: LIST
114366: LIST
114367: PUSH
114368: EMPTY
114369: LIST
114370: LIST
114371: PPUSH
114372: CALL_OW 69
114376: ST_TO_ADDR
// if not tmp then
114377: LD_VAR 0 3
114381: NOT
114382: IFFALSE 114386
// exit ;
114384: GO 114442
// un := tmp [ rand ( 1 , tmp ) ] ;
114386: LD_ADDR_VAR 0 2
114390: PUSH
114391: LD_VAR 0 3
114395: PUSH
114396: LD_INT 1
114398: PPUSH
114399: LD_VAR 0 3
114403: PPUSH
114404: CALL_OW 12
114408: ARRAY
114409: ST_TO_ADDR
// if Crawls ( un ) then
114410: LD_VAR 0 2
114414: PPUSH
114415: CALL_OW 318
114419: IFFALSE 114430
// ComWalk ( un ) ;
114421: LD_VAR 0 2
114425: PPUSH
114426: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114430: LD_VAR 0 2
114434: PPUSH
114435: LD_INT 5
114437: PPUSH
114438: CALL_OW 336
// end ;
114442: PPOPN 3
114444: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
114445: LD_EXP 145
114449: PUSH
114450: LD_EXP 163
114454: AND
114455: PUSH
114456: LD_OWVAR 67
114460: PUSH
114461: LD_INT 3
114463: LESS
114464: AND
114465: IFFALSE 114484
114467: GO 114469
114469: DISABLE
// Difficulty := Difficulty + 1 ;
114470: LD_ADDR_OWVAR 67
114474: PUSH
114475: LD_OWVAR 67
114479: PUSH
114480: LD_INT 1
114482: PLUS
114483: ST_TO_ADDR
114484: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114485: LD_EXP 145
114489: PUSH
114490: LD_EXP 164
114494: AND
114495: IFFALSE 114598
114497: GO 114499
114499: DISABLE
114500: LD_INT 0
114502: PPUSH
// begin for i := 1 to 5 do
114503: LD_ADDR_VAR 0 1
114507: PUSH
114508: DOUBLE
114509: LD_INT 1
114511: DEC
114512: ST_TO_ADDR
114513: LD_INT 5
114515: PUSH
114516: FOR_TO
114517: IFFALSE 114596
// begin uc_nation := nation_nature ;
114519: LD_ADDR_OWVAR 21
114523: PUSH
114524: LD_INT 0
114526: ST_TO_ADDR
// uc_side := 0 ;
114527: LD_ADDR_OWVAR 20
114531: PUSH
114532: LD_INT 0
114534: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114535: LD_ADDR_OWVAR 29
114539: PUSH
114540: LD_INT 12
114542: PUSH
114543: LD_INT 12
114545: PUSH
114546: EMPTY
114547: LIST
114548: LIST
114549: ST_TO_ADDR
// hc_agressivity := 20 ;
114550: LD_ADDR_OWVAR 35
114554: PUSH
114555: LD_INT 20
114557: ST_TO_ADDR
// hc_class := class_tiger ;
114558: LD_ADDR_OWVAR 28
114562: PUSH
114563: LD_INT 14
114565: ST_TO_ADDR
// hc_gallery :=  ;
114566: LD_ADDR_OWVAR 33
114570: PUSH
114571: LD_STRING 
114573: ST_TO_ADDR
// hc_name :=  ;
114574: LD_ADDR_OWVAR 26
114578: PUSH
114579: LD_STRING 
114581: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114582: CALL_OW 44
114586: PPUSH
114587: LD_INT 0
114589: PPUSH
114590: CALL_OW 51
// end ;
114594: GO 114516
114596: POP
114597: POP
// end ;
114598: PPOPN 1
114600: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114601: LD_EXP 145
114605: PUSH
114606: LD_EXP 165
114610: AND
114611: IFFALSE 114620
114613: GO 114615
114615: DISABLE
// StreamSibBomb ;
114616: CALL 114621 0 0
114620: END
// export function StreamSibBomb ; var i , x , y ; begin
114621: LD_INT 0
114623: PPUSH
114624: PPUSH
114625: PPUSH
114626: PPUSH
// result := false ;
114627: LD_ADDR_VAR 0 1
114631: PUSH
114632: LD_INT 0
114634: ST_TO_ADDR
// for i := 1 to 16 do
114635: LD_ADDR_VAR 0 2
114639: PUSH
114640: DOUBLE
114641: LD_INT 1
114643: DEC
114644: ST_TO_ADDR
114645: LD_INT 16
114647: PUSH
114648: FOR_TO
114649: IFFALSE 114848
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114651: LD_ADDR_VAR 0 3
114655: PUSH
114656: LD_INT 10
114658: PUSH
114659: LD_INT 20
114661: PUSH
114662: LD_INT 30
114664: PUSH
114665: LD_INT 40
114667: PUSH
114668: LD_INT 50
114670: PUSH
114671: LD_INT 60
114673: PUSH
114674: LD_INT 70
114676: PUSH
114677: LD_INT 80
114679: PUSH
114680: LD_INT 90
114682: PUSH
114683: LD_INT 100
114685: PUSH
114686: LD_INT 110
114688: PUSH
114689: LD_INT 120
114691: PUSH
114692: LD_INT 130
114694: PUSH
114695: LD_INT 140
114697: PUSH
114698: LD_INT 150
114700: PUSH
114701: EMPTY
114702: LIST
114703: LIST
114704: LIST
114705: LIST
114706: LIST
114707: LIST
114708: LIST
114709: LIST
114710: LIST
114711: LIST
114712: LIST
114713: LIST
114714: LIST
114715: LIST
114716: LIST
114717: PUSH
114718: LD_INT 1
114720: PPUSH
114721: LD_INT 15
114723: PPUSH
114724: CALL_OW 12
114728: ARRAY
114729: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114730: LD_ADDR_VAR 0 4
114734: PUSH
114735: LD_INT 10
114737: PUSH
114738: LD_INT 20
114740: PUSH
114741: LD_INT 30
114743: PUSH
114744: LD_INT 40
114746: PUSH
114747: LD_INT 50
114749: PUSH
114750: LD_INT 60
114752: PUSH
114753: LD_INT 70
114755: PUSH
114756: LD_INT 80
114758: PUSH
114759: LD_INT 90
114761: PUSH
114762: LD_INT 100
114764: PUSH
114765: LD_INT 110
114767: PUSH
114768: LD_INT 120
114770: PUSH
114771: LD_INT 130
114773: PUSH
114774: LD_INT 140
114776: PUSH
114777: LD_INT 150
114779: PUSH
114780: EMPTY
114781: LIST
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: LIST
114789: LIST
114790: LIST
114791: LIST
114792: LIST
114793: LIST
114794: LIST
114795: LIST
114796: PUSH
114797: LD_INT 1
114799: PPUSH
114800: LD_INT 15
114802: PPUSH
114803: CALL_OW 12
114807: ARRAY
114808: ST_TO_ADDR
// if ValidHex ( x , y ) then
114809: LD_VAR 0 3
114813: PPUSH
114814: LD_VAR 0 4
114818: PPUSH
114819: CALL_OW 488
114823: IFFALSE 114846
// begin result := [ x , y ] ;
114825: LD_ADDR_VAR 0 1
114829: PUSH
114830: LD_VAR 0 3
114834: PUSH
114835: LD_VAR 0 4
114839: PUSH
114840: EMPTY
114841: LIST
114842: LIST
114843: ST_TO_ADDR
// break ;
114844: GO 114848
// end ; end ;
114846: GO 114648
114848: POP
114849: POP
// if result then
114850: LD_VAR 0 1
114854: IFFALSE 114914
// begin ToLua ( playSibBomb() ) ;
114856: LD_STRING playSibBomb()
114858: PPUSH
114859: CALL_OW 559
// wait ( 0 0$14 ) ;
114863: LD_INT 490
114865: PPUSH
114866: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
114870: LD_VAR 0 1
114874: PUSH
114875: LD_INT 1
114877: ARRAY
114878: PPUSH
114879: LD_VAR 0 1
114883: PUSH
114884: LD_INT 2
114886: ARRAY
114887: PPUSH
114888: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
114892: LD_VAR 0 1
114896: PUSH
114897: LD_INT 1
114899: ARRAY
114900: PPUSH
114901: LD_VAR 0 1
114905: PUSH
114906: LD_INT 2
114908: ARRAY
114909: PPUSH
114910: CALL_OW 429
// end ; end ;
114914: LD_VAR 0 1
114918: RET
// every 0 0$1 trigger StreamModeActive and sReset do
114919: LD_EXP 145
114923: PUSH
114924: LD_EXP 167
114928: AND
114929: IFFALSE 114941
114931: GO 114933
114933: DISABLE
// YouLost (  ) ;
114934: LD_STRING 
114936: PPUSH
114937: CALL_OW 104
114941: END
// every 0 0$1 trigger StreamModeActive and sFog do
114942: LD_EXP 145
114946: PUSH
114947: LD_EXP 166
114951: AND
114952: IFFALSE 114966
114954: GO 114956
114956: DISABLE
// FogOff ( your_side ) ;
114957: LD_OWVAR 2
114961: PPUSH
114962: CALL_OW 344
114966: END
// every 0 0$1 trigger StreamModeActive and sSun do
114967: LD_EXP 145
114971: PUSH
114972: LD_EXP 168
114976: AND
114977: IFFALSE 115005
114979: GO 114981
114981: DISABLE
// begin solar_recharge_percent := 0 ;
114982: LD_ADDR_OWVAR 79
114986: PUSH
114987: LD_INT 0
114989: ST_TO_ADDR
// wait ( 5 5$00 ) ;
114990: LD_INT 10500
114992: PPUSH
114993: CALL_OW 67
// solar_recharge_percent := 100 ;
114997: LD_ADDR_OWVAR 79
115001: PUSH
115002: LD_INT 100
115004: ST_TO_ADDR
// end ;
115005: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
115006: LD_EXP 145
115010: PUSH
115011: LD_EXP 169
115015: AND
115016: IFFALSE 115255
115018: GO 115020
115020: DISABLE
115021: LD_INT 0
115023: PPUSH
115024: PPUSH
115025: PPUSH
// begin tmp := [ ] ;
115026: LD_ADDR_VAR 0 3
115030: PUSH
115031: EMPTY
115032: ST_TO_ADDR
// for i := 1 to 6 do
115033: LD_ADDR_VAR 0 1
115037: PUSH
115038: DOUBLE
115039: LD_INT 1
115041: DEC
115042: ST_TO_ADDR
115043: LD_INT 6
115045: PUSH
115046: FOR_TO
115047: IFFALSE 115152
// begin uc_nation := nation_nature ;
115049: LD_ADDR_OWVAR 21
115053: PUSH
115054: LD_INT 0
115056: ST_TO_ADDR
// uc_side := 0 ;
115057: LD_ADDR_OWVAR 20
115061: PUSH
115062: LD_INT 0
115064: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115065: LD_ADDR_OWVAR 29
115069: PUSH
115070: LD_INT 12
115072: PUSH
115073: LD_INT 12
115075: PUSH
115076: EMPTY
115077: LIST
115078: LIST
115079: ST_TO_ADDR
// hc_agressivity := 20 ;
115080: LD_ADDR_OWVAR 35
115084: PUSH
115085: LD_INT 20
115087: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115088: LD_ADDR_OWVAR 28
115092: PUSH
115093: LD_INT 17
115095: ST_TO_ADDR
// hc_gallery :=  ;
115096: LD_ADDR_OWVAR 33
115100: PUSH
115101: LD_STRING 
115103: ST_TO_ADDR
// hc_name :=  ;
115104: LD_ADDR_OWVAR 26
115108: PUSH
115109: LD_STRING 
115111: ST_TO_ADDR
// un := CreateHuman ;
115112: LD_ADDR_VAR 0 2
115116: PUSH
115117: CALL_OW 44
115121: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115122: LD_VAR 0 2
115126: PPUSH
115127: LD_INT 1
115129: PPUSH
115130: CALL_OW 51
// tmp := tmp ^ un ;
115134: LD_ADDR_VAR 0 3
115138: PUSH
115139: LD_VAR 0 3
115143: PUSH
115144: LD_VAR 0 2
115148: ADD
115149: ST_TO_ADDR
// end ;
115150: GO 115046
115152: POP
115153: POP
// repeat wait ( 0 0$1 ) ;
115154: LD_INT 35
115156: PPUSH
115157: CALL_OW 67
// for un in tmp do
115161: LD_ADDR_VAR 0 2
115165: PUSH
115166: LD_VAR 0 3
115170: PUSH
115171: FOR_IN
115172: IFFALSE 115246
// begin if IsDead ( un ) then
115174: LD_VAR 0 2
115178: PPUSH
115179: CALL_OW 301
115183: IFFALSE 115203
// begin tmp := tmp diff un ;
115185: LD_ADDR_VAR 0 3
115189: PUSH
115190: LD_VAR 0 3
115194: PUSH
115195: LD_VAR 0 2
115199: DIFF
115200: ST_TO_ADDR
// continue ;
115201: GO 115171
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115203: LD_VAR 0 2
115207: PPUSH
115208: LD_INT 3
115210: PUSH
115211: LD_INT 22
115213: PUSH
115214: LD_INT 0
115216: PUSH
115217: EMPTY
115218: LIST
115219: LIST
115220: PUSH
115221: EMPTY
115222: LIST
115223: LIST
115224: PPUSH
115225: CALL_OW 69
115229: PPUSH
115230: LD_VAR 0 2
115234: PPUSH
115235: CALL_OW 74
115239: PPUSH
115240: CALL_OW 115
// end ;
115244: GO 115171
115246: POP
115247: POP
// until not tmp ;
115248: LD_VAR 0 3
115252: NOT
115253: IFFALSE 115154
// end ;
115255: PPOPN 3
115257: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115258: LD_EXP 145
115262: PUSH
115263: LD_EXP 170
115267: AND
115268: IFFALSE 115322
115270: GO 115272
115272: DISABLE
// begin ToLua ( displayTroll(); ) ;
115273: LD_STRING displayTroll();
115275: PPUSH
115276: CALL_OW 559
// wait ( 3 3$00 ) ;
115280: LD_INT 6300
115282: PPUSH
115283: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115287: LD_STRING hideTroll();
115289: PPUSH
115290: CALL_OW 559
// wait ( 1 1$00 ) ;
115294: LD_INT 2100
115296: PPUSH
115297: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115301: LD_STRING displayTroll();
115303: PPUSH
115304: CALL_OW 559
// wait ( 1 1$00 ) ;
115308: LD_INT 2100
115310: PPUSH
115311: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115315: LD_STRING hideTroll();
115317: PPUSH
115318: CALL_OW 559
// end ;
115322: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115323: LD_EXP 145
115327: PUSH
115328: LD_EXP 171
115332: AND
115333: IFFALSE 115396
115335: GO 115337
115337: DISABLE
115338: LD_INT 0
115340: PPUSH
// begin p := 0 ;
115341: LD_ADDR_VAR 0 1
115345: PUSH
115346: LD_INT 0
115348: ST_TO_ADDR
// repeat game_speed := 1 ;
115349: LD_ADDR_OWVAR 65
115353: PUSH
115354: LD_INT 1
115356: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115357: LD_INT 35
115359: PPUSH
115360: CALL_OW 67
// p := p + 1 ;
115364: LD_ADDR_VAR 0 1
115368: PUSH
115369: LD_VAR 0 1
115373: PUSH
115374: LD_INT 1
115376: PLUS
115377: ST_TO_ADDR
// until p >= 60 ;
115378: LD_VAR 0 1
115382: PUSH
115383: LD_INT 60
115385: GREATEREQUAL
115386: IFFALSE 115349
// game_speed := 4 ;
115388: LD_ADDR_OWVAR 65
115392: PUSH
115393: LD_INT 4
115395: ST_TO_ADDR
// end ;
115396: PPOPN 1
115398: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115399: LD_EXP 145
115403: PUSH
115404: LD_EXP 172
115408: AND
115409: IFFALSE 115555
115411: GO 115413
115413: DISABLE
115414: LD_INT 0
115416: PPUSH
115417: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115418: LD_ADDR_VAR 0 1
115422: PUSH
115423: LD_INT 22
115425: PUSH
115426: LD_OWVAR 2
115430: PUSH
115431: EMPTY
115432: LIST
115433: LIST
115434: PUSH
115435: LD_INT 2
115437: PUSH
115438: LD_INT 30
115440: PUSH
115441: LD_INT 0
115443: PUSH
115444: EMPTY
115445: LIST
115446: LIST
115447: PUSH
115448: LD_INT 30
115450: PUSH
115451: LD_INT 1
115453: PUSH
115454: EMPTY
115455: LIST
115456: LIST
115457: PUSH
115458: EMPTY
115459: LIST
115460: LIST
115461: LIST
115462: PUSH
115463: EMPTY
115464: LIST
115465: LIST
115466: PPUSH
115467: CALL_OW 69
115471: ST_TO_ADDR
// if not depot then
115472: LD_VAR 0 1
115476: NOT
115477: IFFALSE 115481
// exit ;
115479: GO 115555
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115481: LD_ADDR_VAR 0 2
115485: PUSH
115486: LD_VAR 0 1
115490: PUSH
115491: LD_INT 1
115493: PPUSH
115494: LD_VAR 0 1
115498: PPUSH
115499: CALL_OW 12
115503: ARRAY
115504: PPUSH
115505: CALL_OW 274
115509: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115510: LD_VAR 0 2
115514: PPUSH
115515: LD_INT 1
115517: PPUSH
115518: LD_INT 0
115520: PPUSH
115521: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115525: LD_VAR 0 2
115529: PPUSH
115530: LD_INT 2
115532: PPUSH
115533: LD_INT 0
115535: PPUSH
115536: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115540: LD_VAR 0 2
115544: PPUSH
115545: LD_INT 3
115547: PPUSH
115548: LD_INT 0
115550: PPUSH
115551: CALL_OW 277
// end ;
115555: PPOPN 2
115557: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115558: LD_EXP 145
115562: PUSH
115563: LD_EXP 173
115567: AND
115568: IFFALSE 115665
115570: GO 115572
115572: DISABLE
115573: LD_INT 0
115575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115576: LD_ADDR_VAR 0 1
115580: PUSH
115581: LD_INT 22
115583: PUSH
115584: LD_OWVAR 2
115588: PUSH
115589: EMPTY
115590: LIST
115591: LIST
115592: PUSH
115593: LD_INT 21
115595: PUSH
115596: LD_INT 1
115598: PUSH
115599: EMPTY
115600: LIST
115601: LIST
115602: PUSH
115603: LD_INT 3
115605: PUSH
115606: LD_INT 23
115608: PUSH
115609: LD_INT 0
115611: PUSH
115612: EMPTY
115613: LIST
115614: LIST
115615: PUSH
115616: EMPTY
115617: LIST
115618: LIST
115619: PUSH
115620: EMPTY
115621: LIST
115622: LIST
115623: LIST
115624: PPUSH
115625: CALL_OW 69
115629: ST_TO_ADDR
// if not tmp then
115630: LD_VAR 0 1
115634: NOT
115635: IFFALSE 115639
// exit ;
115637: GO 115665
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115639: LD_VAR 0 1
115643: PUSH
115644: LD_INT 1
115646: PPUSH
115647: LD_VAR 0 1
115651: PPUSH
115652: CALL_OW 12
115656: ARRAY
115657: PPUSH
115658: LD_INT 200
115660: PPUSH
115661: CALL_OW 234
// end ;
115665: PPOPN 1
115667: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115668: LD_EXP 145
115672: PUSH
115673: LD_EXP 174
115677: AND
115678: IFFALSE 115757
115680: GO 115682
115682: DISABLE
115683: LD_INT 0
115685: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115686: LD_ADDR_VAR 0 1
115690: PUSH
115691: LD_INT 22
115693: PUSH
115694: LD_OWVAR 2
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: PUSH
115703: LD_INT 21
115705: PUSH
115706: LD_INT 2
115708: PUSH
115709: EMPTY
115710: LIST
115711: LIST
115712: PUSH
115713: EMPTY
115714: LIST
115715: LIST
115716: PPUSH
115717: CALL_OW 69
115721: ST_TO_ADDR
// if not tmp then
115722: LD_VAR 0 1
115726: NOT
115727: IFFALSE 115731
// exit ;
115729: GO 115757
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115731: LD_VAR 0 1
115735: PUSH
115736: LD_INT 1
115738: PPUSH
115739: LD_VAR 0 1
115743: PPUSH
115744: CALL_OW 12
115748: ARRAY
115749: PPUSH
115750: LD_INT 60
115752: PPUSH
115753: CALL_OW 234
// end ;
115757: PPOPN 1
115759: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115760: LD_EXP 145
115764: PUSH
115765: LD_EXP 175
115769: AND
115770: IFFALSE 115869
115772: GO 115774
115774: DISABLE
115775: LD_INT 0
115777: PPUSH
115778: PPUSH
// begin enable ;
115779: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115780: LD_ADDR_VAR 0 1
115784: PUSH
115785: LD_INT 22
115787: PUSH
115788: LD_OWVAR 2
115792: PUSH
115793: EMPTY
115794: LIST
115795: LIST
115796: PUSH
115797: LD_INT 61
115799: PUSH
115800: EMPTY
115801: LIST
115802: PUSH
115803: LD_INT 33
115805: PUSH
115806: LD_INT 2
115808: PUSH
115809: EMPTY
115810: LIST
115811: LIST
115812: PUSH
115813: EMPTY
115814: LIST
115815: LIST
115816: LIST
115817: PPUSH
115818: CALL_OW 69
115822: ST_TO_ADDR
// if not tmp then
115823: LD_VAR 0 1
115827: NOT
115828: IFFALSE 115832
// exit ;
115830: GO 115869
// for i in tmp do
115832: LD_ADDR_VAR 0 2
115836: PUSH
115837: LD_VAR 0 1
115841: PUSH
115842: FOR_IN
115843: IFFALSE 115867
// if IsControledBy ( i ) then
115845: LD_VAR 0 2
115849: PPUSH
115850: CALL_OW 312
115854: IFFALSE 115865
// ComUnlink ( i ) ;
115856: LD_VAR 0 2
115860: PPUSH
115861: CALL_OW 136
115865: GO 115842
115867: POP
115868: POP
// end ;
115869: PPOPN 2
115871: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
115872: LD_EXP 145
115876: PUSH
115877: LD_EXP 176
115881: AND
115882: IFFALSE 116022
115884: GO 115886
115886: DISABLE
115887: LD_INT 0
115889: PPUSH
115890: PPUSH
// begin ToLua ( displayPowell(); ) ;
115891: LD_STRING displayPowell();
115893: PPUSH
115894: CALL_OW 559
// uc_side := 0 ;
115898: LD_ADDR_OWVAR 20
115902: PUSH
115903: LD_INT 0
115905: ST_TO_ADDR
// uc_nation := 2 ;
115906: LD_ADDR_OWVAR 21
115910: PUSH
115911: LD_INT 2
115913: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
115914: LD_ADDR_OWVAR 37
115918: PUSH
115919: LD_INT 14
115921: ST_TO_ADDR
// vc_engine := engine_siberite ;
115922: LD_ADDR_OWVAR 39
115926: PUSH
115927: LD_INT 3
115929: ST_TO_ADDR
// vc_control := control_apeman ;
115930: LD_ADDR_OWVAR 38
115934: PUSH
115935: LD_INT 5
115937: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
115938: LD_ADDR_OWVAR 40
115942: PUSH
115943: LD_INT 29
115945: ST_TO_ADDR
// un := CreateVehicle ;
115946: LD_ADDR_VAR 0 2
115950: PUSH
115951: CALL_OW 45
115955: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115956: LD_VAR 0 2
115960: PPUSH
115961: LD_INT 1
115963: PPUSH
115964: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115968: LD_INT 35
115970: PPUSH
115971: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115975: LD_VAR 0 2
115979: PPUSH
115980: LD_INT 22
115982: PUSH
115983: LD_OWVAR 2
115987: PUSH
115988: EMPTY
115989: LIST
115990: LIST
115991: PPUSH
115992: CALL_OW 69
115996: PPUSH
115997: LD_VAR 0 2
116001: PPUSH
116002: CALL_OW 74
116006: PPUSH
116007: CALL_OW 115
// until IsDead ( un ) ;
116011: LD_VAR 0 2
116015: PPUSH
116016: CALL_OW 301
116020: IFFALSE 115968
// end ;
116022: PPOPN 2
116024: END
// every 0 0$1 trigger StreamModeActive and sStu do
116025: LD_EXP 145
116029: PUSH
116030: LD_EXP 184
116034: AND
116035: IFFALSE 116051
116037: GO 116039
116039: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116040: LD_STRING displayStucuk();
116042: PPUSH
116043: CALL_OW 559
// ResetFog ;
116047: CALL_OW 335
// end ;
116051: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116052: LD_EXP 145
116056: PUSH
116057: LD_EXP 177
116061: AND
116062: IFFALSE 116203
116064: GO 116066
116066: DISABLE
116067: LD_INT 0
116069: PPUSH
116070: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116071: LD_ADDR_VAR 0 2
116075: PUSH
116076: LD_INT 22
116078: PUSH
116079: LD_OWVAR 2
116083: PUSH
116084: EMPTY
116085: LIST
116086: LIST
116087: PUSH
116088: LD_INT 21
116090: PUSH
116091: LD_INT 1
116093: PUSH
116094: EMPTY
116095: LIST
116096: LIST
116097: PUSH
116098: EMPTY
116099: LIST
116100: LIST
116101: PPUSH
116102: CALL_OW 69
116106: ST_TO_ADDR
// if not tmp then
116107: LD_VAR 0 2
116111: NOT
116112: IFFALSE 116116
// exit ;
116114: GO 116203
// un := tmp [ rand ( 1 , tmp ) ] ;
116116: LD_ADDR_VAR 0 1
116120: PUSH
116121: LD_VAR 0 2
116125: PUSH
116126: LD_INT 1
116128: PPUSH
116129: LD_VAR 0 2
116133: PPUSH
116134: CALL_OW 12
116138: ARRAY
116139: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116140: LD_VAR 0 1
116144: PPUSH
116145: LD_INT 0
116147: PPUSH
116148: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116152: LD_VAR 0 1
116156: PPUSH
116157: LD_OWVAR 3
116161: PUSH
116162: LD_VAR 0 1
116166: DIFF
116167: PPUSH
116168: LD_VAR 0 1
116172: PPUSH
116173: CALL_OW 74
116177: PPUSH
116178: CALL_OW 115
// wait ( 0 0$20 ) ;
116182: LD_INT 700
116184: PPUSH
116185: CALL_OW 67
// SetSide ( un , your_side ) ;
116189: LD_VAR 0 1
116193: PPUSH
116194: LD_OWVAR 2
116198: PPUSH
116199: CALL_OW 235
// end ;
116203: PPOPN 2
116205: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116206: LD_EXP 145
116210: PUSH
116211: LD_EXP 178
116215: AND
116216: IFFALSE 116322
116218: GO 116220
116220: DISABLE
116221: LD_INT 0
116223: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116224: LD_ADDR_VAR 0 1
116228: PUSH
116229: LD_INT 22
116231: PUSH
116232: LD_OWVAR 2
116236: PUSH
116237: EMPTY
116238: LIST
116239: LIST
116240: PUSH
116241: LD_INT 2
116243: PUSH
116244: LD_INT 30
116246: PUSH
116247: LD_INT 0
116249: PUSH
116250: EMPTY
116251: LIST
116252: LIST
116253: PUSH
116254: LD_INT 30
116256: PUSH
116257: LD_INT 1
116259: PUSH
116260: EMPTY
116261: LIST
116262: LIST
116263: PUSH
116264: EMPTY
116265: LIST
116266: LIST
116267: LIST
116268: PUSH
116269: EMPTY
116270: LIST
116271: LIST
116272: PPUSH
116273: CALL_OW 69
116277: ST_TO_ADDR
// if not depot then
116278: LD_VAR 0 1
116282: NOT
116283: IFFALSE 116287
// exit ;
116285: GO 116322
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116287: LD_VAR 0 1
116291: PUSH
116292: LD_INT 1
116294: ARRAY
116295: PPUSH
116296: CALL_OW 250
116300: PPUSH
116301: LD_VAR 0 1
116305: PUSH
116306: LD_INT 1
116308: ARRAY
116309: PPUSH
116310: CALL_OW 251
116314: PPUSH
116315: LD_INT 70
116317: PPUSH
116318: CALL_OW 495
// end ;
116322: PPOPN 1
116324: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116325: LD_EXP 145
116329: PUSH
116330: LD_EXP 179
116334: AND
116335: IFFALSE 116546
116337: GO 116339
116339: DISABLE
116340: LD_INT 0
116342: PPUSH
116343: PPUSH
116344: PPUSH
116345: PPUSH
116346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116347: LD_ADDR_VAR 0 5
116351: PUSH
116352: LD_INT 22
116354: PUSH
116355: LD_OWVAR 2
116359: PUSH
116360: EMPTY
116361: LIST
116362: LIST
116363: PUSH
116364: LD_INT 21
116366: PUSH
116367: LD_INT 1
116369: PUSH
116370: EMPTY
116371: LIST
116372: LIST
116373: PUSH
116374: EMPTY
116375: LIST
116376: LIST
116377: PPUSH
116378: CALL_OW 69
116382: ST_TO_ADDR
// if not tmp then
116383: LD_VAR 0 5
116387: NOT
116388: IFFALSE 116392
// exit ;
116390: GO 116546
// for i in tmp do
116392: LD_ADDR_VAR 0 1
116396: PUSH
116397: LD_VAR 0 5
116401: PUSH
116402: FOR_IN
116403: IFFALSE 116544
// begin d := rand ( 0 , 5 ) ;
116405: LD_ADDR_VAR 0 4
116409: PUSH
116410: LD_INT 0
116412: PPUSH
116413: LD_INT 5
116415: PPUSH
116416: CALL_OW 12
116420: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116421: LD_ADDR_VAR 0 2
116425: PUSH
116426: LD_VAR 0 1
116430: PPUSH
116431: CALL_OW 250
116435: PPUSH
116436: LD_VAR 0 4
116440: PPUSH
116441: LD_INT 3
116443: PPUSH
116444: LD_INT 12
116446: PPUSH
116447: CALL_OW 12
116451: PPUSH
116452: CALL_OW 272
116456: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116457: LD_ADDR_VAR 0 3
116461: PUSH
116462: LD_VAR 0 1
116466: PPUSH
116467: CALL_OW 251
116471: PPUSH
116472: LD_VAR 0 4
116476: PPUSH
116477: LD_INT 3
116479: PPUSH
116480: LD_INT 12
116482: PPUSH
116483: CALL_OW 12
116487: PPUSH
116488: CALL_OW 273
116492: ST_TO_ADDR
// if ValidHex ( x , y ) then
116493: LD_VAR 0 2
116497: PPUSH
116498: LD_VAR 0 3
116502: PPUSH
116503: CALL_OW 488
116507: IFFALSE 116542
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116509: LD_VAR 0 1
116513: PPUSH
116514: LD_VAR 0 2
116518: PPUSH
116519: LD_VAR 0 3
116523: PPUSH
116524: LD_INT 3
116526: PPUSH
116527: LD_INT 6
116529: PPUSH
116530: CALL_OW 12
116534: PPUSH
116535: LD_INT 1
116537: PPUSH
116538: CALL_OW 483
// end ;
116542: GO 116402
116544: POP
116545: POP
// end ;
116546: PPOPN 5
116548: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116549: LD_EXP 145
116553: PUSH
116554: LD_EXP 180
116558: AND
116559: IFFALSE 116653
116561: GO 116563
116563: DISABLE
116564: LD_INT 0
116566: PPUSH
116567: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116568: LD_ADDR_VAR 0 2
116572: PUSH
116573: LD_INT 22
116575: PUSH
116576: LD_OWVAR 2
116580: PUSH
116581: EMPTY
116582: LIST
116583: LIST
116584: PUSH
116585: LD_INT 32
116587: PUSH
116588: LD_INT 1
116590: PUSH
116591: EMPTY
116592: LIST
116593: LIST
116594: PUSH
116595: LD_INT 21
116597: PUSH
116598: LD_INT 2
116600: PUSH
116601: EMPTY
116602: LIST
116603: LIST
116604: PUSH
116605: EMPTY
116606: LIST
116607: LIST
116608: LIST
116609: PPUSH
116610: CALL_OW 69
116614: ST_TO_ADDR
// if not tmp then
116615: LD_VAR 0 2
116619: NOT
116620: IFFALSE 116624
// exit ;
116622: GO 116653
// for i in tmp do
116624: LD_ADDR_VAR 0 1
116628: PUSH
116629: LD_VAR 0 2
116633: PUSH
116634: FOR_IN
116635: IFFALSE 116651
// SetFuel ( i , 0 ) ;
116637: LD_VAR 0 1
116641: PPUSH
116642: LD_INT 0
116644: PPUSH
116645: CALL_OW 240
116649: GO 116634
116651: POP
116652: POP
// end ;
116653: PPOPN 2
116655: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116656: LD_EXP 145
116660: PUSH
116661: LD_EXP 181
116665: AND
116666: IFFALSE 116732
116668: GO 116670
116670: DISABLE
116671: LD_INT 0
116673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116674: LD_ADDR_VAR 0 1
116678: PUSH
116679: LD_INT 22
116681: PUSH
116682: LD_OWVAR 2
116686: PUSH
116687: EMPTY
116688: LIST
116689: LIST
116690: PUSH
116691: LD_INT 30
116693: PUSH
116694: LD_INT 29
116696: PUSH
116697: EMPTY
116698: LIST
116699: LIST
116700: PUSH
116701: EMPTY
116702: LIST
116703: LIST
116704: PPUSH
116705: CALL_OW 69
116709: ST_TO_ADDR
// if not tmp then
116710: LD_VAR 0 1
116714: NOT
116715: IFFALSE 116719
// exit ;
116717: GO 116732
// DestroyUnit ( tmp [ 1 ] ) ;
116719: LD_VAR 0 1
116723: PUSH
116724: LD_INT 1
116726: ARRAY
116727: PPUSH
116728: CALL_OW 65
// end ;
116732: PPOPN 1
116734: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116735: LD_EXP 145
116739: PUSH
116740: LD_EXP 183
116744: AND
116745: IFFALSE 116874
116747: GO 116749
116749: DISABLE
116750: LD_INT 0
116752: PPUSH
// begin uc_side := 0 ;
116753: LD_ADDR_OWVAR 20
116757: PUSH
116758: LD_INT 0
116760: ST_TO_ADDR
// uc_nation := nation_arabian ;
116761: LD_ADDR_OWVAR 21
116765: PUSH
116766: LD_INT 2
116768: ST_TO_ADDR
// hc_gallery :=  ;
116769: LD_ADDR_OWVAR 33
116773: PUSH
116774: LD_STRING 
116776: ST_TO_ADDR
// hc_name :=  ;
116777: LD_ADDR_OWVAR 26
116781: PUSH
116782: LD_STRING 
116784: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116785: LD_INT 1
116787: PPUSH
116788: LD_INT 11
116790: PPUSH
116791: LD_INT 10
116793: PPUSH
116794: CALL_OW 380
// un := CreateHuman ;
116798: LD_ADDR_VAR 0 1
116802: PUSH
116803: CALL_OW 44
116807: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116808: LD_VAR 0 1
116812: PPUSH
116813: LD_INT 1
116815: PPUSH
116816: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116820: LD_INT 35
116822: PPUSH
116823: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116827: LD_VAR 0 1
116831: PPUSH
116832: LD_INT 22
116834: PUSH
116835: LD_OWVAR 2
116839: PUSH
116840: EMPTY
116841: LIST
116842: LIST
116843: PPUSH
116844: CALL_OW 69
116848: PPUSH
116849: LD_VAR 0 1
116853: PPUSH
116854: CALL_OW 74
116858: PPUSH
116859: CALL_OW 115
// until IsDead ( un ) ;
116863: LD_VAR 0 1
116867: PPUSH
116868: CALL_OW 301
116872: IFFALSE 116820
// end ;
116874: PPOPN 1
116876: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
116877: LD_EXP 145
116881: PUSH
116882: LD_EXP 185
116886: AND
116887: IFFALSE 116899
116889: GO 116891
116891: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
116892: LD_STRING earthquake(getX(game), 0, 32)
116894: PPUSH
116895: CALL_OW 559
116899: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
116900: LD_EXP 145
116904: PUSH
116905: LD_EXP 186
116909: AND
116910: IFFALSE 117001
116912: GO 116914
116914: DISABLE
116915: LD_INT 0
116917: PPUSH
// begin enable ;
116918: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
116919: LD_ADDR_VAR 0 1
116923: PUSH
116924: LD_INT 22
116926: PUSH
116927: LD_OWVAR 2
116931: PUSH
116932: EMPTY
116933: LIST
116934: LIST
116935: PUSH
116936: LD_INT 21
116938: PUSH
116939: LD_INT 2
116941: PUSH
116942: EMPTY
116943: LIST
116944: LIST
116945: PUSH
116946: LD_INT 33
116948: PUSH
116949: LD_INT 3
116951: PUSH
116952: EMPTY
116953: LIST
116954: LIST
116955: PUSH
116956: EMPTY
116957: LIST
116958: LIST
116959: LIST
116960: PPUSH
116961: CALL_OW 69
116965: ST_TO_ADDR
// if not tmp then
116966: LD_VAR 0 1
116970: NOT
116971: IFFALSE 116975
// exit ;
116973: GO 117001
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116975: LD_VAR 0 1
116979: PUSH
116980: LD_INT 1
116982: PPUSH
116983: LD_VAR 0 1
116987: PPUSH
116988: CALL_OW 12
116992: ARRAY
116993: PPUSH
116994: LD_INT 1
116996: PPUSH
116997: CALL_OW 234
// end ;
117001: PPOPN 1
117003: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
117004: LD_EXP 145
117008: PUSH
117009: LD_EXP 187
117013: AND
117014: IFFALSE 117155
117016: GO 117018
117018: DISABLE
117019: LD_INT 0
117021: PPUSH
117022: PPUSH
117023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117024: LD_ADDR_VAR 0 3
117028: PUSH
117029: LD_INT 22
117031: PUSH
117032: LD_OWVAR 2
117036: PUSH
117037: EMPTY
117038: LIST
117039: LIST
117040: PUSH
117041: LD_INT 25
117043: PUSH
117044: LD_INT 1
117046: PUSH
117047: EMPTY
117048: LIST
117049: LIST
117050: PUSH
117051: EMPTY
117052: LIST
117053: LIST
117054: PPUSH
117055: CALL_OW 69
117059: ST_TO_ADDR
// if not tmp then
117060: LD_VAR 0 3
117064: NOT
117065: IFFALSE 117069
// exit ;
117067: GO 117155
// un := tmp [ rand ( 1 , tmp ) ] ;
117069: LD_ADDR_VAR 0 2
117073: PUSH
117074: LD_VAR 0 3
117078: PUSH
117079: LD_INT 1
117081: PPUSH
117082: LD_VAR 0 3
117086: PPUSH
117087: CALL_OW 12
117091: ARRAY
117092: ST_TO_ADDR
// if Crawls ( un ) then
117093: LD_VAR 0 2
117097: PPUSH
117098: CALL_OW 318
117102: IFFALSE 117113
// ComWalk ( un ) ;
117104: LD_VAR 0 2
117108: PPUSH
117109: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117113: LD_VAR 0 2
117117: PPUSH
117118: LD_INT 9
117120: PPUSH
117121: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117125: LD_INT 28
117127: PPUSH
117128: LD_OWVAR 2
117132: PPUSH
117133: LD_INT 2
117135: PPUSH
117136: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117140: LD_INT 29
117142: PPUSH
117143: LD_OWVAR 2
117147: PPUSH
117148: LD_INT 2
117150: PPUSH
117151: CALL_OW 322
// end ;
117155: PPOPN 3
117157: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117158: LD_EXP 145
117162: PUSH
117163: LD_EXP 188
117167: AND
117168: IFFALSE 117279
117170: GO 117172
117172: DISABLE
117173: LD_INT 0
117175: PPUSH
117176: PPUSH
117177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117178: LD_ADDR_VAR 0 3
117182: PUSH
117183: LD_INT 22
117185: PUSH
117186: LD_OWVAR 2
117190: PUSH
117191: EMPTY
117192: LIST
117193: LIST
117194: PUSH
117195: LD_INT 25
117197: PUSH
117198: LD_INT 1
117200: PUSH
117201: EMPTY
117202: LIST
117203: LIST
117204: PUSH
117205: EMPTY
117206: LIST
117207: LIST
117208: PPUSH
117209: CALL_OW 69
117213: ST_TO_ADDR
// if not tmp then
117214: LD_VAR 0 3
117218: NOT
117219: IFFALSE 117223
// exit ;
117221: GO 117279
// un := tmp [ rand ( 1 , tmp ) ] ;
117223: LD_ADDR_VAR 0 2
117227: PUSH
117228: LD_VAR 0 3
117232: PUSH
117233: LD_INT 1
117235: PPUSH
117236: LD_VAR 0 3
117240: PPUSH
117241: CALL_OW 12
117245: ARRAY
117246: ST_TO_ADDR
// if Crawls ( un ) then
117247: LD_VAR 0 2
117251: PPUSH
117252: CALL_OW 318
117256: IFFALSE 117267
// ComWalk ( un ) ;
117258: LD_VAR 0 2
117262: PPUSH
117263: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117267: LD_VAR 0 2
117271: PPUSH
117272: LD_INT 8
117274: PPUSH
117275: CALL_OW 336
// end ;
117279: PPOPN 3
117281: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117282: LD_EXP 145
117286: PUSH
117287: LD_EXP 189
117291: AND
117292: IFFALSE 117436
117294: GO 117296
117296: DISABLE
117297: LD_INT 0
117299: PPUSH
117300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117301: LD_ADDR_VAR 0 2
117305: PUSH
117306: LD_INT 22
117308: PUSH
117309: LD_OWVAR 2
117313: PUSH
117314: EMPTY
117315: LIST
117316: LIST
117317: PUSH
117318: LD_INT 21
117320: PUSH
117321: LD_INT 2
117323: PUSH
117324: EMPTY
117325: LIST
117326: LIST
117327: PUSH
117328: LD_INT 2
117330: PUSH
117331: LD_INT 34
117333: PUSH
117334: LD_INT 12
117336: PUSH
117337: EMPTY
117338: LIST
117339: LIST
117340: PUSH
117341: LD_INT 34
117343: PUSH
117344: LD_INT 51
117346: PUSH
117347: EMPTY
117348: LIST
117349: LIST
117350: PUSH
117351: LD_INT 34
117353: PUSH
117354: LD_INT 32
117356: PUSH
117357: EMPTY
117358: LIST
117359: LIST
117360: PUSH
117361: EMPTY
117362: LIST
117363: LIST
117364: LIST
117365: LIST
117366: PUSH
117367: EMPTY
117368: LIST
117369: LIST
117370: LIST
117371: PPUSH
117372: CALL_OW 69
117376: ST_TO_ADDR
// if not tmp then
117377: LD_VAR 0 2
117381: NOT
117382: IFFALSE 117386
// exit ;
117384: GO 117436
// for i in tmp do
117386: LD_ADDR_VAR 0 1
117390: PUSH
117391: LD_VAR 0 2
117395: PUSH
117396: FOR_IN
117397: IFFALSE 117434
// if GetCargo ( i , mat_artifact ) = 0 then
117399: LD_VAR 0 1
117403: PPUSH
117404: LD_INT 4
117406: PPUSH
117407: CALL_OW 289
117411: PUSH
117412: LD_INT 0
117414: EQUAL
117415: IFFALSE 117432
// SetCargo ( i , mat_siberit , 100 ) ;
117417: LD_VAR 0 1
117421: PPUSH
117422: LD_INT 3
117424: PPUSH
117425: LD_INT 100
117427: PPUSH
117428: CALL_OW 290
117432: GO 117396
117434: POP
117435: POP
// end ;
117436: PPOPN 2
117438: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117439: LD_EXP 145
117443: PUSH
117444: LD_EXP 190
117448: AND
117449: IFFALSE 117602
117451: GO 117453
117453: DISABLE
117454: LD_INT 0
117456: PPUSH
117457: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117458: LD_ADDR_VAR 0 2
117462: PUSH
117463: LD_INT 22
117465: PUSH
117466: LD_OWVAR 2
117470: PUSH
117471: EMPTY
117472: LIST
117473: LIST
117474: PPUSH
117475: CALL_OW 69
117479: ST_TO_ADDR
// if not tmp then
117480: LD_VAR 0 2
117484: NOT
117485: IFFALSE 117489
// exit ;
117487: GO 117602
// for i := 1 to 2 do
117489: LD_ADDR_VAR 0 1
117493: PUSH
117494: DOUBLE
117495: LD_INT 1
117497: DEC
117498: ST_TO_ADDR
117499: LD_INT 2
117501: PUSH
117502: FOR_TO
117503: IFFALSE 117600
// begin uc_side := your_side ;
117505: LD_ADDR_OWVAR 20
117509: PUSH
117510: LD_OWVAR 2
117514: ST_TO_ADDR
// uc_nation := nation_american ;
117515: LD_ADDR_OWVAR 21
117519: PUSH
117520: LD_INT 1
117522: ST_TO_ADDR
// vc_chassis := us_morphling ;
117523: LD_ADDR_OWVAR 37
117527: PUSH
117528: LD_INT 5
117530: ST_TO_ADDR
// vc_engine := engine_siberite ;
117531: LD_ADDR_OWVAR 39
117535: PUSH
117536: LD_INT 3
117538: ST_TO_ADDR
// vc_control := control_computer ;
117539: LD_ADDR_OWVAR 38
117543: PUSH
117544: LD_INT 3
117546: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117547: LD_ADDR_OWVAR 40
117551: PUSH
117552: LD_INT 10
117554: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
117555: CALL_OW 45
117559: PPUSH
117560: LD_VAR 0 2
117564: PUSH
117565: LD_INT 1
117567: ARRAY
117568: PPUSH
117569: CALL_OW 250
117573: PPUSH
117574: LD_VAR 0 2
117578: PUSH
117579: LD_INT 1
117581: ARRAY
117582: PPUSH
117583: CALL_OW 251
117587: PPUSH
117588: LD_INT 12
117590: PPUSH
117591: LD_INT 1
117593: PPUSH
117594: CALL_OW 50
// end ;
117598: GO 117502
117600: POP
117601: POP
// end ;
117602: PPOPN 2
117604: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117605: LD_EXP 145
117609: PUSH
117610: LD_EXP 191
117614: AND
117615: IFFALSE 117837
117617: GO 117619
117619: DISABLE
117620: LD_INT 0
117622: PPUSH
117623: PPUSH
117624: PPUSH
117625: PPUSH
117626: PPUSH
117627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117628: LD_ADDR_VAR 0 6
117632: PUSH
117633: LD_INT 22
117635: PUSH
117636: LD_OWVAR 2
117640: PUSH
117641: EMPTY
117642: LIST
117643: LIST
117644: PUSH
117645: LD_INT 21
117647: PUSH
117648: LD_INT 1
117650: PUSH
117651: EMPTY
117652: LIST
117653: LIST
117654: PUSH
117655: LD_INT 3
117657: PUSH
117658: LD_INT 23
117660: PUSH
117661: LD_INT 0
117663: PUSH
117664: EMPTY
117665: LIST
117666: LIST
117667: PUSH
117668: EMPTY
117669: LIST
117670: LIST
117671: PUSH
117672: EMPTY
117673: LIST
117674: LIST
117675: LIST
117676: PPUSH
117677: CALL_OW 69
117681: ST_TO_ADDR
// if not tmp then
117682: LD_VAR 0 6
117686: NOT
117687: IFFALSE 117691
// exit ;
117689: GO 117837
// s1 := rand ( 1 , 4 ) ;
117691: LD_ADDR_VAR 0 2
117695: PUSH
117696: LD_INT 1
117698: PPUSH
117699: LD_INT 4
117701: PPUSH
117702: CALL_OW 12
117706: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117707: LD_ADDR_VAR 0 4
117711: PUSH
117712: LD_VAR 0 6
117716: PUSH
117717: LD_INT 1
117719: ARRAY
117720: PPUSH
117721: LD_VAR 0 2
117725: PPUSH
117726: CALL_OW 259
117730: ST_TO_ADDR
// if s1 = 1 then
117731: LD_VAR 0 2
117735: PUSH
117736: LD_INT 1
117738: EQUAL
117739: IFFALSE 117759
// s2 := rand ( 2 , 4 ) else
117741: LD_ADDR_VAR 0 3
117745: PUSH
117746: LD_INT 2
117748: PPUSH
117749: LD_INT 4
117751: PPUSH
117752: CALL_OW 12
117756: ST_TO_ADDR
117757: GO 117767
// s2 := 1 ;
117759: LD_ADDR_VAR 0 3
117763: PUSH
117764: LD_INT 1
117766: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117767: LD_ADDR_VAR 0 5
117771: PUSH
117772: LD_VAR 0 6
117776: PUSH
117777: LD_INT 1
117779: ARRAY
117780: PPUSH
117781: LD_VAR 0 3
117785: PPUSH
117786: CALL_OW 259
117790: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
117791: LD_VAR 0 6
117795: PUSH
117796: LD_INT 1
117798: ARRAY
117799: PPUSH
117800: LD_VAR 0 2
117804: PPUSH
117805: LD_VAR 0 5
117809: PPUSH
117810: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
117814: LD_VAR 0 6
117818: PUSH
117819: LD_INT 1
117821: ARRAY
117822: PPUSH
117823: LD_VAR 0 3
117827: PPUSH
117828: LD_VAR 0 4
117832: PPUSH
117833: CALL_OW 237
// end ;
117837: PPOPN 6
117839: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
117840: LD_EXP 145
117844: PUSH
117845: LD_EXP 192
117849: AND
117850: IFFALSE 117929
117852: GO 117854
117854: DISABLE
117855: LD_INT 0
117857: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
117858: LD_ADDR_VAR 0 1
117862: PUSH
117863: LD_INT 22
117865: PUSH
117866: LD_OWVAR 2
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: PUSH
117875: LD_INT 30
117877: PUSH
117878: LD_INT 3
117880: PUSH
117881: EMPTY
117882: LIST
117883: LIST
117884: PUSH
117885: EMPTY
117886: LIST
117887: LIST
117888: PPUSH
117889: CALL_OW 69
117893: ST_TO_ADDR
// if not tmp then
117894: LD_VAR 0 1
117898: NOT
117899: IFFALSE 117903
// exit ;
117901: GO 117929
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117903: LD_VAR 0 1
117907: PUSH
117908: LD_INT 1
117910: PPUSH
117911: LD_VAR 0 1
117915: PPUSH
117916: CALL_OW 12
117920: ARRAY
117921: PPUSH
117922: LD_INT 1
117924: PPUSH
117925: CALL_OW 234
// end ;
117929: PPOPN 1
117931: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
117932: LD_EXP 145
117936: PUSH
117937: LD_EXP 193
117941: AND
117942: IFFALSE 118054
117944: GO 117946
117946: DISABLE
117947: LD_INT 0
117949: PPUSH
117950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
117951: LD_ADDR_VAR 0 2
117955: PUSH
117956: LD_INT 22
117958: PUSH
117959: LD_OWVAR 2
117963: PUSH
117964: EMPTY
117965: LIST
117966: LIST
117967: PUSH
117968: LD_INT 2
117970: PUSH
117971: LD_INT 30
117973: PUSH
117974: LD_INT 27
117976: PUSH
117977: EMPTY
117978: LIST
117979: LIST
117980: PUSH
117981: LD_INT 30
117983: PUSH
117984: LD_INT 26
117986: PUSH
117987: EMPTY
117988: LIST
117989: LIST
117990: PUSH
117991: LD_INT 30
117993: PUSH
117994: LD_INT 28
117996: PUSH
117997: EMPTY
117998: LIST
117999: LIST
118000: PUSH
118001: EMPTY
118002: LIST
118003: LIST
118004: LIST
118005: LIST
118006: PUSH
118007: EMPTY
118008: LIST
118009: LIST
118010: PPUSH
118011: CALL_OW 69
118015: ST_TO_ADDR
// if not tmp then
118016: LD_VAR 0 2
118020: NOT
118021: IFFALSE 118025
// exit ;
118023: GO 118054
// for i in tmp do
118025: LD_ADDR_VAR 0 1
118029: PUSH
118030: LD_VAR 0 2
118034: PUSH
118035: FOR_IN
118036: IFFALSE 118052
// SetLives ( i , 1 ) ;
118038: LD_VAR 0 1
118042: PPUSH
118043: LD_INT 1
118045: PPUSH
118046: CALL_OW 234
118050: GO 118035
118052: POP
118053: POP
// end ;
118054: PPOPN 2
118056: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118057: LD_EXP 145
118061: PUSH
118062: LD_EXP 194
118066: AND
118067: IFFALSE 118341
118069: GO 118071
118071: DISABLE
118072: LD_INT 0
118074: PPUSH
118075: PPUSH
118076: PPUSH
// begin i := rand ( 1 , 7 ) ;
118077: LD_ADDR_VAR 0 1
118081: PUSH
118082: LD_INT 1
118084: PPUSH
118085: LD_INT 7
118087: PPUSH
118088: CALL_OW 12
118092: ST_TO_ADDR
// case i of 1 :
118093: LD_VAR 0 1
118097: PUSH
118098: LD_INT 1
118100: DOUBLE
118101: EQUAL
118102: IFTRUE 118106
118104: GO 118116
118106: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118107: LD_STRING earthquake(getX(game), 0, 32)
118109: PPUSH
118110: CALL_OW 559
118114: GO 118341
118116: LD_INT 2
118118: DOUBLE
118119: EQUAL
118120: IFTRUE 118124
118122: GO 118138
118124: POP
// begin ToLua ( displayStucuk(); ) ;
118125: LD_STRING displayStucuk();
118127: PPUSH
118128: CALL_OW 559
// ResetFog ;
118132: CALL_OW 335
// end ; 3 :
118136: GO 118341
118138: LD_INT 3
118140: DOUBLE
118141: EQUAL
118142: IFTRUE 118146
118144: GO 118250
118146: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118147: LD_ADDR_VAR 0 2
118151: PUSH
118152: LD_INT 22
118154: PUSH
118155: LD_OWVAR 2
118159: PUSH
118160: EMPTY
118161: LIST
118162: LIST
118163: PUSH
118164: LD_INT 25
118166: PUSH
118167: LD_INT 1
118169: PUSH
118170: EMPTY
118171: LIST
118172: LIST
118173: PUSH
118174: EMPTY
118175: LIST
118176: LIST
118177: PPUSH
118178: CALL_OW 69
118182: ST_TO_ADDR
// if not tmp then
118183: LD_VAR 0 2
118187: NOT
118188: IFFALSE 118192
// exit ;
118190: GO 118341
// un := tmp [ rand ( 1 , tmp ) ] ;
118192: LD_ADDR_VAR 0 3
118196: PUSH
118197: LD_VAR 0 2
118201: PUSH
118202: LD_INT 1
118204: PPUSH
118205: LD_VAR 0 2
118209: PPUSH
118210: CALL_OW 12
118214: ARRAY
118215: ST_TO_ADDR
// if Crawls ( un ) then
118216: LD_VAR 0 3
118220: PPUSH
118221: CALL_OW 318
118225: IFFALSE 118236
// ComWalk ( un ) ;
118227: LD_VAR 0 3
118231: PPUSH
118232: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118236: LD_VAR 0 3
118240: PPUSH
118241: LD_INT 8
118243: PPUSH
118244: CALL_OW 336
// end ; 4 :
118248: GO 118341
118250: LD_INT 4
118252: DOUBLE
118253: EQUAL
118254: IFTRUE 118258
118256: GO 118319
118258: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118259: LD_ADDR_VAR 0 2
118263: PUSH
118264: LD_INT 22
118266: PUSH
118267: LD_OWVAR 2
118271: PUSH
118272: EMPTY
118273: LIST
118274: LIST
118275: PUSH
118276: LD_INT 30
118278: PUSH
118279: LD_INT 29
118281: PUSH
118282: EMPTY
118283: LIST
118284: LIST
118285: PUSH
118286: EMPTY
118287: LIST
118288: LIST
118289: PPUSH
118290: CALL_OW 69
118294: ST_TO_ADDR
// if not tmp then
118295: LD_VAR 0 2
118299: NOT
118300: IFFALSE 118304
// exit ;
118302: GO 118341
// DestroyUnit ( tmp [ 1 ] ) ;
118304: LD_VAR 0 2
118308: PUSH
118309: LD_INT 1
118311: ARRAY
118312: PPUSH
118313: CALL_OW 65
// end ; 5 .. 7 :
118317: GO 118341
118319: LD_INT 5
118321: DOUBLE
118322: GREATEREQUAL
118323: IFFALSE 118331
118325: LD_INT 7
118327: DOUBLE
118328: LESSEQUAL
118329: IFTRUE 118333
118331: GO 118340
118333: POP
// StreamSibBomb ; end ;
118334: CALL 114621 0 0
118338: GO 118341
118340: POP
// end ;
118341: PPOPN 3
118343: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118344: LD_EXP 145
118348: PUSH
118349: LD_EXP 195
118353: AND
118354: IFFALSE 118510
118356: GO 118358
118358: DISABLE
118359: LD_INT 0
118361: PPUSH
118362: PPUSH
118363: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118364: LD_ADDR_VAR 0 2
118368: PUSH
118369: LD_INT 81
118371: PUSH
118372: LD_OWVAR 2
118376: PUSH
118377: EMPTY
118378: LIST
118379: LIST
118380: PUSH
118381: LD_INT 2
118383: PUSH
118384: LD_INT 21
118386: PUSH
118387: LD_INT 1
118389: PUSH
118390: EMPTY
118391: LIST
118392: LIST
118393: PUSH
118394: LD_INT 21
118396: PUSH
118397: LD_INT 2
118399: PUSH
118400: EMPTY
118401: LIST
118402: LIST
118403: PUSH
118404: EMPTY
118405: LIST
118406: LIST
118407: LIST
118408: PUSH
118409: EMPTY
118410: LIST
118411: LIST
118412: PPUSH
118413: CALL_OW 69
118417: ST_TO_ADDR
// if not tmp then
118418: LD_VAR 0 2
118422: NOT
118423: IFFALSE 118427
// exit ;
118425: GO 118510
// p := 0 ;
118427: LD_ADDR_VAR 0 3
118431: PUSH
118432: LD_INT 0
118434: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118435: LD_INT 35
118437: PPUSH
118438: CALL_OW 67
// p := p + 1 ;
118442: LD_ADDR_VAR 0 3
118446: PUSH
118447: LD_VAR 0 3
118451: PUSH
118452: LD_INT 1
118454: PLUS
118455: ST_TO_ADDR
// for i in tmp do
118456: LD_ADDR_VAR 0 1
118460: PUSH
118461: LD_VAR 0 2
118465: PUSH
118466: FOR_IN
118467: IFFALSE 118498
// if GetLives ( i ) < 1000 then
118469: LD_VAR 0 1
118473: PPUSH
118474: CALL_OW 256
118478: PUSH
118479: LD_INT 1000
118481: LESS
118482: IFFALSE 118496
// SetLives ( i , 1000 ) ;
118484: LD_VAR 0 1
118488: PPUSH
118489: LD_INT 1000
118491: PPUSH
118492: CALL_OW 234
118496: GO 118466
118498: POP
118499: POP
// until p > 20 ;
118500: LD_VAR 0 3
118504: PUSH
118505: LD_INT 20
118507: GREATER
118508: IFFALSE 118435
// end ;
118510: PPOPN 3
118512: END
// every 0 0$1 trigger StreamModeActive and sTime do
118513: LD_EXP 145
118517: PUSH
118518: LD_EXP 196
118522: AND
118523: IFFALSE 118558
118525: GO 118527
118527: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118528: LD_INT 28
118530: PPUSH
118531: LD_OWVAR 2
118535: PPUSH
118536: LD_INT 2
118538: PPUSH
118539: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118543: LD_INT 30
118545: PPUSH
118546: LD_OWVAR 2
118550: PPUSH
118551: LD_INT 2
118553: PPUSH
118554: CALL_OW 322
// end ;
118558: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118559: LD_EXP 145
118563: PUSH
118564: LD_EXP 197
118568: AND
118569: IFFALSE 118690
118571: GO 118573
118573: DISABLE
118574: LD_INT 0
118576: PPUSH
118577: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118578: LD_ADDR_VAR 0 2
118582: PUSH
118583: LD_INT 22
118585: PUSH
118586: LD_OWVAR 2
118590: PUSH
118591: EMPTY
118592: LIST
118593: LIST
118594: PUSH
118595: LD_INT 21
118597: PUSH
118598: LD_INT 1
118600: PUSH
118601: EMPTY
118602: LIST
118603: LIST
118604: PUSH
118605: LD_INT 3
118607: PUSH
118608: LD_INT 23
118610: PUSH
118611: LD_INT 0
118613: PUSH
118614: EMPTY
118615: LIST
118616: LIST
118617: PUSH
118618: EMPTY
118619: LIST
118620: LIST
118621: PUSH
118622: EMPTY
118623: LIST
118624: LIST
118625: LIST
118626: PPUSH
118627: CALL_OW 69
118631: ST_TO_ADDR
// if not tmp then
118632: LD_VAR 0 2
118636: NOT
118637: IFFALSE 118641
// exit ;
118639: GO 118690
// for i in tmp do
118641: LD_ADDR_VAR 0 1
118645: PUSH
118646: LD_VAR 0 2
118650: PUSH
118651: FOR_IN
118652: IFFALSE 118688
// begin if Crawls ( i ) then
118654: LD_VAR 0 1
118658: PPUSH
118659: CALL_OW 318
118663: IFFALSE 118674
// ComWalk ( i ) ;
118665: LD_VAR 0 1
118669: PPUSH
118670: CALL_OW 138
// SetClass ( i , 2 ) ;
118674: LD_VAR 0 1
118678: PPUSH
118679: LD_INT 2
118681: PPUSH
118682: CALL_OW 336
// end ;
118686: GO 118651
118688: POP
118689: POP
// end ;
118690: PPOPN 2
118692: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118693: LD_EXP 145
118697: PUSH
118698: LD_EXP 198
118702: AND
118703: IFFALSE 118984
118705: GO 118707
118707: DISABLE
118708: LD_INT 0
118710: PPUSH
118711: PPUSH
118712: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118713: LD_OWVAR 2
118717: PPUSH
118718: LD_INT 9
118720: PPUSH
118721: LD_INT 1
118723: PPUSH
118724: LD_INT 1
118726: PPUSH
118727: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118731: LD_INT 9
118733: PPUSH
118734: LD_OWVAR 2
118738: PPUSH
118739: CALL_OW 343
// uc_side := 9 ;
118743: LD_ADDR_OWVAR 20
118747: PUSH
118748: LD_INT 9
118750: ST_TO_ADDR
// uc_nation := 2 ;
118751: LD_ADDR_OWVAR 21
118755: PUSH
118756: LD_INT 2
118758: ST_TO_ADDR
// hc_name := Dark Warrior ;
118759: LD_ADDR_OWVAR 26
118763: PUSH
118764: LD_STRING Dark Warrior
118766: ST_TO_ADDR
// hc_gallery :=  ;
118767: LD_ADDR_OWVAR 33
118771: PUSH
118772: LD_STRING 
118774: ST_TO_ADDR
// hc_noskilllimit := true ;
118775: LD_ADDR_OWVAR 76
118779: PUSH
118780: LD_INT 1
118782: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
118783: LD_ADDR_OWVAR 31
118787: PUSH
118788: LD_INT 30
118790: PUSH
118791: LD_INT 30
118793: PUSH
118794: LD_INT 30
118796: PUSH
118797: LD_INT 30
118799: PUSH
118800: EMPTY
118801: LIST
118802: LIST
118803: LIST
118804: LIST
118805: ST_TO_ADDR
// un := CreateHuman ;
118806: LD_ADDR_VAR 0 3
118810: PUSH
118811: CALL_OW 44
118815: ST_TO_ADDR
// hc_noskilllimit := false ;
118816: LD_ADDR_OWVAR 76
118820: PUSH
118821: LD_INT 0
118823: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118824: LD_VAR 0 3
118828: PPUSH
118829: LD_INT 1
118831: PPUSH
118832: CALL_OW 51
// p := 0 ;
118836: LD_ADDR_VAR 0 2
118840: PUSH
118841: LD_INT 0
118843: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118844: LD_INT 35
118846: PPUSH
118847: CALL_OW 67
// p := p + 1 ;
118851: LD_ADDR_VAR 0 2
118855: PUSH
118856: LD_VAR 0 2
118860: PUSH
118861: LD_INT 1
118863: PLUS
118864: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118865: LD_VAR 0 3
118869: PPUSH
118870: CALL_OW 256
118874: PUSH
118875: LD_INT 1000
118877: LESS
118878: IFFALSE 118892
// SetLives ( un , 1000 ) ;
118880: LD_VAR 0 3
118884: PPUSH
118885: LD_INT 1000
118887: PPUSH
118888: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
118892: LD_VAR 0 3
118896: PPUSH
118897: LD_INT 81
118899: PUSH
118900: LD_OWVAR 2
118904: PUSH
118905: EMPTY
118906: LIST
118907: LIST
118908: PUSH
118909: LD_INT 91
118911: PUSH
118912: LD_VAR 0 3
118916: PUSH
118917: LD_INT 30
118919: PUSH
118920: EMPTY
118921: LIST
118922: LIST
118923: LIST
118924: PUSH
118925: EMPTY
118926: LIST
118927: LIST
118928: PPUSH
118929: CALL_OW 69
118933: PPUSH
118934: LD_VAR 0 3
118938: PPUSH
118939: CALL_OW 74
118943: PPUSH
118944: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
118948: LD_VAR 0 2
118952: PUSH
118953: LD_INT 60
118955: GREATER
118956: PUSH
118957: LD_VAR 0 3
118961: PPUSH
118962: CALL_OW 301
118966: OR
118967: IFFALSE 118844
// if un then
118969: LD_VAR 0 3
118973: IFFALSE 118984
// RemoveUnit ( un ) ;
118975: LD_VAR 0 3
118979: PPUSH
118980: CALL_OW 64
// end ; end_of_file
118984: PPOPN 3
118986: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
118987: LD_INT 0
118989: PPUSH
118990: PPUSH
118991: PPUSH
118992: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118993: LD_VAR 0 1
118997: PPUSH
118998: CALL_OW 264
119002: PUSH
119003: LD_EXP 99
119007: EQUAL
119008: IFFALSE 119080
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
119010: LD_INT 68
119012: PPUSH
119013: LD_VAR 0 1
119017: PPUSH
119018: CALL_OW 255
119022: PPUSH
119023: CALL_OW 321
119027: PUSH
119028: LD_INT 2
119030: EQUAL
119031: IFFALSE 119043
// eff := 70 else
119033: LD_ADDR_VAR 0 4
119037: PUSH
119038: LD_INT 70
119040: ST_TO_ADDR
119041: GO 119051
// eff := 30 ;
119043: LD_ADDR_VAR 0 4
119047: PUSH
119048: LD_INT 30
119050: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
119051: LD_VAR 0 1
119055: PPUSH
119056: CALL_OW 250
119060: PPUSH
119061: LD_VAR 0 1
119065: PPUSH
119066: CALL_OW 251
119070: PPUSH
119071: LD_VAR 0 4
119075: PPUSH
119076: CALL_OW 495
// end ; end ;
119080: LD_VAR 0 2
119084: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
119085: LD_INT 0
119087: PPUSH
// end ;
119088: LD_VAR 0 4
119092: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
119093: LD_INT 0
119095: PPUSH
119096: PPUSH
119097: PPUSH
119098: PPUSH
119099: PPUSH
119100: PPUSH
// if cmd = 124 then
119101: LD_VAR 0 1
119105: PUSH
119106: LD_INT 124
119108: EQUAL
119109: IFFALSE 119315
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
119111: LD_ADDR_VAR 0 5
119115: PUSH
119116: LD_INT 2
119118: PUSH
119119: LD_INT 34
119121: PUSH
119122: LD_INT 53
119124: PUSH
119125: EMPTY
119126: LIST
119127: LIST
119128: PUSH
119129: LD_INT 34
119131: PUSH
119132: LD_INT 14
119134: PUSH
119135: EMPTY
119136: LIST
119137: LIST
119138: PUSH
119139: EMPTY
119140: LIST
119141: LIST
119142: LIST
119143: PPUSH
119144: CALL_OW 69
119148: ST_TO_ADDR
// if not tmp then
119149: LD_VAR 0 5
119153: NOT
119154: IFFALSE 119158
// exit ;
119156: GO 119315
// for i in tmp do
119158: LD_ADDR_VAR 0 3
119162: PUSH
119163: LD_VAR 0 5
119167: PUSH
119168: FOR_IN
119169: IFFALSE 119313
// begin taskList := GetTaskList ( i ) ;
119171: LD_ADDR_VAR 0 6
119175: PUSH
119176: LD_VAR 0 3
119180: PPUSH
119181: CALL_OW 437
119185: ST_TO_ADDR
// if not taskList then
119186: LD_VAR 0 6
119190: NOT
119191: IFFALSE 119195
// continue ;
119193: GO 119168
// for j = 1 to taskList do
119195: LD_ADDR_VAR 0 4
119199: PUSH
119200: DOUBLE
119201: LD_INT 1
119203: DEC
119204: ST_TO_ADDR
119205: LD_VAR 0 6
119209: PUSH
119210: FOR_TO
119211: IFFALSE 119309
// if taskList [ j ] [ 1 ] = | then
119213: LD_VAR 0 6
119217: PUSH
119218: LD_VAR 0 4
119222: ARRAY
119223: PUSH
119224: LD_INT 1
119226: ARRAY
119227: PUSH
119228: LD_STRING |
119230: EQUAL
119231: IFFALSE 119307
// begin _taskList := Delete ( taskList , 1 ) ;
119233: LD_ADDR_VAR 0 7
119237: PUSH
119238: LD_VAR 0 6
119242: PPUSH
119243: LD_INT 1
119245: PPUSH
119246: CALL_OW 3
119250: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
119251: LD_VAR 0 3
119255: PPUSH
119256: LD_VAR 0 7
119260: PPUSH
119261: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
119265: LD_VAR 0 3
119269: PPUSH
119270: LD_VAR 0 6
119274: PUSH
119275: LD_VAR 0 4
119279: ARRAY
119280: PUSH
119281: LD_INT 2
119283: ARRAY
119284: PPUSH
119285: LD_VAR 0 6
119289: PUSH
119290: LD_VAR 0 4
119294: ARRAY
119295: PUSH
119296: LD_INT 3
119298: ARRAY
119299: PPUSH
119300: LD_INT 8
119302: PPUSH
119303: CALL 119320 0 4
// end ;
119307: GO 119210
119309: POP
119310: POP
// end ;
119311: GO 119168
119313: POP
119314: POP
// end ; end ;
119315: LD_VAR 0 2
119319: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119320: LD_INT 0
119322: PPUSH
119323: PPUSH
119324: PPUSH
119325: PPUSH
119326: PPUSH
119327: PPUSH
119328: PPUSH
119329: PPUSH
119330: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119331: LD_VAR 0 1
119335: NOT
119336: PUSH
119337: LD_VAR 0 2
119341: PPUSH
119342: LD_VAR 0 3
119346: PPUSH
119347: CALL_OW 488
119351: NOT
119352: OR
119353: PUSH
119354: LD_VAR 0 4
119358: NOT
119359: OR
119360: IFFALSE 119364
// exit ;
119362: GO 119704
// list := [ ] ;
119364: LD_ADDR_VAR 0 13
119368: PUSH
119369: EMPTY
119370: ST_TO_ADDR
// if x - r < 0 then
119371: LD_VAR 0 2
119375: PUSH
119376: LD_VAR 0 4
119380: MINUS
119381: PUSH
119382: LD_INT 0
119384: LESS
119385: IFFALSE 119397
// min_x := 0 else
119387: LD_ADDR_VAR 0 7
119391: PUSH
119392: LD_INT 0
119394: ST_TO_ADDR
119395: GO 119413
// min_x := x - r ;
119397: LD_ADDR_VAR 0 7
119401: PUSH
119402: LD_VAR 0 2
119406: PUSH
119407: LD_VAR 0 4
119411: MINUS
119412: ST_TO_ADDR
// if y - r < 0 then
119413: LD_VAR 0 3
119417: PUSH
119418: LD_VAR 0 4
119422: MINUS
119423: PUSH
119424: LD_INT 0
119426: LESS
119427: IFFALSE 119439
// min_y := 0 else
119429: LD_ADDR_VAR 0 8
119433: PUSH
119434: LD_INT 0
119436: ST_TO_ADDR
119437: GO 119455
// min_y := y - r ;
119439: LD_ADDR_VAR 0 8
119443: PUSH
119444: LD_VAR 0 3
119448: PUSH
119449: LD_VAR 0 4
119453: MINUS
119454: ST_TO_ADDR
// max_x := x + r ;
119455: LD_ADDR_VAR 0 9
119459: PUSH
119460: LD_VAR 0 2
119464: PUSH
119465: LD_VAR 0 4
119469: PLUS
119470: ST_TO_ADDR
// max_y := y + r ;
119471: LD_ADDR_VAR 0 10
119475: PUSH
119476: LD_VAR 0 3
119480: PUSH
119481: LD_VAR 0 4
119485: PLUS
119486: ST_TO_ADDR
// for _x = min_x to max_x do
119487: LD_ADDR_VAR 0 11
119491: PUSH
119492: DOUBLE
119493: LD_VAR 0 7
119497: DEC
119498: ST_TO_ADDR
119499: LD_VAR 0 9
119503: PUSH
119504: FOR_TO
119505: IFFALSE 119622
// for _y = min_y to max_y do
119507: LD_ADDR_VAR 0 12
119511: PUSH
119512: DOUBLE
119513: LD_VAR 0 8
119517: DEC
119518: ST_TO_ADDR
119519: LD_VAR 0 10
119523: PUSH
119524: FOR_TO
119525: IFFALSE 119618
// begin if not ValidHex ( _x , _y ) then
119527: LD_VAR 0 11
119531: PPUSH
119532: LD_VAR 0 12
119536: PPUSH
119537: CALL_OW 488
119541: NOT
119542: IFFALSE 119546
// continue ;
119544: GO 119524
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119546: LD_VAR 0 11
119550: PPUSH
119551: LD_VAR 0 12
119555: PPUSH
119556: CALL_OW 351
119560: PUSH
119561: LD_VAR 0 11
119565: PPUSH
119566: LD_VAR 0 12
119570: PPUSH
119571: CALL_OW 554
119575: AND
119576: IFFALSE 119616
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119578: LD_ADDR_VAR 0 13
119582: PUSH
119583: LD_VAR 0 13
119587: PPUSH
119588: LD_VAR 0 13
119592: PUSH
119593: LD_INT 1
119595: PLUS
119596: PPUSH
119597: LD_VAR 0 11
119601: PUSH
119602: LD_VAR 0 12
119606: PUSH
119607: EMPTY
119608: LIST
119609: LIST
119610: PPUSH
119611: CALL_OW 2
119615: ST_TO_ADDR
// end ;
119616: GO 119524
119618: POP
119619: POP
119620: GO 119504
119622: POP
119623: POP
// if not list then
119624: LD_VAR 0 13
119628: NOT
119629: IFFALSE 119633
// exit ;
119631: GO 119704
// for i in list do
119633: LD_ADDR_VAR 0 6
119637: PUSH
119638: LD_VAR 0 13
119642: PUSH
119643: FOR_IN
119644: IFFALSE 119702
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119646: LD_VAR 0 1
119650: PPUSH
119651: LD_STRING M
119653: PUSH
119654: LD_VAR 0 6
119658: PUSH
119659: LD_INT 1
119661: ARRAY
119662: PUSH
119663: LD_VAR 0 6
119667: PUSH
119668: LD_INT 2
119670: ARRAY
119671: PUSH
119672: LD_INT 0
119674: PUSH
119675: LD_INT 0
119677: PUSH
119678: LD_INT 0
119680: PUSH
119681: LD_INT 0
119683: PUSH
119684: EMPTY
119685: LIST
119686: LIST
119687: LIST
119688: LIST
119689: LIST
119690: LIST
119691: LIST
119692: PUSH
119693: EMPTY
119694: LIST
119695: PPUSH
119696: CALL_OW 447
119700: GO 119643
119702: POP
119703: POP
// end ;
119704: LD_VAR 0 5
119708: RET
