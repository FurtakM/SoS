// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34222 0 0
// InitNature ;
  19: CALL 34046 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10934 0 0
// PrepareRussian ;
  40: CALL 6917 0 0
// PrepareLegion ;
  44: CALL 4157 0 0
// PreparePowell ;
  48: CALL 2911 0 0
// PrepareAmerican ;
  52: CALL 1683 0 0
// Action ;
  56: CALL 14841 0 0
// MC_Start ( ) ;
  60: CALL 36334 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// end ;
 455: LD_VAR 0 1
 459: RET
// export function CustomInitMacro ( ) ; begin
 460: LD_INT 0
 462: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 463: LD_ADDR_EXP 125
 467: PUSH
 468: LD_INT 2
 470: PUSH
 471: LD_INT 3
 473: PUSH
 474: LD_INT 6
 476: PUSH
 477: LD_INT 10
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 486: LD_ADDR_EXP 126
 490: PUSH
 491: LD_INT 1
 493: PUSH
 494: LD_INT 4
 496: PUSH
 497: LD_INT 5
 499: PUSH
 500: LD_INT 9
 502: PUSH
 503: EMPTY
 504: LIST
 505: LIST
 506: LIST
 507: LIST
 508: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 10
 514: PUSH
 515: LD_INT 11
 517: PUSH
 518: LD_INT 12
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: LIST
 525: PPUSH
 526: CALL 58715 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 530: LD_INT 1
 532: PPUSH
 533: LD_INT 17
 535: PUSH
 536: EMPTY
 537: LIST
 538: PPUSH
 539: CALL 58808 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 543: LD_INT 1
 545: PPUSH
 546: LD_INT 5
 548: PPUSH
 549: CALL 58158 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 553: LD_INT 1
 555: PPUSH
 556: LD_INT 24
 558: PUSH
 559: LD_INT 3
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 47
 567: PUSH
 568: EMPTY
 569: LIST
 570: LIST
 571: LIST
 572: LIST
 573: PUSH
 574: LD_INT 24
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 47
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 24
 594: PUSH
 595: LD_INT 3
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 47
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: LD_INT 24
 612: PUSH
 613: LD_INT 3
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 47
 621: PUSH
 622: EMPTY
 623: LIST
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_INT 24
 630: PUSH
 631: LD_INT 3
 633: PUSH
 634: LD_INT 1
 636: PUSH
 637: LD_INT 47
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: EMPTY
 647: LIST
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PPUSH
 653: CALL 57973 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 657: LD_INT 2
 659: PPUSH
 660: LD_INT 10
 662: PUSH
 663: LD_INT 11
 665: PUSH
 666: LD_INT 12
 668: PUSH
 669: LD_INT 14
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: PPUSH
 678: CALL 58715 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 682: LD_INT 2
 684: PPUSH
 685: LD_INT 16
 687: PUSH
 688: EMPTY
 689: LIST
 690: PPUSH
 691: CALL 58808 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 21
 700: PUSH
 701: LD_INT 3
 703: PUSH
 704: LD_INT 3
 706: PUSH
 707: LD_INT 51
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: LIST
 715: PUSH
 716: LD_INT 22
 718: PUSH
 719: LD_INT 3
 721: PUSH
 722: LD_INT 3
 724: PUSH
 725: LD_INT 52
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 22
 736: PUSH
 737: LD_INT 3
 739: PUSH
 740: LD_INT 3
 742: PUSH
 743: LD_INT 52
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 24
 754: PUSH
 755: LD_INT 3
 757: PUSH
 758: LD_INT 3
 760: PUSH
 761: LD_INT 47
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 24
 772: PUSH
 773: LD_INT 3
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 47
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 24
 790: PUSH
 791: LD_INT 3
 793: PUSH
 794: LD_INT 3
 796: PUSH
 797: LD_INT 47
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 24
 808: PUSH
 809: LD_INT 3
 811: PUSH
 812: LD_INT 3
 814: PUSH
 815: LD_INT 47
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 24
 826: PUSH
 827: LD_INT 3
 829: PUSH
 830: LD_INT 3
 832: PUSH
 833: LD_INT 47
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: EMPTY
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: LIST
 851: PPUSH
 852: CALL 57973 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 856: LD_INT 2
 858: PPUSH
 859: LD_INT 5
 861: PPUSH
 862: CALL 58158 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 866: LD_INT 2
 868: PPUSH
 869: LD_INT 0
 871: PPUSH
 872: CALL 58588 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 876: LD_INT 3
 878: PPUSH
 879: LD_INT 10
 881: PUSH
 882: LD_INT 12
 884: PUSH
 885: LD_INT 15
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: LIST
 892: PUSH
 893: LD_OWVAR 67
 897: ARRAY
 898: PPUSH
 899: LD_INT 27
 901: PPUSH
 902: CALL 57655 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 906: LD_INT 3
 908: PPUSH
 909: LD_INT 10
 911: PUSH
 912: LD_INT 11
 914: PUSH
 915: LD_INT 13
 917: PUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL 58715 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 931: LD_INT 3
 933: PPUSH
 934: LD_INT 15
 936: PUSH
 937: EMPTY
 938: LIST
 939: PPUSH
 940: CALL 58808 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 944: LD_ADDR_EXP 130
 948: PUSH
 949: LD_EXP 130
 953: PPUSH
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 22
 959: PUSH
 960: LD_INT 8
 962: PUSH
 963: EMPTY
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 25
 969: PUSH
 970: LD_INT 15
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: PUSH
 977: EMPTY
 978: LIST
 979: LIST
 980: PPUSH
 981: CALL_OW 69
 985: PPUSH
 986: CALL_OW 1
 990: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 991: LD_INT 3
 993: PPUSH
 994: LD_INT 13
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 1
1002: PUSH
1003: LD_INT 31
1005: PUSH
1006: EMPTY
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: PUSH
1012: LD_INT 13
1014: PUSH
1015: LD_INT 2
1017: PUSH
1018: LD_INT 1
1020: PUSH
1021: LD_INT 31
1023: PUSH
1024: EMPTY
1025: LIST
1026: LIST
1027: LIST
1028: LIST
1029: PUSH
1030: LD_INT 13
1032: PUSH
1033: LD_INT 3
1035: PUSH
1036: LD_INT 2
1038: PUSH
1039: LD_INT 32
1041: PUSH
1042: EMPTY
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: PPUSH
1053: CALL 57973 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1057: LD_INT 4
1059: PPUSH
1060: LD_INT 10
1062: PUSH
1063: LD_INT 12
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: PPUSH
1070: CALL 58715 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1074: LD_INT 4
1076: PPUSH
1077: LD_INT 9
1079: PUSH
1080: EMPTY
1081: LIST
1082: PPUSH
1083: CALL 58808 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1087: LD_INT 4
1089: PPUSH
1090: LD_INT 26
1092: PUSH
1093: LD_INT 74
1095: PUSH
1096: LD_INT 107
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 32
1110: PUSH
1111: LD_INT 77
1113: PUSH
1114: LD_INT 101
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 32
1128: PUSH
1129: LD_INT 69
1131: PUSH
1132: LD_INT 86
1134: PUSH
1135: LD_INT 4
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 27
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 110
1152: PUSH
1153: LD_INT 3
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 42
1167: PUSH
1168: LD_INT 79
1170: PUSH
1171: LD_INT 5
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 29
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 105
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 30
1200: PUSH
1201: LD_INT 40
1203: PUSH
1204: LD_INT 75
1206: PUSH
1207: LD_INT 1
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 80
1221: PUSH
1222: LD_INT 106
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 75
1239: PUSH
1240: LD_INT 114
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 82
1257: PUSH
1258: LD_INT 110
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 62
1275: PUSH
1276: LD_INT 78
1278: PUSH
1279: LD_INT 4
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 4
1290: PUSH
1291: LD_INT 39
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 3
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: PPUSH
1320: CALL 57865 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1324: LD_INT 4
1326: PPUSH
1327: LD_INT 5
1329: PUSH
1330: LD_INT 6
1332: PUSH
1333: LD_INT 7
1335: PUSH
1336: LD_INT 9
1338: PUSH
1339: EMPTY
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 59126 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 58297 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 58588 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 58588 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 58920 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 57973 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 58539 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$1 trigger debug do var i , tmp ;
1542: LD_EXP 1
1546: IFFALSE 1653
1548: GO 1550
1550: DISABLE
1551: LD_INT 0
1553: PPUSH
1554: PPUSH
// begin enable ;
1555: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1556: LD_ADDR_VAR 0 2
1560: PUSH
1561: LD_INT 22
1563: PUSH
1564: LD_INT 1
1566: PUSH
1567: EMPTY
1568: LIST
1569: LIST
1570: PUSH
1571: LD_INT 3
1573: PUSH
1574: LD_INT 21
1576: PUSH
1577: LD_INT 3
1579: PUSH
1580: EMPTY
1581: LIST
1582: LIST
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: PUSH
1588: LD_INT 3
1590: PUSH
1591: LD_INT 24
1593: PUSH
1594: LD_INT 999
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: EMPTY
1606: LIST
1607: LIST
1608: LIST
1609: PPUSH
1610: CALL_OW 69
1614: ST_TO_ADDR
// if not tmp then
1615: LD_VAR 0 2
1619: NOT
1620: IFFALSE 1624
// exit ;
1622: GO 1653
// for i in tmp do
1624: LD_ADDR_VAR 0 1
1628: PUSH
1629: LD_VAR 0 2
1633: PUSH
1634: FOR_IN
1635: IFFALSE 1651
// SetLives ( i , 1000 ) ;
1637: LD_VAR 0 1
1641: PPUSH
1642: LD_INT 1000
1644: PPUSH
1645: CALL_OW 234
1649: GO 1634
1651: POP
1652: POP
// end ;
1653: PPOPN 2
1655: END
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1656: LD_EXP 36
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 2
1668: GREATEREQUAL
1669: AND
1670: IFFALSE 1682
1672: GO 1674
1674: DISABLE
// SetAchievement ( ACH_POWELL ) ; end_of_file
1675: LD_STRING ACH_POWELL
1677: PPUSH
1678: CALL_OW 543
1682: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1683: LD_INT 0
1685: PPUSH
// uc_side := 1 ;
1686: LD_ADDR_OWVAR 20
1690: PUSH
1691: LD_INT 1
1693: ST_TO_ADDR
// uc_nation := 1 ;
1694: LD_ADDR_OWVAR 21
1698: PUSH
1699: LD_INT 1
1701: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1702: LD_ADDR_EXP 38
1706: PUSH
1707: LD_STRING JMM
1709: PPUSH
1710: LD_EXP 1
1714: NOT
1715: PPUSH
1716: LD_STRING 14_
1718: PPUSH
1719: CALL 64365 0 3
1723: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1724: LD_EXP 4
1728: NOT
1729: PUSH
1730: LD_EXP 4
1734: PUSH
1735: LD_INT 1
1737: ARRAY
1738: PUSH
1739: LD_INT 1
1741: ARRAY
1742: NOT
1743: OR
1744: IFFALSE 1767
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1746: LD_INT 3
1748: PPUSH
1749: LD_INT 3
1751: PPUSH
1752: LD_INT 1
1754: PPUSH
1755: LD_INT 5
1757: PPUSH
1758: LD_INT 100
1760: PPUSH
1761: CALL 71480 0 5
1765: GO 1826
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1767: LD_EXP 4
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PUSH
1776: LD_INT 1
1778: ARRAY
1779: PPUSH
1780: LD_EXP 4
1784: PUSH
1785: LD_INT 2
1787: ARRAY
1788: PUSH
1789: LD_INT 1
1791: ARRAY
1792: PPUSH
1793: LD_EXP 4
1797: PUSH
1798: LD_INT 3
1800: ARRAY
1801: PUSH
1802: LD_INT 1
1804: ARRAY
1805: PPUSH
1806: LD_EXP 4
1810: PUSH
1811: LD_INT 4
1813: ARRAY
1814: PUSH
1815: LD_INT 1
1817: ARRAY
1818: PPUSH
1819: LD_INT 30
1821: PPUSH
1822: CALL 71480 0 5
// JMMNewVeh := CreateVehicle ;
1826: LD_ADDR_EXP 55
1830: PUSH
1831: CALL_OW 45
1835: ST_TO_ADDR
// if not JMMNewVeh then
1836: LD_EXP 55
1840: NOT
1841: IFFALSE 1872
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1843: LD_INT 3
1845: PPUSH
1846: LD_INT 3
1848: PPUSH
1849: LD_INT 1
1851: PPUSH
1852: LD_INT 5
1854: PPUSH
1855: LD_INT 100
1857: PPUSH
1858: CALL 71480 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 55
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1872: LD_EXP 55
1876: PPUSH
1877: LD_INT 4
1879: PPUSH
1880: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1884: LD_EXP 55
1888: PPUSH
1889: LD_INT 79
1891: PPUSH
1892: LD_INT 91
1894: PPUSH
1895: LD_INT 0
1897: PPUSH
1898: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1902: LD_EXP 38
1906: PPUSH
1907: LD_EXP 55
1911: PPUSH
1912: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1916: LD_EXP 6
1920: PUSH
1921: LD_EXP 2
1925: NOT
1926: AND
1927: IFFALSE 2185
// begin if not JMMGirlVeh then
1929: LD_EXP 5
1933: NOT
1934: IFFALSE 1957
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1936: LD_INT 3
1938: PPUSH
1939: LD_INT 3
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_INT 9
1947: PPUSH
1948: LD_INT 100
1950: PPUSH
1951: CALL 71480 0 5
1955: GO 2016
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1957: LD_EXP 5
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PUSH
1966: LD_INT 1
1968: ARRAY
1969: PPUSH
1970: LD_EXP 5
1974: PUSH
1975: LD_INT 2
1977: ARRAY
1978: PUSH
1979: LD_INT 1
1981: ARRAY
1982: PPUSH
1983: LD_EXP 5
1987: PUSH
1988: LD_INT 3
1990: ARRAY
1991: PUSH
1992: LD_INT 1
1994: ARRAY
1995: PPUSH
1996: LD_EXP 5
2000: PUSH
2001: LD_INT 4
2003: ARRAY
2004: PUSH
2005: LD_INT 1
2007: ARRAY
2008: PPUSH
2009: LD_INT 30
2011: PPUSH
2012: CALL 71480 0 5
// GirlNewVeh := CreateVehicle ;
2016: LD_ADDR_EXP 56
2020: PUSH
2021: CALL_OW 45
2025: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2026: LD_EXP 56
2030: PPUSH
2031: LD_INT 4
2033: PPUSH
2034: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2038: LD_EXP 56
2042: PPUSH
2043: LD_INT 82
2045: PPUSH
2046: LD_INT 96
2048: PPUSH
2049: LD_INT 0
2051: PPUSH
2052: CALL_OW 48
// if JMMGirl = 1 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 1
2063: EQUAL
2064: IFFALSE 2099
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Joan
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64365 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 56
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 2 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 2
2106: EQUAL
2107: IFFALSE 2142
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2109: LD_ADDR_EXP 41
2113: PUSH
2114: LD_STRING Lisa
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64365 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2128: LD_EXP 41
2132: PPUSH
2133: LD_EXP 56
2137: PPUSH
2138: CALL_OW 52
// end ; if JMMGirl = 3 then
2142: LD_EXP 7
2146: PUSH
2147: LD_INT 3
2149: EQUAL
2150: IFFALSE 2185
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2152: LD_ADDR_EXP 53
2156: PUSH
2157: LD_STRING Connie
2159: PPUSH
2160: LD_INT 1
2162: PPUSH
2163: LD_STRING 14_
2165: PPUSH
2166: CALL 64365 0 3
2170: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2171: LD_EXP 53
2175: PPUSH
2176: LD_EXP 56
2180: PPUSH
2181: CALL_OW 52
// end ; end ; end ;
2185: LD_VAR 0 1
2189: RET
// export function PrepareStevensSquad ; var tmp ; begin
2190: LD_INT 0
2192: PPUSH
2193: PPUSH
// uc_side := 1 ;
2194: LD_ADDR_OWVAR 20
2198: PUSH
2199: LD_INT 1
2201: ST_TO_ADDR
// uc_nation := 1 ;
2202: LD_ADDR_OWVAR 21
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// tmp := [ ] ;
2210: LD_ADDR_VAR 0 2
2214: PUSH
2215: EMPTY
2216: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2217: LD_ADDR_EXP 40
2221: PUSH
2222: LD_STRING Stevens
2224: PPUSH
2225: LD_EXP 1
2229: NOT
2230: PPUSH
2231: LD_STRING 13f_
2233: PPUSH
2234: CALL 64365 0 3
2238: ST_TO_ADDR
// if not Stevens then
2239: LD_EXP 40
2243: NOT
2244: IFFALSE 2300
// begin hc_name = Baker Smith ;
2246: LD_ADDR_OWVAR 26
2250: PUSH
2251: LD_STRING Baker Smith
2253: ST_TO_ADDR
// hc_gallery =  ;
2254: LD_ADDR_OWVAR 33
2258: PUSH
2259: LD_STRING 
2261: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 10
2267: PPUSH
2268: CALL_OW 384
// Baker = CreateHuman ;
2272: LD_ADDR_EXP 54
2276: PUSH
2277: CALL_OW 44
2281: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2282: LD_ADDR_VAR 0 2
2286: PUSH
2287: LD_VAR 0 2
2291: PUSH
2292: LD_EXP 54
2296: ADD
2297: ST_TO_ADDR
// end else
2298: GO 2316
// tmp := tmp ^ Stevens ;
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 2
2309: PUSH
2310: LD_EXP 40
2314: ADD
2315: ST_TO_ADDR
// if not Lisa then
2316: LD_EXP 41
2320: NOT
2321: IFFALSE 2367
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2323: LD_ADDR_EXP 41
2327: PUSH
2328: LD_STRING Lisa
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_STRING 13f_
2339: PPUSH
2340: CALL 64365 0 3
2344: ST_TO_ADDR
// if Lisa then
2345: LD_EXP 41
2349: IFFALSE 2367
// tmp := tmp ^ Lisa ;
2351: LD_ADDR_VAR 0 2
2355: PUSH
2356: LD_VAR 0 2
2360: PUSH
2361: LD_EXP 41
2365: ADD
2366: ST_TO_ADDR
// end ; if not Donaldson then
2367: LD_EXP 42
2371: NOT
2372: IFFALSE 2418
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2374: LD_ADDR_EXP 42
2378: PUSH
2379: LD_STRING Donaldson
2381: PPUSH
2382: LD_EXP 1
2386: NOT
2387: PPUSH
2388: LD_STRING 13f_
2390: PPUSH
2391: CALL 64365 0 3
2395: ST_TO_ADDR
// if Donaldson then
2396: LD_EXP 42
2400: IFFALSE 2418
// tmp := tmp ^ Donaldson ;
2402: LD_ADDR_VAR 0 2
2406: PUSH
2407: LD_VAR 0 2
2411: PUSH
2412: LD_EXP 42
2416: ADD
2417: ST_TO_ADDR
// end ; if not Bobby then
2418: LD_EXP 43
2422: NOT
2423: IFFALSE 2469
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2425: LD_ADDR_EXP 43
2429: PUSH
2430: LD_STRING Bobby
2432: PPUSH
2433: LD_EXP 1
2437: NOT
2438: PPUSH
2439: LD_STRING 13f_
2441: PPUSH
2442: CALL 64365 0 3
2446: ST_TO_ADDR
// if Bobby then
2447: LD_EXP 43
2451: IFFALSE 2469
// tmp := tmp ^ Bobby ;
2453: LD_ADDR_VAR 0 2
2457: PUSH
2458: LD_VAR 0 2
2462: PUSH
2463: LD_EXP 43
2467: ADD
2468: ST_TO_ADDR
// end ; if not Cyrus then
2469: LD_EXP 44
2473: NOT
2474: IFFALSE 2520
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2476: LD_ADDR_EXP 44
2480: PUSH
2481: LD_STRING Cyrus
2483: PPUSH
2484: LD_EXP 1
2488: NOT
2489: PPUSH
2490: LD_STRING 13f_
2492: PPUSH
2493: CALL 64365 0 3
2497: ST_TO_ADDR
// if Cyrus then
2498: LD_EXP 44
2502: IFFALSE 2520
// tmp := tmp ^ Cyrus ;
2504: LD_ADDR_VAR 0 2
2508: PUSH
2509: LD_VAR 0 2
2513: PUSH
2514: LD_EXP 44
2518: ADD
2519: ST_TO_ADDR
// end ; if not Brown then
2520: LD_EXP 46
2524: NOT
2525: IFFALSE 2571
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2527: LD_ADDR_EXP 46
2531: PUSH
2532: LD_STRING Brown
2534: PPUSH
2535: LD_EXP 1
2539: NOT
2540: PPUSH
2541: LD_STRING 13f_
2543: PPUSH
2544: CALL 64365 0 3
2548: ST_TO_ADDR
// if Brown then
2549: LD_EXP 46
2553: IFFALSE 2571
// tmp := tmp ^ Brown ;
2555: LD_ADDR_VAR 0 2
2559: PUSH
2560: LD_VAR 0 2
2564: PUSH
2565: LD_EXP 46
2569: ADD
2570: ST_TO_ADDR
// end ; if not Gladstone then
2571: LD_EXP 47
2575: NOT
2576: IFFALSE 2622
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2578: LD_ADDR_EXP 47
2582: PUSH
2583: LD_STRING Gladstone
2585: PPUSH
2586: LD_EXP 1
2590: NOT
2591: PPUSH
2592: LD_STRING 13f_
2594: PPUSH
2595: CALL 64365 0 3
2599: ST_TO_ADDR
// if Gladstone then
2600: LD_EXP 47
2604: IFFALSE 2622
// tmp := tmp ^ Gladstone ;
2606: LD_ADDR_VAR 0 2
2610: PUSH
2611: LD_VAR 0 2
2615: PUSH
2616: LD_EXP 47
2620: ADD
2621: ST_TO_ADDR
// end ; if not Houten then
2622: LD_EXP 48
2626: NOT
2627: IFFALSE 2673
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2629: LD_ADDR_EXP 48
2633: PUSH
2634: LD_STRING Houten
2636: PPUSH
2637: LD_EXP 1
2641: NOT
2642: PPUSH
2643: LD_STRING 13f_
2645: PPUSH
2646: CALL 64365 0 3
2650: ST_TO_ADDR
// if Houten then
2651: LD_EXP 48
2655: IFFALSE 2673
// tmp := tmp ^ Houten ;
2657: LD_ADDR_VAR 0 2
2661: PUSH
2662: LD_VAR 0 2
2666: PUSH
2667: LD_EXP 48
2671: ADD
2672: ST_TO_ADDR
// end ; if not Cornel then
2673: LD_EXP 49
2677: NOT
2678: IFFALSE 2724
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2680: LD_ADDR_EXP 49
2684: PUSH
2685: LD_STRING Cornel
2687: PPUSH
2688: LD_EXP 1
2692: NOT
2693: PPUSH
2694: LD_STRING 13f_
2696: PPUSH
2697: CALL 64365 0 3
2701: ST_TO_ADDR
// if Cornel then
2702: LD_EXP 49
2706: IFFALSE 2724
// tmp := tmp ^ Cornel ;
2708: LD_ADDR_VAR 0 2
2712: PUSH
2713: LD_VAR 0 2
2717: PUSH
2718: LD_EXP 49
2722: ADD
2723: ST_TO_ADDR
// end ; if not Gary then
2724: LD_EXP 50
2728: NOT
2729: IFFALSE 2775
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2731: LD_ADDR_EXP 50
2735: PUSH
2736: LD_STRING Gary
2738: PPUSH
2739: LD_EXP 1
2743: NOT
2744: PPUSH
2745: LD_STRING 13f_
2747: PPUSH
2748: CALL 64365 0 3
2752: ST_TO_ADDR
// if Gary then
2753: LD_EXP 50
2757: IFFALSE 2775
// tmp := tmp ^ Gary ;
2759: LD_ADDR_VAR 0 2
2763: PUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_EXP 50
2773: ADD
2774: ST_TO_ADDR
// end ; if not Frank then
2775: LD_EXP 51
2779: NOT
2780: IFFALSE 2826
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2782: LD_ADDR_EXP 51
2786: PUSH
2787: LD_STRING Frank
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_STRING 13f_
2798: PPUSH
2799: CALL 64365 0 3
2803: ST_TO_ADDR
// if Frank then
2804: LD_EXP 51
2808: IFFALSE 2826
// tmp := tmp ^ Frank ;
2810: LD_ADDR_VAR 0 2
2814: PUSH
2815: LD_VAR 0 2
2819: PUSH
2820: LD_EXP 51
2824: ADD
2825: ST_TO_ADDR
// end ; if not Kikuchi then
2826: LD_EXP 52
2830: NOT
2831: IFFALSE 2877
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2833: LD_ADDR_EXP 52
2837: PUSH
2838: LD_STRING Kikuchi
2840: PPUSH
2841: LD_EXP 1
2845: NOT
2846: PPUSH
2847: LD_STRING 13f_
2849: PPUSH
2850: CALL 64365 0 3
2854: ST_TO_ADDR
// if Kikuchi then
2855: LD_EXP 52
2859: IFFALSE 2877
// tmp := tmp ^ Kikuchi ;
2861: LD_ADDR_VAR 0 2
2865: PUSH
2866: LD_VAR 0 2
2870: PUSH
2871: LD_EXP 52
2875: ADD
2876: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2877: LD_ADDR_VAR 0 2
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: LD_STRING 13_other_survivors
2889: PPUSH
2890: CALL_OW 31
2894: UNION
2895: ST_TO_ADDR
// result := tmp ;
2896: LD_ADDR_VAR 0 1
2900: PUSH
2901: LD_VAR 0 2
2905: ST_TO_ADDR
// end ; end_of_file
2906: LD_VAR 0 1
2910: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2911: LD_INT 0
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
2918: PPUSH
2919: PPUSH
2920: PPUSH
2921: PPUSH
2922: PPUSH
// uc_side := 4 ;
2923: LD_ADDR_OWVAR 20
2927: PUSH
2928: LD_INT 4
2930: ST_TO_ADDR
// uc_nation := 1 ;
2931: LD_ADDR_OWVAR 21
2935: PUSH
2936: LD_INT 1
2938: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2939: LD_INT 387
2941: PPUSH
2942: CALL_OW 274
2946: PPUSH
2947: LD_INT 1
2949: PPUSH
2950: LD_INT 2500
2952: PPUSH
2953: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2957: LD_INT 387
2959: PPUSH
2960: CALL_OW 274
2964: PPUSH
2965: LD_INT 2
2967: PPUSH
2968: LD_INT 400
2970: PPUSH
2971: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 3
2985: PPUSH
2986: LD_INT 10
2988: PPUSH
2989: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2993: LD_ADDR_EXP 57
2997: PUSH
2998: LD_STRING Powell
3000: PPUSH
3001: CALL_OW 25
3005: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3006: LD_EXP 57
3010: PPUSH
3011: LD_INT 57
3013: PPUSH
3014: LD_INT 94
3016: PPUSH
3017: LD_INT 0
3019: PPUSH
3020: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3024: LD_EXP 57
3028: PPUSH
3029: LD_INT 58
3031: PPUSH
3032: LD_INT 94
3034: PPUSH
3035: CALL_OW 118
// vip := [ ] ;
3039: LD_ADDR_EXP 58
3043: PUSH
3044: EMPTY
3045: ST_TO_ADDR
// tmp := [ ] ;
3046: LD_ADDR_VAR 0 6
3050: PUSH
3051: EMPTY
3052: ST_TO_ADDR
// if JMMGirl <> 2 then
3053: LD_EXP 7
3057: PUSH
3058: LD_INT 2
3060: NONEQUAL
3061: IFFALSE 3085
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 41
3067: PUSH
3068: LD_STRING Lisa
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 64365 0 3
3084: ST_TO_ADDR
// if Lisa then
3085: LD_EXP 41
3089: IFFALSE 3107
// tmp := tmp ^ Lisa ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 41
3105: ADD
3106: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 42
3111: PUSH
3112: LD_STRING Donaldson
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 64365 0 3
3128: ST_TO_ADDR
// if Donaldson then
3129: LD_EXP 42
3133: IFFALSE 3151
// tmp := tmp ^ Donaldson ;
3135: LD_ADDR_VAR 0 6
3139: PUSH
3140: LD_VAR 0 6
3144: PUSH
3145: LD_EXP 42
3149: ADD
3150: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3151: LD_ADDR_EXP 43
3155: PUSH
3156: LD_STRING Bobby
3158: PPUSH
3159: LD_EXP 1
3163: NOT
3164: PPUSH
3165: LD_STRING 13s_
3167: PPUSH
3168: CALL 64365 0 3
3172: ST_TO_ADDR
// if Bobby then
3173: LD_EXP 43
3177: IFFALSE 3195
// tmp := tmp ^ Bobby ;
3179: LD_ADDR_VAR 0 6
3183: PUSH
3184: LD_VAR 0 6
3188: PUSH
3189: LD_EXP 43
3193: ADD
3194: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3195: LD_ADDR_EXP 44
3199: PUSH
3200: LD_STRING Cyrus
3202: PPUSH
3203: LD_EXP 1
3207: NOT
3208: PPUSH
3209: LD_STRING 13s_
3211: PPUSH
3212: CALL 64365 0 3
3216: ST_TO_ADDR
// if Cyrus then
3217: LD_EXP 44
3221: IFFALSE 3239
// tmp := tmp ^ Cyrus ;
3223: LD_ADDR_VAR 0 6
3227: PUSH
3228: LD_VAR 0 6
3232: PUSH
3233: LD_EXP 44
3237: ADD
3238: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 45
3243: PUSH
3244: LD_STRING Denis
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 64365 0 3
3260: ST_TO_ADDR
// if not Denis then
3261: LD_EXP 45
3265: NOT
3266: IFFALSE 3290
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3268: LD_ADDR_EXP 45
3272: PUSH
3273: LD_STRING Denis
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13f_
3284: PPUSH
3285: CALL 64365 0 3
3289: ST_TO_ADDR
// if Denis then
3290: LD_EXP 45
3294: IFFALSE 3312
// tmp := tmp ^ Denis ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 45
3310: ADD
3311: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 46
3316: PUSH
3317: LD_STRING Brown
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 64365 0 3
3333: ST_TO_ADDR
// if Brown then
3334: LD_EXP 46
3338: IFFALSE 3356
// tmp := tmp ^ Brown ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 46
3354: ADD
3355: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 47
3360: PUSH
3361: LD_STRING Gladstone
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 64365 0 3
3377: ST_TO_ADDR
// if Gladstone then
3378: LD_EXP 47
3382: IFFALSE 3400
// tmp := tmp ^ Gladstone ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 47
3398: ADD
3399: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 48
3404: PUSH
3405: LD_STRING Houten
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 64365 0 3
3421: ST_TO_ADDR
// if Houten then
3422: LD_EXP 48
3426: IFFALSE 3444
// tmp := tmp ^ Houten ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 48
3442: ADD
3443: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 49
3448: PUSH
3449: LD_STRING Cornel
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 64365 0 3
3465: ST_TO_ADDR
// if Cornel then
3466: LD_EXP 49
3470: IFFALSE 3488
// tmp := tmp ^ Cornel ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 49
3486: ADD
3487: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3488: LD_ADDR_EXP 50
3492: PUSH
3493: LD_STRING Gary
3495: PPUSH
3496: LD_EXP 1
3500: NOT
3501: PPUSH
3502: LD_STRING 13s_
3504: PPUSH
3505: CALL 64365 0 3
3509: ST_TO_ADDR
// if Gary then
3510: LD_EXP 50
3514: IFFALSE 3532
// tmp := tmp ^ Gary ;
3516: LD_ADDR_VAR 0 6
3520: PUSH
3521: LD_VAR 0 6
3525: PUSH
3526: LD_EXP 50
3530: ADD
3531: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3532: LD_ADDR_EXP 51
3536: PUSH
3537: LD_STRING Frank
3539: PPUSH
3540: LD_EXP 1
3544: NOT
3545: PPUSH
3546: LD_STRING 13s_
3548: PPUSH
3549: CALL 64365 0 3
3553: ST_TO_ADDR
// if Frank then
3554: LD_EXP 51
3558: IFFALSE 3576
// tmp := tmp ^ Frank ;
3560: LD_ADDR_VAR 0 6
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: LD_EXP 51
3574: ADD
3575: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3576: LD_ADDR_EXP 52
3580: PUSH
3581: LD_STRING Kikuchi
3583: PPUSH
3584: LD_EXP 1
3588: NOT
3589: PPUSH
3590: LD_STRING 13s_
3592: PPUSH
3593: CALL 64365 0 3
3597: ST_TO_ADDR
// if Kikuchi then
3598: LD_EXP 52
3602: IFFALSE 3620
// tmp := tmp ^ Kikuchi ;
3604: LD_ADDR_VAR 0 6
3608: PUSH
3609: LD_VAR 0 6
3613: PUSH
3614: LD_EXP 52
3618: ADD
3619: ST_TO_ADDR
// vip := tmp ;
3620: LD_ADDR_EXP 58
3624: PUSH
3625: LD_VAR 0 6
3629: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3630: LD_ADDR_VAR 0 6
3634: PUSH
3635: LD_VAR 0 6
3639: PUSH
3640: LD_STRING 13s_others
3642: PPUSH
3643: CALL_OW 31
3647: UNION
3648: ST_TO_ADDR
// if tmp < 20 then
3649: LD_VAR 0 6
3653: PUSH
3654: LD_INT 20
3656: LESS
3657: IFFALSE 3724
// for i = 1 to 20 - tmp do
3659: LD_ADDR_VAR 0 2
3663: PUSH
3664: DOUBLE
3665: LD_INT 1
3667: DEC
3668: ST_TO_ADDR
3669: LD_INT 20
3671: PUSH
3672: LD_VAR 0 6
3676: MINUS
3677: PUSH
3678: FOR_TO
3679: IFFALSE 3722
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3681: LD_INT 1
3683: PPUSH
3684: LD_VAR 0 2
3688: PUSH
3689: LD_INT 4
3691: MOD
3692: PUSH
3693: LD_INT 1
3695: PLUS
3696: PPUSH
3697: LD_INT 5
3699: PPUSH
3700: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3704: LD_ADDR_VAR 0 6
3708: PUSH
3709: LD_VAR 0 6
3713: PUSH
3714: CALL_OW 44
3718: ADD
3719: ST_TO_ADDR
// end ;
3720: GO 3678
3722: POP
3723: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3724: LD_ADDR_VAR 0 7
3728: PUSH
3729: LD_INT 22
3731: PUSH
3732: LD_INT 4
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PUSH
3739: LD_INT 30
3741: PUSH
3742: LD_INT 0
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: PUSH
3749: EMPTY
3750: LIST
3751: LIST
3752: PPUSH
3753: CALL_OW 69
3757: PUSH
3758: LD_INT 1
3760: ARRAY
3761: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3762: LD_ADDR_VAR 0 8
3766: PUSH
3767: LD_INT 22
3769: PUSH
3770: LD_INT 4
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 30
3779: PUSH
3780: LD_INT 6
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PPUSH
3791: CALL_OW 69
3795: PUSH
3796: LD_INT 1
3798: ARRAY
3799: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3800: LD_ADDR_VAR 0 9
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 4
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PUSH
3815: LD_INT 30
3817: PUSH
3818: LD_INT 4
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PPUSH
3829: CALL_OW 69
3833: PUSH
3834: LD_INT 1
3836: ARRAY
3837: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3838: LD_ADDR_VAR 0 10
3842: PUSH
3843: LD_INT 22
3845: PUSH
3846: LD_INT 4
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PUSH
3853: LD_INT 30
3855: PUSH
3856: LD_INT 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: CALL_OW 69
3871: PUSH
3872: LD_INT 1
3874: ARRAY
3875: ST_TO_ADDR
// for i in tmp do
3876: LD_ADDR_VAR 0 2
3880: PUSH
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_IN
3887: IFFALSE 4013
// begin cl := GetClass ( i ) ;
3889: LD_ADDR_VAR 0 5
3893: PUSH
3894: LD_VAR 0 2
3898: PPUSH
3899: CALL_OW 257
3903: ST_TO_ADDR
// if cl > 4 then
3904: LD_VAR 0 5
3908: PUSH
3909: LD_INT 4
3911: GREATER
3912: IFFALSE 3922
// cl := 1 ;
3914: LD_ADDR_VAR 0 5
3918: PUSH
3919: LD_INT 1
3921: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3922: LD_ADDR_VAR 0 3
3926: PUSH
3927: LD_VAR 0 9
3931: PUSH
3932: LD_VAR 0 7
3936: PUSH
3937: LD_VAR 0 10
3941: PUSH
3942: LD_VAR 0 8
3946: PUSH
3947: EMPTY
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: PUSH
3953: LD_VAR 0 5
3957: ARRAY
3958: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3959: LD_VAR 0 3
3963: PPUSH
3964: CALL_OW 313
3968: PUSH
3969: LD_INT 5
3971: LESS
3972: IFFALSE 3990
// PlaceHumanInUnit ( i , b ) else
3974: LD_VAR 0 2
3978: PPUSH
3979: LD_VAR 0 3
3983: PPUSH
3984: CALL_OW 52
3988: GO 4011
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3990: LD_VAR 0 2
3994: PPUSH
3995: LD_INT 58
3997: PPUSH
3998: LD_INT 91
4000: PPUSH
4001: LD_INT 6
4003: PPUSH
4004: LD_INT 0
4006: PPUSH
4007: CALL_OW 50
// end ;
4011: GO 3886
4013: POP
4014: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4015: LD_INT 2
4017: PPUSH
4018: LD_INT 1
4020: PPUSH
4021: LD_INT 1
4023: PPUSH
4024: LD_INT 12
4026: PPUSH
4027: LD_INT 100
4029: PPUSH
4030: CALL 71480 0 5
// veh := CreateVehicle ;
4034: LD_ADDR_VAR 0 4
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4044: LD_VAR 0 4
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4056: LD_VAR 0 4
4060: PPUSH
4061: LD_INT 49
4063: PPUSH
4064: LD_INT 88
4066: PPUSH
4067: LD_INT 0
4069: PPUSH
4070: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4074: LD_VAR 0 4
4078: PPUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 100
4084: PPUSH
4085: CALL_OW 290
// uc_side := 0 ;
4089: LD_ADDR_OWVAR 20
4093: PUSH
4094: LD_INT 0
4096: ST_TO_ADDR
// uc_nation := 0 ;
4097: LD_ADDR_OWVAR 21
4101: PUSH
4102: LD_INT 0
4104: ST_TO_ADDR
// for i = 1 to 4 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 4
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4150
// begin InitHc ;
4121: CALL_OW 19
// hc_class := class_apeman ;
4125: LD_ADDR_OWVAR 28
4129: PUSH
4130: LD_INT 12
4132: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4133: CALL_OW 44
4137: PPUSH
4138: LD_INT 13
4140: PPUSH
4141: LD_INT 0
4143: PPUSH
4144: CALL_OW 49
// end ;
4148: GO 4118
4150: POP
4151: POP
// end ; end_of_file
4152: LD_VAR 0 1
4156: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4157: LD_INT 0
4159: PPUSH
4160: PPUSH
4161: PPUSH
4162: PPUSH
4163: PPUSH
// side := 8 ;
4164: LD_ADDR_VAR 0 3
4168: PUSH
4169: LD_INT 8
4171: ST_TO_ADDR
// uc_side := side ;
4172: LD_ADDR_OWVAR 20
4176: PUSH
4177: LD_VAR 0 3
4181: ST_TO_ADDR
// uc_nation := 2 ;
4182: LD_ADDR_OWVAR 21
4186: PUSH
4187: LD_INT 2
4189: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_INT 22
4197: PUSH
4198: LD_VAR 0 3
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 3
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: PUSH
4226: FOR_IN
4227: IFFALSE 4243
// SetBLevel ( i , 10 ) ;
4229: LD_VAR 0 2
4233: PPUSH
4234: LD_INT 10
4236: PPUSH
4237: CALL_OW 241
4241: GO 4226
4243: POP
4244: POP
// if KurtStatus then
4245: LD_EXP 3
4249: IFFALSE 4272
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4251: LD_ADDR_EXP 59
4255: PUSH
4256: LD_STRING Kurt
4258: PPUSH
4259: LD_INT 0
4261: PPUSH
4262: LD_STRING 
4264: PPUSH
4265: CALL 64365 0 3
4269: ST_TO_ADDR
4270: GO 4294
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4272: LD_ADDR_EXP 59
4276: PUSH
4277: LD_STRING AltKurt
4279: PPUSH
4280: LD_EXP 1
4284: NOT
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64365 0 3
4293: ST_TO_ADDR
// if not Kurt then
4294: LD_EXP 59
4298: NOT
4299: IFFALSE 4325
// begin InitHc ;
4301: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4305: LD_INT 1
4307: PPUSH
4308: LD_INT 10
4310: PPUSH
4311: CALL_OW 381
// Kurt := CreateHuman ;
4315: LD_ADDR_EXP 59
4319: PUSH
4320: CALL_OW 44
4324: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4325: LD_EXP 59
4329: PPUSH
4330: LD_INT 324
4332: PPUSH
4333: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4337: LD_ADDR_EXP 60
4341: PUSH
4342: LD_STRING Kozlov
4344: PPUSH
4345: LD_INT 0
4347: PPUSH
4348: LD_STRING 
4350: PPUSH
4351: CALL 64365 0 3
4355: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4356: LD_EXP 60
4360: PPUSH
4361: LD_INT 22
4363: PUSH
4364: LD_INT 8
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: PUSH
4371: LD_INT 23
4373: PUSH
4374: LD_INT 3
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PUSH
4381: LD_INT 30
4383: PUSH
4384: LD_INT 8
4386: PUSH
4387: EMPTY
4388: LIST
4389: LIST
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: PUSH
4401: LD_INT 1
4403: ARRAY
4404: PPUSH
4405: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4409: LD_EXP 60
4413: PPUSH
4414: LD_INT 3
4416: PPUSH
4417: LD_INT 10
4419: PPUSH
4420: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4424: LD_ADDR_VAR 0 5
4428: PUSH
4429: LD_INT 22
4431: PUSH
4432: LD_VAR 0 3
4436: PUSH
4437: EMPTY
4438: LIST
4439: LIST
4440: PUSH
4441: LD_INT 30
4443: PUSH
4444: LD_INT 32
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 58
4453: PUSH
4454: EMPTY
4455: LIST
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ST_TO_ADDR
// for i = 1 to 10 do
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: DOUBLE
4473: LD_INT 1
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 10
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4553
// begin uc_nation := nation_nature ;
4483: LD_ADDR_OWVAR 21
4487: PUSH
4488: LD_INT 0
4490: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4491: LD_ADDR_OWVAR 28
4495: PUSH
4496: LD_INT 15
4498: ST_TO_ADDR
// hc_gallery :=  ;
4499: LD_ADDR_OWVAR 33
4503: PUSH
4504: LD_STRING 
4506: ST_TO_ADDR
// hc_name :=  ;
4507: LD_ADDR_OWVAR 26
4511: PUSH
4512: LD_STRING 
4514: ST_TO_ADDR
// un := CreateHuman ;
4515: LD_ADDR_VAR 0 4
4519: PUSH
4520: CALL_OW 44
4524: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4525: LD_VAR 0 4
4529: PPUSH
4530: LD_VAR 0 5
4534: PUSH
4535: LD_VAR 0 5
4539: PUSH
4540: LD_VAR 0 2
4544: MINUS
4545: ARRAY
4546: PPUSH
4547: CALL_OW 52
// end ;
4551: GO 4480
4553: POP
4554: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4555: LD_ADDR_VAR 0 5
4559: PUSH
4560: LD_STRING 12_kurt_squad
4562: PPUSH
4563: CALL_OW 31
4567: ST_TO_ADDR
// if tmp then
4568: LD_VAR 0 5
4572: IFFALSE 4606
// for i in tmp do
4574: LD_ADDR_VAR 0 2
4578: PUSH
4579: LD_VAR 0 5
4583: PUSH
4584: FOR_IN
4585: IFFALSE 4604
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4587: LD_VAR 0 2
4591: PPUSH
4592: LD_INT 5
4594: PPUSH
4595: LD_INT 0
4597: PPUSH
4598: CALL_OW 49
4602: GO 4584
4604: POP
4605: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4606: LD_INT 324
4608: PPUSH
4609: LD_INT 5
4611: PPUSH
4612: LD_STRING 
4614: PPUSH
4615: LD_INT 8
4617: PUSH
4618: LD_INT 9
4620: PUSH
4621: LD_INT 10
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: LD_OWVAR 67
4633: ARRAY
4634: PPUSH
4635: LD_INT 3000
4637: PUSH
4638: LD_INT 500
4640: PUSH
4641: LD_INT 150
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: PPUSH
4649: LD_INT 16
4651: PUSH
4652: LD_INT 6
4654: PUSH
4655: LD_INT 6
4657: PUSH
4658: LD_INT 8
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: PPUSH
4667: CALL 74889 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4671: LD_ADDR_EXP 101
4675: PUSH
4676: LD_EXP 101
4680: PPUSH
4681: LD_INT 3
4683: PPUSH
4684: LD_INT 22
4686: PUSH
4687: LD_VAR 0 3
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PUSH
4696: LD_INT 23
4698: PUSH
4699: LD_INT 2
4701: PUSH
4702: EMPTY
4703: LIST
4704: LIST
4705: PUSH
4706: LD_INT 3
4708: PUSH
4709: LD_INT 21
4711: PUSH
4712: LD_INT 2
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: LIST
4727: PPUSH
4728: CALL_OW 69
4732: PUSH
4733: LD_EXP 59
4737: DIFF
4738: PPUSH
4739: CALL_OW 1
4743: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 7
4749: PPUSH
4750: CALL_OW 383
// Friend := CreateHuman ;
4754: LD_ADDR_EXP 61
4758: PUSH
4759: CALL_OW 44
4763: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4764: LD_INT 14
4766: PPUSH
4767: LD_INT 3
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 29
4775: PPUSH
4776: LD_INT 100
4778: PPUSH
4779: CALL 71480 0 5
// powellBomb := CreateVehicle ;
4783: LD_ADDR_EXP 62
4787: PUSH
4788: CALL_OW 45
4792: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4793: LD_EXP 62
4797: PPUSH
4798: LD_INT 90
4800: PPUSH
4801: LD_INT 51
4803: PPUSH
4804: LD_INT 0
4806: PPUSH
4807: CALL_OW 48
// end ;
4811: LD_VAR 0 1
4815: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4816: LD_INT 0
4818: PPUSH
4819: PPUSH
4820: PPUSH
// if IsLive ( kozlov_fac ) then
4821: LD_INT 332
4823: PPUSH
4824: CALL_OW 300
4828: IFFALSE 4832
// exit ;
4830: GO 5399
// ComExitBuilding ( Kozlov ) ;
4832: LD_EXP 60
4836: PPUSH
4837: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4841: LD_EXP 60
4845: PPUSH
4846: CALL_OW 257
4850: PUSH
4851: LD_INT 2
4853: NONEQUAL
4854: IFFALSE 4889
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4856: LD_EXP 60
4860: PPUSH
4861: LD_INT 324
4863: PPUSH
4864: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4868: LD_EXP 60
4872: PPUSH
4873: LD_INT 2
4875: PPUSH
4876: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4880: LD_EXP 60
4884: PPUSH
4885: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4889: LD_EXP 60
4893: PPUSH
4894: LD_INT 2
4896: PPUSH
4897: LD_INT 93
4899: PPUSH
4900: LD_INT 32
4902: PPUSH
4903: LD_INT 3
4905: PPUSH
4906: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4910: LD_INT 35
4912: PPUSH
4913: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4917: LD_INT 22
4919: PUSH
4920: LD_INT 8
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PUSH
4927: LD_INT 30
4929: PUSH
4930: LD_INT 3
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 23
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 57
4949: PUSH
4950: EMPTY
4951: LIST
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: LIST
4957: LIST
4958: PPUSH
4959: CALL_OW 69
4963: IFFALSE 4910
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4965: LD_ADDR_VAR 0 2
4969: PUSH
4970: LD_INT 22
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 30
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 23
4992: PUSH
4993: LD_INT 3
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 57
5002: PUSH
5003: EMPTY
5004: LIST
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: PPUSH
5012: CALL_OW 69
5016: PUSH
5017: LD_INT 1
5019: ARRAY
5020: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5021: LD_INT 22
5023: PUSH
5024: LD_INT 8
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 23
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 30
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: LIST
5055: PPUSH
5056: CALL_OW 69
5060: NOT
5061: IFFALSE 5139
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5063: LD_EXP 60
5067: PPUSH
5068: LD_INT 21
5070: PPUSH
5071: LD_INT 97
5073: PPUSH
5074: LD_INT 36
5076: PPUSH
5077: LD_INT 5
5079: PPUSH
5080: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5091: LD_INT 22
5093: PUSH
5094: LD_INT 8
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 23
5103: PUSH
5104: LD_INT 3
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 30
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: LD_INT 57
5123: PUSH
5124: EMPTY
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: LIST
5132: PPUSH
5133: CALL_OW 69
5137: IFFALSE 5084
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5139: LD_INT 22
5141: PUSH
5142: LD_INT 8
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PUSH
5149: LD_INT 23
5151: PUSH
5152: LD_INT 3
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 30
5161: PUSH
5162: LD_INT 18
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: PPUSH
5174: CALL_OW 69
5178: NOT
5179: IFFALSE 5257
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5181: LD_EXP 60
5185: PPUSH
5186: LD_INT 18
5188: PPUSH
5189: LD_INT 89
5191: PPUSH
5192: LD_INT 32
5194: PPUSH
5195: LD_INT 1
5197: PPUSH
5198: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5202: LD_INT 35
5204: PPUSH
5205: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5209: LD_INT 22
5211: PUSH
5212: LD_INT 8
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 23
5221: PUSH
5222: LD_INT 3
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 30
5231: PUSH
5232: LD_INT 18
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: LD_INT 57
5241: PUSH
5242: EMPTY
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PPUSH
5251: CALL_OW 69
5255: IFFALSE 5202
// end ; lab := kozlov_lab ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: LD_INT 336
5264: ST_TO_ADDR
// if not lab then
5265: LD_VAR 0 3
5269: NOT
5270: IFFALSE 5274
// exit ;
5272: GO 5399
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5274: LD_EXP 60
5278: PPUSH
5279: LD_VAR 0 3
5283: PUSH
5284: LD_INT 1
5286: ARRAY
5287: PPUSH
5288: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5292: LD_EXP 60
5296: PPUSH
5297: LD_INT 4
5299: PPUSH
5300: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5304: LD_VAR 0 3
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_INT 25
5315: PPUSH
5316: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5320: LD_INT 35
5322: PPUSH
5323: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5327: LD_INT 25
5329: PPUSH
5330: LD_INT 8
5332: PPUSH
5333: CALL_OW 321
5337: PUSH
5338: LD_INT 2
5340: EQUAL
5341: IFFALSE 5320
// ComExitBuilding ( Kozlov ) ;
5343: LD_EXP 60
5347: PPUSH
5348: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5352: LD_EXP 60
5356: PPUSH
5357: LD_VAR 0 2
5361: PPUSH
5362: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5366: LD_EXP 60
5370: PPUSH
5371: LD_INT 3
5373: PPUSH
5374: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5378: LD_VAR 0 2
5382: PPUSH
5383: LD_INT 23
5385: PPUSH
5386: LD_INT 3
5388: PPUSH
5389: LD_INT 1
5391: PPUSH
5392: LD_INT 48
5394: PPUSH
5395: CALL_OW 125
// end ;
5399: LD_VAR 0 1
5403: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5404: LD_EXP 22
5408: NOT
5409: PUSH
5410: LD_EXP 15
5414: PUSH
5415: LD_INT 6
5417: GREATEREQUAL
5418: AND
5419: IFFALSE 5500
5421: GO 5423
5423: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5424: LD_INT 3
5426: PPUSH
5427: LD_INT 3
5429: PPUSH
5430: CALL 58158 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5434: LD_INT 3
5436: PPUSH
5437: LD_INT 14
5439: PUSH
5440: LD_INT 1
5442: PUSH
5443: LD_INT 1
5445: PUSH
5446: LD_INT 28
5448: PUSH
5449: EMPTY
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 14
5457: PUSH
5458: LD_INT 1
5460: PUSH
5461: LD_INT 1
5463: PUSH
5464: LD_INT 28
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: LIST
5471: LIST
5472: PUSH
5473: LD_INT 14
5475: PUSH
5476: LD_INT 1
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: LD_INT 28
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PPUSH
5496: CALL 58021 0 2
// end ;
5500: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5501: LD_EXP 22
5505: NOT
5506: PUSH
5507: LD_EXP 15
5511: PUSH
5512: LD_INT 6
5514: GREATEREQUAL
5515: AND
5516: PUSH
5517: LD_INT 3
5519: PPUSH
5520: LD_INT 1
5522: PPUSH
5523: CALL 59439 0 2
5527: NOT
5528: AND
5529: IFFALSE 6369
5531: GO 5533
5533: DISABLE
5534: LD_INT 0
5536: PPUSH
5537: PPUSH
5538: PPUSH
// begin enable ;
5539: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 23
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 30
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: PPUSH
5575: CALL_OW 69
5579: NOT
5580: IFFALSE 5584
// exit ;
5582: GO 6369
// if Prob ( 40 ) then
5584: LD_INT 40
5586: PPUSH
5587: CALL_OW 13
5591: IFFALSE 5718
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 14
5598: PUSH
5599: LD_INT 1
5601: PUSH
5602: LD_INT 2
5604: PUSH
5605: LD_INT 28
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_INT 14
5616: PUSH
5617: LD_INT 1
5619: PUSH
5620: LD_INT 2
5622: PUSH
5623: LD_INT 28
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 14
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: LD_INT 2
5640: PUSH
5641: LD_INT 28
5643: PUSH
5644: EMPTY
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: PUSH
5650: LD_INT 14
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 28
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 14
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 28
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 14
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 26
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL 58021 0 2
// end else
5716: GO 5909
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5718: LD_INT 3
5720: PPUSH
5721: LD_INT 14
5723: PUSH
5724: LD_INT 1
5726: PUSH
5727: LD_INT 2
5729: PUSH
5730: LD_INT 27
5732: PUSH
5733: LD_INT 26
5735: PUSH
5736: LD_INT 26
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: LIST
5754: LIST
5755: PUSH
5756: LD_INT 14
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 2
5764: PUSH
5765: LD_INT 27
5767: PUSH
5768: LD_INT 26
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: PUSH
5779: LD_OWVAR 67
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 14
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 2
5799: PUSH
5800: LD_INT 26
5802: PUSH
5803: LD_INT 26
5805: PUSH
5806: LD_INT 29
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: PUSH
5814: LD_OWVAR 67
5818: ARRAY
5819: PUSH
5820: EMPTY
5821: LIST
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 13
5828: PUSH
5829: LD_INT 1
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 26
5837: PUSH
5838: LD_INT 29
5840: PUSH
5841: LD_INT 29
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_OWVAR 67
5853: ARRAY
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 13
5863: PUSH
5864: LD_INT 1
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: LD_INT 29
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 14
5881: PUSH
5882: LD_INT 1
5884: PUSH
5885: LD_INT 2
5887: PUSH
5888: LD_INT 26
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PPUSH
5905: CALL 58021 0 2
// end ; repeat wait ( 0 0$1 ) ;
5909: LD_INT 35
5911: PPUSH
5912: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5916: LD_INT 3
5918: PPUSH
5919: LD_INT 1
5921: PPUSH
5922: CALL 59439 0 2
5926: PUSH
5927: LD_INT 6
5929: GREATEREQUAL
5930: IFFALSE 5909
// wait ( 0 0$30 ) ;
5932: LD_INT 1050
5934: PPUSH
5935: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: LD_INT 3
5946: PPUSH
5947: LD_INT 1
5949: PPUSH
5950: CALL 59439 0 2
5954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5955: LD_ADDR_EXP 120
5959: PUSH
5960: LD_EXP 120
5964: PPUSH
5965: LD_INT 3
5967: PPUSH
5968: LD_EXP 120
5972: PUSH
5973: LD_INT 3
5975: ARRAY
5976: PUSH
5977: LD_VAR 0 2
5981: DIFF
5982: PPUSH
5983: CALL_OW 1
5987: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5988: LD_ADDR_VAR 0 3
5992: PUSH
5993: LD_INT 0
5995: PPUSH
5996: LD_INT 2
5998: PPUSH
5999: CALL_OW 12
6003: ST_TO_ADDR
// if target then
6004: LD_VAR 0 3
6008: IFFALSE 6136
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6010: LD_ADDR_VAR 0 2
6014: PUSH
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 24
6022: PUSH
6023: LD_INT 250
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PPUSH
6030: CALL_OW 72
6034: ST_TO_ADDR
// for i in tmp do
6035: LD_ADDR_VAR 0 1
6039: PUSH
6040: LD_VAR 0 2
6044: PUSH
6045: FOR_IN
6046: IFFALSE 6086
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6048: LD_VAR 0 1
6052: PPUSH
6053: LD_INT 89
6055: PPUSH
6056: LD_INT 71
6058: PPUSH
6059: CALL_OW 297
6063: PUSH
6064: LD_INT 9
6066: GREATER
6067: IFFALSE 6084
// ComMoveXY ( i , 89 , 71 ) ;
6069: LD_VAR 0 1
6073: PPUSH
6074: LD_INT 89
6076: PPUSH
6077: LD_INT 71
6079: PPUSH
6080: CALL_OW 111
6084: GO 6045
6086: POP
6087: POP
// wait ( 0 0$1 ) ;
6088: LD_INT 35
6090: PPUSH
6091: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6095: LD_VAR 0 2
6099: PPUSH
6100: LD_INT 92
6102: PUSH
6103: LD_INT 89
6105: PUSH
6106: LD_INT 71
6108: PUSH
6109: LD_INT 9
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: LIST
6117: PPUSH
6118: CALL_OW 72
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: LD_INT 1
6130: MINUS
6131: GREATEREQUAL
6132: IFFALSE 6010
// end else
6134: GO 6260
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6136: LD_ADDR_VAR 0 2
6140: PUSH
6141: LD_VAR 0 2
6145: PPUSH
6146: LD_INT 24
6148: PUSH
6149: LD_INT 250
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: PPUSH
6156: CALL_OW 72
6160: ST_TO_ADDR
// for i in tmp do
6161: LD_ADDR_VAR 0 1
6165: PUSH
6166: LD_VAR 0 2
6170: PUSH
6171: FOR_IN
6172: IFFALSE 6212
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 125
6181: PPUSH
6182: LD_INT 129
6184: PPUSH
6185: CALL_OW 297
6189: PUSH
6190: LD_INT 9
6192: GREATER
6193: IFFALSE 6210
// ComMoveXY ( i , 125 , 129 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 125
6202: PPUSH
6203: LD_INT 129
6205: PPUSH
6206: CALL_OW 111
6210: GO 6171
6212: POP
6213: POP
// wait ( 0 0$1 ) ;
6214: LD_INT 35
6216: PPUSH
6217: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6221: LD_VAR 0 2
6225: PPUSH
6226: LD_INT 92
6228: PUSH
6229: LD_INT 125
6231: PUSH
6232: LD_INT 129
6234: PUSH
6235: LD_INT 9
6237: PUSH
6238: EMPTY
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: CALL_OW 72
6248: PUSH
6249: LD_VAR 0 2
6253: PUSH
6254: LD_INT 1
6256: MINUS
6257: GREATEREQUAL
6258: IFFALSE 6136
// end ; repeat wait ( 0 0$1 ) ;
6260: LD_INT 35
6262: PPUSH
6263: CALL_OW 67
// for i in tmp do
6267: LD_ADDR_VAR 0 1
6271: PUSH
6272: LD_VAR 0 2
6276: PUSH
6277: FOR_IN
6278: IFFALSE 6360
// begin if GetLives ( i ) > 251 then
6280: LD_VAR 0 1
6284: PPUSH
6285: CALL_OW 256
6289: PUSH
6290: LD_INT 251
6292: GREATER
6293: IFFALSE 6331
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6295: LD_VAR 0 1
6299: PPUSH
6300: LD_INT 81
6302: PUSH
6303: LD_INT 8
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: PPUSH
6310: CALL_OW 69
6314: PPUSH
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL_OW 74
6324: PPUSH
6325: CALL_OW 115
6329: GO 6358
// if IsDead ( i ) then
6331: LD_VAR 0 1
6335: PPUSH
6336: CALL_OW 301
6340: IFFALSE 6358
// tmp := tmp diff i ;
6342: LD_ADDR_VAR 0 2
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: LD_VAR 0 1
6356: DIFF
6357: ST_TO_ADDR
// end ;
6358: GO 6277
6360: POP
6361: POP
// until not tmp ;
6362: LD_VAR 0 2
6366: NOT
6367: IFFALSE 6260
// end ;
6369: PPOPN 3
6371: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6372: LD_EXP 22
6376: NOT
6377: PUSH
6378: LD_EXP 15
6382: PUSH
6383: LD_INT 6
6385: GREATEREQUAL
6386: AND
6387: PUSH
6388: LD_OWVAR 67
6392: PUSH
6393: LD_INT 1
6395: GREATER
6396: AND
6397: IFFALSE 6914
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
// begin enable ;
6407: ENABLE
// tmp := [ ] ;
6408: LD_ADDR_VAR 0 3
6412: PUSH
6413: EMPTY
6414: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6415: LD_ADDR_VAR 0 1
6419: PUSH
6420: DOUBLE
6421: LD_INT 1
6423: DEC
6424: ST_TO_ADDR
6425: LD_INT 4
6427: PUSH
6428: LD_INT 6
6430: PUSH
6431: LD_INT 7
6433: PUSH
6434: EMPTY
6435: LIST
6436: LIST
6437: LIST
6438: PUSH
6439: LD_OWVAR 67
6443: ARRAY
6444: PUSH
6445: FOR_TO
6446: IFFALSE 6606
// begin uc_side := 8 ;
6448: LD_ADDR_OWVAR 20
6452: PUSH
6453: LD_INT 8
6455: ST_TO_ADDR
// uc_nation := 2 ;
6456: LD_ADDR_OWVAR 21
6460: PUSH
6461: LD_INT 2
6463: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6464: LD_INT 13
6466: PUSH
6467: LD_INT 14
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 1
6488: PPUSH
6489: LD_INT 5
6491: PPUSH
6492: LD_INT 27
6494: PUSH
6495: LD_INT 28
6497: PUSH
6498: LD_INT 26
6500: PUSH
6501: LD_INT 25
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 4
6515: PPUSH
6516: CALL_OW 12
6520: ARRAY
6521: PPUSH
6522: LD_INT 88
6524: PPUSH
6525: CALL 71480 0 5
// un := CreateVehicle ;
6529: LD_ADDR_VAR 0 2
6533: PUSH
6534: CALL_OW 45
6538: ST_TO_ADDR
// tmp := tmp ^ un ;
6539: LD_ADDR_VAR 0 3
6543: PUSH
6544: LD_VAR 0 3
6548: PUSH
6549: LD_VAR 0 2
6553: ADD
6554: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6555: LD_VAR 0 2
6559: PPUSH
6560: LD_INT 3
6562: PPUSH
6563: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6567: LD_VAR 0 2
6571: PPUSH
6572: LD_INT 30
6574: PPUSH
6575: LD_INT 0
6577: PPUSH
6578: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6582: LD_VAR 0 2
6586: PPUSH
6587: LD_INT 16
6589: PPUSH
6590: LD_INT 11
6592: PPUSH
6593: CALL_OW 111
// wait ( 0 0$2 ) ;
6597: LD_INT 70
6599: PPUSH
6600: CALL_OW 67
// end ;
6604: GO 6445
6606: POP
6607: POP
// for i = 1 to Difficulty do
6608: LD_ADDR_VAR 0 1
6612: PUSH
6613: DOUBLE
6614: LD_INT 1
6616: DEC
6617: ST_TO_ADDR
6618: LD_OWVAR 67
6622: PUSH
6623: FOR_TO
6624: IFFALSE 6749
// begin uc_side := 8 ;
6626: LD_ADDR_OWVAR 20
6630: PUSH
6631: LD_INT 8
6633: ST_TO_ADDR
// uc_nation := 2 ;
6634: LD_ADDR_OWVAR 21
6638: PUSH
6639: LD_INT 2
6641: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6642: LD_INT 0
6644: PPUSH
6645: LD_INT 8
6647: PPUSH
6648: LD_INT 8
6650: PUSH
6651: LD_INT 8
6653: PUSH
6654: LD_INT 9
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_OWVAR 67
6666: ARRAY
6667: PPUSH
6668: CALL_OW 380
// un := CreateHuman ;
6672: LD_ADDR_VAR 0 2
6676: PUSH
6677: CALL_OW 44
6681: ST_TO_ADDR
// tmp := tmp ^ un ;
6682: LD_ADDR_VAR 0 3
6686: PUSH
6687: LD_VAR 0 3
6691: PUSH
6692: LD_VAR 0 2
6696: ADD
6697: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6698: LD_VAR 0 2
6702: PPUSH
6703: LD_INT 3
6705: PPUSH
6706: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6710: LD_VAR 0 2
6714: PPUSH
6715: LD_INT 30
6717: PPUSH
6718: LD_INT 0
6720: PPUSH
6721: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6725: LD_VAR 0 2
6729: PPUSH
6730: LD_INT 16
6732: PPUSH
6733: LD_INT 11
6735: PPUSH
6736: CALL_OW 111
// wait ( 0 0$2 ) ;
6740: LD_INT 70
6742: PPUSH
6743: CALL_OW 67
// end ;
6747: GO 6623
6749: POP
6750: POP
// repeat wait ( 0 0$1 ) ;
6751: LD_INT 35
6753: PPUSH
6754: CALL_OW 67
// for i in tmp do
6758: LD_ADDR_VAR 0 1
6762: PUSH
6763: LD_VAR 0 3
6767: PUSH
6768: FOR_IN
6769: IFFALSE 6905
// begin if GetLives ( i ) > 250 then
6771: LD_VAR 0 1
6775: PPUSH
6776: CALL_OW 256
6780: PUSH
6781: LD_INT 250
6783: GREATER
6784: IFFALSE 6876
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6786: LD_INT 81
6788: PUSH
6789: LD_INT 8
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 91
6798: PUSH
6799: LD_VAR 0 1
6803: PUSH
6804: LD_INT 10
6806: PUSH
6807: EMPTY
6808: LIST
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: NOT
6821: IFFALSE 6840
// ComAgressiveMove ( i , 67 , 110 ) else
6823: LD_VAR 0 1
6827: PPUSH
6828: LD_INT 67
6830: PPUSH
6831: LD_INT 110
6833: PPUSH
6834: CALL_OW 114
6838: GO 6874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6840: LD_VAR 0 1
6844: PPUSH
6845: LD_INT 81
6847: PUSH
6848: LD_INT 8
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PPUSH
6855: CALL_OW 69
6859: PPUSH
6860: LD_VAR 0 1
6864: PPUSH
6865: CALL_OW 74
6869: PPUSH
6870: CALL_OW 115
// end else
6874: GO 6903
// if IsDead ( i ) then
6876: LD_VAR 0 1
6880: PPUSH
6881: CALL_OW 301
6885: IFFALSE 6903
// tmp := tmp diff i ;
6887: LD_ADDR_VAR 0 3
6891: PUSH
6892: LD_VAR 0 3
6896: PUSH
6897: LD_VAR 0 1
6901: DIFF
6902: ST_TO_ADDR
// end ;
6903: GO 6768
6905: POP
6906: POP
// until not tmp ;
6907: LD_VAR 0 3
6911: NOT
6912: IFFALSE 6751
// end ; end_of_file
6914: PPOPN 3
6916: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6917: LD_INT 0
6919: PPUSH
6920: PPUSH
6921: PPUSH
6922: PPUSH
6923: PPUSH
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
// side := 3 ;
6928: LD_ADDR_VAR 0 6
6932: PUSH
6933: LD_INT 3
6935: ST_TO_ADDR
// uc_side := side ;
6936: LD_ADDR_OWVAR 20
6940: PUSH
6941: LD_VAR 0 6
6945: ST_TO_ADDR
// uc_nation := 3 ;
6946: LD_ADDR_OWVAR 21
6950: PUSH
6951: LD_INT 3
6953: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_VAR 0 6
6966: PUSH
6967: EMPTY
6968: LIST
6969: LIST
6970: PUSH
6971: LD_INT 21
6973: PUSH
6974: LD_INT 3
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PPUSH
6985: CALL_OW 69
6989: PUSH
6990: FOR_IN
6991: IFFALSE 7007
// SetBLevel ( i , 10 ) ;
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_INT 10
7000: PPUSH
7001: CALL_OW 241
7005: GO 6990
7007: POP
7008: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7009: LD_ADDR_VAR 0 9
7013: PUSH
7014: LD_INT 22
7016: PUSH
7017: LD_VAR 0 6
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 30
7028: PUSH
7029: LD_INT 34
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: PPUSH
7040: CALL_OW 69
7044: ST_TO_ADDR
// if teleport then
7045: LD_VAR 0 9
7049: IFFALSE 7070
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7051: LD_VAR 0 9
7055: PUSH
7056: LD_INT 1
7058: ARRAY
7059: PPUSH
7060: LD_INT 123
7062: PPUSH
7063: LD_INT 122
7065: PPUSH
7066: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7070: LD_ADDR_EXP 63
7074: PUSH
7075: LD_STRING Platonov
7077: PPUSH
7078: CALL_OW 25
7082: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7083: LD_ADDR_EXP 64
7087: PUSH
7088: LD_STRING Kovalyuk
7090: PPUSH
7091: CALL_OW 25
7095: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7096: LD_ADDR_EXP 66
7100: PUSH
7101: LD_STRING Yakotich
7103: PPUSH
7104: CALL_OW 25
7108: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7109: LD_ADDR_EXP 65
7113: PUSH
7114: LD_STRING Bystrov
7116: PPUSH
7117: CALL_OW 25
7121: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7122: LD_ADDR_EXP 67
7126: PUSH
7127: LD_STRING Gleb
7129: PPUSH
7130: CALL_OW 25
7134: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7135: LD_STRING 03_Cornel
7137: PPUSH
7138: CALL_OW 28
7142: IFFALSE 7190
// begin Bierezov := NewCharacter ( Mikhail ) ;
7144: LD_ADDR_EXP 68
7148: PUSH
7149: LD_STRING Mikhail
7151: PPUSH
7152: CALL_OW 25
7156: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7157: LD_EXP 68
7161: PPUSH
7162: LD_INT 197
7164: PPUSH
7165: LD_INT 111
7167: PPUSH
7168: LD_INT 9
7170: PPUSH
7171: LD_INT 0
7173: PPUSH
7174: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7178: LD_EXP 68
7182: PPUSH
7183: LD_INT 3
7185: PPUSH
7186: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7190: LD_EXP 63
7194: PPUSH
7195: LD_INT 126
7197: PPUSH
7198: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7202: LD_EXP 64
7206: PPUSH
7207: LD_INT 134
7209: PPUSH
7210: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7214: LD_EXP 66
7218: PPUSH
7219: LD_INT 197
7221: PPUSH
7222: LD_INT 111
7224: PPUSH
7225: LD_INT 9
7227: PPUSH
7228: LD_INT 0
7230: PPUSH
7231: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 197
7242: PPUSH
7243: LD_INT 111
7245: PPUSH
7246: LD_INT 9
7248: PPUSH
7249: LD_INT 0
7251: PPUSH
7252: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7256: LD_EXP 67
7260: PPUSH
7261: LD_INT 197
7263: PPUSH
7264: LD_INT 111
7266: PPUSH
7267: LD_INT 9
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7277: LD_ADDR_VAR 0 5
7281: PUSH
7282: LD_INT 126
7284: PPUSH
7285: LD_INT 4
7287: PPUSH
7288: LD_STRING zhukov
7290: PPUSH
7291: LD_INT 9
7293: PUSH
7294: LD_INT 10
7296: PUSH
7297: LD_INT 10
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: LIST
7304: PUSH
7305: LD_OWVAR 67
7309: ARRAY
7310: PPUSH
7311: LD_INT 90000
7313: PUSH
7314: LD_INT 1000
7316: PUSH
7317: LD_INT 300
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: PPUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 8
7330: PUSH
7331: LD_INT 13
7333: PUSH
7334: LD_INT 8
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: PPUSH
7343: CALL 74889 0 6
7347: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7348: LD_ADDR_VAR 0 4
7352: PUSH
7353: LD_INT 267
7355: PPUSH
7356: CALL_OW 274
7360: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7361: LD_VAR 0 4
7365: PPUSH
7366: LD_INT 1
7368: PPUSH
7369: LD_INT 5000
7371: PPUSH
7372: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7376: LD_VAR 0 4
7380: PPUSH
7381: LD_INT 2
7383: PPUSH
7384: LD_INT 200
7386: PPUSH
7387: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7391: LD_VAR 0 4
7395: PPUSH
7396: LD_INT 3
7398: PPUSH
7399: LD_INT 200
7401: PPUSH
7402: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7406: LD_ADDR_EXP 101
7410: PUSH
7411: LD_EXP 101
7415: PPUSH
7416: LD_INT 2
7418: PPUSH
7419: LD_VAR 0 5
7423: PUSH
7424: LD_INT 22
7426: PUSH
7427: LD_VAR 0 6
7431: PUSH
7432: EMPTY
7433: LIST
7434: LIST
7435: PUSH
7436: LD_INT 3
7438: PUSH
7439: LD_INT 21
7441: PUSH
7442: LD_INT 2
7444: PUSH
7445: EMPTY
7446: LIST
7447: LIST
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PPUSH
7457: CALL_OW 69
7461: UNION
7462: PUSH
7463: LD_EXP 63
7467: DIFF
7468: PPUSH
7469: CALL_OW 1
7473: ST_TO_ADDR
// behemoths := [ ] ;
7474: LD_ADDR_EXP 71
7478: PUSH
7479: EMPTY
7480: ST_TO_ADDR
// behemothBuilders := [ ] ;
7481: LD_ADDR_EXP 72
7485: PUSH
7486: EMPTY
7487: ST_TO_ADDR
// if Kovalyuk then
7488: LD_EXP 64
7492: IFFALSE 7514
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7494: LD_ADDR_EXP 72
7498: PUSH
7499: LD_EXP 72
7503: PPUSH
7504: LD_EXP 64
7508: PPUSH
7509: CALL 107225 0 2
7513: ST_TO_ADDR
// j := 3 ;
7514: LD_ADDR_VAR 0 3
7518: PUSH
7519: LD_INT 3
7521: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 3
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 69
7555: PUSH
7556: LD_EXP 64
7560: DIFF
7561: PUSH
7562: FOR_IN
7563: IFFALSE 7613
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7565: LD_ADDR_EXP 72
7569: PUSH
7570: LD_EXP 72
7574: PPUSH
7575: LD_VAR 0 2
7579: PPUSH
7580: CALL 107225 0 2
7584: ST_TO_ADDR
// j := j - 1 ;
7585: LD_ADDR_VAR 0 3
7589: PUSH
7590: LD_VAR 0 3
7594: PUSH
7595: LD_INT 1
7597: MINUS
7598: ST_TO_ADDR
// if j = 0 then
7599: LD_VAR 0 3
7603: PUSH
7604: LD_INT 0
7606: EQUAL
7607: IFFALSE 7611
// break ;
7609: GO 7613
// end ;
7611: GO 7562
7613: POP
7614: POP
// end ;
7615: LD_VAR 0 1
7619: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7627: LD_ADDR_VAR 0 4
7631: PUSH
7632: LD_INT 209
7634: PUSH
7635: LD_INT 149
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: PUSH
7642: LD_INT 219
7644: PUSH
7645: LD_INT 154
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: PUSH
7652: LD_INT 223
7654: PUSH
7655: LD_INT 149
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 232
7664: PUSH
7665: LD_INT 155
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: ST_TO_ADDR
// if not behemothBuilders then
7678: LD_EXP 72
7682: NOT
7683: IFFALSE 7687
// exit ;
7685: GO 7791
// j := 1 ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// for i in behemothBuilders do
7695: LD_ADDR_VAR 0 2
7699: PUSH
7700: LD_EXP 72
7704: PUSH
7705: FOR_IN
7706: IFFALSE 7789
// begin if IsInUnit ( i ) then
7708: LD_VAR 0 2
7712: PPUSH
7713: CALL_OW 310
7717: IFFALSE 7728
// ComExitBuilding ( i ) ;
7719: LD_VAR 0 2
7723: PPUSH
7724: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7728: LD_VAR 0 2
7732: PPUSH
7733: LD_INT 37
7735: PPUSH
7736: LD_VAR 0 4
7740: PUSH
7741: LD_VAR 0 3
7745: ARRAY
7746: PUSH
7747: LD_INT 1
7749: ARRAY
7750: PPUSH
7751: LD_VAR 0 4
7755: PUSH
7756: LD_VAR 0 3
7760: ARRAY
7761: PUSH
7762: LD_INT 2
7764: ARRAY
7765: PPUSH
7766: LD_INT 0
7768: PPUSH
7769: CALL_OW 230
// j := j + 1 ;
7773: LD_ADDR_VAR 0 3
7777: PUSH
7778: LD_VAR 0 3
7782: PUSH
7783: LD_INT 1
7785: PLUS
7786: ST_TO_ADDR
// end ;
7787: GO 7705
7789: POP
7790: POP
// end ;
7791: LD_VAR 0 1
7795: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7796: LD_INT 24
7798: PPUSH
7799: LD_INT 30
7801: PUSH
7802: LD_INT 37
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 70
7813: IFFALSE 7826
7815: GO 7817
7817: DISABLE
// behemothUnderConstruct := true ;
7818: LD_ADDR_EXP 26
7822: PUSH
7823: LD_INT 1
7825: ST_TO_ADDR
7826: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7827: LD_INT 3
7829: PPUSH
7830: CALL 107273 0 1
7834: PUSH
7835: LD_INT 22
7837: PUSH
7838: LD_INT 3
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: LD_INT 30
7847: PUSH
7848: LD_INT 37
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: PUSH
7855: EMPTY
7856: LIST
7857: LIST
7858: PPUSH
7859: CALL_OW 69
7863: NOT
7864: AND
7865: IFFALSE 8051
7867: GO 7869
7869: DISABLE
7870: LD_INT 0
7872: PPUSH
7873: PPUSH
// begin enable ;
7874: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7875: LD_ADDR_VAR 0 2
7879: PUSH
7880: LD_INT 3
7882: PPUSH
7883: CALL 107273 0 1
7887: ST_TO_ADDR
// for i in tmp do
7888: LD_ADDR_VAR 0 1
7892: PUSH
7893: LD_VAR 0 2
7897: PUSH
7898: FOR_IN
7899: IFFALSE 8049
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7901: LD_VAR 0 1
7905: PPUSH
7906: LD_INT 9
7908: PPUSH
7909: CALL_OW 308
7913: PUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL_OW 110
7923: PUSH
7924: LD_INT 2
7926: EQUAL
7927: NOT
7928: AND
7929: IFFALSE 7943
// SetTag ( i , 2 ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 2
7938: PPUSH
7939: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7943: LD_INT 81
7945: PUSH
7946: LD_INT 3
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 91
7955: PUSH
7956: LD_VAR 0 1
7960: PUSH
7961: LD_INT 12
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: LIST
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PPUSH
7973: CALL_OW 69
7977: NOT
7978: PUSH
7979: LD_VAR 0 1
7983: PPUSH
7984: CALL_OW 110
7988: PUSH
7989: LD_INT 2
7991: EQUAL
7992: NOT
7993: AND
7994: IFFALSE 8013
// ComAgressiveMove ( i , 64 , 93 ) else
7996: LD_VAR 0 1
8000: PPUSH
8001: LD_INT 64
8003: PPUSH
8004: LD_INT 93
8006: PPUSH
8007: CALL_OW 114
8011: GO 8047
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8013: LD_VAR 0 1
8017: PPUSH
8018: LD_INT 81
8020: PUSH
8021: LD_INT 3
8023: PUSH
8024: EMPTY
8025: LIST
8026: LIST
8027: PPUSH
8028: CALL_OW 69
8032: PPUSH
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 74
8042: PPUSH
8043: CALL_OW 115
// end ;
8047: GO 7898
8049: POP
8050: POP
// end ;
8051: PPOPN 2
8053: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8054: LD_INT 0
8056: PPUSH
8057: PPUSH
8058: PPUSH
// result := [ ] ;
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: EMPTY
8065: ST_TO_ADDR
// uc_side := 6 ;
8066: LD_ADDR_OWVAR 20
8070: PUSH
8071: LD_INT 6
8073: ST_TO_ADDR
// uc_nation := 3 ;
8074: LD_ADDR_OWVAR 21
8078: PUSH
8079: LD_INT 3
8081: ST_TO_ADDR
// case strength of 1 :
8082: LD_VAR 0 1
8086: PUSH
8087: LD_INT 1
8089: DOUBLE
8090: EQUAL
8091: IFTRUE 8095
8093: GO 8233
8095: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8096: LD_ADDR_VAR 0 3
8100: PUSH
8101: DOUBLE
8102: LD_INT 1
8104: DEC
8105: ST_TO_ADDR
8106: LD_INT 4
8108: PUSH
8109: LD_INT 5
8111: PUSH
8112: LD_INT 6
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: LIST
8119: PUSH
8120: LD_OWVAR 67
8124: ARRAY
8125: PUSH
8126: FOR_TO
8127: IFFALSE 8229
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8129: LD_INT 22
8131: PUSH
8132: LD_INT 24
8134: PUSH
8135: EMPTY
8136: LIST
8137: LIST
8138: PUSH
8139: LD_VAR 0 3
8143: PUSH
8144: LD_INT 2
8146: MOD
8147: PUSH
8148: LD_INT 1
8150: PLUS
8151: ARRAY
8152: PPUSH
8153: LD_INT 1
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 1
8165: PPUSH
8166: LD_INT 2
8168: PPUSH
8169: CALL_OW 12
8173: ARRAY
8174: PPUSH
8175: LD_INT 3
8177: PPUSH
8178: LD_INT 43
8180: PUSH
8181: LD_INT 44
8183: PUSH
8184: LD_INT 45
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: LIST
8191: PUSH
8192: LD_INT 1
8194: PPUSH
8195: LD_INT 3
8197: PPUSH
8198: CALL_OW 12
8202: ARRAY
8203: PPUSH
8204: LD_INT 80
8206: PPUSH
8207: CALL 71480 0 5
// result := result union CreateVehicle ;
8211: LD_ADDR_VAR 0 2
8215: PUSH
8216: LD_VAR 0 2
8220: PUSH
8221: CALL_OW 45
8225: UNION
8226: ST_TO_ADDR
// end ;
8227: GO 8126
8229: POP
8230: POP
// end ; 2 :
8231: GO 9177
8233: LD_INT 2
8235: DOUBLE
8236: EQUAL
8237: IFTRUE 8241
8239: GO 8397
8241: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8242: LD_ADDR_VAR 0 3
8246: PUSH
8247: DOUBLE
8248: LD_INT 1
8250: DEC
8251: ST_TO_ADDR
8252: LD_INT 5
8254: PUSH
8255: LD_INT 6
8257: PUSH
8258: LD_INT 7
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: LIST
8265: PUSH
8266: LD_OWVAR 67
8270: ARRAY
8271: PUSH
8272: FOR_TO
8273: IFFALSE 8393
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8275: LD_INT 22
8277: PUSH
8278: LD_INT 24
8280: PUSH
8281: LD_INT 24
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: LIST
8288: PUSH
8289: LD_VAR 0 3
8293: PUSH
8294: LD_INT 3
8296: MOD
8297: PUSH
8298: LD_INT 1
8300: PLUS
8301: ARRAY
8302: PPUSH
8303: LD_INT 1
8305: PUSH
8306: LD_INT 3
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: PUSH
8313: LD_INT 1
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: CALL_OW 12
8323: ARRAY
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 43
8330: PUSH
8331: LD_INT 44
8333: PUSH
8334: LD_INT 45
8336: PUSH
8337: LD_INT 44
8339: PUSH
8340: LD_INT 46
8342: PUSH
8343: LD_INT 46
8345: PUSH
8346: EMPTY
8347: LIST
8348: LIST
8349: LIST
8350: LIST
8351: LIST
8352: LIST
8353: PUSH
8354: LD_VAR 0 3
8358: PUSH
8359: LD_INT 6
8361: MOD
8362: PUSH
8363: LD_INT 1
8365: PLUS
8366: ARRAY
8367: PPUSH
8368: LD_INT 80
8370: PPUSH
8371: CALL 71480 0 5
// result := result union CreateVehicle ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_VAR 0 2
8384: PUSH
8385: CALL_OW 45
8389: UNION
8390: ST_TO_ADDR
// end ;
8391: GO 8272
8393: POP
8394: POP
// end ; 3 :
8395: GO 9177
8397: LD_INT 3
8399: DOUBLE
8400: EQUAL
8401: IFTRUE 8405
8403: GO 8561
8405: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8406: LD_ADDR_VAR 0 3
8410: PUSH
8411: DOUBLE
8412: LD_INT 1
8414: DEC
8415: ST_TO_ADDR
8416: LD_INT 5
8418: PUSH
8419: LD_INT 7
8421: PUSH
8422: LD_INT 8
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: LIST
8429: PUSH
8430: LD_OWVAR 67
8434: ARRAY
8435: PUSH
8436: FOR_TO
8437: IFFALSE 8557
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8439: LD_INT 22
8441: PUSH
8442: LD_INT 24
8444: PUSH
8445: LD_INT 24
8447: PUSH
8448: EMPTY
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_VAR 0 3
8457: PUSH
8458: LD_INT 3
8460: MOD
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: ARRAY
8466: PPUSH
8467: LD_INT 1
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: PUSH
8477: LD_INT 1
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 12
8487: ARRAY
8488: PPUSH
8489: LD_INT 3
8491: PPUSH
8492: LD_INT 43
8494: PUSH
8495: LD_INT 47
8497: PUSH
8498: LD_INT 45
8500: PUSH
8501: LD_INT 45
8503: PUSH
8504: LD_INT 46
8506: PUSH
8507: LD_INT 46
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: LIST
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_VAR 0 3
8522: PUSH
8523: LD_INT 6
8525: MOD
8526: PUSH
8527: LD_INT 1
8529: PLUS
8530: ARRAY
8531: PPUSH
8532: LD_INT 80
8534: PPUSH
8535: CALL 71480 0 5
// result := result union CreateVehicle ;
8539: LD_ADDR_VAR 0 2
8543: PUSH
8544: LD_VAR 0 2
8548: PUSH
8549: CALL_OW 45
8553: UNION
8554: ST_TO_ADDR
// end ;
8555: GO 8436
8557: POP
8558: POP
// end ; 4 :
8559: GO 9177
8561: LD_INT 4
8563: DOUBLE
8564: EQUAL
8565: IFTRUE 8569
8567: GO 9176
8569: POP
// begin uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: DOUBLE
8584: LD_INT 1
8586: DEC
8587: ST_TO_ADDR
8588: LD_INT 6
8590: PUSH
8591: LD_INT 8
8593: PUSH
8594: LD_INT 9
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: LIST
8601: PUSH
8602: LD_OWVAR 67
8606: ARRAY
8607: PUSH
8608: FOR_TO
8609: IFFALSE 8729
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8611: LD_INT 22
8613: PUSH
8614: LD_INT 24
8616: PUSH
8617: LD_INT 24
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: PUSH
8625: LD_VAR 0 3
8629: PUSH
8630: LD_INT 3
8632: MOD
8633: PUSH
8634: LD_INT 1
8636: PLUS
8637: ARRAY
8638: PPUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 3
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 1
8651: PPUSH
8652: LD_INT 2
8654: PPUSH
8655: CALL_OW 12
8659: ARRAY
8660: PPUSH
8661: LD_INT 3
8663: PPUSH
8664: LD_INT 45
8666: PUSH
8667: LD_INT 47
8669: PUSH
8670: LD_INT 47
8672: PUSH
8673: LD_INT 45
8675: PUSH
8676: LD_INT 46
8678: PUSH
8679: LD_INT 46
8681: PUSH
8682: EMPTY
8683: LIST
8684: LIST
8685: LIST
8686: LIST
8687: LIST
8688: LIST
8689: PUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_INT 6
8697: MOD
8698: PUSH
8699: LD_INT 1
8701: PLUS
8702: ARRAY
8703: PPUSH
8704: LD_INT 80
8706: PPUSH
8707: CALL 71480 0 5
// result := result union CreateVehicle ;
8711: LD_ADDR_VAR 0 2
8715: PUSH
8716: LD_VAR 0 2
8720: PUSH
8721: CALL_OW 45
8725: UNION
8726: ST_TO_ADDR
// end ;
8727: GO 8608
8729: POP
8730: POP
// if not KappaStatus then
8731: LD_EXP 2
8735: NOT
8736: IFFALSE 8971
// begin uc_nation := 1 ;
8738: LD_ADDR_OWVAR 21
8742: PUSH
8743: LD_INT 1
8745: ST_TO_ADDR
// for i = 1 to 3 do
8746: LD_ADDR_VAR 0 3
8750: PUSH
8751: DOUBLE
8752: LD_INT 1
8754: DEC
8755: ST_TO_ADDR
8756: LD_INT 3
8758: PUSH
8759: FOR_TO
8760: IFFALSE 8896
// begin j := rand ( 0 , 1 ) ;
8762: LD_ADDR_VAR 0 4
8766: PUSH
8767: LD_INT 0
8769: PPUSH
8770: LD_INT 1
8772: PPUSH
8773: CALL_OW 12
8777: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8778: LD_INT 3
8780: PUSH
8781: LD_INT 5
8783: PUSH
8784: LD_INT 5
8786: PUSH
8787: LD_INT 4
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: LIST
8794: LIST
8795: PUSH
8796: LD_VAR 0 4
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 3
8806: PPUSH
8807: CALL_OW 12
8811: PLUS
8812: ARRAY
8813: PPUSH
8814: LD_INT 1
8816: PUSH
8817: LD_INT 3
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 2
8829: PPUSH
8830: CALL_OW 12
8834: ARRAY
8835: PPUSH
8836: LD_INT 3
8838: PPUSH
8839: LD_INT 9
8841: PUSH
8842: LD_INT 7
8844: PUSH
8845: LD_INT 6
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: LIST
8852: PUSH
8853: LD_VAR 0 4
8857: PUSH
8858: LD_INT 1
8860: PPUSH
8861: LD_INT 2
8863: PPUSH
8864: CALL_OW 12
8868: PLUS
8869: ARRAY
8870: PPUSH
8871: LD_INT 85
8873: PPUSH
8874: CALL 71480 0 5
// result := result union CreateVehicle ;
8878: LD_ADDR_VAR 0 2
8882: PUSH
8883: LD_VAR 0 2
8887: PUSH
8888: CALL_OW 45
8892: UNION
8893: ST_TO_ADDR
// end ;
8894: GO 8759
8896: POP
8897: POP
// if vsevolodFirstAttack then
8898: LD_EXP 24
8902: IFFALSE 8969
// begin vsevolodFirstAttack := false ;
8904: LD_ADDR_EXP 24
8908: PUSH
8909: LD_INT 0
8911: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8912: LD_INT 5
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: LD_INT 1
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: LD_INT 100
8926: PPUSH
8927: CALL 71480 0 5
// sewiVeh := CreateVehicle ;
8931: LD_ADDR_EXP 70
8935: PUSH
8936: CALL_OW 45
8940: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8941: LD_EXP 70
8945: PPUSH
8946: LD_INT 1
8948: PPUSH
8949: CALL_OW 242
// result := result union sewiVeh ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_VAR 0 2
8962: PUSH
8963: LD_EXP 70
8967: UNION
8968: ST_TO_ADDR
// end ; end else
8969: GO 9174
// if vsevolodFirstAttack then
8971: LD_EXP 24
8975: IFFALSE 9174
// begin vsevolodFirstAttack := false ;
8977: LD_ADDR_EXP 24
8981: PUSH
8982: LD_INT 0
8984: ST_TO_ADDR
// uc_nation := 3 ;
8985: LD_ADDR_OWVAR 21
8989: PUSH
8990: LD_INT 3
8992: ST_TO_ADDR
// for i = 1 to 3 do
8993: LD_ADDR_VAR 0 3
8997: PUSH
8998: DOUBLE
8999: LD_INT 1
9001: DEC
9002: ST_TO_ADDR
9003: LD_INT 3
9005: PUSH
9006: FOR_TO
9007: IFFALSE 9115
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9009: LD_INT 22
9011: PUSH
9012: LD_INT 24
9014: PUSH
9015: LD_INT 24
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_VAR 0 3
9027: PUSH
9028: LD_INT 3
9030: MOD
9031: PUSH
9032: LD_INT 1
9034: PLUS
9035: ARRAY
9036: PPUSH
9037: LD_INT 1
9039: PUSH
9040: LD_INT 3
9042: PUSH
9043: EMPTY
9044: LIST
9045: LIST
9046: PUSH
9047: LD_INT 1
9049: PPUSH
9050: LD_INT 2
9052: PPUSH
9053: CALL_OW 12
9057: ARRAY
9058: PPUSH
9059: LD_INT 3
9061: PPUSH
9062: LD_INT 45
9064: PUSH
9065: LD_INT 47
9067: PUSH
9068: LD_INT 47
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_VAR 0 3
9080: PUSH
9081: LD_INT 3
9083: MOD
9084: PUSH
9085: LD_INT 1
9087: PLUS
9088: ARRAY
9089: PPUSH
9090: LD_INT 80
9092: PPUSH
9093: CALL 71480 0 5
// result := result union CreateVehicle ;
9097: LD_ADDR_VAR 0 2
9101: PUSH
9102: LD_VAR 0 2
9106: PUSH
9107: CALL_OW 45
9111: UNION
9112: ST_TO_ADDR
// end ;
9113: GO 9006
9115: POP
9116: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9117: LD_INT 24
9119: PPUSH
9120: LD_INT 3
9122: PPUSH
9123: LD_INT 1
9125: PPUSH
9126: LD_INT 47
9128: PPUSH
9129: LD_INT 100
9131: PPUSH
9132: CALL 71480 0 5
// sewiVeh := CreateVehicle ;
9136: LD_ADDR_EXP 70
9140: PUSH
9141: CALL_OW 45
9145: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9146: LD_EXP 70
9150: PPUSH
9151: LD_INT 1
9153: PPUSH
9154: CALL_OW 242
// result := result union sewiVeh ;
9158: LD_ADDR_VAR 0 2
9162: PUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_EXP 70
9172: UNION
9173: ST_TO_ADDR
// end ; end ; end ;
9174: GO 9177
9176: POP
// end ;
9177: LD_VAR 0 2
9181: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9182: LD_EXP 16
9186: IFFALSE 9944
9188: GO 9190
9190: DISABLE
9191: LD_INT 0
9193: PPUSH
9194: PPUSH
9195: PPUSH
9196: PPUSH
9197: PPUSH
9198: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9199: LD_ADDR_VAR 0 4
9203: PUSH
9204: LD_INT 11
9206: PUSH
9207: LD_INT 12
9209: PUSH
9210: EMPTY
9211: LIST
9212: LIST
9213: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: LD_INT 9100
9221: PUSH
9222: LD_INT 7350
9224: PUSH
9225: LD_INT 6650
9227: PUSH
9228: EMPTY
9229: LIST
9230: LIST
9231: LIST
9232: PUSH
9233: LD_OWVAR 67
9237: ARRAY
9238: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9239: LD_ADDR_VAR 0 6
9243: PUSH
9244: LD_INT 70
9246: PUSH
9247: LD_INT 118
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: LD_INT 78
9256: PUSH
9257: LD_INT 31
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: ST_TO_ADDR
// repeat if missionStage = 2 then
9268: LD_EXP 15
9272: PUSH
9273: LD_INT 2
9275: EQUAL
9276: IFFALSE 9287
// wait ( 1 1$30 ) else
9278: LD_INT 3150
9280: PPUSH
9281: CALL_OW 67
9285: GO 9296
// wait ( time ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: CALL_OW 67
// if missionStage = 6 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 6
9303: EQUAL
9304: IFFALSE 9332
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9306: LD_INT 51
9308: PPUSH
9309: LD_INT 6
9311: PPUSH
9312: LD_INT 2
9314: PPUSH
9315: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9319: LD_INT 57
9321: PPUSH
9322: LD_INT 6
9324: PPUSH
9325: LD_INT 2
9327: PPUSH
9328: CALL_OW 322
// end ; if missionStage = 8 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 8
9339: EQUAL
9340: IFFALSE 9368
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9342: LD_INT 52
9344: PPUSH
9345: LD_INT 6
9347: PPUSH
9348: LD_INT 2
9350: PPUSH
9351: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9355: LD_INT 58
9357: PPUSH
9358: LD_INT 6
9360: PPUSH
9361: LD_INT 2
9363: PPUSH
9364: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9368: LD_EXP 15
9372: PUSH
9373: LD_INT 10
9375: EQUAL
9376: PUSH
9377: LD_OWVAR 67
9381: PUSH
9382: LD_INT 1
9384: GREATER
9385: AND
9386: IFFALSE 9414
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9388: LD_INT 53
9390: PPUSH
9391: LD_INT 6
9393: PPUSH
9394: LD_INT 2
9396: PPUSH
9397: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9401: LD_INT 59
9403: PPUSH
9404: LD_INT 6
9406: PPUSH
9407: LD_INT 2
9409: PPUSH
9410: CALL_OW 322
// end ; if activeAttacks then
9414: LD_EXP 16
9418: IFFALSE 9938
// begin if missionStage = 2 then
9420: LD_EXP 15
9424: PUSH
9425: LD_INT 2
9427: EQUAL
9428: IFFALSE 9438
// strength := 1 ;
9430: LD_ADDR_VAR 0 5
9434: PUSH
9435: LD_INT 1
9437: ST_TO_ADDR
// if missionStage > 2 then
9438: LD_EXP 15
9442: PUSH
9443: LD_INT 2
9445: GREATER
9446: IFFALSE 9456
// strength := 2 ;
9448: LD_ADDR_VAR 0 5
9452: PUSH
9453: LD_INT 2
9455: ST_TO_ADDR
// if missionStage > 6 then
9456: LD_EXP 15
9460: PUSH
9461: LD_INT 6
9463: GREATER
9464: IFFALSE 9474
// strength := 3 ;
9466: LD_ADDR_VAR 0 5
9470: PUSH
9471: LD_INT 3
9473: ST_TO_ADDR
// if missionStage > 10 then
9474: LD_EXP 15
9478: PUSH
9479: LD_INT 10
9481: GREATER
9482: IFFALSE 9492
// strength := 4 ;
9484: LD_ADDR_VAR 0 5
9488: PUSH
9489: LD_INT 4
9491: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9492: LD_ADDR_VAR 0 2
9496: PUSH
9497: LD_VAR 0 5
9501: PPUSH
9502: CALL 8054 0 1
9506: ST_TO_ADDR
// for i in tmp do
9507: LD_ADDR_VAR 0 1
9511: PUSH
9512: LD_VAR 0 2
9516: PUSH
9517: FOR_IN
9518: IFFALSE 9618
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9520: LD_VAR 0 1
9524: PPUSH
9525: LD_VAR 0 4
9529: PUSH
9530: LD_INT 1
9532: PPUSH
9533: LD_INT 2
9535: PPUSH
9536: CALL_OW 12
9540: ARRAY
9541: PPUSH
9542: LD_INT 0
9544: PPUSH
9545: CALL_OW 49
// if i = sewiVeh then
9549: LD_VAR 0 1
9553: PUSH
9554: LD_EXP 70
9558: EQUAL
9559: IFFALSE 9594
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9561: LD_ADDR_EXP 69
9565: PUSH
9566: LD_STRING Vsevolod
9568: PPUSH
9569: LD_INT 0
9571: PPUSH
9572: LD_STRING 
9574: PPUSH
9575: CALL 64365 0 3
9579: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9580: LD_EXP 69
9584: PPUSH
9585: LD_VAR 0 1
9589: PPUSH
9590: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9594: LD_VAR 0 1
9598: PPUSH
9599: LD_INT 111
9601: PPUSH
9602: LD_INT 197
9604: PPUSH
9605: CALL_OW 111
// wait ( 0 0$2 ) ;
9609: LD_INT 70
9611: PPUSH
9612: CALL_OW 67
// end ;
9616: GO 9517
9618: POP
9619: POP
// repeat wait ( 0 0$1 ) ;
9620: LD_INT 35
9622: PPUSH
9623: CALL_OW 67
// for i in tmp do
9627: LD_ADDR_VAR 0 1
9631: PUSH
9632: LD_VAR 0 2
9636: PUSH
9637: FOR_IN
9638: IFFALSE 9919
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9640: LD_INT 81
9642: PUSH
9643: LD_INT 6
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 91
9652: PUSH
9653: LD_VAR 0 1
9657: PUSH
9658: LD_INT 12
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: LIST
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 69
9674: IFFALSE 9732
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9676: LD_VAR 0 1
9680: PPUSH
9681: LD_INT 81
9683: PUSH
9684: LD_INT 6
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: LD_INT 91
9693: PUSH
9694: LD_VAR 0 1
9698: PUSH
9699: LD_INT 12
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: LIST
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PPUSH
9711: CALL_OW 69
9715: PPUSH
9716: LD_VAR 0 1
9720: PPUSH
9721: CALL_OW 74
9725: PPUSH
9726: CALL_OW 115
9730: GO 9917
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9732: LD_INT 9
9734: PPUSH
9735: LD_INT 81
9737: PUSH
9738: LD_INT 6
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PPUSH
9745: CALL_OW 70
9749: IFFALSE 9883
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9751: LD_VAR 0 1
9755: PPUSH
9756: LD_VAR 0 6
9760: PUSH
9761: LD_INT 1
9763: ARRAY
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 2
9780: ARRAY
9781: PPUSH
9782: CALL_OW 297
9786: PUSH
9787: LD_INT 10
9789: GREATER
9790: PUSH
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: CALL_OW 308
9803: NOT
9804: AND
9805: IFFALSE 9844
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 6
9816: PUSH
9817: LD_INT 1
9819: ARRAY
9820: PUSH
9821: LD_INT 1
9823: ARRAY
9824: PPUSH
9825: LD_VAR 0 6
9829: PUSH
9830: LD_INT 1
9832: ARRAY
9833: PUSH
9834: LD_INT 2
9836: ARRAY
9837: PPUSH
9838: CALL_OW 114
9842: GO 9881
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 9
9851: PPUSH
9852: LD_INT 81
9854: PUSH
9855: LD_INT 6
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 70
9866: PPUSH
9867: LD_VAR 0 1
9871: PPUSH
9872: CALL_OW 74
9876: PPUSH
9877: CALL_OW 115
// end else
9881: GO 9917
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 81
9890: PUSH
9891: LD_INT 6
9893: PUSH
9894: EMPTY
9895: LIST
9896: LIST
9897: PPUSH
9898: CALL_OW 69
9902: PPUSH
9903: LD_VAR 0 1
9907: PPUSH
9908: CALL_OW 74
9912: PPUSH
9913: CALL_OW 115
// end ;
9917: GO 9637
9919: POP
9920: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9921: LD_INT 22
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PPUSH
9931: CALL_OW 69
9935: NOT
9936: IFFALSE 9620
// end ; until russianDestroyed ;
9938: LD_EXP 21
9942: IFFALSE 9268
// end ;
9944: PPOPN 6
9946: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9947: LD_EXP 21
9951: NOT
9952: PUSH
9953: LD_EXP 15
9957: PUSH
9958: LD_INT 6
9960: GREATEREQUAL
9961: AND
9962: PUSH
9963: LD_INT 2
9965: PPUSH
9966: LD_INT 1
9968: PPUSH
9969: CALL 59439 0 2
9973: NOT
9974: AND
9975: IFFALSE 10931
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
// begin enable ;
9986: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9987: LD_INT 22
9989: PUSH
9990: LD_INT 3
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: LD_INT 30
9999: PUSH
10000: LD_INT 3
10002: PUSH
10003: EMPTY
10004: LIST
10005: LIST
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PPUSH
10011: CALL_OW 69
10015: NOT
10016: IFFALSE 10020
// exit ;
10018: GO 10931
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10020: LD_ADDR_VAR 0 4
10024: PUSH
10025: LD_INT 22
10027: PUSH
10028: LD_INT 3
10030: PUSH
10031: EMPTY
10032: LIST
10033: LIST
10034: PUSH
10035: LD_INT 30
10037: PUSH
10038: LD_INT 34
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: PUSH
10045: EMPTY
10046: LIST
10047: LIST
10048: PPUSH
10049: CALL_OW 69
10053: ST_TO_ADDR
// if Prob ( 40 ) then
10054: LD_INT 40
10056: PPUSH
10057: CALL_OW 13
10061: IFFALSE 10188
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10063: LD_INT 2
10065: PPUSH
10066: LD_INT 22
10068: PUSH
10069: LD_INT 3
10071: PUSH
10072: LD_INT 3
10074: PUSH
10075: LD_INT 49
10077: PUSH
10078: EMPTY
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 22
10086: PUSH
10087: LD_INT 3
10089: PUSH
10090: LD_INT 3
10092: PUSH
10093: LD_INT 49
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: PUSH
10102: LD_INT 22
10104: PUSH
10105: LD_INT 3
10107: PUSH
10108: LD_INT 3
10110: PUSH
10111: LD_INT 49
10113: PUSH
10114: EMPTY
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 24
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: LD_INT 3
10128: PUSH
10129: LD_INT 46
10131: PUSH
10132: EMPTY
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 46
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 46
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: LIST
10178: LIST
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL 58021 0 2
// end else
10186: GO 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10188: LD_INT 2
10190: PPUSH
10191: LD_INT 24
10193: PUSH
10194: LD_INT 3
10196: PUSH
10197: LD_INT 3
10199: PUSH
10200: LD_INT 47
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: LIST
10207: LIST
10208: PUSH
10209: LD_INT 24
10211: PUSH
10212: LD_INT 3
10214: PUSH
10215: LD_INT 3
10217: PUSH
10218: LD_INT 47
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: PUSH
10227: LD_INT 24
10229: PUSH
10230: LD_INT 3
10232: PUSH
10233: LD_INT 3
10235: PUSH
10236: LD_INT 47
10238: PUSH
10239: EMPTY
10240: LIST
10241: LIST
10242: LIST
10243: LIST
10244: PUSH
10245: LD_INT 24
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: LD_INT 3
10253: PUSH
10254: LD_INT 46
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 24
10265: PUSH
10266: LD_INT 3
10268: PUSH
10269: LD_INT 3
10271: PUSH
10272: LD_INT 46
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: LIST
10279: LIST
10280: PUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PPUSH
10307: CALL 58021 0 2
// end ; if Difficulty > 1 then
10311: LD_OWVAR 67
10315: PUSH
10316: LD_INT 1
10318: GREATER
10319: IFFALSE 10349
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10321: LD_INT 2
10323: PPUSH
10324: LD_INT 24
10326: PUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 3
10332: PUSH
10333: LD_INT 47
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: PPUSH
10345: CALL 58021 0 2
// repeat wait ( 0 0$1 ) ;
10349: LD_INT 35
10351: PPUSH
10352: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10356: LD_INT 2
10358: PPUSH
10359: LD_INT 1
10361: PPUSH
10362: CALL 59439 0 2
10366: PUSH
10367: LD_INT 6
10369: PUSH
10370: LD_INT 7
10372: PUSH
10373: LD_INT 7
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: LIST
10380: PUSH
10381: LD_OWVAR 67
10385: ARRAY
10386: GREATEREQUAL
10387: IFFALSE 10349
// wait ( 0 0$30 ) ;
10389: LD_INT 1050
10391: PPUSH
10392: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10396: LD_ADDR_VAR 0 2
10400: PUSH
10401: LD_INT 2
10403: PPUSH
10404: LD_INT 1
10406: PPUSH
10407: CALL 59439 0 2
10411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10412: LD_ADDR_EXP 120
10416: PUSH
10417: LD_EXP 120
10421: PPUSH
10422: LD_INT 2
10424: PPUSH
10425: LD_EXP 120
10429: PUSH
10430: LD_INT 2
10432: ARRAY
10433: PUSH
10434: LD_VAR 0 2
10438: DIFF
10439: PPUSH
10440: CALL_OW 1
10444: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10445: LD_ADDR_VAR 0 3
10449: PUSH
10450: LD_INT 0
10452: PPUSH
10453: LD_INT 1
10455: PPUSH
10456: CALL_OW 12
10460: ST_TO_ADDR
// if target then
10461: LD_VAR 0 3
10465: IFFALSE 10593
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10467: LD_ADDR_VAR 0 2
10471: PUSH
10472: LD_VAR 0 2
10476: PPUSH
10477: LD_INT 24
10479: PUSH
10480: LD_INT 250
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// for i in tmp do
10492: LD_ADDR_VAR 0 1
10496: PUSH
10497: LD_VAR 0 2
10501: PUSH
10502: FOR_IN
10503: IFFALSE 10543
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10505: LD_VAR 0 1
10509: PPUSH
10510: LD_INT 139
10512: PPUSH
10513: LD_INT 89
10515: PPUSH
10516: CALL_OW 297
10520: PUSH
10521: LD_INT 9
10523: GREATER
10524: IFFALSE 10541
// ComMoveXY ( i , 139 , 89 ) ;
10526: LD_VAR 0 1
10530: PPUSH
10531: LD_INT 139
10533: PPUSH
10534: LD_INT 89
10536: PPUSH
10537: CALL_OW 111
10541: GO 10502
10543: POP
10544: POP
// wait ( 0 0$1 ) ;
10545: LD_INT 35
10547: PPUSH
10548: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10552: LD_VAR 0 2
10556: PPUSH
10557: LD_INT 92
10559: PUSH
10560: LD_INT 139
10562: PUSH
10563: LD_INT 89
10565: PUSH
10566: LD_INT 9
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: PPUSH
10575: CALL_OW 72
10579: PUSH
10580: LD_VAR 0 2
10584: PUSH
10585: LD_INT 1
10587: MINUS
10588: GREATEREQUAL
10589: IFFALSE 10467
// end else
10591: GO 10735
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_INT 1
10605: ARRAY
10606: PPUSH
10607: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10611: LD_ADDR_VAR 0 2
10615: PUSH
10616: LD_VAR 0 2
10620: PPUSH
10621: LD_INT 24
10623: PUSH
10624: LD_INT 250
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PPUSH
10631: CALL_OW 72
10635: ST_TO_ADDR
// for i in tmp do
10636: LD_ADDR_VAR 0 1
10640: PUSH
10641: LD_VAR 0 2
10645: PUSH
10646: FOR_IN
10647: IFFALSE 10687
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 124
10656: PPUSH
10657: LD_INT 139
10659: PPUSH
10660: CALL_OW 297
10664: PUSH
10665: LD_INT 9
10667: GREATER
10668: IFFALSE 10685
// ComMoveXY ( i , 124 , 139 ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_INT 124
10677: PPUSH
10678: LD_INT 139
10680: PPUSH
10681: CALL_OW 111
10685: GO 10646
10687: POP
10688: POP
// wait ( 0 0$1 ) ;
10689: LD_INT 35
10691: PPUSH
10692: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10696: LD_VAR 0 2
10700: PPUSH
10701: LD_INT 92
10703: PUSH
10704: LD_INT 124
10706: PUSH
10707: LD_INT 139
10709: PUSH
10710: LD_INT 9
10712: PUSH
10713: EMPTY
10714: LIST
10715: LIST
10716: LIST
10717: LIST
10718: PPUSH
10719: CALL_OW 72
10723: PUSH
10724: LD_VAR 0 2
10728: PUSH
10729: LD_INT 1
10731: MINUS
10732: GREATEREQUAL
10733: IFFALSE 10611
// end ; repeat wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// for i in tmp do
10742: LD_ADDR_VAR 0 1
10746: PUSH
10747: LD_VAR 0 2
10751: PUSH
10752: FOR_IN
10753: IFFALSE 10922
// begin if GetLives ( i ) > 251 then
10755: LD_VAR 0 1
10759: PPUSH
10760: CALL_OW 256
10764: PUSH
10765: LD_INT 251
10767: GREATER
10768: IFFALSE 10893
// begin if GetWeapon ( i ) = ru_time_lapser then
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 264
10779: PUSH
10780: LD_INT 49
10782: EQUAL
10783: IFFALSE 10839
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_INT 2
10792: PUSH
10793: LD_INT 22
10795: PUSH
10796: LD_INT 1
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PUSH
10803: LD_INT 22
10805: PUSH
10806: LD_INT 8
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 69
10822: PPUSH
10823: LD_VAR 0 1
10827: PPUSH
10828: CALL_OW 74
10832: PPUSH
10833: CALL_OW 112
10837: GO 10891
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_INT 2
10846: PUSH
10847: LD_INT 22
10849: PUSH
10850: LD_INT 1
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PUSH
10857: LD_INT 22
10859: PUSH
10860: LD_INT 8
10862: PUSH
10863: EMPTY
10864: LIST
10865: LIST
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: LIST
10871: PPUSH
10872: CALL_OW 69
10876: PPUSH
10877: LD_VAR 0 1
10881: PPUSH
10882: CALL_OW 74
10886: PPUSH
10887: CALL_OW 115
// end else
10891: GO 10920
// if IsDead ( i ) then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 301
10902: IFFALSE 10920
// tmp := tmp diff i ;
10904: LD_ADDR_VAR 0 2
10908: PUSH
10909: LD_VAR 0 2
10913: PUSH
10914: LD_VAR 0 1
10918: DIFF
10919: ST_TO_ADDR
// end ;
10920: GO 10752
10922: POP
10923: POP
// until not tmp ;
10924: LD_VAR 0 2
10928: NOT
10929: IFFALSE 10735
// end ; end_of_file
10931: PPOPN 4
10933: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
10939: PPUSH
10940: PPUSH
10941: PPUSH
// side := 7 ;
10942: LD_ADDR_VAR 0 5
10946: PUSH
10947: LD_INT 7
10949: ST_TO_ADDR
// uc_side := side ;
10950: LD_ADDR_OWVAR 20
10954: PUSH
10955: LD_VAR 0 5
10959: ST_TO_ADDR
// uc_nation := 1 ;
10960: LD_ADDR_OWVAR 21
10964: PUSH
10965: LD_INT 1
10967: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10968: LD_ADDR_VAR 0 2
10972: PUSH
10973: LD_INT 22
10975: PUSH
10976: LD_VAR 0 5
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: PUSH
10985: LD_INT 21
10987: PUSH
10988: LD_INT 3
10990: PUSH
10991: EMPTY
10992: LIST
10993: LIST
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: FOR_IN
11005: IFFALSE 11021
// SetBLevel ( i , 10 ) ;
11007: LD_VAR 0 2
11011: PPUSH
11012: LD_INT 10
11014: PPUSH
11015: CALL_OW 241
11019: GO 11004
11021: POP
11022: POP
// base := GetBase ( al_depot ) ;
11023: LD_ADDR_VAR 0 4
11027: PUSH
11028: LD_INT 2
11030: PPUSH
11031: CALL_OW 274
11035: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11036: LD_ADDR_VAR 0 6
11040: PUSH
11041: LD_INT 22
11043: PUSH
11044: LD_VAR 0 5
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: PUSH
11053: LD_INT 30
11055: PUSH
11056: LD_INT 34
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 69
11071: ST_TO_ADDR
// if teleport then
11072: LD_VAR 0 6
11076: IFFALSE 11097
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11078: LD_VAR 0 6
11082: PUSH
11083: LD_INT 1
11085: ARRAY
11086: PPUSH
11087: LD_INT 262
11089: PPUSH
11090: LD_INT 119
11092: PPUSH
11093: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11097: LD_VAR 0 4
11101: PPUSH
11102: LD_INT 1
11104: PPUSH
11105: LD_INT 19500
11107: PPUSH
11108: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11112: LD_VAR 0 4
11116: PPUSH
11117: LD_INT 2
11119: PPUSH
11120: LD_INT 200
11122: PPUSH
11123: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11127: LD_VAR 0 4
11131: PPUSH
11132: LD_INT 3
11134: PPUSH
11135: LD_INT 650
11137: PPUSH
11138: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11142: LD_ADDR_EXP 73
11146: PUSH
11147: LD_STRING Roth
11149: PPUSH
11150: CALL_OW 25
11154: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11155: LD_ADDR_EXP 74
11159: PUSH
11160: LD_STRING Simms
11162: PPUSH
11163: LD_EXP 1
11167: NOT
11168: PPUSH
11169: LD_STRING 10c_
11171: PPUSH
11172: CALL 64365 0 3
11176: ST_TO_ADDR
// if not Simms then
11177: LD_EXP 74
11181: NOT
11182: IFFALSE 11212
// begin uc_nation := 1 ;
11184: LD_ADDR_OWVAR 21
11188: PUSH
11189: LD_INT 1
11191: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11192: LD_INT 2
11194: PPUSH
11195: LD_INT 10
11197: PPUSH
11198: CALL_OW 384
// Simms := CreateHuman ;
11202: LD_ADDR_EXP 74
11206: PUSH
11207: CALL_OW 44
11211: ST_TO_ADDR
// end ; uc_nation := 3 ;
11212: LD_ADDR_OWVAR 21
11216: PUSH
11217: LD_INT 3
11219: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11220: LD_ADDR_EXP 75
11224: PUSH
11225: LD_STRING Kirilenkova
11227: PPUSH
11228: CALL_OW 25
11232: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11233: LD_ADDR_EXP 89
11237: PUSH
11238: LD_STRING Oblukov
11240: PPUSH
11241: CALL_OW 25
11245: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11246: LD_ADDR_EXP 76
11250: PUSH
11251: LD_STRING Dolgov
11253: PPUSH
11254: CALL_OW 25
11258: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11259: LD_ADDR_EXP 77
11263: PUSH
11264: LD_STRING Petrosyan
11266: PPUSH
11267: CALL_OW 25
11271: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11272: LD_ADDR_EXP 88
11276: PUSH
11277: LD_STRING Scholtze
11279: PPUSH
11280: CALL_OW 25
11284: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11285: LD_ADDR_EXP 87
11289: PUSH
11290: LD_STRING Kapitsova
11292: PPUSH
11293: CALL_OW 25
11297: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11298: LD_ADDR_EXP 78
11302: PUSH
11303: LD_STRING Petrovova
11305: PPUSH
11306: CALL_OW 25
11310: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11311: LD_ADDR_EXP 79
11315: PUSH
11316: LD_STRING Kuzmov
11318: PPUSH
11319: CALL_OW 25
11323: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11324: LD_ADDR_EXP 86
11328: PUSH
11329: LD_STRING Karamazov
11331: PPUSH
11332: CALL_OW 25
11336: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11337: LD_STRING 13_Lipshchin_1
11339: PPUSH
11340: LD_INT 0
11342: PPUSH
11343: CALL_OW 30
11347: IFFALSE 11362
// Lipshchin := NewCharacter ( Lipshchin ) ;
11349: LD_ADDR_EXP 80
11353: PUSH
11354: LD_STRING Lipshchin
11356: PPUSH
11357: CALL_OW 25
11361: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11362: LD_STRING 13_Titov_1
11364: PPUSH
11365: LD_INT 0
11367: PPUSH
11368: CALL_OW 30
11372: IFFALSE 11387
// Titov := NewCharacter ( Titov ) ;
11374: LD_ADDR_EXP 82
11378: PUSH
11379: LD_STRING Titov
11381: PPUSH
11382: CALL_OW 25
11386: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11387: LD_STRING 13_Gnyevko_1
11389: PPUSH
11390: LD_INT 0
11392: PPUSH
11393: CALL_OW 30
11397: IFFALSE 11412
// Gnyevko := NewCharacter ( Gnyevko ) ;
11399: LD_ADDR_EXP 81
11403: PUSH
11404: LD_STRING Gnyevko
11406: PPUSH
11407: CALL_OW 25
11411: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11412: LD_STRING 13_Xavier_1
11414: PPUSH
11415: LD_INT 0
11417: PPUSH
11418: CALL_OW 30
11422: IFFALSE 11437
// Xavier := NewCharacter ( Xavier2 ) ;
11424: LD_ADDR_EXP 83
11428: PUSH
11429: LD_STRING Xavier2
11431: PPUSH
11432: CALL_OW 25
11436: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11437: LD_STRING 13_Belkov_1
11439: PPUSH
11440: LD_INT 0
11442: PPUSH
11443: CALL_OW 30
11447: IFFALSE 11462
// Belkov := NewCharacter ( Belkov ) ;
11449: LD_ADDR_EXP 84
11453: PUSH
11454: LD_STRING Belkov
11456: PPUSH
11457: CALL_OW 25
11461: ST_TO_ADDR
// if not BurlakStatus then
11462: LD_EXP 9
11466: NOT
11467: IFFALSE 11482
// Burlak = NewCharacter ( Burlak ) ;
11469: LD_ADDR_EXP 85
11473: PUSH
11474: LD_STRING Burlak
11476: PPUSH
11477: CALL_OW 25
11481: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11482: LD_ADDR_VAR 0 3
11486: PUSH
11487: LD_EXP 73
11491: PUSH
11492: LD_EXP 75
11496: PUSH
11497: LD_EXP 89
11501: PUSH
11502: LD_EXP 76
11506: PUSH
11507: LD_EXP 77
11511: PUSH
11512: LD_EXP 88
11516: PUSH
11517: LD_EXP 87
11521: PUSH
11522: LD_EXP 78
11526: PUSH
11527: LD_EXP 79
11531: PUSH
11532: LD_EXP 86
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
// if Simms then
11549: LD_EXP 74
11553: IFFALSE 11571
// tmp := tmp ^ Simms ;
11555: LD_ADDR_VAR 0 3
11559: PUSH
11560: LD_VAR 0 3
11564: PUSH
11565: LD_EXP 74
11569: ADD
11570: ST_TO_ADDR
// if Titov then
11571: LD_EXP 82
11575: IFFALSE 11593
// tmp := tmp ^ Titov ;
11577: LD_ADDR_VAR 0 3
11581: PUSH
11582: LD_VAR 0 3
11586: PUSH
11587: LD_EXP 82
11591: ADD
11592: ST_TO_ADDR
// if Lipshchin then
11593: LD_EXP 80
11597: IFFALSE 11615
// tmp := tmp ^ Lipshchin ;
11599: LD_ADDR_VAR 0 3
11603: PUSH
11604: LD_VAR 0 3
11608: PUSH
11609: LD_EXP 80
11613: ADD
11614: ST_TO_ADDR
// if Gnyevko then
11615: LD_EXP 81
11619: IFFALSE 11637
// tmp := tmp ^ Gnyevko ;
11621: LD_ADDR_VAR 0 3
11625: PUSH
11626: LD_VAR 0 3
11630: PUSH
11631: LD_EXP 81
11635: ADD
11636: ST_TO_ADDR
// if Xavier then
11637: LD_EXP 83
11641: IFFALSE 11659
// tmp := tmp ^ Xavier ;
11643: LD_ADDR_VAR 0 3
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: LD_EXP 83
11657: ADD
11658: ST_TO_ADDR
// if Belkov then
11659: LD_EXP 84
11663: IFFALSE 11681
// tmp := tmp ^ Belkov ;
11665: LD_ADDR_VAR 0 3
11669: PUSH
11670: LD_VAR 0 3
11674: PUSH
11675: LD_EXP 84
11679: ADD
11680: ST_TO_ADDR
// if Burlak then
11681: LD_EXP 85
11685: IFFALSE 11703
// tmp := tmp ^ Burlak ;
11687: LD_ADDR_VAR 0 3
11691: PUSH
11692: LD_VAR 0 3
11696: PUSH
11697: LD_EXP 85
11701: ADD
11702: ST_TO_ADDR
// for i = 1 to 8 do
11703: LD_ADDR_VAR 0 2
11707: PUSH
11708: DOUBLE
11709: LD_INT 1
11711: DEC
11712: ST_TO_ADDR
11713: LD_INT 8
11715: PUSH
11716: FOR_TO
11717: IFFALSE 11783
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11719: LD_ADDR_OWVAR 21
11723: PUSH
11724: LD_INT 1
11726: PUSH
11727: LD_INT 3
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: PUSH
11734: LD_INT 1
11736: PPUSH
11737: LD_INT 2
11739: PPUSH
11740: CALL_OW 12
11744: ARRAY
11745: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 2
11753: PUSH
11754: LD_INT 2
11756: DIV
11757: PPUSH
11758: LD_INT 10
11760: PPUSH
11761: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11765: LD_ADDR_VAR 0 3
11769: PUSH
11770: LD_VAR 0 3
11774: PUSH
11775: CALL_OW 44
11779: ADD
11780: ST_TO_ADDR
// end ;
11781: GO 11716
11783: POP
11784: POP
// for i in tmp do
11785: LD_ADDR_VAR 0 2
11789: PUSH
11790: LD_VAR 0 3
11794: PUSH
11795: FOR_IN
11796: IFFALSE 11821
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11798: LD_VAR 0 2
11802: PPUSH
11803: LD_INT 260
11805: PPUSH
11806: LD_INT 235
11808: PPUSH
11809: LD_INT 8
11811: PPUSH
11812: LD_INT 0
11814: PPUSH
11815: CALL_OW 50
11819: GO 11795
11821: POP
11822: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11823: LD_ADDR_EXP 101
11827: PUSH
11828: LD_EXP 101
11832: PPUSH
11833: LD_INT 1
11835: PPUSH
11836: LD_INT 22
11838: PUSH
11839: LD_VAR 0 5
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: LD_INT 3
11850: PUSH
11851: LD_INT 21
11853: PUSH
11854: LD_INT 2
11856: PUSH
11857: EMPTY
11858: LIST
11859: LIST
11860: PUSH
11861: EMPTY
11862: LIST
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 69
11873: PUSH
11874: LD_EXP 73
11878: PUSH
11879: LD_EXP 74
11883: PUSH
11884: EMPTY
11885: LIST
11886: LIST
11887: DIFF
11888: PPUSH
11889: CALL_OW 1
11893: ST_TO_ADDR
// uc_side := 0 ;
11894: LD_ADDR_OWVAR 20
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// uc_nation := 0 ;
11902: LD_ADDR_OWVAR 21
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// for i = 1 to 5 do
11910: LD_ADDR_VAR 0 2
11914: PUSH
11915: DOUBLE
11916: LD_INT 1
11918: DEC
11919: ST_TO_ADDR
11920: LD_INT 5
11922: PUSH
11923: FOR_TO
11924: IFFALSE 11961
// begin InitHc ;
11926: CALL_OW 19
// hc_class := class_apeman ;
11930: LD_ADDR_OWVAR 28
11934: PUSH
11935: LD_INT 12
11937: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11938: CALL_OW 44
11942: PPUSH
11943: LD_INT 299
11945: PPUSH
11946: LD_INT 229
11948: PPUSH
11949: LD_INT 10
11951: PPUSH
11952: LD_INT 0
11954: PPUSH
11955: CALL_OW 50
// end ;
11959: GO 11923
11961: POP
11962: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11963: LD_EXP 73
11967: PPUSH
11968: LD_INT 259
11970: PPUSH
11971: LD_INT 235
11973: PPUSH
11974: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11978: LD_EXP 73
11982: PPUSH
11983: LD_INT 262
11985: PPUSH
11986: LD_INT 235
11988: PPUSH
11989: CALL_OW 178
// if Simms then
11993: LD_EXP 74
11997: IFFALSE 12028
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11999: LD_EXP 74
12003: PPUSH
12004: LD_INT 262
12006: PPUSH
12007: LD_INT 235
12009: PPUSH
12010: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12014: LD_EXP 74
12018: PPUSH
12019: LD_EXP 73
12023: PPUSH
12024: CALL_OW 179
// end ; end ;
12028: LD_VAR 0 1
12032: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12033: LD_EXP 31
12037: PUSH
12038: LD_EXP 23
12042: NOT
12043: AND
12044: IFFALSE 12220
12046: GO 12048
12048: DISABLE
12049: LD_INT 0
12051: PPUSH
12052: PPUSH
12053: PPUSH
// begin enable ;
12054: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12055: LD_ADDR_VAR 0 2
12059: PUSH
12060: LD_INT 81
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 2
12072: PUSH
12073: LD_INT 32
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 30
12085: PUSH
12086: LD_INT 30
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 30
12095: PUSH
12096: LD_INT 28
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 34
12105: PUSH
12106: LD_INT 49
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 34
12115: PUSH
12116: LD_INT 10
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 34
12125: PUSH
12126: LD_INT 8
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: LIST
12141: PUSH
12142: EMPTY
12143: LIST
12144: LIST
12145: PPUSH
12146: CALL_OW 69
12150: ST_TO_ADDR
// if not tmp then
12151: LD_VAR 0 2
12155: NOT
12156: IFFALSE 12160
// exit ;
12158: GO 12220
// target := tmp [ rand ( 1 , tmp ) ] ;
12160: LD_ADDR_VAR 0 3
12164: PUSH
12165: LD_VAR 0 2
12169: PUSH
12170: LD_INT 1
12172: PPUSH
12173: LD_VAR 0 2
12177: PPUSH
12178: CALL_OW 12
12182: ARRAY
12183: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12184: LD_VAR 0 3
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 1
12196: EQUAL
12197: IFFALSE 12208
// CenterNowOnUnits ( target ) ;
12199: LD_VAR 0 3
12203: PPUSH
12204: CALL_OW 87
// SetLives ( target , 0 ) ;
12208: LD_VAR 0 3
12212: PPUSH
12213: LD_INT 0
12215: PPUSH
12216: CALL_OW 234
// end ;
12220: PPOPN 3
12222: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12223: LD_EXP 23
12227: NOT
12228: PUSH
12229: LD_EXP 31
12233: AND
12234: IFFALSE 12756
12236: GO 12238
12238: DISABLE
12239: LD_INT 0
12241: PPUSH
12242: PPUSH
12243: PPUSH
// begin uc_side := 7 ;
12244: LD_ADDR_OWVAR 20
12248: PUSH
12249: LD_INT 7
12251: ST_TO_ADDR
// uc_nation := 1 ;
12252: LD_ADDR_OWVAR 21
12256: PUSH
12257: LD_INT 1
12259: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12260: LD_ADDR_VAR 0 3
12264: PUSH
12265: LD_INT 125
12267: PUSH
12268: LD_INT 163
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 185
12277: PUSH
12278: LD_INT 168
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 111
12287: PUSH
12288: LD_INT 97
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: PPUSH
12300: CALL 107317 0 1
12304: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12305: LD_ADDR_EXP 90
12309: PUSH
12310: EMPTY
12311: ST_TO_ADDR
// for i = 1 to Difficulty do
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: DOUBLE
12318: LD_INT 1
12320: DEC
12321: ST_TO_ADDR
12322: LD_OWVAR 67
12326: PUSH
12327: FOR_TO
12328: IFFALSE 12486
// begin InitHc ;
12330: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12334: LD_INT 0
12336: PPUSH
12337: LD_INT 8
12339: PPUSH
12340: CALL_OW 381
// un := CreateHuman ;
12344: LD_ADDR_VAR 0 2
12348: PUSH
12349: CALL_OW 44
12353: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12354: LD_VAR 0 2
12358: PPUSH
12359: LD_INT 258
12361: PPUSH
12362: LD_INT 267
12364: PPUSH
12365: LD_INT 4
12367: PPUSH
12368: LD_INT 0
12370: PPUSH
12371: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12375: LD_ADDR_EXP 90
12379: PUSH
12380: LD_EXP 90
12384: PUSH
12385: LD_VAR 0 2
12389: UNION
12390: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12391: LD_VAR 0 2
12395: PPUSH
12396: LD_VAR 0 3
12400: PUSH
12401: LD_VAR 0 1
12405: ARRAY
12406: PUSH
12407: LD_INT 1
12409: ARRAY
12410: PPUSH
12411: LD_VAR 0 3
12415: PUSH
12416: LD_VAR 0 1
12420: ARRAY
12421: PUSH
12422: LD_INT 2
12424: ARRAY
12425: PPUSH
12426: LD_INT 4
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12436: LD_VAR 0 2
12440: PPUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 1
12450: ARRAY
12451: PUSH
12452: LD_INT 1
12454: ARRAY
12455: PPUSH
12456: LD_VAR 0 3
12460: PUSH
12461: LD_VAR 0 1
12465: ARRAY
12466: PUSH
12467: LD_INT 2
12469: ARRAY
12470: PPUSH
12471: CALL_OW 171
// AddComInvisible ( un ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL_OW 212
// end ;
12484: GO 12327
12486: POP
12487: POP
// repeat wait ( 0 0$20 ) ;
12488: LD_INT 700
12490: PPUSH
12491: CALL_OW 67
// for i in allianceSpecialForce do
12495: LD_ADDR_VAR 0 1
12499: PUSH
12500: LD_EXP 90
12504: PUSH
12505: FOR_IN
12506: IFFALSE 12741
// begin if IsInvisible ( i ) then
12508: LD_VAR 0 1
12512: PPUSH
12513: CALL_OW 571
12517: IFFALSE 12710
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12519: LD_ADDR_VAR 0 3
12523: PUSH
12524: LD_INT 22
12526: PUSH
12527: LD_INT 1
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: PUSH
12534: LD_INT 50
12536: PUSH
12537: EMPTY
12538: LIST
12539: PUSH
12540: LD_INT 56
12542: PUSH
12543: EMPTY
12544: LIST
12545: PUSH
12546: LD_INT 91
12548: PUSH
12549: LD_VAR 0 1
12553: PUSH
12554: LD_INT 25
12556: PUSH
12557: LD_INT 30
12559: PUSH
12560: LD_INT 35
12562: PUSH
12563: EMPTY
12564: LIST
12565: LIST
12566: LIST
12567: PUSH
12568: LD_OWVAR 67
12572: ARRAY
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 2
12581: PUSH
12582: LD_INT 25
12584: PUSH
12585: LD_INT 1
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 25
12594: PUSH
12595: LD_INT 2
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 3
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 25
12614: PUSH
12615: LD_INT 4
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 25
12624: PUSH
12625: LD_INT 5
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 8
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: EMPTY
12643: LIST
12644: LIST
12645: LIST
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: ST_TO_ADDR
// if not tmp then
12663: LD_VAR 0 3
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12505
// if Prob ( 30 * Difficulty ) then
12672: LD_INT 30
12674: PUSH
12675: LD_OWVAR 67
12679: MUL
12680: PPUSH
12681: CALL_OW 13
12685: IFFALSE 12710
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12687: LD_VAR 0 3
12691: PUSH
12692: LD_INT 1
12694: PPUSH
12695: LD_VAR 0 3
12699: PPUSH
12700: CALL_OW 12
12704: ARRAY
12705: PPUSH
12706: CALL 30367 0 1
// end ; if IsDead ( i ) then
12710: LD_VAR 0 1
12714: PPUSH
12715: CALL_OW 301
12719: IFFALSE 12739
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12721: LD_ADDR_EXP 90
12725: PUSH
12726: LD_EXP 90
12730: PUSH
12731: LD_VAR 0 1
12735: DIFF
12736: ST_TO_ADDR
// continue ;
12737: GO 12505
// end ; end ;
12739: GO 12505
12741: POP
12742: POP
// until allianceDestroyed or not allianceSpecialForce ;
12743: LD_EXP 23
12747: PUSH
12748: LD_EXP 90
12752: NOT
12753: OR
12754: IFFALSE 12488
// end ;
12756: PPOPN 3
12758: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12759: LD_EXP 23
12763: NOT
12764: PUSH
12765: LD_EXP 31
12769: AND
12770: PUSH
12771: LD_INT 1
12773: PPUSH
12774: LD_INT 1
12776: PPUSH
12777: CALL 59439 0 2
12781: NOT
12782: AND
12783: IFFALSE 13750
12785: GO 12787
12787: DISABLE
12788: LD_INT 0
12790: PPUSH
12791: PPUSH
12792: PPUSH
12793: PPUSH
// begin enable ;
12794: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12795: LD_INT 22
12797: PUSH
12798: LD_INT 7
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: PUSH
12805: LD_INT 30
12807: PUSH
12808: LD_INT 3
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 69
12823: NOT
12824: IFFALSE 12828
// exit ;
12826: GO 13750
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12828: LD_ADDR_VAR 0 4
12832: PUSH
12833: LD_INT 22
12835: PUSH
12836: LD_INT 7
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: LD_INT 30
12845: PUSH
12846: LD_INT 34
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: PUSH
12853: EMPTY
12854: LIST
12855: LIST
12856: PPUSH
12857: CALL_OW 69
12861: ST_TO_ADDR
// if Prob ( 40 ) then
12862: LD_INT 40
12864: PPUSH
12865: CALL_OW 13
12869: IFFALSE 12996
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 5
12876: PUSH
12877: LD_INT 3
12879: PUSH
12880: LD_INT 2
12882: PUSH
12883: LD_INT 6
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: PUSH
12892: LD_INT 5
12894: PUSH
12895: LD_INT 3
12897: PUSH
12898: LD_INT 2
12900: PUSH
12901: LD_INT 6
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: LIST
12908: LIST
12909: PUSH
12910: LD_INT 5
12912: PUSH
12913: LD_INT 3
12915: PUSH
12916: LD_INT 2
12918: PUSH
12919: LD_INT 6
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: PUSH
12928: LD_INT 24
12930: PUSH
12931: LD_INT 3
12933: PUSH
12934: LD_INT 3
12936: PUSH
12937: LD_INT 45
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 45
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: LIST
12986: LIST
12987: LIST
12988: LIST
12989: PPUSH
12990: CALL 58021 0 2
// end else
12994: GO 13119
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12996: LD_INT 1
12998: PPUSH
12999: LD_INT 24
13001: PUSH
13002: LD_INT 3
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 47
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: PUSH
13017: LD_INT 24
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 47
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: PUSH
13035: LD_INT 5
13037: PUSH
13038: LD_INT 3
13040: PUSH
13041: LD_INT 2
13043: PUSH
13044: LD_INT 9
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 3
13058: PUSH
13059: LD_INT 2
13061: PUSH
13062: LD_INT 9
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 24
13073: PUSH
13074: LD_INT 1
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 45
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: PUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 1
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 45
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: PPUSH
13115: CALL 58021 0 2
// end ; if Difficulty > 1 then
13119: LD_OWVAR 67
13123: PUSH
13124: LD_INT 1
13126: GREATER
13127: IFFALSE 13157
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13129: LD_INT 1
13131: PPUSH
13132: LD_INT 24
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: LD_INT 47
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: PUSH
13150: EMPTY
13151: LIST
13152: PPUSH
13153: CALL 58021 0 2
// repeat wait ( 0 0$1 ) ;
13157: LD_INT 35
13159: PPUSH
13160: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13164: LD_INT 1
13166: PPUSH
13167: LD_INT 1
13169: PPUSH
13170: CALL 59439 0 2
13174: PUSH
13175: LD_INT 6
13177: PUSH
13178: LD_INT 7
13180: PUSH
13181: LD_INT 7
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: LD_OWVAR 67
13193: ARRAY
13194: GREATEREQUAL
13195: IFFALSE 13157
// wait ( 0 0$40 ) ;
13197: LD_INT 1400
13199: PPUSH
13200: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13204: LD_ADDR_VAR 0 2
13208: PUSH
13209: LD_INT 1
13211: PPUSH
13212: LD_INT 1
13214: PPUSH
13215: CALL 59439 0 2
13219: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13220: LD_ADDR_EXP 120
13224: PUSH
13225: LD_EXP 120
13229: PPUSH
13230: LD_INT 1
13232: PPUSH
13233: LD_EXP 120
13237: PUSH
13238: LD_INT 1
13240: ARRAY
13241: PUSH
13242: LD_VAR 0 2
13246: DIFF
13247: PPUSH
13248: CALL_OW 1
13252: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_INT 0
13260: PPUSH
13261: LD_INT 1
13263: PPUSH
13264: CALL_OW 12
13268: ST_TO_ADDR
// if target then
13269: LD_VAR 0 3
13273: IFFALSE 13439
// begin for i in tmp do
13275: LD_ADDR_VAR 0 1
13279: PUSH
13280: LD_VAR 0 2
13284: PUSH
13285: FOR_IN
13286: IFFALSE 13311
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13288: LD_VAR 0 1
13292: PPUSH
13293: LD_INT 179
13295: PPUSH
13296: LD_INT 209
13298: PPUSH
13299: LD_INT 8
13301: PPUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 483
13309: GO 13285
13311: POP
13312: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13313: LD_ADDR_VAR 0 2
13317: PUSH
13318: LD_VAR 0 2
13322: PPUSH
13323: LD_INT 24
13325: PUSH
13326: LD_INT 250
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 72
13337: ST_TO_ADDR
// for i in tmp do
13338: LD_ADDR_VAR 0 1
13342: PUSH
13343: LD_VAR 0 2
13347: PUSH
13348: FOR_IN
13349: IFFALSE 13389
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13351: LD_VAR 0 1
13355: PPUSH
13356: LD_INT 179
13358: PPUSH
13359: LD_INT 209
13361: PPUSH
13362: CALL_OW 297
13366: PUSH
13367: LD_INT 9
13369: GREATER
13370: IFFALSE 13387
// ComMoveXY ( i , 179 , 209 ) ;
13372: LD_VAR 0 1
13376: PPUSH
13377: LD_INT 179
13379: PPUSH
13380: LD_INT 209
13382: PPUSH
13383: CALL_OW 111
13387: GO 13348
13389: POP
13390: POP
// wait ( 0 0$1 ) ;
13391: LD_INT 35
13393: PPUSH
13394: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13398: LD_VAR 0 2
13402: PPUSH
13403: LD_INT 92
13405: PUSH
13406: LD_INT 179
13408: PUSH
13409: LD_INT 209
13411: PUSH
13412: LD_INT 9
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: PPUSH
13421: CALL_OW 72
13425: PUSH
13426: LD_VAR 0 2
13430: PUSH
13431: LD_INT 1
13433: MINUS
13434: GREATEREQUAL
13435: IFFALSE 13313
// end else
13437: GO 13601
// begin for i in tmp do
13439: LD_ADDR_VAR 0 1
13443: PUSH
13444: LD_VAR 0 2
13448: PUSH
13449: FOR_IN
13450: IFFALSE 13475
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13452: LD_VAR 0 1
13456: PPUSH
13457: LD_INT 285
13459: PPUSH
13460: LD_INT 163
13462: PPUSH
13463: LD_INT 8
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 483
13473: GO 13449
13475: POP
13476: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13477: LD_ADDR_VAR 0 2
13481: PUSH
13482: LD_VAR 0 2
13486: PPUSH
13487: LD_INT 24
13489: PUSH
13490: LD_INT 250
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PPUSH
13497: CALL_OW 72
13501: ST_TO_ADDR
// for i in tmp do
13502: LD_ADDR_VAR 0 1
13506: PUSH
13507: LD_VAR 0 2
13511: PUSH
13512: FOR_IN
13513: IFFALSE 13553
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13515: LD_VAR 0 1
13519: PPUSH
13520: LD_INT 285
13522: PPUSH
13523: LD_INT 163
13525: PPUSH
13526: CALL_OW 297
13530: PUSH
13531: LD_INT 9
13533: GREATER
13534: IFFALSE 13551
// ComMoveXY ( i , 285 , 163 ) ;
13536: LD_VAR 0 1
13540: PPUSH
13541: LD_INT 285
13543: PPUSH
13544: LD_INT 163
13546: PPUSH
13547: CALL_OW 111
13551: GO 13512
13553: POP
13554: POP
// wait ( 0 0$1 ) ;
13555: LD_INT 35
13557: PPUSH
13558: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13562: LD_VAR 0 2
13566: PPUSH
13567: LD_INT 92
13569: PUSH
13570: LD_INT 285
13572: PUSH
13573: LD_INT 163
13575: PUSH
13576: LD_INT 9
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: PPUSH
13585: CALL_OW 72
13589: PUSH
13590: LD_VAR 0 2
13594: PUSH
13595: LD_INT 1
13597: MINUS
13598: GREATEREQUAL
13599: IFFALSE 13477
// end ; repeat wait ( 0 0$1 ) ;
13601: LD_INT 35
13603: PPUSH
13604: CALL_OW 67
// for i in tmp do
13608: LD_ADDR_VAR 0 1
13612: PUSH
13613: LD_VAR 0 2
13617: PUSH
13618: FOR_IN
13619: IFFALSE 13741
// if GetLives ( i ) > 251 then
13621: LD_VAR 0 1
13625: PPUSH
13626: CALL_OW 256
13630: PUSH
13631: LD_INT 251
13633: GREATER
13634: IFFALSE 13723
// begin if GetWeapon ( i ) = ru_time_lapser then
13636: LD_VAR 0 1
13640: PPUSH
13641: CALL_OW 264
13645: PUSH
13646: LD_INT 49
13648: EQUAL
13649: IFFALSE 13687
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13651: LD_VAR 0 1
13655: PPUSH
13656: LD_INT 81
13658: PUSH
13659: LD_INT 7
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 69
13670: PPUSH
13671: LD_VAR 0 1
13675: PPUSH
13676: CALL_OW 74
13680: PPUSH
13681: CALL_OW 112
13685: GO 13721
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_INT 81
13694: PUSH
13695: LD_INT 7
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PPUSH
13702: CALL_OW 69
13706: PPUSH
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 74
13716: PPUSH
13717: CALL_OW 115
// end else
13721: GO 13739
// tmp := tmp diff i ;
13723: LD_ADDR_VAR 0 2
13727: PUSH
13728: LD_VAR 0 2
13732: PUSH
13733: LD_VAR 0 1
13737: DIFF
13738: ST_TO_ADDR
13739: GO 13618
13741: POP
13742: POP
// until not tmp ;
13743: LD_VAR 0 2
13747: NOT
13748: IFFALSE 13601
// end ; end_of_file
13750: PPOPN 4
13752: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13753: LD_INT 0
13755: PPUSH
13756: PPUSH
13757: PPUSH
13758: PPUSH
// missionStage := 13 ;
13759: LD_ADDR_EXP 15
13763: PUSH
13764: LD_INT 13
13766: ST_TO_ADDR
// uc_side := 2 ;
13767: LD_ADDR_OWVAR 20
13771: PUSH
13772: LD_INT 2
13774: ST_TO_ADDR
// uc_nation := 2 ;
13775: LD_ADDR_OWVAR 21
13779: PUSH
13780: LD_INT 2
13782: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13783: LD_ADDR_EXP 91
13787: PUSH
13788: LD_STRING Omar
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13796: LD_EXP 91
13800: PPUSH
13801: LD_INT 4
13803: PPUSH
13804: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13808: LD_EXP 91
13812: PPUSH
13813: LD_INT 242
13815: PPUSH
13816: LD_INT 75
13818: PPUSH
13819: LD_INT 0
13821: PPUSH
13822: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13826: LD_ADDR_EXP 92
13830: PUSH
13831: LD_STRING Heike
13833: PPUSH
13834: CALL_OW 25
13838: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13839: LD_INT 14
13841: PPUSH
13842: LD_INT 3
13844: PPUSH
13845: LD_INT 1
13847: PPUSH
13848: LD_INT 27
13850: PPUSH
13851: LD_INT 100
13853: PPUSH
13854: CALL 71480 0 5
// veh := CreateVehicle ;
13858: LD_ADDR_VAR 0 3
13862: PUSH
13863: CALL_OW 45
13867: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13868: LD_VAR 0 3
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL_OW 242
// SetDir ( veh , 4 ) ;
13880: LD_VAR 0 3
13884: PPUSH
13885: LD_INT 4
13887: PPUSH
13888: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13892: LD_VAR 0 3
13896: PPUSH
13897: LD_INT 241
13899: PPUSH
13900: LD_INT 72
13902: PPUSH
13903: LD_INT 0
13905: PPUSH
13906: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13910: LD_EXP 92
13914: PPUSH
13915: LD_VAR 0 3
13919: PPUSH
13920: CALL_OW 52
// if KhatamStatus then
13924: LD_EXP 8
13928: IFFALSE 13979
// begin Khatam := NewCharacter ( Khatam ) ;
13930: LD_ADDR_EXP 93
13934: PUSH
13935: LD_STRING Khatam
13937: PPUSH
13938: CALL_OW 25
13942: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13943: LD_EXP 93
13947: PPUSH
13948: LD_INT 245
13950: PPUSH
13951: LD_INT 78
13953: PPUSH
13954: LD_INT 3
13956: PPUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13964: LD_EXP 93
13968: PPUSH
13969: LD_INT 4
13971: PPUSH
13972: LD_INT 10
13974: PPUSH
13975: CALL_OW 237
// end ; for i = 1 to Difficulty do
13979: LD_ADDR_VAR 0 2
13983: PUSH
13984: DOUBLE
13985: LD_INT 1
13987: DEC
13988: ST_TO_ADDR
13989: LD_OWVAR 67
13993: PUSH
13994: FOR_TO
13995: IFFALSE 14061
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13997: LD_INT 0
13999: PPUSH
14000: LD_INT 7
14002: PUSH
14003: LD_OWVAR 67
14007: PLUS
14008: PPUSH
14009: CALL_OW 384
// un := CreateHuman ;
14013: LD_ADDR_VAR 0 4
14017: PUSH
14018: CALL_OW 44
14022: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14023: LD_VAR 0 4
14027: PPUSH
14028: LD_INT 28
14030: PUSH
14031: LD_INT 29
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PUSH
14038: LD_VAR 0 2
14042: PUSH
14043: LD_INT 2
14045: MOD
14046: PUSH
14047: LD_INT 1
14049: PLUS
14050: ARRAY
14051: PPUSH
14052: LD_INT 0
14054: PPUSH
14055: CALL_OW 49
// end ;
14059: GO 13994
14061: POP
14062: POP
// for i = 1 to 6 do
14063: LD_ADDR_VAR 0 2
14067: PUSH
14068: DOUBLE
14069: LD_INT 1
14071: DEC
14072: ST_TO_ADDR
14073: LD_INT 6
14075: PUSH
14076: FOR_TO
14077: IFFALSE 14122
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14079: LD_INT 0
14081: PPUSH
14082: LD_INT 7
14084: PUSH
14085: LD_OWVAR 67
14089: PLUS
14090: PPUSH
14091: CALL_OW 381
// un := CreateHuman ;
14095: LD_ADDR_VAR 0 4
14099: PUSH
14100: CALL_OW 44
14104: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14105: LD_VAR 0 4
14109: PPUSH
14110: LD_INT 28
14112: PPUSH
14113: LD_INT 0
14115: PPUSH
14116: CALL_OW 49
// end ;
14120: GO 14076
14122: POP
14123: POP
// for i = 1 to 3 do
14124: LD_ADDR_VAR 0 2
14128: PUSH
14129: DOUBLE
14130: LD_INT 1
14132: DEC
14133: ST_TO_ADDR
14134: LD_INT 3
14136: PUSH
14137: FOR_TO
14138: IFFALSE 14186
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14140: LD_INT 0
14142: PPUSH
14143: LD_INT 8
14145: PPUSH
14146: LD_INT 7
14148: PUSH
14149: LD_OWVAR 67
14153: PLUS
14154: PPUSH
14155: CALL_OW 380
// un := CreateHuman ;
14159: LD_ADDR_VAR 0 4
14163: PUSH
14164: CALL_OW 44
14168: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14169: LD_VAR 0 4
14173: PPUSH
14174: LD_INT 28
14176: PPUSH
14177: LD_INT 0
14179: PPUSH
14180: CALL_OW 49
// end ;
14184: GO 14137
14186: POP
14187: POP
// for i = 1 to 3 do
14188: LD_ADDR_VAR 0 2
14192: PUSH
14193: DOUBLE
14194: LD_INT 1
14196: DEC
14197: ST_TO_ADDR
14198: LD_INT 3
14200: PUSH
14201: FOR_TO
14202: IFFALSE 14292
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14204: LD_INT 14
14206: PPUSH
14207: LD_INT 2
14209: PPUSH
14210: LD_INT 1
14212: PPUSH
14213: LD_INT 28
14215: PPUSH
14216: LD_INT 80
14218: PPUSH
14219: CALL 71480 0 5
// veh := CreateVehicle ;
14223: LD_ADDR_VAR 0 3
14227: PUSH
14228: CALL_OW 45
14232: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14233: LD_VAR 0 3
14237: PPUSH
14238: LD_INT 3
14240: PPUSH
14241: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14245: LD_VAR 0 3
14249: PPUSH
14250: LD_INT 29
14252: PPUSH
14253: LD_INT 0
14255: PPUSH
14256: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14260: LD_INT 0
14262: PPUSH
14263: LD_INT 7
14265: PUSH
14266: LD_OWVAR 67
14270: PLUS
14271: PPUSH
14272: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14276: CALL_OW 44
14280: PPUSH
14281: LD_VAR 0 3
14285: PPUSH
14286: CALL_OW 52
// end ;
14290: GO 14201
14292: POP
14293: POP
// for i = 1 to 5 + Difficulty do
14294: LD_ADDR_VAR 0 2
14298: PUSH
14299: DOUBLE
14300: LD_INT 1
14302: DEC
14303: ST_TO_ADDR
14304: LD_INT 5
14306: PUSH
14307: LD_OWVAR 67
14311: PLUS
14312: PUSH
14313: FOR_TO
14314: IFFALSE 14441
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14316: LD_INT 14
14318: PPUSH
14319: LD_INT 1
14321: PPUSH
14322: LD_INT 3
14324: PPUSH
14325: CALL_OW 12
14329: PPUSH
14330: LD_INT 1
14332: PPUSH
14333: LD_INT 28
14335: PUSH
14336: LD_INT 26
14338: PUSH
14339: LD_INT 27
14341: PUSH
14342: LD_INT 25
14344: PUSH
14345: EMPTY
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: PUSH
14351: LD_VAR 0 2
14355: PUSH
14356: LD_INT 4
14358: MOD
14359: PUSH
14360: LD_INT 1
14362: PLUS
14363: ARRAY
14364: PPUSH
14365: LD_INT 80
14367: PPUSH
14368: CALL 71480 0 5
// veh := CreateVehicle ;
14372: LD_ADDR_VAR 0 3
14376: PUSH
14377: CALL_OW 45
14381: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14382: LD_VAR 0 3
14386: PPUSH
14387: LD_INT 4
14389: PPUSH
14390: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14394: LD_VAR 0 3
14398: PPUSH
14399: LD_INT 28
14401: PPUSH
14402: LD_INT 0
14404: PPUSH
14405: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14409: LD_INT 0
14411: PPUSH
14412: LD_INT 7
14414: PUSH
14415: LD_OWVAR 67
14419: PLUS
14420: PPUSH
14421: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14425: CALL_OW 44
14429: PPUSH
14430: LD_VAR 0 3
14434: PPUSH
14435: CALL_OW 52
// end ;
14439: GO 14313
14441: POP
14442: POP
// for i = 1 to 3 do
14443: LD_ADDR_VAR 0 2
14447: PUSH
14448: DOUBLE
14449: LD_INT 1
14451: DEC
14452: ST_TO_ADDR
14453: LD_INT 3
14455: PUSH
14456: FOR_TO
14457: IFFALSE 14517
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14459: LD_INT 14
14461: PPUSH
14462: LD_INT 3
14464: PPUSH
14465: LD_INT 5
14467: PPUSH
14468: LD_INT 29
14470: PPUSH
14471: LD_INT 80
14473: PPUSH
14474: CALL 71480 0 5
// veh := CreateVehicle ;
14478: LD_ADDR_VAR 0 3
14482: PUSH
14483: CALL_OW 45
14487: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: LD_INT 4
14495: PPUSH
14496: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14500: LD_VAR 0 3
14504: PPUSH
14505: LD_INT 28
14507: PPUSH
14508: LD_INT 0
14510: PPUSH
14511: CALL_OW 49
// end ;
14515: GO 14456
14517: POP
14518: POP
// end ;
14519: LD_VAR 0 1
14523: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14524: LD_INT 22
14526: PUSH
14527: LD_INT 2
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: IFFALSE 14838
14540: GO 14542
14542: DISABLE
14543: LD_INT 0
14545: PPUSH
14546: PPUSH
14547: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14548: LD_ADDR_VAR 0 3
14552: PUSH
14553: LD_INT 22
14555: PUSH
14556: LD_INT 2
14558: PUSH
14559: EMPTY
14560: LIST
14561: LIST
14562: PUSH
14563: LD_INT 25
14565: PUSH
14566: LD_INT 4
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PPUSH
14577: CALL_OW 69
14581: PUSH
14582: LD_EXP 93
14586: DIFF
14587: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14588: LD_ADDR_VAR 0 2
14592: PUSH
14593: LD_INT 22
14595: PUSH
14596: LD_INT 2
14598: PUSH
14599: EMPTY
14600: LIST
14601: LIST
14602: PPUSH
14603: CALL_OW 69
14607: PUSH
14608: LD_EXP 93
14612: PUSH
14613: LD_VAR 0 3
14617: UNION
14618: DIFF
14619: ST_TO_ADDR
// if Khatam then
14620: LD_EXP 93
14624: IFFALSE 14641
// ComMoveXY ( Khatam , 211 , 92 ) ;
14626: LD_EXP 93
14630: PPUSH
14631: LD_INT 211
14633: PPUSH
14634: LD_INT 92
14636: PPUSH
14637: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14641: LD_INT 197
14643: PPUSH
14644: LD_INT 80
14646: PPUSH
14647: LD_INT 2
14649: PPUSH
14650: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14654: LD_INT 213
14656: PPUSH
14657: LD_INT 90
14659: PPUSH
14660: LD_INT 2
14662: PPUSH
14663: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14667: LD_INT 215
14669: PPUSH
14670: LD_INT 129
14672: PPUSH
14673: LD_INT 2
14675: PPUSH
14676: CALL_OW 441
// if sci then
14680: LD_VAR 0 3
14684: IFFALSE 14705
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14686: LD_VAR 0 3
14690: PUSH
14691: LD_INT 1
14693: ARRAY
14694: PPUSH
14695: LD_INT 197
14697: PPUSH
14698: LD_INT 80
14700: PPUSH
14701: CALL_OW 158
// if sci > 1 then
14705: LD_VAR 0 3
14709: PUSH
14710: LD_INT 1
14712: GREATER
14713: IFFALSE 14734
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14715: LD_VAR 0 3
14719: PUSH
14720: LD_INT 2
14722: ARRAY
14723: PPUSH
14724: LD_INT 213
14726: PPUSH
14727: LD_INT 90
14729: PPUSH
14730: CALL_OW 158
// if sci > 2 then
14734: LD_VAR 0 3
14738: PUSH
14739: LD_INT 2
14741: GREATER
14742: IFFALSE 14763
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14744: LD_VAR 0 3
14748: PUSH
14749: LD_INT 3
14751: ARRAY
14752: PPUSH
14753: LD_INT 215
14755: PPUSH
14756: LD_INT 129
14758: PPUSH
14759: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14763: LD_INT 35
14765: PPUSH
14766: CALL_OW 67
// for i in tmp do
14770: LD_ADDR_VAR 0 1
14774: PUSH
14775: LD_VAR 0 2
14779: PUSH
14780: FOR_IN
14781: IFFALSE 14819
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14783: LD_VAR 0 1
14787: PPUSH
14788: LD_INT 81
14790: PUSH
14791: LD_INT 2
14793: PUSH
14794: EMPTY
14795: LIST
14796: LIST
14797: PPUSH
14798: CALL_OW 69
14802: PPUSH
14803: LD_VAR 0 1
14807: PPUSH
14808: CALL_OW 74
14812: PPUSH
14813: CALL_OW 115
14817: GO 14780
14819: POP
14820: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14821: LD_INT 22
14823: PUSH
14824: LD_INT 2
14826: PUSH
14827: EMPTY
14828: LIST
14829: LIST
14830: PPUSH
14831: CALL_OW 69
14835: NOT
14836: IFFALSE 14763
// end ; end_of_file
14838: PPOPN 3
14840: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14841: LD_INT 0
14843: PPUSH
14844: PPUSH
14845: PPUSH
14846: PPUSH
14847: PPUSH
14848: PPUSH
14849: PPUSH
14850: PPUSH
14851: PPUSH
// Video ( true ) ;
14852: LD_INT 1
14854: PPUSH
14855: CALL 107197 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14859: LD_ADDR_VAR 0 5
14863: PUSH
14864: LD_INT 7
14866: PPUSH
14867: LD_INT 0
14869: PPUSH
14870: CALL_OW 517
14874: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14875: LD_ADDR_VAR 0 2
14879: PUSH
14880: DOUBLE
14881: LD_INT 1
14883: DEC
14884: ST_TO_ADDR
14885: LD_VAR 0 5
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: PUSH
14894: FOR_TO
14895: IFFALSE 14940
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14897: LD_VAR 0 5
14901: PUSH
14902: LD_INT 1
14904: ARRAY
14905: PUSH
14906: LD_VAR 0 2
14910: ARRAY
14911: PPUSH
14912: LD_VAR 0 5
14916: PUSH
14917: LD_INT 2
14919: ARRAY
14920: PUSH
14921: LD_VAR 0 2
14925: ARRAY
14926: PPUSH
14927: LD_INT 1
14929: PPUSH
14930: LD_INT 15
14932: NEG
14933: PPUSH
14934: CALL 107111 0 4
14938: GO 14894
14940: POP
14941: POP
// CenterNowOnUnits ( Powell ) ;
14942: LD_EXP 57
14946: PPUSH
14947: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14951: LD_ADDR_VAR 0 5
14955: PUSH
14956: LD_EXP 55
14960: PUSH
14961: EMPTY
14962: LIST
14963: ST_TO_ADDR
// if GirlNewVeh then
14964: LD_EXP 56
14968: IFFALSE 14986
// tmp := tmp ^ GirlNewVeh ;
14970: LD_ADDR_VAR 0 5
14974: PUSH
14975: LD_VAR 0 5
14979: PUSH
14980: LD_EXP 56
14984: ADD
14985: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14986: LD_VAR 0 5
14990: PPUSH
14991: LD_INT 60
14993: PPUSH
14994: LD_INT 109
14996: PPUSH
14997: CALL_OW 111
// if KappaStatus then
15001: LD_EXP 2
15005: IFFALSE 15057
// begin Say ( JMM , D1nT-JMM-1 ) ;
15007: LD_EXP 38
15011: PPUSH
15012: LD_STRING D1nT-JMM-1
15014: PPUSH
15015: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15019: LD_EXP 57
15023: PPUSH
15024: LD_STRING D1T-Pow-1
15026: PPUSH
15027: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15031: LD_EXP 38
15035: PPUSH
15036: LD_STRING D1T-JMM-2
15038: PPUSH
15039: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15043: LD_EXP 57
15047: PPUSH
15048: LD_STRING D1T-Pow-2
15050: PPUSH
15051: CALL_OW 88
// end else
15055: GO 15263
// if JMMGirlStatus then
15057: LD_EXP 6
15061: IFFALSE 15206
// begin Say ( JMM , D1T-JMM-1 ) ;
15063: LD_EXP 38
15067: PPUSH
15068: LD_STRING D1T-JMM-1
15070: PPUSH
15071: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15075: LD_EXP 57
15079: PPUSH
15080: LD_STRING D1T-Pow-1
15082: PPUSH
15083: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15087: LD_EXP 38
15091: PPUSH
15092: LD_STRING D1T-JMM-3
15094: PPUSH
15095: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15099: LD_EXP 57
15103: PPUSH
15104: LD_STRING D1T-Pow-3
15106: PPUSH
15107: CALL_OW 88
// if JMMGirl then
15111: LD_EXP 7
15115: IFFALSE 15204
// begin case JMMGirl of 1 :
15117: LD_EXP 7
15121: PUSH
15122: LD_INT 1
15124: DOUBLE
15125: EQUAL
15126: IFTRUE 15130
15128: GO 15145
15130: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15131: LD_EXP 39
15135: PPUSH
15136: LD_STRING D1T-Joan-3
15138: PPUSH
15139: CALL_OW 88
15143: GO 15192
15145: LD_INT 2
15147: DOUBLE
15148: EQUAL
15149: IFTRUE 15153
15151: GO 15168
15153: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15154: LD_EXP 41
15158: PPUSH
15159: LD_STRING D1T-Lisa-3
15161: PPUSH
15162: CALL_OW 88
15166: GO 15192
15168: LD_INT 3
15170: DOUBLE
15171: EQUAL
15172: IFTRUE 15176
15174: GO 15191
15176: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15177: LD_EXP 53
15181: PPUSH
15182: LD_STRING D1T-Con-3
15184: PPUSH
15185: CALL_OW 88
15189: GO 15192
15191: POP
// Say ( Powell , D1T-Pow-4 ) ;
15192: LD_EXP 57
15196: PPUSH
15197: LD_STRING D1T-Pow-4
15199: PPUSH
15200: CALL_OW 88
// end ; end else
15204: GO 15263
// if not FastEnd then
15206: LD_EXP 11
15210: NOT
15211: IFFALSE 15239
// begin Say ( JMM , D1T-JMM-4 ) ;
15213: LD_EXP 38
15217: PPUSH
15218: LD_STRING D1T-JMM-4
15220: PPUSH
15221: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15225: LD_EXP 57
15229: PPUSH
15230: LD_STRING D1T-Pow-5
15232: PPUSH
15233: CALL_OW 88
// end else
15237: GO 15263
// begin Say ( JMM , D1nT-JMM-1 ) ;
15239: LD_EXP 38
15243: PPUSH
15244: LD_STRING D1nT-JMM-1
15246: PPUSH
15247: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15251: LD_EXP 57
15255: PPUSH
15256: LD_STRING D1nT-Pow-1
15258: PPUSH
15259: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15263: LD_INT 35
15265: PPUSH
15266: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15270: LD_EXP 55
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: IFFALSE 15263
// ComExitVehicle ( JMM ) ;
15282: LD_EXP 38
15286: PPUSH
15287: CALL_OW 121
// wait ( 3 ) ;
15291: LD_INT 3
15293: PPUSH
15294: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15298: LD_EXP 38
15302: PPUSH
15303: LD_INT 60
15305: PPUSH
15306: LD_INT 94
15308: PPUSH
15309: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15313: LD_EXP 38
15317: PPUSH
15318: LD_EXP 57
15322: PPUSH
15323: CALL_OW 179
// if Joan then
15327: LD_EXP 39
15331: IFFALSE 15385
// begin ComExitVehicle ( Joan ) ;
15333: LD_EXP 39
15337: PPUSH
15338: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15342: LD_EXP 39
15346: PPUSH
15347: LD_INT 35
15349: PPUSH
15350: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15354: LD_EXP 39
15358: PPUSH
15359: LD_INT 65
15361: PPUSH
15362: LD_INT 104
15364: PPUSH
15365: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_EXP 38
15378: PPUSH
15379: CALL_OW 179
// end else
15383: GO 15519
// if Lisa and JMMGirl = 2 then
15385: LD_EXP 41
15389: PUSH
15390: LD_EXP 7
15394: PUSH
15395: LD_INT 2
15397: EQUAL
15398: AND
15399: IFFALSE 15453
// begin ComExitVehicle ( Lisa ) ;
15401: LD_EXP 41
15405: PPUSH
15406: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15410: LD_EXP 41
15414: PPUSH
15415: LD_INT 35
15417: PPUSH
15418: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15422: LD_EXP 41
15426: PPUSH
15427: LD_INT 65
15429: PPUSH
15430: LD_INT 104
15432: PPUSH
15433: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15437: LD_EXP 41
15441: PPUSH
15442: LD_EXP 38
15446: PPUSH
15447: CALL_OW 179
// end else
15451: GO 15519
// if Connie and JMMGirl = 3 then
15453: LD_EXP 53
15457: PUSH
15458: LD_EXP 7
15462: PUSH
15463: LD_INT 3
15465: EQUAL
15466: AND
15467: IFFALSE 15519
// begin ComExitVehicle ( Connie ) ;
15469: LD_EXP 53
15473: PPUSH
15474: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15478: LD_EXP 53
15482: PPUSH
15483: LD_INT 35
15485: PPUSH
15486: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15490: LD_EXP 53
15494: PPUSH
15495: LD_INT 65
15497: PPUSH
15498: LD_INT 104
15500: PPUSH
15501: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15505: LD_EXP 53
15509: PPUSH
15510: LD_EXP 38
15514: PPUSH
15515: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15519: LD_INT 35
15521: PPUSH
15522: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15526: LD_EXP 38
15530: PPUSH
15531: LD_EXP 57
15535: PPUSH
15536: CALL_OW 296
15540: PUSH
15541: LD_INT 6
15543: LESS
15544: IFFALSE 15519
// wait ( 0 0$0.5 ) ;
15546: LD_INT 18
15548: PPUSH
15549: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15553: LD_EXP 38
15557: PPUSH
15558: LD_STRING D1-JMM-1
15560: PPUSH
15561: CALL_OW 88
// async ;
15565: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15566: LD_EXP 57
15570: PPUSH
15571: LD_STRING D1-Pow-1
15573: PPUSH
15574: CALL_OW 88
// if not dialogue_skipped then
15578: LD_OWVAR 59
15582: NOT
15583: IFFALSE 15592
// wait ( 0 0$2 ) ;
15585: LD_INT 70
15587: PPUSH
15588: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15592: LD_INT 170
15594: PPUSH
15595: LD_INT 99
15597: PPUSH
15598: LD_INT 1
15600: PPUSH
15601: LD_INT 6
15603: NEG
15604: PPUSH
15605: CALL 107111 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15609: LD_INT 174
15611: PPUSH
15612: LD_INT 115
15614: PPUSH
15615: LD_INT 1
15617: PPUSH
15618: LD_INT 6
15620: NEG
15621: PPUSH
15622: CALL 107111 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15626: LD_INT 169
15628: PPUSH
15629: LD_INT 71
15631: PPUSH
15632: LD_INT 1
15634: PPUSH
15635: LD_INT 6
15637: NEG
15638: PPUSH
15639: CALL 107111 0 4
// if not dialogue_skipped then
15643: LD_OWVAR 59
15647: NOT
15648: IFFALSE 15667
// begin CenterOnXY ( 170 , 99 ) ;
15650: LD_INT 170
15652: PPUSH
15653: LD_INT 99
15655: PPUSH
15656: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15660: LD_INT 80
15662: PPUSH
15663: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15667: LD_INT 75
15669: PPUSH
15670: LD_INT 53
15672: PPUSH
15673: LD_INT 1
15675: PPUSH
15676: LD_INT 9
15678: NEG
15679: PPUSH
15680: CALL 107111 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15684: LD_INT 54
15686: PPUSH
15687: LD_INT 42
15689: PPUSH
15690: LD_INT 1
15692: PPUSH
15693: LD_INT 9
15695: NEG
15696: PPUSH
15697: CALL 107111 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15701: LD_INT 62
15703: PPUSH
15704: LD_INT 51
15706: PPUSH
15707: LD_INT 1
15709: PPUSH
15710: LD_INT 9
15712: NEG
15713: PPUSH
15714: CALL 107111 0 4
// if not dialogue_skipped then
15718: LD_OWVAR 59
15722: NOT
15723: IFFALSE 15742
// begin CenterOnXY ( 75 , 53 ) ;
15725: LD_INT 75
15727: PPUSH
15728: LD_INT 53
15730: PPUSH
15731: CALL_OW 84
// wait ( 0 0$4 ) ;
15735: LD_INT 140
15737: PPUSH
15738: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15742: LD_EXP 57
15746: PPUSH
15747: CALL_OW 87
// if not dialogue_skipped then
15751: LD_OWVAR 59
15755: NOT
15756: IFFALSE 15765
// wait ( 0 0$2 ) ;
15758: LD_INT 70
15760: PPUSH
15761: CALL_OW 67
// sync ;
15765: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15766: LD_EXP 38
15770: PPUSH
15771: LD_STRING D1-JMM-2
15773: PPUSH
15774: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15778: LD_EXP 57
15782: PPUSH
15783: LD_STRING D1-Pow-2
15785: PPUSH
15786: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15790: LD_EXP 38
15794: PPUSH
15795: LD_STRING D1-JMM-3
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15802: LD_EXP 57
15806: PPUSH
15807: LD_STRING D1-Pow-3
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15814: LD_EXP 38
15818: PPUSH
15819: LD_STRING D1-JMM-4
15821: PPUSH
15822: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15826: LD_EXP 57
15830: PPUSH
15831: LD_STRING D1-Pow-4
15833: PPUSH
15834: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15838: LD_EXP 38
15842: PPUSH
15843: LD_STRING D1-JMM-5
15845: PPUSH
15846: CALL_OW 88
// async ;
15850: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15851: LD_EXP 57
15855: PPUSH
15856: LD_STRING D1-Pow-5
15858: PPUSH
15859: CALL_OW 88
// if not dialogue_skipped then
15863: LD_OWVAR 59
15867: NOT
15868: IFFALSE 15877
// wait ( 0 0$3.6 ) ;
15870: LD_INT 126
15872: PPUSH
15873: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15877: LD_INT 134
15879: PPUSH
15880: LD_INT 210
15882: PPUSH
15883: LD_INT 1
15885: PPUSH
15886: LD_INT 11
15888: NEG
15889: PPUSH
15890: CALL 107111 0 4
// if not dialogue_skipped then
15894: LD_OWVAR 59
15898: NOT
15899: IFFALSE 15918
// begin CenterOnXY ( 134 , 210 ) ;
15901: LD_INT 134
15903: PPUSH
15904: LD_INT 210
15906: PPUSH
15907: CALL_OW 84
// wait ( 0 0$2 ) ;
15911: LD_INT 70
15913: PPUSH
15914: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15918: LD_INT 101
15920: PPUSH
15921: LD_INT 159
15923: PPUSH
15924: LD_INT 1
15926: PPUSH
15927: LD_INT 10
15929: NEG
15930: PPUSH
15931: CALL 107111 0 4
// if not dialogue_skipped then
15935: LD_OWVAR 59
15939: NOT
15940: IFFALSE 15959
// begin CenterOnXY ( 101 , 159 ) ;
15942: LD_INT 101
15944: PPUSH
15945: LD_INT 159
15947: PPUSH
15948: CALL_OW 84
// wait ( 0 0$2 ) ;
15952: LD_INT 70
15954: PPUSH
15955: CALL_OW 67
// end ; sync ;
15959: SYNC
// CenterNowOnUnits ( Powell ) ;
15960: LD_EXP 57
15964: PPUSH
15965: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15969: LD_ADDR_VAR 0 6
15973: PUSH
15974: LD_INT 1
15976: PUSH
15977: LD_INT 2
15979: PUSH
15980: LD_INT 3
15982: PUSH
15983: LD_INT 4
15985: PUSH
15986: LD_INT 5
15988: PUSH
15989: LD_INT 6
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: ST_TO_ADDR
// if not dialogue_skipped then
16000: LD_OWVAR 59
16004: NOT
16005: IFFALSE 16174
// begin game_speed := 4 ;
16007: LD_ADDR_OWVAR 65
16011: PUSH
16012: LD_INT 4
16014: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16015: LD_INT 210
16017: PPUSH
16018: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16022: LD_ADDR_VAR 0 7
16026: PUSH
16027: LD_STRING Q1
16029: PPUSH
16030: LD_VAR 0 6
16034: PPUSH
16035: CALL_OW 98
16039: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16040: LD_ADDR_VAR 0 7
16044: PUSH
16045: LD_STRING Q1
16047: PPUSH
16048: LD_VAR 0 6
16052: PPUSH
16053: CALL_OW 98
16057: ST_TO_ADDR
// options = options diff dec ;
16058: LD_ADDR_VAR 0 6
16062: PUSH
16063: LD_VAR 0 6
16067: PUSH
16068: LD_VAR 0 7
16072: DIFF
16073: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16074: LD_VAR 0 7
16078: PPUSH
16079: LD_VAR 0 6
16083: PPUSH
16084: CALL 17646 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16088: LD_VAR 0 7
16092: PUSH
16093: LD_INT 5
16095: PUSH
16096: LD_INT 6
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: IN
16103: PUSH
16104: LD_VAR 0 6
16108: PUSH
16109: LD_INT 2
16111: EQUAL
16112: OR
16113: IFFALSE 16040
// if not ( dec in [ 5 , 6 ] ) then
16115: LD_VAR 0 7
16119: PUSH
16120: LD_INT 5
16122: PUSH
16123: LD_INT 6
16125: PUSH
16126: EMPTY
16127: LIST
16128: LIST
16129: IN
16130: NOT
16131: IFFALSE 16174
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16133: LD_ADDR_VAR 0 7
16137: PUSH
16138: LD_STRING Q1a
16140: PPUSH
16141: LD_INT 1
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 98
16155: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16156: LD_VAR 0 7
16160: PUSH
16161: LD_INT 4
16163: PLUS
16164: PPUSH
16165: LD_VAR 0 6
16169: PPUSH
16170: CALL 17646 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16174: LD_INT 81
16176: PPUSH
16177: LD_INT 127
16179: PPUSH
16180: CALL_OW 84
// amount := 5 ;
16184: LD_ADDR_VAR 0 8
16188: PUSH
16189: LD_INT 5
16191: ST_TO_ADDR
// macmilan_squad := [ ] ;
16192: LD_ADDR_VAR 0 9
16196: PUSH
16197: EMPTY
16198: ST_TO_ADDR
// if vip < amount then
16199: LD_EXP 58
16203: PUSH
16204: LD_VAR 0 8
16208: LESS
16209: IFFALSE 16253
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16211: LD_ADDR_VAR 0 5
16215: PUSH
16216: LD_EXP 58
16220: PUSH
16221: LD_INT 22
16223: PUSH
16224: LD_INT 4
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: LD_INT 21
16233: PUSH
16234: LD_INT 1
16236: PUSH
16237: EMPTY
16238: LIST
16239: LIST
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: PPUSH
16245: CALL_OW 69
16249: UNION
16250: ST_TO_ADDR
16251: GO 16263
// tmp := vip ;
16253: LD_ADDR_VAR 0 5
16257: PUSH
16258: LD_EXP 58
16262: ST_TO_ADDR
// tmp := tmp diff Powell ;
16263: LD_ADDR_VAR 0 5
16267: PUSH
16268: LD_VAR 0 5
16272: PUSH
16273: LD_EXP 57
16277: DIFF
16278: ST_TO_ADDR
// if tmp < amount then
16279: LD_VAR 0 5
16283: PUSH
16284: LD_VAR 0 8
16288: LESS
16289: IFFALSE 16301
// amount := tmp ;
16291: LD_ADDR_VAR 0 8
16295: PUSH
16296: LD_VAR 0 5
16300: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16301: LD_VAR 0 5
16305: PUSH
16306: LD_INT 1
16308: ARRAY
16309: PPUSH
16310: CALL_OW 257
16314: PUSH
16315: LD_INT 2
16317: NONEQUAL
16318: IFFALSE 16380
// begin if IsInUnit ( tmp [ 1 ] ) then
16320: LD_VAR 0 5
16324: PUSH
16325: LD_INT 1
16327: ARRAY
16328: PPUSH
16329: CALL_OW 310
16333: IFFALSE 16348
// ComExitBuilding ( tmp [ 1 ] ) ;
16335: LD_VAR 0 5
16339: PUSH
16340: LD_INT 1
16342: ARRAY
16343: PPUSH
16344: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16348: LD_VAR 0 5
16352: PUSH
16353: LD_INT 1
16355: ARRAY
16356: PPUSH
16357: LD_INT 387
16359: PPUSH
16360: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16364: LD_VAR 0 5
16368: PUSH
16369: LD_INT 1
16371: ARRAY
16372: PPUSH
16373: LD_INT 2
16375: PPUSH
16376: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16380: LD_EXP 38
16384: PPUSH
16385: LD_INT 82
16387: PPUSH
16388: LD_INT 129
16390: PPUSH
16391: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16395: LD_EXP 38
16399: PPUSH
16400: LD_EXP 57
16404: PPUSH
16405: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16409: LD_INT 22
16411: PUSH
16412: LD_INT 1
16414: PUSH
16415: EMPTY
16416: LIST
16417: LIST
16418: PPUSH
16419: CALL_OW 69
16423: PUSH
16424: LD_EXP 38
16428: DIFF
16429: PPUSH
16430: LD_INT 84
16432: PPUSH
16433: LD_INT 128
16435: PPUSH
16436: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16440: LD_INT 22
16442: PUSH
16443: LD_INT 1
16445: PUSH
16446: EMPTY
16447: LIST
16448: LIST
16449: PPUSH
16450: CALL_OW 69
16454: PUSH
16455: LD_EXP 38
16459: DIFF
16460: PPUSH
16461: LD_EXP 38
16465: PPUSH
16466: CALL_OW 179
// for i = 1 to amount do
16470: LD_ADDR_VAR 0 2
16474: PUSH
16475: DOUBLE
16476: LD_INT 1
16478: DEC
16479: ST_TO_ADDR
16480: LD_VAR 0 8
16484: PUSH
16485: FOR_TO
16486: IFFALSE 16654
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16488: LD_ADDR_VAR 0 9
16492: PUSH
16493: LD_VAR 0 9
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_VAR 0 2
16507: ARRAY
16508: ADD
16509: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16510: LD_VAR 0 5
16514: PUSH
16515: LD_VAR 0 2
16519: ARRAY
16520: PPUSH
16521: CALL_OW 310
16525: IFFALSE 16542
// AddComExitBuilding ( tmp [ i ] ) ;
16527: LD_VAR 0 5
16531: PUSH
16532: LD_VAR 0 2
16536: ARRAY
16537: PPUSH
16538: CALL_OW 182
// if i = 2 and JMMNewVeh then
16542: LD_VAR 0 2
16546: PUSH
16547: LD_INT 2
16549: EQUAL
16550: PUSH
16551: LD_EXP 55
16555: AND
16556: IFFALSE 16614
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16558: LD_VAR 0 5
16562: PUSH
16563: LD_VAR 0 2
16567: ARRAY
16568: PPUSH
16569: LD_EXP 55
16573: PPUSH
16574: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_VAR 0 2
16587: ARRAY
16588: PPUSH
16589: LD_INT 86
16591: PPUSH
16592: LD_INT 133
16594: PPUSH
16595: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16599: LD_VAR 0 5
16603: PUSH
16604: LD_VAR 0 2
16608: ARRAY
16609: PPUSH
16610: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16614: LD_VAR 0 5
16618: PUSH
16619: LD_VAR 0 2
16623: ARRAY
16624: PPUSH
16625: LD_INT 8
16627: PPUSH
16628: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16632: LD_VAR 0 5
16636: PUSH
16637: LD_VAR 0 2
16641: ARRAY
16642: PPUSH
16643: LD_EXP 38
16647: PPUSH
16648: CALL_OW 179
// end ;
16652: GO 16485
16654: POP
16655: POP
// if GirlNewVeh then
16656: LD_EXP 56
16660: IFFALSE 16674
// SetSide ( GirlNewVeh , 4 ) ;
16662: LD_EXP 56
16666: PPUSH
16667: LD_INT 4
16669: PPUSH
16670: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16674: LD_INT 35
16676: PPUSH
16677: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16681: LD_VAR 0 9
16685: PPUSH
16686: LD_INT 95
16688: PUSH
16689: LD_INT 9
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: PPUSH
16696: CALL_OW 72
16700: PUSH
16701: LD_INT 0
16703: EQUAL
16704: PUSH
16705: LD_EXP 38
16709: PPUSH
16710: LD_INT 9
16712: PPUSH
16713: CALL_OW 308
16717: NOT
16718: AND
16719: IFFALSE 16674
// wait ( 0 0$2 ) ;
16721: LD_INT 70
16723: PPUSH
16724: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16728: LD_VAR 0 9
16732: PPUSH
16733: LD_INT 1
16735: PPUSH
16736: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16740: LD_INT 21
16742: PUSH
16743: LD_INT 2
16745: PUSH
16746: EMPTY
16747: LIST
16748: LIST
16749: PUSH
16750: LD_INT 92
16752: PUSH
16753: LD_INT 83
16755: PUSH
16756: LD_INT 130
16758: PUSH
16759: LD_INT 10
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PPUSH
16772: CALL_OW 69
16776: PPUSH
16777: LD_INT 1
16779: PPUSH
16780: CALL_OW 235
// Video ( false ) ;
16784: LD_INT 0
16786: PPUSH
16787: CALL 107197 0 1
// ChangeMissionObjectives ( M1 ) ;
16791: LD_STRING M1
16793: PPUSH
16794: CALL_OW 337
// SaveForQuickRestart ;
16798: CALL_OW 22
// missionStart := true ;
16802: LD_ADDR_EXP 13
16806: PUSH
16807: LD_INT 1
16809: ST_TO_ADDR
// missionStage := 2 ;
16810: LD_ADDR_EXP 15
16814: PUSH
16815: LD_INT 2
16817: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16818: LD_INT 105
16820: PPUSH
16821: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16825: LD_ADDR_VAR 0 5
16829: PUSH
16830: LD_INT 22
16832: PUSH
16833: LD_INT 4
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 21
16842: PUSH
16843: LD_INT 1
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 69
16858: PUSH
16859: LD_EXP 57
16863: DIFF
16864: ST_TO_ADDR
// if not tmp then
16865: LD_VAR 0 5
16869: NOT
16870: IFFALSE 16885
// tmp := [ Powell ] ;
16872: LD_ADDR_VAR 0 5
16876: PUSH
16877: LD_EXP 57
16881: PUSH
16882: EMPTY
16883: LIST
16884: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16885: LD_ADDR_EXP 101
16889: PUSH
16890: LD_EXP 101
16894: PPUSH
16895: LD_INT 4
16897: PPUSH
16898: LD_INT 22
16900: PUSH
16901: LD_INT 4
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 23
16910: PUSH
16911: LD_INT 1
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 3
16920: PUSH
16921: LD_INT 21
16923: PUSH
16924: LD_INT 2
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: LIST
16939: PPUSH
16940: CALL_OW 69
16944: PUSH
16945: LD_EXP 57
16949: DIFF
16950: PPUSH
16951: CALL_OW 1
16955: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16956: LD_ADDR_VAR 0 4
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 4
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 34
16973: PUSH
16974: LD_INT 12
16976: PUSH
16977: EMPTY
16978: LIST
16979: LIST
16980: PUSH
16981: EMPTY
16982: LIST
16983: LIST
16984: PPUSH
16985: CALL_OW 69
16989: PUSH
16990: LD_INT 1
16992: ARRAY
16993: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16994: LD_VAR 0 5
16998: PUSH
16999: LD_INT 1
17001: ARRAY
17002: PPUSH
17003: CALL_OW 310
17007: IFFALSE 17022
// ComExitBuilding ( tmp [ 1 ] ) ;
17009: LD_VAR 0 5
17013: PUSH
17014: LD_INT 1
17016: ARRAY
17017: PPUSH
17018: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17022: LD_VAR 0 5
17026: PUSH
17027: LD_INT 1
17029: ARRAY
17030: PPUSH
17031: LD_VAR 0 4
17035: PPUSH
17036: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17040: LD_VAR 0 5
17044: PUSH
17045: LD_INT 1
17047: ARRAY
17048: PPUSH
17049: LD_INT 80
17051: PPUSH
17052: LD_INT 136
17054: PPUSH
17055: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17059: LD_VAR 0 5
17063: PUSH
17064: LD_INT 1
17066: ARRAY
17067: PPUSH
17068: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17072: LD_VAR 0 5
17076: PUSH
17077: LD_INT 1
17079: ARRAY
17080: PPUSH
17081: LD_INT 59
17083: PPUSH
17084: LD_INT 112
17086: PPUSH
17087: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17091: LD_VAR 0 5
17095: PUSH
17096: LD_INT 1
17098: ARRAY
17099: PPUSH
17100: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17104: LD_EXP 39
17108: PUSH
17109: LD_EXP 39
17113: PPUSH
17114: CALL_OW 255
17118: PUSH
17119: LD_INT 1
17121: EQUAL
17122: AND
17123: IFFALSE 17149
// begin Say ( Joan , D3W-Joan-1 ) ;
17125: LD_EXP 39
17129: PPUSH
17130: LD_STRING D3W-Joan-1
17132: PPUSH
17133: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17137: LD_EXP 38
17141: PPUSH
17142: LD_STRING D3W-JMM-1
17144: PPUSH
17145: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17149: LD_EXP 41
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: PUSH
17169: LD_EXP 41
17173: PUSH
17174: LD_EXP 58
17178: IN
17179: NOT
17180: AND
17181: IFFALSE 17207
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17183: LD_EXP 41
17187: PPUSH
17188: LD_STRING D3W-Lisa-1
17190: PPUSH
17191: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17195: LD_EXP 38
17199: PPUSH
17200: LD_STRING D3W-JMM-1
17202: PPUSH
17203: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17207: LD_EXP 53
17211: PUSH
17212: LD_EXP 53
17216: PPUSH
17217: CALL_OW 255
17221: PUSH
17222: LD_INT 1
17224: EQUAL
17225: AND
17226: IFFALSE 17252
// begin Say ( Connie , D3W-Con-1 ) ;
17228: LD_EXP 53
17232: PPUSH
17233: LD_STRING D3W-Con-1
17235: PPUSH
17236: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17240: LD_EXP 38
17244: PPUSH
17245: LD_STRING D3W-JMM-1
17247: PPUSH
17248: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17252: LD_EXP 41
17256: PUSH
17257: LD_EXP 58
17261: IN
17262: PUSH
17263: LD_EXP 41
17267: PPUSH
17268: CALL_OW 255
17272: PUSH
17273: LD_INT 1
17275: EQUAL
17276: AND
17277: IFFALSE 17293
// Say ( Lisa , D3nW-Lisa-1 ) else
17279: LD_EXP 41
17283: PPUSH
17284: LD_STRING D3nW-Lisa-1
17286: PPUSH
17287: CALL_OW 88
17291: GO 17537
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17293: LD_EXP 44
17297: PUSH
17298: LD_EXP 58
17302: IN
17303: PUSH
17304: LD_EXP 44
17308: PPUSH
17309: CALL_OW 255
17313: PUSH
17314: LD_INT 1
17316: EQUAL
17317: AND
17318: IFFALSE 17334
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17320: LD_EXP 44
17324: PPUSH
17325: LD_STRING D3nW-Cyrus-1
17327: PPUSH
17328: CALL_OW 88
17332: GO 17537
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17334: LD_EXP 43
17338: PUSH
17339: LD_EXP 58
17343: IN
17344: PUSH
17345: LD_EXP 43
17349: PPUSH
17350: CALL_OW 255
17354: PUSH
17355: LD_INT 1
17357: EQUAL
17358: AND
17359: IFFALSE 17375
// Say ( Bobby , D3nW-Bobby-1 ) else
17361: LD_EXP 43
17365: PPUSH
17366: LD_STRING D3nW-Bobby-1
17368: PPUSH
17369: CALL_OW 88
17373: GO 17537
// if Gary in vip and GetSide ( Gary ) = 1 then
17375: LD_EXP 50
17379: PUSH
17380: LD_EXP 58
17384: IN
17385: PUSH
17386: LD_EXP 50
17390: PPUSH
17391: CALL_OW 255
17395: PUSH
17396: LD_INT 1
17398: EQUAL
17399: AND
17400: IFFALSE 17416
// Say ( Gary , D3nW-Gary-1 ) else
17402: LD_EXP 50
17406: PPUSH
17407: LD_STRING D3nW-Gary-1
17409: PPUSH
17410: CALL_OW 88
17414: GO 17537
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17416: LD_EXP 42
17420: PUSH
17421: LD_EXP 58
17425: IN
17426: PUSH
17427: LD_EXP 42
17431: PPUSH
17432: CALL_OW 255
17436: PUSH
17437: LD_INT 1
17439: EQUAL
17440: AND
17441: IFFALSE 17457
// Say ( Donaldson , D3nW-Don-1 ) else
17443: LD_EXP 42
17447: PPUSH
17448: LD_STRING D3nW-Don-1
17450: PPUSH
17451: CALL_OW 88
17455: GO 17537
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17457: LD_EXP 49
17461: PUSH
17462: LD_EXP 58
17466: IN
17467: PUSH
17468: LD_EXP 49
17472: PPUSH
17473: CALL_OW 255
17477: PUSH
17478: LD_INT 1
17480: EQUAL
17481: AND
17482: IFFALSE 17498
// Say ( Cornel , D3nW-Corn-1 ) else
17484: LD_EXP 49
17488: PPUSH
17489: LD_STRING D3nW-Corn-1
17491: PPUSH
17492: CALL_OW 88
17496: GO 17537
// if Frank in vip and GetSide ( Frank ) = 1 then
17498: LD_EXP 51
17502: PUSH
17503: LD_EXP 58
17507: IN
17508: PUSH
17509: LD_EXP 51
17513: PPUSH
17514: CALL_OW 255
17518: PUSH
17519: LD_INT 1
17521: EQUAL
17522: AND
17523: IFFALSE 17537
// Say ( Frank , D3nW-Frank-1 ) ;
17525: LD_EXP 51
17529: PPUSH
17530: LD_STRING D3nW-Frank-1
17532: PPUSH
17533: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17537: LD_EXP 58
17541: PPUSH
17542: LD_INT 22
17544: PUSH
17545: LD_INT 1
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PPUSH
17552: CALL_OW 72
17556: IFFALSE 17582
// begin Say ( JMM , D3nW-JMM-1 ) ;
17558: LD_EXP 38
17562: PPUSH
17563: LD_STRING D3nW-JMM-1
17565: PPUSH
17566: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17570: LD_EXP 38
17574: PPUSH
17575: LD_STRING D3nW-JMM-1a
17577: PPUSH
17578: CALL_OW 88
// end ; t := 0 0$00 ;
17582: LD_ADDR_VAR 0 3
17586: PUSH
17587: LD_INT 0
17589: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17590: LD_INT 35
17592: PPUSH
17593: CALL_OW 67
// t := t + 0 0$1 ;
17597: LD_ADDR_VAR 0 3
17601: PUSH
17602: LD_VAR 0 3
17606: PUSH
17607: LD_INT 35
17609: PLUS
17610: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17611: LD_INT 59
17613: PPUSH
17614: LD_INT 112
17616: PPUSH
17617: CALL_OW 428
17621: PUSH
17622: LD_VAR 0 3
17626: PUSH
17627: LD_INT 2100
17629: GREATER
17630: OR
17631: IFFALSE 17590
// activeAttacks := true ;
17633: LD_ADDR_EXP 16
17637: PUSH
17638: LD_INT 1
17640: ST_TO_ADDR
// end ;
17641: LD_VAR 0 1
17645: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17646: LD_INT 0
17648: PPUSH
// case question of 1 :
17649: LD_VAR 0 1
17653: PUSH
17654: LD_INT 1
17656: DOUBLE
17657: EQUAL
17658: IFTRUE 17662
17660: GO 17713
17662: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17663: LD_EXP 38
17667: PPUSH
17668: LD_STRING D2Mot-JMM-1
17670: PPUSH
17671: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17675: LD_EXP 57
17679: PPUSH
17680: LD_STRING D2Mot-Pow-1
17682: PPUSH
17683: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17687: LD_EXP 38
17691: PPUSH
17692: LD_STRING D2Mot-JMM-2
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17699: LD_EXP 57
17703: PPUSH
17704: LD_STRING D2Mot-Pow-2
17706: PPUSH
17707: CALL_OW 88
// end ; 2 :
17711: GO 18064
17713: LD_INT 2
17715: DOUBLE
17716: EQUAL
17717: IFTRUE 17721
17719: GO 17797
17721: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17722: LD_EXP 38
17726: PPUSH
17727: LD_STRING D2Rus-JMM-1
17729: PPUSH
17730: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17734: LD_EXP 57
17738: PPUSH
17739: LD_STRING D2Rus-Pow-1
17741: PPUSH
17742: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17746: LD_EXP 38
17750: PPUSH
17751: LD_STRING D2Rus-JMM-2
17753: PPUSH
17754: CALL_OW 88
// if not ( 3 in list_of_q ) then
17758: LD_INT 3
17760: PUSH
17761: LD_VAR 0 2
17765: IN
17766: NOT
17767: IFFALSE 17783
// Say ( Powell , D2Rus-Pow-2 ) else
17769: LD_EXP 57
17773: PPUSH
17774: LD_STRING D2Rus-Pow-2
17776: PPUSH
17777: CALL_OW 88
17781: GO 17795
// Say ( Powell , D2Rus-Pow-2a ) ;
17783: LD_EXP 57
17787: PPUSH
17788: LD_STRING D2Rus-Pow-2a
17790: PPUSH
17791: CALL_OW 88
// end ; 3 :
17795: GO 18064
17797: LD_INT 3
17799: DOUBLE
17800: EQUAL
17801: IFTRUE 17805
17803: GO 17890
17805: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17806: LD_EXP 38
17810: PPUSH
17811: LD_STRING D2Leg-JMM-1
17813: PPUSH
17814: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17818: LD_EXP 57
17822: PPUSH
17823: LD_STRING D2Leg-Pow-1
17825: PPUSH
17826: CALL_OW 88
// if 2 in list_of_q then
17830: LD_INT 2
17832: PUSH
17833: LD_VAR 0 2
17837: IN
17838: IFFALSE 17864
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17840: LD_EXP 38
17844: PPUSH
17845: LD_STRING D2Leg-JMM-2
17847: PPUSH
17848: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17852: LD_EXP 57
17856: PPUSH
17857: LD_STRING D2Leg-Pow-2
17859: PPUSH
17860: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17864: LD_EXP 38
17868: PPUSH
17869: LD_STRING D2Leg-JMM-3
17871: PPUSH
17872: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17876: LD_EXP 57
17880: PPUSH
17881: LD_STRING D2Leg-Pow-3
17883: PPUSH
17884: CALL_OW 88
// end ; 4 :
17888: GO 18064
17890: LD_INT 4
17892: DOUBLE
17893: EQUAL
17894: IFTRUE 17898
17896: GO 17973
17898: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17899: LD_EXP 38
17903: PPUSH
17904: LD_STRING D2Ar-JMM-1
17906: PPUSH
17907: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17911: LD_EXP 57
17915: PPUSH
17916: LD_STRING D2Ar-Pow-1
17918: PPUSH
17919: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17923: LD_EXP 38
17927: PPUSH
17928: LD_STRING D2Ar-JMM-2
17930: PPUSH
17931: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17935: LD_EXP 57
17939: PPUSH
17940: LD_STRING D2Ar-Pow-2
17942: PPUSH
17943: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17947: LD_EXP 38
17951: PPUSH
17952: LD_STRING D2Ar-JMM-3
17954: PPUSH
17955: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17959: LD_EXP 57
17963: PPUSH
17964: LD_STRING D2Ar-Pow-3
17966: PPUSH
17967: CALL_OW 88
// end ; 5 :
17971: GO 18064
17973: LD_INT 5
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17996
17981: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17982: LD_EXP 38
17986: PPUSH
17987: LD_STRING D2Conf-JMM-1
17989: PPUSH
17990: CALL_OW 88
17994: GO 18064
17996: LD_INT 6
17998: DOUBLE
17999: EQUAL
18000: IFTRUE 18004
18002: GO 18063
18004: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18005: LD_EXP 38
18009: PPUSH
18010: LD_STRING D2Com-JMM-1
18012: PPUSH
18013: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18017: LD_EXP 57
18021: PPUSH
18022: LD_STRING D2Com-Pow-1
18024: PPUSH
18025: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18029: LD_EXP 38
18033: PPUSH
18034: LD_STRING D2Com-JMM-2
18036: PPUSH
18037: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18041: LD_EXP 57
18045: PPUSH
18046: LD_STRING D2Com-Pow-2
18048: PPUSH
18049: CALL_OW 88
// powellAngerQuery := true ;
18053: LD_ADDR_EXP 36
18057: PUSH
18058: LD_INT 1
18060: ST_TO_ADDR
// end ; end ;
18061: GO 18064
18063: POP
// end ;
18064: LD_VAR 0 3
18068: RET
// every 0 0$5 trigger missionStart do var tmp ;
18069: LD_EXP 13
18073: IFFALSE 18356
18075: GO 18077
18077: DISABLE
18078: LD_INT 0
18080: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18081: LD_INT 35
18083: PPUSH
18084: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18088: LD_INT 14
18090: PPUSH
18091: LD_INT 22
18093: PUSH
18094: LD_INT 1
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: PPUSH
18101: CALL_OW 70
18105: PUSH
18106: LD_EXP 15
18110: PUSH
18111: LD_INT 2
18113: PUSH
18114: LD_INT 3
18116: PUSH
18117: LD_INT 4
18119: PUSH
18120: LD_INT 5
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: IN
18129: AND
18130: IFFALSE 18346
// begin powellAnger := powellAnger + 1 ;
18132: LD_ADDR_EXP 17
18136: PUSH
18137: LD_EXP 17
18141: PUSH
18142: LD_INT 1
18144: PLUS
18145: ST_TO_ADDR
// Video ( true ) ;
18146: LD_INT 1
18148: PPUSH
18149: CALL 107197 0 1
// CenterNowOnUnits ( tmp ) ;
18153: LD_VAR 0 1
18157: PPUSH
18158: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18162: LD_INT 14
18164: PPUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PPUSH
18175: CALL_OW 70
18179: PPUSH
18180: LD_INT 86
18182: PPUSH
18183: LD_INT 133
18185: PPUSH
18186: CALL_OW 111
// async ;
18190: ASYNC
// case powellAnger of 1 :
18191: LD_EXP 17
18195: PUSH
18196: LD_INT 1
18198: DOUBLE
18199: EQUAL
18200: IFTRUE 18204
18202: GO 18219
18204: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18205: LD_EXP 57
18209: PPUSH
18210: LD_STRING DBack1-Pow-1
18212: PPUSH
18213: CALL_OW 88
18217: GO 18266
18219: LD_INT 2
18221: DOUBLE
18222: EQUAL
18223: IFTRUE 18227
18225: GO 18242
18227: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18228: LD_EXP 57
18232: PPUSH
18233: LD_STRING DBack2-Pow-1
18235: PPUSH
18236: CALL_OW 88
18240: GO 18266
18242: LD_INT 3
18244: DOUBLE
18245: EQUAL
18246: IFTRUE 18250
18248: GO 18265
18250: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18251: LD_EXP 57
18255: PPUSH
18256: LD_STRING DBack3-Pow-1
18258: PPUSH
18259: CALL_OW 88
18263: GO 18266
18265: POP
// sync ;
18266: SYNC
// repeat wait ( 0 0$1 ) ;
18267: LD_INT 35
18269: PPUSH
18270: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18274: LD_INT 14
18276: PPUSH
18277: LD_INT 22
18279: PUSH
18280: LD_INT 1
18282: PUSH
18283: EMPTY
18284: LIST
18285: LIST
18286: PPUSH
18287: CALL_OW 70
18291: PPUSH
18292: LD_INT 86
18294: PPUSH
18295: LD_INT 133
18297: PPUSH
18298: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18302: LD_INT 14
18304: PPUSH
18305: LD_INT 22
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PPUSH
18315: CALL_OW 70
18319: NOT
18320: IFFALSE 18267
// if powellAnger >= 3 then
18322: LD_EXP 17
18326: PUSH
18327: LD_INT 3
18329: GREATEREQUAL
18330: IFFALSE 18339
// YouLost ( Dismissed ) ;
18332: LD_STRING Dismissed
18334: PPUSH
18335: CALL_OW 104
// Video ( false ) ;
18339: LD_INT 0
18341: PPUSH
18342: CALL 107197 0 1
// end ; until missionStage > 5 ;
18346: LD_EXP 15
18350: PUSH
18351: LD_INT 5
18353: GREATER
18354: IFFALSE 18081
// end ;
18356: PPOPN 1
18358: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18359: LD_EXP 13
18363: PUSH
18364: LD_INT 22
18366: PUSH
18367: LD_INT 4
18369: PUSH
18370: EMPTY
18371: LIST
18372: LIST
18373: PUSH
18374: LD_INT 21
18376: PUSH
18377: LD_INT 2
18379: PUSH
18380: EMPTY
18381: LIST
18382: LIST
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: PPUSH
18388: CALL_OW 69
18392: PUSH
18393: LD_INT 4
18395: GREATEREQUAL
18396: AND
18397: PUSH
18398: LD_EXP 15
18402: PUSH
18403: LD_INT 2
18405: EQUAL
18406: AND
18407: IFFALSE 20230
18409: GO 18411
18411: DISABLE
18412: LD_INT 0
18414: PPUSH
18415: PPUSH
18416: PPUSH
18417: PPUSH
18418: PPUSH
18419: PPUSH
18420: PPUSH
18421: PPUSH
// begin missionStage := 3 ;
18422: LD_ADDR_EXP 15
18426: PUSH
18427: LD_INT 3
18429: ST_TO_ADDR
// retreat := false ;
18430: LD_ADDR_VAR 0 4
18434: PUSH
18435: LD_INT 0
18437: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18438: LD_ADDR_VAR 0 5
18442: PUSH
18443: LD_INT 22
18445: PUSH
18446: LD_INT 4
18448: PUSH
18449: EMPTY
18450: LIST
18451: LIST
18452: PUSH
18453: LD_INT 30
18455: PUSH
18456: LD_INT 4
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PPUSH
18467: CALL_OW 69
18471: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18472: LD_ADDR_VAR 0 6
18476: PUSH
18477: LD_INT 22
18479: PUSH
18480: LD_INT 4
18482: PUSH
18483: EMPTY
18484: LIST
18485: LIST
18486: PUSH
18487: LD_INT 30
18489: PUSH
18490: LD_INT 5
18492: PUSH
18493: EMPTY
18494: LIST
18495: LIST
18496: PUSH
18497: EMPTY
18498: LIST
18499: LIST
18500: PPUSH
18501: CALL_OW 69
18505: ST_TO_ADDR
// if not bar then
18506: LD_VAR 0 6
18510: NOT
18511: IFFALSE 18564
// begin repeat wait ( 0 0$1 ) ;
18513: LD_INT 35
18515: PPUSH
18516: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18520: LD_INT 22
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 3
18532: PUSH
18533: LD_INT 57
18535: PUSH
18536: EMPTY
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PUSH
18543: LD_INT 30
18545: PUSH
18546: LD_INT 5
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: LIST
18557: PPUSH
18558: CALL_OW 69
18562: IFFALSE 18513
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18564: LD_ADDR_VAR 0 6
18568: PUSH
18569: LD_INT 22
18571: PUSH
18572: LD_INT 4
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: PUSH
18579: LD_INT 30
18581: PUSH
18582: LD_INT 5
18584: PUSH
18585: EMPTY
18586: LIST
18587: LIST
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PPUSH
18593: CALL_OW 69
18597: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18598: LD_INT 35
18600: PPUSH
18601: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18605: LD_EXP 120
18609: PUSH
18610: LD_INT 4
18612: ARRAY
18613: PUSH
18614: LD_INT 4
18616: GREATEREQUAL
18617: IFFALSE 18598
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18619: LD_ADDR_VAR 0 2
18623: PUSH
18624: LD_INT 22
18626: PUSH
18627: LD_INT 4
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: PUSH
18634: LD_INT 2
18636: PUSH
18637: LD_INT 25
18639: PUSH
18640: LD_INT 1
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 25
18649: PUSH
18650: LD_INT 2
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: LD_INT 25
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 25
18669: PUSH
18670: LD_INT 4
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: PUSH
18677: LD_INT 25
18679: PUSH
18680: LD_INT 5
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: LIST
18691: LIST
18692: LIST
18693: LIST
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PPUSH
18699: CALL_OW 69
18703: PUSH
18704: LD_EXP 57
18708: PUSH
18709: LD_EXP 58
18713: ADD
18714: DIFF
18715: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18716: LD_ADDR_VAR 0 3
18720: PUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_INT 26
18728: PUSH
18729: LD_INT 1
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: PPUSH
18736: CALL_OW 72
18740: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18741: LD_ADDR_VAR 0 2
18745: PUSH
18746: LD_VAR 0 2
18750: PUSH
18751: LD_VAR 0 3
18755: DIFF
18756: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18757: LD_ADDR_VAR 0 2
18761: PUSH
18762: LD_VAR 0 2
18766: PPUSH
18767: LD_INT 1
18769: PPUSH
18770: CALL 105850 0 2
18774: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_VAR 0 3
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL 105850 0 2
18792: ST_TO_ADDR
// for i = 1 to 4 do
18793: LD_ADDR_VAR 0 1
18797: PUSH
18798: DOUBLE
18799: LD_INT 1
18801: DEC
18802: ST_TO_ADDR
18803: LD_INT 4
18805: PUSH
18806: FOR_TO
18807: IFFALSE 18973
// begin if tmp2 then
18809: LD_VAR 0 3
18813: IFFALSE 18894
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18815: LD_ADDR_EXP 18
18819: PUSH
18820: LD_EXP 18
18824: PPUSH
18825: LD_INT 1
18827: PPUSH
18828: LD_EXP 18
18832: PUSH
18833: LD_INT 1
18835: ARRAY
18836: PUSH
18837: LD_VAR 0 3
18841: PUSH
18842: LD_VAR 0 3
18846: ARRAY
18847: ADD
18848: PPUSH
18849: CALL_OW 1
18853: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18854: LD_VAR 0 3
18858: PUSH
18859: LD_VAR 0 3
18863: ARRAY
18864: PPUSH
18865: LD_INT 1
18867: PPUSH
18868: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18872: LD_ADDR_VAR 0 3
18876: PUSH
18877: LD_VAR 0 3
18881: PPUSH
18882: LD_VAR 0 3
18886: PPUSH
18887: CALL_OW 3
18891: ST_TO_ADDR
// end else
18892: GO 18971
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18894: LD_ADDR_EXP 18
18898: PUSH
18899: LD_EXP 18
18903: PPUSH
18904: LD_INT 1
18906: PPUSH
18907: LD_EXP 18
18911: PUSH
18912: LD_INT 1
18914: ARRAY
18915: PUSH
18916: LD_VAR 0 2
18920: PUSH
18921: LD_VAR 0 2
18925: ARRAY
18926: ADD
18927: PPUSH
18928: CALL_OW 1
18932: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18933: LD_VAR 0 2
18937: PUSH
18938: LD_VAR 0 2
18942: ARRAY
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18951: LD_ADDR_VAR 0 2
18955: PUSH
18956: LD_VAR 0 2
18960: PPUSH
18961: LD_VAR 0 2
18965: PPUSH
18966: CALL_OW 3
18970: ST_TO_ADDR
// end ; end ;
18971: GO 18806
18973: POP
18974: POP
// if tmp2 then
18975: LD_VAR 0 3
18979: IFFALSE 18997
// tmp := tmp union tmp2 ;
18981: LD_ADDR_VAR 0 2
18985: PUSH
18986: LD_VAR 0 2
18990: PUSH
18991: LD_VAR 0 3
18995: UNION
18996: ST_TO_ADDR
// for i = 1 to 4 do
18997: LD_ADDR_VAR 0 1
19001: PUSH
19002: DOUBLE
19003: LD_INT 1
19005: DEC
19006: ST_TO_ADDR
19007: LD_INT 4
19009: PUSH
19010: FOR_TO
19011: IFFALSE 19060
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19013: LD_ADDR_EXP 18
19017: PUSH
19018: LD_EXP 18
19022: PPUSH
19023: LD_INT 2
19025: PPUSH
19026: LD_EXP 18
19030: PUSH
19031: LD_INT 2
19033: ARRAY
19034: PUSH
19035: LD_VAR 0 2
19039: PUSH
19040: LD_VAR 0 2
19044: PUSH
19045: LD_VAR 0 1
19049: MINUS
19050: ARRAY
19051: ADD
19052: PPUSH
19053: CALL_OW 1
19057: ST_TO_ADDR
19058: GO 19010
19060: POP
19061: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19062: LD_ADDR_EXP 101
19066: PUSH
19067: LD_EXP 101
19071: PPUSH
19072: LD_INT 4
19074: PPUSH
19075: LD_EXP 101
19079: PUSH
19080: LD_INT 4
19082: ARRAY
19083: PUSH
19084: LD_EXP 18
19088: PUSH
19089: LD_INT 1
19091: ARRAY
19092: DIFF
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19099: LD_VAR 0 5
19103: PUSH
19104: LD_INT 1
19106: ARRAY
19107: PPUSH
19108: CALL_OW 313
19112: IFFALSE 19167
// begin for i in UnitsInside ( arm [ 1 ] ) do
19114: LD_ADDR_VAR 0 1
19118: PUSH
19119: LD_VAR 0 5
19123: PUSH
19124: LD_INT 1
19126: ARRAY
19127: PPUSH
19128: CALL_OW 313
19132: PUSH
19133: FOR_IN
19134: IFFALSE 19165
// begin ComExitBuilding ( i ) ;
19136: LD_VAR 0 1
19140: PPUSH
19141: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19145: LD_VAR 0 1
19149: PPUSH
19150: LD_VAR 0 6
19154: PUSH
19155: LD_INT 1
19157: ARRAY
19158: PPUSH
19159: CALL_OW 180
// end ;
19163: GO 19133
19165: POP
19166: POP
// end ; wait ( 0 0$3 ) ;
19167: LD_INT 105
19169: PPUSH
19170: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19174: LD_ADDR_VAR 0 1
19178: PUSH
19179: LD_EXP 18
19183: PUSH
19184: LD_INT 1
19186: ARRAY
19187: PUSH
19188: FOR_IN
19189: IFFALSE 19296
// begin if IsInUnit ( i ) then
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 310
19200: IFFALSE 19211
// ComExitBuilding ( i ) ;
19202: LD_VAR 0 1
19206: PPUSH
19207: CALL_OW 122
// if GetClass ( i ) <> 1 then
19211: LD_VAR 0 1
19215: PPUSH
19216: CALL_OW 257
19220: PUSH
19221: LD_INT 1
19223: NONEQUAL
19224: IFFALSE 19265
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19226: LD_VAR 0 1
19230: PPUSH
19231: LD_VAR 0 5
19235: PUSH
19236: LD_INT 1
19238: ARRAY
19239: PPUSH
19240: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19244: LD_VAR 0 1
19248: PPUSH
19249: LD_INT 1
19251: PPUSH
19252: CALL_OW 183
// AddComExitBuilding ( i ) ;
19256: LD_VAR 0 1
19260: PPUSH
19261: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19265: LD_VAR 0 1
19269: PPUSH
19270: LD_INT 60
19272: PPUSH
19273: LD_INT 94
19275: PPUSH
19276: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19280: LD_VAR 0 1
19284: PPUSH
19285: LD_EXP 57
19289: PPUSH
19290: CALL_OW 179
// end ;
19294: GO 19188
19296: POP
19297: POP
// wait ( 0 0$15 ) ;
19298: LD_INT 525
19300: PPUSH
19301: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19305: LD_EXP 57
19309: PPUSH
19310: LD_STRING D4-Pow-1
19312: PPUSH
19313: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19317: LD_ADDR_VAR 0 2
19321: PUSH
19322: LD_EXP 18
19326: PUSH
19327: LD_INT 1
19329: ARRAY
19330: PPUSH
19331: LD_INT 26
19333: PUSH
19334: LD_INT 1
19336: PUSH
19337: EMPTY
19338: LIST
19339: LIST
19340: PPUSH
19341: CALL_OW 72
19345: ST_TO_ADDR
// if tmp then
19346: LD_VAR 0 2
19350: IFFALSE 19368
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19352: LD_VAR 0 2
19356: PUSH
19357: LD_INT 1
19359: ARRAY
19360: PPUSH
19361: LD_STRING D4-Sol1-1
19363: PPUSH
19364: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19368: LD_EXP 57
19372: PPUSH
19373: LD_STRING D4-Pow-2
19375: PPUSH
19376: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19380: LD_ADDR_VAR 0 1
19384: PUSH
19385: DOUBLE
19386: LD_INT 1
19388: DEC
19389: ST_TO_ADDR
19390: LD_EXP 18
19394: PUSH
19395: LD_INT 1
19397: ARRAY
19398: PUSH
19399: FOR_TO
19400: IFFALSE 19493
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19402: LD_EXP 18
19406: PUSH
19407: LD_INT 1
19409: ARRAY
19410: PUSH
19411: LD_VAR 0 1
19415: ARRAY
19416: PPUSH
19417: LD_EXP 120
19421: PUSH
19422: LD_INT 4
19424: ARRAY
19425: PUSH
19426: LD_INT 1
19428: ARRAY
19429: PPUSH
19430: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19434: LD_ADDR_EXP 120
19438: PUSH
19439: LD_EXP 120
19443: PPUSH
19444: LD_INT 4
19446: PPUSH
19447: LD_EXP 120
19451: PUSH
19452: LD_INT 4
19454: ARRAY
19455: PPUSH
19456: LD_INT 1
19458: PPUSH
19459: CALL_OW 3
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19469: LD_INT 8
19471: PPUSH
19472: LD_EXP 18
19476: PUSH
19477: LD_INT 1
19479: ARRAY
19480: PUSH
19481: LD_VAR 0 1
19485: ARRAY
19486: PPUSH
19487: CALL_OW 471
// end ;
19491: GO 19399
19493: POP
19494: POP
// repeat wait ( 0 0$1 ) ;
19495: LD_INT 35
19497: PPUSH
19498: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19502: LD_EXP 18
19506: PUSH
19507: LD_INT 1
19509: ARRAY
19510: PPUSH
19511: LD_INT 55
19513: PUSH
19514: EMPTY
19515: LIST
19516: PPUSH
19517: CALL_OW 72
19521: PUSH
19522: LD_INT 4
19524: GREATEREQUAL
19525: IFFALSE 19495
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19527: LD_EXP 18
19531: PUSH
19532: LD_INT 1
19534: ARRAY
19535: PPUSH
19536: LD_INT 69
19538: PPUSH
19539: LD_INT 94
19541: PPUSH
19542: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19546: LD_EXP 18
19550: PUSH
19551: LD_INT 1
19553: ARRAY
19554: PPUSH
19555: LD_INT 82
19557: PPUSH
19558: LD_INT 83
19560: PPUSH
19561: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PPUSH
19574: LD_INT 77
19576: PPUSH
19577: LD_INT 69
19579: PPUSH
19580: CALL_OW 174
// repeat wait ( 3 ) ;
19584: LD_INT 3
19586: PPUSH
19587: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19591: LD_ADDR_VAR 0 1
19595: PUSH
19596: LD_EXP 18
19600: PUSH
19601: LD_INT 1
19603: ARRAY
19604: PUSH
19605: FOR_IN
19606: IFFALSE 19742
// begin if GetLives ( i ) < 990 then
19608: LD_VAR 0 1
19612: PPUSH
19613: CALL_OW 256
19617: PUSH
19618: LD_INT 990
19620: LESS
19621: IFFALSE 19635
// SetLives ( i , 1000 ) ;
19623: LD_VAR 0 1
19627: PPUSH
19628: LD_INT 1000
19630: PPUSH
19631: CALL_OW 234
// if not IsInUnit ( i ) then
19635: LD_VAR 0 1
19639: PPUSH
19640: CALL_OW 310
19644: NOT
19645: IFFALSE 19740
// begin if not HasTask ( i ) then
19647: LD_VAR 0 1
19651: PPUSH
19652: CALL_OW 314
19656: NOT
19657: IFFALSE 19674
// ComMoveXY ( i , 64 , 93 ) ;
19659: LD_VAR 0 1
19663: PPUSH
19664: LD_INT 64
19666: PPUSH
19667: LD_INT 93
19669: PPUSH
19670: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19674: LD_VAR 0 4
19678: NOT
19679: PUSH
19680: LD_VAR 0 1
19684: PPUSH
19685: CALL_OW 258
19689: PUSH
19690: LD_INT 1
19692: EQUAL
19693: AND
19694: IFFALSE 19740
// begin retreat := true ;
19696: LD_ADDR_VAR 0 4
19700: PUSH
19701: LD_INT 1
19703: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19704: LD_VAR 0 1
19708: PPUSH
19709: LD_INT 2
19711: PPUSH
19712: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19716: LD_VAR 0 1
19720: PPUSH
19721: LD_STRING D4a-Sol1-1
19723: PPUSH
19724: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19728: LD_EXP 57
19732: PPUSH
19733: LD_STRING D4a-Pow-1
19735: PPUSH
19736: CALL_OW 88
// end ; end ; end ;
19740: GO 19605
19742: POP
19743: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19744: LD_EXP 18
19748: PUSH
19749: LD_INT 1
19751: ARRAY
19752: PPUSH
19753: LD_INT 95
19755: PUSH
19756: LD_INT 9
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: LD_INT 55
19768: PUSH
19769: EMPTY
19770: LIST
19771: PUSH
19772: EMPTY
19773: LIST
19774: LIST
19775: PUSH
19776: EMPTY
19777: LIST
19778: LIST
19779: PPUSH
19780: CALL_OW 72
19784: PUSH
19785: LD_INT 4
19787: GREATEREQUAL
19788: IFFALSE 19584
// for i in powellSquadAttack [ 1 ] do
19790: LD_ADDR_VAR 0 1
19794: PUSH
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PUSH
19804: FOR_IN
19805: IFFALSE 19941
// begin if GetTag ( i ) = 2 then
19807: LD_VAR 0 1
19811: PPUSH
19812: CALL_OW 110
19816: PUSH
19817: LD_INT 2
19819: EQUAL
19820: IFFALSE 19882
// begin ComMoveXY ( i , 60 , 94 ) ;
19822: LD_VAR 0 1
19826: PPUSH
19827: LD_INT 60
19829: PPUSH
19830: LD_INT 94
19832: PPUSH
19833: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19837: LD_VAR 0 1
19841: PPUSH
19842: LD_EXP 57
19846: PPUSH
19847: CALL_OW 179
// wait ( 0 0$3 ) ;
19851: LD_INT 105
19853: PPUSH
19854: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19858: LD_VAR 0 1
19862: PPUSH
19863: LD_STRING D4a-Sol1-2
19865: PPUSH
19866: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19870: LD_EXP 57
19874: PPUSH
19875: LD_STRING D4a-Pow-2
19877: PPUSH
19878: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19882: LD_VAR 0 1
19886: PPUSH
19887: LD_INT 0
19889: PPUSH
19890: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19894: LD_ADDR_EXP 101
19898: PUSH
19899: LD_EXP 101
19903: PPUSH
19904: LD_INT 4
19906: PPUSH
19907: LD_EXP 101
19911: PUSH
19912: LD_INT 4
19914: ARRAY
19915: PUSH
19916: LD_VAR 0 1
19920: UNION
19921: PPUSH
19922: CALL_OW 1
19926: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19927: LD_INT 8
19929: PPUSH
19930: LD_VAR 0 1
19934: PPUSH
19935: CALL_OW 472
// end ;
19939: GO 19804
19941: POP
19942: POP
// wait ( 4 4$00 ) ;
19943: LD_INT 8400
19945: PPUSH
19946: CALL_OW 67
// uc_side := 6 ;
19950: LD_ADDR_OWVAR 20
19954: PUSH
19955: LD_INT 6
19957: ST_TO_ADDR
// uc_nation := 3 ;
19958: LD_ADDR_OWVAR 21
19962: PUSH
19963: LD_INT 3
19965: ST_TO_ADDR
// ru := [ ] ;
19966: LD_ADDR_VAR 0 7
19970: PUSH
19971: EMPTY
19972: ST_TO_ADDR
// for i = 1 to 4 do
19973: LD_ADDR_VAR 0 1
19977: PUSH
19978: DOUBLE
19979: LD_INT 1
19981: DEC
19982: ST_TO_ADDR
19983: LD_INT 4
19985: PUSH
19986: FOR_TO
19987: IFFALSE 20088
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19989: LD_INT 22
19991: PPUSH
19992: LD_INT 1
19994: PPUSH
19995: LD_INT 3
19997: PPUSH
19998: LD_INT 43
20000: PUSH
20001: LD_INT 44
20003: PUSH
20004: EMPTY
20005: LIST
20006: LIST
20007: PUSH
20008: LD_INT 1
20010: PPUSH
20011: LD_INT 2
20013: PPUSH
20014: CALL_OW 12
20018: ARRAY
20019: PPUSH
20020: LD_INT 89
20022: PPUSH
20023: CALL 71480 0 5
// un := CreateVehicle ;
20027: LD_ADDR_VAR 0 8
20031: PUSH
20032: CALL_OW 45
20036: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20037: LD_VAR 0 8
20041: PPUSH
20042: LD_INT 4
20044: PPUSH
20045: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20049: LD_VAR 0 8
20053: PPUSH
20054: LD_INT 136
20056: PPUSH
20057: LD_INT 90
20059: PPUSH
20060: LD_INT 8
20062: PPUSH
20063: LD_INT 0
20065: PPUSH
20066: CALL_OW 50
// ru := ru ^ un ;
20070: LD_ADDR_VAR 0 7
20074: PUSH
20075: LD_VAR 0 7
20079: PUSH
20080: LD_VAR 0 8
20084: ADD
20085: ST_TO_ADDR
// end ;
20086: GO 19986
20088: POP
20089: POP
// if ru then
20090: LD_VAR 0 7
20094: IFFALSE 20111
// ComAgressiveMove ( ru , 80 , 92 ) ;
20096: LD_VAR 0 7
20100: PPUSH
20101: LD_INT 80
20103: PPUSH
20104: LD_INT 92
20106: PPUSH
20107: CALL_OW 114
// wait ( 8 8$00 ) ;
20111: LD_INT 16800
20113: PPUSH
20114: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20118: LD_INT 4
20120: PPUSH
20121: LD_INT 3
20123: PUSH
20124: LD_INT 1
20126: PUSH
20127: LD_INT 1
20129: PUSH
20130: LD_INT 5
20132: PUSH
20133: EMPTY
20134: LIST
20135: LIST
20136: LIST
20137: LIST
20138: PUSH
20139: LD_INT 4
20141: PUSH
20142: LD_INT 1
20144: PUSH
20145: LD_INT 1
20147: PUSH
20148: LD_INT 6
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: LIST
20155: LIST
20156: PUSH
20157: LD_INT 4
20159: PUSH
20160: LD_INT 1
20162: PUSH
20163: LD_INT 1
20165: PUSH
20166: LD_INT 7
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: LIST
20173: LIST
20174: PUSH
20175: LD_INT 3
20177: PUSH
20178: LD_INT 1
20180: PUSH
20181: LD_INT 1
20183: PUSH
20184: LD_INT 7
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 3
20195: PUSH
20196: LD_INT 1
20198: PUSH
20199: LD_INT 1
20201: PUSH
20202: LD_INT 5
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: LIST
20209: LIST
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: LIST
20215: LIST
20216: LIST
20217: PPUSH
20218: CALL 57973 0 2
// missionStage := 4 ;
20222: LD_ADDR_EXP 15
20226: PUSH
20227: LD_INT 4
20229: ST_TO_ADDR
// end ;
20230: PPOPN 8
20232: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20233: LD_EXP 15
20237: PUSH
20238: LD_INT 4
20240: EQUAL
20241: PUSH
20242: LD_INT 22
20244: PUSH
20245: LD_INT 4
20247: PUSH
20248: EMPTY
20249: LIST
20250: LIST
20251: PUSH
20252: LD_INT 21
20254: PUSH
20255: LD_INT 2
20257: PUSH
20258: EMPTY
20259: LIST
20260: LIST
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: PPUSH
20266: CALL_OW 69
20270: PUSH
20271: LD_INT 5
20273: GREATEREQUAL
20274: AND
20275: IFFALSE 24380
20277: GO 20279
20279: DISABLE
20280: LD_INT 0
20282: PPUSH
20283: PPUSH
20284: PPUSH
20285: PPUSH
20286: PPUSH
20287: PPUSH
20288: PPUSH
20289: PPUSH
20290: PPUSH
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
// begin missionStage := 5 ;
20295: LD_ADDR_EXP 15
20299: PUSH
20300: LD_INT 5
20302: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20303: LD_ADDR_VAR 0 10
20307: PUSH
20308: LD_INT 22
20310: PUSH
20311: LD_INT 4
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 30
20323: PUSH
20324: LD_INT 4
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: LD_INT 5
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PPUSH
20350: CALL_OW 69
20354: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20355: LD_ADDR_VAR 0 6
20359: PUSH
20360: LD_INT 22
20362: PUSH
20363: LD_INT 4
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 21
20372: PUSH
20373: LD_INT 1
20375: PUSH
20376: EMPTY
20377: LIST
20378: LIST
20379: PUSH
20380: LD_INT 3
20382: PUSH
20383: LD_INT 25
20385: PUSH
20386: LD_INT 16
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 3
20399: PUSH
20400: LD_INT 25
20402: PUSH
20403: LD_INT 12
20405: PUSH
20406: EMPTY
20407: LIST
20408: LIST
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: PPUSH
20420: CALL_OW 69
20424: PUSH
20425: LD_EXP 57
20429: DIFF
20430: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20431: LD_ADDR_VAR 0 9
20435: PUSH
20436: LD_INT 22
20438: PUSH
20439: LD_INT 4
20441: PUSH
20442: EMPTY
20443: LIST
20444: LIST
20445: PUSH
20446: LD_INT 30
20448: PUSH
20449: LD_INT 3
20451: PUSH
20452: EMPTY
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: PUSH
20465: LD_INT 1
20467: ARRAY
20468: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20469: LD_INT 35
20471: PPUSH
20472: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20476: LD_EXP 120
20480: PUSH
20481: LD_INT 4
20483: ARRAY
20484: PUSH
20485: LD_INT 5
20487: GREATEREQUAL
20488: PUSH
20489: LD_EXP 120
20493: PUSH
20494: LD_INT 4
20496: ARRAY
20497: PPUSH
20498: LD_INT 58
20500: PUSH
20501: EMPTY
20502: LIST
20503: PPUSH
20504: CALL_OW 72
20508: PUSH
20509: LD_INT 5
20511: GREATEREQUAL
20512: AND
20513: IFFALSE 20469
// powellAllowRetreat := false ;
20515: LD_ADDR_EXP 19
20519: PUSH
20520: LD_INT 0
20522: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20523: LD_INT 700
20525: PPUSH
20526: CALL_OW 67
// activeAttacks := false ;
20530: LD_ADDR_EXP 16
20534: PUSH
20535: LD_INT 0
20537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20538: LD_INT 35
20540: PPUSH
20541: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20545: LD_INT 22
20547: PUSH
20548: LD_INT 6
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PPUSH
20555: CALL_OW 69
20559: PUSH
20560: LD_INT 0
20562: EQUAL
20563: IFFALSE 20538
// tmp := mc_vehicles [ 4 ] ;
20565: LD_ADDR_VAR 0 3
20569: PUSH
20570: LD_EXP 120
20574: PUSH
20575: LD_INT 4
20577: ARRAY
20578: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20579: LD_ADDR_VAR 0 1
20583: PUSH
20584: DOUBLE
20585: LD_INT 1
20587: DEC
20588: ST_TO_ADDR
20589: LD_EXP 18
20593: PUSH
20594: FOR_TO
20595: IFFALSE 20856
// begin for j in powellSquadAttack [ i ] do
20597: LD_ADDR_VAR 0 2
20601: PUSH
20602: LD_EXP 18
20606: PUSH
20607: LD_VAR 0 1
20611: ARRAY
20612: PUSH
20613: FOR_IN
20614: IFFALSE 20852
// begin forces := forces diff j ;
20616: LD_ADDR_VAR 0 6
20620: PUSH
20621: LD_VAR 0 6
20625: PUSH
20626: LD_VAR 0 2
20630: DIFF
20631: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20632: LD_VAR 0 2
20636: PPUSH
20637: LD_INT 1
20639: PPUSH
20640: CALL_OW 109
// wait ( 0 0$2 ) ;
20644: LD_INT 70
20646: PPUSH
20647: CALL_OW 67
// if IsInUnit ( j ) then
20651: LD_VAR 0 2
20655: PPUSH
20656: CALL_OW 310
20660: IFFALSE 20671
// ComExitBuilding ( j ) ;
20662: LD_VAR 0 2
20666: PPUSH
20667: CALL_OW 122
// if GetClass ( j ) <> 1 then
20671: LD_VAR 0 2
20675: PPUSH
20676: CALL_OW 257
20680: PUSH
20681: LD_INT 1
20683: NONEQUAL
20684: IFFALSE 20764
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20686: LD_VAR 0 10
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_INT 5
20702: GREATEREQUAL
20703: IFFALSE 20725
// AddComEnterUnit ( j , arm [ 2 ] ) else
20705: LD_VAR 0 2
20709: PPUSH
20710: LD_VAR 0 10
20714: PUSH
20715: LD_INT 2
20717: ARRAY
20718: PPUSH
20719: CALL_OW 180
20723: GO 20743
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20725: LD_VAR 0 2
20729: PPUSH
20730: LD_VAR 0 10
20734: PUSH
20735: LD_INT 1
20737: ARRAY
20738: PPUSH
20739: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20743: LD_VAR 0 2
20747: PPUSH
20748: LD_INT 1
20750: PPUSH
20751: CALL_OW 183
// AddComExitBuilding ( j ) ;
20755: LD_VAR 0 2
20759: PPUSH
20760: CALL_OW 182
// end ; if i = 2 then
20764: LD_VAR 0 1
20768: PUSH
20769: LD_INT 2
20771: EQUAL
20772: IFFALSE 20789
// AddComMoveXY ( j , 61 , 93 ) ;
20774: LD_VAR 0 2
20778: PPUSH
20779: LD_INT 61
20781: PPUSH
20782: LD_INT 93
20784: PPUSH
20785: CALL_OW 171
// if i = 1 then
20789: LD_VAR 0 1
20793: PUSH
20794: LD_INT 1
20796: EQUAL
20797: IFFALSE 20850
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20799: LD_VAR 0 2
20803: PPUSH
20804: LD_VAR 0 3
20808: PUSH
20809: LD_INT 1
20811: ARRAY
20812: PPUSH
20813: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20817: LD_ADDR_VAR 0 3
20821: PUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_INT 1
20829: PPUSH
20830: CALL_OW 3
20834: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_INT 69
20842: PPUSH
20843: LD_INT 94
20845: PPUSH
20846: CALL_OW 171
// end ; end ;
20850: GO 20613
20852: POP
20853: POP
// end ;
20854: GO 20594
20856: POP
20857: POP
// wait ( 0 0$55 ) ;
20858: LD_INT 1925
20860: PPUSH
20861: CALL_OW 67
// MC_Kill ( 4 ) ;
20865: LD_INT 4
20867: PPUSH
20868: CALL 34457 0 1
// tmp := UnitsInside ( fac ) ;
20872: LD_ADDR_VAR 0 3
20876: PUSH
20877: LD_VAR 0 9
20881: PPUSH
20882: CALL_OW 313
20886: ST_TO_ADDR
// if tmp then
20887: LD_VAR 0 3
20891: IFFALSE 21012
// for i in tmp do
20893: LD_ADDR_VAR 0 1
20897: PUSH
20898: LD_VAR 0 3
20902: PUSH
20903: FOR_IN
20904: IFFALSE 21010
// begin ComExitBuilding ( i ) ;
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20915: LD_VAR 0 10
20919: PUSH
20920: LD_INT 2
20922: ARRAY
20923: PPUSH
20924: CALL_OW 313
20928: PUSH
20929: LD_INT 6
20931: LESS
20932: IFFALSE 20954
// AddComEnterUnit ( i , arm [ 2 ] ) else
20934: LD_VAR 0 1
20938: PPUSH
20939: LD_VAR 0 10
20943: PUSH
20944: LD_INT 2
20946: ARRAY
20947: PPUSH
20948: CALL_OW 180
20952: GO 21008
// if UnitsInside ( arm [ 1 ] ) < 6 then
20954: LD_VAR 0 10
20958: PUSH
20959: LD_INT 1
20961: ARRAY
20962: PPUSH
20963: CALL_OW 313
20967: PUSH
20968: LD_INT 6
20970: LESS
20971: IFFALSE 20993
// AddComEnterUnit ( i , arm [ 1 ] ) else
20973: LD_VAR 0 1
20977: PPUSH
20978: LD_VAR 0 10
20982: PUSH
20983: LD_INT 1
20985: ARRAY
20986: PPUSH
20987: CALL_OW 180
20991: GO 21008
// AddComMoveXY ( i , 37 , 68 ) ;
20993: LD_VAR 0 1
20997: PPUSH
20998: LD_INT 37
21000: PPUSH
21001: LD_INT 68
21003: PPUSH
21004: CALL_OW 171
// end ;
21008: GO 20903
21010: POP
21011: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21012: LD_ADDR_VAR 0 11
21016: PUSH
21017: LD_VAR 0 6
21021: PPUSH
21022: LD_INT 26
21024: PUSH
21025: LD_INT 1
21027: PUSH
21028: EMPTY
21029: LIST
21030: LIST
21031: PPUSH
21032: CALL_OW 72
21036: PUSH
21037: LD_EXP 58
21041: DIFF
21042: ST_TO_ADDR
// if not speaker then
21043: LD_VAR 0 11
21047: NOT
21048: IFFALSE 21075
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21050: LD_ADDR_VAR 0 11
21054: PUSH
21055: LD_VAR 0 6
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// if speaker then
21075: LD_VAR 0 11
21079: IFFALSE 21095
// speaker := speaker [ 1 ] ;
21081: LD_ADDR_VAR 0 11
21085: PUSH
21086: LD_VAR 0 11
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
// Video ( true ) ;
21095: LD_INT 1
21097: PPUSH
21098: CALL 107197 0 1
// CenterNowOnUnits ( Powell ) ;
21102: LD_EXP 57
21106: PPUSH
21107: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_VAR 0 6
21120: PPUSH
21121: LD_INT 3
21123: PUSH
21124: LD_INT 25
21126: PUSH
21127: LD_INT 1
21129: PUSH
21130: EMPTY
21131: LIST
21132: LIST
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: PPUSH
21138: CALL_OW 72
21142: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21143: LD_ADDR_VAR 0 12
21147: PUSH
21148: LD_INT 22
21150: PUSH
21151: LD_INT 4
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: LD_INT 30
21160: PUSH
21161: LD_INT 32
21163: PUSH
21164: EMPTY
21165: LIST
21166: LIST
21167: PUSH
21168: LD_INT 58
21170: PUSH
21171: EMPTY
21172: LIST
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: PPUSH
21179: CALL_OW 69
21183: ST_TO_ADDR
// for i = 1 to 6 do
21184: LD_ADDR_VAR 0 1
21188: PUSH
21189: DOUBLE
21190: LD_INT 1
21192: DEC
21193: ST_TO_ADDR
21194: LD_INT 6
21196: PUSH
21197: FOR_TO
21198: IFFALSE 21339
// begin if IsInUnit ( tmp [ i ] ) then
21200: LD_VAR 0 3
21204: PUSH
21205: LD_VAR 0 1
21209: ARRAY
21210: PPUSH
21211: CALL_OW 310
21215: IFFALSE 21232
// ComExitBuilding ( tmp [ i ] ) ;
21217: LD_VAR 0 3
21221: PUSH
21222: LD_VAR 0 1
21226: ARRAY
21227: PPUSH
21228: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21232: LD_VAR 0 3
21236: PUSH
21237: LD_VAR 0 1
21241: ARRAY
21242: PPUSH
21243: LD_VAR 0 10
21247: PUSH
21248: LD_INT 1
21250: ARRAY
21251: PPUSH
21252: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21256: LD_VAR 0 3
21260: PUSH
21261: LD_VAR 0 1
21265: ARRAY
21266: PPUSH
21267: LD_INT 1
21269: PPUSH
21270: CALL_OW 183
// if emp_towers then
21274: LD_VAR 0 12
21278: IFFALSE 21337
// begin AddComExitBuilding ( tmp [ i ] ) ;
21280: LD_VAR 0 3
21284: PUSH
21285: LD_VAR 0 1
21289: ARRAY
21290: PPUSH
21291: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21295: LD_VAR 0 3
21299: PUSH
21300: LD_VAR 0 1
21304: ARRAY
21305: PPUSH
21306: LD_VAR 0 12
21310: PUSH
21311: LD_INT 1
21313: ARRAY
21314: PPUSH
21315: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21319: LD_ADDR_VAR 0 12
21323: PUSH
21324: LD_VAR 0 12
21328: PPUSH
21329: LD_INT 1
21331: PPUSH
21332: CALL_OW 3
21336: ST_TO_ADDR
// end ; end ;
21337: GO 21197
21339: POP
21340: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_EXP 18
21350: PUSH
21351: LD_INT 1
21353: ARRAY
21354: PUSH
21355: LD_EXP 18
21359: PUSH
21360: LD_INT 2
21362: ARRAY
21363: ADD
21364: PPUSH
21365: LD_INT 26
21367: PUSH
21368: LD_INT 1
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 72
21379: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21380: LD_ADDR_VAR 0 1
21384: PUSH
21385: LD_EXP 18
21389: PUSH
21390: LD_INT 2
21392: ARRAY
21393: PUSH
21394: FOR_IN
21395: IFFALSE 21413
// ComTurnUnit ( i , Powell ) ;
21397: LD_VAR 0 1
21401: PPUSH
21402: LD_EXP 57
21406: PPUSH
21407: CALL_OW 119
21411: GO 21394
21413: POP
21414: POP
// Say ( Powell , D5-Pow-1 ) ;
21415: LD_EXP 57
21419: PPUSH
21420: LD_STRING D5-Pow-1
21422: PPUSH
21423: CALL_OW 88
// if tmp then
21427: LD_VAR 0 3
21431: IFFALSE 21449
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21433: LD_VAR 0 3
21437: PUSH
21438: LD_INT 1
21440: ARRAY
21441: PPUSH
21442: LD_STRING D5-Sol2-1
21444: PPUSH
21445: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21449: LD_EXP 57
21453: PPUSH
21454: LD_STRING D5-Pow-2
21456: PPUSH
21457: CALL_OW 88
// if tmp > 1 then
21461: LD_VAR 0 3
21465: PUSH
21466: LD_INT 1
21468: GREATER
21469: IFFALSE 21487
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21471: LD_VAR 0 3
21475: PUSH
21476: LD_INT 2
21478: ARRAY
21479: PPUSH
21480: LD_STRING D5-Sol2-2
21482: PPUSH
21483: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21487: LD_EXP 57
21491: PPUSH
21492: LD_STRING D5-Pow-3
21494: PPUSH
21495: CALL_OW 88
// wait ( 0 0$1 ) ;
21499: LD_INT 35
21501: PPUSH
21502: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21506: LD_ADDR_VAR 0 3
21510: PUSH
21511: LD_EXP 18
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PUSH
21520: LD_EXP 18
21524: PUSH
21525: LD_INT 2
21527: ARRAY
21528: UNION
21529: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21530: LD_VAR 0 3
21534: PPUSH
21535: LD_INT 80
21537: PPUSH
21538: LD_INT 67
21540: PPUSH
21541: CALL_OW 114
// wait ( 0 0$2 ) ;
21545: LD_INT 70
21547: PPUSH
21548: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21552: LD_INT 79
21554: PPUSH
21555: LD_INT 72
21557: PPUSH
21558: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21562: LD_INT 35
21564: PPUSH
21565: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21569: LD_VAR 0 3
21573: PPUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 24
21579: PUSH
21580: LD_INT 1000
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: PPUSH
21591: CALL_OW 72
21595: IFFALSE 21562
// Say ( Powell , D5a-Pow-1 ) ;
21597: LD_EXP 57
21601: PPUSH
21602: LD_STRING D5a-Pow-1
21604: PPUSH
21605: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21609: LD_EXP 57
21613: PPUSH
21614: LD_STRING D5a-Pow-1a
21616: PPUSH
21617: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21621: LD_INT 10
21623: PPUSH
21624: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21628: LD_EXP 57
21632: PPUSH
21633: LD_STRING D5a-Pow-1b
21635: PPUSH
21636: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21640: LD_EXP 57
21644: PPUSH
21645: LD_STRING D5a-Pow-1c
21647: PPUSH
21648: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21652: LD_EXP 57
21656: PPUSH
21657: LD_STRING D5a-Pow-1d
21659: PPUSH
21660: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21664: LD_INT 35
21666: PPUSH
21667: CALL_OW 67
// if not HasTask ( tmp ) then
21671: LD_VAR 0 3
21675: PPUSH
21676: CALL_OW 314
21680: NOT
21681: IFFALSE 21698
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21683: LD_VAR 0 3
21687: PPUSH
21688: LD_INT 80
21690: PPUSH
21691: LD_INT 67
21693: PPUSH
21694: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21698: LD_VAR 0 3
21702: PPUSH
21703: LD_INT 24
21705: PUSH
21706: LD_INT 1
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: PPUSH
21713: CALL_OW 72
21717: NOT
21718: IFFALSE 21664
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21720: LD_ADDR_VAR 0 3
21724: PUSH
21725: LD_INT 22
21727: PUSH
21728: LD_INT 4
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 92
21737: PUSH
21738: LD_INT 60
21740: PUSH
21741: LD_INT 93
21743: PUSH
21744: LD_INT 10
21746: PUSH
21747: EMPTY
21748: LIST
21749: LIST
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 3
21755: PUSH
21756: LD_INT 54
21758: PUSH
21759: EMPTY
21760: LIST
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: LIST
21770: PPUSH
21771: CALL_OW 69
21775: PUSH
21776: LD_EXP 57
21780: DIFF
21781: ST_TO_ADDR
// if tmp then
21782: LD_VAR 0 3
21786: IFFALSE 21820
// for i in tmp do
21788: LD_ADDR_VAR 0 1
21792: PUSH
21793: LD_VAR 0 3
21797: PUSH
21798: FOR_IN
21799: IFFALSE 21818
// ComMoveXY ( i , 36 , 67 ) ;
21801: LD_VAR 0 1
21805: PPUSH
21806: LD_INT 36
21808: PPUSH
21809: LD_INT 67
21811: PPUSH
21812: CALL_OW 111
21816: GO 21798
21818: POP
21819: POP
// wait ( 0 0$3 ) ;
21820: LD_INT 105
21822: PPUSH
21823: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21827: LD_VAR 0 11
21831: PPUSH
21832: LD_STRING D6-Sol3-1
21834: PPUSH
21835: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21839: LD_EXP 57
21843: PPUSH
21844: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21848: LD_EXP 57
21852: PPUSH
21853: LD_STRING D6-Pow-1
21855: PPUSH
21856: CALL_OW 88
// tmp := [ ] ;
21860: LD_ADDR_VAR 0 3
21864: PUSH
21865: EMPTY
21866: ST_TO_ADDR
// for i = 1 to 2 do
21867: LD_ADDR_VAR 0 1
21871: PUSH
21872: DOUBLE
21873: LD_INT 1
21875: DEC
21876: ST_TO_ADDR
21877: LD_INT 2
21879: PUSH
21880: FOR_TO
21881: IFFALSE 21995
// begin uc_side := 8 ;
21883: LD_ADDR_OWVAR 20
21887: PUSH
21888: LD_INT 8
21890: ST_TO_ADDR
// uc_nation := 2 ;
21891: LD_ADDR_OWVAR 21
21895: PUSH
21896: LD_INT 2
21898: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21899: LD_INT 14
21901: PPUSH
21902: LD_INT 3
21904: PPUSH
21905: LD_INT 2
21907: PPUSH
21908: LD_INT 29
21910: PPUSH
21911: LD_INT 100
21913: PPUSH
21914: CALL 71480 0 5
// veh := CreateVehicle ;
21918: LD_ADDR_VAR 0 13
21922: PUSH
21923: CALL_OW 45
21927: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21928: LD_VAR 0 13
21932: PPUSH
21933: LD_INT 4
21935: PPUSH
21936: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21940: LD_VAR 0 13
21944: PPUSH
21945: LD_INT 99
21947: PPUSH
21948: LD_INT 83
21950: PPUSH
21951: LD_INT 6
21953: PPUSH
21954: LD_INT 0
21956: PPUSH
21957: CALL_OW 50
// wait ( 3 ) ;
21961: LD_INT 3
21963: PPUSH
21964: CALL_OW 67
// Connect ( veh ) ;
21968: LD_VAR 0 13
21972: PPUSH
21973: CALL 74535 0 1
// tmp := tmp ^ veh ;
21977: LD_ADDR_VAR 0 3
21981: PUSH
21982: LD_VAR 0 3
21986: PUSH
21987: LD_VAR 0 13
21991: ADD
21992: ST_TO_ADDR
// end ;
21993: GO 21880
21995: POP
21996: POP
// wait ( 0 0$1 ) ;
21997: LD_INT 35
21999: PPUSH
22000: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22004: LD_INT 99
22006: PPUSH
22007: LD_INT 83
22009: PPUSH
22010: LD_INT 1
22012: PPUSH
22013: LD_INT 10
22015: PPUSH
22016: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22020: LD_INT 99
22022: PPUSH
22023: LD_INT 83
22025: PPUSH
22026: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22030: LD_VAR 0 11
22034: PPUSH
22035: LD_STRING D6-Sol3-2
22037: PPUSH
22038: CALL_OW 88
// async ;
22042: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22043: LD_EXP 57
22047: PPUSH
22048: LD_STRING D6-Pow-2
22050: PPUSH
22051: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22055: LD_VAR 0 3
22059: PUSH
22060: LD_INT 1
22062: ARRAY
22063: PPUSH
22064: LD_VAR 0 9
22068: PPUSH
22069: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22073: LD_VAR 0 3
22077: PUSH
22078: LD_INT 2
22080: ARRAY
22081: PPUSH
22082: LD_INT 22
22084: PUSH
22085: LD_INT 4
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: LD_INT 21
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: EMPTY
22099: LIST
22100: LIST
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: PPUSH
22106: CALL_OW 69
22110: PPUSH
22111: LD_VAR 0 3
22115: PUSH
22116: LD_INT 2
22118: ARRAY
22119: PPUSH
22120: CALL_OW 74
22124: PPUSH
22125: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22129: LD_EXP 57
22133: PPUSH
22134: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22138: LD_INT 99
22140: PPUSH
22141: LD_INT 83
22143: PPUSH
22144: LD_INT 1
22146: PPUSH
22147: CALL_OW 331
// repeat wait ( 4 ) ;
22151: LD_INT 4
22153: PPUSH
22154: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22158: LD_VAR 0 3
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: PPUSH
22167: CALL_OW 256
22171: PUSH
22172: LD_INT 1000
22174: LESS
22175: IFFALSE 22193
// SetLives ( tmp [ 1 ] , 1000 ) ;
22177: LD_VAR 0 3
22181: PUSH
22182: LD_INT 1
22184: ARRAY
22185: PPUSH
22186: LD_INT 1000
22188: PPUSH
22189: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22193: LD_INT 22
22195: PUSH
22196: LD_INT 4
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_INT 3
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: EMPTY
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 69
22221: PUSH
22222: LD_INT 0
22224: EQUAL
22225: IFFALSE 22151
// sync ;
22227: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22228: LD_EXP 57
22232: PPUSH
22233: LD_STRING D6a-Pow-1
22235: PPUSH
22236: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22240: LD_VAR 0 11
22244: PPUSH
22245: LD_STRING D6a-Sol3-1
22247: PPUSH
22248: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22252: LD_EXP 57
22256: PPUSH
22257: LD_STRING D6a-Pow-2
22259: PPUSH
22260: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22264: LD_VAR 0 11
22268: PPUSH
22269: LD_STRING D6a-Sol3-2
22271: PPUSH
22272: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22276: LD_EXP 57
22280: PPUSH
22281: LD_STRING D6a-Pow-3
22283: PPUSH
22284: CALL_OW 88
// powellCenterCameraMode := true ;
22288: LD_ADDR_EXP 20
22292: PUSH
22293: LD_INT 1
22295: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22296: LD_ADDR_VAR 0 1
22300: PUSH
22301: LD_INT 22
22303: PUSH
22304: LD_INT 8
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PUSH
22311: LD_INT 25
22313: PUSH
22314: LD_INT 2
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: PPUSH
22325: CALL_OW 69
22329: PUSH
22330: FOR_IN
22331: IFFALSE 22386
// begin SetTag ( i , 1 ) ;
22333: LD_VAR 0 1
22337: PPUSH
22338: LD_INT 1
22340: PPUSH
22341: CALL_OW 109
// ComExitBuilding ( i ) ;
22345: LD_VAR 0 1
22349: PPUSH
22350: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22354: LD_VAR 0 1
22358: PPUSH
22359: LD_INT 35
22361: PPUSH
22362: LD_INT 6
22364: PPUSH
22365: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22369: LD_VAR 0 1
22373: PPUSH
22374: LD_INT 53
22376: PPUSH
22377: LD_INT 4
22379: PPUSH
22380: CALL_OW 171
// end ;
22384: GO 22330
22386: POP
22387: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22388: LD_ADDR_VAR 0 3
22392: PUSH
22393: LD_INT 22
22395: PUSH
22396: LD_INT 4
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 21
22405: PUSH
22406: LD_INT 2
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: LD_INT 3
22415: PUSH
22416: LD_INT 34
22418: PUSH
22419: LD_INT 12
22421: PUSH
22422: EMPTY
22423: LIST
22424: LIST
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22440: LD_EXP 57
22444: PPUSH
22445: LD_VAR 0 3
22449: PPUSH
22450: LD_EXP 57
22454: PPUSH
22455: CALL_OW 74
22459: PPUSH
22460: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22464: LD_EXP 57
22468: PPUSH
22469: LD_INT 100
22471: PPUSH
22472: LD_INT 88
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22479: LD_EXP 57
22483: PPUSH
22484: LD_INT 100
22486: PPUSH
22487: LD_INT 75
22489: PPUSH
22490: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22494: LD_EXP 57
22498: PPUSH
22499: LD_INT 88
22501: PPUSH
22502: LD_INT 53
22504: PPUSH
22505: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22509: LD_INT 8
22511: PPUSH
22512: LD_EXP 57
22516: PPUSH
22517: CALL_OW 471
// repeat wait ( 3 ) ;
22521: LD_INT 3
22523: PPUSH
22524: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22528: LD_INT 22
22530: PUSH
22531: LD_INT 4
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: LD_INT 92
22540: PUSH
22541: LD_INT 100
22543: PUSH
22544: LD_INT 75
22546: PUSH
22547: LD_INT 6
22549: PUSH
22550: EMPTY
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PPUSH
22560: CALL_OW 69
22564: IFFALSE 22521
// async ;
22566: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22567: LD_EXP 57
22571: PPUSH
22572: LD_STRING D6b-Pow-1
22574: PPUSH
22575: CALL_OW 88
// repeat wait ( 3 ) ;
22579: LD_INT 3
22581: PPUSH
22582: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22586: LD_EXP 57
22590: PPUSH
22591: CALL_OW 310
22595: PPUSH
22596: CALL_OW 256
22600: PUSH
22601: LD_INT 1000
22603: LESS
22604: IFFALSE 22623
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22606: LD_EXP 57
22610: PPUSH
22611: CALL_OW 310
22615: PPUSH
22616: LD_INT 1000
22618: PPUSH
22619: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22623: LD_EXP 57
22627: PPUSH
22628: CALL_OW 256
22632: PUSH
22633: LD_INT 1000
22635: LESS
22636: IFFALSE 22650
// SetLives ( Powell , 1000 ) ;
22638: LD_EXP 57
22642: PPUSH
22643: LD_INT 1000
22645: PPUSH
22646: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22650: LD_EXP 57
22654: PPUSH
22655: LD_EXP 62
22659: PPUSH
22660: CALL_OW 296
22664: PUSH
22665: LD_INT 5
22667: LESS
22668: PUSH
22669: LD_EXP 57
22673: PPUSH
22674: CALL_OW 310
22678: PPUSH
22679: LD_EXP 62
22683: PPUSH
22684: CALL_OW 296
22688: PUSH
22689: LD_INT 5
22691: LESS
22692: OR
22693: IFFALSE 22712
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22695: LD_EXP 57
22699: PPUSH
22700: CALL_OW 310
22704: PPUSH
22705: LD_INT 100
22707: PPUSH
22708: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22712: LD_EXP 57
22716: PPUSH
22717: CALL_OW 310
22721: NOT
22722: IFFALSE 22579
// DoNotAttack ( 8 , powellBomb ) ;
22724: LD_INT 8
22726: PPUSH
22727: LD_EXP 62
22731: PPUSH
22732: CALL_OW 471
// game_speed := 4 ;
22736: LD_ADDR_OWVAR 65
22740: PUSH
22741: LD_INT 4
22743: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22744: LD_EXP 57
22748: PPUSH
22749: LD_STRING D6b-Pow-1a
22751: PPUSH
22752: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22756: LD_EXP 57
22760: PPUSH
22761: LD_EXP 62
22765: PPUSH
22766: CALL_OW 180
// sync ;
22770: SYNC
// repeat wait ( 0 0$1 ) ;
22771: LD_INT 35
22773: PPUSH
22774: CALL_OW 67
// until IsInUnit ( Powell ) ;
22778: LD_EXP 57
22782: PPUSH
22783: CALL_OW 310
22787: IFFALSE 22771
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22789: LD_INT 8
22791: PPUSH
22792: LD_EXP 57
22796: PPUSH
22797: CALL_OW 310
22801: PPUSH
22802: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22806: LD_EXP 57
22810: PPUSH
22811: LD_INT 91
22813: PPUSH
22814: LD_INT 44
22816: PPUSH
22817: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22821: LD_EXP 57
22825: PPUSH
22826: LD_INT 96
22828: PPUSH
22829: LD_INT 44
22831: PPUSH
22832: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22836: LD_EXP 57
22840: PPUSH
22841: LD_INT 96
22843: PPUSH
22844: LD_INT 41
22846: PPUSH
22847: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22851: LD_EXP 57
22855: PPUSH
22856: LD_INT 92
22858: PPUSH
22859: LD_INT 39
22861: PPUSH
22862: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22866: LD_EXP 57
22870: PPUSH
22871: LD_INT 88
22873: PPUSH
22874: LD_INT 41
22876: PPUSH
22877: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22881: LD_EXP 57
22885: PPUSH
22886: LD_INT 91
22888: PPUSH
22889: LD_INT 44
22891: PPUSH
22892: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22896: LD_EXP 57
22900: PPUSH
22901: LD_INT 96
22903: PPUSH
22904: LD_INT 44
22906: PPUSH
22907: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22911: LD_EXP 57
22915: PPUSH
22916: LD_INT 96
22918: PPUSH
22919: LD_INT 41
22921: PPUSH
22922: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22926: LD_EXP 57
22930: PPUSH
22931: LD_INT 92
22933: PPUSH
22934: LD_INT 39
22936: PPUSH
22937: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22941: LD_EXP 57
22945: PPUSH
22946: LD_INT 88
22948: PPUSH
22949: LD_INT 41
22951: PPUSH
22952: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22956: LD_EXP 57
22960: PPUSH
22961: LD_INT 91
22963: PPUSH
22964: LD_INT 44
22966: PPUSH
22967: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22971: LD_EXP 57
22975: PPUSH
22976: LD_INT 93
22978: PPUSH
22979: LD_INT 39
22981: PPUSH
22982: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22986: LD_EXP 57
22990: PPUSH
22991: LD_INT 93
22993: PPUSH
22994: LD_INT 36
22996: PPUSH
22997: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23001: LD_INT 122
23003: PPUSH
23004: CALL_OW 67
// game_speed := 4 ;
23008: LD_ADDR_OWVAR 65
23012: PUSH
23013: LD_INT 4
23015: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23016: LD_EXP 57
23020: PPUSH
23021: LD_STRING D6b-Pow-1b
23023: PPUSH
23024: CALL_OW 88
// tmp := [ ] ;
23028: LD_ADDR_VAR 0 3
23032: PUSH
23033: EMPTY
23034: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23035: LD_ADDR_VAR 0 5
23039: PUSH
23040: LD_INT 78
23042: PUSH
23043: LD_INT 47
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: PUSH
23050: LD_INT 106
23052: PUSH
23053: LD_INT 53
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23064: LD_ADDR_VAR 0 1
23068: PUSH
23069: LD_INT 22
23071: PUSH
23072: LD_INT 8
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 21
23081: PUSH
23082: LD_INT 3
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: LD_INT 92
23091: PUSH
23092: LD_INT 90
23094: PUSH
23095: LD_INT 52
23097: PUSH
23098: LD_INT 12
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 69
23116: PUSH
23117: FOR_IN
23118: IFFALSE 23143
// tmp := tmp ^ UnitsInside ( i ) ;
23120: LD_ADDR_VAR 0 3
23124: PUSH
23125: LD_VAR 0 3
23129: PUSH
23130: LD_VAR 0 1
23134: PPUSH
23135: CALL_OW 313
23139: ADD
23140: ST_TO_ADDR
23141: GO 23117
23143: POP
23144: POP
// for i in tmp do
23145: LD_ADDR_VAR 0 1
23149: PUSH
23150: LD_VAR 0 3
23154: PUSH
23155: FOR_IN
23156: IFFALSE 23318
// begin dist := 9999 ;
23158: LD_ADDR_VAR 0 8
23162: PUSH
23163: LD_INT 9999
23165: ST_TO_ADDR
// _xy := [ ] ;
23166: LD_ADDR_VAR 0 7
23170: PUSH
23171: EMPTY
23172: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23173: LD_VAR 0 1
23177: PPUSH
23178: LD_INT 1
23180: PPUSH
23181: CALL_OW 109
// ComExitBuilding ( i ) ;
23185: LD_VAR 0 1
23189: PPUSH
23190: CALL_OW 122
// for j in xy do
23194: LD_ADDR_VAR 0 2
23198: PUSH
23199: LD_VAR 0 5
23203: PUSH
23204: FOR_IN
23205: IFFALSE 23287
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_VAR 0 2
23216: PUSH
23217: LD_INT 1
23219: ARRAY
23220: PPUSH
23221: LD_VAR 0 2
23225: PUSH
23226: LD_INT 2
23228: ARRAY
23229: PPUSH
23230: CALL_OW 297
23234: PUSH
23235: LD_VAR 0 8
23239: LESS
23240: IFFALSE 23285
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23242: LD_ADDR_VAR 0 8
23246: PUSH
23247: LD_VAR 0 1
23251: PPUSH
23252: LD_VAR 0 2
23256: PUSH
23257: LD_INT 1
23259: ARRAY
23260: PPUSH
23261: LD_VAR 0 2
23265: PUSH
23266: LD_INT 2
23268: ARRAY
23269: PPUSH
23270: CALL_OW 297
23274: ST_TO_ADDR
// _xy := j ;
23275: LD_ADDR_VAR 0 7
23279: PUSH
23280: LD_VAR 0 2
23284: ST_TO_ADDR
// end ;
23285: GO 23204
23287: POP
23288: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23289: LD_VAR 0 1
23293: PPUSH
23294: LD_VAR 0 7
23298: PUSH
23299: LD_INT 1
23301: ARRAY
23302: PPUSH
23303: LD_VAR 0 7
23307: PUSH
23308: LD_INT 2
23310: ARRAY
23311: PPUSH
23312: CALL_OW 171
// end ;
23316: GO 23155
23318: POP
23319: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23320: LD_ADDR_VAR 0 4
23324: PUSH
23325: LD_VAR 0 3
23329: PPUSH
23330: LD_INT 26
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 25
23342: PUSH
23343: LD_INT 1
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: EMPTY
23351: LIST
23352: LIST
23353: PPUSH
23354: CALL_OW 72
23358: ST_TO_ADDR
// if tmp2 < 2 then
23359: LD_VAR 0 4
23363: PUSH
23364: LD_INT 2
23366: LESS
23367: IFFALSE 23436
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23369: LD_ADDR_VAR 0 4
23373: PUSH
23374: LD_INT 22
23376: PUSH
23377: LD_INT 8
23379: PUSH
23380: EMPTY
23381: LIST
23382: LIST
23383: PUSH
23384: LD_INT 26
23386: PUSH
23387: LD_INT 1
23389: PUSH
23390: EMPTY
23391: LIST
23392: LIST
23393: PUSH
23394: LD_INT 3
23396: PUSH
23397: LD_INT 25
23399: PUSH
23400: LD_INT 15
23402: PUSH
23403: EMPTY
23404: LIST
23405: LIST
23406: PUSH
23407: EMPTY
23408: LIST
23409: LIST
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: LIST
23415: PPUSH
23416: CALL_OW 69
23420: PUSH
23421: LD_EXP 59
23425: PUSH
23426: LD_EXP 60
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: DIFF
23435: ST_TO_ADDR
// if tmp2 then
23436: LD_VAR 0 4
23440: IFFALSE 23458
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23442: LD_VAR 0 4
23446: PUSH
23447: LD_INT 1
23449: ARRAY
23450: PPUSH
23451: LD_STRING D6b-ArSol1-1
23453: PPUSH
23454: CALL_OW 88
// async ;
23458: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23459: LD_EXP 57
23463: PPUSH
23464: LD_STRING D6b-Pow-2
23466: PPUSH
23467: CALL_OW 88
// wait ( 0 0$1 ) ;
23471: LD_INT 35
23473: PPUSH
23474: CALL_OW 67
// if tmp2 > 1 then
23478: LD_VAR 0 4
23482: PUSH
23483: LD_INT 1
23485: GREATER
23486: IFFALSE 23504
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23488: LD_VAR 0 4
23492: PUSH
23493: LD_INT 2
23495: ARRAY
23496: PPUSH
23497: LD_STRING D6b-ArSol2-1
23499: PPUSH
23500: CALL_OW 88
// sync ;
23504: SYNC
// repeat wait ( 5 ) ;
23505: LD_INT 5
23507: PPUSH
23508: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23512: LD_INT 93
23514: PPUSH
23515: LD_INT 36
23517: PPUSH
23518: CALL_OW 428
23522: PPUSH
23523: CALL_OW 255
23527: PUSH
23528: LD_INT 4
23530: EQUAL
23531: IFFALSE 23505
// DialogueOn ;
23533: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23537: LD_INT 10
23539: PPUSH
23540: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23544: LD_EXP 57
23548: PPUSH
23549: LD_STRING D6b-Pow-2a
23551: PPUSH
23552: CALL_OW 88
// DialogueOff ;
23556: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23560: LD_EXP 57
23564: PPUSH
23565: CALL_OW 310
23569: PPUSH
23570: LD_INT 332
23572: PPUSH
23573: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23577: LD_INT 93
23579: PPUSH
23580: LD_INT 35
23582: PPUSH
23583: LD_INT 1
23585: PPUSH
23586: LD_INT 6
23588: NEG
23589: PPUSH
23590: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23594: LD_INT 35
23596: PPUSH
23597: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23601: LD_INT 332
23603: PPUSH
23604: CALL_OW 256
23608: PUSH
23609: LD_INT 1000
23611: LESS
23612: PUSH
23613: LD_INT 332
23615: PPUSH
23616: CALL_OW 300
23620: AND
23621: IFFALSE 23633
// SetLives ( kozlov_fac , 0 ) ;
23623: LD_INT 332
23625: PPUSH
23626: LD_INT 0
23628: PPUSH
23629: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23633: LD_INT 332
23635: PPUSH
23636: CALL_OW 301
23640: PUSH
23641: LD_EXP 57
23645: PPUSH
23646: CALL_OW 301
23650: OR
23651: IFFALSE 23594
// game_speed := 4 ;
23653: LD_ADDR_OWVAR 65
23657: PUSH
23658: LD_INT 4
23660: ST_TO_ADDR
// powellCenterCameraMode := false ;
23661: LD_ADDR_EXP 20
23665: PUSH
23666: LD_INT 0
23668: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23669: LD_ADDR_VAR 0 1
23673: PUSH
23674: LD_VAR 0 3
23678: PUSH
23679: LD_INT 22
23681: PUSH
23682: LD_INT 8
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 25
23691: PUSH
23692: LD_INT 2
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PPUSH
23703: CALL_OW 69
23707: UNION
23708: PUSH
23709: FOR_IN
23710: IFFALSE 23726
// SetTag ( i , 0 ) ;
23712: LD_VAR 0 1
23716: PPUSH
23717: LD_INT 0
23719: PPUSH
23720: CALL_OW 109
23724: GO 23709
23726: POP
23727: POP
// wait ( 0 0$3 ) ;
23728: LD_INT 105
23730: PPUSH
23731: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23735: LD_INT 93
23737: PPUSH
23738: LD_INT 35
23740: PPUSH
23741: LD_INT 1
23743: PPUSH
23744: CALL_OW 331
// DialogueOn ;
23748: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23752: LD_VAR 0 11
23756: PPUSH
23757: LD_STRING D6c-Sol3-1
23759: PPUSH
23760: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23764: LD_INT 10
23766: PPUSH
23767: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23771: LD_EXP 38
23775: PPUSH
23776: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23780: LD_EXP 38
23784: PPUSH
23785: LD_STRING D6c-JMM-1
23787: PPUSH
23788: CALL_OW 88
// if Cyrus then
23792: LD_EXP 44
23796: IFFALSE 23810
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23798: LD_EXP 44
23802: PPUSH
23803: LD_STRING D6c-Cyrus-1
23805: PPUSH
23806: CALL_OW 88
// if Bobby then
23810: LD_EXP 43
23814: IFFALSE 23828
// Say ( Bobby , D6c-Bobby-1 ) ;
23816: LD_EXP 43
23820: PPUSH
23821: LD_STRING D6c-Bobby-1
23823: PPUSH
23824: CALL_OW 88
// if Cornel then
23828: LD_EXP 49
23832: IFFALSE 23846
// Say ( Cornel , D6c-Corn-1 ) ;
23834: LD_EXP 49
23838: PPUSH
23839: LD_STRING D6c-Corn-1
23841: PPUSH
23842: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23846: LD_ADDR_VAR 0 4
23850: PUSH
23851: LD_INT 2
23853: PUSH
23854: LD_INT 22
23856: PUSH
23857: LD_INT 1
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 22
23866: PUSH
23867: LD_INT 4
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 26
23881: PUSH
23882: LD_INT 1
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 3
23891: PUSH
23892: LD_INT 25
23894: PUSH
23895: LD_INT 16
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PUSH
23902: LD_INT 25
23904: PUSH
23905: LD_INT 12
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PPUSH
23922: CALL_OW 69
23926: PUSH
23927: LD_VAR 0 11
23931: PUSH
23932: LD_EXP 38
23936: UNION
23937: PUSH
23938: LD_EXP 58
23942: UNION
23943: PUSH
23944: EMPTY
23945: LIST
23946: DIFF
23947: ST_TO_ADDR
// if tmp2 then
23948: LD_VAR 0 4
23952: IFFALSE 23970
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23954: LD_VAR 0 4
23958: PUSH
23959: LD_INT 1
23961: ARRAY
23962: PPUSH
23963: LD_STRING D6c-Sol1-1
23965: PPUSH
23966: CALL_OW 88
// if Lisa then
23970: LD_EXP 41
23974: IFFALSE 23988
// Say ( Lisa , D6c-Lisa-1 ) ;
23976: LD_EXP 41
23980: PPUSH
23981: LD_STRING D6c-Lisa-1
23983: PPUSH
23984: CALL_OW 88
// if Gary then
23988: LD_EXP 50
23992: IFFALSE 24006
// Say ( Gary , D6c-Gary-1 ) ;
23994: LD_EXP 50
23998: PPUSH
23999: LD_STRING D6c-Gary-1
24001: PPUSH
24002: CALL_OW 88
// if Donaldson then
24006: LD_EXP 42
24010: IFFALSE 24024
// Say ( Donaldson , D6c-Don-1 ) ;
24012: LD_EXP 42
24016: PPUSH
24017: LD_STRING D6c-Don-1
24019: PPUSH
24020: CALL_OW 88
// if tmp2 > 1 then
24024: LD_VAR 0 4
24028: PUSH
24029: LD_INT 1
24031: GREATER
24032: IFFALSE 24050
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24034: LD_VAR 0 4
24038: PUSH
24039: LD_INT 2
24041: ARRAY
24042: PPUSH
24043: LD_STRING D6c-Sol2-1
24045: PPUSH
24046: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24050: LD_VAR 0 11
24054: PPUSH
24055: LD_STRING D6c-Sol3-2
24057: PPUSH
24058: CALL_OW 88
// dwait ( 0 0$1 ) ;
24062: LD_INT 35
24064: PPUSH
24065: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24069: LD_EXP 38
24073: PPUSH
24074: LD_STRING D6c-JMM-2
24076: PPUSH
24077: CALL_OW 88
// DialogueOff ;
24081: CALL_OW 7
// Video ( false ) ;
24085: LD_INT 0
24087: PPUSH
24088: CALL 107197 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24092: LD_INT 22
24094: PUSH
24095: LD_INT 4
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PPUSH
24102: CALL_OW 69
24106: PPUSH
24107: LD_INT 1
24109: PPUSH
24110: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24114: LD_INT 4
24116: PPUSH
24117: LD_INT 4
24119: PPUSH
24120: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24124: LD_ADDR_VAR 0 1
24128: PUSH
24129: LD_INT 4
24131: PPUSH
24132: LD_INT 1
24134: PPUSH
24135: LD_INT 2
24137: PPUSH
24138: CALL 64428 0 3
24142: PUSH
24143: FOR_IN
24144: IFFALSE 24181
// if GetTech ( i , 1 ) <> state_researched then
24146: LD_VAR 0 1
24150: PPUSH
24151: LD_INT 1
24153: PPUSH
24154: CALL_OW 321
24158: PUSH
24159: LD_INT 2
24161: NONEQUAL
24162: IFFALSE 24179
// SetTech ( i , 1 , state_researched ) ;
24164: LD_VAR 0 1
24168: PPUSH
24169: LD_INT 1
24171: PPUSH
24172: LD_INT 2
24174: PPUSH
24175: CALL_OW 322
24179: GO 24143
24181: POP
24182: POP
// missionStage := 6 ;
24183: LD_ADDR_EXP 15
24187: PUSH
24188: LD_INT 6
24190: ST_TO_ADDR
// activeAttacks := true ;
24191: LD_ADDR_EXP 16
24195: PUSH
24196: LD_INT 1
24198: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24199: LD_STRING M2
24201: PPUSH
24202: CALL_OW 337
// SaveForQuickRestart ;
24206: CALL_OW 22
// wait ( 0 0$40 ) ;
24210: LD_INT 1400
24212: PPUSH
24213: CALL_OW 67
// DialogueOn ;
24217: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24221: LD_EXP 61
24225: PPUSH
24226: LD_STRING D7-Friend-1
24228: PPUSH
24229: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24233: LD_EXP 38
24237: PPUSH
24238: LD_STRING D7-JMM-1
24240: PPUSH
24241: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24245: LD_EXP 61
24249: PPUSH
24250: LD_STRING D7-Friend-2
24252: PPUSH
24253: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24257: LD_EXP 38
24261: PPUSH
24262: LD_STRING D7-JMM-2
24264: PPUSH
24265: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24269: LD_EXP 61
24273: PPUSH
24274: LD_STRING D7-Friend-3
24276: PPUSH
24277: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24281: LD_EXP 38
24285: PPUSH
24286: LD_STRING D7-JMM-3
24288: PPUSH
24289: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24293: LD_EXP 61
24297: PPUSH
24298: LD_STRING D7-Friend-4
24300: PPUSH
24301: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24305: LD_EXP 38
24309: PPUSH
24310: LD_STRING D7-JMM-4
24312: PPUSH
24313: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24317: LD_EXP 61
24321: PPUSH
24322: LD_STRING D7-Friend-5
24324: PPUSH
24325: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24329: LD_EXP 38
24333: PPUSH
24334: LD_STRING D7-JMM-5
24336: PPUSH
24337: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24341: LD_EXP 61
24345: PPUSH
24346: LD_STRING D7-Friend-6
24348: PPUSH
24349: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24353: LD_EXP 38
24357: PPUSH
24358: LD_STRING D7-JMM-6
24360: PPUSH
24361: CALL_OW 88
// DialogueOff ;
24365: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24369: LD_STRING Mlegion
24371: PPUSH
24372: CALL_OW 337
// RebuildKozlovFactory ;
24376: CALL 4816 0 0
// end ;
24380: PPOPN 13
24382: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24383: LD_EXP 20
24387: PUSH
24388: LD_EXP 57
24392: PPUSH
24393: CALL_OW 300
24397: AND
24398: IFFALSE 24440
24400: GO 24402
24402: DISABLE
// begin enable ;
24403: ENABLE
// if IsInUnit ( Powell ) then
24404: LD_EXP 57
24408: PPUSH
24409: CALL_OW 310
24413: IFFALSE 24431
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24415: LD_EXP 57
24419: PPUSH
24420: CALL_OW 310
24424: PPUSH
24425: CALL_OW 85
24429: GO 24440
// CenterOnUnits ( Powell ) ;
24431: LD_EXP 57
24435: PPUSH
24436: CALL_OW 85
// end ;
24440: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24441: LD_INT 22
24443: PUSH
24444: LD_INT 8
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: LD_INT 34
24453: PUSH
24454: LD_INT 48
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: PPUSH
24465: CALL_OW 69
24469: IFFALSE 24732
24471: GO 24473
24473: DISABLE
24474: LD_INT 0
24476: PPUSH
24477: PPUSH
// begin if missionStage < 9 then
24478: LD_EXP 15
24482: PUSH
24483: LD_INT 9
24485: LESS
24486: IFFALSE 24496
// missionStage := 9 ;
24488: LD_ADDR_EXP 15
24492: PUSH
24493: LD_INT 9
24495: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24496: LD_ADDR_VAR 0 1
24500: PUSH
24501: LD_INT 22
24503: PUSH
24504: LD_INT 8
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: PUSH
24511: LD_INT 34
24513: PUSH
24514: LD_INT 48
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PPUSH
24525: CALL_OW 69
24529: PUSH
24530: LD_INT 1
24532: ARRAY
24533: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24534: LD_INT 175
24536: PPUSH
24537: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24541: LD_EXP 12
24545: PUSH
24546: LD_EXP 3
24550: PUSH
24551: LD_INT 0
24553: PUSH
24554: LD_INT 2
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: IN
24561: OR
24562: IFFALSE 24585
// target := [ 68 , 108 , 1 ] else
24564: LD_ADDR_VAR 0 2
24568: PUSH
24569: LD_INT 68
24571: PUSH
24572: LD_INT 108
24574: PUSH
24575: LD_INT 1
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: LIST
24582: ST_TO_ADDR
24583: GO 24604
// target := [ 181 , 88 , 2 ] ;
24585: LD_ADDR_VAR 0 2
24589: PUSH
24590: LD_INT 181
24592: PUSH
24593: LD_INT 88
24595: PUSH
24596: LD_INT 2
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: LIST
24603: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24604: LD_VAR 0 1
24608: PPUSH
24609: LD_VAR 0 2
24613: PUSH
24614: LD_INT 1
24616: ARRAY
24617: PPUSH
24618: LD_VAR 0 2
24622: PUSH
24623: LD_INT 2
24625: ARRAY
24626: PPUSH
24627: CALL_OW 176
// if target [ 3 ] = 1 then
24631: LD_VAR 0 2
24635: PUSH
24636: LD_INT 3
24638: ARRAY
24639: PUSH
24640: LD_INT 1
24642: EQUAL
24643: IFFALSE 24659
// SayRadio ( Kurt , D12-Kurt-1 ) else
24645: LD_EXP 59
24649: PPUSH
24650: LD_STRING D12-Kurt-1
24652: PPUSH
24653: CALL_OW 94
24657: GO 24683
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24659: LD_EXP 59
24663: PPUSH
24664: LD_STRING D12a-Kurt-1
24666: PPUSH
24667: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24671: LD_EXP 73
24675: PPUSH
24676: LD_STRING D12a-Roth-1
24678: PPUSH
24679: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24683: LD_INT 350
24685: PPUSH
24686: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24690: LD_VAR 0 1
24694: PPUSH
24695: LD_INT 22
24697: PUSH
24698: LD_INT 8
24700: PUSH
24701: EMPTY
24702: LIST
24703: LIST
24704: PUSH
24705: LD_INT 30
24707: PUSH
24708: LD_INT 3
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PPUSH
24719: CALL_OW 69
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: CALL_OW 228
// end ;
24732: PPOPN 2
24734: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24735: LD_INT 22
24737: PUSH
24738: LD_INT 8
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 21
24747: PUSH
24748: LD_INT 1
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 23
24757: PUSH
24758: LD_INT 2
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: LIST
24769: PPUSH
24770: CALL_OW 69
24774: PUSH
24775: LD_INT 9
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: LD_INT 7
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_OWVAR 67
24793: ARRAY
24794: LESSEQUAL
24795: PUSH
24796: LD_INT 22
24798: PUSH
24799: LD_INT 8
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: LD_INT 34
24808: PUSH
24809: LD_INT 48
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PPUSH
24820: CALL_OW 69
24824: NOT
24825: AND
24826: PUSH
24827: LD_EXP 59
24831: PPUSH
24832: CALL_OW 302
24836: AND
24837: IFFALSE 25142
24839: GO 24841
24841: DISABLE
// begin DialogueOn ;
24842: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24846: LD_EXP 38
24850: PPUSH
24851: LD_STRING D13-JMM-1
24853: PPUSH
24854: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24858: LD_EXP 59
24862: PPUSH
24863: LD_STRING D13-Kurt-1
24865: PPUSH
24866: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24870: LD_EXP 38
24874: PPUSH
24875: LD_STRING D13-JMM-2
24877: PPUSH
24878: CALL_OW 88
// if FakeInfo then
24882: LD_EXP 12
24886: IFFALSE 24906
// begin Say ( Kurt , D13-Kurt-2 ) ;
24888: LD_EXP 59
24892: PPUSH
24893: LD_STRING D13-Kurt-2
24895: PPUSH
24896: CALL_OW 88
// DialogueOff ;
24900: CALL_OW 7
// exit ;
24904: GO 25142
// end ; if not KurtStatus then
24906: LD_EXP 3
24910: NOT
24911: IFFALSE 24927
// Say ( Kurt , D13-Kurt-2b ) else
24913: LD_EXP 59
24917: PPUSH
24918: LD_STRING D13-Kurt-2b
24920: PPUSH
24921: CALL_OW 88
24925: GO 24939
// Say ( Kurt , D13-Kurt-2a ) ;
24927: LD_EXP 59
24931: PPUSH
24932: LD_STRING D13-Kurt-2a
24934: PPUSH
24935: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24939: LD_EXP 38
24943: PPUSH
24944: LD_STRING D13-JMM-3
24946: PPUSH
24947: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24951: LD_EXP 59
24955: PPUSH
24956: LD_STRING D13-Kurt-3
24958: PPUSH
24959: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24963: LD_EXP 38
24967: PPUSH
24968: LD_STRING D13-JMM-4
24970: PPUSH
24971: CALL_OW 88
// DialogueOff ;
24975: CALL_OW 7
// MC_Kill ( 3 ) ;
24979: LD_INT 3
24981: PPUSH
24982: CALL 34457 0 1
// KillUnit ( Kozlov ) ;
24986: LD_EXP 60
24990: PPUSH
24991: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24995: LD_INT 22
24997: PUSH
24998: LD_INT 8
25000: PUSH
25001: EMPTY
25002: LIST
25003: LIST
25004: PUSH
25005: LD_INT 21
25007: PUSH
25008: LD_INT 3
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 23
25017: PUSH
25018: LD_INT 3
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PUSH
25025: LD_INT 30
25027: PUSH
25028: LD_INT 3
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 1
25048: ARRAY
25049: PPUSH
25050: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
25054: LD_INT 8
25056: PPUSH
25057: LD_INT 1
25059: PPUSH
25060: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
25064: LD_INT 22
25066: PUSH
25067: LD_INT 8
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PPUSH
25074: CALL_OW 69
25078: PPUSH
25079: LD_INT 1
25081: PPUSH
25082: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25086: LD_INT 8
25088: PPUSH
25089: LD_INT 1
25091: PPUSH
25092: LD_INT 1
25094: PPUSH
25095: LD_INT 1
25097: PPUSH
25098: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25102: LD_EXP 61
25106: PPUSH
25107: LD_INT 37
25109: PPUSH
25110: LD_INT 1
25112: PPUSH
25113: LD_INT 0
25115: PPUSH
25116: CALL_OW 48
// wait ( 0 0$1 ) ;
25120: LD_INT 35
25122: PPUSH
25123: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25127: LD_EXP 61
25131: PPUSH
25132: LD_INT 60
25134: PPUSH
25135: LD_INT 95
25137: PPUSH
25138: CALL_OW 111
// end ;
25142: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25143: LD_INT 22
25145: PUSH
25146: LD_INT 8
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 21
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PPUSH
25167: CALL_OW 69
25171: PUSH
25172: LD_INT 0
25174: EQUAL
25175: IFFALSE 25195
25177: GO 25179
25179: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25180: LD_STRING MlegionOut
25182: PPUSH
25183: CALL_OW 337
// legionDestroyed := true ;
25187: LD_ADDR_EXP 22
25191: PUSH
25192: LD_INT 1
25194: ST_TO_ADDR
// end ;
25195: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25196: LD_INT 1
25198: PPUSH
25199: LD_EXP 61
25203: PPUSH
25204: CALL_OW 292
25208: IFFALSE 25508
25210: GO 25212
25212: DISABLE
25213: LD_INT 0
25215: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
25216: LD_EXP 61
25220: PPUSH
25221: CALL_OW 87
// DialogueOn ;
25225: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25229: LD_EXP 38
25233: PPUSH
25234: LD_STRING D14-JMM-1
25236: PPUSH
25237: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25241: LD_EXP 61
25245: PPUSH
25246: LD_STRING D14-Friend-1
25248: PPUSH
25249: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25253: LD_EXP 38
25257: PPUSH
25258: LD_STRING D14-JMM-2
25260: PPUSH
25261: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25265: LD_EXP 61
25269: PPUSH
25270: LD_STRING D14-Friend-2
25272: PPUSH
25273: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25277: LD_EXP 38
25281: PPUSH
25282: LD_STRING D14-JMM-3
25284: PPUSH
25285: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25289: LD_EXP 61
25293: PPUSH
25294: LD_STRING D14-Friend-3
25296: PPUSH
25297: CALL_OW 88
// DialogueOff ;
25301: CALL_OW 7
// dec = Query ( Q14 ) ;
25305: LD_ADDR_VAR 0 1
25309: PUSH
25310: LD_STRING Q14
25312: PPUSH
25313: CALL_OW 97
25317: ST_TO_ADDR
// if dec = 1 then
25318: LD_VAR 0 1
25322: PUSH
25323: LD_INT 1
25325: EQUAL
25326: IFFALSE 25360
// begin DialogueOn ;
25328: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25332: LD_EXP 38
25336: PPUSH
25337: LD_STRING D14a-JMM-1
25339: PPUSH
25340: CALL_OW 88
// DialogueOff ;
25344: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25348: LD_EXP 61
25352: PPUSH
25353: LD_INT 1
25355: PPUSH
25356: CALL_OW 235
// end ; if dec = 2 then
25360: LD_VAR 0 1
25364: PUSH
25365: LD_INT 2
25367: EQUAL
25368: IFFALSE 25414
// begin DialogueOn ;
25370: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25374: LD_EXP 38
25378: PPUSH
25379: LD_STRING D14b-JMM-1
25381: PPUSH
25382: CALL_OW 88
// DialogueOff ;
25386: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25390: LD_EXP 61
25394: PPUSH
25395: LD_INT 9
25397: PPUSH
25398: LD_INT 2
25400: PPUSH
25401: CALL_OW 111
// AddComHold ( Friend ) ;
25405: LD_EXP 61
25409: PPUSH
25410: CALL_OW 200
// end ; if dec = 3 then
25414: LD_VAR 0 1
25418: PUSH
25419: LD_INT 3
25421: EQUAL
25422: IFFALSE 25508
// begin DialogueOn ;
25424: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25428: LD_EXP 38
25432: PPUSH
25433: LD_STRING D14c-JMM-1
25435: PPUSH
25436: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25440: LD_EXP 61
25444: PPUSH
25445: LD_STRING D14c-Friend-1
25447: PPUSH
25448: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25452: LD_EXP 38
25456: PPUSH
25457: LD_STRING D14c-JMM-2
25459: PPUSH
25460: CALL_OW 88
// DialogueOff ;
25464: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25468: LD_INT 8
25470: PPUSH
25471: LD_INT 1
25473: PPUSH
25474: LD_INT 2
25476: PPUSH
25477: LD_INT 1
25479: PPUSH
25480: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25484: LD_EXP 61
25488: PPUSH
25489: LD_INT 9
25491: PPUSH
25492: LD_INT 2
25494: PPUSH
25495: CALL_OW 111
// AddComHold ( Friend ) ;
25499: LD_EXP 61
25503: PPUSH
25504: CALL_OW 200
// end ; end ;
25508: PPOPN 1
25510: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25511: LD_INT 9
25513: PPUSH
25514: LD_INT 2
25516: PPUSH
25517: CALL_OW 428
25521: PUSH
25522: LD_EXP 61
25526: EQUAL
25527: PUSH
25528: LD_EXP 61
25532: PPUSH
25533: CALL_OW 255
25537: PUSH
25538: LD_INT 8
25540: EQUAL
25541: AND
25542: IFFALSE 25556
25544: GO 25546
25546: DISABLE
// RemoveUnit ( Friend ) ;
25547: LD_EXP 61
25551: PPUSH
25552: CALL_OW 64
25556: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25557: LD_EXP 14
25561: PUSH
25562: LD_INT 31500
25564: GREATEREQUAL
25565: PUSH
25566: LD_EXP 7
25570: AND
25571: PUSH
25572: LD_EXP 2
25576: AND
25577: IFFALSE 26007
25579: GO 25581
25581: DISABLE
25582: LD_INT 0
25584: PPUSH
25585: PPUSH
25586: PPUSH
// begin missionStage := 7 ;
25587: LD_ADDR_EXP 15
25591: PUSH
25592: LD_INT 7
25594: ST_TO_ADDR
// uc_side = 1 ;
25595: LD_ADDR_OWVAR 20
25599: PUSH
25600: LD_INT 1
25602: ST_TO_ADDR
// uc_nation = 1 ;
25603: LD_ADDR_OWVAR 21
25607: PUSH
25608: LD_INT 1
25610: ST_TO_ADDR
// for i = 1 to 5 do
25611: LD_ADDR_VAR 0 1
25615: PUSH
25616: DOUBLE
25617: LD_INT 1
25619: DEC
25620: ST_TO_ADDR
25621: LD_INT 5
25623: PUSH
25624: FOR_TO
25625: IFFALSE 25721
// begin vc_engine = 3 ;
25627: LD_ADDR_OWVAR 39
25631: PUSH
25632: LD_INT 3
25634: ST_TO_ADDR
// vc_control = 3 ;
25635: LD_ADDR_OWVAR 38
25639: PUSH
25640: LD_INT 3
25642: ST_TO_ADDR
// vc_chassis = 3 ;
25643: LD_ADDR_OWVAR 37
25647: PUSH
25648: LD_INT 3
25650: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25651: LD_ADDR_OWVAR 40
25655: PUSH
25656: LD_INT 5
25658: PUSH
25659: LD_INT 9
25661: PUSH
25662: LD_INT 7
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: LIST
25669: PUSH
25670: LD_INT 1
25672: PPUSH
25673: LD_INT 3
25675: PPUSH
25676: CALL_OW 12
25680: ARRAY
25681: ST_TO_ADDR
// veh = CreateVehicle ;
25682: LD_ADDR_VAR 0 2
25686: PUSH
25687: CALL_OW 45
25691: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25692: LD_VAR 0 2
25696: PPUSH
25697: LD_INT 1
25699: PPUSH
25700: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25704: LD_VAR 0 2
25708: PPUSH
25709: LD_INT 19
25711: PPUSH
25712: LD_INT 0
25714: PPUSH
25715: CALL_OW 49
// end ;
25719: GO 25624
25721: POP
25722: POP
// vc_engine = 3 ;
25723: LD_ADDR_OWVAR 39
25727: PUSH
25728: LD_INT 3
25730: ST_TO_ADDR
// vc_control = 1 ;
25731: LD_ADDR_OWVAR 38
25735: PUSH
25736: LD_INT 1
25738: ST_TO_ADDR
// vc_chassis = 3 ;
25739: LD_ADDR_OWVAR 37
25743: PUSH
25744: LD_INT 3
25746: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25747: LD_ADDR_OWVAR 40
25751: PUSH
25752: LD_INT 5
25754: PUSH
25755: LD_INT 9
25757: PUSH
25758: LD_INT 7
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 1
25768: PPUSH
25769: LD_INT 3
25771: PPUSH
25772: CALL_OW 12
25776: ARRAY
25777: ST_TO_ADDR
// vehG = CreateVehicle ;
25778: LD_ADDR_VAR 0 3
25782: PUSH
25783: CALL_OW 45
25787: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25788: LD_VAR 0 3
25792: PPUSH
25793: LD_INT 1
25795: PPUSH
25796: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25800: LD_VAR 0 3
25804: PPUSH
25805: LD_INT 19
25807: PPUSH
25808: LD_INT 0
25810: PPUSH
25811: CALL_OW 49
// if JMMGirl = 1 then
25815: LD_EXP 7
25819: PUSH
25820: LD_INT 1
25822: EQUAL
25823: IFFALSE 25879
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25825: LD_ADDR_EXP 39
25829: PUSH
25830: LD_STRING Joan
25832: PPUSH
25833: LD_INT 1
25835: PPUSH
25836: LD_STRING 14_
25838: PPUSH
25839: CALL 64365 0 3
25843: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25844: LD_EXP 39
25848: PPUSH
25849: LD_VAR 0 3
25853: PPUSH
25854: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25858: LD_VAR 0 3
25862: PPUSH
25863: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25867: LD_EXP 39
25871: PPUSH
25872: LD_STRING D10BW-Joan-1
25874: PPUSH
25875: CALL_OW 94
// end ; if JMMGirl = 2 then
25879: LD_EXP 7
25883: PUSH
25884: LD_INT 2
25886: EQUAL
25887: IFFALSE 25943
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25889: LD_ADDR_EXP 41
25893: PUSH
25894: LD_STRING Lisa
25896: PPUSH
25897: LD_INT 1
25899: PPUSH
25900: LD_STRING 14_
25902: PPUSH
25903: CALL 64365 0 3
25907: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25908: LD_EXP 41
25912: PPUSH
25913: LD_VAR 0 3
25917: PPUSH
25918: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25922: LD_VAR 0 3
25926: PPUSH
25927: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25931: LD_EXP 41
25935: PPUSH
25936: LD_STRING D10BW-Lisa-1
25938: PPUSH
25939: CALL_OW 94
// end ; if JMMGirl = 3 then
25943: LD_EXP 7
25947: PUSH
25948: LD_INT 3
25950: EQUAL
25951: IFFALSE 26007
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25953: LD_ADDR_EXP 53
25957: PUSH
25958: LD_STRING Connie
25960: PPUSH
25961: LD_INT 1
25963: PPUSH
25964: LD_STRING 14_
25966: PPUSH
25967: CALL 64365 0 3
25971: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25972: LD_EXP 53
25976: PPUSH
25977: LD_VAR 0 3
25981: PPUSH
25982: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25986: LD_VAR 0 3
25990: PPUSH
25991: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
25995: LD_EXP 53
25999: PPUSH
26000: LD_STRING D10BW-Con-1
26002: PPUSH
26003: CALL_OW 94
// end ; end ;
26007: PPOPN 3
26009: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26010: LD_EXP 14
26014: PUSH
26015: LD_INT 94500
26017: GREATEREQUAL
26018: IFFALSE 26430
26020: GO 26022
26022: DISABLE
26023: LD_INT 0
26025: PPUSH
26026: PPUSH
26027: PPUSH
// begin tmp := PrepareStevensSquad ;
26028: LD_ADDR_VAR 0 3
26032: PUSH
26033: CALL 2190 0 0
26037: ST_TO_ADDR
// if not tmp then
26038: LD_VAR 0 3
26042: NOT
26043: IFFALSE 26047
// exit ;
26045: GO 26430
// uc_side := 1 ;
26047: LD_ADDR_OWVAR 20
26051: PUSH
26052: LD_INT 1
26054: ST_TO_ADDR
// uc_nation := 1 ;
26055: LD_ADDR_OWVAR 21
26059: PUSH
26060: LD_INT 1
26062: ST_TO_ADDR
// for i in tmp do
26063: LD_ADDR_VAR 0 1
26067: PUSH
26068: LD_VAR 0 3
26072: PUSH
26073: FOR_IN
26074: IFFALSE 26171
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26076: LD_INT 3
26078: PPUSH
26079: LD_INT 3
26081: PPUSH
26082: LD_INT 1
26084: PPUSH
26085: LD_INT 5
26087: PUSH
26088: LD_INT 9
26090: PUSH
26091: LD_INT 7
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: LIST
26098: PUSH
26099: LD_INT 1
26101: PPUSH
26102: LD_INT 3
26104: PPUSH
26105: CALL_OW 12
26109: ARRAY
26110: PPUSH
26111: LD_INT 40
26113: PPUSH
26114: CALL 71480 0 5
// veh := CreateVehicle ;
26118: LD_ADDR_VAR 0 2
26122: PUSH
26123: CALL_OW 45
26127: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26128: LD_VAR 0 2
26132: PPUSH
26133: LD_INT 1
26135: PPUSH
26136: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26140: LD_VAR 0 2
26144: PPUSH
26145: LD_INT 19
26147: PPUSH
26148: LD_INT 0
26150: PPUSH
26151: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26155: LD_VAR 0 1
26159: PPUSH
26160: LD_VAR 0 2
26164: PPUSH
26165: CALL_OW 52
// end ;
26169: GO 26073
26171: POP
26172: POP
// missionStage := 8 ;
26173: LD_ADDR_EXP 15
26177: PUSH
26178: LD_INT 8
26180: ST_TO_ADDR
// DialogueOn ;
26181: CALL_OW 6
// if Stevens then
26185: LD_EXP 40
26189: IFFALSE 26303
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26191: LD_EXP 40
26195: PPUSH
26196: CALL_OW 310
26200: PPUSH
26201: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26205: LD_EXP 40
26209: PPUSH
26210: LD_STRING D8-Huck-1
26212: PPUSH
26213: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26217: LD_EXP 38
26221: PPUSH
26222: LD_STRING D8-JMM-1
26224: PPUSH
26225: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26229: LD_EXP 40
26233: PPUSH
26234: LD_STRING D8-Huck-2
26236: PPUSH
26237: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26241: LD_EXP 38
26245: PPUSH
26246: LD_STRING D8-JMM-2
26248: PPUSH
26249: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26253: LD_EXP 40
26257: PPUSH
26258: LD_STRING D8-Huck-3
26260: PPUSH
26261: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26265: LD_EXP 38
26269: PPUSH
26270: LD_STRING D8-JMM-3
26272: PPUSH
26273: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26277: LD_EXP 40
26281: PPUSH
26282: LD_STRING D8-Huck-4
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26289: LD_EXP 38
26293: PPUSH
26294: LD_STRING D8-JMM-4
26296: PPUSH
26297: CALL_OW 88
// end else
26301: GO 26413
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26303: LD_EXP 54
26307: PPUSH
26308: CALL_OW 310
26312: PPUSH
26313: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26317: LD_EXP 54
26321: PPUSH
26322: LD_STRING D8-Huck-1
26324: PPUSH
26325: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26329: LD_EXP 38
26333: PPUSH
26334: LD_STRING D8-JMM-1a
26336: PPUSH
26337: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26341: LD_EXP 54
26345: PPUSH
26346: LD_STRING D8-Huck-2
26348: PPUSH
26349: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26353: LD_EXP 38
26357: PPUSH
26358: LD_STRING D8-JMM-2
26360: PPUSH
26361: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26365: LD_EXP 54
26369: PPUSH
26370: LD_STRING D8-Huck-3
26372: PPUSH
26373: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26377: LD_EXP 38
26381: PPUSH
26382: LD_STRING D8-JMM-3
26384: PPUSH
26385: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26389: LD_EXP 54
26393: PPUSH
26394: LD_STRING D8-Huck-4
26396: PPUSH
26397: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26401: LD_EXP 38
26405: PPUSH
26406: LD_STRING D8-JMM-4
26408: PPUSH
26409: CALL_OW 88
// end ; DialogueOff ;
26413: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26417: LD_INT 25
26419: PPUSH
26420: LD_INT 1
26422: PPUSH
26423: LD_INT 1
26425: PPUSH
26426: CALL_OW 322
// end ;
26430: PPOPN 3
26432: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26433: LD_INT 1
26435: PPUSH
26436: LD_EXP 70
26440: PPUSH
26441: CALL_OW 292
26445: IFFALSE 26696
26447: GO 26449
26449: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26450: LD_EXP 70
26454: PPUSH
26455: CALL_OW 87
// DialogueOn ;
26459: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26463: LD_EXP 38
26467: PPUSH
26468: LD_STRING D10nB-JMM-1
26470: PPUSH
26471: CALL_OW 88
// if BurlakStatus = 1 then
26475: LD_EXP 9
26479: PUSH
26480: LD_INT 1
26482: EQUAL
26483: IFFALSE 26497
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26485: LD_EXP 69
26489: PPUSH
26490: LD_STRING D10nB-Vse-1a
26492: PPUSH
26493: CALL_OW 94
// end ; if BurlakStatus = 0 then
26497: LD_EXP 9
26501: PUSH
26502: LD_INT 0
26504: EQUAL
26505: IFFALSE 26519
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26507: LD_EXP 69
26511: PPUSH
26512: LD_STRING D10nB-Vse-1
26514: PPUSH
26515: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26519: LD_EXP 38
26523: PPUSH
26524: LD_STRING D10nB-JMM-2
26526: PPUSH
26527: CALL_OW 88
// if KappaStatus then
26531: LD_EXP 2
26535: IFFALSE 26549
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26537: LD_EXP 69
26541: PPUSH
26542: LD_STRING D10nB-Vse-5a
26544: PPUSH
26545: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26549: LD_EXP 2
26553: NOT
26554: PUSH
26555: LD_EXP 6
26559: PUSH
26560: LD_INT 0
26562: EQUAL
26563: AND
26564: IFFALSE 26692
// begin if JMMGirl = 1 then
26566: LD_EXP 7
26570: PUSH
26571: LD_INT 1
26573: EQUAL
26574: IFFALSE 26624
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26576: LD_EXP 69
26580: PPUSH
26581: LD_STRING D10nB-Vse-2
26583: PPUSH
26584: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26588: LD_EXP 38
26592: PPUSH
26593: LD_STRING D10nB-JMM-3
26595: PPUSH
26596: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26600: LD_EXP 69
26604: PPUSH
26605: LD_STRING D10nB-Vse-3
26607: PPUSH
26608: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26612: LD_EXP 38
26616: PPUSH
26617: LD_STRING D10nB-JMM-4
26619: PPUSH
26620: CALL_OW 88
// end ; if JMMGirl = 2 then
26624: LD_EXP 7
26628: PUSH
26629: LD_INT 2
26631: EQUAL
26632: IFFALSE 26658
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26634: LD_EXP 69
26638: PPUSH
26639: LD_STRING D10nB-Vse-4
26641: PPUSH
26642: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26646: LD_EXP 38
26650: PPUSH
26651: LD_STRING D10nB-JMM-5
26653: PPUSH
26654: CALL_OW 88
// end ; if JMMGirl = 3 then
26658: LD_EXP 7
26662: PUSH
26663: LD_INT 3
26665: EQUAL
26666: IFFALSE 26692
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26668: LD_EXP 69
26672: PPUSH
26673: LD_STRING D10nB-Vse-5
26675: PPUSH
26676: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26680: LD_EXP 38
26684: PPUSH
26685: LD_STRING D10nB-JMM-6
26687: PPUSH
26688: CALL_OW 88
// end ; end ; DialogueOff ;
26692: CALL_OW 7
// end ;
26696: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26697: LD_EXP 14
26701: PUSH
26702: LD_INT 115500
26704: GREATEREQUAL
26705: IFFALSE 27070
26707: GO 26709
26709: DISABLE
26710: LD_INT 0
26712: PPUSH
// begin missionStage := 10 ;
26713: LD_ADDR_EXP 15
26717: PUSH
26718: LD_INT 10
26720: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26721: LD_ADDR_VAR 0 1
26725: PUSH
26726: LD_INT 22
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 26
26738: PUSH
26739: LD_INT 1
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 3
26748: PUSH
26749: LD_INT 25
26751: PUSH
26752: LD_INT 12
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: LD_INT 3
26765: PUSH
26766: LD_INT 25
26768: PUSH
26769: LD_INT 16
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: PPUSH
26786: CALL_OW 69
26790: PUSH
26791: LD_EXP 38
26795: PUSH
26796: LD_EXP 59
26800: PUSH
26801: LD_EXP 40
26805: PUSH
26806: LD_EXP 54
26810: PUSH
26811: LD_EXP 41
26815: PUSH
26816: LD_EXP 42
26820: PUSH
26821: LD_EXP 43
26825: PUSH
26826: LD_EXP 44
26830: PUSH
26831: LD_EXP 45
26835: PUSH
26836: LD_EXP 46
26840: PUSH
26841: LD_EXP 47
26845: PUSH
26846: LD_EXP 48
26850: PUSH
26851: LD_EXP 49
26855: PUSH
26856: LD_EXP 50
26860: PUSH
26861: LD_EXP 51
26865: PUSH
26866: LD_EXP 52
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: LIST
26875: LIST
26876: LIST
26877: LIST
26878: LIST
26879: LIST
26880: LIST
26881: LIST
26882: LIST
26883: LIST
26884: LIST
26885: LIST
26886: LIST
26887: LIST
26888: DIFF
26889: ST_TO_ADDR
// if not tmp and Brown then
26890: LD_VAR 0 1
26894: NOT
26895: PUSH
26896: LD_EXP 46
26900: AND
26901: IFFALSE 26916
// tmp := [ Brown ] ;
26903: LD_ADDR_VAR 0 1
26907: PUSH
26908: LD_EXP 46
26912: PUSH
26913: EMPTY
26914: LIST
26915: ST_TO_ADDR
// DialogueOn ;
26916: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26920: LD_VAR 0 1
26924: PUSH
26925: LD_INT 1
26927: ARRAY
26928: PPUSH
26929: LD_STRING D11-Sol1-1
26931: PPUSH
26932: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26936: LD_EXP 63
26940: PPUSH
26941: LD_STRING D11-Pla-1
26943: PPUSH
26944: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26948: LD_EXP 64
26952: PPUSH
26953: LD_STRING D11-Kov-1
26955: PPUSH
26956: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26960: LD_EXP 63
26964: PPUSH
26965: LD_STRING D11-Pla-2
26967: PPUSH
26968: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26972: LD_VAR 0 1
26976: PUSH
26977: LD_INT 1
26979: ARRAY
26980: PPUSH
26981: LD_STRING D11-Sol1-2
26983: PPUSH
26984: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26988: LD_EXP 38
26992: PPUSH
26993: LD_STRING D11-JMM-2
26995: PPUSH
26996: CALL_OW 88
// DialogueOff ;
27000: CALL_OW 7
// allowBehemothConstruct := true ;
27004: LD_ADDR_EXP 25
27008: PUSH
27009: LD_INT 1
27011: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27012: LD_STRING M4
27014: PPUSH
27015: CALL_OW 337
// BuildBehemoths ;
27019: CALL 7620 0 0
// repeat wait ( 15 15$00 ) ;
27023: LD_INT 31500
27025: PPUSH
27026: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27030: LD_EXP 27
27034: IFFALSE 27038
// break ;
27036: GO 27070
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27038: LD_INT 267
27040: PPUSH
27041: CALL_OW 274
27045: PPUSH
27046: LD_INT 1
27048: PPUSH
27049: CALL_OW 275
27053: PUSH
27054: LD_INT 1000
27056: GREATEREQUAL
27057: IFFALSE 27063
// BuildBehemoths ;
27059: CALL 7620 0 0
// until not behemothBuilders ;
27063: LD_EXP 72
27067: NOT
27068: IFFALSE 27023
// end ;
27070: PPOPN 1
27072: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27073: LD_EXP 72
27077: NOT
27078: PUSH
27079: LD_EXP 28
27083: NOT
27084: AND
27085: PUSH
27086: LD_EXP 25
27090: AND
27091: IFFALSE 27111
27093: GO 27095
27095: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27096: LD_STRING M4a
27098: PPUSH
27099: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27103: LD_ADDR_EXP 27
27107: PUSH
27108: LD_INT 1
27110: ST_TO_ADDR
// end ;
27111: END
// every 0 0$1 trigger behemothDone do
27112: LD_EXP 28
27116: IFFALSE 27128
27118: GO 27120
27120: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27121: LD_STRING M4b
27123: PPUSH
27124: CALL_OW 337
27128: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27129: LD_EXP 29
27133: NOT
27134: IFFALSE 27330
27136: GO 27138
27138: DISABLE
27139: LD_INT 0
27141: PPUSH
27142: PPUSH
// begin enable ;
27143: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27144: LD_ADDR_VAR 0 1
27148: PUSH
27149: LD_INT 3
27151: PPUSH
27152: CALL 107273 0 1
27156: ST_TO_ADDR
// if not tmp and not behemothDone then
27157: LD_VAR 0 1
27161: NOT
27162: PUSH
27163: LD_EXP 28
27167: NOT
27168: AND
27169: IFFALSE 27205
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27171: LD_ADDR_VAR 0 1
27175: PUSH
27176: LD_INT 22
27178: PUSH
27179: LD_INT 3
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 30
27188: PUSH
27189: LD_INT 37
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PPUSH
27200: CALL_OW 69
27204: ST_TO_ADDR
// if not tmp then
27205: LD_VAR 0 1
27209: NOT
27210: IFFALSE 27214
// exit ;
27212: GO 27330
// for i in tmp do
27214: LD_ADDR_VAR 0 2
27218: PUSH
27219: LD_VAR 0 1
27223: PUSH
27224: FOR_IN
27225: IFFALSE 27328
// if See ( 1 , i ) then
27227: LD_INT 1
27229: PPUSH
27230: LD_VAR 0 2
27234: PPUSH
27235: CALL_OW 292
27239: IFFALSE 27326
// begin if GetType ( i ) = unit_building then
27241: LD_VAR 0 2
27245: PPUSH
27246: CALL_OW 247
27250: PUSH
27251: LD_INT 3
27253: EQUAL
27254: IFFALSE 27292
// begin CenterNowOnUnits ( i ) ;
27256: LD_VAR 0 2
27260: PPUSH
27261: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27265: LD_EXP 38
27269: PPUSH
27270: LD_STRING D17a-JMM-1
27272: PPUSH
27273: CALL_OW 88
// seeBehemoth := true ;
27277: LD_ADDR_EXP 29
27281: PUSH
27282: LD_INT 1
27284: ST_TO_ADDR
// disable ;
27285: DISABLE
// exit ;
27286: POP
27287: POP
27288: GO 27330
// end else
27290: GO 27326
// begin CenterNowOnUnits ( i ) ;
27292: LD_VAR 0 2
27296: PPUSH
27297: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27301: LD_EXP 38
27305: PPUSH
27306: LD_STRING D17b-JMM-1
27308: PPUSH
27309: CALL_OW 88
// seeBehemoth := true ;
27313: LD_ADDR_EXP 29
27317: PUSH
27318: LD_INT 1
27320: ST_TO_ADDR
// disable ;
27321: DISABLE
// exit ;
27322: POP
27323: POP
27324: GO 27330
// end ; end ;
27326: GO 27224
27328: POP
27329: POP
// end ;
27330: PPOPN 2
27332: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27333: LD_EXP 14
27337: PUSH
27338: LD_INT 116550
27340: GREATEREQUAL
27341: IFFALSE 28517
27343: GO 27345
27345: DISABLE
27346: LD_INT 0
27348: PPUSH
27349: PPUSH
27350: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27351: LD_INT 2
27353: PPUSH
27354: LD_INT 23
27356: PUSH
27357: LD_INT 3
27359: PUSH
27360: LD_INT 3
27362: PUSH
27363: LD_INT 48
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: PUSH
27372: EMPTY
27373: LIST
27374: PPUSH
27375: CALL 58021 0 2
// repeat wait ( 0 0$1 ) ;
27379: LD_INT 35
27381: PPUSH
27382: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27386: LD_INT 22
27388: PUSH
27389: LD_INT 3
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 34
27398: PUSH
27399: LD_INT 48
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PPUSH
27410: CALL_OW 69
27414: IFFALSE 27379
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27416: LD_ADDR_VAR 0 1
27420: PUSH
27421: LD_INT 22
27423: PUSH
27424: LD_INT 3
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 34
27433: PUSH
27434: LD_INT 48
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PPUSH
27445: CALL_OW 69
27449: PUSH
27450: LD_INT 1
27452: ARRAY
27453: ST_TO_ADDR
// missionStage := 12 ;
27454: LD_ADDR_EXP 15
27458: PUSH
27459: LD_INT 12
27461: ST_TO_ADDR
// platonovHasBomb := true ;
27462: LD_ADDR_EXP 30
27466: PUSH
27467: LD_INT 1
27469: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27470: LD_VAR 0 1
27474: PPUSH
27475: LD_INT 181
27477: PPUSH
27478: LD_INT 86
27480: PPUSH
27481: CALL_OW 171
// AddComHold ( bomb ) ;
27485: LD_VAR 0 1
27489: PPUSH
27490: CALL_OW 200
// wait ( 0 0$10 ) ;
27494: LD_INT 350
27496: PPUSH
27497: CALL_OW 67
// DialogueOn ;
27501: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27505: LD_EXP 63
27509: PPUSH
27510: LD_STRING D15-Pla-1
27512: PPUSH
27513: CALL_OW 94
// dec = Query ( Q15a ) ;
27517: LD_ADDR_VAR 0 2
27521: PUSH
27522: LD_STRING Q15a
27524: PPUSH
27525: CALL_OW 97
27529: ST_TO_ADDR
// if dec = 1 then
27530: LD_VAR 0 2
27534: PUSH
27535: LD_INT 1
27537: EQUAL
27538: IFFALSE 27561
// begin Say ( JMM , D15a-JMM-1 ) ;
27540: LD_EXP 38
27544: PPUSH
27545: LD_STRING D15a-JMM-1
27547: PPUSH
27548: CALL_OW 88
// YouLost ( Surrender ) ;
27552: LD_STRING Surrender
27554: PPUSH
27555: CALL_OW 104
// exit ;
27559: GO 28517
// end ; if dec = 2 then
27561: LD_VAR 0 2
27565: PUSH
27566: LD_INT 2
27568: EQUAL
27569: IFFALSE 27638
// begin Say ( JMM , D15b-JMM-1 ) ;
27571: LD_EXP 38
27575: PPUSH
27576: LD_STRING D15b-JMM-1
27578: PPUSH
27579: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27583: LD_EXP 63
27587: PPUSH
27588: LD_STRING D15b-Pla-1
27590: PPUSH
27591: CALL_OW 94
// DialogueOff ;
27595: CALL_OW 7
// wait ( 3 3$00 ) ;
27599: LD_INT 6300
27601: PPUSH
27602: CALL_OW 67
// DialogueOn ;
27606: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27610: LD_EXP 38
27614: PPUSH
27615: LD_STRING D15d-JMM-1a
27617: PPUSH
27618: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27622: LD_EXP 63
27626: PPUSH
27627: LD_STRING D15d-Pla-1
27629: PPUSH
27630: CALL_OW 94
// DialogueOff ;
27634: CALL_OW 7
// end ; if dec = 3 then
27638: LD_VAR 0 2
27642: PUSH
27643: LD_INT 3
27645: EQUAL
27646: IFFALSE 27700
// begin Say ( JMM , D15c-JMM-1 ) ;
27648: LD_EXP 38
27652: PPUSH
27653: LD_STRING D15c-JMM-1
27655: PPUSH
27656: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27660: LD_EXP 63
27664: PPUSH
27665: LD_STRING D15c-Pla-1
27667: PPUSH
27668: CALL_OW 94
// DialogueOff ;
27672: CALL_OW 7
// wait ( 0 0$15 ) ;
27676: LD_INT 525
27678: PPUSH
27679: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27683: LD_VAR 0 1
27687: PPUSH
27688: LD_INT 60
27690: PPUSH
27691: LD_INT 95
27693: PPUSH
27694: CALL_OW 116
// exit ;
27698: GO 28517
// end ; if dec = 4 then
27700: LD_VAR 0 2
27704: PUSH
27705: LD_INT 4
27707: EQUAL
27708: IFFALSE 27738
// begin Say ( JMM , D15d-JMM-1 ) ;
27710: LD_EXP 38
27714: PPUSH
27715: LD_STRING D15d-JMM-1
27717: PPUSH
27718: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27722: LD_EXP 63
27726: PPUSH
27727: LD_STRING D15d-Pla-1
27729: PPUSH
27730: CALL_OW 94
// DialogueOff ;
27734: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27738: LD_EXP 61
27742: PPUSH
27743: CALL_OW 302
27747: PUSH
27748: LD_EXP 61
27752: PPUSH
27753: CALL_OW 255
27757: PUSH
27758: LD_INT 1
27760: EQUAL
27761: AND
27762: PUSH
27763: LD_INT 22
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 34
27775: PUSH
27776: LD_INT 8
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PPUSH
27787: CALL_OW 69
27791: NOT
27792: AND
27793: IFFALSE 28418
// begin SetSide ( Friend , 8 ) ;
27795: LD_EXP 61
27799: PPUSH
27800: LD_INT 8
27802: PPUSH
27803: CALL_OW 235
// if IsInUnit ( Friend ) then
27807: LD_EXP 61
27811: PPUSH
27812: CALL_OW 310
27816: IFFALSE 27827
// ComExitBuilding ( Friend ) ;
27818: LD_EXP 61
27822: PPUSH
27823: CALL_OW 122
// if IsDriver ( Friend ) then
27827: LD_EXP 61
27831: PPUSH
27832: CALL 104950 0 1
27836: IFFALSE 27847
// ComExitVehicle ( Friend ) ;
27838: LD_EXP 61
27842: PPUSH
27843: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27847: LD_EXP 61
27851: PPUSH
27852: LD_INT 9
27854: PPUSH
27855: LD_INT 2
27857: PPUSH
27858: CALL_OW 171
// wait ( 0 0$05 ) ;
27862: LD_INT 175
27864: PPUSH
27865: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27869: LD_EXP 61
27873: PPUSH
27874: CALL_OW 87
// DialogueOn ;
27878: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27882: LD_EXP 38
27886: PPUSH
27887: LD_STRING D16-JMM-1
27889: PPUSH
27890: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27894: LD_EXP 61
27898: PPUSH
27899: LD_STRING D16-Friend-1
27901: PPUSH
27902: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27906: LD_EXP 38
27910: PPUSH
27911: LD_STRING D16-JMM-2
27913: PPUSH
27914: CALL_OW 88
// DialogueOff ;
27918: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27922: LD_EXP 61
27926: PPUSH
27927: LD_INT 1
27929: PPUSH
27930: CALL_OW 235
// ComHold ( Friend ) ;
27934: LD_EXP 61
27938: PPUSH
27939: CALL_OW 140
// wait ( 0 0$20 ) ;
27943: LD_INT 700
27945: PPUSH
27946: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27950: LD_EXP 61
27954: PPUSH
27955: LD_INT 9
27957: PPUSH
27958: LD_INT 2
27960: PPUSH
27961: CALL_OW 297
27965: PUSH
27966: LD_INT 30
27968: LESS
27969: IFFALSE 28038
// begin SetSide ( Friend , 8 ) ;
27971: LD_EXP 61
27975: PPUSH
27976: LD_INT 8
27978: PPUSH
27979: CALL_OW 235
// if IsInUnit ( Friend ) then
27983: LD_EXP 61
27987: PPUSH
27988: CALL_OW 310
27992: IFFALSE 28003
// ComExitBuilding ( Friend ) ;
27994: LD_EXP 61
27998: PPUSH
27999: CALL_OW 122
// if IsDriver ( Friend ) then
28003: LD_EXP 61
28007: PPUSH
28008: CALL 104950 0 1
28012: IFFALSE 28023
// ComExitVehicle ( Friend ) ;
28014: LD_EXP 61
28018: PPUSH
28019: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28023: LD_EXP 61
28027: PPUSH
28028: LD_INT 9
28030: PPUSH
28031: LD_INT 2
28033: PPUSH
28034: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28038: LD_INT 1050
28040: PPUSH
28041: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28045: LD_INT 22
28047: PUSH
28048: LD_INT 1
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PUSH
28055: LD_INT 34
28057: PUSH
28058: LD_INT 8
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PUSH
28065: EMPTY
28066: LIST
28067: LIST
28068: PPUSH
28069: CALL_OW 69
28073: NOT
28074: IFFALSE 28396
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28076: LD_ADDR_VAR 0 3
28080: PUSH
28081: LD_INT 22
28083: PUSH
28084: LD_INT 1
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 26
28093: PUSH
28094: LD_INT 1
28096: PUSH
28097: EMPTY
28098: LIST
28099: LIST
28100: PUSH
28101: LD_INT 3
28103: PUSH
28104: LD_INT 25
28106: PUSH
28107: LD_INT 12
28109: PUSH
28110: EMPTY
28111: LIST
28112: LIST
28113: PUSH
28114: LD_INT 25
28116: PUSH
28117: LD_INT 16
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: LIST
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: LIST
28133: PPUSH
28134: CALL_OW 69
28138: PUSH
28139: LD_EXP 38
28143: PUSH
28144: LD_EXP 40
28148: PUSH
28149: LD_EXP 54
28153: PUSH
28154: LD_EXP 41
28158: PUSH
28159: LD_EXP 42
28163: PUSH
28164: LD_EXP 43
28168: PUSH
28169: LD_EXP 44
28173: PUSH
28174: LD_EXP 45
28178: PUSH
28179: LD_EXP 46
28183: PUSH
28184: LD_EXP 47
28188: PUSH
28189: LD_EXP 48
28193: PUSH
28194: LD_EXP 49
28198: PUSH
28199: LD_EXP 50
28203: PUSH
28204: LD_EXP 51
28208: PUSH
28209: LD_EXP 52
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: DIFF
28231: ST_TO_ADDR
// DialogueOn ;
28232: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28236: LD_EXP 63
28240: PPUSH
28241: LD_STRING D16a-Pla-1
28243: PPUSH
28244: CALL_OW 94
// if Stevens then
28248: LD_EXP 40
28252: IFFALSE 28268
// Say ( Stevens , D16a-Huck-1 ) else
28254: LD_EXP 40
28258: PPUSH
28259: LD_STRING D16a-Huck-1
28261: PPUSH
28262: CALL_OW 88
28266: GO 28310
// if Baker then
28268: LD_EXP 54
28272: IFFALSE 28288
// Say ( Baker , D16a-Huck-1 ) else
28274: LD_EXP 54
28278: PPUSH
28279: LD_STRING D16a-Huck-1
28281: PPUSH
28282: CALL_OW 88
28286: GO 28310
// if tmp then
28288: LD_VAR 0 3
28292: IFFALSE 28310
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28294: LD_VAR 0 3
28298: PUSH
28299: LD_INT 1
28301: ARRAY
28302: PPUSH
28303: LD_STRING D16a-Sol1-1
28305: PPUSH
28306: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28310: LD_EXP 61
28314: PPUSH
28315: CALL_OW 255
28319: PUSH
28320: LD_INT 8
28322: EQUAL
28323: IFFALSE 28339
// Say ( JMM , D16a-JMM-1 ) else
28325: LD_EXP 38
28329: PPUSH
28330: LD_STRING D16a-JMM-1
28332: PPUSH
28333: CALL_OW 88
28337: GO 28375
// begin Say ( JMM , D16a-JMM-1a ) ;
28339: LD_EXP 38
28343: PPUSH
28344: LD_STRING D16a-JMM-1a
28346: PPUSH
28347: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28351: LD_EXP 61
28355: PPUSH
28356: LD_STRING D16a-Friend-1
28358: PPUSH
28359: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28363: LD_EXP 61
28367: PPUSH
28368: LD_INT 3
28370: PPUSH
28371: CALL_OW 235
// end ; DialogueOff ;
28375: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28379: LD_VAR 0 1
28383: PPUSH
28384: LD_INT 60
28386: PPUSH
28387: LD_INT 95
28389: PPUSH
28390: CALL_OW 116
// end else
28394: GO 28416
// begin DialogueOn ;
28396: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28400: LD_EXP 63
28404: PPUSH
28405: LD_STRING D16c-Pla-
28407: PPUSH
28408: CALL_OW 94
// DialogueOff ;
28412: CALL_OW 7
// end ; end else
28416: GO 28517
// begin wait ( 3 3$00 ) ;
28418: LD_INT 6300
28420: PPUSH
28421: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28425: LD_INT 22
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 34
28437: PUSH
28438: LD_INT 8
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PPUSH
28449: CALL_OW 69
28453: NOT
28454: IFFALSE 28497
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28456: LD_EXP 63
28460: PPUSH
28461: LD_STRING D16b-Pla-1
28463: PPUSH
28464: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28468: LD_EXP 38
28472: PPUSH
28473: LD_STRING D16b-JMM-
28475: PPUSH
28476: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28480: LD_VAR 0 1
28484: PPUSH
28485: LD_INT 60
28487: PPUSH
28488: LD_INT 95
28490: PPUSH
28491: CALL_OW 116
// end else
28495: GO 28517
// begin DialogueOn ;
28497: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28501: LD_EXP 63
28505: PPUSH
28506: LD_STRING D16c-Pla-
28508: PPUSH
28509: CALL_OW 94
// DialogueOff ;
28513: CALL_OW 7
// end ; end ; end ;
28517: PPOPN 3
28519: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28520: LD_EXP 14
28524: PUSH
28525: LD_INT 126000
28527: GREATEREQUAL
28528: PUSH
28529: LD_EXP 23
28533: NOT
28534: AND
28535: PUSH
28536: LD_EXP 73
28540: PPUSH
28541: CALL_OW 302
28545: AND
28546: IFFALSE 28904
28548: GO 28550
28550: DISABLE
28551: LD_INT 0
28553: PPUSH
// begin missionStage = 11 ;
28554: LD_ADDR_EXP 15
28558: PUSH
28559: LD_INT 11
28561: ST_TO_ADDR
// DialogueOn ;
28562: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28566: LD_EXP 73
28570: PPUSH
28571: LD_STRING D9-Roth-1
28573: PPUSH
28574: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28578: LD_EXP 38
28582: PPUSH
28583: LD_STRING D9-JMM-1
28585: PPUSH
28586: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28590: LD_EXP 73
28594: PPUSH
28595: LD_STRING D9-Roth-2
28597: PPUSH
28598: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28602: LD_EXP 73
28606: PPUSH
28607: LD_STRING D9-Roth-2a
28609: PPUSH
28610: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28614: LD_EXP 63
28618: PPUSH
28619: LD_STRING D9-Pla-2
28621: PPUSH
28622: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28626: LD_EXP 73
28630: PPUSH
28631: LD_STRING D9-Roth-3
28633: PPUSH
28634: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28638: LD_EXP 63
28642: PPUSH
28643: LD_STRING D9-Pla-3
28645: PPUSH
28646: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28650: LD_EXP 73
28654: PPUSH
28655: LD_STRING D9-Roth-4
28657: PPUSH
28658: CALL_OW 94
// dec = Query ( Q9 ) ;
28662: LD_ADDR_VAR 0 1
28666: PUSH
28667: LD_STRING Q9
28669: PPUSH
28670: CALL_OW 97
28674: ST_TO_ADDR
// if dec = 1 then
28675: LD_VAR 0 1
28679: PUSH
28680: LD_INT 1
28682: EQUAL
28683: IFFALSE 28697
// SayRadio ( Roth , D9a-Roth-1 ) ;
28685: LD_EXP 73
28689: PPUSH
28690: LD_STRING D9a-Roth-1
28692: PPUSH
28693: CALL_OW 94
// if dec = 2 then
28697: LD_VAR 0 1
28701: PUSH
28702: LD_INT 2
28704: EQUAL
28705: IFFALSE 28731
// begin Say ( JMM , D9b-JMM-1 ) ;
28707: LD_EXP 38
28711: PPUSH
28712: LD_STRING D9b-JMM-1
28714: PPUSH
28715: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28719: LD_EXP 73
28723: PPUSH
28724: LD_STRING D9b-Roth-1
28726: PPUSH
28727: CALL_OW 94
// end ; if dec = 3 then
28731: LD_VAR 0 1
28735: PUSH
28736: LD_INT 3
28738: EQUAL
28739: IFFALSE 28801
// begin Say ( JMM , D9c-JMM-1 ) ;
28741: LD_EXP 38
28745: PPUSH
28746: LD_STRING D9c-JMM-1
28748: PPUSH
28749: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28753: LD_EXP 73
28757: PPUSH
28758: LD_STRING D9c-Roth-1
28760: PPUSH
28761: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28765: LD_EXP 38
28769: PPUSH
28770: LD_STRING D9c-JMM-2
28772: PPUSH
28773: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28777: LD_EXP 73
28781: PPUSH
28782: LD_STRING D9c-Roth-2
28784: PPUSH
28785: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28789: LD_EXP 38
28793: PPUSH
28794: LD_STRING D9c-JMM-3
28796: PPUSH
28797: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28801: LD_EXP 73
28805: PPUSH
28806: LD_STRING D9c-Roth-3
28808: PPUSH
28809: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28813: LD_EXP 73
28817: PPUSH
28818: LD_STRING D9cont-Roth-1
28820: PPUSH
28821: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28825: LD_EXP 38
28829: PPUSH
28830: LD_STRING D9cont-JMM-1
28832: PPUSH
28833: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28837: LD_EXP 73
28841: PPUSH
28842: LD_STRING D9cont-Roth-2
28844: PPUSH
28845: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28849: LD_EXP 38
28853: PPUSH
28854: LD_STRING D9cont-JMM-2
28856: PPUSH
28857: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28861: LD_EXP 73
28865: PPUSH
28866: LD_STRING D9cont-Roth-3
28868: PPUSH
28869: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28873: LD_EXP 38
28877: PPUSH
28878: LD_STRING D9cont-JMM-3
28880: PPUSH
28881: CALL_OW 88
// DialogueOff ;
28885: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28889: LD_STRING M3
28891: PPUSH
28892: CALL_OW 337
// allianceActive := true ;
28896: LD_ADDR_EXP 31
28900: PUSH
28901: LD_INT 1
28903: ST_TO_ADDR
// end ;
28904: PPOPN 1
28906: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28907: LD_EXP 63
28911: PPUSH
28912: CALL_OW 301
28916: PUSH
28917: LD_EXP 66
28921: PPUSH
28922: CALL_OW 301
28926: AND
28927: PUSH
28928: LD_INT 22
28930: PUSH
28931: LD_INT 3
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 21
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 50
28950: PUSH
28951: EMPTY
28952: LIST
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: LIST
28958: PPUSH
28959: CALL_OW 69
28963: PUSH
28964: LD_INT 7
28966: PUSH
28967: LD_INT 8
28969: PUSH
28970: LD_INT 9
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: LIST
28977: PUSH
28978: LD_OWVAR 67
28982: ARRAY
28983: LESS
28984: AND
28985: IFFALSE 29756
28987: GO 28989
28989: DISABLE
28990: LD_INT 0
28992: PPUSH
28993: PPUSH
28994: PPUSH
28995: PPUSH
// begin MC_Kill ( 1 ) ;
28996: LD_INT 1
28998: PPUSH
28999: CALL 34457 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29003: LD_INT 1
29005: PPUSH
29006: LD_INT 3
29008: PPUSH
29009: LD_INT 1
29011: PPUSH
29012: LD_INT 1
29014: PPUSH
29015: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29019: LD_ADDR_VAR 0 1
29023: PUSH
29024: LD_INT 22
29026: PUSH
29027: LD_INT 3
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 21
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 24
29046: PUSH
29047: LD_INT 900
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: LIST
29058: PPUSH
29059: CALL_OW 69
29063: PUSH
29064: FOR_IN
29065: IFFALSE 29096
// if GetSex ( i ) = sex_male then
29067: LD_VAR 0 1
29071: PPUSH
29072: CALL_OW 258
29076: PUSH
29077: LD_INT 1
29079: EQUAL
29080: IFFALSE 29094
// begin tmp = i ;
29082: LD_ADDR_VAR 0 2
29086: PUSH
29087: LD_VAR 0 1
29091: ST_TO_ADDR
// break ;
29092: GO 29096
// end ;
29094: GO 29064
29096: POP
29097: POP
// if tmp = 0 then
29098: LD_VAR 0 2
29102: PUSH
29103: LD_INT 0
29105: EQUAL
29106: IFFALSE 29160
// begin uc_side = 3 ;
29108: LD_ADDR_OWVAR 20
29112: PUSH
29113: LD_INT 3
29115: ST_TO_ADDR
// uc_nation = 3 ;
29116: LD_ADDR_OWVAR 21
29120: PUSH
29121: LD_INT 3
29123: ST_TO_ADDR
// hc_name =  ;
29124: LD_ADDR_OWVAR 26
29128: PUSH
29129: LD_STRING 
29131: ST_TO_ADDR
// hc_gallery =  ;
29132: LD_ADDR_OWVAR 33
29136: PUSH
29137: LD_STRING 
29139: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29140: LD_INT 1
29142: PPUSH
29143: LD_INT 10
29145: PPUSH
29146: CALL_OW 381
// tmp = CreateHuman ;
29150: LD_ADDR_VAR 0 2
29154: PUSH
29155: CALL_OW 44
29159: ST_TO_ADDR
// end ; DialogueOn ;
29160: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29164: LD_VAR 0 2
29168: PPUSH
29169: LD_STRING DSurrenderRussians-RSol1-1a
29171: PPUSH
29172: CALL_OW 94
// DialogueOff ;
29176: CALL_OW 7
// russianDestroyed := true ;
29180: LD_ADDR_EXP 21
29184: PUSH
29185: LD_INT 1
29187: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29188: LD_INT 22
29190: PUSH
29191: LD_INT 3
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 21
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PPUSH
29212: CALL_OW 69
29216: PPUSH
29217: CALL_OW 122
// wait ( 0 0$1 ) ;
29221: LD_INT 35
29223: PPUSH
29224: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29228: LD_INT 22
29230: PUSH
29231: LD_INT 3
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 21
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 69
29256: PPUSH
29257: LD_INT 25
29259: PPUSH
29260: CALL_OW 173
// wait ( 0 0$10 ) ;
29264: LD_INT 350
29266: PPUSH
29267: CALL_OW 67
// PrepareOmarInvasion ;
29271: CALL 13753 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29275: LD_ADDR_VAR 0 2
29279: PUSH
29280: LD_EXP 91
29284: PPUSH
29285: CALL_OW 250
29289: PUSH
29290: LD_EXP 91
29294: PPUSH
29295: CALL_OW 251
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29304: LD_VAR 0 2
29308: PUSH
29309: LD_INT 1
29311: ARRAY
29312: PPUSH
29313: LD_VAR 0 2
29317: PUSH
29318: LD_INT 2
29320: ARRAY
29321: PPUSH
29322: LD_INT 1
29324: PPUSH
29325: LD_INT 8
29327: NEG
29328: PPUSH
29329: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29333: LD_EXP 91
29337: PPUSH
29338: CALL_OW 87
// DialogueOn ;
29342: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29346: LD_EXP 38
29350: PPUSH
29351: LD_STRING D19-JMM-1
29353: PPUSH
29354: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29358: LD_ADDR_VAR 0 3
29362: PUSH
29363: LD_INT 22
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 26
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 2
29385: PUSH
29386: LD_INT 25
29388: PUSH
29389: LD_INT 1
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 25
29398: PUSH
29399: LD_INT 2
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: LD_INT 25
29408: PUSH
29409: LD_INT 3
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 25
29418: PUSH
29419: LD_INT 4
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 25
29428: PUSH
29429: LD_INT 5
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 25
29438: PUSH
29439: LD_INT 8
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: LIST
29459: PPUSH
29460: CALL_OW 69
29464: PUSH
29465: LD_EXP 38
29469: PUSH
29470: LD_EXP 39
29474: PUSH
29475: LD_EXP 40
29479: PUSH
29480: LD_EXP 41
29484: PUSH
29485: LD_EXP 42
29489: PUSH
29490: LD_EXP 43
29494: PUSH
29495: LD_EXP 44
29499: PUSH
29500: LD_EXP 45
29504: PUSH
29505: LD_EXP 46
29509: PUSH
29510: LD_EXP 47
29514: PUSH
29515: LD_EXP 48
29519: PUSH
29520: LD_EXP 49
29524: PUSH
29525: LD_EXP 50
29529: PUSH
29530: LD_EXP 51
29534: PUSH
29535: LD_EXP 52
29539: PUSH
29540: LD_EXP 53
29544: PUSH
29545: LD_EXP 54
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: LIST
29554: LIST
29555: LIST
29556: LIST
29557: LIST
29558: LIST
29559: LIST
29560: LIST
29561: LIST
29562: LIST
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: LIST
29568: DIFF
29569: ST_TO_ADDR
// if tmp2 then
29570: LD_VAR 0 3
29574: IFFALSE 29592
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29576: LD_VAR 0 3
29580: PUSH
29581: LD_INT 1
29583: ARRAY
29584: PPUSH
29585: LD_STRING D19-Sol1-1
29587: PPUSH
29588: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29592: LD_EXP 38
29596: PPUSH
29597: LD_STRING D19-JMM-2
29599: PPUSH
29600: CALL_OW 88
// DialogueOff ;
29604: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29608: LD_VAR 0 2
29612: PUSH
29613: LD_INT 1
29615: ARRAY
29616: PPUSH
29617: LD_VAR 0 2
29621: PUSH
29622: LD_INT 2
29624: ARRAY
29625: PPUSH
29626: LD_INT 1
29628: PPUSH
29629: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29633: LD_STRING M5
29635: PPUSH
29636: CALL_OW 337
// omarOnMotherLode := false ;
29640: LD_ADDR_VAR 0 4
29644: PUSH
29645: LD_INT 0
29647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29648: LD_INT 35
29650: PPUSH
29651: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29655: LD_EXP 91
29659: PPUSH
29660: LD_INT 215
29662: PPUSH
29663: LD_INT 100
29665: PPUSH
29666: CALL_OW 297
29670: PUSH
29671: LD_INT 10
29673: LESS
29674: PUSH
29675: LD_VAR 0 4
29679: NOT
29680: AND
29681: IFFALSE 29715
// begin omarOnMotherLode := true ;
29683: LD_ADDR_VAR 0 4
29687: PUSH
29688: LD_INT 1
29690: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29691: LD_EXP 38
29695: PPUSH
29696: LD_STRING D19b-JMM-1
29698: PPUSH
29699: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29703: LD_EXP 91
29707: PPUSH
29708: LD_STRING DOmarContam-Omar-1
29710: PPUSH
29711: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29715: LD_EXP 91
29719: PPUSH
29720: CALL_OW 301
29724: IFFALSE 29648
// Say ( JMM , D19a-JMM-1 ) ;
29726: LD_EXP 38
29730: PPUSH
29731: LD_STRING D19a-JMM-1
29733: PPUSH
29734: CALL_OW 88
// if Heike then
29738: LD_EXP 92
29742: IFFALSE 29756
// Say ( Heike , D19a-Hke-1 ) ;
29744: LD_EXP 92
29748: PPUSH
29749: LD_STRING D19a-Hke-1
29751: PPUSH
29752: CALL_OW 88
// end ;
29756: PPOPN 4
29758: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29759: LD_INT 22
29761: PUSH
29762: LD_INT 3
29764: PUSH
29765: EMPTY
29766: LIST
29767: LIST
29768: PUSH
29769: LD_INT 21
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PPUSH
29783: CALL_OW 69
29787: PUSH
29788: LD_EXP 21
29792: AND
29793: IFFALSE 29861
29795: GO 29797
29797: DISABLE
29798: LD_INT 0
29800: PPUSH
29801: PPUSH
// begin enable ;
29802: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29803: LD_ADDR_VAR 0 2
29807: PUSH
29808: LD_INT 25
29810: PPUSH
29811: LD_INT 22
29813: PUSH
29814: LD_INT 3
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PPUSH
29821: CALL_OW 70
29825: ST_TO_ADDR
// if not tmp then
29826: LD_VAR 0 2
29830: NOT
29831: IFFALSE 29835
// exit ;
29833: GO 29861
// for i in tmp do
29835: LD_ADDR_VAR 0 1
29839: PUSH
29840: LD_VAR 0 2
29844: PUSH
29845: FOR_IN
29846: IFFALSE 29859
// RemoveUnit ( i ) ;
29848: LD_VAR 0 1
29852: PPUSH
29853: CALL_OW 64
29857: GO 29845
29859: POP
29860: POP
// end ;
29861: PPOPN 2
29863: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29864: LD_INT 22
29866: PUSH
29867: LD_INT 7
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 21
29876: PUSH
29877: LD_INT 1
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PPUSH
29888: CALL_OW 69
29892: PUSH
29893: LD_INT 6
29895: LESS
29896: IFFALSE 30364
29898: GO 29900
29900: DISABLE
29901: LD_INT 0
29903: PPUSH
29904: PPUSH
// begin MC_Kill ( 1 ) ;
29905: LD_INT 1
29907: PPUSH
29908: CALL 34457 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29912: LD_INT 7
29914: PPUSH
29915: LD_INT 1
29917: PPUSH
29918: LD_INT 1
29920: PPUSH
29921: LD_INT 1
29923: PPUSH
29924: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29928: LD_ADDR_VAR 0 1
29932: PUSH
29933: LD_INT 22
29935: PUSH
29936: LD_INT 7
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 26
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PPUSH
29957: CALL_OW 69
29961: PUSH
29962: LD_EXP 73
29966: DIFF
29967: ST_TO_ADDR
// if tmp then
29968: LD_VAR 0 1
29972: IFFALSE 29990
// tmp := tmp [ 1 ] else
29974: LD_ADDR_VAR 0 1
29978: PUSH
29979: LD_VAR 0 1
29983: PUSH
29984: LD_INT 1
29986: ARRAY
29987: ST_TO_ADDR
29988: GO 30026
// begin uc_side := 7 ;
29990: LD_ADDR_OWVAR 20
29994: PUSH
29995: LD_INT 7
29997: ST_TO_ADDR
// uc_nation := 1 ;
29998: LD_ADDR_OWVAR 21
30002: PUSH
30003: LD_INT 1
30005: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30006: LD_INT 1
30008: PPUSH
30009: LD_INT 8
30011: PPUSH
30012: CALL_OW 384
// tmp := CreateHuman ;
30016: LD_ADDR_VAR 0 1
30020: PUSH
30021: CALL_OW 44
30025: ST_TO_ADDR
// end ; DialogueOn ;
30026: CALL_OW 6
// if IsOK ( Roth ) then
30030: LD_EXP 73
30034: PPUSH
30035: CALL_OW 302
30039: IFFALSE 30053
// Say ( JMM , DAb-JMM-1 ) ;
30041: LD_EXP 38
30045: PPUSH
30046: LD_STRING DAb-JMM-1
30048: PPUSH
30049: CALL_OW 88
// if IsOK ( Roth ) then
30053: LD_EXP 73
30057: PPUSH
30058: CALL_OW 302
30062: IFFALSE 30086
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30064: LD_EXP 73
30068: PPUSH
30069: LD_STRING DSurrenderAlliance-Roth-1
30071: PPUSH
30072: CALL_OW 88
// RothCaptured := true ;
30076: LD_ADDR_EXP 33
30080: PUSH
30081: LD_INT 1
30083: ST_TO_ADDR
// end else
30084: GO 30098
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30086: LD_VAR 0 1
30090: PPUSH
30091: LD_STRING DSurrenderAlliance-Sci1-1
30093: PPUSH
30094: CALL_OW 88
// DialogueOff ;
30098: CALL_OW 7
// allianceDestroyed := true ;
30102: LD_ADDR_EXP 23
30106: PUSH
30107: LD_INT 1
30109: ST_TO_ADDR
// if capturedUnit = 0 then
30110: LD_EXP 34
30114: PUSH
30115: LD_INT 0
30117: EQUAL
30118: IFFALSE 30127
// SetAchievement ( ACH_ALLIANCE ) ;
30120: LD_STRING ACH_ALLIANCE
30122: PPUSH
30123: CALL_OW 543
// if trueAmericans then
30127: LD_EXP 35
30131: IFFALSE 30207
// begin if trueAmericans = 1 then
30133: LD_EXP 35
30137: PUSH
30138: LD_INT 1
30140: EQUAL
30141: IFFALSE 30157
// Say ( JMM , DAb-JMM-1a ) else
30143: LD_EXP 38
30147: PPUSH
30148: LD_STRING DAb-JMM-1a
30150: PPUSH
30151: CALL_OW 88
30155: GO 30169
// Say ( JMM , DAb-JMM-1b ) ;
30157: LD_EXP 38
30161: PPUSH
30162: LD_STRING DAb-JMM-1b
30164: PPUSH
30165: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30169: LD_EXP 35
30173: PPUSH
30174: CALL_OW 87
// for i in trueAmericans do
30178: LD_ADDR_VAR 0 2
30182: PUSH
30183: LD_EXP 35
30187: PUSH
30188: FOR_IN
30189: IFFALSE 30205
// SetSide ( i , 1 ) ;
30191: LD_VAR 0 2
30195: PPUSH
30196: LD_INT 1
30198: PPUSH
30199: CALL_OW 235
30203: GO 30188
30205: POP
30206: POP
// end ; repeat wait ( 0 0$1 ) ;
30207: LD_INT 35
30209: PPUSH
30210: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30214: LD_ADDR_VAR 0 2
30218: PUSH
30219: LD_INT 22
30221: PUSH
30222: LD_INT 7
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 21
30231: PUSH
30232: LD_INT 1
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: EMPTY
30240: LIST
30241: LIST
30242: PPUSH
30243: CALL_OW 69
30247: PUSH
30248: FOR_IN
30249: IFFALSE 30331
// begin if IsInUnit ( i ) then
30251: LD_VAR 0 2
30255: PPUSH
30256: CALL_OW 310
30260: IFFALSE 30271
// ComExitBuilding ( i ) ;
30262: LD_VAR 0 2
30266: PPUSH
30267: CALL_OW 122
// if IsDriver ( i ) then
30271: LD_VAR 0 2
30275: PPUSH
30276: CALL 104950 0 1
30280: IFFALSE 30291
// ComExitVehicle ( i ) ;
30282: LD_VAR 0 2
30286: PPUSH
30287: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30291: LD_VAR 0 2
30295: PPUSH
30296: LD_INT 26
30298: PPUSH
30299: CALL_OW 308
30303: NOT
30304: IFFALSE 30320
// AddComMoveToArea ( i , allianceEscapeArea ) else
30306: LD_VAR 0 2
30310: PPUSH
30311: LD_INT 26
30313: PPUSH
30314: CALL_OW 173
30318: GO 30329
// RemoveUnit ( i ) ;
30320: LD_VAR 0 2
30324: PPUSH
30325: CALL_OW 64
// end ;
30329: GO 30248
30331: POP
30332: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30333: LD_INT 22
30335: PUSH
30336: LD_INT 7
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 21
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PPUSH
30357: CALL_OW 69
30361: NOT
30362: IFFALSE 30207
// end ;
30364: PPOPN 2
30366: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30367: LD_INT 0
30369: PPUSH
30370: PPUSH
// if not unit then
30371: LD_VAR 0 1
30375: NOT
30376: IFFALSE 30380
// exit ;
30378: GO 31878
// DoNotAttack ( 7 , unit ) ;
30380: LD_INT 7
30382: PPUSH
30383: LD_VAR 0 1
30387: PPUSH
30388: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30392: LD_VAR 0 1
30396: PPUSH
30397: LD_INT 260
30399: PPUSH
30400: LD_INT 235
30402: PPUSH
30403: LD_INT 3
30405: PPUSH
30406: LD_INT 1
30408: PPUSH
30409: CALL_OW 483
// SetSide ( unit , 4 ) ;
30413: LD_VAR 0 1
30417: PPUSH
30418: LD_INT 4
30420: PPUSH
30421: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30425: LD_ADDR_EXP 34
30429: PUSH
30430: LD_EXP 34
30434: PUSH
30435: LD_INT 1
30437: PLUS
30438: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30439: LD_INT 70
30441: PPUSH
30442: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30446: LD_INT 260
30448: PPUSH
30449: LD_INT 235
30451: PPUSH
30452: LD_INT 1
30454: PPUSH
30455: LD_INT 8
30457: NEG
30458: PPUSH
30459: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30463: LD_VAR 0 1
30467: PPUSH
30468: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30472: LD_VAR 0 1
30476: PPUSH
30477: LD_EXP 73
30481: PPUSH
30482: CALL_OW 119
// DialogueOn ;
30486: CALL_OW 6
// case unit of JMM :
30490: LD_VAR 0 1
30494: PUSH
30495: LD_EXP 38
30499: DOUBLE
30500: EQUAL
30501: IFTRUE 30505
30503: GO 30520
30505: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30506: LD_EXP 38
30510: PPUSH
30511: LD_STRING DA1-JMM-1
30513: PPUSH
30514: CALL_OW 91
30518: GO 30962
30520: LD_EXP 39
30524: DOUBLE
30525: EQUAL
30526: IFTRUE 30530
30528: GO 30545
30530: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30531: LD_EXP 39
30535: PPUSH
30536: LD_STRING DA1-Joan-1
30538: PPUSH
30539: CALL_OW 91
30543: GO 30962
30545: LD_EXP 41
30549: DOUBLE
30550: EQUAL
30551: IFTRUE 30555
30553: GO 30570
30555: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30556: LD_EXP 41
30560: PPUSH
30561: LD_STRING DA1-Lisa-1
30563: PPUSH
30564: CALL_OW 91
30568: GO 30962
30570: LD_EXP 42
30574: DOUBLE
30575: EQUAL
30576: IFTRUE 30580
30578: GO 30595
30580: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30581: LD_EXP 42
30585: PPUSH
30586: LD_STRING DA1-Don-1
30588: PPUSH
30589: CALL_OW 91
30593: GO 30962
30595: LD_EXP 49
30599: DOUBLE
30600: EQUAL
30601: IFTRUE 30605
30603: GO 30620
30605: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30606: LD_EXP 49
30610: PPUSH
30611: LD_STRING DA1-Corn-1
30613: PPUSH
30614: CALL_OW 91
30618: GO 30962
30620: LD_EXP 45
30624: DOUBLE
30625: EQUAL
30626: IFTRUE 30630
30628: GO 30645
30630: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30631: LD_EXP 45
30635: PPUSH
30636: LD_STRING DA1-Den-1
30638: PPUSH
30639: CALL_OW 91
30643: GO 30962
30645: LD_EXP 43
30649: DOUBLE
30650: EQUAL
30651: IFTRUE 30655
30653: GO 30670
30655: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30656: LD_EXP 43
30660: PPUSH
30661: LD_STRING DA1-Bobby-1
30663: PPUSH
30664: CALL_OW 91
30668: GO 30962
30670: LD_EXP 47
30674: DOUBLE
30675: EQUAL
30676: IFTRUE 30680
30678: GO 30695
30680: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30681: LD_EXP 47
30685: PPUSH
30686: LD_STRING DA1-Glad-1
30688: PPUSH
30689: CALL_OW 91
30693: GO 30962
30695: LD_EXP 44
30699: DOUBLE
30700: EQUAL
30701: IFTRUE 30705
30703: GO 30720
30705: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30706: LD_EXP 44
30710: PPUSH
30711: LD_STRING DA1-Cyrus-1
30713: PPUSH
30714: CALL_OW 91
30718: GO 30962
30720: LD_EXP 40
30724: DOUBLE
30725: EQUAL
30726: IFTRUE 30730
30728: GO 30745
30730: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30731: LD_EXP 40
30735: PPUSH
30736: LD_STRING DA1-Huck-1
30738: PPUSH
30739: CALL_OW 91
30743: GO 30962
30745: LD_EXP 54
30749: DOUBLE
30750: EQUAL
30751: IFTRUE 30755
30753: GO 30770
30755: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30756: LD_EXP 54
30760: PPUSH
30761: LD_STRING DA1-Huck-1
30763: PPUSH
30764: CALL_OW 91
30768: GO 30962
30770: LD_EXP 46
30774: DOUBLE
30775: EQUAL
30776: IFTRUE 30780
30778: GO 30795
30780: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30781: LD_EXP 46
30785: PPUSH
30786: LD_STRING DA1-Brown-1
30788: PPUSH
30789: CALL_OW 91
30793: GO 30962
30795: LD_EXP 50
30799: DOUBLE
30800: EQUAL
30801: IFTRUE 30805
30803: GO 30820
30805: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30806: LD_EXP 50
30810: PPUSH
30811: LD_STRING DA1-Gary-1
30813: PPUSH
30814: CALL_OW 91
30818: GO 30962
30820: LD_EXP 53
30824: DOUBLE
30825: EQUAL
30826: IFTRUE 30830
30828: GO 30845
30830: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30831: LD_EXP 53
30835: PPUSH
30836: LD_STRING DA1-Con-1
30838: PPUSH
30839: CALL_OW 91
30843: GO 30962
30845: LD_EXP 59
30849: DOUBLE
30850: EQUAL
30851: IFTRUE 30855
30853: GO 30870
30855: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30856: LD_EXP 59
30860: PPUSH
30861: LD_STRING DA1-Kurt-1
30863: PPUSH
30864: CALL_OW 91
30868: GO 30962
30870: LD_EXP 52
30874: DOUBLE
30875: EQUAL
30876: IFTRUE 30880
30878: GO 30895
30880: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30881: LD_EXP 52
30885: PPUSH
30886: LD_STRING DA1-Yam-1
30888: PPUSH
30889: CALL_OW 91
30893: GO 30962
30895: LD_EXP 51
30899: DOUBLE
30900: EQUAL
30901: IFTRUE 30905
30903: GO 30920
30905: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30906: LD_EXP 51
30910: PPUSH
30911: LD_STRING DA1-Frank-1
30913: PPUSH
30914: CALL_OW 91
30918: GO 30962
30920: POP
// begin if GetSex ( unit ) = sex_male then
30921: LD_VAR 0 1
30925: PPUSH
30926: CALL_OW 258
30930: PUSH
30931: LD_INT 1
30933: EQUAL
30934: IFFALSE 30950
// ForceSay ( unit , DA1-Sol1-1 ) else
30936: LD_VAR 0 1
30940: PPUSH
30941: LD_STRING DA1-Sol1-1
30943: PPUSH
30944: CALL_OW 91
30948: GO 30962
// ForceSay ( unit , DA1-FSol1-1 ) ;
30950: LD_VAR 0 1
30954: PPUSH
30955: LD_STRING DA1-FSol1-1
30957: PPUSH
30958: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30962: LD_EXP 73
30966: PPUSH
30967: LD_STRING DA-Roth-1
30969: PPUSH
30970: CALL_OW 88
// if capturedUnit = 1 then
30974: LD_EXP 34
30978: PUSH
30979: LD_INT 1
30981: EQUAL
30982: IFFALSE 31010
// begin Say ( Simms , DA-Sim-1 ) ;
30984: LD_EXP 74
30988: PPUSH
30989: LD_STRING DA-Sim-1
30991: PPUSH
30992: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30996: LD_EXP 73
31000: PPUSH
31001: LD_STRING DA-Roth-2
31003: PPUSH
31004: CALL_OW 88
// end else
31008: GO 31022
// Say ( Simms , DA-Sim-2 ) ;
31010: LD_EXP 74
31014: PPUSH
31015: LD_STRING DA-Sim-2
31017: PPUSH
31018: CALL_OW 88
// case unit of JMM :
31022: LD_VAR 0 1
31026: PUSH
31027: LD_EXP 38
31031: DOUBLE
31032: EQUAL
31033: IFTRUE 31037
31035: GO 31052
31037: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31038: LD_EXP 38
31042: PPUSH
31043: LD_STRING DA1-JMM-1a
31045: PPUSH
31046: CALL_OW 91
31050: GO 31559
31052: LD_EXP 39
31056: DOUBLE
31057: EQUAL
31058: IFTRUE 31062
31060: GO 31077
31062: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31063: LD_EXP 39
31067: PPUSH
31068: LD_STRING DA1-Joan-1a
31070: PPUSH
31071: CALL_OW 91
31075: GO 31559
31077: LD_EXP 41
31081: DOUBLE
31082: EQUAL
31083: IFTRUE 31087
31085: GO 31102
31087: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31088: LD_EXP 41
31092: PPUSH
31093: LD_STRING DA1-Lisa-1a
31095: PPUSH
31096: CALL_OW 91
31100: GO 31559
31102: LD_EXP 42
31106: DOUBLE
31107: EQUAL
31108: IFTRUE 31112
31110: GO 31127
31112: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31113: LD_EXP 42
31117: PPUSH
31118: LD_STRING DA1-Don-1a
31120: PPUSH
31121: CALL_OW 91
31125: GO 31559
31127: LD_EXP 49
31131: DOUBLE
31132: EQUAL
31133: IFTRUE 31137
31135: GO 31152
31137: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31138: LD_EXP 49
31142: PPUSH
31143: LD_STRING DA1-Corn-1a
31145: PPUSH
31146: CALL_OW 91
31150: GO 31559
31152: LD_EXP 45
31156: DOUBLE
31157: EQUAL
31158: IFTRUE 31162
31160: GO 31177
31162: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31163: LD_EXP 45
31167: PPUSH
31168: LD_STRING DA1-Den-1a
31170: PPUSH
31171: CALL_OW 91
31175: GO 31559
31177: LD_EXP 43
31181: DOUBLE
31182: EQUAL
31183: IFTRUE 31187
31185: GO 31202
31187: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31188: LD_EXP 43
31192: PPUSH
31193: LD_STRING DA1-Bobby-1a
31195: PPUSH
31196: CALL_OW 91
31200: GO 31559
31202: LD_EXP 47
31206: DOUBLE
31207: EQUAL
31208: IFTRUE 31212
31210: GO 31227
31212: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31213: LD_EXP 47
31217: PPUSH
31218: LD_STRING DA1-Glad-1a
31220: PPUSH
31221: CALL_OW 91
31225: GO 31559
31227: LD_EXP 44
31231: DOUBLE
31232: EQUAL
31233: IFTRUE 31237
31235: GO 31252
31237: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31238: LD_EXP 44
31242: PPUSH
31243: LD_STRING DA1-Cyrus-1a
31245: PPUSH
31246: CALL_OW 91
31250: GO 31559
31252: LD_EXP 40
31256: DOUBLE
31257: EQUAL
31258: IFTRUE 31262
31260: GO 31277
31262: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31263: LD_EXP 40
31267: PPUSH
31268: LD_STRING DA1-Huck-1a
31270: PPUSH
31271: CALL_OW 91
31275: GO 31559
31277: LD_EXP 54
31281: DOUBLE
31282: EQUAL
31283: IFTRUE 31287
31285: GO 31302
31287: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31288: LD_EXP 54
31292: PPUSH
31293: LD_STRING DA1-Huck-1a
31295: PPUSH
31296: CALL_OW 91
31300: GO 31559
31302: LD_EXP 46
31306: DOUBLE
31307: EQUAL
31308: IFTRUE 31312
31310: GO 31327
31312: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31313: LD_EXP 46
31317: PPUSH
31318: LD_STRING DA1-Brown-1a
31320: PPUSH
31321: CALL_OW 91
31325: GO 31559
31327: LD_EXP 50
31331: DOUBLE
31332: EQUAL
31333: IFTRUE 31337
31335: GO 31352
31337: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31338: LD_EXP 50
31342: PPUSH
31343: LD_STRING DA1-Gary-1a
31345: PPUSH
31346: CALL_OW 91
31350: GO 31559
31352: LD_EXP 53
31356: DOUBLE
31357: EQUAL
31358: IFTRUE 31362
31360: GO 31377
31362: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31363: LD_EXP 53
31367: PPUSH
31368: LD_STRING DA1-Con-1a
31370: PPUSH
31371: CALL_OW 91
31375: GO 31559
31377: LD_EXP 59
31381: DOUBLE
31382: EQUAL
31383: IFTRUE 31387
31385: GO 31402
31387: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31388: LD_EXP 59
31392: PPUSH
31393: LD_STRING DA1-Kurt-1a
31395: PPUSH
31396: CALL_OW 91
31400: GO 31559
31402: LD_EXP 52
31406: DOUBLE
31407: EQUAL
31408: IFTRUE 31412
31410: GO 31427
31412: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31413: LD_EXP 52
31417: PPUSH
31418: LD_STRING DA1-Yam-1a
31420: PPUSH
31421: CALL_OW 91
31425: GO 31559
31427: LD_EXP 51
31431: DOUBLE
31432: EQUAL
31433: IFTRUE 31437
31435: GO 31452
31437: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31438: LD_EXP 51
31442: PPUSH
31443: LD_STRING DA1-Frank-1a
31445: PPUSH
31446: CALL_OW 91
31450: GO 31559
31452: POP
// begin join := rand ( 0 , 1 ) ;
31453: LD_ADDR_VAR 0 3
31457: PUSH
31458: LD_INT 0
31460: PPUSH
31461: LD_INT 1
31463: PPUSH
31464: CALL_OW 12
31468: ST_TO_ADDR
// if join then
31469: LD_VAR 0 3
31473: IFFALSE 31518
// begin if GetSex ( unit ) = sex_male then
31475: LD_VAR 0 1
31479: PPUSH
31480: CALL_OW 258
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31504
// ForceSay ( unit , DA1-Sol1-1b ) else
31490: LD_VAR 0 1
31494: PPUSH
31495: LD_STRING DA1-Sol1-1b
31497: PPUSH
31498: CALL_OW 91
31502: GO 31516
// ForceSay ( unit , DA1-FSol1-1b ) ;
31504: LD_VAR 0 1
31508: PPUSH
31509: LD_STRING DA1-FSol1-1b
31511: PPUSH
31512: CALL_OW 91
// end else
31516: GO 31559
// begin if GetSex ( unit ) = sex_male then
31518: LD_VAR 0 1
31522: PPUSH
31523: CALL_OW 258
31527: PUSH
31528: LD_INT 1
31530: EQUAL
31531: IFFALSE 31547
// ForceSay ( unit , DA1-Sol1-1a ) else
31533: LD_VAR 0 1
31537: PPUSH
31538: LD_STRING DA1-Sol1-1a
31540: PPUSH
31541: CALL_OW 91
31545: GO 31559
// ForceSay ( unit , DA1-FSol1-1a ) ;
31547: LD_VAR 0 1
31551: PPUSH
31552: LD_STRING DA1-FSol1-1a
31554: PPUSH
31555: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31559: LD_VAR 0 1
31563: PUSH
31564: LD_EXP 38
31568: EQUAL
31569: IFFALSE 31580
// begin YouLost ( JMMCaptured ) ;
31571: LD_STRING JMMCaptured
31573: PPUSH
31574: CALL_OW 104
// exit ;
31578: GO 31878
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31580: LD_VAR 0 1
31584: PUSH
31585: LD_EXP 42
31589: PUSH
31590: LD_EXP 45
31594: PUSH
31595: LD_EXP 43
31599: PUSH
31600: LD_EXP 40
31604: PUSH
31605: LD_EXP 54
31609: PUSH
31610: LD_EXP 46
31614: PUSH
31615: LD_EXP 52
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: IN
31629: PUSH
31630: LD_VAR 0 3
31634: OR
31635: IFFALSE 31734
// begin Say ( Roth , DA-Roth-3 ) ;
31637: LD_EXP 73
31641: PPUSH
31642: LD_STRING DA-Roth-3
31644: PPUSH
31645: CALL_OW 88
// SetSide ( unit , 7 ) ;
31649: LD_VAR 0 1
31653: PPUSH
31654: LD_INT 7
31656: PPUSH
31657: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31661: LD_ADDR_EXP 101
31665: PUSH
31666: LD_EXP 101
31670: PPUSH
31671: LD_INT 1
31673: PPUSH
31674: LD_EXP 101
31678: PUSH
31679: LD_INT 1
31681: ARRAY
31682: PUSH
31683: LD_VAR 0 1
31687: ADD
31688: PPUSH
31689: CALL_OW 1
31693: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31694: LD_INT 260
31696: PPUSH
31697: LD_INT 235
31699: PPUSH
31700: LD_INT 1
31702: PPUSH
31703: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31707: LD_VAR 0 1
31711: PPUSH
31712: LD_INT 1000
31714: PPUSH
31715: CALL_OW 234
// DialogueOff ;
31719: CALL_OW 7
// ComFree ( unit ) ;
31723: LD_VAR 0 1
31727: PPUSH
31728: CALL_OW 139
// end else
31732: GO 31815
// begin Say ( Roth , DA-Roth-3a ) ;
31734: LD_EXP 73
31738: PPUSH
31739: LD_STRING DA-Roth-3a
31741: PPUSH
31742: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31746: LD_ADDR_EXP 35
31750: PUSH
31751: LD_EXP 35
31755: PUSH
31756: LD_VAR 0 1
31760: ADD
31761: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31762: LD_INT 260
31764: PPUSH
31765: LD_INT 235
31767: PPUSH
31768: LD_INT 1
31770: PPUSH
31771: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31775: LD_VAR 0 1
31779: PPUSH
31780: LD_INT 1000
31782: PPUSH
31783: CALL_OW 234
// DialogueOff ;
31787: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31791: LD_VAR 0 1
31795: PPUSH
31796: LD_INT 272
31798: PPUSH
31799: LD_INT 254
31801: PPUSH
31802: CALL_OW 111
// AddComHold ( unit ) ;
31806: LD_VAR 0 1
31810: PPUSH
31811: CALL_OW 200
// end ; if capturedUnit = 1 then
31815: LD_EXP 34
31819: PUSH
31820: LD_INT 1
31822: EQUAL
31823: IFFALSE 31878
// begin DialogueOn ;
31825: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31829: LD_EXP 38
31833: PPUSH
31834: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31838: LD_EXP 38
31842: PPUSH
31843: LD_STRING DAa-JMM-1
31845: PPUSH
31846: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31850: LD_EXP 38
31854: PPUSH
31855: LD_STRING DAa-JMM-1a
31857: PPUSH
31858: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31862: LD_EXP 38
31866: PPUSH
31867: LD_STRING DAa-JMM-1b
31869: PPUSH
31870: CALL_OW 88
// DialogueOff ;
31874: CALL_OW 7
// end ; end ;
31878: LD_VAR 0 2
31882: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31883: LD_EXP 15
31887: PUSH
31888: LD_INT 13
31890: GREATEREQUAL
31891: PUSH
31892: LD_INT 22
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 21
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 69
31920: PUSH
31921: LD_INT 0
31923: EQUAL
31924: AND
31925: PUSH
31926: LD_INT 22
31928: PUSH
31929: LD_INT 2
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 21
31938: PUSH
31939: LD_INT 2
31941: PUSH
31942: EMPTY
31943: LIST
31944: LIST
31945: PUSH
31946: LD_INT 50
31948: PUSH
31949: EMPTY
31950: LIST
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: LIST
31956: PPUSH
31957: CALL_OW 69
31961: PUSH
31962: LD_INT 0
31964: EQUAL
31965: AND
31966: PUSH
31967: LD_EXP 21
31971: AND
31972: PUSH
31973: LD_EXP 22
31977: AND
31978: PUSH
31979: LD_EXP 23
31983: AND
31984: IFFALSE 32626
31986: GO 31988
31988: DISABLE
31989: LD_INT 0
31991: PPUSH
31992: PPUSH
31993: PPUSH
// begin m1 := false ;
31994: LD_ADDR_VAR 0 1
31998: PUSH
31999: LD_INT 0
32001: ST_TO_ADDR
// m2 := false ;
32002: LD_ADDR_VAR 0 2
32006: PUSH
32007: LD_INT 0
32009: ST_TO_ADDR
// m3 := false ;
32010: LD_ADDR_VAR 0 3
32014: PUSH
32015: LD_INT 0
32017: ST_TO_ADDR
// if not bombExploded then
32018: LD_EXP 37
32022: NOT
32023: IFFALSE 32032
// SetAchievement ( ACH_SIBROCKET ) ;
32025: LD_STRING ACH_SIBROCKET
32027: PPUSH
32028: CALL_OW 543
// if tick <= 120 120$00 then
32032: LD_OWVAR 1
32036: PUSH
32037: LD_INT 252000
32039: LESSEQUAL
32040: IFFALSE 32056
// begin wait ( 3 ) ;
32042: LD_INT 3
32044: PPUSH
32045: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32049: LD_STRING ACH_ASPEED_15
32051: PPUSH
32052: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32056: LD_EXP 38
32060: PPUSH
32061: CALL_OW 87
// music_class := 5 ;
32065: LD_ADDR_OWVAR 72
32069: PUSH
32070: LD_INT 5
32072: ST_TO_ADDR
// music_nat := 5 ;
32073: LD_ADDR_OWVAR 71
32077: PUSH
32078: LD_INT 5
32080: ST_TO_ADDR
// DialogueOn ;
32081: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32085: LD_EXP 38
32089: PPUSH
32090: LD_STRING D20-JMM-1
32092: PPUSH
32093: CALL_OW 88
// if IsOK ( Joan ) then
32097: LD_EXP 39
32101: PPUSH
32102: CALL_OW 302
32106: IFFALSE 32120
// Say ( Joan , D20-Joan-1 ) ;
32108: LD_EXP 39
32112: PPUSH
32113: LD_STRING D20-Joan-1
32115: PPUSH
32116: CALL_OW 88
// if IsOk ( Lisa ) then
32120: LD_EXP 41
32124: PPUSH
32125: CALL_OW 302
32129: IFFALSE 32143
// Say ( Lisa , D20-Lisa-1 ) ;
32131: LD_EXP 41
32135: PPUSH
32136: LD_STRING D20-Lisa-1
32138: PPUSH
32139: CALL_OW 88
// if IsOk ( Donaldson ) then
32143: LD_EXP 42
32147: PPUSH
32148: CALL_OW 302
32152: IFFALSE 32166
// Say ( Donaldson , D20-Don-1 ) ;
32154: LD_EXP 42
32158: PPUSH
32159: LD_STRING D20-Don-1
32161: PPUSH
32162: CALL_OW 88
// if IsOK ( Cornel ) then
32166: LD_EXP 49
32170: PPUSH
32171: CALL_OW 302
32175: IFFALSE 32189
// Say ( Cornel , D20-Corn-1 ) ;
32177: LD_EXP 49
32181: PPUSH
32182: LD_STRING D20-Corn-1
32184: PPUSH
32185: CALL_OW 88
// if IsOk ( Denis ) then
32189: LD_EXP 45
32193: PPUSH
32194: CALL_OW 302
32198: IFFALSE 32212
// Say ( Denis , D20-Den-1 ) ;
32200: LD_EXP 45
32204: PPUSH
32205: LD_STRING D20-Den-1
32207: PPUSH
32208: CALL_OW 88
// if IsOk ( Bobby ) then
32212: LD_EXP 43
32216: PPUSH
32217: CALL_OW 302
32221: IFFALSE 32235
// Say ( Bobby , D20-Bobby-1 ) ;
32223: LD_EXP 43
32227: PPUSH
32228: LD_STRING D20-Bobby-1
32230: PPUSH
32231: CALL_OW 88
// if IsOk ( Gladstone ) then
32235: LD_EXP 47
32239: PPUSH
32240: CALL_OW 302
32244: IFFALSE 32258
// Say ( Gladstone , D20-Glad-1 ) ;
32246: LD_EXP 47
32250: PPUSH
32251: LD_STRING D20-Glad-1
32253: PPUSH
32254: CALL_OW 88
// if IsOk ( Cyrus ) then
32258: LD_EXP 44
32262: PPUSH
32263: CALL_OW 302
32267: IFFALSE 32281
// Say ( Cyrus , D20-Cyrus-1 ) ;
32269: LD_EXP 44
32273: PPUSH
32274: LD_STRING D20-Cyrus-1
32276: PPUSH
32277: CALL_OW 88
// if IsOk ( Stevens ) then
32281: LD_EXP 40
32285: PPUSH
32286: CALL_OW 302
32290: IFFALSE 32304
// Say ( Stevens , D20-Huck-1 ) ;
32292: LD_EXP 40
32296: PPUSH
32297: LD_STRING D20-Huck-1
32299: PPUSH
32300: CALL_OW 88
// if IsOk ( Brown ) then
32304: LD_EXP 46
32308: PPUSH
32309: CALL_OW 302
32313: IFFALSE 32327
// Say ( Brown , D20-Brown-1 ) ;
32315: LD_EXP 46
32319: PPUSH
32320: LD_STRING D20-Brown-1
32322: PPUSH
32323: CALL_OW 88
// if IsOk ( Gary ) then
32327: LD_EXP 50
32331: PPUSH
32332: CALL_OW 302
32336: IFFALSE 32350
// Say ( Gary , D20-Gary-1 ) ;
32338: LD_EXP 50
32342: PPUSH
32343: LD_STRING D20-Gary-1
32345: PPUSH
32346: CALL_OW 88
// if IsOk ( Connie ) then
32350: LD_EXP 53
32354: PPUSH
32355: CALL_OW 302
32359: IFFALSE 32373
// Say ( Connie , D20-Con-1 ) ;
32361: LD_EXP 53
32365: PPUSH
32366: LD_STRING D20-Con-1
32368: PPUSH
32369: CALL_OW 88
// if IsOk ( Kurt ) then
32373: LD_EXP 59
32377: PPUSH
32378: CALL_OW 302
32382: IFFALSE 32396
// Say ( Kurt , D20-Kurt-1 ) ;
32384: LD_EXP 59
32388: PPUSH
32389: LD_STRING D20-Kurt-1
32391: PPUSH
32392: CALL_OW 88
// if IsOk ( Kikuchi ) then
32396: LD_EXP 52
32400: PPUSH
32401: CALL_OW 302
32405: IFFALSE 32419
// Say ( Kikuchi , D20-Yam-1 ) ;
32407: LD_EXP 52
32411: PPUSH
32412: LD_STRING D20-Yam-1
32414: PPUSH
32415: CALL_OW 88
// if IsOk ( Frank ) then
32419: LD_EXP 51
32423: PPUSH
32424: CALL_OW 302
32428: IFFALSE 32442
// Say ( Frank , D20-Frank-1 ) ;
32430: LD_EXP 51
32434: PPUSH
32435: LD_STRING D20-Frank-1
32437: PPUSH
32438: CALL_OW 88
// DialogueOff ;
32442: CALL_OW 7
// if RothCaptured then
32446: LD_EXP 33
32450: IFFALSE 32472
// begin m1 := true ;
32452: LD_ADDR_VAR 0 1
32456: PUSH
32457: LD_INT 1
32459: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32460: LD_STRING Roth
32462: PPUSH
32463: LD_INT 1
32465: PPUSH
32466: CALL_OW 101
// end else
32470: GO 32483
// AddMedal ( Roth , - 1 ) ;
32472: LD_STRING Roth
32474: PPUSH
32475: LD_INT 1
32477: NEG
32478: PPUSH
32479: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32483: LD_EXP 27
32487: IFFALSE 32509
// begin m2 := true ;
32489: LD_ADDR_VAR 0 2
32493: PUSH
32494: LD_INT 1
32496: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32497: LD_STRING Project
32499: PPUSH
32500: LD_INT 1
32502: PPUSH
32503: CALL_OW 101
// end else
32507: GO 32520
// AddMedal ( Project , - 1 ) ;
32509: LD_STRING Project
32511: PPUSH
32512: LD_INT 1
32514: NEG
32515: PPUSH
32516: CALL_OW 101
// if lostCounter = 0 then
32520: LD_EXP 32
32524: PUSH
32525: LD_INT 0
32527: EQUAL
32528: IFFALSE 32550
// begin m3 := true ;
32530: LD_ADDR_VAR 0 3
32534: PUSH
32535: LD_INT 1
32537: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32538: LD_STRING NoLosses
32540: PPUSH
32541: LD_INT 1
32543: PPUSH
32544: CALL_OW 101
// end else
32548: GO 32561
// AddMedal ( NoLosses , - 1 ) ;
32550: LD_STRING NoLosses
32552: PPUSH
32553: LD_INT 1
32555: NEG
32556: PPUSH
32557: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32561: LD_VAR 0 1
32565: PUSH
32566: LD_VAR 0 2
32570: AND
32571: PUSH
32572: LD_VAR 0 3
32576: AND
32577: PUSH
32578: LD_OWVAR 67
32582: PUSH
32583: LD_INT 3
32585: EQUAL
32586: AND
32587: IFFALSE 32599
// SetAchievementEX ( ACH_AMER , 15 ) ;
32589: LD_STRING ACH_AMER
32591: PPUSH
32592: LD_INT 15
32594: PPUSH
32595: CALL_OW 564
// GiveMedals ( MAIN ) ;
32599: LD_STRING MAIN
32601: PPUSH
32602: CALL_OW 102
// music_class := 4 ;
32606: LD_ADDR_OWVAR 72
32610: PUSH
32611: LD_INT 4
32613: ST_TO_ADDR
// music_nat := 1 ;
32614: LD_ADDR_OWVAR 71
32618: PUSH
32619: LD_INT 1
32621: ST_TO_ADDR
// YouWin ;
32622: CALL_OW 103
// end ; end_of_file
32626: PPOPN 3
32628: END
// export function CustomEvent ( event ) ; begin
32629: LD_INT 0
32631: PPUSH
// end ;
32632: LD_VAR 0 2
32636: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32637: LD_VAR 0 1
32641: PUSH
32642: LD_INT 1
32644: EQUAL
32645: PUSH
32646: LD_VAR 0 2
32650: PUSH
32651: LD_INT 4
32653: EQUAL
32654: AND
32655: PUSH
32656: LD_EXP 57
32660: PPUSH
32661: CALL_OW 300
32665: AND
32666: IFFALSE 32682
// begin wait ( 0 0$2 ) ;
32668: LD_INT 70
32670: PPUSH
32671: CALL_OW 67
// YouLost ( Dismissed ) ;
32675: LD_STRING Dismissed
32677: PPUSH
32678: CALL_OW 104
// end ; end ;
32682: PPOPN 2
32684: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32685: LD_VAR 0 2
32689: PPUSH
32690: LD_VAR 0 3
32694: PPUSH
32695: LD_INT 18
32697: PPUSH
32698: CALL_OW 309
32702: IFFALSE 32711
// YouLost ( Motherlode3 ) ;
32704: LD_STRING Motherlode3
32706: PPUSH
32707: CALL_OW 104
// end ;
32711: PPOPN 3
32713: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32714: LD_EXP 27
32718: NOT
32719: IFFALSE 32729
// behemothDone := true ;
32721: LD_ADDR_EXP 28
32725: PUSH
32726: LD_INT 1
32728: ST_TO_ADDR
// end ;
32729: PPOPN 1
32731: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
32732: LD_VAR 0 1
32736: PPUSH
32737: CALL_OW 255
32741: PUSH
32742: LD_INT 1
32744: EQUAL
32745: IFFALSE 32755
// bombExploded := true ;
32747: LD_ADDR_EXP 37
32751: PUSH
32752: LD_INT 1
32754: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32755: LD_VAR 0 1
32759: PPUSH
32760: CALL_OW 255
32764: PUSH
32765: LD_INT 1
32767: EQUAL
32768: PUSH
32769: LD_EXP 30
32773: AND
32774: PUSH
32775: LD_INT 22
32777: PUSH
32778: LD_INT 3
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 34
32787: PUSH
32788: LD_INT 48
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PPUSH
32799: CALL_OW 69
32803: AND
32804: PUSH
32805: LD_INT 22
32807: PUSH
32808: LD_INT 1
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 34
32817: PUSH
32818: LD_INT 8
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PPUSH
32829: CALL_OW 69
32833: NOT
32834: AND
32835: IFFALSE 32887
// begin wait ( 0 0$5 ) ;
32837: LD_INT 175
32839: PPUSH
32840: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32844: LD_INT 22
32846: PUSH
32847: LD_INT 3
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 34
32856: PUSH
32857: LD_INT 48
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PPUSH
32868: CALL_OW 69
32872: PUSH
32873: LD_INT 1
32875: ARRAY
32876: PPUSH
32877: LD_INT 60
32879: PPUSH
32880: LD_INT 95
32882: PPUSH
32883: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32887: LD_VAR 0 2
32891: PPUSH
32892: LD_VAR 0 3
32896: PPUSH
32897: LD_INT 18
32899: PPUSH
32900: CALL_OW 309
32904: IFFALSE 32964
// begin if GetSide ( unit ) = 1 then
32906: LD_VAR 0 1
32910: PPUSH
32911: CALL_OW 255
32915: PUSH
32916: LD_INT 1
32918: EQUAL
32919: IFFALSE 32935
// begin wait ( 0 0$6 ) ;
32921: LD_INT 210
32923: PPUSH
32924: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32928: LD_STRING Motherlode2
32930: PPUSH
32931: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32935: LD_VAR 0 1
32939: PPUSH
32940: CALL_OW 255
32944: PUSH
32945: LD_INT 8
32947: EQUAL
32948: IFFALSE 32964
// begin wait ( 0 0$6 ) ;
32950: LD_INT 210
32952: PPUSH
32953: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32957: LD_STRING Motherlode1
32959: PPUSH
32960: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32964: LD_VAR 0 1
32968: PPUSH
32969: CALL_OW 255
32973: PUSH
32974: LD_INT 3
32976: EQUAL
32977: IFFALSE 32998
// begin wait ( 0 0$5 ) ;
32979: LD_INT 175
32981: PPUSH
32982: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32986: LD_EXP 63
32990: PPUSH
32991: LD_STRING D18-Pla-1
32993: PPUSH
32994: CALL_OW 94
// end ; end ;
32998: PPOPN 3
33000: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33001: LD_VAR 0 1
33005: PUSH
33006: LD_EXP 72
33010: IN
33011: IFFALSE 33031
// begin behemothBuilders := behemothBuilders diff un ;
33013: LD_ADDR_EXP 72
33017: PUSH
33018: LD_EXP 72
33022: PUSH
33023: LD_VAR 0 1
33027: DIFF
33028: ST_TO_ADDR
// exit ;
33029: GO 33129
// end ; if un = JMM then
33031: LD_VAR 0 1
33035: PUSH
33036: LD_EXP 38
33040: EQUAL
33041: IFFALSE 33052
// begin YouLost ( JMM ) ;
33043: LD_STRING JMM
33045: PPUSH
33046: CALL_OW 104
// exit ;
33050: GO 33129
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33052: LD_VAR 0 1
33056: PUSH
33057: LD_INT 22
33059: PUSH
33060: LD_INT 1
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 3
33069: PUSH
33070: LD_INT 25
33072: PUSH
33073: LD_INT 16
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 25
33082: PUSH
33083: LD_INT 12
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: LIST
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PPUSH
33099: CALL_OW 69
33103: IN
33104: IFFALSE 33120
// lostCounter := lostCounter + 1 ;
33106: LD_ADDR_EXP 32
33110: PUSH
33111: LD_EXP 32
33115: PUSH
33116: LD_INT 1
33118: PLUS
33119: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33120: LD_VAR 0 1
33124: PPUSH
33125: CALL 61413 0 1
// end ;
33129: PPOPN 1
33131: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33132: LD_VAR 0 1
33136: PPUSH
33137: LD_VAR 0 2
33141: PPUSH
33142: CALL 63747 0 2
// end ;
33146: PPOPN 2
33148: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33149: LD_VAR 0 1
33153: PPUSH
33154: CALL 62815 0 1
// end ;
33158: PPOPN 1
33160: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33161: LD_VAR 0 1
33165: PUSH
33166: LD_INT 22
33168: PUSH
33169: LD_INT 8
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 30
33178: PUSH
33179: LD_INT 2
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 23
33188: PUSH
33189: LD_INT 3
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: LIST
33200: PPUSH
33201: CALL_OW 69
33205: IN
33206: IFFALSE 33233
// begin ComUpgrade ( building ) ;
33208: LD_VAR 0 1
33212: PPUSH
33213: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33217: LD_EXP 60
33221: PPUSH
33222: LD_VAR 0 1
33226: PPUSH
33227: CALL 74453 0 2
// exit ;
33231: GO 33242
// end ; MCE_BuildingComplete ( building ) ;
33233: LD_VAR 0 1
33237: PPUSH
33238: CALL 63056 0 1
// end ;
33242: PPOPN 1
33244: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33245: LD_VAR 0 1
33249: PPUSH
33250: LD_VAR 0 2
33254: PPUSH
33255: CALL 61109 0 2
// end ;
33259: PPOPN 2
33261: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33262: LD_VAR 0 1
33266: PPUSH
33267: LD_VAR 0 2
33271: PPUSH
33272: LD_VAR 0 3
33276: PPUSH
33277: LD_VAR 0 4
33281: PPUSH
33282: LD_VAR 0 5
33286: PPUSH
33287: CALL 60729 0 5
// end ;
33291: PPOPN 5
33293: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33294: LD_VAR 0 1
33298: PPUSH
33299: LD_VAR 0 2
33303: PPUSH
33304: CALL 60325 0 2
// end ;
33308: PPOPN 2
33310: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33311: LD_VAR 0 1
33315: PPUSH
33316: LD_VAR 0 2
33320: PPUSH
33321: LD_VAR 0 3
33325: PPUSH
33326: LD_VAR 0 4
33330: PPUSH
33331: CALL 60163 0 4
// end ;
33335: PPOPN 4
33337: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33338: LD_VAR 0 1
33342: PPUSH
33343: LD_VAR 0 2
33347: PPUSH
33348: LD_VAR 0 3
33352: PPUSH
33353: CALL 59938 0 3
// end ;
33357: PPOPN 3
33359: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33360: LD_VAR 0 1
33364: PPUSH
33365: LD_VAR 0 2
33369: PPUSH
33370: CALL 59823 0 2
// end ;
33374: PPOPN 2
33376: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33377: LD_VAR 0 1
33381: PPUSH
33382: LD_VAR 0 2
33386: PPUSH
33387: CALL 64008 0 2
// end ;
33391: PPOPN 2
33393: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33394: LD_VAR 0 1
33398: PPUSH
33399: CALL_OW 255
33403: PUSH
33404: LD_INT 4
33406: EQUAL
33407: PUSH
33408: LD_VAR 0 1
33412: PUSH
33413: LD_EXP 18
33417: PUSH
33418: LD_INT 1
33420: ARRAY
33421: IN
33422: AND
33423: PUSH
33424: LD_EXP 19
33428: AND
33429: IFFALSE 33448
// begin ComMoveXY ( driver , 61 , 93 ) ;
33431: LD_VAR 0 1
33435: PPUSH
33436: LD_INT 61
33438: PPUSH
33439: LD_INT 93
33441: PPUSH
33442: CALL_OW 111
// exit ;
33446: GO 33472
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33448: LD_VAR 0 1
33452: PPUSH
33453: LD_VAR 0 2
33457: PPUSH
33458: LD_VAR 0 3
33462: PPUSH
33463: LD_VAR 0 4
33467: PPUSH
33468: CALL 64224 0 4
// end ;
33472: PPOPN 4
33474: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33475: LD_VAR 0 1
33479: PPUSH
33480: LD_VAR 0 2
33484: PPUSH
33485: CALL 59632 0 2
// end ;
33489: PPOPN 2
33491: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33492: LD_VAR 0 1
33496: PPUSH
33497: CALL 107625 0 1
// end ; end_of_file
33501: PPOPN 1
33503: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33504: LD_EXP 15
33508: PUSH
33509: LD_INT 2
33511: EQUAL
33512: IFFALSE 33991
33514: GO 33516
33516: DISABLE
33517: LD_INT 0
33519: PPUSH
// begin time := 0 0$40 ;
33520: LD_ADDR_VAR 0 1
33524: PUSH
33525: LD_INT 1400
33527: ST_TO_ADDR
// repeat wait ( time ) ;
33528: LD_VAR 0 1
33532: PPUSH
33533: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33537: LD_INT 1
33539: PPUSH
33540: LD_INT 5
33542: PPUSH
33543: CALL_OW 12
33547: PPUSH
33548: LD_INT 106
33550: PPUSH
33551: LD_INT 150
33553: PPUSH
33554: LD_INT 19
33556: PPUSH
33557: LD_INT 1
33559: PPUSH
33560: CALL_OW 56
// time := time + 0 0$9 ;
33564: LD_ADDR_VAR 0 1
33568: PUSH
33569: LD_VAR 0 1
33573: PUSH
33574: LD_INT 315
33576: PLUS
33577: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33578: LD_INT 455
33580: PPUSH
33581: LD_INT 840
33583: PPUSH
33584: CALL_OW 12
33588: PPUSH
33589: CALL_OW 67
// if Prob ( 50 ) then
33593: LD_INT 50
33595: PPUSH
33596: CALL_OW 13
33600: IFFALSE 33629
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33602: LD_INT 1
33604: PPUSH
33605: LD_INT 5
33607: PPUSH
33608: CALL_OW 12
33612: PPUSH
33613: LD_INT 62
33615: PPUSH
33616: LD_INT 108
33618: PPUSH
33619: LD_INT 10
33621: PPUSH
33622: LD_INT 1
33624: PPUSH
33625: CALL_OW 56
// until missionStage > 4 ;
33629: LD_EXP 15
33633: PUSH
33634: LD_INT 4
33636: GREATER
33637: IFFALSE 33528
// repeat wait ( 0 0$1 ) ;
33639: LD_INT 35
33641: PPUSH
33642: CALL_OW 67
// until missionStage = 6 ;
33646: LD_EXP 15
33650: PUSH
33651: LD_INT 6
33653: EQUAL
33654: IFFALSE 33639
// time := 0 0$50 ;
33656: LD_ADDR_VAR 0 1
33660: PUSH
33661: LD_INT 1750
33663: ST_TO_ADDR
// repeat wait ( time ) ;
33664: LD_VAR 0 1
33668: PPUSH
33669: CALL_OW 67
// if Prob ( 50 ) then
33673: LD_INT 50
33675: PPUSH
33676: CALL_OW 13
33680: IFFALSE 33709
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33682: LD_INT 1
33684: PPUSH
33685: LD_INT 5
33687: PPUSH
33688: CALL_OW 12
33692: PPUSH
33693: LD_INT 106
33695: PPUSH
33696: LD_INT 89
33698: PPUSH
33699: LD_INT 45
33701: PPUSH
33702: LD_INT 1
33704: PPUSH
33705: CALL_OW 56
// time := time + 0 0$3 ;
33709: LD_ADDR_VAR 0 1
33713: PUSH
33714: LD_VAR 0 1
33718: PUSH
33719: LD_INT 105
33721: PLUS
33722: ST_TO_ADDR
// if Prob ( 30 ) then
33723: LD_INT 30
33725: PPUSH
33726: CALL_OW 13
33730: IFFALSE 33776
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33732: LD_INT 525
33734: PPUSH
33735: LD_INT 735
33737: PPUSH
33738: CALL_OW 12
33742: PPUSH
33743: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33747: LD_INT 1
33749: PPUSH
33750: LD_INT 5
33752: PPUSH
33753: CALL_OW 12
33757: PPUSH
33758: LD_INT 21
33760: PPUSH
33761: LD_INT 26
33763: PPUSH
33764: LD_INT 12
33766: PPUSH
33767: LD_INT 1
33769: PPUSH
33770: CALL_OW 56
// end else
33774: GO 33812
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33776: LD_INT 700
33778: PPUSH
33779: LD_INT 1225
33781: PPUSH
33782: CALL_OW 12
33786: PPUSH
33787: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33791: LD_INT 1
33793: PPUSH
33794: LD_INT 5
33796: PPUSH
33797: CALL_OW 12
33801: PPUSH
33802: LD_INT 16
33804: PPUSH
33805: LD_INT 1
33807: PPUSH
33808: CALL_OW 55
// end ; if Prob ( 50 ) then
33812: LD_INT 50
33814: PPUSH
33815: CALL_OW 13
33819: IFFALSE 33865
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33821: LD_INT 700
33823: PPUSH
33824: LD_INT 1050
33826: PPUSH
33827: CALL_OW 12
33831: PPUSH
33832: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33836: LD_INT 1
33838: PPUSH
33839: LD_INT 5
33841: PPUSH
33842: CALL_OW 12
33846: PPUSH
33847: LD_INT 181
33849: PPUSH
33850: LD_INT 218
33852: PPUSH
33853: LD_INT 16
33855: PPUSH
33856: LD_INT 1
33858: PPUSH
33859: CALL_OW 56
// end else
33863: GO 33901
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33865: LD_INT 350
33867: PPUSH
33868: LD_INT 525
33870: PPUSH
33871: CALL_OW 12
33875: PPUSH
33876: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33880: LD_INT 1
33882: PPUSH
33883: LD_INT 5
33885: PPUSH
33886: CALL_OW 12
33890: PPUSH
33891: LD_INT 15
33893: PPUSH
33894: LD_INT 1
33896: PPUSH
33897: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33901: LD_INT 45
33903: PUSH
33904: LD_INT 32
33906: PUSH
33907: LD_INT 25
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: PUSH
33915: LD_OWVAR 67
33919: ARRAY
33920: PPUSH
33921: CALL_OW 13
33925: IFFALSE 33969
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33927: LD_INT 525
33929: PPUSH
33930: LD_INT 875
33932: PPUSH
33933: CALL_OW 12
33937: PPUSH
33938: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33942: LD_INT 1
33944: PPUSH
33945: LD_INT 5
33947: PPUSH
33948: CALL_OW 12
33952: PPUSH
33953: LD_INT 103
33955: PPUSH
33956: LD_INT 140
33958: PPUSH
33959: LD_INT 20
33961: PPUSH
33962: LD_INT 1
33964: PPUSH
33965: CALL_OW 56
// end ; if time > 2 2$20 then
33969: LD_VAR 0 1
33973: PUSH
33974: LD_INT 4900
33976: GREATER
33977: IFFALSE 33987
// time := 0 0$50 ;
33979: LD_ADDR_VAR 0 1
33983: PUSH
33984: LD_INT 1750
33986: ST_TO_ADDR
// until false ;
33987: LD_INT 0
33989: IFFALSE 33664
// end ; end_of_file
33991: PPOPN 1
33993: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33994: LD_EXP 13
33998: PUSH
33999: LD_EXP 15
34003: PUSH
34004: LD_INT 6
34006: GREATEREQUAL
34007: AND
34008: IFFALSE 34045
34010: GO 34012
34012: DISABLE
// begin enable ;
34013: ENABLE
// missionTime := missionTime + 0 0$1 ;
34014: LD_ADDR_EXP 14
34018: PUSH
34019: LD_EXP 14
34023: PUSH
34024: LD_INT 35
34026: PLUS
34027: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34028: LD_ADDR_OWVAR 47
34032: PUSH
34033: LD_STRING #Am15-1
34035: PUSH
34036: LD_EXP 14
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: ST_TO_ADDR
// end ; end_of_file
34045: END
// export function InitNature ; begin
34046: LD_INT 0
34048: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34049: LD_INT 3
34051: PPUSH
34052: LD_INT 3
34054: PPUSH
34055: LD_INT 2
34057: PPUSH
34058: LD_INT 1
34060: PPUSH
34061: LD_INT 1
34063: PPUSH
34064: LD_INT 0
34066: PPUSH
34067: LD_INT 0
34069: PPUSH
34070: LD_INT 20
34072: PPUSH
34073: LD_INT 0
34075: PPUSH
34076: CALL 99294 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34080: LD_INT 2
34082: PPUSH
34083: LD_INT 1
34085: PPUSH
34086: LD_INT 1
34088: PPUSH
34089: LD_INT 1
34091: PPUSH
34092: LD_INT 1
34094: PPUSH
34095: LD_INT 0
34097: PPUSH
34098: LD_INT 0
34100: PPUSH
34101: LD_INT 21
34103: PPUSH
34104: LD_INT 0
34106: PPUSH
34107: CALL 99294 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34111: LD_INT 4
34113: PPUSH
34114: LD_INT 1
34116: PPUSH
34117: LD_INT 2
34119: PPUSH
34120: LD_INT 4
34122: PPUSH
34123: LD_INT 2
34125: PPUSH
34126: LD_INT 1
34128: PPUSH
34129: LD_INT 0
34131: PPUSH
34132: LD_INT 22
34134: PPUSH
34135: LD_INT 0
34137: PPUSH
34138: CALL 99294 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34142: LD_INT 0
34144: PPUSH
34145: LD_INT 0
34147: PPUSH
34148: LD_INT 0
34150: PPUSH
34151: LD_INT 0
34153: PPUSH
34154: LD_INT 0
34156: PPUSH
34157: LD_INT 0
34159: PPUSH
34160: LD_INT 9
34162: PPUSH
34163: LD_INT 0
34165: PPUSH
34166: LD_INT 23
34168: PPUSH
34169: CALL 99294 0 9
// end ; end_of_file
34173: LD_VAR 0 1
34177: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34178: GO 34180
34180: DISABLE
// begin ru_radar := 98 ;
34181: LD_ADDR_EXP 94
34185: PUSH
34186: LD_INT 98
34188: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34189: LD_ADDR_EXP 95
34193: PUSH
34194: LD_INT 89
34196: ST_TO_ADDR
// us_hack := 99 ;
34197: LD_ADDR_EXP 96
34201: PUSH
34202: LD_INT 99
34204: ST_TO_ADDR
// us_artillery := 97 ;
34205: LD_ADDR_EXP 97
34209: PUSH
34210: LD_INT 97
34212: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34213: LD_ADDR_EXP 98
34217: PUSH
34218: LD_INT 91
34220: ST_TO_ADDR
// end ; end_of_file
34221: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34222: LD_INT 0
34224: PPUSH
34225: PPUSH
// skirmish := false ;
34226: LD_ADDR_EXP 99
34230: PUSH
34231: LD_INT 0
34233: ST_TO_ADDR
// debug_mc := false ;
34234: LD_ADDR_EXP 100
34238: PUSH
34239: LD_INT 0
34241: ST_TO_ADDR
// mc_bases := [ ] ;
34242: LD_ADDR_EXP 101
34246: PUSH
34247: EMPTY
34248: ST_TO_ADDR
// mc_sides := [ ] ;
34249: LD_ADDR_EXP 127
34253: PUSH
34254: EMPTY
34255: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34256: LD_ADDR_EXP 102
34260: PUSH
34261: EMPTY
34262: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34263: LD_ADDR_EXP 103
34267: PUSH
34268: EMPTY
34269: ST_TO_ADDR
// mc_need_heal := [ ] ;
34270: LD_ADDR_EXP 104
34274: PUSH
34275: EMPTY
34276: ST_TO_ADDR
// mc_healers := [ ] ;
34277: LD_ADDR_EXP 105
34281: PUSH
34282: EMPTY
34283: ST_TO_ADDR
// mc_build_list := [ ] ;
34284: LD_ADDR_EXP 106
34288: PUSH
34289: EMPTY
34290: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34291: LD_ADDR_EXP 133
34295: PUSH
34296: EMPTY
34297: ST_TO_ADDR
// mc_builders := [ ] ;
34298: LD_ADDR_EXP 107
34302: PUSH
34303: EMPTY
34304: ST_TO_ADDR
// mc_construct_list := [ ] ;
34305: LD_ADDR_EXP 108
34309: PUSH
34310: EMPTY
34311: ST_TO_ADDR
// mc_turret_list := [ ] ;
34312: LD_ADDR_EXP 109
34316: PUSH
34317: EMPTY
34318: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34319: LD_ADDR_EXP 110
34323: PUSH
34324: EMPTY
34325: ST_TO_ADDR
// mc_miners := [ ] ;
34326: LD_ADDR_EXP 115
34330: PUSH
34331: EMPTY
34332: ST_TO_ADDR
// mc_mines := [ ] ;
34333: LD_ADDR_EXP 114
34337: PUSH
34338: EMPTY
34339: ST_TO_ADDR
// mc_minefields := [ ] ;
34340: LD_ADDR_EXP 116
34344: PUSH
34345: EMPTY
34346: ST_TO_ADDR
// mc_crates := [ ] ;
34347: LD_ADDR_EXP 117
34351: PUSH
34352: EMPTY
34353: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34354: LD_ADDR_EXP 118
34358: PUSH
34359: EMPTY
34360: ST_TO_ADDR
// mc_crates_area := [ ] ;
34361: LD_ADDR_EXP 119
34365: PUSH
34366: EMPTY
34367: ST_TO_ADDR
// mc_vehicles := [ ] ;
34368: LD_ADDR_EXP 120
34372: PUSH
34373: EMPTY
34374: ST_TO_ADDR
// mc_attack := [ ] ;
34375: LD_ADDR_EXP 121
34379: PUSH
34380: EMPTY
34381: ST_TO_ADDR
// mc_produce := [ ] ;
34382: LD_ADDR_EXP 122
34386: PUSH
34387: EMPTY
34388: ST_TO_ADDR
// mc_defender := [ ] ;
34389: LD_ADDR_EXP 123
34393: PUSH
34394: EMPTY
34395: ST_TO_ADDR
// mc_parking := [ ] ;
34396: LD_ADDR_EXP 125
34400: PUSH
34401: EMPTY
34402: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34403: LD_ADDR_EXP 111
34407: PUSH
34408: EMPTY
34409: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34410: LD_ADDR_EXP 113
34414: PUSH
34415: EMPTY
34416: ST_TO_ADDR
// mc_scan := [ ] ;
34417: LD_ADDR_EXP 124
34421: PUSH
34422: EMPTY
34423: ST_TO_ADDR
// mc_scan_area := [ ] ;
34424: LD_ADDR_EXP 126
34428: PUSH
34429: EMPTY
34430: ST_TO_ADDR
// mc_tech := [ ] ;
34431: LD_ADDR_EXP 128
34435: PUSH
34436: EMPTY
34437: ST_TO_ADDR
// mc_class := [ ] ;
34438: LD_ADDR_EXP 142
34442: PUSH
34443: EMPTY
34444: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34445: LD_ADDR_EXP 143
34449: PUSH
34450: EMPTY
34451: ST_TO_ADDR
// end ;
34452: LD_VAR 0 1
34456: RET
// export function MC_Kill ( base ) ; begin
34457: LD_INT 0
34459: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34460: LD_ADDR_EXP 101
34464: PUSH
34465: LD_EXP 101
34469: PPUSH
34470: LD_VAR 0 1
34474: PPUSH
34475: EMPTY
34476: PPUSH
34477: CALL_OW 1
34481: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34482: LD_ADDR_EXP 102
34486: PUSH
34487: LD_EXP 102
34491: PPUSH
34492: LD_VAR 0 1
34496: PPUSH
34497: EMPTY
34498: PPUSH
34499: CALL_OW 1
34503: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34504: LD_ADDR_EXP 103
34508: PUSH
34509: LD_EXP 103
34513: PPUSH
34514: LD_VAR 0 1
34518: PPUSH
34519: EMPTY
34520: PPUSH
34521: CALL_OW 1
34525: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34526: LD_ADDR_EXP 104
34530: PUSH
34531: LD_EXP 104
34535: PPUSH
34536: LD_VAR 0 1
34540: PPUSH
34541: EMPTY
34542: PPUSH
34543: CALL_OW 1
34547: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34548: LD_ADDR_EXP 105
34552: PUSH
34553: LD_EXP 105
34557: PPUSH
34558: LD_VAR 0 1
34562: PPUSH
34563: EMPTY
34564: PPUSH
34565: CALL_OW 1
34569: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34570: LD_ADDR_EXP 106
34574: PUSH
34575: LD_EXP 106
34579: PPUSH
34580: LD_VAR 0 1
34584: PPUSH
34585: EMPTY
34586: PPUSH
34587: CALL_OW 1
34591: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34592: LD_ADDR_EXP 107
34596: PUSH
34597: LD_EXP 107
34601: PPUSH
34602: LD_VAR 0 1
34606: PPUSH
34607: EMPTY
34608: PPUSH
34609: CALL_OW 1
34613: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34614: LD_ADDR_EXP 108
34618: PUSH
34619: LD_EXP 108
34623: PPUSH
34624: LD_VAR 0 1
34628: PPUSH
34629: EMPTY
34630: PPUSH
34631: CALL_OW 1
34635: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34636: LD_ADDR_EXP 109
34640: PUSH
34641: LD_EXP 109
34645: PPUSH
34646: LD_VAR 0 1
34650: PPUSH
34651: EMPTY
34652: PPUSH
34653: CALL_OW 1
34657: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34658: LD_ADDR_EXP 110
34662: PUSH
34663: LD_EXP 110
34667: PPUSH
34668: LD_VAR 0 1
34672: PPUSH
34673: EMPTY
34674: PPUSH
34675: CALL_OW 1
34679: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34680: LD_ADDR_EXP 111
34684: PUSH
34685: LD_EXP 111
34689: PPUSH
34690: LD_VAR 0 1
34694: PPUSH
34695: EMPTY
34696: PPUSH
34697: CALL_OW 1
34701: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34702: LD_ADDR_EXP 112
34706: PUSH
34707: LD_EXP 112
34711: PPUSH
34712: LD_VAR 0 1
34716: PPUSH
34717: LD_INT 0
34719: PPUSH
34720: CALL_OW 1
34724: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34725: LD_ADDR_EXP 113
34729: PUSH
34730: LD_EXP 113
34734: PPUSH
34735: LD_VAR 0 1
34739: PPUSH
34740: EMPTY
34741: PPUSH
34742: CALL_OW 1
34746: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34747: LD_ADDR_EXP 114
34751: PUSH
34752: LD_EXP 114
34756: PPUSH
34757: LD_VAR 0 1
34761: PPUSH
34762: EMPTY
34763: PPUSH
34764: CALL_OW 1
34768: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34769: LD_ADDR_EXP 115
34773: PUSH
34774: LD_EXP 115
34778: PPUSH
34779: LD_VAR 0 1
34783: PPUSH
34784: EMPTY
34785: PPUSH
34786: CALL_OW 1
34790: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34791: LD_ADDR_EXP 116
34795: PUSH
34796: LD_EXP 116
34800: PPUSH
34801: LD_VAR 0 1
34805: PPUSH
34806: EMPTY
34807: PPUSH
34808: CALL_OW 1
34812: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34813: LD_ADDR_EXP 117
34817: PUSH
34818: LD_EXP 117
34822: PPUSH
34823: LD_VAR 0 1
34827: PPUSH
34828: EMPTY
34829: PPUSH
34830: CALL_OW 1
34834: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34835: LD_ADDR_EXP 118
34839: PUSH
34840: LD_EXP 118
34844: PPUSH
34845: LD_VAR 0 1
34849: PPUSH
34850: EMPTY
34851: PPUSH
34852: CALL_OW 1
34856: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34857: LD_ADDR_EXP 119
34861: PUSH
34862: LD_EXP 119
34866: PPUSH
34867: LD_VAR 0 1
34871: PPUSH
34872: EMPTY
34873: PPUSH
34874: CALL_OW 1
34878: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34879: LD_ADDR_EXP 120
34883: PUSH
34884: LD_EXP 120
34888: PPUSH
34889: LD_VAR 0 1
34893: PPUSH
34894: EMPTY
34895: PPUSH
34896: CALL_OW 1
34900: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34901: LD_ADDR_EXP 121
34905: PUSH
34906: LD_EXP 121
34910: PPUSH
34911: LD_VAR 0 1
34915: PPUSH
34916: EMPTY
34917: PPUSH
34918: CALL_OW 1
34922: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34923: LD_ADDR_EXP 122
34927: PUSH
34928: LD_EXP 122
34932: PPUSH
34933: LD_VAR 0 1
34937: PPUSH
34938: EMPTY
34939: PPUSH
34940: CALL_OW 1
34944: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34945: LD_ADDR_EXP 123
34949: PUSH
34950: LD_EXP 123
34954: PPUSH
34955: LD_VAR 0 1
34959: PPUSH
34960: EMPTY
34961: PPUSH
34962: CALL_OW 1
34966: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34967: LD_ADDR_EXP 124
34971: PUSH
34972: LD_EXP 124
34976: PPUSH
34977: LD_VAR 0 1
34981: PPUSH
34982: EMPTY
34983: PPUSH
34984: CALL_OW 1
34988: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34989: LD_ADDR_EXP 125
34993: PUSH
34994: LD_EXP 125
34998: PPUSH
34999: LD_VAR 0 1
35003: PPUSH
35004: EMPTY
35005: PPUSH
35006: CALL_OW 1
35010: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35011: LD_ADDR_EXP 126
35015: PUSH
35016: LD_EXP 126
35020: PPUSH
35021: LD_VAR 0 1
35025: PPUSH
35026: EMPTY
35027: PPUSH
35028: CALL_OW 1
35032: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35033: LD_ADDR_EXP 128
35037: PUSH
35038: LD_EXP 128
35042: PPUSH
35043: LD_VAR 0 1
35047: PPUSH
35048: EMPTY
35049: PPUSH
35050: CALL_OW 1
35054: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35055: LD_ADDR_EXP 130
35059: PUSH
35060: LD_EXP 130
35064: PPUSH
35065: LD_VAR 0 1
35069: PPUSH
35070: EMPTY
35071: PPUSH
35072: CALL_OW 1
35076: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35077: LD_ADDR_EXP 131
35081: PUSH
35082: LD_EXP 131
35086: PPUSH
35087: LD_VAR 0 1
35091: PPUSH
35092: EMPTY
35093: PPUSH
35094: CALL_OW 1
35098: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35099: LD_ADDR_EXP 132
35103: PUSH
35104: LD_EXP 132
35108: PPUSH
35109: LD_VAR 0 1
35113: PPUSH
35114: EMPTY
35115: PPUSH
35116: CALL_OW 1
35120: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35121: LD_ADDR_EXP 133
35125: PUSH
35126: LD_EXP 133
35130: PPUSH
35131: LD_VAR 0 1
35135: PPUSH
35136: EMPTY
35137: PPUSH
35138: CALL_OW 1
35142: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35143: LD_ADDR_EXP 134
35147: PUSH
35148: LD_EXP 134
35152: PPUSH
35153: LD_VAR 0 1
35157: PPUSH
35158: EMPTY
35159: PPUSH
35160: CALL_OW 1
35164: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35165: LD_ADDR_EXP 135
35169: PUSH
35170: LD_EXP 135
35174: PPUSH
35175: LD_VAR 0 1
35179: PPUSH
35180: EMPTY
35181: PPUSH
35182: CALL_OW 1
35186: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35187: LD_ADDR_EXP 136
35191: PUSH
35192: LD_EXP 136
35196: PPUSH
35197: LD_VAR 0 1
35201: PPUSH
35202: EMPTY
35203: PPUSH
35204: CALL_OW 1
35208: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35209: LD_ADDR_EXP 137
35213: PUSH
35214: LD_EXP 137
35218: PPUSH
35219: LD_VAR 0 1
35223: PPUSH
35224: EMPTY
35225: PPUSH
35226: CALL_OW 1
35230: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35231: LD_ADDR_EXP 138
35235: PUSH
35236: LD_EXP 138
35240: PPUSH
35241: LD_VAR 0 1
35245: PPUSH
35246: EMPTY
35247: PPUSH
35248: CALL_OW 1
35252: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35253: LD_ADDR_EXP 139
35257: PUSH
35258: LD_EXP 139
35262: PPUSH
35263: LD_VAR 0 1
35267: PPUSH
35268: EMPTY
35269: PPUSH
35270: CALL_OW 1
35274: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35275: LD_ADDR_EXP 140
35279: PUSH
35280: LD_EXP 140
35284: PPUSH
35285: LD_VAR 0 1
35289: PPUSH
35290: EMPTY
35291: PPUSH
35292: CALL_OW 1
35296: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35297: LD_ADDR_EXP 141
35301: PUSH
35302: LD_EXP 141
35306: PPUSH
35307: LD_VAR 0 1
35311: PPUSH
35312: EMPTY
35313: PPUSH
35314: CALL_OW 1
35318: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35319: LD_ADDR_EXP 142
35323: PUSH
35324: LD_EXP 142
35328: PPUSH
35329: LD_VAR 0 1
35333: PPUSH
35334: EMPTY
35335: PPUSH
35336: CALL_OW 1
35340: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35341: LD_ADDR_EXP 143
35345: PUSH
35346: LD_EXP 143
35350: PPUSH
35351: LD_VAR 0 1
35355: PPUSH
35356: LD_INT 0
35358: PPUSH
35359: CALL_OW 1
35363: ST_TO_ADDR
// end ;
35364: LD_VAR 0 2
35368: RET
// export function MC_Add ( side , units ) ; var base ; begin
35369: LD_INT 0
35371: PPUSH
35372: PPUSH
// base := mc_bases + 1 ;
35373: LD_ADDR_VAR 0 4
35377: PUSH
35378: LD_EXP 101
35382: PUSH
35383: LD_INT 1
35385: PLUS
35386: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35387: LD_ADDR_EXP 127
35391: PUSH
35392: LD_EXP 127
35396: PPUSH
35397: LD_VAR 0 4
35401: PPUSH
35402: LD_VAR 0 1
35406: PPUSH
35407: CALL_OW 1
35411: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35412: LD_ADDR_EXP 101
35416: PUSH
35417: LD_EXP 101
35421: PPUSH
35422: LD_VAR 0 4
35426: PPUSH
35427: LD_VAR 0 2
35431: PPUSH
35432: CALL_OW 1
35436: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35437: LD_ADDR_EXP 102
35441: PUSH
35442: LD_EXP 102
35446: PPUSH
35447: LD_VAR 0 4
35451: PPUSH
35452: EMPTY
35453: PPUSH
35454: CALL_OW 1
35458: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35459: LD_ADDR_EXP 103
35463: PUSH
35464: LD_EXP 103
35468: PPUSH
35469: LD_VAR 0 4
35473: PPUSH
35474: EMPTY
35475: PPUSH
35476: CALL_OW 1
35480: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35481: LD_ADDR_EXP 104
35485: PUSH
35486: LD_EXP 104
35490: PPUSH
35491: LD_VAR 0 4
35495: PPUSH
35496: EMPTY
35497: PPUSH
35498: CALL_OW 1
35502: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35503: LD_ADDR_EXP 105
35507: PUSH
35508: LD_EXP 105
35512: PPUSH
35513: LD_VAR 0 4
35517: PPUSH
35518: EMPTY
35519: PPUSH
35520: CALL_OW 1
35524: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35525: LD_ADDR_EXP 106
35529: PUSH
35530: LD_EXP 106
35534: PPUSH
35535: LD_VAR 0 4
35539: PPUSH
35540: EMPTY
35541: PPUSH
35542: CALL_OW 1
35546: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35547: LD_ADDR_EXP 107
35551: PUSH
35552: LD_EXP 107
35556: PPUSH
35557: LD_VAR 0 4
35561: PPUSH
35562: EMPTY
35563: PPUSH
35564: CALL_OW 1
35568: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35569: LD_ADDR_EXP 108
35573: PUSH
35574: LD_EXP 108
35578: PPUSH
35579: LD_VAR 0 4
35583: PPUSH
35584: EMPTY
35585: PPUSH
35586: CALL_OW 1
35590: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35591: LD_ADDR_EXP 109
35595: PUSH
35596: LD_EXP 109
35600: PPUSH
35601: LD_VAR 0 4
35605: PPUSH
35606: EMPTY
35607: PPUSH
35608: CALL_OW 1
35612: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35613: LD_ADDR_EXP 110
35617: PUSH
35618: LD_EXP 110
35622: PPUSH
35623: LD_VAR 0 4
35627: PPUSH
35628: EMPTY
35629: PPUSH
35630: CALL_OW 1
35634: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35635: LD_ADDR_EXP 111
35639: PUSH
35640: LD_EXP 111
35644: PPUSH
35645: LD_VAR 0 4
35649: PPUSH
35650: EMPTY
35651: PPUSH
35652: CALL_OW 1
35656: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35657: LD_ADDR_EXP 112
35661: PUSH
35662: LD_EXP 112
35666: PPUSH
35667: LD_VAR 0 4
35671: PPUSH
35672: LD_INT 0
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35680: LD_ADDR_EXP 113
35684: PUSH
35685: LD_EXP 113
35689: PPUSH
35690: LD_VAR 0 4
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35702: LD_ADDR_EXP 114
35706: PUSH
35707: LD_EXP 114
35711: PPUSH
35712: LD_VAR 0 4
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35724: LD_ADDR_EXP 115
35728: PUSH
35729: LD_EXP 115
35733: PPUSH
35734: LD_VAR 0 4
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35746: LD_ADDR_EXP 116
35750: PUSH
35751: LD_EXP 116
35755: PPUSH
35756: LD_VAR 0 4
35760: PPUSH
35761: EMPTY
35762: PPUSH
35763: CALL_OW 1
35767: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35768: LD_ADDR_EXP 117
35772: PUSH
35773: LD_EXP 117
35777: PPUSH
35778: LD_VAR 0 4
35782: PPUSH
35783: EMPTY
35784: PPUSH
35785: CALL_OW 1
35789: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35790: LD_ADDR_EXP 118
35794: PUSH
35795: LD_EXP 118
35799: PPUSH
35800: LD_VAR 0 4
35804: PPUSH
35805: EMPTY
35806: PPUSH
35807: CALL_OW 1
35811: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35812: LD_ADDR_EXP 119
35816: PUSH
35817: LD_EXP 119
35821: PPUSH
35822: LD_VAR 0 4
35826: PPUSH
35827: EMPTY
35828: PPUSH
35829: CALL_OW 1
35833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35834: LD_ADDR_EXP 120
35838: PUSH
35839: LD_EXP 120
35843: PPUSH
35844: LD_VAR 0 4
35848: PPUSH
35849: EMPTY
35850: PPUSH
35851: CALL_OW 1
35855: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35856: LD_ADDR_EXP 121
35860: PUSH
35861: LD_EXP 121
35865: PPUSH
35866: LD_VAR 0 4
35870: PPUSH
35871: EMPTY
35872: PPUSH
35873: CALL_OW 1
35877: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35878: LD_ADDR_EXP 122
35882: PUSH
35883: LD_EXP 122
35887: PPUSH
35888: LD_VAR 0 4
35892: PPUSH
35893: EMPTY
35894: PPUSH
35895: CALL_OW 1
35899: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35900: LD_ADDR_EXP 123
35904: PUSH
35905: LD_EXP 123
35909: PPUSH
35910: LD_VAR 0 4
35914: PPUSH
35915: EMPTY
35916: PPUSH
35917: CALL_OW 1
35921: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35922: LD_ADDR_EXP 124
35926: PUSH
35927: LD_EXP 124
35931: PPUSH
35932: LD_VAR 0 4
35936: PPUSH
35937: EMPTY
35938: PPUSH
35939: CALL_OW 1
35943: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35944: LD_ADDR_EXP 125
35948: PUSH
35949: LD_EXP 125
35953: PPUSH
35954: LD_VAR 0 4
35958: PPUSH
35959: EMPTY
35960: PPUSH
35961: CALL_OW 1
35965: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35966: LD_ADDR_EXP 126
35970: PUSH
35971: LD_EXP 126
35975: PPUSH
35976: LD_VAR 0 4
35980: PPUSH
35981: EMPTY
35982: PPUSH
35983: CALL_OW 1
35987: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35988: LD_ADDR_EXP 128
35992: PUSH
35993: LD_EXP 128
35997: PPUSH
35998: LD_VAR 0 4
36002: PPUSH
36003: EMPTY
36004: PPUSH
36005: CALL_OW 1
36009: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36010: LD_ADDR_EXP 130
36014: PUSH
36015: LD_EXP 130
36019: PPUSH
36020: LD_VAR 0 4
36024: PPUSH
36025: EMPTY
36026: PPUSH
36027: CALL_OW 1
36031: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36032: LD_ADDR_EXP 131
36036: PUSH
36037: LD_EXP 131
36041: PPUSH
36042: LD_VAR 0 4
36046: PPUSH
36047: EMPTY
36048: PPUSH
36049: CALL_OW 1
36053: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36054: LD_ADDR_EXP 132
36058: PUSH
36059: LD_EXP 132
36063: PPUSH
36064: LD_VAR 0 4
36068: PPUSH
36069: EMPTY
36070: PPUSH
36071: CALL_OW 1
36075: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36076: LD_ADDR_EXP 133
36080: PUSH
36081: LD_EXP 133
36085: PPUSH
36086: LD_VAR 0 4
36090: PPUSH
36091: EMPTY
36092: PPUSH
36093: CALL_OW 1
36097: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36098: LD_ADDR_EXP 134
36102: PUSH
36103: LD_EXP 134
36107: PPUSH
36108: LD_VAR 0 4
36112: PPUSH
36113: EMPTY
36114: PPUSH
36115: CALL_OW 1
36119: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36120: LD_ADDR_EXP 135
36124: PUSH
36125: LD_EXP 135
36129: PPUSH
36130: LD_VAR 0 4
36134: PPUSH
36135: EMPTY
36136: PPUSH
36137: CALL_OW 1
36141: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36142: LD_ADDR_EXP 136
36146: PUSH
36147: LD_EXP 136
36151: PPUSH
36152: LD_VAR 0 4
36156: PPUSH
36157: EMPTY
36158: PPUSH
36159: CALL_OW 1
36163: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36164: LD_ADDR_EXP 137
36168: PUSH
36169: LD_EXP 137
36173: PPUSH
36174: LD_VAR 0 4
36178: PPUSH
36179: EMPTY
36180: PPUSH
36181: CALL_OW 1
36185: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36186: LD_ADDR_EXP 138
36190: PUSH
36191: LD_EXP 138
36195: PPUSH
36196: LD_VAR 0 4
36200: PPUSH
36201: EMPTY
36202: PPUSH
36203: CALL_OW 1
36207: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36208: LD_ADDR_EXP 139
36212: PUSH
36213: LD_EXP 139
36217: PPUSH
36218: LD_VAR 0 4
36222: PPUSH
36223: EMPTY
36224: PPUSH
36225: CALL_OW 1
36229: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36230: LD_ADDR_EXP 140
36234: PUSH
36235: LD_EXP 140
36239: PPUSH
36240: LD_VAR 0 4
36244: PPUSH
36245: EMPTY
36246: PPUSH
36247: CALL_OW 1
36251: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36252: LD_ADDR_EXP 141
36256: PUSH
36257: LD_EXP 141
36261: PPUSH
36262: LD_VAR 0 4
36266: PPUSH
36267: EMPTY
36268: PPUSH
36269: CALL_OW 1
36273: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36274: LD_ADDR_EXP 142
36278: PUSH
36279: LD_EXP 142
36283: PPUSH
36284: LD_VAR 0 4
36288: PPUSH
36289: EMPTY
36290: PPUSH
36291: CALL_OW 1
36295: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36296: LD_ADDR_EXP 143
36300: PUSH
36301: LD_EXP 143
36305: PPUSH
36306: LD_VAR 0 4
36310: PPUSH
36311: LD_INT 0
36313: PPUSH
36314: CALL_OW 1
36318: ST_TO_ADDR
// result := base ;
36319: LD_ADDR_VAR 0 3
36323: PUSH
36324: LD_VAR 0 4
36328: ST_TO_ADDR
// end ;
36329: LD_VAR 0 3
36333: RET
// export function MC_Start ( ) ; var i ; begin
36334: LD_INT 0
36336: PPUSH
36337: PPUSH
// for i = 1 to mc_bases do
36338: LD_ADDR_VAR 0 2
36342: PUSH
36343: DOUBLE
36344: LD_INT 1
36346: DEC
36347: ST_TO_ADDR
36348: LD_EXP 101
36352: PUSH
36353: FOR_TO
36354: IFFALSE 37431
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36356: LD_ADDR_EXP 101
36360: PUSH
36361: LD_EXP 101
36365: PPUSH
36366: LD_VAR 0 2
36370: PPUSH
36371: LD_EXP 101
36375: PUSH
36376: LD_VAR 0 2
36380: ARRAY
36381: PUSH
36382: LD_INT 0
36384: DIFF
36385: PPUSH
36386: CALL_OW 1
36390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36391: LD_ADDR_EXP 102
36395: PUSH
36396: LD_EXP 102
36400: PPUSH
36401: LD_VAR 0 2
36405: PPUSH
36406: EMPTY
36407: PPUSH
36408: CALL_OW 1
36412: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36413: LD_ADDR_EXP 103
36417: PUSH
36418: LD_EXP 103
36422: PPUSH
36423: LD_VAR 0 2
36427: PPUSH
36428: EMPTY
36429: PPUSH
36430: CALL_OW 1
36434: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36435: LD_ADDR_EXP 104
36439: PUSH
36440: LD_EXP 104
36444: PPUSH
36445: LD_VAR 0 2
36449: PPUSH
36450: EMPTY
36451: PPUSH
36452: CALL_OW 1
36456: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36457: LD_ADDR_EXP 105
36461: PUSH
36462: LD_EXP 105
36466: PPUSH
36467: LD_VAR 0 2
36471: PPUSH
36472: EMPTY
36473: PUSH
36474: EMPTY
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PPUSH
36480: CALL_OW 1
36484: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36485: LD_ADDR_EXP 106
36489: PUSH
36490: LD_EXP 106
36494: PPUSH
36495: LD_VAR 0 2
36499: PPUSH
36500: EMPTY
36501: PPUSH
36502: CALL_OW 1
36506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36507: LD_ADDR_EXP 133
36511: PUSH
36512: LD_EXP 133
36516: PPUSH
36517: LD_VAR 0 2
36521: PPUSH
36522: EMPTY
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36529: LD_ADDR_EXP 107
36533: PUSH
36534: LD_EXP 107
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36551: LD_ADDR_EXP 108
36555: PUSH
36556: LD_EXP 108
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: EMPTY
36567: PPUSH
36568: CALL_OW 1
36572: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36573: LD_ADDR_EXP 109
36577: PUSH
36578: LD_EXP 109
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: LD_EXP 101
36592: PUSH
36593: LD_VAR 0 2
36597: ARRAY
36598: PPUSH
36599: LD_INT 2
36601: PUSH
36602: LD_INT 30
36604: PUSH
36605: LD_INT 32
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 30
36614: PUSH
36615: LD_INT 33
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: LIST
36626: PPUSH
36627: CALL_OW 72
36631: PPUSH
36632: CALL_OW 1
36636: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36637: LD_ADDR_EXP 110
36641: PUSH
36642: LD_EXP 110
36646: PPUSH
36647: LD_VAR 0 2
36651: PPUSH
36652: LD_EXP 101
36656: PUSH
36657: LD_VAR 0 2
36661: ARRAY
36662: PPUSH
36663: LD_INT 2
36665: PUSH
36666: LD_INT 30
36668: PUSH
36669: LD_INT 32
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 30
36678: PUSH
36679: LD_INT 31
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 58
36693: PUSH
36694: EMPTY
36695: LIST
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PPUSH
36701: CALL_OW 72
36705: PPUSH
36706: CALL_OW 1
36710: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36711: LD_ADDR_EXP 111
36715: PUSH
36716: LD_EXP 111
36720: PPUSH
36721: LD_VAR 0 2
36725: PPUSH
36726: EMPTY
36727: PPUSH
36728: CALL_OW 1
36732: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36733: LD_ADDR_EXP 115
36737: PUSH
36738: LD_EXP 115
36742: PPUSH
36743: LD_VAR 0 2
36747: PPUSH
36748: EMPTY
36749: PPUSH
36750: CALL_OW 1
36754: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36755: LD_ADDR_EXP 114
36759: PUSH
36760: LD_EXP 114
36764: PPUSH
36765: LD_VAR 0 2
36769: PPUSH
36770: EMPTY
36771: PPUSH
36772: CALL_OW 1
36776: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36777: LD_ADDR_EXP 116
36781: PUSH
36782: LD_EXP 116
36786: PPUSH
36787: LD_VAR 0 2
36791: PPUSH
36792: EMPTY
36793: PPUSH
36794: CALL_OW 1
36798: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36799: LD_ADDR_EXP 117
36803: PUSH
36804: LD_EXP 117
36808: PPUSH
36809: LD_VAR 0 2
36813: PPUSH
36814: EMPTY
36815: PPUSH
36816: CALL_OW 1
36820: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36821: LD_ADDR_EXP 118
36825: PUSH
36826: LD_EXP 118
36830: PPUSH
36831: LD_VAR 0 2
36835: PPUSH
36836: EMPTY
36837: PPUSH
36838: CALL_OW 1
36842: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36843: LD_ADDR_EXP 119
36847: PUSH
36848: LD_EXP 119
36852: PPUSH
36853: LD_VAR 0 2
36857: PPUSH
36858: EMPTY
36859: PPUSH
36860: CALL_OW 1
36864: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36865: LD_ADDR_EXP 120
36869: PUSH
36870: LD_EXP 120
36874: PPUSH
36875: LD_VAR 0 2
36879: PPUSH
36880: EMPTY
36881: PPUSH
36882: CALL_OW 1
36886: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36887: LD_ADDR_EXP 121
36891: PUSH
36892: LD_EXP 121
36896: PPUSH
36897: LD_VAR 0 2
36901: PPUSH
36902: EMPTY
36903: PPUSH
36904: CALL_OW 1
36908: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36909: LD_ADDR_EXP 122
36913: PUSH
36914: LD_EXP 122
36918: PPUSH
36919: LD_VAR 0 2
36923: PPUSH
36924: EMPTY
36925: PPUSH
36926: CALL_OW 1
36930: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36931: LD_ADDR_EXP 123
36935: PUSH
36936: LD_EXP 123
36940: PPUSH
36941: LD_VAR 0 2
36945: PPUSH
36946: EMPTY
36947: PPUSH
36948: CALL_OW 1
36952: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36953: LD_ADDR_EXP 112
36957: PUSH
36958: LD_EXP 112
36962: PPUSH
36963: LD_VAR 0 2
36967: PPUSH
36968: LD_INT 0
36970: PPUSH
36971: CALL_OW 1
36975: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36976: LD_ADDR_EXP 125
36980: PUSH
36981: LD_EXP 125
36985: PPUSH
36986: LD_VAR 0 2
36990: PPUSH
36991: LD_INT 0
36993: PPUSH
36994: CALL_OW 1
36998: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36999: LD_ADDR_EXP 113
37003: PUSH
37004: LD_EXP 113
37008: PPUSH
37009: LD_VAR 0 2
37013: PPUSH
37014: EMPTY
37015: PPUSH
37016: CALL_OW 1
37020: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37021: LD_ADDR_EXP 124
37025: PUSH
37026: LD_EXP 124
37030: PPUSH
37031: LD_VAR 0 2
37035: PPUSH
37036: LD_INT 0
37038: PPUSH
37039: CALL_OW 1
37043: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37044: LD_ADDR_EXP 126
37048: PUSH
37049: LD_EXP 126
37053: PPUSH
37054: LD_VAR 0 2
37058: PPUSH
37059: EMPTY
37060: PPUSH
37061: CALL_OW 1
37065: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37066: LD_ADDR_EXP 129
37070: PUSH
37071: LD_EXP 129
37075: PPUSH
37076: LD_VAR 0 2
37080: PPUSH
37081: LD_INT 0
37083: PPUSH
37084: CALL_OW 1
37088: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37089: LD_ADDR_EXP 130
37093: PUSH
37094: LD_EXP 130
37098: PPUSH
37099: LD_VAR 0 2
37103: PPUSH
37104: EMPTY
37105: PPUSH
37106: CALL_OW 1
37110: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37111: LD_ADDR_EXP 131
37115: PUSH
37116: LD_EXP 131
37120: PPUSH
37121: LD_VAR 0 2
37125: PPUSH
37126: EMPTY
37127: PPUSH
37128: CALL_OW 1
37132: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37133: LD_ADDR_EXP 132
37137: PUSH
37138: LD_EXP 132
37142: PPUSH
37143: LD_VAR 0 2
37147: PPUSH
37148: EMPTY
37149: PPUSH
37150: CALL_OW 1
37154: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37155: LD_ADDR_EXP 134
37159: PUSH
37160: LD_EXP 134
37164: PPUSH
37165: LD_VAR 0 2
37169: PPUSH
37170: LD_EXP 101
37174: PUSH
37175: LD_VAR 0 2
37179: ARRAY
37180: PPUSH
37181: LD_INT 2
37183: PUSH
37184: LD_INT 30
37186: PUSH
37187: LD_INT 6
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 30
37196: PUSH
37197: LD_INT 7
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 30
37206: PUSH
37207: LD_INT 8
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: LIST
37218: LIST
37219: PPUSH
37220: CALL_OW 72
37224: PPUSH
37225: CALL_OW 1
37229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37230: LD_ADDR_EXP 135
37234: PUSH
37235: LD_EXP 135
37239: PPUSH
37240: LD_VAR 0 2
37244: PPUSH
37245: EMPTY
37246: PPUSH
37247: CALL_OW 1
37251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37252: LD_ADDR_EXP 136
37256: PUSH
37257: LD_EXP 136
37261: PPUSH
37262: LD_VAR 0 2
37266: PPUSH
37267: EMPTY
37268: PPUSH
37269: CALL_OW 1
37273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37274: LD_ADDR_EXP 137
37278: PUSH
37279: LD_EXP 137
37283: PPUSH
37284: LD_VAR 0 2
37288: PPUSH
37289: EMPTY
37290: PPUSH
37291: CALL_OW 1
37295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37296: LD_ADDR_EXP 138
37300: PUSH
37301: LD_EXP 138
37305: PPUSH
37306: LD_VAR 0 2
37310: PPUSH
37311: EMPTY
37312: PPUSH
37313: CALL_OW 1
37317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37318: LD_ADDR_EXP 139
37322: PUSH
37323: LD_EXP 139
37327: PPUSH
37328: LD_VAR 0 2
37332: PPUSH
37333: EMPTY
37334: PPUSH
37335: CALL_OW 1
37339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37340: LD_ADDR_EXP 140
37344: PUSH
37345: LD_EXP 140
37349: PPUSH
37350: LD_VAR 0 2
37354: PPUSH
37355: EMPTY
37356: PPUSH
37357: CALL_OW 1
37361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37362: LD_ADDR_EXP 141
37366: PUSH
37367: LD_EXP 141
37371: PPUSH
37372: LD_VAR 0 2
37376: PPUSH
37377: EMPTY
37378: PPUSH
37379: CALL_OW 1
37383: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37384: LD_ADDR_EXP 142
37388: PUSH
37389: LD_EXP 142
37393: PPUSH
37394: LD_VAR 0 2
37398: PPUSH
37399: EMPTY
37400: PPUSH
37401: CALL_OW 1
37405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37406: LD_ADDR_EXP 143
37410: PUSH
37411: LD_EXP 143
37415: PPUSH
37416: LD_VAR 0 2
37420: PPUSH
37421: LD_INT 0
37423: PPUSH
37424: CALL_OW 1
37428: ST_TO_ADDR
// end ;
37429: GO 36353
37431: POP
37432: POP
// MC_InitSides ( ) ;
37433: CALL 37719 0 0
// MC_InitResearch ( ) ;
37437: CALL 37458 0 0
// CustomInitMacro ( ) ;
37441: CALL 460 0 0
// skirmish := true ;
37445: LD_ADDR_EXP 99
37449: PUSH
37450: LD_INT 1
37452: ST_TO_ADDR
// end ;
37453: LD_VAR 0 1
37457: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37458: LD_INT 0
37460: PPUSH
37461: PPUSH
37462: PPUSH
37463: PPUSH
37464: PPUSH
37465: PPUSH
// if not mc_bases then
37466: LD_EXP 101
37470: NOT
37471: IFFALSE 37475
// exit ;
37473: GO 37714
// for i = 1 to 8 do
37475: LD_ADDR_VAR 0 2
37479: PUSH
37480: DOUBLE
37481: LD_INT 1
37483: DEC
37484: ST_TO_ADDR
37485: LD_INT 8
37487: PUSH
37488: FOR_TO
37489: IFFALSE 37515
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37491: LD_ADDR_EXP 128
37495: PUSH
37496: LD_EXP 128
37500: PPUSH
37501: LD_VAR 0 2
37505: PPUSH
37506: EMPTY
37507: PPUSH
37508: CALL_OW 1
37512: ST_TO_ADDR
37513: GO 37488
37515: POP
37516: POP
// tmp := [ ] ;
37517: LD_ADDR_VAR 0 5
37521: PUSH
37522: EMPTY
37523: ST_TO_ADDR
// for i = 1 to mc_sides do
37524: LD_ADDR_VAR 0 2
37528: PUSH
37529: DOUBLE
37530: LD_INT 1
37532: DEC
37533: ST_TO_ADDR
37534: LD_EXP 127
37538: PUSH
37539: FOR_TO
37540: IFFALSE 37598
// if not mc_sides [ i ] in tmp then
37542: LD_EXP 127
37546: PUSH
37547: LD_VAR 0 2
37551: ARRAY
37552: PUSH
37553: LD_VAR 0 5
37557: IN
37558: NOT
37559: IFFALSE 37596
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37561: LD_ADDR_VAR 0 5
37565: PUSH
37566: LD_VAR 0 5
37570: PPUSH
37571: LD_VAR 0 5
37575: PUSH
37576: LD_INT 1
37578: PLUS
37579: PPUSH
37580: LD_EXP 127
37584: PUSH
37585: LD_VAR 0 2
37589: ARRAY
37590: PPUSH
37591: CALL_OW 2
37595: ST_TO_ADDR
37596: GO 37539
37598: POP
37599: POP
// if not tmp then
37600: LD_VAR 0 5
37604: NOT
37605: IFFALSE 37609
// exit ;
37607: GO 37714
// for j in tmp do
37609: LD_ADDR_VAR 0 3
37613: PUSH
37614: LD_VAR 0 5
37618: PUSH
37619: FOR_IN
37620: IFFALSE 37712
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37622: LD_ADDR_VAR 0 6
37626: PUSH
37627: LD_INT 22
37629: PUSH
37630: LD_VAR 0 3
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PPUSH
37639: CALL_OW 69
37643: ST_TO_ADDR
// if not un then
37644: LD_VAR 0 6
37648: NOT
37649: IFFALSE 37653
// continue ;
37651: GO 37619
// nation := GetNation ( un [ 1 ] ) ;
37653: LD_ADDR_VAR 0 4
37657: PUSH
37658: LD_VAR 0 6
37662: PUSH
37663: LD_INT 1
37665: ARRAY
37666: PPUSH
37667: CALL_OW 248
37671: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37672: LD_ADDR_EXP 128
37676: PUSH
37677: LD_EXP 128
37681: PPUSH
37682: LD_VAR 0 3
37686: PPUSH
37687: LD_VAR 0 3
37691: PPUSH
37692: LD_VAR 0 4
37696: PPUSH
37697: LD_INT 1
37699: PPUSH
37700: CALL 64428 0 3
37704: PPUSH
37705: CALL_OW 1
37709: ST_TO_ADDR
// end ;
37710: GO 37619
37712: POP
37713: POP
// end ;
37714: LD_VAR 0 1
37718: RET
// export function MC_InitSides ( ) ; var i ; begin
37719: LD_INT 0
37721: PPUSH
37722: PPUSH
// if not mc_bases then
37723: LD_EXP 101
37727: NOT
37728: IFFALSE 37732
// exit ;
37730: GO 37806
// for i = 1 to mc_bases do
37732: LD_ADDR_VAR 0 2
37736: PUSH
37737: DOUBLE
37738: LD_INT 1
37740: DEC
37741: ST_TO_ADDR
37742: LD_EXP 101
37746: PUSH
37747: FOR_TO
37748: IFFALSE 37804
// if mc_bases [ i ] then
37750: LD_EXP 101
37754: PUSH
37755: LD_VAR 0 2
37759: ARRAY
37760: IFFALSE 37802
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37762: LD_ADDR_EXP 127
37766: PUSH
37767: LD_EXP 127
37771: PPUSH
37772: LD_VAR 0 2
37776: PPUSH
37777: LD_EXP 101
37781: PUSH
37782: LD_VAR 0 2
37786: ARRAY
37787: PUSH
37788: LD_INT 1
37790: ARRAY
37791: PPUSH
37792: CALL_OW 255
37796: PPUSH
37797: CALL_OW 1
37801: ST_TO_ADDR
37802: GO 37747
37804: POP
37805: POP
// end ;
37806: LD_VAR 0 1
37810: RET
// every 0 0$01 trigger skirmish do
37811: LD_EXP 99
37815: IFFALSE 37969
37817: GO 37819
37819: DISABLE
// begin enable ;
37820: ENABLE
// MC_CheckBuildings ( ) ;
37821: CALL 42467 0 0
// MC_CheckPeopleLife ( ) ;
37825: CALL 42592 0 0
// RaiseSailEvent ( 100 ) ;
37829: LD_INT 100
37831: PPUSH
37832: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37836: LD_INT 103
37838: PPUSH
37839: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37843: LD_INT 104
37845: PPUSH
37846: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37850: LD_INT 105
37852: PPUSH
37853: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37857: LD_INT 106
37859: PPUSH
37860: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37864: LD_INT 107
37866: PPUSH
37867: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37871: LD_INT 108
37873: PPUSH
37874: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37878: LD_INT 109
37880: PPUSH
37881: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37885: LD_INT 110
37887: PPUSH
37888: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37892: LD_INT 111
37894: PPUSH
37895: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37899: LD_INT 112
37901: PPUSH
37902: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37906: LD_INT 113
37908: PPUSH
37909: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37913: LD_INT 120
37915: PPUSH
37916: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37920: LD_INT 121
37922: PPUSH
37923: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37927: LD_INT 122
37929: PPUSH
37930: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37934: LD_INT 123
37936: PPUSH
37937: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37941: LD_INT 124
37943: PPUSH
37944: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37948: LD_INT 125
37950: PPUSH
37951: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37955: LD_INT 126
37957: PPUSH
37958: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37962: LD_INT 200
37964: PPUSH
37965: CALL_OW 427
// end ;
37969: END
// on SailEvent ( event ) do begin if event < 100 then
37970: LD_VAR 0 1
37974: PUSH
37975: LD_INT 100
37977: LESS
37978: IFFALSE 37989
// CustomEvent ( event ) ;
37980: LD_VAR 0 1
37984: PPUSH
37985: CALL 32629 0 1
// if event = 100 then
37989: LD_VAR 0 1
37993: PUSH
37994: LD_INT 100
37996: EQUAL
37997: IFFALSE 38003
// MC_ClassManager ( ) ;
37999: CALL 38395 0 0
// if event = 101 then
38003: LD_VAR 0 1
38007: PUSH
38008: LD_INT 101
38010: EQUAL
38011: IFFALSE 38017
// MC_RepairBuildings ( ) ;
38013: CALL 43188 0 0
// if event = 102 then
38017: LD_VAR 0 1
38021: PUSH
38022: LD_INT 102
38024: EQUAL
38025: IFFALSE 38031
// MC_Heal ( ) ;
38027: CALL 43920 0 0
// if event = 103 then
38031: LD_VAR 0 1
38035: PUSH
38036: LD_INT 103
38038: EQUAL
38039: IFFALSE 38045
// MC_Build ( ) ;
38041: CALL 44342 0 0
// if event = 104 then
38045: LD_VAR 0 1
38049: PUSH
38050: LD_INT 104
38052: EQUAL
38053: IFFALSE 38059
// MC_TurretWeapon ( ) ;
38055: CALL 45955 0 0
// if event = 105 then
38059: LD_VAR 0 1
38063: PUSH
38064: LD_INT 105
38066: EQUAL
38067: IFFALSE 38073
// MC_BuildUpgrade ( ) ;
38069: CALL 45506 0 0
// if event = 106 then
38073: LD_VAR 0 1
38077: PUSH
38078: LD_INT 106
38080: EQUAL
38081: IFFALSE 38087
// MC_PlantMines ( ) ;
38083: CALL 46385 0 0
// if event = 107 then
38087: LD_VAR 0 1
38091: PUSH
38092: LD_INT 107
38094: EQUAL
38095: IFFALSE 38101
// MC_CollectCrates ( ) ;
38097: CALL 47419 0 0
// if event = 108 then
38101: LD_VAR 0 1
38105: PUSH
38106: LD_INT 108
38108: EQUAL
38109: IFFALSE 38115
// MC_LinkRemoteControl ( ) ;
38111: CALL 49195 0 0
// if event = 109 then
38115: LD_VAR 0 1
38119: PUSH
38120: LD_INT 109
38122: EQUAL
38123: IFFALSE 38129
// MC_ProduceVehicle ( ) ;
38125: CALL 49376 0 0
// if event = 110 then
38129: LD_VAR 0 1
38133: PUSH
38134: LD_INT 110
38136: EQUAL
38137: IFFALSE 38143
// MC_SendAttack ( ) ;
38139: CALL 49842 0 0
// if event = 111 then
38143: LD_VAR 0 1
38147: PUSH
38148: LD_INT 111
38150: EQUAL
38151: IFFALSE 38157
// MC_Defend ( ) ;
38153: CALL 49950 0 0
// if event = 112 then
38157: LD_VAR 0 1
38161: PUSH
38162: LD_INT 112
38164: EQUAL
38165: IFFALSE 38171
// MC_Research ( ) ;
38167: CALL 50555 0 0
// if event = 113 then
38171: LD_VAR 0 1
38175: PUSH
38176: LD_INT 113
38178: EQUAL
38179: IFFALSE 38185
// MC_MinesTrigger ( ) ;
38181: CALL 51669 0 0
// if event = 120 then
38185: LD_VAR 0 1
38189: PUSH
38190: LD_INT 120
38192: EQUAL
38193: IFFALSE 38199
// MC_RepairVehicle ( ) ;
38195: CALL 51768 0 0
// if event = 121 then
38199: LD_VAR 0 1
38203: PUSH
38204: LD_INT 121
38206: EQUAL
38207: IFFALSE 38213
// MC_TameApe ( ) ;
38209: CALL 52498 0 0
// if event = 122 then
38213: LD_VAR 0 1
38217: PUSH
38218: LD_INT 122
38220: EQUAL
38221: IFFALSE 38227
// MC_ChangeApeClass ( ) ;
38223: CALL 53327 0 0
// if event = 123 then
38227: LD_VAR 0 1
38231: PUSH
38232: LD_INT 123
38234: EQUAL
38235: IFFALSE 38241
// MC_Bazooka ( ) ;
38237: CALL 53977 0 0
// if event = 124 then
38241: LD_VAR 0 1
38245: PUSH
38246: LD_INT 124
38248: EQUAL
38249: IFFALSE 38255
// MC_TeleportExit ( ) ;
38251: CALL 54175 0 0
// if event = 125 then
38255: LD_VAR 0 1
38259: PUSH
38260: LD_INT 125
38262: EQUAL
38263: IFFALSE 38269
// MC_Deposits ( ) ;
38265: CALL 54822 0 0
// if event = 126 then
38269: LD_VAR 0 1
38273: PUSH
38274: LD_INT 126
38276: EQUAL
38277: IFFALSE 38283
// MC_RemoteDriver ( ) ;
38279: CALL 55447 0 0
// if event = 200 then
38283: LD_VAR 0 1
38287: PUSH
38288: LD_INT 200
38290: EQUAL
38291: IFFALSE 38297
// MC_Idle ( ) ;
38293: CALL 57396 0 0
// end ;
38297: PPOPN 1
38299: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38300: LD_INT 0
38302: PPUSH
38303: PPUSH
// if not mc_bases [ base ] or not tag then
38304: LD_EXP 101
38308: PUSH
38309: LD_VAR 0 1
38313: ARRAY
38314: NOT
38315: PUSH
38316: LD_VAR 0 2
38320: NOT
38321: OR
38322: IFFALSE 38326
// exit ;
38324: GO 38390
// for i in mc_bases [ base ] union mc_ape [ base ] do
38326: LD_ADDR_VAR 0 4
38330: PUSH
38331: LD_EXP 101
38335: PUSH
38336: LD_VAR 0 1
38340: ARRAY
38341: PUSH
38342: LD_EXP 130
38346: PUSH
38347: LD_VAR 0 1
38351: ARRAY
38352: UNION
38353: PUSH
38354: FOR_IN
38355: IFFALSE 38388
// if GetTag ( i ) = tag then
38357: LD_VAR 0 4
38361: PPUSH
38362: CALL_OW 110
38366: PUSH
38367: LD_VAR 0 2
38371: EQUAL
38372: IFFALSE 38386
// SetTag ( i , 0 ) ;
38374: LD_VAR 0 4
38378: PPUSH
38379: LD_INT 0
38381: PPUSH
38382: CALL_OW 109
38386: GO 38354
38388: POP
38389: POP
// end ;
38390: LD_VAR 0 3
38394: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38395: LD_INT 0
38397: PPUSH
38398: PPUSH
38399: PPUSH
38400: PPUSH
38401: PPUSH
38402: PPUSH
38403: PPUSH
38404: PPUSH
// if not mc_bases then
38405: LD_EXP 101
38409: NOT
38410: IFFALSE 38414
// exit ;
38412: GO 38872
// for i = 1 to mc_bases do
38414: LD_ADDR_VAR 0 2
38418: PUSH
38419: DOUBLE
38420: LD_INT 1
38422: DEC
38423: ST_TO_ADDR
38424: LD_EXP 101
38428: PUSH
38429: FOR_TO
38430: IFFALSE 38870
// begin tmp := MC_ClassCheckReq ( i ) ;
38432: LD_ADDR_VAR 0 4
38436: PUSH
38437: LD_VAR 0 2
38441: PPUSH
38442: CALL 38877 0 1
38446: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38447: LD_ADDR_EXP 142
38451: PUSH
38452: LD_EXP 142
38456: PPUSH
38457: LD_VAR 0 2
38461: PPUSH
38462: LD_VAR 0 4
38466: PPUSH
38467: CALL_OW 1
38471: ST_TO_ADDR
// if not tmp then
38472: LD_VAR 0 4
38476: NOT
38477: IFFALSE 38481
// continue ;
38479: GO 38429
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38481: LD_ADDR_VAR 0 6
38485: PUSH
38486: LD_EXP 101
38490: PUSH
38491: LD_VAR 0 2
38495: ARRAY
38496: PPUSH
38497: LD_INT 2
38499: PUSH
38500: LD_INT 30
38502: PUSH
38503: LD_INT 4
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 30
38512: PUSH
38513: LD_INT 5
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: LIST
38524: PPUSH
38525: CALL_OW 72
38529: PUSH
38530: LD_EXP 101
38534: PUSH
38535: LD_VAR 0 2
38539: ARRAY
38540: PPUSH
38541: LD_INT 2
38543: PUSH
38544: LD_INT 30
38546: PUSH
38547: LD_INT 0
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 30
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: LIST
38568: PPUSH
38569: CALL_OW 72
38573: PUSH
38574: LD_EXP 101
38578: PUSH
38579: LD_VAR 0 2
38583: ARRAY
38584: PPUSH
38585: LD_INT 30
38587: PUSH
38588: LD_INT 3
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PPUSH
38595: CALL_OW 72
38599: PUSH
38600: LD_EXP 101
38604: PUSH
38605: LD_VAR 0 2
38609: ARRAY
38610: PPUSH
38611: LD_INT 2
38613: PUSH
38614: LD_INT 30
38616: PUSH
38617: LD_INT 6
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 30
38626: PUSH
38627: LD_INT 7
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 30
38636: PUSH
38637: LD_INT 8
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: PPUSH
38650: CALL_OW 72
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: ST_TO_ADDR
// for j = 1 to 4 do
38661: LD_ADDR_VAR 0 3
38665: PUSH
38666: DOUBLE
38667: LD_INT 1
38669: DEC
38670: ST_TO_ADDR
38671: LD_INT 4
38673: PUSH
38674: FOR_TO
38675: IFFALSE 38866
// begin if not tmp [ j ] then
38677: LD_VAR 0 4
38681: PUSH
38682: LD_VAR 0 3
38686: ARRAY
38687: NOT
38688: IFFALSE 38692
// continue ;
38690: GO 38674
// for p in tmp [ j ] do
38692: LD_ADDR_VAR 0 5
38696: PUSH
38697: LD_VAR 0 4
38701: PUSH
38702: LD_VAR 0 3
38706: ARRAY
38707: PUSH
38708: FOR_IN
38709: IFFALSE 38862
// begin if not b [ j ] then
38711: LD_VAR 0 6
38715: PUSH
38716: LD_VAR 0 3
38720: ARRAY
38721: NOT
38722: IFFALSE 38726
// break ;
38724: GO 38862
// e := 0 ;
38726: LD_ADDR_VAR 0 7
38730: PUSH
38731: LD_INT 0
38733: ST_TO_ADDR
// for k in b [ j ] do
38734: LD_ADDR_VAR 0 8
38738: PUSH
38739: LD_VAR 0 6
38743: PUSH
38744: LD_VAR 0 3
38748: ARRAY
38749: PUSH
38750: FOR_IN
38751: IFFALSE 38778
// if IsNotFull ( k ) then
38753: LD_VAR 0 8
38757: PPUSH
38758: CALL 68868 0 1
38762: IFFALSE 38776
// begin e := k ;
38764: LD_ADDR_VAR 0 7
38768: PUSH
38769: LD_VAR 0 8
38773: ST_TO_ADDR
// break ;
38774: GO 38778
// end ;
38776: GO 38750
38778: POP
38779: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38780: LD_VAR 0 7
38784: PUSH
38785: LD_VAR 0 5
38789: PPUSH
38790: LD_VAR 0 7
38794: PPUSH
38795: CALL 105987 0 2
38799: NOT
38800: AND
38801: IFFALSE 38860
// begin if IsInUnit ( p ) then
38803: LD_VAR 0 5
38807: PPUSH
38808: CALL_OW 310
38812: IFFALSE 38823
// ComExitBuilding ( p ) ;
38814: LD_VAR 0 5
38818: PPUSH
38819: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38823: LD_VAR 0 5
38827: PPUSH
38828: LD_VAR 0 7
38832: PPUSH
38833: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38837: LD_VAR 0 5
38841: PPUSH
38842: LD_VAR 0 3
38846: PPUSH
38847: CALL_OW 183
// AddComExitBuilding ( p ) ;
38851: LD_VAR 0 5
38855: PPUSH
38856: CALL_OW 182
// end ; end ;
38860: GO 38708
38862: POP
38863: POP
// end ;
38864: GO 38674
38866: POP
38867: POP
// end ;
38868: GO 38429
38870: POP
38871: POP
// end ;
38872: LD_VAR 0 1
38876: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38877: LD_INT 0
38879: PPUSH
38880: PPUSH
38881: PPUSH
38882: PPUSH
38883: PPUSH
38884: PPUSH
38885: PPUSH
38886: PPUSH
38887: PPUSH
38888: PPUSH
38889: PPUSH
38890: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38891: LD_VAR 0 1
38895: NOT
38896: PUSH
38897: LD_EXP 101
38901: PUSH
38902: LD_VAR 0 1
38906: ARRAY
38907: NOT
38908: OR
38909: PUSH
38910: LD_EXP 101
38914: PUSH
38915: LD_VAR 0 1
38919: ARRAY
38920: PPUSH
38921: LD_INT 2
38923: PUSH
38924: LD_INT 30
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 30
38936: PUSH
38937: LD_INT 1
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: LIST
38948: PPUSH
38949: CALL_OW 72
38953: NOT
38954: OR
38955: IFFALSE 38959
// exit ;
38957: GO 42462
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38959: LD_ADDR_VAR 0 4
38963: PUSH
38964: LD_EXP 101
38968: PUSH
38969: LD_VAR 0 1
38973: ARRAY
38974: PPUSH
38975: LD_INT 2
38977: PUSH
38978: LD_INT 25
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 25
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 25
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 25
39010: PUSH
39011: LD_INT 4
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 25
39020: PUSH
39021: LD_INT 5
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 25
39030: PUSH
39031: LD_INT 8
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 25
39040: PUSH
39041: LD_INT 9
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: PPUSH
39058: CALL_OW 72
39062: ST_TO_ADDR
// if not tmp then
39063: LD_VAR 0 4
39067: NOT
39068: IFFALSE 39072
// exit ;
39070: GO 42462
// for i in tmp do
39072: LD_ADDR_VAR 0 3
39076: PUSH
39077: LD_VAR 0 4
39081: PUSH
39082: FOR_IN
39083: IFFALSE 39114
// if GetTag ( i ) then
39085: LD_VAR 0 3
39089: PPUSH
39090: CALL_OW 110
39094: IFFALSE 39112
// tmp := tmp diff i ;
39096: LD_ADDR_VAR 0 4
39100: PUSH
39101: LD_VAR 0 4
39105: PUSH
39106: LD_VAR 0 3
39110: DIFF
39111: ST_TO_ADDR
39112: GO 39082
39114: POP
39115: POP
// if not tmp then
39116: LD_VAR 0 4
39120: NOT
39121: IFFALSE 39125
// exit ;
39123: GO 42462
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39125: LD_ADDR_VAR 0 5
39129: PUSH
39130: LD_EXP 101
39134: PUSH
39135: LD_VAR 0 1
39139: ARRAY
39140: PPUSH
39141: LD_INT 2
39143: PUSH
39144: LD_INT 25
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 25
39156: PUSH
39157: LD_INT 5
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 25
39166: PUSH
39167: LD_INT 8
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 25
39176: PUSH
39177: LD_INT 9
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: PPUSH
39191: CALL_OW 72
39195: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39196: LD_ADDR_VAR 0 6
39200: PUSH
39201: LD_EXP 101
39205: PUSH
39206: LD_VAR 0 1
39210: ARRAY
39211: PPUSH
39212: LD_INT 25
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PPUSH
39222: CALL_OW 72
39226: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39227: LD_ADDR_VAR 0 7
39231: PUSH
39232: LD_EXP 101
39236: PUSH
39237: LD_VAR 0 1
39241: ARRAY
39242: PPUSH
39243: LD_INT 25
39245: PUSH
39246: LD_INT 3
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PPUSH
39253: CALL_OW 72
39257: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39258: LD_ADDR_VAR 0 8
39262: PUSH
39263: LD_EXP 101
39267: PUSH
39268: LD_VAR 0 1
39272: ARRAY
39273: PPUSH
39274: LD_INT 25
39276: PUSH
39277: LD_INT 4
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 24
39286: PUSH
39287: LD_INT 251
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PPUSH
39298: CALL_OW 72
39302: ST_TO_ADDR
// if mc_scan [ base ] then
39303: LD_EXP 124
39307: PUSH
39308: LD_VAR 0 1
39312: ARRAY
39313: IFFALSE 39774
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39315: LD_ADDR_EXP 143
39319: PUSH
39320: LD_EXP 143
39324: PPUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: LD_INT 4
39332: PPUSH
39333: CALL_OW 1
39337: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39338: LD_ADDR_VAR 0 12
39342: PUSH
39343: LD_EXP 101
39347: PUSH
39348: LD_VAR 0 1
39352: ARRAY
39353: PPUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 30
39359: PUSH
39360: LD_INT 4
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 30
39369: PUSH
39370: LD_INT 5
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: LIST
39381: PPUSH
39382: CALL_OW 72
39386: ST_TO_ADDR
// if not b then
39387: LD_VAR 0 12
39391: NOT
39392: IFFALSE 39396
// exit ;
39394: GO 42462
// p := [ ] ;
39396: LD_ADDR_VAR 0 11
39400: PUSH
39401: EMPTY
39402: ST_TO_ADDR
// if sci >= 2 then
39403: LD_VAR 0 8
39407: PUSH
39408: LD_INT 2
39410: GREATEREQUAL
39411: IFFALSE 39442
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39413: LD_ADDR_VAR 0 8
39417: PUSH
39418: LD_VAR 0 8
39422: PUSH
39423: LD_INT 1
39425: ARRAY
39426: PUSH
39427: LD_VAR 0 8
39431: PUSH
39432: LD_INT 2
39434: ARRAY
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: ST_TO_ADDR
39440: GO 39503
// if sci = 1 then
39442: LD_VAR 0 8
39446: PUSH
39447: LD_INT 1
39449: EQUAL
39450: IFFALSE 39471
// sci := [ sci [ 1 ] ] else
39452: LD_ADDR_VAR 0 8
39456: PUSH
39457: LD_VAR 0 8
39461: PUSH
39462: LD_INT 1
39464: ARRAY
39465: PUSH
39466: EMPTY
39467: LIST
39468: ST_TO_ADDR
39469: GO 39503
// if sci = 0 then
39471: LD_VAR 0 8
39475: PUSH
39476: LD_INT 0
39478: EQUAL
39479: IFFALSE 39503
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39481: LD_ADDR_VAR 0 11
39485: PUSH
39486: LD_VAR 0 4
39490: PPUSH
39491: LD_INT 4
39493: PPUSH
39494: CALL 105850 0 2
39498: PUSH
39499: LD_INT 1
39501: ARRAY
39502: ST_TO_ADDR
// if eng > 4 then
39503: LD_VAR 0 6
39507: PUSH
39508: LD_INT 4
39510: GREATER
39511: IFFALSE 39557
// for i = eng downto 4 do
39513: LD_ADDR_VAR 0 3
39517: PUSH
39518: DOUBLE
39519: LD_VAR 0 6
39523: INC
39524: ST_TO_ADDR
39525: LD_INT 4
39527: PUSH
39528: FOR_DOWNTO
39529: IFFALSE 39555
// eng := eng diff eng [ i ] ;
39531: LD_ADDR_VAR 0 6
39535: PUSH
39536: LD_VAR 0 6
39540: PUSH
39541: LD_VAR 0 6
39545: PUSH
39546: LD_VAR 0 3
39550: ARRAY
39551: DIFF
39552: ST_TO_ADDR
39553: GO 39528
39555: POP
39556: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39557: LD_ADDR_VAR 0 4
39561: PUSH
39562: LD_VAR 0 4
39566: PUSH
39567: LD_VAR 0 5
39571: PUSH
39572: LD_VAR 0 6
39576: UNION
39577: PUSH
39578: LD_VAR 0 7
39582: UNION
39583: PUSH
39584: LD_VAR 0 8
39588: UNION
39589: DIFF
39590: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39591: LD_ADDR_VAR 0 13
39595: PUSH
39596: LD_EXP 101
39600: PUSH
39601: LD_VAR 0 1
39605: ARRAY
39606: PPUSH
39607: LD_INT 2
39609: PUSH
39610: LD_INT 30
39612: PUSH
39613: LD_INT 32
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 30
39622: PUSH
39623: LD_INT 31
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: LIST
39634: PPUSH
39635: CALL_OW 72
39639: PUSH
39640: LD_EXP 101
39644: PUSH
39645: LD_VAR 0 1
39649: ARRAY
39650: PPUSH
39651: LD_INT 2
39653: PUSH
39654: LD_INT 30
39656: PUSH
39657: LD_INT 4
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 30
39666: PUSH
39667: LD_INT 5
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: LIST
39678: PPUSH
39679: CALL_OW 72
39683: PUSH
39684: LD_INT 6
39686: MUL
39687: PLUS
39688: ST_TO_ADDR
// if bcount < tmp then
39689: LD_VAR 0 13
39693: PUSH
39694: LD_VAR 0 4
39698: LESS
39699: IFFALSE 39745
// for i = tmp downto bcount do
39701: LD_ADDR_VAR 0 3
39705: PUSH
39706: DOUBLE
39707: LD_VAR 0 4
39711: INC
39712: ST_TO_ADDR
39713: LD_VAR 0 13
39717: PUSH
39718: FOR_DOWNTO
39719: IFFALSE 39743
// tmp := Delete ( tmp , tmp ) ;
39721: LD_ADDR_VAR 0 4
39725: PUSH
39726: LD_VAR 0 4
39730: PPUSH
39731: LD_VAR 0 4
39735: PPUSH
39736: CALL_OW 3
39740: ST_TO_ADDR
39741: GO 39718
39743: POP
39744: POP
// result := [ tmp , 0 , 0 , p ] ;
39745: LD_ADDR_VAR 0 2
39749: PUSH
39750: LD_VAR 0 4
39754: PUSH
39755: LD_INT 0
39757: PUSH
39758: LD_INT 0
39760: PUSH
39761: LD_VAR 0 11
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: ST_TO_ADDR
// exit ;
39772: GO 42462
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39774: LD_EXP 101
39778: PUSH
39779: LD_VAR 0 1
39783: ARRAY
39784: PPUSH
39785: LD_INT 2
39787: PUSH
39788: LD_INT 30
39790: PUSH
39791: LD_INT 6
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 30
39800: PUSH
39801: LD_INT 7
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 30
39810: PUSH
39811: LD_INT 8
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: NOT
39829: PUSH
39830: LD_EXP 101
39834: PUSH
39835: LD_VAR 0 1
39839: ARRAY
39840: PPUSH
39841: LD_INT 30
39843: PUSH
39844: LD_INT 3
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: PPUSH
39851: CALL_OW 72
39855: NOT
39856: AND
39857: IFFALSE 39929
// begin if eng = tmp then
39859: LD_VAR 0 6
39863: PUSH
39864: LD_VAR 0 4
39868: EQUAL
39869: IFFALSE 39873
// exit ;
39871: GO 42462
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39873: LD_ADDR_EXP 143
39877: PUSH
39878: LD_EXP 143
39882: PPUSH
39883: LD_VAR 0 1
39887: PPUSH
39888: LD_INT 1
39890: PPUSH
39891: CALL_OW 1
39895: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39896: LD_ADDR_VAR 0 2
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: LD_VAR 0 4
39908: PUSH
39909: LD_VAR 0 6
39913: DIFF
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: LD_INT 0
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: ST_TO_ADDR
// exit ;
39927: GO 42462
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39929: LD_EXP 128
39933: PUSH
39934: LD_EXP 127
39938: PUSH
39939: LD_VAR 0 1
39943: ARRAY
39944: ARRAY
39945: PUSH
39946: LD_EXP 101
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: PPUSH
39957: LD_INT 2
39959: PUSH
39960: LD_INT 30
39962: PUSH
39963: LD_INT 6
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 30
39972: PUSH
39973: LD_INT 7
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 30
39982: PUSH
39983: LD_INT 8
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: PPUSH
39996: CALL_OW 72
40000: AND
40001: PUSH
40002: LD_EXP 101
40006: PUSH
40007: LD_VAR 0 1
40011: ARRAY
40012: PPUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PPUSH
40023: CALL_OW 72
40027: NOT
40028: AND
40029: IFFALSE 40243
// begin if sci >= 6 then
40031: LD_VAR 0 8
40035: PUSH
40036: LD_INT 6
40038: GREATEREQUAL
40039: IFFALSE 40043
// exit ;
40041: GO 42462
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40043: LD_ADDR_EXP 143
40047: PUSH
40048: LD_EXP 143
40052: PPUSH
40053: LD_VAR 0 1
40057: PPUSH
40058: LD_INT 2
40060: PPUSH
40061: CALL_OW 1
40065: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40066: LD_ADDR_VAR 0 9
40070: PUSH
40071: LD_VAR 0 4
40075: PUSH
40076: LD_VAR 0 8
40080: DIFF
40081: PPUSH
40082: LD_INT 4
40084: PPUSH
40085: CALL 105850 0 2
40089: ST_TO_ADDR
// p := [ ] ;
40090: LD_ADDR_VAR 0 11
40094: PUSH
40095: EMPTY
40096: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40097: LD_VAR 0 8
40101: PUSH
40102: LD_INT 6
40104: LESS
40105: PUSH
40106: LD_VAR 0 9
40110: PUSH
40111: LD_INT 6
40113: GREATER
40114: AND
40115: IFFALSE 40196
// begin for i = 1 to 6 - sci do
40117: LD_ADDR_VAR 0 3
40121: PUSH
40122: DOUBLE
40123: LD_INT 1
40125: DEC
40126: ST_TO_ADDR
40127: LD_INT 6
40129: PUSH
40130: LD_VAR 0 8
40134: MINUS
40135: PUSH
40136: FOR_TO
40137: IFFALSE 40192
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40139: LD_ADDR_VAR 0 11
40143: PUSH
40144: LD_VAR 0 11
40148: PPUSH
40149: LD_VAR 0 11
40153: PUSH
40154: LD_INT 1
40156: PLUS
40157: PPUSH
40158: LD_VAR 0 9
40162: PUSH
40163: LD_INT 1
40165: ARRAY
40166: PPUSH
40167: CALL_OW 2
40171: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40172: LD_ADDR_VAR 0 9
40176: PUSH
40177: LD_VAR 0 9
40181: PPUSH
40182: LD_INT 1
40184: PPUSH
40185: CALL_OW 3
40189: ST_TO_ADDR
// end ;
40190: GO 40136
40192: POP
40193: POP
// end else
40194: GO 40216
// if sort then
40196: LD_VAR 0 9
40200: IFFALSE 40216
// p := sort [ 1 ] ;
40202: LD_ADDR_VAR 0 11
40206: PUSH
40207: LD_VAR 0 9
40211: PUSH
40212: LD_INT 1
40214: ARRAY
40215: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40216: LD_ADDR_VAR 0 2
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_VAR 0 11
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: ST_TO_ADDR
// exit ;
40241: GO 42462
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40243: LD_EXP 128
40247: PUSH
40248: LD_EXP 127
40252: PUSH
40253: LD_VAR 0 1
40257: ARRAY
40258: ARRAY
40259: PUSH
40260: LD_EXP 101
40264: PUSH
40265: LD_VAR 0 1
40269: ARRAY
40270: PPUSH
40271: LD_INT 2
40273: PUSH
40274: LD_INT 30
40276: PUSH
40277: LD_INT 6
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 30
40286: PUSH
40287: LD_INT 7
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 30
40296: PUSH
40297: LD_INT 8
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: PPUSH
40310: CALL_OW 72
40314: AND
40315: PUSH
40316: LD_EXP 101
40320: PUSH
40321: LD_VAR 0 1
40325: ARRAY
40326: PPUSH
40327: LD_INT 30
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PPUSH
40337: CALL_OW 72
40341: AND
40342: IFFALSE 41076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40344: LD_ADDR_EXP 143
40348: PUSH
40349: LD_EXP 143
40353: PPUSH
40354: LD_VAR 0 1
40358: PPUSH
40359: LD_INT 3
40361: PPUSH
40362: CALL_OW 1
40366: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40367: LD_ADDR_VAR 0 2
40371: PUSH
40372: LD_INT 0
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: LD_INT 0
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: ST_TO_ADDR
// if not eng then
40390: LD_VAR 0 6
40394: NOT
40395: IFFALSE 40458
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40397: LD_ADDR_VAR 0 11
40401: PUSH
40402: LD_VAR 0 4
40406: PPUSH
40407: LD_INT 2
40409: PPUSH
40410: CALL 105850 0 2
40414: PUSH
40415: LD_INT 1
40417: ARRAY
40418: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40419: LD_ADDR_VAR 0 2
40423: PUSH
40424: LD_VAR 0 2
40428: PPUSH
40429: LD_INT 2
40431: PPUSH
40432: LD_VAR 0 11
40436: PPUSH
40437: CALL_OW 1
40441: ST_TO_ADDR
// tmp := tmp diff p ;
40442: LD_ADDR_VAR 0 4
40446: PUSH
40447: LD_VAR 0 4
40451: PUSH
40452: LD_VAR 0 11
40456: DIFF
40457: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40458: LD_VAR 0 4
40462: PUSH
40463: LD_VAR 0 8
40467: PUSH
40468: LD_INT 6
40470: LESS
40471: AND
40472: IFFALSE 40660
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40474: LD_ADDR_VAR 0 9
40478: PUSH
40479: LD_VAR 0 4
40483: PUSH
40484: LD_VAR 0 8
40488: PUSH
40489: LD_VAR 0 7
40493: UNION
40494: DIFF
40495: PPUSH
40496: LD_INT 4
40498: PPUSH
40499: CALL 105850 0 2
40503: ST_TO_ADDR
// p := [ ] ;
40504: LD_ADDR_VAR 0 11
40508: PUSH
40509: EMPTY
40510: ST_TO_ADDR
// if sort then
40511: LD_VAR 0 9
40515: IFFALSE 40631
// for i = 1 to 6 - sci do
40517: LD_ADDR_VAR 0 3
40521: PUSH
40522: DOUBLE
40523: LD_INT 1
40525: DEC
40526: ST_TO_ADDR
40527: LD_INT 6
40529: PUSH
40530: LD_VAR 0 8
40534: MINUS
40535: PUSH
40536: FOR_TO
40537: IFFALSE 40629
// begin if i = sort then
40539: LD_VAR 0 3
40543: PUSH
40544: LD_VAR 0 9
40548: EQUAL
40549: IFFALSE 40553
// break ;
40551: GO 40629
// if GetClass ( i ) = 4 then
40553: LD_VAR 0 3
40557: PPUSH
40558: CALL_OW 257
40562: PUSH
40563: LD_INT 4
40565: EQUAL
40566: IFFALSE 40570
// continue ;
40568: GO 40536
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40570: LD_ADDR_VAR 0 11
40574: PUSH
40575: LD_VAR 0 11
40579: PPUSH
40580: LD_VAR 0 11
40584: PUSH
40585: LD_INT 1
40587: PLUS
40588: PPUSH
40589: LD_VAR 0 9
40593: PUSH
40594: LD_VAR 0 3
40598: ARRAY
40599: PPUSH
40600: CALL_OW 2
40604: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40605: LD_ADDR_VAR 0 4
40609: PUSH
40610: LD_VAR 0 4
40614: PUSH
40615: LD_VAR 0 9
40619: PUSH
40620: LD_VAR 0 3
40624: ARRAY
40625: DIFF
40626: ST_TO_ADDR
// end ;
40627: GO 40536
40629: POP
40630: POP
// if p then
40631: LD_VAR 0 11
40635: IFFALSE 40660
// result := Replace ( result , 4 , p ) ;
40637: LD_ADDR_VAR 0 2
40641: PUSH
40642: LD_VAR 0 2
40646: PPUSH
40647: LD_INT 4
40649: PPUSH
40650: LD_VAR 0 11
40654: PPUSH
40655: CALL_OW 1
40659: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40660: LD_VAR 0 4
40664: PUSH
40665: LD_VAR 0 7
40669: PUSH
40670: LD_INT 6
40672: LESS
40673: AND
40674: IFFALSE 40862
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40676: LD_ADDR_VAR 0 9
40680: PUSH
40681: LD_VAR 0 4
40685: PUSH
40686: LD_VAR 0 8
40690: PUSH
40691: LD_VAR 0 7
40695: UNION
40696: DIFF
40697: PPUSH
40698: LD_INT 3
40700: PPUSH
40701: CALL 105850 0 2
40705: ST_TO_ADDR
// p := [ ] ;
40706: LD_ADDR_VAR 0 11
40710: PUSH
40711: EMPTY
40712: ST_TO_ADDR
// if sort then
40713: LD_VAR 0 9
40717: IFFALSE 40833
// for i = 1 to 6 - mech do
40719: LD_ADDR_VAR 0 3
40723: PUSH
40724: DOUBLE
40725: LD_INT 1
40727: DEC
40728: ST_TO_ADDR
40729: LD_INT 6
40731: PUSH
40732: LD_VAR 0 7
40736: MINUS
40737: PUSH
40738: FOR_TO
40739: IFFALSE 40831
// begin if i = sort then
40741: LD_VAR 0 3
40745: PUSH
40746: LD_VAR 0 9
40750: EQUAL
40751: IFFALSE 40755
// break ;
40753: GO 40831
// if GetClass ( i ) = 3 then
40755: LD_VAR 0 3
40759: PPUSH
40760: CALL_OW 257
40764: PUSH
40765: LD_INT 3
40767: EQUAL
40768: IFFALSE 40772
// continue ;
40770: GO 40738
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40772: LD_ADDR_VAR 0 11
40776: PUSH
40777: LD_VAR 0 11
40781: PPUSH
40782: LD_VAR 0 11
40786: PUSH
40787: LD_INT 1
40789: PLUS
40790: PPUSH
40791: LD_VAR 0 9
40795: PUSH
40796: LD_VAR 0 3
40800: ARRAY
40801: PPUSH
40802: CALL_OW 2
40806: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40807: LD_ADDR_VAR 0 4
40811: PUSH
40812: LD_VAR 0 4
40816: PUSH
40817: LD_VAR 0 9
40821: PUSH
40822: LD_VAR 0 3
40826: ARRAY
40827: DIFF
40828: ST_TO_ADDR
// end ;
40829: GO 40738
40831: POP
40832: POP
// if p then
40833: LD_VAR 0 11
40837: IFFALSE 40862
// result := Replace ( result , 3 , p ) ;
40839: LD_ADDR_VAR 0 2
40843: PUSH
40844: LD_VAR 0 2
40848: PPUSH
40849: LD_INT 3
40851: PPUSH
40852: LD_VAR 0 11
40856: PPUSH
40857: CALL_OW 1
40861: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40862: LD_VAR 0 4
40866: PUSH
40867: LD_INT 6
40869: GREATER
40870: PUSH
40871: LD_VAR 0 6
40875: PUSH
40876: LD_INT 6
40878: LESS
40879: AND
40880: IFFALSE 41074
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40882: LD_ADDR_VAR 0 9
40886: PUSH
40887: LD_VAR 0 4
40891: PUSH
40892: LD_VAR 0 8
40896: PUSH
40897: LD_VAR 0 7
40901: UNION
40902: PUSH
40903: LD_VAR 0 6
40907: UNION
40908: DIFF
40909: PPUSH
40910: LD_INT 2
40912: PPUSH
40913: CALL 105850 0 2
40917: ST_TO_ADDR
// p := [ ] ;
40918: LD_ADDR_VAR 0 11
40922: PUSH
40923: EMPTY
40924: ST_TO_ADDR
// if sort then
40925: LD_VAR 0 9
40929: IFFALSE 41045
// for i = 1 to 6 - eng do
40931: LD_ADDR_VAR 0 3
40935: PUSH
40936: DOUBLE
40937: LD_INT 1
40939: DEC
40940: ST_TO_ADDR
40941: LD_INT 6
40943: PUSH
40944: LD_VAR 0 6
40948: MINUS
40949: PUSH
40950: FOR_TO
40951: IFFALSE 41043
// begin if i = sort then
40953: LD_VAR 0 3
40957: PUSH
40958: LD_VAR 0 9
40962: EQUAL
40963: IFFALSE 40967
// break ;
40965: GO 41043
// if GetClass ( i ) = 2 then
40967: LD_VAR 0 3
40971: PPUSH
40972: CALL_OW 257
40976: PUSH
40977: LD_INT 2
40979: EQUAL
40980: IFFALSE 40984
// continue ;
40982: GO 40950
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40984: LD_ADDR_VAR 0 11
40988: PUSH
40989: LD_VAR 0 11
40993: PPUSH
40994: LD_VAR 0 11
40998: PUSH
40999: LD_INT 1
41001: PLUS
41002: PPUSH
41003: LD_VAR 0 9
41007: PUSH
41008: LD_VAR 0 3
41012: ARRAY
41013: PPUSH
41014: CALL_OW 2
41018: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41019: LD_ADDR_VAR 0 4
41023: PUSH
41024: LD_VAR 0 4
41028: PUSH
41029: LD_VAR 0 9
41033: PUSH
41034: LD_VAR 0 3
41038: ARRAY
41039: DIFF
41040: ST_TO_ADDR
// end ;
41041: GO 40950
41043: POP
41044: POP
// if p then
41045: LD_VAR 0 11
41049: IFFALSE 41074
// result := Replace ( result , 2 , p ) ;
41051: LD_ADDR_VAR 0 2
41055: PUSH
41056: LD_VAR 0 2
41060: PPUSH
41061: LD_INT 2
41063: PPUSH
41064: LD_VAR 0 11
41068: PPUSH
41069: CALL_OW 1
41073: ST_TO_ADDR
// end ; exit ;
41074: GO 42462
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41076: LD_EXP 128
41080: PUSH
41081: LD_EXP 127
41085: PUSH
41086: LD_VAR 0 1
41090: ARRAY
41091: ARRAY
41092: NOT
41093: PUSH
41094: LD_EXP 101
41098: PUSH
41099: LD_VAR 0 1
41103: ARRAY
41104: PPUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 3
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PPUSH
41115: CALL_OW 72
41119: AND
41120: PUSH
41121: LD_EXP 106
41125: PUSH
41126: LD_VAR 0 1
41130: ARRAY
41131: AND
41132: IFFALSE 41740
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41134: LD_ADDR_EXP 143
41138: PUSH
41139: LD_EXP 143
41143: PPUSH
41144: LD_VAR 0 1
41148: PPUSH
41149: LD_INT 5
41151: PPUSH
41152: CALL_OW 1
41156: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41157: LD_ADDR_VAR 0 2
41161: PUSH
41162: LD_INT 0
41164: PUSH
41165: LD_INT 0
41167: PUSH
41168: LD_INT 0
41170: PUSH
41171: LD_INT 0
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: LIST
41178: LIST
41179: ST_TO_ADDR
// if sci > 1 then
41180: LD_VAR 0 8
41184: PUSH
41185: LD_INT 1
41187: GREATER
41188: IFFALSE 41216
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41190: LD_ADDR_VAR 0 4
41194: PUSH
41195: LD_VAR 0 4
41199: PUSH
41200: LD_VAR 0 8
41204: PUSH
41205: LD_VAR 0 8
41209: PUSH
41210: LD_INT 1
41212: ARRAY
41213: DIFF
41214: DIFF
41215: ST_TO_ADDR
// if tmp and not sci then
41216: LD_VAR 0 4
41220: PUSH
41221: LD_VAR 0 8
41225: NOT
41226: AND
41227: IFFALSE 41296
// begin sort := SortBySkill ( tmp , 4 ) ;
41229: LD_ADDR_VAR 0 9
41233: PUSH
41234: LD_VAR 0 4
41238: PPUSH
41239: LD_INT 4
41241: PPUSH
41242: CALL 105850 0 2
41246: ST_TO_ADDR
// if sort then
41247: LD_VAR 0 9
41251: IFFALSE 41267
// p := sort [ 1 ] ;
41253: LD_ADDR_VAR 0 11
41257: PUSH
41258: LD_VAR 0 9
41262: PUSH
41263: LD_INT 1
41265: ARRAY
41266: ST_TO_ADDR
// if p then
41267: LD_VAR 0 11
41271: IFFALSE 41296
// result := Replace ( result , 4 , p ) ;
41273: LD_ADDR_VAR 0 2
41277: PUSH
41278: LD_VAR 0 2
41282: PPUSH
41283: LD_INT 4
41285: PPUSH
41286: LD_VAR 0 11
41290: PPUSH
41291: CALL_OW 1
41295: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41296: LD_ADDR_VAR 0 4
41300: PUSH
41301: LD_VAR 0 4
41305: PUSH
41306: LD_VAR 0 7
41310: DIFF
41311: ST_TO_ADDR
// if tmp and mech < 6 then
41312: LD_VAR 0 4
41316: PUSH
41317: LD_VAR 0 7
41321: PUSH
41322: LD_INT 6
41324: LESS
41325: AND
41326: IFFALSE 41514
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41328: LD_ADDR_VAR 0 9
41332: PUSH
41333: LD_VAR 0 4
41337: PUSH
41338: LD_VAR 0 8
41342: PUSH
41343: LD_VAR 0 7
41347: UNION
41348: DIFF
41349: PPUSH
41350: LD_INT 3
41352: PPUSH
41353: CALL 105850 0 2
41357: ST_TO_ADDR
// p := [ ] ;
41358: LD_ADDR_VAR 0 11
41362: PUSH
41363: EMPTY
41364: ST_TO_ADDR
// if sort then
41365: LD_VAR 0 9
41369: IFFALSE 41485
// for i = 1 to 6 - mech do
41371: LD_ADDR_VAR 0 3
41375: PUSH
41376: DOUBLE
41377: LD_INT 1
41379: DEC
41380: ST_TO_ADDR
41381: LD_INT 6
41383: PUSH
41384: LD_VAR 0 7
41388: MINUS
41389: PUSH
41390: FOR_TO
41391: IFFALSE 41483
// begin if i = sort then
41393: LD_VAR 0 3
41397: PUSH
41398: LD_VAR 0 9
41402: EQUAL
41403: IFFALSE 41407
// break ;
41405: GO 41483
// if GetClass ( i ) = 3 then
41407: LD_VAR 0 3
41411: PPUSH
41412: CALL_OW 257
41416: PUSH
41417: LD_INT 3
41419: EQUAL
41420: IFFALSE 41424
// continue ;
41422: GO 41390
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41424: LD_ADDR_VAR 0 11
41428: PUSH
41429: LD_VAR 0 11
41433: PPUSH
41434: LD_VAR 0 11
41438: PUSH
41439: LD_INT 1
41441: PLUS
41442: PPUSH
41443: LD_VAR 0 9
41447: PUSH
41448: LD_VAR 0 3
41452: ARRAY
41453: PPUSH
41454: CALL_OW 2
41458: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41459: LD_ADDR_VAR 0 4
41463: PUSH
41464: LD_VAR 0 4
41468: PUSH
41469: LD_VAR 0 9
41473: PUSH
41474: LD_VAR 0 3
41478: ARRAY
41479: DIFF
41480: ST_TO_ADDR
// end ;
41481: GO 41390
41483: POP
41484: POP
// if p then
41485: LD_VAR 0 11
41489: IFFALSE 41514
// result := Replace ( result , 3 , p ) ;
41491: LD_ADDR_VAR 0 2
41495: PUSH
41496: LD_VAR 0 2
41500: PPUSH
41501: LD_INT 3
41503: PPUSH
41504: LD_VAR 0 11
41508: PPUSH
41509: CALL_OW 1
41513: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41514: LD_ADDR_VAR 0 4
41518: PUSH
41519: LD_VAR 0 4
41523: PUSH
41524: LD_VAR 0 6
41528: DIFF
41529: ST_TO_ADDR
// if tmp and eng < 6 then
41530: LD_VAR 0 4
41534: PUSH
41535: LD_VAR 0 6
41539: PUSH
41540: LD_INT 6
41542: LESS
41543: AND
41544: IFFALSE 41738
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41546: LD_ADDR_VAR 0 9
41550: PUSH
41551: LD_VAR 0 4
41555: PUSH
41556: LD_VAR 0 8
41560: PUSH
41561: LD_VAR 0 7
41565: UNION
41566: PUSH
41567: LD_VAR 0 6
41571: UNION
41572: DIFF
41573: PPUSH
41574: LD_INT 2
41576: PPUSH
41577: CALL 105850 0 2
41581: ST_TO_ADDR
// p := [ ] ;
41582: LD_ADDR_VAR 0 11
41586: PUSH
41587: EMPTY
41588: ST_TO_ADDR
// if sort then
41589: LD_VAR 0 9
41593: IFFALSE 41709
// for i = 1 to 6 - eng do
41595: LD_ADDR_VAR 0 3
41599: PUSH
41600: DOUBLE
41601: LD_INT 1
41603: DEC
41604: ST_TO_ADDR
41605: LD_INT 6
41607: PUSH
41608: LD_VAR 0 6
41612: MINUS
41613: PUSH
41614: FOR_TO
41615: IFFALSE 41707
// begin if i = sort then
41617: LD_VAR 0 3
41621: PUSH
41622: LD_VAR 0 9
41626: EQUAL
41627: IFFALSE 41631
// break ;
41629: GO 41707
// if GetClass ( i ) = 2 then
41631: LD_VAR 0 3
41635: PPUSH
41636: CALL_OW 257
41640: PUSH
41641: LD_INT 2
41643: EQUAL
41644: IFFALSE 41648
// continue ;
41646: GO 41614
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41648: LD_ADDR_VAR 0 11
41652: PUSH
41653: LD_VAR 0 11
41657: PPUSH
41658: LD_VAR 0 11
41662: PUSH
41663: LD_INT 1
41665: PLUS
41666: PPUSH
41667: LD_VAR 0 9
41671: PUSH
41672: LD_VAR 0 3
41676: ARRAY
41677: PPUSH
41678: CALL_OW 2
41682: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41683: LD_ADDR_VAR 0 4
41687: PUSH
41688: LD_VAR 0 4
41692: PUSH
41693: LD_VAR 0 9
41697: PUSH
41698: LD_VAR 0 3
41702: ARRAY
41703: DIFF
41704: ST_TO_ADDR
// end ;
41705: GO 41614
41707: POP
41708: POP
// if p then
41709: LD_VAR 0 11
41713: IFFALSE 41738
// result := Replace ( result , 2 , p ) ;
41715: LD_ADDR_VAR 0 2
41719: PUSH
41720: LD_VAR 0 2
41724: PPUSH
41725: LD_INT 2
41727: PPUSH
41728: LD_VAR 0 11
41732: PPUSH
41733: CALL_OW 1
41737: ST_TO_ADDR
// end ; exit ;
41738: GO 42462
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41740: LD_EXP 128
41744: PUSH
41745: LD_EXP 127
41749: PUSH
41750: LD_VAR 0 1
41754: ARRAY
41755: ARRAY
41756: NOT
41757: PUSH
41758: LD_EXP 101
41762: PUSH
41763: LD_VAR 0 1
41767: ARRAY
41768: PPUSH
41769: LD_INT 30
41771: PUSH
41772: LD_INT 3
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: PPUSH
41779: CALL_OW 72
41783: AND
41784: PUSH
41785: LD_EXP 106
41789: PUSH
41790: LD_VAR 0 1
41794: ARRAY
41795: NOT
41796: AND
41797: IFFALSE 42462
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41799: LD_ADDR_EXP 143
41803: PUSH
41804: LD_EXP 143
41808: PPUSH
41809: LD_VAR 0 1
41813: PPUSH
41814: LD_INT 6
41816: PPUSH
41817: CALL_OW 1
41821: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41822: LD_ADDR_VAR 0 2
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: LD_INT 0
41832: PUSH
41833: LD_INT 0
41835: PUSH
41836: LD_INT 0
41838: PUSH
41839: EMPTY
41840: LIST
41841: LIST
41842: LIST
41843: LIST
41844: ST_TO_ADDR
// if sci >= 1 then
41845: LD_VAR 0 8
41849: PUSH
41850: LD_INT 1
41852: GREATEREQUAL
41853: IFFALSE 41875
// tmp := tmp diff sci [ 1 ] ;
41855: LD_ADDR_VAR 0 4
41859: PUSH
41860: LD_VAR 0 4
41864: PUSH
41865: LD_VAR 0 8
41869: PUSH
41870: LD_INT 1
41872: ARRAY
41873: DIFF
41874: ST_TO_ADDR
// if tmp and not sci then
41875: LD_VAR 0 4
41879: PUSH
41880: LD_VAR 0 8
41884: NOT
41885: AND
41886: IFFALSE 41955
// begin sort := SortBySkill ( tmp , 4 ) ;
41888: LD_ADDR_VAR 0 9
41892: PUSH
41893: LD_VAR 0 4
41897: PPUSH
41898: LD_INT 4
41900: PPUSH
41901: CALL 105850 0 2
41905: ST_TO_ADDR
// if sort then
41906: LD_VAR 0 9
41910: IFFALSE 41926
// p := sort [ 1 ] ;
41912: LD_ADDR_VAR 0 11
41916: PUSH
41917: LD_VAR 0 9
41921: PUSH
41922: LD_INT 1
41924: ARRAY
41925: ST_TO_ADDR
// if p then
41926: LD_VAR 0 11
41930: IFFALSE 41955
// result := Replace ( result , 4 , p ) ;
41932: LD_ADDR_VAR 0 2
41936: PUSH
41937: LD_VAR 0 2
41941: PPUSH
41942: LD_INT 4
41944: PPUSH
41945: LD_VAR 0 11
41949: PPUSH
41950: CALL_OW 1
41954: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41955: LD_ADDR_VAR 0 4
41959: PUSH
41960: LD_VAR 0 4
41964: PUSH
41965: LD_VAR 0 7
41969: DIFF
41970: ST_TO_ADDR
// if tmp and mech < 6 then
41971: LD_VAR 0 4
41975: PUSH
41976: LD_VAR 0 7
41980: PUSH
41981: LD_INT 6
41983: LESS
41984: AND
41985: IFFALSE 42167
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41987: LD_ADDR_VAR 0 9
41991: PUSH
41992: LD_VAR 0 4
41996: PUSH
41997: LD_VAR 0 7
42001: DIFF
42002: PPUSH
42003: LD_INT 3
42005: PPUSH
42006: CALL 105850 0 2
42010: ST_TO_ADDR
// p := [ ] ;
42011: LD_ADDR_VAR 0 11
42015: PUSH
42016: EMPTY
42017: ST_TO_ADDR
// if sort then
42018: LD_VAR 0 9
42022: IFFALSE 42138
// for i = 1 to 6 - mech do
42024: LD_ADDR_VAR 0 3
42028: PUSH
42029: DOUBLE
42030: LD_INT 1
42032: DEC
42033: ST_TO_ADDR
42034: LD_INT 6
42036: PUSH
42037: LD_VAR 0 7
42041: MINUS
42042: PUSH
42043: FOR_TO
42044: IFFALSE 42136
// begin if i = sort then
42046: LD_VAR 0 3
42050: PUSH
42051: LD_VAR 0 9
42055: EQUAL
42056: IFFALSE 42060
// break ;
42058: GO 42136
// if GetClass ( i ) = 3 then
42060: LD_VAR 0 3
42064: PPUSH
42065: CALL_OW 257
42069: PUSH
42070: LD_INT 3
42072: EQUAL
42073: IFFALSE 42077
// continue ;
42075: GO 42043
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42077: LD_ADDR_VAR 0 11
42081: PUSH
42082: LD_VAR 0 11
42086: PPUSH
42087: LD_VAR 0 11
42091: PUSH
42092: LD_INT 1
42094: PLUS
42095: PPUSH
42096: LD_VAR 0 9
42100: PUSH
42101: LD_VAR 0 3
42105: ARRAY
42106: PPUSH
42107: CALL_OW 2
42111: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42112: LD_ADDR_VAR 0 4
42116: PUSH
42117: LD_VAR 0 4
42121: PUSH
42122: LD_VAR 0 9
42126: PUSH
42127: LD_VAR 0 3
42131: ARRAY
42132: DIFF
42133: ST_TO_ADDR
// end ;
42134: GO 42043
42136: POP
42137: POP
// if p then
42138: LD_VAR 0 11
42142: IFFALSE 42167
// result := Replace ( result , 3 , p ) ;
42144: LD_ADDR_VAR 0 2
42148: PUSH
42149: LD_VAR 0 2
42153: PPUSH
42154: LD_INT 3
42156: PPUSH
42157: LD_VAR 0 11
42161: PPUSH
42162: CALL_OW 1
42166: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42167: LD_ADDR_VAR 0 4
42171: PUSH
42172: LD_VAR 0 4
42176: PUSH
42177: LD_VAR 0 6
42181: DIFF
42182: ST_TO_ADDR
// if tmp and eng < 4 then
42183: LD_VAR 0 4
42187: PUSH
42188: LD_VAR 0 6
42192: PUSH
42193: LD_INT 4
42195: LESS
42196: AND
42197: IFFALSE 42387
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42199: LD_ADDR_VAR 0 9
42203: PUSH
42204: LD_VAR 0 4
42208: PUSH
42209: LD_VAR 0 7
42213: PUSH
42214: LD_VAR 0 6
42218: UNION
42219: DIFF
42220: PPUSH
42221: LD_INT 2
42223: PPUSH
42224: CALL 105850 0 2
42228: ST_TO_ADDR
// p := [ ] ;
42229: LD_ADDR_VAR 0 11
42233: PUSH
42234: EMPTY
42235: ST_TO_ADDR
// if sort then
42236: LD_VAR 0 9
42240: IFFALSE 42356
// for i = 1 to 4 - eng do
42242: LD_ADDR_VAR 0 3
42246: PUSH
42247: DOUBLE
42248: LD_INT 1
42250: DEC
42251: ST_TO_ADDR
42252: LD_INT 4
42254: PUSH
42255: LD_VAR 0 6
42259: MINUS
42260: PUSH
42261: FOR_TO
42262: IFFALSE 42354
// begin if i = sort then
42264: LD_VAR 0 3
42268: PUSH
42269: LD_VAR 0 9
42273: EQUAL
42274: IFFALSE 42278
// break ;
42276: GO 42354
// if GetClass ( i ) = 2 then
42278: LD_VAR 0 3
42282: PPUSH
42283: CALL_OW 257
42287: PUSH
42288: LD_INT 2
42290: EQUAL
42291: IFFALSE 42295
// continue ;
42293: GO 42261
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42295: LD_ADDR_VAR 0 11
42299: PUSH
42300: LD_VAR 0 11
42304: PPUSH
42305: LD_VAR 0 11
42309: PUSH
42310: LD_INT 1
42312: PLUS
42313: PPUSH
42314: LD_VAR 0 9
42318: PUSH
42319: LD_VAR 0 3
42323: ARRAY
42324: PPUSH
42325: CALL_OW 2
42329: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42330: LD_ADDR_VAR 0 4
42334: PUSH
42335: LD_VAR 0 4
42339: PUSH
42340: LD_VAR 0 9
42344: PUSH
42345: LD_VAR 0 3
42349: ARRAY
42350: DIFF
42351: ST_TO_ADDR
// end ;
42352: GO 42261
42354: POP
42355: POP
// if p then
42356: LD_VAR 0 11
42360: IFFALSE 42385
// result := Replace ( result , 2 , p ) ;
42362: LD_ADDR_VAR 0 2
42366: PUSH
42367: LD_VAR 0 2
42371: PPUSH
42372: LD_INT 2
42374: PPUSH
42375: LD_VAR 0 11
42379: PPUSH
42380: CALL_OW 1
42384: ST_TO_ADDR
// end else
42385: GO 42431
// for i = eng downto 5 do
42387: LD_ADDR_VAR 0 3
42391: PUSH
42392: DOUBLE
42393: LD_VAR 0 6
42397: INC
42398: ST_TO_ADDR
42399: LD_INT 5
42401: PUSH
42402: FOR_DOWNTO
42403: IFFALSE 42429
// tmp := tmp union eng [ i ] ;
42405: LD_ADDR_VAR 0 4
42409: PUSH
42410: LD_VAR 0 4
42414: PUSH
42415: LD_VAR 0 6
42419: PUSH
42420: LD_VAR 0 3
42424: ARRAY
42425: UNION
42426: ST_TO_ADDR
42427: GO 42402
42429: POP
42430: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42431: LD_ADDR_VAR 0 2
42435: PUSH
42436: LD_VAR 0 2
42440: PPUSH
42441: LD_INT 1
42443: PPUSH
42444: LD_VAR 0 4
42448: PUSH
42449: LD_VAR 0 5
42453: DIFF
42454: PPUSH
42455: CALL_OW 1
42459: ST_TO_ADDR
// exit ;
42460: GO 42462
// end ; end ;
42462: LD_VAR 0 2
42466: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42467: LD_INT 0
42469: PPUSH
42470: PPUSH
42471: PPUSH
// if not mc_bases then
42472: LD_EXP 101
42476: NOT
42477: IFFALSE 42481
// exit ;
42479: GO 42587
// for i = 1 to mc_bases do
42481: LD_ADDR_VAR 0 2
42485: PUSH
42486: DOUBLE
42487: LD_INT 1
42489: DEC
42490: ST_TO_ADDR
42491: LD_EXP 101
42495: PUSH
42496: FOR_TO
42497: IFFALSE 42578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42499: LD_ADDR_VAR 0 3
42503: PUSH
42504: LD_EXP 101
42508: PUSH
42509: LD_VAR 0 2
42513: ARRAY
42514: PPUSH
42515: LD_INT 21
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 3
42527: PUSH
42528: LD_INT 24
42530: PUSH
42531: LD_INT 1000
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PPUSH
42546: CALL_OW 72
42550: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42551: LD_ADDR_EXP 102
42555: PUSH
42556: LD_EXP 102
42560: PPUSH
42561: LD_VAR 0 2
42565: PPUSH
42566: LD_VAR 0 3
42570: PPUSH
42571: CALL_OW 1
42575: ST_TO_ADDR
// end ;
42576: GO 42496
42578: POP
42579: POP
// RaiseSailEvent ( 101 ) ;
42580: LD_INT 101
42582: PPUSH
42583: CALL_OW 427
// end ;
42587: LD_VAR 0 1
42591: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42592: LD_INT 0
42594: PPUSH
42595: PPUSH
42596: PPUSH
42597: PPUSH
42598: PPUSH
42599: PPUSH
42600: PPUSH
// if not mc_bases then
42601: LD_EXP 101
42605: NOT
42606: IFFALSE 42610
// exit ;
42608: GO 43183
// for i = 1 to mc_bases do
42610: LD_ADDR_VAR 0 2
42614: PUSH
42615: DOUBLE
42616: LD_INT 1
42618: DEC
42619: ST_TO_ADDR
42620: LD_EXP 101
42624: PUSH
42625: FOR_TO
42626: IFFALSE 43174
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42628: LD_ADDR_VAR 0 5
42632: PUSH
42633: LD_EXP 101
42637: PUSH
42638: LD_VAR 0 2
42642: ARRAY
42643: PUSH
42644: LD_EXP 130
42648: PUSH
42649: LD_VAR 0 2
42653: ARRAY
42654: UNION
42655: PPUSH
42656: LD_INT 21
42658: PUSH
42659: LD_INT 1
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 1
42668: PUSH
42669: LD_INT 3
42671: PUSH
42672: LD_INT 54
42674: PUSH
42675: EMPTY
42676: LIST
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 3
42684: PUSH
42685: LD_INT 24
42687: PUSH
42688: LD_INT 800
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PPUSH
42708: CALL_OW 72
42712: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42713: LD_ADDR_VAR 0 6
42717: PUSH
42718: LD_EXP 101
42722: PUSH
42723: LD_VAR 0 2
42727: ARRAY
42728: PPUSH
42729: LD_INT 21
42731: PUSH
42732: LD_INT 1
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 1
42741: PUSH
42742: LD_INT 3
42744: PUSH
42745: LD_INT 54
42747: PUSH
42748: EMPTY
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: PUSH
42758: LD_INT 24
42760: PUSH
42761: LD_INT 250
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: LIST
42776: PUSH
42777: EMPTY
42778: LIST
42779: LIST
42780: PPUSH
42781: CALL_OW 72
42785: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42786: LD_ADDR_VAR 0 7
42790: PUSH
42791: LD_VAR 0 5
42795: PUSH
42796: LD_VAR 0 6
42800: DIFF
42801: ST_TO_ADDR
// if not need_heal_1 then
42802: LD_VAR 0 6
42806: NOT
42807: IFFALSE 42840
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42809: LD_ADDR_EXP 104
42813: PUSH
42814: LD_EXP 104
42818: PPUSH
42819: LD_VAR 0 2
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PPUSH
42831: EMPTY
42832: PPUSH
42833: CALL 71602 0 3
42837: ST_TO_ADDR
42838: GO 42910
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42840: LD_ADDR_EXP 104
42844: PUSH
42845: LD_EXP 104
42849: PPUSH
42850: LD_VAR 0 2
42854: PUSH
42855: LD_INT 1
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PPUSH
42862: LD_EXP 104
42866: PUSH
42867: LD_VAR 0 2
42871: ARRAY
42872: PUSH
42873: LD_INT 1
42875: ARRAY
42876: PPUSH
42877: LD_INT 3
42879: PUSH
42880: LD_INT 24
42882: PUSH
42883: LD_INT 1000
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PPUSH
42894: CALL_OW 72
42898: PUSH
42899: LD_VAR 0 6
42903: UNION
42904: PPUSH
42905: CALL 71602 0 3
42909: ST_TO_ADDR
// if not need_heal_2 then
42910: LD_VAR 0 7
42914: NOT
42915: IFFALSE 42948
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42917: LD_ADDR_EXP 104
42921: PUSH
42922: LD_EXP 104
42926: PPUSH
42927: LD_VAR 0 2
42931: PUSH
42932: LD_INT 2
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PPUSH
42939: EMPTY
42940: PPUSH
42941: CALL 71602 0 3
42945: ST_TO_ADDR
42946: GO 42980
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42948: LD_ADDR_EXP 104
42952: PUSH
42953: LD_EXP 104
42957: PPUSH
42958: LD_VAR 0 2
42962: PUSH
42963: LD_INT 2
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PPUSH
42970: LD_VAR 0 7
42974: PPUSH
42975: CALL 71602 0 3
42979: ST_TO_ADDR
// if need_heal_2 then
42980: LD_VAR 0 7
42984: IFFALSE 43156
// for j in need_heal_2 do
42986: LD_ADDR_VAR 0 3
42990: PUSH
42991: LD_VAR 0 7
42995: PUSH
42996: FOR_IN
42997: IFFALSE 43154
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42999: LD_ADDR_VAR 0 5
43003: PUSH
43004: LD_EXP 101
43008: PUSH
43009: LD_VAR 0 2
43013: ARRAY
43014: PPUSH
43015: LD_INT 2
43017: PUSH
43018: LD_INT 30
43020: PUSH
43021: LD_INT 6
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 30
43030: PUSH
43031: LD_INT 7
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 30
43040: PUSH
43041: LD_INT 8
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 30
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 30
43060: PUSH
43061: LD_INT 1
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 25
43070: PUSH
43071: LD_INT 4
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: PPUSH
43087: CALL_OW 72
43091: ST_TO_ADDR
// if tmp then
43092: LD_VAR 0 5
43096: IFFALSE 43152
// begin k := NearestUnitToUnit ( tmp , j ) ;
43098: LD_ADDR_VAR 0 4
43102: PUSH
43103: LD_VAR 0 5
43107: PPUSH
43108: LD_VAR 0 3
43112: PPUSH
43113: CALL_OW 74
43117: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43118: LD_VAR 0 3
43122: PPUSH
43123: LD_VAR 0 4
43127: PPUSH
43128: CALL_OW 296
43132: PUSH
43133: LD_INT 7
43135: GREATER
43136: IFFALSE 43152
// ComMoveUnit ( j , k ) ;
43138: LD_VAR 0 3
43142: PPUSH
43143: LD_VAR 0 4
43147: PPUSH
43148: CALL_OW 112
// end ; end ;
43152: GO 42996
43154: POP
43155: POP
// if not need_heal_1 and not need_heal_2 then
43156: LD_VAR 0 6
43160: NOT
43161: PUSH
43162: LD_VAR 0 7
43166: NOT
43167: AND
43168: IFFALSE 43172
// continue ;
43170: GO 42625
// end ;
43172: GO 42625
43174: POP
43175: POP
// RaiseSailEvent ( 102 ) ;
43176: LD_INT 102
43178: PPUSH
43179: CALL_OW 427
// end ;
43183: LD_VAR 0 1
43187: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
43188: LD_INT 0
43190: PPUSH
43191: PPUSH
43192: PPUSH
43193: PPUSH
43194: PPUSH
43195: PPUSH
// if not mc_bases then
43196: LD_EXP 101
43200: NOT
43201: IFFALSE 43205
// exit ;
43203: GO 43915
// for i = 1 to mc_bases do
43205: LD_ADDR_VAR 0 2
43209: PUSH
43210: DOUBLE
43211: LD_INT 1
43213: DEC
43214: ST_TO_ADDR
43215: LD_EXP 101
43219: PUSH
43220: FOR_TO
43221: IFFALSE 43913
// begin if not mc_building_need_repair [ i ] then
43223: LD_EXP 102
43227: PUSH
43228: LD_VAR 0 2
43232: ARRAY
43233: NOT
43234: IFFALSE 43408
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43236: LD_ADDR_VAR 0 6
43240: PUSH
43241: LD_EXP 120
43245: PUSH
43246: LD_VAR 0 2
43250: ARRAY
43251: PPUSH
43252: LD_INT 3
43254: PUSH
43255: LD_INT 24
43257: PUSH
43258: LD_INT 1000
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 2
43271: PUSH
43272: LD_INT 34
43274: PUSH
43275: LD_INT 13
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 34
43284: PUSH
43285: LD_INT 52
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: LIST
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PPUSH
43301: CALL_OW 72
43305: ST_TO_ADDR
// if cranes then
43306: LD_VAR 0 6
43310: IFFALSE 43372
// for j in cranes do
43312: LD_ADDR_VAR 0 3
43316: PUSH
43317: LD_VAR 0 6
43321: PUSH
43322: FOR_IN
43323: IFFALSE 43370
// if not IsInArea ( j , mc_parking [ i ] ) then
43325: LD_VAR 0 3
43329: PPUSH
43330: LD_EXP 125
43334: PUSH
43335: LD_VAR 0 2
43339: ARRAY
43340: PPUSH
43341: CALL_OW 308
43345: NOT
43346: IFFALSE 43368
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43348: LD_VAR 0 3
43352: PPUSH
43353: LD_EXP 125
43357: PUSH
43358: LD_VAR 0 2
43362: ARRAY
43363: PPUSH
43364: CALL_OW 113
43368: GO 43322
43370: POP
43371: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43372: LD_ADDR_EXP 103
43376: PUSH
43377: LD_EXP 103
43381: PPUSH
43382: LD_VAR 0 2
43386: PPUSH
43387: EMPTY
43388: PPUSH
43389: CALL_OW 1
43393: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43394: LD_VAR 0 2
43398: PPUSH
43399: LD_INT 101
43401: PPUSH
43402: CALL 38300 0 2
// continue ;
43406: GO 43220
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43408: LD_ADDR_EXP 107
43412: PUSH
43413: LD_EXP 107
43417: PPUSH
43418: LD_VAR 0 2
43422: PPUSH
43423: EMPTY
43424: PPUSH
43425: CALL_OW 1
43429: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43430: LD_VAR 0 2
43434: PPUSH
43435: LD_INT 103
43437: PPUSH
43438: CALL 38300 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43442: LD_ADDR_VAR 0 5
43446: PUSH
43447: LD_EXP 101
43451: PUSH
43452: LD_VAR 0 2
43456: ARRAY
43457: PUSH
43458: LD_EXP 130
43462: PUSH
43463: LD_VAR 0 2
43467: ARRAY
43468: UNION
43469: PPUSH
43470: LD_INT 2
43472: PUSH
43473: LD_INT 25
43475: PUSH
43476: LD_INT 2
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 25
43485: PUSH
43486: LD_INT 16
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: LIST
43497: PUSH
43498: EMPTY
43499: LIST
43500: PPUSH
43501: CALL_OW 72
43505: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43506: LD_ADDR_VAR 0 6
43510: PUSH
43511: LD_EXP 120
43515: PUSH
43516: LD_VAR 0 2
43520: ARRAY
43521: PPUSH
43522: LD_INT 2
43524: PUSH
43525: LD_INT 34
43527: PUSH
43528: LD_INT 13
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 34
43537: PUSH
43538: LD_INT 52
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: LIST
43549: PPUSH
43550: CALL_OW 72
43554: ST_TO_ADDR
// if cranes then
43555: LD_VAR 0 6
43559: IFFALSE 43695
// begin for j in cranes do
43561: LD_ADDR_VAR 0 3
43565: PUSH
43566: LD_VAR 0 6
43570: PUSH
43571: FOR_IN
43572: IFFALSE 43693
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43574: LD_VAR 0 3
43578: PPUSH
43579: CALL_OW 256
43583: PUSH
43584: LD_INT 500
43586: GREATEREQUAL
43587: PUSH
43588: LD_VAR 0 3
43592: PPUSH
43593: CALL_OW 314
43597: NOT
43598: AND
43599: IFFALSE 43633
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43601: LD_VAR 0 3
43605: PPUSH
43606: LD_EXP 102
43610: PUSH
43611: LD_VAR 0 2
43615: ARRAY
43616: PPUSH
43617: LD_VAR 0 3
43621: PPUSH
43622: CALL_OW 74
43626: PPUSH
43627: CALL_OW 130
43631: GO 43691
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43633: LD_VAR 0 3
43637: PPUSH
43638: CALL_OW 256
43642: PUSH
43643: LD_INT 500
43645: LESS
43646: PUSH
43647: LD_VAR 0 3
43651: PPUSH
43652: LD_EXP 125
43656: PUSH
43657: LD_VAR 0 2
43661: ARRAY
43662: PPUSH
43663: CALL_OW 308
43667: NOT
43668: AND
43669: IFFALSE 43691
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43671: LD_VAR 0 3
43675: PPUSH
43676: LD_EXP 125
43680: PUSH
43681: LD_VAR 0 2
43685: ARRAY
43686: PPUSH
43687: CALL_OW 113
43691: GO 43571
43693: POP
43694: POP
// end ; if not tmp then
43695: LD_VAR 0 5
43699: NOT
43700: IFFALSE 43704
// continue ;
43702: GO 43220
// for j in tmp do
43704: LD_ADDR_VAR 0 3
43708: PUSH
43709: LD_VAR 0 5
43713: PUSH
43714: FOR_IN
43715: IFFALSE 43909
// begin if mc_need_heal [ i ] then
43717: LD_EXP 104
43721: PUSH
43722: LD_VAR 0 2
43726: ARRAY
43727: IFFALSE 43775
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43729: LD_VAR 0 3
43733: PUSH
43734: LD_EXP 104
43738: PUSH
43739: LD_VAR 0 2
43743: ARRAY
43744: PUSH
43745: LD_INT 1
43747: ARRAY
43748: IN
43749: PUSH
43750: LD_VAR 0 3
43754: PUSH
43755: LD_EXP 104
43759: PUSH
43760: LD_VAR 0 2
43764: ARRAY
43765: PUSH
43766: LD_INT 2
43768: ARRAY
43769: IN
43770: OR
43771: IFFALSE 43775
// continue ;
43773: GO 43714
// if IsInUnit ( j ) then
43775: LD_VAR 0 3
43779: PPUSH
43780: CALL_OW 310
43784: IFFALSE 43795
// ComExitBuilding ( j ) ;
43786: LD_VAR 0 3
43790: PPUSH
43791: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43795: LD_VAR 0 3
43799: PUSH
43800: LD_EXP 103
43804: PUSH
43805: LD_VAR 0 2
43809: ARRAY
43810: IN
43811: NOT
43812: IFFALSE 43870
// begin SetTag ( j , 101 ) ;
43814: LD_VAR 0 3
43818: PPUSH
43819: LD_INT 101
43821: PPUSH
43822: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43826: LD_ADDR_EXP 103
43830: PUSH
43831: LD_EXP 103
43835: PPUSH
43836: LD_VAR 0 2
43840: PUSH
43841: LD_EXP 103
43845: PUSH
43846: LD_VAR 0 2
43850: ARRAY
43851: PUSH
43852: LD_INT 1
43854: PLUS
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PPUSH
43860: LD_VAR 0 3
43864: PPUSH
43865: CALL 71602 0 3
43869: ST_TO_ADDR
// end ; wait ( 1 ) ;
43870: LD_INT 1
43872: PPUSH
43873: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43877: LD_VAR 0 3
43881: PPUSH
43882: LD_EXP 102
43886: PUSH
43887: LD_VAR 0 2
43891: ARRAY
43892: PPUSH
43893: LD_VAR 0 3
43897: PPUSH
43898: CALL_OW 74
43902: PPUSH
43903: CALL_OW 130
// end ;
43907: GO 43714
43909: POP
43910: POP
// end ;
43911: GO 43220
43913: POP
43914: POP
// end ;
43915: LD_VAR 0 1
43919: RET
// export function MC_Heal ; var i , j , tmp ; begin
43920: LD_INT 0
43922: PPUSH
43923: PPUSH
43924: PPUSH
43925: PPUSH
// if not mc_bases then
43926: LD_EXP 101
43930: NOT
43931: IFFALSE 43935
// exit ;
43933: GO 44337
// for i = 1 to mc_bases do
43935: LD_ADDR_VAR 0 2
43939: PUSH
43940: DOUBLE
43941: LD_INT 1
43943: DEC
43944: ST_TO_ADDR
43945: LD_EXP 101
43949: PUSH
43950: FOR_TO
43951: IFFALSE 44335
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43953: LD_EXP 104
43957: PUSH
43958: LD_VAR 0 2
43962: ARRAY
43963: PUSH
43964: LD_INT 1
43966: ARRAY
43967: NOT
43968: PUSH
43969: LD_EXP 104
43973: PUSH
43974: LD_VAR 0 2
43978: ARRAY
43979: PUSH
43980: LD_INT 2
43982: ARRAY
43983: NOT
43984: AND
43985: IFFALSE 44023
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43987: LD_ADDR_EXP 105
43991: PUSH
43992: LD_EXP 105
43996: PPUSH
43997: LD_VAR 0 2
44001: PPUSH
44002: EMPTY
44003: PPUSH
44004: CALL_OW 1
44008: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44009: LD_VAR 0 2
44013: PPUSH
44014: LD_INT 102
44016: PPUSH
44017: CALL 38300 0 2
// continue ;
44021: GO 43950
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44023: LD_ADDR_VAR 0 4
44027: PUSH
44028: LD_EXP 101
44032: PUSH
44033: LD_VAR 0 2
44037: ARRAY
44038: PPUSH
44039: LD_INT 25
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PPUSH
44049: CALL_OW 72
44053: ST_TO_ADDR
// if not tmp then
44054: LD_VAR 0 4
44058: NOT
44059: IFFALSE 44063
// continue ;
44061: GO 43950
// if mc_taming [ i ] then
44063: LD_EXP 132
44067: PUSH
44068: LD_VAR 0 2
44072: ARRAY
44073: IFFALSE 44097
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44075: LD_ADDR_EXP 132
44079: PUSH
44080: LD_EXP 132
44084: PPUSH
44085: LD_VAR 0 2
44089: PPUSH
44090: EMPTY
44091: PPUSH
44092: CALL_OW 1
44096: ST_TO_ADDR
// for j in tmp do
44097: LD_ADDR_VAR 0 3
44101: PUSH
44102: LD_VAR 0 4
44106: PUSH
44107: FOR_IN
44108: IFFALSE 44331
// begin if IsInUnit ( j ) then
44110: LD_VAR 0 3
44114: PPUSH
44115: CALL_OW 310
44119: IFFALSE 44130
// ComExitBuilding ( j ) ;
44121: LD_VAR 0 3
44125: PPUSH
44126: CALL_OW 122
// if not j in mc_healers [ i ] then
44130: LD_VAR 0 3
44134: PUSH
44135: LD_EXP 105
44139: PUSH
44140: LD_VAR 0 2
44144: ARRAY
44145: IN
44146: NOT
44147: IFFALSE 44193
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44149: LD_ADDR_EXP 105
44153: PUSH
44154: LD_EXP 105
44158: PPUSH
44159: LD_VAR 0 2
44163: PUSH
44164: LD_EXP 105
44168: PUSH
44169: LD_VAR 0 2
44173: ARRAY
44174: PUSH
44175: LD_INT 1
44177: PLUS
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PPUSH
44183: LD_VAR 0 3
44187: PPUSH
44188: CALL 71602 0 3
44192: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44193: LD_VAR 0 3
44197: PPUSH
44198: CALL_OW 110
44202: PUSH
44203: LD_INT 102
44205: NONEQUAL
44206: IFFALSE 44220
// SetTag ( j , 102 ) ;
44208: LD_VAR 0 3
44212: PPUSH
44213: LD_INT 102
44215: PPUSH
44216: CALL_OW 109
// Wait ( 3 ) ;
44220: LD_INT 3
44222: PPUSH
44223: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44227: LD_EXP 104
44231: PUSH
44232: LD_VAR 0 2
44236: ARRAY
44237: PUSH
44238: LD_INT 1
44240: ARRAY
44241: IFFALSE 44273
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
44243: LD_VAR 0 3
44247: PPUSH
44248: LD_EXP 104
44252: PUSH
44253: LD_VAR 0 2
44257: ARRAY
44258: PUSH
44259: LD_INT 1
44261: ARRAY
44262: PUSH
44263: LD_INT 1
44265: ARRAY
44266: PPUSH
44267: CALL_OW 128
44271: GO 44329
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
44273: LD_VAR 0 3
44277: PPUSH
44278: CALL_OW 314
44282: NOT
44283: PUSH
44284: LD_EXP 104
44288: PUSH
44289: LD_VAR 0 2
44293: ARRAY
44294: PUSH
44295: LD_INT 2
44297: ARRAY
44298: AND
44299: IFFALSE 44329
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
44301: LD_VAR 0 3
44305: PPUSH
44306: LD_EXP 104
44310: PUSH
44311: LD_VAR 0 2
44315: ARRAY
44316: PUSH
44317: LD_INT 2
44319: ARRAY
44320: PUSH
44321: LD_INT 1
44323: ARRAY
44324: PPUSH
44325: CALL_OW 128
// end ;
44329: GO 44107
44331: POP
44332: POP
// end ;
44333: GO 43950
44335: POP
44336: POP
// end ;
44337: LD_VAR 0 1
44341: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44342: LD_INT 0
44344: PPUSH
44345: PPUSH
44346: PPUSH
44347: PPUSH
44348: PPUSH
// if not mc_bases then
44349: LD_EXP 101
44353: NOT
44354: IFFALSE 44358
// exit ;
44356: GO 45501
// for i = 1 to mc_bases do
44358: LD_ADDR_VAR 0 2
44362: PUSH
44363: DOUBLE
44364: LD_INT 1
44366: DEC
44367: ST_TO_ADDR
44368: LD_EXP 101
44372: PUSH
44373: FOR_TO
44374: IFFALSE 45499
// begin if mc_scan [ i ] then
44376: LD_EXP 124
44380: PUSH
44381: LD_VAR 0 2
44385: ARRAY
44386: IFFALSE 44390
// continue ;
44388: GO 44373
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44390: LD_EXP 106
44394: PUSH
44395: LD_VAR 0 2
44399: ARRAY
44400: NOT
44401: PUSH
44402: LD_EXP 108
44406: PUSH
44407: LD_VAR 0 2
44411: ARRAY
44412: NOT
44413: AND
44414: PUSH
44415: LD_EXP 107
44419: PUSH
44420: LD_VAR 0 2
44424: ARRAY
44425: AND
44426: IFFALSE 44464
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44428: LD_ADDR_EXP 107
44432: PUSH
44433: LD_EXP 107
44437: PPUSH
44438: LD_VAR 0 2
44442: PPUSH
44443: EMPTY
44444: PPUSH
44445: CALL_OW 1
44449: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44450: LD_VAR 0 2
44454: PPUSH
44455: LD_INT 103
44457: PPUSH
44458: CALL 38300 0 2
// continue ;
44462: GO 44373
// end ; if mc_construct_list [ i ] then
44464: LD_EXP 108
44468: PUSH
44469: LD_VAR 0 2
44473: ARRAY
44474: IFFALSE 44694
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44476: LD_ADDR_VAR 0 4
44480: PUSH
44481: LD_EXP 101
44485: PUSH
44486: LD_VAR 0 2
44490: ARRAY
44491: PPUSH
44492: LD_INT 25
44494: PUSH
44495: LD_INT 2
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PPUSH
44502: CALL_OW 72
44506: PUSH
44507: LD_EXP 103
44511: PUSH
44512: LD_VAR 0 2
44516: ARRAY
44517: DIFF
44518: ST_TO_ADDR
// if not tmp then
44519: LD_VAR 0 4
44523: NOT
44524: IFFALSE 44528
// continue ;
44526: GO 44373
// for j in tmp do
44528: LD_ADDR_VAR 0 3
44532: PUSH
44533: LD_VAR 0 4
44537: PUSH
44538: FOR_IN
44539: IFFALSE 44690
// begin if not mc_builders [ i ] then
44541: LD_EXP 107
44545: PUSH
44546: LD_VAR 0 2
44550: ARRAY
44551: NOT
44552: IFFALSE 44610
// begin SetTag ( j , 103 ) ;
44554: LD_VAR 0 3
44558: PPUSH
44559: LD_INT 103
44561: PPUSH
44562: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44566: LD_ADDR_EXP 107
44570: PUSH
44571: LD_EXP 107
44575: PPUSH
44576: LD_VAR 0 2
44580: PUSH
44581: LD_EXP 107
44585: PUSH
44586: LD_VAR 0 2
44590: ARRAY
44591: PUSH
44592: LD_INT 1
44594: PLUS
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PPUSH
44600: LD_VAR 0 3
44604: PPUSH
44605: CALL 71602 0 3
44609: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44610: LD_VAR 0 3
44614: PPUSH
44615: CALL_OW 310
44619: IFFALSE 44630
// ComExitBuilding ( j ) ;
44621: LD_VAR 0 3
44625: PPUSH
44626: CALL_OW 122
// wait ( 3 ) ;
44630: LD_INT 3
44632: PPUSH
44633: CALL_OW 67
// if not mc_construct_list [ i ] then
44637: LD_EXP 108
44641: PUSH
44642: LD_VAR 0 2
44646: ARRAY
44647: NOT
44648: IFFALSE 44652
// break ;
44650: GO 44690
// if not HasTask ( j ) then
44652: LD_VAR 0 3
44656: PPUSH
44657: CALL_OW 314
44661: NOT
44662: IFFALSE 44688
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44664: LD_VAR 0 3
44668: PPUSH
44669: LD_EXP 108
44673: PUSH
44674: LD_VAR 0 2
44678: ARRAY
44679: PUSH
44680: LD_INT 1
44682: ARRAY
44683: PPUSH
44684: CALL 74453 0 2
// end ;
44688: GO 44538
44690: POP
44691: POP
// end else
44692: GO 45497
// if mc_build_list [ i ] then
44694: LD_EXP 106
44698: PUSH
44699: LD_VAR 0 2
44703: ARRAY
44704: IFFALSE 45497
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44706: LD_ADDR_VAR 0 5
44710: PUSH
44711: LD_EXP 101
44715: PUSH
44716: LD_VAR 0 2
44720: ARRAY
44721: PPUSH
44722: LD_INT 2
44724: PUSH
44725: LD_INT 30
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 30
44737: PUSH
44738: LD_INT 1
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: LIST
44749: PPUSH
44750: CALL_OW 72
44754: ST_TO_ADDR
// if depot then
44755: LD_VAR 0 5
44759: IFFALSE 44777
// depot := depot [ 1 ] else
44761: LD_ADDR_VAR 0 5
44765: PUSH
44766: LD_VAR 0 5
44770: PUSH
44771: LD_INT 1
44773: ARRAY
44774: ST_TO_ADDR
44775: GO 44785
// depot := 0 ;
44777: LD_ADDR_VAR 0 5
44781: PUSH
44782: LD_INT 0
44784: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44785: LD_EXP 106
44789: PUSH
44790: LD_VAR 0 2
44794: ARRAY
44795: PUSH
44796: LD_INT 1
44798: ARRAY
44799: PUSH
44800: LD_INT 1
44802: ARRAY
44803: PPUSH
44804: CALL 74283 0 1
44808: PUSH
44809: LD_EXP 101
44813: PUSH
44814: LD_VAR 0 2
44818: ARRAY
44819: PPUSH
44820: LD_INT 2
44822: PUSH
44823: LD_INT 30
44825: PUSH
44826: LD_INT 2
44828: PUSH
44829: EMPTY
44830: LIST
44831: LIST
44832: PUSH
44833: LD_INT 30
44835: PUSH
44836: LD_INT 3
44838: PUSH
44839: EMPTY
44840: LIST
44841: LIST
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: LIST
44847: PPUSH
44848: CALL_OW 72
44852: NOT
44853: AND
44854: IFFALSE 44959
// begin for j = 1 to mc_build_list [ i ] do
44856: LD_ADDR_VAR 0 3
44860: PUSH
44861: DOUBLE
44862: LD_INT 1
44864: DEC
44865: ST_TO_ADDR
44866: LD_EXP 106
44870: PUSH
44871: LD_VAR 0 2
44875: ARRAY
44876: PUSH
44877: FOR_TO
44878: IFFALSE 44957
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44880: LD_EXP 106
44884: PUSH
44885: LD_VAR 0 2
44889: ARRAY
44890: PUSH
44891: LD_VAR 0 3
44895: ARRAY
44896: PUSH
44897: LD_INT 1
44899: ARRAY
44900: PUSH
44901: LD_INT 2
44903: EQUAL
44904: IFFALSE 44955
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44906: LD_ADDR_EXP 106
44910: PUSH
44911: LD_EXP 106
44915: PPUSH
44916: LD_VAR 0 2
44920: PPUSH
44921: LD_EXP 106
44925: PUSH
44926: LD_VAR 0 2
44930: ARRAY
44931: PPUSH
44932: LD_VAR 0 3
44936: PPUSH
44937: LD_INT 1
44939: PPUSH
44940: LD_INT 0
44942: PPUSH
44943: CALL 71020 0 4
44947: PPUSH
44948: CALL_OW 1
44952: ST_TO_ADDR
// break ;
44953: GO 44957
// end ;
44955: GO 44877
44957: POP
44958: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44959: LD_EXP 106
44963: PUSH
44964: LD_VAR 0 2
44968: ARRAY
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: PUSH
44974: LD_INT 1
44976: ARRAY
44977: PUSH
44978: LD_INT 0
44980: EQUAL
44981: PUSH
44982: LD_VAR 0 5
44986: PUSH
44987: LD_VAR 0 5
44991: PPUSH
44992: LD_EXP 106
44996: PUSH
44997: LD_VAR 0 2
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: PUSH
45007: LD_INT 1
45009: ARRAY
45010: PPUSH
45011: LD_EXP 106
45015: PUSH
45016: LD_VAR 0 2
45020: ARRAY
45021: PUSH
45022: LD_INT 1
45024: ARRAY
45025: PUSH
45026: LD_INT 2
45028: ARRAY
45029: PPUSH
45030: LD_EXP 106
45034: PUSH
45035: LD_VAR 0 2
45039: ARRAY
45040: PUSH
45041: LD_INT 1
45043: ARRAY
45044: PUSH
45045: LD_INT 3
45047: ARRAY
45048: PPUSH
45049: LD_EXP 106
45053: PUSH
45054: LD_VAR 0 2
45058: ARRAY
45059: PUSH
45060: LD_INT 1
45062: ARRAY
45063: PUSH
45064: LD_INT 4
45066: ARRAY
45067: PPUSH
45068: CALL 79017 0 5
45072: AND
45073: OR
45074: IFFALSE 45355
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45076: LD_ADDR_VAR 0 4
45080: PUSH
45081: LD_EXP 101
45085: PUSH
45086: LD_VAR 0 2
45090: ARRAY
45091: PPUSH
45092: LD_INT 25
45094: PUSH
45095: LD_INT 2
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PPUSH
45102: CALL_OW 72
45106: PUSH
45107: LD_EXP 103
45111: PUSH
45112: LD_VAR 0 2
45116: ARRAY
45117: DIFF
45118: ST_TO_ADDR
// if not tmp then
45119: LD_VAR 0 4
45123: NOT
45124: IFFALSE 45128
// continue ;
45126: GO 44373
// for j in tmp do
45128: LD_ADDR_VAR 0 3
45132: PUSH
45133: LD_VAR 0 4
45137: PUSH
45138: FOR_IN
45139: IFFALSE 45351
// begin if not mc_builders [ i ] then
45141: LD_EXP 107
45145: PUSH
45146: LD_VAR 0 2
45150: ARRAY
45151: NOT
45152: IFFALSE 45210
// begin SetTag ( j , 103 ) ;
45154: LD_VAR 0 3
45158: PPUSH
45159: LD_INT 103
45161: PPUSH
45162: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45166: LD_ADDR_EXP 107
45170: PUSH
45171: LD_EXP 107
45175: PPUSH
45176: LD_VAR 0 2
45180: PUSH
45181: LD_EXP 107
45185: PUSH
45186: LD_VAR 0 2
45190: ARRAY
45191: PUSH
45192: LD_INT 1
45194: PLUS
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PPUSH
45200: LD_VAR 0 3
45204: PPUSH
45205: CALL 71602 0 3
45209: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45210: LD_VAR 0 3
45214: PPUSH
45215: CALL_OW 310
45219: IFFALSE 45230
// ComExitBuilding ( j ) ;
45221: LD_VAR 0 3
45225: PPUSH
45226: CALL_OW 122
// wait ( 3 ) ;
45230: LD_INT 3
45232: PPUSH
45233: CALL_OW 67
// if not mc_build_list [ i ] then
45237: LD_EXP 106
45241: PUSH
45242: LD_VAR 0 2
45246: ARRAY
45247: NOT
45248: IFFALSE 45252
// break ;
45250: GO 45351
// if not HasTask ( j ) then
45252: LD_VAR 0 3
45256: PPUSH
45257: CALL_OW 314
45261: NOT
45262: IFFALSE 45349
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
45264: LD_VAR 0 3
45268: PPUSH
45269: LD_EXP 106
45273: PUSH
45274: LD_VAR 0 2
45278: ARRAY
45279: PUSH
45280: LD_INT 1
45282: ARRAY
45283: PUSH
45284: LD_INT 1
45286: ARRAY
45287: PPUSH
45288: LD_EXP 106
45292: PUSH
45293: LD_VAR 0 2
45297: ARRAY
45298: PUSH
45299: LD_INT 1
45301: ARRAY
45302: PUSH
45303: LD_INT 2
45305: ARRAY
45306: PPUSH
45307: LD_EXP 106
45311: PUSH
45312: LD_VAR 0 2
45316: ARRAY
45317: PUSH
45318: LD_INT 1
45320: ARRAY
45321: PUSH
45322: LD_INT 3
45324: ARRAY
45325: PPUSH
45326: LD_EXP 106
45330: PUSH
45331: LD_VAR 0 2
45335: ARRAY
45336: PUSH
45337: LD_INT 1
45339: ARRAY
45340: PUSH
45341: LD_INT 4
45343: ARRAY
45344: PPUSH
45345: CALL_OW 145
// end ;
45349: GO 45138
45351: POP
45352: POP
// end else
45353: GO 45497
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45355: LD_EXP 101
45359: PUSH
45360: LD_VAR 0 2
45364: ARRAY
45365: PPUSH
45366: LD_EXP 106
45370: PUSH
45371: LD_VAR 0 2
45375: ARRAY
45376: PUSH
45377: LD_INT 1
45379: ARRAY
45380: PUSH
45381: LD_INT 1
45383: ARRAY
45384: PPUSH
45385: LD_EXP 106
45389: PUSH
45390: LD_VAR 0 2
45394: ARRAY
45395: PUSH
45396: LD_INT 1
45398: ARRAY
45399: PUSH
45400: LD_INT 2
45402: ARRAY
45403: PPUSH
45404: LD_EXP 106
45408: PUSH
45409: LD_VAR 0 2
45413: ARRAY
45414: PUSH
45415: LD_INT 1
45417: ARRAY
45418: PUSH
45419: LD_INT 3
45421: ARRAY
45422: PPUSH
45423: LD_EXP 106
45427: PUSH
45428: LD_VAR 0 2
45432: ARRAY
45433: PUSH
45434: LD_INT 1
45436: ARRAY
45437: PUSH
45438: LD_INT 4
45440: ARRAY
45441: PPUSH
45442: CALL 78353 0 5
45446: NOT
45447: IFFALSE 45497
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45449: LD_ADDR_EXP 106
45453: PUSH
45454: LD_EXP 106
45458: PPUSH
45459: LD_VAR 0 2
45463: PPUSH
45464: LD_EXP 106
45468: PUSH
45469: LD_VAR 0 2
45473: ARRAY
45474: PPUSH
45475: LD_INT 1
45477: PPUSH
45478: LD_INT 1
45480: NEG
45481: PPUSH
45482: LD_INT 0
45484: PPUSH
45485: CALL 71020 0 4
45489: PPUSH
45490: CALL_OW 1
45494: ST_TO_ADDR
// continue ;
45495: GO 44373
// end ; end ; end ;
45497: GO 44373
45499: POP
45500: POP
// end ;
45501: LD_VAR 0 1
45505: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45506: LD_INT 0
45508: PPUSH
45509: PPUSH
45510: PPUSH
45511: PPUSH
45512: PPUSH
45513: PPUSH
// if not mc_bases then
45514: LD_EXP 101
45518: NOT
45519: IFFALSE 45523
// exit ;
45521: GO 45950
// for i = 1 to mc_bases do
45523: LD_ADDR_VAR 0 2
45527: PUSH
45528: DOUBLE
45529: LD_INT 1
45531: DEC
45532: ST_TO_ADDR
45533: LD_EXP 101
45537: PUSH
45538: FOR_TO
45539: IFFALSE 45948
// begin tmp := mc_build_upgrade [ i ] ;
45541: LD_ADDR_VAR 0 4
45545: PUSH
45546: LD_EXP 133
45550: PUSH
45551: LD_VAR 0 2
45555: ARRAY
45556: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45557: LD_ADDR_VAR 0 6
45561: PUSH
45562: LD_EXP 134
45566: PUSH
45567: LD_VAR 0 2
45571: ARRAY
45572: PPUSH
45573: LD_INT 2
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 6
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 30
45588: PUSH
45589: LD_INT 7
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: LIST
45600: PPUSH
45601: CALL_OW 72
45605: ST_TO_ADDR
// if not tmp and not lab then
45606: LD_VAR 0 4
45610: NOT
45611: PUSH
45612: LD_VAR 0 6
45616: NOT
45617: AND
45618: IFFALSE 45622
// continue ;
45620: GO 45538
// if tmp then
45622: LD_VAR 0 4
45626: IFFALSE 45746
// for j in tmp do
45628: LD_ADDR_VAR 0 3
45632: PUSH
45633: LD_VAR 0 4
45637: PUSH
45638: FOR_IN
45639: IFFALSE 45744
// begin if UpgradeCost ( j ) then
45641: LD_VAR 0 3
45645: PPUSH
45646: CALL 78013 0 1
45650: IFFALSE 45742
// begin ComUpgrade ( j ) ;
45652: LD_VAR 0 3
45656: PPUSH
45657: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45661: LD_ADDR_EXP 133
45665: PUSH
45666: LD_EXP 133
45670: PPUSH
45671: LD_VAR 0 2
45675: PPUSH
45676: LD_EXP 133
45680: PUSH
45681: LD_VAR 0 2
45685: ARRAY
45686: PUSH
45687: LD_VAR 0 3
45691: DIFF
45692: PPUSH
45693: CALL_OW 1
45697: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45698: LD_ADDR_EXP 108
45702: PUSH
45703: LD_EXP 108
45707: PPUSH
45708: LD_VAR 0 2
45712: PUSH
45713: LD_EXP 108
45717: PUSH
45718: LD_VAR 0 2
45722: ARRAY
45723: PUSH
45724: LD_INT 1
45726: PLUS
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PPUSH
45732: LD_VAR 0 3
45736: PPUSH
45737: CALL 71602 0 3
45741: ST_TO_ADDR
// end ; end ;
45742: GO 45638
45744: POP
45745: POP
// if not lab or not mc_lab_upgrade [ i ] then
45746: LD_VAR 0 6
45750: NOT
45751: PUSH
45752: LD_EXP 135
45756: PUSH
45757: LD_VAR 0 2
45761: ARRAY
45762: NOT
45763: OR
45764: IFFALSE 45768
// continue ;
45766: GO 45538
// for j in lab do
45768: LD_ADDR_VAR 0 3
45772: PUSH
45773: LD_VAR 0 6
45777: PUSH
45778: FOR_IN
45779: IFFALSE 45944
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45781: LD_VAR 0 3
45785: PPUSH
45786: CALL_OW 266
45790: PUSH
45791: LD_INT 6
45793: PUSH
45794: LD_INT 7
45796: PUSH
45797: EMPTY
45798: LIST
45799: LIST
45800: IN
45801: PUSH
45802: LD_VAR 0 3
45806: PPUSH
45807: CALL_OW 461
45811: PUSH
45812: LD_INT 1
45814: NONEQUAL
45815: AND
45816: IFFALSE 45942
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45818: LD_VAR 0 3
45822: PPUSH
45823: LD_EXP 135
45827: PUSH
45828: LD_VAR 0 2
45832: ARRAY
45833: PUSH
45834: LD_INT 1
45836: ARRAY
45837: PPUSH
45838: CALL 78218 0 2
45842: IFFALSE 45942
// begin ComCancel ( j ) ;
45844: LD_VAR 0 3
45848: PPUSH
45849: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45853: LD_VAR 0 3
45857: PPUSH
45858: LD_EXP 135
45862: PUSH
45863: LD_VAR 0 2
45867: ARRAY
45868: PUSH
45869: LD_INT 1
45871: ARRAY
45872: PPUSH
45873: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45877: LD_VAR 0 3
45881: PUSH
45882: LD_EXP 108
45886: PUSH
45887: LD_VAR 0 2
45891: ARRAY
45892: IN
45893: NOT
45894: IFFALSE 45940
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45896: LD_ADDR_EXP 108
45900: PUSH
45901: LD_EXP 108
45905: PPUSH
45906: LD_VAR 0 2
45910: PUSH
45911: LD_EXP 108
45915: PUSH
45916: LD_VAR 0 2
45920: ARRAY
45921: PUSH
45922: LD_INT 1
45924: PLUS
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PPUSH
45930: LD_VAR 0 3
45934: PPUSH
45935: CALL 71602 0 3
45939: ST_TO_ADDR
// break ;
45940: GO 45944
// end ; end ; end ;
45942: GO 45778
45944: POP
45945: POP
// end ;
45946: GO 45538
45948: POP
45949: POP
// end ;
45950: LD_VAR 0 1
45954: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45955: LD_INT 0
45957: PPUSH
45958: PPUSH
45959: PPUSH
45960: PPUSH
45961: PPUSH
45962: PPUSH
45963: PPUSH
45964: PPUSH
45965: PPUSH
// if not mc_bases then
45966: LD_EXP 101
45970: NOT
45971: IFFALSE 45975
// exit ;
45973: GO 46380
// for i = 1 to mc_bases do
45975: LD_ADDR_VAR 0 2
45979: PUSH
45980: DOUBLE
45981: LD_INT 1
45983: DEC
45984: ST_TO_ADDR
45985: LD_EXP 101
45989: PUSH
45990: FOR_TO
45991: IFFALSE 46378
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45993: LD_EXP 109
45997: PUSH
45998: LD_VAR 0 2
46002: ARRAY
46003: NOT
46004: PUSH
46005: LD_EXP 101
46009: PUSH
46010: LD_VAR 0 2
46014: ARRAY
46015: PPUSH
46016: LD_INT 30
46018: PUSH
46019: LD_INT 3
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PPUSH
46026: CALL_OW 72
46030: NOT
46031: OR
46032: IFFALSE 46036
// continue ;
46034: GO 45990
// busy := false ;
46036: LD_ADDR_VAR 0 8
46040: PUSH
46041: LD_INT 0
46043: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46044: LD_ADDR_VAR 0 4
46048: PUSH
46049: LD_EXP 101
46053: PUSH
46054: LD_VAR 0 2
46058: ARRAY
46059: PPUSH
46060: LD_INT 30
46062: PUSH
46063: LD_INT 3
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PPUSH
46070: CALL_OW 72
46074: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46075: LD_ADDR_VAR 0 6
46079: PUSH
46080: LD_EXP 109
46084: PUSH
46085: LD_VAR 0 2
46089: ARRAY
46090: PPUSH
46091: LD_INT 2
46093: PUSH
46094: LD_INT 30
46096: PUSH
46097: LD_INT 32
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 30
46106: PUSH
46107: LD_INT 33
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: LIST
46118: PPUSH
46119: CALL_OW 72
46123: ST_TO_ADDR
// if not t then
46124: LD_VAR 0 6
46128: NOT
46129: IFFALSE 46133
// continue ;
46131: GO 45990
// for j in tmp do
46133: LD_ADDR_VAR 0 3
46137: PUSH
46138: LD_VAR 0 4
46142: PUSH
46143: FOR_IN
46144: IFFALSE 46174
// if not BuildingStatus ( j ) = bs_idle then
46146: LD_VAR 0 3
46150: PPUSH
46151: CALL_OW 461
46155: PUSH
46156: LD_INT 2
46158: EQUAL
46159: NOT
46160: IFFALSE 46172
// begin busy := true ;
46162: LD_ADDR_VAR 0 8
46166: PUSH
46167: LD_INT 1
46169: ST_TO_ADDR
// break ;
46170: GO 46174
// end ;
46172: GO 46143
46174: POP
46175: POP
// if busy then
46176: LD_VAR 0 8
46180: IFFALSE 46184
// continue ;
46182: GO 45990
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46184: LD_ADDR_VAR 0 7
46188: PUSH
46189: LD_VAR 0 6
46193: PPUSH
46194: LD_INT 35
46196: PUSH
46197: LD_INT 0
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: PPUSH
46204: CALL_OW 72
46208: ST_TO_ADDR
// if tw then
46209: LD_VAR 0 7
46213: IFFALSE 46290
// begin tw := tw [ 1 ] ;
46215: LD_ADDR_VAR 0 7
46219: PUSH
46220: LD_VAR 0 7
46224: PUSH
46225: LD_INT 1
46227: ARRAY
46228: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46229: LD_ADDR_VAR 0 9
46233: PUSH
46234: LD_VAR 0 7
46238: PPUSH
46239: LD_EXP 126
46243: PUSH
46244: LD_VAR 0 2
46248: ARRAY
46249: PPUSH
46250: CALL 76572 0 2
46254: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
46255: LD_EXP 140
46259: PUSH
46260: LD_VAR 0 2
46264: ARRAY
46265: IFFALSE 46288
// if not weapon in mc_allowed_tower_weapons [ i ] then
46267: LD_VAR 0 9
46271: PUSH
46272: LD_EXP 140
46276: PUSH
46277: LD_VAR 0 2
46281: ARRAY
46282: IN
46283: NOT
46284: IFFALSE 46288
// continue ;
46286: GO 45990
// end else
46288: GO 46353
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
46290: LD_ADDR_VAR 0 5
46294: PUSH
46295: LD_EXP 109
46299: PUSH
46300: LD_VAR 0 2
46304: ARRAY
46305: PPUSH
46306: LD_VAR 0 4
46310: PPUSH
46311: CALL 106773 0 2
46315: ST_TO_ADDR
// if not tmp2 then
46316: LD_VAR 0 5
46320: NOT
46321: IFFALSE 46325
// continue ;
46323: GO 45990
// tw := tmp2 [ 1 ] ;
46325: LD_ADDR_VAR 0 7
46329: PUSH
46330: LD_VAR 0 5
46334: PUSH
46335: LD_INT 1
46337: ARRAY
46338: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46339: LD_ADDR_VAR 0 9
46343: PUSH
46344: LD_VAR 0 5
46348: PUSH
46349: LD_INT 2
46351: ARRAY
46352: ST_TO_ADDR
// end ; if not weapon then
46353: LD_VAR 0 9
46357: NOT
46358: IFFALSE 46362
// continue ;
46360: GO 45990
// ComPlaceWeapon ( tw , weapon ) ;
46362: LD_VAR 0 7
46366: PPUSH
46367: LD_VAR 0 9
46371: PPUSH
46372: CALL_OW 148
// end ;
46376: GO 45990
46378: POP
46379: POP
// end ;
46380: LD_VAR 0 1
46384: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46385: LD_INT 0
46387: PPUSH
46388: PPUSH
46389: PPUSH
46390: PPUSH
46391: PPUSH
46392: PPUSH
// if not mc_bases then
46393: LD_EXP 101
46397: NOT
46398: IFFALSE 46402
// exit ;
46400: GO 47414
// for i = 1 to mc_bases do
46402: LD_ADDR_VAR 0 2
46406: PUSH
46407: DOUBLE
46408: LD_INT 1
46410: DEC
46411: ST_TO_ADDR
46412: LD_EXP 101
46416: PUSH
46417: FOR_TO
46418: IFFALSE 47412
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46420: LD_EXP 114
46424: PUSH
46425: LD_VAR 0 2
46429: ARRAY
46430: NOT
46431: PUSH
46432: LD_EXP 114
46436: PUSH
46437: LD_VAR 0 2
46441: ARRAY
46442: PUSH
46443: LD_EXP 115
46447: PUSH
46448: LD_VAR 0 2
46452: ARRAY
46453: EQUAL
46454: OR
46455: IFFALSE 46459
// continue ;
46457: GO 46417
// if mc_miners [ i ] then
46459: LD_EXP 115
46463: PUSH
46464: LD_VAR 0 2
46468: ARRAY
46469: IFFALSE 47099
// begin k := 1 ;
46471: LD_ADDR_VAR 0 4
46475: PUSH
46476: LD_INT 1
46478: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46479: LD_ADDR_VAR 0 3
46483: PUSH
46484: DOUBLE
46485: LD_EXP 115
46489: PUSH
46490: LD_VAR 0 2
46494: ARRAY
46495: INC
46496: ST_TO_ADDR
46497: LD_INT 1
46499: PUSH
46500: FOR_DOWNTO
46501: IFFALSE 47097
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46503: LD_EXP 115
46507: PUSH
46508: LD_VAR 0 2
46512: ARRAY
46513: PUSH
46514: LD_VAR 0 3
46518: ARRAY
46519: PPUSH
46520: CALL_OW 301
46524: PUSH
46525: LD_EXP 115
46529: PUSH
46530: LD_VAR 0 2
46534: ARRAY
46535: PUSH
46536: LD_VAR 0 3
46540: ARRAY
46541: PPUSH
46542: CALL_OW 257
46546: PUSH
46547: LD_INT 1
46549: NONEQUAL
46550: OR
46551: IFFALSE 46614
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46553: LD_ADDR_VAR 0 5
46557: PUSH
46558: LD_EXP 115
46562: PUSH
46563: LD_VAR 0 2
46567: ARRAY
46568: PUSH
46569: LD_EXP 115
46573: PUSH
46574: LD_VAR 0 2
46578: ARRAY
46579: PUSH
46580: LD_VAR 0 3
46584: ARRAY
46585: DIFF
46586: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46587: LD_ADDR_EXP 115
46591: PUSH
46592: LD_EXP 115
46596: PPUSH
46597: LD_VAR 0 2
46601: PPUSH
46602: LD_VAR 0 5
46606: PPUSH
46607: CALL_OW 1
46611: ST_TO_ADDR
// continue ;
46612: GO 46500
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46614: LD_EXP 115
46618: PUSH
46619: LD_VAR 0 2
46623: ARRAY
46624: PUSH
46625: LD_VAR 0 3
46629: ARRAY
46630: PPUSH
46631: CALL 71538 0 1
46635: PUSH
46636: LD_EXP 115
46640: PUSH
46641: LD_VAR 0 2
46645: ARRAY
46646: PUSH
46647: LD_VAR 0 3
46651: ARRAY
46652: PPUSH
46653: CALL_OW 255
46657: PPUSH
46658: LD_EXP 114
46662: PUSH
46663: LD_VAR 0 2
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 4
46673: ARRAY
46674: PUSH
46675: LD_INT 1
46677: ARRAY
46678: PPUSH
46679: LD_EXP 114
46683: PUSH
46684: LD_VAR 0 2
46688: ARRAY
46689: PUSH
46690: LD_VAR 0 4
46694: ARRAY
46695: PUSH
46696: LD_INT 2
46698: ARRAY
46699: PPUSH
46700: LD_INT 15
46702: PPUSH
46703: CALL 72498 0 4
46707: PUSH
46708: LD_INT 4
46710: ARRAY
46711: PUSH
46712: LD_EXP 115
46716: PUSH
46717: LD_VAR 0 2
46721: ARRAY
46722: PUSH
46723: LD_VAR 0 3
46727: ARRAY
46728: PPUSH
46729: LD_INT 10
46731: PPUSH
46732: CALL 74195 0 2
46736: PUSH
46737: LD_INT 4
46739: ARRAY
46740: OR
46741: AND
46742: IFFALSE 46765
// ComStop ( mc_miners [ i ] [ j ] ) ;
46744: LD_EXP 115
46748: PUSH
46749: LD_VAR 0 2
46753: ARRAY
46754: PUSH
46755: LD_VAR 0 3
46759: ARRAY
46760: PPUSH
46761: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46765: LD_EXP 115
46769: PUSH
46770: LD_VAR 0 2
46774: ARRAY
46775: PUSH
46776: LD_VAR 0 3
46780: ARRAY
46781: PPUSH
46782: CALL_OW 257
46786: PUSH
46787: LD_INT 1
46789: EQUAL
46790: PUSH
46791: LD_EXP 115
46795: PUSH
46796: LD_VAR 0 2
46800: ARRAY
46801: PUSH
46802: LD_VAR 0 3
46806: ARRAY
46807: PPUSH
46808: CALL_OW 459
46812: NOT
46813: AND
46814: PUSH
46815: LD_EXP 115
46819: PUSH
46820: LD_VAR 0 2
46824: ARRAY
46825: PUSH
46826: LD_VAR 0 3
46830: ARRAY
46831: PPUSH
46832: CALL_OW 255
46836: PPUSH
46837: LD_EXP 114
46841: PUSH
46842: LD_VAR 0 2
46846: ARRAY
46847: PUSH
46848: LD_VAR 0 4
46852: ARRAY
46853: PUSH
46854: LD_INT 1
46856: ARRAY
46857: PPUSH
46858: LD_EXP 114
46862: PUSH
46863: LD_VAR 0 2
46867: ARRAY
46868: PUSH
46869: LD_VAR 0 4
46873: ARRAY
46874: PUSH
46875: LD_INT 2
46877: ARRAY
46878: PPUSH
46879: LD_INT 15
46881: PPUSH
46882: CALL 72498 0 4
46886: PUSH
46887: LD_INT 4
46889: ARRAY
46890: PUSH
46891: LD_INT 0
46893: EQUAL
46894: AND
46895: PUSH
46896: LD_EXP 115
46900: PUSH
46901: LD_VAR 0 2
46905: ARRAY
46906: PUSH
46907: LD_VAR 0 3
46911: ARRAY
46912: PPUSH
46913: CALL_OW 314
46917: NOT
46918: AND
46919: IFFALSE 47095
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46921: LD_EXP 115
46925: PUSH
46926: LD_VAR 0 2
46930: ARRAY
46931: PUSH
46932: LD_VAR 0 3
46936: ARRAY
46937: PPUSH
46938: CALL_OW 310
46942: IFFALSE 46965
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46944: LD_EXP 115
46948: PUSH
46949: LD_VAR 0 2
46953: ARRAY
46954: PUSH
46955: LD_VAR 0 3
46959: ARRAY
46960: PPUSH
46961: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46965: LD_EXP 115
46969: PUSH
46970: LD_VAR 0 2
46974: ARRAY
46975: PUSH
46976: LD_VAR 0 3
46980: ARRAY
46981: PPUSH
46982: CALL_OW 314
46986: NOT
46987: IFFALSE 47055
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46989: LD_EXP 115
46993: PUSH
46994: LD_VAR 0 2
46998: ARRAY
46999: PUSH
47000: LD_VAR 0 3
47004: ARRAY
47005: PPUSH
47006: LD_EXP 114
47010: PUSH
47011: LD_VAR 0 2
47015: ARRAY
47016: PUSH
47017: LD_VAR 0 4
47021: ARRAY
47022: PUSH
47023: LD_INT 1
47025: ARRAY
47026: PPUSH
47027: LD_EXP 114
47031: PUSH
47032: LD_VAR 0 2
47036: ARRAY
47037: PUSH
47038: LD_VAR 0 4
47042: ARRAY
47043: PUSH
47044: LD_INT 2
47046: ARRAY
47047: PPUSH
47048: LD_INT 0
47050: PPUSH
47051: CALL_OW 193
// k := k + 1 ;
47055: LD_ADDR_VAR 0 4
47059: PUSH
47060: LD_VAR 0 4
47064: PUSH
47065: LD_INT 1
47067: PLUS
47068: ST_TO_ADDR
// if k > mc_mines [ i ] then
47069: LD_VAR 0 4
47073: PUSH
47074: LD_EXP 114
47078: PUSH
47079: LD_VAR 0 2
47083: ARRAY
47084: GREATER
47085: IFFALSE 47095
// k := 1 ;
47087: LD_ADDR_VAR 0 4
47091: PUSH
47092: LD_INT 1
47094: ST_TO_ADDR
// end ; end ;
47095: GO 46500
47097: POP
47098: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47099: LD_ADDR_VAR 0 5
47103: PUSH
47104: LD_EXP 101
47108: PUSH
47109: LD_VAR 0 2
47113: ARRAY
47114: PPUSH
47115: LD_INT 2
47117: PUSH
47118: LD_INT 30
47120: PUSH
47121: LD_INT 4
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 30
47130: PUSH
47131: LD_INT 5
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 30
47140: PUSH
47141: LD_INT 32
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: PPUSH
47154: CALL_OW 72
47158: ST_TO_ADDR
// if not tmp then
47159: LD_VAR 0 5
47163: NOT
47164: IFFALSE 47168
// continue ;
47166: GO 46417
// list := [ ] ;
47168: LD_ADDR_VAR 0 6
47172: PUSH
47173: EMPTY
47174: ST_TO_ADDR
// for j in tmp do
47175: LD_ADDR_VAR 0 3
47179: PUSH
47180: LD_VAR 0 5
47184: PUSH
47185: FOR_IN
47186: IFFALSE 47255
// begin for k in UnitsInside ( j ) do
47188: LD_ADDR_VAR 0 4
47192: PUSH
47193: LD_VAR 0 3
47197: PPUSH
47198: CALL_OW 313
47202: PUSH
47203: FOR_IN
47204: IFFALSE 47251
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47206: LD_VAR 0 4
47210: PPUSH
47211: CALL_OW 257
47215: PUSH
47216: LD_INT 1
47218: EQUAL
47219: PUSH
47220: LD_VAR 0 4
47224: PPUSH
47225: CALL_OW 459
47229: NOT
47230: AND
47231: IFFALSE 47249
// list := list ^ k ;
47233: LD_ADDR_VAR 0 6
47237: PUSH
47238: LD_VAR 0 6
47242: PUSH
47243: LD_VAR 0 4
47247: ADD
47248: ST_TO_ADDR
47249: GO 47203
47251: POP
47252: POP
// end ;
47253: GO 47185
47255: POP
47256: POP
// list := list diff mc_miners [ i ] ;
47257: LD_ADDR_VAR 0 6
47261: PUSH
47262: LD_VAR 0 6
47266: PUSH
47267: LD_EXP 115
47271: PUSH
47272: LD_VAR 0 2
47276: ARRAY
47277: DIFF
47278: ST_TO_ADDR
// if not list then
47279: LD_VAR 0 6
47283: NOT
47284: IFFALSE 47288
// continue ;
47286: GO 46417
// k := mc_mines [ i ] - mc_miners [ i ] ;
47288: LD_ADDR_VAR 0 4
47292: PUSH
47293: LD_EXP 114
47297: PUSH
47298: LD_VAR 0 2
47302: ARRAY
47303: PUSH
47304: LD_EXP 115
47308: PUSH
47309: LD_VAR 0 2
47313: ARRAY
47314: MINUS
47315: ST_TO_ADDR
// if k > list then
47316: LD_VAR 0 4
47320: PUSH
47321: LD_VAR 0 6
47325: GREATER
47326: IFFALSE 47338
// k := list ;
47328: LD_ADDR_VAR 0 4
47332: PUSH
47333: LD_VAR 0 6
47337: ST_TO_ADDR
// for j = 1 to k do
47338: LD_ADDR_VAR 0 3
47342: PUSH
47343: DOUBLE
47344: LD_INT 1
47346: DEC
47347: ST_TO_ADDR
47348: LD_VAR 0 4
47352: PUSH
47353: FOR_TO
47354: IFFALSE 47408
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47356: LD_ADDR_EXP 115
47360: PUSH
47361: LD_EXP 115
47365: PPUSH
47366: LD_VAR 0 2
47370: PUSH
47371: LD_EXP 115
47375: PUSH
47376: LD_VAR 0 2
47380: ARRAY
47381: PUSH
47382: LD_INT 1
47384: PLUS
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PPUSH
47390: LD_VAR 0 6
47394: PUSH
47395: LD_VAR 0 3
47399: ARRAY
47400: PPUSH
47401: CALL 71602 0 3
47405: ST_TO_ADDR
47406: GO 47353
47408: POP
47409: POP
// end ;
47410: GO 46417
47412: POP
47413: POP
// end ;
47414: LD_VAR 0 1
47418: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47419: LD_INT 0
47421: PPUSH
47422: PPUSH
47423: PPUSH
47424: PPUSH
47425: PPUSH
47426: PPUSH
47427: PPUSH
47428: PPUSH
47429: PPUSH
47430: PPUSH
// if not mc_bases then
47431: LD_EXP 101
47435: NOT
47436: IFFALSE 47440
// exit ;
47438: GO 49190
// for i = 1 to mc_bases do
47440: LD_ADDR_VAR 0 2
47444: PUSH
47445: DOUBLE
47446: LD_INT 1
47448: DEC
47449: ST_TO_ADDR
47450: LD_EXP 101
47454: PUSH
47455: FOR_TO
47456: IFFALSE 49188
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47458: LD_EXP 101
47462: PUSH
47463: LD_VAR 0 2
47467: ARRAY
47468: NOT
47469: PUSH
47470: LD_EXP 108
47474: PUSH
47475: LD_VAR 0 2
47479: ARRAY
47480: OR
47481: IFFALSE 47485
// continue ;
47483: GO 47455
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47485: LD_EXP 117
47489: PUSH
47490: LD_VAR 0 2
47494: ARRAY
47495: NOT
47496: PUSH
47497: LD_EXP 118
47501: PUSH
47502: LD_VAR 0 2
47506: ARRAY
47507: AND
47508: IFFALSE 47546
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47510: LD_ADDR_EXP 118
47514: PUSH
47515: LD_EXP 118
47519: PPUSH
47520: LD_VAR 0 2
47524: PPUSH
47525: EMPTY
47526: PPUSH
47527: CALL_OW 1
47531: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47532: LD_VAR 0 2
47536: PPUSH
47537: LD_INT 107
47539: PPUSH
47540: CALL 38300 0 2
// continue ;
47544: GO 47455
// end ; target := [ ] ;
47546: LD_ADDR_VAR 0 6
47550: PUSH
47551: EMPTY
47552: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47553: LD_ADDR_VAR 0 3
47557: PUSH
47558: DOUBLE
47559: LD_EXP 117
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: INC
47570: ST_TO_ADDR
47571: LD_INT 1
47573: PUSH
47574: FOR_DOWNTO
47575: IFFALSE 47835
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47577: LD_EXP 117
47581: PUSH
47582: LD_VAR 0 2
47586: ARRAY
47587: PUSH
47588: LD_VAR 0 3
47592: ARRAY
47593: PUSH
47594: LD_INT 2
47596: ARRAY
47597: PPUSH
47598: LD_EXP 117
47602: PUSH
47603: LD_VAR 0 2
47607: ARRAY
47608: PUSH
47609: LD_VAR 0 3
47613: ARRAY
47614: PUSH
47615: LD_INT 3
47617: ARRAY
47618: PPUSH
47619: CALL_OW 488
47623: PUSH
47624: LD_EXP 117
47628: PUSH
47629: LD_VAR 0 2
47633: ARRAY
47634: PUSH
47635: LD_VAR 0 3
47639: ARRAY
47640: PUSH
47641: LD_INT 2
47643: ARRAY
47644: PPUSH
47645: LD_EXP 117
47649: PUSH
47650: LD_VAR 0 2
47654: ARRAY
47655: PUSH
47656: LD_VAR 0 3
47660: ARRAY
47661: PUSH
47662: LD_INT 3
47664: ARRAY
47665: PPUSH
47666: CALL_OW 284
47670: PUSH
47671: LD_INT 0
47673: EQUAL
47674: AND
47675: IFFALSE 47730
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47677: LD_ADDR_VAR 0 5
47681: PUSH
47682: LD_EXP 117
47686: PUSH
47687: LD_VAR 0 2
47691: ARRAY
47692: PPUSH
47693: LD_VAR 0 3
47697: PPUSH
47698: CALL_OW 3
47702: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47703: LD_ADDR_EXP 117
47707: PUSH
47708: LD_EXP 117
47712: PPUSH
47713: LD_VAR 0 2
47717: PPUSH
47718: LD_VAR 0 5
47722: PPUSH
47723: CALL_OW 1
47727: ST_TO_ADDR
// continue ;
47728: GO 47574
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47730: LD_EXP 101
47734: PUSH
47735: LD_VAR 0 2
47739: ARRAY
47740: PUSH
47741: LD_INT 1
47743: ARRAY
47744: PPUSH
47745: CALL_OW 255
47749: PPUSH
47750: LD_EXP 117
47754: PUSH
47755: LD_VAR 0 2
47759: ARRAY
47760: PUSH
47761: LD_VAR 0 3
47765: ARRAY
47766: PUSH
47767: LD_INT 2
47769: ARRAY
47770: PPUSH
47771: LD_EXP 117
47775: PUSH
47776: LD_VAR 0 2
47780: ARRAY
47781: PUSH
47782: LD_VAR 0 3
47786: ARRAY
47787: PUSH
47788: LD_INT 3
47790: ARRAY
47791: PPUSH
47792: LD_INT 30
47794: PPUSH
47795: CALL 72498 0 4
47799: PUSH
47800: LD_INT 4
47802: ARRAY
47803: PUSH
47804: LD_INT 0
47806: EQUAL
47807: IFFALSE 47833
// begin target := mc_crates [ i ] [ j ] ;
47809: LD_ADDR_VAR 0 6
47813: PUSH
47814: LD_EXP 117
47818: PUSH
47819: LD_VAR 0 2
47823: ARRAY
47824: PUSH
47825: LD_VAR 0 3
47829: ARRAY
47830: ST_TO_ADDR
// break ;
47831: GO 47835
// end ; end ;
47833: GO 47574
47835: POP
47836: POP
// if not target then
47837: LD_VAR 0 6
47841: NOT
47842: IFFALSE 47846
// continue ;
47844: GO 47455
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47846: LD_ADDR_VAR 0 7
47850: PUSH
47851: LD_EXP 120
47855: PUSH
47856: LD_VAR 0 2
47860: ARRAY
47861: PPUSH
47862: LD_INT 2
47864: PUSH
47865: LD_INT 3
47867: PUSH
47868: LD_INT 58
47870: PUSH
47871: EMPTY
47872: LIST
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_INT 61
47880: PUSH
47881: EMPTY
47882: LIST
47883: PUSH
47884: LD_INT 33
47886: PUSH
47887: LD_INT 5
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: LD_INT 33
47896: PUSH
47897: LD_INT 3
47899: PUSH
47900: EMPTY
47901: LIST
47902: LIST
47903: PUSH
47904: EMPTY
47905: LIST
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: PUSH
47911: LD_INT 2
47913: PUSH
47914: LD_INT 34
47916: PUSH
47917: LD_INT 32
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 34
47926: PUSH
47927: LD_INT 51
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_INT 34
47936: PUSH
47937: LD_INT 12
47939: PUSH
47940: EMPTY
47941: LIST
47942: LIST
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: PUSH
47950: EMPTY
47951: LIST
47952: LIST
47953: PPUSH
47954: CALL_OW 72
47958: ST_TO_ADDR
// if not cargo then
47959: LD_VAR 0 7
47963: NOT
47964: IFFALSE 48607
// begin if mc_crates_collector [ i ] < 5 then
47966: LD_EXP 118
47970: PUSH
47971: LD_VAR 0 2
47975: ARRAY
47976: PUSH
47977: LD_INT 5
47979: LESS
47980: IFFALSE 48346
// begin if mc_ape [ i ] then
47982: LD_EXP 130
47986: PUSH
47987: LD_VAR 0 2
47991: ARRAY
47992: IFFALSE 48039
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47994: LD_ADDR_VAR 0 5
47998: PUSH
47999: LD_EXP 130
48003: PUSH
48004: LD_VAR 0 2
48008: ARRAY
48009: PPUSH
48010: LD_INT 25
48012: PUSH
48013: LD_INT 16
48015: PUSH
48016: EMPTY
48017: LIST
48018: LIST
48019: PUSH
48020: LD_INT 24
48022: PUSH
48023: LD_INT 750
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: EMPTY
48031: LIST
48032: LIST
48033: PPUSH
48034: CALL_OW 72
48038: ST_TO_ADDR
// if not tmp then
48039: LD_VAR 0 5
48043: NOT
48044: IFFALSE 48091
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48046: LD_ADDR_VAR 0 5
48050: PUSH
48051: LD_EXP 101
48055: PUSH
48056: LD_VAR 0 2
48060: ARRAY
48061: PPUSH
48062: LD_INT 25
48064: PUSH
48065: LD_INT 2
48067: PUSH
48068: EMPTY
48069: LIST
48070: LIST
48071: PUSH
48072: LD_INT 24
48074: PUSH
48075: LD_INT 750
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PPUSH
48086: CALL_OW 72
48090: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48091: LD_EXP 130
48095: PUSH
48096: LD_VAR 0 2
48100: ARRAY
48101: PUSH
48102: LD_EXP 101
48106: PUSH
48107: LD_VAR 0 2
48111: ARRAY
48112: PPUSH
48113: LD_INT 25
48115: PUSH
48116: LD_INT 2
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 24
48125: PUSH
48126: LD_INT 750
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PPUSH
48137: CALL_OW 72
48141: AND
48142: PUSH
48143: LD_VAR 0 5
48147: PUSH
48148: LD_INT 5
48150: LESS
48151: AND
48152: IFFALSE 48234
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48154: LD_ADDR_VAR 0 3
48158: PUSH
48159: LD_EXP 101
48163: PUSH
48164: LD_VAR 0 2
48168: ARRAY
48169: PPUSH
48170: LD_INT 25
48172: PUSH
48173: LD_INT 2
48175: PUSH
48176: EMPTY
48177: LIST
48178: LIST
48179: PUSH
48180: LD_INT 24
48182: PUSH
48183: LD_INT 750
48185: PUSH
48186: EMPTY
48187: LIST
48188: LIST
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PPUSH
48194: CALL_OW 72
48198: PUSH
48199: FOR_IN
48200: IFFALSE 48232
// begin tmp := tmp union j ;
48202: LD_ADDR_VAR 0 5
48206: PUSH
48207: LD_VAR 0 5
48211: PUSH
48212: LD_VAR 0 3
48216: UNION
48217: ST_TO_ADDR
// if tmp >= 5 then
48218: LD_VAR 0 5
48222: PUSH
48223: LD_INT 5
48225: GREATEREQUAL
48226: IFFALSE 48230
// break ;
48228: GO 48232
// end ;
48230: GO 48199
48232: POP
48233: POP
// end ; if not tmp then
48234: LD_VAR 0 5
48238: NOT
48239: IFFALSE 48243
// continue ;
48241: GO 47455
// for j in tmp do
48243: LD_ADDR_VAR 0 3
48247: PUSH
48248: LD_VAR 0 5
48252: PUSH
48253: FOR_IN
48254: IFFALSE 48344
// if not GetTag ( j ) then
48256: LD_VAR 0 3
48260: PPUSH
48261: CALL_OW 110
48265: NOT
48266: IFFALSE 48342
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48268: LD_ADDR_EXP 118
48272: PUSH
48273: LD_EXP 118
48277: PPUSH
48278: LD_VAR 0 2
48282: PUSH
48283: LD_EXP 118
48287: PUSH
48288: LD_VAR 0 2
48292: ARRAY
48293: PUSH
48294: LD_INT 1
48296: PLUS
48297: PUSH
48298: EMPTY
48299: LIST
48300: LIST
48301: PPUSH
48302: LD_VAR 0 3
48306: PPUSH
48307: CALL 71602 0 3
48311: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48312: LD_VAR 0 3
48316: PPUSH
48317: LD_INT 107
48319: PPUSH
48320: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48324: LD_EXP 118
48328: PUSH
48329: LD_VAR 0 2
48333: ARRAY
48334: PUSH
48335: LD_INT 5
48337: GREATEREQUAL
48338: IFFALSE 48342
// break ;
48340: GO 48344
// end ;
48342: GO 48253
48344: POP
48345: POP
// end ; if mc_crates_collector [ i ] and target then
48346: LD_EXP 118
48350: PUSH
48351: LD_VAR 0 2
48355: ARRAY
48356: PUSH
48357: LD_VAR 0 6
48361: AND
48362: IFFALSE 48605
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48364: LD_EXP 118
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: PUSH
48375: LD_VAR 0 6
48379: PUSH
48380: LD_INT 1
48382: ARRAY
48383: LESS
48384: IFFALSE 48404
// tmp := mc_crates_collector [ i ] else
48386: LD_ADDR_VAR 0 5
48390: PUSH
48391: LD_EXP 118
48395: PUSH
48396: LD_VAR 0 2
48400: ARRAY
48401: ST_TO_ADDR
48402: GO 48418
// tmp := target [ 1 ] ;
48404: LD_ADDR_VAR 0 5
48408: PUSH
48409: LD_VAR 0 6
48413: PUSH
48414: LD_INT 1
48416: ARRAY
48417: ST_TO_ADDR
// k := 0 ;
48418: LD_ADDR_VAR 0 4
48422: PUSH
48423: LD_INT 0
48425: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48426: LD_ADDR_VAR 0 3
48430: PUSH
48431: LD_EXP 118
48435: PUSH
48436: LD_VAR 0 2
48440: ARRAY
48441: PUSH
48442: FOR_IN
48443: IFFALSE 48603
// begin k := k + 1 ;
48445: LD_ADDR_VAR 0 4
48449: PUSH
48450: LD_VAR 0 4
48454: PUSH
48455: LD_INT 1
48457: PLUS
48458: ST_TO_ADDR
// if k > tmp then
48459: LD_VAR 0 4
48463: PUSH
48464: LD_VAR 0 5
48468: GREATER
48469: IFFALSE 48473
// break ;
48471: GO 48603
// if not GetClass ( j ) in [ 2 , 16 ] then
48473: LD_VAR 0 3
48477: PPUSH
48478: CALL_OW 257
48482: PUSH
48483: LD_INT 2
48485: PUSH
48486: LD_INT 16
48488: PUSH
48489: EMPTY
48490: LIST
48491: LIST
48492: IN
48493: NOT
48494: IFFALSE 48547
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48496: LD_ADDR_EXP 118
48500: PUSH
48501: LD_EXP 118
48505: PPUSH
48506: LD_VAR 0 2
48510: PPUSH
48511: LD_EXP 118
48515: PUSH
48516: LD_VAR 0 2
48520: ARRAY
48521: PUSH
48522: LD_VAR 0 3
48526: DIFF
48527: PPUSH
48528: CALL_OW 1
48532: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48533: LD_VAR 0 3
48537: PPUSH
48538: LD_INT 0
48540: PPUSH
48541: CALL_OW 109
// continue ;
48545: GO 48442
// end ; if IsInUnit ( j ) then
48547: LD_VAR 0 3
48551: PPUSH
48552: CALL_OW 310
48556: IFFALSE 48567
// ComExitBuilding ( j ) ;
48558: LD_VAR 0 3
48562: PPUSH
48563: CALL_OW 122
// wait ( 3 ) ;
48567: LD_INT 3
48569: PPUSH
48570: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48574: LD_VAR 0 3
48578: PPUSH
48579: LD_VAR 0 6
48583: PUSH
48584: LD_INT 2
48586: ARRAY
48587: PPUSH
48588: LD_VAR 0 6
48592: PUSH
48593: LD_INT 3
48595: ARRAY
48596: PPUSH
48597: CALL_OW 117
// end ;
48601: GO 48442
48603: POP
48604: POP
// end ; end else
48605: GO 49186
// begin for j in cargo do
48607: LD_ADDR_VAR 0 3
48611: PUSH
48612: LD_VAR 0 7
48616: PUSH
48617: FOR_IN
48618: IFFALSE 49184
// begin if GetTag ( j ) <> 0 then
48620: LD_VAR 0 3
48624: PPUSH
48625: CALL_OW 110
48629: PUSH
48630: LD_INT 0
48632: NONEQUAL
48633: IFFALSE 48637
// continue ;
48635: GO 48617
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48637: LD_VAR 0 3
48641: PPUSH
48642: CALL_OW 256
48646: PUSH
48647: LD_INT 1000
48649: LESS
48650: PUSH
48651: LD_VAR 0 3
48655: PPUSH
48656: LD_EXP 125
48660: PUSH
48661: LD_VAR 0 2
48665: ARRAY
48666: PPUSH
48667: CALL_OW 308
48671: NOT
48672: AND
48673: IFFALSE 48695
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48675: LD_VAR 0 3
48679: PPUSH
48680: LD_EXP 125
48684: PUSH
48685: LD_VAR 0 2
48689: ARRAY
48690: PPUSH
48691: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48695: LD_VAR 0 3
48699: PPUSH
48700: CALL_OW 256
48704: PUSH
48705: LD_INT 1000
48707: LESS
48708: PUSH
48709: LD_VAR 0 3
48713: PPUSH
48714: LD_EXP 125
48718: PUSH
48719: LD_VAR 0 2
48723: ARRAY
48724: PPUSH
48725: CALL_OW 308
48729: AND
48730: IFFALSE 48734
// continue ;
48732: GO 48617
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48734: LD_VAR 0 3
48738: PPUSH
48739: CALL_OW 262
48743: PUSH
48744: LD_INT 2
48746: EQUAL
48747: PUSH
48748: LD_VAR 0 3
48752: PPUSH
48753: CALL_OW 261
48757: PUSH
48758: LD_INT 15
48760: LESS
48761: AND
48762: IFFALSE 48766
// continue ;
48764: GO 48617
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48766: LD_VAR 0 3
48770: PPUSH
48771: CALL_OW 262
48775: PUSH
48776: LD_INT 1
48778: EQUAL
48779: PUSH
48780: LD_VAR 0 3
48784: PPUSH
48785: CALL_OW 261
48789: PUSH
48790: LD_INT 10
48792: LESS
48793: AND
48794: IFFALSE 49123
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48796: LD_ADDR_VAR 0 8
48800: PUSH
48801: LD_EXP 101
48805: PUSH
48806: LD_VAR 0 2
48810: ARRAY
48811: PPUSH
48812: LD_INT 2
48814: PUSH
48815: LD_INT 30
48817: PUSH
48818: LD_INT 0
48820: PUSH
48821: EMPTY
48822: LIST
48823: LIST
48824: PUSH
48825: LD_INT 30
48827: PUSH
48828: LD_INT 1
48830: PUSH
48831: EMPTY
48832: LIST
48833: LIST
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: LIST
48839: PPUSH
48840: CALL_OW 72
48844: ST_TO_ADDR
// if not depot then
48845: LD_VAR 0 8
48849: NOT
48850: IFFALSE 48854
// continue ;
48852: GO 48617
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48854: LD_VAR 0 3
48858: PPUSH
48859: LD_VAR 0 8
48863: PPUSH
48864: LD_VAR 0 3
48868: PPUSH
48869: CALL_OW 74
48873: PPUSH
48874: CALL_OW 296
48878: PUSH
48879: LD_INT 6
48881: LESS
48882: IFFALSE 48898
// SetFuel ( j , 100 ) else
48884: LD_VAR 0 3
48888: PPUSH
48889: LD_INT 100
48891: PPUSH
48892: CALL_OW 240
48896: GO 49123
// if GetFuel ( j ) = 0 then
48898: LD_VAR 0 3
48902: PPUSH
48903: CALL_OW 261
48907: PUSH
48908: LD_INT 0
48910: EQUAL
48911: IFFALSE 49123
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48913: LD_ADDR_EXP 120
48917: PUSH
48918: LD_EXP 120
48922: PPUSH
48923: LD_VAR 0 2
48927: PPUSH
48928: LD_EXP 120
48932: PUSH
48933: LD_VAR 0 2
48937: ARRAY
48938: PUSH
48939: LD_VAR 0 3
48943: DIFF
48944: PPUSH
48945: CALL_OW 1
48949: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48950: LD_VAR 0 3
48954: PPUSH
48955: CALL_OW 263
48959: PUSH
48960: LD_INT 1
48962: EQUAL
48963: IFFALSE 48979
// ComExitVehicle ( IsInUnit ( j ) ) ;
48965: LD_VAR 0 3
48969: PPUSH
48970: CALL_OW 310
48974: PPUSH
48975: CALL_OW 121
// if GetControl ( j ) = control_remote then
48979: LD_VAR 0 3
48983: PPUSH
48984: CALL_OW 263
48988: PUSH
48989: LD_INT 2
48991: EQUAL
48992: IFFALSE 49003
// ComUnlink ( j ) ;
48994: LD_VAR 0 3
48998: PPUSH
48999: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49003: LD_ADDR_VAR 0 9
49007: PUSH
49008: LD_VAR 0 2
49012: PPUSH
49013: LD_INT 3
49015: PPUSH
49016: CALL 58476 0 2
49020: ST_TO_ADDR
// if fac then
49021: LD_VAR 0 9
49025: IFFALSE 49121
// begin for k in fac do
49027: LD_ADDR_VAR 0 4
49031: PUSH
49032: LD_VAR 0 9
49036: PUSH
49037: FOR_IN
49038: IFFALSE 49119
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49040: LD_ADDR_VAR 0 10
49044: PUSH
49045: LD_VAR 0 9
49049: PPUSH
49050: LD_VAR 0 3
49054: PPUSH
49055: CALL_OW 265
49059: PPUSH
49060: LD_VAR 0 3
49064: PPUSH
49065: CALL_OW 262
49069: PPUSH
49070: LD_VAR 0 3
49074: PPUSH
49075: CALL_OW 263
49079: PPUSH
49080: LD_VAR 0 3
49084: PPUSH
49085: CALL_OW 264
49089: PPUSH
49090: CALL 69134 0 5
49094: ST_TO_ADDR
// if components then
49095: LD_VAR 0 10
49099: IFFALSE 49117
// begin MC_InsertProduceList ( i , components ) ;
49101: LD_VAR 0 2
49105: PPUSH
49106: LD_VAR 0 10
49110: PPUSH
49111: CALL 58021 0 2
// break ;
49115: GO 49119
// end ; end ;
49117: GO 49037
49119: POP
49120: POP
// end ; continue ;
49121: GO 48617
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49123: LD_VAR 0 3
49127: PPUSH
49128: LD_INT 1
49130: PPUSH
49131: CALL_OW 289
49135: PUSH
49136: LD_INT 100
49138: LESS
49139: PUSH
49140: LD_VAR 0 3
49144: PPUSH
49145: CALL_OW 314
49149: NOT
49150: AND
49151: IFFALSE 49180
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49153: LD_VAR 0 3
49157: PPUSH
49158: LD_VAR 0 6
49162: PUSH
49163: LD_INT 2
49165: ARRAY
49166: PPUSH
49167: LD_VAR 0 6
49171: PUSH
49172: LD_INT 3
49174: ARRAY
49175: PPUSH
49176: CALL_OW 117
// break ;
49180: GO 49184
// end ;
49182: GO 48617
49184: POP
49185: POP
// end ; end ;
49186: GO 47455
49188: POP
49189: POP
// end ;
49190: LD_VAR 0 1
49194: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49195: LD_INT 0
49197: PPUSH
49198: PPUSH
49199: PPUSH
49200: PPUSH
// if not mc_bases then
49201: LD_EXP 101
49205: NOT
49206: IFFALSE 49210
// exit ;
49208: GO 49371
// for i = 1 to mc_bases do
49210: LD_ADDR_VAR 0 2
49214: PUSH
49215: DOUBLE
49216: LD_INT 1
49218: DEC
49219: ST_TO_ADDR
49220: LD_EXP 101
49224: PUSH
49225: FOR_TO
49226: IFFALSE 49369
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49228: LD_ADDR_VAR 0 4
49232: PUSH
49233: LD_EXP 120
49237: PUSH
49238: LD_VAR 0 2
49242: ARRAY
49243: PUSH
49244: LD_EXP 123
49248: PUSH
49249: LD_VAR 0 2
49253: ARRAY
49254: UNION
49255: PPUSH
49256: LD_INT 33
49258: PUSH
49259: LD_INT 2
49261: PUSH
49262: EMPTY
49263: LIST
49264: LIST
49265: PPUSH
49266: CALL_OW 72
49270: ST_TO_ADDR
// if tmp then
49271: LD_VAR 0 4
49275: IFFALSE 49367
// for j in tmp do
49277: LD_ADDR_VAR 0 3
49281: PUSH
49282: LD_VAR 0 4
49286: PUSH
49287: FOR_IN
49288: IFFALSE 49365
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49290: LD_VAR 0 3
49294: PPUSH
49295: CALL_OW 312
49299: NOT
49300: PUSH
49301: LD_VAR 0 3
49305: PPUSH
49306: CALL_OW 256
49310: PUSH
49311: LD_INT 250
49313: GREATEREQUAL
49314: AND
49315: IFFALSE 49328
// Connect ( j ) else
49317: LD_VAR 0 3
49321: PPUSH
49322: CALL 74535 0 1
49326: GO 49363
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49328: LD_VAR 0 3
49332: PPUSH
49333: CALL_OW 256
49337: PUSH
49338: LD_INT 250
49340: LESS
49341: PUSH
49342: LD_VAR 0 3
49346: PPUSH
49347: CALL_OW 312
49351: AND
49352: IFFALSE 49363
// ComUnlink ( j ) ;
49354: LD_VAR 0 3
49358: PPUSH
49359: CALL_OW 136
49363: GO 49287
49365: POP
49366: POP
// end ;
49367: GO 49225
49369: POP
49370: POP
// end ;
49371: LD_VAR 0 1
49375: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49376: LD_INT 0
49378: PPUSH
49379: PPUSH
49380: PPUSH
49381: PPUSH
49382: PPUSH
// if not mc_bases then
49383: LD_EXP 101
49387: NOT
49388: IFFALSE 49392
// exit ;
49390: GO 49837
// for i = 1 to mc_bases do
49392: LD_ADDR_VAR 0 2
49396: PUSH
49397: DOUBLE
49398: LD_INT 1
49400: DEC
49401: ST_TO_ADDR
49402: LD_EXP 101
49406: PUSH
49407: FOR_TO
49408: IFFALSE 49835
// begin if not mc_produce [ i ] then
49410: LD_EXP 122
49414: PUSH
49415: LD_VAR 0 2
49419: ARRAY
49420: NOT
49421: IFFALSE 49425
// continue ;
49423: GO 49407
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49425: LD_ADDR_VAR 0 5
49429: PUSH
49430: LD_EXP 101
49434: PUSH
49435: LD_VAR 0 2
49439: ARRAY
49440: PPUSH
49441: LD_INT 30
49443: PUSH
49444: LD_INT 3
49446: PUSH
49447: EMPTY
49448: LIST
49449: LIST
49450: PPUSH
49451: CALL_OW 72
49455: ST_TO_ADDR
// if not fac then
49456: LD_VAR 0 5
49460: NOT
49461: IFFALSE 49465
// continue ;
49463: GO 49407
// for j in fac do
49465: LD_ADDR_VAR 0 3
49469: PUSH
49470: LD_VAR 0 5
49474: PUSH
49475: FOR_IN
49476: IFFALSE 49831
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49478: LD_VAR 0 3
49482: PPUSH
49483: CALL_OW 461
49487: PUSH
49488: LD_INT 2
49490: NONEQUAL
49491: PUSH
49492: LD_VAR 0 3
49496: PPUSH
49497: LD_INT 15
49499: PPUSH
49500: CALL 74195 0 2
49504: PUSH
49505: LD_INT 4
49507: ARRAY
49508: OR
49509: IFFALSE 49513
// continue ;
49511: GO 49475
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49513: LD_VAR 0 3
49517: PPUSH
49518: LD_EXP 122
49522: PUSH
49523: LD_VAR 0 2
49527: ARRAY
49528: PUSH
49529: LD_INT 1
49531: ARRAY
49532: PUSH
49533: LD_INT 1
49535: ARRAY
49536: PPUSH
49537: LD_EXP 122
49541: PUSH
49542: LD_VAR 0 2
49546: ARRAY
49547: PUSH
49548: LD_INT 1
49550: ARRAY
49551: PUSH
49552: LD_INT 2
49554: ARRAY
49555: PPUSH
49556: LD_EXP 122
49560: PUSH
49561: LD_VAR 0 2
49565: ARRAY
49566: PUSH
49567: LD_INT 1
49569: ARRAY
49570: PUSH
49571: LD_INT 3
49573: ARRAY
49574: PPUSH
49575: LD_EXP 122
49579: PUSH
49580: LD_VAR 0 2
49584: ARRAY
49585: PUSH
49586: LD_INT 1
49588: ARRAY
49589: PUSH
49590: LD_INT 4
49592: ARRAY
49593: PPUSH
49594: CALL_OW 448
49598: PUSH
49599: LD_VAR 0 3
49603: PPUSH
49604: LD_EXP 122
49608: PUSH
49609: LD_VAR 0 2
49613: ARRAY
49614: PUSH
49615: LD_INT 1
49617: ARRAY
49618: PUSH
49619: LD_INT 1
49621: ARRAY
49622: PUSH
49623: LD_EXP 122
49627: PUSH
49628: LD_VAR 0 2
49632: ARRAY
49633: PUSH
49634: LD_INT 1
49636: ARRAY
49637: PUSH
49638: LD_INT 2
49640: ARRAY
49641: PUSH
49642: LD_EXP 122
49646: PUSH
49647: LD_VAR 0 2
49651: ARRAY
49652: PUSH
49653: LD_INT 1
49655: ARRAY
49656: PUSH
49657: LD_INT 3
49659: ARRAY
49660: PUSH
49661: LD_EXP 122
49665: PUSH
49666: LD_VAR 0 2
49670: ARRAY
49671: PUSH
49672: LD_INT 1
49674: ARRAY
49675: PUSH
49676: LD_INT 4
49678: ARRAY
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: PPUSH
49686: CALL 77866 0 2
49690: AND
49691: IFFALSE 49829
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49693: LD_VAR 0 3
49697: PPUSH
49698: LD_EXP 122
49702: PUSH
49703: LD_VAR 0 2
49707: ARRAY
49708: PUSH
49709: LD_INT 1
49711: ARRAY
49712: PUSH
49713: LD_INT 1
49715: ARRAY
49716: PPUSH
49717: LD_EXP 122
49721: PUSH
49722: LD_VAR 0 2
49726: ARRAY
49727: PUSH
49728: LD_INT 1
49730: ARRAY
49731: PUSH
49732: LD_INT 2
49734: ARRAY
49735: PPUSH
49736: LD_EXP 122
49740: PUSH
49741: LD_VAR 0 2
49745: ARRAY
49746: PUSH
49747: LD_INT 1
49749: ARRAY
49750: PUSH
49751: LD_INT 3
49753: ARRAY
49754: PPUSH
49755: LD_EXP 122
49759: PUSH
49760: LD_VAR 0 2
49764: ARRAY
49765: PUSH
49766: LD_INT 1
49768: ARRAY
49769: PUSH
49770: LD_INT 4
49772: ARRAY
49773: PPUSH
49774: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49778: LD_ADDR_VAR 0 4
49782: PUSH
49783: LD_EXP 122
49787: PUSH
49788: LD_VAR 0 2
49792: ARRAY
49793: PPUSH
49794: LD_INT 1
49796: PPUSH
49797: CALL_OW 3
49801: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49802: LD_ADDR_EXP 122
49806: PUSH
49807: LD_EXP 122
49811: PPUSH
49812: LD_VAR 0 2
49816: PPUSH
49817: LD_VAR 0 4
49821: PPUSH
49822: CALL_OW 1
49826: ST_TO_ADDR
// break ;
49827: GO 49831
// end ; end ;
49829: GO 49475
49831: POP
49832: POP
// end ;
49833: GO 49407
49835: POP
49836: POP
// end ;
49837: LD_VAR 0 1
49841: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49842: LD_INT 0
49844: PPUSH
49845: PPUSH
49846: PPUSH
// if not mc_bases then
49847: LD_EXP 101
49851: NOT
49852: IFFALSE 49856
// exit ;
49854: GO 49945
// for i = 1 to mc_bases do
49856: LD_ADDR_VAR 0 2
49860: PUSH
49861: DOUBLE
49862: LD_INT 1
49864: DEC
49865: ST_TO_ADDR
49866: LD_EXP 101
49870: PUSH
49871: FOR_TO
49872: IFFALSE 49943
// begin if mc_attack [ i ] then
49874: LD_EXP 121
49878: PUSH
49879: LD_VAR 0 2
49883: ARRAY
49884: IFFALSE 49941
// begin tmp := mc_attack [ i ] [ 1 ] ;
49886: LD_ADDR_VAR 0 3
49890: PUSH
49891: LD_EXP 121
49895: PUSH
49896: LD_VAR 0 2
49900: ARRAY
49901: PUSH
49902: LD_INT 1
49904: ARRAY
49905: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49906: LD_ADDR_EXP 121
49910: PUSH
49911: LD_EXP 121
49915: PPUSH
49916: LD_VAR 0 2
49920: PPUSH
49921: EMPTY
49922: PPUSH
49923: CALL_OW 1
49927: ST_TO_ADDR
// Attack ( tmp ) ;
49928: LD_VAR 0 3
49932: PPUSH
49933: CALL 100079 0 1
// exit ;
49937: POP
49938: POP
49939: GO 49945
// end ; end ;
49941: GO 49871
49943: POP
49944: POP
// end ;
49945: LD_VAR 0 1
49949: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49950: LD_INT 0
49952: PPUSH
49953: PPUSH
49954: PPUSH
49955: PPUSH
49956: PPUSH
49957: PPUSH
49958: PPUSH
// if not mc_bases then
49959: LD_EXP 101
49963: NOT
49964: IFFALSE 49968
// exit ;
49966: GO 50550
// for i = 1 to mc_bases do
49968: LD_ADDR_VAR 0 2
49972: PUSH
49973: DOUBLE
49974: LD_INT 1
49976: DEC
49977: ST_TO_ADDR
49978: LD_EXP 101
49982: PUSH
49983: FOR_TO
49984: IFFALSE 50548
// begin if not mc_bases [ i ] then
49986: LD_EXP 101
49990: PUSH
49991: LD_VAR 0 2
49995: ARRAY
49996: NOT
49997: IFFALSE 50001
// continue ;
49999: GO 49983
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50001: LD_ADDR_VAR 0 7
50005: PUSH
50006: LD_EXP 101
50010: PUSH
50011: LD_VAR 0 2
50015: ARRAY
50016: PUSH
50017: LD_INT 1
50019: ARRAY
50020: PPUSH
50021: CALL 68438 0 1
50025: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50026: LD_ADDR_EXP 124
50030: PUSH
50031: LD_EXP 124
50035: PPUSH
50036: LD_VAR 0 2
50040: PPUSH
50041: LD_EXP 101
50045: PUSH
50046: LD_VAR 0 2
50050: ARRAY
50051: PUSH
50052: LD_INT 1
50054: ARRAY
50055: PPUSH
50056: CALL_OW 255
50060: PPUSH
50061: LD_EXP 126
50065: PUSH
50066: LD_VAR 0 2
50070: ARRAY
50071: PPUSH
50072: CALL 65992 0 2
50076: PPUSH
50077: CALL_OW 1
50081: ST_TO_ADDR
// if not mc_scan [ i ] then
50082: LD_EXP 124
50086: PUSH
50087: LD_VAR 0 2
50091: ARRAY
50092: NOT
50093: IFFALSE 50248
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50095: LD_ADDR_VAR 0 4
50099: PUSH
50100: LD_EXP 101
50104: PUSH
50105: LD_VAR 0 2
50109: ARRAY
50110: PPUSH
50111: LD_INT 2
50113: PUSH
50114: LD_INT 25
50116: PUSH
50117: LD_INT 5
50119: PUSH
50120: EMPTY
50121: LIST
50122: LIST
50123: PUSH
50124: LD_INT 25
50126: PUSH
50127: LD_INT 8
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PUSH
50134: LD_INT 25
50136: PUSH
50137: LD_INT 9
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: LIST
50148: LIST
50149: PPUSH
50150: CALL_OW 72
50154: ST_TO_ADDR
// if not tmp then
50155: LD_VAR 0 4
50159: NOT
50160: IFFALSE 50164
// continue ;
50162: GO 49983
// for j in tmp do
50164: LD_ADDR_VAR 0 3
50168: PUSH
50169: LD_VAR 0 4
50173: PUSH
50174: FOR_IN
50175: IFFALSE 50246
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50177: LD_VAR 0 3
50181: PPUSH
50182: CALL_OW 310
50186: PPUSH
50187: CALL_OW 266
50191: PUSH
50192: LD_INT 5
50194: EQUAL
50195: PUSH
50196: LD_VAR 0 3
50200: PPUSH
50201: CALL_OW 257
50205: PUSH
50206: LD_INT 1
50208: EQUAL
50209: AND
50210: PUSH
50211: LD_VAR 0 3
50215: PPUSH
50216: CALL_OW 459
50220: NOT
50221: AND
50222: PUSH
50223: LD_VAR 0 7
50227: AND
50228: IFFALSE 50244
// ComChangeProfession ( j , class ) ;
50230: LD_VAR 0 3
50234: PPUSH
50235: LD_VAR 0 7
50239: PPUSH
50240: CALL_OW 123
50244: GO 50174
50246: POP
50247: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50248: LD_EXP 124
50252: PUSH
50253: LD_VAR 0 2
50257: ARRAY
50258: PUSH
50259: LD_EXP 123
50263: PUSH
50264: LD_VAR 0 2
50268: ARRAY
50269: NOT
50270: AND
50271: PUSH
50272: LD_EXP 101
50276: PUSH
50277: LD_VAR 0 2
50281: ARRAY
50282: PPUSH
50283: LD_INT 30
50285: PUSH
50286: LD_INT 32
50288: PUSH
50289: EMPTY
50290: LIST
50291: LIST
50292: PPUSH
50293: CALL_OW 72
50297: NOT
50298: AND
50299: PUSH
50300: LD_EXP 101
50304: PUSH
50305: LD_VAR 0 2
50309: ARRAY
50310: PPUSH
50311: LD_INT 2
50313: PUSH
50314: LD_INT 30
50316: PUSH
50317: LD_INT 4
50319: PUSH
50320: EMPTY
50321: LIST
50322: LIST
50323: PUSH
50324: LD_INT 30
50326: PUSH
50327: LD_INT 5
50329: PUSH
50330: EMPTY
50331: LIST
50332: LIST
50333: PUSH
50334: EMPTY
50335: LIST
50336: LIST
50337: LIST
50338: PPUSH
50339: CALL_OW 72
50343: NOT
50344: AND
50345: IFFALSE 50477
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50347: LD_ADDR_VAR 0 4
50351: PUSH
50352: LD_EXP 101
50356: PUSH
50357: LD_VAR 0 2
50361: ARRAY
50362: PPUSH
50363: LD_INT 2
50365: PUSH
50366: LD_INT 25
50368: PUSH
50369: LD_INT 1
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 25
50378: PUSH
50379: LD_INT 5
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: PUSH
50386: LD_INT 25
50388: PUSH
50389: LD_INT 8
50391: PUSH
50392: EMPTY
50393: LIST
50394: LIST
50395: PUSH
50396: LD_INT 25
50398: PUSH
50399: LD_INT 9
50401: PUSH
50402: EMPTY
50403: LIST
50404: LIST
50405: PUSH
50406: EMPTY
50407: LIST
50408: LIST
50409: LIST
50410: LIST
50411: LIST
50412: PPUSH
50413: CALL_OW 72
50417: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50418: LD_ADDR_VAR 0 4
50422: PUSH
50423: LD_VAR 0 4
50427: PUSH
50428: LD_VAR 0 4
50432: PPUSH
50433: LD_INT 18
50435: PPUSH
50436: CALL 104862 0 2
50440: DIFF
50441: ST_TO_ADDR
// if tmp then
50442: LD_VAR 0 4
50446: IFFALSE 50477
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50448: LD_VAR 0 2
50452: PPUSH
50453: LD_VAR 0 4
50457: PPUSH
50458: LD_EXP 126
50462: PUSH
50463: LD_VAR 0 2
50467: ARRAY
50468: PPUSH
50469: CALL 66027 0 3
// exit ;
50473: POP
50474: POP
50475: GO 50550
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50477: LD_EXP 124
50481: PUSH
50482: LD_VAR 0 2
50486: ARRAY
50487: PUSH
50488: LD_EXP 123
50492: PUSH
50493: LD_VAR 0 2
50497: ARRAY
50498: AND
50499: IFFALSE 50546
// begin tmp := mc_defender [ i ] ;
50501: LD_ADDR_VAR 0 4
50505: PUSH
50506: LD_EXP 123
50510: PUSH
50511: LD_VAR 0 2
50515: ARRAY
50516: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50517: LD_VAR 0 2
50521: PPUSH
50522: LD_VAR 0 4
50526: PPUSH
50527: LD_EXP 124
50531: PUSH
50532: LD_VAR 0 2
50536: ARRAY
50537: PPUSH
50538: CALL 66588 0 3
// exit ;
50542: POP
50543: POP
50544: GO 50550
// end ; end ;
50546: GO 49983
50548: POP
50549: POP
// end ;
50550: LD_VAR 0 1
50554: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50555: LD_INT 0
50557: PPUSH
50558: PPUSH
50559: PPUSH
50560: PPUSH
50561: PPUSH
50562: PPUSH
50563: PPUSH
50564: PPUSH
50565: PPUSH
50566: PPUSH
50567: PPUSH
// if not mc_bases then
50568: LD_EXP 101
50572: NOT
50573: IFFALSE 50577
// exit ;
50575: GO 51664
// for i = 1 to mc_bases do
50577: LD_ADDR_VAR 0 2
50581: PUSH
50582: DOUBLE
50583: LD_INT 1
50585: DEC
50586: ST_TO_ADDR
50587: LD_EXP 101
50591: PUSH
50592: FOR_TO
50593: IFFALSE 51662
// begin tmp := mc_lab [ i ] ;
50595: LD_ADDR_VAR 0 6
50599: PUSH
50600: LD_EXP 134
50604: PUSH
50605: LD_VAR 0 2
50609: ARRAY
50610: ST_TO_ADDR
// if not tmp then
50611: LD_VAR 0 6
50615: NOT
50616: IFFALSE 50620
// continue ;
50618: GO 50592
// idle_lab := 0 ;
50620: LD_ADDR_VAR 0 11
50624: PUSH
50625: LD_INT 0
50627: ST_TO_ADDR
// for j in tmp do
50628: LD_ADDR_VAR 0 3
50632: PUSH
50633: LD_VAR 0 6
50637: PUSH
50638: FOR_IN
50639: IFFALSE 51658
// begin researching := false ;
50641: LD_ADDR_VAR 0 10
50645: PUSH
50646: LD_INT 0
50648: ST_TO_ADDR
// side := GetSide ( j ) ;
50649: LD_ADDR_VAR 0 4
50653: PUSH
50654: LD_VAR 0 3
50658: PPUSH
50659: CALL_OW 255
50663: ST_TO_ADDR
// if not mc_tech [ side ] then
50664: LD_EXP 128
50668: PUSH
50669: LD_VAR 0 4
50673: ARRAY
50674: NOT
50675: IFFALSE 50679
// continue ;
50677: GO 50638
// if BuildingStatus ( j ) = bs_idle then
50679: LD_VAR 0 3
50683: PPUSH
50684: CALL_OW 461
50688: PUSH
50689: LD_INT 2
50691: EQUAL
50692: IFFALSE 50880
// begin if idle_lab and UnitsInside ( j ) < 6 then
50694: LD_VAR 0 11
50698: PUSH
50699: LD_VAR 0 3
50703: PPUSH
50704: CALL_OW 313
50708: PUSH
50709: LD_INT 6
50711: LESS
50712: AND
50713: IFFALSE 50784
// begin tmp2 := UnitsInside ( idle_lab ) ;
50715: LD_ADDR_VAR 0 9
50719: PUSH
50720: LD_VAR 0 11
50724: PPUSH
50725: CALL_OW 313
50729: ST_TO_ADDR
// if tmp2 then
50730: LD_VAR 0 9
50734: IFFALSE 50776
// for x in tmp2 do
50736: LD_ADDR_VAR 0 7
50740: PUSH
50741: LD_VAR 0 9
50745: PUSH
50746: FOR_IN
50747: IFFALSE 50774
// begin ComExitBuilding ( x ) ;
50749: LD_VAR 0 7
50753: PPUSH
50754: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50758: LD_VAR 0 7
50762: PPUSH
50763: LD_VAR 0 3
50767: PPUSH
50768: CALL_OW 180
// end ;
50772: GO 50746
50774: POP
50775: POP
// idle_lab := 0 ;
50776: LD_ADDR_VAR 0 11
50780: PUSH
50781: LD_INT 0
50783: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50784: LD_ADDR_VAR 0 5
50788: PUSH
50789: LD_EXP 128
50793: PUSH
50794: LD_VAR 0 4
50798: ARRAY
50799: PUSH
50800: FOR_IN
50801: IFFALSE 50861
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50803: LD_VAR 0 3
50807: PPUSH
50808: LD_VAR 0 5
50812: PPUSH
50813: CALL_OW 430
50817: PUSH
50818: LD_VAR 0 4
50822: PPUSH
50823: LD_VAR 0 5
50827: PPUSH
50828: CALL 65097 0 2
50832: AND
50833: IFFALSE 50859
// begin researching := true ;
50835: LD_ADDR_VAR 0 10
50839: PUSH
50840: LD_INT 1
50842: ST_TO_ADDR
// ComResearch ( j , t ) ;
50843: LD_VAR 0 3
50847: PPUSH
50848: LD_VAR 0 5
50852: PPUSH
50853: CALL_OW 124
// break ;
50857: GO 50861
// end ;
50859: GO 50800
50861: POP
50862: POP
// if not researching then
50863: LD_VAR 0 10
50867: NOT
50868: IFFALSE 50880
// idle_lab := j ;
50870: LD_ADDR_VAR 0 11
50874: PUSH
50875: LD_VAR 0 3
50879: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50880: LD_VAR 0 3
50884: PPUSH
50885: CALL_OW 461
50889: PUSH
50890: LD_INT 10
50892: EQUAL
50893: IFFALSE 51481
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50895: LD_EXP 130
50899: PUSH
50900: LD_VAR 0 2
50904: ARRAY
50905: NOT
50906: PUSH
50907: LD_EXP 131
50911: PUSH
50912: LD_VAR 0 2
50916: ARRAY
50917: NOT
50918: AND
50919: PUSH
50920: LD_EXP 128
50924: PUSH
50925: LD_VAR 0 4
50929: ARRAY
50930: PUSH
50931: LD_INT 1
50933: GREATER
50934: AND
50935: IFFALSE 51066
// begin ComCancel ( j ) ;
50937: LD_VAR 0 3
50941: PPUSH
50942: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50946: LD_ADDR_EXP 128
50950: PUSH
50951: LD_EXP 128
50955: PPUSH
50956: LD_VAR 0 4
50960: PPUSH
50961: LD_EXP 128
50965: PUSH
50966: LD_VAR 0 4
50970: ARRAY
50971: PPUSH
50972: LD_EXP 128
50976: PUSH
50977: LD_VAR 0 4
50981: ARRAY
50982: PUSH
50983: LD_INT 1
50985: MINUS
50986: PPUSH
50987: LD_EXP 128
50991: PUSH
50992: LD_VAR 0 4
50996: ARRAY
50997: PPUSH
50998: LD_INT 0
51000: PPUSH
51001: CALL 71020 0 4
51005: PPUSH
51006: CALL_OW 1
51010: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51011: LD_ADDR_EXP 128
51015: PUSH
51016: LD_EXP 128
51020: PPUSH
51021: LD_VAR 0 4
51025: PPUSH
51026: LD_EXP 128
51030: PUSH
51031: LD_VAR 0 4
51035: ARRAY
51036: PPUSH
51037: LD_EXP 128
51041: PUSH
51042: LD_VAR 0 4
51046: ARRAY
51047: PPUSH
51048: LD_INT 1
51050: PPUSH
51051: LD_INT 0
51053: PPUSH
51054: CALL 71020 0 4
51058: PPUSH
51059: CALL_OW 1
51063: ST_TO_ADDR
// continue ;
51064: GO 50638
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51066: LD_EXP 130
51070: PUSH
51071: LD_VAR 0 2
51075: ARRAY
51076: PUSH
51077: LD_EXP 131
51081: PUSH
51082: LD_VAR 0 2
51086: ARRAY
51087: NOT
51088: AND
51089: IFFALSE 51216
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51091: LD_ADDR_EXP 131
51095: PUSH
51096: LD_EXP 131
51100: PPUSH
51101: LD_VAR 0 2
51105: PUSH
51106: LD_EXP 131
51110: PUSH
51111: LD_VAR 0 2
51115: ARRAY
51116: PUSH
51117: LD_INT 1
51119: PLUS
51120: PUSH
51121: EMPTY
51122: LIST
51123: LIST
51124: PPUSH
51125: LD_EXP 130
51129: PUSH
51130: LD_VAR 0 2
51134: ARRAY
51135: PUSH
51136: LD_INT 1
51138: ARRAY
51139: PPUSH
51140: CALL 71602 0 3
51144: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51145: LD_EXP 130
51149: PUSH
51150: LD_VAR 0 2
51154: ARRAY
51155: PUSH
51156: LD_INT 1
51158: ARRAY
51159: PPUSH
51160: LD_INT 112
51162: PPUSH
51163: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51167: LD_ADDR_VAR 0 9
51171: PUSH
51172: LD_EXP 130
51176: PUSH
51177: LD_VAR 0 2
51181: ARRAY
51182: PPUSH
51183: LD_INT 1
51185: PPUSH
51186: CALL_OW 3
51190: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51191: LD_ADDR_EXP 130
51195: PUSH
51196: LD_EXP 130
51200: PPUSH
51201: LD_VAR 0 2
51205: PPUSH
51206: LD_VAR 0 9
51210: PPUSH
51211: CALL_OW 1
51215: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51216: LD_EXP 130
51220: PUSH
51221: LD_VAR 0 2
51225: ARRAY
51226: PUSH
51227: LD_EXP 131
51231: PUSH
51232: LD_VAR 0 2
51236: ARRAY
51237: AND
51238: PUSH
51239: LD_EXP 131
51243: PUSH
51244: LD_VAR 0 2
51248: ARRAY
51249: PUSH
51250: LD_INT 1
51252: ARRAY
51253: PPUSH
51254: CALL_OW 310
51258: NOT
51259: AND
51260: PUSH
51261: LD_VAR 0 3
51265: PPUSH
51266: CALL_OW 313
51270: PUSH
51271: LD_INT 6
51273: EQUAL
51274: AND
51275: IFFALSE 51331
// begin tmp2 := UnitsInside ( j ) ;
51277: LD_ADDR_VAR 0 9
51281: PUSH
51282: LD_VAR 0 3
51286: PPUSH
51287: CALL_OW 313
51291: ST_TO_ADDR
// if tmp2 = 6 then
51292: LD_VAR 0 9
51296: PUSH
51297: LD_INT 6
51299: EQUAL
51300: IFFALSE 51331
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51302: LD_VAR 0 9
51306: PUSH
51307: LD_INT 1
51309: ARRAY
51310: PPUSH
51311: LD_INT 112
51313: PPUSH
51314: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51318: LD_VAR 0 9
51322: PUSH
51323: LD_INT 1
51325: ARRAY
51326: PPUSH
51327: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51331: LD_EXP 131
51335: PUSH
51336: LD_VAR 0 2
51340: ARRAY
51341: PUSH
51342: LD_EXP 131
51346: PUSH
51347: LD_VAR 0 2
51351: ARRAY
51352: PUSH
51353: LD_INT 1
51355: ARRAY
51356: PPUSH
51357: CALL_OW 314
51361: NOT
51362: AND
51363: PUSH
51364: LD_EXP 131
51368: PUSH
51369: LD_VAR 0 2
51373: ARRAY
51374: PUSH
51375: LD_INT 1
51377: ARRAY
51378: PPUSH
51379: CALL_OW 310
51383: NOT
51384: AND
51385: IFFALSE 51411
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51387: LD_EXP 131
51391: PUSH
51392: LD_VAR 0 2
51396: ARRAY
51397: PUSH
51398: LD_INT 1
51400: ARRAY
51401: PPUSH
51402: LD_VAR 0 3
51406: PPUSH
51407: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51411: LD_EXP 131
51415: PUSH
51416: LD_VAR 0 2
51420: ARRAY
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PPUSH
51426: CALL_OW 310
51430: PUSH
51431: LD_EXP 131
51435: PUSH
51436: LD_VAR 0 2
51440: ARRAY
51441: PUSH
51442: LD_INT 1
51444: ARRAY
51445: PPUSH
51446: CALL_OW 310
51450: PPUSH
51451: CALL_OW 461
51455: PUSH
51456: LD_INT 3
51458: NONEQUAL
51459: AND
51460: IFFALSE 51481
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51462: LD_EXP 131
51466: PUSH
51467: LD_VAR 0 2
51471: ARRAY
51472: PUSH
51473: LD_INT 1
51475: ARRAY
51476: PPUSH
51477: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51481: LD_VAR 0 3
51485: PPUSH
51486: CALL_OW 461
51490: PUSH
51491: LD_INT 6
51493: EQUAL
51494: PUSH
51495: LD_VAR 0 6
51499: PUSH
51500: LD_INT 1
51502: GREATER
51503: AND
51504: IFFALSE 51656
// begin sci := [ ] ;
51506: LD_ADDR_VAR 0 8
51510: PUSH
51511: EMPTY
51512: ST_TO_ADDR
// for x in ( tmp diff j ) do
51513: LD_ADDR_VAR 0 7
51517: PUSH
51518: LD_VAR 0 6
51522: PUSH
51523: LD_VAR 0 3
51527: DIFF
51528: PUSH
51529: FOR_IN
51530: IFFALSE 51582
// begin if sci = 6 then
51532: LD_VAR 0 8
51536: PUSH
51537: LD_INT 6
51539: EQUAL
51540: IFFALSE 51544
// break ;
51542: GO 51582
// if BuildingStatus ( x ) = bs_idle then
51544: LD_VAR 0 7
51548: PPUSH
51549: CALL_OW 461
51553: PUSH
51554: LD_INT 2
51556: EQUAL
51557: IFFALSE 51580
// sci := sci ^ UnitsInside ( x ) ;
51559: LD_ADDR_VAR 0 8
51563: PUSH
51564: LD_VAR 0 8
51568: PUSH
51569: LD_VAR 0 7
51573: PPUSH
51574: CALL_OW 313
51578: ADD
51579: ST_TO_ADDR
// end ;
51580: GO 51529
51582: POP
51583: POP
// if not sci then
51584: LD_VAR 0 8
51588: NOT
51589: IFFALSE 51593
// continue ;
51591: GO 50638
// for x in sci do
51593: LD_ADDR_VAR 0 7
51597: PUSH
51598: LD_VAR 0 8
51602: PUSH
51603: FOR_IN
51604: IFFALSE 51654
// if IsInUnit ( x ) and not HasTask ( x ) then
51606: LD_VAR 0 7
51610: PPUSH
51611: CALL_OW 310
51615: PUSH
51616: LD_VAR 0 7
51620: PPUSH
51621: CALL_OW 314
51625: NOT
51626: AND
51627: IFFALSE 51652
// begin ComExitBuilding ( x ) ;
51629: LD_VAR 0 7
51633: PPUSH
51634: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51638: LD_VAR 0 7
51642: PPUSH
51643: LD_VAR 0 3
51647: PPUSH
51648: CALL_OW 180
// end ;
51652: GO 51603
51654: POP
51655: POP
// end ; end ;
51656: GO 50638
51658: POP
51659: POP
// end ;
51660: GO 50592
51662: POP
51663: POP
// end ;
51664: LD_VAR 0 1
51668: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51669: LD_INT 0
51671: PPUSH
51672: PPUSH
// if not mc_bases then
51673: LD_EXP 101
51677: NOT
51678: IFFALSE 51682
// exit ;
51680: GO 51763
// for i = 1 to mc_bases do
51682: LD_ADDR_VAR 0 2
51686: PUSH
51687: DOUBLE
51688: LD_INT 1
51690: DEC
51691: ST_TO_ADDR
51692: LD_EXP 101
51696: PUSH
51697: FOR_TO
51698: IFFALSE 51761
// if mc_mines [ i ] and mc_miners [ i ] then
51700: LD_EXP 114
51704: PUSH
51705: LD_VAR 0 2
51709: ARRAY
51710: PUSH
51711: LD_EXP 115
51715: PUSH
51716: LD_VAR 0 2
51720: ARRAY
51721: AND
51722: IFFALSE 51759
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51724: LD_EXP 115
51728: PUSH
51729: LD_VAR 0 2
51733: ARRAY
51734: PUSH
51735: LD_INT 1
51737: ARRAY
51738: PPUSH
51739: CALL_OW 255
51743: PPUSH
51744: LD_EXP 114
51748: PUSH
51749: LD_VAR 0 2
51753: ARRAY
51754: PPUSH
51755: CALL 68591 0 2
51759: GO 51697
51761: POP
51762: POP
// end ;
51763: LD_VAR 0 1
51767: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51768: LD_INT 0
51770: PPUSH
51771: PPUSH
51772: PPUSH
51773: PPUSH
51774: PPUSH
51775: PPUSH
51776: PPUSH
51777: PPUSH
// if not mc_bases or not mc_parking then
51778: LD_EXP 101
51782: NOT
51783: PUSH
51784: LD_EXP 125
51788: NOT
51789: OR
51790: IFFALSE 51794
// exit ;
51792: GO 52493
// for i = 1 to mc_bases do
51794: LD_ADDR_VAR 0 2
51798: PUSH
51799: DOUBLE
51800: LD_INT 1
51802: DEC
51803: ST_TO_ADDR
51804: LD_EXP 101
51808: PUSH
51809: FOR_TO
51810: IFFALSE 52491
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51812: LD_EXP 101
51816: PUSH
51817: LD_VAR 0 2
51821: ARRAY
51822: NOT
51823: PUSH
51824: LD_EXP 125
51828: PUSH
51829: LD_VAR 0 2
51833: ARRAY
51834: NOT
51835: OR
51836: IFFALSE 51840
// continue ;
51838: GO 51809
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51840: LD_ADDR_VAR 0 5
51844: PUSH
51845: LD_EXP 101
51849: PUSH
51850: LD_VAR 0 2
51854: ARRAY
51855: PUSH
51856: LD_INT 1
51858: ARRAY
51859: PPUSH
51860: CALL_OW 255
51864: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51865: LD_ADDR_VAR 0 6
51869: PUSH
51870: LD_EXP 101
51874: PUSH
51875: LD_VAR 0 2
51879: ARRAY
51880: PPUSH
51881: LD_INT 30
51883: PUSH
51884: LD_INT 3
51886: PUSH
51887: EMPTY
51888: LIST
51889: LIST
51890: PPUSH
51891: CALL_OW 72
51895: ST_TO_ADDR
// if not fac then
51896: LD_VAR 0 6
51900: NOT
51901: IFFALSE 51952
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51903: LD_ADDR_VAR 0 6
51907: PUSH
51908: LD_EXP 101
51912: PUSH
51913: LD_VAR 0 2
51917: ARRAY
51918: PPUSH
51919: LD_INT 2
51921: PUSH
51922: LD_INT 30
51924: PUSH
51925: LD_INT 0
51927: PUSH
51928: EMPTY
51929: LIST
51930: LIST
51931: PUSH
51932: LD_INT 30
51934: PUSH
51935: LD_INT 1
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: LIST
51946: PPUSH
51947: CALL_OW 72
51951: ST_TO_ADDR
// if not fac then
51952: LD_VAR 0 6
51956: NOT
51957: IFFALSE 51961
// continue ;
51959: GO 51809
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51961: LD_ADDR_VAR 0 7
51965: PUSH
51966: LD_EXP 125
51970: PUSH
51971: LD_VAR 0 2
51975: ARRAY
51976: PPUSH
51977: LD_INT 22
51979: PUSH
51980: LD_VAR 0 5
51984: PUSH
51985: EMPTY
51986: LIST
51987: LIST
51988: PUSH
51989: LD_INT 21
51991: PUSH
51992: LD_INT 2
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PUSH
51999: LD_INT 3
52001: PUSH
52002: LD_INT 24
52004: PUSH
52005: LD_INT 1000
52007: PUSH
52008: EMPTY
52009: LIST
52010: LIST
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: LIST
52020: PPUSH
52021: CALL_OW 70
52025: ST_TO_ADDR
// for j in fac do
52026: LD_ADDR_VAR 0 3
52030: PUSH
52031: LD_VAR 0 6
52035: PUSH
52036: FOR_IN
52037: IFFALSE 52118
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52039: LD_ADDR_VAR 0 7
52043: PUSH
52044: LD_VAR 0 7
52048: PUSH
52049: LD_INT 22
52051: PUSH
52052: LD_VAR 0 5
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: PUSH
52061: LD_INT 91
52063: PUSH
52064: LD_VAR 0 3
52068: PUSH
52069: LD_INT 15
52071: PUSH
52072: EMPTY
52073: LIST
52074: LIST
52075: LIST
52076: PUSH
52077: LD_INT 21
52079: PUSH
52080: LD_INT 2
52082: PUSH
52083: EMPTY
52084: LIST
52085: LIST
52086: PUSH
52087: LD_INT 3
52089: PUSH
52090: LD_INT 24
52092: PUSH
52093: LD_INT 1000
52095: PUSH
52096: EMPTY
52097: LIST
52098: LIST
52099: PUSH
52100: EMPTY
52101: LIST
52102: LIST
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: LIST
52108: LIST
52109: PPUSH
52110: CALL_OW 69
52114: UNION
52115: ST_TO_ADDR
52116: GO 52036
52118: POP
52119: POP
// if not vehs then
52120: LD_VAR 0 7
52124: NOT
52125: IFFALSE 52151
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52127: LD_ADDR_EXP 113
52131: PUSH
52132: LD_EXP 113
52136: PPUSH
52137: LD_VAR 0 2
52141: PPUSH
52142: EMPTY
52143: PPUSH
52144: CALL_OW 1
52148: ST_TO_ADDR
// continue ;
52149: GO 51809
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52151: LD_ADDR_VAR 0 8
52155: PUSH
52156: LD_EXP 101
52160: PUSH
52161: LD_VAR 0 2
52165: ARRAY
52166: PPUSH
52167: LD_INT 30
52169: PUSH
52170: LD_INT 3
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: PPUSH
52177: CALL_OW 72
52181: ST_TO_ADDR
// if tmp then
52182: LD_VAR 0 8
52186: IFFALSE 52289
// begin for j in tmp do
52188: LD_ADDR_VAR 0 3
52192: PUSH
52193: LD_VAR 0 8
52197: PUSH
52198: FOR_IN
52199: IFFALSE 52287
// for k in UnitsInside ( j ) do
52201: LD_ADDR_VAR 0 4
52205: PUSH
52206: LD_VAR 0 3
52210: PPUSH
52211: CALL_OW 313
52215: PUSH
52216: FOR_IN
52217: IFFALSE 52283
// if k then
52219: LD_VAR 0 4
52223: IFFALSE 52281
// if not k in mc_repair_vehicle [ i ] then
52225: LD_VAR 0 4
52229: PUSH
52230: LD_EXP 113
52234: PUSH
52235: LD_VAR 0 2
52239: ARRAY
52240: IN
52241: NOT
52242: IFFALSE 52281
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52244: LD_ADDR_EXP 113
52248: PUSH
52249: LD_EXP 113
52253: PPUSH
52254: LD_VAR 0 2
52258: PPUSH
52259: LD_EXP 113
52263: PUSH
52264: LD_VAR 0 2
52268: ARRAY
52269: PUSH
52270: LD_VAR 0 4
52274: UNION
52275: PPUSH
52276: CALL_OW 1
52280: ST_TO_ADDR
52281: GO 52216
52283: POP
52284: POP
52285: GO 52198
52287: POP
52288: POP
// end ; if not mc_repair_vehicle [ i ] then
52289: LD_EXP 113
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: NOT
52300: IFFALSE 52304
// continue ;
52302: GO 51809
// for j in mc_repair_vehicle [ i ] do
52304: LD_ADDR_VAR 0 3
52308: PUSH
52309: LD_EXP 113
52313: PUSH
52314: LD_VAR 0 2
52318: ARRAY
52319: PUSH
52320: FOR_IN
52321: IFFALSE 52487
// begin if GetClass ( j ) <> 3 then
52323: LD_VAR 0 3
52327: PPUSH
52328: CALL_OW 257
52332: PUSH
52333: LD_INT 3
52335: NONEQUAL
52336: IFFALSE 52377
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52338: LD_ADDR_EXP 113
52342: PUSH
52343: LD_EXP 113
52347: PPUSH
52348: LD_VAR 0 2
52352: PPUSH
52353: LD_EXP 113
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: PUSH
52364: LD_VAR 0 3
52368: DIFF
52369: PPUSH
52370: CALL_OW 1
52374: ST_TO_ADDR
// continue ;
52375: GO 52320
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52377: LD_VAR 0 3
52381: PPUSH
52382: CALL_OW 311
52386: NOT
52387: PUSH
52388: LD_VAR 0 3
52392: PUSH
52393: LD_EXP 104
52397: PUSH
52398: LD_VAR 0 2
52402: ARRAY
52403: PUSH
52404: LD_INT 1
52406: ARRAY
52407: IN
52408: NOT
52409: AND
52410: PUSH
52411: LD_VAR 0 3
52415: PUSH
52416: LD_EXP 104
52420: PUSH
52421: LD_VAR 0 2
52425: ARRAY
52426: PUSH
52427: LD_INT 2
52429: ARRAY
52430: IN
52431: NOT
52432: AND
52433: IFFALSE 52485
// begin if IsInUnit ( j ) then
52435: LD_VAR 0 3
52439: PPUSH
52440: CALL_OW 310
52444: IFFALSE 52455
// ComExitBuilding ( j ) ;
52446: LD_VAR 0 3
52450: PPUSH
52451: CALL_OW 122
// if not HasTask ( j ) then
52455: LD_VAR 0 3
52459: PPUSH
52460: CALL_OW 314
52464: NOT
52465: IFFALSE 52485
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52467: LD_VAR 0 3
52471: PPUSH
52472: LD_VAR 0 7
52476: PUSH
52477: LD_INT 1
52479: ARRAY
52480: PPUSH
52481: CALL_OW 189
// end ; end ;
52485: GO 52320
52487: POP
52488: POP
// end ;
52489: GO 51809
52491: POP
52492: POP
// end ;
52493: LD_VAR 0 1
52497: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52498: LD_INT 0
52500: PPUSH
52501: PPUSH
52502: PPUSH
52503: PPUSH
52504: PPUSH
52505: PPUSH
52506: PPUSH
52507: PPUSH
52508: PPUSH
52509: PPUSH
52510: PPUSH
// if not mc_bases then
52511: LD_EXP 101
52515: NOT
52516: IFFALSE 52520
// exit ;
52518: GO 53322
// for i = 1 to mc_bases do
52520: LD_ADDR_VAR 0 2
52524: PUSH
52525: DOUBLE
52526: LD_INT 1
52528: DEC
52529: ST_TO_ADDR
52530: LD_EXP 101
52534: PUSH
52535: FOR_TO
52536: IFFALSE 53320
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52538: LD_EXP 129
52542: PUSH
52543: LD_VAR 0 2
52547: ARRAY
52548: NOT
52549: PUSH
52550: LD_EXP 104
52554: PUSH
52555: LD_VAR 0 2
52559: ARRAY
52560: PUSH
52561: LD_INT 1
52563: ARRAY
52564: OR
52565: PUSH
52566: LD_EXP 104
52570: PUSH
52571: LD_VAR 0 2
52575: ARRAY
52576: PUSH
52577: LD_INT 2
52579: ARRAY
52580: OR
52581: PUSH
52582: LD_EXP 127
52586: PUSH
52587: LD_VAR 0 2
52591: ARRAY
52592: PPUSH
52593: LD_INT 1
52595: PPUSH
52596: CALL_OW 325
52600: NOT
52601: OR
52602: PUSH
52603: LD_EXP 124
52607: PUSH
52608: LD_VAR 0 2
52612: ARRAY
52613: OR
52614: IFFALSE 52618
// continue ;
52616: GO 52535
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52618: LD_ADDR_VAR 0 8
52622: PUSH
52623: LD_EXP 101
52627: PUSH
52628: LD_VAR 0 2
52632: ARRAY
52633: PPUSH
52634: LD_INT 25
52636: PUSH
52637: LD_INT 4
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: PUSH
52644: LD_INT 50
52646: PUSH
52647: EMPTY
52648: LIST
52649: PUSH
52650: LD_INT 3
52652: PUSH
52653: LD_INT 60
52655: PUSH
52656: EMPTY
52657: LIST
52658: PUSH
52659: EMPTY
52660: LIST
52661: LIST
52662: PUSH
52663: EMPTY
52664: LIST
52665: LIST
52666: LIST
52667: PPUSH
52668: CALL_OW 72
52672: PUSH
52673: LD_EXP 105
52677: PUSH
52678: LD_VAR 0 2
52682: ARRAY
52683: DIFF
52684: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52685: LD_ADDR_VAR 0 9
52689: PUSH
52690: LD_EXP 101
52694: PUSH
52695: LD_VAR 0 2
52699: ARRAY
52700: PPUSH
52701: LD_INT 2
52703: PUSH
52704: LD_INT 30
52706: PUSH
52707: LD_INT 0
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: PUSH
52714: LD_INT 30
52716: PUSH
52717: LD_INT 1
52719: PUSH
52720: EMPTY
52721: LIST
52722: LIST
52723: PUSH
52724: EMPTY
52725: LIST
52726: LIST
52727: LIST
52728: PPUSH
52729: CALL_OW 72
52733: ST_TO_ADDR
// if not tmp or not dep then
52734: LD_VAR 0 8
52738: NOT
52739: PUSH
52740: LD_VAR 0 9
52744: NOT
52745: OR
52746: IFFALSE 52750
// continue ;
52748: GO 52535
// side := GetSide ( tmp [ 1 ] ) ;
52750: LD_ADDR_VAR 0 11
52754: PUSH
52755: LD_VAR 0 8
52759: PUSH
52760: LD_INT 1
52762: ARRAY
52763: PPUSH
52764: CALL_OW 255
52768: ST_TO_ADDR
// dep := dep [ 1 ] ;
52769: LD_ADDR_VAR 0 9
52773: PUSH
52774: LD_VAR 0 9
52778: PUSH
52779: LD_INT 1
52781: ARRAY
52782: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52783: LD_ADDR_VAR 0 7
52787: PUSH
52788: LD_EXP 129
52792: PUSH
52793: LD_VAR 0 2
52797: ARRAY
52798: PPUSH
52799: LD_INT 22
52801: PUSH
52802: LD_INT 0
52804: PUSH
52805: EMPTY
52806: LIST
52807: LIST
52808: PUSH
52809: LD_INT 25
52811: PUSH
52812: LD_INT 12
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: EMPTY
52820: LIST
52821: LIST
52822: PPUSH
52823: CALL_OW 70
52827: PUSH
52828: LD_INT 22
52830: PUSH
52831: LD_INT 0
52833: PUSH
52834: EMPTY
52835: LIST
52836: LIST
52837: PUSH
52838: LD_INT 25
52840: PUSH
52841: LD_INT 12
52843: PUSH
52844: EMPTY
52845: LIST
52846: LIST
52847: PUSH
52848: LD_INT 91
52850: PUSH
52851: LD_VAR 0 9
52855: PUSH
52856: LD_INT 20
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: LIST
52863: PUSH
52864: EMPTY
52865: LIST
52866: LIST
52867: LIST
52868: PPUSH
52869: CALL_OW 69
52873: UNION
52874: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52875: LD_ADDR_VAR 0 10
52879: PUSH
52880: LD_EXP 129
52884: PUSH
52885: LD_VAR 0 2
52889: ARRAY
52890: PPUSH
52891: LD_INT 81
52893: PUSH
52894: LD_VAR 0 11
52898: PUSH
52899: EMPTY
52900: LIST
52901: LIST
52902: PPUSH
52903: CALL_OW 70
52907: ST_TO_ADDR
// if not apes or danger_at_area then
52908: LD_VAR 0 7
52912: NOT
52913: PUSH
52914: LD_VAR 0 10
52918: OR
52919: IFFALSE 52969
// begin if mc_taming [ i ] then
52921: LD_EXP 132
52925: PUSH
52926: LD_VAR 0 2
52930: ARRAY
52931: IFFALSE 52967
// begin MC_Reset ( i , 121 ) ;
52933: LD_VAR 0 2
52937: PPUSH
52938: LD_INT 121
52940: PPUSH
52941: CALL 38300 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52945: LD_ADDR_EXP 132
52949: PUSH
52950: LD_EXP 132
52954: PPUSH
52955: LD_VAR 0 2
52959: PPUSH
52960: EMPTY
52961: PPUSH
52962: CALL_OW 1
52966: ST_TO_ADDR
// end ; continue ;
52967: GO 52535
// end ; for j in tmp do
52969: LD_ADDR_VAR 0 3
52973: PUSH
52974: LD_VAR 0 8
52978: PUSH
52979: FOR_IN
52980: IFFALSE 53316
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52982: LD_VAR 0 3
52986: PUSH
52987: LD_EXP 132
52991: PUSH
52992: LD_VAR 0 2
52996: ARRAY
52997: IN
52998: NOT
52999: PUSH
53000: LD_EXP 132
53004: PUSH
53005: LD_VAR 0 2
53009: ARRAY
53010: PUSH
53011: LD_INT 3
53013: LESS
53014: AND
53015: IFFALSE 53073
// begin SetTag ( j , 121 ) ;
53017: LD_VAR 0 3
53021: PPUSH
53022: LD_INT 121
53024: PPUSH
53025: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53029: LD_ADDR_EXP 132
53033: PUSH
53034: LD_EXP 132
53038: PPUSH
53039: LD_VAR 0 2
53043: PUSH
53044: LD_EXP 132
53048: PUSH
53049: LD_VAR 0 2
53053: ARRAY
53054: PUSH
53055: LD_INT 1
53057: PLUS
53058: PUSH
53059: EMPTY
53060: LIST
53061: LIST
53062: PPUSH
53063: LD_VAR 0 3
53067: PPUSH
53068: CALL 71602 0 3
53072: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53073: LD_VAR 0 3
53077: PUSH
53078: LD_EXP 132
53082: PUSH
53083: LD_VAR 0 2
53087: ARRAY
53088: IN
53089: IFFALSE 53314
// begin if GetClass ( j ) <> 4 then
53091: LD_VAR 0 3
53095: PPUSH
53096: CALL_OW 257
53100: PUSH
53101: LD_INT 4
53103: NONEQUAL
53104: IFFALSE 53157
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53106: LD_ADDR_EXP 132
53110: PUSH
53111: LD_EXP 132
53115: PPUSH
53116: LD_VAR 0 2
53120: PPUSH
53121: LD_EXP 132
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PUSH
53132: LD_VAR 0 3
53136: DIFF
53137: PPUSH
53138: CALL_OW 1
53142: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53143: LD_VAR 0 3
53147: PPUSH
53148: LD_INT 0
53150: PPUSH
53151: CALL_OW 109
// continue ;
53155: GO 52979
// end ; if IsInUnit ( j ) then
53157: LD_VAR 0 3
53161: PPUSH
53162: CALL_OW 310
53166: IFFALSE 53177
// ComExitBuilding ( j ) ;
53168: LD_VAR 0 3
53172: PPUSH
53173: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53177: LD_ADDR_VAR 0 6
53181: PUSH
53182: LD_VAR 0 7
53186: PPUSH
53187: LD_VAR 0 3
53191: PPUSH
53192: CALL_OW 74
53196: ST_TO_ADDR
// if not ape then
53197: LD_VAR 0 6
53201: NOT
53202: IFFALSE 53206
// break ;
53204: GO 53316
// x := GetX ( ape ) ;
53206: LD_ADDR_VAR 0 4
53210: PUSH
53211: LD_VAR 0 6
53215: PPUSH
53216: CALL_OW 250
53220: ST_TO_ADDR
// y := GetY ( ape ) ;
53221: LD_ADDR_VAR 0 5
53225: PUSH
53226: LD_VAR 0 6
53230: PPUSH
53231: CALL_OW 251
53235: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53236: LD_VAR 0 4
53240: PPUSH
53241: LD_VAR 0 5
53245: PPUSH
53246: CALL_OW 488
53250: NOT
53251: PUSH
53252: LD_VAR 0 11
53256: PPUSH
53257: LD_VAR 0 4
53261: PPUSH
53262: LD_VAR 0 5
53266: PPUSH
53267: LD_INT 20
53269: PPUSH
53270: CALL 72498 0 4
53274: PUSH
53275: LD_INT 4
53277: ARRAY
53278: OR
53279: IFFALSE 53283
// break ;
53281: GO 53316
// if not HasTask ( j ) then
53283: LD_VAR 0 3
53287: PPUSH
53288: CALL_OW 314
53292: NOT
53293: IFFALSE 53314
// ComTameXY ( j , x , y ) ;
53295: LD_VAR 0 3
53299: PPUSH
53300: LD_VAR 0 4
53304: PPUSH
53305: LD_VAR 0 5
53309: PPUSH
53310: CALL_OW 131
// end ; end ;
53314: GO 52979
53316: POP
53317: POP
// end ;
53318: GO 52535
53320: POP
53321: POP
// end ;
53322: LD_VAR 0 1
53326: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53327: LD_INT 0
53329: PPUSH
53330: PPUSH
53331: PPUSH
53332: PPUSH
53333: PPUSH
53334: PPUSH
53335: PPUSH
53336: PPUSH
// if not mc_bases then
53337: LD_EXP 101
53341: NOT
53342: IFFALSE 53346
// exit ;
53344: GO 53972
// for i = 1 to mc_bases do
53346: LD_ADDR_VAR 0 2
53350: PUSH
53351: DOUBLE
53352: LD_INT 1
53354: DEC
53355: ST_TO_ADDR
53356: LD_EXP 101
53360: PUSH
53361: FOR_TO
53362: IFFALSE 53970
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53364: LD_EXP 130
53368: PUSH
53369: LD_VAR 0 2
53373: ARRAY
53374: NOT
53375: PUSH
53376: LD_EXP 130
53380: PUSH
53381: LD_VAR 0 2
53385: ARRAY
53386: PPUSH
53387: LD_INT 25
53389: PUSH
53390: LD_INT 12
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: PPUSH
53397: CALL_OW 72
53401: NOT
53402: OR
53403: IFFALSE 53407
// continue ;
53405: GO 53361
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53407: LD_ADDR_VAR 0 5
53411: PUSH
53412: LD_EXP 130
53416: PUSH
53417: LD_VAR 0 2
53421: ARRAY
53422: PUSH
53423: LD_INT 1
53425: ARRAY
53426: PPUSH
53427: CALL_OW 255
53431: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53432: LD_VAR 0 5
53436: PPUSH
53437: LD_INT 2
53439: PPUSH
53440: CALL_OW 325
53444: IFFALSE 53697
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53446: LD_ADDR_VAR 0 4
53450: PUSH
53451: LD_EXP 130
53455: PUSH
53456: LD_VAR 0 2
53460: ARRAY
53461: PPUSH
53462: LD_INT 25
53464: PUSH
53465: LD_INT 16
53467: PUSH
53468: EMPTY
53469: LIST
53470: LIST
53471: PPUSH
53472: CALL_OW 72
53476: ST_TO_ADDR
// if tmp < 6 then
53477: LD_VAR 0 4
53481: PUSH
53482: LD_INT 6
53484: LESS
53485: IFFALSE 53697
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53487: LD_ADDR_VAR 0 6
53491: PUSH
53492: LD_EXP 101
53496: PUSH
53497: LD_VAR 0 2
53501: ARRAY
53502: PPUSH
53503: LD_INT 2
53505: PUSH
53506: LD_INT 30
53508: PUSH
53509: LD_INT 0
53511: PUSH
53512: EMPTY
53513: LIST
53514: LIST
53515: PUSH
53516: LD_INT 30
53518: PUSH
53519: LD_INT 1
53521: PUSH
53522: EMPTY
53523: LIST
53524: LIST
53525: PUSH
53526: EMPTY
53527: LIST
53528: LIST
53529: LIST
53530: PPUSH
53531: CALL_OW 72
53535: ST_TO_ADDR
// if depot then
53536: LD_VAR 0 6
53540: IFFALSE 53697
// begin selected := 0 ;
53542: LD_ADDR_VAR 0 7
53546: PUSH
53547: LD_INT 0
53549: ST_TO_ADDR
// for j in depot do
53550: LD_ADDR_VAR 0 3
53554: PUSH
53555: LD_VAR 0 6
53559: PUSH
53560: FOR_IN
53561: IFFALSE 53592
// begin if UnitsInside ( j ) < 6 then
53563: LD_VAR 0 3
53567: PPUSH
53568: CALL_OW 313
53572: PUSH
53573: LD_INT 6
53575: LESS
53576: IFFALSE 53590
// begin selected := j ;
53578: LD_ADDR_VAR 0 7
53582: PUSH
53583: LD_VAR 0 3
53587: ST_TO_ADDR
// break ;
53588: GO 53592
// end ; end ;
53590: GO 53560
53592: POP
53593: POP
// if selected then
53594: LD_VAR 0 7
53598: IFFALSE 53697
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53600: LD_ADDR_VAR 0 3
53604: PUSH
53605: LD_EXP 130
53609: PUSH
53610: LD_VAR 0 2
53614: ARRAY
53615: PPUSH
53616: LD_INT 25
53618: PUSH
53619: LD_INT 12
53621: PUSH
53622: EMPTY
53623: LIST
53624: LIST
53625: PPUSH
53626: CALL_OW 72
53630: PUSH
53631: FOR_IN
53632: IFFALSE 53695
// if not HasTask ( j ) then
53634: LD_VAR 0 3
53638: PPUSH
53639: CALL_OW 314
53643: NOT
53644: IFFALSE 53693
// begin if not IsInUnit ( j ) then
53646: LD_VAR 0 3
53650: PPUSH
53651: CALL_OW 310
53655: NOT
53656: IFFALSE 53672
// ComEnterUnit ( j , selected ) ;
53658: LD_VAR 0 3
53662: PPUSH
53663: LD_VAR 0 7
53667: PPUSH
53668: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53672: LD_VAR 0 3
53676: PPUSH
53677: LD_INT 16
53679: PPUSH
53680: CALL_OW 183
// AddComExitBuilding ( j ) ;
53684: LD_VAR 0 3
53688: PPUSH
53689: CALL_OW 182
// end ;
53693: GO 53631
53695: POP
53696: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53697: LD_VAR 0 5
53701: PPUSH
53702: LD_INT 11
53704: PPUSH
53705: CALL_OW 325
53709: IFFALSE 53968
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53711: LD_ADDR_VAR 0 4
53715: PUSH
53716: LD_EXP 130
53720: PUSH
53721: LD_VAR 0 2
53725: ARRAY
53726: PPUSH
53727: LD_INT 25
53729: PUSH
53730: LD_INT 16
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: PPUSH
53737: CALL_OW 72
53741: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53742: LD_VAR 0 4
53746: PUSH
53747: LD_INT 6
53749: GREATEREQUAL
53750: PUSH
53751: LD_VAR 0 5
53755: PPUSH
53756: LD_INT 2
53758: PPUSH
53759: CALL_OW 325
53763: NOT
53764: OR
53765: IFFALSE 53968
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53767: LD_ADDR_VAR 0 8
53771: PUSH
53772: LD_EXP 101
53776: PUSH
53777: LD_VAR 0 2
53781: ARRAY
53782: PPUSH
53783: LD_INT 2
53785: PUSH
53786: LD_INT 30
53788: PUSH
53789: LD_INT 4
53791: PUSH
53792: EMPTY
53793: LIST
53794: LIST
53795: PUSH
53796: LD_INT 30
53798: PUSH
53799: LD_INT 5
53801: PUSH
53802: EMPTY
53803: LIST
53804: LIST
53805: PUSH
53806: EMPTY
53807: LIST
53808: LIST
53809: LIST
53810: PPUSH
53811: CALL_OW 72
53815: ST_TO_ADDR
// if barracks then
53816: LD_VAR 0 8
53820: IFFALSE 53968
// begin selected := 0 ;
53822: LD_ADDR_VAR 0 7
53826: PUSH
53827: LD_INT 0
53829: ST_TO_ADDR
// for j in barracks do
53830: LD_ADDR_VAR 0 3
53834: PUSH
53835: LD_VAR 0 8
53839: PUSH
53840: FOR_IN
53841: IFFALSE 53872
// begin if UnitsInside ( j ) < 6 then
53843: LD_VAR 0 3
53847: PPUSH
53848: CALL_OW 313
53852: PUSH
53853: LD_INT 6
53855: LESS
53856: IFFALSE 53870
// begin selected := j ;
53858: LD_ADDR_VAR 0 7
53862: PUSH
53863: LD_VAR 0 3
53867: ST_TO_ADDR
// break ;
53868: GO 53872
// end ; end ;
53870: GO 53840
53872: POP
53873: POP
// if selected then
53874: LD_VAR 0 7
53878: IFFALSE 53968
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53880: LD_ADDR_VAR 0 3
53884: PUSH
53885: LD_EXP 130
53889: PUSH
53890: LD_VAR 0 2
53894: ARRAY
53895: PPUSH
53896: LD_INT 25
53898: PUSH
53899: LD_INT 12
53901: PUSH
53902: EMPTY
53903: LIST
53904: LIST
53905: PPUSH
53906: CALL_OW 72
53910: PUSH
53911: FOR_IN
53912: IFFALSE 53966
// if not IsInUnit ( j ) and not HasTask ( j ) then
53914: LD_VAR 0 3
53918: PPUSH
53919: CALL_OW 310
53923: NOT
53924: PUSH
53925: LD_VAR 0 3
53929: PPUSH
53930: CALL_OW 314
53934: NOT
53935: AND
53936: IFFALSE 53964
// begin ComEnterUnit ( j , selected ) ;
53938: LD_VAR 0 3
53942: PPUSH
53943: LD_VAR 0 7
53947: PPUSH
53948: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53952: LD_VAR 0 3
53956: PPUSH
53957: LD_INT 15
53959: PPUSH
53960: CALL_OW 183
// end ;
53964: GO 53911
53966: POP
53967: POP
// end ; end ; end ; end ; end ;
53968: GO 53361
53970: POP
53971: POP
// end ;
53972: LD_VAR 0 1
53976: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53977: LD_INT 0
53979: PPUSH
53980: PPUSH
53981: PPUSH
53982: PPUSH
// if not mc_bases then
53983: LD_EXP 101
53987: NOT
53988: IFFALSE 53992
// exit ;
53990: GO 54170
// for i = 1 to mc_bases do
53992: LD_ADDR_VAR 0 2
53996: PUSH
53997: DOUBLE
53998: LD_INT 1
54000: DEC
54001: ST_TO_ADDR
54002: LD_EXP 101
54006: PUSH
54007: FOR_TO
54008: IFFALSE 54168
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54010: LD_ADDR_VAR 0 4
54014: PUSH
54015: LD_EXP 101
54019: PUSH
54020: LD_VAR 0 2
54024: ARRAY
54025: PPUSH
54026: LD_INT 25
54028: PUSH
54029: LD_INT 9
54031: PUSH
54032: EMPTY
54033: LIST
54034: LIST
54035: PPUSH
54036: CALL_OW 72
54040: ST_TO_ADDR
// if not tmp then
54041: LD_VAR 0 4
54045: NOT
54046: IFFALSE 54050
// continue ;
54048: GO 54007
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54050: LD_EXP 127
54054: PUSH
54055: LD_VAR 0 2
54059: ARRAY
54060: PPUSH
54061: LD_INT 29
54063: PPUSH
54064: CALL_OW 325
54068: NOT
54069: PUSH
54070: LD_EXP 127
54074: PUSH
54075: LD_VAR 0 2
54079: ARRAY
54080: PPUSH
54081: LD_INT 28
54083: PPUSH
54084: CALL_OW 325
54088: NOT
54089: AND
54090: IFFALSE 54094
// continue ;
54092: GO 54007
// for j in tmp do
54094: LD_ADDR_VAR 0 3
54098: PUSH
54099: LD_VAR 0 4
54103: PUSH
54104: FOR_IN
54105: IFFALSE 54164
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54107: LD_VAR 0 3
54111: PUSH
54112: LD_EXP 104
54116: PUSH
54117: LD_VAR 0 2
54121: ARRAY
54122: PUSH
54123: LD_INT 1
54125: ARRAY
54126: IN
54127: NOT
54128: PUSH
54129: LD_VAR 0 3
54133: PUSH
54134: LD_EXP 104
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PUSH
54145: LD_INT 2
54147: ARRAY
54148: IN
54149: NOT
54150: AND
54151: IFFALSE 54162
// ComSpaceTimeShoot ( j ) ;
54153: LD_VAR 0 3
54157: PPUSH
54158: CALL 65188 0 1
54162: GO 54104
54164: POP
54165: POP
// end ;
54166: GO 54007
54168: POP
54169: POP
// end ;
54170: LD_VAR 0 1
54174: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54175: LD_INT 0
54177: PPUSH
54178: PPUSH
54179: PPUSH
54180: PPUSH
54181: PPUSH
54182: PPUSH
54183: PPUSH
54184: PPUSH
54185: PPUSH
// if not mc_bases then
54186: LD_EXP 101
54190: NOT
54191: IFFALSE 54195
// exit ;
54193: GO 54817
// for i = 1 to mc_bases do
54195: LD_ADDR_VAR 0 2
54199: PUSH
54200: DOUBLE
54201: LD_INT 1
54203: DEC
54204: ST_TO_ADDR
54205: LD_EXP 101
54209: PUSH
54210: FOR_TO
54211: IFFALSE 54815
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54213: LD_EXP 136
54217: PUSH
54218: LD_VAR 0 2
54222: ARRAY
54223: NOT
54224: PUSH
54225: LD_INT 38
54227: PPUSH
54228: LD_EXP 127
54232: PUSH
54233: LD_VAR 0 2
54237: ARRAY
54238: PPUSH
54239: CALL_OW 321
54243: PUSH
54244: LD_INT 2
54246: NONEQUAL
54247: OR
54248: IFFALSE 54252
// continue ;
54250: GO 54210
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54252: LD_ADDR_VAR 0 8
54256: PUSH
54257: LD_EXP 101
54261: PUSH
54262: LD_VAR 0 2
54266: ARRAY
54267: PPUSH
54268: LD_INT 30
54270: PUSH
54271: LD_INT 34
54273: PUSH
54274: EMPTY
54275: LIST
54276: LIST
54277: PPUSH
54278: CALL_OW 72
54282: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54283: LD_ADDR_VAR 0 9
54287: PUSH
54288: LD_EXP 101
54292: PUSH
54293: LD_VAR 0 2
54297: ARRAY
54298: PPUSH
54299: LD_INT 25
54301: PUSH
54302: LD_INT 4
54304: PUSH
54305: EMPTY
54306: LIST
54307: LIST
54308: PPUSH
54309: CALL_OW 72
54313: PPUSH
54314: LD_INT 0
54316: PPUSH
54317: CALL 104862 0 2
54321: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54322: LD_VAR 0 9
54326: NOT
54327: PUSH
54328: LD_VAR 0 8
54332: NOT
54333: OR
54334: PUSH
54335: LD_EXP 101
54339: PUSH
54340: LD_VAR 0 2
54344: ARRAY
54345: PPUSH
54346: LD_INT 124
54348: PPUSH
54349: CALL 104862 0 2
54353: OR
54354: IFFALSE 54358
// continue ;
54356: GO 54210
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54358: LD_EXP 137
54362: PUSH
54363: LD_VAR 0 2
54367: ARRAY
54368: PUSH
54369: LD_EXP 136
54373: PUSH
54374: LD_VAR 0 2
54378: ARRAY
54379: LESS
54380: PUSH
54381: LD_EXP 137
54385: PUSH
54386: LD_VAR 0 2
54390: ARRAY
54391: PUSH
54392: LD_VAR 0 8
54396: LESS
54397: AND
54398: IFFALSE 54813
// begin tmp := sci [ 1 ] ;
54400: LD_ADDR_VAR 0 7
54404: PUSH
54405: LD_VAR 0 9
54409: PUSH
54410: LD_INT 1
54412: ARRAY
54413: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54414: LD_VAR 0 7
54418: PPUSH
54419: LD_INT 124
54421: PPUSH
54422: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54426: LD_ADDR_VAR 0 3
54430: PUSH
54431: DOUBLE
54432: LD_EXP 136
54436: PUSH
54437: LD_VAR 0 2
54441: ARRAY
54442: INC
54443: ST_TO_ADDR
54444: LD_EXP 136
54448: PUSH
54449: LD_VAR 0 2
54453: ARRAY
54454: PUSH
54455: FOR_DOWNTO
54456: IFFALSE 54799
// begin if IsInUnit ( tmp ) then
54458: LD_VAR 0 7
54462: PPUSH
54463: CALL_OW 310
54467: IFFALSE 54478
// ComExitBuilding ( tmp ) ;
54469: LD_VAR 0 7
54473: PPUSH
54474: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54478: LD_INT 35
54480: PPUSH
54481: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54485: LD_VAR 0 7
54489: PPUSH
54490: CALL_OW 310
54494: NOT
54495: PUSH
54496: LD_VAR 0 7
54500: PPUSH
54501: CALL_OW 314
54505: NOT
54506: AND
54507: IFFALSE 54478
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54509: LD_ADDR_VAR 0 6
54513: PUSH
54514: LD_VAR 0 7
54518: PPUSH
54519: CALL_OW 250
54523: PUSH
54524: LD_VAR 0 7
54528: PPUSH
54529: CALL_OW 251
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54538: LD_INT 35
54540: PPUSH
54541: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54545: LD_ADDR_VAR 0 4
54549: PUSH
54550: LD_EXP 136
54554: PUSH
54555: LD_VAR 0 2
54559: ARRAY
54560: PUSH
54561: LD_VAR 0 3
54565: ARRAY
54566: PUSH
54567: LD_INT 1
54569: ARRAY
54570: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54571: LD_ADDR_VAR 0 5
54575: PUSH
54576: LD_EXP 136
54580: PUSH
54581: LD_VAR 0 2
54585: ARRAY
54586: PUSH
54587: LD_VAR 0 3
54591: ARRAY
54592: PUSH
54593: LD_INT 2
54595: ARRAY
54596: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54597: LD_VAR 0 7
54601: PPUSH
54602: LD_INT 10
54604: PPUSH
54605: CALL 74195 0 2
54609: PUSH
54610: LD_INT 4
54612: ARRAY
54613: IFFALSE 54651
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54615: LD_VAR 0 7
54619: PPUSH
54620: LD_VAR 0 6
54624: PUSH
54625: LD_INT 1
54627: ARRAY
54628: PPUSH
54629: LD_VAR 0 6
54633: PUSH
54634: LD_INT 2
54636: ARRAY
54637: PPUSH
54638: CALL_OW 111
// wait ( 0 0$10 ) ;
54642: LD_INT 350
54644: PPUSH
54645: CALL_OW 67
// end else
54649: GO 54677
// begin ComMoveXY ( tmp , x , y ) ;
54651: LD_VAR 0 7
54655: PPUSH
54656: LD_VAR 0 4
54660: PPUSH
54661: LD_VAR 0 5
54665: PPUSH
54666: CALL_OW 111
// wait ( 0 0$3 ) ;
54670: LD_INT 105
54672: PPUSH
54673: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54677: LD_VAR 0 7
54681: PPUSH
54682: LD_VAR 0 4
54686: PPUSH
54687: LD_VAR 0 5
54691: PPUSH
54692: CALL_OW 307
54696: IFFALSE 54538
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54698: LD_VAR 0 7
54702: PPUSH
54703: LD_VAR 0 4
54707: PPUSH
54708: LD_VAR 0 5
54712: PPUSH
54713: LD_VAR 0 8
54717: PUSH
54718: LD_VAR 0 3
54722: ARRAY
54723: PPUSH
54724: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54728: LD_INT 35
54730: PPUSH
54731: CALL_OW 67
// until not HasTask ( tmp ) ;
54735: LD_VAR 0 7
54739: PPUSH
54740: CALL_OW 314
54744: NOT
54745: IFFALSE 54728
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54747: LD_ADDR_EXP 137
54751: PUSH
54752: LD_EXP 137
54756: PPUSH
54757: LD_VAR 0 2
54761: PUSH
54762: LD_EXP 137
54766: PUSH
54767: LD_VAR 0 2
54771: ARRAY
54772: PUSH
54773: LD_INT 1
54775: PLUS
54776: PUSH
54777: EMPTY
54778: LIST
54779: LIST
54780: PPUSH
54781: LD_VAR 0 8
54785: PUSH
54786: LD_VAR 0 3
54790: ARRAY
54791: PPUSH
54792: CALL 71602 0 3
54796: ST_TO_ADDR
// end ;
54797: GO 54455
54799: POP
54800: POP
// MC_Reset ( i , 124 ) ;
54801: LD_VAR 0 2
54805: PPUSH
54806: LD_INT 124
54808: PPUSH
54809: CALL 38300 0 2
// end ; end ;
54813: GO 54210
54815: POP
54816: POP
// end ;
54817: LD_VAR 0 1
54821: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54822: LD_INT 0
54824: PPUSH
54825: PPUSH
54826: PPUSH
// if not mc_bases then
54827: LD_EXP 101
54831: NOT
54832: IFFALSE 54836
// exit ;
54834: GO 55442
// for i = 1 to mc_bases do
54836: LD_ADDR_VAR 0 2
54840: PUSH
54841: DOUBLE
54842: LD_INT 1
54844: DEC
54845: ST_TO_ADDR
54846: LD_EXP 101
54850: PUSH
54851: FOR_TO
54852: IFFALSE 55440
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54854: LD_ADDR_VAR 0 3
54858: PUSH
54859: LD_EXP 101
54863: PUSH
54864: LD_VAR 0 2
54868: ARRAY
54869: PPUSH
54870: LD_INT 25
54872: PUSH
54873: LD_INT 4
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PPUSH
54880: CALL_OW 72
54884: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54885: LD_VAR 0 3
54889: NOT
54890: PUSH
54891: LD_EXP 138
54895: PUSH
54896: LD_VAR 0 2
54900: ARRAY
54901: NOT
54902: OR
54903: PUSH
54904: LD_EXP 101
54908: PUSH
54909: LD_VAR 0 2
54913: ARRAY
54914: PPUSH
54915: LD_INT 2
54917: PUSH
54918: LD_INT 30
54920: PUSH
54921: LD_INT 0
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: PUSH
54928: LD_INT 30
54930: PUSH
54931: LD_INT 1
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: PUSH
54938: EMPTY
54939: LIST
54940: LIST
54941: LIST
54942: PPUSH
54943: CALL_OW 72
54947: NOT
54948: OR
54949: IFFALSE 54999
// begin if mc_deposits_finder [ i ] then
54951: LD_EXP 139
54955: PUSH
54956: LD_VAR 0 2
54960: ARRAY
54961: IFFALSE 54997
// begin MC_Reset ( i , 125 ) ;
54963: LD_VAR 0 2
54967: PPUSH
54968: LD_INT 125
54970: PPUSH
54971: CALL 38300 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54975: LD_ADDR_EXP 139
54979: PUSH
54980: LD_EXP 139
54984: PPUSH
54985: LD_VAR 0 2
54989: PPUSH
54990: EMPTY
54991: PPUSH
54992: CALL_OW 1
54996: ST_TO_ADDR
// end ; continue ;
54997: GO 54851
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54999: LD_EXP 138
55003: PUSH
55004: LD_VAR 0 2
55008: ARRAY
55009: PUSH
55010: LD_INT 1
55012: ARRAY
55013: PUSH
55014: LD_INT 3
55016: ARRAY
55017: PUSH
55018: LD_INT 1
55020: EQUAL
55021: PUSH
55022: LD_INT 20
55024: PPUSH
55025: LD_EXP 127
55029: PUSH
55030: LD_VAR 0 2
55034: ARRAY
55035: PPUSH
55036: CALL_OW 321
55040: PUSH
55041: LD_INT 2
55043: NONEQUAL
55044: AND
55045: IFFALSE 55095
// begin if mc_deposits_finder [ i ] then
55047: LD_EXP 139
55051: PUSH
55052: LD_VAR 0 2
55056: ARRAY
55057: IFFALSE 55093
// begin MC_Reset ( i , 125 ) ;
55059: LD_VAR 0 2
55063: PPUSH
55064: LD_INT 125
55066: PPUSH
55067: CALL 38300 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55071: LD_ADDR_EXP 139
55075: PUSH
55076: LD_EXP 139
55080: PPUSH
55081: LD_VAR 0 2
55085: PPUSH
55086: EMPTY
55087: PPUSH
55088: CALL_OW 1
55092: ST_TO_ADDR
// end ; continue ;
55093: GO 54851
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55095: LD_EXP 138
55099: PUSH
55100: LD_VAR 0 2
55104: ARRAY
55105: PUSH
55106: LD_INT 1
55108: ARRAY
55109: PUSH
55110: LD_INT 1
55112: ARRAY
55113: PPUSH
55114: LD_EXP 138
55118: PUSH
55119: LD_VAR 0 2
55123: ARRAY
55124: PUSH
55125: LD_INT 1
55127: ARRAY
55128: PUSH
55129: LD_INT 2
55131: ARRAY
55132: PPUSH
55133: LD_EXP 127
55137: PUSH
55138: LD_VAR 0 2
55142: ARRAY
55143: PPUSH
55144: CALL_OW 440
55148: IFFALSE 55191
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55150: LD_ADDR_EXP 138
55154: PUSH
55155: LD_EXP 138
55159: PPUSH
55160: LD_VAR 0 2
55164: PPUSH
55165: LD_EXP 138
55169: PUSH
55170: LD_VAR 0 2
55174: ARRAY
55175: PPUSH
55176: LD_INT 1
55178: PPUSH
55179: CALL_OW 3
55183: PPUSH
55184: CALL_OW 1
55188: ST_TO_ADDR
55189: GO 55438
// begin if not mc_deposits_finder [ i ] then
55191: LD_EXP 139
55195: PUSH
55196: LD_VAR 0 2
55200: ARRAY
55201: NOT
55202: IFFALSE 55254
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55204: LD_ADDR_EXP 139
55208: PUSH
55209: LD_EXP 139
55213: PPUSH
55214: LD_VAR 0 2
55218: PPUSH
55219: LD_VAR 0 3
55223: PUSH
55224: LD_INT 1
55226: ARRAY
55227: PUSH
55228: EMPTY
55229: LIST
55230: PPUSH
55231: CALL_OW 1
55235: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55236: LD_VAR 0 3
55240: PUSH
55241: LD_INT 1
55243: ARRAY
55244: PPUSH
55245: LD_INT 125
55247: PPUSH
55248: CALL_OW 109
// end else
55252: GO 55438
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55254: LD_EXP 139
55258: PUSH
55259: LD_VAR 0 2
55263: ARRAY
55264: PUSH
55265: LD_INT 1
55267: ARRAY
55268: PPUSH
55269: CALL_OW 310
55273: IFFALSE 55296
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55275: LD_EXP 139
55279: PUSH
55280: LD_VAR 0 2
55284: ARRAY
55285: PUSH
55286: LD_INT 1
55288: ARRAY
55289: PPUSH
55290: CALL_OW 122
55294: GO 55438
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55296: LD_EXP 139
55300: PUSH
55301: LD_VAR 0 2
55305: ARRAY
55306: PUSH
55307: LD_INT 1
55309: ARRAY
55310: PPUSH
55311: CALL_OW 314
55315: NOT
55316: PUSH
55317: LD_EXP 139
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PUSH
55328: LD_INT 1
55330: ARRAY
55331: PPUSH
55332: LD_EXP 138
55336: PUSH
55337: LD_VAR 0 2
55341: ARRAY
55342: PUSH
55343: LD_INT 1
55345: ARRAY
55346: PUSH
55347: LD_INT 1
55349: ARRAY
55350: PPUSH
55351: LD_EXP 138
55355: PUSH
55356: LD_VAR 0 2
55360: ARRAY
55361: PUSH
55362: LD_INT 1
55364: ARRAY
55365: PUSH
55366: LD_INT 2
55368: ARRAY
55369: PPUSH
55370: CALL_OW 297
55374: PUSH
55375: LD_INT 6
55377: GREATER
55378: AND
55379: IFFALSE 55438
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55381: LD_EXP 139
55385: PUSH
55386: LD_VAR 0 2
55390: ARRAY
55391: PUSH
55392: LD_INT 1
55394: ARRAY
55395: PPUSH
55396: LD_EXP 138
55400: PUSH
55401: LD_VAR 0 2
55405: ARRAY
55406: PUSH
55407: LD_INT 1
55409: ARRAY
55410: PUSH
55411: LD_INT 1
55413: ARRAY
55414: PPUSH
55415: LD_EXP 138
55419: PUSH
55420: LD_VAR 0 2
55424: ARRAY
55425: PUSH
55426: LD_INT 1
55428: ARRAY
55429: PUSH
55430: LD_INT 2
55432: ARRAY
55433: PPUSH
55434: CALL_OW 111
// end ; end ; end ;
55438: GO 54851
55440: POP
55441: POP
// end ;
55442: LD_VAR 0 1
55446: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55447: LD_INT 0
55449: PPUSH
55450: PPUSH
55451: PPUSH
55452: PPUSH
55453: PPUSH
55454: PPUSH
55455: PPUSH
55456: PPUSH
55457: PPUSH
55458: PPUSH
55459: PPUSH
// if not mc_bases then
55460: LD_EXP 101
55464: NOT
55465: IFFALSE 55469
// exit ;
55467: GO 56409
// for i = 1 to mc_bases do
55469: LD_ADDR_VAR 0 2
55473: PUSH
55474: DOUBLE
55475: LD_INT 1
55477: DEC
55478: ST_TO_ADDR
55479: LD_EXP 101
55483: PUSH
55484: FOR_TO
55485: IFFALSE 56407
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55487: LD_EXP 101
55491: PUSH
55492: LD_VAR 0 2
55496: ARRAY
55497: NOT
55498: PUSH
55499: LD_EXP 124
55503: PUSH
55504: LD_VAR 0 2
55508: ARRAY
55509: OR
55510: IFFALSE 55514
// continue ;
55512: GO 55484
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55514: LD_ADDR_VAR 0 7
55518: PUSH
55519: LD_EXP 101
55523: PUSH
55524: LD_VAR 0 2
55528: ARRAY
55529: PUSH
55530: LD_INT 1
55532: ARRAY
55533: PPUSH
55534: CALL_OW 248
55538: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55539: LD_VAR 0 7
55543: PUSH
55544: LD_INT 3
55546: EQUAL
55547: PUSH
55548: LD_EXP 120
55552: PUSH
55553: LD_VAR 0 2
55557: ARRAY
55558: PUSH
55559: LD_EXP 123
55563: PUSH
55564: LD_VAR 0 2
55568: ARRAY
55569: UNION
55570: PPUSH
55571: LD_INT 33
55573: PUSH
55574: LD_INT 2
55576: PUSH
55577: EMPTY
55578: LIST
55579: LIST
55580: PPUSH
55581: CALL_OW 72
55585: NOT
55586: OR
55587: IFFALSE 55591
// continue ;
55589: GO 55484
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55591: LD_ADDR_VAR 0 9
55595: PUSH
55596: LD_EXP 101
55600: PUSH
55601: LD_VAR 0 2
55605: ARRAY
55606: PPUSH
55607: LD_INT 30
55609: PUSH
55610: LD_INT 36
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PPUSH
55617: CALL_OW 72
55621: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55622: LD_ADDR_VAR 0 10
55626: PUSH
55627: LD_EXP 120
55631: PUSH
55632: LD_VAR 0 2
55636: ARRAY
55637: PPUSH
55638: LD_INT 34
55640: PUSH
55641: LD_INT 31
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: PPUSH
55648: CALL_OW 72
55652: ST_TO_ADDR
// if not cts and not mcts then
55653: LD_VAR 0 9
55657: NOT
55658: PUSH
55659: LD_VAR 0 10
55663: NOT
55664: AND
55665: IFFALSE 55669
// continue ;
55667: GO 55484
// x := cts ;
55669: LD_ADDR_VAR 0 11
55673: PUSH
55674: LD_VAR 0 9
55678: ST_TO_ADDR
// if not x then
55679: LD_VAR 0 11
55683: NOT
55684: IFFALSE 55696
// x := mcts ;
55686: LD_ADDR_VAR 0 11
55690: PUSH
55691: LD_VAR 0 10
55695: ST_TO_ADDR
// if not x then
55696: LD_VAR 0 11
55700: NOT
55701: IFFALSE 55705
// continue ;
55703: GO 55484
// if mc_remote_driver [ i ] then
55705: LD_EXP 141
55709: PUSH
55710: LD_VAR 0 2
55714: ARRAY
55715: IFFALSE 56102
// for j in mc_remote_driver [ i ] do
55717: LD_ADDR_VAR 0 3
55721: PUSH
55722: LD_EXP 141
55726: PUSH
55727: LD_VAR 0 2
55731: ARRAY
55732: PUSH
55733: FOR_IN
55734: IFFALSE 56100
// begin if GetClass ( j ) <> 3 then
55736: LD_VAR 0 3
55740: PPUSH
55741: CALL_OW 257
55745: PUSH
55746: LD_INT 3
55748: NONEQUAL
55749: IFFALSE 55802
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55751: LD_ADDR_EXP 141
55755: PUSH
55756: LD_EXP 141
55760: PPUSH
55761: LD_VAR 0 2
55765: PPUSH
55766: LD_EXP 141
55770: PUSH
55771: LD_VAR 0 2
55775: ARRAY
55776: PUSH
55777: LD_VAR 0 3
55781: DIFF
55782: PPUSH
55783: CALL_OW 1
55787: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55788: LD_VAR 0 3
55792: PPUSH
55793: LD_INT 0
55795: PPUSH
55796: CALL_OW 109
// continue ;
55800: GO 55733
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55802: LD_EXP 120
55806: PUSH
55807: LD_VAR 0 2
55811: ARRAY
55812: PPUSH
55813: LD_INT 34
55815: PUSH
55816: LD_INT 31
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PUSH
55823: LD_INT 58
55825: PUSH
55826: EMPTY
55827: LIST
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: PPUSH
55833: CALL_OW 72
55837: PUSH
55838: LD_VAR 0 3
55842: PPUSH
55843: CALL 104950 0 1
55847: NOT
55848: AND
55849: IFFALSE 55920
// begin if IsInUnit ( j ) then
55851: LD_VAR 0 3
55855: PPUSH
55856: CALL_OW 310
55860: IFFALSE 55871
// ComExitBuilding ( j ) ;
55862: LD_VAR 0 3
55866: PPUSH
55867: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55871: LD_VAR 0 3
55875: PPUSH
55876: LD_EXP 120
55880: PUSH
55881: LD_VAR 0 2
55885: ARRAY
55886: PPUSH
55887: LD_INT 34
55889: PUSH
55890: LD_INT 31
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: PUSH
55897: LD_INT 58
55899: PUSH
55900: EMPTY
55901: LIST
55902: PUSH
55903: EMPTY
55904: LIST
55905: LIST
55906: PPUSH
55907: CALL_OW 72
55911: PUSH
55912: LD_INT 1
55914: ARRAY
55915: PPUSH
55916: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55920: LD_VAR 0 3
55924: PPUSH
55925: CALL_OW 310
55929: NOT
55930: PUSH
55931: LD_VAR 0 3
55935: PPUSH
55936: CALL_OW 310
55940: PPUSH
55941: CALL_OW 266
55945: PUSH
55946: LD_INT 36
55948: NONEQUAL
55949: PUSH
55950: LD_VAR 0 3
55954: PPUSH
55955: CALL 104950 0 1
55959: NOT
55960: AND
55961: OR
55962: IFFALSE 56098
// begin if IsInUnit ( j ) then
55964: LD_VAR 0 3
55968: PPUSH
55969: CALL_OW 310
55973: IFFALSE 55984
// ComExitBuilding ( j ) ;
55975: LD_VAR 0 3
55979: PPUSH
55980: CALL_OW 122
// ct := 0 ;
55984: LD_ADDR_VAR 0 8
55988: PUSH
55989: LD_INT 0
55991: ST_TO_ADDR
// for k in x do
55992: LD_ADDR_VAR 0 4
55996: PUSH
55997: LD_VAR 0 11
56001: PUSH
56002: FOR_IN
56003: IFFALSE 56076
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56005: LD_VAR 0 4
56009: PPUSH
56010: CALL_OW 264
56014: PUSH
56015: LD_INT 31
56017: EQUAL
56018: PUSH
56019: LD_VAR 0 4
56023: PPUSH
56024: CALL_OW 311
56028: NOT
56029: AND
56030: PUSH
56031: LD_VAR 0 4
56035: PPUSH
56036: CALL_OW 266
56040: PUSH
56041: LD_INT 36
56043: EQUAL
56044: PUSH
56045: LD_VAR 0 4
56049: PPUSH
56050: CALL_OW 313
56054: PUSH
56055: LD_INT 3
56057: LESS
56058: AND
56059: OR
56060: IFFALSE 56074
// begin ct := k ;
56062: LD_ADDR_VAR 0 8
56066: PUSH
56067: LD_VAR 0 4
56071: ST_TO_ADDR
// break ;
56072: GO 56076
// end ;
56074: GO 56002
56076: POP
56077: POP
// if ct then
56078: LD_VAR 0 8
56082: IFFALSE 56098
// ComEnterUnit ( j , ct ) ;
56084: LD_VAR 0 3
56088: PPUSH
56089: LD_VAR 0 8
56093: PPUSH
56094: CALL_OW 120
// end ; end ;
56098: GO 55733
56100: POP
56101: POP
// places := 0 ;
56102: LD_ADDR_VAR 0 5
56106: PUSH
56107: LD_INT 0
56109: ST_TO_ADDR
// for j = 1 to x do
56110: LD_ADDR_VAR 0 3
56114: PUSH
56115: DOUBLE
56116: LD_INT 1
56118: DEC
56119: ST_TO_ADDR
56120: LD_VAR 0 11
56124: PUSH
56125: FOR_TO
56126: IFFALSE 56202
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56128: LD_VAR 0 11
56132: PUSH
56133: LD_VAR 0 3
56137: ARRAY
56138: PPUSH
56139: CALL_OW 264
56143: PUSH
56144: LD_INT 31
56146: EQUAL
56147: IFFALSE 56165
// places := places + 1 else
56149: LD_ADDR_VAR 0 5
56153: PUSH
56154: LD_VAR 0 5
56158: PUSH
56159: LD_INT 1
56161: PLUS
56162: ST_TO_ADDR
56163: GO 56200
// if GetBType ( x [ j ] ) = b_control_tower then
56165: LD_VAR 0 11
56169: PUSH
56170: LD_VAR 0 3
56174: ARRAY
56175: PPUSH
56176: CALL_OW 266
56180: PUSH
56181: LD_INT 36
56183: EQUAL
56184: IFFALSE 56200
// places := places + 3 ;
56186: LD_ADDR_VAR 0 5
56190: PUSH
56191: LD_VAR 0 5
56195: PUSH
56196: LD_INT 3
56198: PLUS
56199: ST_TO_ADDR
56200: GO 56125
56202: POP
56203: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56204: LD_VAR 0 5
56208: PUSH
56209: LD_INT 0
56211: EQUAL
56212: PUSH
56213: LD_VAR 0 5
56217: PUSH
56218: LD_EXP 141
56222: PUSH
56223: LD_VAR 0 2
56227: ARRAY
56228: LESSEQUAL
56229: OR
56230: IFFALSE 56234
// continue ;
56232: GO 55484
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56234: LD_ADDR_VAR 0 6
56238: PUSH
56239: LD_EXP 101
56243: PUSH
56244: LD_VAR 0 2
56248: ARRAY
56249: PPUSH
56250: LD_INT 25
56252: PUSH
56253: LD_INT 3
56255: PUSH
56256: EMPTY
56257: LIST
56258: LIST
56259: PPUSH
56260: CALL_OW 72
56264: PUSH
56265: LD_EXP 141
56269: PUSH
56270: LD_VAR 0 2
56274: ARRAY
56275: DIFF
56276: PPUSH
56277: LD_INT 3
56279: PPUSH
56280: CALL 105850 0 2
56284: ST_TO_ADDR
// for j in tmp do
56285: LD_ADDR_VAR 0 3
56289: PUSH
56290: LD_VAR 0 6
56294: PUSH
56295: FOR_IN
56296: IFFALSE 56331
// if GetTag ( j ) > 0 then
56298: LD_VAR 0 3
56302: PPUSH
56303: CALL_OW 110
56307: PUSH
56308: LD_INT 0
56310: GREATER
56311: IFFALSE 56329
// tmp := tmp diff j ;
56313: LD_ADDR_VAR 0 6
56317: PUSH
56318: LD_VAR 0 6
56322: PUSH
56323: LD_VAR 0 3
56327: DIFF
56328: ST_TO_ADDR
56329: GO 56295
56331: POP
56332: POP
// if not tmp then
56333: LD_VAR 0 6
56337: NOT
56338: IFFALSE 56342
// continue ;
56340: GO 55484
// if places then
56342: LD_VAR 0 5
56346: IFFALSE 56405
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56348: LD_ADDR_EXP 141
56352: PUSH
56353: LD_EXP 141
56357: PPUSH
56358: LD_VAR 0 2
56362: PPUSH
56363: LD_EXP 141
56367: PUSH
56368: LD_VAR 0 2
56372: ARRAY
56373: PUSH
56374: LD_VAR 0 6
56378: PUSH
56379: LD_INT 1
56381: ARRAY
56382: UNION
56383: PPUSH
56384: CALL_OW 1
56388: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56389: LD_VAR 0 6
56393: PUSH
56394: LD_INT 1
56396: ARRAY
56397: PPUSH
56398: LD_INT 126
56400: PPUSH
56401: CALL_OW 109
// end ; end ;
56405: GO 55484
56407: POP
56408: POP
// end ;
56409: LD_VAR 0 1
56413: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56414: LD_INT 0
56416: PPUSH
56417: PPUSH
56418: PPUSH
56419: PPUSH
56420: PPUSH
56421: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56422: LD_VAR 0 1
56426: NOT
56427: PUSH
56428: LD_VAR 0 2
56432: NOT
56433: OR
56434: PUSH
56435: LD_VAR 0 3
56439: NOT
56440: OR
56441: PUSH
56442: LD_VAR 0 4
56446: PUSH
56447: LD_INT 1
56449: PUSH
56450: LD_INT 2
56452: PUSH
56453: LD_INT 3
56455: PUSH
56456: LD_INT 4
56458: PUSH
56459: LD_INT 5
56461: PUSH
56462: LD_INT 8
56464: PUSH
56465: LD_INT 9
56467: PUSH
56468: LD_INT 15
56470: PUSH
56471: LD_INT 16
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: LIST
56478: LIST
56479: LIST
56480: LIST
56481: LIST
56482: LIST
56483: LIST
56484: IN
56485: NOT
56486: OR
56487: IFFALSE 56491
// exit ;
56489: GO 57391
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56491: LD_ADDR_VAR 0 2
56495: PUSH
56496: LD_VAR 0 2
56500: PPUSH
56501: LD_INT 21
56503: PUSH
56504: LD_INT 3
56506: PUSH
56507: EMPTY
56508: LIST
56509: LIST
56510: PUSH
56511: LD_INT 24
56513: PUSH
56514: LD_INT 250
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: PUSH
56521: EMPTY
56522: LIST
56523: LIST
56524: PPUSH
56525: CALL_OW 72
56529: ST_TO_ADDR
// case class of 1 , 15 :
56530: LD_VAR 0 4
56534: PUSH
56535: LD_INT 1
56537: DOUBLE
56538: EQUAL
56539: IFTRUE 56549
56541: LD_INT 15
56543: DOUBLE
56544: EQUAL
56545: IFTRUE 56549
56547: GO 56634
56549: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56550: LD_ADDR_VAR 0 8
56554: PUSH
56555: LD_VAR 0 2
56559: PPUSH
56560: LD_INT 2
56562: PUSH
56563: LD_INT 30
56565: PUSH
56566: LD_INT 32
56568: PUSH
56569: EMPTY
56570: LIST
56571: LIST
56572: PUSH
56573: LD_INT 30
56575: PUSH
56576: LD_INT 31
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: EMPTY
56584: LIST
56585: LIST
56586: LIST
56587: PPUSH
56588: CALL_OW 72
56592: PUSH
56593: LD_VAR 0 2
56597: PPUSH
56598: LD_INT 2
56600: PUSH
56601: LD_INT 30
56603: PUSH
56604: LD_INT 4
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: PUSH
56611: LD_INT 30
56613: PUSH
56614: LD_INT 5
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PUSH
56621: EMPTY
56622: LIST
56623: LIST
56624: LIST
56625: PPUSH
56626: CALL_OW 72
56630: ADD
56631: ST_TO_ADDR
56632: GO 56880
56634: LD_INT 2
56636: DOUBLE
56637: EQUAL
56638: IFTRUE 56648
56640: LD_INT 16
56642: DOUBLE
56643: EQUAL
56644: IFTRUE 56648
56646: GO 56694
56648: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56649: LD_ADDR_VAR 0 8
56653: PUSH
56654: LD_VAR 0 2
56658: PPUSH
56659: LD_INT 2
56661: PUSH
56662: LD_INT 30
56664: PUSH
56665: LD_INT 0
56667: PUSH
56668: EMPTY
56669: LIST
56670: LIST
56671: PUSH
56672: LD_INT 30
56674: PUSH
56675: LD_INT 1
56677: PUSH
56678: EMPTY
56679: LIST
56680: LIST
56681: PUSH
56682: EMPTY
56683: LIST
56684: LIST
56685: LIST
56686: PPUSH
56687: CALL_OW 72
56691: ST_TO_ADDR
56692: GO 56880
56694: LD_INT 3
56696: DOUBLE
56697: EQUAL
56698: IFTRUE 56702
56700: GO 56748
56702: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56703: LD_ADDR_VAR 0 8
56707: PUSH
56708: LD_VAR 0 2
56712: PPUSH
56713: LD_INT 2
56715: PUSH
56716: LD_INT 30
56718: PUSH
56719: LD_INT 2
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: PUSH
56726: LD_INT 30
56728: PUSH
56729: LD_INT 3
56731: PUSH
56732: EMPTY
56733: LIST
56734: LIST
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: LIST
56740: PPUSH
56741: CALL_OW 72
56745: ST_TO_ADDR
56746: GO 56880
56748: LD_INT 4
56750: DOUBLE
56751: EQUAL
56752: IFTRUE 56756
56754: GO 56813
56756: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56757: LD_ADDR_VAR 0 8
56761: PUSH
56762: LD_VAR 0 2
56766: PPUSH
56767: LD_INT 2
56769: PUSH
56770: LD_INT 30
56772: PUSH
56773: LD_INT 6
56775: PUSH
56776: EMPTY
56777: LIST
56778: LIST
56779: PUSH
56780: LD_INT 30
56782: PUSH
56783: LD_INT 7
56785: PUSH
56786: EMPTY
56787: LIST
56788: LIST
56789: PUSH
56790: LD_INT 30
56792: PUSH
56793: LD_INT 8
56795: PUSH
56796: EMPTY
56797: LIST
56798: LIST
56799: PUSH
56800: EMPTY
56801: LIST
56802: LIST
56803: LIST
56804: LIST
56805: PPUSH
56806: CALL_OW 72
56810: ST_TO_ADDR
56811: GO 56880
56813: LD_INT 5
56815: DOUBLE
56816: EQUAL
56817: IFTRUE 56833
56819: LD_INT 8
56821: DOUBLE
56822: EQUAL
56823: IFTRUE 56833
56825: LD_INT 9
56827: DOUBLE
56828: EQUAL
56829: IFTRUE 56833
56831: GO 56879
56833: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56834: LD_ADDR_VAR 0 8
56838: PUSH
56839: LD_VAR 0 2
56843: PPUSH
56844: LD_INT 2
56846: PUSH
56847: LD_INT 30
56849: PUSH
56850: LD_INT 4
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: PUSH
56857: LD_INT 30
56859: PUSH
56860: LD_INT 5
56862: PUSH
56863: EMPTY
56864: LIST
56865: LIST
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: LIST
56871: PPUSH
56872: CALL_OW 72
56876: ST_TO_ADDR
56877: GO 56880
56879: POP
// if not tmp then
56880: LD_VAR 0 8
56884: NOT
56885: IFFALSE 56889
// exit ;
56887: GO 57391
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56889: LD_VAR 0 4
56893: PUSH
56894: LD_INT 1
56896: PUSH
56897: LD_INT 15
56899: PUSH
56900: EMPTY
56901: LIST
56902: LIST
56903: IN
56904: PUSH
56905: LD_EXP 110
56909: PUSH
56910: LD_VAR 0 1
56914: ARRAY
56915: AND
56916: IFFALSE 57072
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56918: LD_ADDR_VAR 0 9
56922: PUSH
56923: LD_EXP 110
56927: PUSH
56928: LD_VAR 0 1
56932: ARRAY
56933: PUSH
56934: LD_INT 1
56936: ARRAY
56937: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56938: LD_VAR 0 9
56942: PUSH
56943: LD_EXP 111
56947: PUSH
56948: LD_VAR 0 1
56952: ARRAY
56953: IN
56954: NOT
56955: IFFALSE 57070
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56957: LD_ADDR_EXP 111
56961: PUSH
56962: LD_EXP 111
56966: PPUSH
56967: LD_VAR 0 1
56971: PUSH
56972: LD_EXP 111
56976: PUSH
56977: LD_VAR 0 1
56981: ARRAY
56982: PUSH
56983: LD_INT 1
56985: PLUS
56986: PUSH
56987: EMPTY
56988: LIST
56989: LIST
56990: PPUSH
56991: LD_VAR 0 9
56995: PPUSH
56996: CALL 71602 0 3
57000: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57001: LD_ADDR_EXP 110
57005: PUSH
57006: LD_EXP 110
57010: PPUSH
57011: LD_VAR 0 1
57015: PPUSH
57016: LD_EXP 110
57020: PUSH
57021: LD_VAR 0 1
57025: ARRAY
57026: PUSH
57027: LD_VAR 0 9
57031: DIFF
57032: PPUSH
57033: CALL_OW 1
57037: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57038: LD_VAR 0 3
57042: PPUSH
57043: LD_EXP 111
57047: PUSH
57048: LD_VAR 0 1
57052: ARRAY
57053: PUSH
57054: LD_EXP 111
57058: PUSH
57059: LD_VAR 0 1
57063: ARRAY
57064: ARRAY
57065: PPUSH
57066: CALL_OW 120
// end ; exit ;
57070: GO 57391
// end ; if tmp > 1 then
57072: LD_VAR 0 8
57076: PUSH
57077: LD_INT 1
57079: GREATER
57080: IFFALSE 57184
// for i = 2 to tmp do
57082: LD_ADDR_VAR 0 6
57086: PUSH
57087: DOUBLE
57088: LD_INT 2
57090: DEC
57091: ST_TO_ADDR
57092: LD_VAR 0 8
57096: PUSH
57097: FOR_TO
57098: IFFALSE 57182
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57100: LD_VAR 0 8
57104: PUSH
57105: LD_VAR 0 6
57109: ARRAY
57110: PPUSH
57111: CALL_OW 461
57115: PUSH
57116: LD_INT 6
57118: EQUAL
57119: IFFALSE 57180
// begin x := tmp [ i ] ;
57121: LD_ADDR_VAR 0 9
57125: PUSH
57126: LD_VAR 0 8
57130: PUSH
57131: LD_VAR 0 6
57135: ARRAY
57136: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57137: LD_ADDR_VAR 0 8
57141: PUSH
57142: LD_VAR 0 8
57146: PPUSH
57147: LD_VAR 0 6
57151: PPUSH
57152: CALL_OW 3
57156: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57157: LD_ADDR_VAR 0 8
57161: PUSH
57162: LD_VAR 0 8
57166: PPUSH
57167: LD_INT 1
57169: PPUSH
57170: LD_VAR 0 9
57174: PPUSH
57175: CALL_OW 2
57179: ST_TO_ADDR
// end ;
57180: GO 57097
57182: POP
57183: POP
// for i in tmp do
57184: LD_ADDR_VAR 0 6
57188: PUSH
57189: LD_VAR 0 8
57193: PUSH
57194: FOR_IN
57195: IFFALSE 57264
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57197: LD_VAR 0 6
57201: PPUSH
57202: CALL_OW 313
57206: PUSH
57207: LD_INT 6
57209: LESS
57210: PUSH
57211: LD_VAR 0 6
57215: PPUSH
57216: CALL_OW 266
57220: PUSH
57221: LD_INT 31
57223: PUSH
57224: LD_INT 32
57226: PUSH
57227: EMPTY
57228: LIST
57229: LIST
57230: IN
57231: NOT
57232: AND
57233: PUSH
57234: LD_VAR 0 6
57238: PPUSH
57239: CALL_OW 313
57243: PUSH
57244: LD_INT 0
57246: EQUAL
57247: OR
57248: IFFALSE 57262
// begin j := i ;
57250: LD_ADDR_VAR 0 7
57254: PUSH
57255: LD_VAR 0 6
57259: ST_TO_ADDR
// break ;
57260: GO 57264
// end ; end ;
57262: GO 57194
57264: POP
57265: POP
// if j then
57266: LD_VAR 0 7
57270: IFFALSE 57288
// ComEnterUnit ( unit , j ) else
57272: LD_VAR 0 3
57276: PPUSH
57277: LD_VAR 0 7
57281: PPUSH
57282: CALL_OW 120
57286: GO 57391
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57288: LD_ADDR_VAR 0 10
57292: PUSH
57293: LD_VAR 0 2
57297: PPUSH
57298: LD_INT 2
57300: PUSH
57301: LD_INT 30
57303: PUSH
57304: LD_INT 0
57306: PUSH
57307: EMPTY
57308: LIST
57309: LIST
57310: PUSH
57311: LD_INT 30
57313: PUSH
57314: LD_INT 1
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: LIST
57325: PPUSH
57326: CALL_OW 72
57330: ST_TO_ADDR
// if depot then
57331: LD_VAR 0 10
57335: IFFALSE 57391
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57337: LD_ADDR_VAR 0 10
57341: PUSH
57342: LD_VAR 0 10
57346: PPUSH
57347: LD_VAR 0 3
57351: PPUSH
57352: CALL_OW 74
57356: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57357: LD_VAR 0 3
57361: PPUSH
57362: LD_VAR 0 10
57366: PPUSH
57367: CALL_OW 296
57371: PUSH
57372: LD_INT 10
57374: GREATER
57375: IFFALSE 57391
// ComStandNearbyBuilding ( unit , depot ) ;
57377: LD_VAR 0 3
57381: PPUSH
57382: LD_VAR 0 10
57386: PPUSH
57387: CALL 65805 0 2
// end ; end ; end ;
57391: LD_VAR 0 5
57395: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57396: LD_INT 0
57398: PPUSH
57399: PPUSH
57400: PPUSH
57401: PPUSH
// if not mc_bases then
57402: LD_EXP 101
57406: NOT
57407: IFFALSE 57411
// exit ;
57409: GO 57650
// for i = 1 to mc_bases do
57411: LD_ADDR_VAR 0 2
57415: PUSH
57416: DOUBLE
57417: LD_INT 1
57419: DEC
57420: ST_TO_ADDR
57421: LD_EXP 101
57425: PUSH
57426: FOR_TO
57427: IFFALSE 57648
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57429: LD_ADDR_VAR 0 4
57433: PUSH
57434: LD_EXP 101
57438: PUSH
57439: LD_VAR 0 2
57443: ARRAY
57444: PPUSH
57445: LD_INT 21
57447: PUSH
57448: LD_INT 1
57450: PUSH
57451: EMPTY
57452: LIST
57453: LIST
57454: PPUSH
57455: CALL_OW 72
57459: PUSH
57460: LD_EXP 130
57464: PUSH
57465: LD_VAR 0 2
57469: ARRAY
57470: UNION
57471: ST_TO_ADDR
// if not tmp then
57472: LD_VAR 0 4
57476: NOT
57477: IFFALSE 57481
// continue ;
57479: GO 57426
// for j in tmp do
57481: LD_ADDR_VAR 0 3
57485: PUSH
57486: LD_VAR 0 4
57490: PUSH
57491: FOR_IN
57492: IFFALSE 57644
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57494: LD_VAR 0 3
57498: PPUSH
57499: CALL_OW 110
57503: NOT
57504: PUSH
57505: LD_VAR 0 3
57509: PPUSH
57510: CALL_OW 314
57514: NOT
57515: AND
57516: PUSH
57517: LD_VAR 0 3
57521: PPUSH
57522: CALL_OW 311
57526: NOT
57527: AND
57528: PUSH
57529: LD_VAR 0 3
57533: PPUSH
57534: CALL_OW 310
57538: NOT
57539: AND
57540: PUSH
57541: LD_VAR 0 3
57545: PUSH
57546: LD_EXP 104
57550: PUSH
57551: LD_VAR 0 2
57555: ARRAY
57556: PUSH
57557: LD_INT 1
57559: ARRAY
57560: IN
57561: NOT
57562: AND
57563: PUSH
57564: LD_VAR 0 3
57568: PUSH
57569: LD_EXP 104
57573: PUSH
57574: LD_VAR 0 2
57578: ARRAY
57579: PUSH
57580: LD_INT 2
57582: ARRAY
57583: IN
57584: NOT
57585: AND
57586: PUSH
57587: LD_VAR 0 3
57591: PUSH
57592: LD_EXP 113
57596: PUSH
57597: LD_VAR 0 2
57601: ARRAY
57602: IN
57603: NOT
57604: AND
57605: IFFALSE 57642
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57607: LD_VAR 0 2
57611: PPUSH
57612: LD_EXP 101
57616: PUSH
57617: LD_VAR 0 2
57621: ARRAY
57622: PPUSH
57623: LD_VAR 0 3
57627: PPUSH
57628: LD_VAR 0 3
57632: PPUSH
57633: CALL_OW 257
57637: PPUSH
57638: CALL 56414 0 4
// end ;
57642: GO 57491
57644: POP
57645: POP
// end ;
57646: GO 57426
57648: POP
57649: POP
// end ;
57650: LD_VAR 0 1
57654: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57655: LD_INT 0
57657: PPUSH
57658: PPUSH
57659: PPUSH
57660: PPUSH
57661: PPUSH
57662: PPUSH
// if not mc_bases [ base ] then
57663: LD_EXP 101
57667: PUSH
57668: LD_VAR 0 1
57672: ARRAY
57673: NOT
57674: IFFALSE 57678
// exit ;
57676: GO 57860
// tmp := [ ] ;
57678: LD_ADDR_VAR 0 6
57682: PUSH
57683: EMPTY
57684: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57685: LD_ADDR_VAR 0 7
57689: PUSH
57690: LD_VAR 0 3
57694: PPUSH
57695: LD_INT 0
57697: PPUSH
57698: CALL_OW 517
57702: ST_TO_ADDR
// if not list then
57703: LD_VAR 0 7
57707: NOT
57708: IFFALSE 57712
// exit ;
57710: GO 57860
// for i = 1 to amount do
57712: LD_ADDR_VAR 0 5
57716: PUSH
57717: DOUBLE
57718: LD_INT 1
57720: DEC
57721: ST_TO_ADDR
57722: LD_VAR 0 2
57726: PUSH
57727: FOR_TO
57728: IFFALSE 57808
// begin x := rand ( 1 , list [ 1 ] ) ;
57730: LD_ADDR_VAR 0 8
57734: PUSH
57735: LD_INT 1
57737: PPUSH
57738: LD_VAR 0 7
57742: PUSH
57743: LD_INT 1
57745: ARRAY
57746: PPUSH
57747: CALL_OW 12
57751: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57752: LD_ADDR_VAR 0 6
57756: PUSH
57757: LD_VAR 0 6
57761: PPUSH
57762: LD_VAR 0 5
57766: PPUSH
57767: LD_VAR 0 7
57771: PUSH
57772: LD_INT 1
57774: ARRAY
57775: PUSH
57776: LD_VAR 0 8
57780: ARRAY
57781: PUSH
57782: LD_VAR 0 7
57786: PUSH
57787: LD_INT 2
57789: ARRAY
57790: PUSH
57791: LD_VAR 0 8
57795: ARRAY
57796: PUSH
57797: EMPTY
57798: LIST
57799: LIST
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// end ;
57806: GO 57727
57808: POP
57809: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57810: LD_ADDR_EXP 114
57814: PUSH
57815: LD_EXP 114
57819: PPUSH
57820: LD_VAR 0 1
57824: PPUSH
57825: LD_VAR 0 6
57829: PPUSH
57830: CALL_OW 1
57834: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57835: LD_ADDR_EXP 116
57839: PUSH
57840: LD_EXP 116
57844: PPUSH
57845: LD_VAR 0 1
57849: PPUSH
57850: LD_VAR 0 3
57854: PPUSH
57855: CALL_OW 1
57859: ST_TO_ADDR
// end ;
57860: LD_VAR 0 4
57864: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57865: LD_INT 0
57867: PPUSH
// if not mc_bases [ base ] then
57868: LD_EXP 101
57872: PUSH
57873: LD_VAR 0 1
57877: ARRAY
57878: NOT
57879: IFFALSE 57883
// exit ;
57881: GO 57908
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57883: LD_ADDR_EXP 106
57887: PUSH
57888: LD_EXP 106
57892: PPUSH
57893: LD_VAR 0 1
57897: PPUSH
57898: LD_VAR 0 2
57902: PPUSH
57903: CALL_OW 1
57907: ST_TO_ADDR
// end ;
57908: LD_VAR 0 3
57912: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57913: LD_INT 0
57915: PPUSH
// if not mc_bases [ base ] then
57916: LD_EXP 101
57920: PUSH
57921: LD_VAR 0 1
57925: ARRAY
57926: NOT
57927: IFFALSE 57931
// exit ;
57929: GO 57968
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57931: LD_ADDR_EXP 106
57935: PUSH
57936: LD_EXP 106
57940: PPUSH
57941: LD_VAR 0 1
57945: PPUSH
57946: LD_EXP 106
57950: PUSH
57951: LD_VAR 0 1
57955: ARRAY
57956: PUSH
57957: LD_VAR 0 2
57961: UNION
57962: PPUSH
57963: CALL_OW 1
57967: ST_TO_ADDR
// end ;
57968: LD_VAR 0 3
57972: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57973: LD_INT 0
57975: PPUSH
// if not mc_bases [ base ] then
57976: LD_EXP 101
57980: PUSH
57981: LD_VAR 0 1
57985: ARRAY
57986: NOT
57987: IFFALSE 57991
// exit ;
57989: GO 58016
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57991: LD_ADDR_EXP 122
57995: PUSH
57996: LD_EXP 122
58000: PPUSH
58001: LD_VAR 0 1
58005: PPUSH
58006: LD_VAR 0 2
58010: PPUSH
58011: CALL_OW 1
58015: ST_TO_ADDR
// end ;
58016: LD_VAR 0 3
58020: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58021: LD_INT 0
58023: PPUSH
// if not mc_bases [ base ] then
58024: LD_EXP 101
58028: PUSH
58029: LD_VAR 0 1
58033: ARRAY
58034: NOT
58035: IFFALSE 58039
// exit ;
58037: GO 58076
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58039: LD_ADDR_EXP 122
58043: PUSH
58044: LD_EXP 122
58048: PPUSH
58049: LD_VAR 0 1
58053: PPUSH
58054: LD_EXP 122
58058: PUSH
58059: LD_VAR 0 1
58063: ARRAY
58064: PUSH
58065: LD_VAR 0 2
58069: ADD
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
// end ;
58076: LD_VAR 0 3
58080: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58081: LD_INT 0
58083: PPUSH
// if not mc_bases [ base ] then
58084: LD_EXP 101
58088: PUSH
58089: LD_VAR 0 1
58093: ARRAY
58094: NOT
58095: IFFALSE 58099
// exit ;
58097: GO 58153
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58099: LD_ADDR_EXP 123
58103: PUSH
58104: LD_EXP 123
58108: PPUSH
58109: LD_VAR 0 1
58113: PPUSH
58114: LD_VAR 0 2
58118: PPUSH
58119: CALL_OW 1
58123: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58124: LD_ADDR_EXP 112
58128: PUSH
58129: LD_EXP 112
58133: PPUSH
58134: LD_VAR 0 1
58138: PPUSH
58139: LD_VAR 0 2
58143: PUSH
58144: LD_INT 0
58146: PLUS
58147: PPUSH
58148: CALL_OW 1
58152: ST_TO_ADDR
// end ;
58153: LD_VAR 0 3
58157: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58158: LD_INT 0
58160: PPUSH
// if not mc_bases [ base ] then
58161: LD_EXP 101
58165: PUSH
58166: LD_VAR 0 1
58170: ARRAY
58171: NOT
58172: IFFALSE 58176
// exit ;
58174: GO 58201
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58176: LD_ADDR_EXP 112
58180: PUSH
58181: LD_EXP 112
58185: PPUSH
58186: LD_VAR 0 1
58190: PPUSH
58191: LD_VAR 0 2
58195: PPUSH
58196: CALL_OW 1
58200: ST_TO_ADDR
// end ;
58201: LD_VAR 0 3
58205: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58206: LD_INT 0
58208: PPUSH
58209: PPUSH
58210: PPUSH
58211: PPUSH
// if not mc_bases [ base ] then
58212: LD_EXP 101
58216: PUSH
58217: LD_VAR 0 1
58221: ARRAY
58222: NOT
58223: IFFALSE 58227
// exit ;
58225: GO 58292
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58227: LD_ADDR_EXP 121
58231: PUSH
58232: LD_EXP 121
58236: PPUSH
58237: LD_VAR 0 1
58241: PUSH
58242: LD_EXP 121
58246: PUSH
58247: LD_VAR 0 1
58251: ARRAY
58252: PUSH
58253: LD_INT 1
58255: PLUS
58256: PUSH
58257: EMPTY
58258: LIST
58259: LIST
58260: PPUSH
58261: LD_VAR 0 1
58265: PUSH
58266: LD_VAR 0 2
58270: PUSH
58271: LD_VAR 0 3
58275: PUSH
58276: LD_VAR 0 4
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: LIST
58285: LIST
58286: PPUSH
58287: CALL 71602 0 3
58291: ST_TO_ADDR
// end ;
58292: LD_VAR 0 5
58296: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58297: LD_INT 0
58299: PPUSH
// if not mc_bases [ base ] then
58300: LD_EXP 101
58304: PUSH
58305: LD_VAR 0 1
58309: ARRAY
58310: NOT
58311: IFFALSE 58315
// exit ;
58313: GO 58340
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58315: LD_ADDR_EXP 138
58319: PUSH
58320: LD_EXP 138
58324: PPUSH
58325: LD_VAR 0 1
58329: PPUSH
58330: LD_VAR 0 2
58334: PPUSH
58335: CALL_OW 1
58339: ST_TO_ADDR
// end ;
58340: LD_VAR 0 3
58344: RET
// export function MC_GetMinesField ( base ) ; begin
58345: LD_INT 0
58347: PPUSH
// result := mc_mines [ base ] ;
58348: LD_ADDR_VAR 0 2
58352: PUSH
58353: LD_EXP 114
58357: PUSH
58358: LD_VAR 0 1
58362: ARRAY
58363: ST_TO_ADDR
// end ;
58364: LD_VAR 0 2
58368: RET
// export function MC_GetProduceList ( base ) ; begin
58369: LD_INT 0
58371: PPUSH
// result := mc_produce [ base ] ;
58372: LD_ADDR_VAR 0 2
58376: PUSH
58377: LD_EXP 122
58381: PUSH
58382: LD_VAR 0 1
58386: ARRAY
58387: ST_TO_ADDR
// end ;
58388: LD_VAR 0 2
58392: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58393: LD_INT 0
58395: PPUSH
58396: PPUSH
// if not mc_bases then
58397: LD_EXP 101
58401: NOT
58402: IFFALSE 58406
// exit ;
58404: GO 58471
// if mc_bases [ base ] then
58406: LD_EXP 101
58410: PUSH
58411: LD_VAR 0 1
58415: ARRAY
58416: IFFALSE 58471
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58418: LD_ADDR_VAR 0 3
58422: PUSH
58423: LD_EXP 101
58427: PUSH
58428: LD_VAR 0 1
58432: ARRAY
58433: PPUSH
58434: LD_INT 30
58436: PUSH
58437: LD_VAR 0 2
58441: PUSH
58442: EMPTY
58443: LIST
58444: LIST
58445: PPUSH
58446: CALL_OW 72
58450: ST_TO_ADDR
// if result then
58451: LD_VAR 0 3
58455: IFFALSE 58471
// result := result [ 1 ] ;
58457: LD_ADDR_VAR 0 3
58461: PUSH
58462: LD_VAR 0 3
58466: PUSH
58467: LD_INT 1
58469: ARRAY
58470: ST_TO_ADDR
// end ; end ;
58471: LD_VAR 0 3
58475: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58476: LD_INT 0
58478: PPUSH
58479: PPUSH
// if not mc_bases then
58480: LD_EXP 101
58484: NOT
58485: IFFALSE 58489
// exit ;
58487: GO 58534
// if mc_bases [ base ] then
58489: LD_EXP 101
58493: PUSH
58494: LD_VAR 0 1
58498: ARRAY
58499: IFFALSE 58534
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58501: LD_ADDR_VAR 0 3
58505: PUSH
58506: LD_EXP 101
58510: PUSH
58511: LD_VAR 0 1
58515: ARRAY
58516: PPUSH
58517: LD_INT 30
58519: PUSH
58520: LD_VAR 0 2
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: PPUSH
58529: CALL_OW 72
58533: ST_TO_ADDR
// end ;
58534: LD_VAR 0 3
58538: RET
// export function MC_SetTame ( base , area ) ; begin
58539: LD_INT 0
58541: PPUSH
// if not mc_bases or not base then
58542: LD_EXP 101
58546: NOT
58547: PUSH
58548: LD_VAR 0 1
58552: NOT
58553: OR
58554: IFFALSE 58558
// exit ;
58556: GO 58583
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58558: LD_ADDR_EXP 129
58562: PUSH
58563: LD_EXP 129
58567: PPUSH
58568: LD_VAR 0 1
58572: PPUSH
58573: LD_VAR 0 2
58577: PPUSH
58578: CALL_OW 1
58582: ST_TO_ADDR
// end ;
58583: LD_VAR 0 3
58587: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58588: LD_INT 0
58590: PPUSH
58591: PPUSH
// if not mc_bases or not base then
58592: LD_EXP 101
58596: NOT
58597: PUSH
58598: LD_VAR 0 1
58602: NOT
58603: OR
58604: IFFALSE 58608
// exit ;
58606: GO 58710
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58608: LD_ADDR_VAR 0 4
58612: PUSH
58613: LD_EXP 101
58617: PUSH
58618: LD_VAR 0 1
58622: ARRAY
58623: PPUSH
58624: LD_INT 30
58626: PUSH
58627: LD_VAR 0 2
58631: PUSH
58632: EMPTY
58633: LIST
58634: LIST
58635: PPUSH
58636: CALL_OW 72
58640: ST_TO_ADDR
// if not tmp then
58641: LD_VAR 0 4
58645: NOT
58646: IFFALSE 58650
// exit ;
58648: GO 58710
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58650: LD_ADDR_EXP 133
58654: PUSH
58655: LD_EXP 133
58659: PPUSH
58660: LD_VAR 0 1
58664: PPUSH
58665: LD_EXP 133
58669: PUSH
58670: LD_VAR 0 1
58674: ARRAY
58675: PPUSH
58676: LD_EXP 133
58680: PUSH
58681: LD_VAR 0 1
58685: ARRAY
58686: PUSH
58687: LD_INT 1
58689: PLUS
58690: PPUSH
58691: LD_VAR 0 4
58695: PUSH
58696: LD_INT 1
58698: ARRAY
58699: PPUSH
58700: CALL_OW 2
58704: PPUSH
58705: CALL_OW 1
58709: ST_TO_ADDR
// end ;
58710: LD_VAR 0 3
58714: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58715: LD_INT 0
58717: PPUSH
58718: PPUSH
// if not mc_bases or not base or not kinds then
58719: LD_EXP 101
58723: NOT
58724: PUSH
58725: LD_VAR 0 1
58729: NOT
58730: OR
58731: PUSH
58732: LD_VAR 0 2
58736: NOT
58737: OR
58738: IFFALSE 58742
// exit ;
58740: GO 58803
// for i in kinds do
58742: LD_ADDR_VAR 0 4
58746: PUSH
58747: LD_VAR 0 2
58751: PUSH
58752: FOR_IN
58753: IFFALSE 58801
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58755: LD_ADDR_EXP 135
58759: PUSH
58760: LD_EXP 135
58764: PPUSH
58765: LD_VAR 0 1
58769: PUSH
58770: LD_EXP 135
58774: PUSH
58775: LD_VAR 0 1
58779: ARRAY
58780: PUSH
58781: LD_INT 1
58783: PLUS
58784: PUSH
58785: EMPTY
58786: LIST
58787: LIST
58788: PPUSH
58789: LD_VAR 0 4
58793: PPUSH
58794: CALL 71602 0 3
58798: ST_TO_ADDR
58799: GO 58752
58801: POP
58802: POP
// end ;
58803: LD_VAR 0 3
58807: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58808: LD_INT 0
58810: PPUSH
// if not mc_bases or not base or not areas then
58811: LD_EXP 101
58815: NOT
58816: PUSH
58817: LD_VAR 0 1
58821: NOT
58822: OR
58823: PUSH
58824: LD_VAR 0 2
58828: NOT
58829: OR
58830: IFFALSE 58834
// exit ;
58832: GO 58859
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58834: LD_ADDR_EXP 119
58838: PUSH
58839: LD_EXP 119
58843: PPUSH
58844: LD_VAR 0 1
58848: PPUSH
58849: LD_VAR 0 2
58853: PPUSH
58854: CALL_OW 1
58858: ST_TO_ADDR
// end ;
58859: LD_VAR 0 3
58863: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58864: LD_INT 0
58866: PPUSH
// if not mc_bases or not base or not teleports_exit then
58867: LD_EXP 101
58871: NOT
58872: PUSH
58873: LD_VAR 0 1
58877: NOT
58878: OR
58879: PUSH
58880: LD_VAR 0 2
58884: NOT
58885: OR
58886: IFFALSE 58890
// exit ;
58888: GO 58915
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58890: LD_ADDR_EXP 136
58894: PUSH
58895: LD_EXP 136
58899: PPUSH
58900: LD_VAR 0 1
58904: PPUSH
58905: LD_VAR 0 2
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// end ;
58915: LD_VAR 0 3
58919: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58920: LD_INT 0
58922: PPUSH
58923: PPUSH
58924: PPUSH
// if not mc_bases or not base or not ext_list then
58925: LD_EXP 101
58929: NOT
58930: PUSH
58931: LD_VAR 0 1
58935: NOT
58936: OR
58937: PUSH
58938: LD_VAR 0 5
58942: NOT
58943: OR
58944: IFFALSE 58948
// exit ;
58946: GO 59121
// tmp := GetFacExtXYD ( x , y , d ) ;
58948: LD_ADDR_VAR 0 8
58952: PUSH
58953: LD_VAR 0 2
58957: PPUSH
58958: LD_VAR 0 3
58962: PPUSH
58963: LD_VAR 0 4
58967: PPUSH
58968: CALL 104980 0 3
58972: ST_TO_ADDR
// if not tmp then
58973: LD_VAR 0 8
58977: NOT
58978: IFFALSE 58982
// exit ;
58980: GO 59121
// for i in tmp do
58982: LD_ADDR_VAR 0 7
58986: PUSH
58987: LD_VAR 0 8
58991: PUSH
58992: FOR_IN
58993: IFFALSE 59119
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58995: LD_ADDR_EXP 106
58999: PUSH
59000: LD_EXP 106
59004: PPUSH
59005: LD_VAR 0 1
59009: PPUSH
59010: LD_EXP 106
59014: PUSH
59015: LD_VAR 0 1
59019: ARRAY
59020: PPUSH
59021: LD_EXP 106
59025: PUSH
59026: LD_VAR 0 1
59030: ARRAY
59031: PUSH
59032: LD_INT 1
59034: PLUS
59035: PPUSH
59036: LD_VAR 0 5
59040: PUSH
59041: LD_INT 1
59043: ARRAY
59044: PUSH
59045: LD_VAR 0 7
59049: PUSH
59050: LD_INT 1
59052: ARRAY
59053: PUSH
59054: LD_VAR 0 7
59058: PUSH
59059: LD_INT 2
59061: ARRAY
59062: PUSH
59063: LD_VAR 0 7
59067: PUSH
59068: LD_INT 3
59070: ARRAY
59071: PUSH
59072: EMPTY
59073: LIST
59074: LIST
59075: LIST
59076: LIST
59077: PPUSH
59078: CALL_OW 2
59082: PPUSH
59083: CALL_OW 1
59087: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59088: LD_ADDR_VAR 0 5
59092: PUSH
59093: LD_VAR 0 5
59097: PPUSH
59098: LD_INT 1
59100: PPUSH
59101: CALL_OW 3
59105: ST_TO_ADDR
// if not ext_list then
59106: LD_VAR 0 5
59110: NOT
59111: IFFALSE 59117
// exit ;
59113: POP
59114: POP
59115: GO 59121
// end ;
59117: GO 58992
59119: POP
59120: POP
// end ;
59121: LD_VAR 0 6
59125: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59126: LD_INT 0
59128: PPUSH
// if not mc_bases or not base or not weapon_list then
59129: LD_EXP 101
59133: NOT
59134: PUSH
59135: LD_VAR 0 1
59139: NOT
59140: OR
59141: PUSH
59142: LD_VAR 0 2
59146: NOT
59147: OR
59148: IFFALSE 59152
// exit ;
59150: GO 59177
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59152: LD_ADDR_EXP 140
59156: PUSH
59157: LD_EXP 140
59161: PPUSH
59162: LD_VAR 0 1
59166: PPUSH
59167: LD_VAR 0 2
59171: PPUSH
59172: CALL_OW 1
59176: ST_TO_ADDR
// end ;
59177: LD_VAR 0 3
59181: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59182: LD_INT 0
59184: PPUSH
// if not mc_bases or not base or not tech_list then
59185: LD_EXP 101
59189: NOT
59190: PUSH
59191: LD_VAR 0 1
59195: NOT
59196: OR
59197: PUSH
59198: LD_VAR 0 2
59202: NOT
59203: OR
59204: IFFALSE 59208
// exit ;
59206: GO 59233
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59208: LD_ADDR_EXP 128
59212: PUSH
59213: LD_EXP 128
59217: PPUSH
59218: LD_VAR 0 1
59222: PPUSH
59223: LD_VAR 0 2
59227: PPUSH
59228: CALL_OW 1
59232: ST_TO_ADDR
// end ;
59233: LD_VAR 0 3
59237: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59238: LD_INT 0
59240: PPUSH
// if not mc_bases or not parking_area or not base then
59241: LD_EXP 101
59245: NOT
59246: PUSH
59247: LD_VAR 0 2
59251: NOT
59252: OR
59253: PUSH
59254: LD_VAR 0 1
59258: NOT
59259: OR
59260: IFFALSE 59264
// exit ;
59262: GO 59289
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59264: LD_ADDR_EXP 125
59268: PUSH
59269: LD_EXP 125
59273: PPUSH
59274: LD_VAR 0 1
59278: PPUSH
59279: LD_VAR 0 2
59283: PPUSH
59284: CALL_OW 1
59288: ST_TO_ADDR
// end ;
59289: LD_VAR 0 3
59293: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59294: LD_INT 0
59296: PPUSH
// if not mc_bases or not base or not scan_area then
59297: LD_EXP 101
59301: NOT
59302: PUSH
59303: LD_VAR 0 1
59307: NOT
59308: OR
59309: PUSH
59310: LD_VAR 0 2
59314: NOT
59315: OR
59316: IFFALSE 59320
// exit ;
59318: GO 59345
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59320: LD_ADDR_EXP 126
59324: PUSH
59325: LD_EXP 126
59329: PPUSH
59330: LD_VAR 0 1
59334: PPUSH
59335: LD_VAR 0 2
59339: PPUSH
59340: CALL_OW 1
59344: ST_TO_ADDR
// end ;
59345: LD_VAR 0 3
59349: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59350: LD_INT 0
59352: PPUSH
59353: PPUSH
// if not mc_bases or not base then
59354: LD_EXP 101
59358: NOT
59359: PUSH
59360: LD_VAR 0 1
59364: NOT
59365: OR
59366: IFFALSE 59370
// exit ;
59368: GO 59434
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59370: LD_ADDR_VAR 0 3
59374: PUSH
59375: LD_INT 1
59377: PUSH
59378: LD_INT 2
59380: PUSH
59381: LD_INT 3
59383: PUSH
59384: LD_INT 4
59386: PUSH
59387: LD_INT 11
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59397: LD_ADDR_EXP 128
59401: PUSH
59402: LD_EXP 128
59406: PPUSH
59407: LD_VAR 0 1
59411: PPUSH
59412: LD_EXP 128
59416: PUSH
59417: LD_VAR 0 1
59421: ARRAY
59422: PUSH
59423: LD_VAR 0 3
59427: DIFF
59428: PPUSH
59429: CALL_OW 1
59433: ST_TO_ADDR
// end ;
59434: LD_VAR 0 2
59438: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59439: LD_INT 0
59441: PPUSH
// result := mc_vehicles [ base ] ;
59442: LD_ADDR_VAR 0 3
59446: PUSH
59447: LD_EXP 120
59451: PUSH
59452: LD_VAR 0 1
59456: ARRAY
59457: ST_TO_ADDR
// if onlyCombat then
59458: LD_VAR 0 2
59462: IFFALSE 59627
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59464: LD_ADDR_VAR 0 3
59468: PUSH
59469: LD_VAR 0 3
59473: PUSH
59474: LD_VAR 0 3
59478: PPUSH
59479: LD_INT 2
59481: PUSH
59482: LD_INT 34
59484: PUSH
59485: LD_INT 12
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: LD_INT 34
59494: PUSH
59495: LD_INT 51
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: LD_INT 34
59504: PUSH
59505: LD_EXP 95
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: LD_INT 34
59516: PUSH
59517: LD_INT 32
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 34
59526: PUSH
59527: LD_INT 13
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PUSH
59534: LD_INT 34
59536: PUSH
59537: LD_INT 52
59539: PUSH
59540: EMPTY
59541: LIST
59542: LIST
59543: PUSH
59544: LD_INT 34
59546: PUSH
59547: LD_INT 14
59549: PUSH
59550: EMPTY
59551: LIST
59552: LIST
59553: PUSH
59554: LD_INT 34
59556: PUSH
59557: LD_INT 53
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PUSH
59564: LD_INT 34
59566: PUSH
59567: LD_EXP 94
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: LD_INT 34
59578: PUSH
59579: LD_INT 31
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: LD_INT 34
59588: PUSH
59589: LD_INT 48
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: LD_INT 34
59598: PUSH
59599: LD_INT 8
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: LIST
59610: LIST
59611: LIST
59612: LIST
59613: LIST
59614: LIST
59615: LIST
59616: LIST
59617: LIST
59618: LIST
59619: LIST
59620: PPUSH
59621: CALL_OW 72
59625: DIFF
59626: ST_TO_ADDR
// end ; end_of_file
59627: LD_VAR 0 3
59631: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59632: LD_INT 0
59634: PPUSH
59635: PPUSH
59636: PPUSH
// if not mc_bases or not skirmish then
59637: LD_EXP 101
59641: NOT
59642: PUSH
59643: LD_EXP 99
59647: NOT
59648: OR
59649: IFFALSE 59653
// exit ;
59651: GO 59818
// for i = 1 to mc_bases do
59653: LD_ADDR_VAR 0 4
59657: PUSH
59658: DOUBLE
59659: LD_INT 1
59661: DEC
59662: ST_TO_ADDR
59663: LD_EXP 101
59667: PUSH
59668: FOR_TO
59669: IFFALSE 59816
// begin if sci in mc_bases [ i ] then
59671: LD_VAR 0 2
59675: PUSH
59676: LD_EXP 101
59680: PUSH
59681: LD_VAR 0 4
59685: ARRAY
59686: IN
59687: IFFALSE 59814
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59689: LD_ADDR_EXP 130
59693: PUSH
59694: LD_EXP 130
59698: PPUSH
59699: LD_VAR 0 4
59703: PUSH
59704: LD_EXP 130
59708: PUSH
59709: LD_VAR 0 4
59713: ARRAY
59714: PUSH
59715: LD_INT 1
59717: PLUS
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: PPUSH
59723: LD_VAR 0 1
59727: PPUSH
59728: CALL 71602 0 3
59732: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59733: LD_ADDR_VAR 0 5
59737: PUSH
59738: LD_EXP 101
59742: PUSH
59743: LD_VAR 0 4
59747: ARRAY
59748: PPUSH
59749: LD_INT 2
59751: PUSH
59752: LD_INT 30
59754: PUSH
59755: LD_INT 0
59757: PUSH
59758: EMPTY
59759: LIST
59760: LIST
59761: PUSH
59762: LD_INT 30
59764: PUSH
59765: LD_INT 1
59767: PUSH
59768: EMPTY
59769: LIST
59770: LIST
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: LIST
59776: PPUSH
59777: CALL_OW 72
59781: PPUSH
59782: LD_VAR 0 1
59786: PPUSH
59787: CALL_OW 74
59791: ST_TO_ADDR
// if tmp then
59792: LD_VAR 0 5
59796: IFFALSE 59812
// ComStandNearbyBuilding ( ape , tmp ) ;
59798: LD_VAR 0 1
59802: PPUSH
59803: LD_VAR 0 5
59807: PPUSH
59808: CALL 65805 0 2
// break ;
59812: GO 59816
// end ; end ;
59814: GO 59668
59816: POP
59817: POP
// end ;
59818: LD_VAR 0 3
59822: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59823: LD_INT 0
59825: PPUSH
59826: PPUSH
59827: PPUSH
// if not mc_bases or not skirmish then
59828: LD_EXP 101
59832: NOT
59833: PUSH
59834: LD_EXP 99
59838: NOT
59839: OR
59840: IFFALSE 59844
// exit ;
59842: GO 59933
// for i = 1 to mc_bases do
59844: LD_ADDR_VAR 0 4
59848: PUSH
59849: DOUBLE
59850: LD_INT 1
59852: DEC
59853: ST_TO_ADDR
59854: LD_EXP 101
59858: PUSH
59859: FOR_TO
59860: IFFALSE 59931
// begin if building in mc_busy_turret_list [ i ] then
59862: LD_VAR 0 1
59866: PUSH
59867: LD_EXP 111
59871: PUSH
59872: LD_VAR 0 4
59876: ARRAY
59877: IN
59878: IFFALSE 59929
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59880: LD_ADDR_VAR 0 5
59884: PUSH
59885: LD_EXP 111
59889: PUSH
59890: LD_VAR 0 4
59894: ARRAY
59895: PUSH
59896: LD_VAR 0 1
59900: DIFF
59901: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59902: LD_ADDR_EXP 111
59906: PUSH
59907: LD_EXP 111
59911: PPUSH
59912: LD_VAR 0 4
59916: PPUSH
59917: LD_VAR 0 5
59921: PPUSH
59922: CALL_OW 1
59926: ST_TO_ADDR
// break ;
59927: GO 59931
// end ; end ;
59929: GO 59859
59931: POP
59932: POP
// end ;
59933: LD_VAR 0 3
59937: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59938: LD_INT 0
59940: PPUSH
59941: PPUSH
59942: PPUSH
// if not mc_bases or not skirmish then
59943: LD_EXP 101
59947: NOT
59948: PUSH
59949: LD_EXP 99
59953: NOT
59954: OR
59955: IFFALSE 59959
// exit ;
59957: GO 60158
// for i = 1 to mc_bases do
59959: LD_ADDR_VAR 0 5
59963: PUSH
59964: DOUBLE
59965: LD_INT 1
59967: DEC
59968: ST_TO_ADDR
59969: LD_EXP 101
59973: PUSH
59974: FOR_TO
59975: IFFALSE 60156
// if building in mc_bases [ i ] then
59977: LD_VAR 0 1
59981: PUSH
59982: LD_EXP 101
59986: PUSH
59987: LD_VAR 0 5
59991: ARRAY
59992: IN
59993: IFFALSE 60154
// begin tmp := mc_bases [ i ] diff building ;
59995: LD_ADDR_VAR 0 6
59999: PUSH
60000: LD_EXP 101
60004: PUSH
60005: LD_VAR 0 5
60009: ARRAY
60010: PUSH
60011: LD_VAR 0 1
60015: DIFF
60016: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60017: LD_ADDR_EXP 101
60021: PUSH
60022: LD_EXP 101
60026: PPUSH
60027: LD_VAR 0 5
60031: PPUSH
60032: LD_VAR 0 6
60036: PPUSH
60037: CALL_OW 1
60041: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60042: LD_VAR 0 1
60046: PUSH
60047: LD_EXP 109
60051: PUSH
60052: LD_VAR 0 5
60056: ARRAY
60057: IN
60058: IFFALSE 60097
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60060: LD_ADDR_EXP 109
60064: PUSH
60065: LD_EXP 109
60069: PPUSH
60070: LD_VAR 0 5
60074: PPUSH
60075: LD_EXP 109
60079: PUSH
60080: LD_VAR 0 5
60084: ARRAY
60085: PUSH
60086: LD_VAR 0 1
60090: DIFF
60091: PPUSH
60092: CALL_OW 1
60096: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60097: LD_VAR 0 1
60101: PUSH
60102: LD_EXP 110
60106: PUSH
60107: LD_VAR 0 5
60111: ARRAY
60112: IN
60113: IFFALSE 60152
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60115: LD_ADDR_EXP 110
60119: PUSH
60120: LD_EXP 110
60124: PPUSH
60125: LD_VAR 0 5
60129: PPUSH
60130: LD_EXP 110
60134: PUSH
60135: LD_VAR 0 5
60139: ARRAY
60140: PUSH
60141: LD_VAR 0 1
60145: DIFF
60146: PPUSH
60147: CALL_OW 1
60151: ST_TO_ADDR
// break ;
60152: GO 60156
// end ;
60154: GO 59974
60156: POP
60157: POP
// end ;
60158: LD_VAR 0 4
60162: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60163: LD_INT 0
60165: PPUSH
60166: PPUSH
60167: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60168: LD_EXP 101
60172: NOT
60173: PUSH
60174: LD_EXP 99
60178: NOT
60179: OR
60180: PUSH
60181: LD_VAR 0 3
60185: PUSH
60186: LD_EXP 127
60190: IN
60191: NOT
60192: OR
60193: IFFALSE 60197
// exit ;
60195: GO 60320
// for i = 1 to mc_vehicles do
60197: LD_ADDR_VAR 0 6
60201: PUSH
60202: DOUBLE
60203: LD_INT 1
60205: DEC
60206: ST_TO_ADDR
60207: LD_EXP 120
60211: PUSH
60212: FOR_TO
60213: IFFALSE 60318
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60215: LD_VAR 0 2
60219: PUSH
60220: LD_EXP 120
60224: PUSH
60225: LD_VAR 0 6
60229: ARRAY
60230: IN
60231: PUSH
60232: LD_VAR 0 1
60236: PUSH
60237: LD_EXP 120
60241: PUSH
60242: LD_VAR 0 6
60246: ARRAY
60247: IN
60248: OR
60249: IFFALSE 60316
// begin tmp := mc_vehicles [ i ] diff old ;
60251: LD_ADDR_VAR 0 7
60255: PUSH
60256: LD_EXP 120
60260: PUSH
60261: LD_VAR 0 6
60265: ARRAY
60266: PUSH
60267: LD_VAR 0 2
60271: DIFF
60272: ST_TO_ADDR
// tmp := tmp diff new ;
60273: LD_ADDR_VAR 0 7
60277: PUSH
60278: LD_VAR 0 7
60282: PUSH
60283: LD_VAR 0 1
60287: DIFF
60288: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60289: LD_ADDR_EXP 120
60293: PUSH
60294: LD_EXP 120
60298: PPUSH
60299: LD_VAR 0 6
60303: PPUSH
60304: LD_VAR 0 7
60308: PPUSH
60309: CALL_OW 1
60313: ST_TO_ADDR
// break ;
60314: GO 60318
// end ;
60316: GO 60212
60318: POP
60319: POP
// end ;
60320: LD_VAR 0 5
60324: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60325: LD_INT 0
60327: PPUSH
60328: PPUSH
60329: PPUSH
60330: PPUSH
// if not mc_bases or not skirmish then
60331: LD_EXP 101
60335: NOT
60336: PUSH
60337: LD_EXP 99
60341: NOT
60342: OR
60343: IFFALSE 60347
// exit ;
60345: GO 60724
// side := GetSide ( vehicle ) ;
60347: LD_ADDR_VAR 0 5
60351: PUSH
60352: LD_VAR 0 1
60356: PPUSH
60357: CALL_OW 255
60361: ST_TO_ADDR
// for i = 1 to mc_bases do
60362: LD_ADDR_VAR 0 4
60366: PUSH
60367: DOUBLE
60368: LD_INT 1
60370: DEC
60371: ST_TO_ADDR
60372: LD_EXP 101
60376: PUSH
60377: FOR_TO
60378: IFFALSE 60722
// begin if factory in mc_bases [ i ] then
60380: LD_VAR 0 2
60384: PUSH
60385: LD_EXP 101
60389: PUSH
60390: LD_VAR 0 4
60394: ARRAY
60395: IN
60396: IFFALSE 60720
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60398: LD_EXP 123
60402: PUSH
60403: LD_VAR 0 4
60407: ARRAY
60408: PUSH
60409: LD_EXP 112
60413: PUSH
60414: LD_VAR 0 4
60418: ARRAY
60419: LESS
60420: PUSH
60421: LD_VAR 0 1
60425: PPUSH
60426: CALL_OW 264
60430: PUSH
60431: LD_INT 31
60433: PUSH
60434: LD_INT 32
60436: PUSH
60437: LD_INT 51
60439: PUSH
60440: LD_EXP 95
60444: PUSH
60445: LD_INT 12
60447: PUSH
60448: LD_INT 30
60450: PUSH
60451: LD_EXP 94
60455: PUSH
60456: LD_INT 11
60458: PUSH
60459: LD_INT 53
60461: PUSH
60462: LD_INT 14
60464: PUSH
60465: LD_EXP 98
60469: PUSH
60470: LD_INT 29
60472: PUSH
60473: LD_EXP 96
60477: PUSH
60478: LD_INT 13
60480: PUSH
60481: LD_INT 52
60483: PUSH
60484: LD_INT 48
60486: PUSH
60487: LD_INT 8
60489: PUSH
60490: EMPTY
60491: LIST
60492: LIST
60493: LIST
60494: LIST
60495: LIST
60496: LIST
60497: LIST
60498: LIST
60499: LIST
60500: LIST
60501: LIST
60502: LIST
60503: LIST
60504: LIST
60505: LIST
60506: LIST
60507: LIST
60508: IN
60509: NOT
60510: AND
60511: IFFALSE 60559
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60513: LD_ADDR_EXP 123
60517: PUSH
60518: LD_EXP 123
60522: PPUSH
60523: LD_VAR 0 4
60527: PUSH
60528: LD_EXP 123
60532: PUSH
60533: LD_VAR 0 4
60537: ARRAY
60538: PUSH
60539: LD_INT 1
60541: PLUS
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PPUSH
60547: LD_VAR 0 1
60551: PPUSH
60552: CALL 71602 0 3
60556: ST_TO_ADDR
60557: GO 60603
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60559: LD_ADDR_EXP 120
60563: PUSH
60564: LD_EXP 120
60568: PPUSH
60569: LD_VAR 0 4
60573: PUSH
60574: LD_EXP 120
60578: PUSH
60579: LD_VAR 0 4
60583: ARRAY
60584: PUSH
60585: LD_INT 1
60587: PLUS
60588: PUSH
60589: EMPTY
60590: LIST
60591: LIST
60592: PPUSH
60593: LD_VAR 0 1
60597: PPUSH
60598: CALL 71602 0 3
60602: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60603: LD_VAR 0 1
60607: PPUSH
60608: CALL_OW 263
60612: PUSH
60613: LD_INT 2
60615: EQUAL
60616: IFFALSE 60636
// begin repeat wait ( 0 0$1 ) ;
60618: LD_INT 35
60620: PPUSH
60621: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60625: LD_VAR 0 1
60629: PPUSH
60630: CALL_OW 312
60634: IFFALSE 60618
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60636: LD_VAR 0 1
60640: PPUSH
60641: LD_EXP 125
60645: PUSH
60646: LD_VAR 0 4
60650: ARRAY
60651: PPUSH
60652: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60656: LD_VAR 0 1
60660: PPUSH
60661: CALL_OW 263
60665: PUSH
60666: LD_INT 1
60668: NONEQUAL
60669: IFFALSE 60673
// break ;
60671: GO 60722
// repeat wait ( 0 0$1 ) ;
60673: LD_INT 35
60675: PPUSH
60676: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60680: LD_VAR 0 1
60684: PPUSH
60685: LD_EXP 125
60689: PUSH
60690: LD_VAR 0 4
60694: ARRAY
60695: PPUSH
60696: CALL_OW 308
60700: IFFALSE 60673
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60702: LD_VAR 0 1
60706: PPUSH
60707: CALL_OW 311
60711: PPUSH
60712: CALL_OW 121
// exit ;
60716: POP
60717: POP
60718: GO 60724
// end ; end ;
60720: GO 60377
60722: POP
60723: POP
// end ;
60724: LD_VAR 0 3
60728: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60729: LD_INT 0
60731: PPUSH
60732: PPUSH
60733: PPUSH
60734: PPUSH
// if not mc_bases or not skirmish then
60735: LD_EXP 101
60739: NOT
60740: PUSH
60741: LD_EXP 99
60745: NOT
60746: OR
60747: IFFALSE 60751
// exit ;
60749: GO 61104
// repeat wait ( 0 0$1 ) ;
60751: LD_INT 35
60753: PPUSH
60754: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60758: LD_VAR 0 2
60762: PPUSH
60763: LD_VAR 0 3
60767: PPUSH
60768: CALL_OW 284
60772: IFFALSE 60751
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60774: LD_VAR 0 2
60778: PPUSH
60779: LD_VAR 0 3
60783: PPUSH
60784: CALL_OW 283
60788: PUSH
60789: LD_INT 4
60791: EQUAL
60792: IFFALSE 60796
// exit ;
60794: GO 61104
// for i = 1 to mc_bases do
60796: LD_ADDR_VAR 0 7
60800: PUSH
60801: DOUBLE
60802: LD_INT 1
60804: DEC
60805: ST_TO_ADDR
60806: LD_EXP 101
60810: PUSH
60811: FOR_TO
60812: IFFALSE 61102
// begin if mc_crates_area [ i ] then
60814: LD_EXP 119
60818: PUSH
60819: LD_VAR 0 7
60823: ARRAY
60824: IFFALSE 60935
// for j in mc_crates_area [ i ] do
60826: LD_ADDR_VAR 0 8
60830: PUSH
60831: LD_EXP 119
60835: PUSH
60836: LD_VAR 0 7
60840: ARRAY
60841: PUSH
60842: FOR_IN
60843: IFFALSE 60933
// if InArea ( x , y , j ) then
60845: LD_VAR 0 2
60849: PPUSH
60850: LD_VAR 0 3
60854: PPUSH
60855: LD_VAR 0 8
60859: PPUSH
60860: CALL_OW 309
60864: IFFALSE 60931
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60866: LD_ADDR_EXP 117
60870: PUSH
60871: LD_EXP 117
60875: PPUSH
60876: LD_VAR 0 7
60880: PUSH
60881: LD_EXP 117
60885: PUSH
60886: LD_VAR 0 7
60890: ARRAY
60891: PUSH
60892: LD_INT 1
60894: PLUS
60895: PUSH
60896: EMPTY
60897: LIST
60898: LIST
60899: PPUSH
60900: LD_VAR 0 4
60904: PUSH
60905: LD_VAR 0 2
60909: PUSH
60910: LD_VAR 0 3
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: LIST
60919: PPUSH
60920: CALL 71602 0 3
60924: ST_TO_ADDR
// exit ;
60925: POP
60926: POP
60927: POP
60928: POP
60929: GO 61104
// end ;
60931: GO 60842
60933: POP
60934: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60935: LD_ADDR_VAR 0 9
60939: PUSH
60940: LD_EXP 101
60944: PUSH
60945: LD_VAR 0 7
60949: ARRAY
60950: PPUSH
60951: LD_INT 2
60953: PUSH
60954: LD_INT 30
60956: PUSH
60957: LD_INT 0
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: LD_INT 30
60966: PUSH
60967: LD_INT 1
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: LIST
60978: PPUSH
60979: CALL_OW 72
60983: ST_TO_ADDR
// if not depot then
60984: LD_VAR 0 9
60988: NOT
60989: IFFALSE 60993
// continue ;
60991: GO 60811
// for j in depot do
60993: LD_ADDR_VAR 0 8
60997: PUSH
60998: LD_VAR 0 9
61002: PUSH
61003: FOR_IN
61004: IFFALSE 61098
// if GetDistUnitXY ( j , x , y ) < 30 then
61006: LD_VAR 0 8
61010: PPUSH
61011: LD_VAR 0 2
61015: PPUSH
61016: LD_VAR 0 3
61020: PPUSH
61021: CALL_OW 297
61025: PUSH
61026: LD_INT 30
61028: LESS
61029: IFFALSE 61096
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61031: LD_ADDR_EXP 117
61035: PUSH
61036: LD_EXP 117
61040: PPUSH
61041: LD_VAR 0 7
61045: PUSH
61046: LD_EXP 117
61050: PUSH
61051: LD_VAR 0 7
61055: ARRAY
61056: PUSH
61057: LD_INT 1
61059: PLUS
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PPUSH
61065: LD_VAR 0 4
61069: PUSH
61070: LD_VAR 0 2
61074: PUSH
61075: LD_VAR 0 3
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: LIST
61084: PPUSH
61085: CALL 71602 0 3
61089: ST_TO_ADDR
// exit ;
61090: POP
61091: POP
61092: POP
61093: POP
61094: GO 61104
// end ;
61096: GO 61003
61098: POP
61099: POP
// end ;
61100: GO 60811
61102: POP
61103: POP
// end ;
61104: LD_VAR 0 6
61108: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61109: LD_INT 0
61111: PPUSH
61112: PPUSH
61113: PPUSH
61114: PPUSH
// if not mc_bases or not skirmish then
61115: LD_EXP 101
61119: NOT
61120: PUSH
61121: LD_EXP 99
61125: NOT
61126: OR
61127: IFFALSE 61131
// exit ;
61129: GO 61408
// side := GetSide ( lab ) ;
61131: LD_ADDR_VAR 0 4
61135: PUSH
61136: LD_VAR 0 2
61140: PPUSH
61141: CALL_OW 255
61145: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61146: LD_VAR 0 4
61150: PUSH
61151: LD_EXP 127
61155: IN
61156: NOT
61157: PUSH
61158: LD_EXP 128
61162: NOT
61163: OR
61164: PUSH
61165: LD_EXP 101
61169: NOT
61170: OR
61171: IFFALSE 61175
// exit ;
61173: GO 61408
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61175: LD_ADDR_EXP 128
61179: PUSH
61180: LD_EXP 128
61184: PPUSH
61185: LD_VAR 0 4
61189: PPUSH
61190: LD_EXP 128
61194: PUSH
61195: LD_VAR 0 4
61199: ARRAY
61200: PUSH
61201: LD_VAR 0 1
61205: DIFF
61206: PPUSH
61207: CALL_OW 1
61211: ST_TO_ADDR
// for i = 1 to mc_bases do
61212: LD_ADDR_VAR 0 5
61216: PUSH
61217: DOUBLE
61218: LD_INT 1
61220: DEC
61221: ST_TO_ADDR
61222: LD_EXP 101
61226: PUSH
61227: FOR_TO
61228: IFFALSE 61406
// begin if lab in mc_bases [ i ] then
61230: LD_VAR 0 2
61234: PUSH
61235: LD_EXP 101
61239: PUSH
61240: LD_VAR 0 5
61244: ARRAY
61245: IN
61246: IFFALSE 61404
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61248: LD_VAR 0 1
61252: PUSH
61253: LD_INT 11
61255: PUSH
61256: LD_INT 4
61258: PUSH
61259: LD_INT 3
61261: PUSH
61262: LD_INT 2
61264: PUSH
61265: EMPTY
61266: LIST
61267: LIST
61268: LIST
61269: LIST
61270: IN
61271: PUSH
61272: LD_EXP 131
61276: PUSH
61277: LD_VAR 0 5
61281: ARRAY
61282: AND
61283: IFFALSE 61404
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61285: LD_ADDR_VAR 0 6
61289: PUSH
61290: LD_EXP 131
61294: PUSH
61295: LD_VAR 0 5
61299: ARRAY
61300: PUSH
61301: LD_INT 1
61303: ARRAY
61304: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61305: LD_ADDR_EXP 131
61309: PUSH
61310: LD_EXP 131
61314: PPUSH
61315: LD_VAR 0 5
61319: PPUSH
61320: EMPTY
61321: PPUSH
61322: CALL_OW 1
61326: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61327: LD_VAR 0 6
61331: PPUSH
61332: LD_INT 0
61334: PPUSH
61335: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61339: LD_VAR 0 6
61343: PPUSH
61344: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61348: LD_ADDR_EXP 130
61352: PUSH
61353: LD_EXP 130
61357: PPUSH
61358: LD_VAR 0 5
61362: PPUSH
61363: LD_EXP 130
61367: PUSH
61368: LD_VAR 0 5
61372: ARRAY
61373: PPUSH
61374: LD_INT 1
61376: PPUSH
61377: LD_VAR 0 6
61381: PPUSH
61382: CALL_OW 2
61386: PPUSH
61387: CALL_OW 1
61391: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61392: LD_VAR 0 5
61396: PPUSH
61397: LD_INT 112
61399: PPUSH
61400: CALL 38300 0 2
// end ; end ; end ;
61404: GO 61227
61406: POP
61407: POP
// end ;
61408: LD_VAR 0 3
61412: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61413: LD_INT 0
61415: PPUSH
61416: PPUSH
61417: PPUSH
61418: PPUSH
61419: PPUSH
61420: PPUSH
61421: PPUSH
61422: PPUSH
// if not mc_bases or not skirmish then
61423: LD_EXP 101
61427: NOT
61428: PUSH
61429: LD_EXP 99
61433: NOT
61434: OR
61435: IFFALSE 61439
// exit ;
61437: GO 62810
// for i = 1 to mc_bases do
61439: LD_ADDR_VAR 0 3
61443: PUSH
61444: DOUBLE
61445: LD_INT 1
61447: DEC
61448: ST_TO_ADDR
61449: LD_EXP 101
61453: PUSH
61454: FOR_TO
61455: IFFALSE 62808
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61457: LD_VAR 0 1
61461: PUSH
61462: LD_EXP 101
61466: PUSH
61467: LD_VAR 0 3
61471: ARRAY
61472: IN
61473: PUSH
61474: LD_VAR 0 1
61478: PUSH
61479: LD_EXP 108
61483: PUSH
61484: LD_VAR 0 3
61488: ARRAY
61489: IN
61490: OR
61491: PUSH
61492: LD_VAR 0 1
61496: PUSH
61497: LD_EXP 123
61501: PUSH
61502: LD_VAR 0 3
61506: ARRAY
61507: IN
61508: OR
61509: PUSH
61510: LD_VAR 0 1
61514: PUSH
61515: LD_EXP 120
61519: PUSH
61520: LD_VAR 0 3
61524: ARRAY
61525: IN
61526: OR
61527: PUSH
61528: LD_VAR 0 1
61532: PUSH
61533: LD_EXP 130
61537: PUSH
61538: LD_VAR 0 3
61542: ARRAY
61543: IN
61544: OR
61545: PUSH
61546: LD_VAR 0 1
61550: PUSH
61551: LD_EXP 131
61555: PUSH
61556: LD_VAR 0 3
61560: ARRAY
61561: IN
61562: OR
61563: IFFALSE 62806
// begin if un in mc_ape [ i ] then
61565: LD_VAR 0 1
61569: PUSH
61570: LD_EXP 130
61574: PUSH
61575: LD_VAR 0 3
61579: ARRAY
61580: IN
61581: IFFALSE 61620
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61583: LD_ADDR_EXP 130
61587: PUSH
61588: LD_EXP 130
61592: PPUSH
61593: LD_VAR 0 3
61597: PPUSH
61598: LD_EXP 130
61602: PUSH
61603: LD_VAR 0 3
61607: ARRAY
61608: PUSH
61609: LD_VAR 0 1
61613: DIFF
61614: PPUSH
61615: CALL_OW 1
61619: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61620: LD_VAR 0 1
61624: PUSH
61625: LD_EXP 131
61629: PUSH
61630: LD_VAR 0 3
61634: ARRAY
61635: IN
61636: IFFALSE 61660
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61638: LD_ADDR_EXP 131
61642: PUSH
61643: LD_EXP 131
61647: PPUSH
61648: LD_VAR 0 3
61652: PPUSH
61653: EMPTY
61654: PPUSH
61655: CALL_OW 1
61659: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61660: LD_VAR 0 1
61664: PPUSH
61665: CALL_OW 247
61669: PUSH
61670: LD_INT 2
61672: EQUAL
61673: PUSH
61674: LD_VAR 0 1
61678: PPUSH
61679: CALL_OW 110
61683: PUSH
61684: LD_INT 20
61686: EQUAL
61687: PUSH
61688: LD_VAR 0 1
61692: PUSH
61693: LD_EXP 123
61697: PUSH
61698: LD_VAR 0 3
61702: ARRAY
61703: IN
61704: OR
61705: PUSH
61706: LD_VAR 0 1
61710: PPUSH
61711: CALL_OW 264
61715: PUSH
61716: LD_INT 12
61718: PUSH
61719: LD_INT 51
61721: PUSH
61722: LD_EXP 95
61726: PUSH
61727: LD_INT 32
61729: PUSH
61730: LD_INT 13
61732: PUSH
61733: LD_INT 52
61735: PUSH
61736: LD_INT 31
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: LIST
61743: LIST
61744: LIST
61745: LIST
61746: LIST
61747: IN
61748: OR
61749: AND
61750: IFFALSE 62058
// begin if un in mc_defender [ i ] then
61752: LD_VAR 0 1
61756: PUSH
61757: LD_EXP 123
61761: PUSH
61762: LD_VAR 0 3
61766: ARRAY
61767: IN
61768: IFFALSE 61807
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61770: LD_ADDR_EXP 123
61774: PUSH
61775: LD_EXP 123
61779: PPUSH
61780: LD_VAR 0 3
61784: PPUSH
61785: LD_EXP 123
61789: PUSH
61790: LD_VAR 0 3
61794: ARRAY
61795: PUSH
61796: LD_VAR 0 1
61800: DIFF
61801: PPUSH
61802: CALL_OW 1
61806: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61807: LD_ADDR_VAR 0 8
61811: PUSH
61812: LD_VAR 0 3
61816: PPUSH
61817: LD_INT 3
61819: PPUSH
61820: CALL 58476 0 2
61824: ST_TO_ADDR
// if fac then
61825: LD_VAR 0 8
61829: IFFALSE 62058
// begin for j in fac do
61831: LD_ADDR_VAR 0 4
61835: PUSH
61836: LD_VAR 0 8
61840: PUSH
61841: FOR_IN
61842: IFFALSE 62056
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61844: LD_ADDR_VAR 0 9
61848: PUSH
61849: LD_VAR 0 8
61853: PPUSH
61854: LD_VAR 0 1
61858: PPUSH
61859: CALL_OW 265
61863: PPUSH
61864: LD_VAR 0 1
61868: PPUSH
61869: CALL_OW 262
61873: PPUSH
61874: LD_VAR 0 1
61878: PPUSH
61879: CALL_OW 263
61883: PPUSH
61884: LD_VAR 0 1
61888: PPUSH
61889: CALL_OW 264
61893: PPUSH
61894: CALL 69134 0 5
61898: ST_TO_ADDR
// if components then
61899: LD_VAR 0 9
61903: IFFALSE 62054
// begin if GetWeapon ( un ) = ar_control_tower then
61905: LD_VAR 0 1
61909: PPUSH
61910: CALL_OW 264
61914: PUSH
61915: LD_INT 31
61917: EQUAL
61918: IFFALSE 62035
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61920: LD_VAR 0 1
61924: PPUSH
61925: CALL_OW 311
61929: PPUSH
61930: LD_INT 0
61932: PPUSH
61933: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61937: LD_ADDR_EXP 141
61941: PUSH
61942: LD_EXP 141
61946: PPUSH
61947: LD_VAR 0 3
61951: PPUSH
61952: LD_EXP 141
61956: PUSH
61957: LD_VAR 0 3
61961: ARRAY
61962: PUSH
61963: LD_VAR 0 1
61967: PPUSH
61968: CALL_OW 311
61972: DIFF
61973: PPUSH
61974: CALL_OW 1
61978: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61979: LD_ADDR_VAR 0 7
61983: PUSH
61984: LD_EXP 122
61988: PUSH
61989: LD_VAR 0 3
61993: ARRAY
61994: PPUSH
61995: LD_INT 1
61997: PPUSH
61998: LD_VAR 0 9
62002: PPUSH
62003: CALL_OW 2
62007: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62008: LD_ADDR_EXP 122
62012: PUSH
62013: LD_EXP 122
62017: PPUSH
62018: LD_VAR 0 3
62022: PPUSH
62023: LD_VAR 0 7
62027: PPUSH
62028: CALL_OW 1
62032: ST_TO_ADDR
// end else
62033: GO 62052
// MC_InsertProduceList ( i , [ components ] ) ;
62035: LD_VAR 0 3
62039: PPUSH
62040: LD_VAR 0 9
62044: PUSH
62045: EMPTY
62046: LIST
62047: PPUSH
62048: CALL 58021 0 2
// break ;
62052: GO 62056
// end ; end ;
62054: GO 61841
62056: POP
62057: POP
// end ; end ; if GetType ( un ) = unit_building then
62058: LD_VAR 0 1
62062: PPUSH
62063: CALL_OW 247
62067: PUSH
62068: LD_INT 3
62070: EQUAL
62071: IFFALSE 62474
// begin btype := GetBType ( un ) ;
62073: LD_ADDR_VAR 0 5
62077: PUSH
62078: LD_VAR 0 1
62082: PPUSH
62083: CALL_OW 266
62087: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62088: LD_VAR 0 5
62092: PUSH
62093: LD_INT 29
62095: PUSH
62096: LD_INT 30
62098: PUSH
62099: EMPTY
62100: LIST
62101: LIST
62102: IN
62103: IFFALSE 62176
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62105: LD_VAR 0 1
62109: PPUSH
62110: CALL_OW 250
62114: PPUSH
62115: LD_VAR 0 1
62119: PPUSH
62120: CALL_OW 251
62124: PPUSH
62125: LD_VAR 0 1
62129: PPUSH
62130: CALL_OW 255
62134: PPUSH
62135: CALL_OW 440
62139: NOT
62140: IFFALSE 62176
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 250
62151: PPUSH
62152: LD_VAR 0 1
62156: PPUSH
62157: CALL_OW 251
62161: PPUSH
62162: LD_VAR 0 1
62166: PPUSH
62167: CALL_OW 255
62171: PPUSH
62172: CALL_OW 441
// end ; if btype = b_warehouse then
62176: LD_VAR 0 5
62180: PUSH
62181: LD_INT 1
62183: EQUAL
62184: IFFALSE 62202
// begin btype := b_depot ;
62186: LD_ADDR_VAR 0 5
62190: PUSH
62191: LD_INT 0
62193: ST_TO_ADDR
// pos := 1 ;
62194: LD_ADDR_VAR 0 6
62198: PUSH
62199: LD_INT 1
62201: ST_TO_ADDR
// end ; if btype = b_factory then
62202: LD_VAR 0 5
62206: PUSH
62207: LD_INT 3
62209: EQUAL
62210: IFFALSE 62228
// begin btype := b_workshop ;
62212: LD_ADDR_VAR 0 5
62216: PUSH
62217: LD_INT 2
62219: ST_TO_ADDR
// pos := 1 ;
62220: LD_ADDR_VAR 0 6
62224: PUSH
62225: LD_INT 1
62227: ST_TO_ADDR
// end ; if btype = b_barracks then
62228: LD_VAR 0 5
62232: PUSH
62233: LD_INT 5
62235: EQUAL
62236: IFFALSE 62246
// btype := b_armoury ;
62238: LD_ADDR_VAR 0 5
62242: PUSH
62243: LD_INT 4
62245: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62246: LD_VAR 0 5
62250: PUSH
62251: LD_INT 7
62253: PUSH
62254: LD_INT 8
62256: PUSH
62257: EMPTY
62258: LIST
62259: LIST
62260: IN
62261: IFFALSE 62271
// btype := b_lab ;
62263: LD_ADDR_VAR 0 5
62267: PUSH
62268: LD_INT 6
62270: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62271: LD_ADDR_EXP 106
62275: PUSH
62276: LD_EXP 106
62280: PPUSH
62281: LD_VAR 0 3
62285: PUSH
62286: LD_EXP 106
62290: PUSH
62291: LD_VAR 0 3
62295: ARRAY
62296: PUSH
62297: LD_INT 1
62299: PLUS
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: PPUSH
62305: LD_VAR 0 5
62309: PUSH
62310: LD_VAR 0 1
62314: PPUSH
62315: CALL_OW 250
62319: PUSH
62320: LD_VAR 0 1
62324: PPUSH
62325: CALL_OW 251
62329: PUSH
62330: LD_VAR 0 1
62334: PPUSH
62335: CALL_OW 254
62339: PUSH
62340: EMPTY
62341: LIST
62342: LIST
62343: LIST
62344: LIST
62345: PPUSH
62346: CALL 71602 0 3
62350: ST_TO_ADDR
// if pos = 1 then
62351: LD_VAR 0 6
62355: PUSH
62356: LD_INT 1
62358: EQUAL
62359: IFFALSE 62474
// begin tmp := mc_build_list [ i ] ;
62361: LD_ADDR_VAR 0 7
62365: PUSH
62366: LD_EXP 106
62370: PUSH
62371: LD_VAR 0 3
62375: ARRAY
62376: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62377: LD_VAR 0 7
62381: PPUSH
62382: LD_INT 2
62384: PUSH
62385: LD_INT 30
62387: PUSH
62388: LD_INT 0
62390: PUSH
62391: EMPTY
62392: LIST
62393: LIST
62394: PUSH
62395: LD_INT 30
62397: PUSH
62398: LD_INT 1
62400: PUSH
62401: EMPTY
62402: LIST
62403: LIST
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: LIST
62409: PPUSH
62410: CALL_OW 72
62414: IFFALSE 62424
// pos := 2 ;
62416: LD_ADDR_VAR 0 6
62420: PUSH
62421: LD_INT 2
62423: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62424: LD_ADDR_VAR 0 7
62428: PUSH
62429: LD_VAR 0 7
62433: PPUSH
62434: LD_VAR 0 6
62438: PPUSH
62439: LD_VAR 0 7
62443: PPUSH
62444: CALL 71928 0 3
62448: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62449: LD_ADDR_EXP 106
62453: PUSH
62454: LD_EXP 106
62458: PPUSH
62459: LD_VAR 0 3
62463: PPUSH
62464: LD_VAR 0 7
62468: PPUSH
62469: CALL_OW 1
62473: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62474: LD_VAR 0 1
62478: PUSH
62479: LD_EXP 101
62483: PUSH
62484: LD_VAR 0 3
62488: ARRAY
62489: IN
62490: IFFALSE 62529
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62492: LD_ADDR_EXP 101
62496: PUSH
62497: LD_EXP 101
62501: PPUSH
62502: LD_VAR 0 3
62506: PPUSH
62507: LD_EXP 101
62511: PUSH
62512: LD_VAR 0 3
62516: ARRAY
62517: PUSH
62518: LD_VAR 0 1
62522: DIFF
62523: PPUSH
62524: CALL_OW 1
62528: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62529: LD_VAR 0 1
62533: PUSH
62534: LD_EXP 108
62538: PUSH
62539: LD_VAR 0 3
62543: ARRAY
62544: IN
62545: IFFALSE 62584
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62547: LD_ADDR_EXP 108
62551: PUSH
62552: LD_EXP 108
62556: PPUSH
62557: LD_VAR 0 3
62561: PPUSH
62562: LD_EXP 108
62566: PUSH
62567: LD_VAR 0 3
62571: ARRAY
62572: PUSH
62573: LD_VAR 0 1
62577: DIFF
62578: PPUSH
62579: CALL_OW 1
62583: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62584: LD_VAR 0 1
62588: PUSH
62589: LD_EXP 120
62593: PUSH
62594: LD_VAR 0 3
62598: ARRAY
62599: IN
62600: IFFALSE 62639
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62602: LD_ADDR_EXP 120
62606: PUSH
62607: LD_EXP 120
62611: PPUSH
62612: LD_VAR 0 3
62616: PPUSH
62617: LD_EXP 120
62621: PUSH
62622: LD_VAR 0 3
62626: ARRAY
62627: PUSH
62628: LD_VAR 0 1
62632: DIFF
62633: PPUSH
62634: CALL_OW 1
62638: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62639: LD_VAR 0 1
62643: PUSH
62644: LD_EXP 123
62648: PUSH
62649: LD_VAR 0 3
62653: ARRAY
62654: IN
62655: IFFALSE 62694
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62657: LD_ADDR_EXP 123
62661: PUSH
62662: LD_EXP 123
62666: PPUSH
62667: LD_VAR 0 3
62671: PPUSH
62672: LD_EXP 123
62676: PUSH
62677: LD_VAR 0 3
62681: ARRAY
62682: PUSH
62683: LD_VAR 0 1
62687: DIFF
62688: PPUSH
62689: CALL_OW 1
62693: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62694: LD_VAR 0 1
62698: PUSH
62699: LD_EXP 110
62703: PUSH
62704: LD_VAR 0 3
62708: ARRAY
62709: IN
62710: IFFALSE 62749
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62712: LD_ADDR_EXP 110
62716: PUSH
62717: LD_EXP 110
62721: PPUSH
62722: LD_VAR 0 3
62726: PPUSH
62727: LD_EXP 110
62731: PUSH
62732: LD_VAR 0 3
62736: ARRAY
62737: PUSH
62738: LD_VAR 0 1
62742: DIFF
62743: PPUSH
62744: CALL_OW 1
62748: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62749: LD_VAR 0 1
62753: PUSH
62754: LD_EXP 109
62758: PUSH
62759: LD_VAR 0 3
62763: ARRAY
62764: IN
62765: IFFALSE 62804
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62767: LD_ADDR_EXP 109
62771: PUSH
62772: LD_EXP 109
62776: PPUSH
62777: LD_VAR 0 3
62781: PPUSH
62782: LD_EXP 109
62786: PUSH
62787: LD_VAR 0 3
62791: ARRAY
62792: PUSH
62793: LD_VAR 0 1
62797: DIFF
62798: PPUSH
62799: CALL_OW 1
62803: ST_TO_ADDR
// end ; break ;
62804: GO 62808
// end ;
62806: GO 61454
62808: POP
62809: POP
// end ;
62810: LD_VAR 0 2
62814: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62815: LD_INT 0
62817: PPUSH
62818: PPUSH
62819: PPUSH
// if not mc_bases or not skirmish then
62820: LD_EXP 101
62824: NOT
62825: PUSH
62826: LD_EXP 99
62830: NOT
62831: OR
62832: IFFALSE 62836
// exit ;
62834: GO 63051
// for i = 1 to mc_bases do
62836: LD_ADDR_VAR 0 3
62840: PUSH
62841: DOUBLE
62842: LD_INT 1
62844: DEC
62845: ST_TO_ADDR
62846: LD_EXP 101
62850: PUSH
62851: FOR_TO
62852: IFFALSE 63049
// begin if building in mc_construct_list [ i ] then
62854: LD_VAR 0 1
62858: PUSH
62859: LD_EXP 108
62863: PUSH
62864: LD_VAR 0 3
62868: ARRAY
62869: IN
62870: IFFALSE 63047
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62872: LD_ADDR_EXP 108
62876: PUSH
62877: LD_EXP 108
62881: PPUSH
62882: LD_VAR 0 3
62886: PPUSH
62887: LD_EXP 108
62891: PUSH
62892: LD_VAR 0 3
62896: ARRAY
62897: PUSH
62898: LD_VAR 0 1
62902: DIFF
62903: PPUSH
62904: CALL_OW 1
62908: ST_TO_ADDR
// if building in mc_lab [ i ] then
62909: LD_VAR 0 1
62913: PUSH
62914: LD_EXP 134
62918: PUSH
62919: LD_VAR 0 3
62923: ARRAY
62924: IN
62925: IFFALSE 62980
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62927: LD_ADDR_EXP 135
62931: PUSH
62932: LD_EXP 135
62936: PPUSH
62937: LD_VAR 0 3
62941: PPUSH
62942: LD_EXP 135
62946: PUSH
62947: LD_VAR 0 3
62951: ARRAY
62952: PPUSH
62953: LD_INT 1
62955: PPUSH
62956: LD_EXP 135
62960: PUSH
62961: LD_VAR 0 3
62965: ARRAY
62966: PPUSH
62967: LD_INT 0
62969: PPUSH
62970: CALL 71020 0 4
62974: PPUSH
62975: CALL_OW 1
62979: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62980: LD_VAR 0 1
62984: PUSH
62985: LD_EXP 101
62989: PUSH
62990: LD_VAR 0 3
62994: ARRAY
62995: IN
62996: NOT
62997: IFFALSE 63043
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62999: LD_ADDR_EXP 101
63003: PUSH
63004: LD_EXP 101
63008: PPUSH
63009: LD_VAR 0 3
63013: PUSH
63014: LD_EXP 101
63018: PUSH
63019: LD_VAR 0 3
63023: ARRAY
63024: PUSH
63025: LD_INT 1
63027: PLUS
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PPUSH
63033: LD_VAR 0 1
63037: PPUSH
63038: CALL 71602 0 3
63042: ST_TO_ADDR
// exit ;
63043: POP
63044: POP
63045: GO 63051
// end ; end ;
63047: GO 62851
63049: POP
63050: POP
// end ;
63051: LD_VAR 0 2
63055: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63056: LD_INT 0
63058: PPUSH
63059: PPUSH
63060: PPUSH
63061: PPUSH
63062: PPUSH
63063: PPUSH
63064: PPUSH
// if not mc_bases or not skirmish then
63065: LD_EXP 101
63069: NOT
63070: PUSH
63071: LD_EXP 99
63075: NOT
63076: OR
63077: IFFALSE 63081
// exit ;
63079: GO 63742
// for i = 1 to mc_bases do
63081: LD_ADDR_VAR 0 3
63085: PUSH
63086: DOUBLE
63087: LD_INT 1
63089: DEC
63090: ST_TO_ADDR
63091: LD_EXP 101
63095: PUSH
63096: FOR_TO
63097: IFFALSE 63740
// begin if building in mc_construct_list [ i ] then
63099: LD_VAR 0 1
63103: PUSH
63104: LD_EXP 108
63108: PUSH
63109: LD_VAR 0 3
63113: ARRAY
63114: IN
63115: IFFALSE 63738
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63117: LD_ADDR_EXP 108
63121: PUSH
63122: LD_EXP 108
63126: PPUSH
63127: LD_VAR 0 3
63131: PPUSH
63132: LD_EXP 108
63136: PUSH
63137: LD_VAR 0 3
63141: ARRAY
63142: PUSH
63143: LD_VAR 0 1
63147: DIFF
63148: PPUSH
63149: CALL_OW 1
63153: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63154: LD_ADDR_EXP 101
63158: PUSH
63159: LD_EXP 101
63163: PPUSH
63164: LD_VAR 0 3
63168: PUSH
63169: LD_EXP 101
63173: PUSH
63174: LD_VAR 0 3
63178: ARRAY
63179: PUSH
63180: LD_INT 1
63182: PLUS
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PPUSH
63188: LD_VAR 0 1
63192: PPUSH
63193: CALL 71602 0 3
63197: ST_TO_ADDR
// btype := GetBType ( building ) ;
63198: LD_ADDR_VAR 0 5
63202: PUSH
63203: LD_VAR 0 1
63207: PPUSH
63208: CALL_OW 266
63212: ST_TO_ADDR
// side := GetSide ( building ) ;
63213: LD_ADDR_VAR 0 8
63217: PUSH
63218: LD_VAR 0 1
63222: PPUSH
63223: CALL_OW 255
63227: ST_TO_ADDR
// if btype = b_lab then
63228: LD_VAR 0 5
63232: PUSH
63233: LD_INT 6
63235: EQUAL
63236: IFFALSE 63286
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63238: LD_ADDR_EXP 134
63242: PUSH
63243: LD_EXP 134
63247: PPUSH
63248: LD_VAR 0 3
63252: PUSH
63253: LD_EXP 134
63257: PUSH
63258: LD_VAR 0 3
63262: ARRAY
63263: PUSH
63264: LD_INT 1
63266: PLUS
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PPUSH
63272: LD_VAR 0 1
63276: PPUSH
63277: CALL 71602 0 3
63281: ST_TO_ADDR
// exit ;
63282: POP
63283: POP
63284: GO 63742
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63286: LD_VAR 0 5
63290: PUSH
63291: LD_INT 0
63293: PUSH
63294: LD_INT 2
63296: PUSH
63297: LD_INT 4
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: LIST
63304: IN
63305: IFFALSE 63429
// begin if btype = b_armoury then
63307: LD_VAR 0 5
63311: PUSH
63312: LD_INT 4
63314: EQUAL
63315: IFFALSE 63325
// btype := b_barracks ;
63317: LD_ADDR_VAR 0 5
63321: PUSH
63322: LD_INT 5
63324: ST_TO_ADDR
// if btype = b_depot then
63325: LD_VAR 0 5
63329: PUSH
63330: LD_INT 0
63332: EQUAL
63333: IFFALSE 63343
// btype := b_warehouse ;
63335: LD_ADDR_VAR 0 5
63339: PUSH
63340: LD_INT 1
63342: ST_TO_ADDR
// if btype = b_workshop then
63343: LD_VAR 0 5
63347: PUSH
63348: LD_INT 2
63350: EQUAL
63351: IFFALSE 63361
// btype := b_factory ;
63353: LD_ADDR_VAR 0 5
63357: PUSH
63358: LD_INT 3
63360: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63361: LD_VAR 0 5
63365: PPUSH
63366: LD_VAR 0 8
63370: PPUSH
63371: CALL_OW 323
63375: PUSH
63376: LD_INT 1
63378: EQUAL
63379: IFFALSE 63425
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63381: LD_ADDR_EXP 133
63385: PUSH
63386: LD_EXP 133
63390: PPUSH
63391: LD_VAR 0 3
63395: PUSH
63396: LD_EXP 133
63400: PUSH
63401: LD_VAR 0 3
63405: ARRAY
63406: PUSH
63407: LD_INT 1
63409: PLUS
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PPUSH
63415: LD_VAR 0 1
63419: PPUSH
63420: CALL 71602 0 3
63424: ST_TO_ADDR
// exit ;
63425: POP
63426: POP
63427: GO 63742
// end ; if btype in [ b_bunker , b_turret ] then
63429: LD_VAR 0 5
63433: PUSH
63434: LD_INT 32
63436: PUSH
63437: LD_INT 33
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: IN
63444: IFFALSE 63734
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63446: LD_ADDR_EXP 109
63450: PUSH
63451: LD_EXP 109
63455: PPUSH
63456: LD_VAR 0 3
63460: PUSH
63461: LD_EXP 109
63465: PUSH
63466: LD_VAR 0 3
63470: ARRAY
63471: PUSH
63472: LD_INT 1
63474: PLUS
63475: PUSH
63476: EMPTY
63477: LIST
63478: LIST
63479: PPUSH
63480: LD_VAR 0 1
63484: PPUSH
63485: CALL 71602 0 3
63489: ST_TO_ADDR
// if btype = b_bunker then
63490: LD_VAR 0 5
63494: PUSH
63495: LD_INT 32
63497: EQUAL
63498: IFFALSE 63734
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63500: LD_ADDR_EXP 110
63504: PUSH
63505: LD_EXP 110
63509: PPUSH
63510: LD_VAR 0 3
63514: PUSH
63515: LD_EXP 110
63519: PUSH
63520: LD_VAR 0 3
63524: ARRAY
63525: PUSH
63526: LD_INT 1
63528: PLUS
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PPUSH
63534: LD_VAR 0 1
63538: PPUSH
63539: CALL 71602 0 3
63543: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63544: LD_ADDR_VAR 0 6
63548: PUSH
63549: LD_EXP 101
63553: PUSH
63554: LD_VAR 0 3
63558: ARRAY
63559: PPUSH
63560: LD_INT 25
63562: PUSH
63563: LD_INT 1
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: PUSH
63570: LD_INT 3
63572: PUSH
63573: LD_INT 54
63575: PUSH
63576: EMPTY
63577: LIST
63578: PUSH
63579: EMPTY
63580: LIST
63581: LIST
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PPUSH
63587: CALL_OW 72
63591: ST_TO_ADDR
// if tmp then
63592: LD_VAR 0 6
63596: IFFALSE 63602
// exit ;
63598: POP
63599: POP
63600: GO 63742
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63602: LD_ADDR_VAR 0 6
63606: PUSH
63607: LD_EXP 101
63611: PUSH
63612: LD_VAR 0 3
63616: ARRAY
63617: PPUSH
63618: LD_INT 2
63620: PUSH
63621: LD_INT 30
63623: PUSH
63624: LD_INT 4
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PUSH
63631: LD_INT 30
63633: PUSH
63634: LD_INT 5
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PUSH
63641: EMPTY
63642: LIST
63643: LIST
63644: LIST
63645: PPUSH
63646: CALL_OW 72
63650: ST_TO_ADDR
// if not tmp then
63651: LD_VAR 0 6
63655: NOT
63656: IFFALSE 63662
// exit ;
63658: POP
63659: POP
63660: GO 63742
// for j in tmp do
63662: LD_ADDR_VAR 0 4
63666: PUSH
63667: LD_VAR 0 6
63671: PUSH
63672: FOR_IN
63673: IFFALSE 63732
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63675: LD_ADDR_VAR 0 7
63679: PUSH
63680: LD_VAR 0 4
63684: PPUSH
63685: CALL_OW 313
63689: PPUSH
63690: LD_INT 25
63692: PUSH
63693: LD_INT 1
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PPUSH
63700: CALL_OW 72
63704: ST_TO_ADDR
// if units then
63705: LD_VAR 0 7
63709: IFFALSE 63730
// begin ComExitBuilding ( units [ 1 ] ) ;
63711: LD_VAR 0 7
63715: PUSH
63716: LD_INT 1
63718: ARRAY
63719: PPUSH
63720: CALL_OW 122
// exit ;
63724: POP
63725: POP
63726: POP
63727: POP
63728: GO 63742
// end ; end ;
63730: GO 63672
63732: POP
63733: POP
// end ; end ; exit ;
63734: POP
63735: POP
63736: GO 63742
// end ; end ;
63738: GO 63096
63740: POP
63741: POP
// end ;
63742: LD_VAR 0 2
63746: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63747: LD_INT 0
63749: PPUSH
63750: PPUSH
63751: PPUSH
63752: PPUSH
63753: PPUSH
63754: PPUSH
63755: PPUSH
// if not mc_bases or not skirmish then
63756: LD_EXP 101
63760: NOT
63761: PUSH
63762: LD_EXP 99
63766: NOT
63767: OR
63768: IFFALSE 63772
// exit ;
63770: GO 64003
// btype := GetBType ( building ) ;
63772: LD_ADDR_VAR 0 6
63776: PUSH
63777: LD_VAR 0 1
63781: PPUSH
63782: CALL_OW 266
63786: ST_TO_ADDR
// x := GetX ( building ) ;
63787: LD_ADDR_VAR 0 7
63791: PUSH
63792: LD_VAR 0 1
63796: PPUSH
63797: CALL_OW 250
63801: ST_TO_ADDR
// y := GetY ( building ) ;
63802: LD_ADDR_VAR 0 8
63806: PUSH
63807: LD_VAR 0 1
63811: PPUSH
63812: CALL_OW 251
63816: ST_TO_ADDR
// d := GetDir ( building ) ;
63817: LD_ADDR_VAR 0 9
63821: PUSH
63822: LD_VAR 0 1
63826: PPUSH
63827: CALL_OW 254
63831: ST_TO_ADDR
// for i = 1 to mc_bases do
63832: LD_ADDR_VAR 0 4
63836: PUSH
63837: DOUBLE
63838: LD_INT 1
63840: DEC
63841: ST_TO_ADDR
63842: LD_EXP 101
63846: PUSH
63847: FOR_TO
63848: IFFALSE 64001
// begin if not mc_build_list [ i ] then
63850: LD_EXP 106
63854: PUSH
63855: LD_VAR 0 4
63859: ARRAY
63860: NOT
63861: IFFALSE 63865
// continue ;
63863: GO 63847
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63865: LD_VAR 0 6
63869: PUSH
63870: LD_VAR 0 7
63874: PUSH
63875: LD_VAR 0 8
63879: PUSH
63880: LD_VAR 0 9
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: LIST
63889: LIST
63890: PPUSH
63891: LD_EXP 106
63895: PUSH
63896: LD_VAR 0 4
63900: ARRAY
63901: PUSH
63902: LD_INT 1
63904: ARRAY
63905: PPUSH
63906: CALL 77771 0 2
63910: IFFALSE 63999
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63912: LD_ADDR_EXP 106
63916: PUSH
63917: LD_EXP 106
63921: PPUSH
63922: LD_VAR 0 4
63926: PPUSH
63927: LD_EXP 106
63931: PUSH
63932: LD_VAR 0 4
63936: ARRAY
63937: PPUSH
63938: LD_INT 1
63940: PPUSH
63941: CALL_OW 3
63945: PPUSH
63946: CALL_OW 1
63950: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63951: LD_ADDR_EXP 108
63955: PUSH
63956: LD_EXP 108
63960: PPUSH
63961: LD_VAR 0 4
63965: PUSH
63966: LD_EXP 108
63970: PUSH
63971: LD_VAR 0 4
63975: ARRAY
63976: PUSH
63977: LD_INT 1
63979: PLUS
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PPUSH
63985: LD_VAR 0 1
63989: PPUSH
63990: CALL 71602 0 3
63994: ST_TO_ADDR
// exit ;
63995: POP
63996: POP
63997: GO 64003
// end ; end ;
63999: GO 63847
64001: POP
64002: POP
// end ;
64003: LD_VAR 0 3
64007: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64008: LD_INT 0
64010: PPUSH
64011: PPUSH
64012: PPUSH
// if not mc_bases or not skirmish then
64013: LD_EXP 101
64017: NOT
64018: PUSH
64019: LD_EXP 99
64023: NOT
64024: OR
64025: IFFALSE 64029
// exit ;
64027: GO 64219
// for i = 1 to mc_bases do
64029: LD_ADDR_VAR 0 4
64033: PUSH
64034: DOUBLE
64035: LD_INT 1
64037: DEC
64038: ST_TO_ADDR
64039: LD_EXP 101
64043: PUSH
64044: FOR_TO
64045: IFFALSE 64132
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64047: LD_VAR 0 1
64051: PUSH
64052: LD_EXP 109
64056: PUSH
64057: LD_VAR 0 4
64061: ARRAY
64062: IN
64063: PUSH
64064: LD_VAR 0 1
64068: PUSH
64069: LD_EXP 110
64073: PUSH
64074: LD_VAR 0 4
64078: ARRAY
64079: IN
64080: NOT
64081: AND
64082: IFFALSE 64130
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64084: LD_ADDR_EXP 110
64088: PUSH
64089: LD_EXP 110
64093: PPUSH
64094: LD_VAR 0 4
64098: PUSH
64099: LD_EXP 110
64103: PUSH
64104: LD_VAR 0 4
64108: ARRAY
64109: PUSH
64110: LD_INT 1
64112: PLUS
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: PPUSH
64118: LD_VAR 0 1
64122: PPUSH
64123: CALL 71602 0 3
64127: ST_TO_ADDR
// break ;
64128: GO 64132
// end ; end ;
64130: GO 64044
64132: POP
64133: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64134: LD_VAR 0 1
64138: PPUSH
64139: CALL_OW 257
64143: PUSH
64144: LD_EXP 127
64148: IN
64149: PUSH
64150: LD_VAR 0 1
64154: PPUSH
64155: CALL_OW 266
64159: PUSH
64160: LD_INT 5
64162: EQUAL
64163: AND
64164: PUSH
64165: LD_VAR 0 2
64169: PPUSH
64170: CALL_OW 110
64174: PUSH
64175: LD_INT 18
64177: NONEQUAL
64178: AND
64179: IFFALSE 64219
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64181: LD_VAR 0 2
64185: PPUSH
64186: CALL_OW 257
64190: PUSH
64191: LD_INT 5
64193: PUSH
64194: LD_INT 8
64196: PUSH
64197: LD_INT 9
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: LIST
64204: IN
64205: IFFALSE 64219
// SetClass ( unit , 1 ) ;
64207: LD_VAR 0 2
64211: PPUSH
64212: LD_INT 1
64214: PPUSH
64215: CALL_OW 336
// end ;
64219: LD_VAR 0 3
64223: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64224: LD_INT 0
64226: PPUSH
64227: PPUSH
// if not mc_bases or not skirmish then
64228: LD_EXP 101
64232: NOT
64233: PUSH
64234: LD_EXP 99
64238: NOT
64239: OR
64240: IFFALSE 64244
// exit ;
64242: GO 64360
// if GetLives ( abandoned_vehicle ) > 250 then
64244: LD_VAR 0 2
64248: PPUSH
64249: CALL_OW 256
64253: PUSH
64254: LD_INT 250
64256: GREATER
64257: IFFALSE 64261
// exit ;
64259: GO 64360
// for i = 1 to mc_bases do
64261: LD_ADDR_VAR 0 6
64265: PUSH
64266: DOUBLE
64267: LD_INT 1
64269: DEC
64270: ST_TO_ADDR
64271: LD_EXP 101
64275: PUSH
64276: FOR_TO
64277: IFFALSE 64358
// begin if driver in mc_bases [ i ] then
64279: LD_VAR 0 1
64283: PUSH
64284: LD_EXP 101
64288: PUSH
64289: LD_VAR 0 6
64293: ARRAY
64294: IN
64295: IFFALSE 64356
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64297: LD_VAR 0 1
64301: PPUSH
64302: LD_EXP 101
64306: PUSH
64307: LD_VAR 0 6
64311: ARRAY
64312: PPUSH
64313: LD_INT 2
64315: PUSH
64316: LD_INT 30
64318: PUSH
64319: LD_INT 0
64321: PUSH
64322: EMPTY
64323: LIST
64324: LIST
64325: PUSH
64326: LD_INT 30
64328: PUSH
64329: LD_INT 1
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: EMPTY
64337: LIST
64338: LIST
64339: LIST
64340: PPUSH
64341: CALL_OW 72
64345: PUSH
64346: LD_INT 1
64348: ARRAY
64349: PPUSH
64350: CALL_OW 112
// break ;
64354: GO 64358
// end ; end ;
64356: GO 64276
64358: POP
64359: POP
// end ; end_of_file
64360: LD_VAR 0 5
64364: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64365: LD_INT 0
64367: PPUSH
64368: PPUSH
// if exist_mode then
64369: LD_VAR 0 2
64373: IFFALSE 64398
// unit := CreateCharacter ( prefix & ident ) else
64375: LD_ADDR_VAR 0 5
64379: PUSH
64380: LD_VAR 0 3
64384: PUSH
64385: LD_VAR 0 1
64389: STR
64390: PPUSH
64391: CALL_OW 34
64395: ST_TO_ADDR
64396: GO 64413
// unit := NewCharacter ( ident ) ;
64398: LD_ADDR_VAR 0 5
64402: PUSH
64403: LD_VAR 0 1
64407: PPUSH
64408: CALL_OW 25
64412: ST_TO_ADDR
// result := unit ;
64413: LD_ADDR_VAR 0 4
64417: PUSH
64418: LD_VAR 0 5
64422: ST_TO_ADDR
// end ;
64423: LD_VAR 0 4
64427: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64428: LD_INT 0
64430: PPUSH
64431: PPUSH
// if not side or not nation then
64432: LD_VAR 0 1
64436: NOT
64437: PUSH
64438: LD_VAR 0 2
64442: NOT
64443: OR
64444: IFFALSE 64448
// exit ;
64446: GO 65092
// case nation of nation_american :
64448: LD_VAR 0 2
64452: PUSH
64453: LD_INT 1
64455: DOUBLE
64456: EQUAL
64457: IFTRUE 64461
64459: GO 64635
64461: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64462: LD_ADDR_VAR 0 4
64466: PUSH
64467: LD_INT 35
64469: PUSH
64470: LD_INT 45
64472: PUSH
64473: LD_INT 46
64475: PUSH
64476: LD_INT 47
64478: PUSH
64479: LD_INT 1
64481: PUSH
64482: LD_INT 2
64484: PUSH
64485: LD_INT 6
64487: PUSH
64488: LD_INT 15
64490: PUSH
64491: LD_INT 16
64493: PUSH
64494: LD_INT 7
64496: PUSH
64497: LD_INT 12
64499: PUSH
64500: LD_INT 13
64502: PUSH
64503: LD_INT 10
64505: PUSH
64506: LD_INT 14
64508: PUSH
64509: LD_INT 20
64511: PUSH
64512: LD_INT 21
64514: PUSH
64515: LD_INT 22
64517: PUSH
64518: LD_INT 25
64520: PUSH
64521: LD_INT 32
64523: PUSH
64524: LD_INT 27
64526: PUSH
64527: LD_INT 36
64529: PUSH
64530: LD_INT 69
64532: PUSH
64533: LD_INT 39
64535: PUSH
64536: LD_INT 34
64538: PUSH
64539: LD_INT 40
64541: PUSH
64542: LD_INT 48
64544: PUSH
64545: LD_INT 49
64547: PUSH
64548: LD_INT 50
64550: PUSH
64551: LD_INT 51
64553: PUSH
64554: LD_INT 52
64556: PUSH
64557: LD_INT 53
64559: PUSH
64560: LD_INT 54
64562: PUSH
64563: LD_INT 55
64565: PUSH
64566: LD_INT 56
64568: PUSH
64569: LD_INT 57
64571: PUSH
64572: LD_INT 58
64574: PUSH
64575: LD_INT 59
64577: PUSH
64578: LD_INT 60
64580: PUSH
64581: LD_INT 61
64583: PUSH
64584: LD_INT 62
64586: PUSH
64587: LD_INT 80
64589: PUSH
64590: EMPTY
64591: LIST
64592: LIST
64593: LIST
64594: LIST
64595: LIST
64596: LIST
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: LIST
64615: LIST
64616: LIST
64617: LIST
64618: LIST
64619: LIST
64620: LIST
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: LIST
64626: LIST
64627: LIST
64628: LIST
64629: LIST
64630: LIST
64631: LIST
64632: ST_TO_ADDR
64633: GO 65016
64635: LD_INT 2
64637: DOUBLE
64638: EQUAL
64639: IFTRUE 64643
64641: GO 64825
64643: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64644: LD_ADDR_VAR 0 4
64648: PUSH
64649: LD_INT 35
64651: PUSH
64652: LD_INT 45
64654: PUSH
64655: LD_INT 46
64657: PUSH
64658: LD_INT 47
64660: PUSH
64661: LD_INT 70
64663: PUSH
64664: LD_INT 1
64666: PUSH
64667: LD_INT 11
64669: PUSH
64670: LD_INT 3
64672: PUSH
64673: LD_INT 4
64675: PUSH
64676: LD_INT 5
64678: PUSH
64679: LD_INT 6
64681: PUSH
64682: LD_INT 15
64684: PUSH
64685: LD_INT 18
64687: PUSH
64688: LD_INT 7
64690: PUSH
64691: LD_INT 17
64693: PUSH
64694: LD_INT 8
64696: PUSH
64697: LD_INT 20
64699: PUSH
64700: LD_INT 21
64702: PUSH
64703: LD_INT 22
64705: PUSH
64706: LD_INT 72
64708: PUSH
64709: LD_INT 26
64711: PUSH
64712: LD_INT 69
64714: PUSH
64715: LD_INT 39
64717: PUSH
64718: LD_INT 40
64720: PUSH
64721: LD_INT 41
64723: PUSH
64724: LD_INT 42
64726: PUSH
64727: LD_INT 43
64729: PUSH
64730: LD_INT 48
64732: PUSH
64733: LD_INT 49
64735: PUSH
64736: LD_INT 50
64738: PUSH
64739: LD_INT 51
64741: PUSH
64742: LD_INT 52
64744: PUSH
64745: LD_INT 53
64747: PUSH
64748: LD_INT 54
64750: PUSH
64751: LD_INT 55
64753: PUSH
64754: LD_INT 56
64756: PUSH
64757: LD_INT 60
64759: PUSH
64760: LD_INT 61
64762: PUSH
64763: LD_INT 62
64765: PUSH
64766: LD_INT 66
64768: PUSH
64769: LD_INT 67
64771: PUSH
64772: LD_INT 68
64774: PUSH
64775: LD_INT 81
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: LIST
64786: LIST
64787: LIST
64788: LIST
64789: LIST
64790: LIST
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: LIST
64806: LIST
64807: LIST
64808: LIST
64809: LIST
64810: LIST
64811: LIST
64812: LIST
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: LIST
64818: LIST
64819: LIST
64820: LIST
64821: LIST
64822: ST_TO_ADDR
64823: GO 65016
64825: LD_INT 3
64827: DOUBLE
64828: EQUAL
64829: IFTRUE 64833
64831: GO 65015
64833: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64834: LD_ADDR_VAR 0 4
64838: PUSH
64839: LD_INT 46
64841: PUSH
64842: LD_INT 47
64844: PUSH
64845: LD_INT 1
64847: PUSH
64848: LD_INT 2
64850: PUSH
64851: LD_INT 11
64853: PUSH
64854: LD_INT 9
64856: PUSH
64857: LD_INT 20
64859: PUSH
64860: LD_INT 19
64862: PUSH
64863: LD_INT 21
64865: PUSH
64866: LD_INT 24
64868: PUSH
64869: LD_INT 22
64871: PUSH
64872: LD_INT 25
64874: PUSH
64875: LD_INT 28
64877: PUSH
64878: LD_INT 29
64880: PUSH
64881: LD_INT 30
64883: PUSH
64884: LD_INT 31
64886: PUSH
64887: LD_INT 37
64889: PUSH
64890: LD_INT 38
64892: PUSH
64893: LD_INT 32
64895: PUSH
64896: LD_INT 27
64898: PUSH
64899: LD_INT 33
64901: PUSH
64902: LD_INT 69
64904: PUSH
64905: LD_INT 39
64907: PUSH
64908: LD_INT 34
64910: PUSH
64911: LD_INT 40
64913: PUSH
64914: LD_INT 71
64916: PUSH
64917: LD_INT 23
64919: PUSH
64920: LD_INT 44
64922: PUSH
64923: LD_INT 48
64925: PUSH
64926: LD_INT 49
64928: PUSH
64929: LD_INT 50
64931: PUSH
64932: LD_INT 51
64934: PUSH
64935: LD_INT 52
64937: PUSH
64938: LD_INT 53
64940: PUSH
64941: LD_INT 54
64943: PUSH
64944: LD_INT 55
64946: PUSH
64947: LD_INT 56
64949: PUSH
64950: LD_INT 57
64952: PUSH
64953: LD_INT 58
64955: PUSH
64956: LD_INT 59
64958: PUSH
64959: LD_INT 63
64961: PUSH
64962: LD_INT 64
64964: PUSH
64965: LD_INT 65
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: ST_TO_ADDR
65013: GO 65016
65015: POP
// if state > - 1 and state < 3 then
65016: LD_VAR 0 3
65020: PUSH
65021: LD_INT 1
65023: NEG
65024: GREATER
65025: PUSH
65026: LD_VAR 0 3
65030: PUSH
65031: LD_INT 3
65033: LESS
65034: AND
65035: IFFALSE 65092
// for i in result do
65037: LD_ADDR_VAR 0 5
65041: PUSH
65042: LD_VAR 0 4
65046: PUSH
65047: FOR_IN
65048: IFFALSE 65090
// if GetTech ( i , side ) <> state then
65050: LD_VAR 0 5
65054: PPUSH
65055: LD_VAR 0 1
65059: PPUSH
65060: CALL_OW 321
65064: PUSH
65065: LD_VAR 0 3
65069: NONEQUAL
65070: IFFALSE 65088
// result := result diff i ;
65072: LD_ADDR_VAR 0 4
65076: PUSH
65077: LD_VAR 0 4
65081: PUSH
65082: LD_VAR 0 5
65086: DIFF
65087: ST_TO_ADDR
65088: GO 65047
65090: POP
65091: POP
// end ;
65092: LD_VAR 0 4
65096: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65097: LD_INT 0
65099: PPUSH
65100: PPUSH
65101: PPUSH
// result := true ;
65102: LD_ADDR_VAR 0 3
65106: PUSH
65107: LD_INT 1
65109: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65110: LD_ADDR_VAR 0 5
65114: PUSH
65115: LD_VAR 0 2
65119: PPUSH
65120: CALL_OW 480
65124: ST_TO_ADDR
// if not tmp then
65125: LD_VAR 0 5
65129: NOT
65130: IFFALSE 65134
// exit ;
65132: GO 65183
// for i in tmp do
65134: LD_ADDR_VAR 0 4
65138: PUSH
65139: LD_VAR 0 5
65143: PUSH
65144: FOR_IN
65145: IFFALSE 65181
// if GetTech ( i , side ) <> state_researched then
65147: LD_VAR 0 4
65151: PPUSH
65152: LD_VAR 0 1
65156: PPUSH
65157: CALL_OW 321
65161: PUSH
65162: LD_INT 2
65164: NONEQUAL
65165: IFFALSE 65179
// begin result := false ;
65167: LD_ADDR_VAR 0 3
65171: PUSH
65172: LD_INT 0
65174: ST_TO_ADDR
// exit ;
65175: POP
65176: POP
65177: GO 65183
// end ;
65179: GO 65144
65181: POP
65182: POP
// end ;
65183: LD_VAR 0 3
65187: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65188: LD_INT 0
65190: PPUSH
65191: PPUSH
65192: PPUSH
65193: PPUSH
65194: PPUSH
65195: PPUSH
65196: PPUSH
65197: PPUSH
65198: PPUSH
65199: PPUSH
65200: PPUSH
65201: PPUSH
65202: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65203: LD_VAR 0 1
65207: NOT
65208: PUSH
65209: LD_VAR 0 1
65213: PPUSH
65214: CALL_OW 257
65218: PUSH
65219: LD_INT 9
65221: NONEQUAL
65222: OR
65223: IFFALSE 65227
// exit ;
65225: GO 65800
// side := GetSide ( unit ) ;
65227: LD_ADDR_VAR 0 9
65231: PUSH
65232: LD_VAR 0 1
65236: PPUSH
65237: CALL_OW 255
65241: ST_TO_ADDR
// tech_space := tech_spacanom ;
65242: LD_ADDR_VAR 0 12
65246: PUSH
65247: LD_INT 29
65249: ST_TO_ADDR
// tech_time := tech_taurad ;
65250: LD_ADDR_VAR 0 13
65254: PUSH
65255: LD_INT 28
65257: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65258: LD_ADDR_VAR 0 11
65262: PUSH
65263: LD_VAR 0 1
65267: PPUSH
65268: CALL_OW 310
65272: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65273: LD_VAR 0 11
65277: PPUSH
65278: CALL_OW 247
65282: PUSH
65283: LD_INT 2
65285: EQUAL
65286: IFFALSE 65290
// exit ;
65288: GO 65800
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65290: LD_ADDR_VAR 0 8
65294: PUSH
65295: LD_INT 81
65297: PUSH
65298: LD_VAR 0 9
65302: PUSH
65303: EMPTY
65304: LIST
65305: LIST
65306: PUSH
65307: LD_INT 3
65309: PUSH
65310: LD_INT 21
65312: PUSH
65313: LD_INT 3
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PPUSH
65328: CALL_OW 69
65332: ST_TO_ADDR
// if not tmp then
65333: LD_VAR 0 8
65337: NOT
65338: IFFALSE 65342
// exit ;
65340: GO 65800
// if in_unit then
65342: LD_VAR 0 11
65346: IFFALSE 65370
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65348: LD_ADDR_VAR 0 10
65352: PUSH
65353: LD_VAR 0 8
65357: PPUSH
65358: LD_VAR 0 11
65362: PPUSH
65363: CALL_OW 74
65367: ST_TO_ADDR
65368: GO 65390
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65370: LD_ADDR_VAR 0 10
65374: PUSH
65375: LD_VAR 0 8
65379: PPUSH
65380: LD_VAR 0 1
65384: PPUSH
65385: CALL_OW 74
65389: ST_TO_ADDR
// if not enemy then
65390: LD_VAR 0 10
65394: NOT
65395: IFFALSE 65399
// exit ;
65397: GO 65800
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65399: LD_VAR 0 11
65403: PUSH
65404: LD_VAR 0 11
65408: PPUSH
65409: LD_VAR 0 10
65413: PPUSH
65414: CALL_OW 296
65418: PUSH
65419: LD_INT 13
65421: GREATER
65422: AND
65423: PUSH
65424: LD_VAR 0 1
65428: PPUSH
65429: LD_VAR 0 10
65433: PPUSH
65434: CALL_OW 296
65438: PUSH
65439: LD_INT 12
65441: GREATER
65442: OR
65443: IFFALSE 65447
// exit ;
65445: GO 65800
// missile := [ 1 ] ;
65447: LD_ADDR_VAR 0 14
65451: PUSH
65452: LD_INT 1
65454: PUSH
65455: EMPTY
65456: LIST
65457: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65458: LD_VAR 0 9
65462: PPUSH
65463: LD_VAR 0 12
65467: PPUSH
65468: CALL_OW 325
65472: IFFALSE 65501
// missile := Insert ( missile , missile + 1 , 2 ) ;
65474: LD_ADDR_VAR 0 14
65478: PUSH
65479: LD_VAR 0 14
65483: PPUSH
65484: LD_VAR 0 14
65488: PUSH
65489: LD_INT 1
65491: PLUS
65492: PPUSH
65493: LD_INT 2
65495: PPUSH
65496: CALL_OW 2
65500: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65501: LD_VAR 0 9
65505: PPUSH
65506: LD_VAR 0 13
65510: PPUSH
65511: CALL_OW 325
65515: PUSH
65516: LD_VAR 0 10
65520: PPUSH
65521: CALL_OW 255
65525: PPUSH
65526: LD_VAR 0 13
65530: PPUSH
65531: CALL_OW 325
65535: NOT
65536: AND
65537: IFFALSE 65566
// missile := Insert ( missile , missile + 1 , 3 ) ;
65539: LD_ADDR_VAR 0 14
65543: PUSH
65544: LD_VAR 0 14
65548: PPUSH
65549: LD_VAR 0 14
65553: PUSH
65554: LD_INT 1
65556: PLUS
65557: PPUSH
65558: LD_INT 3
65560: PPUSH
65561: CALL_OW 2
65565: ST_TO_ADDR
// if missile < 2 then
65566: LD_VAR 0 14
65570: PUSH
65571: LD_INT 2
65573: LESS
65574: IFFALSE 65578
// exit ;
65576: GO 65800
// x := GetX ( enemy ) ;
65578: LD_ADDR_VAR 0 4
65582: PUSH
65583: LD_VAR 0 10
65587: PPUSH
65588: CALL_OW 250
65592: ST_TO_ADDR
// y := GetY ( enemy ) ;
65593: LD_ADDR_VAR 0 5
65597: PUSH
65598: LD_VAR 0 10
65602: PPUSH
65603: CALL_OW 251
65607: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65608: LD_ADDR_VAR 0 6
65612: PUSH
65613: LD_VAR 0 4
65617: PUSH
65618: LD_INT 1
65620: NEG
65621: PPUSH
65622: LD_INT 1
65624: PPUSH
65625: CALL_OW 12
65629: PLUS
65630: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65631: LD_ADDR_VAR 0 7
65635: PUSH
65636: LD_VAR 0 5
65640: PUSH
65641: LD_INT 1
65643: NEG
65644: PPUSH
65645: LD_INT 1
65647: PPUSH
65648: CALL_OW 12
65652: PLUS
65653: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65654: LD_VAR 0 6
65658: PPUSH
65659: LD_VAR 0 7
65663: PPUSH
65664: CALL_OW 488
65668: NOT
65669: IFFALSE 65691
// begin _x := x ;
65671: LD_ADDR_VAR 0 6
65675: PUSH
65676: LD_VAR 0 4
65680: ST_TO_ADDR
// _y := y ;
65681: LD_ADDR_VAR 0 7
65685: PUSH
65686: LD_VAR 0 5
65690: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65691: LD_ADDR_VAR 0 3
65695: PUSH
65696: LD_INT 1
65698: PPUSH
65699: LD_VAR 0 14
65703: PPUSH
65704: CALL_OW 12
65708: ST_TO_ADDR
// case i of 1 :
65709: LD_VAR 0 3
65713: PUSH
65714: LD_INT 1
65716: DOUBLE
65717: EQUAL
65718: IFTRUE 65722
65720: GO 65739
65722: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65723: LD_VAR 0 1
65727: PPUSH
65728: LD_VAR 0 10
65732: PPUSH
65733: CALL_OW 115
65737: GO 65800
65739: LD_INT 2
65741: DOUBLE
65742: EQUAL
65743: IFTRUE 65747
65745: GO 65769
65747: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65748: LD_VAR 0 1
65752: PPUSH
65753: LD_VAR 0 6
65757: PPUSH
65758: LD_VAR 0 7
65762: PPUSH
65763: CALL_OW 153
65767: GO 65800
65769: LD_INT 3
65771: DOUBLE
65772: EQUAL
65773: IFTRUE 65777
65775: GO 65799
65777: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65778: LD_VAR 0 1
65782: PPUSH
65783: LD_VAR 0 6
65787: PPUSH
65788: LD_VAR 0 7
65792: PPUSH
65793: CALL_OW 154
65797: GO 65800
65799: POP
// end ;
65800: LD_VAR 0 2
65804: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65805: LD_INT 0
65807: PPUSH
65808: PPUSH
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
// if not unit or not building then
65813: LD_VAR 0 1
65817: NOT
65818: PUSH
65819: LD_VAR 0 2
65823: NOT
65824: OR
65825: IFFALSE 65829
// exit ;
65827: GO 65987
// x := GetX ( building ) ;
65829: LD_ADDR_VAR 0 5
65833: PUSH
65834: LD_VAR 0 2
65838: PPUSH
65839: CALL_OW 250
65843: ST_TO_ADDR
// y := GetY ( building ) ;
65844: LD_ADDR_VAR 0 6
65848: PUSH
65849: LD_VAR 0 2
65853: PPUSH
65854: CALL_OW 251
65858: ST_TO_ADDR
// for i = 0 to 5 do
65859: LD_ADDR_VAR 0 4
65863: PUSH
65864: DOUBLE
65865: LD_INT 0
65867: DEC
65868: ST_TO_ADDR
65869: LD_INT 5
65871: PUSH
65872: FOR_TO
65873: IFFALSE 65985
// begin _x := ShiftX ( x , i , 3 ) ;
65875: LD_ADDR_VAR 0 7
65879: PUSH
65880: LD_VAR 0 5
65884: PPUSH
65885: LD_VAR 0 4
65889: PPUSH
65890: LD_INT 3
65892: PPUSH
65893: CALL_OW 272
65897: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65898: LD_ADDR_VAR 0 8
65902: PUSH
65903: LD_VAR 0 6
65907: PPUSH
65908: LD_VAR 0 4
65912: PPUSH
65913: LD_INT 3
65915: PPUSH
65916: CALL_OW 273
65920: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65921: LD_VAR 0 7
65925: PPUSH
65926: LD_VAR 0 8
65930: PPUSH
65931: CALL_OW 488
65935: NOT
65936: IFFALSE 65940
// continue ;
65938: GO 65872
// if HexInfo ( _x , _y ) = 0 then
65940: LD_VAR 0 7
65944: PPUSH
65945: LD_VAR 0 8
65949: PPUSH
65950: CALL_OW 428
65954: PUSH
65955: LD_INT 0
65957: EQUAL
65958: IFFALSE 65983
// begin ComMoveXY ( unit , _x , _y ) ;
65960: LD_VAR 0 1
65964: PPUSH
65965: LD_VAR 0 7
65969: PPUSH
65970: LD_VAR 0 8
65974: PPUSH
65975: CALL_OW 111
// exit ;
65979: POP
65980: POP
65981: GO 65987
// end ; end ;
65983: GO 65872
65985: POP
65986: POP
// end ;
65987: LD_VAR 0 3
65991: RET
// export function ScanBase ( side , base_area ) ; begin
65992: LD_INT 0
65994: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65995: LD_ADDR_VAR 0 3
65999: PUSH
66000: LD_VAR 0 2
66004: PPUSH
66005: LD_INT 81
66007: PUSH
66008: LD_VAR 0 1
66012: PUSH
66013: EMPTY
66014: LIST
66015: LIST
66016: PPUSH
66017: CALL_OW 70
66021: ST_TO_ADDR
// end ;
66022: LD_VAR 0 3
66026: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66027: LD_INT 0
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66034: LD_VAR 0 1
66038: NOT
66039: PUSH
66040: LD_EXP 101
66044: PUSH
66045: LD_VAR 0 1
66049: ARRAY
66050: NOT
66051: OR
66052: PUSH
66053: LD_VAR 0 2
66057: NOT
66058: OR
66059: PUSH
66060: LD_VAR 0 3
66064: NOT
66065: OR
66066: IFFALSE 66070
// exit ;
66068: GO 66583
// side := mc_sides [ base ] ;
66070: LD_ADDR_VAR 0 6
66074: PUSH
66075: LD_EXP 127
66079: PUSH
66080: LD_VAR 0 1
66084: ARRAY
66085: ST_TO_ADDR
// if not side then
66086: LD_VAR 0 6
66090: NOT
66091: IFFALSE 66095
// exit ;
66093: GO 66583
// for i in solds do
66095: LD_ADDR_VAR 0 7
66099: PUSH
66100: LD_VAR 0 2
66104: PUSH
66105: FOR_IN
66106: IFFALSE 66167
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66108: LD_VAR 0 7
66112: PPUSH
66113: CALL_OW 310
66117: PPUSH
66118: CALL_OW 266
66122: PUSH
66123: LD_INT 32
66125: PUSH
66126: LD_INT 31
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: IN
66133: IFFALSE 66153
// solds := solds diff i else
66135: LD_ADDR_VAR 0 2
66139: PUSH
66140: LD_VAR 0 2
66144: PUSH
66145: LD_VAR 0 7
66149: DIFF
66150: ST_TO_ADDR
66151: GO 66165
// SetTag ( i , 18 ) ;
66153: LD_VAR 0 7
66157: PPUSH
66158: LD_INT 18
66160: PPUSH
66161: CALL_OW 109
66165: GO 66105
66167: POP
66168: POP
// if not solds then
66169: LD_VAR 0 2
66173: NOT
66174: IFFALSE 66178
// exit ;
66176: GO 66583
// repeat wait ( 0 0$1 ) ;
66178: LD_INT 35
66180: PPUSH
66181: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66185: LD_ADDR_VAR 0 5
66189: PUSH
66190: LD_VAR 0 6
66194: PPUSH
66195: LD_VAR 0 3
66199: PPUSH
66200: CALL 65992 0 2
66204: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66205: LD_EXP 101
66209: PUSH
66210: LD_VAR 0 1
66214: ARRAY
66215: NOT
66216: PUSH
66217: LD_EXP 101
66221: PUSH
66222: LD_VAR 0 1
66226: ARRAY
66227: PUSH
66228: EMPTY
66229: EQUAL
66230: OR
66231: IFFALSE 66268
// begin for i in solds do
66233: LD_ADDR_VAR 0 7
66237: PUSH
66238: LD_VAR 0 2
66242: PUSH
66243: FOR_IN
66244: IFFALSE 66257
// ComStop ( i ) ;
66246: LD_VAR 0 7
66250: PPUSH
66251: CALL_OW 141
66255: GO 66243
66257: POP
66258: POP
// solds := [ ] ;
66259: LD_ADDR_VAR 0 2
66263: PUSH
66264: EMPTY
66265: ST_TO_ADDR
// exit ;
66266: GO 66583
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66268: LD_VAR 0 5
66272: NOT
66273: PUSH
66274: LD_VAR 0 5
66278: PUSH
66279: LD_INT 3
66281: GREATER
66282: OR
66283: PUSH
66284: LD_EXP 123
66288: PUSH
66289: LD_VAR 0 1
66293: ARRAY
66294: OR
66295: IFFALSE 66336
// begin for i in solds do
66297: LD_ADDR_VAR 0 7
66301: PUSH
66302: LD_VAR 0 2
66306: PUSH
66307: FOR_IN
66308: IFFALSE 66332
// if HasTask ( i ) then
66310: LD_VAR 0 7
66314: PPUSH
66315: CALL_OW 314
66319: IFFALSE 66330
// ComStop ( i ) ;
66321: LD_VAR 0 7
66325: PPUSH
66326: CALL_OW 141
66330: GO 66307
66332: POP
66333: POP
// break ;
66334: GO 66571
// end ; for i in solds do
66336: LD_ADDR_VAR 0 7
66340: PUSH
66341: LD_VAR 0 2
66345: PUSH
66346: FOR_IN
66347: IFFALSE 66563
// begin if IsInUnit ( i ) then
66349: LD_VAR 0 7
66353: PPUSH
66354: CALL_OW 310
66358: IFFALSE 66369
// ComExitBuilding ( i ) ;
66360: LD_VAR 0 7
66364: PPUSH
66365: CALL_OW 122
// if GetLives ( i ) > 333 then
66369: LD_VAR 0 7
66373: PPUSH
66374: CALL_OW 256
66378: PUSH
66379: LD_INT 333
66381: GREATER
66382: IFFALSE 66410
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66384: LD_VAR 0 7
66388: PPUSH
66389: LD_VAR 0 5
66393: PPUSH
66394: LD_VAR 0 7
66398: PPUSH
66399: CALL_OW 74
66403: PPUSH
66404: CALL_OW 115
66408: GO 66561
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66410: LD_ADDR_VAR 0 8
66414: PUSH
66415: LD_EXP 101
66419: PUSH
66420: LD_VAR 0 1
66424: ARRAY
66425: PPUSH
66426: LD_INT 2
66428: PUSH
66429: LD_INT 30
66431: PUSH
66432: LD_INT 0
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 30
66441: PUSH
66442: LD_INT 1
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: LD_INT 30
66451: PUSH
66452: LD_INT 6
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: LIST
66463: LIST
66464: PPUSH
66465: CALL_OW 72
66469: PPUSH
66470: LD_VAR 0 7
66474: PPUSH
66475: CALL_OW 74
66479: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66480: LD_VAR 0 7
66484: PPUSH
66485: LD_VAR 0 8
66489: PPUSH
66490: CALL_OW 250
66494: PPUSH
66495: LD_INT 3
66497: PPUSH
66498: LD_INT 5
66500: PPUSH
66501: CALL_OW 272
66505: PPUSH
66506: LD_VAR 0 8
66510: PPUSH
66511: CALL_OW 251
66515: PPUSH
66516: LD_INT 3
66518: PPUSH
66519: LD_INT 5
66521: PPUSH
66522: CALL_OW 273
66526: PPUSH
66527: CALL_OW 111
// SetTag ( i , 0 ) ;
66531: LD_VAR 0 7
66535: PPUSH
66536: LD_INT 0
66538: PPUSH
66539: CALL_OW 109
// solds := solds diff i ;
66543: LD_ADDR_VAR 0 2
66547: PUSH
66548: LD_VAR 0 2
66552: PUSH
66553: LD_VAR 0 7
66557: DIFF
66558: ST_TO_ADDR
// continue ;
66559: GO 66346
// end ; end ;
66561: GO 66346
66563: POP
66564: POP
// until solds ;
66565: LD_VAR 0 2
66569: IFFALSE 66178
// MC_Reset ( base , 18 ) ;
66571: LD_VAR 0 1
66575: PPUSH
66576: LD_INT 18
66578: PPUSH
66579: CALL 38300 0 2
// end ;
66583: LD_VAR 0 4
66587: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66588: LD_INT 0
66590: PPUSH
66591: PPUSH
66592: PPUSH
66593: PPUSH
66594: PPUSH
66595: PPUSH
66596: PPUSH
66597: PPUSH
66598: PPUSH
66599: PPUSH
66600: PPUSH
66601: PPUSH
66602: PPUSH
66603: PPUSH
66604: PPUSH
66605: PPUSH
66606: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66607: LD_ADDR_VAR 0 13
66611: PUSH
66612: LD_EXP 101
66616: PUSH
66617: LD_VAR 0 1
66621: ARRAY
66622: PPUSH
66623: LD_INT 25
66625: PUSH
66626: LD_INT 3
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PPUSH
66633: CALL_OW 72
66637: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66638: LD_EXP 141
66642: PUSH
66643: LD_VAR 0 1
66647: ARRAY
66648: IFFALSE 66672
// mechs := mechs diff mc_remote_driver [ base ] ;
66650: LD_ADDR_VAR 0 13
66654: PUSH
66655: LD_VAR 0 13
66659: PUSH
66660: LD_EXP 141
66664: PUSH
66665: LD_VAR 0 1
66669: ARRAY
66670: DIFF
66671: ST_TO_ADDR
// for i in mechs do
66672: LD_ADDR_VAR 0 5
66676: PUSH
66677: LD_VAR 0 13
66681: PUSH
66682: FOR_IN
66683: IFFALSE 66718
// if GetTag ( i ) > 0 then
66685: LD_VAR 0 5
66689: PPUSH
66690: CALL_OW 110
66694: PUSH
66695: LD_INT 0
66697: GREATER
66698: IFFALSE 66716
// mechs := mechs diff i ;
66700: LD_ADDR_VAR 0 13
66704: PUSH
66705: LD_VAR 0 13
66709: PUSH
66710: LD_VAR 0 5
66714: DIFF
66715: ST_TO_ADDR
66716: GO 66682
66718: POP
66719: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66720: LD_ADDR_VAR 0 9
66724: PUSH
66725: LD_EXP 101
66729: PUSH
66730: LD_VAR 0 1
66734: ARRAY
66735: PPUSH
66736: LD_INT 2
66738: PUSH
66739: LD_INT 25
66741: PUSH
66742: LD_INT 1
66744: PUSH
66745: EMPTY
66746: LIST
66747: LIST
66748: PUSH
66749: LD_INT 25
66751: PUSH
66752: LD_INT 5
66754: PUSH
66755: EMPTY
66756: LIST
66757: LIST
66758: PUSH
66759: LD_INT 25
66761: PUSH
66762: LD_INT 8
66764: PUSH
66765: EMPTY
66766: LIST
66767: LIST
66768: PUSH
66769: LD_INT 25
66771: PUSH
66772: LD_INT 9
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: PPUSH
66786: CALL_OW 72
66790: ST_TO_ADDR
// if not defenders and not solds then
66791: LD_VAR 0 2
66795: NOT
66796: PUSH
66797: LD_VAR 0 9
66801: NOT
66802: AND
66803: IFFALSE 66807
// exit ;
66805: GO 68433
// depot_under_attack := false ;
66807: LD_ADDR_VAR 0 17
66811: PUSH
66812: LD_INT 0
66814: ST_TO_ADDR
// sold_defenders := [ ] ;
66815: LD_ADDR_VAR 0 18
66819: PUSH
66820: EMPTY
66821: ST_TO_ADDR
// if mechs then
66822: LD_VAR 0 13
66826: IFFALSE 66955
// for i in defenders do
66828: LD_ADDR_VAR 0 5
66832: PUSH
66833: LD_VAR 0 2
66837: PUSH
66838: FOR_IN
66839: IFFALSE 66953
// begin SetTag ( i , 20 ) ;
66841: LD_VAR 0 5
66845: PPUSH
66846: LD_INT 20
66848: PPUSH
66849: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66853: LD_VAR 0 5
66857: PPUSH
66858: CALL_OW 263
66862: PUSH
66863: LD_INT 1
66865: EQUAL
66866: PUSH
66867: LD_VAR 0 5
66871: PPUSH
66872: CALL_OW 311
66876: NOT
66877: AND
66878: PUSH
66879: LD_VAR 0 13
66883: AND
66884: IFFALSE 66951
// begin un := mechs [ 1 ] ;
66886: LD_ADDR_VAR 0 11
66890: PUSH
66891: LD_VAR 0 13
66895: PUSH
66896: LD_INT 1
66898: ARRAY
66899: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66900: LD_VAR 0 11
66904: PPUSH
66905: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66909: LD_VAR 0 11
66913: PPUSH
66914: LD_VAR 0 5
66918: PPUSH
66919: CALL_OW 180
// SetTag ( un , 19 ) ;
66923: LD_VAR 0 11
66927: PPUSH
66928: LD_INT 19
66930: PPUSH
66931: CALL_OW 109
// mechs := mechs diff un ;
66935: LD_ADDR_VAR 0 13
66939: PUSH
66940: LD_VAR 0 13
66944: PUSH
66945: LD_VAR 0 11
66949: DIFF
66950: ST_TO_ADDR
// end ; end ;
66951: GO 66838
66953: POP
66954: POP
// if solds then
66955: LD_VAR 0 9
66959: IFFALSE 67018
// for i in solds do
66961: LD_ADDR_VAR 0 5
66965: PUSH
66966: LD_VAR 0 9
66970: PUSH
66971: FOR_IN
66972: IFFALSE 67016
// if not GetTag ( i ) then
66974: LD_VAR 0 5
66978: PPUSH
66979: CALL_OW 110
66983: NOT
66984: IFFALSE 67014
// begin defenders := defenders union i ;
66986: LD_ADDR_VAR 0 2
66990: PUSH
66991: LD_VAR 0 2
66995: PUSH
66996: LD_VAR 0 5
67000: UNION
67001: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67002: LD_VAR 0 5
67006: PPUSH
67007: LD_INT 18
67009: PPUSH
67010: CALL_OW 109
// end ;
67014: GO 66971
67016: POP
67017: POP
// repeat wait ( 0 0$1 ) ;
67018: LD_INT 35
67020: PPUSH
67021: CALL_OW 67
// enemy := mc_scan [ base ] ;
67025: LD_ADDR_VAR 0 3
67029: PUSH
67030: LD_EXP 124
67034: PUSH
67035: LD_VAR 0 1
67039: ARRAY
67040: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67041: LD_EXP 101
67045: PUSH
67046: LD_VAR 0 1
67050: ARRAY
67051: NOT
67052: PUSH
67053: LD_EXP 101
67057: PUSH
67058: LD_VAR 0 1
67062: ARRAY
67063: PUSH
67064: EMPTY
67065: EQUAL
67066: OR
67067: IFFALSE 67104
// begin for i in defenders do
67069: LD_ADDR_VAR 0 5
67073: PUSH
67074: LD_VAR 0 2
67078: PUSH
67079: FOR_IN
67080: IFFALSE 67093
// ComStop ( i ) ;
67082: LD_VAR 0 5
67086: PPUSH
67087: CALL_OW 141
67091: GO 67079
67093: POP
67094: POP
// defenders := [ ] ;
67095: LD_ADDR_VAR 0 2
67099: PUSH
67100: EMPTY
67101: ST_TO_ADDR
// exit ;
67102: GO 68433
// end ; for i in defenders do
67104: LD_ADDR_VAR 0 5
67108: PUSH
67109: LD_VAR 0 2
67113: PUSH
67114: FOR_IN
67115: IFFALSE 67933
// begin e := NearestUnitToUnit ( enemy , i ) ;
67117: LD_ADDR_VAR 0 14
67121: PUSH
67122: LD_VAR 0 3
67126: PPUSH
67127: LD_VAR 0 5
67131: PPUSH
67132: CALL_OW 74
67136: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67137: LD_ADDR_VAR 0 8
67141: PUSH
67142: LD_EXP 101
67146: PUSH
67147: LD_VAR 0 1
67151: ARRAY
67152: PPUSH
67153: LD_INT 2
67155: PUSH
67156: LD_INT 30
67158: PUSH
67159: LD_INT 0
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 30
67168: PUSH
67169: LD_INT 1
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: EMPTY
67177: LIST
67178: LIST
67179: LIST
67180: PPUSH
67181: CALL_OW 72
67185: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67186: LD_ADDR_VAR 0 17
67190: PUSH
67191: LD_VAR 0 8
67195: NOT
67196: PUSH
67197: LD_VAR 0 8
67201: PPUSH
67202: LD_INT 3
67204: PUSH
67205: LD_INT 24
67207: PUSH
67208: LD_INT 600
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PPUSH
67219: CALL_OW 72
67223: OR
67224: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67225: LD_VAR 0 5
67229: PPUSH
67230: CALL_OW 247
67234: PUSH
67235: LD_INT 2
67237: DOUBLE
67238: EQUAL
67239: IFTRUE 67243
67241: GO 67639
67243: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67244: LD_VAR 0 5
67248: PPUSH
67249: CALL_OW 256
67253: PUSH
67254: LD_INT 650
67256: GREATER
67257: PUSH
67258: LD_VAR 0 5
67262: PPUSH
67263: LD_VAR 0 14
67267: PPUSH
67268: CALL_OW 296
67272: PUSH
67273: LD_INT 40
67275: LESS
67276: PUSH
67277: LD_VAR 0 14
67281: PPUSH
67282: LD_EXP 126
67286: PUSH
67287: LD_VAR 0 1
67291: ARRAY
67292: PPUSH
67293: CALL_OW 308
67297: OR
67298: AND
67299: IFFALSE 67421
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67301: LD_VAR 0 5
67305: PPUSH
67306: CALL_OW 262
67310: PUSH
67311: LD_INT 1
67313: EQUAL
67314: PUSH
67315: LD_VAR 0 5
67319: PPUSH
67320: CALL_OW 261
67324: PUSH
67325: LD_INT 30
67327: LESS
67328: AND
67329: PUSH
67330: LD_VAR 0 8
67334: AND
67335: IFFALSE 67405
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67337: LD_VAR 0 5
67341: PPUSH
67342: LD_VAR 0 8
67346: PPUSH
67347: LD_VAR 0 5
67351: PPUSH
67352: CALL_OW 74
67356: PPUSH
67357: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67361: LD_VAR 0 5
67365: PPUSH
67366: LD_VAR 0 8
67370: PPUSH
67371: LD_VAR 0 5
67375: PPUSH
67376: CALL_OW 74
67380: PPUSH
67381: CALL_OW 296
67385: PUSH
67386: LD_INT 6
67388: LESS
67389: IFFALSE 67403
// SetFuel ( i , 100 ) ;
67391: LD_VAR 0 5
67395: PPUSH
67396: LD_INT 100
67398: PPUSH
67399: CALL_OW 240
// end else
67403: GO 67419
// ComAttackUnit ( i , e ) ;
67405: LD_VAR 0 5
67409: PPUSH
67410: LD_VAR 0 14
67414: PPUSH
67415: CALL_OW 115
// end else
67419: GO 67522
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67421: LD_VAR 0 14
67425: PPUSH
67426: LD_EXP 126
67430: PUSH
67431: LD_VAR 0 1
67435: ARRAY
67436: PPUSH
67437: CALL_OW 308
67441: NOT
67442: PUSH
67443: LD_VAR 0 5
67447: PPUSH
67448: LD_VAR 0 14
67452: PPUSH
67453: CALL_OW 296
67457: PUSH
67458: LD_INT 40
67460: GREATEREQUAL
67461: AND
67462: PUSH
67463: LD_VAR 0 5
67467: PPUSH
67468: CALL_OW 256
67472: PUSH
67473: LD_INT 650
67475: LESSEQUAL
67476: OR
67477: PUSH
67478: LD_VAR 0 5
67482: PPUSH
67483: LD_EXP 125
67487: PUSH
67488: LD_VAR 0 1
67492: ARRAY
67493: PPUSH
67494: CALL_OW 308
67498: NOT
67499: AND
67500: IFFALSE 67522
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67502: LD_VAR 0 5
67506: PPUSH
67507: LD_EXP 125
67511: PUSH
67512: LD_VAR 0 1
67516: ARRAY
67517: PPUSH
67518: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67522: LD_VAR 0 5
67526: PPUSH
67527: CALL_OW 256
67531: PUSH
67532: LD_INT 998
67534: LESS
67535: PUSH
67536: LD_VAR 0 5
67540: PPUSH
67541: CALL_OW 263
67545: PUSH
67546: LD_INT 1
67548: EQUAL
67549: AND
67550: PUSH
67551: LD_VAR 0 5
67555: PPUSH
67556: CALL_OW 311
67560: AND
67561: PUSH
67562: LD_VAR 0 5
67566: PPUSH
67567: LD_EXP 125
67571: PUSH
67572: LD_VAR 0 1
67576: ARRAY
67577: PPUSH
67578: CALL_OW 308
67582: AND
67583: IFFALSE 67637
// begin mech := IsDrivenBy ( i ) ;
67585: LD_ADDR_VAR 0 10
67589: PUSH
67590: LD_VAR 0 5
67594: PPUSH
67595: CALL_OW 311
67599: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67600: LD_VAR 0 10
67604: PPUSH
67605: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67609: LD_VAR 0 10
67613: PPUSH
67614: LD_VAR 0 5
67618: PPUSH
67619: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67623: LD_VAR 0 10
67627: PPUSH
67628: LD_VAR 0 5
67632: PPUSH
67633: CALL_OW 180
// end ; end ; unit_human :
67637: GO 67904
67639: LD_INT 1
67641: DOUBLE
67642: EQUAL
67643: IFTRUE 67647
67645: GO 67903
67647: POP
// begin b := IsInUnit ( i ) ;
67648: LD_ADDR_VAR 0 19
67652: PUSH
67653: LD_VAR 0 5
67657: PPUSH
67658: CALL_OW 310
67662: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67663: LD_ADDR_VAR 0 20
67667: PUSH
67668: LD_VAR 0 19
67672: NOT
67673: PUSH
67674: LD_VAR 0 19
67678: PPUSH
67679: CALL_OW 266
67683: PUSH
67684: LD_INT 32
67686: PUSH
67687: LD_INT 31
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: IN
67694: OR
67695: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67696: LD_VAR 0 17
67700: PUSH
67701: LD_VAR 0 2
67705: PPUSH
67706: LD_INT 21
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PPUSH
67716: CALL_OW 72
67720: PUSH
67721: LD_INT 1
67723: LESSEQUAL
67724: OR
67725: PUSH
67726: LD_VAR 0 20
67730: AND
67731: PUSH
67732: LD_VAR 0 5
67736: PUSH
67737: LD_VAR 0 18
67741: IN
67742: NOT
67743: AND
67744: IFFALSE 67837
// begin if b then
67746: LD_VAR 0 19
67750: IFFALSE 67799
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67752: LD_VAR 0 19
67756: PPUSH
67757: LD_VAR 0 3
67761: PPUSH
67762: LD_VAR 0 19
67766: PPUSH
67767: CALL_OW 74
67771: PPUSH
67772: CALL_OW 296
67776: PUSH
67777: LD_INT 10
67779: LESS
67780: PUSH
67781: LD_VAR 0 19
67785: PPUSH
67786: CALL_OW 461
67790: PUSH
67791: LD_INT 7
67793: NONEQUAL
67794: AND
67795: IFFALSE 67799
// continue ;
67797: GO 67114
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67799: LD_ADDR_VAR 0 18
67803: PUSH
67804: LD_VAR 0 18
67808: PPUSH
67809: LD_VAR 0 18
67813: PUSH
67814: LD_INT 1
67816: PLUS
67817: PPUSH
67818: LD_VAR 0 5
67822: PPUSH
67823: CALL_OW 1
67827: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67828: LD_VAR 0 5
67832: PPUSH
67833: CALL_OW 122
// end ; if sold_defenders then
67837: LD_VAR 0 18
67841: IFFALSE 67901
// if i in sold_defenders then
67843: LD_VAR 0 5
67847: PUSH
67848: LD_VAR 0 18
67852: IN
67853: IFFALSE 67901
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67855: LD_VAR 0 5
67859: PPUSH
67860: CALL_OW 314
67864: NOT
67865: PUSH
67866: LD_VAR 0 5
67870: PPUSH
67871: LD_VAR 0 14
67875: PPUSH
67876: CALL_OW 296
67880: PUSH
67881: LD_INT 30
67883: LESS
67884: AND
67885: IFFALSE 67901
// ComAttackUnit ( i , e ) ;
67887: LD_VAR 0 5
67891: PPUSH
67892: LD_VAR 0 14
67896: PPUSH
67897: CALL_OW 115
// end ; end ; end ;
67901: GO 67904
67903: POP
// if IsDead ( i ) then
67904: LD_VAR 0 5
67908: PPUSH
67909: CALL_OW 301
67913: IFFALSE 67931
// defenders := defenders diff i ;
67915: LD_ADDR_VAR 0 2
67919: PUSH
67920: LD_VAR 0 2
67924: PUSH
67925: LD_VAR 0 5
67929: DIFF
67930: ST_TO_ADDR
// end ;
67931: GO 67114
67933: POP
67934: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67935: LD_VAR 0 3
67939: NOT
67940: PUSH
67941: LD_VAR 0 2
67945: NOT
67946: OR
67947: PUSH
67948: LD_EXP 101
67952: PUSH
67953: LD_VAR 0 1
67957: ARRAY
67958: NOT
67959: OR
67960: IFFALSE 67018
// MC_Reset ( base , 18 ) ;
67962: LD_VAR 0 1
67966: PPUSH
67967: LD_INT 18
67969: PPUSH
67970: CALL 38300 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67974: LD_ADDR_VAR 0 2
67978: PUSH
67979: LD_VAR 0 2
67983: PUSH
67984: LD_VAR 0 2
67988: PPUSH
67989: LD_INT 2
67991: PUSH
67992: LD_INT 25
67994: PUSH
67995: LD_INT 1
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 25
68004: PUSH
68005: LD_INT 5
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 25
68014: PUSH
68015: LD_INT 8
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 25
68024: PUSH
68025: LD_INT 9
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: PPUSH
68039: CALL_OW 72
68043: DIFF
68044: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68045: LD_VAR 0 3
68049: NOT
68050: PUSH
68051: LD_VAR 0 2
68055: PPUSH
68056: LD_INT 21
68058: PUSH
68059: LD_INT 2
68061: PUSH
68062: EMPTY
68063: LIST
68064: LIST
68065: PPUSH
68066: CALL_OW 72
68070: AND
68071: IFFALSE 68409
// begin tmp := FilterByTag ( defenders , 19 ) ;
68073: LD_ADDR_VAR 0 12
68077: PUSH
68078: LD_VAR 0 2
68082: PPUSH
68083: LD_INT 19
68085: PPUSH
68086: CALL 104862 0 2
68090: ST_TO_ADDR
// if tmp then
68091: LD_VAR 0 12
68095: IFFALSE 68165
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68097: LD_ADDR_VAR 0 12
68101: PUSH
68102: LD_VAR 0 12
68106: PPUSH
68107: LD_INT 25
68109: PUSH
68110: LD_INT 3
68112: PUSH
68113: EMPTY
68114: LIST
68115: LIST
68116: PPUSH
68117: CALL_OW 72
68121: ST_TO_ADDR
// if tmp then
68122: LD_VAR 0 12
68126: IFFALSE 68165
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68128: LD_ADDR_EXP 113
68132: PUSH
68133: LD_EXP 113
68137: PPUSH
68138: LD_VAR 0 1
68142: PPUSH
68143: LD_EXP 113
68147: PUSH
68148: LD_VAR 0 1
68152: ARRAY
68153: PUSH
68154: LD_VAR 0 12
68158: UNION
68159: PPUSH
68160: CALL_OW 1
68164: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68165: LD_VAR 0 1
68169: PPUSH
68170: LD_INT 19
68172: PPUSH
68173: CALL 38300 0 2
// repeat wait ( 0 0$1 ) ;
68177: LD_INT 35
68179: PPUSH
68180: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68184: LD_EXP 101
68188: PUSH
68189: LD_VAR 0 1
68193: ARRAY
68194: NOT
68195: PUSH
68196: LD_EXP 101
68200: PUSH
68201: LD_VAR 0 1
68205: ARRAY
68206: PUSH
68207: EMPTY
68208: EQUAL
68209: OR
68210: IFFALSE 68247
// begin for i in defenders do
68212: LD_ADDR_VAR 0 5
68216: PUSH
68217: LD_VAR 0 2
68221: PUSH
68222: FOR_IN
68223: IFFALSE 68236
// ComStop ( i ) ;
68225: LD_VAR 0 5
68229: PPUSH
68230: CALL_OW 141
68234: GO 68222
68236: POP
68237: POP
// defenders := [ ] ;
68238: LD_ADDR_VAR 0 2
68242: PUSH
68243: EMPTY
68244: ST_TO_ADDR
// exit ;
68245: GO 68433
// end ; for i in defenders do
68247: LD_ADDR_VAR 0 5
68251: PUSH
68252: LD_VAR 0 2
68256: PUSH
68257: FOR_IN
68258: IFFALSE 68347
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68260: LD_VAR 0 5
68264: PPUSH
68265: LD_EXP 125
68269: PUSH
68270: LD_VAR 0 1
68274: ARRAY
68275: PPUSH
68276: CALL_OW 308
68280: NOT
68281: IFFALSE 68305
// ComMoveToArea ( i , mc_parking [ base ] ) else
68283: LD_VAR 0 5
68287: PPUSH
68288: LD_EXP 125
68292: PUSH
68293: LD_VAR 0 1
68297: ARRAY
68298: PPUSH
68299: CALL_OW 113
68303: GO 68345
// if GetControl ( i ) = control_manual then
68305: LD_VAR 0 5
68309: PPUSH
68310: CALL_OW 263
68314: PUSH
68315: LD_INT 1
68317: EQUAL
68318: IFFALSE 68345
// if IsDrivenBy ( i ) then
68320: LD_VAR 0 5
68324: PPUSH
68325: CALL_OW 311
68329: IFFALSE 68345
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68331: LD_VAR 0 5
68335: PPUSH
68336: CALL_OW 311
68340: PPUSH
68341: CALL_OW 121
// end ;
68345: GO 68257
68347: POP
68348: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68349: LD_VAR 0 2
68353: PPUSH
68354: LD_INT 95
68356: PUSH
68357: LD_EXP 125
68361: PUSH
68362: LD_VAR 0 1
68366: ARRAY
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PPUSH
68372: CALL_OW 72
68376: PUSH
68377: LD_VAR 0 2
68381: EQUAL
68382: PUSH
68383: LD_EXP 124
68387: PUSH
68388: LD_VAR 0 1
68392: ARRAY
68393: OR
68394: PUSH
68395: LD_EXP 101
68399: PUSH
68400: LD_VAR 0 1
68404: ARRAY
68405: NOT
68406: OR
68407: IFFALSE 68177
// end ; MC_Reset ( base , 19 ) ;
68409: LD_VAR 0 1
68413: PPUSH
68414: LD_INT 19
68416: PPUSH
68417: CALL 38300 0 2
// MC_Reset ( base , 20 ) ;
68421: LD_VAR 0 1
68425: PPUSH
68426: LD_INT 20
68428: PPUSH
68429: CALL 38300 0 2
// end ;
68433: LD_VAR 0 4
68437: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68438: LD_INT 0
68440: PPUSH
68441: PPUSH
68442: PPUSH
68443: PPUSH
// result := false ;
68444: LD_ADDR_VAR 0 2
68448: PUSH
68449: LD_INT 0
68451: ST_TO_ADDR
// side := GetSide ( unit ) ;
68452: LD_ADDR_VAR 0 3
68456: PUSH
68457: LD_VAR 0 1
68461: PPUSH
68462: CALL_OW 255
68466: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68467: LD_ADDR_VAR 0 4
68471: PUSH
68472: LD_VAR 0 1
68476: PPUSH
68477: CALL_OW 248
68481: ST_TO_ADDR
// case nat of 1 :
68482: LD_VAR 0 4
68486: PUSH
68487: LD_INT 1
68489: DOUBLE
68490: EQUAL
68491: IFTRUE 68495
68493: GO 68506
68495: POP
// tech := tech_lassight ; 2 :
68496: LD_ADDR_VAR 0 5
68500: PUSH
68501: LD_INT 12
68503: ST_TO_ADDR
68504: GO 68545
68506: LD_INT 2
68508: DOUBLE
68509: EQUAL
68510: IFTRUE 68514
68512: GO 68525
68514: POP
// tech := tech_mortar ; 3 :
68515: LD_ADDR_VAR 0 5
68519: PUSH
68520: LD_INT 41
68522: ST_TO_ADDR
68523: GO 68545
68525: LD_INT 3
68527: DOUBLE
68528: EQUAL
68529: IFTRUE 68533
68531: GO 68544
68533: POP
// tech := tech_bazooka ; end ;
68534: LD_ADDR_VAR 0 5
68538: PUSH
68539: LD_INT 44
68541: ST_TO_ADDR
68542: GO 68545
68544: POP
// if Researched ( side , tech ) then
68545: LD_VAR 0 3
68549: PPUSH
68550: LD_VAR 0 5
68554: PPUSH
68555: CALL_OW 325
68559: IFFALSE 68586
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68561: LD_ADDR_VAR 0 2
68565: PUSH
68566: LD_INT 5
68568: PUSH
68569: LD_INT 8
68571: PUSH
68572: LD_INT 9
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: LIST
68579: PUSH
68580: LD_VAR 0 4
68584: ARRAY
68585: ST_TO_ADDR
// end ;
68586: LD_VAR 0 2
68590: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68591: LD_INT 0
68593: PPUSH
68594: PPUSH
68595: PPUSH
// if not mines then
68596: LD_VAR 0 2
68600: NOT
68601: IFFALSE 68605
// exit ;
68603: GO 68749
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68605: LD_ADDR_VAR 0 5
68609: PUSH
68610: LD_INT 81
68612: PUSH
68613: LD_VAR 0 1
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PUSH
68622: LD_INT 3
68624: PUSH
68625: LD_INT 21
68627: PUSH
68628: LD_INT 3
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: EMPTY
68636: LIST
68637: LIST
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PPUSH
68643: CALL_OW 69
68647: ST_TO_ADDR
// for i in mines do
68648: LD_ADDR_VAR 0 4
68652: PUSH
68653: LD_VAR 0 2
68657: PUSH
68658: FOR_IN
68659: IFFALSE 68747
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68661: LD_VAR 0 4
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PPUSH
68670: LD_VAR 0 4
68674: PUSH
68675: LD_INT 2
68677: ARRAY
68678: PPUSH
68679: CALL_OW 458
68683: NOT
68684: IFFALSE 68688
// continue ;
68686: GO 68658
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68688: LD_VAR 0 4
68692: PUSH
68693: LD_INT 1
68695: ARRAY
68696: PPUSH
68697: LD_VAR 0 4
68701: PUSH
68702: LD_INT 2
68704: ARRAY
68705: PPUSH
68706: CALL_OW 428
68710: PUSH
68711: LD_VAR 0 5
68715: IN
68716: IFFALSE 68745
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68718: LD_VAR 0 4
68722: PUSH
68723: LD_INT 1
68725: ARRAY
68726: PPUSH
68727: LD_VAR 0 4
68731: PUSH
68732: LD_INT 2
68734: ARRAY
68735: PPUSH
68736: LD_VAR 0 1
68740: PPUSH
68741: CALL_OW 456
// end ;
68745: GO 68658
68747: POP
68748: POP
// end ;
68749: LD_VAR 0 3
68753: RET
// export function Count ( array ) ; var i ; begin
68754: LD_INT 0
68756: PPUSH
68757: PPUSH
// result := 0 ;
68758: LD_ADDR_VAR 0 2
68762: PUSH
68763: LD_INT 0
68765: ST_TO_ADDR
// for i in array do
68766: LD_ADDR_VAR 0 3
68770: PUSH
68771: LD_VAR 0 1
68775: PUSH
68776: FOR_IN
68777: IFFALSE 68801
// if i then
68779: LD_VAR 0 3
68783: IFFALSE 68799
// result := result + 1 ;
68785: LD_ADDR_VAR 0 2
68789: PUSH
68790: LD_VAR 0 2
68794: PUSH
68795: LD_INT 1
68797: PLUS
68798: ST_TO_ADDR
68799: GO 68776
68801: POP
68802: POP
// end ;
68803: LD_VAR 0 2
68807: RET
// export function IsEmpty ( building ) ; begin
68808: LD_INT 0
68810: PPUSH
// if not building then
68811: LD_VAR 0 1
68815: NOT
68816: IFFALSE 68820
// exit ;
68818: GO 68863
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68820: LD_ADDR_VAR 0 2
68824: PUSH
68825: LD_VAR 0 1
68829: PUSH
68830: LD_INT 22
68832: PUSH
68833: LD_VAR 0 1
68837: PPUSH
68838: CALL_OW 255
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 58
68849: PUSH
68850: EMPTY
68851: LIST
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PPUSH
68857: CALL_OW 69
68861: IN
68862: ST_TO_ADDR
// end ;
68863: LD_VAR 0 2
68867: RET
// export function IsNotFull ( building ) ; begin
68868: LD_INT 0
68870: PPUSH
// if not building then
68871: LD_VAR 0 1
68875: NOT
68876: IFFALSE 68880
// exit ;
68878: GO 68899
// result := UnitsInside ( building ) < 6 ;
68880: LD_ADDR_VAR 0 2
68884: PUSH
68885: LD_VAR 0 1
68889: PPUSH
68890: CALL_OW 313
68894: PUSH
68895: LD_INT 6
68897: LESS
68898: ST_TO_ADDR
// end ;
68899: LD_VAR 0 2
68903: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68904: LD_INT 0
68906: PPUSH
68907: PPUSH
68908: PPUSH
68909: PPUSH
// tmp := [ ] ;
68910: LD_ADDR_VAR 0 3
68914: PUSH
68915: EMPTY
68916: ST_TO_ADDR
// list := [ ] ;
68917: LD_ADDR_VAR 0 5
68921: PUSH
68922: EMPTY
68923: ST_TO_ADDR
// for i = 16 to 25 do
68924: LD_ADDR_VAR 0 4
68928: PUSH
68929: DOUBLE
68930: LD_INT 16
68932: DEC
68933: ST_TO_ADDR
68934: LD_INT 25
68936: PUSH
68937: FOR_TO
68938: IFFALSE 69011
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68940: LD_ADDR_VAR 0 3
68944: PUSH
68945: LD_VAR 0 3
68949: PUSH
68950: LD_INT 22
68952: PUSH
68953: LD_VAR 0 1
68957: PPUSH
68958: CALL_OW 255
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: LD_INT 91
68969: PUSH
68970: LD_VAR 0 1
68974: PUSH
68975: LD_INT 6
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 30
68985: PUSH
68986: LD_VAR 0 4
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: LIST
68999: PUSH
69000: EMPTY
69001: LIST
69002: PPUSH
69003: CALL_OW 69
69007: ADD
69008: ST_TO_ADDR
69009: GO 68937
69011: POP
69012: POP
// for i = 1 to tmp do
69013: LD_ADDR_VAR 0 4
69017: PUSH
69018: DOUBLE
69019: LD_INT 1
69021: DEC
69022: ST_TO_ADDR
69023: LD_VAR 0 3
69027: PUSH
69028: FOR_TO
69029: IFFALSE 69117
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69031: LD_ADDR_VAR 0 5
69035: PUSH
69036: LD_VAR 0 5
69040: PUSH
69041: LD_VAR 0 3
69045: PUSH
69046: LD_VAR 0 4
69050: ARRAY
69051: PPUSH
69052: CALL_OW 266
69056: PUSH
69057: LD_VAR 0 3
69061: PUSH
69062: LD_VAR 0 4
69066: ARRAY
69067: PPUSH
69068: CALL_OW 250
69072: PUSH
69073: LD_VAR 0 3
69077: PUSH
69078: LD_VAR 0 4
69082: ARRAY
69083: PPUSH
69084: CALL_OW 251
69088: PUSH
69089: LD_VAR 0 3
69093: PUSH
69094: LD_VAR 0 4
69098: ARRAY
69099: PPUSH
69100: CALL_OW 254
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: LIST
69109: LIST
69110: PUSH
69111: EMPTY
69112: LIST
69113: ADD
69114: ST_TO_ADDR
69115: GO 69028
69117: POP
69118: POP
// result := list ;
69119: LD_ADDR_VAR 0 2
69123: PUSH
69124: LD_VAR 0 5
69128: ST_TO_ADDR
// end ;
69129: LD_VAR 0 2
69133: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69134: LD_INT 0
69136: PPUSH
69137: PPUSH
69138: PPUSH
69139: PPUSH
69140: PPUSH
69141: PPUSH
69142: PPUSH
// if not factory then
69143: LD_VAR 0 1
69147: NOT
69148: IFFALSE 69152
// exit ;
69150: GO 69745
// if control = control_apeman then
69152: LD_VAR 0 4
69156: PUSH
69157: LD_INT 5
69159: EQUAL
69160: IFFALSE 69269
// begin tmp := UnitsInside ( factory ) ;
69162: LD_ADDR_VAR 0 8
69166: PUSH
69167: LD_VAR 0 1
69171: PPUSH
69172: CALL_OW 313
69176: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69177: LD_VAR 0 8
69181: PPUSH
69182: LD_INT 25
69184: PUSH
69185: LD_INT 12
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PPUSH
69192: CALL_OW 72
69196: NOT
69197: IFFALSE 69207
// control := control_manual ;
69199: LD_ADDR_VAR 0 4
69203: PUSH
69204: LD_INT 1
69206: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69207: LD_ADDR_VAR 0 8
69211: PUSH
69212: LD_VAR 0 1
69216: PPUSH
69217: CALL 68904 0 1
69221: ST_TO_ADDR
// if tmp then
69222: LD_VAR 0 8
69226: IFFALSE 69269
// begin for i in tmp do
69228: LD_ADDR_VAR 0 7
69232: PUSH
69233: LD_VAR 0 8
69237: PUSH
69238: FOR_IN
69239: IFFALSE 69267
// if i [ 1 ] = b_ext_radio then
69241: LD_VAR 0 7
69245: PUSH
69246: LD_INT 1
69248: ARRAY
69249: PUSH
69250: LD_INT 22
69252: EQUAL
69253: IFFALSE 69265
// begin control := control_remote ;
69255: LD_ADDR_VAR 0 4
69259: PUSH
69260: LD_INT 2
69262: ST_TO_ADDR
// break ;
69263: GO 69267
// end ;
69265: GO 69238
69267: POP
69268: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69269: LD_VAR 0 1
69273: PPUSH
69274: LD_VAR 0 2
69278: PPUSH
69279: LD_VAR 0 3
69283: PPUSH
69284: LD_VAR 0 4
69288: PPUSH
69289: LD_VAR 0 5
69293: PPUSH
69294: CALL_OW 448
69298: IFFALSE 69333
// begin result := [ chassis , engine , control , weapon ] ;
69300: LD_ADDR_VAR 0 6
69304: PUSH
69305: LD_VAR 0 2
69309: PUSH
69310: LD_VAR 0 3
69314: PUSH
69315: LD_VAR 0 4
69319: PUSH
69320: LD_VAR 0 5
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: ST_TO_ADDR
// exit ;
69331: GO 69745
// end ; _chassis := AvailableChassisList ( factory ) ;
69333: LD_ADDR_VAR 0 9
69337: PUSH
69338: LD_VAR 0 1
69342: PPUSH
69343: CALL_OW 475
69347: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69348: LD_ADDR_VAR 0 11
69352: PUSH
69353: LD_VAR 0 1
69357: PPUSH
69358: CALL_OW 476
69362: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69363: LD_ADDR_VAR 0 12
69367: PUSH
69368: LD_VAR 0 1
69372: PPUSH
69373: CALL_OW 477
69377: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69378: LD_ADDR_VAR 0 10
69382: PUSH
69383: LD_VAR 0 1
69387: PPUSH
69388: CALL_OW 478
69392: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69393: LD_VAR 0 9
69397: NOT
69398: PUSH
69399: LD_VAR 0 11
69403: NOT
69404: OR
69405: PUSH
69406: LD_VAR 0 12
69410: NOT
69411: OR
69412: PUSH
69413: LD_VAR 0 10
69417: NOT
69418: OR
69419: IFFALSE 69454
// begin result := [ chassis , engine , control , weapon ] ;
69421: LD_ADDR_VAR 0 6
69425: PUSH
69426: LD_VAR 0 2
69430: PUSH
69431: LD_VAR 0 3
69435: PUSH
69436: LD_VAR 0 4
69440: PUSH
69441: LD_VAR 0 5
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: LIST
69450: LIST
69451: ST_TO_ADDR
// exit ;
69452: GO 69745
// end ; if not chassis in _chassis then
69454: LD_VAR 0 2
69458: PUSH
69459: LD_VAR 0 9
69463: IN
69464: NOT
69465: IFFALSE 69491
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69467: LD_ADDR_VAR 0 2
69471: PUSH
69472: LD_VAR 0 9
69476: PUSH
69477: LD_INT 1
69479: PPUSH
69480: LD_VAR 0 9
69484: PPUSH
69485: CALL_OW 12
69489: ARRAY
69490: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69491: LD_VAR 0 2
69495: PPUSH
69496: LD_VAR 0 3
69500: PPUSH
69501: CALL 69750 0 2
69505: NOT
69506: IFFALSE 69565
// repeat engine := _engine [ 1 ] ;
69508: LD_ADDR_VAR 0 3
69512: PUSH
69513: LD_VAR 0 11
69517: PUSH
69518: LD_INT 1
69520: ARRAY
69521: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69522: LD_ADDR_VAR 0 11
69526: PUSH
69527: LD_VAR 0 11
69531: PPUSH
69532: LD_INT 1
69534: PPUSH
69535: CALL_OW 3
69539: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69540: LD_VAR 0 2
69544: PPUSH
69545: LD_VAR 0 3
69549: PPUSH
69550: CALL 69750 0 2
69554: PUSH
69555: LD_VAR 0 11
69559: PUSH
69560: EMPTY
69561: EQUAL
69562: OR
69563: IFFALSE 69508
// if not control in _control then
69565: LD_VAR 0 4
69569: PUSH
69570: LD_VAR 0 12
69574: IN
69575: NOT
69576: IFFALSE 69602
// control := _control [ rand ( 1 , _control ) ] ;
69578: LD_ADDR_VAR 0 4
69582: PUSH
69583: LD_VAR 0 12
69587: PUSH
69588: LD_INT 1
69590: PPUSH
69591: LD_VAR 0 12
69595: PPUSH
69596: CALL_OW 12
69600: ARRAY
69601: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69602: LD_VAR 0 2
69606: PPUSH
69607: LD_VAR 0 5
69611: PPUSH
69612: CALL 69970 0 2
69616: NOT
69617: IFFALSE 69676
// repeat weapon := _weapon [ 1 ] ;
69619: LD_ADDR_VAR 0 5
69623: PUSH
69624: LD_VAR 0 10
69628: PUSH
69629: LD_INT 1
69631: ARRAY
69632: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69633: LD_ADDR_VAR 0 10
69637: PUSH
69638: LD_VAR 0 10
69642: PPUSH
69643: LD_INT 1
69645: PPUSH
69646: CALL_OW 3
69650: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69651: LD_VAR 0 2
69655: PPUSH
69656: LD_VAR 0 5
69660: PPUSH
69661: CALL 69970 0 2
69665: PUSH
69666: LD_VAR 0 10
69670: PUSH
69671: EMPTY
69672: EQUAL
69673: OR
69674: IFFALSE 69619
// result := [ ] ;
69676: LD_ADDR_VAR 0 6
69680: PUSH
69681: EMPTY
69682: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69683: LD_VAR 0 1
69687: PPUSH
69688: LD_VAR 0 2
69692: PPUSH
69693: LD_VAR 0 3
69697: PPUSH
69698: LD_VAR 0 4
69702: PPUSH
69703: LD_VAR 0 5
69707: PPUSH
69708: CALL_OW 448
69712: IFFALSE 69745
// result := [ chassis , engine , control , weapon ] ;
69714: LD_ADDR_VAR 0 6
69718: PUSH
69719: LD_VAR 0 2
69723: PUSH
69724: LD_VAR 0 3
69728: PUSH
69729: LD_VAR 0 4
69733: PUSH
69734: LD_VAR 0 5
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: ST_TO_ADDR
// end ;
69745: LD_VAR 0 6
69749: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69750: LD_INT 0
69752: PPUSH
// if not chassis or not engine then
69753: LD_VAR 0 1
69757: NOT
69758: PUSH
69759: LD_VAR 0 2
69763: NOT
69764: OR
69765: IFFALSE 69769
// exit ;
69767: GO 69965
// case engine of engine_solar :
69769: LD_VAR 0 2
69773: PUSH
69774: LD_INT 2
69776: DOUBLE
69777: EQUAL
69778: IFTRUE 69782
69780: GO 69820
69782: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69783: LD_ADDR_VAR 0 3
69787: PUSH
69788: LD_INT 11
69790: PUSH
69791: LD_INT 12
69793: PUSH
69794: LD_INT 13
69796: PUSH
69797: LD_INT 14
69799: PUSH
69800: LD_INT 1
69802: PUSH
69803: LD_INT 2
69805: PUSH
69806: LD_INT 3
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: LIST
69815: LIST
69816: LIST
69817: ST_TO_ADDR
69818: GO 69949
69820: LD_INT 1
69822: DOUBLE
69823: EQUAL
69824: IFTRUE 69828
69826: GO 69890
69828: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69829: LD_ADDR_VAR 0 3
69833: PUSH
69834: LD_INT 11
69836: PUSH
69837: LD_INT 12
69839: PUSH
69840: LD_INT 13
69842: PUSH
69843: LD_INT 14
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: LD_INT 2
69851: PUSH
69852: LD_INT 3
69854: PUSH
69855: LD_INT 4
69857: PUSH
69858: LD_INT 5
69860: PUSH
69861: LD_INT 21
69863: PUSH
69864: LD_INT 23
69866: PUSH
69867: LD_INT 22
69869: PUSH
69870: LD_INT 24
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: LIST
69885: LIST
69886: LIST
69887: ST_TO_ADDR
69888: GO 69949
69890: LD_INT 3
69892: DOUBLE
69893: EQUAL
69894: IFTRUE 69898
69896: GO 69948
69898: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69899: LD_ADDR_VAR 0 3
69903: PUSH
69904: LD_INT 13
69906: PUSH
69907: LD_INT 14
69909: PUSH
69910: LD_INT 2
69912: PUSH
69913: LD_INT 3
69915: PUSH
69916: LD_INT 4
69918: PUSH
69919: LD_INT 5
69921: PUSH
69922: LD_INT 21
69924: PUSH
69925: LD_INT 22
69927: PUSH
69928: LD_INT 23
69930: PUSH
69931: LD_INT 24
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: ST_TO_ADDR
69946: GO 69949
69948: POP
// result := ( chassis in result ) ;
69949: LD_ADDR_VAR 0 3
69953: PUSH
69954: LD_VAR 0 1
69958: PUSH
69959: LD_VAR 0 3
69963: IN
69964: ST_TO_ADDR
// end ;
69965: LD_VAR 0 3
69969: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69970: LD_INT 0
69972: PPUSH
// if not chassis or not weapon then
69973: LD_VAR 0 1
69977: NOT
69978: PUSH
69979: LD_VAR 0 2
69983: NOT
69984: OR
69985: IFFALSE 69989
// exit ;
69987: GO 71015
// case weapon of us_machine_gun :
69989: LD_VAR 0 2
69993: PUSH
69994: LD_INT 2
69996: DOUBLE
69997: EQUAL
69998: IFTRUE 70002
70000: GO 70032
70002: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70003: LD_ADDR_VAR 0 3
70007: PUSH
70008: LD_INT 1
70010: PUSH
70011: LD_INT 2
70013: PUSH
70014: LD_INT 3
70016: PUSH
70017: LD_INT 4
70019: PUSH
70020: LD_INT 5
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: ST_TO_ADDR
70030: GO 70999
70032: LD_INT 3
70034: DOUBLE
70035: EQUAL
70036: IFTRUE 70040
70038: GO 70070
70040: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70041: LD_ADDR_VAR 0 3
70045: PUSH
70046: LD_INT 1
70048: PUSH
70049: LD_INT 2
70051: PUSH
70052: LD_INT 3
70054: PUSH
70055: LD_INT 4
70057: PUSH
70058: LD_INT 5
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: LIST
70067: ST_TO_ADDR
70068: GO 70999
70070: LD_INT 11
70072: DOUBLE
70073: EQUAL
70074: IFTRUE 70078
70076: GO 70108
70078: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70079: LD_ADDR_VAR 0 3
70083: PUSH
70084: LD_INT 1
70086: PUSH
70087: LD_INT 2
70089: PUSH
70090: LD_INT 3
70092: PUSH
70093: LD_INT 4
70095: PUSH
70096: LD_INT 5
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: LIST
70105: ST_TO_ADDR
70106: GO 70999
70108: LD_INT 4
70110: DOUBLE
70111: EQUAL
70112: IFTRUE 70116
70114: GO 70142
70116: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70117: LD_ADDR_VAR 0 3
70121: PUSH
70122: LD_INT 2
70124: PUSH
70125: LD_INT 3
70127: PUSH
70128: LD_INT 4
70130: PUSH
70131: LD_INT 5
70133: PUSH
70134: EMPTY
70135: LIST
70136: LIST
70137: LIST
70138: LIST
70139: ST_TO_ADDR
70140: GO 70999
70142: LD_INT 5
70144: DOUBLE
70145: EQUAL
70146: IFTRUE 70150
70148: GO 70176
70150: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70151: LD_ADDR_VAR 0 3
70155: PUSH
70156: LD_INT 2
70158: PUSH
70159: LD_INT 3
70161: PUSH
70162: LD_INT 4
70164: PUSH
70165: LD_INT 5
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: ST_TO_ADDR
70174: GO 70999
70176: LD_INT 9
70178: DOUBLE
70179: EQUAL
70180: IFTRUE 70184
70182: GO 70210
70184: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70185: LD_ADDR_VAR 0 3
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: LD_INT 3
70195: PUSH
70196: LD_INT 4
70198: PUSH
70199: LD_INT 5
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: ST_TO_ADDR
70208: GO 70999
70210: LD_INT 7
70212: DOUBLE
70213: EQUAL
70214: IFTRUE 70218
70216: GO 70244
70218: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70219: LD_ADDR_VAR 0 3
70223: PUSH
70224: LD_INT 2
70226: PUSH
70227: LD_INT 3
70229: PUSH
70230: LD_INT 4
70232: PUSH
70233: LD_INT 5
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: ST_TO_ADDR
70242: GO 70999
70244: LD_INT 12
70246: DOUBLE
70247: EQUAL
70248: IFTRUE 70252
70250: GO 70278
70252: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70253: LD_ADDR_VAR 0 3
70257: PUSH
70258: LD_INT 2
70260: PUSH
70261: LD_INT 3
70263: PUSH
70264: LD_INT 4
70266: PUSH
70267: LD_INT 5
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: ST_TO_ADDR
70276: GO 70999
70278: LD_INT 13
70280: DOUBLE
70281: EQUAL
70282: IFTRUE 70286
70284: GO 70312
70286: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70287: LD_ADDR_VAR 0 3
70291: PUSH
70292: LD_INT 2
70294: PUSH
70295: LD_INT 3
70297: PUSH
70298: LD_INT 4
70300: PUSH
70301: LD_INT 5
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: ST_TO_ADDR
70310: GO 70999
70312: LD_INT 14
70314: DOUBLE
70315: EQUAL
70316: IFTRUE 70320
70318: GO 70338
70320: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70321: LD_ADDR_VAR 0 3
70325: PUSH
70326: LD_INT 4
70328: PUSH
70329: LD_INT 5
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: ST_TO_ADDR
70336: GO 70999
70338: LD_INT 6
70340: DOUBLE
70341: EQUAL
70342: IFTRUE 70346
70344: GO 70364
70346: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70347: LD_ADDR_VAR 0 3
70351: PUSH
70352: LD_INT 4
70354: PUSH
70355: LD_INT 5
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: ST_TO_ADDR
70362: GO 70999
70364: LD_INT 10
70366: DOUBLE
70367: EQUAL
70368: IFTRUE 70372
70370: GO 70390
70372: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70373: LD_ADDR_VAR 0 3
70377: PUSH
70378: LD_INT 4
70380: PUSH
70381: LD_INT 5
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: ST_TO_ADDR
70388: GO 70999
70390: LD_INT 22
70392: DOUBLE
70393: EQUAL
70394: IFTRUE 70398
70396: GO 70424
70398: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70399: LD_ADDR_VAR 0 3
70403: PUSH
70404: LD_INT 11
70406: PUSH
70407: LD_INT 12
70409: PUSH
70410: LD_INT 13
70412: PUSH
70413: LD_INT 14
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: LIST
70420: LIST
70421: ST_TO_ADDR
70422: GO 70999
70424: LD_INT 23
70426: DOUBLE
70427: EQUAL
70428: IFTRUE 70432
70430: GO 70458
70432: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70433: LD_ADDR_VAR 0 3
70437: PUSH
70438: LD_INT 11
70440: PUSH
70441: LD_INT 12
70443: PUSH
70444: LD_INT 13
70446: PUSH
70447: LD_INT 14
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: ST_TO_ADDR
70456: GO 70999
70458: LD_INT 24
70460: DOUBLE
70461: EQUAL
70462: IFTRUE 70466
70464: GO 70492
70466: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70467: LD_ADDR_VAR 0 3
70471: PUSH
70472: LD_INT 11
70474: PUSH
70475: LD_INT 12
70477: PUSH
70478: LD_INT 13
70480: PUSH
70481: LD_INT 14
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: LIST
70488: LIST
70489: ST_TO_ADDR
70490: GO 70999
70492: LD_INT 30
70494: DOUBLE
70495: EQUAL
70496: IFTRUE 70500
70498: GO 70526
70500: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70501: LD_ADDR_VAR 0 3
70505: PUSH
70506: LD_INT 11
70508: PUSH
70509: LD_INT 12
70511: PUSH
70512: LD_INT 13
70514: PUSH
70515: LD_INT 14
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: ST_TO_ADDR
70524: GO 70999
70526: LD_INT 25
70528: DOUBLE
70529: EQUAL
70530: IFTRUE 70534
70532: GO 70552
70534: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70535: LD_ADDR_VAR 0 3
70539: PUSH
70540: LD_INT 13
70542: PUSH
70543: LD_INT 14
70545: PUSH
70546: EMPTY
70547: LIST
70548: LIST
70549: ST_TO_ADDR
70550: GO 70999
70552: LD_INT 27
70554: DOUBLE
70555: EQUAL
70556: IFTRUE 70560
70558: GO 70578
70560: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70561: LD_ADDR_VAR 0 3
70565: PUSH
70566: LD_INT 13
70568: PUSH
70569: LD_INT 14
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: ST_TO_ADDR
70576: GO 70999
70578: LD_INT 28
70580: DOUBLE
70581: EQUAL
70582: IFTRUE 70586
70584: GO 70604
70586: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70587: LD_ADDR_VAR 0 3
70591: PUSH
70592: LD_INT 13
70594: PUSH
70595: LD_INT 14
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: ST_TO_ADDR
70602: GO 70999
70604: LD_INT 29
70606: DOUBLE
70607: EQUAL
70608: IFTRUE 70612
70610: GO 70630
70612: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70613: LD_ADDR_VAR 0 3
70617: PUSH
70618: LD_INT 13
70620: PUSH
70621: LD_INT 14
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: ST_TO_ADDR
70628: GO 70999
70630: LD_INT 31
70632: DOUBLE
70633: EQUAL
70634: IFTRUE 70638
70636: GO 70656
70638: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70639: LD_ADDR_VAR 0 3
70643: PUSH
70644: LD_INT 13
70646: PUSH
70647: LD_INT 14
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: ST_TO_ADDR
70654: GO 70999
70656: LD_INT 26
70658: DOUBLE
70659: EQUAL
70660: IFTRUE 70664
70662: GO 70682
70664: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70665: LD_ADDR_VAR 0 3
70669: PUSH
70670: LD_INT 13
70672: PUSH
70673: LD_INT 14
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: ST_TO_ADDR
70680: GO 70999
70682: LD_INT 42
70684: DOUBLE
70685: EQUAL
70686: IFTRUE 70690
70688: GO 70716
70690: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: LD_INT 21
70698: PUSH
70699: LD_INT 22
70701: PUSH
70702: LD_INT 23
70704: PUSH
70705: LD_INT 24
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: ST_TO_ADDR
70714: GO 70999
70716: LD_INT 43
70718: DOUBLE
70719: EQUAL
70720: IFTRUE 70724
70722: GO 70750
70724: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70725: LD_ADDR_VAR 0 3
70729: PUSH
70730: LD_INT 21
70732: PUSH
70733: LD_INT 22
70735: PUSH
70736: LD_INT 23
70738: PUSH
70739: LD_INT 24
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: ST_TO_ADDR
70748: GO 70999
70750: LD_INT 44
70752: DOUBLE
70753: EQUAL
70754: IFTRUE 70758
70756: GO 70784
70758: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70759: LD_ADDR_VAR 0 3
70763: PUSH
70764: LD_INT 21
70766: PUSH
70767: LD_INT 22
70769: PUSH
70770: LD_INT 23
70772: PUSH
70773: LD_INT 24
70775: PUSH
70776: EMPTY
70777: LIST
70778: LIST
70779: LIST
70780: LIST
70781: ST_TO_ADDR
70782: GO 70999
70784: LD_INT 45
70786: DOUBLE
70787: EQUAL
70788: IFTRUE 70792
70790: GO 70818
70792: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70793: LD_ADDR_VAR 0 3
70797: PUSH
70798: LD_INT 21
70800: PUSH
70801: LD_INT 22
70803: PUSH
70804: LD_INT 23
70806: PUSH
70807: LD_INT 24
70809: PUSH
70810: EMPTY
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: ST_TO_ADDR
70816: GO 70999
70818: LD_INT 49
70820: DOUBLE
70821: EQUAL
70822: IFTRUE 70826
70824: GO 70852
70826: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70827: LD_ADDR_VAR 0 3
70831: PUSH
70832: LD_INT 21
70834: PUSH
70835: LD_INT 22
70837: PUSH
70838: LD_INT 23
70840: PUSH
70841: LD_INT 24
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: LIST
70848: LIST
70849: ST_TO_ADDR
70850: GO 70999
70852: LD_INT 51
70854: DOUBLE
70855: EQUAL
70856: IFTRUE 70860
70858: GO 70886
70860: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70861: LD_ADDR_VAR 0 3
70865: PUSH
70866: LD_INT 21
70868: PUSH
70869: LD_INT 22
70871: PUSH
70872: LD_INT 23
70874: PUSH
70875: LD_INT 24
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: ST_TO_ADDR
70884: GO 70999
70886: LD_INT 52
70888: DOUBLE
70889: EQUAL
70890: IFTRUE 70894
70892: GO 70920
70894: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70895: LD_ADDR_VAR 0 3
70899: PUSH
70900: LD_INT 21
70902: PUSH
70903: LD_INT 22
70905: PUSH
70906: LD_INT 23
70908: PUSH
70909: LD_INT 24
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: LIST
70916: LIST
70917: ST_TO_ADDR
70918: GO 70999
70920: LD_INT 53
70922: DOUBLE
70923: EQUAL
70924: IFTRUE 70928
70926: GO 70946
70928: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70929: LD_ADDR_VAR 0 3
70933: PUSH
70934: LD_INT 23
70936: PUSH
70937: LD_INT 24
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: ST_TO_ADDR
70944: GO 70999
70946: LD_INT 46
70948: DOUBLE
70949: EQUAL
70950: IFTRUE 70954
70952: GO 70972
70954: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70955: LD_ADDR_VAR 0 3
70959: PUSH
70960: LD_INT 23
70962: PUSH
70963: LD_INT 24
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: ST_TO_ADDR
70970: GO 70999
70972: LD_INT 47
70974: DOUBLE
70975: EQUAL
70976: IFTRUE 70980
70978: GO 70998
70980: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70981: LD_ADDR_VAR 0 3
70985: PUSH
70986: LD_INT 23
70988: PUSH
70989: LD_INT 24
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: ST_TO_ADDR
70996: GO 70999
70998: POP
// result := ( chassis in result ) ;
70999: LD_ADDR_VAR 0 3
71003: PUSH
71004: LD_VAR 0 1
71008: PUSH
71009: LD_VAR 0 3
71013: IN
71014: ST_TO_ADDR
// end ;
71015: LD_VAR 0 3
71019: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71020: LD_INT 0
71022: PPUSH
71023: PPUSH
71024: PPUSH
71025: PPUSH
71026: PPUSH
71027: PPUSH
71028: PPUSH
// result := array ;
71029: LD_ADDR_VAR 0 5
71033: PUSH
71034: LD_VAR 0 1
71038: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71039: LD_VAR 0 1
71043: NOT
71044: PUSH
71045: LD_VAR 0 2
71049: NOT
71050: OR
71051: PUSH
71052: LD_VAR 0 3
71056: NOT
71057: OR
71058: PUSH
71059: LD_VAR 0 2
71063: PUSH
71064: LD_VAR 0 1
71068: GREATER
71069: OR
71070: PUSH
71071: LD_VAR 0 3
71075: PUSH
71076: LD_VAR 0 1
71080: GREATER
71081: OR
71082: IFFALSE 71086
// exit ;
71084: GO 71382
// if direction then
71086: LD_VAR 0 4
71090: IFFALSE 71154
// begin d := 1 ;
71092: LD_ADDR_VAR 0 9
71096: PUSH
71097: LD_INT 1
71099: ST_TO_ADDR
// if i_from > i_to then
71100: LD_VAR 0 2
71104: PUSH
71105: LD_VAR 0 3
71109: GREATER
71110: IFFALSE 71136
// length := ( array - i_from ) + i_to else
71112: LD_ADDR_VAR 0 11
71116: PUSH
71117: LD_VAR 0 1
71121: PUSH
71122: LD_VAR 0 2
71126: MINUS
71127: PUSH
71128: LD_VAR 0 3
71132: PLUS
71133: ST_TO_ADDR
71134: GO 71152
// length := i_to - i_from ;
71136: LD_ADDR_VAR 0 11
71140: PUSH
71141: LD_VAR 0 3
71145: PUSH
71146: LD_VAR 0 2
71150: MINUS
71151: ST_TO_ADDR
// end else
71152: GO 71215
// begin d := - 1 ;
71154: LD_ADDR_VAR 0 9
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: ST_TO_ADDR
// if i_from > i_to then
71163: LD_VAR 0 2
71167: PUSH
71168: LD_VAR 0 3
71172: GREATER
71173: IFFALSE 71193
// length := i_from - i_to else
71175: LD_ADDR_VAR 0 11
71179: PUSH
71180: LD_VAR 0 2
71184: PUSH
71185: LD_VAR 0 3
71189: MINUS
71190: ST_TO_ADDR
71191: GO 71215
// length := ( array - i_to ) + i_from ;
71193: LD_ADDR_VAR 0 11
71197: PUSH
71198: LD_VAR 0 1
71202: PUSH
71203: LD_VAR 0 3
71207: MINUS
71208: PUSH
71209: LD_VAR 0 2
71213: PLUS
71214: ST_TO_ADDR
// end ; if not length then
71215: LD_VAR 0 11
71219: NOT
71220: IFFALSE 71224
// exit ;
71222: GO 71382
// tmp := array ;
71224: LD_ADDR_VAR 0 10
71228: PUSH
71229: LD_VAR 0 1
71233: ST_TO_ADDR
// for i = 1 to length do
71234: LD_ADDR_VAR 0 6
71238: PUSH
71239: DOUBLE
71240: LD_INT 1
71242: DEC
71243: ST_TO_ADDR
71244: LD_VAR 0 11
71248: PUSH
71249: FOR_TO
71250: IFFALSE 71370
// begin for j = 1 to array do
71252: LD_ADDR_VAR 0 7
71256: PUSH
71257: DOUBLE
71258: LD_INT 1
71260: DEC
71261: ST_TO_ADDR
71262: LD_VAR 0 1
71266: PUSH
71267: FOR_TO
71268: IFFALSE 71356
// begin k := j + d ;
71270: LD_ADDR_VAR 0 8
71274: PUSH
71275: LD_VAR 0 7
71279: PUSH
71280: LD_VAR 0 9
71284: PLUS
71285: ST_TO_ADDR
// if k > array then
71286: LD_VAR 0 8
71290: PUSH
71291: LD_VAR 0 1
71295: GREATER
71296: IFFALSE 71306
// k := 1 ;
71298: LD_ADDR_VAR 0 8
71302: PUSH
71303: LD_INT 1
71305: ST_TO_ADDR
// if not k then
71306: LD_VAR 0 8
71310: NOT
71311: IFFALSE 71323
// k := array ;
71313: LD_ADDR_VAR 0 8
71317: PUSH
71318: LD_VAR 0 1
71322: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71323: LD_ADDR_VAR 0 10
71327: PUSH
71328: LD_VAR 0 10
71332: PPUSH
71333: LD_VAR 0 8
71337: PPUSH
71338: LD_VAR 0 1
71342: PUSH
71343: LD_VAR 0 7
71347: ARRAY
71348: PPUSH
71349: CALL_OW 1
71353: ST_TO_ADDR
// end ;
71354: GO 71267
71356: POP
71357: POP
// array := tmp ;
71358: LD_ADDR_VAR 0 1
71362: PUSH
71363: LD_VAR 0 10
71367: ST_TO_ADDR
// end ;
71368: GO 71249
71370: POP
71371: POP
// result := array ;
71372: LD_ADDR_VAR 0 5
71376: PUSH
71377: LD_VAR 0 1
71381: ST_TO_ADDR
// end ;
71382: LD_VAR 0 5
71386: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71387: LD_INT 0
71389: PPUSH
71390: PPUSH
// result := 0 ;
71391: LD_ADDR_VAR 0 3
71395: PUSH
71396: LD_INT 0
71398: ST_TO_ADDR
// if not array or not value in array then
71399: LD_VAR 0 1
71403: NOT
71404: PUSH
71405: LD_VAR 0 2
71409: PUSH
71410: LD_VAR 0 1
71414: IN
71415: NOT
71416: OR
71417: IFFALSE 71421
// exit ;
71419: GO 71475
// for i = 1 to array do
71421: LD_ADDR_VAR 0 4
71425: PUSH
71426: DOUBLE
71427: LD_INT 1
71429: DEC
71430: ST_TO_ADDR
71431: LD_VAR 0 1
71435: PUSH
71436: FOR_TO
71437: IFFALSE 71473
// if value = array [ i ] then
71439: LD_VAR 0 2
71443: PUSH
71444: LD_VAR 0 1
71448: PUSH
71449: LD_VAR 0 4
71453: ARRAY
71454: EQUAL
71455: IFFALSE 71471
// begin result := i ;
71457: LD_ADDR_VAR 0 3
71461: PUSH
71462: LD_VAR 0 4
71466: ST_TO_ADDR
// exit ;
71467: POP
71468: POP
71469: GO 71475
// end ;
71471: GO 71436
71473: POP
71474: POP
// end ;
71475: LD_VAR 0 3
71479: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71480: LD_INT 0
71482: PPUSH
// vc_chassis := chassis ;
71483: LD_ADDR_OWVAR 37
71487: PUSH
71488: LD_VAR 0 1
71492: ST_TO_ADDR
// vc_engine := engine ;
71493: LD_ADDR_OWVAR 39
71497: PUSH
71498: LD_VAR 0 2
71502: ST_TO_ADDR
// vc_control := control ;
71503: LD_ADDR_OWVAR 38
71507: PUSH
71508: LD_VAR 0 3
71512: ST_TO_ADDR
// vc_weapon := weapon ;
71513: LD_ADDR_OWVAR 40
71517: PUSH
71518: LD_VAR 0 4
71522: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71523: LD_ADDR_OWVAR 41
71527: PUSH
71528: LD_VAR 0 5
71532: ST_TO_ADDR
// end ;
71533: LD_VAR 0 6
71537: RET
// export function WantPlant ( unit ) ; var task ; begin
71538: LD_INT 0
71540: PPUSH
71541: PPUSH
// result := false ;
71542: LD_ADDR_VAR 0 2
71546: PUSH
71547: LD_INT 0
71549: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71550: LD_ADDR_VAR 0 3
71554: PUSH
71555: LD_VAR 0 1
71559: PPUSH
71560: CALL_OW 437
71564: ST_TO_ADDR
// if task then
71565: LD_VAR 0 3
71569: IFFALSE 71597
// if task [ 1 ] [ 1 ] = p then
71571: LD_VAR 0 3
71575: PUSH
71576: LD_INT 1
71578: ARRAY
71579: PUSH
71580: LD_INT 1
71582: ARRAY
71583: PUSH
71584: LD_STRING p
71586: EQUAL
71587: IFFALSE 71597
// result := true ;
71589: LD_ADDR_VAR 0 2
71593: PUSH
71594: LD_INT 1
71596: ST_TO_ADDR
// end ;
71597: LD_VAR 0 2
71601: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71602: LD_INT 0
71604: PPUSH
71605: PPUSH
71606: PPUSH
71607: PPUSH
// if pos < 1 then
71608: LD_VAR 0 2
71612: PUSH
71613: LD_INT 1
71615: LESS
71616: IFFALSE 71620
// exit ;
71618: GO 71923
// if pos = 1 then
71620: LD_VAR 0 2
71624: PUSH
71625: LD_INT 1
71627: EQUAL
71628: IFFALSE 71661
// result := Replace ( arr , pos [ 1 ] , value ) else
71630: LD_ADDR_VAR 0 4
71634: PUSH
71635: LD_VAR 0 1
71639: PPUSH
71640: LD_VAR 0 2
71644: PUSH
71645: LD_INT 1
71647: ARRAY
71648: PPUSH
71649: LD_VAR 0 3
71653: PPUSH
71654: CALL_OW 1
71658: ST_TO_ADDR
71659: GO 71923
// begin tmp := arr ;
71661: LD_ADDR_VAR 0 6
71665: PUSH
71666: LD_VAR 0 1
71670: ST_TO_ADDR
// s_arr := [ tmp ] ;
71671: LD_ADDR_VAR 0 7
71675: PUSH
71676: LD_VAR 0 6
71680: PUSH
71681: EMPTY
71682: LIST
71683: ST_TO_ADDR
// for i = 1 to pos - 1 do
71684: LD_ADDR_VAR 0 5
71688: PUSH
71689: DOUBLE
71690: LD_INT 1
71692: DEC
71693: ST_TO_ADDR
71694: LD_VAR 0 2
71698: PUSH
71699: LD_INT 1
71701: MINUS
71702: PUSH
71703: FOR_TO
71704: IFFALSE 71749
// begin tmp := tmp [ pos [ i ] ] ;
71706: LD_ADDR_VAR 0 6
71710: PUSH
71711: LD_VAR 0 6
71715: PUSH
71716: LD_VAR 0 2
71720: PUSH
71721: LD_VAR 0 5
71725: ARRAY
71726: ARRAY
71727: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71728: LD_ADDR_VAR 0 7
71732: PUSH
71733: LD_VAR 0 7
71737: PUSH
71738: LD_VAR 0 6
71742: PUSH
71743: EMPTY
71744: LIST
71745: ADD
71746: ST_TO_ADDR
// end ;
71747: GO 71703
71749: POP
71750: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71751: LD_ADDR_VAR 0 6
71755: PUSH
71756: LD_VAR 0 6
71760: PPUSH
71761: LD_VAR 0 2
71765: PUSH
71766: LD_VAR 0 2
71770: ARRAY
71771: PPUSH
71772: LD_VAR 0 3
71776: PPUSH
71777: CALL_OW 1
71781: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71782: LD_ADDR_VAR 0 7
71786: PUSH
71787: LD_VAR 0 7
71791: PPUSH
71792: LD_VAR 0 7
71796: PPUSH
71797: LD_VAR 0 6
71801: PPUSH
71802: CALL_OW 1
71806: ST_TO_ADDR
// for i = s_arr downto 2 do
71807: LD_ADDR_VAR 0 5
71811: PUSH
71812: DOUBLE
71813: LD_VAR 0 7
71817: INC
71818: ST_TO_ADDR
71819: LD_INT 2
71821: PUSH
71822: FOR_DOWNTO
71823: IFFALSE 71907
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71825: LD_ADDR_VAR 0 6
71829: PUSH
71830: LD_VAR 0 7
71834: PUSH
71835: LD_VAR 0 5
71839: PUSH
71840: LD_INT 1
71842: MINUS
71843: ARRAY
71844: PPUSH
71845: LD_VAR 0 2
71849: PUSH
71850: LD_VAR 0 5
71854: PUSH
71855: LD_INT 1
71857: MINUS
71858: ARRAY
71859: PPUSH
71860: LD_VAR 0 7
71864: PUSH
71865: LD_VAR 0 5
71869: ARRAY
71870: PPUSH
71871: CALL_OW 1
71875: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71876: LD_ADDR_VAR 0 7
71880: PUSH
71881: LD_VAR 0 7
71885: PPUSH
71886: LD_VAR 0 5
71890: PUSH
71891: LD_INT 1
71893: MINUS
71894: PPUSH
71895: LD_VAR 0 6
71899: PPUSH
71900: CALL_OW 1
71904: ST_TO_ADDR
// end ;
71905: GO 71822
71907: POP
71908: POP
// result := s_arr [ 1 ] ;
71909: LD_ADDR_VAR 0 4
71913: PUSH
71914: LD_VAR 0 7
71918: PUSH
71919: LD_INT 1
71921: ARRAY
71922: ST_TO_ADDR
// end ; end ;
71923: LD_VAR 0 4
71927: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71928: LD_INT 0
71930: PPUSH
71931: PPUSH
// if not list then
71932: LD_VAR 0 1
71936: NOT
71937: IFFALSE 71941
// exit ;
71939: GO 72032
// i := list [ pos1 ] ;
71941: LD_ADDR_VAR 0 5
71945: PUSH
71946: LD_VAR 0 1
71950: PUSH
71951: LD_VAR 0 2
71955: ARRAY
71956: ST_TO_ADDR
// if not i then
71957: LD_VAR 0 5
71961: NOT
71962: IFFALSE 71966
// exit ;
71964: GO 72032
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71966: LD_ADDR_VAR 0 1
71970: PUSH
71971: LD_VAR 0 1
71975: PPUSH
71976: LD_VAR 0 2
71980: PPUSH
71981: LD_VAR 0 1
71985: PUSH
71986: LD_VAR 0 3
71990: ARRAY
71991: PPUSH
71992: CALL_OW 1
71996: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71997: LD_ADDR_VAR 0 1
72001: PUSH
72002: LD_VAR 0 1
72006: PPUSH
72007: LD_VAR 0 3
72011: PPUSH
72012: LD_VAR 0 5
72016: PPUSH
72017: CALL_OW 1
72021: ST_TO_ADDR
// result := list ;
72022: LD_ADDR_VAR 0 4
72026: PUSH
72027: LD_VAR 0 1
72031: ST_TO_ADDR
// end ;
72032: LD_VAR 0 4
72036: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72037: LD_INT 0
72039: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72040: LD_ADDR_VAR 0 5
72044: PUSH
72045: LD_VAR 0 1
72049: PPUSH
72050: CALL_OW 250
72054: PPUSH
72055: LD_VAR 0 1
72059: PPUSH
72060: CALL_OW 251
72064: PPUSH
72065: LD_VAR 0 2
72069: PPUSH
72070: LD_VAR 0 3
72074: PPUSH
72075: LD_VAR 0 4
72079: PPUSH
72080: CALL 72090 0 5
72084: ST_TO_ADDR
// end ;
72085: LD_VAR 0 5
72089: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72090: LD_INT 0
72092: PPUSH
72093: PPUSH
72094: PPUSH
72095: PPUSH
// if not list then
72096: LD_VAR 0 3
72100: NOT
72101: IFFALSE 72105
// exit ;
72103: GO 72493
// result := [ ] ;
72105: LD_ADDR_VAR 0 6
72109: PUSH
72110: EMPTY
72111: ST_TO_ADDR
// for i in list do
72112: LD_ADDR_VAR 0 7
72116: PUSH
72117: LD_VAR 0 3
72121: PUSH
72122: FOR_IN
72123: IFFALSE 72325
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72125: LD_ADDR_VAR 0 9
72129: PUSH
72130: LD_VAR 0 7
72134: PPUSH
72135: LD_VAR 0 1
72139: PPUSH
72140: LD_VAR 0 2
72144: PPUSH
72145: CALL_OW 297
72149: ST_TO_ADDR
// if not result then
72150: LD_VAR 0 6
72154: NOT
72155: IFFALSE 72181
// result := [ [ i , tmp ] ] else
72157: LD_ADDR_VAR 0 6
72161: PUSH
72162: LD_VAR 0 7
72166: PUSH
72167: LD_VAR 0 9
72171: PUSH
72172: EMPTY
72173: LIST
72174: LIST
72175: PUSH
72176: EMPTY
72177: LIST
72178: ST_TO_ADDR
72179: GO 72323
// begin if result [ result ] [ 2 ] < tmp then
72181: LD_VAR 0 6
72185: PUSH
72186: LD_VAR 0 6
72190: ARRAY
72191: PUSH
72192: LD_INT 2
72194: ARRAY
72195: PUSH
72196: LD_VAR 0 9
72200: LESS
72201: IFFALSE 72243
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72203: LD_ADDR_VAR 0 6
72207: PUSH
72208: LD_VAR 0 6
72212: PPUSH
72213: LD_VAR 0 6
72217: PUSH
72218: LD_INT 1
72220: PLUS
72221: PPUSH
72222: LD_VAR 0 7
72226: PUSH
72227: LD_VAR 0 9
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PPUSH
72236: CALL_OW 2
72240: ST_TO_ADDR
72241: GO 72323
// for j = 1 to result do
72243: LD_ADDR_VAR 0 8
72247: PUSH
72248: DOUBLE
72249: LD_INT 1
72251: DEC
72252: ST_TO_ADDR
72253: LD_VAR 0 6
72257: PUSH
72258: FOR_TO
72259: IFFALSE 72321
// begin if tmp < result [ j ] [ 2 ] then
72261: LD_VAR 0 9
72265: PUSH
72266: LD_VAR 0 6
72270: PUSH
72271: LD_VAR 0 8
72275: ARRAY
72276: PUSH
72277: LD_INT 2
72279: ARRAY
72280: LESS
72281: IFFALSE 72319
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72283: LD_ADDR_VAR 0 6
72287: PUSH
72288: LD_VAR 0 6
72292: PPUSH
72293: LD_VAR 0 8
72297: PPUSH
72298: LD_VAR 0 7
72302: PUSH
72303: LD_VAR 0 9
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PPUSH
72312: CALL_OW 2
72316: ST_TO_ADDR
// break ;
72317: GO 72321
// end ; end ;
72319: GO 72258
72321: POP
72322: POP
// end ; end ;
72323: GO 72122
72325: POP
72326: POP
// if result and not asc then
72327: LD_VAR 0 6
72331: PUSH
72332: LD_VAR 0 4
72336: NOT
72337: AND
72338: IFFALSE 72413
// begin tmp := result ;
72340: LD_ADDR_VAR 0 9
72344: PUSH
72345: LD_VAR 0 6
72349: ST_TO_ADDR
// for i = tmp downto 1 do
72350: LD_ADDR_VAR 0 7
72354: PUSH
72355: DOUBLE
72356: LD_VAR 0 9
72360: INC
72361: ST_TO_ADDR
72362: LD_INT 1
72364: PUSH
72365: FOR_DOWNTO
72366: IFFALSE 72411
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72368: LD_ADDR_VAR 0 6
72372: PUSH
72373: LD_VAR 0 6
72377: PPUSH
72378: LD_VAR 0 9
72382: PUSH
72383: LD_VAR 0 7
72387: MINUS
72388: PUSH
72389: LD_INT 1
72391: PLUS
72392: PPUSH
72393: LD_VAR 0 9
72397: PUSH
72398: LD_VAR 0 7
72402: ARRAY
72403: PPUSH
72404: CALL_OW 1
72408: ST_TO_ADDR
72409: GO 72365
72411: POP
72412: POP
// end ; tmp := [ ] ;
72413: LD_ADDR_VAR 0 9
72417: PUSH
72418: EMPTY
72419: ST_TO_ADDR
// if mode then
72420: LD_VAR 0 5
72424: IFFALSE 72493
// begin for i = 1 to result do
72426: LD_ADDR_VAR 0 7
72430: PUSH
72431: DOUBLE
72432: LD_INT 1
72434: DEC
72435: ST_TO_ADDR
72436: LD_VAR 0 6
72440: PUSH
72441: FOR_TO
72442: IFFALSE 72481
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72444: LD_ADDR_VAR 0 9
72448: PUSH
72449: LD_VAR 0 9
72453: PPUSH
72454: LD_VAR 0 7
72458: PPUSH
72459: LD_VAR 0 6
72463: PUSH
72464: LD_VAR 0 7
72468: ARRAY
72469: PUSH
72470: LD_INT 1
72472: ARRAY
72473: PPUSH
72474: CALL_OW 1
72478: ST_TO_ADDR
72479: GO 72441
72481: POP
72482: POP
// result := tmp ;
72483: LD_ADDR_VAR 0 6
72487: PUSH
72488: LD_VAR 0 9
72492: ST_TO_ADDR
// end ; end ;
72493: LD_VAR 0 6
72497: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72498: LD_INT 0
72500: PPUSH
72501: PPUSH
72502: PPUSH
72503: PPUSH
72504: PPUSH
72505: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72506: LD_ADDR_VAR 0 5
72510: PUSH
72511: LD_INT 0
72513: PUSH
72514: LD_INT 0
72516: PUSH
72517: LD_INT 0
72519: PUSH
72520: EMPTY
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: ST_TO_ADDR
// if not x or not y then
72528: LD_VAR 0 2
72532: NOT
72533: PUSH
72534: LD_VAR 0 3
72538: NOT
72539: OR
72540: IFFALSE 72544
// exit ;
72542: GO 74190
// if not range then
72544: LD_VAR 0 4
72548: NOT
72549: IFFALSE 72559
// range := 10 ;
72551: LD_ADDR_VAR 0 4
72555: PUSH
72556: LD_INT 10
72558: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72559: LD_ADDR_VAR 0 8
72563: PUSH
72564: LD_INT 81
72566: PUSH
72567: LD_VAR 0 1
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 92
72578: PUSH
72579: LD_VAR 0 2
72583: PUSH
72584: LD_VAR 0 3
72588: PUSH
72589: LD_VAR 0 4
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 3
72602: PUSH
72603: LD_INT 21
72605: PUSH
72606: LD_INT 3
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: LIST
72621: PPUSH
72622: CALL_OW 69
72626: ST_TO_ADDR
// if not tmp then
72627: LD_VAR 0 8
72631: NOT
72632: IFFALSE 72636
// exit ;
72634: GO 74190
// for i in tmp do
72636: LD_ADDR_VAR 0 6
72640: PUSH
72641: LD_VAR 0 8
72645: PUSH
72646: FOR_IN
72647: IFFALSE 74165
// begin points := [ 0 , 0 , 0 ] ;
72649: LD_ADDR_VAR 0 9
72653: PUSH
72654: LD_INT 0
72656: PUSH
72657: LD_INT 0
72659: PUSH
72660: LD_INT 0
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: LIST
72667: ST_TO_ADDR
// bpoints := 1 ;
72668: LD_ADDR_VAR 0 10
72672: PUSH
72673: LD_INT 1
72675: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72676: LD_VAR 0 6
72680: PPUSH
72681: CALL_OW 247
72685: PUSH
72686: LD_INT 1
72688: DOUBLE
72689: EQUAL
72690: IFTRUE 72694
72692: GO 73272
72694: POP
// begin if GetClass ( i ) = 1 then
72695: LD_VAR 0 6
72699: PPUSH
72700: CALL_OW 257
72704: PUSH
72705: LD_INT 1
72707: EQUAL
72708: IFFALSE 72729
// points := [ 10 , 5 , 3 ] ;
72710: LD_ADDR_VAR 0 9
72714: PUSH
72715: LD_INT 10
72717: PUSH
72718: LD_INT 5
72720: PUSH
72721: LD_INT 3
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: LIST
72728: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72729: LD_VAR 0 6
72733: PPUSH
72734: CALL_OW 257
72738: PUSH
72739: LD_INT 2
72741: PUSH
72742: LD_INT 3
72744: PUSH
72745: LD_INT 4
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: LIST
72752: IN
72753: IFFALSE 72774
// points := [ 3 , 2 , 1 ] ;
72755: LD_ADDR_VAR 0 9
72759: PUSH
72760: LD_INT 3
72762: PUSH
72763: LD_INT 2
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: LIST
72773: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72774: LD_VAR 0 6
72778: PPUSH
72779: CALL_OW 257
72783: PUSH
72784: LD_INT 5
72786: EQUAL
72787: IFFALSE 72808
// points := [ 130 , 5 , 2 ] ;
72789: LD_ADDR_VAR 0 9
72793: PUSH
72794: LD_INT 130
72796: PUSH
72797: LD_INT 5
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: LIST
72807: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72808: LD_VAR 0 6
72812: PPUSH
72813: CALL_OW 257
72817: PUSH
72818: LD_INT 8
72820: EQUAL
72821: IFFALSE 72842
// points := [ 35 , 35 , 30 ] ;
72823: LD_ADDR_VAR 0 9
72827: PUSH
72828: LD_INT 35
72830: PUSH
72831: LD_INT 35
72833: PUSH
72834: LD_INT 30
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: LIST
72841: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72842: LD_VAR 0 6
72846: PPUSH
72847: CALL_OW 257
72851: PUSH
72852: LD_INT 9
72854: EQUAL
72855: IFFALSE 72876
// points := [ 20 , 55 , 40 ] ;
72857: LD_ADDR_VAR 0 9
72861: PUSH
72862: LD_INT 20
72864: PUSH
72865: LD_INT 55
72867: PUSH
72868: LD_INT 40
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: LIST
72875: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72876: LD_VAR 0 6
72880: PPUSH
72881: CALL_OW 257
72885: PUSH
72886: LD_INT 12
72888: PUSH
72889: LD_INT 16
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: IN
72896: IFFALSE 72917
// points := [ 5 , 3 , 2 ] ;
72898: LD_ADDR_VAR 0 9
72902: PUSH
72903: LD_INT 5
72905: PUSH
72906: LD_INT 3
72908: PUSH
72909: LD_INT 2
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: LIST
72916: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72917: LD_VAR 0 6
72921: PPUSH
72922: CALL_OW 257
72926: PUSH
72927: LD_INT 17
72929: EQUAL
72930: IFFALSE 72951
// points := [ 100 , 50 , 75 ] ;
72932: LD_ADDR_VAR 0 9
72936: PUSH
72937: LD_INT 100
72939: PUSH
72940: LD_INT 50
72942: PUSH
72943: LD_INT 75
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: LIST
72950: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72951: LD_VAR 0 6
72955: PPUSH
72956: CALL_OW 257
72960: PUSH
72961: LD_INT 15
72963: EQUAL
72964: IFFALSE 72985
// points := [ 10 , 5 , 3 ] ;
72966: LD_ADDR_VAR 0 9
72970: PUSH
72971: LD_INT 10
72973: PUSH
72974: LD_INT 5
72976: PUSH
72977: LD_INT 3
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: LIST
72984: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72985: LD_VAR 0 6
72989: PPUSH
72990: CALL_OW 257
72994: PUSH
72995: LD_INT 14
72997: EQUAL
72998: IFFALSE 73019
// points := [ 10 , 0 , 0 ] ;
73000: LD_ADDR_VAR 0 9
73004: PUSH
73005: LD_INT 10
73007: PUSH
73008: LD_INT 0
73010: PUSH
73011: LD_INT 0
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: LIST
73018: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73019: LD_VAR 0 6
73023: PPUSH
73024: CALL_OW 257
73028: PUSH
73029: LD_INT 11
73031: EQUAL
73032: IFFALSE 73053
// points := [ 30 , 10 , 5 ] ;
73034: LD_ADDR_VAR 0 9
73038: PUSH
73039: LD_INT 30
73041: PUSH
73042: LD_INT 10
73044: PUSH
73045: LD_INT 5
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: LIST
73052: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73053: LD_VAR 0 1
73057: PPUSH
73058: LD_INT 5
73060: PPUSH
73061: CALL_OW 321
73065: PUSH
73066: LD_INT 2
73068: EQUAL
73069: IFFALSE 73086
// bpoints := bpoints * 1.8 ;
73071: LD_ADDR_VAR 0 10
73075: PUSH
73076: LD_VAR 0 10
73080: PUSH
73081: LD_REAL  1.80000000000000E+0000
73084: MUL
73085: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73086: LD_VAR 0 6
73090: PPUSH
73091: CALL_OW 257
73095: PUSH
73096: LD_INT 1
73098: PUSH
73099: LD_INT 2
73101: PUSH
73102: LD_INT 3
73104: PUSH
73105: LD_INT 4
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: LIST
73112: LIST
73113: IN
73114: PUSH
73115: LD_VAR 0 1
73119: PPUSH
73120: LD_INT 51
73122: PPUSH
73123: CALL_OW 321
73127: PUSH
73128: LD_INT 2
73130: EQUAL
73131: AND
73132: IFFALSE 73149
// bpoints := bpoints * 1.2 ;
73134: LD_ADDR_VAR 0 10
73138: PUSH
73139: LD_VAR 0 10
73143: PUSH
73144: LD_REAL  1.20000000000000E+0000
73147: MUL
73148: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73149: LD_VAR 0 6
73153: PPUSH
73154: CALL_OW 257
73158: PUSH
73159: LD_INT 5
73161: PUSH
73162: LD_INT 7
73164: PUSH
73165: LD_INT 9
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: LIST
73172: IN
73173: PUSH
73174: LD_VAR 0 1
73178: PPUSH
73179: LD_INT 52
73181: PPUSH
73182: CALL_OW 321
73186: PUSH
73187: LD_INT 2
73189: EQUAL
73190: AND
73191: IFFALSE 73208
// bpoints := bpoints * 1.5 ;
73193: LD_ADDR_VAR 0 10
73197: PUSH
73198: LD_VAR 0 10
73202: PUSH
73203: LD_REAL  1.50000000000000E+0000
73206: MUL
73207: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73208: LD_VAR 0 1
73212: PPUSH
73213: LD_INT 66
73215: PPUSH
73216: CALL_OW 321
73220: PUSH
73221: LD_INT 2
73223: EQUAL
73224: IFFALSE 73241
// bpoints := bpoints * 1.1 ;
73226: LD_ADDR_VAR 0 10
73230: PUSH
73231: LD_VAR 0 10
73235: PUSH
73236: LD_REAL  1.10000000000000E+0000
73239: MUL
73240: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73241: LD_ADDR_VAR 0 10
73245: PUSH
73246: LD_VAR 0 10
73250: PUSH
73251: LD_VAR 0 6
73255: PPUSH
73256: LD_INT 1
73258: PPUSH
73259: CALL_OW 259
73263: PUSH
73264: LD_REAL  1.15000000000000E+0000
73267: MUL
73268: MUL
73269: ST_TO_ADDR
// end ; unit_vehicle :
73270: GO 74094
73272: LD_INT 2
73274: DOUBLE
73275: EQUAL
73276: IFTRUE 73280
73278: GO 74082
73280: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73281: LD_VAR 0 6
73285: PPUSH
73286: CALL_OW 264
73290: PUSH
73291: LD_INT 2
73293: PUSH
73294: LD_INT 42
73296: PUSH
73297: LD_INT 24
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: LIST
73304: IN
73305: IFFALSE 73326
// points := [ 25 , 5 , 3 ] ;
73307: LD_ADDR_VAR 0 9
73311: PUSH
73312: LD_INT 25
73314: PUSH
73315: LD_INT 5
73317: PUSH
73318: LD_INT 3
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: LIST
73325: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73326: LD_VAR 0 6
73330: PPUSH
73331: CALL_OW 264
73335: PUSH
73336: LD_INT 4
73338: PUSH
73339: LD_INT 43
73341: PUSH
73342: LD_INT 25
73344: PUSH
73345: EMPTY
73346: LIST
73347: LIST
73348: LIST
73349: IN
73350: IFFALSE 73371
// points := [ 40 , 15 , 5 ] ;
73352: LD_ADDR_VAR 0 9
73356: PUSH
73357: LD_INT 40
73359: PUSH
73360: LD_INT 15
73362: PUSH
73363: LD_INT 5
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: LIST
73370: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73371: LD_VAR 0 6
73375: PPUSH
73376: CALL_OW 264
73380: PUSH
73381: LD_INT 3
73383: PUSH
73384: LD_INT 23
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: IN
73391: IFFALSE 73412
// points := [ 7 , 25 , 8 ] ;
73393: LD_ADDR_VAR 0 9
73397: PUSH
73398: LD_INT 7
73400: PUSH
73401: LD_INT 25
73403: PUSH
73404: LD_INT 8
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: LIST
73411: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73412: LD_VAR 0 6
73416: PPUSH
73417: CALL_OW 264
73421: PUSH
73422: LD_INT 5
73424: PUSH
73425: LD_INT 27
73427: PUSH
73428: LD_INT 44
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: LIST
73435: IN
73436: IFFALSE 73457
// points := [ 14 , 50 , 16 ] ;
73438: LD_ADDR_VAR 0 9
73442: PUSH
73443: LD_INT 14
73445: PUSH
73446: LD_INT 50
73448: PUSH
73449: LD_INT 16
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: LIST
73456: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73457: LD_VAR 0 6
73461: PPUSH
73462: CALL_OW 264
73466: PUSH
73467: LD_INT 6
73469: PUSH
73470: LD_INT 46
73472: PUSH
73473: EMPTY
73474: LIST
73475: LIST
73476: IN
73477: IFFALSE 73498
// points := [ 32 , 120 , 70 ] ;
73479: LD_ADDR_VAR 0 9
73483: PUSH
73484: LD_INT 32
73486: PUSH
73487: LD_INT 120
73489: PUSH
73490: LD_INT 70
73492: PUSH
73493: EMPTY
73494: LIST
73495: LIST
73496: LIST
73497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73498: LD_VAR 0 6
73502: PPUSH
73503: CALL_OW 264
73507: PUSH
73508: LD_INT 7
73510: PUSH
73511: LD_INT 28
73513: PUSH
73514: LD_INT 45
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: LIST
73521: IN
73522: IFFALSE 73543
// points := [ 35 , 20 , 45 ] ;
73524: LD_ADDR_VAR 0 9
73528: PUSH
73529: LD_INT 35
73531: PUSH
73532: LD_INT 20
73534: PUSH
73535: LD_INT 45
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: LIST
73542: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73543: LD_VAR 0 6
73547: PPUSH
73548: CALL_OW 264
73552: PUSH
73553: LD_INT 47
73555: PUSH
73556: EMPTY
73557: LIST
73558: IN
73559: IFFALSE 73580
// points := [ 67 , 45 , 75 ] ;
73561: LD_ADDR_VAR 0 9
73565: PUSH
73566: LD_INT 67
73568: PUSH
73569: LD_INT 45
73571: PUSH
73572: LD_INT 75
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: LIST
73579: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73580: LD_VAR 0 6
73584: PPUSH
73585: CALL_OW 264
73589: PUSH
73590: LD_INT 26
73592: PUSH
73593: EMPTY
73594: LIST
73595: IN
73596: IFFALSE 73617
// points := [ 120 , 30 , 80 ] ;
73598: LD_ADDR_VAR 0 9
73602: PUSH
73603: LD_INT 120
73605: PUSH
73606: LD_INT 30
73608: PUSH
73609: LD_INT 80
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: LIST
73616: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73617: LD_VAR 0 6
73621: PPUSH
73622: CALL_OW 264
73626: PUSH
73627: LD_INT 22
73629: PUSH
73630: EMPTY
73631: LIST
73632: IN
73633: IFFALSE 73654
// points := [ 40 , 1 , 1 ] ;
73635: LD_ADDR_VAR 0 9
73639: PUSH
73640: LD_INT 40
73642: PUSH
73643: LD_INT 1
73645: PUSH
73646: LD_INT 1
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: LIST
73653: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73654: LD_VAR 0 6
73658: PPUSH
73659: CALL_OW 264
73663: PUSH
73664: LD_INT 29
73666: PUSH
73667: EMPTY
73668: LIST
73669: IN
73670: IFFALSE 73691
// points := [ 70 , 200 , 400 ] ;
73672: LD_ADDR_VAR 0 9
73676: PUSH
73677: LD_INT 70
73679: PUSH
73680: LD_INT 200
73682: PUSH
73683: LD_INT 400
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: LIST
73690: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73691: LD_VAR 0 6
73695: PPUSH
73696: CALL_OW 264
73700: PUSH
73701: LD_INT 14
73703: PUSH
73704: LD_INT 53
73706: PUSH
73707: EMPTY
73708: LIST
73709: LIST
73710: IN
73711: IFFALSE 73732
// points := [ 40 , 10 , 20 ] ;
73713: LD_ADDR_VAR 0 9
73717: PUSH
73718: LD_INT 40
73720: PUSH
73721: LD_INT 10
73723: PUSH
73724: LD_INT 20
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: LIST
73731: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73732: LD_VAR 0 6
73736: PPUSH
73737: CALL_OW 264
73741: PUSH
73742: LD_INT 9
73744: PUSH
73745: EMPTY
73746: LIST
73747: IN
73748: IFFALSE 73769
// points := [ 5 , 70 , 20 ] ;
73750: LD_ADDR_VAR 0 9
73754: PUSH
73755: LD_INT 5
73757: PUSH
73758: LD_INT 70
73760: PUSH
73761: LD_INT 20
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: LIST
73768: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73769: LD_VAR 0 6
73773: PPUSH
73774: CALL_OW 264
73778: PUSH
73779: LD_INT 10
73781: PUSH
73782: EMPTY
73783: LIST
73784: IN
73785: IFFALSE 73806
// points := [ 35 , 110 , 70 ] ;
73787: LD_ADDR_VAR 0 9
73791: PUSH
73792: LD_INT 35
73794: PUSH
73795: LD_INT 110
73797: PUSH
73798: LD_INT 70
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: LIST
73805: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73806: LD_VAR 0 6
73810: PPUSH
73811: CALL_OW 265
73815: PUSH
73816: LD_INT 25
73818: EQUAL
73819: IFFALSE 73840
// points := [ 80 , 65 , 100 ] ;
73821: LD_ADDR_VAR 0 9
73825: PUSH
73826: LD_INT 80
73828: PUSH
73829: LD_INT 65
73831: PUSH
73832: LD_INT 100
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: LIST
73839: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73840: LD_VAR 0 6
73844: PPUSH
73845: CALL_OW 263
73849: PUSH
73850: LD_INT 1
73852: EQUAL
73853: IFFALSE 73888
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73855: LD_ADDR_VAR 0 10
73859: PUSH
73860: LD_VAR 0 10
73864: PUSH
73865: LD_VAR 0 6
73869: PPUSH
73870: CALL_OW 311
73874: PPUSH
73875: LD_INT 3
73877: PPUSH
73878: CALL_OW 259
73882: PUSH
73883: LD_INT 4
73885: MUL
73886: MUL
73887: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73888: LD_VAR 0 6
73892: PPUSH
73893: CALL_OW 263
73897: PUSH
73898: LD_INT 2
73900: EQUAL
73901: IFFALSE 73952
// begin j := IsControledBy ( i ) ;
73903: LD_ADDR_VAR 0 7
73907: PUSH
73908: LD_VAR 0 6
73912: PPUSH
73913: CALL_OW 312
73917: ST_TO_ADDR
// if j then
73918: LD_VAR 0 7
73922: IFFALSE 73952
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73924: LD_ADDR_VAR 0 10
73928: PUSH
73929: LD_VAR 0 10
73933: PUSH
73934: LD_VAR 0 7
73938: PPUSH
73939: LD_INT 3
73941: PPUSH
73942: CALL_OW 259
73946: PUSH
73947: LD_INT 3
73949: MUL
73950: MUL
73951: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73952: LD_VAR 0 6
73956: PPUSH
73957: CALL_OW 264
73961: PUSH
73962: LD_INT 5
73964: PUSH
73965: LD_INT 6
73967: PUSH
73968: LD_INT 46
73970: PUSH
73971: LD_INT 44
73973: PUSH
73974: LD_INT 47
73976: PUSH
73977: LD_INT 45
73979: PUSH
73980: LD_INT 28
73982: PUSH
73983: LD_INT 7
73985: PUSH
73986: LD_INT 27
73988: PUSH
73989: LD_INT 29
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: IN
74004: PUSH
74005: LD_VAR 0 1
74009: PPUSH
74010: LD_INT 52
74012: PPUSH
74013: CALL_OW 321
74017: PUSH
74018: LD_INT 2
74020: EQUAL
74021: AND
74022: IFFALSE 74039
// bpoints := bpoints * 1.2 ;
74024: LD_ADDR_VAR 0 10
74028: PUSH
74029: LD_VAR 0 10
74033: PUSH
74034: LD_REAL  1.20000000000000E+0000
74037: MUL
74038: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74039: LD_VAR 0 6
74043: PPUSH
74044: CALL_OW 264
74048: PUSH
74049: LD_INT 6
74051: PUSH
74052: LD_INT 46
74054: PUSH
74055: LD_INT 47
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: LIST
74062: IN
74063: IFFALSE 74080
// bpoints := bpoints * 1.2 ;
74065: LD_ADDR_VAR 0 10
74069: PUSH
74070: LD_VAR 0 10
74074: PUSH
74075: LD_REAL  1.20000000000000E+0000
74078: MUL
74079: ST_TO_ADDR
// end ; unit_building :
74080: GO 74094
74082: LD_INT 3
74084: DOUBLE
74085: EQUAL
74086: IFTRUE 74090
74088: GO 74093
74090: POP
// ; end ;
74091: GO 74094
74093: POP
// for j = 1 to 3 do
74094: LD_ADDR_VAR 0 7
74098: PUSH
74099: DOUBLE
74100: LD_INT 1
74102: DEC
74103: ST_TO_ADDR
74104: LD_INT 3
74106: PUSH
74107: FOR_TO
74108: IFFALSE 74161
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74110: LD_ADDR_VAR 0 5
74114: PUSH
74115: LD_VAR 0 5
74119: PPUSH
74120: LD_VAR 0 7
74124: PPUSH
74125: LD_VAR 0 5
74129: PUSH
74130: LD_VAR 0 7
74134: ARRAY
74135: PUSH
74136: LD_VAR 0 9
74140: PUSH
74141: LD_VAR 0 7
74145: ARRAY
74146: PUSH
74147: LD_VAR 0 10
74151: MUL
74152: PLUS
74153: PPUSH
74154: CALL_OW 1
74158: ST_TO_ADDR
74159: GO 74107
74161: POP
74162: POP
// end ;
74163: GO 72646
74165: POP
74166: POP
// result := Replace ( result , 4 , tmp ) ;
74167: LD_ADDR_VAR 0 5
74171: PUSH
74172: LD_VAR 0 5
74176: PPUSH
74177: LD_INT 4
74179: PPUSH
74180: LD_VAR 0 8
74184: PPUSH
74185: CALL_OW 1
74189: ST_TO_ADDR
// end ;
74190: LD_VAR 0 5
74194: RET
// export function DangerAtRange ( unit , range ) ; begin
74195: LD_INT 0
74197: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74198: LD_ADDR_VAR 0 3
74202: PUSH
74203: LD_VAR 0 1
74207: PPUSH
74208: CALL_OW 255
74212: PPUSH
74213: LD_VAR 0 1
74217: PPUSH
74218: CALL_OW 250
74222: PPUSH
74223: LD_VAR 0 1
74227: PPUSH
74228: CALL_OW 251
74232: PPUSH
74233: LD_VAR 0 2
74237: PPUSH
74238: CALL 72498 0 4
74242: ST_TO_ADDR
// end ;
74243: LD_VAR 0 3
74247: RET
// export function DangerInArea ( side , area ) ; begin
74248: LD_INT 0
74250: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74251: LD_ADDR_VAR 0 3
74255: PUSH
74256: LD_VAR 0 2
74260: PPUSH
74261: LD_INT 81
74263: PUSH
74264: LD_VAR 0 1
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PPUSH
74273: CALL_OW 70
74277: ST_TO_ADDR
// end ;
74278: LD_VAR 0 3
74282: RET
// export function IsExtension ( b ) ; begin
74283: LD_INT 0
74285: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74286: LD_ADDR_VAR 0 2
74290: PUSH
74291: LD_VAR 0 1
74295: PUSH
74296: LD_INT 23
74298: PUSH
74299: LD_INT 20
74301: PUSH
74302: LD_INT 22
74304: PUSH
74305: LD_INT 17
74307: PUSH
74308: LD_INT 24
74310: PUSH
74311: LD_INT 21
74313: PUSH
74314: LD_INT 19
74316: PUSH
74317: LD_INT 16
74319: PUSH
74320: LD_INT 25
74322: PUSH
74323: LD_INT 18
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: LIST
74330: LIST
74331: LIST
74332: LIST
74333: LIST
74334: LIST
74335: LIST
74336: LIST
74337: IN
74338: ST_TO_ADDR
// end ;
74339: LD_VAR 0 2
74343: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74344: LD_INT 0
74346: PPUSH
74347: PPUSH
74348: PPUSH
// result := [ ] ;
74349: LD_ADDR_VAR 0 3
74353: PUSH
74354: EMPTY
74355: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74356: LD_ADDR_VAR 0 4
74360: PUSH
74361: LD_VAR 0 2
74365: PPUSH
74366: LD_INT 21
74368: PUSH
74369: LD_INT 3
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PPUSH
74376: CALL_OW 70
74380: ST_TO_ADDR
// if not tmp then
74381: LD_VAR 0 4
74385: NOT
74386: IFFALSE 74390
// exit ;
74388: GO 74448
// for i in tmp do
74390: LD_ADDR_VAR 0 5
74394: PUSH
74395: LD_VAR 0 4
74399: PUSH
74400: FOR_IN
74401: IFFALSE 74436
// if GetBase ( i ) <> base then
74403: LD_VAR 0 5
74407: PPUSH
74408: CALL_OW 274
74412: PUSH
74413: LD_VAR 0 1
74417: NONEQUAL
74418: IFFALSE 74434
// ComLinkToBase ( base , i ) ;
74420: LD_VAR 0 1
74424: PPUSH
74425: LD_VAR 0 5
74429: PPUSH
74430: CALL_OW 169
74434: GO 74400
74436: POP
74437: POP
// result := tmp ;
74438: LD_ADDR_VAR 0 3
74442: PUSH
74443: LD_VAR 0 4
74447: ST_TO_ADDR
// end ;
74448: LD_VAR 0 3
74452: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74453: LD_INT 0
74455: PPUSH
74456: PPUSH
// if BuildingStatus ( b ) = bs_build then
74457: LD_VAR 0 2
74461: PPUSH
74462: CALL_OW 461
74466: PUSH
74467: LD_INT 1
74469: EQUAL
74470: IFFALSE 74530
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74472: LD_VAR 0 1
74476: PPUSH
74477: LD_STRING h
74479: PUSH
74480: LD_VAR 0 2
74484: PPUSH
74485: CALL_OW 250
74489: PUSH
74490: LD_VAR 0 2
74494: PPUSH
74495: CALL_OW 251
74499: PUSH
74500: LD_VAR 0 2
74504: PUSH
74505: LD_INT 0
74507: PUSH
74508: LD_INT 0
74510: PUSH
74511: LD_INT 0
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: PUSH
74523: EMPTY
74524: LIST
74525: PPUSH
74526: CALL_OW 446
// end ;
74530: LD_VAR 0 3
74534: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74535: LD_INT 0
74537: PPUSH
74538: PPUSH
74539: PPUSH
74540: PPUSH
74541: PPUSH
74542: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74543: LD_VAR 0 1
74547: NOT
74548: PUSH
74549: LD_VAR 0 1
74553: PPUSH
74554: CALL_OW 263
74558: PUSH
74559: LD_INT 2
74561: EQUAL
74562: NOT
74563: OR
74564: IFFALSE 74568
// exit ;
74566: GO 74884
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74568: LD_ADDR_VAR 0 6
74572: PUSH
74573: LD_INT 22
74575: PUSH
74576: LD_VAR 0 1
74580: PPUSH
74581: CALL_OW 255
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: LD_INT 2
74592: PUSH
74593: LD_INT 30
74595: PUSH
74596: LD_INT 36
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 34
74605: PUSH
74606: LD_INT 31
74608: PUSH
74609: EMPTY
74610: LIST
74611: LIST
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PPUSH
74622: CALL_OW 69
74626: ST_TO_ADDR
// if not tmp then
74627: LD_VAR 0 6
74631: NOT
74632: IFFALSE 74636
// exit ;
74634: GO 74884
// result := [ ] ;
74636: LD_ADDR_VAR 0 2
74640: PUSH
74641: EMPTY
74642: ST_TO_ADDR
// for i in tmp do
74643: LD_ADDR_VAR 0 3
74647: PUSH
74648: LD_VAR 0 6
74652: PUSH
74653: FOR_IN
74654: IFFALSE 74725
// begin t := UnitsInside ( i ) ;
74656: LD_ADDR_VAR 0 4
74660: PUSH
74661: LD_VAR 0 3
74665: PPUSH
74666: CALL_OW 313
74670: ST_TO_ADDR
// if t then
74671: LD_VAR 0 4
74675: IFFALSE 74723
// for j in t do
74677: LD_ADDR_VAR 0 7
74681: PUSH
74682: LD_VAR 0 4
74686: PUSH
74687: FOR_IN
74688: IFFALSE 74721
// result := Insert ( result , result + 1 , j ) ;
74690: LD_ADDR_VAR 0 2
74694: PUSH
74695: LD_VAR 0 2
74699: PPUSH
74700: LD_VAR 0 2
74704: PUSH
74705: LD_INT 1
74707: PLUS
74708: PPUSH
74709: LD_VAR 0 7
74713: PPUSH
74714: CALL_OW 2
74718: ST_TO_ADDR
74719: GO 74687
74721: POP
74722: POP
// end ;
74723: GO 74653
74725: POP
74726: POP
// if not result then
74727: LD_VAR 0 2
74731: NOT
74732: IFFALSE 74736
// exit ;
74734: GO 74884
// mech := result [ 1 ] ;
74736: LD_ADDR_VAR 0 5
74740: PUSH
74741: LD_VAR 0 2
74745: PUSH
74746: LD_INT 1
74748: ARRAY
74749: ST_TO_ADDR
// if result > 1 then
74750: LD_VAR 0 2
74754: PUSH
74755: LD_INT 1
74757: GREATER
74758: IFFALSE 74870
// for i = 2 to result do
74760: LD_ADDR_VAR 0 3
74764: PUSH
74765: DOUBLE
74766: LD_INT 2
74768: DEC
74769: ST_TO_ADDR
74770: LD_VAR 0 2
74774: PUSH
74775: FOR_TO
74776: IFFALSE 74868
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74778: LD_ADDR_VAR 0 4
74782: PUSH
74783: LD_VAR 0 2
74787: PUSH
74788: LD_VAR 0 3
74792: ARRAY
74793: PPUSH
74794: LD_INT 3
74796: PPUSH
74797: CALL_OW 259
74801: PUSH
74802: LD_VAR 0 2
74806: PUSH
74807: LD_VAR 0 3
74811: ARRAY
74812: PPUSH
74813: CALL_OW 432
74817: MINUS
74818: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74819: LD_VAR 0 4
74823: PUSH
74824: LD_VAR 0 5
74828: PPUSH
74829: LD_INT 3
74831: PPUSH
74832: CALL_OW 259
74836: PUSH
74837: LD_VAR 0 5
74841: PPUSH
74842: CALL_OW 432
74846: MINUS
74847: GREATEREQUAL
74848: IFFALSE 74866
// mech := result [ i ] ;
74850: LD_ADDR_VAR 0 5
74854: PUSH
74855: LD_VAR 0 2
74859: PUSH
74860: LD_VAR 0 3
74864: ARRAY
74865: ST_TO_ADDR
// end ;
74866: GO 74775
74868: POP
74869: POP
// ComLinkTo ( vehicle , mech ) ;
74870: LD_VAR 0 1
74874: PPUSH
74875: LD_VAR 0 5
74879: PPUSH
74880: CALL_OW 135
// end ;
74884: LD_VAR 0 2
74888: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74889: LD_INT 0
74891: PPUSH
74892: PPUSH
74893: PPUSH
74894: PPUSH
74895: PPUSH
74896: PPUSH
74897: PPUSH
74898: PPUSH
74899: PPUSH
74900: PPUSH
74901: PPUSH
74902: PPUSH
74903: PPUSH
// result := [ ] ;
74904: LD_ADDR_VAR 0 7
74908: PUSH
74909: EMPTY
74910: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74911: LD_VAR 0 1
74915: PPUSH
74916: CALL_OW 266
74920: PUSH
74921: LD_INT 0
74923: PUSH
74924: LD_INT 1
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: IN
74931: NOT
74932: IFFALSE 74936
// exit ;
74934: GO 76567
// if name then
74936: LD_VAR 0 3
74940: IFFALSE 74956
// SetBName ( base_dep , name ) ;
74942: LD_VAR 0 1
74946: PPUSH
74947: LD_VAR 0 3
74951: PPUSH
74952: CALL_OW 500
// base := GetBase ( base_dep ) ;
74956: LD_ADDR_VAR 0 15
74960: PUSH
74961: LD_VAR 0 1
74965: PPUSH
74966: CALL_OW 274
74970: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74971: LD_ADDR_VAR 0 16
74975: PUSH
74976: LD_VAR 0 1
74980: PPUSH
74981: CALL_OW 255
74985: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74986: LD_ADDR_VAR 0 17
74990: PUSH
74991: LD_VAR 0 1
74995: PPUSH
74996: CALL_OW 248
75000: ST_TO_ADDR
// if sources then
75001: LD_VAR 0 5
75005: IFFALSE 75052
// for i = 1 to 3 do
75007: LD_ADDR_VAR 0 8
75011: PUSH
75012: DOUBLE
75013: LD_INT 1
75015: DEC
75016: ST_TO_ADDR
75017: LD_INT 3
75019: PUSH
75020: FOR_TO
75021: IFFALSE 75050
// AddResourceType ( base , i , sources [ i ] ) ;
75023: LD_VAR 0 15
75027: PPUSH
75028: LD_VAR 0 8
75032: PPUSH
75033: LD_VAR 0 5
75037: PUSH
75038: LD_VAR 0 8
75042: ARRAY
75043: PPUSH
75044: CALL_OW 276
75048: GO 75020
75050: POP
75051: POP
// buildings := GetBaseBuildings ( base , area ) ;
75052: LD_ADDR_VAR 0 18
75056: PUSH
75057: LD_VAR 0 15
75061: PPUSH
75062: LD_VAR 0 2
75066: PPUSH
75067: CALL 74344 0 2
75071: ST_TO_ADDR
// InitHc ;
75072: CALL_OW 19
// InitUc ;
75076: CALL_OW 18
// uc_side := side ;
75080: LD_ADDR_OWVAR 20
75084: PUSH
75085: LD_VAR 0 16
75089: ST_TO_ADDR
// uc_nation := nation ;
75090: LD_ADDR_OWVAR 21
75094: PUSH
75095: LD_VAR 0 17
75099: ST_TO_ADDR
// if buildings then
75100: LD_VAR 0 18
75104: IFFALSE 76426
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75106: LD_ADDR_VAR 0 19
75110: PUSH
75111: LD_VAR 0 18
75115: PPUSH
75116: LD_INT 2
75118: PUSH
75119: LD_INT 30
75121: PUSH
75122: LD_INT 29
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 30
75131: PUSH
75132: LD_INT 30
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: PPUSH
75144: CALL_OW 72
75148: ST_TO_ADDR
// if tmp then
75149: LD_VAR 0 19
75153: IFFALSE 75201
// for i in tmp do
75155: LD_ADDR_VAR 0 8
75159: PUSH
75160: LD_VAR 0 19
75164: PUSH
75165: FOR_IN
75166: IFFALSE 75199
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75168: LD_VAR 0 8
75172: PPUSH
75173: CALL_OW 250
75177: PPUSH
75178: LD_VAR 0 8
75182: PPUSH
75183: CALL_OW 251
75187: PPUSH
75188: LD_VAR 0 16
75192: PPUSH
75193: CALL_OW 441
75197: GO 75165
75199: POP
75200: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75201: LD_VAR 0 18
75205: PPUSH
75206: LD_INT 2
75208: PUSH
75209: LD_INT 30
75211: PUSH
75212: LD_INT 32
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 30
75221: PUSH
75222: LD_INT 33
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: LIST
75233: PPUSH
75234: CALL_OW 72
75238: IFFALSE 75326
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75240: LD_ADDR_VAR 0 8
75244: PUSH
75245: LD_VAR 0 18
75249: PPUSH
75250: LD_INT 2
75252: PUSH
75253: LD_INT 30
75255: PUSH
75256: LD_INT 32
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: PUSH
75263: LD_INT 30
75265: PUSH
75266: LD_INT 33
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: LIST
75277: PPUSH
75278: CALL_OW 72
75282: PUSH
75283: FOR_IN
75284: IFFALSE 75324
// begin if not GetBWeapon ( i ) then
75286: LD_VAR 0 8
75290: PPUSH
75291: CALL_OW 269
75295: NOT
75296: IFFALSE 75322
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75298: LD_VAR 0 8
75302: PPUSH
75303: LD_VAR 0 8
75307: PPUSH
75308: LD_VAR 0 2
75312: PPUSH
75313: CALL 76572 0 2
75317: PPUSH
75318: CALL_OW 431
// end ;
75322: GO 75283
75324: POP
75325: POP
// end ; for i = 1 to personel do
75326: LD_ADDR_VAR 0 8
75330: PUSH
75331: DOUBLE
75332: LD_INT 1
75334: DEC
75335: ST_TO_ADDR
75336: LD_VAR 0 6
75340: PUSH
75341: FOR_TO
75342: IFFALSE 76406
// begin if i > 4 then
75344: LD_VAR 0 8
75348: PUSH
75349: LD_INT 4
75351: GREATER
75352: IFFALSE 75356
// break ;
75354: GO 76406
// case i of 1 :
75356: LD_VAR 0 8
75360: PUSH
75361: LD_INT 1
75363: DOUBLE
75364: EQUAL
75365: IFTRUE 75369
75367: GO 75449
75369: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75370: LD_ADDR_VAR 0 12
75374: PUSH
75375: LD_VAR 0 18
75379: PPUSH
75380: LD_INT 22
75382: PUSH
75383: LD_VAR 0 16
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 58
75394: PUSH
75395: EMPTY
75396: LIST
75397: PUSH
75398: LD_INT 2
75400: PUSH
75401: LD_INT 30
75403: PUSH
75404: LD_INT 32
75406: PUSH
75407: EMPTY
75408: LIST
75409: LIST
75410: PUSH
75411: LD_INT 30
75413: PUSH
75414: LD_INT 4
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 30
75423: PUSH
75424: LD_INT 5
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: LIST
75435: LIST
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: LIST
75441: PPUSH
75442: CALL_OW 72
75446: ST_TO_ADDR
75447: GO 75671
75449: LD_INT 2
75451: DOUBLE
75452: EQUAL
75453: IFTRUE 75457
75455: GO 75519
75457: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75458: LD_ADDR_VAR 0 12
75462: PUSH
75463: LD_VAR 0 18
75467: PPUSH
75468: LD_INT 22
75470: PUSH
75471: LD_VAR 0 16
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: PUSH
75480: LD_INT 2
75482: PUSH
75483: LD_INT 30
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PUSH
75493: LD_INT 30
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: LIST
75507: PUSH
75508: EMPTY
75509: LIST
75510: LIST
75511: PPUSH
75512: CALL_OW 72
75516: ST_TO_ADDR
75517: GO 75671
75519: LD_INT 3
75521: DOUBLE
75522: EQUAL
75523: IFTRUE 75527
75525: GO 75589
75527: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75528: LD_ADDR_VAR 0 12
75532: PUSH
75533: LD_VAR 0 18
75537: PPUSH
75538: LD_INT 22
75540: PUSH
75541: LD_VAR 0 16
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 2
75552: PUSH
75553: LD_INT 30
75555: PUSH
75556: LD_INT 2
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: LD_INT 30
75565: PUSH
75566: LD_INT 3
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: LIST
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PPUSH
75582: CALL_OW 72
75586: ST_TO_ADDR
75587: GO 75671
75589: LD_INT 4
75591: DOUBLE
75592: EQUAL
75593: IFTRUE 75597
75595: GO 75670
75597: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75598: LD_ADDR_VAR 0 12
75602: PUSH
75603: LD_VAR 0 18
75607: PPUSH
75608: LD_INT 22
75610: PUSH
75611: LD_VAR 0 16
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: PUSH
75620: LD_INT 2
75622: PUSH
75623: LD_INT 30
75625: PUSH
75626: LD_INT 6
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 30
75635: PUSH
75636: LD_INT 7
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 30
75645: PUSH
75646: LD_INT 8
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: EMPTY
75654: LIST
75655: LIST
75656: LIST
75657: LIST
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PPUSH
75663: CALL_OW 72
75667: ST_TO_ADDR
75668: GO 75671
75670: POP
// if i = 1 then
75671: LD_VAR 0 8
75675: PUSH
75676: LD_INT 1
75678: EQUAL
75679: IFFALSE 75790
// begin tmp := [ ] ;
75681: LD_ADDR_VAR 0 19
75685: PUSH
75686: EMPTY
75687: ST_TO_ADDR
// for j in f do
75688: LD_ADDR_VAR 0 9
75692: PUSH
75693: LD_VAR 0 12
75697: PUSH
75698: FOR_IN
75699: IFFALSE 75772
// if GetBType ( j ) = b_bunker then
75701: LD_VAR 0 9
75705: PPUSH
75706: CALL_OW 266
75710: PUSH
75711: LD_INT 32
75713: EQUAL
75714: IFFALSE 75741
// tmp := Insert ( tmp , 1 , j ) else
75716: LD_ADDR_VAR 0 19
75720: PUSH
75721: LD_VAR 0 19
75725: PPUSH
75726: LD_INT 1
75728: PPUSH
75729: LD_VAR 0 9
75733: PPUSH
75734: CALL_OW 2
75738: ST_TO_ADDR
75739: GO 75770
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75741: LD_ADDR_VAR 0 19
75745: PUSH
75746: LD_VAR 0 19
75750: PPUSH
75751: LD_VAR 0 19
75755: PUSH
75756: LD_INT 1
75758: PLUS
75759: PPUSH
75760: LD_VAR 0 9
75764: PPUSH
75765: CALL_OW 2
75769: ST_TO_ADDR
75770: GO 75698
75772: POP
75773: POP
// if tmp then
75774: LD_VAR 0 19
75778: IFFALSE 75790
// f := tmp ;
75780: LD_ADDR_VAR 0 12
75784: PUSH
75785: LD_VAR 0 19
75789: ST_TO_ADDR
// end ; x := personel [ i ] ;
75790: LD_ADDR_VAR 0 13
75794: PUSH
75795: LD_VAR 0 6
75799: PUSH
75800: LD_VAR 0 8
75804: ARRAY
75805: ST_TO_ADDR
// if x = - 1 then
75806: LD_VAR 0 13
75810: PUSH
75811: LD_INT 1
75813: NEG
75814: EQUAL
75815: IFFALSE 76024
// begin for j in f do
75817: LD_ADDR_VAR 0 9
75821: PUSH
75822: LD_VAR 0 12
75826: PUSH
75827: FOR_IN
75828: IFFALSE 76020
// repeat InitHc ;
75830: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75834: LD_VAR 0 9
75838: PPUSH
75839: CALL_OW 266
75843: PUSH
75844: LD_INT 5
75846: EQUAL
75847: IFFALSE 75917
// begin if UnitsInside ( j ) < 3 then
75849: LD_VAR 0 9
75853: PPUSH
75854: CALL_OW 313
75858: PUSH
75859: LD_INT 3
75861: LESS
75862: IFFALSE 75898
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75864: LD_INT 0
75866: PPUSH
75867: LD_INT 5
75869: PUSH
75870: LD_INT 8
75872: PUSH
75873: LD_INT 9
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: LIST
75880: PUSH
75881: LD_VAR 0 17
75885: ARRAY
75886: PPUSH
75887: LD_VAR 0 4
75891: PPUSH
75892: CALL_OW 380
75896: GO 75915
// PrepareHuman ( false , i , skill ) ;
75898: LD_INT 0
75900: PPUSH
75901: LD_VAR 0 8
75905: PPUSH
75906: LD_VAR 0 4
75910: PPUSH
75911: CALL_OW 380
// end else
75915: GO 75934
// PrepareHuman ( false , i , skill ) ;
75917: LD_INT 0
75919: PPUSH
75920: LD_VAR 0 8
75924: PPUSH
75925: LD_VAR 0 4
75929: PPUSH
75930: CALL_OW 380
// un := CreateHuman ;
75934: LD_ADDR_VAR 0 14
75938: PUSH
75939: CALL_OW 44
75943: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75944: LD_ADDR_VAR 0 7
75948: PUSH
75949: LD_VAR 0 7
75953: PPUSH
75954: LD_INT 1
75956: PPUSH
75957: LD_VAR 0 14
75961: PPUSH
75962: CALL_OW 2
75966: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75967: LD_VAR 0 14
75971: PPUSH
75972: LD_VAR 0 9
75976: PPUSH
75977: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75981: LD_VAR 0 9
75985: PPUSH
75986: CALL_OW 313
75990: PUSH
75991: LD_INT 6
75993: EQUAL
75994: PUSH
75995: LD_VAR 0 9
75999: PPUSH
76000: CALL_OW 266
76004: PUSH
76005: LD_INT 32
76007: PUSH
76008: LD_INT 31
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: IN
76015: OR
76016: IFFALSE 75830
76018: GO 75827
76020: POP
76021: POP
// end else
76022: GO 76404
// for j = 1 to x do
76024: LD_ADDR_VAR 0 9
76028: PUSH
76029: DOUBLE
76030: LD_INT 1
76032: DEC
76033: ST_TO_ADDR
76034: LD_VAR 0 13
76038: PUSH
76039: FOR_TO
76040: IFFALSE 76402
// begin InitHc ;
76042: CALL_OW 19
// if not f then
76046: LD_VAR 0 12
76050: NOT
76051: IFFALSE 76140
// begin PrepareHuman ( false , i , skill ) ;
76053: LD_INT 0
76055: PPUSH
76056: LD_VAR 0 8
76060: PPUSH
76061: LD_VAR 0 4
76065: PPUSH
76066: CALL_OW 380
// un := CreateHuman ;
76070: LD_ADDR_VAR 0 14
76074: PUSH
76075: CALL_OW 44
76079: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76080: LD_ADDR_VAR 0 7
76084: PUSH
76085: LD_VAR 0 7
76089: PPUSH
76090: LD_INT 1
76092: PPUSH
76093: LD_VAR 0 14
76097: PPUSH
76098: CALL_OW 2
76102: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76103: LD_VAR 0 14
76107: PPUSH
76108: LD_VAR 0 1
76112: PPUSH
76113: CALL_OW 250
76117: PPUSH
76118: LD_VAR 0 1
76122: PPUSH
76123: CALL_OW 251
76127: PPUSH
76128: LD_INT 10
76130: PPUSH
76131: LD_INT 0
76133: PPUSH
76134: CALL_OW 50
// continue ;
76138: GO 76039
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76140: LD_VAR 0 12
76144: PUSH
76145: LD_INT 1
76147: ARRAY
76148: PPUSH
76149: CALL_OW 313
76153: PUSH
76154: LD_VAR 0 12
76158: PUSH
76159: LD_INT 1
76161: ARRAY
76162: PPUSH
76163: CALL_OW 266
76167: PUSH
76168: LD_INT 32
76170: PUSH
76171: LD_INT 31
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: IN
76178: AND
76179: PUSH
76180: LD_VAR 0 12
76184: PUSH
76185: LD_INT 1
76187: ARRAY
76188: PPUSH
76189: CALL_OW 313
76193: PUSH
76194: LD_INT 6
76196: EQUAL
76197: OR
76198: IFFALSE 76218
// f := Delete ( f , 1 ) ;
76200: LD_ADDR_VAR 0 12
76204: PUSH
76205: LD_VAR 0 12
76209: PPUSH
76210: LD_INT 1
76212: PPUSH
76213: CALL_OW 3
76217: ST_TO_ADDR
// if not f then
76218: LD_VAR 0 12
76222: NOT
76223: IFFALSE 76241
// begin x := x + 2 ;
76225: LD_ADDR_VAR 0 13
76229: PUSH
76230: LD_VAR 0 13
76234: PUSH
76235: LD_INT 2
76237: PLUS
76238: ST_TO_ADDR
// continue ;
76239: GO 76039
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76241: LD_VAR 0 12
76245: PUSH
76246: LD_INT 1
76248: ARRAY
76249: PPUSH
76250: CALL_OW 266
76254: PUSH
76255: LD_INT 5
76257: EQUAL
76258: IFFALSE 76332
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76260: LD_VAR 0 12
76264: PUSH
76265: LD_INT 1
76267: ARRAY
76268: PPUSH
76269: CALL_OW 313
76273: PUSH
76274: LD_INT 3
76276: LESS
76277: IFFALSE 76313
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76279: LD_INT 0
76281: PPUSH
76282: LD_INT 5
76284: PUSH
76285: LD_INT 8
76287: PUSH
76288: LD_INT 9
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: PUSH
76296: LD_VAR 0 17
76300: ARRAY
76301: PPUSH
76302: LD_VAR 0 4
76306: PPUSH
76307: CALL_OW 380
76311: GO 76330
// PrepareHuman ( false , i , skill ) ;
76313: LD_INT 0
76315: PPUSH
76316: LD_VAR 0 8
76320: PPUSH
76321: LD_VAR 0 4
76325: PPUSH
76326: CALL_OW 380
// end else
76330: GO 76349
// PrepareHuman ( false , i , skill ) ;
76332: LD_INT 0
76334: PPUSH
76335: LD_VAR 0 8
76339: PPUSH
76340: LD_VAR 0 4
76344: PPUSH
76345: CALL_OW 380
// un := CreateHuman ;
76349: LD_ADDR_VAR 0 14
76353: PUSH
76354: CALL_OW 44
76358: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76359: LD_ADDR_VAR 0 7
76363: PUSH
76364: LD_VAR 0 7
76368: PPUSH
76369: LD_INT 1
76371: PPUSH
76372: LD_VAR 0 14
76376: PPUSH
76377: CALL_OW 2
76381: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76382: LD_VAR 0 14
76386: PPUSH
76387: LD_VAR 0 12
76391: PUSH
76392: LD_INT 1
76394: ARRAY
76395: PPUSH
76396: CALL_OW 52
// end ;
76400: GO 76039
76402: POP
76403: POP
// end ;
76404: GO 75341
76406: POP
76407: POP
// result := result ^ buildings ;
76408: LD_ADDR_VAR 0 7
76412: PUSH
76413: LD_VAR 0 7
76417: PUSH
76418: LD_VAR 0 18
76422: ADD
76423: ST_TO_ADDR
// end else
76424: GO 76567
// begin for i = 1 to personel do
76426: LD_ADDR_VAR 0 8
76430: PUSH
76431: DOUBLE
76432: LD_INT 1
76434: DEC
76435: ST_TO_ADDR
76436: LD_VAR 0 6
76440: PUSH
76441: FOR_TO
76442: IFFALSE 76565
// begin if i > 4 then
76444: LD_VAR 0 8
76448: PUSH
76449: LD_INT 4
76451: GREATER
76452: IFFALSE 76456
// break ;
76454: GO 76565
// x := personel [ i ] ;
76456: LD_ADDR_VAR 0 13
76460: PUSH
76461: LD_VAR 0 6
76465: PUSH
76466: LD_VAR 0 8
76470: ARRAY
76471: ST_TO_ADDR
// if x = - 1 then
76472: LD_VAR 0 13
76476: PUSH
76477: LD_INT 1
76479: NEG
76480: EQUAL
76481: IFFALSE 76485
// continue ;
76483: GO 76441
// PrepareHuman ( false , i , skill ) ;
76485: LD_INT 0
76487: PPUSH
76488: LD_VAR 0 8
76492: PPUSH
76493: LD_VAR 0 4
76497: PPUSH
76498: CALL_OW 380
// un := CreateHuman ;
76502: LD_ADDR_VAR 0 14
76506: PUSH
76507: CALL_OW 44
76511: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76512: LD_VAR 0 14
76516: PPUSH
76517: LD_VAR 0 1
76521: PPUSH
76522: CALL_OW 250
76526: PPUSH
76527: LD_VAR 0 1
76531: PPUSH
76532: CALL_OW 251
76536: PPUSH
76537: LD_INT 10
76539: PPUSH
76540: LD_INT 0
76542: PPUSH
76543: CALL_OW 50
// result := result ^ un ;
76547: LD_ADDR_VAR 0 7
76551: PUSH
76552: LD_VAR 0 7
76556: PUSH
76557: LD_VAR 0 14
76561: ADD
76562: ST_TO_ADDR
// end ;
76563: GO 76441
76565: POP
76566: POP
// end ; end ;
76567: LD_VAR 0 7
76571: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76572: LD_INT 0
76574: PPUSH
76575: PPUSH
76576: PPUSH
76577: PPUSH
76578: PPUSH
76579: PPUSH
76580: PPUSH
76581: PPUSH
76582: PPUSH
76583: PPUSH
76584: PPUSH
76585: PPUSH
76586: PPUSH
76587: PPUSH
76588: PPUSH
76589: PPUSH
// result := false ;
76590: LD_ADDR_VAR 0 3
76594: PUSH
76595: LD_INT 0
76597: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76598: LD_VAR 0 1
76602: NOT
76603: PUSH
76604: LD_VAR 0 1
76608: PPUSH
76609: CALL_OW 266
76613: PUSH
76614: LD_INT 32
76616: PUSH
76617: LD_INT 33
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: IN
76624: NOT
76625: OR
76626: IFFALSE 76630
// exit ;
76628: GO 77766
// nat := GetNation ( tower ) ;
76630: LD_ADDR_VAR 0 12
76634: PUSH
76635: LD_VAR 0 1
76639: PPUSH
76640: CALL_OW 248
76644: ST_TO_ADDR
// side := GetSide ( tower ) ;
76645: LD_ADDR_VAR 0 16
76649: PUSH
76650: LD_VAR 0 1
76654: PPUSH
76655: CALL_OW 255
76659: ST_TO_ADDR
// x := GetX ( tower ) ;
76660: LD_ADDR_VAR 0 10
76664: PUSH
76665: LD_VAR 0 1
76669: PPUSH
76670: CALL_OW 250
76674: ST_TO_ADDR
// y := GetY ( tower ) ;
76675: LD_ADDR_VAR 0 11
76679: PUSH
76680: LD_VAR 0 1
76684: PPUSH
76685: CALL_OW 251
76689: ST_TO_ADDR
// if not x or not y then
76690: LD_VAR 0 10
76694: NOT
76695: PUSH
76696: LD_VAR 0 11
76700: NOT
76701: OR
76702: IFFALSE 76706
// exit ;
76704: GO 77766
// weapon := 0 ;
76706: LD_ADDR_VAR 0 18
76710: PUSH
76711: LD_INT 0
76713: ST_TO_ADDR
// fac_list := [ ] ;
76714: LD_ADDR_VAR 0 17
76718: PUSH
76719: EMPTY
76720: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76721: LD_ADDR_VAR 0 6
76725: PUSH
76726: LD_VAR 0 1
76730: PPUSH
76731: CALL_OW 274
76735: PPUSH
76736: LD_VAR 0 2
76740: PPUSH
76741: CALL 74344 0 2
76745: PPUSH
76746: LD_INT 30
76748: PUSH
76749: LD_INT 3
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: PPUSH
76756: CALL_OW 72
76760: ST_TO_ADDR
// if not factories then
76761: LD_VAR 0 6
76765: NOT
76766: IFFALSE 76770
// exit ;
76768: GO 77766
// for i in factories do
76770: LD_ADDR_VAR 0 8
76774: PUSH
76775: LD_VAR 0 6
76779: PUSH
76780: FOR_IN
76781: IFFALSE 76806
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76783: LD_ADDR_VAR 0 17
76787: PUSH
76788: LD_VAR 0 17
76792: PUSH
76793: LD_VAR 0 8
76797: PPUSH
76798: CALL_OW 478
76802: UNION
76803: ST_TO_ADDR
76804: GO 76780
76806: POP
76807: POP
// if not fac_list then
76808: LD_VAR 0 17
76812: NOT
76813: IFFALSE 76817
// exit ;
76815: GO 77766
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76817: LD_ADDR_VAR 0 5
76821: PUSH
76822: LD_INT 4
76824: PUSH
76825: LD_INT 5
76827: PUSH
76828: LD_INT 9
76830: PUSH
76831: LD_INT 10
76833: PUSH
76834: LD_INT 6
76836: PUSH
76837: LD_INT 7
76839: PUSH
76840: LD_INT 11
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: LIST
76847: LIST
76848: LIST
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 27
76854: PUSH
76855: LD_INT 28
76857: PUSH
76858: LD_INT 26
76860: PUSH
76861: LD_INT 30
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 43
76872: PUSH
76873: LD_INT 44
76875: PUSH
76876: LD_INT 46
76878: PUSH
76879: LD_INT 45
76881: PUSH
76882: LD_INT 47
76884: PUSH
76885: LD_INT 49
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: LIST
76900: PUSH
76901: LD_VAR 0 12
76905: ARRAY
76906: ST_TO_ADDR
// for i in list do
76907: LD_ADDR_VAR 0 8
76911: PUSH
76912: LD_VAR 0 5
76916: PUSH
76917: FOR_IN
76918: IFFALSE 76951
// if not i in fac_list then
76920: LD_VAR 0 8
76924: PUSH
76925: LD_VAR 0 17
76929: IN
76930: NOT
76931: IFFALSE 76949
// list := list diff i ;
76933: LD_ADDR_VAR 0 5
76937: PUSH
76938: LD_VAR 0 5
76942: PUSH
76943: LD_VAR 0 8
76947: DIFF
76948: ST_TO_ADDR
76949: GO 76917
76951: POP
76952: POP
// if not list then
76953: LD_VAR 0 5
76957: NOT
76958: IFFALSE 76962
// exit ;
76960: GO 77766
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76962: LD_VAR 0 12
76966: PUSH
76967: LD_INT 3
76969: EQUAL
76970: PUSH
76971: LD_INT 49
76973: PUSH
76974: LD_VAR 0 5
76978: IN
76979: AND
76980: PUSH
76981: LD_INT 31
76983: PPUSH
76984: LD_VAR 0 16
76988: PPUSH
76989: CALL_OW 321
76993: PUSH
76994: LD_INT 2
76996: EQUAL
76997: AND
76998: IFFALSE 77058
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77000: LD_INT 22
77002: PUSH
77003: LD_VAR 0 16
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 35
77014: PUSH
77015: LD_INT 49
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 91
77024: PUSH
77025: LD_VAR 0 1
77029: PUSH
77030: LD_INT 10
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: LIST
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: LIST
77042: PPUSH
77043: CALL_OW 69
77047: NOT
77048: IFFALSE 77058
// weapon := ru_time_lapser ;
77050: LD_ADDR_VAR 0 18
77054: PUSH
77055: LD_INT 49
77057: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77058: LD_VAR 0 12
77062: PUSH
77063: LD_INT 1
77065: PUSH
77066: LD_INT 2
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: IN
77073: PUSH
77074: LD_INT 11
77076: PUSH
77077: LD_VAR 0 5
77081: IN
77082: PUSH
77083: LD_INT 30
77085: PUSH
77086: LD_VAR 0 5
77090: IN
77091: OR
77092: AND
77093: PUSH
77094: LD_INT 6
77096: PPUSH
77097: LD_VAR 0 16
77101: PPUSH
77102: CALL_OW 321
77106: PUSH
77107: LD_INT 2
77109: EQUAL
77110: AND
77111: IFFALSE 77276
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77113: LD_INT 22
77115: PUSH
77116: LD_VAR 0 16
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 2
77127: PUSH
77128: LD_INT 35
77130: PUSH
77131: LD_INT 11
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 35
77140: PUSH
77141: LD_INT 30
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 91
77155: PUSH
77156: LD_VAR 0 1
77160: PUSH
77161: LD_INT 18
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: LIST
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: LIST
77173: PPUSH
77174: CALL_OW 69
77178: NOT
77179: PUSH
77180: LD_INT 22
77182: PUSH
77183: LD_VAR 0 16
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 2
77194: PUSH
77195: LD_INT 30
77197: PUSH
77198: LD_INT 32
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 30
77207: PUSH
77208: LD_INT 33
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 91
77222: PUSH
77223: LD_VAR 0 1
77227: PUSH
77228: LD_INT 12
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: LIST
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: LIST
77240: PUSH
77241: EMPTY
77242: LIST
77243: PPUSH
77244: CALL_OW 69
77248: PUSH
77249: LD_INT 2
77251: GREATER
77252: AND
77253: IFFALSE 77276
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77255: LD_ADDR_VAR 0 18
77259: PUSH
77260: LD_INT 11
77262: PUSH
77263: LD_INT 30
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_VAR 0 12
77274: ARRAY
77275: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77276: LD_VAR 0 18
77280: NOT
77281: PUSH
77282: LD_INT 40
77284: PPUSH
77285: LD_VAR 0 16
77289: PPUSH
77290: CALL_OW 321
77294: PUSH
77295: LD_INT 2
77297: EQUAL
77298: AND
77299: PUSH
77300: LD_INT 7
77302: PUSH
77303: LD_VAR 0 5
77307: IN
77308: PUSH
77309: LD_INT 28
77311: PUSH
77312: LD_VAR 0 5
77316: IN
77317: OR
77318: PUSH
77319: LD_INT 45
77321: PUSH
77322: LD_VAR 0 5
77326: IN
77327: OR
77328: AND
77329: IFFALSE 77583
// begin hex := GetHexInfo ( x , y ) ;
77331: LD_ADDR_VAR 0 4
77335: PUSH
77336: LD_VAR 0 10
77340: PPUSH
77341: LD_VAR 0 11
77345: PPUSH
77346: CALL_OW 546
77350: ST_TO_ADDR
// if hex [ 1 ] then
77351: LD_VAR 0 4
77355: PUSH
77356: LD_INT 1
77358: ARRAY
77359: IFFALSE 77363
// exit ;
77361: GO 77766
// height := hex [ 2 ] ;
77363: LD_ADDR_VAR 0 15
77367: PUSH
77368: LD_VAR 0 4
77372: PUSH
77373: LD_INT 2
77375: ARRAY
77376: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77377: LD_ADDR_VAR 0 14
77381: PUSH
77382: LD_INT 0
77384: PUSH
77385: LD_INT 2
77387: PUSH
77388: LD_INT 3
77390: PUSH
77391: LD_INT 5
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: ST_TO_ADDR
// for i in tmp do
77400: LD_ADDR_VAR 0 8
77404: PUSH
77405: LD_VAR 0 14
77409: PUSH
77410: FOR_IN
77411: IFFALSE 77581
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77413: LD_ADDR_VAR 0 9
77417: PUSH
77418: LD_VAR 0 10
77422: PPUSH
77423: LD_VAR 0 8
77427: PPUSH
77428: LD_INT 5
77430: PPUSH
77431: CALL_OW 272
77435: PUSH
77436: LD_VAR 0 11
77440: PPUSH
77441: LD_VAR 0 8
77445: PPUSH
77446: LD_INT 5
77448: PPUSH
77449: CALL_OW 273
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77458: LD_VAR 0 9
77462: PUSH
77463: LD_INT 1
77465: ARRAY
77466: PPUSH
77467: LD_VAR 0 9
77471: PUSH
77472: LD_INT 2
77474: ARRAY
77475: PPUSH
77476: CALL_OW 488
77480: IFFALSE 77579
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77482: LD_ADDR_VAR 0 4
77486: PUSH
77487: LD_VAR 0 9
77491: PUSH
77492: LD_INT 1
77494: ARRAY
77495: PPUSH
77496: LD_VAR 0 9
77500: PUSH
77501: LD_INT 2
77503: ARRAY
77504: PPUSH
77505: CALL_OW 546
77509: ST_TO_ADDR
// if hex [ 1 ] then
77510: LD_VAR 0 4
77514: PUSH
77515: LD_INT 1
77517: ARRAY
77518: IFFALSE 77522
// continue ;
77520: GO 77410
// h := hex [ 2 ] ;
77522: LD_ADDR_VAR 0 13
77526: PUSH
77527: LD_VAR 0 4
77531: PUSH
77532: LD_INT 2
77534: ARRAY
77535: ST_TO_ADDR
// if h + 7 < height then
77536: LD_VAR 0 13
77540: PUSH
77541: LD_INT 7
77543: PLUS
77544: PUSH
77545: LD_VAR 0 15
77549: LESS
77550: IFFALSE 77579
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77552: LD_ADDR_VAR 0 18
77556: PUSH
77557: LD_INT 7
77559: PUSH
77560: LD_INT 28
77562: PUSH
77563: LD_INT 45
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: LIST
77570: PUSH
77571: LD_VAR 0 12
77575: ARRAY
77576: ST_TO_ADDR
// break ;
77577: GO 77581
// end ; end ; end ;
77579: GO 77410
77581: POP
77582: POP
// end ; if not weapon then
77583: LD_VAR 0 18
77587: NOT
77588: IFFALSE 77648
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77590: LD_ADDR_VAR 0 5
77594: PUSH
77595: LD_VAR 0 5
77599: PUSH
77600: LD_INT 11
77602: PUSH
77603: LD_INT 30
77605: PUSH
77606: LD_INT 49
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: LIST
77613: DIFF
77614: ST_TO_ADDR
// if not list then
77615: LD_VAR 0 5
77619: NOT
77620: IFFALSE 77624
// exit ;
77622: GO 77766
// weapon := list [ rand ( 1 , list ) ] ;
77624: LD_ADDR_VAR 0 18
77628: PUSH
77629: LD_VAR 0 5
77633: PUSH
77634: LD_INT 1
77636: PPUSH
77637: LD_VAR 0 5
77641: PPUSH
77642: CALL_OW 12
77646: ARRAY
77647: ST_TO_ADDR
// end ; if weapon then
77648: LD_VAR 0 18
77652: IFFALSE 77766
// begin tmp := CostOfWeapon ( weapon ) ;
77654: LD_ADDR_VAR 0 14
77658: PUSH
77659: LD_VAR 0 18
77663: PPUSH
77664: CALL_OW 451
77668: ST_TO_ADDR
// j := GetBase ( tower ) ;
77669: LD_ADDR_VAR 0 9
77673: PUSH
77674: LD_VAR 0 1
77678: PPUSH
77679: CALL_OW 274
77683: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77684: LD_VAR 0 9
77688: PPUSH
77689: LD_INT 1
77691: PPUSH
77692: CALL_OW 275
77696: PUSH
77697: LD_VAR 0 14
77701: PUSH
77702: LD_INT 1
77704: ARRAY
77705: GREATEREQUAL
77706: PUSH
77707: LD_VAR 0 9
77711: PPUSH
77712: LD_INT 2
77714: PPUSH
77715: CALL_OW 275
77719: PUSH
77720: LD_VAR 0 14
77724: PUSH
77725: LD_INT 2
77727: ARRAY
77728: GREATEREQUAL
77729: AND
77730: PUSH
77731: LD_VAR 0 9
77735: PPUSH
77736: LD_INT 3
77738: PPUSH
77739: CALL_OW 275
77743: PUSH
77744: LD_VAR 0 14
77748: PUSH
77749: LD_INT 3
77751: ARRAY
77752: GREATEREQUAL
77753: AND
77754: IFFALSE 77766
// result := weapon ;
77756: LD_ADDR_VAR 0 3
77760: PUSH
77761: LD_VAR 0 18
77765: ST_TO_ADDR
// end ; end ;
77766: LD_VAR 0 3
77770: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77771: LD_INT 0
77773: PPUSH
77774: PPUSH
// result := true ;
77775: LD_ADDR_VAR 0 3
77779: PUSH
77780: LD_INT 1
77782: ST_TO_ADDR
// if array1 = array2 then
77783: LD_VAR 0 1
77787: PUSH
77788: LD_VAR 0 2
77792: EQUAL
77793: IFFALSE 77853
// begin for i = 1 to array1 do
77795: LD_ADDR_VAR 0 4
77799: PUSH
77800: DOUBLE
77801: LD_INT 1
77803: DEC
77804: ST_TO_ADDR
77805: LD_VAR 0 1
77809: PUSH
77810: FOR_TO
77811: IFFALSE 77849
// if array1 [ i ] <> array2 [ i ] then
77813: LD_VAR 0 1
77817: PUSH
77818: LD_VAR 0 4
77822: ARRAY
77823: PUSH
77824: LD_VAR 0 2
77828: PUSH
77829: LD_VAR 0 4
77833: ARRAY
77834: NONEQUAL
77835: IFFALSE 77847
// begin result := false ;
77837: LD_ADDR_VAR 0 3
77841: PUSH
77842: LD_INT 0
77844: ST_TO_ADDR
// break ;
77845: GO 77849
// end ;
77847: GO 77810
77849: POP
77850: POP
// end else
77851: GO 77861
// result := false ;
77853: LD_ADDR_VAR 0 3
77857: PUSH
77858: LD_INT 0
77860: ST_TO_ADDR
// end ;
77861: LD_VAR 0 3
77865: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77866: LD_INT 0
77868: PPUSH
77869: PPUSH
77870: PPUSH
// pom := GetBase ( fac ) ;
77871: LD_ADDR_VAR 0 5
77875: PUSH
77876: LD_VAR 0 1
77880: PPUSH
77881: CALL_OW 274
77885: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77886: LD_ADDR_VAR 0 4
77890: PUSH
77891: LD_VAR 0 2
77895: PUSH
77896: LD_INT 1
77898: ARRAY
77899: PPUSH
77900: LD_VAR 0 2
77904: PUSH
77905: LD_INT 2
77907: ARRAY
77908: PPUSH
77909: LD_VAR 0 2
77913: PUSH
77914: LD_INT 3
77916: ARRAY
77917: PPUSH
77918: LD_VAR 0 2
77922: PUSH
77923: LD_INT 4
77925: ARRAY
77926: PPUSH
77927: CALL_OW 449
77931: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77932: LD_ADDR_VAR 0 3
77936: PUSH
77937: LD_VAR 0 5
77941: PPUSH
77942: LD_INT 1
77944: PPUSH
77945: CALL_OW 275
77949: PUSH
77950: LD_VAR 0 4
77954: PUSH
77955: LD_INT 1
77957: ARRAY
77958: GREATEREQUAL
77959: PUSH
77960: LD_VAR 0 5
77964: PPUSH
77965: LD_INT 2
77967: PPUSH
77968: CALL_OW 275
77972: PUSH
77973: LD_VAR 0 4
77977: PUSH
77978: LD_INT 2
77980: ARRAY
77981: GREATEREQUAL
77982: AND
77983: PUSH
77984: LD_VAR 0 5
77988: PPUSH
77989: LD_INT 3
77991: PPUSH
77992: CALL_OW 275
77996: PUSH
77997: LD_VAR 0 4
78001: PUSH
78002: LD_INT 3
78004: ARRAY
78005: GREATEREQUAL
78006: AND
78007: ST_TO_ADDR
// end ;
78008: LD_VAR 0 3
78012: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78013: LD_INT 0
78015: PPUSH
78016: PPUSH
78017: PPUSH
78018: PPUSH
// pom := GetBase ( building ) ;
78019: LD_ADDR_VAR 0 3
78023: PUSH
78024: LD_VAR 0 1
78028: PPUSH
78029: CALL_OW 274
78033: ST_TO_ADDR
// if not pom then
78034: LD_VAR 0 3
78038: NOT
78039: IFFALSE 78043
// exit ;
78041: GO 78213
// btype := GetBType ( building ) ;
78043: LD_ADDR_VAR 0 5
78047: PUSH
78048: LD_VAR 0 1
78052: PPUSH
78053: CALL_OW 266
78057: ST_TO_ADDR
// if btype = b_armoury then
78058: LD_VAR 0 5
78062: PUSH
78063: LD_INT 4
78065: EQUAL
78066: IFFALSE 78076
// btype := b_barracks ;
78068: LD_ADDR_VAR 0 5
78072: PUSH
78073: LD_INT 5
78075: ST_TO_ADDR
// if btype = b_depot then
78076: LD_VAR 0 5
78080: PUSH
78081: LD_INT 0
78083: EQUAL
78084: IFFALSE 78094
// btype := b_warehouse ;
78086: LD_ADDR_VAR 0 5
78090: PUSH
78091: LD_INT 1
78093: ST_TO_ADDR
// if btype = b_workshop then
78094: LD_VAR 0 5
78098: PUSH
78099: LD_INT 2
78101: EQUAL
78102: IFFALSE 78112
// btype := b_factory ;
78104: LD_ADDR_VAR 0 5
78108: PUSH
78109: LD_INT 3
78111: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78112: LD_ADDR_VAR 0 4
78116: PUSH
78117: LD_VAR 0 5
78121: PPUSH
78122: LD_VAR 0 1
78126: PPUSH
78127: CALL_OW 248
78131: PPUSH
78132: CALL_OW 450
78136: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78137: LD_ADDR_VAR 0 2
78141: PUSH
78142: LD_VAR 0 3
78146: PPUSH
78147: LD_INT 1
78149: PPUSH
78150: CALL_OW 275
78154: PUSH
78155: LD_VAR 0 4
78159: PUSH
78160: LD_INT 1
78162: ARRAY
78163: GREATEREQUAL
78164: PUSH
78165: LD_VAR 0 3
78169: PPUSH
78170: LD_INT 2
78172: PPUSH
78173: CALL_OW 275
78177: PUSH
78178: LD_VAR 0 4
78182: PUSH
78183: LD_INT 2
78185: ARRAY
78186: GREATEREQUAL
78187: AND
78188: PUSH
78189: LD_VAR 0 3
78193: PPUSH
78194: LD_INT 3
78196: PPUSH
78197: CALL_OW 275
78201: PUSH
78202: LD_VAR 0 4
78206: PUSH
78207: LD_INT 3
78209: ARRAY
78210: GREATEREQUAL
78211: AND
78212: ST_TO_ADDR
// end ;
78213: LD_VAR 0 2
78217: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78218: LD_INT 0
78220: PPUSH
78221: PPUSH
78222: PPUSH
// pom := GetBase ( building ) ;
78223: LD_ADDR_VAR 0 4
78227: PUSH
78228: LD_VAR 0 1
78232: PPUSH
78233: CALL_OW 274
78237: ST_TO_ADDR
// if not pom then
78238: LD_VAR 0 4
78242: NOT
78243: IFFALSE 78247
// exit ;
78245: GO 78348
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78247: LD_ADDR_VAR 0 5
78251: PUSH
78252: LD_VAR 0 2
78256: PPUSH
78257: LD_VAR 0 1
78261: PPUSH
78262: CALL_OW 248
78266: PPUSH
78267: CALL_OW 450
78271: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78272: LD_ADDR_VAR 0 3
78276: PUSH
78277: LD_VAR 0 4
78281: PPUSH
78282: LD_INT 1
78284: PPUSH
78285: CALL_OW 275
78289: PUSH
78290: LD_VAR 0 5
78294: PUSH
78295: LD_INT 1
78297: ARRAY
78298: GREATEREQUAL
78299: PUSH
78300: LD_VAR 0 4
78304: PPUSH
78305: LD_INT 2
78307: PPUSH
78308: CALL_OW 275
78312: PUSH
78313: LD_VAR 0 5
78317: PUSH
78318: LD_INT 2
78320: ARRAY
78321: GREATEREQUAL
78322: AND
78323: PUSH
78324: LD_VAR 0 4
78328: PPUSH
78329: LD_INT 3
78331: PPUSH
78332: CALL_OW 275
78336: PUSH
78337: LD_VAR 0 5
78341: PUSH
78342: LD_INT 3
78344: ARRAY
78345: GREATEREQUAL
78346: AND
78347: ST_TO_ADDR
// end ;
78348: LD_VAR 0 3
78352: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78353: LD_INT 0
78355: PPUSH
78356: PPUSH
78357: PPUSH
78358: PPUSH
78359: PPUSH
78360: PPUSH
78361: PPUSH
78362: PPUSH
78363: PPUSH
78364: PPUSH
// result := false ;
78365: LD_ADDR_VAR 0 6
78369: PUSH
78370: LD_INT 0
78372: ST_TO_ADDR
// if not base or not btype or not x or not y then
78373: LD_VAR 0 1
78377: NOT
78378: PUSH
78379: LD_VAR 0 2
78383: NOT
78384: OR
78385: PUSH
78386: LD_VAR 0 3
78390: NOT
78391: OR
78392: PUSH
78393: LD_VAR 0 4
78397: NOT
78398: OR
78399: IFFALSE 78403
// exit ;
78401: GO 79012
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78403: LD_ADDR_VAR 0 12
78407: PUSH
78408: LD_VAR 0 2
78412: PPUSH
78413: LD_VAR 0 3
78417: PPUSH
78418: LD_VAR 0 4
78422: PPUSH
78423: LD_VAR 0 5
78427: PPUSH
78428: LD_VAR 0 1
78432: PUSH
78433: LD_INT 1
78435: ARRAY
78436: PPUSH
78437: CALL_OW 248
78441: PPUSH
78442: LD_INT 0
78444: PPUSH
78445: CALL 79849 0 6
78449: ST_TO_ADDR
// if not hexes then
78450: LD_VAR 0 12
78454: NOT
78455: IFFALSE 78459
// exit ;
78457: GO 79012
// for i = 1 to hexes do
78459: LD_ADDR_VAR 0 7
78463: PUSH
78464: DOUBLE
78465: LD_INT 1
78467: DEC
78468: ST_TO_ADDR
78469: LD_VAR 0 12
78473: PUSH
78474: FOR_TO
78475: IFFALSE 79010
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78477: LD_ADDR_VAR 0 11
78481: PUSH
78482: LD_VAR 0 12
78486: PUSH
78487: LD_VAR 0 7
78491: ARRAY
78492: PUSH
78493: LD_INT 1
78495: ARRAY
78496: PPUSH
78497: LD_VAR 0 12
78501: PUSH
78502: LD_VAR 0 7
78506: ARRAY
78507: PUSH
78508: LD_INT 2
78510: ARRAY
78511: PPUSH
78512: CALL_OW 428
78516: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78517: LD_VAR 0 12
78521: PUSH
78522: LD_VAR 0 7
78526: ARRAY
78527: PUSH
78528: LD_INT 1
78530: ARRAY
78531: PPUSH
78532: LD_VAR 0 12
78536: PUSH
78537: LD_VAR 0 7
78541: ARRAY
78542: PUSH
78543: LD_INT 2
78545: ARRAY
78546: PPUSH
78547: CALL_OW 351
78551: PUSH
78552: LD_VAR 0 12
78556: PUSH
78557: LD_VAR 0 7
78561: ARRAY
78562: PUSH
78563: LD_INT 1
78565: ARRAY
78566: PPUSH
78567: LD_VAR 0 12
78571: PUSH
78572: LD_VAR 0 7
78576: ARRAY
78577: PUSH
78578: LD_INT 2
78580: ARRAY
78581: PPUSH
78582: CALL_OW 488
78586: NOT
78587: OR
78588: PUSH
78589: LD_VAR 0 11
78593: PPUSH
78594: CALL_OW 247
78598: PUSH
78599: LD_INT 3
78601: EQUAL
78602: OR
78603: IFFALSE 78609
// exit ;
78605: POP
78606: POP
78607: GO 79012
// if not tmp or not tmp in base then
78609: LD_VAR 0 11
78613: NOT
78614: PUSH
78615: LD_VAR 0 11
78619: PUSH
78620: LD_VAR 0 1
78624: IN
78625: NOT
78626: OR
78627: IFFALSE 78631
// continue ;
78629: GO 78474
// result := true ;
78631: LD_ADDR_VAR 0 6
78635: PUSH
78636: LD_INT 1
78638: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78639: LD_ADDR_VAR 0 15
78643: PUSH
78644: LD_VAR 0 1
78648: PPUSH
78649: LD_INT 22
78651: PUSH
78652: LD_VAR 0 11
78656: PPUSH
78657: CALL_OW 255
78661: PUSH
78662: EMPTY
78663: LIST
78664: LIST
78665: PUSH
78666: LD_INT 2
78668: PUSH
78669: LD_INT 30
78671: PUSH
78672: LD_INT 0
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 30
78681: PUSH
78682: LD_INT 1
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: LIST
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PPUSH
78698: CALL_OW 72
78702: ST_TO_ADDR
// if dep then
78703: LD_VAR 0 15
78707: IFFALSE 78843
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78709: LD_ADDR_VAR 0 14
78713: PUSH
78714: LD_VAR 0 15
78718: PUSH
78719: LD_INT 1
78721: ARRAY
78722: PPUSH
78723: CALL_OW 250
78727: PPUSH
78728: LD_VAR 0 15
78732: PUSH
78733: LD_INT 1
78735: ARRAY
78736: PPUSH
78737: CALL_OW 254
78741: PPUSH
78742: LD_INT 5
78744: PPUSH
78745: CALL_OW 272
78749: PUSH
78750: LD_VAR 0 15
78754: PUSH
78755: LD_INT 1
78757: ARRAY
78758: PPUSH
78759: CALL_OW 251
78763: PPUSH
78764: LD_VAR 0 15
78768: PUSH
78769: LD_INT 1
78771: ARRAY
78772: PPUSH
78773: CALL_OW 254
78777: PPUSH
78778: LD_INT 5
78780: PPUSH
78781: CALL_OW 273
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78790: LD_VAR 0 14
78794: PUSH
78795: LD_INT 1
78797: ARRAY
78798: PPUSH
78799: LD_VAR 0 14
78803: PUSH
78804: LD_INT 2
78806: ARRAY
78807: PPUSH
78808: CALL_OW 488
78812: IFFALSE 78843
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78814: LD_VAR 0 11
78818: PPUSH
78819: LD_VAR 0 14
78823: PUSH
78824: LD_INT 1
78826: ARRAY
78827: PPUSH
78828: LD_VAR 0 14
78832: PUSH
78833: LD_INT 2
78835: ARRAY
78836: PPUSH
78837: CALL_OW 111
// continue ;
78841: GO 78474
// end ; end ; r := GetDir ( tmp ) ;
78843: LD_ADDR_VAR 0 13
78847: PUSH
78848: LD_VAR 0 11
78852: PPUSH
78853: CALL_OW 254
78857: ST_TO_ADDR
// if r = 5 then
78858: LD_VAR 0 13
78862: PUSH
78863: LD_INT 5
78865: EQUAL
78866: IFFALSE 78876
// r := 0 ;
78868: LD_ADDR_VAR 0 13
78872: PUSH
78873: LD_INT 0
78875: ST_TO_ADDR
// for j = r to 5 do
78876: LD_ADDR_VAR 0 8
78880: PUSH
78881: DOUBLE
78882: LD_VAR 0 13
78886: DEC
78887: ST_TO_ADDR
78888: LD_INT 5
78890: PUSH
78891: FOR_TO
78892: IFFALSE 79006
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78894: LD_ADDR_VAR 0 9
78898: PUSH
78899: LD_VAR 0 11
78903: PPUSH
78904: CALL_OW 250
78908: PPUSH
78909: LD_VAR 0 8
78913: PPUSH
78914: LD_INT 2
78916: PPUSH
78917: CALL_OW 272
78921: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78922: LD_ADDR_VAR 0 10
78926: PUSH
78927: LD_VAR 0 11
78931: PPUSH
78932: CALL_OW 251
78936: PPUSH
78937: LD_VAR 0 8
78941: PPUSH
78942: LD_INT 2
78944: PPUSH
78945: CALL_OW 273
78949: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78950: LD_VAR 0 9
78954: PPUSH
78955: LD_VAR 0 10
78959: PPUSH
78960: CALL_OW 488
78964: PUSH
78965: LD_VAR 0 9
78969: PPUSH
78970: LD_VAR 0 10
78974: PPUSH
78975: CALL_OW 428
78979: NOT
78980: AND
78981: IFFALSE 79004
// begin ComMoveXY ( tmp , _x , _y ) ;
78983: LD_VAR 0 11
78987: PPUSH
78988: LD_VAR 0 9
78992: PPUSH
78993: LD_VAR 0 10
78997: PPUSH
78998: CALL_OW 111
// break ;
79002: GO 79006
// end ; end ;
79004: GO 78891
79006: POP
79007: POP
// end ;
79008: GO 78474
79010: POP
79011: POP
// end ;
79012: LD_VAR 0 6
79016: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79017: LD_INT 0
79019: PPUSH
79020: PPUSH
79021: PPUSH
79022: PPUSH
79023: PPUSH
79024: PPUSH
79025: PPUSH
79026: PPUSH
79027: PPUSH
79028: PPUSH
// result := false ;
79029: LD_ADDR_VAR 0 6
79033: PUSH
79034: LD_INT 0
79036: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79037: LD_VAR 0 1
79041: NOT
79042: PUSH
79043: LD_VAR 0 1
79047: PPUSH
79048: CALL_OW 266
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: LD_INT 1
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: IN
79063: NOT
79064: OR
79065: PUSH
79066: LD_VAR 0 2
79070: NOT
79071: OR
79072: PUSH
79073: LD_VAR 0 5
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: LD_INT 2
79086: PUSH
79087: LD_INT 3
79089: PUSH
79090: LD_INT 4
79092: PUSH
79093: LD_INT 5
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: IN
79104: NOT
79105: OR
79106: PUSH
79107: LD_VAR 0 3
79111: PPUSH
79112: LD_VAR 0 4
79116: PPUSH
79117: CALL_OW 488
79121: NOT
79122: OR
79123: IFFALSE 79127
// exit ;
79125: GO 79844
// pom := GetBase ( depot ) ;
79127: LD_ADDR_VAR 0 10
79131: PUSH
79132: LD_VAR 0 1
79136: PPUSH
79137: CALL_OW 274
79141: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79142: LD_ADDR_VAR 0 11
79146: PUSH
79147: LD_VAR 0 2
79151: PPUSH
79152: LD_VAR 0 1
79156: PPUSH
79157: CALL_OW 248
79161: PPUSH
79162: CALL_OW 450
79166: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79167: LD_VAR 0 10
79171: PPUSH
79172: LD_INT 1
79174: PPUSH
79175: CALL_OW 275
79179: PUSH
79180: LD_VAR 0 11
79184: PUSH
79185: LD_INT 1
79187: ARRAY
79188: GREATEREQUAL
79189: PUSH
79190: LD_VAR 0 10
79194: PPUSH
79195: LD_INT 2
79197: PPUSH
79198: CALL_OW 275
79202: PUSH
79203: LD_VAR 0 11
79207: PUSH
79208: LD_INT 2
79210: ARRAY
79211: GREATEREQUAL
79212: AND
79213: PUSH
79214: LD_VAR 0 10
79218: PPUSH
79219: LD_INT 3
79221: PPUSH
79222: CALL_OW 275
79226: PUSH
79227: LD_VAR 0 11
79231: PUSH
79232: LD_INT 3
79234: ARRAY
79235: GREATEREQUAL
79236: AND
79237: NOT
79238: IFFALSE 79242
// exit ;
79240: GO 79844
// if GetBType ( depot ) = b_depot then
79242: LD_VAR 0 1
79246: PPUSH
79247: CALL_OW 266
79251: PUSH
79252: LD_INT 0
79254: EQUAL
79255: IFFALSE 79267
// dist := 28 else
79257: LD_ADDR_VAR 0 14
79261: PUSH
79262: LD_INT 28
79264: ST_TO_ADDR
79265: GO 79275
// dist := 36 ;
79267: LD_ADDR_VAR 0 14
79271: PUSH
79272: LD_INT 36
79274: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79275: LD_VAR 0 1
79279: PPUSH
79280: LD_VAR 0 3
79284: PPUSH
79285: LD_VAR 0 4
79289: PPUSH
79290: CALL_OW 297
79294: PUSH
79295: LD_VAR 0 14
79299: GREATER
79300: IFFALSE 79304
// exit ;
79302: GO 79844
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79304: LD_ADDR_VAR 0 12
79308: PUSH
79309: LD_VAR 0 2
79313: PPUSH
79314: LD_VAR 0 3
79318: PPUSH
79319: LD_VAR 0 4
79323: PPUSH
79324: LD_VAR 0 5
79328: PPUSH
79329: LD_VAR 0 1
79333: PPUSH
79334: CALL_OW 248
79338: PPUSH
79339: LD_INT 0
79341: PPUSH
79342: CALL 79849 0 6
79346: ST_TO_ADDR
// if not hexes then
79347: LD_VAR 0 12
79351: NOT
79352: IFFALSE 79356
// exit ;
79354: GO 79844
// hex := GetHexInfo ( x , y ) ;
79356: LD_ADDR_VAR 0 15
79360: PUSH
79361: LD_VAR 0 3
79365: PPUSH
79366: LD_VAR 0 4
79370: PPUSH
79371: CALL_OW 546
79375: ST_TO_ADDR
// if hex [ 1 ] then
79376: LD_VAR 0 15
79380: PUSH
79381: LD_INT 1
79383: ARRAY
79384: IFFALSE 79388
// exit ;
79386: GO 79844
// height := hex [ 2 ] ;
79388: LD_ADDR_VAR 0 13
79392: PUSH
79393: LD_VAR 0 15
79397: PUSH
79398: LD_INT 2
79400: ARRAY
79401: ST_TO_ADDR
// for i = 1 to hexes do
79402: LD_ADDR_VAR 0 7
79406: PUSH
79407: DOUBLE
79408: LD_INT 1
79410: DEC
79411: ST_TO_ADDR
79412: LD_VAR 0 12
79416: PUSH
79417: FOR_TO
79418: IFFALSE 79748
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79420: LD_VAR 0 12
79424: PUSH
79425: LD_VAR 0 7
79429: ARRAY
79430: PUSH
79431: LD_INT 1
79433: ARRAY
79434: PPUSH
79435: LD_VAR 0 12
79439: PUSH
79440: LD_VAR 0 7
79444: ARRAY
79445: PUSH
79446: LD_INT 2
79448: ARRAY
79449: PPUSH
79450: CALL_OW 488
79454: NOT
79455: PUSH
79456: LD_VAR 0 12
79460: PUSH
79461: LD_VAR 0 7
79465: ARRAY
79466: PUSH
79467: LD_INT 1
79469: ARRAY
79470: PPUSH
79471: LD_VAR 0 12
79475: PUSH
79476: LD_VAR 0 7
79480: ARRAY
79481: PUSH
79482: LD_INT 2
79484: ARRAY
79485: PPUSH
79486: CALL_OW 428
79490: PUSH
79491: LD_INT 0
79493: GREATER
79494: OR
79495: PUSH
79496: LD_VAR 0 12
79500: PUSH
79501: LD_VAR 0 7
79505: ARRAY
79506: PUSH
79507: LD_INT 1
79509: ARRAY
79510: PPUSH
79511: LD_VAR 0 12
79515: PUSH
79516: LD_VAR 0 7
79520: ARRAY
79521: PUSH
79522: LD_INT 2
79524: ARRAY
79525: PPUSH
79526: CALL_OW 351
79530: OR
79531: IFFALSE 79537
// exit ;
79533: POP
79534: POP
79535: GO 79844
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79537: LD_ADDR_VAR 0 8
79541: PUSH
79542: LD_VAR 0 12
79546: PUSH
79547: LD_VAR 0 7
79551: ARRAY
79552: PUSH
79553: LD_INT 1
79555: ARRAY
79556: PPUSH
79557: LD_VAR 0 12
79561: PUSH
79562: LD_VAR 0 7
79566: ARRAY
79567: PUSH
79568: LD_INT 2
79570: ARRAY
79571: PPUSH
79572: CALL_OW 546
79576: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79577: LD_VAR 0 8
79581: PUSH
79582: LD_INT 1
79584: ARRAY
79585: PUSH
79586: LD_VAR 0 8
79590: PUSH
79591: LD_INT 2
79593: ARRAY
79594: PUSH
79595: LD_VAR 0 13
79599: PUSH
79600: LD_INT 2
79602: PLUS
79603: GREATER
79604: OR
79605: PUSH
79606: LD_VAR 0 8
79610: PUSH
79611: LD_INT 2
79613: ARRAY
79614: PUSH
79615: LD_VAR 0 13
79619: PUSH
79620: LD_INT 2
79622: MINUS
79623: LESS
79624: OR
79625: PUSH
79626: LD_VAR 0 8
79630: PUSH
79631: LD_INT 3
79633: ARRAY
79634: PUSH
79635: LD_INT 0
79637: PUSH
79638: LD_INT 8
79640: PUSH
79641: LD_INT 9
79643: PUSH
79644: LD_INT 10
79646: PUSH
79647: LD_INT 11
79649: PUSH
79650: LD_INT 12
79652: PUSH
79653: LD_INT 13
79655: PUSH
79656: LD_INT 16
79658: PUSH
79659: LD_INT 17
79661: PUSH
79662: LD_INT 18
79664: PUSH
79665: LD_INT 19
79667: PUSH
79668: LD_INT 20
79670: PUSH
79671: LD_INT 21
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: LIST
79684: LIST
79685: LIST
79686: LIST
79687: LIST
79688: IN
79689: NOT
79690: OR
79691: PUSH
79692: LD_VAR 0 8
79696: PUSH
79697: LD_INT 5
79699: ARRAY
79700: NOT
79701: OR
79702: PUSH
79703: LD_VAR 0 8
79707: PUSH
79708: LD_INT 6
79710: ARRAY
79711: PUSH
79712: LD_INT 1
79714: PUSH
79715: LD_INT 2
79717: PUSH
79718: LD_INT 7
79720: PUSH
79721: LD_INT 9
79723: PUSH
79724: LD_INT 10
79726: PUSH
79727: LD_INT 11
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: LIST
79734: LIST
79735: LIST
79736: LIST
79737: IN
79738: NOT
79739: OR
79740: IFFALSE 79746
// exit ;
79742: POP
79743: POP
79744: GO 79844
// end ;
79746: GO 79417
79748: POP
79749: POP
// side := GetSide ( depot ) ;
79750: LD_ADDR_VAR 0 9
79754: PUSH
79755: LD_VAR 0 1
79759: PPUSH
79760: CALL_OW 255
79764: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79765: LD_VAR 0 9
79769: PPUSH
79770: LD_VAR 0 3
79774: PPUSH
79775: LD_VAR 0 4
79779: PPUSH
79780: LD_INT 20
79782: PPUSH
79783: CALL 72498 0 4
79787: PUSH
79788: LD_INT 4
79790: ARRAY
79791: IFFALSE 79795
// exit ;
79793: GO 79844
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79795: LD_VAR 0 2
79799: PUSH
79800: LD_INT 29
79802: PUSH
79803: LD_INT 30
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: IN
79810: PUSH
79811: LD_VAR 0 3
79815: PPUSH
79816: LD_VAR 0 4
79820: PPUSH
79821: LD_VAR 0 9
79825: PPUSH
79826: CALL_OW 440
79830: NOT
79831: AND
79832: IFFALSE 79836
// exit ;
79834: GO 79844
// result := true ;
79836: LD_ADDR_VAR 0 6
79840: PUSH
79841: LD_INT 1
79843: ST_TO_ADDR
// end ;
79844: LD_VAR 0 6
79848: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79849: LD_INT 0
79851: PPUSH
79852: PPUSH
79853: PPUSH
79854: PPUSH
79855: PPUSH
79856: PPUSH
79857: PPUSH
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
79878: PPUSH
79879: PPUSH
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
79886: PPUSH
79887: PPUSH
79888: PPUSH
79889: PPUSH
79890: PPUSH
79891: PPUSH
79892: PPUSH
79893: PPUSH
79894: PPUSH
79895: PPUSH
79896: PPUSH
79897: PPUSH
79898: PPUSH
79899: PPUSH
79900: PPUSH
79901: PPUSH
79902: PPUSH
79903: PPUSH
79904: PPUSH
79905: PPUSH
79906: PPUSH
79907: PPUSH
79908: PPUSH
// result = [ ] ;
79909: LD_ADDR_VAR 0 7
79913: PUSH
79914: EMPTY
79915: ST_TO_ADDR
// temp_list = [ ] ;
79916: LD_ADDR_VAR 0 9
79920: PUSH
79921: EMPTY
79922: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79923: LD_VAR 0 4
79927: PUSH
79928: LD_INT 0
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: LD_INT 3
79939: PUSH
79940: LD_INT 4
79942: PUSH
79943: LD_INT 5
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: IN
79954: NOT
79955: PUSH
79956: LD_VAR 0 1
79960: PUSH
79961: LD_INT 0
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: IN
79971: PUSH
79972: LD_VAR 0 5
79976: PUSH
79977: LD_INT 1
79979: PUSH
79980: LD_INT 2
79982: PUSH
79983: LD_INT 3
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: LIST
79990: IN
79991: NOT
79992: AND
79993: OR
79994: IFFALSE 79998
// exit ;
79996: GO 98389
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79998: LD_VAR 0 1
80002: PUSH
80003: LD_INT 6
80005: PUSH
80006: LD_INT 7
80008: PUSH
80009: LD_INT 8
80011: PUSH
80012: LD_INT 13
80014: PUSH
80015: LD_INT 12
80017: PUSH
80018: LD_INT 15
80020: PUSH
80021: LD_INT 11
80023: PUSH
80024: LD_INT 14
80026: PUSH
80027: LD_INT 10
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: IN
80041: IFFALSE 80051
// btype = b_lab ;
80043: LD_ADDR_VAR 0 1
80047: PUSH
80048: LD_INT 6
80050: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80051: LD_VAR 0 6
80055: PUSH
80056: LD_INT 0
80058: PUSH
80059: LD_INT 1
80061: PUSH
80062: LD_INT 2
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: LIST
80069: IN
80070: NOT
80071: PUSH
80072: LD_VAR 0 1
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 1
80082: PUSH
80083: LD_INT 2
80085: PUSH
80086: LD_INT 3
80088: PUSH
80089: LD_INT 6
80091: PUSH
80092: LD_INT 36
80094: PUSH
80095: LD_INT 4
80097: PUSH
80098: LD_INT 5
80100: PUSH
80101: LD_INT 31
80103: PUSH
80104: LD_INT 32
80106: PUSH
80107: LD_INT 33
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: IN
80123: NOT
80124: PUSH
80125: LD_VAR 0 6
80129: PUSH
80130: LD_INT 1
80132: EQUAL
80133: AND
80134: OR
80135: PUSH
80136: LD_VAR 0 1
80140: PUSH
80141: LD_INT 2
80143: PUSH
80144: LD_INT 3
80146: PUSH
80147: EMPTY
80148: LIST
80149: LIST
80150: IN
80151: NOT
80152: PUSH
80153: LD_VAR 0 6
80157: PUSH
80158: LD_INT 2
80160: EQUAL
80161: AND
80162: OR
80163: IFFALSE 80173
// mode = 0 ;
80165: LD_ADDR_VAR 0 6
80169: PUSH
80170: LD_INT 0
80172: ST_TO_ADDR
// case mode of 0 :
80173: LD_VAR 0 6
80177: PUSH
80178: LD_INT 0
80180: DOUBLE
80181: EQUAL
80182: IFTRUE 80186
80184: GO 91639
80186: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80187: LD_ADDR_VAR 0 11
80191: PUSH
80192: LD_INT 0
80194: PUSH
80195: LD_INT 0
80197: PUSH
80198: EMPTY
80199: LIST
80200: LIST
80201: PUSH
80202: LD_INT 0
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 1
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 1
80225: PUSH
80226: LD_INT 1
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 0
80235: PUSH
80236: LD_INT 1
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: PUSH
80254: LD_INT 1
80256: NEG
80257: PUSH
80258: LD_INT 1
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 1
80268: NEG
80269: PUSH
80270: LD_INT 2
80272: NEG
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: LD_INT 2
80283: NEG
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: LD_INT 1
80294: NEG
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: PUSH
80300: LD_INT 1
80302: PUSH
80303: LD_INT 2
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PUSH
80310: LD_INT 0
80312: PUSH
80313: LD_INT 2
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 1
80322: NEG
80323: PUSH
80324: LD_INT 1
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 1
80333: PUSH
80334: LD_INT 3
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 0
80343: PUSH
80344: LD_INT 3
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 1
80353: NEG
80354: PUSH
80355: LD_INT 2
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80380: LD_ADDR_VAR 0 12
80384: PUSH
80385: LD_INT 0
80387: PUSH
80388: LD_INT 0
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 0
80397: PUSH
80398: LD_INT 1
80400: NEG
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: LD_INT 0
80411: PUSH
80412: EMPTY
80413: LIST
80414: LIST
80415: PUSH
80416: LD_INT 1
80418: PUSH
80419: LD_INT 1
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: LD_INT 1
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: NEG
80439: PUSH
80440: LD_INT 0
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 1
80449: NEG
80450: PUSH
80451: LD_INT 1
80453: NEG
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 1
80461: PUSH
80462: LD_INT 1
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 2
80472: PUSH
80473: LD_INT 0
80475: PUSH
80476: EMPTY
80477: LIST
80478: LIST
80479: PUSH
80480: LD_INT 2
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 1
80492: NEG
80493: PUSH
80494: LD_INT 1
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 2
80503: NEG
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 2
80514: NEG
80515: PUSH
80516: LD_INT 1
80518: NEG
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 2
80526: NEG
80527: PUSH
80528: LD_INT 1
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 3
80537: NEG
80538: PUSH
80539: LD_INT 0
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 3
80548: NEG
80549: PUSH
80550: LD_INT 1
80552: NEG
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: EMPTY
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80576: LD_ADDR_VAR 0 13
80580: PUSH
80581: LD_INT 0
80583: PUSH
80584: LD_INT 0
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 0
80593: PUSH
80594: LD_INT 1
80596: NEG
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 1
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: EMPTY
80619: LIST
80620: LIST
80621: PUSH
80622: LD_INT 0
80624: PUSH
80625: LD_INT 1
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: NEG
80635: PUSH
80636: LD_INT 0
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 1
80645: NEG
80646: PUSH
80647: LD_INT 1
80649: NEG
80650: PUSH
80651: EMPTY
80652: LIST
80653: LIST
80654: PUSH
80655: LD_INT 1
80657: NEG
80658: PUSH
80659: LD_INT 2
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 1
80689: PUSH
80690: LD_INT 2
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 2
80699: NEG
80700: PUSH
80701: LD_INT 1
80703: NEG
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 2
80711: NEG
80712: PUSH
80713: LD_INT 2
80715: NEG
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 2
80723: NEG
80724: PUSH
80725: LD_INT 3
80727: NEG
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 3
80735: NEG
80736: PUSH
80737: LD_INT 2
80739: NEG
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 3
80747: NEG
80748: PUSH
80749: LD_INT 3
80751: NEG
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: EMPTY
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80775: LD_ADDR_VAR 0 14
80779: PUSH
80780: LD_INT 0
80782: PUSH
80783: LD_INT 0
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PUSH
80790: LD_INT 0
80792: PUSH
80793: LD_INT 1
80795: NEG
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: PUSH
80801: LD_INT 1
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 1
80813: PUSH
80814: LD_INT 1
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 0
80823: PUSH
80824: LD_INT 1
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: LD_INT 0
80837: PUSH
80838: EMPTY
80839: LIST
80840: LIST
80841: PUSH
80842: LD_INT 1
80844: NEG
80845: PUSH
80846: LD_INT 1
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 1
80856: NEG
80857: PUSH
80858: LD_INT 2
80860: NEG
80861: PUSH
80862: EMPTY
80863: LIST
80864: LIST
80865: PUSH
80866: LD_INT 0
80868: PUSH
80869: LD_INT 2
80871: NEG
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: PUSH
80880: LD_INT 1
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: PUSH
80891: LD_INT 2
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 0
80900: PUSH
80901: LD_INT 2
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: LD_INT 1
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 1
80921: NEG
80922: PUSH
80923: LD_INT 3
80925: NEG
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: PUSH
80931: LD_INT 0
80933: PUSH
80934: LD_INT 3
80936: NEG
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: LD_INT 2
80947: NEG
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80971: LD_ADDR_VAR 0 15
80975: PUSH
80976: LD_INT 0
80978: PUSH
80979: LD_INT 0
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 0
80988: PUSH
80989: LD_INT 1
80991: NEG
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: PUSH
80997: LD_INT 1
80999: PUSH
81000: LD_INT 0
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: PUSH
81007: LD_INT 1
81009: PUSH
81010: LD_INT 1
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 0
81019: PUSH
81020: LD_INT 1
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 1
81029: NEG
81030: PUSH
81031: LD_INT 0
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 1
81040: NEG
81041: PUSH
81042: LD_INT 1
81044: NEG
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: PUSH
81053: LD_INT 1
81055: NEG
81056: PUSH
81057: EMPTY
81058: LIST
81059: LIST
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: LD_INT 0
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 2
81073: PUSH
81074: LD_INT 1
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 1
81083: NEG
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 2
81094: NEG
81095: PUSH
81096: LD_INT 0
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 2
81105: NEG
81106: PUSH
81107: LD_INT 1
81109: NEG
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PUSH
81115: LD_INT 2
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 3
81128: PUSH
81129: LD_INT 0
81131: PUSH
81132: EMPTY
81133: LIST
81134: LIST
81135: PUSH
81136: LD_INT 3
81138: PUSH
81139: LD_INT 1
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: EMPTY
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81164: LD_ADDR_VAR 0 16
81168: PUSH
81169: LD_INT 0
81171: PUSH
81172: LD_INT 0
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 0
81181: PUSH
81182: LD_INT 1
81184: NEG
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: LD_INT 0
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: LD_INT 1
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 1
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: LD_INT 0
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: NEG
81234: PUSH
81235: LD_INT 1
81237: NEG
81238: PUSH
81239: EMPTY
81240: LIST
81241: LIST
81242: PUSH
81243: LD_INT 1
81245: NEG
81246: PUSH
81247: LD_INT 2
81249: NEG
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PUSH
81255: LD_INT 2
81257: PUSH
81258: LD_INT 1
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 2
81267: PUSH
81268: LD_INT 2
81270: PUSH
81271: EMPTY
81272: LIST
81273: LIST
81274: PUSH
81275: LD_INT 1
81277: PUSH
81278: LD_INT 2
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 2
81287: NEG
81288: PUSH
81289: LD_INT 1
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 2
81299: NEG
81300: PUSH
81301: LD_INT 2
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 3
81311: PUSH
81312: LD_INT 2
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 3
81321: PUSH
81322: LD_INT 3
81324: PUSH
81325: EMPTY
81326: LIST
81327: LIST
81328: PUSH
81329: LD_INT 2
81331: PUSH
81332: LD_INT 3
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PUSH
81339: EMPTY
81340: LIST
81341: LIST
81342: LIST
81343: LIST
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81357: LD_ADDR_VAR 0 17
81361: PUSH
81362: LD_INT 0
81364: PUSH
81365: LD_INT 0
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: LD_INT 1
81377: NEG
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 1
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 1
81395: PUSH
81396: LD_INT 1
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 0
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 1
81415: NEG
81416: PUSH
81417: LD_INT 0
81419: PUSH
81420: EMPTY
81421: LIST
81422: LIST
81423: PUSH
81424: LD_INT 1
81426: NEG
81427: PUSH
81428: LD_INT 1
81430: NEG
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: NEG
81439: PUSH
81440: LD_INT 2
81442: NEG
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 0
81450: PUSH
81451: LD_INT 2
81453: NEG
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: PUSH
81459: LD_INT 1
81461: PUSH
81462: LD_INT 1
81464: NEG
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 2
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 2
81482: PUSH
81483: LD_INT 1
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 2
81492: PUSH
81493: LD_INT 2
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 1
81502: PUSH
81503: LD_INT 2
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 2
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: NEG
81523: PUSH
81524: LD_INT 1
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 2
81533: NEG
81534: PUSH
81535: LD_INT 0
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 2
81544: NEG
81545: PUSH
81546: LD_INT 1
81548: NEG
81549: PUSH
81550: EMPTY
81551: LIST
81552: LIST
81553: PUSH
81554: LD_INT 2
81556: NEG
81557: PUSH
81558: LD_INT 2
81560: NEG
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: LIST
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: LIST
81586: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81587: LD_ADDR_VAR 0 18
81591: PUSH
81592: LD_INT 0
81594: PUSH
81595: LD_INT 0
81597: PUSH
81598: EMPTY
81599: LIST
81600: LIST
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: LD_INT 1
81607: NEG
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: LD_INT 0
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 1
81625: PUSH
81626: LD_INT 1
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 0
81635: PUSH
81636: LD_INT 1
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 1
81656: NEG
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 1
81668: NEG
81669: PUSH
81670: LD_INT 2
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 0
81680: PUSH
81681: LD_INT 2
81683: NEG
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: LD_INT 1
81691: PUSH
81692: LD_INT 1
81694: NEG
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 2
81702: PUSH
81703: LD_INT 0
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: LD_INT 1
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 2
81722: PUSH
81723: LD_INT 2
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 1
81732: PUSH
81733: LD_INT 2
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: LD_INT 2
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 1
81752: NEG
81753: PUSH
81754: LD_INT 1
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 2
81763: NEG
81764: PUSH
81765: LD_INT 0
81767: PUSH
81768: EMPTY
81769: LIST
81770: LIST
81771: PUSH
81772: LD_INT 2
81774: NEG
81775: PUSH
81776: LD_INT 1
81778: NEG
81779: PUSH
81780: EMPTY
81781: LIST
81782: LIST
81783: PUSH
81784: LD_INT 2
81786: NEG
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: LIST
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81817: LD_ADDR_VAR 0 19
81821: PUSH
81822: LD_INT 0
81824: PUSH
81825: LD_INT 0
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: LD_INT 1
81837: NEG
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 1
81845: PUSH
81846: LD_INT 0
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 1
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: LD_INT 0
81865: PUSH
81866: LD_INT 1
81868: PUSH
81869: EMPTY
81870: LIST
81871: LIST
81872: PUSH
81873: LD_INT 1
81875: NEG
81876: PUSH
81877: LD_INT 0
81879: PUSH
81880: EMPTY
81881: LIST
81882: LIST
81883: PUSH
81884: LD_INT 1
81886: NEG
81887: PUSH
81888: LD_INT 1
81890: NEG
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: NEG
81899: PUSH
81900: LD_INT 2
81902: NEG
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 0
81910: PUSH
81911: LD_INT 2
81913: NEG
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 1
81921: PUSH
81922: LD_INT 1
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 2
81932: PUSH
81933: LD_INT 0
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: LD_INT 1
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: LD_INT 2
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: LD_INT 2
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 0
81972: PUSH
81973: LD_INT 2
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: LD_INT 1
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: LD_INT 0
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 2
82004: NEG
82005: PUSH
82006: LD_INT 1
82008: NEG
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PUSH
82014: LD_INT 2
82016: NEG
82017: PUSH
82018: LD_INT 2
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82047: LD_ADDR_VAR 0 20
82051: PUSH
82052: LD_INT 0
82054: PUSH
82055: LD_INT 0
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: LD_INT 1
82067: NEG
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: PUSH
82086: LD_INT 1
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 0
82095: PUSH
82096: LD_INT 1
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PUSH
82114: LD_INT 1
82116: NEG
82117: PUSH
82118: LD_INT 1
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: NEG
82129: PUSH
82130: LD_INT 2
82132: NEG
82133: PUSH
82134: EMPTY
82135: LIST
82136: LIST
82137: PUSH
82138: LD_INT 0
82140: PUSH
82141: LD_INT 2
82143: NEG
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: LD_INT 1
82154: NEG
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 2
82162: PUSH
82163: LD_INT 0
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 2
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: PUSH
82183: LD_INT 2
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 1
82192: PUSH
82193: LD_INT 2
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 0
82202: PUSH
82203: LD_INT 2
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 1
82212: NEG
82213: PUSH
82214: LD_INT 1
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 2
82223: NEG
82224: PUSH
82225: LD_INT 0
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 2
82234: NEG
82235: PUSH
82236: LD_INT 1
82238: NEG
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 2
82246: NEG
82247: PUSH
82248: LD_INT 2
82250: NEG
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: LIST
82262: LIST
82263: LIST
82264: LIST
82265: LIST
82266: LIST
82267: LIST
82268: LIST
82269: LIST
82270: LIST
82271: LIST
82272: LIST
82273: LIST
82274: LIST
82275: LIST
82276: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82277: LD_ADDR_VAR 0 21
82281: PUSH
82282: LD_INT 0
82284: PUSH
82285: LD_INT 0
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: LD_INT 1
82297: NEG
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 1
82305: PUSH
82306: LD_INT 0
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: PUSH
82316: LD_INT 1
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: LD_INT 1
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: LD_INT 0
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 1
82346: NEG
82347: PUSH
82348: LD_INT 1
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 1
82358: NEG
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: EMPTY
82365: LIST
82366: LIST
82367: PUSH
82368: LD_INT 0
82370: PUSH
82371: LD_INT 2
82373: NEG
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 1
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 2
82392: PUSH
82393: LD_INT 0
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 2
82402: PUSH
82403: LD_INT 1
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 2
82412: PUSH
82413: LD_INT 2
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 1
82422: PUSH
82423: LD_INT 2
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 0
82432: PUSH
82433: LD_INT 2
82435: PUSH
82436: EMPTY
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 1
82442: NEG
82443: PUSH
82444: LD_INT 1
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 2
82453: NEG
82454: PUSH
82455: LD_INT 0
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 2
82464: NEG
82465: PUSH
82466: LD_INT 1
82468: NEG
82469: PUSH
82470: EMPTY
82471: LIST
82472: LIST
82473: PUSH
82474: LD_INT 2
82476: NEG
82477: PUSH
82478: LD_INT 2
82480: NEG
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: EMPTY
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: LIST
82503: LIST
82504: LIST
82505: LIST
82506: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82507: LD_ADDR_VAR 0 22
82511: PUSH
82512: LD_INT 0
82514: PUSH
82515: LD_INT 0
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: LD_INT 1
82527: NEG
82528: PUSH
82529: EMPTY
82530: LIST
82531: LIST
82532: PUSH
82533: LD_INT 1
82535: PUSH
82536: LD_INT 0
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 1
82545: PUSH
82546: LD_INT 1
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 0
82555: PUSH
82556: LD_INT 1
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: NEG
82566: PUSH
82567: LD_INT 0
82569: PUSH
82570: EMPTY
82571: LIST
82572: LIST
82573: PUSH
82574: LD_INT 1
82576: NEG
82577: PUSH
82578: LD_INT 1
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 1
82588: NEG
82589: PUSH
82590: LD_INT 2
82592: NEG
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 0
82600: PUSH
82601: LD_INT 2
82603: NEG
82604: PUSH
82605: EMPTY
82606: LIST
82607: LIST
82608: PUSH
82609: LD_INT 1
82611: PUSH
82612: LD_INT 1
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 2
82622: PUSH
82623: LD_INT 0
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 2
82632: PUSH
82633: LD_INT 1
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: LD_INT 2
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: LD_INT 2
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: LD_INT 2
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 1
82672: NEG
82673: PUSH
82674: LD_INT 1
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 2
82683: NEG
82684: PUSH
82685: LD_INT 0
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 2
82694: NEG
82695: PUSH
82696: LD_INT 1
82698: NEG
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PUSH
82704: LD_INT 2
82706: NEG
82707: PUSH
82708: LD_INT 2
82710: NEG
82711: PUSH
82712: EMPTY
82713: LIST
82714: LIST
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82737: LD_ADDR_VAR 0 23
82741: PUSH
82742: LD_INT 0
82744: PUSH
82745: LD_INT 0
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: LD_INT 1
82757: NEG
82758: PUSH
82759: EMPTY
82760: LIST
82761: LIST
82762: PUSH
82763: LD_INT 1
82765: PUSH
82766: LD_INT 0
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: PUSH
82773: LD_INT 1
82775: PUSH
82776: LD_INT 1
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: PUSH
82783: LD_INT 0
82785: PUSH
82786: LD_INT 1
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 1
82795: NEG
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 1
82806: NEG
82807: PUSH
82808: LD_INT 1
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: NEG
82819: PUSH
82820: LD_INT 2
82822: NEG
82823: PUSH
82824: EMPTY
82825: LIST
82826: LIST
82827: PUSH
82828: LD_INT 0
82830: PUSH
82831: LD_INT 2
82833: NEG
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 1
82841: PUSH
82842: LD_INT 1
82844: NEG
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: LD_INT 0
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 2
82862: PUSH
82863: LD_INT 1
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 2
82872: PUSH
82873: LD_INT 2
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: LD_INT 2
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 0
82892: PUSH
82893: LD_INT 2
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 1
82902: NEG
82903: PUSH
82904: LD_INT 1
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 2
82913: NEG
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 2
82924: NEG
82925: PUSH
82926: LD_INT 1
82928: NEG
82929: PUSH
82930: EMPTY
82931: LIST
82932: LIST
82933: PUSH
82934: LD_INT 2
82936: NEG
82937: PUSH
82938: LD_INT 2
82940: NEG
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 2
82948: NEG
82949: PUSH
82950: LD_INT 3
82952: NEG
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 1
82960: NEG
82961: PUSH
82962: LD_INT 3
82964: NEG
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 1
82972: PUSH
82973: LD_INT 2
82975: NEG
82976: PUSH
82977: EMPTY
82978: LIST
82979: LIST
82980: PUSH
82981: LD_INT 2
82983: PUSH
82984: LD_INT 1
82986: NEG
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83017: LD_ADDR_VAR 0 24
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: LD_INT 0
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 0
83034: PUSH
83035: LD_INT 1
83037: NEG
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 1
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 0
83065: PUSH
83066: LD_INT 1
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 1
83075: NEG
83076: PUSH
83077: LD_INT 0
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: LD_INT 1
83086: NEG
83087: PUSH
83088: LD_INT 1
83090: NEG
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 1
83098: NEG
83099: PUSH
83100: LD_INT 2
83102: NEG
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: PUSH
83108: LD_INT 0
83110: PUSH
83111: LD_INT 2
83113: NEG
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 1
83121: PUSH
83122: LD_INT 1
83124: NEG
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 2
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 2
83142: PUSH
83143: LD_INT 1
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: PUSH
83150: LD_INT 2
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: PUSH
83163: LD_INT 2
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: PUSH
83170: LD_INT 0
83172: PUSH
83173: LD_INT 2
83175: PUSH
83176: EMPTY
83177: LIST
83178: LIST
83179: PUSH
83180: LD_INT 1
83182: NEG
83183: PUSH
83184: LD_INT 1
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: NEG
83194: PUSH
83195: LD_INT 0
83197: PUSH
83198: EMPTY
83199: LIST
83200: LIST
83201: PUSH
83202: LD_INT 2
83204: NEG
83205: PUSH
83206: LD_INT 1
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: NEG
83217: PUSH
83218: LD_INT 2
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 1
83228: PUSH
83229: LD_INT 2
83231: NEG
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 2
83239: PUSH
83240: LD_INT 1
83242: NEG
83243: PUSH
83244: EMPTY
83245: LIST
83246: LIST
83247: PUSH
83248: LD_INT 3
83250: PUSH
83251: LD_INT 1
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PUSH
83258: LD_INT 3
83260: PUSH
83261: LD_INT 2
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83293: LD_ADDR_VAR 0 25
83297: PUSH
83298: LD_INT 0
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 0
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: LD_INT 0
83324: PUSH
83325: EMPTY
83326: LIST
83327: LIST
83328: PUSH
83329: LD_INT 1
83331: PUSH
83332: LD_INT 1
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: LD_INT 1
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 1
83351: NEG
83352: PUSH
83353: LD_INT 0
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 1
83362: NEG
83363: PUSH
83364: LD_INT 1
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 1
83374: NEG
83375: PUSH
83376: LD_INT 2
83378: NEG
83379: PUSH
83380: EMPTY
83381: LIST
83382: LIST
83383: PUSH
83384: LD_INT 0
83386: PUSH
83387: LD_INT 2
83389: NEG
83390: PUSH
83391: EMPTY
83392: LIST
83393: LIST
83394: PUSH
83395: LD_INT 1
83397: PUSH
83398: LD_INT 1
83400: NEG
83401: PUSH
83402: EMPTY
83403: LIST
83404: LIST
83405: PUSH
83406: LD_INT 2
83408: PUSH
83409: LD_INT 0
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: PUSH
83416: LD_INT 2
83418: PUSH
83419: LD_INT 1
83421: PUSH
83422: EMPTY
83423: LIST
83424: LIST
83425: PUSH
83426: LD_INT 2
83428: PUSH
83429: LD_INT 2
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: LD_INT 2
83441: PUSH
83442: EMPTY
83443: LIST
83444: LIST
83445: PUSH
83446: LD_INT 0
83448: PUSH
83449: LD_INT 2
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: PUSH
83456: LD_INT 1
83458: NEG
83459: PUSH
83460: LD_INT 1
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: LD_INT 0
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 2
83480: NEG
83481: PUSH
83482: LD_INT 1
83484: NEG
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 2
83492: NEG
83493: PUSH
83494: LD_INT 2
83496: NEG
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 3
83504: PUSH
83505: LD_INT 1
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: LD_INT 2
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: PUSH
83522: LD_INT 2
83524: PUSH
83525: LD_INT 3
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 1
83534: PUSH
83535: LD_INT 3
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83567: LD_ADDR_VAR 0 26
83571: PUSH
83572: LD_INT 0
83574: PUSH
83575: LD_INT 0
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: LD_INT 1
83587: NEG
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 1
83605: PUSH
83606: LD_INT 1
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 0
83615: PUSH
83616: LD_INT 1
83618: PUSH
83619: EMPTY
83620: LIST
83621: LIST
83622: PUSH
83623: LD_INT 1
83625: NEG
83626: PUSH
83627: LD_INT 0
83629: PUSH
83630: EMPTY
83631: LIST
83632: LIST
83633: PUSH
83634: LD_INT 1
83636: NEG
83637: PUSH
83638: LD_INT 1
83640: NEG
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: NEG
83649: PUSH
83650: LD_INT 2
83652: NEG
83653: PUSH
83654: EMPTY
83655: LIST
83656: LIST
83657: PUSH
83658: LD_INT 0
83660: PUSH
83661: LD_INT 2
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 1
83671: PUSH
83672: LD_INT 1
83674: NEG
83675: PUSH
83676: EMPTY
83677: LIST
83678: LIST
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: LD_INT 1
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: LD_INT 2
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 1
83712: PUSH
83713: LD_INT 2
83715: PUSH
83716: EMPTY
83717: LIST
83718: LIST
83719: PUSH
83720: LD_INT 0
83722: PUSH
83723: LD_INT 2
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PUSH
83730: LD_INT 1
83732: NEG
83733: PUSH
83734: LD_INT 1
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 0
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 2
83754: NEG
83755: PUSH
83756: LD_INT 1
83758: NEG
83759: PUSH
83760: EMPTY
83761: LIST
83762: LIST
83763: PUSH
83764: LD_INT 2
83766: NEG
83767: PUSH
83768: LD_INT 2
83770: NEG
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 2
83778: PUSH
83779: LD_INT 3
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 1
83788: PUSH
83789: LD_INT 3
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: PUSH
83796: LD_INT 1
83798: NEG
83799: PUSH
83800: LD_INT 2
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 2
83809: NEG
83810: PUSH
83811: LD_INT 1
83813: PUSH
83814: EMPTY
83815: LIST
83816: LIST
83817: PUSH
83818: EMPTY
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83843: LD_ADDR_VAR 0 27
83847: PUSH
83848: LD_INT 0
83850: PUSH
83851: LD_INT 0
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 1
83863: NEG
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: LD_INT 0
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: PUSH
83882: LD_INT 1
83884: PUSH
83885: EMPTY
83886: LIST
83887: LIST
83888: PUSH
83889: LD_INT 0
83891: PUSH
83892: LD_INT 1
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 0
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: PUSH
83910: LD_INT 1
83912: NEG
83913: PUSH
83914: LD_INT 1
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: NEG
83925: PUSH
83926: LD_INT 2
83928: NEG
83929: PUSH
83930: EMPTY
83931: LIST
83932: LIST
83933: PUSH
83934: LD_INT 0
83936: PUSH
83937: LD_INT 2
83939: NEG
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 1
83947: PUSH
83948: LD_INT 1
83950: NEG
83951: PUSH
83952: EMPTY
83953: LIST
83954: LIST
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: LD_INT 0
83961: PUSH
83962: EMPTY
83963: LIST
83964: LIST
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: LD_INT 1
83971: PUSH
83972: EMPTY
83973: LIST
83974: LIST
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: LD_INT 2
83981: PUSH
83982: EMPTY
83983: LIST
83984: LIST
83985: PUSH
83986: LD_INT 1
83988: PUSH
83989: LD_INT 2
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 0
83998: PUSH
83999: LD_INT 2
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 1
84008: NEG
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 0
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: PUSH
84028: LD_INT 2
84030: NEG
84031: PUSH
84032: LD_INT 1
84034: NEG
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: NEG
84043: PUSH
84044: LD_INT 2
84046: NEG
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 1
84054: NEG
84055: PUSH
84056: LD_INT 2
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: LD_INT 1
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 3
84076: NEG
84077: PUSH
84078: LD_INT 1
84080: NEG
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 3
84088: NEG
84089: PUSH
84090: LD_INT 2
84092: NEG
84093: PUSH
84094: EMPTY
84095: LIST
84096: LIST
84097: PUSH
84098: EMPTY
84099: LIST
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84123: LD_ADDR_VAR 0 28
84127: PUSH
84128: LD_INT 0
84130: PUSH
84131: LD_INT 0
84133: PUSH
84134: EMPTY
84135: LIST
84136: LIST
84137: PUSH
84138: LD_INT 0
84140: PUSH
84141: LD_INT 1
84143: NEG
84144: PUSH
84145: EMPTY
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 1
84151: PUSH
84152: LD_INT 0
84154: PUSH
84155: EMPTY
84156: LIST
84157: LIST
84158: PUSH
84159: LD_INT 1
84161: PUSH
84162: LD_INT 1
84164: PUSH
84165: EMPTY
84166: LIST
84167: LIST
84168: PUSH
84169: LD_INT 0
84171: PUSH
84172: LD_INT 1
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: LD_INT 0
84185: PUSH
84186: EMPTY
84187: LIST
84188: LIST
84189: PUSH
84190: LD_INT 1
84192: NEG
84193: PUSH
84194: LD_INT 1
84196: NEG
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 1
84204: NEG
84205: PUSH
84206: LD_INT 2
84208: NEG
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 0
84216: PUSH
84217: LD_INT 2
84219: NEG
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 1
84227: PUSH
84228: LD_INT 1
84230: NEG
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 2
84238: PUSH
84239: LD_INT 0
84241: PUSH
84242: EMPTY
84243: LIST
84244: LIST
84245: PUSH
84246: LD_INT 2
84248: PUSH
84249: LD_INT 1
84251: PUSH
84252: EMPTY
84253: LIST
84254: LIST
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: LD_INT 2
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 1
84268: PUSH
84269: LD_INT 2
84271: PUSH
84272: EMPTY
84273: LIST
84274: LIST
84275: PUSH
84276: LD_INT 0
84278: PUSH
84279: LD_INT 2
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_INT 1
84288: NEG
84289: PUSH
84290: LD_INT 1
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: LD_INT 0
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PUSH
84308: LD_INT 2
84310: NEG
84311: PUSH
84312: LD_INT 1
84314: NEG
84315: PUSH
84316: EMPTY
84317: LIST
84318: LIST
84319: PUSH
84320: LD_INT 2
84322: NEG
84323: PUSH
84324: LD_INT 2
84326: NEG
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 2
84334: NEG
84335: PUSH
84336: LD_INT 3
84338: NEG
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: PUSH
84344: LD_INT 1
84346: NEG
84347: PUSH
84348: LD_INT 3
84350: NEG
84351: PUSH
84352: EMPTY
84353: LIST
84354: LIST
84355: PUSH
84356: LD_INT 3
84358: NEG
84359: PUSH
84360: LD_INT 1
84362: NEG
84363: PUSH
84364: EMPTY
84365: LIST
84366: LIST
84367: PUSH
84368: LD_INT 3
84370: NEG
84371: PUSH
84372: LD_INT 2
84374: NEG
84375: PUSH
84376: EMPTY
84377: LIST
84378: LIST
84379: PUSH
84380: EMPTY
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: LIST
84398: LIST
84399: LIST
84400: LIST
84401: LIST
84402: LIST
84403: LIST
84404: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84405: LD_ADDR_VAR 0 29
84409: PUSH
84410: LD_INT 0
84412: PUSH
84413: LD_INT 0
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PUSH
84420: LD_INT 0
84422: PUSH
84423: LD_INT 1
84425: NEG
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: PUSH
84431: LD_INT 1
84433: PUSH
84434: LD_INT 0
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PUSH
84441: LD_INT 1
84443: PUSH
84444: LD_INT 1
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 0
84453: PUSH
84454: LD_INT 1
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: LD_INT 1
84463: NEG
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: PUSH
84472: LD_INT 1
84474: NEG
84475: PUSH
84476: LD_INT 1
84478: NEG
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 1
84486: NEG
84487: PUSH
84488: LD_INT 2
84490: NEG
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 0
84498: PUSH
84499: LD_INT 2
84501: NEG
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: PUSH
84507: LD_INT 1
84509: PUSH
84510: LD_INT 1
84512: NEG
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: LD_INT 0
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: PUSH
84528: LD_INT 2
84530: PUSH
84531: LD_INT 1
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 1
84540: PUSH
84541: LD_INT 2
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: LD_INT 2
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 1
84560: NEG
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: PUSH
84569: LD_INT 2
84571: NEG
84572: PUSH
84573: LD_INT 1
84575: NEG
84576: PUSH
84577: EMPTY
84578: LIST
84579: LIST
84580: PUSH
84581: LD_INT 2
84583: NEG
84584: PUSH
84585: LD_INT 2
84587: NEG
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: LD_INT 3
84599: NEG
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 2
84607: PUSH
84608: LD_INT 1
84610: NEG
84611: PUSH
84612: EMPTY
84613: LIST
84614: LIST
84615: PUSH
84616: LD_INT 3
84618: PUSH
84619: LD_INT 1
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: PUSH
84629: LD_INT 3
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 1
84638: NEG
84639: PUSH
84640: LD_INT 2
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 3
84649: NEG
84650: PUSH
84651: LD_INT 2
84653: NEG
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84684: LD_ADDR_VAR 0 30
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: LD_INT 0
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: LD_INT 1
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: LD_INT 1
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: NEG
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: NEG
84766: PUSH
84767: LD_INT 2
84769: NEG
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: PUSH
84775: LD_INT 0
84777: PUSH
84778: LD_INT 2
84780: NEG
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 1
84788: PUSH
84789: LD_INT 1
84791: NEG
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: LD_INT 0
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: LD_INT 1
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 2
84819: PUSH
84820: LD_INT 2
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 1
84829: PUSH
84830: LD_INT 2
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 1
84839: NEG
84840: PUSH
84841: LD_INT 1
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 2
84850: NEG
84851: PUSH
84852: LD_INT 0
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PUSH
84859: LD_INT 2
84861: NEG
84862: PUSH
84863: LD_INT 1
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 1
84873: NEG
84874: PUSH
84875: LD_INT 3
84877: NEG
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 1
84885: PUSH
84886: LD_INT 2
84888: NEG
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 3
84896: PUSH
84897: LD_INT 2
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 2
84906: PUSH
84907: LD_INT 3
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 2
84916: NEG
84917: PUSH
84918: LD_INT 1
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PUSH
84925: LD_INT 3
84927: NEG
84928: PUSH
84929: LD_INT 1
84931: NEG
84932: PUSH
84933: EMPTY
84934: LIST
84935: LIST
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84962: LD_ADDR_VAR 0 31
84966: PUSH
84967: LD_INT 0
84969: PUSH
84970: LD_INT 0
84972: PUSH
84973: EMPTY
84974: LIST
84975: LIST
84976: PUSH
84977: LD_INT 0
84979: PUSH
84980: LD_INT 1
84982: NEG
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PUSH
84998: LD_INT 1
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 0
85010: PUSH
85011: LD_INT 1
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: LD_INT 0
85024: PUSH
85025: EMPTY
85026: LIST
85027: LIST
85028: PUSH
85029: LD_INT 1
85031: NEG
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 1
85043: NEG
85044: PUSH
85045: LD_INT 2
85047: NEG
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 1
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 2
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 2
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 2
85086: PUSH
85087: LD_INT 2
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 1
85096: PUSH
85097: LD_INT 2
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 0
85106: PUSH
85107: LD_INT 2
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 1
85116: NEG
85117: PUSH
85118: LD_INT 1
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_INT 2
85127: NEG
85128: PUSH
85129: LD_INT 1
85131: NEG
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 2
85139: NEG
85140: PUSH
85141: LD_INT 2
85143: NEG
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 2
85151: NEG
85152: PUSH
85153: LD_INT 3
85155: NEG
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 2
85163: PUSH
85164: LD_INT 1
85166: NEG
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 3
85174: PUSH
85175: LD_INT 1
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: LD_INT 3
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 1
85194: NEG
85195: PUSH
85196: LD_INT 2
85198: PUSH
85199: EMPTY
85200: LIST
85201: LIST
85202: PUSH
85203: LD_INT 3
85205: NEG
85206: PUSH
85207: LD_INT 2
85209: NEG
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85240: LD_ADDR_VAR 0 32
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: LD_INT 0
85250: PUSH
85251: EMPTY
85252: LIST
85253: LIST
85254: PUSH
85255: LD_INT 0
85257: PUSH
85258: LD_INT 1
85260: NEG
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: EMPTY
85283: LIST
85284: LIST
85285: PUSH
85286: LD_INT 0
85288: PUSH
85289: LD_INT 1
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 0
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 1
85309: NEG
85310: PUSH
85311: LD_INT 1
85313: NEG
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: NEG
85322: PUSH
85323: LD_INT 2
85325: NEG
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 0
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: LD_INT 1
85347: NEG
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 2
85355: PUSH
85356: LD_INT 1
85358: PUSH
85359: EMPTY
85360: LIST
85361: LIST
85362: PUSH
85363: LD_INT 2
85365: PUSH
85366: LD_INT 2
85368: PUSH
85369: EMPTY
85370: LIST
85371: LIST
85372: PUSH
85373: LD_INT 1
85375: PUSH
85376: LD_INT 2
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: PUSH
85383: LD_INT 0
85385: PUSH
85386: LD_INT 2
85388: PUSH
85389: EMPTY
85390: LIST
85391: LIST
85392: PUSH
85393: LD_INT 1
85395: NEG
85396: PUSH
85397: LD_INT 1
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PUSH
85404: LD_INT 2
85406: NEG
85407: PUSH
85408: LD_INT 0
85410: PUSH
85411: EMPTY
85412: LIST
85413: LIST
85414: PUSH
85415: LD_INT 2
85417: NEG
85418: PUSH
85419: LD_INT 1
85421: NEG
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 1
85429: NEG
85430: PUSH
85431: LD_INT 3
85433: NEG
85434: PUSH
85435: EMPTY
85436: LIST
85437: LIST
85438: PUSH
85439: LD_INT 1
85441: PUSH
85442: LD_INT 2
85444: NEG
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 3
85452: PUSH
85453: LD_INT 2
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 2
85462: PUSH
85463: LD_INT 3
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: LD_INT 2
85472: NEG
85473: PUSH
85474: LD_INT 1
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: PUSH
85481: LD_INT 3
85483: NEG
85484: PUSH
85485: LD_INT 1
85487: NEG
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: EMPTY
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85518: LD_ADDR_VAR 0 33
85522: PUSH
85523: LD_INT 0
85525: PUSH
85526: LD_INT 0
85528: PUSH
85529: EMPTY
85530: LIST
85531: LIST
85532: PUSH
85533: LD_INT 0
85535: PUSH
85536: LD_INT 1
85538: NEG
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: LD_INT 0
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PUSH
85554: LD_INT 1
85556: PUSH
85557: LD_INT 1
85559: PUSH
85560: EMPTY
85561: LIST
85562: LIST
85563: PUSH
85564: LD_INT 0
85566: PUSH
85567: LD_INT 1
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: NEG
85577: PUSH
85578: LD_INT 0
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: LD_INT 1
85587: NEG
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 1
85599: NEG
85600: PUSH
85601: LD_INT 2
85603: NEG
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: PUSH
85612: LD_INT 1
85614: NEG
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: LD_INT 0
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: LD_INT 1
85635: PUSH
85636: EMPTY
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: LD_INT 2
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: PUSH
85650: LD_INT 0
85652: PUSH
85653: LD_INT 2
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 1
85662: NEG
85663: PUSH
85664: LD_INT 1
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: NEG
85674: PUSH
85675: LD_INT 0
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: PUSH
85682: LD_INT 2
85684: NEG
85685: PUSH
85686: LD_INT 1
85688: NEG
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: PUSH
85694: LD_INT 2
85696: NEG
85697: PUSH
85698: LD_INT 2
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 2
85708: NEG
85709: PUSH
85710: LD_INT 3
85712: NEG
85713: PUSH
85714: EMPTY
85715: LIST
85716: LIST
85717: PUSH
85718: LD_INT 2
85720: PUSH
85721: LD_INT 1
85723: NEG
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: PUSH
85729: LD_INT 3
85731: PUSH
85732: LD_INT 1
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 1
85741: PUSH
85742: LD_INT 3
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 1
85751: NEG
85752: PUSH
85753: LD_INT 2
85755: PUSH
85756: EMPTY
85757: LIST
85758: LIST
85759: PUSH
85760: LD_INT 3
85762: NEG
85763: PUSH
85764: LD_INT 2
85766: NEG
85767: PUSH
85768: EMPTY
85769: LIST
85770: LIST
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: LIST
85783: LIST
85784: LIST
85785: LIST
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: LIST
85796: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85797: LD_ADDR_VAR 0 34
85801: PUSH
85802: LD_INT 0
85804: PUSH
85805: LD_INT 0
85807: PUSH
85808: EMPTY
85809: LIST
85810: LIST
85811: PUSH
85812: LD_INT 0
85814: PUSH
85815: LD_INT 1
85817: NEG
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 1
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: LD_INT 1
85835: PUSH
85836: LD_INT 1
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: LD_INT 0
85845: PUSH
85846: LD_INT 1
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: EMPTY
85861: LIST
85862: LIST
85863: PUSH
85864: LD_INT 1
85866: NEG
85867: PUSH
85868: LD_INT 1
85870: NEG
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: LD_INT 1
85878: NEG
85879: PUSH
85880: LD_INT 2
85882: NEG
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 0
85890: PUSH
85891: LD_INT 2
85893: NEG
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: LD_INT 1
85901: PUSH
85902: LD_INT 1
85904: NEG
85905: PUSH
85906: EMPTY
85907: LIST
85908: LIST
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 2
85922: PUSH
85923: LD_INT 2
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 1
85932: PUSH
85933: LD_INT 2
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_INT 1
85942: NEG
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 2
85953: NEG
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 2
85964: NEG
85965: PUSH
85966: LD_INT 1
85968: NEG
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 2
85976: NEG
85977: PUSH
85978: LD_INT 2
85980: NEG
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 1
85988: NEG
85989: PUSH
85990: LD_INT 3
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: PUSH
86001: LD_INT 2
86003: NEG
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: LD_INT 3
86011: PUSH
86012: LD_INT 2
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: LD_INT 2
86021: PUSH
86022: LD_INT 3
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: LD_INT 2
86031: NEG
86032: PUSH
86033: LD_INT 1
86035: PUSH
86036: EMPTY
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 3
86042: NEG
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: LIST
86056: LIST
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86077: LD_ADDR_VAR 0 35
86081: PUSH
86082: LD_INT 0
86084: PUSH
86085: LD_INT 0
86087: PUSH
86088: EMPTY
86089: LIST
86090: LIST
86091: PUSH
86092: LD_INT 0
86094: PUSH
86095: LD_INT 1
86097: NEG
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: LD_INT 0
86108: PUSH
86109: EMPTY
86110: LIST
86111: LIST
86112: PUSH
86113: LD_INT 1
86115: PUSH
86116: LD_INT 1
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PUSH
86123: LD_INT 0
86125: PUSH
86126: LD_INT 1
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 1
86135: NEG
86136: PUSH
86137: LD_INT 0
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PUSH
86144: LD_INT 1
86146: NEG
86147: PUSH
86148: LD_INT 1
86150: NEG
86151: PUSH
86152: EMPTY
86153: LIST
86154: LIST
86155: PUSH
86156: LD_INT 2
86158: PUSH
86159: LD_INT 1
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 2
86168: NEG
86169: PUSH
86170: LD_INT 1
86172: NEG
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86189: LD_ADDR_VAR 0 36
86193: PUSH
86194: LD_INT 0
86196: PUSH
86197: LD_INT 0
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 0
86206: PUSH
86207: LD_INT 1
86209: NEG
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: PUSH
86215: LD_INT 1
86217: PUSH
86218: LD_INT 0
86220: PUSH
86221: EMPTY
86222: LIST
86223: LIST
86224: PUSH
86225: LD_INT 1
86227: PUSH
86228: LD_INT 1
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 0
86237: PUSH
86238: LD_INT 1
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 0
86251: PUSH
86252: EMPTY
86253: LIST
86254: LIST
86255: PUSH
86256: LD_INT 1
86258: NEG
86259: PUSH
86260: LD_INT 1
86262: NEG
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 1
86270: NEG
86271: PUSH
86272: LD_INT 2
86274: NEG
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 2
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: LIST
86299: LIST
86300: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86301: LD_ADDR_VAR 0 37
86305: PUSH
86306: LD_INT 0
86308: PUSH
86309: LD_INT 0
86311: PUSH
86312: EMPTY
86313: LIST
86314: LIST
86315: PUSH
86316: LD_INT 0
86318: PUSH
86319: LD_INT 1
86321: NEG
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 1
86329: PUSH
86330: LD_INT 0
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 1
86339: PUSH
86340: LD_INT 1
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 0
86349: PUSH
86350: LD_INT 1
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: NEG
86360: PUSH
86361: LD_INT 0
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: LD_INT 1
86374: NEG
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PUSH
86380: LD_INT 1
86382: PUSH
86383: LD_INT 1
86385: NEG
86386: PUSH
86387: EMPTY
86388: LIST
86389: LIST
86390: PUSH
86391: LD_INT 1
86393: NEG
86394: PUSH
86395: LD_INT 1
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86413: LD_ADDR_VAR 0 38
86417: PUSH
86418: LD_INT 0
86420: PUSH
86421: LD_INT 0
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 0
86430: PUSH
86431: LD_INT 1
86433: NEG
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 1
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: EMPTY
86446: LIST
86447: LIST
86448: PUSH
86449: LD_INT 1
86451: PUSH
86452: LD_INT 1
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PUSH
86459: LD_INT 0
86461: PUSH
86462: LD_INT 1
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 1
86471: NEG
86472: PUSH
86473: LD_INT 0
86475: PUSH
86476: EMPTY
86477: LIST
86478: LIST
86479: PUSH
86480: LD_INT 1
86482: NEG
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 2
86494: PUSH
86495: LD_INT 1
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: LD_INT 1
86508: NEG
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86525: LD_ADDR_VAR 0 39
86529: PUSH
86530: LD_INT 0
86532: PUSH
86533: LD_INT 0
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 1
86545: NEG
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 1
86553: PUSH
86554: LD_INT 0
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: PUSH
86564: LD_INT 1
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 0
86573: PUSH
86574: LD_INT 1
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: NEG
86584: PUSH
86585: LD_INT 0
86587: PUSH
86588: EMPTY
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 1
86594: NEG
86595: PUSH
86596: LD_INT 1
86598: NEG
86599: PUSH
86600: EMPTY
86601: LIST
86602: LIST
86603: PUSH
86604: LD_INT 1
86606: NEG
86607: PUSH
86608: LD_INT 2
86610: NEG
86611: PUSH
86612: EMPTY
86613: LIST
86614: LIST
86615: PUSH
86616: LD_INT 1
86618: PUSH
86619: LD_INT 2
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86637: LD_ADDR_VAR 0 40
86641: PUSH
86642: LD_INT 0
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: EMPTY
86649: LIST
86650: LIST
86651: PUSH
86652: LD_INT 0
86654: PUSH
86655: LD_INT 1
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 1
86665: PUSH
86666: LD_INT 0
86668: PUSH
86669: EMPTY
86670: LIST
86671: LIST
86672: PUSH
86673: LD_INT 1
86675: PUSH
86676: LD_INT 1
86678: PUSH
86679: EMPTY
86680: LIST
86681: LIST
86682: PUSH
86683: LD_INT 0
86685: PUSH
86686: LD_INT 1
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: NEG
86696: PUSH
86697: LD_INT 0
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 1
86706: NEG
86707: PUSH
86708: LD_INT 1
86710: NEG
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: LD_INT 1
86721: NEG
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 1
86729: NEG
86730: PUSH
86731: LD_INT 1
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: LIST
86742: LIST
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86749: LD_ADDR_VAR 0 41
86753: PUSH
86754: LD_INT 0
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: EMPTY
86761: LIST
86762: LIST
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: LD_INT 1
86769: NEG
86770: PUSH
86771: EMPTY
86772: LIST
86773: LIST
86774: PUSH
86775: LD_INT 1
86777: PUSH
86778: LD_INT 0
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: PUSH
86788: LD_INT 1
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: PUSH
86795: LD_INT 0
86797: PUSH
86798: LD_INT 1
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: LD_INT 0
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 1
86818: NEG
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 1
86830: NEG
86831: PUSH
86832: LD_INT 2
86834: NEG
86835: PUSH
86836: EMPTY
86837: LIST
86838: LIST
86839: PUSH
86840: LD_INT 1
86842: PUSH
86843: LD_INT 1
86845: NEG
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: LD_INT 2
86853: PUSH
86854: LD_INT 0
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: LD_INT 2
86863: PUSH
86864: LD_INT 1
86866: PUSH
86867: EMPTY
86868: LIST
86869: LIST
86870: PUSH
86871: LD_INT 2
86873: PUSH
86874: LD_INT 2
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: PUSH
86881: LD_INT 1
86883: PUSH
86884: LD_INT 2
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: PUSH
86891: LD_INT 1
86893: NEG
86894: PUSH
86895: LD_INT 1
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: LD_INT 0
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PUSH
86913: LD_INT 2
86915: NEG
86916: PUSH
86917: LD_INT 1
86919: NEG
86920: PUSH
86921: EMPTY
86922: LIST
86923: LIST
86924: PUSH
86925: LD_INT 2
86927: NEG
86928: PUSH
86929: LD_INT 2
86931: NEG
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 2
86939: NEG
86940: PUSH
86941: LD_INT 3
86943: NEG
86944: PUSH
86945: EMPTY
86946: LIST
86947: LIST
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: LD_INT 1
86954: NEG
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 3
86962: PUSH
86963: LD_INT 0
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 3
86972: PUSH
86973: LD_INT 1
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 3
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 3
86992: PUSH
86993: LD_INT 3
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 2
87002: PUSH
87003: LD_INT 3
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 2
87012: NEG
87013: PUSH
87014: LD_INT 1
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 3
87023: NEG
87024: PUSH
87025: LD_INT 0
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: PUSH
87032: LD_INT 3
87034: NEG
87035: PUSH
87036: LD_INT 1
87038: NEG
87039: PUSH
87040: EMPTY
87041: LIST
87042: LIST
87043: PUSH
87044: LD_INT 3
87046: NEG
87047: PUSH
87048: LD_INT 2
87050: NEG
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 3
87058: NEG
87059: PUSH
87060: LD_INT 3
87062: NEG
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87099: LD_ADDR_VAR 0 42
87103: PUSH
87104: LD_INT 0
87106: PUSH
87107: LD_INT 0
87109: PUSH
87110: EMPTY
87111: LIST
87112: LIST
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 1
87119: NEG
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: LD_INT 0
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: PUSH
87138: LD_INT 1
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 0
87147: PUSH
87148: LD_INT 1
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 1
87157: NEG
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 1
87168: NEG
87169: PUSH
87170: LD_INT 1
87172: NEG
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: NEG
87181: PUSH
87182: LD_INT 2
87184: NEG
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 0
87192: PUSH
87193: LD_INT 2
87195: NEG
87196: PUSH
87197: EMPTY
87198: LIST
87199: LIST
87200: PUSH
87201: LD_INT 1
87203: PUSH
87204: LD_INT 1
87206: NEG
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: PUSH
87212: LD_INT 2
87214: PUSH
87215: LD_INT 1
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: PUSH
87222: LD_INT 2
87224: PUSH
87225: LD_INT 2
87227: PUSH
87228: EMPTY
87229: LIST
87230: LIST
87231: PUSH
87232: LD_INT 1
87234: PUSH
87235: LD_INT 2
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 0
87244: PUSH
87245: LD_INT 2
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 1
87254: NEG
87255: PUSH
87256: LD_INT 1
87258: PUSH
87259: EMPTY
87260: LIST
87261: LIST
87262: PUSH
87263: LD_INT 2
87265: NEG
87266: PUSH
87267: LD_INT 1
87269: NEG
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 2
87277: NEG
87278: PUSH
87279: LD_INT 2
87281: NEG
87282: PUSH
87283: EMPTY
87284: LIST
87285: LIST
87286: PUSH
87287: LD_INT 2
87289: NEG
87290: PUSH
87291: LD_INT 3
87293: NEG
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 1
87301: NEG
87302: PUSH
87303: LD_INT 3
87305: NEG
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: LD_INT 0
87313: PUSH
87314: LD_INT 3
87316: NEG
87317: PUSH
87318: EMPTY
87319: LIST
87320: LIST
87321: PUSH
87322: LD_INT 1
87324: PUSH
87325: LD_INT 2
87327: NEG
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 3
87335: PUSH
87336: LD_INT 2
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 3
87345: PUSH
87346: LD_INT 3
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 2
87355: PUSH
87356: LD_INT 3
87358: PUSH
87359: EMPTY
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 1
87365: PUSH
87366: LD_INT 3
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: LD_INT 0
87375: PUSH
87376: LD_INT 3
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 1
87385: NEG
87386: PUSH
87387: LD_INT 2
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 3
87396: NEG
87397: PUSH
87398: LD_INT 2
87400: NEG
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 3
87408: NEG
87409: PUSH
87410: LD_INT 3
87412: NEG
87413: PUSH
87414: EMPTY
87415: LIST
87416: LIST
87417: PUSH
87418: EMPTY
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: LIST
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: LIST
87433: LIST
87434: LIST
87435: LIST
87436: LIST
87437: LIST
87438: LIST
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87449: LD_ADDR_VAR 0 43
87453: PUSH
87454: LD_INT 0
87456: PUSH
87457: LD_INT 0
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: LD_INT 1
87469: NEG
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: LD_INT 0
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 1
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: LD_INT 1
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 1
87518: NEG
87519: PUSH
87520: LD_INT 1
87522: NEG
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: NEG
87531: PUSH
87532: LD_INT 2
87534: NEG
87535: PUSH
87536: EMPTY
87537: LIST
87538: LIST
87539: PUSH
87540: LD_INT 0
87542: PUSH
87543: LD_INT 2
87545: NEG
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 1
87553: PUSH
87554: LD_INT 1
87556: NEG
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: LD_INT 0
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: LD_INT 1
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 1
87584: PUSH
87585: LD_INT 2
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 0
87594: PUSH
87595: LD_INT 2
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 1
87604: NEG
87605: PUSH
87606: LD_INT 1
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 2
87615: NEG
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 2
87626: NEG
87627: PUSH
87628: LD_INT 1
87630: NEG
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 1
87638: NEG
87639: PUSH
87640: LD_INT 3
87642: NEG
87643: PUSH
87644: EMPTY
87645: LIST
87646: LIST
87647: PUSH
87648: LD_INT 0
87650: PUSH
87651: LD_INT 3
87653: NEG
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 1
87661: PUSH
87662: LD_INT 2
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 2
87672: PUSH
87673: LD_INT 1
87675: NEG
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 3
87683: PUSH
87684: LD_INT 0
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 3
87693: PUSH
87694: LD_INT 1
87696: PUSH
87697: EMPTY
87698: LIST
87699: LIST
87700: PUSH
87701: LD_INT 1
87703: PUSH
87704: LD_INT 3
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 0
87713: PUSH
87714: LD_INT 3
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 1
87723: NEG
87724: PUSH
87725: LD_INT 2
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PUSH
87732: LD_INT 2
87734: NEG
87735: PUSH
87736: LD_INT 1
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: LD_INT 3
87745: NEG
87746: PUSH
87747: LD_INT 0
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 3
87756: NEG
87757: PUSH
87758: LD_INT 1
87760: NEG
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: PUSH
87766: EMPTY
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87797: LD_ADDR_VAR 0 44
87801: PUSH
87802: LD_INT 0
87804: PUSH
87805: LD_INT 0
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: LD_INT 1
87817: NEG
87818: PUSH
87819: EMPTY
87820: LIST
87821: LIST
87822: PUSH
87823: LD_INT 1
87825: PUSH
87826: LD_INT 0
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: PUSH
87836: LD_INT 1
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 0
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: LD_INT 0
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 1
87866: NEG
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 1
87878: NEG
87879: PUSH
87880: LD_INT 2
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 1
87890: PUSH
87891: LD_INT 1
87893: NEG
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 2
87901: PUSH
87902: LD_INT 0
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 2
87911: PUSH
87912: LD_INT 1
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 2
87921: PUSH
87922: LD_INT 2
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 1
87931: PUSH
87932: LD_INT 2
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 1
87941: NEG
87942: PUSH
87943: LD_INT 1
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: LD_INT 0
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 1
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 2
87975: NEG
87976: PUSH
87977: LD_INT 2
87979: NEG
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 2
87987: NEG
87988: PUSH
87989: LD_INT 3
87991: NEG
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: PUSH
87997: LD_INT 2
87999: PUSH
88000: LD_INT 1
88002: NEG
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 3
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 3
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 3
88030: PUSH
88031: LD_INT 2
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 3
88040: PUSH
88041: LD_INT 3
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: PUSH
88048: LD_INT 2
88050: PUSH
88051: LD_INT 3
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 2
88060: NEG
88061: PUSH
88062: LD_INT 1
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 3
88071: NEG
88072: PUSH
88073: LD_INT 0
88075: PUSH
88076: EMPTY
88077: LIST
88078: LIST
88079: PUSH
88080: LD_INT 3
88082: NEG
88083: PUSH
88084: LD_INT 1
88086: NEG
88087: PUSH
88088: EMPTY
88089: LIST
88090: LIST
88091: PUSH
88092: LD_INT 3
88094: NEG
88095: PUSH
88096: LD_INT 2
88098: NEG
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 3
88106: NEG
88107: PUSH
88108: LD_INT 3
88110: NEG
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88147: LD_ADDR_VAR 0 45
88151: PUSH
88152: LD_INT 0
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 0
88164: PUSH
88165: LD_INT 1
88167: NEG
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: LD_INT 0
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: PUSH
88186: LD_INT 1
88188: PUSH
88189: EMPTY
88190: LIST
88191: LIST
88192: PUSH
88193: LD_INT 0
88195: PUSH
88196: LD_INT 1
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 1
88205: NEG
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: EMPTY
88211: LIST
88212: LIST
88213: PUSH
88214: LD_INT 1
88216: NEG
88217: PUSH
88218: LD_INT 1
88220: NEG
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 1
88228: NEG
88229: PUSH
88230: LD_INT 2
88232: NEG
88233: PUSH
88234: EMPTY
88235: LIST
88236: LIST
88237: PUSH
88238: LD_INT 0
88240: PUSH
88241: LD_INT 2
88243: NEG
88244: PUSH
88245: EMPTY
88246: LIST
88247: LIST
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: PUSH
88256: EMPTY
88257: LIST
88258: LIST
88259: PUSH
88260: LD_INT 2
88262: PUSH
88263: LD_INT 1
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: LD_INT 2
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 1
88282: PUSH
88283: LD_INT 2
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 0
88292: PUSH
88293: LD_INT 2
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 1
88302: NEG
88303: PUSH
88304: LD_INT 1
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 2
88313: NEG
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 2
88325: NEG
88326: PUSH
88327: LD_INT 2
88329: NEG
88330: PUSH
88331: EMPTY
88332: LIST
88333: LIST
88334: PUSH
88335: LD_INT 2
88337: NEG
88338: PUSH
88339: LD_INT 3
88341: NEG
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: NEG
88350: PUSH
88351: LD_INT 3
88353: NEG
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 0
88361: PUSH
88362: LD_INT 3
88364: NEG
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 1
88372: PUSH
88373: LD_INT 2
88375: NEG
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 3
88383: PUSH
88384: LD_INT 2
88386: PUSH
88387: EMPTY
88388: LIST
88389: LIST
88390: PUSH
88391: LD_INT 3
88393: PUSH
88394: LD_INT 3
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 2
88403: PUSH
88404: LD_INT 3
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 1
88413: PUSH
88414: LD_INT 3
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 0
88423: PUSH
88424: LD_INT 3
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 1
88433: NEG
88434: PUSH
88435: LD_INT 2
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 3
88444: NEG
88445: PUSH
88446: LD_INT 2
88448: NEG
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: LD_INT 3
88456: NEG
88457: PUSH
88458: LD_INT 3
88460: NEG
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88497: LD_ADDR_VAR 0 46
88501: PUSH
88502: LD_INT 0
88504: PUSH
88505: LD_INT 0
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 1
88517: NEG
88518: PUSH
88519: EMPTY
88520: LIST
88521: LIST
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: LD_INT 0
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: PUSH
88536: LD_INT 1
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 1
88555: NEG
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 1
88566: NEG
88567: PUSH
88568: LD_INT 1
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 1
88578: NEG
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 0
88590: PUSH
88591: LD_INT 2
88593: NEG
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 1
88601: PUSH
88602: LD_INT 1
88604: NEG
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: LD_INT 0
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: LD_INT 1
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 1
88632: PUSH
88633: LD_INT 2
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 0
88642: PUSH
88643: LD_INT 2
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 1
88652: NEG
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 2
88663: NEG
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: EMPTY
88669: LIST
88670: LIST
88671: PUSH
88672: LD_INT 2
88674: NEG
88675: PUSH
88676: LD_INT 1
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: NEG
88687: PUSH
88688: LD_INT 3
88690: NEG
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 0
88698: PUSH
88699: LD_INT 3
88701: NEG
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 1
88709: PUSH
88710: LD_INT 2
88712: NEG
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: LD_INT 1
88723: NEG
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 3
88731: PUSH
88732: LD_INT 0
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 3
88741: PUSH
88742: LD_INT 1
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: PUSH
88749: LD_INT 1
88751: PUSH
88752: LD_INT 3
88754: PUSH
88755: EMPTY
88756: LIST
88757: LIST
88758: PUSH
88759: LD_INT 0
88761: PUSH
88762: LD_INT 3
88764: PUSH
88765: EMPTY
88766: LIST
88767: LIST
88768: PUSH
88769: LD_INT 1
88771: NEG
88772: PUSH
88773: LD_INT 2
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 2
88782: NEG
88783: PUSH
88784: LD_INT 1
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 3
88793: NEG
88794: PUSH
88795: LD_INT 0
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 3
88804: NEG
88805: PUSH
88806: LD_INT 1
88808: NEG
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: LIST
88826: LIST
88827: LIST
88828: LIST
88829: LIST
88830: LIST
88831: LIST
88832: LIST
88833: LIST
88834: LIST
88835: LIST
88836: LIST
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88845: LD_ADDR_VAR 0 47
88849: PUSH
88850: LD_INT 0
88852: PUSH
88853: LD_INT 0
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 0
88862: PUSH
88863: LD_INT 1
88865: NEG
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PUSH
88871: LD_INT 1
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 1
88883: PUSH
88884: LD_INT 1
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 0
88893: PUSH
88894: LD_INT 1
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: PUSH
88912: LD_INT 1
88914: NEG
88915: PUSH
88916: LD_INT 1
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 1
88926: NEG
88927: PUSH
88928: LD_INT 2
88930: NEG
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 0
88938: PUSH
88939: LD_INT 2
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 1
88949: PUSH
88950: LD_INT 1
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 2
88960: NEG
88961: PUSH
88962: LD_INT 1
88964: NEG
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 2
88972: NEG
88973: PUSH
88974: LD_INT 2
88976: NEG
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: EMPTY
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: LIST
88993: LIST
88994: LIST
88995: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88996: LD_ADDR_VAR 0 48
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: EMPTY
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 0
89013: PUSH
89014: LD_INT 1
89016: NEG
89017: PUSH
89018: EMPTY
89019: LIST
89020: LIST
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: LD_INT 0
89027: PUSH
89028: EMPTY
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 1
89034: PUSH
89035: LD_INT 1
89037: PUSH
89038: EMPTY
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: LD_INT 1
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 0
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 1
89065: NEG
89066: PUSH
89067: LD_INT 1
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: NEG
89078: PUSH
89079: LD_INT 2
89081: NEG
89082: PUSH
89083: EMPTY
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 0
89089: PUSH
89090: LD_INT 2
89092: NEG
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 1
89100: PUSH
89101: LD_INT 1
89103: NEG
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PUSH
89109: LD_INT 2
89111: PUSH
89112: LD_INT 0
89114: PUSH
89115: EMPTY
89116: LIST
89117: LIST
89118: PUSH
89119: LD_INT 2
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89143: LD_ADDR_VAR 0 49
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: PUSH
89158: LD_INT 0
89160: PUSH
89161: LD_INT 1
89163: NEG
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: LD_INT 0
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: LD_INT 1
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: EMPTY
89186: LIST
89187: LIST
89188: PUSH
89189: LD_INT 0
89191: PUSH
89192: LD_INT 1
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: NEG
89202: PUSH
89203: LD_INT 0
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 1
89212: NEG
89213: PUSH
89214: LD_INT 1
89216: NEG
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 1
89224: PUSH
89225: LD_INT 1
89227: NEG
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: PUSH
89233: LD_INT 2
89235: PUSH
89236: LD_INT 0
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: LD_INT 1
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 2
89255: PUSH
89256: LD_INT 2
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: LD_INT 1
89265: PUSH
89266: LD_INT 2
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89287: LD_ADDR_VAR 0 50
89291: PUSH
89292: LD_INT 0
89294: PUSH
89295: LD_INT 0
89297: PUSH
89298: EMPTY
89299: LIST
89300: LIST
89301: PUSH
89302: LD_INT 0
89304: PUSH
89305: LD_INT 1
89307: NEG
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 1
89315: PUSH
89316: LD_INT 0
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: PUSH
89326: LD_INT 1
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PUSH
89333: LD_INT 0
89335: PUSH
89336: LD_INT 1
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 1
89345: NEG
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: EMPTY
89351: LIST
89352: LIST
89353: PUSH
89354: LD_INT 1
89356: NEG
89357: PUSH
89358: LD_INT 1
89360: NEG
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: PUSH
89366: LD_INT 2
89368: PUSH
89369: LD_INT 1
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 2
89378: PUSH
89379: LD_INT 2
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: LD_INT 1
89388: PUSH
89389: LD_INT 2
89391: PUSH
89392: EMPTY
89393: LIST
89394: LIST
89395: PUSH
89396: LD_INT 0
89398: PUSH
89399: LD_INT 2
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 1
89408: NEG
89409: PUSH
89410: LD_INT 1
89412: PUSH
89413: EMPTY
89414: LIST
89415: LIST
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89431: LD_ADDR_VAR 0 51
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 0
89448: PUSH
89449: LD_INT 1
89451: NEG
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: LD_INT 0
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 1
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: EMPTY
89474: LIST
89475: LIST
89476: PUSH
89477: LD_INT 0
89479: PUSH
89480: LD_INT 1
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: LD_INT 0
89493: PUSH
89494: EMPTY
89495: LIST
89496: LIST
89497: PUSH
89498: LD_INT 1
89500: NEG
89501: PUSH
89502: LD_INT 1
89504: NEG
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 1
89512: PUSH
89513: LD_INT 2
89515: PUSH
89516: EMPTY
89517: LIST
89518: LIST
89519: PUSH
89520: LD_INT 0
89522: PUSH
89523: LD_INT 2
89525: PUSH
89526: EMPTY
89527: LIST
89528: LIST
89529: PUSH
89530: LD_INT 1
89532: NEG
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 2
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 2
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89578: LD_ADDR_VAR 0 52
89582: PUSH
89583: LD_INT 0
89585: PUSH
89586: LD_INT 0
89588: PUSH
89589: EMPTY
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: LD_INT 1
89598: NEG
89599: PUSH
89600: EMPTY
89601: LIST
89602: LIST
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: LD_INT 0
89609: PUSH
89610: EMPTY
89611: LIST
89612: LIST
89613: PUSH
89614: LD_INT 1
89616: PUSH
89617: LD_INT 1
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: PUSH
89624: LD_INT 0
89626: PUSH
89627: LD_INT 1
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 1
89647: NEG
89648: PUSH
89649: LD_INT 1
89651: NEG
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 1
89659: NEG
89660: PUSH
89661: LD_INT 2
89663: NEG
89664: PUSH
89665: EMPTY
89666: LIST
89667: LIST
89668: PUSH
89669: LD_INT 1
89671: NEG
89672: PUSH
89673: LD_INT 1
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 2
89682: NEG
89683: PUSH
89684: LD_INT 0
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 2
89693: NEG
89694: PUSH
89695: LD_INT 1
89697: NEG
89698: PUSH
89699: EMPTY
89700: LIST
89701: LIST
89702: PUSH
89703: LD_INT 2
89705: NEG
89706: PUSH
89707: LD_INT 2
89709: NEG
89710: PUSH
89711: EMPTY
89712: LIST
89713: LIST
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89729: LD_ADDR_VAR 0 53
89733: PUSH
89734: LD_INT 0
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: LD_INT 1
89749: NEG
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: LD_INT 0
89777: PUSH
89778: LD_INT 1
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: LD_INT 0
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: PUSH
89796: LD_INT 1
89798: NEG
89799: PUSH
89800: LD_INT 1
89802: NEG
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: NEG
89811: PUSH
89812: LD_INT 2
89814: NEG
89815: PUSH
89816: EMPTY
89817: LIST
89818: LIST
89819: PUSH
89820: LD_INT 0
89822: PUSH
89823: LD_INT 2
89825: NEG
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 1
89833: PUSH
89834: LD_INT 1
89836: NEG
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 2
89844: PUSH
89845: LD_INT 0
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 2
89854: PUSH
89855: LD_INT 1
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 2
89864: PUSH
89865: LD_INT 2
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: LD_INT 2
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: LD_INT 2
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 1
89894: NEG
89895: PUSH
89896: LD_INT 1
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 2
89905: NEG
89906: PUSH
89907: LD_INT 0
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 2
89916: NEG
89917: PUSH
89918: LD_INT 1
89920: NEG
89921: PUSH
89922: EMPTY
89923: LIST
89924: LIST
89925: PUSH
89926: LD_INT 2
89928: NEG
89929: PUSH
89930: LD_INT 2
89932: NEG
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: EMPTY
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89959: LD_ADDR_VAR 0 54
89963: PUSH
89964: LD_INT 0
89966: PUSH
89967: LD_INT 0
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: LD_INT 1
89979: NEG
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 1
89987: PUSH
89988: LD_INT 0
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: LD_INT 1
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: LD_INT 0
90007: PUSH
90008: LD_INT 1
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: LD_INT 0
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: PUSH
90026: LD_INT 1
90028: NEG
90029: PUSH
90030: LD_INT 1
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: NEG
90041: PUSH
90042: LD_INT 2
90044: NEG
90045: PUSH
90046: EMPTY
90047: LIST
90048: LIST
90049: PUSH
90050: LD_INT 0
90052: PUSH
90053: LD_INT 2
90055: NEG
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 1
90063: PUSH
90064: LD_INT 1
90066: NEG
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 2
90074: PUSH
90075: LD_INT 0
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: LD_INT 1
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: LD_INT 2
90094: PUSH
90095: LD_INT 2
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 1
90104: PUSH
90105: LD_INT 2
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 2
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 1
90124: NEG
90125: PUSH
90126: LD_INT 1
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 2
90135: NEG
90136: PUSH
90137: LD_INT 0
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 2
90146: NEG
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: LD_INT 2
90158: NEG
90159: PUSH
90160: LD_INT 2
90162: NEG
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90189: LD_ADDR_VAR 0 55
90193: PUSH
90194: LD_INT 0
90196: PUSH
90197: LD_INT 0
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: LD_INT 1
90209: NEG
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: LD_INT 0
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PUSH
90225: LD_INT 1
90227: PUSH
90228: LD_INT 1
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 0
90237: PUSH
90238: LD_INT 1
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: NEG
90248: PUSH
90249: LD_INT 0
90251: PUSH
90252: EMPTY
90253: LIST
90254: LIST
90255: PUSH
90256: LD_INT 1
90258: NEG
90259: PUSH
90260: LD_INT 1
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: NEG
90271: PUSH
90272: LD_INT 2
90274: NEG
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 0
90282: PUSH
90283: LD_INT 2
90285: NEG
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: LD_INT 1
90293: PUSH
90294: LD_INT 1
90296: NEG
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 2
90304: PUSH
90305: LD_INT 0
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: LD_INT 1
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: PUSH
90322: LD_INT 2
90324: PUSH
90325: LD_INT 2
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 1
90334: PUSH
90335: LD_INT 2
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 0
90344: PUSH
90345: LD_INT 2
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: NEG
90355: PUSH
90356: LD_INT 1
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 2
90365: NEG
90366: PUSH
90367: LD_INT 0
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 2
90376: NEG
90377: PUSH
90378: LD_INT 1
90380: NEG
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: PUSH
90386: LD_INT 2
90388: NEG
90389: PUSH
90390: LD_INT 2
90392: NEG
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90419: LD_ADDR_VAR 0 56
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: LD_INT 0
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: LD_INT 1
90439: NEG
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: LD_INT 0
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 1
90457: PUSH
90458: LD_INT 1
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 0
90467: PUSH
90468: LD_INT 1
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: LD_INT 1
90477: NEG
90478: PUSH
90479: LD_INT 0
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 1
90488: NEG
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: NEG
90501: PUSH
90502: LD_INT 2
90504: NEG
90505: PUSH
90506: EMPTY
90507: LIST
90508: LIST
90509: PUSH
90510: LD_INT 0
90512: PUSH
90513: LD_INT 2
90515: NEG
90516: PUSH
90517: EMPTY
90518: LIST
90519: LIST
90520: PUSH
90521: LD_INT 1
90523: PUSH
90524: LD_INT 1
90526: NEG
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 2
90534: PUSH
90535: LD_INT 0
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: LD_INT 1
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 2
90554: PUSH
90555: LD_INT 2
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 1
90564: PUSH
90565: LD_INT 2
90567: PUSH
90568: EMPTY
90569: LIST
90570: LIST
90571: PUSH
90572: LD_INT 0
90574: PUSH
90575: LD_INT 2
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: PUSH
90582: LD_INT 1
90584: NEG
90585: PUSH
90586: LD_INT 1
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 2
90595: NEG
90596: PUSH
90597: LD_INT 0
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 2
90606: NEG
90607: PUSH
90608: LD_INT 1
90610: NEG
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 2
90618: NEG
90619: PUSH
90620: LD_INT 2
90622: NEG
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90649: LD_ADDR_VAR 0 57
90653: PUSH
90654: LD_INT 0
90656: PUSH
90657: LD_INT 0
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 1
90669: NEG
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: LD_INT 0
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 1
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 0
90697: PUSH
90698: LD_INT 1
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: NEG
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 1
90718: NEG
90719: PUSH
90720: LD_INT 1
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: NEG
90731: PUSH
90732: LD_INT 2
90734: NEG
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 0
90742: PUSH
90743: LD_INT 2
90745: NEG
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 1
90753: PUSH
90754: LD_INT 1
90756: NEG
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: LD_INT 1
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 2
90784: PUSH
90785: LD_INT 2
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: PUSH
90795: LD_INT 2
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PUSH
90802: LD_INT 0
90804: PUSH
90805: LD_INT 2
90807: PUSH
90808: EMPTY
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 1
90814: NEG
90815: PUSH
90816: LD_INT 1
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 2
90825: NEG
90826: PUSH
90827: LD_INT 0
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 2
90836: NEG
90837: PUSH
90838: LD_INT 1
90840: NEG
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: PUSH
90846: LD_INT 2
90848: NEG
90849: PUSH
90850: LD_INT 2
90852: NEG
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: PUSH
90858: EMPTY
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90879: LD_ADDR_VAR 0 58
90883: PUSH
90884: LD_INT 0
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: EMPTY
90891: LIST
90892: LIST
90893: PUSH
90894: LD_INT 0
90896: PUSH
90897: LD_INT 1
90899: NEG
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 1
90907: PUSH
90908: LD_INT 0
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 1
90917: PUSH
90918: LD_INT 1
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 0
90927: PUSH
90928: LD_INT 1
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: NEG
90938: PUSH
90939: LD_INT 0
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 1
90948: NEG
90949: PUSH
90950: LD_INT 1
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: LD_INT 2
90964: NEG
90965: PUSH
90966: EMPTY
90967: LIST
90968: LIST
90969: PUSH
90970: LD_INT 0
90972: PUSH
90973: LD_INT 2
90975: NEG
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: LD_INT 1
90983: PUSH
90984: LD_INT 1
90986: NEG
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: LD_INT 0
90997: PUSH
90998: EMPTY
90999: LIST
91000: LIST
91001: PUSH
91002: LD_INT 2
91004: PUSH
91005: LD_INT 1
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: PUSH
91012: LD_INT 2
91014: PUSH
91015: LD_INT 2
91017: PUSH
91018: EMPTY
91019: LIST
91020: LIST
91021: PUSH
91022: LD_INT 1
91024: PUSH
91025: LD_INT 2
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PUSH
91032: LD_INT 0
91034: PUSH
91035: LD_INT 2
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 1
91044: NEG
91045: PUSH
91046: LD_INT 1
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 2
91055: NEG
91056: PUSH
91057: LD_INT 0
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 2
91066: NEG
91067: PUSH
91068: LD_INT 1
91070: NEG
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: LD_INT 2
91078: NEG
91079: PUSH
91080: LD_INT 2
91082: NEG
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91109: LD_ADDR_VAR 0 59
91113: PUSH
91114: LD_INT 0
91116: PUSH
91117: LD_INT 0
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 1
91137: PUSH
91138: LD_INT 0
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: PUSH
91145: LD_INT 1
91147: PUSH
91148: LD_INT 1
91150: PUSH
91151: EMPTY
91152: LIST
91153: LIST
91154: PUSH
91155: LD_INT 0
91157: PUSH
91158: LD_INT 1
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: LD_INT 1
91167: NEG
91168: PUSH
91169: LD_INT 0
91171: PUSH
91172: EMPTY
91173: LIST
91174: LIST
91175: PUSH
91176: LD_INT 1
91178: NEG
91179: PUSH
91180: LD_INT 1
91182: NEG
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91197: LD_ADDR_VAR 0 60
91201: PUSH
91202: LD_INT 0
91204: PUSH
91205: LD_INT 0
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 0
91214: PUSH
91215: LD_INT 1
91217: NEG
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 1
91235: PUSH
91236: LD_INT 1
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 0
91245: PUSH
91246: LD_INT 1
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: LD_INT 1
91255: NEG
91256: PUSH
91257: LD_INT 0
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 1
91266: NEG
91267: PUSH
91268: LD_INT 1
91270: NEG
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91285: LD_ADDR_VAR 0 61
91289: PUSH
91290: LD_INT 0
91292: PUSH
91293: LD_INT 0
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: PUSH
91300: LD_INT 0
91302: PUSH
91303: LD_INT 1
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 1
91313: PUSH
91314: LD_INT 0
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: PUSH
91321: LD_INT 1
91323: PUSH
91324: LD_INT 1
91326: PUSH
91327: EMPTY
91328: LIST
91329: LIST
91330: PUSH
91331: LD_INT 0
91333: PUSH
91334: LD_INT 1
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 1
91343: NEG
91344: PUSH
91345: LD_INT 0
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: PUSH
91352: LD_INT 1
91354: NEG
91355: PUSH
91356: LD_INT 1
91358: NEG
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91373: LD_ADDR_VAR 0 62
91377: PUSH
91378: LD_INT 0
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: EMPTY
91385: LIST
91386: LIST
91387: PUSH
91388: LD_INT 0
91390: PUSH
91391: LD_INT 1
91393: NEG
91394: PUSH
91395: EMPTY
91396: LIST
91397: LIST
91398: PUSH
91399: LD_INT 1
91401: PUSH
91402: LD_INT 0
91404: PUSH
91405: EMPTY
91406: LIST
91407: LIST
91408: PUSH
91409: LD_INT 1
91411: PUSH
91412: LD_INT 1
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 0
91421: PUSH
91422: LD_INT 1
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 1
91431: NEG
91432: PUSH
91433: LD_INT 0
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PUSH
91440: LD_INT 1
91442: NEG
91443: PUSH
91444: LD_INT 1
91446: NEG
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91461: LD_ADDR_VAR 0 63
91465: PUSH
91466: LD_INT 0
91468: PUSH
91469: LD_INT 0
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: LD_INT 1
91481: NEG
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: LD_INT 0
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: PUSH
91500: LD_INT 1
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: PUSH
91507: LD_INT 0
91509: PUSH
91510: LD_INT 1
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: LD_INT 1
91519: NEG
91520: PUSH
91521: LD_INT 0
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: LD_INT 1
91534: NEG
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91549: LD_ADDR_VAR 0 64
91553: PUSH
91554: LD_INT 0
91556: PUSH
91557: LD_INT 0
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 0
91566: PUSH
91567: LD_INT 1
91569: NEG
91570: PUSH
91571: EMPTY
91572: LIST
91573: LIST
91574: PUSH
91575: LD_INT 1
91577: PUSH
91578: LD_INT 0
91580: PUSH
91581: EMPTY
91582: LIST
91583: LIST
91584: PUSH
91585: LD_INT 1
91587: PUSH
91588: LD_INT 1
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: PUSH
91595: LD_INT 0
91597: PUSH
91598: LD_INT 1
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: LD_INT 1
91607: NEG
91608: PUSH
91609: LD_INT 0
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 1
91618: NEG
91619: PUSH
91620: LD_INT 1
91622: NEG
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: ST_TO_ADDR
// end ; 1 :
91637: GO 97534
91639: LD_INT 1
91641: DOUBLE
91642: EQUAL
91643: IFTRUE 91647
91645: GO 94270
91647: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91648: LD_ADDR_VAR 0 11
91652: PUSH
91653: LD_INT 1
91655: NEG
91656: PUSH
91657: LD_INT 3
91659: NEG
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 0
91667: PUSH
91668: LD_INT 3
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 1
91678: PUSH
91679: LD_INT 2
91681: NEG
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PUSH
91687: EMPTY
91688: LIST
91689: LIST
91690: LIST
91691: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91692: LD_ADDR_VAR 0 12
91696: PUSH
91697: LD_INT 2
91699: PUSH
91700: LD_INT 1
91702: NEG
91703: PUSH
91704: EMPTY
91705: LIST
91706: LIST
91707: PUSH
91708: LD_INT 3
91710: PUSH
91711: LD_INT 0
91713: PUSH
91714: EMPTY
91715: LIST
91716: LIST
91717: PUSH
91718: LD_INT 3
91720: PUSH
91721: LD_INT 1
91723: PUSH
91724: EMPTY
91725: LIST
91726: LIST
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91733: LD_ADDR_VAR 0 13
91737: PUSH
91738: LD_INT 3
91740: PUSH
91741: LD_INT 2
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: PUSH
91748: LD_INT 3
91750: PUSH
91751: LD_INT 3
91753: PUSH
91754: EMPTY
91755: LIST
91756: LIST
91757: PUSH
91758: LD_INT 2
91760: PUSH
91761: LD_INT 3
91763: PUSH
91764: EMPTY
91765: LIST
91766: LIST
91767: PUSH
91768: EMPTY
91769: LIST
91770: LIST
91771: LIST
91772: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91773: LD_ADDR_VAR 0 14
91777: PUSH
91778: LD_INT 1
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: LD_INT 0
91790: PUSH
91791: LD_INT 3
91793: PUSH
91794: EMPTY
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 1
91800: NEG
91801: PUSH
91802: LD_INT 2
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: LIST
91813: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91814: LD_ADDR_VAR 0 15
91818: PUSH
91819: LD_INT 2
91821: NEG
91822: PUSH
91823: LD_INT 1
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: LD_INT 3
91832: NEG
91833: PUSH
91834: LD_INT 0
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 3
91843: NEG
91844: PUSH
91845: LD_INT 1
91847: NEG
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: LIST
91857: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91858: LD_ADDR_VAR 0 16
91862: PUSH
91863: LD_INT 2
91865: NEG
91866: PUSH
91867: LD_INT 3
91869: NEG
91870: PUSH
91871: EMPTY
91872: LIST
91873: LIST
91874: PUSH
91875: LD_INT 3
91877: NEG
91878: PUSH
91879: LD_INT 2
91881: NEG
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 3
91889: NEG
91890: PUSH
91891: LD_INT 3
91893: NEG
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: LIST
91903: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91904: LD_ADDR_VAR 0 17
91908: PUSH
91909: LD_INT 1
91911: NEG
91912: PUSH
91913: LD_INT 3
91915: NEG
91916: PUSH
91917: EMPTY
91918: LIST
91919: LIST
91920: PUSH
91921: LD_INT 0
91923: PUSH
91924: LD_INT 3
91926: NEG
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: LD_INT 2
91937: NEG
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: EMPTY
91944: LIST
91945: LIST
91946: LIST
91947: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91948: LD_ADDR_VAR 0 18
91952: PUSH
91953: LD_INT 2
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: LD_INT 3
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: EMPTY
91971: LIST
91972: LIST
91973: PUSH
91974: LD_INT 3
91976: PUSH
91977: LD_INT 1
91979: PUSH
91980: EMPTY
91981: LIST
91982: LIST
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: LIST
91988: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91989: LD_ADDR_VAR 0 19
91993: PUSH
91994: LD_INT 3
91996: PUSH
91997: LD_INT 2
91999: PUSH
92000: EMPTY
92001: LIST
92002: LIST
92003: PUSH
92004: LD_INT 3
92006: PUSH
92007: LD_INT 3
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PUSH
92014: LD_INT 2
92016: PUSH
92017: LD_INT 3
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: LIST
92028: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92029: LD_ADDR_VAR 0 20
92033: PUSH
92034: LD_INT 1
92036: PUSH
92037: LD_INT 3
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: LD_INT 0
92046: PUSH
92047: LD_INT 3
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: LD_INT 1
92056: NEG
92057: PUSH
92058: LD_INT 2
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: LIST
92069: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92070: LD_ADDR_VAR 0 21
92074: PUSH
92075: LD_INT 2
92077: NEG
92078: PUSH
92079: LD_INT 1
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 3
92088: NEG
92089: PUSH
92090: LD_INT 0
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 3
92099: NEG
92100: PUSH
92101: LD_INT 1
92103: NEG
92104: PUSH
92105: EMPTY
92106: LIST
92107: LIST
92108: PUSH
92109: EMPTY
92110: LIST
92111: LIST
92112: LIST
92113: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92114: LD_ADDR_VAR 0 22
92118: PUSH
92119: LD_INT 2
92121: NEG
92122: PUSH
92123: LD_INT 3
92125: NEG
92126: PUSH
92127: EMPTY
92128: LIST
92129: LIST
92130: PUSH
92131: LD_INT 3
92133: NEG
92134: PUSH
92135: LD_INT 2
92137: NEG
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: PUSH
92143: LD_INT 3
92145: NEG
92146: PUSH
92147: LD_INT 3
92149: NEG
92150: PUSH
92151: EMPTY
92152: LIST
92153: LIST
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: LIST
92159: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92160: LD_ADDR_VAR 0 23
92164: PUSH
92165: LD_INT 0
92167: PUSH
92168: LD_INT 3
92170: NEG
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: LD_INT 1
92178: NEG
92179: PUSH
92180: LD_INT 4
92182: NEG
92183: PUSH
92184: EMPTY
92185: LIST
92186: LIST
92187: PUSH
92188: LD_INT 1
92190: PUSH
92191: LD_INT 3
92193: NEG
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: LIST
92203: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92204: LD_ADDR_VAR 0 24
92208: PUSH
92209: LD_INT 3
92211: PUSH
92212: LD_INT 0
92214: PUSH
92215: EMPTY
92216: LIST
92217: LIST
92218: PUSH
92219: LD_INT 3
92221: PUSH
92222: LD_INT 1
92224: NEG
92225: PUSH
92226: EMPTY
92227: LIST
92228: LIST
92229: PUSH
92230: LD_INT 4
92232: PUSH
92233: LD_INT 1
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: LIST
92244: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92245: LD_ADDR_VAR 0 25
92249: PUSH
92250: LD_INT 3
92252: PUSH
92253: LD_INT 3
92255: PUSH
92256: EMPTY
92257: LIST
92258: LIST
92259: PUSH
92260: LD_INT 4
92262: PUSH
92263: LD_INT 3
92265: PUSH
92266: EMPTY
92267: LIST
92268: LIST
92269: PUSH
92270: LD_INT 3
92272: PUSH
92273: LD_INT 4
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: PUSH
92280: EMPTY
92281: LIST
92282: LIST
92283: LIST
92284: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92285: LD_ADDR_VAR 0 26
92289: PUSH
92290: LD_INT 0
92292: PUSH
92293: LD_INT 3
92295: PUSH
92296: EMPTY
92297: LIST
92298: LIST
92299: PUSH
92300: LD_INT 1
92302: PUSH
92303: LD_INT 4
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: LD_INT 1
92312: NEG
92313: PUSH
92314: LD_INT 3
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: LIST
92325: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92326: LD_ADDR_VAR 0 27
92330: PUSH
92331: LD_INT 3
92333: NEG
92334: PUSH
92335: LD_INT 0
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: LD_INT 3
92344: NEG
92345: PUSH
92346: LD_INT 1
92348: PUSH
92349: EMPTY
92350: LIST
92351: LIST
92352: PUSH
92353: LD_INT 4
92355: NEG
92356: PUSH
92357: LD_INT 1
92359: NEG
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: LIST
92369: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92370: LD_ADDR_VAR 0 28
92374: PUSH
92375: LD_INT 3
92377: NEG
92378: PUSH
92379: LD_INT 3
92381: NEG
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 3
92389: NEG
92390: PUSH
92391: LD_INT 4
92393: NEG
92394: PUSH
92395: EMPTY
92396: LIST
92397: LIST
92398: PUSH
92399: LD_INT 4
92401: NEG
92402: PUSH
92403: LD_INT 3
92405: NEG
92406: PUSH
92407: EMPTY
92408: LIST
92409: LIST
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: LIST
92415: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92416: LD_ADDR_VAR 0 29
92420: PUSH
92421: LD_INT 1
92423: NEG
92424: PUSH
92425: LD_INT 3
92427: NEG
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: PUSH
92433: LD_INT 0
92435: PUSH
92436: LD_INT 3
92438: NEG
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 1
92446: PUSH
92447: LD_INT 2
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 1
92457: NEG
92458: PUSH
92459: LD_INT 4
92461: NEG
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: LD_INT 0
92469: PUSH
92470: LD_INT 4
92472: NEG
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 1
92480: PUSH
92481: LD_INT 3
92483: NEG
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 1
92491: NEG
92492: PUSH
92493: LD_INT 5
92495: NEG
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 0
92503: PUSH
92504: LD_INT 5
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 1
92514: PUSH
92515: LD_INT 4
92517: NEG
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 1
92525: NEG
92526: PUSH
92527: LD_INT 6
92529: NEG
92530: PUSH
92531: EMPTY
92532: LIST
92533: LIST
92534: PUSH
92535: LD_INT 0
92537: PUSH
92538: LD_INT 6
92540: NEG
92541: PUSH
92542: EMPTY
92543: LIST
92544: LIST
92545: PUSH
92546: LD_INT 1
92548: PUSH
92549: LD_INT 5
92551: NEG
92552: PUSH
92553: EMPTY
92554: LIST
92555: LIST
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92571: LD_ADDR_VAR 0 30
92575: PUSH
92576: LD_INT 2
92578: PUSH
92579: LD_INT 1
92581: NEG
92582: PUSH
92583: EMPTY
92584: LIST
92585: LIST
92586: PUSH
92587: LD_INT 3
92589: PUSH
92590: LD_INT 0
92592: PUSH
92593: EMPTY
92594: LIST
92595: LIST
92596: PUSH
92597: LD_INT 3
92599: PUSH
92600: LD_INT 1
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 3
92609: PUSH
92610: LD_INT 1
92612: NEG
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 4
92620: PUSH
92621: LD_INT 0
92623: PUSH
92624: EMPTY
92625: LIST
92626: LIST
92627: PUSH
92628: LD_INT 4
92630: PUSH
92631: LD_INT 1
92633: PUSH
92634: EMPTY
92635: LIST
92636: LIST
92637: PUSH
92638: LD_INT 4
92640: PUSH
92641: LD_INT 1
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 5
92651: PUSH
92652: LD_INT 0
92654: PUSH
92655: EMPTY
92656: LIST
92657: LIST
92658: PUSH
92659: LD_INT 5
92661: PUSH
92662: LD_INT 1
92664: PUSH
92665: EMPTY
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 5
92671: PUSH
92672: LD_INT 1
92674: NEG
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 6
92682: PUSH
92683: LD_INT 0
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 6
92692: PUSH
92693: LD_INT 1
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92714: LD_ADDR_VAR 0 31
92718: PUSH
92719: LD_INT 3
92721: PUSH
92722: LD_INT 2
92724: PUSH
92725: EMPTY
92726: LIST
92727: LIST
92728: PUSH
92729: LD_INT 3
92731: PUSH
92732: LD_INT 3
92734: PUSH
92735: EMPTY
92736: LIST
92737: LIST
92738: PUSH
92739: LD_INT 2
92741: PUSH
92742: LD_INT 3
92744: PUSH
92745: EMPTY
92746: LIST
92747: LIST
92748: PUSH
92749: LD_INT 4
92751: PUSH
92752: LD_INT 3
92754: PUSH
92755: EMPTY
92756: LIST
92757: LIST
92758: PUSH
92759: LD_INT 4
92761: PUSH
92762: LD_INT 4
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 3
92771: PUSH
92772: LD_INT 4
92774: PUSH
92775: EMPTY
92776: LIST
92777: LIST
92778: PUSH
92779: LD_INT 5
92781: PUSH
92782: LD_INT 4
92784: PUSH
92785: EMPTY
92786: LIST
92787: LIST
92788: PUSH
92789: LD_INT 5
92791: PUSH
92792: LD_INT 5
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 4
92801: PUSH
92802: LD_INT 5
92804: PUSH
92805: EMPTY
92806: LIST
92807: LIST
92808: PUSH
92809: LD_INT 6
92811: PUSH
92812: LD_INT 5
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 6
92821: PUSH
92822: LD_INT 6
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 5
92831: PUSH
92832: LD_INT 6
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92853: LD_ADDR_VAR 0 32
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: LD_INT 3
92863: PUSH
92864: EMPTY
92865: LIST
92866: LIST
92867: PUSH
92868: LD_INT 0
92870: PUSH
92871: LD_INT 3
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: LD_INT 2
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 1
92891: PUSH
92892: LD_INT 4
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 0
92901: PUSH
92902: LD_INT 4
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 1
92911: NEG
92912: PUSH
92913: LD_INT 3
92915: PUSH
92916: EMPTY
92917: LIST
92918: LIST
92919: PUSH
92920: LD_INT 1
92922: PUSH
92923: LD_INT 5
92925: PUSH
92926: EMPTY
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 0
92932: PUSH
92933: LD_INT 5
92935: PUSH
92936: EMPTY
92937: LIST
92938: LIST
92939: PUSH
92940: LD_INT 1
92942: NEG
92943: PUSH
92944: LD_INT 4
92946: PUSH
92947: EMPTY
92948: LIST
92949: LIST
92950: PUSH
92951: LD_INT 1
92953: PUSH
92954: LD_INT 6
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: LD_INT 6
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 1
92973: NEG
92974: PUSH
92975: LD_INT 5
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92996: LD_ADDR_VAR 0 33
93000: PUSH
93001: LD_INT 2
93003: NEG
93004: PUSH
93005: LD_INT 1
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 3
93014: NEG
93015: PUSH
93016: LD_INT 0
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 3
93025: NEG
93026: PUSH
93027: LD_INT 1
93029: NEG
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 3
93037: NEG
93038: PUSH
93039: LD_INT 1
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 4
93048: NEG
93049: PUSH
93050: LD_INT 0
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 4
93059: NEG
93060: PUSH
93061: LD_INT 1
93063: NEG
93064: PUSH
93065: EMPTY
93066: LIST
93067: LIST
93068: PUSH
93069: LD_INT 4
93071: NEG
93072: PUSH
93073: LD_INT 1
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 5
93082: NEG
93083: PUSH
93084: LD_INT 0
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 5
93093: NEG
93094: PUSH
93095: LD_INT 1
93097: NEG
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 5
93105: NEG
93106: PUSH
93107: LD_INT 1
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 6
93116: NEG
93117: PUSH
93118: LD_INT 0
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 6
93127: NEG
93128: PUSH
93129: LD_INT 1
93131: NEG
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93151: LD_ADDR_VAR 0 34
93155: PUSH
93156: LD_INT 2
93158: NEG
93159: PUSH
93160: LD_INT 3
93162: NEG
93163: PUSH
93164: EMPTY
93165: LIST
93166: LIST
93167: PUSH
93168: LD_INT 3
93170: NEG
93171: PUSH
93172: LD_INT 2
93174: NEG
93175: PUSH
93176: EMPTY
93177: LIST
93178: LIST
93179: PUSH
93180: LD_INT 3
93182: NEG
93183: PUSH
93184: LD_INT 3
93186: NEG
93187: PUSH
93188: EMPTY
93189: LIST
93190: LIST
93191: PUSH
93192: LD_INT 3
93194: NEG
93195: PUSH
93196: LD_INT 4
93198: NEG
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: PUSH
93204: LD_INT 4
93206: NEG
93207: PUSH
93208: LD_INT 3
93210: NEG
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 4
93218: NEG
93219: PUSH
93220: LD_INT 4
93222: NEG
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: PUSH
93228: LD_INT 4
93230: NEG
93231: PUSH
93232: LD_INT 5
93234: NEG
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 5
93242: NEG
93243: PUSH
93244: LD_INT 4
93246: NEG
93247: PUSH
93248: EMPTY
93249: LIST
93250: LIST
93251: PUSH
93252: LD_INT 5
93254: NEG
93255: PUSH
93256: LD_INT 5
93258: NEG
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: PUSH
93264: LD_INT 5
93266: NEG
93267: PUSH
93268: LD_INT 6
93270: NEG
93271: PUSH
93272: EMPTY
93273: LIST
93274: LIST
93275: PUSH
93276: LD_INT 6
93278: NEG
93279: PUSH
93280: LD_INT 5
93282: NEG
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 6
93290: NEG
93291: PUSH
93292: LD_INT 6
93294: NEG
93295: PUSH
93296: EMPTY
93297: LIST
93298: LIST
93299: PUSH
93300: EMPTY
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93314: LD_ADDR_VAR 0 41
93318: PUSH
93319: LD_INT 0
93321: PUSH
93322: LD_INT 2
93324: NEG
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: LD_INT 1
93332: NEG
93333: PUSH
93334: LD_INT 3
93336: NEG
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 1
93344: PUSH
93345: LD_INT 2
93347: NEG
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: EMPTY
93354: LIST
93355: LIST
93356: LIST
93357: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93358: LD_ADDR_VAR 0 42
93362: PUSH
93363: LD_INT 2
93365: PUSH
93366: LD_INT 0
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 2
93375: PUSH
93376: LD_INT 1
93378: NEG
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: PUSH
93384: LD_INT 3
93386: PUSH
93387: LD_INT 1
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: LIST
93398: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93399: LD_ADDR_VAR 0 43
93403: PUSH
93404: LD_INT 2
93406: PUSH
93407: LD_INT 2
93409: PUSH
93410: EMPTY
93411: LIST
93412: LIST
93413: PUSH
93414: LD_INT 3
93416: PUSH
93417: LD_INT 2
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: LD_INT 3
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: LIST
93438: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93439: LD_ADDR_VAR 0 44
93443: PUSH
93444: LD_INT 0
93446: PUSH
93447: LD_INT 2
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 1
93456: PUSH
93457: LD_INT 3
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: PUSH
93464: LD_INT 1
93466: NEG
93467: PUSH
93468: LD_INT 2
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: EMPTY
93476: LIST
93477: LIST
93478: LIST
93479: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93480: LD_ADDR_VAR 0 45
93484: PUSH
93485: LD_INT 2
93487: NEG
93488: PUSH
93489: LD_INT 0
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: LD_INT 2
93498: NEG
93499: PUSH
93500: LD_INT 1
93502: PUSH
93503: EMPTY
93504: LIST
93505: LIST
93506: PUSH
93507: LD_INT 3
93509: NEG
93510: PUSH
93511: LD_INT 1
93513: NEG
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: LIST
93523: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93524: LD_ADDR_VAR 0 46
93528: PUSH
93529: LD_INT 2
93531: NEG
93532: PUSH
93533: LD_INT 2
93535: NEG
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 2
93543: NEG
93544: PUSH
93545: LD_INT 3
93547: NEG
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 3
93555: NEG
93556: PUSH
93557: LD_INT 2
93559: NEG
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: EMPTY
93566: LIST
93567: LIST
93568: LIST
93569: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93570: LD_ADDR_VAR 0 47
93574: PUSH
93575: LD_INT 2
93577: NEG
93578: PUSH
93579: LD_INT 3
93581: NEG
93582: PUSH
93583: EMPTY
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 1
93589: NEG
93590: PUSH
93591: LD_INT 3
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93603: LD_ADDR_VAR 0 48
93607: PUSH
93608: LD_INT 1
93610: PUSH
93611: LD_INT 2
93613: NEG
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: PUSH
93622: LD_INT 1
93624: NEG
93625: PUSH
93626: EMPTY
93627: LIST
93628: LIST
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93634: LD_ADDR_VAR 0 49
93638: PUSH
93639: LD_INT 3
93641: PUSH
93642: LD_INT 1
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PUSH
93649: LD_INT 3
93651: PUSH
93652: LD_INT 2
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93663: LD_ADDR_VAR 0 50
93667: PUSH
93668: LD_INT 2
93670: PUSH
93671: LD_INT 3
93673: PUSH
93674: EMPTY
93675: LIST
93676: LIST
93677: PUSH
93678: LD_INT 1
93680: PUSH
93681: LD_INT 3
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93692: LD_ADDR_VAR 0 51
93696: PUSH
93697: LD_INT 1
93699: NEG
93700: PUSH
93701: LD_INT 2
93703: PUSH
93704: EMPTY
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 2
93710: NEG
93711: PUSH
93712: LD_INT 1
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: EMPTY
93720: LIST
93721: LIST
93722: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93723: LD_ADDR_VAR 0 52
93727: PUSH
93728: LD_INT 3
93730: NEG
93731: PUSH
93732: LD_INT 1
93734: NEG
93735: PUSH
93736: EMPTY
93737: LIST
93738: LIST
93739: PUSH
93740: LD_INT 3
93742: NEG
93743: PUSH
93744: LD_INT 2
93746: NEG
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: EMPTY
93753: LIST
93754: LIST
93755: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93756: LD_ADDR_VAR 0 53
93760: PUSH
93761: LD_INT 1
93763: NEG
93764: PUSH
93765: LD_INT 3
93767: NEG
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: PUSH
93773: LD_INT 0
93775: PUSH
93776: LD_INT 3
93778: NEG
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: PUSH
93784: LD_INT 1
93786: PUSH
93787: LD_INT 2
93789: NEG
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: LIST
93799: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93800: LD_ADDR_VAR 0 54
93804: PUSH
93805: LD_INT 2
93807: PUSH
93808: LD_INT 1
93810: NEG
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: LD_INT 3
93818: PUSH
93819: LD_INT 0
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 3
93828: PUSH
93829: LD_INT 1
93831: PUSH
93832: EMPTY
93833: LIST
93834: LIST
93835: PUSH
93836: EMPTY
93837: LIST
93838: LIST
93839: LIST
93840: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93841: LD_ADDR_VAR 0 55
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: LD_INT 2
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 3
93858: PUSH
93859: LD_INT 3
93861: PUSH
93862: EMPTY
93863: LIST
93864: LIST
93865: PUSH
93866: LD_INT 2
93868: PUSH
93869: LD_INT 3
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: LIST
93880: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93881: LD_ADDR_VAR 0 56
93885: PUSH
93886: LD_INT 1
93888: PUSH
93889: LD_INT 3
93891: PUSH
93892: EMPTY
93893: LIST
93894: LIST
93895: PUSH
93896: LD_INT 0
93898: PUSH
93899: LD_INT 3
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: PUSH
93906: LD_INT 1
93908: NEG
93909: PUSH
93910: LD_INT 2
93912: PUSH
93913: EMPTY
93914: LIST
93915: LIST
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: LIST
93921: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93922: LD_ADDR_VAR 0 57
93926: PUSH
93927: LD_INT 2
93929: NEG
93930: PUSH
93931: LD_INT 1
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 3
93940: NEG
93941: PUSH
93942: LD_INT 0
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 3
93951: NEG
93952: PUSH
93953: LD_INT 1
93955: NEG
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: LIST
93965: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93966: LD_ADDR_VAR 0 58
93970: PUSH
93971: LD_INT 2
93973: NEG
93974: PUSH
93975: LD_INT 3
93977: NEG
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: LD_INT 3
93985: NEG
93986: PUSH
93987: LD_INT 2
93989: NEG
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: PUSH
93995: LD_INT 3
93997: NEG
93998: PUSH
93999: LD_INT 3
94001: NEG
94002: PUSH
94003: EMPTY
94004: LIST
94005: LIST
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: LIST
94011: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94012: LD_ADDR_VAR 0 59
94016: PUSH
94017: LD_INT 1
94019: NEG
94020: PUSH
94021: LD_INT 2
94023: NEG
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 0
94031: PUSH
94032: LD_INT 2
94034: NEG
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: LD_INT 1
94042: PUSH
94043: LD_INT 1
94045: NEG
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: LIST
94055: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94056: LD_ADDR_VAR 0 60
94060: PUSH
94061: LD_INT 1
94063: PUSH
94064: LD_INT 1
94066: NEG
94067: PUSH
94068: EMPTY
94069: LIST
94070: LIST
94071: PUSH
94072: LD_INT 2
94074: PUSH
94075: LD_INT 0
94077: PUSH
94078: EMPTY
94079: LIST
94080: LIST
94081: PUSH
94082: LD_INT 2
94084: PUSH
94085: LD_INT 1
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: LIST
94096: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94097: LD_ADDR_VAR 0 61
94101: PUSH
94102: LD_INT 2
94104: PUSH
94105: LD_INT 1
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: PUSH
94112: LD_INT 2
94114: PUSH
94115: LD_INT 2
94117: PUSH
94118: EMPTY
94119: LIST
94120: LIST
94121: PUSH
94122: LD_INT 1
94124: PUSH
94125: LD_INT 2
94127: PUSH
94128: EMPTY
94129: LIST
94130: LIST
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: LIST
94136: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94137: LD_ADDR_VAR 0 62
94141: PUSH
94142: LD_INT 1
94144: PUSH
94145: LD_INT 2
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 0
94154: PUSH
94155: LD_INT 2
94157: PUSH
94158: EMPTY
94159: LIST
94160: LIST
94161: PUSH
94162: LD_INT 1
94164: NEG
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: LIST
94177: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94178: LD_ADDR_VAR 0 63
94182: PUSH
94183: LD_INT 1
94185: NEG
94186: PUSH
94187: LD_INT 1
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: LD_INT 2
94196: NEG
94197: PUSH
94198: LD_INT 0
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: LD_INT 2
94207: NEG
94208: PUSH
94209: LD_INT 1
94211: NEG
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: LIST
94221: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94222: LD_ADDR_VAR 0 64
94226: PUSH
94227: LD_INT 1
94229: NEG
94230: PUSH
94231: LD_INT 2
94233: NEG
94234: PUSH
94235: EMPTY
94236: LIST
94237: LIST
94238: PUSH
94239: LD_INT 2
94241: NEG
94242: PUSH
94243: LD_INT 1
94245: NEG
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: PUSH
94251: LD_INT 2
94253: NEG
94254: PUSH
94255: LD_INT 2
94257: NEG
94258: PUSH
94259: EMPTY
94260: LIST
94261: LIST
94262: PUSH
94263: EMPTY
94264: LIST
94265: LIST
94266: LIST
94267: ST_TO_ADDR
// end ; 2 :
94268: GO 97534
94270: LD_INT 2
94272: DOUBLE
94273: EQUAL
94274: IFTRUE 94278
94276: GO 97533
94278: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94279: LD_ADDR_VAR 0 29
94283: PUSH
94284: LD_INT 4
94286: PUSH
94287: LD_INT 0
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 4
94296: PUSH
94297: LD_INT 1
94299: NEG
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 5
94307: PUSH
94308: LD_INT 0
94310: PUSH
94311: EMPTY
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 5
94317: PUSH
94318: LD_INT 1
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: PUSH
94325: LD_INT 4
94327: PUSH
94328: LD_INT 1
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 3
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: PUSH
94345: LD_INT 3
94347: PUSH
94348: LD_INT 1
94350: NEG
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: PUSH
94356: LD_INT 3
94358: PUSH
94359: LD_INT 2
94361: NEG
94362: PUSH
94363: EMPTY
94364: LIST
94365: LIST
94366: PUSH
94367: LD_INT 5
94369: PUSH
94370: LD_INT 2
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: LD_INT 3
94379: PUSH
94380: LD_INT 3
94382: PUSH
94383: EMPTY
94384: LIST
94385: LIST
94386: PUSH
94387: LD_INT 3
94389: PUSH
94390: LD_INT 2
94392: PUSH
94393: EMPTY
94394: LIST
94395: LIST
94396: PUSH
94397: LD_INT 4
94399: PUSH
94400: LD_INT 3
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 4
94409: PUSH
94410: LD_INT 4
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 3
94419: PUSH
94420: LD_INT 4
94422: PUSH
94423: EMPTY
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 2
94429: PUSH
94430: LD_INT 3
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: PUSH
94437: LD_INT 2
94439: PUSH
94440: LD_INT 2
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 4
94449: PUSH
94450: LD_INT 2
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 2
94459: PUSH
94460: LD_INT 4
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 0
94469: PUSH
94470: LD_INT 4
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 0
94479: PUSH
94480: LD_INT 3
94482: PUSH
94483: EMPTY
94484: LIST
94485: LIST
94486: PUSH
94487: LD_INT 1
94489: PUSH
94490: LD_INT 4
94492: PUSH
94493: EMPTY
94494: LIST
94495: LIST
94496: PUSH
94497: LD_INT 1
94499: PUSH
94500: LD_INT 5
94502: PUSH
94503: EMPTY
94504: LIST
94505: LIST
94506: PUSH
94507: LD_INT 0
94509: PUSH
94510: LD_INT 5
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 1
94519: NEG
94520: PUSH
94521: LD_INT 4
94523: PUSH
94524: EMPTY
94525: LIST
94526: LIST
94527: PUSH
94528: LD_INT 1
94530: NEG
94531: PUSH
94532: LD_INT 3
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 2
94541: PUSH
94542: LD_INT 5
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 2
94551: NEG
94552: PUSH
94553: LD_INT 3
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 3
94562: NEG
94563: PUSH
94564: LD_INT 0
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 3
94573: NEG
94574: PUSH
94575: LD_INT 1
94577: NEG
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: PUSH
94583: LD_INT 2
94585: NEG
94586: PUSH
94587: LD_INT 0
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: PUSH
94594: LD_INT 2
94596: NEG
94597: PUSH
94598: LD_INT 1
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 3
94607: NEG
94608: PUSH
94609: LD_INT 1
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 4
94618: NEG
94619: PUSH
94620: LD_INT 0
94622: PUSH
94623: EMPTY
94624: LIST
94625: LIST
94626: PUSH
94627: LD_INT 4
94629: NEG
94630: PUSH
94631: LD_INT 1
94633: NEG
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 4
94641: NEG
94642: PUSH
94643: LD_INT 2
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 2
94653: NEG
94654: PUSH
94655: LD_INT 2
94657: PUSH
94658: EMPTY
94659: LIST
94660: LIST
94661: PUSH
94662: LD_INT 4
94664: NEG
94665: PUSH
94666: LD_INT 4
94668: NEG
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: LD_INT 4
94676: NEG
94677: PUSH
94678: LD_INT 5
94680: NEG
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: PUSH
94686: LD_INT 3
94688: NEG
94689: PUSH
94690: LD_INT 4
94692: NEG
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 3
94700: NEG
94701: PUSH
94702: LD_INT 3
94704: NEG
94705: PUSH
94706: EMPTY
94707: LIST
94708: LIST
94709: PUSH
94710: LD_INT 4
94712: NEG
94713: PUSH
94714: LD_INT 3
94716: NEG
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PUSH
94722: LD_INT 5
94724: NEG
94725: PUSH
94726: LD_INT 4
94728: NEG
94729: PUSH
94730: EMPTY
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 5
94736: NEG
94737: PUSH
94738: LD_INT 5
94740: NEG
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 3
94748: NEG
94749: PUSH
94750: LD_INT 5
94752: NEG
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 5
94760: NEG
94761: PUSH
94762: LD_INT 3
94764: NEG
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94817: LD_ADDR_VAR 0 30
94821: PUSH
94822: LD_INT 4
94824: PUSH
94825: LD_INT 4
94827: PUSH
94828: EMPTY
94829: LIST
94830: LIST
94831: PUSH
94832: LD_INT 4
94834: PUSH
94835: LD_INT 3
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 5
94844: PUSH
94845: LD_INT 4
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 5
94854: PUSH
94855: LD_INT 5
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: LD_INT 4
94864: PUSH
94865: LD_INT 5
94867: PUSH
94868: EMPTY
94869: LIST
94870: LIST
94871: PUSH
94872: LD_INT 3
94874: PUSH
94875: LD_INT 4
94877: PUSH
94878: EMPTY
94879: LIST
94880: LIST
94881: PUSH
94882: LD_INT 3
94884: PUSH
94885: LD_INT 3
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 5
94894: PUSH
94895: LD_INT 3
94897: PUSH
94898: EMPTY
94899: LIST
94900: LIST
94901: PUSH
94902: LD_INT 3
94904: PUSH
94905: LD_INT 5
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 0
94914: PUSH
94915: LD_INT 3
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 0
94924: PUSH
94925: LD_INT 2
94927: PUSH
94928: EMPTY
94929: LIST
94930: LIST
94931: PUSH
94932: LD_INT 1
94934: PUSH
94935: LD_INT 3
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 1
94944: PUSH
94945: LD_INT 4
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: LD_INT 0
94954: PUSH
94955: LD_INT 4
94957: PUSH
94958: EMPTY
94959: LIST
94960: LIST
94961: PUSH
94962: LD_INT 1
94964: NEG
94965: PUSH
94966: LD_INT 3
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: LD_INT 1
94975: NEG
94976: PUSH
94977: LD_INT 2
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: LD_INT 2
94986: PUSH
94987: LD_INT 4
94989: PUSH
94990: EMPTY
94991: LIST
94992: LIST
94993: PUSH
94994: LD_INT 2
94996: NEG
94997: PUSH
94998: LD_INT 2
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 4
95007: NEG
95008: PUSH
95009: LD_INT 0
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 4
95018: NEG
95019: PUSH
95020: LD_INT 1
95022: NEG
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 3
95030: NEG
95031: PUSH
95032: LD_INT 0
95034: PUSH
95035: EMPTY
95036: LIST
95037: LIST
95038: PUSH
95039: LD_INT 3
95041: NEG
95042: PUSH
95043: LD_INT 1
95045: PUSH
95046: EMPTY
95047: LIST
95048: LIST
95049: PUSH
95050: LD_INT 4
95052: NEG
95053: PUSH
95054: LD_INT 1
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 5
95063: NEG
95064: PUSH
95065: LD_INT 0
95067: PUSH
95068: EMPTY
95069: LIST
95070: LIST
95071: PUSH
95072: LD_INT 5
95074: NEG
95075: PUSH
95076: LD_INT 1
95078: NEG
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 5
95086: NEG
95087: PUSH
95088: LD_INT 2
95090: NEG
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 3
95098: NEG
95099: PUSH
95100: LD_INT 2
95102: PUSH
95103: EMPTY
95104: LIST
95105: LIST
95106: PUSH
95107: LD_INT 3
95109: NEG
95110: PUSH
95111: LD_INT 3
95113: NEG
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 3
95121: NEG
95122: PUSH
95123: LD_INT 4
95125: NEG
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: PUSH
95131: LD_INT 2
95133: NEG
95134: PUSH
95135: LD_INT 3
95137: NEG
95138: PUSH
95139: EMPTY
95140: LIST
95141: LIST
95142: PUSH
95143: LD_INT 2
95145: NEG
95146: PUSH
95147: LD_INT 2
95149: NEG
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: LD_INT 3
95157: NEG
95158: PUSH
95159: LD_INT 2
95161: NEG
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 4
95169: NEG
95170: PUSH
95171: LD_INT 3
95173: NEG
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 4
95181: NEG
95182: PUSH
95183: LD_INT 4
95185: NEG
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PUSH
95191: LD_INT 2
95193: NEG
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 4
95205: NEG
95206: PUSH
95207: LD_INT 2
95209: NEG
95210: PUSH
95211: EMPTY
95212: LIST
95213: LIST
95214: PUSH
95215: LD_INT 0
95217: PUSH
95218: LD_INT 4
95220: NEG
95221: PUSH
95222: EMPTY
95223: LIST
95224: LIST
95225: PUSH
95226: LD_INT 0
95228: PUSH
95229: LD_INT 5
95231: NEG
95232: PUSH
95233: EMPTY
95234: LIST
95235: LIST
95236: PUSH
95237: LD_INT 1
95239: PUSH
95240: LD_INT 4
95242: NEG
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 1
95250: PUSH
95251: LD_INT 3
95253: NEG
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 0
95261: PUSH
95262: LD_INT 3
95264: NEG
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PUSH
95270: LD_INT 1
95272: NEG
95273: PUSH
95274: LD_INT 4
95276: NEG
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 1
95284: NEG
95285: PUSH
95286: LD_INT 5
95288: NEG
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: LD_INT 2
95296: PUSH
95297: LD_INT 3
95299: NEG
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: PUSH
95305: LD_INT 2
95307: NEG
95308: PUSH
95309: LD_INT 5
95311: NEG
95312: PUSH
95313: EMPTY
95314: LIST
95315: LIST
95316: PUSH
95317: EMPTY
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: LIST
95344: LIST
95345: LIST
95346: LIST
95347: LIST
95348: LIST
95349: LIST
95350: LIST
95351: LIST
95352: LIST
95353: LIST
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95364: LD_ADDR_VAR 0 31
95368: PUSH
95369: LD_INT 0
95371: PUSH
95372: LD_INT 4
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PUSH
95379: LD_INT 0
95381: PUSH
95382: LD_INT 3
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PUSH
95389: LD_INT 1
95391: PUSH
95392: LD_INT 4
95394: PUSH
95395: EMPTY
95396: LIST
95397: LIST
95398: PUSH
95399: LD_INT 1
95401: PUSH
95402: LD_INT 5
95404: PUSH
95405: EMPTY
95406: LIST
95407: LIST
95408: PUSH
95409: LD_INT 0
95411: PUSH
95412: LD_INT 5
95414: PUSH
95415: EMPTY
95416: LIST
95417: LIST
95418: PUSH
95419: LD_INT 1
95421: NEG
95422: PUSH
95423: LD_INT 4
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: PUSH
95430: LD_INT 1
95432: NEG
95433: PUSH
95434: LD_INT 3
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 2
95443: PUSH
95444: LD_INT 5
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 2
95453: NEG
95454: PUSH
95455: LD_INT 3
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 3
95464: NEG
95465: PUSH
95466: LD_INT 0
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 3
95475: NEG
95476: PUSH
95477: LD_INT 1
95479: NEG
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 2
95487: NEG
95488: PUSH
95489: LD_INT 0
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 2
95498: NEG
95499: PUSH
95500: LD_INT 1
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: PUSH
95507: LD_INT 3
95509: NEG
95510: PUSH
95511: LD_INT 1
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 4
95520: NEG
95521: PUSH
95522: LD_INT 0
95524: PUSH
95525: EMPTY
95526: LIST
95527: LIST
95528: PUSH
95529: LD_INT 4
95531: NEG
95532: PUSH
95533: LD_INT 1
95535: NEG
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 4
95543: NEG
95544: PUSH
95545: LD_INT 2
95547: NEG
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 2
95555: NEG
95556: PUSH
95557: LD_INT 2
95559: PUSH
95560: EMPTY
95561: LIST
95562: LIST
95563: PUSH
95564: LD_INT 4
95566: NEG
95567: PUSH
95568: LD_INT 4
95570: NEG
95571: PUSH
95572: EMPTY
95573: LIST
95574: LIST
95575: PUSH
95576: LD_INT 4
95578: NEG
95579: PUSH
95580: LD_INT 5
95582: NEG
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: LD_INT 3
95590: NEG
95591: PUSH
95592: LD_INT 4
95594: NEG
95595: PUSH
95596: EMPTY
95597: LIST
95598: LIST
95599: PUSH
95600: LD_INT 3
95602: NEG
95603: PUSH
95604: LD_INT 3
95606: NEG
95607: PUSH
95608: EMPTY
95609: LIST
95610: LIST
95611: PUSH
95612: LD_INT 4
95614: NEG
95615: PUSH
95616: LD_INT 3
95618: NEG
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PUSH
95624: LD_INT 5
95626: NEG
95627: PUSH
95628: LD_INT 4
95630: NEG
95631: PUSH
95632: EMPTY
95633: LIST
95634: LIST
95635: PUSH
95636: LD_INT 5
95638: NEG
95639: PUSH
95640: LD_INT 5
95642: NEG
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 3
95650: NEG
95651: PUSH
95652: LD_INT 5
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 5
95662: NEG
95663: PUSH
95664: LD_INT 3
95666: NEG
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: PUSH
95672: LD_INT 0
95674: PUSH
95675: LD_INT 3
95677: NEG
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 0
95685: PUSH
95686: LD_INT 4
95688: NEG
95689: PUSH
95690: EMPTY
95691: LIST
95692: LIST
95693: PUSH
95694: LD_INT 1
95696: PUSH
95697: LD_INT 3
95699: NEG
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 1
95707: PUSH
95708: LD_INT 2
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 0
95718: PUSH
95719: LD_INT 2
95721: NEG
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: PUSH
95727: LD_INT 1
95729: NEG
95730: PUSH
95731: LD_INT 3
95733: NEG
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 1
95741: NEG
95742: PUSH
95743: LD_INT 4
95745: NEG
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 2
95753: PUSH
95754: LD_INT 2
95756: NEG
95757: PUSH
95758: EMPTY
95759: LIST
95760: LIST
95761: PUSH
95762: LD_INT 2
95764: NEG
95765: PUSH
95766: LD_INT 4
95768: NEG
95769: PUSH
95770: EMPTY
95771: LIST
95772: LIST
95773: PUSH
95774: LD_INT 4
95776: PUSH
95777: LD_INT 0
95779: PUSH
95780: EMPTY
95781: LIST
95782: LIST
95783: PUSH
95784: LD_INT 4
95786: PUSH
95787: LD_INT 1
95789: NEG
95790: PUSH
95791: EMPTY
95792: LIST
95793: LIST
95794: PUSH
95795: LD_INT 5
95797: PUSH
95798: LD_INT 0
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 5
95807: PUSH
95808: LD_INT 1
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 4
95817: PUSH
95818: LD_INT 1
95820: PUSH
95821: EMPTY
95822: LIST
95823: LIST
95824: PUSH
95825: LD_INT 3
95827: PUSH
95828: LD_INT 0
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 3
95837: PUSH
95838: LD_INT 1
95840: NEG
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: PUSH
95846: LD_INT 3
95848: PUSH
95849: LD_INT 2
95851: NEG
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 5
95859: PUSH
95860: LD_INT 2
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95914: LD_ADDR_VAR 0 32
95918: PUSH
95919: LD_INT 4
95921: NEG
95922: PUSH
95923: LD_INT 0
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 4
95932: NEG
95933: PUSH
95934: LD_INT 1
95936: NEG
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: LD_INT 3
95944: NEG
95945: PUSH
95946: LD_INT 0
95948: PUSH
95949: EMPTY
95950: LIST
95951: LIST
95952: PUSH
95953: LD_INT 3
95955: NEG
95956: PUSH
95957: LD_INT 1
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 4
95966: NEG
95967: PUSH
95968: LD_INT 1
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 5
95977: NEG
95978: PUSH
95979: LD_INT 0
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 5
95988: NEG
95989: PUSH
95990: LD_INT 1
95992: NEG
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 5
96000: NEG
96001: PUSH
96002: LD_INT 2
96004: NEG
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 3
96012: NEG
96013: PUSH
96014: LD_INT 2
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: PUSH
96021: LD_INT 3
96023: NEG
96024: PUSH
96025: LD_INT 3
96027: NEG
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: PUSH
96033: LD_INT 3
96035: NEG
96036: PUSH
96037: LD_INT 4
96039: NEG
96040: PUSH
96041: EMPTY
96042: LIST
96043: LIST
96044: PUSH
96045: LD_INT 2
96047: NEG
96048: PUSH
96049: LD_INT 3
96051: NEG
96052: PUSH
96053: EMPTY
96054: LIST
96055: LIST
96056: PUSH
96057: LD_INT 2
96059: NEG
96060: PUSH
96061: LD_INT 2
96063: NEG
96064: PUSH
96065: EMPTY
96066: LIST
96067: LIST
96068: PUSH
96069: LD_INT 3
96071: NEG
96072: PUSH
96073: LD_INT 2
96075: NEG
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 4
96083: NEG
96084: PUSH
96085: LD_INT 3
96087: NEG
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 4
96095: NEG
96096: PUSH
96097: LD_INT 4
96099: NEG
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: PUSH
96105: LD_INT 2
96107: NEG
96108: PUSH
96109: LD_INT 4
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 4
96119: NEG
96120: PUSH
96121: LD_INT 2
96123: NEG
96124: PUSH
96125: EMPTY
96126: LIST
96127: LIST
96128: PUSH
96129: LD_INT 0
96131: PUSH
96132: LD_INT 4
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 0
96142: PUSH
96143: LD_INT 5
96145: NEG
96146: PUSH
96147: EMPTY
96148: LIST
96149: LIST
96150: PUSH
96151: LD_INT 1
96153: PUSH
96154: LD_INT 4
96156: NEG
96157: PUSH
96158: EMPTY
96159: LIST
96160: LIST
96161: PUSH
96162: LD_INT 1
96164: PUSH
96165: LD_INT 3
96167: NEG
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 0
96175: PUSH
96176: LD_INT 3
96178: NEG
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: LD_INT 1
96186: NEG
96187: PUSH
96188: LD_INT 4
96190: NEG
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 1
96198: NEG
96199: PUSH
96200: LD_INT 5
96202: NEG
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 2
96210: PUSH
96211: LD_INT 3
96213: NEG
96214: PUSH
96215: EMPTY
96216: LIST
96217: LIST
96218: PUSH
96219: LD_INT 2
96221: NEG
96222: PUSH
96223: LD_INT 5
96225: NEG
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: PUSH
96231: LD_INT 3
96233: PUSH
96234: LD_INT 0
96236: PUSH
96237: EMPTY
96238: LIST
96239: LIST
96240: PUSH
96241: LD_INT 3
96243: PUSH
96244: LD_INT 1
96246: NEG
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 4
96254: PUSH
96255: LD_INT 0
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PUSH
96262: LD_INT 4
96264: PUSH
96265: LD_INT 1
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 3
96274: PUSH
96275: LD_INT 1
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 2
96284: PUSH
96285: LD_INT 0
96287: PUSH
96288: EMPTY
96289: LIST
96290: LIST
96291: PUSH
96292: LD_INT 2
96294: PUSH
96295: LD_INT 1
96297: NEG
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 2
96305: PUSH
96306: LD_INT 2
96308: NEG
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 4
96316: PUSH
96317: LD_INT 2
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 4
96326: PUSH
96327: LD_INT 4
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 4
96336: PUSH
96337: LD_INT 3
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 5
96346: PUSH
96347: LD_INT 4
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 5
96356: PUSH
96357: LD_INT 5
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 4
96366: PUSH
96367: LD_INT 5
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: LD_INT 4
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 3
96386: PUSH
96387: LD_INT 3
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 5
96396: PUSH
96397: LD_INT 3
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 3
96406: PUSH
96407: LD_INT 5
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96461: LD_ADDR_VAR 0 33
96465: PUSH
96466: LD_INT 4
96468: NEG
96469: PUSH
96470: LD_INT 4
96472: NEG
96473: PUSH
96474: EMPTY
96475: LIST
96476: LIST
96477: PUSH
96478: LD_INT 4
96480: NEG
96481: PUSH
96482: LD_INT 5
96484: NEG
96485: PUSH
96486: EMPTY
96487: LIST
96488: LIST
96489: PUSH
96490: LD_INT 3
96492: NEG
96493: PUSH
96494: LD_INT 4
96496: NEG
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: PUSH
96502: LD_INT 3
96504: NEG
96505: PUSH
96506: LD_INT 3
96508: NEG
96509: PUSH
96510: EMPTY
96511: LIST
96512: LIST
96513: PUSH
96514: LD_INT 4
96516: NEG
96517: PUSH
96518: LD_INT 3
96520: NEG
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 5
96528: NEG
96529: PUSH
96530: LD_INT 4
96532: NEG
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: PUSH
96538: LD_INT 5
96540: NEG
96541: PUSH
96542: LD_INT 5
96544: NEG
96545: PUSH
96546: EMPTY
96547: LIST
96548: LIST
96549: PUSH
96550: LD_INT 3
96552: NEG
96553: PUSH
96554: LD_INT 5
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 5
96564: NEG
96565: PUSH
96566: LD_INT 3
96568: NEG
96569: PUSH
96570: EMPTY
96571: LIST
96572: LIST
96573: PUSH
96574: LD_INT 0
96576: PUSH
96577: LD_INT 3
96579: NEG
96580: PUSH
96581: EMPTY
96582: LIST
96583: LIST
96584: PUSH
96585: LD_INT 0
96587: PUSH
96588: LD_INT 4
96590: NEG
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: PUSH
96596: LD_INT 1
96598: PUSH
96599: LD_INT 3
96601: NEG
96602: PUSH
96603: EMPTY
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 1
96609: PUSH
96610: LD_INT 2
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 0
96620: PUSH
96621: LD_INT 2
96623: NEG
96624: PUSH
96625: EMPTY
96626: LIST
96627: LIST
96628: PUSH
96629: LD_INT 1
96631: NEG
96632: PUSH
96633: LD_INT 3
96635: NEG
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 1
96643: NEG
96644: PUSH
96645: LD_INT 4
96647: NEG
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 2
96655: PUSH
96656: LD_INT 2
96658: NEG
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: PUSH
96664: LD_INT 2
96666: NEG
96667: PUSH
96668: LD_INT 4
96670: NEG
96671: PUSH
96672: EMPTY
96673: LIST
96674: LIST
96675: PUSH
96676: LD_INT 4
96678: PUSH
96679: LD_INT 0
96681: PUSH
96682: EMPTY
96683: LIST
96684: LIST
96685: PUSH
96686: LD_INT 4
96688: PUSH
96689: LD_INT 1
96691: NEG
96692: PUSH
96693: EMPTY
96694: LIST
96695: LIST
96696: PUSH
96697: LD_INT 5
96699: PUSH
96700: LD_INT 0
96702: PUSH
96703: EMPTY
96704: LIST
96705: LIST
96706: PUSH
96707: LD_INT 5
96709: PUSH
96710: LD_INT 1
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 4
96719: PUSH
96720: LD_INT 1
96722: PUSH
96723: EMPTY
96724: LIST
96725: LIST
96726: PUSH
96727: LD_INT 3
96729: PUSH
96730: LD_INT 0
96732: PUSH
96733: EMPTY
96734: LIST
96735: LIST
96736: PUSH
96737: LD_INT 3
96739: PUSH
96740: LD_INT 1
96742: NEG
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: LD_INT 3
96750: PUSH
96751: LD_INT 2
96753: NEG
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: PUSH
96759: LD_INT 5
96761: PUSH
96762: LD_INT 2
96764: PUSH
96765: EMPTY
96766: LIST
96767: LIST
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: LD_INT 3
96774: PUSH
96775: EMPTY
96776: LIST
96777: LIST
96778: PUSH
96779: LD_INT 3
96781: PUSH
96782: LD_INT 2
96784: PUSH
96785: EMPTY
96786: LIST
96787: LIST
96788: PUSH
96789: LD_INT 4
96791: PUSH
96792: LD_INT 3
96794: PUSH
96795: EMPTY
96796: LIST
96797: LIST
96798: PUSH
96799: LD_INT 4
96801: PUSH
96802: LD_INT 4
96804: PUSH
96805: EMPTY
96806: LIST
96807: LIST
96808: PUSH
96809: LD_INT 3
96811: PUSH
96812: LD_INT 4
96814: PUSH
96815: EMPTY
96816: LIST
96817: LIST
96818: PUSH
96819: LD_INT 2
96821: PUSH
96822: LD_INT 3
96824: PUSH
96825: EMPTY
96826: LIST
96827: LIST
96828: PUSH
96829: LD_INT 2
96831: PUSH
96832: LD_INT 2
96834: PUSH
96835: EMPTY
96836: LIST
96837: LIST
96838: PUSH
96839: LD_INT 4
96841: PUSH
96842: LD_INT 2
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: PUSH
96849: LD_INT 2
96851: PUSH
96852: LD_INT 4
96854: PUSH
96855: EMPTY
96856: LIST
96857: LIST
96858: PUSH
96859: LD_INT 0
96861: PUSH
96862: LD_INT 4
96864: PUSH
96865: EMPTY
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 0
96871: PUSH
96872: LD_INT 3
96874: PUSH
96875: EMPTY
96876: LIST
96877: LIST
96878: PUSH
96879: LD_INT 1
96881: PUSH
96882: LD_INT 4
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PUSH
96889: LD_INT 1
96891: PUSH
96892: LD_INT 5
96894: PUSH
96895: EMPTY
96896: LIST
96897: LIST
96898: PUSH
96899: LD_INT 0
96901: PUSH
96902: LD_INT 5
96904: PUSH
96905: EMPTY
96906: LIST
96907: LIST
96908: PUSH
96909: LD_INT 1
96911: NEG
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PUSH
96920: LD_INT 1
96922: NEG
96923: PUSH
96924: LD_INT 3
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 2
96933: PUSH
96934: LD_INT 5
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: PUSH
96941: LD_INT 2
96943: NEG
96944: PUSH
96945: LD_INT 3
96947: PUSH
96948: EMPTY
96949: LIST
96950: LIST
96951: PUSH
96952: EMPTY
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96999: LD_ADDR_VAR 0 34
97003: PUSH
97004: LD_INT 0
97006: PUSH
97007: LD_INT 4
97009: NEG
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: PUSH
97015: LD_INT 0
97017: PUSH
97018: LD_INT 5
97020: NEG
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: PUSH
97026: LD_INT 1
97028: PUSH
97029: LD_INT 4
97031: NEG
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: LD_INT 1
97039: PUSH
97040: LD_INT 3
97042: NEG
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 0
97050: PUSH
97051: LD_INT 3
97053: NEG
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: PUSH
97059: LD_INT 1
97061: NEG
97062: PUSH
97063: LD_INT 4
97065: NEG
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 1
97073: NEG
97074: PUSH
97075: LD_INT 5
97077: NEG
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 2
97085: PUSH
97086: LD_INT 3
97088: NEG
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PUSH
97094: LD_INT 2
97096: NEG
97097: PUSH
97098: LD_INT 5
97100: NEG
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PUSH
97106: LD_INT 3
97108: PUSH
97109: LD_INT 0
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: PUSH
97116: LD_INT 3
97118: PUSH
97119: LD_INT 1
97121: NEG
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 4
97129: PUSH
97130: LD_INT 0
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: PUSH
97137: LD_INT 4
97139: PUSH
97140: LD_INT 1
97142: PUSH
97143: EMPTY
97144: LIST
97145: LIST
97146: PUSH
97147: LD_INT 3
97149: PUSH
97150: LD_INT 1
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 2
97159: PUSH
97160: LD_INT 0
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 2
97169: PUSH
97170: LD_INT 1
97172: NEG
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: PUSH
97178: LD_INT 2
97180: PUSH
97181: LD_INT 2
97183: NEG
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PUSH
97189: LD_INT 4
97191: PUSH
97192: LD_INT 2
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: LD_INT 4
97201: PUSH
97202: LD_INT 4
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: PUSH
97209: LD_INT 4
97211: PUSH
97212: LD_INT 3
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: PUSH
97219: LD_INT 5
97221: PUSH
97222: LD_INT 4
97224: PUSH
97225: EMPTY
97226: LIST
97227: LIST
97228: PUSH
97229: LD_INT 5
97231: PUSH
97232: LD_INT 5
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: PUSH
97239: LD_INT 4
97241: PUSH
97242: LD_INT 5
97244: PUSH
97245: EMPTY
97246: LIST
97247: LIST
97248: PUSH
97249: LD_INT 3
97251: PUSH
97252: LD_INT 4
97254: PUSH
97255: EMPTY
97256: LIST
97257: LIST
97258: PUSH
97259: LD_INT 3
97261: PUSH
97262: LD_INT 3
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 5
97271: PUSH
97272: LD_INT 3
97274: PUSH
97275: EMPTY
97276: LIST
97277: LIST
97278: PUSH
97279: LD_INT 3
97281: PUSH
97282: LD_INT 5
97284: PUSH
97285: EMPTY
97286: LIST
97287: LIST
97288: PUSH
97289: LD_INT 0
97291: PUSH
97292: LD_INT 3
97294: PUSH
97295: EMPTY
97296: LIST
97297: LIST
97298: PUSH
97299: LD_INT 0
97301: PUSH
97302: LD_INT 2
97304: PUSH
97305: EMPTY
97306: LIST
97307: LIST
97308: PUSH
97309: LD_INT 1
97311: PUSH
97312: LD_INT 3
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: PUSH
97319: LD_INT 1
97321: PUSH
97322: LD_INT 4
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: LD_INT 0
97331: PUSH
97332: LD_INT 4
97334: PUSH
97335: EMPTY
97336: LIST
97337: LIST
97338: PUSH
97339: LD_INT 1
97341: NEG
97342: PUSH
97343: LD_INT 3
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: LD_INT 1
97352: NEG
97353: PUSH
97354: LD_INT 2
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: PUSH
97361: LD_INT 2
97363: PUSH
97364: LD_INT 4
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: PUSH
97371: LD_INT 2
97373: NEG
97374: PUSH
97375: LD_INT 2
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 4
97384: NEG
97385: PUSH
97386: LD_INT 0
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 4
97395: NEG
97396: PUSH
97397: LD_INT 1
97399: NEG
97400: PUSH
97401: EMPTY
97402: LIST
97403: LIST
97404: PUSH
97405: LD_INT 3
97407: NEG
97408: PUSH
97409: LD_INT 0
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: LD_INT 3
97418: NEG
97419: PUSH
97420: LD_INT 1
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 4
97429: NEG
97430: PUSH
97431: LD_INT 1
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 5
97440: NEG
97441: PUSH
97442: LD_INT 0
97444: PUSH
97445: EMPTY
97446: LIST
97447: LIST
97448: PUSH
97449: LD_INT 5
97451: NEG
97452: PUSH
97453: LD_INT 1
97455: NEG
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: PUSH
97461: LD_INT 5
97463: NEG
97464: PUSH
97465: LD_INT 2
97467: NEG
97468: PUSH
97469: EMPTY
97470: LIST
97471: LIST
97472: PUSH
97473: LD_INT 3
97475: NEG
97476: PUSH
97477: LD_INT 2
97479: PUSH
97480: EMPTY
97481: LIST
97482: LIST
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: ST_TO_ADDR
// end ; end ;
97531: GO 97534
97533: POP
// case btype of b_depot , b_warehouse :
97534: LD_VAR 0 1
97538: PUSH
97539: LD_INT 0
97541: DOUBLE
97542: EQUAL
97543: IFTRUE 97553
97545: LD_INT 1
97547: DOUBLE
97548: EQUAL
97549: IFTRUE 97553
97551: GO 97754
97553: POP
// case nation of nation_american :
97554: LD_VAR 0 5
97558: PUSH
97559: LD_INT 1
97561: DOUBLE
97562: EQUAL
97563: IFTRUE 97567
97565: GO 97623
97567: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97568: LD_ADDR_VAR 0 9
97572: PUSH
97573: LD_VAR 0 11
97577: PUSH
97578: LD_VAR 0 12
97582: PUSH
97583: LD_VAR 0 13
97587: PUSH
97588: LD_VAR 0 14
97592: PUSH
97593: LD_VAR 0 15
97597: PUSH
97598: LD_VAR 0 16
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: PUSH
97611: LD_VAR 0 4
97615: PUSH
97616: LD_INT 1
97618: PLUS
97619: ARRAY
97620: ST_TO_ADDR
97621: GO 97752
97623: LD_INT 2
97625: DOUBLE
97626: EQUAL
97627: IFTRUE 97631
97629: GO 97687
97631: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97632: LD_ADDR_VAR 0 9
97636: PUSH
97637: LD_VAR 0 17
97641: PUSH
97642: LD_VAR 0 18
97646: PUSH
97647: LD_VAR 0 19
97651: PUSH
97652: LD_VAR 0 20
97656: PUSH
97657: LD_VAR 0 21
97661: PUSH
97662: LD_VAR 0 22
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: PUSH
97675: LD_VAR 0 4
97679: PUSH
97680: LD_INT 1
97682: PLUS
97683: ARRAY
97684: ST_TO_ADDR
97685: GO 97752
97687: LD_INT 3
97689: DOUBLE
97690: EQUAL
97691: IFTRUE 97695
97693: GO 97751
97695: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97696: LD_ADDR_VAR 0 9
97700: PUSH
97701: LD_VAR 0 23
97705: PUSH
97706: LD_VAR 0 24
97710: PUSH
97711: LD_VAR 0 25
97715: PUSH
97716: LD_VAR 0 26
97720: PUSH
97721: LD_VAR 0 27
97725: PUSH
97726: LD_VAR 0 28
97730: PUSH
97731: EMPTY
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: PUSH
97739: LD_VAR 0 4
97743: PUSH
97744: LD_INT 1
97746: PLUS
97747: ARRAY
97748: ST_TO_ADDR
97749: GO 97752
97751: POP
97752: GO 98307
97754: LD_INT 2
97756: DOUBLE
97757: EQUAL
97758: IFTRUE 97768
97760: LD_INT 3
97762: DOUBLE
97763: EQUAL
97764: IFTRUE 97768
97766: GO 97824
97768: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97769: LD_ADDR_VAR 0 9
97773: PUSH
97774: LD_VAR 0 29
97778: PUSH
97779: LD_VAR 0 30
97783: PUSH
97784: LD_VAR 0 31
97788: PUSH
97789: LD_VAR 0 32
97793: PUSH
97794: LD_VAR 0 33
97798: PUSH
97799: LD_VAR 0 34
97803: PUSH
97804: EMPTY
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: PUSH
97812: LD_VAR 0 4
97816: PUSH
97817: LD_INT 1
97819: PLUS
97820: ARRAY
97821: ST_TO_ADDR
97822: GO 98307
97824: LD_INT 16
97826: DOUBLE
97827: EQUAL
97828: IFTRUE 97886
97830: LD_INT 17
97832: DOUBLE
97833: EQUAL
97834: IFTRUE 97886
97836: LD_INT 18
97838: DOUBLE
97839: EQUAL
97840: IFTRUE 97886
97842: LD_INT 19
97844: DOUBLE
97845: EQUAL
97846: IFTRUE 97886
97848: LD_INT 22
97850: DOUBLE
97851: EQUAL
97852: IFTRUE 97886
97854: LD_INT 20
97856: DOUBLE
97857: EQUAL
97858: IFTRUE 97886
97860: LD_INT 21
97862: DOUBLE
97863: EQUAL
97864: IFTRUE 97886
97866: LD_INT 23
97868: DOUBLE
97869: EQUAL
97870: IFTRUE 97886
97872: LD_INT 24
97874: DOUBLE
97875: EQUAL
97876: IFTRUE 97886
97878: LD_INT 25
97880: DOUBLE
97881: EQUAL
97882: IFTRUE 97886
97884: GO 97942
97886: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97887: LD_ADDR_VAR 0 9
97891: PUSH
97892: LD_VAR 0 35
97896: PUSH
97897: LD_VAR 0 36
97901: PUSH
97902: LD_VAR 0 37
97906: PUSH
97907: LD_VAR 0 38
97911: PUSH
97912: LD_VAR 0 39
97916: PUSH
97917: LD_VAR 0 40
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: PUSH
97930: LD_VAR 0 4
97934: PUSH
97935: LD_INT 1
97937: PLUS
97938: ARRAY
97939: ST_TO_ADDR
97940: GO 98307
97942: LD_INT 6
97944: DOUBLE
97945: EQUAL
97946: IFTRUE 97998
97948: LD_INT 7
97950: DOUBLE
97951: EQUAL
97952: IFTRUE 97998
97954: LD_INT 8
97956: DOUBLE
97957: EQUAL
97958: IFTRUE 97998
97960: LD_INT 13
97962: DOUBLE
97963: EQUAL
97964: IFTRUE 97998
97966: LD_INT 12
97968: DOUBLE
97969: EQUAL
97970: IFTRUE 97998
97972: LD_INT 15
97974: DOUBLE
97975: EQUAL
97976: IFTRUE 97998
97978: LD_INT 11
97980: DOUBLE
97981: EQUAL
97982: IFTRUE 97998
97984: LD_INT 14
97986: DOUBLE
97987: EQUAL
97988: IFTRUE 97998
97990: LD_INT 10
97992: DOUBLE
97993: EQUAL
97994: IFTRUE 97998
97996: GO 98054
97998: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97999: LD_ADDR_VAR 0 9
98003: PUSH
98004: LD_VAR 0 41
98008: PUSH
98009: LD_VAR 0 42
98013: PUSH
98014: LD_VAR 0 43
98018: PUSH
98019: LD_VAR 0 44
98023: PUSH
98024: LD_VAR 0 45
98028: PUSH
98029: LD_VAR 0 46
98033: PUSH
98034: EMPTY
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: PUSH
98042: LD_VAR 0 4
98046: PUSH
98047: LD_INT 1
98049: PLUS
98050: ARRAY
98051: ST_TO_ADDR
98052: GO 98307
98054: LD_INT 36
98056: DOUBLE
98057: EQUAL
98058: IFTRUE 98062
98060: GO 98118
98062: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98063: LD_ADDR_VAR 0 9
98067: PUSH
98068: LD_VAR 0 47
98072: PUSH
98073: LD_VAR 0 48
98077: PUSH
98078: LD_VAR 0 49
98082: PUSH
98083: LD_VAR 0 50
98087: PUSH
98088: LD_VAR 0 51
98092: PUSH
98093: LD_VAR 0 52
98097: PUSH
98098: EMPTY
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: PUSH
98106: LD_VAR 0 4
98110: PUSH
98111: LD_INT 1
98113: PLUS
98114: ARRAY
98115: ST_TO_ADDR
98116: GO 98307
98118: LD_INT 4
98120: DOUBLE
98121: EQUAL
98122: IFTRUE 98144
98124: LD_INT 5
98126: DOUBLE
98127: EQUAL
98128: IFTRUE 98144
98130: LD_INT 34
98132: DOUBLE
98133: EQUAL
98134: IFTRUE 98144
98136: LD_INT 37
98138: DOUBLE
98139: EQUAL
98140: IFTRUE 98144
98142: GO 98200
98144: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98145: LD_ADDR_VAR 0 9
98149: PUSH
98150: LD_VAR 0 53
98154: PUSH
98155: LD_VAR 0 54
98159: PUSH
98160: LD_VAR 0 55
98164: PUSH
98165: LD_VAR 0 56
98169: PUSH
98170: LD_VAR 0 57
98174: PUSH
98175: LD_VAR 0 58
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: LIST
98186: LIST
98187: PUSH
98188: LD_VAR 0 4
98192: PUSH
98193: LD_INT 1
98195: PLUS
98196: ARRAY
98197: ST_TO_ADDR
98198: GO 98307
98200: LD_INT 31
98202: DOUBLE
98203: EQUAL
98204: IFTRUE 98250
98206: LD_INT 32
98208: DOUBLE
98209: EQUAL
98210: IFTRUE 98250
98212: LD_INT 33
98214: DOUBLE
98215: EQUAL
98216: IFTRUE 98250
98218: LD_INT 27
98220: DOUBLE
98221: EQUAL
98222: IFTRUE 98250
98224: LD_INT 26
98226: DOUBLE
98227: EQUAL
98228: IFTRUE 98250
98230: LD_INT 28
98232: DOUBLE
98233: EQUAL
98234: IFTRUE 98250
98236: LD_INT 29
98238: DOUBLE
98239: EQUAL
98240: IFTRUE 98250
98242: LD_INT 30
98244: DOUBLE
98245: EQUAL
98246: IFTRUE 98250
98248: GO 98306
98250: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98251: LD_ADDR_VAR 0 9
98255: PUSH
98256: LD_VAR 0 59
98260: PUSH
98261: LD_VAR 0 60
98265: PUSH
98266: LD_VAR 0 61
98270: PUSH
98271: LD_VAR 0 62
98275: PUSH
98276: LD_VAR 0 63
98280: PUSH
98281: LD_VAR 0 64
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: PUSH
98294: LD_VAR 0 4
98298: PUSH
98299: LD_INT 1
98301: PLUS
98302: ARRAY
98303: ST_TO_ADDR
98304: GO 98307
98306: POP
// temp_list2 = [ ] ;
98307: LD_ADDR_VAR 0 10
98311: PUSH
98312: EMPTY
98313: ST_TO_ADDR
// for i in temp_list do
98314: LD_ADDR_VAR 0 8
98318: PUSH
98319: LD_VAR 0 9
98323: PUSH
98324: FOR_IN
98325: IFFALSE 98377
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98327: LD_ADDR_VAR 0 10
98331: PUSH
98332: LD_VAR 0 10
98336: PUSH
98337: LD_VAR 0 8
98341: PUSH
98342: LD_INT 1
98344: ARRAY
98345: PUSH
98346: LD_VAR 0 2
98350: PLUS
98351: PUSH
98352: LD_VAR 0 8
98356: PUSH
98357: LD_INT 2
98359: ARRAY
98360: PUSH
98361: LD_VAR 0 3
98365: PLUS
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: EMPTY
98372: LIST
98373: ADD
98374: ST_TO_ADDR
98375: GO 98324
98377: POP
98378: POP
// result = temp_list2 ;
98379: LD_ADDR_VAR 0 7
98383: PUSH
98384: LD_VAR 0 10
98388: ST_TO_ADDR
// end ;
98389: LD_VAR 0 7
98393: RET
// export function EnemyInRange ( unit , dist ) ; begin
98394: LD_INT 0
98396: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98397: LD_ADDR_VAR 0 3
98401: PUSH
98402: LD_VAR 0 1
98406: PPUSH
98407: CALL_OW 255
98411: PPUSH
98412: LD_VAR 0 1
98416: PPUSH
98417: CALL_OW 250
98421: PPUSH
98422: LD_VAR 0 1
98426: PPUSH
98427: CALL_OW 251
98431: PPUSH
98432: LD_VAR 0 2
98436: PPUSH
98437: CALL 72498 0 4
98441: PUSH
98442: LD_INT 4
98444: ARRAY
98445: ST_TO_ADDR
// end ;
98446: LD_VAR 0 3
98450: RET
// export function PlayerSeeMe ( unit ) ; begin
98451: LD_INT 0
98453: PPUSH
// result := See ( your_side , unit ) ;
98454: LD_ADDR_VAR 0 2
98458: PUSH
98459: LD_OWVAR 2
98463: PPUSH
98464: LD_VAR 0 1
98468: PPUSH
98469: CALL_OW 292
98473: ST_TO_ADDR
// end ;
98474: LD_VAR 0 2
98478: RET
// export function ReverseDir ( unit ) ; begin
98479: LD_INT 0
98481: PPUSH
// if not unit then
98482: LD_VAR 0 1
98486: NOT
98487: IFFALSE 98491
// exit ;
98489: GO 98537
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98491: LD_ADDR_VAR 0 2
98495: PUSH
98496: LD_INT 3
98498: PUSH
98499: LD_INT 4
98501: PUSH
98502: LD_INT 5
98504: PUSH
98505: LD_INT 0
98507: PUSH
98508: LD_INT 1
98510: PUSH
98511: LD_INT 2
98513: PUSH
98514: EMPTY
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: PUSH
98522: LD_VAR 0 1
98526: PPUSH
98527: CALL_OW 254
98531: PUSH
98532: LD_INT 1
98534: PLUS
98535: ARRAY
98536: ST_TO_ADDR
// end ;
98537: LD_VAR 0 2
98541: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98542: LD_INT 0
98544: PPUSH
98545: PPUSH
98546: PPUSH
98547: PPUSH
98548: PPUSH
// if not hexes then
98549: LD_VAR 0 2
98553: NOT
98554: IFFALSE 98558
// exit ;
98556: GO 98706
// dist := 9999 ;
98558: LD_ADDR_VAR 0 5
98562: PUSH
98563: LD_INT 9999
98565: ST_TO_ADDR
// for i = 1 to hexes do
98566: LD_ADDR_VAR 0 4
98570: PUSH
98571: DOUBLE
98572: LD_INT 1
98574: DEC
98575: ST_TO_ADDR
98576: LD_VAR 0 2
98580: PUSH
98581: FOR_TO
98582: IFFALSE 98694
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98584: LD_VAR 0 1
98588: PPUSH
98589: LD_VAR 0 2
98593: PUSH
98594: LD_VAR 0 4
98598: ARRAY
98599: PUSH
98600: LD_INT 1
98602: ARRAY
98603: PPUSH
98604: LD_VAR 0 2
98608: PUSH
98609: LD_VAR 0 4
98613: ARRAY
98614: PUSH
98615: LD_INT 2
98617: ARRAY
98618: PPUSH
98619: CALL_OW 297
98623: PUSH
98624: LD_VAR 0 5
98628: LESS
98629: IFFALSE 98692
// begin hex := hexes [ i ] ;
98631: LD_ADDR_VAR 0 7
98635: PUSH
98636: LD_VAR 0 2
98640: PUSH
98641: LD_VAR 0 4
98645: ARRAY
98646: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98647: LD_ADDR_VAR 0 5
98651: PUSH
98652: LD_VAR 0 1
98656: PPUSH
98657: LD_VAR 0 2
98661: PUSH
98662: LD_VAR 0 4
98666: ARRAY
98667: PUSH
98668: LD_INT 1
98670: ARRAY
98671: PPUSH
98672: LD_VAR 0 2
98676: PUSH
98677: LD_VAR 0 4
98681: ARRAY
98682: PUSH
98683: LD_INT 2
98685: ARRAY
98686: PPUSH
98687: CALL_OW 297
98691: ST_TO_ADDR
// end ; end ;
98692: GO 98581
98694: POP
98695: POP
// result := hex ;
98696: LD_ADDR_VAR 0 3
98700: PUSH
98701: LD_VAR 0 7
98705: ST_TO_ADDR
// end ;
98706: LD_VAR 0 3
98710: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98711: LD_INT 0
98713: PPUSH
98714: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98715: LD_VAR 0 1
98719: NOT
98720: PUSH
98721: LD_VAR 0 1
98725: PUSH
98726: LD_INT 21
98728: PUSH
98729: LD_INT 2
98731: PUSH
98732: EMPTY
98733: LIST
98734: LIST
98735: PUSH
98736: LD_INT 23
98738: PUSH
98739: LD_INT 2
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PPUSH
98750: CALL_OW 69
98754: IN
98755: NOT
98756: OR
98757: IFFALSE 98761
// exit ;
98759: GO 98808
// for i = 1 to 3 do
98761: LD_ADDR_VAR 0 3
98765: PUSH
98766: DOUBLE
98767: LD_INT 1
98769: DEC
98770: ST_TO_ADDR
98771: LD_INT 3
98773: PUSH
98774: FOR_TO
98775: IFFALSE 98806
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98777: LD_VAR 0 1
98781: PPUSH
98782: CALL_OW 250
98786: PPUSH
98787: LD_VAR 0 1
98791: PPUSH
98792: CALL_OW 251
98796: PPUSH
98797: LD_INT 1
98799: PPUSH
98800: CALL_OW 453
98804: GO 98774
98806: POP
98807: POP
// end ;
98808: LD_VAR 0 2
98812: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98813: LD_INT 0
98815: PPUSH
98816: PPUSH
98817: PPUSH
98818: PPUSH
98819: PPUSH
98820: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98821: LD_VAR 0 1
98825: NOT
98826: PUSH
98827: LD_VAR 0 2
98831: NOT
98832: OR
98833: PUSH
98834: LD_VAR 0 1
98838: PPUSH
98839: CALL_OW 314
98843: OR
98844: IFFALSE 98848
// exit ;
98846: GO 99289
// x := GetX ( enemy_unit ) ;
98848: LD_ADDR_VAR 0 7
98852: PUSH
98853: LD_VAR 0 2
98857: PPUSH
98858: CALL_OW 250
98862: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98863: LD_ADDR_VAR 0 8
98867: PUSH
98868: LD_VAR 0 2
98872: PPUSH
98873: CALL_OW 251
98877: ST_TO_ADDR
// if not x or not y then
98878: LD_VAR 0 7
98882: NOT
98883: PUSH
98884: LD_VAR 0 8
98888: NOT
98889: OR
98890: IFFALSE 98894
// exit ;
98892: GO 99289
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98894: LD_ADDR_VAR 0 6
98898: PUSH
98899: LD_VAR 0 7
98903: PPUSH
98904: LD_INT 0
98906: PPUSH
98907: LD_INT 4
98909: PPUSH
98910: CALL_OW 272
98914: PUSH
98915: LD_VAR 0 8
98919: PPUSH
98920: LD_INT 0
98922: PPUSH
98923: LD_INT 4
98925: PPUSH
98926: CALL_OW 273
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_VAR 0 7
98939: PPUSH
98940: LD_INT 1
98942: PPUSH
98943: LD_INT 4
98945: PPUSH
98946: CALL_OW 272
98950: PUSH
98951: LD_VAR 0 8
98955: PPUSH
98956: LD_INT 1
98958: PPUSH
98959: LD_INT 4
98961: PPUSH
98962: CALL_OW 273
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: PUSH
98971: LD_VAR 0 7
98975: PPUSH
98976: LD_INT 2
98978: PPUSH
98979: LD_INT 4
98981: PPUSH
98982: CALL_OW 272
98986: PUSH
98987: LD_VAR 0 8
98991: PPUSH
98992: LD_INT 2
98994: PPUSH
98995: LD_INT 4
98997: PPUSH
98998: CALL_OW 273
99002: PUSH
99003: EMPTY
99004: LIST
99005: LIST
99006: PUSH
99007: LD_VAR 0 7
99011: PPUSH
99012: LD_INT 3
99014: PPUSH
99015: LD_INT 4
99017: PPUSH
99018: CALL_OW 272
99022: PUSH
99023: LD_VAR 0 8
99027: PPUSH
99028: LD_INT 3
99030: PPUSH
99031: LD_INT 4
99033: PPUSH
99034: CALL_OW 273
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PUSH
99043: LD_VAR 0 7
99047: PPUSH
99048: LD_INT 4
99050: PPUSH
99051: LD_INT 4
99053: PPUSH
99054: CALL_OW 272
99058: PUSH
99059: LD_VAR 0 8
99063: PPUSH
99064: LD_INT 4
99066: PPUSH
99067: LD_INT 4
99069: PPUSH
99070: CALL_OW 273
99074: PUSH
99075: EMPTY
99076: LIST
99077: LIST
99078: PUSH
99079: LD_VAR 0 7
99083: PPUSH
99084: LD_INT 5
99086: PPUSH
99087: LD_INT 4
99089: PPUSH
99090: CALL_OW 272
99094: PUSH
99095: LD_VAR 0 8
99099: PPUSH
99100: LD_INT 5
99102: PPUSH
99103: LD_INT 4
99105: PPUSH
99106: CALL_OW 273
99110: PUSH
99111: EMPTY
99112: LIST
99113: LIST
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: ST_TO_ADDR
// for i = tmp downto 1 do
99123: LD_ADDR_VAR 0 4
99127: PUSH
99128: DOUBLE
99129: LD_VAR 0 6
99133: INC
99134: ST_TO_ADDR
99135: LD_INT 1
99137: PUSH
99138: FOR_DOWNTO
99139: IFFALSE 99240
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99141: LD_VAR 0 6
99145: PUSH
99146: LD_VAR 0 4
99150: ARRAY
99151: PUSH
99152: LD_INT 1
99154: ARRAY
99155: PPUSH
99156: LD_VAR 0 6
99160: PUSH
99161: LD_VAR 0 4
99165: ARRAY
99166: PUSH
99167: LD_INT 2
99169: ARRAY
99170: PPUSH
99171: CALL_OW 488
99175: NOT
99176: PUSH
99177: LD_VAR 0 6
99181: PUSH
99182: LD_VAR 0 4
99186: ARRAY
99187: PUSH
99188: LD_INT 1
99190: ARRAY
99191: PPUSH
99192: LD_VAR 0 6
99196: PUSH
99197: LD_VAR 0 4
99201: ARRAY
99202: PUSH
99203: LD_INT 2
99205: ARRAY
99206: PPUSH
99207: CALL_OW 428
99211: PUSH
99212: LD_INT 0
99214: NONEQUAL
99215: OR
99216: IFFALSE 99238
// tmp := Delete ( tmp , i ) ;
99218: LD_ADDR_VAR 0 6
99222: PUSH
99223: LD_VAR 0 6
99227: PPUSH
99228: LD_VAR 0 4
99232: PPUSH
99233: CALL_OW 3
99237: ST_TO_ADDR
99238: GO 99138
99240: POP
99241: POP
// j := GetClosestHex ( unit , tmp ) ;
99242: LD_ADDR_VAR 0 5
99246: PUSH
99247: LD_VAR 0 1
99251: PPUSH
99252: LD_VAR 0 6
99256: PPUSH
99257: CALL 98542 0 2
99261: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99262: LD_VAR 0 1
99266: PPUSH
99267: LD_VAR 0 5
99271: PUSH
99272: LD_INT 1
99274: ARRAY
99275: PPUSH
99276: LD_VAR 0 5
99280: PUSH
99281: LD_INT 2
99283: ARRAY
99284: PPUSH
99285: CALL_OW 111
// end ;
99289: LD_VAR 0 3
99293: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99294: LD_INT 0
99296: PPUSH
99297: PPUSH
99298: PPUSH
// uc_side = 0 ;
99299: LD_ADDR_OWVAR 20
99303: PUSH
99304: LD_INT 0
99306: ST_TO_ADDR
// uc_nation = 0 ;
99307: LD_ADDR_OWVAR 21
99311: PUSH
99312: LD_INT 0
99314: ST_TO_ADDR
// InitHc ;
99315: CALL_OW 19
// InitVc ;
99319: CALL_OW 20
// if mastodonts then
99323: LD_VAR 0 6
99327: IFFALSE 99394
// for i = 1 to mastodonts do
99329: LD_ADDR_VAR 0 11
99333: PUSH
99334: DOUBLE
99335: LD_INT 1
99337: DEC
99338: ST_TO_ADDR
99339: LD_VAR 0 6
99343: PUSH
99344: FOR_TO
99345: IFFALSE 99392
// begin vc_chassis := 31 ;
99347: LD_ADDR_OWVAR 37
99351: PUSH
99352: LD_INT 31
99354: ST_TO_ADDR
// vc_control := control_rider ;
99355: LD_ADDR_OWVAR 38
99359: PUSH
99360: LD_INT 4
99362: ST_TO_ADDR
// animal := CreateVehicle ;
99363: LD_ADDR_VAR 0 12
99367: PUSH
99368: CALL_OW 45
99372: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99373: LD_VAR 0 12
99377: PPUSH
99378: LD_VAR 0 8
99382: PPUSH
99383: LD_INT 0
99385: PPUSH
99386: CALL 106139 0 3
// end ;
99390: GO 99344
99392: POP
99393: POP
// if horses then
99394: LD_VAR 0 5
99398: IFFALSE 99465
// for i = 1 to horses do
99400: LD_ADDR_VAR 0 11
99404: PUSH
99405: DOUBLE
99406: LD_INT 1
99408: DEC
99409: ST_TO_ADDR
99410: LD_VAR 0 5
99414: PUSH
99415: FOR_TO
99416: IFFALSE 99463
// begin hc_class := 21 ;
99418: LD_ADDR_OWVAR 28
99422: PUSH
99423: LD_INT 21
99425: ST_TO_ADDR
// hc_gallery :=  ;
99426: LD_ADDR_OWVAR 33
99430: PUSH
99431: LD_STRING 
99433: ST_TO_ADDR
// animal := CreateHuman ;
99434: LD_ADDR_VAR 0 12
99438: PUSH
99439: CALL_OW 44
99443: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99444: LD_VAR 0 12
99448: PPUSH
99449: LD_VAR 0 8
99453: PPUSH
99454: LD_INT 0
99456: PPUSH
99457: CALL 106139 0 3
// end ;
99461: GO 99415
99463: POP
99464: POP
// if birds then
99465: LD_VAR 0 1
99469: IFFALSE 99536
// for i = 1 to birds do
99471: LD_ADDR_VAR 0 11
99475: PUSH
99476: DOUBLE
99477: LD_INT 1
99479: DEC
99480: ST_TO_ADDR
99481: LD_VAR 0 1
99485: PUSH
99486: FOR_TO
99487: IFFALSE 99534
// begin hc_class = 18 ;
99489: LD_ADDR_OWVAR 28
99493: PUSH
99494: LD_INT 18
99496: ST_TO_ADDR
// hc_gallery =  ;
99497: LD_ADDR_OWVAR 33
99501: PUSH
99502: LD_STRING 
99504: ST_TO_ADDR
// animal := CreateHuman ;
99505: LD_ADDR_VAR 0 12
99509: PUSH
99510: CALL_OW 44
99514: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99515: LD_VAR 0 12
99519: PPUSH
99520: LD_VAR 0 8
99524: PPUSH
99525: LD_INT 0
99527: PPUSH
99528: CALL 106139 0 3
// end ;
99532: GO 99486
99534: POP
99535: POP
// if tigers then
99536: LD_VAR 0 2
99540: IFFALSE 99624
// for i = 1 to tigers do
99542: LD_ADDR_VAR 0 11
99546: PUSH
99547: DOUBLE
99548: LD_INT 1
99550: DEC
99551: ST_TO_ADDR
99552: LD_VAR 0 2
99556: PUSH
99557: FOR_TO
99558: IFFALSE 99622
// begin hc_class = class_tiger ;
99560: LD_ADDR_OWVAR 28
99564: PUSH
99565: LD_INT 14
99567: ST_TO_ADDR
// hc_gallery =  ;
99568: LD_ADDR_OWVAR 33
99572: PUSH
99573: LD_STRING 
99575: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99576: LD_ADDR_OWVAR 35
99580: PUSH
99581: LD_INT 7
99583: NEG
99584: PPUSH
99585: LD_INT 7
99587: PPUSH
99588: CALL_OW 12
99592: ST_TO_ADDR
// animal := CreateHuman ;
99593: LD_ADDR_VAR 0 12
99597: PUSH
99598: CALL_OW 44
99602: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99603: LD_VAR 0 12
99607: PPUSH
99608: LD_VAR 0 8
99612: PPUSH
99613: LD_INT 0
99615: PPUSH
99616: CALL 106139 0 3
// end ;
99620: GO 99557
99622: POP
99623: POP
// if apemans then
99624: LD_VAR 0 3
99628: IFFALSE 99751
// for i = 1 to apemans do
99630: LD_ADDR_VAR 0 11
99634: PUSH
99635: DOUBLE
99636: LD_INT 1
99638: DEC
99639: ST_TO_ADDR
99640: LD_VAR 0 3
99644: PUSH
99645: FOR_TO
99646: IFFALSE 99749
// begin hc_class = class_apeman ;
99648: LD_ADDR_OWVAR 28
99652: PUSH
99653: LD_INT 12
99655: ST_TO_ADDR
// hc_gallery =  ;
99656: LD_ADDR_OWVAR 33
99660: PUSH
99661: LD_STRING 
99663: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99664: LD_ADDR_OWVAR 35
99668: PUSH
99669: LD_INT 5
99671: NEG
99672: PPUSH
99673: LD_INT 5
99675: PPUSH
99676: CALL_OW 12
99680: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99681: LD_ADDR_OWVAR 31
99685: PUSH
99686: LD_INT 1
99688: PPUSH
99689: LD_INT 3
99691: PPUSH
99692: CALL_OW 12
99696: PUSH
99697: LD_INT 1
99699: PPUSH
99700: LD_INT 3
99702: PPUSH
99703: CALL_OW 12
99707: PUSH
99708: LD_INT 0
99710: PUSH
99711: LD_INT 0
99713: PUSH
99714: EMPTY
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: ST_TO_ADDR
// animal := CreateHuman ;
99720: LD_ADDR_VAR 0 12
99724: PUSH
99725: CALL_OW 44
99729: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99730: LD_VAR 0 12
99734: PPUSH
99735: LD_VAR 0 8
99739: PPUSH
99740: LD_INT 0
99742: PPUSH
99743: CALL 106139 0 3
// end ;
99747: GO 99645
99749: POP
99750: POP
// if enchidnas then
99751: LD_VAR 0 4
99755: IFFALSE 99822
// for i = 1 to enchidnas do
99757: LD_ADDR_VAR 0 11
99761: PUSH
99762: DOUBLE
99763: LD_INT 1
99765: DEC
99766: ST_TO_ADDR
99767: LD_VAR 0 4
99771: PUSH
99772: FOR_TO
99773: IFFALSE 99820
// begin hc_class = 13 ;
99775: LD_ADDR_OWVAR 28
99779: PUSH
99780: LD_INT 13
99782: ST_TO_ADDR
// hc_gallery =  ;
99783: LD_ADDR_OWVAR 33
99787: PUSH
99788: LD_STRING 
99790: ST_TO_ADDR
// animal := CreateHuman ;
99791: LD_ADDR_VAR 0 12
99795: PUSH
99796: CALL_OW 44
99800: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99801: LD_VAR 0 12
99805: PPUSH
99806: LD_VAR 0 8
99810: PPUSH
99811: LD_INT 0
99813: PPUSH
99814: CALL 106139 0 3
// end ;
99818: GO 99772
99820: POP
99821: POP
// if fishes then
99822: LD_VAR 0 7
99826: IFFALSE 99893
// for i = 1 to fishes do
99828: LD_ADDR_VAR 0 11
99832: PUSH
99833: DOUBLE
99834: LD_INT 1
99836: DEC
99837: ST_TO_ADDR
99838: LD_VAR 0 7
99842: PUSH
99843: FOR_TO
99844: IFFALSE 99891
// begin hc_class = 20 ;
99846: LD_ADDR_OWVAR 28
99850: PUSH
99851: LD_INT 20
99853: ST_TO_ADDR
// hc_gallery =  ;
99854: LD_ADDR_OWVAR 33
99858: PUSH
99859: LD_STRING 
99861: ST_TO_ADDR
// animal := CreateHuman ;
99862: LD_ADDR_VAR 0 12
99866: PUSH
99867: CALL_OW 44
99871: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99872: LD_VAR 0 12
99876: PPUSH
99877: LD_VAR 0 9
99881: PPUSH
99882: LD_INT 0
99884: PPUSH
99885: CALL 106139 0 3
// end ;
99889: GO 99843
99891: POP
99892: POP
// end ;
99893: LD_VAR 0 10
99897: RET
// export function WantHeal ( sci , unit ) ; begin
99898: LD_INT 0
99900: PPUSH
// if GetTaskList ( sci ) > 0 then
99901: LD_VAR 0 1
99905: PPUSH
99906: CALL_OW 437
99910: PUSH
99911: LD_INT 0
99913: GREATER
99914: IFFALSE 99984
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99916: LD_VAR 0 1
99920: PPUSH
99921: CALL_OW 437
99925: PUSH
99926: LD_INT 1
99928: ARRAY
99929: PUSH
99930: LD_INT 1
99932: ARRAY
99933: PUSH
99934: LD_STRING l
99936: EQUAL
99937: PUSH
99938: LD_VAR 0 1
99942: PPUSH
99943: CALL_OW 437
99947: PUSH
99948: LD_INT 1
99950: ARRAY
99951: PUSH
99952: LD_INT 4
99954: ARRAY
99955: PUSH
99956: LD_VAR 0 2
99960: EQUAL
99961: AND
99962: IFFALSE 99974
// result := true else
99964: LD_ADDR_VAR 0 3
99968: PUSH
99969: LD_INT 1
99971: ST_TO_ADDR
99972: GO 99982
// result := false ;
99974: LD_ADDR_VAR 0 3
99978: PUSH
99979: LD_INT 0
99981: ST_TO_ADDR
// end else
99982: GO 99992
// result := false ;
99984: LD_ADDR_VAR 0 3
99988: PUSH
99989: LD_INT 0
99991: ST_TO_ADDR
// end ;
99992: LD_VAR 0 3
99996: RET
// export function HealTarget ( sci ) ; begin
99997: LD_INT 0
99999: PPUSH
// if not sci then
100000: LD_VAR 0 1
100004: NOT
100005: IFFALSE 100009
// exit ;
100007: GO 100074
// result := 0 ;
100009: LD_ADDR_VAR 0 2
100013: PUSH
100014: LD_INT 0
100016: ST_TO_ADDR
// if GetTaskList ( sci ) then
100017: LD_VAR 0 1
100021: PPUSH
100022: CALL_OW 437
100026: IFFALSE 100074
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100028: LD_VAR 0 1
100032: PPUSH
100033: CALL_OW 437
100037: PUSH
100038: LD_INT 1
100040: ARRAY
100041: PUSH
100042: LD_INT 1
100044: ARRAY
100045: PUSH
100046: LD_STRING l
100048: EQUAL
100049: IFFALSE 100074
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100051: LD_ADDR_VAR 0 2
100055: PUSH
100056: LD_VAR 0 1
100060: PPUSH
100061: CALL_OW 437
100065: PUSH
100066: LD_INT 1
100068: ARRAY
100069: PUSH
100070: LD_INT 4
100072: ARRAY
100073: ST_TO_ADDR
// end ;
100074: LD_VAR 0 2
100078: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100079: LD_INT 0
100081: PPUSH
100082: PPUSH
100083: PPUSH
100084: PPUSH
100085: PPUSH
100086: PPUSH
100087: PPUSH
100088: PPUSH
100089: PPUSH
100090: PPUSH
100091: PPUSH
100092: PPUSH
100093: PPUSH
100094: PPUSH
100095: PPUSH
100096: PPUSH
100097: PPUSH
100098: PPUSH
100099: PPUSH
100100: PPUSH
100101: PPUSH
100102: PPUSH
100103: PPUSH
100104: PPUSH
100105: PPUSH
100106: PPUSH
100107: PPUSH
100108: PPUSH
100109: PPUSH
100110: PPUSH
100111: PPUSH
100112: PPUSH
100113: PPUSH
100114: PPUSH
// if not list then
100115: LD_VAR 0 1
100119: NOT
100120: IFFALSE 100124
// exit ;
100122: GO 104750
// base := list [ 1 ] ;
100124: LD_ADDR_VAR 0 3
100128: PUSH
100129: LD_VAR 0 1
100133: PUSH
100134: LD_INT 1
100136: ARRAY
100137: ST_TO_ADDR
// group := list [ 2 ] ;
100138: LD_ADDR_VAR 0 4
100142: PUSH
100143: LD_VAR 0 1
100147: PUSH
100148: LD_INT 2
100150: ARRAY
100151: ST_TO_ADDR
// path := list [ 3 ] ;
100152: LD_ADDR_VAR 0 5
100156: PUSH
100157: LD_VAR 0 1
100161: PUSH
100162: LD_INT 3
100164: ARRAY
100165: ST_TO_ADDR
// flags := list [ 4 ] ;
100166: LD_ADDR_VAR 0 6
100170: PUSH
100171: LD_VAR 0 1
100175: PUSH
100176: LD_INT 4
100178: ARRAY
100179: ST_TO_ADDR
// mined := [ ] ;
100180: LD_ADDR_VAR 0 27
100184: PUSH
100185: EMPTY
100186: ST_TO_ADDR
// bombed := [ ] ;
100187: LD_ADDR_VAR 0 28
100191: PUSH
100192: EMPTY
100193: ST_TO_ADDR
// healers := [ ] ;
100194: LD_ADDR_VAR 0 31
100198: PUSH
100199: EMPTY
100200: ST_TO_ADDR
// to_heal := [ ] ;
100201: LD_ADDR_VAR 0 30
100205: PUSH
100206: EMPTY
100207: ST_TO_ADDR
// repairs := [ ] ;
100208: LD_ADDR_VAR 0 33
100212: PUSH
100213: EMPTY
100214: ST_TO_ADDR
// to_repair := [ ] ;
100215: LD_ADDR_VAR 0 32
100219: PUSH
100220: EMPTY
100221: ST_TO_ADDR
// if not group or not path then
100222: LD_VAR 0 4
100226: NOT
100227: PUSH
100228: LD_VAR 0 5
100232: NOT
100233: OR
100234: IFFALSE 100238
// exit ;
100236: GO 104750
// side := GetSide ( group [ 1 ] ) ;
100238: LD_ADDR_VAR 0 35
100242: PUSH
100243: LD_VAR 0 4
100247: PUSH
100248: LD_INT 1
100250: ARRAY
100251: PPUSH
100252: CALL_OW 255
100256: ST_TO_ADDR
// if flags then
100257: LD_VAR 0 6
100261: IFFALSE 100405
// begin f_ignore_area := flags [ 1 ] ;
100263: LD_ADDR_VAR 0 17
100267: PUSH
100268: LD_VAR 0 6
100272: PUSH
100273: LD_INT 1
100275: ARRAY
100276: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100277: LD_ADDR_VAR 0 18
100281: PUSH
100282: LD_VAR 0 6
100286: PUSH
100287: LD_INT 2
100289: ARRAY
100290: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100291: LD_ADDR_VAR 0 19
100295: PUSH
100296: LD_VAR 0 6
100300: PUSH
100301: LD_INT 3
100303: ARRAY
100304: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100305: LD_ADDR_VAR 0 20
100309: PUSH
100310: LD_VAR 0 6
100314: PUSH
100315: LD_INT 4
100317: ARRAY
100318: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100319: LD_ADDR_VAR 0 21
100323: PUSH
100324: LD_VAR 0 6
100328: PUSH
100329: LD_INT 5
100331: ARRAY
100332: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100333: LD_ADDR_VAR 0 22
100337: PUSH
100338: LD_VAR 0 6
100342: PUSH
100343: LD_INT 6
100345: ARRAY
100346: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100347: LD_ADDR_VAR 0 23
100351: PUSH
100352: LD_VAR 0 6
100356: PUSH
100357: LD_INT 7
100359: ARRAY
100360: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100361: LD_ADDR_VAR 0 24
100365: PUSH
100366: LD_VAR 0 6
100370: PUSH
100371: LD_INT 8
100373: ARRAY
100374: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100375: LD_ADDR_VAR 0 25
100379: PUSH
100380: LD_VAR 0 6
100384: PUSH
100385: LD_INT 9
100387: ARRAY
100388: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100389: LD_ADDR_VAR 0 26
100393: PUSH
100394: LD_VAR 0 6
100398: PUSH
100399: LD_INT 10
100401: ARRAY
100402: ST_TO_ADDR
// end else
100403: GO 100485
// begin f_ignore_area := false ;
100405: LD_ADDR_VAR 0 17
100409: PUSH
100410: LD_INT 0
100412: ST_TO_ADDR
// f_capture := false ;
100413: LD_ADDR_VAR 0 18
100417: PUSH
100418: LD_INT 0
100420: ST_TO_ADDR
// f_ignore_civ := false ;
100421: LD_ADDR_VAR 0 19
100425: PUSH
100426: LD_INT 0
100428: ST_TO_ADDR
// f_murder := false ;
100429: LD_ADDR_VAR 0 20
100433: PUSH
100434: LD_INT 0
100436: ST_TO_ADDR
// f_mines := false ;
100437: LD_ADDR_VAR 0 21
100441: PUSH
100442: LD_INT 0
100444: ST_TO_ADDR
// f_repair := false ;
100445: LD_ADDR_VAR 0 22
100449: PUSH
100450: LD_INT 0
100452: ST_TO_ADDR
// f_heal := false ;
100453: LD_ADDR_VAR 0 23
100457: PUSH
100458: LD_INT 0
100460: ST_TO_ADDR
// f_spacetime := false ;
100461: LD_ADDR_VAR 0 24
100465: PUSH
100466: LD_INT 0
100468: ST_TO_ADDR
// f_attack_depot := false ;
100469: LD_ADDR_VAR 0 25
100473: PUSH
100474: LD_INT 0
100476: ST_TO_ADDR
// f_crawl := false ;
100477: LD_ADDR_VAR 0 26
100481: PUSH
100482: LD_INT 0
100484: ST_TO_ADDR
// end ; if f_heal then
100485: LD_VAR 0 23
100489: IFFALSE 100516
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100491: LD_ADDR_VAR 0 31
100495: PUSH
100496: LD_VAR 0 4
100500: PPUSH
100501: LD_INT 25
100503: PUSH
100504: LD_INT 4
100506: PUSH
100507: EMPTY
100508: LIST
100509: LIST
100510: PPUSH
100511: CALL_OW 72
100515: ST_TO_ADDR
// if f_repair then
100516: LD_VAR 0 22
100520: IFFALSE 100547
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100522: LD_ADDR_VAR 0 33
100526: PUSH
100527: LD_VAR 0 4
100531: PPUSH
100532: LD_INT 25
100534: PUSH
100535: LD_INT 3
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PPUSH
100542: CALL_OW 72
100546: ST_TO_ADDR
// units_path := [ ] ;
100547: LD_ADDR_VAR 0 16
100551: PUSH
100552: EMPTY
100553: ST_TO_ADDR
// for i = 1 to group do
100554: LD_ADDR_VAR 0 7
100558: PUSH
100559: DOUBLE
100560: LD_INT 1
100562: DEC
100563: ST_TO_ADDR
100564: LD_VAR 0 4
100568: PUSH
100569: FOR_TO
100570: IFFALSE 100599
// units_path := Replace ( units_path , i , path ) ;
100572: LD_ADDR_VAR 0 16
100576: PUSH
100577: LD_VAR 0 16
100581: PPUSH
100582: LD_VAR 0 7
100586: PPUSH
100587: LD_VAR 0 5
100591: PPUSH
100592: CALL_OW 1
100596: ST_TO_ADDR
100597: GO 100569
100599: POP
100600: POP
// repeat for i = group downto 1 do
100601: LD_ADDR_VAR 0 7
100605: PUSH
100606: DOUBLE
100607: LD_VAR 0 4
100611: INC
100612: ST_TO_ADDR
100613: LD_INT 1
100615: PUSH
100616: FOR_DOWNTO
100617: IFFALSE 104713
// begin wait ( 5 ) ;
100619: LD_INT 5
100621: PPUSH
100622: CALL_OW 67
// tmp := [ ] ;
100626: LD_ADDR_VAR 0 14
100630: PUSH
100631: EMPTY
100632: ST_TO_ADDR
// attacking := false ;
100633: LD_ADDR_VAR 0 29
100637: PUSH
100638: LD_INT 0
100640: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100641: LD_VAR 0 4
100645: PUSH
100646: LD_VAR 0 7
100650: ARRAY
100651: PPUSH
100652: CALL_OW 301
100656: PUSH
100657: LD_VAR 0 4
100661: PUSH
100662: LD_VAR 0 7
100666: ARRAY
100667: NOT
100668: OR
100669: IFFALSE 100778
// begin if GetType ( group [ i ] ) = unit_human then
100671: LD_VAR 0 4
100675: PUSH
100676: LD_VAR 0 7
100680: ARRAY
100681: PPUSH
100682: CALL_OW 247
100686: PUSH
100687: LD_INT 1
100689: EQUAL
100690: IFFALSE 100736
// begin to_heal := to_heal diff group [ i ] ;
100692: LD_ADDR_VAR 0 30
100696: PUSH
100697: LD_VAR 0 30
100701: PUSH
100702: LD_VAR 0 4
100706: PUSH
100707: LD_VAR 0 7
100711: ARRAY
100712: DIFF
100713: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100714: LD_ADDR_VAR 0 31
100718: PUSH
100719: LD_VAR 0 31
100723: PUSH
100724: LD_VAR 0 4
100728: PUSH
100729: LD_VAR 0 7
100733: ARRAY
100734: DIFF
100735: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100736: LD_ADDR_VAR 0 4
100740: PUSH
100741: LD_VAR 0 4
100745: PPUSH
100746: LD_VAR 0 7
100750: PPUSH
100751: CALL_OW 3
100755: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100756: LD_ADDR_VAR 0 16
100760: PUSH
100761: LD_VAR 0 16
100765: PPUSH
100766: LD_VAR 0 7
100770: PPUSH
100771: CALL_OW 3
100775: ST_TO_ADDR
// continue ;
100776: GO 100616
// end ; if f_repair then
100778: LD_VAR 0 22
100782: IFFALSE 101271
// begin if GetType ( group [ i ] ) = unit_vehicle then
100784: LD_VAR 0 4
100788: PUSH
100789: LD_VAR 0 7
100793: ARRAY
100794: PPUSH
100795: CALL_OW 247
100799: PUSH
100800: LD_INT 2
100802: EQUAL
100803: IFFALSE 100993
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100805: LD_VAR 0 4
100809: PUSH
100810: LD_VAR 0 7
100814: ARRAY
100815: PPUSH
100816: CALL_OW 256
100820: PUSH
100821: LD_INT 700
100823: LESS
100824: PUSH
100825: LD_VAR 0 4
100829: PUSH
100830: LD_VAR 0 7
100834: ARRAY
100835: PUSH
100836: LD_VAR 0 32
100840: IN
100841: NOT
100842: AND
100843: IFFALSE 100867
// to_repair := to_repair union group [ i ] ;
100845: LD_ADDR_VAR 0 32
100849: PUSH
100850: LD_VAR 0 32
100854: PUSH
100855: LD_VAR 0 4
100859: PUSH
100860: LD_VAR 0 7
100864: ARRAY
100865: UNION
100866: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100867: LD_VAR 0 4
100871: PUSH
100872: LD_VAR 0 7
100876: ARRAY
100877: PPUSH
100878: CALL_OW 256
100882: PUSH
100883: LD_INT 1000
100885: EQUAL
100886: PUSH
100887: LD_VAR 0 4
100891: PUSH
100892: LD_VAR 0 7
100896: ARRAY
100897: PUSH
100898: LD_VAR 0 32
100902: IN
100903: AND
100904: IFFALSE 100928
// to_repair := to_repair diff group [ i ] ;
100906: LD_ADDR_VAR 0 32
100910: PUSH
100911: LD_VAR 0 32
100915: PUSH
100916: LD_VAR 0 4
100920: PUSH
100921: LD_VAR 0 7
100925: ARRAY
100926: DIFF
100927: ST_TO_ADDR
// if group [ i ] in to_repair then
100928: LD_VAR 0 4
100932: PUSH
100933: LD_VAR 0 7
100937: ARRAY
100938: PUSH
100939: LD_VAR 0 32
100943: IN
100944: IFFALSE 100991
// begin if not IsInArea ( group [ i ] , f_repair ) then
100946: LD_VAR 0 4
100950: PUSH
100951: LD_VAR 0 7
100955: ARRAY
100956: PPUSH
100957: LD_VAR 0 22
100961: PPUSH
100962: CALL_OW 308
100966: NOT
100967: IFFALSE 100989
// ComMoveToArea ( group [ i ] , f_repair ) ;
100969: LD_VAR 0 4
100973: PUSH
100974: LD_VAR 0 7
100978: ARRAY
100979: PPUSH
100980: LD_VAR 0 22
100984: PPUSH
100985: CALL_OW 113
// continue ;
100989: GO 100616
// end ; end else
100991: GO 101271
// if group [ i ] in repairs then
100993: LD_VAR 0 4
100997: PUSH
100998: LD_VAR 0 7
101002: ARRAY
101003: PUSH
101004: LD_VAR 0 33
101008: IN
101009: IFFALSE 101271
// begin if IsInUnit ( group [ i ] ) then
101011: LD_VAR 0 4
101015: PUSH
101016: LD_VAR 0 7
101020: ARRAY
101021: PPUSH
101022: CALL_OW 310
101026: IFFALSE 101094
// begin z := IsInUnit ( group [ i ] ) ;
101028: LD_ADDR_VAR 0 13
101032: PUSH
101033: LD_VAR 0 4
101037: PUSH
101038: LD_VAR 0 7
101042: ARRAY
101043: PPUSH
101044: CALL_OW 310
101048: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101049: LD_VAR 0 13
101053: PUSH
101054: LD_VAR 0 32
101058: IN
101059: PUSH
101060: LD_VAR 0 13
101064: PPUSH
101065: LD_VAR 0 22
101069: PPUSH
101070: CALL_OW 308
101074: AND
101075: IFFALSE 101092
// ComExitVehicle ( group [ i ] ) ;
101077: LD_VAR 0 4
101081: PUSH
101082: LD_VAR 0 7
101086: ARRAY
101087: PPUSH
101088: CALL_OW 121
// end else
101092: GO 101271
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101094: LD_ADDR_VAR 0 13
101098: PUSH
101099: LD_VAR 0 4
101103: PPUSH
101104: LD_INT 95
101106: PUSH
101107: LD_VAR 0 22
101111: PUSH
101112: EMPTY
101113: LIST
101114: LIST
101115: PUSH
101116: LD_INT 58
101118: PUSH
101119: EMPTY
101120: LIST
101121: PUSH
101122: EMPTY
101123: LIST
101124: LIST
101125: PPUSH
101126: CALL_OW 72
101130: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101131: LD_VAR 0 4
101135: PUSH
101136: LD_VAR 0 7
101140: ARRAY
101141: PPUSH
101142: CALL_OW 314
101146: NOT
101147: IFFALSE 101269
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101149: LD_ADDR_VAR 0 10
101153: PUSH
101154: LD_VAR 0 13
101158: PPUSH
101159: LD_VAR 0 4
101163: PUSH
101164: LD_VAR 0 7
101168: ARRAY
101169: PPUSH
101170: CALL_OW 74
101174: ST_TO_ADDR
// if not x then
101175: LD_VAR 0 10
101179: NOT
101180: IFFALSE 101184
// continue ;
101182: GO 100616
// if GetLives ( x ) < 1000 then
101184: LD_VAR 0 10
101188: PPUSH
101189: CALL_OW 256
101193: PUSH
101194: LD_INT 1000
101196: LESS
101197: IFFALSE 101221
// ComRepairVehicle ( group [ i ] , x ) else
101199: LD_VAR 0 4
101203: PUSH
101204: LD_VAR 0 7
101208: ARRAY
101209: PPUSH
101210: LD_VAR 0 10
101214: PPUSH
101215: CALL_OW 129
101219: GO 101269
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101221: LD_VAR 0 23
101225: PUSH
101226: LD_VAR 0 4
101230: PUSH
101231: LD_VAR 0 7
101235: ARRAY
101236: PPUSH
101237: CALL_OW 256
101241: PUSH
101242: LD_INT 1000
101244: LESS
101245: AND
101246: NOT
101247: IFFALSE 101269
// ComEnterUnit ( group [ i ] , x ) ;
101249: LD_VAR 0 4
101253: PUSH
101254: LD_VAR 0 7
101258: ARRAY
101259: PPUSH
101260: LD_VAR 0 10
101264: PPUSH
101265: CALL_OW 120
// end ; continue ;
101269: GO 100616
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101271: LD_VAR 0 23
101275: PUSH
101276: LD_VAR 0 4
101280: PUSH
101281: LD_VAR 0 7
101285: ARRAY
101286: PPUSH
101287: CALL_OW 247
101291: PUSH
101292: LD_INT 1
101294: EQUAL
101295: AND
101296: IFFALSE 101774
// begin if group [ i ] in healers then
101298: LD_VAR 0 4
101302: PUSH
101303: LD_VAR 0 7
101307: ARRAY
101308: PUSH
101309: LD_VAR 0 31
101313: IN
101314: IFFALSE 101587
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101316: LD_VAR 0 4
101320: PUSH
101321: LD_VAR 0 7
101325: ARRAY
101326: PPUSH
101327: LD_VAR 0 23
101331: PPUSH
101332: CALL_OW 308
101336: NOT
101337: PUSH
101338: LD_VAR 0 4
101342: PUSH
101343: LD_VAR 0 7
101347: ARRAY
101348: PPUSH
101349: CALL_OW 314
101353: NOT
101354: AND
101355: IFFALSE 101379
// ComMoveToArea ( group [ i ] , f_heal ) else
101357: LD_VAR 0 4
101361: PUSH
101362: LD_VAR 0 7
101366: ARRAY
101367: PPUSH
101368: LD_VAR 0 23
101372: PPUSH
101373: CALL_OW 113
101377: GO 101585
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101379: LD_VAR 0 4
101383: PUSH
101384: LD_VAR 0 7
101388: ARRAY
101389: PPUSH
101390: CALL 99997 0 1
101394: PPUSH
101395: CALL_OW 256
101399: PUSH
101400: LD_INT 1000
101402: EQUAL
101403: IFFALSE 101422
// ComStop ( group [ i ] ) else
101405: LD_VAR 0 4
101409: PUSH
101410: LD_VAR 0 7
101414: ARRAY
101415: PPUSH
101416: CALL_OW 141
101420: GO 101585
// if not HasTask ( group [ i ] ) and to_heal then
101422: LD_VAR 0 4
101426: PUSH
101427: LD_VAR 0 7
101431: ARRAY
101432: PPUSH
101433: CALL_OW 314
101437: NOT
101438: PUSH
101439: LD_VAR 0 30
101443: AND
101444: IFFALSE 101585
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101446: LD_ADDR_VAR 0 13
101450: PUSH
101451: LD_VAR 0 30
101455: PPUSH
101456: LD_INT 3
101458: PUSH
101459: LD_INT 54
101461: PUSH
101462: EMPTY
101463: LIST
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PPUSH
101469: CALL_OW 72
101473: PPUSH
101474: LD_VAR 0 4
101478: PUSH
101479: LD_VAR 0 7
101483: ARRAY
101484: PPUSH
101485: CALL_OW 74
101489: ST_TO_ADDR
// if z then
101490: LD_VAR 0 13
101494: IFFALSE 101585
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101496: LD_INT 91
101498: PUSH
101499: LD_VAR 0 13
101503: PUSH
101504: LD_INT 10
101506: PUSH
101507: EMPTY
101508: LIST
101509: LIST
101510: LIST
101511: PUSH
101512: LD_INT 81
101514: PUSH
101515: LD_VAR 0 13
101519: PPUSH
101520: CALL_OW 255
101524: PUSH
101525: EMPTY
101526: LIST
101527: LIST
101528: PUSH
101529: EMPTY
101530: LIST
101531: LIST
101532: PPUSH
101533: CALL_OW 69
101537: PUSH
101538: LD_INT 0
101540: EQUAL
101541: IFFALSE 101565
// ComHeal ( group [ i ] , z ) else
101543: LD_VAR 0 4
101547: PUSH
101548: LD_VAR 0 7
101552: ARRAY
101553: PPUSH
101554: LD_VAR 0 13
101558: PPUSH
101559: CALL_OW 128
101563: GO 101585
// ComMoveToArea ( group [ i ] , f_heal ) ;
101565: LD_VAR 0 4
101569: PUSH
101570: LD_VAR 0 7
101574: ARRAY
101575: PPUSH
101576: LD_VAR 0 23
101580: PPUSH
101581: CALL_OW 113
// end ; continue ;
101585: GO 100616
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101587: LD_VAR 0 4
101591: PUSH
101592: LD_VAR 0 7
101596: ARRAY
101597: PPUSH
101598: CALL_OW 256
101602: PUSH
101603: LD_INT 700
101605: LESS
101606: PUSH
101607: LD_VAR 0 4
101611: PUSH
101612: LD_VAR 0 7
101616: ARRAY
101617: PUSH
101618: LD_VAR 0 30
101622: IN
101623: NOT
101624: AND
101625: IFFALSE 101649
// to_heal := to_heal union group [ i ] ;
101627: LD_ADDR_VAR 0 30
101631: PUSH
101632: LD_VAR 0 30
101636: PUSH
101637: LD_VAR 0 4
101641: PUSH
101642: LD_VAR 0 7
101646: ARRAY
101647: UNION
101648: ST_TO_ADDR
// if group [ i ] in to_heal then
101649: LD_VAR 0 4
101653: PUSH
101654: LD_VAR 0 7
101658: ARRAY
101659: PUSH
101660: LD_VAR 0 30
101664: IN
101665: IFFALSE 101774
// begin if GetLives ( group [ i ] ) = 1000 then
101667: LD_VAR 0 4
101671: PUSH
101672: LD_VAR 0 7
101676: ARRAY
101677: PPUSH
101678: CALL_OW 256
101682: PUSH
101683: LD_INT 1000
101685: EQUAL
101686: IFFALSE 101712
// to_heal := to_heal diff group [ i ] else
101688: LD_ADDR_VAR 0 30
101692: PUSH
101693: LD_VAR 0 30
101697: PUSH
101698: LD_VAR 0 4
101702: PUSH
101703: LD_VAR 0 7
101707: ARRAY
101708: DIFF
101709: ST_TO_ADDR
101710: GO 101774
// begin if not IsInArea ( group [ i ] , to_heal ) then
101712: LD_VAR 0 4
101716: PUSH
101717: LD_VAR 0 7
101721: ARRAY
101722: PPUSH
101723: LD_VAR 0 30
101727: PPUSH
101728: CALL_OW 308
101732: NOT
101733: IFFALSE 101757
// ComMoveToArea ( group [ i ] , f_heal ) else
101735: LD_VAR 0 4
101739: PUSH
101740: LD_VAR 0 7
101744: ARRAY
101745: PPUSH
101746: LD_VAR 0 23
101750: PPUSH
101751: CALL_OW 113
101755: GO 101772
// ComHold ( group [ i ] ) ;
101757: LD_VAR 0 4
101761: PUSH
101762: LD_VAR 0 7
101766: ARRAY
101767: PPUSH
101768: CALL_OW 140
// continue ;
101772: GO 100616
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101774: LD_VAR 0 4
101778: PUSH
101779: LD_VAR 0 7
101783: ARRAY
101784: PPUSH
101785: LD_INT 10
101787: PPUSH
101788: CALL 98394 0 2
101792: NOT
101793: PUSH
101794: LD_VAR 0 16
101798: PUSH
101799: LD_VAR 0 7
101803: ARRAY
101804: PUSH
101805: EMPTY
101806: EQUAL
101807: NOT
101808: AND
101809: IFFALSE 102075
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101811: LD_VAR 0 4
101815: PUSH
101816: LD_VAR 0 7
101820: ARRAY
101821: PPUSH
101822: CALL_OW 262
101826: PUSH
101827: LD_INT 1
101829: PUSH
101830: LD_INT 2
101832: PUSH
101833: EMPTY
101834: LIST
101835: LIST
101836: IN
101837: IFFALSE 101878
// if GetFuel ( group [ i ] ) < 10 then
101839: LD_VAR 0 4
101843: PUSH
101844: LD_VAR 0 7
101848: ARRAY
101849: PPUSH
101850: CALL_OW 261
101854: PUSH
101855: LD_INT 10
101857: LESS
101858: IFFALSE 101878
// SetFuel ( group [ i ] , 12 ) ;
101860: LD_VAR 0 4
101864: PUSH
101865: LD_VAR 0 7
101869: ARRAY
101870: PPUSH
101871: LD_INT 12
101873: PPUSH
101874: CALL_OW 240
// if units_path [ i ] then
101878: LD_VAR 0 16
101882: PUSH
101883: LD_VAR 0 7
101887: ARRAY
101888: IFFALSE 102073
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101890: LD_VAR 0 4
101894: PUSH
101895: LD_VAR 0 7
101899: ARRAY
101900: PPUSH
101901: LD_VAR 0 16
101905: PUSH
101906: LD_VAR 0 7
101910: ARRAY
101911: PUSH
101912: LD_INT 1
101914: ARRAY
101915: PUSH
101916: LD_INT 1
101918: ARRAY
101919: PPUSH
101920: LD_VAR 0 16
101924: PUSH
101925: LD_VAR 0 7
101929: ARRAY
101930: PUSH
101931: LD_INT 1
101933: ARRAY
101934: PUSH
101935: LD_INT 2
101937: ARRAY
101938: PPUSH
101939: CALL_OW 297
101943: PUSH
101944: LD_INT 6
101946: GREATER
101947: IFFALSE 102022
// begin if not HasTask ( group [ i ] ) then
101949: LD_VAR 0 4
101953: PUSH
101954: LD_VAR 0 7
101958: ARRAY
101959: PPUSH
101960: CALL_OW 314
101964: NOT
101965: IFFALSE 102020
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101967: LD_VAR 0 4
101971: PUSH
101972: LD_VAR 0 7
101976: ARRAY
101977: PPUSH
101978: LD_VAR 0 16
101982: PUSH
101983: LD_VAR 0 7
101987: ARRAY
101988: PUSH
101989: LD_INT 1
101991: ARRAY
101992: PUSH
101993: LD_INT 1
101995: ARRAY
101996: PPUSH
101997: LD_VAR 0 16
102001: PUSH
102002: LD_VAR 0 7
102006: ARRAY
102007: PUSH
102008: LD_INT 1
102010: ARRAY
102011: PUSH
102012: LD_INT 2
102014: ARRAY
102015: PPUSH
102016: CALL_OW 114
// end else
102020: GO 102073
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102022: LD_ADDR_VAR 0 15
102026: PUSH
102027: LD_VAR 0 16
102031: PUSH
102032: LD_VAR 0 7
102036: ARRAY
102037: PPUSH
102038: LD_INT 1
102040: PPUSH
102041: CALL_OW 3
102045: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102046: LD_ADDR_VAR 0 16
102050: PUSH
102051: LD_VAR 0 16
102055: PPUSH
102056: LD_VAR 0 7
102060: PPUSH
102061: LD_VAR 0 15
102065: PPUSH
102066: CALL_OW 1
102070: ST_TO_ADDR
// continue ;
102071: GO 100616
// end ; end ; end else
102073: GO 104711
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102075: LD_ADDR_VAR 0 14
102079: PUSH
102080: LD_INT 81
102082: PUSH
102083: LD_VAR 0 4
102087: PUSH
102088: LD_VAR 0 7
102092: ARRAY
102093: PPUSH
102094: CALL_OW 255
102098: PUSH
102099: EMPTY
102100: LIST
102101: LIST
102102: PPUSH
102103: CALL_OW 69
102107: ST_TO_ADDR
// if not tmp then
102108: LD_VAR 0 14
102112: NOT
102113: IFFALSE 102117
// continue ;
102115: GO 100616
// if f_ignore_area then
102117: LD_VAR 0 17
102121: IFFALSE 102209
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102123: LD_ADDR_VAR 0 15
102127: PUSH
102128: LD_VAR 0 14
102132: PPUSH
102133: LD_INT 3
102135: PUSH
102136: LD_INT 92
102138: PUSH
102139: LD_VAR 0 17
102143: PUSH
102144: LD_INT 1
102146: ARRAY
102147: PUSH
102148: LD_VAR 0 17
102152: PUSH
102153: LD_INT 2
102155: ARRAY
102156: PUSH
102157: LD_VAR 0 17
102161: PUSH
102162: LD_INT 3
102164: ARRAY
102165: PUSH
102166: EMPTY
102167: LIST
102168: LIST
102169: LIST
102170: LIST
102171: PUSH
102172: EMPTY
102173: LIST
102174: LIST
102175: PPUSH
102176: CALL_OW 72
102180: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102181: LD_VAR 0 14
102185: PUSH
102186: LD_VAR 0 15
102190: DIFF
102191: IFFALSE 102209
// tmp := tmp diff tmp2 ;
102193: LD_ADDR_VAR 0 14
102197: PUSH
102198: LD_VAR 0 14
102202: PUSH
102203: LD_VAR 0 15
102207: DIFF
102208: ST_TO_ADDR
// end ; if not f_murder then
102209: LD_VAR 0 20
102213: NOT
102214: IFFALSE 102272
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102216: LD_ADDR_VAR 0 15
102220: PUSH
102221: LD_VAR 0 14
102225: PPUSH
102226: LD_INT 3
102228: PUSH
102229: LD_INT 50
102231: PUSH
102232: EMPTY
102233: LIST
102234: PUSH
102235: EMPTY
102236: LIST
102237: LIST
102238: PPUSH
102239: CALL_OW 72
102243: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102244: LD_VAR 0 14
102248: PUSH
102249: LD_VAR 0 15
102253: DIFF
102254: IFFALSE 102272
// tmp := tmp diff tmp2 ;
102256: LD_ADDR_VAR 0 14
102260: PUSH
102261: LD_VAR 0 14
102265: PUSH
102266: LD_VAR 0 15
102270: DIFF
102271: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102272: LD_ADDR_VAR 0 14
102276: PUSH
102277: LD_VAR 0 4
102281: PUSH
102282: LD_VAR 0 7
102286: ARRAY
102287: PPUSH
102288: LD_VAR 0 14
102292: PPUSH
102293: LD_INT 1
102295: PPUSH
102296: LD_INT 1
102298: PPUSH
102299: CALL 72037 0 4
102303: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102304: LD_VAR 0 4
102308: PUSH
102309: LD_VAR 0 7
102313: ARRAY
102314: PPUSH
102315: CALL_OW 257
102319: PUSH
102320: LD_INT 1
102322: EQUAL
102323: IFFALSE 102771
// begin if WantPlant ( group [ i ] ) then
102325: LD_VAR 0 4
102329: PUSH
102330: LD_VAR 0 7
102334: ARRAY
102335: PPUSH
102336: CALL 71538 0 1
102340: IFFALSE 102344
// continue ;
102342: GO 100616
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102344: LD_VAR 0 18
102348: PUSH
102349: LD_VAR 0 4
102353: PUSH
102354: LD_VAR 0 7
102358: ARRAY
102359: PPUSH
102360: CALL_OW 310
102364: NOT
102365: AND
102366: PUSH
102367: LD_VAR 0 14
102371: PUSH
102372: LD_INT 1
102374: ARRAY
102375: PUSH
102376: LD_VAR 0 14
102380: PPUSH
102381: LD_INT 21
102383: PUSH
102384: LD_INT 2
102386: PUSH
102387: EMPTY
102388: LIST
102389: LIST
102390: PUSH
102391: LD_INT 58
102393: PUSH
102394: EMPTY
102395: LIST
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PPUSH
102401: CALL_OW 72
102405: IN
102406: AND
102407: IFFALSE 102443
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102409: LD_VAR 0 4
102413: PUSH
102414: LD_VAR 0 7
102418: ARRAY
102419: PPUSH
102420: LD_VAR 0 14
102424: PUSH
102425: LD_INT 1
102427: ARRAY
102428: PPUSH
102429: CALL_OW 120
// attacking := true ;
102433: LD_ADDR_VAR 0 29
102437: PUSH
102438: LD_INT 1
102440: ST_TO_ADDR
// continue ;
102441: GO 100616
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102443: LD_VAR 0 26
102447: PUSH
102448: LD_VAR 0 4
102452: PUSH
102453: LD_VAR 0 7
102457: ARRAY
102458: PPUSH
102459: CALL_OW 257
102463: PUSH
102464: LD_INT 1
102466: EQUAL
102467: AND
102468: PUSH
102469: LD_VAR 0 4
102473: PUSH
102474: LD_VAR 0 7
102478: ARRAY
102479: PPUSH
102480: CALL_OW 256
102484: PUSH
102485: LD_INT 800
102487: LESS
102488: AND
102489: PUSH
102490: LD_VAR 0 4
102494: PUSH
102495: LD_VAR 0 7
102499: ARRAY
102500: PPUSH
102501: CALL_OW 318
102505: NOT
102506: AND
102507: IFFALSE 102524
// ComCrawl ( group [ i ] ) ;
102509: LD_VAR 0 4
102513: PUSH
102514: LD_VAR 0 7
102518: ARRAY
102519: PPUSH
102520: CALL_OW 137
// if f_mines then
102524: LD_VAR 0 21
102528: IFFALSE 102771
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102530: LD_VAR 0 14
102534: PUSH
102535: LD_INT 1
102537: ARRAY
102538: PPUSH
102539: CALL_OW 247
102543: PUSH
102544: LD_INT 3
102546: EQUAL
102547: PUSH
102548: LD_VAR 0 14
102552: PUSH
102553: LD_INT 1
102555: ARRAY
102556: PUSH
102557: LD_VAR 0 27
102561: IN
102562: NOT
102563: AND
102564: IFFALSE 102771
// begin x := GetX ( tmp [ 1 ] ) ;
102566: LD_ADDR_VAR 0 10
102570: PUSH
102571: LD_VAR 0 14
102575: PUSH
102576: LD_INT 1
102578: ARRAY
102579: PPUSH
102580: CALL_OW 250
102584: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102585: LD_ADDR_VAR 0 11
102589: PUSH
102590: LD_VAR 0 14
102594: PUSH
102595: LD_INT 1
102597: ARRAY
102598: PPUSH
102599: CALL_OW 251
102603: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102604: LD_ADDR_VAR 0 12
102608: PUSH
102609: LD_VAR 0 4
102613: PUSH
102614: LD_VAR 0 7
102618: ARRAY
102619: PPUSH
102620: CALL 98479 0 1
102624: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102625: LD_VAR 0 4
102629: PUSH
102630: LD_VAR 0 7
102634: ARRAY
102635: PPUSH
102636: LD_VAR 0 10
102640: PPUSH
102641: LD_VAR 0 11
102645: PPUSH
102646: LD_VAR 0 14
102650: PUSH
102651: LD_INT 1
102653: ARRAY
102654: PPUSH
102655: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102659: LD_VAR 0 4
102663: PUSH
102664: LD_VAR 0 7
102668: ARRAY
102669: PPUSH
102670: LD_VAR 0 10
102674: PPUSH
102675: LD_VAR 0 12
102679: PPUSH
102680: LD_INT 7
102682: PPUSH
102683: CALL_OW 272
102687: PPUSH
102688: LD_VAR 0 11
102692: PPUSH
102693: LD_VAR 0 12
102697: PPUSH
102698: LD_INT 7
102700: PPUSH
102701: CALL_OW 273
102705: PPUSH
102706: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102710: LD_VAR 0 4
102714: PUSH
102715: LD_VAR 0 7
102719: ARRAY
102720: PPUSH
102721: LD_INT 71
102723: PPUSH
102724: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102728: LD_ADDR_VAR 0 27
102732: PUSH
102733: LD_VAR 0 27
102737: PPUSH
102738: LD_VAR 0 27
102742: PUSH
102743: LD_INT 1
102745: PLUS
102746: PPUSH
102747: LD_VAR 0 14
102751: PUSH
102752: LD_INT 1
102754: ARRAY
102755: PPUSH
102756: CALL_OW 1
102760: ST_TO_ADDR
// attacking := true ;
102761: LD_ADDR_VAR 0 29
102765: PUSH
102766: LD_INT 1
102768: ST_TO_ADDR
// continue ;
102769: GO 100616
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102771: LD_VAR 0 4
102775: PUSH
102776: LD_VAR 0 7
102780: ARRAY
102781: PPUSH
102782: CALL_OW 257
102786: PUSH
102787: LD_INT 17
102789: EQUAL
102790: PUSH
102791: LD_VAR 0 4
102795: PUSH
102796: LD_VAR 0 7
102800: ARRAY
102801: PPUSH
102802: CALL_OW 110
102806: PUSH
102807: LD_INT 71
102809: EQUAL
102810: NOT
102811: AND
102812: IFFALSE 102958
// begin attacking := false ;
102814: LD_ADDR_VAR 0 29
102818: PUSH
102819: LD_INT 0
102821: ST_TO_ADDR
// k := 5 ;
102822: LD_ADDR_VAR 0 9
102826: PUSH
102827: LD_INT 5
102829: ST_TO_ADDR
// if tmp < k then
102830: LD_VAR 0 14
102834: PUSH
102835: LD_VAR 0 9
102839: LESS
102840: IFFALSE 102852
// k := tmp ;
102842: LD_ADDR_VAR 0 9
102846: PUSH
102847: LD_VAR 0 14
102851: ST_TO_ADDR
// for j = 1 to k do
102852: LD_ADDR_VAR 0 8
102856: PUSH
102857: DOUBLE
102858: LD_INT 1
102860: DEC
102861: ST_TO_ADDR
102862: LD_VAR 0 9
102866: PUSH
102867: FOR_TO
102868: IFFALSE 102956
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102870: LD_VAR 0 14
102874: PUSH
102875: LD_VAR 0 8
102879: ARRAY
102880: PUSH
102881: LD_VAR 0 14
102885: PPUSH
102886: LD_INT 58
102888: PUSH
102889: EMPTY
102890: LIST
102891: PPUSH
102892: CALL_OW 72
102896: IN
102897: NOT
102898: IFFALSE 102954
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102900: LD_VAR 0 4
102904: PUSH
102905: LD_VAR 0 7
102909: ARRAY
102910: PPUSH
102911: LD_VAR 0 14
102915: PUSH
102916: LD_VAR 0 8
102920: ARRAY
102921: PPUSH
102922: CALL_OW 115
// attacking := true ;
102926: LD_ADDR_VAR 0 29
102930: PUSH
102931: LD_INT 1
102933: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102934: LD_VAR 0 4
102938: PUSH
102939: LD_VAR 0 7
102943: ARRAY
102944: PPUSH
102945: LD_INT 71
102947: PPUSH
102948: CALL_OW 109
// continue ;
102952: GO 102867
// end ; end ;
102954: GO 102867
102956: POP
102957: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102958: LD_VAR 0 4
102962: PUSH
102963: LD_VAR 0 7
102967: ARRAY
102968: PPUSH
102969: CALL_OW 257
102973: PUSH
102974: LD_INT 8
102976: EQUAL
102977: PUSH
102978: LD_VAR 0 4
102982: PUSH
102983: LD_VAR 0 7
102987: ARRAY
102988: PPUSH
102989: CALL_OW 264
102993: PUSH
102994: LD_INT 28
102996: PUSH
102997: LD_INT 45
102999: PUSH
103000: LD_INT 7
103002: PUSH
103003: LD_INT 47
103005: PUSH
103006: EMPTY
103007: LIST
103008: LIST
103009: LIST
103010: LIST
103011: IN
103012: OR
103013: IFFALSE 103243
// begin attacking := false ;
103015: LD_ADDR_VAR 0 29
103019: PUSH
103020: LD_INT 0
103022: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103023: LD_VAR 0 14
103027: PUSH
103028: LD_INT 1
103030: ARRAY
103031: PPUSH
103032: CALL_OW 266
103036: PUSH
103037: LD_INT 32
103039: PUSH
103040: LD_INT 31
103042: PUSH
103043: LD_INT 33
103045: PUSH
103046: LD_INT 4
103048: PUSH
103049: LD_INT 5
103051: PUSH
103052: EMPTY
103053: LIST
103054: LIST
103055: LIST
103056: LIST
103057: LIST
103058: IN
103059: IFFALSE 103243
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103061: LD_ADDR_VAR 0 9
103065: PUSH
103066: LD_VAR 0 14
103070: PUSH
103071: LD_INT 1
103073: ARRAY
103074: PPUSH
103075: CALL_OW 266
103079: PPUSH
103080: LD_VAR 0 14
103084: PUSH
103085: LD_INT 1
103087: ARRAY
103088: PPUSH
103089: CALL_OW 250
103093: PPUSH
103094: LD_VAR 0 14
103098: PUSH
103099: LD_INT 1
103101: ARRAY
103102: PPUSH
103103: CALL_OW 251
103107: PPUSH
103108: LD_VAR 0 14
103112: PUSH
103113: LD_INT 1
103115: ARRAY
103116: PPUSH
103117: CALL_OW 254
103121: PPUSH
103122: LD_VAR 0 14
103126: PUSH
103127: LD_INT 1
103129: ARRAY
103130: PPUSH
103131: CALL_OW 248
103135: PPUSH
103136: LD_INT 0
103138: PPUSH
103139: CALL 79849 0 6
103143: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103144: LD_ADDR_VAR 0 8
103148: PUSH
103149: LD_VAR 0 4
103153: PUSH
103154: LD_VAR 0 7
103158: ARRAY
103159: PPUSH
103160: LD_VAR 0 9
103164: PPUSH
103165: CALL 98542 0 2
103169: ST_TO_ADDR
// if j then
103170: LD_VAR 0 8
103174: IFFALSE 103243
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103176: LD_VAR 0 8
103180: PUSH
103181: LD_INT 1
103183: ARRAY
103184: PPUSH
103185: LD_VAR 0 8
103189: PUSH
103190: LD_INT 2
103192: ARRAY
103193: PPUSH
103194: CALL_OW 488
103198: IFFALSE 103243
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103200: LD_VAR 0 4
103204: PUSH
103205: LD_VAR 0 7
103209: ARRAY
103210: PPUSH
103211: LD_VAR 0 8
103215: PUSH
103216: LD_INT 1
103218: ARRAY
103219: PPUSH
103220: LD_VAR 0 8
103224: PUSH
103225: LD_INT 2
103227: ARRAY
103228: PPUSH
103229: CALL_OW 116
// attacking := true ;
103233: LD_ADDR_VAR 0 29
103237: PUSH
103238: LD_INT 1
103240: ST_TO_ADDR
// continue ;
103241: GO 100616
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103243: LD_VAR 0 4
103247: PUSH
103248: LD_VAR 0 7
103252: ARRAY
103253: PPUSH
103254: CALL_OW 265
103258: PUSH
103259: LD_INT 11
103261: EQUAL
103262: IFFALSE 103540
// begin k := 10 ;
103264: LD_ADDR_VAR 0 9
103268: PUSH
103269: LD_INT 10
103271: ST_TO_ADDR
// x := 0 ;
103272: LD_ADDR_VAR 0 10
103276: PUSH
103277: LD_INT 0
103279: ST_TO_ADDR
// if tmp < k then
103280: LD_VAR 0 14
103284: PUSH
103285: LD_VAR 0 9
103289: LESS
103290: IFFALSE 103302
// k := tmp ;
103292: LD_ADDR_VAR 0 9
103296: PUSH
103297: LD_VAR 0 14
103301: ST_TO_ADDR
// for j = k downto 1 do
103302: LD_ADDR_VAR 0 8
103306: PUSH
103307: DOUBLE
103308: LD_VAR 0 9
103312: INC
103313: ST_TO_ADDR
103314: LD_INT 1
103316: PUSH
103317: FOR_DOWNTO
103318: IFFALSE 103393
// begin if GetType ( tmp [ j ] ) = unit_human then
103320: LD_VAR 0 14
103324: PUSH
103325: LD_VAR 0 8
103329: ARRAY
103330: PPUSH
103331: CALL_OW 247
103335: PUSH
103336: LD_INT 1
103338: EQUAL
103339: IFFALSE 103391
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103341: LD_VAR 0 4
103345: PUSH
103346: LD_VAR 0 7
103350: ARRAY
103351: PPUSH
103352: LD_VAR 0 14
103356: PUSH
103357: LD_VAR 0 8
103361: ARRAY
103362: PPUSH
103363: CALL 98813 0 2
// x := tmp [ j ] ;
103367: LD_ADDR_VAR 0 10
103371: PUSH
103372: LD_VAR 0 14
103376: PUSH
103377: LD_VAR 0 8
103381: ARRAY
103382: ST_TO_ADDR
// attacking := true ;
103383: LD_ADDR_VAR 0 29
103387: PUSH
103388: LD_INT 1
103390: ST_TO_ADDR
// end ; end ;
103391: GO 103317
103393: POP
103394: POP
// if not x then
103395: LD_VAR 0 10
103399: NOT
103400: IFFALSE 103540
// begin attacking := true ;
103402: LD_ADDR_VAR 0 29
103406: PUSH
103407: LD_INT 1
103409: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103410: LD_VAR 0 4
103414: PUSH
103415: LD_VAR 0 7
103419: ARRAY
103420: PPUSH
103421: CALL_OW 250
103425: PPUSH
103426: LD_VAR 0 4
103430: PUSH
103431: LD_VAR 0 7
103435: ARRAY
103436: PPUSH
103437: CALL_OW 251
103441: PPUSH
103442: CALL_OW 546
103446: PUSH
103447: LD_INT 2
103449: ARRAY
103450: PUSH
103451: LD_VAR 0 14
103455: PUSH
103456: LD_INT 1
103458: ARRAY
103459: PPUSH
103460: CALL_OW 250
103464: PPUSH
103465: LD_VAR 0 14
103469: PUSH
103470: LD_INT 1
103472: ARRAY
103473: PPUSH
103474: CALL_OW 251
103478: PPUSH
103479: CALL_OW 546
103483: PUSH
103484: LD_INT 2
103486: ARRAY
103487: EQUAL
103488: IFFALSE 103516
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103490: LD_VAR 0 4
103494: PUSH
103495: LD_VAR 0 7
103499: ARRAY
103500: PPUSH
103501: LD_VAR 0 14
103505: PUSH
103506: LD_INT 1
103508: ARRAY
103509: PPUSH
103510: CALL 98813 0 2
103514: GO 103540
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: LD_VAR 0 14
103531: PUSH
103532: LD_INT 1
103534: ARRAY
103535: PPUSH
103536: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103540: LD_VAR 0 4
103544: PUSH
103545: LD_VAR 0 7
103549: ARRAY
103550: PPUSH
103551: CALL_OW 264
103555: PUSH
103556: LD_INT 29
103558: EQUAL
103559: IFFALSE 103925
// begin if WantsToAttack ( group [ i ] ) in bombed then
103561: LD_VAR 0 4
103565: PUSH
103566: LD_VAR 0 7
103570: ARRAY
103571: PPUSH
103572: CALL_OW 319
103576: PUSH
103577: LD_VAR 0 28
103581: IN
103582: IFFALSE 103586
// continue ;
103584: GO 100616
// k := 8 ;
103586: LD_ADDR_VAR 0 9
103590: PUSH
103591: LD_INT 8
103593: ST_TO_ADDR
// x := 0 ;
103594: LD_ADDR_VAR 0 10
103598: PUSH
103599: LD_INT 0
103601: ST_TO_ADDR
// if tmp < k then
103602: LD_VAR 0 14
103606: PUSH
103607: LD_VAR 0 9
103611: LESS
103612: IFFALSE 103624
// k := tmp ;
103614: LD_ADDR_VAR 0 9
103618: PUSH
103619: LD_VAR 0 14
103623: ST_TO_ADDR
// for j = 1 to k do
103624: LD_ADDR_VAR 0 8
103628: PUSH
103629: DOUBLE
103630: LD_INT 1
103632: DEC
103633: ST_TO_ADDR
103634: LD_VAR 0 9
103638: PUSH
103639: FOR_TO
103640: IFFALSE 103772
// begin if GetType ( tmp [ j ] ) = unit_building then
103642: LD_VAR 0 14
103646: PUSH
103647: LD_VAR 0 8
103651: ARRAY
103652: PPUSH
103653: CALL_OW 247
103657: PUSH
103658: LD_INT 3
103660: EQUAL
103661: IFFALSE 103770
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103663: LD_VAR 0 14
103667: PUSH
103668: LD_VAR 0 8
103672: ARRAY
103673: PUSH
103674: LD_VAR 0 28
103678: IN
103679: NOT
103680: PUSH
103681: LD_VAR 0 14
103685: PUSH
103686: LD_VAR 0 8
103690: ARRAY
103691: PPUSH
103692: CALL_OW 313
103696: AND
103697: IFFALSE 103770
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103699: LD_VAR 0 4
103703: PUSH
103704: LD_VAR 0 7
103708: ARRAY
103709: PPUSH
103710: LD_VAR 0 14
103714: PUSH
103715: LD_VAR 0 8
103719: ARRAY
103720: PPUSH
103721: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103725: LD_ADDR_VAR 0 28
103729: PUSH
103730: LD_VAR 0 28
103734: PPUSH
103735: LD_VAR 0 28
103739: PUSH
103740: LD_INT 1
103742: PLUS
103743: PPUSH
103744: LD_VAR 0 14
103748: PUSH
103749: LD_VAR 0 8
103753: ARRAY
103754: PPUSH
103755: CALL_OW 1
103759: ST_TO_ADDR
// attacking := true ;
103760: LD_ADDR_VAR 0 29
103764: PUSH
103765: LD_INT 1
103767: ST_TO_ADDR
// break ;
103768: GO 103772
// end ; end ;
103770: GO 103639
103772: POP
103773: POP
// if not attacking and f_attack_depot then
103774: LD_VAR 0 29
103778: NOT
103779: PUSH
103780: LD_VAR 0 25
103784: AND
103785: IFFALSE 103880
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103787: LD_ADDR_VAR 0 13
103791: PUSH
103792: LD_VAR 0 14
103796: PPUSH
103797: LD_INT 2
103799: PUSH
103800: LD_INT 30
103802: PUSH
103803: LD_INT 0
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PUSH
103810: LD_INT 30
103812: PUSH
103813: LD_INT 1
103815: PUSH
103816: EMPTY
103817: LIST
103818: LIST
103819: PUSH
103820: EMPTY
103821: LIST
103822: LIST
103823: LIST
103824: PPUSH
103825: CALL_OW 72
103829: ST_TO_ADDR
// if z then
103830: LD_VAR 0 13
103834: IFFALSE 103880
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103836: LD_VAR 0 4
103840: PUSH
103841: LD_VAR 0 7
103845: ARRAY
103846: PPUSH
103847: LD_VAR 0 13
103851: PPUSH
103852: LD_VAR 0 4
103856: PUSH
103857: LD_VAR 0 7
103861: ARRAY
103862: PPUSH
103863: CALL_OW 74
103867: PPUSH
103868: CALL_OW 115
// attacking := true ;
103872: LD_ADDR_VAR 0 29
103876: PUSH
103877: LD_INT 1
103879: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103880: LD_VAR 0 4
103884: PUSH
103885: LD_VAR 0 7
103889: ARRAY
103890: PPUSH
103891: CALL_OW 256
103895: PUSH
103896: LD_INT 500
103898: LESS
103899: IFFALSE 103925
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103901: LD_VAR 0 4
103905: PUSH
103906: LD_VAR 0 7
103910: ARRAY
103911: PPUSH
103912: LD_VAR 0 14
103916: PUSH
103917: LD_INT 1
103919: ARRAY
103920: PPUSH
103921: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103925: LD_VAR 0 4
103929: PUSH
103930: LD_VAR 0 7
103934: ARRAY
103935: PPUSH
103936: CALL_OW 264
103940: PUSH
103941: LD_INT 49
103943: EQUAL
103944: IFFALSE 104065
// begin if not HasTask ( group [ i ] ) then
103946: LD_VAR 0 4
103950: PUSH
103951: LD_VAR 0 7
103955: ARRAY
103956: PPUSH
103957: CALL_OW 314
103961: NOT
103962: IFFALSE 104065
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103964: LD_ADDR_VAR 0 9
103968: PUSH
103969: LD_INT 81
103971: PUSH
103972: LD_VAR 0 4
103976: PUSH
103977: LD_VAR 0 7
103981: ARRAY
103982: PPUSH
103983: CALL_OW 255
103987: PUSH
103988: EMPTY
103989: LIST
103990: LIST
103991: PPUSH
103992: CALL_OW 69
103996: PPUSH
103997: LD_VAR 0 4
104001: PUSH
104002: LD_VAR 0 7
104006: ARRAY
104007: PPUSH
104008: CALL_OW 74
104012: ST_TO_ADDR
// if k then
104013: LD_VAR 0 9
104017: IFFALSE 104065
// if GetDistUnits ( group [ i ] , k ) > 10 then
104019: LD_VAR 0 4
104023: PUSH
104024: LD_VAR 0 7
104028: ARRAY
104029: PPUSH
104030: LD_VAR 0 9
104034: PPUSH
104035: CALL_OW 296
104039: PUSH
104040: LD_INT 10
104042: GREATER
104043: IFFALSE 104065
// ComMoveUnit ( group [ i ] , k ) ;
104045: LD_VAR 0 4
104049: PUSH
104050: LD_VAR 0 7
104054: ARRAY
104055: PPUSH
104056: LD_VAR 0 9
104060: PPUSH
104061: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104065: LD_VAR 0 4
104069: PUSH
104070: LD_VAR 0 7
104074: ARRAY
104075: PPUSH
104076: CALL_OW 256
104080: PUSH
104081: LD_INT 250
104083: LESS
104084: PUSH
104085: LD_VAR 0 4
104089: PUSH
104090: LD_VAR 0 7
104094: ARRAY
104095: PUSH
104096: LD_INT 21
104098: PUSH
104099: LD_INT 2
104101: PUSH
104102: EMPTY
104103: LIST
104104: LIST
104105: PUSH
104106: LD_INT 23
104108: PUSH
104109: LD_INT 2
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: PPUSH
104120: CALL_OW 69
104124: IN
104125: AND
104126: IFFALSE 104251
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104128: LD_ADDR_VAR 0 9
104132: PUSH
104133: LD_OWVAR 3
104137: PUSH
104138: LD_VAR 0 4
104142: PUSH
104143: LD_VAR 0 7
104147: ARRAY
104148: DIFF
104149: PPUSH
104150: LD_VAR 0 4
104154: PUSH
104155: LD_VAR 0 7
104159: ARRAY
104160: PPUSH
104161: CALL_OW 74
104165: ST_TO_ADDR
// if not k then
104166: LD_VAR 0 9
104170: NOT
104171: IFFALSE 104175
// continue ;
104173: GO 100616
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104175: LD_VAR 0 9
104179: PUSH
104180: LD_INT 81
104182: PUSH
104183: LD_VAR 0 4
104187: PUSH
104188: LD_VAR 0 7
104192: ARRAY
104193: PPUSH
104194: CALL_OW 255
104198: PUSH
104199: EMPTY
104200: LIST
104201: LIST
104202: PPUSH
104203: CALL_OW 69
104207: IN
104208: PUSH
104209: LD_VAR 0 9
104213: PPUSH
104214: LD_VAR 0 4
104218: PUSH
104219: LD_VAR 0 7
104223: ARRAY
104224: PPUSH
104225: CALL_OW 296
104229: PUSH
104230: LD_INT 5
104232: LESS
104233: AND
104234: IFFALSE 104251
// ComAutodestruct ( group [ i ] ) ;
104236: LD_VAR 0 4
104240: PUSH
104241: LD_VAR 0 7
104245: ARRAY
104246: PPUSH
104247: CALL 98711 0 1
// end ; if f_attack_depot then
104251: LD_VAR 0 25
104255: IFFALSE 104367
// begin k := 6 ;
104257: LD_ADDR_VAR 0 9
104261: PUSH
104262: LD_INT 6
104264: ST_TO_ADDR
// if tmp < k then
104265: LD_VAR 0 14
104269: PUSH
104270: LD_VAR 0 9
104274: LESS
104275: IFFALSE 104287
// k := tmp ;
104277: LD_ADDR_VAR 0 9
104281: PUSH
104282: LD_VAR 0 14
104286: ST_TO_ADDR
// for j = 1 to k do
104287: LD_ADDR_VAR 0 8
104291: PUSH
104292: DOUBLE
104293: LD_INT 1
104295: DEC
104296: ST_TO_ADDR
104297: LD_VAR 0 9
104301: PUSH
104302: FOR_TO
104303: IFFALSE 104365
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104305: LD_VAR 0 8
104309: PPUSH
104310: CALL_OW 266
104314: PUSH
104315: LD_INT 0
104317: PUSH
104318: LD_INT 1
104320: PUSH
104321: EMPTY
104322: LIST
104323: LIST
104324: IN
104325: IFFALSE 104363
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104327: LD_VAR 0 4
104331: PUSH
104332: LD_VAR 0 7
104336: ARRAY
104337: PPUSH
104338: LD_VAR 0 14
104342: PUSH
104343: LD_VAR 0 8
104347: ARRAY
104348: PPUSH
104349: CALL_OW 115
// attacking := true ;
104353: LD_ADDR_VAR 0 29
104357: PUSH
104358: LD_INT 1
104360: ST_TO_ADDR
// break ;
104361: GO 104365
// end ;
104363: GO 104302
104365: POP
104366: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104367: LD_VAR 0 4
104371: PUSH
104372: LD_VAR 0 7
104376: ARRAY
104377: PPUSH
104378: CALL_OW 302
104382: PUSH
104383: LD_VAR 0 29
104387: NOT
104388: AND
104389: IFFALSE 104711
// begin if GetTag ( group [ i ] ) = 71 then
104391: LD_VAR 0 4
104395: PUSH
104396: LD_VAR 0 7
104400: ARRAY
104401: PPUSH
104402: CALL_OW 110
104406: PUSH
104407: LD_INT 71
104409: EQUAL
104410: IFFALSE 104451
// begin if HasTask ( group [ i ] ) then
104412: LD_VAR 0 4
104416: PUSH
104417: LD_VAR 0 7
104421: ARRAY
104422: PPUSH
104423: CALL_OW 314
104427: IFFALSE 104433
// continue else
104429: GO 100616
104431: GO 104451
// SetTag ( group [ i ] , 0 ) ;
104433: LD_VAR 0 4
104437: PUSH
104438: LD_VAR 0 7
104442: ARRAY
104443: PPUSH
104444: LD_INT 0
104446: PPUSH
104447: CALL_OW 109
// end ; k := 8 ;
104451: LD_ADDR_VAR 0 9
104455: PUSH
104456: LD_INT 8
104458: ST_TO_ADDR
// x := 0 ;
104459: LD_ADDR_VAR 0 10
104463: PUSH
104464: LD_INT 0
104466: ST_TO_ADDR
// if tmp < k then
104467: LD_VAR 0 14
104471: PUSH
104472: LD_VAR 0 9
104476: LESS
104477: IFFALSE 104489
// k := tmp ;
104479: LD_ADDR_VAR 0 9
104483: PUSH
104484: LD_VAR 0 14
104488: ST_TO_ADDR
// for j = 1 to k do
104489: LD_ADDR_VAR 0 8
104493: PUSH
104494: DOUBLE
104495: LD_INT 1
104497: DEC
104498: ST_TO_ADDR
104499: LD_VAR 0 9
104503: PUSH
104504: FOR_TO
104505: IFFALSE 104603
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104507: LD_VAR 0 14
104511: PUSH
104512: LD_VAR 0 8
104516: ARRAY
104517: PPUSH
104518: CALL_OW 247
104522: PUSH
104523: LD_INT 1
104525: EQUAL
104526: PUSH
104527: LD_VAR 0 14
104531: PUSH
104532: LD_VAR 0 8
104536: ARRAY
104537: PPUSH
104538: CALL_OW 256
104542: PUSH
104543: LD_INT 250
104545: LESS
104546: PUSH
104547: LD_VAR 0 20
104551: AND
104552: PUSH
104553: LD_VAR 0 20
104557: NOT
104558: PUSH
104559: LD_VAR 0 14
104563: PUSH
104564: LD_VAR 0 8
104568: ARRAY
104569: PPUSH
104570: CALL_OW 256
104574: PUSH
104575: LD_INT 250
104577: GREATEREQUAL
104578: AND
104579: OR
104580: AND
104581: IFFALSE 104601
// begin x := tmp [ j ] ;
104583: LD_ADDR_VAR 0 10
104587: PUSH
104588: LD_VAR 0 14
104592: PUSH
104593: LD_VAR 0 8
104597: ARRAY
104598: ST_TO_ADDR
// break ;
104599: GO 104603
// end ;
104601: GO 104504
104603: POP
104604: POP
// if x then
104605: LD_VAR 0 10
104609: IFFALSE 104633
// ComAttackUnit ( group [ i ] , x ) else
104611: LD_VAR 0 4
104615: PUSH
104616: LD_VAR 0 7
104620: ARRAY
104621: PPUSH
104622: LD_VAR 0 10
104626: PPUSH
104627: CALL_OW 115
104631: GO 104657
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104633: LD_VAR 0 4
104637: PUSH
104638: LD_VAR 0 7
104642: ARRAY
104643: PPUSH
104644: LD_VAR 0 14
104648: PUSH
104649: LD_INT 1
104651: ARRAY
104652: PPUSH
104653: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104657: LD_VAR 0 4
104661: PUSH
104662: LD_VAR 0 7
104666: ARRAY
104667: PPUSH
104668: CALL_OW 314
104672: NOT
104673: IFFALSE 104711
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104675: LD_VAR 0 4
104679: PUSH
104680: LD_VAR 0 7
104684: ARRAY
104685: PPUSH
104686: LD_VAR 0 14
104690: PPUSH
104691: LD_VAR 0 4
104695: PUSH
104696: LD_VAR 0 7
104700: ARRAY
104701: PPUSH
104702: CALL_OW 74
104706: PPUSH
104707: CALL_OW 115
// end ; end ; end ;
104711: GO 100616
104713: POP
104714: POP
// wait ( 0 0$1 ) ;
104715: LD_INT 35
104717: PPUSH
104718: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104722: LD_VAR 0 4
104726: PUSH
104727: EMPTY
104728: EQUAL
104729: PUSH
104730: LD_INT 81
104732: PUSH
104733: LD_VAR 0 35
104737: PUSH
104738: EMPTY
104739: LIST
104740: LIST
104741: PPUSH
104742: CALL_OW 69
104746: NOT
104747: OR
104748: IFFALSE 100601
// end ;
104750: LD_VAR 0 2
104754: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104755: LD_INT 0
104757: PPUSH
104758: PPUSH
104759: PPUSH
104760: PPUSH
// if not base_units then
104761: LD_VAR 0 1
104765: NOT
104766: IFFALSE 104770
// exit ;
104768: GO 104857
// result := false ;
104770: LD_ADDR_VAR 0 2
104774: PUSH
104775: LD_INT 0
104777: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104778: LD_ADDR_VAR 0 5
104782: PUSH
104783: LD_VAR 0 1
104787: PPUSH
104788: LD_INT 21
104790: PUSH
104791: LD_INT 3
104793: PUSH
104794: EMPTY
104795: LIST
104796: LIST
104797: PPUSH
104798: CALL_OW 72
104802: ST_TO_ADDR
// if not tmp then
104803: LD_VAR 0 5
104807: NOT
104808: IFFALSE 104812
// exit ;
104810: GO 104857
// for i in tmp do
104812: LD_ADDR_VAR 0 3
104816: PUSH
104817: LD_VAR 0 5
104821: PUSH
104822: FOR_IN
104823: IFFALSE 104855
// begin result := EnemyInRange ( i , 22 ) ;
104825: LD_ADDR_VAR 0 2
104829: PUSH
104830: LD_VAR 0 3
104834: PPUSH
104835: LD_INT 22
104837: PPUSH
104838: CALL 98394 0 2
104842: ST_TO_ADDR
// if result then
104843: LD_VAR 0 2
104847: IFFALSE 104853
// exit ;
104849: POP
104850: POP
104851: GO 104857
// end ;
104853: GO 104822
104855: POP
104856: POP
// end ;
104857: LD_VAR 0 2
104861: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104862: LD_INT 0
104864: PPUSH
104865: PPUSH
// if not units then
104866: LD_VAR 0 1
104870: NOT
104871: IFFALSE 104875
// exit ;
104873: GO 104945
// result := [ ] ;
104875: LD_ADDR_VAR 0 3
104879: PUSH
104880: EMPTY
104881: ST_TO_ADDR
// for i in units do
104882: LD_ADDR_VAR 0 4
104886: PUSH
104887: LD_VAR 0 1
104891: PUSH
104892: FOR_IN
104893: IFFALSE 104943
// if GetTag ( i ) = tag then
104895: LD_VAR 0 4
104899: PPUSH
104900: CALL_OW 110
104904: PUSH
104905: LD_VAR 0 2
104909: EQUAL
104910: IFFALSE 104941
// result := Insert ( result , result + 1 , i ) ;
104912: LD_ADDR_VAR 0 3
104916: PUSH
104917: LD_VAR 0 3
104921: PPUSH
104922: LD_VAR 0 3
104926: PUSH
104927: LD_INT 1
104929: PLUS
104930: PPUSH
104931: LD_VAR 0 4
104935: PPUSH
104936: CALL_OW 2
104940: ST_TO_ADDR
104941: GO 104892
104943: POP
104944: POP
// end ;
104945: LD_VAR 0 3
104949: RET
// export function IsDriver ( un ) ; begin
104950: LD_INT 0
104952: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104953: LD_ADDR_VAR 0 2
104957: PUSH
104958: LD_VAR 0 1
104962: PUSH
104963: LD_INT 55
104965: PUSH
104966: EMPTY
104967: LIST
104968: PPUSH
104969: CALL_OW 69
104973: IN
104974: ST_TO_ADDR
// end ;
104975: LD_VAR 0 2
104979: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104980: LD_INT 0
104982: PPUSH
104983: PPUSH
// list := [ ] ;
104984: LD_ADDR_VAR 0 5
104988: PUSH
104989: EMPTY
104990: ST_TO_ADDR
// case d of 0 :
104991: LD_VAR 0 3
104995: PUSH
104996: LD_INT 0
104998: DOUBLE
104999: EQUAL
105000: IFTRUE 105004
105002: GO 105137
105004: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105005: LD_ADDR_VAR 0 5
105009: PUSH
105010: LD_VAR 0 1
105014: PUSH
105015: LD_INT 4
105017: MINUS
105018: PUSH
105019: LD_VAR 0 2
105023: PUSH
105024: LD_INT 4
105026: MINUS
105027: PUSH
105028: LD_INT 2
105030: PUSH
105031: EMPTY
105032: LIST
105033: LIST
105034: LIST
105035: PUSH
105036: LD_VAR 0 1
105040: PUSH
105041: LD_INT 3
105043: MINUS
105044: PUSH
105045: LD_VAR 0 2
105049: PUSH
105050: LD_INT 1
105052: PUSH
105053: EMPTY
105054: LIST
105055: LIST
105056: LIST
105057: PUSH
105058: LD_VAR 0 1
105062: PUSH
105063: LD_INT 4
105065: PLUS
105066: PUSH
105067: LD_VAR 0 2
105071: PUSH
105072: LD_INT 4
105074: PUSH
105075: EMPTY
105076: LIST
105077: LIST
105078: LIST
105079: PUSH
105080: LD_VAR 0 1
105084: PUSH
105085: LD_INT 3
105087: PLUS
105088: PUSH
105089: LD_VAR 0 2
105093: PUSH
105094: LD_INT 3
105096: PLUS
105097: PUSH
105098: LD_INT 5
105100: PUSH
105101: EMPTY
105102: LIST
105103: LIST
105104: LIST
105105: PUSH
105106: LD_VAR 0 1
105110: PUSH
105111: LD_VAR 0 2
105115: PUSH
105116: LD_INT 4
105118: PLUS
105119: PUSH
105120: LD_INT 0
105122: PUSH
105123: EMPTY
105124: LIST
105125: LIST
105126: LIST
105127: PUSH
105128: EMPTY
105129: LIST
105130: LIST
105131: LIST
105132: LIST
105133: LIST
105134: ST_TO_ADDR
// end ; 1 :
105135: GO 105835
105137: LD_INT 1
105139: DOUBLE
105140: EQUAL
105141: IFTRUE 105145
105143: GO 105278
105145: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105146: LD_ADDR_VAR 0 5
105150: PUSH
105151: LD_VAR 0 1
105155: PUSH
105156: LD_VAR 0 2
105160: PUSH
105161: LD_INT 4
105163: MINUS
105164: PUSH
105165: LD_INT 3
105167: PUSH
105168: EMPTY
105169: LIST
105170: LIST
105171: LIST
105172: PUSH
105173: LD_VAR 0 1
105177: PUSH
105178: LD_INT 3
105180: MINUS
105181: PUSH
105182: LD_VAR 0 2
105186: PUSH
105187: LD_INT 3
105189: MINUS
105190: PUSH
105191: LD_INT 2
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: LIST
105198: PUSH
105199: LD_VAR 0 1
105203: PUSH
105204: LD_INT 4
105206: MINUS
105207: PUSH
105208: LD_VAR 0 2
105212: PUSH
105213: LD_INT 1
105215: PUSH
105216: EMPTY
105217: LIST
105218: LIST
105219: LIST
105220: PUSH
105221: LD_VAR 0 1
105225: PUSH
105226: LD_VAR 0 2
105230: PUSH
105231: LD_INT 3
105233: PLUS
105234: PUSH
105235: LD_INT 0
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: LIST
105242: PUSH
105243: LD_VAR 0 1
105247: PUSH
105248: LD_INT 4
105250: PLUS
105251: PUSH
105252: LD_VAR 0 2
105256: PUSH
105257: LD_INT 4
105259: PLUS
105260: PUSH
105261: LD_INT 5
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: LIST
105268: PUSH
105269: EMPTY
105270: LIST
105271: LIST
105272: LIST
105273: LIST
105274: LIST
105275: ST_TO_ADDR
// end ; 2 :
105276: GO 105835
105278: LD_INT 2
105280: DOUBLE
105281: EQUAL
105282: IFTRUE 105286
105284: GO 105415
105286: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105287: LD_ADDR_VAR 0 5
105291: PUSH
105292: LD_VAR 0 1
105296: PUSH
105297: LD_VAR 0 2
105301: PUSH
105302: LD_INT 3
105304: MINUS
105305: PUSH
105306: LD_INT 3
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: LIST
105313: PUSH
105314: LD_VAR 0 1
105318: PUSH
105319: LD_INT 4
105321: PLUS
105322: PUSH
105323: LD_VAR 0 2
105327: PUSH
105328: LD_INT 4
105330: PUSH
105331: EMPTY
105332: LIST
105333: LIST
105334: LIST
105335: PUSH
105336: LD_VAR 0 1
105340: PUSH
105341: LD_VAR 0 2
105345: PUSH
105346: LD_INT 4
105348: PLUS
105349: PUSH
105350: LD_INT 0
105352: PUSH
105353: EMPTY
105354: LIST
105355: LIST
105356: LIST
105357: PUSH
105358: LD_VAR 0 1
105362: PUSH
105363: LD_INT 3
105365: MINUS
105366: PUSH
105367: LD_VAR 0 2
105371: PUSH
105372: LD_INT 1
105374: PUSH
105375: EMPTY
105376: LIST
105377: LIST
105378: LIST
105379: PUSH
105380: LD_VAR 0 1
105384: PUSH
105385: LD_INT 4
105387: MINUS
105388: PUSH
105389: LD_VAR 0 2
105393: PUSH
105394: LD_INT 4
105396: MINUS
105397: PUSH
105398: LD_INT 2
105400: PUSH
105401: EMPTY
105402: LIST
105403: LIST
105404: LIST
105405: PUSH
105406: EMPTY
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: LIST
105412: ST_TO_ADDR
// end ; 3 :
105413: GO 105835
105415: LD_INT 3
105417: DOUBLE
105418: EQUAL
105419: IFTRUE 105423
105421: GO 105556
105423: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105424: LD_ADDR_VAR 0 5
105428: PUSH
105429: LD_VAR 0 1
105433: PUSH
105434: LD_INT 3
105436: PLUS
105437: PUSH
105438: LD_VAR 0 2
105442: PUSH
105443: LD_INT 4
105445: PUSH
105446: EMPTY
105447: LIST
105448: LIST
105449: LIST
105450: PUSH
105451: LD_VAR 0 1
105455: PUSH
105456: LD_INT 4
105458: PLUS
105459: PUSH
105460: LD_VAR 0 2
105464: PUSH
105465: LD_INT 4
105467: PLUS
105468: PUSH
105469: LD_INT 5
105471: PUSH
105472: EMPTY
105473: LIST
105474: LIST
105475: LIST
105476: PUSH
105477: LD_VAR 0 1
105481: PUSH
105482: LD_INT 4
105484: MINUS
105485: PUSH
105486: LD_VAR 0 2
105490: PUSH
105491: LD_INT 1
105493: PUSH
105494: EMPTY
105495: LIST
105496: LIST
105497: LIST
105498: PUSH
105499: LD_VAR 0 1
105503: PUSH
105504: LD_VAR 0 2
105508: PUSH
105509: LD_INT 4
105511: MINUS
105512: PUSH
105513: LD_INT 3
105515: PUSH
105516: EMPTY
105517: LIST
105518: LIST
105519: LIST
105520: PUSH
105521: LD_VAR 0 1
105525: PUSH
105526: LD_INT 3
105528: MINUS
105529: PUSH
105530: LD_VAR 0 2
105534: PUSH
105535: LD_INT 3
105537: MINUS
105538: PUSH
105539: LD_INT 2
105541: PUSH
105542: EMPTY
105543: LIST
105544: LIST
105545: LIST
105546: PUSH
105547: EMPTY
105548: LIST
105549: LIST
105550: LIST
105551: LIST
105552: LIST
105553: ST_TO_ADDR
// end ; 4 :
105554: GO 105835
105556: LD_INT 4
105558: DOUBLE
105559: EQUAL
105560: IFTRUE 105564
105562: GO 105697
105564: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105565: LD_ADDR_VAR 0 5
105569: PUSH
105570: LD_VAR 0 1
105574: PUSH
105575: LD_VAR 0 2
105579: PUSH
105580: LD_INT 4
105582: PLUS
105583: PUSH
105584: LD_INT 0
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: LIST
105591: PUSH
105592: LD_VAR 0 1
105596: PUSH
105597: LD_INT 3
105599: PLUS
105600: PUSH
105601: LD_VAR 0 2
105605: PUSH
105606: LD_INT 3
105608: PLUS
105609: PUSH
105610: LD_INT 5
105612: PUSH
105613: EMPTY
105614: LIST
105615: LIST
105616: LIST
105617: PUSH
105618: LD_VAR 0 1
105622: PUSH
105623: LD_INT 4
105625: PLUS
105626: PUSH
105627: LD_VAR 0 2
105631: PUSH
105632: LD_INT 4
105634: PUSH
105635: EMPTY
105636: LIST
105637: LIST
105638: LIST
105639: PUSH
105640: LD_VAR 0 1
105644: PUSH
105645: LD_VAR 0 2
105649: PUSH
105650: LD_INT 3
105652: MINUS
105653: PUSH
105654: LD_INT 3
105656: PUSH
105657: EMPTY
105658: LIST
105659: LIST
105660: LIST
105661: PUSH
105662: LD_VAR 0 1
105666: PUSH
105667: LD_INT 4
105669: MINUS
105670: PUSH
105671: LD_VAR 0 2
105675: PUSH
105676: LD_INT 4
105678: MINUS
105679: PUSH
105680: LD_INT 2
105682: PUSH
105683: EMPTY
105684: LIST
105685: LIST
105686: LIST
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: LIST
105692: LIST
105693: LIST
105694: ST_TO_ADDR
// end ; 5 :
105695: GO 105835
105697: LD_INT 5
105699: DOUBLE
105700: EQUAL
105701: IFTRUE 105705
105703: GO 105834
105705: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105706: LD_ADDR_VAR 0 5
105710: PUSH
105711: LD_VAR 0 1
105715: PUSH
105716: LD_INT 4
105718: MINUS
105719: PUSH
105720: LD_VAR 0 2
105724: PUSH
105725: LD_INT 1
105727: PUSH
105728: EMPTY
105729: LIST
105730: LIST
105731: LIST
105732: PUSH
105733: LD_VAR 0 1
105737: PUSH
105738: LD_VAR 0 2
105742: PUSH
105743: LD_INT 4
105745: MINUS
105746: PUSH
105747: LD_INT 3
105749: PUSH
105750: EMPTY
105751: LIST
105752: LIST
105753: LIST
105754: PUSH
105755: LD_VAR 0 1
105759: PUSH
105760: LD_INT 4
105762: PLUS
105763: PUSH
105764: LD_VAR 0 2
105768: PUSH
105769: LD_INT 4
105771: PLUS
105772: PUSH
105773: LD_INT 5
105775: PUSH
105776: EMPTY
105777: LIST
105778: LIST
105779: LIST
105780: PUSH
105781: LD_VAR 0 1
105785: PUSH
105786: LD_INT 3
105788: PLUS
105789: PUSH
105790: LD_VAR 0 2
105794: PUSH
105795: LD_INT 4
105797: PUSH
105798: EMPTY
105799: LIST
105800: LIST
105801: LIST
105802: PUSH
105803: LD_VAR 0 1
105807: PUSH
105808: LD_VAR 0 2
105812: PUSH
105813: LD_INT 3
105815: PLUS
105816: PUSH
105817: LD_INT 0
105819: PUSH
105820: EMPTY
105821: LIST
105822: LIST
105823: LIST
105824: PUSH
105825: EMPTY
105826: LIST
105827: LIST
105828: LIST
105829: LIST
105830: LIST
105831: ST_TO_ADDR
// end ; end ;
105832: GO 105835
105834: POP
// result := list ;
105835: LD_ADDR_VAR 0 4
105839: PUSH
105840: LD_VAR 0 5
105844: ST_TO_ADDR
// end ;
105845: LD_VAR 0 4
105849: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105850: LD_INT 0
105852: PPUSH
105853: PPUSH
105854: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105855: LD_VAR 0 1
105859: NOT
105860: PUSH
105861: LD_VAR 0 2
105865: PUSH
105866: LD_INT 1
105868: PUSH
105869: LD_INT 2
105871: PUSH
105872: LD_INT 3
105874: PUSH
105875: LD_INT 4
105877: PUSH
105878: EMPTY
105879: LIST
105880: LIST
105881: LIST
105882: LIST
105883: IN
105884: NOT
105885: OR
105886: IFFALSE 105890
// exit ;
105888: GO 105982
// tmp := [ ] ;
105890: LD_ADDR_VAR 0 5
105894: PUSH
105895: EMPTY
105896: ST_TO_ADDR
// for i in units do
105897: LD_ADDR_VAR 0 4
105901: PUSH
105902: LD_VAR 0 1
105906: PUSH
105907: FOR_IN
105908: IFFALSE 105951
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105910: LD_ADDR_VAR 0 5
105914: PUSH
105915: LD_VAR 0 5
105919: PPUSH
105920: LD_VAR 0 5
105924: PUSH
105925: LD_INT 1
105927: PLUS
105928: PPUSH
105929: LD_VAR 0 4
105933: PPUSH
105934: LD_VAR 0 2
105938: PPUSH
105939: CALL_OW 259
105943: PPUSH
105944: CALL_OW 2
105948: ST_TO_ADDR
105949: GO 105907
105951: POP
105952: POP
// if not tmp then
105953: LD_VAR 0 5
105957: NOT
105958: IFFALSE 105962
// exit ;
105960: GO 105982
// result := SortListByListDesc ( units , tmp ) ;
105962: LD_ADDR_VAR 0 3
105966: PUSH
105967: LD_VAR 0 1
105971: PPUSH
105972: LD_VAR 0 5
105976: PPUSH
105977: CALL_OW 77
105981: ST_TO_ADDR
// end ;
105982: LD_VAR 0 3
105986: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105987: LD_INT 0
105989: PPUSH
105990: PPUSH
105991: PPUSH
// x := GetX ( building ) ;
105992: LD_ADDR_VAR 0 4
105996: PUSH
105997: LD_VAR 0 2
106001: PPUSH
106002: CALL_OW 250
106006: ST_TO_ADDR
// y := GetY ( building ) ;
106007: LD_ADDR_VAR 0 5
106011: PUSH
106012: LD_VAR 0 2
106016: PPUSH
106017: CALL_OW 251
106021: ST_TO_ADDR
// if GetTaskList ( unit ) then
106022: LD_VAR 0 1
106026: PPUSH
106027: CALL_OW 437
106031: IFFALSE 106126
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106033: LD_STRING e
106035: PUSH
106036: LD_VAR 0 1
106040: PPUSH
106041: CALL_OW 437
106045: PUSH
106046: LD_INT 1
106048: ARRAY
106049: PUSH
106050: LD_INT 1
106052: ARRAY
106053: EQUAL
106054: PUSH
106055: LD_VAR 0 4
106059: PUSH
106060: LD_VAR 0 1
106064: PPUSH
106065: CALL_OW 437
106069: PUSH
106070: LD_INT 1
106072: ARRAY
106073: PUSH
106074: LD_INT 2
106076: ARRAY
106077: EQUAL
106078: AND
106079: PUSH
106080: LD_VAR 0 5
106084: PUSH
106085: LD_VAR 0 1
106089: PPUSH
106090: CALL_OW 437
106094: PUSH
106095: LD_INT 1
106097: ARRAY
106098: PUSH
106099: LD_INT 3
106101: ARRAY
106102: EQUAL
106103: AND
106104: IFFALSE 106116
// result := true else
106106: LD_ADDR_VAR 0 3
106110: PUSH
106111: LD_INT 1
106113: ST_TO_ADDR
106114: GO 106124
// result := false ;
106116: LD_ADDR_VAR 0 3
106120: PUSH
106121: LD_INT 0
106123: ST_TO_ADDR
// end else
106124: GO 106134
// result := false ;
106126: LD_ADDR_VAR 0 3
106130: PUSH
106131: LD_INT 0
106133: ST_TO_ADDR
// end ;
106134: LD_VAR 0 3
106138: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106139: LD_INT 0
106141: PPUSH
106142: PPUSH
106143: PPUSH
106144: PPUSH
// if not unit or not area then
106145: LD_VAR 0 1
106149: NOT
106150: PUSH
106151: LD_VAR 0 2
106155: NOT
106156: OR
106157: IFFALSE 106161
// exit ;
106159: GO 106325
// tmp := AreaToList ( area , i ) ;
106161: LD_ADDR_VAR 0 6
106165: PUSH
106166: LD_VAR 0 2
106170: PPUSH
106171: LD_VAR 0 5
106175: PPUSH
106176: CALL_OW 517
106180: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106181: LD_ADDR_VAR 0 5
106185: PUSH
106186: DOUBLE
106187: LD_INT 1
106189: DEC
106190: ST_TO_ADDR
106191: LD_VAR 0 6
106195: PUSH
106196: LD_INT 1
106198: ARRAY
106199: PUSH
106200: FOR_TO
106201: IFFALSE 106323
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106203: LD_ADDR_VAR 0 7
106207: PUSH
106208: LD_VAR 0 6
106212: PUSH
106213: LD_INT 1
106215: ARRAY
106216: PUSH
106217: LD_VAR 0 5
106221: ARRAY
106222: PUSH
106223: LD_VAR 0 6
106227: PUSH
106228: LD_INT 2
106230: ARRAY
106231: PUSH
106232: LD_VAR 0 5
106236: ARRAY
106237: PUSH
106238: EMPTY
106239: LIST
106240: LIST
106241: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106242: LD_VAR 0 7
106246: PUSH
106247: LD_INT 1
106249: ARRAY
106250: PPUSH
106251: LD_VAR 0 7
106255: PUSH
106256: LD_INT 2
106258: ARRAY
106259: PPUSH
106260: CALL_OW 428
106264: PUSH
106265: LD_INT 0
106267: EQUAL
106268: IFFALSE 106321
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106270: LD_VAR 0 1
106274: PPUSH
106275: LD_VAR 0 7
106279: PUSH
106280: LD_INT 1
106282: ARRAY
106283: PPUSH
106284: LD_VAR 0 7
106288: PUSH
106289: LD_INT 2
106291: ARRAY
106292: PPUSH
106293: LD_VAR 0 3
106297: PPUSH
106298: CALL_OW 48
// result := IsPlaced ( unit ) ;
106302: LD_ADDR_VAR 0 4
106306: PUSH
106307: LD_VAR 0 1
106311: PPUSH
106312: CALL_OW 305
106316: ST_TO_ADDR
// exit ;
106317: POP
106318: POP
106319: GO 106325
// end ; end ;
106321: GO 106200
106323: POP
106324: POP
// end ;
106325: LD_VAR 0 4
106329: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106330: LD_INT 0
106332: PPUSH
106333: PPUSH
106334: PPUSH
// if not side or side > 8 then
106335: LD_VAR 0 1
106339: NOT
106340: PUSH
106341: LD_VAR 0 1
106345: PUSH
106346: LD_INT 8
106348: GREATER
106349: OR
106350: IFFALSE 106354
// exit ;
106352: GO 106541
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106354: LD_ADDR_VAR 0 4
106358: PUSH
106359: LD_INT 22
106361: PUSH
106362: LD_VAR 0 1
106366: PUSH
106367: EMPTY
106368: LIST
106369: LIST
106370: PUSH
106371: LD_INT 21
106373: PUSH
106374: LD_INT 3
106376: PUSH
106377: EMPTY
106378: LIST
106379: LIST
106380: PUSH
106381: EMPTY
106382: LIST
106383: LIST
106384: PPUSH
106385: CALL_OW 69
106389: ST_TO_ADDR
// if not tmp then
106390: LD_VAR 0 4
106394: NOT
106395: IFFALSE 106399
// exit ;
106397: GO 106541
// enable_addtolog := true ;
106399: LD_ADDR_OWVAR 81
106403: PUSH
106404: LD_INT 1
106406: ST_TO_ADDR
// AddToLog ( [ ) ;
106407: LD_STRING [
106409: PPUSH
106410: CALL_OW 561
// for i in tmp do
106414: LD_ADDR_VAR 0 3
106418: PUSH
106419: LD_VAR 0 4
106423: PUSH
106424: FOR_IN
106425: IFFALSE 106532
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106427: LD_STRING [
106429: PUSH
106430: LD_VAR 0 3
106434: PPUSH
106435: CALL_OW 266
106439: STR
106440: PUSH
106441: LD_STRING , 
106443: STR
106444: PUSH
106445: LD_VAR 0 3
106449: PPUSH
106450: CALL_OW 250
106454: STR
106455: PUSH
106456: LD_STRING , 
106458: STR
106459: PUSH
106460: LD_VAR 0 3
106464: PPUSH
106465: CALL_OW 251
106469: STR
106470: PUSH
106471: LD_STRING , 
106473: STR
106474: PUSH
106475: LD_VAR 0 3
106479: PPUSH
106480: CALL_OW 254
106484: STR
106485: PUSH
106486: LD_STRING , 
106488: STR
106489: PUSH
106490: LD_VAR 0 3
106494: PPUSH
106495: LD_INT 1
106497: PPUSH
106498: CALL_OW 268
106502: STR
106503: PUSH
106504: LD_STRING , 
106506: STR
106507: PUSH
106508: LD_VAR 0 3
106512: PPUSH
106513: LD_INT 2
106515: PPUSH
106516: CALL_OW 268
106520: STR
106521: PUSH
106522: LD_STRING ],
106524: STR
106525: PPUSH
106526: CALL_OW 561
// end ;
106530: GO 106424
106532: POP
106533: POP
// AddToLog ( ]; ) ;
106534: LD_STRING ];
106536: PPUSH
106537: CALL_OW 561
// end ;
106541: LD_VAR 0 2
106545: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106546: LD_INT 0
106548: PPUSH
106549: PPUSH
106550: PPUSH
106551: PPUSH
106552: PPUSH
// if not area or not rate or not max then
106553: LD_VAR 0 1
106557: NOT
106558: PUSH
106559: LD_VAR 0 2
106563: NOT
106564: OR
106565: PUSH
106566: LD_VAR 0 4
106570: NOT
106571: OR
106572: IFFALSE 106576
// exit ;
106574: GO 106768
// while 1 do
106576: LD_INT 1
106578: IFFALSE 106768
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106580: LD_ADDR_VAR 0 9
106584: PUSH
106585: LD_VAR 0 1
106589: PPUSH
106590: LD_INT 1
106592: PPUSH
106593: CALL_OW 287
106597: PUSH
106598: LD_INT 10
106600: MUL
106601: ST_TO_ADDR
// r := rate / 10 ;
106602: LD_ADDR_VAR 0 7
106606: PUSH
106607: LD_VAR 0 2
106611: PUSH
106612: LD_INT 10
106614: DIVREAL
106615: ST_TO_ADDR
// time := 1 1$00 ;
106616: LD_ADDR_VAR 0 8
106620: PUSH
106621: LD_INT 2100
106623: ST_TO_ADDR
// if amount < min then
106624: LD_VAR 0 9
106628: PUSH
106629: LD_VAR 0 3
106633: LESS
106634: IFFALSE 106652
// r := r * 2 else
106636: LD_ADDR_VAR 0 7
106640: PUSH
106641: LD_VAR 0 7
106645: PUSH
106646: LD_INT 2
106648: MUL
106649: ST_TO_ADDR
106650: GO 106678
// if amount > max then
106652: LD_VAR 0 9
106656: PUSH
106657: LD_VAR 0 4
106661: GREATER
106662: IFFALSE 106678
// r := r / 2 ;
106664: LD_ADDR_VAR 0 7
106668: PUSH
106669: LD_VAR 0 7
106673: PUSH
106674: LD_INT 2
106676: DIVREAL
106677: ST_TO_ADDR
// time := time / r ;
106678: LD_ADDR_VAR 0 8
106682: PUSH
106683: LD_VAR 0 8
106687: PUSH
106688: LD_VAR 0 7
106692: DIVREAL
106693: ST_TO_ADDR
// if time < 0 then
106694: LD_VAR 0 8
106698: PUSH
106699: LD_INT 0
106701: LESS
106702: IFFALSE 106719
// time := time * - 1 ;
106704: LD_ADDR_VAR 0 8
106708: PUSH
106709: LD_VAR 0 8
106713: PUSH
106714: LD_INT 1
106716: NEG
106717: MUL
106718: ST_TO_ADDR
// wait ( time ) ;
106719: LD_VAR 0 8
106723: PPUSH
106724: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106728: LD_INT 35
106730: PPUSH
106731: LD_INT 875
106733: PPUSH
106734: CALL_OW 12
106738: PPUSH
106739: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106743: LD_INT 1
106745: PPUSH
106746: LD_INT 5
106748: PPUSH
106749: CALL_OW 12
106753: PPUSH
106754: LD_VAR 0 1
106758: PPUSH
106759: LD_INT 1
106761: PPUSH
106762: CALL_OW 55
// end ;
106766: GO 106576
// end ;
106768: LD_VAR 0 5
106772: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106773: LD_INT 0
106775: PPUSH
106776: PPUSH
106777: PPUSH
106778: PPUSH
106779: PPUSH
106780: PPUSH
106781: PPUSH
106782: PPUSH
// if not turrets or not factories then
106783: LD_VAR 0 1
106787: NOT
106788: PUSH
106789: LD_VAR 0 2
106793: NOT
106794: OR
106795: IFFALSE 106799
// exit ;
106797: GO 107106
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106799: LD_ADDR_VAR 0 10
106803: PUSH
106804: LD_INT 5
106806: PUSH
106807: LD_INT 6
106809: PUSH
106810: EMPTY
106811: LIST
106812: LIST
106813: PUSH
106814: LD_INT 2
106816: PUSH
106817: LD_INT 4
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: PUSH
106824: LD_INT 3
106826: PUSH
106827: LD_INT 5
106829: PUSH
106830: EMPTY
106831: LIST
106832: LIST
106833: PUSH
106834: EMPTY
106835: LIST
106836: LIST
106837: LIST
106838: PUSH
106839: LD_INT 24
106841: PUSH
106842: LD_INT 25
106844: PUSH
106845: EMPTY
106846: LIST
106847: LIST
106848: PUSH
106849: LD_INT 23
106851: PUSH
106852: LD_INT 27
106854: PUSH
106855: EMPTY
106856: LIST
106857: LIST
106858: PUSH
106859: EMPTY
106860: LIST
106861: LIST
106862: PUSH
106863: LD_INT 42
106865: PUSH
106866: LD_INT 43
106868: PUSH
106869: EMPTY
106870: LIST
106871: LIST
106872: PUSH
106873: LD_INT 44
106875: PUSH
106876: LD_INT 46
106878: PUSH
106879: EMPTY
106880: LIST
106881: LIST
106882: PUSH
106883: LD_INT 45
106885: PUSH
106886: LD_INT 47
106888: PUSH
106889: EMPTY
106890: LIST
106891: LIST
106892: PUSH
106893: EMPTY
106894: LIST
106895: LIST
106896: LIST
106897: PUSH
106898: EMPTY
106899: LIST
106900: LIST
106901: LIST
106902: ST_TO_ADDR
// result := [ ] ;
106903: LD_ADDR_VAR 0 3
106907: PUSH
106908: EMPTY
106909: ST_TO_ADDR
// for i in turrets do
106910: LD_ADDR_VAR 0 4
106914: PUSH
106915: LD_VAR 0 1
106919: PUSH
106920: FOR_IN
106921: IFFALSE 107104
// begin nat := GetNation ( i ) ;
106923: LD_ADDR_VAR 0 7
106927: PUSH
106928: LD_VAR 0 4
106932: PPUSH
106933: CALL_OW 248
106937: ST_TO_ADDR
// weapon := 0 ;
106938: LD_ADDR_VAR 0 8
106942: PUSH
106943: LD_INT 0
106945: ST_TO_ADDR
// if not nat then
106946: LD_VAR 0 7
106950: NOT
106951: IFFALSE 106955
// continue ;
106953: GO 106920
// for j in list [ nat ] do
106955: LD_ADDR_VAR 0 5
106959: PUSH
106960: LD_VAR 0 10
106964: PUSH
106965: LD_VAR 0 7
106969: ARRAY
106970: PUSH
106971: FOR_IN
106972: IFFALSE 107013
// if GetBWeapon ( i ) = j [ 1 ] then
106974: LD_VAR 0 4
106978: PPUSH
106979: CALL_OW 269
106983: PUSH
106984: LD_VAR 0 5
106988: PUSH
106989: LD_INT 1
106991: ARRAY
106992: EQUAL
106993: IFFALSE 107011
// begin weapon := j [ 2 ] ;
106995: LD_ADDR_VAR 0 8
106999: PUSH
107000: LD_VAR 0 5
107004: PUSH
107005: LD_INT 2
107007: ARRAY
107008: ST_TO_ADDR
// break ;
107009: GO 107013
// end ;
107011: GO 106971
107013: POP
107014: POP
// if not weapon then
107015: LD_VAR 0 8
107019: NOT
107020: IFFALSE 107024
// continue ;
107022: GO 106920
// for k in factories do
107024: LD_ADDR_VAR 0 6
107028: PUSH
107029: LD_VAR 0 2
107033: PUSH
107034: FOR_IN
107035: IFFALSE 107100
// begin weapons := AvailableWeaponList ( k ) ;
107037: LD_ADDR_VAR 0 9
107041: PUSH
107042: LD_VAR 0 6
107046: PPUSH
107047: CALL_OW 478
107051: ST_TO_ADDR
// if not weapons then
107052: LD_VAR 0 9
107056: NOT
107057: IFFALSE 107061
// continue ;
107059: GO 107034
// if weapon in weapons then
107061: LD_VAR 0 8
107065: PUSH
107066: LD_VAR 0 9
107070: IN
107071: IFFALSE 107098
// begin result := [ i , weapon ] ;
107073: LD_ADDR_VAR 0 3
107077: PUSH
107078: LD_VAR 0 4
107082: PUSH
107083: LD_VAR 0 8
107087: PUSH
107088: EMPTY
107089: LIST
107090: LIST
107091: ST_TO_ADDR
// exit ;
107092: POP
107093: POP
107094: POP
107095: POP
107096: GO 107106
// end ; end ;
107098: GO 107034
107100: POP
107101: POP
// end ;
107102: GO 106920
107104: POP
107105: POP
// end ;
107106: LD_VAR 0 3
107110: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107111: LD_INT 0
107113: PPUSH
// if not side or side > 8 then
107114: LD_VAR 0 3
107118: NOT
107119: PUSH
107120: LD_VAR 0 3
107124: PUSH
107125: LD_INT 8
107127: GREATER
107128: OR
107129: IFFALSE 107133
// exit ;
107131: GO 107192
// if not range then
107133: LD_VAR 0 4
107137: NOT
107138: IFFALSE 107149
// range := - 12 ;
107140: LD_ADDR_VAR 0 4
107144: PUSH
107145: LD_INT 12
107147: NEG
107148: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107149: LD_VAR 0 1
107153: PPUSH
107154: LD_VAR 0 2
107158: PPUSH
107159: LD_VAR 0 3
107163: PPUSH
107164: LD_VAR 0 4
107168: PPUSH
107169: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107173: LD_VAR 0 1
107177: PPUSH
107178: LD_VAR 0 2
107182: PPUSH
107183: LD_VAR 0 3
107187: PPUSH
107188: CALL_OW 331
// end ;
107192: LD_VAR 0 5
107196: RET
// export function Video ( mode ) ; begin
107197: LD_INT 0
107199: PPUSH
// ingame_video = mode ;
107200: LD_ADDR_OWVAR 52
107204: PUSH
107205: LD_VAR 0 1
107209: ST_TO_ADDR
// interface_hidden = mode ;
107210: LD_ADDR_OWVAR 54
107214: PUSH
107215: LD_VAR 0 1
107219: ST_TO_ADDR
// end ;
107220: LD_VAR 0 2
107224: RET
// export function Join ( array , element ) ; begin
107225: LD_INT 0
107227: PPUSH
// result := array ^ element ;
107228: LD_ADDR_VAR 0 3
107232: PUSH
107233: LD_VAR 0 1
107237: PUSH
107238: LD_VAR 0 2
107242: ADD
107243: ST_TO_ADDR
// end ;
107244: LD_VAR 0 3
107248: RET
// export function JoinUnion ( array , element ) ; begin
107249: LD_INT 0
107251: PPUSH
// result := array union element ;
107252: LD_ADDR_VAR 0 3
107256: PUSH
107257: LD_VAR 0 1
107261: PUSH
107262: LD_VAR 0 2
107266: UNION
107267: ST_TO_ADDR
// end ;
107268: LD_VAR 0 3
107272: RET
// export function GetBehemoths ( side ) ; begin
107273: LD_INT 0
107275: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107276: LD_ADDR_VAR 0 2
107280: PUSH
107281: LD_INT 22
107283: PUSH
107284: LD_VAR 0 1
107288: PUSH
107289: EMPTY
107290: LIST
107291: LIST
107292: PUSH
107293: LD_INT 31
107295: PUSH
107296: LD_INT 25
107298: PUSH
107299: EMPTY
107300: LIST
107301: LIST
107302: PUSH
107303: EMPTY
107304: LIST
107305: LIST
107306: PPUSH
107307: CALL_OW 69
107311: ST_TO_ADDR
// end ;
107312: LD_VAR 0 2
107316: RET
// export function Shuffle ( array ) ; var i , index ; begin
107317: LD_INT 0
107319: PPUSH
107320: PPUSH
107321: PPUSH
// result := [ ] ;
107322: LD_ADDR_VAR 0 2
107326: PUSH
107327: EMPTY
107328: ST_TO_ADDR
// if not array then
107329: LD_VAR 0 1
107333: NOT
107334: IFFALSE 107338
// exit ;
107336: GO 107437
// Randomize ;
107338: CALL_OW 10
// for i = array downto 1 do
107342: LD_ADDR_VAR 0 3
107346: PUSH
107347: DOUBLE
107348: LD_VAR 0 1
107352: INC
107353: ST_TO_ADDR
107354: LD_INT 1
107356: PUSH
107357: FOR_DOWNTO
107358: IFFALSE 107435
// begin index := rand ( 1 , array ) ;
107360: LD_ADDR_VAR 0 4
107364: PUSH
107365: LD_INT 1
107367: PPUSH
107368: LD_VAR 0 1
107372: PPUSH
107373: CALL_OW 12
107377: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107378: LD_ADDR_VAR 0 2
107382: PUSH
107383: LD_VAR 0 2
107387: PPUSH
107388: LD_VAR 0 2
107392: PUSH
107393: LD_INT 1
107395: PLUS
107396: PPUSH
107397: LD_VAR 0 1
107401: PUSH
107402: LD_VAR 0 4
107406: ARRAY
107407: PPUSH
107408: CALL_OW 2
107412: ST_TO_ADDR
// array := Delete ( array , index ) ;
107413: LD_ADDR_VAR 0 1
107417: PUSH
107418: LD_VAR 0 1
107422: PPUSH
107423: LD_VAR 0 4
107427: PPUSH
107428: CALL_OW 3
107432: ST_TO_ADDR
// end ;
107433: GO 107357
107435: POP
107436: POP
// end ;
107437: LD_VAR 0 2
107441: RET
// export function GetBaseMaterials ( base ) ; begin
107442: LD_INT 0
107444: PPUSH
// result := [ 0 , 0 , 0 ] ;
107445: LD_ADDR_VAR 0 2
107449: PUSH
107450: LD_INT 0
107452: PUSH
107453: LD_INT 0
107455: PUSH
107456: LD_INT 0
107458: PUSH
107459: EMPTY
107460: LIST
107461: LIST
107462: LIST
107463: ST_TO_ADDR
// if not base then
107464: LD_VAR 0 1
107468: NOT
107469: IFFALSE 107473
// exit ;
107471: GO 107522
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107473: LD_ADDR_VAR 0 2
107477: PUSH
107478: LD_VAR 0 1
107482: PPUSH
107483: LD_INT 1
107485: PPUSH
107486: CALL_OW 275
107490: PUSH
107491: LD_VAR 0 1
107495: PPUSH
107496: LD_INT 2
107498: PPUSH
107499: CALL_OW 275
107503: PUSH
107504: LD_VAR 0 1
107508: PPUSH
107509: LD_INT 3
107511: PPUSH
107512: CALL_OW 275
107516: PUSH
107517: EMPTY
107518: LIST
107519: LIST
107520: LIST
107521: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107522: LD_VAR 0 2
107526: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107527: LD_INT 0
107529: PPUSH
107530: PPUSH
107531: PPUSH
107532: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107533: LD_VAR 0 1
107537: PPUSH
107538: CALL_OW 264
107542: PUSH
107543: LD_EXP 98
107547: EQUAL
107548: IFFALSE 107620
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107550: LD_INT 68
107552: PPUSH
107553: LD_VAR 0 1
107557: PPUSH
107558: CALL_OW 255
107562: PPUSH
107563: CALL_OW 321
107567: PUSH
107568: LD_INT 2
107570: EQUAL
107571: IFFALSE 107583
// eff := 70 else
107573: LD_ADDR_VAR 0 6
107577: PUSH
107578: LD_INT 70
107580: ST_TO_ADDR
107581: GO 107591
// eff := 30 ;
107583: LD_ADDR_VAR 0 6
107587: PUSH
107588: LD_INT 30
107590: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107591: LD_VAR 0 1
107595: PPUSH
107596: CALL_OW 250
107600: PPUSH
107601: LD_VAR 0 1
107605: PPUSH
107606: CALL_OW 251
107610: PPUSH
107611: LD_VAR 0 6
107615: PPUSH
107616: CALL_OW 495
// end ; end ;
107620: LD_VAR 0 4
107624: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107625: LD_INT 0
107627: PPUSH
107628: PPUSH
107629: PPUSH
107630: PPUSH
107631: PPUSH
107632: PPUSH
// if cmd = 124 then
107633: LD_VAR 0 1
107637: PUSH
107638: LD_INT 124
107640: EQUAL
107641: IFFALSE 107847
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107643: LD_ADDR_VAR 0 5
107647: PUSH
107648: LD_INT 2
107650: PUSH
107651: LD_INT 34
107653: PUSH
107654: LD_INT 53
107656: PUSH
107657: EMPTY
107658: LIST
107659: LIST
107660: PUSH
107661: LD_INT 34
107663: PUSH
107664: LD_INT 14
107666: PUSH
107667: EMPTY
107668: LIST
107669: LIST
107670: PUSH
107671: EMPTY
107672: LIST
107673: LIST
107674: LIST
107675: PPUSH
107676: CALL_OW 69
107680: ST_TO_ADDR
// if not tmp then
107681: LD_VAR 0 5
107685: NOT
107686: IFFALSE 107690
// exit ;
107688: GO 107847
// for i in tmp do
107690: LD_ADDR_VAR 0 3
107694: PUSH
107695: LD_VAR 0 5
107699: PUSH
107700: FOR_IN
107701: IFFALSE 107845
// begin taskList := GetTaskList ( i ) ;
107703: LD_ADDR_VAR 0 6
107707: PUSH
107708: LD_VAR 0 3
107712: PPUSH
107713: CALL_OW 437
107717: ST_TO_ADDR
// if not taskList then
107718: LD_VAR 0 6
107722: NOT
107723: IFFALSE 107727
// continue ;
107725: GO 107700
// for j = 1 to taskList do
107727: LD_ADDR_VAR 0 4
107731: PUSH
107732: DOUBLE
107733: LD_INT 1
107735: DEC
107736: ST_TO_ADDR
107737: LD_VAR 0 6
107741: PUSH
107742: FOR_TO
107743: IFFALSE 107841
// if taskList [ j ] [ 1 ] = | then
107745: LD_VAR 0 6
107749: PUSH
107750: LD_VAR 0 4
107754: ARRAY
107755: PUSH
107756: LD_INT 1
107758: ARRAY
107759: PUSH
107760: LD_STRING |
107762: EQUAL
107763: IFFALSE 107839
// begin _taskList := Delete ( taskList , 1 ) ;
107765: LD_ADDR_VAR 0 7
107769: PUSH
107770: LD_VAR 0 6
107774: PPUSH
107775: LD_INT 1
107777: PPUSH
107778: CALL_OW 3
107782: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107783: LD_VAR 0 3
107787: PPUSH
107788: LD_VAR 0 7
107792: PPUSH
107793: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107797: LD_VAR 0 3
107801: PPUSH
107802: LD_VAR 0 6
107806: PUSH
107807: LD_VAR 0 4
107811: ARRAY
107812: PUSH
107813: LD_INT 2
107815: ARRAY
107816: PPUSH
107817: LD_VAR 0 6
107821: PUSH
107822: LD_VAR 0 4
107826: ARRAY
107827: PUSH
107828: LD_INT 3
107830: ARRAY
107831: PPUSH
107832: LD_INT 8
107834: PPUSH
107835: CALL 107852 0 4
// end ;
107839: GO 107742
107841: POP
107842: POP
// end ;
107843: GO 107700
107845: POP
107846: POP
// end ; end ;
107847: LD_VAR 0 2
107851: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107852: LD_INT 0
107854: PPUSH
107855: PPUSH
107856: PPUSH
107857: PPUSH
107858: PPUSH
107859: PPUSH
107860: PPUSH
107861: PPUSH
107862: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107863: LD_VAR 0 1
107867: NOT
107868: PUSH
107869: LD_VAR 0 2
107873: PPUSH
107874: LD_VAR 0 3
107878: PPUSH
107879: CALL_OW 488
107883: NOT
107884: OR
107885: PUSH
107886: LD_VAR 0 4
107890: NOT
107891: OR
107892: IFFALSE 107896
// exit ;
107894: GO 108236
// list := [ ] ;
107896: LD_ADDR_VAR 0 13
107900: PUSH
107901: EMPTY
107902: ST_TO_ADDR
// if x - r < 0 then
107903: LD_VAR 0 2
107907: PUSH
107908: LD_VAR 0 4
107912: MINUS
107913: PUSH
107914: LD_INT 0
107916: LESS
107917: IFFALSE 107929
// min_x := 0 else
107919: LD_ADDR_VAR 0 7
107923: PUSH
107924: LD_INT 0
107926: ST_TO_ADDR
107927: GO 107945
// min_x := x - r ;
107929: LD_ADDR_VAR 0 7
107933: PUSH
107934: LD_VAR 0 2
107938: PUSH
107939: LD_VAR 0 4
107943: MINUS
107944: ST_TO_ADDR
// if y - r < 0 then
107945: LD_VAR 0 3
107949: PUSH
107950: LD_VAR 0 4
107954: MINUS
107955: PUSH
107956: LD_INT 0
107958: LESS
107959: IFFALSE 107971
// min_y := 0 else
107961: LD_ADDR_VAR 0 8
107965: PUSH
107966: LD_INT 0
107968: ST_TO_ADDR
107969: GO 107987
// min_y := y - r ;
107971: LD_ADDR_VAR 0 8
107975: PUSH
107976: LD_VAR 0 3
107980: PUSH
107981: LD_VAR 0 4
107985: MINUS
107986: ST_TO_ADDR
// max_x := x + r ;
107987: LD_ADDR_VAR 0 9
107991: PUSH
107992: LD_VAR 0 2
107996: PUSH
107997: LD_VAR 0 4
108001: PLUS
108002: ST_TO_ADDR
// max_y := y + r ;
108003: LD_ADDR_VAR 0 10
108007: PUSH
108008: LD_VAR 0 3
108012: PUSH
108013: LD_VAR 0 4
108017: PLUS
108018: ST_TO_ADDR
// for _x = min_x to max_x do
108019: LD_ADDR_VAR 0 11
108023: PUSH
108024: DOUBLE
108025: LD_VAR 0 7
108029: DEC
108030: ST_TO_ADDR
108031: LD_VAR 0 9
108035: PUSH
108036: FOR_TO
108037: IFFALSE 108154
// for _y = min_y to max_y do
108039: LD_ADDR_VAR 0 12
108043: PUSH
108044: DOUBLE
108045: LD_VAR 0 8
108049: DEC
108050: ST_TO_ADDR
108051: LD_VAR 0 10
108055: PUSH
108056: FOR_TO
108057: IFFALSE 108150
// begin if not ValidHex ( _x , _y ) then
108059: LD_VAR 0 11
108063: PPUSH
108064: LD_VAR 0 12
108068: PPUSH
108069: CALL_OW 488
108073: NOT
108074: IFFALSE 108078
// continue ;
108076: GO 108056
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108078: LD_VAR 0 11
108082: PPUSH
108083: LD_VAR 0 12
108087: PPUSH
108088: CALL_OW 351
108092: PUSH
108093: LD_VAR 0 11
108097: PPUSH
108098: LD_VAR 0 12
108102: PPUSH
108103: CALL_OW 554
108107: AND
108108: IFFALSE 108148
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108110: LD_ADDR_VAR 0 13
108114: PUSH
108115: LD_VAR 0 13
108119: PPUSH
108120: LD_VAR 0 13
108124: PUSH
108125: LD_INT 1
108127: PLUS
108128: PPUSH
108129: LD_VAR 0 11
108133: PUSH
108134: LD_VAR 0 12
108138: PUSH
108139: EMPTY
108140: LIST
108141: LIST
108142: PPUSH
108143: CALL_OW 2
108147: ST_TO_ADDR
// end ;
108148: GO 108056
108150: POP
108151: POP
108152: GO 108036
108154: POP
108155: POP
// if not list then
108156: LD_VAR 0 13
108160: NOT
108161: IFFALSE 108165
// exit ;
108163: GO 108236
// for i in list do
108165: LD_ADDR_VAR 0 6
108169: PUSH
108170: LD_VAR 0 13
108174: PUSH
108175: FOR_IN
108176: IFFALSE 108234
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108178: LD_VAR 0 1
108182: PPUSH
108183: LD_STRING M
108185: PUSH
108186: LD_VAR 0 6
108190: PUSH
108191: LD_INT 1
108193: ARRAY
108194: PUSH
108195: LD_VAR 0 6
108199: PUSH
108200: LD_INT 2
108202: ARRAY
108203: PUSH
108204: LD_INT 0
108206: PUSH
108207: LD_INT 0
108209: PUSH
108210: LD_INT 0
108212: PUSH
108213: LD_INT 0
108215: PUSH
108216: EMPTY
108217: LIST
108218: LIST
108219: LIST
108220: LIST
108221: LIST
108222: LIST
108223: LIST
108224: PUSH
108225: EMPTY
108226: LIST
108227: PPUSH
108228: CALL_OW 447
108232: GO 108175
108234: POP
108235: POP
// end ;
108236: LD_VAR 0 5
108240: RET
