// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39877 0 0
// InitNature ;
  19: CALL 39745 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12700 0 0
// PrepareRussian ;
  40: CALL 7630 0 0
// PrepareLegion ;
  44: CALL 4684 0 0
// PreparePowell ;
  48: CALL 3218 0 0
// PrepareAmerican ;
  52: CALL 1818 0 0
// Action ;
  56: CALL 17650 0 0
// MC_Start ( ) ;
  60: CALL 42057 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 65113 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 65210 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 64552 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 64367 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 65113 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 65210 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 64367 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 64552 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64984 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 64030 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 65113 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 65210 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 64367 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 65113 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 65210 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 64259 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 65540 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64691 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64984 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64984 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 65330 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 64367 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64933 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: IFFALSE 1558
1548: PUSH
1549: LD_EXP 17
1553: PUSH
1554: LD_INT 2
1556: GREATEREQUAL
1557: AND
1558: IFFALSE 1570
1560: GO 1562
1562: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1563: LD_STRING ACH_POWELL
1565: PPUSH
1566: CALL_OW 543
1570: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1571: LD_EXP 39
1575: PUSH
1576: LD_INT 30
1578: GREATEREQUAL
1579: IFFALSE 1591
1581: GO 1583
1583: DISABLE
// SetAchievement ( ACH_PROD ) ;
1584: LD_STRING ACH_PROD
1586: PPUSH
1587: CALL_OW 543
1591: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1592: LD_INT 22
1594: PUSH
1595: LD_INT 1
1597: PUSH
1598: EMPTY
1599: LIST
1600: LIST
1601: PUSH
1602: LD_INT 21
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 2
1614: PUSH
1615: LD_INT 28
1617: PUSH
1618: LD_INT 1
1620: PUSH
1621: LD_INT 10
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: PUSH
1629: LD_INT 28
1631: PUSH
1632: LD_INT 2
1634: PUSH
1635: LD_INT 10
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_INT 3
1648: PUSH
1649: LD_INT 10
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 28
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 10
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: LIST
1682: PPUSH
1683: CALL_OW 69
1687: PUSH
1688: LD_INT 10
1690: GREATEREQUAL
1691: IFFALSE 1703
1693: GO 1695
1695: DISABLE
// SetAchievement ( ACH_EXP ) ;
1696: LD_STRING ACH_EXP
1698: PPUSH
1699: CALL_OW 543
1703: END
// every 0 0$1 trigger debug do var i , tmp ;
1704: LD_EXP 1
1708: IFFALSE 1815
1710: GO 1712
1712: DISABLE
1713: LD_INT 0
1715: PPUSH
1716: PPUSH
// begin enable ;
1717: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1718: LD_ADDR_VAR 0 2
1722: PUSH
1723: LD_INT 22
1725: PUSH
1726: LD_INT 1
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: PUSH
1733: LD_INT 3
1735: PUSH
1736: LD_INT 21
1738: PUSH
1739: LD_INT 3
1741: PUSH
1742: EMPTY
1743: LIST
1744: LIST
1745: PUSH
1746: EMPTY
1747: LIST
1748: LIST
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 24
1755: PUSH
1756: LD_INT 999
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: PUSH
1763: EMPTY
1764: LIST
1765: LIST
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: ST_TO_ADDR
// if not tmp then
1777: LD_VAR 0 2
1781: NOT
1782: IFFALSE 1786
// exit ;
1784: GO 1815
// for i in tmp do
1786: LD_ADDR_VAR 0 1
1790: PUSH
1791: LD_VAR 0 2
1795: PUSH
1796: FOR_IN
1797: IFFALSE 1813
// SetLives ( i , 1000 ) ;
1799: LD_VAR 0 1
1803: PPUSH
1804: LD_INT 1000
1806: PPUSH
1807: CALL_OW 234
1811: GO 1796
1813: POP
1814: POP
// end ; end_of_file
1815: PPOPN 2
1817: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1818: LD_INT 0
1820: PPUSH
// uc_side := 1 ;
1821: LD_ADDR_OWVAR 20
1825: PUSH
1826: LD_INT 1
1828: ST_TO_ADDR
// uc_nation := 1 ;
1829: LD_ADDR_OWVAR 21
1833: PUSH
1834: LD_INT 1
1836: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING JMM
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 14_
1853: PPUSH
1854: CALL 70939 0 3
1858: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1859: LD_EXP 4
1863: NOT
1864: IFTRUE 1881
1866: PUSH
1867: LD_EXP 4
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: PUSH
1876: LD_INT 1
1878: ARRAY
1879: NOT
1880: OR
1881: IFFALSE 1946
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1883: LD_INT 5
1885: PUSH
1886: LD_INT 5
1888: PUSH
1889: LD_INT 3
1891: PUSH
1892: LD_INT 3
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_OWVAR 67
1905: ARRAY
1906: PPUSH
1907: LD_INT 3
1909: PPUSH
1910: LD_INT 1
1912: PPUSH
1913: LD_INT 9
1915: PUSH
1916: LD_INT 9
1918: PUSH
1919: LD_INT 5
1921: PUSH
1922: LD_INT 5
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: PUSH
1931: LD_OWVAR 67
1935: ARRAY
1936: PPUSH
1937: LD_INT 100
1939: PPUSH
1940: CALL 75901 0 5
1944: GO 2005
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1946: LD_EXP 4
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PUSH
1955: LD_INT 1
1957: ARRAY
1958: PPUSH
1959: LD_EXP 4
1963: PUSH
1964: LD_INT 2
1966: ARRAY
1967: PUSH
1968: LD_INT 1
1970: ARRAY
1971: PPUSH
1972: LD_EXP 4
1976: PUSH
1977: LD_INT 3
1979: ARRAY
1980: PUSH
1981: LD_INT 1
1983: ARRAY
1984: PPUSH
1985: LD_EXP 4
1989: PUSH
1990: LD_INT 4
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PPUSH
1998: LD_INT 30
2000: PPUSH
2001: CALL 75901 0 5
// JMMNewVeh := CreateVehicle ;
2005: LD_ADDR_EXP 59
2009: PUSH
2010: CALL_OW 45
2014: ST_TO_ADDR
// if not JMMNewVeh then
2015: LD_EXP 59
2019: NOT
2020: IFFALSE 2051
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2022: LD_INT 5
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_INT 9
2033: PPUSH
2034: LD_INT 100
2036: PPUSH
2037: CALL 75901 0 5
// JMMNewVeh := CreateVehicle ;
2041: LD_ADDR_EXP 59
2045: PUSH
2046: CALL_OW 45
2050: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2051: LD_EXP 59
2055: PPUSH
2056: LD_INT 4
2058: PPUSH
2059: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2063: LD_EXP 59
2067: PPUSH
2068: LD_INT 1
2070: NEG
2071: PPUSH
2072: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2076: LD_EXP 59
2080: PPUSH
2081: LD_INT 79
2083: PPUSH
2084: LD_INT 91
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2094: LD_EXP 40
2098: PPUSH
2099: LD_EXP 59
2103: PPUSH
2104: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2108: LD_EXP 6
2112: IFFALSE 2121
2114: PUSH
2115: LD_EXP 2
2119: NOT
2120: AND
2121: IFFALSE 2379
// begin if not JMMGirlVeh then
2123: LD_EXP 5
2127: NOT
2128: IFFALSE 2151
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2130: LD_INT 3
2132: PPUSH
2133: LD_INT 3
2135: PPUSH
2136: LD_INT 1
2138: PPUSH
2139: LD_INT 9
2141: PPUSH
2142: LD_INT 100
2144: PPUSH
2145: CALL 75901 0 5
2149: GO 2210
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2151: LD_EXP 5
2155: PUSH
2156: LD_INT 1
2158: ARRAY
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PPUSH
2164: LD_EXP 5
2168: PUSH
2169: LD_INT 2
2171: ARRAY
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: PPUSH
2177: LD_EXP 5
2181: PUSH
2182: LD_INT 3
2184: ARRAY
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: LD_EXP 5
2194: PUSH
2195: LD_INT 4
2197: ARRAY
2198: PUSH
2199: LD_INT 1
2201: ARRAY
2202: PPUSH
2203: LD_INT 30
2205: PPUSH
2206: CALL 75901 0 5
// GirlNewVeh := CreateVehicle ;
2210: LD_ADDR_EXP 60
2214: PUSH
2215: CALL_OW 45
2219: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2220: LD_EXP 60
2224: PPUSH
2225: LD_INT 4
2227: PPUSH
2228: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2232: LD_EXP 60
2236: PPUSH
2237: LD_INT 82
2239: PPUSH
2240: LD_INT 96
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 48
// if JMMGirl = 1 then
2250: LD_EXP 7
2254: PUSH
2255: LD_INT 1
2257: EQUAL
2258: IFFALSE 2293
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2260: LD_ADDR_EXP 41
2264: PUSH
2265: LD_STRING Joan
2267: PPUSH
2268: LD_INT 1
2270: PPUSH
2271: LD_STRING 14_
2273: PPUSH
2274: CALL 70939 0 3
2278: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2279: LD_EXP 41
2283: PPUSH
2284: LD_EXP 60
2288: PPUSH
2289: CALL_OW 52
// end ; if JMMGirl = 2 then
2293: LD_EXP 7
2297: PUSH
2298: LD_INT 2
2300: EQUAL
2301: IFFALSE 2336
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2303: LD_ADDR_EXP 43
2307: PUSH
2308: LD_STRING Lisa
2310: PPUSH
2311: LD_INT 1
2313: PPUSH
2314: LD_STRING 14_
2316: PPUSH
2317: CALL 70939 0 3
2321: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2322: LD_EXP 43
2326: PPUSH
2327: LD_EXP 60
2331: PPUSH
2332: CALL_OW 52
// end ; if JMMGirl = 3 then
2336: LD_EXP 7
2340: PUSH
2341: LD_INT 3
2343: EQUAL
2344: IFFALSE 2379
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2346: LD_ADDR_EXP 55
2350: PUSH
2351: LD_STRING Connie
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_STRING 14_
2359: PPUSH
2360: CALL 70939 0 3
2364: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2365: LD_EXP 55
2369: PPUSH
2370: LD_EXP 60
2374: PPUSH
2375: CALL_OW 52
// end ; end ; end ;
2379: LD_VAR 0 1
2383: RET
// export function PrepareStevensSquad ; var tmp ; begin
2384: LD_INT 0
2386: PPUSH
2387: PPUSH
// uc_side := 1 ;
2388: LD_ADDR_OWVAR 20
2392: PUSH
2393: LD_INT 1
2395: ST_TO_ADDR
// uc_nation := 1 ;
2396: LD_ADDR_OWVAR 21
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// tmp := [ ] ;
2404: LD_ADDR_VAR 0 2
2408: PUSH
2409: EMPTY
2410: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2411: LD_ADDR_EXP 42
2415: PUSH
2416: LD_STRING Stevens
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13f_
2427: PPUSH
2428: CALL 70939 0 3
2432: ST_TO_ADDR
// if not Stevens then
2433: LD_EXP 42
2437: NOT
2438: IFFALSE 2552
// begin hc_name = Baker Smith ;
2440: LD_ADDR_OWVAR 26
2444: PUSH
2445: LD_STRING Baker Smith
2447: ST_TO_ADDR
// hc_gallery = us ;
2448: LD_ADDR_OWVAR 33
2452: PUSH
2453: LD_STRING us
2455: ST_TO_ADDR
// hc_face_number := 29 ;
2456: LD_ADDR_OWVAR 34
2460: PUSH
2461: LD_INT 29
2463: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2464: LD_INT 1
2466: PPUSH
2467: LD_INT 10
2469: PPUSH
2470: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2474: LD_ADDR_OWVAR 30
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 2
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2497: LD_ADDR_OWVAR 31
2501: PUSH
2502: LD_INT 4
2504: PUSH
2505: LD_INT 5
2507: PUSH
2508: LD_INT 2
2510: PUSH
2511: LD_INT 10
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: ST_TO_ADDR
// Baker := CreateHuman ;
2520: LD_ADDR_EXP 56
2524: PUSH
2525: CALL_OW 44
2529: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2530: LD_ADDR_VAR 0 2
2534: PUSH
2535: LD_VAR 0 2
2539: PUSH
2540: LD_EXP 56
2544: ADD
2545: ST_TO_ADDR
// InitHc ;
2546: CALL_OW 19
// end else
2550: GO 2568
// tmp := tmp ^ Stevens ;
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 2
2561: PUSH
2562: LD_EXP 42
2566: ADD
2567: ST_TO_ADDR
// if not Lisa then
2568: LD_EXP 43
2572: NOT
2573: IFFALSE 2619
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2575: LD_ADDR_EXP 43
2579: PUSH
2580: LD_STRING Lisa
2582: PPUSH
2583: LD_EXP 1
2587: NOT
2588: PPUSH
2589: LD_STRING 13f_
2591: PPUSH
2592: CALL 70939 0 3
2596: ST_TO_ADDR
// if Lisa then
2597: LD_EXP 43
2601: IFFALSE 2619
// tmp := tmp ^ Lisa ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_VAR 0 2
2612: PUSH
2613: LD_EXP 43
2617: ADD
2618: ST_TO_ADDR
// end ; if not Donaldson then
2619: LD_EXP 44
2623: NOT
2624: IFFALSE 2670
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2626: LD_ADDR_EXP 44
2630: PUSH
2631: LD_STRING Donaldson
2633: PPUSH
2634: LD_EXP 1
2638: NOT
2639: PPUSH
2640: LD_STRING 13f_
2642: PPUSH
2643: CALL 70939 0 3
2647: ST_TO_ADDR
// if Donaldson then
2648: LD_EXP 44
2652: IFFALSE 2670
// tmp := tmp ^ Donaldson ;
2654: LD_ADDR_VAR 0 2
2658: PUSH
2659: LD_VAR 0 2
2663: PUSH
2664: LD_EXP 44
2668: ADD
2669: ST_TO_ADDR
// end ; if not Bobby then
2670: LD_EXP 45
2674: NOT
2675: IFFALSE 2721
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2677: LD_ADDR_EXP 45
2681: PUSH
2682: LD_STRING Bobby
2684: PPUSH
2685: LD_EXP 1
2689: NOT
2690: PPUSH
2691: LD_STRING 13f_
2693: PPUSH
2694: CALL 70939 0 3
2698: ST_TO_ADDR
// if Bobby then
2699: LD_EXP 45
2703: IFFALSE 2721
// tmp := tmp ^ Bobby ;
2705: LD_ADDR_VAR 0 2
2709: PUSH
2710: LD_VAR 0 2
2714: PUSH
2715: LD_EXP 45
2719: ADD
2720: ST_TO_ADDR
// end ; if not Cyrus then
2721: LD_EXP 46
2725: NOT
2726: IFFALSE 2772
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2728: LD_ADDR_EXP 46
2732: PUSH
2733: LD_STRING Cyrus
2735: PPUSH
2736: LD_EXP 1
2740: NOT
2741: PPUSH
2742: LD_STRING 13f_
2744: PPUSH
2745: CALL 70939 0 3
2749: ST_TO_ADDR
// if Cyrus then
2750: LD_EXP 46
2754: IFFALSE 2772
// tmp := tmp ^ Cyrus ;
2756: LD_ADDR_VAR 0 2
2760: PUSH
2761: LD_VAR 0 2
2765: PUSH
2766: LD_EXP 46
2770: ADD
2771: ST_TO_ADDR
// end ; if not Brown then
2772: LD_EXP 48
2776: NOT
2777: IFFALSE 2823
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2779: LD_ADDR_EXP 48
2783: PUSH
2784: LD_STRING Brown
2786: PPUSH
2787: LD_EXP 1
2791: NOT
2792: PPUSH
2793: LD_STRING 13f_
2795: PPUSH
2796: CALL 70939 0 3
2800: ST_TO_ADDR
// if Brown then
2801: LD_EXP 48
2805: IFFALSE 2823
// tmp := tmp ^ Brown ;
2807: LD_ADDR_VAR 0 2
2811: PUSH
2812: LD_VAR 0 2
2816: PUSH
2817: LD_EXP 48
2821: ADD
2822: ST_TO_ADDR
// end ; if not Gladstone then
2823: LD_EXP 49
2827: NOT
2828: IFFALSE 2874
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2830: LD_ADDR_EXP 49
2834: PUSH
2835: LD_STRING Gladstone
2837: PPUSH
2838: LD_EXP 1
2842: NOT
2843: PPUSH
2844: LD_STRING 13f_
2846: PPUSH
2847: CALL 70939 0 3
2851: ST_TO_ADDR
// if Gladstone then
2852: LD_EXP 49
2856: IFFALSE 2874
// tmp := tmp ^ Gladstone ;
2858: LD_ADDR_VAR 0 2
2862: PUSH
2863: LD_VAR 0 2
2867: PUSH
2868: LD_EXP 49
2872: ADD
2873: ST_TO_ADDR
// end ; if not Houten then
2874: LD_EXP 50
2878: NOT
2879: IFFALSE 2925
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2881: LD_ADDR_EXP 50
2885: PUSH
2886: LD_STRING Houten
2888: PPUSH
2889: LD_EXP 1
2893: NOT
2894: PPUSH
2895: LD_STRING 13f_
2897: PPUSH
2898: CALL 70939 0 3
2902: ST_TO_ADDR
// if Houten then
2903: LD_EXP 50
2907: IFFALSE 2925
// tmp := tmp ^ Houten ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_EXP 50
2923: ADD
2924: ST_TO_ADDR
// end ; if not Cornel then
2925: LD_EXP 51
2929: NOT
2930: IFFALSE 2976
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2932: LD_ADDR_EXP 51
2936: PUSH
2937: LD_STRING Cornell
2939: PPUSH
2940: LD_EXP 1
2944: NOT
2945: PPUSH
2946: LD_STRING 13f_
2948: PPUSH
2949: CALL 70939 0 3
2953: ST_TO_ADDR
// if Cornel then
2954: LD_EXP 51
2958: IFFALSE 2976
// tmp := tmp ^ Cornel ;
2960: LD_ADDR_VAR 0 2
2964: PUSH
2965: LD_VAR 0 2
2969: PUSH
2970: LD_EXP 51
2974: ADD
2975: ST_TO_ADDR
// end ; if not Gary then
2976: LD_EXP 52
2980: NOT
2981: IFFALSE 3027
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2983: LD_ADDR_EXP 52
2987: PUSH
2988: LD_STRING Gary
2990: PPUSH
2991: LD_EXP 1
2995: NOT
2996: PPUSH
2997: LD_STRING 13f_
2999: PPUSH
3000: CALL 70939 0 3
3004: ST_TO_ADDR
// if Gary then
3005: LD_EXP 52
3009: IFFALSE 3027
// tmp := tmp ^ Gary ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_EXP 52
3025: ADD
3026: ST_TO_ADDR
// end ; if not Frank then
3027: LD_EXP 53
3031: NOT
3032: IFFALSE 3078
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3034: LD_ADDR_EXP 53
3038: PUSH
3039: LD_STRING Frank
3041: PPUSH
3042: LD_EXP 1
3046: NOT
3047: PPUSH
3048: LD_STRING 13f_
3050: PPUSH
3051: CALL 70939 0 3
3055: ST_TO_ADDR
// if Frank then
3056: LD_EXP 53
3060: IFFALSE 3078
// tmp := tmp ^ Frank ;
3062: LD_ADDR_VAR 0 2
3066: PUSH
3067: LD_VAR 0 2
3071: PUSH
3072: LD_EXP 53
3076: ADD
3077: ST_TO_ADDR
// end ; if not Kikuchi then
3078: LD_EXP 54
3082: NOT
3083: IFFALSE 3129
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3085: LD_ADDR_EXP 54
3089: PUSH
3090: LD_STRING Kikuchi
3092: PPUSH
3093: LD_EXP 1
3097: NOT
3098: PPUSH
3099: LD_STRING 13f_
3101: PPUSH
3102: CALL 70939 0 3
3106: ST_TO_ADDR
// if Kikuchi then
3107: LD_EXP 54
3111: IFFALSE 3129
// tmp := tmp ^ Kikuchi ;
3113: LD_ADDR_VAR 0 2
3117: PUSH
3118: LD_VAR 0 2
3122: PUSH
3123: LD_EXP 54
3127: ADD
3128: ST_TO_ADDR
// end ; if not DeltaDoctor then
3129: LD_EXP 58
3133: NOT
3134: IFFALSE 3180
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 58
3140: PUSH
3141: LD_STRING DeltaDoctor
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 70939 0 3
3157: ST_TO_ADDR
// if Bobby then
3158: LD_EXP 45
3162: IFFALSE 3180
// tmp := tmp ^ DeltaDoctor ;
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_VAR 0 2
3173: PUSH
3174: LD_EXP 58
3178: ADD
3179: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3180: LD_ADDR_VAR 0 2
3184: PUSH
3185: LD_VAR 0 2
3189: PUSH
3190: LD_STRING 13_other_survivors
3192: PPUSH
3193: CALL_OW 31
3197: UNION
3198: ST_TO_ADDR
// result := tmp diff 0 ;
3199: LD_ADDR_VAR 0 1
3203: PUSH
3204: LD_VAR 0 2
3208: PUSH
3209: LD_INT 0
3211: DIFF
3212: ST_TO_ADDR
// end ; end_of_file
3213: LD_VAR 0 1
3217: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3218: LD_INT 0
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
3226: PPUSH
3227: PPUSH
3228: PPUSH
3229: PPUSH
// uc_side := 4 ;
3230: LD_ADDR_OWVAR 20
3234: PUSH
3235: LD_INT 4
3237: ST_TO_ADDR
// uc_nation := 1 ;
3238: LD_ADDR_OWVAR 21
3242: PUSH
3243: LD_INT 1
3245: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3246: LD_INT 387
3248: PPUSH
3249: CALL_OW 274
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 3500
3259: PUSH
3260: LD_INT 3000
3262: PUSH
3263: LD_INT 2500
3265: PUSH
3266: LD_INT 2000
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_OWVAR 67
3279: ARRAY
3280: PPUSH
3281: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3285: LD_INT 387
3287: PPUSH
3288: CALL_OW 274
3292: PPUSH
3293: LD_INT 2
3295: PPUSH
3296: LD_INT 400
3298: PPUSH
3299: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3303: LD_INT 387
3305: PPUSH
3306: CALL_OW 274
3310: PPUSH
3311: LD_INT 3
3313: PPUSH
3314: LD_INT 10
3316: PPUSH
3317: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3321: LD_INT 387
3323: PPUSH
3324: LD_STRING sigma
3326: PPUSH
3327: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3331: LD_ADDR_EXP 61
3335: PUSH
3336: LD_STRING Powell
3338: PPUSH
3339: CALL_OW 25
3343: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3344: LD_EXP 61
3348: PPUSH
3349: LD_INT 57
3351: PPUSH
3352: LD_INT 94
3354: PPUSH
3355: LD_INT 0
3357: PPUSH
3358: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3362: LD_EXP 61
3366: PPUSH
3367: LD_INT 58
3369: PPUSH
3370: LD_INT 94
3372: PPUSH
3373: CALL_OW 118
// vip := [ ] ;
3377: LD_ADDR_EXP 62
3381: PUSH
3382: EMPTY
3383: ST_TO_ADDR
// extraSquad := [ ] ;
3384: LD_ADDR_EXP 63
3388: PUSH
3389: EMPTY
3390: ST_TO_ADDR
// tmp := [ ] ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: EMPTY
3397: ST_TO_ADDR
// if JMMGirl <> 2 then
3398: LD_EXP 7
3402: PUSH
3403: LD_INT 2
3405: NONEQUAL
3406: IFFALSE 3430
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3408: LD_ADDR_EXP 43
3412: PUSH
3413: LD_STRING Lisa
3415: PPUSH
3416: LD_EXP 1
3420: NOT
3421: PPUSH
3422: LD_STRING 13s_
3424: PPUSH
3425: CALL 70939 0 3
3429: ST_TO_ADDR
// if Lisa then
3430: LD_EXP 43
3434: IFFALSE 3452
// tmp := tmp ^ Lisa ;
3436: LD_ADDR_VAR 0 5
3440: PUSH
3441: LD_VAR 0 5
3445: PUSH
3446: LD_EXP 43
3450: ADD
3451: ST_TO_ADDR
// if JMMGirl < 3 then
3452: LD_EXP 7
3456: PUSH
3457: LD_INT 3
3459: LESS
3460: IFFALSE 3491
// begin Connie := NewCharacter ( Coonie ) ;
3462: LD_ADDR_EXP 55
3466: PUSH
3467: LD_STRING Coonie
3469: PPUSH
3470: CALL_OW 25
3474: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3475: LD_ADDR_VAR 0 5
3479: PUSH
3480: LD_VAR 0 5
3484: PUSH
3485: LD_EXP 55
3489: ADD
3490: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3491: LD_ADDR_EXP 44
3495: PUSH
3496: LD_STRING Donaldson
3498: PPUSH
3499: LD_EXP 1
3503: NOT
3504: PPUSH
3505: LD_STRING 13s_
3507: PPUSH
3508: CALL 70939 0 3
3512: ST_TO_ADDR
// if Donaldson then
3513: LD_EXP 44
3517: IFFALSE 3535
// tmp := tmp ^ Donaldson ;
3519: LD_ADDR_VAR 0 5
3523: PUSH
3524: LD_VAR 0 5
3528: PUSH
3529: LD_EXP 44
3533: ADD
3534: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3535: LD_ADDR_EXP 45
3539: PUSH
3540: LD_STRING Bobby
3542: PPUSH
3543: LD_EXP 1
3547: NOT
3548: PPUSH
3549: LD_STRING 13s_
3551: PPUSH
3552: CALL 70939 0 3
3556: ST_TO_ADDR
// if Bobby then
3557: LD_EXP 45
3561: IFFALSE 3579
// tmp := tmp ^ Bobby ;
3563: LD_ADDR_VAR 0 5
3567: PUSH
3568: LD_VAR 0 5
3572: PUSH
3573: LD_EXP 45
3577: ADD
3578: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3579: LD_ADDR_EXP 46
3583: PUSH
3584: LD_STRING Cyrus
3586: PPUSH
3587: LD_EXP 1
3591: NOT
3592: PPUSH
3593: LD_STRING 13s_
3595: PPUSH
3596: CALL 70939 0 3
3600: ST_TO_ADDR
// if Cyrus then
3601: LD_EXP 46
3605: IFFALSE 3623
// tmp := tmp ^ Cyrus ;
3607: LD_ADDR_VAR 0 5
3611: PUSH
3612: LD_VAR 0 5
3616: PUSH
3617: LD_EXP 46
3621: ADD
3622: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3623: LD_ADDR_EXP 47
3627: PUSH
3628: LD_STRING Denis
3630: PPUSH
3631: LD_EXP 1
3635: NOT
3636: PPUSH
3637: LD_STRING 13s_
3639: PPUSH
3640: CALL 70939 0 3
3644: ST_TO_ADDR
// if not Denis then
3645: LD_EXP 47
3649: NOT
3650: IFFALSE 3674
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3652: LD_ADDR_EXP 47
3656: PUSH
3657: LD_STRING Denis
3659: PPUSH
3660: LD_EXP 1
3664: NOT
3665: PPUSH
3666: LD_STRING 13f_
3668: PPUSH
3669: CALL 70939 0 3
3673: ST_TO_ADDR
// if Denis then
3674: LD_EXP 47
3678: IFFALSE 3696
// tmp := tmp ^ Denis ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: LD_EXP 47
3694: ADD
3695: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3696: LD_ADDR_EXP 48
3700: PUSH
3701: LD_STRING Brown
3703: PPUSH
3704: LD_EXP 1
3708: NOT
3709: PPUSH
3710: LD_STRING 13s_
3712: PPUSH
3713: CALL 70939 0 3
3717: ST_TO_ADDR
// if Brown then
3718: LD_EXP 48
3722: IFFALSE 3740
// tmp := tmp ^ Brown ;
3724: LD_ADDR_VAR 0 5
3728: PUSH
3729: LD_VAR 0 5
3733: PUSH
3734: LD_EXP 48
3738: ADD
3739: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3740: LD_ADDR_EXP 49
3744: PUSH
3745: LD_STRING Gladstone
3747: PPUSH
3748: LD_EXP 1
3752: NOT
3753: PPUSH
3754: LD_STRING 13s_
3756: PPUSH
3757: CALL 70939 0 3
3761: ST_TO_ADDR
// if Gladstone then
3762: LD_EXP 49
3766: IFFALSE 3784
// tmp := tmp ^ Gladstone ;
3768: LD_ADDR_VAR 0 5
3772: PUSH
3773: LD_VAR 0 5
3777: PUSH
3778: LD_EXP 49
3782: ADD
3783: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3784: LD_ADDR_EXP 50
3788: PUSH
3789: LD_STRING Houten
3791: PPUSH
3792: LD_EXP 1
3796: NOT
3797: PPUSH
3798: LD_STRING 13s_
3800: PPUSH
3801: CALL 70939 0 3
3805: ST_TO_ADDR
// if Houten then
3806: LD_EXP 50
3810: IFFALSE 3828
// tmp := tmp ^ Houten ;
3812: LD_ADDR_VAR 0 5
3816: PUSH
3817: LD_VAR 0 5
3821: PUSH
3822: LD_EXP 50
3826: ADD
3827: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3828: LD_ADDR_EXP 51
3832: PUSH
3833: LD_STRING Cornel
3835: PPUSH
3836: LD_EXP 1
3840: NOT
3841: PPUSH
3842: LD_STRING 13s_
3844: PPUSH
3845: CALL 70939 0 3
3849: ST_TO_ADDR
// if Cornel then
3850: LD_EXP 51
3854: IFFALSE 3872
// tmp := tmp ^ Cornel ;
3856: LD_ADDR_VAR 0 5
3860: PUSH
3861: LD_VAR 0 5
3865: PUSH
3866: LD_EXP 51
3870: ADD
3871: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3872: LD_ADDR_EXP 52
3876: PUSH
3877: LD_STRING Gary
3879: PPUSH
3880: LD_EXP 1
3884: NOT
3885: PPUSH
3886: LD_STRING 13s_
3888: PPUSH
3889: CALL 70939 0 3
3893: ST_TO_ADDR
// if Gary then
3894: LD_EXP 52
3898: IFFALSE 3916
// tmp := tmp ^ Gary ;
3900: LD_ADDR_VAR 0 5
3904: PUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_EXP 52
3914: ADD
3915: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3916: LD_ADDR_EXP 53
3920: PUSH
3921: LD_STRING Frank
3923: PPUSH
3924: LD_EXP 1
3928: NOT
3929: PPUSH
3930: LD_STRING 13s_
3932: PPUSH
3933: CALL 70939 0 3
3937: ST_TO_ADDR
// if Frank then
3938: LD_EXP 53
3942: IFFALSE 3960
// tmp := tmp ^ Frank ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: LD_VAR 0 5
3953: PUSH
3954: LD_EXP 53
3958: ADD
3959: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3960: LD_ADDR_EXP 54
3964: PUSH
3965: LD_STRING Kikuchi
3967: PPUSH
3968: LD_EXP 1
3972: NOT
3973: PPUSH
3974: LD_STRING 13s_
3976: PPUSH
3977: CALL 70939 0 3
3981: ST_TO_ADDR
// if Kikuchi then
3982: LD_EXP 54
3986: IFFALSE 4004
// tmp := tmp ^ Kikuchi ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: LD_VAR 0 5
3997: PUSH
3998: LD_EXP 54
4002: ADD
4003: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
4004: LD_ADDR_EXP 58
4008: PUSH
4009: LD_STRING DeltaDoctor
4011: PPUSH
4012: LD_EXP 1
4016: NOT
4017: PPUSH
4018: LD_STRING 13s_
4020: PPUSH
4021: CALL 70939 0 3
4025: ST_TO_ADDR
// if DeltaDoctor then
4026: LD_EXP 58
4030: IFFALSE 4048
// tmp := tmp ^ DeltaDoctor ;
4032: LD_ADDR_VAR 0 5
4036: PUSH
4037: LD_VAR 0 5
4041: PUSH
4042: LD_EXP 58
4046: ADD
4047: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4048: LD_ADDR_EXP 57
4052: PUSH
4053: LD_STRING Mike
4055: PPUSH
4056: LD_EXP 1
4060: NOT
4061: PPUSH
4062: LD_STRING 10c_
4064: PPUSH
4065: CALL 70939 0 3
4069: ST_TO_ADDR
// if Mike then
4070: LD_EXP 57
4074: IFFALSE 4097
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4076: LD_EXP 57
4080: PPUSH
4081: LD_INT 61
4083: PPUSH
4084: LD_INT 89
4086: PPUSH
4087: LD_INT 8
4089: PPUSH
4090: LD_INT 0
4092: PPUSH
4093: CALL_OW 50
// vip := tmp ;
4097: LD_ADDR_EXP 62
4101: PUSH
4102: LD_VAR 0 5
4106: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4107: LD_ADDR_VAR 0 5
4111: PUSH
4112: LD_VAR 0 5
4116: PUSH
4117: LD_STRING 13s_others
4119: PPUSH
4120: CALL_OW 31
4124: UNION
4125: ST_TO_ADDR
// if tmp < 18 then
4126: LD_VAR 0 5
4130: PUSH
4131: LD_INT 18
4133: LESS
4134: IFFALSE 4239
// begin InitHC_All ( ) ;
4136: CALL_OW 584
// for i = 1 to 18 - tmp do
4140: LD_ADDR_VAR 0 2
4144: PUSH
4145: DOUBLE
4146: LD_INT 1
4148: DEC
4149: ST_TO_ADDR
4150: LD_INT 18
4152: PUSH
4153: LD_VAR 0 5
4157: MINUS
4158: PUSH
4159: FOR_TO
4160: IFFALSE 4237
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4162: LD_INT 1
4164: PPUSH
4165: LD_VAR 0 2
4169: PUSH
4170: LD_INT 4
4172: MOD
4173: PUSH
4174: LD_INT 1
4176: PLUS
4177: PPUSH
4178: LD_INT 4
4180: PPUSH
4181: CALL_OW 380
// un := CreateHuman ;
4185: LD_ADDR_VAR 0 10
4189: PUSH
4190: CALL_OW 44
4194: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4195: LD_ADDR_VAR 0 5
4199: PUSH
4200: LD_VAR 0 5
4204: PPUSH
4205: LD_VAR 0 10
4209: PPUSH
4210: CALL 109071 0 2
4214: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4215: LD_ADDR_EXP 63
4219: PUSH
4220: LD_EXP 63
4224: PPUSH
4225: LD_VAR 0 10
4229: PPUSH
4230: CALL 109071 0 2
4234: ST_TO_ADDR
// end ;
4235: GO 4159
4237: POP
4238: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4239: LD_ADDR_VAR 0 6
4243: PUSH
4244: LD_INT 53
4246: PPUSH
4247: LD_INT 94
4249: PPUSH
4250: CALL_OW 428
4254: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4255: LD_ADDR_VAR 0 7
4259: PUSH
4260: LD_INT 56
4262: PPUSH
4263: LD_INT 101
4265: PPUSH
4266: CALL_OW 428
4270: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4271: LD_ADDR_VAR 0 8
4275: PUSH
4276: LD_INT 67
4278: PPUSH
4279: LD_INT 101
4281: PPUSH
4282: CALL_OW 428
4286: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4287: LD_ADDR_VAR 0 9
4291: PUSH
4292: LD_INT 54
4294: PPUSH
4295: LD_INT 85
4297: PPUSH
4298: CALL_OW 428
4302: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4303: LD_ADDR_VAR 0 3
4307: PUSH
4308: LD_VAR 0 8
4312: PUSH
4313: LD_VAR 0 6
4317: PUSH
4318: LD_VAR 0 9
4322: PUSH
4323: LD_VAR 0 7
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: LIST
4332: LIST
4333: ST_TO_ADDR
// for i in tmp do
4334: LD_ADDR_VAR 0 2
4338: PUSH
4339: LD_VAR 0 5
4343: PUSH
4344: FOR_IN
4345: IFFALSE 4540
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4347: LD_VAR 0 3
4351: PUSH
4352: LD_INT 1
4354: ARRAY
4355: PPUSH
4356: CALL_OW 266
4360: PUSH
4361: LD_INT 4
4363: DOUBLE
4364: EQUAL
4365: IFTRUE 4369
4367: GO 4384
4369: POP
// SetClass ( i , class_soldier ) ; b_depot :
4370: LD_VAR 0 2
4374: PPUSH
4375: LD_INT 1
4377: PPUSH
4378: CALL_OW 336
4382: GO 4454
4384: LD_INT 0
4386: DOUBLE
4387: EQUAL
4388: IFTRUE 4392
4390: GO 4407
4392: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4393: LD_VAR 0 2
4397: PPUSH
4398: LD_INT 2
4400: PPUSH
4401: CALL_OW 336
4405: GO 4454
4407: LD_INT 2
4409: DOUBLE
4410: EQUAL
4411: IFTRUE 4415
4413: GO 4430
4415: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4416: LD_VAR 0 2
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: CALL_OW 336
4428: GO 4454
4430: LD_INT 6
4432: DOUBLE
4433: EQUAL
4434: IFTRUE 4438
4436: GO 4453
4438: POP
// SetClass ( i , class_scientistic ) ; end ;
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_INT 4
4446: PPUSH
4447: CALL_OW 336
4451: GO 4454
4453: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4454: LD_VAR 0 3
4458: PUSH
4459: LD_INT 1
4461: ARRAY
4462: PPUSH
4463: CALL_OW 313
4467: PUSH
4468: LD_INT 6
4470: EQUAL
4471: IFFALSE 4491
// b := Delete ( b , 1 ) ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: LD_VAR 0 3
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: CALL_OW 3
4490: ST_TO_ADDR
// if b then
4491: LD_VAR 0 3
4495: IFFALSE 4517
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4497: LD_VAR 0 2
4501: PPUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_INT 1
4509: ARRAY
4510: PPUSH
4511: CALL_OW 52
4515: GO 4538
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4517: LD_VAR 0 2
4521: PPUSH
4522: LD_INT 61
4524: PPUSH
4525: LD_INT 89
4527: PPUSH
4528: LD_INT 8
4530: PPUSH
4531: LD_INT 0
4533: PPUSH
4534: CALL_OW 50
// end ;
4538: GO 4344
4540: POP
4541: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4542: LD_INT 2
4544: PPUSH
4545: LD_INT 1
4547: PPUSH
4548: LD_INT 1
4550: PPUSH
4551: LD_INT 12
4553: PPUSH
4554: LD_INT 100
4556: PPUSH
4557: CALL 75901 0 5
// veh := CreateVehicle ;
4561: LD_ADDR_VAR 0 4
4565: PUSH
4566: CALL_OW 45
4570: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4571: LD_VAR 0 4
4575: PPUSH
4576: LD_INT 4
4578: PPUSH
4579: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4583: LD_VAR 0 4
4587: PPUSH
4588: LD_INT 49
4590: PPUSH
4591: LD_INT 88
4593: PPUSH
4594: LD_INT 0
4596: PPUSH
4597: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4601: LD_VAR 0 4
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: LD_INT 100
4611: PPUSH
4612: CALL_OW 290
// uc_side := 0 ;
4616: LD_ADDR_OWVAR 20
4620: PUSH
4621: LD_INT 0
4623: ST_TO_ADDR
// uc_nation := 0 ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 0
4631: ST_TO_ADDR
// for i := 1 to 3 do
4632: LD_ADDR_VAR 0 2
4636: PUSH
4637: DOUBLE
4638: LD_INT 1
4640: DEC
4641: ST_TO_ADDR
4642: LD_INT 3
4644: PUSH
4645: FOR_TO
4646: IFFALSE 4677
// begin InitHc ;
4648: CALL_OW 19
// hc_class := class_apeman ;
4652: LD_ADDR_OWVAR 28
4656: PUSH
4657: LD_INT 12
4659: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4660: CALL_OW 44
4664: PPUSH
4665: LD_INT 13
4667: PPUSH
4668: LD_INT 0
4670: PPUSH
4671: CALL_OW 49
// end ;
4675: GO 4645
4677: POP
4678: POP
// end ; end_of_file
4679: LD_VAR 0 1
4683: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
4689: PPUSH
4690: PPUSH
// side := 8 ;
4691: LD_ADDR_VAR 0 3
4695: PUSH
4696: LD_INT 8
4698: ST_TO_ADDR
// uc_side := side ;
4699: LD_ADDR_OWVAR 20
4703: PUSH
4704: LD_VAR 0 3
4708: ST_TO_ADDR
// uc_nation := 2 ;
4709: LD_ADDR_OWVAR 21
4713: PUSH
4714: LD_INT 2
4716: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4717: LD_ADDR_VAR 0 2
4721: PUSH
4722: LD_INT 22
4724: PUSH
4725: LD_VAR 0 3
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 21
4736: PUSH
4737: LD_INT 3
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: FOR_IN
4754: IFFALSE 4770
// SetBLevel ( i , 10 ) ;
4756: LD_VAR 0 2
4760: PPUSH
4761: LD_INT 10
4763: PPUSH
4764: CALL_OW 241
4768: GO 4753
4770: POP
4771: POP
// if KurtStatus then
4772: LD_EXP 3
4776: IFFALSE 4799
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4778: LD_ADDR_EXP 64
4782: PUSH
4783: LD_STRING Kurt
4785: PPUSH
4786: LD_INT 0
4788: PPUSH
4789: LD_STRING 
4791: PPUSH
4792: CALL 70939 0 3
4796: ST_TO_ADDR
4797: GO 4821
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4799: LD_ADDR_EXP 64
4803: PUSH
4804: LD_STRING AltKurt
4806: PPUSH
4807: LD_EXP 1
4811: NOT
4812: PPUSH
4813: LD_STRING 
4815: PPUSH
4816: CALL 70939 0 3
4820: ST_TO_ADDR
// if not Kurt then
4821: LD_EXP 64
4825: NOT
4826: IFFALSE 4852
// begin InitHc ;
4828: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4832: LD_INT 1
4834: PPUSH
4835: LD_INT 10
4837: PPUSH
4838: CALL_OW 381
// Kurt := CreateHuman ;
4842: LD_ADDR_EXP 64
4846: PUSH
4847: CALL_OW 44
4851: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4852: LD_EXP 64
4856: PPUSH
4857: LD_INT 324
4859: PPUSH
4860: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4864: LD_ADDR_EXP 65
4868: PUSH
4869: LD_STRING Kozlov
4871: PPUSH
4872: LD_INT 0
4874: PPUSH
4875: LD_STRING 
4877: PPUSH
4878: CALL 70939 0 3
4882: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4883: LD_EXP 65
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_INT 8
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 23
4900: PUSH
4901: LD_INT 3
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 30
4910: PUSH
4911: LD_INT 8
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: LIST
4922: PPUSH
4923: CALL_OW 69
4927: PUSH
4928: LD_INT 1
4930: ARRAY
4931: PPUSH
4932: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4936: LD_EXP 65
4940: PPUSH
4941: LD_INT 3
4943: PPUSH
4944: LD_INT 10
4946: PPUSH
4947: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4951: LD_EXP 65
4955: PPUSH
4956: LD_INT 4
4958: PPUSH
4959: LD_INT 10
4961: PPUSH
4962: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4966: LD_ADDR_VAR 0 5
4970: PUSH
4971: LD_INT 22
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 32
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 58
4995: PUSH
4996: EMPTY
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL_OW 69
5008: ST_TO_ADDR
// for i = 1 to 10 do
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: DOUBLE
5015: LD_INT 1
5017: DEC
5018: ST_TO_ADDR
5019: LD_INT 10
5021: PUSH
5022: FOR_TO
5023: IFFALSE 5095
// begin uc_nation := nation_nature ;
5025: LD_ADDR_OWVAR 21
5029: PUSH
5030: LD_INT 0
5032: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5033: LD_ADDR_OWVAR 28
5037: PUSH
5038: LD_INT 15
5040: ST_TO_ADDR
// hc_gallery :=  ;
5041: LD_ADDR_OWVAR 33
5045: PUSH
5046: LD_STRING 
5048: ST_TO_ADDR
// hc_name :=  ;
5049: LD_ADDR_OWVAR 26
5053: PUSH
5054: LD_STRING 
5056: ST_TO_ADDR
// un := CreateHuman ;
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: CALL_OW 44
5066: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5067: LD_VAR 0 4
5071: PPUSH
5072: LD_VAR 0 5
5076: PUSH
5077: LD_VAR 0 5
5081: PUSH
5082: LD_VAR 0 2
5086: MINUS
5087: ARRAY
5088: PPUSH
5089: CALL_OW 52
// end ;
5093: GO 5022
5095: POP
5096: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5097: LD_ADDR_VAR 0 5
5101: PUSH
5102: LD_STRING 12_kurt_squad
5104: PPUSH
5105: CALL_OW 31
5109: ST_TO_ADDR
// if tmp then
5110: LD_VAR 0 5
5114: IFFALSE 5148
// for i in tmp do
5116: LD_ADDR_VAR 0 2
5120: PUSH
5121: LD_VAR 0 5
5125: PUSH
5126: FOR_IN
5127: IFFALSE 5146
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5129: LD_VAR 0 2
5133: PPUSH
5134: LD_INT 5
5136: PPUSH
5137: LD_INT 0
5139: PPUSH
5140: CALL_OW 49
5144: GO 5126
5146: POP
5147: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5148: LD_INT 324
5150: PPUSH
5151: LD_INT 5
5153: PPUSH
5154: LD_STRING 
5156: PPUSH
5157: LD_INT 8
5159: PUSH
5160: LD_INT 9
5162: PUSH
5163: LD_INT 10
5165: PUSH
5166: LD_INT 10
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_OWVAR 67
5179: ARRAY
5180: PPUSH
5181: LD_INT 3000
5183: PUSH
5184: LD_INT 500
5186: PUSH
5187: LD_INT 150
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: LIST
5194: PPUSH
5195: LD_INT 16
5197: PUSH
5198: LD_INT 6
5200: PUSH
5201: LD_INT 6
5203: PUSH
5204: LD_INT 8
5206: PUSH
5207: EMPTY
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL 79738 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5217: LD_ADDR_EXP 102
5221: PUSH
5222: LD_EXP 102
5226: PPUSH
5227: LD_INT 3
5229: PPUSH
5230: LD_INT 22
5232: PUSH
5233: LD_VAR 0 3
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 23
5244: PUSH
5245: LD_INT 2
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: PUSH
5252: LD_INT 3
5254: PUSH
5255: LD_INT 21
5257: PUSH
5258: LD_INT 2
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: PPUSH
5274: CALL_OW 69
5278: PUSH
5279: LD_EXP 64
5283: DIFF
5284: PPUSH
5285: CALL_OW 1
5289: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5290: LD_INT 1
5292: PPUSH
5293: LD_INT 7
5295: PPUSH
5296: CALL_OW 383
// hc_name := Ali Hadrach ;
5300: LD_ADDR_OWVAR 26
5304: PUSH
5305: LD_STRING Ali Hadrach
5307: ST_TO_ADDR
// hc_gallery := us ;
5308: LD_ADDR_OWVAR 33
5312: PUSH
5313: LD_STRING us
5315: ST_TO_ADDR
// hc_face_number := 31 ;
5316: LD_ADDR_OWVAR 34
5320: PUSH
5321: LD_INT 31
5323: ST_TO_ADDR
// Friend := CreateHuman ;
5324: LD_ADDR_EXP 66
5328: PUSH
5329: CALL_OW 44
5333: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5334: LD_INT 14
5336: PPUSH
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 29
5345: PPUSH
5346: LD_INT 100
5348: PPUSH
5349: CALL 75901 0 5
// powellBomb := CreateVehicle ;
5353: LD_ADDR_EXP 67
5357: PUSH
5358: CALL_OW 45
5362: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5363: LD_EXP 67
5367: PPUSH
5368: LD_INT 90
5370: PPUSH
5371: LD_INT 51
5373: PPUSH
5374: LD_INT 0
5376: PPUSH
5377: CALL_OW 48
// end ;
5381: LD_VAR 0 1
5385: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5386: LD_INT 0
5388: PPUSH
5389: PPUSH
5390: PPUSH
// if IsLive ( kozlov_fac ) then
5391: LD_INT 332
5393: PPUSH
5394: CALL_OW 300
5398: IFFALSE 5402
// exit ;
5400: GO 5969
// ComExitBuilding ( Kozlov ) ;
5402: LD_EXP 65
5406: PPUSH
5407: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5411: LD_EXP 65
5415: PPUSH
5416: CALL_OW 257
5420: PUSH
5421: LD_INT 2
5423: NONEQUAL
5424: IFFALSE 5459
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5426: LD_EXP 65
5430: PPUSH
5431: LD_INT 324
5433: PPUSH
5434: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5438: LD_EXP 65
5442: PPUSH
5443: LD_INT 2
5445: PPUSH
5446: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5450: LD_EXP 65
5454: PPUSH
5455: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5459: LD_EXP 65
5463: PPUSH
5464: LD_INT 2
5466: PPUSH
5467: LD_INT 93
5469: PPUSH
5470: LD_INT 32
5472: PPUSH
5473: LD_INT 3
5475: PPUSH
5476: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5480: LD_INT 35
5482: PPUSH
5483: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5487: LD_INT 22
5489: PUSH
5490: LD_INT 8
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 30
5499: PUSH
5500: LD_INT 3
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 3
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 57
5519: PUSH
5520: EMPTY
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL_OW 69
5533: IFFALSE 5480
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5535: LD_ADDR_VAR 0 2
5539: PUSH
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 30
5552: PUSH
5553: LD_INT 3
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 23
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 57
5572: PUSH
5573: EMPTY
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: PUSH
5587: LD_INT 1
5589: ARRAY
5590: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5591: LD_INT 22
5593: PUSH
5594: LD_INT 8
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: PUSH
5601: LD_INT 23
5603: PUSH
5604: LD_INT 3
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PUSH
5611: LD_INT 30
5613: PUSH
5614: LD_INT 21
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PUSH
5621: EMPTY
5622: LIST
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: NOT
5631: IFFALSE 5709
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5633: LD_EXP 65
5637: PPUSH
5638: LD_INT 21
5640: PPUSH
5641: LD_INT 97
5643: PPUSH
5644: LD_INT 36
5646: PPUSH
5647: LD_INT 5
5649: PPUSH
5650: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5654: LD_INT 35
5656: PPUSH
5657: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5661: LD_INT 22
5663: PUSH
5664: LD_INT 8
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 23
5673: PUSH
5674: LD_INT 3
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_INT 30
5683: PUSH
5684: LD_INT 21
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 57
5693: PUSH
5694: EMPTY
5695: LIST
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 69
5707: IFFALSE 5654
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5709: LD_INT 22
5711: PUSH
5712: LD_INT 8
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 23
5721: PUSH
5722: LD_INT 3
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 30
5731: PUSH
5732: LD_INT 18
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PPUSH
5744: CALL_OW 69
5748: NOT
5749: IFFALSE 5827
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5751: LD_EXP 65
5755: PPUSH
5756: LD_INT 18
5758: PPUSH
5759: LD_INT 89
5761: PPUSH
5762: LD_INT 32
5764: PPUSH
5765: LD_INT 1
5767: PPUSH
5768: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5772: LD_INT 35
5774: PPUSH
5775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5779: LD_INT 22
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_INT 23
5791: PUSH
5792: LD_INT 3
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: LD_INT 30
5801: PUSH
5802: LD_INT 18
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 57
5811: PUSH
5812: EMPTY
5813: LIST
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: PPUSH
5821: CALL_OW 69
5825: IFFALSE 5772
// end ; lab := kozlov_lab ;
5827: LD_ADDR_VAR 0 3
5831: PUSH
5832: LD_INT 336
5834: ST_TO_ADDR
// if not lab then
5835: LD_VAR 0 3
5839: NOT
5840: IFFALSE 5844
// exit ;
5842: GO 5969
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5844: LD_EXP 65
5848: PPUSH
5849: LD_VAR 0 3
5853: PUSH
5854: LD_INT 1
5856: ARRAY
5857: PPUSH
5858: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5862: LD_EXP 65
5866: PPUSH
5867: LD_INT 4
5869: PPUSH
5870: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 1
5881: ARRAY
5882: PPUSH
5883: LD_INT 25
5885: PPUSH
5886: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5897: LD_INT 25
5899: PPUSH
5900: LD_INT 8
5902: PPUSH
5903: CALL_OW 321
5907: PUSH
5908: LD_INT 2
5910: EQUAL
5911: IFFALSE 5890
// ComExitBuilding ( Kozlov ) ;
5913: LD_EXP 65
5917: PPUSH
5918: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5922: LD_EXP 65
5926: PPUSH
5927: LD_VAR 0 2
5931: PPUSH
5932: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5936: LD_EXP 65
5940: PPUSH
5941: LD_INT 3
5943: PPUSH
5944: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5948: LD_VAR 0 2
5952: PPUSH
5953: LD_INT 23
5955: PPUSH
5956: LD_INT 3
5958: PPUSH
5959: LD_INT 1
5961: PPUSH
5962: LD_INT 48
5964: PPUSH
5965: CALL_OW 125
// end ;
5969: LD_VAR 0 1
5973: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5974: LD_EXP 22
5978: NOT
5979: IFFALSE 5991
5981: PUSH
5982: LD_EXP 15
5986: PUSH
5987: LD_INT 6
5989: GREATEREQUAL
5990: AND
5991: IFFALSE 6072
5993: GO 5995
5995: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5996: LD_INT 3
5998: PPUSH
5999: LD_INT 3
6001: PPUSH
6002: CALL 64552 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
6006: LD_INT 3
6008: PPUSH
6009: LD_INT 14
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: LD_INT 1
6017: PUSH
6018: LD_INT 28
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_INT 14
6029: PUSH
6030: LD_INT 1
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 28
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 14
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 28
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL 64415 0 2
// end ;
6072: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6073: LD_EXP 22
6077: NOT
6078: IFFALSE 6090
6080: PUSH
6081: LD_EXP 15
6085: PUSH
6086: LD_INT 6
6088: GREATEREQUAL
6089: AND
6090: IFFALSE 6105
6092: PUSH
6093: LD_INT 3
6095: PPUSH
6096: LD_INT 1
6098: PPUSH
6099: CALL 65871 0 2
6103: NOT
6104: AND
6105: IFFALSE 7062
6107: GO 6109
6109: DISABLE
6110: LD_INT 0
6112: PPUSH
6113: PPUSH
6114: PPUSH
6115: PPUSH
// begin enable ;
6116: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6117: LD_INT 22
6119: PUSH
6120: LD_INT 8
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 23
6129: PUSH
6130: LD_INT 2
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 30
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 7062
// if Prob ( 40 ) then
6161: LD_INT 40
6163: PPUSH
6164: CALL_OW 13
6168: IFFALSE 6295
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6170: LD_INT 3
6172: PPUSH
6173: LD_INT 14
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 28
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 14
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 28
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 14
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 28
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 14
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 28
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 14
6247: PUSH
6248: LD_INT 1
6250: PUSH
6251: LD_INT 2
6253: PUSH
6254: LD_INT 28
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 14
6265: PUSH
6266: LD_INT 1
6268: PUSH
6269: LD_INT 2
6271: PUSH
6272: LD_INT 26
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL 64415 0 2
// end else
6293: GO 6502
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6295: LD_INT 3
6297: PPUSH
6298: LD_INT 14
6300: PUSH
6301: LD_INT 1
6303: PUSH
6304: LD_INT 2
6306: PUSH
6307: LD_INT 27
6309: PUSH
6310: LD_INT 26
6312: PUSH
6313: LD_INT 26
6315: PUSH
6316: LD_INT 28
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_OWVAR 67
6329: ARRAY
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 14
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 27
6348: PUSH
6349: LD_INT 26
6351: PUSH
6352: LD_INT 26
6354: PUSH
6355: LD_INT 26
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_OWVAR 67
6368: ARRAY
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 14
6378: PUSH
6379: LD_INT 1
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: LD_INT 26
6387: PUSH
6388: LD_INT 26
6390: PUSH
6391: LD_INT 29
6393: PUSH
6394: LD_INT 29
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_OWVAR 67
6407: ARRAY
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 13
6417: PUSH
6418: LD_INT 1
6420: PUSH
6421: LD_INT 2
6423: PUSH
6424: LD_INT 26
6426: PUSH
6427: LD_INT 29
6429: PUSH
6430: LD_INT 29
6432: PUSH
6433: LD_INT 29
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_OWVAR 67
6446: ARRAY
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 29
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 14
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 26
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
6502: LD_INT 4200
6504: PPUSH
6505: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6509: LD_ADDR_VAR 0 2
6513: PUSH
6514: LD_INT 22
6516: PUSH
6517: LD_INT 8
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 21
6526: PUSH
6527: LD_INT 2
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 3
6536: PUSH
6537: LD_INT 34
6539: PUSH
6540: LD_INT 31
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: LD_INT 3
6553: PUSH
6554: LD_INT 34
6556: PUSH
6557: LD_INT 32
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 34
6573: PUSH
6574: LD_INT 88
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PPUSH
6592: CALL_OW 69
6596: PUSH
6597: LD_EXP 124
6601: PUSH
6602: LD_INT 3
6604: ARRAY
6605: DIFF
6606: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6607: LD_ADDR_EXP 121
6611: PUSH
6612: LD_EXP 121
6616: PPUSH
6617: LD_INT 3
6619: PPUSH
6620: LD_EXP 121
6624: PUSH
6625: LD_INT 3
6627: ARRAY
6628: PUSH
6629: LD_VAR 0 2
6633: DIFF
6634: PPUSH
6635: CALL_OW 1
6639: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6640: LD_ADDR_VAR 0 3
6644: PUSH
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 2
6650: PPUSH
6651: CALL_OW 12
6655: ST_TO_ADDR
// if target then
6656: LD_VAR 0 3
6660: IFFALSE 6820
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6662: LD_ADDR_VAR 0 2
6666: PUSH
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 50
6674: PUSH
6675: EMPTY
6676: LIST
6677: PPUSH
6678: CALL_OW 72
6682: ST_TO_ADDR
// if not tmp then
6683: LD_VAR 0 2
6687: NOT
6688: IFFALSE 6692
// break ;
6690: GO 6818
// for i in tmp do
6692: LD_ADDR_VAR 0 1
6696: PUSH
6697: LD_VAR 0 2
6701: PUSH
6702: FOR_IN
6703: IFFALSE 6743
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6705: LD_VAR 0 1
6709: PPUSH
6710: LD_INT 89
6712: PPUSH
6713: LD_INT 71
6715: PPUSH
6716: CALL_OW 297
6720: PUSH
6721: LD_INT 9
6723: GREATER
6724: IFFALSE 6741
// ComMoveXY ( i , 89 , 71 ) ;
6726: LD_VAR 0 1
6730: PPUSH
6731: LD_INT 89
6733: PPUSH
6734: LD_INT 71
6736: PPUSH
6737: CALL_OW 111
6741: GO 6702
6743: POP
6744: POP
// wait ( 0 0$1 ) ;
6745: LD_INT 35
6747: PPUSH
6748: CALL_OW 67
// p := Inc ( p ) ;
6752: LD_ADDR_VAR 0 4
6756: PUSH
6757: LD_VAR 0 4
6761: PPUSH
6762: CALL 110444 0 1
6766: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6767: LD_VAR 0 2
6771: PPUSH
6772: LD_INT 92
6774: PUSH
6775: LD_INT 89
6777: PUSH
6778: LD_INT 71
6780: PUSH
6781: LD_INT 9
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 72
6794: PUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_INT 1
6802: MINUS
6803: GREATEREQUAL
6804: IFTRUE 6816
6806: PUSH
6807: LD_VAR 0 4
6811: PUSH
6812: LD_INT 30
6814: GREATER
6815: OR
6816: IFFALSE 6662
// end else
6818: GO 6976
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6820: LD_ADDR_VAR 0 2
6824: PUSH
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 50
6832: PUSH
6833: EMPTY
6834: LIST
6835: PPUSH
6836: CALL_OW 72
6840: ST_TO_ADDR
// if not tmp then
6841: LD_VAR 0 2
6845: NOT
6846: IFFALSE 6850
// break ;
6848: GO 6976
// for i in tmp do
6850: LD_ADDR_VAR 0 1
6854: PUSH
6855: LD_VAR 0 2
6859: PUSH
6860: FOR_IN
6861: IFFALSE 6901
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6863: LD_VAR 0 1
6867: PPUSH
6868: LD_INT 125
6870: PPUSH
6871: LD_INT 129
6873: PPUSH
6874: CALL_OW 297
6878: PUSH
6879: LD_INT 9
6881: GREATER
6882: IFFALSE 6899
// ComMoveXY ( i , 125 , 129 ) ;
6884: LD_VAR 0 1
6888: PPUSH
6889: LD_INT 125
6891: PPUSH
6892: LD_INT 129
6894: PPUSH
6895: CALL_OW 111
6899: GO 6860
6901: POP
6902: POP
// wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// p := Inc ( p ) ;
6910: LD_ADDR_VAR 0 4
6914: PUSH
6915: LD_VAR 0 4
6919: PPUSH
6920: CALL 110444 0 1
6924: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6925: LD_VAR 0 2
6929: PPUSH
6930: LD_INT 92
6932: PUSH
6933: LD_INT 125
6935: PUSH
6936: LD_INT 129
6938: PUSH
6939: LD_INT 9
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: LIST
6946: LIST
6947: PPUSH
6948: CALL_OW 72
6952: PUSH
6953: LD_VAR 0 2
6957: PUSH
6958: LD_INT 1
6960: MINUS
6961: GREATEREQUAL
6962: IFTRUE 6974
6964: PUSH
6965: LD_VAR 0 4
6969: PUSH
6970: LD_INT 30
6972: GREATER
6973: OR
6974: IFFALSE 6820
// end ; repeat wait ( 0 0$1 ) ;
6976: LD_INT 35
6978: PPUSH
6979: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6983: LD_ADDR_VAR 0 2
6987: PUSH
6988: LD_VAR 0 2
6992: PPUSH
6993: LD_INT 50
6995: PUSH
6996: EMPTY
6997: LIST
6998: PPUSH
6999: CALL_OW 72
7003: ST_TO_ADDR
// for i in tmp do
7004: LD_ADDR_VAR 0 1
7008: PUSH
7009: LD_VAR 0 2
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7053
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7017: LD_VAR 0 1
7021: PPUSH
7022: LD_INT 81
7024: PUSH
7025: LD_INT 8
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PPUSH
7032: CALL_OW 69
7036: PPUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL_OW 74
7046: PPUSH
7047: CALL_OW 115
7051: GO 7014
7053: POP
7054: POP
// until not tmp ;
7055: LD_VAR 0 2
7059: NOT
7060: IFFALSE 6976
// end ;
7062: PPOPN 4
7064: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7065: LD_EXP 22
7069: NOT
7070: IFFALSE 7082
7072: PUSH
7073: LD_EXP 15
7077: PUSH
7078: LD_INT 6
7080: GREATEREQUAL
7081: AND
7082: IFFALSE 7094
7084: PUSH
7085: LD_OWVAR 67
7089: PUSH
7090: LD_INT 1
7092: GREATER
7093: AND
7094: IFFALSE 7627
7096: GO 7098
7098: DISABLE
7099: LD_INT 0
7101: PPUSH
7102: PPUSH
7103: PPUSH
// begin enable ;
7104: ENABLE
// tmp := [ ] ;
7105: LD_ADDR_VAR 0 3
7109: PUSH
7110: EMPTY
7111: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7112: LD_ADDR_VAR 0 1
7116: PUSH
7117: DOUBLE
7118: LD_INT 1
7120: DEC
7121: ST_TO_ADDR
7122: LD_INT 4
7124: PUSH
7125: LD_INT 6
7127: PUSH
7128: LD_INT 7
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: LIST
7138: LIST
7139: PUSH
7140: LD_OWVAR 67
7144: ARRAY
7145: PUSH
7146: FOR_TO
7147: IFFALSE 7307
// begin uc_side := 8 ;
7149: LD_ADDR_OWVAR 20
7153: PUSH
7154: LD_INT 8
7156: ST_TO_ADDR
// uc_nation := 2 ;
7157: LD_ADDR_OWVAR 21
7161: PUSH
7162: LD_INT 2
7164: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7165: LD_INT 13
7167: PUSH
7168: LD_INT 14
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 1
7177: PPUSH
7178: LD_INT 2
7180: PPUSH
7181: CALL_OW 12
7185: ARRAY
7186: PPUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_INT 5
7192: PPUSH
7193: LD_INT 27
7195: PUSH
7196: LD_INT 28
7198: PUSH
7199: LD_INT 26
7201: PUSH
7202: LD_INT 25
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PUSH
7211: LD_INT 1
7213: PPUSH
7214: LD_INT 4
7216: PPUSH
7217: CALL_OW 12
7221: ARRAY
7222: PPUSH
7223: LD_INT 88
7225: PPUSH
7226: CALL 75901 0 5
// un := CreateVehicle ;
7230: LD_ADDR_VAR 0 2
7234: PUSH
7235: CALL_OW 45
7239: ST_TO_ADDR
// tmp := tmp ^ un ;
7240: LD_ADDR_VAR 0 3
7244: PUSH
7245: LD_VAR 0 3
7249: PUSH
7250: LD_VAR 0 2
7254: ADD
7255: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7256: LD_VAR 0 2
7260: PPUSH
7261: LD_INT 3
7263: PPUSH
7264: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7268: LD_VAR 0 2
7272: PPUSH
7273: LD_INT 30
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 16
7290: PPUSH
7291: LD_INT 11
7293: PPUSH
7294: CALL_OW 111
// wait ( 0 0$2 ) ;
7298: LD_INT 70
7300: PPUSH
7301: CALL_OW 67
// end ;
7305: GO 7146
7307: POP
7308: POP
// for i = 1 to Difficulty do
7309: LD_ADDR_VAR 0 1
7313: PUSH
7314: DOUBLE
7315: LD_INT 1
7317: DEC
7318: ST_TO_ADDR
7319: LD_OWVAR 67
7323: PUSH
7324: FOR_TO
7325: IFFALSE 7454
// begin uc_side := 8 ;
7327: LD_ADDR_OWVAR 20
7331: PUSH
7332: LD_INT 8
7334: ST_TO_ADDR
// uc_nation := 2 ;
7335: LD_ADDR_OWVAR 21
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7343: LD_INT 0
7345: PPUSH
7346: LD_INT 8
7348: PPUSH
7349: LD_INT 8
7351: PUSH
7352: LD_INT 8
7354: PUSH
7355: LD_INT 9
7357: PUSH
7358: LD_INT 10
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_OWVAR 67
7371: ARRAY
7372: PPUSH
7373: CALL_OW 380
// un := CreateHuman ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: CALL_OW 44
7386: ST_TO_ADDR
// tmp := tmp ^ un ;
7387: LD_ADDR_VAR 0 3
7391: PUSH
7392: LD_VAR 0 3
7396: PUSH
7397: LD_VAR 0 2
7401: ADD
7402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7403: LD_VAR 0 2
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7415: LD_VAR 0 2
7419: PPUSH
7420: LD_INT 30
7422: PPUSH
7423: LD_INT 0
7425: PPUSH
7426: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7430: LD_VAR 0 2
7434: PPUSH
7435: LD_INT 16
7437: PPUSH
7438: LD_INT 11
7440: PPUSH
7441: CALL_OW 111
// wait ( 0 0$2 ) ;
7445: LD_INT 70
7447: PPUSH
7448: CALL_OW 67
// end ;
7452: GO 7324
7454: POP
7455: POP
// repeat wait ( 0 0$1 ) ;
7456: LD_INT 35
7458: PPUSH
7459: CALL_OW 67
// if legionDestroyed then
7463: LD_EXP 22
7467: IFFALSE 7471
// exit ;
7469: GO 7627
// for i in tmp do
7471: LD_ADDR_VAR 0 1
7475: PUSH
7476: LD_VAR 0 3
7480: PUSH
7481: FOR_IN
7482: IFFALSE 7618
// begin if GetLives ( i ) > 250 then
7484: LD_VAR 0 1
7488: PPUSH
7489: CALL_OW 256
7493: PUSH
7494: LD_INT 250
7496: GREATER
7497: IFFALSE 7589
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7499: LD_INT 81
7501: PUSH
7502: LD_INT 8
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 91
7511: PUSH
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 10
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PPUSH
7529: CALL_OW 69
7533: NOT
7534: IFFALSE 7553
// ComAgressiveMove ( i , 67 , 110 ) else
7536: LD_VAR 0 1
7540: PPUSH
7541: LD_INT 67
7543: PPUSH
7544: LD_INT 110
7546: PPUSH
7547: CALL_OW 114
7551: GO 7587
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7553: LD_VAR 0 1
7557: PPUSH
7558: LD_INT 81
7560: PUSH
7561: LD_INT 8
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PPUSH
7568: CALL_OW 69
7572: PPUSH
7573: LD_VAR 0 1
7577: PPUSH
7578: CALL_OW 74
7582: PPUSH
7583: CALL_OW 115
// end else
7587: GO 7616
// if IsDead ( i ) then
7589: LD_VAR 0 1
7593: PPUSH
7594: CALL_OW 301
7598: IFFALSE 7616
// tmp := tmp diff i ;
7600: LD_ADDR_VAR 0 3
7604: PUSH
7605: LD_VAR 0 3
7609: PUSH
7610: LD_VAR 0 1
7614: DIFF
7615: ST_TO_ADDR
// end ;
7616: GO 7481
7618: POP
7619: POP
// until not tmp ;
7620: LD_VAR 0 3
7624: NOT
7625: IFFALSE 7456
// end ; end_of_file
7627: PPOPN 3
7629: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7630: LD_INT 0
7632: PPUSH
7633: PPUSH
7634: PPUSH
7635: PPUSH
7636: PPUSH
7637: PPUSH
7638: PPUSH
7639: PPUSH
7640: PPUSH
7641: PPUSH
// side := 3 ;
7642: LD_ADDR_VAR 0 6
7646: PUSH
7647: LD_INT 3
7649: ST_TO_ADDR
// uc_side := side ;
7650: LD_ADDR_OWVAR 20
7654: PUSH
7655: LD_VAR 0 6
7659: ST_TO_ADDR
// uc_nation := 3 ;
7660: LD_ADDR_OWVAR 21
7664: PUSH
7665: LD_INT 3
7667: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: LD_INT 22
7675: PUSH
7676: LD_VAR 0 6
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 21
7687: PUSH
7688: LD_INT 3
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: PPUSH
7699: CALL_OW 69
7703: PUSH
7704: FOR_IN
7705: IFFALSE 7721
// SetBLevel ( i , 10 ) ;
7707: LD_VAR 0 2
7711: PPUSH
7712: LD_INT 10
7714: PPUSH
7715: CALL_OW 241
7719: GO 7704
7721: POP
7722: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7723: LD_ADDR_VAR 0 10
7727: PUSH
7728: LD_INT 22
7730: PUSH
7731: LD_VAR 0 6
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 34
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PPUSH
7754: CALL_OW 69
7758: ST_TO_ADDR
// if teleport then
7759: LD_VAR 0 10
7763: IFFALSE 7784
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7765: LD_VAR 0 10
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_INT 123
7776: PPUSH
7777: LD_INT 122
7779: PPUSH
7780: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7784: LD_ADDR_EXP 68
7788: PUSH
7789: LD_STRING Platonov
7791: PPUSH
7792: CALL_OW 25
7796: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7797: LD_ADDR_EXP 69
7801: PUSH
7802: LD_STRING Kovalyuk
7804: PPUSH
7805: CALL_OW 25
7809: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7810: LD_ADDR_EXP 71
7814: PUSH
7815: LD_STRING Yakotich
7817: PPUSH
7818: LD_EXP 1
7822: NOT
7823: PPUSH
7824: LD_STRING 09_
7826: PPUSH
7827: CALL 70939 0 3
7831: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7832: LD_ADDR_EXP 70
7836: PUSH
7837: LD_STRING Bystrov
7839: PPUSH
7840: CALL_OW 25
7844: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7845: LD_ADDR_EXP 72
7849: PUSH
7850: LD_STRING Gleb
7852: PPUSH
7853: CALL_OW 25
7857: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7858: LD_STRING 03_Cornel
7860: PPUSH
7861: CALL_OW 28
7865: IFFALSE 7913
// begin Bierezov := NewCharacter ( Mikhail ) ;
7867: LD_ADDR_EXP 73
7871: PUSH
7872: LD_STRING Mikhail
7874: PPUSH
7875: CALL_OW 25
7879: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7880: LD_EXP 73
7884: PPUSH
7885: LD_INT 197
7887: PPUSH
7888: LD_INT 111
7890: PPUSH
7891: LD_INT 9
7893: PPUSH
7894: LD_INT 0
7896: PPUSH
7897: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7901: LD_EXP 73
7905: PPUSH
7906: LD_INT 3
7908: PPUSH
7909: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7913: LD_EXP 68
7917: PPUSH
7918: LD_INT 126
7920: PPUSH
7921: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7925: LD_EXP 69
7929: PPUSH
7930: LD_INT 134
7932: PPUSH
7933: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7937: LD_EXP 71
7941: PPUSH
7942: LD_INT 197
7944: PPUSH
7945: LD_INT 111
7947: PPUSH
7948: LD_INT 9
7950: PPUSH
7951: LD_INT 0
7953: PPUSH
7954: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7958: LD_EXP 70
7962: PPUSH
7963: LD_INT 197
7965: PPUSH
7966: LD_INT 111
7968: PPUSH
7969: LD_INT 9
7971: PPUSH
7972: LD_INT 0
7974: PPUSH
7975: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7979: LD_EXP 72
7983: PPUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 111
7989: PPUSH
7990: LD_INT 9
7992: PPUSH
7993: LD_INT 0
7995: PPUSH
7996: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
8000: LD_ADDR_VAR 0 5
8004: PUSH
8005: LD_INT 126
8007: PPUSH
8008: LD_INT 4
8010: PPUSH
8011: LD_STRING zhukov
8013: PPUSH
8014: LD_INT 9
8016: PUSH
8017: LD_INT 10
8019: PUSH
8020: LD_INT 10
8022: PUSH
8023: LD_INT 10
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: PUSH
8032: LD_OWVAR 67
8036: ARRAY
8037: PPUSH
8038: LD_INT 90000
8040: PUSH
8041: LD_INT 1000
8043: PUSH
8044: LD_INT 300
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PPUSH
8052: LD_INT 18
8054: PUSH
8055: LD_INT 8
8057: PUSH
8058: LD_INT 12
8060: PUSH
8061: LD_INT 6
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: PPUSH
8070: CALL 79738 0 6
8074: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8075: LD_ADDR_EXP 102
8079: PUSH
8080: LD_EXP 102
8084: PPUSH
8085: LD_INT 2
8087: PPUSH
8088: LD_VAR 0 5
8092: PUSH
8093: LD_EXP 71
8097: PUSH
8098: LD_EXP 70
8102: PUSH
8103: LD_EXP 72
8107: PUSH
8108: LD_EXP 73
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: LIST
8117: LIST
8118: UNION
8119: PPUSH
8120: CALL_OW 1
8124: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8125: LD_ADDR_VAR 0 4
8129: PUSH
8130: LD_INT 267
8132: PPUSH
8133: CALL_OW 274
8137: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8138: LD_VAR 0 4
8142: PPUSH
8143: LD_INT 1
8145: PPUSH
8146: LD_INT 5000
8148: PPUSH
8149: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8153: LD_VAR 0 4
8157: PPUSH
8158: LD_INT 2
8160: PPUSH
8161: LD_INT 200
8163: PPUSH
8164: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8168: LD_VAR 0 4
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 200
8178: PPUSH
8179: CALL_OW 277
// for i := 1 to 6 do
8183: LD_ADDR_VAR 0 2
8187: PUSH
8188: DOUBLE
8189: LD_INT 1
8191: DEC
8192: ST_TO_ADDR
8193: LD_INT 6
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8280
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8199: LD_INT 0
8201: PPUSH
8202: LD_INT 8
8204: PUSH
8205: LD_INT 9
8207: PUSH
8208: LD_INT 10
8210: PUSH
8211: LD_INT 10
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: PUSH
8220: LD_OWVAR 67
8224: ARRAY
8225: PPUSH
8226: CALL_OW 381
// un := CreateHuman ;
8230: LD_ADDR_VAR 0 8
8234: PUSH
8235: CALL_OW 44
8239: ST_TO_ADDR
// if i mod 2 = 0 then
8240: LD_VAR 0 2
8244: PUSH
8245: LD_INT 2
8247: MOD
8248: PUSH
8249: LD_INT 0
8251: EQUAL
8252: IFFALSE 8266
// SetClass ( un , class_bazooker ) ;
8254: LD_VAR 0 8
8258: PPUSH
8259: LD_INT 9
8261: PPUSH
8262: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8266: LD_VAR 0 8
8270: PPUSH
8271: LD_INT 460
8273: PPUSH
8274: CALL_OW 52
// end ;
8278: GO 8196
8280: POP
8281: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8282: LD_INT 21
8284: PPUSH
8285: LD_INT 3
8287: PPUSH
8288: LD_INT 3
8290: PPUSH
8291: LD_INT 52
8293: PPUSH
8294: LD_INT 100
8296: PPUSH
8297: CALL 75901 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8301: CALL_OW 45
8305: PPUSH
8306: LD_INT 259
8308: PPUSH
8309: LD_INT 145
8311: PPUSH
8312: LD_INT 3
8314: PPUSH
8315: LD_INT 0
8317: PPUSH
8318: CALL 111231 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8322: CALL_OW 45
8326: PPUSH
8327: LD_INT 245
8329: PPUSH
8330: LD_INT 139
8332: PPUSH
8333: LD_INT 3
8335: PPUSH
8336: LD_INT 0
8338: PPUSH
8339: CALL 111231 0 5
// behemoths := [ ] ;
8343: LD_ADDR_EXP 76
8347: PUSH
8348: EMPTY
8349: ST_TO_ADDR
// behemothBuilders := [ ] ;
8350: LD_ADDR_EXP 77
8354: PUSH
8355: EMPTY
8356: ST_TO_ADDR
// if Kovalyuk then
8357: LD_EXP 69
8361: IFFALSE 8383
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8363: LD_ADDR_EXP 77
8367: PUSH
8368: LD_EXP 77
8372: PPUSH
8373: LD_EXP 69
8377: PPUSH
8378: CALL 109071 0 2
8382: ST_TO_ADDR
// end ;
8383: LD_VAR 0 1
8387: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8388: LD_INT 0
8390: PPUSH
8391: PPUSH
8392: PPUSH
8393: PPUSH
8394: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8395: LD_ADDR_VAR 0 4
8399: PUSH
8400: LD_INT 221
8402: PUSH
8403: LD_INT 154
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 223
8412: PUSH
8413: LD_INT 149
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 228
8422: PUSH
8423: LD_INT 147
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: LD_INT 232
8432: PUSH
8433: LD_INT 155
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: LIST
8444: LIST
8445: ST_TO_ADDR
// if not behemothBuilders then
8446: LD_EXP 77
8450: NOT
8451: IFFALSE 8455
// exit ;
8453: GO 8586
// j := 1 ;
8455: LD_ADDR_VAR 0 3
8459: PUSH
8460: LD_INT 1
8462: ST_TO_ADDR
// for i in behemothBuilders do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_EXP 77
8472: PUSH
8473: FOR_IN
8474: IFFALSE 8584
// begin if GetClass ( i ) <> class_mechanic then
8476: LD_VAR 0 2
8480: PPUSH
8481: CALL_OW 257
8485: PUSH
8486: LD_INT 3
8488: NONEQUAL
8489: IFFALSE 8503
// SetClass ( i , class_mechanic ) ;
8491: LD_VAR 0 2
8495: PPUSH
8496: LD_INT 3
8498: PPUSH
8499: CALL_OW 336
// if IsInUnit ( i ) then
8503: LD_VAR 0 2
8507: PPUSH
8508: CALL_OW 310
8512: IFFALSE 8523
// ComExitBuilding ( i ) ;
8514: LD_VAR 0 2
8518: PPUSH
8519: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_INT 37
8530: PPUSH
8531: LD_VAR 0 4
8535: PUSH
8536: LD_VAR 0 3
8540: ARRAY
8541: PUSH
8542: LD_INT 1
8544: ARRAY
8545: PPUSH
8546: LD_VAR 0 4
8550: PUSH
8551: LD_VAR 0 3
8555: ARRAY
8556: PUSH
8557: LD_INT 2
8559: ARRAY
8560: PPUSH
8561: LD_INT 0
8563: PPUSH
8564: CALL_OW 230
// j := j + 1 ;
8568: LD_ADDR_VAR 0 3
8572: PUSH
8573: LD_VAR 0 3
8577: PUSH
8578: LD_INT 1
8580: PLUS
8581: ST_TO_ADDR
// end ;
8582: GO 8473
8584: POP
8585: POP
// end ;
8586: LD_VAR 0 1
8590: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8591: LD_INT 24
8593: PPUSH
8594: LD_INT 30
8596: PUSH
8597: LD_INT 37
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PPUSH
8604: CALL_OW 70
8608: IFFALSE 8621
8610: GO 8612
8612: DISABLE
// behemothUnderConstruct := true ;
8613: LD_ADDR_EXP 26
8617: PUSH
8618: LD_INT 1
8620: ST_TO_ADDR
8621: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8622: LD_INT 3
8624: PPUSH
8625: CALL 109132 0 1
8629: IFFALSE 8662
8631: PUSH
8632: LD_INT 22
8634: PUSH
8635: LD_INT 3
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 37
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PPUSH
8656: CALL_OW 69
8660: NOT
8661: AND
8662: IFFALSE 8852
8664: GO 8666
8666: DISABLE
8667: LD_INT 0
8669: PPUSH
8670: PPUSH
// begin enable ;
8671: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_INT 3
8679: PPUSH
8680: CALL 109132 0 1
8684: ST_TO_ADDR
// for i in tmp do
8685: LD_ADDR_VAR 0 1
8689: PUSH
8690: LD_VAR 0 2
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8850
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8698: LD_VAR 0 1
8702: PPUSH
8703: LD_INT 9
8705: PPUSH
8706: CALL_OW 308
8710: IFFALSE 8728
8712: PUSH
8713: LD_VAR 0 1
8717: PPUSH
8718: CALL_OW 110
8722: PUSH
8723: LD_INT 2
8725: EQUAL
8726: NOT
8727: AND
8728: IFFALSE 8742
// SetTag ( i , 2 ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_INT 2
8737: PPUSH
8738: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8742: LD_INT 81
8744: PUSH
8745: LD_INT 3
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PUSH
8752: LD_INT 91
8754: PUSH
8755: LD_VAR 0 1
8759: PUSH
8760: LD_INT 12
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL_OW 69
8776: NOT
8777: IFFALSE 8795
8779: PUSH
8780: LD_VAR 0 1
8784: PPUSH
8785: CALL_OW 110
8789: PUSH
8790: LD_INT 2
8792: EQUAL
8793: NOT
8794: AND
8795: IFFALSE 8814
// ComAgressiveMove ( i , 64 , 93 ) else
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_INT 64
8804: PPUSH
8805: LD_INT 93
8807: PPUSH
8808: CALL_OW 114
8812: GO 8848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8814: LD_VAR 0 1
8818: PPUSH
8819: LD_INT 81
8821: PUSH
8822: LD_INT 3
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 74
8843: PPUSH
8844: CALL_OW 115
// end ;
8848: GO 8695
8850: POP
8851: POP
// end ;
8852: PPOPN 2
8854: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8855: LD_INT 0
8857: PPUSH
8858: PPUSH
8859: PPUSH
// result := [ ] ;
8860: LD_ADDR_VAR 0 2
8864: PUSH
8865: EMPTY
8866: ST_TO_ADDR
// uc_side := 6 ;
8867: LD_ADDR_OWVAR 20
8871: PUSH
8872: LD_INT 6
8874: ST_TO_ADDR
// uc_nation := 3 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 3
8882: ST_TO_ADDR
// case strength of 1 :
8883: LD_VAR 0 1
8887: PUSH
8888: LD_INT 1
8890: DOUBLE
8891: EQUAL
8892: IFTRUE 8896
8894: GO 9038
8896: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8897: LD_ADDR_VAR 0 3
8901: PUSH
8902: DOUBLE
8903: LD_INT 1
8905: DEC
8906: ST_TO_ADDR
8907: LD_INT 4
8909: PUSH
8910: LD_INT 5
8912: PUSH
8913: LD_INT 6
8915: PUSH
8916: LD_INT 7
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_OWVAR 67
8929: ARRAY
8930: PUSH
8931: FOR_TO
8932: IFFALSE 9034
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8934: LD_INT 22
8936: PUSH
8937: LD_INT 24
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 2
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 1
8960: PUSH
8961: LD_INT 3
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: LD_INT 1
8970: PPUSH
8971: LD_INT 2
8973: PPUSH
8974: CALL_OW 12
8978: ARRAY
8979: PPUSH
8980: LD_INT 3
8982: PPUSH
8983: LD_INT 43
8985: PUSH
8986: LD_INT 44
8988: PUSH
8989: LD_INT 45
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: LIST
8996: PUSH
8997: LD_INT 1
8999: PPUSH
9000: LD_INT 3
9002: PPUSH
9003: CALL_OW 12
9007: ARRAY
9008: PPUSH
9009: LD_INT 80
9011: PPUSH
9012: CALL 75901 0 5
// result := result union CreateVehicle ;
9016: LD_ADDR_VAR 0 2
9020: PUSH
9021: LD_VAR 0 2
9025: PUSH
9026: CALL_OW 45
9030: UNION
9031: ST_TO_ADDR
// end ;
9032: GO 8931
9034: POP
9035: POP
// end ; 2 :
9036: GO 10033
9038: LD_INT 2
9040: DOUBLE
9041: EQUAL
9042: IFTRUE 9046
9044: GO 9214
9046: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9047: LD_ADDR_VAR 0 3
9051: PUSH
9052: DOUBLE
9053: LD_INT 1
9055: DEC
9056: ST_TO_ADDR
9057: LD_INT 5
9059: PUSH
9060: LD_INT 6
9062: PUSH
9063: LD_INT 7
9065: PUSH
9066: LD_INT 8
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: PUSH
9075: LD_OWVAR 67
9079: ARRAY
9080: PUSH
9081: FOR_TO
9082: IFFALSE 9210
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9084: LD_INT 22
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 24
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: PUSH
9098: LD_VAR 0 3
9102: PUSH
9103: LD_INT 3
9105: MOD
9106: PUSH
9107: LD_INT 1
9109: PLUS
9110: ARRAY
9111: PPUSH
9112: LD_INT 1
9114: PUSH
9115: LD_INT 3
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 1
9124: PPUSH
9125: LD_INT 2
9127: PPUSH
9128: CALL_OW 12
9132: ARRAY
9133: PPUSH
9134: LD_INT 3
9136: PPUSH
9137: LD_INT 43
9139: PUSH
9140: LD_INT 44
9142: PUSH
9143: LD_INT 45
9145: PUSH
9146: LD_INT 44
9148: PUSH
9149: LD_INT 46
9151: PUSH
9152: LD_INT 46
9154: PUSH
9155: LD_INT 49
9157: PUSH
9158: LD_INT 49
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: PUSH
9171: LD_VAR 0 3
9175: PUSH
9176: LD_INT 8
9178: MOD
9179: PUSH
9180: LD_INT 1
9182: PLUS
9183: ARRAY
9184: PPUSH
9185: LD_INT 80
9187: PPUSH
9188: CALL 75901 0 5
// result := result union CreateVehicle ;
9192: LD_ADDR_VAR 0 2
9196: PUSH
9197: LD_VAR 0 2
9201: PUSH
9202: CALL_OW 45
9206: UNION
9207: ST_TO_ADDR
// end ;
9208: GO 9081
9210: POP
9211: POP
// end ; 3 :
9212: GO 10033
9214: LD_INT 3
9216: DOUBLE
9217: EQUAL
9218: IFTRUE 9222
9220: GO 9394
9222: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 6
9235: PUSH
9236: LD_INT 7
9238: PUSH
9239: LD_INT 8
9241: PUSH
9242: LD_INT 9
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: PUSH
9251: LD_OWVAR 67
9255: ARRAY
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9390
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9260: LD_INT 22
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: LD_INT 24
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: LD_VAR 0 3
9278: PUSH
9279: LD_INT 3
9281: MOD
9282: PUSH
9283: LD_INT 1
9285: PLUS
9286: ARRAY
9287: PPUSH
9288: LD_INT 1
9290: PUSH
9291: LD_INT 3
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PUSH
9298: LD_INT 1
9300: PPUSH
9301: LD_INT 2
9303: PPUSH
9304: CALL_OW 12
9308: ARRAY
9309: PPUSH
9310: LD_INT 3
9312: PPUSH
9313: LD_INT 43
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: LD_INT 45
9321: PUSH
9322: LD_INT 45
9324: PUSH
9325: LD_INT 46
9327: PUSH
9328: LD_INT 46
9330: PUSH
9331: LD_INT 49
9333: PUSH
9334: LD_INT 49
9336: PUSH
9337: LD_INT 49
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 9
9358: MOD
9359: PUSH
9360: LD_INT 1
9362: PLUS
9363: ARRAY
9364: PPUSH
9365: LD_INT 80
9367: PPUSH
9368: CALL 75901 0 5
// result := result union CreateVehicle ;
9372: LD_ADDR_VAR 0 2
9376: PUSH
9377: LD_VAR 0 2
9381: PUSH
9382: CALL_OW 45
9386: UNION
9387: ST_TO_ADDR
// end ;
9388: GO 9257
9390: POP
9391: POP
// end ; 4 :
9392: GO 10033
9394: LD_INT 4
9396: DOUBLE
9397: EQUAL
9398: IFTRUE 9402
9400: GO 10032
9402: POP
// begin uc_nation := 3 ;
9403: LD_ADDR_OWVAR 21
9407: PUSH
9408: LD_INT 3
9410: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9411: LD_ADDR_VAR 0 3
9415: PUSH
9416: DOUBLE
9417: LD_INT 1
9419: DEC
9420: ST_TO_ADDR
9421: LD_INT 6
9423: PUSH
9424: LD_INT 8
9426: PUSH
9427: LD_INT 9
9429: PUSH
9430: LD_INT 10
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: PUSH
9439: LD_OWVAR 67
9443: ARRAY
9444: PUSH
9445: FOR_TO
9446: IFFALSE 9578
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9448: LD_INT 22
9450: PUSH
9451: LD_INT 24
9453: PUSH
9454: LD_INT 24
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: LIST
9461: PUSH
9462: LD_VAR 0 3
9466: PUSH
9467: LD_INT 3
9469: MOD
9470: PUSH
9471: LD_INT 1
9473: PLUS
9474: ARRAY
9475: PPUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 3
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 2
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 45
9503: PUSH
9504: LD_INT 47
9506: PUSH
9507: LD_INT 47
9509: PUSH
9510: LD_INT 45
9512: PUSH
9513: LD_INT 46
9515: PUSH
9516: LD_INT 46
9518: PUSH
9519: LD_INT 49
9521: PUSH
9522: LD_INT 49
9524: PUSH
9525: LD_INT 49
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: PUSH
9539: LD_VAR 0 3
9543: PUSH
9544: LD_INT 9
9546: MOD
9547: PUSH
9548: LD_INT 1
9550: PLUS
9551: ARRAY
9552: PPUSH
9553: LD_INT 80
9555: PPUSH
9556: CALL 75901 0 5
// result := result union CreateVehicle ;
9560: LD_ADDR_VAR 0 2
9564: PUSH
9565: LD_VAR 0 2
9569: PUSH
9570: CALL_OW 45
9574: UNION
9575: ST_TO_ADDR
// end ;
9576: GO 9445
9578: POP
9579: POP
// if not KappaStatus then
9580: LD_EXP 2
9584: NOT
9585: IFFALSE 9820
// begin uc_nation := 1 ;
9587: LD_ADDR_OWVAR 21
9591: PUSH
9592: LD_INT 1
9594: ST_TO_ADDR
// for i = 1 to 3 do
9595: LD_ADDR_VAR 0 3
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_INT 3
9607: PUSH
9608: FOR_TO
9609: IFFALSE 9745
// begin j := rand ( 0 , 1 ) ;
9611: LD_ADDR_VAR 0 4
9615: PUSH
9616: LD_INT 0
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9627: LD_INT 3
9629: PUSH
9630: LD_INT 5
9632: PUSH
9633: LD_INT 5
9635: PUSH
9636: LD_INT 4
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_VAR 0 4
9649: PUSH
9650: LD_INT 1
9652: PPUSH
9653: LD_INT 3
9655: PPUSH
9656: CALL_OW 12
9660: PLUS
9661: ARRAY
9662: PPUSH
9663: LD_INT 1
9665: PUSH
9666: LD_INT 3
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 2
9678: PPUSH
9679: CALL_OW 12
9683: ARRAY
9684: PPUSH
9685: LD_INT 3
9687: PPUSH
9688: LD_INT 9
9690: PUSH
9691: LD_INT 7
9693: PUSH
9694: LD_INT 6
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PUSH
9702: LD_VAR 0 4
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 2
9712: PPUSH
9713: CALL_OW 12
9717: PLUS
9718: ARRAY
9719: PPUSH
9720: LD_INT 85
9722: PPUSH
9723: CALL 75901 0 5
// result := result union CreateVehicle ;
9727: LD_ADDR_VAR 0 2
9731: PUSH
9732: LD_VAR 0 2
9736: PUSH
9737: CALL_OW 45
9741: UNION
9742: ST_TO_ADDR
// end ;
9743: GO 9608
9745: POP
9746: POP
// if vsevolodFirstAttack then
9747: LD_EXP 24
9751: IFFALSE 9818
// begin vsevolodFirstAttack := false ;
9753: LD_ADDR_EXP 24
9757: PUSH
9758: LD_INT 0
9760: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9761: LD_INT 5
9763: PPUSH
9764: LD_INT 3
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 100
9775: PPUSH
9776: CALL 75901 0 5
// sewiVeh := CreateVehicle ;
9780: LD_ADDR_EXP 75
9784: PUSH
9785: CALL_OW 45
9789: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9790: LD_EXP 75
9794: PPUSH
9795: LD_INT 1
9797: PPUSH
9798: CALL_OW 242
// result := result union sewiVeh ;
9802: LD_ADDR_VAR 0 2
9806: PUSH
9807: LD_VAR 0 2
9811: PUSH
9812: LD_EXP 75
9816: UNION
9817: ST_TO_ADDR
// end ; end else
9818: GO 10030
// if vsevolodFirstAttack then
9820: LD_EXP 24
9824: IFFALSE 10030
// begin vsevolodFirstAttack := false ;
9826: LD_ADDR_EXP 24
9830: PUSH
9831: LD_INT 0
9833: ST_TO_ADDR
// uc_nation := 3 ;
9834: LD_ADDR_OWVAR 21
9838: PUSH
9839: LD_INT 3
9841: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9842: LD_ADDR_VAR 0 3
9846: PUSH
9847: DOUBLE
9848: LD_INT 1
9850: DEC
9851: ST_TO_ADDR
9852: LD_INT 2
9854: PUSH
9855: LD_OWVAR 67
9859: PLUS
9860: PUSH
9861: FOR_TO
9862: IFFALSE 9970
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9864: LD_INT 22
9866: PUSH
9867: LD_INT 24
9869: PUSH
9870: LD_INT 24
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: LIST
9877: PUSH
9878: LD_VAR 0 3
9882: PUSH
9883: LD_INT 3
9885: MOD
9886: PUSH
9887: LD_INT 1
9889: PLUS
9890: ARRAY
9891: PPUSH
9892: LD_INT 1
9894: PUSH
9895: LD_INT 3
9897: PUSH
9898: EMPTY
9899: LIST
9900: LIST
9901: PUSH
9902: LD_INT 1
9904: PPUSH
9905: LD_INT 2
9907: PPUSH
9908: CALL_OW 12
9912: ARRAY
9913: PPUSH
9914: LD_INT 1
9916: PPUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 47
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: LIST
9930: PUSH
9931: LD_VAR 0 3
9935: PUSH
9936: LD_INT 3
9938: MOD
9939: PUSH
9940: LD_INT 1
9942: PLUS
9943: ARRAY
9944: PPUSH
9945: LD_INT 80
9947: PPUSH
9948: CALL 75901 0 5
// result := result union CreateVehicle ;
9952: LD_ADDR_VAR 0 2
9956: PUSH
9957: LD_VAR 0 2
9961: PUSH
9962: CALL_OW 45
9966: UNION
9967: ST_TO_ADDR
// end ;
9968: GO 9861
9970: POP
9971: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9972: LD_INT 24
9974: PPUSH
9975: LD_INT 3
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: LD_INT 47
9983: PPUSH
9984: LD_INT 100
9986: PPUSH
9987: CALL 75901 0 5
// sewiVeh := CreateVehicle ;
9991: LD_ADDR_EXP 75
9995: PUSH
9996: CALL_OW 45
10000: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
10001: LD_EXP 75
10005: PPUSH
10006: LD_INT 6
10008: NEG
10009: PPUSH
10010: CALL_OW 242
// result := result union sewiVeh ;
10014: LD_ADDR_VAR 0 2
10018: PUSH
10019: LD_VAR 0 2
10023: PUSH
10024: LD_EXP 75
10028: UNION
10029: ST_TO_ADDR
// end ; end ; end ;
10030: GO 10033
10032: POP
// end ;
10033: LD_VAR 0 2
10037: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10038: LD_EXP 16
10042: IFFALSE 10803
10044: GO 10046
10046: DISABLE
10047: LD_INT 0
10049: PPUSH
10050: PPUSH
10051: PPUSH
10052: PPUSH
10053: PPUSH
10054: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10055: LD_ADDR_VAR 0 4
10059: PUSH
10060: LD_INT 11
10062: PUSH
10063: LD_INT 12
10065: PUSH
10066: EMPTY
10067: LIST
10068: LIST
10069: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10070: LD_ADDR_VAR 0 3
10074: PUSH
10075: LD_INT 11550
10077: PUSH
10078: LD_INT 10150
10080: PUSH
10081: LD_INT 9800
10083: PUSH
10084: LD_INT 9450
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_OWVAR 67
10097: ARRAY
10098: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10099: LD_ADDR_VAR 0 6
10103: PUSH
10104: LD_INT 70
10106: PUSH
10107: LD_INT 118
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 78
10116: PUSH
10117: LD_INT 31
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: PUSH
10124: EMPTY
10125: LIST
10126: LIST
10127: ST_TO_ADDR
// repeat if missionStage = 2 then
10128: LD_EXP 15
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10147
// wait ( 1 1$30 ) else
10138: LD_INT 3150
10140: PPUSH
10141: CALL_OW 67
10145: GO 10156
// wait ( time ) ;
10147: LD_VAR 0 3
10151: PPUSH
10152: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10156: LD_EXP 15
10160: PUSH
10161: LD_INT 6
10163: EQUAL
10164: IFTRUE 10176
10166: PUSH
10167: LD_OWVAR 67
10171: PUSH
10172: LD_INT 2
10174: GREATER
10175: OR
10176: IFFALSE 10204
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10178: LD_INT 51
10180: PPUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 2
10186: PPUSH
10187: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10191: LD_INT 57
10193: PPUSH
10194: LD_INT 6
10196: PPUSH
10197: LD_INT 2
10199: PPUSH
10200: CALL_OW 322
// end ; if missionStage = 8 then
10204: LD_EXP 15
10208: PUSH
10209: LD_INT 8
10211: EQUAL
10212: IFFALSE 10240
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10214: LD_INT 52
10216: PPUSH
10217: LD_INT 6
10219: PPUSH
10220: LD_INT 2
10222: PPUSH
10223: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10227: LD_INT 58
10229: PPUSH
10230: LD_INT 6
10232: PPUSH
10233: LD_INT 2
10235: PPUSH
10236: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 4
10247: EQUAL
10248: IFTRUE 10260
10250: PUSH
10251: LD_EXP 15
10255: PUSH
10256: LD_INT 10
10258: EQUAL
10259: OR
10260: IFFALSE 10288
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10262: LD_INT 53
10264: PPUSH
10265: LD_INT 6
10267: PPUSH
10268: LD_INT 2
10270: PPUSH
10271: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10275: LD_INT 59
10277: PPUSH
10278: LD_INT 6
10280: PPUSH
10281: LD_INT 2
10283: PPUSH
10284: CALL_OW 322
// end ; if activeAttacks then
10288: LD_EXP 16
10292: IFFALSE 10797
// begin if missionStage = 2 then
10294: LD_EXP 15
10298: PUSH
10299: LD_INT 2
10301: EQUAL
10302: IFFALSE 10312
// strength := 1 ;
10304: LD_ADDR_VAR 0 5
10308: PUSH
10309: LD_INT 1
10311: ST_TO_ADDR
// if missionStage > 2 then
10312: LD_EXP 15
10316: PUSH
10317: LD_INT 2
10319: GREATER
10320: IFFALSE 10330
// strength := 2 ;
10322: LD_ADDR_VAR 0 5
10326: PUSH
10327: LD_INT 2
10329: ST_TO_ADDR
// if missionStage > 6 then
10330: LD_EXP 15
10334: PUSH
10335: LD_INT 6
10337: GREATER
10338: IFFALSE 10348
// strength := 3 ;
10340: LD_ADDR_VAR 0 5
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// if missionStage > 10 then
10348: LD_EXP 15
10352: PUSH
10353: LD_INT 10
10355: GREATER
10356: IFFALSE 10366
// strength := 4 ;
10358: LD_ADDR_VAR 0 5
10362: PUSH
10363: LD_INT 4
10365: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10366: LD_ADDR_VAR 0 2
10370: PUSH
10371: LD_VAR 0 5
10375: PPUSH
10376: CALL 8855 0 1
10380: ST_TO_ADDR
// for i in tmp do
10381: LD_ADDR_VAR 0 1
10385: PUSH
10386: LD_VAR 0 2
10390: PUSH
10391: FOR_IN
10392: IFFALSE 10666
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_VAR 0 4
10403: PUSH
10404: LD_INT 1
10406: PPUSH
10407: LD_INT 2
10409: PPUSH
10410: CALL_OW 12
10414: ARRAY
10415: PPUSH
10416: LD_INT 0
10418: PPUSH
10419: CALL_OW 49
// if i = sewiVeh then
10423: LD_VAR 0 1
10427: PUSH
10428: LD_EXP 75
10432: EQUAL
10433: IFFALSE 10486
// begin uc_side := 6 ;
10435: LD_ADDR_OWVAR 20
10439: PUSH
10440: LD_INT 6
10442: ST_TO_ADDR
// uc_nation := nation_russian ;
10443: LD_ADDR_OWVAR 21
10447: PUSH
10448: LD_INT 3
10450: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10451: LD_ADDR_EXP 74
10455: PUSH
10456: LD_STRING Vsevolod
10458: PPUSH
10459: LD_INT 0
10461: PPUSH
10462: LD_STRING 
10464: PPUSH
10465: CALL 70939 0 3
10469: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10470: LD_EXP 74
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 52
// end else
10484: GO 10567
// if GetControl ( i ) = control_manual then
10486: LD_VAR 0 1
10490: PPUSH
10491: CALL_OW 263
10495: PUSH
10496: LD_INT 1
10498: EQUAL
10499: IFFALSE 10567
// begin uc_side := 6 ;
10501: LD_ADDR_OWVAR 20
10505: PUSH
10506: LD_INT 6
10508: ST_TO_ADDR
// uc_nation := 3 ;
10509: LD_ADDR_OWVAR 21
10513: PUSH
10514: LD_INT 3
10516: ST_TO_ADDR
// hc_gallery :=  ;
10517: LD_ADDR_OWVAR 33
10521: PUSH
10522: LD_STRING 
10524: ST_TO_ADDR
// hc_name :=  ;
10525: LD_ADDR_OWVAR 26
10529: PUSH
10530: LD_STRING 
10532: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10533: LD_INT 0
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: LD_INT 10
10541: PPUSH
10542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10546: CALL_OW 44
10550: PPUSH
10551: LD_VAR 0 1
10555: PPUSH
10556: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10560: LD_INT 10
10562: PPUSH
10563: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10567: LD_INT 1
10569: PPUSH
10570: LD_INT 3
10572: PPUSH
10573: CALL_OW 12
10577: PUSH
10578: LD_INT 1
10580: DOUBLE
10581: EQUAL
10582: IFTRUE 10586
10584: GO 10604
10586: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10587: LD_VAR 0 1
10591: PPUSH
10592: LD_INT 111
10594: PPUSH
10595: LD_INT 197
10597: PPUSH
10598: CALL_OW 111
10602: GO 10657
10604: LD_INT 2
10606: DOUBLE
10607: EQUAL
10608: IFTRUE 10612
10610: GO 10630
10612: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_INT 91
10620: PPUSH
10621: LD_INT 165
10623: PPUSH
10624: CALL_OW 111
10628: GO 10657
10630: LD_INT 3
10632: DOUBLE
10633: EQUAL
10634: IFTRUE 10638
10636: GO 10656
10638: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10639: LD_VAR 0 1
10643: PPUSH
10644: LD_INT 137
10646: PPUSH
10647: LD_INT 157
10649: PPUSH
10650: CALL_OW 111
10654: GO 10657
10656: POP
// wait ( 0 0$2 ) ;
10657: LD_INT 70
10659: PPUSH
10660: CALL_OW 67
// end ;
10664: GO 10391
10666: POP
10667: POP
// repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10675: LD_ADDR_VAR 0 1
10679: PUSH
10680: LD_VAR 0 2
10684: PPUSH
10685: LD_INT 50
10687: PUSH
10688: EMPTY
10689: LIST
10690: PPUSH
10691: CALL_OW 72
10695: PUSH
10696: FOR_IN
10697: IFFALSE 10756
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10699: LD_VAR 0 1
10703: PPUSH
10704: LD_INT 108
10706: PUSH
10707: LD_INT 153
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 105
10716: PUSH
10717: LD_INT 149
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: LD_INT 85
10726: PUSH
10727: LD_INT 131
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: PUSH
10734: LD_INT 64
10736: PUSH
10737: LD_INT 105
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL 111837 0 2
10754: GO 10696
10756: POP
10757: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_INT 3
10765: PUSH
10766: LD_INT 34
10768: PUSH
10769: LD_INT 49
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: PUSH
10780: LD_INT 50
10782: PUSH
10783: EMPTY
10784: LIST
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PPUSH
10790: CALL_OW 72
10794: NOT
10795: IFFALSE 10668
// end ; until russianDestroyed ;
10797: LD_EXP 21
10801: IFFALSE 10128
// end ;
10803: PPOPN 6
10805: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10806: LD_EXP 21
10810: NOT
10811: IFFALSE 10823
10813: PUSH
10814: LD_EXP 15
10818: PUSH
10819: LD_INT 6
10821: GREATEREQUAL
10822: AND
10823: IFFALSE 11864
10825: GO 10827
10827: DISABLE
10828: LD_INT 0
10830: PPUSH
10831: PPUSH
10832: PPUSH
10833: PPUSH
10834: PPUSH
// begin enable ;
10835: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10836: LD_INT 22
10838: PUSH
10839: LD_INT 3
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 30
10848: PUSH
10849: LD_INT 3
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 69
10864: NOT
10865: IFFALSE 10869
// exit ;
10867: GO 11864
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10869: LD_ADDR_VAR 0 4
10873: PUSH
10874: LD_INT 22
10876: PUSH
10877: LD_INT 3
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PUSH
10884: LD_INT 30
10886: PUSH
10887: LD_INT 34
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PPUSH
10898: CALL_OW 69
10902: ST_TO_ADDR
// if Prob ( 40 ) then
10903: LD_INT 40
10905: PPUSH
10906: CALL_OW 13
10910: IFFALSE 11056
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10912: LD_INT 2
10914: PPUSH
10915: LD_INT 22
10917: PUSH
10918: LD_INT 3
10920: PUSH
10921: LD_INT 3
10923: PUSH
10924: LD_INT 49
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 22
10935: PUSH
10936: LD_INT 3
10938: PUSH
10939: LD_INT 3
10941: PUSH
10942: LD_INT 49
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 22
10953: PUSH
10954: LD_INT 3
10956: PUSH
10957: LD_INT 3
10959: PUSH
10960: LD_INT 49
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: PUSH
10969: LD_INT 24
10971: PUSH
10972: LD_INT 3
10974: PUSH
10975: LD_INT 3
10977: PUSH
10978: LD_INT 46
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: LIST
10985: LIST
10986: PUSH
10987: LD_INT 24
10989: PUSH
10990: LD_INT 3
10992: PUSH
10993: LD_INT 3
10995: PUSH
10996: LD_INT 46
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: PUSH
11005: LD_INT 24
11007: PUSH
11008: LD_INT 3
11010: PUSH
11011: LD_INT 3
11013: PUSH
11014: LD_INT 46
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: PUSH
11023: LD_INT 24
11025: PUSH
11026: LD_INT 3
11028: PUSH
11029: LD_INT 3
11031: PUSH
11032: LD_INT 46
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: PPUSH
11050: CALL 64415 0 2
// end else
11054: GO 11198
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11056: LD_INT 2
11058: PPUSH
11059: LD_INT 24
11061: PUSH
11062: LD_INT 3
11064: PUSH
11065: LD_INT 3
11067: PUSH
11068: LD_INT 47
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: PUSH
11077: LD_INT 24
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 3
11085: PUSH
11086: LD_INT 47
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: PUSH
11095: LD_INT 24
11097: PUSH
11098: LD_INT 3
11100: PUSH
11101: LD_INT 3
11103: PUSH
11104: LD_INT 47
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: PUSH
11113: LD_INT 24
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 3
11121: PUSH
11122: LD_INT 46
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 24
11133: PUSH
11134: LD_INT 3
11136: PUSH
11137: LD_INT 3
11139: PUSH
11140: LD_INT 46
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: LIST
11147: LIST
11148: PUSH
11149: LD_INT 24
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 46
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: PUSH
11167: LD_INT 24
11169: PUSH
11170: LD_INT 3
11172: PUSH
11173: LD_INT 3
11175: PUSH
11176: LD_INT 46
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
11198: LD_INT 4200
11200: PPUSH
11201: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11205: LD_ADDR_VAR 0 2
11209: PUSH
11210: LD_INT 22
11212: PUSH
11213: LD_INT 3
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 23
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 2
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: LD_INT 3
11242: PUSH
11243: LD_INT 34
11245: PUSH
11246: LD_INT 48
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: PUSH
11257: LD_INT 3
11259: PUSH
11260: LD_INT 34
11262: PUSH
11263: LD_INT 51
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 3
11276: PUSH
11277: LD_INT 34
11279: PUSH
11280: LD_INT 52
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: EMPTY
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: PPUSH
11299: CALL_OW 69
11303: PUSH
11304: LD_EXP 124
11308: PUSH
11309: LD_INT 2
11311: ARRAY
11312: DIFF
11313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11314: LD_ADDR_EXP 121
11318: PUSH
11319: LD_EXP 121
11323: PPUSH
11324: LD_INT 2
11326: PPUSH
11327: LD_EXP 121
11331: PUSH
11332: LD_INT 2
11334: ARRAY
11335: PUSH
11336: LD_VAR 0 2
11340: DIFF
11341: PPUSH
11342: CALL_OW 1
11346: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11347: LD_ADDR_VAR 0 3
11351: PUSH
11352: LD_INT 0
11354: PPUSH
11355: LD_INT 1
11357: PPUSH
11358: CALL_OW 12
11362: ST_TO_ADDR
// p := 0 ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// if target then
11371: LD_VAR 0 3
11375: IFFALSE 11526
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11377: LD_ADDR_VAR 0 2
11381: PUSH
11382: LD_VAR 0 2
11386: PPUSH
11387: LD_INT 50
11389: PUSH
11390: EMPTY
11391: LIST
11392: PPUSH
11393: CALL_OW 72
11397: ST_TO_ADDR
// for i in tmp do
11398: LD_ADDR_VAR 0 1
11402: PUSH
11403: LD_VAR 0 2
11407: PUSH
11408: FOR_IN
11409: IFFALSE 11449
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11411: LD_VAR 0 1
11415: PPUSH
11416: LD_INT 139
11418: PPUSH
11419: LD_INT 89
11421: PPUSH
11422: CALL_OW 297
11426: PUSH
11427: LD_INT 9
11429: GREATER
11430: IFFALSE 11447
// ComMoveXY ( i , 139 , 89 ) ;
11432: LD_VAR 0 1
11436: PPUSH
11437: LD_INT 139
11439: PPUSH
11440: LD_INT 89
11442: PPUSH
11443: CALL_OW 111
11447: GO 11408
11449: POP
11450: POP
// wait ( 0 0$1 ) ;
11451: LD_INT 35
11453: PPUSH
11454: CALL_OW 67
// p := Inc ( p ) ;
11458: LD_ADDR_VAR 0 5
11462: PUSH
11463: LD_VAR 0 5
11467: PPUSH
11468: CALL 110444 0 1
11472: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11473: LD_VAR 0 2
11477: PPUSH
11478: LD_INT 92
11480: PUSH
11481: LD_INT 139
11483: PUSH
11484: LD_INT 89
11486: PUSH
11487: LD_INT 9
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: PPUSH
11496: CALL_OW 72
11500: PUSH
11501: LD_VAR 0 2
11505: PUSH
11506: LD_INT 1
11508: MINUS
11509: GREATEREQUAL
11510: IFTRUE 11522
11512: PUSH
11513: LD_VAR 0 5
11517: PUSH
11518: LD_INT 60
11520: GREATER
11521: OR
11522: IFFALSE 11377
// end else
11524: GO 11691
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11526: LD_VAR 0 2
11530: PPUSH
11531: LD_VAR 0 4
11535: PUSH
11536: LD_INT 1
11538: ARRAY
11539: PPUSH
11540: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11544: LD_ADDR_VAR 0 2
11548: PUSH
11549: LD_VAR 0 2
11553: PPUSH
11554: LD_INT 50
11556: PUSH
11557: EMPTY
11558: LIST
11559: PPUSH
11560: CALL_OW 72
11564: ST_TO_ADDR
// for i in tmp do
11565: LD_ADDR_VAR 0 1
11569: PUSH
11570: LD_VAR 0 2
11574: PUSH
11575: FOR_IN
11576: IFFALSE 11616
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11578: LD_VAR 0 1
11582: PPUSH
11583: LD_INT 124
11585: PPUSH
11586: LD_INT 139
11588: PPUSH
11589: CALL_OW 297
11593: PUSH
11594: LD_INT 9
11596: GREATER
11597: IFFALSE 11614
// ComMoveXY ( i , 124 , 139 ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_INT 124
11606: PPUSH
11607: LD_INT 139
11609: PPUSH
11610: CALL_OW 111
11614: GO 11575
11616: POP
11617: POP
// wait ( 0 0$1 ) ;
11618: LD_INT 35
11620: PPUSH
11621: CALL_OW 67
// p := Inc ( p ) ;
11625: LD_ADDR_VAR 0 5
11629: PUSH
11630: LD_VAR 0 5
11634: PPUSH
11635: CALL 110444 0 1
11639: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11640: LD_VAR 0 2
11644: PPUSH
11645: LD_INT 92
11647: PUSH
11648: LD_INT 124
11650: PUSH
11651: LD_INT 139
11653: PUSH
11654: LD_INT 9
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: PPUSH
11663: CALL_OW 72
11667: PUSH
11668: LD_VAR 0 2
11672: PUSH
11673: LD_INT 1
11675: MINUS
11676: GREATEREQUAL
11677: IFTRUE 11689
11679: PUSH
11680: LD_VAR 0 5
11684: PUSH
11685: LD_INT 60
11687: GREATER
11688: OR
11689: IFFALSE 11544
// end ; repeat wait ( 0 0$1 ) ;
11691: LD_INT 35
11693: PPUSH
11694: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11698: LD_ADDR_VAR 0 2
11702: PUSH
11703: LD_VAR 0 2
11707: PPUSH
11708: LD_INT 50
11710: PUSH
11711: EMPTY
11712: LIST
11713: PPUSH
11714: CALL_OW 72
11718: ST_TO_ADDR
// for i in tmp do
11719: LD_ADDR_VAR 0 1
11723: PUSH
11724: LD_VAR 0 2
11728: PUSH
11729: FOR_IN
11730: IFFALSE 11855
// begin if GetWeapon ( i ) = ru_time_lapser then
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 264
11741: PUSH
11742: LD_INT 49
11744: EQUAL
11745: IFFALSE 11801
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11747: LD_VAR 0 1
11751: PPUSH
11752: LD_INT 2
11754: PUSH
11755: LD_INT 22
11757: PUSH
11758: LD_INT 1
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 22
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: LIST
11779: PPUSH
11780: CALL_OW 69
11784: PPUSH
11785: LD_VAR 0 1
11789: PPUSH
11790: CALL_OW 74
11794: PPUSH
11795: CALL_OW 112
11799: GO 11853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 22
11821: PUSH
11822: LD_INT 8
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: PPUSH
11834: CALL_OW 69
11838: PPUSH
11839: LD_VAR 0 1
11843: PPUSH
11844: CALL_OW 74
11848: PPUSH
11849: CALL_OW 115
// end ;
11853: GO 11729
11855: POP
11856: POP
// until not tmp ;
11857: LD_VAR 0 2
11861: NOT
11862: IFFALSE 11691
// end ;
11864: PPOPN 5
11866: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11867: LD_EXP 15
11871: PUSH
11872: LD_INT 7
11874: GREATEREQUAL
11875: IFFALSE 11887
11877: PUSH
11878: LD_OWVAR 67
11882: PUSH
11883: LD_INT 1
11885: GREATER
11886: AND
11887: IFFALSE 12179
11889: GO 11891
11891: DISABLE
11892: LD_INT 0
11894: PPUSH
11895: PPUSH
11896: PPUSH
// begin ruMobile := [ ] ;
11897: LD_ADDR_EXP 78
11901: PUSH
11902: EMPTY
11903: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11904: LD_ADDR_VAR 0 1
11908: PUSH
11909: DOUBLE
11910: LD_INT 1
11912: DEC
11913: ST_TO_ADDR
11914: LD_INT 4
11916: PUSH
11917: LD_INT 5
11919: PUSH
11920: LD_INT 6
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PUSH
11928: LD_OWVAR 67
11932: PUSH
11933: LD_INT 1
11935: MINUS
11936: ARRAY
11937: PUSH
11938: FOR_TO
11939: IFFALSE 12177
// begin uc_side := 3 ;
11941: LD_ADDR_OWVAR 20
11945: PUSH
11946: LD_INT 3
11948: ST_TO_ADDR
// uc_nation := 1 ;
11949: LD_ADDR_OWVAR 21
11953: PUSH
11954: LD_INT 1
11956: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11957: LD_INT 5
11959: PPUSH
11960: LD_INT 3
11962: PPUSH
11963: LD_INT 1
11965: PPUSH
11966: LD_INT 9
11968: PUSH
11969: LD_INT 7
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: LD_VAR 0 1
11980: PUSH
11981: LD_INT 2
11983: MOD
11984: PUSH
11985: LD_INT 1
11987: PLUS
11988: ARRAY
11989: PPUSH
11990: LD_INT 100
11992: PPUSH
11993: CALL 75901 0 5
// veh := CreateVehicle ;
11997: LD_ADDR_VAR 0 2
12001: PUSH
12002: CALL_OW 45
12006: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
12007: LD_VAR 0 2
12011: PPUSH
12012: LD_INT 3
12014: PPUSH
12015: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
12019: LD_VAR 0 2
12023: PPUSH
12024: LD_INT 29
12026: PPUSH
12027: LD_INT 0
12029: PPUSH
12030: CALL_OW 49
// uc_nation := 3 ;
12034: LD_ADDR_OWVAR 21
12038: PUSH
12039: LD_INT 3
12041: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12042: LD_INT 0
12044: PPUSH
12045: LD_INT 10
12047: PPUSH
12048: CALL_OW 383
// un := CreateHuman ;
12052: LD_ADDR_VAR 0 3
12056: PUSH
12057: CALL_OW 44
12061: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12062: LD_VAR 0 3
12066: PPUSH
12067: LD_INT 105
12069: PPUSH
12070: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12074: LD_VAR 0 3
12078: PPUSH
12079: LD_INT 3
12081: PPUSH
12082: CALL_OW 259
12086: PUSH
12087: LD_INT 8
12089: PUSH
12090: LD_INT 9
12092: PUSH
12093: LD_INT 10
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: LIST
12100: PUSH
12101: LD_OWVAR 67
12105: ARRAY
12106: LESS
12107: IFFALSE 12141
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12109: LD_VAR 0 3
12113: PPUSH
12114: LD_INT 3
12116: PPUSH
12117: LD_INT 8
12119: PUSH
12120: LD_INT 9
12122: PUSH
12123: LD_INT 10
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: PUSH
12131: LD_OWVAR 67
12135: ARRAY
12136: PPUSH
12137: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12141: LD_VAR 0 3
12145: PPUSH
12146: LD_VAR 0 2
12150: PPUSH
12151: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12155: LD_ADDR_EXP 78
12159: PUSH
12160: LD_EXP 78
12164: PPUSH
12165: LD_VAR 0 2
12169: PPUSH
12170: CALL 109071 0 2
12174: ST_TO_ADDR
// end ;
12175: GO 11938
12177: POP
12178: POP
// end ;
12179: PPOPN 3
12181: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12182: LD_EXP 78
12186: IFFALSE 12697
12188: GO 12190
12190: DISABLE
12191: LD_INT 0
12193: PPUSH
12194: PPUSH
12195: PPUSH
// begin enable ;
12196: ENABLE
// if not ruMobile then
12197: LD_EXP 78
12201: NOT
12202: IFFALSE 12207
// begin disable ;
12204: DISABLE
// exit ;
12205: GO 12697
// end ; for i in ruMobile do
12207: LD_ADDR_VAR 0 1
12211: PUSH
12212: LD_EXP 78
12216: PUSH
12217: FOR_IN
12218: IFFALSE 12695
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12220: LD_VAR 0 1
12224: PPUSH
12225: CALL_OW 302
12229: NOT
12230: IFTRUE 12247
12232: PUSH
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL_OW 255
12242: PUSH
12243: LD_INT 3
12245: NONEQUAL
12246: OR
12247: IFFALSE 12267
// begin ruMobile := ruMobile diff i ;
12249: LD_ADDR_EXP 78
12253: PUSH
12254: LD_EXP 78
12258: PUSH
12259: LD_VAR 0 1
12263: DIFF
12264: ST_TO_ADDR
// continue ;
12265: GO 12217
// end ; if GetTag ( i ) = 300 then
12267: LD_VAR 0 1
12271: PPUSH
12272: CALL_OW 110
12276: PUSH
12277: LD_INT 300
12279: EQUAL
12280: IFFALSE 12330
// begin ComMoveXY ( i , 160 , 81 ) ;
12282: LD_VAR 0 1
12286: PPUSH
12287: LD_INT 160
12289: PPUSH
12290: LD_INT 81
12292: PPUSH
12293: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_INT 160
12304: PPUSH
12305: LD_INT 81
12307: PPUSH
12308: CALL_OW 297
12312: PUSH
12313: LD_INT 8
12315: LESS
12316: IFFALSE 12330
// SetTag ( i , 301 ) ;
12318: LD_VAR 0 1
12322: PPUSH
12323: LD_INT 301
12325: PPUSH
12326: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12330: LD_VAR 0 1
12334: PPUSH
12335: CALL_OW 110
12339: PUSH
12340: LD_INT 301
12342: EQUAL
12343: IFFALSE 12386
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12345: LD_VAR 0 1
12349: PPUSH
12350: LD_INT 33
12352: PPUSH
12353: CALL_OW 308
12357: NOT
12358: IFFALSE 12374
// ComMoveToArea ( i , ruMobileParkingArea ) else
12360: LD_VAR 0 1
12364: PPUSH
12365: LD_INT 33
12367: PPUSH
12368: CALL_OW 113
12372: GO 12386
// SetTag ( i , 302 ) ;
12374: LD_VAR 0 1
12378: PPUSH
12379: LD_INT 302
12381: PPUSH
12382: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12386: LD_VAR 0 1
12390: PPUSH
12391: CALL_OW 110
12395: PUSH
12396: LD_INT 302
12398: EQUAL
12399: IFFALSE 12529
// begin if GetLives ( i ) < 1000 then
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 256
12410: PUSH
12411: LD_INT 1000
12413: LESS
12414: IFFALSE 12506
// begin if not IsDrivenBy ( i ) then
12416: LD_VAR 0 1
12420: PPUSH
12421: CALL_OW 311
12425: NOT
12426: IFFALSE 12430
// continue ;
12428: GO 12217
// mech := IsDrivenBy ( i ) ;
12430: LD_ADDR_VAR 0 2
12434: PUSH
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 311
12444: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12445: LD_VAR 0 2
12449: PPUSH
12450: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12454: LD_VAR 0 2
12458: PPUSH
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12468: LD_INT 35
12470: PPUSH
12471: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12475: LD_VAR 0 1
12479: PPUSH
12480: CALL_OW 256
12484: PUSH
12485: LD_INT 1000
12487: EQUAL
12488: IFFALSE 12468
// ComEnterUnit ( mech , i ) ;
12490: LD_VAR 0 2
12494: PPUSH
12495: LD_VAR 0 1
12499: PPUSH
12500: CALL_OW 120
// end else
12504: GO 12529
// if IsDrivenBy ( i ) then
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 311
12515: IFFALSE 12529
// SetTag ( i , 0 ) ;
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 0
12524: PPUSH
12525: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12529: LD_VAR 0 1
12533: PPUSH
12534: CALL_OW 110
12538: PUSH
12539: LD_INT 300
12541: LESS
12542: IFFALSE 12693
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12544: LD_ADDR_VAR 0 3
12548: PUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 81
12554: PUSH
12555: LD_INT 3
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: PPUSH
12562: CALL_OW 70
12566: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12567: LD_VAR 0 1
12571: PPUSH
12572: CALL_OW 256
12576: PUSH
12577: LD_INT 650
12579: LESS
12580: IFFALSE 12605
// begin ComStop ( i ) ;
12582: LD_VAR 0 1
12586: PPUSH
12587: CALL_OW 141
// SetTag ( i , 300 ) ;
12591: LD_VAR 0 1
12595: PPUSH
12596: LD_INT 300
12598: PPUSH
12599: CALL_OW 109
// continue ;
12603: GO 12217
// end ; if enemy then
12605: LD_VAR 0 3
12609: IFFALSE 12649
// begin if not HasTask ( i ) then
12611: LD_VAR 0 1
12615: PPUSH
12616: CALL_OW 314
12620: NOT
12621: IFFALSE 12647
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: LD_VAR 0 3
12632: PPUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 74
12642: PPUSH
12643: CALL_OW 115
// end else
12647: GO 12693
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12649: LD_VAR 0 1
12653: PPUSH
12654: LD_INT 158
12656: PUSH
12657: LD_INT 61
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PUSH
12664: LD_INT 98
12666: PUSH
12667: LD_INT 100
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PUSH
12674: LD_INT 78
12676: PUSH
12677: LD_INT 93
12679: PUSH
12680: EMPTY
12681: LIST
12682: LIST
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL 111837 0 2
// end ; end ;
12693: GO 12217
12695: POP
12696: POP
// end ; end_of_file
12697: PPOPN 3
12699: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12700: LD_INT 0
12702: PPUSH
12703: PPUSH
12704: PPUSH
12705: PPUSH
12706: PPUSH
12707: PPUSH
12708: PPUSH
// if Difficulty = 1 then
12709: LD_OWVAR 67
12713: PUSH
12714: LD_INT 1
12716: EQUAL
12717: IFFALSE 12755
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12719: LD_ADDR_VAR 0 2
12723: PUSH
12724: LD_INT 95
12726: PUSH
12727: LD_INT 34
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: PUSH
12739: FOR_IN
12740: IFFALSE 12753
// RemoveUnit ( i ) ;
12742: LD_VAR 0 2
12746: PPUSH
12747: CALL_OW 64
12751: GO 12739
12753: POP
12754: POP
// SetInvulnrability ( alien , true ) ;
12755: LD_INT 1
12757: PPUSH
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 607
// side := 7 ;
12765: LD_ADDR_VAR 0 5
12769: PUSH
12770: LD_INT 7
12772: ST_TO_ADDR
// uc_side := side ;
12773: LD_ADDR_OWVAR 20
12777: PUSH
12778: LD_VAR 0 5
12782: ST_TO_ADDR
// uc_nation := 1 ;
12783: LD_ADDR_OWVAR 21
12787: PUSH
12788: LD_INT 1
12790: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12791: LD_ADDR_VAR 0 2
12795: PUSH
12796: LD_INT 22
12798: PUSH
12799: LD_VAR 0 5
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 21
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: FOR_IN
12828: IFFALSE 12844
// SetBLevel ( i , 10 ) ;
12830: LD_VAR 0 2
12834: PPUSH
12835: LD_INT 10
12837: PPUSH
12838: CALL_OW 241
12842: GO 12827
12844: POP
12845: POP
// base := GetBase ( al_depot ) ;
12846: LD_ADDR_VAR 0 4
12850: PUSH
12851: LD_INT 2
12853: PPUSH
12854: CALL_OW 274
12858: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12859: LD_ADDR_VAR 0 6
12863: PUSH
12864: LD_INT 22
12866: PUSH
12867: LD_VAR 0 5
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 30
12878: PUSH
12879: LD_INT 34
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PPUSH
12890: CALL_OW 69
12894: ST_TO_ADDR
// if teleport then
12895: LD_VAR 0 6
12899: IFFALSE 12920
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12901: LD_VAR 0 6
12905: PUSH
12906: LD_INT 1
12908: ARRAY
12909: PPUSH
12910: LD_INT 262
12912: PPUSH
12913: LD_INT 119
12915: PPUSH
12916: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12920: LD_VAR 0 4
12924: PPUSH
12925: LD_INT 1
12927: PPUSH
12928: LD_INT 19500
12930: PPUSH
12931: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12935: LD_VAR 0 4
12939: PPUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 200
12945: PPUSH
12946: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12950: LD_VAR 0 4
12954: PPUSH
12955: LD_INT 3
12957: PPUSH
12958: LD_INT 650
12960: PPUSH
12961: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12965: LD_ADDR_EXP 79
12969: PUSH
12970: LD_STRING Roth
12972: PPUSH
12973: CALL_OW 25
12977: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12978: LD_ADDR_EXP 80
12982: PUSH
12983: LD_STRING Simms
12985: PPUSH
12986: LD_EXP 1
12990: NOT
12991: PPUSH
12992: LD_STRING 10c_
12994: PPUSH
12995: CALL 70939 0 3
12999: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
13000: LD_EXP 80
13004: PPUSH
13005: LD_INT 4
13007: PPUSH
13008: CALL_OW 336
// if not Simms then
13012: LD_EXP 80
13016: NOT
13017: IFFALSE 13047
// begin uc_nation := 1 ;
13019: LD_ADDR_OWVAR 21
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
13027: LD_INT 2
13029: PPUSH
13030: LD_INT 10
13032: PPUSH
13033: CALL_OW 384
// Simms := CreateHuman ;
13037: LD_ADDR_EXP 80
13041: PUSH
13042: CALL_OW 44
13046: ST_TO_ADDR
// end ; uc_nation := 3 ;
13047: LD_ADDR_OWVAR 21
13051: PUSH
13052: LD_INT 3
13054: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13055: LD_ADDR_EXP 81
13059: PUSH
13060: LD_STRING Kirilenkova
13062: PPUSH
13063: CALL_OW 25
13067: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13068: LD_ADDR_EXP 95
13072: PUSH
13073: LD_STRING Oblukov
13075: PPUSH
13076: CALL_OW 25
13080: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13081: LD_ADDR_EXP 82
13085: PUSH
13086: LD_STRING Dolgov
13088: PPUSH
13089: CALL_OW 25
13093: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13094: LD_ADDR_EXP 83
13098: PUSH
13099: LD_STRING Petrosyan
13101: PPUSH
13102: CALL_OW 25
13106: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13107: LD_ADDR_EXP 94
13111: PUSH
13112: LD_STRING Scholtze
13114: PPUSH
13115: CALL_OW 25
13119: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13120: LD_ADDR_EXP 93
13124: PUSH
13125: LD_STRING Kapitsova
13127: PPUSH
13128: CALL_OW 25
13132: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13133: LD_ADDR_EXP 84
13137: PUSH
13138: LD_STRING Petrovova
13140: PPUSH
13141: CALL_OW 25
13145: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13146: LD_ADDR_EXP 85
13150: PUSH
13151: LD_STRING Kuzmov
13153: PPUSH
13154: CALL_OW 25
13158: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13159: LD_ADDR_EXP 92
13163: PUSH
13164: LD_STRING Karamazov
13166: PPUSH
13167: CALL_OW 25
13171: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13172: LD_STRING 13_Lipshchin_1
13174: PPUSH
13175: LD_INT 0
13177: PPUSH
13178: CALL_OW 30
13182: IFFALSE 13197
// Lipshchin := NewCharacter ( Lipshchin ) ;
13184: LD_ADDR_EXP 86
13188: PUSH
13189: LD_STRING Lipshchin
13191: PPUSH
13192: CALL_OW 25
13196: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13197: LD_STRING 13_Titov_1
13199: PPUSH
13200: LD_INT 0
13202: PPUSH
13203: CALL_OW 30
13207: IFFALSE 13222
// Titov := NewCharacter ( Titov ) ;
13209: LD_ADDR_EXP 88
13213: PUSH
13214: LD_STRING Titov
13216: PPUSH
13217: CALL_OW 25
13221: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13222: LD_STRING 13_Gnyevko_1
13224: PPUSH
13225: LD_INT 0
13227: PPUSH
13228: CALL_OW 30
13232: IFFALSE 13247
// Gnyevko := NewCharacter ( Gnyevko ) ;
13234: LD_ADDR_EXP 87
13238: PUSH
13239: LD_STRING Gnyevko
13241: PPUSH
13242: CALL_OW 25
13246: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13247: LD_STRING 13_Xavier_1
13249: PPUSH
13250: LD_INT 0
13252: PPUSH
13253: CALL_OW 30
13257: IFFALSE 13272
// Xavier := NewCharacter ( Xavier2 ) ;
13259: LD_ADDR_EXP 89
13263: PUSH
13264: LD_STRING Xavier2
13266: PPUSH
13267: CALL_OW 25
13271: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13272: LD_STRING 13_Belkov_1
13274: PPUSH
13275: LD_INT 0
13277: PPUSH
13278: CALL_OW 30
13282: IFFALSE 13297
// Belkov := NewCharacter ( Belkov ) ;
13284: LD_ADDR_EXP 90
13288: PUSH
13289: LD_STRING Belkov
13291: PPUSH
13292: CALL_OW 25
13296: ST_TO_ADDR
// if not BurlakStatus then
13297: LD_EXP 9
13301: NOT
13302: IFFALSE 13317
// Burlak = NewCharacter ( Burlak ) ;
13304: LD_ADDR_EXP 91
13308: PUSH
13309: LD_STRING Burlak
13311: PPUSH
13312: CALL_OW 25
13316: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_EXP 79
13326: PUSH
13327: LD_EXP 81
13331: PUSH
13332: LD_EXP 95
13336: PUSH
13337: LD_EXP 82
13341: PUSH
13342: LD_EXP 83
13346: PUSH
13347: LD_EXP 94
13351: PUSH
13352: LD_EXP 93
13356: PUSH
13357: LD_EXP 84
13361: PUSH
13362: LD_EXP 85
13366: PUSH
13367: LD_EXP 92
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: ST_TO_ADDR
// if Simms then
13384: LD_EXP 80
13388: IFFALSE 13406
// tmp := tmp ^ Simms ;
13390: LD_ADDR_VAR 0 3
13394: PUSH
13395: LD_VAR 0 3
13399: PUSH
13400: LD_EXP 80
13404: ADD
13405: ST_TO_ADDR
// if Titov then
13406: LD_EXP 88
13410: IFFALSE 13428
// tmp := tmp ^ Titov ;
13412: LD_ADDR_VAR 0 3
13416: PUSH
13417: LD_VAR 0 3
13421: PUSH
13422: LD_EXP 88
13426: ADD
13427: ST_TO_ADDR
// if Lipshchin then
13428: LD_EXP 86
13432: IFFALSE 13450
// tmp := tmp ^ Lipshchin ;
13434: LD_ADDR_VAR 0 3
13438: PUSH
13439: LD_VAR 0 3
13443: PUSH
13444: LD_EXP 86
13448: ADD
13449: ST_TO_ADDR
// if Gnyevko then
13450: LD_EXP 87
13454: IFFALSE 13472
// tmp := tmp ^ Gnyevko ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_EXP 87
13470: ADD
13471: ST_TO_ADDR
// if Xavier then
13472: LD_EXP 89
13476: IFFALSE 13494
// tmp := tmp ^ Xavier ;
13478: LD_ADDR_VAR 0 3
13482: PUSH
13483: LD_VAR 0 3
13487: PUSH
13488: LD_EXP 89
13492: ADD
13493: ST_TO_ADDR
// if Belkov then
13494: LD_EXP 90
13498: IFFALSE 13516
// tmp := tmp ^ Belkov ;
13500: LD_ADDR_VAR 0 3
13504: PUSH
13505: LD_VAR 0 3
13509: PUSH
13510: LD_EXP 90
13514: ADD
13515: ST_TO_ADDR
// if Burlak then
13516: LD_EXP 91
13520: IFFALSE 13538
// tmp := tmp ^ Burlak ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_EXP 91
13536: ADD
13537: ST_TO_ADDR
// for i = 1 to 11 do
13538: LD_ADDR_VAR 0 2
13542: PUSH
13543: DOUBLE
13544: LD_INT 1
13546: DEC
13547: ST_TO_ADDR
13548: LD_INT 11
13550: PUSH
13551: FOR_TO
13552: IFFALSE 13620
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13554: LD_ADDR_OWVAR 21
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: LD_INT 3
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: LD_INT 1
13571: PPUSH
13572: LD_INT 2
13574: PPUSH
13575: CALL_OW 12
13579: ARRAY
13580: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13581: LD_INT 0
13583: PPUSH
13584: LD_INT 1
13586: PPUSH
13587: LD_INT 4
13589: PPUSH
13590: CALL_OW 12
13594: PPUSH
13595: LD_INT 10
13597: PPUSH
13598: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13602: LD_ADDR_VAR 0 3
13606: PUSH
13607: LD_VAR 0 3
13611: PUSH
13612: CALL_OW 44
13616: ADD
13617: ST_TO_ADDR
// end ;
13618: GO 13551
13620: POP
13621: POP
// for i in tmp do
13622: LD_ADDR_VAR 0 2
13626: PUSH
13627: LD_VAR 0 3
13631: PUSH
13632: FOR_IN
13633: IFFALSE 13658
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13635: LD_VAR 0 2
13639: PPUSH
13640: LD_INT 260
13642: PPUSH
13643: LD_INT 235
13645: PPUSH
13646: LD_INT 8
13648: PPUSH
13649: LD_INT 0
13651: PPUSH
13652: CALL_OW 50
13656: GO 13632
13658: POP
13659: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13660: LD_ADDR_EXP 102
13664: PUSH
13665: LD_EXP 102
13669: PPUSH
13670: LD_INT 1
13672: PPUSH
13673: LD_INT 22
13675: PUSH
13676: LD_VAR 0 5
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: LD_INT 3
13687: PUSH
13688: LD_INT 21
13690: PUSH
13691: LD_INT 2
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PPUSH
13706: CALL_OW 69
13710: PUSH
13711: LD_EXP 79
13715: PUSH
13716: LD_EXP 80
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: DIFF
13725: PPUSH
13726: CALL_OW 1
13730: ST_TO_ADDR
// uc_side := 0 ;
13731: LD_ADDR_OWVAR 20
13735: PUSH
13736: LD_INT 0
13738: ST_TO_ADDR
// uc_nation := 0 ;
13739: LD_ADDR_OWVAR 21
13743: PUSH
13744: LD_INT 0
13746: ST_TO_ADDR
// for i = 1 to 5 do
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: DOUBLE
13753: LD_INT 1
13755: DEC
13756: ST_TO_ADDR
13757: LD_INT 5
13759: PUSH
13760: FOR_TO
13761: IFFALSE 13798
// begin InitHc ;
13763: CALL_OW 19
// hc_class := class_apeman ;
13767: LD_ADDR_OWVAR 28
13771: PUSH
13772: LD_INT 12
13774: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13775: CALL_OW 44
13779: PPUSH
13780: LD_INT 299
13782: PPUSH
13783: LD_INT 229
13785: PPUSH
13786: LD_INT 10
13788: PPUSH
13789: LD_INT 0
13791: PPUSH
13792: CALL_OW 50
// end ;
13796: GO 13760
13798: POP
13799: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13800: LD_EXP 79
13804: PPUSH
13805: LD_INT 259
13807: PPUSH
13808: LD_INT 235
13810: PPUSH
13811: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13815: LD_EXP 79
13819: PPUSH
13820: LD_INT 262
13822: PPUSH
13823: LD_INT 235
13825: PPUSH
13826: CALL_OW 178
// if Simms then
13830: LD_EXP 80
13834: IFFALSE 13865
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13836: LD_EXP 80
13840: PPUSH
13841: LD_INT 262
13843: PPUSH
13844: LD_INT 235
13846: PPUSH
13847: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13851: LD_EXP 80
13855: PPUSH
13856: LD_EXP 79
13860: PPUSH
13861: CALL_OW 179
// end ; uc_side := 7 ;
13865: LD_ADDR_OWVAR 20
13869: PUSH
13870: LD_INT 7
13872: ST_TO_ADDR
// uc_nation := 1 ;
13873: LD_ADDR_OWVAR 21
13877: PUSH
13878: LD_INT 1
13880: ST_TO_ADDR
// bc_type := b_control_tower ;
13881: LD_ADDR_OWVAR 42
13885: PUSH
13886: LD_INT 36
13888: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13889: LD_ADDR_VAR 0 7
13893: PUSH
13894: LD_INT 268
13896: PPUSH
13897: LD_INT 251
13899: PPUSH
13900: LD_INT 4
13902: PPUSH
13903: CALL_OW 47
13907: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13908: LD_INT 0
13910: PPUSH
13911: LD_INT 10
13913: PPUSH
13914: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13918: CALL_OW 44
13922: PPUSH
13923: LD_VAR 0 7
13927: PPUSH
13928: CALL_OW 52
// end ;
13932: LD_VAR 0 1
13936: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13937: LD_EXP 31
13941: IFFALSE 13950
13943: PUSH
13944: LD_EXP 23
13948: NOT
13949: AND
13950: IFFALSE 13982
13952: PUSH
13953: LD_INT 22
13955: PUSH
13956: LD_INT 7
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PUSH
13963: LD_INT 30
13965: PUSH
13966: LD_INT 8
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PPUSH
13977: CALL_OW 69
13981: AND
13982: IFFALSE 14210
13984: GO 13986
13986: DISABLE
13987: LD_INT 0
13989: PPUSH
13990: PPUSH
13991: PPUSH
// begin enable ;
13992: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13993: LD_ADDR_VAR 0 2
13997: PUSH
13998: LD_INT 81
14000: PUSH
14001: LD_INT 7
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: LD_INT 2
14010: PUSH
14011: LD_INT 32
14013: PUSH
14014: LD_INT 3
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: PUSH
14021: LD_INT 30
14023: PUSH
14024: LD_INT 30
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: LD_INT 30
14033: PUSH
14034: LD_INT 28
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 34
14043: PUSH
14044: LD_INT 49
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 34
14053: PUSH
14054: LD_INT 10
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PUSH
14061: LD_INT 34
14063: PUSH
14064: LD_INT 8
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: PPUSH
14084: CALL_OW 69
14088: ST_TO_ADDR
// if not tmp then
14089: LD_VAR 0 2
14093: NOT
14094: IFFALSE 14098
// exit ;
14096: GO 14210
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_INT 34
14105: PUSH
14106: LD_INT 8
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 72
14117: IFFALSE 14150
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14119: LD_ADDR_VAR 0 3
14123: PUSH
14124: LD_VAR 0 2
14128: PPUSH
14129: LD_INT 34
14131: PUSH
14132: LD_INT 8
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 72
14143: PUSH
14144: LD_INT 1
14146: ARRAY
14147: ST_TO_ADDR
14148: GO 14174
// target := tmp [ rand ( 1 , tmp ) ] ;
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_VAR 0 2
14159: PUSH
14160: LD_INT 1
14162: PPUSH
14163: LD_VAR 0 2
14167: PPUSH
14168: CALL_OW 12
14172: ARRAY
14173: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14174: LD_VAR 0 3
14178: PPUSH
14179: CALL_OW 255
14183: PUSH
14184: LD_INT 1
14186: EQUAL
14187: IFFALSE 14198
// CenterNowOnUnits ( target ) ;
14189: LD_VAR 0 3
14193: PPUSH
14194: CALL_OW 87
// SetLives ( target , 0 ) ;
14198: LD_VAR 0 3
14202: PPUSH
14203: LD_INT 0
14205: PPUSH
14206: CALL_OW 234
// end ;
14210: PPOPN 3
14212: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14213: LD_EXP 23
14217: NOT
14218: IFFALSE 14226
14220: PUSH
14221: LD_EXP 31
14225: AND
14226: IFFALSE 14744
14228: GO 14230
14230: DISABLE
14231: LD_INT 0
14233: PPUSH
14234: PPUSH
14235: PPUSH
// begin uc_side := 7 ;
14236: LD_ADDR_OWVAR 20
14240: PUSH
14241: LD_INT 7
14243: ST_TO_ADDR
// uc_nation := 1 ;
14244: LD_ADDR_OWVAR 21
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14252: LD_ADDR_VAR 0 3
14256: PUSH
14257: LD_INT 125
14259: PUSH
14260: LD_INT 163
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: PUSH
14267: LD_INT 185
14269: PUSH
14270: LD_INT 168
14272: PUSH
14273: EMPTY
14274: LIST
14275: LIST
14276: PUSH
14277: LD_INT 111
14279: PUSH
14280: LD_INT 97
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: PUSH
14287: LD_INT 94
14289: PUSH
14290: LD_INT 114
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: PPUSH
14303: CALL 109176 0 1
14307: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14308: LD_ADDR_EXP 96
14312: PUSH
14313: EMPTY
14314: ST_TO_ADDR
// for i = 1 to Difficulty do
14315: LD_ADDR_VAR 0 1
14319: PUSH
14320: DOUBLE
14321: LD_INT 1
14323: DEC
14324: ST_TO_ADDR
14325: LD_OWVAR 67
14329: PUSH
14330: FOR_TO
14331: IFFALSE 14489
// begin InitHc ;
14333: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 8
14342: PPUSH
14343: CALL_OW 381
// un := CreateHuman ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: CALL_OW 44
14356: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14357: LD_VAR 0 2
14361: PPUSH
14362: LD_INT 258
14364: PPUSH
14365: LD_INT 267
14367: PPUSH
14368: LD_INT 4
14370: PPUSH
14371: LD_INT 0
14373: PPUSH
14374: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14378: LD_ADDR_EXP 96
14382: PUSH
14383: LD_EXP 96
14387: PUSH
14388: LD_VAR 0 2
14392: UNION
14393: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14394: LD_VAR 0 2
14398: PPUSH
14399: LD_VAR 0 3
14403: PUSH
14404: LD_VAR 0 1
14408: ARRAY
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: LD_VAR 0 3
14418: PUSH
14419: LD_VAR 0 1
14423: ARRAY
14424: PUSH
14425: LD_INT 2
14427: ARRAY
14428: PPUSH
14429: LD_INT 4
14431: PPUSH
14432: LD_INT 1
14434: PPUSH
14435: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14439: LD_VAR 0 2
14443: PPUSH
14444: LD_VAR 0 3
14448: PUSH
14449: LD_VAR 0 1
14453: ARRAY
14454: PUSH
14455: LD_INT 1
14457: ARRAY
14458: PPUSH
14459: LD_VAR 0 3
14463: PUSH
14464: LD_VAR 0 1
14468: ARRAY
14469: PUSH
14470: LD_INT 2
14472: ARRAY
14473: PPUSH
14474: CALL_OW 171
// AddComInvisible ( un ) ;
14478: LD_VAR 0 2
14482: PPUSH
14483: CALL_OW 212
// end ;
14487: GO 14330
14489: POP
14490: POP
// repeat wait ( 0 0$45 ) ;
14491: LD_INT 1575
14493: PPUSH
14494: CALL_OW 67
// for i in allianceSpecialForce do
14498: LD_ADDR_VAR 0 1
14502: PUSH
14503: LD_EXP 96
14507: PUSH
14508: FOR_IN
14509: IFFALSE 14727
// begin if IsInvisible ( i ) then
14511: LD_VAR 0 1
14515: PPUSH
14516: CALL_OW 571
14520: IFFALSE 14696
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: LD_INT 22
14529: PUSH
14530: LD_INT 1
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 50
14539: PUSH
14540: EMPTY
14541: LIST
14542: PUSH
14543: LD_INT 56
14545: PUSH
14546: EMPTY
14547: LIST
14548: PUSH
14549: LD_INT 91
14551: PUSH
14552: LD_VAR 0 1
14556: PUSH
14557: LD_INT 25
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 25
14570: PUSH
14571: LD_INT 1
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PUSH
14578: LD_INT 25
14580: PUSH
14581: LD_INT 2
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 25
14590: PUSH
14591: LD_INT 3
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: LD_INT 25
14600: PUSH
14601: LD_INT 4
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 25
14610: PUSH
14611: LD_INT 5
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 8
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: ST_TO_ADDR
// if not tmp then
14649: LD_VAR 0 3
14653: NOT
14654: IFFALSE 14658
// continue ;
14656: GO 14508
// if Prob ( 30 * Difficulty ) then
14658: LD_INT 30
14660: PUSH
14661: LD_OWVAR 67
14665: MUL
14666: PPUSH
14667: CALL_OW 13
14671: IFFALSE 14696
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14673: LD_VAR 0 3
14677: PUSH
14678: LD_INT 1
14680: PPUSH
14681: LD_VAR 0 3
14685: PPUSH
14686: CALL_OW 12
14690: ARRAY
14691: PPUSH
14692: CALL 35627 0 1
// end ; if IsDead ( i ) then
14696: LD_VAR 0 1
14700: PPUSH
14701: CALL_OW 301
14705: IFFALSE 14725
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14707: LD_ADDR_EXP 96
14711: PUSH
14712: LD_EXP 96
14716: PUSH
14717: LD_VAR 0 1
14721: DIFF
14722: ST_TO_ADDR
// continue ;
14723: GO 14508
// end ; end ;
14725: GO 14508
14727: POP
14728: POP
// until allianceDestroyed or not allianceSpecialForce ;
14729: LD_EXP 23
14733: IFTRUE 14742
14735: PUSH
14736: LD_EXP 96
14740: NOT
14741: OR
14742: IFFALSE 14491
// end ;
14744: PPOPN 3
14746: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14747: LD_EXP 31
14751: IFFALSE 14801
14753: PUSH
14754: LD_INT 22
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 2
14766: PUSH
14767: LD_INT 35
14769: PUSH
14770: LD_INT 8
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 34
14779: PUSH
14780: LD_INT 8
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: PPUSH
14796: CALL_OW 69
14800: AND
14801: IFFALSE 15201
14803: GO 14805
14805: DISABLE
14806: LD_INT 0
14808: PPUSH
14809: PPUSH
14810: PPUSH
14811: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14812: LD_ADDR_VAR 0 1
14816: PUSH
14817: DOUBLE
14818: LD_INT 1
14820: DEC
14821: ST_TO_ADDR
14822: LD_INT 6
14824: PUSH
14825: LD_INT 8
14827: PUSH
14828: LD_INT 10
14830: PUSH
14831: LD_INT 12
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: PUSH
14840: LD_OWVAR 67
14844: ARRAY
14845: PUSH
14846: FOR_TO
14847: IFFALSE 15039
// begin uc_side := 7 ;
14849: LD_ADDR_OWVAR 20
14853: PUSH
14854: LD_INT 7
14856: ST_TO_ADDR
// uc_nation := 1 ;
14857: LD_ADDR_OWVAR 21
14861: PUSH
14862: LD_INT 1
14864: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14865: LD_INT 5
14867: PPUSH
14868: LD_INT 3
14870: PPUSH
14871: LD_INT 2
14873: PUSH
14874: LD_INT 3
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 1
14883: PPUSH
14884: LD_INT 2
14886: PPUSH
14887: CALL_OW 12
14891: ARRAY
14892: PPUSH
14893: LD_INT 6
14895: PUSH
14896: LD_INT 9
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 1
14905: PPUSH
14906: LD_INT 2
14908: PPUSH
14909: CALL_OW 12
14913: ARRAY
14914: PPUSH
14915: LD_INT 100
14917: PPUSH
14918: CALL 75901 0 5
// un := CreateVehicle ;
14922: LD_ADDR_VAR 0 2
14926: PUSH
14927: CALL_OW 45
14931: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14932: LD_VAR 0 2
14936: PPUSH
14937: LD_INT 4
14939: PPUSH
14940: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14944: LD_VAR 0 2
14948: PPUSH
14949: LD_INT 307
14951: PPUSH
14952: LD_INT 219
14954: PPUSH
14955: LD_INT 6
14957: PPUSH
14958: LD_INT 0
14960: PPUSH
14961: CALL_OW 50
// if GetControl ( un ) = control_remote then
14965: LD_VAR 0 2
14969: PPUSH
14970: CALL_OW 263
14974: PUSH
14975: LD_INT 2
14977: EQUAL
14978: IFFALSE 14989
// Connect ( un ) ;
14980: LD_VAR 0 2
14984: PPUSH
14985: CALL 79383 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14989: LD_VAR 0 2
14993: PPUSH
14994: LD_INT 124
14996: PPUSH
14997: LD_INT 92
14999: PPUSH
15000: LD_INT 12
15002: PPUSH
15003: LD_INT 1
15005: PPUSH
15006: CALL_OW 483
// tmp := Join ( tmp , un ) ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_VAR 0 3
15019: PPUSH
15020: LD_VAR 0 2
15024: PPUSH
15025: CALL 109071 0 2
15029: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
15030: LD_INT 10
15032: PPUSH
15033: CALL_OW 67
// end ;
15037: GO 14846
15039: POP
15040: POP
// repeat wait ( 0 0$2 ) ;
15041: LD_INT 70
15043: PPUSH
15044: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
15048: LD_ADDR_VAR 0 4
15052: PUSH
15053: LD_INT 22
15055: PUSH
15056: LD_INT 1
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 34
15065: PUSH
15066: LD_INT 8
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PPUSH
15077: CALL_OW 69
15081: ST_TO_ADDR
// if not e then
15082: LD_VAR 0 4
15086: NOT
15087: IFFALSE 15123
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15089: LD_ADDR_VAR 0 4
15093: PUSH
15094: LD_INT 22
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 21
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PPUSH
15118: CALL_OW 69
15122: ST_TO_ADDR
// for i in tmp do
15123: LD_ADDR_VAR 0 1
15127: PUSH
15128: LD_VAR 0 3
15132: PUSH
15133: FOR_IN
15134: IFFALSE 15192
// if not IsOK ( i ) then
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 302
15145: NOT
15146: IFFALSE 15166
// tmp := tmp diff i else
15148: LD_ADDR_VAR 0 3
15152: PUSH
15153: LD_VAR 0 3
15157: PUSH
15158: LD_VAR 0 1
15162: DIFF
15163: ST_TO_ADDR
15164: GO 15190
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 4
15175: PPUSH
15176: LD_VAR 0 1
15180: PPUSH
15181: CALL_OW 74
15185: PPUSH
15186: CALL_OW 115
15190: GO 15133
15192: POP
15193: POP
// until not tmp ;
15194: LD_VAR 0 3
15198: NOT
15199: IFFALSE 15041
// end ;
15201: PPOPN 4
15203: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15204: LD_EXP 23
15208: NOT
15209: IFFALSE 15217
15211: PUSH
15212: LD_EXP 31
15216: AND
15217: IFFALSE 16295
15219: GO 15221
15221: DISABLE
15222: LD_INT 0
15224: PPUSH
15225: PPUSH
15226: PPUSH
15227: PPUSH
15228: PPUSH
// begin enable ;
15229: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15230: LD_INT 22
15232: PUSH
15233: LD_INT 7
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 30
15242: PUSH
15243: LD_INT 3
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: PPUSH
15254: CALL_OW 69
15258: NOT
15259: IFFALSE 15263
// exit ;
15261: GO 16295
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15263: LD_ADDR_VAR 0 4
15267: PUSH
15268: LD_INT 22
15270: PUSH
15271: LD_INT 7
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PUSH
15278: LD_INT 30
15280: PUSH
15281: LD_INT 34
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PPUSH
15292: CALL_OW 69
15296: ST_TO_ADDR
// if Prob ( 40 ) then
15297: LD_INT 40
15299: PPUSH
15300: CALL_OW 13
15304: IFFALSE 15450
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15306: LD_INT 1
15308: PPUSH
15309: LD_INT 5
15311: PUSH
15312: LD_INT 3
15314: PUSH
15315: LD_INT 2
15317: PUSH
15318: LD_INT 6
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PUSH
15327: LD_INT 5
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: LD_INT 2
15335: PUSH
15336: LD_INT 6
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: PUSH
15345: LD_INT 5
15347: PUSH
15348: LD_INT 3
15350: PUSH
15351: LD_INT 2
15353: PUSH
15354: LD_INT 6
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: LD_INT 5
15365: PUSH
15366: LD_INT 3
15368: PUSH
15369: LD_INT 2
15371: PUSH
15372: LD_INT 9
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 24
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: LD_INT 3
15389: PUSH
15390: LD_INT 45
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 24
15401: PUSH
15402: LD_INT 3
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: LD_INT 47
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PUSH
15417: LD_INT 24
15419: PUSH
15420: LD_INT 3
15422: PUSH
15423: LD_INT 3
15425: PUSH
15426: LD_INT 45
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL 64415 0 2
// end else
15448: GO 15592
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15450: LD_INT 1
15452: PPUSH
15453: LD_INT 24
15455: PUSH
15456: LD_INT 3
15458: PUSH
15459: LD_INT 3
15461: PUSH
15462: LD_INT 47
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: PUSH
15471: LD_INT 24
15473: PUSH
15474: LD_INT 3
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: LD_INT 47
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: PUSH
15489: LD_INT 5
15491: PUSH
15492: LD_INT 3
15494: PUSH
15495: LD_INT 2
15497: PUSH
15498: LD_INT 9
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: PUSH
15507: LD_INT 5
15509: PUSH
15510: LD_INT 3
15512: PUSH
15513: LD_INT 2
15515: PUSH
15516: LD_INT 9
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 3
15530: PUSH
15531: LD_INT 2
15533: PUSH
15534: LD_INT 9
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: PUSH
15543: LD_INT 24
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: LD_INT 45
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 24
15563: PUSH
15564: LD_INT 1
15566: PUSH
15567: LD_INT 3
15569: PUSH
15570: LD_INT 45
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: PPUSH
15588: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
15592: LD_INT 4200
15594: PPUSH
15595: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15599: LD_ADDR_VAR 0 2
15603: PUSH
15604: LD_INT 22
15606: PUSH
15607: LD_INT 7
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: LD_INT 21
15616: PUSH
15617: LD_INT 2
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PUSH
15624: LD_INT 3
15626: PUSH
15627: LD_INT 34
15629: PUSH
15630: LD_INT 13
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: PUSH
15641: LD_INT 3
15643: PUSH
15644: LD_INT 34
15646: PUSH
15647: LD_INT 12
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: PUSH
15658: LD_INT 3
15660: PUSH
15661: LD_INT 34
15663: PUSH
15664: LD_INT 51
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: PUSH
15675: LD_INT 3
15677: PUSH
15678: LD_INT 34
15680: PUSH
15681: LD_INT 52
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: PUSH
15705: LD_EXP 124
15709: PUSH
15710: LD_INT 1
15712: ARRAY
15713: DIFF
15714: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15715: LD_ADDR_EXP 121
15719: PUSH
15720: LD_EXP 121
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_EXP 121
15732: PUSH
15733: LD_INT 1
15735: ARRAY
15736: PUSH
15737: LD_VAR 0 2
15741: DIFF
15742: PPUSH
15743: CALL_OW 1
15747: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15748: LD_ADDR_VAR 0 3
15752: PUSH
15753: LD_INT 0
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: CALL_OW 12
15763: ST_TO_ADDR
// p := 0 ;
15764: LD_ADDR_VAR 0 5
15768: PUSH
15769: LD_INT 0
15771: ST_TO_ADDR
// if target then
15772: LD_VAR 0 3
15776: IFFALSE 15969
// begin for i in tmp do
15778: LD_ADDR_VAR 0 1
15782: PUSH
15783: LD_VAR 0 2
15787: PUSH
15788: FOR_IN
15789: IFFALSE 15814
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15791: LD_VAR 0 1
15795: PPUSH
15796: LD_INT 179
15798: PPUSH
15799: LD_INT 209
15801: PPUSH
15802: LD_INT 8
15804: PPUSH
15805: LD_INT 1
15807: PPUSH
15808: CALL_OW 483
15812: GO 15788
15814: POP
15815: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15816: LD_ADDR_VAR 0 2
15820: PUSH
15821: LD_VAR 0 2
15825: PPUSH
15826: LD_INT 24
15828: PUSH
15829: LD_INT 250
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PPUSH
15836: CALL_OW 72
15840: ST_TO_ADDR
// for i in tmp do
15841: LD_ADDR_VAR 0 1
15845: PUSH
15846: LD_VAR 0 2
15850: PUSH
15851: FOR_IN
15852: IFFALSE 15892
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15854: LD_VAR 0 1
15858: PPUSH
15859: LD_INT 179
15861: PPUSH
15862: LD_INT 209
15864: PPUSH
15865: CALL_OW 297
15869: PUSH
15870: LD_INT 9
15872: GREATER
15873: IFFALSE 15890
// ComMoveXY ( i , 179 , 209 ) ;
15875: LD_VAR 0 1
15879: PPUSH
15880: LD_INT 179
15882: PPUSH
15883: LD_INT 209
15885: PPUSH
15886: CALL_OW 111
15890: GO 15851
15892: POP
15893: POP
// wait ( 0 0$1 ) ;
15894: LD_INT 35
15896: PPUSH
15897: CALL_OW 67
// p := Inc ( p ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 5
15910: PPUSH
15911: CALL 110444 0 1
15915: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15916: LD_VAR 0 2
15920: PPUSH
15921: LD_INT 92
15923: PUSH
15924: LD_INT 179
15926: PUSH
15927: LD_INT 209
15929: PUSH
15930: LD_INT 9
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PUSH
15944: LD_VAR 0 2
15948: PUSH
15949: LD_INT 1
15951: MINUS
15952: GREATEREQUAL
15953: IFTRUE 15965
15955: PUSH
15956: LD_VAR 0 5
15960: PUSH
15961: LD_INT 30
15963: GREATER
15964: OR
15965: IFFALSE 15816
// end else
15967: GO 16158
// begin for i in tmp do
15969: LD_ADDR_VAR 0 1
15973: PUSH
15974: LD_VAR 0 2
15978: PUSH
15979: FOR_IN
15980: IFFALSE 16005
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 285
15989: PPUSH
15990: LD_INT 163
15992: PPUSH
15993: LD_INT 8
15995: PPUSH
15996: LD_INT 1
15998: PPUSH
15999: CALL_OW 483
16003: GO 15979
16005: POP
16006: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_VAR 0 2
16016: PPUSH
16017: LD_INT 24
16019: PUSH
16020: LD_INT 250
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 72
16031: ST_TO_ADDR
// for i in tmp do
16032: LD_ADDR_VAR 0 1
16036: PUSH
16037: LD_VAR 0 2
16041: PUSH
16042: FOR_IN
16043: IFFALSE 16083
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 285
16052: PPUSH
16053: LD_INT 163
16055: PPUSH
16056: CALL_OW 297
16060: PUSH
16061: LD_INT 9
16063: GREATER
16064: IFFALSE 16081
// ComMoveXY ( i , 285 , 163 ) ;
16066: LD_VAR 0 1
16070: PPUSH
16071: LD_INT 285
16073: PPUSH
16074: LD_INT 163
16076: PPUSH
16077: CALL_OW 111
16081: GO 16042
16083: POP
16084: POP
// wait ( 0 0$1 ) ;
16085: LD_INT 35
16087: PPUSH
16088: CALL_OW 67
// p := Inc ( p ) ;
16092: LD_ADDR_VAR 0 5
16096: PUSH
16097: LD_VAR 0 5
16101: PPUSH
16102: CALL 110444 0 1
16106: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16107: LD_VAR 0 2
16111: PPUSH
16112: LD_INT 92
16114: PUSH
16115: LD_INT 285
16117: PUSH
16118: LD_INT 163
16120: PUSH
16121: LD_INT 9
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: LIST
16128: LIST
16129: PPUSH
16130: CALL_OW 72
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: LD_INT 1
16142: MINUS
16143: GREATEREQUAL
16144: IFTRUE 16156
16146: PUSH
16147: LD_VAR 0 5
16151: PUSH
16152: LD_INT 30
16154: GREATER
16155: OR
16156: IFFALSE 16007
// end ; repeat wait ( 0 0$1 ) ;
16158: LD_INT 35
16160: PPUSH
16161: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16165: LD_ADDR_VAR 0 2
16169: PUSH
16170: LD_VAR 0 2
16174: PPUSH
16175: LD_INT 50
16177: PUSH
16178: EMPTY
16179: LIST
16180: PPUSH
16181: CALL_OW 72
16185: ST_TO_ADDR
// for i in tmp do
16186: LD_ADDR_VAR 0 1
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: FOR_IN
16197: IFFALSE 16286
// if GetWeapon ( i ) = ru_time_lapser then
16199: LD_VAR 0 1
16203: PPUSH
16204: CALL_OW 264
16208: PUSH
16209: LD_INT 49
16211: EQUAL
16212: IFFALSE 16250
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16214: LD_VAR 0 1
16218: PPUSH
16219: LD_INT 81
16221: PUSH
16222: LD_INT 7
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 69
16233: PPUSH
16234: LD_VAR 0 1
16238: PPUSH
16239: CALL_OW 74
16243: PPUSH
16244: CALL_OW 112
16248: GO 16284
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16250: LD_VAR 0 1
16254: PPUSH
16255: LD_INT 81
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PPUSH
16265: CALL_OW 69
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: CALL_OW 74
16279: PPUSH
16280: CALL_OW 115
16284: GO 16196
16286: POP
16287: POP
// until not tmp ;
16288: LD_VAR 0 2
16292: NOT
16293: IFFALSE 16158
// end ;
16295: PPOPN 5
16297: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16298: LD_EXP 31
16302: IFFALSE 16315
16304: PUSH
16305: LD_EXP 79
16309: PPUSH
16310: CALL_OW 302
16314: AND
16315: IFFALSE 16327
16317: PUSH
16318: LD_OWVAR 67
16322: PUSH
16323: LD_INT 2
16325: GREATER
16326: AND
16327: IFFALSE 16427
16329: GO 16331
16331: DISABLE
// begin enable ;
16332: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16333: LD_EXP 79
16337: PPUSH
16338: LD_INT 245
16340: PPUSH
16341: LD_INT 234
16343: PPUSH
16344: CALL_OW 297
16348: PUSH
16349: LD_INT 6
16351: GREATER
16352: IFFALSE 16371
// ComMoveXY ( Roth , 245 , 234 ) else
16354: LD_EXP 79
16358: PPUSH
16359: LD_INT 245
16361: PPUSH
16362: LD_INT 234
16364: PPUSH
16365: CALL_OW 111
16369: GO 16427
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16371: LD_EXP 79
16375: PPUSH
16376: LD_INT 259
16378: PUSH
16379: LD_INT 235
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 252
16388: PUSH
16389: LD_INT 209
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 275
16398: PUSH
16399: LD_INT 235
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: EMPTY
16407: LIST
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 1
16413: PPUSH
16414: LD_INT 3
16416: PPUSH
16417: CALL_OW 12
16421: ARRAY
16422: PPUSH
16423: CALL 113399 0 2
// end ; end_of_file
16427: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
// missionStage := 13 ;
16434: LD_ADDR_EXP 15
16438: PUSH
16439: LD_INT 13
16441: ST_TO_ADDR
// uc_side := 2 ;
16442: LD_ADDR_OWVAR 20
16446: PUSH
16447: LD_INT 2
16449: ST_TO_ADDR
// uc_nation := 2 ;
16450: LD_ADDR_OWVAR 21
16454: PUSH
16455: LD_INT 2
16457: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16458: LD_ADDR_EXP 97
16462: PUSH
16463: LD_STRING Omar
16465: PPUSH
16466: CALL_OW 25
16470: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16471: LD_EXP 97
16475: PPUSH
16476: LD_INT 4
16478: PPUSH
16479: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16483: LD_EXP 97
16487: PPUSH
16488: LD_INT 242
16490: PPUSH
16491: LD_INT 75
16493: PPUSH
16494: LD_INT 0
16496: PPUSH
16497: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16501: LD_ADDR_EXP 98
16505: PUSH
16506: LD_STRING Heike
16508: PPUSH
16509: CALL_OW 25
16513: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16514: LD_INT 14
16516: PPUSH
16517: LD_INT 3
16519: PPUSH
16520: LD_INT 1
16522: PPUSH
16523: LD_INT 27
16525: PPUSH
16526: LD_INT 100
16528: PPUSH
16529: CALL 75901 0 5
// veh := CreateVehicle ;
16533: LD_ADDR_VAR 0 3
16537: PUSH
16538: CALL_OW 45
16542: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16543: LD_VAR 0 3
16547: PPUSH
16548: LD_INT 2
16550: NEG
16551: PPUSH
16552: CALL_OW 242
// SetDir ( veh , 4 ) ;
16556: LD_VAR 0 3
16560: PPUSH
16561: LD_INT 4
16563: PPUSH
16564: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16568: LD_VAR 0 3
16572: PPUSH
16573: LD_INT 241
16575: PPUSH
16576: LD_INT 72
16578: PPUSH
16579: LD_INT 0
16581: PPUSH
16582: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16586: LD_EXP 98
16590: PPUSH
16591: LD_VAR 0 3
16595: PPUSH
16596: CALL_OW 52
// if KhatamStatus then
16600: LD_EXP 8
16604: IFFALSE 16667
// begin Khatam := NewCharacter ( Khatam ) ;
16606: LD_ADDR_EXP 99
16610: PUSH
16611: LD_STRING Khatam
16613: PPUSH
16614: CALL_OW 25
16618: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16619: LD_EXP 99
16623: PPUSH
16624: LD_INT 245
16626: PPUSH
16627: LD_INT 78
16629: PPUSH
16630: LD_INT 3
16632: PPUSH
16633: LD_INT 0
16635: PPUSH
16636: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16640: LD_EXP 99
16644: PPUSH
16645: LD_INT 4
16647: PPUSH
16648: LD_INT 10
16650: PPUSH
16651: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16655: LD_EXP 99
16659: PPUSH
16660: LD_INT 4
16662: PPUSH
16663: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16667: LD_ADDR_VAR 0 2
16671: PUSH
16672: DOUBLE
16673: LD_INT 1
16675: DEC
16676: ST_TO_ADDR
16677: LD_INT 2
16679: PUSH
16680: LD_INT 2
16682: PUSH
16683: LD_INT 3
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: PUSH
16695: LD_OWVAR 67
16699: ARRAY
16700: PUSH
16701: FOR_TO
16702: IFFALSE 16768
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16704: LD_INT 0
16706: PPUSH
16707: LD_INT 6
16709: PUSH
16710: LD_OWVAR 67
16714: PLUS
16715: PPUSH
16716: CALL_OW 384
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 4
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16730: LD_VAR 0 4
16734: PPUSH
16735: LD_INT 28
16737: PUSH
16738: LD_INT 29
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: PUSH
16745: LD_VAR 0 2
16749: PUSH
16750: LD_INT 2
16752: MOD
16753: PUSH
16754: LD_INT 1
16756: PLUS
16757: ARRAY
16758: PPUSH
16759: LD_INT 0
16761: PPUSH
16762: CALL_OW 49
// end ;
16766: GO 16701
16768: POP
16769: POP
// for i = 1 to 6 do
16770: LD_ADDR_VAR 0 2
16774: PUSH
16775: DOUBLE
16776: LD_INT 1
16778: DEC
16779: ST_TO_ADDR
16780: LD_INT 6
16782: PUSH
16783: FOR_TO
16784: IFFALSE 16829
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16786: LD_INT 0
16788: PPUSH
16789: LD_INT 6
16791: PUSH
16792: LD_OWVAR 67
16796: PLUS
16797: PPUSH
16798: CALL_OW 381
// un := CreateHuman ;
16802: LD_ADDR_VAR 0 4
16806: PUSH
16807: CALL_OW 44
16811: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16812: LD_VAR 0 4
16816: PPUSH
16817: LD_INT 32
16819: PPUSH
16820: LD_INT 0
16822: PPUSH
16823: CALL_OW 49
// end ;
16827: GO 16783
16829: POP
16830: POP
// for i = 1 to 3 do
16831: LD_ADDR_VAR 0 2
16835: PUSH
16836: DOUBLE
16837: LD_INT 1
16839: DEC
16840: ST_TO_ADDR
16841: LD_INT 3
16843: PUSH
16844: FOR_TO
16845: IFFALSE 16893
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16847: LD_INT 0
16849: PPUSH
16850: LD_INT 8
16852: PPUSH
16853: LD_INT 6
16855: PUSH
16856: LD_OWVAR 67
16860: PLUS
16861: PPUSH
16862: CALL_OW 380
// un := CreateHuman ;
16866: LD_ADDR_VAR 0 4
16870: PUSH
16871: CALL_OW 44
16875: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16876: LD_VAR 0 4
16880: PPUSH
16881: LD_INT 32
16883: PPUSH
16884: LD_INT 0
16886: PPUSH
16887: CALL_OW 49
// end ;
16891: GO 16844
16893: POP
16894: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16895: LD_ADDR_VAR 0 2
16899: PUSH
16900: DOUBLE
16901: LD_INT 1
16903: DEC
16904: ST_TO_ADDR
16905: LD_INT 2
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: LD_INT 4
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: LD_OWVAR 67
16927: ARRAY
16928: PUSH
16929: FOR_TO
16930: IFFALSE 17020
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16932: LD_INT 14
16934: PPUSH
16935: LD_INT 2
16937: PPUSH
16938: LD_INT 1
16940: PPUSH
16941: LD_INT 28
16943: PPUSH
16944: LD_INT 80
16946: PPUSH
16947: CALL 75901 0 5
// veh := CreateVehicle ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: CALL_OW 45
16960: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16961: LD_VAR 0 3
16965: PPUSH
16966: LD_INT 3
16968: PPUSH
16969: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16973: LD_VAR 0 3
16977: PPUSH
16978: LD_INT 29
16980: PPUSH
16981: LD_INT 0
16983: PPUSH
16984: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16988: LD_INT 0
16990: PPUSH
16991: LD_INT 6
16993: PUSH
16994: LD_OWVAR 67
16998: PLUS
16999: PPUSH
17000: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17004: CALL_OW 44
17008: PPUSH
17009: LD_VAR 0 3
17013: PPUSH
17014: CALL_OW 52
// end ;
17018: GO 16929
17020: POP
17021: POP
// for i = 1 to 5 + Difficulty do
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: DOUBLE
17028: LD_INT 1
17030: DEC
17031: ST_TO_ADDR
17032: LD_INT 5
17034: PUSH
17035: LD_OWVAR 67
17039: PLUS
17040: PUSH
17041: FOR_TO
17042: IFFALSE 17169
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
17044: LD_INT 14
17046: PPUSH
17047: LD_INT 1
17049: PPUSH
17050: LD_INT 3
17052: PPUSH
17053: CALL_OW 12
17057: PPUSH
17058: LD_INT 1
17060: PPUSH
17061: LD_INT 28
17063: PUSH
17064: LD_INT 26
17066: PUSH
17067: LD_INT 27
17069: PUSH
17070: LD_INT 25
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: PUSH
17079: LD_VAR 0 2
17083: PUSH
17084: LD_INT 4
17086: MOD
17087: PUSH
17088: LD_INT 1
17090: PLUS
17091: ARRAY
17092: PPUSH
17093: LD_INT 80
17095: PPUSH
17096: CALL 75901 0 5
// veh := CreateVehicle ;
17100: LD_ADDR_VAR 0 3
17104: PUSH
17105: CALL_OW 45
17109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17110: LD_VAR 0 3
17114: PPUSH
17115: LD_INT 4
17117: PPUSH
17118: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17122: LD_VAR 0 3
17126: PPUSH
17127: LD_INT 28
17129: PPUSH
17130: LD_INT 0
17132: PPUSH
17133: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17137: LD_INT 0
17139: PPUSH
17140: LD_INT 6
17142: PUSH
17143: LD_OWVAR 67
17147: PLUS
17148: PPUSH
17149: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17153: CALL_OW 44
17157: PPUSH
17158: LD_VAR 0 3
17162: PPUSH
17163: CALL_OW 52
// end ;
17167: GO 17041
17169: POP
17170: POP
// for i = 1 to Difficulty do
17171: LD_ADDR_VAR 0 2
17175: PUSH
17176: DOUBLE
17177: LD_INT 1
17179: DEC
17180: ST_TO_ADDR
17181: LD_OWVAR 67
17185: PUSH
17186: FOR_TO
17187: IFFALSE 17247
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17189: LD_INT 14
17191: PPUSH
17192: LD_INT 3
17194: PPUSH
17195: LD_INT 5
17197: PPUSH
17198: LD_INT 29
17200: PPUSH
17201: LD_INT 80
17203: PPUSH
17204: CALL 75901 0 5
// veh := CreateVehicle ;
17208: LD_ADDR_VAR 0 3
17212: PUSH
17213: CALL_OW 45
17217: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17218: LD_VAR 0 3
17222: PPUSH
17223: LD_INT 4
17225: PPUSH
17226: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17230: LD_VAR 0 3
17234: PPUSH
17235: LD_INT 28
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: CALL_OW 49
// end ;
17245: GO 17186
17247: POP
17248: POP
// end ;
17249: LD_VAR 0 1
17253: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PPUSH
17264: CALL_OW 69
17268: IFFALSE 17647
17270: GO 17272
17272: DISABLE
17273: LD_INT 0
17275: PPUSH
17276: PPUSH
17277: PPUSH
17278: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17279: LD_ADDR_VAR 0 3
17283: PUSH
17284: LD_INT 22
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PUSH
17294: LD_INT 25
17296: PUSH
17297: LD_INT 4
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PPUSH
17308: CALL_OW 69
17312: PUSH
17313: LD_EXP 99
17317: DIFF
17318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17319: LD_ADDR_VAR 0 2
17323: PUSH
17324: LD_INT 22
17326: PUSH
17327: LD_INT 2
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 69
17338: PUSH
17339: LD_EXP 99
17343: PUSH
17344: LD_VAR 0 3
17348: UNION
17349: DIFF
17350: ST_TO_ADDR
// if Khatam then
17351: LD_EXP 99
17355: IFFALSE 17372
// ComMoveXY ( Khatam , 211 , 92 ) ;
17357: LD_EXP 99
17361: PPUSH
17362: LD_INT 211
17364: PPUSH
17365: LD_INT 92
17367: PPUSH
17368: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17372: LD_INT 197
17374: PPUSH
17375: LD_INT 80
17377: PPUSH
17378: LD_INT 2
17380: PPUSH
17381: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17385: LD_INT 213
17387: PPUSH
17388: LD_INT 90
17390: PPUSH
17391: LD_INT 2
17393: PPUSH
17394: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17398: LD_INT 215
17400: PPUSH
17401: LD_INT 129
17403: PPUSH
17404: LD_INT 2
17406: PPUSH
17407: CALL_OW 441
// if sci then
17411: LD_VAR 0 3
17415: IFFALSE 17436
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17417: LD_VAR 0 3
17421: PUSH
17422: LD_INT 1
17424: ARRAY
17425: PPUSH
17426: LD_INT 197
17428: PPUSH
17429: LD_INT 80
17431: PPUSH
17432: CALL_OW 158
// if sci > 1 then
17436: LD_VAR 0 3
17440: PUSH
17441: LD_INT 1
17443: GREATER
17444: IFFALSE 17465
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17446: LD_VAR 0 3
17450: PUSH
17451: LD_INT 2
17453: ARRAY
17454: PPUSH
17455: LD_INT 213
17457: PPUSH
17458: LD_INT 90
17460: PPUSH
17461: CALL_OW 158
// if sci > 2 then
17465: LD_VAR 0 3
17469: PUSH
17470: LD_INT 2
17472: GREATER
17473: IFFALSE 17494
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17475: LD_VAR 0 3
17479: PUSH
17480: LD_INT 3
17482: ARRAY
17483: PPUSH
17484: LD_INT 215
17486: PPUSH
17487: LD_INT 129
17489: PPUSH
17490: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17494: LD_VAR 0 2
17498: PPUSH
17499: LD_INT 195
17501: PPUSH
17502: LD_INT 102
17504: PPUSH
17505: CALL_OW 114
// wait ( 0 0$5 ) ;
17509: LD_INT 175
17511: PPUSH
17512: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17516: LD_INT 70
17518: PPUSH
17519: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17523: LD_ADDR_VAR 0 4
17527: PUSH
17528: LD_INT 92
17530: PUSH
17531: LD_INT 195
17533: PUSH
17534: LD_INT 102
17536: PUSH
17537: LD_INT 36
17539: PUSH
17540: EMPTY
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: PUSH
17546: LD_INT 22
17548: PUSH
17549: LD_INT 1
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PPUSH
17560: CALL_OW 69
17564: ST_TO_ADDR
// for i in tmp do
17565: LD_ADDR_VAR 0 1
17569: PUSH
17570: LD_VAR 0 2
17574: PUSH
17575: FOR_IN
17576: IFFALSE 17627
// if enemy then
17578: LD_VAR 0 4
17582: IFFALSE 17610
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17584: LD_VAR 0 1
17588: PPUSH
17589: LD_VAR 0 4
17593: PPUSH
17594: LD_VAR 0 1
17598: PPUSH
17599: CALL_OW 74
17603: PPUSH
17604: CALL_OW 115
17608: GO 17625
// ComAgressiveMove ( i , 195 , 102 ) ;
17610: LD_VAR 0 1
17614: PPUSH
17615: LD_INT 195
17617: PPUSH
17618: LD_INT 102
17620: PPUSH
17621: CALL_OW 114
17625: GO 17575
17627: POP
17628: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17629: LD_VAR 0 2
17633: PPUSH
17634: LD_INT 50
17636: PUSH
17637: EMPTY
17638: LIST
17639: PPUSH
17640: CALL_OW 72
17644: NOT
17645: IFFALSE 17516
// end ; end_of_file
17647: PPOPN 4
17649: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad , hasSomethingToSay ; begin
17650: LD_INT 0
17652: PPUSH
17653: PPUSH
17654: PPUSH
17655: PPUSH
17656: PPUSH
17657: PPUSH
17658: PPUSH
17659: PPUSH
17660: PPUSH
17661: PPUSH
// Video ( true ) ;
17662: LD_INT 1
17664: PPUSH
17665: CALL 109043 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17669: LD_ADDR_VAR 0 5
17673: PUSH
17674: LD_INT 7
17676: PPUSH
17677: LD_INT 0
17679: PPUSH
17680: CALL_OW 517
17684: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17685: LD_ADDR_VAR 0 2
17689: PUSH
17690: DOUBLE
17691: LD_INT 1
17693: DEC
17694: ST_TO_ADDR
17695: LD_VAR 0 5
17699: PUSH
17700: LD_INT 1
17702: ARRAY
17703: PUSH
17704: FOR_TO
17705: IFFALSE 17750
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17707: LD_VAR 0 5
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: LD_VAR 0 5
17726: PUSH
17727: LD_INT 2
17729: ARRAY
17730: PUSH
17731: LD_VAR 0 2
17735: ARRAY
17736: PPUSH
17737: LD_INT 1
17739: PPUSH
17740: LD_INT 15
17742: NEG
17743: PPUSH
17744: CALL 108955 0 4
17748: GO 17704
17750: POP
17751: POP
// CenterNowOnUnits ( Powell ) ;
17752: LD_EXP 61
17756: PPUSH
17757: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17761: LD_ADDR_VAR 0 5
17765: PUSH
17766: LD_EXP 59
17770: PUSH
17771: EMPTY
17772: LIST
17773: ST_TO_ADDR
// if GirlNewVeh then
17774: LD_EXP 60
17778: IFFALSE 17796
// tmp := tmp ^ GirlNewVeh ;
17780: LD_ADDR_VAR 0 5
17784: PUSH
17785: LD_VAR 0 5
17789: PUSH
17790: LD_EXP 60
17794: ADD
17795: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17796: LD_VAR 0 5
17800: PPUSH
17801: LD_INT 60
17803: PPUSH
17804: LD_INT 109
17806: PPUSH
17807: CALL_OW 111
// if KappaStatus then
17811: LD_EXP 2
17815: IFFALSE 17867
// begin Say ( JMM , D1nT-JMM-1 ) ;
17817: LD_EXP 40
17821: PPUSH
17822: LD_STRING D1nT-JMM-1
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17829: LD_EXP 61
17833: PPUSH
17834: LD_STRING D1T-Pow-1
17836: PPUSH
17837: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17841: LD_EXP 40
17845: PPUSH
17846: LD_STRING D1T-JMM-2
17848: PPUSH
17849: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17853: LD_EXP 61
17857: PPUSH
17858: LD_STRING D1T-Pow-2
17860: PPUSH
17861: CALL_OW 88
// end else
17865: GO 18073
// if JMMGirlStatus then
17867: LD_EXP 6
17871: IFFALSE 18016
// begin Say ( JMM , D1T-JMM-1 ) ;
17873: LD_EXP 40
17877: PPUSH
17878: LD_STRING D1T-JMM-1
17880: PPUSH
17881: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17885: LD_EXP 61
17889: PPUSH
17890: LD_STRING D1T-Pow-1
17892: PPUSH
17893: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17897: LD_EXP 40
17901: PPUSH
17902: LD_STRING D1T-JMM-3
17904: PPUSH
17905: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17909: LD_EXP 61
17913: PPUSH
17914: LD_STRING D1T-Pow-3
17916: PPUSH
17917: CALL_OW 88
// if JMMGirl then
17921: LD_EXP 7
17925: IFFALSE 18014
// begin case JMMGirl of 1 :
17927: LD_EXP 7
17931: PUSH
17932: LD_INT 1
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17955
17940: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17941: LD_EXP 41
17945: PPUSH
17946: LD_STRING D1T-Joan-3
17948: PPUSH
17949: CALL_OW 88
17953: GO 18002
17955: LD_INT 2
17957: DOUBLE
17958: EQUAL
17959: IFTRUE 17963
17961: GO 17978
17963: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17964: LD_EXP 43
17968: PPUSH
17969: LD_STRING D1T-Lisa-3
17971: PPUSH
17972: CALL_OW 88
17976: GO 18002
17978: LD_INT 3
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18001
17986: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17987: LD_EXP 55
17991: PPUSH
17992: LD_STRING D1T-Con-3
17994: PPUSH
17995: CALL_OW 88
17999: GO 18002
18001: POP
// Say ( Powell , D1T-Pow-4 ) ;
18002: LD_EXP 61
18006: PPUSH
18007: LD_STRING D1T-Pow-4
18009: PPUSH
18010: CALL_OW 88
// end ; end else
18014: GO 18073
// if not FastEnd then
18016: LD_EXP 11
18020: NOT
18021: IFFALSE 18049
// begin Say ( JMM , D1T-JMM-4 ) ;
18023: LD_EXP 40
18027: PPUSH
18028: LD_STRING D1T-JMM-4
18030: PPUSH
18031: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
18035: LD_EXP 61
18039: PPUSH
18040: LD_STRING D1T-Pow-5
18042: PPUSH
18043: CALL_OW 88
// end else
18047: GO 18073
// begin Say ( JMM , D1nT-JMM-1 ) ;
18049: LD_EXP 40
18053: PPUSH
18054: LD_STRING D1nT-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18061: LD_EXP 61
18065: PPUSH
18066: LD_STRING D1nT-Pow-1
18068: PPUSH
18069: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18073: LD_INT 3
18075: PPUSH
18076: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18080: LD_EXP 59
18084: PPUSH
18085: CALL_OW 314
18089: NOT
18090: IFFALSE 18073
// ComExitVehicle ( JMM ) ;
18092: LD_EXP 40
18096: PPUSH
18097: CALL_OW 121
// repeat wait ( 3 ) ;
18101: LD_INT 3
18103: PPUSH
18104: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18108: LD_EXP 40
18112: PPUSH
18113: CALL_OW 310
18117: NOT
18118: IFFALSE 18101
// ComMoveXY ( JMM , 60 , 94 ) ;
18120: LD_EXP 40
18124: PPUSH
18125: LD_INT 60
18127: PPUSH
18128: LD_INT 94
18130: PPUSH
18131: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18135: LD_EXP 40
18139: PPUSH
18140: LD_EXP 61
18144: PPUSH
18145: CALL_OW 179
// if Joan then
18149: LD_EXP 41
18153: IFFALSE 18207
// begin ComExitVehicle ( Joan ) ;
18155: LD_EXP 41
18159: PPUSH
18160: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18164: LD_EXP 41
18168: PPUSH
18169: LD_INT 35
18171: PPUSH
18172: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18176: LD_EXP 41
18180: PPUSH
18181: LD_INT 65
18183: PPUSH
18184: LD_INT 104
18186: PPUSH
18187: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18191: LD_EXP 41
18195: PPUSH
18196: LD_EXP 40
18200: PPUSH
18201: CALL_OW 179
// end else
18205: GO 18345
// if Lisa and JMMGirl = 2 then
18207: LD_EXP 43
18211: IFFALSE 18223
18213: PUSH
18214: LD_EXP 7
18218: PUSH
18219: LD_INT 2
18221: EQUAL
18222: AND
18223: IFFALSE 18277
// begin ComExitVehicle ( Lisa ) ;
18225: LD_EXP 43
18229: PPUSH
18230: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18234: LD_EXP 43
18238: PPUSH
18239: LD_INT 35
18241: PPUSH
18242: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18246: LD_EXP 43
18250: PPUSH
18251: LD_INT 65
18253: PPUSH
18254: LD_INT 104
18256: PPUSH
18257: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18261: LD_EXP 43
18265: PPUSH
18266: LD_EXP 40
18270: PPUSH
18271: CALL_OW 179
// end else
18275: GO 18345
// if Connie and JMMGirl = 3 then
18277: LD_EXP 55
18281: IFFALSE 18293
18283: PUSH
18284: LD_EXP 7
18288: PUSH
18289: LD_INT 3
18291: EQUAL
18292: AND
18293: IFFALSE 18345
// begin ComExitVehicle ( Connie ) ;
18295: LD_EXP 55
18299: PPUSH
18300: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18304: LD_EXP 55
18308: PPUSH
18309: LD_INT 35
18311: PPUSH
18312: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18316: LD_EXP 55
18320: PPUSH
18321: LD_INT 65
18323: PPUSH
18324: LD_INT 104
18326: PPUSH
18327: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18331: LD_EXP 55
18335: PPUSH
18336: LD_EXP 40
18340: PPUSH
18341: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18345: LD_INT 35
18347: PPUSH
18348: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18352: LD_EXP 40
18356: PPUSH
18357: LD_EXP 61
18361: PPUSH
18362: CALL_OW 296
18366: PUSH
18367: LD_INT 8
18369: LESS
18370: IFFALSE 18345
// wait ( 0 0$0.5 ) ;
18372: LD_INT 18
18374: PPUSH
18375: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18379: LD_EXP 40
18383: PPUSH
18384: LD_STRING D1-JMM-1
18386: PPUSH
18387: CALL_OW 88
// async ;
18391: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18392: LD_EXP 61
18396: PPUSH
18397: LD_STRING D1-Pow-1
18399: PPUSH
18400: CALL_OW 88
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18418
// wait ( 0 0$2 ) ;
18411: LD_INT 70
18413: PPUSH
18414: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18418: LD_INT 170
18420: PPUSH
18421: LD_INT 99
18423: PPUSH
18424: LD_INT 1
18426: PPUSH
18427: LD_INT 6
18429: NEG
18430: PPUSH
18431: CALL 108955 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18435: LD_INT 174
18437: PPUSH
18438: LD_INT 115
18440: PPUSH
18441: LD_INT 1
18443: PPUSH
18444: LD_INT 6
18446: NEG
18447: PPUSH
18448: CALL 108955 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18452: LD_INT 169
18454: PPUSH
18455: LD_INT 71
18457: PPUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_INT 6
18463: NEG
18464: PPUSH
18465: CALL 108955 0 4
// if not dialogue_skipped then
18469: LD_OWVAR 59
18473: NOT
18474: IFFALSE 18493
// begin CenterOnXY ( 170 , 99 ) ;
18476: LD_INT 170
18478: PPUSH
18479: LD_INT 99
18481: PPUSH
18482: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18486: LD_INT 80
18488: PPUSH
18489: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18493: LD_INT 75
18495: PPUSH
18496: LD_INT 53
18498: PPUSH
18499: LD_INT 1
18501: PPUSH
18502: LD_INT 9
18504: NEG
18505: PPUSH
18506: CALL 108955 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18510: LD_INT 54
18512: PPUSH
18513: LD_INT 42
18515: PPUSH
18516: LD_INT 1
18518: PPUSH
18519: LD_INT 9
18521: NEG
18522: PPUSH
18523: CALL 108955 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18527: LD_INT 62
18529: PPUSH
18530: LD_INT 51
18532: PPUSH
18533: LD_INT 1
18535: PPUSH
18536: LD_INT 9
18538: NEG
18539: PPUSH
18540: CALL 108955 0 4
// if not dialogue_skipped then
18544: LD_OWVAR 59
18548: NOT
18549: IFFALSE 18568
// begin CenterOnXY ( 75 , 53 ) ;
18551: LD_INT 75
18553: PPUSH
18554: LD_INT 53
18556: PPUSH
18557: CALL_OW 84
// wait ( 0 0$4 ) ;
18561: LD_INT 140
18563: PPUSH
18564: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18568: LD_EXP 61
18572: PPUSH
18573: CALL_OW 87
// if not dialogue_skipped then
18577: LD_OWVAR 59
18581: NOT
18582: IFFALSE 18591
// wait ( 0 0$2 ) ;
18584: LD_INT 70
18586: PPUSH
18587: CALL_OW 67
// sync ;
18591: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18592: LD_EXP 40
18596: PPUSH
18597: LD_STRING D1-JMM-2
18599: PPUSH
18600: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18604: LD_EXP 61
18608: PPUSH
18609: LD_STRING D1-Pow-2
18611: PPUSH
18612: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18616: LD_EXP 40
18620: PPUSH
18621: LD_STRING D1-JMM-3
18623: PPUSH
18624: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18628: LD_EXP 61
18632: PPUSH
18633: LD_STRING D1-Pow-3
18635: PPUSH
18636: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18640: LD_EXP 40
18644: PPUSH
18645: LD_STRING D1-JMM-4
18647: PPUSH
18648: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18652: LD_EXP 61
18656: PPUSH
18657: LD_STRING D1-Pow-4
18659: PPUSH
18660: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18664: LD_EXP 40
18668: PPUSH
18669: LD_STRING D1-JMM-5
18671: PPUSH
18672: CALL_OW 88
// async ;
18676: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18677: LD_EXP 61
18681: PPUSH
18682: LD_STRING D1-Pow-5
18684: PPUSH
18685: CALL_OW 88
// if not dialogue_skipped then
18689: LD_OWVAR 59
18693: NOT
18694: IFFALSE 18703
// wait ( 0 0$3.6 ) ;
18696: LD_INT 126
18698: PPUSH
18699: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18703: LD_INT 134
18705: PPUSH
18706: LD_INT 210
18708: PPUSH
18709: LD_INT 1
18711: PPUSH
18712: LD_INT 11
18714: NEG
18715: PPUSH
18716: CALL 108955 0 4
// if not dialogue_skipped then
18720: LD_OWVAR 59
18724: NOT
18725: IFFALSE 18744
// begin CenterOnXY ( 134 , 210 ) ;
18727: LD_INT 134
18729: PPUSH
18730: LD_INT 210
18732: PPUSH
18733: CALL_OW 84
// wait ( 0 0$2 ) ;
18737: LD_INT 70
18739: PPUSH
18740: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18744: LD_INT 101
18746: PPUSH
18747: LD_INT 159
18749: PPUSH
18750: LD_INT 1
18752: PPUSH
18753: LD_INT 10
18755: NEG
18756: PPUSH
18757: CALL 108955 0 4
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18785
// begin CenterOnXY ( 101 , 159 ) ;
18768: LD_INT 101
18770: PPUSH
18771: LD_INT 159
18773: PPUSH
18774: CALL_OW 84
// wait ( 0 0$2 ) ;
18778: LD_INT 70
18780: PPUSH
18781: CALL_OW 67
// end ; sync ;
18785: SYNC
// CenterNowOnUnits ( Powell ) ;
18786: LD_EXP 61
18790: PPUSH
18791: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18795: LD_ADDR_VAR 0 6
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 3
18808: PUSH
18809: LD_INT 4
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: LD_INT 6
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: ST_TO_ADDR
// if not dialogue_skipped then
18826: LD_OWVAR 59
18830: NOT
18831: IFFALSE 19002
// begin game_speed := 4 ;
18833: LD_ADDR_OWVAR 65
18837: PUSH
18838: LD_INT 4
18840: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18841: LD_INT 210
18843: PPUSH
18844: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18848: LD_ADDR_VAR 0 7
18852: PUSH
18853: LD_STRING Q1
18855: PPUSH
18856: LD_VAR 0 6
18860: PPUSH
18861: CALL_OW 98
18865: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18866: LD_ADDR_VAR 0 7
18870: PUSH
18871: LD_STRING Q1
18873: PPUSH
18874: LD_VAR 0 6
18878: PPUSH
18879: CALL_OW 98
18883: ST_TO_ADDR
// options := options diff dec ;
18884: LD_ADDR_VAR 0 6
18888: PUSH
18889: LD_VAR 0 6
18893: PUSH
18894: LD_VAR 0 7
18898: DIFF
18899: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18900: LD_VAR 0 7
18904: PPUSH
18905: LD_VAR 0 6
18909: PPUSH
18910: CALL 20690 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18914: LD_VAR 0 7
18918: PUSH
18919: LD_INT 5
18921: PUSH
18922: LD_INT 6
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: IN
18929: IFTRUE 18941
18931: PUSH
18932: LD_VAR 0 6
18936: PUSH
18937: LD_INT 2
18939: EQUAL
18940: OR
18941: IFFALSE 18866
// if not ( dec in [ 5 , 6 ] ) then
18943: LD_VAR 0 7
18947: PUSH
18948: LD_INT 5
18950: PUSH
18951: LD_INT 6
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: IN
18958: NOT
18959: IFFALSE 19002
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18961: LD_ADDR_VAR 0 7
18965: PUSH
18966: LD_STRING Q1a
18968: PPUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 2
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PPUSH
18979: CALL_OW 98
18983: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18984: LD_VAR 0 7
18988: PUSH
18989: LD_INT 4
18991: PLUS
18992: PPUSH
18993: LD_VAR 0 6
18997: PPUSH
18998: CALL 20690 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
19002: LD_INT 81
19004: PPUSH
19005: LD_INT 127
19007: PPUSH
19008: CALL_OW 84
// amount := 8 ;
19012: LD_ADDR_VAR 0 8
19016: PUSH
19017: LD_INT 8
19019: ST_TO_ADDR
// macmilan_squad := [ ] ;
19020: LD_ADDR_VAR 0 9
19024: PUSH
19025: EMPTY
19026: ST_TO_ADDR
// if vip < amount then
19027: LD_EXP 62
19031: PUSH
19032: LD_VAR 0 8
19036: LESS
19037: IFFALSE 19092
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) else
19039: LD_ADDR_VAR 0 5
19043: PUSH
19044: LD_EXP 62
19048: PUSH
19049: LD_INT 22
19051: PUSH
19052: LD_INT 4
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 23
19061: PUSH
19062: LD_INT 1
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PUSH
19069: LD_INT 21
19071: PUSH
19072: LD_INT 1
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: PUSH
19079: EMPTY
19080: LIST
19081: LIST
19082: LIST
19083: PPUSH
19084: CALL_OW 69
19088: UNION
19089: ST_TO_ADDR
19090: GO 19102
// tmp := vip ;
19092: LD_ADDR_VAR 0 5
19096: PUSH
19097: LD_EXP 62
19101: ST_TO_ADDR
// tmp := tmp diff Powell ;
19102: LD_ADDR_VAR 0 5
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: LD_EXP 61
19116: DIFF
19117: ST_TO_ADDR
// if tmp < amount then
19118: LD_VAR 0 5
19122: PUSH
19123: LD_VAR 0 8
19127: LESS
19128: IFFALSE 19140
// amount := tmp ;
19130: LD_ADDR_VAR 0 8
19134: PUSH
19135: LD_VAR 0 5
19139: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19140: LD_VAR 0 5
19144: PUSH
19145: LD_INT 1
19147: ARRAY
19148: PPUSH
19149: CALL_OW 257
19153: PUSH
19154: LD_INT 2
19156: NONEQUAL
19157: IFFALSE 19255
// begin if IsInUnit ( tmp [ 1 ] ) then
19159: LD_VAR 0 5
19163: PUSH
19164: LD_INT 1
19166: ARRAY
19167: PPUSH
19168: CALL_OW 310
19172: IFFALSE 19187
// ComExitBuilding ( tmp [ 1 ] ) ;
19174: LD_VAR 0 5
19178: PUSH
19179: LD_INT 1
19181: ARRAY
19182: PPUSH
19183: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19187: LD_INT 387
19189: PPUSH
19190: CALL_OW 313
19194: PUSH
19195: LD_INT 6
19197: EQUAL
19198: IFFALSE 19223
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19200: LD_INT 387
19202: PPUSH
19203: CALL_OW 313
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: PPUSH
19212: CALL_OW 122
// wait ( 3 ) ;
19216: LD_INT 3
19218: PPUSH
19219: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19223: LD_VAR 0 5
19227: PUSH
19228: LD_INT 1
19230: ARRAY
19231: PPUSH
19232: LD_INT 387
19234: PPUSH
19235: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19239: LD_VAR 0 5
19243: PUSH
19244: LD_INT 1
19246: ARRAY
19247: PPUSH
19248: LD_INT 2
19250: PPUSH
19251: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19255: LD_EXP 40
19259: PPUSH
19260: LD_INT 82
19262: PPUSH
19263: LD_INT 129
19265: PPUSH
19266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19270: LD_EXP 40
19274: PPUSH
19275: LD_EXP 61
19279: PPUSH
19280: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19284: LD_INT 22
19286: PUSH
19287: LD_INT 1
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PPUSH
19294: CALL_OW 69
19298: PUSH
19299: LD_EXP 40
19303: DIFF
19304: PPUSH
19305: LD_INT 84
19307: PPUSH
19308: LD_INT 128
19310: PPUSH
19311: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19315: LD_INT 22
19317: PUSH
19318: LD_INT 1
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PPUSH
19325: CALL_OW 69
19329: PUSH
19330: LD_EXP 40
19334: DIFF
19335: PPUSH
19336: LD_EXP 40
19340: PPUSH
19341: CALL_OW 179
// for i = 1 to amount do
19345: LD_ADDR_VAR 0 2
19349: PUSH
19350: DOUBLE
19351: LD_INT 1
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 8
19359: PUSH
19360: FOR_TO
19361: IFFALSE 19531
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19363: LD_ADDR_VAR 0 9
19367: PUSH
19368: LD_VAR 0 9
19372: PUSH
19373: LD_VAR 0 5
19377: PUSH
19378: LD_VAR 0 2
19382: ARRAY
19383: ADD
19384: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19385: LD_VAR 0 5
19389: PUSH
19390: LD_VAR 0 2
19394: ARRAY
19395: PPUSH
19396: CALL_OW 310
19400: IFFALSE 19417
// AddComExitBuilding ( tmp [ i ] ) ;
19402: LD_VAR 0 5
19406: PUSH
19407: LD_VAR 0 2
19411: ARRAY
19412: PPUSH
19413: CALL_OW 182
// if i = 2 and JMMNewVeh then
19417: LD_VAR 0 2
19421: PUSH
19422: LD_INT 2
19424: EQUAL
19425: IFFALSE 19433
19427: PUSH
19428: LD_EXP 59
19432: AND
19433: IFFALSE 19491
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19435: LD_VAR 0 5
19439: PUSH
19440: LD_VAR 0 2
19444: ARRAY
19445: PPUSH
19446: LD_EXP 59
19450: PPUSH
19451: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19455: LD_VAR 0 5
19459: PUSH
19460: LD_VAR 0 2
19464: ARRAY
19465: PPUSH
19466: LD_INT 86
19468: PPUSH
19469: LD_INT 133
19471: PPUSH
19472: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19476: LD_VAR 0 5
19480: PUSH
19481: LD_VAR 0 2
19485: ARRAY
19486: PPUSH
19487: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19491: LD_VAR 0 5
19495: PUSH
19496: LD_VAR 0 2
19500: ARRAY
19501: PPUSH
19502: LD_INT 8
19504: PPUSH
19505: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19509: LD_VAR 0 5
19513: PUSH
19514: LD_VAR 0 2
19518: ARRAY
19519: PPUSH
19520: LD_EXP 40
19524: PPUSH
19525: CALL_OW 179
// end ;
19529: GO 19360
19531: POP
19532: POP
// if GirlNewVeh then
19533: LD_EXP 60
19537: IFFALSE 19551
// SetSide ( GirlNewVeh , 4 ) ;
19539: LD_EXP 60
19543: PPUSH
19544: LD_INT 4
19546: PPUSH
19547: CALL_OW 235
// if Mike then
19551: LD_EXP 57
19555: IFFALSE 19592
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19557: LD_ADDR_VAR 0 9
19561: PUSH
19562: LD_VAR 0 9
19566: PPUSH
19567: LD_EXP 57
19571: PPUSH
19572: CALL 109071 0 2
19576: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19577: LD_EXP 57
19581: PPUSH
19582: LD_INT 86
19584: PPUSH
19585: LD_INT 133
19587: PPUSH
19588: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19592: LD_INT 35
19594: PPUSH
19595: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19599: LD_VAR 0 9
19603: PPUSH
19604: LD_INT 95
19606: PUSH
19607: LD_INT 9
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: PPUSH
19614: CALL_OW 72
19618: PUSH
19619: LD_INT 0
19621: EQUAL
19622: IFFALSE 19639
19624: PUSH
19625: LD_EXP 40
19629: PPUSH
19630: LD_INT 9
19632: PPUSH
19633: CALL_OW 308
19637: NOT
19638: AND
19639: IFFALSE 19592
// wait ( 0 0$2 ) ;
19641: LD_INT 70
19643: PPUSH
19644: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19648: LD_VAR 0 9
19652: PPUSH
19653: LD_INT 1
19655: PPUSH
19656: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19660: LD_INT 21
19662: PUSH
19663: LD_INT 2
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: PUSH
19670: LD_INT 92
19672: PUSH
19673: LD_INT 83
19675: PUSH
19676: LD_INT 130
19678: PUSH
19679: LD_INT 10
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: LIST
19686: LIST
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: PPUSH
19692: CALL_OW 69
19696: PPUSH
19697: LD_INT 1
19699: PPUSH
19700: CALL_OW 235
// tick := 0 ;
19704: LD_ADDR_OWVAR 1
19708: PUSH
19709: LD_INT 0
19711: ST_TO_ADDR
// Video ( false ) ;
19712: LD_INT 0
19714: PPUSH
19715: CALL 109043 0 1
// ChangeMissionObjectives ( M1 ) ;
19719: LD_STRING M1
19721: PPUSH
19722: CALL_OW 337
// SaveForQuickRestart ;
19726: CALL_OW 22
// missionStart := true ;
19730: LD_ADDR_EXP 13
19734: PUSH
19735: LD_INT 1
19737: ST_TO_ADDR
// missionStage := 2 ;
19738: LD_ADDR_EXP 15
19742: PUSH
19743: LD_INT 2
19745: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19746: LD_INT 35
19748: PPUSH
19749: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19753: LD_ADDR_VAR 0 5
19757: PUSH
19758: LD_INT 22
19760: PUSH
19761: LD_INT 4
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: PUSH
19768: LD_INT 21
19770: PUSH
19771: LD_INT 1
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: PPUSH
19782: CALL_OW 69
19786: PUSH
19787: LD_EXP 61
19791: DIFF
19792: ST_TO_ADDR
// if not tmp then
19793: LD_VAR 0 5
19797: NOT
19798: IFFALSE 19813
// tmp := [ Powell ] ;
19800: LD_ADDR_VAR 0 5
19804: PUSH
19805: LD_EXP 61
19809: PUSH
19810: EMPTY
19811: LIST
19812: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19813: LD_ADDR_VAR 0 4
19817: PUSH
19818: LD_INT 22
19820: PUSH
19821: LD_INT 4
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: PUSH
19828: LD_INT 34
19830: PUSH
19831: LD_INT 12
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: PUSH
19847: LD_INT 1
19849: ARRAY
19850: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19851: LD_VAR 0 5
19855: PUSH
19856: LD_INT 1
19858: ARRAY
19859: PPUSH
19860: CALL_OW 310
19864: IFFALSE 19879
// ComExitBuilding ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19879: LD_VAR 0 5
19883: PUSH
19884: LD_INT 1
19886: ARRAY
19887: PPUSH
19888: LD_VAR 0 4
19892: PPUSH
19893: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19897: LD_VAR 0 5
19901: PUSH
19902: LD_INT 1
19904: ARRAY
19905: PPUSH
19906: LD_INT 80
19908: PPUSH
19909: LD_INT 136
19911: PPUSH
19912: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19916: LD_VAR 0 5
19920: PUSH
19921: LD_INT 1
19923: ARRAY
19924: PPUSH
19925: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19929: LD_VAR 0 5
19933: PUSH
19934: LD_INT 1
19936: ARRAY
19937: PPUSH
19938: LD_INT 59
19940: PPUSH
19941: LD_INT 112
19943: PPUSH
19944: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19948: LD_VAR 0 5
19952: PUSH
19953: LD_INT 1
19955: ARRAY
19956: PPUSH
19957: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 and JMMGirl = 1 then
19961: LD_EXP 41
19965: IFFALSE 19982
19967: PUSH
19968: LD_EXP 41
19972: PPUSH
19973: CALL_OW 255
19977: PUSH
19978: LD_INT 1
19980: EQUAL
19981: AND
19982: IFFALSE 19994
19984: PUSH
19985: LD_EXP 7
19989: PUSH
19990: LD_INT 1
19992: EQUAL
19993: AND
19994: IFFALSE 20020
// begin Say ( Joan , D3W-Joan-1 ) ;
19996: LD_EXP 41
20000: PPUSH
20001: LD_STRING D3W-Joan-1
20003: PPUSH
20004: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20008: LD_EXP 40
20012: PPUSH
20013: LD_STRING D3W-JMM-1
20015: PPUSH
20016: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip and JMMGirl = 2 then
20020: LD_EXP 43
20024: IFFALSE 20041
20026: PUSH
20027: LD_EXP 43
20031: PPUSH
20032: CALL_OW 255
20036: PUSH
20037: LD_INT 1
20039: EQUAL
20040: AND
20041: IFFALSE 20056
20043: PUSH
20044: LD_EXP 43
20048: PUSH
20049: LD_EXP 62
20053: IN
20054: NOT
20055: AND
20056: IFFALSE 20068
20058: PUSH
20059: LD_EXP 7
20063: PUSH
20064: LD_INT 2
20066: EQUAL
20067: AND
20068: IFFALSE 20094
// begin Say ( Lisa , D3W-Lisa-1 ) ;
20070: LD_EXP 43
20074: PPUSH
20075: LD_STRING D3W-Lisa-1
20077: PPUSH
20078: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20082: LD_EXP 40
20086: PPUSH
20087: LD_STRING D3W-JMM-1
20089: PPUSH
20090: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 and JMMGirl = 3 then
20094: LD_EXP 55
20098: IFFALSE 20115
20100: PUSH
20101: LD_EXP 55
20105: PPUSH
20106: CALL_OW 255
20110: PUSH
20111: LD_INT 1
20113: EQUAL
20114: AND
20115: IFFALSE 20127
20117: PUSH
20118: LD_EXP 7
20122: PUSH
20123: LD_INT 3
20125: EQUAL
20126: AND
20127: IFFALSE 20153
// begin Say ( Connie , D3W-Con-1 ) ;
20129: LD_EXP 55
20133: PPUSH
20134: LD_STRING D3W-Con-1
20136: PPUSH
20137: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20141: LD_EXP 40
20145: PPUSH
20146: LD_STRING D3W-JMM-1
20148: PPUSH
20149: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20153: LD_INT 18
20155: PPUSH
20156: CALL_OW 67
// hasSomethingToSay := false ;
20160: LD_ADDR_VAR 0 10
20164: PUSH
20165: LD_INT 0
20167: ST_TO_ADDR
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20168: LD_EXP 43
20172: PUSH
20173: LD_EXP 62
20177: IN
20178: IFFALSE 20195
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: CALL_OW 255
20190: PUSH
20191: LD_INT 1
20193: EQUAL
20194: AND
20195: IFFALSE 20219
// begin hasSomethingToSay := true ;
20197: LD_ADDR_VAR 0 10
20201: PUSH
20202: LD_INT 1
20204: ST_TO_ADDR
// Say ( Lisa , D3nW-Lisa-1 ) ;
20205: LD_EXP 43
20209: PPUSH
20210: LD_STRING D3nW-Lisa-1
20212: PPUSH
20213: CALL_OW 88
// end else
20217: GO 20523
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20219: LD_EXP 46
20223: PUSH
20224: LD_EXP 62
20228: IN
20229: IFFALSE 20246
20231: PUSH
20232: LD_EXP 46
20236: PPUSH
20237: CALL_OW 255
20241: PUSH
20242: LD_INT 1
20244: EQUAL
20245: AND
20246: IFFALSE 20270
// begin hasSomethingToSay := true ;
20248: LD_ADDR_VAR 0 10
20252: PUSH
20253: LD_INT 1
20255: ST_TO_ADDR
// Say ( Cyrus , D3nW-Cyrus-1 ) ;
20256: LD_EXP 46
20260: PPUSH
20261: LD_STRING D3nW-Cyrus-1
20263: PPUSH
20264: CALL_OW 88
// end else
20268: GO 20523
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20270: LD_EXP 45
20274: PUSH
20275: LD_EXP 62
20279: IN
20280: IFFALSE 20297
20282: PUSH
20283: LD_EXP 45
20287: PPUSH
20288: CALL_OW 255
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: AND
20297: IFFALSE 20321
// begin hasSomethingToSay := true ;
20299: LD_ADDR_VAR 0 10
20303: PUSH
20304: LD_INT 1
20306: ST_TO_ADDR
// Say ( Bobby , D3nW-Bobby-1 ) ;
20307: LD_EXP 45
20311: PPUSH
20312: LD_STRING D3nW-Bobby-1
20314: PPUSH
20315: CALL_OW 88
// end else
20319: GO 20523
// if Gary in vip and GetSide ( Gary ) = 1 then
20321: LD_EXP 52
20325: PUSH
20326: LD_EXP 62
20330: IN
20331: IFFALSE 20348
20333: PUSH
20334: LD_EXP 52
20338: PPUSH
20339: CALL_OW 255
20343: PUSH
20344: LD_INT 1
20346: EQUAL
20347: AND
20348: IFFALSE 20372
// begin hasSomethingToSay := true ;
20350: LD_ADDR_VAR 0 10
20354: PUSH
20355: LD_INT 1
20357: ST_TO_ADDR
// Say ( Gary , D3nW-Gary-1 ) ;
20358: LD_EXP 52
20362: PPUSH
20363: LD_STRING D3nW-Gary-1
20365: PPUSH
20366: CALL_OW 88
// end else
20370: GO 20523
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20372: LD_EXP 44
20376: PUSH
20377: LD_EXP 62
20381: IN
20382: IFFALSE 20399
20384: PUSH
20385: LD_EXP 44
20389: PPUSH
20390: CALL_OW 255
20394: PUSH
20395: LD_INT 1
20397: EQUAL
20398: AND
20399: IFFALSE 20423
// begin hasSomethingToSay := true ;
20401: LD_ADDR_VAR 0 10
20405: PUSH
20406: LD_INT 1
20408: ST_TO_ADDR
// Say ( Donaldson , D3nW-Don-1 ) ;
20409: LD_EXP 44
20413: PPUSH
20414: LD_STRING D3nW-Don-1
20416: PPUSH
20417: CALL_OW 88
// end else
20421: GO 20523
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20423: LD_EXP 51
20427: PUSH
20428: LD_EXP 62
20432: IN
20433: IFFALSE 20450
20435: PUSH
20436: LD_EXP 51
20440: PPUSH
20441: CALL_OW 255
20445: PUSH
20446: LD_INT 1
20448: EQUAL
20449: AND
20450: IFFALSE 20474
// begin hasSomethingToSay := true ;
20452: LD_ADDR_VAR 0 10
20456: PUSH
20457: LD_INT 1
20459: ST_TO_ADDR
// Say ( Cornel , D3nW-Corn-1 ) ;
20460: LD_EXP 51
20464: PPUSH
20465: LD_STRING D3nW-Corn-1
20467: PPUSH
20468: CALL_OW 88
// end else
20472: GO 20523
// if Frank in vip and GetSide ( Frank ) = 1 then
20474: LD_EXP 53
20478: PUSH
20479: LD_EXP 62
20483: IN
20484: IFFALSE 20501
20486: PUSH
20487: LD_EXP 53
20491: PPUSH
20492: CALL_OW 255
20496: PUSH
20497: LD_INT 1
20499: EQUAL
20500: AND
20501: IFFALSE 20523
// begin hasSomethingToSay := true ;
20503: LD_ADDR_VAR 0 10
20507: PUSH
20508: LD_INT 1
20510: ST_TO_ADDR
// Say ( Frank , D3nW-Frank-1 ) ;
20511: LD_EXP 53
20515: PPUSH
20516: LD_STRING D3nW-Frank-1
20518: PPUSH
20519: CALL_OW 88
// end ; if hasSomethingToSay then
20523: LD_VAR 0 10
20527: IFFALSE 20553
// begin Say ( JMM , D3nW-JMM-1 ) ;
20529: LD_EXP 40
20533: PPUSH
20534: LD_STRING D3nW-JMM-1
20536: PPUSH
20537: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20541: LD_EXP 40
20545: PPUSH
20546: LD_STRING D3nW-JMM-1a
20548: PPUSH
20549: CALL_OW 88
// end ; t := 0 0$00 ;
20553: LD_ADDR_VAR 0 3
20557: PUSH
20558: LD_INT 0
20560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20561: LD_INT 35
20563: PPUSH
20564: CALL_OW 67
// t := t + 0 0$1 ;
20568: LD_ADDR_VAR 0 3
20572: PUSH
20573: LD_VAR 0 3
20577: PUSH
20578: LD_INT 35
20580: PLUS
20581: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20582: LD_INT 59
20584: PPUSH
20585: LD_INT 112
20587: PPUSH
20588: CALL_OW 428
20592: IFTRUE 20604
20594: PUSH
20595: LD_VAR 0 3
20599: PUSH
20600: LD_INT 2100
20602: GREATER
20603: OR
20604: IFFALSE 20561
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20606: LD_ADDR_EXP 102
20610: PUSH
20611: LD_EXP 102
20615: PPUSH
20616: LD_INT 4
20618: PPUSH
20619: LD_INT 22
20621: PUSH
20622: LD_INT 4
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 23
20631: PUSH
20632: LD_INT 1
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PUSH
20639: LD_INT 3
20641: PUSH
20642: LD_INT 21
20644: PUSH
20645: LD_INT 2
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 69
20665: PUSH
20666: LD_EXP 61
20670: DIFF
20671: PPUSH
20672: CALL_OW 1
20676: ST_TO_ADDR
// activeAttacks := true ;
20677: LD_ADDR_EXP 16
20681: PUSH
20682: LD_INT 1
20684: ST_TO_ADDR
// end ;
20685: LD_VAR 0 1
20689: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20690: LD_INT 0
20692: PPUSH
// case question of 1 :
20693: LD_VAR 0 1
20697: PUSH
20698: LD_INT 1
20700: DOUBLE
20701: EQUAL
20702: IFTRUE 20706
20704: GO 20757
20706: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20707: LD_EXP 40
20711: PPUSH
20712: LD_STRING D2Mot-JMM-1
20714: PPUSH
20715: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20719: LD_EXP 61
20723: PPUSH
20724: LD_STRING D2Mot-Pow-1
20726: PPUSH
20727: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20731: LD_EXP 40
20735: PPUSH
20736: LD_STRING D2Mot-JMM-2
20738: PPUSH
20739: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20743: LD_EXP 61
20747: PPUSH
20748: LD_STRING D2Mot-Pow-2
20750: PPUSH
20751: CALL_OW 88
// end ; 2 :
20755: GO 21108
20757: LD_INT 2
20759: DOUBLE
20760: EQUAL
20761: IFTRUE 20765
20763: GO 20841
20765: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20766: LD_EXP 40
20770: PPUSH
20771: LD_STRING D2Rus-JMM-1
20773: PPUSH
20774: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20778: LD_EXP 61
20782: PPUSH
20783: LD_STRING D2Rus-Pow-1
20785: PPUSH
20786: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20790: LD_EXP 40
20794: PPUSH
20795: LD_STRING D2Rus-JMM-2
20797: PPUSH
20798: CALL_OW 88
// if not ( 3 in list_of_q ) then
20802: LD_INT 3
20804: PUSH
20805: LD_VAR 0 2
20809: IN
20810: NOT
20811: IFFALSE 20827
// Say ( Powell , D2Rus-Pow-2 ) else
20813: LD_EXP 61
20817: PPUSH
20818: LD_STRING D2Rus-Pow-2
20820: PPUSH
20821: CALL_OW 88
20825: GO 20839
// Say ( Powell , D2Rus-Pow-2a ) ;
20827: LD_EXP 61
20831: PPUSH
20832: LD_STRING D2Rus-Pow-2a
20834: PPUSH
20835: CALL_OW 88
// end ; 3 :
20839: GO 21108
20841: LD_INT 3
20843: DOUBLE
20844: EQUAL
20845: IFTRUE 20849
20847: GO 20934
20849: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20850: LD_EXP 40
20854: PPUSH
20855: LD_STRING D2Leg-JMM-1
20857: PPUSH
20858: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20862: LD_EXP 61
20866: PPUSH
20867: LD_STRING D2Leg-Pow-1
20869: PPUSH
20870: CALL_OW 88
// if 2 in list_of_q then
20874: LD_INT 2
20876: PUSH
20877: LD_VAR 0 2
20881: IN
20882: IFFALSE 20908
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20884: LD_EXP 40
20888: PPUSH
20889: LD_STRING D2Leg-JMM-2
20891: PPUSH
20892: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20896: LD_EXP 61
20900: PPUSH
20901: LD_STRING D2Leg-Pow-2
20903: PPUSH
20904: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20908: LD_EXP 40
20912: PPUSH
20913: LD_STRING D2Leg-JMM-3
20915: PPUSH
20916: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20920: LD_EXP 61
20924: PPUSH
20925: LD_STRING D2Leg-Pow-3
20927: PPUSH
20928: CALL_OW 88
// end ; 4 :
20932: GO 21108
20934: LD_INT 4
20936: DOUBLE
20937: EQUAL
20938: IFTRUE 20942
20940: GO 21017
20942: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20943: LD_EXP 40
20947: PPUSH
20948: LD_STRING D2Ar-JMM-1
20950: PPUSH
20951: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20955: LD_EXP 61
20959: PPUSH
20960: LD_STRING D2Ar-Pow-1
20962: PPUSH
20963: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20967: LD_EXP 40
20971: PPUSH
20972: LD_STRING D2Ar-JMM-2
20974: PPUSH
20975: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20979: LD_EXP 61
20983: PPUSH
20984: LD_STRING D2Ar-Pow-2
20986: PPUSH
20987: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20991: LD_EXP 40
20995: PPUSH
20996: LD_STRING D2Ar-JMM-3
20998: PPUSH
20999: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
21003: LD_EXP 61
21007: PPUSH
21008: LD_STRING D2Ar-Pow-3
21010: PPUSH
21011: CALL_OW 88
// end ; 5 :
21015: GO 21108
21017: LD_INT 5
21019: DOUBLE
21020: EQUAL
21021: IFTRUE 21025
21023: GO 21040
21025: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
21026: LD_EXP 40
21030: PPUSH
21031: LD_STRING D2Conf-JMM-1
21033: PPUSH
21034: CALL_OW 88
21038: GO 21108
21040: LD_INT 6
21042: DOUBLE
21043: EQUAL
21044: IFTRUE 21048
21046: GO 21107
21048: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
21049: LD_EXP 40
21053: PPUSH
21054: LD_STRING D2Com-JMM-1
21056: PPUSH
21057: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
21061: LD_EXP 61
21065: PPUSH
21066: LD_STRING D2Com-Pow-1
21068: PPUSH
21069: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
21073: LD_EXP 40
21077: PPUSH
21078: LD_STRING D2Com-JMM-2
21080: PPUSH
21081: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
21085: LD_EXP 61
21089: PPUSH
21090: LD_STRING D2Com-Pow-2
21092: PPUSH
21093: CALL_OW 88
// powellAngerQuery := true ;
21097: LD_ADDR_EXP 36
21101: PUSH
21102: LD_INT 1
21104: ST_TO_ADDR
// end ; end ;
21105: GO 21108
21107: POP
// end ;
21108: LD_VAR 0 3
21112: RET
// every 0 0$5 trigger missionStart do var tmp ;
21113: LD_EXP 13
21117: IFFALSE 21444
21119: GO 21121
21121: DISABLE
21122: LD_INT 0
21124: PPUSH
// begin repeat wait ( 0 0$1 ) ;
21125: LD_INT 35
21127: PPUSH
21128: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
21132: LD_INT 14
21134: PPUSH
21135: LD_INT 22
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 3
21147: PUSH
21148: LD_INT 21
21150: PUSH
21151: LD_INT 3
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: PPUSH
21166: CALL_OW 70
21170: IFFALSE 21197
21172: PUSH
21173: LD_EXP 15
21177: PUSH
21178: LD_INT 2
21180: PUSH
21181: LD_INT 3
21183: PUSH
21184: LD_INT 4
21186: PUSH
21187: LD_INT 5
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: IN
21196: AND
21197: IFFALSE 21434
// begin powellAnger := powellAnger + 1 ;
21199: LD_ADDR_EXP 17
21203: PUSH
21204: LD_EXP 17
21208: PUSH
21209: LD_INT 1
21211: PLUS
21212: ST_TO_ADDR
// Video ( true ) ;
21213: LD_INT 1
21215: PPUSH
21216: CALL 109043 0 1
// CenterNowOnUnits ( tmp ) ;
21220: LD_VAR 0 1
21224: PPUSH
21225: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21229: LD_INT 14
21231: PPUSH
21232: LD_INT 22
21234: PUSH
21235: LD_INT 1
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PPUSH
21242: CALL_OW 70
21246: PPUSH
21247: LD_INT 86
21249: PPUSH
21250: LD_INT 133
21252: PPUSH
21253: CALL_OW 111
// async ;
21257: ASYNC
// case powellAnger of 1 :
21258: LD_EXP 17
21262: PUSH
21263: LD_INT 1
21265: DOUBLE
21266: EQUAL
21267: IFTRUE 21271
21269: GO 21286
21271: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21272: LD_EXP 61
21276: PPUSH
21277: LD_STRING DBack1-Pow-1
21279: PPUSH
21280: CALL_OW 88
21284: GO 21333
21286: LD_INT 2
21288: DOUBLE
21289: EQUAL
21290: IFTRUE 21294
21292: GO 21309
21294: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21295: LD_EXP 61
21299: PPUSH
21300: LD_STRING DBack2-Pow-1
21302: PPUSH
21303: CALL_OW 88
21307: GO 21333
21309: LD_INT 3
21311: DOUBLE
21312: EQUAL
21313: IFTRUE 21317
21315: GO 21332
21317: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21318: LD_EXP 61
21322: PPUSH
21323: LD_STRING DBack3-Pow-1
21325: PPUSH
21326: CALL_OW 88
21330: GO 21333
21332: POP
// sync ;
21333: SYNC
// repeat wait ( 0 0$1 ) ;
21334: LD_INT 35
21336: PPUSH
21337: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21341: LD_INT 14
21343: PPUSH
21344: LD_INT 22
21346: PUSH
21347: LD_INT 1
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: PPUSH
21354: CALL_OW 70
21358: PPUSH
21359: LD_INT 86
21361: PPUSH
21362: LD_INT 133
21364: PPUSH
21365: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21369: LD_INT 14
21371: PPUSH
21372: LD_INT 22
21374: PUSH
21375: LD_INT 1
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PUSH
21382: LD_INT 3
21384: PUSH
21385: LD_INT 21
21387: PUSH
21388: LD_INT 3
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PPUSH
21403: CALL_OW 70
21407: NOT
21408: IFFALSE 21334
// if powellAnger >= 3 then
21410: LD_EXP 17
21414: PUSH
21415: LD_INT 3
21417: GREATEREQUAL
21418: IFFALSE 21427
// YouLost ( Dismissed ) ;
21420: LD_STRING Dismissed
21422: PPUSH
21423: CALL_OW 104
// Video ( false ) ;
21427: LD_INT 0
21429: PPUSH
21430: CALL 109043 0 1
// end ; until missionStage > 5 ;
21434: LD_EXP 15
21438: PUSH
21439: LD_INT 5
21441: GREATER
21442: IFFALSE 21125
// end ;
21444: PPOPN 1
21446: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21447: LD_EXP 13
21451: IFFALSE 21487
21453: PUSH
21454: LD_INT 22
21456: PUSH
21457: LD_INT 4
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 21
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PPUSH
21478: CALL_OW 69
21482: PUSH
21483: LD_INT 4
21485: GREATEREQUAL
21486: AND
21487: IFFALSE 21499
21489: PUSH
21490: LD_EXP 15
21494: PUSH
21495: LD_INT 2
21497: EQUAL
21498: AND
21499: IFFALSE 24127
21501: GO 21503
21503: DISABLE
21504: LD_INT 0
21506: PPUSH
21507: PPUSH
21508: PPUSH
21509: PPUSH
21510: PPUSH
21511: PPUSH
21512: PPUSH
21513: PPUSH
21514: PPUSH
21515: PPUSH
21516: PPUSH
// begin missionStage := 3 ;
21517: LD_ADDR_EXP 15
21521: PUSH
21522: LD_INT 3
21524: ST_TO_ADDR
// retreat := false ;
21525: LD_ADDR_VAR 0 4
21529: PUSH
21530: LD_INT 0
21532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21533: LD_ADDR_VAR 0 5
21537: PUSH
21538: LD_INT 22
21540: PUSH
21541: LD_INT 4
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: PUSH
21548: LD_INT 30
21550: PUSH
21551: LD_INT 4
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: PPUSH
21562: CALL_OW 69
21566: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21567: LD_ADDR_VAR 0 6
21571: PUSH
21572: LD_INT 22
21574: PUSH
21575: LD_INT 4
21577: PUSH
21578: EMPTY
21579: LIST
21580: LIST
21581: PUSH
21582: LD_INT 30
21584: PUSH
21585: LD_INT 5
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PPUSH
21596: CALL_OW 69
21600: ST_TO_ADDR
// if not bar then
21601: LD_VAR 0 6
21605: NOT
21606: IFFALSE 21659
// begin repeat wait ( 0 0$1 ) ;
21608: LD_INT 35
21610: PPUSH
21611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21615: LD_INT 22
21617: PUSH
21618: LD_INT 4
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 3
21627: PUSH
21628: LD_INT 57
21630: PUSH
21631: EMPTY
21632: LIST
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: PUSH
21638: LD_INT 30
21640: PUSH
21641: LD_INT 5
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 69
21657: IFFALSE 21608
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21659: LD_ADDR_VAR 0 6
21663: PUSH
21664: LD_INT 22
21666: PUSH
21667: LD_INT 4
21669: PUSH
21670: EMPTY
21671: LIST
21672: LIST
21673: PUSH
21674: LD_INT 30
21676: PUSH
21677: LD_INT 5
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: PPUSH
21688: CALL_OW 69
21692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21693: LD_INT 35
21695: PPUSH
21696: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21700: LD_EXP 121
21704: PUSH
21705: LD_INT 4
21707: ARRAY
21708: PUSH
21709: LD_INT 4
21711: GREATEREQUAL
21712: IFFALSE 21693
// tmp := [ ] ;
21714: LD_ADDR_VAR 0 2
21718: PUSH
21719: EMPTY
21720: ST_TO_ADDR
// tmp2 := [ ] ;
21721: LD_ADDR_VAR 0 3
21725: PUSH
21726: EMPTY
21727: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21728: LD_ADDR_VAR 0 1
21732: PUSH
21733: LD_INT 22
21735: PUSH
21736: LD_INT 4
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PUSH
21743: LD_INT 2
21745: PUSH
21746: LD_INT 25
21748: PUSH
21749: LD_INT 1
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 25
21758: PUSH
21759: LD_INT 2
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 25
21768: PUSH
21769: LD_INT 3
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: LD_INT 25
21778: PUSH
21779: LD_INT 4
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 25
21788: PUSH
21789: LD_INT 5
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: LIST
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PPUSH
21808: CALL_OW 69
21812: PUSH
21813: LD_EXP 61
21817: PUSH
21818: LD_EXP 62
21822: UNION
21823: DIFF
21824: PUSH
21825: FOR_IN
21826: IFFALSE 21888
// if not i in extraSquad then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_EXP 63
21837: IN
21838: NOT
21839: IFFALSE 21863
// tmp := Join ( tmp , i ) else
21841: LD_ADDR_VAR 0 2
21845: PUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 1
21855: PPUSH
21856: CALL 109071 0 2
21860: ST_TO_ADDR
21861: GO 21886
// tmp := Insert ( tmp , 1 , i ) ;
21863: LD_ADDR_VAR 0 2
21867: PUSH
21868: LD_VAR 0 2
21872: PPUSH
21873: LD_INT 1
21875: PPUSH
21876: LD_VAR 0 1
21880: PPUSH
21881: CALL_OW 2
21885: ST_TO_ADDR
21886: GO 21825
21888: POP
21889: POP
// tmp := tmp diff 0 ;
21890: LD_ADDR_VAR 0 2
21894: PUSH
21895: LD_VAR 0 2
21899: PUSH
21900: LD_INT 0
21902: DIFF
21903: ST_TO_ADDR
// p := 0 ;
21904: LD_ADDR_VAR 0 11
21908: PUSH
21909: LD_INT 0
21911: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21912: LD_ADDR_VAR 0 1
21916: PUSH
21917: LD_VAR 0 2
21921: PPUSH
21922: LD_INT 26
21924: PUSH
21925: LD_INT 1
21927: PUSH
21928: EMPTY
21929: LIST
21930: LIST
21931: PPUSH
21932: CALL_OW 72
21936: PUSH
21937: FOR_IN
21938: IFFALSE 21989
// begin p := Inc ( p ) ;
21940: LD_ADDR_VAR 0 11
21944: PUSH
21945: LD_VAR 0 11
21949: PPUSH
21950: CALL 110444 0 1
21954: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 3
21964: PPUSH
21965: LD_VAR 0 1
21969: PPUSH
21970: CALL 109071 0 2
21974: ST_TO_ADDR
// if p = 4 then
21975: LD_VAR 0 11
21979: PUSH
21980: LD_INT 4
21982: EQUAL
21983: IFFALSE 21987
// break ;
21985: GO 21989
// end ;
21987: GO 21937
21989: POP
21990: POP
// tmp := tmp diff tmp2 ;
21991: LD_ADDR_VAR 0 2
21995: PUSH
21996: LD_VAR 0 2
22000: PUSH
22001: LD_VAR 0 3
22005: DIFF
22006: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
22007: LD_ADDR_VAR 0 2
22011: PUSH
22012: LD_VAR 0 2
22016: PPUSH
22017: LD_INT 3
22019: PPUSH
22020: CALL 107551 0 2
22024: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
22025: LD_ADDR_VAR 0 3
22029: PUSH
22030: LD_VAR 0 3
22034: PPUSH
22035: LD_INT 3
22037: PPUSH
22038: CALL 107551 0 2
22042: ST_TO_ADDR
// for i := 1 to 4 do
22043: LD_ADDR_VAR 0 1
22047: PUSH
22048: DOUBLE
22049: LD_INT 1
22051: DEC
22052: ST_TO_ADDR
22053: LD_INT 4
22055: PUSH
22056: FOR_TO
22057: IFFALSE 22223
// begin if tmp2 then
22059: LD_VAR 0 3
22063: IFFALSE 22144
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
22065: LD_ADDR_EXP 18
22069: PUSH
22070: LD_EXP 18
22074: PPUSH
22075: LD_INT 1
22077: PPUSH
22078: LD_EXP 18
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PUSH
22087: LD_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: ARRAY
22097: ADD
22098: PPUSH
22099: CALL_OW 1
22103: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
22104: LD_VAR 0 3
22108: PUSH
22109: LD_VAR 0 3
22113: ARRAY
22114: PPUSH
22115: LD_INT 1
22117: PPUSH
22118: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
22122: LD_ADDR_VAR 0 3
22126: PUSH
22127: LD_VAR 0 3
22131: PPUSH
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 3
22141: ST_TO_ADDR
// end else
22142: GO 22221
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
22144: LD_ADDR_EXP 18
22148: PUSH
22149: LD_EXP 18
22153: PPUSH
22154: LD_INT 1
22156: PPUSH
22157: LD_EXP 18
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PUSH
22166: LD_VAR 0 2
22170: PUSH
22171: LD_VAR 0 2
22175: ARRAY
22176: ADD
22177: PPUSH
22178: CALL_OW 1
22182: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
22183: LD_VAR 0 2
22187: PUSH
22188: LD_VAR 0 2
22192: ARRAY
22193: PPUSH
22194: LD_INT 1
22196: PPUSH
22197: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22201: LD_ADDR_VAR 0 2
22205: PUSH
22206: LD_VAR 0 2
22210: PPUSH
22211: LD_VAR 0 2
22215: PPUSH
22216: CALL_OW 3
22220: ST_TO_ADDR
// end ; end ;
22221: GO 22056
22223: POP
22224: POP
// if tmp2 then
22225: LD_VAR 0 3
22229: IFFALSE 22247
// tmp := tmp union tmp2 ;
22231: LD_ADDR_VAR 0 2
22235: PUSH
22236: LD_VAR 0 2
22240: PUSH
22241: LD_VAR 0 3
22245: UNION
22246: ST_TO_ADDR
// for i := 0 to 3 do
22247: LD_ADDR_VAR 0 1
22251: PUSH
22252: DOUBLE
22253: LD_INT 0
22255: DEC
22256: ST_TO_ADDR
22257: LD_INT 3
22259: PUSH
22260: FOR_TO
22261: IFFALSE 22424
// begin if not tmp [ tmp - i ] then
22263: LD_VAR 0 2
22267: PUSH
22268: LD_VAR 0 2
22272: PUSH
22273: LD_VAR 0 1
22277: MINUS
22278: ARRAY
22279: NOT
22280: IFFALSE 22377
// begin uc_side := 4 ;
22282: LD_ADDR_OWVAR 20
22286: PUSH
22287: LD_INT 4
22289: ST_TO_ADDR
// uc_nation := 1 ;
22290: LD_ADDR_OWVAR 21
22294: PUSH
22295: LD_INT 1
22297: ST_TO_ADDR
// InitHc ;
22298: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22302: LD_INT 1
22304: PPUSH
22305: LD_INT 3
22307: PPUSH
22308: CALL_OW 381
// un := CreateHuman ;
22312: LD_ADDR_VAR 0 8
22316: PUSH
22317: CALL_OW 44
22321: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22322: LD_VAR 0 8
22326: PPUSH
22327: LD_INT 39
22329: PPUSH
22330: LD_INT 61
22332: PPUSH
22333: CALL_OW 428
22337: PPUSH
22338: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22342: LD_ADDR_EXP 18
22346: PUSH
22347: LD_EXP 18
22351: PPUSH
22352: LD_INT 2
22354: PPUSH
22355: LD_EXP 18
22359: PUSH
22360: LD_INT 2
22362: ARRAY
22363: PUSH
22364: LD_VAR 0 8
22368: ADD
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// end else
22375: GO 22422
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22377: LD_ADDR_EXP 18
22381: PUSH
22382: LD_EXP 18
22386: PPUSH
22387: LD_INT 2
22389: PPUSH
22390: LD_EXP 18
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_VAR 0 2
22408: PUSH
22409: LD_VAR 0 1
22413: MINUS
22414: ARRAY
22415: ADD
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// end ;
22422: GO 22260
22424: POP
22425: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22426: LD_ADDR_EXP 102
22430: PUSH
22431: LD_EXP 102
22435: PPUSH
22436: LD_INT 4
22438: PPUSH
22439: LD_EXP 102
22443: PUSH
22444: LD_INT 4
22446: ARRAY
22447: PUSH
22448: LD_EXP 18
22452: PUSH
22453: LD_INT 1
22455: ARRAY
22456: DIFF
22457: PPUSH
22458: CALL_OW 1
22462: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22463: LD_VAR 0 5
22467: PUSH
22468: LD_INT 1
22470: ARRAY
22471: PPUSH
22472: CALL_OW 313
22476: IFFALSE 22531
// begin for i in UnitsInside ( arm [ 1 ] ) do
22478: LD_ADDR_VAR 0 1
22482: PUSH
22483: LD_VAR 0 5
22487: PUSH
22488: LD_INT 1
22490: ARRAY
22491: PPUSH
22492: CALL_OW 313
22496: PUSH
22497: FOR_IN
22498: IFFALSE 22529
// begin ComExitBuilding ( i ) ;
22500: LD_VAR 0 1
22504: PPUSH
22505: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22509: LD_VAR 0 1
22513: PPUSH
22514: LD_VAR 0 6
22518: PUSH
22519: LD_INT 1
22521: ARRAY
22522: PPUSH
22523: CALL_OW 180
// end ;
22527: GO 22497
22529: POP
22530: POP
// end ; wait ( 0 0$5 ) ;
22531: LD_INT 175
22533: PPUSH
22534: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22538: LD_INT 35
22540: PPUSH
22541: CALL_OW 67
22545: LD_EXP 18
22549: PUSH
22550: LD_INT 1
22552: ARRAY
22553: PPUSH
22554: LD_INT 55
22556: PUSH
22557: EMPTY
22558: LIST
22559: PPUSH
22560: CALL_OW 72
22564: NOT
22565: IFFALSE 22538
// for i in powellSquadAttack [ 1 ] do
22567: LD_ADDR_VAR 0 1
22571: PUSH
22572: LD_EXP 18
22576: PUSH
22577: LD_INT 1
22579: ARRAY
22580: PUSH
22581: FOR_IN
22582: IFFALSE 22689
// begin if IsInUnit ( i ) then
22584: LD_VAR 0 1
22588: PPUSH
22589: CALL_OW 310
22593: IFFALSE 22604
// ComExitBuilding ( i ) ;
22595: LD_VAR 0 1
22599: PPUSH
22600: CALL_OW 122
// if GetClass ( i ) <> 1 then
22604: LD_VAR 0 1
22608: PPUSH
22609: CALL_OW 257
22613: PUSH
22614: LD_INT 1
22616: NONEQUAL
22617: IFFALSE 22658
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22619: LD_VAR 0 1
22623: PPUSH
22624: LD_VAR 0 5
22628: PUSH
22629: LD_INT 1
22631: ARRAY
22632: PPUSH
22633: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22637: LD_VAR 0 1
22641: PPUSH
22642: LD_INT 1
22644: PPUSH
22645: CALL_OW 183
// AddComExitBuilding ( i ) ;
22649: LD_VAR 0 1
22653: PPUSH
22654: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22658: LD_VAR 0 1
22662: PPUSH
22663: LD_INT 60
22665: PPUSH
22666: LD_INT 94
22668: PPUSH
22669: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_EXP 61
22682: PPUSH
22683: CALL_OW 179
// end ;
22687: GO 22581
22689: POP
22690: POP
// wait ( 0 0$45 ) ;
22691: LD_INT 1575
22693: PPUSH
22694: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22698: LD_EXP 61
22702: PPUSH
22703: LD_STRING D4-Pow-1
22705: PPUSH
22706: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22710: LD_ADDR_VAR 0 2
22714: PUSH
22715: LD_EXP 18
22719: PUSH
22720: LD_INT 1
22722: ARRAY
22723: PPUSH
22724: LD_INT 26
22726: PUSH
22727: LD_INT 1
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: PPUSH
22734: CALL_OW 72
22738: ST_TO_ADDR
// if tmp then
22739: LD_VAR 0 2
22743: IFFALSE 22761
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22745: LD_VAR 0 2
22749: PUSH
22750: LD_INT 1
22752: ARRAY
22753: PPUSH
22754: LD_STRING D4-Sol1-1
22756: PPUSH
22757: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22761: LD_EXP 61
22765: PPUSH
22766: LD_STRING D4-Pow-2
22768: PPUSH
22769: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22773: LD_ADDR_VAR 0 1
22777: PUSH
22778: DOUBLE
22779: LD_INT 1
22781: DEC
22782: ST_TO_ADDR
22783: LD_EXP 18
22787: PUSH
22788: LD_INT 1
22790: ARRAY
22791: PUSH
22792: FOR_TO
22793: IFFALSE 22886
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22795: LD_EXP 18
22799: PUSH
22800: LD_INT 1
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 1
22808: ARRAY
22809: PPUSH
22810: LD_EXP 121
22814: PUSH
22815: LD_INT 4
22817: ARRAY
22818: PUSH
22819: LD_INT 1
22821: ARRAY
22822: PPUSH
22823: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22827: LD_ADDR_EXP 121
22831: PUSH
22832: LD_EXP 121
22836: PPUSH
22837: LD_INT 4
22839: PPUSH
22840: LD_EXP 121
22844: PUSH
22845: LD_INT 4
22847: ARRAY
22848: PPUSH
22849: LD_INT 1
22851: PPUSH
22852: CALL_OW 3
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22862: LD_INT 8
22864: PPUSH
22865: LD_EXP 18
22869: PUSH
22870: LD_INT 1
22872: ARRAY
22873: PUSH
22874: LD_VAR 0 1
22878: ARRAY
22879: PPUSH
22880: CALL_OW 471
// end ;
22884: GO 22792
22886: POP
22887: POP
// repeat wait ( 0 0$1 ) ;
22888: LD_INT 35
22890: PPUSH
22891: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22895: LD_EXP 18
22899: PUSH
22900: LD_INT 1
22902: ARRAY
22903: PPUSH
22904: LD_INT 55
22906: PUSH
22907: EMPTY
22908: LIST
22909: PPUSH
22910: CALL_OW 72
22914: PUSH
22915: LD_INT 4
22917: GREATEREQUAL
22918: IFFALSE 22888
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22920: LD_EXP 18
22924: PUSH
22925: LD_INT 1
22927: ARRAY
22928: PPUSH
22929: LD_INT 69
22931: PPUSH
22932: LD_INT 94
22934: PPUSH
22935: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22939: LD_EXP 18
22943: PUSH
22944: LD_INT 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 82
22950: PPUSH
22951: LD_INT 83
22953: PPUSH
22954: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22958: LD_EXP 18
22962: PUSH
22963: LD_INT 1
22965: ARRAY
22966: PPUSH
22967: LD_INT 77
22969: PPUSH
22970: LD_INT 69
22972: PPUSH
22973: CALL_OW 174
// wait ( 0 0$30 ) ;
22977: LD_INT 1050
22979: PPUSH
22980: CALL_OW 67
// repeat wait ( 3 ) ;
22984: LD_INT 3
22986: PPUSH
22987: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22991: LD_ADDR_VAR 0 1
22995: PUSH
22996: LD_EXP 18
23000: PUSH
23001: LD_INT 1
23003: ARRAY
23004: PUSH
23005: FOR_IN
23006: IFFALSE 23144
// begin if GetLives ( i ) < 990 then
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 256
23017: PUSH
23018: LD_INT 990
23020: LESS
23021: IFFALSE 23035
// SetLives ( i , 1000 ) ;
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_INT 1000
23030: PPUSH
23031: CALL_OW 234
// if not IsInUnit ( i ) then
23035: LD_VAR 0 1
23039: PPUSH
23040: CALL_OW 310
23044: NOT
23045: IFFALSE 23142
// begin if not HasTask ( i ) then
23047: LD_VAR 0 1
23051: PPUSH
23052: CALL_OW 314
23056: NOT
23057: IFFALSE 23074
// ComMoveXY ( i , 64 , 93 ) ;
23059: LD_VAR 0 1
23063: PPUSH
23064: LD_INT 64
23066: PPUSH
23067: LD_INT 93
23069: PPUSH
23070: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
23074: LD_VAR 0 4
23078: NOT
23079: IFFALSE 23096
23081: PUSH
23082: LD_VAR 0 1
23086: PPUSH
23087: CALL_OW 258
23091: PUSH
23092: LD_INT 1
23094: EQUAL
23095: AND
23096: IFFALSE 23142
// begin retreat := true ;
23098: LD_ADDR_VAR 0 4
23102: PUSH
23103: LD_INT 1
23105: ST_TO_ADDR
// SetTag ( i , 2 ) ;
23106: LD_VAR 0 1
23110: PPUSH
23111: LD_INT 2
23113: PPUSH
23114: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
23118: LD_VAR 0 1
23122: PPUSH
23123: LD_STRING D4a-Sol1-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
23130: LD_EXP 61
23134: PPUSH
23135: LD_STRING D4a-Pow-1
23137: PPUSH
23138: CALL_OW 88
// end ; end ; end ;
23142: GO 23005
23144: POP
23145: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
23146: LD_EXP 18
23150: PUSH
23151: LD_INT 1
23153: ARRAY
23154: PPUSH
23155: LD_INT 95
23157: PUSH
23158: LD_INT 9
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: PUSH
23170: LD_INT 4
23172: GREATEREQUAL
23173: IFFALSE 22984
// for i in powellSquadAttack [ 1 ] do
23175: LD_ADDR_VAR 0 1
23179: PUSH
23180: LD_EXP 18
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PUSH
23189: FOR_IN
23190: IFFALSE 23326
// begin if GetTag ( i ) = 2 then
23192: LD_VAR 0 1
23196: PPUSH
23197: CALL_OW 110
23201: PUSH
23202: LD_INT 2
23204: EQUAL
23205: IFFALSE 23267
// begin ComMoveXY ( i , 60 , 94 ) ;
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_INT 60
23214: PPUSH
23215: LD_INT 94
23217: PPUSH
23218: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23222: LD_VAR 0 1
23226: PPUSH
23227: LD_EXP 61
23231: PPUSH
23232: CALL_OW 179
// wait ( 0 0$3 ) ;
23236: LD_INT 105
23238: PPUSH
23239: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23243: LD_VAR 0 1
23247: PPUSH
23248: LD_STRING D4a-Sol1-2
23250: PPUSH
23251: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23255: LD_EXP 61
23259: PPUSH
23260: LD_STRING D4a-Pow-2
23262: PPUSH
23263: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23267: LD_VAR 0 1
23271: PPUSH
23272: LD_INT 0
23274: PPUSH
23275: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23279: LD_ADDR_EXP 102
23283: PUSH
23284: LD_EXP 102
23288: PPUSH
23289: LD_INT 4
23291: PPUSH
23292: LD_EXP 102
23296: PUSH
23297: LD_INT 4
23299: ARRAY
23300: PUSH
23301: LD_VAR 0 1
23305: UNION
23306: PPUSH
23307: CALL_OW 1
23311: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23312: LD_INT 8
23314: PPUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 472
// end ;
23324: GO 23189
23326: POP
23327: POP
// wait ( 1 1$00 ) ;
23328: LD_INT 2100
23330: PPUSH
23331: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23335: LD_ADDR_VAR 0 9
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 4
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 30
23352: PUSH
23353: LD_INT 32
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: LD_INT 58
23362: PUSH
23363: EMPTY
23364: LIST
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: LIST
23370: PPUSH
23371: CALL_OW 69
23375: ST_TO_ADDR
// if tmp then
23376: LD_VAR 0 2
23380: IFFALSE 23622
// begin for i := 1 to tmp do
23382: LD_ADDR_VAR 0 1
23386: PUSH
23387: DOUBLE
23388: LD_INT 1
23390: DEC
23391: ST_TO_ADDR
23392: LD_VAR 0 2
23396: PUSH
23397: FOR_TO
23398: IFFALSE 23613
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23400: LD_ADDR_EXP 102
23404: PUSH
23405: LD_EXP 102
23409: PPUSH
23410: LD_INT 4
23412: PPUSH
23413: LD_EXP 102
23417: PUSH
23418: LD_INT 4
23420: ARRAY
23421: PUSH
23422: LD_VAR 0 2
23426: PUSH
23427: LD_VAR 0 1
23431: ARRAY
23432: DIFF
23433: PPUSH
23434: CALL_OW 1
23438: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23439: LD_ADDR_VAR 0 10
23443: PUSH
23444: LD_VAR 0 2
23448: PUSH
23449: LD_VAR 0 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 310
23459: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23460: LD_VAR 0 10
23464: IFFALSE 23481
23466: PUSH
23467: LD_VAR 0 10
23471: PPUSH
23472: CALL_OW 266
23476: PUSH
23477: LD_INT 32
23479: EQUAL
23480: AND
23481: IFFALSE 23485
// continue ;
23483: GO 23397
// if t then
23485: LD_VAR 0 10
23489: IFFALSE 23506
// ComExitBuilding ( tmp [ i ] ) ;
23491: LD_VAR 0 2
23495: PUSH
23496: LD_VAR 0 1
23500: ARRAY
23501: PPUSH
23502: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23506: LD_VAR 0 2
23510: PUSH
23511: LD_VAR 0 1
23515: ARRAY
23516: PPUSH
23517: LD_VAR 0 5
23521: PUSH
23522: LD_INT 1
23524: ARRAY
23525: PPUSH
23526: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23530: LD_VAR 0 2
23534: PUSH
23535: LD_VAR 0 1
23539: ARRAY
23540: PPUSH
23541: LD_INT 1
23543: PPUSH
23544: CALL_OW 183
// if emptyTowers then
23548: LD_VAR 0 9
23552: IFFALSE 23611
// begin AddComExitBuilding ( tmp [ i ] ) ;
23554: LD_VAR 0 2
23558: PUSH
23559: LD_VAR 0 1
23563: ARRAY
23564: PPUSH
23565: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23569: LD_VAR 0 2
23573: PUSH
23574: LD_VAR 0 1
23578: ARRAY
23579: PPUSH
23580: LD_VAR 0 9
23584: PUSH
23585: LD_INT 1
23587: ARRAY
23588: PPUSH
23589: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23593: LD_ADDR_VAR 0 9
23597: PUSH
23598: LD_VAR 0 9
23602: PPUSH
23603: LD_INT 1
23605: PPUSH
23606: CALL_OW 3
23610: ST_TO_ADDR
// end ; end ;
23611: GO 23397
23613: POP
23614: POP
// wait ( 0 0$30 ) ;
23615: LD_INT 1050
23617: PPUSH
23618: CALL_OW 67
// end ; uc_side := 6 ;
23622: LD_ADDR_OWVAR 20
23626: PUSH
23627: LD_INT 6
23629: ST_TO_ADDR
// uc_nation := 3 ;
23630: LD_ADDR_OWVAR 21
23634: PUSH
23635: LD_INT 3
23637: ST_TO_ADDR
// ru := [ ] ;
23638: LD_ADDR_VAR 0 7
23642: PUSH
23643: EMPTY
23644: ST_TO_ADDR
// for i = 1 to 5 do
23645: LD_ADDR_VAR 0 1
23649: PUSH
23650: DOUBLE
23651: LD_INT 1
23653: DEC
23654: ST_TO_ADDR
23655: LD_INT 5
23657: PUSH
23658: FOR_TO
23659: IFFALSE 23779
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23661: LD_INT 22
23663: PUSH
23664: LD_INT 23
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: LD_INT 1
23673: PPUSH
23674: LD_INT 2
23676: PPUSH
23677: CALL_OW 12
23681: ARRAY
23682: PPUSH
23683: LD_INT 1
23685: PPUSH
23686: LD_INT 3
23688: PPUSH
23689: LD_INT 43
23691: PUSH
23692: LD_INT 44
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: LD_INT 1
23701: PPUSH
23702: LD_INT 2
23704: PPUSH
23705: CALL_OW 12
23709: ARRAY
23710: PPUSH
23711: LD_INT 89
23713: PPUSH
23714: CALL 75901 0 5
// un := CreateVehicle ;
23718: LD_ADDR_VAR 0 8
23722: PUSH
23723: CALL_OW 45
23727: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23728: LD_VAR 0 8
23732: PPUSH
23733: LD_INT 4
23735: PPUSH
23736: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23740: LD_VAR 0 8
23744: PPUSH
23745: LD_INT 136
23747: PPUSH
23748: LD_INT 90
23750: PPUSH
23751: LD_INT 8
23753: PPUSH
23754: LD_INT 0
23756: PPUSH
23757: CALL_OW 50
// ru := ru ^ un ;
23761: LD_ADDR_VAR 0 7
23765: PUSH
23766: LD_VAR 0 7
23770: PUSH
23771: LD_VAR 0 8
23775: ADD
23776: ST_TO_ADDR
// end ;
23777: GO 23658
23779: POP
23780: POP
// if ru then
23781: LD_VAR 0 7
23785: IFFALSE 23802
// ComAgressiveMove ( ru , 57 , 94 ) ;
23787: LD_VAR 0 7
23791: PPUSH
23792: LD_INT 57
23794: PPUSH
23795: LD_INT 94
23797: PPUSH
23798: CALL_OW 114
// wait ( 3 3$00 ) ;
23802: LD_INT 6300
23804: PPUSH
23805: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23809: LD_ADDR_VAR 0 11
23813: PUSH
23814: LD_INT 54
23816: PPUSH
23817: LD_INT 85
23819: PPUSH
23820: CALL_OW 428
23824: PPUSH
23825: CALL_OW 313
23829: ST_TO_ADDR
// t := 0 ;
23830: LD_ADDR_VAR 0 10
23834: PUSH
23835: LD_INT 0
23837: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23838: LD_ADDR_VAR 0 1
23842: PUSH
23843: LD_INT 22
23845: PUSH
23846: LD_INT 4
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 3
23855: PUSH
23856: LD_INT 58
23858: PUSH
23859: EMPTY
23860: LIST
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 30
23868: PUSH
23869: LD_INT 32
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: LIST
23880: PPUSH
23881: CALL_OW 69
23885: PUSH
23886: FOR_IN
23887: IFFALSE 24013
// begin if p + t > 5 then
23889: LD_VAR 0 11
23893: PUSH
23894: LD_VAR 0 10
23898: PLUS
23899: PUSH
23900: LD_INT 5
23902: GREATER
23903: IFFALSE 23907
// break ;
23905: GO 24013
// un := UnitsInside ( i ) ;
23907: LD_ADDR_VAR 0 8
23911: PUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 313
23921: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23922: LD_VAR 0 8
23926: PPUSH
23927: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23931: LD_VAR 0 8
23935: PPUSH
23936: LD_INT 54
23938: PPUSH
23939: LD_INT 85
23941: PPUSH
23942: CALL_OW 428
23946: PPUSH
23947: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23951: LD_VAR 0 8
23955: PPUSH
23956: LD_INT 3
23958: PPUSH
23959: CALL_OW 183
// t := Inc ( t ) ;
23963: LD_ADDR_VAR 0 10
23967: PUSH
23968: LD_VAR 0 10
23972: PPUSH
23973: CALL 110444 0 1
23977: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23978: LD_ADDR_EXP 102
23982: PUSH
23983: LD_EXP 102
23987: PPUSH
23988: LD_INT 4
23990: PPUSH
23991: LD_EXP 102
23995: PUSH
23996: LD_INT 4
23998: ARRAY
23999: PUSH
24000: LD_VAR 0 8
24004: ADD
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// end ;
24011: GO 23886
24013: POP
24014: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24015: LD_INT 4
24017: PPUSH
24018: LD_INT 3
24020: PUSH
24021: LD_INT 1
24023: PUSH
24024: LD_INT 1
24026: PUSH
24027: LD_INT 5
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 4
24038: PUSH
24039: LD_INT 1
24041: PUSH
24042: LD_INT 1
24044: PUSH
24045: LD_INT 6
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: PUSH
24054: LD_INT 4
24056: PUSH
24057: LD_INT 1
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: LD_INT 7
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: PUSH
24072: LD_INT 3
24074: PUSH
24075: LD_INT 1
24077: PUSH
24078: LD_INT 1
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 3
24092: PUSH
24093: LD_INT 1
24095: PUSH
24096: LD_INT 1
24098: PUSH
24099: LD_INT 5
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: LIST
24112: LIST
24113: LIST
24114: PPUSH
24115: CALL 64367 0 2
// missionStage := 4 ;
24119: LD_ADDR_EXP 15
24123: PUSH
24124: LD_INT 4
24126: ST_TO_ADDR
// end ;
24127: PPOPN 11
24129: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
24130: LD_EXP 15
24134: PUSH
24135: LD_INT 4
24137: EQUAL
24138: IFFALSE 24174
24140: PUSH
24141: LD_INT 22
24143: PUSH
24144: LD_INT 4
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 21
24153: PUSH
24154: LD_INT 2
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: PPUSH
24165: CALL_OW 69
24169: PUSH
24170: LD_INT 5
24172: GREATEREQUAL
24173: AND
24174: IFFALSE 28550
24176: GO 24178
24178: DISABLE
24179: LD_INT 0
24181: PPUSH
24182: PPUSH
24183: PPUSH
24184: PPUSH
24185: PPUSH
24186: PPUSH
24187: PPUSH
24188: PPUSH
24189: PPUSH
24190: PPUSH
24191: PPUSH
24192: PPUSH
24193: PPUSH
24194: PPUSH
// begin wait ( 0 0$10 ) ;
24195: LD_INT 350
24197: PPUSH
24198: CALL_OW 67
// missionStage := 5 ;
24202: LD_ADDR_EXP 15
24206: PUSH
24207: LD_INT 5
24209: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24210: LD_ADDR_VAR 0 11
24214: PUSH
24215: LD_INT 22
24217: PUSH
24218: LD_INT 4
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 2
24227: PUSH
24228: LD_INT 30
24230: PUSH
24231: LD_INT 4
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: PUSH
24238: LD_INT 30
24240: PUSH
24241: LD_INT 5
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: LIST
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PPUSH
24257: CALL_OW 69
24261: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24262: LD_ADDR_VAR 0 6
24266: PUSH
24267: LD_INT 22
24269: PUSH
24270: LD_INT 4
24272: PUSH
24273: EMPTY
24274: LIST
24275: LIST
24276: PUSH
24277: LD_INT 21
24279: PUSH
24280: LD_INT 1
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: LD_INT 25
24292: PUSH
24293: LD_INT 16
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PUSH
24304: LD_INT 3
24306: PUSH
24307: LD_INT 25
24309: PUSH
24310: LD_INT 12
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PPUSH
24327: CALL_OW 69
24331: PUSH
24332: LD_EXP 61
24336: DIFF
24337: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24338: LD_ADDR_VAR 0 10
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_INT 4
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 30
24355: PUSH
24356: LD_INT 3
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PPUSH
24367: CALL_OW 69
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24376: LD_INT 350
24378: PPUSH
24379: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24383: LD_EXP 121
24387: PUSH
24388: LD_INT 4
24390: ARRAY
24391: PUSH
24392: LD_INT 5
24394: LESS
24395: IFFALSE 24412
24397: PUSH
24398: LD_VAR 0 10
24402: PPUSH
24403: CALL_OW 461
24407: PUSH
24408: LD_INT 2
24410: EQUAL
24411: AND
24412: IFFALSE 24442
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24414: LD_INT 4
24416: PPUSH
24417: LD_INT 3
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: LD_INT 5
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: PUSH
24435: EMPTY
24436: LIST
24437: PPUSH
24438: CALL 64415 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24442: LD_EXP 121
24446: PUSH
24447: LD_INT 4
24449: ARRAY
24450: PUSH
24451: LD_INT 5
24453: GREATEREQUAL
24454: IFFALSE 24481
24456: PUSH
24457: LD_EXP 121
24461: PUSH
24462: LD_INT 4
24464: ARRAY
24465: PPUSH
24466: LD_INT 58
24468: PUSH
24469: EMPTY
24470: LIST
24471: PPUSH
24472: CALL_OW 72
24476: PUSH
24477: LD_INT 5
24479: GREATEREQUAL
24480: AND
24481: IFFALSE 24376
// powellAllowRetreat := false ;
24483: LD_ADDR_EXP 19
24487: PUSH
24488: LD_INT 0
24490: ST_TO_ADDR
// activeAttacks := false ;
24491: LD_ADDR_EXP 16
24495: PUSH
24496: LD_INT 0
24498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24499: LD_INT 35
24501: PPUSH
24502: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24506: LD_INT 22
24508: PUSH
24509: LD_INT 6
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PPUSH
24516: CALL_OW 69
24520: PUSH
24521: LD_INT 0
24523: EQUAL
24524: IFFALSE 24499
// tmp := mc_vehicles [ 4 ] ;
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: LD_EXP 121
24535: PUSH
24536: LD_INT 4
24538: ARRAY
24539: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24540: LD_ADDR_VAR 0 1
24544: PUSH
24545: DOUBLE
24546: LD_INT 1
24548: DEC
24549: ST_TO_ADDR
24550: LD_EXP 18
24554: PUSH
24555: FOR_TO
24556: IFFALSE 24880
// begin for j in powellSquadAttack [ i ] do
24558: LD_ADDR_VAR 0 2
24562: PUSH
24563: LD_EXP 18
24567: PUSH
24568: LD_VAR 0 1
24572: ARRAY
24573: PUSH
24574: FOR_IN
24575: IFFALSE 24876
// begin if j in mc_bases [ 4 ] then
24577: LD_VAR 0 2
24581: PUSH
24582: LD_EXP 102
24586: PUSH
24587: LD_INT 4
24589: ARRAY
24590: IN
24591: IFFALSE 24626
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24593: LD_ADDR_EXP 102
24597: PUSH
24598: LD_EXP 102
24602: PPUSH
24603: LD_INT 4
24605: PPUSH
24606: LD_EXP 102
24610: PUSH
24611: LD_INT 4
24613: ARRAY
24614: PUSH
24615: LD_VAR 0 2
24619: DIFF
24620: PPUSH
24621: CALL_OW 1
24625: ST_TO_ADDR
// forces := forces diff j ;
24626: LD_ADDR_VAR 0 6
24630: PUSH
24631: LD_VAR 0 6
24635: PUSH
24636: LD_VAR 0 2
24640: DIFF
24641: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24642: LD_VAR 0 2
24646: PPUSH
24647: LD_INT 1
24649: PPUSH
24650: CALL_OW 109
// wait ( 0 0$2 ) ;
24654: LD_INT 70
24656: PPUSH
24657: CALL_OW 67
// if IsInUnit ( j ) then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 310
24670: IFFALSE 24681
// ComExitBuilding ( j ) ;
24672: LD_VAR 0 2
24676: PPUSH
24677: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24681: LD_VAR 0 2
24685: PPUSH
24686: CALL_OW 257
24690: PUSH
24691: LD_INT 1
24693: NONEQUAL
24694: IFFALSE 24708
24696: PUSH
24697: LD_VAR 0 2
24701: PPUSH
24702: CALL_OW 314
24706: NOT
24707: AND
24708: IFFALSE 24788
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24710: LD_VAR 0 11
24714: PUSH
24715: LD_INT 1
24717: ARRAY
24718: PPUSH
24719: CALL_OW 313
24723: PUSH
24724: LD_INT 5
24726: GREATEREQUAL
24727: IFFALSE 24749
// ComEnterUnit ( j , arm [ 2 ] ) else
24729: LD_VAR 0 2
24733: PPUSH
24734: LD_VAR 0 11
24738: PUSH
24739: LD_INT 2
24741: ARRAY
24742: PPUSH
24743: CALL_OW 120
24747: GO 24767
// ComEnterUnit ( j , arm [ 1 ] ) ;
24749: LD_VAR 0 2
24753: PPUSH
24754: LD_VAR 0 11
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PPUSH
24763: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24767: LD_VAR 0 2
24771: PPUSH
24772: LD_INT 1
24774: PPUSH
24775: CALL_OW 183
// AddComExitBuilding ( j ) ;
24779: LD_VAR 0 2
24783: PPUSH
24784: CALL_OW 182
// end ; if i = 2 then
24788: LD_VAR 0 1
24792: PUSH
24793: LD_INT 2
24795: EQUAL
24796: IFFALSE 24813
// AddComMoveXY ( j , 61 , 93 ) ;
24798: LD_VAR 0 2
24802: PPUSH
24803: LD_INT 61
24805: PPUSH
24806: LD_INT 93
24808: PPUSH
24809: CALL_OW 171
// if i = 1 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 1
24820: EQUAL
24821: IFFALSE 24874
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24823: LD_VAR 0 2
24827: PPUSH
24828: LD_VAR 0 3
24832: PUSH
24833: LD_INT 1
24835: ARRAY
24836: PPUSH
24837: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24841: LD_ADDR_VAR 0 3
24845: PUSH
24846: LD_VAR 0 3
24850: PPUSH
24851: LD_INT 1
24853: PPUSH
24854: CALL_OW 3
24858: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24859: LD_VAR 0 2
24863: PPUSH
24864: LD_INT 69
24866: PPUSH
24867: LD_INT 94
24869: PPUSH
24870: CALL_OW 171
// end ; end ;
24874: GO 24574
24876: POP
24877: POP
// end ;
24878: GO 24555
24880: POP
24881: POP
// wait ( 0 0$30 ) ;
24882: LD_INT 1050
24884: PPUSH
24885: CALL_OW 67
// MC_Kill ( 4 ) ;
24889: LD_INT 4
24891: PPUSH
24892: CALL 40134 0 1
// tmp := UnitsInside ( fac ) ;
24896: LD_ADDR_VAR 0 3
24900: PUSH
24901: LD_VAR 0 10
24905: PPUSH
24906: CALL_OW 313
24910: ST_TO_ADDR
// if tmp then
24911: LD_VAR 0 3
24915: IFFALSE 25036
// for i in tmp do
24917: LD_ADDR_VAR 0 1
24921: PUSH
24922: LD_VAR 0 3
24926: PUSH
24927: FOR_IN
24928: IFFALSE 25034
// begin ComExitBuilding ( i ) ;
24930: LD_VAR 0 1
24934: PPUSH
24935: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24939: LD_VAR 0 11
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 313
24952: PUSH
24953: LD_INT 6
24955: LESS
24956: IFFALSE 24978
// AddComEnterUnit ( i , arm [ 2 ] ) else
24958: LD_VAR 0 1
24962: PPUSH
24963: LD_VAR 0 11
24967: PUSH
24968: LD_INT 2
24970: ARRAY
24971: PPUSH
24972: CALL_OW 180
24976: GO 25032
// if UnitsInside ( arm [ 1 ] ) < 6 then
24978: LD_VAR 0 11
24982: PUSH
24983: LD_INT 1
24985: ARRAY
24986: PPUSH
24987: CALL_OW 313
24991: PUSH
24992: LD_INT 6
24994: LESS
24995: IFFALSE 25017
// AddComEnterUnit ( i , arm [ 1 ] ) else
24997: LD_VAR 0 1
25001: PPUSH
25002: LD_VAR 0 11
25006: PUSH
25007: LD_INT 1
25009: ARRAY
25010: PPUSH
25011: CALL_OW 180
25015: GO 25032
// AddComMoveXY ( i , 37 , 68 ) ;
25017: LD_VAR 0 1
25021: PPUSH
25022: LD_INT 37
25024: PPUSH
25025: LD_INT 68
25027: PPUSH
25028: CALL_OW 171
// end ;
25032: GO 24927
25034: POP
25035: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
25036: LD_ADDR_VAR 0 12
25040: PUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: LD_INT 26
25048: PUSH
25049: LD_INT 1
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PPUSH
25056: CALL_OW 72
25060: PUSH
25061: LD_EXP 62
25065: DIFF
25066: ST_TO_ADDR
// if not speaker then
25067: LD_VAR 0 12
25071: NOT
25072: IFFALSE 25099
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
25074: LD_ADDR_VAR 0 12
25078: PUSH
25079: LD_VAR 0 6
25083: PPUSH
25084: LD_INT 26
25086: PUSH
25087: LD_INT 1
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PPUSH
25094: CALL_OW 72
25098: ST_TO_ADDR
// if speaker then
25099: LD_VAR 0 12
25103: IFFALSE 25119
// speaker := speaker [ 1 ] ;
25105: LD_ADDR_VAR 0 12
25109: PUSH
25110: LD_VAR 0 12
25114: PUSH
25115: LD_INT 1
25117: ARRAY
25118: ST_TO_ADDR
// Video ( true ) ;
25119: LD_INT 1
25121: PPUSH
25122: CALL 109043 0 1
// CenterNowOnUnits ( Powell ) ;
25126: LD_EXP 61
25130: PPUSH
25131: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
25135: LD_ADDR_VAR 0 3
25139: PUSH
25140: LD_VAR 0 6
25144: PPUSH
25145: LD_INT 3
25147: PUSH
25148: LD_INT 25
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PPUSH
25162: CALL_OW 72
25166: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
25167: LD_ADDR_VAR 0 13
25171: PUSH
25172: LD_INT 22
25174: PUSH
25175: LD_INT 4
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 32
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: LD_INT 58
25194: PUSH
25195: EMPTY
25196: LIST
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: PPUSH
25203: CALL_OW 69
25207: ST_TO_ADDR
// t := Count ( tmp ) ;
25208: LD_ADDR_VAR 0 7
25212: PUSH
25213: LD_VAR 0 3
25217: PPUSH
25218: CALL 73139 0 1
25222: ST_TO_ADDR
// if t > 4 then
25223: LD_VAR 0 7
25227: PUSH
25228: LD_INT 4
25230: GREATER
25231: IFFALSE 25241
// t := 4 ;
25233: LD_ADDR_VAR 0 7
25237: PUSH
25238: LD_INT 4
25240: ST_TO_ADDR
// for i := 1 to t do
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: DOUBLE
25247: LD_INT 1
25249: DEC
25250: ST_TO_ADDR
25251: LD_VAR 0 7
25255: PUSH
25256: FOR_TO
25257: IFFALSE 25403
// begin if IsInUnit ( tmp [ i ] ) then
25259: LD_VAR 0 3
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: CALL_OW 310
25274: IFFALSE 25291
// ComExitBuilding ( tmp [ i ] ) ;
25276: LD_VAR 0 3
25280: PUSH
25281: LD_VAR 0 1
25285: ARRAY
25286: PPUSH
25287: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25291: LD_VAR 0 3
25295: PUSH
25296: LD_VAR 0 1
25300: ARRAY
25301: PPUSH
25302: LD_VAR 0 11
25306: PUSH
25307: LD_INT 1
25309: ARRAY
25310: PPUSH
25311: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25315: LD_VAR 0 3
25319: PUSH
25320: LD_VAR 0 1
25324: ARRAY
25325: PPUSH
25326: LD_INT 1
25328: PPUSH
25329: CALL_OW 183
// if Count ( emp_towers ) then
25333: LD_VAR 0 13
25337: PPUSH
25338: CALL 73139 0 1
25342: IFFALSE 25401
// begin AddComExitBuilding ( tmp [ i ] ) ;
25344: LD_VAR 0 3
25348: PUSH
25349: LD_VAR 0 1
25353: ARRAY
25354: PPUSH
25355: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25359: LD_VAR 0 3
25363: PUSH
25364: LD_VAR 0 1
25368: ARRAY
25369: PPUSH
25370: LD_VAR 0 13
25374: PUSH
25375: LD_INT 1
25377: ARRAY
25378: PPUSH
25379: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25383: LD_ADDR_VAR 0 13
25387: PUSH
25388: LD_VAR 0 13
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 3
25400: ST_TO_ADDR
// end ; end ;
25401: GO 25256
25403: POP
25404: POP
// wait ( 0 0$5 ) ;
25405: LD_INT 175
25407: PPUSH
25408: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25412: LD_VAR 0 3
25416: PPUSH
25417: LD_INT 3
25419: PUSH
25420: LD_INT 54
25422: PUSH
25423: EMPTY
25424: LIST
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PPUSH
25430: CALL_OW 72
25434: IFFALSE 25454
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25436: LD_VAR 0 3
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25454: LD_ADDR_VAR 0 3
25458: PUSH
25459: LD_EXP 18
25463: PUSH
25464: LD_INT 1
25466: ARRAY
25467: PUSH
25468: LD_EXP 18
25472: PUSH
25473: LD_INT 2
25475: ARRAY
25476: ADD
25477: PPUSH
25478: LD_INT 26
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25493: LD_ADDR_VAR 0 1
25497: PUSH
25498: LD_EXP 18
25502: PUSH
25503: LD_INT 2
25505: ARRAY
25506: PUSH
25507: FOR_IN
25508: IFFALSE 25526
// ComTurnUnit ( i , Powell ) ;
25510: LD_VAR 0 1
25514: PPUSH
25515: LD_EXP 61
25519: PPUSH
25520: CALL_OW 119
25524: GO 25507
25526: POP
25527: POP
// Say ( Powell , D5-Pow-1 ) ;
25528: LD_EXP 61
25532: PPUSH
25533: LD_STRING D5-Pow-1
25535: PPUSH
25536: CALL_OW 88
// if tmp then
25540: LD_VAR 0 3
25544: IFFALSE 25562
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25546: LD_VAR 0 3
25550: PUSH
25551: LD_INT 1
25553: ARRAY
25554: PPUSH
25555: LD_STRING D5-Sol2-1
25557: PPUSH
25558: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25562: LD_EXP 61
25566: PPUSH
25567: LD_STRING D5-Pow-2
25569: PPUSH
25570: CALL_OW 88
// if tmp > 1 then
25574: LD_VAR 0 3
25578: PUSH
25579: LD_INT 1
25581: GREATER
25582: IFFALSE 25600
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 2
25591: ARRAY
25592: PPUSH
25593: LD_STRING D5-Sol2-2
25595: PPUSH
25596: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25600: LD_EXP 61
25604: PPUSH
25605: LD_STRING D5-Pow-3
25607: PPUSH
25608: CALL_OW 88
// wait ( 0 0$1 ) ;
25612: LD_INT 35
25614: PPUSH
25615: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25619: LD_ADDR_VAR 0 3
25623: PUSH
25624: LD_EXP 18
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PUSH
25633: LD_EXP 18
25637: PUSH
25638: LD_INT 2
25640: ARRAY
25641: UNION
25642: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25643: LD_VAR 0 3
25647: PPUSH
25648: LD_INT 80
25650: PPUSH
25651: LD_INT 67
25653: PPUSH
25654: CALL_OW 114
// wait ( 0 0$2 ) ;
25658: LD_INT 70
25660: PPUSH
25661: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25665: LD_INT 79
25667: PPUSH
25668: LD_INT 72
25670: PPUSH
25671: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25675: LD_INT 70
25677: PPUSH
25678: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25682: LD_VAR 0 3
25686: PPUSH
25687: LD_INT 3
25689: PUSH
25690: LD_INT 24
25692: PUSH
25693: LD_INT 1000
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PPUSH
25704: CALL_OW 72
25708: IFFALSE 25675
// Say ( Powell , D5a-Pow-1 ) ;
25710: LD_EXP 61
25714: PPUSH
25715: LD_STRING D5a-Pow-1
25717: PPUSH
25718: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25722: LD_EXP 61
25726: PPUSH
25727: LD_STRING D5a-Pow-1a
25729: PPUSH
25730: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25734: LD_INT 24
25736: PPUSH
25737: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25741: LD_EXP 61
25745: PPUSH
25746: LD_STRING D5a-Pow-1b
25748: PPUSH
25749: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25753: LD_INT 10
25755: PPUSH
25756: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25760: LD_EXP 61
25764: PPUSH
25765: LD_STRING D5a-Pow-1c
25767: PPUSH
25768: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25772: LD_VAR 0 3
25776: PPUSH
25777: LD_INT 68
25779: PPUSH
25780: LD_INT 63
25782: PPUSH
25783: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25787: LD_INT 18
25789: PPUSH
25790: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25794: LD_EXP 61
25798: PPUSH
25799: LD_STRING D5a-Pow-1d
25801: PPUSH
25802: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25806: LD_INT 35
25808: PPUSH
25809: CALL_OW 67
// if not HasTask ( tmp ) then
25813: LD_VAR 0 3
25817: PPUSH
25818: CALL_OW 314
25822: NOT
25823: IFFALSE 25840
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 68
25832: PPUSH
25833: LD_INT 63
25835: PPUSH
25836: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25840: LD_VAR 0 3
25844: PPUSH
25845: LD_INT 24
25847: PUSH
25848: LD_INT 1
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PPUSH
25855: CALL_OW 72
25859: NOT
25860: IFFALSE 25806
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25862: LD_ADDR_VAR 0 3
25866: PUSH
25867: LD_INT 22
25869: PUSH
25870: LD_INT 4
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 92
25879: PUSH
25880: LD_INT 60
25882: PUSH
25883: LD_INT 93
25885: PUSH
25886: LD_INT 10
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 3
25897: PUSH
25898: LD_INT 54
25900: PUSH
25901: EMPTY
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 69
25917: PUSH
25918: LD_EXP 61
25922: DIFF
25923: ST_TO_ADDR
// if tmp then
25924: LD_VAR 0 3
25928: IFFALSE 25962
// for i in tmp do
25930: LD_ADDR_VAR 0 1
25934: PUSH
25935: LD_VAR 0 3
25939: PUSH
25940: FOR_IN
25941: IFFALSE 25960
// ComMoveXY ( i , 36 , 67 ) ;
25943: LD_VAR 0 1
25947: PPUSH
25948: LD_INT 36
25950: PPUSH
25951: LD_INT 67
25953: PPUSH
25954: CALL_OW 111
25958: GO 25940
25960: POP
25961: POP
// wait ( 0 0$3 ) ;
25962: LD_INT 105
25964: PPUSH
25965: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25969: LD_VAR 0 12
25973: PPUSH
25974: LD_STRING D6-Sol3-1
25976: PPUSH
25977: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25981: LD_EXP 61
25985: PPUSH
25986: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25990: LD_EXP 61
25994: PPUSH
25995: LD_STRING D6-Pow-1
25997: PPUSH
25998: CALL_OW 88
// tmp := [ ] ;
26002: LD_ADDR_VAR 0 3
26006: PUSH
26007: EMPTY
26008: ST_TO_ADDR
// for i = 1 to 2 do
26009: LD_ADDR_VAR 0 1
26013: PUSH
26014: DOUBLE
26015: LD_INT 1
26017: DEC
26018: ST_TO_ADDR
26019: LD_INT 2
26021: PUSH
26022: FOR_TO
26023: IFFALSE 26137
// begin uc_side := 8 ;
26025: LD_ADDR_OWVAR 20
26029: PUSH
26030: LD_INT 8
26032: ST_TO_ADDR
// uc_nation := 2 ;
26033: LD_ADDR_OWVAR 21
26037: PUSH
26038: LD_INT 2
26040: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
26041: LD_INT 14
26043: PPUSH
26044: LD_INT 3
26046: PPUSH
26047: LD_INT 2
26049: PPUSH
26050: LD_INT 29
26052: PPUSH
26053: LD_INT 100
26055: PPUSH
26056: CALL 75901 0 5
// veh := CreateVehicle ;
26060: LD_ADDR_VAR 0 14
26064: PUSH
26065: CALL_OW 45
26069: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
26070: LD_VAR 0 14
26074: PPUSH
26075: LD_INT 4
26077: PPUSH
26078: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
26082: LD_VAR 0 14
26086: PPUSH
26087: LD_INT 99
26089: PPUSH
26090: LD_INT 83
26092: PPUSH
26093: LD_INT 3
26095: PPUSH
26096: LD_INT 0
26098: PPUSH
26099: CALL_OW 50
// wait ( 3 ) ;
26103: LD_INT 3
26105: PPUSH
26106: CALL_OW 67
// Connect ( veh ) ;
26110: LD_VAR 0 14
26114: PPUSH
26115: CALL 79383 0 1
// tmp := tmp ^ veh ;
26119: LD_ADDR_VAR 0 3
26123: PUSH
26124: LD_VAR 0 3
26128: PUSH
26129: LD_VAR 0 14
26133: ADD
26134: ST_TO_ADDR
// end ;
26135: GO 26022
26137: POP
26138: POP
// wait ( 0 0$1 ) ;
26139: LD_INT 35
26141: PPUSH
26142: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
26146: LD_INT 99
26148: PPUSH
26149: LD_INT 83
26151: PPUSH
26152: LD_INT 1
26154: PPUSH
26155: LD_INT 10
26157: PPUSH
26158: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
26162: LD_INT 99
26164: PPUSH
26165: LD_INT 83
26167: PPUSH
26168: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
26172: LD_VAR 0 12
26176: PPUSH
26177: LD_STRING D6-Sol3-2
26179: PPUSH
26180: CALL_OW 88
// async ;
26184: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
26185: LD_EXP 61
26189: PPUSH
26190: LD_STRING D6-Pow-2
26192: PPUSH
26193: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
26197: LD_VAR 0 3
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: PPUSH
26206: LD_VAR 0 10
26210: PPUSH
26211: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26215: LD_VAR 0 3
26219: PUSH
26220: LD_INT 2
26222: ARRAY
26223: PPUSH
26224: LD_INT 22
26226: PUSH
26227: LD_INT 4
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 21
26236: PUSH
26237: LD_INT 3
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PPUSH
26248: CALL_OW 69
26252: PPUSH
26253: LD_VAR 0 3
26257: PUSH
26258: LD_INT 2
26260: ARRAY
26261: PPUSH
26262: CALL_OW 74
26266: PPUSH
26267: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26271: LD_EXP 61
26275: PPUSH
26276: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26280: LD_INT 99
26282: PPUSH
26283: LD_INT 83
26285: PPUSH
26286: LD_INT 1
26288: PPUSH
26289: CALL_OW 331
// repeat wait ( 4 ) ;
26293: LD_INT 4
26295: PPUSH
26296: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26300: LD_VAR 0 3
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: PPUSH
26309: CALL_OW 256
26313: PUSH
26314: LD_INT 1000
26316: LESS
26317: IFFALSE 26335
// SetLives ( tmp [ 1 ] , 1000 ) ;
26319: LD_VAR 0 3
26323: PUSH
26324: LD_INT 1
26326: ARRAY
26327: PPUSH
26328: LD_INT 1000
26330: PPUSH
26331: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26335: LD_INT 22
26337: PUSH
26338: LD_INT 4
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: LD_INT 30
26347: PUSH
26348: LD_INT 3
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PPUSH
26359: CALL_OW 69
26363: PUSH
26364: LD_INT 0
26366: EQUAL
26367: IFFALSE 26293
// skirmish := false ;
26369: LD_ADDR_EXP 100
26373: PUSH
26374: LD_INT 0
26376: ST_TO_ADDR
// sync ;
26377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26378: LD_EXP 61
26382: PPUSH
26383: LD_STRING D6a-Pow-1
26385: PPUSH
26386: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26390: LD_VAR 0 12
26394: PPUSH
26395: LD_STRING D6a-Sol3-1
26397: PPUSH
26398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26402: LD_EXP 61
26406: PPUSH
26407: LD_STRING D6a-Pow-2
26409: PPUSH
26410: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26414: LD_VAR 0 12
26418: PPUSH
26419: LD_STRING D6a-Sol3-2
26421: PPUSH
26422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26426: LD_EXP 61
26430: PPUSH
26431: LD_STRING D6a-Pow-3
26433: PPUSH
26434: CALL_OW 88
// powellCenterCameraMode := true ;
26438: LD_ADDR_EXP 20
26442: PUSH
26443: LD_INT 1
26445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26446: LD_ADDR_VAR 0 1
26450: PUSH
26451: LD_INT 22
26453: PUSH
26454: LD_INT 8
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 25
26463: PUSH
26464: LD_INT 2
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PPUSH
26475: CALL_OW 69
26479: PUSH
26480: FOR_IN
26481: IFFALSE 26536
// begin SetTag ( i , 1 ) ;
26483: LD_VAR 0 1
26487: PPUSH
26488: LD_INT 1
26490: PPUSH
26491: CALL_OW 109
// ComExitBuilding ( i ) ;
26495: LD_VAR 0 1
26499: PPUSH
26500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26504: LD_VAR 0 1
26508: PPUSH
26509: LD_INT 35
26511: PPUSH
26512: LD_INT 6
26514: PPUSH
26515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26519: LD_VAR 0 1
26523: PPUSH
26524: LD_INT 53
26526: PPUSH
26527: LD_INT 4
26529: PPUSH
26530: CALL_OW 171
// end ;
26534: GO 26480
26536: POP
26537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26538: LD_ADDR_VAR 0 3
26542: PUSH
26543: LD_INT 22
26545: PUSH
26546: LD_INT 4
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 21
26555: PUSH
26556: LD_INT 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 3
26565: PUSH
26566: LD_INT 34
26568: PUSH
26569: LD_INT 12
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: PPUSH
26585: CALL_OW 69
26589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26590: LD_EXP 61
26594: PPUSH
26595: LD_VAR 0 3
26599: PPUSH
26600: LD_EXP 61
26604: PPUSH
26605: CALL_OW 74
26609: PPUSH
26610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26614: LD_EXP 61
26618: PPUSH
26619: LD_INT 100
26621: PPUSH
26622: LD_INT 88
26624: PPUSH
26625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26629: LD_EXP 61
26633: PPUSH
26634: LD_INT 100
26636: PPUSH
26637: LD_INT 75
26639: PPUSH
26640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26644: LD_EXP 61
26648: PPUSH
26649: LD_INT 88
26651: PPUSH
26652: LD_INT 53
26654: PPUSH
26655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26659: LD_INT 8
26661: PPUSH
26662: LD_EXP 61
26666: PPUSH
26667: CALL_OW 471
// repeat wait ( 3 ) ;
26671: LD_INT 3
26673: PPUSH
26674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26678: LD_INT 22
26680: PUSH
26681: LD_INT 4
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 92
26690: PUSH
26691: LD_INT 100
26693: PUSH
26694: LD_INT 75
26696: PUSH
26697: LD_INT 6
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PPUSH
26710: CALL_OW 69
26714: IFFALSE 26671
// async ;
26716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26717: LD_EXP 61
26721: PPUSH
26722: LD_STRING D6b-Pow-1
26724: PPUSH
26725: CALL_OW 88
// repeat wait ( 3 ) ;
26729: LD_INT 3
26731: PPUSH
26732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26736: LD_EXP 61
26740: PPUSH
26741: CALL_OW 310
26745: PPUSH
26746: CALL_OW 256
26750: PUSH
26751: LD_INT 1000
26753: LESS
26754: IFFALSE 26773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26756: LD_EXP 61
26760: PPUSH
26761: CALL_OW 310
26765: PPUSH
26766: LD_INT 1000
26768: PPUSH
26769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26773: LD_EXP 61
26777: PPUSH
26778: CALL_OW 256
26782: PUSH
26783: LD_INT 1000
26785: LESS
26786: IFFALSE 26800
// SetLives ( Powell , 1000 ) ;
26788: LD_EXP 61
26792: PPUSH
26793: LD_INT 1000
26795: PPUSH
26796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26800: LD_EXP 61
26804: PPUSH
26805: LD_EXP 67
26809: PPUSH
26810: CALL_OW 296
26814: PUSH
26815: LD_INT 5
26817: LESS
26818: IFTRUE 26845
26820: PUSH
26821: LD_EXP 61
26825: PPUSH
26826: CALL_OW 310
26830: PPUSH
26831: LD_EXP 67
26835: PPUSH
26836: CALL_OW 296
26840: PUSH
26841: LD_INT 5
26843: LESS
26844: OR
26845: IFFALSE 26864
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26847: LD_EXP 61
26851: PPUSH
26852: CALL_OW 310
26856: PPUSH
26857: LD_INT 100
26859: PPUSH
26860: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26864: LD_EXP 61
26868: PPUSH
26869: CALL_OW 310
26873: NOT
26874: IFFALSE 26729
// DoNotAttack ( 8 , powellBomb ) ;
26876: LD_INT 8
26878: PPUSH
26879: LD_EXP 67
26883: PPUSH
26884: CALL_OW 471
// game_speed := 4 ;
26888: LD_ADDR_OWVAR 65
26892: PUSH
26893: LD_INT 4
26895: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26896: LD_EXP 61
26900: PPUSH
26901: LD_STRING D6b-Pow-1a
26903: PPUSH
26904: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26908: LD_EXP 61
26912: PPUSH
26913: LD_EXP 67
26917: PPUSH
26918: CALL_OW 180
// sync ;
26922: SYNC
// repeat wait ( 0 0$1 ) ;
26923: LD_INT 35
26925: PPUSH
26926: CALL_OW 67
// until IsInUnit ( Powell ) ;
26930: LD_EXP 61
26934: PPUSH
26935: CALL_OW 310
26939: IFFALSE 26923
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26941: LD_INT 8
26943: PPUSH
26944: LD_EXP 61
26948: PPUSH
26949: CALL_OW 310
26953: PPUSH
26954: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26958: LD_EXP 61
26962: PPUSH
26963: LD_INT 91
26965: PPUSH
26966: LD_INT 44
26968: PPUSH
26969: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26973: LD_EXP 61
26977: PPUSH
26978: LD_INT 96
26980: PPUSH
26981: LD_INT 44
26983: PPUSH
26984: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26988: LD_EXP 61
26992: PPUSH
26993: LD_INT 96
26995: PPUSH
26996: LD_INT 41
26998: PPUSH
26999: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27003: LD_EXP 61
27007: PPUSH
27008: LD_INT 92
27010: PPUSH
27011: LD_INT 39
27013: PPUSH
27014: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27018: LD_EXP 61
27022: PPUSH
27023: LD_INT 88
27025: PPUSH
27026: LD_INT 41
27028: PPUSH
27029: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27033: LD_EXP 61
27037: PPUSH
27038: LD_INT 91
27040: PPUSH
27041: LD_INT 44
27043: PPUSH
27044: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
27048: LD_EXP 61
27052: PPUSH
27053: LD_INT 96
27055: PPUSH
27056: LD_INT 44
27058: PPUSH
27059: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
27063: LD_EXP 61
27067: PPUSH
27068: LD_INT 96
27070: PPUSH
27071: LD_INT 41
27073: PPUSH
27074: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27078: LD_EXP 61
27082: PPUSH
27083: LD_INT 92
27085: PPUSH
27086: LD_INT 39
27088: PPUSH
27089: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27093: LD_EXP 61
27097: PPUSH
27098: LD_INT 88
27100: PPUSH
27101: LD_INT 41
27103: PPUSH
27104: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27108: LD_EXP 61
27112: PPUSH
27113: LD_INT 91
27115: PPUSH
27116: LD_INT 44
27118: PPUSH
27119: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
27123: LD_EXP 61
27127: PPUSH
27128: LD_INT 93
27130: PPUSH
27131: LD_INT 39
27133: PPUSH
27134: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
27138: LD_EXP 61
27142: PPUSH
27143: LD_INT 93
27145: PPUSH
27146: LD_INT 36
27148: PPUSH
27149: CALL_OW 171
// wait ( 0 0$3.5 ) ;
27153: LD_INT 122
27155: PPUSH
27156: CALL_OW 67
// game_speed := 4 ;
27160: LD_ADDR_OWVAR 65
27164: PUSH
27165: LD_INT 4
27167: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
27168: LD_EXP 61
27172: PPUSH
27173: LD_STRING D6b-Pow-1b
27175: PPUSH
27176: CALL_OW 88
// tmp := [ ] ;
27180: LD_ADDR_VAR 0 3
27184: PUSH
27185: EMPTY
27186: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
27187: LD_ADDR_VAR 0 5
27191: PUSH
27192: LD_INT 78
27194: PUSH
27195: LD_INT 47
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 106
27204: PUSH
27205: LD_INT 53
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27216: LD_ADDR_VAR 0 1
27220: PUSH
27221: LD_INT 22
27223: PUSH
27224: LD_INT 8
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 21
27233: PUSH
27234: LD_INT 3
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 92
27243: PUSH
27244: LD_INT 90
27246: PUSH
27247: LD_INT 52
27249: PUSH
27250: LD_INT 12
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: LIST
27257: LIST
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: PPUSH
27264: CALL_OW 69
27268: PUSH
27269: FOR_IN
27270: IFFALSE 27295
// tmp := tmp ^ UnitsInside ( i ) ;
27272: LD_ADDR_VAR 0 3
27276: PUSH
27277: LD_VAR 0 3
27281: PUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: CALL_OW 313
27291: ADD
27292: ST_TO_ADDR
27293: GO 27269
27295: POP
27296: POP
// for i in tmp do
27297: LD_ADDR_VAR 0 1
27301: PUSH
27302: LD_VAR 0 3
27306: PUSH
27307: FOR_IN
27308: IFFALSE 27470
// begin dist := 9999 ;
27310: LD_ADDR_VAR 0 9
27314: PUSH
27315: LD_INT 9999
27317: ST_TO_ADDR
// _xy := [ ] ;
27318: LD_ADDR_VAR 0 8
27322: PUSH
27323: EMPTY
27324: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: CALL_OW 109
// ComExitBuilding ( i ) ;
27337: LD_VAR 0 1
27341: PPUSH
27342: CALL_OW 122
// for j in xy do
27346: LD_ADDR_VAR 0 2
27350: PUSH
27351: LD_VAR 0 5
27355: PUSH
27356: FOR_IN
27357: IFFALSE 27439
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_VAR 0 2
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: LD_VAR 0 2
27377: PUSH
27378: LD_INT 2
27380: ARRAY
27381: PPUSH
27382: CALL_OW 297
27386: PUSH
27387: LD_VAR 0 9
27391: LESS
27392: IFFALSE 27437
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27394: LD_ADDR_VAR 0 9
27398: PUSH
27399: LD_VAR 0 1
27403: PPUSH
27404: LD_VAR 0 2
27408: PUSH
27409: LD_INT 1
27411: ARRAY
27412: PPUSH
27413: LD_VAR 0 2
27417: PUSH
27418: LD_INT 2
27420: ARRAY
27421: PPUSH
27422: CALL_OW 297
27426: ST_TO_ADDR
// _xy := j ;
27427: LD_ADDR_VAR 0 8
27431: PUSH
27432: LD_VAR 0 2
27436: ST_TO_ADDR
// end ;
27437: GO 27356
27439: POP
27440: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27441: LD_VAR 0 1
27445: PPUSH
27446: LD_VAR 0 8
27450: PUSH
27451: LD_INT 1
27453: ARRAY
27454: PPUSH
27455: LD_VAR 0 8
27459: PUSH
27460: LD_INT 2
27462: ARRAY
27463: PPUSH
27464: CALL_OW 171
// end ;
27468: GO 27307
27470: POP
27471: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27472: LD_ADDR_VAR 0 4
27476: PUSH
27477: LD_VAR 0 3
27481: PPUSH
27482: LD_INT 26
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 25
27494: PUSH
27495: LD_INT 1
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PPUSH
27506: CALL_OW 72
27510: ST_TO_ADDR
// if tmp2 < 2 then
27511: LD_VAR 0 4
27515: PUSH
27516: LD_INT 2
27518: LESS
27519: IFFALSE 27588
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27521: LD_ADDR_VAR 0 4
27525: PUSH
27526: LD_INT 22
27528: PUSH
27529: LD_INT 8
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 26
27538: PUSH
27539: LD_INT 1
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: LD_INT 25
27551: PUSH
27552: LD_INT 15
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: PPUSH
27568: CALL_OW 69
27572: PUSH
27573: LD_EXP 64
27577: PUSH
27578: LD_EXP 65
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: DIFF
27587: ST_TO_ADDR
// if tmp2 then
27588: LD_VAR 0 4
27592: IFFALSE 27610
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27594: LD_VAR 0 4
27598: PUSH
27599: LD_INT 1
27601: ARRAY
27602: PPUSH
27603: LD_STRING D6b-ArSol1-1
27605: PPUSH
27606: CALL_OW 88
// async ;
27610: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27611: LD_EXP 61
27615: PPUSH
27616: LD_STRING D6b-Pow-2
27618: PPUSH
27619: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27623: LD_INT 18
27625: PPUSH
27626: CALL_OW 67
// if tmp2 > 1 then
27630: LD_VAR 0 4
27634: PUSH
27635: LD_INT 1
27637: GREATER
27638: IFFALSE 27656
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27640: LD_VAR 0 4
27644: PUSH
27645: LD_INT 2
27647: ARRAY
27648: PPUSH
27649: LD_STRING D6b-ArSol2-1
27651: PPUSH
27652: CALL_OW 88
// sync ;
27656: SYNC
// repeat wait ( 5 ) ;
27657: LD_INT 5
27659: PPUSH
27660: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27664: LD_INT 93
27666: PPUSH
27667: LD_INT 36
27669: PPUSH
27670: CALL_OW 428
27674: PPUSH
27675: CALL_OW 255
27679: PUSH
27680: LD_INT 4
27682: EQUAL
27683: IFFALSE 27657
// DialogueOn ;
27685: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27689: LD_INT 10
27691: PPUSH
27692: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27696: LD_EXP 61
27700: PPUSH
27701: LD_STRING D6b-Pow-2a
27703: PPUSH
27704: CALL_OW 88
// DialogueOff ;
27708: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27712: LD_EXP 61
27716: PPUSH
27717: CALL_OW 310
27721: PPUSH
27722: LD_INT 332
27724: PPUSH
27725: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27729: LD_INT 93
27731: PPUSH
27732: LD_INT 35
27734: PPUSH
27735: LD_INT 1
27737: PPUSH
27738: LD_INT 6
27740: NEG
27741: PPUSH
27742: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27746: LD_INT 35
27748: PPUSH
27749: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27753: LD_INT 332
27755: PPUSH
27756: CALL_OW 256
27760: PUSH
27761: LD_INT 1000
27763: LESS
27764: IFFALSE 27775
27766: PUSH
27767: LD_INT 332
27769: PPUSH
27770: CALL_OW 300
27774: AND
27775: IFFALSE 27787
// SetLives ( kozlov_fac , 0 ) ;
27777: LD_INT 332
27779: PPUSH
27780: LD_INT 0
27782: PPUSH
27783: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27787: LD_INT 332
27789: PPUSH
27790: CALL_OW 301
27794: IFTRUE 27807
27796: PUSH
27797: LD_EXP 61
27801: PPUSH
27802: CALL_OW 301
27806: OR
27807: IFFALSE 27746
// game_speed := 4 ;
27809: LD_ADDR_OWVAR 65
27813: PUSH
27814: LD_INT 4
27816: ST_TO_ADDR
// powellCenterCameraMode := false ;
27817: LD_ADDR_EXP 20
27821: PUSH
27822: LD_INT 0
27824: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27825: LD_ADDR_VAR 0 1
27829: PUSH
27830: LD_VAR 0 3
27834: PUSH
27835: LD_INT 22
27837: PUSH
27838: LD_INT 8
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 25
27847: PUSH
27848: LD_INT 2
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PPUSH
27859: CALL_OW 69
27863: UNION
27864: PUSH
27865: FOR_IN
27866: IFFALSE 27882
// SetTag ( i , 0 ) ;
27868: LD_VAR 0 1
27872: PPUSH
27873: LD_INT 0
27875: PPUSH
27876: CALL_OW 109
27880: GO 27865
27882: POP
27883: POP
// wait ( 0 0$3 ) ;
27884: LD_INT 105
27886: PPUSH
27887: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27891: LD_INT 93
27893: PPUSH
27894: LD_INT 35
27896: PPUSH
27897: LD_INT 1
27899: PPUSH
27900: CALL_OW 331
// DialogueOn ;
27904: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27908: LD_VAR 0 12
27912: PPUSH
27913: LD_STRING D6c-Sol3-1
27915: PPUSH
27916: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27920: LD_INT 10
27922: PPUSH
27923: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27927: LD_EXP 40
27931: PPUSH
27932: LD_STRING D6c-JMM-1
27934: PPUSH
27935: CALL_OW 88
// if Cyrus then
27939: LD_EXP 46
27943: IFFALSE 27957
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27945: LD_EXP 46
27949: PPUSH
27950: LD_STRING D6c-Cyrus-1
27952: PPUSH
27953: CALL_OW 88
// if Bobby then
27957: LD_EXP 45
27961: IFFALSE 27975
// Say ( Bobby , D6c-Bobby-1 ) ;
27963: LD_EXP 45
27967: PPUSH
27968: LD_STRING D6c-Bobby-1
27970: PPUSH
27971: CALL_OW 88
// if Cornel then
27975: LD_EXP 51
27979: IFFALSE 27993
// Say ( Cornel , D6c-Corn-1 ) ;
27981: LD_EXP 51
27985: PPUSH
27986: LD_STRING D6c-Corn-1
27988: PPUSH
27989: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27993: LD_ADDR_VAR 0 4
27997: PUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 22
28003: PUSH
28004: LD_INT 1
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 22
28013: PUSH
28014: LD_INT 4
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 26
28028: PUSH
28029: LD_INT 1
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 23
28038: PUSH
28039: LD_INT 1
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: CALL_OW 69
28055: PUSH
28056: LD_VAR 0 12
28060: PUSH
28061: LD_EXP 40
28065: UNION
28066: PUSH
28067: LD_EXP 62
28071: UNION
28072: DIFF
28073: ST_TO_ADDR
// if tmp2 then
28074: LD_VAR 0 4
28078: IFFALSE 28096
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
28080: LD_VAR 0 4
28084: PUSH
28085: LD_INT 1
28087: ARRAY
28088: PPUSH
28089: LD_STRING D6c-Sol1-1
28091: PPUSH
28092: CALL_OW 88
// if Lisa then
28096: LD_EXP 43
28100: IFFALSE 28114
// Say ( Lisa , D6c-Lisa-1 ) ;
28102: LD_EXP 43
28106: PPUSH
28107: LD_STRING D6c-Lisa-1
28109: PPUSH
28110: CALL_OW 88
// if Gary then
28114: LD_EXP 52
28118: IFFALSE 28132
// Say ( Gary , D6c-Gary-1 ) ;
28120: LD_EXP 52
28124: PPUSH
28125: LD_STRING D6c-Gary-1
28127: PPUSH
28128: CALL_OW 88
// if Donaldson then
28132: LD_EXP 44
28136: IFFALSE 28150
// Say ( Donaldson , D6c-Don-1 ) ;
28138: LD_EXP 44
28142: PPUSH
28143: LD_STRING D6c-Don-1
28145: PPUSH
28146: CALL_OW 88
// if tmp2 > 1 then
28150: LD_VAR 0 4
28154: PUSH
28155: LD_INT 1
28157: GREATER
28158: IFFALSE 28176
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
28160: LD_VAR 0 4
28164: PUSH
28165: LD_INT 2
28167: ARRAY
28168: PPUSH
28169: LD_STRING D6c-Sol2-1
28171: PPUSH
28172: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
28176: LD_VAR 0 12
28180: PPUSH
28181: LD_STRING D6c-Sol3-2
28183: PPUSH
28184: CALL_OW 88
// if IsInUnit ( JMM ) then
28188: LD_EXP 40
28192: PPUSH
28193: CALL_OW 310
28197: IFFALSE 28215
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
28199: LD_EXP 40
28203: PPUSH
28204: CALL_OW 310
28208: PPUSH
28209: CALL_OW 87
28213: GO 28224
// CenterNowOnUnits ( JMM ) ;
28215: LD_EXP 40
28219: PPUSH
28220: CALL_OW 87
// dwait ( 0 0$2 ) ;
28224: LD_INT 70
28226: PPUSH
28227: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28231: LD_EXP 40
28235: PPUSH
28236: LD_STRING D6c-JMM-2
28238: PPUSH
28239: CALL_OW 88
// DialogueOff ;
28243: CALL_OW 7
// Video ( false ) ;
28247: LD_INT 0
28249: PPUSH
28250: CALL 109043 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28254: LD_INT 22
28256: PUSH
28257: LD_INT 4
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PPUSH
28264: CALL_OW 69
28268: PPUSH
28269: LD_INT 1
28271: PPUSH
28272: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28276: LD_INT 4
28278: PPUSH
28279: LD_INT 4
28281: PPUSH
28282: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28286: LD_ADDR_VAR 0 1
28290: PUSH
28291: LD_INT 4
28293: PPUSH
28294: LD_INT 1
28296: PPUSH
28297: LD_INT 2
28299: PPUSH
28300: CALL 71086 0 3
28304: PUSH
28305: FOR_IN
28306: IFFALSE 28343
// if GetTech ( i , 1 ) <> state_researched then
28308: LD_VAR 0 1
28312: PPUSH
28313: LD_INT 1
28315: PPUSH
28316: CALL_OW 321
28320: PUSH
28321: LD_INT 2
28323: NONEQUAL
28324: IFFALSE 28341
// SetTech ( i , 1 , state_researched ) ;
28326: LD_VAR 0 1
28330: PPUSH
28331: LD_INT 1
28333: PPUSH
28334: LD_INT 2
28336: PPUSH
28337: CALL_OW 322
28341: GO 28305
28343: POP
28344: POP
// missionStage := 6 ;
28345: LD_ADDR_EXP 15
28349: PUSH
28350: LD_INT 6
28352: ST_TO_ADDR
// activeAttacks := true ;
28353: LD_ADDR_EXP 16
28357: PUSH
28358: LD_INT 1
28360: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28361: LD_STRING M2
28363: PPUSH
28364: CALL_OW 337
// SaveForQuickRestart ;
28368: CALL_OW 22
// wait ( 0 0$40 ) ;
28372: LD_INT 1400
28374: PPUSH
28375: CALL_OW 67
// DialogueOn ;
28379: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28383: LD_EXP 66
28387: PPUSH
28388: LD_STRING D7-Friend-1
28390: PPUSH
28391: CALL 113316 0 2
// Say ( JMM , D7-JMM-1 ) ;
28395: LD_EXP 40
28399: PPUSH
28400: LD_STRING D7-JMM-1
28402: PPUSH
28403: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28407: LD_EXP 66
28411: PPUSH
28412: LD_STRING D7-Friend-2
28414: PPUSH
28415: CALL 113316 0 2
// Say ( JMM , D7-JMM-2 ) ;
28419: LD_EXP 40
28423: PPUSH
28424: LD_STRING D7-JMM-2
28426: PPUSH
28427: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28431: LD_EXP 66
28435: PPUSH
28436: LD_STRING D7-Friend-3
28438: PPUSH
28439: CALL 113316 0 2
// Say ( JMM , D7-JMM-3 ) ;
28443: LD_EXP 40
28447: PPUSH
28448: LD_STRING D7-JMM-3
28450: PPUSH
28451: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28455: LD_EXP 66
28459: PPUSH
28460: LD_STRING D7-Friend-4
28462: PPUSH
28463: CALL 113316 0 2
// Say ( JMM , D7-JMM-4 ) ;
28467: LD_EXP 40
28471: PPUSH
28472: LD_STRING D7-JMM-4
28474: PPUSH
28475: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28479: LD_EXP 66
28483: PPUSH
28484: LD_STRING D7-Friend-5
28486: PPUSH
28487: CALL 113316 0 2
// Say ( JMM , D7-JMM-5 ) ;
28491: LD_EXP 40
28495: PPUSH
28496: LD_STRING D7-JMM-5
28498: PPUSH
28499: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28503: LD_EXP 66
28507: PPUSH
28508: LD_STRING D7-Friend-6
28510: PPUSH
28511: CALL 113316 0 2
// Say ( JMM , D7-JMM-6 ) ;
28515: LD_EXP 40
28519: PPUSH
28520: LD_STRING D7-JMM-6
28522: PPUSH
28523: CALL_OW 88
// DialogueOff ;
28527: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28531: LD_STRING Mlegion
28533: PPUSH
28534: CALL_OW 337
// skirmish := true ;
28538: LD_ADDR_EXP 100
28542: PUSH
28543: LD_INT 1
28545: ST_TO_ADDR
// RebuildKozlovFactory ;
28546: CALL 5386 0 0
// end ;
28550: PPOPN 14
28552: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28553: LD_EXP 20
28557: IFFALSE 28570
28559: PUSH
28560: LD_EXP 61
28564: PPUSH
28565: CALL_OW 300
28569: AND
28570: IFFALSE 28612
28572: GO 28574
28574: DISABLE
// begin enable ;
28575: ENABLE
// if IsInUnit ( Powell ) then
28576: LD_EXP 61
28580: PPUSH
28581: CALL_OW 310
28585: IFFALSE 28603
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28587: LD_EXP 61
28591: PPUSH
28592: CALL_OW 310
28596: PPUSH
28597: CALL_OW 85
28601: GO 28612
// CenterOnUnits ( Powell ) ;
28603: LD_EXP 61
28607: PPUSH
28608: CALL_OW 85
// end ;
28612: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28613: LD_INT 22
28615: PUSH
28616: LD_INT 8
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 34
28625: PUSH
28626: LD_INT 48
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PPUSH
28637: CALL_OW 69
28641: IFFALSE 28917
28643: GO 28645
28645: DISABLE
28646: LD_INT 0
28648: PPUSH
28649: PPUSH
// begin if missionStage < 9 then
28650: LD_EXP 15
28654: PUSH
28655: LD_INT 9
28657: LESS
28658: IFFALSE 28668
// missionStage := 9 ;
28660: LD_ADDR_EXP 15
28664: PUSH
28665: LD_INT 9
28667: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28668: LD_ADDR_VAR 0 1
28672: PUSH
28673: LD_INT 22
28675: PUSH
28676: LD_INT 8
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 34
28685: PUSH
28686: LD_INT 48
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PPUSH
28697: CALL_OW 69
28701: PUSH
28702: LD_INT 1
28704: ARRAY
28705: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28706: LD_INT 175
28708: PPUSH
28709: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28713: LD_EXP 12
28717: IFTRUE 28736
28719: PUSH
28720: LD_EXP 3
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: IN
28735: OR
28736: IFFALSE 28759
// target := [ 68 , 108 , 1 ] else
28738: LD_ADDR_VAR 0 2
28742: PUSH
28743: LD_INT 68
28745: PUSH
28746: LD_INT 108
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: ST_TO_ADDR
28757: GO 28778
// target := [ 181 , 88 , 2 ] ;
28759: LD_ADDR_VAR 0 2
28763: PUSH
28764: LD_INT 181
28766: PUSH
28767: LD_INT 88
28769: PUSH
28770: LD_INT 2
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: LIST
28777: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28778: LD_VAR 0 1
28782: PPUSH
28783: LD_VAR 0 2
28787: PUSH
28788: LD_INT 1
28790: ARRAY
28791: PPUSH
28792: LD_VAR 0 2
28796: PUSH
28797: LD_INT 2
28799: ARRAY
28800: PPUSH
28801: CALL_OW 176
// if target [ 3 ] = 1 then
28805: LD_VAR 0 2
28809: PUSH
28810: LD_INT 3
28812: ARRAY
28813: PUSH
28814: LD_INT 1
28816: EQUAL
28817: IFFALSE 28833
// SayRadio ( Kurt , D12-Kurt-1 ) else
28819: LD_EXP 64
28823: PPUSH
28824: LD_STRING D12-Kurt-1
28826: PPUSH
28827: CALL_OW 94
28831: GO 28857
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28833: LD_EXP 64
28837: PPUSH
28838: LD_STRING D12a-Kurt-1
28840: PPUSH
28841: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28845: LD_EXP 79
28849: PPUSH
28850: LD_STRING D12a-Roth-1
28852: PPUSH
28853: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28857: LD_INT 350
28859: PPUSH
28860: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28864: LD_VAR 0 1
28868: PPUSH
28869: LD_INT 22
28871: PUSH
28872: LD_INT 8
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 23
28881: PUSH
28882: LD_INT 2
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 30
28891: PUSH
28892: LD_INT 3
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: LIST
28903: PPUSH
28904: CALL_OW 69
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: CALL_OW 228
// end ;
28917: PPOPN 2
28919: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28920: LD_EXP 64
28924: PPUSH
28925: CALL_OW 256
28929: PUSH
28930: LD_INT 999
28932: LESS
28933: IFTRUE 29001
28935: PUSH
28936: LD_INT 22
28938: PUSH
28939: LD_INT 8
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 21
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 23
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: LIST
28970: PPUSH
28971: CALL_OW 69
28975: PUSH
28976: LD_INT 9
28978: PUSH
28979: LD_INT 8
28981: PUSH
28982: LD_INT 7
28984: PUSH
28985: LD_INT 6
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: PUSH
28994: LD_OWVAR 67
28998: ARRAY
28999: LESSEQUAL
29000: OR
29001: IFFALSE 29034
29003: PUSH
29004: LD_INT 22
29006: PUSH
29007: LD_INT 8
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 34
29016: PUSH
29017: LD_INT 48
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PPUSH
29028: CALL_OW 69
29032: NOT
29033: AND
29034: IFFALSE 29047
29036: PUSH
29037: LD_EXP 64
29041: PPUSH
29042: CALL_OW 302
29046: AND
29047: IFFALSE 29068
29049: PUSH
29050: LD_INT 5
29052: PPUSH
29053: LD_INT 22
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PPUSH
29063: CALL_OW 70
29067: AND
29068: IFFALSE 29830
29070: GO 29072
29072: DISABLE
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
// begin legionDestroyed := true ;
29078: LD_ADDR_EXP 22
29082: PUSH
29083: LD_INT 1
29085: ST_TO_ADDR
// DialogueOn ;
29086: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
29090: LD_EXP 40
29094: PPUSH
29095: LD_STRING D13-JMM-1
29097: PPUSH
29098: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
29102: LD_EXP 64
29106: PPUSH
29107: LD_STRING D13-Kurt-1
29109: PPUSH
29110: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
29114: LD_EXP 40
29118: PPUSH
29119: LD_STRING D13-JMM-2
29121: PPUSH
29122: CALL_OW 88
// if FakeInfo then
29126: LD_EXP 12
29130: IFFALSE 29150
// begin Say ( Kurt , D13-Kurt-2 ) ;
29132: LD_EXP 64
29136: PPUSH
29137: LD_STRING D13-Kurt-2
29139: PPUSH
29140: CALL_OW 88
// DialogueOff ;
29144: CALL_OW 7
// exit ;
29148: GO 29830
// end ; if not KurtStatus then
29150: LD_EXP 3
29154: NOT
29155: IFFALSE 29171
// Say ( Kurt , D13-Kurt-2b ) else
29157: LD_EXP 64
29161: PPUSH
29162: LD_STRING D13-Kurt-2b
29164: PPUSH
29165: CALL_OW 88
29169: GO 29183
// Say ( Kurt , D13-Kurt-2a ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D13-Kurt-2a
29178: PPUSH
29179: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
29183: LD_EXP 40
29187: PPUSH
29188: LD_STRING D13-JMM-3
29190: PPUSH
29191: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
29195: LD_EXP 64
29199: PPUSH
29200: LD_STRING D13-Kurt-3
29202: PPUSH
29203: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
29207: LD_EXP 40
29211: PPUSH
29212: LD_STRING D13-JMM-4
29214: PPUSH
29215: CALL_OW 88
// DialogueOff ;
29219: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29223: LD_STRING MlegionOut
29225: PPUSH
29226: CALL_OW 337
// MC_Kill ( 3 ) ;
29230: LD_INT 3
29232: PPUSH
29233: CALL 40134 0 1
// KillUnit ( Kozlov ) ;
29237: LD_EXP 65
29241: PPUSH
29242: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29246: LD_ADDR_VAR 0 1
29250: PUSH
29251: LD_INT 22
29253: PUSH
29254: LD_INT 8
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 23
29263: PUSH
29264: LD_INT 3
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 3
29273: PUSH
29274: LD_INT 21
29276: PUSH
29277: LD_INT 33
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: LIST
29292: PPUSH
29293: CALL_OW 69
29297: PUSH
29298: FOR_IN
29299: IFFALSE 29312
// KillUnit ( i ) ;
29301: LD_VAR 0 1
29305: PPUSH
29306: CALL_OW 66
29310: GO 29298
29312: POP
29313: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29314: LD_ADDR_VAR 0 1
29318: PUSH
29319: LD_INT 22
29321: PUSH
29322: LD_INT 8
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 21
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PPUSH
29343: CALL_OW 69
29347: PUSH
29348: FOR_IN
29349: IFFALSE 29362
// KillUnit ( i ) ;
29351: LD_VAR 0 1
29355: PPUSH
29356: CALL_OW 66
29360: GO 29348
29362: POP
29363: POP
// wait ( 0 0$0.6 ) ;
29364: LD_INT 21
29366: PPUSH
29367: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29371: LD_INT 8
29373: PPUSH
29374: LD_INT 1
29376: PPUSH
29377: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29381: LD_ADDR_VAR 0 2
29385: PUSH
29386: LD_INT 22
29388: PUSH
29389: LD_INT 8
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 21
29398: PUSH
29399: LD_INT 1
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PPUSH
29410: CALL_OW 69
29414: PUSH
29415: LD_EXP 65
29419: PUSH
29420: LD_EXP 64
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: DIFF
29429: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29430: LD_VAR 0 2
29434: PUSH
29435: LD_INT 6
29437: PUSH
29438: LD_INT 5
29440: PUSH
29441: LD_INT 4
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: PUSH
29453: LD_OWVAR 67
29457: ARRAY
29458: GREATEREQUAL
29459: IFFALSE 29611
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29461: LD_ADDR_VAR 0 3
29465: PUSH
29466: LD_INT 6
29468: PUSH
29469: LD_INT 5
29471: PUSH
29472: LD_INT 4
29474: PUSH
29475: LD_INT 3
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: PUSH
29484: LD_OWVAR 67
29488: ARRAY
29489: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29490: LD_ADDR_VAR 0 1
29494: PUSH
29495: DOUBLE
29496: LD_VAR 0 2
29500: PUSH
29501: LD_VAR 0 3
29505: PUSH
29506: LD_INT 1
29508: PLUS
29509: MINUS
29510: INC
29511: ST_TO_ADDR
29512: LD_INT 1
29514: PUSH
29515: FOR_DOWNTO
29516: IFFALSE 29607
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29518: LD_ADDR_EXP 38
29522: PUSH
29523: LD_EXP 38
29527: PUSH
29528: LD_VAR 0 2
29532: PUSH
29533: LD_VAR 0 1
29537: ARRAY
29538: ADD
29539: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29540: LD_VAR 0 2
29544: PUSH
29545: LD_VAR 0 1
29549: ARRAY
29550: PPUSH
29551: CALL_OW 310
29555: IFFALSE 29572
// ComExit ( tmp [ i ] ) ;
29557: LD_VAR 0 2
29561: PUSH
29562: LD_VAR 0 1
29566: ARRAY
29567: PPUSH
29568: CALL 109469 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 1
29581: ARRAY
29582: PPUSH
29583: LD_INT 34
29585: PUSH
29586: LD_INT 0
29588: PPUSH
29589: LD_INT 6
29591: PPUSH
29592: CALL_OW 12
29596: PLUS
29597: PPUSH
29598: LD_INT 1
29600: PPUSH
29601: CALL_OW 171
// end ;
29605: GO 29515
29607: POP
29608: POP
// end else
29609: GO 29621
// x := tmp ;
29611: LD_ADDR_VAR 0 3
29615: PUSH
29616: LD_VAR 0 2
29620: ST_TO_ADDR
// for i := tmp downto tmp - x do
29621: LD_ADDR_VAR 0 1
29625: PUSH
29626: DOUBLE
29627: LD_VAR 0 2
29631: INC
29632: ST_TO_ADDR
29633: LD_VAR 0 2
29637: PUSH
29638: LD_VAR 0 3
29642: MINUS
29643: PUSH
29644: FOR_DOWNTO
29645: IFFALSE 29717
// begin if IsInUnit ( tmp [ i ] ) then
29647: LD_VAR 0 2
29651: PUSH
29652: LD_VAR 0 1
29656: ARRAY
29657: PPUSH
29658: CALL_OW 310
29662: IFFALSE 29679
// ComExit ( tmp [ i ] ) ;
29664: LD_VAR 0 2
29668: PUSH
29669: LD_VAR 0 1
29673: ARRAY
29674: PPUSH
29675: CALL 109469 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29679: LD_VAR 0 2
29683: PUSH
29684: LD_VAR 0 1
29688: ARRAY
29689: PPUSH
29690: LD_INT 1
29692: PPUSH
29693: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29697: LD_VAR 0 2
29701: PUSH
29702: LD_VAR 0 1
29706: ARRAY
29707: PPUSH
29708: LD_INT 1000
29710: PPUSH
29711: CALL_OW 234
// end ;
29715: GO 29644
29717: POP
29718: POP
// SetSide ( Kurt , 1 ) ;
29719: LD_EXP 64
29723: PPUSH
29724: LD_INT 1
29726: PPUSH
29727: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29731: LD_INT 22
29733: PUSH
29734: LD_INT 8
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 21
29743: PUSH
29744: LD_INT 3
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PPUSH
29755: CALL_OW 69
29759: PPUSH
29760: LD_INT 1
29762: PPUSH
29763: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29767: LD_INT 8
29769: PPUSH
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 1
29778: PPUSH
29779: CALL_OW 80
// wait ( 1 1$20 ) ;
29783: LD_INT 2800
29785: PPUSH
29786: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29790: LD_EXP 66
29794: PPUSH
29795: LD_INT 37
29797: PPUSH
29798: LD_INT 1
29800: PPUSH
29801: LD_INT 0
29803: PPUSH
29804: CALL_OW 48
// wait ( 0 0$1 ) ;
29808: LD_INT 35
29810: PPUSH
29811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29815: LD_EXP 66
29819: PPUSH
29820: LD_INT 60
29822: PPUSH
29823: LD_INT 95
29825: PPUSH
29826: CALL_OW 111
// end ;
29830: PPOPN 3
29832: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29833: LD_EXP 22
29837: NOT
29838: IFFALSE 29874
29840: PUSH
29841: LD_INT 22
29843: PUSH
29844: LD_INT 8
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 21
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 0
29872: EQUAL
29873: AND
29874: IFFALSE 29894
29876: GO 29878
29878: DISABLE
// begin legionDestroyed := true ;
29879: LD_ADDR_EXP 22
29883: PUSH
29884: LD_INT 1
29886: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29887: LD_STRING MlegionOut
29889: PPUSH
29890: CALL_OW 337
// end ;
29894: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29895: LD_EXP 38
29899: IFFALSE 29974
29901: GO 29903
29903: DISABLE
29904: LD_INT 0
29906: PPUSH
// begin enable ;
29907: ENABLE
// for i in legionEscapeUnits do
29908: LD_ADDR_VAR 0 1
29912: PUSH
29913: LD_EXP 38
29917: PUSH
29918: FOR_IN
29919: IFFALSE 29972
// begin if IsInArea ( i , legionEscapeArea ) then
29921: LD_VAR 0 1
29925: PPUSH
29926: LD_INT 31
29928: PPUSH
29929: CALL_OW 308
29933: IFFALSE 29946
// RemoveUnit ( i ) else
29935: LD_VAR 0 1
29939: PPUSH
29940: CALL_OW 64
29944: GO 29970
// if not HasTask ( i ) then
29946: LD_VAR 0 1
29950: PPUSH
29951: CALL_OW 314
29955: NOT
29956: IFFALSE 29970
// ComMoveToArea ( i , legionEscapeArea ) ;
29958: LD_VAR 0 1
29962: PPUSH
29963: LD_INT 31
29965: PPUSH
29966: CALL_OW 113
// end ;
29970: GO 29918
29972: POP
29973: POP
// end ;
29974: PPOPN 1
29976: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29977: LD_INT 1
29979: PPUSH
29980: LD_EXP 66
29984: PPUSH
29985: CALL_OW 292
29989: IFFALSE 30287
29991: GO 29993
29993: DISABLE
29994: LD_INT 0
29996: PPUSH
// begin wait ( 0 0$2 ) ;
29997: LD_INT 70
29999: PPUSH
30000: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30004: LD_EXP 66
30008: PPUSH
30009: CALL_OW 87
// DialogueOn ;
30013: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
30017: LD_EXP 40
30021: PPUSH
30022: LD_STRING D14-JMM-1
30024: PPUSH
30025: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
30029: LD_EXP 66
30033: PPUSH
30034: LD_STRING D14-Friend-1
30036: PPUSH
30037: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D14-JMM-2
30048: PPUSH
30049: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D14-Friend-2
30060: PPUSH
30061: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
30065: LD_EXP 40
30069: PPUSH
30070: LD_STRING D14-JMM-3
30072: PPUSH
30073: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
30077: LD_EXP 66
30081: PPUSH
30082: LD_STRING D14-Friend-3
30084: PPUSH
30085: CALL_OW 88
// DialogueOff ;
30089: CALL_OW 7
// dec := Query ( Q14 ) ;
30093: LD_ADDR_VAR 0 1
30097: PUSH
30098: LD_STRING Q14
30100: PPUSH
30101: CALL_OW 97
30105: ST_TO_ADDR
// if dec = 1 then
30106: LD_VAR 0 1
30110: PUSH
30111: LD_INT 1
30113: EQUAL
30114: IFFALSE 30148
// begin DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
30120: LD_EXP 40
30124: PPUSH
30125: LD_STRING D14a-JMM-1
30127: PPUSH
30128: CALL_OW 88
// DialogueOff ;
30132: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30136: LD_EXP 66
30140: PPUSH
30141: LD_INT 1
30143: PPUSH
30144: CALL_OW 235
// end ; if dec = 2 then
30148: LD_VAR 0 1
30152: PUSH
30153: LD_INT 2
30155: EQUAL
30156: IFFALSE 30209
// begin DialogueOn ;
30158: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
30162: LD_EXP 40
30166: PPUSH
30167: LD_STRING D14b-JMM-1
30169: PPUSH
30170: CALL_OW 88
// DialogueOff ;
30174: CALL_OW 7
// wait ( 0 0$1 ) ;
30178: LD_INT 35
30180: PPUSH
30181: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
30185: LD_EXP 66
30189: PPUSH
30190: LD_INT 9
30192: PPUSH
30193: LD_INT 2
30195: PPUSH
30196: CALL_OW 111
// AddComHold ( Friend ) ;
30200: LD_EXP 66
30204: PPUSH
30205: CALL_OW 200
// end ; if dec = 3 then
30209: LD_VAR 0 1
30213: PUSH
30214: LD_INT 3
30216: EQUAL
30217: IFFALSE 30287
// begin DialogueOn ;
30219: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30223: LD_EXP 40
30227: PPUSH
30228: LD_STRING D14c-JMM-1
30230: PPUSH
30231: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30235: LD_EXP 66
30239: PPUSH
30240: LD_STRING D14c-Friend-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30247: LD_EXP 40
30251: PPUSH
30252: LD_STRING D14c-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30263: LD_EXP 66
30267: PPUSH
30268: LD_INT 9
30270: PPUSH
30271: LD_INT 2
30273: PPUSH
30274: CALL_OW 111
// AddComHold ( Friend ) ;
30278: LD_EXP 66
30282: PPUSH
30283: CALL_OW 200
// end ; end ;
30287: PPOPN 1
30289: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30290: LD_INT 9
30292: PPUSH
30293: LD_INT 2
30295: PPUSH
30296: CALL_OW 428
30300: PUSH
30301: LD_EXP 66
30305: EQUAL
30306: IFFALSE 30323
30308: PUSH
30309: LD_EXP 66
30313: PPUSH
30314: CALL_OW 255
30318: PUSH
30319: LD_INT 8
30321: EQUAL
30322: AND
30323: IFFALSE 30337
30325: GO 30327
30327: DISABLE
// RemoveUnit ( Friend ) ;
30328: LD_EXP 66
30332: PPUSH
30333: CALL_OW 64
30337: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30338: LD_EXP 14
30342: PUSH
30343: LD_INT 31500
30345: GREATEREQUAL
30346: IFFALSE 30354
30348: PUSH
30349: LD_EXP 7
30353: AND
30354: IFFALSE 30362
30356: PUSH
30357: LD_EXP 2
30361: AND
30362: IFFALSE 30808
30364: GO 30366
30366: DISABLE
30367: LD_INT 0
30369: PPUSH
30370: PPUSH
30371: PPUSH
// begin missionStage := 7 ;
30372: LD_ADDR_EXP 15
30376: PUSH
30377: LD_INT 7
30379: ST_TO_ADDR
// for i := 1 to 5 do
30380: LD_ADDR_VAR 0 1
30384: PUSH
30385: DOUBLE
30386: LD_INT 1
30388: DEC
30389: ST_TO_ADDR
30390: LD_INT 5
30392: PUSH
30393: FOR_TO
30394: IFFALSE 30506
// begin uc_side = 1 ;
30396: LD_ADDR_OWVAR 20
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// uc_nation = 1 ;
30404: LD_ADDR_OWVAR 21
30408: PUSH
30409: LD_INT 1
30411: ST_TO_ADDR
// vc_engine = engine_siberite ;
30412: LD_ADDR_OWVAR 39
30416: PUSH
30417: LD_INT 3
30419: ST_TO_ADDR
// vc_control = control_computer ;
30420: LD_ADDR_OWVAR 38
30424: PUSH
30425: LD_INT 3
30427: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30428: LD_ADDR_OWVAR 37
30432: PUSH
30433: LD_INT 3
30435: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30436: LD_ADDR_OWVAR 40
30440: PUSH
30441: LD_INT 5
30443: PUSH
30444: LD_INT 9
30446: PUSH
30447: LD_INT 7
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 1
30457: PPUSH
30458: LD_INT 3
30460: PPUSH
30461: CALL_OW 12
30465: ARRAY
30466: ST_TO_ADDR
// veh = CreateVehicle ;
30467: LD_ADDR_VAR 0 2
30471: PUSH
30472: CALL_OW 45
30476: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30477: LD_VAR 0 2
30481: PPUSH
30482: LD_INT 1
30484: PPUSH
30485: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30489: LD_VAR 0 2
30493: PPUSH
30494: LD_INT 19
30496: PPUSH
30497: LD_INT 0
30499: PPUSH
30500: CALL_OW 49
// end ;
30504: GO 30393
30506: POP
30507: POP
// uc_side = 1 ;
30508: LD_ADDR_OWVAR 20
30512: PUSH
30513: LD_INT 1
30515: ST_TO_ADDR
// uc_nation = 1 ;
30516: LD_ADDR_OWVAR 21
30520: PUSH
30521: LD_INT 1
30523: ST_TO_ADDR
// vc_engine = 3 ;
30524: LD_ADDR_OWVAR 39
30528: PUSH
30529: LD_INT 3
30531: ST_TO_ADDR
// vc_control = 1 ;
30532: LD_ADDR_OWVAR 38
30536: PUSH
30537: LD_INT 1
30539: ST_TO_ADDR
// vc_chassis = 3 ;
30540: LD_ADDR_OWVAR 37
30544: PUSH
30545: LD_INT 3
30547: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30548: LD_ADDR_OWVAR 40
30552: PUSH
30553: LD_INT 5
30555: PUSH
30556: LD_INT 9
30558: PUSH
30559: LD_INT 7
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 1
30569: PPUSH
30570: LD_INT 3
30572: PPUSH
30573: CALL_OW 12
30577: ARRAY
30578: ST_TO_ADDR
// vehG = CreateVehicle ;
30579: LD_ADDR_VAR 0 3
30583: PUSH
30584: CALL_OW 45
30588: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30589: LD_VAR 0 3
30593: PPUSH
30594: LD_INT 1
30596: PPUSH
30597: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30601: LD_VAR 0 3
30605: PPUSH
30606: LD_INT 19
30608: PPUSH
30609: LD_INT 0
30611: PPUSH
30612: CALL_OW 49
// if JMMGirl = 1 then
30616: LD_EXP 7
30620: PUSH
30621: LD_INT 1
30623: EQUAL
30624: IFFALSE 30680
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30626: LD_ADDR_EXP 41
30630: PUSH
30631: LD_STRING Joan
30633: PPUSH
30634: LD_INT 1
30636: PPUSH
30637: LD_STRING 14_
30639: PPUSH
30640: CALL 70939 0 3
30644: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30645: LD_EXP 41
30649: PPUSH
30650: LD_VAR 0 3
30654: PPUSH
30655: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30659: LD_VAR 0 3
30663: PPUSH
30664: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30668: LD_EXP 41
30672: PPUSH
30673: LD_STRING D10BW-Joan-1
30675: PPUSH
30676: CALL_OW 94
// end ; if JMMGirl = 2 then
30680: LD_EXP 7
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: IFFALSE 30744
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30690: LD_ADDR_EXP 43
30694: PUSH
30695: LD_STRING Lisa
30697: PPUSH
30698: LD_INT 1
30700: PPUSH
30701: LD_STRING 14_
30703: PPUSH
30704: CALL 70939 0 3
30708: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30709: LD_EXP 43
30713: PPUSH
30714: LD_VAR 0 3
30718: PPUSH
30719: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30723: LD_VAR 0 3
30727: PPUSH
30728: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30732: LD_EXP 43
30736: PPUSH
30737: LD_STRING D10BW-Lisa-1
30739: PPUSH
30740: CALL_OW 94
// end ; if JMMGirl = 3 then
30744: LD_EXP 7
30748: PUSH
30749: LD_INT 3
30751: EQUAL
30752: IFFALSE 30808
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30754: LD_ADDR_EXP 55
30758: PUSH
30759: LD_STRING Connie
30761: PPUSH
30762: LD_INT 1
30764: PPUSH
30765: LD_STRING 14_
30767: PPUSH
30768: CALL 70939 0 3
30772: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30773: LD_EXP 55
30777: PPUSH
30778: LD_VAR 0 3
30782: PPUSH
30783: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30787: LD_VAR 0 3
30791: PPUSH
30792: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30796: LD_EXP 55
30800: PPUSH
30801: LD_STRING D10BW-Con-1
30803: PPUSH
30804: CALL_OW 94
// end ; end ;
30808: PPOPN 3
30810: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30811: LD_EXP 14
30815: PUSH
30816: LD_INT 94500
30818: GREATEREQUAL
30819: IFFALSE 31231
30821: GO 30823
30823: DISABLE
30824: LD_INT 0
30826: PPUSH
30827: PPUSH
30828: PPUSH
// begin tmp := PrepareStevensSquad ;
30829: LD_ADDR_VAR 0 3
30833: PUSH
30834: CALL 2384 0 0
30838: ST_TO_ADDR
// if not tmp then
30839: LD_VAR 0 3
30843: NOT
30844: IFFALSE 30848
// exit ;
30846: GO 31231
// uc_side := 1 ;
30848: LD_ADDR_OWVAR 20
30852: PUSH
30853: LD_INT 1
30855: ST_TO_ADDR
// uc_nation := 1 ;
30856: LD_ADDR_OWVAR 21
30860: PUSH
30861: LD_INT 1
30863: ST_TO_ADDR
// for i in tmp do
30864: LD_ADDR_VAR 0 1
30868: PUSH
30869: LD_VAR 0 3
30873: PUSH
30874: FOR_IN
30875: IFFALSE 30972
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30877: LD_INT 3
30879: PPUSH
30880: LD_INT 3
30882: PPUSH
30883: LD_INT 1
30885: PPUSH
30886: LD_INT 5
30888: PUSH
30889: LD_INT 9
30891: PUSH
30892: LD_INT 7
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 1
30902: PPUSH
30903: LD_INT 3
30905: PPUSH
30906: CALL_OW 12
30910: ARRAY
30911: PPUSH
30912: LD_INT 40
30914: PPUSH
30915: CALL 75901 0 5
// veh := CreateVehicle ;
30919: LD_ADDR_VAR 0 2
30923: PUSH
30924: CALL_OW 45
30928: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30929: LD_VAR 0 2
30933: PPUSH
30934: LD_INT 1
30936: PPUSH
30937: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30941: LD_VAR 0 2
30945: PPUSH
30946: LD_INT 19
30948: PPUSH
30949: LD_INT 0
30951: PPUSH
30952: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30956: LD_VAR 0 1
30960: PPUSH
30961: LD_VAR 0 2
30965: PPUSH
30966: CALL_OW 52
// end ;
30970: GO 30874
30972: POP
30973: POP
// missionStage := 8 ;
30974: LD_ADDR_EXP 15
30978: PUSH
30979: LD_INT 8
30981: ST_TO_ADDR
// DialogueOn ;
30982: CALL_OW 6
// if Stevens then
30986: LD_EXP 42
30990: IFFALSE 31104
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30992: LD_EXP 42
30996: PPUSH
30997: CALL_OW 310
31001: PPUSH
31002: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
31006: LD_EXP 42
31010: PPUSH
31011: LD_STRING D8-Huck-1
31013: PPUSH
31014: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
31018: LD_EXP 40
31022: PPUSH
31023: LD_STRING D8-JMM-1
31025: PPUSH
31026: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
31030: LD_EXP 42
31034: PPUSH
31035: LD_STRING D8-Huck-2
31037: PPUSH
31038: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31042: LD_EXP 40
31046: PPUSH
31047: LD_STRING D8-JMM-2
31049: PPUSH
31050: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
31054: LD_EXP 42
31058: PPUSH
31059: LD_STRING D8-Huck-3
31061: PPUSH
31062: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31066: LD_EXP 40
31070: PPUSH
31071: LD_STRING D8-JMM-3
31073: PPUSH
31074: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
31078: LD_EXP 42
31082: PPUSH
31083: LD_STRING D8-Huck-4
31085: PPUSH
31086: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31090: LD_EXP 40
31094: PPUSH
31095: LD_STRING D8-JMM-4
31097: PPUSH
31098: CALL_OW 88
// end else
31102: GO 31214
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
31104: LD_EXP 56
31108: PPUSH
31109: CALL_OW 310
31113: PPUSH
31114: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
31118: LD_EXP 56
31122: PPUSH
31123: LD_STRING D8-Huck-1
31125: PPUSH
31126: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
31130: LD_EXP 40
31134: PPUSH
31135: LD_STRING D8-JMM-1a
31137: PPUSH
31138: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
31142: LD_EXP 56
31146: PPUSH
31147: LD_STRING D8-Huck-2
31149: PPUSH
31150: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31154: LD_EXP 40
31158: PPUSH
31159: LD_STRING D8-JMM-2
31161: PPUSH
31162: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
31166: LD_EXP 56
31170: PPUSH
31171: LD_STRING D8-Huck-3
31173: PPUSH
31174: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31178: LD_EXP 40
31182: PPUSH
31183: LD_STRING D8-JMM-3
31185: PPUSH
31186: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
31190: LD_EXP 56
31194: PPUSH
31195: LD_STRING D8-Huck-4
31197: PPUSH
31198: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31202: LD_EXP 40
31206: PPUSH
31207: LD_STRING D8-JMM-4
31209: PPUSH
31210: CALL_OW 88
// end ; DialogueOff ;
31214: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
31218: LD_INT 25
31220: PPUSH
31221: LD_INT 1
31223: PPUSH
31224: LD_INT 1
31226: PPUSH
31227: CALL_OW 322
// end ;
31231: PPOPN 3
31233: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31234: LD_EXP 75
31238: PPUSH
31239: CALL_OW 302
31243: IFFALSE 31259
31245: PUSH
31246: LD_INT 1
31248: PPUSH
31249: LD_EXP 75
31253: PPUSH
31254: CALL_OW 292
31258: AND
31259: IFFALSE 31497
31261: GO 31263
31263: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31264: LD_EXP 75
31268: PPUSH
31269: CALL_OW 87
// DialogueOn ;
31273: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31277: LD_EXP 40
31281: PPUSH
31282: LD_STRING D10nB-JMM-1
31284: PPUSH
31285: CALL_OW 88
// if BurlakStatus = 1 then
31289: LD_EXP 9
31293: PUSH
31294: LD_INT 1
31296: EQUAL
31297: IFFALSE 31313
// SayRadio ( Vsevolod , D10nB-Vse-1a ) else
31299: LD_EXP 74
31303: PPUSH
31304: LD_STRING D10nB-Vse-1a
31306: PPUSH
31307: CALL_OW 94
31311: GO 31325
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31313: LD_EXP 74
31317: PPUSH
31318: LD_STRING D10nB-Vse-1
31320: PPUSH
31321: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31325: LD_EXP 40
31329: PPUSH
31330: LD_STRING D10nB-JMM-2
31332: PPUSH
31333: CALL_OW 88
// if KappaStatus then
31337: LD_EXP 2
31341: IFFALSE 31357
// SayRadio ( Vsevolod , D10nB-Vse-5a ) else
31343: LD_EXP 74
31347: PPUSH
31348: LD_STRING D10nB-Vse-5a
31350: PPUSH
31351: CALL_OW 94
31355: GO 31493
// if JMMGirlStatus = 0 then
31357: LD_EXP 6
31361: PUSH
31362: LD_INT 0
31364: EQUAL
31365: IFFALSE 31493
// begin if JMMGirl = 1 then
31367: LD_EXP 7
31371: PUSH
31372: LD_INT 1
31374: EQUAL
31375: IFFALSE 31425
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31377: LD_EXP 74
31381: PPUSH
31382: LD_STRING D10nB-Vse-2
31384: PPUSH
31385: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31389: LD_EXP 40
31393: PPUSH
31394: LD_STRING D10nB-JMM-3
31396: PPUSH
31397: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31401: LD_EXP 74
31405: PPUSH
31406: LD_STRING D10nB-Vse-3
31408: PPUSH
31409: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31413: LD_EXP 40
31417: PPUSH
31418: LD_STRING D10nB-JMM-4
31420: PPUSH
31421: CALL_OW 88
// end ; if JMMGirl = 2 then
31425: LD_EXP 7
31429: PUSH
31430: LD_INT 2
31432: EQUAL
31433: IFFALSE 31459
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31435: LD_EXP 74
31439: PPUSH
31440: LD_STRING D10nB-Vse-4
31442: PPUSH
31443: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31447: LD_EXP 40
31451: PPUSH
31452: LD_STRING D10nB-JMM-5
31454: PPUSH
31455: CALL_OW 88
// end ; if JMMGirl = 3 then
31459: LD_EXP 7
31463: PUSH
31464: LD_INT 3
31466: EQUAL
31467: IFFALSE 31493
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31469: LD_EXP 74
31473: PPUSH
31474: LD_STRING D10nB-Vse-5
31476: PPUSH
31477: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31481: LD_EXP 40
31485: PPUSH
31486: LD_STRING D10nB-JMM-6
31488: PPUSH
31489: CALL_OW 88
// end ; end ; DialogueOff ;
31493: CALL_OW 7
// end ;
31497: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31498: LD_EXP 14
31502: PUSH
31503: LD_INT 115500
31505: GREATEREQUAL
31506: IFFALSE 31519
31508: PUSH
31509: LD_EXP 69
31513: PPUSH
31514: CALL_OW 302
31518: AND
31519: IFFALSE 31530
31521: PUSH
31522: LD_INT 267
31524: PPUSH
31525: CALL_OW 302
31529: AND
31530: IFFALSE 32046
31532: GO 31534
31534: DISABLE
31535: LD_INT 0
31537: PPUSH
31538: PPUSH
31539: PPUSH
// begin missionStage := 10 ;
31540: LD_ADDR_EXP 15
31544: PUSH
31545: LD_INT 10
31547: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_INT 22
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 23
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 26
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 25
31588: PUSH
31589: LD_INT 12
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 3
31602: PUSH
31603: LD_INT 25
31605: PUSH
31606: LD_INT 16
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: PPUSH
31624: CALL_OW 69
31628: PUSH
31629: LD_EXP 40
31633: PUSH
31634: LD_EXP 64
31638: PUSH
31639: LD_EXP 42
31643: PUSH
31644: LD_EXP 56
31648: PUSH
31649: LD_EXP 43
31653: PUSH
31654: LD_EXP 44
31658: PUSH
31659: LD_EXP 45
31663: PUSH
31664: LD_EXP 46
31668: PUSH
31669: LD_EXP 47
31673: PUSH
31674: LD_EXP 48
31678: PUSH
31679: LD_EXP 49
31683: PUSH
31684: LD_EXP 50
31688: PUSH
31689: LD_EXP 51
31693: PUSH
31694: LD_EXP 52
31698: PUSH
31699: LD_EXP 53
31703: PUSH
31704: LD_EXP 54
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: DIFF
31727: ST_TO_ADDR
// if not tmp and Brown then
31728: LD_VAR 0 3
31732: NOT
31733: IFFALSE 31741
31735: PUSH
31736: LD_EXP 48
31740: AND
31741: IFFALSE 31756
// tmp := [ Brown ] ;
31743: LD_ADDR_VAR 0 3
31747: PUSH
31748: LD_EXP 48
31752: PUSH
31753: EMPTY
31754: LIST
31755: ST_TO_ADDR
// DialogueOn ;
31756: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31760: LD_VAR 0 3
31764: PUSH
31765: LD_INT 1
31767: ARRAY
31768: PPUSH
31769: LD_STRING D11-Sol1-1
31771: PPUSH
31772: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31776: LD_EXP 68
31780: PPUSH
31781: LD_STRING D11-Pla-1
31783: PPUSH
31784: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31788: LD_EXP 69
31792: PPUSH
31793: LD_STRING D11-Kov-1
31795: PPUSH
31796: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31800: LD_EXP 68
31804: PPUSH
31805: LD_STRING D11-Pla-2
31807: PPUSH
31808: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31812: LD_VAR 0 3
31816: PUSH
31817: LD_INT 1
31819: ARRAY
31820: PPUSH
31821: LD_STRING D11-Sol1-2
31823: PPUSH
31824: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31828: LD_EXP 40
31832: PPUSH
31833: LD_STRING D11-JMM-2
31835: PPUSH
31836: CALL_OW 88
// DialogueOff ;
31840: CALL_OW 7
// allowBehemothConstruct := true ;
31844: LD_ADDR_EXP 25
31848: PUSH
31849: LD_INT 1
31851: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31852: LD_STRING M4
31854: PPUSH
31855: CALL_OW 337
// j := 3 ;
31859: LD_ADDR_VAR 0 2
31863: PUSH
31864: LD_INT 3
31866: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31867: LD_ADDR_VAR 0 3
31871: PUSH
31872: LD_INT 22
31874: PUSH
31875: LD_INT 3
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 50
31884: PUSH
31885: EMPTY
31886: LIST
31887: PUSH
31888: LD_INT 3
31890: PUSH
31891: LD_INT 120
31893: PUSH
31894: LD_INT 105
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 25
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: PPUSH
31921: CALL_OW 69
31925: PUSH
31926: LD_EXP 69
31930: DIFF
31931: ST_TO_ADDR
// for i in tmp do
31932: LD_ADDR_VAR 0 1
31936: PUSH
31937: LD_VAR 0 3
31941: PUSH
31942: FOR_IN
31943: IFFALSE 31993
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31945: LD_ADDR_EXP 77
31949: PUSH
31950: LD_EXP 77
31954: PPUSH
31955: LD_VAR 0 1
31959: PPUSH
31960: CALL 109071 0 2
31964: ST_TO_ADDR
// j := j - 1 ;
31965: LD_ADDR_VAR 0 2
31969: PUSH
31970: LD_VAR 0 2
31974: PUSH
31975: LD_INT 1
31977: MINUS
31978: ST_TO_ADDR
// if j = 0 then
31979: LD_VAR 0 2
31983: PUSH
31984: LD_INT 0
31986: EQUAL
31987: IFFALSE 31991
// break ;
31989: GO 31993
// end ;
31991: GO 31942
31993: POP
31994: POP
// BuildBehemoths ;
31995: CALL 8388 0 0
// repeat wait ( 15 15$00 ) ;
31999: LD_INT 31500
32001: PPUSH
32002: CALL_OW 67
// if behemothDestroyedBeforeFinish then
32006: LD_EXP 27
32010: IFFALSE 32014
// break ;
32012: GO 32046
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
32014: LD_INT 267
32016: PPUSH
32017: CALL_OW 274
32021: PPUSH
32022: LD_INT 1
32024: PPUSH
32025: CALL_OW 275
32029: PUSH
32030: LD_INT 1000
32032: GREATEREQUAL
32033: IFFALSE 32039
// BuildBehemoths ;
32035: CALL 8388 0 0
// until not behemothBuilders ;
32039: LD_EXP 77
32043: NOT
32044: IFFALSE 31999
// end ;
32046: PPOPN 3
32048: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
32049: LD_EXP 77
32053: NOT
32054: IFFALSE 32063
32056: PUSH
32057: LD_EXP 28
32061: NOT
32062: AND
32063: IFFALSE 32071
32065: PUSH
32066: LD_EXP 25
32070: AND
32071: IFFALSE 32091
32073: GO 32075
32075: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
32076: LD_STRING M4a
32078: PPUSH
32079: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
32083: LD_ADDR_EXP 27
32087: PUSH
32088: LD_INT 1
32090: ST_TO_ADDR
// end ;
32091: END
// every 0 0$1 trigger behemothDone do
32092: LD_EXP 28
32096: IFFALSE 32108
32098: GO 32100
32100: DISABLE
// ChangeMissionObjectives ( M4b ) ;
32101: LD_STRING M4b
32103: PPUSH
32104: CALL_OW 337
32108: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
32109: LD_EXP 29
32113: NOT
32114: IFFALSE 32312
32116: GO 32118
32118: DISABLE
32119: LD_INT 0
32121: PPUSH
32122: PPUSH
// begin enable ;
32123: ENABLE
// tmp := GetBehemoths ( 3 ) ;
32124: LD_ADDR_VAR 0 1
32128: PUSH
32129: LD_INT 3
32131: PPUSH
32132: CALL 109132 0 1
32136: ST_TO_ADDR
// if not tmp and not behemothDone then
32137: LD_VAR 0 1
32141: NOT
32142: IFFALSE 32151
32144: PUSH
32145: LD_EXP 28
32149: NOT
32150: AND
32151: IFFALSE 32187
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
32153: LD_ADDR_VAR 0 1
32157: PUSH
32158: LD_INT 22
32160: PUSH
32161: LD_INT 3
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 30
32170: PUSH
32171: LD_INT 37
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PPUSH
32182: CALL_OW 69
32186: ST_TO_ADDR
// if not tmp then
32187: LD_VAR 0 1
32191: NOT
32192: IFFALSE 32196
// exit ;
32194: GO 32312
// for i in tmp do
32196: LD_ADDR_VAR 0 2
32200: PUSH
32201: LD_VAR 0 1
32205: PUSH
32206: FOR_IN
32207: IFFALSE 32310
// if See ( 1 , i ) then
32209: LD_INT 1
32211: PPUSH
32212: LD_VAR 0 2
32216: PPUSH
32217: CALL_OW 292
32221: IFFALSE 32308
// begin if GetType ( i ) = unit_building then
32223: LD_VAR 0 2
32227: PPUSH
32228: CALL_OW 247
32232: PUSH
32233: LD_INT 3
32235: EQUAL
32236: IFFALSE 32274
// begin disable ;
32238: DISABLE
// CenterNowOnUnits ( i ) ;
32239: LD_VAR 0 2
32243: PPUSH
32244: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32248: LD_EXP 40
32252: PPUSH
32253: LD_STRING D17a-JMM-1
32255: PPUSH
32256: CALL_OW 88
// seeBehemoth := true ;
32260: LD_ADDR_EXP 29
32264: PUSH
32265: LD_INT 1
32267: ST_TO_ADDR
// exit ;
32268: POP
32269: POP
32270: GO 32312
// end else
32272: GO 32308
// begin disable ;
32274: DISABLE
// CenterNowOnUnits ( i ) ;
32275: LD_VAR 0 2
32279: PPUSH
32280: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32284: LD_EXP 40
32288: PPUSH
32289: LD_STRING D17b-JMM-1
32291: PPUSH
32292: CALL_OW 88
// seeBehemoth := true ;
32296: LD_ADDR_EXP 29
32300: PUSH
32301: LD_INT 1
32303: ST_TO_ADDR
// exit ;
32304: POP
32305: POP
32306: GO 32312
// end ; end ;
32308: GO 32206
32310: POP
32311: POP
// end ;
32312: PPOPN 2
32314: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32315: LD_EXP 14
32319: PUSH
32320: LD_INT 123200
32322: GREATEREQUAL
32323: IFFALSE 33536
32325: GO 32327
32327: DISABLE
32328: LD_INT 0
32330: PPUSH
32331: PPUSH
32332: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32333: LD_INT 2
32335: PPUSH
32336: LD_INT 23
32338: PUSH
32339: LD_INT 3
32341: PUSH
32342: LD_INT 3
32344: PUSH
32345: LD_INT 48
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: PUSH
32354: EMPTY
32355: LIST
32356: PPUSH
32357: CALL 64415 0 2
// repeat wait ( 0 0$1 ) ;
32361: LD_INT 35
32363: PPUSH
32364: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32368: LD_INT 22
32370: PUSH
32371: LD_INT 3
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 34
32380: PUSH
32381: LD_INT 48
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PPUSH
32392: CALL_OW 69
32396: IFFALSE 32361
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32398: LD_ADDR_VAR 0 1
32402: PUSH
32403: LD_INT 22
32405: PUSH
32406: LD_INT 3
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 34
32415: PUSH
32416: LD_INT 48
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PPUSH
32427: CALL_OW 69
32431: PUSH
32432: LD_INT 1
32434: ARRAY
32435: ST_TO_ADDR
// missionStage := 12 ;
32436: LD_ADDR_EXP 15
32440: PUSH
32441: LD_INT 12
32443: ST_TO_ADDR
// platonovHasBomb := true ;
32444: LD_ADDR_EXP 30
32448: PUSH
32449: LD_INT 1
32451: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32452: LD_VAR 0 1
32456: PPUSH
32457: LD_INT 181
32459: PPUSH
32460: LD_INT 86
32462: PPUSH
32463: CALL_OW 171
// AddComHold ( bomb ) ;
32467: LD_VAR 0 1
32471: PPUSH
32472: CALL_OW 200
// wait ( 0 0$10 ) ;
32476: LD_INT 350
32478: PPUSH
32479: CALL_OW 67
// DialogueOn ;
32483: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32487: LD_EXP 68
32491: PPUSH
32492: LD_STRING D15-Pla-1
32494: PPUSH
32495: CALL_OW 94
// dec := Query ( Q15a ) ;
32499: LD_ADDR_VAR 0 2
32503: PUSH
32504: LD_STRING Q15a
32506: PPUSH
32507: CALL_OW 97
32511: ST_TO_ADDR
// if dec = 1 then
32512: LD_VAR 0 2
32516: PUSH
32517: LD_INT 1
32519: EQUAL
32520: IFFALSE 32543
// begin Say ( JMM , D15a-JMM-1 ) ;
32522: LD_EXP 40
32526: PPUSH
32527: LD_STRING D15a-JMM-1
32529: PPUSH
32530: CALL_OW 88
// YouLost ( Surrender ) ;
32534: LD_STRING Surrender
32536: PPUSH
32537: CALL_OW 104
// exit ;
32541: GO 33536
// end ; if dec = 2 then
32543: LD_VAR 0 2
32547: PUSH
32548: LD_INT 2
32550: EQUAL
32551: IFFALSE 32620
// begin Say ( JMM , D15b-JMM-1 ) ;
32553: LD_EXP 40
32557: PPUSH
32558: LD_STRING D15b-JMM-1
32560: PPUSH
32561: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32565: LD_EXP 68
32569: PPUSH
32570: LD_STRING D15b-Pla-1
32572: PPUSH
32573: CALL_OW 94
// DialogueOff ;
32577: CALL_OW 7
// wait ( 3 3$00 ) ;
32581: LD_INT 6300
32583: PPUSH
32584: CALL_OW 67
// DialogueOn ;
32588: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32592: LD_EXP 40
32596: PPUSH
32597: LD_STRING D15d-JMM-1a
32599: PPUSH
32600: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32604: LD_EXP 68
32608: PPUSH
32609: LD_STRING D15d-Pla-1
32611: PPUSH
32612: CALL_OW 94
// DialogueOff ;
32616: CALL_OW 7
// end ; if dec = 3 then
32620: LD_VAR 0 2
32624: PUSH
32625: LD_INT 3
32627: EQUAL
32628: IFFALSE 32682
// begin Say ( JMM , D15c-JMM-1 ) ;
32630: LD_EXP 40
32634: PPUSH
32635: LD_STRING D15c-JMM-1
32637: PPUSH
32638: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32642: LD_EXP 68
32646: PPUSH
32647: LD_STRING D15c-Pla-1
32649: PPUSH
32650: CALL_OW 94
// DialogueOff ;
32654: CALL_OW 7
// wait ( 0 0$15 ) ;
32658: LD_INT 525
32660: PPUSH
32661: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32665: LD_VAR 0 1
32669: PPUSH
32670: LD_INT 60
32672: PPUSH
32673: LD_INT 95
32675: PPUSH
32676: CALL_OW 116
// exit ;
32680: GO 33536
// end ; if dec = 4 then
32682: LD_VAR 0 2
32686: PUSH
32687: LD_INT 4
32689: EQUAL
32690: IFFALSE 32720
// begin Say ( JMM , D15d-JMM-1 ) ;
32692: LD_EXP 40
32696: PPUSH
32697: LD_STRING D15d-JMM-1
32699: PPUSH
32700: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32704: LD_EXP 68
32708: PPUSH
32709: LD_STRING D15d-Pla-1
32711: PPUSH
32712: CALL_OW 94
// DialogueOff ;
32716: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32720: LD_EXP 66
32724: PPUSH
32725: CALL_OW 302
32729: IFFALSE 32746
32731: PUSH
32732: LD_EXP 66
32736: PPUSH
32737: CALL_OW 255
32741: PUSH
32742: LD_INT 1
32744: EQUAL
32745: AND
32746: IFFALSE 32779
32748: PUSH
32749: LD_INT 22
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 34
32761: PUSH
32762: LD_INT 8
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PPUSH
32773: CALL_OW 69
32777: NOT
32778: AND
32779: IFFALSE 33428
// begin SetSide ( Friend , 8 ) ;
32781: LD_EXP 66
32785: PPUSH
32786: LD_INT 8
32788: PPUSH
32789: CALL_OW 235
// if IsInUnit ( Friend ) then
32793: LD_EXP 66
32797: PPUSH
32798: CALL_OW 310
32802: IFFALSE 32813
// ComExitBuilding ( Friend ) ;
32804: LD_EXP 66
32808: PPUSH
32809: CALL_OW 122
// if IsDriver ( Friend ) then
32813: LD_EXP 66
32817: PPUSH
32818: CALL 106651 0 1
32822: IFFALSE 32833
// ComExitVehicle ( Friend ) ;
32824: LD_EXP 66
32828: PPUSH
32829: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32833: LD_EXP 66
32837: PPUSH
32838: LD_INT 9
32840: PPUSH
32841: LD_INT 2
32843: PPUSH
32844: CALL_OW 171
// wait ( 0 0$05 ) ;
32848: LD_INT 175
32850: PPUSH
32851: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32855: LD_EXP 66
32859: PPUSH
32860: CALL_OW 87
// DialogueOn ;
32864: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32868: LD_EXP 40
32872: PPUSH
32873: LD_STRING D16-JMM-1
32875: PPUSH
32876: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32880: LD_EXP 66
32884: PPUSH
32885: LD_STRING D16-Friend-1
32887: PPUSH
32888: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32892: LD_EXP 40
32896: PPUSH
32897: LD_STRING D16-JMM-2
32899: PPUSH
32900: CALL_OW 88
// DialogueOff ;
32904: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32908: LD_EXP 66
32912: PPUSH
32913: LD_INT 1
32915: PPUSH
32916: CALL_OW 235
// ComHold ( Friend ) ;
32920: LD_EXP 66
32924: PPUSH
32925: CALL_OW 140
// wait ( 0 0$20 ) ;
32929: LD_INT 700
32931: PPUSH
32932: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32936: LD_EXP 66
32940: PPUSH
32941: LD_INT 9
32943: PPUSH
32944: LD_INT 2
32946: PPUSH
32947: CALL_OW 297
32951: PUSH
32952: LD_INT 30
32954: LESS
32955: IFFALSE 33024
// begin SetSide ( Friend , 8 ) ;
32957: LD_EXP 66
32961: PPUSH
32962: LD_INT 8
32964: PPUSH
32965: CALL_OW 235
// if IsInUnit ( Friend ) then
32969: LD_EXP 66
32973: PPUSH
32974: CALL_OW 310
32978: IFFALSE 32989
// ComExitBuilding ( Friend ) ;
32980: LD_EXP 66
32984: PPUSH
32985: CALL_OW 122
// if IsDriver ( Friend ) then
32989: LD_EXP 66
32993: PPUSH
32994: CALL 106651 0 1
32998: IFFALSE 33009
// ComExitVehicle ( Friend ) ;
33000: LD_EXP 66
33004: PPUSH
33005: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
33009: LD_EXP 66
33013: PPUSH
33014: LD_INT 9
33016: PPUSH
33017: LD_INT 2
33019: PPUSH
33020: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
33024: LD_INT 1050
33026: PPUSH
33027: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33031: LD_INT 22
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 34
33043: PUSH
33044: LD_INT 8
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PPUSH
33055: CALL_OW 69
33059: NOT
33060: IFFALSE 33406
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
33062: LD_ADDR_VAR 0 3
33066: PUSH
33067: LD_INT 22
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 26
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 3
33089: PUSH
33090: LD_INT 25
33092: PUSH
33093: LD_INT 12
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 25
33102: PUSH
33103: LD_INT 16
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: LIST
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: LIST
33119: PPUSH
33120: CALL_OW 69
33124: PUSH
33125: LD_EXP 40
33129: PUSH
33130: LD_EXP 42
33134: PUSH
33135: LD_EXP 56
33139: PUSH
33140: LD_EXP 43
33144: PUSH
33145: LD_EXP 44
33149: PUSH
33150: LD_EXP 45
33154: PUSH
33155: LD_EXP 46
33159: PUSH
33160: LD_EXP 47
33164: PUSH
33165: LD_EXP 48
33169: PUSH
33170: LD_EXP 49
33174: PUSH
33175: LD_EXP 50
33179: PUSH
33180: LD_EXP 51
33184: PUSH
33185: LD_EXP 52
33189: PUSH
33190: LD_EXP 53
33194: PUSH
33195: LD_EXP 54
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: DIFF
33217: ST_TO_ADDR
// DialogueOn ;
33218: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
33222: LD_EXP 68
33226: PPUSH
33227: LD_STRING D16a-Pla-1
33229: PPUSH
33230: CALL_OW 94
// if Stevens then
33234: LD_EXP 42
33238: IFFALSE 33254
// Say ( Stevens , D16a-Huck-1 ) else
33240: LD_EXP 42
33244: PPUSH
33245: LD_STRING D16a-Huck-1
33247: PPUSH
33248: CALL_OW 88
33252: GO 33296
// if Baker then
33254: LD_EXP 56
33258: IFFALSE 33274
// Say ( Baker , D16a-Huck-1 ) else
33260: LD_EXP 56
33264: PPUSH
33265: LD_STRING D16a-Huck-1
33267: PPUSH
33268: CALL_OW 88
33272: GO 33296
// if tmp then
33274: LD_VAR 0 3
33278: IFFALSE 33296
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33280: LD_VAR 0 3
33284: PUSH
33285: LD_INT 1
33287: ARRAY
33288: PPUSH
33289: LD_STRING D16a-Sol1-1
33291: PPUSH
33292: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33296: LD_EXP 66
33300: PPUSH
33301: CALL_OW 255
33305: PUSH
33306: LD_INT 8
33308: EQUAL
33309: IFFALSE 33325
// Say ( JMM , D16a-JMM-1 ) else
33311: LD_EXP 40
33315: PPUSH
33316: LD_STRING D16a-JMM-1
33318: PPUSH
33319: CALL_OW 88
33323: GO 33385
// begin Say ( JMM , D16a-JMM-1a ) ;
33325: LD_EXP 40
33329: PPUSH
33330: LD_STRING D16a-JMM-1a
33332: PPUSH
33333: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33337: LD_EXP 66
33341: PPUSH
33342: LD_STRING D16a-Friend-1
33344: PPUSH
33345: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33349: LD_EXP 66
33353: PPUSH
33354: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33358: LD_EXP 66
33362: PPUSH
33363: LD_INT 191
33365: PPUSH
33366: LD_INT 103
33368: PPUSH
33369: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33373: LD_EXP 66
33377: PPUSH
33378: LD_INT 3
33380: PPUSH
33381: CALL_OW 235
// end ; DialogueOff ;
33385: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33389: LD_VAR 0 1
33393: PPUSH
33394: LD_INT 60
33396: PPUSH
33397: LD_INT 95
33399: PPUSH
33400: CALL_OW 116
// end else
33404: GO 33426
// begin DialogueOn ;
33406: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33410: LD_EXP 68
33414: PPUSH
33415: LD_STRING D16c-Pla-1
33417: PPUSH
33418: CALL_OW 94
// DialogueOff ;
33422: CALL_OW 7
// end ; end else
33426: GO 33536
// begin wait ( 3 3$00 ) ;
33428: LD_INT 6300
33430: PPUSH
33431: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) and not bombExploded then
33435: LD_INT 22
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 34
33447: PUSH
33448: LD_INT 8
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PPUSH
33459: CALL_OW 69
33463: NOT
33464: IFFALSE 33473
33466: PUSH
33467: LD_EXP 37
33471: NOT
33472: AND
33473: IFFALSE 33516
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33475: LD_EXP 68
33479: PPUSH
33480: LD_STRING D16b-Pla-1
33482: PPUSH
33483: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33487: LD_EXP 40
33491: PPUSH
33492: LD_STRING D16b-JMM-1
33494: PPUSH
33495: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33499: LD_VAR 0 1
33503: PPUSH
33504: LD_INT 60
33506: PPUSH
33507: LD_INT 95
33509: PPUSH
33510: CALL_OW 116
// end else
33514: GO 33536
// begin DialogueOn ;
33516: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33520: LD_EXP 68
33524: PPUSH
33525: LD_STRING D16c-Pla-1
33527: PPUSH
33528: CALL_OW 94
// DialogueOff ;
33532: CALL_OW 7
// end ; end ; end ;
33536: PPOPN 3
33538: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33539: LD_INT 25
33541: PPUSH
33542: LD_INT 1
33544: PPUSH
33545: CALL_OW 321
33549: PUSH
33550: LD_INT 2
33552: EQUAL
33553: IFTRUE 33565
33555: PUSH
33556: LD_EXP 14
33560: PUSH
33561: LD_INT 126000
33563: GREATEREQUAL
33564: OR
33565: IFFALSE 33574
33567: PUSH
33568: LD_EXP 23
33572: NOT
33573: AND
33574: IFFALSE 33587
33576: PUSH
33577: LD_EXP 79
33581: PPUSH
33582: CALL_OW 302
33586: AND
33587: IFFALSE 33945
33589: GO 33591
33591: DISABLE
33592: LD_INT 0
33594: PPUSH
// begin missionStage := 11 ;
33595: LD_ADDR_EXP 15
33599: PUSH
33600: LD_INT 11
33602: ST_TO_ADDR
// DialogueOn ;
33603: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33607: LD_EXP 79
33611: PPUSH
33612: LD_STRING D9-Roth-1
33614: PPUSH
33615: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33619: LD_EXP 40
33623: PPUSH
33624: LD_STRING D9-JMM-1
33626: PPUSH
33627: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33631: LD_EXP 79
33635: PPUSH
33636: LD_STRING D9-Roth-2
33638: PPUSH
33639: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33643: LD_EXP 79
33647: PPUSH
33648: LD_STRING D9-Roth-2a
33650: PPUSH
33651: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33655: LD_EXP 68
33659: PPUSH
33660: LD_STRING D9-Pla-2
33662: PPUSH
33663: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33667: LD_EXP 79
33671: PPUSH
33672: LD_STRING D9-Roth-3
33674: PPUSH
33675: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33679: LD_EXP 68
33683: PPUSH
33684: LD_STRING D9-Pla-3
33686: PPUSH
33687: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33691: LD_EXP 79
33695: PPUSH
33696: LD_STRING D9-Roth-4
33698: PPUSH
33699: CALL_OW 94
// dec := Query ( Q9 ) ;
33703: LD_ADDR_VAR 0 1
33707: PUSH
33708: LD_STRING Q9
33710: PPUSH
33711: CALL_OW 97
33715: ST_TO_ADDR
// if dec = 1 then
33716: LD_VAR 0 1
33720: PUSH
33721: LD_INT 1
33723: EQUAL
33724: IFFALSE 33738
// SayRadio ( Roth , D9a-Roth-1 ) ;
33726: LD_EXP 79
33730: PPUSH
33731: LD_STRING D9a-Roth-1
33733: PPUSH
33734: CALL_OW 94
// if dec = 2 then
33738: LD_VAR 0 1
33742: PUSH
33743: LD_INT 2
33745: EQUAL
33746: IFFALSE 33772
// begin Say ( JMM , D9b-JMM-1 ) ;
33748: LD_EXP 40
33752: PPUSH
33753: LD_STRING D9b-JMM-1
33755: PPUSH
33756: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33760: LD_EXP 79
33764: PPUSH
33765: LD_STRING D9b-Roth-1
33767: PPUSH
33768: CALL_OW 94
// end ; if dec = 3 then
33772: LD_VAR 0 1
33776: PUSH
33777: LD_INT 3
33779: EQUAL
33780: IFFALSE 33842
// begin Say ( JMM , D9c-JMM-1 ) ;
33782: LD_EXP 40
33786: PPUSH
33787: LD_STRING D9c-JMM-1
33789: PPUSH
33790: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33794: LD_EXP 79
33798: PPUSH
33799: LD_STRING D9c-Roth-1
33801: PPUSH
33802: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33806: LD_EXP 40
33810: PPUSH
33811: LD_STRING D9c-JMM-2
33813: PPUSH
33814: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33818: LD_EXP 79
33822: PPUSH
33823: LD_STRING D9c-Roth-2
33825: PPUSH
33826: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33830: LD_EXP 40
33834: PPUSH
33835: LD_STRING D9c-JMM-3
33837: PPUSH
33838: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33842: LD_EXP 79
33846: PPUSH
33847: LD_STRING D9c-Roth-3
33849: PPUSH
33850: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33854: LD_EXP 79
33858: PPUSH
33859: LD_STRING D9cont-Roth-1
33861: PPUSH
33862: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33866: LD_EXP 40
33870: PPUSH
33871: LD_STRING D9cont-JMM-1
33873: PPUSH
33874: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33878: LD_EXP 79
33882: PPUSH
33883: LD_STRING D9cont-Roth-2
33885: PPUSH
33886: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33890: LD_EXP 40
33894: PPUSH
33895: LD_STRING D9cont-JMM-2
33897: PPUSH
33898: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33902: LD_EXP 79
33906: PPUSH
33907: LD_STRING D9cont-Roth-3
33909: PPUSH
33910: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33914: LD_EXP 40
33918: PPUSH
33919: LD_STRING D9cont-JMM-3
33921: PPUSH
33922: CALL_OW 88
// DialogueOff ;
33926: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33930: LD_STRING M3
33932: PPUSH
33933: CALL_OW 337
// allianceActive := true ;
33937: LD_ADDR_EXP 31
33941: PUSH
33942: LD_INT 1
33944: ST_TO_ADDR
// end ;
33945: PPOPN 1
33947: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33948: LD_INT 1
33950: PPUSH
33951: LD_INT 126
33953: PPUSH
33954: CALL_OW 292
33958: IFFALSE 33971
33960: PUSH
33961: LD_EXP 68
33965: PPUSH
33966: CALL_OW 310
33970: AND
33971: IFFALSE 34124
33973: GO 33975
33975: DISABLE
33976: LD_INT 0
33978: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33979: LD_EXP 68
33983: PPUSH
33984: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33988: LD_ADDR_VAR 0 1
33992: PUSH
33993: LD_INT 4
33995: PPUSH
33996: LD_INT 22
33998: PUSH
33999: LD_INT 1
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PPUSH
34006: CALL_OW 70
34010: PPUSH
34011: LD_EXP 68
34015: PPUSH
34016: CALL_OW 74
34020: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
34021: LD_EXP 68
34025: PPUSH
34026: LD_VAR 0 1
34030: PUSH
34031: LD_INT 1
34033: ARRAY
34034: PPUSH
34035: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
34039: LD_EXP 68
34043: PPUSH
34044: LD_STRING D18-Pla-1
34046: PPUSH
34047: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
34051: LD_INT 22
34053: PUSH
34054: LD_INT 3
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 34
34063: PUSH
34064: LD_INT 48
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PPUSH
34075: CALL_OW 69
34079: IFFALSE 34124
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
34081: LD_INT 22
34083: PUSH
34084: LD_INT 3
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 34
34093: PUSH
34094: LD_INT 48
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PPUSH
34105: CALL_OW 69
34109: PUSH
34110: LD_INT 1
34112: ARRAY
34113: PPUSH
34114: LD_INT 111
34116: PPUSH
34117: LD_INT 97
34119: PPUSH
34120: CALL_OW 116
// end ;
34124: PPOPN 1
34126: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
34127: LD_EXP 68
34131: PPUSH
34132: CALL_OW 301
34136: IFFALSE 34149
34138: PUSH
34139: LD_EXP 71
34143: PPUSH
34144: CALL_OW 301
34148: AND
34149: IFFALSE 34213
34151: PUSH
34152: LD_INT 22
34154: PUSH
34155: LD_INT 3
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 21
34164: PUSH
34165: LD_INT 1
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 50
34174: PUSH
34175: EMPTY
34176: LIST
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: LIST
34182: PPUSH
34183: CALL_OW 69
34187: PUSH
34188: LD_INT 14
34190: PUSH
34191: LD_INT 13
34193: PUSH
34194: LD_INT 12
34196: PUSH
34197: LD_INT 10
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: PUSH
34206: LD_OWVAR 67
34210: ARRAY
34211: LESS
34212: AND
34213: IFFALSE 35014
34215: GO 34217
34217: DISABLE
34218: LD_INT 0
34220: PPUSH
34221: PPUSH
34222: PPUSH
34223: PPUSH
// begin MC_Kill ( 2 ) ;
34224: LD_INT 2
34226: PPUSH
34227: CALL 40134 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
34231: LD_INT 1
34233: PPUSH
34234: LD_INT 3
34236: PPUSH
34237: LD_INT 1
34239: PPUSH
34240: LD_INT 1
34242: PPUSH
34243: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
34247: LD_ADDR_VAR 0 2
34251: PUSH
34252: LD_INT 22
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 21
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 50
34274: PUSH
34275: EMPTY
34276: LIST
34277: PUSH
34278: LD_INT 26
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: PPUSH
34294: CALL_OW 69
34298: ST_TO_ADDR
// if not tmp then
34299: LD_VAR 0 2
34303: NOT
34304: IFFALSE 34360
// begin uc_side = 3 ;
34306: LD_ADDR_OWVAR 20
34310: PUSH
34311: LD_INT 3
34313: ST_TO_ADDR
// uc_nation = 3 ;
34314: LD_ADDR_OWVAR 21
34318: PUSH
34319: LD_INT 3
34321: ST_TO_ADDR
// hc_name =  ;
34322: LD_ADDR_OWVAR 26
34326: PUSH
34327: LD_STRING 
34329: ST_TO_ADDR
// hc_gallery =  ;
34330: LD_ADDR_OWVAR 33
34334: PUSH
34335: LD_STRING 
34337: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34338: LD_INT 1
34340: PPUSH
34341: LD_INT 10
34343: PPUSH
34344: CALL_OW 381
// tmp = CreateHuman ;
34348: LD_ADDR_VAR 0 2
34352: PUSH
34353: CALL_OW 44
34357: ST_TO_ADDR
// end else
34358: GO 34374
// tmp := tmp [ 1 ] ;
34360: LD_ADDR_VAR 0 2
34364: PUSH
34365: LD_VAR 0 2
34369: PUSH
34370: LD_INT 1
34372: ARRAY
34373: ST_TO_ADDR
// DialogueOn ;
34374: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34378: LD_VAR 0 2
34382: PPUSH
34383: LD_STRING DSurrenderRussians-RSol1-1a
34385: PPUSH
34386: CALL_OW 94
// DialogueOff ;
34390: CALL_OW 7
// russianDestroyed := true ;
34394: LD_ADDR_EXP 21
34398: PUSH
34399: LD_INT 1
34401: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34402: LD_ADDR_VAR 0 1
34406: PUSH
34407: LD_INT 22
34409: PUSH
34410: LD_INT 6
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PPUSH
34417: CALL_OW 69
34421: PUSH
34422: FOR_IN
34423: IFFALSE 34436
// KillUnit ( i ) ;
34425: LD_VAR 0 1
34429: PPUSH
34430: CALL_OW 66
34434: GO 34422
34436: POP
34437: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34438: LD_INT 22
34440: PUSH
34441: LD_INT 3
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 21
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PPUSH
34462: CALL_OW 69
34466: PPUSH
34467: CALL_OW 122
// wait ( 0 0$1 ) ;
34471: LD_INT 35
34473: PPUSH
34474: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34478: LD_INT 22
34480: PUSH
34481: LD_INT 3
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 21
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PPUSH
34502: CALL_OW 69
34506: PPUSH
34507: LD_INT 25
34509: PPUSH
34510: CALL_OW 173
// wait ( 0 0$35 ) ;
34514: LD_INT 1225
34516: PPUSH
34517: CALL_OW 67
// PrepareOmarInvasion ;
34521: CALL 16428 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34525: LD_ADDR_VAR 0 2
34529: PUSH
34530: LD_EXP 97
34534: PPUSH
34535: CALL_OW 250
34539: PUSH
34540: LD_EXP 97
34544: PPUSH
34545: CALL_OW 251
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34554: LD_VAR 0 2
34558: PUSH
34559: LD_INT 1
34561: ARRAY
34562: PPUSH
34563: LD_VAR 0 2
34567: PUSH
34568: LD_INT 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: LD_INT 8
34577: NEG
34578: PPUSH
34579: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34583: LD_EXP 97
34587: PPUSH
34588: CALL_OW 87
// DialogueOn ;
34592: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34596: LD_EXP 40
34600: PPUSH
34601: LD_STRING D19-JMM-1
34603: PPUSH
34604: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34608: LD_ADDR_VAR 0 3
34612: PUSH
34613: LD_INT 22
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 26
34625: PUSH
34626: LD_INT 1
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: PUSH
34636: LD_INT 25
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 25
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 25
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 25
34668: PUSH
34669: LD_INT 4
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 25
34678: PUSH
34679: LD_INT 5
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 25
34688: PUSH
34689: LD_INT 8
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: PPUSH
34710: CALL_OW 69
34714: PUSH
34715: LD_EXP 40
34719: PUSH
34720: LD_EXP 41
34724: PUSH
34725: LD_EXP 64
34729: PUSH
34730: LD_EXP 42
34734: PUSH
34735: LD_EXP 43
34739: PUSH
34740: LD_EXP 44
34744: PUSH
34745: LD_EXP 45
34749: PUSH
34750: LD_EXP 46
34754: PUSH
34755: LD_EXP 47
34759: PUSH
34760: LD_EXP 48
34764: PUSH
34765: LD_EXP 49
34769: PUSH
34770: LD_EXP 50
34774: PUSH
34775: LD_EXP 51
34779: PUSH
34780: LD_EXP 52
34784: PUSH
34785: LD_EXP 53
34789: PUSH
34790: LD_EXP 54
34794: PUSH
34795: LD_EXP 55
34799: PUSH
34800: LD_EXP 56
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: DIFF
34825: ST_TO_ADDR
// if tmp2 then
34826: LD_VAR 0 3
34830: IFFALSE 34848
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34832: LD_VAR 0 3
34836: PUSH
34837: LD_INT 1
34839: ARRAY
34840: PPUSH
34841: LD_STRING D19-Sol1-1
34843: PPUSH
34844: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34848: LD_EXP 40
34852: PPUSH
34853: LD_STRING D19-JMM-2
34855: PPUSH
34856: CALL_OW 88
// DialogueOff ;
34860: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34864: LD_VAR 0 2
34868: PUSH
34869: LD_INT 1
34871: ARRAY
34872: PPUSH
34873: LD_VAR 0 2
34877: PUSH
34878: LD_INT 2
34880: ARRAY
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34889: LD_STRING M5
34891: PPUSH
34892: CALL_OW 337
// omarOnMotherLode := false ;
34896: LD_ADDR_VAR 0 4
34900: PUSH
34901: LD_INT 0
34903: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34904: LD_INT 35
34906: PPUSH
34907: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34911: LD_EXP 97
34915: PPUSH
34916: LD_INT 215
34918: PPUSH
34919: LD_INT 100
34921: PPUSH
34922: CALL_OW 297
34926: PUSH
34927: LD_INT 10
34929: LESS
34930: IFFALSE 34939
34932: PUSH
34933: LD_VAR 0 4
34937: NOT
34938: AND
34939: IFFALSE 34973
// begin omarOnMotherLode := true ;
34941: LD_ADDR_VAR 0 4
34945: PUSH
34946: LD_INT 1
34948: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34949: LD_EXP 40
34953: PPUSH
34954: LD_STRING D19b-JMM-1
34956: PPUSH
34957: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34961: LD_EXP 97
34965: PPUSH
34966: LD_STRING DOmarContam-Omar-1
34968: PPUSH
34969: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34973: LD_EXP 97
34977: PPUSH
34978: CALL_OW 301
34982: IFFALSE 34904
// Say ( JMM , D19a-JMM-1 ) ;
34984: LD_EXP 40
34988: PPUSH
34989: LD_STRING D19a-JMM-1
34991: PPUSH
34992: CALL_OW 88
// if Heike then
34996: LD_EXP 98
35000: IFFALSE 35014
// Say ( Heike , D19a-Hke-1 ) ;
35002: LD_EXP 98
35006: PPUSH
35007: LD_STRING D19a-Hke-1
35009: PPUSH
35010: CALL_OW 88
// end ;
35014: PPOPN 4
35016: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
35017: LD_INT 22
35019: PUSH
35020: LD_INT 3
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 21
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PPUSH
35041: CALL_OW 69
35045: IFFALSE 35053
35047: PUSH
35048: LD_EXP 21
35052: AND
35053: IFFALSE 35121
35055: GO 35057
35057: DISABLE
35058: LD_INT 0
35060: PPUSH
35061: PPUSH
// begin enable ;
35062: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
35063: LD_ADDR_VAR 0 2
35067: PUSH
35068: LD_INT 25
35070: PPUSH
35071: LD_INT 22
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PPUSH
35081: CALL_OW 70
35085: ST_TO_ADDR
// if not tmp then
35086: LD_VAR 0 2
35090: NOT
35091: IFFALSE 35095
// exit ;
35093: GO 35121
// for i in tmp do
35095: LD_ADDR_VAR 0 1
35099: PUSH
35100: LD_VAR 0 2
35104: PUSH
35105: FOR_IN
35106: IFFALSE 35119
// RemoveUnit ( i ) ;
35108: LD_VAR 0 1
35112: PPUSH
35113: CALL_OW 64
35117: GO 35105
35119: POP
35120: POP
// end ;
35121: PPOPN 2
35123: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
35124: LD_INT 22
35126: PUSH
35127: LD_INT 7
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 21
35136: PUSH
35137: LD_INT 1
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PPUSH
35148: CALL_OW 69
35152: PUSH
35153: LD_INT 6
35155: LESS
35156: IFFALSE 35624
35158: GO 35160
35160: DISABLE
35161: LD_INT 0
35163: PPUSH
35164: PPUSH
// begin MC_Kill ( 1 ) ;
35165: LD_INT 1
35167: PPUSH
35168: CALL 40134 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
35172: LD_INT 7
35174: PPUSH
35175: LD_INT 1
35177: PPUSH
35178: LD_INT 1
35180: PPUSH
35181: LD_INT 1
35183: PPUSH
35184: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
35188: LD_ADDR_VAR 0 1
35192: PUSH
35193: LD_INT 22
35195: PUSH
35196: LD_INT 7
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 26
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PPUSH
35217: CALL_OW 69
35221: PUSH
35222: LD_EXP 79
35226: DIFF
35227: ST_TO_ADDR
// if tmp then
35228: LD_VAR 0 1
35232: IFFALSE 35250
// tmp := tmp [ 1 ] else
35234: LD_ADDR_VAR 0 1
35238: PUSH
35239: LD_VAR 0 1
35243: PUSH
35244: LD_INT 1
35246: ARRAY
35247: ST_TO_ADDR
35248: GO 35286
// begin uc_side := 7 ;
35250: LD_ADDR_OWVAR 20
35254: PUSH
35255: LD_INT 7
35257: ST_TO_ADDR
// uc_nation := 1 ;
35258: LD_ADDR_OWVAR 21
35262: PUSH
35263: LD_INT 1
35265: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35266: LD_INT 1
35268: PPUSH
35269: LD_INT 8
35271: PPUSH
35272: CALL_OW 384
// tmp := CreateHuman ;
35276: LD_ADDR_VAR 0 1
35280: PUSH
35281: CALL_OW 44
35285: ST_TO_ADDR
// end ; DialogueOn ;
35286: CALL_OW 6
// if IsOK ( Roth ) then
35290: LD_EXP 79
35294: PPUSH
35295: CALL_OW 302
35299: IFFALSE 35313
// Say ( JMM , DAb-JMM-1 ) ;
35301: LD_EXP 40
35305: PPUSH
35306: LD_STRING DAb-JMM-1
35308: PPUSH
35309: CALL_OW 88
// if IsOK ( Roth ) then
35313: LD_EXP 79
35317: PPUSH
35318: CALL_OW 302
35322: IFFALSE 35346
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35324: LD_EXP 79
35328: PPUSH
35329: LD_STRING DSurrenderAlliance-Roth-1
35331: PPUSH
35332: CALL_OW 88
// RothCaptured := true ;
35336: LD_ADDR_EXP 33
35340: PUSH
35341: LD_INT 1
35343: ST_TO_ADDR
// end else
35344: GO 35358
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35346: LD_VAR 0 1
35350: PPUSH
35351: LD_STRING DSurrenderAlliance-Sci1-1
35353: PPUSH
35354: CALL_OW 88
// DialogueOff ;
35358: CALL_OW 7
// allianceDestroyed := true ;
35362: LD_ADDR_EXP 23
35366: PUSH
35367: LD_INT 1
35369: ST_TO_ADDR
// if capturedUnit = 0 then
35370: LD_EXP 34
35374: PUSH
35375: LD_INT 0
35377: EQUAL
35378: IFFALSE 35387
// SetAchievement ( ACH_ALLIANCE ) ;
35380: LD_STRING ACH_ALLIANCE
35382: PPUSH
35383: CALL_OW 543
// if trueAmericans then
35387: LD_EXP 35
35391: IFFALSE 35467
// begin if trueAmericans = 1 then
35393: LD_EXP 35
35397: PUSH
35398: LD_INT 1
35400: EQUAL
35401: IFFALSE 35417
// Say ( JMM , DAb-JMM-1a ) else
35403: LD_EXP 40
35407: PPUSH
35408: LD_STRING DAb-JMM-1a
35410: PPUSH
35411: CALL_OW 88
35415: GO 35429
// Say ( JMM , DAb-JMM-1b ) ;
35417: LD_EXP 40
35421: PPUSH
35422: LD_STRING DAb-JMM-1b
35424: PPUSH
35425: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35429: LD_EXP 35
35433: PPUSH
35434: CALL_OW 87
// for i in trueAmericans do
35438: LD_ADDR_VAR 0 2
35442: PUSH
35443: LD_EXP 35
35447: PUSH
35448: FOR_IN
35449: IFFALSE 35465
// SetSide ( i , 1 ) ;
35451: LD_VAR 0 2
35455: PPUSH
35456: LD_INT 1
35458: PPUSH
35459: CALL_OW 235
35463: GO 35448
35465: POP
35466: POP
// end ; repeat wait ( 0 0$1 ) ;
35467: LD_INT 35
35469: PPUSH
35470: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35474: LD_ADDR_VAR 0 2
35478: PUSH
35479: LD_INT 22
35481: PUSH
35482: LD_INT 7
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 21
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PPUSH
35503: CALL_OW 69
35507: PUSH
35508: FOR_IN
35509: IFFALSE 35591
// begin if IsInUnit ( i ) then
35511: LD_VAR 0 2
35515: PPUSH
35516: CALL_OW 310
35520: IFFALSE 35531
// ComExitBuilding ( i ) ;
35522: LD_VAR 0 2
35526: PPUSH
35527: CALL_OW 122
// if IsDriver ( i ) then
35531: LD_VAR 0 2
35535: PPUSH
35536: CALL 106651 0 1
35540: IFFALSE 35551
// ComExitVehicle ( i ) ;
35542: LD_VAR 0 2
35546: PPUSH
35547: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35551: LD_VAR 0 2
35555: PPUSH
35556: LD_INT 26
35558: PPUSH
35559: CALL_OW 308
35563: NOT
35564: IFFALSE 35580
// AddComMoveToArea ( i , allianceEscapeArea ) else
35566: LD_VAR 0 2
35570: PPUSH
35571: LD_INT 26
35573: PPUSH
35574: CALL_OW 173
35578: GO 35589
// RemoveUnit ( i ) ;
35580: LD_VAR 0 2
35584: PPUSH
35585: CALL_OW 64
// end ;
35589: GO 35508
35591: POP
35592: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35593: LD_INT 22
35595: PUSH
35596: LD_INT 7
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 21
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PPUSH
35617: CALL_OW 69
35621: NOT
35622: IFFALSE 35467
// end ;
35624: PPOPN 2
35626: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35627: LD_INT 0
35629: PPUSH
35630: PPUSH
// if not unit then
35631: LD_VAR 0 1
35635: NOT
35636: IFFALSE 35640
// exit ;
35638: GO 37156
// DoNotAttack ( 7 , unit ) ;
35640: LD_INT 7
35642: PPUSH
35643: LD_VAR 0 1
35647: PPUSH
35648: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35652: LD_VAR 0 1
35656: PPUSH
35657: LD_INT 260
35659: PPUSH
35660: LD_INT 235
35662: PPUSH
35663: LD_INT 3
35665: PPUSH
35666: LD_INT 1
35668: PPUSH
35669: CALL_OW 483
// SetSide ( unit , 4 ) ;
35673: LD_VAR 0 1
35677: PPUSH
35678: LD_INT 4
35680: PPUSH
35681: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35685: LD_ADDR_EXP 34
35689: PUSH
35690: LD_EXP 34
35694: PUSH
35695: LD_INT 1
35697: PLUS
35698: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35699: LD_INT 70
35701: PPUSH
35702: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35706: LD_INT 260
35708: PPUSH
35709: LD_INT 235
35711: PPUSH
35712: LD_INT 1
35714: PPUSH
35715: LD_INT 8
35717: NEG
35718: PPUSH
35719: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35723: LD_VAR 0 1
35727: PPUSH
35728: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35732: LD_VAR 0 1
35736: PPUSH
35737: LD_EXP 79
35741: PPUSH
35742: CALL_OW 119
// DialogueOn ;
35746: CALL_OW 6
// case unit of JMM :
35750: LD_VAR 0 1
35754: PUSH
35755: LD_EXP 40
35759: DOUBLE
35760: EQUAL
35761: IFTRUE 35765
35763: GO 35780
35765: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35766: LD_EXP 40
35770: PPUSH
35771: LD_STRING DA1-JMM-1
35773: PPUSH
35774: CALL_OW 91
35778: GO 36222
35780: LD_EXP 41
35784: DOUBLE
35785: EQUAL
35786: IFTRUE 35790
35788: GO 35805
35790: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35791: LD_EXP 41
35795: PPUSH
35796: LD_STRING DA1-Joan-1
35798: PPUSH
35799: CALL_OW 91
35803: GO 36222
35805: LD_EXP 43
35809: DOUBLE
35810: EQUAL
35811: IFTRUE 35815
35813: GO 35830
35815: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35816: LD_EXP 43
35820: PPUSH
35821: LD_STRING DA1-Lisa-1
35823: PPUSH
35824: CALL_OW 91
35828: GO 36222
35830: LD_EXP 44
35834: DOUBLE
35835: EQUAL
35836: IFTRUE 35840
35838: GO 35855
35840: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35841: LD_EXP 44
35845: PPUSH
35846: LD_STRING DA1-Don-1
35848: PPUSH
35849: CALL_OW 91
35853: GO 36222
35855: LD_EXP 51
35859: DOUBLE
35860: EQUAL
35861: IFTRUE 35865
35863: GO 35880
35865: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35866: LD_EXP 51
35870: PPUSH
35871: LD_STRING DA1-Corn-1
35873: PPUSH
35874: CALL_OW 91
35878: GO 36222
35880: LD_EXP 47
35884: DOUBLE
35885: EQUAL
35886: IFTRUE 35890
35888: GO 35905
35890: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35891: LD_EXP 47
35895: PPUSH
35896: LD_STRING DA1-Den-1
35898: PPUSH
35899: CALL_OW 91
35903: GO 36222
35905: LD_EXP 45
35909: DOUBLE
35910: EQUAL
35911: IFTRUE 35915
35913: GO 35930
35915: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35916: LD_EXP 45
35920: PPUSH
35921: LD_STRING DA1-Bobby-1
35923: PPUSH
35924: CALL_OW 91
35928: GO 36222
35930: LD_EXP 49
35934: DOUBLE
35935: EQUAL
35936: IFTRUE 35940
35938: GO 35955
35940: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35941: LD_EXP 49
35945: PPUSH
35946: LD_STRING DA1-Glad-1
35948: PPUSH
35949: CALL_OW 91
35953: GO 36222
35955: LD_EXP 46
35959: DOUBLE
35960: EQUAL
35961: IFTRUE 35965
35963: GO 35980
35965: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35966: LD_EXP 46
35970: PPUSH
35971: LD_STRING DA1-Cyrus-1
35973: PPUSH
35974: CALL_OW 91
35978: GO 36222
35980: LD_EXP 42
35984: DOUBLE
35985: EQUAL
35986: IFTRUE 35990
35988: GO 36005
35990: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35991: LD_EXP 42
35995: PPUSH
35996: LD_STRING DA1-Huck-1
35998: PPUSH
35999: CALL_OW 91
36003: GO 36222
36005: LD_EXP 56
36009: DOUBLE
36010: EQUAL
36011: IFTRUE 36015
36013: GO 36030
36015: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
36016: LD_EXP 56
36020: PPUSH
36021: LD_STRING DA1-Huck-1
36023: PPUSH
36024: CALL_OW 91
36028: GO 36222
36030: LD_EXP 48
36034: DOUBLE
36035: EQUAL
36036: IFTRUE 36040
36038: GO 36055
36040: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
36041: LD_EXP 48
36045: PPUSH
36046: LD_STRING DA1-Brown-1
36048: PPUSH
36049: CALL_OW 91
36053: GO 36222
36055: LD_EXP 52
36059: DOUBLE
36060: EQUAL
36061: IFTRUE 36065
36063: GO 36080
36065: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
36066: LD_EXP 52
36070: PPUSH
36071: LD_STRING DA1-Gary-1
36073: PPUSH
36074: CALL_OW 91
36078: GO 36222
36080: LD_EXP 55
36084: DOUBLE
36085: EQUAL
36086: IFTRUE 36090
36088: GO 36105
36090: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
36091: LD_EXP 55
36095: PPUSH
36096: LD_STRING DA1-Con-1
36098: PPUSH
36099: CALL_OW 91
36103: GO 36222
36105: LD_EXP 64
36109: DOUBLE
36110: EQUAL
36111: IFTRUE 36115
36113: GO 36130
36115: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
36116: LD_EXP 64
36120: PPUSH
36121: LD_STRING DA1-Kurt-1
36123: PPUSH
36124: CALL_OW 91
36128: GO 36222
36130: LD_EXP 54
36134: DOUBLE
36135: EQUAL
36136: IFTRUE 36140
36138: GO 36155
36140: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
36141: LD_EXP 54
36145: PPUSH
36146: LD_STRING DA1-Yam-1
36148: PPUSH
36149: CALL_OW 91
36153: GO 36222
36155: LD_EXP 53
36159: DOUBLE
36160: EQUAL
36161: IFTRUE 36165
36163: GO 36180
36165: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
36166: LD_EXP 53
36170: PPUSH
36171: LD_STRING DA1-Frank-1
36173: PPUSH
36174: CALL_OW 91
36178: GO 36222
36180: POP
// begin if GetSex ( unit ) = sex_male then
36181: LD_VAR 0 1
36185: PPUSH
36186: CALL_OW 258
36190: PUSH
36191: LD_INT 1
36193: EQUAL
36194: IFFALSE 36210
// ForceSay ( unit , DA1-Sol1-1 ) else
36196: LD_VAR 0 1
36200: PPUSH
36201: LD_STRING DA1-Sol1-1
36203: PPUSH
36204: CALL_OW 91
36208: GO 36222
// ForceSay ( unit , DA1-FSol1-1 ) ;
36210: LD_VAR 0 1
36214: PPUSH
36215: LD_STRING DA1-FSol1-1
36217: PPUSH
36218: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
36222: LD_EXP 79
36226: PPUSH
36227: LD_STRING DA-Roth-1
36229: PPUSH
36230: CALL_OW 88
// if capturedUnit = 1 then
36234: LD_EXP 34
36238: PUSH
36239: LD_INT 1
36241: EQUAL
36242: IFFALSE 36270
// begin Say ( Simms , DA-Sim-1 ) ;
36244: LD_EXP 80
36248: PPUSH
36249: LD_STRING DA-Sim-1
36251: PPUSH
36252: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36256: LD_EXP 79
36260: PPUSH
36261: LD_STRING DA-Roth-2
36263: PPUSH
36264: CALL_OW 88
// end else
36268: GO 36282
// Say ( Simms , DA-Sim-2 ) ;
36270: LD_EXP 80
36274: PPUSH
36275: LD_STRING DA-Sim-2
36277: PPUSH
36278: CALL_OW 88
// case unit of JMM :
36282: LD_VAR 0 1
36286: PUSH
36287: LD_EXP 40
36291: DOUBLE
36292: EQUAL
36293: IFTRUE 36297
36295: GO 36312
36297: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36298: LD_EXP 40
36302: PPUSH
36303: LD_STRING DA1-JMM-1a
36305: PPUSH
36306: CALL_OW 91
36310: GO 36829
36312: LD_EXP 41
36316: DOUBLE
36317: EQUAL
36318: IFTRUE 36322
36320: GO 36337
36322: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36323: LD_EXP 41
36327: PPUSH
36328: LD_STRING DA1-Joan-1a
36330: PPUSH
36331: CALL_OW 91
36335: GO 36829
36337: LD_EXP 43
36341: DOUBLE
36342: EQUAL
36343: IFTRUE 36347
36345: GO 36362
36347: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36348: LD_EXP 43
36352: PPUSH
36353: LD_STRING DA1-Lisa-1a
36355: PPUSH
36356: CALL_OW 91
36360: GO 36829
36362: LD_EXP 44
36366: DOUBLE
36367: EQUAL
36368: IFTRUE 36372
36370: GO 36387
36372: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36373: LD_EXP 44
36377: PPUSH
36378: LD_STRING DA1-Don-1a
36380: PPUSH
36381: CALL_OW 91
36385: GO 36829
36387: LD_EXP 51
36391: DOUBLE
36392: EQUAL
36393: IFTRUE 36397
36395: GO 36412
36397: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36398: LD_EXP 51
36402: PPUSH
36403: LD_STRING DA1-Corn-1a
36405: PPUSH
36406: CALL_OW 91
36410: GO 36829
36412: LD_EXP 47
36416: DOUBLE
36417: EQUAL
36418: IFTRUE 36422
36420: GO 36437
36422: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36423: LD_EXP 47
36427: PPUSH
36428: LD_STRING DA1-Den-1a
36430: PPUSH
36431: CALL_OW 91
36435: GO 36829
36437: LD_EXP 45
36441: DOUBLE
36442: EQUAL
36443: IFTRUE 36447
36445: GO 36462
36447: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36448: LD_EXP 45
36452: PPUSH
36453: LD_STRING DA1-Bobby-1a
36455: PPUSH
36456: CALL_OW 91
36460: GO 36829
36462: LD_EXP 49
36466: DOUBLE
36467: EQUAL
36468: IFTRUE 36472
36470: GO 36487
36472: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36473: LD_EXP 49
36477: PPUSH
36478: LD_STRING DA1-Glad-1a
36480: PPUSH
36481: CALL_OW 91
36485: GO 36829
36487: LD_EXP 46
36491: DOUBLE
36492: EQUAL
36493: IFTRUE 36497
36495: GO 36512
36497: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36498: LD_EXP 46
36502: PPUSH
36503: LD_STRING DA1-Cyrus-1a
36505: PPUSH
36506: CALL_OW 91
36510: GO 36829
36512: LD_EXP 42
36516: DOUBLE
36517: EQUAL
36518: IFTRUE 36522
36520: GO 36537
36522: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36523: LD_EXP 42
36527: PPUSH
36528: LD_STRING DA1-Huck-1a
36530: PPUSH
36531: CALL_OW 91
36535: GO 36829
36537: LD_EXP 56
36541: DOUBLE
36542: EQUAL
36543: IFTRUE 36547
36545: GO 36562
36547: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36548: LD_EXP 56
36552: PPUSH
36553: LD_STRING DA1-Huck-1a
36555: PPUSH
36556: CALL_OW 91
36560: GO 36829
36562: LD_EXP 48
36566: DOUBLE
36567: EQUAL
36568: IFTRUE 36572
36570: GO 36587
36572: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36573: LD_EXP 48
36577: PPUSH
36578: LD_STRING DA1-Brown-1a
36580: PPUSH
36581: CALL_OW 91
36585: GO 36829
36587: LD_EXP 52
36591: DOUBLE
36592: EQUAL
36593: IFTRUE 36597
36595: GO 36612
36597: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36598: LD_EXP 52
36602: PPUSH
36603: LD_STRING DA1-Gary-1a
36605: PPUSH
36606: CALL_OW 91
36610: GO 36829
36612: LD_EXP 55
36616: DOUBLE
36617: EQUAL
36618: IFTRUE 36622
36620: GO 36647
36622: POP
// if JMMGirl = 3 then
36623: LD_EXP 7
36627: PUSH
36628: LD_INT 3
36630: EQUAL
36631: IFFALSE 36645
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36633: LD_EXP 55
36637: PPUSH
36638: LD_STRING DA1-Con-1a
36640: PPUSH
36641: CALL_OW 91
36645: GO 36829
36647: LD_EXP 64
36651: DOUBLE
36652: EQUAL
36653: IFTRUE 36657
36655: GO 36672
36657: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36658: LD_EXP 64
36662: PPUSH
36663: LD_STRING DA1-Kurt-1a
36665: PPUSH
36666: CALL_OW 91
36670: GO 36829
36672: LD_EXP 54
36676: DOUBLE
36677: EQUAL
36678: IFTRUE 36682
36680: GO 36697
36682: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36683: LD_EXP 54
36687: PPUSH
36688: LD_STRING DA1-Yam-1a
36690: PPUSH
36691: CALL_OW 91
36695: GO 36829
36697: LD_EXP 53
36701: DOUBLE
36702: EQUAL
36703: IFTRUE 36707
36705: GO 36722
36707: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36708: LD_EXP 53
36712: PPUSH
36713: LD_STRING DA1-Frank-1a
36715: PPUSH
36716: CALL_OW 91
36720: GO 36829
36722: POP
// begin join := rand ( 0 , 1 ) ;
36723: LD_ADDR_VAR 0 3
36727: PUSH
36728: LD_INT 0
36730: PPUSH
36731: LD_INT 1
36733: PPUSH
36734: CALL_OW 12
36738: ST_TO_ADDR
// if join then
36739: LD_VAR 0 3
36743: IFFALSE 36788
// begin if GetSex ( unit ) = sex_male then
36745: LD_VAR 0 1
36749: PPUSH
36750: CALL_OW 258
36754: PUSH
36755: LD_INT 1
36757: EQUAL
36758: IFFALSE 36774
// ForceSay ( unit , DA1-Sol1-1b ) else
36760: LD_VAR 0 1
36764: PPUSH
36765: LD_STRING DA1-Sol1-1b
36767: PPUSH
36768: CALL_OW 91
36772: GO 36786
// ForceSay ( unit , DA1-FSol1-1b ) ;
36774: LD_VAR 0 1
36778: PPUSH
36779: LD_STRING DA1-FSol1-1b
36781: PPUSH
36782: CALL_OW 91
// end else
36786: GO 36829
// begin if GetSex ( unit ) = sex_male then
36788: LD_VAR 0 1
36792: PPUSH
36793: CALL_OW 258
36797: PUSH
36798: LD_INT 1
36800: EQUAL
36801: IFFALSE 36817
// ForceSay ( unit , DA1-Sol1-1a ) else
36803: LD_VAR 0 1
36807: PPUSH
36808: LD_STRING DA1-Sol1-1a
36810: PPUSH
36811: CALL_OW 91
36815: GO 36829
// ForceSay ( unit , DA1-FSol1-1a ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: LD_STRING DA1-FSol1-1a
36824: PPUSH
36825: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36829: LD_VAR 0 1
36833: PUSH
36834: LD_EXP 40
36838: EQUAL
36839: IFFALSE 36850
// begin YouLost ( JMMCaptured ) ;
36841: LD_STRING JMMCaptured
36843: PPUSH
36844: CALL_OW 104
// exit ;
36848: GO 37156
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36850: LD_VAR 0 1
36854: PUSH
36855: LD_EXP 44
36859: PUSH
36860: LD_EXP 47
36864: PUSH
36865: LD_EXP 45
36869: PUSH
36870: LD_EXP 42
36874: PUSH
36875: LD_EXP 56
36879: PUSH
36880: LD_EXP 48
36884: PUSH
36885: LD_EXP 54
36889: PUSH
36890: LD_EXP 58
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: IN
36905: IFTRUE 36913
36907: PUSH
36908: LD_VAR 0 3
36912: OR
36913: IFFALSE 37012
// begin Say ( Roth , DA-Roth-3 ) ;
36915: LD_EXP 79
36919: PPUSH
36920: LD_STRING DA-Roth-3
36922: PPUSH
36923: CALL_OW 88
// SetSide ( unit , 7 ) ;
36927: LD_VAR 0 1
36931: PPUSH
36932: LD_INT 7
36934: PPUSH
36935: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36939: LD_ADDR_EXP 102
36943: PUSH
36944: LD_EXP 102
36948: PPUSH
36949: LD_INT 1
36951: PPUSH
36952: LD_EXP 102
36956: PUSH
36957: LD_INT 1
36959: ARRAY
36960: PUSH
36961: LD_VAR 0 1
36965: ADD
36966: PPUSH
36967: CALL_OW 1
36971: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36972: LD_INT 260
36974: PPUSH
36975: LD_INT 235
36977: PPUSH
36978: LD_INT 1
36980: PPUSH
36981: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36985: LD_VAR 0 1
36989: PPUSH
36990: LD_INT 1000
36992: PPUSH
36993: CALL_OW 234
// DialogueOff ;
36997: CALL_OW 7
// ComFree ( unit ) ;
37001: LD_VAR 0 1
37005: PPUSH
37006: CALL_OW 139
// end else
37010: GO 37093
// begin Say ( Roth , DA-Roth-3a ) ;
37012: LD_EXP 79
37016: PPUSH
37017: LD_STRING DA-Roth-3a
37019: PPUSH
37020: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
37024: LD_ADDR_EXP 35
37028: PUSH
37029: LD_EXP 35
37033: PUSH
37034: LD_VAR 0 1
37038: ADD
37039: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
37040: LD_INT 260
37042: PPUSH
37043: LD_INT 235
37045: PPUSH
37046: LD_INT 1
37048: PPUSH
37049: CALL_OW 331
// SetLives ( unit , 1000 ) ;
37053: LD_VAR 0 1
37057: PPUSH
37058: LD_INT 1000
37060: PPUSH
37061: CALL_OW 234
// DialogueOff ;
37065: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
37069: LD_VAR 0 1
37073: PPUSH
37074: LD_INT 272
37076: PPUSH
37077: LD_INT 254
37079: PPUSH
37080: CALL_OW 111
// AddComHold ( unit ) ;
37084: LD_VAR 0 1
37088: PPUSH
37089: CALL_OW 200
// end ; if capturedUnit = 1 then
37093: LD_EXP 34
37097: PUSH
37098: LD_INT 1
37100: EQUAL
37101: IFFALSE 37156
// begin DialogueOn ;
37103: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
37107: LD_EXP 40
37111: PPUSH
37112: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
37116: LD_EXP 40
37120: PPUSH
37121: LD_STRING DAa-JMM-1
37123: PPUSH
37124: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
37128: LD_EXP 40
37132: PPUSH
37133: LD_STRING DAa-JMM-1a
37135: PPUSH
37136: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
37140: LD_EXP 40
37144: PPUSH
37145: LD_STRING DAa-JMM-1b
37147: PPUSH
37148: CALL_OW 88
// DialogueOff ;
37152: CALL_OW 7
// end ; end ;
37156: LD_VAR 0 2
37160: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
37161: LD_EXP 15
37165: PUSH
37166: LD_INT 13
37168: GREATEREQUAL
37169: IFFALSE 37205
37171: PUSH
37172: LD_INT 22
37174: PUSH
37175: LD_INT 2
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 21
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PPUSH
37196: CALL_OW 69
37200: PUSH
37201: LD_INT 0
37203: EQUAL
37204: AND
37205: IFFALSE 37259
37207: PUSH
37208: LD_INT 22
37210: PUSH
37211: LD_INT 2
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 33
37220: PUSH
37221: LD_INT 5
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 21
37230: PUSH
37231: LD_INT 2
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 50
37240: PUSH
37241: EMPTY
37242: LIST
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: PPUSH
37250: CALL_OW 69
37254: PUSH
37255: LD_INT 0
37257: EQUAL
37258: AND
37259: IFFALSE 37267
37261: PUSH
37262: LD_EXP 21
37266: AND
37267: IFFALSE 37275
37269: PUSH
37270: LD_EXP 22
37274: AND
37275: IFFALSE 37283
37277: PUSH
37278: LD_EXP 23
37282: AND
37283: IFFALSE 38064
37285: GO 37287
37287: DISABLE
37288: LD_INT 0
37290: PPUSH
37291: PPUSH
37292: PPUSH
// begin wait ( 0 0$05 ) ;
37293: LD_INT 175
37295: PPUSH
37296: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37300: LD_INT 22
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 21
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 23
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 50
37332: PUSH
37333: EMPTY
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: PPUSH
37342: CALL_OW 69
37346: PPUSH
37347: CALL 73139 0 1
37351: PUSH
37352: LD_INT 2
37354: LESS
37355: IFFALSE 37366
// begin YouLost ( LostVictory ) ;
37357: LD_STRING LostVictory
37359: PPUSH
37360: CALL_OW 104
// exit ;
37364: GO 38064
// end ; m1 := false ;
37366: LD_ADDR_VAR 0 1
37370: PUSH
37371: LD_INT 0
37373: ST_TO_ADDR
// m2 := false ;
37374: LD_ADDR_VAR 0 2
37378: PUSH
37379: LD_INT 0
37381: ST_TO_ADDR
// m3 := false ;
37382: LD_ADDR_VAR 0 3
37386: PUSH
37387: LD_INT 0
37389: ST_TO_ADDR
// if not bombExploded then
37390: LD_EXP 37
37394: NOT
37395: IFFALSE 37404
// SetAchievement ( ACH_SIBROCKET ) ;
37397: LD_STRING ACH_SIBROCKET
37399: PPUSH
37400: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37404: LD_EXP 66
37408: PPUSH
37409: CALL_OW 255
37413: PUSH
37414: LD_INT 1
37416: EQUAL
37417: IFFALSE 37430
37419: PUSH
37420: LD_EXP 66
37424: PPUSH
37425: CALL_OW 302
37429: AND
37430: IFFALSE 37446
// begin wait ( 3 ) ;
37432: LD_INT 3
37434: PPUSH
37435: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37439: LD_STRING ACH_OPO
37441: PPUSH
37442: CALL_OW 543
// end ; if tick <= 120 120$00 then
37446: LD_OWVAR 1
37450: PUSH
37451: LD_INT 252000
37453: LESSEQUAL
37454: IFFALSE 37470
// begin wait ( 3 ) ;
37456: LD_INT 3
37458: PPUSH
37459: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37463: LD_STRING ACH_ASPEED_15
37465: PPUSH
37466: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37470: LD_EXP 40
37474: PPUSH
37475: CALL_OW 87
// music_class := 5 ;
37479: LD_ADDR_OWVAR 72
37483: PUSH
37484: LD_INT 5
37486: ST_TO_ADDR
// music_nat := 5 ;
37487: LD_ADDR_OWVAR 71
37491: PUSH
37492: LD_INT 5
37494: ST_TO_ADDR
// DialogueOn ;
37495: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37499: LD_EXP 40
37503: PPUSH
37504: LD_STRING D20-JMM-1
37506: PPUSH
37507: CALL_OW 88
// if IsOK ( Joan ) then
37511: LD_EXP 41
37515: PPUSH
37516: CALL_OW 302
37520: IFFALSE 37534
// Say ( Joan , D20-Joan-1 ) ;
37522: LD_EXP 41
37526: PPUSH
37527: LD_STRING D20-Joan-1
37529: PPUSH
37530: CALL_OW 88
// if IsOk ( Lisa ) then
37534: LD_EXP 43
37538: PPUSH
37539: CALL_OW 302
37543: IFFALSE 37557
// Say ( Lisa , D20-Lisa-1 ) ;
37545: LD_EXP 43
37549: PPUSH
37550: LD_STRING D20-Lisa-1
37552: PPUSH
37553: CALL_OW 88
// if IsOk ( Donaldson ) then
37557: LD_EXP 44
37561: PPUSH
37562: CALL_OW 302
37566: IFFALSE 37580
// Say ( Donaldson , D20-Don-1 ) ;
37568: LD_EXP 44
37572: PPUSH
37573: LD_STRING D20-Don-1
37575: PPUSH
37576: CALL_OW 88
// if IsOK ( Cornel ) then
37580: LD_EXP 51
37584: PPUSH
37585: CALL_OW 302
37589: IFFALSE 37603
// Say ( Cornel , D20-Corn-1 ) ;
37591: LD_EXP 51
37595: PPUSH
37596: LD_STRING D20-Corn-1
37598: PPUSH
37599: CALL_OW 88
// if IsOk ( Denis ) then
37603: LD_EXP 47
37607: PPUSH
37608: CALL_OW 302
37612: IFFALSE 37626
// Say ( Denis , D20-Den-1 ) ;
37614: LD_EXP 47
37618: PPUSH
37619: LD_STRING D20-Den-1
37621: PPUSH
37622: CALL_OW 88
// if IsOk ( Bobby ) then
37626: LD_EXP 45
37630: PPUSH
37631: CALL_OW 302
37635: IFFALSE 37649
// Say ( Bobby , D20-Bobby-1 ) ;
37637: LD_EXP 45
37641: PPUSH
37642: LD_STRING D20-Bobby-1
37644: PPUSH
37645: CALL_OW 88
// if IsOk ( Gladstone ) then
37649: LD_EXP 49
37653: PPUSH
37654: CALL_OW 302
37658: IFFALSE 37672
// Say ( Gladstone , D20-Glad-1 ) ;
37660: LD_EXP 49
37664: PPUSH
37665: LD_STRING D20-Glad-1
37667: PPUSH
37668: CALL_OW 88
// if IsOk ( Cyrus ) then
37672: LD_EXP 46
37676: PPUSH
37677: CALL_OW 302
37681: IFFALSE 37695
// Say ( Cyrus , D20-Cyrus-1 ) ;
37683: LD_EXP 46
37687: PPUSH
37688: LD_STRING D20-Cyrus-1
37690: PPUSH
37691: CALL_OW 88
// if IsOk ( Stevens ) then
37695: LD_EXP 42
37699: PPUSH
37700: CALL_OW 302
37704: IFFALSE 37718
// Say ( Stevens , D20-Huck-1 ) ;
37706: LD_EXP 42
37710: PPUSH
37711: LD_STRING D20-Huck-1
37713: PPUSH
37714: CALL_OW 88
// if IsOk ( Brown ) then
37718: LD_EXP 48
37722: PPUSH
37723: CALL_OW 302
37727: IFFALSE 37741
// Say ( Brown , D20-Brown-1 ) ;
37729: LD_EXP 48
37733: PPUSH
37734: LD_STRING D20-Brown-1
37736: PPUSH
37737: CALL_OW 88
// if IsOk ( Gary ) then
37741: LD_EXP 52
37745: PPUSH
37746: CALL_OW 302
37750: IFFALSE 37764
// Say ( Gary , D20-Gary-1 ) ;
37752: LD_EXP 52
37756: PPUSH
37757: LD_STRING D20-Gary-1
37759: PPUSH
37760: CALL_OW 88
// if IsOk ( Connie ) then
37764: LD_EXP 55
37768: PPUSH
37769: CALL_OW 302
37773: IFFALSE 37787
// Say ( Connie , D20-Con-1 ) ;
37775: LD_EXP 55
37779: PPUSH
37780: LD_STRING D20-Con-1
37782: PPUSH
37783: CALL_OW 88
// if IsOk ( Kurt ) then
37787: LD_EXP 64
37791: PPUSH
37792: CALL_OW 302
37796: IFFALSE 37810
// Say ( Kurt , D20-Kurt-1 ) ;
37798: LD_EXP 64
37802: PPUSH
37803: LD_STRING D20-Kurt-1
37805: PPUSH
37806: CALL_OW 88
// if IsOk ( Kikuchi ) then
37810: LD_EXP 54
37814: PPUSH
37815: CALL_OW 302
37819: IFFALSE 37833
// Say ( Kikuchi , D20-Yam-1 ) ;
37821: LD_EXP 54
37825: PPUSH
37826: LD_STRING D20-Yam-1
37828: PPUSH
37829: CALL_OW 88
// if IsOk ( Frank ) then
37833: LD_EXP 53
37837: PPUSH
37838: CALL_OW 302
37842: IFFALSE 37856
// Say ( Frank , D20-Frank-1 ) ;
37844: LD_EXP 53
37848: PPUSH
37849: LD_STRING D20-Frank-1
37851: PPUSH
37852: CALL_OW 88
// DialogueOff ;
37856: CALL_OW 7
// if RothCaptured then
37860: LD_EXP 33
37864: IFFALSE 37886
// begin m1 := true ;
37866: LD_ADDR_VAR 0 1
37870: PUSH
37871: LD_INT 1
37873: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37874: LD_STRING Roth
37876: PPUSH
37877: LD_INT 1
37879: PPUSH
37880: CALL_OW 101
// end else
37884: GO 37897
// AddMedal ( Roth , - 1 ) ;
37886: LD_STRING Roth
37888: PPUSH
37889: LD_INT 1
37891: NEG
37892: PPUSH
37893: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37897: LD_EXP 25
37901: NOT
37902: IFTRUE 37910
37904: PUSH
37905: LD_EXP 27
37909: OR
37910: IFTRUE 37919
37912: PUSH
37913: LD_EXP 28
37917: NOT
37918: OR
37919: IFFALSE 37941
// begin m2 := true ;
37921: LD_ADDR_VAR 0 2
37925: PUSH
37926: LD_INT 1
37928: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37929: LD_STRING Project
37931: PPUSH
37932: LD_INT 1
37934: PPUSH
37935: CALL_OW 101
// end else
37939: GO 37952
// AddMedal ( Project , - 1 ) ;
37941: LD_STRING Project
37943: PPUSH
37944: LD_INT 1
37946: NEG
37947: PPUSH
37948: CALL_OW 101
// if lostCounter = 0 then
37952: LD_EXP 32
37956: PUSH
37957: LD_INT 0
37959: EQUAL
37960: IFFALSE 37982
// begin m3 := true ;
37962: LD_ADDR_VAR 0 3
37966: PUSH
37967: LD_INT 1
37969: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37970: LD_STRING NoLosses
37972: PPUSH
37973: LD_INT 1
37975: PPUSH
37976: CALL_OW 101
// end else
37980: GO 37993
// AddMedal ( NoLosses , - 1 ) ;
37982: LD_STRING NoLosses
37984: PPUSH
37985: LD_INT 1
37987: NEG
37988: PPUSH
37989: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37993: LD_VAR 0 1
37997: IFFALSE 38005
37999: PUSH
38000: LD_VAR 0 2
38004: AND
38005: IFFALSE 38013
38007: PUSH
38008: LD_VAR 0 3
38012: AND
38013: IFFALSE 38025
38015: PUSH
38016: LD_OWVAR 67
38020: PUSH
38021: LD_INT 3
38023: GREATEREQUAL
38024: AND
38025: IFFALSE 38037
// SetAchievementEX ( ACH_AMER , 15 ) ;
38027: LD_STRING ACH_AMER
38029: PPUSH
38030: LD_INT 15
38032: PPUSH
38033: CALL_OW 564
// GiveMedals ( MAIN ) ;
38037: LD_STRING MAIN
38039: PPUSH
38040: CALL_OW 102
// music_class := 4 ;
38044: LD_ADDR_OWVAR 72
38048: PUSH
38049: LD_INT 4
38051: ST_TO_ADDR
// music_nat := 1 ;
38052: LD_ADDR_OWVAR 71
38056: PUSH
38057: LD_INT 1
38059: ST_TO_ADDR
// YouWin ;
38060: CALL_OW 103
// end ; end_of_file
38064: PPOPN 3
38066: END
// export function CustomEvent ( event ) ; begin
38067: LD_INT 0
38069: PPUSH
// end ;
38070: LD_VAR 0 2
38074: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
38075: LD_VAR 0 1
38079: PUSH
38080: LD_INT 1
38082: EQUAL
38083: IFFALSE 38095
38085: PUSH
38086: LD_VAR 0 2
38090: PUSH
38091: LD_INT 4
38093: EQUAL
38094: AND
38095: IFFALSE 38108
38097: PUSH
38098: LD_EXP 61
38102: PPUSH
38103: CALL_OW 300
38107: AND
38108: IFFALSE 38124
// begin wait ( 0 0$2 ) ;
38110: LD_INT 70
38112: PPUSH
38113: CALL_OW 67
// YouLost ( Dismissed ) ;
38117: LD_STRING Dismissed
38119: PPUSH
38120: CALL_OW 104
// end ; end ;
38124: PPOPN 2
38126: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
38127: LD_VAR 0 2
38131: PPUSH
38132: LD_VAR 0 3
38136: PPUSH
38137: LD_INT 18
38139: PPUSH
38140: CALL_OW 309
38144: IFFALSE 38153
// YouLost ( Motherlode3 ) ;
38146: LD_STRING Motherlode3
38148: PPUSH
38149: CALL_OW 104
// end ;
38153: PPOPN 3
38155: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
38156: LD_EXP 27
38160: NOT
38161: IFFALSE 38171
// behemothDone := true ;
38163: LD_ADDR_EXP 28
38167: PUSH
38168: LD_INT 1
38170: ST_TO_ADDR
// end ;
38171: PPOPN 1
38173: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
38174: LD_VAR 0 1
38178: PPUSH
38179: CALL_OW 255
38183: PUSH
38184: LD_INT 1
38186: EQUAL
38187: IFFALSE 38197
// bombExploded := true ;
38189: LD_ADDR_EXP 37
38193: PUSH
38194: LD_INT 1
38196: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
38197: LD_VAR 0 1
38201: PPUSH
38202: CALL_OW 255
38206: PUSH
38207: LD_INT 3
38209: EQUAL
38210: IFFALSE 38240
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
38212: LD_INT 2
38214: PPUSH
38215: LD_INT 23
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: LD_INT 48
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: PPUSH
38236: CALL 64415 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
38240: LD_VAR 0 1
38244: PPUSH
38245: CALL_OW 255
38249: PUSH
38250: LD_INT 1
38252: EQUAL
38253: IFFALSE 38270
38255: PUSH
38256: LD_EXP 66
38260: PPUSH
38261: CALL_OW 255
38265: PUSH
38266: LD_INT 1
38268: EQUAL
38269: AND
38270: IFFALSE 38283
38272: PUSH
38273: LD_EXP 66
38277: PPUSH
38278: CALL_OW 302
38282: AND
38283: IFFALSE 38291
38285: PUSH
38286: LD_EXP 30
38290: AND
38291: IFFALSE 38323
38293: PUSH
38294: LD_INT 22
38296: PUSH
38297: LD_INT 3
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 34
38306: PUSH
38307: LD_INT 48
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PPUSH
38318: CALL_OW 69
38322: AND
38323: IFFALSE 38356
38325: PUSH
38326: LD_INT 22
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 34
38338: PUSH
38339: LD_INT 8
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PPUSH
38350: CALL_OW 69
38354: NOT
38355: AND
38356: IFFALSE 38408
// begin wait ( 0 0$5 ) ;
38358: LD_INT 175
38360: PPUSH
38361: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38365: LD_INT 22
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 34
38377: PUSH
38378: LD_INT 48
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PPUSH
38389: CALL_OW 69
38393: PUSH
38394: LD_INT 1
38396: ARRAY
38397: PPUSH
38398: LD_INT 60
38400: PPUSH
38401: LD_INT 95
38403: PPUSH
38404: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38408: LD_VAR 0 2
38412: PPUSH
38413: LD_VAR 0 3
38417: PPUSH
38418: LD_INT 18
38420: PPUSH
38421: CALL_OW 309
38425: IFTRUE 38446
38427: PUSH
38428: LD_VAR 0 2
38432: PPUSH
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_INT 18
38440: PPUSH
38441: CALL 113056 0 3
38445: OR
38446: IFFALSE 38493
// begin if GetSide ( unit ) = 1 then
38448: LD_VAR 0 1
38452: PPUSH
38453: CALL_OW 255
38457: PUSH
38458: LD_INT 1
38460: EQUAL
38461: IFFALSE 38479
// begin wait ( 0 0$6 ) ;
38463: LD_INT 210
38465: PPUSH
38466: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38470: LD_STRING Motherlode2
38472: PPUSH
38473: CALL_OW 104
// end else
38477: GO 38493
// begin wait ( 0 0$6 ) ;
38479: LD_INT 210
38481: PPUSH
38482: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38486: LD_STRING Motherlode1
38488: PPUSH
38489: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38493: LD_VAR 0 1
38497: PPUSH
38498: CALL_OW 255
38502: PUSH
38503: LD_INT 3
38505: EQUAL
38506: IFFALSE 38527
// begin wait ( 0 0$5 ) ;
38508: LD_INT 175
38510: PPUSH
38511: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38515: LD_EXP 68
38519: PPUSH
38520: LD_STRING D18-Pla-1
38522: PPUSH
38523: CALL_OW 94
// end ; end ;
38527: PPOPN 3
38529: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38530: LD_VAR 0 1
38534: PPUSH
38535: CALL 130418 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 22
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 21
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 23
38566: PUSH
38567: LD_INT 1
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: PPUSH
38579: CALL_OW 69
38583: IN
38584: IFFALSE 38600
// lostCounter := lostCounter + 1 ;
38586: LD_ADDR_EXP 32
38590: PUSH
38591: LD_EXP 32
38595: PUSH
38596: LD_INT 1
38598: PLUS
38599: ST_TO_ADDR
// if un in behemothBuilders then
38600: LD_VAR 0 1
38604: PUSH
38605: LD_EXP 77
38609: IN
38610: IFFALSE 38630
// begin behemothBuilders := behemothBuilders diff un ;
38612: LD_ADDR_EXP 77
38616: PUSH
38617: LD_EXP 77
38621: PUSH
38622: LD_VAR 0 1
38626: DIFF
38627: ST_TO_ADDR
// exit ;
38628: GO 38660
// end ; if un = JMM then
38630: LD_VAR 0 1
38634: PUSH
38635: LD_EXP 40
38639: EQUAL
38640: IFFALSE 38651
// begin YouLost ( JMM ) ;
38642: LD_STRING JMM
38644: PPUSH
38645: CALL_OW 104
// exit ;
38649: GO 38660
// end ; MCE_UnitDestroyed ( un ) ;
38651: LD_VAR 0 1
38655: PPUSH
38656: CALL 67921 0 1
// end ;
38660: PPOPN 1
38662: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38663: LD_VAR 0 1
38667: PPUSH
38668: LD_VAR 0 2
38672: PPUSH
38673: CALL 70275 0 2
// end ;
38677: PPOPN 2
38679: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38680: LD_VAR 0 1
38684: PPUSH
38685: CALL 69339 0 1
// end ;
38689: PPOPN 1
38691: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 22
38699: PUSH
38700: LD_INT 8
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 30
38709: PUSH
38710: LD_INT 2
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 23
38719: PUSH
38720: LD_INT 3
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: PPUSH
38732: CALL_OW 69
38736: IN
38737: IFFALSE 38764
// begin ComUpgrade ( building ) ;
38739: LD_VAR 0 1
38743: PPUSH
38744: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38748: LD_EXP 65
38752: PPUSH
38753: LD_VAR 0 1
38757: PPUSH
38758: CALL 79275 0 2
// exit ;
38762: GO 38773
// end ; MCE_BuildingComplete ( building ) ;
38764: LD_VAR 0 1
38768: PPUSH
38769: CALL 69582 0 1
// end ;
38773: PPOPN 1
38775: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38776: LD_VAR 0 1
38780: PPUSH
38781: LD_VAR 0 2
38785: PPUSH
38786: CALL 67609 0 2
// end ;
38790: PPOPN 2
38792: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38793: LD_VAR 0 1
38797: PPUSH
38798: LD_VAR 0 2
38802: PPUSH
38803: LD_VAR 0 3
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_VAR 0 5
38817: PPUSH
38818: CALL 67227 0 5
// end ;
38822: PPOPN 5
38824: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38825: LD_VAR 0 1
38829: PPUSH
38830: CALL_OW 255
38834: PUSH
38835: LD_INT 1
38837: EQUAL
38838: IFFALSE 38855
// amConstructCounter := Inc ( amConstructCounter ) ;
38840: LD_ADDR_EXP 39
38844: PUSH
38845: LD_EXP 39
38849: PPUSH
38850: CALL 110444 0 1
38854: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38855: LD_VAR 0 1
38859: PPUSH
38860: LD_VAR 0 2
38864: PPUSH
38865: CALL 130476 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38869: LD_VAR 0 1
38873: PPUSH
38874: LD_VAR 0 2
38878: PPUSH
38879: CALL 66776 0 2
// end ;
38883: PPOPN 2
38885: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38886: LD_VAR 0 1
38890: PPUSH
38891: LD_VAR 0 2
38895: PPUSH
38896: LD_VAR 0 3
38900: PPUSH
38901: LD_VAR 0 4
38905: PPUSH
38906: CALL 66608 0 4
// end ;
38910: PPOPN 4
38912: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38913: LD_VAR 0 1
38917: PPUSH
38918: LD_VAR 0 2
38922: PPUSH
38923: LD_VAR 0 3
38927: PPUSH
38928: CALL 66381 0 3
// end ;
38932: PPOPN 3
38934: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38935: LD_VAR 0 1
38939: PPUSH
38940: LD_VAR 0 2
38944: PPUSH
38945: CALL 66264 0 2
// end ;
38949: PPOPN 2
38951: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38952: LD_VAR 0 1
38956: PPUSH
38957: LD_VAR 0 2
38961: PPUSH
38962: CALL 70572 0 2
// end ;
38966: PPOPN 2
38968: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38969: LD_VAR 0 1
38973: PUSH
38974: LD_INT 460
38976: EQUAL
38977: IFFALSE 38999
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38979: LD_VAR 0 2
38983: PPUSH
38984: LD_INT 227
38986: PPUSH
38987: LD_INT 136
38989: PPUSH
38990: CALL_OW 428
38994: PPUSH
38995: CALL_OW 120
// end ;
38999: PPOPN 2
39001: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
39002: LD_VAR 0 1
39006: PPUSH
39007: CALL_OW 255
39011: PUSH
39012: LD_INT 4
39014: EQUAL
39015: IFFALSE 39033
39017: PUSH
39018: LD_VAR 0 1
39022: PUSH
39023: LD_EXP 18
39027: PUSH
39028: LD_INT 1
39030: ARRAY
39031: IN
39032: AND
39033: IFFALSE 39041
39035: PUSH
39036: LD_EXP 19
39040: AND
39041: IFFALSE 39060
// begin ComMoveXY ( driver , 61 , 93 ) ;
39043: LD_VAR 0 1
39047: PPUSH
39048: LD_INT 61
39050: PPUSH
39051: LD_INT 93
39053: PPUSH
39054: CALL_OW 111
// exit ;
39058: GO 39131
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
39060: LD_VAR 0 1
39064: PPUSH
39065: CALL_OW 255
39069: PUSH
39070: LD_INT 3
39072: EQUAL
39073: IFFALSE 39090
39075: PUSH
39076: LD_VAR 0 1
39080: PPUSH
39081: CALL_OW 110
39085: PUSH
39086: LD_INT 105
39088: EQUAL
39089: AND
39090: IFFALSE 39107
// begin ComMoveXY ( driver , 187 , 92 ) ;
39092: LD_VAR 0 1
39096: PPUSH
39097: LD_INT 187
39099: PPUSH
39100: LD_INT 92
39102: PPUSH
39103: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
39107: LD_VAR 0 1
39111: PPUSH
39112: LD_VAR 0 2
39116: PPUSH
39117: LD_VAR 0 3
39121: PPUSH
39122: LD_VAR 0 4
39126: PPUSH
39127: CALL 70796 0 4
// end ;
39131: PPOPN 4
39133: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
39134: LD_VAR 0 1
39138: PPUSH
39139: LD_VAR 0 2
39143: PPUSH
39144: CALL 66071 0 2
// end ;
39148: PPOPN 2
39150: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
39151: LD_VAR 0 1
39155: PPUSH
39156: CALL 130460 0 1
// end ; end_of_file
39160: PPOPN 1
39162: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
39163: LD_EXP 15
39167: PUSH
39168: LD_INT 2
39170: EQUAL
39171: IFFALSE 39688
39173: GO 39175
39175: DISABLE
39176: LD_INT 0
39178: PPUSH
39179: PPUSH
// begin time := 0 0$35 ;
39180: LD_ADDR_VAR 0 2
39184: PUSH
39185: LD_INT 1225
39187: ST_TO_ADDR
// repeat wait ( time ) ;
39188: LD_VAR 0 2
39192: PPUSH
39193: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
39197: LD_INT 1
39199: PPUSH
39200: LD_INT 5
39202: PPUSH
39203: CALL_OW 12
39207: PPUSH
39208: LD_INT 106
39210: PPUSH
39211: LD_INT 150
39213: PPUSH
39214: LD_INT 19
39216: PPUSH
39217: LD_INT 1
39219: PPUSH
39220: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
39224: LD_INT 455
39226: PPUSH
39227: LD_INT 770
39229: PPUSH
39230: CALL_OW 12
39234: PPUSH
39235: CALL_OW 67
// if Prob ( 50 ) then
39239: LD_INT 50
39241: PPUSH
39242: CALL_OW 13
39246: IFFALSE 39275
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
39248: LD_INT 1
39250: PPUSH
39251: LD_INT 5
39253: PPUSH
39254: CALL_OW 12
39258: PPUSH
39259: LD_INT 62
39261: PPUSH
39262: LD_INT 108
39264: PPUSH
39265: LD_INT 10
39267: PPUSH
39268: LD_INT 1
39270: PPUSH
39271: CALL_OW 56
// until missionStage > 4 ;
39275: LD_EXP 15
39279: PUSH
39280: LD_INT 4
39282: GREATER
39283: IFFALSE 39188
// repeat wait ( 0 0$1 ) ;
39285: LD_INT 35
39287: PPUSH
39288: CALL_OW 67
// until missionStage = 6 ;
39292: LD_EXP 15
39296: PUSH
39297: LD_INT 6
39299: EQUAL
39300: IFFALSE 39285
// time := 0 0$20 ;
39302: LD_ADDR_VAR 0 2
39306: PUSH
39307: LD_INT 700
39309: ST_TO_ADDR
// repeat wait ( time ) ;
39310: LD_VAR 0 2
39314: PPUSH
39315: CALL_OW 67
// if Prob ( 90 ) then
39319: LD_INT 90
39321: PPUSH
39322: CALL_OW 13
39326: IFFALSE 39369
// begin time := time + 0 0$2 ;
39328: LD_ADDR_VAR 0 2
39332: PUSH
39333: LD_VAR 0 2
39337: PUSH
39338: LD_INT 70
39340: PLUS
39341: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39342: LD_INT 1
39344: PPUSH
39345: LD_INT 5
39347: PPUSH
39348: CALL_OW 12
39352: PPUSH
39353: LD_INT 106
39355: PPUSH
39356: LD_INT 89
39358: PPUSH
39359: LD_INT 45
39361: PPUSH
39362: LD_INT 1
39364: PPUSH
39365: CALL_OW 56
// end ; if Prob ( 45 ) then
39369: LD_INT 45
39371: PPUSH
39372: CALL_OW 13
39376: IFFALSE 39432
// begin for i := 1 to 4 do
39378: LD_ADDR_VAR 0 1
39382: PUSH
39383: DOUBLE
39384: LD_INT 1
39386: DEC
39387: ST_TO_ADDR
39388: LD_INT 4
39390: PUSH
39391: FOR_TO
39392: IFFALSE 39430
// begin wait ( 0 0$5 ) ;
39394: LD_INT 175
39396: PPUSH
39397: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39401: LD_INT 1
39403: PPUSH
39404: LD_INT 5
39406: PPUSH
39407: CALL_OW 12
39411: PPUSH
39412: LD_INT 113
39414: PPUSH
39415: LD_INT 117
39417: PPUSH
39418: LD_INT 25
39420: PPUSH
39421: LD_INT 1
39423: PPUSH
39424: CALL_OW 56
// end ;
39428: GO 39391
39430: POP
39431: POP
// end ; if Prob ( 40 ) then
39432: LD_INT 40
39434: PPUSH
39435: CALL_OW 13
39439: IFFALSE 39485
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39441: LD_INT 385
39443: PPUSH
39444: LD_INT 945
39446: PPUSH
39447: CALL_OW 12
39451: PPUSH
39452: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39456: LD_INT 1
39458: PPUSH
39459: LD_INT 5
39461: PPUSH
39462: CALL_OW 12
39466: PPUSH
39467: LD_INT 21
39469: PPUSH
39470: LD_INT 26
39472: PPUSH
39473: LD_INT 12
39475: PPUSH
39476: LD_INT 1
39478: PPUSH
39479: CALL_OW 56
// end else
39483: GO 39521
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39485: LD_INT 700
39487: PPUSH
39488: LD_INT 1225
39490: PPUSH
39491: CALL_OW 12
39495: PPUSH
39496: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39500: LD_INT 1
39502: PPUSH
39503: LD_INT 5
39505: PPUSH
39506: CALL_OW 12
39510: PPUSH
39511: LD_INT 16
39513: PPUSH
39514: LD_INT 1
39516: PPUSH
39517: CALL_OW 55
// end ; if Prob ( 50 ) then
39521: LD_INT 50
39523: PPUSH
39524: CALL_OW 13
39528: IFFALSE 39574
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39530: LD_INT 700
39532: PPUSH
39533: LD_INT 1050
39535: PPUSH
39536: CALL_OW 12
39540: PPUSH
39541: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39545: LD_INT 1
39547: PPUSH
39548: LD_INT 5
39550: PPUSH
39551: CALL_OW 12
39555: PPUSH
39556: LD_INT 168
39558: PPUSH
39559: LD_INT 168
39561: PPUSH
39562: LD_INT 16
39564: PPUSH
39565: LD_INT 1
39567: PPUSH
39568: CALL_OW 56
// end else
39572: GO 39610
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39574: LD_INT 350
39576: PPUSH
39577: LD_INT 525
39579: PPUSH
39580: CALL_OW 12
39584: PPUSH
39585: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39589: LD_INT 1
39591: PPUSH
39592: LD_INT 5
39594: PPUSH
39595: CALL_OW 12
39599: PPUSH
39600: LD_INT 15
39602: PPUSH
39603: LD_INT 1
39605: PPUSH
39606: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39610: LD_INT 175
39612: PPUSH
39613: LD_INT 315
39615: PPUSH
39616: CALL_OW 12
39620: PPUSH
39621: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39625: LD_INT 1
39627: PPUSH
39628: LD_INT 5
39630: PPUSH
39631: CALL_OW 12
39635: PPUSH
39636: LD_INT 103
39638: PPUSH
39639: LD_INT 140
39641: PPUSH
39642: LD_INT 20
39644: PPUSH
39645: LD_INT 1
39647: PPUSH
39648: CALL_OW 56
// time := time + 0 0$2 ;
39652: LD_ADDR_VAR 0 2
39656: PUSH
39657: LD_VAR 0 2
39661: PUSH
39662: LD_INT 70
39664: PLUS
39665: ST_TO_ADDR
// if time > 1 1$20 then
39666: LD_VAR 0 2
39670: PUSH
39671: LD_INT 2800
39673: GREATER
39674: IFFALSE 39684
// time := 0 0$30 ;
39676: LD_ADDR_VAR 0 2
39680: PUSH
39681: LD_INT 1050
39683: ST_TO_ADDR
// until false ;
39684: LD_INT 0
39686: IFFALSE 39310
// end ; end_of_file
39688: PPOPN 2
39690: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39691: LD_EXP 13
39695: IFFALSE 39707
39697: PUSH
39698: LD_EXP 15
39702: PUSH
39703: LD_INT 6
39705: GREATEREQUAL
39706: AND
39707: IFFALSE 39744
39709: GO 39711
39711: DISABLE
// begin enable ;
39712: ENABLE
// missionTime := missionTime + 0 0$1 ;
39713: LD_ADDR_EXP 14
39717: PUSH
39718: LD_EXP 14
39722: PUSH
39723: LD_INT 35
39725: PLUS
39726: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39727: LD_ADDR_OWVAR 47
39731: PUSH
39732: LD_STRING #Am15-1
39734: PUSH
39735: LD_EXP 14
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: ST_TO_ADDR
// end ; end_of_file
39744: END
// export function InitNature ; begin
39745: LD_INT 0
39747: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39748: LD_INT 3
39750: PPUSH
39751: LD_INT 3
39753: PPUSH
39754: LD_INT 2
39756: PPUSH
39757: LD_INT 1
39759: PPUSH
39760: LD_INT 1
39762: PPUSH
39763: LD_INT 0
39765: PPUSH
39766: LD_INT 0
39768: PPUSH
39769: LD_INT 20
39771: PPUSH
39772: LD_INT 0
39774: PPUSH
39775: CALL 105722 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39779: LD_INT 2
39781: PPUSH
39782: LD_INT 1
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: LD_INT 1
39790: PPUSH
39791: LD_INT 1
39793: PPUSH
39794: LD_INT 0
39796: PPUSH
39797: LD_INT 0
39799: PPUSH
39800: LD_INT 21
39802: PPUSH
39803: LD_INT 0
39805: PPUSH
39806: CALL 105722 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39810: LD_INT 4
39812: PPUSH
39813: LD_INT 1
39815: PPUSH
39816: LD_INT 2
39818: PPUSH
39819: LD_INT 4
39821: PPUSH
39822: LD_INT 2
39824: PPUSH
39825: LD_INT 1
39827: PPUSH
39828: LD_INT 0
39830: PPUSH
39831: LD_INT 22
39833: PPUSH
39834: LD_INT 0
39836: PPUSH
39837: CALL 105722 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39841: LD_INT 0
39843: PPUSH
39844: LD_INT 0
39846: PPUSH
39847: LD_INT 0
39849: PPUSH
39850: LD_INT 0
39852: PPUSH
39853: LD_INT 0
39855: PPUSH
39856: LD_INT 0
39858: PPUSH
39859: LD_INT 9
39861: PPUSH
39862: LD_INT 0
39864: PPUSH
39865: LD_INT 23
39867: PPUSH
39868: CALL 105722 0 9
// end ; end_of_file
39872: LD_VAR 0 1
39876: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39877: LD_INT 0
39879: PPUSH
39880: PPUSH
// skirmish := false ;
39881: LD_ADDR_EXP 100
39885: PUSH
39886: LD_INT 0
39888: ST_TO_ADDR
// debug_mc := false ;
39889: LD_ADDR_EXP 101
39893: PUSH
39894: LD_INT 0
39896: ST_TO_ADDR
// mc_bases := [ ] ;
39897: LD_ADDR_EXP 102
39901: PUSH
39902: EMPTY
39903: ST_TO_ADDR
// mc_sides := [ ] ;
39904: LD_ADDR_EXP 128
39908: PUSH
39909: EMPTY
39910: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39911: LD_ADDR_EXP 103
39915: PUSH
39916: EMPTY
39917: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39918: LD_ADDR_EXP 104
39922: PUSH
39923: EMPTY
39924: ST_TO_ADDR
// mc_need_heal := [ ] ;
39925: LD_ADDR_EXP 105
39929: PUSH
39930: EMPTY
39931: ST_TO_ADDR
// mc_healers := [ ] ;
39932: LD_ADDR_EXP 106
39936: PUSH
39937: EMPTY
39938: ST_TO_ADDR
// mc_build_list := [ ] ;
39939: LD_ADDR_EXP 107
39943: PUSH
39944: EMPTY
39945: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39946: LD_ADDR_EXP 134
39950: PUSH
39951: EMPTY
39952: ST_TO_ADDR
// mc_builders := [ ] ;
39953: LD_ADDR_EXP 108
39957: PUSH
39958: EMPTY
39959: ST_TO_ADDR
// mc_construct_list := [ ] ;
39960: LD_ADDR_EXP 109
39964: PUSH
39965: EMPTY
39966: ST_TO_ADDR
// mc_turret_list := [ ] ;
39967: LD_ADDR_EXP 110
39971: PUSH
39972: EMPTY
39973: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39974: LD_ADDR_EXP 111
39978: PUSH
39979: EMPTY
39980: ST_TO_ADDR
// mc_miners := [ ] ;
39981: LD_ADDR_EXP 116
39985: PUSH
39986: EMPTY
39987: ST_TO_ADDR
// mc_mines := [ ] ;
39988: LD_ADDR_EXP 115
39992: PUSH
39993: EMPTY
39994: ST_TO_ADDR
// mc_minefields := [ ] ;
39995: LD_ADDR_EXP 117
39999: PUSH
40000: EMPTY
40001: ST_TO_ADDR
// mc_crates := [ ] ;
40002: LD_ADDR_EXP 118
40006: PUSH
40007: EMPTY
40008: ST_TO_ADDR
// mc_crates_collector := [ ] ;
40009: LD_ADDR_EXP 119
40013: PUSH
40014: EMPTY
40015: ST_TO_ADDR
// mc_crates_area := [ ] ;
40016: LD_ADDR_EXP 120
40020: PUSH
40021: EMPTY
40022: ST_TO_ADDR
// mc_vehicles := [ ] ;
40023: LD_ADDR_EXP 121
40027: PUSH
40028: EMPTY
40029: ST_TO_ADDR
// mc_attack := [ ] ;
40030: LD_ADDR_EXP 122
40034: PUSH
40035: EMPTY
40036: ST_TO_ADDR
// mc_produce := [ ] ;
40037: LD_ADDR_EXP 123
40041: PUSH
40042: EMPTY
40043: ST_TO_ADDR
// mc_defender := [ ] ;
40044: LD_ADDR_EXP 124
40048: PUSH
40049: EMPTY
40050: ST_TO_ADDR
// mc_parking := [ ] ;
40051: LD_ADDR_EXP 126
40055: PUSH
40056: EMPTY
40057: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
40058: LD_ADDR_EXP 112
40062: PUSH
40063: EMPTY
40064: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
40065: LD_ADDR_EXP 114
40069: PUSH
40070: EMPTY
40071: ST_TO_ADDR
// mc_scan := [ ] ;
40072: LD_ADDR_EXP 125
40076: PUSH
40077: EMPTY
40078: ST_TO_ADDR
// mc_scan_area := [ ] ;
40079: LD_ADDR_EXP 127
40083: PUSH
40084: EMPTY
40085: ST_TO_ADDR
// mc_tech := [ ] ;
40086: LD_ADDR_EXP 129
40090: PUSH
40091: EMPTY
40092: ST_TO_ADDR
// mc_class := [ ] ;
40093: LD_ADDR_EXP 143
40097: PUSH
40098: EMPTY
40099: ST_TO_ADDR
// mc_class_case_use := [ ] ;
40100: LD_ADDR_EXP 144
40104: PUSH
40105: EMPTY
40106: ST_TO_ADDR
// mc_is_defending := [ ] ;
40107: LD_ADDR_EXP 145
40111: PUSH
40112: EMPTY
40113: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
40114: LD_ADDR_EXP 136
40118: PUSH
40119: EMPTY
40120: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
40121: LD_ADDR_EXP 146
40125: PUSH
40126: LD_INT 0
40128: ST_TO_ADDR
// end ;
40129: LD_VAR 0 1
40133: RET
// export function MC_Kill ( base ) ; begin
40134: LD_INT 0
40136: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
40137: LD_ADDR_EXP 102
40141: PUSH
40142: LD_EXP 102
40146: PPUSH
40147: LD_VAR 0 1
40151: PPUSH
40152: EMPTY
40153: PPUSH
40154: CALL_OW 1
40158: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40159: LD_ADDR_EXP 103
40163: PUSH
40164: LD_EXP 103
40168: PPUSH
40169: LD_VAR 0 1
40173: PPUSH
40174: EMPTY
40175: PPUSH
40176: CALL_OW 1
40180: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40181: LD_ADDR_EXP 104
40185: PUSH
40186: LD_EXP 104
40190: PPUSH
40191: LD_VAR 0 1
40195: PPUSH
40196: EMPTY
40197: PPUSH
40198: CALL_OW 1
40202: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40203: LD_ADDR_EXP 105
40207: PUSH
40208: LD_EXP 105
40212: PPUSH
40213: LD_VAR 0 1
40217: PPUSH
40218: EMPTY
40219: PPUSH
40220: CALL_OW 1
40224: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40225: LD_ADDR_EXP 106
40229: PUSH
40230: LD_EXP 106
40234: PPUSH
40235: LD_VAR 0 1
40239: PPUSH
40240: EMPTY
40241: PPUSH
40242: CALL_OW 1
40246: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40247: LD_ADDR_EXP 107
40251: PUSH
40252: LD_EXP 107
40256: PPUSH
40257: LD_VAR 0 1
40261: PPUSH
40262: EMPTY
40263: PPUSH
40264: CALL_OW 1
40268: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40269: LD_ADDR_EXP 108
40273: PUSH
40274: LD_EXP 108
40278: PPUSH
40279: LD_VAR 0 1
40283: PPUSH
40284: EMPTY
40285: PPUSH
40286: CALL_OW 1
40290: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40291: LD_ADDR_EXP 109
40295: PUSH
40296: LD_EXP 109
40300: PPUSH
40301: LD_VAR 0 1
40305: PPUSH
40306: EMPTY
40307: PPUSH
40308: CALL_OW 1
40312: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40313: LD_ADDR_EXP 110
40317: PUSH
40318: LD_EXP 110
40322: PPUSH
40323: LD_VAR 0 1
40327: PPUSH
40328: EMPTY
40329: PPUSH
40330: CALL_OW 1
40334: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40335: LD_ADDR_EXP 111
40339: PUSH
40340: LD_EXP 111
40344: PPUSH
40345: LD_VAR 0 1
40349: PPUSH
40350: EMPTY
40351: PPUSH
40352: CALL_OW 1
40356: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40357: LD_ADDR_EXP 112
40361: PUSH
40362: LD_EXP 112
40366: PPUSH
40367: LD_VAR 0 1
40371: PPUSH
40372: EMPTY
40373: PPUSH
40374: CALL_OW 1
40378: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40379: LD_ADDR_EXP 113
40383: PUSH
40384: LD_EXP 113
40388: PPUSH
40389: LD_VAR 0 1
40393: PPUSH
40394: LD_INT 0
40396: PPUSH
40397: CALL_OW 1
40401: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40402: LD_ADDR_EXP 114
40406: PUSH
40407: LD_EXP 114
40411: PPUSH
40412: LD_VAR 0 1
40416: PPUSH
40417: EMPTY
40418: PPUSH
40419: CALL_OW 1
40423: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40424: LD_ADDR_EXP 115
40428: PUSH
40429: LD_EXP 115
40433: PPUSH
40434: LD_VAR 0 1
40438: PPUSH
40439: EMPTY
40440: PPUSH
40441: CALL_OW 1
40445: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40446: LD_ADDR_EXP 116
40450: PUSH
40451: LD_EXP 116
40455: PPUSH
40456: LD_VAR 0 1
40460: PPUSH
40461: EMPTY
40462: PPUSH
40463: CALL_OW 1
40467: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40468: LD_ADDR_EXP 117
40472: PUSH
40473: LD_EXP 117
40477: PPUSH
40478: LD_VAR 0 1
40482: PPUSH
40483: EMPTY
40484: PPUSH
40485: CALL_OW 1
40489: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40490: LD_ADDR_EXP 118
40494: PUSH
40495: LD_EXP 118
40499: PPUSH
40500: LD_VAR 0 1
40504: PPUSH
40505: EMPTY
40506: PPUSH
40507: CALL_OW 1
40511: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40512: LD_ADDR_EXP 119
40516: PUSH
40517: LD_EXP 119
40521: PPUSH
40522: LD_VAR 0 1
40526: PPUSH
40527: EMPTY
40528: PPUSH
40529: CALL_OW 1
40533: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40534: LD_ADDR_EXP 120
40538: PUSH
40539: LD_EXP 120
40543: PPUSH
40544: LD_VAR 0 1
40548: PPUSH
40549: EMPTY
40550: PPUSH
40551: CALL_OW 1
40555: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40556: LD_ADDR_EXP 121
40560: PUSH
40561: LD_EXP 121
40565: PPUSH
40566: LD_VAR 0 1
40570: PPUSH
40571: EMPTY
40572: PPUSH
40573: CALL_OW 1
40577: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40578: LD_ADDR_EXP 122
40582: PUSH
40583: LD_EXP 122
40587: PPUSH
40588: LD_VAR 0 1
40592: PPUSH
40593: EMPTY
40594: PPUSH
40595: CALL_OW 1
40599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40600: LD_ADDR_EXP 123
40604: PUSH
40605: LD_EXP 123
40609: PPUSH
40610: LD_VAR 0 1
40614: PPUSH
40615: EMPTY
40616: PPUSH
40617: CALL_OW 1
40621: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40622: LD_ADDR_EXP 124
40626: PUSH
40627: LD_EXP 124
40631: PPUSH
40632: LD_VAR 0 1
40636: PPUSH
40637: EMPTY
40638: PPUSH
40639: CALL_OW 1
40643: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40644: LD_ADDR_EXP 125
40648: PUSH
40649: LD_EXP 125
40653: PPUSH
40654: LD_VAR 0 1
40658: PPUSH
40659: EMPTY
40660: PPUSH
40661: CALL_OW 1
40665: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40666: LD_ADDR_EXP 126
40670: PUSH
40671: LD_EXP 126
40675: PPUSH
40676: LD_VAR 0 1
40680: PPUSH
40681: EMPTY
40682: PPUSH
40683: CALL_OW 1
40687: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40688: LD_ADDR_EXP 127
40692: PUSH
40693: LD_EXP 127
40697: PPUSH
40698: LD_VAR 0 1
40702: PPUSH
40703: EMPTY
40704: PPUSH
40705: CALL_OW 1
40709: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40710: LD_ADDR_EXP 129
40714: PUSH
40715: LD_EXP 129
40719: PPUSH
40720: LD_VAR 0 1
40724: PPUSH
40725: EMPTY
40726: PPUSH
40727: CALL_OW 1
40731: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40732: LD_ADDR_EXP 131
40736: PUSH
40737: LD_EXP 131
40741: PPUSH
40742: LD_VAR 0 1
40746: PPUSH
40747: EMPTY
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40754: LD_ADDR_EXP 132
40758: PUSH
40759: LD_EXP 132
40763: PPUSH
40764: LD_VAR 0 1
40768: PPUSH
40769: EMPTY
40770: PPUSH
40771: CALL_OW 1
40775: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40776: LD_ADDR_EXP 133
40780: PUSH
40781: LD_EXP 133
40785: PPUSH
40786: LD_VAR 0 1
40790: PPUSH
40791: EMPTY
40792: PPUSH
40793: CALL_OW 1
40797: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40798: LD_ADDR_EXP 134
40802: PUSH
40803: LD_EXP 134
40807: PPUSH
40808: LD_VAR 0 1
40812: PPUSH
40813: EMPTY
40814: PPUSH
40815: CALL_OW 1
40819: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40820: LD_ADDR_EXP 135
40824: PUSH
40825: LD_EXP 135
40829: PPUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: EMPTY
40836: PPUSH
40837: CALL_OW 1
40841: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40842: LD_ADDR_EXP 136
40846: PUSH
40847: LD_EXP 136
40851: PPUSH
40852: LD_VAR 0 1
40856: PPUSH
40857: EMPTY
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40864: LD_ADDR_EXP 137
40868: PUSH
40869: LD_EXP 137
40873: PPUSH
40874: LD_VAR 0 1
40878: PPUSH
40879: EMPTY
40880: PPUSH
40881: CALL_OW 1
40885: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40886: LD_ADDR_EXP 138
40890: PUSH
40891: LD_EXP 138
40895: PPUSH
40896: LD_VAR 0 1
40900: PPUSH
40901: EMPTY
40902: PPUSH
40903: CALL_OW 1
40907: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40908: LD_ADDR_EXP 139
40912: PUSH
40913: LD_EXP 139
40917: PPUSH
40918: LD_VAR 0 1
40922: PPUSH
40923: EMPTY
40924: PPUSH
40925: CALL_OW 1
40929: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40930: LD_ADDR_EXP 140
40934: PUSH
40935: LD_EXP 140
40939: PPUSH
40940: LD_VAR 0 1
40944: PPUSH
40945: EMPTY
40946: PPUSH
40947: CALL_OW 1
40951: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40952: LD_ADDR_EXP 141
40956: PUSH
40957: LD_EXP 141
40961: PPUSH
40962: LD_VAR 0 1
40966: PPUSH
40967: EMPTY
40968: PPUSH
40969: CALL_OW 1
40973: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40974: LD_ADDR_EXP 142
40978: PUSH
40979: LD_EXP 142
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: EMPTY
40990: PPUSH
40991: CALL_OW 1
40995: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40996: LD_ADDR_EXP 143
41000: PUSH
41001: LD_EXP 143
41005: PPUSH
41006: LD_VAR 0 1
41010: PPUSH
41011: EMPTY
41012: PPUSH
41013: CALL_OW 1
41017: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41018: LD_ADDR_EXP 144
41022: PUSH
41023: LD_EXP 144
41027: PPUSH
41028: LD_VAR 0 1
41032: PPUSH
41033: LD_INT 0
41035: PPUSH
41036: CALL_OW 1
41040: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41041: LD_ADDR_EXP 145
41045: PUSH
41046: LD_EXP 145
41050: PPUSH
41051: LD_VAR 0 1
41055: PPUSH
41056: LD_INT 0
41058: PPUSH
41059: CALL_OW 1
41063: ST_TO_ADDR
// end ;
41064: LD_VAR 0 2
41068: RET
// export function MC_Add ( side , units ) ; var base ; begin
41069: LD_INT 0
41071: PPUSH
41072: PPUSH
// base := mc_bases + 1 ;
41073: LD_ADDR_VAR 0 4
41077: PUSH
41078: LD_EXP 102
41082: PUSH
41083: LD_INT 1
41085: PLUS
41086: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
41087: LD_ADDR_EXP 128
41091: PUSH
41092: LD_EXP 128
41096: PPUSH
41097: LD_VAR 0 4
41101: PPUSH
41102: LD_VAR 0 1
41106: PPUSH
41107: CALL_OW 1
41111: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
41112: LD_ADDR_EXP 102
41116: PUSH
41117: LD_EXP 102
41121: PPUSH
41122: LD_VAR 0 4
41126: PPUSH
41127: LD_VAR 0 2
41131: PPUSH
41132: CALL_OW 1
41136: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41137: LD_ADDR_EXP 103
41141: PUSH
41142: LD_EXP 103
41146: PPUSH
41147: LD_VAR 0 4
41151: PPUSH
41152: EMPTY
41153: PPUSH
41154: CALL_OW 1
41158: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41159: LD_ADDR_EXP 104
41163: PUSH
41164: LD_EXP 104
41168: PPUSH
41169: LD_VAR 0 4
41173: PPUSH
41174: EMPTY
41175: PPUSH
41176: CALL_OW 1
41180: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41181: LD_ADDR_EXP 105
41185: PUSH
41186: LD_EXP 105
41190: PPUSH
41191: LD_VAR 0 4
41195: PPUSH
41196: EMPTY
41197: PPUSH
41198: CALL_OW 1
41202: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41203: LD_ADDR_EXP 106
41207: PUSH
41208: LD_EXP 106
41212: PPUSH
41213: LD_VAR 0 4
41217: PPUSH
41218: EMPTY
41219: PPUSH
41220: CALL_OW 1
41224: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41225: LD_ADDR_EXP 107
41229: PUSH
41230: LD_EXP 107
41234: PPUSH
41235: LD_VAR 0 4
41239: PPUSH
41240: EMPTY
41241: PPUSH
41242: CALL_OW 1
41246: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41247: LD_ADDR_EXP 108
41251: PUSH
41252: LD_EXP 108
41256: PPUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: EMPTY
41263: PPUSH
41264: CALL_OW 1
41268: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41269: LD_ADDR_EXP 109
41273: PUSH
41274: LD_EXP 109
41278: PPUSH
41279: LD_VAR 0 4
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41291: LD_ADDR_EXP 110
41295: PUSH
41296: LD_EXP 110
41300: PPUSH
41301: LD_VAR 0 4
41305: PPUSH
41306: EMPTY
41307: PPUSH
41308: CALL_OW 1
41312: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41313: LD_ADDR_EXP 111
41317: PUSH
41318: LD_EXP 111
41322: PPUSH
41323: LD_VAR 0 4
41327: PPUSH
41328: EMPTY
41329: PPUSH
41330: CALL_OW 1
41334: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41335: LD_ADDR_EXP 112
41339: PUSH
41340: LD_EXP 112
41344: PPUSH
41345: LD_VAR 0 4
41349: PPUSH
41350: EMPTY
41351: PPUSH
41352: CALL_OW 1
41356: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41357: LD_ADDR_EXP 113
41361: PUSH
41362: LD_EXP 113
41366: PPUSH
41367: LD_VAR 0 4
41371: PPUSH
41372: LD_INT 0
41374: PPUSH
41375: CALL_OW 1
41379: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41380: LD_ADDR_EXP 114
41384: PUSH
41385: LD_EXP 114
41389: PPUSH
41390: LD_VAR 0 4
41394: PPUSH
41395: EMPTY
41396: PPUSH
41397: CALL_OW 1
41401: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41402: LD_ADDR_EXP 115
41406: PUSH
41407: LD_EXP 115
41411: PPUSH
41412: LD_VAR 0 4
41416: PPUSH
41417: EMPTY
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41424: LD_ADDR_EXP 116
41428: PUSH
41429: LD_EXP 116
41433: PPUSH
41434: LD_VAR 0 4
41438: PPUSH
41439: EMPTY
41440: PPUSH
41441: CALL_OW 1
41445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41446: LD_ADDR_EXP 117
41450: PUSH
41451: LD_EXP 117
41455: PPUSH
41456: LD_VAR 0 4
41460: PPUSH
41461: EMPTY
41462: PPUSH
41463: CALL_OW 1
41467: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41468: LD_ADDR_EXP 118
41472: PUSH
41473: LD_EXP 118
41477: PPUSH
41478: LD_VAR 0 4
41482: PPUSH
41483: EMPTY
41484: PPUSH
41485: CALL_OW 1
41489: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41490: LD_ADDR_EXP 119
41494: PUSH
41495: LD_EXP 119
41499: PPUSH
41500: LD_VAR 0 4
41504: PPUSH
41505: EMPTY
41506: PPUSH
41507: CALL_OW 1
41511: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41512: LD_ADDR_EXP 120
41516: PUSH
41517: LD_EXP 120
41521: PPUSH
41522: LD_VAR 0 4
41526: PPUSH
41527: EMPTY
41528: PPUSH
41529: CALL_OW 1
41533: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41534: LD_ADDR_EXP 121
41538: PUSH
41539: LD_EXP 121
41543: PPUSH
41544: LD_VAR 0 4
41548: PPUSH
41549: EMPTY
41550: PPUSH
41551: CALL_OW 1
41555: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41556: LD_ADDR_EXP 122
41560: PUSH
41561: LD_EXP 122
41565: PPUSH
41566: LD_VAR 0 4
41570: PPUSH
41571: EMPTY
41572: PPUSH
41573: CALL_OW 1
41577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41578: LD_ADDR_EXP 123
41582: PUSH
41583: LD_EXP 123
41587: PPUSH
41588: LD_VAR 0 4
41592: PPUSH
41593: EMPTY
41594: PPUSH
41595: CALL_OW 1
41599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41600: LD_ADDR_EXP 124
41604: PUSH
41605: LD_EXP 124
41609: PPUSH
41610: LD_VAR 0 4
41614: PPUSH
41615: EMPTY
41616: PPUSH
41617: CALL_OW 1
41621: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41622: LD_ADDR_EXP 125
41626: PUSH
41627: LD_EXP 125
41631: PPUSH
41632: LD_VAR 0 4
41636: PPUSH
41637: EMPTY
41638: PPUSH
41639: CALL_OW 1
41643: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41644: LD_ADDR_EXP 126
41648: PUSH
41649: LD_EXP 126
41653: PPUSH
41654: LD_VAR 0 4
41658: PPUSH
41659: EMPTY
41660: PPUSH
41661: CALL_OW 1
41665: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41666: LD_ADDR_EXP 127
41670: PUSH
41671: LD_EXP 127
41675: PPUSH
41676: LD_VAR 0 4
41680: PPUSH
41681: EMPTY
41682: PPUSH
41683: CALL_OW 1
41687: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41688: LD_ADDR_EXP 129
41692: PUSH
41693: LD_EXP 129
41697: PPUSH
41698: LD_VAR 0 4
41702: PPUSH
41703: EMPTY
41704: PPUSH
41705: CALL_OW 1
41709: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41710: LD_ADDR_EXP 131
41714: PUSH
41715: LD_EXP 131
41719: PPUSH
41720: LD_VAR 0 4
41724: PPUSH
41725: EMPTY
41726: PPUSH
41727: CALL_OW 1
41731: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41732: LD_ADDR_EXP 132
41736: PUSH
41737: LD_EXP 132
41741: PPUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: EMPTY
41748: PPUSH
41749: CALL_OW 1
41753: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41754: LD_ADDR_EXP 133
41758: PUSH
41759: LD_EXP 133
41763: PPUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: EMPTY
41770: PPUSH
41771: CALL_OW 1
41775: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41776: LD_ADDR_EXP 134
41780: PUSH
41781: LD_EXP 134
41785: PPUSH
41786: LD_VAR 0 4
41790: PPUSH
41791: EMPTY
41792: PPUSH
41793: CALL_OW 1
41797: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41798: LD_ADDR_EXP 135
41802: PUSH
41803: LD_EXP 135
41807: PPUSH
41808: LD_VAR 0 4
41812: PPUSH
41813: EMPTY
41814: PPUSH
41815: CALL_OW 1
41819: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41820: LD_ADDR_EXP 136
41824: PUSH
41825: LD_EXP 136
41829: PPUSH
41830: LD_VAR 0 4
41834: PPUSH
41835: EMPTY
41836: PPUSH
41837: CALL_OW 1
41841: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41842: LD_ADDR_EXP 137
41846: PUSH
41847: LD_EXP 137
41851: PPUSH
41852: LD_VAR 0 4
41856: PPUSH
41857: EMPTY
41858: PPUSH
41859: CALL_OW 1
41863: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41864: LD_ADDR_EXP 138
41868: PUSH
41869: LD_EXP 138
41873: PPUSH
41874: LD_VAR 0 4
41878: PPUSH
41879: EMPTY
41880: PPUSH
41881: CALL_OW 1
41885: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41886: LD_ADDR_EXP 139
41890: PUSH
41891: LD_EXP 139
41895: PPUSH
41896: LD_VAR 0 4
41900: PPUSH
41901: EMPTY
41902: PPUSH
41903: CALL_OW 1
41907: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41908: LD_ADDR_EXP 140
41912: PUSH
41913: LD_EXP 140
41917: PPUSH
41918: LD_VAR 0 4
41922: PPUSH
41923: EMPTY
41924: PPUSH
41925: CALL_OW 1
41929: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41930: LD_ADDR_EXP 141
41934: PUSH
41935: LD_EXP 141
41939: PPUSH
41940: LD_VAR 0 4
41944: PPUSH
41945: EMPTY
41946: PPUSH
41947: CALL_OW 1
41951: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41952: LD_ADDR_EXP 142
41956: PUSH
41957: LD_EXP 142
41961: PPUSH
41962: LD_VAR 0 4
41966: PPUSH
41967: EMPTY
41968: PPUSH
41969: CALL_OW 1
41973: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41974: LD_ADDR_EXP 143
41978: PUSH
41979: LD_EXP 143
41983: PPUSH
41984: LD_VAR 0 4
41988: PPUSH
41989: EMPTY
41990: PPUSH
41991: CALL_OW 1
41995: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41996: LD_ADDR_EXP 144
42000: PUSH
42001: LD_EXP 144
42005: PPUSH
42006: LD_VAR 0 4
42010: PPUSH
42011: LD_INT 0
42013: PPUSH
42014: CALL_OW 1
42018: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
42019: LD_ADDR_EXP 145
42023: PUSH
42024: LD_EXP 145
42028: PPUSH
42029: LD_VAR 0 4
42033: PPUSH
42034: LD_INT 0
42036: PPUSH
42037: CALL_OW 1
42041: ST_TO_ADDR
// result := base ;
42042: LD_ADDR_VAR 0 3
42046: PUSH
42047: LD_VAR 0 4
42051: ST_TO_ADDR
// end ;
42052: LD_VAR 0 3
42056: RET
// export function MC_Start ( ) ; var i ; begin
42057: LD_INT 0
42059: PPUSH
42060: PPUSH
// for i = 1 to mc_bases do
42061: LD_ADDR_VAR 0 2
42065: PUSH
42066: DOUBLE
42067: LD_INT 1
42069: DEC
42070: ST_TO_ADDR
42071: LD_EXP 102
42075: PUSH
42076: FOR_TO
42077: IFFALSE 43177
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
42079: LD_ADDR_EXP 102
42083: PUSH
42084: LD_EXP 102
42088: PPUSH
42089: LD_VAR 0 2
42093: PPUSH
42094: LD_EXP 102
42098: PUSH
42099: LD_VAR 0 2
42103: ARRAY
42104: PUSH
42105: LD_INT 0
42107: DIFF
42108: PPUSH
42109: CALL_OW 1
42113: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
42114: LD_ADDR_EXP 103
42118: PUSH
42119: LD_EXP 103
42123: PPUSH
42124: LD_VAR 0 2
42128: PPUSH
42129: EMPTY
42130: PPUSH
42131: CALL_OW 1
42135: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42136: LD_ADDR_EXP 104
42140: PUSH
42141: LD_EXP 104
42145: PPUSH
42146: LD_VAR 0 2
42150: PPUSH
42151: EMPTY
42152: PPUSH
42153: CALL_OW 1
42157: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
42158: LD_ADDR_EXP 105
42162: PUSH
42163: LD_EXP 105
42167: PPUSH
42168: LD_VAR 0 2
42172: PPUSH
42173: EMPTY
42174: PPUSH
42175: CALL_OW 1
42179: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
42180: LD_ADDR_EXP 106
42184: PUSH
42185: LD_EXP 106
42189: PPUSH
42190: LD_VAR 0 2
42194: PPUSH
42195: EMPTY
42196: PUSH
42197: EMPTY
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PPUSH
42203: CALL_OW 1
42207: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
42208: LD_ADDR_EXP 107
42212: PUSH
42213: LD_EXP 107
42217: PPUSH
42218: LD_VAR 0 2
42222: PPUSH
42223: EMPTY
42224: PPUSH
42225: CALL_OW 1
42229: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
42230: LD_ADDR_EXP 134
42234: PUSH
42235: LD_EXP 134
42239: PPUSH
42240: LD_VAR 0 2
42244: PPUSH
42245: EMPTY
42246: PPUSH
42247: CALL_OW 1
42251: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
42252: LD_ADDR_EXP 108
42256: PUSH
42257: LD_EXP 108
42261: PPUSH
42262: LD_VAR 0 2
42266: PPUSH
42267: EMPTY
42268: PPUSH
42269: CALL_OW 1
42273: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
42274: LD_ADDR_EXP 109
42278: PUSH
42279: LD_EXP 109
42283: PPUSH
42284: LD_VAR 0 2
42288: PPUSH
42289: EMPTY
42290: PPUSH
42291: CALL_OW 1
42295: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
42296: LD_ADDR_EXP 110
42300: PUSH
42301: LD_EXP 110
42305: PPUSH
42306: LD_VAR 0 2
42310: PPUSH
42311: LD_EXP 102
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: PPUSH
42322: LD_INT 2
42324: PUSH
42325: LD_INT 30
42327: PUSH
42328: LD_INT 32
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 30
42337: PUSH
42338: LD_INT 33
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: PPUSH
42350: CALL_OW 72
42354: PPUSH
42355: CALL_OW 1
42359: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42360: LD_ADDR_EXP 111
42364: PUSH
42365: LD_EXP 111
42369: PPUSH
42370: LD_VAR 0 2
42374: PPUSH
42375: LD_EXP 102
42379: PUSH
42380: LD_VAR 0 2
42384: ARRAY
42385: PPUSH
42386: LD_INT 2
42388: PUSH
42389: LD_INT 30
42391: PUSH
42392: LD_INT 32
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 30
42401: PUSH
42402: LD_INT 31
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 58
42416: PUSH
42417: EMPTY
42418: LIST
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PPUSH
42424: CALL_OW 72
42428: PPUSH
42429: CALL_OW 1
42433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42434: LD_ADDR_EXP 112
42438: PUSH
42439: LD_EXP 112
42443: PPUSH
42444: LD_VAR 0 2
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL_OW 1
42455: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42456: LD_ADDR_EXP 116
42460: PUSH
42461: LD_EXP 116
42465: PPUSH
42466: LD_VAR 0 2
42470: PPUSH
42471: EMPTY
42472: PPUSH
42473: CALL_OW 1
42477: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42478: LD_ADDR_EXP 115
42482: PUSH
42483: LD_EXP 115
42487: PPUSH
42488: LD_VAR 0 2
42492: PPUSH
42493: EMPTY
42494: PPUSH
42495: CALL_OW 1
42499: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42500: LD_ADDR_EXP 117
42504: PUSH
42505: LD_EXP 117
42509: PPUSH
42510: LD_VAR 0 2
42514: PPUSH
42515: EMPTY
42516: PPUSH
42517: CALL_OW 1
42521: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42522: LD_ADDR_EXP 118
42526: PUSH
42527: LD_EXP 118
42531: PPUSH
42532: LD_VAR 0 2
42536: PPUSH
42537: EMPTY
42538: PPUSH
42539: CALL_OW 1
42543: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42544: LD_ADDR_EXP 119
42548: PUSH
42549: LD_EXP 119
42553: PPUSH
42554: LD_VAR 0 2
42558: PPUSH
42559: EMPTY
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42566: LD_ADDR_EXP 120
42570: PUSH
42571: LD_EXP 120
42575: PPUSH
42576: LD_VAR 0 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42588: LD_ADDR_EXP 121
42592: PUSH
42593: LD_EXP 121
42597: PPUSH
42598: LD_VAR 0 2
42602: PPUSH
42603: EMPTY
42604: PPUSH
42605: CALL_OW 1
42609: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42610: LD_ADDR_EXP 122
42614: PUSH
42615: LD_EXP 122
42619: PPUSH
42620: LD_VAR 0 2
42624: PPUSH
42625: EMPTY
42626: PPUSH
42627: CALL_OW 1
42631: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42632: LD_ADDR_EXP 123
42636: PUSH
42637: LD_EXP 123
42641: PPUSH
42642: LD_VAR 0 2
42646: PPUSH
42647: EMPTY
42648: PPUSH
42649: CALL_OW 1
42653: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42654: LD_ADDR_EXP 124
42658: PUSH
42659: LD_EXP 124
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: EMPTY
42670: PPUSH
42671: CALL_OW 1
42675: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42676: LD_ADDR_EXP 113
42680: PUSH
42681: LD_EXP 113
42685: PPUSH
42686: LD_VAR 0 2
42690: PPUSH
42691: LD_INT 0
42693: PPUSH
42694: CALL_OW 1
42698: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42699: LD_ADDR_EXP 126
42703: PUSH
42704: LD_EXP 126
42708: PPUSH
42709: LD_VAR 0 2
42713: PPUSH
42714: LD_INT 0
42716: PPUSH
42717: CALL_OW 1
42721: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42722: LD_ADDR_EXP 114
42726: PUSH
42727: LD_EXP 114
42731: PPUSH
42732: LD_VAR 0 2
42736: PPUSH
42737: EMPTY
42738: PPUSH
42739: CALL_OW 1
42743: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42744: LD_ADDR_EXP 125
42748: PUSH
42749: LD_EXP 125
42753: PPUSH
42754: LD_VAR 0 2
42758: PPUSH
42759: LD_INT 0
42761: PPUSH
42762: CALL_OW 1
42766: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42767: LD_ADDR_EXP 127
42771: PUSH
42772: LD_EXP 127
42776: PPUSH
42777: LD_VAR 0 2
42781: PPUSH
42782: EMPTY
42783: PPUSH
42784: CALL_OW 1
42788: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42789: LD_ADDR_EXP 130
42793: PUSH
42794: LD_EXP 130
42798: PPUSH
42799: LD_VAR 0 2
42803: PPUSH
42804: LD_INT 0
42806: PPUSH
42807: CALL_OW 1
42811: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42812: LD_ADDR_EXP 131
42816: PUSH
42817: LD_EXP 131
42821: PPUSH
42822: LD_VAR 0 2
42826: PPUSH
42827: EMPTY
42828: PPUSH
42829: CALL_OW 1
42833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42834: LD_ADDR_EXP 132
42838: PUSH
42839: LD_EXP 132
42843: PPUSH
42844: LD_VAR 0 2
42848: PPUSH
42849: EMPTY
42850: PPUSH
42851: CALL_OW 1
42855: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42856: LD_ADDR_EXP 133
42860: PUSH
42861: LD_EXP 133
42865: PPUSH
42866: LD_VAR 0 2
42870: PPUSH
42871: EMPTY
42872: PPUSH
42873: CALL_OW 1
42877: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42878: LD_ADDR_EXP 135
42882: PUSH
42883: LD_EXP 135
42887: PPUSH
42888: LD_VAR 0 2
42892: PPUSH
42893: LD_EXP 102
42897: PUSH
42898: LD_VAR 0 2
42902: ARRAY
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 6
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 7
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 30
42929: PUSH
42930: LD_INT 8
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: PPUSH
42943: CALL_OW 72
42947: PPUSH
42948: CALL_OW 1
42952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42953: LD_ADDR_EXP 136
42957: PUSH
42958: LD_EXP 136
42962: PPUSH
42963: LD_VAR 0 2
42967: PPUSH
42968: EMPTY
42969: PPUSH
42970: CALL_OW 1
42974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42975: LD_ADDR_EXP 137
42979: PUSH
42980: LD_EXP 137
42984: PPUSH
42985: LD_VAR 0 2
42989: PPUSH
42990: EMPTY
42991: PPUSH
42992: CALL_OW 1
42996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42997: LD_ADDR_EXP 138
43001: PUSH
43002: LD_EXP 138
43006: PPUSH
43007: LD_VAR 0 2
43011: PPUSH
43012: EMPTY
43013: PPUSH
43014: CALL_OW 1
43018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
43019: LD_ADDR_EXP 139
43023: PUSH
43024: LD_EXP 139
43028: PPUSH
43029: LD_VAR 0 2
43033: PPUSH
43034: EMPTY
43035: PPUSH
43036: CALL_OW 1
43040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43041: LD_ADDR_EXP 140
43045: PUSH
43046: LD_EXP 140
43050: PPUSH
43051: LD_VAR 0 2
43055: PPUSH
43056: EMPTY
43057: PPUSH
43058: CALL_OW 1
43062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
43063: LD_ADDR_EXP 141
43067: PUSH
43068: LD_EXP 141
43072: PPUSH
43073: LD_VAR 0 2
43077: PPUSH
43078: EMPTY
43079: PPUSH
43080: CALL_OW 1
43084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
43085: LD_ADDR_EXP 142
43089: PUSH
43090: LD_EXP 142
43094: PPUSH
43095: LD_VAR 0 2
43099: PPUSH
43100: EMPTY
43101: PPUSH
43102: CALL_OW 1
43106: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
43107: LD_ADDR_EXP 143
43111: PUSH
43112: LD_EXP 143
43116: PPUSH
43117: LD_VAR 0 2
43121: PPUSH
43122: EMPTY
43123: PPUSH
43124: CALL_OW 1
43128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
43129: LD_ADDR_EXP 144
43133: PUSH
43134: LD_EXP 144
43138: PPUSH
43139: LD_VAR 0 2
43143: PPUSH
43144: LD_INT 0
43146: PPUSH
43147: CALL_OW 1
43151: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
43152: LD_ADDR_EXP 145
43156: PUSH
43157: LD_EXP 145
43161: PPUSH
43162: LD_VAR 0 2
43166: PPUSH
43167: LD_INT 0
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// end ;
43175: GO 42076
43177: POP
43178: POP
// MC_InitSides ( ) ;
43179: CALL 43465 0 0
// MC_InitResearch ( ) ;
43183: CALL 43204 0 0
// CustomInitMacro ( ) ;
43187: CALL 475 0 0
// skirmish := true ;
43191: LD_ADDR_EXP 100
43195: PUSH
43196: LD_INT 1
43198: ST_TO_ADDR
// end ;
43199: LD_VAR 0 1
43203: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
43204: LD_INT 0
43206: PPUSH
43207: PPUSH
43208: PPUSH
43209: PPUSH
43210: PPUSH
43211: PPUSH
// if not mc_bases then
43212: LD_EXP 102
43216: NOT
43217: IFFALSE 43221
// exit ;
43219: GO 43460
// for i = 1 to 8 do
43221: LD_ADDR_VAR 0 2
43225: PUSH
43226: DOUBLE
43227: LD_INT 1
43229: DEC
43230: ST_TO_ADDR
43231: LD_INT 8
43233: PUSH
43234: FOR_TO
43235: IFFALSE 43261
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
43237: LD_ADDR_EXP 129
43241: PUSH
43242: LD_EXP 129
43246: PPUSH
43247: LD_VAR 0 2
43251: PPUSH
43252: EMPTY
43253: PPUSH
43254: CALL_OW 1
43258: ST_TO_ADDR
43259: GO 43234
43261: POP
43262: POP
// tmp := [ ] ;
43263: LD_ADDR_VAR 0 5
43267: PUSH
43268: EMPTY
43269: ST_TO_ADDR
// for i = 1 to mc_sides do
43270: LD_ADDR_VAR 0 2
43274: PUSH
43275: DOUBLE
43276: LD_INT 1
43278: DEC
43279: ST_TO_ADDR
43280: LD_EXP 128
43284: PUSH
43285: FOR_TO
43286: IFFALSE 43344
// if not mc_sides [ i ] in tmp then
43288: LD_EXP 128
43292: PUSH
43293: LD_VAR 0 2
43297: ARRAY
43298: PUSH
43299: LD_VAR 0 5
43303: IN
43304: NOT
43305: IFFALSE 43342
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43307: LD_ADDR_VAR 0 5
43311: PUSH
43312: LD_VAR 0 5
43316: PPUSH
43317: LD_VAR 0 5
43321: PUSH
43322: LD_INT 1
43324: PLUS
43325: PPUSH
43326: LD_EXP 128
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: PPUSH
43337: CALL_OW 2
43341: ST_TO_ADDR
43342: GO 43285
43344: POP
43345: POP
// if not tmp then
43346: LD_VAR 0 5
43350: NOT
43351: IFFALSE 43355
// exit ;
43353: GO 43460
// for j in tmp do
43355: LD_ADDR_VAR 0 3
43359: PUSH
43360: LD_VAR 0 5
43364: PUSH
43365: FOR_IN
43366: IFFALSE 43458
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43368: LD_ADDR_VAR 0 6
43372: PUSH
43373: LD_INT 22
43375: PUSH
43376: LD_VAR 0 3
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PPUSH
43385: CALL_OW 69
43389: ST_TO_ADDR
// if not un then
43390: LD_VAR 0 6
43394: NOT
43395: IFFALSE 43399
// continue ;
43397: GO 43365
// nation := GetNation ( un [ 1 ] ) ;
43399: LD_ADDR_VAR 0 4
43403: PUSH
43404: LD_VAR 0 6
43408: PUSH
43409: LD_INT 1
43411: ARRAY
43412: PPUSH
43413: CALL_OW 248
43417: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43418: LD_ADDR_EXP 129
43422: PUSH
43423: LD_EXP 129
43427: PPUSH
43428: LD_VAR 0 3
43432: PPUSH
43433: LD_VAR 0 3
43437: PPUSH
43438: LD_VAR 0 4
43442: PPUSH
43443: LD_INT 1
43445: PPUSH
43446: CALL 71086 0 3
43450: PPUSH
43451: CALL_OW 1
43455: ST_TO_ADDR
// end ;
43456: GO 43365
43458: POP
43459: POP
// end ;
43460: LD_VAR 0 1
43464: RET
// export function MC_InitSides ( ) ; var i ; begin
43465: LD_INT 0
43467: PPUSH
43468: PPUSH
// if not mc_bases then
43469: LD_EXP 102
43473: NOT
43474: IFFALSE 43478
// exit ;
43476: GO 43552
// for i = 1 to mc_bases do
43478: LD_ADDR_VAR 0 2
43482: PUSH
43483: DOUBLE
43484: LD_INT 1
43486: DEC
43487: ST_TO_ADDR
43488: LD_EXP 102
43492: PUSH
43493: FOR_TO
43494: IFFALSE 43550
// if mc_bases [ i ] then
43496: LD_EXP 102
43500: PUSH
43501: LD_VAR 0 2
43505: ARRAY
43506: IFFALSE 43548
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43508: LD_ADDR_EXP 128
43512: PUSH
43513: LD_EXP 128
43517: PPUSH
43518: LD_VAR 0 2
43522: PPUSH
43523: LD_EXP 102
43527: PUSH
43528: LD_VAR 0 2
43532: ARRAY
43533: PUSH
43534: LD_INT 1
43536: ARRAY
43537: PPUSH
43538: CALL_OW 255
43542: PPUSH
43543: CALL_OW 1
43547: ST_TO_ADDR
43548: GO 43493
43550: POP
43551: POP
// end ;
43552: LD_VAR 0 1
43556: RET
// every 0 0$03 trigger skirmish do
43557: LD_EXP 100
43561: IFFALSE 43715
43563: GO 43565
43565: DISABLE
// begin enable ;
43566: ENABLE
// MC_CheckBuildings ( ) ;
43567: CALL 48273 0 0
// MC_CheckPeopleLife ( ) ;
43571: CALL 48434 0 0
// RaiseSailEvent ( 100 ) ;
43575: LD_INT 100
43577: PPUSH
43578: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43582: LD_INT 103
43584: PPUSH
43585: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43589: LD_INT 104
43591: PPUSH
43592: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43596: LD_INT 105
43598: PPUSH
43599: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43603: LD_INT 106
43605: PPUSH
43606: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43610: LD_INT 107
43612: PPUSH
43613: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43617: LD_INT 108
43619: PPUSH
43620: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43624: LD_INT 109
43626: PPUSH
43627: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43631: LD_INT 110
43633: PPUSH
43634: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43638: LD_INT 111
43640: PPUSH
43641: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43645: LD_INT 112
43647: PPUSH
43648: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43652: LD_INT 113
43654: PPUSH
43655: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43659: LD_INT 120
43661: PPUSH
43662: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43666: LD_INT 121
43668: PPUSH
43669: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43673: LD_INT 122
43675: PPUSH
43676: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43680: LD_INT 123
43682: PPUSH
43683: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43687: LD_INT 124
43689: PPUSH
43690: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43694: LD_INT 125
43696: PPUSH
43697: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43701: LD_INT 126
43703: PPUSH
43704: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43708: LD_INT 200
43710: PPUSH
43711: CALL_OW 427
// end ;
43715: END
// on SailEvent ( event ) do begin if event < 100 then
43716: LD_VAR 0 1
43720: PUSH
43721: LD_INT 100
43723: LESS
43724: IFFALSE 43735
// CustomEvent ( event ) ;
43726: LD_VAR 0 1
43730: PPUSH
43731: CALL 38067 0 1
// if event = 100 then
43735: LD_VAR 0 1
43739: PUSH
43740: LD_INT 100
43742: EQUAL
43743: IFFALSE 43749
// MC_ClassManager ( ) ;
43745: CALL 44143 0 0
// if event = 101 then
43749: LD_VAR 0 1
43753: PUSH
43754: LD_INT 101
43756: EQUAL
43757: IFFALSE 43763
// MC_RepairBuildings ( ) ;
43759: CALL 49021 0 0
// if event = 102 then
43763: LD_VAR 0 1
43767: PUSH
43768: LD_INT 102
43770: EQUAL
43771: IFFALSE 43777
// MC_Heal ( ) ;
43773: CALL 49960 0 0
// if event = 103 then
43777: LD_VAR 0 1
43781: PUSH
43782: LD_INT 103
43784: EQUAL
43785: IFFALSE 43791
// MC_Build ( ) ;
43787: CALL 50386 0 0
// if event = 104 then
43791: LD_VAR 0 1
43795: PUSH
43796: LD_INT 104
43798: EQUAL
43799: IFFALSE 43805
// MC_TurretWeapon ( ) ;
43801: CALL 52034 0 0
// if event = 105 then
43805: LD_VAR 0 1
43809: PUSH
43810: LD_INT 105
43812: EQUAL
43813: IFFALSE 43819
// MC_BuildUpgrade ( ) ;
43815: CALL 51579 0 0
// if event = 106 then
43819: LD_VAR 0 1
43823: PUSH
43824: LD_INT 106
43826: EQUAL
43827: IFFALSE 43833
// MC_PlantMines ( ) ;
43829: CALL 52466 0 0
// if event = 107 then
43833: LD_VAR 0 1
43837: PUSH
43838: LD_INT 107
43840: EQUAL
43841: IFFALSE 43847
// MC_CollectCrates ( ) ;
43843: CALL 53276 0 0
// if event = 108 then
43847: LD_VAR 0 1
43851: PUSH
43852: LD_INT 108
43854: EQUAL
43855: IFFALSE 43861
// MC_LinkRemoteControl ( ) ;
43857: CALL 55150 0 0
// if event = 109 then
43861: LD_VAR 0 1
43865: PUSH
43866: LD_INT 109
43868: EQUAL
43869: IFFALSE 43875
// MC_ProduceVehicle ( ) ;
43871: CALL 55335 0 0
// if event = 110 then
43875: LD_VAR 0 1
43879: PUSH
43880: LD_INT 110
43882: EQUAL
43883: IFFALSE 43889
// MC_SendAttack ( ) ;
43885: CALL 55805 0 0
// if event = 111 then
43889: LD_VAR 0 1
43893: PUSH
43894: LD_INT 111
43896: EQUAL
43897: IFFALSE 43903
// MC_Defend ( ) ;
43899: CALL 55913 0 0
// if event = 112 then
43903: LD_VAR 0 1
43907: PUSH
43908: LD_INT 112
43910: EQUAL
43911: IFFALSE 43917
// MC_Research ( ) ;
43913: CALL 56813 0 0
// if event = 113 then
43917: LD_VAR 0 1
43921: PUSH
43922: LD_INT 113
43924: EQUAL
43925: IFFALSE 43931
// MC_MinesTrigger ( ) ;
43927: CALL 57953 0 0
// if event = 120 then
43931: LD_VAR 0 1
43935: PUSH
43936: LD_INT 120
43938: EQUAL
43939: IFFALSE 43945
// MC_RepairVehicle ( ) ;
43941: CALL 58054 0 0
// if event = 121 then
43945: LD_VAR 0 1
43949: PUSH
43950: LD_INT 121
43952: EQUAL
43953: IFFALSE 43959
// MC_TameApe ( ) ;
43955: CALL 58831 0 0
// if event = 122 then
43959: LD_VAR 0 1
43963: PUSH
43964: LD_INT 122
43966: EQUAL
43967: IFFALSE 43973
// MC_ChangeApeClass ( ) ;
43969: CALL 59676 0 0
// if event = 123 then
43973: LD_VAR 0 1
43977: PUSH
43978: LD_INT 123
43980: EQUAL
43981: IFFALSE 43987
// MC_Bazooka ( ) ;
43983: CALL 60332 0 0
// if event = 124 then
43987: LD_VAR 0 1
43991: PUSH
43992: LD_INT 124
43994: EQUAL
43995: IFFALSE 44001
// MC_TeleportExit ( ) ;
43997: CALL 60534 0 0
// if event = 125 then
44001: LD_VAR 0 1
44005: PUSH
44006: LD_INT 125
44008: EQUAL
44009: IFFALSE 44015
// MC_Deposits ( ) ;
44011: CALL 61191 0 0
// if event = 126 then
44015: LD_VAR 0 1
44019: PUSH
44020: LD_INT 126
44022: EQUAL
44023: IFFALSE 44029
// MC_RemoteDriver ( ) ;
44025: CALL 61824 0 0
// if event = 200 then
44029: LD_VAR 0 1
44033: PUSH
44034: LD_INT 200
44036: EQUAL
44037: IFFALSE 44043
// MC_Idle ( ) ;
44039: CALL 63759 0 0
// end ;
44043: PPOPN 1
44045: END
// export function MC_Reset ( base , tag ) ; var i ; begin
44046: LD_INT 0
44048: PPUSH
44049: PPUSH
// if not mc_bases [ base ] or not tag then
44050: LD_EXP 102
44054: PUSH
44055: LD_VAR 0 1
44059: ARRAY
44060: NOT
44061: IFTRUE 44070
44063: PUSH
44064: LD_VAR 0 2
44068: NOT
44069: OR
44070: IFFALSE 44074
// exit ;
44072: GO 44138
// for i in mc_bases [ base ] union mc_ape [ base ] do
44074: LD_ADDR_VAR 0 4
44078: PUSH
44079: LD_EXP 102
44083: PUSH
44084: LD_VAR 0 1
44088: ARRAY
44089: PUSH
44090: LD_EXP 131
44094: PUSH
44095: LD_VAR 0 1
44099: ARRAY
44100: UNION
44101: PUSH
44102: FOR_IN
44103: IFFALSE 44136
// if GetTag ( i ) = tag then
44105: LD_VAR 0 4
44109: PPUSH
44110: CALL_OW 110
44114: PUSH
44115: LD_VAR 0 2
44119: EQUAL
44120: IFFALSE 44134
// SetTag ( i , 0 ) ;
44122: LD_VAR 0 4
44126: PPUSH
44127: LD_INT 0
44129: PPUSH
44130: CALL_OW 109
44134: GO 44102
44136: POP
44137: POP
// end ;
44138: LD_VAR 0 3
44142: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
44143: LD_INT 0
44145: PPUSH
44146: PPUSH
44147: PPUSH
44148: PPUSH
44149: PPUSH
44150: PPUSH
44151: PPUSH
44152: PPUSH
// if not mc_bases then
44153: LD_EXP 102
44157: NOT
44158: IFFALSE 44162
// exit ;
44160: GO 44613
// for i = 1 to mc_bases do
44162: LD_ADDR_VAR 0 2
44166: PUSH
44167: DOUBLE
44168: LD_INT 1
44170: DEC
44171: ST_TO_ADDR
44172: LD_EXP 102
44176: PUSH
44177: FOR_TO
44178: IFFALSE 44611
// begin tmp := MC_ClassCheckReq ( i ) ;
44180: LD_ADDR_VAR 0 4
44184: PUSH
44185: LD_VAR 0 2
44189: PPUSH
44190: CALL 44618 0 1
44194: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
44195: LD_ADDR_EXP 143
44199: PUSH
44200: LD_EXP 143
44204: PPUSH
44205: LD_VAR 0 2
44209: PPUSH
44210: LD_VAR 0 4
44214: PPUSH
44215: CALL_OW 1
44219: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
44220: LD_ADDR_VAR 0 6
44224: PUSH
44225: LD_EXP 102
44229: PUSH
44230: LD_VAR 0 2
44234: ARRAY
44235: PPUSH
44236: LD_INT 2
44238: PUSH
44239: LD_INT 30
44241: PUSH
44242: LD_INT 4
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: LD_INT 30
44251: PUSH
44252: LD_INT 5
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: LIST
44263: PPUSH
44264: CALL_OW 72
44268: PUSH
44269: LD_EXP 102
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PPUSH
44280: LD_INT 2
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 30
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: LIST
44307: PPUSH
44308: CALL_OW 72
44312: PUSH
44313: LD_EXP 102
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PPUSH
44324: LD_INT 30
44326: PUSH
44327: LD_INT 3
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PPUSH
44334: CALL_OW 72
44338: PUSH
44339: LD_EXP 102
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: PPUSH
44350: LD_INT 2
44352: PUSH
44353: LD_INT 30
44355: PUSH
44356: LD_INT 6
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 30
44365: PUSH
44366: LD_INT 7
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 30
44375: PUSH
44376: LD_INT 8
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: PPUSH
44389: CALL_OW 72
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: ST_TO_ADDR
// for j := 1 to 4 do
44400: LD_ADDR_VAR 0 3
44404: PUSH
44405: DOUBLE
44406: LD_INT 1
44408: DEC
44409: ST_TO_ADDR
44410: LD_INT 4
44412: PUSH
44413: FOR_TO
44414: IFFALSE 44607
// begin if not tmp [ j ] then
44416: LD_VAR 0 4
44420: PUSH
44421: LD_VAR 0 3
44425: ARRAY
44426: NOT
44427: IFFALSE 44431
// continue ;
44429: GO 44413
// for p in tmp [ j ] do
44431: LD_ADDR_VAR 0 5
44435: PUSH
44436: LD_VAR 0 4
44440: PUSH
44441: LD_VAR 0 3
44445: ARRAY
44446: PUSH
44447: FOR_IN
44448: IFFALSE 44603
// begin if not b [ j ] then
44450: LD_VAR 0 6
44454: PUSH
44455: LD_VAR 0 3
44459: ARRAY
44460: NOT
44461: IFFALSE 44465
// break ;
44463: GO 44603
// e := 0 ;
44465: LD_ADDR_VAR 0 7
44469: PUSH
44470: LD_INT 0
44472: ST_TO_ADDR
// for k in b [ j ] do
44473: LD_ADDR_VAR 0 8
44477: PUSH
44478: LD_VAR 0 6
44482: PUSH
44483: LD_VAR 0 3
44487: ARRAY
44488: PUSH
44489: FOR_IN
44490: IFFALSE 44517
// if IsNotFull ( k ) then
44492: LD_VAR 0 8
44496: PPUSH
44497: CALL 73221 0 1
44501: IFFALSE 44515
// begin e := k ;
44503: LD_ADDR_VAR 0 7
44507: PUSH
44508: LD_VAR 0 8
44512: ST_TO_ADDR
// break ;
44513: GO 44517
// end ;
44515: GO 44489
44517: POP
44518: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44519: LD_VAR 0 7
44523: IFFALSE 44542
44525: PUSH
44526: LD_VAR 0 5
44530: PPUSH
44531: LD_VAR 0 7
44535: PPUSH
44536: CALL 107681 0 2
44540: NOT
44541: AND
44542: IFFALSE 44601
// begin if IsInUnit ( p ) then
44544: LD_VAR 0 5
44548: PPUSH
44549: CALL_OW 310
44553: IFFALSE 44564
// ComExitBuilding ( p ) ;
44555: LD_VAR 0 5
44559: PPUSH
44560: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44564: LD_VAR 0 5
44568: PPUSH
44569: LD_VAR 0 7
44573: PPUSH
44574: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44578: LD_VAR 0 5
44582: PPUSH
44583: LD_VAR 0 3
44587: PPUSH
44588: CALL_OW 183
// AddComExitBuilding ( p ) ;
44592: LD_VAR 0 5
44596: PPUSH
44597: CALL_OW 182
// end ; end ;
44601: GO 44447
44603: POP
44604: POP
// end ;
44605: GO 44413
44607: POP
44608: POP
// end ;
44609: GO 44177
44611: POP
44612: POP
// end ;
44613: LD_VAR 0 1
44617: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44618: LD_INT 0
44620: PPUSH
44621: PPUSH
44622: PPUSH
44623: PPUSH
44624: PPUSH
44625: PPUSH
44626: PPUSH
44627: PPUSH
44628: PPUSH
44629: PPUSH
44630: PPUSH
44631: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44632: LD_ADDR_VAR 0 2
44636: PUSH
44637: LD_INT 0
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 0
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44655: LD_VAR 0 1
44659: NOT
44660: IFTRUE 44675
44662: PUSH
44663: LD_EXP 102
44667: PUSH
44668: LD_VAR 0 1
44672: ARRAY
44673: NOT
44674: OR
44675: IFTRUE 44723
44677: PUSH
44678: LD_EXP 102
44682: PUSH
44683: LD_VAR 0 1
44687: ARRAY
44688: PPUSH
44689: LD_INT 2
44691: PUSH
44692: LD_INT 30
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 30
44704: PUSH
44705: LD_INT 1
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: LIST
44716: PPUSH
44717: CALL_OW 72
44721: NOT
44722: OR
44723: IFFALSE 44727
// exit ;
44725: GO 48268
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44727: LD_ADDR_VAR 0 4
44731: PUSH
44732: LD_EXP 102
44736: PUSH
44737: LD_VAR 0 1
44741: ARRAY
44742: PPUSH
44743: LD_INT 2
44745: PUSH
44746: LD_INT 25
44748: PUSH
44749: LD_INT 1
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 25
44758: PUSH
44759: LD_INT 2
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 25
44768: PUSH
44769: LD_INT 3
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 25
44778: PUSH
44779: LD_INT 4
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 25
44788: PUSH
44789: LD_INT 5
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 25
44798: PUSH
44799: LD_INT 8
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 25
44808: PUSH
44809: LD_INT 9
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: PPUSH
44826: CALL_OW 72
44830: ST_TO_ADDR
// if not tmp then
44831: LD_VAR 0 4
44835: NOT
44836: IFFALSE 44840
// exit ;
44838: GO 48268
// for i in tmp do
44840: LD_ADDR_VAR 0 3
44844: PUSH
44845: LD_VAR 0 4
44849: PUSH
44850: FOR_IN
44851: IFFALSE 44882
// if GetTag ( i ) then
44853: LD_VAR 0 3
44857: PPUSH
44858: CALL_OW 110
44862: IFFALSE 44880
// tmp := tmp diff i ;
44864: LD_ADDR_VAR 0 4
44868: PUSH
44869: LD_VAR 0 4
44873: PUSH
44874: LD_VAR 0 3
44878: DIFF
44879: ST_TO_ADDR
44880: GO 44850
44882: POP
44883: POP
// if not tmp then
44884: LD_VAR 0 4
44888: NOT
44889: IFFALSE 44893
// exit ;
44891: GO 48268
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44893: LD_ADDR_VAR 0 5
44897: PUSH
44898: LD_EXP 102
44902: PUSH
44903: LD_VAR 0 1
44907: ARRAY
44908: PPUSH
44909: LD_INT 2
44911: PUSH
44912: LD_INT 25
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 25
44924: PUSH
44925: LD_INT 5
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 25
44934: PUSH
44935: LD_INT 8
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 25
44944: PUSH
44945: LD_INT 9
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: PPUSH
44959: CALL_OW 72
44963: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44964: LD_ADDR_VAR 0 6
44968: PUSH
44969: LD_EXP 102
44973: PUSH
44974: LD_VAR 0 1
44978: ARRAY
44979: PPUSH
44980: LD_INT 25
44982: PUSH
44983: LD_INT 2
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PPUSH
44990: CALL_OW 72
44994: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44995: LD_ADDR_VAR 0 7
44999: PUSH
45000: LD_EXP 102
45004: PUSH
45005: LD_VAR 0 1
45009: ARRAY
45010: PPUSH
45011: LD_INT 25
45013: PUSH
45014: LD_INT 3
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PPUSH
45021: CALL_OW 72
45025: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
45026: LD_ADDR_VAR 0 8
45030: PUSH
45031: LD_EXP 102
45035: PUSH
45036: LD_VAR 0 1
45040: ARRAY
45041: PPUSH
45042: LD_INT 25
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 24
45054: PUSH
45055: LD_INT 251
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PPUSH
45066: CALL_OW 72
45070: ST_TO_ADDR
// if mc_is_defending [ base ] then
45071: LD_EXP 145
45075: PUSH
45076: LD_VAR 0 1
45080: ARRAY
45081: IFFALSE 45542
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
45083: LD_ADDR_EXP 144
45087: PUSH
45088: LD_EXP 144
45092: PPUSH
45093: LD_VAR 0 1
45097: PPUSH
45098: LD_INT 4
45100: PPUSH
45101: CALL_OW 1
45105: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
45106: LD_ADDR_VAR 0 12
45110: PUSH
45111: LD_EXP 102
45115: PUSH
45116: LD_VAR 0 1
45120: ARRAY
45121: PPUSH
45122: LD_INT 2
45124: PUSH
45125: LD_INT 30
45127: PUSH
45128: LD_INT 4
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 30
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: ST_TO_ADDR
// if not b then
45155: LD_VAR 0 12
45159: NOT
45160: IFFALSE 45164
// exit ;
45162: GO 48268
// p := [ ] ;
45164: LD_ADDR_VAR 0 11
45168: PUSH
45169: EMPTY
45170: ST_TO_ADDR
// if sci >= 2 then
45171: LD_VAR 0 8
45175: PUSH
45176: LD_INT 2
45178: GREATEREQUAL
45179: IFFALSE 45210
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
45181: LD_ADDR_VAR 0 8
45185: PUSH
45186: LD_VAR 0 8
45190: PUSH
45191: LD_INT 1
45193: ARRAY
45194: PUSH
45195: LD_VAR 0 8
45199: PUSH
45200: LD_INT 2
45202: ARRAY
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: ST_TO_ADDR
45208: GO 45271
// if sci = 1 then
45210: LD_VAR 0 8
45214: PUSH
45215: LD_INT 1
45217: EQUAL
45218: IFFALSE 45239
// sci := [ sci [ 1 ] ] else
45220: LD_ADDR_VAR 0 8
45224: PUSH
45225: LD_VAR 0 8
45229: PUSH
45230: LD_INT 1
45232: ARRAY
45233: PUSH
45234: EMPTY
45235: LIST
45236: ST_TO_ADDR
45237: GO 45271
// if sci = 0 then
45239: LD_VAR 0 8
45243: PUSH
45244: LD_INT 0
45246: EQUAL
45247: IFFALSE 45271
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
45249: LD_ADDR_VAR 0 11
45253: PUSH
45254: LD_VAR 0 4
45258: PPUSH
45259: LD_INT 4
45261: PPUSH
45262: CALL 107551 0 2
45266: PUSH
45267: LD_INT 1
45269: ARRAY
45270: ST_TO_ADDR
// if eng > 4 then
45271: LD_VAR 0 6
45275: PUSH
45276: LD_INT 4
45278: GREATER
45279: IFFALSE 45325
// for i = eng downto 4 do
45281: LD_ADDR_VAR 0 3
45285: PUSH
45286: DOUBLE
45287: LD_VAR 0 6
45291: INC
45292: ST_TO_ADDR
45293: LD_INT 4
45295: PUSH
45296: FOR_DOWNTO
45297: IFFALSE 45323
// eng := eng diff eng [ i ] ;
45299: LD_ADDR_VAR 0 6
45303: PUSH
45304: LD_VAR 0 6
45308: PUSH
45309: LD_VAR 0 6
45313: PUSH
45314: LD_VAR 0 3
45318: ARRAY
45319: DIFF
45320: ST_TO_ADDR
45321: GO 45296
45323: POP
45324: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45325: LD_ADDR_VAR 0 4
45329: PUSH
45330: LD_VAR 0 4
45334: PUSH
45335: LD_VAR 0 5
45339: PUSH
45340: LD_VAR 0 6
45344: UNION
45345: PUSH
45346: LD_VAR 0 7
45350: UNION
45351: PUSH
45352: LD_VAR 0 8
45356: UNION
45357: DIFF
45358: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45359: LD_ADDR_VAR 0 13
45363: PUSH
45364: LD_EXP 102
45368: PUSH
45369: LD_VAR 0 1
45373: ARRAY
45374: PPUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 30
45380: PUSH
45381: LD_INT 32
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 30
45390: PUSH
45391: LD_INT 31
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: PPUSH
45403: CALL_OW 72
45407: PUSH
45408: LD_EXP 102
45412: PUSH
45413: LD_VAR 0 1
45417: ARRAY
45418: PPUSH
45419: LD_INT 2
45421: PUSH
45422: LD_INT 30
45424: PUSH
45425: LD_INT 4
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 30
45434: PUSH
45435: LD_INT 5
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PPUSH
45447: CALL_OW 72
45451: PUSH
45452: LD_INT 6
45454: MUL
45455: PLUS
45456: ST_TO_ADDR
// if bcount < tmp then
45457: LD_VAR 0 13
45461: PUSH
45462: LD_VAR 0 4
45466: LESS
45467: IFFALSE 45513
// for i = tmp downto bcount do
45469: LD_ADDR_VAR 0 3
45473: PUSH
45474: DOUBLE
45475: LD_VAR 0 4
45479: INC
45480: ST_TO_ADDR
45481: LD_VAR 0 13
45485: PUSH
45486: FOR_DOWNTO
45487: IFFALSE 45511
// tmp := Delete ( tmp , tmp ) ;
45489: LD_ADDR_VAR 0 4
45493: PUSH
45494: LD_VAR 0 4
45498: PPUSH
45499: LD_VAR 0 4
45503: PPUSH
45504: CALL_OW 3
45508: ST_TO_ADDR
45509: GO 45486
45511: POP
45512: POP
// result := [ tmp , 0 , 0 , p ] ;
45513: LD_ADDR_VAR 0 2
45517: PUSH
45518: LD_VAR 0 4
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: LD_INT 0
45528: PUSH
45529: LD_VAR 0 11
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// exit ;
45540: GO 48268
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45542: LD_EXP 102
45546: PUSH
45547: LD_VAR 0 1
45551: ARRAY
45552: PPUSH
45553: LD_INT 2
45555: PUSH
45556: LD_INT 30
45558: PUSH
45559: LD_INT 6
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 30
45568: PUSH
45569: LD_INT 7
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 8
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: PPUSH
45592: CALL_OW 72
45596: NOT
45597: IFFALSE 45627
45599: PUSH
45600: LD_EXP 102
45604: PUSH
45605: LD_VAR 0 1
45609: ARRAY
45610: PPUSH
45611: LD_INT 30
45613: PUSH
45614: LD_INT 3
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PPUSH
45621: CALL_OW 72
45625: NOT
45626: AND
45627: IFFALSE 45699
// begin if eng = tmp then
45629: LD_VAR 0 6
45633: PUSH
45634: LD_VAR 0 4
45638: EQUAL
45639: IFFALSE 45643
// exit ;
45641: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45643: LD_ADDR_EXP 144
45647: PUSH
45648: LD_EXP 144
45652: PPUSH
45653: LD_VAR 0 1
45657: PPUSH
45658: LD_INT 1
45660: PPUSH
45661: CALL_OW 1
45665: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45666: LD_ADDR_VAR 0 2
45670: PUSH
45671: LD_INT 0
45673: PUSH
45674: LD_VAR 0 4
45678: PUSH
45679: LD_VAR 0 6
45683: DIFF
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 0
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: ST_TO_ADDR
// exit ;
45697: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45699: LD_EXP 129
45703: PUSH
45704: LD_EXP 128
45708: PUSH
45709: LD_VAR 0 1
45713: ARRAY
45714: ARRAY
45715: IFFALSE 45773
45717: PUSH
45718: LD_EXP 102
45722: PUSH
45723: LD_VAR 0 1
45727: ARRAY
45728: PPUSH
45729: LD_INT 2
45731: PUSH
45732: LD_INT 30
45734: PUSH
45735: LD_INT 6
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 30
45744: PUSH
45745: LD_INT 7
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 30
45754: PUSH
45755: LD_INT 8
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: PPUSH
45768: CALL_OW 72
45772: AND
45773: IFFALSE 45803
45775: PUSH
45776: LD_EXP 102
45780: PUSH
45781: LD_VAR 0 1
45785: ARRAY
45786: PPUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: CALL_OW 72
45801: NOT
45802: AND
45803: IFFALSE 46019
// begin if sci >= 6 then
45805: LD_VAR 0 8
45809: PUSH
45810: LD_INT 6
45812: GREATEREQUAL
45813: IFFALSE 45817
// exit ;
45815: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45817: LD_ADDR_EXP 144
45821: PUSH
45822: LD_EXP 144
45826: PPUSH
45827: LD_VAR 0 1
45831: PPUSH
45832: LD_INT 2
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45840: LD_ADDR_VAR 0 9
45844: PUSH
45845: LD_VAR 0 4
45849: PUSH
45850: LD_VAR 0 8
45854: DIFF
45855: PPUSH
45856: LD_INT 4
45858: PPUSH
45859: CALL 107551 0 2
45863: ST_TO_ADDR
// p := [ ] ;
45864: LD_ADDR_VAR 0 11
45868: PUSH
45869: EMPTY
45870: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45871: LD_VAR 0 8
45875: PUSH
45876: LD_INT 6
45878: LESS
45879: IFFALSE 45891
45881: PUSH
45882: LD_VAR 0 9
45886: PUSH
45887: LD_INT 6
45889: GREATER
45890: AND
45891: IFFALSE 45972
// begin for i = 1 to 6 - sci do
45893: LD_ADDR_VAR 0 3
45897: PUSH
45898: DOUBLE
45899: LD_INT 1
45901: DEC
45902: ST_TO_ADDR
45903: LD_INT 6
45905: PUSH
45906: LD_VAR 0 8
45910: MINUS
45911: PUSH
45912: FOR_TO
45913: IFFALSE 45968
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45915: LD_ADDR_VAR 0 11
45919: PUSH
45920: LD_VAR 0 11
45924: PPUSH
45925: LD_VAR 0 11
45929: PUSH
45930: LD_INT 1
45932: PLUS
45933: PPUSH
45934: LD_VAR 0 9
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: PPUSH
45943: CALL_OW 2
45947: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45948: LD_ADDR_VAR 0 9
45952: PUSH
45953: LD_VAR 0 9
45957: PPUSH
45958: LD_INT 1
45960: PPUSH
45961: CALL_OW 3
45965: ST_TO_ADDR
// end ;
45966: GO 45912
45968: POP
45969: POP
// end else
45970: GO 45992
// if sort then
45972: LD_VAR 0 9
45976: IFFALSE 45992
// p := sort [ 1 ] ;
45978: LD_ADDR_VAR 0 11
45982: PUSH
45983: LD_VAR 0 9
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45992: LD_ADDR_VAR 0 2
45996: PUSH
45997: LD_INT 0
45999: PUSH
46000: LD_INT 0
46002: PUSH
46003: LD_INT 0
46005: PUSH
46006: LD_VAR 0 11
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: ST_TO_ADDR
// exit ;
46017: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
46019: LD_EXP 129
46023: PUSH
46024: LD_EXP 128
46028: PUSH
46029: LD_VAR 0 1
46033: ARRAY
46034: ARRAY
46035: IFFALSE 46093
46037: PUSH
46038: LD_EXP 102
46042: PUSH
46043: LD_VAR 0 1
46047: ARRAY
46048: PPUSH
46049: LD_INT 2
46051: PUSH
46052: LD_INT 30
46054: PUSH
46055: LD_INT 6
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 30
46064: PUSH
46065: LD_INT 7
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 30
46074: PUSH
46075: LD_INT 8
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: PPUSH
46088: CALL_OW 72
46092: AND
46093: IFFALSE 46122
46095: PUSH
46096: LD_EXP 102
46100: PUSH
46101: LD_VAR 0 1
46105: ARRAY
46106: PPUSH
46107: LD_INT 30
46109: PUSH
46110: LD_INT 3
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: PPUSH
46117: CALL_OW 72
46121: AND
46122: IFFALSE 46862
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
46124: LD_ADDR_EXP 144
46128: PUSH
46129: LD_EXP 144
46133: PPUSH
46134: LD_VAR 0 1
46138: PPUSH
46139: LD_INT 3
46141: PPUSH
46142: CALL_OW 1
46146: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46147: LD_ADDR_VAR 0 2
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: LD_INT 0
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: ST_TO_ADDR
// if not eng then
46170: LD_VAR 0 6
46174: NOT
46175: IFFALSE 46238
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
46177: LD_ADDR_VAR 0 11
46181: PUSH
46182: LD_VAR 0 4
46186: PPUSH
46187: LD_INT 2
46189: PPUSH
46190: CALL 107551 0 2
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
46199: LD_ADDR_VAR 0 2
46203: PUSH
46204: LD_VAR 0 2
46208: PPUSH
46209: LD_INT 2
46211: PPUSH
46212: LD_VAR 0 11
46216: PPUSH
46217: CALL_OW 1
46221: ST_TO_ADDR
// tmp := tmp diff p ;
46222: LD_ADDR_VAR 0 4
46226: PUSH
46227: LD_VAR 0 4
46231: PUSH
46232: LD_VAR 0 11
46236: DIFF
46237: ST_TO_ADDR
// end ; if tmp and sci < 6 then
46238: LD_VAR 0 4
46242: IFFALSE 46254
46244: PUSH
46245: LD_VAR 0 8
46249: PUSH
46250: LD_INT 6
46252: LESS
46253: AND
46254: IFFALSE 46442
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
46256: LD_ADDR_VAR 0 9
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_VAR 0 8
46270: PUSH
46271: LD_VAR 0 7
46275: UNION
46276: DIFF
46277: PPUSH
46278: LD_INT 4
46280: PPUSH
46281: CALL 107551 0 2
46285: ST_TO_ADDR
// p := [ ] ;
46286: LD_ADDR_VAR 0 11
46290: PUSH
46291: EMPTY
46292: ST_TO_ADDR
// if sort then
46293: LD_VAR 0 9
46297: IFFALSE 46413
// for i = 1 to 6 - sci do
46299: LD_ADDR_VAR 0 3
46303: PUSH
46304: DOUBLE
46305: LD_INT 1
46307: DEC
46308: ST_TO_ADDR
46309: LD_INT 6
46311: PUSH
46312: LD_VAR 0 8
46316: MINUS
46317: PUSH
46318: FOR_TO
46319: IFFALSE 46411
// begin if i = sort then
46321: LD_VAR 0 3
46325: PUSH
46326: LD_VAR 0 9
46330: EQUAL
46331: IFFALSE 46335
// break ;
46333: GO 46411
// if GetClass ( i ) = 4 then
46335: LD_VAR 0 3
46339: PPUSH
46340: CALL_OW 257
46344: PUSH
46345: LD_INT 4
46347: EQUAL
46348: IFFALSE 46352
// continue ;
46350: GO 46318
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46352: LD_ADDR_VAR 0 11
46356: PUSH
46357: LD_VAR 0 11
46361: PPUSH
46362: LD_VAR 0 11
46366: PUSH
46367: LD_INT 1
46369: PLUS
46370: PPUSH
46371: LD_VAR 0 9
46375: PUSH
46376: LD_VAR 0 3
46380: ARRAY
46381: PPUSH
46382: CALL_OW 2
46386: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46387: LD_ADDR_VAR 0 4
46391: PUSH
46392: LD_VAR 0 4
46396: PUSH
46397: LD_VAR 0 9
46401: PUSH
46402: LD_VAR 0 3
46406: ARRAY
46407: DIFF
46408: ST_TO_ADDR
// end ;
46409: GO 46318
46411: POP
46412: POP
// if p then
46413: LD_VAR 0 11
46417: IFFALSE 46442
// result := Replace ( result , 4 , p ) ;
46419: LD_ADDR_VAR 0 2
46423: PUSH
46424: LD_VAR 0 2
46428: PPUSH
46429: LD_INT 4
46431: PPUSH
46432: LD_VAR 0 11
46436: PPUSH
46437: CALL_OW 1
46441: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46442: LD_VAR 0 4
46446: IFFALSE 46458
46448: PUSH
46449: LD_VAR 0 7
46453: PUSH
46454: LD_INT 6
46456: LESS
46457: AND
46458: IFFALSE 46646
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46460: LD_ADDR_VAR 0 9
46464: PUSH
46465: LD_VAR 0 4
46469: PUSH
46470: LD_VAR 0 8
46474: PUSH
46475: LD_VAR 0 7
46479: UNION
46480: DIFF
46481: PPUSH
46482: LD_INT 3
46484: PPUSH
46485: CALL 107551 0 2
46489: ST_TO_ADDR
// p := [ ] ;
46490: LD_ADDR_VAR 0 11
46494: PUSH
46495: EMPTY
46496: ST_TO_ADDR
// if sort then
46497: LD_VAR 0 9
46501: IFFALSE 46617
// for i = 1 to 6 - mech do
46503: LD_ADDR_VAR 0 3
46507: PUSH
46508: DOUBLE
46509: LD_INT 1
46511: DEC
46512: ST_TO_ADDR
46513: LD_INT 6
46515: PUSH
46516: LD_VAR 0 7
46520: MINUS
46521: PUSH
46522: FOR_TO
46523: IFFALSE 46615
// begin if i = sort then
46525: LD_VAR 0 3
46529: PUSH
46530: LD_VAR 0 9
46534: EQUAL
46535: IFFALSE 46539
// break ;
46537: GO 46615
// if GetClass ( i ) = 3 then
46539: LD_VAR 0 3
46543: PPUSH
46544: CALL_OW 257
46548: PUSH
46549: LD_INT 3
46551: EQUAL
46552: IFFALSE 46556
// continue ;
46554: GO 46522
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46556: LD_ADDR_VAR 0 11
46560: PUSH
46561: LD_VAR 0 11
46565: PPUSH
46566: LD_VAR 0 11
46570: PUSH
46571: LD_INT 1
46573: PLUS
46574: PPUSH
46575: LD_VAR 0 9
46579: PUSH
46580: LD_VAR 0 3
46584: ARRAY
46585: PPUSH
46586: CALL_OW 2
46590: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46591: LD_ADDR_VAR 0 4
46595: PUSH
46596: LD_VAR 0 4
46600: PUSH
46601: LD_VAR 0 9
46605: PUSH
46606: LD_VAR 0 3
46610: ARRAY
46611: DIFF
46612: ST_TO_ADDR
// end ;
46613: GO 46522
46615: POP
46616: POP
// if p then
46617: LD_VAR 0 11
46621: IFFALSE 46646
// result := Replace ( result , 3 , p ) ;
46623: LD_ADDR_VAR 0 2
46627: PUSH
46628: LD_VAR 0 2
46632: PPUSH
46633: LD_INT 3
46635: PPUSH
46636: LD_VAR 0 11
46640: PPUSH
46641: CALL_OW 1
46645: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46646: LD_VAR 0 4
46650: PUSH
46651: LD_INT 6
46653: GREATER
46654: IFFALSE 46666
46656: PUSH
46657: LD_VAR 0 6
46661: PUSH
46662: LD_INT 6
46664: LESS
46665: AND
46666: IFFALSE 46860
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46668: LD_ADDR_VAR 0 9
46672: PUSH
46673: LD_VAR 0 4
46677: PUSH
46678: LD_VAR 0 8
46682: PUSH
46683: LD_VAR 0 7
46687: UNION
46688: PUSH
46689: LD_VAR 0 6
46693: UNION
46694: DIFF
46695: PPUSH
46696: LD_INT 2
46698: PPUSH
46699: CALL 107551 0 2
46703: ST_TO_ADDR
// p := [ ] ;
46704: LD_ADDR_VAR 0 11
46708: PUSH
46709: EMPTY
46710: ST_TO_ADDR
// if sort then
46711: LD_VAR 0 9
46715: IFFALSE 46831
// for i = 1 to 6 - eng do
46717: LD_ADDR_VAR 0 3
46721: PUSH
46722: DOUBLE
46723: LD_INT 1
46725: DEC
46726: ST_TO_ADDR
46727: LD_INT 6
46729: PUSH
46730: LD_VAR 0 6
46734: MINUS
46735: PUSH
46736: FOR_TO
46737: IFFALSE 46829
// begin if i = sort then
46739: LD_VAR 0 3
46743: PUSH
46744: LD_VAR 0 9
46748: EQUAL
46749: IFFALSE 46753
// break ;
46751: GO 46829
// if GetClass ( i ) = 2 then
46753: LD_VAR 0 3
46757: PPUSH
46758: CALL_OW 257
46762: PUSH
46763: LD_INT 2
46765: EQUAL
46766: IFFALSE 46770
// continue ;
46768: GO 46736
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46770: LD_ADDR_VAR 0 11
46774: PUSH
46775: LD_VAR 0 11
46779: PPUSH
46780: LD_VAR 0 11
46784: PUSH
46785: LD_INT 1
46787: PLUS
46788: PPUSH
46789: LD_VAR 0 9
46793: PUSH
46794: LD_VAR 0 3
46798: ARRAY
46799: PPUSH
46800: CALL_OW 2
46804: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46805: LD_ADDR_VAR 0 4
46809: PUSH
46810: LD_VAR 0 4
46814: PUSH
46815: LD_VAR 0 9
46819: PUSH
46820: LD_VAR 0 3
46824: ARRAY
46825: DIFF
46826: ST_TO_ADDR
// end ;
46827: GO 46736
46829: POP
46830: POP
// if p then
46831: LD_VAR 0 11
46835: IFFALSE 46860
// result := Replace ( result , 2 , p ) ;
46837: LD_ADDR_VAR 0 2
46841: PUSH
46842: LD_VAR 0 2
46846: PPUSH
46847: LD_INT 2
46849: PPUSH
46850: LD_VAR 0 11
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// end ; exit ;
46860: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46862: LD_EXP 129
46866: PUSH
46867: LD_EXP 128
46871: PUSH
46872: LD_VAR 0 1
46876: ARRAY
46877: ARRAY
46878: NOT
46879: IFFALSE 46908
46881: PUSH
46882: LD_EXP 102
46886: PUSH
46887: LD_VAR 0 1
46891: ARRAY
46892: PPUSH
46893: LD_INT 30
46895: PUSH
46896: LD_INT 3
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PPUSH
46903: CALL_OW 72
46907: AND
46908: IFFALSE 46922
46910: PUSH
46911: LD_EXP 107
46915: PUSH
46916: LD_VAR 0 1
46920: ARRAY
46921: AND
46922: IFFALSE 47536
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46924: LD_ADDR_EXP 144
46928: PUSH
46929: LD_EXP 144
46933: PPUSH
46934: LD_VAR 0 1
46938: PPUSH
46939: LD_INT 5
46941: PPUSH
46942: CALL_OW 1
46946: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46947: LD_ADDR_VAR 0 2
46951: PUSH
46952: LD_INT 0
46954: PUSH
46955: LD_INT 0
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: LD_INT 0
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: ST_TO_ADDR
// if sci > 1 then
46970: LD_VAR 0 8
46974: PUSH
46975: LD_INT 1
46977: GREATER
46978: IFFALSE 47006
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46980: LD_ADDR_VAR 0 4
46984: PUSH
46985: LD_VAR 0 4
46989: PUSH
46990: LD_VAR 0 8
46994: PUSH
46995: LD_VAR 0 8
46999: PUSH
47000: LD_INT 1
47002: ARRAY
47003: DIFF
47004: DIFF
47005: ST_TO_ADDR
// if tmp and not sci then
47006: LD_VAR 0 4
47010: IFFALSE 47019
47012: PUSH
47013: LD_VAR 0 8
47017: NOT
47018: AND
47019: IFFALSE 47088
// begin sort := SortBySkill ( tmp , 4 ) ;
47021: LD_ADDR_VAR 0 9
47025: PUSH
47026: LD_VAR 0 4
47030: PPUSH
47031: LD_INT 4
47033: PPUSH
47034: CALL 107551 0 2
47038: ST_TO_ADDR
// if sort then
47039: LD_VAR 0 9
47043: IFFALSE 47059
// p := sort [ 1 ] ;
47045: LD_ADDR_VAR 0 11
47049: PUSH
47050: LD_VAR 0 9
47054: PUSH
47055: LD_INT 1
47057: ARRAY
47058: ST_TO_ADDR
// if p then
47059: LD_VAR 0 11
47063: IFFALSE 47088
// result := Replace ( result , 4 , p ) ;
47065: LD_ADDR_VAR 0 2
47069: PUSH
47070: LD_VAR 0 2
47074: PPUSH
47075: LD_INT 4
47077: PPUSH
47078: LD_VAR 0 11
47082: PPUSH
47083: CALL_OW 1
47087: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47088: LD_ADDR_VAR 0 4
47092: PUSH
47093: LD_VAR 0 4
47097: PUSH
47098: LD_VAR 0 7
47102: DIFF
47103: ST_TO_ADDR
// if tmp and mech < 6 then
47104: LD_VAR 0 4
47108: IFFALSE 47120
47110: PUSH
47111: LD_VAR 0 7
47115: PUSH
47116: LD_INT 6
47118: LESS
47119: AND
47120: IFFALSE 47308
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
47122: LD_ADDR_VAR 0 9
47126: PUSH
47127: LD_VAR 0 4
47131: PUSH
47132: LD_VAR 0 8
47136: PUSH
47137: LD_VAR 0 7
47141: UNION
47142: DIFF
47143: PPUSH
47144: LD_INT 3
47146: PPUSH
47147: CALL 107551 0 2
47151: ST_TO_ADDR
// p := [ ] ;
47152: LD_ADDR_VAR 0 11
47156: PUSH
47157: EMPTY
47158: ST_TO_ADDR
// if sort then
47159: LD_VAR 0 9
47163: IFFALSE 47279
// for i = 1 to 6 - mech do
47165: LD_ADDR_VAR 0 3
47169: PUSH
47170: DOUBLE
47171: LD_INT 1
47173: DEC
47174: ST_TO_ADDR
47175: LD_INT 6
47177: PUSH
47178: LD_VAR 0 7
47182: MINUS
47183: PUSH
47184: FOR_TO
47185: IFFALSE 47277
// begin if i = sort then
47187: LD_VAR 0 3
47191: PUSH
47192: LD_VAR 0 9
47196: EQUAL
47197: IFFALSE 47201
// break ;
47199: GO 47277
// if GetClass ( i ) = 3 then
47201: LD_VAR 0 3
47205: PPUSH
47206: CALL_OW 257
47210: PUSH
47211: LD_INT 3
47213: EQUAL
47214: IFFALSE 47218
// continue ;
47216: GO 47184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47218: LD_ADDR_VAR 0 11
47222: PUSH
47223: LD_VAR 0 11
47227: PPUSH
47228: LD_VAR 0 11
47232: PUSH
47233: LD_INT 1
47235: PLUS
47236: PPUSH
47237: LD_VAR 0 9
47241: PUSH
47242: LD_VAR 0 3
47246: ARRAY
47247: PPUSH
47248: CALL_OW 2
47252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47253: LD_ADDR_VAR 0 4
47257: PUSH
47258: LD_VAR 0 4
47262: PUSH
47263: LD_VAR 0 9
47267: PUSH
47268: LD_VAR 0 3
47272: ARRAY
47273: DIFF
47274: ST_TO_ADDR
// end ;
47275: GO 47184
47277: POP
47278: POP
// if p then
47279: LD_VAR 0 11
47283: IFFALSE 47308
// result := Replace ( result , 3 , p ) ;
47285: LD_ADDR_VAR 0 2
47289: PUSH
47290: LD_VAR 0 2
47294: PPUSH
47295: LD_INT 3
47297: PPUSH
47298: LD_VAR 0 11
47302: PPUSH
47303: CALL_OW 1
47307: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47308: LD_ADDR_VAR 0 4
47312: PUSH
47313: LD_VAR 0 4
47317: PUSH
47318: LD_VAR 0 6
47322: DIFF
47323: ST_TO_ADDR
// if tmp and eng < 6 then
47324: LD_VAR 0 4
47328: IFFALSE 47340
47330: PUSH
47331: LD_VAR 0 6
47335: PUSH
47336: LD_INT 6
47338: LESS
47339: AND
47340: IFFALSE 47534
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47342: LD_ADDR_VAR 0 9
47346: PUSH
47347: LD_VAR 0 4
47351: PUSH
47352: LD_VAR 0 8
47356: PUSH
47357: LD_VAR 0 7
47361: UNION
47362: PUSH
47363: LD_VAR 0 6
47367: UNION
47368: DIFF
47369: PPUSH
47370: LD_INT 2
47372: PPUSH
47373: CALL 107551 0 2
47377: ST_TO_ADDR
// p := [ ] ;
47378: LD_ADDR_VAR 0 11
47382: PUSH
47383: EMPTY
47384: ST_TO_ADDR
// if sort then
47385: LD_VAR 0 9
47389: IFFALSE 47505
// for i = 1 to 6 - eng do
47391: LD_ADDR_VAR 0 3
47395: PUSH
47396: DOUBLE
47397: LD_INT 1
47399: DEC
47400: ST_TO_ADDR
47401: LD_INT 6
47403: PUSH
47404: LD_VAR 0 6
47408: MINUS
47409: PUSH
47410: FOR_TO
47411: IFFALSE 47503
// begin if i = sort then
47413: LD_VAR 0 3
47417: PUSH
47418: LD_VAR 0 9
47422: EQUAL
47423: IFFALSE 47427
// break ;
47425: GO 47503
// if GetClass ( i ) = 2 then
47427: LD_VAR 0 3
47431: PPUSH
47432: CALL_OW 257
47436: PUSH
47437: LD_INT 2
47439: EQUAL
47440: IFFALSE 47444
// continue ;
47442: GO 47410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47444: LD_ADDR_VAR 0 11
47448: PUSH
47449: LD_VAR 0 11
47453: PPUSH
47454: LD_VAR 0 11
47458: PUSH
47459: LD_INT 1
47461: PLUS
47462: PPUSH
47463: LD_VAR 0 9
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: PPUSH
47474: CALL_OW 2
47478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47479: LD_ADDR_VAR 0 4
47483: PUSH
47484: LD_VAR 0 4
47488: PUSH
47489: LD_VAR 0 9
47493: PUSH
47494: LD_VAR 0 3
47498: ARRAY
47499: DIFF
47500: ST_TO_ADDR
// end ;
47501: GO 47410
47503: POP
47504: POP
// if p then
47505: LD_VAR 0 11
47509: IFFALSE 47534
// result := Replace ( result , 2 , p ) ;
47511: LD_ADDR_VAR 0 2
47515: PUSH
47516: LD_VAR 0 2
47520: PPUSH
47521: LD_INT 2
47523: PPUSH
47524: LD_VAR 0 11
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// end ; exit ;
47534: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47536: LD_EXP 129
47540: PUSH
47541: LD_EXP 128
47545: PUSH
47546: LD_VAR 0 1
47550: ARRAY
47551: ARRAY
47552: NOT
47553: IFFALSE 47582
47555: PUSH
47556: LD_EXP 102
47560: PUSH
47561: LD_VAR 0 1
47565: ARRAY
47566: PPUSH
47567: LD_INT 30
47569: PUSH
47570: LD_INT 3
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: PPUSH
47577: CALL_OW 72
47581: AND
47582: IFFALSE 47597
47584: PUSH
47585: LD_EXP 107
47589: PUSH
47590: LD_VAR 0 1
47594: ARRAY
47595: NOT
47596: AND
47597: IFFALSE 48268
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47599: LD_ADDR_EXP 144
47603: PUSH
47604: LD_EXP 144
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: LD_INT 6
47616: PPUSH
47617: CALL_OW 1
47621: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: PUSH
47630: LD_INT 0
47632: PUSH
47633: LD_INT 0
47635: PUSH
47636: LD_INT 0
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// if sci >= 1 then
47645: LD_VAR 0 8
47649: PUSH
47650: LD_INT 1
47652: GREATEREQUAL
47653: IFFALSE 47675
// tmp := tmp diff sci [ 1 ] ;
47655: LD_ADDR_VAR 0 4
47659: PUSH
47660: LD_VAR 0 4
47664: PUSH
47665: LD_VAR 0 8
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: DIFF
47674: ST_TO_ADDR
// if tmp and not sci then
47675: LD_VAR 0 4
47679: IFFALSE 47688
47681: PUSH
47682: LD_VAR 0 8
47686: NOT
47687: AND
47688: IFFALSE 47757
// begin sort := SortBySkill ( tmp , 4 ) ;
47690: LD_ADDR_VAR 0 9
47694: PUSH
47695: LD_VAR 0 4
47699: PPUSH
47700: LD_INT 4
47702: PPUSH
47703: CALL 107551 0 2
47707: ST_TO_ADDR
// if sort then
47708: LD_VAR 0 9
47712: IFFALSE 47728
// p := sort [ 1 ] ;
47714: LD_ADDR_VAR 0 11
47718: PUSH
47719: LD_VAR 0 9
47723: PUSH
47724: LD_INT 1
47726: ARRAY
47727: ST_TO_ADDR
// if p then
47728: LD_VAR 0 11
47732: IFFALSE 47757
// result := Replace ( result , 4 , p ) ;
47734: LD_ADDR_VAR 0 2
47738: PUSH
47739: LD_VAR 0 2
47743: PPUSH
47744: LD_INT 4
47746: PPUSH
47747: LD_VAR 0 11
47751: PPUSH
47752: CALL_OW 1
47756: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47757: LD_ADDR_VAR 0 4
47761: PUSH
47762: LD_VAR 0 4
47766: PUSH
47767: LD_VAR 0 7
47771: DIFF
47772: ST_TO_ADDR
// if tmp and mech < 6 then
47773: LD_VAR 0 4
47777: IFFALSE 47789
47779: PUSH
47780: LD_VAR 0 7
47784: PUSH
47785: LD_INT 6
47787: LESS
47788: AND
47789: IFFALSE 47971
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47791: LD_ADDR_VAR 0 9
47795: PUSH
47796: LD_VAR 0 4
47800: PUSH
47801: LD_VAR 0 7
47805: DIFF
47806: PPUSH
47807: LD_INT 3
47809: PPUSH
47810: CALL 107551 0 2
47814: ST_TO_ADDR
// p := [ ] ;
47815: LD_ADDR_VAR 0 11
47819: PUSH
47820: EMPTY
47821: ST_TO_ADDR
// if sort then
47822: LD_VAR 0 9
47826: IFFALSE 47942
// for i = 1 to 6 - mech do
47828: LD_ADDR_VAR 0 3
47832: PUSH
47833: DOUBLE
47834: LD_INT 1
47836: DEC
47837: ST_TO_ADDR
47838: LD_INT 6
47840: PUSH
47841: LD_VAR 0 7
47845: MINUS
47846: PUSH
47847: FOR_TO
47848: IFFALSE 47940
// begin if i = sort then
47850: LD_VAR 0 3
47854: PUSH
47855: LD_VAR 0 9
47859: EQUAL
47860: IFFALSE 47864
// break ;
47862: GO 47940
// if GetClass ( i ) = 3 then
47864: LD_VAR 0 3
47868: PPUSH
47869: CALL_OW 257
47873: PUSH
47874: LD_INT 3
47876: EQUAL
47877: IFFALSE 47881
// continue ;
47879: GO 47847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47881: LD_ADDR_VAR 0 11
47885: PUSH
47886: LD_VAR 0 11
47890: PPUSH
47891: LD_VAR 0 11
47895: PUSH
47896: LD_INT 1
47898: PLUS
47899: PPUSH
47900: LD_VAR 0 9
47904: PUSH
47905: LD_VAR 0 3
47909: ARRAY
47910: PPUSH
47911: CALL_OW 2
47915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47916: LD_ADDR_VAR 0 4
47920: PUSH
47921: LD_VAR 0 4
47925: PUSH
47926: LD_VAR 0 9
47930: PUSH
47931: LD_VAR 0 3
47935: ARRAY
47936: DIFF
47937: ST_TO_ADDR
// end ;
47938: GO 47847
47940: POP
47941: POP
// if p then
47942: LD_VAR 0 11
47946: IFFALSE 47971
// result := Replace ( result , 3 , p ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 2
47957: PPUSH
47958: LD_INT 3
47960: PPUSH
47961: LD_VAR 0 11
47965: PPUSH
47966: CALL_OW 1
47970: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47971: LD_ADDR_VAR 0 4
47975: PUSH
47976: LD_VAR 0 4
47980: PUSH
47981: LD_VAR 0 6
47985: DIFF
47986: ST_TO_ADDR
// if tmp and eng < 4 then
47987: LD_VAR 0 4
47991: IFFALSE 48003
47993: PUSH
47994: LD_VAR 0 6
47998: PUSH
47999: LD_INT 4
48001: LESS
48002: AND
48003: IFFALSE 48193
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
48005: LD_ADDR_VAR 0 9
48009: PUSH
48010: LD_VAR 0 4
48014: PUSH
48015: LD_VAR 0 7
48019: PUSH
48020: LD_VAR 0 6
48024: UNION
48025: DIFF
48026: PPUSH
48027: LD_INT 2
48029: PPUSH
48030: CALL 107551 0 2
48034: ST_TO_ADDR
// p := [ ] ;
48035: LD_ADDR_VAR 0 11
48039: PUSH
48040: EMPTY
48041: ST_TO_ADDR
// if sort then
48042: LD_VAR 0 9
48046: IFFALSE 48162
// for i = 1 to 4 - eng do
48048: LD_ADDR_VAR 0 3
48052: PUSH
48053: DOUBLE
48054: LD_INT 1
48056: DEC
48057: ST_TO_ADDR
48058: LD_INT 4
48060: PUSH
48061: LD_VAR 0 6
48065: MINUS
48066: PUSH
48067: FOR_TO
48068: IFFALSE 48160
// begin if i = sort then
48070: LD_VAR 0 3
48074: PUSH
48075: LD_VAR 0 9
48079: EQUAL
48080: IFFALSE 48084
// break ;
48082: GO 48160
// if GetClass ( i ) = 2 then
48084: LD_VAR 0 3
48088: PPUSH
48089: CALL_OW 257
48093: PUSH
48094: LD_INT 2
48096: EQUAL
48097: IFFALSE 48101
// continue ;
48099: GO 48067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48101: LD_ADDR_VAR 0 11
48105: PUSH
48106: LD_VAR 0 11
48110: PPUSH
48111: LD_VAR 0 11
48115: PUSH
48116: LD_INT 1
48118: PLUS
48119: PPUSH
48120: LD_VAR 0 9
48124: PUSH
48125: LD_VAR 0 3
48129: ARRAY
48130: PPUSH
48131: CALL_OW 2
48135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48136: LD_ADDR_VAR 0 4
48140: PUSH
48141: LD_VAR 0 4
48145: PUSH
48146: LD_VAR 0 9
48150: PUSH
48151: LD_VAR 0 3
48155: ARRAY
48156: DIFF
48157: ST_TO_ADDR
// end ;
48158: GO 48067
48160: POP
48161: POP
// if p then
48162: LD_VAR 0 11
48166: IFFALSE 48191
// result := Replace ( result , 2 , p ) ;
48168: LD_ADDR_VAR 0 2
48172: PUSH
48173: LD_VAR 0 2
48177: PPUSH
48178: LD_INT 2
48180: PPUSH
48181: LD_VAR 0 11
48185: PPUSH
48186: CALL_OW 1
48190: ST_TO_ADDR
// end else
48191: GO 48237
// for i = eng downto 5 do
48193: LD_ADDR_VAR 0 3
48197: PUSH
48198: DOUBLE
48199: LD_VAR 0 6
48203: INC
48204: ST_TO_ADDR
48205: LD_INT 5
48207: PUSH
48208: FOR_DOWNTO
48209: IFFALSE 48235
// tmp := tmp union eng [ i ] ;
48211: LD_ADDR_VAR 0 4
48215: PUSH
48216: LD_VAR 0 4
48220: PUSH
48221: LD_VAR 0 6
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: UNION
48232: ST_TO_ADDR
48233: GO 48208
48235: POP
48236: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
48237: LD_ADDR_VAR 0 2
48241: PUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: LD_INT 1
48249: PPUSH
48250: LD_VAR 0 4
48254: PUSH
48255: LD_VAR 0 5
48259: DIFF
48260: PPUSH
48261: CALL_OW 1
48265: ST_TO_ADDR
// exit ;
48266: GO 48268
// end ; end ;
48268: LD_VAR 0 2
48272: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
48273: LD_INT 0
48275: PPUSH
48276: PPUSH
48277: PPUSH
// if not mc_bases then
48278: LD_EXP 102
48282: NOT
48283: IFFALSE 48287
// exit ;
48285: GO 48429
// for i = 1 to mc_bases do
48287: LD_ADDR_VAR 0 2
48291: PUSH
48292: DOUBLE
48293: LD_INT 1
48295: DEC
48296: ST_TO_ADDR
48297: LD_EXP 102
48301: PUSH
48302: FOR_TO
48303: IFFALSE 48420
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
48305: LD_ADDR_VAR 0 3
48309: PUSH
48310: LD_EXP 102
48314: PUSH
48315: LD_VAR 0 2
48319: ARRAY
48320: PPUSH
48321: LD_INT 21
48323: PUSH
48324: LD_INT 3
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 3
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 29
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: LD_INT 30
48349: PUSH
48350: LD_INT 30
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: LIST
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 3
48368: PUSH
48369: LD_INT 24
48371: PUSH
48372: LD_INT 1000
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PPUSH
48388: CALL_OW 72
48392: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48393: LD_ADDR_EXP 103
48397: PUSH
48398: LD_EXP 103
48402: PPUSH
48403: LD_VAR 0 2
48407: PPUSH
48408: LD_VAR 0 3
48412: PPUSH
48413: CALL_OW 1
48417: ST_TO_ADDR
// end ;
48418: GO 48302
48420: POP
48421: POP
// RaiseSailEvent ( 101 ) ;
48422: LD_INT 101
48424: PPUSH
48425: CALL_OW 427
// end ;
48429: LD_VAR 0 1
48433: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48434: LD_INT 0
48436: PPUSH
48437: PPUSH
48438: PPUSH
48439: PPUSH
48440: PPUSH
48441: PPUSH
48442: PPUSH
// if not mc_bases then
48443: LD_EXP 102
48447: NOT
48448: IFFALSE 48452
// exit ;
48450: GO 49016
// for i = 1 to mc_bases do
48452: LD_ADDR_VAR 0 2
48456: PUSH
48457: DOUBLE
48458: LD_INT 1
48460: DEC
48461: ST_TO_ADDR
48462: LD_EXP 102
48466: PUSH
48467: FOR_TO
48468: IFFALSE 49007
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48470: LD_ADDR_VAR 0 5
48474: PUSH
48475: LD_EXP 102
48479: PUSH
48480: LD_VAR 0 2
48484: ARRAY
48485: PUSH
48486: LD_EXP 131
48490: PUSH
48491: LD_VAR 0 2
48495: ARRAY
48496: UNION
48497: PPUSH
48498: LD_INT 21
48500: PUSH
48501: LD_INT 1
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 1
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: LD_INT 54
48516: PUSH
48517: EMPTY
48518: LIST
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 3
48526: PUSH
48527: LD_INT 24
48529: PUSH
48530: LD_INT 1000
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: LIST
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PPUSH
48550: CALL_OW 72
48554: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48555: LD_ADDR_VAR 0 6
48559: PUSH
48560: LD_EXP 102
48564: PUSH
48565: LD_VAR 0 2
48569: ARRAY
48570: PPUSH
48571: LD_INT 21
48573: PUSH
48574: LD_INT 1
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: PUSH
48581: LD_INT 1
48583: PUSH
48584: LD_INT 3
48586: PUSH
48587: LD_INT 54
48589: PUSH
48590: EMPTY
48591: LIST
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 3
48599: PUSH
48600: LD_INT 24
48602: PUSH
48603: LD_INT 250
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: LIST
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PPUSH
48623: CALL_OW 72
48627: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48628: LD_ADDR_VAR 0 7
48632: PUSH
48633: LD_VAR 0 5
48637: PUSH
48638: LD_VAR 0 6
48642: DIFF
48643: ST_TO_ADDR
// if not need_heal_1 then
48644: LD_VAR 0 6
48648: NOT
48649: IFFALSE 48682
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48651: LD_ADDR_EXP 105
48655: PUSH
48656: LD_EXP 105
48660: PPUSH
48661: LD_VAR 0 2
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PPUSH
48673: EMPTY
48674: PPUSH
48675: CALL 76023 0 3
48679: ST_TO_ADDR
48680: GO 48752
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48682: LD_ADDR_EXP 105
48686: PUSH
48687: LD_EXP 105
48691: PPUSH
48692: LD_VAR 0 2
48696: PUSH
48697: LD_INT 1
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PPUSH
48704: LD_EXP 105
48708: PUSH
48709: LD_VAR 0 2
48713: ARRAY
48714: PUSH
48715: LD_INT 1
48717: ARRAY
48718: PPUSH
48719: LD_INT 3
48721: PUSH
48722: LD_INT 24
48724: PUSH
48725: LD_INT 1000
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PPUSH
48736: CALL_OW 72
48740: PUSH
48741: LD_VAR 0 6
48745: UNION
48746: PPUSH
48747: CALL 76023 0 3
48751: ST_TO_ADDR
// if not need_heal_2 then
48752: LD_VAR 0 7
48756: NOT
48757: IFFALSE 48790
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48759: LD_ADDR_EXP 105
48763: PUSH
48764: LD_EXP 105
48768: PPUSH
48769: LD_VAR 0 2
48773: PUSH
48774: LD_INT 2
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PPUSH
48781: EMPTY
48782: PPUSH
48783: CALL 76023 0 3
48787: ST_TO_ADDR
48788: GO 48822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48790: LD_ADDR_EXP 105
48794: PUSH
48795: LD_EXP 105
48799: PPUSH
48800: LD_VAR 0 2
48804: PUSH
48805: LD_INT 2
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PPUSH
48812: LD_VAR 0 7
48816: PPUSH
48817: CALL 76023 0 3
48821: ST_TO_ADDR
// if need_heal_2 then
48822: LD_VAR 0 7
48826: IFFALSE 48987
// for j in need_heal_2 do
48828: LD_ADDR_VAR 0 3
48832: PUSH
48833: LD_VAR 0 7
48837: PUSH
48838: FOR_IN
48839: IFFALSE 48985
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48841: LD_ADDR_VAR 0 5
48845: PUSH
48846: LD_EXP 102
48850: PUSH
48851: LD_VAR 0 2
48855: ARRAY
48856: PPUSH
48857: LD_INT 2
48859: PUSH
48860: LD_INT 30
48862: PUSH
48863: LD_INT 6
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 30
48872: PUSH
48873: LD_INT 7
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 30
48882: PUSH
48883: LD_INT 8
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 30
48892: PUSH
48893: LD_INT 0
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 30
48902: PUSH
48903: LD_INT 1
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: PPUSH
48918: CALL_OW 72
48922: ST_TO_ADDR
// if tmp then
48923: LD_VAR 0 5
48927: IFFALSE 48983
// begin k := NearestUnitToUnit ( tmp , j ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: LD_VAR 0 3
48943: PPUSH
48944: CALL_OW 74
48948: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48949: LD_VAR 0 3
48953: PPUSH
48954: LD_VAR 0 4
48958: PPUSH
48959: CALL_OW 296
48963: PUSH
48964: LD_INT 5
48966: GREATER
48967: IFFALSE 48983
// ComMoveToNearbyEntrance ( j , k ) ;
48969: LD_VAR 0 3
48973: PPUSH
48974: LD_VAR 0 4
48978: PPUSH
48979: CALL 109950 0 2
// end ; end ;
48983: GO 48838
48985: POP
48986: POP
// if not need_heal_1 and not need_heal_2 then
48987: LD_VAR 0 6
48991: NOT
48992: IFFALSE 49001
48994: PUSH
48995: LD_VAR 0 7
48999: NOT
49000: AND
49001: IFFALSE 49005
// continue ;
49003: GO 48467
// end ;
49005: GO 48467
49007: POP
49008: POP
// RaiseSailEvent ( 102 ) ;
49009: LD_INT 102
49011: PPUSH
49012: CALL_OW 427
// end ;
49016: LD_VAR 0 1
49020: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
49021: LD_INT 0
49023: PPUSH
49024: PPUSH
49025: PPUSH
49026: PPUSH
49027: PPUSH
49028: PPUSH
49029: PPUSH
49030: PPUSH
// if not mc_bases then
49031: LD_EXP 102
49035: NOT
49036: IFFALSE 49040
// exit ;
49038: GO 49955
// for i = 1 to mc_bases do
49040: LD_ADDR_VAR 0 2
49044: PUSH
49045: DOUBLE
49046: LD_INT 1
49048: DEC
49049: ST_TO_ADDR
49050: LD_EXP 102
49054: PUSH
49055: FOR_TO
49056: IFFALSE 49953
// begin if not mc_building_need_repair [ i ] then
49058: LD_EXP 103
49062: PUSH
49063: LD_VAR 0 2
49067: ARRAY
49068: NOT
49069: IFFALSE 49254
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
49071: LD_ADDR_VAR 0 6
49075: PUSH
49076: LD_EXP 121
49080: PUSH
49081: LD_VAR 0 2
49085: ARRAY
49086: PPUSH
49087: LD_INT 3
49089: PUSH
49090: LD_INT 24
49092: PUSH
49093: LD_INT 1000
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 2
49106: PUSH
49107: LD_INT 34
49109: PUSH
49110: LD_INT 13
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 34
49119: PUSH
49120: LD_INT 52
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 34
49129: PUSH
49130: LD_INT 88
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PPUSH
49147: CALL_OW 72
49151: ST_TO_ADDR
// if cranes then
49152: LD_VAR 0 6
49156: IFFALSE 49218
// for j in cranes do
49158: LD_ADDR_VAR 0 3
49162: PUSH
49163: LD_VAR 0 6
49167: PUSH
49168: FOR_IN
49169: IFFALSE 49216
// if not IsInArea ( j , mc_parking [ i ] ) then
49171: LD_VAR 0 3
49175: PPUSH
49176: LD_EXP 126
49180: PUSH
49181: LD_VAR 0 2
49185: ARRAY
49186: PPUSH
49187: CALL_OW 308
49191: NOT
49192: IFFALSE 49214
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49194: LD_VAR 0 3
49198: PPUSH
49199: LD_EXP 126
49203: PUSH
49204: LD_VAR 0 2
49208: ARRAY
49209: PPUSH
49210: CALL_OW 113
49214: GO 49168
49216: POP
49217: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49218: LD_ADDR_EXP 104
49222: PUSH
49223: LD_EXP 104
49227: PPUSH
49228: LD_VAR 0 2
49232: PPUSH
49233: EMPTY
49234: PPUSH
49235: CALL_OW 1
49239: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
49240: LD_VAR 0 2
49244: PPUSH
49245: LD_INT 101
49247: PPUSH
49248: CALL 44046 0 2
// continue ;
49252: GO 49055
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
49254: LD_ADDR_EXP 108
49258: PUSH
49259: LD_EXP 108
49263: PPUSH
49264: LD_VAR 0 2
49268: PPUSH
49269: EMPTY
49270: PPUSH
49271: CALL_OW 1
49275: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49276: LD_VAR 0 2
49280: PPUSH
49281: LD_INT 103
49283: PPUSH
49284: CALL 44046 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
49288: LD_ADDR_VAR 0 5
49292: PUSH
49293: LD_EXP 102
49297: PUSH
49298: LD_VAR 0 2
49302: ARRAY
49303: PUSH
49304: LD_EXP 131
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: UNION
49315: PPUSH
49316: LD_INT 2
49318: PUSH
49319: LD_INT 25
49321: PUSH
49322: LD_INT 2
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PUSH
49329: LD_INT 25
49331: PUSH
49332: LD_INT 16
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: LIST
49343: PUSH
49344: EMPTY
49345: LIST
49346: PPUSH
49347: CALL_OW 72
49351: ST_TO_ADDR
// if mc_need_heal [ i ] then
49352: LD_EXP 105
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: IFFALSE 49406
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49364: LD_ADDR_VAR 0 5
49368: PUSH
49369: LD_VAR 0 5
49373: PUSH
49374: LD_EXP 105
49378: PUSH
49379: LD_VAR 0 2
49383: ARRAY
49384: PUSH
49385: LD_INT 1
49387: ARRAY
49388: PUSH
49389: LD_EXP 105
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: PUSH
49400: LD_INT 2
49402: ARRAY
49403: UNION
49404: DIFF
49405: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49406: LD_ADDR_VAR 0 6
49410: PUSH
49411: LD_EXP 121
49415: PUSH
49416: LD_VAR 0 2
49420: ARRAY
49421: PPUSH
49422: LD_INT 2
49424: PUSH
49425: LD_INT 34
49427: PUSH
49428: LD_INT 13
49430: PUSH
49431: EMPTY
49432: LIST
49433: LIST
49434: PUSH
49435: LD_INT 34
49437: PUSH
49438: LD_INT 52
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 34
49447: PUSH
49448: LD_INT 88
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: PPUSH
49461: CALL_OW 72
49465: ST_TO_ADDR
// if cranes then
49466: LD_VAR 0 6
49470: IFFALSE 49642
// begin for j in cranes do
49472: LD_ADDR_VAR 0 3
49476: PUSH
49477: LD_VAR 0 6
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49640
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49485: LD_VAR 0 3
49489: PPUSH
49490: CALL_OW 256
49494: PUSH
49495: LD_INT 1000
49497: EQUAL
49498: IFFALSE 49512
49500: PUSH
49501: LD_VAR 0 3
49505: PPUSH
49506: CALL_OW 314
49510: NOT
49511: AND
49512: IFFALSE 49578
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49514: LD_ADDR_VAR 0 8
49518: PUSH
49519: LD_EXP 103
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PPUSH
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 74
49539: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49540: LD_VAR 0 8
49544: PPUSH
49545: LD_INT 16
49547: PPUSH
49548: CALL 79002 0 2
49552: PUSH
49553: LD_INT 4
49555: ARRAY
49556: PUSH
49557: LD_INT 10
49559: LESS
49560: IFFALSE 49576
// ComRepairBuilding ( j , to_repair ) ;
49562: LD_VAR 0 3
49566: PPUSH
49567: LD_VAR 0 8
49571: PPUSH
49572: CALL_OW 130
// end else
49576: GO 49638
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 256
49587: PUSH
49588: LD_INT 500
49590: LESS
49591: IFFALSE 49616
49593: PUSH
49594: LD_VAR 0 3
49598: PPUSH
49599: LD_EXP 126
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: CALL_OW 308
49614: NOT
49615: AND
49616: IFFALSE 49638
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49618: LD_VAR 0 3
49622: PPUSH
49623: LD_EXP 126
49627: PUSH
49628: LD_VAR 0 2
49632: ARRAY
49633: PPUSH
49634: CALL_OW 113
// end ;
49638: GO 49482
49640: POP
49641: POP
// end ; if tmp > 3 then
49642: LD_VAR 0 5
49646: PUSH
49647: LD_INT 3
49649: GREATER
49650: IFFALSE 49670
// tmp := ShrinkArray ( tmp , 4 ) ;
49652: LD_ADDR_VAR 0 5
49656: PUSH
49657: LD_VAR 0 5
49661: PPUSH
49662: LD_INT 4
49664: PPUSH
49665: CALL 109386 0 2
49669: ST_TO_ADDR
// if not tmp then
49670: LD_VAR 0 5
49674: NOT
49675: IFFALSE 49679
// continue ;
49677: GO 49055
// for j in tmp do
49679: LD_ADDR_VAR 0 3
49683: PUSH
49684: LD_VAR 0 5
49688: PUSH
49689: FOR_IN
49690: IFFALSE 49949
// begin if IsInUnit ( j ) then
49692: LD_VAR 0 3
49696: PPUSH
49697: CALL_OW 310
49701: IFFALSE 49712
// ComExitBuilding ( j ) ;
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49712: LD_VAR 0 3
49716: PUSH
49717: LD_EXP 104
49721: PUSH
49722: LD_VAR 0 2
49726: ARRAY
49727: IN
49728: NOT
49729: IFFALSE 49787
// begin SetTag ( j , 101 ) ;
49731: LD_VAR 0 3
49735: PPUSH
49736: LD_INT 101
49738: PPUSH
49739: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49743: LD_ADDR_EXP 104
49747: PUSH
49748: LD_EXP 104
49752: PPUSH
49753: LD_VAR 0 2
49757: PUSH
49758: LD_EXP 104
49762: PUSH
49763: LD_VAR 0 2
49767: ARRAY
49768: PUSH
49769: LD_INT 1
49771: PLUS
49772: PUSH
49773: EMPTY
49774: LIST
49775: LIST
49776: PPUSH
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL 76023 0 3
49786: ST_TO_ADDR
// end ; wait ( 1 ) ;
49787: LD_INT 1
49789: PPUSH
49790: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49794: LD_ADDR_VAR 0 7
49798: PUSH
49799: LD_EXP 103
49803: PUSH
49804: LD_VAR 0 2
49808: ARRAY
49809: ST_TO_ADDR
// if mc_scan [ i ] then
49810: LD_EXP 125
49814: PUSH
49815: LD_VAR 0 2
49819: ARRAY
49820: IFFALSE 49882
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49822: LD_ADDR_VAR 0 7
49826: PUSH
49827: LD_EXP 103
49831: PUSH
49832: LD_VAR 0 2
49836: ARRAY
49837: PPUSH
49838: LD_INT 3
49840: PUSH
49841: LD_INT 30
49843: PUSH
49844: LD_INT 32
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: PUSH
49851: LD_INT 30
49853: PUSH
49854: LD_INT 33
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: LD_INT 30
49863: PUSH
49864: LD_INT 31
49866: PUSH
49867: EMPTY
49868: LIST
49869: LIST
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: PPUSH
49877: CALL_OW 72
49881: ST_TO_ADDR
// if not to_repair_tmp then
49882: LD_VAR 0 7
49886: NOT
49887: IFFALSE 49891
// continue ;
49889: GO 49689
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49891: LD_ADDR_VAR 0 8
49895: PUSH
49896: LD_VAR 0 7
49900: PPUSH
49901: LD_VAR 0 3
49905: PPUSH
49906: CALL_OW 74
49910: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49911: LD_VAR 0 8
49915: PPUSH
49916: LD_INT 16
49918: PPUSH
49919: CALL 79002 0 2
49923: PUSH
49924: LD_INT 4
49926: ARRAY
49927: PUSH
49928: LD_INT 14
49930: LESS
49931: IFFALSE 49947
// ComRepairBuilding ( j , to_repair ) ;
49933: LD_VAR 0 3
49937: PPUSH
49938: LD_VAR 0 8
49942: PPUSH
49943: CALL_OW 130
// end ;
49947: GO 49689
49949: POP
49950: POP
// end ;
49951: GO 49055
49953: POP
49954: POP
// end ;
49955: LD_VAR 0 1
49959: RET
// export function MC_Heal ; var i , j , tmp ; begin
49960: LD_INT 0
49962: PPUSH
49963: PPUSH
49964: PPUSH
49965: PPUSH
// if not mc_bases then
49966: LD_EXP 102
49970: NOT
49971: IFFALSE 49975
// exit ;
49973: GO 50381
// for i = 1 to mc_bases do
49975: LD_ADDR_VAR 0 2
49979: PUSH
49980: DOUBLE
49981: LD_INT 1
49983: DEC
49984: ST_TO_ADDR
49985: LD_EXP 102
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50379
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49993: LD_EXP 105
49997: PUSH
49998: LD_VAR 0 2
50002: ARRAY
50003: PUSH
50004: LD_INT 1
50006: ARRAY
50007: NOT
50008: IFFALSE 50027
50010: PUSH
50011: LD_EXP 105
50015: PUSH
50016: LD_VAR 0 2
50020: ARRAY
50021: PUSH
50022: LD_INT 2
50024: ARRAY
50025: NOT
50026: AND
50027: IFFALSE 50065
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
50029: LD_ADDR_EXP 106
50033: PUSH
50034: LD_EXP 106
50038: PPUSH
50039: LD_VAR 0 2
50043: PPUSH
50044: EMPTY
50045: PPUSH
50046: CALL_OW 1
50050: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
50051: LD_VAR 0 2
50055: PPUSH
50056: LD_INT 102
50058: PPUSH
50059: CALL 44046 0 2
// continue ;
50063: GO 49990
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
50065: LD_ADDR_VAR 0 4
50069: PUSH
50070: LD_EXP 102
50074: PUSH
50075: LD_VAR 0 2
50079: ARRAY
50080: PPUSH
50081: LD_INT 25
50083: PUSH
50084: LD_INT 4
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PPUSH
50091: CALL_OW 72
50095: ST_TO_ADDR
// if not tmp then
50096: LD_VAR 0 4
50100: NOT
50101: IFFALSE 50105
// continue ;
50103: GO 49990
// if mc_taming [ i ] then
50105: LD_EXP 133
50109: PUSH
50110: LD_VAR 0 2
50114: ARRAY
50115: IFFALSE 50139
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50117: LD_ADDR_EXP 133
50121: PUSH
50122: LD_EXP 133
50126: PPUSH
50127: LD_VAR 0 2
50131: PPUSH
50132: EMPTY
50133: PPUSH
50134: CALL_OW 1
50138: ST_TO_ADDR
// for j in tmp do
50139: LD_ADDR_VAR 0 3
50143: PUSH
50144: LD_VAR 0 4
50148: PUSH
50149: FOR_IN
50150: IFFALSE 50375
// begin if IsInUnit ( j ) then
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 310
50161: IFFALSE 50172
// ComExitBuilding ( j ) ;
50163: LD_VAR 0 3
50167: PPUSH
50168: CALL_OW 122
// if not j in mc_healers [ i ] then
50172: LD_VAR 0 3
50176: PUSH
50177: LD_EXP 106
50181: PUSH
50182: LD_VAR 0 2
50186: ARRAY
50187: IN
50188: NOT
50189: IFFALSE 50235
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
50191: LD_ADDR_EXP 106
50195: PUSH
50196: LD_EXP 106
50200: PPUSH
50201: LD_VAR 0 2
50205: PUSH
50206: LD_EXP 106
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: PUSH
50217: LD_INT 1
50219: PLUS
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PPUSH
50225: LD_VAR 0 3
50229: PPUSH
50230: CALL 76023 0 3
50234: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 110
50244: PUSH
50245: LD_INT 102
50247: NONEQUAL
50248: IFFALSE 50262
// SetTag ( j , 102 ) ;
50250: LD_VAR 0 3
50254: PPUSH
50255: LD_INT 102
50257: PPUSH
50258: CALL_OW 109
// Wait ( 3 ) ;
50262: LD_INT 3
50264: PPUSH
50265: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
50269: LD_EXP 105
50273: PUSH
50274: LD_VAR 0 2
50278: ARRAY
50279: PUSH
50280: LD_INT 1
50282: ARRAY
50283: IFFALSE 50315
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
50285: LD_VAR 0 3
50289: PPUSH
50290: LD_EXP 105
50294: PUSH
50295: LD_VAR 0 2
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PPUSH
50309: CALL_OW 128
50313: GO 50373
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
50315: LD_VAR 0 3
50319: PPUSH
50320: CALL_OW 314
50324: NOT
50325: IFFALSE 50343
50327: PUSH
50328: LD_EXP 105
50332: PUSH
50333: LD_VAR 0 2
50337: ARRAY
50338: PUSH
50339: LD_INT 2
50341: ARRAY
50342: AND
50343: IFFALSE 50373
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
50345: LD_VAR 0 3
50349: PPUSH
50350: LD_EXP 105
50354: PUSH
50355: LD_VAR 0 2
50359: ARRAY
50360: PUSH
50361: LD_INT 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PPUSH
50369: CALL_OW 128
// end ;
50373: GO 50149
50375: POP
50376: POP
// end ;
50377: GO 49990
50379: POP
50380: POP
// end ;
50381: LD_VAR 0 1
50385: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50386: LD_INT 0
50388: PPUSH
50389: PPUSH
50390: PPUSH
50391: PPUSH
50392: PPUSH
50393: PPUSH
// if not mc_bases then
50394: LD_EXP 102
50398: NOT
50399: IFFALSE 50403
// exit ;
50401: GO 51574
// for i = 1 to mc_bases do
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: DOUBLE
50409: LD_INT 1
50411: DEC
50412: ST_TO_ADDR
50413: LD_EXP 102
50417: PUSH
50418: FOR_TO
50419: IFFALSE 51572
// begin if mc_scan [ i ] then
50421: LD_EXP 125
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: IFFALSE 50435
// continue ;
50433: GO 50418
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50435: LD_EXP 107
50439: PUSH
50440: LD_VAR 0 2
50444: ARRAY
50445: NOT
50446: IFFALSE 50461
50448: PUSH
50449: LD_EXP 109
50453: PUSH
50454: LD_VAR 0 2
50458: ARRAY
50459: NOT
50460: AND
50461: IFFALSE 50475
50463: PUSH
50464: LD_EXP 108
50468: PUSH
50469: LD_VAR 0 2
50473: ARRAY
50474: AND
50475: IFFALSE 50513
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50477: LD_ADDR_EXP 108
50481: PUSH
50482: LD_EXP 108
50486: PPUSH
50487: LD_VAR 0 2
50491: PPUSH
50492: EMPTY
50493: PPUSH
50494: CALL_OW 1
50498: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50499: LD_VAR 0 2
50503: PPUSH
50504: LD_INT 103
50506: PPUSH
50507: CALL 44046 0 2
// continue ;
50511: GO 50418
// end ; if mc_construct_list [ i ] then
50513: LD_EXP 109
50517: PUSH
50518: LD_VAR 0 2
50522: ARRAY
50523: IFFALSE 50743
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50525: LD_ADDR_VAR 0 5
50529: PUSH
50530: LD_EXP 102
50534: PUSH
50535: LD_VAR 0 2
50539: ARRAY
50540: PPUSH
50541: LD_INT 25
50543: PUSH
50544: LD_INT 2
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PPUSH
50551: CALL_OW 72
50555: PUSH
50556: LD_EXP 104
50560: PUSH
50561: LD_VAR 0 2
50565: ARRAY
50566: DIFF
50567: ST_TO_ADDR
// if not tmp then
50568: LD_VAR 0 5
50572: NOT
50573: IFFALSE 50577
// continue ;
50575: GO 50418
// for j in tmp do
50577: LD_ADDR_VAR 0 3
50581: PUSH
50582: LD_VAR 0 5
50586: PUSH
50587: FOR_IN
50588: IFFALSE 50739
// begin if not mc_builders [ i ] then
50590: LD_EXP 108
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: NOT
50601: IFFALSE 50659
// begin SetTag ( j , 103 ) ;
50603: LD_VAR 0 3
50607: PPUSH
50608: LD_INT 103
50610: PPUSH
50611: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50615: LD_ADDR_EXP 108
50619: PUSH
50620: LD_EXP 108
50624: PPUSH
50625: LD_VAR 0 2
50629: PUSH
50630: LD_EXP 108
50634: PUSH
50635: LD_VAR 0 2
50639: ARRAY
50640: PUSH
50641: LD_INT 1
50643: PLUS
50644: PUSH
50645: EMPTY
50646: LIST
50647: LIST
50648: PPUSH
50649: LD_VAR 0 3
50653: PPUSH
50654: CALL 76023 0 3
50658: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50659: LD_VAR 0 3
50663: PPUSH
50664: CALL_OW 310
50668: IFFALSE 50679
// ComExitBuilding ( j ) ;
50670: LD_VAR 0 3
50674: PPUSH
50675: CALL_OW 122
// wait ( 3 ) ;
50679: LD_INT 3
50681: PPUSH
50682: CALL_OW 67
// if not mc_construct_list [ i ] then
50686: LD_EXP 109
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: NOT
50697: IFFALSE 50701
// break ;
50699: GO 50739
// if not HasTask ( j ) then
50701: LD_VAR 0 3
50705: PPUSH
50706: CALL_OW 314
50710: NOT
50711: IFFALSE 50737
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50713: LD_VAR 0 3
50717: PPUSH
50718: LD_EXP 109
50722: PUSH
50723: LD_VAR 0 2
50727: ARRAY
50728: PUSH
50729: LD_INT 1
50731: ARRAY
50732: PPUSH
50733: CALL 79275 0 2
// end ;
50737: GO 50587
50739: POP
50740: POP
// end else
50741: GO 51570
// if mc_build_list [ i ] then
50743: LD_EXP 107
50747: PUSH
50748: LD_VAR 0 2
50752: ARRAY
50753: IFFALSE 51570
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50755: LD_EXP 107
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: PUSH
50766: LD_INT 1
50768: ARRAY
50769: PUSH
50770: LD_INT 1
50772: ARRAY
50773: PPUSH
50774: CALL 79099 0 1
50778: IFFALSE 50826
50780: PUSH
50781: LD_EXP 102
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: PPUSH
50792: LD_INT 2
50794: PUSH
50795: LD_INT 30
50797: PUSH
50798: LD_INT 2
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: LD_INT 30
50807: PUSH
50808: LD_INT 3
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: LIST
50819: PPUSH
50820: CALL_OW 72
50824: NOT
50825: AND
50826: IFFALSE 50931
// begin for j = 1 to mc_build_list [ i ] do
50828: LD_ADDR_VAR 0 3
50832: PUSH
50833: DOUBLE
50834: LD_INT 1
50836: DEC
50837: ST_TO_ADDR
50838: LD_EXP 107
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: FOR_TO
50850: IFFALSE 50929
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50852: LD_EXP 107
50856: PUSH
50857: LD_VAR 0 2
50861: ARRAY
50862: PUSH
50863: LD_VAR 0 3
50867: ARRAY
50868: PUSH
50869: LD_INT 1
50871: ARRAY
50872: PUSH
50873: LD_INT 2
50875: EQUAL
50876: IFFALSE 50927
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50878: LD_ADDR_EXP 107
50882: PUSH
50883: LD_EXP 107
50887: PPUSH
50888: LD_VAR 0 2
50892: PPUSH
50893: LD_EXP 107
50897: PUSH
50898: LD_VAR 0 2
50902: ARRAY
50903: PPUSH
50904: LD_VAR 0 3
50908: PPUSH
50909: LD_INT 1
50911: PPUSH
50912: LD_INT 0
50914: PPUSH
50915: CALL 75431 0 4
50919: PPUSH
50920: CALL_OW 1
50924: ST_TO_ADDR
// break ;
50925: GO 50929
// end ;
50927: GO 50849
50929: POP
50930: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50931: LD_ADDR_VAR 0 6
50935: PUSH
50936: LD_EXP 102
50940: PUSH
50941: LD_VAR 0 2
50945: ARRAY
50946: PPUSH
50947: LD_INT 2
50949: PUSH
50950: LD_INT 30
50952: PUSH
50953: LD_INT 0
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 30
50962: PUSH
50963: LD_INT 1
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: LIST
50974: PPUSH
50975: CALL_OW 72
50979: ST_TO_ADDR
// for k := 1 to depot do
50980: LD_ADDR_VAR 0 4
50984: PUSH
50985: DOUBLE
50986: LD_INT 1
50988: DEC
50989: ST_TO_ADDR
50990: LD_VAR 0 6
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51568
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50998: LD_EXP 107
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PUSH
51013: LD_INT 1
51015: ARRAY
51016: PUSH
51017: LD_INT 0
51019: EQUAL
51020: IFTRUE 51115
51022: PUSH
51023: LD_VAR 0 6
51027: PUSH
51028: LD_VAR 0 4
51032: ARRAY
51033: PPUSH
51034: LD_EXP 107
51038: PUSH
51039: LD_VAR 0 2
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: LD_EXP 107
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_INT 1
51066: ARRAY
51067: PUSH
51068: LD_INT 2
51070: ARRAY
51071: PPUSH
51072: LD_EXP 107
51076: PUSH
51077: LD_VAR 0 2
51081: ARRAY
51082: PUSH
51083: LD_INT 1
51085: ARRAY
51086: PUSH
51087: LD_INT 3
51089: ARRAY
51090: PPUSH
51091: LD_EXP 107
51095: PUSH
51096: LD_VAR 0 2
51100: ARRAY
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 4
51108: ARRAY
51109: PPUSH
51110: CALL 84579 0 5
51114: OR
51115: IFFALSE 51396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51117: LD_ADDR_VAR 0 5
51121: PUSH
51122: LD_EXP 102
51126: PUSH
51127: LD_VAR 0 2
51131: ARRAY
51132: PPUSH
51133: LD_INT 25
51135: PUSH
51136: LD_INT 2
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PPUSH
51143: CALL_OW 72
51147: PUSH
51148: LD_EXP 104
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: DIFF
51159: ST_TO_ADDR
// if not tmp then
51160: LD_VAR 0 5
51164: NOT
51165: IFFALSE 51169
// continue ;
51167: GO 50995
// for j in tmp do
51169: LD_ADDR_VAR 0 3
51173: PUSH
51174: LD_VAR 0 5
51178: PUSH
51179: FOR_IN
51180: IFFALSE 51392
// begin if not mc_builders [ i ] then
51182: LD_EXP 108
51186: PUSH
51187: LD_VAR 0 2
51191: ARRAY
51192: NOT
51193: IFFALSE 51251
// begin SetTag ( j , 103 ) ;
51195: LD_VAR 0 3
51199: PPUSH
51200: LD_INT 103
51202: PPUSH
51203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
51207: LD_ADDR_EXP 108
51211: PUSH
51212: LD_EXP 108
51216: PPUSH
51217: LD_VAR 0 2
51221: PUSH
51222: LD_EXP 108
51226: PUSH
51227: LD_VAR 0 2
51231: ARRAY
51232: PUSH
51233: LD_INT 1
51235: PLUS
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PPUSH
51241: LD_VAR 0 3
51245: PPUSH
51246: CALL 76023 0 3
51250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
51251: LD_VAR 0 3
51255: PPUSH
51256: CALL_OW 310
51260: IFFALSE 51271
// ComExitBuilding ( j ) ;
51262: LD_VAR 0 3
51266: PPUSH
51267: CALL_OW 122
// wait ( 3 ) ;
51271: LD_INT 3
51273: PPUSH
51274: CALL_OW 67
// if not mc_build_list [ i ] then
51278: LD_EXP 107
51282: PUSH
51283: LD_VAR 0 2
51287: ARRAY
51288: NOT
51289: IFFALSE 51293
// break ;
51291: GO 51392
// if not HasTask ( j ) then
51293: LD_VAR 0 3
51297: PPUSH
51298: CALL_OW 314
51302: NOT
51303: IFFALSE 51390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
51305: LD_VAR 0 3
51309: PPUSH
51310: LD_EXP 107
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PUSH
51321: LD_INT 1
51323: ARRAY
51324: PUSH
51325: LD_INT 1
51327: ARRAY
51328: PPUSH
51329: LD_EXP 107
51333: PUSH
51334: LD_VAR 0 2
51338: ARRAY
51339: PUSH
51340: LD_INT 1
51342: ARRAY
51343: PUSH
51344: LD_INT 2
51346: ARRAY
51347: PPUSH
51348: LD_EXP 107
51352: PUSH
51353: LD_VAR 0 2
51357: ARRAY
51358: PUSH
51359: LD_INT 1
51361: ARRAY
51362: PUSH
51363: LD_INT 3
51365: ARRAY
51366: PPUSH
51367: LD_EXP 107
51371: PUSH
51372: LD_VAR 0 2
51376: ARRAY
51377: PUSH
51378: LD_INT 1
51380: ARRAY
51381: PUSH
51382: LD_INT 4
51384: ARRAY
51385: PPUSH
51386: CALL_OW 145
// end ;
51390: GO 51179
51392: POP
51393: POP
// end else
51394: GO 51566
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51396: LD_EXP 102
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PPUSH
51407: LD_EXP 107
51411: PUSH
51412: LD_VAR 0 2
51416: ARRAY
51417: PUSH
51418: LD_INT 1
51420: ARRAY
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PPUSH
51426: LD_EXP 107
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: PUSH
51437: LD_INT 1
51439: ARRAY
51440: PUSH
51441: LD_INT 2
51443: ARRAY
51444: PPUSH
51445: LD_EXP 107
51449: PUSH
51450: LD_VAR 0 2
51454: ARRAY
51455: PUSH
51456: LD_INT 1
51458: ARRAY
51459: PUSH
51460: LD_INT 3
51462: ARRAY
51463: PPUSH
51464: LD_EXP 107
51468: PUSH
51469: LD_VAR 0 2
51473: ARRAY
51474: PUSH
51475: LD_INT 1
51477: ARRAY
51478: PUSH
51479: LD_INT 4
51481: ARRAY
51482: PPUSH
51483: LD_EXP 102
51487: PUSH
51488: LD_VAR 0 2
51492: ARRAY
51493: PPUSH
51494: LD_INT 21
51496: PUSH
51497: LD_INT 3
51499: PUSH
51500: EMPTY
51501: LIST
51502: LIST
51503: PPUSH
51504: CALL_OW 72
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL 83315 0 7
51515: NOT
51516: IFFALSE 51566
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51518: LD_ADDR_EXP 107
51522: PUSH
51523: LD_EXP 107
51527: PPUSH
51528: LD_VAR 0 2
51532: PPUSH
51533: LD_EXP 107
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: PPUSH
51544: LD_INT 1
51546: PPUSH
51547: LD_INT 1
51549: NEG
51550: PPUSH
51551: LD_INT 0
51553: PPUSH
51554: CALL 75431 0 4
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// continue ;
51564: GO 50995
// end ; end ;
51566: GO 50995
51568: POP
51569: POP
// end ; end ;
51570: GO 50418
51572: POP
51573: POP
// end ;
51574: LD_VAR 0 1
51578: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51579: LD_INT 0
51581: PPUSH
51582: PPUSH
51583: PPUSH
51584: PPUSH
51585: PPUSH
51586: PPUSH
// if not mc_bases then
51587: LD_EXP 102
51591: NOT
51592: IFFALSE 51596
// exit ;
51594: GO 52029
// for i = 1 to mc_bases do
51596: LD_ADDR_VAR 0 2
51600: PUSH
51601: DOUBLE
51602: LD_INT 1
51604: DEC
51605: ST_TO_ADDR
51606: LD_EXP 102
51610: PUSH
51611: FOR_TO
51612: IFFALSE 52027
// begin tmp := mc_build_upgrade [ i ] ;
51614: LD_ADDR_VAR 0 4
51618: PUSH
51619: LD_EXP 134
51623: PUSH
51624: LD_VAR 0 2
51628: ARRAY
51629: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51630: LD_ADDR_VAR 0 6
51634: PUSH
51635: LD_EXP 135
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PPUSH
51646: LD_INT 2
51648: PUSH
51649: LD_INT 30
51651: PUSH
51652: LD_INT 6
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: PUSH
51659: LD_INT 30
51661: PUSH
51662: LD_INT 7
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: LIST
51673: PPUSH
51674: CALL_OW 72
51678: ST_TO_ADDR
// if not tmp and not lab then
51679: LD_VAR 0 4
51683: NOT
51684: IFFALSE 51693
51686: PUSH
51687: LD_VAR 0 6
51691: NOT
51692: AND
51693: IFFALSE 51697
// continue ;
51695: GO 51611
// if tmp then
51697: LD_VAR 0 4
51701: IFFALSE 51821
// for j in tmp do
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_VAR 0 4
51712: PUSH
51713: FOR_IN
51714: IFFALSE 51819
// begin if UpgradeCost ( j ) then
51716: LD_VAR 0 3
51720: PPUSH
51721: CALL 82967 0 1
51725: IFFALSE 51817
// begin ComUpgrade ( j ) ;
51727: LD_VAR 0 3
51731: PPUSH
51732: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51736: LD_ADDR_EXP 134
51740: PUSH
51741: LD_EXP 134
51745: PPUSH
51746: LD_VAR 0 2
51750: PPUSH
51751: LD_EXP 134
51755: PUSH
51756: LD_VAR 0 2
51760: ARRAY
51761: PUSH
51762: LD_VAR 0 3
51766: DIFF
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51773: LD_ADDR_EXP 109
51777: PUSH
51778: LD_EXP 109
51782: PPUSH
51783: LD_VAR 0 2
51787: PUSH
51788: LD_EXP 109
51792: PUSH
51793: LD_VAR 0 2
51797: ARRAY
51798: PUSH
51799: LD_INT 1
51801: PLUS
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PPUSH
51807: LD_VAR 0 3
51811: PPUSH
51812: CALL 76023 0 3
51816: ST_TO_ADDR
// end ; end ;
51817: GO 51713
51819: POP
51820: POP
// if not lab or not mc_lab_upgrade [ i ] then
51821: LD_VAR 0 6
51825: NOT
51826: IFTRUE 51841
51828: PUSH
51829: LD_EXP 136
51833: PUSH
51834: LD_VAR 0 2
51838: ARRAY
51839: NOT
51840: OR
51841: IFFALSE 51845
// continue ;
51843: GO 51611
// for j in lab do
51845: LD_ADDR_VAR 0 3
51849: PUSH
51850: LD_VAR 0 6
51854: PUSH
51855: FOR_IN
51856: IFFALSE 52023
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51858: LD_VAR 0 3
51862: PPUSH
51863: CALL_OW 266
51867: PUSH
51868: LD_INT 6
51870: PUSH
51871: LD_INT 7
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: IN
51878: IFFALSE 51895
51880: PUSH
51881: LD_VAR 0 3
51885: PPUSH
51886: CALL_OW 461
51890: PUSH
51891: LD_INT 1
51893: NONEQUAL
51894: AND
51895: IFFALSE 52021
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51897: LD_VAR 0 3
51901: PPUSH
51902: LD_EXP 136
51906: PUSH
51907: LD_VAR 0 2
51911: ARRAY
51912: PUSH
51913: LD_INT 1
51915: ARRAY
51916: PPUSH
51917: CALL 83176 0 2
51921: IFFALSE 52021
// begin ComCancel ( j ) ;
51923: LD_VAR 0 3
51927: PPUSH
51928: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51932: LD_VAR 0 3
51936: PPUSH
51937: LD_EXP 136
51941: PUSH
51942: LD_VAR 0 2
51946: ARRAY
51947: PUSH
51948: LD_INT 1
51950: ARRAY
51951: PPUSH
51952: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51956: LD_VAR 0 3
51960: PUSH
51961: LD_EXP 109
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: IN
51972: NOT
51973: IFFALSE 52019
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51975: LD_ADDR_EXP 109
51979: PUSH
51980: LD_EXP 109
51984: PPUSH
51985: LD_VAR 0 2
51989: PUSH
51990: LD_EXP 109
51994: PUSH
51995: LD_VAR 0 2
51999: ARRAY
52000: PUSH
52001: LD_INT 1
52003: PLUS
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PPUSH
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL 76023 0 3
52018: ST_TO_ADDR
// break ;
52019: GO 52023
// end ; end ; end ;
52021: GO 51855
52023: POP
52024: POP
// end ;
52025: GO 51611
52027: POP
52028: POP
// end ;
52029: LD_VAR 0 1
52033: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
52034: LD_INT 0
52036: PPUSH
52037: PPUSH
52038: PPUSH
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
52044: PPUSH
// if not mc_bases then
52045: LD_EXP 102
52049: NOT
52050: IFFALSE 52054
// exit ;
52052: GO 52461
// for i = 1 to mc_bases do
52054: LD_ADDR_VAR 0 2
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_EXP 102
52068: PUSH
52069: FOR_TO
52070: IFFALSE 52459
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
52072: LD_EXP 110
52076: PUSH
52077: LD_VAR 0 2
52081: ARRAY
52082: NOT
52083: IFTRUE 52113
52085: PUSH
52086: LD_EXP 102
52090: PUSH
52091: LD_VAR 0 2
52095: ARRAY
52096: PPUSH
52097: LD_INT 30
52099: PUSH
52100: LD_INT 3
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PPUSH
52107: CALL_OW 72
52111: NOT
52112: OR
52113: IFFALSE 52117
// continue ;
52115: GO 52069
// busy := false ;
52117: LD_ADDR_VAR 0 8
52121: PUSH
52122: LD_INT 0
52124: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52125: LD_ADDR_VAR 0 4
52129: PUSH
52130: LD_EXP 102
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PPUSH
52141: LD_INT 30
52143: PUSH
52144: LD_INT 3
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: PPUSH
52151: CALL_OW 72
52155: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
52156: LD_ADDR_VAR 0 6
52160: PUSH
52161: LD_EXP 110
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PPUSH
52172: LD_INT 2
52174: PUSH
52175: LD_INT 30
52177: PUSH
52178: LD_INT 32
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: PUSH
52185: LD_INT 30
52187: PUSH
52188: LD_INT 33
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: LIST
52199: PPUSH
52200: CALL_OW 72
52204: ST_TO_ADDR
// if not t then
52205: LD_VAR 0 6
52209: NOT
52210: IFFALSE 52214
// continue ;
52212: GO 52069
// for j in tmp do
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_VAR 0 4
52223: PUSH
52224: FOR_IN
52225: IFFALSE 52255
// if not BuildingStatus ( j ) = bs_idle then
52227: LD_VAR 0 3
52231: PPUSH
52232: CALL_OW 461
52236: PUSH
52237: LD_INT 2
52239: EQUAL
52240: NOT
52241: IFFALSE 52253
// begin busy := true ;
52243: LD_ADDR_VAR 0 8
52247: PUSH
52248: LD_INT 1
52250: ST_TO_ADDR
// break ;
52251: GO 52255
// end ;
52253: GO 52224
52255: POP
52256: POP
// if busy then
52257: LD_VAR 0 8
52261: IFFALSE 52265
// continue ;
52263: GO 52069
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
52265: LD_ADDR_VAR 0 7
52269: PUSH
52270: LD_VAR 0 6
52274: PPUSH
52275: LD_INT 35
52277: PUSH
52278: LD_INT 0
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PPUSH
52285: CALL_OW 72
52289: ST_TO_ADDR
// if tw then
52290: LD_VAR 0 7
52294: IFFALSE 52371
// begin tw := tw [ 1 ] ;
52296: LD_ADDR_VAR 0 7
52300: PUSH
52301: LD_VAR 0 7
52305: PUSH
52306: LD_INT 1
52308: ARRAY
52309: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
52310: LD_ADDR_VAR 0 9
52314: PUSH
52315: LD_VAR 0 7
52319: PPUSH
52320: LD_EXP 127
52324: PUSH
52325: LD_VAR 0 2
52329: ARRAY
52330: PPUSH
52331: CALL 81430 0 2
52335: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
52336: LD_EXP 141
52340: PUSH
52341: LD_VAR 0 2
52345: ARRAY
52346: IFFALSE 52369
// if not weapon in mc_allowed_tower_weapons [ i ] then
52348: LD_VAR 0 9
52352: PUSH
52353: LD_EXP 141
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: IN
52364: NOT
52365: IFFALSE 52369
// continue ;
52367: GO 52069
// end else
52369: GO 52434
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
52371: LD_ADDR_VAR 0 5
52375: PUSH
52376: LD_EXP 110
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: PPUSH
52387: LD_VAR 0 4
52391: PPUSH
52392: CALL 108615 0 2
52396: ST_TO_ADDR
// if not tmp2 then
52397: LD_VAR 0 5
52401: NOT
52402: IFFALSE 52406
// continue ;
52404: GO 52069
// tw := tmp2 [ 1 ] ;
52406: LD_ADDR_VAR 0 7
52410: PUSH
52411: LD_VAR 0 5
52415: PUSH
52416: LD_INT 1
52418: ARRAY
52419: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52420: LD_ADDR_VAR 0 9
52424: PUSH
52425: LD_VAR 0 5
52429: PUSH
52430: LD_INT 2
52432: ARRAY
52433: ST_TO_ADDR
// end ; if not weapon then
52434: LD_VAR 0 9
52438: NOT
52439: IFFALSE 52443
// continue ;
52441: GO 52069
// ComPlaceWeapon ( tw , weapon ) ;
52443: LD_VAR 0 7
52447: PPUSH
52448: LD_VAR 0 9
52452: PPUSH
52453: CALL_OW 148
// end ;
52457: GO 52069
52459: POP
52460: POP
// end ;
52461: LD_VAR 0 1
52465: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52466: LD_INT 0
52468: PPUSH
52469: PPUSH
52470: PPUSH
52471: PPUSH
52472: PPUSH
52473: PPUSH
52474: PPUSH
// if not mc_bases then
52475: LD_EXP 102
52479: NOT
52480: IFFALSE 52484
// exit ;
52482: GO 53271
// for i = 1 to mc_bases do
52484: LD_ADDR_VAR 0 2
52488: PUSH
52489: DOUBLE
52490: LD_INT 1
52492: DEC
52493: ST_TO_ADDR
52494: LD_EXP 102
52498: PUSH
52499: FOR_TO
52500: IFFALSE 53269
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52502: LD_EXP 115
52506: PUSH
52507: LD_VAR 0 2
52511: ARRAY
52512: NOT
52513: IFTRUE 52539
52515: PUSH
52516: LD_EXP 115
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: PUSH
52527: LD_EXP 116
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: EQUAL
52538: OR
52539: IFTRUE 52553
52541: PUSH
52542: LD_EXP 125
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: OR
52553: IFFALSE 52557
// continue ;
52555: GO 52499
// if mc_miners [ i ] then
52557: LD_EXP 116
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: IFFALSE 52954
// begin for j = mc_miners [ i ] downto 1 do
52569: LD_ADDR_VAR 0 3
52573: PUSH
52574: DOUBLE
52575: LD_EXP 116
52579: PUSH
52580: LD_VAR 0 2
52584: ARRAY
52585: INC
52586: ST_TO_ADDR
52587: LD_INT 1
52589: PUSH
52590: FOR_DOWNTO
52591: IFFALSE 52952
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52593: LD_EXP 116
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: PUSH
52604: LD_VAR 0 3
52608: ARRAY
52609: PPUSH
52610: CALL_OW 301
52614: IFTRUE 52643
52616: PUSH
52617: LD_EXP 116
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: PUSH
52628: LD_VAR 0 3
52632: ARRAY
52633: PPUSH
52634: CALL_OW 257
52638: PUSH
52639: LD_INT 1
52641: NONEQUAL
52642: OR
52643: IFFALSE 52706
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52645: LD_ADDR_VAR 0 5
52649: PUSH
52650: LD_EXP 116
52654: PUSH
52655: LD_VAR 0 2
52659: ARRAY
52660: PUSH
52661: LD_EXP 116
52665: PUSH
52666: LD_VAR 0 2
52670: ARRAY
52671: PUSH
52672: LD_VAR 0 3
52676: ARRAY
52677: DIFF
52678: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52679: LD_ADDR_EXP 116
52683: PUSH
52684: LD_EXP 116
52688: PPUSH
52689: LD_VAR 0 2
52693: PPUSH
52694: LD_VAR 0 5
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// continue ;
52704: GO 52590
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52706: LD_EXP 116
52710: PUSH
52711: LD_VAR 0 2
52715: ARRAY
52716: PUSH
52717: LD_VAR 0 3
52721: ARRAY
52722: PPUSH
52723: CALL_OW 257
52727: PUSH
52728: LD_INT 1
52730: EQUAL
52731: IFFALSE 52757
52733: PUSH
52734: LD_EXP 116
52738: PUSH
52739: LD_VAR 0 2
52743: ARRAY
52744: PUSH
52745: LD_VAR 0 3
52749: ARRAY
52750: PPUSH
52751: CALL_OW 459
52755: NOT
52756: AND
52757: IFFALSE 52783
52759: PUSH
52760: LD_EXP 116
52764: PUSH
52765: LD_VAR 0 2
52769: ARRAY
52770: PUSH
52771: LD_VAR 0 3
52775: ARRAY
52776: PPUSH
52777: CALL_OW 314
52781: NOT
52782: AND
52783: IFFALSE 52950
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52785: LD_EXP 116
52789: PUSH
52790: LD_VAR 0 2
52794: ARRAY
52795: PUSH
52796: LD_VAR 0 3
52800: ARRAY
52801: PPUSH
52802: CALL_OW 310
52806: IFFALSE 52829
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52808: LD_EXP 116
52812: PUSH
52813: LD_VAR 0 2
52817: ARRAY
52818: PUSH
52819: LD_VAR 0 3
52823: ARRAY
52824: PPUSH
52825: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52829: LD_EXP 116
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: PUSH
52840: LD_VAR 0 3
52844: ARRAY
52845: PPUSH
52846: CALL_OW 314
52850: NOT
52851: IFFALSE 52950
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 3
52862: PUSH
52863: LD_EXP 115
52867: PUSH
52868: LD_VAR 0 2
52872: ARRAY
52873: PPUSH
52874: CALL 73139 0 1
52878: MOD
52879: PUSH
52880: LD_INT 1
52882: PLUS
52883: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52884: LD_EXP 116
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_VAR 0 3
52899: ARRAY
52900: PPUSH
52901: LD_EXP 115
52905: PUSH
52906: LD_VAR 0 2
52910: ARRAY
52911: PUSH
52912: LD_VAR 0 7
52916: ARRAY
52917: PUSH
52918: LD_INT 1
52920: ARRAY
52921: PPUSH
52922: LD_EXP 115
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_VAR 0 7
52937: ARRAY
52938: PUSH
52939: LD_INT 2
52941: ARRAY
52942: PPUSH
52943: LD_INT 0
52945: PPUSH
52946: CALL_OW 193
// end ; end ; end ;
52950: GO 52590
52952: POP
52953: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52954: LD_ADDR_VAR 0 5
52958: PUSH
52959: LD_EXP 102
52963: PUSH
52964: LD_VAR 0 2
52968: ARRAY
52969: PPUSH
52970: LD_INT 2
52972: PUSH
52973: LD_INT 30
52975: PUSH
52976: LD_INT 4
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: LD_INT 30
52985: PUSH
52986: LD_INT 5
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: PUSH
52993: LD_INT 30
52995: PUSH
52996: LD_INT 32
52998: PUSH
52999: EMPTY
53000: LIST
53001: LIST
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: LIST
53007: LIST
53008: PPUSH
53009: CALL_OW 72
53013: ST_TO_ADDR
// if not tmp then
53014: LD_VAR 0 5
53018: NOT
53019: IFFALSE 53023
// continue ;
53021: GO 52499
// list := [ ] ;
53023: LD_ADDR_VAR 0 6
53027: PUSH
53028: EMPTY
53029: ST_TO_ADDR
// for j in tmp do
53030: LD_ADDR_VAR 0 3
53034: PUSH
53035: LD_VAR 0 5
53039: PUSH
53040: FOR_IN
53041: IFFALSE 53112
// begin for k in UnitsInside ( j ) do
53043: LD_ADDR_VAR 0 4
53047: PUSH
53048: LD_VAR 0 3
53052: PPUSH
53053: CALL_OW 313
53057: PUSH
53058: FOR_IN
53059: IFFALSE 53108
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
53061: LD_VAR 0 4
53065: PPUSH
53066: CALL_OW 257
53070: PUSH
53071: LD_INT 1
53073: EQUAL
53074: IFFALSE 53088
53076: PUSH
53077: LD_VAR 0 4
53081: PPUSH
53082: CALL_OW 459
53086: NOT
53087: AND
53088: IFFALSE 53106
// list := list ^ k ;
53090: LD_ADDR_VAR 0 6
53094: PUSH
53095: LD_VAR 0 6
53099: PUSH
53100: LD_VAR 0 4
53104: ADD
53105: ST_TO_ADDR
53106: GO 53058
53108: POP
53109: POP
// end ;
53110: GO 53040
53112: POP
53113: POP
// list := list diff mc_miners [ i ] ;
53114: LD_ADDR_VAR 0 6
53118: PUSH
53119: LD_VAR 0 6
53123: PUSH
53124: LD_EXP 116
53128: PUSH
53129: LD_VAR 0 2
53133: ARRAY
53134: DIFF
53135: ST_TO_ADDR
// if not list then
53136: LD_VAR 0 6
53140: NOT
53141: IFFALSE 53145
// continue ;
53143: GO 52499
// k := mc_mines [ i ] - mc_miners [ i ] ;
53145: LD_ADDR_VAR 0 4
53149: PUSH
53150: LD_EXP 115
53154: PUSH
53155: LD_VAR 0 2
53159: ARRAY
53160: PUSH
53161: LD_EXP 116
53165: PUSH
53166: LD_VAR 0 2
53170: ARRAY
53171: MINUS
53172: ST_TO_ADDR
// if k > list then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 6
53182: GREATER
53183: IFFALSE 53195
// k := list ;
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 6
53194: ST_TO_ADDR
// for j = 1 to k do
53195: LD_ADDR_VAR 0 3
53199: PUSH
53200: DOUBLE
53201: LD_INT 1
53203: DEC
53204: ST_TO_ADDR
53205: LD_VAR 0 4
53209: PUSH
53210: FOR_TO
53211: IFFALSE 53265
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
53213: LD_ADDR_EXP 116
53217: PUSH
53218: LD_EXP 116
53222: PPUSH
53223: LD_VAR 0 2
53227: PUSH
53228: LD_EXP 116
53232: PUSH
53233: LD_VAR 0 2
53237: ARRAY
53238: PUSH
53239: LD_INT 1
53241: PLUS
53242: PUSH
53243: EMPTY
53244: LIST
53245: LIST
53246: PPUSH
53247: LD_VAR 0 6
53251: PUSH
53252: LD_VAR 0 3
53256: ARRAY
53257: PPUSH
53258: CALL 76023 0 3
53262: ST_TO_ADDR
53263: GO 53210
53265: POP
53266: POP
// end ;
53267: GO 52499
53269: POP
53270: POP
// end ;
53271: LD_VAR 0 1
53275: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
53276: LD_INT 0
53278: PPUSH
53279: PPUSH
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
53287: PPUSH
53288: PPUSH
// if not mc_bases then
53289: LD_EXP 102
53293: NOT
53294: IFFALSE 53298
// exit ;
53296: GO 55145
// for i = 1 to mc_bases do
53298: LD_ADDR_VAR 0 2
53302: PUSH
53303: DOUBLE
53304: LD_INT 1
53306: DEC
53307: ST_TO_ADDR
53308: LD_EXP 102
53312: PUSH
53313: FOR_TO
53314: IFFALSE 55143
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
53316: LD_EXP 102
53320: PUSH
53321: LD_VAR 0 2
53325: ARRAY
53326: NOT
53327: IFTRUE 53341
53329: PUSH
53330: LD_EXP 109
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: OR
53341: IFFALSE 53345
// continue ;
53343: GO 53313
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
53345: LD_EXP 118
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: NOT
53356: IFFALSE 53370
53358: PUSH
53359: LD_EXP 119
53363: PUSH
53364: LD_VAR 0 2
53368: ARRAY
53369: AND
53370: IFFALSE 53408
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53372: LD_ADDR_EXP 119
53376: PUSH
53377: LD_EXP 119
53381: PPUSH
53382: LD_VAR 0 2
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53394: LD_VAR 0 2
53398: PPUSH
53399: LD_INT 107
53401: PPUSH
53402: CALL 44046 0 2
// continue ;
53406: GO 53313
// end ; target := [ ] ;
53408: LD_ADDR_VAR 0 7
53412: PUSH
53413: EMPTY
53414: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53415: LD_ADDR_VAR 0 6
53419: PUSH
53420: LD_EXP 102
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: PUSH
53431: LD_INT 1
53433: ARRAY
53434: PPUSH
53435: CALL_OW 255
53439: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53440: LD_ADDR_VAR 0 9
53444: PUSH
53445: LD_EXP 102
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PPUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 30
53461: PUSH
53462: LD_INT 0
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PUSH
53469: LD_INT 30
53471: PUSH
53472: LD_INT 1
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 72
53488: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: DOUBLE
53495: LD_EXP 118
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: INC
53506: ST_TO_ADDR
53507: LD_INT 1
53509: PUSH
53510: FOR_DOWNTO
53511: IFFALSE 53758
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53513: LD_EXP 118
53517: PUSH
53518: LD_VAR 0 2
53522: ARRAY
53523: PUSH
53524: LD_VAR 0 3
53528: ARRAY
53529: PUSH
53530: LD_INT 2
53532: ARRAY
53533: PPUSH
53534: LD_EXP 118
53538: PUSH
53539: LD_VAR 0 2
53543: ARRAY
53544: PUSH
53545: LD_VAR 0 3
53549: ARRAY
53550: PUSH
53551: LD_INT 3
53553: ARRAY
53554: PPUSH
53555: CALL_OW 488
53559: IFFALSE 53613
53561: PUSH
53562: LD_EXP 118
53566: PUSH
53567: LD_VAR 0 2
53571: ARRAY
53572: PUSH
53573: LD_VAR 0 3
53577: ARRAY
53578: PUSH
53579: LD_INT 2
53581: ARRAY
53582: PPUSH
53583: LD_EXP 118
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: PUSH
53594: LD_VAR 0 3
53598: ARRAY
53599: PUSH
53600: LD_INT 3
53602: ARRAY
53603: PPUSH
53604: CALL_OW 284
53608: PUSH
53609: LD_INT 0
53611: EQUAL
53612: AND
53613: IFFALSE 53668
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: LD_EXP 118
53624: PUSH
53625: LD_VAR 0 2
53629: ARRAY
53630: PPUSH
53631: LD_VAR 0 3
53635: PPUSH
53636: CALL_OW 3
53640: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53641: LD_ADDR_EXP 118
53645: PUSH
53646: LD_EXP 118
53650: PPUSH
53651: LD_VAR 0 2
53655: PPUSH
53656: LD_VAR 0 5
53660: PPUSH
53661: CALL_OW 1
53665: ST_TO_ADDR
// continue ;
53666: GO 53510
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53668: LD_VAR 0 6
53672: PPUSH
53673: LD_EXP 118
53677: PUSH
53678: LD_VAR 0 2
53682: ARRAY
53683: PUSH
53684: LD_VAR 0 3
53688: ARRAY
53689: PUSH
53690: LD_INT 2
53692: ARRAY
53693: PPUSH
53694: LD_EXP 118
53698: PUSH
53699: LD_VAR 0 2
53703: ARRAY
53704: PUSH
53705: LD_VAR 0 3
53709: ARRAY
53710: PUSH
53711: LD_INT 3
53713: ARRAY
53714: PPUSH
53715: LD_INT 30
53717: PPUSH
53718: CALL 77293 0 4
53722: PUSH
53723: LD_INT 4
53725: ARRAY
53726: PUSH
53727: LD_INT 0
53729: EQUAL
53730: IFFALSE 53756
// begin target := mc_crates [ i ] [ j ] ;
53732: LD_ADDR_VAR 0 7
53736: PUSH
53737: LD_EXP 118
53741: PUSH
53742: LD_VAR 0 2
53746: ARRAY
53747: PUSH
53748: LD_VAR 0 3
53752: ARRAY
53753: ST_TO_ADDR
// break ;
53754: GO 53758
// end ; end ;
53756: GO 53510
53758: POP
53759: POP
// if not target then
53760: LD_VAR 0 7
53764: NOT
53765: IFFALSE 53769
// continue ;
53767: GO 53313
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53769: LD_ADDR_VAR 0 8
53773: PUSH
53774: LD_EXP 121
53778: PUSH
53779: LD_VAR 0 2
53783: ARRAY
53784: PPUSH
53785: LD_INT 2
53787: PUSH
53788: LD_INT 3
53790: PUSH
53791: LD_INT 58
53793: PUSH
53794: EMPTY
53795: LIST
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 61
53803: PUSH
53804: EMPTY
53805: LIST
53806: PUSH
53807: LD_INT 33
53809: PUSH
53810: LD_INT 5
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PUSH
53817: LD_INT 33
53819: PUSH
53820: LD_INT 3
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: LIST
53833: PUSH
53834: LD_INT 2
53836: PUSH
53837: LD_INT 34
53839: PUSH
53840: LD_INT 32
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: PUSH
53847: LD_INT 34
53849: PUSH
53850: LD_INT 51
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: PUSH
53857: LD_INT 34
53859: PUSH
53860: LD_INT 12
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PPUSH
53877: CALL_OW 72
53881: ST_TO_ADDR
// if not cargo then
53882: LD_VAR 0 8
53886: NOT
53887: IFFALSE 54601
// begin if mc_crates_collector [ i ] < 5 then
53889: LD_EXP 119
53893: PUSH
53894: LD_VAR 0 2
53898: ARRAY
53899: PUSH
53900: LD_INT 5
53902: LESS
53903: IFFALSE 54273
// begin if mc_ape [ i ] then
53905: LD_EXP 131
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: IFFALSE 53962
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53917: LD_ADDR_VAR 0 5
53921: PUSH
53922: LD_EXP 131
53926: PUSH
53927: LD_VAR 0 2
53931: ARRAY
53932: PPUSH
53933: LD_INT 25
53935: PUSH
53936: LD_INT 16
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PUSH
53943: LD_INT 24
53945: PUSH
53946: LD_INT 750
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PPUSH
53957: CALL_OW 72
53961: ST_TO_ADDR
// if not tmp then
53962: LD_VAR 0 5
53966: NOT
53967: IFFALSE 54014
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53969: LD_ADDR_VAR 0 5
53973: PUSH
53974: LD_EXP 102
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 25
53987: PUSH
53988: LD_INT 2
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PUSH
53995: LD_INT 24
53997: PUSH
53998: LD_INT 750
54000: PUSH
54001: EMPTY
54002: LIST
54003: LIST
54004: PUSH
54005: EMPTY
54006: LIST
54007: LIST
54008: PPUSH
54009: CALL_OW 72
54013: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
54014: LD_EXP 131
54018: PUSH
54019: LD_VAR 0 2
54023: ARRAY
54024: IFFALSE 54067
54026: PUSH
54027: LD_EXP 102
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PPUSH
54038: LD_INT 25
54040: PUSH
54041: LD_INT 2
54043: PUSH
54044: EMPTY
54045: LIST
54046: LIST
54047: PUSH
54048: LD_INT 24
54050: PUSH
54051: LD_INT 750
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: PUSH
54058: EMPTY
54059: LIST
54060: LIST
54061: PPUSH
54062: CALL_OW 72
54066: AND
54067: IFFALSE 54079
54069: PUSH
54070: LD_VAR 0 5
54074: PUSH
54075: LD_INT 5
54077: LESS
54078: AND
54079: IFFALSE 54161
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
54081: LD_ADDR_VAR 0 3
54085: PUSH
54086: LD_EXP 102
54090: PUSH
54091: LD_VAR 0 2
54095: ARRAY
54096: PPUSH
54097: LD_INT 25
54099: PUSH
54100: LD_INT 2
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: LD_INT 24
54109: PUSH
54110: LD_INT 750
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PPUSH
54121: CALL_OW 72
54125: PUSH
54126: FOR_IN
54127: IFFALSE 54159
// begin tmp := tmp union j ;
54129: LD_ADDR_VAR 0 5
54133: PUSH
54134: LD_VAR 0 5
54138: PUSH
54139: LD_VAR 0 3
54143: UNION
54144: ST_TO_ADDR
// if tmp >= 5 then
54145: LD_VAR 0 5
54149: PUSH
54150: LD_INT 5
54152: GREATEREQUAL
54153: IFFALSE 54157
// break ;
54155: GO 54159
// end ;
54157: GO 54126
54159: POP
54160: POP
// end ; if not tmp then
54161: LD_VAR 0 5
54165: NOT
54166: IFFALSE 54170
// continue ;
54168: GO 53313
// for j in tmp do
54170: LD_ADDR_VAR 0 3
54174: PUSH
54175: LD_VAR 0 5
54179: PUSH
54180: FOR_IN
54181: IFFALSE 54271
// if not GetTag ( j ) then
54183: LD_VAR 0 3
54187: PPUSH
54188: CALL_OW 110
54192: NOT
54193: IFFALSE 54269
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
54195: LD_ADDR_EXP 119
54199: PUSH
54200: LD_EXP 119
54204: PPUSH
54205: LD_VAR 0 2
54209: PUSH
54210: LD_EXP 119
54214: PUSH
54215: LD_VAR 0 2
54219: ARRAY
54220: PUSH
54221: LD_INT 1
54223: PLUS
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: LD_VAR 0 3
54233: PPUSH
54234: CALL 76023 0 3
54238: ST_TO_ADDR
// SetTag ( j , 107 ) ;
54239: LD_VAR 0 3
54243: PPUSH
54244: LD_INT 107
54246: PPUSH
54247: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
54251: LD_EXP 119
54255: PUSH
54256: LD_VAR 0 2
54260: ARRAY
54261: PUSH
54262: LD_INT 5
54264: GREATEREQUAL
54265: IFFALSE 54269
// break ;
54267: GO 54271
// end ;
54269: GO 54180
54271: POP
54272: POP
// end ; if mc_crates_collector [ i ] and target then
54273: LD_EXP 119
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: IFFALSE 54291
54285: PUSH
54286: LD_VAR 0 7
54290: AND
54291: IFFALSE 54599
// begin if mc_crates_collector [ i ] < target [ 1 ] then
54293: LD_EXP 119
54297: PUSH
54298: LD_VAR 0 2
54302: ARRAY
54303: PUSH
54304: LD_VAR 0 7
54308: PUSH
54309: LD_INT 1
54311: ARRAY
54312: LESS
54313: IFFALSE 54333
// tmp := mc_crates_collector [ i ] else
54315: LD_ADDR_VAR 0 5
54319: PUSH
54320: LD_EXP 119
54324: PUSH
54325: LD_VAR 0 2
54329: ARRAY
54330: ST_TO_ADDR
54331: GO 54347
// tmp := target [ 1 ] ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: LD_VAR 0 7
54342: PUSH
54343: LD_INT 1
54345: ARRAY
54346: ST_TO_ADDR
// k := 0 ;
54347: LD_ADDR_VAR 0 4
54351: PUSH
54352: LD_INT 0
54354: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
54355: LD_ADDR_VAR 0 3
54359: PUSH
54360: LD_EXP 119
54364: PUSH
54365: LD_VAR 0 2
54369: ARRAY
54370: PUSH
54371: FOR_IN
54372: IFFALSE 54597
// begin k := k + 1 ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 4
54383: PUSH
54384: LD_INT 1
54386: PLUS
54387: ST_TO_ADDR
// if k > tmp then
54388: LD_VAR 0 4
54392: PUSH
54393: LD_VAR 0 5
54397: GREATER
54398: IFFALSE 54402
// break ;
54400: GO 54597
// if not GetClass ( j ) in [ 2 , 16 ] then
54402: LD_VAR 0 3
54406: PPUSH
54407: CALL_OW 257
54411: PUSH
54412: LD_INT 2
54414: PUSH
54415: LD_INT 16
54417: PUSH
54418: EMPTY
54419: LIST
54420: LIST
54421: IN
54422: NOT
54423: IFFALSE 54476
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54425: LD_ADDR_EXP 119
54429: PUSH
54430: LD_EXP 119
54434: PPUSH
54435: LD_VAR 0 2
54439: PPUSH
54440: LD_EXP 119
54444: PUSH
54445: LD_VAR 0 2
54449: ARRAY
54450: PUSH
54451: LD_VAR 0 3
54455: DIFF
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54462: LD_VAR 0 3
54466: PPUSH
54467: LD_INT 0
54469: PPUSH
54470: CALL_OW 109
// continue ;
54474: GO 54371
// end ; if IsInUnit ( j ) then
54476: LD_VAR 0 3
54480: PPUSH
54481: CALL_OW 310
54485: IFFALSE 54496
// ComExitBuilding ( j ) ;
54487: LD_VAR 0 3
54491: PPUSH
54492: CALL_OW 122
// wait ( 3 ) ;
54496: LD_INT 3
54498: PPUSH
54499: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54503: LD_VAR 0 3
54507: PPUSH
54508: CALL_OW 314
54512: IFFALSE 54550
54514: PUSH
54515: LD_VAR 0 6
54519: PPUSH
54520: LD_VAR 0 7
54524: PUSH
54525: LD_INT 2
54527: ARRAY
54528: PPUSH
54529: LD_VAR 0 7
54533: PUSH
54534: LD_INT 3
54536: ARRAY
54537: PPUSH
54538: LD_INT 30
54540: PPUSH
54541: CALL 77293 0 4
54545: PUSH
54546: LD_INT 4
54548: ARRAY
54549: AND
54550: IFFALSE 54568
// ComStandNearbyBuilding ( j , depot ) else
54552: LD_VAR 0 3
54556: PPUSH
54557: LD_VAR 0 9
54561: PPUSH
54562: CALL 72599 0 2
54566: GO 54595
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54568: LD_VAR 0 3
54572: PPUSH
54573: LD_VAR 0 7
54577: PUSH
54578: LD_INT 2
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 7
54586: PUSH
54587: LD_INT 3
54589: ARRAY
54590: PPUSH
54591: CALL_OW 117
// end ;
54595: GO 54371
54597: POP
54598: POP
// end ; end else
54599: GO 55141
// begin for j in cargo do
54601: LD_ADDR_VAR 0 3
54605: PUSH
54606: LD_VAR 0 8
54610: PUSH
54611: FOR_IN
54612: IFFALSE 55139
// begin if GetTag ( j ) <> 0 then
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 110
54623: PUSH
54624: LD_INT 0
54626: NONEQUAL
54627: IFFALSE 54631
// continue ;
54629: GO 54611
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54631: LD_VAR 0 3
54635: PPUSH
54636: CALL_OW 256
54640: PUSH
54641: LD_INT 1000
54643: LESS
54644: IFFALSE 54669
54646: PUSH
54647: LD_VAR 0 3
54651: PPUSH
54652: LD_EXP 126
54656: PUSH
54657: LD_VAR 0 2
54661: ARRAY
54662: PPUSH
54663: CALL_OW 308
54667: NOT
54668: AND
54669: IFFALSE 54691
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54671: LD_VAR 0 3
54675: PPUSH
54676: LD_EXP 126
54680: PUSH
54681: LD_VAR 0 2
54685: ARRAY
54686: PPUSH
54687: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54691: LD_VAR 0 3
54695: PPUSH
54696: CALL_OW 256
54700: PUSH
54701: LD_INT 1000
54703: LESS
54704: IFFALSE 54728
54706: PUSH
54707: LD_VAR 0 3
54711: PPUSH
54712: LD_EXP 126
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PPUSH
54723: CALL_OW 308
54727: AND
54728: IFFALSE 54732
// continue ;
54730: GO 54611
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54732: LD_VAR 0 3
54736: PPUSH
54737: CALL_OW 262
54741: PUSH
54742: LD_INT 2
54744: EQUAL
54745: IFFALSE 54762
54747: PUSH
54748: LD_VAR 0 3
54752: PPUSH
54753: CALL_OW 261
54757: PUSH
54758: LD_INT 15
54760: LESS
54761: AND
54762: IFFALSE 54766
// continue ;
54764: GO 54611
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54766: LD_VAR 0 3
54770: PPUSH
54771: CALL_OW 262
54775: PUSH
54776: LD_INT 1
54778: EQUAL
54779: IFFALSE 54796
54781: PUSH
54782: LD_VAR 0 3
54786: PPUSH
54787: CALL_OW 261
54791: PUSH
54792: LD_INT 10
54794: LESS
54795: AND
54796: IFFALSE 55076
// begin if not depot then
54798: LD_VAR 0 9
54802: NOT
54803: IFFALSE 54807
// continue ;
54805: GO 54611
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54807: LD_VAR 0 3
54811: PPUSH
54812: LD_VAR 0 9
54816: PPUSH
54817: LD_VAR 0 3
54821: PPUSH
54822: CALL_OW 74
54826: PPUSH
54827: CALL_OW 296
54831: PUSH
54832: LD_INT 6
54834: LESS
54835: IFFALSE 54851
// SetFuel ( j , 100 ) else
54837: LD_VAR 0 3
54841: PPUSH
54842: LD_INT 100
54844: PPUSH
54845: CALL_OW 240
54849: GO 55076
// if GetFuel ( j ) = 0 then
54851: LD_VAR 0 3
54855: PPUSH
54856: CALL_OW 261
54860: PUSH
54861: LD_INT 0
54863: EQUAL
54864: IFFALSE 55076
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54866: LD_ADDR_EXP 121
54870: PUSH
54871: LD_EXP 121
54875: PPUSH
54876: LD_VAR 0 2
54880: PPUSH
54881: LD_EXP 121
54885: PUSH
54886: LD_VAR 0 2
54890: ARRAY
54891: PUSH
54892: LD_VAR 0 3
54896: DIFF
54897: PPUSH
54898: CALL_OW 1
54902: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54903: LD_VAR 0 3
54907: PPUSH
54908: CALL_OW 263
54912: PUSH
54913: LD_INT 1
54915: EQUAL
54916: IFFALSE 54932
// ComExitVehicle ( IsInUnit ( j ) ) ;
54918: LD_VAR 0 3
54922: PPUSH
54923: CALL_OW 310
54927: PPUSH
54928: CALL_OW 121
// if GetControl ( j ) = control_remote then
54932: LD_VAR 0 3
54936: PPUSH
54937: CALL_OW 263
54941: PUSH
54942: LD_INT 2
54944: EQUAL
54945: IFFALSE 54956
// ComUnlink ( j ) ;
54947: LD_VAR 0 3
54951: PPUSH
54952: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54956: LD_ADDR_VAR 0 10
54960: PUSH
54961: LD_VAR 0 2
54965: PPUSH
54966: LD_INT 3
54968: PPUSH
54969: CALL 64870 0 2
54973: ST_TO_ADDR
// if fac then
54974: LD_VAR 0 10
54978: IFFALSE 55074
// begin for k in fac do
54980: LD_ADDR_VAR 0 4
54984: PUSH
54985: LD_VAR 0 10
54989: PUSH
54990: FOR_IN
54991: IFFALSE 55072
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54993: LD_ADDR_VAR 0 11
54997: PUSH
54998: LD_VAR 0 10
55002: PPUSH
55003: LD_VAR 0 3
55007: PPUSH
55008: CALL_OW 265
55012: PPUSH
55013: LD_VAR 0 3
55017: PPUSH
55018: CALL_OW 262
55022: PPUSH
55023: LD_VAR 0 3
55027: PPUSH
55028: CALL_OW 263
55032: PPUSH
55033: LD_VAR 0 3
55037: PPUSH
55038: CALL_OW 264
55042: PPUSH
55043: CALL 73497 0 5
55047: ST_TO_ADDR
// if components then
55048: LD_VAR 0 11
55052: IFFALSE 55070
// begin MC_InsertProduceList ( i , components ) ;
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 11
55063: PPUSH
55064: CALL 64415 0 2
// break ;
55068: GO 55072
// end ; end ;
55070: GO 54990
55072: POP
55073: POP
// end ; continue ;
55074: GO 54611
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
55076: LD_VAR 0 3
55080: PPUSH
55081: LD_INT 1
55083: PPUSH
55084: CALL_OW 289
55088: PUSH
55089: LD_INT 100
55091: LESS
55092: IFFALSE 55106
55094: PUSH
55095: LD_VAR 0 3
55099: PPUSH
55100: CALL_OW 314
55104: NOT
55105: AND
55106: IFFALSE 55135
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55108: LD_VAR 0 3
55112: PPUSH
55113: LD_VAR 0 7
55117: PUSH
55118: LD_INT 2
55120: ARRAY
55121: PPUSH
55122: LD_VAR 0 7
55126: PUSH
55127: LD_INT 3
55129: ARRAY
55130: PPUSH
55131: CALL_OW 117
// break ;
55135: GO 55139
// end ;
55137: GO 54611
55139: POP
55140: POP
// end ; end ;
55141: GO 53313
55143: POP
55144: POP
// end ;
55145: LD_VAR 0 1
55149: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
55150: LD_INT 0
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
// if not mc_bases then
55156: LD_EXP 102
55160: NOT
55161: IFFALSE 55165
// exit ;
55163: GO 55330
// for i = 1 to mc_bases do
55165: LD_ADDR_VAR 0 2
55169: PUSH
55170: DOUBLE
55171: LD_INT 1
55173: DEC
55174: ST_TO_ADDR
55175: LD_EXP 102
55179: PUSH
55180: FOR_TO
55181: IFFALSE 55328
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
55183: LD_ADDR_VAR 0 4
55187: PUSH
55188: LD_EXP 121
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PUSH
55199: LD_EXP 124
55203: PUSH
55204: LD_VAR 0 2
55208: ARRAY
55209: UNION
55210: PPUSH
55211: LD_INT 33
55213: PUSH
55214: LD_INT 2
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: PPUSH
55221: CALL_OW 72
55225: ST_TO_ADDR
// if tmp then
55226: LD_VAR 0 4
55230: IFFALSE 55326
// for j in tmp do
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_VAR 0 4
55241: PUSH
55242: FOR_IN
55243: IFFALSE 55324
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
55245: LD_VAR 0 3
55249: PPUSH
55250: CALL_OW 312
55254: NOT
55255: IFFALSE 55272
55257: PUSH
55258: LD_VAR 0 3
55262: PPUSH
55263: CALL_OW 256
55267: PUSH
55268: LD_INT 250
55270: GREATEREQUAL
55271: AND
55272: IFFALSE 55285
// Connect ( j ) else
55274: LD_VAR 0 3
55278: PPUSH
55279: CALL 79383 0 1
55283: GO 55322
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
55285: LD_VAR 0 3
55289: PPUSH
55290: CALL_OW 256
55294: PUSH
55295: LD_INT 250
55297: LESS
55298: IFFALSE 55311
55300: PUSH
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 312
55310: AND
55311: IFFALSE 55322
// ComUnlink ( j ) ;
55313: LD_VAR 0 3
55317: PPUSH
55318: CALL_OW 136
55322: GO 55242
55324: POP
55325: POP
// end ;
55326: GO 55180
55328: POP
55329: POP
// end ;
55330: LD_VAR 0 1
55334: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
55335: LD_INT 0
55337: PPUSH
55338: PPUSH
55339: PPUSH
55340: PPUSH
55341: PPUSH
// if not mc_bases then
55342: LD_EXP 102
55346: NOT
55347: IFFALSE 55351
// exit ;
55349: GO 55800
// for i = 1 to mc_bases do
55351: LD_ADDR_VAR 0 2
55355: PUSH
55356: DOUBLE
55357: LD_INT 1
55359: DEC
55360: ST_TO_ADDR
55361: LD_EXP 102
55365: PUSH
55366: FOR_TO
55367: IFFALSE 55798
// begin if not mc_produce [ i ] then
55369: LD_EXP 123
55373: PUSH
55374: LD_VAR 0 2
55378: ARRAY
55379: NOT
55380: IFFALSE 55384
// continue ;
55382: GO 55366
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55384: LD_ADDR_VAR 0 5
55388: PUSH
55389: LD_EXP 102
55393: PUSH
55394: LD_VAR 0 2
55398: ARRAY
55399: PPUSH
55400: LD_INT 30
55402: PUSH
55403: LD_INT 3
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PPUSH
55410: CALL_OW 72
55414: ST_TO_ADDR
// if not fac then
55415: LD_VAR 0 5
55419: NOT
55420: IFFALSE 55424
// continue ;
55422: GO 55366
// for j in fac do
55424: LD_ADDR_VAR 0 3
55428: PUSH
55429: LD_VAR 0 5
55433: PUSH
55434: FOR_IN
55435: IFFALSE 55794
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55437: LD_VAR 0 3
55441: PPUSH
55442: CALL_OW 461
55446: PUSH
55447: LD_INT 2
55449: NONEQUAL
55450: IFTRUE 55470
55452: PUSH
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_INT 15
55460: PPUSH
55461: CALL 79002 0 2
55465: PUSH
55466: LD_INT 4
55468: ARRAY
55469: OR
55470: IFFALSE 55474
// continue ;
55472: GO 55434
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55474: LD_VAR 0 3
55478: PPUSH
55479: LD_EXP 123
55483: PUSH
55484: LD_VAR 0 2
55488: ARRAY
55489: PUSH
55490: LD_INT 1
55492: ARRAY
55493: PUSH
55494: LD_INT 1
55496: ARRAY
55497: PPUSH
55498: LD_EXP 123
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: PUSH
55509: LD_INT 1
55511: ARRAY
55512: PUSH
55513: LD_INT 2
55515: ARRAY
55516: PPUSH
55517: LD_EXP 123
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PUSH
55528: LD_INT 1
55530: ARRAY
55531: PUSH
55532: LD_INT 3
55534: ARRAY
55535: PPUSH
55536: LD_EXP 123
55540: PUSH
55541: LD_VAR 0 2
55545: ARRAY
55546: PUSH
55547: LD_INT 1
55549: ARRAY
55550: PUSH
55551: LD_INT 4
55553: ARRAY
55554: PPUSH
55555: CALL_OW 448
55559: IFFALSE 55654
55561: PUSH
55562: LD_VAR 0 3
55566: PPUSH
55567: LD_EXP 123
55571: PUSH
55572: LD_VAR 0 2
55576: ARRAY
55577: PUSH
55578: LD_INT 1
55580: ARRAY
55581: PUSH
55582: LD_INT 1
55584: ARRAY
55585: PUSH
55586: LD_EXP 123
55590: PUSH
55591: LD_VAR 0 2
55595: ARRAY
55596: PUSH
55597: LD_INT 1
55599: ARRAY
55600: PUSH
55601: LD_INT 2
55603: ARRAY
55604: PUSH
55605: LD_EXP 123
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: PUSH
55616: LD_INT 1
55618: ARRAY
55619: PUSH
55620: LD_INT 3
55622: ARRAY
55623: PUSH
55624: LD_EXP 123
55628: PUSH
55629: LD_VAR 0 2
55633: ARRAY
55634: PUSH
55635: LD_INT 1
55637: ARRAY
55638: PUSH
55639: LD_INT 4
55641: ARRAY
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL 82816 0 2
55653: AND
55654: IFFALSE 55792
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55656: LD_VAR 0 3
55660: PPUSH
55661: LD_EXP 123
55665: PUSH
55666: LD_VAR 0 2
55670: ARRAY
55671: PUSH
55672: LD_INT 1
55674: ARRAY
55675: PUSH
55676: LD_INT 1
55678: ARRAY
55679: PPUSH
55680: LD_EXP 123
55684: PUSH
55685: LD_VAR 0 2
55689: ARRAY
55690: PUSH
55691: LD_INT 1
55693: ARRAY
55694: PUSH
55695: LD_INT 2
55697: ARRAY
55698: PPUSH
55699: LD_EXP 123
55703: PUSH
55704: LD_VAR 0 2
55708: ARRAY
55709: PUSH
55710: LD_INT 1
55712: ARRAY
55713: PUSH
55714: LD_INT 3
55716: ARRAY
55717: PPUSH
55718: LD_EXP 123
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: ARRAY
55732: PUSH
55733: LD_INT 4
55735: ARRAY
55736: PPUSH
55737: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55741: LD_ADDR_VAR 0 4
55745: PUSH
55746: LD_EXP 123
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 1
55759: PPUSH
55760: CALL_OW 3
55764: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55765: LD_ADDR_EXP 123
55769: PUSH
55770: LD_EXP 123
55774: PPUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_VAR 0 4
55784: PPUSH
55785: CALL_OW 1
55789: ST_TO_ADDR
// break ;
55790: GO 55794
// end ; end ;
55792: GO 55434
55794: POP
55795: POP
// end ;
55796: GO 55366
55798: POP
55799: POP
// end ;
55800: LD_VAR 0 1
55804: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55805: LD_INT 0
55807: PPUSH
55808: PPUSH
55809: PPUSH
// if not mc_bases then
55810: LD_EXP 102
55814: NOT
55815: IFFALSE 55819
// exit ;
55817: GO 55908
// for i = 1 to mc_bases do
55819: LD_ADDR_VAR 0 2
55823: PUSH
55824: DOUBLE
55825: LD_INT 1
55827: DEC
55828: ST_TO_ADDR
55829: LD_EXP 102
55833: PUSH
55834: FOR_TO
55835: IFFALSE 55906
// begin if mc_attack [ i ] then
55837: LD_EXP 122
55841: PUSH
55842: LD_VAR 0 2
55846: ARRAY
55847: IFFALSE 55904
// begin tmp := mc_attack [ i ] [ 1 ] ;
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: LD_EXP 122
55858: PUSH
55859: LD_VAR 0 2
55863: ARRAY
55864: PUSH
55865: LD_INT 1
55867: ARRAY
55868: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55869: LD_ADDR_EXP 122
55873: PUSH
55874: LD_EXP 122
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// Attack ( tmp ) ;
55891: LD_VAR 0 3
55895: PPUSH
55896: CALL 135844 0 1
// exit ;
55900: POP
55901: POP
55902: GO 55908
// end ; end ;
55904: GO 55834
55906: POP
55907: POP
// end ;
55908: LD_VAR 0 1
55912: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55913: LD_INT 0
55915: PPUSH
55916: PPUSH
55917: PPUSH
55918: PPUSH
55919: PPUSH
55920: PPUSH
55921: PPUSH
// if not mc_bases then
55922: LD_EXP 102
55926: NOT
55927: IFFALSE 55931
// exit ;
55929: GO 56808
// for i = 1 to mc_bases do
55931: LD_ADDR_VAR 0 2
55935: PUSH
55936: DOUBLE
55937: LD_INT 1
55939: DEC
55940: ST_TO_ADDR
55941: LD_EXP 102
55945: PUSH
55946: FOR_TO
55947: IFFALSE 56806
// begin if not mc_bases [ i ] then
55949: LD_EXP 102
55953: PUSH
55954: LD_VAR 0 2
55958: ARRAY
55959: NOT
55960: IFFALSE 55964
// continue ;
55962: GO 55946
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55964: LD_ADDR_VAR 0 7
55968: PUSH
55969: LD_EXP 102
55973: PUSH
55974: LD_VAR 0 2
55978: ARRAY
55979: PUSH
55980: LD_INT 1
55982: ARRAY
55983: PPUSH
55984: CALL 72823 0 1
55988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55989: LD_ADDR_EXP 125
55993: PUSH
55994: LD_EXP 125
55998: PPUSH
55999: LD_VAR 0 2
56003: PPUSH
56004: LD_EXP 102
56008: PUSH
56009: LD_VAR 0 2
56013: ARRAY
56014: PUSH
56015: LD_INT 1
56017: ARRAY
56018: PPUSH
56019: CALL_OW 255
56023: PPUSH
56024: LD_EXP 127
56028: PUSH
56029: LD_VAR 0 2
56033: ARRAY
56034: PPUSH
56035: CALL 72788 0 2
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// if not mc_scan [ i ] then
56045: LD_EXP 125
56049: PUSH
56050: LD_VAR 0 2
56054: ARRAY
56055: NOT
56056: IFFALSE 56240
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56058: LD_ADDR_EXP 145
56062: PUSH
56063: LD_EXP 145
56067: PPUSH
56068: LD_VAR 0 2
56072: PPUSH
56073: LD_INT 0
56075: PPUSH
56076: CALL_OW 1
56080: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56081: LD_ADDR_VAR 0 4
56085: PUSH
56086: LD_EXP 102
56090: PUSH
56091: LD_VAR 0 2
56095: ARRAY
56096: PPUSH
56097: LD_INT 2
56099: PUSH
56100: LD_INT 25
56102: PUSH
56103: LD_INT 5
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: LD_INT 25
56112: PUSH
56113: LD_INT 8
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 25
56122: PUSH
56123: LD_INT 9
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: LIST
56134: LIST
56135: PPUSH
56136: CALL_OW 72
56140: ST_TO_ADDR
// if not tmp then
56141: LD_VAR 0 4
56145: NOT
56146: IFFALSE 56150
// continue ;
56148: GO 55946
// for j in tmp do
56150: LD_ADDR_VAR 0 3
56154: PUSH
56155: LD_VAR 0 4
56159: PUSH
56160: FOR_IN
56161: IFFALSE 56238
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
56163: LD_VAR 0 3
56167: PPUSH
56168: CALL_OW 310
56172: PPUSH
56173: CALL_OW 266
56177: PUSH
56178: LD_INT 5
56180: EQUAL
56181: IFFALSE 56198
56183: PUSH
56184: LD_VAR 0 3
56188: PPUSH
56189: CALL_OW 257
56193: PUSH
56194: LD_INT 1
56196: EQUAL
56197: AND
56198: IFFALSE 56212
56200: PUSH
56201: LD_VAR 0 3
56205: PPUSH
56206: CALL_OW 459
56210: NOT
56211: AND
56212: IFFALSE 56220
56214: PUSH
56215: LD_VAR 0 7
56219: AND
56220: IFFALSE 56236
// ComChangeProfession ( j , class ) ;
56222: LD_VAR 0 3
56226: PPUSH
56227: LD_VAR 0 7
56231: PPUSH
56232: CALL_OW 123
56236: GO 56160
56238: POP
56239: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
56240: LD_EXP 125
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: IFFALSE 56265
56252: PUSH
56253: LD_EXP 145
56257: PUSH
56258: LD_VAR 0 2
56262: ARRAY
56263: NOT
56264: AND
56265: IFFALSE 56280
56267: PUSH
56268: LD_EXP 124
56272: PUSH
56273: LD_VAR 0 2
56277: ARRAY
56278: NOT
56279: AND
56280: IFFALSE 56431
56282: PUSH
56283: LD_EXP 102
56287: PUSH
56288: LD_VAR 0 2
56292: ARRAY
56293: PPUSH
56294: LD_INT 50
56296: PUSH
56297: EMPTY
56298: LIST
56299: PUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 30
56305: PUSH
56306: LD_INT 32
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 30
56315: PUSH
56316: LD_INT 33
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 30
56325: PUSH
56326: LD_INT 4
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 30
56335: PUSH
56336: LD_INT 5
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: LIST
56347: LIST
56348: LIST
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PPUSH
56354: CALL_OW 72
56358: PUSH
56359: LD_INT 4
56361: LESS
56362: IFTRUE 56430
56364: PUSH
56365: LD_EXP 102
56369: PUSH
56370: LD_VAR 0 2
56374: ARRAY
56375: PPUSH
56376: LD_INT 3
56378: PUSH
56379: LD_INT 24
56381: PUSH
56382: LD_INT 1000
56384: PUSH
56385: EMPTY
56386: LIST
56387: LIST
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PUSH
56393: LD_INT 2
56395: PUSH
56396: LD_INT 30
56398: PUSH
56399: LD_INT 0
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: LD_INT 30
56408: PUSH
56409: LD_INT 1
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: LIST
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: PPUSH
56425: CALL_OW 72
56429: OR
56430: AND
56431: IFFALSE 56684
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56433: LD_ADDR_EXP 145
56437: PUSH
56438: LD_EXP 145
56442: PPUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: LD_INT 1
56450: PPUSH
56451: CALL_OW 1
56455: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56456: LD_ADDR_VAR 0 4
56460: PUSH
56461: LD_EXP 102
56465: PUSH
56466: LD_VAR 0 2
56470: ARRAY
56471: PPUSH
56472: LD_INT 2
56474: PUSH
56475: LD_INT 25
56477: PUSH
56478: LD_INT 1
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: PUSH
56485: LD_INT 25
56487: PUSH
56488: LD_INT 5
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: PUSH
56495: LD_INT 25
56497: PUSH
56498: LD_INT 8
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: PUSH
56505: LD_INT 25
56507: PUSH
56508: LD_INT 9
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: EMPTY
56516: LIST
56517: LIST
56518: LIST
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56527: LD_ADDR_VAR 0 4
56531: PUSH
56532: LD_VAR 0 4
56536: PUSH
56537: LD_VAR 0 4
56541: PPUSH
56542: LD_INT 18
56544: PPUSH
56545: CALL 106616 0 2
56549: DIFF
56550: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56551: LD_VAR 0 4
56555: NOT
56556: IFFALSE 56604
56558: PUSH
56559: LD_EXP 102
56563: PUSH
56564: LD_VAR 0 2
56568: ARRAY
56569: PPUSH
56570: LD_INT 2
56572: PUSH
56573: LD_INT 30
56575: PUSH
56576: LD_INT 4
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: LD_INT 30
56585: PUSH
56586: LD_INT 5
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: PUSH
56593: EMPTY
56594: LIST
56595: LIST
56596: LIST
56597: PPUSH
56598: CALL_OW 72
56602: NOT
56603: AND
56604: IFFALSE 56666
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56606: LD_ADDR_VAR 0 4
56610: PUSH
56611: LD_EXP 102
56615: PUSH
56616: LD_VAR 0 2
56620: ARRAY
56621: PPUSH
56622: LD_INT 2
56624: PUSH
56625: LD_INT 25
56627: PUSH
56628: LD_INT 2
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: PUSH
56635: LD_INT 25
56637: PUSH
56638: LD_INT 3
56640: PUSH
56641: EMPTY
56642: LIST
56643: LIST
56644: PUSH
56645: LD_INT 25
56647: PUSH
56648: LD_INT 4
56650: PUSH
56651: EMPTY
56652: LIST
56653: LIST
56654: PUSH
56655: EMPTY
56656: LIST
56657: LIST
56658: LIST
56659: LIST
56660: PPUSH
56661: CALL_OW 72
56665: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56666: LD_VAR 0 2
56670: PPUSH
56671: LD_VAR 0 4
56675: PPUSH
56676: CALL 140613 0 2
// exit ;
56680: POP
56681: POP
56682: GO 56808
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56684: LD_EXP 125
56688: PUSH
56689: LD_VAR 0 2
56693: ARRAY
56694: IFFALSE 56709
56696: PUSH
56697: LD_EXP 145
56701: PUSH
56702: LD_VAR 0 2
56706: ARRAY
56707: NOT
56708: AND
56709: IFFALSE 56723
56711: PUSH
56712: LD_EXP 124
56716: PUSH
56717: LD_VAR 0 2
56721: ARRAY
56722: AND
56723: IFFALSE 56804
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56725: LD_ADDR_EXP 145
56729: PUSH
56730: LD_EXP 145
56734: PPUSH
56735: LD_VAR 0 2
56739: PPUSH
56740: LD_INT 1
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56748: LD_ADDR_VAR 0 4
56752: PUSH
56753: LD_EXP 124
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56764: LD_ADDR_EXP 124
56768: PUSH
56769: LD_EXP 124
56773: PPUSH
56774: LD_VAR 0 2
56778: PPUSH
56779: EMPTY
56780: PPUSH
56781: CALL_OW 1
56785: ST_TO_ADDR
// Defend ( i , tmp ) ;
56786: LD_VAR 0 2
56790: PPUSH
56791: LD_VAR 0 4
56795: PPUSH
56796: CALL 141217 0 2
// exit ;
56800: POP
56801: POP
56802: GO 56808
// end ; end ;
56804: GO 55946
56806: POP
56807: POP
// end ;
56808: LD_VAR 0 1
56812: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56813: LD_INT 0
56815: PPUSH
56816: PPUSH
56817: PPUSH
56818: PPUSH
56819: PPUSH
56820: PPUSH
56821: PPUSH
56822: PPUSH
56823: PPUSH
56824: PPUSH
56825: PPUSH
// if not mc_bases then
56826: LD_EXP 102
56830: NOT
56831: IFFALSE 56835
// exit ;
56833: GO 57948
// for i = 1 to mc_bases do
56835: LD_ADDR_VAR 0 2
56839: PUSH
56840: DOUBLE
56841: LD_INT 1
56843: DEC
56844: ST_TO_ADDR
56845: LD_EXP 102
56849: PUSH
56850: FOR_TO
56851: IFFALSE 57946
// begin tmp := mc_lab [ i ] ;
56853: LD_ADDR_VAR 0 6
56857: PUSH
56858: LD_EXP 135
56862: PUSH
56863: LD_VAR 0 2
56867: ARRAY
56868: ST_TO_ADDR
// if not tmp then
56869: LD_VAR 0 6
56873: NOT
56874: IFFALSE 56878
// continue ;
56876: GO 56850
// idle_lab := 0 ;
56878: LD_ADDR_VAR 0 11
56882: PUSH
56883: LD_INT 0
56885: ST_TO_ADDR
// for j in tmp do
56886: LD_ADDR_VAR 0 3
56890: PUSH
56891: LD_VAR 0 6
56895: PUSH
56896: FOR_IN
56897: IFFALSE 57942
// begin researching := false ;
56899: LD_ADDR_VAR 0 10
56903: PUSH
56904: LD_INT 0
56906: ST_TO_ADDR
// side := GetSide ( j ) ;
56907: LD_ADDR_VAR 0 4
56911: PUSH
56912: LD_VAR 0 3
56916: PPUSH
56917: CALL_OW 255
56921: ST_TO_ADDR
// if not mc_tech [ side ] then
56922: LD_EXP 129
56926: PUSH
56927: LD_VAR 0 4
56931: ARRAY
56932: NOT
56933: IFFALSE 56937
// continue ;
56935: GO 56896
// if BuildingStatus ( j ) = bs_idle then
56937: LD_VAR 0 3
56941: PPUSH
56942: CALL_OW 461
56946: PUSH
56947: LD_INT 2
56949: EQUAL
56950: IFFALSE 57142
// begin if idle_lab and UnitsInside ( j ) < 6 then
56952: LD_VAR 0 11
56956: IFFALSE 56973
56958: PUSH
56959: LD_VAR 0 3
56963: PPUSH
56964: CALL_OW 313
56968: PUSH
56969: LD_INT 6
56971: LESS
56972: AND
56973: IFFALSE 57044
// begin tmp2 := UnitsInside ( idle_lab ) ;
56975: LD_ADDR_VAR 0 9
56979: PUSH
56980: LD_VAR 0 11
56984: PPUSH
56985: CALL_OW 313
56989: ST_TO_ADDR
// if tmp2 then
56990: LD_VAR 0 9
56994: IFFALSE 57036
// for x in tmp2 do
56996: LD_ADDR_VAR 0 7
57000: PUSH
57001: LD_VAR 0 9
57005: PUSH
57006: FOR_IN
57007: IFFALSE 57034
// begin ComExitBuilding ( x ) ;
57009: LD_VAR 0 7
57013: PPUSH
57014: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57018: LD_VAR 0 7
57022: PPUSH
57023: LD_VAR 0 3
57027: PPUSH
57028: CALL_OW 180
// end ;
57032: GO 57006
57034: POP
57035: POP
// idle_lab := 0 ;
57036: LD_ADDR_VAR 0 11
57040: PUSH
57041: LD_INT 0
57043: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
57044: LD_ADDR_VAR 0 5
57048: PUSH
57049: LD_EXP 129
57053: PUSH
57054: LD_VAR 0 4
57058: ARRAY
57059: PUSH
57060: FOR_IN
57061: IFFALSE 57123
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
57063: LD_VAR 0 3
57067: PPUSH
57068: LD_VAR 0 5
57072: PPUSH
57073: CALL_OW 430
57077: IFFALSE 57095
57079: PUSH
57080: LD_VAR 0 4
57084: PPUSH
57085: LD_VAR 0 5
57089: PPUSH
57090: CALL 71883 0 2
57094: AND
57095: IFFALSE 57121
// begin researching := true ;
57097: LD_ADDR_VAR 0 10
57101: PUSH
57102: LD_INT 1
57104: ST_TO_ADDR
// ComResearch ( j , t ) ;
57105: LD_VAR 0 3
57109: PPUSH
57110: LD_VAR 0 5
57114: PPUSH
57115: CALL_OW 124
// break ;
57119: GO 57123
// end ;
57121: GO 57060
57123: POP
57124: POP
// if not researching then
57125: LD_VAR 0 10
57129: NOT
57130: IFFALSE 57142
// idle_lab := j ;
57132: LD_ADDR_VAR 0 11
57136: PUSH
57137: LD_VAR 0 3
57141: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
57142: LD_VAR 0 3
57146: PPUSH
57147: CALL_OW 461
57151: PUSH
57152: LD_INT 10
57154: EQUAL
57155: IFFALSE 57761
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
57157: LD_EXP 131
57161: PUSH
57162: LD_VAR 0 2
57166: ARRAY
57167: NOT
57168: IFFALSE 57183
57170: PUSH
57171: LD_EXP 132
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: NOT
57182: AND
57183: IFFALSE 57201
57185: PUSH
57186: LD_EXP 129
57190: PUSH
57191: LD_VAR 0 4
57195: ARRAY
57196: PUSH
57197: LD_INT 1
57199: GREATER
57200: AND
57201: IFFALSE 57332
// begin ComCancel ( j ) ;
57203: LD_VAR 0 3
57207: PPUSH
57208: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
57212: LD_ADDR_EXP 129
57216: PUSH
57217: LD_EXP 129
57221: PPUSH
57222: LD_VAR 0 4
57226: PPUSH
57227: LD_EXP 129
57231: PUSH
57232: LD_VAR 0 4
57236: ARRAY
57237: PPUSH
57238: LD_EXP 129
57242: PUSH
57243: LD_VAR 0 4
57247: ARRAY
57248: PUSH
57249: LD_INT 1
57251: MINUS
57252: PPUSH
57253: LD_EXP 129
57257: PUSH
57258: LD_VAR 0 4
57262: ARRAY
57263: PPUSH
57264: LD_INT 0
57266: PPUSH
57267: CALL 75431 0 4
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
57277: LD_ADDR_EXP 129
57281: PUSH
57282: LD_EXP 129
57286: PPUSH
57287: LD_VAR 0 4
57291: PPUSH
57292: LD_EXP 129
57296: PUSH
57297: LD_VAR 0 4
57301: ARRAY
57302: PPUSH
57303: LD_EXP 129
57307: PUSH
57308: LD_VAR 0 4
57312: ARRAY
57313: PPUSH
57314: LD_INT 1
57316: PPUSH
57317: LD_INT 0
57319: PPUSH
57320: CALL 75431 0 4
57324: PPUSH
57325: CALL_OW 1
57329: ST_TO_ADDR
// continue ;
57330: GO 56896
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
57332: LD_EXP 131
57336: PUSH
57337: LD_VAR 0 2
57341: ARRAY
57342: IFFALSE 57357
57344: PUSH
57345: LD_EXP 132
57349: PUSH
57350: LD_VAR 0 2
57354: ARRAY
57355: NOT
57356: AND
57357: IFFALSE 57484
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
57359: LD_ADDR_EXP 132
57363: PUSH
57364: LD_EXP 132
57368: PPUSH
57369: LD_VAR 0 2
57373: PUSH
57374: LD_EXP 132
57378: PUSH
57379: LD_VAR 0 2
57383: ARRAY
57384: PUSH
57385: LD_INT 1
57387: PLUS
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PPUSH
57393: LD_EXP 131
57397: PUSH
57398: LD_VAR 0 2
57402: ARRAY
57403: PUSH
57404: LD_INT 1
57406: ARRAY
57407: PPUSH
57408: CALL 76023 0 3
57412: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
57413: LD_EXP 131
57417: PUSH
57418: LD_VAR 0 2
57422: ARRAY
57423: PUSH
57424: LD_INT 1
57426: ARRAY
57427: PPUSH
57428: LD_INT 112
57430: PPUSH
57431: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
57435: LD_ADDR_VAR 0 9
57439: PUSH
57440: LD_EXP 131
57444: PUSH
57445: LD_VAR 0 2
57449: ARRAY
57450: PPUSH
57451: LD_INT 1
57453: PPUSH
57454: CALL_OW 3
57458: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57459: LD_ADDR_EXP 131
57463: PUSH
57464: LD_EXP 131
57468: PPUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: LD_VAR 0 9
57478: PPUSH
57479: CALL_OW 1
57483: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57484: LD_EXP 131
57488: PUSH
57489: LD_VAR 0 2
57493: ARRAY
57494: IFFALSE 57508
57496: PUSH
57497: LD_EXP 132
57501: PUSH
57502: LD_VAR 0 2
57506: ARRAY
57507: AND
57508: IFFALSE 57532
57510: PUSH
57511: LD_EXP 132
57515: PUSH
57516: LD_VAR 0 2
57520: ARRAY
57521: PUSH
57522: LD_INT 1
57524: ARRAY
57525: PPUSH
57526: CALL_OW 310
57530: NOT
57531: AND
57532: IFFALSE 57549
57534: PUSH
57535: LD_VAR 0 3
57539: PPUSH
57540: CALL_OW 313
57544: PUSH
57545: LD_INT 6
57547: EQUAL
57548: AND
57549: IFFALSE 57605
// begin tmp2 := UnitsInside ( j ) ;
57551: LD_ADDR_VAR 0 9
57555: PUSH
57556: LD_VAR 0 3
57560: PPUSH
57561: CALL_OW 313
57565: ST_TO_ADDR
// if tmp2 = 6 then
57566: LD_VAR 0 9
57570: PUSH
57571: LD_INT 6
57573: EQUAL
57574: IFFALSE 57605
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57576: LD_VAR 0 9
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: PPUSH
57585: LD_INT 112
57587: PPUSH
57588: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57592: LD_VAR 0 9
57596: PUSH
57597: LD_INT 1
57599: ARRAY
57600: PPUSH
57601: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57605: LD_EXP 132
57609: PUSH
57610: LD_VAR 0 2
57614: ARRAY
57615: IFFALSE 57639
57617: PUSH
57618: LD_EXP 132
57622: PUSH
57623: LD_VAR 0 2
57627: ARRAY
57628: PUSH
57629: LD_INT 1
57631: ARRAY
57632: PPUSH
57633: CALL_OW 314
57637: NOT
57638: AND
57639: IFFALSE 57663
57641: PUSH
57642: LD_EXP 132
57646: PUSH
57647: LD_VAR 0 2
57651: ARRAY
57652: PUSH
57653: LD_INT 1
57655: ARRAY
57656: PPUSH
57657: CALL_OW 310
57661: NOT
57662: AND
57663: IFFALSE 57689
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57665: LD_EXP 132
57669: PUSH
57670: LD_VAR 0 2
57674: ARRAY
57675: PUSH
57676: LD_INT 1
57678: ARRAY
57679: PPUSH
57680: LD_VAR 0 3
57684: PPUSH
57685: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57689: LD_EXP 132
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PUSH
57700: LD_INT 1
57702: ARRAY
57703: PPUSH
57704: CALL_OW 310
57708: IFFALSE 57740
57710: PUSH
57711: LD_EXP 132
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_INT 1
57724: ARRAY
57725: PPUSH
57726: CALL_OW 310
57730: PPUSH
57731: CALL_OW 461
57735: PUSH
57736: LD_INT 3
57738: NONEQUAL
57739: AND
57740: IFFALSE 57761
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57742: LD_EXP 132
57746: PUSH
57747: LD_VAR 0 2
57751: ARRAY
57752: PUSH
57753: LD_INT 1
57755: ARRAY
57756: PPUSH
57757: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57761: LD_VAR 0 3
57765: PPUSH
57766: CALL_OW 461
57770: PUSH
57771: LD_INT 6
57773: EQUAL
57774: IFFALSE 57786
57776: PUSH
57777: LD_VAR 0 6
57781: PUSH
57782: LD_INT 1
57784: GREATER
57785: AND
57786: IFFALSE 57940
// begin sci := [ ] ;
57788: LD_ADDR_VAR 0 8
57792: PUSH
57793: EMPTY
57794: ST_TO_ADDR
// for x in ( tmp diff j ) do
57795: LD_ADDR_VAR 0 7
57799: PUSH
57800: LD_VAR 0 6
57804: PUSH
57805: LD_VAR 0 3
57809: DIFF
57810: PUSH
57811: FOR_IN
57812: IFFALSE 57864
// begin if sci = 6 then
57814: LD_VAR 0 8
57818: PUSH
57819: LD_INT 6
57821: EQUAL
57822: IFFALSE 57826
// break ;
57824: GO 57864
// if BuildingStatus ( x ) = bs_idle then
57826: LD_VAR 0 7
57830: PPUSH
57831: CALL_OW 461
57835: PUSH
57836: LD_INT 2
57838: EQUAL
57839: IFFALSE 57862
// sci := sci ^ UnitsInside ( x ) ;
57841: LD_ADDR_VAR 0 8
57845: PUSH
57846: LD_VAR 0 8
57850: PUSH
57851: LD_VAR 0 7
57855: PPUSH
57856: CALL_OW 313
57860: ADD
57861: ST_TO_ADDR
// end ;
57862: GO 57811
57864: POP
57865: POP
// if not sci then
57866: LD_VAR 0 8
57870: NOT
57871: IFFALSE 57875
// continue ;
57873: GO 56896
// for x in sci do
57875: LD_ADDR_VAR 0 7
57879: PUSH
57880: LD_VAR 0 8
57884: PUSH
57885: FOR_IN
57886: IFFALSE 57938
// if IsInUnit ( x ) and not HasTask ( x ) then
57888: LD_VAR 0 7
57892: PPUSH
57893: CALL_OW 310
57897: IFFALSE 57911
57899: PUSH
57900: LD_VAR 0 7
57904: PPUSH
57905: CALL_OW 314
57909: NOT
57910: AND
57911: IFFALSE 57936
// begin ComExitBuilding ( x ) ;
57913: LD_VAR 0 7
57917: PPUSH
57918: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57922: LD_VAR 0 7
57926: PPUSH
57927: LD_VAR 0 3
57931: PPUSH
57932: CALL_OW 180
// end ;
57936: GO 57885
57938: POP
57939: POP
// end ; end ;
57940: GO 56896
57942: POP
57943: POP
// end ;
57944: GO 56850
57946: POP
57947: POP
// end ;
57948: LD_VAR 0 1
57952: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57953: LD_INT 0
57955: PPUSH
57956: PPUSH
// if not mc_bases then
57957: LD_EXP 102
57961: NOT
57962: IFFALSE 57966
// exit ;
57964: GO 58049
// for i = 1 to mc_bases do
57966: LD_ADDR_VAR 0 2
57970: PUSH
57971: DOUBLE
57972: LD_INT 1
57974: DEC
57975: ST_TO_ADDR
57976: LD_EXP 102
57980: PUSH
57981: FOR_TO
57982: IFFALSE 58047
// if mc_mines [ i ] and mc_miners [ i ] then
57984: LD_EXP 115
57988: PUSH
57989: LD_VAR 0 2
57993: ARRAY
57994: IFFALSE 58008
57996: PUSH
57997: LD_EXP 116
58001: PUSH
58002: LD_VAR 0 2
58006: ARRAY
58007: AND
58008: IFFALSE 58045
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58010: LD_EXP 116
58014: PUSH
58015: LD_VAR 0 2
58019: ARRAY
58020: PUSH
58021: LD_INT 1
58023: ARRAY
58024: PPUSH
58025: CALL_OW 255
58029: PPUSH
58030: LD_EXP 115
58034: PUSH
58035: LD_VAR 0 2
58039: ARRAY
58040: PPUSH
58041: CALL 72976 0 2
58045: GO 57981
58047: POP
58048: POP
// end ;
58049: LD_VAR 0 1
58053: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
58054: LD_INT 0
58056: PPUSH
58057: PPUSH
58058: PPUSH
58059: PPUSH
58060: PPUSH
58061: PPUSH
58062: PPUSH
58063: PPUSH
// if not mc_bases or not mc_parking then
58064: LD_EXP 102
58068: NOT
58069: IFTRUE 58078
58071: PUSH
58072: LD_EXP 126
58076: NOT
58077: OR
58078: IFFALSE 58082
// exit ;
58080: GO 58826
// for i = 1 to mc_bases do
58082: LD_ADDR_VAR 0 2
58086: PUSH
58087: DOUBLE
58088: LD_INT 1
58090: DEC
58091: ST_TO_ADDR
58092: LD_EXP 102
58096: PUSH
58097: FOR_TO
58098: IFFALSE 58824
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
58100: LD_EXP 102
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: NOT
58111: IFTRUE 58126
58113: PUSH
58114: LD_EXP 126
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: NOT
58125: OR
58126: IFFALSE 58130
// continue ;
58128: GO 58097
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
58130: LD_ADDR_VAR 0 5
58134: PUSH
58135: LD_EXP 102
58139: PUSH
58140: LD_VAR 0 2
58144: ARRAY
58145: PUSH
58146: LD_INT 1
58148: ARRAY
58149: PPUSH
58150: CALL_OW 255
58154: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58155: LD_ADDR_VAR 0 6
58159: PUSH
58160: LD_EXP 102
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: PPUSH
58171: LD_INT 30
58173: PUSH
58174: LD_INT 3
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: PPUSH
58181: CALL_OW 72
58185: ST_TO_ADDR
// if not fac then
58186: LD_VAR 0 6
58190: NOT
58191: IFFALSE 58242
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58193: LD_ADDR_VAR 0 6
58197: PUSH
58198: LD_EXP 102
58202: PUSH
58203: LD_VAR 0 2
58207: ARRAY
58208: PPUSH
58209: LD_INT 2
58211: PUSH
58212: LD_INT 30
58214: PUSH
58215: LD_INT 0
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 30
58224: PUSH
58225: LD_INT 1
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: PPUSH
58237: CALL_OW 72
58241: ST_TO_ADDR
// if not fac then
58242: LD_VAR 0 6
58246: NOT
58247: IFFALSE 58251
// continue ;
58249: GO 58097
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58251: LD_ADDR_VAR 0 7
58255: PUSH
58256: LD_EXP 126
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: PPUSH
58267: LD_INT 22
58269: PUSH
58270: LD_VAR 0 5
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: LD_INT 21
58281: PUSH
58282: LD_INT 2
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: LD_INT 3
58291: PUSH
58292: LD_INT 60
58294: PUSH
58295: EMPTY
58296: LIST
58297: PUSH
58298: EMPTY
58299: LIST
58300: LIST
58301: PUSH
58302: LD_INT 3
58304: PUSH
58305: LD_INT 24
58307: PUSH
58308: LD_INT 1000
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: LIST
58323: LIST
58324: PPUSH
58325: CALL_OW 70
58329: ST_TO_ADDR
// for j in fac do
58330: LD_ADDR_VAR 0 3
58334: PUSH
58335: LD_VAR 0 6
58339: PUSH
58340: FOR_IN
58341: IFFALSE 58436
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58343: LD_ADDR_VAR 0 7
58347: PUSH
58348: LD_VAR 0 7
58352: PUSH
58353: LD_INT 22
58355: PUSH
58356: LD_VAR 0 5
58360: PUSH
58361: EMPTY
58362: LIST
58363: LIST
58364: PUSH
58365: LD_INT 91
58367: PUSH
58368: LD_VAR 0 3
58372: PUSH
58373: LD_INT 15
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 21
58383: PUSH
58384: LD_INT 2
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: LD_INT 3
58393: PUSH
58394: LD_INT 60
58396: PUSH
58397: EMPTY
58398: LIST
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 3
58406: PUSH
58407: LD_INT 24
58409: PUSH
58410: LD_INT 1000
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: LIST
58425: LIST
58426: LIST
58427: PPUSH
58428: CALL_OW 69
58432: UNION
58433: ST_TO_ADDR
58434: GO 58340
58436: POP
58437: POP
// if not vehs then
58438: LD_VAR 0 7
58442: NOT
58443: IFFALSE 58469
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58445: LD_ADDR_EXP 114
58449: PUSH
58450: LD_EXP 114
58454: PPUSH
58455: LD_VAR 0 2
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// continue ;
58467: GO 58097
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58469: LD_ADDR_VAR 0 8
58473: PUSH
58474: LD_EXP 102
58478: PUSH
58479: LD_VAR 0 2
58483: ARRAY
58484: PPUSH
58485: LD_INT 30
58487: PUSH
58488: LD_INT 3
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PPUSH
58495: CALL_OW 72
58499: ST_TO_ADDR
// if tmp then
58500: LD_VAR 0 8
58504: IFFALSE 58607
// begin for j in tmp do
58506: LD_ADDR_VAR 0 3
58510: PUSH
58511: LD_VAR 0 8
58515: PUSH
58516: FOR_IN
58517: IFFALSE 58605
// for k in UnitsInside ( j ) do
58519: LD_ADDR_VAR 0 4
58523: PUSH
58524: LD_VAR 0 3
58528: PPUSH
58529: CALL_OW 313
58533: PUSH
58534: FOR_IN
58535: IFFALSE 58601
// if k then
58537: LD_VAR 0 4
58541: IFFALSE 58599
// if not k in mc_repair_vehicle [ i ] then
58543: LD_VAR 0 4
58547: PUSH
58548: LD_EXP 114
58552: PUSH
58553: LD_VAR 0 2
58557: ARRAY
58558: IN
58559: NOT
58560: IFFALSE 58599
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58562: LD_ADDR_EXP 114
58566: PUSH
58567: LD_EXP 114
58571: PPUSH
58572: LD_VAR 0 2
58576: PPUSH
58577: LD_EXP 114
58581: PUSH
58582: LD_VAR 0 2
58586: ARRAY
58587: PUSH
58588: LD_VAR 0 4
58592: UNION
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
58599: GO 58534
58601: POP
58602: POP
58603: GO 58516
58605: POP
58606: POP
// end ; if not mc_repair_vehicle [ i ] then
58607: LD_EXP 114
58611: PUSH
58612: LD_VAR 0 2
58616: ARRAY
58617: NOT
58618: IFFALSE 58622
// continue ;
58620: GO 58097
// for j in mc_repair_vehicle [ i ] do
58622: LD_ADDR_VAR 0 3
58626: PUSH
58627: LD_EXP 114
58631: PUSH
58632: LD_VAR 0 2
58636: ARRAY
58637: PUSH
58638: FOR_IN
58639: IFFALSE 58820
// begin if GetClass ( j ) <> 3 then
58641: LD_VAR 0 3
58645: PPUSH
58646: CALL_OW 257
58650: PUSH
58651: LD_INT 3
58653: NONEQUAL
58654: IFFALSE 58695
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58656: LD_ADDR_EXP 114
58660: PUSH
58661: LD_EXP 114
58665: PPUSH
58666: LD_VAR 0 2
58670: PPUSH
58671: LD_EXP 114
58675: PUSH
58676: LD_VAR 0 2
58680: ARRAY
58681: PUSH
58682: LD_VAR 0 3
58686: DIFF
58687: PPUSH
58688: CALL_OW 1
58692: ST_TO_ADDR
// continue ;
58693: GO 58638
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58695: LD_VAR 0 3
58699: PPUSH
58700: CALL_OW 311
58704: NOT
58705: IFFALSE 58730
58707: PUSH
58708: LD_VAR 0 3
58712: PUSH
58713: LD_EXP 105
58717: PUSH
58718: LD_VAR 0 2
58722: ARRAY
58723: PUSH
58724: LD_INT 1
58726: ARRAY
58727: IN
58728: NOT
58729: AND
58730: IFFALSE 58755
58732: PUSH
58733: LD_VAR 0 3
58737: PUSH
58738: LD_EXP 105
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PUSH
58749: LD_INT 2
58751: ARRAY
58752: IN
58753: NOT
58754: AND
58755: IFFALSE 58818
// begin if IsInUnit ( j ) then
58757: LD_VAR 0 3
58761: PPUSH
58762: CALL_OW 310
58766: IFFALSE 58779
// ComExitBuilding ( j ) else
58768: LD_VAR 0 3
58772: PPUSH
58773: CALL_OW 122
58777: GO 58818
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58779: LD_VAR 0 3
58783: PPUSH
58784: LD_VAR 0 7
58788: PUSH
58789: LD_INT 1
58791: ARRAY
58792: PPUSH
58793: CALL 111154 0 2
58797: NOT
58798: IFFALSE 58818
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58800: LD_VAR 0 3
58804: PPUSH
58805: LD_VAR 0 7
58809: PUSH
58810: LD_INT 1
58812: ARRAY
58813: PPUSH
58814: CALL_OW 129
// end ; end ;
58818: GO 58638
58820: POP
58821: POP
// end ;
58822: GO 58097
58824: POP
58825: POP
// end ;
58826: LD_VAR 0 1
58830: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58831: LD_INT 0
58833: PPUSH
58834: PPUSH
58835: PPUSH
58836: PPUSH
58837: PPUSH
58838: PPUSH
58839: PPUSH
58840: PPUSH
58841: PPUSH
58842: PPUSH
58843: PPUSH
// if not mc_bases then
58844: LD_EXP 102
58848: NOT
58849: IFFALSE 58853
// exit ;
58851: GO 59671
// for i = 1 to mc_bases do
58853: LD_ADDR_VAR 0 2
58857: PUSH
58858: DOUBLE
58859: LD_INT 1
58861: DEC
58862: ST_TO_ADDR
58863: LD_EXP 102
58867: PUSH
58868: FOR_TO
58869: IFFALSE 59669
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58871: LD_EXP 130
58875: PUSH
58876: LD_VAR 0 2
58880: ARRAY
58881: NOT
58882: IFTRUE 58900
58884: PUSH
58885: LD_EXP 105
58889: PUSH
58890: LD_VAR 0 2
58894: ARRAY
58895: PUSH
58896: LD_INT 1
58898: ARRAY
58899: OR
58900: IFTRUE 58918
58902: PUSH
58903: LD_EXP 105
58907: PUSH
58908: LD_VAR 0 2
58912: ARRAY
58913: PUSH
58914: LD_INT 2
58916: ARRAY
58917: OR
58918: IFTRUE 58941
58920: PUSH
58921: LD_EXP 128
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: PPUSH
58932: LD_INT 1
58934: PPUSH
58935: CALL_OW 325
58939: NOT
58940: OR
58941: IFTRUE 58955
58943: PUSH
58944: LD_EXP 125
58948: PUSH
58949: LD_VAR 0 2
58953: ARRAY
58954: OR
58955: IFFALSE 58959
// continue ;
58957: GO 58868
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58959: LD_ADDR_VAR 0 8
58963: PUSH
58964: LD_EXP 102
58968: PUSH
58969: LD_VAR 0 2
58973: ARRAY
58974: PPUSH
58975: LD_INT 25
58977: PUSH
58978: LD_INT 4
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: LD_INT 50
58987: PUSH
58988: EMPTY
58989: LIST
58990: PUSH
58991: LD_INT 3
58993: PUSH
58994: LD_INT 60
58996: PUSH
58997: EMPTY
58998: LIST
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: LIST
59008: PPUSH
59009: CALL_OW 72
59013: PUSH
59014: LD_EXP 106
59018: PUSH
59019: LD_VAR 0 2
59023: ARRAY
59024: DIFF
59025: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59026: LD_ADDR_VAR 0 9
59030: PUSH
59031: LD_EXP 102
59035: PUSH
59036: LD_VAR 0 2
59040: ARRAY
59041: PPUSH
59042: LD_INT 2
59044: PUSH
59045: LD_INT 30
59047: PUSH
59048: LD_INT 0
59050: PUSH
59051: EMPTY
59052: LIST
59053: LIST
59054: PUSH
59055: LD_INT 30
59057: PUSH
59058: LD_INT 1
59060: PUSH
59061: EMPTY
59062: LIST
59063: LIST
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: PPUSH
59070: CALL_OW 72
59074: ST_TO_ADDR
// if not tmp or not dep then
59075: LD_VAR 0 8
59079: NOT
59080: IFTRUE 59089
59082: PUSH
59083: LD_VAR 0 9
59087: NOT
59088: OR
59089: IFFALSE 59093
// continue ;
59091: GO 58868
// side := GetSide ( tmp [ 1 ] ) ;
59093: LD_ADDR_VAR 0 11
59097: PUSH
59098: LD_VAR 0 8
59102: PUSH
59103: LD_INT 1
59105: ARRAY
59106: PPUSH
59107: CALL_OW 255
59111: ST_TO_ADDR
// dep := dep [ 1 ] ;
59112: LD_ADDR_VAR 0 9
59116: PUSH
59117: LD_VAR 0 9
59121: PUSH
59122: LD_INT 1
59124: ARRAY
59125: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
59126: LD_ADDR_VAR 0 7
59130: PUSH
59131: LD_EXP 130
59135: PUSH
59136: LD_VAR 0 2
59140: ARRAY
59141: PPUSH
59142: LD_INT 22
59144: PUSH
59145: LD_INT 0
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PUSH
59152: LD_INT 25
59154: PUSH
59155: LD_INT 12
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PPUSH
59166: CALL_OW 70
59170: PUSH
59171: LD_INT 22
59173: PUSH
59174: LD_INT 0
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 25
59183: PUSH
59184: LD_INT 12
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PUSH
59191: LD_INT 91
59193: PUSH
59194: LD_VAR 0 9
59198: PUSH
59199: LD_INT 20
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 69
59216: UNION
59217: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
59218: LD_ADDR_VAR 0 10
59222: PUSH
59223: LD_EXP 130
59227: PUSH
59228: LD_VAR 0 2
59232: ARRAY
59233: PPUSH
59234: LD_INT 81
59236: PUSH
59237: LD_VAR 0 11
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PPUSH
59246: CALL_OW 70
59250: ST_TO_ADDR
// if not apes or danger_at_area then
59251: LD_VAR 0 7
59255: NOT
59256: IFTRUE 59264
59258: PUSH
59259: LD_VAR 0 10
59263: OR
59264: IFFALSE 59314
// begin if mc_taming [ i ] then
59266: LD_EXP 133
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: IFFALSE 59312
// begin MC_Reset ( i , 121 ) ;
59278: LD_VAR 0 2
59282: PPUSH
59283: LD_INT 121
59285: PPUSH
59286: CALL 44046 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59290: LD_ADDR_EXP 133
59294: PUSH
59295: LD_EXP 133
59299: PPUSH
59300: LD_VAR 0 2
59304: PPUSH
59305: EMPTY
59306: PPUSH
59307: CALL_OW 1
59311: ST_TO_ADDR
// end ; continue ;
59312: GO 58868
// end ; for j in tmp do
59314: LD_ADDR_VAR 0 3
59318: PUSH
59319: LD_VAR 0 8
59323: PUSH
59324: FOR_IN
59325: IFFALSE 59665
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
59327: LD_VAR 0 3
59331: PUSH
59332: LD_EXP 133
59336: PUSH
59337: LD_VAR 0 2
59341: ARRAY
59342: IN
59343: NOT
59344: IFFALSE 59362
59346: PUSH
59347: LD_EXP 133
59351: PUSH
59352: LD_VAR 0 2
59356: ARRAY
59357: PUSH
59358: LD_INT 3
59360: LESS
59361: AND
59362: IFFALSE 59420
// begin SetTag ( j , 121 ) ;
59364: LD_VAR 0 3
59368: PPUSH
59369: LD_INT 121
59371: PPUSH
59372: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
59376: LD_ADDR_EXP 133
59380: PUSH
59381: LD_EXP 133
59385: PPUSH
59386: LD_VAR 0 2
59390: PUSH
59391: LD_EXP 133
59395: PUSH
59396: LD_VAR 0 2
59400: ARRAY
59401: PUSH
59402: LD_INT 1
59404: PLUS
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PPUSH
59410: LD_VAR 0 3
59414: PPUSH
59415: CALL 76023 0 3
59419: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
59420: LD_VAR 0 3
59424: PUSH
59425: LD_EXP 133
59429: PUSH
59430: LD_VAR 0 2
59434: ARRAY
59435: IN
59436: IFFALSE 59663
// begin if GetClass ( j ) <> 4 then
59438: LD_VAR 0 3
59442: PPUSH
59443: CALL_OW 257
59447: PUSH
59448: LD_INT 4
59450: NONEQUAL
59451: IFFALSE 59504
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
59453: LD_ADDR_EXP 133
59457: PUSH
59458: LD_EXP 133
59462: PPUSH
59463: LD_VAR 0 2
59467: PPUSH
59468: LD_EXP 133
59472: PUSH
59473: LD_VAR 0 2
59477: ARRAY
59478: PUSH
59479: LD_VAR 0 3
59483: DIFF
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59490: LD_VAR 0 3
59494: PPUSH
59495: LD_INT 0
59497: PPUSH
59498: CALL_OW 109
// continue ;
59502: GO 59324
// end ; if IsInUnit ( j ) then
59504: LD_VAR 0 3
59508: PPUSH
59509: CALL_OW 310
59513: IFFALSE 59524
// ComExitBuilding ( j ) ;
59515: LD_VAR 0 3
59519: PPUSH
59520: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59524: LD_ADDR_VAR 0 6
59528: PUSH
59529: LD_VAR 0 7
59533: PPUSH
59534: LD_VAR 0 3
59538: PPUSH
59539: CALL_OW 74
59543: ST_TO_ADDR
// if not ape then
59544: LD_VAR 0 6
59548: NOT
59549: IFFALSE 59553
// break ;
59551: GO 59665
// x := GetX ( ape ) ;
59553: LD_ADDR_VAR 0 4
59557: PUSH
59558: LD_VAR 0 6
59562: PPUSH
59563: CALL_OW 250
59567: ST_TO_ADDR
// y := GetY ( ape ) ;
59568: LD_ADDR_VAR 0 5
59572: PUSH
59573: LD_VAR 0 6
59577: PPUSH
59578: CALL_OW 251
59582: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59583: LD_VAR 0 4
59587: PPUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: CALL_OW 488
59597: NOT
59598: IFTRUE 59628
59600: PUSH
59601: LD_VAR 0 11
59605: PPUSH
59606: LD_VAR 0 4
59610: PPUSH
59611: LD_VAR 0 5
59615: PPUSH
59616: LD_INT 20
59618: PPUSH
59619: CALL 77293 0 4
59623: PUSH
59624: LD_INT 4
59626: ARRAY
59627: OR
59628: IFFALSE 59632
// break ;
59630: GO 59665
// if not HasTask ( j ) then
59632: LD_VAR 0 3
59636: PPUSH
59637: CALL_OW 314
59641: NOT
59642: IFFALSE 59663
// ComTameXY ( j , x , y ) ;
59644: LD_VAR 0 3
59648: PPUSH
59649: LD_VAR 0 4
59653: PPUSH
59654: LD_VAR 0 5
59658: PPUSH
59659: CALL_OW 131
// end ; end ;
59663: GO 59324
59665: POP
59666: POP
// end ;
59667: GO 58868
59669: POP
59670: POP
// end ;
59671: LD_VAR 0 1
59675: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59676: LD_INT 0
59678: PPUSH
59679: PPUSH
59680: PPUSH
59681: PPUSH
59682: PPUSH
59683: PPUSH
59684: PPUSH
59685: PPUSH
// if not mc_bases then
59686: LD_EXP 102
59690: NOT
59691: IFFALSE 59695
// exit ;
59693: GO 60327
// for i = 1 to mc_bases do
59695: LD_ADDR_VAR 0 2
59699: PUSH
59700: DOUBLE
59701: LD_INT 1
59703: DEC
59704: ST_TO_ADDR
59705: LD_EXP 102
59709: PUSH
59710: FOR_TO
59711: IFFALSE 60325
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59713: LD_EXP 131
59717: PUSH
59718: LD_VAR 0 2
59722: ARRAY
59723: NOT
59724: IFTRUE 59754
59726: PUSH
59727: LD_EXP 131
59731: PUSH
59732: LD_VAR 0 2
59736: ARRAY
59737: PPUSH
59738: LD_INT 25
59740: PUSH
59741: LD_INT 12
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PPUSH
59748: CALL_OW 72
59752: NOT
59753: OR
59754: IFFALSE 59758
// continue ;
59756: GO 59710
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59758: LD_ADDR_VAR 0 5
59762: PUSH
59763: LD_EXP 131
59767: PUSH
59768: LD_VAR 0 2
59772: ARRAY
59773: PUSH
59774: LD_INT 1
59776: ARRAY
59777: PPUSH
59778: CALL_OW 255
59782: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59783: LD_VAR 0 5
59787: PPUSH
59788: LD_INT 2
59790: PPUSH
59791: CALL_OW 325
59795: IFFALSE 60048
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59797: LD_ADDR_VAR 0 4
59801: PUSH
59802: LD_EXP 131
59806: PUSH
59807: LD_VAR 0 2
59811: ARRAY
59812: PPUSH
59813: LD_INT 25
59815: PUSH
59816: LD_INT 16
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PPUSH
59823: CALL_OW 72
59827: ST_TO_ADDR
// if tmp < 6 then
59828: LD_VAR 0 4
59832: PUSH
59833: LD_INT 6
59835: LESS
59836: IFFALSE 60048
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59838: LD_ADDR_VAR 0 6
59842: PUSH
59843: LD_EXP 102
59847: PUSH
59848: LD_VAR 0 2
59852: ARRAY
59853: PPUSH
59854: LD_INT 2
59856: PUSH
59857: LD_INT 30
59859: PUSH
59860: LD_INT 0
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: PUSH
59867: LD_INT 30
59869: PUSH
59870: LD_INT 1
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: PPUSH
59882: CALL_OW 72
59886: ST_TO_ADDR
// if depot then
59887: LD_VAR 0 6
59891: IFFALSE 60048
// begin selected := 0 ;
59893: LD_ADDR_VAR 0 7
59897: PUSH
59898: LD_INT 0
59900: ST_TO_ADDR
// for j in depot do
59901: LD_ADDR_VAR 0 3
59905: PUSH
59906: LD_VAR 0 6
59910: PUSH
59911: FOR_IN
59912: IFFALSE 59943
// begin if UnitsInside ( j ) < 6 then
59914: LD_VAR 0 3
59918: PPUSH
59919: CALL_OW 313
59923: PUSH
59924: LD_INT 6
59926: LESS
59927: IFFALSE 59941
// begin selected := j ;
59929: LD_ADDR_VAR 0 7
59933: PUSH
59934: LD_VAR 0 3
59938: ST_TO_ADDR
// break ;
59939: GO 59943
// end ; end ;
59941: GO 59911
59943: POP
59944: POP
// if selected then
59945: LD_VAR 0 7
59949: IFFALSE 60048
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59951: LD_ADDR_VAR 0 3
59955: PUSH
59956: LD_EXP 131
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: PPUSH
59967: LD_INT 25
59969: PUSH
59970: LD_INT 12
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PPUSH
59977: CALL_OW 72
59981: PUSH
59982: FOR_IN
59983: IFFALSE 60046
// if not HasTask ( j ) then
59985: LD_VAR 0 3
59989: PPUSH
59990: CALL_OW 314
59994: NOT
59995: IFFALSE 60044
// begin if not IsInUnit ( j ) then
59997: LD_VAR 0 3
60001: PPUSH
60002: CALL_OW 310
60006: NOT
60007: IFFALSE 60023
// ComEnterUnit ( j , selected ) ;
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_VAR 0 7
60018: PPUSH
60019: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60023: LD_VAR 0 3
60027: PPUSH
60028: LD_INT 16
60030: PPUSH
60031: CALL_OW 183
// AddComExitBuilding ( j ) ;
60035: LD_VAR 0 3
60039: PPUSH
60040: CALL_OW 182
// end ;
60044: GO 59982
60046: POP
60047: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_INT 11
60055: PPUSH
60056: CALL_OW 325
60060: IFFALSE 60323
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60062: LD_ADDR_VAR 0 4
60066: PUSH
60067: LD_EXP 131
60071: PUSH
60072: LD_VAR 0 2
60076: ARRAY
60077: PPUSH
60078: LD_INT 25
60080: PUSH
60081: LD_INT 16
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PPUSH
60088: CALL_OW 72
60092: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60093: LD_VAR 0 4
60097: PUSH
60098: LD_INT 6
60100: GREATEREQUAL
60101: IFTRUE 60118
60103: PUSH
60104: LD_VAR 0 5
60108: PPUSH
60109: LD_INT 2
60111: PPUSH
60112: CALL_OW 325
60116: NOT
60117: OR
60118: IFFALSE 60323
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60120: LD_ADDR_VAR 0 8
60124: PUSH
60125: LD_EXP 102
60129: PUSH
60130: LD_VAR 0 2
60134: ARRAY
60135: PPUSH
60136: LD_INT 2
60138: PUSH
60139: LD_INT 30
60141: PUSH
60142: LD_INT 4
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 30
60151: PUSH
60152: LD_INT 5
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: LIST
60163: PPUSH
60164: CALL_OW 72
60168: ST_TO_ADDR
// if barracks then
60169: LD_VAR 0 8
60173: IFFALSE 60323
// begin selected := 0 ;
60175: LD_ADDR_VAR 0 7
60179: PUSH
60180: LD_INT 0
60182: ST_TO_ADDR
// for j in barracks do
60183: LD_ADDR_VAR 0 3
60187: PUSH
60188: LD_VAR 0 8
60192: PUSH
60193: FOR_IN
60194: IFFALSE 60225
// begin if UnitsInside ( j ) < 6 then
60196: LD_VAR 0 3
60200: PPUSH
60201: CALL_OW 313
60205: PUSH
60206: LD_INT 6
60208: LESS
60209: IFFALSE 60223
// begin selected := j ;
60211: LD_ADDR_VAR 0 7
60215: PUSH
60216: LD_VAR 0 3
60220: ST_TO_ADDR
// break ;
60221: GO 60225
// end ; end ;
60223: GO 60193
60225: POP
60226: POP
// if selected then
60227: LD_VAR 0 7
60231: IFFALSE 60323
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60233: LD_ADDR_VAR 0 3
60237: PUSH
60238: LD_EXP 131
60242: PUSH
60243: LD_VAR 0 2
60247: ARRAY
60248: PPUSH
60249: LD_INT 25
60251: PUSH
60252: LD_INT 12
60254: PUSH
60255: EMPTY
60256: LIST
60257: LIST
60258: PPUSH
60259: CALL_OW 72
60263: PUSH
60264: FOR_IN
60265: IFFALSE 60321
// if not IsInUnit ( j ) and not HasTask ( j ) then
60267: LD_VAR 0 3
60271: PPUSH
60272: CALL_OW 310
60276: NOT
60277: IFFALSE 60291
60279: PUSH
60280: LD_VAR 0 3
60284: PPUSH
60285: CALL_OW 314
60289: NOT
60290: AND
60291: IFFALSE 60319
// begin ComEnterUnit ( j , selected ) ;
60293: LD_VAR 0 3
60297: PPUSH
60298: LD_VAR 0 7
60302: PPUSH
60303: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
60307: LD_VAR 0 3
60311: PPUSH
60312: LD_INT 15
60314: PPUSH
60315: CALL_OW 183
// end ;
60319: GO 60264
60321: POP
60322: POP
// end ; end ; end ; end ; end ;
60323: GO 59710
60325: POP
60326: POP
// end ;
60327: LD_VAR 0 1
60331: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
60332: LD_INT 0
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
// if not mc_bases then
60338: LD_EXP 102
60342: NOT
60343: IFFALSE 60347
// exit ;
60345: GO 60529
// for i = 1 to mc_bases do
60347: LD_ADDR_VAR 0 2
60351: PUSH
60352: DOUBLE
60353: LD_INT 1
60355: DEC
60356: ST_TO_ADDR
60357: LD_EXP 102
60361: PUSH
60362: FOR_TO
60363: IFFALSE 60527
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
60365: LD_ADDR_VAR 0 4
60369: PUSH
60370: LD_EXP 102
60374: PUSH
60375: LD_VAR 0 2
60379: ARRAY
60380: PPUSH
60381: LD_INT 25
60383: PUSH
60384: LD_INT 9
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PPUSH
60391: CALL_OW 72
60395: ST_TO_ADDR
// if not tmp then
60396: LD_VAR 0 4
60400: NOT
60401: IFFALSE 60405
// continue ;
60403: GO 60362
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
60405: LD_EXP 128
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PPUSH
60416: LD_INT 29
60418: PPUSH
60419: CALL_OW 325
60423: NOT
60424: IFFALSE 60447
60426: PUSH
60427: LD_EXP 128
60431: PUSH
60432: LD_VAR 0 2
60436: ARRAY
60437: PPUSH
60438: LD_INT 28
60440: PPUSH
60441: CALL_OW 325
60445: NOT
60446: AND
60447: IFFALSE 60451
// continue ;
60449: GO 60362
// for j in tmp do
60451: LD_ADDR_VAR 0 3
60455: PUSH
60456: LD_VAR 0 4
60460: PUSH
60461: FOR_IN
60462: IFFALSE 60523
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
60464: LD_VAR 0 3
60468: PUSH
60469: LD_EXP 105
60473: PUSH
60474: LD_VAR 0 2
60478: ARRAY
60479: PUSH
60480: LD_INT 1
60482: ARRAY
60483: IN
60484: NOT
60485: IFFALSE 60510
60487: PUSH
60488: LD_VAR 0 3
60492: PUSH
60493: LD_EXP 105
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PUSH
60504: LD_INT 2
60506: ARRAY
60507: IN
60508: NOT
60509: AND
60510: IFFALSE 60521
// ComSpaceTimeShoot ( j ) ;
60512: LD_VAR 0 3
60516: PPUSH
60517: CALL 71974 0 1
60521: GO 60461
60523: POP
60524: POP
// end ;
60525: GO 60362
60527: POP
60528: POP
// end ;
60529: LD_VAR 0 1
60533: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
60538: PPUSH
60539: PPUSH
60540: PPUSH
60541: PPUSH
60542: PPUSH
60543: PPUSH
60544: PPUSH
// if not mc_bases then
60545: LD_EXP 102
60549: NOT
60550: IFFALSE 60554
// exit ;
60552: GO 61186
// for i = 1 to mc_bases do
60554: LD_ADDR_VAR 0 2
60558: PUSH
60559: DOUBLE
60560: LD_INT 1
60562: DEC
60563: ST_TO_ADDR
60564: LD_EXP 102
60568: PUSH
60569: FOR_TO
60570: IFFALSE 61184
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60572: LD_EXP 137
60576: PUSH
60577: LD_VAR 0 2
60581: ARRAY
60582: NOT
60583: IFTRUE 60609
60585: PUSH
60586: LD_INT 38
60588: PPUSH
60589: LD_EXP 128
60593: PUSH
60594: LD_VAR 0 2
60598: ARRAY
60599: PPUSH
60600: CALL_OW 321
60604: PUSH
60605: LD_INT 2
60607: NONEQUAL
60608: OR
60609: IFFALSE 60613
// continue ;
60611: GO 60569
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60613: LD_ADDR_VAR 0 8
60617: PUSH
60618: LD_EXP 102
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PPUSH
60629: LD_INT 30
60631: PUSH
60632: LD_INT 34
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PPUSH
60639: CALL_OW 72
60643: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60644: LD_ADDR_VAR 0 9
60648: PUSH
60649: LD_EXP 102
60653: PUSH
60654: LD_VAR 0 2
60658: ARRAY
60659: PPUSH
60660: LD_INT 25
60662: PUSH
60663: LD_INT 4
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PPUSH
60670: CALL_OW 72
60674: PPUSH
60675: LD_INT 0
60677: PPUSH
60678: CALL 106616 0 2
60682: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60683: LD_VAR 0 9
60687: NOT
60688: IFTRUE 60697
60690: PUSH
60691: LD_VAR 0 8
60695: NOT
60696: OR
60697: IFTRUE 60719
60699: PUSH
60700: LD_EXP 102
60704: PUSH
60705: LD_VAR 0 2
60709: ARRAY
60710: PPUSH
60711: LD_INT 124
60713: PPUSH
60714: CALL 106616 0 2
60718: OR
60719: IFFALSE 60723
// continue ;
60721: GO 60569
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60723: LD_EXP 138
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: PUSH
60734: LD_EXP 137
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: LESS
60745: IFFALSE 60765
60747: PUSH
60748: LD_EXP 138
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PUSH
60759: LD_VAR 0 8
60763: LESS
60764: AND
60765: IFFALSE 61182
// begin tmp := sci [ 1 ] ;
60767: LD_ADDR_VAR 0 7
60771: PUSH
60772: LD_VAR 0 9
60776: PUSH
60777: LD_INT 1
60779: ARRAY
60780: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60781: LD_VAR 0 7
60785: PPUSH
60786: LD_INT 124
60788: PPUSH
60789: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60793: LD_ADDR_VAR 0 3
60797: PUSH
60798: DOUBLE
60799: LD_EXP 137
60803: PUSH
60804: LD_VAR 0 2
60808: ARRAY
60809: INC
60810: ST_TO_ADDR
60811: LD_EXP 137
60815: PUSH
60816: LD_VAR 0 2
60820: ARRAY
60821: PUSH
60822: FOR_DOWNTO
60823: IFFALSE 61168
// begin if IsInUnit ( tmp ) then
60825: LD_VAR 0 7
60829: PPUSH
60830: CALL_OW 310
60834: IFFALSE 60845
// ComExitBuilding ( tmp ) ;
60836: LD_VAR 0 7
60840: PPUSH
60841: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60845: LD_INT 35
60847: PPUSH
60848: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60852: LD_VAR 0 7
60856: PPUSH
60857: CALL_OW 310
60861: NOT
60862: IFFALSE 60876
60864: PUSH
60865: LD_VAR 0 7
60869: PPUSH
60870: CALL_OW 314
60874: NOT
60875: AND
60876: IFFALSE 60845
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60878: LD_ADDR_VAR 0 6
60882: PUSH
60883: LD_VAR 0 7
60887: PPUSH
60888: CALL_OW 250
60892: PUSH
60893: LD_VAR 0 7
60897: PPUSH
60898: CALL_OW 251
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60907: LD_INT 35
60909: PPUSH
60910: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60914: LD_ADDR_VAR 0 4
60918: PUSH
60919: LD_EXP 137
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: PUSH
60930: LD_VAR 0 3
60934: ARRAY
60935: PUSH
60936: LD_INT 1
60938: ARRAY
60939: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60940: LD_ADDR_VAR 0 5
60944: PUSH
60945: LD_EXP 137
60949: PUSH
60950: LD_VAR 0 2
60954: ARRAY
60955: PUSH
60956: LD_VAR 0 3
60960: ARRAY
60961: PUSH
60962: LD_INT 2
60964: ARRAY
60965: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60966: LD_VAR 0 7
60970: PPUSH
60971: LD_INT 10
60973: PPUSH
60974: CALL 79002 0 2
60978: PUSH
60979: LD_INT 4
60981: ARRAY
60982: IFFALSE 61020
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60984: LD_VAR 0 7
60988: PPUSH
60989: LD_VAR 0 6
60993: PUSH
60994: LD_INT 1
60996: ARRAY
60997: PPUSH
60998: LD_VAR 0 6
61002: PUSH
61003: LD_INT 2
61005: ARRAY
61006: PPUSH
61007: CALL_OW 111
// wait ( 0 0$10 ) ;
61011: LD_INT 350
61013: PPUSH
61014: CALL_OW 67
// end else
61018: GO 61046
// begin ComMoveXY ( tmp , x , y ) ;
61020: LD_VAR 0 7
61024: PPUSH
61025: LD_VAR 0 4
61029: PPUSH
61030: LD_VAR 0 5
61034: PPUSH
61035: CALL_OW 111
// wait ( 0 0$3 ) ;
61039: LD_INT 105
61041: PPUSH
61042: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61046: LD_VAR 0 7
61050: PPUSH
61051: LD_VAR 0 4
61055: PPUSH
61056: LD_VAR 0 5
61060: PPUSH
61061: CALL_OW 307
61065: IFFALSE 60907
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61067: LD_VAR 0 7
61071: PPUSH
61072: LD_VAR 0 4
61076: PPUSH
61077: LD_VAR 0 5
61081: PPUSH
61082: LD_VAR 0 8
61086: PUSH
61087: LD_VAR 0 3
61091: ARRAY
61092: PPUSH
61093: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61097: LD_INT 35
61099: PPUSH
61100: CALL_OW 67
// until not HasTask ( tmp ) ;
61104: LD_VAR 0 7
61108: PPUSH
61109: CALL_OW 314
61113: NOT
61114: IFFALSE 61097
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
61116: LD_ADDR_EXP 138
61120: PUSH
61121: LD_EXP 138
61125: PPUSH
61126: LD_VAR 0 2
61130: PUSH
61131: LD_EXP 138
61135: PUSH
61136: LD_VAR 0 2
61140: ARRAY
61141: PUSH
61142: LD_INT 1
61144: PLUS
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: LD_VAR 0 8
61154: PUSH
61155: LD_VAR 0 3
61159: ARRAY
61160: PPUSH
61161: CALL 76023 0 3
61165: ST_TO_ADDR
// end ;
61166: GO 60822
61168: POP
61169: POP
// MC_Reset ( i , 124 ) ;
61170: LD_VAR 0 2
61174: PPUSH
61175: LD_INT 124
61177: PPUSH
61178: CALL 44046 0 2
// end ; end ;
61182: GO 60569
61184: POP
61185: POP
// end ;
61186: LD_VAR 0 1
61190: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
61191: LD_INT 0
61193: PPUSH
61194: PPUSH
61195: PPUSH
// if not mc_bases then
61196: LD_EXP 102
61200: NOT
61201: IFFALSE 61205
// exit ;
61203: GO 61819
// for i = 1 to mc_bases do
61205: LD_ADDR_VAR 0 2
61209: PUSH
61210: DOUBLE
61211: LD_INT 1
61213: DEC
61214: ST_TO_ADDR
61215: LD_EXP 102
61219: PUSH
61220: FOR_TO
61221: IFFALSE 61817
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61223: LD_ADDR_VAR 0 3
61227: PUSH
61228: LD_EXP 102
61232: PUSH
61233: LD_VAR 0 2
61237: ARRAY
61238: PPUSH
61239: LD_INT 25
61241: PUSH
61242: LD_INT 4
61244: PUSH
61245: EMPTY
61246: LIST
61247: LIST
61248: PPUSH
61249: CALL_OW 72
61253: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61254: LD_VAR 0 3
61258: NOT
61259: IFTRUE 61274
61261: PUSH
61262: LD_EXP 139
61266: PUSH
61267: LD_VAR 0 2
61271: ARRAY
61272: NOT
61273: OR
61274: IFTRUE 61322
61276: PUSH
61277: LD_EXP 102
61281: PUSH
61282: LD_VAR 0 2
61286: ARRAY
61287: PPUSH
61288: LD_INT 2
61290: PUSH
61291: LD_INT 30
61293: PUSH
61294: LD_INT 0
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 1
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: PPUSH
61316: CALL_OW 72
61320: NOT
61321: OR
61322: IFFALSE 61372
// begin if mc_deposits_finder [ i ] then
61324: LD_EXP 140
61328: PUSH
61329: LD_VAR 0 2
61333: ARRAY
61334: IFFALSE 61370
// begin MC_Reset ( i , 125 ) ;
61336: LD_VAR 0 2
61340: PPUSH
61341: LD_INT 125
61343: PPUSH
61344: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61348: LD_ADDR_EXP 140
61352: PUSH
61353: LD_EXP 140
61357: PPUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: EMPTY
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// end ; continue ;
61370: GO 61220
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
61372: LD_EXP 139
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PUSH
61383: LD_INT 1
61385: ARRAY
61386: PUSH
61387: LD_INT 3
61389: ARRAY
61390: PUSH
61391: LD_INT 1
61393: EQUAL
61394: IFFALSE 61420
61396: PUSH
61397: LD_INT 20
61399: PPUSH
61400: LD_EXP 128
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: PPUSH
61411: CALL_OW 321
61415: PUSH
61416: LD_INT 2
61418: NONEQUAL
61419: AND
61420: IFFALSE 61470
// begin if mc_deposits_finder [ i ] then
61422: LD_EXP 140
61426: PUSH
61427: LD_VAR 0 2
61431: ARRAY
61432: IFFALSE 61468
// begin MC_Reset ( i , 125 ) ;
61434: LD_VAR 0 2
61438: PPUSH
61439: LD_INT 125
61441: PPUSH
61442: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61446: LD_ADDR_EXP 140
61450: PUSH
61451: LD_EXP 140
61455: PPUSH
61456: LD_VAR 0 2
61460: PPUSH
61461: EMPTY
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// end ; continue ;
61468: GO 61220
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
61470: LD_EXP 139
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: ARRAY
61484: PUSH
61485: LD_INT 1
61487: ARRAY
61488: PPUSH
61489: LD_EXP 139
61493: PUSH
61494: LD_VAR 0 2
61498: ARRAY
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: PUSH
61504: LD_INT 2
61506: ARRAY
61507: PPUSH
61508: LD_EXP 128
61512: PUSH
61513: LD_VAR 0 2
61517: ARRAY
61518: PPUSH
61519: CALL_OW 440
61523: IFFALSE 61566
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61525: LD_ADDR_EXP 139
61529: PUSH
61530: LD_EXP 139
61534: PPUSH
61535: LD_VAR 0 2
61539: PPUSH
61540: LD_EXP 139
61544: PUSH
61545: LD_VAR 0 2
61549: ARRAY
61550: PPUSH
61551: LD_INT 1
61553: PPUSH
61554: CALL_OW 3
61558: PPUSH
61559: CALL_OW 1
61563: ST_TO_ADDR
61564: GO 61815
// begin if not mc_deposits_finder [ i ] then
61566: LD_EXP 140
61570: PUSH
61571: LD_VAR 0 2
61575: ARRAY
61576: NOT
61577: IFFALSE 61629
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61579: LD_ADDR_EXP 140
61583: PUSH
61584: LD_EXP 140
61588: PPUSH
61589: LD_VAR 0 2
61593: PPUSH
61594: LD_VAR 0 3
61598: PUSH
61599: LD_INT 1
61601: ARRAY
61602: PUSH
61603: EMPTY
61604: LIST
61605: PPUSH
61606: CALL_OW 1
61610: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61611: LD_VAR 0 3
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: LD_INT 125
61622: PPUSH
61623: CALL_OW 109
// end else
61627: GO 61815
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61629: LD_EXP 140
61633: PUSH
61634: LD_VAR 0 2
61638: ARRAY
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: CALL_OW 310
61648: IFFALSE 61671
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61650: LD_EXP 140
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: PPUSH
61665: CALL_OW 122
61669: GO 61815
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61671: LD_EXP 140
61675: PUSH
61676: LD_VAR 0 2
61680: ARRAY
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: PPUSH
61686: CALL_OW 314
61690: NOT
61691: IFFALSE 61756
61693: PUSH
61694: LD_EXP 140
61698: PUSH
61699: LD_VAR 0 2
61703: ARRAY
61704: PUSH
61705: LD_INT 1
61707: ARRAY
61708: PPUSH
61709: LD_EXP 139
61713: PUSH
61714: LD_VAR 0 2
61718: ARRAY
61719: PUSH
61720: LD_INT 1
61722: ARRAY
61723: PUSH
61724: LD_INT 1
61726: ARRAY
61727: PPUSH
61728: LD_EXP 139
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: PUSH
61743: LD_INT 2
61745: ARRAY
61746: PPUSH
61747: CALL_OW 297
61751: PUSH
61752: LD_INT 6
61754: GREATER
61755: AND
61756: IFFALSE 61815
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61758: LD_EXP 140
61762: PUSH
61763: LD_VAR 0 2
61767: ARRAY
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: PPUSH
61773: LD_EXP 139
61777: PUSH
61778: LD_VAR 0 2
61782: ARRAY
61783: PUSH
61784: LD_INT 1
61786: ARRAY
61787: PUSH
61788: LD_INT 1
61790: ARRAY
61791: PPUSH
61792: LD_EXP 139
61796: PUSH
61797: LD_VAR 0 2
61801: ARRAY
61802: PUSH
61803: LD_INT 1
61805: ARRAY
61806: PUSH
61807: LD_INT 2
61809: ARRAY
61810: PPUSH
61811: CALL_OW 111
// end ; end ; end ;
61815: GO 61220
61817: POP
61818: POP
// end ;
61819: LD_VAR 0 1
61823: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61824: LD_INT 0
61826: PPUSH
61827: PPUSH
61828: PPUSH
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
61836: PPUSH
// if not mc_bases then
61837: LD_EXP 102
61841: NOT
61842: IFFALSE 61846
// exit ;
61844: GO 62806
// for i = 1 to mc_bases do
61846: LD_ADDR_VAR 0 2
61850: PUSH
61851: DOUBLE
61852: LD_INT 1
61854: DEC
61855: ST_TO_ADDR
61856: LD_EXP 102
61860: PUSH
61861: FOR_TO
61862: IFFALSE 62804
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61864: LD_EXP 102
61868: PUSH
61869: LD_VAR 0 2
61873: ARRAY
61874: NOT
61875: IFTRUE 61889
61877: PUSH
61878: LD_EXP 125
61882: PUSH
61883: LD_VAR 0 2
61887: ARRAY
61888: OR
61889: IFFALSE 61893
// continue ;
61891: GO 61861
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61893: LD_ADDR_VAR 0 7
61897: PUSH
61898: LD_EXP 102
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: PUSH
61909: LD_INT 1
61911: ARRAY
61912: PPUSH
61913: CALL_OW 248
61917: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61918: LD_VAR 0 7
61922: PUSH
61923: LD_INT 3
61925: EQUAL
61926: IFTRUE 61968
61928: PUSH
61929: LD_EXP 121
61933: PUSH
61934: LD_VAR 0 2
61938: ARRAY
61939: PUSH
61940: LD_EXP 124
61944: PUSH
61945: LD_VAR 0 2
61949: ARRAY
61950: UNION
61951: PPUSH
61952: LD_INT 33
61954: PUSH
61955: LD_INT 2
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL_OW 72
61966: NOT
61967: OR
61968: IFFALSE 61972
// continue ;
61970: GO 61861
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61972: LD_ADDR_VAR 0 9
61976: PUSH
61977: LD_EXP 102
61981: PUSH
61982: LD_VAR 0 2
61986: ARRAY
61987: PPUSH
61988: LD_INT 30
61990: PUSH
61991: LD_INT 36
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PPUSH
61998: CALL_OW 72
62002: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62003: LD_ADDR_VAR 0 10
62007: PUSH
62008: LD_EXP 121
62012: PUSH
62013: LD_VAR 0 2
62017: ARRAY
62018: PPUSH
62019: LD_INT 34
62021: PUSH
62022: LD_INT 31
62024: PUSH
62025: EMPTY
62026: LIST
62027: LIST
62028: PPUSH
62029: CALL_OW 72
62033: ST_TO_ADDR
// if not cts and not mcts then
62034: LD_VAR 0 9
62038: NOT
62039: IFFALSE 62048
62041: PUSH
62042: LD_VAR 0 10
62046: NOT
62047: AND
62048: IFFALSE 62052
// continue ;
62050: GO 61861
// x := cts ;
62052: LD_ADDR_VAR 0 11
62056: PUSH
62057: LD_VAR 0 9
62061: ST_TO_ADDR
// if not x then
62062: LD_VAR 0 11
62066: NOT
62067: IFFALSE 62079
// x := mcts ;
62069: LD_ADDR_VAR 0 11
62073: PUSH
62074: LD_VAR 0 10
62078: ST_TO_ADDR
// if not x then
62079: LD_VAR 0 11
62083: NOT
62084: IFFALSE 62088
// continue ;
62086: GO 61861
// if mc_remote_driver [ i ] then
62088: LD_EXP 142
62092: PUSH
62093: LD_VAR 0 2
62097: ARRAY
62098: IFFALSE 62497
// for j in mc_remote_driver [ i ] do
62100: LD_ADDR_VAR 0 3
62104: PUSH
62105: LD_EXP 142
62109: PUSH
62110: LD_VAR 0 2
62114: ARRAY
62115: PUSH
62116: FOR_IN
62117: IFFALSE 62495
// begin if GetClass ( j ) <> 3 then
62119: LD_VAR 0 3
62123: PPUSH
62124: CALL_OW 257
62128: PUSH
62129: LD_INT 3
62131: NONEQUAL
62132: IFFALSE 62185
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
62134: LD_ADDR_EXP 142
62138: PUSH
62139: LD_EXP 142
62143: PPUSH
62144: LD_VAR 0 2
62148: PPUSH
62149: LD_EXP 142
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: PUSH
62160: LD_VAR 0 3
62164: DIFF
62165: PPUSH
62166: CALL_OW 1
62170: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62171: LD_VAR 0 3
62175: PPUSH
62176: LD_INT 0
62178: PPUSH
62179: CALL_OW 109
// continue ;
62183: GO 62116
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
62185: LD_EXP 121
62189: PUSH
62190: LD_VAR 0 2
62194: ARRAY
62195: PPUSH
62196: LD_INT 34
62198: PUSH
62199: LD_INT 31
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PUSH
62206: LD_INT 58
62208: PUSH
62209: EMPTY
62210: LIST
62211: PUSH
62212: EMPTY
62213: LIST
62214: LIST
62215: PPUSH
62216: CALL_OW 72
62220: IFFALSE 62234
62222: PUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: CALL 106651 0 1
62232: NOT
62233: AND
62234: IFFALSE 62305
// begin if IsInUnit ( j ) then
62236: LD_VAR 0 3
62240: PPUSH
62241: CALL_OW 310
62245: IFFALSE 62256
// ComExitBuilding ( j ) ;
62247: LD_VAR 0 3
62251: PPUSH
62252: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
62256: LD_VAR 0 3
62260: PPUSH
62261: LD_EXP 121
62265: PUSH
62266: LD_VAR 0 2
62270: ARRAY
62271: PPUSH
62272: LD_INT 34
62274: PUSH
62275: LD_INT 31
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 58
62284: PUSH
62285: EMPTY
62286: LIST
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PPUSH
62292: CALL_OW 72
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: PPUSH
62301: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
62305: LD_VAR 0 3
62309: PPUSH
62310: CALL_OW 310
62314: NOT
62315: IFTRUE 62351
62317: PUSH
62318: LD_VAR 0 3
62322: PPUSH
62323: CALL_OW 310
62327: PPUSH
62328: CALL_OW 266
62332: PUSH
62333: LD_INT 36
62335: NONEQUAL
62336: IFFALSE 62350
62338: PUSH
62339: LD_VAR 0 3
62343: PPUSH
62344: CALL 106651 0 1
62348: NOT
62349: AND
62350: OR
62351: IFFALSE 62493
// begin if IsInUnit ( j ) then
62353: LD_VAR 0 3
62357: PPUSH
62358: CALL_OW 310
62362: IFFALSE 62373
// ComExitBuilding ( j ) ;
62364: LD_VAR 0 3
62368: PPUSH
62369: CALL_OW 122
// ct := 0 ;
62373: LD_ADDR_VAR 0 8
62377: PUSH
62378: LD_INT 0
62380: ST_TO_ADDR
// for k in x do
62381: LD_ADDR_VAR 0 4
62385: PUSH
62386: LD_VAR 0 11
62390: PUSH
62391: FOR_IN
62392: IFFALSE 62471
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
62394: LD_VAR 0 4
62398: PPUSH
62399: CALL_OW 264
62403: PUSH
62404: LD_INT 31
62406: EQUAL
62407: IFFALSE 62421
62409: PUSH
62410: LD_VAR 0 4
62414: PPUSH
62415: CALL_OW 311
62419: NOT
62420: AND
62421: IFTRUE 62455
62423: PUSH
62424: LD_VAR 0 4
62428: PPUSH
62429: CALL_OW 266
62433: PUSH
62434: LD_INT 36
62436: EQUAL
62437: IFFALSE 62454
62439: PUSH
62440: LD_VAR 0 4
62444: PPUSH
62445: CALL_OW 313
62449: PUSH
62450: LD_INT 3
62452: LESS
62453: AND
62454: OR
62455: IFFALSE 62469
// begin ct := k ;
62457: LD_ADDR_VAR 0 8
62461: PUSH
62462: LD_VAR 0 4
62466: ST_TO_ADDR
// break ;
62467: GO 62471
// end ;
62469: GO 62391
62471: POP
62472: POP
// if ct then
62473: LD_VAR 0 8
62477: IFFALSE 62493
// ComEnterUnit ( j , ct ) ;
62479: LD_VAR 0 3
62483: PPUSH
62484: LD_VAR 0 8
62488: PPUSH
62489: CALL_OW 120
// end ; end ;
62493: GO 62116
62495: POP
62496: POP
// places := 0 ;
62497: LD_ADDR_VAR 0 5
62501: PUSH
62502: LD_INT 0
62504: ST_TO_ADDR
// for j = 1 to x do
62505: LD_ADDR_VAR 0 3
62509: PUSH
62510: DOUBLE
62511: LD_INT 1
62513: DEC
62514: ST_TO_ADDR
62515: LD_VAR 0 11
62519: PUSH
62520: FOR_TO
62521: IFFALSE 62597
// if GetWeapon ( x [ j ] ) = ar_control_tower then
62523: LD_VAR 0 11
62527: PUSH
62528: LD_VAR 0 3
62532: ARRAY
62533: PPUSH
62534: CALL_OW 264
62538: PUSH
62539: LD_INT 31
62541: EQUAL
62542: IFFALSE 62560
// places := places + 1 else
62544: LD_ADDR_VAR 0 5
62548: PUSH
62549: LD_VAR 0 5
62553: PUSH
62554: LD_INT 1
62556: PLUS
62557: ST_TO_ADDR
62558: GO 62595
// if GetBType ( x [ j ] ) = b_control_tower then
62560: LD_VAR 0 11
62564: PUSH
62565: LD_VAR 0 3
62569: ARRAY
62570: PPUSH
62571: CALL_OW 266
62575: PUSH
62576: LD_INT 36
62578: EQUAL
62579: IFFALSE 62595
// places := places + 3 ;
62581: LD_ADDR_VAR 0 5
62585: PUSH
62586: LD_VAR 0 5
62590: PUSH
62591: LD_INT 3
62593: PLUS
62594: ST_TO_ADDR
62595: GO 62520
62597: POP
62598: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62599: LD_VAR 0 5
62603: PUSH
62604: LD_INT 0
62606: EQUAL
62607: IFTRUE 62627
62609: PUSH
62610: LD_VAR 0 5
62614: PUSH
62615: LD_EXP 142
62619: PUSH
62620: LD_VAR 0 2
62624: ARRAY
62625: LESSEQUAL
62626: OR
62627: IFFALSE 62631
// continue ;
62629: GO 61861
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62631: LD_ADDR_VAR 0 6
62635: PUSH
62636: LD_EXP 102
62640: PUSH
62641: LD_VAR 0 2
62645: ARRAY
62646: PPUSH
62647: LD_INT 25
62649: PUSH
62650: LD_INT 3
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PPUSH
62657: CALL_OW 72
62661: PUSH
62662: LD_EXP 142
62666: PUSH
62667: LD_VAR 0 2
62671: ARRAY
62672: DIFF
62673: PPUSH
62674: LD_INT 3
62676: PPUSH
62677: CALL 107551 0 2
62681: ST_TO_ADDR
// for j in tmp do
62682: LD_ADDR_VAR 0 3
62686: PUSH
62687: LD_VAR 0 6
62691: PUSH
62692: FOR_IN
62693: IFFALSE 62728
// if GetTag ( j ) > 0 then
62695: LD_VAR 0 3
62699: PPUSH
62700: CALL_OW 110
62704: PUSH
62705: LD_INT 0
62707: GREATER
62708: IFFALSE 62726
// tmp := tmp diff j ;
62710: LD_ADDR_VAR 0 6
62714: PUSH
62715: LD_VAR 0 6
62719: PUSH
62720: LD_VAR 0 3
62724: DIFF
62725: ST_TO_ADDR
62726: GO 62692
62728: POP
62729: POP
// if not tmp then
62730: LD_VAR 0 6
62734: NOT
62735: IFFALSE 62739
// continue ;
62737: GO 61861
// if places then
62739: LD_VAR 0 5
62743: IFFALSE 62802
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62745: LD_ADDR_EXP 142
62749: PUSH
62750: LD_EXP 142
62754: PPUSH
62755: LD_VAR 0 2
62759: PPUSH
62760: LD_EXP 142
62764: PUSH
62765: LD_VAR 0 2
62769: ARRAY
62770: PUSH
62771: LD_VAR 0 6
62775: PUSH
62776: LD_INT 1
62778: ARRAY
62779: UNION
62780: PPUSH
62781: CALL_OW 1
62785: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62786: LD_VAR 0 6
62790: PUSH
62791: LD_INT 1
62793: ARRAY
62794: PPUSH
62795: LD_INT 126
62797: PPUSH
62798: CALL_OW 109
// end ; end ;
62802: GO 61861
62804: POP
62805: POP
// end ;
62806: LD_VAR 0 1
62810: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62811: LD_INT 0
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62819: LD_VAR 0 1
62823: NOT
62824: IFTRUE 62833
62826: PUSH
62827: LD_VAR 0 2
62831: NOT
62832: OR
62833: IFTRUE 62842
62835: PUSH
62836: LD_VAR 0 3
62840: NOT
62841: OR
62842: IFTRUE 62890
62844: PUSH
62845: LD_VAR 0 4
62849: PUSH
62850: LD_INT 1
62852: PUSH
62853: LD_INT 2
62855: PUSH
62856: LD_INT 3
62858: PUSH
62859: LD_INT 4
62861: PUSH
62862: LD_INT 5
62864: PUSH
62865: LD_INT 8
62867: PUSH
62868: LD_INT 9
62870: PUSH
62871: LD_INT 15
62873: PUSH
62874: LD_INT 16
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: LIST
62886: LIST
62887: IN
62888: NOT
62889: OR
62890: IFFALSE 62894
// exit ;
62892: GO 63754
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: LD_VAR 0 2
62903: PPUSH
62904: LD_INT 21
62906: PUSH
62907: LD_INT 3
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 24
62916: PUSH
62917: LD_INT 250
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PPUSH
62928: CALL_OW 72
62932: ST_TO_ADDR
// case class of 1 , 15 :
62933: LD_VAR 0 4
62937: PUSH
62938: LD_INT 1
62940: DOUBLE
62941: EQUAL
62942: IFTRUE 62952
62944: LD_INT 15
62946: DOUBLE
62947: EQUAL
62948: IFTRUE 62952
62950: GO 63037
62952: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62953: LD_ADDR_VAR 0 8
62957: PUSH
62958: LD_VAR 0 2
62962: PPUSH
62963: LD_INT 2
62965: PUSH
62966: LD_INT 30
62968: PUSH
62969: LD_INT 32
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 30
62978: PUSH
62979: LD_INT 31
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: LIST
62990: PPUSH
62991: CALL_OW 72
62995: PUSH
62996: LD_VAR 0 2
63000: PPUSH
63001: LD_INT 2
63003: PUSH
63004: LD_INT 30
63006: PUSH
63007: LD_INT 4
63009: PUSH
63010: EMPTY
63011: LIST
63012: LIST
63013: PUSH
63014: LD_INT 30
63016: PUSH
63017: LD_INT 5
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: LIST
63028: PPUSH
63029: CALL_OW 72
63033: ADD
63034: ST_TO_ADDR
63035: GO 63283
63037: LD_INT 2
63039: DOUBLE
63040: EQUAL
63041: IFTRUE 63051
63043: LD_INT 16
63045: DOUBLE
63046: EQUAL
63047: IFTRUE 63051
63049: GO 63097
63051: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63052: LD_ADDR_VAR 0 8
63056: PUSH
63057: LD_VAR 0 2
63061: PPUSH
63062: LD_INT 2
63064: PUSH
63065: LD_INT 30
63067: PUSH
63068: LD_INT 0
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 30
63077: PUSH
63078: LD_INT 1
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: LIST
63089: PPUSH
63090: CALL_OW 72
63094: ST_TO_ADDR
63095: GO 63283
63097: LD_INT 3
63099: DOUBLE
63100: EQUAL
63101: IFTRUE 63105
63103: GO 63151
63105: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63106: LD_ADDR_VAR 0 8
63110: PUSH
63111: LD_VAR 0 2
63115: PPUSH
63116: LD_INT 2
63118: PUSH
63119: LD_INT 30
63121: PUSH
63122: LD_INT 2
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 30
63131: PUSH
63132: LD_INT 3
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: LIST
63143: PPUSH
63144: CALL_OW 72
63148: ST_TO_ADDR
63149: GO 63283
63151: LD_INT 4
63153: DOUBLE
63154: EQUAL
63155: IFTRUE 63159
63157: GO 63216
63159: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
63160: LD_ADDR_VAR 0 8
63164: PUSH
63165: LD_VAR 0 2
63169: PPUSH
63170: LD_INT 2
63172: PUSH
63173: LD_INT 30
63175: PUSH
63176: LD_INT 6
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 30
63185: PUSH
63186: LD_INT 7
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 30
63195: PUSH
63196: LD_INT 8
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: PPUSH
63209: CALL_OW 72
63213: ST_TO_ADDR
63214: GO 63283
63216: LD_INT 5
63218: DOUBLE
63219: EQUAL
63220: IFTRUE 63236
63222: LD_INT 8
63224: DOUBLE
63225: EQUAL
63226: IFTRUE 63236
63228: LD_INT 9
63230: DOUBLE
63231: EQUAL
63232: IFTRUE 63236
63234: GO 63282
63236: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
63237: LD_ADDR_VAR 0 8
63241: PUSH
63242: LD_VAR 0 2
63246: PPUSH
63247: LD_INT 2
63249: PUSH
63250: LD_INT 30
63252: PUSH
63253: LD_INT 4
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 30
63262: PUSH
63263: LD_INT 5
63265: PUSH
63266: EMPTY
63267: LIST
63268: LIST
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: LIST
63274: PPUSH
63275: CALL_OW 72
63279: ST_TO_ADDR
63280: GO 63283
63282: POP
// if not tmp then
63283: LD_VAR 0 8
63287: NOT
63288: IFFALSE 63292
// exit ;
63290: GO 63754
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
63292: LD_VAR 0 4
63296: PUSH
63297: LD_INT 1
63299: PUSH
63300: LD_INT 15
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: IN
63307: IFFALSE 63321
63309: PUSH
63310: LD_EXP 111
63314: PUSH
63315: LD_VAR 0 1
63319: ARRAY
63320: AND
63321: IFFALSE 63477
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
63323: LD_ADDR_VAR 0 9
63327: PUSH
63328: LD_EXP 111
63332: PUSH
63333: LD_VAR 0 1
63337: ARRAY
63338: PUSH
63339: LD_INT 1
63341: ARRAY
63342: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
63343: LD_VAR 0 9
63347: PUSH
63348: LD_EXP 112
63352: PUSH
63353: LD_VAR 0 1
63357: ARRAY
63358: IN
63359: NOT
63360: IFFALSE 63475
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
63362: LD_ADDR_EXP 112
63366: PUSH
63367: LD_EXP 112
63371: PPUSH
63372: LD_VAR 0 1
63376: PUSH
63377: LD_EXP 112
63381: PUSH
63382: LD_VAR 0 1
63386: ARRAY
63387: PUSH
63388: LD_INT 1
63390: PLUS
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PPUSH
63396: LD_VAR 0 9
63400: PPUSH
63401: CALL 76023 0 3
63405: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
63406: LD_ADDR_EXP 111
63410: PUSH
63411: LD_EXP 111
63415: PPUSH
63416: LD_VAR 0 1
63420: PPUSH
63421: LD_EXP 111
63425: PUSH
63426: LD_VAR 0 1
63430: ARRAY
63431: PUSH
63432: LD_VAR 0 9
63436: DIFF
63437: PPUSH
63438: CALL_OW 1
63442: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
63443: LD_VAR 0 3
63447: PPUSH
63448: LD_EXP 112
63452: PUSH
63453: LD_VAR 0 1
63457: ARRAY
63458: PUSH
63459: LD_EXP 112
63463: PUSH
63464: LD_VAR 0 1
63468: ARRAY
63469: ARRAY
63470: PPUSH
63471: CALL_OW 120
// end ; exit ;
63475: GO 63754
// end ; if tmp > 1 then
63477: LD_VAR 0 8
63481: PUSH
63482: LD_INT 1
63484: GREATER
63485: IFFALSE 63589
// for i = 2 to tmp do
63487: LD_ADDR_VAR 0 6
63491: PUSH
63492: DOUBLE
63493: LD_INT 2
63495: DEC
63496: ST_TO_ADDR
63497: LD_VAR 0 8
63501: PUSH
63502: FOR_TO
63503: IFFALSE 63587
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
63505: LD_VAR 0 8
63509: PUSH
63510: LD_VAR 0 6
63514: ARRAY
63515: PPUSH
63516: CALL_OW 461
63520: PUSH
63521: LD_INT 6
63523: EQUAL
63524: IFFALSE 63585
// begin x := tmp [ i ] ;
63526: LD_ADDR_VAR 0 9
63530: PUSH
63531: LD_VAR 0 8
63535: PUSH
63536: LD_VAR 0 6
63540: ARRAY
63541: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
63542: LD_ADDR_VAR 0 8
63546: PUSH
63547: LD_VAR 0 8
63551: PPUSH
63552: LD_VAR 0 6
63556: PPUSH
63557: CALL_OW 3
63561: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63562: LD_ADDR_VAR 0 8
63566: PUSH
63567: LD_VAR 0 8
63571: PPUSH
63572: LD_INT 1
63574: PPUSH
63575: LD_VAR 0 9
63579: PPUSH
63580: CALL_OW 2
63584: ST_TO_ADDR
// end ;
63585: GO 63502
63587: POP
63588: POP
// for i in tmp do
63589: LD_ADDR_VAR 0 6
63593: PUSH
63594: LD_VAR 0 8
63598: PUSH
63599: FOR_IN
63600: IFFALSE 63627
// begin if IsNotFull ( i ) then
63602: LD_VAR 0 6
63606: PPUSH
63607: CALL 73221 0 1
63611: IFFALSE 63625
// begin j := i ;
63613: LD_ADDR_VAR 0 7
63617: PUSH
63618: LD_VAR 0 6
63622: ST_TO_ADDR
// break ;
63623: GO 63627
// end ; end ;
63625: GO 63599
63627: POP
63628: POP
// if j then
63629: LD_VAR 0 7
63633: IFFALSE 63651
// ComEnterUnit ( unit , j ) else
63635: LD_VAR 0 3
63639: PPUSH
63640: LD_VAR 0 7
63644: PPUSH
63645: CALL_OW 120
63649: GO 63754
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63651: LD_ADDR_VAR 0 10
63655: PUSH
63656: LD_VAR 0 2
63660: PPUSH
63661: LD_INT 2
63663: PUSH
63664: LD_INT 30
63666: PUSH
63667: LD_INT 0
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 30
63676: PUSH
63677: LD_INT 1
63679: PUSH
63680: EMPTY
63681: LIST
63682: LIST
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: LIST
63688: PPUSH
63689: CALL_OW 72
63693: ST_TO_ADDR
// if depot then
63694: LD_VAR 0 10
63698: IFFALSE 63754
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63700: LD_ADDR_VAR 0 10
63704: PUSH
63705: LD_VAR 0 10
63709: PPUSH
63710: LD_VAR 0 3
63714: PPUSH
63715: CALL_OW 74
63719: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63720: LD_VAR 0 3
63724: PPUSH
63725: LD_VAR 0 10
63729: PPUSH
63730: CALL_OW 296
63734: PUSH
63735: LD_INT 10
63737: GREATER
63738: IFFALSE 63754
// ComStandNearbyBuilding ( unit , depot ) ;
63740: LD_VAR 0 3
63744: PPUSH
63745: LD_VAR 0 10
63749: PPUSH
63750: CALL 72599 0 2
// end ; end ; end ;
63754: LD_VAR 0 5
63758: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63759: LD_INT 0
63761: PPUSH
63762: PPUSH
63763: PPUSH
63764: PPUSH
// if not mc_bases then
63765: LD_EXP 102
63769: NOT
63770: IFFALSE 63774
// exit ;
63772: GO 64025
// for i = 1 to mc_bases do
63774: LD_ADDR_VAR 0 2
63778: PUSH
63779: DOUBLE
63780: LD_INT 1
63782: DEC
63783: ST_TO_ADDR
63784: LD_EXP 102
63788: PUSH
63789: FOR_TO
63790: IFFALSE 64023
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63792: LD_ADDR_VAR 0 4
63796: PUSH
63797: LD_EXP 102
63801: PUSH
63802: LD_VAR 0 2
63806: ARRAY
63807: PPUSH
63808: LD_INT 21
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PPUSH
63818: CALL_OW 72
63822: PUSH
63823: LD_EXP 131
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: UNION
63834: ST_TO_ADDR
// if not tmp then
63835: LD_VAR 0 4
63839: NOT
63840: IFFALSE 63844
// continue ;
63842: GO 63789
// for j in tmp do
63844: LD_ADDR_VAR 0 3
63848: PUSH
63849: LD_VAR 0 4
63853: PUSH
63854: FOR_IN
63855: IFFALSE 64019
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63857: LD_VAR 0 3
63861: PPUSH
63862: CALL_OW 110
63866: NOT
63867: IFFALSE 63881
63869: PUSH
63870: LD_VAR 0 3
63874: PPUSH
63875: CALL_OW 314
63879: NOT
63880: AND
63881: IFFALSE 63895
63883: PUSH
63884: LD_VAR 0 3
63888: PPUSH
63889: CALL_OW 311
63893: NOT
63894: AND
63895: IFFALSE 63909
63897: PUSH
63898: LD_VAR 0 3
63902: PPUSH
63903: CALL_OW 310
63907: NOT
63908: AND
63909: IFFALSE 63934
63911: PUSH
63912: LD_VAR 0 3
63916: PUSH
63917: LD_EXP 105
63921: PUSH
63922: LD_VAR 0 2
63926: ARRAY
63927: PUSH
63928: LD_INT 1
63930: ARRAY
63931: IN
63932: NOT
63933: AND
63934: IFFALSE 63959
63936: PUSH
63937: LD_VAR 0 3
63941: PUSH
63942: LD_EXP 105
63946: PUSH
63947: LD_VAR 0 2
63951: ARRAY
63952: PUSH
63953: LD_INT 2
63955: ARRAY
63956: IN
63957: NOT
63958: AND
63959: IFFALSE 63980
63961: PUSH
63962: LD_VAR 0 3
63966: PUSH
63967: LD_EXP 114
63971: PUSH
63972: LD_VAR 0 2
63976: ARRAY
63977: IN
63978: NOT
63979: AND
63980: IFFALSE 64017
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63982: LD_VAR 0 2
63986: PPUSH
63987: LD_EXP 102
63991: PUSH
63992: LD_VAR 0 2
63996: ARRAY
63997: PPUSH
63998: LD_VAR 0 3
64002: PPUSH
64003: LD_VAR 0 3
64007: PPUSH
64008: CALL_OW 257
64012: PPUSH
64013: CALL 62811 0 4
// end ;
64017: GO 63854
64019: POP
64020: POP
// end ;
64021: GO 63789
64023: POP
64024: POP
// end ;
64025: LD_VAR 0 1
64029: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
64030: LD_INT 0
64032: PPUSH
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
64037: PPUSH
// if not mc_bases [ base ] then
64038: LD_EXP 102
64042: PUSH
64043: LD_VAR 0 1
64047: ARRAY
64048: NOT
64049: IFFALSE 64053
// exit ;
64051: GO 64254
// tmp := [ ] ;
64053: LD_ADDR_VAR 0 6
64057: PUSH
64058: EMPTY
64059: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64060: LD_ADDR_VAR 0 7
64064: PUSH
64065: LD_VAR 0 3
64069: PPUSH
64070: LD_INT 0
64072: PPUSH
64073: CALL_OW 517
64077: ST_TO_ADDR
// if not list then
64078: LD_VAR 0 7
64082: NOT
64083: IFFALSE 64087
// exit ;
64085: GO 64254
// c := Count ( list [ 1 ] ) ;
64087: LD_ADDR_VAR 0 9
64091: PUSH
64092: LD_VAR 0 7
64096: PUSH
64097: LD_INT 1
64099: ARRAY
64100: PPUSH
64101: CALL 73139 0 1
64105: ST_TO_ADDR
// if amount > c then
64106: LD_VAR 0 2
64110: PUSH
64111: LD_VAR 0 9
64115: GREATER
64116: IFFALSE 64128
// amount := c ;
64118: LD_ADDR_VAR 0 2
64122: PUSH
64123: LD_VAR 0 9
64127: ST_TO_ADDR
// for i := 1 to amount do
64128: LD_ADDR_VAR 0 5
64132: PUSH
64133: DOUBLE
64134: LD_INT 1
64136: DEC
64137: ST_TO_ADDR
64138: LD_VAR 0 2
64142: PUSH
64143: FOR_TO
64144: IFFALSE 64202
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
64146: LD_ADDR_VAR 0 6
64150: PUSH
64151: LD_VAR 0 6
64155: PPUSH
64156: LD_VAR 0 5
64160: PPUSH
64161: LD_VAR 0 7
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: PUSH
64170: LD_VAR 0 5
64174: ARRAY
64175: PUSH
64176: LD_VAR 0 7
64180: PUSH
64181: LD_INT 2
64183: ARRAY
64184: PUSH
64185: LD_VAR 0 5
64189: ARRAY
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PPUSH
64195: CALL_OW 1
64199: ST_TO_ADDR
64200: GO 64143
64202: POP
64203: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
64204: LD_ADDR_EXP 115
64208: PUSH
64209: LD_EXP 115
64213: PPUSH
64214: LD_VAR 0 1
64218: PPUSH
64219: LD_VAR 0 6
64223: PPUSH
64224: CALL_OW 1
64228: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
64229: LD_ADDR_EXP 117
64233: PUSH
64234: LD_EXP 117
64238: PPUSH
64239: LD_VAR 0 1
64243: PPUSH
64244: LD_VAR 0 3
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// end ;
64254: LD_VAR 0 4
64258: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
64259: LD_INT 0
64261: PPUSH
// if not mc_bases [ base ] then
64262: LD_EXP 102
64266: PUSH
64267: LD_VAR 0 1
64271: ARRAY
64272: NOT
64273: IFFALSE 64277
// exit ;
64275: GO 64302
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
64277: LD_ADDR_EXP 107
64281: PUSH
64282: LD_EXP 107
64286: PPUSH
64287: LD_VAR 0 1
64291: PPUSH
64292: LD_VAR 0 2
64296: PPUSH
64297: CALL_OW 1
64301: ST_TO_ADDR
// end ;
64302: LD_VAR 0 3
64306: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
64307: LD_INT 0
64309: PPUSH
// if not mc_bases [ base ] then
64310: LD_EXP 102
64314: PUSH
64315: LD_VAR 0 1
64319: ARRAY
64320: NOT
64321: IFFALSE 64325
// exit ;
64323: GO 64362
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
64325: LD_ADDR_EXP 107
64329: PUSH
64330: LD_EXP 107
64334: PPUSH
64335: LD_VAR 0 1
64339: PPUSH
64340: LD_EXP 107
64344: PUSH
64345: LD_VAR 0 1
64349: ARRAY
64350: PUSH
64351: LD_VAR 0 2
64355: UNION
64356: PPUSH
64357: CALL_OW 1
64361: ST_TO_ADDR
// end ;
64362: LD_VAR 0 3
64366: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
64367: LD_INT 0
64369: PPUSH
// if not mc_bases [ base ] then
64370: LD_EXP 102
64374: PUSH
64375: LD_VAR 0 1
64379: ARRAY
64380: NOT
64381: IFFALSE 64385
// exit ;
64383: GO 64410
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
64385: LD_ADDR_EXP 123
64389: PUSH
64390: LD_EXP 123
64394: PPUSH
64395: LD_VAR 0 1
64399: PPUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: CALL_OW 1
64409: ST_TO_ADDR
// end ;
64410: LD_VAR 0 3
64414: RET
// export function MC_InsertProduceList ( base , components ) ; begin
64415: LD_INT 0
64417: PPUSH
// if not mc_bases [ base ] then
64418: LD_EXP 102
64422: PUSH
64423: LD_VAR 0 1
64427: ARRAY
64428: NOT
64429: IFFALSE 64433
// exit ;
64431: GO 64470
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
64433: LD_ADDR_EXP 123
64437: PUSH
64438: LD_EXP 123
64442: PPUSH
64443: LD_VAR 0 1
64447: PPUSH
64448: LD_EXP 123
64452: PUSH
64453: LD_VAR 0 1
64457: ARRAY
64458: PUSH
64459: LD_VAR 0 2
64463: ADD
64464: PPUSH
64465: CALL_OW 1
64469: ST_TO_ADDR
// end ;
64470: LD_VAR 0 3
64474: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
64475: LD_INT 0
64477: PPUSH
// if not mc_bases [ base ] then
64478: LD_EXP 102
64482: PUSH
64483: LD_VAR 0 1
64487: ARRAY
64488: NOT
64489: IFFALSE 64493
// exit ;
64491: GO 64547
// mc_defender := Replace ( mc_defender , base , deflist ) ;
64493: LD_ADDR_EXP 124
64497: PUSH
64498: LD_EXP 124
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: LD_VAR 0 2
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
64518: LD_ADDR_EXP 113
64522: PUSH
64523: LD_EXP 113
64527: PPUSH
64528: LD_VAR 0 1
64532: PPUSH
64533: LD_VAR 0 2
64537: PUSH
64538: LD_INT 0
64540: PLUS
64541: PPUSH
64542: CALL_OW 1
64546: ST_TO_ADDR
// end ;
64547: LD_VAR 0 3
64551: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
64552: LD_INT 0
64554: PPUSH
// if not mc_bases [ base ] then
64555: LD_EXP 102
64559: PUSH
64560: LD_VAR 0 1
64564: ARRAY
64565: NOT
64566: IFFALSE 64570
// exit ;
64568: GO 64595
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64570: LD_ADDR_EXP 113
64574: PUSH
64575: LD_EXP 113
64579: PPUSH
64580: LD_VAR 0 1
64584: PPUSH
64585: LD_VAR 0 2
64589: PPUSH
64590: CALL_OW 1
64594: ST_TO_ADDR
// end ;
64595: LD_VAR 0 3
64599: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64600: LD_INT 0
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
// if not mc_bases [ base ] then
64606: LD_EXP 102
64610: PUSH
64611: LD_VAR 0 1
64615: ARRAY
64616: NOT
64617: IFFALSE 64621
// exit ;
64619: GO 64686
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64621: LD_ADDR_EXP 122
64625: PUSH
64626: LD_EXP 122
64630: PPUSH
64631: LD_VAR 0 1
64635: PUSH
64636: LD_EXP 122
64640: PUSH
64641: LD_VAR 0 1
64645: ARRAY
64646: PUSH
64647: LD_INT 1
64649: PLUS
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PPUSH
64655: LD_VAR 0 1
64659: PUSH
64660: LD_VAR 0 2
64664: PUSH
64665: LD_VAR 0 3
64669: PUSH
64670: LD_VAR 0 4
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: PPUSH
64681: CALL 76023 0 3
64685: ST_TO_ADDR
// end ;
64686: LD_VAR 0 5
64690: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64691: LD_INT 0
64693: PPUSH
// if not mc_bases [ base ] then
64694: LD_EXP 102
64698: PUSH
64699: LD_VAR 0 1
64703: ARRAY
64704: NOT
64705: IFFALSE 64709
// exit ;
64707: GO 64734
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64709: LD_ADDR_EXP 139
64713: PUSH
64714: LD_EXP 139
64718: PPUSH
64719: LD_VAR 0 1
64723: PPUSH
64724: LD_VAR 0 2
64728: PPUSH
64729: CALL_OW 1
64733: ST_TO_ADDR
// end ;
64734: LD_VAR 0 3
64738: RET
// export function MC_GetMinesField ( base ) ; begin
64739: LD_INT 0
64741: PPUSH
// result := mc_mines [ base ] ;
64742: LD_ADDR_VAR 0 2
64746: PUSH
64747: LD_EXP 115
64751: PUSH
64752: LD_VAR 0 1
64756: ARRAY
64757: ST_TO_ADDR
// end ;
64758: LD_VAR 0 2
64762: RET
// export function MC_GetProduceList ( base ) ; begin
64763: LD_INT 0
64765: PPUSH
// result := mc_produce [ base ] ;
64766: LD_ADDR_VAR 0 2
64770: PUSH
64771: LD_EXP 123
64775: PUSH
64776: LD_VAR 0 1
64780: ARRAY
64781: ST_TO_ADDR
// end ;
64782: LD_VAR 0 2
64786: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64787: LD_INT 0
64789: PPUSH
64790: PPUSH
// if not mc_bases then
64791: LD_EXP 102
64795: NOT
64796: IFFALSE 64800
// exit ;
64798: GO 64865
// if mc_bases [ base ] then
64800: LD_EXP 102
64804: PUSH
64805: LD_VAR 0 1
64809: ARRAY
64810: IFFALSE 64865
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64812: LD_ADDR_VAR 0 3
64816: PUSH
64817: LD_EXP 102
64821: PUSH
64822: LD_VAR 0 1
64826: ARRAY
64827: PPUSH
64828: LD_INT 30
64830: PUSH
64831: LD_VAR 0 2
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PPUSH
64840: CALL_OW 72
64844: ST_TO_ADDR
// if result then
64845: LD_VAR 0 3
64849: IFFALSE 64865
// result := result [ 1 ] ;
64851: LD_ADDR_VAR 0 3
64855: PUSH
64856: LD_VAR 0 3
64860: PUSH
64861: LD_INT 1
64863: ARRAY
64864: ST_TO_ADDR
// end ; end ;
64865: LD_VAR 0 3
64869: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64870: LD_INT 0
64872: PPUSH
64873: PPUSH
// if not mc_bases then
64874: LD_EXP 102
64878: NOT
64879: IFFALSE 64883
// exit ;
64881: GO 64928
// if mc_bases [ base ] then
64883: LD_EXP 102
64887: PUSH
64888: LD_VAR 0 1
64892: ARRAY
64893: IFFALSE 64928
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64895: LD_ADDR_VAR 0 3
64899: PUSH
64900: LD_EXP 102
64904: PUSH
64905: LD_VAR 0 1
64909: ARRAY
64910: PPUSH
64911: LD_INT 30
64913: PUSH
64914: LD_VAR 0 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PPUSH
64923: CALL_OW 72
64927: ST_TO_ADDR
// end ;
64928: LD_VAR 0 3
64932: RET
// export function MC_SetTame ( base , area ) ; begin
64933: LD_INT 0
64935: PPUSH
// if not mc_bases or not base then
64936: LD_EXP 102
64940: NOT
64941: IFTRUE 64950
64943: PUSH
64944: LD_VAR 0 1
64948: NOT
64949: OR
64950: IFFALSE 64954
// exit ;
64952: GO 64979
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64954: LD_ADDR_EXP 130
64958: PUSH
64959: LD_EXP 130
64963: PPUSH
64964: LD_VAR 0 1
64968: PPUSH
64969: LD_VAR 0 2
64973: PPUSH
64974: CALL_OW 1
64978: ST_TO_ADDR
// end ;
64979: LD_VAR 0 3
64983: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64984: LD_INT 0
64986: PPUSH
64987: PPUSH
// if not mc_bases or not base then
64988: LD_EXP 102
64992: NOT
64993: IFTRUE 65002
64995: PUSH
64996: LD_VAR 0 1
65000: NOT
65001: OR
65002: IFFALSE 65006
// exit ;
65004: GO 65108
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65006: LD_ADDR_VAR 0 4
65010: PUSH
65011: LD_EXP 102
65015: PUSH
65016: LD_VAR 0 1
65020: ARRAY
65021: PPUSH
65022: LD_INT 30
65024: PUSH
65025: LD_VAR 0 2
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PPUSH
65034: CALL_OW 72
65038: ST_TO_ADDR
// if not tmp then
65039: LD_VAR 0 4
65043: NOT
65044: IFFALSE 65048
// exit ;
65046: GO 65108
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65048: LD_ADDR_EXP 134
65052: PUSH
65053: LD_EXP 134
65057: PPUSH
65058: LD_VAR 0 1
65062: PPUSH
65063: LD_EXP 134
65067: PUSH
65068: LD_VAR 0 1
65072: ARRAY
65073: PPUSH
65074: LD_EXP 134
65078: PUSH
65079: LD_VAR 0 1
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: PLUS
65088: PPUSH
65089: LD_VAR 0 4
65093: PUSH
65094: LD_INT 1
65096: ARRAY
65097: PPUSH
65098: CALL_OW 2
65102: PPUSH
65103: CALL_OW 1
65107: ST_TO_ADDR
// end ;
65108: LD_VAR 0 3
65112: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65113: LD_INT 0
65115: PPUSH
65116: PPUSH
// if not mc_bases or not base or not kinds then
65117: LD_EXP 102
65121: NOT
65122: IFTRUE 65131
65124: PUSH
65125: LD_VAR 0 1
65129: NOT
65130: OR
65131: IFTRUE 65140
65133: PUSH
65134: LD_VAR 0 2
65138: NOT
65139: OR
65140: IFFALSE 65144
// exit ;
65142: GO 65205
// for i in kinds do
65144: LD_ADDR_VAR 0 4
65148: PUSH
65149: LD_VAR 0 2
65153: PUSH
65154: FOR_IN
65155: IFFALSE 65203
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
65157: LD_ADDR_EXP 136
65161: PUSH
65162: LD_EXP 136
65166: PPUSH
65167: LD_VAR 0 1
65171: PUSH
65172: LD_EXP 136
65176: PUSH
65177: LD_VAR 0 1
65181: ARRAY
65182: PUSH
65183: LD_INT 1
65185: PLUS
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PPUSH
65191: LD_VAR 0 4
65195: PPUSH
65196: CALL 76023 0 3
65200: ST_TO_ADDR
65201: GO 65154
65203: POP
65204: POP
// end ;
65205: LD_VAR 0 3
65209: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
65210: LD_INT 0
65212: PPUSH
// if not mc_bases or not base or not areas then
65213: LD_EXP 102
65217: NOT
65218: IFTRUE 65227
65220: PUSH
65221: LD_VAR 0 1
65225: NOT
65226: OR
65227: IFTRUE 65236
65229: PUSH
65230: LD_VAR 0 2
65234: NOT
65235: OR
65236: IFFALSE 65240
// exit ;
65238: GO 65265
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
65240: LD_ADDR_EXP 120
65244: PUSH
65245: LD_EXP 120
65249: PPUSH
65250: LD_VAR 0 1
65254: PPUSH
65255: LD_VAR 0 2
65259: PPUSH
65260: CALL_OW 1
65264: ST_TO_ADDR
// end ;
65265: LD_VAR 0 3
65269: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
65270: LD_INT 0
65272: PPUSH
// if not mc_bases or not base or not teleports_exit then
65273: LD_EXP 102
65277: NOT
65278: IFTRUE 65287
65280: PUSH
65281: LD_VAR 0 1
65285: NOT
65286: OR
65287: IFTRUE 65296
65289: PUSH
65290: LD_VAR 0 2
65294: NOT
65295: OR
65296: IFFALSE 65300
// exit ;
65298: GO 65325
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
65300: LD_ADDR_EXP 137
65304: PUSH
65305: LD_EXP 137
65309: PPUSH
65310: LD_VAR 0 1
65314: PPUSH
65315: LD_VAR 0 2
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// end ;
65325: LD_VAR 0 3
65329: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
65330: LD_INT 0
65332: PPUSH
65333: PPUSH
65334: PPUSH
// if not mc_bases or not base or not ext_list then
65335: LD_EXP 102
65339: NOT
65340: IFTRUE 65349
65342: PUSH
65343: LD_VAR 0 1
65347: NOT
65348: OR
65349: IFTRUE 65358
65351: PUSH
65352: LD_VAR 0 5
65356: NOT
65357: OR
65358: IFFALSE 65362
// exit ;
65360: GO 65535
// tmp := GetFacExtXYD ( x , y , d ) ;
65362: LD_ADDR_VAR 0 8
65366: PUSH
65367: LD_VAR 0 2
65371: PPUSH
65372: LD_VAR 0 3
65376: PPUSH
65377: LD_VAR 0 4
65381: PPUSH
65382: CALL 106681 0 3
65386: ST_TO_ADDR
// if not tmp then
65387: LD_VAR 0 8
65391: NOT
65392: IFFALSE 65396
// exit ;
65394: GO 65535
// for i in tmp do
65396: LD_ADDR_VAR 0 7
65400: PUSH
65401: LD_VAR 0 8
65405: PUSH
65406: FOR_IN
65407: IFFALSE 65533
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
65409: LD_ADDR_EXP 107
65413: PUSH
65414: LD_EXP 107
65418: PPUSH
65419: LD_VAR 0 1
65423: PPUSH
65424: LD_EXP 107
65428: PUSH
65429: LD_VAR 0 1
65433: ARRAY
65434: PPUSH
65435: LD_EXP 107
65439: PUSH
65440: LD_VAR 0 1
65444: ARRAY
65445: PUSH
65446: LD_INT 1
65448: PLUS
65449: PPUSH
65450: LD_VAR 0 5
65454: PUSH
65455: LD_INT 1
65457: ARRAY
65458: PUSH
65459: LD_VAR 0 7
65463: PUSH
65464: LD_INT 1
65466: ARRAY
65467: PUSH
65468: LD_VAR 0 7
65472: PUSH
65473: LD_INT 2
65475: ARRAY
65476: PUSH
65477: LD_VAR 0 7
65481: PUSH
65482: LD_INT 3
65484: ARRAY
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: CALL_OW 2
65496: PPUSH
65497: CALL_OW 1
65501: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
65502: LD_ADDR_VAR 0 5
65506: PUSH
65507: LD_VAR 0 5
65511: PPUSH
65512: LD_INT 1
65514: PPUSH
65515: CALL_OW 3
65519: ST_TO_ADDR
// if not ext_list then
65520: LD_VAR 0 5
65524: NOT
65525: IFFALSE 65531
// exit ;
65527: POP
65528: POP
65529: GO 65535
// end ;
65531: GO 65406
65533: POP
65534: POP
// end ;
65535: LD_VAR 0 6
65539: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
65540: LD_INT 0
65542: PPUSH
// if not mc_bases or not base or not weapon_list then
65543: LD_EXP 102
65547: NOT
65548: IFTRUE 65557
65550: PUSH
65551: LD_VAR 0 1
65555: NOT
65556: OR
65557: IFTRUE 65566
65559: PUSH
65560: LD_VAR 0 2
65564: NOT
65565: OR
65566: IFFALSE 65570
// exit ;
65568: GO 65595
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
65570: LD_ADDR_EXP 141
65574: PUSH
65575: LD_EXP 141
65579: PPUSH
65580: LD_VAR 0 1
65584: PPUSH
65585: LD_VAR 0 2
65589: PPUSH
65590: CALL_OW 1
65594: ST_TO_ADDR
// end ;
65595: LD_VAR 0 3
65599: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65600: LD_INT 0
65602: PPUSH
// if not mc_bases or not base or not tech_list then
65603: LD_EXP 102
65607: NOT
65608: IFTRUE 65617
65610: PUSH
65611: LD_VAR 0 1
65615: NOT
65616: OR
65617: IFTRUE 65626
65619: PUSH
65620: LD_VAR 0 2
65624: NOT
65625: OR
65626: IFFALSE 65630
// exit ;
65628: GO 65655
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65630: LD_ADDR_EXP 129
65634: PUSH
65635: LD_EXP 129
65639: PPUSH
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 2
65649: PPUSH
65650: CALL_OW 1
65654: ST_TO_ADDR
// end ;
65655: LD_VAR 0 3
65659: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65660: LD_INT 0
65662: PPUSH
// if not mc_bases or not parking_area or not base then
65663: LD_EXP 102
65667: NOT
65668: IFTRUE 65677
65670: PUSH
65671: LD_VAR 0 2
65675: NOT
65676: OR
65677: IFTRUE 65686
65679: PUSH
65680: LD_VAR 0 1
65684: NOT
65685: OR
65686: IFFALSE 65690
// exit ;
65688: GO 65715
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65690: LD_ADDR_EXP 126
65694: PUSH
65695: LD_EXP 126
65699: PPUSH
65700: LD_VAR 0 1
65704: PPUSH
65705: LD_VAR 0 2
65709: PPUSH
65710: CALL_OW 1
65714: ST_TO_ADDR
// end ;
65715: LD_VAR 0 3
65719: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65720: LD_INT 0
65722: PPUSH
// if not mc_bases or not base or not scan_area then
65723: LD_EXP 102
65727: NOT
65728: IFTRUE 65737
65730: PUSH
65731: LD_VAR 0 1
65735: NOT
65736: OR
65737: IFTRUE 65746
65739: PUSH
65740: LD_VAR 0 2
65744: NOT
65745: OR
65746: IFFALSE 65750
// exit ;
65748: GO 65775
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65750: LD_ADDR_EXP 127
65754: PUSH
65755: LD_EXP 127
65759: PPUSH
65760: LD_VAR 0 1
65764: PPUSH
65765: LD_VAR 0 2
65769: PPUSH
65770: CALL_OW 1
65774: ST_TO_ADDR
// end ;
65775: LD_VAR 0 3
65779: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65780: LD_INT 0
65782: PPUSH
65783: PPUSH
// if not mc_bases or not base then
65784: LD_EXP 102
65788: NOT
65789: IFTRUE 65798
65791: PUSH
65792: LD_VAR 0 1
65796: NOT
65797: OR
65798: IFFALSE 65802
// exit ;
65800: GO 65866
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65802: LD_ADDR_VAR 0 3
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 3
65815: PUSH
65816: LD_INT 4
65818: PUSH
65819: LD_INT 11
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65829: LD_ADDR_EXP 129
65833: PUSH
65834: LD_EXP 129
65838: PPUSH
65839: LD_VAR 0 1
65843: PPUSH
65844: LD_EXP 129
65848: PUSH
65849: LD_VAR 0 1
65853: ARRAY
65854: PUSH
65855: LD_VAR 0 3
65859: DIFF
65860: PPUSH
65861: CALL_OW 1
65865: ST_TO_ADDR
// end ;
65866: LD_VAR 0 2
65870: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65871: LD_INT 0
65873: PPUSH
// result := mc_vehicles [ base ] ;
65874: LD_ADDR_VAR 0 3
65878: PUSH
65879: LD_EXP 121
65883: PUSH
65884: LD_VAR 0 1
65888: ARRAY
65889: ST_TO_ADDR
// if onlyCombat then
65890: LD_VAR 0 2
65894: IFFALSE 66066
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65896: LD_ADDR_VAR 0 3
65900: PUSH
65901: LD_VAR 0 3
65905: PUSH
65906: LD_VAR 0 3
65910: PPUSH
65911: LD_INT 2
65913: PUSH
65914: LD_INT 34
65916: PUSH
65917: LD_INT 12
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 34
65926: PUSH
65927: LD_INT 51
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 34
65936: PUSH
65937: LD_INT 89
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 34
65946: PUSH
65947: LD_INT 32
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 34
65956: PUSH
65957: LD_INT 13
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 34
65966: PUSH
65967: LD_INT 52
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 34
65976: PUSH
65977: LD_INT 88
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 34
65986: PUSH
65987: LD_INT 14
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 34
65996: PUSH
65997: LD_INT 53
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 34
66006: PUSH
66007: LD_INT 98
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 34
66016: PUSH
66017: LD_INT 31
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 34
66026: PUSH
66027: LD_INT 48
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 34
66036: PUSH
66037: LD_INT 8
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: PPUSH
66060: CALL_OW 72
66064: DIFF
66065: ST_TO_ADDR
// end ; end_of_file
66066: LD_VAR 0 3
66070: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66071: LD_INT 0
66073: PPUSH
66074: PPUSH
66075: PPUSH
// if not mc_bases or not skirmish then
66076: LD_EXP 102
66080: NOT
66081: IFTRUE 66090
66083: PUSH
66084: LD_EXP 100
66088: NOT
66089: OR
66090: IFFALSE 66094
// exit ;
66092: GO 66259
// for i = 1 to mc_bases do
66094: LD_ADDR_VAR 0 4
66098: PUSH
66099: DOUBLE
66100: LD_INT 1
66102: DEC
66103: ST_TO_ADDR
66104: LD_EXP 102
66108: PUSH
66109: FOR_TO
66110: IFFALSE 66257
// begin if sci in mc_bases [ i ] then
66112: LD_VAR 0 2
66116: PUSH
66117: LD_EXP 102
66121: PUSH
66122: LD_VAR 0 4
66126: ARRAY
66127: IN
66128: IFFALSE 66255
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66130: LD_ADDR_EXP 131
66134: PUSH
66135: LD_EXP 131
66139: PPUSH
66140: LD_VAR 0 4
66144: PUSH
66145: LD_EXP 131
66149: PUSH
66150: LD_VAR 0 4
66154: ARRAY
66155: PUSH
66156: LD_INT 1
66158: PLUS
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PPUSH
66164: LD_VAR 0 1
66168: PPUSH
66169: CALL 76023 0 3
66173: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
66174: LD_ADDR_VAR 0 5
66178: PUSH
66179: LD_EXP 102
66183: PUSH
66184: LD_VAR 0 4
66188: ARRAY
66189: PPUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 30
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 30
66205: PUSH
66206: LD_INT 1
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: LIST
66217: PPUSH
66218: CALL_OW 72
66222: PPUSH
66223: LD_VAR 0 1
66227: PPUSH
66228: CALL_OW 74
66232: ST_TO_ADDR
// if tmp then
66233: LD_VAR 0 5
66237: IFFALSE 66253
// ComStandNearbyBuilding ( ape , tmp ) ;
66239: LD_VAR 0 1
66243: PPUSH
66244: LD_VAR 0 5
66248: PPUSH
66249: CALL 72599 0 2
// break ;
66253: GO 66257
// end ; end ;
66255: GO 66109
66257: POP
66258: POP
// end ;
66259: LD_VAR 0 3
66263: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
66264: LD_INT 0
66266: PPUSH
66267: PPUSH
66268: PPUSH
// if not mc_bases or not skirmish then
66269: LD_EXP 102
66273: NOT
66274: IFTRUE 66283
66276: PUSH
66277: LD_EXP 100
66281: NOT
66282: OR
66283: IFFALSE 66287
// exit ;
66285: GO 66376
// for i = 1 to mc_bases do
66287: LD_ADDR_VAR 0 4
66291: PUSH
66292: DOUBLE
66293: LD_INT 1
66295: DEC
66296: ST_TO_ADDR
66297: LD_EXP 102
66301: PUSH
66302: FOR_TO
66303: IFFALSE 66374
// begin if building in mc_busy_turret_list [ i ] then
66305: LD_VAR 0 1
66309: PUSH
66310: LD_EXP 112
66314: PUSH
66315: LD_VAR 0 4
66319: ARRAY
66320: IN
66321: IFFALSE 66372
// begin tmp := mc_busy_turret_list [ i ] diff building ;
66323: LD_ADDR_VAR 0 5
66327: PUSH
66328: LD_EXP 112
66332: PUSH
66333: LD_VAR 0 4
66337: ARRAY
66338: PUSH
66339: LD_VAR 0 1
66343: DIFF
66344: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
66345: LD_ADDR_EXP 112
66349: PUSH
66350: LD_EXP 112
66354: PPUSH
66355: LD_VAR 0 4
66359: PPUSH
66360: LD_VAR 0 5
66364: PPUSH
66365: CALL_OW 1
66369: ST_TO_ADDR
// break ;
66370: GO 66374
// end ; end ;
66372: GO 66302
66374: POP
66375: POP
// end ;
66376: LD_VAR 0 3
66380: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
66381: LD_INT 0
66383: PPUSH
66384: PPUSH
66385: PPUSH
// if not mc_bases or not skirmish then
66386: LD_EXP 102
66390: NOT
66391: IFTRUE 66400
66393: PUSH
66394: LD_EXP 100
66398: NOT
66399: OR
66400: IFFALSE 66404
// exit ;
66402: GO 66603
// for i = 1 to mc_bases do
66404: LD_ADDR_VAR 0 5
66408: PUSH
66409: DOUBLE
66410: LD_INT 1
66412: DEC
66413: ST_TO_ADDR
66414: LD_EXP 102
66418: PUSH
66419: FOR_TO
66420: IFFALSE 66601
// if building in mc_bases [ i ] then
66422: LD_VAR 0 1
66426: PUSH
66427: LD_EXP 102
66431: PUSH
66432: LD_VAR 0 5
66436: ARRAY
66437: IN
66438: IFFALSE 66599
// begin tmp := mc_bases [ i ] diff building ;
66440: LD_ADDR_VAR 0 6
66444: PUSH
66445: LD_EXP 102
66449: PUSH
66450: LD_VAR 0 5
66454: ARRAY
66455: PUSH
66456: LD_VAR 0 1
66460: DIFF
66461: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
66462: LD_ADDR_EXP 102
66466: PUSH
66467: LD_EXP 102
66471: PPUSH
66472: LD_VAR 0 5
66476: PPUSH
66477: LD_VAR 0 6
66481: PPUSH
66482: CALL_OW 1
66486: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
66487: LD_VAR 0 1
66491: PUSH
66492: LD_EXP 110
66496: PUSH
66497: LD_VAR 0 5
66501: ARRAY
66502: IN
66503: IFFALSE 66542
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
66505: LD_ADDR_EXP 110
66509: PUSH
66510: LD_EXP 110
66514: PPUSH
66515: LD_VAR 0 5
66519: PPUSH
66520: LD_EXP 110
66524: PUSH
66525: LD_VAR 0 5
66529: ARRAY
66530: PUSH
66531: LD_VAR 0 1
66535: DIFF
66536: PPUSH
66537: CALL_OW 1
66541: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
66542: LD_VAR 0 1
66546: PUSH
66547: LD_EXP 111
66551: PUSH
66552: LD_VAR 0 5
66556: ARRAY
66557: IN
66558: IFFALSE 66597
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
66560: LD_ADDR_EXP 111
66564: PUSH
66565: LD_EXP 111
66569: PPUSH
66570: LD_VAR 0 5
66574: PPUSH
66575: LD_EXP 111
66579: PUSH
66580: LD_VAR 0 5
66584: ARRAY
66585: PUSH
66586: LD_VAR 0 1
66590: DIFF
66591: PPUSH
66592: CALL_OW 1
66596: ST_TO_ADDR
// break ;
66597: GO 66601
// end ;
66599: GO 66419
66601: POP
66602: POP
// end ;
66603: LD_VAR 0 4
66607: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66608: LD_INT 0
66610: PPUSH
66611: PPUSH
66612: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66613: LD_EXP 102
66617: NOT
66618: IFTRUE 66627
66620: PUSH
66621: LD_EXP 100
66625: NOT
66626: OR
66627: IFTRUE 66642
66629: PUSH
66630: LD_VAR 0 3
66634: PUSH
66635: LD_EXP 128
66639: IN
66640: NOT
66641: OR
66642: IFFALSE 66646
// exit ;
66644: GO 66771
// for i = 1 to mc_vehicles do
66646: LD_ADDR_VAR 0 6
66650: PUSH
66651: DOUBLE
66652: LD_INT 1
66654: DEC
66655: ST_TO_ADDR
66656: LD_EXP 121
66660: PUSH
66661: FOR_TO
66662: IFFALSE 66769
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66664: LD_VAR 0 2
66668: PUSH
66669: LD_EXP 121
66673: PUSH
66674: LD_VAR 0 6
66678: ARRAY
66679: IN
66680: IFTRUE 66700
66682: PUSH
66683: LD_VAR 0 1
66687: PUSH
66688: LD_EXP 121
66692: PUSH
66693: LD_VAR 0 6
66697: ARRAY
66698: IN
66699: OR
66700: IFFALSE 66767
// begin tmp := mc_vehicles [ i ] diff old ;
66702: LD_ADDR_VAR 0 7
66706: PUSH
66707: LD_EXP 121
66711: PUSH
66712: LD_VAR 0 6
66716: ARRAY
66717: PUSH
66718: LD_VAR 0 2
66722: DIFF
66723: ST_TO_ADDR
// tmp := tmp diff new ;
66724: LD_ADDR_VAR 0 7
66728: PUSH
66729: LD_VAR 0 7
66733: PUSH
66734: LD_VAR 0 1
66738: DIFF
66739: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66740: LD_ADDR_EXP 121
66744: PUSH
66745: LD_EXP 121
66749: PPUSH
66750: LD_VAR 0 6
66754: PPUSH
66755: LD_VAR 0 7
66759: PPUSH
66760: CALL_OW 1
66764: ST_TO_ADDR
// break ;
66765: GO 66769
// end ;
66767: GO 66661
66769: POP
66770: POP
// end ;
66771: LD_VAR 0 5
66775: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66776: LD_INT 0
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
// if not mc_bases or not skirmish then
66782: LD_EXP 102
66786: NOT
66787: IFTRUE 66796
66789: PUSH
66790: LD_EXP 100
66794: NOT
66795: OR
66796: IFFALSE 66800
// exit ;
66798: GO 67222
// repeat wait ( 0 0$1 ) ;
66800: LD_INT 35
66802: PPUSH
66803: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66807: LD_EXP 146
66811: NOT
66812: IFFALSE 66800
// mc_block_vehicle_constructed_thread := true ;
66814: LD_ADDR_EXP 146
66818: PUSH
66819: LD_INT 1
66821: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66822: LD_ADDR_VAR 0 5
66826: PUSH
66827: LD_VAR 0 1
66831: PPUSH
66832: CALL_OW 255
66836: ST_TO_ADDR
// for i = 1 to mc_bases do
66837: LD_ADDR_VAR 0 4
66841: PUSH
66842: DOUBLE
66843: LD_INT 1
66845: DEC
66846: ST_TO_ADDR
66847: LD_EXP 102
66851: PUSH
66852: FOR_TO
66853: IFFALSE 67212
// begin if factory in mc_bases [ i ] then
66855: LD_VAR 0 2
66859: PUSH
66860: LD_EXP 102
66864: PUSH
66865: LD_VAR 0 4
66869: ARRAY
66870: IN
66871: IFFALSE 67210
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66873: LD_EXP 124
66877: PUSH
66878: LD_VAR 0 4
66882: ARRAY
66883: PUSH
66884: LD_EXP 113
66888: PUSH
66889: LD_VAR 0 4
66893: ARRAY
66894: LESS
66895: IFFALSE 66984
66897: PUSH
66898: LD_VAR 0 1
66902: PPUSH
66903: CALL_OW 264
66907: PUSH
66908: LD_INT 31
66910: PUSH
66911: LD_INT 32
66913: PUSH
66914: LD_INT 51
66916: PUSH
66917: LD_INT 89
66919: PUSH
66920: LD_INT 12
66922: PUSH
66923: LD_INT 30
66925: PUSH
66926: LD_INT 98
66928: PUSH
66929: LD_INT 11
66931: PUSH
66932: LD_INT 53
66934: PUSH
66935: LD_INT 14
66937: PUSH
66938: LD_INT 91
66940: PUSH
66941: LD_INT 29
66943: PUSH
66944: LD_INT 99
66946: PUSH
66947: LD_INT 13
66949: PUSH
66950: LD_INT 52
66952: PUSH
66953: LD_INT 88
66955: PUSH
66956: LD_INT 48
66958: PUSH
66959: LD_INT 8
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: LIST
66979: LIST
66980: LIST
66981: IN
66982: NOT
66983: AND
66984: IFFALSE 67032
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66986: LD_ADDR_EXP 124
66990: PUSH
66991: LD_EXP 124
66995: PPUSH
66996: LD_VAR 0 4
67000: PUSH
67001: LD_EXP 124
67005: PUSH
67006: LD_VAR 0 4
67010: ARRAY
67011: PUSH
67012: LD_INT 1
67014: PLUS
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PPUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL 76023 0 3
67029: ST_TO_ADDR
67030: GO 67076
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67032: LD_ADDR_EXP 121
67036: PUSH
67037: LD_EXP 121
67041: PPUSH
67042: LD_VAR 0 4
67046: PUSH
67047: LD_EXP 121
67051: PUSH
67052: LD_VAR 0 4
67056: ARRAY
67057: PUSH
67058: LD_INT 1
67060: PLUS
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PPUSH
67066: LD_VAR 0 1
67070: PPUSH
67071: CALL 76023 0 3
67075: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
67076: LD_ADDR_EXP 146
67080: PUSH
67081: LD_INT 0
67083: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67084: LD_VAR 0 1
67088: PPUSH
67089: CALL_OW 263
67093: PUSH
67094: LD_INT 2
67096: EQUAL
67097: IFFALSE 67126
// begin repeat wait ( 0 0$3 ) ;
67099: LD_INT 105
67101: PPUSH
67102: CALL_OW 67
// Connect ( vehicle ) ;
67106: LD_VAR 0 1
67110: PPUSH
67111: CALL 79383 0 1
// until IsControledBy ( vehicle ) ;
67115: LD_VAR 0 1
67119: PPUSH
67120: CALL_OW 312
67124: IFFALSE 67099
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67126: LD_VAR 0 1
67130: PPUSH
67131: LD_EXP 126
67135: PUSH
67136: LD_VAR 0 4
67140: ARRAY
67141: PPUSH
67142: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67146: LD_VAR 0 1
67150: PPUSH
67151: CALL_OW 263
67155: PUSH
67156: LD_INT 1
67158: NONEQUAL
67159: IFFALSE 67163
// break ;
67161: GO 67212
// repeat wait ( 0 0$1 ) ;
67163: LD_INT 35
67165: PPUSH
67166: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67170: LD_VAR 0 1
67174: PPUSH
67175: LD_EXP 126
67179: PUSH
67180: LD_VAR 0 4
67184: ARRAY
67185: PPUSH
67186: CALL_OW 308
67190: IFFALSE 67163
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67192: LD_VAR 0 1
67196: PPUSH
67197: CALL_OW 311
67201: PPUSH
67202: CALL_OW 121
// exit ;
67206: POP
67207: POP
67208: GO 67222
// end ; end ;
67210: GO 66852
67212: POP
67213: POP
// mc_block_vehicle_constructed_thread := false ;
67214: LD_ADDR_EXP 146
67218: PUSH
67219: LD_INT 0
67221: ST_TO_ADDR
// end ;
67222: LD_VAR 0 3
67226: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
67227: LD_INT 0
67229: PPUSH
67230: PPUSH
67231: PPUSH
67232: PPUSH
// if not mc_bases or not skirmish then
67233: LD_EXP 102
67237: NOT
67238: IFTRUE 67247
67240: PUSH
67241: LD_EXP 100
67245: NOT
67246: OR
67247: IFFALSE 67251
// exit ;
67249: GO 67604
// repeat wait ( 0 0$1 ) ;
67251: LD_INT 35
67253: PPUSH
67254: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
67258: LD_VAR 0 2
67262: PPUSH
67263: LD_VAR 0 3
67267: PPUSH
67268: CALL_OW 284
67272: IFFALSE 67251
// if GetResourceTypeXY ( x , y ) = mat_artefact then
67274: LD_VAR 0 2
67278: PPUSH
67279: LD_VAR 0 3
67283: PPUSH
67284: CALL_OW 283
67288: PUSH
67289: LD_INT 4
67291: EQUAL
67292: IFFALSE 67296
// exit ;
67294: GO 67604
// for i = 1 to mc_bases do
67296: LD_ADDR_VAR 0 7
67300: PUSH
67301: DOUBLE
67302: LD_INT 1
67304: DEC
67305: ST_TO_ADDR
67306: LD_EXP 102
67310: PUSH
67311: FOR_TO
67312: IFFALSE 67602
// begin if mc_crates_area [ i ] then
67314: LD_EXP 120
67318: PUSH
67319: LD_VAR 0 7
67323: ARRAY
67324: IFFALSE 67435
// for j in mc_crates_area [ i ] do
67326: LD_ADDR_VAR 0 8
67330: PUSH
67331: LD_EXP 120
67335: PUSH
67336: LD_VAR 0 7
67340: ARRAY
67341: PUSH
67342: FOR_IN
67343: IFFALSE 67433
// if InArea ( x , y , j ) then
67345: LD_VAR 0 2
67349: PPUSH
67350: LD_VAR 0 3
67354: PPUSH
67355: LD_VAR 0 8
67359: PPUSH
67360: CALL_OW 309
67364: IFFALSE 67431
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67366: LD_ADDR_EXP 118
67370: PUSH
67371: LD_EXP 118
67375: PPUSH
67376: LD_VAR 0 7
67380: PUSH
67381: LD_EXP 118
67385: PUSH
67386: LD_VAR 0 7
67390: ARRAY
67391: PUSH
67392: LD_INT 1
67394: PLUS
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PPUSH
67400: LD_VAR 0 4
67404: PUSH
67405: LD_VAR 0 2
67409: PUSH
67410: LD_VAR 0 3
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: LIST
67419: PPUSH
67420: CALL 76023 0 3
67424: ST_TO_ADDR
// exit ;
67425: POP
67426: POP
67427: POP
67428: POP
67429: GO 67604
// end ;
67431: GO 67342
67433: POP
67434: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67435: LD_ADDR_VAR 0 9
67439: PUSH
67440: LD_EXP 102
67444: PUSH
67445: LD_VAR 0 7
67449: ARRAY
67450: PPUSH
67451: LD_INT 2
67453: PUSH
67454: LD_INT 30
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 30
67466: PUSH
67467: LD_INT 1
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: LIST
67478: PPUSH
67479: CALL_OW 72
67483: ST_TO_ADDR
// if not depot then
67484: LD_VAR 0 9
67488: NOT
67489: IFFALSE 67493
// continue ;
67491: GO 67311
// for j in depot do
67493: LD_ADDR_VAR 0 8
67497: PUSH
67498: LD_VAR 0 9
67502: PUSH
67503: FOR_IN
67504: IFFALSE 67598
// if GetDistUnitXY ( j , x , y ) < 30 then
67506: LD_VAR 0 8
67510: PPUSH
67511: LD_VAR 0 2
67515: PPUSH
67516: LD_VAR 0 3
67520: PPUSH
67521: CALL_OW 297
67525: PUSH
67526: LD_INT 30
67528: LESS
67529: IFFALSE 67596
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67531: LD_ADDR_EXP 118
67535: PUSH
67536: LD_EXP 118
67540: PPUSH
67541: LD_VAR 0 7
67545: PUSH
67546: LD_EXP 118
67550: PUSH
67551: LD_VAR 0 7
67555: ARRAY
67556: PUSH
67557: LD_INT 1
67559: PLUS
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PPUSH
67565: LD_VAR 0 4
67569: PUSH
67570: LD_VAR 0 2
67574: PUSH
67575: LD_VAR 0 3
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: LIST
67584: PPUSH
67585: CALL 76023 0 3
67589: ST_TO_ADDR
// exit ;
67590: POP
67591: POP
67592: POP
67593: POP
67594: GO 67604
// end ;
67596: GO 67503
67598: POP
67599: POP
// end ;
67600: GO 67311
67602: POP
67603: POP
// end ;
67604: LD_VAR 0 6
67608: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
67609: LD_INT 0
67611: PPUSH
67612: PPUSH
67613: PPUSH
67614: PPUSH
// if not mc_bases or not skirmish then
67615: LD_EXP 102
67619: NOT
67620: IFTRUE 67629
67622: PUSH
67623: LD_EXP 100
67627: NOT
67628: OR
67629: IFFALSE 67633
// exit ;
67631: GO 67916
// side := GetSide ( lab ) ;
67633: LD_ADDR_VAR 0 4
67637: PUSH
67638: LD_VAR 0 2
67642: PPUSH
67643: CALL_OW 255
67647: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67648: LD_VAR 0 4
67652: PUSH
67653: LD_EXP 128
67657: IN
67658: NOT
67659: IFTRUE 67668
67661: PUSH
67662: LD_EXP 129
67666: NOT
67667: OR
67668: IFTRUE 67677
67670: PUSH
67671: LD_EXP 102
67675: NOT
67676: OR
67677: IFFALSE 67681
// exit ;
67679: GO 67916
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67681: LD_ADDR_EXP 129
67685: PUSH
67686: LD_EXP 129
67690: PPUSH
67691: LD_VAR 0 4
67695: PPUSH
67696: LD_EXP 129
67700: PUSH
67701: LD_VAR 0 4
67705: ARRAY
67706: PUSH
67707: LD_VAR 0 1
67711: DIFF
67712: PPUSH
67713: CALL_OW 1
67717: ST_TO_ADDR
// for i = 1 to mc_bases do
67718: LD_ADDR_VAR 0 5
67722: PUSH
67723: DOUBLE
67724: LD_INT 1
67726: DEC
67727: ST_TO_ADDR
67728: LD_EXP 102
67732: PUSH
67733: FOR_TO
67734: IFFALSE 67914
// begin if lab in mc_bases [ i ] then
67736: LD_VAR 0 2
67740: PUSH
67741: LD_EXP 102
67745: PUSH
67746: LD_VAR 0 5
67750: ARRAY
67751: IN
67752: IFFALSE 67912
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67754: LD_VAR 0 1
67758: PUSH
67759: LD_INT 11
67761: PUSH
67762: LD_INT 4
67764: PUSH
67765: LD_INT 3
67767: PUSH
67768: LD_INT 2
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: IN
67777: IFFALSE 67791
67779: PUSH
67780: LD_EXP 132
67784: PUSH
67785: LD_VAR 0 5
67789: ARRAY
67790: AND
67791: IFFALSE 67912
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67793: LD_ADDR_VAR 0 6
67797: PUSH
67798: LD_EXP 132
67802: PUSH
67803: LD_VAR 0 5
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67813: LD_ADDR_EXP 132
67817: PUSH
67818: LD_EXP 132
67822: PPUSH
67823: LD_VAR 0 5
67827: PPUSH
67828: EMPTY
67829: PPUSH
67830: CALL_OW 1
67834: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67835: LD_VAR 0 6
67839: PPUSH
67840: LD_INT 0
67842: PPUSH
67843: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67847: LD_VAR 0 6
67851: PPUSH
67852: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67856: LD_ADDR_EXP 131
67860: PUSH
67861: LD_EXP 131
67865: PPUSH
67866: LD_VAR 0 5
67870: PPUSH
67871: LD_EXP 131
67875: PUSH
67876: LD_VAR 0 5
67880: ARRAY
67881: PPUSH
67882: LD_INT 1
67884: PPUSH
67885: LD_VAR 0 6
67889: PPUSH
67890: CALL_OW 2
67894: PPUSH
67895: CALL_OW 1
67899: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67900: LD_VAR 0 5
67904: PPUSH
67905: LD_INT 112
67907: PPUSH
67908: CALL 44046 0 2
// end ; end ; end ;
67912: GO 67733
67914: POP
67915: POP
// end ;
67916: LD_VAR 0 3
67920: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67921: LD_INT 0
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
67928: PPUSH
67929: PPUSH
67930: PPUSH
// if not mc_bases or not skirmish then
67931: LD_EXP 102
67935: NOT
67936: IFTRUE 67945
67938: PUSH
67939: LD_EXP 100
67943: NOT
67944: OR
67945: IFFALSE 67949
// exit ;
67947: GO 69334
// for i = 1 to mc_bases do
67949: LD_ADDR_VAR 0 3
67953: PUSH
67954: DOUBLE
67955: LD_INT 1
67957: DEC
67958: ST_TO_ADDR
67959: LD_EXP 102
67963: PUSH
67964: FOR_TO
67965: IFFALSE 69332
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67967: LD_VAR 0 1
67971: PUSH
67972: LD_EXP 102
67976: PUSH
67977: LD_VAR 0 3
67981: ARRAY
67982: IN
67983: IFTRUE 68003
67985: PUSH
67986: LD_VAR 0 1
67990: PUSH
67991: LD_EXP 109
67995: PUSH
67996: LD_VAR 0 3
68000: ARRAY
68001: IN
68002: OR
68003: IFTRUE 68023
68005: PUSH
68006: LD_VAR 0 1
68010: PUSH
68011: LD_EXP 124
68015: PUSH
68016: LD_VAR 0 3
68020: ARRAY
68021: IN
68022: OR
68023: IFTRUE 68043
68025: PUSH
68026: LD_VAR 0 1
68030: PUSH
68031: LD_EXP 121
68035: PUSH
68036: LD_VAR 0 3
68040: ARRAY
68041: IN
68042: OR
68043: IFTRUE 68063
68045: PUSH
68046: LD_VAR 0 1
68050: PUSH
68051: LD_EXP 131
68055: PUSH
68056: LD_VAR 0 3
68060: ARRAY
68061: IN
68062: OR
68063: IFTRUE 68083
68065: PUSH
68066: LD_VAR 0 1
68070: PUSH
68071: LD_EXP 132
68075: PUSH
68076: LD_VAR 0 3
68080: ARRAY
68081: IN
68082: OR
68083: IFFALSE 69330
// begin if un in mc_ape [ i ] then
68085: LD_VAR 0 1
68089: PUSH
68090: LD_EXP 131
68094: PUSH
68095: LD_VAR 0 3
68099: ARRAY
68100: IN
68101: IFFALSE 68140
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68103: LD_ADDR_EXP 131
68107: PUSH
68108: LD_EXP 131
68112: PPUSH
68113: LD_VAR 0 3
68117: PPUSH
68118: LD_EXP 131
68122: PUSH
68123: LD_VAR 0 3
68127: ARRAY
68128: PUSH
68129: LD_VAR 0 1
68133: DIFF
68134: PPUSH
68135: CALL_OW 1
68139: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68140: LD_VAR 0 1
68144: PUSH
68145: LD_EXP 132
68149: PUSH
68150: LD_VAR 0 3
68154: ARRAY
68155: IN
68156: IFFALSE 68180
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68158: LD_ADDR_EXP 132
68162: PUSH
68163: LD_EXP 132
68167: PPUSH
68168: LD_VAR 0 3
68172: PPUSH
68173: EMPTY
68174: PPUSH
68175: CALL_OW 1
68179: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68180: LD_VAR 0 1
68184: PPUSH
68185: CALL_OW 247
68189: PUSH
68190: LD_INT 2
68192: EQUAL
68193: IFFALSE 68274
68195: PUSH
68196: LD_VAR 0 1
68200: PPUSH
68201: CALL_OW 110
68205: PUSH
68206: LD_INT 20
68208: EQUAL
68209: IFTRUE 68229
68211: PUSH
68212: LD_VAR 0 1
68216: PUSH
68217: LD_EXP 124
68221: PUSH
68222: LD_VAR 0 3
68226: ARRAY
68227: IN
68228: OR
68229: IFTRUE 68273
68231: PUSH
68232: LD_VAR 0 1
68236: PPUSH
68237: CALL_OW 264
68241: PUSH
68242: LD_INT 12
68244: PUSH
68245: LD_INT 51
68247: PUSH
68248: LD_INT 89
68250: PUSH
68251: LD_INT 32
68253: PUSH
68254: LD_INT 13
68256: PUSH
68257: LD_INT 52
68259: PUSH
68260: LD_INT 31
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: IN
68272: OR
68273: AND
68274: IFFALSE 68582
// begin if un in mc_defender [ i ] then
68276: LD_VAR 0 1
68280: PUSH
68281: LD_EXP 124
68285: PUSH
68286: LD_VAR 0 3
68290: ARRAY
68291: IN
68292: IFFALSE 68331
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68294: LD_ADDR_EXP 124
68298: PUSH
68299: LD_EXP 124
68303: PPUSH
68304: LD_VAR 0 3
68308: PPUSH
68309: LD_EXP 124
68313: PUSH
68314: LD_VAR 0 3
68318: ARRAY
68319: PUSH
68320: LD_VAR 0 1
68324: DIFF
68325: PPUSH
68326: CALL_OW 1
68330: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
68331: LD_ADDR_VAR 0 8
68335: PUSH
68336: LD_VAR 0 3
68340: PPUSH
68341: LD_INT 3
68343: PPUSH
68344: CALL 64870 0 2
68348: ST_TO_ADDR
// if fac then
68349: LD_VAR 0 8
68353: IFFALSE 68582
// begin for j in fac do
68355: LD_ADDR_VAR 0 4
68359: PUSH
68360: LD_VAR 0 8
68364: PUSH
68365: FOR_IN
68366: IFFALSE 68580
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
68368: LD_ADDR_VAR 0 9
68372: PUSH
68373: LD_VAR 0 8
68377: PPUSH
68378: LD_VAR 0 1
68382: PPUSH
68383: CALL_OW 265
68387: PPUSH
68388: LD_VAR 0 1
68392: PPUSH
68393: CALL_OW 262
68397: PPUSH
68398: LD_VAR 0 1
68402: PPUSH
68403: CALL_OW 263
68407: PPUSH
68408: LD_VAR 0 1
68412: PPUSH
68413: CALL_OW 264
68417: PPUSH
68418: CALL 73497 0 5
68422: ST_TO_ADDR
// if components then
68423: LD_VAR 0 9
68427: IFFALSE 68578
// begin if GetWeapon ( un ) = ar_control_tower then
68429: LD_VAR 0 1
68433: PPUSH
68434: CALL_OW 264
68438: PUSH
68439: LD_INT 31
68441: EQUAL
68442: IFFALSE 68559
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
68444: LD_VAR 0 1
68448: PPUSH
68449: CALL_OW 311
68453: PPUSH
68454: LD_INT 0
68456: PPUSH
68457: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
68461: LD_ADDR_EXP 142
68465: PUSH
68466: LD_EXP 142
68470: PPUSH
68471: LD_VAR 0 3
68475: PPUSH
68476: LD_EXP 142
68480: PUSH
68481: LD_VAR 0 3
68485: ARRAY
68486: PUSH
68487: LD_VAR 0 1
68491: PPUSH
68492: CALL_OW 311
68496: DIFF
68497: PPUSH
68498: CALL_OW 1
68502: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
68503: LD_ADDR_VAR 0 7
68507: PUSH
68508: LD_EXP 123
68512: PUSH
68513: LD_VAR 0 3
68517: ARRAY
68518: PPUSH
68519: LD_INT 1
68521: PPUSH
68522: LD_VAR 0 9
68526: PPUSH
68527: CALL_OW 2
68531: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68532: LD_ADDR_EXP 123
68536: PUSH
68537: LD_EXP 123
68541: PPUSH
68542: LD_VAR 0 3
68546: PPUSH
68547: LD_VAR 0 7
68551: PPUSH
68552: CALL_OW 1
68556: ST_TO_ADDR
// end else
68557: GO 68576
// MC_InsertProduceList ( i , [ components ] ) ;
68559: LD_VAR 0 3
68563: PPUSH
68564: LD_VAR 0 9
68568: PUSH
68569: EMPTY
68570: LIST
68571: PPUSH
68572: CALL 64415 0 2
// break ;
68576: GO 68580
// end ; end ;
68578: GO 68365
68580: POP
68581: POP
// end ; end ; if GetType ( un ) = unit_building then
68582: LD_VAR 0 1
68586: PPUSH
68587: CALL_OW 247
68591: PUSH
68592: LD_INT 3
68594: EQUAL
68595: IFFALSE 68998
// begin btype := GetBType ( un ) ;
68597: LD_ADDR_VAR 0 5
68601: PUSH
68602: LD_VAR 0 1
68606: PPUSH
68607: CALL_OW 266
68611: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
68612: LD_VAR 0 5
68616: PUSH
68617: LD_INT 29
68619: PUSH
68620: LD_INT 30
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: IN
68627: IFFALSE 68700
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
68629: LD_VAR 0 1
68633: PPUSH
68634: CALL_OW 250
68638: PPUSH
68639: LD_VAR 0 1
68643: PPUSH
68644: CALL_OW 251
68648: PPUSH
68649: LD_VAR 0 1
68653: PPUSH
68654: CALL_OW 255
68658: PPUSH
68659: CALL_OW 440
68663: NOT
68664: IFFALSE 68700
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68666: LD_VAR 0 1
68670: PPUSH
68671: CALL_OW 250
68675: PPUSH
68676: LD_VAR 0 1
68680: PPUSH
68681: CALL_OW 251
68685: PPUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: CALL_OW 255
68695: PPUSH
68696: CALL_OW 441
// end ; if btype = b_warehouse then
68700: LD_VAR 0 5
68704: PUSH
68705: LD_INT 1
68707: EQUAL
68708: IFFALSE 68726
// begin btype := b_depot ;
68710: LD_ADDR_VAR 0 5
68714: PUSH
68715: LD_INT 0
68717: ST_TO_ADDR
// pos := 1 ;
68718: LD_ADDR_VAR 0 6
68722: PUSH
68723: LD_INT 1
68725: ST_TO_ADDR
// end ; if btype = b_factory then
68726: LD_VAR 0 5
68730: PUSH
68731: LD_INT 3
68733: EQUAL
68734: IFFALSE 68752
// begin btype := b_workshop ;
68736: LD_ADDR_VAR 0 5
68740: PUSH
68741: LD_INT 2
68743: ST_TO_ADDR
// pos := 1 ;
68744: LD_ADDR_VAR 0 6
68748: PUSH
68749: LD_INT 1
68751: ST_TO_ADDR
// end ; if btype = b_barracks then
68752: LD_VAR 0 5
68756: PUSH
68757: LD_INT 5
68759: EQUAL
68760: IFFALSE 68770
// btype := b_armoury ;
68762: LD_ADDR_VAR 0 5
68766: PUSH
68767: LD_INT 4
68769: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68770: LD_VAR 0 5
68774: PUSH
68775: LD_INT 7
68777: PUSH
68778: LD_INT 8
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: IN
68785: IFFALSE 68795
// btype := b_lab ;
68787: LD_ADDR_VAR 0 5
68791: PUSH
68792: LD_INT 6
68794: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68795: LD_ADDR_EXP 107
68799: PUSH
68800: LD_EXP 107
68804: PPUSH
68805: LD_VAR 0 3
68809: PUSH
68810: LD_EXP 107
68814: PUSH
68815: LD_VAR 0 3
68819: ARRAY
68820: PUSH
68821: LD_INT 1
68823: PLUS
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PPUSH
68829: LD_VAR 0 5
68833: PUSH
68834: LD_VAR 0 1
68838: PPUSH
68839: CALL_OW 250
68843: PUSH
68844: LD_VAR 0 1
68848: PPUSH
68849: CALL_OW 251
68853: PUSH
68854: LD_VAR 0 1
68858: PPUSH
68859: CALL_OW 254
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: PPUSH
68870: CALL 76023 0 3
68874: ST_TO_ADDR
// if pos = 1 then
68875: LD_VAR 0 6
68879: PUSH
68880: LD_INT 1
68882: EQUAL
68883: IFFALSE 68998
// begin tmp := mc_build_list [ i ] ;
68885: LD_ADDR_VAR 0 7
68889: PUSH
68890: LD_EXP 107
68894: PUSH
68895: LD_VAR 0 3
68899: ARRAY
68900: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68901: LD_VAR 0 7
68905: PPUSH
68906: LD_INT 2
68908: PUSH
68909: LD_INT 30
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 30
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: PPUSH
68934: CALL_OW 72
68938: IFFALSE 68948
// pos := 2 ;
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: LD_INT 2
68947: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68948: LD_ADDR_VAR 0 7
68952: PUSH
68953: LD_VAR 0 7
68957: PPUSH
68958: LD_VAR 0 6
68962: PPUSH
68963: LD_VAR 0 7
68967: PPUSH
68968: CALL 76349 0 3
68972: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68973: LD_ADDR_EXP 107
68977: PUSH
68978: LD_EXP 107
68982: PPUSH
68983: LD_VAR 0 3
68987: PPUSH
68988: LD_VAR 0 7
68992: PPUSH
68993: CALL_OW 1
68997: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68998: LD_VAR 0 1
69002: PUSH
69003: LD_EXP 102
69007: PUSH
69008: LD_VAR 0 3
69012: ARRAY
69013: IN
69014: IFFALSE 69053
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69016: LD_ADDR_EXP 102
69020: PUSH
69021: LD_EXP 102
69025: PPUSH
69026: LD_VAR 0 3
69030: PPUSH
69031: LD_EXP 102
69035: PUSH
69036: LD_VAR 0 3
69040: ARRAY
69041: PUSH
69042: LD_VAR 0 1
69046: DIFF
69047: PPUSH
69048: CALL_OW 1
69052: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69053: LD_VAR 0 1
69057: PUSH
69058: LD_EXP 109
69062: PUSH
69063: LD_VAR 0 3
69067: ARRAY
69068: IN
69069: IFFALSE 69108
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69071: LD_ADDR_EXP 109
69075: PUSH
69076: LD_EXP 109
69080: PPUSH
69081: LD_VAR 0 3
69085: PPUSH
69086: LD_EXP 109
69090: PUSH
69091: LD_VAR 0 3
69095: ARRAY
69096: PUSH
69097: LD_VAR 0 1
69101: DIFF
69102: PPUSH
69103: CALL_OW 1
69107: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69108: LD_VAR 0 1
69112: PUSH
69113: LD_EXP 121
69117: PUSH
69118: LD_VAR 0 3
69122: ARRAY
69123: IN
69124: IFFALSE 69163
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69126: LD_ADDR_EXP 121
69130: PUSH
69131: LD_EXP 121
69135: PPUSH
69136: LD_VAR 0 3
69140: PPUSH
69141: LD_EXP 121
69145: PUSH
69146: LD_VAR 0 3
69150: ARRAY
69151: PUSH
69152: LD_VAR 0 1
69156: DIFF
69157: PPUSH
69158: CALL_OW 1
69162: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69163: LD_VAR 0 1
69167: PUSH
69168: LD_EXP 124
69172: PUSH
69173: LD_VAR 0 3
69177: ARRAY
69178: IN
69179: IFFALSE 69218
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69181: LD_ADDR_EXP 124
69185: PUSH
69186: LD_EXP 124
69190: PPUSH
69191: LD_VAR 0 3
69195: PPUSH
69196: LD_EXP 124
69200: PUSH
69201: LD_VAR 0 3
69205: ARRAY
69206: PUSH
69207: LD_VAR 0 1
69211: DIFF
69212: PPUSH
69213: CALL_OW 1
69217: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69218: LD_VAR 0 1
69222: PUSH
69223: LD_EXP 111
69227: PUSH
69228: LD_VAR 0 3
69232: ARRAY
69233: IN
69234: IFFALSE 69273
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69236: LD_ADDR_EXP 111
69240: PUSH
69241: LD_EXP 111
69245: PPUSH
69246: LD_VAR 0 3
69250: PPUSH
69251: LD_EXP 111
69255: PUSH
69256: LD_VAR 0 3
69260: ARRAY
69261: PUSH
69262: LD_VAR 0 1
69266: DIFF
69267: PPUSH
69268: CALL_OW 1
69272: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
69273: LD_VAR 0 1
69277: PUSH
69278: LD_EXP 110
69282: PUSH
69283: LD_VAR 0 3
69287: ARRAY
69288: IN
69289: IFFALSE 69328
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
69291: LD_ADDR_EXP 110
69295: PUSH
69296: LD_EXP 110
69300: PPUSH
69301: LD_VAR 0 3
69305: PPUSH
69306: LD_EXP 110
69310: PUSH
69311: LD_VAR 0 3
69315: ARRAY
69316: PUSH
69317: LD_VAR 0 1
69321: DIFF
69322: PPUSH
69323: CALL_OW 1
69327: ST_TO_ADDR
// end ; break ;
69328: GO 69332
// end ;
69330: GO 67964
69332: POP
69333: POP
// end ;
69334: LD_VAR 0 2
69338: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
69339: LD_INT 0
69341: PPUSH
69342: PPUSH
69343: PPUSH
// if not mc_bases or not skirmish then
69344: LD_EXP 102
69348: NOT
69349: IFTRUE 69358
69351: PUSH
69352: LD_EXP 100
69356: NOT
69357: OR
69358: IFFALSE 69362
// exit ;
69360: GO 69577
// for i = 1 to mc_bases do
69362: LD_ADDR_VAR 0 3
69366: PUSH
69367: DOUBLE
69368: LD_INT 1
69370: DEC
69371: ST_TO_ADDR
69372: LD_EXP 102
69376: PUSH
69377: FOR_TO
69378: IFFALSE 69575
// begin if building in mc_construct_list [ i ] then
69380: LD_VAR 0 1
69384: PUSH
69385: LD_EXP 109
69389: PUSH
69390: LD_VAR 0 3
69394: ARRAY
69395: IN
69396: IFFALSE 69573
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69398: LD_ADDR_EXP 109
69402: PUSH
69403: LD_EXP 109
69407: PPUSH
69408: LD_VAR 0 3
69412: PPUSH
69413: LD_EXP 109
69417: PUSH
69418: LD_VAR 0 3
69422: ARRAY
69423: PUSH
69424: LD_VAR 0 1
69428: DIFF
69429: PPUSH
69430: CALL_OW 1
69434: ST_TO_ADDR
// if building in mc_lab [ i ] then
69435: LD_VAR 0 1
69439: PUSH
69440: LD_EXP 135
69444: PUSH
69445: LD_VAR 0 3
69449: ARRAY
69450: IN
69451: IFFALSE 69506
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
69453: LD_ADDR_EXP 136
69457: PUSH
69458: LD_EXP 136
69462: PPUSH
69463: LD_VAR 0 3
69467: PPUSH
69468: LD_EXP 136
69472: PUSH
69473: LD_VAR 0 3
69477: ARRAY
69478: PPUSH
69479: LD_INT 1
69481: PPUSH
69482: LD_EXP 136
69486: PUSH
69487: LD_VAR 0 3
69491: ARRAY
69492: PPUSH
69493: LD_INT 0
69495: PPUSH
69496: CALL 75431 0 4
69500: PPUSH
69501: CALL_OW 1
69505: ST_TO_ADDR
// if not building in mc_bases [ i ] then
69506: LD_VAR 0 1
69510: PUSH
69511: LD_EXP 102
69515: PUSH
69516: LD_VAR 0 3
69520: ARRAY
69521: IN
69522: NOT
69523: IFFALSE 69569
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69525: LD_ADDR_EXP 102
69529: PUSH
69530: LD_EXP 102
69534: PPUSH
69535: LD_VAR 0 3
69539: PUSH
69540: LD_EXP 102
69544: PUSH
69545: LD_VAR 0 3
69549: ARRAY
69550: PUSH
69551: LD_INT 1
69553: PLUS
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PPUSH
69559: LD_VAR 0 1
69563: PPUSH
69564: CALL 76023 0 3
69568: ST_TO_ADDR
// exit ;
69569: POP
69570: POP
69571: GO 69577
// end ; end ;
69573: GO 69377
69575: POP
69576: POP
// end ;
69577: LD_VAR 0 2
69581: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
69582: LD_INT 0
69584: PPUSH
69585: PPUSH
69586: PPUSH
69587: PPUSH
69588: PPUSH
69589: PPUSH
69590: PPUSH
// if not mc_bases or not skirmish then
69591: LD_EXP 102
69595: NOT
69596: IFTRUE 69605
69598: PUSH
69599: LD_EXP 100
69603: NOT
69604: OR
69605: IFFALSE 69609
// exit ;
69607: GO 70270
// for i = 1 to mc_bases do
69609: LD_ADDR_VAR 0 3
69613: PUSH
69614: DOUBLE
69615: LD_INT 1
69617: DEC
69618: ST_TO_ADDR
69619: LD_EXP 102
69623: PUSH
69624: FOR_TO
69625: IFFALSE 70268
// begin if building in mc_construct_list [ i ] then
69627: LD_VAR 0 1
69631: PUSH
69632: LD_EXP 109
69636: PUSH
69637: LD_VAR 0 3
69641: ARRAY
69642: IN
69643: IFFALSE 70266
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69645: LD_ADDR_EXP 109
69649: PUSH
69650: LD_EXP 109
69654: PPUSH
69655: LD_VAR 0 3
69659: PPUSH
69660: LD_EXP 109
69664: PUSH
69665: LD_VAR 0 3
69669: ARRAY
69670: PUSH
69671: LD_VAR 0 1
69675: DIFF
69676: PPUSH
69677: CALL_OW 1
69681: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69682: LD_ADDR_EXP 102
69686: PUSH
69687: LD_EXP 102
69691: PPUSH
69692: LD_VAR 0 3
69696: PUSH
69697: LD_EXP 102
69701: PUSH
69702: LD_VAR 0 3
69706: ARRAY
69707: PUSH
69708: LD_INT 1
69710: PLUS
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PPUSH
69716: LD_VAR 0 1
69720: PPUSH
69721: CALL 76023 0 3
69725: ST_TO_ADDR
// btype := GetBType ( building ) ;
69726: LD_ADDR_VAR 0 5
69730: PUSH
69731: LD_VAR 0 1
69735: PPUSH
69736: CALL_OW 266
69740: ST_TO_ADDR
// side := GetSide ( building ) ;
69741: LD_ADDR_VAR 0 8
69745: PUSH
69746: LD_VAR 0 1
69750: PPUSH
69751: CALL_OW 255
69755: ST_TO_ADDR
// if btype = b_lab then
69756: LD_VAR 0 5
69760: PUSH
69761: LD_INT 6
69763: EQUAL
69764: IFFALSE 69814
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69766: LD_ADDR_EXP 135
69770: PUSH
69771: LD_EXP 135
69775: PPUSH
69776: LD_VAR 0 3
69780: PUSH
69781: LD_EXP 135
69785: PUSH
69786: LD_VAR 0 3
69790: ARRAY
69791: PUSH
69792: LD_INT 1
69794: PLUS
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PPUSH
69800: LD_VAR 0 1
69804: PPUSH
69805: CALL 76023 0 3
69809: ST_TO_ADDR
// exit ;
69810: POP
69811: POP
69812: GO 70270
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69814: LD_VAR 0 5
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 2
69824: PUSH
69825: LD_INT 4
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: IN
69833: IFFALSE 69957
// begin if btype = b_armoury then
69835: LD_VAR 0 5
69839: PUSH
69840: LD_INT 4
69842: EQUAL
69843: IFFALSE 69853
// btype := b_barracks ;
69845: LD_ADDR_VAR 0 5
69849: PUSH
69850: LD_INT 5
69852: ST_TO_ADDR
// if btype = b_depot then
69853: LD_VAR 0 5
69857: PUSH
69858: LD_INT 0
69860: EQUAL
69861: IFFALSE 69871
// btype := b_warehouse ;
69863: LD_ADDR_VAR 0 5
69867: PUSH
69868: LD_INT 1
69870: ST_TO_ADDR
// if btype = b_workshop then
69871: LD_VAR 0 5
69875: PUSH
69876: LD_INT 2
69878: EQUAL
69879: IFFALSE 69889
// btype := b_factory ;
69881: LD_ADDR_VAR 0 5
69885: PUSH
69886: LD_INT 3
69888: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69889: LD_VAR 0 5
69893: PPUSH
69894: LD_VAR 0 8
69898: PPUSH
69899: CALL_OW 323
69903: PUSH
69904: LD_INT 1
69906: EQUAL
69907: IFFALSE 69953
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69909: LD_ADDR_EXP 134
69913: PUSH
69914: LD_EXP 134
69918: PPUSH
69919: LD_VAR 0 3
69923: PUSH
69924: LD_EXP 134
69928: PUSH
69929: LD_VAR 0 3
69933: ARRAY
69934: PUSH
69935: LD_INT 1
69937: PLUS
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PPUSH
69943: LD_VAR 0 1
69947: PPUSH
69948: CALL 76023 0 3
69952: ST_TO_ADDR
// exit ;
69953: POP
69954: POP
69955: GO 70270
// end ; if btype in [ b_bunker , b_turret ] then
69957: LD_VAR 0 5
69961: PUSH
69962: LD_INT 32
69964: PUSH
69965: LD_INT 33
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: IN
69972: IFFALSE 70262
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69974: LD_ADDR_EXP 110
69978: PUSH
69979: LD_EXP 110
69983: PPUSH
69984: LD_VAR 0 3
69988: PUSH
69989: LD_EXP 110
69993: PUSH
69994: LD_VAR 0 3
69998: ARRAY
69999: PUSH
70000: LD_INT 1
70002: PLUS
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PPUSH
70008: LD_VAR 0 1
70012: PPUSH
70013: CALL 76023 0 3
70017: ST_TO_ADDR
// if btype = b_bunker then
70018: LD_VAR 0 5
70022: PUSH
70023: LD_INT 32
70025: EQUAL
70026: IFFALSE 70262
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70028: LD_ADDR_EXP 111
70032: PUSH
70033: LD_EXP 111
70037: PPUSH
70038: LD_VAR 0 3
70042: PUSH
70043: LD_EXP 111
70047: PUSH
70048: LD_VAR 0 3
70052: ARRAY
70053: PUSH
70054: LD_INT 1
70056: PLUS
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PPUSH
70062: LD_VAR 0 1
70066: PPUSH
70067: CALL 76023 0 3
70071: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70072: LD_ADDR_VAR 0 6
70076: PUSH
70077: LD_EXP 102
70081: PUSH
70082: LD_VAR 0 3
70086: ARRAY
70087: PPUSH
70088: LD_INT 25
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 3
70100: PUSH
70101: LD_INT 54
70103: PUSH
70104: EMPTY
70105: LIST
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PPUSH
70115: CALL_OW 72
70119: ST_TO_ADDR
// if tmp then
70120: LD_VAR 0 6
70124: IFFALSE 70130
// exit ;
70126: POP
70127: POP
70128: GO 70270
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70130: LD_ADDR_VAR 0 6
70134: PUSH
70135: LD_EXP 102
70139: PUSH
70140: LD_VAR 0 3
70144: ARRAY
70145: PPUSH
70146: LD_INT 2
70148: PUSH
70149: LD_INT 30
70151: PUSH
70152: LD_INT 4
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 30
70161: PUSH
70162: LD_INT 5
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: LIST
70173: PPUSH
70174: CALL_OW 72
70178: ST_TO_ADDR
// if not tmp then
70179: LD_VAR 0 6
70183: NOT
70184: IFFALSE 70190
// exit ;
70186: POP
70187: POP
70188: GO 70270
// for j in tmp do
70190: LD_ADDR_VAR 0 4
70194: PUSH
70195: LD_VAR 0 6
70199: PUSH
70200: FOR_IN
70201: IFFALSE 70260
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70203: LD_ADDR_VAR 0 7
70207: PUSH
70208: LD_VAR 0 4
70212: PPUSH
70213: CALL_OW 313
70217: PPUSH
70218: LD_INT 25
70220: PUSH
70221: LD_INT 1
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PPUSH
70228: CALL_OW 72
70232: ST_TO_ADDR
// if units then
70233: LD_VAR 0 7
70237: IFFALSE 70258
// begin ComExitBuilding ( units [ 1 ] ) ;
70239: LD_VAR 0 7
70243: PUSH
70244: LD_INT 1
70246: ARRAY
70247: PPUSH
70248: CALL_OW 122
// exit ;
70252: POP
70253: POP
70254: POP
70255: POP
70256: GO 70270
// end ; end ;
70258: GO 70200
70260: POP
70261: POP
// end ; end ; exit ;
70262: POP
70263: POP
70264: GO 70270
// end ; end ;
70266: GO 69624
70268: POP
70269: POP
// end ;
70270: LD_VAR 0 2
70274: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
70275: LD_INT 0
70277: PPUSH
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
// if not mc_bases or not skirmish then
70284: LD_EXP 102
70288: NOT
70289: IFTRUE 70298
70291: PUSH
70292: LD_EXP 100
70296: NOT
70297: OR
70298: IFFALSE 70302
// exit ;
70300: GO 70567
// btype := GetBType ( building ) ;
70302: LD_ADDR_VAR 0 6
70306: PUSH
70307: LD_VAR 0 1
70311: PPUSH
70312: CALL_OW 266
70316: ST_TO_ADDR
// x := GetX ( building ) ;
70317: LD_ADDR_VAR 0 7
70321: PUSH
70322: LD_VAR 0 1
70326: PPUSH
70327: CALL_OW 250
70331: ST_TO_ADDR
// y := GetY ( building ) ;
70332: LD_ADDR_VAR 0 8
70336: PUSH
70337: LD_VAR 0 1
70341: PPUSH
70342: CALL_OW 251
70346: ST_TO_ADDR
// d := GetDir ( building ) ;
70347: LD_ADDR_VAR 0 9
70351: PUSH
70352: LD_VAR 0 1
70356: PPUSH
70357: CALL_OW 254
70361: ST_TO_ADDR
// for i = 1 to mc_bases do
70362: LD_ADDR_VAR 0 4
70366: PUSH
70367: DOUBLE
70368: LD_INT 1
70370: DEC
70371: ST_TO_ADDR
70372: LD_EXP 102
70376: PUSH
70377: FOR_TO
70378: IFFALSE 70565
// begin if not mc_build_list [ i ] then
70380: LD_EXP 107
70384: PUSH
70385: LD_VAR 0 4
70389: ARRAY
70390: NOT
70391: IFFALSE 70395
// continue ;
70393: GO 70377
// for j := 1 to mc_build_list [ i ] do
70395: LD_ADDR_VAR 0 5
70399: PUSH
70400: DOUBLE
70401: LD_INT 1
70403: DEC
70404: ST_TO_ADDR
70405: LD_EXP 107
70409: PUSH
70410: LD_VAR 0 4
70414: ARRAY
70415: PUSH
70416: FOR_TO
70417: IFFALSE 70561
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
70419: LD_VAR 0 6
70423: PUSH
70424: LD_VAR 0 7
70428: PUSH
70429: LD_VAR 0 8
70433: PUSH
70434: LD_VAR 0 9
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: PPUSH
70445: LD_EXP 107
70449: PUSH
70450: LD_VAR 0 4
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 5
70460: ARRAY
70461: PPUSH
70462: CALL 82630 0 2
70466: IFFALSE 70559
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
70468: LD_ADDR_EXP 107
70472: PUSH
70473: LD_EXP 107
70477: PPUSH
70478: LD_VAR 0 4
70482: PPUSH
70483: LD_EXP 107
70487: PUSH
70488: LD_VAR 0 4
70492: ARRAY
70493: PPUSH
70494: LD_VAR 0 5
70498: PPUSH
70499: CALL_OW 3
70503: PPUSH
70504: CALL_OW 1
70508: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
70509: LD_ADDR_EXP 109
70513: PUSH
70514: LD_EXP 109
70518: PPUSH
70519: LD_VAR 0 4
70523: PUSH
70524: LD_EXP 109
70528: PUSH
70529: LD_VAR 0 4
70533: ARRAY
70534: PUSH
70535: LD_INT 1
70537: PLUS
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PPUSH
70543: LD_VAR 0 1
70547: PPUSH
70548: CALL 76023 0 3
70552: ST_TO_ADDR
// exit ;
70553: POP
70554: POP
70555: POP
70556: POP
70557: GO 70567
// end ;
70559: GO 70416
70561: POP
70562: POP
// end ;
70563: GO 70377
70565: POP
70566: POP
// end ;
70567: LD_VAR 0 3
70571: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
70572: LD_INT 0
70574: PPUSH
70575: PPUSH
70576: PPUSH
// if not mc_bases or not skirmish then
70577: LD_EXP 102
70581: NOT
70582: IFTRUE 70591
70584: PUSH
70585: LD_EXP 100
70589: NOT
70590: OR
70591: IFFALSE 70595
// exit ;
70593: GO 70791
// for i = 1 to mc_bases do
70595: LD_ADDR_VAR 0 4
70599: PUSH
70600: DOUBLE
70601: LD_INT 1
70603: DEC
70604: ST_TO_ADDR
70605: LD_EXP 102
70609: PUSH
70610: FOR_TO
70611: IFFALSE 70700
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
70613: LD_VAR 0 1
70617: PUSH
70618: LD_EXP 110
70622: PUSH
70623: LD_VAR 0 4
70627: ARRAY
70628: IN
70629: IFFALSE 70650
70631: PUSH
70632: LD_VAR 0 1
70636: PUSH
70637: LD_EXP 111
70641: PUSH
70642: LD_VAR 0 4
70646: ARRAY
70647: IN
70648: NOT
70649: AND
70650: IFFALSE 70698
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70652: LD_ADDR_EXP 111
70656: PUSH
70657: LD_EXP 111
70661: PPUSH
70662: LD_VAR 0 4
70666: PUSH
70667: LD_EXP 111
70671: PUSH
70672: LD_VAR 0 4
70676: ARRAY
70677: PUSH
70678: LD_INT 1
70680: PLUS
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PPUSH
70686: LD_VAR 0 1
70690: PPUSH
70691: CALL 76023 0 3
70695: ST_TO_ADDR
// break ;
70696: GO 70700
// end ; end ;
70698: GO 70610
70700: POP
70701: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70702: LD_VAR 0 1
70706: PPUSH
70707: CALL_OW 257
70711: PUSH
70712: LD_EXP 128
70716: IN
70717: IFFALSE 70734
70719: PUSH
70720: LD_VAR 0 1
70724: PPUSH
70725: CALL_OW 266
70729: PUSH
70730: LD_INT 5
70732: EQUAL
70733: AND
70734: IFFALSE 70751
70736: PUSH
70737: LD_VAR 0 2
70741: PPUSH
70742: CALL_OW 110
70746: PUSH
70747: LD_INT 18
70749: NONEQUAL
70750: AND
70751: IFFALSE 70791
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70753: LD_VAR 0 2
70757: PPUSH
70758: CALL_OW 257
70762: PUSH
70763: LD_INT 5
70765: PUSH
70766: LD_INT 8
70768: PUSH
70769: LD_INT 9
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: LIST
70776: IN
70777: IFFALSE 70791
// SetClass ( unit , 1 ) ;
70779: LD_VAR 0 2
70783: PPUSH
70784: LD_INT 1
70786: PPUSH
70787: CALL_OW 336
// end ;
70791: LD_VAR 0 3
70795: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70796: LD_INT 0
70798: PPUSH
70799: PPUSH
// if not mc_bases or not skirmish then
70800: LD_EXP 102
70804: NOT
70805: IFTRUE 70814
70807: PUSH
70808: LD_EXP 100
70812: NOT
70813: OR
70814: IFFALSE 70818
// exit ;
70816: GO 70934
// if GetLives ( abandoned_vehicle ) > 250 then
70818: LD_VAR 0 2
70822: PPUSH
70823: CALL_OW 256
70827: PUSH
70828: LD_INT 250
70830: GREATER
70831: IFFALSE 70835
// exit ;
70833: GO 70934
// for i = 1 to mc_bases do
70835: LD_ADDR_VAR 0 6
70839: PUSH
70840: DOUBLE
70841: LD_INT 1
70843: DEC
70844: ST_TO_ADDR
70845: LD_EXP 102
70849: PUSH
70850: FOR_TO
70851: IFFALSE 70932
// begin if driver in mc_bases [ i ] then
70853: LD_VAR 0 1
70857: PUSH
70858: LD_EXP 102
70862: PUSH
70863: LD_VAR 0 6
70867: ARRAY
70868: IN
70869: IFFALSE 70930
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70871: LD_VAR 0 1
70875: PPUSH
70876: LD_EXP 102
70880: PUSH
70881: LD_VAR 0 6
70885: ARRAY
70886: PPUSH
70887: LD_INT 2
70889: PUSH
70890: LD_INT 30
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 30
70902: PUSH
70903: LD_INT 1
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: PPUSH
70915: CALL_OW 72
70919: PUSH
70920: LD_INT 1
70922: ARRAY
70923: PPUSH
70924: CALL 109950 0 2
// break ;
70928: GO 70932
// end ; end ;
70930: GO 70850
70932: POP
70933: POP
// end ; end_of_file
70934: LD_VAR 0 5
70938: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70939: LD_INT 0
70941: PPUSH
70942: PPUSH
// if exist_mode then
70943: LD_VAR 0 2
70947: IFFALSE 70993
// begin unit := CreateCharacter ( prefix & ident ) ;
70949: LD_ADDR_VAR 0 5
70953: PUSH
70954: LD_VAR 0 3
70958: PUSH
70959: LD_VAR 0 1
70963: STR
70964: PPUSH
70965: CALL_OW 34
70969: ST_TO_ADDR
// if unit then
70970: LD_VAR 0 5
70974: IFFALSE 70991
// DeleteCharacters ( prefix & ident ) ;
70976: LD_VAR 0 3
70980: PUSH
70981: LD_VAR 0 1
70985: STR
70986: PPUSH
70987: CALL_OW 40
// end else
70991: GO 71008
// unit := NewCharacter ( ident ) ;
70993: LD_ADDR_VAR 0 5
70997: PUSH
70998: LD_VAR 0 1
71002: PPUSH
71003: CALL_OW 25
71007: ST_TO_ADDR
// result := unit ;
71008: LD_ADDR_VAR 0 4
71012: PUSH
71013: LD_VAR 0 5
71017: ST_TO_ADDR
// end ;
71018: LD_VAR 0 4
71022: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
71023: LD_INT 0
71025: PPUSH
71026: PPUSH
// if exist_mode then
71027: LD_VAR 0 2
71031: IFFALSE 71056
// unit := CreateCharacter ( prefix & ident ) else
71033: LD_ADDR_VAR 0 5
71037: PUSH
71038: LD_VAR 0 3
71042: PUSH
71043: LD_VAR 0 1
71047: STR
71048: PPUSH
71049: CALL_OW 34
71053: ST_TO_ADDR
71054: GO 71071
// unit := NewCharacter ( ident ) ;
71056: LD_ADDR_VAR 0 5
71060: PUSH
71061: LD_VAR 0 1
71065: PPUSH
71066: CALL_OW 25
71070: ST_TO_ADDR
// result := unit ;
71071: LD_ADDR_VAR 0 4
71075: PUSH
71076: LD_VAR 0 5
71080: ST_TO_ADDR
// end ;
71081: LD_VAR 0 4
71085: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
71086: LD_INT 0
71088: PPUSH
71089: PPUSH
// if not side or not nation then
71090: LD_VAR 0 1
71094: NOT
71095: IFTRUE 71104
71097: PUSH
71098: LD_VAR 0 2
71102: NOT
71103: OR
71104: IFFALSE 71108
// exit ;
71106: GO 71878
// case nation of nation_american :
71108: LD_VAR 0 2
71112: PUSH
71113: LD_INT 1
71115: DOUBLE
71116: EQUAL
71117: IFTRUE 71121
71119: GO 71335
71121: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
71122: LD_ADDR_VAR 0 4
71126: PUSH
71127: LD_INT 35
71129: PUSH
71130: LD_INT 45
71132: PUSH
71133: LD_INT 46
71135: PUSH
71136: LD_INT 47
71138: PUSH
71139: LD_INT 82
71141: PUSH
71142: LD_INT 83
71144: PUSH
71145: LD_INT 84
71147: PUSH
71148: LD_INT 85
71150: PUSH
71151: LD_INT 86
71153: PUSH
71154: LD_INT 1
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: LD_INT 6
71162: PUSH
71163: LD_INT 15
71165: PUSH
71166: LD_INT 16
71168: PUSH
71169: LD_INT 7
71171: PUSH
71172: LD_INT 12
71174: PUSH
71175: LD_INT 13
71177: PUSH
71178: LD_INT 10
71180: PUSH
71181: LD_INT 14
71183: PUSH
71184: LD_INT 20
71186: PUSH
71187: LD_INT 21
71189: PUSH
71190: LD_INT 22
71192: PUSH
71193: LD_INT 25
71195: PUSH
71196: LD_INT 32
71198: PUSH
71199: LD_INT 27
71201: PUSH
71202: LD_INT 36
71204: PUSH
71205: LD_INT 69
71207: PUSH
71208: LD_INT 39
71210: PUSH
71211: LD_INT 34
71213: PUSH
71214: LD_INT 40
71216: PUSH
71217: LD_INT 48
71219: PUSH
71220: LD_INT 49
71222: PUSH
71223: LD_INT 50
71225: PUSH
71226: LD_INT 51
71228: PUSH
71229: LD_INT 52
71231: PUSH
71232: LD_INT 53
71234: PUSH
71235: LD_INT 54
71237: PUSH
71238: LD_INT 55
71240: PUSH
71241: LD_INT 56
71243: PUSH
71244: LD_INT 57
71246: PUSH
71247: LD_INT 58
71249: PUSH
71250: LD_INT 59
71252: PUSH
71253: LD_INT 60
71255: PUSH
71256: LD_INT 61
71258: PUSH
71259: LD_INT 62
71261: PUSH
71262: LD_INT 80
71264: PUSH
71265: LD_INT 82
71267: PUSH
71268: LD_INT 83
71270: PUSH
71271: LD_INT 84
71273: PUSH
71274: LD_INT 85
71276: PUSH
71277: LD_INT 86
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: LIST
71284: LIST
71285: LIST
71286: LIST
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: ST_TO_ADDR
71333: GO 71800
71335: LD_INT 2
71337: DOUBLE
71338: EQUAL
71339: IFTRUE 71343
71341: GO 71569
71343: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
71344: LD_ADDR_VAR 0 4
71348: PUSH
71349: LD_INT 35
71351: PUSH
71352: LD_INT 45
71354: PUSH
71355: LD_INT 46
71357: PUSH
71358: LD_INT 47
71360: PUSH
71361: LD_INT 82
71363: PUSH
71364: LD_INT 83
71366: PUSH
71367: LD_INT 84
71369: PUSH
71370: LD_INT 85
71372: PUSH
71373: LD_INT 87
71375: PUSH
71376: LD_INT 70
71378: PUSH
71379: LD_INT 1
71381: PUSH
71382: LD_INT 11
71384: PUSH
71385: LD_INT 3
71387: PUSH
71388: LD_INT 4
71390: PUSH
71391: LD_INT 5
71393: PUSH
71394: LD_INT 6
71396: PUSH
71397: LD_INT 15
71399: PUSH
71400: LD_INT 18
71402: PUSH
71403: LD_INT 7
71405: PUSH
71406: LD_INT 17
71408: PUSH
71409: LD_INT 8
71411: PUSH
71412: LD_INT 20
71414: PUSH
71415: LD_INT 21
71417: PUSH
71418: LD_INT 22
71420: PUSH
71421: LD_INT 72
71423: PUSH
71424: LD_INT 26
71426: PUSH
71427: LD_INT 69
71429: PUSH
71430: LD_INT 39
71432: PUSH
71433: LD_INT 40
71435: PUSH
71436: LD_INT 41
71438: PUSH
71439: LD_INT 42
71441: PUSH
71442: LD_INT 43
71444: PUSH
71445: LD_INT 48
71447: PUSH
71448: LD_INT 49
71450: PUSH
71451: LD_INT 50
71453: PUSH
71454: LD_INT 51
71456: PUSH
71457: LD_INT 52
71459: PUSH
71460: LD_INT 53
71462: PUSH
71463: LD_INT 54
71465: PUSH
71466: LD_INT 55
71468: PUSH
71469: LD_INT 56
71471: PUSH
71472: LD_INT 60
71474: PUSH
71475: LD_INT 61
71477: PUSH
71478: LD_INT 62
71480: PUSH
71481: LD_INT 66
71483: PUSH
71484: LD_INT 67
71486: PUSH
71487: LD_INT 68
71489: PUSH
71490: LD_INT 81
71492: PUSH
71493: LD_INT 82
71495: PUSH
71496: LD_INT 83
71498: PUSH
71499: LD_INT 84
71501: PUSH
71502: LD_INT 85
71504: PUSH
71505: LD_INT 87
71507: PUSH
71508: LD_INT 88
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: LIST
71515: LIST
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: LIST
71521: LIST
71522: LIST
71523: LIST
71524: LIST
71525: LIST
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: LIST
71562: LIST
71563: LIST
71564: LIST
71565: LIST
71566: ST_TO_ADDR
71567: GO 71800
71569: LD_INT 3
71571: DOUBLE
71572: EQUAL
71573: IFTRUE 71577
71575: GO 71799
71577: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
71578: LD_ADDR_VAR 0 4
71582: PUSH
71583: LD_INT 46
71585: PUSH
71586: LD_INT 47
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: LD_INT 2
71594: PUSH
71595: LD_INT 82
71597: PUSH
71598: LD_INT 83
71600: PUSH
71601: LD_INT 84
71603: PUSH
71604: LD_INT 85
71606: PUSH
71607: LD_INT 86
71609: PUSH
71610: LD_INT 11
71612: PUSH
71613: LD_INT 9
71615: PUSH
71616: LD_INT 20
71618: PUSH
71619: LD_INT 19
71621: PUSH
71622: LD_INT 21
71624: PUSH
71625: LD_INT 24
71627: PUSH
71628: LD_INT 22
71630: PUSH
71631: LD_INT 25
71633: PUSH
71634: LD_INT 28
71636: PUSH
71637: LD_INT 29
71639: PUSH
71640: LD_INT 30
71642: PUSH
71643: LD_INT 31
71645: PUSH
71646: LD_INT 37
71648: PUSH
71649: LD_INT 38
71651: PUSH
71652: LD_INT 32
71654: PUSH
71655: LD_INT 27
71657: PUSH
71658: LD_INT 33
71660: PUSH
71661: LD_INT 69
71663: PUSH
71664: LD_INT 39
71666: PUSH
71667: LD_INT 34
71669: PUSH
71670: LD_INT 40
71672: PUSH
71673: LD_INT 71
71675: PUSH
71676: LD_INT 23
71678: PUSH
71679: LD_INT 44
71681: PUSH
71682: LD_INT 48
71684: PUSH
71685: LD_INT 49
71687: PUSH
71688: LD_INT 50
71690: PUSH
71691: LD_INT 51
71693: PUSH
71694: LD_INT 52
71696: PUSH
71697: LD_INT 53
71699: PUSH
71700: LD_INT 54
71702: PUSH
71703: LD_INT 55
71705: PUSH
71706: LD_INT 56
71708: PUSH
71709: LD_INT 57
71711: PUSH
71712: LD_INT 58
71714: PUSH
71715: LD_INT 59
71717: PUSH
71718: LD_INT 63
71720: PUSH
71721: LD_INT 64
71723: PUSH
71724: LD_INT 65
71726: PUSH
71727: LD_INT 82
71729: PUSH
71730: LD_INT 83
71732: PUSH
71733: LD_INT 84
71735: PUSH
71736: LD_INT 85
71738: PUSH
71739: LD_INT 86
71741: PUSH
71742: EMPTY
71743: LIST
71744: LIST
71745: LIST
71746: LIST
71747: LIST
71748: LIST
71749: LIST
71750: LIST
71751: LIST
71752: LIST
71753: LIST
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: ST_TO_ADDR
71797: GO 71800
71799: POP
// if state > - 1 and state < 3 then
71800: LD_VAR 0 3
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: GREATER
71809: IFFALSE 71821
71811: PUSH
71812: LD_VAR 0 3
71816: PUSH
71817: LD_INT 3
71819: LESS
71820: AND
71821: IFFALSE 71878
// for i in result do
71823: LD_ADDR_VAR 0 5
71827: PUSH
71828: LD_VAR 0 4
71832: PUSH
71833: FOR_IN
71834: IFFALSE 71876
// if GetTech ( i , side ) <> state then
71836: LD_VAR 0 5
71840: PPUSH
71841: LD_VAR 0 1
71845: PPUSH
71846: CALL_OW 321
71850: PUSH
71851: LD_VAR 0 3
71855: NONEQUAL
71856: IFFALSE 71874
// result := result diff i ;
71858: LD_ADDR_VAR 0 4
71862: PUSH
71863: LD_VAR 0 4
71867: PUSH
71868: LD_VAR 0 5
71872: DIFF
71873: ST_TO_ADDR
71874: GO 71833
71876: POP
71877: POP
// end ;
71878: LD_VAR 0 4
71882: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71883: LD_INT 0
71885: PPUSH
71886: PPUSH
71887: PPUSH
// result := true ;
71888: LD_ADDR_VAR 0 3
71892: PUSH
71893: LD_INT 1
71895: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71896: LD_ADDR_VAR 0 5
71900: PUSH
71901: LD_VAR 0 2
71905: PPUSH
71906: CALL_OW 480
71910: ST_TO_ADDR
// if not tmp then
71911: LD_VAR 0 5
71915: NOT
71916: IFFALSE 71920
// exit ;
71918: GO 71969
// for i in tmp do
71920: LD_ADDR_VAR 0 4
71924: PUSH
71925: LD_VAR 0 5
71929: PUSH
71930: FOR_IN
71931: IFFALSE 71967
// if GetTech ( i , side ) <> state_researched then
71933: LD_VAR 0 4
71937: PPUSH
71938: LD_VAR 0 1
71942: PPUSH
71943: CALL_OW 321
71947: PUSH
71948: LD_INT 2
71950: NONEQUAL
71951: IFFALSE 71965
// begin result := false ;
71953: LD_ADDR_VAR 0 3
71957: PUSH
71958: LD_INT 0
71960: ST_TO_ADDR
// exit ;
71961: POP
71962: POP
71963: GO 71969
// end ;
71965: GO 71930
71967: POP
71968: POP
// end ;
71969: LD_VAR 0 3
71973: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71974: LD_INT 0
71976: PPUSH
71977: PPUSH
71978: PPUSH
71979: PPUSH
71980: PPUSH
71981: PPUSH
71982: PPUSH
71983: PPUSH
71984: PPUSH
71985: PPUSH
71986: PPUSH
71987: PPUSH
71988: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
71989: LD_VAR 0 1
71993: NOT
71994: IFTRUE 72011
71996: PUSH
71997: LD_VAR 0 1
72001: PPUSH
72002: CALL_OW 257
72006: PUSH
72007: LD_INT 9
72009: NONEQUAL
72010: OR
72011: IFFALSE 72015
// exit ;
72013: GO 72594
// side := GetSide ( unit ) ;
72015: LD_ADDR_VAR 0 9
72019: PUSH
72020: LD_VAR 0 1
72024: PPUSH
72025: CALL_OW 255
72029: ST_TO_ADDR
// tech_space := tech_spacanom ;
72030: LD_ADDR_VAR 0 12
72034: PUSH
72035: LD_INT 29
72037: ST_TO_ADDR
// tech_time := tech_taurad ;
72038: LD_ADDR_VAR 0 13
72042: PUSH
72043: LD_INT 28
72045: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
72046: LD_ADDR_VAR 0 11
72050: PUSH
72051: LD_VAR 0 1
72055: PPUSH
72056: CALL_OW 310
72060: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
72061: LD_VAR 0 11
72065: PPUSH
72066: CALL_OW 247
72070: PUSH
72071: LD_INT 2
72073: EQUAL
72074: IFFALSE 72078
// exit ;
72076: GO 72594
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72078: LD_ADDR_VAR 0 8
72082: PUSH
72083: LD_INT 81
72085: PUSH
72086: LD_VAR 0 9
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 3
72097: PUSH
72098: LD_INT 21
72100: PUSH
72101: LD_INT 3
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: EMPTY
72109: LIST
72110: LIST
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PPUSH
72116: CALL_OW 69
72120: ST_TO_ADDR
// if not tmp then
72121: LD_VAR 0 8
72125: NOT
72126: IFFALSE 72130
// exit ;
72128: GO 72594
// if in_unit then
72130: LD_VAR 0 11
72134: IFFALSE 72158
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
72136: LD_ADDR_VAR 0 10
72140: PUSH
72141: LD_VAR 0 8
72145: PPUSH
72146: LD_VAR 0 11
72150: PPUSH
72151: CALL_OW 74
72155: ST_TO_ADDR
72156: GO 72178
// enemy := NearestUnitToUnit ( tmp , unit ) ;
72158: LD_ADDR_VAR 0 10
72162: PUSH
72163: LD_VAR 0 8
72167: PPUSH
72168: LD_VAR 0 1
72172: PPUSH
72173: CALL_OW 74
72177: ST_TO_ADDR
// if not enemy then
72178: LD_VAR 0 10
72182: NOT
72183: IFFALSE 72187
// exit ;
72185: GO 72594
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
72187: LD_VAR 0 11
72191: IFFALSE 72213
72193: PUSH
72194: LD_VAR 0 11
72198: PPUSH
72199: LD_VAR 0 10
72203: PPUSH
72204: CALL_OW 296
72208: PUSH
72209: LD_INT 13
72211: GREATER
72212: AND
72213: IFTRUE 72235
72215: PUSH
72216: LD_VAR 0 1
72220: PPUSH
72221: LD_VAR 0 10
72225: PPUSH
72226: CALL_OW 296
72230: PUSH
72231: LD_INT 12
72233: GREATER
72234: OR
72235: IFFALSE 72239
// exit ;
72237: GO 72594
// missile := [ 1 ] ;
72239: LD_ADDR_VAR 0 14
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: EMPTY
72248: LIST
72249: ST_TO_ADDR
// if Researched ( side , tech_space ) then
72250: LD_VAR 0 9
72254: PPUSH
72255: LD_VAR 0 12
72259: PPUSH
72260: CALL_OW 325
72264: IFFALSE 72293
// missile := Replace ( missile , missile + 1 , 2 ) ;
72266: LD_ADDR_VAR 0 14
72270: PUSH
72271: LD_VAR 0 14
72275: PPUSH
72276: LD_VAR 0 14
72280: PUSH
72281: LD_INT 1
72283: PLUS
72284: PPUSH
72285: LD_INT 2
72287: PPUSH
72288: CALL_OW 1
72292: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
72293: LD_VAR 0 9
72297: PPUSH
72298: LD_VAR 0 13
72302: PPUSH
72303: CALL_OW 325
72307: IFFALSE 72331
72309: PUSH
72310: LD_VAR 0 10
72314: PPUSH
72315: CALL_OW 255
72319: PPUSH
72320: LD_VAR 0 13
72324: PPUSH
72325: CALL_OW 325
72329: NOT
72330: AND
72331: IFFALSE 72360
// missile := Replace ( missile , missile + 1 , 3 ) ;
72333: LD_ADDR_VAR 0 14
72337: PUSH
72338: LD_VAR 0 14
72342: PPUSH
72343: LD_VAR 0 14
72347: PUSH
72348: LD_INT 1
72350: PLUS
72351: PPUSH
72352: LD_INT 3
72354: PPUSH
72355: CALL_OW 1
72359: ST_TO_ADDR
// if missile < 2 then
72360: LD_VAR 0 14
72364: PUSH
72365: LD_INT 2
72367: LESS
72368: IFFALSE 72372
// exit ;
72370: GO 72594
// x := GetX ( enemy ) ;
72372: LD_ADDR_VAR 0 4
72376: PUSH
72377: LD_VAR 0 10
72381: PPUSH
72382: CALL_OW 250
72386: ST_TO_ADDR
// y := GetY ( enemy ) ;
72387: LD_ADDR_VAR 0 5
72391: PUSH
72392: LD_VAR 0 10
72396: PPUSH
72397: CALL_OW 251
72401: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
72402: LD_ADDR_VAR 0 6
72406: PUSH
72407: LD_VAR 0 4
72411: PUSH
72412: LD_INT 1
72414: NEG
72415: PPUSH
72416: LD_INT 1
72418: PPUSH
72419: CALL_OW 12
72423: PLUS
72424: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
72425: LD_ADDR_VAR 0 7
72429: PUSH
72430: LD_VAR 0 5
72434: PUSH
72435: LD_INT 1
72437: NEG
72438: PPUSH
72439: LD_INT 1
72441: PPUSH
72442: CALL_OW 12
72446: PLUS
72447: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72448: LD_VAR 0 6
72452: PPUSH
72453: LD_VAR 0 7
72457: PPUSH
72458: CALL_OW 488
72462: NOT
72463: IFFALSE 72485
// begin _x := x ;
72465: LD_ADDR_VAR 0 6
72469: PUSH
72470: LD_VAR 0 4
72474: ST_TO_ADDR
// _y := y ;
72475: LD_ADDR_VAR 0 7
72479: PUSH
72480: LD_VAR 0 5
72484: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
72485: LD_ADDR_VAR 0 3
72489: PUSH
72490: LD_INT 1
72492: PPUSH
72493: LD_VAR 0 14
72497: PPUSH
72498: CALL_OW 12
72502: ST_TO_ADDR
// case i of 1 :
72503: LD_VAR 0 3
72507: PUSH
72508: LD_INT 1
72510: DOUBLE
72511: EQUAL
72512: IFTRUE 72516
72514: GO 72533
72516: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
72517: LD_VAR 0 1
72521: PPUSH
72522: LD_VAR 0 10
72526: PPUSH
72527: CALL_OW 115
72531: GO 72594
72533: LD_INT 2
72535: DOUBLE
72536: EQUAL
72537: IFTRUE 72541
72539: GO 72563
72541: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
72542: LD_VAR 0 1
72546: PPUSH
72547: LD_VAR 0 6
72551: PPUSH
72552: LD_VAR 0 7
72556: PPUSH
72557: CALL_OW 153
72561: GO 72594
72563: LD_INT 3
72565: DOUBLE
72566: EQUAL
72567: IFTRUE 72571
72569: GO 72593
72571: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
72572: LD_VAR 0 1
72576: PPUSH
72577: LD_VAR 0 6
72581: PPUSH
72582: LD_VAR 0 7
72586: PPUSH
72587: CALL_OW 154
72591: GO 72594
72593: POP
// end ;
72594: LD_VAR 0 2
72598: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
72599: LD_INT 0
72601: PPUSH
72602: PPUSH
72603: PPUSH
72604: PPUSH
72605: PPUSH
72606: PPUSH
// if not unit or not building then
72607: LD_VAR 0 1
72611: NOT
72612: IFTRUE 72621
72614: PUSH
72615: LD_VAR 0 2
72619: NOT
72620: OR
72621: IFFALSE 72625
// exit ;
72623: GO 72783
// x := GetX ( building ) ;
72625: LD_ADDR_VAR 0 5
72629: PUSH
72630: LD_VAR 0 2
72634: PPUSH
72635: CALL_OW 250
72639: ST_TO_ADDR
// y := GetY ( building ) ;
72640: LD_ADDR_VAR 0 6
72644: PUSH
72645: LD_VAR 0 2
72649: PPUSH
72650: CALL_OW 251
72654: ST_TO_ADDR
// for i := 0 to 5 do
72655: LD_ADDR_VAR 0 4
72659: PUSH
72660: DOUBLE
72661: LD_INT 0
72663: DEC
72664: ST_TO_ADDR
72665: LD_INT 5
72667: PUSH
72668: FOR_TO
72669: IFFALSE 72781
// begin _x := ShiftX ( x , i , 3 ) ;
72671: LD_ADDR_VAR 0 7
72675: PUSH
72676: LD_VAR 0 5
72680: PPUSH
72681: LD_VAR 0 4
72685: PPUSH
72686: LD_INT 3
72688: PPUSH
72689: CALL_OW 272
72693: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
72694: LD_ADDR_VAR 0 8
72698: PUSH
72699: LD_VAR 0 6
72703: PPUSH
72704: LD_VAR 0 4
72708: PPUSH
72709: LD_INT 3
72711: PPUSH
72712: CALL_OW 273
72716: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72717: LD_VAR 0 7
72721: PPUSH
72722: LD_VAR 0 8
72726: PPUSH
72727: CALL_OW 488
72731: NOT
72732: IFFALSE 72736
// continue ;
72734: GO 72668
// if HexInfo ( _x , _y ) = 0 then
72736: LD_VAR 0 7
72740: PPUSH
72741: LD_VAR 0 8
72745: PPUSH
72746: CALL_OW 428
72750: PUSH
72751: LD_INT 0
72753: EQUAL
72754: IFFALSE 72779
// begin ComMoveXY ( unit , _x , _y ) ;
72756: LD_VAR 0 1
72760: PPUSH
72761: LD_VAR 0 7
72765: PPUSH
72766: LD_VAR 0 8
72770: PPUSH
72771: CALL_OW 111
// exit ;
72775: POP
72776: POP
72777: GO 72783
// end ; end ;
72779: GO 72668
72781: POP
72782: POP
// end ;
72783: LD_VAR 0 3
72787: RET
// export function ScanBase ( side , base_area ) ; begin
72788: LD_INT 0
72790: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72791: LD_ADDR_VAR 0 3
72795: PUSH
72796: LD_VAR 0 2
72800: PPUSH
72801: LD_INT 81
72803: PUSH
72804: LD_VAR 0 1
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PPUSH
72813: CALL_OW 70
72817: ST_TO_ADDR
// end ;
72818: LD_VAR 0 3
72822: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72823: LD_INT 0
72825: PPUSH
72826: PPUSH
72827: PPUSH
72828: PPUSH
// result := false ;
72829: LD_ADDR_VAR 0 2
72833: PUSH
72834: LD_INT 0
72836: ST_TO_ADDR
// side := GetSide ( unit ) ;
72837: LD_ADDR_VAR 0 3
72841: PUSH
72842: LD_VAR 0 1
72846: PPUSH
72847: CALL_OW 255
72851: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72852: LD_ADDR_VAR 0 4
72856: PUSH
72857: LD_VAR 0 1
72861: PPUSH
72862: CALL_OW 248
72866: ST_TO_ADDR
// case nat of 1 :
72867: LD_VAR 0 4
72871: PUSH
72872: LD_INT 1
72874: DOUBLE
72875: EQUAL
72876: IFTRUE 72880
72878: GO 72891
72880: POP
// tech := tech_lassight ; 2 :
72881: LD_ADDR_VAR 0 5
72885: PUSH
72886: LD_INT 12
72888: ST_TO_ADDR
72889: GO 72930
72891: LD_INT 2
72893: DOUBLE
72894: EQUAL
72895: IFTRUE 72899
72897: GO 72910
72899: POP
// tech := tech_mortar ; 3 :
72900: LD_ADDR_VAR 0 5
72904: PUSH
72905: LD_INT 41
72907: ST_TO_ADDR
72908: GO 72930
72910: LD_INT 3
72912: DOUBLE
72913: EQUAL
72914: IFTRUE 72918
72916: GO 72929
72918: POP
// tech := tech_bazooka ; end ;
72919: LD_ADDR_VAR 0 5
72923: PUSH
72924: LD_INT 44
72926: ST_TO_ADDR
72927: GO 72930
72929: POP
// if Researched ( side , tech ) then
72930: LD_VAR 0 3
72934: PPUSH
72935: LD_VAR 0 5
72939: PPUSH
72940: CALL_OW 325
72944: IFFALSE 72971
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72946: LD_ADDR_VAR 0 2
72950: PUSH
72951: LD_INT 5
72953: PUSH
72954: LD_INT 8
72956: PUSH
72957: LD_INT 9
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: LIST
72964: PUSH
72965: LD_VAR 0 4
72969: ARRAY
72970: ST_TO_ADDR
// end ;
72971: LD_VAR 0 2
72975: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
72976: LD_INT 0
72978: PPUSH
72979: PPUSH
72980: PPUSH
// if not mines then
72981: LD_VAR 0 2
72985: NOT
72986: IFFALSE 72990
// exit ;
72988: GO 73134
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72990: LD_ADDR_VAR 0 5
72994: PUSH
72995: LD_INT 81
72997: PUSH
72998: LD_VAR 0 1
73002: PUSH
73003: EMPTY
73004: LIST
73005: LIST
73006: PUSH
73007: LD_INT 3
73009: PUSH
73010: LD_INT 21
73012: PUSH
73013: LD_INT 3
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: EMPTY
73025: LIST
73026: LIST
73027: PPUSH
73028: CALL_OW 69
73032: ST_TO_ADDR
// for i in mines do
73033: LD_ADDR_VAR 0 4
73037: PUSH
73038: LD_VAR 0 2
73042: PUSH
73043: FOR_IN
73044: IFFALSE 73132
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
73046: LD_VAR 0 4
73050: PUSH
73051: LD_INT 1
73053: ARRAY
73054: PPUSH
73055: LD_VAR 0 4
73059: PUSH
73060: LD_INT 2
73062: ARRAY
73063: PPUSH
73064: CALL_OW 458
73068: NOT
73069: IFFALSE 73073
// continue ;
73071: GO 73043
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
73073: LD_VAR 0 4
73077: PUSH
73078: LD_INT 1
73080: ARRAY
73081: PPUSH
73082: LD_VAR 0 4
73086: PUSH
73087: LD_INT 2
73089: ARRAY
73090: PPUSH
73091: CALL_OW 428
73095: PUSH
73096: LD_VAR 0 5
73100: IN
73101: IFFALSE 73130
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
73103: LD_VAR 0 4
73107: PUSH
73108: LD_INT 1
73110: ARRAY
73111: PPUSH
73112: LD_VAR 0 4
73116: PUSH
73117: LD_INT 2
73119: ARRAY
73120: PPUSH
73121: LD_VAR 0 1
73125: PPUSH
73126: CALL_OW 456
// end ;
73130: GO 73043
73132: POP
73133: POP
// end ;
73134: LD_VAR 0 3
73138: RET
// export function Count ( array ) ; begin
73139: LD_INT 0
73141: PPUSH
// result := array + 0 ;
73142: LD_ADDR_VAR 0 2
73146: PUSH
73147: LD_VAR 0 1
73151: PUSH
73152: LD_INT 0
73154: PLUS
73155: ST_TO_ADDR
// end ;
73156: LD_VAR 0 2
73160: RET
// export function IsEmpty ( building ) ; begin
73161: LD_INT 0
73163: PPUSH
// if not building then
73164: LD_VAR 0 1
73168: NOT
73169: IFFALSE 73173
// exit ;
73171: GO 73216
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
73173: LD_ADDR_VAR 0 2
73177: PUSH
73178: LD_VAR 0 1
73182: PUSH
73183: LD_INT 22
73185: PUSH
73186: LD_VAR 0 1
73190: PPUSH
73191: CALL_OW 255
73195: PUSH
73196: EMPTY
73197: LIST
73198: LIST
73199: PUSH
73200: LD_INT 58
73202: PUSH
73203: EMPTY
73204: LIST
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: PPUSH
73210: CALL_OW 69
73214: IN
73215: ST_TO_ADDR
// end ;
73216: LD_VAR 0 2
73220: RET
// export function IsNotFull ( building ) ; var places ; begin
73221: LD_INT 0
73223: PPUSH
73224: PPUSH
// if not building then
73225: LD_VAR 0 1
73229: NOT
73230: IFFALSE 73234
// exit ;
73232: GO 73262
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
73234: LD_ADDR_VAR 0 2
73238: PUSH
73239: LD_VAR 0 1
73243: PPUSH
73244: LD_INT 3
73246: PUSH
73247: LD_INT 62
73249: PUSH
73250: EMPTY
73251: LIST
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PPUSH
73257: CALL_OW 72
73261: ST_TO_ADDR
// end ;
73262: LD_VAR 0 2
73266: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
73267: LD_INT 0
73269: PPUSH
73270: PPUSH
73271: PPUSH
73272: PPUSH
// tmp := [ ] ;
73273: LD_ADDR_VAR 0 3
73277: PUSH
73278: EMPTY
73279: ST_TO_ADDR
// list := [ ] ;
73280: LD_ADDR_VAR 0 5
73284: PUSH
73285: EMPTY
73286: ST_TO_ADDR
// for i = 16 to 25 do
73287: LD_ADDR_VAR 0 4
73291: PUSH
73292: DOUBLE
73293: LD_INT 16
73295: DEC
73296: ST_TO_ADDR
73297: LD_INT 25
73299: PUSH
73300: FOR_TO
73301: IFFALSE 73374
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
73303: LD_ADDR_VAR 0 3
73307: PUSH
73308: LD_VAR 0 3
73312: PUSH
73313: LD_INT 22
73315: PUSH
73316: LD_VAR 0 1
73320: PPUSH
73321: CALL_OW 255
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 91
73332: PUSH
73333: LD_VAR 0 1
73337: PUSH
73338: LD_INT 6
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: LIST
73345: PUSH
73346: LD_INT 30
73348: PUSH
73349: LD_VAR 0 4
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: LIST
73362: PUSH
73363: EMPTY
73364: LIST
73365: PPUSH
73366: CALL_OW 69
73370: ADD
73371: ST_TO_ADDR
73372: GO 73300
73374: POP
73375: POP
// for i = 1 to tmp do
73376: LD_ADDR_VAR 0 4
73380: PUSH
73381: DOUBLE
73382: LD_INT 1
73384: DEC
73385: ST_TO_ADDR
73386: LD_VAR 0 3
73390: PUSH
73391: FOR_TO
73392: IFFALSE 73480
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
73394: LD_ADDR_VAR 0 5
73398: PUSH
73399: LD_VAR 0 5
73403: PUSH
73404: LD_VAR 0 3
73408: PUSH
73409: LD_VAR 0 4
73413: ARRAY
73414: PPUSH
73415: CALL_OW 266
73419: PUSH
73420: LD_VAR 0 3
73424: PUSH
73425: LD_VAR 0 4
73429: ARRAY
73430: PPUSH
73431: CALL_OW 250
73435: PUSH
73436: LD_VAR 0 3
73440: PUSH
73441: LD_VAR 0 4
73445: ARRAY
73446: PPUSH
73447: CALL_OW 251
73451: PUSH
73452: LD_VAR 0 3
73456: PUSH
73457: LD_VAR 0 4
73461: ARRAY
73462: PPUSH
73463: CALL_OW 254
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: PUSH
73474: EMPTY
73475: LIST
73476: ADD
73477: ST_TO_ADDR
73478: GO 73391
73480: POP
73481: POP
// result := list ;
73482: LD_ADDR_VAR 0 2
73486: PUSH
73487: LD_VAR 0 5
73491: ST_TO_ADDR
// end ;
73492: LD_VAR 0 2
73496: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
73497: LD_INT 0
73499: PPUSH
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
// if not factory then
73506: LD_VAR 0 1
73510: NOT
73511: IFFALSE 73515
// exit ;
73513: GO 74118
// if control = control_apeman then
73515: LD_VAR 0 4
73519: PUSH
73520: LD_INT 5
73522: EQUAL
73523: IFFALSE 73632
// begin tmp := UnitsInside ( factory ) ;
73525: LD_ADDR_VAR 0 8
73529: PUSH
73530: LD_VAR 0 1
73534: PPUSH
73535: CALL_OW 313
73539: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
73540: LD_VAR 0 8
73544: PPUSH
73545: LD_INT 25
73547: PUSH
73548: LD_INT 12
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PPUSH
73555: CALL_OW 72
73559: NOT
73560: IFFALSE 73570
// control := control_manual ;
73562: LD_ADDR_VAR 0 4
73566: PUSH
73567: LD_INT 1
73569: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
73570: LD_ADDR_VAR 0 8
73574: PUSH
73575: LD_VAR 0 1
73579: PPUSH
73580: CALL 73267 0 1
73584: ST_TO_ADDR
// if tmp then
73585: LD_VAR 0 8
73589: IFFALSE 73632
// begin for i in tmp do
73591: LD_ADDR_VAR 0 7
73595: PUSH
73596: LD_VAR 0 8
73600: PUSH
73601: FOR_IN
73602: IFFALSE 73630
// if i [ 1 ] = b_ext_radio then
73604: LD_VAR 0 7
73608: PUSH
73609: LD_INT 1
73611: ARRAY
73612: PUSH
73613: LD_INT 22
73615: EQUAL
73616: IFFALSE 73628
// begin control := control_remote ;
73618: LD_ADDR_VAR 0 4
73622: PUSH
73623: LD_INT 2
73625: ST_TO_ADDR
// break ;
73626: GO 73630
// end ;
73628: GO 73601
73630: POP
73631: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73632: LD_VAR 0 1
73636: PPUSH
73637: LD_VAR 0 2
73641: PPUSH
73642: LD_VAR 0 3
73646: PPUSH
73647: LD_VAR 0 4
73651: PPUSH
73652: LD_VAR 0 5
73656: PPUSH
73657: CALL_OW 448
73661: IFFALSE 73696
// begin result := [ chassis , engine , control , weapon ] ;
73663: LD_ADDR_VAR 0 6
73667: PUSH
73668: LD_VAR 0 2
73672: PUSH
73673: LD_VAR 0 3
73677: PUSH
73678: LD_VAR 0 4
73682: PUSH
73683: LD_VAR 0 5
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: LIST
73692: LIST
73693: ST_TO_ADDR
// exit ;
73694: GO 74118
// end ; _chassis := AvailableChassisList ( factory ) ;
73696: LD_ADDR_VAR 0 9
73700: PUSH
73701: LD_VAR 0 1
73705: PPUSH
73706: CALL_OW 475
73710: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
73711: LD_ADDR_VAR 0 11
73715: PUSH
73716: LD_VAR 0 1
73720: PPUSH
73721: CALL_OW 476
73725: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
73726: LD_ADDR_VAR 0 12
73730: PUSH
73731: LD_VAR 0 1
73735: PPUSH
73736: CALL_OW 477
73740: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
73741: LD_ADDR_VAR 0 10
73745: PUSH
73746: LD_VAR 0 1
73750: PPUSH
73751: CALL_OW 478
73755: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73756: LD_VAR 0 9
73760: NOT
73761: IFTRUE 73770
73763: PUSH
73764: LD_VAR 0 11
73768: NOT
73769: OR
73770: IFTRUE 73779
73772: PUSH
73773: LD_VAR 0 12
73777: NOT
73778: OR
73779: IFTRUE 73788
73781: PUSH
73782: LD_VAR 0 10
73786: NOT
73787: OR
73788: IFFALSE 73823
// begin result := [ chassis , engine , control , weapon ] ;
73790: LD_ADDR_VAR 0 6
73794: PUSH
73795: LD_VAR 0 2
73799: PUSH
73800: LD_VAR 0 3
73804: PUSH
73805: LD_VAR 0 4
73809: PUSH
73810: LD_VAR 0 5
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: ST_TO_ADDR
// exit ;
73821: GO 74118
// end ; if not chassis in _chassis then
73823: LD_VAR 0 2
73827: PUSH
73828: LD_VAR 0 9
73832: IN
73833: NOT
73834: IFFALSE 73860
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73836: LD_ADDR_VAR 0 2
73840: PUSH
73841: LD_VAR 0 9
73845: PUSH
73846: LD_INT 1
73848: PPUSH
73849: LD_VAR 0 9
73853: PPUSH
73854: CALL_OW 12
73858: ARRAY
73859: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73860: LD_VAR 0 2
73864: PPUSH
73865: LD_VAR 0 3
73869: PPUSH
73870: CALL 74123 0 2
73874: NOT
73875: IFFALSE 73936
// repeat engine := _engine [ 1 ] ;
73877: LD_ADDR_VAR 0 3
73881: PUSH
73882: LD_VAR 0 11
73886: PUSH
73887: LD_INT 1
73889: ARRAY
73890: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73891: LD_ADDR_VAR 0 11
73895: PUSH
73896: LD_VAR 0 11
73900: PPUSH
73901: LD_INT 1
73903: PPUSH
73904: CALL_OW 3
73908: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73909: LD_VAR 0 2
73913: PPUSH
73914: LD_VAR 0 3
73918: PPUSH
73919: CALL 74123 0 2
73923: IFTRUE 73934
73925: PUSH
73926: LD_VAR 0 11
73930: PUSH
73931: EMPTY
73932: EQUAL
73933: OR
73934: IFFALSE 73877
// if not control in _control then
73936: LD_VAR 0 4
73940: PUSH
73941: LD_VAR 0 12
73945: IN
73946: NOT
73947: IFFALSE 73973
// control := _control [ rand ( 1 , _control ) ] ;
73949: LD_ADDR_VAR 0 4
73953: PUSH
73954: LD_VAR 0 12
73958: PUSH
73959: LD_INT 1
73961: PPUSH
73962: LD_VAR 0 12
73966: PPUSH
73967: CALL_OW 12
73971: ARRAY
73972: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73973: LD_VAR 0 2
73977: PPUSH
73978: LD_VAR 0 5
73982: PPUSH
73983: CALL 74345 0 2
73987: NOT
73988: IFFALSE 74049
// repeat weapon := _weapon [ 1 ] ;
73990: LD_ADDR_VAR 0 5
73994: PUSH
73995: LD_VAR 0 10
73999: PUSH
74000: LD_INT 1
74002: ARRAY
74003: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
74004: LD_ADDR_VAR 0 10
74008: PUSH
74009: LD_VAR 0 10
74013: PPUSH
74014: LD_INT 1
74016: PPUSH
74017: CALL_OW 3
74021: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
74022: LD_VAR 0 2
74026: PPUSH
74027: LD_VAR 0 5
74031: PPUSH
74032: CALL 74345 0 2
74036: IFTRUE 74047
74038: PUSH
74039: LD_VAR 0 10
74043: PUSH
74044: EMPTY
74045: EQUAL
74046: OR
74047: IFFALSE 73990
// result := [ ] ;
74049: LD_ADDR_VAR 0 6
74053: PUSH
74054: EMPTY
74055: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
74056: LD_VAR 0 1
74060: PPUSH
74061: LD_VAR 0 2
74065: PPUSH
74066: LD_VAR 0 3
74070: PPUSH
74071: LD_VAR 0 4
74075: PPUSH
74076: LD_VAR 0 5
74080: PPUSH
74081: CALL_OW 448
74085: IFFALSE 74118
// result := [ chassis , engine , control , weapon ] ;
74087: LD_ADDR_VAR 0 6
74091: PUSH
74092: LD_VAR 0 2
74096: PUSH
74097: LD_VAR 0 3
74101: PUSH
74102: LD_VAR 0 4
74106: PUSH
74107: LD_VAR 0 5
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: LIST
74116: LIST
74117: ST_TO_ADDR
// end ;
74118: LD_VAR 0 6
74122: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
74123: LD_INT 0
74125: PPUSH
// if not chassis or not engine then
74126: LD_VAR 0 1
74130: NOT
74131: IFTRUE 74140
74133: PUSH
74134: LD_VAR 0 2
74138: NOT
74139: OR
74140: IFFALSE 74144
// exit ;
74142: GO 74340
// case engine of engine_solar :
74144: LD_VAR 0 2
74148: PUSH
74149: LD_INT 2
74151: DOUBLE
74152: EQUAL
74153: IFTRUE 74157
74155: GO 74195
74157: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
74158: LD_ADDR_VAR 0 3
74162: PUSH
74163: LD_INT 11
74165: PUSH
74166: LD_INT 12
74168: PUSH
74169: LD_INT 13
74171: PUSH
74172: LD_INT 14
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: LD_INT 3
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: ST_TO_ADDR
74193: GO 74324
74195: LD_INT 1
74197: DOUBLE
74198: EQUAL
74199: IFTRUE 74203
74201: GO 74265
74203: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
74204: LD_ADDR_VAR 0 3
74208: PUSH
74209: LD_INT 11
74211: PUSH
74212: LD_INT 12
74214: PUSH
74215: LD_INT 13
74217: PUSH
74218: LD_INT 14
74220: PUSH
74221: LD_INT 1
74223: PUSH
74224: LD_INT 2
74226: PUSH
74227: LD_INT 3
74229: PUSH
74230: LD_INT 4
74232: PUSH
74233: LD_INT 5
74235: PUSH
74236: LD_INT 21
74238: PUSH
74239: LD_INT 23
74241: PUSH
74242: LD_INT 22
74244: PUSH
74245: LD_INT 24
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: ST_TO_ADDR
74263: GO 74324
74265: LD_INT 3
74267: DOUBLE
74268: EQUAL
74269: IFTRUE 74273
74271: GO 74323
74273: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74274: LD_ADDR_VAR 0 3
74278: PUSH
74279: LD_INT 13
74281: PUSH
74282: LD_INT 14
74284: PUSH
74285: LD_INT 2
74287: PUSH
74288: LD_INT 3
74290: PUSH
74291: LD_INT 4
74293: PUSH
74294: LD_INT 5
74296: PUSH
74297: LD_INT 21
74299: PUSH
74300: LD_INT 22
74302: PUSH
74303: LD_INT 23
74305: PUSH
74306: LD_INT 24
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: ST_TO_ADDR
74321: GO 74324
74323: POP
// result := ( chassis in result ) ;
74324: LD_ADDR_VAR 0 3
74328: PUSH
74329: LD_VAR 0 1
74333: PUSH
74334: LD_VAR 0 3
74338: IN
74339: ST_TO_ADDR
// end ;
74340: LD_VAR 0 3
74344: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
74345: LD_INT 0
74347: PPUSH
// if not chassis or not weapon then
74348: LD_VAR 0 1
74352: NOT
74353: IFTRUE 74362
74355: PUSH
74356: LD_VAR 0 2
74360: NOT
74361: OR
74362: IFFALSE 74366
// exit ;
74364: GO 75426
// case weapon of us_machine_gun :
74366: LD_VAR 0 2
74370: PUSH
74371: LD_INT 2
74373: DOUBLE
74374: EQUAL
74375: IFTRUE 74379
74377: GO 74409
74379: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
74380: LD_ADDR_VAR 0 3
74384: PUSH
74385: LD_INT 1
74387: PUSH
74388: LD_INT 2
74390: PUSH
74391: LD_INT 3
74393: PUSH
74394: LD_INT 4
74396: PUSH
74397: LD_INT 5
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: LIST
74404: LIST
74405: LIST
74406: ST_TO_ADDR
74407: GO 75410
74409: LD_INT 3
74411: DOUBLE
74412: EQUAL
74413: IFTRUE 74417
74415: GO 74447
74417: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
74418: LD_ADDR_VAR 0 3
74422: PUSH
74423: LD_INT 1
74425: PUSH
74426: LD_INT 2
74428: PUSH
74429: LD_INT 3
74431: PUSH
74432: LD_INT 4
74434: PUSH
74435: LD_INT 5
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: ST_TO_ADDR
74445: GO 75410
74447: LD_INT 11
74449: DOUBLE
74450: EQUAL
74451: IFTRUE 74455
74453: GO 74485
74455: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
74456: LD_ADDR_VAR 0 3
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 2
74466: PUSH
74467: LD_INT 3
74469: PUSH
74470: LD_INT 4
74472: PUSH
74473: LD_INT 5
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: LIST
74480: LIST
74481: LIST
74482: ST_TO_ADDR
74483: GO 75410
74485: LD_INT 4
74487: DOUBLE
74488: EQUAL
74489: IFTRUE 74493
74491: GO 74519
74493: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
74494: LD_ADDR_VAR 0 3
74498: PUSH
74499: LD_INT 2
74501: PUSH
74502: LD_INT 3
74504: PUSH
74505: LD_INT 4
74507: PUSH
74508: LD_INT 5
74510: PUSH
74511: EMPTY
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: ST_TO_ADDR
74517: GO 75410
74519: LD_INT 5
74521: DOUBLE
74522: EQUAL
74523: IFTRUE 74527
74525: GO 74553
74527: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
74528: LD_ADDR_VAR 0 3
74532: PUSH
74533: LD_INT 2
74535: PUSH
74536: LD_INT 3
74538: PUSH
74539: LD_INT 4
74541: PUSH
74542: LD_INT 5
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: LIST
74549: LIST
74550: ST_TO_ADDR
74551: GO 75410
74553: LD_INT 9
74555: DOUBLE
74556: EQUAL
74557: IFTRUE 74561
74559: GO 74587
74561: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
74562: LD_ADDR_VAR 0 3
74566: PUSH
74567: LD_INT 2
74569: PUSH
74570: LD_INT 3
74572: PUSH
74573: LD_INT 4
74575: PUSH
74576: LD_INT 5
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: LIST
74583: LIST
74584: ST_TO_ADDR
74585: GO 75410
74587: LD_INT 7
74589: DOUBLE
74590: EQUAL
74591: IFTRUE 74595
74593: GO 74621
74595: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
74596: LD_ADDR_VAR 0 3
74600: PUSH
74601: LD_INT 2
74603: PUSH
74604: LD_INT 3
74606: PUSH
74607: LD_INT 4
74609: PUSH
74610: LD_INT 5
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: ST_TO_ADDR
74619: GO 75410
74621: LD_INT 12
74623: DOUBLE
74624: EQUAL
74625: IFTRUE 74629
74627: GO 74655
74629: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
74630: LD_ADDR_VAR 0 3
74634: PUSH
74635: LD_INT 2
74637: PUSH
74638: LD_INT 3
74640: PUSH
74641: LD_INT 4
74643: PUSH
74644: LD_INT 5
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: ST_TO_ADDR
74653: GO 75410
74655: LD_INT 13
74657: DOUBLE
74658: EQUAL
74659: IFTRUE 74663
74661: GO 74689
74663: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
74664: LD_ADDR_VAR 0 3
74668: PUSH
74669: LD_INT 2
74671: PUSH
74672: LD_INT 3
74674: PUSH
74675: LD_INT 4
74677: PUSH
74678: LD_INT 5
74680: PUSH
74681: EMPTY
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: ST_TO_ADDR
74687: GO 75410
74689: LD_INT 14
74691: DOUBLE
74692: EQUAL
74693: IFTRUE 74697
74695: GO 74715
74697: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
74698: LD_ADDR_VAR 0 3
74702: PUSH
74703: LD_INT 4
74705: PUSH
74706: LD_INT 5
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: ST_TO_ADDR
74713: GO 75410
74715: LD_INT 6
74717: DOUBLE
74718: EQUAL
74719: IFTRUE 74723
74721: GO 74741
74723: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
74724: LD_ADDR_VAR 0 3
74728: PUSH
74729: LD_INT 4
74731: PUSH
74732: LD_INT 5
74734: PUSH
74735: EMPTY
74736: LIST
74737: LIST
74738: ST_TO_ADDR
74739: GO 75410
74741: LD_INT 10
74743: DOUBLE
74744: EQUAL
74745: IFTRUE 74749
74747: GO 74767
74749: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
74750: LD_ADDR_VAR 0 3
74754: PUSH
74755: LD_INT 4
74757: PUSH
74758: LD_INT 5
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: ST_TO_ADDR
74765: GO 75410
74767: LD_INT 22
74769: DOUBLE
74770: EQUAL
74771: IFTRUE 74775
74773: GO 74801
74775: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74776: LD_ADDR_VAR 0 3
74780: PUSH
74781: LD_INT 11
74783: PUSH
74784: LD_INT 12
74786: PUSH
74787: LD_INT 13
74789: PUSH
74790: LD_INT 14
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: LIST
74797: LIST
74798: ST_TO_ADDR
74799: GO 75410
74801: LD_INT 23
74803: DOUBLE
74804: EQUAL
74805: IFTRUE 74809
74807: GO 74835
74809: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74810: LD_ADDR_VAR 0 3
74814: PUSH
74815: LD_INT 11
74817: PUSH
74818: LD_INT 12
74820: PUSH
74821: LD_INT 13
74823: PUSH
74824: LD_INT 14
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: LIST
74831: LIST
74832: ST_TO_ADDR
74833: GO 75410
74835: LD_INT 24
74837: DOUBLE
74838: EQUAL
74839: IFTRUE 74843
74841: GO 74869
74843: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74844: LD_ADDR_VAR 0 3
74848: PUSH
74849: LD_INT 11
74851: PUSH
74852: LD_INT 12
74854: PUSH
74855: LD_INT 13
74857: PUSH
74858: LD_INT 14
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: ST_TO_ADDR
74867: GO 75410
74869: LD_INT 30
74871: DOUBLE
74872: EQUAL
74873: IFTRUE 74877
74875: GO 74903
74877: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74878: LD_ADDR_VAR 0 3
74882: PUSH
74883: LD_INT 11
74885: PUSH
74886: LD_INT 12
74888: PUSH
74889: LD_INT 13
74891: PUSH
74892: LD_INT 14
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: LIST
74899: LIST
74900: ST_TO_ADDR
74901: GO 75410
74903: LD_INT 25
74905: DOUBLE
74906: EQUAL
74907: IFTRUE 74911
74909: GO 74929
74911: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74912: LD_ADDR_VAR 0 3
74916: PUSH
74917: LD_INT 13
74919: PUSH
74920: LD_INT 14
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: ST_TO_ADDR
74927: GO 75410
74929: LD_INT 27
74931: DOUBLE
74932: EQUAL
74933: IFTRUE 74937
74935: GO 74955
74937: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74938: LD_ADDR_VAR 0 3
74942: PUSH
74943: LD_INT 13
74945: PUSH
74946: LD_INT 14
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: ST_TO_ADDR
74953: GO 75410
74955: LD_INT 92
74957: DOUBLE
74958: EQUAL
74959: IFTRUE 74963
74961: GO 74989
74963: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74964: LD_ADDR_VAR 0 3
74968: PUSH
74969: LD_INT 11
74971: PUSH
74972: LD_INT 12
74974: PUSH
74975: LD_INT 13
74977: PUSH
74978: LD_INT 14
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: ST_TO_ADDR
74987: GO 75410
74989: LD_INT 28
74991: DOUBLE
74992: EQUAL
74993: IFTRUE 74997
74995: GO 75015
74997: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
74998: LD_ADDR_VAR 0 3
75002: PUSH
75003: LD_INT 13
75005: PUSH
75006: LD_INT 14
75008: PUSH
75009: EMPTY
75010: LIST
75011: LIST
75012: ST_TO_ADDR
75013: GO 75410
75015: LD_INT 29
75017: DOUBLE
75018: EQUAL
75019: IFTRUE 75023
75021: GO 75041
75023: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
75024: LD_ADDR_VAR 0 3
75028: PUSH
75029: LD_INT 13
75031: PUSH
75032: LD_INT 14
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: ST_TO_ADDR
75039: GO 75410
75041: LD_INT 31
75043: DOUBLE
75044: EQUAL
75045: IFTRUE 75049
75047: GO 75067
75049: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
75050: LD_ADDR_VAR 0 3
75054: PUSH
75055: LD_INT 13
75057: PUSH
75058: LD_INT 14
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: ST_TO_ADDR
75065: GO 75410
75067: LD_INT 26
75069: DOUBLE
75070: EQUAL
75071: IFTRUE 75075
75073: GO 75093
75075: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
75076: LD_ADDR_VAR 0 3
75080: PUSH
75081: LD_INT 13
75083: PUSH
75084: LD_INT 14
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: ST_TO_ADDR
75091: GO 75410
75093: LD_INT 42
75095: DOUBLE
75096: EQUAL
75097: IFTRUE 75101
75099: GO 75127
75101: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
75102: LD_ADDR_VAR 0 3
75106: PUSH
75107: LD_INT 21
75109: PUSH
75110: LD_INT 22
75112: PUSH
75113: LD_INT 23
75115: PUSH
75116: LD_INT 24
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: LIST
75123: LIST
75124: ST_TO_ADDR
75125: GO 75410
75127: LD_INT 43
75129: DOUBLE
75130: EQUAL
75131: IFTRUE 75135
75133: GO 75161
75135: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
75136: LD_ADDR_VAR 0 3
75140: PUSH
75141: LD_INT 21
75143: PUSH
75144: LD_INT 22
75146: PUSH
75147: LD_INT 23
75149: PUSH
75150: LD_INT 24
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: LIST
75157: LIST
75158: ST_TO_ADDR
75159: GO 75410
75161: LD_INT 44
75163: DOUBLE
75164: EQUAL
75165: IFTRUE 75169
75167: GO 75195
75169: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
75170: LD_ADDR_VAR 0 3
75174: PUSH
75175: LD_INT 21
75177: PUSH
75178: LD_INT 22
75180: PUSH
75181: LD_INT 23
75183: PUSH
75184: LD_INT 24
75186: PUSH
75187: EMPTY
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: ST_TO_ADDR
75193: GO 75410
75195: LD_INT 45
75197: DOUBLE
75198: EQUAL
75199: IFTRUE 75203
75201: GO 75229
75203: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
75204: LD_ADDR_VAR 0 3
75208: PUSH
75209: LD_INT 21
75211: PUSH
75212: LD_INT 22
75214: PUSH
75215: LD_INT 23
75217: PUSH
75218: LD_INT 24
75220: PUSH
75221: EMPTY
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: ST_TO_ADDR
75227: GO 75410
75229: LD_INT 49
75231: DOUBLE
75232: EQUAL
75233: IFTRUE 75237
75235: GO 75263
75237: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
75238: LD_ADDR_VAR 0 3
75242: PUSH
75243: LD_INT 21
75245: PUSH
75246: LD_INT 22
75248: PUSH
75249: LD_INT 23
75251: PUSH
75252: LD_INT 24
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: ST_TO_ADDR
75261: GO 75410
75263: LD_INT 51
75265: DOUBLE
75266: EQUAL
75267: IFTRUE 75271
75269: GO 75297
75271: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
75272: LD_ADDR_VAR 0 3
75276: PUSH
75277: LD_INT 21
75279: PUSH
75280: LD_INT 22
75282: PUSH
75283: LD_INT 23
75285: PUSH
75286: LD_INT 24
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: ST_TO_ADDR
75295: GO 75410
75297: LD_INT 52
75299: DOUBLE
75300: EQUAL
75301: IFTRUE 75305
75303: GO 75331
75305: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
75306: LD_ADDR_VAR 0 3
75310: PUSH
75311: LD_INT 21
75313: PUSH
75314: LD_INT 22
75316: PUSH
75317: LD_INT 23
75319: PUSH
75320: LD_INT 24
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: ST_TO_ADDR
75329: GO 75410
75331: LD_INT 53
75333: DOUBLE
75334: EQUAL
75335: IFTRUE 75339
75337: GO 75357
75339: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
75340: LD_ADDR_VAR 0 3
75344: PUSH
75345: LD_INT 23
75347: PUSH
75348: LD_INT 24
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: ST_TO_ADDR
75355: GO 75410
75357: LD_INT 46
75359: DOUBLE
75360: EQUAL
75361: IFTRUE 75365
75363: GO 75383
75365: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
75366: LD_ADDR_VAR 0 3
75370: PUSH
75371: LD_INT 23
75373: PUSH
75374: LD_INT 24
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: ST_TO_ADDR
75381: GO 75410
75383: LD_INT 47
75385: DOUBLE
75386: EQUAL
75387: IFTRUE 75391
75389: GO 75409
75391: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
75392: LD_ADDR_VAR 0 3
75396: PUSH
75397: LD_INT 23
75399: PUSH
75400: LD_INT 24
75402: PUSH
75403: EMPTY
75404: LIST
75405: LIST
75406: ST_TO_ADDR
75407: GO 75410
75409: POP
// result := ( chassis in result ) ;
75410: LD_ADDR_VAR 0 3
75414: PUSH
75415: LD_VAR 0 1
75419: PUSH
75420: LD_VAR 0 3
75424: IN
75425: ST_TO_ADDR
// end ;
75426: LD_VAR 0 3
75430: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
75431: LD_INT 0
75433: PPUSH
75434: PPUSH
75435: PPUSH
75436: PPUSH
75437: PPUSH
75438: PPUSH
75439: PPUSH
// result := array ;
75440: LD_ADDR_VAR 0 5
75444: PUSH
75445: LD_VAR 0 1
75449: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
75450: LD_VAR 0 1
75454: NOT
75455: IFTRUE 75464
75457: PUSH
75458: LD_VAR 0 2
75462: NOT
75463: OR
75464: IFTRUE 75473
75466: PUSH
75467: LD_VAR 0 3
75471: NOT
75472: OR
75473: IFTRUE 75487
75475: PUSH
75476: LD_VAR 0 2
75480: PUSH
75481: LD_VAR 0 1
75485: GREATER
75486: OR
75487: IFTRUE 75501
75489: PUSH
75490: LD_VAR 0 3
75494: PUSH
75495: LD_VAR 0 1
75499: GREATER
75500: OR
75501: IFFALSE 75505
// exit ;
75503: GO 75801
// if direction then
75505: LD_VAR 0 4
75509: IFFALSE 75573
// begin d := 1 ;
75511: LD_ADDR_VAR 0 9
75515: PUSH
75516: LD_INT 1
75518: ST_TO_ADDR
// if i_from > i_to then
75519: LD_VAR 0 2
75523: PUSH
75524: LD_VAR 0 3
75528: GREATER
75529: IFFALSE 75555
// length := ( array - i_from ) + i_to else
75531: LD_ADDR_VAR 0 11
75535: PUSH
75536: LD_VAR 0 1
75540: PUSH
75541: LD_VAR 0 2
75545: MINUS
75546: PUSH
75547: LD_VAR 0 3
75551: PLUS
75552: ST_TO_ADDR
75553: GO 75571
// length := i_to - i_from ;
75555: LD_ADDR_VAR 0 11
75559: PUSH
75560: LD_VAR 0 3
75564: PUSH
75565: LD_VAR 0 2
75569: MINUS
75570: ST_TO_ADDR
// end else
75571: GO 75634
// begin d := - 1 ;
75573: LD_ADDR_VAR 0 9
75577: PUSH
75578: LD_INT 1
75580: NEG
75581: ST_TO_ADDR
// if i_from > i_to then
75582: LD_VAR 0 2
75586: PUSH
75587: LD_VAR 0 3
75591: GREATER
75592: IFFALSE 75612
// length := i_from - i_to else
75594: LD_ADDR_VAR 0 11
75598: PUSH
75599: LD_VAR 0 2
75603: PUSH
75604: LD_VAR 0 3
75608: MINUS
75609: ST_TO_ADDR
75610: GO 75634
// length := ( array - i_to ) + i_from ;
75612: LD_ADDR_VAR 0 11
75616: PUSH
75617: LD_VAR 0 1
75621: PUSH
75622: LD_VAR 0 3
75626: MINUS
75627: PUSH
75628: LD_VAR 0 2
75632: PLUS
75633: ST_TO_ADDR
// end ; if not length then
75634: LD_VAR 0 11
75638: NOT
75639: IFFALSE 75643
// exit ;
75641: GO 75801
// tmp := array ;
75643: LD_ADDR_VAR 0 10
75647: PUSH
75648: LD_VAR 0 1
75652: ST_TO_ADDR
// for i = 1 to length do
75653: LD_ADDR_VAR 0 6
75657: PUSH
75658: DOUBLE
75659: LD_INT 1
75661: DEC
75662: ST_TO_ADDR
75663: LD_VAR 0 11
75667: PUSH
75668: FOR_TO
75669: IFFALSE 75789
// begin for j = 1 to array do
75671: LD_ADDR_VAR 0 7
75675: PUSH
75676: DOUBLE
75677: LD_INT 1
75679: DEC
75680: ST_TO_ADDR
75681: LD_VAR 0 1
75685: PUSH
75686: FOR_TO
75687: IFFALSE 75775
// begin k := j + d ;
75689: LD_ADDR_VAR 0 8
75693: PUSH
75694: LD_VAR 0 7
75698: PUSH
75699: LD_VAR 0 9
75703: PLUS
75704: ST_TO_ADDR
// if k > array then
75705: LD_VAR 0 8
75709: PUSH
75710: LD_VAR 0 1
75714: GREATER
75715: IFFALSE 75725
// k := 1 ;
75717: LD_ADDR_VAR 0 8
75721: PUSH
75722: LD_INT 1
75724: ST_TO_ADDR
// if not k then
75725: LD_VAR 0 8
75729: NOT
75730: IFFALSE 75742
// k := array ;
75732: LD_ADDR_VAR 0 8
75736: PUSH
75737: LD_VAR 0 1
75741: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
75742: LD_ADDR_VAR 0 10
75746: PUSH
75747: LD_VAR 0 10
75751: PPUSH
75752: LD_VAR 0 8
75756: PPUSH
75757: LD_VAR 0 1
75761: PUSH
75762: LD_VAR 0 7
75766: ARRAY
75767: PPUSH
75768: CALL_OW 1
75772: ST_TO_ADDR
// end ;
75773: GO 75686
75775: POP
75776: POP
// array := tmp ;
75777: LD_ADDR_VAR 0 1
75781: PUSH
75782: LD_VAR 0 10
75786: ST_TO_ADDR
// end ;
75787: GO 75668
75789: POP
75790: POP
// result := array ;
75791: LD_ADDR_VAR 0 5
75795: PUSH
75796: LD_VAR 0 1
75800: ST_TO_ADDR
// end ;
75801: LD_VAR 0 5
75805: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75806: LD_INT 0
75808: PPUSH
75809: PPUSH
// result := 0 ;
75810: LD_ADDR_VAR 0 3
75814: PUSH
75815: LD_INT 0
75817: ST_TO_ADDR
// if not array or not value in array then
75818: LD_VAR 0 1
75822: NOT
75823: IFTRUE 75838
75825: PUSH
75826: LD_VAR 0 2
75830: PUSH
75831: LD_VAR 0 1
75835: IN
75836: NOT
75837: OR
75838: IFFALSE 75842
// exit ;
75840: GO 75896
// for i = 1 to array do
75842: LD_ADDR_VAR 0 4
75846: PUSH
75847: DOUBLE
75848: LD_INT 1
75850: DEC
75851: ST_TO_ADDR
75852: LD_VAR 0 1
75856: PUSH
75857: FOR_TO
75858: IFFALSE 75894
// if value = array [ i ] then
75860: LD_VAR 0 2
75864: PUSH
75865: LD_VAR 0 1
75869: PUSH
75870: LD_VAR 0 4
75874: ARRAY
75875: EQUAL
75876: IFFALSE 75892
// begin result := i ;
75878: LD_ADDR_VAR 0 3
75882: PUSH
75883: LD_VAR 0 4
75887: ST_TO_ADDR
// exit ;
75888: POP
75889: POP
75890: GO 75896
// end ;
75892: GO 75857
75894: POP
75895: POP
// end ;
75896: LD_VAR 0 3
75900: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75901: LD_INT 0
75903: PPUSH
// vc_chassis := chassis ;
75904: LD_ADDR_OWVAR 37
75908: PUSH
75909: LD_VAR 0 1
75913: ST_TO_ADDR
// vc_engine := engine ;
75914: LD_ADDR_OWVAR 39
75918: PUSH
75919: LD_VAR 0 2
75923: ST_TO_ADDR
// vc_control := control ;
75924: LD_ADDR_OWVAR 38
75928: PUSH
75929: LD_VAR 0 3
75933: ST_TO_ADDR
// vc_weapon := weapon ;
75934: LD_ADDR_OWVAR 40
75938: PUSH
75939: LD_VAR 0 4
75943: ST_TO_ADDR
// vc_fuel_battery := fuel ;
75944: LD_ADDR_OWVAR 41
75948: PUSH
75949: LD_VAR 0 5
75953: ST_TO_ADDR
// end ;
75954: LD_VAR 0 6
75958: RET
// export function WantPlant ( unit ) ; var task ; begin
75959: LD_INT 0
75961: PPUSH
75962: PPUSH
// result := false ;
75963: LD_ADDR_VAR 0 2
75967: PUSH
75968: LD_INT 0
75970: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
75971: LD_ADDR_VAR 0 3
75975: PUSH
75976: LD_VAR 0 1
75980: PPUSH
75981: CALL_OW 437
75985: ST_TO_ADDR
// if task then
75986: LD_VAR 0 3
75990: IFFALSE 76018
// if task [ 1 ] [ 1 ] = p then
75992: LD_VAR 0 3
75996: PUSH
75997: LD_INT 1
75999: ARRAY
76000: PUSH
76001: LD_INT 1
76003: ARRAY
76004: PUSH
76005: LD_STRING p
76007: EQUAL
76008: IFFALSE 76018
// result := true ;
76010: LD_ADDR_VAR 0 2
76014: PUSH
76015: LD_INT 1
76017: ST_TO_ADDR
// end ;
76018: LD_VAR 0 2
76022: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
76023: LD_INT 0
76025: PPUSH
76026: PPUSH
76027: PPUSH
76028: PPUSH
// if pos < 1 then
76029: LD_VAR 0 2
76033: PUSH
76034: LD_INT 1
76036: LESS
76037: IFFALSE 76041
// exit ;
76039: GO 76344
// if pos = 1 then
76041: LD_VAR 0 2
76045: PUSH
76046: LD_INT 1
76048: EQUAL
76049: IFFALSE 76082
// result := Replace ( arr , pos [ 1 ] , value ) else
76051: LD_ADDR_VAR 0 4
76055: PUSH
76056: LD_VAR 0 1
76060: PPUSH
76061: LD_VAR 0 2
76065: PUSH
76066: LD_INT 1
76068: ARRAY
76069: PPUSH
76070: LD_VAR 0 3
76074: PPUSH
76075: CALL_OW 1
76079: ST_TO_ADDR
76080: GO 76344
// begin tmp := arr ;
76082: LD_ADDR_VAR 0 6
76086: PUSH
76087: LD_VAR 0 1
76091: ST_TO_ADDR
// s_arr := [ tmp ] ;
76092: LD_ADDR_VAR 0 7
76096: PUSH
76097: LD_VAR 0 6
76101: PUSH
76102: EMPTY
76103: LIST
76104: ST_TO_ADDR
// for i = 1 to pos - 1 do
76105: LD_ADDR_VAR 0 5
76109: PUSH
76110: DOUBLE
76111: LD_INT 1
76113: DEC
76114: ST_TO_ADDR
76115: LD_VAR 0 2
76119: PUSH
76120: LD_INT 1
76122: MINUS
76123: PUSH
76124: FOR_TO
76125: IFFALSE 76170
// begin tmp := tmp [ pos [ i ] ] ;
76127: LD_ADDR_VAR 0 6
76131: PUSH
76132: LD_VAR 0 6
76136: PUSH
76137: LD_VAR 0 2
76141: PUSH
76142: LD_VAR 0 5
76146: ARRAY
76147: ARRAY
76148: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
76149: LD_ADDR_VAR 0 7
76153: PUSH
76154: LD_VAR 0 7
76158: PUSH
76159: LD_VAR 0 6
76163: PUSH
76164: EMPTY
76165: LIST
76166: ADD
76167: ST_TO_ADDR
// end ;
76168: GO 76124
76170: POP
76171: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
76172: LD_ADDR_VAR 0 6
76176: PUSH
76177: LD_VAR 0 6
76181: PPUSH
76182: LD_VAR 0 2
76186: PUSH
76187: LD_VAR 0 2
76191: ARRAY
76192: PPUSH
76193: LD_VAR 0 3
76197: PPUSH
76198: CALL_OW 1
76202: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
76203: LD_ADDR_VAR 0 7
76207: PUSH
76208: LD_VAR 0 7
76212: PPUSH
76213: LD_VAR 0 7
76217: PPUSH
76218: LD_VAR 0 6
76222: PPUSH
76223: CALL_OW 1
76227: ST_TO_ADDR
// for i = s_arr downto 2 do
76228: LD_ADDR_VAR 0 5
76232: PUSH
76233: DOUBLE
76234: LD_VAR 0 7
76238: INC
76239: ST_TO_ADDR
76240: LD_INT 2
76242: PUSH
76243: FOR_DOWNTO
76244: IFFALSE 76328
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
76246: LD_ADDR_VAR 0 6
76250: PUSH
76251: LD_VAR 0 7
76255: PUSH
76256: LD_VAR 0 5
76260: PUSH
76261: LD_INT 1
76263: MINUS
76264: ARRAY
76265: PPUSH
76266: LD_VAR 0 2
76270: PUSH
76271: LD_VAR 0 5
76275: PUSH
76276: LD_INT 1
76278: MINUS
76279: ARRAY
76280: PPUSH
76281: LD_VAR 0 7
76285: PUSH
76286: LD_VAR 0 5
76290: ARRAY
76291: PPUSH
76292: CALL_OW 1
76296: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
76297: LD_ADDR_VAR 0 7
76301: PUSH
76302: LD_VAR 0 7
76306: PPUSH
76307: LD_VAR 0 5
76311: PUSH
76312: LD_INT 1
76314: MINUS
76315: PPUSH
76316: LD_VAR 0 6
76320: PPUSH
76321: CALL_OW 1
76325: ST_TO_ADDR
// end ;
76326: GO 76243
76328: POP
76329: POP
// result := s_arr [ 1 ] ;
76330: LD_ADDR_VAR 0 4
76334: PUSH
76335: LD_VAR 0 7
76339: PUSH
76340: LD_INT 1
76342: ARRAY
76343: ST_TO_ADDR
// end ; end ;
76344: LD_VAR 0 4
76348: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
76349: LD_INT 0
76351: PPUSH
76352: PPUSH
// if not list then
76353: LD_VAR 0 1
76357: NOT
76358: IFFALSE 76362
// exit ;
76360: GO 76453
// i := list [ pos1 ] ;
76362: LD_ADDR_VAR 0 5
76366: PUSH
76367: LD_VAR 0 1
76371: PUSH
76372: LD_VAR 0 2
76376: ARRAY
76377: ST_TO_ADDR
// if not i then
76378: LD_VAR 0 5
76382: NOT
76383: IFFALSE 76387
// exit ;
76385: GO 76453
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
76387: LD_ADDR_VAR 0 1
76391: PUSH
76392: LD_VAR 0 1
76396: PPUSH
76397: LD_VAR 0 2
76401: PPUSH
76402: LD_VAR 0 1
76406: PUSH
76407: LD_VAR 0 3
76411: ARRAY
76412: PPUSH
76413: CALL_OW 1
76417: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
76418: LD_ADDR_VAR 0 1
76422: PUSH
76423: LD_VAR 0 1
76427: PPUSH
76428: LD_VAR 0 3
76432: PPUSH
76433: LD_VAR 0 5
76437: PPUSH
76438: CALL_OW 1
76442: ST_TO_ADDR
// result := list ;
76443: LD_ADDR_VAR 0 4
76447: PUSH
76448: LD_VAR 0 1
76452: ST_TO_ADDR
// end ;
76453: LD_VAR 0 4
76457: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
76458: LD_INT 0
76460: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
76461: LD_ADDR_VAR 0 5
76465: PUSH
76466: LD_VAR 0 1
76470: PPUSH
76471: CALL_OW 250
76475: PPUSH
76476: LD_VAR 0 1
76480: PPUSH
76481: CALL_OW 251
76485: PPUSH
76486: LD_VAR 0 2
76490: PPUSH
76491: LD_VAR 0 3
76495: PPUSH
76496: LD_VAR 0 4
76500: PPUSH
76501: CALL 76883 0 5
76505: ST_TO_ADDR
// end ;
76506: LD_VAR 0 5
76510: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
76511: LD_INT 0
76513: PPUSH
76514: PPUSH
76515: PPUSH
76516: PPUSH
// if not list or not unit then
76517: LD_VAR 0 2
76521: NOT
76522: IFTRUE 76531
76524: PUSH
76525: LD_VAR 0 1
76529: NOT
76530: OR
76531: IFFALSE 76535
// exit ;
76533: GO 76878
// result := [ ] ;
76535: LD_ADDR_VAR 0 5
76539: PUSH
76540: EMPTY
76541: ST_TO_ADDR
// for i in list do
76542: LD_ADDR_VAR 0 6
76546: PUSH
76547: LD_VAR 0 2
76551: PUSH
76552: FOR_IN
76553: IFFALSE 76771
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
76555: LD_ADDR_VAR 0 8
76559: PUSH
76560: LD_VAR 0 1
76564: PPUSH
76565: LD_VAR 0 6
76569: PUSH
76570: LD_INT 1
76572: ARRAY
76573: PPUSH
76574: LD_VAR 0 6
76578: PUSH
76579: LD_INT 2
76581: ARRAY
76582: PPUSH
76583: CALL_OW 297
76587: ST_TO_ADDR
// if not Count ( result ) then
76588: LD_VAR 0 5
76592: PPUSH
76593: CALL 73139 0 1
76597: NOT
76598: IFFALSE 76631
// begin result := Join ( result , [ i , tmp ] ) ;
76600: LD_ADDR_VAR 0 5
76604: PUSH
76605: LD_VAR 0 5
76609: PPUSH
76610: LD_VAR 0 6
76614: PUSH
76615: LD_VAR 0 8
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PPUSH
76624: CALL 109071 0 2
76628: ST_TO_ADDR
// continue ;
76629: GO 76552
// end ; if result [ result ] [ 2 ] <= tmp then
76631: LD_VAR 0 5
76635: PUSH
76636: LD_VAR 0 5
76640: ARRAY
76641: PUSH
76642: LD_INT 2
76644: ARRAY
76645: PUSH
76646: LD_VAR 0 8
76650: LESSEQUAL
76651: IFFALSE 76684
// result := Join ( result , [ i , tmp ] ) else
76653: LD_ADDR_VAR 0 5
76657: PUSH
76658: LD_VAR 0 5
76662: PPUSH
76663: LD_VAR 0 6
76667: PUSH
76668: LD_VAR 0 8
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: PPUSH
76677: CALL 109071 0 2
76681: ST_TO_ADDR
76682: GO 76769
// begin for j := 1 to Count ( result ) do
76684: LD_ADDR_VAR 0 7
76688: PUSH
76689: DOUBLE
76690: LD_INT 1
76692: DEC
76693: ST_TO_ADDR
76694: LD_VAR 0 5
76698: PPUSH
76699: CALL 73139 0 1
76703: PUSH
76704: FOR_TO
76705: IFFALSE 76767
// begin if tmp < result [ j ] [ 2 ] then
76707: LD_VAR 0 8
76711: PUSH
76712: LD_VAR 0 5
76716: PUSH
76717: LD_VAR 0 7
76721: ARRAY
76722: PUSH
76723: LD_INT 2
76725: ARRAY
76726: LESS
76727: IFFALSE 76765
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76729: LD_ADDR_VAR 0 5
76733: PUSH
76734: LD_VAR 0 5
76738: PPUSH
76739: LD_VAR 0 7
76743: PPUSH
76744: LD_VAR 0 6
76748: PUSH
76749: LD_VAR 0 8
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PPUSH
76758: CALL_OW 2
76762: ST_TO_ADDR
// break ;
76763: GO 76767
// end ; end ;
76765: GO 76704
76767: POP
76768: POP
// end ; end ;
76769: GO 76552
76771: POP
76772: POP
// if result and not asc then
76773: LD_VAR 0 5
76777: IFFALSE 76786
76779: PUSH
76780: LD_VAR 0 3
76784: NOT
76785: AND
76786: IFFALSE 76803
// result := ReverseArray ( result ) ;
76788: LD_ADDR_VAR 0 5
76792: PUSH
76793: LD_VAR 0 5
76797: PPUSH
76798: CALL 104161 0 1
76802: ST_TO_ADDR
// tmp := [ ] ;
76803: LD_ADDR_VAR 0 8
76807: PUSH
76808: EMPTY
76809: ST_TO_ADDR
// if mode then
76810: LD_VAR 0 4
76814: IFFALSE 76878
// begin for i := 1 to result do
76816: LD_ADDR_VAR 0 6
76820: PUSH
76821: DOUBLE
76822: LD_INT 1
76824: DEC
76825: ST_TO_ADDR
76826: LD_VAR 0 5
76830: PUSH
76831: FOR_TO
76832: IFFALSE 76866
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76834: LD_ADDR_VAR 0 8
76838: PUSH
76839: LD_VAR 0 8
76843: PPUSH
76844: LD_VAR 0 5
76848: PUSH
76849: LD_VAR 0 6
76853: ARRAY
76854: PUSH
76855: LD_INT 1
76857: ARRAY
76858: PPUSH
76859: CALL 109071 0 2
76863: ST_TO_ADDR
76864: GO 76831
76866: POP
76867: POP
// result := tmp ;
76868: LD_ADDR_VAR 0 5
76872: PUSH
76873: LD_VAR 0 8
76877: ST_TO_ADDR
// end ; end ;
76878: LD_VAR 0 5
76882: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76883: LD_INT 0
76885: PPUSH
76886: PPUSH
76887: PPUSH
76888: PPUSH
// if not list then
76889: LD_VAR 0 3
76893: NOT
76894: IFFALSE 76898
// exit ;
76896: GO 77288
// result := [ ] ;
76898: LD_ADDR_VAR 0 6
76902: PUSH
76903: EMPTY
76904: ST_TO_ADDR
// for i in list do
76905: LD_ADDR_VAR 0 7
76909: PUSH
76910: LD_VAR 0 3
76914: PUSH
76915: FOR_IN
76916: IFFALSE 77118
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76918: LD_ADDR_VAR 0 9
76922: PUSH
76923: LD_VAR 0 7
76927: PPUSH
76928: LD_VAR 0 1
76932: PPUSH
76933: LD_VAR 0 2
76937: PPUSH
76938: CALL_OW 297
76942: ST_TO_ADDR
// if not result then
76943: LD_VAR 0 6
76947: NOT
76948: IFFALSE 76974
// result := [ [ i , tmp ] ] else
76950: LD_ADDR_VAR 0 6
76954: PUSH
76955: LD_VAR 0 7
76959: PUSH
76960: LD_VAR 0 9
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: EMPTY
76970: LIST
76971: ST_TO_ADDR
76972: GO 77116
// begin if result [ result ] [ 2 ] <= tmp then
76974: LD_VAR 0 6
76978: PUSH
76979: LD_VAR 0 6
76983: ARRAY
76984: PUSH
76985: LD_INT 2
76987: ARRAY
76988: PUSH
76989: LD_VAR 0 9
76993: LESSEQUAL
76994: IFFALSE 77036
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
76996: LD_ADDR_VAR 0 6
77000: PUSH
77001: LD_VAR 0 6
77005: PPUSH
77006: LD_VAR 0 6
77010: PUSH
77011: LD_INT 1
77013: PLUS
77014: PPUSH
77015: LD_VAR 0 7
77019: PUSH
77020: LD_VAR 0 9
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PPUSH
77029: CALL_OW 2
77033: ST_TO_ADDR
77034: GO 77116
// for j := 1 to result do
77036: LD_ADDR_VAR 0 8
77040: PUSH
77041: DOUBLE
77042: LD_INT 1
77044: DEC
77045: ST_TO_ADDR
77046: LD_VAR 0 6
77050: PUSH
77051: FOR_TO
77052: IFFALSE 77114
// begin if tmp < result [ j ] [ 2 ] then
77054: LD_VAR 0 9
77058: PUSH
77059: LD_VAR 0 6
77063: PUSH
77064: LD_VAR 0 8
77068: ARRAY
77069: PUSH
77070: LD_INT 2
77072: ARRAY
77073: LESS
77074: IFFALSE 77112
// begin result := Insert ( result , j , [ i , tmp ] ) ;
77076: LD_ADDR_VAR 0 6
77080: PUSH
77081: LD_VAR 0 6
77085: PPUSH
77086: LD_VAR 0 8
77090: PPUSH
77091: LD_VAR 0 7
77095: PUSH
77096: LD_VAR 0 9
77100: PUSH
77101: EMPTY
77102: LIST
77103: LIST
77104: PPUSH
77105: CALL_OW 2
77109: ST_TO_ADDR
// break ;
77110: GO 77114
// end ; end ;
77112: GO 77051
77114: POP
77115: POP
// end ; end ;
77116: GO 76915
77118: POP
77119: POP
// if result and not asc then
77120: LD_VAR 0 6
77124: IFFALSE 77133
77126: PUSH
77127: LD_VAR 0 4
77131: NOT
77132: AND
77133: IFFALSE 77208
// begin tmp := result ;
77135: LD_ADDR_VAR 0 9
77139: PUSH
77140: LD_VAR 0 6
77144: ST_TO_ADDR
// for i = tmp downto 1 do
77145: LD_ADDR_VAR 0 7
77149: PUSH
77150: DOUBLE
77151: LD_VAR 0 9
77155: INC
77156: ST_TO_ADDR
77157: LD_INT 1
77159: PUSH
77160: FOR_DOWNTO
77161: IFFALSE 77206
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
77163: LD_ADDR_VAR 0 6
77167: PUSH
77168: LD_VAR 0 6
77172: PPUSH
77173: LD_VAR 0 9
77177: PUSH
77178: LD_VAR 0 7
77182: MINUS
77183: PUSH
77184: LD_INT 1
77186: PLUS
77187: PPUSH
77188: LD_VAR 0 9
77192: PUSH
77193: LD_VAR 0 7
77197: ARRAY
77198: PPUSH
77199: CALL_OW 1
77203: ST_TO_ADDR
77204: GO 77160
77206: POP
77207: POP
// end ; tmp := [ ] ;
77208: LD_ADDR_VAR 0 9
77212: PUSH
77213: EMPTY
77214: ST_TO_ADDR
// if mode then
77215: LD_VAR 0 5
77219: IFFALSE 77288
// begin for i = 1 to result do
77221: LD_ADDR_VAR 0 7
77225: PUSH
77226: DOUBLE
77227: LD_INT 1
77229: DEC
77230: ST_TO_ADDR
77231: LD_VAR 0 6
77235: PUSH
77236: FOR_TO
77237: IFFALSE 77276
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
77239: LD_ADDR_VAR 0 9
77243: PUSH
77244: LD_VAR 0 9
77248: PPUSH
77249: LD_VAR 0 7
77253: PPUSH
77254: LD_VAR 0 6
77258: PUSH
77259: LD_VAR 0 7
77263: ARRAY
77264: PUSH
77265: LD_INT 1
77267: ARRAY
77268: PPUSH
77269: CALL_OW 1
77273: ST_TO_ADDR
77274: GO 77236
77276: POP
77277: POP
// result := tmp ;
77278: LD_ADDR_VAR 0 6
77282: PUSH
77283: LD_VAR 0 9
77287: ST_TO_ADDR
// end ; end ;
77288: LD_VAR 0 6
77292: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
77293: LD_INT 0
77295: PPUSH
77296: PPUSH
77297: PPUSH
77298: PPUSH
77299: PPUSH
77300: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
77301: LD_ADDR_VAR 0 5
77305: PUSH
77306: LD_INT 0
77308: PUSH
77309: LD_INT 0
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: EMPTY
77316: PUSH
77317: EMPTY
77318: LIST
77319: LIST
77320: LIST
77321: LIST
77322: ST_TO_ADDR
// if not x or not y then
77323: LD_VAR 0 2
77327: NOT
77328: IFTRUE 77337
77330: PUSH
77331: LD_VAR 0 3
77335: NOT
77336: OR
77337: IFFALSE 77341
// exit ;
77339: GO 78997
// if not range then
77341: LD_VAR 0 4
77345: NOT
77346: IFFALSE 77356
// range := 10 ;
77348: LD_ADDR_VAR 0 4
77352: PUSH
77353: LD_INT 10
77355: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
77356: LD_ADDR_VAR 0 8
77360: PUSH
77361: LD_INT 81
77363: PUSH
77364: LD_VAR 0 1
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 92
77375: PUSH
77376: LD_VAR 0 2
77380: PUSH
77381: LD_VAR 0 3
77385: PUSH
77386: LD_VAR 0 4
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 3
77399: PUSH
77400: LD_INT 21
77402: PUSH
77403: LD_INT 3
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: LIST
77418: PPUSH
77419: CALL_OW 69
77423: ST_TO_ADDR
// if not tmp then
77424: LD_VAR 0 8
77428: NOT
77429: IFFALSE 77433
// exit ;
77431: GO 78997
// for i in tmp do
77433: LD_ADDR_VAR 0 6
77437: PUSH
77438: LD_VAR 0 8
77442: PUSH
77443: FOR_IN
77444: IFFALSE 78972
// begin points := [ 0 , 0 , 0 ] ;
77446: LD_ADDR_VAR 0 9
77450: PUSH
77451: LD_INT 0
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: ST_TO_ADDR
// bpoints := 1 ;
77465: LD_ADDR_VAR 0 10
77469: PUSH
77470: LD_INT 1
77472: ST_TO_ADDR
// case GetType ( i ) of unit_human :
77473: LD_VAR 0 6
77477: PPUSH
77478: CALL_OW 247
77482: PUSH
77483: LD_INT 1
77485: DOUBLE
77486: EQUAL
77487: IFTRUE 77491
77489: GO 78073
77491: POP
// begin if GetClass ( i ) = 1 then
77492: LD_VAR 0 6
77496: PPUSH
77497: CALL_OW 257
77501: PUSH
77502: LD_INT 1
77504: EQUAL
77505: IFFALSE 77526
// points := [ 10 , 5 , 3 ] ;
77507: LD_ADDR_VAR 0 9
77511: PUSH
77512: LD_INT 10
77514: PUSH
77515: LD_INT 5
77517: PUSH
77518: LD_INT 3
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: LIST
77525: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
77526: LD_VAR 0 6
77530: PPUSH
77531: CALL_OW 257
77535: PUSH
77536: LD_INT 2
77538: PUSH
77539: LD_INT 3
77541: PUSH
77542: LD_INT 4
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: IN
77550: IFFALSE 77571
// points := [ 3 , 2 , 1 ] ;
77552: LD_ADDR_VAR 0 9
77556: PUSH
77557: LD_INT 3
77559: PUSH
77560: LD_INT 2
77562: PUSH
77563: LD_INT 1
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: LIST
77570: ST_TO_ADDR
// if GetClass ( i ) = 5 then
77571: LD_VAR 0 6
77575: PPUSH
77576: CALL_OW 257
77580: PUSH
77581: LD_INT 5
77583: EQUAL
77584: IFFALSE 77605
// points := [ 130 , 5 , 2 ] ;
77586: LD_ADDR_VAR 0 9
77590: PUSH
77591: LD_INT 130
77593: PUSH
77594: LD_INT 5
77596: PUSH
77597: LD_INT 2
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: ST_TO_ADDR
// if GetClass ( i ) = 8 then
77605: LD_VAR 0 6
77609: PPUSH
77610: CALL_OW 257
77614: PUSH
77615: LD_INT 8
77617: EQUAL
77618: IFFALSE 77639
// points := [ 35 , 35 , 30 ] ;
77620: LD_ADDR_VAR 0 9
77624: PUSH
77625: LD_INT 35
77627: PUSH
77628: LD_INT 35
77630: PUSH
77631: LD_INT 30
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: LIST
77638: ST_TO_ADDR
// if GetClass ( i ) = 9 then
77639: LD_VAR 0 6
77643: PPUSH
77644: CALL_OW 257
77648: PUSH
77649: LD_INT 9
77651: EQUAL
77652: IFFALSE 77673
// points := [ 20 , 55 , 40 ] ;
77654: LD_ADDR_VAR 0 9
77658: PUSH
77659: LD_INT 20
77661: PUSH
77662: LD_INT 55
77664: PUSH
77665: LD_INT 40
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: LIST
77672: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
77673: LD_VAR 0 6
77677: PPUSH
77678: CALL_OW 257
77682: PUSH
77683: LD_INT 12
77685: PUSH
77686: LD_INT 16
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: IN
77693: IFFALSE 77714
// points := [ 5 , 3 , 2 ] ;
77695: LD_ADDR_VAR 0 9
77699: PUSH
77700: LD_INT 5
77702: PUSH
77703: LD_INT 3
77705: PUSH
77706: LD_INT 2
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: LIST
77713: ST_TO_ADDR
// if GetClass ( i ) = 17 then
77714: LD_VAR 0 6
77718: PPUSH
77719: CALL_OW 257
77723: PUSH
77724: LD_INT 17
77726: EQUAL
77727: IFFALSE 77748
// points := [ 100 , 50 , 75 ] ;
77729: LD_ADDR_VAR 0 9
77733: PUSH
77734: LD_INT 100
77736: PUSH
77737: LD_INT 50
77739: PUSH
77740: LD_INT 75
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: LIST
77747: ST_TO_ADDR
// if GetClass ( i ) = 15 then
77748: LD_VAR 0 6
77752: PPUSH
77753: CALL_OW 257
77757: PUSH
77758: LD_INT 15
77760: EQUAL
77761: IFFALSE 77782
// points := [ 10 , 5 , 3 ] ;
77763: LD_ADDR_VAR 0 9
77767: PUSH
77768: LD_INT 10
77770: PUSH
77771: LD_INT 5
77773: PUSH
77774: LD_INT 3
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: LIST
77781: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77782: LD_VAR 0 6
77786: PPUSH
77787: CALL_OW 257
77791: PUSH
77792: LD_INT 14
77794: EQUAL
77795: IFFALSE 77816
// points := [ 10 , 0 , 0 ] ;
77797: LD_ADDR_VAR 0 9
77801: PUSH
77802: LD_INT 10
77804: PUSH
77805: LD_INT 0
77807: PUSH
77808: LD_INT 0
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: LIST
77815: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77816: LD_VAR 0 6
77820: PPUSH
77821: CALL_OW 257
77825: PUSH
77826: LD_INT 11
77828: EQUAL
77829: IFFALSE 77850
// points := [ 30 , 10 , 5 ] ;
77831: LD_ADDR_VAR 0 9
77835: PUSH
77836: LD_INT 30
77838: PUSH
77839: LD_INT 10
77841: PUSH
77842: LD_INT 5
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: LIST
77849: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77850: LD_VAR 0 1
77854: PPUSH
77855: LD_INT 5
77857: PPUSH
77858: CALL_OW 321
77862: PUSH
77863: LD_INT 2
77865: EQUAL
77866: IFFALSE 77883
// bpoints := bpoints * 1.8 ;
77868: LD_ADDR_VAR 0 10
77872: PUSH
77873: LD_VAR 0 10
77877: PUSH
77878: LD_REAL  1.80000000000000E+0000
77881: MUL
77882: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77883: LD_VAR 0 6
77887: PPUSH
77888: CALL_OW 257
77892: PUSH
77893: LD_INT 1
77895: PUSH
77896: LD_INT 2
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 4
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: IN
77911: IFFALSE 77931
77913: PUSH
77914: LD_VAR 0 1
77918: PPUSH
77919: LD_INT 51
77921: PPUSH
77922: CALL_OW 321
77926: PUSH
77927: LD_INT 2
77929: EQUAL
77930: AND
77931: IFFALSE 77948
// bpoints := bpoints * 1.2 ;
77933: LD_ADDR_VAR 0 10
77937: PUSH
77938: LD_VAR 0 10
77942: PUSH
77943: LD_REAL  1.20000000000000E+0000
77946: MUL
77947: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
77948: LD_VAR 0 6
77952: PPUSH
77953: CALL_OW 257
77957: PUSH
77958: LD_INT 5
77960: PUSH
77961: LD_INT 7
77963: PUSH
77964: LD_INT 9
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: LIST
77971: IN
77972: IFFALSE 77992
77974: PUSH
77975: LD_VAR 0 1
77979: PPUSH
77980: LD_INT 52
77982: PPUSH
77983: CALL_OW 321
77987: PUSH
77988: LD_INT 2
77990: EQUAL
77991: AND
77992: IFFALSE 78009
// bpoints := bpoints * 1.5 ;
77994: LD_ADDR_VAR 0 10
77998: PUSH
77999: LD_VAR 0 10
78003: PUSH
78004: LD_REAL  1.50000000000000E+0000
78007: MUL
78008: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
78009: LD_VAR 0 1
78013: PPUSH
78014: LD_INT 66
78016: PPUSH
78017: CALL_OW 321
78021: PUSH
78022: LD_INT 2
78024: EQUAL
78025: IFFALSE 78042
// bpoints := bpoints * 1.1 ;
78027: LD_ADDR_VAR 0 10
78031: PUSH
78032: LD_VAR 0 10
78036: PUSH
78037: LD_REAL  1.10000000000000E+0000
78040: MUL
78041: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
78042: LD_ADDR_VAR 0 10
78046: PUSH
78047: LD_VAR 0 10
78051: PUSH
78052: LD_VAR 0 6
78056: PPUSH
78057: LD_INT 1
78059: PPUSH
78060: CALL_OW 259
78064: PUSH
78065: LD_REAL  1.15000000000000E+0000
78068: MUL
78069: MUL
78070: ST_TO_ADDR
// end ; unit_vehicle :
78071: GO 78901
78073: LD_INT 2
78075: DOUBLE
78076: EQUAL
78077: IFTRUE 78081
78079: GO 78889
78081: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
78082: LD_VAR 0 6
78086: PPUSH
78087: CALL_OW 264
78091: PUSH
78092: LD_INT 2
78094: PUSH
78095: LD_INT 42
78097: PUSH
78098: LD_INT 24
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: LIST
78105: IN
78106: IFFALSE 78127
// points := [ 25 , 5 , 3 ] ;
78108: LD_ADDR_VAR 0 9
78112: PUSH
78113: LD_INT 25
78115: PUSH
78116: LD_INT 5
78118: PUSH
78119: LD_INT 3
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: LIST
78126: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
78127: LD_VAR 0 6
78131: PPUSH
78132: CALL_OW 264
78136: PUSH
78137: LD_INT 4
78139: PUSH
78140: LD_INT 43
78142: PUSH
78143: LD_INT 25
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: LIST
78150: IN
78151: IFFALSE 78172
// points := [ 40 , 15 , 5 ] ;
78153: LD_ADDR_VAR 0 9
78157: PUSH
78158: LD_INT 40
78160: PUSH
78161: LD_INT 15
78163: PUSH
78164: LD_INT 5
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: LIST
78171: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
78172: LD_VAR 0 6
78176: PPUSH
78177: CALL_OW 264
78181: PUSH
78182: LD_INT 3
78184: PUSH
78185: LD_INT 23
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: IN
78192: IFFALSE 78213
// points := [ 7 , 25 , 8 ] ;
78194: LD_ADDR_VAR 0 9
78198: PUSH
78199: LD_INT 7
78201: PUSH
78202: LD_INT 25
78204: PUSH
78205: LD_INT 8
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: LIST
78212: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
78213: LD_VAR 0 6
78217: PPUSH
78218: CALL_OW 264
78222: PUSH
78223: LD_INT 5
78225: PUSH
78226: LD_INT 27
78228: PUSH
78229: LD_INT 44
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: LIST
78236: IN
78237: IFFALSE 78258
// points := [ 14 , 50 , 16 ] ;
78239: LD_ADDR_VAR 0 9
78243: PUSH
78244: LD_INT 14
78246: PUSH
78247: LD_INT 50
78249: PUSH
78250: LD_INT 16
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: LIST
78257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
78258: LD_VAR 0 6
78262: PPUSH
78263: CALL_OW 264
78267: PUSH
78268: LD_INT 6
78270: PUSH
78271: LD_INT 46
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: IN
78278: IFFALSE 78299
// points := [ 32 , 120 , 70 ] ;
78280: LD_ADDR_VAR 0 9
78284: PUSH
78285: LD_INT 32
78287: PUSH
78288: LD_INT 120
78290: PUSH
78291: LD_INT 70
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: LIST
78298: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
78299: LD_VAR 0 6
78303: PPUSH
78304: CALL_OW 264
78308: PUSH
78309: LD_INT 7
78311: PUSH
78312: LD_INT 28
78314: PUSH
78315: LD_INT 45
78317: PUSH
78318: LD_INT 92
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: LIST
78325: LIST
78326: IN
78327: IFFALSE 78348
// points := [ 35 , 20 , 45 ] ;
78329: LD_ADDR_VAR 0 9
78333: PUSH
78334: LD_INT 35
78336: PUSH
78337: LD_INT 20
78339: PUSH
78340: LD_INT 45
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: LIST
78347: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
78348: LD_VAR 0 6
78352: PPUSH
78353: CALL_OW 264
78357: PUSH
78358: LD_INT 47
78360: PUSH
78361: EMPTY
78362: LIST
78363: IN
78364: IFFALSE 78385
// points := [ 67 , 45 , 75 ] ;
78366: LD_ADDR_VAR 0 9
78370: PUSH
78371: LD_INT 67
78373: PUSH
78374: LD_INT 45
78376: PUSH
78377: LD_INT 75
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: LIST
78384: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
78385: LD_VAR 0 6
78389: PPUSH
78390: CALL_OW 264
78394: PUSH
78395: LD_INT 26
78397: PUSH
78398: EMPTY
78399: LIST
78400: IN
78401: IFFALSE 78422
// points := [ 120 , 30 , 80 ] ;
78403: LD_ADDR_VAR 0 9
78407: PUSH
78408: LD_INT 120
78410: PUSH
78411: LD_INT 30
78413: PUSH
78414: LD_INT 80
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: LIST
78421: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
78422: LD_VAR 0 6
78426: PPUSH
78427: CALL_OW 264
78431: PUSH
78432: LD_INT 22
78434: PUSH
78435: EMPTY
78436: LIST
78437: IN
78438: IFFALSE 78459
// points := [ 40 , 1 , 1 ] ;
78440: LD_ADDR_VAR 0 9
78444: PUSH
78445: LD_INT 40
78447: PUSH
78448: LD_INT 1
78450: PUSH
78451: LD_INT 1
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: LIST
78458: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
78459: LD_VAR 0 6
78463: PPUSH
78464: CALL_OW 264
78468: PUSH
78469: LD_INT 29
78471: PUSH
78472: EMPTY
78473: LIST
78474: IN
78475: IFFALSE 78496
// points := [ 70 , 200 , 400 ] ;
78477: LD_ADDR_VAR 0 9
78481: PUSH
78482: LD_INT 70
78484: PUSH
78485: LD_INT 200
78487: PUSH
78488: LD_INT 400
78490: PUSH
78491: EMPTY
78492: LIST
78493: LIST
78494: LIST
78495: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
78496: LD_VAR 0 6
78500: PPUSH
78501: CALL_OW 264
78505: PUSH
78506: LD_INT 14
78508: PUSH
78509: LD_INT 53
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: IN
78516: IFFALSE 78537
// points := [ 40 , 10 , 20 ] ;
78518: LD_ADDR_VAR 0 9
78522: PUSH
78523: LD_INT 40
78525: PUSH
78526: LD_INT 10
78528: PUSH
78529: LD_INT 20
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: LIST
78536: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
78537: LD_VAR 0 6
78541: PPUSH
78542: CALL_OW 264
78546: PUSH
78547: LD_INT 9
78549: PUSH
78550: EMPTY
78551: LIST
78552: IN
78553: IFFALSE 78574
// points := [ 5 , 70 , 20 ] ;
78555: LD_ADDR_VAR 0 9
78559: PUSH
78560: LD_INT 5
78562: PUSH
78563: LD_INT 70
78565: PUSH
78566: LD_INT 20
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: LIST
78573: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
78574: LD_VAR 0 6
78578: PPUSH
78579: CALL_OW 264
78583: PUSH
78584: LD_INT 10
78586: PUSH
78587: EMPTY
78588: LIST
78589: IN
78590: IFFALSE 78611
// points := [ 35 , 110 , 70 ] ;
78592: LD_ADDR_VAR 0 9
78596: PUSH
78597: LD_INT 35
78599: PUSH
78600: LD_INT 110
78602: PUSH
78603: LD_INT 70
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: LIST
78610: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
78611: LD_VAR 0 6
78615: PPUSH
78616: CALL_OW 265
78620: PUSH
78621: LD_INT 25
78623: EQUAL
78624: IFFALSE 78645
// points := [ 80 , 65 , 100 ] ;
78626: LD_ADDR_VAR 0 9
78630: PUSH
78631: LD_INT 80
78633: PUSH
78634: LD_INT 65
78636: PUSH
78637: LD_INT 100
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: LIST
78644: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
78645: LD_VAR 0 6
78649: PPUSH
78650: CALL_OW 263
78654: PUSH
78655: LD_INT 1
78657: EQUAL
78658: IFFALSE 78693
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
78660: LD_ADDR_VAR 0 10
78664: PUSH
78665: LD_VAR 0 10
78669: PUSH
78670: LD_VAR 0 6
78674: PPUSH
78675: CALL_OW 311
78679: PPUSH
78680: LD_INT 3
78682: PPUSH
78683: CALL_OW 259
78687: PUSH
78688: LD_INT 4
78690: MUL
78691: MUL
78692: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
78693: LD_VAR 0 6
78697: PPUSH
78698: CALL_OW 263
78702: PUSH
78703: LD_INT 2
78705: EQUAL
78706: IFFALSE 78757
// begin j := IsControledBy ( i ) ;
78708: LD_ADDR_VAR 0 7
78712: PUSH
78713: LD_VAR 0 6
78717: PPUSH
78718: CALL_OW 312
78722: ST_TO_ADDR
// if j then
78723: LD_VAR 0 7
78727: IFFALSE 78757
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
78729: LD_ADDR_VAR 0 10
78733: PUSH
78734: LD_VAR 0 10
78738: PUSH
78739: LD_VAR 0 7
78743: PPUSH
78744: LD_INT 3
78746: PPUSH
78747: CALL_OW 259
78751: PUSH
78752: LD_INT 3
78754: MUL
78755: MUL
78756: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
78757: LD_VAR 0 6
78761: PPUSH
78762: CALL_OW 264
78766: PUSH
78767: LD_INT 5
78769: PUSH
78770: LD_INT 6
78772: PUSH
78773: LD_INT 46
78775: PUSH
78776: LD_INT 44
78778: PUSH
78779: LD_INT 47
78781: PUSH
78782: LD_INT 45
78784: PUSH
78785: LD_INT 28
78787: PUSH
78788: LD_INT 7
78790: PUSH
78791: LD_INT 27
78793: PUSH
78794: LD_INT 29
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: IN
78809: IFFALSE 78829
78811: PUSH
78812: LD_VAR 0 1
78816: PPUSH
78817: LD_INT 52
78819: PPUSH
78820: CALL_OW 321
78824: PUSH
78825: LD_INT 2
78827: EQUAL
78828: AND
78829: IFFALSE 78846
// bpoints := bpoints * 1.2 ;
78831: LD_ADDR_VAR 0 10
78835: PUSH
78836: LD_VAR 0 10
78840: PUSH
78841: LD_REAL  1.20000000000000E+0000
78844: MUL
78845: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78846: LD_VAR 0 6
78850: PPUSH
78851: CALL_OW 264
78855: PUSH
78856: LD_INT 6
78858: PUSH
78859: LD_INT 46
78861: PUSH
78862: LD_INT 47
78864: PUSH
78865: EMPTY
78866: LIST
78867: LIST
78868: LIST
78869: IN
78870: IFFALSE 78887
// bpoints := bpoints * 1.2 ;
78872: LD_ADDR_VAR 0 10
78876: PUSH
78877: LD_VAR 0 10
78881: PUSH
78882: LD_REAL  1.20000000000000E+0000
78885: MUL
78886: ST_TO_ADDR
// end ; unit_building :
78887: GO 78901
78889: LD_INT 3
78891: DOUBLE
78892: EQUAL
78893: IFTRUE 78897
78895: GO 78900
78897: POP
// ; end ;
78898: GO 78901
78900: POP
// for j = 1 to 3 do
78901: LD_ADDR_VAR 0 7
78905: PUSH
78906: DOUBLE
78907: LD_INT 1
78909: DEC
78910: ST_TO_ADDR
78911: LD_INT 3
78913: PUSH
78914: FOR_TO
78915: IFFALSE 78968
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78917: LD_ADDR_VAR 0 5
78921: PUSH
78922: LD_VAR 0 5
78926: PPUSH
78927: LD_VAR 0 7
78931: PPUSH
78932: LD_VAR 0 5
78936: PUSH
78937: LD_VAR 0 7
78941: ARRAY
78942: PUSH
78943: LD_VAR 0 9
78947: PUSH
78948: LD_VAR 0 7
78952: ARRAY
78953: PUSH
78954: LD_VAR 0 10
78958: MUL
78959: PLUS
78960: PPUSH
78961: CALL_OW 1
78965: ST_TO_ADDR
78966: GO 78914
78968: POP
78969: POP
// end ;
78970: GO 77443
78972: POP
78973: POP
// result := Replace ( result , 4 , tmp ) ;
78974: LD_ADDR_VAR 0 5
78978: PUSH
78979: LD_VAR 0 5
78983: PPUSH
78984: LD_INT 4
78986: PPUSH
78987: LD_VAR 0 8
78991: PPUSH
78992: CALL_OW 1
78996: ST_TO_ADDR
// end ;
78997: LD_VAR 0 5
79001: RET
// export function DangerAtRange ( unit , range ) ; begin
79002: LD_INT 0
79004: PPUSH
// if not unit then
79005: LD_VAR 0 1
79009: NOT
79010: IFFALSE 79014
// exit ;
79012: GO 79059
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
79014: LD_ADDR_VAR 0 3
79018: PUSH
79019: LD_VAR 0 1
79023: PPUSH
79024: CALL_OW 255
79028: PPUSH
79029: LD_VAR 0 1
79033: PPUSH
79034: CALL_OW 250
79038: PPUSH
79039: LD_VAR 0 1
79043: PPUSH
79044: CALL_OW 251
79048: PPUSH
79049: LD_VAR 0 2
79053: PPUSH
79054: CALL 77293 0 4
79058: ST_TO_ADDR
// end ;
79059: LD_VAR 0 3
79063: RET
// export function DangerInArea ( side , area ) ; begin
79064: LD_INT 0
79066: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
79067: LD_ADDR_VAR 0 3
79071: PUSH
79072: LD_VAR 0 2
79076: PPUSH
79077: LD_INT 81
79079: PUSH
79080: LD_VAR 0 1
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PPUSH
79089: CALL_OW 70
79093: ST_TO_ADDR
// end ;
79094: LD_VAR 0 3
79098: RET
// export function IsExtension ( b ) ; begin
79099: LD_INT 0
79101: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
79102: LD_ADDR_VAR 0 2
79106: PUSH
79107: LD_VAR 0 1
79111: PUSH
79112: LD_INT 23
79114: PUSH
79115: LD_INT 20
79117: PUSH
79118: LD_INT 22
79120: PUSH
79121: LD_INT 17
79123: PUSH
79124: LD_INT 24
79126: PUSH
79127: LD_INT 21
79129: PUSH
79130: LD_INT 19
79132: PUSH
79133: LD_INT 16
79135: PUSH
79136: LD_INT 25
79138: PUSH
79139: LD_INT 18
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: IN
79154: ST_TO_ADDR
// end ;
79155: LD_VAR 0 2
79159: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
79160: LD_INT 0
79162: PPUSH
79163: PPUSH
79164: PPUSH
// result := [ ] ;
79165: LD_ADDR_VAR 0 4
79169: PUSH
79170: EMPTY
79171: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
79172: LD_ADDR_VAR 0 5
79176: PUSH
79177: LD_VAR 0 2
79181: PPUSH
79182: LD_INT 21
79184: PUSH
79185: LD_INT 3
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PPUSH
79192: CALL_OW 70
79196: ST_TO_ADDR
// if not tmp then
79197: LD_VAR 0 5
79201: NOT
79202: IFFALSE 79206
// exit ;
79204: GO 79270
// if checkLink then
79206: LD_VAR 0 3
79210: IFFALSE 79260
// begin for i in tmp do
79212: LD_ADDR_VAR 0 6
79216: PUSH
79217: LD_VAR 0 5
79221: PUSH
79222: FOR_IN
79223: IFFALSE 79258
// if GetBase ( i ) <> base then
79225: LD_VAR 0 6
79229: PPUSH
79230: CALL_OW 274
79234: PUSH
79235: LD_VAR 0 1
79239: NONEQUAL
79240: IFFALSE 79256
// ComLinkToBase ( base , i ) ;
79242: LD_VAR 0 1
79246: PPUSH
79247: LD_VAR 0 6
79251: PPUSH
79252: CALL_OW 169
79256: GO 79222
79258: POP
79259: POP
// end ; result := tmp ;
79260: LD_ADDR_VAR 0 4
79264: PUSH
79265: LD_VAR 0 5
79269: ST_TO_ADDR
// end ;
79270: LD_VAR 0 4
79274: RET
// export function ComComplete ( units , b ) ; var i ; begin
79275: LD_INT 0
79277: PPUSH
79278: PPUSH
// if not units then
79279: LD_VAR 0 1
79283: NOT
79284: IFFALSE 79288
// exit ;
79286: GO 79378
// for i in units do
79288: LD_ADDR_VAR 0 4
79292: PUSH
79293: LD_VAR 0 1
79297: PUSH
79298: FOR_IN
79299: IFFALSE 79376
// if BuildingStatus ( b ) = bs_build then
79301: LD_VAR 0 2
79305: PPUSH
79306: CALL_OW 461
79310: PUSH
79311: LD_INT 1
79313: EQUAL
79314: IFFALSE 79374
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
79316: LD_VAR 0 4
79320: PPUSH
79321: LD_STRING h
79323: PUSH
79324: LD_VAR 0 2
79328: PPUSH
79329: CALL_OW 250
79333: PUSH
79334: LD_VAR 0 2
79338: PPUSH
79339: CALL_OW 251
79343: PUSH
79344: LD_VAR 0 2
79348: PUSH
79349: LD_INT 0
79351: PUSH
79352: LD_INT 0
79354: PUSH
79355: LD_INT 0
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: LIST
79362: LIST
79363: LIST
79364: LIST
79365: LIST
79366: PUSH
79367: EMPTY
79368: LIST
79369: PPUSH
79370: CALL_OW 446
79374: GO 79298
79376: POP
79377: POP
// end ;
79378: LD_VAR 0 3
79382: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
79383: LD_INT 0
79385: PPUSH
79386: PPUSH
79387: PPUSH
79388: PPUSH
79389: PPUSH
79390: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
79391: LD_VAR 0 1
79395: NOT
79396: IFTRUE 79413
79398: PUSH
79399: LD_VAR 0 1
79403: PPUSH
79404: CALL_OW 263
79408: PUSH
79409: LD_INT 2
79411: NONEQUAL
79412: OR
79413: IFFALSE 79417
// exit ;
79415: GO 79733
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
79417: LD_ADDR_VAR 0 6
79421: PUSH
79422: LD_INT 22
79424: PUSH
79425: LD_VAR 0 1
79429: PPUSH
79430: CALL_OW 255
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 2
79441: PUSH
79442: LD_INT 30
79444: PUSH
79445: LD_INT 36
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: LD_INT 34
79454: PUSH
79455: LD_INT 31
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: LIST
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PPUSH
79471: CALL_OW 69
79475: ST_TO_ADDR
// if not tmp then
79476: LD_VAR 0 6
79480: NOT
79481: IFFALSE 79485
// exit ;
79483: GO 79733
// result := [ ] ;
79485: LD_ADDR_VAR 0 2
79489: PUSH
79490: EMPTY
79491: ST_TO_ADDR
// for i in tmp do
79492: LD_ADDR_VAR 0 3
79496: PUSH
79497: LD_VAR 0 6
79501: PUSH
79502: FOR_IN
79503: IFFALSE 79574
// begin t := UnitsInside ( i ) ;
79505: LD_ADDR_VAR 0 4
79509: PUSH
79510: LD_VAR 0 3
79514: PPUSH
79515: CALL_OW 313
79519: ST_TO_ADDR
// if t then
79520: LD_VAR 0 4
79524: IFFALSE 79572
// for j in t do
79526: LD_ADDR_VAR 0 7
79530: PUSH
79531: LD_VAR 0 4
79535: PUSH
79536: FOR_IN
79537: IFFALSE 79570
// result := Replace ( result , result + 1 , j ) ;
79539: LD_ADDR_VAR 0 2
79543: PUSH
79544: LD_VAR 0 2
79548: PPUSH
79549: LD_VAR 0 2
79553: PUSH
79554: LD_INT 1
79556: PLUS
79557: PPUSH
79558: LD_VAR 0 7
79562: PPUSH
79563: CALL_OW 1
79567: ST_TO_ADDR
79568: GO 79536
79570: POP
79571: POP
// end ;
79572: GO 79502
79574: POP
79575: POP
// if not result then
79576: LD_VAR 0 2
79580: NOT
79581: IFFALSE 79585
// exit ;
79583: GO 79733
// mech := result [ 1 ] ;
79585: LD_ADDR_VAR 0 5
79589: PUSH
79590: LD_VAR 0 2
79594: PUSH
79595: LD_INT 1
79597: ARRAY
79598: ST_TO_ADDR
// if result > 1 then
79599: LD_VAR 0 2
79603: PUSH
79604: LD_INT 1
79606: GREATER
79607: IFFALSE 79719
// begin for i = 2 to result do
79609: LD_ADDR_VAR 0 3
79613: PUSH
79614: DOUBLE
79615: LD_INT 2
79617: DEC
79618: ST_TO_ADDR
79619: LD_VAR 0 2
79623: PUSH
79624: FOR_TO
79625: IFFALSE 79717
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
79627: LD_ADDR_VAR 0 4
79631: PUSH
79632: LD_VAR 0 2
79636: PUSH
79637: LD_VAR 0 3
79641: ARRAY
79642: PPUSH
79643: LD_INT 3
79645: PPUSH
79646: CALL_OW 259
79650: PUSH
79651: LD_VAR 0 2
79655: PUSH
79656: LD_VAR 0 3
79660: ARRAY
79661: PPUSH
79662: CALL_OW 432
79666: MINUS
79667: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
79668: LD_VAR 0 4
79672: PUSH
79673: LD_VAR 0 5
79677: PPUSH
79678: LD_INT 3
79680: PPUSH
79681: CALL_OW 259
79685: PUSH
79686: LD_VAR 0 5
79690: PPUSH
79691: CALL_OW 432
79695: MINUS
79696: GREATEREQUAL
79697: IFFALSE 79715
// mech := result [ i ] ;
79699: LD_ADDR_VAR 0 5
79703: PUSH
79704: LD_VAR 0 2
79708: PUSH
79709: LD_VAR 0 3
79713: ARRAY
79714: ST_TO_ADDR
// end ;
79715: GO 79624
79717: POP
79718: POP
// end ; ComLinkTo ( vehicle , mech ) ;
79719: LD_VAR 0 1
79723: PPUSH
79724: LD_VAR 0 5
79728: PPUSH
79729: CALL_OW 135
// end ;
79733: LD_VAR 0 2
79737: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
79738: LD_INT 0
79740: PPUSH
79741: PPUSH
79742: PPUSH
79743: PPUSH
79744: PPUSH
79745: PPUSH
79746: PPUSH
79747: PPUSH
79748: PPUSH
79749: PPUSH
79750: PPUSH
79751: PPUSH
79752: PPUSH
// result := [ ] ;
79753: LD_ADDR_VAR 0 7
79757: PUSH
79758: EMPTY
79759: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
79760: LD_VAR 0 1
79764: PPUSH
79765: CALL_OW 266
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: LD_INT 1
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: IN
79780: NOT
79781: IFFALSE 79785
// exit ;
79783: GO 81425
// if name then
79785: LD_VAR 0 3
79789: IFFALSE 79805
// SetBName ( base_dep , name ) ;
79791: LD_VAR 0 1
79795: PPUSH
79796: LD_VAR 0 3
79800: PPUSH
79801: CALL_OW 500
// base := GetBase ( base_dep ) ;
79805: LD_ADDR_VAR 0 15
79809: PUSH
79810: LD_VAR 0 1
79814: PPUSH
79815: CALL_OW 274
79819: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79820: LD_ADDR_VAR 0 16
79824: PUSH
79825: LD_VAR 0 1
79829: PPUSH
79830: CALL_OW 255
79834: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79835: LD_ADDR_VAR 0 17
79839: PUSH
79840: LD_VAR 0 1
79844: PPUSH
79845: CALL_OW 248
79849: ST_TO_ADDR
// if sources then
79850: LD_VAR 0 5
79854: IFFALSE 79901
// for i = 1 to 3 do
79856: LD_ADDR_VAR 0 8
79860: PUSH
79861: DOUBLE
79862: LD_INT 1
79864: DEC
79865: ST_TO_ADDR
79866: LD_INT 3
79868: PUSH
79869: FOR_TO
79870: IFFALSE 79899
// AddResourceType ( base , i , sources [ i ] ) ;
79872: LD_VAR 0 15
79876: PPUSH
79877: LD_VAR 0 8
79881: PPUSH
79882: LD_VAR 0 5
79886: PUSH
79887: LD_VAR 0 8
79891: ARRAY
79892: PPUSH
79893: CALL_OW 276
79897: GO 79869
79899: POP
79900: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79901: LD_ADDR_VAR 0 18
79905: PUSH
79906: LD_VAR 0 15
79910: PPUSH
79911: LD_VAR 0 2
79915: PPUSH
79916: LD_INT 1
79918: PPUSH
79919: CALL 79160 0 3
79923: ST_TO_ADDR
// InitHc ;
79924: CALL_OW 19
// InitUc ;
79928: CALL_OW 18
// uc_side := side ;
79932: LD_ADDR_OWVAR 20
79936: PUSH
79937: LD_VAR 0 16
79941: ST_TO_ADDR
// uc_nation := nation ;
79942: LD_ADDR_OWVAR 21
79946: PUSH
79947: LD_VAR 0 17
79951: ST_TO_ADDR
// if buildings then
79952: LD_VAR 0 18
79956: IFFALSE 81284
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
79958: LD_ADDR_VAR 0 19
79962: PUSH
79963: LD_VAR 0 18
79967: PPUSH
79968: LD_INT 2
79970: PUSH
79971: LD_INT 30
79973: PUSH
79974: LD_INT 29
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 30
79983: PUSH
79984: LD_INT 30
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: LIST
79995: PPUSH
79996: CALL_OW 72
80000: ST_TO_ADDR
// if tmp then
80001: LD_VAR 0 19
80005: IFFALSE 80053
// for i in tmp do
80007: LD_ADDR_VAR 0 8
80011: PUSH
80012: LD_VAR 0 19
80016: PUSH
80017: FOR_IN
80018: IFFALSE 80051
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
80020: LD_VAR 0 8
80024: PPUSH
80025: CALL_OW 250
80029: PPUSH
80030: LD_VAR 0 8
80034: PPUSH
80035: CALL_OW 251
80039: PPUSH
80040: LD_VAR 0 16
80044: PPUSH
80045: CALL_OW 441
80049: GO 80017
80051: POP
80052: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
80053: LD_VAR 0 18
80057: PPUSH
80058: LD_INT 2
80060: PUSH
80061: LD_INT 30
80063: PUSH
80064: LD_INT 32
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 30
80073: PUSH
80074: LD_INT 33
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: LIST
80085: PPUSH
80086: CALL_OW 72
80090: IFFALSE 80178
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
80092: LD_ADDR_VAR 0 8
80096: PUSH
80097: LD_VAR 0 18
80101: PPUSH
80102: LD_INT 2
80104: PUSH
80105: LD_INT 30
80107: PUSH
80108: LD_INT 32
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 30
80117: PUSH
80118: LD_INT 33
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: LIST
80129: PPUSH
80130: CALL_OW 72
80134: PUSH
80135: FOR_IN
80136: IFFALSE 80176
// begin if not GetBWeapon ( i ) then
80138: LD_VAR 0 8
80142: PPUSH
80143: CALL_OW 269
80147: NOT
80148: IFFALSE 80174
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
80150: LD_VAR 0 8
80154: PPUSH
80155: LD_VAR 0 8
80159: PPUSH
80160: LD_VAR 0 2
80164: PPUSH
80165: CALL 81430 0 2
80169: PPUSH
80170: CALL_OW 431
// end ;
80174: GO 80135
80176: POP
80177: POP
// end ; for i = 1 to personel do
80178: LD_ADDR_VAR 0 8
80182: PUSH
80183: DOUBLE
80184: LD_INT 1
80186: DEC
80187: ST_TO_ADDR
80188: LD_VAR 0 6
80192: PUSH
80193: FOR_TO
80194: IFFALSE 81264
// begin if i > 4 then
80196: LD_VAR 0 8
80200: PUSH
80201: LD_INT 4
80203: GREATER
80204: IFFALSE 80208
// break ;
80206: GO 81264
// case i of 1 :
80208: LD_VAR 0 8
80212: PUSH
80213: LD_INT 1
80215: DOUBLE
80216: EQUAL
80217: IFTRUE 80221
80219: GO 80301
80221: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
80222: LD_ADDR_VAR 0 12
80226: PUSH
80227: LD_VAR 0 18
80231: PPUSH
80232: LD_INT 22
80234: PUSH
80235: LD_VAR 0 16
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 58
80246: PUSH
80247: EMPTY
80248: LIST
80249: PUSH
80250: LD_INT 2
80252: PUSH
80253: LD_INT 30
80255: PUSH
80256: LD_INT 32
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 30
80265: PUSH
80266: LD_INT 4
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 30
80275: PUSH
80276: LD_INT 5
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: LIST
80293: PPUSH
80294: CALL_OW 72
80298: ST_TO_ADDR
80299: GO 80523
80301: LD_INT 2
80303: DOUBLE
80304: EQUAL
80305: IFTRUE 80309
80307: GO 80371
80309: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
80310: LD_ADDR_VAR 0 12
80314: PUSH
80315: LD_VAR 0 18
80319: PPUSH
80320: LD_INT 22
80322: PUSH
80323: LD_VAR 0 16
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: PUSH
80332: LD_INT 2
80334: PUSH
80335: LD_INT 30
80337: PUSH
80338: LD_INT 0
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 30
80347: PUSH
80348: LD_INT 1
80350: PUSH
80351: EMPTY
80352: LIST
80353: LIST
80354: PUSH
80355: EMPTY
80356: LIST
80357: LIST
80358: LIST
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PPUSH
80364: CALL_OW 72
80368: ST_TO_ADDR
80369: GO 80523
80371: LD_INT 3
80373: DOUBLE
80374: EQUAL
80375: IFTRUE 80379
80377: GO 80441
80379: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
80380: LD_ADDR_VAR 0 12
80384: PUSH
80385: LD_VAR 0 18
80389: PPUSH
80390: LD_INT 22
80392: PUSH
80393: LD_VAR 0 16
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: PUSH
80402: LD_INT 2
80404: PUSH
80405: LD_INT 30
80407: PUSH
80408: LD_INT 2
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 30
80417: PUSH
80418: LD_INT 3
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: LIST
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PPUSH
80434: CALL_OW 72
80438: ST_TO_ADDR
80439: GO 80523
80441: LD_INT 4
80443: DOUBLE
80444: EQUAL
80445: IFTRUE 80449
80447: GO 80522
80449: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
80450: LD_ADDR_VAR 0 12
80454: PUSH
80455: LD_VAR 0 18
80459: PPUSH
80460: LD_INT 22
80462: PUSH
80463: LD_VAR 0 16
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 2
80474: PUSH
80475: LD_INT 30
80477: PUSH
80478: LD_INT 6
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 30
80487: PUSH
80488: LD_INT 7
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 30
80497: PUSH
80498: LD_INT 8
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: LIST
80509: LIST
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PPUSH
80515: CALL_OW 72
80519: ST_TO_ADDR
80520: GO 80523
80522: POP
// if i = 1 then
80523: LD_VAR 0 8
80527: PUSH
80528: LD_INT 1
80530: EQUAL
80531: IFFALSE 80642
// begin tmp := [ ] ;
80533: LD_ADDR_VAR 0 19
80537: PUSH
80538: EMPTY
80539: ST_TO_ADDR
// for j in f do
80540: LD_ADDR_VAR 0 9
80544: PUSH
80545: LD_VAR 0 12
80549: PUSH
80550: FOR_IN
80551: IFFALSE 80624
// if GetBType ( j ) = b_bunker then
80553: LD_VAR 0 9
80557: PPUSH
80558: CALL_OW 266
80562: PUSH
80563: LD_INT 32
80565: EQUAL
80566: IFFALSE 80593
// tmp := Insert ( tmp , 1 , j ) else
80568: LD_ADDR_VAR 0 19
80572: PUSH
80573: LD_VAR 0 19
80577: PPUSH
80578: LD_INT 1
80580: PPUSH
80581: LD_VAR 0 9
80585: PPUSH
80586: CALL_OW 2
80590: ST_TO_ADDR
80591: GO 80622
// tmp := Insert ( tmp , tmp + 1 , j ) ;
80593: LD_ADDR_VAR 0 19
80597: PUSH
80598: LD_VAR 0 19
80602: PPUSH
80603: LD_VAR 0 19
80607: PUSH
80608: LD_INT 1
80610: PLUS
80611: PPUSH
80612: LD_VAR 0 9
80616: PPUSH
80617: CALL_OW 2
80621: ST_TO_ADDR
80622: GO 80550
80624: POP
80625: POP
// if tmp then
80626: LD_VAR 0 19
80630: IFFALSE 80642
// f := tmp ;
80632: LD_ADDR_VAR 0 12
80636: PUSH
80637: LD_VAR 0 19
80641: ST_TO_ADDR
// end ; x := personel [ i ] ;
80642: LD_ADDR_VAR 0 13
80646: PUSH
80647: LD_VAR 0 6
80651: PUSH
80652: LD_VAR 0 8
80656: ARRAY
80657: ST_TO_ADDR
// if x = - 1 then
80658: LD_VAR 0 13
80662: PUSH
80663: LD_INT 1
80665: NEG
80666: EQUAL
80667: IFFALSE 80878
// begin for j in f do
80669: LD_ADDR_VAR 0 9
80673: PUSH
80674: LD_VAR 0 12
80678: PUSH
80679: FOR_IN
80680: IFFALSE 80874
// repeat InitHc ;
80682: CALL_OW 19
// if GetBType ( j ) = b_barracks then
80686: LD_VAR 0 9
80690: PPUSH
80691: CALL_OW 266
80695: PUSH
80696: LD_INT 5
80698: EQUAL
80699: IFFALSE 80769
// begin if UnitsInside ( j ) < 3 then
80701: LD_VAR 0 9
80705: PPUSH
80706: CALL_OW 313
80710: PUSH
80711: LD_INT 3
80713: LESS
80714: IFFALSE 80750
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80716: LD_INT 0
80718: PPUSH
80719: LD_INT 5
80721: PUSH
80722: LD_INT 8
80724: PUSH
80725: LD_INT 9
80727: PUSH
80728: EMPTY
80729: LIST
80730: LIST
80731: LIST
80732: PUSH
80733: LD_VAR 0 17
80737: ARRAY
80738: PPUSH
80739: LD_VAR 0 4
80743: PPUSH
80744: CALL_OW 380
80748: GO 80767
// PrepareHuman ( false , i , skill ) ;
80750: LD_INT 0
80752: PPUSH
80753: LD_VAR 0 8
80757: PPUSH
80758: LD_VAR 0 4
80762: PPUSH
80763: CALL_OW 380
// end else
80767: GO 80786
// PrepareHuman ( false , i , skill ) ;
80769: LD_INT 0
80771: PPUSH
80772: LD_VAR 0 8
80776: PPUSH
80777: LD_VAR 0 4
80781: PPUSH
80782: CALL_OW 380
// un := CreateHuman ;
80786: LD_ADDR_VAR 0 14
80790: PUSH
80791: CALL_OW 44
80795: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80796: LD_ADDR_VAR 0 7
80800: PUSH
80801: LD_VAR 0 7
80805: PPUSH
80806: LD_INT 1
80808: PPUSH
80809: LD_VAR 0 14
80813: PPUSH
80814: CALL_OW 2
80818: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80819: LD_VAR 0 14
80823: PPUSH
80824: LD_VAR 0 9
80828: PPUSH
80829: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80833: LD_VAR 0 9
80837: PPUSH
80838: CALL_OW 313
80842: PUSH
80843: LD_INT 6
80845: EQUAL
80846: IFTRUE 80870
80848: PUSH
80849: LD_VAR 0 9
80853: PPUSH
80854: CALL_OW 266
80858: PUSH
80859: LD_INT 32
80861: PUSH
80862: LD_INT 31
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: IN
80869: OR
80870: IFFALSE 80682
80872: GO 80679
80874: POP
80875: POP
// end else
80876: GO 81262
// for j = 1 to x do
80878: LD_ADDR_VAR 0 9
80882: PUSH
80883: DOUBLE
80884: LD_INT 1
80886: DEC
80887: ST_TO_ADDR
80888: LD_VAR 0 13
80892: PUSH
80893: FOR_TO
80894: IFFALSE 81260
// begin InitHc ;
80896: CALL_OW 19
// if not f then
80900: LD_VAR 0 12
80904: NOT
80905: IFFALSE 80994
// begin PrepareHuman ( false , i , skill ) ;
80907: LD_INT 0
80909: PPUSH
80910: LD_VAR 0 8
80914: PPUSH
80915: LD_VAR 0 4
80919: PPUSH
80920: CALL_OW 380
// un := CreateHuman ;
80924: LD_ADDR_VAR 0 14
80928: PUSH
80929: CALL_OW 44
80933: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80934: LD_ADDR_VAR 0 7
80938: PUSH
80939: LD_VAR 0 7
80943: PPUSH
80944: LD_INT 1
80946: PPUSH
80947: LD_VAR 0 14
80951: PPUSH
80952: CALL_OW 2
80956: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
80957: LD_VAR 0 14
80961: PPUSH
80962: LD_VAR 0 1
80966: PPUSH
80967: CALL_OW 250
80971: PPUSH
80972: LD_VAR 0 1
80976: PPUSH
80977: CALL_OW 251
80981: PPUSH
80982: LD_INT 10
80984: PPUSH
80985: LD_INT 0
80987: PPUSH
80988: CALL_OW 50
// continue ;
80992: GO 80893
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
80994: LD_VAR 0 12
80998: PUSH
80999: LD_INT 1
81001: ARRAY
81002: PPUSH
81003: CALL_OW 313
81007: IFFALSE 81035
81009: PUSH
81010: LD_VAR 0 12
81014: PUSH
81015: LD_INT 1
81017: ARRAY
81018: PPUSH
81019: CALL_OW 266
81023: PUSH
81024: LD_INT 32
81026: PUSH
81027: LD_INT 31
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: IN
81034: AND
81035: IFTRUE 81056
81037: PUSH
81038: LD_VAR 0 12
81042: PUSH
81043: LD_INT 1
81045: ARRAY
81046: PPUSH
81047: CALL_OW 313
81051: PUSH
81052: LD_INT 6
81054: EQUAL
81055: OR
81056: IFFALSE 81076
// f := Delete ( f , 1 ) ;
81058: LD_ADDR_VAR 0 12
81062: PUSH
81063: LD_VAR 0 12
81067: PPUSH
81068: LD_INT 1
81070: PPUSH
81071: CALL_OW 3
81075: ST_TO_ADDR
// if not f then
81076: LD_VAR 0 12
81080: NOT
81081: IFFALSE 81099
// begin x := x + 2 ;
81083: LD_ADDR_VAR 0 13
81087: PUSH
81088: LD_VAR 0 13
81092: PUSH
81093: LD_INT 2
81095: PLUS
81096: ST_TO_ADDR
// continue ;
81097: GO 80893
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
81099: LD_VAR 0 12
81103: PUSH
81104: LD_INT 1
81106: ARRAY
81107: PPUSH
81108: CALL_OW 266
81112: PUSH
81113: LD_INT 5
81115: EQUAL
81116: IFFALSE 81190
// begin if UnitsInside ( f [ 1 ] ) < 3 then
81118: LD_VAR 0 12
81122: PUSH
81123: LD_INT 1
81125: ARRAY
81126: PPUSH
81127: CALL_OW 313
81131: PUSH
81132: LD_INT 3
81134: LESS
81135: IFFALSE 81171
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
81137: LD_INT 0
81139: PPUSH
81140: LD_INT 5
81142: PUSH
81143: LD_INT 8
81145: PUSH
81146: LD_INT 9
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: LIST
81153: PUSH
81154: LD_VAR 0 17
81158: ARRAY
81159: PPUSH
81160: LD_VAR 0 4
81164: PPUSH
81165: CALL_OW 380
81169: GO 81188
// PrepareHuman ( false , i , skill ) ;
81171: LD_INT 0
81173: PPUSH
81174: LD_VAR 0 8
81178: PPUSH
81179: LD_VAR 0 4
81183: PPUSH
81184: CALL_OW 380
// end else
81188: GO 81207
// PrepareHuman ( false , i , skill ) ;
81190: LD_INT 0
81192: PPUSH
81193: LD_VAR 0 8
81197: PPUSH
81198: LD_VAR 0 4
81202: PPUSH
81203: CALL_OW 380
// un := CreateHuman ;
81207: LD_ADDR_VAR 0 14
81211: PUSH
81212: CALL_OW 44
81216: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
81217: LD_ADDR_VAR 0 7
81221: PUSH
81222: LD_VAR 0 7
81226: PPUSH
81227: LD_INT 1
81229: PPUSH
81230: LD_VAR 0 14
81234: PPUSH
81235: CALL_OW 2
81239: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
81240: LD_VAR 0 14
81244: PPUSH
81245: LD_VAR 0 12
81249: PUSH
81250: LD_INT 1
81252: ARRAY
81253: PPUSH
81254: CALL_OW 52
// end ;
81258: GO 80893
81260: POP
81261: POP
// end ;
81262: GO 80193
81264: POP
81265: POP
// result := result ^ buildings ;
81266: LD_ADDR_VAR 0 7
81270: PUSH
81271: LD_VAR 0 7
81275: PUSH
81276: LD_VAR 0 18
81280: ADD
81281: ST_TO_ADDR
// end else
81282: GO 81425
// begin for i = 1 to personel do
81284: LD_ADDR_VAR 0 8
81288: PUSH
81289: DOUBLE
81290: LD_INT 1
81292: DEC
81293: ST_TO_ADDR
81294: LD_VAR 0 6
81298: PUSH
81299: FOR_TO
81300: IFFALSE 81423
// begin if i > 4 then
81302: LD_VAR 0 8
81306: PUSH
81307: LD_INT 4
81309: GREATER
81310: IFFALSE 81314
// break ;
81312: GO 81423
// x := personel [ i ] ;
81314: LD_ADDR_VAR 0 13
81318: PUSH
81319: LD_VAR 0 6
81323: PUSH
81324: LD_VAR 0 8
81328: ARRAY
81329: ST_TO_ADDR
// if x = - 1 then
81330: LD_VAR 0 13
81334: PUSH
81335: LD_INT 1
81337: NEG
81338: EQUAL
81339: IFFALSE 81343
// continue ;
81341: GO 81299
// PrepareHuman ( false , i , skill ) ;
81343: LD_INT 0
81345: PPUSH
81346: LD_VAR 0 8
81350: PPUSH
81351: LD_VAR 0 4
81355: PPUSH
81356: CALL_OW 380
// un := CreateHuman ;
81360: LD_ADDR_VAR 0 14
81364: PUSH
81365: CALL_OW 44
81369: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
81370: LD_VAR 0 14
81374: PPUSH
81375: LD_VAR 0 1
81379: PPUSH
81380: CALL_OW 250
81384: PPUSH
81385: LD_VAR 0 1
81389: PPUSH
81390: CALL_OW 251
81394: PPUSH
81395: LD_INT 10
81397: PPUSH
81398: LD_INT 0
81400: PPUSH
81401: CALL_OW 50
// result := result ^ un ;
81405: LD_ADDR_VAR 0 7
81409: PUSH
81410: LD_VAR 0 7
81414: PUSH
81415: LD_VAR 0 14
81419: ADD
81420: ST_TO_ADDR
// end ;
81421: GO 81299
81423: POP
81424: POP
// end ; end ;
81425: LD_VAR 0 7
81429: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
81430: LD_INT 0
81432: PPUSH
81433: PPUSH
81434: PPUSH
81435: PPUSH
81436: PPUSH
81437: PPUSH
81438: PPUSH
81439: PPUSH
81440: PPUSH
81441: PPUSH
81442: PPUSH
81443: PPUSH
81444: PPUSH
81445: PPUSH
81446: PPUSH
81447: PPUSH
// result := false ;
81448: LD_ADDR_VAR 0 3
81452: PUSH
81453: LD_INT 0
81455: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
81456: LD_VAR 0 1
81460: NOT
81461: IFTRUE 81486
81463: PUSH
81464: LD_VAR 0 1
81468: PPUSH
81469: CALL_OW 266
81473: PUSH
81474: LD_INT 32
81476: PUSH
81477: LD_INT 33
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: IN
81484: NOT
81485: OR
81486: IFFALSE 81490
// exit ;
81488: GO 82625
// nat := GetNation ( tower ) ;
81490: LD_ADDR_VAR 0 12
81494: PUSH
81495: LD_VAR 0 1
81499: PPUSH
81500: CALL_OW 248
81504: ST_TO_ADDR
// side := GetSide ( tower ) ;
81505: LD_ADDR_VAR 0 16
81509: PUSH
81510: LD_VAR 0 1
81514: PPUSH
81515: CALL_OW 255
81519: ST_TO_ADDR
// x := GetX ( tower ) ;
81520: LD_ADDR_VAR 0 10
81524: PUSH
81525: LD_VAR 0 1
81529: PPUSH
81530: CALL_OW 250
81534: ST_TO_ADDR
// y := GetY ( tower ) ;
81535: LD_ADDR_VAR 0 11
81539: PUSH
81540: LD_VAR 0 1
81544: PPUSH
81545: CALL_OW 251
81549: ST_TO_ADDR
// if not x or not y then
81550: LD_VAR 0 10
81554: NOT
81555: IFTRUE 81564
81557: PUSH
81558: LD_VAR 0 11
81562: NOT
81563: OR
81564: IFFALSE 81568
// exit ;
81566: GO 82625
// weapon := 0 ;
81568: LD_ADDR_VAR 0 18
81572: PUSH
81573: LD_INT 0
81575: ST_TO_ADDR
// fac_list := [ ] ;
81576: LD_ADDR_VAR 0 17
81580: PUSH
81581: EMPTY
81582: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
81583: LD_ADDR_VAR 0 6
81587: PUSH
81588: LD_VAR 0 1
81592: PPUSH
81593: CALL_OW 274
81597: PPUSH
81598: LD_VAR 0 2
81602: PPUSH
81603: LD_INT 0
81605: PPUSH
81606: CALL 79160 0 3
81610: PPUSH
81611: LD_INT 30
81613: PUSH
81614: LD_INT 3
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PPUSH
81621: CALL_OW 72
81625: ST_TO_ADDR
// if not factories then
81626: LD_VAR 0 6
81630: NOT
81631: IFFALSE 81635
// exit ;
81633: GO 82625
// for i in factories do
81635: LD_ADDR_VAR 0 8
81639: PUSH
81640: LD_VAR 0 6
81644: PUSH
81645: FOR_IN
81646: IFFALSE 81671
// fac_list := fac_list union AvailableWeaponList ( i ) ;
81648: LD_ADDR_VAR 0 17
81652: PUSH
81653: LD_VAR 0 17
81657: PUSH
81658: LD_VAR 0 8
81662: PPUSH
81663: CALL_OW 478
81667: UNION
81668: ST_TO_ADDR
81669: GO 81645
81671: POP
81672: POP
// if not fac_list then
81673: LD_VAR 0 17
81677: NOT
81678: IFFALSE 81682
// exit ;
81680: GO 82625
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
81682: LD_ADDR_VAR 0 5
81686: PUSH
81687: LD_INT 4
81689: PUSH
81690: LD_INT 5
81692: PUSH
81693: LD_INT 9
81695: PUSH
81696: LD_INT 10
81698: PUSH
81699: LD_INT 6
81701: PUSH
81702: LD_INT 7
81704: PUSH
81705: LD_INT 11
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 27
81719: PUSH
81720: LD_INT 28
81722: PUSH
81723: LD_INT 26
81725: PUSH
81726: LD_INT 30
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 43
81737: PUSH
81738: LD_INT 44
81740: PUSH
81741: LD_INT 46
81743: PUSH
81744: LD_INT 45
81746: PUSH
81747: LD_INT 47
81749: PUSH
81750: LD_INT 49
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: LIST
81765: PUSH
81766: LD_VAR 0 12
81770: ARRAY
81771: ST_TO_ADDR
// list := list isect fac_list ;
81772: LD_ADDR_VAR 0 5
81776: PUSH
81777: LD_VAR 0 5
81781: PUSH
81782: LD_VAR 0 17
81786: ISECT
81787: ST_TO_ADDR
// if not list then
81788: LD_VAR 0 5
81792: NOT
81793: IFFALSE 81797
// exit ;
81795: GO 82625
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81797: LD_VAR 0 12
81801: PUSH
81802: LD_INT 3
81804: EQUAL
81805: IFFALSE 81817
81807: PUSH
81808: LD_INT 49
81810: PUSH
81811: LD_VAR 0 5
81815: IN
81816: AND
81817: IFFALSE 81837
81819: PUSH
81820: LD_INT 31
81822: PPUSH
81823: LD_VAR 0 16
81827: PPUSH
81828: CALL_OW 321
81832: PUSH
81833: LD_INT 2
81835: EQUAL
81836: AND
81837: IFFALSE 81897
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81839: LD_INT 22
81841: PUSH
81842: LD_VAR 0 16
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 35
81853: PUSH
81854: LD_INT 49
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 91
81863: PUSH
81864: LD_VAR 0 1
81868: PUSH
81869: LD_INT 10
81871: PUSH
81872: EMPTY
81873: LIST
81874: LIST
81875: LIST
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: LIST
81881: PPUSH
81882: CALL_OW 69
81886: NOT
81887: IFFALSE 81897
// weapon := ru_time_lapser ;
81889: LD_ADDR_VAR 0 18
81893: PUSH
81894: LD_INT 49
81896: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81897: LD_VAR 0 12
81901: PUSH
81902: LD_INT 1
81904: PUSH
81905: LD_INT 2
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: IN
81912: IFFALSE 81936
81914: PUSH
81915: LD_INT 11
81917: PUSH
81918: LD_VAR 0 5
81922: IN
81923: IFTRUE 81935
81925: PUSH
81926: LD_INT 30
81928: PUSH
81929: LD_VAR 0 5
81933: IN
81934: OR
81935: AND
81936: IFFALSE 81956
81938: PUSH
81939: LD_INT 6
81941: PPUSH
81942: LD_VAR 0 16
81946: PPUSH
81947: CALL_OW 321
81951: PUSH
81952: LD_INT 2
81954: EQUAL
81955: AND
81956: IFFALSE 82123
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
81958: LD_INT 22
81960: PUSH
81961: LD_VAR 0 16
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 2
81972: PUSH
81973: LD_INT 35
81975: PUSH
81976: LD_INT 11
81978: PUSH
81979: EMPTY
81980: LIST
81981: LIST
81982: PUSH
81983: LD_INT 35
81985: PUSH
81986: LD_INT 30
81988: PUSH
81989: EMPTY
81990: LIST
81991: LIST
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 91
82000: PUSH
82001: LD_VAR 0 1
82005: PUSH
82006: LD_INT 18
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: LIST
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: LIST
82018: PPUSH
82019: CALL_OW 69
82023: NOT
82024: IFFALSE 82100
82026: PUSH
82027: LD_INT 22
82029: PUSH
82030: LD_VAR 0 16
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 2
82041: PUSH
82042: LD_INT 30
82044: PUSH
82045: LD_INT 32
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 30
82054: PUSH
82055: LD_INT 33
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: EMPTY
82063: LIST
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 91
82069: PUSH
82070: LD_VAR 0 1
82074: PUSH
82075: LD_INT 12
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: LIST
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: LIST
82087: PUSH
82088: EMPTY
82089: LIST
82090: PPUSH
82091: CALL_OW 69
82095: PUSH
82096: LD_INT 2
82098: GREATER
82099: AND
82100: IFFALSE 82123
// weapon := [ us_radar , ar_radar ] [ nat ] ;
82102: LD_ADDR_VAR 0 18
82106: PUSH
82107: LD_INT 11
82109: PUSH
82110: LD_INT 30
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_VAR 0 12
82121: ARRAY
82122: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
82123: LD_VAR 0 18
82127: NOT
82128: IFFALSE 82148
82130: PUSH
82131: LD_INT 40
82133: PPUSH
82134: LD_VAR 0 16
82138: PPUSH
82139: CALL_OW 321
82143: PUSH
82144: LD_INT 2
82146: EQUAL
82147: AND
82148: IFFALSE 82184
82150: PUSH
82151: LD_INT 7
82153: PUSH
82154: LD_VAR 0 5
82158: IN
82159: IFTRUE 82171
82161: PUSH
82162: LD_INT 28
82164: PUSH
82165: LD_VAR 0 5
82169: IN
82170: OR
82171: IFTRUE 82183
82173: PUSH
82174: LD_INT 45
82176: PUSH
82177: LD_VAR 0 5
82181: IN
82182: OR
82183: AND
82184: IFFALSE 82438
// begin hex := GetHexInfo ( x , y ) ;
82186: LD_ADDR_VAR 0 4
82190: PUSH
82191: LD_VAR 0 10
82195: PPUSH
82196: LD_VAR 0 11
82200: PPUSH
82201: CALL_OW 546
82205: ST_TO_ADDR
// if hex [ 1 ] then
82206: LD_VAR 0 4
82210: PUSH
82211: LD_INT 1
82213: ARRAY
82214: IFFALSE 82218
// exit ;
82216: GO 82625
// height := hex [ 2 ] ;
82218: LD_ADDR_VAR 0 15
82222: PUSH
82223: LD_VAR 0 4
82227: PUSH
82228: LD_INT 2
82230: ARRAY
82231: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
82232: LD_ADDR_VAR 0 14
82236: PUSH
82237: LD_INT 0
82239: PUSH
82240: LD_INT 2
82242: PUSH
82243: LD_INT 3
82245: PUSH
82246: LD_INT 5
82248: PUSH
82249: EMPTY
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: ST_TO_ADDR
// for i in tmp do
82255: LD_ADDR_VAR 0 8
82259: PUSH
82260: LD_VAR 0 14
82264: PUSH
82265: FOR_IN
82266: IFFALSE 82436
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
82268: LD_ADDR_VAR 0 9
82272: PUSH
82273: LD_VAR 0 10
82277: PPUSH
82278: LD_VAR 0 8
82282: PPUSH
82283: LD_INT 5
82285: PPUSH
82286: CALL_OW 272
82290: PUSH
82291: LD_VAR 0 11
82295: PPUSH
82296: LD_VAR 0 8
82300: PPUSH
82301: LD_INT 5
82303: PPUSH
82304: CALL_OW 273
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82313: LD_VAR 0 9
82317: PUSH
82318: LD_INT 1
82320: ARRAY
82321: PPUSH
82322: LD_VAR 0 9
82326: PUSH
82327: LD_INT 2
82329: ARRAY
82330: PPUSH
82331: CALL_OW 488
82335: IFFALSE 82434
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
82337: LD_ADDR_VAR 0 4
82341: PUSH
82342: LD_VAR 0 9
82346: PUSH
82347: LD_INT 1
82349: ARRAY
82350: PPUSH
82351: LD_VAR 0 9
82355: PUSH
82356: LD_INT 2
82358: ARRAY
82359: PPUSH
82360: CALL_OW 546
82364: ST_TO_ADDR
// if hex [ 1 ] then
82365: LD_VAR 0 4
82369: PUSH
82370: LD_INT 1
82372: ARRAY
82373: IFFALSE 82377
// continue ;
82375: GO 82265
// h := hex [ 2 ] ;
82377: LD_ADDR_VAR 0 13
82381: PUSH
82382: LD_VAR 0 4
82386: PUSH
82387: LD_INT 2
82389: ARRAY
82390: ST_TO_ADDR
// if h + 7 < height then
82391: LD_VAR 0 13
82395: PUSH
82396: LD_INT 7
82398: PLUS
82399: PUSH
82400: LD_VAR 0 15
82404: LESS
82405: IFFALSE 82434
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
82407: LD_ADDR_VAR 0 18
82411: PUSH
82412: LD_INT 7
82414: PUSH
82415: LD_INT 28
82417: PUSH
82418: LD_INT 45
82420: PUSH
82421: EMPTY
82422: LIST
82423: LIST
82424: LIST
82425: PUSH
82426: LD_VAR 0 12
82430: ARRAY
82431: ST_TO_ADDR
// break ;
82432: GO 82436
// end ; end ; end ;
82434: GO 82265
82436: POP
82437: POP
// end ; if not weapon then
82438: LD_VAR 0 18
82442: NOT
82443: IFFALSE 82503
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
82445: LD_ADDR_VAR 0 5
82449: PUSH
82450: LD_VAR 0 5
82454: PUSH
82455: LD_INT 11
82457: PUSH
82458: LD_INT 30
82460: PUSH
82461: LD_INT 49
82463: PUSH
82464: EMPTY
82465: LIST
82466: LIST
82467: LIST
82468: DIFF
82469: ST_TO_ADDR
// if not list then
82470: LD_VAR 0 5
82474: NOT
82475: IFFALSE 82479
// exit ;
82477: GO 82625
// weapon := list [ rand ( 1 , list ) ] ;
82479: LD_ADDR_VAR 0 18
82483: PUSH
82484: LD_VAR 0 5
82488: PUSH
82489: LD_INT 1
82491: PPUSH
82492: LD_VAR 0 5
82496: PPUSH
82497: CALL_OW 12
82501: ARRAY
82502: ST_TO_ADDR
// end ; if weapon then
82503: LD_VAR 0 18
82507: IFFALSE 82625
// begin tmp := CostOfWeapon ( weapon ) ;
82509: LD_ADDR_VAR 0 14
82513: PUSH
82514: LD_VAR 0 18
82518: PPUSH
82519: CALL_OW 451
82523: ST_TO_ADDR
// j := GetBase ( tower ) ;
82524: LD_ADDR_VAR 0 9
82528: PUSH
82529: LD_VAR 0 1
82533: PPUSH
82534: CALL_OW 274
82538: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
82539: LD_VAR 0 9
82543: PPUSH
82544: LD_INT 1
82546: PPUSH
82547: CALL_OW 275
82551: PUSH
82552: LD_VAR 0 14
82556: PUSH
82557: LD_INT 1
82559: ARRAY
82560: GREATEREQUAL
82561: IFFALSE 82587
82563: PUSH
82564: LD_VAR 0 9
82568: PPUSH
82569: LD_INT 2
82571: PPUSH
82572: CALL_OW 275
82576: PUSH
82577: LD_VAR 0 14
82581: PUSH
82582: LD_INT 2
82584: ARRAY
82585: GREATEREQUAL
82586: AND
82587: IFFALSE 82613
82589: PUSH
82590: LD_VAR 0 9
82594: PPUSH
82595: LD_INT 3
82597: PPUSH
82598: CALL_OW 275
82602: PUSH
82603: LD_VAR 0 14
82607: PUSH
82608: LD_INT 3
82610: ARRAY
82611: GREATEREQUAL
82612: AND
82613: IFFALSE 82625
// result := weapon ;
82615: LD_ADDR_VAR 0 3
82619: PUSH
82620: LD_VAR 0 18
82624: ST_TO_ADDR
// end ; end ;
82625: LD_VAR 0 3
82629: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
82630: LD_INT 0
82632: PPUSH
82633: PPUSH
// result := true ;
82634: LD_ADDR_VAR 0 3
82638: PUSH
82639: LD_INT 1
82641: ST_TO_ADDR
// if array1 = array2 then
82642: LD_VAR 0 1
82646: PUSH
82647: LD_VAR 0 2
82651: EQUAL
82652: IFFALSE 82712
// begin for i = 1 to array1 do
82654: LD_ADDR_VAR 0 4
82658: PUSH
82659: DOUBLE
82660: LD_INT 1
82662: DEC
82663: ST_TO_ADDR
82664: LD_VAR 0 1
82668: PUSH
82669: FOR_TO
82670: IFFALSE 82708
// if array1 [ i ] <> array2 [ i ] then
82672: LD_VAR 0 1
82676: PUSH
82677: LD_VAR 0 4
82681: ARRAY
82682: PUSH
82683: LD_VAR 0 2
82687: PUSH
82688: LD_VAR 0 4
82692: ARRAY
82693: NONEQUAL
82694: IFFALSE 82706
// begin result := false ;
82696: LD_ADDR_VAR 0 3
82700: PUSH
82701: LD_INT 0
82703: ST_TO_ADDR
// break ;
82704: GO 82708
// end ;
82706: GO 82669
82708: POP
82709: POP
// end else
82710: GO 82720
// result := false ;
82712: LD_ADDR_VAR 0 3
82716: PUSH
82717: LD_INT 0
82719: ST_TO_ADDR
// end ;
82720: LD_VAR 0 3
82724: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
82725: LD_INT 0
82727: PPUSH
82728: PPUSH
// if not array1 or not array2 then
82729: LD_VAR 0 1
82733: NOT
82734: IFTRUE 82743
82736: PUSH
82737: LD_VAR 0 2
82741: NOT
82742: OR
82743: IFFALSE 82747
// exit ;
82745: GO 82811
// result := true ;
82747: LD_ADDR_VAR 0 3
82751: PUSH
82752: LD_INT 1
82754: ST_TO_ADDR
// for i = 1 to array1 do
82755: LD_ADDR_VAR 0 4
82759: PUSH
82760: DOUBLE
82761: LD_INT 1
82763: DEC
82764: ST_TO_ADDR
82765: LD_VAR 0 1
82769: PUSH
82770: FOR_TO
82771: IFFALSE 82809
// if array1 [ i ] <> array2 [ i ] then
82773: LD_VAR 0 1
82777: PUSH
82778: LD_VAR 0 4
82782: ARRAY
82783: PUSH
82784: LD_VAR 0 2
82788: PUSH
82789: LD_VAR 0 4
82793: ARRAY
82794: NONEQUAL
82795: IFFALSE 82807
// begin result := false ;
82797: LD_ADDR_VAR 0 3
82801: PUSH
82802: LD_INT 0
82804: ST_TO_ADDR
// break ;
82805: GO 82809
// end ;
82807: GO 82770
82809: POP
82810: POP
// end ;
82811: LD_VAR 0 3
82815: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
82816: LD_INT 0
82818: PPUSH
82819: PPUSH
82820: PPUSH
// pom := GetBase ( fac ) ;
82821: LD_ADDR_VAR 0 5
82825: PUSH
82826: LD_VAR 0 1
82830: PPUSH
82831: CALL_OW 274
82835: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82836: LD_ADDR_VAR 0 4
82840: PUSH
82841: LD_VAR 0 2
82845: PUSH
82846: LD_INT 1
82848: ARRAY
82849: PPUSH
82850: LD_VAR 0 2
82854: PUSH
82855: LD_INT 2
82857: ARRAY
82858: PPUSH
82859: LD_VAR 0 2
82863: PUSH
82864: LD_INT 3
82866: ARRAY
82867: PPUSH
82868: LD_VAR 0 2
82872: PUSH
82873: LD_INT 4
82875: ARRAY
82876: PPUSH
82877: CALL_OW 449
82881: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82882: LD_ADDR_VAR 0 3
82886: PUSH
82887: LD_VAR 0 5
82891: PPUSH
82892: LD_INT 1
82894: PPUSH
82895: CALL_OW 275
82899: PUSH
82900: LD_VAR 0 4
82904: PUSH
82905: LD_INT 1
82907: ARRAY
82908: GREATEREQUAL
82909: IFFALSE 82935
82911: PUSH
82912: LD_VAR 0 5
82916: PPUSH
82917: LD_INT 2
82919: PPUSH
82920: CALL_OW 275
82924: PUSH
82925: LD_VAR 0 4
82929: PUSH
82930: LD_INT 2
82932: ARRAY
82933: GREATEREQUAL
82934: AND
82935: IFFALSE 82961
82937: PUSH
82938: LD_VAR 0 5
82942: PPUSH
82943: LD_INT 3
82945: PPUSH
82946: CALL_OW 275
82950: PUSH
82951: LD_VAR 0 4
82955: PUSH
82956: LD_INT 3
82958: ARRAY
82959: GREATEREQUAL
82960: AND
82961: ST_TO_ADDR
// end ;
82962: LD_VAR 0 3
82966: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
82967: LD_INT 0
82969: PPUSH
82970: PPUSH
82971: PPUSH
82972: PPUSH
// pom := GetBase ( building ) ;
82973: LD_ADDR_VAR 0 3
82977: PUSH
82978: LD_VAR 0 1
82982: PPUSH
82983: CALL_OW 274
82987: ST_TO_ADDR
// if not pom then
82988: LD_VAR 0 3
82992: NOT
82993: IFFALSE 82997
// exit ;
82995: GO 83171
// btype := GetBType ( building ) ;
82997: LD_ADDR_VAR 0 5
83001: PUSH
83002: LD_VAR 0 1
83006: PPUSH
83007: CALL_OW 266
83011: ST_TO_ADDR
// if btype = b_armoury then
83012: LD_VAR 0 5
83016: PUSH
83017: LD_INT 4
83019: EQUAL
83020: IFFALSE 83030
// btype := b_barracks ;
83022: LD_ADDR_VAR 0 5
83026: PUSH
83027: LD_INT 5
83029: ST_TO_ADDR
// if btype = b_depot then
83030: LD_VAR 0 5
83034: PUSH
83035: LD_INT 0
83037: EQUAL
83038: IFFALSE 83048
// btype := b_warehouse ;
83040: LD_ADDR_VAR 0 5
83044: PUSH
83045: LD_INT 1
83047: ST_TO_ADDR
// if btype = b_workshop then
83048: LD_VAR 0 5
83052: PUSH
83053: LD_INT 2
83055: EQUAL
83056: IFFALSE 83066
// btype := b_factory ;
83058: LD_ADDR_VAR 0 5
83062: PUSH
83063: LD_INT 3
83065: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83066: LD_ADDR_VAR 0 4
83070: PUSH
83071: LD_VAR 0 5
83075: PPUSH
83076: LD_VAR 0 1
83080: PPUSH
83081: CALL_OW 248
83085: PPUSH
83086: CALL_OW 450
83090: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83091: LD_ADDR_VAR 0 2
83095: PUSH
83096: LD_VAR 0 3
83100: PPUSH
83101: LD_INT 1
83103: PPUSH
83104: CALL_OW 275
83108: PUSH
83109: LD_VAR 0 4
83113: PUSH
83114: LD_INT 1
83116: ARRAY
83117: GREATEREQUAL
83118: IFFALSE 83144
83120: PUSH
83121: LD_VAR 0 3
83125: PPUSH
83126: LD_INT 2
83128: PPUSH
83129: CALL_OW 275
83133: PUSH
83134: LD_VAR 0 4
83138: PUSH
83139: LD_INT 2
83141: ARRAY
83142: GREATEREQUAL
83143: AND
83144: IFFALSE 83170
83146: PUSH
83147: LD_VAR 0 3
83151: PPUSH
83152: LD_INT 3
83154: PPUSH
83155: CALL_OW 275
83159: PUSH
83160: LD_VAR 0 4
83164: PUSH
83165: LD_INT 3
83167: ARRAY
83168: GREATEREQUAL
83169: AND
83170: ST_TO_ADDR
// end ;
83171: LD_VAR 0 2
83175: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
83176: LD_INT 0
83178: PPUSH
83179: PPUSH
83180: PPUSH
// pom := GetBase ( building ) ;
83181: LD_ADDR_VAR 0 4
83185: PUSH
83186: LD_VAR 0 1
83190: PPUSH
83191: CALL_OW 274
83195: ST_TO_ADDR
// if not pom then
83196: LD_VAR 0 4
83200: NOT
83201: IFFALSE 83205
// exit ;
83203: GO 83310
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83205: LD_ADDR_VAR 0 5
83209: PUSH
83210: LD_VAR 0 2
83214: PPUSH
83215: LD_VAR 0 1
83219: PPUSH
83220: CALL_OW 248
83224: PPUSH
83225: CALL_OW 450
83229: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83230: LD_ADDR_VAR 0 3
83234: PUSH
83235: LD_VAR 0 4
83239: PPUSH
83240: LD_INT 1
83242: PPUSH
83243: CALL_OW 275
83247: PUSH
83248: LD_VAR 0 5
83252: PUSH
83253: LD_INT 1
83255: ARRAY
83256: GREATEREQUAL
83257: IFFALSE 83283
83259: PUSH
83260: LD_VAR 0 4
83264: PPUSH
83265: LD_INT 2
83267: PPUSH
83268: CALL_OW 275
83272: PUSH
83273: LD_VAR 0 5
83277: PUSH
83278: LD_INT 2
83280: ARRAY
83281: GREATEREQUAL
83282: AND
83283: IFFALSE 83309
83285: PUSH
83286: LD_VAR 0 4
83290: PPUSH
83291: LD_INT 3
83293: PPUSH
83294: CALL_OW 275
83298: PUSH
83299: LD_VAR 0 5
83303: PUSH
83304: LD_INT 3
83306: ARRAY
83307: GREATEREQUAL
83308: AND
83309: ST_TO_ADDR
// end ;
83310: LD_VAR 0 3
83314: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
83315: LD_INT 0
83317: PPUSH
83318: PPUSH
83319: PPUSH
83320: PPUSH
83321: PPUSH
83322: PPUSH
83323: PPUSH
83324: PPUSH
83325: PPUSH
83326: PPUSH
83327: PPUSH
// result := false ;
83328: LD_ADDR_VAR 0 8
83332: PUSH
83333: LD_INT 0
83335: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
83336: LD_VAR 0 5
83340: NOT
83341: IFTRUE 83350
83343: PUSH
83344: LD_VAR 0 1
83348: NOT
83349: OR
83350: IFTRUE 83359
83352: PUSH
83353: LD_VAR 0 2
83357: NOT
83358: OR
83359: IFTRUE 83368
83361: PUSH
83362: LD_VAR 0 3
83366: NOT
83367: OR
83368: IFFALSE 83372
// exit ;
83370: GO 84198
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
83372: LD_ADDR_VAR 0 14
83376: PUSH
83377: LD_VAR 0 1
83381: PPUSH
83382: LD_VAR 0 2
83386: PPUSH
83387: LD_VAR 0 3
83391: PPUSH
83392: LD_VAR 0 4
83396: PPUSH
83397: LD_VAR 0 5
83401: PUSH
83402: LD_INT 1
83404: ARRAY
83405: PPUSH
83406: CALL_OW 248
83410: PPUSH
83411: LD_INT 0
83413: PPUSH
83414: CALL 85479 0 6
83418: ST_TO_ADDR
// if not hexes then
83419: LD_VAR 0 14
83423: NOT
83424: IFFALSE 83428
// exit ;
83426: GO 84198
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
83428: LD_ADDR_VAR 0 17
83432: PUSH
83433: LD_VAR 0 5
83437: PPUSH
83438: LD_INT 22
83440: PUSH
83441: LD_VAR 0 13
83445: PPUSH
83446: CALL_OW 255
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 2
83457: PUSH
83458: LD_INT 30
83460: PUSH
83461: LD_INT 0
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 30
83470: PUSH
83471: LD_INT 1
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: EMPTY
83479: LIST
83480: LIST
83481: LIST
83482: PUSH
83483: EMPTY
83484: LIST
83485: LIST
83486: PPUSH
83487: CALL_OW 72
83491: ST_TO_ADDR
// for i = 1 to hexes do
83492: LD_ADDR_VAR 0 9
83496: PUSH
83497: DOUBLE
83498: LD_INT 1
83500: DEC
83501: ST_TO_ADDR
83502: LD_VAR 0 14
83506: PUSH
83507: FOR_TO
83508: IFFALSE 84196
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83510: LD_ADDR_VAR 0 13
83514: PUSH
83515: LD_VAR 0 14
83519: PUSH
83520: LD_VAR 0 9
83524: ARRAY
83525: PUSH
83526: LD_INT 1
83528: ARRAY
83529: PPUSH
83530: LD_VAR 0 14
83534: PUSH
83535: LD_VAR 0 9
83539: ARRAY
83540: PUSH
83541: LD_INT 2
83543: ARRAY
83544: PPUSH
83545: CALL_OW 428
83549: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
83550: LD_VAR 0 14
83554: PUSH
83555: LD_VAR 0 9
83559: ARRAY
83560: PUSH
83561: LD_INT 1
83563: ARRAY
83564: PPUSH
83565: LD_VAR 0 14
83569: PUSH
83570: LD_VAR 0 9
83574: ARRAY
83575: PUSH
83576: LD_INT 2
83578: ARRAY
83579: PPUSH
83580: CALL_OW 351
83584: IFTRUE 83623
83586: PUSH
83587: LD_VAR 0 14
83591: PUSH
83592: LD_VAR 0 9
83596: ARRAY
83597: PUSH
83598: LD_INT 1
83600: ARRAY
83601: PPUSH
83602: LD_VAR 0 14
83606: PUSH
83607: LD_VAR 0 9
83611: ARRAY
83612: PUSH
83613: LD_INT 2
83615: ARRAY
83616: PPUSH
83617: CALL_OW 488
83621: NOT
83622: OR
83623: IFTRUE 83640
83625: PUSH
83626: LD_VAR 0 13
83630: PPUSH
83631: CALL_OW 247
83635: PUSH
83636: LD_INT 3
83638: EQUAL
83639: OR
83640: IFFALSE 83646
// exit ;
83642: POP
83643: POP
83644: GO 84198
// if not tmp then
83646: LD_VAR 0 13
83650: NOT
83651: IFFALSE 83655
// continue ;
83653: GO 83507
// result := true ;
83655: LD_ADDR_VAR 0 8
83659: PUSH
83660: LD_INT 1
83662: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
83663: LD_VAR 0 6
83667: IFFALSE 83684
83669: PUSH
83670: LD_VAR 0 13
83674: PPUSH
83675: CALL_OW 247
83679: PUSH
83680: LD_INT 2
83682: EQUAL
83683: AND
83684: IFFALSE 83701
83686: PUSH
83687: LD_VAR 0 13
83691: PPUSH
83692: CALL_OW 263
83696: PUSH
83697: LD_INT 1
83699: EQUAL
83700: AND
83701: IFFALSE 83865
// begin if IsDrivenBy ( tmp ) then
83703: LD_VAR 0 13
83707: PPUSH
83708: CALL_OW 311
83712: IFFALSE 83716
// continue ;
83714: GO 83507
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
83716: LD_VAR 0 6
83720: PPUSH
83721: LD_INT 3
83723: PUSH
83724: LD_INT 60
83726: PUSH
83727: EMPTY
83728: LIST
83729: PUSH
83730: EMPTY
83731: LIST
83732: LIST
83733: PUSH
83734: LD_INT 3
83736: PUSH
83737: LD_INT 55
83739: PUSH
83740: EMPTY
83741: LIST
83742: PUSH
83743: EMPTY
83744: LIST
83745: LIST
83746: PUSH
83747: EMPTY
83748: LIST
83749: LIST
83750: PPUSH
83751: CALL_OW 72
83755: IFFALSE 83863
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
83757: LD_ADDR_VAR 0 18
83761: PUSH
83762: LD_VAR 0 6
83766: PPUSH
83767: LD_INT 3
83769: PUSH
83770: LD_INT 60
83772: PUSH
83773: EMPTY
83774: LIST
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 3
83782: PUSH
83783: LD_INT 55
83785: PUSH
83786: EMPTY
83787: LIST
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PPUSH
83797: CALL_OW 72
83801: PUSH
83802: LD_INT 1
83804: ARRAY
83805: ST_TO_ADDR
// if IsInUnit ( driver ) then
83806: LD_VAR 0 18
83810: PPUSH
83811: CALL_OW 310
83815: IFFALSE 83826
// ComExit ( driver ) ;
83817: LD_VAR 0 18
83821: PPUSH
83822: CALL 109469 0 1
// AddComEnterUnit ( driver , tmp ) ;
83826: LD_VAR 0 18
83830: PPUSH
83831: LD_VAR 0 13
83835: PPUSH
83836: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
83840: LD_VAR 0 18
83844: PPUSH
83845: LD_VAR 0 7
83849: PPUSH
83850: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83854: LD_VAR 0 18
83858: PPUSH
83859: CALL_OW 181
// end ; continue ;
83863: GO 83507
// end ; if not cleaners or not tmp in cleaners then
83865: LD_VAR 0 6
83869: NOT
83870: IFTRUE 83885
83872: PUSH
83873: LD_VAR 0 13
83877: PUSH
83878: LD_VAR 0 6
83882: IN
83883: NOT
83884: OR
83885: IFFALSE 84194
// begin if dep then
83887: LD_VAR 0 17
83891: IFFALSE 84027
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83893: LD_ADDR_VAR 0 16
83897: PUSH
83898: LD_VAR 0 17
83902: PUSH
83903: LD_INT 1
83905: ARRAY
83906: PPUSH
83907: CALL_OW 250
83911: PPUSH
83912: LD_VAR 0 17
83916: PUSH
83917: LD_INT 1
83919: ARRAY
83920: PPUSH
83921: CALL_OW 254
83925: PPUSH
83926: LD_INT 5
83928: PPUSH
83929: CALL_OW 272
83933: PUSH
83934: LD_VAR 0 17
83938: PUSH
83939: LD_INT 1
83941: ARRAY
83942: PPUSH
83943: CALL_OW 251
83947: PPUSH
83948: LD_VAR 0 17
83952: PUSH
83953: LD_INT 1
83955: ARRAY
83956: PPUSH
83957: CALL_OW 254
83961: PPUSH
83962: LD_INT 5
83964: PPUSH
83965: CALL_OW 273
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
83974: LD_VAR 0 16
83978: PUSH
83979: LD_INT 1
83981: ARRAY
83982: PPUSH
83983: LD_VAR 0 16
83987: PUSH
83988: LD_INT 2
83990: ARRAY
83991: PPUSH
83992: CALL_OW 488
83996: IFFALSE 84027
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
83998: LD_VAR 0 13
84002: PPUSH
84003: LD_VAR 0 16
84007: PUSH
84008: LD_INT 1
84010: ARRAY
84011: PPUSH
84012: LD_VAR 0 16
84016: PUSH
84017: LD_INT 2
84019: ARRAY
84020: PPUSH
84021: CALL_OW 111
// continue ;
84025: GO 83507
// end ; end ; r := GetDir ( tmp ) ;
84027: LD_ADDR_VAR 0 15
84031: PUSH
84032: LD_VAR 0 13
84036: PPUSH
84037: CALL_OW 254
84041: ST_TO_ADDR
// if r = 5 then
84042: LD_VAR 0 15
84046: PUSH
84047: LD_INT 5
84049: EQUAL
84050: IFFALSE 84060
// r := 0 ;
84052: LD_ADDR_VAR 0 15
84056: PUSH
84057: LD_INT 0
84059: ST_TO_ADDR
// for j = r to 5 do
84060: LD_ADDR_VAR 0 10
84064: PUSH
84065: DOUBLE
84066: LD_VAR 0 15
84070: DEC
84071: ST_TO_ADDR
84072: LD_INT 5
84074: PUSH
84075: FOR_TO
84076: IFFALSE 84192
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
84078: LD_ADDR_VAR 0 11
84082: PUSH
84083: LD_VAR 0 13
84087: PPUSH
84088: CALL_OW 250
84092: PPUSH
84093: LD_VAR 0 10
84097: PPUSH
84098: LD_INT 2
84100: PPUSH
84101: CALL_OW 272
84105: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
84106: LD_ADDR_VAR 0 12
84110: PUSH
84111: LD_VAR 0 13
84115: PPUSH
84116: CALL_OW 251
84120: PPUSH
84121: LD_VAR 0 10
84125: PPUSH
84126: LD_INT 2
84128: PPUSH
84129: CALL_OW 273
84133: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
84134: LD_VAR 0 11
84138: PPUSH
84139: LD_VAR 0 12
84143: PPUSH
84144: CALL_OW 488
84148: IFFALSE 84167
84150: PUSH
84151: LD_VAR 0 11
84155: PPUSH
84156: LD_VAR 0 12
84160: PPUSH
84161: CALL_OW 428
84165: NOT
84166: AND
84167: IFFALSE 84190
// begin ComMoveXY ( tmp , _x , _y ) ;
84169: LD_VAR 0 13
84173: PPUSH
84174: LD_VAR 0 11
84178: PPUSH
84179: LD_VAR 0 12
84183: PPUSH
84184: CALL_OW 111
// break ;
84188: GO 84192
// end ; end ;
84190: GO 84075
84192: POP
84193: POP
// end ; end ;
84194: GO 83507
84196: POP
84197: POP
// end ;
84198: LD_VAR 0 8
84202: RET
// export function BuildingTechInvented ( side , btype ) ; begin
84203: LD_INT 0
84205: PPUSH
// result := true ;
84206: LD_ADDR_VAR 0 3
84210: PUSH
84211: LD_INT 1
84213: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
84214: LD_VAR 0 2
84218: PUSH
84219: LD_INT 24
84221: DOUBLE
84222: EQUAL
84223: IFTRUE 84233
84225: LD_INT 33
84227: DOUBLE
84228: EQUAL
84229: IFTRUE 84233
84231: GO 84258
84233: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
84234: LD_ADDR_VAR 0 3
84238: PUSH
84239: LD_INT 32
84241: PPUSH
84242: LD_VAR 0 1
84246: PPUSH
84247: CALL_OW 321
84251: PUSH
84252: LD_INT 2
84254: EQUAL
84255: ST_TO_ADDR
84256: GO 84574
84258: LD_INT 20
84260: DOUBLE
84261: EQUAL
84262: IFTRUE 84266
84264: GO 84291
84266: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
84267: LD_ADDR_VAR 0 3
84271: PUSH
84272: LD_INT 6
84274: PPUSH
84275: LD_VAR 0 1
84279: PPUSH
84280: CALL_OW 321
84284: PUSH
84285: LD_INT 2
84287: EQUAL
84288: ST_TO_ADDR
84289: GO 84574
84291: LD_INT 22
84293: DOUBLE
84294: EQUAL
84295: IFTRUE 84305
84297: LD_INT 36
84299: DOUBLE
84300: EQUAL
84301: IFTRUE 84305
84303: GO 84330
84305: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
84306: LD_ADDR_VAR 0 3
84310: PUSH
84311: LD_INT 15
84313: PPUSH
84314: LD_VAR 0 1
84318: PPUSH
84319: CALL_OW 321
84323: PUSH
84324: LD_INT 2
84326: EQUAL
84327: ST_TO_ADDR
84328: GO 84574
84330: LD_INT 30
84332: DOUBLE
84333: EQUAL
84334: IFTRUE 84338
84336: GO 84363
84338: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
84339: LD_ADDR_VAR 0 3
84343: PUSH
84344: LD_INT 20
84346: PPUSH
84347: LD_VAR 0 1
84351: PPUSH
84352: CALL_OW 321
84356: PUSH
84357: LD_INT 2
84359: EQUAL
84360: ST_TO_ADDR
84361: GO 84574
84363: LD_INT 28
84365: DOUBLE
84366: EQUAL
84367: IFTRUE 84377
84369: LD_INT 21
84371: DOUBLE
84372: EQUAL
84373: IFTRUE 84377
84375: GO 84402
84377: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
84378: LD_ADDR_VAR 0 3
84382: PUSH
84383: LD_INT 21
84385: PPUSH
84386: LD_VAR 0 1
84390: PPUSH
84391: CALL_OW 321
84395: PUSH
84396: LD_INT 2
84398: EQUAL
84399: ST_TO_ADDR
84400: GO 84574
84402: LD_INT 16
84404: DOUBLE
84405: EQUAL
84406: IFTRUE 84410
84408: GO 84435
84410: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
84411: LD_ADDR_VAR 0 3
84415: PUSH
84416: LD_INT 84
84418: PPUSH
84419: LD_VAR 0 1
84423: PPUSH
84424: CALL_OW 321
84428: PUSH
84429: LD_INT 2
84431: EQUAL
84432: ST_TO_ADDR
84433: GO 84574
84435: LD_INT 19
84437: DOUBLE
84438: EQUAL
84439: IFTRUE 84449
84441: LD_INT 23
84443: DOUBLE
84444: EQUAL
84445: IFTRUE 84449
84447: GO 84474
84449: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
84450: LD_ADDR_VAR 0 3
84454: PUSH
84455: LD_INT 83
84457: PPUSH
84458: LD_VAR 0 1
84462: PPUSH
84463: CALL_OW 321
84467: PUSH
84468: LD_INT 2
84470: EQUAL
84471: ST_TO_ADDR
84472: GO 84574
84474: LD_INT 17
84476: DOUBLE
84477: EQUAL
84478: IFTRUE 84482
84480: GO 84507
84482: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
84483: LD_ADDR_VAR 0 3
84487: PUSH
84488: LD_INT 39
84490: PPUSH
84491: LD_VAR 0 1
84495: PPUSH
84496: CALL_OW 321
84500: PUSH
84501: LD_INT 2
84503: EQUAL
84504: ST_TO_ADDR
84505: GO 84574
84507: LD_INT 18
84509: DOUBLE
84510: EQUAL
84511: IFTRUE 84515
84513: GO 84540
84515: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
84516: LD_ADDR_VAR 0 3
84520: PUSH
84521: LD_INT 40
84523: PPUSH
84524: LD_VAR 0 1
84528: PPUSH
84529: CALL_OW 321
84533: PUSH
84534: LD_INT 2
84536: EQUAL
84537: ST_TO_ADDR
84538: GO 84574
84540: LD_INT 27
84542: DOUBLE
84543: EQUAL
84544: IFTRUE 84548
84546: GO 84573
84548: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
84549: LD_ADDR_VAR 0 3
84553: PUSH
84554: LD_INT 35
84556: PPUSH
84557: LD_VAR 0 1
84561: PPUSH
84562: CALL_OW 321
84566: PUSH
84567: LD_INT 2
84569: EQUAL
84570: ST_TO_ADDR
84571: GO 84574
84573: POP
// end ;
84574: LD_VAR 0 3
84578: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
84579: LD_INT 0
84581: PPUSH
84582: PPUSH
84583: PPUSH
84584: PPUSH
84585: PPUSH
84586: PPUSH
84587: PPUSH
84588: PPUSH
84589: PPUSH
84590: PPUSH
84591: PPUSH
// result := false ;
84592: LD_ADDR_VAR 0 6
84596: PUSH
84597: LD_INT 0
84599: ST_TO_ADDR
// if btype = b_depot then
84600: LD_VAR 0 2
84604: PUSH
84605: LD_INT 0
84607: EQUAL
84608: IFFALSE 84620
// begin result := true ;
84610: LD_ADDR_VAR 0 6
84614: PUSH
84615: LD_INT 1
84617: ST_TO_ADDR
// exit ;
84618: GO 85474
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
84620: LD_VAR 0 1
84624: NOT
84625: IFTRUE 84650
84627: PUSH
84628: LD_VAR 0 1
84632: PPUSH
84633: CALL_OW 266
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: LD_INT 1
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: IN
84648: NOT
84649: OR
84650: IFTRUE 84659
84652: PUSH
84653: LD_VAR 0 2
84657: NOT
84658: OR
84659: IFTRUE 84695
84661: PUSH
84662: LD_VAR 0 5
84666: PUSH
84667: LD_INT 0
84669: PUSH
84670: LD_INT 1
84672: PUSH
84673: LD_INT 2
84675: PUSH
84676: LD_INT 3
84678: PUSH
84679: LD_INT 4
84681: PUSH
84682: LD_INT 5
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: IN
84693: NOT
84694: OR
84695: IFTRUE 84714
84697: PUSH
84698: LD_VAR 0 3
84702: PPUSH
84703: LD_VAR 0 4
84707: PPUSH
84708: CALL_OW 488
84712: NOT
84713: OR
84714: IFFALSE 84718
// exit ;
84716: GO 85474
// side := GetSide ( depot ) ;
84718: LD_ADDR_VAR 0 9
84722: PUSH
84723: LD_VAR 0 1
84727: PPUSH
84728: CALL_OW 255
84732: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
84733: LD_VAR 0 9
84737: PPUSH
84738: LD_VAR 0 2
84742: PPUSH
84743: CALL 84203 0 2
84747: NOT
84748: IFFALSE 84752
// exit ;
84750: GO 85474
// pom := GetBase ( depot ) ;
84752: LD_ADDR_VAR 0 10
84756: PUSH
84757: LD_VAR 0 1
84761: PPUSH
84762: CALL_OW 274
84766: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
84767: LD_ADDR_VAR 0 11
84771: PUSH
84772: LD_VAR 0 2
84776: PPUSH
84777: LD_VAR 0 1
84781: PPUSH
84782: CALL_OW 248
84786: PPUSH
84787: CALL_OW 450
84791: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
84792: LD_VAR 0 10
84796: PPUSH
84797: LD_INT 1
84799: PPUSH
84800: CALL_OW 275
84804: PUSH
84805: LD_VAR 0 11
84809: PUSH
84810: LD_INT 1
84812: ARRAY
84813: GREATEREQUAL
84814: IFFALSE 84840
84816: PUSH
84817: LD_VAR 0 10
84821: PPUSH
84822: LD_INT 2
84824: PPUSH
84825: CALL_OW 275
84829: PUSH
84830: LD_VAR 0 11
84834: PUSH
84835: LD_INT 2
84837: ARRAY
84838: GREATEREQUAL
84839: AND
84840: IFFALSE 84866
84842: PUSH
84843: LD_VAR 0 10
84847: PPUSH
84848: LD_INT 3
84850: PPUSH
84851: CALL_OW 275
84855: PUSH
84856: LD_VAR 0 11
84860: PUSH
84861: LD_INT 3
84863: ARRAY
84864: GREATEREQUAL
84865: AND
84866: NOT
84867: IFFALSE 84871
// exit ;
84869: GO 85474
// if GetBType ( depot ) = b_depot then
84871: LD_VAR 0 1
84875: PPUSH
84876: CALL_OW 266
84880: PUSH
84881: LD_INT 0
84883: EQUAL
84884: IFFALSE 84896
// dist := 28 else
84886: LD_ADDR_VAR 0 14
84890: PUSH
84891: LD_INT 28
84893: ST_TO_ADDR
84894: GO 84904
// dist := 36 ;
84896: LD_ADDR_VAR 0 14
84900: PUSH
84901: LD_INT 36
84903: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84904: LD_VAR 0 1
84908: PPUSH
84909: LD_VAR 0 3
84913: PPUSH
84914: LD_VAR 0 4
84918: PPUSH
84919: CALL_OW 297
84923: PUSH
84924: LD_VAR 0 14
84928: GREATER
84929: IFFALSE 84933
// exit ;
84931: GO 85474
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84933: LD_ADDR_VAR 0 12
84937: PUSH
84938: LD_VAR 0 2
84942: PPUSH
84943: LD_VAR 0 3
84947: PPUSH
84948: LD_VAR 0 4
84952: PPUSH
84953: LD_VAR 0 5
84957: PPUSH
84958: LD_VAR 0 1
84962: PPUSH
84963: CALL_OW 248
84967: PPUSH
84968: LD_INT 0
84970: PPUSH
84971: CALL 85479 0 6
84975: ST_TO_ADDR
// if not hexes then
84976: LD_VAR 0 12
84980: NOT
84981: IFFALSE 84985
// exit ;
84983: GO 85474
// hex := GetHexInfo ( x , y ) ;
84985: LD_ADDR_VAR 0 15
84989: PUSH
84990: LD_VAR 0 3
84994: PPUSH
84995: LD_VAR 0 4
84999: PPUSH
85000: CALL_OW 546
85004: ST_TO_ADDR
// if hex [ 1 ] then
85005: LD_VAR 0 15
85009: PUSH
85010: LD_INT 1
85012: ARRAY
85013: IFFALSE 85017
// exit ;
85015: GO 85474
// height := hex [ 2 ] ;
85017: LD_ADDR_VAR 0 13
85021: PUSH
85022: LD_VAR 0 15
85026: PUSH
85027: LD_INT 2
85029: ARRAY
85030: ST_TO_ADDR
// for i = 1 to hexes do
85031: LD_ADDR_VAR 0 7
85035: PUSH
85036: DOUBLE
85037: LD_INT 1
85039: DEC
85040: ST_TO_ADDR
85041: LD_VAR 0 12
85045: PUSH
85046: FOR_TO
85047: IFFALSE 85391
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
85049: LD_VAR 0 12
85053: PUSH
85054: LD_VAR 0 7
85058: ARRAY
85059: PUSH
85060: LD_INT 1
85062: ARRAY
85063: PPUSH
85064: LD_VAR 0 12
85068: PUSH
85069: LD_VAR 0 7
85073: ARRAY
85074: PUSH
85075: LD_INT 2
85077: ARRAY
85078: PPUSH
85079: CALL_OW 488
85083: NOT
85084: IFTRUE 85126
85086: PUSH
85087: LD_VAR 0 12
85091: PUSH
85092: LD_VAR 0 7
85096: ARRAY
85097: PUSH
85098: LD_INT 1
85100: ARRAY
85101: PPUSH
85102: LD_VAR 0 12
85106: PUSH
85107: LD_VAR 0 7
85111: ARRAY
85112: PUSH
85113: LD_INT 2
85115: ARRAY
85116: PPUSH
85117: CALL_OW 428
85121: PUSH
85122: LD_INT 0
85124: GREATER
85125: OR
85126: IFTRUE 85164
85128: PUSH
85129: LD_VAR 0 12
85133: PUSH
85134: LD_VAR 0 7
85138: ARRAY
85139: PUSH
85140: LD_INT 1
85142: ARRAY
85143: PPUSH
85144: LD_VAR 0 12
85148: PUSH
85149: LD_VAR 0 7
85153: ARRAY
85154: PUSH
85155: LD_INT 2
85157: ARRAY
85158: PPUSH
85159: CALL_OW 351
85163: OR
85164: IFFALSE 85170
// exit ;
85166: POP
85167: POP
85168: GO 85474
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85170: LD_ADDR_VAR 0 8
85174: PUSH
85175: LD_VAR 0 12
85179: PUSH
85180: LD_VAR 0 7
85184: ARRAY
85185: PUSH
85186: LD_INT 1
85188: ARRAY
85189: PPUSH
85190: LD_VAR 0 12
85194: PUSH
85195: LD_VAR 0 7
85199: ARRAY
85200: PUSH
85201: LD_INT 2
85203: ARRAY
85204: PPUSH
85205: CALL_OW 546
85209: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
85210: LD_VAR 0 8
85214: PUSH
85215: LD_INT 1
85217: ARRAY
85218: IFTRUE 85240
85220: PUSH
85221: LD_VAR 0 8
85225: PUSH
85226: LD_INT 2
85228: ARRAY
85229: PUSH
85230: LD_VAR 0 13
85234: PUSH
85235: LD_INT 2
85237: PLUS
85238: GREATER
85239: OR
85240: IFTRUE 85262
85242: PUSH
85243: LD_VAR 0 8
85247: PUSH
85248: LD_INT 2
85250: ARRAY
85251: PUSH
85252: LD_VAR 0 13
85256: PUSH
85257: LD_INT 2
85259: MINUS
85260: LESS
85261: OR
85262: IFTRUE 85330
85264: PUSH
85265: LD_VAR 0 8
85269: PUSH
85270: LD_INT 3
85272: ARRAY
85273: PUSH
85274: LD_INT 0
85276: PUSH
85277: LD_INT 8
85279: PUSH
85280: LD_INT 9
85282: PUSH
85283: LD_INT 10
85285: PUSH
85286: LD_INT 11
85288: PUSH
85289: LD_INT 12
85291: PUSH
85292: LD_INT 13
85294: PUSH
85295: LD_INT 16
85297: PUSH
85298: LD_INT 17
85300: PUSH
85301: LD_INT 18
85303: PUSH
85304: LD_INT 19
85306: PUSH
85307: LD_INT 20
85309: PUSH
85310: LD_INT 21
85312: PUSH
85313: EMPTY
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: IN
85328: NOT
85329: OR
85330: IFTRUE 85343
85332: PUSH
85333: LD_VAR 0 8
85337: PUSH
85338: LD_INT 5
85340: ARRAY
85341: NOT
85342: OR
85343: IFTRUE 85383
85345: PUSH
85346: LD_VAR 0 8
85350: PUSH
85351: LD_INT 6
85353: ARRAY
85354: PUSH
85355: LD_INT 1
85357: PUSH
85358: LD_INT 2
85360: PUSH
85361: LD_INT 7
85363: PUSH
85364: LD_INT 9
85366: PUSH
85367: LD_INT 10
85369: PUSH
85370: LD_INT 11
85372: PUSH
85373: EMPTY
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: IN
85381: NOT
85382: OR
85383: IFFALSE 85389
// exit ;
85385: POP
85386: POP
85387: GO 85474
// end ;
85389: GO 85046
85391: POP
85392: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
85393: LD_VAR 0 9
85397: PPUSH
85398: LD_VAR 0 3
85402: PPUSH
85403: LD_VAR 0 4
85407: PPUSH
85408: LD_INT 20
85410: PPUSH
85411: CALL 77293 0 4
85415: PUSH
85416: LD_INT 4
85418: ARRAY
85419: IFFALSE 85423
// exit ;
85421: GO 85474
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
85423: LD_VAR 0 2
85427: PUSH
85428: LD_INT 29
85430: PUSH
85431: LD_INT 30
85433: PUSH
85434: EMPTY
85435: LIST
85436: LIST
85437: IN
85438: IFFALSE 85462
85440: PUSH
85441: LD_VAR 0 3
85445: PPUSH
85446: LD_VAR 0 4
85450: PPUSH
85451: LD_VAR 0 9
85455: PPUSH
85456: CALL_OW 440
85460: NOT
85461: AND
85462: IFFALSE 85466
// exit ;
85464: GO 85474
// result := true ;
85466: LD_ADDR_VAR 0 6
85470: PUSH
85471: LD_INT 1
85473: ST_TO_ADDR
// end ;
85474: LD_VAR 0 6
85478: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
85479: LD_INT 0
85481: PPUSH
85482: PPUSH
85483: PPUSH
85484: PPUSH
85485: PPUSH
85486: PPUSH
85487: PPUSH
85488: PPUSH
85489: PPUSH
85490: PPUSH
85491: PPUSH
85492: PPUSH
85493: PPUSH
85494: PPUSH
85495: PPUSH
85496: PPUSH
85497: PPUSH
85498: PPUSH
85499: PPUSH
85500: PPUSH
85501: PPUSH
85502: PPUSH
85503: PPUSH
85504: PPUSH
85505: PPUSH
85506: PPUSH
85507: PPUSH
85508: PPUSH
85509: PPUSH
85510: PPUSH
85511: PPUSH
85512: PPUSH
85513: PPUSH
85514: PPUSH
85515: PPUSH
85516: PPUSH
85517: PPUSH
85518: PPUSH
85519: PPUSH
85520: PPUSH
85521: PPUSH
85522: PPUSH
85523: PPUSH
85524: PPUSH
85525: PPUSH
85526: PPUSH
85527: PPUSH
85528: PPUSH
85529: PPUSH
85530: PPUSH
85531: PPUSH
85532: PPUSH
85533: PPUSH
85534: PPUSH
85535: PPUSH
85536: PPUSH
85537: PPUSH
85538: PPUSH
// result = [ ] ;
85539: LD_ADDR_VAR 0 7
85543: PUSH
85544: EMPTY
85545: ST_TO_ADDR
// temp_list = [ ] ;
85546: LD_ADDR_VAR 0 9
85550: PUSH
85551: EMPTY
85552: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
85553: LD_VAR 0 4
85557: PUSH
85558: LD_INT 0
85560: PUSH
85561: LD_INT 1
85563: PUSH
85564: LD_INT 2
85566: PUSH
85567: LD_INT 3
85569: PUSH
85570: LD_INT 4
85572: PUSH
85573: LD_INT 5
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: LIST
85580: LIST
85581: LIST
85582: LIST
85583: IN
85584: NOT
85585: IFTRUE 85628
85587: PUSH
85588: LD_VAR 0 1
85592: PUSH
85593: LD_INT 0
85595: PUSH
85596: LD_INT 1
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: IN
85603: IFFALSE 85627
85605: PUSH
85606: LD_VAR 0 5
85610: PUSH
85611: LD_INT 1
85613: PUSH
85614: LD_INT 2
85616: PUSH
85617: LD_INT 3
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: LIST
85624: IN
85625: NOT
85626: AND
85627: OR
85628: IFFALSE 85632
// exit ;
85630: GO 104031
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
85632: LD_VAR 0 1
85636: PUSH
85637: LD_INT 6
85639: PUSH
85640: LD_INT 7
85642: PUSH
85643: LD_INT 8
85645: PUSH
85646: LD_INT 13
85648: PUSH
85649: LD_INT 12
85651: PUSH
85652: LD_INT 15
85654: PUSH
85655: LD_INT 11
85657: PUSH
85658: LD_INT 14
85660: PUSH
85661: LD_INT 10
85663: PUSH
85664: EMPTY
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: IN
85675: IFFALSE 85685
// btype = b_lab ;
85677: LD_ADDR_VAR 0 1
85681: PUSH
85682: LD_INT 6
85684: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
85685: LD_VAR 0 6
85689: PUSH
85690: LD_INT 0
85692: PUSH
85693: LD_INT 1
85695: PUSH
85696: LD_INT 2
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: LIST
85703: IN
85704: NOT
85705: IFTRUE 85773
85707: PUSH
85708: LD_VAR 0 1
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: LD_INT 1
85718: PUSH
85719: LD_INT 2
85721: PUSH
85722: LD_INT 3
85724: PUSH
85725: LD_INT 6
85727: PUSH
85728: LD_INT 36
85730: PUSH
85731: LD_INT 4
85733: PUSH
85734: LD_INT 5
85736: PUSH
85737: LD_INT 31
85739: PUSH
85740: LD_INT 32
85742: PUSH
85743: LD_INT 33
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: IN
85759: NOT
85760: IFFALSE 85772
85762: PUSH
85763: LD_VAR 0 6
85767: PUSH
85768: LD_INT 1
85770: EQUAL
85771: AND
85772: OR
85773: IFTRUE 85805
85775: PUSH
85776: LD_VAR 0 1
85780: PUSH
85781: LD_INT 2
85783: PUSH
85784: LD_INT 3
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: IN
85791: NOT
85792: IFFALSE 85804
85794: PUSH
85795: LD_VAR 0 6
85799: PUSH
85800: LD_INT 2
85802: EQUAL
85803: AND
85804: OR
85805: IFFALSE 85815
// mode = 0 ;
85807: LD_ADDR_VAR 0 6
85811: PUSH
85812: LD_INT 0
85814: ST_TO_ADDR
// case mode of 0 :
85815: LD_VAR 0 6
85819: PUSH
85820: LD_INT 0
85822: DOUBLE
85823: EQUAL
85824: IFTRUE 85828
85826: GO 97281
85828: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85829: LD_ADDR_VAR 0 11
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 0
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 1
85857: PUSH
85858: LD_INT 0
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 1
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 1
85887: NEG
85888: PUSH
85889: LD_INT 0
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 1
85898: NEG
85899: PUSH
85900: LD_INT 1
85902: NEG
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: PUSH
85908: LD_INT 1
85910: NEG
85911: PUSH
85912: LD_INT 2
85914: NEG
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 2
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: LD_INT 1
85936: NEG
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 1
85944: PUSH
85945: LD_INT 2
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 0
85954: PUSH
85955: LD_INT 2
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: NEG
85965: PUSH
85966: LD_INT 1
85968: PUSH
85969: EMPTY
85970: LIST
85971: LIST
85972: PUSH
85973: LD_INT 1
85975: PUSH
85976: LD_INT 3
85978: PUSH
85979: EMPTY
85980: LIST
85981: LIST
85982: PUSH
85983: LD_INT 0
85985: PUSH
85986: LD_INT 3
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 1
85995: NEG
85996: PUSH
85997: LD_INT 2
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86022: LD_ADDR_VAR 0 12
86026: PUSH
86027: LD_INT 0
86029: PUSH
86030: LD_INT 0
86032: PUSH
86033: EMPTY
86034: LIST
86035: LIST
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: LD_INT 1
86042: NEG
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 1
86050: PUSH
86051: LD_INT 0
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 1
86060: PUSH
86061: LD_INT 1
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: LD_INT 1
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 1
86080: NEG
86081: PUSH
86082: LD_INT 0
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 1
86091: NEG
86092: PUSH
86093: LD_INT 1
86095: NEG
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PUSH
86101: LD_INT 1
86103: PUSH
86104: LD_INT 1
86106: NEG
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 2
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 2
86124: PUSH
86125: LD_INT 1
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: LD_INT 1
86134: NEG
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: EMPTY
86151: LIST
86152: LIST
86153: PUSH
86154: LD_INT 2
86156: NEG
86157: PUSH
86158: LD_INT 1
86160: NEG
86161: PUSH
86162: EMPTY
86163: LIST
86164: LIST
86165: PUSH
86166: LD_INT 2
86168: NEG
86169: PUSH
86170: LD_INT 1
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 3
86179: NEG
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 3
86190: NEG
86191: PUSH
86192: LD_INT 1
86194: NEG
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: LIST
86204: LIST
86205: LIST
86206: LIST
86207: LIST
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86218: LD_ADDR_VAR 0 13
86222: PUSH
86223: LD_INT 0
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 0
86235: PUSH
86236: LD_INT 1
86238: NEG
86239: PUSH
86240: EMPTY
86241: LIST
86242: LIST
86243: PUSH
86244: LD_INT 1
86246: PUSH
86247: LD_INT 0
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: LD_INT 1
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: EMPTY
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: LD_INT 1
86269: PUSH
86270: EMPTY
86271: LIST
86272: LIST
86273: PUSH
86274: LD_INT 1
86276: NEG
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 1
86287: NEG
86288: PUSH
86289: LD_INT 1
86291: NEG
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: PUSH
86297: LD_INT 1
86299: NEG
86300: PUSH
86301: LD_INT 2
86303: NEG
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 2
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: EMPTY
86316: LIST
86317: LIST
86318: PUSH
86319: LD_INT 2
86321: PUSH
86322: LD_INT 2
86324: PUSH
86325: EMPTY
86326: LIST
86327: LIST
86328: PUSH
86329: LD_INT 1
86331: PUSH
86332: LD_INT 2
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: PUSH
86339: LD_INT 2
86341: NEG
86342: PUSH
86343: LD_INT 1
86345: NEG
86346: PUSH
86347: EMPTY
86348: LIST
86349: LIST
86350: PUSH
86351: LD_INT 2
86353: NEG
86354: PUSH
86355: LD_INT 2
86357: NEG
86358: PUSH
86359: EMPTY
86360: LIST
86361: LIST
86362: PUSH
86363: LD_INT 2
86365: NEG
86366: PUSH
86367: LD_INT 3
86369: NEG
86370: PUSH
86371: EMPTY
86372: LIST
86373: LIST
86374: PUSH
86375: LD_INT 3
86377: NEG
86378: PUSH
86379: LD_INT 2
86381: NEG
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 3
86389: NEG
86390: PUSH
86391: LD_INT 3
86393: NEG
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: EMPTY
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: LIST
86415: LIST
86416: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86417: LD_ADDR_VAR 0 14
86421: PUSH
86422: LD_INT 0
86424: PUSH
86425: LD_INT 0
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: LD_INT 0
86434: PUSH
86435: LD_INT 1
86437: NEG
86438: PUSH
86439: EMPTY
86440: LIST
86441: LIST
86442: PUSH
86443: LD_INT 1
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 1
86455: PUSH
86456: LD_INT 1
86458: PUSH
86459: EMPTY
86460: LIST
86461: LIST
86462: PUSH
86463: LD_INT 0
86465: PUSH
86466: LD_INT 1
86468: PUSH
86469: EMPTY
86470: LIST
86471: LIST
86472: PUSH
86473: LD_INT 1
86475: NEG
86476: PUSH
86477: LD_INT 0
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: PUSH
86484: LD_INT 1
86486: NEG
86487: PUSH
86488: LD_INT 1
86490: NEG
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: PUSH
86496: LD_INT 1
86498: NEG
86499: PUSH
86500: LD_INT 2
86502: NEG
86503: PUSH
86504: EMPTY
86505: LIST
86506: LIST
86507: PUSH
86508: LD_INT 0
86510: PUSH
86511: LD_INT 2
86513: NEG
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 1
86521: PUSH
86522: LD_INT 1
86524: NEG
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 1
86532: PUSH
86533: LD_INT 2
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 0
86542: PUSH
86543: LD_INT 2
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: NEG
86553: PUSH
86554: LD_INT 1
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PUSH
86561: LD_INT 1
86563: NEG
86564: PUSH
86565: LD_INT 3
86567: NEG
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: LD_INT 3
86578: NEG
86579: PUSH
86580: EMPTY
86581: LIST
86582: LIST
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: LD_INT 2
86589: NEG
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: LIST
86599: LIST
86600: LIST
86601: LIST
86602: LIST
86603: LIST
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86613: LD_ADDR_VAR 0 15
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: LD_INT 0
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 0
86630: PUSH
86631: LD_INT 1
86633: NEG
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 1
86641: PUSH
86642: LD_INT 0
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: PUSH
86649: LD_INT 1
86651: PUSH
86652: LD_INT 1
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: PUSH
86659: LD_INT 0
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PUSH
86669: LD_INT 1
86671: NEG
86672: PUSH
86673: LD_INT 0
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 1
86682: NEG
86683: PUSH
86684: LD_INT 1
86686: NEG
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: LD_INT 1
86697: NEG
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 2
86705: PUSH
86706: LD_INT 0
86708: PUSH
86709: EMPTY
86710: LIST
86711: LIST
86712: PUSH
86713: LD_INT 2
86715: PUSH
86716: LD_INT 1
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: PUSH
86723: LD_INT 1
86725: NEG
86726: PUSH
86727: LD_INT 1
86729: PUSH
86730: EMPTY
86731: LIST
86732: LIST
86733: PUSH
86734: LD_INT 2
86736: NEG
86737: PUSH
86738: LD_INT 0
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 2
86747: NEG
86748: PUSH
86749: LD_INT 1
86751: NEG
86752: PUSH
86753: EMPTY
86754: LIST
86755: LIST
86756: PUSH
86757: LD_INT 2
86759: PUSH
86760: LD_INT 1
86762: NEG
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PUSH
86768: LD_INT 3
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 3
86780: PUSH
86781: LD_INT 1
86783: PUSH
86784: EMPTY
86785: LIST
86786: LIST
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86806: LD_ADDR_VAR 0 16
86810: PUSH
86811: LD_INT 0
86813: PUSH
86814: LD_INT 0
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 0
86823: PUSH
86824: LD_INT 1
86826: NEG
86827: PUSH
86828: EMPTY
86829: LIST
86830: LIST
86831: PUSH
86832: LD_INT 1
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: EMPTY
86839: LIST
86840: LIST
86841: PUSH
86842: LD_INT 1
86844: PUSH
86845: LD_INT 1
86847: PUSH
86848: EMPTY
86849: LIST
86850: LIST
86851: PUSH
86852: LD_INT 0
86854: PUSH
86855: LD_INT 1
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 1
86864: NEG
86865: PUSH
86866: LD_INT 0
86868: PUSH
86869: EMPTY
86870: LIST
86871: LIST
86872: PUSH
86873: LD_INT 1
86875: NEG
86876: PUSH
86877: LD_INT 1
86879: NEG
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 1
86887: NEG
86888: PUSH
86889: LD_INT 2
86891: NEG
86892: PUSH
86893: EMPTY
86894: LIST
86895: LIST
86896: PUSH
86897: LD_INT 2
86899: PUSH
86900: LD_INT 1
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 2
86909: PUSH
86910: LD_INT 2
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 1
86919: PUSH
86920: LD_INT 2
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PUSH
86927: LD_INT 2
86929: NEG
86930: PUSH
86931: LD_INT 1
86933: NEG
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: PUSH
86939: LD_INT 2
86941: NEG
86942: PUSH
86943: LD_INT 2
86945: NEG
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 3
86953: PUSH
86954: LD_INT 2
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 3
86963: PUSH
86964: LD_INT 3
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 2
86973: PUSH
86974: LD_INT 3
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86999: LD_ADDR_VAR 0 17
87003: PUSH
87004: LD_INT 0
87006: PUSH
87007: LD_INT 0
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 0
87016: PUSH
87017: LD_INT 1
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 1
87027: PUSH
87028: LD_INT 0
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 1
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 0
87047: PUSH
87048: LD_INT 1
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 1
87057: NEG
87058: PUSH
87059: LD_INT 0
87061: PUSH
87062: EMPTY
87063: LIST
87064: LIST
87065: PUSH
87066: LD_INT 1
87068: NEG
87069: PUSH
87070: LD_INT 1
87072: NEG
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 1
87080: NEG
87081: PUSH
87082: LD_INT 2
87084: NEG
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 0
87092: PUSH
87093: LD_INT 2
87095: NEG
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: PUSH
87101: LD_INT 1
87103: PUSH
87104: LD_INT 1
87106: NEG
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 2
87114: PUSH
87115: LD_INT 0
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 2
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 2
87134: PUSH
87135: LD_INT 2
87137: PUSH
87138: EMPTY
87139: LIST
87140: LIST
87141: PUSH
87142: LD_INT 1
87144: PUSH
87145: LD_INT 2
87147: PUSH
87148: EMPTY
87149: LIST
87150: LIST
87151: PUSH
87152: LD_INT 0
87154: PUSH
87155: LD_INT 2
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: LD_INT 1
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: PUSH
87173: LD_INT 2
87175: NEG
87176: PUSH
87177: LD_INT 0
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 2
87186: NEG
87187: PUSH
87188: LD_INT 1
87190: NEG
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 2
87198: NEG
87199: PUSH
87200: LD_INT 2
87202: NEG
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PUSH
87208: EMPTY
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87229: LD_ADDR_VAR 0 18
87233: PUSH
87234: LD_INT 0
87236: PUSH
87237: LD_INT 0
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: LD_INT 0
87246: PUSH
87247: LD_INT 1
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 0
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: LD_INT 1
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PUSH
87275: LD_INT 0
87277: PUSH
87278: LD_INT 1
87280: PUSH
87281: EMPTY
87282: LIST
87283: LIST
87284: PUSH
87285: LD_INT 1
87287: NEG
87288: PUSH
87289: LD_INT 0
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 1
87298: NEG
87299: PUSH
87300: LD_INT 1
87302: NEG
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 1
87310: NEG
87311: PUSH
87312: LD_INT 2
87314: NEG
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: LD_INT 2
87325: NEG
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PUSH
87331: LD_INT 1
87333: PUSH
87334: LD_INT 1
87336: NEG
87337: PUSH
87338: EMPTY
87339: LIST
87340: LIST
87341: PUSH
87342: LD_INT 2
87344: PUSH
87345: LD_INT 0
87347: PUSH
87348: EMPTY
87349: LIST
87350: LIST
87351: PUSH
87352: LD_INT 2
87354: PUSH
87355: LD_INT 1
87357: PUSH
87358: EMPTY
87359: LIST
87360: LIST
87361: PUSH
87362: LD_INT 2
87364: PUSH
87365: LD_INT 2
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PUSH
87372: LD_INT 1
87374: PUSH
87375: LD_INT 2
87377: PUSH
87378: EMPTY
87379: LIST
87380: LIST
87381: PUSH
87382: LD_INT 0
87384: PUSH
87385: LD_INT 2
87387: PUSH
87388: EMPTY
87389: LIST
87390: LIST
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: LD_INT 1
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PUSH
87403: LD_INT 2
87405: NEG
87406: PUSH
87407: LD_INT 0
87409: PUSH
87410: EMPTY
87411: LIST
87412: LIST
87413: PUSH
87414: LD_INT 2
87416: NEG
87417: PUSH
87418: LD_INT 1
87420: NEG
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: LD_INT 2
87428: NEG
87429: PUSH
87430: LD_INT 2
87432: NEG
87433: PUSH
87434: EMPTY
87435: LIST
87436: LIST
87437: PUSH
87438: EMPTY
87439: LIST
87440: LIST
87441: LIST
87442: LIST
87443: LIST
87444: LIST
87445: LIST
87446: LIST
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87459: LD_ADDR_VAR 0 19
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: LD_INT 0
87469: PUSH
87470: EMPTY
87471: LIST
87472: LIST
87473: PUSH
87474: LD_INT 0
87476: PUSH
87477: LD_INT 1
87479: NEG
87480: PUSH
87481: EMPTY
87482: LIST
87483: LIST
87484: PUSH
87485: LD_INT 1
87487: PUSH
87488: LD_INT 0
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 1
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 0
87507: PUSH
87508: LD_INT 1
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 1
87517: NEG
87518: PUSH
87519: LD_INT 0
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 1
87528: NEG
87529: PUSH
87530: LD_INT 1
87532: NEG
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: LD_INT 2
87544: NEG
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 0
87552: PUSH
87553: LD_INT 2
87555: NEG
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 1
87563: PUSH
87564: LD_INT 1
87566: NEG
87567: PUSH
87568: EMPTY
87569: LIST
87570: LIST
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: LD_INT 0
87577: PUSH
87578: EMPTY
87579: LIST
87580: LIST
87581: PUSH
87582: LD_INT 2
87584: PUSH
87585: LD_INT 1
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 2
87594: PUSH
87595: LD_INT 2
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 1
87604: PUSH
87605: LD_INT 2
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: LD_INT 0
87614: PUSH
87615: LD_INT 2
87617: PUSH
87618: EMPTY
87619: LIST
87620: LIST
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: LD_INT 1
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 2
87635: NEG
87636: PUSH
87637: LD_INT 0
87639: PUSH
87640: EMPTY
87641: LIST
87642: LIST
87643: PUSH
87644: LD_INT 2
87646: NEG
87647: PUSH
87648: LD_INT 1
87650: NEG
87651: PUSH
87652: EMPTY
87653: LIST
87654: LIST
87655: PUSH
87656: LD_INT 2
87658: NEG
87659: PUSH
87660: LD_INT 2
87662: NEG
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: LIST
87688: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87689: LD_ADDR_VAR 0 20
87693: PUSH
87694: LD_INT 0
87696: PUSH
87697: LD_INT 0
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 0
87706: PUSH
87707: LD_INT 1
87709: NEG
87710: PUSH
87711: EMPTY
87712: LIST
87713: LIST
87714: PUSH
87715: LD_INT 1
87717: PUSH
87718: LD_INT 0
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PUSH
87725: LD_INT 1
87727: PUSH
87728: LD_INT 1
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 0
87737: PUSH
87738: LD_INT 1
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 1
87747: NEG
87748: PUSH
87749: LD_INT 0
87751: PUSH
87752: EMPTY
87753: LIST
87754: LIST
87755: PUSH
87756: LD_INT 1
87758: NEG
87759: PUSH
87760: LD_INT 1
87762: NEG
87763: PUSH
87764: EMPTY
87765: LIST
87766: LIST
87767: PUSH
87768: LD_INT 1
87770: NEG
87771: PUSH
87772: LD_INT 2
87774: NEG
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 0
87782: PUSH
87783: LD_INT 2
87785: NEG
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 1
87793: PUSH
87794: LD_INT 1
87796: NEG
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 2
87804: PUSH
87805: LD_INT 0
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 2
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 2
87824: PUSH
87825: LD_INT 2
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 1
87834: PUSH
87835: LD_INT 2
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: PUSH
87842: LD_INT 0
87844: PUSH
87845: LD_INT 2
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 1
87854: NEG
87855: PUSH
87856: LD_INT 1
87858: PUSH
87859: EMPTY
87860: LIST
87861: LIST
87862: PUSH
87863: LD_INT 2
87865: NEG
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 2
87876: NEG
87877: PUSH
87878: LD_INT 1
87880: NEG
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: NEG
87889: PUSH
87890: LD_INT 2
87892: NEG
87893: PUSH
87894: EMPTY
87895: LIST
87896: LIST
87897: PUSH
87898: EMPTY
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87919: LD_ADDR_VAR 0 21
87923: PUSH
87924: LD_INT 0
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: EMPTY
87931: LIST
87932: LIST
87933: PUSH
87934: LD_INT 0
87936: PUSH
87937: LD_INT 1
87939: NEG
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: LD_INT 0
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: PUSH
87955: LD_INT 1
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: LD_INT 1
87970: PUSH
87971: EMPTY
87972: LIST
87973: LIST
87974: PUSH
87975: LD_INT 1
87977: NEG
87978: PUSH
87979: LD_INT 0
87981: PUSH
87982: EMPTY
87983: LIST
87984: LIST
87985: PUSH
87986: LD_INT 1
87988: NEG
87989: PUSH
87990: LD_INT 1
87992: NEG
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 1
88000: NEG
88001: PUSH
88002: LD_INT 2
88004: NEG
88005: PUSH
88006: EMPTY
88007: LIST
88008: LIST
88009: PUSH
88010: LD_INT 0
88012: PUSH
88013: LD_INT 2
88015: NEG
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 2
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 2
88044: PUSH
88045: LD_INT 1
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 2
88054: PUSH
88055: LD_INT 2
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 1
88064: PUSH
88065: LD_INT 2
88067: PUSH
88068: EMPTY
88069: LIST
88070: LIST
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: LD_INT 2
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: LD_INT 1
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: LD_INT 2
88095: NEG
88096: PUSH
88097: LD_INT 0
88099: PUSH
88100: EMPTY
88101: LIST
88102: LIST
88103: PUSH
88104: LD_INT 2
88106: NEG
88107: PUSH
88108: LD_INT 1
88110: NEG
88111: PUSH
88112: EMPTY
88113: LIST
88114: LIST
88115: PUSH
88116: LD_INT 2
88118: NEG
88119: PUSH
88120: LD_INT 2
88122: NEG
88123: PUSH
88124: EMPTY
88125: LIST
88126: LIST
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88149: LD_ADDR_VAR 0 22
88153: PUSH
88154: LD_INT 0
88156: PUSH
88157: LD_INT 0
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: LD_INT 1
88169: NEG
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: LD_INT 0
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 1
88187: PUSH
88188: LD_INT 1
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 0
88197: PUSH
88198: LD_INT 1
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: LD_INT 1
88207: NEG
88208: PUSH
88209: LD_INT 0
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 1
88218: NEG
88219: PUSH
88220: LD_INT 1
88222: NEG
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: PUSH
88228: LD_INT 1
88230: NEG
88231: PUSH
88232: LD_INT 2
88234: NEG
88235: PUSH
88236: EMPTY
88237: LIST
88238: LIST
88239: PUSH
88240: LD_INT 0
88242: PUSH
88243: LD_INT 2
88245: NEG
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 1
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 2
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 2
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 2
88284: PUSH
88285: LD_INT 2
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 1
88294: PUSH
88295: LD_INT 2
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 0
88304: PUSH
88305: LD_INT 2
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 1
88314: NEG
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 2
88325: NEG
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: LD_INT 2
88336: NEG
88337: PUSH
88338: LD_INT 1
88340: NEG
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 2
88348: NEG
88349: PUSH
88350: LD_INT 2
88352: NEG
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88379: LD_ADDR_VAR 0 23
88383: PUSH
88384: LD_INT 0
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: LD_INT 1
88399: NEG
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 1
88407: PUSH
88408: LD_INT 0
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 1
88417: PUSH
88418: LD_INT 1
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 0
88427: PUSH
88428: LD_INT 1
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: LD_INT 1
88437: NEG
88438: PUSH
88439: LD_INT 0
88441: PUSH
88442: EMPTY
88443: LIST
88444: LIST
88445: PUSH
88446: LD_INT 1
88448: NEG
88449: PUSH
88450: LD_INT 1
88452: NEG
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: PUSH
88458: LD_INT 1
88460: NEG
88461: PUSH
88462: LD_INT 2
88464: NEG
88465: PUSH
88466: EMPTY
88467: LIST
88468: LIST
88469: PUSH
88470: LD_INT 0
88472: PUSH
88473: LD_INT 2
88475: NEG
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 1
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 2
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 2
88514: PUSH
88515: LD_INT 2
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: PUSH
88525: LD_INT 2
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: LD_INT 0
88534: PUSH
88535: LD_INT 2
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: LD_INT 1
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 2
88555: NEG
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: EMPTY
88561: LIST
88562: LIST
88563: PUSH
88564: LD_INT 2
88566: NEG
88567: PUSH
88568: LD_INT 1
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 2
88578: NEG
88579: PUSH
88580: LD_INT 2
88582: NEG
88583: PUSH
88584: EMPTY
88585: LIST
88586: LIST
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: LD_INT 3
88594: NEG
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: NEG
88603: PUSH
88604: LD_INT 3
88606: NEG
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: PUSH
88612: LD_INT 1
88614: PUSH
88615: LD_INT 2
88617: NEG
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: PUSH
88623: LD_INT 2
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
88659: LD_ADDR_VAR 0 24
88663: PUSH
88664: LD_INT 0
88666: PUSH
88667: LD_INT 0
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 0
88676: PUSH
88677: LD_INT 1
88679: NEG
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: LD_INT 1
88687: PUSH
88688: LD_INT 0
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 1
88697: PUSH
88698: LD_INT 1
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: PUSH
88705: LD_INT 0
88707: PUSH
88708: LD_INT 1
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: PUSH
88715: LD_INT 1
88717: NEG
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: LD_INT 1
88728: NEG
88729: PUSH
88730: LD_INT 1
88732: NEG
88733: PUSH
88734: EMPTY
88735: LIST
88736: LIST
88737: PUSH
88738: LD_INT 1
88740: NEG
88741: PUSH
88742: LD_INT 2
88744: NEG
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PUSH
88750: LD_INT 0
88752: PUSH
88753: LD_INT 2
88755: NEG
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 1
88763: PUSH
88764: LD_INT 1
88766: NEG
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 2
88774: PUSH
88775: LD_INT 0
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 2
88784: PUSH
88785: LD_INT 1
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 2
88794: PUSH
88795: LD_INT 2
88797: PUSH
88798: EMPTY
88799: LIST
88800: LIST
88801: PUSH
88802: LD_INT 1
88804: PUSH
88805: LD_INT 2
88807: PUSH
88808: EMPTY
88809: LIST
88810: LIST
88811: PUSH
88812: LD_INT 0
88814: PUSH
88815: LD_INT 2
88817: PUSH
88818: EMPTY
88819: LIST
88820: LIST
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: LD_INT 1
88828: PUSH
88829: EMPTY
88830: LIST
88831: LIST
88832: PUSH
88833: LD_INT 2
88835: NEG
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 2
88846: NEG
88847: PUSH
88848: LD_INT 1
88850: NEG
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 2
88858: NEG
88859: PUSH
88860: LD_INT 2
88862: NEG
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 1
88870: PUSH
88871: LD_INT 2
88873: NEG
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 2
88881: PUSH
88882: LD_INT 1
88884: NEG
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 3
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 3
88902: PUSH
88903: LD_INT 2
88905: PUSH
88906: EMPTY
88907: LIST
88908: LIST
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: LIST
88926: LIST
88927: LIST
88928: LIST
88929: LIST
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88935: LD_ADDR_VAR 0 25
88939: PUSH
88940: LD_INT 0
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: LD_INT 1
88955: NEG
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 1
88963: PUSH
88964: LD_INT 0
88966: PUSH
88967: EMPTY
88968: LIST
88969: LIST
88970: PUSH
88971: LD_INT 1
88973: PUSH
88974: LD_INT 1
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: LD_INT 1
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: LD_INT 0
88997: PUSH
88998: EMPTY
88999: LIST
89000: LIST
89001: PUSH
89002: LD_INT 1
89004: NEG
89005: PUSH
89006: LD_INT 1
89008: NEG
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 1
89016: NEG
89017: PUSH
89018: LD_INT 2
89020: NEG
89021: PUSH
89022: EMPTY
89023: LIST
89024: LIST
89025: PUSH
89026: LD_INT 0
89028: PUSH
89029: LD_INT 2
89031: NEG
89032: PUSH
89033: EMPTY
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 1
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: PUSH
89048: LD_INT 2
89050: PUSH
89051: LD_INT 0
89053: PUSH
89054: EMPTY
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 2
89060: PUSH
89061: LD_INT 1
89063: PUSH
89064: EMPTY
89065: LIST
89066: LIST
89067: PUSH
89068: LD_INT 2
89070: PUSH
89071: LD_INT 2
89073: PUSH
89074: EMPTY
89075: LIST
89076: LIST
89077: PUSH
89078: LD_INT 1
89080: PUSH
89081: LD_INT 2
89083: PUSH
89084: EMPTY
89085: LIST
89086: LIST
89087: PUSH
89088: LD_INT 0
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PUSH
89098: LD_INT 1
89100: NEG
89101: PUSH
89102: LD_INT 1
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: PUSH
89109: LD_INT 2
89111: NEG
89112: PUSH
89113: LD_INT 0
89115: PUSH
89116: EMPTY
89117: LIST
89118: LIST
89119: PUSH
89120: LD_INT 2
89122: NEG
89123: PUSH
89124: LD_INT 1
89126: NEG
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 2
89134: NEG
89135: PUSH
89136: LD_INT 2
89138: NEG
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: LD_INT 3
89146: PUSH
89147: LD_INT 1
89149: PUSH
89150: EMPTY
89151: LIST
89152: LIST
89153: PUSH
89154: LD_INT 3
89156: PUSH
89157: LD_INT 2
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 2
89166: PUSH
89167: LD_INT 3
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: PUSH
89174: LD_INT 1
89176: PUSH
89177: LD_INT 3
89179: PUSH
89180: EMPTY
89181: LIST
89182: LIST
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: LIST
89188: LIST
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89209: LD_ADDR_VAR 0 26
89213: PUSH
89214: LD_INT 0
89216: PUSH
89217: LD_INT 0
89219: PUSH
89220: EMPTY
89221: LIST
89222: LIST
89223: PUSH
89224: LD_INT 0
89226: PUSH
89227: LD_INT 1
89229: NEG
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: LD_INT 1
89237: PUSH
89238: LD_INT 0
89240: PUSH
89241: EMPTY
89242: LIST
89243: LIST
89244: PUSH
89245: LD_INT 1
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: EMPTY
89252: LIST
89253: LIST
89254: PUSH
89255: LD_INT 0
89257: PUSH
89258: LD_INT 1
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 1
89267: NEG
89268: PUSH
89269: LD_INT 0
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: LD_INT 1
89282: NEG
89283: PUSH
89284: EMPTY
89285: LIST
89286: LIST
89287: PUSH
89288: LD_INT 1
89290: NEG
89291: PUSH
89292: LD_INT 2
89294: NEG
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 0
89302: PUSH
89303: LD_INT 2
89305: NEG
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: PUSH
89314: LD_INT 1
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: LD_INT 2
89324: PUSH
89325: LD_INT 0
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: PUSH
89332: LD_INT 2
89334: PUSH
89335: LD_INT 1
89337: PUSH
89338: EMPTY
89339: LIST
89340: LIST
89341: PUSH
89342: LD_INT 2
89344: PUSH
89345: LD_INT 2
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: PUSH
89352: LD_INT 1
89354: PUSH
89355: LD_INT 2
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: PUSH
89362: LD_INT 0
89364: PUSH
89365: LD_INT 2
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 1
89374: NEG
89375: PUSH
89376: LD_INT 1
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 2
89385: NEG
89386: PUSH
89387: LD_INT 0
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: LD_INT 2
89396: NEG
89397: PUSH
89398: LD_INT 1
89400: NEG
89401: PUSH
89402: EMPTY
89403: LIST
89404: LIST
89405: PUSH
89406: LD_INT 2
89408: NEG
89409: PUSH
89410: LD_INT 2
89412: NEG
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: PUSH
89418: LD_INT 2
89420: PUSH
89421: LD_INT 3
89423: PUSH
89424: EMPTY
89425: LIST
89426: LIST
89427: PUSH
89428: LD_INT 1
89430: PUSH
89431: LD_INT 3
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 1
89440: NEG
89441: PUSH
89442: LD_INT 2
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 2
89451: NEG
89452: PUSH
89453: LD_INT 1
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89485: LD_ADDR_VAR 0 27
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 0
89502: PUSH
89503: LD_INT 1
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: LD_INT 1
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 0
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: LD_INT 2
89570: NEG
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: LD_INT 2
89581: NEG
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: LD_INT 1
89589: PUSH
89590: LD_INT 1
89592: NEG
89593: PUSH
89594: EMPTY
89595: LIST
89596: LIST
89597: PUSH
89598: LD_INT 2
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: EMPTY
89605: LIST
89606: LIST
89607: PUSH
89608: LD_INT 2
89610: PUSH
89611: LD_INT 1
89613: PUSH
89614: EMPTY
89615: LIST
89616: LIST
89617: PUSH
89618: LD_INT 2
89620: PUSH
89621: LD_INT 2
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 1
89630: PUSH
89631: LD_INT 2
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 0
89640: PUSH
89641: LD_INT 2
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 1
89650: NEG
89651: PUSH
89652: LD_INT 1
89654: PUSH
89655: EMPTY
89656: LIST
89657: LIST
89658: PUSH
89659: LD_INT 2
89661: NEG
89662: PUSH
89663: LD_INT 0
89665: PUSH
89666: EMPTY
89667: LIST
89668: LIST
89669: PUSH
89670: LD_INT 2
89672: NEG
89673: PUSH
89674: LD_INT 1
89676: NEG
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: LD_INT 2
89684: NEG
89685: PUSH
89686: LD_INT 2
89688: NEG
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: PUSH
89694: LD_INT 1
89696: NEG
89697: PUSH
89698: LD_INT 2
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: PUSH
89705: LD_INT 2
89707: NEG
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: PUSH
89716: LD_INT 3
89718: NEG
89719: PUSH
89720: LD_INT 1
89722: NEG
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 3
89730: NEG
89731: PUSH
89732: LD_INT 2
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: LIST
89744: LIST
89745: LIST
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89765: LD_ADDR_VAR 0 28
89769: PUSH
89770: LD_INT 0
89772: PUSH
89773: LD_INT 0
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 0
89782: PUSH
89783: LD_INT 1
89785: NEG
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 1
89793: PUSH
89794: LD_INT 0
89796: PUSH
89797: EMPTY
89798: LIST
89799: LIST
89800: PUSH
89801: LD_INT 1
89803: PUSH
89804: LD_INT 1
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: LD_INT 1
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 1
89823: NEG
89824: PUSH
89825: LD_INT 0
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 1
89834: NEG
89835: PUSH
89836: LD_INT 1
89838: NEG
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: PUSH
89844: LD_INT 1
89846: NEG
89847: PUSH
89848: LD_INT 2
89850: NEG
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: LD_INT 2
89861: NEG
89862: PUSH
89863: EMPTY
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 1
89869: PUSH
89870: LD_INT 1
89872: NEG
89873: PUSH
89874: EMPTY
89875: LIST
89876: LIST
89877: PUSH
89878: LD_INT 2
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 2
89890: PUSH
89891: LD_INT 1
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 2
89900: PUSH
89901: LD_INT 2
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PUSH
89908: LD_INT 1
89910: PUSH
89911: LD_INT 2
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PUSH
89918: LD_INT 0
89920: PUSH
89921: LD_INT 2
89923: PUSH
89924: EMPTY
89925: LIST
89926: LIST
89927: PUSH
89928: LD_INT 1
89930: NEG
89931: PUSH
89932: LD_INT 1
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 2
89941: NEG
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 2
89952: NEG
89953: PUSH
89954: LD_INT 1
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 2
89964: NEG
89965: PUSH
89966: LD_INT 2
89968: NEG
89969: PUSH
89970: EMPTY
89971: LIST
89972: LIST
89973: PUSH
89974: LD_INT 2
89976: NEG
89977: PUSH
89978: LD_INT 3
89980: NEG
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: LD_INT 3
89992: NEG
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PUSH
89998: LD_INT 3
90000: NEG
90001: PUSH
90002: LD_INT 1
90004: NEG
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 3
90012: NEG
90013: PUSH
90014: LD_INT 2
90016: NEG
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: EMPTY
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90047: LD_ADDR_VAR 0 29
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 0
90064: PUSH
90065: LD_INT 1
90067: NEG
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: PUSH
90073: LD_INT 1
90075: PUSH
90076: LD_INT 0
90078: PUSH
90079: EMPTY
90080: LIST
90081: LIST
90082: PUSH
90083: LD_INT 1
90085: PUSH
90086: LD_INT 1
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 0
90095: PUSH
90096: LD_INT 1
90098: PUSH
90099: EMPTY
90100: LIST
90101: LIST
90102: PUSH
90103: LD_INT 1
90105: NEG
90106: PUSH
90107: LD_INT 0
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: PUSH
90114: LD_INT 1
90116: NEG
90117: PUSH
90118: LD_INT 1
90120: NEG
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 1
90128: NEG
90129: PUSH
90130: LD_INT 2
90132: NEG
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 0
90140: PUSH
90141: LD_INT 2
90143: NEG
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: PUSH
90149: LD_INT 1
90151: PUSH
90152: LD_INT 1
90154: NEG
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: PUSH
90160: LD_INT 2
90162: PUSH
90163: LD_INT 0
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PUSH
90170: LD_INT 2
90172: PUSH
90173: LD_INT 1
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PUSH
90180: LD_INT 1
90182: PUSH
90183: LD_INT 2
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 0
90192: PUSH
90193: LD_INT 2
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 1
90202: NEG
90203: PUSH
90204: LD_INT 1
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 2
90213: NEG
90214: PUSH
90215: LD_INT 1
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: NEG
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 2
90237: NEG
90238: PUSH
90239: LD_INT 3
90241: NEG
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: LD_INT 2
90249: PUSH
90250: LD_INT 1
90252: NEG
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 3
90260: PUSH
90261: LD_INT 1
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: LD_INT 3
90273: PUSH
90274: EMPTY
90275: LIST
90276: LIST
90277: PUSH
90278: LD_INT 1
90280: NEG
90281: PUSH
90282: LD_INT 2
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 3
90291: NEG
90292: PUSH
90293: LD_INT 2
90295: NEG
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90326: LD_ADDR_VAR 0 30
90330: PUSH
90331: LD_INT 0
90333: PUSH
90334: LD_INT 0
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 0
90343: PUSH
90344: LD_INT 1
90346: NEG
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: PUSH
90355: LD_INT 0
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 1
90364: PUSH
90365: LD_INT 1
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 0
90374: PUSH
90375: LD_INT 1
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 1
90384: NEG
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: PUSH
90393: LD_INT 1
90395: NEG
90396: PUSH
90397: LD_INT 1
90399: NEG
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: PUSH
90405: LD_INT 1
90407: NEG
90408: PUSH
90409: LD_INT 2
90411: NEG
90412: PUSH
90413: EMPTY
90414: LIST
90415: LIST
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: LD_INT 2
90422: NEG
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: PUSH
90428: LD_INT 1
90430: PUSH
90431: LD_INT 1
90433: NEG
90434: PUSH
90435: EMPTY
90436: LIST
90437: LIST
90438: PUSH
90439: LD_INT 2
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: EMPTY
90446: LIST
90447: LIST
90448: PUSH
90449: LD_INT 2
90451: PUSH
90452: LD_INT 1
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 2
90461: PUSH
90462: LD_INT 2
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: LD_INT 1
90471: PUSH
90472: LD_INT 2
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: LD_INT 1
90481: NEG
90482: PUSH
90483: LD_INT 1
90485: PUSH
90486: EMPTY
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 2
90492: NEG
90493: PUSH
90494: LD_INT 0
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 2
90503: NEG
90504: PUSH
90505: LD_INT 1
90507: NEG
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: LD_INT 1
90515: NEG
90516: PUSH
90517: LD_INT 3
90519: NEG
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: LD_INT 2
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 3
90538: PUSH
90539: LD_INT 2
90541: PUSH
90542: EMPTY
90543: LIST
90544: LIST
90545: PUSH
90546: LD_INT 2
90548: PUSH
90549: LD_INT 3
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: PUSH
90556: LD_INT 2
90558: NEG
90559: PUSH
90560: LD_INT 1
90562: PUSH
90563: EMPTY
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 3
90569: NEG
90570: PUSH
90571: LD_INT 1
90573: NEG
90574: PUSH
90575: EMPTY
90576: LIST
90577: LIST
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: LIST
90599: LIST
90600: LIST
90601: LIST
90602: LIST
90603: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90604: LD_ADDR_VAR 0 31
90608: PUSH
90609: LD_INT 0
90611: PUSH
90612: LD_INT 0
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: LD_INT 1
90624: NEG
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 1
90632: PUSH
90633: LD_INT 0
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: PUSH
90640: LD_INT 1
90642: PUSH
90643: LD_INT 1
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 0
90652: PUSH
90653: LD_INT 1
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 1
90662: NEG
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 1
90673: NEG
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 1
90685: NEG
90686: PUSH
90687: LD_INT 2
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: LD_INT 1
90697: PUSH
90698: LD_INT 1
90700: NEG
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 2
90708: PUSH
90709: LD_INT 0
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 2
90718: PUSH
90719: LD_INT 1
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: LD_INT 2
90728: PUSH
90729: LD_INT 2
90731: PUSH
90732: EMPTY
90733: LIST
90734: LIST
90735: PUSH
90736: LD_INT 1
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: EMPTY
90743: LIST
90744: LIST
90745: PUSH
90746: LD_INT 0
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: PUSH
90756: LD_INT 1
90758: NEG
90759: PUSH
90760: LD_INT 1
90762: PUSH
90763: EMPTY
90764: LIST
90765: LIST
90766: PUSH
90767: LD_INT 2
90769: NEG
90770: PUSH
90771: LD_INT 1
90773: NEG
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 2
90781: NEG
90782: PUSH
90783: LD_INT 2
90785: NEG
90786: PUSH
90787: EMPTY
90788: LIST
90789: LIST
90790: PUSH
90791: LD_INT 2
90793: NEG
90794: PUSH
90795: LD_INT 3
90797: NEG
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 2
90805: PUSH
90806: LD_INT 1
90808: NEG
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 3
90816: PUSH
90817: LD_INT 1
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 1
90826: PUSH
90827: LD_INT 3
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 1
90836: NEG
90837: PUSH
90838: LD_INT 2
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 3
90847: NEG
90848: PUSH
90849: LD_INT 2
90851: NEG
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90882: LD_ADDR_VAR 0 32
90886: PUSH
90887: LD_INT 0
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 0
90899: PUSH
90900: LD_INT 1
90902: NEG
90903: PUSH
90904: EMPTY
90905: LIST
90906: LIST
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: LD_INT 0
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 1
90920: PUSH
90921: LD_INT 1
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 0
90930: PUSH
90931: LD_INT 1
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 1
90940: NEG
90941: PUSH
90942: LD_INT 0
90944: PUSH
90945: EMPTY
90946: LIST
90947: LIST
90948: PUSH
90949: LD_INT 1
90951: NEG
90952: PUSH
90953: LD_INT 1
90955: NEG
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 1
90963: NEG
90964: PUSH
90965: LD_INT 2
90967: NEG
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: LD_INT 0
90975: PUSH
90976: LD_INT 2
90978: NEG
90979: PUSH
90980: EMPTY
90981: LIST
90982: LIST
90983: PUSH
90984: LD_INT 1
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 2
90997: PUSH
90998: LD_INT 1
91000: PUSH
91001: EMPTY
91002: LIST
91003: LIST
91004: PUSH
91005: LD_INT 2
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: EMPTY
91012: LIST
91013: LIST
91014: PUSH
91015: LD_INT 1
91017: PUSH
91018: LD_INT 2
91020: PUSH
91021: EMPTY
91022: LIST
91023: LIST
91024: PUSH
91025: LD_INT 0
91027: PUSH
91028: LD_INT 2
91030: PUSH
91031: EMPTY
91032: LIST
91033: LIST
91034: PUSH
91035: LD_INT 1
91037: NEG
91038: PUSH
91039: LD_INT 1
91041: PUSH
91042: EMPTY
91043: LIST
91044: LIST
91045: PUSH
91046: LD_INT 2
91048: NEG
91049: PUSH
91050: LD_INT 0
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 2
91059: NEG
91060: PUSH
91061: LD_INT 1
91063: NEG
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 1
91071: NEG
91072: PUSH
91073: LD_INT 3
91075: NEG
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 1
91083: PUSH
91084: LD_INT 2
91086: NEG
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: PUSH
91092: LD_INT 3
91094: PUSH
91095: LD_INT 2
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: LD_INT 2
91104: PUSH
91105: LD_INT 3
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 2
91114: NEG
91115: PUSH
91116: LD_INT 1
91118: PUSH
91119: EMPTY
91120: LIST
91121: LIST
91122: PUSH
91123: LD_INT 3
91125: NEG
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: LIST
91157: LIST
91158: LIST
91159: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
91160: LD_ADDR_VAR 0 33
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: LD_INT 0
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: PUSH
91175: LD_INT 0
91177: PUSH
91178: LD_INT 1
91180: NEG
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 1
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 1
91198: PUSH
91199: LD_INT 1
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 0
91208: PUSH
91209: LD_INT 1
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: LD_INT 1
91218: NEG
91219: PUSH
91220: LD_INT 0
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 1
91229: NEG
91230: PUSH
91231: LD_INT 1
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 1
91241: NEG
91242: PUSH
91243: LD_INT 2
91245: NEG
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 1
91253: PUSH
91254: LD_INT 1
91256: NEG
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: PUSH
91262: LD_INT 2
91264: PUSH
91265: LD_INT 0
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 2
91274: PUSH
91275: LD_INT 1
91277: PUSH
91278: EMPTY
91279: LIST
91280: LIST
91281: PUSH
91282: LD_INT 1
91284: PUSH
91285: LD_INT 2
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: PUSH
91292: LD_INT 0
91294: PUSH
91295: LD_INT 2
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 1
91304: NEG
91305: PUSH
91306: LD_INT 1
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PUSH
91313: LD_INT 2
91315: NEG
91316: PUSH
91317: LD_INT 0
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: LD_INT 2
91326: NEG
91327: PUSH
91328: LD_INT 1
91330: NEG
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 2
91338: NEG
91339: PUSH
91340: LD_INT 2
91342: NEG
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: PUSH
91348: LD_INT 2
91350: NEG
91351: PUSH
91352: LD_INT 3
91354: NEG
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 2
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 3
91373: PUSH
91374: LD_INT 1
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: LD_INT 3
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: LD_INT 1
91393: NEG
91394: PUSH
91395: LD_INT 2
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: LD_INT 3
91404: NEG
91405: PUSH
91406: LD_INT 2
91408: NEG
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91439: LD_ADDR_VAR 0 34
91443: PUSH
91444: LD_INT 0
91446: PUSH
91447: LD_INT 0
91449: PUSH
91450: EMPTY
91451: LIST
91452: LIST
91453: PUSH
91454: LD_INT 0
91456: PUSH
91457: LD_INT 1
91459: NEG
91460: PUSH
91461: EMPTY
91462: LIST
91463: LIST
91464: PUSH
91465: LD_INT 1
91467: PUSH
91468: LD_INT 0
91470: PUSH
91471: EMPTY
91472: LIST
91473: LIST
91474: PUSH
91475: LD_INT 1
91477: PUSH
91478: LD_INT 1
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: PUSH
91485: LD_INT 0
91487: PUSH
91488: LD_INT 1
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: PUSH
91495: LD_INT 1
91497: NEG
91498: PUSH
91499: LD_INT 0
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: LD_INT 1
91508: NEG
91509: PUSH
91510: LD_INT 1
91512: NEG
91513: PUSH
91514: EMPTY
91515: LIST
91516: LIST
91517: PUSH
91518: LD_INT 1
91520: NEG
91521: PUSH
91522: LD_INT 2
91524: NEG
91525: PUSH
91526: EMPTY
91527: LIST
91528: LIST
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: LD_INT 2
91535: NEG
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 1
91543: PUSH
91544: LD_INT 1
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 2
91554: PUSH
91555: LD_INT 1
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 2
91564: PUSH
91565: LD_INT 2
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 1
91574: PUSH
91575: LD_INT 2
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: LD_INT 1
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 2
91595: NEG
91596: PUSH
91597: LD_INT 0
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 2
91606: NEG
91607: PUSH
91608: LD_INT 1
91610: NEG
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: PUSH
91616: LD_INT 2
91618: NEG
91619: PUSH
91620: LD_INT 2
91622: NEG
91623: PUSH
91624: EMPTY
91625: LIST
91626: LIST
91627: PUSH
91628: LD_INT 1
91630: NEG
91631: PUSH
91632: LD_INT 3
91634: NEG
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: PUSH
91643: LD_INT 2
91645: NEG
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 3
91653: PUSH
91654: LD_INT 2
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 2
91663: PUSH
91664: LD_INT 3
91666: PUSH
91667: EMPTY
91668: LIST
91669: LIST
91670: PUSH
91671: LD_INT 2
91673: NEG
91674: PUSH
91675: LD_INT 1
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 3
91684: NEG
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91719: LD_ADDR_VAR 0 35
91723: PUSH
91724: LD_INT 0
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 0
91736: PUSH
91737: LD_INT 1
91739: NEG
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: LD_INT 1
91747: PUSH
91748: LD_INT 0
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: LD_INT 1
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 0
91767: PUSH
91768: LD_INT 1
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 1
91777: NEG
91778: PUSH
91779: LD_INT 0
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: PUSH
91786: LD_INT 1
91788: NEG
91789: PUSH
91790: LD_INT 1
91792: NEG
91793: PUSH
91794: EMPTY
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 2
91800: PUSH
91801: LD_INT 1
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: PUSH
91808: LD_INT 2
91810: NEG
91811: PUSH
91812: LD_INT 1
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: EMPTY
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: LIST
91826: LIST
91827: LIST
91828: LIST
91829: LIST
91830: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91831: LD_ADDR_VAR 0 36
91835: PUSH
91836: LD_INT 0
91838: PUSH
91839: LD_INT 0
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 0
91848: PUSH
91849: LD_INT 1
91851: NEG
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: PUSH
91857: LD_INT 1
91859: PUSH
91860: LD_INT 0
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: PUSH
91867: LD_INT 1
91869: PUSH
91870: LD_INT 1
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 0
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 1
91889: NEG
91890: PUSH
91891: LD_INT 0
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 1
91900: NEG
91901: PUSH
91902: LD_INT 1
91904: NEG
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 1
91912: NEG
91913: PUSH
91914: LD_INT 2
91916: NEG
91917: PUSH
91918: EMPTY
91919: LIST
91920: LIST
91921: PUSH
91922: LD_INT 1
91924: PUSH
91925: LD_INT 2
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: LIST
91936: LIST
91937: LIST
91938: LIST
91939: LIST
91940: LIST
91941: LIST
91942: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
91943: LD_ADDR_VAR 0 37
91947: PUSH
91948: LD_INT 0
91950: PUSH
91951: LD_INT 0
91953: PUSH
91954: EMPTY
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 0
91960: PUSH
91961: LD_INT 1
91963: NEG
91964: PUSH
91965: EMPTY
91966: LIST
91967: LIST
91968: PUSH
91969: LD_INT 1
91971: PUSH
91972: LD_INT 0
91974: PUSH
91975: EMPTY
91976: LIST
91977: LIST
91978: PUSH
91979: LD_INT 1
91981: PUSH
91982: LD_INT 1
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 0
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: LD_INT 1
92001: NEG
92002: PUSH
92003: LD_INT 0
92005: PUSH
92006: EMPTY
92007: LIST
92008: LIST
92009: PUSH
92010: LD_INT 1
92012: NEG
92013: PUSH
92014: LD_INT 1
92016: NEG
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: PUSH
92022: LD_INT 1
92024: PUSH
92025: LD_INT 1
92027: NEG
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: EMPTY
92041: LIST
92042: LIST
92043: PUSH
92044: EMPTY
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
92055: LD_ADDR_VAR 0 38
92059: PUSH
92060: LD_INT 0
92062: PUSH
92063: LD_INT 0
92065: PUSH
92066: EMPTY
92067: LIST
92068: LIST
92069: PUSH
92070: LD_INT 0
92072: PUSH
92073: LD_INT 1
92075: NEG
92076: PUSH
92077: EMPTY
92078: LIST
92079: LIST
92080: PUSH
92081: LD_INT 1
92083: PUSH
92084: LD_INT 0
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 1
92093: PUSH
92094: LD_INT 1
92096: PUSH
92097: EMPTY
92098: LIST
92099: LIST
92100: PUSH
92101: LD_INT 0
92103: PUSH
92104: LD_INT 1
92106: PUSH
92107: EMPTY
92108: LIST
92109: LIST
92110: PUSH
92111: LD_INT 1
92113: NEG
92114: PUSH
92115: LD_INT 0
92117: PUSH
92118: EMPTY
92119: LIST
92120: LIST
92121: PUSH
92122: LD_INT 1
92124: NEG
92125: PUSH
92126: LD_INT 1
92128: NEG
92129: PUSH
92130: EMPTY
92131: LIST
92132: LIST
92133: PUSH
92134: LD_INT 2
92136: PUSH
92137: LD_INT 1
92139: PUSH
92140: EMPTY
92141: LIST
92142: LIST
92143: PUSH
92144: LD_INT 2
92146: NEG
92147: PUSH
92148: LD_INT 1
92150: NEG
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PUSH
92156: EMPTY
92157: LIST
92158: LIST
92159: LIST
92160: LIST
92161: LIST
92162: LIST
92163: LIST
92164: LIST
92165: LIST
92166: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
92167: LD_ADDR_VAR 0 39
92171: PUSH
92172: LD_INT 0
92174: PUSH
92175: LD_INT 0
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 0
92184: PUSH
92185: LD_INT 1
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 1
92195: PUSH
92196: LD_INT 0
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 1
92205: PUSH
92206: LD_INT 1
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 0
92215: PUSH
92216: LD_INT 1
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 1
92225: NEG
92226: PUSH
92227: LD_INT 0
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 1
92236: NEG
92237: PUSH
92238: LD_INT 1
92240: NEG
92241: PUSH
92242: EMPTY
92243: LIST
92244: LIST
92245: PUSH
92246: LD_INT 1
92248: NEG
92249: PUSH
92250: LD_INT 2
92252: NEG
92253: PUSH
92254: EMPTY
92255: LIST
92256: LIST
92257: PUSH
92258: LD_INT 1
92260: PUSH
92261: LD_INT 2
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: PUSH
92268: EMPTY
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
92279: LD_ADDR_VAR 0 40
92283: PUSH
92284: LD_INT 0
92286: PUSH
92287: LD_INT 0
92289: PUSH
92290: EMPTY
92291: LIST
92292: LIST
92293: PUSH
92294: LD_INT 0
92296: PUSH
92297: LD_INT 1
92299: NEG
92300: PUSH
92301: EMPTY
92302: LIST
92303: LIST
92304: PUSH
92305: LD_INT 1
92307: PUSH
92308: LD_INT 0
92310: PUSH
92311: EMPTY
92312: LIST
92313: LIST
92314: PUSH
92315: LD_INT 1
92317: PUSH
92318: LD_INT 1
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PUSH
92325: LD_INT 0
92327: PUSH
92328: LD_INT 1
92330: PUSH
92331: EMPTY
92332: LIST
92333: LIST
92334: PUSH
92335: LD_INT 1
92337: NEG
92338: PUSH
92339: LD_INT 0
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 1
92348: NEG
92349: PUSH
92350: LD_INT 1
92352: NEG
92353: PUSH
92354: EMPTY
92355: LIST
92356: LIST
92357: PUSH
92358: LD_INT 1
92360: PUSH
92361: LD_INT 1
92363: NEG
92364: PUSH
92365: EMPTY
92366: LIST
92367: LIST
92368: PUSH
92369: LD_INT 1
92371: NEG
92372: PUSH
92373: LD_INT 1
92375: PUSH
92376: EMPTY
92377: LIST
92378: LIST
92379: PUSH
92380: EMPTY
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92391: LD_ADDR_VAR 0 41
92395: PUSH
92396: LD_INT 0
92398: PUSH
92399: LD_INT 0
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 0
92408: PUSH
92409: LD_INT 1
92411: NEG
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 1
92419: PUSH
92420: LD_INT 0
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 1
92429: PUSH
92430: LD_INT 1
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: LD_INT 1
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 1
92449: NEG
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: NEG
92461: PUSH
92462: LD_INT 1
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 1
92472: NEG
92473: PUSH
92474: LD_INT 2
92476: NEG
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 1
92484: PUSH
92485: LD_INT 1
92487: NEG
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: PUSH
92493: LD_INT 2
92495: PUSH
92496: LD_INT 0
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PUSH
92503: LD_INT 2
92505: PUSH
92506: LD_INT 1
92508: PUSH
92509: EMPTY
92510: LIST
92511: LIST
92512: PUSH
92513: LD_INT 2
92515: PUSH
92516: LD_INT 2
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 1
92525: PUSH
92526: LD_INT 2
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: PUSH
92533: LD_INT 1
92535: NEG
92536: PUSH
92537: LD_INT 1
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: PUSH
92544: LD_INT 2
92546: NEG
92547: PUSH
92548: LD_INT 0
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PUSH
92555: LD_INT 2
92557: NEG
92558: PUSH
92559: LD_INT 1
92561: NEG
92562: PUSH
92563: EMPTY
92564: LIST
92565: LIST
92566: PUSH
92567: LD_INT 2
92569: NEG
92570: PUSH
92571: LD_INT 2
92573: NEG
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: PUSH
92579: LD_INT 2
92581: NEG
92582: PUSH
92583: LD_INT 3
92585: NEG
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: LD_INT 1
92596: NEG
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: PUSH
92602: LD_INT 3
92604: PUSH
92605: LD_INT 0
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: PUSH
92612: LD_INT 3
92614: PUSH
92615: LD_INT 1
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 3
92624: PUSH
92625: LD_INT 2
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 3
92634: PUSH
92635: LD_INT 3
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 2
92644: PUSH
92645: LD_INT 3
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 2
92654: NEG
92655: PUSH
92656: LD_INT 1
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 3
92665: NEG
92666: PUSH
92667: LD_INT 0
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 3
92676: NEG
92677: PUSH
92678: LD_INT 1
92680: NEG
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 3
92688: NEG
92689: PUSH
92690: LD_INT 2
92692: NEG
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 3
92700: NEG
92701: PUSH
92702: LD_INT 3
92704: NEG
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: EMPTY
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92741: LD_ADDR_VAR 0 42
92745: PUSH
92746: LD_INT 0
92748: PUSH
92749: LD_INT 0
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 0
92758: PUSH
92759: LD_INT 1
92761: NEG
92762: PUSH
92763: EMPTY
92764: LIST
92765: LIST
92766: PUSH
92767: LD_INT 1
92769: PUSH
92770: LD_INT 0
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 1
92779: PUSH
92780: LD_INT 1
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 0
92789: PUSH
92790: LD_INT 1
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 1
92799: NEG
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 1
92810: NEG
92811: PUSH
92812: LD_INT 1
92814: NEG
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: PUSH
92820: LD_INT 1
92822: NEG
92823: PUSH
92824: LD_INT 2
92826: NEG
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 0
92834: PUSH
92835: LD_INT 2
92837: NEG
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 1
92845: PUSH
92846: LD_INT 1
92848: NEG
92849: PUSH
92850: EMPTY
92851: LIST
92852: LIST
92853: PUSH
92854: LD_INT 2
92856: PUSH
92857: LD_INT 1
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: PUSH
92864: LD_INT 2
92866: PUSH
92867: LD_INT 2
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: PUSH
92874: LD_INT 1
92876: PUSH
92877: LD_INT 2
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 0
92886: PUSH
92887: LD_INT 2
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 1
92896: NEG
92897: PUSH
92898: LD_INT 1
92900: PUSH
92901: EMPTY
92902: LIST
92903: LIST
92904: PUSH
92905: LD_INT 2
92907: NEG
92908: PUSH
92909: LD_INT 1
92911: NEG
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 2
92919: NEG
92920: PUSH
92921: LD_INT 2
92923: NEG
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 2
92931: NEG
92932: PUSH
92933: LD_INT 3
92935: NEG
92936: PUSH
92937: EMPTY
92938: LIST
92939: LIST
92940: PUSH
92941: LD_INT 1
92943: NEG
92944: PUSH
92945: LD_INT 3
92947: NEG
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 0
92955: PUSH
92956: LD_INT 3
92958: NEG
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 1
92966: PUSH
92967: LD_INT 2
92969: NEG
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 3
92977: PUSH
92978: LD_INT 2
92980: PUSH
92981: EMPTY
92982: LIST
92983: LIST
92984: PUSH
92985: LD_INT 3
92987: PUSH
92988: LD_INT 3
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: PUSH
92995: LD_INT 2
92997: PUSH
92998: LD_INT 3
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 1
93007: PUSH
93008: LD_INT 3
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 0
93017: PUSH
93018: LD_INT 3
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: LD_INT 1
93027: NEG
93028: PUSH
93029: LD_INT 2
93031: PUSH
93032: EMPTY
93033: LIST
93034: LIST
93035: PUSH
93036: LD_INT 3
93038: NEG
93039: PUSH
93040: LD_INT 2
93042: NEG
93043: PUSH
93044: EMPTY
93045: LIST
93046: LIST
93047: PUSH
93048: LD_INT 3
93050: NEG
93051: PUSH
93052: LD_INT 3
93054: NEG
93055: PUSH
93056: EMPTY
93057: LIST
93058: LIST
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93091: LD_ADDR_VAR 0 43
93095: PUSH
93096: LD_INT 0
93098: PUSH
93099: LD_INT 0
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 0
93108: PUSH
93109: LD_INT 1
93111: NEG
93112: PUSH
93113: EMPTY
93114: LIST
93115: LIST
93116: PUSH
93117: LD_INT 1
93119: PUSH
93120: LD_INT 0
93122: PUSH
93123: EMPTY
93124: LIST
93125: LIST
93126: PUSH
93127: LD_INT 1
93129: PUSH
93130: LD_INT 1
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: PUSH
93137: LD_INT 0
93139: PUSH
93140: LD_INT 1
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 1
93149: NEG
93150: PUSH
93151: LD_INT 0
93153: PUSH
93154: EMPTY
93155: LIST
93156: LIST
93157: PUSH
93158: LD_INT 1
93160: NEG
93161: PUSH
93162: LD_INT 1
93164: NEG
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PUSH
93170: LD_INT 1
93172: NEG
93173: PUSH
93174: LD_INT 2
93176: NEG
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 0
93184: PUSH
93185: LD_INT 2
93187: NEG
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: LD_INT 1
93195: PUSH
93196: LD_INT 1
93198: NEG
93199: PUSH
93200: EMPTY
93201: LIST
93202: LIST
93203: PUSH
93204: LD_INT 2
93206: PUSH
93207: LD_INT 0
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 2
93216: PUSH
93217: LD_INT 1
93219: PUSH
93220: EMPTY
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 1
93226: PUSH
93227: LD_INT 2
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: PUSH
93234: LD_INT 0
93236: PUSH
93237: LD_INT 2
93239: PUSH
93240: EMPTY
93241: LIST
93242: LIST
93243: PUSH
93244: LD_INT 1
93246: NEG
93247: PUSH
93248: LD_INT 1
93250: PUSH
93251: EMPTY
93252: LIST
93253: LIST
93254: PUSH
93255: LD_INT 2
93257: NEG
93258: PUSH
93259: LD_INT 0
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: LD_INT 2
93268: NEG
93269: PUSH
93270: LD_INT 1
93272: NEG
93273: PUSH
93274: EMPTY
93275: LIST
93276: LIST
93277: PUSH
93278: LD_INT 1
93280: NEG
93281: PUSH
93282: LD_INT 3
93284: NEG
93285: PUSH
93286: EMPTY
93287: LIST
93288: LIST
93289: PUSH
93290: LD_INT 0
93292: PUSH
93293: LD_INT 3
93295: NEG
93296: PUSH
93297: EMPTY
93298: LIST
93299: LIST
93300: PUSH
93301: LD_INT 1
93303: PUSH
93304: LD_INT 2
93306: NEG
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 2
93314: PUSH
93315: LD_INT 1
93317: NEG
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 3
93325: PUSH
93326: LD_INT 0
93328: PUSH
93329: EMPTY
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 3
93335: PUSH
93336: LD_INT 1
93338: PUSH
93339: EMPTY
93340: LIST
93341: LIST
93342: PUSH
93343: LD_INT 1
93345: PUSH
93346: LD_INT 3
93348: PUSH
93349: EMPTY
93350: LIST
93351: LIST
93352: PUSH
93353: LD_INT 0
93355: PUSH
93356: LD_INT 3
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: PUSH
93363: LD_INT 1
93365: NEG
93366: PUSH
93367: LD_INT 2
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PUSH
93374: LD_INT 2
93376: NEG
93377: PUSH
93378: LD_INT 1
93380: PUSH
93381: EMPTY
93382: LIST
93383: LIST
93384: PUSH
93385: LD_INT 3
93387: NEG
93388: PUSH
93389: LD_INT 0
93391: PUSH
93392: EMPTY
93393: LIST
93394: LIST
93395: PUSH
93396: LD_INT 3
93398: NEG
93399: PUSH
93400: LD_INT 1
93402: NEG
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: EMPTY
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: LIST
93414: LIST
93415: LIST
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93439: LD_ADDR_VAR 0 44
93443: PUSH
93444: LD_INT 0
93446: PUSH
93447: LD_INT 0
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 0
93456: PUSH
93457: LD_INT 1
93459: NEG
93460: PUSH
93461: EMPTY
93462: LIST
93463: LIST
93464: PUSH
93465: LD_INT 1
93467: PUSH
93468: LD_INT 0
93470: PUSH
93471: EMPTY
93472: LIST
93473: LIST
93474: PUSH
93475: LD_INT 1
93477: PUSH
93478: LD_INT 1
93480: PUSH
93481: EMPTY
93482: LIST
93483: LIST
93484: PUSH
93485: LD_INT 0
93487: PUSH
93488: LD_INT 1
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: PUSH
93495: LD_INT 1
93497: NEG
93498: PUSH
93499: LD_INT 0
93501: PUSH
93502: EMPTY
93503: LIST
93504: LIST
93505: PUSH
93506: LD_INT 1
93508: NEG
93509: PUSH
93510: LD_INT 1
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 1
93520: NEG
93521: PUSH
93522: LD_INT 2
93524: NEG
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 1
93532: PUSH
93533: LD_INT 1
93535: NEG
93536: PUSH
93537: EMPTY
93538: LIST
93539: LIST
93540: PUSH
93541: LD_INT 2
93543: PUSH
93544: LD_INT 0
93546: PUSH
93547: EMPTY
93548: LIST
93549: LIST
93550: PUSH
93551: LD_INT 2
93553: PUSH
93554: LD_INT 1
93556: PUSH
93557: EMPTY
93558: LIST
93559: LIST
93560: PUSH
93561: LD_INT 2
93563: PUSH
93564: LD_INT 2
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 1
93573: PUSH
93574: LD_INT 2
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 1
93583: NEG
93584: PUSH
93585: LD_INT 1
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: LD_INT 0
93598: PUSH
93599: EMPTY
93600: LIST
93601: LIST
93602: PUSH
93603: LD_INT 2
93605: NEG
93606: PUSH
93607: LD_INT 1
93609: NEG
93610: PUSH
93611: EMPTY
93612: LIST
93613: LIST
93614: PUSH
93615: LD_INT 2
93617: NEG
93618: PUSH
93619: LD_INT 2
93621: NEG
93622: PUSH
93623: EMPTY
93624: LIST
93625: LIST
93626: PUSH
93627: LD_INT 2
93629: NEG
93630: PUSH
93631: LD_INT 3
93633: NEG
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 2
93641: PUSH
93642: LD_INT 1
93644: NEG
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: PUSH
93650: LD_INT 3
93652: PUSH
93653: LD_INT 0
93655: PUSH
93656: EMPTY
93657: LIST
93658: LIST
93659: PUSH
93660: LD_INT 3
93662: PUSH
93663: LD_INT 1
93665: PUSH
93666: EMPTY
93667: LIST
93668: LIST
93669: PUSH
93670: LD_INT 3
93672: PUSH
93673: LD_INT 2
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 3
93682: PUSH
93683: LD_INT 3
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: PUSH
93690: LD_INT 2
93692: PUSH
93693: LD_INT 3
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: PUSH
93700: LD_INT 2
93702: NEG
93703: PUSH
93704: LD_INT 1
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 3
93713: NEG
93714: PUSH
93715: LD_INT 0
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 3
93724: NEG
93725: PUSH
93726: LD_INT 1
93728: NEG
93729: PUSH
93730: EMPTY
93731: LIST
93732: LIST
93733: PUSH
93734: LD_INT 3
93736: NEG
93737: PUSH
93738: LD_INT 2
93740: NEG
93741: PUSH
93742: EMPTY
93743: LIST
93744: LIST
93745: PUSH
93746: LD_INT 3
93748: NEG
93749: PUSH
93750: LD_INT 3
93752: NEG
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: LIST
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93789: LD_ADDR_VAR 0 45
93793: PUSH
93794: LD_INT 0
93796: PUSH
93797: LD_INT 0
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 0
93806: PUSH
93807: LD_INT 1
93809: NEG
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: LD_INT 1
93817: PUSH
93818: LD_INT 0
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 1
93827: PUSH
93828: LD_INT 1
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 0
93837: PUSH
93838: LD_INT 1
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: LD_INT 1
93847: NEG
93848: PUSH
93849: LD_INT 0
93851: PUSH
93852: EMPTY
93853: LIST
93854: LIST
93855: PUSH
93856: LD_INT 1
93858: NEG
93859: PUSH
93860: LD_INT 1
93862: NEG
93863: PUSH
93864: EMPTY
93865: LIST
93866: LIST
93867: PUSH
93868: LD_INT 1
93870: NEG
93871: PUSH
93872: LD_INT 2
93874: NEG
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 0
93882: PUSH
93883: LD_INT 2
93885: NEG
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: PUSH
93891: LD_INT 1
93893: PUSH
93894: LD_INT 1
93896: NEG
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: PUSH
93902: LD_INT 2
93904: PUSH
93905: LD_INT 1
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 2
93914: PUSH
93915: LD_INT 2
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 1
93924: PUSH
93925: LD_INT 2
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 0
93934: PUSH
93935: LD_INT 2
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 1
93944: NEG
93945: PUSH
93946: LD_INT 1
93948: PUSH
93949: EMPTY
93950: LIST
93951: LIST
93952: PUSH
93953: LD_INT 2
93955: NEG
93956: PUSH
93957: LD_INT 1
93959: NEG
93960: PUSH
93961: EMPTY
93962: LIST
93963: LIST
93964: PUSH
93965: LD_INT 2
93967: NEG
93968: PUSH
93969: LD_INT 2
93971: NEG
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 2
93979: NEG
93980: PUSH
93981: LD_INT 3
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 1
93991: NEG
93992: PUSH
93993: LD_INT 3
93995: NEG
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: PUSH
94001: LD_INT 0
94003: PUSH
94004: LD_INT 3
94006: NEG
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PUSH
94012: LD_INT 1
94014: PUSH
94015: LD_INT 2
94017: NEG
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 3
94025: PUSH
94026: LD_INT 2
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 3
94035: PUSH
94036: LD_INT 3
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 2
94045: PUSH
94046: LD_INT 3
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 1
94055: PUSH
94056: LD_INT 3
94058: PUSH
94059: EMPTY
94060: LIST
94061: LIST
94062: PUSH
94063: LD_INT 0
94065: PUSH
94066: LD_INT 3
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 1
94075: NEG
94076: PUSH
94077: LD_INT 2
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 3
94086: NEG
94087: PUSH
94088: LD_INT 2
94090: NEG
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 3
94098: NEG
94099: PUSH
94100: LD_INT 3
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94139: LD_ADDR_VAR 0 46
94143: PUSH
94144: LD_INT 0
94146: PUSH
94147: LD_INT 0
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 0
94156: PUSH
94157: LD_INT 1
94159: NEG
94160: PUSH
94161: EMPTY
94162: LIST
94163: LIST
94164: PUSH
94165: LD_INT 1
94167: PUSH
94168: LD_INT 0
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PUSH
94175: LD_INT 1
94177: PUSH
94178: LD_INT 1
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 0
94187: PUSH
94188: LD_INT 1
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 1
94197: NEG
94198: PUSH
94199: LD_INT 0
94201: PUSH
94202: EMPTY
94203: LIST
94204: LIST
94205: PUSH
94206: LD_INT 1
94208: NEG
94209: PUSH
94210: LD_INT 1
94212: NEG
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: PUSH
94218: LD_INT 1
94220: NEG
94221: PUSH
94222: LD_INT 2
94224: NEG
94225: PUSH
94226: EMPTY
94227: LIST
94228: LIST
94229: PUSH
94230: LD_INT 0
94232: PUSH
94233: LD_INT 2
94235: NEG
94236: PUSH
94237: EMPTY
94238: LIST
94239: LIST
94240: PUSH
94241: LD_INT 1
94243: PUSH
94244: LD_INT 1
94246: NEG
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 2
94254: PUSH
94255: LD_INT 0
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: LD_INT 2
94264: PUSH
94265: LD_INT 1
94267: PUSH
94268: EMPTY
94269: LIST
94270: LIST
94271: PUSH
94272: LD_INT 1
94274: PUSH
94275: LD_INT 2
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 0
94284: PUSH
94285: LD_INT 2
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: PUSH
94292: LD_INT 1
94294: NEG
94295: PUSH
94296: LD_INT 1
94298: PUSH
94299: EMPTY
94300: LIST
94301: LIST
94302: PUSH
94303: LD_INT 2
94305: NEG
94306: PUSH
94307: LD_INT 0
94309: PUSH
94310: EMPTY
94311: LIST
94312: LIST
94313: PUSH
94314: LD_INT 2
94316: NEG
94317: PUSH
94318: LD_INT 1
94320: NEG
94321: PUSH
94322: EMPTY
94323: LIST
94324: LIST
94325: PUSH
94326: LD_INT 1
94328: NEG
94329: PUSH
94330: LD_INT 3
94332: NEG
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: LD_INT 3
94343: NEG
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: PUSH
94349: LD_INT 1
94351: PUSH
94352: LD_INT 2
94354: NEG
94355: PUSH
94356: EMPTY
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 2
94362: PUSH
94363: LD_INT 1
94365: NEG
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 3
94373: PUSH
94374: LD_INT 0
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 3
94383: PUSH
94384: LD_INT 1
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 1
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 0
94403: PUSH
94404: LD_INT 3
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 1
94413: NEG
94414: PUSH
94415: LD_INT 2
94417: PUSH
94418: EMPTY
94419: LIST
94420: LIST
94421: PUSH
94422: LD_INT 2
94424: NEG
94425: PUSH
94426: LD_INT 1
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: PUSH
94433: LD_INT 3
94435: NEG
94436: PUSH
94437: LD_INT 0
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 3
94446: NEG
94447: PUSH
94448: LD_INT 1
94450: NEG
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: PUSH
94456: EMPTY
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94487: LD_ADDR_VAR 0 47
94491: PUSH
94492: LD_INT 0
94494: PUSH
94495: LD_INT 0
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 0
94504: PUSH
94505: LD_INT 1
94507: NEG
94508: PUSH
94509: EMPTY
94510: LIST
94511: LIST
94512: PUSH
94513: LD_INT 1
94515: PUSH
94516: LD_INT 0
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PUSH
94523: LD_INT 1
94525: PUSH
94526: LD_INT 1
94528: PUSH
94529: EMPTY
94530: LIST
94531: LIST
94532: PUSH
94533: LD_INT 0
94535: PUSH
94536: LD_INT 1
94538: PUSH
94539: EMPTY
94540: LIST
94541: LIST
94542: PUSH
94543: LD_INT 1
94545: NEG
94546: PUSH
94547: LD_INT 0
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: PUSH
94554: LD_INT 1
94556: NEG
94557: PUSH
94558: LD_INT 1
94560: NEG
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 1
94568: NEG
94569: PUSH
94570: LD_INT 2
94572: NEG
94573: PUSH
94574: EMPTY
94575: LIST
94576: LIST
94577: PUSH
94578: LD_INT 0
94580: PUSH
94581: LD_INT 2
94583: NEG
94584: PUSH
94585: EMPTY
94586: LIST
94587: LIST
94588: PUSH
94589: LD_INT 1
94591: PUSH
94592: LD_INT 1
94594: NEG
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: PUSH
94600: LD_INT 2
94602: NEG
94603: PUSH
94604: LD_INT 1
94606: NEG
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 2
94614: NEG
94615: PUSH
94616: LD_INT 2
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94638: LD_ADDR_VAR 0 48
94642: PUSH
94643: LD_INT 0
94645: PUSH
94646: LD_INT 0
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: PUSH
94653: LD_INT 0
94655: PUSH
94656: LD_INT 1
94658: NEG
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: PUSH
94664: LD_INT 1
94666: PUSH
94667: LD_INT 0
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: PUSH
94674: LD_INT 1
94676: PUSH
94677: LD_INT 1
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 0
94686: PUSH
94687: LD_INT 1
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 1
94696: NEG
94697: PUSH
94698: LD_INT 0
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 1
94707: NEG
94708: PUSH
94709: LD_INT 1
94711: NEG
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: PUSH
94717: LD_INT 1
94719: NEG
94720: PUSH
94721: LD_INT 2
94723: NEG
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PUSH
94729: LD_INT 0
94731: PUSH
94732: LD_INT 2
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 1
94742: PUSH
94743: LD_INT 1
94745: NEG
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 2
94753: PUSH
94754: LD_INT 0
94756: PUSH
94757: EMPTY
94758: LIST
94759: LIST
94760: PUSH
94761: LD_INT 2
94763: PUSH
94764: LD_INT 1
94766: PUSH
94767: EMPTY
94768: LIST
94769: LIST
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94785: LD_ADDR_VAR 0 49
94789: PUSH
94790: LD_INT 0
94792: PUSH
94793: LD_INT 0
94795: PUSH
94796: EMPTY
94797: LIST
94798: LIST
94799: PUSH
94800: LD_INT 0
94802: PUSH
94803: LD_INT 1
94805: NEG
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 1
94813: PUSH
94814: LD_INT 0
94816: PUSH
94817: EMPTY
94818: LIST
94819: LIST
94820: PUSH
94821: LD_INT 1
94823: PUSH
94824: LD_INT 1
94826: PUSH
94827: EMPTY
94828: LIST
94829: LIST
94830: PUSH
94831: LD_INT 0
94833: PUSH
94834: LD_INT 1
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: PUSH
94841: LD_INT 1
94843: NEG
94844: PUSH
94845: LD_INT 0
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 1
94854: NEG
94855: PUSH
94856: LD_INT 1
94858: NEG
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: LD_INT 1
94866: PUSH
94867: LD_INT 1
94869: NEG
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: PUSH
94875: LD_INT 2
94877: PUSH
94878: LD_INT 0
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: PUSH
94885: LD_INT 2
94887: PUSH
94888: LD_INT 1
94890: PUSH
94891: EMPTY
94892: LIST
94893: LIST
94894: PUSH
94895: LD_INT 2
94897: PUSH
94898: LD_INT 2
94900: PUSH
94901: EMPTY
94902: LIST
94903: LIST
94904: PUSH
94905: LD_INT 1
94907: PUSH
94908: LD_INT 2
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94929: LD_ADDR_VAR 0 50
94933: PUSH
94934: LD_INT 0
94936: PUSH
94937: LD_INT 0
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: LD_INT 0
94946: PUSH
94947: LD_INT 1
94949: NEG
94950: PUSH
94951: EMPTY
94952: LIST
94953: LIST
94954: PUSH
94955: LD_INT 1
94957: PUSH
94958: LD_INT 0
94960: PUSH
94961: EMPTY
94962: LIST
94963: LIST
94964: PUSH
94965: LD_INT 1
94967: PUSH
94968: LD_INT 1
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 0
94977: PUSH
94978: LD_INT 1
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 1
94987: NEG
94988: PUSH
94989: LD_INT 0
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: NEG
94999: PUSH
95000: LD_INT 1
95002: NEG
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 2
95010: PUSH
95011: LD_INT 1
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: LD_INT 2
95020: PUSH
95021: LD_INT 2
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: PUSH
95028: LD_INT 1
95030: PUSH
95031: LD_INT 2
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 0
95040: PUSH
95041: LD_INT 2
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 1
95050: NEG
95051: PUSH
95052: LD_INT 1
95054: PUSH
95055: EMPTY
95056: LIST
95057: LIST
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95073: LD_ADDR_VAR 0 51
95077: PUSH
95078: LD_INT 0
95080: PUSH
95081: LD_INT 0
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: PUSH
95088: LD_INT 0
95090: PUSH
95091: LD_INT 1
95093: NEG
95094: PUSH
95095: EMPTY
95096: LIST
95097: LIST
95098: PUSH
95099: LD_INT 1
95101: PUSH
95102: LD_INT 0
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: PUSH
95109: LD_INT 1
95111: PUSH
95112: LD_INT 1
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: PUSH
95119: LD_INT 0
95121: PUSH
95122: LD_INT 1
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 1
95131: NEG
95132: PUSH
95133: LD_INT 0
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: LD_INT 1
95142: NEG
95143: PUSH
95144: LD_INT 1
95146: NEG
95147: PUSH
95148: EMPTY
95149: LIST
95150: LIST
95151: PUSH
95152: LD_INT 1
95154: PUSH
95155: LD_INT 2
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 0
95164: PUSH
95165: LD_INT 2
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 1
95174: NEG
95175: PUSH
95176: LD_INT 1
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 2
95185: NEG
95186: PUSH
95187: LD_INT 0
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 2
95196: NEG
95197: PUSH
95198: LD_INT 1
95200: NEG
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95220: LD_ADDR_VAR 0 52
95224: PUSH
95225: LD_INT 0
95227: PUSH
95228: LD_INT 0
95230: PUSH
95231: EMPTY
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 0
95237: PUSH
95238: LD_INT 1
95240: NEG
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 1
95248: PUSH
95249: LD_INT 0
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 1
95258: PUSH
95259: LD_INT 1
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: LD_INT 0
95268: PUSH
95269: LD_INT 1
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: PUSH
95276: LD_INT 1
95278: NEG
95279: PUSH
95280: LD_INT 0
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 1
95289: NEG
95290: PUSH
95291: LD_INT 1
95293: NEG
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 1
95301: NEG
95302: PUSH
95303: LD_INT 2
95305: NEG
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: PUSH
95311: LD_INT 1
95313: NEG
95314: PUSH
95315: LD_INT 1
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PUSH
95322: LD_INT 2
95324: NEG
95325: PUSH
95326: LD_INT 0
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: PUSH
95333: LD_INT 2
95335: NEG
95336: PUSH
95337: LD_INT 1
95339: NEG
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 2
95347: NEG
95348: PUSH
95349: LD_INT 2
95351: NEG
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: EMPTY
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95371: LD_ADDR_VAR 0 53
95375: PUSH
95376: LD_INT 0
95378: PUSH
95379: LD_INT 0
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: LD_INT 1
95391: NEG
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 1
95399: PUSH
95400: LD_INT 0
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 1
95409: PUSH
95410: LD_INT 1
95412: PUSH
95413: EMPTY
95414: LIST
95415: LIST
95416: PUSH
95417: LD_INT 0
95419: PUSH
95420: LD_INT 1
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 1
95429: NEG
95430: PUSH
95431: LD_INT 0
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 1
95440: NEG
95441: PUSH
95442: LD_INT 1
95444: NEG
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 1
95452: NEG
95453: PUSH
95454: LD_INT 2
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 0
95464: PUSH
95465: LD_INT 2
95467: NEG
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 1
95475: PUSH
95476: LD_INT 1
95478: NEG
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 2
95486: PUSH
95487: LD_INT 0
95489: PUSH
95490: EMPTY
95491: LIST
95492: LIST
95493: PUSH
95494: LD_INT 2
95496: PUSH
95497: LD_INT 1
95499: PUSH
95500: EMPTY
95501: LIST
95502: LIST
95503: PUSH
95504: LD_INT 2
95506: PUSH
95507: LD_INT 2
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: PUSH
95514: LD_INT 1
95516: PUSH
95517: LD_INT 2
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: PUSH
95524: LD_INT 0
95526: PUSH
95527: LD_INT 2
95529: PUSH
95530: EMPTY
95531: LIST
95532: LIST
95533: PUSH
95534: LD_INT 1
95536: NEG
95537: PUSH
95538: LD_INT 1
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PUSH
95545: LD_INT 2
95547: NEG
95548: PUSH
95549: LD_INT 0
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: LD_INT 2
95558: NEG
95559: PUSH
95560: LD_INT 1
95562: NEG
95563: PUSH
95564: EMPTY
95565: LIST
95566: LIST
95567: PUSH
95568: LD_INT 2
95570: NEG
95571: PUSH
95572: LD_INT 2
95574: NEG
95575: PUSH
95576: EMPTY
95577: LIST
95578: LIST
95579: PUSH
95580: EMPTY
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: LIST
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95601: LD_ADDR_VAR 0 54
95605: PUSH
95606: LD_INT 0
95608: PUSH
95609: LD_INT 0
95611: PUSH
95612: EMPTY
95613: LIST
95614: LIST
95615: PUSH
95616: LD_INT 0
95618: PUSH
95619: LD_INT 1
95621: NEG
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: PUSH
95627: LD_INT 1
95629: PUSH
95630: LD_INT 0
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 1
95639: PUSH
95640: LD_INT 1
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PUSH
95647: LD_INT 0
95649: PUSH
95650: LD_INT 1
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 1
95659: NEG
95660: PUSH
95661: LD_INT 0
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: PUSH
95668: LD_INT 1
95670: NEG
95671: PUSH
95672: LD_INT 1
95674: NEG
95675: PUSH
95676: EMPTY
95677: LIST
95678: LIST
95679: PUSH
95680: LD_INT 1
95682: NEG
95683: PUSH
95684: LD_INT 2
95686: NEG
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: PUSH
95692: LD_INT 0
95694: PUSH
95695: LD_INT 2
95697: NEG
95698: PUSH
95699: EMPTY
95700: LIST
95701: LIST
95702: PUSH
95703: LD_INT 1
95705: PUSH
95706: LD_INT 1
95708: NEG
95709: PUSH
95710: EMPTY
95711: LIST
95712: LIST
95713: PUSH
95714: LD_INT 2
95716: PUSH
95717: LD_INT 0
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 2
95726: PUSH
95727: LD_INT 1
95729: PUSH
95730: EMPTY
95731: LIST
95732: LIST
95733: PUSH
95734: LD_INT 2
95736: PUSH
95737: LD_INT 2
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 1
95746: PUSH
95747: LD_INT 2
95749: PUSH
95750: EMPTY
95751: LIST
95752: LIST
95753: PUSH
95754: LD_INT 0
95756: PUSH
95757: LD_INT 2
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: PUSH
95764: LD_INT 1
95766: NEG
95767: PUSH
95768: LD_INT 1
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: PUSH
95775: LD_INT 2
95777: NEG
95778: PUSH
95779: LD_INT 0
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 2
95788: NEG
95789: PUSH
95790: LD_INT 1
95792: NEG
95793: PUSH
95794: EMPTY
95795: LIST
95796: LIST
95797: PUSH
95798: LD_INT 2
95800: NEG
95801: PUSH
95802: LD_INT 2
95804: NEG
95805: PUSH
95806: EMPTY
95807: LIST
95808: LIST
95809: PUSH
95810: EMPTY
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95831: LD_ADDR_VAR 0 55
95835: PUSH
95836: LD_INT 0
95838: PUSH
95839: LD_INT 0
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: PUSH
95846: LD_INT 0
95848: PUSH
95849: LD_INT 1
95851: NEG
95852: PUSH
95853: EMPTY
95854: LIST
95855: LIST
95856: PUSH
95857: LD_INT 1
95859: PUSH
95860: LD_INT 0
95862: PUSH
95863: EMPTY
95864: LIST
95865: LIST
95866: PUSH
95867: LD_INT 1
95869: PUSH
95870: LD_INT 1
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: PUSH
95877: LD_INT 0
95879: PUSH
95880: LD_INT 1
95882: PUSH
95883: EMPTY
95884: LIST
95885: LIST
95886: PUSH
95887: LD_INT 1
95889: NEG
95890: PUSH
95891: LD_INT 0
95893: PUSH
95894: EMPTY
95895: LIST
95896: LIST
95897: PUSH
95898: LD_INT 1
95900: NEG
95901: PUSH
95902: LD_INT 1
95904: NEG
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: LD_INT 1
95912: NEG
95913: PUSH
95914: LD_INT 2
95916: NEG
95917: PUSH
95918: EMPTY
95919: LIST
95920: LIST
95921: PUSH
95922: LD_INT 0
95924: PUSH
95925: LD_INT 2
95927: NEG
95928: PUSH
95929: EMPTY
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 1
95935: PUSH
95936: LD_INT 1
95938: NEG
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: PUSH
95944: LD_INT 2
95946: PUSH
95947: LD_INT 0
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: PUSH
95954: LD_INT 2
95956: PUSH
95957: LD_INT 1
95959: PUSH
95960: EMPTY
95961: LIST
95962: LIST
95963: PUSH
95964: LD_INT 2
95966: PUSH
95967: LD_INT 2
95969: PUSH
95970: EMPTY
95971: LIST
95972: LIST
95973: PUSH
95974: LD_INT 1
95976: PUSH
95977: LD_INT 2
95979: PUSH
95980: EMPTY
95981: LIST
95982: LIST
95983: PUSH
95984: LD_INT 0
95986: PUSH
95987: LD_INT 2
95989: PUSH
95990: EMPTY
95991: LIST
95992: LIST
95993: PUSH
95994: LD_INT 1
95996: NEG
95997: PUSH
95998: LD_INT 1
96000: PUSH
96001: EMPTY
96002: LIST
96003: LIST
96004: PUSH
96005: LD_INT 2
96007: NEG
96008: PUSH
96009: LD_INT 0
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 2
96018: NEG
96019: PUSH
96020: LD_INT 1
96022: NEG
96023: PUSH
96024: EMPTY
96025: LIST
96026: LIST
96027: PUSH
96028: LD_INT 2
96030: NEG
96031: PUSH
96032: LD_INT 2
96034: NEG
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: EMPTY
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96061: LD_ADDR_VAR 0 56
96065: PUSH
96066: LD_INT 0
96068: PUSH
96069: LD_INT 0
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 0
96078: PUSH
96079: LD_INT 1
96081: NEG
96082: PUSH
96083: EMPTY
96084: LIST
96085: LIST
96086: PUSH
96087: LD_INT 1
96089: PUSH
96090: LD_INT 0
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 1
96099: PUSH
96100: LD_INT 1
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 0
96109: PUSH
96110: LD_INT 1
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 1
96119: NEG
96120: PUSH
96121: LD_INT 0
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 1
96130: NEG
96131: PUSH
96132: LD_INT 1
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 1
96142: NEG
96143: PUSH
96144: LD_INT 2
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 0
96154: PUSH
96155: LD_INT 2
96157: NEG
96158: PUSH
96159: EMPTY
96160: LIST
96161: LIST
96162: PUSH
96163: LD_INT 1
96165: PUSH
96166: LD_INT 1
96168: NEG
96169: PUSH
96170: EMPTY
96171: LIST
96172: LIST
96173: PUSH
96174: LD_INT 2
96176: PUSH
96177: LD_INT 0
96179: PUSH
96180: EMPTY
96181: LIST
96182: LIST
96183: PUSH
96184: LD_INT 2
96186: PUSH
96187: LD_INT 1
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: PUSH
96194: LD_INT 2
96196: PUSH
96197: LD_INT 2
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PUSH
96204: LD_INT 1
96206: PUSH
96207: LD_INT 2
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: PUSH
96214: LD_INT 0
96216: PUSH
96217: LD_INT 2
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 1
96226: NEG
96227: PUSH
96228: LD_INT 1
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PUSH
96235: LD_INT 2
96237: NEG
96238: PUSH
96239: LD_INT 0
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 2
96248: NEG
96249: PUSH
96250: LD_INT 1
96252: NEG
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 2
96260: NEG
96261: PUSH
96262: LD_INT 2
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: EMPTY
96271: LIST
96272: LIST
96273: LIST
96274: LIST
96275: LIST
96276: LIST
96277: LIST
96278: LIST
96279: LIST
96280: LIST
96281: LIST
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96291: LD_ADDR_VAR 0 57
96295: PUSH
96296: LD_INT 0
96298: PUSH
96299: LD_INT 0
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: PUSH
96306: LD_INT 0
96308: PUSH
96309: LD_INT 1
96311: NEG
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: PUSH
96317: LD_INT 1
96319: PUSH
96320: LD_INT 0
96322: PUSH
96323: EMPTY
96324: LIST
96325: LIST
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: LD_INT 1
96332: PUSH
96333: EMPTY
96334: LIST
96335: LIST
96336: PUSH
96337: LD_INT 0
96339: PUSH
96340: LD_INT 1
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: PUSH
96347: LD_INT 1
96349: NEG
96350: PUSH
96351: LD_INT 0
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: PUSH
96358: LD_INT 1
96360: NEG
96361: PUSH
96362: LD_INT 1
96364: NEG
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: PUSH
96370: LD_INT 1
96372: NEG
96373: PUSH
96374: LD_INT 2
96376: NEG
96377: PUSH
96378: EMPTY
96379: LIST
96380: LIST
96381: PUSH
96382: LD_INT 0
96384: PUSH
96385: LD_INT 2
96387: NEG
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: PUSH
96393: LD_INT 1
96395: PUSH
96396: LD_INT 1
96398: NEG
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 2
96406: PUSH
96407: LD_INT 0
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 2
96416: PUSH
96417: LD_INT 1
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 2
96426: PUSH
96427: LD_INT 2
96429: PUSH
96430: EMPTY
96431: LIST
96432: LIST
96433: PUSH
96434: LD_INT 1
96436: PUSH
96437: LD_INT 2
96439: PUSH
96440: EMPTY
96441: LIST
96442: LIST
96443: PUSH
96444: LD_INT 0
96446: PUSH
96447: LD_INT 2
96449: PUSH
96450: EMPTY
96451: LIST
96452: LIST
96453: PUSH
96454: LD_INT 1
96456: NEG
96457: PUSH
96458: LD_INT 1
96460: PUSH
96461: EMPTY
96462: LIST
96463: LIST
96464: PUSH
96465: LD_INT 2
96467: NEG
96468: PUSH
96469: LD_INT 0
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 2
96478: NEG
96479: PUSH
96480: LD_INT 1
96482: NEG
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: PUSH
96488: LD_INT 2
96490: NEG
96491: PUSH
96492: LD_INT 2
96494: NEG
96495: PUSH
96496: EMPTY
96497: LIST
96498: LIST
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96521: LD_ADDR_VAR 0 58
96525: PUSH
96526: LD_INT 0
96528: PUSH
96529: LD_INT 0
96531: PUSH
96532: EMPTY
96533: LIST
96534: LIST
96535: PUSH
96536: LD_INT 0
96538: PUSH
96539: LD_INT 1
96541: NEG
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PUSH
96547: LD_INT 1
96549: PUSH
96550: LD_INT 0
96552: PUSH
96553: EMPTY
96554: LIST
96555: LIST
96556: PUSH
96557: LD_INT 1
96559: PUSH
96560: LD_INT 1
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: PUSH
96567: LD_INT 0
96569: PUSH
96570: LD_INT 1
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: PUSH
96577: LD_INT 1
96579: NEG
96580: PUSH
96581: LD_INT 0
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: PUSH
96588: LD_INT 1
96590: NEG
96591: PUSH
96592: LD_INT 1
96594: NEG
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: PUSH
96600: LD_INT 1
96602: NEG
96603: PUSH
96604: LD_INT 2
96606: NEG
96607: PUSH
96608: EMPTY
96609: LIST
96610: LIST
96611: PUSH
96612: LD_INT 0
96614: PUSH
96615: LD_INT 2
96617: NEG
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: PUSH
96623: LD_INT 1
96625: PUSH
96626: LD_INT 1
96628: NEG
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 2
96636: PUSH
96637: LD_INT 0
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 2
96646: PUSH
96647: LD_INT 1
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PUSH
96654: LD_INT 2
96656: PUSH
96657: LD_INT 2
96659: PUSH
96660: EMPTY
96661: LIST
96662: LIST
96663: PUSH
96664: LD_INT 1
96666: PUSH
96667: LD_INT 2
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: LD_INT 0
96676: PUSH
96677: LD_INT 2
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 1
96686: NEG
96687: PUSH
96688: LD_INT 1
96690: PUSH
96691: EMPTY
96692: LIST
96693: LIST
96694: PUSH
96695: LD_INT 2
96697: NEG
96698: PUSH
96699: LD_INT 0
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 2
96708: NEG
96709: PUSH
96710: LD_INT 1
96712: NEG
96713: PUSH
96714: EMPTY
96715: LIST
96716: LIST
96717: PUSH
96718: LD_INT 2
96720: NEG
96721: PUSH
96722: LD_INT 2
96724: NEG
96725: PUSH
96726: EMPTY
96727: LIST
96728: LIST
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96751: LD_ADDR_VAR 0 59
96755: PUSH
96756: LD_INT 0
96758: PUSH
96759: LD_INT 0
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 0
96768: PUSH
96769: LD_INT 1
96771: NEG
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: PUSH
96777: LD_INT 1
96779: PUSH
96780: LD_INT 0
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: PUSH
96787: LD_INT 1
96789: PUSH
96790: LD_INT 1
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 0
96799: PUSH
96800: LD_INT 1
96802: PUSH
96803: EMPTY
96804: LIST
96805: LIST
96806: PUSH
96807: LD_INT 1
96809: NEG
96810: PUSH
96811: LD_INT 0
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: PUSH
96818: LD_INT 1
96820: NEG
96821: PUSH
96822: LD_INT 1
96824: NEG
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PUSH
96830: EMPTY
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96839: LD_ADDR_VAR 0 60
96843: PUSH
96844: LD_INT 0
96846: PUSH
96847: LD_INT 0
96849: PUSH
96850: EMPTY
96851: LIST
96852: LIST
96853: PUSH
96854: LD_INT 0
96856: PUSH
96857: LD_INT 1
96859: NEG
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: PUSH
96865: LD_INT 1
96867: PUSH
96868: LD_INT 0
96870: PUSH
96871: EMPTY
96872: LIST
96873: LIST
96874: PUSH
96875: LD_INT 1
96877: PUSH
96878: LD_INT 1
96880: PUSH
96881: EMPTY
96882: LIST
96883: LIST
96884: PUSH
96885: LD_INT 0
96887: PUSH
96888: LD_INT 1
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: PUSH
96895: LD_INT 1
96897: NEG
96898: PUSH
96899: LD_INT 0
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 1
96908: NEG
96909: PUSH
96910: LD_INT 1
96912: NEG
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96927: LD_ADDR_VAR 0 61
96931: PUSH
96932: LD_INT 0
96934: PUSH
96935: LD_INT 0
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: PUSH
96942: LD_INT 0
96944: PUSH
96945: LD_INT 1
96947: NEG
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 1
96955: PUSH
96956: LD_INT 0
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 1
96965: PUSH
96966: LD_INT 1
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 0
96975: PUSH
96976: LD_INT 1
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 1
96985: NEG
96986: PUSH
96987: LD_INT 0
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 1
96996: NEG
96997: PUSH
96998: LD_INT 1
97000: NEG
97001: PUSH
97002: EMPTY
97003: LIST
97004: LIST
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97015: LD_ADDR_VAR 0 62
97019: PUSH
97020: LD_INT 0
97022: PUSH
97023: LD_INT 0
97025: PUSH
97026: EMPTY
97027: LIST
97028: LIST
97029: PUSH
97030: LD_INT 0
97032: PUSH
97033: LD_INT 1
97035: NEG
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 1
97043: PUSH
97044: LD_INT 0
97046: PUSH
97047: EMPTY
97048: LIST
97049: LIST
97050: PUSH
97051: LD_INT 1
97053: PUSH
97054: LD_INT 1
97056: PUSH
97057: EMPTY
97058: LIST
97059: LIST
97060: PUSH
97061: LD_INT 0
97063: PUSH
97064: LD_INT 1
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 1
97073: NEG
97074: PUSH
97075: LD_INT 0
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: PUSH
97082: LD_INT 1
97084: NEG
97085: PUSH
97086: LD_INT 1
97088: NEG
97089: PUSH
97090: EMPTY
97091: LIST
97092: LIST
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97103: LD_ADDR_VAR 0 63
97107: PUSH
97108: LD_INT 0
97110: PUSH
97111: LD_INT 0
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 0
97120: PUSH
97121: LD_INT 1
97123: NEG
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 1
97131: PUSH
97132: LD_INT 0
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 1
97141: PUSH
97142: LD_INT 1
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: PUSH
97149: LD_INT 0
97151: PUSH
97152: LD_INT 1
97154: PUSH
97155: EMPTY
97156: LIST
97157: LIST
97158: PUSH
97159: LD_INT 1
97161: NEG
97162: PUSH
97163: LD_INT 0
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 1
97172: NEG
97173: PUSH
97174: LD_INT 1
97176: NEG
97177: PUSH
97178: EMPTY
97179: LIST
97180: LIST
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: LIST
97186: LIST
97187: LIST
97188: LIST
97189: LIST
97190: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97191: LD_ADDR_VAR 0 64
97195: PUSH
97196: LD_INT 0
97198: PUSH
97199: LD_INT 0
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 0
97208: PUSH
97209: LD_INT 1
97211: NEG
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: LD_INT 1
97219: PUSH
97220: LD_INT 0
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 1
97229: PUSH
97230: LD_INT 1
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 0
97239: PUSH
97240: LD_INT 1
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: LD_INT 1
97249: NEG
97250: PUSH
97251: LD_INT 0
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: PUSH
97258: LD_INT 1
97260: NEG
97261: PUSH
97262: LD_INT 1
97264: NEG
97265: PUSH
97266: EMPTY
97267: LIST
97268: LIST
97269: PUSH
97270: EMPTY
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: ST_TO_ADDR
// end ; 1 :
97279: GO 103176
97281: LD_INT 1
97283: DOUBLE
97284: EQUAL
97285: IFTRUE 97289
97287: GO 99912
97289: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97290: LD_ADDR_VAR 0 11
97294: PUSH
97295: LD_INT 1
97297: NEG
97298: PUSH
97299: LD_INT 3
97301: NEG
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 0
97309: PUSH
97310: LD_INT 3
97312: NEG
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: PUSH
97318: LD_INT 1
97320: PUSH
97321: LD_INT 2
97323: NEG
97324: PUSH
97325: EMPTY
97326: LIST
97327: LIST
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: LIST
97333: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97334: LD_ADDR_VAR 0 12
97338: PUSH
97339: LD_INT 2
97341: PUSH
97342: LD_INT 1
97344: NEG
97345: PUSH
97346: EMPTY
97347: LIST
97348: LIST
97349: PUSH
97350: LD_INT 3
97352: PUSH
97353: LD_INT 0
97355: PUSH
97356: EMPTY
97357: LIST
97358: LIST
97359: PUSH
97360: LD_INT 3
97362: PUSH
97363: LD_INT 1
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: EMPTY
97371: LIST
97372: LIST
97373: LIST
97374: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97375: LD_ADDR_VAR 0 13
97379: PUSH
97380: LD_INT 3
97382: PUSH
97383: LD_INT 2
97385: PUSH
97386: EMPTY
97387: LIST
97388: LIST
97389: PUSH
97390: LD_INT 3
97392: PUSH
97393: LD_INT 3
97395: PUSH
97396: EMPTY
97397: LIST
97398: LIST
97399: PUSH
97400: LD_INT 2
97402: PUSH
97403: LD_INT 3
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: PUSH
97410: EMPTY
97411: LIST
97412: LIST
97413: LIST
97414: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97415: LD_ADDR_VAR 0 14
97419: PUSH
97420: LD_INT 1
97422: PUSH
97423: LD_INT 3
97425: PUSH
97426: EMPTY
97427: LIST
97428: LIST
97429: PUSH
97430: LD_INT 0
97432: PUSH
97433: LD_INT 3
97435: PUSH
97436: EMPTY
97437: LIST
97438: LIST
97439: PUSH
97440: LD_INT 1
97442: NEG
97443: PUSH
97444: LD_INT 2
97446: PUSH
97447: EMPTY
97448: LIST
97449: LIST
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: LIST
97455: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97456: LD_ADDR_VAR 0 15
97460: PUSH
97461: LD_INT 2
97463: NEG
97464: PUSH
97465: LD_INT 1
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: PUSH
97472: LD_INT 3
97474: NEG
97475: PUSH
97476: LD_INT 0
97478: PUSH
97479: EMPTY
97480: LIST
97481: LIST
97482: PUSH
97483: LD_INT 3
97485: NEG
97486: PUSH
97487: LD_INT 1
97489: NEG
97490: PUSH
97491: EMPTY
97492: LIST
97493: LIST
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: LIST
97499: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97500: LD_ADDR_VAR 0 16
97504: PUSH
97505: LD_INT 2
97507: NEG
97508: PUSH
97509: LD_INT 3
97511: NEG
97512: PUSH
97513: EMPTY
97514: LIST
97515: LIST
97516: PUSH
97517: LD_INT 3
97519: NEG
97520: PUSH
97521: LD_INT 2
97523: NEG
97524: PUSH
97525: EMPTY
97526: LIST
97527: LIST
97528: PUSH
97529: LD_INT 3
97531: NEG
97532: PUSH
97533: LD_INT 3
97535: NEG
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: LIST
97545: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97546: LD_ADDR_VAR 0 17
97550: PUSH
97551: LD_INT 1
97553: NEG
97554: PUSH
97555: LD_INT 3
97557: NEG
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: PUSH
97563: LD_INT 0
97565: PUSH
97566: LD_INT 3
97568: NEG
97569: PUSH
97570: EMPTY
97571: LIST
97572: LIST
97573: PUSH
97574: LD_INT 1
97576: PUSH
97577: LD_INT 2
97579: NEG
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: PUSH
97585: EMPTY
97586: LIST
97587: LIST
97588: LIST
97589: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97590: LD_ADDR_VAR 0 18
97594: PUSH
97595: LD_INT 2
97597: PUSH
97598: LD_INT 1
97600: NEG
97601: PUSH
97602: EMPTY
97603: LIST
97604: LIST
97605: PUSH
97606: LD_INT 3
97608: PUSH
97609: LD_INT 0
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 3
97618: PUSH
97619: LD_INT 1
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: LIST
97630: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97631: LD_ADDR_VAR 0 19
97635: PUSH
97636: LD_INT 3
97638: PUSH
97639: LD_INT 2
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: PUSH
97646: LD_INT 3
97648: PUSH
97649: LD_INT 3
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PUSH
97656: LD_INT 2
97658: PUSH
97659: LD_INT 3
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: LIST
97670: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97671: LD_ADDR_VAR 0 20
97675: PUSH
97676: LD_INT 1
97678: PUSH
97679: LD_INT 3
97681: PUSH
97682: EMPTY
97683: LIST
97684: LIST
97685: PUSH
97686: LD_INT 0
97688: PUSH
97689: LD_INT 3
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 1
97698: NEG
97699: PUSH
97700: LD_INT 2
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: LIST
97711: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97712: LD_ADDR_VAR 0 21
97716: PUSH
97717: LD_INT 2
97719: NEG
97720: PUSH
97721: LD_INT 1
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: PUSH
97728: LD_INT 3
97730: NEG
97731: PUSH
97732: LD_INT 0
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: LD_INT 3
97741: NEG
97742: PUSH
97743: LD_INT 1
97745: NEG
97746: PUSH
97747: EMPTY
97748: LIST
97749: LIST
97750: PUSH
97751: EMPTY
97752: LIST
97753: LIST
97754: LIST
97755: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97756: LD_ADDR_VAR 0 22
97760: PUSH
97761: LD_INT 2
97763: NEG
97764: PUSH
97765: LD_INT 3
97767: NEG
97768: PUSH
97769: EMPTY
97770: LIST
97771: LIST
97772: PUSH
97773: LD_INT 3
97775: NEG
97776: PUSH
97777: LD_INT 2
97779: NEG
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: PUSH
97785: LD_INT 3
97787: NEG
97788: PUSH
97789: LD_INT 3
97791: NEG
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: EMPTY
97798: LIST
97799: LIST
97800: LIST
97801: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
97802: LD_ADDR_VAR 0 23
97806: PUSH
97807: LD_INT 0
97809: PUSH
97810: LD_INT 3
97812: NEG
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 1
97820: NEG
97821: PUSH
97822: LD_INT 4
97824: NEG
97825: PUSH
97826: EMPTY
97827: LIST
97828: LIST
97829: PUSH
97830: LD_INT 1
97832: PUSH
97833: LD_INT 3
97835: NEG
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: PUSH
97841: EMPTY
97842: LIST
97843: LIST
97844: LIST
97845: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
97846: LD_ADDR_VAR 0 24
97850: PUSH
97851: LD_INT 3
97853: PUSH
97854: LD_INT 0
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: LD_INT 3
97863: PUSH
97864: LD_INT 1
97866: NEG
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PUSH
97872: LD_INT 4
97874: PUSH
97875: LD_INT 1
97877: PUSH
97878: EMPTY
97879: LIST
97880: LIST
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: LIST
97886: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
97887: LD_ADDR_VAR 0 25
97891: PUSH
97892: LD_INT 3
97894: PUSH
97895: LD_INT 3
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 4
97904: PUSH
97905: LD_INT 3
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 3
97914: PUSH
97915: LD_INT 4
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: EMPTY
97923: LIST
97924: LIST
97925: LIST
97926: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97927: LD_ADDR_VAR 0 26
97931: PUSH
97932: LD_INT 0
97934: PUSH
97935: LD_INT 3
97937: PUSH
97938: EMPTY
97939: LIST
97940: LIST
97941: PUSH
97942: LD_INT 1
97944: PUSH
97945: LD_INT 4
97947: PUSH
97948: EMPTY
97949: LIST
97950: LIST
97951: PUSH
97952: LD_INT 1
97954: NEG
97955: PUSH
97956: LD_INT 3
97958: PUSH
97959: EMPTY
97960: LIST
97961: LIST
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: LIST
97967: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
97968: LD_ADDR_VAR 0 27
97972: PUSH
97973: LD_INT 3
97975: NEG
97976: PUSH
97977: LD_INT 0
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: LD_INT 3
97986: NEG
97987: PUSH
97988: LD_INT 1
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: LD_INT 4
97997: NEG
97998: PUSH
97999: LD_INT 1
98001: NEG
98002: PUSH
98003: EMPTY
98004: LIST
98005: LIST
98006: PUSH
98007: EMPTY
98008: LIST
98009: LIST
98010: LIST
98011: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
98012: LD_ADDR_VAR 0 28
98016: PUSH
98017: LD_INT 3
98019: NEG
98020: PUSH
98021: LD_INT 3
98023: NEG
98024: PUSH
98025: EMPTY
98026: LIST
98027: LIST
98028: PUSH
98029: LD_INT 3
98031: NEG
98032: PUSH
98033: LD_INT 4
98035: NEG
98036: PUSH
98037: EMPTY
98038: LIST
98039: LIST
98040: PUSH
98041: LD_INT 4
98043: NEG
98044: PUSH
98045: LD_INT 3
98047: NEG
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: LIST
98057: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
98058: LD_ADDR_VAR 0 29
98062: PUSH
98063: LD_INT 1
98065: NEG
98066: PUSH
98067: LD_INT 3
98069: NEG
98070: PUSH
98071: EMPTY
98072: LIST
98073: LIST
98074: PUSH
98075: LD_INT 0
98077: PUSH
98078: LD_INT 3
98080: NEG
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PUSH
98086: LD_INT 1
98088: PUSH
98089: LD_INT 2
98091: NEG
98092: PUSH
98093: EMPTY
98094: LIST
98095: LIST
98096: PUSH
98097: LD_INT 1
98099: NEG
98100: PUSH
98101: LD_INT 4
98103: NEG
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PUSH
98109: LD_INT 0
98111: PUSH
98112: LD_INT 4
98114: NEG
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: PUSH
98120: LD_INT 1
98122: PUSH
98123: LD_INT 3
98125: NEG
98126: PUSH
98127: EMPTY
98128: LIST
98129: LIST
98130: PUSH
98131: LD_INT 1
98133: NEG
98134: PUSH
98135: LD_INT 5
98137: NEG
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: PUSH
98143: LD_INT 0
98145: PUSH
98146: LD_INT 5
98148: NEG
98149: PUSH
98150: EMPTY
98151: LIST
98152: LIST
98153: PUSH
98154: LD_INT 1
98156: PUSH
98157: LD_INT 4
98159: NEG
98160: PUSH
98161: EMPTY
98162: LIST
98163: LIST
98164: PUSH
98165: LD_INT 1
98167: NEG
98168: PUSH
98169: LD_INT 6
98171: NEG
98172: PUSH
98173: EMPTY
98174: LIST
98175: LIST
98176: PUSH
98177: LD_INT 0
98179: PUSH
98180: LD_INT 6
98182: NEG
98183: PUSH
98184: EMPTY
98185: LIST
98186: LIST
98187: PUSH
98188: LD_INT 1
98190: PUSH
98191: LD_INT 5
98193: NEG
98194: PUSH
98195: EMPTY
98196: LIST
98197: LIST
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
98213: LD_ADDR_VAR 0 30
98217: PUSH
98218: LD_INT 2
98220: PUSH
98221: LD_INT 1
98223: NEG
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: PUSH
98229: LD_INT 3
98231: PUSH
98232: LD_INT 0
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PUSH
98239: LD_INT 3
98241: PUSH
98242: LD_INT 1
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: PUSH
98249: LD_INT 3
98251: PUSH
98252: LD_INT 1
98254: NEG
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: PUSH
98260: LD_INT 4
98262: PUSH
98263: LD_INT 0
98265: PUSH
98266: EMPTY
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 4
98272: PUSH
98273: LD_INT 1
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: PUSH
98280: LD_INT 4
98282: PUSH
98283: LD_INT 1
98285: NEG
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PUSH
98291: LD_INT 5
98293: PUSH
98294: LD_INT 0
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: PUSH
98301: LD_INT 5
98303: PUSH
98304: LD_INT 1
98306: PUSH
98307: EMPTY
98308: LIST
98309: LIST
98310: PUSH
98311: LD_INT 5
98313: PUSH
98314: LD_INT 1
98316: NEG
98317: PUSH
98318: EMPTY
98319: LIST
98320: LIST
98321: PUSH
98322: LD_INT 6
98324: PUSH
98325: LD_INT 0
98327: PUSH
98328: EMPTY
98329: LIST
98330: LIST
98331: PUSH
98332: LD_INT 6
98334: PUSH
98335: LD_INT 1
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
98356: LD_ADDR_VAR 0 31
98360: PUSH
98361: LD_INT 3
98363: PUSH
98364: LD_INT 2
98366: PUSH
98367: EMPTY
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 3
98373: PUSH
98374: LD_INT 3
98376: PUSH
98377: EMPTY
98378: LIST
98379: LIST
98380: PUSH
98381: LD_INT 2
98383: PUSH
98384: LD_INT 3
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 4
98393: PUSH
98394: LD_INT 3
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 4
98403: PUSH
98404: LD_INT 4
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 3
98413: PUSH
98414: LD_INT 4
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: LD_INT 5
98423: PUSH
98424: LD_INT 4
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PUSH
98431: LD_INT 5
98433: PUSH
98434: LD_INT 5
98436: PUSH
98437: EMPTY
98438: LIST
98439: LIST
98440: PUSH
98441: LD_INT 4
98443: PUSH
98444: LD_INT 5
98446: PUSH
98447: EMPTY
98448: LIST
98449: LIST
98450: PUSH
98451: LD_INT 6
98453: PUSH
98454: LD_INT 5
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: PUSH
98461: LD_INT 6
98463: PUSH
98464: LD_INT 6
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 5
98473: PUSH
98474: LD_INT 6
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
98495: LD_ADDR_VAR 0 32
98499: PUSH
98500: LD_INT 1
98502: PUSH
98503: LD_INT 3
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: PUSH
98510: LD_INT 0
98512: PUSH
98513: LD_INT 3
98515: PUSH
98516: EMPTY
98517: LIST
98518: LIST
98519: PUSH
98520: LD_INT 1
98522: NEG
98523: PUSH
98524: LD_INT 2
98526: PUSH
98527: EMPTY
98528: LIST
98529: LIST
98530: PUSH
98531: LD_INT 1
98533: PUSH
98534: LD_INT 4
98536: PUSH
98537: EMPTY
98538: LIST
98539: LIST
98540: PUSH
98541: LD_INT 0
98543: PUSH
98544: LD_INT 4
98546: PUSH
98547: EMPTY
98548: LIST
98549: LIST
98550: PUSH
98551: LD_INT 1
98553: NEG
98554: PUSH
98555: LD_INT 3
98557: PUSH
98558: EMPTY
98559: LIST
98560: LIST
98561: PUSH
98562: LD_INT 1
98564: PUSH
98565: LD_INT 5
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 0
98574: PUSH
98575: LD_INT 5
98577: PUSH
98578: EMPTY
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 1
98584: NEG
98585: PUSH
98586: LD_INT 4
98588: PUSH
98589: EMPTY
98590: LIST
98591: LIST
98592: PUSH
98593: LD_INT 1
98595: PUSH
98596: LD_INT 6
98598: PUSH
98599: EMPTY
98600: LIST
98601: LIST
98602: PUSH
98603: LD_INT 0
98605: PUSH
98606: LD_INT 6
98608: PUSH
98609: EMPTY
98610: LIST
98611: LIST
98612: PUSH
98613: LD_INT 1
98615: NEG
98616: PUSH
98617: LD_INT 5
98619: PUSH
98620: EMPTY
98621: LIST
98622: LIST
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
98638: LD_ADDR_VAR 0 33
98642: PUSH
98643: LD_INT 2
98645: NEG
98646: PUSH
98647: LD_INT 1
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 3
98656: NEG
98657: PUSH
98658: LD_INT 0
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 3
98667: NEG
98668: PUSH
98669: LD_INT 1
98671: NEG
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: PUSH
98677: LD_INT 3
98679: NEG
98680: PUSH
98681: LD_INT 1
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: PUSH
98688: LD_INT 4
98690: NEG
98691: PUSH
98692: LD_INT 0
98694: PUSH
98695: EMPTY
98696: LIST
98697: LIST
98698: PUSH
98699: LD_INT 4
98701: NEG
98702: PUSH
98703: LD_INT 1
98705: NEG
98706: PUSH
98707: EMPTY
98708: LIST
98709: LIST
98710: PUSH
98711: LD_INT 4
98713: NEG
98714: PUSH
98715: LD_INT 1
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 5
98724: NEG
98725: PUSH
98726: LD_INT 0
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: LD_INT 5
98735: NEG
98736: PUSH
98737: LD_INT 1
98739: NEG
98740: PUSH
98741: EMPTY
98742: LIST
98743: LIST
98744: PUSH
98745: LD_INT 5
98747: NEG
98748: PUSH
98749: LD_INT 1
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PUSH
98756: LD_INT 6
98758: NEG
98759: PUSH
98760: LD_INT 0
98762: PUSH
98763: EMPTY
98764: LIST
98765: LIST
98766: PUSH
98767: LD_INT 6
98769: NEG
98770: PUSH
98771: LD_INT 1
98773: NEG
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
98793: LD_ADDR_VAR 0 34
98797: PUSH
98798: LD_INT 2
98800: NEG
98801: PUSH
98802: LD_INT 3
98804: NEG
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 3
98812: NEG
98813: PUSH
98814: LD_INT 2
98816: NEG
98817: PUSH
98818: EMPTY
98819: LIST
98820: LIST
98821: PUSH
98822: LD_INT 3
98824: NEG
98825: PUSH
98826: LD_INT 3
98828: NEG
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: PUSH
98834: LD_INT 3
98836: NEG
98837: PUSH
98838: LD_INT 4
98840: NEG
98841: PUSH
98842: EMPTY
98843: LIST
98844: LIST
98845: PUSH
98846: LD_INT 4
98848: NEG
98849: PUSH
98850: LD_INT 3
98852: NEG
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: LD_INT 4
98860: NEG
98861: PUSH
98862: LD_INT 4
98864: NEG
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: LD_INT 4
98872: NEG
98873: PUSH
98874: LD_INT 5
98876: NEG
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: PUSH
98882: LD_INT 5
98884: NEG
98885: PUSH
98886: LD_INT 4
98888: NEG
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PUSH
98894: LD_INT 5
98896: NEG
98897: PUSH
98898: LD_INT 5
98900: NEG
98901: PUSH
98902: EMPTY
98903: LIST
98904: LIST
98905: PUSH
98906: LD_INT 5
98908: NEG
98909: PUSH
98910: LD_INT 6
98912: NEG
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PUSH
98918: LD_INT 6
98920: NEG
98921: PUSH
98922: LD_INT 5
98924: NEG
98925: PUSH
98926: EMPTY
98927: LIST
98928: LIST
98929: PUSH
98930: LD_INT 6
98932: NEG
98933: PUSH
98934: LD_INT 6
98936: NEG
98937: PUSH
98938: EMPTY
98939: LIST
98940: LIST
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: LIST
98953: LIST
98954: LIST
98955: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
98956: LD_ADDR_VAR 0 41
98960: PUSH
98961: LD_INT 0
98963: PUSH
98964: LD_INT 2
98966: NEG
98967: PUSH
98968: EMPTY
98969: LIST
98970: LIST
98971: PUSH
98972: LD_INT 1
98974: NEG
98975: PUSH
98976: LD_INT 3
98978: NEG
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PUSH
98984: LD_INT 1
98986: PUSH
98987: LD_INT 2
98989: NEG
98990: PUSH
98991: EMPTY
98992: LIST
98993: LIST
98994: PUSH
98995: EMPTY
98996: LIST
98997: LIST
98998: LIST
98999: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
99000: LD_ADDR_VAR 0 42
99004: PUSH
99005: LD_INT 2
99007: PUSH
99008: LD_INT 0
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: LD_INT 2
99017: PUSH
99018: LD_INT 1
99020: NEG
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: LD_INT 3
99028: PUSH
99029: LD_INT 1
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: EMPTY
99037: LIST
99038: LIST
99039: LIST
99040: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
99041: LD_ADDR_VAR 0 43
99045: PUSH
99046: LD_INT 2
99048: PUSH
99049: LD_INT 2
99051: PUSH
99052: EMPTY
99053: LIST
99054: LIST
99055: PUSH
99056: LD_INT 3
99058: PUSH
99059: LD_INT 2
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: PUSH
99066: LD_INT 2
99068: PUSH
99069: LD_INT 3
99071: PUSH
99072: EMPTY
99073: LIST
99074: LIST
99075: PUSH
99076: EMPTY
99077: LIST
99078: LIST
99079: LIST
99080: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
99081: LD_ADDR_VAR 0 44
99085: PUSH
99086: LD_INT 0
99088: PUSH
99089: LD_INT 2
99091: PUSH
99092: EMPTY
99093: LIST
99094: LIST
99095: PUSH
99096: LD_INT 1
99098: PUSH
99099: LD_INT 3
99101: PUSH
99102: EMPTY
99103: LIST
99104: LIST
99105: PUSH
99106: LD_INT 1
99108: NEG
99109: PUSH
99110: LD_INT 2
99112: PUSH
99113: EMPTY
99114: LIST
99115: LIST
99116: PUSH
99117: EMPTY
99118: LIST
99119: LIST
99120: LIST
99121: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
99122: LD_ADDR_VAR 0 45
99126: PUSH
99127: LD_INT 2
99129: NEG
99130: PUSH
99131: LD_INT 0
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 2
99140: NEG
99141: PUSH
99142: LD_INT 1
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 3
99151: NEG
99152: PUSH
99153: LD_INT 1
99155: NEG
99156: PUSH
99157: EMPTY
99158: LIST
99159: LIST
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: LIST
99165: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
99166: LD_ADDR_VAR 0 46
99170: PUSH
99171: LD_INT 2
99173: NEG
99174: PUSH
99175: LD_INT 2
99177: NEG
99178: PUSH
99179: EMPTY
99180: LIST
99181: LIST
99182: PUSH
99183: LD_INT 2
99185: NEG
99186: PUSH
99187: LD_INT 3
99189: NEG
99190: PUSH
99191: EMPTY
99192: LIST
99193: LIST
99194: PUSH
99195: LD_INT 3
99197: NEG
99198: PUSH
99199: LD_INT 2
99201: NEG
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: LIST
99211: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
99212: LD_ADDR_VAR 0 47
99216: PUSH
99217: LD_INT 2
99219: NEG
99220: PUSH
99221: LD_INT 3
99223: NEG
99224: PUSH
99225: EMPTY
99226: LIST
99227: LIST
99228: PUSH
99229: LD_INT 1
99231: NEG
99232: PUSH
99233: LD_INT 3
99235: NEG
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: EMPTY
99242: LIST
99243: LIST
99244: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
99245: LD_ADDR_VAR 0 48
99249: PUSH
99250: LD_INT 1
99252: PUSH
99253: LD_INT 2
99255: NEG
99256: PUSH
99257: EMPTY
99258: LIST
99259: LIST
99260: PUSH
99261: LD_INT 2
99263: PUSH
99264: LD_INT 1
99266: NEG
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PUSH
99272: EMPTY
99273: LIST
99274: LIST
99275: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
99276: LD_ADDR_VAR 0 49
99280: PUSH
99281: LD_INT 3
99283: PUSH
99284: LD_INT 1
99286: PUSH
99287: EMPTY
99288: LIST
99289: LIST
99290: PUSH
99291: LD_INT 3
99293: PUSH
99294: LD_INT 2
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: PUSH
99301: EMPTY
99302: LIST
99303: LIST
99304: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
99305: LD_ADDR_VAR 0 50
99309: PUSH
99310: LD_INT 2
99312: PUSH
99313: LD_INT 3
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 1
99322: PUSH
99323: LD_INT 3
99325: PUSH
99326: EMPTY
99327: LIST
99328: LIST
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
99334: LD_ADDR_VAR 0 51
99338: PUSH
99339: LD_INT 1
99341: NEG
99342: PUSH
99343: LD_INT 2
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: PUSH
99350: LD_INT 2
99352: NEG
99353: PUSH
99354: LD_INT 1
99356: PUSH
99357: EMPTY
99358: LIST
99359: LIST
99360: PUSH
99361: EMPTY
99362: LIST
99363: LIST
99364: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
99365: LD_ADDR_VAR 0 52
99369: PUSH
99370: LD_INT 3
99372: NEG
99373: PUSH
99374: LD_INT 1
99376: NEG
99377: PUSH
99378: EMPTY
99379: LIST
99380: LIST
99381: PUSH
99382: LD_INT 3
99384: NEG
99385: PUSH
99386: LD_INT 2
99388: NEG
99389: PUSH
99390: EMPTY
99391: LIST
99392: LIST
99393: PUSH
99394: EMPTY
99395: LIST
99396: LIST
99397: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
99398: LD_ADDR_VAR 0 53
99402: PUSH
99403: LD_INT 1
99405: NEG
99406: PUSH
99407: LD_INT 3
99409: NEG
99410: PUSH
99411: EMPTY
99412: LIST
99413: LIST
99414: PUSH
99415: LD_INT 0
99417: PUSH
99418: LD_INT 3
99420: NEG
99421: PUSH
99422: EMPTY
99423: LIST
99424: LIST
99425: PUSH
99426: LD_INT 1
99428: PUSH
99429: LD_INT 2
99431: NEG
99432: PUSH
99433: EMPTY
99434: LIST
99435: LIST
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: LIST
99441: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
99442: LD_ADDR_VAR 0 54
99446: PUSH
99447: LD_INT 2
99449: PUSH
99450: LD_INT 1
99452: NEG
99453: PUSH
99454: EMPTY
99455: LIST
99456: LIST
99457: PUSH
99458: LD_INT 3
99460: PUSH
99461: LD_INT 0
99463: PUSH
99464: EMPTY
99465: LIST
99466: LIST
99467: PUSH
99468: LD_INT 3
99470: PUSH
99471: LD_INT 1
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: LIST
99482: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
99483: LD_ADDR_VAR 0 55
99487: PUSH
99488: LD_INT 3
99490: PUSH
99491: LD_INT 2
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 3
99500: PUSH
99501: LD_INT 3
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: PUSH
99508: LD_INT 2
99510: PUSH
99511: LD_INT 3
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: LIST
99522: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
99523: LD_ADDR_VAR 0 56
99527: PUSH
99528: LD_INT 1
99530: PUSH
99531: LD_INT 3
99533: PUSH
99534: EMPTY
99535: LIST
99536: LIST
99537: PUSH
99538: LD_INT 0
99540: PUSH
99541: LD_INT 3
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: PUSH
99548: LD_INT 1
99550: NEG
99551: PUSH
99552: LD_INT 2
99554: PUSH
99555: EMPTY
99556: LIST
99557: LIST
99558: PUSH
99559: EMPTY
99560: LIST
99561: LIST
99562: LIST
99563: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
99564: LD_ADDR_VAR 0 57
99568: PUSH
99569: LD_INT 2
99571: NEG
99572: PUSH
99573: LD_INT 1
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: PUSH
99580: LD_INT 3
99582: NEG
99583: PUSH
99584: LD_INT 0
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 3
99593: NEG
99594: PUSH
99595: LD_INT 1
99597: NEG
99598: PUSH
99599: EMPTY
99600: LIST
99601: LIST
99602: PUSH
99603: EMPTY
99604: LIST
99605: LIST
99606: LIST
99607: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
99608: LD_ADDR_VAR 0 58
99612: PUSH
99613: LD_INT 2
99615: NEG
99616: PUSH
99617: LD_INT 3
99619: NEG
99620: PUSH
99621: EMPTY
99622: LIST
99623: LIST
99624: PUSH
99625: LD_INT 3
99627: NEG
99628: PUSH
99629: LD_INT 2
99631: NEG
99632: PUSH
99633: EMPTY
99634: LIST
99635: LIST
99636: PUSH
99637: LD_INT 3
99639: NEG
99640: PUSH
99641: LD_INT 3
99643: NEG
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: LIST
99653: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
99654: LD_ADDR_VAR 0 59
99658: PUSH
99659: LD_INT 1
99661: NEG
99662: PUSH
99663: LD_INT 2
99665: NEG
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: LD_INT 0
99673: PUSH
99674: LD_INT 2
99676: NEG
99677: PUSH
99678: EMPTY
99679: LIST
99680: LIST
99681: PUSH
99682: LD_INT 1
99684: PUSH
99685: LD_INT 1
99687: NEG
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: EMPTY
99694: LIST
99695: LIST
99696: LIST
99697: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
99698: LD_ADDR_VAR 0 60
99702: PUSH
99703: LD_INT 1
99705: PUSH
99706: LD_INT 1
99708: NEG
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: PUSH
99714: LD_INT 2
99716: PUSH
99717: LD_INT 0
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PUSH
99724: LD_INT 2
99726: PUSH
99727: LD_INT 1
99729: PUSH
99730: EMPTY
99731: LIST
99732: LIST
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: LIST
99738: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
99739: LD_ADDR_VAR 0 61
99743: PUSH
99744: LD_INT 2
99746: PUSH
99747: LD_INT 1
99749: PUSH
99750: EMPTY
99751: LIST
99752: LIST
99753: PUSH
99754: LD_INT 2
99756: PUSH
99757: LD_INT 2
99759: PUSH
99760: EMPTY
99761: LIST
99762: LIST
99763: PUSH
99764: LD_INT 1
99766: PUSH
99767: LD_INT 2
99769: PUSH
99770: EMPTY
99771: LIST
99772: LIST
99773: PUSH
99774: EMPTY
99775: LIST
99776: LIST
99777: LIST
99778: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
99779: LD_ADDR_VAR 0 62
99783: PUSH
99784: LD_INT 1
99786: PUSH
99787: LD_INT 2
99789: PUSH
99790: EMPTY
99791: LIST
99792: LIST
99793: PUSH
99794: LD_INT 0
99796: PUSH
99797: LD_INT 2
99799: PUSH
99800: EMPTY
99801: LIST
99802: LIST
99803: PUSH
99804: LD_INT 1
99806: NEG
99807: PUSH
99808: LD_INT 1
99810: PUSH
99811: EMPTY
99812: LIST
99813: LIST
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: LIST
99819: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
99820: LD_ADDR_VAR 0 63
99824: PUSH
99825: LD_INT 1
99827: NEG
99828: PUSH
99829: LD_INT 1
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: PUSH
99836: LD_INT 2
99838: NEG
99839: PUSH
99840: LD_INT 0
99842: PUSH
99843: EMPTY
99844: LIST
99845: LIST
99846: PUSH
99847: LD_INT 2
99849: NEG
99850: PUSH
99851: LD_INT 1
99853: NEG
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: PUSH
99859: EMPTY
99860: LIST
99861: LIST
99862: LIST
99863: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
99864: LD_ADDR_VAR 0 64
99868: PUSH
99869: LD_INT 1
99871: NEG
99872: PUSH
99873: LD_INT 2
99875: NEG
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: PUSH
99881: LD_INT 2
99883: NEG
99884: PUSH
99885: LD_INT 1
99887: NEG
99888: PUSH
99889: EMPTY
99890: LIST
99891: LIST
99892: PUSH
99893: LD_INT 2
99895: NEG
99896: PUSH
99897: LD_INT 2
99899: NEG
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: LIST
99909: ST_TO_ADDR
// end ; 2 :
99910: GO 103176
99912: LD_INT 2
99914: DOUBLE
99915: EQUAL
99916: IFTRUE 99920
99918: GO 103175
99920: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99921: LD_ADDR_VAR 0 29
99925: PUSH
99926: LD_INT 4
99928: PUSH
99929: LD_INT 0
99931: PUSH
99932: EMPTY
99933: LIST
99934: LIST
99935: PUSH
99936: LD_INT 4
99938: PUSH
99939: LD_INT 1
99941: NEG
99942: PUSH
99943: EMPTY
99944: LIST
99945: LIST
99946: PUSH
99947: LD_INT 5
99949: PUSH
99950: LD_INT 0
99952: PUSH
99953: EMPTY
99954: LIST
99955: LIST
99956: PUSH
99957: LD_INT 5
99959: PUSH
99960: LD_INT 1
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PUSH
99967: LD_INT 4
99969: PUSH
99970: LD_INT 1
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: PUSH
99977: LD_INT 3
99979: PUSH
99980: LD_INT 0
99982: PUSH
99983: EMPTY
99984: LIST
99985: LIST
99986: PUSH
99987: LD_INT 3
99989: PUSH
99990: LD_INT 1
99992: NEG
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: PUSH
99998: LD_INT 3
100000: PUSH
100001: LD_INT 2
100003: NEG
100004: PUSH
100005: EMPTY
100006: LIST
100007: LIST
100008: PUSH
100009: LD_INT 5
100011: PUSH
100012: LD_INT 2
100014: PUSH
100015: EMPTY
100016: LIST
100017: LIST
100018: PUSH
100019: LD_INT 3
100021: PUSH
100022: LD_INT 3
100024: PUSH
100025: EMPTY
100026: LIST
100027: LIST
100028: PUSH
100029: LD_INT 3
100031: PUSH
100032: LD_INT 2
100034: PUSH
100035: EMPTY
100036: LIST
100037: LIST
100038: PUSH
100039: LD_INT 4
100041: PUSH
100042: LD_INT 3
100044: PUSH
100045: EMPTY
100046: LIST
100047: LIST
100048: PUSH
100049: LD_INT 4
100051: PUSH
100052: LD_INT 4
100054: PUSH
100055: EMPTY
100056: LIST
100057: LIST
100058: PUSH
100059: LD_INT 3
100061: PUSH
100062: LD_INT 4
100064: PUSH
100065: EMPTY
100066: LIST
100067: LIST
100068: PUSH
100069: LD_INT 2
100071: PUSH
100072: LD_INT 3
100074: PUSH
100075: EMPTY
100076: LIST
100077: LIST
100078: PUSH
100079: LD_INT 2
100081: PUSH
100082: LD_INT 2
100084: PUSH
100085: EMPTY
100086: LIST
100087: LIST
100088: PUSH
100089: LD_INT 4
100091: PUSH
100092: LD_INT 2
100094: PUSH
100095: EMPTY
100096: LIST
100097: LIST
100098: PUSH
100099: LD_INT 2
100101: PUSH
100102: LD_INT 4
100104: PUSH
100105: EMPTY
100106: LIST
100107: LIST
100108: PUSH
100109: LD_INT 0
100111: PUSH
100112: LD_INT 4
100114: PUSH
100115: EMPTY
100116: LIST
100117: LIST
100118: PUSH
100119: LD_INT 0
100121: PUSH
100122: LD_INT 3
100124: PUSH
100125: EMPTY
100126: LIST
100127: LIST
100128: PUSH
100129: LD_INT 1
100131: PUSH
100132: LD_INT 4
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PUSH
100139: LD_INT 1
100141: PUSH
100142: LD_INT 5
100144: PUSH
100145: EMPTY
100146: LIST
100147: LIST
100148: PUSH
100149: LD_INT 0
100151: PUSH
100152: LD_INT 5
100154: PUSH
100155: EMPTY
100156: LIST
100157: LIST
100158: PUSH
100159: LD_INT 1
100161: NEG
100162: PUSH
100163: LD_INT 4
100165: PUSH
100166: EMPTY
100167: LIST
100168: LIST
100169: PUSH
100170: LD_INT 1
100172: NEG
100173: PUSH
100174: LD_INT 3
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: PUSH
100181: LD_INT 2
100183: PUSH
100184: LD_INT 5
100186: PUSH
100187: EMPTY
100188: LIST
100189: LIST
100190: PUSH
100191: LD_INT 2
100193: NEG
100194: PUSH
100195: LD_INT 3
100197: PUSH
100198: EMPTY
100199: LIST
100200: LIST
100201: PUSH
100202: LD_INT 3
100204: NEG
100205: PUSH
100206: LD_INT 0
100208: PUSH
100209: EMPTY
100210: LIST
100211: LIST
100212: PUSH
100213: LD_INT 3
100215: NEG
100216: PUSH
100217: LD_INT 1
100219: NEG
100220: PUSH
100221: EMPTY
100222: LIST
100223: LIST
100224: PUSH
100225: LD_INT 2
100227: NEG
100228: PUSH
100229: LD_INT 0
100231: PUSH
100232: EMPTY
100233: LIST
100234: LIST
100235: PUSH
100236: LD_INT 2
100238: NEG
100239: PUSH
100240: LD_INT 1
100242: PUSH
100243: EMPTY
100244: LIST
100245: LIST
100246: PUSH
100247: LD_INT 3
100249: NEG
100250: PUSH
100251: LD_INT 1
100253: PUSH
100254: EMPTY
100255: LIST
100256: LIST
100257: PUSH
100258: LD_INT 4
100260: NEG
100261: PUSH
100262: LD_INT 0
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: LD_INT 4
100271: NEG
100272: PUSH
100273: LD_INT 1
100275: NEG
100276: PUSH
100277: EMPTY
100278: LIST
100279: LIST
100280: PUSH
100281: LD_INT 4
100283: NEG
100284: PUSH
100285: LD_INT 2
100287: NEG
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: PUSH
100293: LD_INT 2
100295: NEG
100296: PUSH
100297: LD_INT 2
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: PUSH
100304: LD_INT 4
100306: NEG
100307: PUSH
100308: LD_INT 4
100310: NEG
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: LD_INT 4
100318: NEG
100319: PUSH
100320: LD_INT 5
100322: NEG
100323: PUSH
100324: EMPTY
100325: LIST
100326: LIST
100327: PUSH
100328: LD_INT 3
100330: NEG
100331: PUSH
100332: LD_INT 4
100334: NEG
100335: PUSH
100336: EMPTY
100337: LIST
100338: LIST
100339: PUSH
100340: LD_INT 3
100342: NEG
100343: PUSH
100344: LD_INT 3
100346: NEG
100347: PUSH
100348: EMPTY
100349: LIST
100350: LIST
100351: PUSH
100352: LD_INT 4
100354: NEG
100355: PUSH
100356: LD_INT 3
100358: NEG
100359: PUSH
100360: EMPTY
100361: LIST
100362: LIST
100363: PUSH
100364: LD_INT 5
100366: NEG
100367: PUSH
100368: LD_INT 4
100370: NEG
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 5
100378: NEG
100379: PUSH
100380: LD_INT 5
100382: NEG
100383: PUSH
100384: EMPTY
100385: LIST
100386: LIST
100387: PUSH
100388: LD_INT 3
100390: NEG
100391: PUSH
100392: LD_INT 5
100394: NEG
100395: PUSH
100396: EMPTY
100397: LIST
100398: LIST
100399: PUSH
100400: LD_INT 5
100402: NEG
100403: PUSH
100404: LD_INT 3
100406: NEG
100407: PUSH
100408: EMPTY
100409: LIST
100410: LIST
100411: PUSH
100412: EMPTY
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
100459: LD_ADDR_VAR 0 30
100463: PUSH
100464: LD_INT 4
100466: PUSH
100467: LD_INT 4
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: PUSH
100474: LD_INT 4
100476: PUSH
100477: LD_INT 3
100479: PUSH
100480: EMPTY
100481: LIST
100482: LIST
100483: PUSH
100484: LD_INT 5
100486: PUSH
100487: LD_INT 4
100489: PUSH
100490: EMPTY
100491: LIST
100492: LIST
100493: PUSH
100494: LD_INT 5
100496: PUSH
100497: LD_INT 5
100499: PUSH
100500: EMPTY
100501: LIST
100502: LIST
100503: PUSH
100504: LD_INT 4
100506: PUSH
100507: LD_INT 5
100509: PUSH
100510: EMPTY
100511: LIST
100512: LIST
100513: PUSH
100514: LD_INT 3
100516: PUSH
100517: LD_INT 4
100519: PUSH
100520: EMPTY
100521: LIST
100522: LIST
100523: PUSH
100524: LD_INT 3
100526: PUSH
100527: LD_INT 3
100529: PUSH
100530: EMPTY
100531: LIST
100532: LIST
100533: PUSH
100534: LD_INT 5
100536: PUSH
100537: LD_INT 3
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PUSH
100544: LD_INT 3
100546: PUSH
100547: LD_INT 5
100549: PUSH
100550: EMPTY
100551: LIST
100552: LIST
100553: PUSH
100554: LD_INT 0
100556: PUSH
100557: LD_INT 3
100559: PUSH
100560: EMPTY
100561: LIST
100562: LIST
100563: PUSH
100564: LD_INT 0
100566: PUSH
100567: LD_INT 2
100569: PUSH
100570: EMPTY
100571: LIST
100572: LIST
100573: PUSH
100574: LD_INT 1
100576: PUSH
100577: LD_INT 3
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: PUSH
100584: LD_INT 1
100586: PUSH
100587: LD_INT 4
100589: PUSH
100590: EMPTY
100591: LIST
100592: LIST
100593: PUSH
100594: LD_INT 0
100596: PUSH
100597: LD_INT 4
100599: PUSH
100600: EMPTY
100601: LIST
100602: LIST
100603: PUSH
100604: LD_INT 1
100606: NEG
100607: PUSH
100608: LD_INT 3
100610: PUSH
100611: EMPTY
100612: LIST
100613: LIST
100614: PUSH
100615: LD_INT 1
100617: NEG
100618: PUSH
100619: LD_INT 2
100621: PUSH
100622: EMPTY
100623: LIST
100624: LIST
100625: PUSH
100626: LD_INT 2
100628: PUSH
100629: LD_INT 4
100631: PUSH
100632: EMPTY
100633: LIST
100634: LIST
100635: PUSH
100636: LD_INT 2
100638: NEG
100639: PUSH
100640: LD_INT 2
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: PUSH
100647: LD_INT 4
100649: NEG
100650: PUSH
100651: LD_INT 0
100653: PUSH
100654: EMPTY
100655: LIST
100656: LIST
100657: PUSH
100658: LD_INT 4
100660: NEG
100661: PUSH
100662: LD_INT 1
100664: NEG
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: PUSH
100670: LD_INT 3
100672: NEG
100673: PUSH
100674: LD_INT 0
100676: PUSH
100677: EMPTY
100678: LIST
100679: LIST
100680: PUSH
100681: LD_INT 3
100683: NEG
100684: PUSH
100685: LD_INT 1
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: PUSH
100692: LD_INT 4
100694: NEG
100695: PUSH
100696: LD_INT 1
100698: PUSH
100699: EMPTY
100700: LIST
100701: LIST
100702: PUSH
100703: LD_INT 5
100705: NEG
100706: PUSH
100707: LD_INT 0
100709: PUSH
100710: EMPTY
100711: LIST
100712: LIST
100713: PUSH
100714: LD_INT 5
100716: NEG
100717: PUSH
100718: LD_INT 1
100720: NEG
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PUSH
100726: LD_INT 5
100728: NEG
100729: PUSH
100730: LD_INT 2
100732: NEG
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PUSH
100738: LD_INT 3
100740: NEG
100741: PUSH
100742: LD_INT 2
100744: PUSH
100745: EMPTY
100746: LIST
100747: LIST
100748: PUSH
100749: LD_INT 3
100751: NEG
100752: PUSH
100753: LD_INT 3
100755: NEG
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PUSH
100761: LD_INT 3
100763: NEG
100764: PUSH
100765: LD_INT 4
100767: NEG
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: LD_INT 2
100775: NEG
100776: PUSH
100777: LD_INT 3
100779: NEG
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 2
100787: NEG
100788: PUSH
100789: LD_INT 2
100791: NEG
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: LD_INT 3
100799: NEG
100800: PUSH
100801: LD_INT 2
100803: NEG
100804: PUSH
100805: EMPTY
100806: LIST
100807: LIST
100808: PUSH
100809: LD_INT 4
100811: NEG
100812: PUSH
100813: LD_INT 3
100815: NEG
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PUSH
100821: LD_INT 4
100823: NEG
100824: PUSH
100825: LD_INT 4
100827: NEG
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 2
100835: NEG
100836: PUSH
100837: LD_INT 4
100839: NEG
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: PUSH
100845: LD_INT 4
100847: NEG
100848: PUSH
100849: LD_INT 2
100851: NEG
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: PUSH
100857: LD_INT 0
100859: PUSH
100860: LD_INT 4
100862: NEG
100863: PUSH
100864: EMPTY
100865: LIST
100866: LIST
100867: PUSH
100868: LD_INT 0
100870: PUSH
100871: LD_INT 5
100873: NEG
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PUSH
100879: LD_INT 1
100881: PUSH
100882: LD_INT 4
100884: NEG
100885: PUSH
100886: EMPTY
100887: LIST
100888: LIST
100889: PUSH
100890: LD_INT 1
100892: PUSH
100893: LD_INT 3
100895: NEG
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PUSH
100901: LD_INT 0
100903: PUSH
100904: LD_INT 3
100906: NEG
100907: PUSH
100908: EMPTY
100909: LIST
100910: LIST
100911: PUSH
100912: LD_INT 1
100914: NEG
100915: PUSH
100916: LD_INT 4
100918: NEG
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: LD_INT 1
100926: NEG
100927: PUSH
100928: LD_INT 5
100930: NEG
100931: PUSH
100932: EMPTY
100933: LIST
100934: LIST
100935: PUSH
100936: LD_INT 2
100938: PUSH
100939: LD_INT 3
100941: NEG
100942: PUSH
100943: EMPTY
100944: LIST
100945: LIST
100946: PUSH
100947: LD_INT 2
100949: NEG
100950: PUSH
100951: LD_INT 5
100953: NEG
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PUSH
100959: EMPTY
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: LIST
100983: LIST
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: LIST
100994: LIST
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: LIST
101002: LIST
101003: LIST
101004: LIST
101005: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
101006: LD_ADDR_VAR 0 31
101010: PUSH
101011: LD_INT 0
101013: PUSH
101014: LD_INT 4
101016: PUSH
101017: EMPTY
101018: LIST
101019: LIST
101020: PUSH
101021: LD_INT 0
101023: PUSH
101024: LD_INT 3
101026: PUSH
101027: EMPTY
101028: LIST
101029: LIST
101030: PUSH
101031: LD_INT 1
101033: PUSH
101034: LD_INT 4
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PUSH
101041: LD_INT 1
101043: PUSH
101044: LD_INT 5
101046: PUSH
101047: EMPTY
101048: LIST
101049: LIST
101050: PUSH
101051: LD_INT 0
101053: PUSH
101054: LD_INT 5
101056: PUSH
101057: EMPTY
101058: LIST
101059: LIST
101060: PUSH
101061: LD_INT 1
101063: NEG
101064: PUSH
101065: LD_INT 4
101067: PUSH
101068: EMPTY
101069: LIST
101070: LIST
101071: PUSH
101072: LD_INT 1
101074: NEG
101075: PUSH
101076: LD_INT 3
101078: PUSH
101079: EMPTY
101080: LIST
101081: LIST
101082: PUSH
101083: LD_INT 2
101085: PUSH
101086: LD_INT 5
101088: PUSH
101089: EMPTY
101090: LIST
101091: LIST
101092: PUSH
101093: LD_INT 2
101095: NEG
101096: PUSH
101097: LD_INT 3
101099: PUSH
101100: EMPTY
101101: LIST
101102: LIST
101103: PUSH
101104: LD_INT 3
101106: NEG
101107: PUSH
101108: LD_INT 0
101110: PUSH
101111: EMPTY
101112: LIST
101113: LIST
101114: PUSH
101115: LD_INT 3
101117: NEG
101118: PUSH
101119: LD_INT 1
101121: NEG
101122: PUSH
101123: EMPTY
101124: LIST
101125: LIST
101126: PUSH
101127: LD_INT 2
101129: NEG
101130: PUSH
101131: LD_INT 0
101133: PUSH
101134: EMPTY
101135: LIST
101136: LIST
101137: PUSH
101138: LD_INT 2
101140: NEG
101141: PUSH
101142: LD_INT 1
101144: PUSH
101145: EMPTY
101146: LIST
101147: LIST
101148: PUSH
101149: LD_INT 3
101151: NEG
101152: PUSH
101153: LD_INT 1
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: PUSH
101160: LD_INT 4
101162: NEG
101163: PUSH
101164: LD_INT 0
101166: PUSH
101167: EMPTY
101168: LIST
101169: LIST
101170: PUSH
101171: LD_INT 4
101173: NEG
101174: PUSH
101175: LD_INT 1
101177: NEG
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: PUSH
101183: LD_INT 4
101185: NEG
101186: PUSH
101187: LD_INT 2
101189: NEG
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PUSH
101195: LD_INT 2
101197: NEG
101198: PUSH
101199: LD_INT 2
101201: PUSH
101202: EMPTY
101203: LIST
101204: LIST
101205: PUSH
101206: LD_INT 4
101208: NEG
101209: PUSH
101210: LD_INT 4
101212: NEG
101213: PUSH
101214: EMPTY
101215: LIST
101216: LIST
101217: PUSH
101218: LD_INT 4
101220: NEG
101221: PUSH
101222: LD_INT 5
101224: NEG
101225: PUSH
101226: EMPTY
101227: LIST
101228: LIST
101229: PUSH
101230: LD_INT 3
101232: NEG
101233: PUSH
101234: LD_INT 4
101236: NEG
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: PUSH
101242: LD_INT 3
101244: NEG
101245: PUSH
101246: LD_INT 3
101248: NEG
101249: PUSH
101250: EMPTY
101251: LIST
101252: LIST
101253: PUSH
101254: LD_INT 4
101256: NEG
101257: PUSH
101258: LD_INT 3
101260: NEG
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PUSH
101266: LD_INT 5
101268: NEG
101269: PUSH
101270: LD_INT 4
101272: NEG
101273: PUSH
101274: EMPTY
101275: LIST
101276: LIST
101277: PUSH
101278: LD_INT 5
101280: NEG
101281: PUSH
101282: LD_INT 5
101284: NEG
101285: PUSH
101286: EMPTY
101287: LIST
101288: LIST
101289: PUSH
101290: LD_INT 3
101292: NEG
101293: PUSH
101294: LD_INT 5
101296: NEG
101297: PUSH
101298: EMPTY
101299: LIST
101300: LIST
101301: PUSH
101302: LD_INT 5
101304: NEG
101305: PUSH
101306: LD_INT 3
101308: NEG
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PUSH
101314: LD_INT 0
101316: PUSH
101317: LD_INT 3
101319: NEG
101320: PUSH
101321: EMPTY
101322: LIST
101323: LIST
101324: PUSH
101325: LD_INT 0
101327: PUSH
101328: LD_INT 4
101330: NEG
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: LD_INT 1
101338: PUSH
101339: LD_INT 3
101341: NEG
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: PUSH
101347: LD_INT 1
101349: PUSH
101350: LD_INT 2
101352: NEG
101353: PUSH
101354: EMPTY
101355: LIST
101356: LIST
101357: PUSH
101358: LD_INT 0
101360: PUSH
101361: LD_INT 2
101363: NEG
101364: PUSH
101365: EMPTY
101366: LIST
101367: LIST
101368: PUSH
101369: LD_INT 1
101371: NEG
101372: PUSH
101373: LD_INT 3
101375: NEG
101376: PUSH
101377: EMPTY
101378: LIST
101379: LIST
101380: PUSH
101381: LD_INT 1
101383: NEG
101384: PUSH
101385: LD_INT 4
101387: NEG
101388: PUSH
101389: EMPTY
101390: LIST
101391: LIST
101392: PUSH
101393: LD_INT 2
101395: PUSH
101396: LD_INT 2
101398: NEG
101399: PUSH
101400: EMPTY
101401: LIST
101402: LIST
101403: PUSH
101404: LD_INT 2
101406: NEG
101407: PUSH
101408: LD_INT 4
101410: NEG
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 4
101418: PUSH
101419: LD_INT 0
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PUSH
101426: LD_INT 4
101428: PUSH
101429: LD_INT 1
101431: NEG
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PUSH
101437: LD_INT 5
101439: PUSH
101440: LD_INT 0
101442: PUSH
101443: EMPTY
101444: LIST
101445: LIST
101446: PUSH
101447: LD_INT 5
101449: PUSH
101450: LD_INT 1
101452: PUSH
101453: EMPTY
101454: LIST
101455: LIST
101456: PUSH
101457: LD_INT 4
101459: PUSH
101460: LD_INT 1
101462: PUSH
101463: EMPTY
101464: LIST
101465: LIST
101466: PUSH
101467: LD_INT 3
101469: PUSH
101470: LD_INT 0
101472: PUSH
101473: EMPTY
101474: LIST
101475: LIST
101476: PUSH
101477: LD_INT 3
101479: PUSH
101480: LD_INT 1
101482: NEG
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: PUSH
101488: LD_INT 3
101490: PUSH
101491: LD_INT 2
101493: NEG
101494: PUSH
101495: EMPTY
101496: LIST
101497: LIST
101498: PUSH
101499: LD_INT 5
101501: PUSH
101502: LD_INT 2
101504: PUSH
101505: EMPTY
101506: LIST
101507: LIST
101508: PUSH
101509: EMPTY
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: LIST
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: LIST
101531: LIST
101532: LIST
101533: LIST
101534: LIST
101535: LIST
101536: LIST
101537: LIST
101538: LIST
101539: LIST
101540: LIST
101541: LIST
101542: LIST
101543: LIST
101544: LIST
101545: LIST
101546: LIST
101547: LIST
101548: LIST
101549: LIST
101550: LIST
101551: LIST
101552: LIST
101553: LIST
101554: LIST
101555: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
101556: LD_ADDR_VAR 0 32
101560: PUSH
101561: LD_INT 4
101563: NEG
101564: PUSH
101565: LD_INT 0
101567: PUSH
101568: EMPTY
101569: LIST
101570: LIST
101571: PUSH
101572: LD_INT 4
101574: NEG
101575: PUSH
101576: LD_INT 1
101578: NEG
101579: PUSH
101580: EMPTY
101581: LIST
101582: LIST
101583: PUSH
101584: LD_INT 3
101586: NEG
101587: PUSH
101588: LD_INT 0
101590: PUSH
101591: EMPTY
101592: LIST
101593: LIST
101594: PUSH
101595: LD_INT 3
101597: NEG
101598: PUSH
101599: LD_INT 1
101601: PUSH
101602: EMPTY
101603: LIST
101604: LIST
101605: PUSH
101606: LD_INT 4
101608: NEG
101609: PUSH
101610: LD_INT 1
101612: PUSH
101613: EMPTY
101614: LIST
101615: LIST
101616: PUSH
101617: LD_INT 5
101619: NEG
101620: PUSH
101621: LD_INT 0
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: LD_INT 5
101630: NEG
101631: PUSH
101632: LD_INT 1
101634: NEG
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PUSH
101640: LD_INT 5
101642: NEG
101643: PUSH
101644: LD_INT 2
101646: NEG
101647: PUSH
101648: EMPTY
101649: LIST
101650: LIST
101651: PUSH
101652: LD_INT 3
101654: NEG
101655: PUSH
101656: LD_INT 2
101658: PUSH
101659: EMPTY
101660: LIST
101661: LIST
101662: PUSH
101663: LD_INT 3
101665: NEG
101666: PUSH
101667: LD_INT 3
101669: NEG
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: PUSH
101675: LD_INT 3
101677: NEG
101678: PUSH
101679: LD_INT 4
101681: NEG
101682: PUSH
101683: EMPTY
101684: LIST
101685: LIST
101686: PUSH
101687: LD_INT 2
101689: NEG
101690: PUSH
101691: LD_INT 3
101693: NEG
101694: PUSH
101695: EMPTY
101696: LIST
101697: LIST
101698: PUSH
101699: LD_INT 2
101701: NEG
101702: PUSH
101703: LD_INT 2
101705: NEG
101706: PUSH
101707: EMPTY
101708: LIST
101709: LIST
101710: PUSH
101711: LD_INT 3
101713: NEG
101714: PUSH
101715: LD_INT 2
101717: NEG
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: PUSH
101723: LD_INT 4
101725: NEG
101726: PUSH
101727: LD_INT 3
101729: NEG
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: PUSH
101735: LD_INT 4
101737: NEG
101738: PUSH
101739: LD_INT 4
101741: NEG
101742: PUSH
101743: EMPTY
101744: LIST
101745: LIST
101746: PUSH
101747: LD_INT 2
101749: NEG
101750: PUSH
101751: LD_INT 4
101753: NEG
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: LD_INT 4
101761: NEG
101762: PUSH
101763: LD_INT 2
101765: NEG
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PUSH
101771: LD_INT 0
101773: PUSH
101774: LD_INT 4
101776: NEG
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PUSH
101782: LD_INT 0
101784: PUSH
101785: LD_INT 5
101787: NEG
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: PUSH
101793: LD_INT 1
101795: PUSH
101796: LD_INT 4
101798: NEG
101799: PUSH
101800: EMPTY
101801: LIST
101802: LIST
101803: PUSH
101804: LD_INT 1
101806: PUSH
101807: LD_INT 3
101809: NEG
101810: PUSH
101811: EMPTY
101812: LIST
101813: LIST
101814: PUSH
101815: LD_INT 0
101817: PUSH
101818: LD_INT 3
101820: NEG
101821: PUSH
101822: EMPTY
101823: LIST
101824: LIST
101825: PUSH
101826: LD_INT 1
101828: NEG
101829: PUSH
101830: LD_INT 4
101832: NEG
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PUSH
101838: LD_INT 1
101840: NEG
101841: PUSH
101842: LD_INT 5
101844: NEG
101845: PUSH
101846: EMPTY
101847: LIST
101848: LIST
101849: PUSH
101850: LD_INT 2
101852: PUSH
101853: LD_INT 3
101855: NEG
101856: PUSH
101857: EMPTY
101858: LIST
101859: LIST
101860: PUSH
101861: LD_INT 2
101863: NEG
101864: PUSH
101865: LD_INT 5
101867: NEG
101868: PUSH
101869: EMPTY
101870: LIST
101871: LIST
101872: PUSH
101873: LD_INT 3
101875: PUSH
101876: LD_INT 0
101878: PUSH
101879: EMPTY
101880: LIST
101881: LIST
101882: PUSH
101883: LD_INT 3
101885: PUSH
101886: LD_INT 1
101888: NEG
101889: PUSH
101890: EMPTY
101891: LIST
101892: LIST
101893: PUSH
101894: LD_INT 4
101896: PUSH
101897: LD_INT 0
101899: PUSH
101900: EMPTY
101901: LIST
101902: LIST
101903: PUSH
101904: LD_INT 4
101906: PUSH
101907: LD_INT 1
101909: PUSH
101910: EMPTY
101911: LIST
101912: LIST
101913: PUSH
101914: LD_INT 3
101916: PUSH
101917: LD_INT 1
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: PUSH
101924: LD_INT 2
101926: PUSH
101927: LD_INT 0
101929: PUSH
101930: EMPTY
101931: LIST
101932: LIST
101933: PUSH
101934: LD_INT 2
101936: PUSH
101937: LD_INT 1
101939: NEG
101940: PUSH
101941: EMPTY
101942: LIST
101943: LIST
101944: PUSH
101945: LD_INT 2
101947: PUSH
101948: LD_INT 2
101950: NEG
101951: PUSH
101952: EMPTY
101953: LIST
101954: LIST
101955: PUSH
101956: LD_INT 4
101958: PUSH
101959: LD_INT 2
101961: PUSH
101962: EMPTY
101963: LIST
101964: LIST
101965: PUSH
101966: LD_INT 4
101968: PUSH
101969: LD_INT 4
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: PUSH
101976: LD_INT 4
101978: PUSH
101979: LD_INT 3
101981: PUSH
101982: EMPTY
101983: LIST
101984: LIST
101985: PUSH
101986: LD_INT 5
101988: PUSH
101989: LD_INT 4
101991: PUSH
101992: EMPTY
101993: LIST
101994: LIST
101995: PUSH
101996: LD_INT 5
101998: PUSH
101999: LD_INT 5
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PUSH
102006: LD_INT 4
102008: PUSH
102009: LD_INT 5
102011: PUSH
102012: EMPTY
102013: LIST
102014: LIST
102015: PUSH
102016: LD_INT 3
102018: PUSH
102019: LD_INT 4
102021: PUSH
102022: EMPTY
102023: LIST
102024: LIST
102025: PUSH
102026: LD_INT 3
102028: PUSH
102029: LD_INT 3
102031: PUSH
102032: EMPTY
102033: LIST
102034: LIST
102035: PUSH
102036: LD_INT 5
102038: PUSH
102039: LD_INT 3
102041: PUSH
102042: EMPTY
102043: LIST
102044: LIST
102045: PUSH
102046: LD_INT 3
102048: PUSH
102049: LD_INT 5
102051: PUSH
102052: EMPTY
102053: LIST
102054: LIST
102055: PUSH
102056: EMPTY
102057: LIST
102058: LIST
102059: LIST
102060: LIST
102061: LIST
102062: LIST
102063: LIST
102064: LIST
102065: LIST
102066: LIST
102067: LIST
102068: LIST
102069: LIST
102070: LIST
102071: LIST
102072: LIST
102073: LIST
102074: LIST
102075: LIST
102076: LIST
102077: LIST
102078: LIST
102079: LIST
102080: LIST
102081: LIST
102082: LIST
102083: LIST
102084: LIST
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: LIST
102097: LIST
102098: LIST
102099: LIST
102100: LIST
102101: LIST
102102: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
102103: LD_ADDR_VAR 0 33
102107: PUSH
102108: LD_INT 4
102110: NEG
102111: PUSH
102112: LD_INT 4
102114: NEG
102115: PUSH
102116: EMPTY
102117: LIST
102118: LIST
102119: PUSH
102120: LD_INT 4
102122: NEG
102123: PUSH
102124: LD_INT 5
102126: NEG
102127: PUSH
102128: EMPTY
102129: LIST
102130: LIST
102131: PUSH
102132: LD_INT 3
102134: NEG
102135: PUSH
102136: LD_INT 4
102138: NEG
102139: PUSH
102140: EMPTY
102141: LIST
102142: LIST
102143: PUSH
102144: LD_INT 3
102146: NEG
102147: PUSH
102148: LD_INT 3
102150: NEG
102151: PUSH
102152: EMPTY
102153: LIST
102154: LIST
102155: PUSH
102156: LD_INT 4
102158: NEG
102159: PUSH
102160: LD_INT 3
102162: NEG
102163: PUSH
102164: EMPTY
102165: LIST
102166: LIST
102167: PUSH
102168: LD_INT 5
102170: NEG
102171: PUSH
102172: LD_INT 4
102174: NEG
102175: PUSH
102176: EMPTY
102177: LIST
102178: LIST
102179: PUSH
102180: LD_INT 5
102182: NEG
102183: PUSH
102184: LD_INT 5
102186: NEG
102187: PUSH
102188: EMPTY
102189: LIST
102190: LIST
102191: PUSH
102192: LD_INT 3
102194: NEG
102195: PUSH
102196: LD_INT 5
102198: NEG
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 5
102206: NEG
102207: PUSH
102208: LD_INT 3
102210: NEG
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PUSH
102216: LD_INT 0
102218: PUSH
102219: LD_INT 3
102221: NEG
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: PUSH
102227: LD_INT 0
102229: PUSH
102230: LD_INT 4
102232: NEG
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: PUSH
102238: LD_INT 1
102240: PUSH
102241: LD_INT 3
102243: NEG
102244: PUSH
102245: EMPTY
102246: LIST
102247: LIST
102248: PUSH
102249: LD_INT 1
102251: PUSH
102252: LD_INT 2
102254: NEG
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: PUSH
102260: LD_INT 0
102262: PUSH
102263: LD_INT 2
102265: NEG
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: PUSH
102271: LD_INT 1
102273: NEG
102274: PUSH
102275: LD_INT 3
102277: NEG
102278: PUSH
102279: EMPTY
102280: LIST
102281: LIST
102282: PUSH
102283: LD_INT 1
102285: NEG
102286: PUSH
102287: LD_INT 4
102289: NEG
102290: PUSH
102291: EMPTY
102292: LIST
102293: LIST
102294: PUSH
102295: LD_INT 2
102297: PUSH
102298: LD_INT 2
102300: NEG
102301: PUSH
102302: EMPTY
102303: LIST
102304: LIST
102305: PUSH
102306: LD_INT 2
102308: NEG
102309: PUSH
102310: LD_INT 4
102312: NEG
102313: PUSH
102314: EMPTY
102315: LIST
102316: LIST
102317: PUSH
102318: LD_INT 4
102320: PUSH
102321: LD_INT 0
102323: PUSH
102324: EMPTY
102325: LIST
102326: LIST
102327: PUSH
102328: LD_INT 4
102330: PUSH
102331: LD_INT 1
102333: NEG
102334: PUSH
102335: EMPTY
102336: LIST
102337: LIST
102338: PUSH
102339: LD_INT 5
102341: PUSH
102342: LD_INT 0
102344: PUSH
102345: EMPTY
102346: LIST
102347: LIST
102348: PUSH
102349: LD_INT 5
102351: PUSH
102352: LD_INT 1
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: PUSH
102359: LD_INT 4
102361: PUSH
102362: LD_INT 1
102364: PUSH
102365: EMPTY
102366: LIST
102367: LIST
102368: PUSH
102369: LD_INT 3
102371: PUSH
102372: LD_INT 0
102374: PUSH
102375: EMPTY
102376: LIST
102377: LIST
102378: PUSH
102379: LD_INT 3
102381: PUSH
102382: LD_INT 1
102384: NEG
102385: PUSH
102386: EMPTY
102387: LIST
102388: LIST
102389: PUSH
102390: LD_INT 3
102392: PUSH
102393: LD_INT 2
102395: NEG
102396: PUSH
102397: EMPTY
102398: LIST
102399: LIST
102400: PUSH
102401: LD_INT 5
102403: PUSH
102404: LD_INT 2
102406: PUSH
102407: EMPTY
102408: LIST
102409: LIST
102410: PUSH
102411: LD_INT 3
102413: PUSH
102414: LD_INT 3
102416: PUSH
102417: EMPTY
102418: LIST
102419: LIST
102420: PUSH
102421: LD_INT 3
102423: PUSH
102424: LD_INT 2
102426: PUSH
102427: EMPTY
102428: LIST
102429: LIST
102430: PUSH
102431: LD_INT 4
102433: PUSH
102434: LD_INT 3
102436: PUSH
102437: EMPTY
102438: LIST
102439: LIST
102440: PUSH
102441: LD_INT 4
102443: PUSH
102444: LD_INT 4
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: PUSH
102451: LD_INT 3
102453: PUSH
102454: LD_INT 4
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PUSH
102461: LD_INT 2
102463: PUSH
102464: LD_INT 3
102466: PUSH
102467: EMPTY
102468: LIST
102469: LIST
102470: PUSH
102471: LD_INT 2
102473: PUSH
102474: LD_INT 2
102476: PUSH
102477: EMPTY
102478: LIST
102479: LIST
102480: PUSH
102481: LD_INT 4
102483: PUSH
102484: LD_INT 2
102486: PUSH
102487: EMPTY
102488: LIST
102489: LIST
102490: PUSH
102491: LD_INT 2
102493: PUSH
102494: LD_INT 4
102496: PUSH
102497: EMPTY
102498: LIST
102499: LIST
102500: PUSH
102501: LD_INT 0
102503: PUSH
102504: LD_INT 4
102506: PUSH
102507: EMPTY
102508: LIST
102509: LIST
102510: PUSH
102511: LD_INT 0
102513: PUSH
102514: LD_INT 3
102516: PUSH
102517: EMPTY
102518: LIST
102519: LIST
102520: PUSH
102521: LD_INT 1
102523: PUSH
102524: LD_INT 4
102526: PUSH
102527: EMPTY
102528: LIST
102529: LIST
102530: PUSH
102531: LD_INT 1
102533: PUSH
102534: LD_INT 5
102536: PUSH
102537: EMPTY
102538: LIST
102539: LIST
102540: PUSH
102541: LD_INT 0
102543: PUSH
102544: LD_INT 5
102546: PUSH
102547: EMPTY
102548: LIST
102549: LIST
102550: PUSH
102551: LD_INT 1
102553: NEG
102554: PUSH
102555: LD_INT 4
102557: PUSH
102558: EMPTY
102559: LIST
102560: LIST
102561: PUSH
102562: LD_INT 1
102564: NEG
102565: PUSH
102566: LD_INT 3
102568: PUSH
102569: EMPTY
102570: LIST
102571: LIST
102572: PUSH
102573: LD_INT 2
102575: PUSH
102576: LD_INT 5
102578: PUSH
102579: EMPTY
102580: LIST
102581: LIST
102582: PUSH
102583: LD_INT 2
102585: NEG
102586: PUSH
102587: LD_INT 3
102589: PUSH
102590: EMPTY
102591: LIST
102592: LIST
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: LIST
102598: LIST
102599: LIST
102600: LIST
102601: LIST
102602: LIST
102603: LIST
102604: LIST
102605: LIST
102606: LIST
102607: LIST
102608: LIST
102609: LIST
102610: LIST
102611: LIST
102612: LIST
102613: LIST
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: LIST
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: LIST
102624: LIST
102625: LIST
102626: LIST
102627: LIST
102628: LIST
102629: LIST
102630: LIST
102631: LIST
102632: LIST
102633: LIST
102634: LIST
102635: LIST
102636: LIST
102637: LIST
102638: LIST
102639: LIST
102640: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
102641: LD_ADDR_VAR 0 34
102645: PUSH
102646: LD_INT 0
102648: PUSH
102649: LD_INT 4
102651: NEG
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: PUSH
102657: LD_INT 0
102659: PUSH
102660: LD_INT 5
102662: NEG
102663: PUSH
102664: EMPTY
102665: LIST
102666: LIST
102667: PUSH
102668: LD_INT 1
102670: PUSH
102671: LD_INT 4
102673: NEG
102674: PUSH
102675: EMPTY
102676: LIST
102677: LIST
102678: PUSH
102679: LD_INT 1
102681: PUSH
102682: LD_INT 3
102684: NEG
102685: PUSH
102686: EMPTY
102687: LIST
102688: LIST
102689: PUSH
102690: LD_INT 0
102692: PUSH
102693: LD_INT 3
102695: NEG
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: PUSH
102701: LD_INT 1
102703: NEG
102704: PUSH
102705: LD_INT 4
102707: NEG
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: PUSH
102713: LD_INT 1
102715: NEG
102716: PUSH
102717: LD_INT 5
102719: NEG
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 2
102727: PUSH
102728: LD_INT 3
102730: NEG
102731: PUSH
102732: EMPTY
102733: LIST
102734: LIST
102735: PUSH
102736: LD_INT 2
102738: NEG
102739: PUSH
102740: LD_INT 5
102742: NEG
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: PUSH
102748: LD_INT 3
102750: PUSH
102751: LD_INT 0
102753: PUSH
102754: EMPTY
102755: LIST
102756: LIST
102757: PUSH
102758: LD_INT 3
102760: PUSH
102761: LD_INT 1
102763: NEG
102764: PUSH
102765: EMPTY
102766: LIST
102767: LIST
102768: PUSH
102769: LD_INT 4
102771: PUSH
102772: LD_INT 0
102774: PUSH
102775: EMPTY
102776: LIST
102777: LIST
102778: PUSH
102779: LD_INT 4
102781: PUSH
102782: LD_INT 1
102784: PUSH
102785: EMPTY
102786: LIST
102787: LIST
102788: PUSH
102789: LD_INT 3
102791: PUSH
102792: LD_INT 1
102794: PUSH
102795: EMPTY
102796: LIST
102797: LIST
102798: PUSH
102799: LD_INT 2
102801: PUSH
102802: LD_INT 0
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: PUSH
102809: LD_INT 2
102811: PUSH
102812: LD_INT 1
102814: NEG
102815: PUSH
102816: EMPTY
102817: LIST
102818: LIST
102819: PUSH
102820: LD_INT 2
102822: PUSH
102823: LD_INT 2
102825: NEG
102826: PUSH
102827: EMPTY
102828: LIST
102829: LIST
102830: PUSH
102831: LD_INT 4
102833: PUSH
102834: LD_INT 2
102836: PUSH
102837: EMPTY
102838: LIST
102839: LIST
102840: PUSH
102841: LD_INT 4
102843: PUSH
102844: LD_INT 4
102846: PUSH
102847: EMPTY
102848: LIST
102849: LIST
102850: PUSH
102851: LD_INT 4
102853: PUSH
102854: LD_INT 3
102856: PUSH
102857: EMPTY
102858: LIST
102859: LIST
102860: PUSH
102861: LD_INT 5
102863: PUSH
102864: LD_INT 4
102866: PUSH
102867: EMPTY
102868: LIST
102869: LIST
102870: PUSH
102871: LD_INT 5
102873: PUSH
102874: LD_INT 5
102876: PUSH
102877: EMPTY
102878: LIST
102879: LIST
102880: PUSH
102881: LD_INT 4
102883: PUSH
102884: LD_INT 5
102886: PUSH
102887: EMPTY
102888: LIST
102889: LIST
102890: PUSH
102891: LD_INT 3
102893: PUSH
102894: LD_INT 4
102896: PUSH
102897: EMPTY
102898: LIST
102899: LIST
102900: PUSH
102901: LD_INT 3
102903: PUSH
102904: LD_INT 3
102906: PUSH
102907: EMPTY
102908: LIST
102909: LIST
102910: PUSH
102911: LD_INT 5
102913: PUSH
102914: LD_INT 3
102916: PUSH
102917: EMPTY
102918: LIST
102919: LIST
102920: PUSH
102921: LD_INT 3
102923: PUSH
102924: LD_INT 5
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: PUSH
102931: LD_INT 0
102933: PUSH
102934: LD_INT 3
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: PUSH
102941: LD_INT 0
102943: PUSH
102944: LD_INT 2
102946: PUSH
102947: EMPTY
102948: LIST
102949: LIST
102950: PUSH
102951: LD_INT 1
102953: PUSH
102954: LD_INT 3
102956: PUSH
102957: EMPTY
102958: LIST
102959: LIST
102960: PUSH
102961: LD_INT 1
102963: PUSH
102964: LD_INT 4
102966: PUSH
102967: EMPTY
102968: LIST
102969: LIST
102970: PUSH
102971: LD_INT 0
102973: PUSH
102974: LD_INT 4
102976: PUSH
102977: EMPTY
102978: LIST
102979: LIST
102980: PUSH
102981: LD_INT 1
102983: NEG
102984: PUSH
102985: LD_INT 3
102987: PUSH
102988: EMPTY
102989: LIST
102990: LIST
102991: PUSH
102992: LD_INT 1
102994: NEG
102995: PUSH
102996: LD_INT 2
102998: PUSH
102999: EMPTY
103000: LIST
103001: LIST
103002: PUSH
103003: LD_INT 2
103005: PUSH
103006: LD_INT 4
103008: PUSH
103009: EMPTY
103010: LIST
103011: LIST
103012: PUSH
103013: LD_INT 2
103015: NEG
103016: PUSH
103017: LD_INT 2
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 4
103026: NEG
103027: PUSH
103028: LD_INT 0
103030: PUSH
103031: EMPTY
103032: LIST
103033: LIST
103034: PUSH
103035: LD_INT 4
103037: NEG
103038: PUSH
103039: LD_INT 1
103041: NEG
103042: PUSH
103043: EMPTY
103044: LIST
103045: LIST
103046: PUSH
103047: LD_INT 3
103049: NEG
103050: PUSH
103051: LD_INT 0
103053: PUSH
103054: EMPTY
103055: LIST
103056: LIST
103057: PUSH
103058: LD_INT 3
103060: NEG
103061: PUSH
103062: LD_INT 1
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: PUSH
103069: LD_INT 4
103071: NEG
103072: PUSH
103073: LD_INT 1
103075: PUSH
103076: EMPTY
103077: LIST
103078: LIST
103079: PUSH
103080: LD_INT 5
103082: NEG
103083: PUSH
103084: LD_INT 0
103086: PUSH
103087: EMPTY
103088: LIST
103089: LIST
103090: PUSH
103091: LD_INT 5
103093: NEG
103094: PUSH
103095: LD_INT 1
103097: NEG
103098: PUSH
103099: EMPTY
103100: LIST
103101: LIST
103102: PUSH
103103: LD_INT 5
103105: NEG
103106: PUSH
103107: LD_INT 2
103109: NEG
103110: PUSH
103111: EMPTY
103112: LIST
103113: LIST
103114: PUSH
103115: LD_INT 3
103117: NEG
103118: PUSH
103119: LD_INT 2
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: PUSH
103126: EMPTY
103127: LIST
103128: LIST
103129: LIST
103130: LIST
103131: LIST
103132: LIST
103133: LIST
103134: LIST
103135: LIST
103136: LIST
103137: LIST
103138: LIST
103139: LIST
103140: LIST
103141: LIST
103142: LIST
103143: LIST
103144: LIST
103145: LIST
103146: LIST
103147: LIST
103148: LIST
103149: LIST
103150: LIST
103151: LIST
103152: LIST
103153: LIST
103154: LIST
103155: LIST
103156: LIST
103157: LIST
103158: LIST
103159: LIST
103160: LIST
103161: LIST
103162: LIST
103163: LIST
103164: LIST
103165: LIST
103166: LIST
103167: LIST
103168: LIST
103169: LIST
103170: LIST
103171: LIST
103172: ST_TO_ADDR
// end ; end ;
103173: GO 103176
103175: POP
// case btype of b_depot , b_warehouse :
103176: LD_VAR 0 1
103180: PUSH
103181: LD_INT 0
103183: DOUBLE
103184: EQUAL
103185: IFTRUE 103195
103187: LD_INT 1
103189: DOUBLE
103190: EQUAL
103191: IFTRUE 103195
103193: GO 103396
103195: POP
// case nation of nation_american :
103196: LD_VAR 0 5
103200: PUSH
103201: LD_INT 1
103203: DOUBLE
103204: EQUAL
103205: IFTRUE 103209
103207: GO 103265
103209: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
103210: LD_ADDR_VAR 0 9
103214: PUSH
103215: LD_VAR 0 11
103219: PUSH
103220: LD_VAR 0 12
103224: PUSH
103225: LD_VAR 0 13
103229: PUSH
103230: LD_VAR 0 14
103234: PUSH
103235: LD_VAR 0 15
103239: PUSH
103240: LD_VAR 0 16
103244: PUSH
103245: EMPTY
103246: LIST
103247: LIST
103248: LIST
103249: LIST
103250: LIST
103251: LIST
103252: PUSH
103253: LD_VAR 0 4
103257: PUSH
103258: LD_INT 1
103260: PLUS
103261: ARRAY
103262: ST_TO_ADDR
103263: GO 103394
103265: LD_INT 2
103267: DOUBLE
103268: EQUAL
103269: IFTRUE 103273
103271: GO 103329
103273: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
103274: LD_ADDR_VAR 0 9
103278: PUSH
103279: LD_VAR 0 17
103283: PUSH
103284: LD_VAR 0 18
103288: PUSH
103289: LD_VAR 0 19
103293: PUSH
103294: LD_VAR 0 20
103298: PUSH
103299: LD_VAR 0 21
103303: PUSH
103304: LD_VAR 0 22
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: LIST
103313: LIST
103314: LIST
103315: LIST
103316: PUSH
103317: LD_VAR 0 4
103321: PUSH
103322: LD_INT 1
103324: PLUS
103325: ARRAY
103326: ST_TO_ADDR
103327: GO 103394
103329: LD_INT 3
103331: DOUBLE
103332: EQUAL
103333: IFTRUE 103337
103335: GO 103393
103337: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
103338: LD_ADDR_VAR 0 9
103342: PUSH
103343: LD_VAR 0 23
103347: PUSH
103348: LD_VAR 0 24
103352: PUSH
103353: LD_VAR 0 25
103357: PUSH
103358: LD_VAR 0 26
103362: PUSH
103363: LD_VAR 0 27
103367: PUSH
103368: LD_VAR 0 28
103372: PUSH
103373: EMPTY
103374: LIST
103375: LIST
103376: LIST
103377: LIST
103378: LIST
103379: LIST
103380: PUSH
103381: LD_VAR 0 4
103385: PUSH
103386: LD_INT 1
103388: PLUS
103389: ARRAY
103390: ST_TO_ADDR
103391: GO 103394
103393: POP
103394: GO 103949
103396: LD_INT 2
103398: DOUBLE
103399: EQUAL
103400: IFTRUE 103410
103402: LD_INT 3
103404: DOUBLE
103405: EQUAL
103406: IFTRUE 103410
103408: GO 103466
103410: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
103411: LD_ADDR_VAR 0 9
103415: PUSH
103416: LD_VAR 0 29
103420: PUSH
103421: LD_VAR 0 30
103425: PUSH
103426: LD_VAR 0 31
103430: PUSH
103431: LD_VAR 0 32
103435: PUSH
103436: LD_VAR 0 33
103440: PUSH
103441: LD_VAR 0 34
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: LIST
103450: LIST
103451: LIST
103452: LIST
103453: PUSH
103454: LD_VAR 0 4
103458: PUSH
103459: LD_INT 1
103461: PLUS
103462: ARRAY
103463: ST_TO_ADDR
103464: GO 103949
103466: LD_INT 16
103468: DOUBLE
103469: EQUAL
103470: IFTRUE 103528
103472: LD_INT 17
103474: DOUBLE
103475: EQUAL
103476: IFTRUE 103528
103478: LD_INT 18
103480: DOUBLE
103481: EQUAL
103482: IFTRUE 103528
103484: LD_INT 19
103486: DOUBLE
103487: EQUAL
103488: IFTRUE 103528
103490: LD_INT 22
103492: DOUBLE
103493: EQUAL
103494: IFTRUE 103528
103496: LD_INT 20
103498: DOUBLE
103499: EQUAL
103500: IFTRUE 103528
103502: LD_INT 21
103504: DOUBLE
103505: EQUAL
103506: IFTRUE 103528
103508: LD_INT 23
103510: DOUBLE
103511: EQUAL
103512: IFTRUE 103528
103514: LD_INT 24
103516: DOUBLE
103517: EQUAL
103518: IFTRUE 103528
103520: LD_INT 25
103522: DOUBLE
103523: EQUAL
103524: IFTRUE 103528
103526: GO 103584
103528: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
103529: LD_ADDR_VAR 0 9
103533: PUSH
103534: LD_VAR 0 35
103538: PUSH
103539: LD_VAR 0 36
103543: PUSH
103544: LD_VAR 0 37
103548: PUSH
103549: LD_VAR 0 38
103553: PUSH
103554: LD_VAR 0 39
103558: PUSH
103559: LD_VAR 0 40
103563: PUSH
103564: EMPTY
103565: LIST
103566: LIST
103567: LIST
103568: LIST
103569: LIST
103570: LIST
103571: PUSH
103572: LD_VAR 0 4
103576: PUSH
103577: LD_INT 1
103579: PLUS
103580: ARRAY
103581: ST_TO_ADDR
103582: GO 103949
103584: LD_INT 6
103586: DOUBLE
103587: EQUAL
103588: IFTRUE 103640
103590: LD_INT 7
103592: DOUBLE
103593: EQUAL
103594: IFTRUE 103640
103596: LD_INT 8
103598: DOUBLE
103599: EQUAL
103600: IFTRUE 103640
103602: LD_INT 13
103604: DOUBLE
103605: EQUAL
103606: IFTRUE 103640
103608: LD_INT 12
103610: DOUBLE
103611: EQUAL
103612: IFTRUE 103640
103614: LD_INT 15
103616: DOUBLE
103617: EQUAL
103618: IFTRUE 103640
103620: LD_INT 11
103622: DOUBLE
103623: EQUAL
103624: IFTRUE 103640
103626: LD_INT 14
103628: DOUBLE
103629: EQUAL
103630: IFTRUE 103640
103632: LD_INT 10
103634: DOUBLE
103635: EQUAL
103636: IFTRUE 103640
103638: GO 103696
103640: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
103641: LD_ADDR_VAR 0 9
103645: PUSH
103646: LD_VAR 0 41
103650: PUSH
103651: LD_VAR 0 42
103655: PUSH
103656: LD_VAR 0 43
103660: PUSH
103661: LD_VAR 0 44
103665: PUSH
103666: LD_VAR 0 45
103670: PUSH
103671: LD_VAR 0 46
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: LIST
103680: LIST
103681: LIST
103682: LIST
103683: PUSH
103684: LD_VAR 0 4
103688: PUSH
103689: LD_INT 1
103691: PLUS
103692: ARRAY
103693: ST_TO_ADDR
103694: GO 103949
103696: LD_INT 36
103698: DOUBLE
103699: EQUAL
103700: IFTRUE 103704
103702: GO 103760
103704: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
103705: LD_ADDR_VAR 0 9
103709: PUSH
103710: LD_VAR 0 47
103714: PUSH
103715: LD_VAR 0 48
103719: PUSH
103720: LD_VAR 0 49
103724: PUSH
103725: LD_VAR 0 50
103729: PUSH
103730: LD_VAR 0 51
103734: PUSH
103735: LD_VAR 0 52
103739: PUSH
103740: EMPTY
103741: LIST
103742: LIST
103743: LIST
103744: LIST
103745: LIST
103746: LIST
103747: PUSH
103748: LD_VAR 0 4
103752: PUSH
103753: LD_INT 1
103755: PLUS
103756: ARRAY
103757: ST_TO_ADDR
103758: GO 103949
103760: LD_INT 4
103762: DOUBLE
103763: EQUAL
103764: IFTRUE 103786
103766: LD_INT 5
103768: DOUBLE
103769: EQUAL
103770: IFTRUE 103786
103772: LD_INT 34
103774: DOUBLE
103775: EQUAL
103776: IFTRUE 103786
103778: LD_INT 37
103780: DOUBLE
103781: EQUAL
103782: IFTRUE 103786
103784: GO 103842
103786: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
103787: LD_ADDR_VAR 0 9
103791: PUSH
103792: LD_VAR 0 53
103796: PUSH
103797: LD_VAR 0 54
103801: PUSH
103802: LD_VAR 0 55
103806: PUSH
103807: LD_VAR 0 56
103811: PUSH
103812: LD_VAR 0 57
103816: PUSH
103817: LD_VAR 0 58
103821: PUSH
103822: EMPTY
103823: LIST
103824: LIST
103825: LIST
103826: LIST
103827: LIST
103828: LIST
103829: PUSH
103830: LD_VAR 0 4
103834: PUSH
103835: LD_INT 1
103837: PLUS
103838: ARRAY
103839: ST_TO_ADDR
103840: GO 103949
103842: LD_INT 31
103844: DOUBLE
103845: EQUAL
103846: IFTRUE 103892
103848: LD_INT 32
103850: DOUBLE
103851: EQUAL
103852: IFTRUE 103892
103854: LD_INT 33
103856: DOUBLE
103857: EQUAL
103858: IFTRUE 103892
103860: LD_INT 27
103862: DOUBLE
103863: EQUAL
103864: IFTRUE 103892
103866: LD_INT 26
103868: DOUBLE
103869: EQUAL
103870: IFTRUE 103892
103872: LD_INT 28
103874: DOUBLE
103875: EQUAL
103876: IFTRUE 103892
103878: LD_INT 29
103880: DOUBLE
103881: EQUAL
103882: IFTRUE 103892
103884: LD_INT 30
103886: DOUBLE
103887: EQUAL
103888: IFTRUE 103892
103890: GO 103948
103892: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103893: LD_ADDR_VAR 0 9
103897: PUSH
103898: LD_VAR 0 59
103902: PUSH
103903: LD_VAR 0 60
103907: PUSH
103908: LD_VAR 0 61
103912: PUSH
103913: LD_VAR 0 62
103917: PUSH
103918: LD_VAR 0 63
103922: PUSH
103923: LD_VAR 0 64
103927: PUSH
103928: EMPTY
103929: LIST
103930: LIST
103931: LIST
103932: LIST
103933: LIST
103934: LIST
103935: PUSH
103936: LD_VAR 0 4
103940: PUSH
103941: LD_INT 1
103943: PLUS
103944: ARRAY
103945: ST_TO_ADDR
103946: GO 103949
103948: POP
// temp_list2 = [ ] ;
103949: LD_ADDR_VAR 0 10
103953: PUSH
103954: EMPTY
103955: ST_TO_ADDR
// for i in temp_list do
103956: LD_ADDR_VAR 0 8
103960: PUSH
103961: LD_VAR 0 9
103965: PUSH
103966: FOR_IN
103967: IFFALSE 104019
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
103969: LD_ADDR_VAR 0 10
103973: PUSH
103974: LD_VAR 0 10
103978: PUSH
103979: LD_VAR 0 8
103983: PUSH
103984: LD_INT 1
103986: ARRAY
103987: PUSH
103988: LD_VAR 0 2
103992: PLUS
103993: PUSH
103994: LD_VAR 0 8
103998: PUSH
103999: LD_INT 2
104001: ARRAY
104002: PUSH
104003: LD_VAR 0 3
104007: PLUS
104008: PUSH
104009: EMPTY
104010: LIST
104011: LIST
104012: PUSH
104013: EMPTY
104014: LIST
104015: ADD
104016: ST_TO_ADDR
104017: GO 103966
104019: POP
104020: POP
// result = temp_list2 ;
104021: LD_ADDR_VAR 0 7
104025: PUSH
104026: LD_VAR 0 10
104030: ST_TO_ADDR
// end ;
104031: LD_VAR 0 7
104035: RET
// export function EnemyInRange ( unit , dist ) ; begin
104036: LD_INT 0
104038: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
104039: LD_ADDR_VAR 0 3
104043: PUSH
104044: LD_VAR 0 1
104048: PPUSH
104049: CALL_OW 255
104053: PPUSH
104054: LD_VAR 0 1
104058: PPUSH
104059: CALL_OW 250
104063: PPUSH
104064: LD_VAR 0 1
104068: PPUSH
104069: CALL_OW 251
104073: PPUSH
104074: LD_VAR 0 2
104078: PPUSH
104079: CALL 77293 0 4
104083: PUSH
104084: LD_INT 4
104086: ARRAY
104087: ST_TO_ADDR
// end ;
104088: LD_VAR 0 3
104092: RET
// export function PlayerSeeMe ( unit ) ; begin
104093: LD_INT 0
104095: PPUSH
// result := See ( your_side , unit ) ;
104096: LD_ADDR_VAR 0 2
104100: PUSH
104101: LD_OWVAR 2
104105: PPUSH
104106: LD_VAR 0 1
104110: PPUSH
104111: CALL_OW 292
104115: ST_TO_ADDR
// end ;
104116: LD_VAR 0 2
104120: RET
// export function ReverseDir ( unit ) ; begin
104121: LD_INT 0
104123: PPUSH
// if not unit then
104124: LD_VAR 0 1
104128: NOT
104129: IFFALSE 104133
// exit ;
104131: GO 104156
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
104133: LD_ADDR_VAR 0 2
104137: PUSH
104138: LD_VAR 0 1
104142: PPUSH
104143: CALL_OW 254
104147: PUSH
104148: LD_INT 3
104150: PLUS
104151: PUSH
104152: LD_INT 6
104154: MOD
104155: ST_TO_ADDR
// end ;
104156: LD_VAR 0 2
104160: RET
// export function ReverseArray ( array ) ; var i ; begin
104161: LD_INT 0
104163: PPUSH
104164: PPUSH
// if not array then
104165: LD_VAR 0 1
104169: NOT
104170: IFFALSE 104174
// exit ;
104172: GO 104229
// result := [ ] ;
104174: LD_ADDR_VAR 0 2
104178: PUSH
104179: EMPTY
104180: ST_TO_ADDR
// for i := array downto 1 do
104181: LD_ADDR_VAR 0 3
104185: PUSH
104186: DOUBLE
104187: LD_VAR 0 1
104191: INC
104192: ST_TO_ADDR
104193: LD_INT 1
104195: PUSH
104196: FOR_DOWNTO
104197: IFFALSE 104227
// result := Join ( result , array [ i ] ) ;
104199: LD_ADDR_VAR 0 2
104203: PUSH
104204: LD_VAR 0 2
104208: PPUSH
104209: LD_VAR 0 1
104213: PUSH
104214: LD_VAR 0 3
104218: ARRAY
104219: PPUSH
104220: CALL 109071 0 2
104224: ST_TO_ADDR
104225: GO 104196
104227: POP
104228: POP
// end ;
104229: LD_VAR 0 2
104233: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
104234: LD_INT 0
104236: PPUSH
104237: PPUSH
104238: PPUSH
104239: PPUSH
104240: PPUSH
104241: PPUSH
// if not unit or not hexes then
104242: LD_VAR 0 1
104246: NOT
104247: IFTRUE 104256
104249: PUSH
104250: LD_VAR 0 2
104254: NOT
104255: OR
104256: IFFALSE 104260
// exit ;
104258: GO 104383
// dist := 9999 ;
104260: LD_ADDR_VAR 0 5
104264: PUSH
104265: LD_INT 9999
104267: ST_TO_ADDR
// for i = 1 to hexes do
104268: LD_ADDR_VAR 0 4
104272: PUSH
104273: DOUBLE
104274: LD_INT 1
104276: DEC
104277: ST_TO_ADDR
104278: LD_VAR 0 2
104282: PUSH
104283: FOR_TO
104284: IFFALSE 104371
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
104286: LD_ADDR_VAR 0 6
104290: PUSH
104291: LD_VAR 0 1
104295: PPUSH
104296: LD_VAR 0 2
104300: PUSH
104301: LD_VAR 0 4
104305: ARRAY
104306: PUSH
104307: LD_INT 1
104309: ARRAY
104310: PPUSH
104311: LD_VAR 0 2
104315: PUSH
104316: LD_VAR 0 4
104320: ARRAY
104321: PUSH
104322: LD_INT 2
104324: ARRAY
104325: PPUSH
104326: CALL_OW 297
104330: ST_TO_ADDR
// if tdist < dist then
104331: LD_VAR 0 6
104335: PUSH
104336: LD_VAR 0 5
104340: LESS
104341: IFFALSE 104369
// begin hex := hexes [ i ] ;
104343: LD_ADDR_VAR 0 8
104347: PUSH
104348: LD_VAR 0 2
104352: PUSH
104353: LD_VAR 0 4
104357: ARRAY
104358: ST_TO_ADDR
// dist := tdist ;
104359: LD_ADDR_VAR 0 5
104363: PUSH
104364: LD_VAR 0 6
104368: ST_TO_ADDR
// end ; end ;
104369: GO 104283
104371: POP
104372: POP
// result := hex ;
104373: LD_ADDR_VAR 0 3
104377: PUSH
104378: LD_VAR 0 8
104382: ST_TO_ADDR
// end ;
104383: LD_VAR 0 3
104387: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
104388: LD_INT 0
104390: PPUSH
104391: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104392: LD_VAR 0 1
104396: NOT
104397: IFTRUE 104436
104399: PUSH
104400: LD_VAR 0 1
104404: PUSH
104405: LD_INT 21
104407: PUSH
104408: LD_INT 2
104410: PUSH
104411: EMPTY
104412: LIST
104413: LIST
104414: PUSH
104415: LD_INT 23
104417: PUSH
104418: LD_INT 2
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: PUSH
104425: EMPTY
104426: LIST
104427: LIST
104428: PPUSH
104429: CALL_OW 69
104433: IN
104434: NOT
104435: OR
104436: IFFALSE 104440
// exit ;
104438: GO 104487
// for i = 1 to 3 do
104440: LD_ADDR_VAR 0 3
104444: PUSH
104445: DOUBLE
104446: LD_INT 1
104448: DEC
104449: ST_TO_ADDR
104450: LD_INT 3
104452: PUSH
104453: FOR_TO
104454: IFFALSE 104485
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
104456: LD_VAR 0 1
104460: PPUSH
104461: CALL_OW 250
104465: PPUSH
104466: LD_VAR 0 1
104470: PPUSH
104471: CALL_OW 251
104475: PPUSH
104476: LD_INT 1
104478: PPUSH
104479: CALL_OW 453
104483: GO 104453
104485: POP
104486: POP
// end ;
104487: LD_VAR 0 2
104491: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
104492: LD_INT 0
104494: PPUSH
104495: PPUSH
104496: PPUSH
104497: PPUSH
104498: PPUSH
104499: PPUSH
// if not unit or not enemy_unit then
104500: LD_VAR 0 1
104504: NOT
104505: IFTRUE 104514
104507: PUSH
104508: LD_VAR 0 2
104512: NOT
104513: OR
104514: IFFALSE 104518
// exit ;
104516: GO 104989
// if GetLives ( i ) < 250 then
104518: LD_VAR 0 4
104522: PPUSH
104523: CALL_OW 256
104527: PUSH
104528: LD_INT 250
104530: LESS
104531: IFFALSE 104544
// begin ComAutodestruct ( i ) ;
104533: LD_VAR 0 4
104537: PPUSH
104538: CALL 104388 0 1
// exit ;
104542: GO 104989
// end ; x := GetX ( enemy_unit ) ;
104544: LD_ADDR_VAR 0 7
104548: PUSH
104549: LD_VAR 0 2
104553: PPUSH
104554: CALL_OW 250
104558: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
104559: LD_ADDR_VAR 0 8
104563: PUSH
104564: LD_VAR 0 2
104568: PPUSH
104569: CALL_OW 251
104573: ST_TO_ADDR
// if not x or not y then
104574: LD_VAR 0 7
104578: NOT
104579: IFTRUE 104588
104581: PUSH
104582: LD_VAR 0 8
104586: NOT
104587: OR
104588: IFFALSE 104592
// exit ;
104590: GO 104989
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
104592: LD_ADDR_VAR 0 6
104596: PUSH
104597: LD_VAR 0 7
104601: PPUSH
104602: LD_INT 0
104604: PPUSH
104605: LD_INT 4
104607: PPUSH
104608: CALL_OW 272
104612: PUSH
104613: LD_VAR 0 8
104617: PPUSH
104618: LD_INT 0
104620: PPUSH
104621: LD_INT 4
104623: PPUSH
104624: CALL_OW 273
104628: PUSH
104629: EMPTY
104630: LIST
104631: LIST
104632: PUSH
104633: LD_VAR 0 7
104637: PPUSH
104638: LD_INT 1
104640: PPUSH
104641: LD_INT 4
104643: PPUSH
104644: CALL_OW 272
104648: PUSH
104649: LD_VAR 0 8
104653: PPUSH
104654: LD_INT 1
104656: PPUSH
104657: LD_INT 4
104659: PPUSH
104660: CALL_OW 273
104664: PUSH
104665: EMPTY
104666: LIST
104667: LIST
104668: PUSH
104669: LD_VAR 0 7
104673: PPUSH
104674: LD_INT 2
104676: PPUSH
104677: LD_INT 4
104679: PPUSH
104680: CALL_OW 272
104684: PUSH
104685: LD_VAR 0 8
104689: PPUSH
104690: LD_INT 2
104692: PPUSH
104693: LD_INT 4
104695: PPUSH
104696: CALL_OW 273
104700: PUSH
104701: EMPTY
104702: LIST
104703: LIST
104704: PUSH
104705: LD_VAR 0 7
104709: PPUSH
104710: LD_INT 3
104712: PPUSH
104713: LD_INT 4
104715: PPUSH
104716: CALL_OW 272
104720: PUSH
104721: LD_VAR 0 8
104725: PPUSH
104726: LD_INT 3
104728: PPUSH
104729: LD_INT 4
104731: PPUSH
104732: CALL_OW 273
104736: PUSH
104737: EMPTY
104738: LIST
104739: LIST
104740: PUSH
104741: LD_VAR 0 7
104745: PPUSH
104746: LD_INT 4
104748: PPUSH
104749: LD_INT 4
104751: PPUSH
104752: CALL_OW 272
104756: PUSH
104757: LD_VAR 0 8
104761: PPUSH
104762: LD_INT 4
104764: PPUSH
104765: LD_INT 4
104767: PPUSH
104768: CALL_OW 273
104772: PUSH
104773: EMPTY
104774: LIST
104775: LIST
104776: PUSH
104777: LD_VAR 0 7
104781: PPUSH
104782: LD_INT 5
104784: PPUSH
104785: LD_INT 4
104787: PPUSH
104788: CALL_OW 272
104792: PUSH
104793: LD_VAR 0 8
104797: PPUSH
104798: LD_INT 5
104800: PPUSH
104801: LD_INT 4
104803: PPUSH
104804: CALL_OW 273
104808: PUSH
104809: EMPTY
104810: LIST
104811: LIST
104812: PUSH
104813: EMPTY
104814: LIST
104815: LIST
104816: LIST
104817: LIST
104818: LIST
104819: LIST
104820: ST_TO_ADDR
// for i = tmp downto 1 do
104821: LD_ADDR_VAR 0 4
104825: PUSH
104826: DOUBLE
104827: LD_VAR 0 6
104831: INC
104832: ST_TO_ADDR
104833: LD_INT 1
104835: PUSH
104836: FOR_DOWNTO
104837: IFFALSE 104940
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
104839: LD_VAR 0 6
104843: PUSH
104844: LD_VAR 0 4
104848: ARRAY
104849: PUSH
104850: LD_INT 1
104852: ARRAY
104853: PPUSH
104854: LD_VAR 0 6
104858: PUSH
104859: LD_VAR 0 4
104863: ARRAY
104864: PUSH
104865: LD_INT 2
104867: ARRAY
104868: PPUSH
104869: CALL_OW 488
104873: NOT
104874: IFTRUE 104916
104876: PUSH
104877: LD_VAR 0 6
104881: PUSH
104882: LD_VAR 0 4
104886: ARRAY
104887: PUSH
104888: LD_INT 1
104890: ARRAY
104891: PPUSH
104892: LD_VAR 0 6
104896: PUSH
104897: LD_VAR 0 4
104901: ARRAY
104902: PUSH
104903: LD_INT 2
104905: ARRAY
104906: PPUSH
104907: CALL_OW 428
104911: PUSH
104912: LD_INT 0
104914: NONEQUAL
104915: OR
104916: IFFALSE 104938
// tmp := Delete ( tmp , i ) ;
104918: LD_ADDR_VAR 0 6
104922: PUSH
104923: LD_VAR 0 6
104927: PPUSH
104928: LD_VAR 0 4
104932: PPUSH
104933: CALL_OW 3
104937: ST_TO_ADDR
104938: GO 104836
104940: POP
104941: POP
// j := GetClosestHex ( unit , tmp ) ;
104942: LD_ADDR_VAR 0 5
104946: PUSH
104947: LD_VAR 0 1
104951: PPUSH
104952: LD_VAR 0 6
104956: PPUSH
104957: CALL 104234 0 2
104961: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
104962: LD_VAR 0 1
104966: PPUSH
104967: LD_VAR 0 5
104971: PUSH
104972: LD_INT 1
104974: ARRAY
104975: PPUSH
104976: LD_VAR 0 5
104980: PUSH
104981: LD_INT 2
104983: ARRAY
104984: PPUSH
104985: CALL_OW 111
// end ;
104989: LD_VAR 0 3
104993: RET
// export function PrepareApemanSoldier ( ) ; begin
104994: LD_INT 0
104996: PPUSH
// uc_nation := 0 ;
104997: LD_ADDR_OWVAR 21
105001: PUSH
105002: LD_INT 0
105004: ST_TO_ADDR
// hc_sex := sex_male ;
105005: LD_ADDR_OWVAR 27
105009: PUSH
105010: LD_INT 1
105012: ST_TO_ADDR
// hc_name :=  ;
105013: LD_ADDR_OWVAR 26
105017: PUSH
105018: LD_STRING 
105020: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
105021: LD_ADDR_OWVAR 28
105025: PUSH
105026: LD_INT 15
105028: ST_TO_ADDR
// hc_gallery :=  ;
105029: LD_ADDR_OWVAR 33
105033: PUSH
105034: LD_STRING 
105036: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105037: LD_ADDR_OWVAR 31
105041: PUSH
105042: LD_INT 0
105044: PPUSH
105045: LD_INT 3
105047: PPUSH
105048: CALL_OW 12
105052: PUSH
105053: LD_INT 0
105055: PPUSH
105056: LD_INT 3
105058: PPUSH
105059: CALL_OW 12
105063: PUSH
105064: LD_INT 0
105066: PUSH
105067: LD_INT 0
105069: PUSH
105070: EMPTY
105071: LIST
105072: LIST
105073: LIST
105074: LIST
105075: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105076: LD_ADDR_OWVAR 29
105080: PUSH
105081: LD_INT 12
105083: PUSH
105084: LD_INT 12
105086: PUSH
105087: EMPTY
105088: LIST
105089: LIST
105090: ST_TO_ADDR
// end ;
105091: LD_VAR 0 1
105095: RET
// export function PrepareApemanEngineer ( ) ; begin
105096: LD_INT 0
105098: PPUSH
// uc_nation := 0 ;
105099: LD_ADDR_OWVAR 21
105103: PUSH
105104: LD_INT 0
105106: ST_TO_ADDR
// hc_sex := sex_male ;
105107: LD_ADDR_OWVAR 27
105111: PUSH
105112: LD_INT 1
105114: ST_TO_ADDR
// hc_name :=  ;
105115: LD_ADDR_OWVAR 26
105119: PUSH
105120: LD_STRING 
105122: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
105123: LD_ADDR_OWVAR 28
105127: PUSH
105128: LD_INT 16
105130: ST_TO_ADDR
// hc_gallery :=  ;
105131: LD_ADDR_OWVAR 33
105135: PUSH
105136: LD_STRING 
105138: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105139: LD_ADDR_OWVAR 31
105143: PUSH
105144: LD_INT 0
105146: PPUSH
105147: LD_INT 3
105149: PPUSH
105150: CALL_OW 12
105154: PUSH
105155: LD_INT 0
105157: PPUSH
105158: LD_INT 3
105160: PPUSH
105161: CALL_OW 12
105165: PUSH
105166: LD_INT 0
105168: PUSH
105169: LD_INT 0
105171: PUSH
105172: EMPTY
105173: LIST
105174: LIST
105175: LIST
105176: LIST
105177: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105178: LD_ADDR_OWVAR 29
105182: PUSH
105183: LD_INT 12
105185: PUSH
105186: LD_INT 12
105188: PUSH
105189: EMPTY
105190: LIST
105191: LIST
105192: ST_TO_ADDR
// end ;
105193: LD_VAR 0 1
105197: RET
// export function PrepareApeman ( agressivity ) ; begin
105198: LD_INT 0
105200: PPUSH
// uc_side := 0 ;
105201: LD_ADDR_OWVAR 20
105205: PUSH
105206: LD_INT 0
105208: ST_TO_ADDR
// uc_nation := 0 ;
105209: LD_ADDR_OWVAR 21
105213: PUSH
105214: LD_INT 0
105216: ST_TO_ADDR
// hc_sex := sex_male ;
105217: LD_ADDR_OWVAR 27
105221: PUSH
105222: LD_INT 1
105224: ST_TO_ADDR
// hc_class := class_apeman ;
105225: LD_ADDR_OWVAR 28
105229: PUSH
105230: LD_INT 12
105232: ST_TO_ADDR
// hc_gallery :=  ;
105233: LD_ADDR_OWVAR 33
105237: PUSH
105238: LD_STRING 
105240: ST_TO_ADDR
// hc_name :=  ;
105241: LD_ADDR_OWVAR 26
105245: PUSH
105246: LD_STRING 
105248: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105249: LD_ADDR_OWVAR 29
105253: PUSH
105254: LD_INT 12
105256: PUSH
105257: LD_INT 12
105259: PUSH
105260: EMPTY
105261: LIST
105262: LIST
105263: ST_TO_ADDR
// if agressivity = 0 then
105264: LD_VAR 0 1
105268: PUSH
105269: LD_INT 0
105271: EQUAL
105272: IFFALSE 105284
// hc_agressivity := 0 else
105274: LD_ADDR_OWVAR 35
105278: PUSH
105279: LD_INT 0
105281: ST_TO_ADDR
105282: GO 105305
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105284: LD_ADDR_OWVAR 35
105288: PUSH
105289: LD_VAR 0 1
105293: NEG
105294: PPUSH
105295: LD_VAR 0 1
105299: PPUSH
105300: CALL_OW 12
105304: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105305: LD_ADDR_OWVAR 31
105309: PUSH
105310: LD_INT 0
105312: PPUSH
105313: LD_INT 3
105315: PPUSH
105316: CALL_OW 12
105320: PUSH
105321: LD_INT 0
105323: PPUSH
105324: LD_INT 3
105326: PPUSH
105327: CALL_OW 12
105331: PUSH
105332: LD_INT 0
105334: PUSH
105335: LD_INT 0
105337: PUSH
105338: EMPTY
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: ST_TO_ADDR
// end ;
105344: LD_VAR 0 2
105348: RET
// export function PrepareTiger ( agressivity ) ; begin
105349: LD_INT 0
105351: PPUSH
// uc_side := 0 ;
105352: LD_ADDR_OWVAR 20
105356: PUSH
105357: LD_INT 0
105359: ST_TO_ADDR
// uc_nation := 0 ;
105360: LD_ADDR_OWVAR 21
105364: PUSH
105365: LD_INT 0
105367: ST_TO_ADDR
// InitHc ;
105368: CALL_OW 19
// hc_class := class_tiger ;
105372: LD_ADDR_OWVAR 28
105376: PUSH
105377: LD_INT 14
105379: ST_TO_ADDR
// hc_gallery :=  ;
105380: LD_ADDR_OWVAR 33
105384: PUSH
105385: LD_STRING 
105387: ST_TO_ADDR
// hc_name :=  ;
105388: LD_ADDR_OWVAR 26
105392: PUSH
105393: LD_STRING 
105395: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105396: LD_ADDR_OWVAR 35
105400: PUSH
105401: LD_VAR 0 1
105405: NEG
105406: PPUSH
105407: LD_VAR 0 1
105411: PPUSH
105412: CALL_OW 12
105416: ST_TO_ADDR
// end ;
105417: LD_VAR 0 2
105421: RET
// export function PrepareEnchidna ( ) ; begin
105422: LD_INT 0
105424: PPUSH
// uc_side := 0 ;
105425: LD_ADDR_OWVAR 20
105429: PUSH
105430: LD_INT 0
105432: ST_TO_ADDR
// uc_nation := 0 ;
105433: LD_ADDR_OWVAR 21
105437: PUSH
105438: LD_INT 0
105440: ST_TO_ADDR
// InitHc ;
105441: CALL_OW 19
// hc_class := class_baggie ;
105445: LD_ADDR_OWVAR 28
105449: PUSH
105450: LD_INT 13
105452: ST_TO_ADDR
// hc_gallery :=  ;
105453: LD_ADDR_OWVAR 33
105457: PUSH
105458: LD_STRING 
105460: ST_TO_ADDR
// hc_name :=  ;
105461: LD_ADDR_OWVAR 26
105465: PUSH
105466: LD_STRING 
105468: ST_TO_ADDR
// end ;
105469: LD_VAR 0 1
105473: RET
// export function PrepareFrog ( ) ; begin
105474: LD_INT 0
105476: PPUSH
// uc_side := 0 ;
105477: LD_ADDR_OWVAR 20
105481: PUSH
105482: LD_INT 0
105484: ST_TO_ADDR
// uc_nation := 0 ;
105485: LD_ADDR_OWVAR 21
105489: PUSH
105490: LD_INT 0
105492: ST_TO_ADDR
// InitHc ;
105493: CALL_OW 19
// hc_class := class_frog ;
105497: LD_ADDR_OWVAR 28
105501: PUSH
105502: LD_INT 19
105504: ST_TO_ADDR
// hc_gallery :=  ;
105505: LD_ADDR_OWVAR 33
105509: PUSH
105510: LD_STRING 
105512: ST_TO_ADDR
// hc_name :=  ;
105513: LD_ADDR_OWVAR 26
105517: PUSH
105518: LD_STRING 
105520: ST_TO_ADDR
// end ;
105521: LD_VAR 0 1
105525: RET
// export function PrepareFish ( ) ; begin
105526: LD_INT 0
105528: PPUSH
// uc_side := 0 ;
105529: LD_ADDR_OWVAR 20
105533: PUSH
105534: LD_INT 0
105536: ST_TO_ADDR
// uc_nation := 0 ;
105537: LD_ADDR_OWVAR 21
105541: PUSH
105542: LD_INT 0
105544: ST_TO_ADDR
// InitHc ;
105545: CALL_OW 19
// hc_class := class_fish ;
105549: LD_ADDR_OWVAR 28
105553: PUSH
105554: LD_INT 20
105556: ST_TO_ADDR
// hc_gallery :=  ;
105557: LD_ADDR_OWVAR 33
105561: PUSH
105562: LD_STRING 
105564: ST_TO_ADDR
// hc_name :=  ;
105565: LD_ADDR_OWVAR 26
105569: PUSH
105570: LD_STRING 
105572: ST_TO_ADDR
// end ;
105573: LD_VAR 0 1
105577: RET
// export function PrepareBird ( ) ; begin
105578: LD_INT 0
105580: PPUSH
// uc_side := 0 ;
105581: LD_ADDR_OWVAR 20
105585: PUSH
105586: LD_INT 0
105588: ST_TO_ADDR
// uc_nation := 0 ;
105589: LD_ADDR_OWVAR 21
105593: PUSH
105594: LD_INT 0
105596: ST_TO_ADDR
// InitHc ;
105597: CALL_OW 19
// hc_class := class_phororhacos ;
105601: LD_ADDR_OWVAR 28
105605: PUSH
105606: LD_INT 18
105608: ST_TO_ADDR
// hc_gallery :=  ;
105609: LD_ADDR_OWVAR 33
105613: PUSH
105614: LD_STRING 
105616: ST_TO_ADDR
// hc_name :=  ;
105617: LD_ADDR_OWVAR 26
105621: PUSH
105622: LD_STRING 
105624: ST_TO_ADDR
// end ;
105625: LD_VAR 0 1
105629: RET
// export function PrepareHorse ( ) ; begin
105630: LD_INT 0
105632: PPUSH
// uc_side := 0 ;
105633: LD_ADDR_OWVAR 20
105637: PUSH
105638: LD_INT 0
105640: ST_TO_ADDR
// uc_nation := 0 ;
105641: LD_ADDR_OWVAR 21
105645: PUSH
105646: LD_INT 0
105648: ST_TO_ADDR
// InitHc ;
105649: CALL_OW 19
// hc_class := class_horse ;
105653: LD_ADDR_OWVAR 28
105657: PUSH
105658: LD_INT 21
105660: ST_TO_ADDR
// hc_gallery :=  ;
105661: LD_ADDR_OWVAR 33
105665: PUSH
105666: LD_STRING 
105668: ST_TO_ADDR
// hc_name :=  ;
105669: LD_ADDR_OWVAR 26
105673: PUSH
105674: LD_STRING 
105676: ST_TO_ADDR
// end ;
105677: LD_VAR 0 1
105681: RET
// export function PrepareMastodont ( ) ; begin
105682: LD_INT 0
105684: PPUSH
// uc_side := 0 ;
105685: LD_ADDR_OWVAR 20
105689: PUSH
105690: LD_INT 0
105692: ST_TO_ADDR
// uc_nation := 0 ;
105693: LD_ADDR_OWVAR 21
105697: PUSH
105698: LD_INT 0
105700: ST_TO_ADDR
// vc_chassis := class_mastodont ;
105701: LD_ADDR_OWVAR 37
105705: PUSH
105706: LD_INT 31
105708: ST_TO_ADDR
// vc_control := control_rider ;
105709: LD_ADDR_OWVAR 38
105713: PUSH
105714: LD_INT 4
105716: ST_TO_ADDR
// end ;
105717: LD_VAR 0 1
105721: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
105722: LD_INT 0
105724: PPUSH
105725: PPUSH
105726: PPUSH
// uc_side = 0 ;
105727: LD_ADDR_OWVAR 20
105731: PUSH
105732: LD_INT 0
105734: ST_TO_ADDR
// uc_nation = 0 ;
105735: LD_ADDR_OWVAR 21
105739: PUSH
105740: LD_INT 0
105742: ST_TO_ADDR
// InitHc_All ( ) ;
105743: CALL_OW 584
// InitVc ;
105747: CALL_OW 20
// if mastodonts then
105751: LD_VAR 0 6
105755: IFFALSE 105822
// for i = 1 to mastodonts do
105757: LD_ADDR_VAR 0 11
105761: PUSH
105762: DOUBLE
105763: LD_INT 1
105765: DEC
105766: ST_TO_ADDR
105767: LD_VAR 0 6
105771: PUSH
105772: FOR_TO
105773: IFFALSE 105820
// begin vc_chassis := 31 ;
105775: LD_ADDR_OWVAR 37
105779: PUSH
105780: LD_INT 31
105782: ST_TO_ADDR
// vc_control := control_rider ;
105783: LD_ADDR_OWVAR 38
105787: PUSH
105788: LD_INT 4
105790: ST_TO_ADDR
// animal := CreateVehicle ;
105791: LD_ADDR_VAR 0 12
105795: PUSH
105796: CALL_OW 45
105800: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105801: LD_VAR 0 12
105805: PPUSH
105806: LD_VAR 0 8
105810: PPUSH
105811: LD_INT 0
105813: PPUSH
105814: CALL 107964 0 3
// end ;
105818: GO 105772
105820: POP
105821: POP
// if horses then
105822: LD_VAR 0 5
105826: IFFALSE 105893
// for i = 1 to horses do
105828: LD_ADDR_VAR 0 11
105832: PUSH
105833: DOUBLE
105834: LD_INT 1
105836: DEC
105837: ST_TO_ADDR
105838: LD_VAR 0 5
105842: PUSH
105843: FOR_TO
105844: IFFALSE 105891
// begin hc_class := 21 ;
105846: LD_ADDR_OWVAR 28
105850: PUSH
105851: LD_INT 21
105853: ST_TO_ADDR
// hc_gallery :=  ;
105854: LD_ADDR_OWVAR 33
105858: PUSH
105859: LD_STRING 
105861: ST_TO_ADDR
// animal := CreateHuman ;
105862: LD_ADDR_VAR 0 12
105866: PUSH
105867: CALL_OW 44
105871: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105872: LD_VAR 0 12
105876: PPUSH
105877: LD_VAR 0 8
105881: PPUSH
105882: LD_INT 0
105884: PPUSH
105885: CALL 107964 0 3
// end ;
105889: GO 105843
105891: POP
105892: POP
// if birds then
105893: LD_VAR 0 1
105897: IFFALSE 105964
// for i = 1 to birds do
105899: LD_ADDR_VAR 0 11
105903: PUSH
105904: DOUBLE
105905: LD_INT 1
105907: DEC
105908: ST_TO_ADDR
105909: LD_VAR 0 1
105913: PUSH
105914: FOR_TO
105915: IFFALSE 105962
// begin hc_class := 18 ;
105917: LD_ADDR_OWVAR 28
105921: PUSH
105922: LD_INT 18
105924: ST_TO_ADDR
// hc_gallery =  ;
105925: LD_ADDR_OWVAR 33
105929: PUSH
105930: LD_STRING 
105932: ST_TO_ADDR
// animal := CreateHuman ;
105933: LD_ADDR_VAR 0 12
105937: PUSH
105938: CALL_OW 44
105942: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105943: LD_VAR 0 12
105947: PPUSH
105948: LD_VAR 0 8
105952: PPUSH
105953: LD_INT 0
105955: PPUSH
105956: CALL 107964 0 3
// end ;
105960: GO 105914
105962: POP
105963: POP
// if tigers then
105964: LD_VAR 0 2
105968: IFFALSE 106052
// for i = 1 to tigers do
105970: LD_ADDR_VAR 0 11
105974: PUSH
105975: DOUBLE
105976: LD_INT 1
105978: DEC
105979: ST_TO_ADDR
105980: LD_VAR 0 2
105984: PUSH
105985: FOR_TO
105986: IFFALSE 106050
// begin hc_class = class_tiger ;
105988: LD_ADDR_OWVAR 28
105992: PUSH
105993: LD_INT 14
105995: ST_TO_ADDR
// hc_gallery =  ;
105996: LD_ADDR_OWVAR 33
106000: PUSH
106001: LD_STRING 
106003: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
106004: LD_ADDR_OWVAR 35
106008: PUSH
106009: LD_INT 7
106011: NEG
106012: PPUSH
106013: LD_INT 7
106015: PPUSH
106016: CALL_OW 12
106020: ST_TO_ADDR
// animal := CreateHuman ;
106021: LD_ADDR_VAR 0 12
106025: PUSH
106026: CALL_OW 44
106030: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106031: LD_VAR 0 12
106035: PPUSH
106036: LD_VAR 0 8
106040: PPUSH
106041: LD_INT 0
106043: PPUSH
106044: CALL 107964 0 3
// end ;
106048: GO 105985
106050: POP
106051: POP
// if apemans then
106052: LD_VAR 0 3
106056: IFFALSE 106179
// for i = 1 to apemans do
106058: LD_ADDR_VAR 0 11
106062: PUSH
106063: DOUBLE
106064: LD_INT 1
106066: DEC
106067: ST_TO_ADDR
106068: LD_VAR 0 3
106072: PUSH
106073: FOR_TO
106074: IFFALSE 106177
// begin hc_class = class_apeman ;
106076: LD_ADDR_OWVAR 28
106080: PUSH
106081: LD_INT 12
106083: ST_TO_ADDR
// hc_gallery =  ;
106084: LD_ADDR_OWVAR 33
106088: PUSH
106089: LD_STRING 
106091: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
106092: LD_ADDR_OWVAR 35
106096: PUSH
106097: LD_INT 2
106099: NEG
106100: PPUSH
106101: LD_INT 2
106103: PPUSH
106104: CALL_OW 12
106108: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
106109: LD_ADDR_OWVAR 31
106113: PUSH
106114: LD_INT 1
106116: PPUSH
106117: LD_INT 3
106119: PPUSH
106120: CALL_OW 12
106124: PUSH
106125: LD_INT 1
106127: PPUSH
106128: LD_INT 3
106130: PPUSH
106131: CALL_OW 12
106135: PUSH
106136: LD_INT 0
106138: PUSH
106139: LD_INT 0
106141: PUSH
106142: EMPTY
106143: LIST
106144: LIST
106145: LIST
106146: LIST
106147: ST_TO_ADDR
// animal := CreateHuman ;
106148: LD_ADDR_VAR 0 12
106152: PUSH
106153: CALL_OW 44
106157: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106158: LD_VAR 0 12
106162: PPUSH
106163: LD_VAR 0 8
106167: PPUSH
106168: LD_INT 0
106170: PPUSH
106171: CALL 107964 0 3
// end ;
106175: GO 106073
106177: POP
106178: POP
// if enchidnas then
106179: LD_VAR 0 4
106183: IFFALSE 106250
// for i = 1 to enchidnas do
106185: LD_ADDR_VAR 0 11
106189: PUSH
106190: DOUBLE
106191: LD_INT 1
106193: DEC
106194: ST_TO_ADDR
106195: LD_VAR 0 4
106199: PUSH
106200: FOR_TO
106201: IFFALSE 106248
// begin hc_class = 13 ;
106203: LD_ADDR_OWVAR 28
106207: PUSH
106208: LD_INT 13
106210: ST_TO_ADDR
// hc_gallery =  ;
106211: LD_ADDR_OWVAR 33
106215: PUSH
106216: LD_STRING 
106218: ST_TO_ADDR
// animal := CreateHuman ;
106219: LD_ADDR_VAR 0 12
106223: PUSH
106224: CALL_OW 44
106228: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106229: LD_VAR 0 12
106233: PPUSH
106234: LD_VAR 0 8
106238: PPUSH
106239: LD_INT 0
106241: PPUSH
106242: CALL 107964 0 3
// end ;
106246: GO 106200
106248: POP
106249: POP
// if fishes then
106250: LD_VAR 0 7
106254: IFFALSE 106321
// for i = 1 to fishes do
106256: LD_ADDR_VAR 0 11
106260: PUSH
106261: DOUBLE
106262: LD_INT 1
106264: DEC
106265: ST_TO_ADDR
106266: LD_VAR 0 7
106270: PUSH
106271: FOR_TO
106272: IFFALSE 106319
// begin hc_class = 20 ;
106274: LD_ADDR_OWVAR 28
106278: PUSH
106279: LD_INT 20
106281: ST_TO_ADDR
// hc_gallery =  ;
106282: LD_ADDR_OWVAR 33
106286: PUSH
106287: LD_STRING 
106289: ST_TO_ADDR
// animal := CreateHuman ;
106290: LD_ADDR_VAR 0 12
106294: PUSH
106295: CALL_OW 44
106299: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
106300: LD_VAR 0 12
106304: PPUSH
106305: LD_VAR 0 9
106309: PPUSH
106310: LD_INT 0
106312: PPUSH
106313: CALL 107964 0 3
// end ;
106317: GO 106271
106319: POP
106320: POP
// end ;
106321: LD_VAR 0 10
106325: RET
// export function WantHeal ( sci , unit ) ; begin
106326: LD_INT 0
106328: PPUSH
// if GetTaskList ( sci ) > 0 then
106329: LD_VAR 0 1
106333: PPUSH
106334: CALL_OW 437
106338: PUSH
106339: LD_INT 0
106341: GREATER
106342: IFFALSE 106414
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
106344: LD_VAR 0 1
106348: PPUSH
106349: CALL_OW 437
106353: PUSH
106354: LD_INT 1
106356: ARRAY
106357: PUSH
106358: LD_INT 1
106360: ARRAY
106361: PUSH
106362: LD_STRING l
106364: EQUAL
106365: IFFALSE 106392
106367: PUSH
106368: LD_VAR 0 1
106372: PPUSH
106373: CALL_OW 437
106377: PUSH
106378: LD_INT 1
106380: ARRAY
106381: PUSH
106382: LD_INT 4
106384: ARRAY
106385: PUSH
106386: LD_VAR 0 2
106390: EQUAL
106391: AND
106392: IFFALSE 106404
// result := true else
106394: LD_ADDR_VAR 0 3
106398: PUSH
106399: LD_INT 1
106401: ST_TO_ADDR
106402: GO 106412
// result := false ;
106404: LD_ADDR_VAR 0 3
106408: PUSH
106409: LD_INT 0
106411: ST_TO_ADDR
// end else
106412: GO 106422
// result := false ;
106414: LD_ADDR_VAR 0 3
106418: PUSH
106419: LD_INT 0
106421: ST_TO_ADDR
// end ;
106422: LD_VAR 0 3
106426: RET
// export function HealTarget ( sci ) ; begin
106427: LD_INT 0
106429: PPUSH
// if not sci then
106430: LD_VAR 0 1
106434: NOT
106435: IFFALSE 106439
// exit ;
106437: GO 106504
// result := 0 ;
106439: LD_ADDR_VAR 0 2
106443: PUSH
106444: LD_INT 0
106446: ST_TO_ADDR
// if GetTaskList ( sci ) then
106447: LD_VAR 0 1
106451: PPUSH
106452: CALL_OW 437
106456: IFFALSE 106504
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
106458: LD_VAR 0 1
106462: PPUSH
106463: CALL_OW 437
106467: PUSH
106468: LD_INT 1
106470: ARRAY
106471: PUSH
106472: LD_INT 1
106474: ARRAY
106475: PUSH
106476: LD_STRING l
106478: EQUAL
106479: IFFALSE 106504
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
106481: LD_ADDR_VAR 0 2
106485: PUSH
106486: LD_VAR 0 1
106490: PPUSH
106491: CALL_OW 437
106495: PUSH
106496: LD_INT 1
106498: ARRAY
106499: PUSH
106500: LD_INT 4
106502: ARRAY
106503: ST_TO_ADDR
// end ;
106504: LD_VAR 0 2
106508: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
106509: LD_INT 0
106511: PPUSH
106512: PPUSH
106513: PPUSH
106514: PPUSH
// if not base_units then
106515: LD_VAR 0 1
106519: NOT
106520: IFFALSE 106524
// exit ;
106522: GO 106611
// result := false ;
106524: LD_ADDR_VAR 0 2
106528: PUSH
106529: LD_INT 0
106531: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
106532: LD_ADDR_VAR 0 5
106536: PUSH
106537: LD_VAR 0 1
106541: PPUSH
106542: LD_INT 21
106544: PUSH
106545: LD_INT 3
106547: PUSH
106548: EMPTY
106549: LIST
106550: LIST
106551: PPUSH
106552: CALL_OW 72
106556: ST_TO_ADDR
// if not tmp then
106557: LD_VAR 0 5
106561: NOT
106562: IFFALSE 106566
// exit ;
106564: GO 106611
// for i in tmp do
106566: LD_ADDR_VAR 0 3
106570: PUSH
106571: LD_VAR 0 5
106575: PUSH
106576: FOR_IN
106577: IFFALSE 106609
// begin result := EnemyInRange ( i , 22 ) ;
106579: LD_ADDR_VAR 0 2
106583: PUSH
106584: LD_VAR 0 3
106588: PPUSH
106589: LD_INT 22
106591: PPUSH
106592: CALL 104036 0 2
106596: ST_TO_ADDR
// if result then
106597: LD_VAR 0 2
106601: IFFALSE 106607
// exit ;
106603: POP
106604: POP
106605: GO 106611
// end ;
106607: GO 106576
106609: POP
106610: POP
// end ;
106611: LD_VAR 0 2
106615: RET
// export function FilterByTag ( units , tag ) ; begin
106616: LD_INT 0
106618: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
106619: LD_ADDR_VAR 0 3
106623: PUSH
106624: LD_VAR 0 1
106628: PPUSH
106629: LD_INT 120
106631: PUSH
106632: LD_VAR 0 2
106636: PUSH
106637: EMPTY
106638: LIST
106639: LIST
106640: PPUSH
106641: CALL_OW 72
106645: ST_TO_ADDR
// end ;
106646: LD_VAR 0 3
106650: RET
// export function IsDriver ( un ) ; begin
106651: LD_INT 0
106653: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
106654: LD_ADDR_VAR 0 2
106658: PUSH
106659: LD_VAR 0 1
106663: PUSH
106664: LD_INT 55
106666: PUSH
106667: EMPTY
106668: LIST
106669: PPUSH
106670: CALL_OW 69
106674: IN
106675: ST_TO_ADDR
// end ;
106676: LD_VAR 0 2
106680: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
106681: LD_INT 0
106683: PPUSH
106684: PPUSH
// list := [ ] ;
106685: LD_ADDR_VAR 0 5
106689: PUSH
106690: EMPTY
106691: ST_TO_ADDR
// case d of 0 :
106692: LD_VAR 0 3
106696: PUSH
106697: LD_INT 0
106699: DOUBLE
106700: EQUAL
106701: IFTRUE 106705
106703: GO 106838
106705: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
106706: LD_ADDR_VAR 0 5
106710: PUSH
106711: LD_VAR 0 1
106715: PUSH
106716: LD_INT 4
106718: MINUS
106719: PUSH
106720: LD_VAR 0 2
106724: PUSH
106725: LD_INT 4
106727: MINUS
106728: PUSH
106729: LD_INT 2
106731: PUSH
106732: EMPTY
106733: LIST
106734: LIST
106735: LIST
106736: PUSH
106737: LD_VAR 0 1
106741: PUSH
106742: LD_INT 3
106744: MINUS
106745: PUSH
106746: LD_VAR 0 2
106750: PUSH
106751: LD_INT 1
106753: PUSH
106754: EMPTY
106755: LIST
106756: LIST
106757: LIST
106758: PUSH
106759: LD_VAR 0 1
106763: PUSH
106764: LD_INT 4
106766: PLUS
106767: PUSH
106768: LD_VAR 0 2
106772: PUSH
106773: LD_INT 4
106775: PUSH
106776: EMPTY
106777: LIST
106778: LIST
106779: LIST
106780: PUSH
106781: LD_VAR 0 1
106785: PUSH
106786: LD_INT 3
106788: PLUS
106789: PUSH
106790: LD_VAR 0 2
106794: PUSH
106795: LD_INT 3
106797: PLUS
106798: PUSH
106799: LD_INT 5
106801: PUSH
106802: EMPTY
106803: LIST
106804: LIST
106805: LIST
106806: PUSH
106807: LD_VAR 0 1
106811: PUSH
106812: LD_VAR 0 2
106816: PUSH
106817: LD_INT 4
106819: PLUS
106820: PUSH
106821: LD_INT 0
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: LIST
106828: PUSH
106829: EMPTY
106830: LIST
106831: LIST
106832: LIST
106833: LIST
106834: LIST
106835: ST_TO_ADDR
// end ; 1 :
106836: GO 107536
106838: LD_INT 1
106840: DOUBLE
106841: EQUAL
106842: IFTRUE 106846
106844: GO 106979
106846: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
106847: LD_ADDR_VAR 0 5
106851: PUSH
106852: LD_VAR 0 1
106856: PUSH
106857: LD_VAR 0 2
106861: PUSH
106862: LD_INT 4
106864: MINUS
106865: PUSH
106866: LD_INT 3
106868: PUSH
106869: EMPTY
106870: LIST
106871: LIST
106872: LIST
106873: PUSH
106874: LD_VAR 0 1
106878: PUSH
106879: LD_INT 3
106881: MINUS
106882: PUSH
106883: LD_VAR 0 2
106887: PUSH
106888: LD_INT 3
106890: MINUS
106891: PUSH
106892: LD_INT 2
106894: PUSH
106895: EMPTY
106896: LIST
106897: LIST
106898: LIST
106899: PUSH
106900: LD_VAR 0 1
106904: PUSH
106905: LD_INT 4
106907: MINUS
106908: PUSH
106909: LD_VAR 0 2
106913: PUSH
106914: LD_INT 1
106916: PUSH
106917: EMPTY
106918: LIST
106919: LIST
106920: LIST
106921: PUSH
106922: LD_VAR 0 1
106926: PUSH
106927: LD_VAR 0 2
106931: PUSH
106932: LD_INT 3
106934: PLUS
106935: PUSH
106936: LD_INT 0
106938: PUSH
106939: EMPTY
106940: LIST
106941: LIST
106942: LIST
106943: PUSH
106944: LD_VAR 0 1
106948: PUSH
106949: LD_INT 4
106951: PLUS
106952: PUSH
106953: LD_VAR 0 2
106957: PUSH
106958: LD_INT 4
106960: PLUS
106961: PUSH
106962: LD_INT 5
106964: PUSH
106965: EMPTY
106966: LIST
106967: LIST
106968: LIST
106969: PUSH
106970: EMPTY
106971: LIST
106972: LIST
106973: LIST
106974: LIST
106975: LIST
106976: ST_TO_ADDR
// end ; 2 :
106977: GO 107536
106979: LD_INT 2
106981: DOUBLE
106982: EQUAL
106983: IFTRUE 106987
106985: GO 107116
106987: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
106988: LD_ADDR_VAR 0 5
106992: PUSH
106993: LD_VAR 0 1
106997: PUSH
106998: LD_VAR 0 2
107002: PUSH
107003: LD_INT 3
107005: MINUS
107006: PUSH
107007: LD_INT 3
107009: PUSH
107010: EMPTY
107011: LIST
107012: LIST
107013: LIST
107014: PUSH
107015: LD_VAR 0 1
107019: PUSH
107020: LD_INT 4
107022: PLUS
107023: PUSH
107024: LD_VAR 0 2
107028: PUSH
107029: LD_INT 4
107031: PUSH
107032: EMPTY
107033: LIST
107034: LIST
107035: LIST
107036: PUSH
107037: LD_VAR 0 1
107041: PUSH
107042: LD_VAR 0 2
107046: PUSH
107047: LD_INT 4
107049: PLUS
107050: PUSH
107051: LD_INT 0
107053: PUSH
107054: EMPTY
107055: LIST
107056: LIST
107057: LIST
107058: PUSH
107059: LD_VAR 0 1
107063: PUSH
107064: LD_INT 3
107066: MINUS
107067: PUSH
107068: LD_VAR 0 2
107072: PUSH
107073: LD_INT 1
107075: PUSH
107076: EMPTY
107077: LIST
107078: LIST
107079: LIST
107080: PUSH
107081: LD_VAR 0 1
107085: PUSH
107086: LD_INT 4
107088: MINUS
107089: PUSH
107090: LD_VAR 0 2
107094: PUSH
107095: LD_INT 4
107097: MINUS
107098: PUSH
107099: LD_INT 2
107101: PUSH
107102: EMPTY
107103: LIST
107104: LIST
107105: LIST
107106: PUSH
107107: EMPTY
107108: LIST
107109: LIST
107110: LIST
107111: LIST
107112: LIST
107113: ST_TO_ADDR
// end ; 3 :
107114: GO 107536
107116: LD_INT 3
107118: DOUBLE
107119: EQUAL
107120: IFTRUE 107124
107122: GO 107257
107124: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
107125: LD_ADDR_VAR 0 5
107129: PUSH
107130: LD_VAR 0 1
107134: PUSH
107135: LD_INT 3
107137: PLUS
107138: PUSH
107139: LD_VAR 0 2
107143: PUSH
107144: LD_INT 4
107146: PUSH
107147: EMPTY
107148: LIST
107149: LIST
107150: LIST
107151: PUSH
107152: LD_VAR 0 1
107156: PUSH
107157: LD_INT 4
107159: PLUS
107160: PUSH
107161: LD_VAR 0 2
107165: PUSH
107166: LD_INT 4
107168: PLUS
107169: PUSH
107170: LD_INT 5
107172: PUSH
107173: EMPTY
107174: LIST
107175: LIST
107176: LIST
107177: PUSH
107178: LD_VAR 0 1
107182: PUSH
107183: LD_INT 4
107185: MINUS
107186: PUSH
107187: LD_VAR 0 2
107191: PUSH
107192: LD_INT 1
107194: PUSH
107195: EMPTY
107196: LIST
107197: LIST
107198: LIST
107199: PUSH
107200: LD_VAR 0 1
107204: PUSH
107205: LD_VAR 0 2
107209: PUSH
107210: LD_INT 4
107212: MINUS
107213: PUSH
107214: LD_INT 3
107216: PUSH
107217: EMPTY
107218: LIST
107219: LIST
107220: LIST
107221: PUSH
107222: LD_VAR 0 1
107226: PUSH
107227: LD_INT 3
107229: MINUS
107230: PUSH
107231: LD_VAR 0 2
107235: PUSH
107236: LD_INT 3
107238: MINUS
107239: PUSH
107240: LD_INT 2
107242: PUSH
107243: EMPTY
107244: LIST
107245: LIST
107246: LIST
107247: PUSH
107248: EMPTY
107249: LIST
107250: LIST
107251: LIST
107252: LIST
107253: LIST
107254: ST_TO_ADDR
// end ; 4 :
107255: GO 107536
107257: LD_INT 4
107259: DOUBLE
107260: EQUAL
107261: IFTRUE 107265
107263: GO 107398
107265: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
107266: LD_ADDR_VAR 0 5
107270: PUSH
107271: LD_VAR 0 1
107275: PUSH
107276: LD_VAR 0 2
107280: PUSH
107281: LD_INT 4
107283: PLUS
107284: PUSH
107285: LD_INT 0
107287: PUSH
107288: EMPTY
107289: LIST
107290: LIST
107291: LIST
107292: PUSH
107293: LD_VAR 0 1
107297: PUSH
107298: LD_INT 3
107300: PLUS
107301: PUSH
107302: LD_VAR 0 2
107306: PUSH
107307: LD_INT 3
107309: PLUS
107310: PUSH
107311: LD_INT 5
107313: PUSH
107314: EMPTY
107315: LIST
107316: LIST
107317: LIST
107318: PUSH
107319: LD_VAR 0 1
107323: PUSH
107324: LD_INT 4
107326: PLUS
107327: PUSH
107328: LD_VAR 0 2
107332: PUSH
107333: LD_INT 4
107335: PUSH
107336: EMPTY
107337: LIST
107338: LIST
107339: LIST
107340: PUSH
107341: LD_VAR 0 1
107345: PUSH
107346: LD_VAR 0 2
107350: PUSH
107351: LD_INT 3
107353: MINUS
107354: PUSH
107355: LD_INT 3
107357: PUSH
107358: EMPTY
107359: LIST
107360: LIST
107361: LIST
107362: PUSH
107363: LD_VAR 0 1
107367: PUSH
107368: LD_INT 4
107370: MINUS
107371: PUSH
107372: LD_VAR 0 2
107376: PUSH
107377: LD_INT 4
107379: MINUS
107380: PUSH
107381: LD_INT 2
107383: PUSH
107384: EMPTY
107385: LIST
107386: LIST
107387: LIST
107388: PUSH
107389: EMPTY
107390: LIST
107391: LIST
107392: LIST
107393: LIST
107394: LIST
107395: ST_TO_ADDR
// end ; 5 :
107396: GO 107536
107398: LD_INT 5
107400: DOUBLE
107401: EQUAL
107402: IFTRUE 107406
107404: GO 107535
107406: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
107407: LD_ADDR_VAR 0 5
107411: PUSH
107412: LD_VAR 0 1
107416: PUSH
107417: LD_INT 4
107419: MINUS
107420: PUSH
107421: LD_VAR 0 2
107425: PUSH
107426: LD_INT 1
107428: PUSH
107429: EMPTY
107430: LIST
107431: LIST
107432: LIST
107433: PUSH
107434: LD_VAR 0 1
107438: PUSH
107439: LD_VAR 0 2
107443: PUSH
107444: LD_INT 4
107446: MINUS
107447: PUSH
107448: LD_INT 3
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: LIST
107455: PUSH
107456: LD_VAR 0 1
107460: PUSH
107461: LD_INT 4
107463: PLUS
107464: PUSH
107465: LD_VAR 0 2
107469: PUSH
107470: LD_INT 4
107472: PLUS
107473: PUSH
107474: LD_INT 5
107476: PUSH
107477: EMPTY
107478: LIST
107479: LIST
107480: LIST
107481: PUSH
107482: LD_VAR 0 1
107486: PUSH
107487: LD_INT 3
107489: PLUS
107490: PUSH
107491: LD_VAR 0 2
107495: PUSH
107496: LD_INT 4
107498: PUSH
107499: EMPTY
107500: LIST
107501: LIST
107502: LIST
107503: PUSH
107504: LD_VAR 0 1
107508: PUSH
107509: LD_VAR 0 2
107513: PUSH
107514: LD_INT 3
107516: PLUS
107517: PUSH
107518: LD_INT 0
107520: PUSH
107521: EMPTY
107522: LIST
107523: LIST
107524: LIST
107525: PUSH
107526: EMPTY
107527: LIST
107528: LIST
107529: LIST
107530: LIST
107531: LIST
107532: ST_TO_ADDR
// end ; end ;
107533: GO 107536
107535: POP
// result := list ;
107536: LD_ADDR_VAR 0 4
107540: PUSH
107541: LD_VAR 0 5
107545: ST_TO_ADDR
// end ;
107546: LD_VAR 0 4
107550: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
107551: LD_INT 0
107553: PPUSH
107554: PPUSH
107555: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
107556: LD_VAR 0 1
107560: NOT
107561: IFTRUE 107589
107563: PUSH
107564: LD_VAR 0 2
107568: PUSH
107569: LD_INT 1
107571: PUSH
107572: LD_INT 2
107574: PUSH
107575: LD_INT 3
107577: PUSH
107578: LD_INT 4
107580: PUSH
107581: EMPTY
107582: LIST
107583: LIST
107584: LIST
107585: LIST
107586: IN
107587: NOT
107588: OR
107589: IFFALSE 107593
// exit ;
107591: GO 107676
// tmp := [ ] ;
107593: LD_ADDR_VAR 0 5
107597: PUSH
107598: EMPTY
107599: ST_TO_ADDR
// for i in units do
107600: LD_ADDR_VAR 0 4
107604: PUSH
107605: LD_VAR 0 1
107609: PUSH
107610: FOR_IN
107611: IFFALSE 107645
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
107613: LD_ADDR_VAR 0 5
107617: PUSH
107618: LD_VAR 0 5
107622: PPUSH
107623: LD_VAR 0 4
107627: PPUSH
107628: LD_VAR 0 2
107632: PPUSH
107633: CALL_OW 259
107637: PPUSH
107638: CALL 109071 0 2
107642: ST_TO_ADDR
107643: GO 107610
107645: POP
107646: POP
// if not tmp then
107647: LD_VAR 0 5
107651: NOT
107652: IFFALSE 107656
// exit ;
107654: GO 107676
// result := SortListByListDesc ( units , tmp ) ;
107656: LD_ADDR_VAR 0 3
107660: PUSH
107661: LD_VAR 0 1
107665: PPUSH
107666: LD_VAR 0 5
107670: PPUSH
107671: CALL_OW 77
107675: ST_TO_ADDR
// end ;
107676: LD_VAR 0 3
107680: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
107681: LD_INT 0
107683: PPUSH
107684: PPUSH
107685: PPUSH
// result := false ;
107686: LD_ADDR_VAR 0 3
107690: PUSH
107691: LD_INT 0
107693: ST_TO_ADDR
// if not building then
107694: LD_VAR 0 2
107698: NOT
107699: IFFALSE 107703
// exit ;
107701: GO 107847
// x := GetX ( building ) ;
107703: LD_ADDR_VAR 0 4
107707: PUSH
107708: LD_VAR 0 2
107712: PPUSH
107713: CALL_OW 250
107717: ST_TO_ADDR
// y := GetY ( building ) ;
107718: LD_ADDR_VAR 0 5
107722: PUSH
107723: LD_VAR 0 2
107727: PPUSH
107728: CALL_OW 251
107732: ST_TO_ADDR
// if not x or not y then
107733: LD_VAR 0 4
107737: NOT
107738: IFTRUE 107747
107740: PUSH
107741: LD_VAR 0 5
107745: NOT
107746: OR
107747: IFFALSE 107751
// exit ;
107749: GO 107847
// if GetTaskList ( unit ) then
107751: LD_VAR 0 1
107755: PPUSH
107756: CALL_OW 437
107760: IFFALSE 107847
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107762: LD_STRING e
107764: PUSH
107765: LD_VAR 0 1
107769: PPUSH
107770: CALL_OW 437
107774: PUSH
107775: LD_INT 1
107777: ARRAY
107778: PUSH
107779: LD_INT 1
107781: ARRAY
107782: EQUAL
107783: IFFALSE 107810
107785: PUSH
107786: LD_VAR 0 4
107790: PUSH
107791: LD_VAR 0 1
107795: PPUSH
107796: CALL_OW 437
107800: PUSH
107801: LD_INT 1
107803: ARRAY
107804: PUSH
107805: LD_INT 2
107807: ARRAY
107808: EQUAL
107809: AND
107810: IFFALSE 107837
107812: PUSH
107813: LD_VAR 0 5
107817: PUSH
107818: LD_VAR 0 1
107822: PPUSH
107823: CALL_OW 437
107827: PUSH
107828: LD_INT 1
107830: ARRAY
107831: PUSH
107832: LD_INT 3
107834: ARRAY
107835: EQUAL
107836: AND
107837: IFFALSE 107847
// result := true end ;
107839: LD_ADDR_VAR 0 3
107843: PUSH
107844: LD_INT 1
107846: ST_TO_ADDR
// end ;
107847: LD_VAR 0 3
107851: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
107852: LD_INT 0
107854: PPUSH
// result := false ;
107855: LD_ADDR_VAR 0 4
107859: PUSH
107860: LD_INT 0
107862: ST_TO_ADDR
// if GetTaskList ( unit ) then
107863: LD_VAR 0 1
107867: PPUSH
107868: CALL_OW 437
107872: IFFALSE 107959
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107874: LD_STRING M
107876: PUSH
107877: LD_VAR 0 1
107881: PPUSH
107882: CALL_OW 437
107886: PUSH
107887: LD_INT 1
107889: ARRAY
107890: PUSH
107891: LD_INT 1
107893: ARRAY
107894: EQUAL
107895: IFFALSE 107922
107897: PUSH
107898: LD_VAR 0 2
107902: PUSH
107903: LD_VAR 0 1
107907: PPUSH
107908: CALL_OW 437
107912: PUSH
107913: LD_INT 1
107915: ARRAY
107916: PUSH
107917: LD_INT 2
107919: ARRAY
107920: EQUAL
107921: AND
107922: IFFALSE 107949
107924: PUSH
107925: LD_VAR 0 3
107929: PUSH
107930: LD_VAR 0 1
107934: PPUSH
107935: CALL_OW 437
107939: PUSH
107940: LD_INT 1
107942: ARRAY
107943: PUSH
107944: LD_INT 3
107946: ARRAY
107947: EQUAL
107948: AND
107949: IFFALSE 107959
// result := true ;
107951: LD_ADDR_VAR 0 4
107955: PUSH
107956: LD_INT 1
107958: ST_TO_ADDR
// end ; end ;
107959: LD_VAR 0 4
107963: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
107964: LD_INT 0
107966: PPUSH
107967: PPUSH
107968: PPUSH
107969: PPUSH
// if not unit or not area then
107970: LD_VAR 0 1
107974: NOT
107975: IFTRUE 107984
107977: PUSH
107978: LD_VAR 0 2
107982: NOT
107983: OR
107984: IFFALSE 107988
// exit ;
107986: GO 108164
// tmp := AreaToList ( area , i ) ;
107988: LD_ADDR_VAR 0 6
107992: PUSH
107993: LD_VAR 0 2
107997: PPUSH
107998: LD_VAR 0 5
108002: PPUSH
108003: CALL_OW 517
108007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
108008: LD_ADDR_VAR 0 5
108012: PUSH
108013: DOUBLE
108014: LD_INT 1
108016: DEC
108017: ST_TO_ADDR
108018: LD_VAR 0 6
108022: PUSH
108023: LD_INT 1
108025: ARRAY
108026: PUSH
108027: FOR_TO
108028: IFFALSE 108162
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
108030: LD_ADDR_VAR 0 7
108034: PUSH
108035: LD_VAR 0 6
108039: PUSH
108040: LD_INT 1
108042: ARRAY
108043: PUSH
108044: LD_VAR 0 5
108048: ARRAY
108049: PUSH
108050: LD_VAR 0 6
108054: PUSH
108055: LD_INT 2
108057: ARRAY
108058: PUSH
108059: LD_VAR 0 5
108063: ARRAY
108064: PUSH
108065: EMPTY
108066: LIST
108067: LIST
108068: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
108069: LD_INT 92
108071: PUSH
108072: LD_VAR 0 7
108076: PUSH
108077: LD_INT 1
108079: ARRAY
108080: PUSH
108081: LD_VAR 0 7
108085: PUSH
108086: LD_INT 2
108088: ARRAY
108089: PUSH
108090: LD_INT 2
108092: PUSH
108093: EMPTY
108094: LIST
108095: LIST
108096: LIST
108097: LIST
108098: PPUSH
108099: CALL_OW 69
108103: PUSH
108104: LD_INT 0
108106: EQUAL
108107: IFFALSE 108160
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
108109: LD_VAR 0 1
108113: PPUSH
108114: LD_VAR 0 7
108118: PUSH
108119: LD_INT 1
108121: ARRAY
108122: PPUSH
108123: LD_VAR 0 7
108127: PUSH
108128: LD_INT 2
108130: ARRAY
108131: PPUSH
108132: LD_VAR 0 3
108136: PPUSH
108137: CALL_OW 48
// result := IsPlaced ( unit ) ;
108141: LD_ADDR_VAR 0 4
108145: PUSH
108146: LD_VAR 0 1
108150: PPUSH
108151: CALL_OW 305
108155: ST_TO_ADDR
// exit ;
108156: POP
108157: POP
108158: GO 108164
// end ; end ;
108160: GO 108027
108162: POP
108163: POP
// end ;
108164: LD_VAR 0 4
108168: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
108169: LD_INT 0
108171: PPUSH
108172: PPUSH
108173: PPUSH
// if not side or side > 8 then
108174: LD_VAR 0 1
108178: NOT
108179: IFTRUE 108191
108181: PUSH
108182: LD_VAR 0 1
108186: PUSH
108187: LD_INT 8
108189: GREATER
108190: OR
108191: IFFALSE 108195
// exit ;
108193: GO 108382
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
108195: LD_ADDR_VAR 0 4
108199: PUSH
108200: LD_INT 22
108202: PUSH
108203: LD_VAR 0 1
108207: PUSH
108208: EMPTY
108209: LIST
108210: LIST
108211: PUSH
108212: LD_INT 21
108214: PUSH
108215: LD_INT 3
108217: PUSH
108218: EMPTY
108219: LIST
108220: LIST
108221: PUSH
108222: EMPTY
108223: LIST
108224: LIST
108225: PPUSH
108226: CALL_OW 69
108230: ST_TO_ADDR
// if not tmp then
108231: LD_VAR 0 4
108235: NOT
108236: IFFALSE 108240
// exit ;
108238: GO 108382
// enable_addtolog := true ;
108240: LD_ADDR_OWVAR 81
108244: PUSH
108245: LD_INT 1
108247: ST_TO_ADDR
// AddToLog ( [ ) ;
108248: LD_STRING [
108250: PPUSH
108251: CALL_OW 561
// for i in tmp do
108255: LD_ADDR_VAR 0 3
108259: PUSH
108260: LD_VAR 0 4
108264: PUSH
108265: FOR_IN
108266: IFFALSE 108373
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
108268: LD_STRING [
108270: PUSH
108271: LD_VAR 0 3
108275: PPUSH
108276: CALL_OW 266
108280: STR
108281: PUSH
108282: LD_STRING , 
108284: STR
108285: PUSH
108286: LD_VAR 0 3
108290: PPUSH
108291: CALL_OW 250
108295: STR
108296: PUSH
108297: LD_STRING , 
108299: STR
108300: PUSH
108301: LD_VAR 0 3
108305: PPUSH
108306: CALL_OW 251
108310: STR
108311: PUSH
108312: LD_STRING , 
108314: STR
108315: PUSH
108316: LD_VAR 0 3
108320: PPUSH
108321: CALL_OW 254
108325: STR
108326: PUSH
108327: LD_STRING , 
108329: STR
108330: PUSH
108331: LD_VAR 0 3
108335: PPUSH
108336: LD_INT 1
108338: PPUSH
108339: CALL_OW 268
108343: STR
108344: PUSH
108345: LD_STRING , 
108347: STR
108348: PUSH
108349: LD_VAR 0 3
108353: PPUSH
108354: LD_INT 2
108356: PPUSH
108357: CALL_OW 268
108361: STR
108362: PUSH
108363: LD_STRING ],
108365: STR
108366: PPUSH
108367: CALL_OW 561
// end ;
108371: GO 108265
108373: POP
108374: POP
// AddToLog ( ]; ) ;
108375: LD_STRING ];
108377: PPUSH
108378: CALL_OW 561
// end ;
108382: LD_VAR 0 2
108386: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
108387: LD_INT 0
108389: PPUSH
108390: PPUSH
108391: PPUSH
108392: PPUSH
108393: PPUSH
// if not area or not rate or not max then
108394: LD_VAR 0 1
108398: NOT
108399: IFTRUE 108408
108401: PUSH
108402: LD_VAR 0 2
108406: NOT
108407: OR
108408: IFTRUE 108417
108410: PUSH
108411: LD_VAR 0 4
108415: NOT
108416: OR
108417: IFFALSE 108421
// exit ;
108419: GO 108610
// while 1 do
108421: LD_INT 1
108423: IFFALSE 108610
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
108425: LD_ADDR_VAR 0 9
108429: PUSH
108430: LD_VAR 0 1
108434: PPUSH
108435: LD_INT 1
108437: PPUSH
108438: CALL_OW 287
108442: PUSH
108443: LD_INT 10
108445: MUL
108446: ST_TO_ADDR
// r := rate / 10 ;
108447: LD_ADDR_VAR 0 7
108451: PUSH
108452: LD_VAR 0 2
108456: PUSH
108457: LD_INT 10
108459: DIVREAL
108460: ST_TO_ADDR
// time := 1 1$00 ;
108461: LD_ADDR_VAR 0 8
108465: PUSH
108466: LD_INT 2100
108468: ST_TO_ADDR
// if amount < min then
108469: LD_VAR 0 9
108473: PUSH
108474: LD_VAR 0 3
108478: LESS
108479: IFFALSE 108497
// r := r * 2 else
108481: LD_ADDR_VAR 0 7
108485: PUSH
108486: LD_VAR 0 7
108490: PUSH
108491: LD_INT 2
108493: MUL
108494: ST_TO_ADDR
108495: GO 108523
// if amount > max then
108497: LD_VAR 0 9
108501: PUSH
108502: LD_VAR 0 4
108506: GREATER
108507: IFFALSE 108523
// r := r / 2 ;
108509: LD_ADDR_VAR 0 7
108513: PUSH
108514: LD_VAR 0 7
108518: PUSH
108519: LD_INT 2
108521: DIVREAL
108522: ST_TO_ADDR
// time := time / r ;
108523: LD_ADDR_VAR 0 8
108527: PUSH
108528: LD_VAR 0 8
108532: PUSH
108533: LD_VAR 0 7
108537: DIVREAL
108538: ST_TO_ADDR
// if time < 0 then
108539: LD_VAR 0 8
108543: PUSH
108544: LD_INT 0
108546: LESS
108547: IFFALSE 108564
// time := time * - 1 ;
108549: LD_ADDR_VAR 0 8
108553: PUSH
108554: LD_VAR 0 8
108558: PUSH
108559: LD_INT 1
108561: NEG
108562: MUL
108563: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
108564: LD_VAR 0 8
108568: PUSH
108569: LD_INT 35
108571: PPUSH
108572: LD_INT 875
108574: PPUSH
108575: CALL_OW 12
108579: PLUS
108580: PPUSH
108581: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
108585: LD_INT 1
108587: PPUSH
108588: LD_INT 5
108590: PPUSH
108591: CALL_OW 12
108595: PPUSH
108596: LD_VAR 0 1
108600: PPUSH
108601: LD_INT 1
108603: PPUSH
108604: CALL_OW 55
// end ;
108608: GO 108421
// end ;
108610: LD_VAR 0 5
108614: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
108615: LD_INT 0
108617: PPUSH
108618: PPUSH
108619: PPUSH
108620: PPUSH
108621: PPUSH
108622: PPUSH
108623: PPUSH
108624: PPUSH
// if not turrets or not factories then
108625: LD_VAR 0 1
108629: NOT
108630: IFTRUE 108639
108632: PUSH
108633: LD_VAR 0 2
108637: NOT
108638: OR
108639: IFFALSE 108643
// exit ;
108641: GO 108950
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
108643: LD_ADDR_VAR 0 10
108647: PUSH
108648: LD_INT 5
108650: PUSH
108651: LD_INT 6
108653: PUSH
108654: EMPTY
108655: LIST
108656: LIST
108657: PUSH
108658: LD_INT 2
108660: PUSH
108661: LD_INT 4
108663: PUSH
108664: EMPTY
108665: LIST
108666: LIST
108667: PUSH
108668: LD_INT 3
108670: PUSH
108671: LD_INT 5
108673: PUSH
108674: EMPTY
108675: LIST
108676: LIST
108677: PUSH
108678: EMPTY
108679: LIST
108680: LIST
108681: LIST
108682: PUSH
108683: LD_INT 24
108685: PUSH
108686: LD_INT 25
108688: PUSH
108689: EMPTY
108690: LIST
108691: LIST
108692: PUSH
108693: LD_INT 23
108695: PUSH
108696: LD_INT 27
108698: PUSH
108699: EMPTY
108700: LIST
108701: LIST
108702: PUSH
108703: EMPTY
108704: LIST
108705: LIST
108706: PUSH
108707: LD_INT 42
108709: PUSH
108710: LD_INT 43
108712: PUSH
108713: EMPTY
108714: LIST
108715: LIST
108716: PUSH
108717: LD_INT 44
108719: PUSH
108720: LD_INT 46
108722: PUSH
108723: EMPTY
108724: LIST
108725: LIST
108726: PUSH
108727: LD_INT 45
108729: PUSH
108730: LD_INT 47
108732: PUSH
108733: EMPTY
108734: LIST
108735: LIST
108736: PUSH
108737: EMPTY
108738: LIST
108739: LIST
108740: LIST
108741: PUSH
108742: EMPTY
108743: LIST
108744: LIST
108745: LIST
108746: ST_TO_ADDR
// result := [ ] ;
108747: LD_ADDR_VAR 0 3
108751: PUSH
108752: EMPTY
108753: ST_TO_ADDR
// for i in turrets do
108754: LD_ADDR_VAR 0 4
108758: PUSH
108759: LD_VAR 0 1
108763: PUSH
108764: FOR_IN
108765: IFFALSE 108948
// begin nat := GetNation ( i ) ;
108767: LD_ADDR_VAR 0 7
108771: PUSH
108772: LD_VAR 0 4
108776: PPUSH
108777: CALL_OW 248
108781: ST_TO_ADDR
// weapon := 0 ;
108782: LD_ADDR_VAR 0 8
108786: PUSH
108787: LD_INT 0
108789: ST_TO_ADDR
// if not nat then
108790: LD_VAR 0 7
108794: NOT
108795: IFFALSE 108799
// continue ;
108797: GO 108764
// for j in list [ nat ] do
108799: LD_ADDR_VAR 0 5
108803: PUSH
108804: LD_VAR 0 10
108808: PUSH
108809: LD_VAR 0 7
108813: ARRAY
108814: PUSH
108815: FOR_IN
108816: IFFALSE 108857
// if GetBWeapon ( i ) = j [ 1 ] then
108818: LD_VAR 0 4
108822: PPUSH
108823: CALL_OW 269
108827: PUSH
108828: LD_VAR 0 5
108832: PUSH
108833: LD_INT 1
108835: ARRAY
108836: EQUAL
108837: IFFALSE 108855
// begin weapon := j [ 2 ] ;
108839: LD_ADDR_VAR 0 8
108843: PUSH
108844: LD_VAR 0 5
108848: PUSH
108849: LD_INT 2
108851: ARRAY
108852: ST_TO_ADDR
// break ;
108853: GO 108857
// end ;
108855: GO 108815
108857: POP
108858: POP
// if not weapon then
108859: LD_VAR 0 8
108863: NOT
108864: IFFALSE 108868
// continue ;
108866: GO 108764
// for k in factories do
108868: LD_ADDR_VAR 0 6
108872: PUSH
108873: LD_VAR 0 2
108877: PUSH
108878: FOR_IN
108879: IFFALSE 108944
// begin weapons := AvailableWeaponList ( k ) ;
108881: LD_ADDR_VAR 0 9
108885: PUSH
108886: LD_VAR 0 6
108890: PPUSH
108891: CALL_OW 478
108895: ST_TO_ADDR
// if not weapons then
108896: LD_VAR 0 9
108900: NOT
108901: IFFALSE 108905
// continue ;
108903: GO 108878
// if weapon in weapons then
108905: LD_VAR 0 8
108909: PUSH
108910: LD_VAR 0 9
108914: IN
108915: IFFALSE 108942
// begin result := [ i , weapon ] ;
108917: LD_ADDR_VAR 0 3
108921: PUSH
108922: LD_VAR 0 4
108926: PUSH
108927: LD_VAR 0 8
108931: PUSH
108932: EMPTY
108933: LIST
108934: LIST
108935: ST_TO_ADDR
// exit ;
108936: POP
108937: POP
108938: POP
108939: POP
108940: GO 108950
// end ; end ;
108942: GO 108878
108944: POP
108945: POP
// end ;
108946: GO 108764
108948: POP
108949: POP
// end ;
108950: LD_VAR 0 3
108954: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
108955: LD_INT 0
108957: PPUSH
// if not side or side > 8 then
108958: LD_VAR 0 3
108962: NOT
108963: IFTRUE 108975
108965: PUSH
108966: LD_VAR 0 3
108970: PUSH
108971: LD_INT 8
108973: GREATER
108974: OR
108975: IFFALSE 108979
// exit ;
108977: GO 109038
// if not range then
108979: LD_VAR 0 4
108983: NOT
108984: IFFALSE 108995
// range := - 12 ;
108986: LD_ADDR_VAR 0 4
108990: PUSH
108991: LD_INT 12
108993: NEG
108994: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
108995: LD_VAR 0 1
108999: PPUSH
109000: LD_VAR 0 2
109004: PPUSH
109005: LD_VAR 0 3
109009: PPUSH
109010: LD_VAR 0 4
109014: PPUSH
109015: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
109019: LD_VAR 0 1
109023: PPUSH
109024: LD_VAR 0 2
109028: PPUSH
109029: LD_VAR 0 3
109033: PPUSH
109034: CALL_OW 331
// end ;
109038: LD_VAR 0 5
109042: RET
// export function Video ( mode ) ; begin
109043: LD_INT 0
109045: PPUSH
// ingame_video = mode ;
109046: LD_ADDR_OWVAR 52
109050: PUSH
109051: LD_VAR 0 1
109055: ST_TO_ADDR
// interface_hidden = mode ;
109056: LD_ADDR_OWVAR 54
109060: PUSH
109061: LD_VAR 0 1
109065: ST_TO_ADDR
// end ;
109066: LD_VAR 0 2
109070: RET
// export function Join ( array , element ) ; begin
109071: LD_INT 0
109073: PPUSH
// result := Replace ( array , array + 1 , element ) ;
109074: LD_ADDR_VAR 0 3
109078: PUSH
109079: LD_VAR 0 1
109083: PPUSH
109084: LD_VAR 0 1
109088: PUSH
109089: LD_INT 1
109091: PLUS
109092: PPUSH
109093: LD_VAR 0 2
109097: PPUSH
109098: CALL_OW 1
109102: ST_TO_ADDR
// end ;
109103: LD_VAR 0 3
109107: RET
// export function JoinUnion ( array , element ) ; begin
109108: LD_INT 0
109110: PPUSH
// result := array union element ;
109111: LD_ADDR_VAR 0 3
109115: PUSH
109116: LD_VAR 0 1
109120: PUSH
109121: LD_VAR 0 2
109125: UNION
109126: ST_TO_ADDR
// end ;
109127: LD_VAR 0 3
109131: RET
// export function GetBehemoths ( side ) ; begin
109132: LD_INT 0
109134: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
109135: LD_ADDR_VAR 0 2
109139: PUSH
109140: LD_INT 22
109142: PUSH
109143: LD_VAR 0 1
109147: PUSH
109148: EMPTY
109149: LIST
109150: LIST
109151: PUSH
109152: LD_INT 31
109154: PUSH
109155: LD_INT 25
109157: PUSH
109158: EMPTY
109159: LIST
109160: LIST
109161: PUSH
109162: EMPTY
109163: LIST
109164: LIST
109165: PPUSH
109166: CALL_OW 69
109170: ST_TO_ADDR
// end ;
109171: LD_VAR 0 2
109175: RET
// export function Shuffle ( array ) ; var i , index ; begin
109176: LD_INT 0
109178: PPUSH
109179: PPUSH
109180: PPUSH
// result := [ ] ;
109181: LD_ADDR_VAR 0 2
109185: PUSH
109186: EMPTY
109187: ST_TO_ADDR
// if not array then
109188: LD_VAR 0 1
109192: NOT
109193: IFFALSE 109197
// exit ;
109195: GO 109296
// Randomize ;
109197: CALL_OW 10
// for i = array downto 1 do
109201: LD_ADDR_VAR 0 3
109205: PUSH
109206: DOUBLE
109207: LD_VAR 0 1
109211: INC
109212: ST_TO_ADDR
109213: LD_INT 1
109215: PUSH
109216: FOR_DOWNTO
109217: IFFALSE 109294
// begin index := rand ( 1 , array ) ;
109219: LD_ADDR_VAR 0 4
109223: PUSH
109224: LD_INT 1
109226: PPUSH
109227: LD_VAR 0 1
109231: PPUSH
109232: CALL_OW 12
109236: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
109237: LD_ADDR_VAR 0 2
109241: PUSH
109242: LD_VAR 0 2
109246: PPUSH
109247: LD_VAR 0 2
109251: PUSH
109252: LD_INT 1
109254: PLUS
109255: PPUSH
109256: LD_VAR 0 1
109260: PUSH
109261: LD_VAR 0 4
109265: ARRAY
109266: PPUSH
109267: CALL_OW 2
109271: ST_TO_ADDR
// array := Delete ( array , index ) ;
109272: LD_ADDR_VAR 0 1
109276: PUSH
109277: LD_VAR 0 1
109281: PPUSH
109282: LD_VAR 0 4
109286: PPUSH
109287: CALL_OW 3
109291: ST_TO_ADDR
// end ;
109292: GO 109216
109294: POP
109295: POP
// end ;
109296: LD_VAR 0 2
109300: RET
// export function GetBaseMaterials ( base ) ; begin
109301: LD_INT 0
109303: PPUSH
// result := [ 0 , 0 , 0 ] ;
109304: LD_ADDR_VAR 0 2
109308: PUSH
109309: LD_INT 0
109311: PUSH
109312: LD_INT 0
109314: PUSH
109315: LD_INT 0
109317: PUSH
109318: EMPTY
109319: LIST
109320: LIST
109321: LIST
109322: ST_TO_ADDR
// if not base then
109323: LD_VAR 0 1
109327: NOT
109328: IFFALSE 109332
// exit ;
109330: GO 109381
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
109332: LD_ADDR_VAR 0 2
109336: PUSH
109337: LD_VAR 0 1
109341: PPUSH
109342: LD_INT 1
109344: PPUSH
109345: CALL_OW 275
109349: PUSH
109350: LD_VAR 0 1
109354: PPUSH
109355: LD_INT 2
109357: PPUSH
109358: CALL_OW 275
109362: PUSH
109363: LD_VAR 0 1
109367: PPUSH
109368: LD_INT 3
109370: PPUSH
109371: CALL_OW 275
109375: PUSH
109376: EMPTY
109377: LIST
109378: LIST
109379: LIST
109380: ST_TO_ADDR
// end ;
109381: LD_VAR 0 2
109385: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
109386: LD_INT 0
109388: PPUSH
109389: PPUSH
// result := array ;
109390: LD_ADDR_VAR 0 3
109394: PUSH
109395: LD_VAR 0 1
109399: ST_TO_ADDR
// if size >= result then
109400: LD_VAR 0 2
109404: PUSH
109405: LD_VAR 0 3
109409: GREATEREQUAL
109410: IFFALSE 109414
// exit ;
109412: GO 109464
// if size then
109414: LD_VAR 0 2
109418: IFFALSE 109464
// for i := array downto size do
109420: LD_ADDR_VAR 0 4
109424: PUSH
109425: DOUBLE
109426: LD_VAR 0 1
109430: INC
109431: ST_TO_ADDR
109432: LD_VAR 0 2
109436: PUSH
109437: FOR_DOWNTO
109438: IFFALSE 109462
// result := Delete ( result , result ) ;
109440: LD_ADDR_VAR 0 3
109444: PUSH
109445: LD_VAR 0 3
109449: PPUSH
109450: LD_VAR 0 3
109454: PPUSH
109455: CALL_OW 3
109459: ST_TO_ADDR
109460: GO 109437
109462: POP
109463: POP
// end ;
109464: LD_VAR 0 3
109468: RET
// export function ComExit ( unit ) ; var tmp ; begin
109469: LD_INT 0
109471: PPUSH
109472: PPUSH
// if not IsInUnit ( unit ) then
109473: LD_VAR 0 1
109477: PPUSH
109478: CALL_OW 310
109482: NOT
109483: IFFALSE 109487
// exit ;
109485: GO 109547
// tmp := IsInUnit ( unit ) ;
109487: LD_ADDR_VAR 0 3
109491: PUSH
109492: LD_VAR 0 1
109496: PPUSH
109497: CALL_OW 310
109501: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
109502: LD_VAR 0 3
109506: PPUSH
109507: CALL_OW 247
109511: PUSH
109512: LD_INT 2
109514: EQUAL
109515: IFFALSE 109528
// ComExitVehicle ( unit ) else
109517: LD_VAR 0 1
109521: PPUSH
109522: CALL_OW 121
109526: GO 109537
// ComExitBuilding ( unit ) ;
109528: LD_VAR 0 1
109532: PPUSH
109533: CALL_OW 122
// result := tmp ;
109537: LD_ADDR_VAR 0 2
109541: PUSH
109542: LD_VAR 0 3
109546: ST_TO_ADDR
// end ;
109547: LD_VAR 0 2
109551: RET
// export function ComExitAll ( units ) ; var i ; begin
109552: LD_INT 0
109554: PPUSH
109555: PPUSH
// if not units then
109556: LD_VAR 0 1
109560: NOT
109561: IFFALSE 109565
// exit ;
109563: GO 109591
// for i in units do
109565: LD_ADDR_VAR 0 3
109569: PUSH
109570: LD_VAR 0 1
109574: PUSH
109575: FOR_IN
109576: IFFALSE 109589
// ComExit ( i ) ;
109578: LD_VAR 0 3
109582: PPUSH
109583: CALL 109469 0 1
109587: GO 109575
109589: POP
109590: POP
// end ;
109591: LD_VAR 0 2
109595: RET
// export function ResetHc ; begin
109596: LD_INT 0
109598: PPUSH
// InitHc ;
109599: CALL_OW 19
// hc_importance := 0 ;
109603: LD_ADDR_OWVAR 32
109607: PUSH
109608: LD_INT 0
109610: ST_TO_ADDR
// end ;
109611: LD_VAR 0 1
109615: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
109616: LD_INT 0
109618: PPUSH
109619: PPUSH
109620: PPUSH
// _x := ( x1 + x2 ) div 2 ;
109621: LD_ADDR_VAR 0 6
109625: PUSH
109626: LD_VAR 0 1
109630: PUSH
109631: LD_VAR 0 3
109635: PLUS
109636: PUSH
109637: LD_INT 2
109639: DIV
109640: ST_TO_ADDR
// if _x < 0 then
109641: LD_VAR 0 6
109645: PUSH
109646: LD_INT 0
109648: LESS
109649: IFFALSE 109666
// _x := _x * - 1 ;
109651: LD_ADDR_VAR 0 6
109655: PUSH
109656: LD_VAR 0 6
109660: PUSH
109661: LD_INT 1
109663: NEG
109664: MUL
109665: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
109666: LD_ADDR_VAR 0 7
109670: PUSH
109671: LD_VAR 0 2
109675: PUSH
109676: LD_VAR 0 4
109680: PLUS
109681: PUSH
109682: LD_INT 2
109684: DIV
109685: ST_TO_ADDR
// if _y < 0 then
109686: LD_VAR 0 7
109690: PUSH
109691: LD_INT 0
109693: LESS
109694: IFFALSE 109711
// _y := _y * - 1 ;
109696: LD_ADDR_VAR 0 7
109700: PUSH
109701: LD_VAR 0 7
109705: PUSH
109706: LD_INT 1
109708: NEG
109709: MUL
109710: ST_TO_ADDR
// result := [ _x , _y ] ;
109711: LD_ADDR_VAR 0 5
109715: PUSH
109716: LD_VAR 0 6
109720: PUSH
109721: LD_VAR 0 7
109725: PUSH
109726: EMPTY
109727: LIST
109728: LIST
109729: ST_TO_ADDR
// end ;
109730: LD_VAR 0 5
109734: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
109735: LD_INT 0
109737: PPUSH
109738: PPUSH
109739: PPUSH
109740: PPUSH
// task := GetTaskList ( unit ) ;
109741: LD_ADDR_VAR 0 7
109745: PUSH
109746: LD_VAR 0 1
109750: PPUSH
109751: CALL_OW 437
109755: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
109756: LD_VAR 0 7
109760: NOT
109761: IFFALSE 109780
109763: PUSH
109764: LD_VAR 0 1
109768: PPUSH
109769: LD_VAR 0 2
109773: PPUSH
109774: CALL_OW 308
109778: NOT
109779: AND
109780: IFFALSE 109784
// exit ;
109782: GO 109902
// if IsInArea ( unit , area ) then
109784: LD_VAR 0 1
109788: PPUSH
109789: LD_VAR 0 2
109793: PPUSH
109794: CALL_OW 308
109798: IFFALSE 109816
// begin ComMoveToArea ( unit , goAway ) ;
109800: LD_VAR 0 1
109804: PPUSH
109805: LD_VAR 0 3
109809: PPUSH
109810: CALL_OW 113
// exit ;
109814: GO 109902
// end ; if task [ 1 ] [ 1 ] <> M then
109816: LD_VAR 0 7
109820: PUSH
109821: LD_INT 1
109823: ARRAY
109824: PUSH
109825: LD_INT 1
109827: ARRAY
109828: PUSH
109829: LD_STRING M
109831: NONEQUAL
109832: IFFALSE 109836
// exit ;
109834: GO 109902
// x := task [ 1 ] [ 2 ] ;
109836: LD_ADDR_VAR 0 5
109840: PUSH
109841: LD_VAR 0 7
109845: PUSH
109846: LD_INT 1
109848: ARRAY
109849: PUSH
109850: LD_INT 2
109852: ARRAY
109853: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
109854: LD_ADDR_VAR 0 6
109858: PUSH
109859: LD_VAR 0 7
109863: PUSH
109864: LD_INT 1
109866: ARRAY
109867: PUSH
109868: LD_INT 3
109870: ARRAY
109871: ST_TO_ADDR
// if InArea ( x , y , area ) then
109872: LD_VAR 0 5
109876: PPUSH
109877: LD_VAR 0 6
109881: PPUSH
109882: LD_VAR 0 2
109886: PPUSH
109887: CALL_OW 309
109891: IFFALSE 109902
// ComStop ( unit ) ;
109893: LD_VAR 0 1
109897: PPUSH
109898: CALL_OW 141
// end ;
109902: LD_VAR 0 4
109906: RET
// export function Abs ( value ) ; begin
109907: LD_INT 0
109909: PPUSH
// result := value ;
109910: LD_ADDR_VAR 0 2
109914: PUSH
109915: LD_VAR 0 1
109919: ST_TO_ADDR
// if value < 0 then
109920: LD_VAR 0 1
109924: PUSH
109925: LD_INT 0
109927: LESS
109928: IFFALSE 109945
// result := value * - 1 ;
109930: LD_ADDR_VAR 0 2
109934: PUSH
109935: LD_VAR 0 1
109939: PUSH
109940: LD_INT 1
109942: NEG
109943: MUL
109944: ST_TO_ADDR
// end ;
109945: LD_VAR 0 2
109949: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
109950: LD_INT 0
109952: PPUSH
109953: PPUSH
109954: PPUSH
109955: PPUSH
109956: PPUSH
109957: PPUSH
109958: PPUSH
109959: PPUSH
// if not unit or not building then
109960: LD_VAR 0 1
109964: NOT
109965: IFTRUE 109974
109967: PUSH
109968: LD_VAR 0 2
109972: NOT
109973: OR
109974: IFFALSE 109978
// exit ;
109976: GO 110206
// x := GetX ( building ) ;
109978: LD_ADDR_VAR 0 4
109982: PUSH
109983: LD_VAR 0 2
109987: PPUSH
109988: CALL_OW 250
109992: ST_TO_ADDR
// y := GetY ( building ) ;
109993: LD_ADDR_VAR 0 6
109997: PUSH
109998: LD_VAR 0 2
110002: PPUSH
110003: CALL_OW 251
110007: ST_TO_ADDR
// d := GetDir ( building ) ;
110008: LD_ADDR_VAR 0 8
110012: PUSH
110013: LD_VAR 0 2
110017: PPUSH
110018: CALL_OW 254
110022: ST_TO_ADDR
// r := 4 ;
110023: LD_ADDR_VAR 0 9
110027: PUSH
110028: LD_INT 4
110030: ST_TO_ADDR
// for i := 1 to 5 do
110031: LD_ADDR_VAR 0 10
110035: PUSH
110036: DOUBLE
110037: LD_INT 1
110039: DEC
110040: ST_TO_ADDR
110041: LD_INT 5
110043: PUSH
110044: FOR_TO
110045: IFFALSE 110204
// begin _x := ShiftX ( x , d , r + i ) ;
110047: LD_ADDR_VAR 0 5
110051: PUSH
110052: LD_VAR 0 4
110056: PPUSH
110057: LD_VAR 0 8
110061: PPUSH
110062: LD_VAR 0 9
110066: PUSH
110067: LD_VAR 0 10
110071: PLUS
110072: PPUSH
110073: CALL_OW 272
110077: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
110078: LD_ADDR_VAR 0 7
110082: PUSH
110083: LD_VAR 0 6
110087: PPUSH
110088: LD_VAR 0 8
110092: PPUSH
110093: LD_VAR 0 9
110097: PUSH
110098: LD_VAR 0 10
110102: PLUS
110103: PPUSH
110104: CALL_OW 273
110108: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
110109: LD_VAR 0 5
110113: PPUSH
110114: LD_VAR 0 7
110118: PPUSH
110119: CALL_OW 488
110123: IFFALSE 110158
110125: PUSH
110126: LD_VAR 0 5
110130: PPUSH
110131: LD_VAR 0 7
110135: PPUSH
110136: CALL_OW 428
110140: PPUSH
110141: CALL_OW 247
110145: PUSH
110146: LD_INT 3
110148: PUSH
110149: LD_INT 2
110151: PUSH
110152: EMPTY
110153: LIST
110154: LIST
110155: IN
110156: NOT
110157: AND
110158: IFFALSE 110202
// begin ComMoveXY ( unit , _x , _y ) ;
110160: LD_VAR 0 1
110164: PPUSH
110165: LD_VAR 0 5
110169: PPUSH
110170: LD_VAR 0 7
110174: PPUSH
110175: CALL_OW 111
// result := [ _x , _y ] ;
110179: LD_ADDR_VAR 0 3
110183: PUSH
110184: LD_VAR 0 5
110188: PUSH
110189: LD_VAR 0 7
110193: PUSH
110194: EMPTY
110195: LIST
110196: LIST
110197: ST_TO_ADDR
// exit ;
110198: POP
110199: POP
110200: GO 110206
// end ; end ;
110202: GO 110044
110204: POP
110205: POP
// end ;
110206: LD_VAR 0 3
110210: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
110211: LD_INT 0
110213: PPUSH
110214: PPUSH
110215: PPUSH
// result := 0 ;
110216: LD_ADDR_VAR 0 3
110220: PUSH
110221: LD_INT 0
110223: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
110224: LD_VAR 0 1
110228: PUSH
110229: LD_INT 0
110231: LESS
110232: IFTRUE 110244
110234: PUSH
110235: LD_VAR 0 1
110239: PUSH
110240: LD_INT 8
110242: GREATER
110243: OR
110244: IFTRUE 110256
110246: PUSH
110247: LD_VAR 0 2
110251: PUSH
110252: LD_INT 0
110254: LESS
110255: OR
110256: IFTRUE 110268
110258: PUSH
110259: LD_VAR 0 2
110263: PUSH
110264: LD_INT 8
110266: GREATER
110267: OR
110268: IFFALSE 110272
// exit ;
110270: GO 110347
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
110272: LD_ADDR_VAR 0 4
110276: PUSH
110277: LD_INT 22
110279: PUSH
110280: LD_VAR 0 2
110284: PUSH
110285: EMPTY
110286: LIST
110287: LIST
110288: PPUSH
110289: CALL_OW 69
110293: PUSH
110294: FOR_IN
110295: IFFALSE 110345
// begin un := UnitShoot ( i ) ;
110297: LD_ADDR_VAR 0 5
110301: PUSH
110302: LD_VAR 0 4
110306: PPUSH
110307: CALL_OW 504
110311: ST_TO_ADDR
// if GetSide ( un ) = side1 then
110312: LD_VAR 0 5
110316: PPUSH
110317: CALL_OW 255
110321: PUSH
110322: LD_VAR 0 1
110326: EQUAL
110327: IFFALSE 110343
// begin result := un ;
110329: LD_ADDR_VAR 0 3
110333: PUSH
110334: LD_VAR 0 5
110338: ST_TO_ADDR
// exit ;
110339: POP
110340: POP
110341: GO 110347
// end ; end ;
110343: GO 110294
110345: POP
110346: POP
// end ;
110347: LD_VAR 0 3
110351: RET
// export function GetCargoBay ( units ) ; begin
110352: LD_INT 0
110354: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
110355: LD_ADDR_VAR 0 2
110359: PUSH
110360: LD_VAR 0 1
110364: PPUSH
110365: LD_INT 2
110367: PUSH
110368: LD_INT 34
110370: PUSH
110371: LD_INT 12
110373: PUSH
110374: EMPTY
110375: LIST
110376: LIST
110377: PUSH
110378: LD_INT 34
110380: PUSH
110381: LD_INT 51
110383: PUSH
110384: EMPTY
110385: LIST
110386: LIST
110387: PUSH
110388: LD_INT 34
110390: PUSH
110391: LD_INT 32
110393: PUSH
110394: EMPTY
110395: LIST
110396: LIST
110397: PUSH
110398: LD_INT 34
110400: PUSH
110401: LD_INT 89
110403: PUSH
110404: EMPTY
110405: LIST
110406: LIST
110407: PUSH
110408: EMPTY
110409: LIST
110410: LIST
110411: LIST
110412: LIST
110413: LIST
110414: PPUSH
110415: CALL_OW 72
110419: ST_TO_ADDR
// end ;
110420: LD_VAR 0 2
110424: RET
// export function Negate ( value ) ; begin
110425: LD_INT 0
110427: PPUSH
// result := not value ;
110428: LD_ADDR_VAR 0 2
110432: PUSH
110433: LD_VAR 0 1
110437: NOT
110438: ST_TO_ADDR
// end ;
110439: LD_VAR 0 2
110443: RET
// export function Inc ( value ) ; begin
110444: LD_INT 0
110446: PPUSH
// result := value + 1 ;
110447: LD_ADDR_VAR 0 2
110451: PUSH
110452: LD_VAR 0 1
110456: PUSH
110457: LD_INT 1
110459: PLUS
110460: ST_TO_ADDR
// end ;
110461: LD_VAR 0 2
110465: RET
// export function Dec ( value ) ; begin
110466: LD_INT 0
110468: PPUSH
// result := value - 1 ;
110469: LD_ADDR_VAR 0 2
110473: PUSH
110474: LD_VAR 0 1
110478: PUSH
110479: LD_INT 1
110481: MINUS
110482: ST_TO_ADDR
// end ;
110483: LD_VAR 0 2
110487: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
110488: LD_INT 0
110490: PPUSH
110491: PPUSH
110492: PPUSH
110493: PPUSH
110494: PPUSH
110495: PPUSH
110496: PPUSH
110497: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
110498: LD_VAR 0 1
110502: PPUSH
110503: LD_VAR 0 2
110507: PPUSH
110508: CALL_OW 488
110512: NOT
110513: IFTRUE 110532
110515: PUSH
110516: LD_VAR 0 3
110520: PPUSH
110521: LD_VAR 0 4
110525: PPUSH
110526: CALL_OW 488
110530: NOT
110531: OR
110532: IFFALSE 110545
// begin result := - 1 ;
110534: LD_ADDR_VAR 0 5
110538: PUSH
110539: LD_INT 1
110541: NEG
110542: ST_TO_ADDR
// exit ;
110543: GO 110780
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
110545: LD_ADDR_VAR 0 12
110549: PUSH
110550: LD_VAR 0 1
110554: PPUSH
110555: LD_VAR 0 2
110559: PPUSH
110560: LD_VAR 0 3
110564: PPUSH
110565: LD_VAR 0 4
110569: PPUSH
110570: CALL 109616 0 4
110574: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
110575: LD_ADDR_VAR 0 11
110579: PUSH
110580: LD_VAR 0 1
110584: PPUSH
110585: LD_VAR 0 2
110589: PPUSH
110590: LD_VAR 0 12
110594: PUSH
110595: LD_INT 1
110597: ARRAY
110598: PPUSH
110599: LD_VAR 0 12
110603: PUSH
110604: LD_INT 2
110606: ARRAY
110607: PPUSH
110608: CALL_OW 298
110612: ST_TO_ADDR
// distance := 9999 ;
110613: LD_ADDR_VAR 0 10
110617: PUSH
110618: LD_INT 9999
110620: ST_TO_ADDR
// for i := 0 to 5 do
110621: LD_ADDR_VAR 0 6
110625: PUSH
110626: DOUBLE
110627: LD_INT 0
110629: DEC
110630: ST_TO_ADDR
110631: LD_INT 5
110633: PUSH
110634: FOR_TO
110635: IFFALSE 110778
// begin _x := ShiftX ( x1 , i , centerDist ) ;
110637: LD_ADDR_VAR 0 7
110641: PUSH
110642: LD_VAR 0 1
110646: PPUSH
110647: LD_VAR 0 6
110651: PPUSH
110652: LD_VAR 0 11
110656: PPUSH
110657: CALL_OW 272
110661: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
110662: LD_ADDR_VAR 0 8
110666: PUSH
110667: LD_VAR 0 2
110671: PPUSH
110672: LD_VAR 0 6
110676: PPUSH
110677: LD_VAR 0 11
110681: PPUSH
110682: CALL_OW 273
110686: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110687: LD_VAR 0 7
110691: PPUSH
110692: LD_VAR 0 8
110696: PPUSH
110697: CALL_OW 488
110701: NOT
110702: IFFALSE 110706
// continue ;
110704: GO 110634
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
110706: LD_ADDR_VAR 0 9
110710: PUSH
110711: LD_VAR 0 12
110715: PUSH
110716: LD_INT 1
110718: ARRAY
110719: PPUSH
110720: LD_VAR 0 12
110724: PUSH
110725: LD_INT 2
110727: ARRAY
110728: PPUSH
110729: LD_VAR 0 7
110733: PPUSH
110734: LD_VAR 0 8
110738: PPUSH
110739: CALL_OW 298
110743: ST_TO_ADDR
// if tmp < distance then
110744: LD_VAR 0 9
110748: PUSH
110749: LD_VAR 0 10
110753: LESS
110754: IFFALSE 110776
// begin result := i ;
110756: LD_ADDR_VAR 0 5
110760: PUSH
110761: LD_VAR 0 6
110765: ST_TO_ADDR
// distance := tmp ;
110766: LD_ADDR_VAR 0 10
110770: PUSH
110771: LD_VAR 0 9
110775: ST_TO_ADDR
// end ; end ;
110776: GO 110634
110778: POP
110779: POP
// end ;
110780: LD_VAR 0 5
110784: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110785: LD_INT 0
110787: PPUSH
110788: PPUSH
// if not driver or not IsInUnit ( driver ) then
110789: LD_VAR 0 1
110793: NOT
110794: IFTRUE 110808
110796: PUSH
110797: LD_VAR 0 1
110801: PPUSH
110802: CALL_OW 310
110806: NOT
110807: OR
110808: IFFALSE 110812
// exit ;
110810: GO 110902
// vehicle := IsInUnit ( driver ) ;
110812: LD_ADDR_VAR 0 3
110816: PUSH
110817: LD_VAR 0 1
110821: PPUSH
110822: CALL_OW 310
110826: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
110827: LD_VAR 0 1
110831: PPUSH
110832: LD_STRING \
110834: PUSH
110835: LD_INT 0
110837: PUSH
110838: LD_INT 0
110840: PUSH
110841: LD_INT 0
110843: PUSH
110844: LD_INT 0
110846: PUSH
110847: LD_INT 0
110849: PUSH
110850: LD_INT 0
110852: PUSH
110853: EMPTY
110854: LIST
110855: LIST
110856: LIST
110857: LIST
110858: LIST
110859: LIST
110860: LIST
110861: PUSH
110862: LD_STRING E
110864: PUSH
110865: LD_INT 0
110867: PUSH
110868: LD_INT 0
110870: PUSH
110871: LD_VAR 0 3
110875: PUSH
110876: LD_INT 0
110878: PUSH
110879: LD_INT 0
110881: PUSH
110882: LD_INT 0
110884: PUSH
110885: EMPTY
110886: LIST
110887: LIST
110888: LIST
110889: LIST
110890: LIST
110891: LIST
110892: LIST
110893: PUSH
110894: EMPTY
110895: LIST
110896: LIST
110897: PPUSH
110898: CALL_OW 446
// end ;
110902: LD_VAR 0 2
110906: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110907: LD_INT 0
110909: PPUSH
110910: PPUSH
// if not driver or not IsInUnit ( driver ) then
110911: LD_VAR 0 1
110915: NOT
110916: IFTRUE 110930
110918: PUSH
110919: LD_VAR 0 1
110923: PPUSH
110924: CALL_OW 310
110928: NOT
110929: OR
110930: IFFALSE 110934
// exit ;
110932: GO 111024
// vehicle := IsInUnit ( driver ) ;
110934: LD_ADDR_VAR 0 3
110938: PUSH
110939: LD_VAR 0 1
110943: PPUSH
110944: CALL_OW 310
110948: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
110949: LD_VAR 0 1
110953: PPUSH
110954: LD_STRING \
110956: PUSH
110957: LD_INT 0
110959: PUSH
110960: LD_INT 0
110962: PUSH
110963: LD_INT 0
110965: PUSH
110966: LD_INT 0
110968: PUSH
110969: LD_INT 0
110971: PUSH
110972: LD_INT 0
110974: PUSH
110975: EMPTY
110976: LIST
110977: LIST
110978: LIST
110979: LIST
110980: LIST
110981: LIST
110982: LIST
110983: PUSH
110984: LD_STRING E
110986: PUSH
110987: LD_INT 0
110989: PUSH
110990: LD_INT 0
110992: PUSH
110993: LD_VAR 0 3
110997: PUSH
110998: LD_INT 0
111000: PUSH
111001: LD_INT 0
111003: PUSH
111004: LD_INT 0
111006: PUSH
111007: EMPTY
111008: LIST
111009: LIST
111010: LIST
111011: LIST
111012: LIST
111013: LIST
111014: LIST
111015: PUSH
111016: EMPTY
111017: LIST
111018: LIST
111019: PPUSH
111020: CALL_OW 447
// end ;
111024: LD_VAR 0 2
111028: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
111029: LD_INT 0
111031: PPUSH
111032: PPUSH
111033: PPUSH
// tmp := [ ] ;
111034: LD_ADDR_VAR 0 5
111038: PUSH
111039: EMPTY
111040: ST_TO_ADDR
// for i in units do
111041: LD_ADDR_VAR 0 4
111045: PUSH
111046: LD_VAR 0 1
111050: PUSH
111051: FOR_IN
111052: IFFALSE 111090
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
111054: LD_ADDR_VAR 0 5
111058: PUSH
111059: LD_VAR 0 5
111063: PPUSH
111064: LD_VAR 0 5
111068: PUSH
111069: LD_INT 1
111071: PLUS
111072: PPUSH
111073: LD_VAR 0 4
111077: PPUSH
111078: CALL_OW 256
111082: PPUSH
111083: CALL_OW 2
111087: ST_TO_ADDR
111088: GO 111051
111090: POP
111091: POP
// if not tmp then
111092: LD_VAR 0 5
111096: NOT
111097: IFFALSE 111101
// exit ;
111099: GO 111149
// if asc then
111101: LD_VAR 0 2
111105: IFFALSE 111129
// result := SortListByListAsc ( units , tmp ) else
111107: LD_ADDR_VAR 0 3
111111: PUSH
111112: LD_VAR 0 1
111116: PPUSH
111117: LD_VAR 0 5
111121: PPUSH
111122: CALL_OW 76
111126: ST_TO_ADDR
111127: GO 111149
// result := SortListByListDesc ( units , tmp ) ;
111129: LD_ADDR_VAR 0 3
111133: PUSH
111134: LD_VAR 0 1
111138: PPUSH
111139: LD_VAR 0 5
111143: PPUSH
111144: CALL_OW 77
111148: ST_TO_ADDR
// end ;
111149: LD_VAR 0 3
111153: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
111154: LD_INT 0
111156: PPUSH
111157: PPUSH
// task := GetTaskList ( mech ) ;
111158: LD_ADDR_VAR 0 4
111162: PUSH
111163: LD_VAR 0 1
111167: PPUSH
111168: CALL_OW 437
111172: ST_TO_ADDR
// if not task then
111173: LD_VAR 0 4
111177: NOT
111178: IFFALSE 111182
// exit ;
111180: GO 111226
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
111182: LD_ADDR_VAR 0 3
111186: PUSH
111187: LD_VAR 0 4
111191: PUSH
111192: LD_INT 1
111194: ARRAY
111195: PUSH
111196: LD_INT 1
111198: ARRAY
111199: PUSH
111200: LD_STRING r
111202: EQUAL
111203: IFFALSE 111225
111205: PUSH
111206: LD_VAR 0 4
111210: PUSH
111211: LD_INT 1
111213: ARRAY
111214: PUSH
111215: LD_INT 4
111217: ARRAY
111218: PUSH
111219: LD_VAR 0 2
111223: EQUAL
111224: AND
111225: ST_TO_ADDR
// end ;
111226: LD_VAR 0 3
111230: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
111231: LD_INT 0
111233: PPUSH
// SetDir ( unit , d ) ;
111234: LD_VAR 0 1
111238: PPUSH
111239: LD_VAR 0 4
111243: PPUSH
111244: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
111248: LD_ADDR_VAR 0 6
111252: PUSH
111253: LD_VAR 0 1
111257: PPUSH
111258: LD_VAR 0 2
111262: PPUSH
111263: LD_VAR 0 3
111267: PPUSH
111268: LD_VAR 0 5
111272: PPUSH
111273: CALL_OW 48
111277: ST_TO_ADDR
// end ;
111278: LD_VAR 0 6
111282: RET
// export function ToNaturalNumber ( number ) ; begin
111283: LD_INT 0
111285: PPUSH
// result := number div 1 ;
111286: LD_ADDR_VAR 0 2
111290: PUSH
111291: LD_VAR 0 1
111295: PUSH
111296: LD_INT 1
111298: DIV
111299: ST_TO_ADDR
// if number < 0 then
111300: LD_VAR 0 1
111304: PUSH
111305: LD_INT 0
111307: LESS
111308: IFFALSE 111318
// result := 0 ;
111310: LD_ADDR_VAR 0 2
111314: PUSH
111315: LD_INT 0
111317: ST_TO_ADDR
// end ;
111318: LD_VAR 0 2
111322: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
111323: LD_INT 0
111325: PPUSH
111326: PPUSH
111327: PPUSH
// if not buildings then
111328: LD_VAR 0 1
111332: NOT
111333: IFFALSE 111337
// exit ;
111335: GO 111452
// tmp := [ ] ;
111337: LD_ADDR_VAR 0 5
111341: PUSH
111342: EMPTY
111343: ST_TO_ADDR
// for b in buildings do
111344: LD_ADDR_VAR 0 4
111348: PUSH
111349: LD_VAR 0 1
111353: PUSH
111354: FOR_IN
111355: IFFALSE 111393
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
111357: LD_ADDR_VAR 0 5
111361: PUSH
111362: LD_VAR 0 5
111366: PPUSH
111367: LD_VAR 0 5
111371: PUSH
111372: LD_INT 1
111374: PLUS
111375: PPUSH
111376: LD_VAR 0 4
111380: PPUSH
111381: CALL_OW 266
111385: PPUSH
111386: CALL_OW 1
111390: ST_TO_ADDR
111391: GO 111354
111393: POP
111394: POP
// if not tmp then
111395: LD_VAR 0 5
111399: NOT
111400: IFFALSE 111404
// exit ;
111402: GO 111452
// if asc then
111404: LD_VAR 0 2
111408: IFFALSE 111432
// result := SortListByListAsc ( buildings , tmp ) else
111410: LD_ADDR_VAR 0 3
111414: PUSH
111415: LD_VAR 0 1
111419: PPUSH
111420: LD_VAR 0 5
111424: PPUSH
111425: CALL_OW 76
111429: ST_TO_ADDR
111430: GO 111452
// result := SortListByListDesc ( buildings , tmp ) ;
111432: LD_ADDR_VAR 0 3
111436: PUSH
111437: LD_VAR 0 1
111441: PPUSH
111442: LD_VAR 0 5
111446: PPUSH
111447: CALL_OW 77
111451: ST_TO_ADDR
// end ;
111452: LD_VAR 0 3
111456: RET
// export function SortByClass ( units , class ) ; var un ; begin
111457: LD_INT 0
111459: PPUSH
111460: PPUSH
// if not units or not class then
111461: LD_VAR 0 1
111465: NOT
111466: IFTRUE 111475
111468: PUSH
111469: LD_VAR 0 2
111473: NOT
111474: OR
111475: IFFALSE 111479
// exit ;
111477: GO 111574
// result := [ ] ;
111479: LD_ADDR_VAR 0 3
111483: PUSH
111484: EMPTY
111485: ST_TO_ADDR
// for un in units do
111486: LD_ADDR_VAR 0 4
111490: PUSH
111491: LD_VAR 0 1
111495: PUSH
111496: FOR_IN
111497: IFFALSE 111572
// if GetClass ( un ) = class then
111499: LD_VAR 0 4
111503: PPUSH
111504: CALL_OW 257
111508: PUSH
111509: LD_VAR 0 2
111513: EQUAL
111514: IFFALSE 111541
// result := Insert ( result , 1 , un ) else
111516: LD_ADDR_VAR 0 3
111520: PUSH
111521: LD_VAR 0 3
111525: PPUSH
111526: LD_INT 1
111528: PPUSH
111529: LD_VAR 0 4
111533: PPUSH
111534: CALL_OW 2
111538: ST_TO_ADDR
111539: GO 111570
// result := Replace ( result , result + 1 , un ) ;
111541: LD_ADDR_VAR 0 3
111545: PUSH
111546: LD_VAR 0 3
111550: PPUSH
111551: LD_VAR 0 3
111555: PUSH
111556: LD_INT 1
111558: PLUS
111559: PPUSH
111560: LD_VAR 0 4
111564: PPUSH
111565: CALL_OW 1
111569: ST_TO_ADDR
111570: GO 111496
111572: POP
111573: POP
// end ;
111574: LD_VAR 0 3
111578: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
111579: LD_INT 0
111581: PPUSH
111582: PPUSH
111583: PPUSH
111584: PPUSH
111585: PPUSH
111586: PPUSH
111587: PPUSH
// result := [ ] ;
111588: LD_ADDR_VAR 0 4
111592: PUSH
111593: EMPTY
111594: ST_TO_ADDR
// if x - r < 0 then
111595: LD_VAR 0 1
111599: PUSH
111600: LD_VAR 0 3
111604: MINUS
111605: PUSH
111606: LD_INT 0
111608: LESS
111609: IFFALSE 111621
// min_x := 0 else
111611: LD_ADDR_VAR 0 8
111615: PUSH
111616: LD_INT 0
111618: ST_TO_ADDR
111619: GO 111637
// min_x := x - r ;
111621: LD_ADDR_VAR 0 8
111625: PUSH
111626: LD_VAR 0 1
111630: PUSH
111631: LD_VAR 0 3
111635: MINUS
111636: ST_TO_ADDR
// if y - r < 0 then
111637: LD_VAR 0 2
111641: PUSH
111642: LD_VAR 0 3
111646: MINUS
111647: PUSH
111648: LD_INT 0
111650: LESS
111651: IFFALSE 111663
// min_y := 0 else
111653: LD_ADDR_VAR 0 7
111657: PUSH
111658: LD_INT 0
111660: ST_TO_ADDR
111661: GO 111679
// min_y := y - r ;
111663: LD_ADDR_VAR 0 7
111667: PUSH
111668: LD_VAR 0 2
111672: PUSH
111673: LD_VAR 0 3
111677: MINUS
111678: ST_TO_ADDR
// max_x := x + r ;
111679: LD_ADDR_VAR 0 9
111683: PUSH
111684: LD_VAR 0 1
111688: PUSH
111689: LD_VAR 0 3
111693: PLUS
111694: ST_TO_ADDR
// max_y := y + r ;
111695: LD_ADDR_VAR 0 10
111699: PUSH
111700: LD_VAR 0 2
111704: PUSH
111705: LD_VAR 0 3
111709: PLUS
111710: ST_TO_ADDR
// for _x = min_x to max_x do
111711: LD_ADDR_VAR 0 5
111715: PUSH
111716: DOUBLE
111717: LD_VAR 0 8
111721: DEC
111722: ST_TO_ADDR
111723: LD_VAR 0 9
111727: PUSH
111728: FOR_TO
111729: IFFALSE 111830
// for _y = min_y to max_y do
111731: LD_ADDR_VAR 0 6
111735: PUSH
111736: DOUBLE
111737: LD_VAR 0 7
111741: DEC
111742: ST_TO_ADDR
111743: LD_VAR 0 10
111747: PUSH
111748: FOR_TO
111749: IFFALSE 111826
// begin if not ValidHex ( _x , _y ) then
111751: LD_VAR 0 5
111755: PPUSH
111756: LD_VAR 0 6
111760: PPUSH
111761: CALL_OW 488
111765: NOT
111766: IFFALSE 111770
// continue ;
111768: GO 111748
// if GetResourceTypeXY ( _x , _y ) then
111770: LD_VAR 0 5
111774: PPUSH
111775: LD_VAR 0 6
111779: PPUSH
111780: CALL_OW 283
111784: IFFALSE 111824
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
111786: LD_ADDR_VAR 0 4
111790: PUSH
111791: LD_VAR 0 4
111795: PPUSH
111796: LD_VAR 0 4
111800: PUSH
111801: LD_INT 1
111803: PLUS
111804: PPUSH
111805: LD_VAR 0 5
111809: PUSH
111810: LD_VAR 0 6
111814: PUSH
111815: EMPTY
111816: LIST
111817: LIST
111818: PPUSH
111819: CALL_OW 1
111823: ST_TO_ADDR
// end ;
111824: GO 111748
111826: POP
111827: POP
111828: GO 111728
111830: POP
111831: POP
// end ;
111832: LD_VAR 0 4
111836: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
111837: LD_INT 0
111839: PPUSH
111840: PPUSH
111841: PPUSH
111842: PPUSH
111843: PPUSH
111844: PPUSH
111845: PPUSH
111846: PPUSH
// if not units then
111847: LD_VAR 0 1
111851: NOT
111852: IFFALSE 111856
// exit ;
111854: GO 112388
// result := UnitFilter ( units , [ f_ok ] ) ;
111856: LD_ADDR_VAR 0 3
111860: PUSH
111861: LD_VAR 0 1
111865: PPUSH
111866: LD_INT 50
111868: PUSH
111869: EMPTY
111870: LIST
111871: PPUSH
111872: CALL_OW 72
111876: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
111877: LD_ADDR_VAR 0 8
111881: PUSH
111882: LD_VAR 0 1
111886: PUSH
111887: LD_INT 1
111889: ARRAY
111890: PPUSH
111891: CALL_OW 255
111895: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
111896: LD_ADDR_VAR 0 10
111900: PUSH
111901: LD_INT 29
111903: PUSH
111904: LD_INT 91
111906: PUSH
111907: LD_INT 49
111909: PUSH
111910: EMPTY
111911: LIST
111912: LIST
111913: LIST
111914: ST_TO_ADDR
// if not result then
111915: LD_VAR 0 3
111919: NOT
111920: IFFALSE 111924
// exit ;
111922: GO 112388
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
111924: LD_ADDR_VAR 0 5
111928: PUSH
111929: LD_INT 81
111931: PUSH
111932: LD_VAR 0 8
111936: PUSH
111937: EMPTY
111938: LIST
111939: LIST
111940: PPUSH
111941: CALL_OW 69
111945: ST_TO_ADDR
// for i in result do
111946: LD_ADDR_VAR 0 4
111950: PUSH
111951: LD_VAR 0 3
111955: PUSH
111956: FOR_IN
111957: IFFALSE 112386
// begin tag := GetTag ( i ) + 1 ;
111959: LD_ADDR_VAR 0 9
111963: PUSH
111964: LD_VAR 0 4
111968: PPUSH
111969: CALL_OW 110
111973: PUSH
111974: LD_INT 1
111976: PLUS
111977: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
111978: LD_ADDR_VAR 0 7
111982: PUSH
111983: LD_VAR 0 4
111987: PPUSH
111988: CALL_OW 250
111992: PPUSH
111993: LD_VAR 0 4
111997: PPUSH
111998: CALL_OW 251
112002: PPUSH
112003: LD_INT 4
112005: PPUSH
112006: CALL 111579 0 3
112010: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
112011: LD_VAR 0 4
112015: PPUSH
112016: CALL_OW 247
112020: PUSH
112021: LD_INT 2
112023: EQUAL
112024: IFFALSE 112036
112026: PUSH
112027: LD_VAR 0 7
112031: PUSH
112032: LD_INT 2
112034: GREATER
112035: AND
112036: IFFALSE 112056
112038: PUSH
112039: LD_VAR 0 4
112043: PPUSH
112044: CALL_OW 264
112048: PUSH
112049: LD_VAR 0 10
112053: IN
112054: NOT
112055: AND
112056: IFFALSE 112095
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
112058: LD_VAR 0 4
112062: PPUSH
112063: LD_VAR 0 7
112067: PUSH
112068: LD_INT 1
112070: ARRAY
112071: PUSH
112072: LD_INT 1
112074: ARRAY
112075: PPUSH
112076: LD_VAR 0 7
112080: PUSH
112081: LD_INT 1
112083: ARRAY
112084: PUSH
112085: LD_INT 2
112087: ARRAY
112088: PPUSH
112089: CALL_OW 116
112093: GO 112384
// if path > tag then
112095: LD_VAR 0 2
112099: PUSH
112100: LD_VAR 0 9
112104: GREATER
112105: IFFALSE 112313
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
112107: LD_ADDR_VAR 0 6
112111: PUSH
112112: LD_VAR 0 5
112116: PPUSH
112117: LD_INT 91
112119: PUSH
112120: LD_VAR 0 4
112124: PUSH
112125: LD_INT 8
112127: PUSH
112128: EMPTY
112129: LIST
112130: LIST
112131: LIST
112132: PPUSH
112133: CALL_OW 72
112137: ST_TO_ADDR
// if nearEnemy then
112138: LD_VAR 0 6
112142: IFFALSE 112211
// begin if GetWeapon ( i ) = ru_time_lapser then
112144: LD_VAR 0 4
112148: PPUSH
112149: CALL_OW 264
112153: PUSH
112154: LD_INT 49
112156: EQUAL
112157: IFFALSE 112185
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
112159: LD_VAR 0 4
112163: PPUSH
112164: LD_VAR 0 6
112168: PPUSH
112169: LD_VAR 0 4
112173: PPUSH
112174: CALL_OW 74
112178: PPUSH
112179: CALL_OW 112
112183: GO 112209
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
112185: LD_VAR 0 4
112189: PPUSH
112190: LD_VAR 0 6
112194: PPUSH
112195: LD_VAR 0 4
112199: PPUSH
112200: CALL_OW 74
112204: PPUSH
112205: CALL 113469 0 2
// end else
112209: GO 112311
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
112211: LD_VAR 0 4
112215: PPUSH
112216: LD_VAR 0 2
112220: PUSH
112221: LD_VAR 0 9
112225: ARRAY
112226: PUSH
112227: LD_INT 1
112229: ARRAY
112230: PPUSH
112231: LD_VAR 0 2
112235: PUSH
112236: LD_VAR 0 9
112240: ARRAY
112241: PUSH
112242: LD_INT 2
112244: ARRAY
112245: PPUSH
112246: CALL_OW 297
112250: PUSH
112251: LD_INT 6
112253: GREATER
112254: IFFALSE 112297
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
112256: LD_VAR 0 4
112260: PPUSH
112261: LD_VAR 0 2
112265: PUSH
112266: LD_VAR 0 9
112270: ARRAY
112271: PUSH
112272: LD_INT 1
112274: ARRAY
112275: PPUSH
112276: LD_VAR 0 2
112280: PUSH
112281: LD_VAR 0 9
112285: ARRAY
112286: PUSH
112287: LD_INT 2
112289: ARRAY
112290: PPUSH
112291: CALL_OW 114
112295: GO 112311
// SetTag ( i , tag ) ;
112297: LD_VAR 0 4
112301: PPUSH
112302: LD_VAR 0 9
112306: PPUSH
112307: CALL_OW 109
// end else
112311: GO 112384
// if enemy then
112313: LD_VAR 0 5
112317: IFFALSE 112384
// begin if GetWeapon ( i ) = ru_time_lapser then
112319: LD_VAR 0 4
112323: PPUSH
112324: CALL_OW 264
112328: PUSH
112329: LD_INT 49
112331: EQUAL
112332: IFFALSE 112360
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
112334: LD_VAR 0 4
112338: PPUSH
112339: LD_VAR 0 5
112343: PPUSH
112344: LD_VAR 0 4
112348: PPUSH
112349: CALL_OW 74
112353: PPUSH
112354: CALL_OW 112
112358: GO 112384
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
112360: LD_VAR 0 4
112364: PPUSH
112365: LD_VAR 0 5
112369: PPUSH
112370: LD_VAR 0 4
112374: PPUSH
112375: CALL_OW 74
112379: PPUSH
112380: CALL 113469 0 2
// end ; end ;
112384: GO 111956
112386: POP
112387: POP
// end ;
112388: LD_VAR 0 3
112392: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
112393: LD_INT 0
112395: PPUSH
112396: PPUSH
112397: PPUSH
// if not unit or IsInUnit ( unit ) then
112398: LD_VAR 0 1
112402: NOT
112403: IFTRUE 112416
112405: PUSH
112406: LD_VAR 0 1
112410: PPUSH
112411: CALL_OW 310
112415: OR
112416: IFFALSE 112420
// exit ;
112418: GO 112511
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
112420: LD_ADDR_VAR 0 4
112424: PUSH
112425: LD_VAR 0 1
112429: PPUSH
112430: CALL_OW 250
112434: PPUSH
112435: LD_VAR 0 2
112439: PPUSH
112440: LD_INT 1
112442: PPUSH
112443: CALL_OW 272
112447: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
112448: LD_ADDR_VAR 0 5
112452: PUSH
112453: LD_VAR 0 1
112457: PPUSH
112458: CALL_OW 251
112462: PPUSH
112463: LD_VAR 0 2
112467: PPUSH
112468: LD_INT 1
112470: PPUSH
112471: CALL_OW 273
112475: ST_TO_ADDR
// if ValidHex ( x , y ) then
112476: LD_VAR 0 4
112480: PPUSH
112481: LD_VAR 0 5
112485: PPUSH
112486: CALL_OW 488
112490: IFFALSE 112511
// ComTurnXY ( unit , x , y ) ;
112492: LD_VAR 0 1
112496: PPUSH
112497: LD_VAR 0 4
112501: PPUSH
112502: LD_VAR 0 5
112506: PPUSH
112507: CALL_OW 118
// end ;
112511: LD_VAR 0 3
112515: RET
// export function SeeUnits ( side , units ) ; var i ; begin
112516: LD_INT 0
112518: PPUSH
112519: PPUSH
// result := false ;
112520: LD_ADDR_VAR 0 3
112524: PUSH
112525: LD_INT 0
112527: ST_TO_ADDR
// if not units then
112528: LD_VAR 0 2
112532: NOT
112533: IFFALSE 112537
// exit ;
112535: GO 112582
// for i in units do
112537: LD_ADDR_VAR 0 4
112541: PUSH
112542: LD_VAR 0 2
112546: PUSH
112547: FOR_IN
112548: IFFALSE 112580
// if See ( side , i ) then
112550: LD_VAR 0 1
112554: PPUSH
112555: LD_VAR 0 4
112559: PPUSH
112560: CALL_OW 292
112564: IFFALSE 112578
// begin result := true ;
112566: LD_ADDR_VAR 0 3
112570: PUSH
112571: LD_INT 1
112573: ST_TO_ADDR
// exit ;
112574: POP
112575: POP
112576: GO 112582
// end ;
112578: GO 112547
112580: POP
112581: POP
// end ;
112582: LD_VAR 0 3
112586: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
112587: LD_INT 0
112589: PPUSH
112590: PPUSH
112591: PPUSH
112592: PPUSH
// if not unit or not points then
112593: LD_VAR 0 1
112597: NOT
112598: IFTRUE 112607
112600: PUSH
112601: LD_VAR 0 2
112605: NOT
112606: OR
112607: IFFALSE 112611
// exit ;
112609: GO 112701
// dist := 99999 ;
112611: LD_ADDR_VAR 0 5
112615: PUSH
112616: LD_INT 99999
112618: ST_TO_ADDR
// for i in points do
112619: LD_ADDR_VAR 0 4
112623: PUSH
112624: LD_VAR 0 2
112628: PUSH
112629: FOR_IN
112630: IFFALSE 112699
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
112632: LD_ADDR_VAR 0 6
112636: PUSH
112637: LD_VAR 0 1
112641: PPUSH
112642: LD_VAR 0 4
112646: PUSH
112647: LD_INT 1
112649: ARRAY
112650: PPUSH
112651: LD_VAR 0 4
112655: PUSH
112656: LD_INT 2
112658: ARRAY
112659: PPUSH
112660: CALL_OW 297
112664: ST_TO_ADDR
// if tmpDist < dist then
112665: LD_VAR 0 6
112669: PUSH
112670: LD_VAR 0 5
112674: LESS
112675: IFFALSE 112697
// begin result := i ;
112677: LD_ADDR_VAR 0 3
112681: PUSH
112682: LD_VAR 0 4
112686: ST_TO_ADDR
// dist := tmpDist ;
112687: LD_ADDR_VAR 0 5
112691: PUSH
112692: LD_VAR 0 6
112696: ST_TO_ADDR
// end ; end ;
112697: GO 112629
112699: POP
112700: POP
// end ;
112701: LD_VAR 0 3
112705: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
112706: LD_INT 0
112708: PPUSH
// uc_side := side ;
112709: LD_ADDR_OWVAR 20
112713: PUSH
112714: LD_VAR 0 1
112718: ST_TO_ADDR
// uc_nation := 3 ;
112719: LD_ADDR_OWVAR 21
112723: PUSH
112724: LD_INT 3
112726: ST_TO_ADDR
// vc_chassis := 25 ;
112727: LD_ADDR_OWVAR 37
112731: PUSH
112732: LD_INT 25
112734: ST_TO_ADDR
// vc_engine := engine_siberite ;
112735: LD_ADDR_OWVAR 39
112739: PUSH
112740: LD_INT 3
112742: ST_TO_ADDR
// vc_control := control_computer ;
112743: LD_ADDR_OWVAR 38
112747: PUSH
112748: LD_INT 3
112750: ST_TO_ADDR
// vc_weapon := 59 ;
112751: LD_ADDR_OWVAR 40
112755: PUSH
112756: LD_INT 59
112758: ST_TO_ADDR
// result := CreateVehicle ;
112759: LD_ADDR_VAR 0 5
112763: PUSH
112764: CALL_OW 45
112768: ST_TO_ADDR
// SetDir ( result , d ) ;
112769: LD_VAR 0 5
112773: PPUSH
112774: LD_VAR 0 4
112778: PPUSH
112779: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
112783: LD_VAR 0 5
112787: PPUSH
112788: LD_VAR 0 2
112792: PPUSH
112793: LD_VAR 0 3
112797: PPUSH
112798: LD_INT 0
112800: PPUSH
112801: CALL_OW 48
// end ;
112805: LD_VAR 0 5
112809: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
112810: LD_INT 0
112812: PPUSH
112813: PPUSH
112814: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
112815: LD_ADDR_VAR 0 2
112819: PUSH
112820: LD_INT 0
112822: PUSH
112823: LD_INT 0
112825: PUSH
112826: LD_INT 0
112828: PUSH
112829: LD_INT 0
112831: PUSH
112832: EMPTY
112833: LIST
112834: LIST
112835: LIST
112836: LIST
112837: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
112838: LD_VAR 0 1
112842: NOT
112843: IFTRUE 112876
112845: PUSH
112846: LD_VAR 0 1
112850: PPUSH
112851: CALL_OW 264
112855: PUSH
112856: LD_INT 12
112858: PUSH
112859: LD_INT 51
112861: PUSH
112862: LD_INT 32
112864: PUSH
112865: LD_INT 89
112867: PUSH
112868: EMPTY
112869: LIST
112870: LIST
112871: LIST
112872: LIST
112873: IN
112874: NOT
112875: OR
112876: IFFALSE 112880
// exit ;
112878: GO 112978
// for i := 1 to 3 do
112880: LD_ADDR_VAR 0 3
112884: PUSH
112885: DOUBLE
112886: LD_INT 1
112888: DEC
112889: ST_TO_ADDR
112890: LD_INT 3
112892: PUSH
112893: FOR_TO
112894: IFFALSE 112976
// begin tmp := GetCargo ( cargo , i ) ;
112896: LD_ADDR_VAR 0 4
112900: PUSH
112901: LD_VAR 0 1
112905: PPUSH
112906: LD_VAR 0 3
112910: PPUSH
112911: CALL_OW 289
112915: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
112916: LD_ADDR_VAR 0 2
112920: PUSH
112921: LD_VAR 0 2
112925: PPUSH
112926: LD_VAR 0 3
112930: PPUSH
112931: LD_VAR 0 4
112935: PPUSH
112936: CALL_OW 1
112940: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
112941: LD_ADDR_VAR 0 2
112945: PUSH
112946: LD_VAR 0 2
112950: PPUSH
112951: LD_INT 4
112953: PPUSH
112954: LD_VAR 0 2
112958: PUSH
112959: LD_INT 4
112961: ARRAY
112962: PUSH
112963: LD_VAR 0 4
112967: PLUS
112968: PPUSH
112969: CALL_OW 1
112973: ST_TO_ADDR
// end ;
112974: GO 112893
112976: POP
112977: POP
// end ;
112978: LD_VAR 0 2
112982: RET
// export function Length ( array ) ; begin
112983: LD_INT 0
112985: PPUSH
// result := array + 0 ;
112986: LD_ADDR_VAR 0 2
112990: PUSH
112991: LD_VAR 0 1
112995: PUSH
112996: LD_INT 0
112998: PLUS
112999: ST_TO_ADDR
// end ;
113000: LD_VAR 0 2
113004: RET
// export function PrepareArray ( array ) ; begin
113005: LD_INT 0
113007: PPUSH
// result := array diff 0 ;
113008: LD_ADDR_VAR 0 2
113012: PUSH
113013: LD_VAR 0 1
113017: PUSH
113018: LD_INT 0
113020: DIFF
113021: ST_TO_ADDR
// if not result [ 1 ] then
113022: LD_VAR 0 2
113026: PUSH
113027: LD_INT 1
113029: ARRAY
113030: NOT
113031: IFFALSE 113051
// result := Delete ( result , 1 ) ;
113033: LD_ADDR_VAR 0 2
113037: PUSH
113038: LD_VAR 0 2
113042: PPUSH
113043: LD_INT 1
113045: PPUSH
113046: CALL_OW 3
113050: ST_TO_ADDR
// end ;
113051: LD_VAR 0 2
113055: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
113056: LD_INT 0
113058: PPUSH
113059: PPUSH
113060: PPUSH
113061: PPUSH
// sibRocketRange := 25 ;
113062: LD_ADDR_VAR 0 6
113066: PUSH
113067: LD_INT 25
113069: ST_TO_ADDR
// result := false ;
113070: LD_ADDR_VAR 0 4
113074: PUSH
113075: LD_INT 0
113077: ST_TO_ADDR
// for i := 0 to 5 do
113078: LD_ADDR_VAR 0 5
113082: PUSH
113083: DOUBLE
113084: LD_INT 0
113086: DEC
113087: ST_TO_ADDR
113088: LD_INT 5
113090: PUSH
113091: FOR_TO
113092: IFFALSE 113159
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
113094: LD_VAR 0 1
113098: PPUSH
113099: LD_VAR 0 5
113103: PPUSH
113104: LD_VAR 0 6
113108: PPUSH
113109: CALL_OW 272
113113: PPUSH
113114: LD_VAR 0 2
113118: PPUSH
113119: LD_VAR 0 5
113123: PPUSH
113124: LD_VAR 0 6
113128: PPUSH
113129: CALL_OW 273
113133: PPUSH
113134: LD_VAR 0 3
113138: PPUSH
113139: CALL_OW 309
113143: IFFALSE 113157
// begin result := true ;
113145: LD_ADDR_VAR 0 4
113149: PUSH
113150: LD_INT 1
113152: ST_TO_ADDR
// exit ;
113153: POP
113154: POP
113155: GO 113161
// end ;
113157: GO 113091
113159: POP
113160: POP
// end ;
113161: LD_VAR 0 4
113165: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
113166: LD_INT 0
113168: PPUSH
113169: PPUSH
113170: PPUSH
// if btype = b_depot then
113171: LD_VAR 0 2
113175: PUSH
113176: LD_INT 0
113178: EQUAL
113179: IFFALSE 113191
// begin result := true ;
113181: LD_ADDR_VAR 0 3
113185: PUSH
113186: LD_INT 1
113188: ST_TO_ADDR
// exit ;
113189: GO 113311
// end ; pom := GetBase ( depot ) ;
113191: LD_ADDR_VAR 0 4
113195: PUSH
113196: LD_VAR 0 1
113200: PPUSH
113201: CALL_OW 274
113205: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
113206: LD_ADDR_VAR 0 5
113210: PUSH
113211: LD_VAR 0 2
113215: PPUSH
113216: LD_VAR 0 1
113220: PPUSH
113221: CALL_OW 248
113225: PPUSH
113226: CALL_OW 450
113230: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
113231: LD_ADDR_VAR 0 3
113235: PUSH
113236: LD_VAR 0 4
113240: PPUSH
113241: LD_INT 1
113243: PPUSH
113244: CALL_OW 275
113248: PUSH
113249: LD_VAR 0 5
113253: PUSH
113254: LD_INT 1
113256: ARRAY
113257: GREATEREQUAL
113258: IFFALSE 113284
113260: PUSH
113261: LD_VAR 0 4
113265: PPUSH
113266: LD_INT 2
113268: PPUSH
113269: CALL_OW 275
113273: PUSH
113274: LD_VAR 0 5
113278: PUSH
113279: LD_INT 2
113281: ARRAY
113282: GREATEREQUAL
113283: AND
113284: IFFALSE 113310
113286: PUSH
113287: LD_VAR 0 4
113291: PPUSH
113292: LD_INT 3
113294: PPUSH
113295: CALL_OW 275
113299: PUSH
113300: LD_VAR 0 5
113304: PUSH
113305: LD_INT 3
113307: ARRAY
113308: GREATEREQUAL
113309: AND
113310: ST_TO_ADDR
// end ;
113311: LD_VAR 0 3
113315: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
113316: LD_INT 0
113318: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
113319: LD_VAR 0 1
113323: PPUSH
113324: LD_VAR 0 2
113328: PPUSH
113329: LD_INT 0
113331: PPUSH
113332: LD_INT 0
113334: PPUSH
113335: LD_INT 1
113337: PPUSH
113338: LD_INT 0
113340: PPUSH
113341: CALL_OW 587
// end ;
113345: LD_VAR 0 3
113349: RET
// export function CenterOnNow ( unit ) ; begin
113350: LD_INT 0
113352: PPUSH
// result := IsInUnit ( unit ) ;
113353: LD_ADDR_VAR 0 2
113357: PUSH
113358: LD_VAR 0 1
113362: PPUSH
113363: CALL_OW 310
113367: ST_TO_ADDR
// if not result then
113368: LD_VAR 0 2
113372: NOT
113373: IFFALSE 113385
// result := unit ;
113375: LD_ADDR_VAR 0 2
113379: PUSH
113380: LD_VAR 0 1
113384: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
113385: LD_VAR 0 1
113389: PPUSH
113390: CALL_OW 87
// end ;
113394: LD_VAR 0 2
113398: RET
// export function ComMoveHex ( unit , hex ) ; begin
113399: LD_INT 0
113401: PPUSH
// if not hex then
113402: LD_VAR 0 2
113406: NOT
113407: IFFALSE 113411
// exit ;
113409: GO 113464
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
113411: LD_VAR 0 2
113415: PUSH
113416: LD_INT 1
113418: ARRAY
113419: PPUSH
113420: LD_VAR 0 2
113424: PUSH
113425: LD_INT 2
113427: ARRAY
113428: PPUSH
113429: CALL_OW 428
113433: IFFALSE 113437
// exit ;
113435: GO 113464
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
113437: LD_VAR 0 1
113441: PPUSH
113442: LD_VAR 0 2
113446: PUSH
113447: LD_INT 1
113449: ARRAY
113450: PPUSH
113451: LD_VAR 0 2
113455: PUSH
113456: LD_INT 2
113458: ARRAY
113459: PPUSH
113460: CALL_OW 111
// end ;
113464: LD_VAR 0 3
113468: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
113469: LD_INT 0
113471: PPUSH
113472: PPUSH
113473: PPUSH
// if not unit or not enemy then
113474: LD_VAR 0 1
113478: NOT
113479: IFTRUE 113488
113481: PUSH
113482: LD_VAR 0 2
113486: NOT
113487: OR
113488: IFFALSE 113492
// exit ;
113490: GO 113618
// x := GetX ( enemy ) ;
113492: LD_ADDR_VAR 0 4
113496: PUSH
113497: LD_VAR 0 2
113501: PPUSH
113502: CALL_OW 250
113506: ST_TO_ADDR
// y := GetY ( enemy ) ;
113507: LD_ADDR_VAR 0 5
113511: PUSH
113512: LD_VAR 0 2
113516: PPUSH
113517: CALL_OW 251
113521: ST_TO_ADDR
// if ValidHex ( x , y ) then
113522: LD_VAR 0 4
113526: PPUSH
113527: LD_VAR 0 5
113531: PPUSH
113532: CALL_OW 488
113536: IFFALSE 113618
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
113538: LD_VAR 0 2
113542: PPUSH
113543: CALL_OW 247
113547: PUSH
113548: LD_INT 3
113550: PUSH
113551: LD_INT 2
113553: PUSH
113554: EMPTY
113555: LIST
113556: LIST
113557: IN
113558: IFTRUE 113581
113560: PUSH
113561: LD_VAR 0 1
113565: PPUSH
113566: CALL_OW 255
113570: PPUSH
113571: LD_VAR 0 2
113575: PPUSH
113576: CALL_OW 292
113580: OR
113581: IFFALSE 113599
// ComAttackUnit ( unit , enemy ) else
113583: LD_VAR 0 1
113587: PPUSH
113588: LD_VAR 0 2
113592: PPUSH
113593: CALL_OW 115
113597: GO 113618
// ComAgressiveMove ( unit , x , y ) ;
113599: LD_VAR 0 1
113603: PPUSH
113604: LD_VAR 0 4
113608: PPUSH
113609: LD_VAR 0 5
113613: PPUSH
113614: CALL_OW 114
// end ;
113618: LD_VAR 0 3
113622: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
113623: LD_INT 0
113625: PPUSH
113626: PPUSH
113627: PPUSH
// list := AreaToList ( area , 0 ) ;
113628: LD_ADDR_VAR 0 5
113632: PUSH
113633: LD_VAR 0 1
113637: PPUSH
113638: LD_INT 0
113640: PPUSH
113641: CALL_OW 517
113645: ST_TO_ADDR
// if not list then
113646: LD_VAR 0 5
113650: NOT
113651: IFFALSE 113655
// exit ;
113653: GO 113785
// if all then
113655: LD_VAR 0 2
113659: IFFALSE 113747
// begin for i := 1 to list [ 1 ] do
113661: LD_ADDR_VAR 0 4
113665: PUSH
113666: DOUBLE
113667: LD_INT 1
113669: DEC
113670: ST_TO_ADDR
113671: LD_VAR 0 5
113675: PUSH
113676: LD_INT 1
113678: ARRAY
113679: PUSH
113680: FOR_TO
113681: IFFALSE 113743
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
113683: LD_ADDR_VAR 0 3
113687: PUSH
113688: LD_VAR 0 3
113692: PPUSH
113693: LD_VAR 0 3
113697: PUSH
113698: LD_INT 1
113700: PLUS
113701: PPUSH
113702: LD_VAR 0 5
113706: PUSH
113707: LD_INT 1
113709: ARRAY
113710: PUSH
113711: LD_VAR 0 4
113715: ARRAY
113716: PUSH
113717: LD_VAR 0 5
113721: PUSH
113722: LD_INT 2
113724: ARRAY
113725: PUSH
113726: LD_VAR 0 4
113730: ARRAY
113731: PUSH
113732: EMPTY
113733: LIST
113734: LIST
113735: PPUSH
113736: CALL_OW 1
113740: ST_TO_ADDR
113741: GO 113680
113743: POP
113744: POP
// exit ;
113745: GO 113785
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
113747: LD_ADDR_VAR 0 3
113751: PUSH
113752: LD_VAR 0 5
113756: PUSH
113757: LD_INT 1
113759: ARRAY
113760: PUSH
113761: LD_INT 1
113763: ARRAY
113764: PUSH
113765: LD_VAR 0 5
113769: PUSH
113770: LD_INT 2
113772: ARRAY
113773: PUSH
113774: LD_INT 1
113776: ARRAY
113777: PUSH
113778: EMPTY
113779: LIST
113780: LIST
113781: PUSH
113782: EMPTY
113783: LIST
113784: ST_TO_ADDR
// end ;
113785: LD_VAR 0 3
113789: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
113790: LD_INT 0
113792: PPUSH
113793: PPUSH
// list := AreaToList ( area , 0 ) ;
113794: LD_ADDR_VAR 0 4
113798: PUSH
113799: LD_VAR 0 1
113803: PPUSH
113804: LD_INT 0
113806: PPUSH
113807: CALL_OW 517
113811: ST_TO_ADDR
// if not list then
113812: LD_VAR 0 4
113816: NOT
113817: IFFALSE 113821
// exit ;
113819: GO 113862
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
113821: LD_ADDR_VAR 0 3
113825: PUSH
113826: LD_VAR 0 4
113830: PUSH
113831: LD_INT 1
113833: ARRAY
113834: PUSH
113835: LD_INT 1
113837: ARRAY
113838: PUSH
113839: LD_VAR 0 4
113843: PUSH
113844: LD_INT 2
113846: ARRAY
113847: PUSH
113848: LD_INT 1
113850: ARRAY
113851: PUSH
113852: LD_VAR 0 2
113856: PUSH
113857: EMPTY
113858: LIST
113859: LIST
113860: LIST
113861: ST_TO_ADDR
// end ;
113862: LD_VAR 0 3
113866: RET
// export function First ( array ) ; begin
113867: LD_INT 0
113869: PPUSH
// if not array then
113870: LD_VAR 0 1
113874: NOT
113875: IFFALSE 113879
// exit ;
113877: GO 113893
// result := array [ 1 ] ;
113879: LD_ADDR_VAR 0 2
113883: PUSH
113884: LD_VAR 0 1
113888: PUSH
113889: LD_INT 1
113891: ARRAY
113892: ST_TO_ADDR
// end ;
113893: LD_VAR 0 2
113897: RET
// export function Last ( array ) ; begin
113898: LD_INT 0
113900: PPUSH
// if not array then
113901: LD_VAR 0 1
113905: NOT
113906: IFFALSE 113910
// exit ;
113908: GO 113926
// result := array [ array ] ;
113910: LD_ADDR_VAR 0 2
113914: PUSH
113915: LD_VAR 0 1
113919: PUSH
113920: LD_VAR 0 1
113924: ARRAY
113925: ST_TO_ADDR
// end ;
113926: LD_VAR 0 2
113930: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
113931: LD_INT 0
113933: PPUSH
113934: PPUSH
// result := [ ] ;
113935: LD_ADDR_VAR 0 5
113939: PUSH
113940: EMPTY
113941: ST_TO_ADDR
// if not array then
113942: LD_VAR 0 1
113946: NOT
113947: IFFALSE 113951
// exit ;
113949: GO 114063
// for i := 1 to array do
113951: LD_ADDR_VAR 0 6
113955: PUSH
113956: DOUBLE
113957: LD_INT 1
113959: DEC
113960: ST_TO_ADDR
113961: LD_VAR 0 1
113965: PUSH
113966: FOR_TO
113967: IFFALSE 114061
// if array [ i ] [ index ] = value then
113969: LD_VAR 0 1
113973: PUSH
113974: LD_VAR 0 6
113978: ARRAY
113979: PUSH
113980: LD_VAR 0 2
113984: ARRAY
113985: PUSH
113986: LD_VAR 0 3
113990: EQUAL
113991: IFFALSE 114059
// begin if indexColumn then
113993: LD_VAR 0 4
113997: IFFALSE 114033
// result := Join ( result , array [ i ] [ indexColumn ] ) else
113999: LD_ADDR_VAR 0 5
114003: PUSH
114004: LD_VAR 0 5
114008: PPUSH
114009: LD_VAR 0 1
114013: PUSH
114014: LD_VAR 0 6
114018: ARRAY
114019: PUSH
114020: LD_VAR 0 4
114024: ARRAY
114025: PPUSH
114026: CALL 109071 0 2
114030: ST_TO_ADDR
114031: GO 114059
// result := Join ( result , array [ i ] ) ;
114033: LD_ADDR_VAR 0 5
114037: PUSH
114038: LD_VAR 0 5
114042: PPUSH
114043: LD_VAR 0 1
114047: PUSH
114048: LD_VAR 0 6
114052: ARRAY
114053: PPUSH
114054: CALL 109071 0 2
114058: ST_TO_ADDR
// end ;
114059: GO 113966
114061: POP
114062: POP
// end ;
114063: LD_VAR 0 5
114067: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
114068: LD_INT 0
114070: PPUSH
// if not vehicles or not parkingPoint then
114071: LD_VAR 0 1
114075: NOT
114076: IFTRUE 114085
114078: PUSH
114079: LD_VAR 0 2
114083: NOT
114084: OR
114085: IFFALSE 114089
// exit ;
114087: GO 114187
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
114089: LD_ADDR_VAR 0 1
114093: PUSH
114094: LD_VAR 0 1
114098: PPUSH
114099: LD_INT 50
114101: PUSH
114102: EMPTY
114103: LIST
114104: PUSH
114105: LD_INT 3
114107: PUSH
114108: LD_INT 92
114110: PUSH
114111: LD_VAR 0 2
114115: PUSH
114116: LD_INT 1
114118: ARRAY
114119: PUSH
114120: LD_VAR 0 2
114124: PUSH
114125: LD_INT 2
114127: ARRAY
114128: PUSH
114129: LD_INT 8
114131: PUSH
114132: EMPTY
114133: LIST
114134: LIST
114135: LIST
114136: LIST
114137: PUSH
114138: EMPTY
114139: LIST
114140: LIST
114141: PUSH
114142: EMPTY
114143: LIST
114144: LIST
114145: PPUSH
114146: CALL_OW 72
114150: ST_TO_ADDR
// if not vehicles then
114151: LD_VAR 0 1
114155: NOT
114156: IFFALSE 114160
// exit ;
114158: GO 114187
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
114160: LD_VAR 0 1
114164: PPUSH
114165: LD_VAR 0 2
114169: PUSH
114170: LD_INT 1
114172: ARRAY
114173: PPUSH
114174: LD_VAR 0 2
114178: PUSH
114179: LD_INT 2
114181: ARRAY
114182: PPUSH
114183: CALL_OW 111
// end ;
114187: LD_VAR 0 3
114191: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
114192: LD_INT 0
114194: PPUSH
114195: PPUSH
114196: PPUSH
// if not side or not area then
114197: LD_VAR 0 1
114201: NOT
114202: IFTRUE 114211
114204: PUSH
114205: LD_VAR 0 2
114209: NOT
114210: OR
114211: IFFALSE 114215
// exit ;
114213: GO 114334
// tmp := AreaToList ( area , 0 ) ;
114215: LD_ADDR_VAR 0 5
114219: PUSH
114220: LD_VAR 0 2
114224: PPUSH
114225: LD_INT 0
114227: PPUSH
114228: CALL_OW 517
114232: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
114233: LD_ADDR_VAR 0 4
114237: PUSH
114238: DOUBLE
114239: LD_INT 1
114241: DEC
114242: ST_TO_ADDR
114243: LD_VAR 0 5
114247: PUSH
114248: LD_INT 1
114250: ARRAY
114251: PUSH
114252: FOR_TO
114253: IFFALSE 114332
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
114255: LD_VAR 0 5
114259: PUSH
114260: LD_INT 1
114262: ARRAY
114263: PUSH
114264: LD_VAR 0 4
114268: ARRAY
114269: PPUSH
114270: LD_VAR 0 5
114274: PUSH
114275: LD_INT 2
114277: ARRAY
114278: PUSH
114279: LD_VAR 0 4
114283: ARRAY
114284: PPUSH
114285: CALL_OW 351
114289: IFFALSE 114330
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
114291: LD_VAR 0 5
114295: PUSH
114296: LD_INT 1
114298: ARRAY
114299: PUSH
114300: LD_VAR 0 4
114304: ARRAY
114305: PPUSH
114306: LD_VAR 0 5
114310: PUSH
114311: LD_INT 2
114313: ARRAY
114314: PUSH
114315: LD_VAR 0 4
114319: ARRAY
114320: PPUSH
114321: LD_VAR 0 1
114325: PPUSH
114326: CALL_OW 244
// end ;
114330: GO 114252
114332: POP
114333: POP
// end ; end_of_file end_of_file
114334: LD_VAR 0 3
114338: RET
// export globalGameSaveCounter ; every 0 0$1 do
114339: GO 114341
114341: DISABLE
// begin enable ;
114342: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
114343: LD_STRING updateTimer(
114345: PUSH
114346: LD_OWVAR 1
114350: STR
114351: PUSH
114352: LD_STRING );
114354: STR
114355: PPUSH
114356: CALL_OW 559
// end ;
114360: END
// every 0 0$1 do
114361: GO 114363
114363: DISABLE
// begin globalGameSaveCounter := 0 ;
114364: LD_ADDR_EXP 147
114368: PUSH
114369: LD_INT 0
114371: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
114372: LD_STRING setGameSaveCounter(0)
114374: PPUSH
114375: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
114379: LD_STRING initStreamRollete();
114381: PPUSH
114382: CALL_OW 559
// InitStreamMode ;
114386: CALL 115731 0 0
// DefineStreamItems ( false ) ;
114390: LD_INT 0
114392: PPUSH
114393: CALL 116195 0 1
// end ;
114397: END
// export function SOS_MapStart ( ) ; begin
114398: LD_INT 0
114400: PPUSH
// if streamModeActive then
114401: LD_EXP 148
114405: IFFALSE 114414
// DefineStreamItems ( true ) ;
114407: LD_INT 1
114409: PPUSH
114410: CALL 116195 0 1
// UpdateLuaVariables ( ) ;
114414: CALL 114431 0 0
// UpdateFactoryWaypoints ( ) ;
114418: CALL 129317 0 0
// UpdateWarehouseGatheringPoints ( ) ;
114422: CALL 129569 0 0
// end ;
114426: LD_VAR 0 1
114430: RET
// function UpdateLuaVariables ( ) ; begin
114431: LD_INT 0
114433: PPUSH
// if globalGameSaveCounter then
114434: LD_EXP 147
114438: IFFALSE 114472
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
114440: LD_ADDR_EXP 147
114444: PUSH
114445: LD_EXP 147
114449: PPUSH
114450: CALL 110444 0 1
114454: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114455: LD_STRING setGameSaveCounter(
114457: PUSH
114458: LD_EXP 147
114462: STR
114463: PUSH
114464: LD_STRING )
114466: STR
114467: PPUSH
114468: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
114472: LD_STRING setGameDifficulty(
114474: PUSH
114475: LD_OWVAR 67
114479: STR
114480: PUSH
114481: LD_STRING )
114483: STR
114484: PPUSH
114485: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
114489: LD_STRING displayDifficulty(
114491: PUSH
114492: LD_OWVAR 67
114496: STR
114497: PUSH
114498: LD_STRING )
114500: STR
114501: PPUSH
114502: CALL_OW 559
// end ;
114506: LD_VAR 0 1
114510: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
114511: LD_INT 0
114513: PPUSH
// if p2 = stream_mode then
114514: LD_VAR 0 2
114518: PUSH
114519: LD_INT 100
114521: EQUAL
114522: IFFALSE 115525
// begin if not StreamModeActive then
114524: LD_EXP 148
114528: NOT
114529: IFFALSE 114539
// StreamModeActive := true ;
114531: LD_ADDR_EXP 148
114535: PUSH
114536: LD_INT 1
114538: ST_TO_ADDR
// if p3 = 0 then
114539: LD_VAR 0 3
114543: PUSH
114544: LD_INT 0
114546: EQUAL
114547: IFFALSE 114553
// InitStreamMode ;
114549: CALL 115731 0 0
// if p3 = 1 then
114553: LD_VAR 0 3
114557: PUSH
114558: LD_INT 1
114560: EQUAL
114561: IFFALSE 114571
// sRocket := true ;
114563: LD_ADDR_EXP 153
114567: PUSH
114568: LD_INT 1
114570: ST_TO_ADDR
// if p3 = 2 then
114571: LD_VAR 0 3
114575: PUSH
114576: LD_INT 2
114578: EQUAL
114579: IFFALSE 114589
// sSpeed := true ;
114581: LD_ADDR_EXP 152
114585: PUSH
114586: LD_INT 1
114588: ST_TO_ADDR
// if p3 = 3 then
114589: LD_VAR 0 3
114593: PUSH
114594: LD_INT 3
114596: EQUAL
114597: IFFALSE 114607
// sEngine := true ;
114599: LD_ADDR_EXP 154
114603: PUSH
114604: LD_INT 1
114606: ST_TO_ADDR
// if p3 = 4 then
114607: LD_VAR 0 3
114611: PUSH
114612: LD_INT 4
114614: EQUAL
114615: IFFALSE 114625
// sSpec := true ;
114617: LD_ADDR_EXP 151
114621: PUSH
114622: LD_INT 1
114624: ST_TO_ADDR
// if p3 = 5 then
114625: LD_VAR 0 3
114629: PUSH
114630: LD_INT 5
114632: EQUAL
114633: IFFALSE 114643
// sLevel := true ;
114635: LD_ADDR_EXP 155
114639: PUSH
114640: LD_INT 1
114642: ST_TO_ADDR
// if p3 = 6 then
114643: LD_VAR 0 3
114647: PUSH
114648: LD_INT 6
114650: EQUAL
114651: IFFALSE 114661
// sArmoury := true ;
114653: LD_ADDR_EXP 156
114657: PUSH
114658: LD_INT 1
114660: ST_TO_ADDR
// if p3 = 7 then
114661: LD_VAR 0 3
114665: PUSH
114666: LD_INT 7
114668: EQUAL
114669: IFFALSE 114679
// sRadar := true ;
114671: LD_ADDR_EXP 157
114675: PUSH
114676: LD_INT 1
114678: ST_TO_ADDR
// if p3 = 8 then
114679: LD_VAR 0 3
114683: PUSH
114684: LD_INT 8
114686: EQUAL
114687: IFFALSE 114697
// sBunker := true ;
114689: LD_ADDR_EXP 158
114693: PUSH
114694: LD_INT 1
114696: ST_TO_ADDR
// if p3 = 9 then
114697: LD_VAR 0 3
114701: PUSH
114702: LD_INT 9
114704: EQUAL
114705: IFFALSE 114715
// sHack := true ;
114707: LD_ADDR_EXP 159
114711: PUSH
114712: LD_INT 1
114714: ST_TO_ADDR
// if p3 = 10 then
114715: LD_VAR 0 3
114719: PUSH
114720: LD_INT 10
114722: EQUAL
114723: IFFALSE 114733
// sFire := true ;
114725: LD_ADDR_EXP 160
114729: PUSH
114730: LD_INT 1
114732: ST_TO_ADDR
// if p3 = 11 then
114733: LD_VAR 0 3
114737: PUSH
114738: LD_INT 11
114740: EQUAL
114741: IFFALSE 114751
// sRefresh := true ;
114743: LD_ADDR_EXP 161
114747: PUSH
114748: LD_INT 1
114750: ST_TO_ADDR
// if p3 = 12 then
114751: LD_VAR 0 3
114755: PUSH
114756: LD_INT 12
114758: EQUAL
114759: IFFALSE 114769
// sExp := true ;
114761: LD_ADDR_EXP 162
114765: PUSH
114766: LD_INT 1
114768: ST_TO_ADDR
// if p3 = 13 then
114769: LD_VAR 0 3
114773: PUSH
114774: LD_INT 13
114776: EQUAL
114777: IFFALSE 114787
// sDepot := true ;
114779: LD_ADDR_EXP 163
114783: PUSH
114784: LD_INT 1
114786: ST_TO_ADDR
// if p3 = 14 then
114787: LD_VAR 0 3
114791: PUSH
114792: LD_INT 14
114794: EQUAL
114795: IFFALSE 114805
// sFlag := true ;
114797: LD_ADDR_EXP 164
114801: PUSH
114802: LD_INT 1
114804: ST_TO_ADDR
// if p3 = 15 then
114805: LD_VAR 0 3
114809: PUSH
114810: LD_INT 15
114812: EQUAL
114813: IFFALSE 114823
// sKamikadze := true ;
114815: LD_ADDR_EXP 172
114819: PUSH
114820: LD_INT 1
114822: ST_TO_ADDR
// if p3 = 16 then
114823: LD_VAR 0 3
114827: PUSH
114828: LD_INT 16
114830: EQUAL
114831: IFFALSE 114841
// sTroll := true ;
114833: LD_ADDR_EXP 173
114837: PUSH
114838: LD_INT 1
114840: ST_TO_ADDR
// if p3 = 17 then
114841: LD_VAR 0 3
114845: PUSH
114846: LD_INT 17
114848: EQUAL
114849: IFFALSE 114859
// sSlow := true ;
114851: LD_ADDR_EXP 174
114855: PUSH
114856: LD_INT 1
114858: ST_TO_ADDR
// if p3 = 18 then
114859: LD_VAR 0 3
114863: PUSH
114864: LD_INT 18
114866: EQUAL
114867: IFFALSE 114877
// sLack := true ;
114869: LD_ADDR_EXP 175
114873: PUSH
114874: LD_INT 1
114876: ST_TO_ADDR
// if p3 = 19 then
114877: LD_VAR 0 3
114881: PUSH
114882: LD_INT 19
114884: EQUAL
114885: IFFALSE 114895
// sTank := true ;
114887: LD_ADDR_EXP 177
114891: PUSH
114892: LD_INT 1
114894: ST_TO_ADDR
// if p3 = 20 then
114895: LD_VAR 0 3
114899: PUSH
114900: LD_INT 20
114902: EQUAL
114903: IFFALSE 114913
// sRemote := true ;
114905: LD_ADDR_EXP 178
114909: PUSH
114910: LD_INT 1
114912: ST_TO_ADDR
// if p3 = 21 then
114913: LD_VAR 0 3
114917: PUSH
114918: LD_INT 21
114920: EQUAL
114921: IFFALSE 114931
// sPowell := true ;
114923: LD_ADDR_EXP 179
114927: PUSH
114928: LD_INT 1
114930: ST_TO_ADDR
// if p3 = 22 then
114931: LD_VAR 0 3
114935: PUSH
114936: LD_INT 22
114938: EQUAL
114939: IFFALSE 114949
// sTeleport := true ;
114941: LD_ADDR_EXP 182
114945: PUSH
114946: LD_INT 1
114948: ST_TO_ADDR
// if p3 = 23 then
114949: LD_VAR 0 3
114953: PUSH
114954: LD_INT 23
114956: EQUAL
114957: IFFALSE 114967
// sOilTower := true ;
114959: LD_ADDR_EXP 184
114963: PUSH
114964: LD_INT 1
114966: ST_TO_ADDR
// if p3 = 24 then
114967: LD_VAR 0 3
114971: PUSH
114972: LD_INT 24
114974: EQUAL
114975: IFFALSE 114985
// sShovel := true ;
114977: LD_ADDR_EXP 185
114981: PUSH
114982: LD_INT 1
114984: ST_TO_ADDR
// if p3 = 25 then
114985: LD_VAR 0 3
114989: PUSH
114990: LD_INT 25
114992: EQUAL
114993: IFFALSE 115003
// sSheik := true ;
114995: LD_ADDR_EXP 186
114999: PUSH
115000: LD_INT 1
115002: ST_TO_ADDR
// if p3 = 26 then
115003: LD_VAR 0 3
115007: PUSH
115008: LD_INT 26
115010: EQUAL
115011: IFFALSE 115021
// sEarthquake := true ;
115013: LD_ADDR_EXP 188
115017: PUSH
115018: LD_INT 1
115020: ST_TO_ADDR
// if p3 = 27 then
115021: LD_VAR 0 3
115025: PUSH
115026: LD_INT 27
115028: EQUAL
115029: IFFALSE 115039
// sAI := true ;
115031: LD_ADDR_EXP 189
115035: PUSH
115036: LD_INT 1
115038: ST_TO_ADDR
// if p3 = 28 then
115039: LD_VAR 0 3
115043: PUSH
115044: LD_INT 28
115046: EQUAL
115047: IFFALSE 115057
// sCargo := true ;
115049: LD_ADDR_EXP 192
115053: PUSH
115054: LD_INT 1
115056: ST_TO_ADDR
// if p3 = 29 then
115057: LD_VAR 0 3
115061: PUSH
115062: LD_INT 29
115064: EQUAL
115065: IFFALSE 115075
// sDLaser := true ;
115067: LD_ADDR_EXP 193
115071: PUSH
115072: LD_INT 1
115074: ST_TO_ADDR
// if p3 = 30 then
115075: LD_VAR 0 3
115079: PUSH
115080: LD_INT 30
115082: EQUAL
115083: IFFALSE 115093
// sExchange := true ;
115085: LD_ADDR_EXP 194
115089: PUSH
115090: LD_INT 1
115092: ST_TO_ADDR
// if p3 = 31 then
115093: LD_VAR 0 3
115097: PUSH
115098: LD_INT 31
115100: EQUAL
115101: IFFALSE 115111
// sFac := true ;
115103: LD_ADDR_EXP 195
115107: PUSH
115108: LD_INT 1
115110: ST_TO_ADDR
// if p3 = 32 then
115111: LD_VAR 0 3
115115: PUSH
115116: LD_INT 32
115118: EQUAL
115119: IFFALSE 115129
// sPower := true ;
115121: LD_ADDR_EXP 196
115125: PUSH
115126: LD_INT 1
115128: ST_TO_ADDR
// if p3 = 33 then
115129: LD_VAR 0 3
115133: PUSH
115134: LD_INT 33
115136: EQUAL
115137: IFFALSE 115147
// sRandom := true ;
115139: LD_ADDR_EXP 197
115143: PUSH
115144: LD_INT 1
115146: ST_TO_ADDR
// if p3 = 34 then
115147: LD_VAR 0 3
115151: PUSH
115152: LD_INT 34
115154: EQUAL
115155: IFFALSE 115165
// sShield := true ;
115157: LD_ADDR_EXP 198
115161: PUSH
115162: LD_INT 1
115164: ST_TO_ADDR
// if p3 = 35 then
115165: LD_VAR 0 3
115169: PUSH
115170: LD_INT 35
115172: EQUAL
115173: IFFALSE 115183
// sTime := true ;
115175: LD_ADDR_EXP 199
115179: PUSH
115180: LD_INT 1
115182: ST_TO_ADDR
// if p3 = 36 then
115183: LD_VAR 0 3
115187: PUSH
115188: LD_INT 36
115190: EQUAL
115191: IFFALSE 115201
// sTools := true ;
115193: LD_ADDR_EXP 200
115197: PUSH
115198: LD_INT 1
115200: ST_TO_ADDR
// if p3 = 101 then
115201: LD_VAR 0 3
115205: PUSH
115206: LD_INT 101
115208: EQUAL
115209: IFFALSE 115219
// sSold := true ;
115211: LD_ADDR_EXP 165
115215: PUSH
115216: LD_INT 1
115218: ST_TO_ADDR
// if p3 = 102 then
115219: LD_VAR 0 3
115223: PUSH
115224: LD_INT 102
115226: EQUAL
115227: IFFALSE 115237
// sDiff := true ;
115229: LD_ADDR_EXP 166
115233: PUSH
115234: LD_INT 1
115236: ST_TO_ADDR
// if p3 = 103 then
115237: LD_VAR 0 3
115241: PUSH
115242: LD_INT 103
115244: EQUAL
115245: IFFALSE 115255
// sFog := true ;
115247: LD_ADDR_EXP 169
115251: PUSH
115252: LD_INT 1
115254: ST_TO_ADDR
// if p3 = 104 then
115255: LD_VAR 0 3
115259: PUSH
115260: LD_INT 104
115262: EQUAL
115263: IFFALSE 115273
// sReset := true ;
115265: LD_ADDR_EXP 170
115269: PUSH
115270: LD_INT 1
115272: ST_TO_ADDR
// if p3 = 105 then
115273: LD_VAR 0 3
115277: PUSH
115278: LD_INT 105
115280: EQUAL
115281: IFFALSE 115291
// sSun := true ;
115283: LD_ADDR_EXP 171
115287: PUSH
115288: LD_INT 1
115290: ST_TO_ADDR
// if p3 = 106 then
115291: LD_VAR 0 3
115295: PUSH
115296: LD_INT 106
115298: EQUAL
115299: IFFALSE 115309
// sTiger := true ;
115301: LD_ADDR_EXP 167
115305: PUSH
115306: LD_INT 1
115308: ST_TO_ADDR
// if p3 = 107 then
115309: LD_VAR 0 3
115313: PUSH
115314: LD_INT 107
115316: EQUAL
115317: IFFALSE 115327
// sBomb := true ;
115319: LD_ADDR_EXP 168
115323: PUSH
115324: LD_INT 1
115326: ST_TO_ADDR
// if p3 = 108 then
115327: LD_VAR 0 3
115331: PUSH
115332: LD_INT 108
115334: EQUAL
115335: IFFALSE 115345
// sWound := true ;
115337: LD_ADDR_EXP 176
115341: PUSH
115342: LD_INT 1
115344: ST_TO_ADDR
// if p3 = 109 then
115345: LD_VAR 0 3
115349: PUSH
115350: LD_INT 109
115352: EQUAL
115353: IFFALSE 115363
// sBetray := true ;
115355: LD_ADDR_EXP 180
115359: PUSH
115360: LD_INT 1
115362: ST_TO_ADDR
// if p3 = 110 then
115363: LD_VAR 0 3
115367: PUSH
115368: LD_INT 110
115370: EQUAL
115371: IFFALSE 115381
// sContamin := true ;
115373: LD_ADDR_EXP 181
115377: PUSH
115378: LD_INT 1
115380: ST_TO_ADDR
// if p3 = 111 then
115381: LD_VAR 0 3
115385: PUSH
115386: LD_INT 111
115388: EQUAL
115389: IFFALSE 115399
// sOil := true ;
115391: LD_ADDR_EXP 183
115395: PUSH
115396: LD_INT 1
115398: ST_TO_ADDR
// if p3 = 112 then
115399: LD_VAR 0 3
115403: PUSH
115404: LD_INT 112
115406: EQUAL
115407: IFFALSE 115417
// sStu := true ;
115409: LD_ADDR_EXP 187
115413: PUSH
115414: LD_INT 1
115416: ST_TO_ADDR
// if p3 = 113 then
115417: LD_VAR 0 3
115421: PUSH
115422: LD_INT 113
115424: EQUAL
115425: IFFALSE 115435
// sBazooka := true ;
115427: LD_ADDR_EXP 190
115431: PUSH
115432: LD_INT 1
115434: ST_TO_ADDR
// if p3 = 114 then
115435: LD_VAR 0 3
115439: PUSH
115440: LD_INT 114
115442: EQUAL
115443: IFFALSE 115453
// sMortar := true ;
115445: LD_ADDR_EXP 191
115449: PUSH
115450: LD_INT 1
115452: ST_TO_ADDR
// if p3 = 115 then
115453: LD_VAR 0 3
115457: PUSH
115458: LD_INT 115
115460: EQUAL
115461: IFFALSE 115471
// sRanger := true ;
115463: LD_ADDR_EXP 201
115467: PUSH
115468: LD_INT 1
115470: ST_TO_ADDR
// if p3 = 116 then
115471: LD_VAR 0 3
115475: PUSH
115476: LD_INT 116
115478: EQUAL
115479: IFFALSE 115489
// sComputer := true ;
115481: LD_ADDR_EXP 202
115485: PUSH
115486: LD_INT 1
115488: ST_TO_ADDR
// if p3 = 117 then
115489: LD_VAR 0 3
115493: PUSH
115494: LD_INT 117
115496: EQUAL
115497: IFFALSE 115507
// s30 := true ;
115499: LD_ADDR_EXP 203
115503: PUSH
115504: LD_INT 1
115506: ST_TO_ADDR
// if p3 = 118 then
115507: LD_VAR 0 3
115511: PUSH
115512: LD_INT 118
115514: EQUAL
115515: IFFALSE 115525
// s60 := true ;
115517: LD_ADDR_EXP 204
115521: PUSH
115522: LD_INT 1
115524: ST_TO_ADDR
// end ; if p2 = hack_mode then
115525: LD_VAR 0 2
115529: PUSH
115530: LD_INT 101
115532: EQUAL
115533: IFFALSE 115661
// begin case p3 of 1 :
115535: LD_VAR 0 3
115539: PUSH
115540: LD_INT 1
115542: DOUBLE
115543: EQUAL
115544: IFTRUE 115548
115546: GO 115555
115548: POP
// hHackUnlimitedResources ; 2 :
115549: CALL 127924 0 0
115553: GO 115661
115555: LD_INT 2
115557: DOUBLE
115558: EQUAL
115559: IFTRUE 115563
115561: GO 115570
115563: POP
// hHackSetLevel10 ; 3 :
115564: CALL 128057 0 0
115568: GO 115661
115570: LD_INT 3
115572: DOUBLE
115573: EQUAL
115574: IFTRUE 115578
115576: GO 115585
115578: POP
// hHackSetLevel10YourUnits ; 4 :
115579: CALL 128142 0 0
115583: GO 115661
115585: LD_INT 4
115587: DOUBLE
115588: EQUAL
115589: IFTRUE 115593
115591: GO 115600
115593: POP
// hHackInvincible ; 5 :
115594: CALL 128590 0 0
115598: GO 115661
115600: LD_INT 5
115602: DOUBLE
115603: EQUAL
115604: IFTRUE 115608
115606: GO 115615
115608: POP
// hHackInvisible ; 6 :
115609: CALL 128701 0 0
115613: GO 115661
115615: LD_INT 6
115617: DOUBLE
115618: EQUAL
115619: IFTRUE 115623
115621: GO 115630
115623: POP
// hHackChangeYourSide ; 7 :
115624: CALL 128758 0 0
115628: GO 115661
115630: LD_INT 7
115632: DOUBLE
115633: EQUAL
115634: IFTRUE 115638
115636: GO 115645
115638: POP
// hHackChangeUnitSide ; 8 :
115639: CALL 128800 0 0
115643: GO 115661
115645: LD_INT 8
115647: DOUBLE
115648: EQUAL
115649: IFTRUE 115653
115651: GO 115660
115653: POP
// hHackFog ; end ;
115654: CALL 128901 0 0
115658: GO 115661
115660: POP
// end ; if p2 = game_save_mode then
115661: LD_VAR 0 2
115665: PUSH
115666: LD_INT 102
115668: EQUAL
115669: IFFALSE 115726
// begin if p3 = 1 then
115671: LD_VAR 0 3
115675: PUSH
115676: LD_INT 1
115678: EQUAL
115679: IFFALSE 115691
// globalGameSaveCounter := p4 ;
115681: LD_ADDR_EXP 147
115685: PUSH
115686: LD_VAR 0 4
115690: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
115691: LD_VAR 0 3
115695: PUSH
115696: LD_INT 2
115698: EQUAL
115699: IFFALSE 115707
115701: PUSH
115702: LD_EXP 147
115706: AND
115707: IFFALSE 115726
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
115709: LD_STRING setGameSaveCounter(
115711: PUSH
115712: LD_EXP 147
115716: STR
115717: PUSH
115718: LD_STRING )
115720: STR
115721: PPUSH
115722: CALL_OW 559
// end ; end ;
115726: LD_VAR 0 7
115730: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
115731: LD_INT 0
115733: PPUSH
// streamModeActive := false ;
115734: LD_ADDR_EXP 148
115738: PUSH
115739: LD_INT 0
115741: ST_TO_ADDR
// normalCounter := 36 ;
115742: LD_ADDR_EXP 149
115746: PUSH
115747: LD_INT 36
115749: ST_TO_ADDR
// hardcoreCounter := 18 ;
115750: LD_ADDR_EXP 150
115754: PUSH
115755: LD_INT 18
115757: ST_TO_ADDR
// sRocket := false ;
115758: LD_ADDR_EXP 153
115762: PUSH
115763: LD_INT 0
115765: ST_TO_ADDR
// sSpeed := false ;
115766: LD_ADDR_EXP 152
115770: PUSH
115771: LD_INT 0
115773: ST_TO_ADDR
// sEngine := false ;
115774: LD_ADDR_EXP 154
115778: PUSH
115779: LD_INT 0
115781: ST_TO_ADDR
// sSpec := false ;
115782: LD_ADDR_EXP 151
115786: PUSH
115787: LD_INT 0
115789: ST_TO_ADDR
// sLevel := false ;
115790: LD_ADDR_EXP 155
115794: PUSH
115795: LD_INT 0
115797: ST_TO_ADDR
// sArmoury := false ;
115798: LD_ADDR_EXP 156
115802: PUSH
115803: LD_INT 0
115805: ST_TO_ADDR
// sRadar := false ;
115806: LD_ADDR_EXP 157
115810: PUSH
115811: LD_INT 0
115813: ST_TO_ADDR
// sBunker := false ;
115814: LD_ADDR_EXP 158
115818: PUSH
115819: LD_INT 0
115821: ST_TO_ADDR
// sHack := false ;
115822: LD_ADDR_EXP 159
115826: PUSH
115827: LD_INT 0
115829: ST_TO_ADDR
// sFire := false ;
115830: LD_ADDR_EXP 160
115834: PUSH
115835: LD_INT 0
115837: ST_TO_ADDR
// sRefresh := false ;
115838: LD_ADDR_EXP 161
115842: PUSH
115843: LD_INT 0
115845: ST_TO_ADDR
// sExp := false ;
115846: LD_ADDR_EXP 162
115850: PUSH
115851: LD_INT 0
115853: ST_TO_ADDR
// sDepot := false ;
115854: LD_ADDR_EXP 163
115858: PUSH
115859: LD_INT 0
115861: ST_TO_ADDR
// sFlag := false ;
115862: LD_ADDR_EXP 164
115866: PUSH
115867: LD_INT 0
115869: ST_TO_ADDR
// sKamikadze := false ;
115870: LD_ADDR_EXP 172
115874: PUSH
115875: LD_INT 0
115877: ST_TO_ADDR
// sTroll := false ;
115878: LD_ADDR_EXP 173
115882: PUSH
115883: LD_INT 0
115885: ST_TO_ADDR
// sSlow := false ;
115886: LD_ADDR_EXP 174
115890: PUSH
115891: LD_INT 0
115893: ST_TO_ADDR
// sLack := false ;
115894: LD_ADDR_EXP 175
115898: PUSH
115899: LD_INT 0
115901: ST_TO_ADDR
// sTank := false ;
115902: LD_ADDR_EXP 177
115906: PUSH
115907: LD_INT 0
115909: ST_TO_ADDR
// sRemote := false ;
115910: LD_ADDR_EXP 178
115914: PUSH
115915: LD_INT 0
115917: ST_TO_ADDR
// sPowell := false ;
115918: LD_ADDR_EXP 179
115922: PUSH
115923: LD_INT 0
115925: ST_TO_ADDR
// sTeleport := false ;
115926: LD_ADDR_EXP 182
115930: PUSH
115931: LD_INT 0
115933: ST_TO_ADDR
// sOilTower := false ;
115934: LD_ADDR_EXP 184
115938: PUSH
115939: LD_INT 0
115941: ST_TO_ADDR
// sShovel := false ;
115942: LD_ADDR_EXP 185
115946: PUSH
115947: LD_INT 0
115949: ST_TO_ADDR
// sSheik := false ;
115950: LD_ADDR_EXP 186
115954: PUSH
115955: LD_INT 0
115957: ST_TO_ADDR
// sEarthquake := false ;
115958: LD_ADDR_EXP 188
115962: PUSH
115963: LD_INT 0
115965: ST_TO_ADDR
// sAI := false ;
115966: LD_ADDR_EXP 189
115970: PUSH
115971: LD_INT 0
115973: ST_TO_ADDR
// sCargo := false ;
115974: LD_ADDR_EXP 192
115978: PUSH
115979: LD_INT 0
115981: ST_TO_ADDR
// sDLaser := false ;
115982: LD_ADDR_EXP 193
115986: PUSH
115987: LD_INT 0
115989: ST_TO_ADDR
// sExchange := false ;
115990: LD_ADDR_EXP 194
115994: PUSH
115995: LD_INT 0
115997: ST_TO_ADDR
// sFac := false ;
115998: LD_ADDR_EXP 195
116002: PUSH
116003: LD_INT 0
116005: ST_TO_ADDR
// sPower := false ;
116006: LD_ADDR_EXP 196
116010: PUSH
116011: LD_INT 0
116013: ST_TO_ADDR
// sRandom := false ;
116014: LD_ADDR_EXP 197
116018: PUSH
116019: LD_INT 0
116021: ST_TO_ADDR
// sShield := false ;
116022: LD_ADDR_EXP 198
116026: PUSH
116027: LD_INT 0
116029: ST_TO_ADDR
// sTime := false ;
116030: LD_ADDR_EXP 199
116034: PUSH
116035: LD_INT 0
116037: ST_TO_ADDR
// sTools := false ;
116038: LD_ADDR_EXP 200
116042: PUSH
116043: LD_INT 0
116045: ST_TO_ADDR
// sSold := false ;
116046: LD_ADDR_EXP 165
116050: PUSH
116051: LD_INT 0
116053: ST_TO_ADDR
// sDiff := false ;
116054: LD_ADDR_EXP 166
116058: PUSH
116059: LD_INT 0
116061: ST_TO_ADDR
// sFog := false ;
116062: LD_ADDR_EXP 169
116066: PUSH
116067: LD_INT 0
116069: ST_TO_ADDR
// sReset := false ;
116070: LD_ADDR_EXP 170
116074: PUSH
116075: LD_INT 0
116077: ST_TO_ADDR
// sSun := false ;
116078: LD_ADDR_EXP 171
116082: PUSH
116083: LD_INT 0
116085: ST_TO_ADDR
// sTiger := false ;
116086: LD_ADDR_EXP 167
116090: PUSH
116091: LD_INT 0
116093: ST_TO_ADDR
// sBomb := false ;
116094: LD_ADDR_EXP 168
116098: PUSH
116099: LD_INT 0
116101: ST_TO_ADDR
// sWound := false ;
116102: LD_ADDR_EXP 176
116106: PUSH
116107: LD_INT 0
116109: ST_TO_ADDR
// sBetray := false ;
116110: LD_ADDR_EXP 180
116114: PUSH
116115: LD_INT 0
116117: ST_TO_ADDR
// sContamin := false ;
116118: LD_ADDR_EXP 181
116122: PUSH
116123: LD_INT 0
116125: ST_TO_ADDR
// sOil := false ;
116126: LD_ADDR_EXP 183
116130: PUSH
116131: LD_INT 0
116133: ST_TO_ADDR
// sStu := false ;
116134: LD_ADDR_EXP 187
116138: PUSH
116139: LD_INT 0
116141: ST_TO_ADDR
// sBazooka := false ;
116142: LD_ADDR_EXP 190
116146: PUSH
116147: LD_INT 0
116149: ST_TO_ADDR
// sMortar := false ;
116150: LD_ADDR_EXP 191
116154: PUSH
116155: LD_INT 0
116157: ST_TO_ADDR
// sRanger := false ;
116158: LD_ADDR_EXP 201
116162: PUSH
116163: LD_INT 0
116165: ST_TO_ADDR
// sComputer := false ;
116166: LD_ADDR_EXP 202
116170: PUSH
116171: LD_INT 0
116173: ST_TO_ADDR
// s30 := false ;
116174: LD_ADDR_EXP 203
116178: PUSH
116179: LD_INT 0
116181: ST_TO_ADDR
// s60 := false ;
116182: LD_ADDR_EXP 204
116186: PUSH
116187: LD_INT 0
116189: ST_TO_ADDR
// end ;
116190: LD_VAR 0 1
116194: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
116195: LD_INT 0
116197: PPUSH
116198: PPUSH
116199: PPUSH
116200: PPUSH
116201: PPUSH
116202: PPUSH
116203: PPUSH
// result := [ ] ;
116204: LD_ADDR_VAR 0 2
116208: PUSH
116209: EMPTY
116210: ST_TO_ADDR
// if campaign_id = 1 then
116211: LD_OWVAR 69
116215: PUSH
116216: LD_INT 1
116218: EQUAL
116219: IFFALSE 119385
// begin case mission_number of 1 :
116221: LD_OWVAR 70
116225: PUSH
116226: LD_INT 1
116228: DOUBLE
116229: EQUAL
116230: IFTRUE 116234
116232: GO 116310
116234: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
116235: LD_ADDR_VAR 0 2
116239: PUSH
116240: LD_INT 2
116242: PUSH
116243: LD_INT 4
116245: PUSH
116246: LD_INT 11
116248: PUSH
116249: LD_INT 12
116251: PUSH
116252: LD_INT 15
116254: PUSH
116255: LD_INT 16
116257: PUSH
116258: LD_INT 22
116260: PUSH
116261: LD_INT 23
116263: PUSH
116264: LD_INT 26
116266: PUSH
116267: EMPTY
116268: LIST
116269: LIST
116270: LIST
116271: LIST
116272: LIST
116273: LIST
116274: LIST
116275: LIST
116276: LIST
116277: PUSH
116278: LD_INT 101
116280: PUSH
116281: LD_INT 102
116283: PUSH
116284: LD_INT 106
116286: PUSH
116287: LD_INT 116
116289: PUSH
116290: LD_INT 117
116292: PUSH
116293: LD_INT 118
116295: PUSH
116296: EMPTY
116297: LIST
116298: LIST
116299: LIST
116300: LIST
116301: LIST
116302: LIST
116303: PUSH
116304: EMPTY
116305: LIST
116306: LIST
116307: ST_TO_ADDR
116308: GO 119383
116310: LD_INT 2
116312: DOUBLE
116313: EQUAL
116314: IFTRUE 116318
116316: GO 116402
116318: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
116319: LD_ADDR_VAR 0 2
116323: PUSH
116324: LD_INT 2
116326: PUSH
116327: LD_INT 4
116329: PUSH
116330: LD_INT 11
116332: PUSH
116333: LD_INT 12
116335: PUSH
116336: LD_INT 15
116338: PUSH
116339: LD_INT 16
116341: PUSH
116342: LD_INT 22
116344: PUSH
116345: LD_INT 23
116347: PUSH
116348: LD_INT 26
116350: PUSH
116351: EMPTY
116352: LIST
116353: LIST
116354: LIST
116355: LIST
116356: LIST
116357: LIST
116358: LIST
116359: LIST
116360: LIST
116361: PUSH
116362: LD_INT 101
116364: PUSH
116365: LD_INT 102
116367: PUSH
116368: LD_INT 105
116370: PUSH
116371: LD_INT 106
116373: PUSH
116374: LD_INT 108
116376: PUSH
116377: LD_INT 116
116379: PUSH
116380: LD_INT 117
116382: PUSH
116383: LD_INT 118
116385: PUSH
116386: EMPTY
116387: LIST
116388: LIST
116389: LIST
116390: LIST
116391: LIST
116392: LIST
116393: LIST
116394: LIST
116395: PUSH
116396: EMPTY
116397: LIST
116398: LIST
116399: ST_TO_ADDR
116400: GO 119383
116402: LD_INT 3
116404: DOUBLE
116405: EQUAL
116406: IFTRUE 116410
116408: GO 116498
116410: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
116411: LD_ADDR_VAR 0 2
116415: PUSH
116416: LD_INT 2
116418: PUSH
116419: LD_INT 4
116421: PUSH
116422: LD_INT 5
116424: PUSH
116425: LD_INT 11
116427: PUSH
116428: LD_INT 12
116430: PUSH
116431: LD_INT 15
116433: PUSH
116434: LD_INT 16
116436: PUSH
116437: LD_INT 22
116439: PUSH
116440: LD_INT 26
116442: PUSH
116443: LD_INT 36
116445: PUSH
116446: EMPTY
116447: LIST
116448: LIST
116449: LIST
116450: LIST
116451: LIST
116452: LIST
116453: LIST
116454: LIST
116455: LIST
116456: LIST
116457: PUSH
116458: LD_INT 101
116460: PUSH
116461: LD_INT 102
116463: PUSH
116464: LD_INT 105
116466: PUSH
116467: LD_INT 106
116469: PUSH
116470: LD_INT 108
116472: PUSH
116473: LD_INT 116
116475: PUSH
116476: LD_INT 117
116478: PUSH
116479: LD_INT 118
116481: PUSH
116482: EMPTY
116483: LIST
116484: LIST
116485: LIST
116486: LIST
116487: LIST
116488: LIST
116489: LIST
116490: LIST
116491: PUSH
116492: EMPTY
116493: LIST
116494: LIST
116495: ST_TO_ADDR
116496: GO 119383
116498: LD_INT 4
116500: DOUBLE
116501: EQUAL
116502: IFTRUE 116506
116504: GO 116602
116506: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
116507: LD_ADDR_VAR 0 2
116511: PUSH
116512: LD_INT 2
116514: PUSH
116515: LD_INT 4
116517: PUSH
116518: LD_INT 5
116520: PUSH
116521: LD_INT 8
116523: PUSH
116524: LD_INT 11
116526: PUSH
116527: LD_INT 12
116529: PUSH
116530: LD_INT 15
116532: PUSH
116533: LD_INT 16
116535: PUSH
116536: LD_INT 22
116538: PUSH
116539: LD_INT 23
116541: PUSH
116542: LD_INT 26
116544: PUSH
116545: LD_INT 36
116547: PUSH
116548: EMPTY
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: LIST
116554: LIST
116555: LIST
116556: LIST
116557: LIST
116558: LIST
116559: LIST
116560: LIST
116561: PUSH
116562: LD_INT 101
116564: PUSH
116565: LD_INT 102
116567: PUSH
116568: LD_INT 105
116570: PUSH
116571: LD_INT 106
116573: PUSH
116574: LD_INT 108
116576: PUSH
116577: LD_INT 116
116579: PUSH
116580: LD_INT 117
116582: PUSH
116583: LD_INT 118
116585: PUSH
116586: EMPTY
116587: LIST
116588: LIST
116589: LIST
116590: LIST
116591: LIST
116592: LIST
116593: LIST
116594: LIST
116595: PUSH
116596: EMPTY
116597: LIST
116598: LIST
116599: ST_TO_ADDR
116600: GO 119383
116602: LD_INT 5
116604: DOUBLE
116605: EQUAL
116606: IFTRUE 116610
116608: GO 116722
116610: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
116611: LD_ADDR_VAR 0 2
116615: PUSH
116616: LD_INT 2
116618: PUSH
116619: LD_INT 4
116621: PUSH
116622: LD_INT 5
116624: PUSH
116625: LD_INT 6
116627: PUSH
116628: LD_INT 8
116630: PUSH
116631: LD_INT 11
116633: PUSH
116634: LD_INT 12
116636: PUSH
116637: LD_INT 15
116639: PUSH
116640: LD_INT 16
116642: PUSH
116643: LD_INT 22
116645: PUSH
116646: LD_INT 23
116648: PUSH
116649: LD_INT 25
116651: PUSH
116652: LD_INT 26
116654: PUSH
116655: LD_INT 36
116657: PUSH
116658: EMPTY
116659: LIST
116660: LIST
116661: LIST
116662: LIST
116663: LIST
116664: LIST
116665: LIST
116666: LIST
116667: LIST
116668: LIST
116669: LIST
116670: LIST
116671: LIST
116672: LIST
116673: PUSH
116674: LD_INT 101
116676: PUSH
116677: LD_INT 102
116679: PUSH
116680: LD_INT 105
116682: PUSH
116683: LD_INT 106
116685: PUSH
116686: LD_INT 108
116688: PUSH
116689: LD_INT 109
116691: PUSH
116692: LD_INT 112
116694: PUSH
116695: LD_INT 116
116697: PUSH
116698: LD_INT 117
116700: PUSH
116701: LD_INT 118
116703: PUSH
116704: EMPTY
116705: LIST
116706: LIST
116707: LIST
116708: LIST
116709: LIST
116710: LIST
116711: LIST
116712: LIST
116713: LIST
116714: LIST
116715: PUSH
116716: EMPTY
116717: LIST
116718: LIST
116719: ST_TO_ADDR
116720: GO 119383
116722: LD_INT 6
116724: DOUBLE
116725: EQUAL
116726: IFTRUE 116730
116728: GO 116862
116730: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
116731: LD_ADDR_VAR 0 2
116735: PUSH
116736: LD_INT 2
116738: PUSH
116739: LD_INT 4
116741: PUSH
116742: LD_INT 5
116744: PUSH
116745: LD_INT 6
116747: PUSH
116748: LD_INT 8
116750: PUSH
116751: LD_INT 11
116753: PUSH
116754: LD_INT 12
116756: PUSH
116757: LD_INT 15
116759: PUSH
116760: LD_INT 16
116762: PUSH
116763: LD_INT 20
116765: PUSH
116766: LD_INT 21
116768: PUSH
116769: LD_INT 22
116771: PUSH
116772: LD_INT 23
116774: PUSH
116775: LD_INT 25
116777: PUSH
116778: LD_INT 26
116780: PUSH
116781: LD_INT 30
116783: PUSH
116784: LD_INT 31
116786: PUSH
116787: LD_INT 32
116789: PUSH
116790: LD_INT 36
116792: PUSH
116793: EMPTY
116794: LIST
116795: LIST
116796: LIST
116797: LIST
116798: LIST
116799: LIST
116800: LIST
116801: LIST
116802: LIST
116803: LIST
116804: LIST
116805: LIST
116806: LIST
116807: LIST
116808: LIST
116809: LIST
116810: LIST
116811: LIST
116812: LIST
116813: PUSH
116814: LD_INT 101
116816: PUSH
116817: LD_INT 102
116819: PUSH
116820: LD_INT 105
116822: PUSH
116823: LD_INT 106
116825: PUSH
116826: LD_INT 108
116828: PUSH
116829: LD_INT 109
116831: PUSH
116832: LD_INT 112
116834: PUSH
116835: LD_INT 116
116837: PUSH
116838: LD_INT 117
116840: PUSH
116841: LD_INT 118
116843: PUSH
116844: EMPTY
116845: LIST
116846: LIST
116847: LIST
116848: LIST
116849: LIST
116850: LIST
116851: LIST
116852: LIST
116853: LIST
116854: LIST
116855: PUSH
116856: EMPTY
116857: LIST
116858: LIST
116859: ST_TO_ADDR
116860: GO 119383
116862: LD_INT 7
116864: DOUBLE
116865: EQUAL
116866: IFTRUE 116870
116868: GO 116982
116870: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
116871: LD_ADDR_VAR 0 2
116875: PUSH
116876: LD_INT 2
116878: PUSH
116879: LD_INT 4
116881: PUSH
116882: LD_INT 5
116884: PUSH
116885: LD_INT 7
116887: PUSH
116888: LD_INT 11
116890: PUSH
116891: LD_INT 12
116893: PUSH
116894: LD_INT 15
116896: PUSH
116897: LD_INT 16
116899: PUSH
116900: LD_INT 20
116902: PUSH
116903: LD_INT 21
116905: PUSH
116906: LD_INT 22
116908: PUSH
116909: LD_INT 23
116911: PUSH
116912: LD_INT 25
116914: PUSH
116915: LD_INT 26
116917: PUSH
116918: EMPTY
116919: LIST
116920: LIST
116921: LIST
116922: LIST
116923: LIST
116924: LIST
116925: LIST
116926: LIST
116927: LIST
116928: LIST
116929: LIST
116930: LIST
116931: LIST
116932: LIST
116933: PUSH
116934: LD_INT 101
116936: PUSH
116937: LD_INT 102
116939: PUSH
116940: LD_INT 103
116942: PUSH
116943: LD_INT 105
116945: PUSH
116946: LD_INT 106
116948: PUSH
116949: LD_INT 108
116951: PUSH
116952: LD_INT 112
116954: PUSH
116955: LD_INT 116
116957: PUSH
116958: LD_INT 117
116960: PUSH
116961: LD_INT 118
116963: PUSH
116964: EMPTY
116965: LIST
116966: LIST
116967: LIST
116968: LIST
116969: LIST
116970: LIST
116971: LIST
116972: LIST
116973: LIST
116974: LIST
116975: PUSH
116976: EMPTY
116977: LIST
116978: LIST
116979: ST_TO_ADDR
116980: GO 119383
116982: LD_INT 8
116984: DOUBLE
116985: EQUAL
116986: IFTRUE 116990
116988: GO 117130
116990: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
116991: LD_ADDR_VAR 0 2
116995: PUSH
116996: LD_INT 2
116998: PUSH
116999: LD_INT 4
117001: PUSH
117002: LD_INT 5
117004: PUSH
117005: LD_INT 6
117007: PUSH
117008: LD_INT 7
117010: PUSH
117011: LD_INT 8
117013: PUSH
117014: LD_INT 11
117016: PUSH
117017: LD_INT 12
117019: PUSH
117020: LD_INT 15
117022: PUSH
117023: LD_INT 16
117025: PUSH
117026: LD_INT 20
117028: PUSH
117029: LD_INT 21
117031: PUSH
117032: LD_INT 22
117034: PUSH
117035: LD_INT 23
117037: PUSH
117038: LD_INT 25
117040: PUSH
117041: LD_INT 26
117043: PUSH
117044: LD_INT 30
117046: PUSH
117047: LD_INT 31
117049: PUSH
117050: LD_INT 32
117052: PUSH
117053: LD_INT 36
117055: PUSH
117056: EMPTY
117057: LIST
117058: LIST
117059: LIST
117060: LIST
117061: LIST
117062: LIST
117063: LIST
117064: LIST
117065: LIST
117066: LIST
117067: LIST
117068: LIST
117069: LIST
117070: LIST
117071: LIST
117072: LIST
117073: LIST
117074: LIST
117075: LIST
117076: LIST
117077: PUSH
117078: LD_INT 101
117080: PUSH
117081: LD_INT 102
117083: PUSH
117084: LD_INT 103
117086: PUSH
117087: LD_INT 105
117089: PUSH
117090: LD_INT 106
117092: PUSH
117093: LD_INT 108
117095: PUSH
117096: LD_INT 109
117098: PUSH
117099: LD_INT 112
117101: PUSH
117102: LD_INT 116
117104: PUSH
117105: LD_INT 117
117107: PUSH
117108: LD_INT 118
117110: PUSH
117111: EMPTY
117112: LIST
117113: LIST
117114: LIST
117115: LIST
117116: LIST
117117: LIST
117118: LIST
117119: LIST
117120: LIST
117121: LIST
117122: LIST
117123: PUSH
117124: EMPTY
117125: LIST
117126: LIST
117127: ST_TO_ADDR
117128: GO 119383
117130: LD_INT 9
117132: DOUBLE
117133: EQUAL
117134: IFTRUE 117138
117136: GO 117286
117138: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
117139: LD_ADDR_VAR 0 2
117143: PUSH
117144: LD_INT 2
117146: PUSH
117147: LD_INT 4
117149: PUSH
117150: LD_INT 5
117152: PUSH
117153: LD_INT 6
117155: PUSH
117156: LD_INT 7
117158: PUSH
117159: LD_INT 8
117161: PUSH
117162: LD_INT 11
117164: PUSH
117165: LD_INT 12
117167: PUSH
117168: LD_INT 15
117170: PUSH
117171: LD_INT 16
117173: PUSH
117174: LD_INT 20
117176: PUSH
117177: LD_INT 21
117179: PUSH
117180: LD_INT 22
117182: PUSH
117183: LD_INT 23
117185: PUSH
117186: LD_INT 25
117188: PUSH
117189: LD_INT 26
117191: PUSH
117192: LD_INT 28
117194: PUSH
117195: LD_INT 30
117197: PUSH
117198: LD_INT 31
117200: PUSH
117201: LD_INT 32
117203: PUSH
117204: LD_INT 36
117206: PUSH
117207: EMPTY
117208: LIST
117209: LIST
117210: LIST
117211: LIST
117212: LIST
117213: LIST
117214: LIST
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: PUSH
117230: LD_INT 101
117232: PUSH
117233: LD_INT 102
117235: PUSH
117236: LD_INT 103
117238: PUSH
117239: LD_INT 105
117241: PUSH
117242: LD_INT 106
117244: PUSH
117245: LD_INT 108
117247: PUSH
117248: LD_INT 109
117250: PUSH
117251: LD_INT 112
117253: PUSH
117254: LD_INT 114
117256: PUSH
117257: LD_INT 116
117259: PUSH
117260: LD_INT 117
117262: PUSH
117263: LD_INT 118
117265: PUSH
117266: EMPTY
117267: LIST
117268: LIST
117269: LIST
117270: LIST
117271: LIST
117272: LIST
117273: LIST
117274: LIST
117275: LIST
117276: LIST
117277: LIST
117278: LIST
117279: PUSH
117280: EMPTY
117281: LIST
117282: LIST
117283: ST_TO_ADDR
117284: GO 119383
117286: LD_INT 10
117288: DOUBLE
117289: EQUAL
117290: IFTRUE 117294
117292: GO 117490
117294: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
117295: LD_ADDR_VAR 0 2
117299: PUSH
117300: LD_INT 2
117302: PUSH
117303: LD_INT 4
117305: PUSH
117306: LD_INT 5
117308: PUSH
117309: LD_INT 6
117311: PUSH
117312: LD_INT 7
117314: PUSH
117315: LD_INT 8
117317: PUSH
117318: LD_INT 9
117320: PUSH
117321: LD_INT 10
117323: PUSH
117324: LD_INT 11
117326: PUSH
117327: LD_INT 12
117329: PUSH
117330: LD_INT 13
117332: PUSH
117333: LD_INT 14
117335: PUSH
117336: LD_INT 15
117338: PUSH
117339: LD_INT 16
117341: PUSH
117342: LD_INT 17
117344: PUSH
117345: LD_INT 18
117347: PUSH
117348: LD_INT 19
117350: PUSH
117351: LD_INT 20
117353: PUSH
117354: LD_INT 21
117356: PUSH
117357: LD_INT 22
117359: PUSH
117360: LD_INT 23
117362: PUSH
117363: LD_INT 24
117365: PUSH
117366: LD_INT 25
117368: PUSH
117369: LD_INT 26
117371: PUSH
117372: LD_INT 28
117374: PUSH
117375: LD_INT 30
117377: PUSH
117378: LD_INT 31
117380: PUSH
117381: LD_INT 32
117383: PUSH
117384: LD_INT 36
117386: PUSH
117387: EMPTY
117388: LIST
117389: LIST
117390: LIST
117391: LIST
117392: LIST
117393: LIST
117394: LIST
117395: LIST
117396: LIST
117397: LIST
117398: LIST
117399: LIST
117400: LIST
117401: LIST
117402: LIST
117403: LIST
117404: LIST
117405: LIST
117406: LIST
117407: LIST
117408: LIST
117409: LIST
117410: LIST
117411: LIST
117412: LIST
117413: LIST
117414: LIST
117415: LIST
117416: LIST
117417: PUSH
117418: LD_INT 101
117420: PUSH
117421: LD_INT 102
117423: PUSH
117424: LD_INT 103
117426: PUSH
117427: LD_INT 104
117429: PUSH
117430: LD_INT 105
117432: PUSH
117433: LD_INT 106
117435: PUSH
117436: LD_INT 107
117438: PUSH
117439: LD_INT 108
117441: PUSH
117442: LD_INT 109
117444: PUSH
117445: LD_INT 110
117447: PUSH
117448: LD_INT 111
117450: PUSH
117451: LD_INT 112
117453: PUSH
117454: LD_INT 114
117456: PUSH
117457: LD_INT 116
117459: PUSH
117460: LD_INT 117
117462: PUSH
117463: LD_INT 118
117465: PUSH
117466: EMPTY
117467: LIST
117468: LIST
117469: LIST
117470: LIST
117471: LIST
117472: LIST
117473: LIST
117474: LIST
117475: LIST
117476: LIST
117477: LIST
117478: LIST
117479: LIST
117480: LIST
117481: LIST
117482: LIST
117483: PUSH
117484: EMPTY
117485: LIST
117486: LIST
117487: ST_TO_ADDR
117488: GO 119383
117490: LD_INT 11
117492: DOUBLE
117493: EQUAL
117494: IFTRUE 117498
117496: GO 117702
117498: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
117499: LD_ADDR_VAR 0 2
117503: PUSH
117504: LD_INT 2
117506: PUSH
117507: LD_INT 3
117509: PUSH
117510: LD_INT 4
117512: PUSH
117513: LD_INT 5
117515: PUSH
117516: LD_INT 6
117518: PUSH
117519: LD_INT 7
117521: PUSH
117522: LD_INT 8
117524: PUSH
117525: LD_INT 9
117527: PUSH
117528: LD_INT 10
117530: PUSH
117531: LD_INT 11
117533: PUSH
117534: LD_INT 12
117536: PUSH
117537: LD_INT 13
117539: PUSH
117540: LD_INT 14
117542: PUSH
117543: LD_INT 15
117545: PUSH
117546: LD_INT 16
117548: PUSH
117549: LD_INT 17
117551: PUSH
117552: LD_INT 18
117554: PUSH
117555: LD_INT 19
117557: PUSH
117558: LD_INT 20
117560: PUSH
117561: LD_INT 21
117563: PUSH
117564: LD_INT 22
117566: PUSH
117567: LD_INT 23
117569: PUSH
117570: LD_INT 24
117572: PUSH
117573: LD_INT 25
117575: PUSH
117576: LD_INT 26
117578: PUSH
117579: LD_INT 28
117581: PUSH
117582: LD_INT 30
117584: PUSH
117585: LD_INT 31
117587: PUSH
117588: LD_INT 32
117590: PUSH
117591: LD_INT 34
117593: PUSH
117594: LD_INT 36
117596: PUSH
117597: EMPTY
117598: LIST
117599: LIST
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: LIST
117605: LIST
117606: LIST
117607: LIST
117608: LIST
117609: LIST
117610: LIST
117611: LIST
117612: LIST
117613: LIST
117614: LIST
117615: LIST
117616: LIST
117617: LIST
117618: LIST
117619: LIST
117620: LIST
117621: LIST
117622: LIST
117623: LIST
117624: LIST
117625: LIST
117626: LIST
117627: LIST
117628: LIST
117629: PUSH
117630: LD_INT 101
117632: PUSH
117633: LD_INT 102
117635: PUSH
117636: LD_INT 103
117638: PUSH
117639: LD_INT 104
117641: PUSH
117642: LD_INT 105
117644: PUSH
117645: LD_INT 106
117647: PUSH
117648: LD_INT 107
117650: PUSH
117651: LD_INT 108
117653: PUSH
117654: LD_INT 109
117656: PUSH
117657: LD_INT 110
117659: PUSH
117660: LD_INT 111
117662: PUSH
117663: LD_INT 112
117665: PUSH
117666: LD_INT 114
117668: PUSH
117669: LD_INT 116
117671: PUSH
117672: LD_INT 117
117674: PUSH
117675: LD_INT 118
117677: PUSH
117678: EMPTY
117679: LIST
117680: LIST
117681: LIST
117682: LIST
117683: LIST
117684: LIST
117685: LIST
117686: LIST
117687: LIST
117688: LIST
117689: LIST
117690: LIST
117691: LIST
117692: LIST
117693: LIST
117694: LIST
117695: PUSH
117696: EMPTY
117697: LIST
117698: LIST
117699: ST_TO_ADDR
117700: GO 119383
117702: LD_INT 12
117704: DOUBLE
117705: EQUAL
117706: IFTRUE 117710
117708: GO 117930
117710: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
117711: LD_ADDR_VAR 0 2
117715: PUSH
117716: LD_INT 1
117718: PUSH
117719: LD_INT 2
117721: PUSH
117722: LD_INT 3
117724: PUSH
117725: LD_INT 4
117727: PUSH
117728: LD_INT 5
117730: PUSH
117731: LD_INT 6
117733: PUSH
117734: LD_INT 7
117736: PUSH
117737: LD_INT 8
117739: PUSH
117740: LD_INT 9
117742: PUSH
117743: LD_INT 10
117745: PUSH
117746: LD_INT 11
117748: PUSH
117749: LD_INT 12
117751: PUSH
117752: LD_INT 13
117754: PUSH
117755: LD_INT 14
117757: PUSH
117758: LD_INT 15
117760: PUSH
117761: LD_INT 16
117763: PUSH
117764: LD_INT 17
117766: PUSH
117767: LD_INT 18
117769: PUSH
117770: LD_INT 19
117772: PUSH
117773: LD_INT 20
117775: PUSH
117776: LD_INT 21
117778: PUSH
117779: LD_INT 22
117781: PUSH
117782: LD_INT 23
117784: PUSH
117785: LD_INT 24
117787: PUSH
117788: LD_INT 25
117790: PUSH
117791: LD_INT 26
117793: PUSH
117794: LD_INT 27
117796: PUSH
117797: LD_INT 28
117799: PUSH
117800: LD_INT 30
117802: PUSH
117803: LD_INT 31
117805: PUSH
117806: LD_INT 32
117808: PUSH
117809: LD_INT 33
117811: PUSH
117812: LD_INT 34
117814: PUSH
117815: LD_INT 36
117817: PUSH
117818: EMPTY
117819: LIST
117820: LIST
117821: LIST
117822: LIST
117823: LIST
117824: LIST
117825: LIST
117826: LIST
117827: LIST
117828: LIST
117829: LIST
117830: LIST
117831: LIST
117832: LIST
117833: LIST
117834: LIST
117835: LIST
117836: LIST
117837: LIST
117838: LIST
117839: LIST
117840: LIST
117841: LIST
117842: LIST
117843: LIST
117844: LIST
117845: LIST
117846: LIST
117847: LIST
117848: LIST
117849: LIST
117850: LIST
117851: LIST
117852: LIST
117853: PUSH
117854: LD_INT 101
117856: PUSH
117857: LD_INT 102
117859: PUSH
117860: LD_INT 103
117862: PUSH
117863: LD_INT 104
117865: PUSH
117866: LD_INT 105
117868: PUSH
117869: LD_INT 106
117871: PUSH
117872: LD_INT 107
117874: PUSH
117875: LD_INT 108
117877: PUSH
117878: LD_INT 109
117880: PUSH
117881: LD_INT 110
117883: PUSH
117884: LD_INT 111
117886: PUSH
117887: LD_INT 112
117889: PUSH
117890: LD_INT 113
117892: PUSH
117893: LD_INT 114
117895: PUSH
117896: LD_INT 116
117898: PUSH
117899: LD_INT 117
117901: PUSH
117902: LD_INT 118
117904: PUSH
117905: EMPTY
117906: LIST
117907: LIST
117908: LIST
117909: LIST
117910: LIST
117911: LIST
117912: LIST
117913: LIST
117914: LIST
117915: LIST
117916: LIST
117917: LIST
117918: LIST
117919: LIST
117920: LIST
117921: LIST
117922: LIST
117923: PUSH
117924: EMPTY
117925: LIST
117926: LIST
117927: ST_TO_ADDR
117928: GO 119383
117930: LD_INT 13
117932: DOUBLE
117933: EQUAL
117934: IFTRUE 117938
117936: GO 118146
117938: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
117939: LD_ADDR_VAR 0 2
117943: PUSH
117944: LD_INT 1
117946: PUSH
117947: LD_INT 2
117949: PUSH
117950: LD_INT 3
117952: PUSH
117953: LD_INT 4
117955: PUSH
117956: LD_INT 5
117958: PUSH
117959: LD_INT 8
117961: PUSH
117962: LD_INT 9
117964: PUSH
117965: LD_INT 10
117967: PUSH
117968: LD_INT 11
117970: PUSH
117971: LD_INT 12
117973: PUSH
117974: LD_INT 14
117976: PUSH
117977: LD_INT 15
117979: PUSH
117980: LD_INT 16
117982: PUSH
117983: LD_INT 17
117985: PUSH
117986: LD_INT 18
117988: PUSH
117989: LD_INT 19
117991: PUSH
117992: LD_INT 20
117994: PUSH
117995: LD_INT 21
117997: PUSH
117998: LD_INT 22
118000: PUSH
118001: LD_INT 23
118003: PUSH
118004: LD_INT 24
118006: PUSH
118007: LD_INT 25
118009: PUSH
118010: LD_INT 26
118012: PUSH
118013: LD_INT 27
118015: PUSH
118016: LD_INT 28
118018: PUSH
118019: LD_INT 30
118021: PUSH
118022: LD_INT 31
118024: PUSH
118025: LD_INT 32
118027: PUSH
118028: LD_INT 33
118030: PUSH
118031: LD_INT 34
118033: PUSH
118034: LD_INT 36
118036: PUSH
118037: EMPTY
118038: LIST
118039: LIST
118040: LIST
118041: LIST
118042: LIST
118043: LIST
118044: LIST
118045: LIST
118046: LIST
118047: LIST
118048: LIST
118049: LIST
118050: LIST
118051: LIST
118052: LIST
118053: LIST
118054: LIST
118055: LIST
118056: LIST
118057: LIST
118058: LIST
118059: LIST
118060: LIST
118061: LIST
118062: LIST
118063: LIST
118064: LIST
118065: LIST
118066: LIST
118067: LIST
118068: LIST
118069: PUSH
118070: LD_INT 101
118072: PUSH
118073: LD_INT 102
118075: PUSH
118076: LD_INT 103
118078: PUSH
118079: LD_INT 104
118081: PUSH
118082: LD_INT 105
118084: PUSH
118085: LD_INT 106
118087: PUSH
118088: LD_INT 107
118090: PUSH
118091: LD_INT 108
118093: PUSH
118094: LD_INT 109
118096: PUSH
118097: LD_INT 110
118099: PUSH
118100: LD_INT 111
118102: PUSH
118103: LD_INT 112
118105: PUSH
118106: LD_INT 113
118108: PUSH
118109: LD_INT 114
118111: PUSH
118112: LD_INT 116
118114: PUSH
118115: LD_INT 117
118117: PUSH
118118: LD_INT 118
118120: PUSH
118121: EMPTY
118122: LIST
118123: LIST
118124: LIST
118125: LIST
118126: LIST
118127: LIST
118128: LIST
118129: LIST
118130: LIST
118131: LIST
118132: LIST
118133: LIST
118134: LIST
118135: LIST
118136: LIST
118137: LIST
118138: LIST
118139: PUSH
118140: EMPTY
118141: LIST
118142: LIST
118143: ST_TO_ADDR
118144: GO 119383
118146: LD_INT 14
118148: DOUBLE
118149: EQUAL
118150: IFTRUE 118154
118152: GO 118378
118154: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
118155: LD_ADDR_VAR 0 2
118159: PUSH
118160: LD_INT 1
118162: PUSH
118163: LD_INT 2
118165: PUSH
118166: LD_INT 3
118168: PUSH
118169: LD_INT 4
118171: PUSH
118172: LD_INT 5
118174: PUSH
118175: LD_INT 6
118177: PUSH
118178: LD_INT 7
118180: PUSH
118181: LD_INT 8
118183: PUSH
118184: LD_INT 9
118186: PUSH
118187: LD_INT 10
118189: PUSH
118190: LD_INT 11
118192: PUSH
118193: LD_INT 12
118195: PUSH
118196: LD_INT 13
118198: PUSH
118199: LD_INT 14
118201: PUSH
118202: LD_INT 15
118204: PUSH
118205: LD_INT 16
118207: PUSH
118208: LD_INT 17
118210: PUSH
118211: LD_INT 18
118213: PUSH
118214: LD_INT 19
118216: PUSH
118217: LD_INT 20
118219: PUSH
118220: LD_INT 21
118222: PUSH
118223: LD_INT 22
118225: PUSH
118226: LD_INT 23
118228: PUSH
118229: LD_INT 24
118231: PUSH
118232: LD_INT 25
118234: PUSH
118235: LD_INT 26
118237: PUSH
118238: LD_INT 27
118240: PUSH
118241: LD_INT 28
118243: PUSH
118244: LD_INT 29
118246: PUSH
118247: LD_INT 30
118249: PUSH
118250: LD_INT 31
118252: PUSH
118253: LD_INT 32
118255: PUSH
118256: LD_INT 33
118258: PUSH
118259: LD_INT 34
118261: PUSH
118262: LD_INT 36
118264: PUSH
118265: EMPTY
118266: LIST
118267: LIST
118268: LIST
118269: LIST
118270: LIST
118271: LIST
118272: LIST
118273: LIST
118274: LIST
118275: LIST
118276: LIST
118277: LIST
118278: LIST
118279: LIST
118280: LIST
118281: LIST
118282: LIST
118283: LIST
118284: LIST
118285: LIST
118286: LIST
118287: LIST
118288: LIST
118289: LIST
118290: LIST
118291: LIST
118292: LIST
118293: LIST
118294: LIST
118295: LIST
118296: LIST
118297: LIST
118298: LIST
118299: LIST
118300: LIST
118301: PUSH
118302: LD_INT 101
118304: PUSH
118305: LD_INT 102
118307: PUSH
118308: LD_INT 103
118310: PUSH
118311: LD_INT 104
118313: PUSH
118314: LD_INT 105
118316: PUSH
118317: LD_INT 106
118319: PUSH
118320: LD_INT 107
118322: PUSH
118323: LD_INT 108
118325: PUSH
118326: LD_INT 109
118328: PUSH
118329: LD_INT 110
118331: PUSH
118332: LD_INT 111
118334: PUSH
118335: LD_INT 112
118337: PUSH
118338: LD_INT 113
118340: PUSH
118341: LD_INT 114
118343: PUSH
118344: LD_INT 116
118346: PUSH
118347: LD_INT 117
118349: PUSH
118350: LD_INT 118
118352: PUSH
118353: EMPTY
118354: LIST
118355: LIST
118356: LIST
118357: LIST
118358: LIST
118359: LIST
118360: LIST
118361: LIST
118362: LIST
118363: LIST
118364: LIST
118365: LIST
118366: LIST
118367: LIST
118368: LIST
118369: LIST
118370: LIST
118371: PUSH
118372: EMPTY
118373: LIST
118374: LIST
118375: ST_TO_ADDR
118376: GO 119383
118378: LD_INT 15
118380: DOUBLE
118381: EQUAL
118382: IFTRUE 118386
118384: GO 118610
118386: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
118387: LD_ADDR_VAR 0 2
118391: PUSH
118392: LD_INT 1
118394: PUSH
118395: LD_INT 2
118397: PUSH
118398: LD_INT 3
118400: PUSH
118401: LD_INT 4
118403: PUSH
118404: LD_INT 5
118406: PUSH
118407: LD_INT 6
118409: PUSH
118410: LD_INT 7
118412: PUSH
118413: LD_INT 8
118415: PUSH
118416: LD_INT 9
118418: PUSH
118419: LD_INT 10
118421: PUSH
118422: LD_INT 11
118424: PUSH
118425: LD_INT 12
118427: PUSH
118428: LD_INT 13
118430: PUSH
118431: LD_INT 14
118433: PUSH
118434: LD_INT 15
118436: PUSH
118437: LD_INT 16
118439: PUSH
118440: LD_INT 17
118442: PUSH
118443: LD_INT 18
118445: PUSH
118446: LD_INT 19
118448: PUSH
118449: LD_INT 20
118451: PUSH
118452: LD_INT 21
118454: PUSH
118455: LD_INT 22
118457: PUSH
118458: LD_INT 23
118460: PUSH
118461: LD_INT 24
118463: PUSH
118464: LD_INT 25
118466: PUSH
118467: LD_INT 26
118469: PUSH
118470: LD_INT 27
118472: PUSH
118473: LD_INT 28
118475: PUSH
118476: LD_INT 29
118478: PUSH
118479: LD_INT 30
118481: PUSH
118482: LD_INT 31
118484: PUSH
118485: LD_INT 32
118487: PUSH
118488: LD_INT 33
118490: PUSH
118491: LD_INT 34
118493: PUSH
118494: LD_INT 36
118496: PUSH
118497: EMPTY
118498: LIST
118499: LIST
118500: LIST
118501: LIST
118502: LIST
118503: LIST
118504: LIST
118505: LIST
118506: LIST
118507: LIST
118508: LIST
118509: LIST
118510: LIST
118511: LIST
118512: LIST
118513: LIST
118514: LIST
118515: LIST
118516: LIST
118517: LIST
118518: LIST
118519: LIST
118520: LIST
118521: LIST
118522: LIST
118523: LIST
118524: LIST
118525: LIST
118526: LIST
118527: LIST
118528: LIST
118529: LIST
118530: LIST
118531: LIST
118532: LIST
118533: PUSH
118534: LD_INT 101
118536: PUSH
118537: LD_INT 102
118539: PUSH
118540: LD_INT 103
118542: PUSH
118543: LD_INT 104
118545: PUSH
118546: LD_INT 105
118548: PUSH
118549: LD_INT 106
118551: PUSH
118552: LD_INT 107
118554: PUSH
118555: LD_INT 108
118557: PUSH
118558: LD_INT 109
118560: PUSH
118561: LD_INT 110
118563: PUSH
118564: LD_INT 111
118566: PUSH
118567: LD_INT 112
118569: PUSH
118570: LD_INT 113
118572: PUSH
118573: LD_INT 114
118575: PUSH
118576: LD_INT 116
118578: PUSH
118579: LD_INT 117
118581: PUSH
118582: LD_INT 118
118584: PUSH
118585: EMPTY
118586: LIST
118587: LIST
118588: LIST
118589: LIST
118590: LIST
118591: LIST
118592: LIST
118593: LIST
118594: LIST
118595: LIST
118596: LIST
118597: LIST
118598: LIST
118599: LIST
118600: LIST
118601: LIST
118602: LIST
118603: PUSH
118604: EMPTY
118605: LIST
118606: LIST
118607: ST_TO_ADDR
118608: GO 119383
118610: LD_INT 16
118612: DOUBLE
118613: EQUAL
118614: IFTRUE 118618
118616: GO 118754
118618: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
118619: LD_ADDR_VAR 0 2
118623: PUSH
118624: LD_INT 2
118626: PUSH
118627: LD_INT 4
118629: PUSH
118630: LD_INT 5
118632: PUSH
118633: LD_INT 7
118635: PUSH
118636: LD_INT 11
118638: PUSH
118639: LD_INT 12
118641: PUSH
118642: LD_INT 15
118644: PUSH
118645: LD_INT 16
118647: PUSH
118648: LD_INT 20
118650: PUSH
118651: LD_INT 21
118653: PUSH
118654: LD_INT 22
118656: PUSH
118657: LD_INT 23
118659: PUSH
118660: LD_INT 25
118662: PUSH
118663: LD_INT 26
118665: PUSH
118666: LD_INT 30
118668: PUSH
118669: LD_INT 31
118671: PUSH
118672: LD_INT 32
118674: PUSH
118675: LD_INT 33
118677: PUSH
118678: LD_INT 34
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: LIST
118685: LIST
118686: LIST
118687: LIST
118688: LIST
118689: LIST
118690: LIST
118691: LIST
118692: LIST
118693: LIST
118694: LIST
118695: LIST
118696: LIST
118697: LIST
118698: LIST
118699: LIST
118700: LIST
118701: PUSH
118702: LD_INT 101
118704: PUSH
118705: LD_INT 102
118707: PUSH
118708: LD_INT 103
118710: PUSH
118711: LD_INT 106
118713: PUSH
118714: LD_INT 108
118716: PUSH
118717: LD_INT 112
118719: PUSH
118720: LD_INT 113
118722: PUSH
118723: LD_INT 114
118725: PUSH
118726: LD_INT 116
118728: PUSH
118729: LD_INT 117
118731: PUSH
118732: LD_INT 118
118734: PUSH
118735: EMPTY
118736: LIST
118737: LIST
118738: LIST
118739: LIST
118740: LIST
118741: LIST
118742: LIST
118743: LIST
118744: LIST
118745: LIST
118746: LIST
118747: PUSH
118748: EMPTY
118749: LIST
118750: LIST
118751: ST_TO_ADDR
118752: GO 119383
118754: LD_INT 17
118756: DOUBLE
118757: EQUAL
118758: IFTRUE 118762
118760: GO 118986
118762: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
118763: LD_ADDR_VAR 0 2
118767: PUSH
118768: LD_INT 1
118770: PUSH
118771: LD_INT 2
118773: PUSH
118774: LD_INT 3
118776: PUSH
118777: LD_INT 4
118779: PUSH
118780: LD_INT 5
118782: PUSH
118783: LD_INT 6
118785: PUSH
118786: LD_INT 7
118788: PUSH
118789: LD_INT 8
118791: PUSH
118792: LD_INT 9
118794: PUSH
118795: LD_INT 10
118797: PUSH
118798: LD_INT 11
118800: PUSH
118801: LD_INT 12
118803: PUSH
118804: LD_INT 13
118806: PUSH
118807: LD_INT 14
118809: PUSH
118810: LD_INT 15
118812: PUSH
118813: LD_INT 16
118815: PUSH
118816: LD_INT 17
118818: PUSH
118819: LD_INT 18
118821: PUSH
118822: LD_INT 19
118824: PUSH
118825: LD_INT 20
118827: PUSH
118828: LD_INT 21
118830: PUSH
118831: LD_INT 22
118833: PUSH
118834: LD_INT 23
118836: PUSH
118837: LD_INT 24
118839: PUSH
118840: LD_INT 25
118842: PUSH
118843: LD_INT 26
118845: PUSH
118846: LD_INT 27
118848: PUSH
118849: LD_INT 28
118851: PUSH
118852: LD_INT 29
118854: PUSH
118855: LD_INT 30
118857: PUSH
118858: LD_INT 31
118860: PUSH
118861: LD_INT 32
118863: PUSH
118864: LD_INT 33
118866: PUSH
118867: LD_INT 34
118869: PUSH
118870: LD_INT 36
118872: PUSH
118873: EMPTY
118874: LIST
118875: LIST
118876: LIST
118877: LIST
118878: LIST
118879: LIST
118880: LIST
118881: LIST
118882: LIST
118883: LIST
118884: LIST
118885: LIST
118886: LIST
118887: LIST
118888: LIST
118889: LIST
118890: LIST
118891: LIST
118892: LIST
118893: LIST
118894: LIST
118895: LIST
118896: LIST
118897: LIST
118898: LIST
118899: LIST
118900: LIST
118901: LIST
118902: LIST
118903: LIST
118904: LIST
118905: LIST
118906: LIST
118907: LIST
118908: LIST
118909: PUSH
118910: LD_INT 101
118912: PUSH
118913: LD_INT 102
118915: PUSH
118916: LD_INT 103
118918: PUSH
118919: LD_INT 104
118921: PUSH
118922: LD_INT 105
118924: PUSH
118925: LD_INT 106
118927: PUSH
118928: LD_INT 107
118930: PUSH
118931: LD_INT 108
118933: PUSH
118934: LD_INT 109
118936: PUSH
118937: LD_INT 110
118939: PUSH
118940: LD_INT 111
118942: PUSH
118943: LD_INT 112
118945: PUSH
118946: LD_INT 113
118948: PUSH
118949: LD_INT 114
118951: PUSH
118952: LD_INT 116
118954: PUSH
118955: LD_INT 117
118957: PUSH
118958: LD_INT 118
118960: PUSH
118961: EMPTY
118962: LIST
118963: LIST
118964: LIST
118965: LIST
118966: LIST
118967: LIST
118968: LIST
118969: LIST
118970: LIST
118971: LIST
118972: LIST
118973: LIST
118974: LIST
118975: LIST
118976: LIST
118977: LIST
118978: LIST
118979: PUSH
118980: EMPTY
118981: LIST
118982: LIST
118983: ST_TO_ADDR
118984: GO 119383
118986: LD_INT 18
118988: DOUBLE
118989: EQUAL
118990: IFTRUE 118994
118992: GO 119142
118994: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
118995: LD_ADDR_VAR 0 2
118999: PUSH
119000: LD_INT 2
119002: PUSH
119003: LD_INT 4
119005: PUSH
119006: LD_INT 5
119008: PUSH
119009: LD_INT 7
119011: PUSH
119012: LD_INT 11
119014: PUSH
119015: LD_INT 12
119017: PUSH
119018: LD_INT 15
119020: PUSH
119021: LD_INT 16
119023: PUSH
119024: LD_INT 20
119026: PUSH
119027: LD_INT 21
119029: PUSH
119030: LD_INT 22
119032: PUSH
119033: LD_INT 23
119035: PUSH
119036: LD_INT 25
119038: PUSH
119039: LD_INT 26
119041: PUSH
119042: LD_INT 30
119044: PUSH
119045: LD_INT 31
119047: PUSH
119048: LD_INT 32
119050: PUSH
119051: LD_INT 33
119053: PUSH
119054: LD_INT 34
119056: PUSH
119057: LD_INT 35
119059: PUSH
119060: LD_INT 36
119062: PUSH
119063: EMPTY
119064: LIST
119065: LIST
119066: LIST
119067: LIST
119068: LIST
119069: LIST
119070: LIST
119071: LIST
119072: LIST
119073: LIST
119074: LIST
119075: LIST
119076: LIST
119077: LIST
119078: LIST
119079: LIST
119080: LIST
119081: LIST
119082: LIST
119083: LIST
119084: LIST
119085: PUSH
119086: LD_INT 101
119088: PUSH
119089: LD_INT 102
119091: PUSH
119092: LD_INT 103
119094: PUSH
119095: LD_INT 106
119097: PUSH
119098: LD_INT 108
119100: PUSH
119101: LD_INT 112
119103: PUSH
119104: LD_INT 113
119106: PUSH
119107: LD_INT 114
119109: PUSH
119110: LD_INT 115
119112: PUSH
119113: LD_INT 116
119115: PUSH
119116: LD_INT 117
119118: PUSH
119119: LD_INT 118
119121: PUSH
119122: EMPTY
119123: LIST
119124: LIST
119125: LIST
119126: LIST
119127: LIST
119128: LIST
119129: LIST
119130: LIST
119131: LIST
119132: LIST
119133: LIST
119134: LIST
119135: PUSH
119136: EMPTY
119137: LIST
119138: LIST
119139: ST_TO_ADDR
119140: GO 119383
119142: LD_INT 19
119144: DOUBLE
119145: EQUAL
119146: IFTRUE 119150
119148: GO 119382
119150: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
119151: LD_ADDR_VAR 0 2
119155: PUSH
119156: LD_INT 1
119158: PUSH
119159: LD_INT 2
119161: PUSH
119162: LD_INT 3
119164: PUSH
119165: LD_INT 4
119167: PUSH
119168: LD_INT 5
119170: PUSH
119171: LD_INT 6
119173: PUSH
119174: LD_INT 7
119176: PUSH
119177: LD_INT 8
119179: PUSH
119180: LD_INT 9
119182: PUSH
119183: LD_INT 10
119185: PUSH
119186: LD_INT 11
119188: PUSH
119189: LD_INT 12
119191: PUSH
119192: LD_INT 13
119194: PUSH
119195: LD_INT 14
119197: PUSH
119198: LD_INT 15
119200: PUSH
119201: LD_INT 16
119203: PUSH
119204: LD_INT 17
119206: PUSH
119207: LD_INT 18
119209: PUSH
119210: LD_INT 19
119212: PUSH
119213: LD_INT 20
119215: PUSH
119216: LD_INT 21
119218: PUSH
119219: LD_INT 22
119221: PUSH
119222: LD_INT 23
119224: PUSH
119225: LD_INT 24
119227: PUSH
119228: LD_INT 25
119230: PUSH
119231: LD_INT 26
119233: PUSH
119234: LD_INT 27
119236: PUSH
119237: LD_INT 28
119239: PUSH
119240: LD_INT 29
119242: PUSH
119243: LD_INT 30
119245: PUSH
119246: LD_INT 31
119248: PUSH
119249: LD_INT 32
119251: PUSH
119252: LD_INT 33
119254: PUSH
119255: LD_INT 34
119257: PUSH
119258: LD_INT 35
119260: PUSH
119261: LD_INT 36
119263: PUSH
119264: EMPTY
119265: LIST
119266: LIST
119267: LIST
119268: LIST
119269: LIST
119270: LIST
119271: LIST
119272: LIST
119273: LIST
119274: LIST
119275: LIST
119276: LIST
119277: LIST
119278: LIST
119279: LIST
119280: LIST
119281: LIST
119282: LIST
119283: LIST
119284: LIST
119285: LIST
119286: LIST
119287: LIST
119288: LIST
119289: LIST
119290: LIST
119291: LIST
119292: LIST
119293: LIST
119294: LIST
119295: LIST
119296: LIST
119297: LIST
119298: LIST
119299: LIST
119300: LIST
119301: PUSH
119302: LD_INT 101
119304: PUSH
119305: LD_INT 102
119307: PUSH
119308: LD_INT 103
119310: PUSH
119311: LD_INT 104
119313: PUSH
119314: LD_INT 105
119316: PUSH
119317: LD_INT 106
119319: PUSH
119320: LD_INT 107
119322: PUSH
119323: LD_INT 108
119325: PUSH
119326: LD_INT 109
119328: PUSH
119329: LD_INT 110
119331: PUSH
119332: LD_INT 111
119334: PUSH
119335: LD_INT 112
119337: PUSH
119338: LD_INT 113
119340: PUSH
119341: LD_INT 114
119343: PUSH
119344: LD_INT 115
119346: PUSH
119347: LD_INT 116
119349: PUSH
119350: LD_INT 117
119352: PUSH
119353: LD_INT 118
119355: PUSH
119356: EMPTY
119357: LIST
119358: LIST
119359: LIST
119360: LIST
119361: LIST
119362: LIST
119363: LIST
119364: LIST
119365: LIST
119366: LIST
119367: LIST
119368: LIST
119369: LIST
119370: LIST
119371: LIST
119372: LIST
119373: LIST
119374: LIST
119375: PUSH
119376: EMPTY
119377: LIST
119378: LIST
119379: ST_TO_ADDR
119380: GO 119383
119382: POP
// end else
119383: GO 119614
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
119385: LD_ADDR_VAR 0 2
119389: PUSH
119390: LD_INT 1
119392: PUSH
119393: LD_INT 2
119395: PUSH
119396: LD_INT 3
119398: PUSH
119399: LD_INT 4
119401: PUSH
119402: LD_INT 5
119404: PUSH
119405: LD_INT 6
119407: PUSH
119408: LD_INT 7
119410: PUSH
119411: LD_INT 8
119413: PUSH
119414: LD_INT 9
119416: PUSH
119417: LD_INT 10
119419: PUSH
119420: LD_INT 11
119422: PUSH
119423: LD_INT 12
119425: PUSH
119426: LD_INT 13
119428: PUSH
119429: LD_INT 14
119431: PUSH
119432: LD_INT 15
119434: PUSH
119435: LD_INT 16
119437: PUSH
119438: LD_INT 17
119440: PUSH
119441: LD_INT 18
119443: PUSH
119444: LD_INT 19
119446: PUSH
119447: LD_INT 20
119449: PUSH
119450: LD_INT 21
119452: PUSH
119453: LD_INT 22
119455: PUSH
119456: LD_INT 23
119458: PUSH
119459: LD_INT 24
119461: PUSH
119462: LD_INT 25
119464: PUSH
119465: LD_INT 26
119467: PUSH
119468: LD_INT 27
119470: PUSH
119471: LD_INT 28
119473: PUSH
119474: LD_INT 29
119476: PUSH
119477: LD_INT 30
119479: PUSH
119480: LD_INT 31
119482: PUSH
119483: LD_INT 32
119485: PUSH
119486: LD_INT 33
119488: PUSH
119489: LD_INT 34
119491: PUSH
119492: LD_INT 35
119494: PUSH
119495: LD_INT 36
119497: PUSH
119498: EMPTY
119499: LIST
119500: LIST
119501: LIST
119502: LIST
119503: LIST
119504: LIST
119505: LIST
119506: LIST
119507: LIST
119508: LIST
119509: LIST
119510: LIST
119511: LIST
119512: LIST
119513: LIST
119514: LIST
119515: LIST
119516: LIST
119517: LIST
119518: LIST
119519: LIST
119520: LIST
119521: LIST
119522: LIST
119523: LIST
119524: LIST
119525: LIST
119526: LIST
119527: LIST
119528: LIST
119529: LIST
119530: LIST
119531: LIST
119532: LIST
119533: LIST
119534: LIST
119535: PUSH
119536: LD_INT 101
119538: PUSH
119539: LD_INT 102
119541: PUSH
119542: LD_INT 103
119544: PUSH
119545: LD_INT 104
119547: PUSH
119548: LD_INT 105
119550: PUSH
119551: LD_INT 106
119553: PUSH
119554: LD_INT 107
119556: PUSH
119557: LD_INT 108
119559: PUSH
119560: LD_INT 109
119562: PUSH
119563: LD_INT 110
119565: PUSH
119566: LD_INT 111
119568: PUSH
119569: LD_INT 112
119571: PUSH
119572: LD_INT 113
119574: PUSH
119575: LD_INT 114
119577: PUSH
119578: LD_INT 115
119580: PUSH
119581: LD_INT 116
119583: PUSH
119584: LD_INT 117
119586: PUSH
119587: LD_INT 118
119589: PUSH
119590: EMPTY
119591: LIST
119592: LIST
119593: LIST
119594: LIST
119595: LIST
119596: LIST
119597: LIST
119598: LIST
119599: LIST
119600: LIST
119601: LIST
119602: LIST
119603: LIST
119604: LIST
119605: LIST
119606: LIST
119607: LIST
119608: LIST
119609: PUSH
119610: EMPTY
119611: LIST
119612: LIST
119613: ST_TO_ADDR
// if result then
119614: LD_VAR 0 2
119618: IFFALSE 120404
// begin normal :=  ;
119620: LD_ADDR_VAR 0 5
119624: PUSH
119625: LD_STRING 
119627: ST_TO_ADDR
// hardcore :=  ;
119628: LD_ADDR_VAR 0 6
119632: PUSH
119633: LD_STRING 
119635: ST_TO_ADDR
// active :=  ;
119636: LD_ADDR_VAR 0 7
119640: PUSH
119641: LD_STRING 
119643: ST_TO_ADDR
// for i = 1 to normalCounter do
119644: LD_ADDR_VAR 0 8
119648: PUSH
119649: DOUBLE
119650: LD_INT 1
119652: DEC
119653: ST_TO_ADDR
119654: LD_EXP 149
119658: PUSH
119659: FOR_TO
119660: IFFALSE 119761
// begin tmp := 0 ;
119662: LD_ADDR_VAR 0 3
119666: PUSH
119667: LD_STRING 0
119669: ST_TO_ADDR
// if result [ 1 ] then
119670: LD_VAR 0 2
119674: PUSH
119675: LD_INT 1
119677: ARRAY
119678: IFFALSE 119743
// if result [ 1 ] [ 1 ] = i then
119680: LD_VAR 0 2
119684: PUSH
119685: LD_INT 1
119687: ARRAY
119688: PUSH
119689: LD_INT 1
119691: ARRAY
119692: PUSH
119693: LD_VAR 0 8
119697: EQUAL
119698: IFFALSE 119743
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
119700: LD_ADDR_VAR 0 2
119704: PUSH
119705: LD_VAR 0 2
119709: PPUSH
119710: LD_INT 1
119712: PPUSH
119713: LD_VAR 0 2
119717: PUSH
119718: LD_INT 1
119720: ARRAY
119721: PPUSH
119722: LD_INT 1
119724: PPUSH
119725: CALL_OW 3
119729: PPUSH
119730: CALL_OW 1
119734: ST_TO_ADDR
// tmp := 1 ;
119735: LD_ADDR_VAR 0 3
119739: PUSH
119740: LD_STRING 1
119742: ST_TO_ADDR
// end ; normal := normal & tmp ;
119743: LD_ADDR_VAR 0 5
119747: PUSH
119748: LD_VAR 0 5
119752: PUSH
119753: LD_VAR 0 3
119757: STR
119758: ST_TO_ADDR
// end ;
119759: GO 119659
119761: POP
119762: POP
// for i = 1 to hardcoreCounter do
119763: LD_ADDR_VAR 0 8
119767: PUSH
119768: DOUBLE
119769: LD_INT 1
119771: DEC
119772: ST_TO_ADDR
119773: LD_EXP 150
119777: PUSH
119778: FOR_TO
119779: IFFALSE 119884
// begin tmp := 0 ;
119781: LD_ADDR_VAR 0 3
119785: PUSH
119786: LD_STRING 0
119788: ST_TO_ADDR
// if result [ 2 ] then
119789: LD_VAR 0 2
119793: PUSH
119794: LD_INT 2
119796: ARRAY
119797: IFFALSE 119866
// if result [ 2 ] [ 1 ] = 100 + i then
119799: LD_VAR 0 2
119803: PUSH
119804: LD_INT 2
119806: ARRAY
119807: PUSH
119808: LD_INT 1
119810: ARRAY
119811: PUSH
119812: LD_INT 100
119814: PUSH
119815: LD_VAR 0 8
119819: PLUS
119820: EQUAL
119821: IFFALSE 119866
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
119823: LD_ADDR_VAR 0 2
119827: PUSH
119828: LD_VAR 0 2
119832: PPUSH
119833: LD_INT 2
119835: PPUSH
119836: LD_VAR 0 2
119840: PUSH
119841: LD_INT 2
119843: ARRAY
119844: PPUSH
119845: LD_INT 1
119847: PPUSH
119848: CALL_OW 3
119852: PPUSH
119853: CALL_OW 1
119857: ST_TO_ADDR
// tmp := 1 ;
119858: LD_ADDR_VAR 0 3
119862: PUSH
119863: LD_STRING 1
119865: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
119866: LD_ADDR_VAR 0 6
119870: PUSH
119871: LD_VAR 0 6
119875: PUSH
119876: LD_VAR 0 3
119880: STR
119881: ST_TO_ADDR
// end ;
119882: GO 119778
119884: POP
119885: POP
// if isGameLoad then
119886: LD_VAR 0 1
119890: IFFALSE 120365
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
119892: LD_ADDR_VAR 0 4
119896: PUSH
119897: LD_EXP 153
119901: PUSH
119902: LD_EXP 152
119906: PUSH
119907: LD_EXP 154
119911: PUSH
119912: LD_EXP 151
119916: PUSH
119917: LD_EXP 155
119921: PUSH
119922: LD_EXP 156
119926: PUSH
119927: LD_EXP 157
119931: PUSH
119932: LD_EXP 158
119936: PUSH
119937: LD_EXP 159
119941: PUSH
119942: LD_EXP 160
119946: PUSH
119947: LD_EXP 161
119951: PUSH
119952: LD_EXP 162
119956: PUSH
119957: LD_EXP 163
119961: PUSH
119962: LD_EXP 164
119966: PUSH
119967: LD_EXP 172
119971: PUSH
119972: LD_EXP 173
119976: PUSH
119977: LD_EXP 174
119981: PUSH
119982: LD_EXP 175
119986: PUSH
119987: LD_EXP 177
119991: PUSH
119992: LD_EXP 178
119996: PUSH
119997: LD_EXP 179
120001: PUSH
120002: LD_EXP 182
120006: PUSH
120007: LD_EXP 184
120011: PUSH
120012: LD_EXP 185
120016: PUSH
120017: LD_EXP 186
120021: PUSH
120022: LD_EXP 188
120026: PUSH
120027: LD_EXP 189
120031: PUSH
120032: LD_EXP 192
120036: PUSH
120037: LD_EXP 193
120041: PUSH
120042: LD_EXP 194
120046: PUSH
120047: LD_EXP 195
120051: PUSH
120052: LD_EXP 196
120056: PUSH
120057: LD_EXP 197
120061: PUSH
120062: LD_EXP 198
120066: PUSH
120067: LD_EXP 199
120071: PUSH
120072: LD_EXP 200
120076: PUSH
120077: LD_EXP 165
120081: PUSH
120082: LD_EXP 166
120086: PUSH
120087: LD_EXP 169
120091: PUSH
120092: LD_EXP 170
120096: PUSH
120097: LD_EXP 171
120101: PUSH
120102: LD_EXP 167
120106: PUSH
120107: LD_EXP 168
120111: PUSH
120112: LD_EXP 176
120116: PUSH
120117: LD_EXP 180
120121: PUSH
120122: LD_EXP 181
120126: PUSH
120127: LD_EXP 183
120131: PUSH
120132: LD_EXP 187
120136: PUSH
120137: LD_EXP 190
120141: PUSH
120142: LD_EXP 191
120146: PUSH
120147: LD_EXP 201
120151: PUSH
120152: LD_EXP 202
120156: PUSH
120157: LD_EXP 203
120161: PUSH
120162: LD_EXP 204
120166: PUSH
120167: EMPTY
120168: LIST
120169: LIST
120170: LIST
120171: LIST
120172: LIST
120173: LIST
120174: LIST
120175: LIST
120176: LIST
120177: LIST
120178: LIST
120179: LIST
120180: LIST
120181: LIST
120182: LIST
120183: LIST
120184: LIST
120185: LIST
120186: LIST
120187: LIST
120188: LIST
120189: LIST
120190: LIST
120191: LIST
120192: LIST
120193: LIST
120194: LIST
120195: LIST
120196: LIST
120197: LIST
120198: LIST
120199: LIST
120200: LIST
120201: LIST
120202: LIST
120203: LIST
120204: LIST
120205: LIST
120206: LIST
120207: LIST
120208: LIST
120209: LIST
120210: LIST
120211: LIST
120212: LIST
120213: LIST
120214: LIST
120215: LIST
120216: LIST
120217: LIST
120218: LIST
120219: LIST
120220: LIST
120221: LIST
120222: ST_TO_ADDR
// tmp :=  ;
120223: LD_ADDR_VAR 0 3
120227: PUSH
120228: LD_STRING 
120230: ST_TO_ADDR
// for i = 1 to normalCounter do
120231: LD_ADDR_VAR 0 8
120235: PUSH
120236: DOUBLE
120237: LD_INT 1
120239: DEC
120240: ST_TO_ADDR
120241: LD_EXP 149
120245: PUSH
120246: FOR_TO
120247: IFFALSE 120283
// begin if flags [ i ] then
120249: LD_VAR 0 4
120253: PUSH
120254: LD_VAR 0 8
120258: ARRAY
120259: IFFALSE 120281
// tmp := tmp & i & ; ;
120261: LD_ADDR_VAR 0 3
120265: PUSH
120266: LD_VAR 0 3
120270: PUSH
120271: LD_VAR 0 8
120275: STR
120276: PUSH
120277: LD_STRING ;
120279: STR
120280: ST_TO_ADDR
// end ;
120281: GO 120246
120283: POP
120284: POP
// for i = 1 to hardcoreCounter do
120285: LD_ADDR_VAR 0 8
120289: PUSH
120290: DOUBLE
120291: LD_INT 1
120293: DEC
120294: ST_TO_ADDR
120295: LD_EXP 150
120299: PUSH
120300: FOR_TO
120301: IFFALSE 120347
// begin if flags [ normalCounter + i ] then
120303: LD_VAR 0 4
120307: PUSH
120308: LD_EXP 149
120312: PUSH
120313: LD_VAR 0 8
120317: PLUS
120318: ARRAY
120319: IFFALSE 120345
// tmp := tmp & ( 100 + i ) & ; ;
120321: LD_ADDR_VAR 0 3
120325: PUSH
120326: LD_VAR 0 3
120330: PUSH
120331: LD_INT 100
120333: PUSH
120334: LD_VAR 0 8
120338: PLUS
120339: STR
120340: PUSH
120341: LD_STRING ;
120343: STR
120344: ST_TO_ADDR
// end ;
120345: GO 120300
120347: POP
120348: POP
// if tmp then
120349: LD_VAR 0 3
120353: IFFALSE 120365
// active := tmp ;
120355: LD_ADDR_VAR 0 7
120359: PUSH
120360: LD_VAR 0 3
120364: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
120365: LD_STRING getStreamItemsFromMission("
120367: PUSH
120368: LD_VAR 0 5
120372: STR
120373: PUSH
120374: LD_STRING ","
120376: STR
120377: PUSH
120378: LD_VAR 0 6
120382: STR
120383: PUSH
120384: LD_STRING ","
120386: STR
120387: PUSH
120388: LD_VAR 0 7
120392: STR
120393: PUSH
120394: LD_STRING ")
120396: STR
120397: PPUSH
120398: CALL_OW 559
// end else
120402: GO 120411
// ToLua ( getStreamItemsFromMission("","","") ) ;
120404: LD_STRING getStreamItemsFromMission("","","")
120406: PPUSH
120407: CALL_OW 559
// end ;
120411: LD_VAR 0 2
120415: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
120416: LD_EXP 148
120420: IFFALSE 120428
120422: PUSH
120423: LD_EXP 153
120427: AND
120428: IFFALSE 120552
120430: GO 120432
120432: DISABLE
120433: LD_INT 0
120435: PPUSH
120436: PPUSH
// begin enable ;
120437: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
120438: LD_ADDR_VAR 0 2
120442: PUSH
120443: LD_INT 22
120445: PUSH
120446: LD_OWVAR 2
120450: PUSH
120451: EMPTY
120452: LIST
120453: LIST
120454: PUSH
120455: LD_INT 2
120457: PUSH
120458: LD_INT 34
120460: PUSH
120461: LD_INT 7
120463: PUSH
120464: EMPTY
120465: LIST
120466: LIST
120467: PUSH
120468: LD_INT 34
120470: PUSH
120471: LD_INT 45
120473: PUSH
120474: EMPTY
120475: LIST
120476: LIST
120477: PUSH
120478: LD_INT 34
120480: PUSH
120481: LD_INT 28
120483: PUSH
120484: EMPTY
120485: LIST
120486: LIST
120487: PUSH
120488: LD_INT 34
120490: PUSH
120491: LD_INT 47
120493: PUSH
120494: EMPTY
120495: LIST
120496: LIST
120497: PUSH
120498: EMPTY
120499: LIST
120500: LIST
120501: LIST
120502: LIST
120503: LIST
120504: PUSH
120505: EMPTY
120506: LIST
120507: LIST
120508: PPUSH
120509: CALL_OW 69
120513: ST_TO_ADDR
// if not tmp then
120514: LD_VAR 0 2
120518: NOT
120519: IFFALSE 120523
// exit ;
120521: GO 120552
// for i in tmp do
120523: LD_ADDR_VAR 0 1
120527: PUSH
120528: LD_VAR 0 2
120532: PUSH
120533: FOR_IN
120534: IFFALSE 120550
// begin SetLives ( i , 0 ) ;
120536: LD_VAR 0 1
120540: PPUSH
120541: LD_INT 0
120543: PPUSH
120544: CALL_OW 234
// end ;
120548: GO 120533
120550: POP
120551: POP
// end ;
120552: PPOPN 2
120554: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
120555: LD_EXP 148
120559: IFFALSE 120567
120561: PUSH
120562: LD_EXP 154
120566: AND
120567: IFFALSE 120651
120569: GO 120571
120571: DISABLE
120572: LD_INT 0
120574: PPUSH
120575: PPUSH
// begin enable ;
120576: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
120577: LD_ADDR_VAR 0 2
120581: PUSH
120582: LD_INT 22
120584: PUSH
120585: LD_OWVAR 2
120589: PUSH
120590: EMPTY
120591: LIST
120592: LIST
120593: PUSH
120594: LD_INT 32
120596: PUSH
120597: LD_INT 3
120599: PUSH
120600: EMPTY
120601: LIST
120602: LIST
120603: PUSH
120604: EMPTY
120605: LIST
120606: LIST
120607: PPUSH
120608: CALL_OW 69
120612: ST_TO_ADDR
// if not tmp then
120613: LD_VAR 0 2
120617: NOT
120618: IFFALSE 120622
// exit ;
120620: GO 120651
// for i in tmp do
120622: LD_ADDR_VAR 0 1
120626: PUSH
120627: LD_VAR 0 2
120631: PUSH
120632: FOR_IN
120633: IFFALSE 120649
// begin SetLives ( i , 0 ) ;
120635: LD_VAR 0 1
120639: PPUSH
120640: LD_INT 0
120642: PPUSH
120643: CALL_OW 234
// end ;
120647: GO 120632
120649: POP
120650: POP
// end ;
120651: PPOPN 2
120653: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
120654: LD_EXP 148
120658: IFFALSE 120666
120660: PUSH
120661: LD_EXP 151
120665: AND
120666: IFFALSE 120759
120668: GO 120670
120670: DISABLE
120671: LD_INT 0
120673: PPUSH
// begin enable ;
120674: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
120675: LD_ADDR_VAR 0 1
120679: PUSH
120680: LD_INT 22
120682: PUSH
120683: LD_OWVAR 2
120687: PUSH
120688: EMPTY
120689: LIST
120690: LIST
120691: PUSH
120692: LD_INT 2
120694: PUSH
120695: LD_INT 25
120697: PUSH
120698: LD_INT 5
120700: PUSH
120701: EMPTY
120702: LIST
120703: LIST
120704: PUSH
120705: LD_INT 25
120707: PUSH
120708: LD_INT 9
120710: PUSH
120711: EMPTY
120712: LIST
120713: LIST
120714: PUSH
120715: LD_INT 25
120717: PUSH
120718: LD_INT 8
120720: PUSH
120721: EMPTY
120722: LIST
120723: LIST
120724: PUSH
120725: EMPTY
120726: LIST
120727: LIST
120728: LIST
120729: LIST
120730: PUSH
120731: EMPTY
120732: LIST
120733: LIST
120734: PPUSH
120735: CALL_OW 69
120739: PUSH
120740: FOR_IN
120741: IFFALSE 120757
// begin SetClass ( i , 1 ) ;
120743: LD_VAR 0 1
120747: PPUSH
120748: LD_INT 1
120750: PPUSH
120751: CALL_OW 336
// end ;
120755: GO 120740
120757: POP
120758: POP
// end ;
120759: PPOPN 1
120761: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
120762: LD_EXP 148
120766: IFFALSE 120774
120768: PUSH
120769: LD_EXP 152
120773: AND
120774: IFFALSE 120786
120776: PUSH
120777: LD_OWVAR 65
120781: PUSH
120782: LD_INT 7
120784: LESS
120785: AND
120786: IFFALSE 120800
120788: GO 120790
120790: DISABLE
// begin enable ;
120791: ENABLE
// game_speed := 7 ;
120792: LD_ADDR_OWVAR 65
120796: PUSH
120797: LD_INT 7
120799: ST_TO_ADDR
// end ;
120800: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
120801: LD_EXP 148
120805: IFFALSE 120813
120807: PUSH
120808: LD_EXP 155
120812: AND
120813: IFFALSE 121015
120815: GO 120817
120817: DISABLE
120818: LD_INT 0
120820: PPUSH
120821: PPUSH
120822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120823: LD_ADDR_VAR 0 3
120827: PUSH
120828: LD_INT 81
120830: PUSH
120831: LD_OWVAR 2
120835: PUSH
120836: EMPTY
120837: LIST
120838: LIST
120839: PUSH
120840: LD_INT 21
120842: PUSH
120843: LD_INT 1
120845: PUSH
120846: EMPTY
120847: LIST
120848: LIST
120849: PUSH
120850: EMPTY
120851: LIST
120852: LIST
120853: PPUSH
120854: CALL_OW 69
120858: ST_TO_ADDR
// if not tmp then
120859: LD_VAR 0 3
120863: NOT
120864: IFFALSE 120868
// exit ;
120866: GO 121015
// if tmp > 5 then
120868: LD_VAR 0 3
120872: PUSH
120873: LD_INT 5
120875: GREATER
120876: IFFALSE 120888
// k := 5 else
120878: LD_ADDR_VAR 0 2
120882: PUSH
120883: LD_INT 5
120885: ST_TO_ADDR
120886: GO 120898
// k := tmp ;
120888: LD_ADDR_VAR 0 2
120892: PUSH
120893: LD_VAR 0 3
120897: ST_TO_ADDR
// for i := 1 to k do
120898: LD_ADDR_VAR 0 1
120902: PUSH
120903: DOUBLE
120904: LD_INT 1
120906: DEC
120907: ST_TO_ADDR
120908: LD_VAR 0 2
120912: PUSH
120913: FOR_TO
120914: IFFALSE 121013
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
120916: LD_VAR 0 3
120920: PUSH
120921: LD_VAR 0 1
120925: ARRAY
120926: PPUSH
120927: LD_VAR 0 1
120931: PUSH
120932: LD_INT 4
120934: MOD
120935: PUSH
120936: LD_INT 1
120938: PLUS
120939: PPUSH
120940: CALL_OW 259
120944: PUSH
120945: LD_INT 10
120947: LESS
120948: IFFALSE 121011
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
120950: LD_VAR 0 3
120954: PUSH
120955: LD_VAR 0 1
120959: ARRAY
120960: PPUSH
120961: LD_VAR 0 1
120965: PUSH
120966: LD_INT 4
120968: MOD
120969: PUSH
120970: LD_INT 1
120972: PLUS
120973: PPUSH
120974: LD_VAR 0 3
120978: PUSH
120979: LD_VAR 0 1
120983: ARRAY
120984: PPUSH
120985: LD_VAR 0 1
120989: PUSH
120990: LD_INT 4
120992: MOD
120993: PUSH
120994: LD_INT 1
120996: PLUS
120997: PPUSH
120998: CALL_OW 259
121002: PUSH
121003: LD_INT 1
121005: PLUS
121006: PPUSH
121007: CALL_OW 237
121011: GO 120913
121013: POP
121014: POP
// end ;
121015: PPOPN 3
121017: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
121018: LD_EXP 148
121022: IFFALSE 121030
121024: PUSH
121025: LD_EXP 156
121029: AND
121030: IFFALSE 121050
121032: GO 121034
121034: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
121035: LD_INT 4
121037: PPUSH
121038: LD_OWVAR 2
121042: PPUSH
121043: LD_INT 0
121045: PPUSH
121046: CALL_OW 324
121050: END
// every 0 0$1 trigger StreamModeActive and sShovel do
121051: LD_EXP 148
121055: IFFALSE 121063
121057: PUSH
121058: LD_EXP 185
121062: AND
121063: IFFALSE 121083
121065: GO 121067
121067: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
121068: LD_INT 19
121070: PPUSH
121071: LD_OWVAR 2
121075: PPUSH
121076: LD_INT 0
121078: PPUSH
121079: CALL_OW 324
121083: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
121084: LD_EXP 148
121088: IFFALSE 121096
121090: PUSH
121091: LD_EXP 157
121095: AND
121096: IFFALSE 121198
121098: GO 121100
121100: DISABLE
121101: LD_INT 0
121103: PPUSH
121104: PPUSH
// begin enable ;
121105: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
121106: LD_ADDR_VAR 0 2
121110: PUSH
121111: LD_INT 22
121113: PUSH
121114: LD_OWVAR 2
121118: PUSH
121119: EMPTY
121120: LIST
121121: LIST
121122: PUSH
121123: LD_INT 2
121125: PUSH
121126: LD_INT 34
121128: PUSH
121129: LD_INT 11
121131: PUSH
121132: EMPTY
121133: LIST
121134: LIST
121135: PUSH
121136: LD_INT 34
121138: PUSH
121139: LD_INT 30
121141: PUSH
121142: EMPTY
121143: LIST
121144: LIST
121145: PUSH
121146: EMPTY
121147: LIST
121148: LIST
121149: LIST
121150: PUSH
121151: EMPTY
121152: LIST
121153: LIST
121154: PPUSH
121155: CALL_OW 69
121159: ST_TO_ADDR
// if not tmp then
121160: LD_VAR 0 2
121164: NOT
121165: IFFALSE 121169
// exit ;
121167: GO 121198
// for i in tmp do
121169: LD_ADDR_VAR 0 1
121173: PUSH
121174: LD_VAR 0 2
121178: PUSH
121179: FOR_IN
121180: IFFALSE 121196
// begin SetLives ( i , 0 ) ;
121182: LD_VAR 0 1
121186: PPUSH
121187: LD_INT 0
121189: PPUSH
121190: CALL_OW 234
// end ;
121194: GO 121179
121196: POP
121197: POP
// end ;
121198: PPOPN 2
121200: END
// every 0 0$1 trigger StreamModeActive and sBunker do
121201: LD_EXP 148
121205: IFFALSE 121213
121207: PUSH
121208: LD_EXP 158
121212: AND
121213: IFFALSE 121233
121215: GO 121217
121217: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
121218: LD_INT 32
121220: PPUSH
121221: LD_OWVAR 2
121225: PPUSH
121226: LD_INT 0
121228: PPUSH
121229: CALL_OW 324
121233: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
121234: LD_EXP 148
121238: IFFALSE 121246
121240: PUSH
121241: LD_EXP 159
121245: AND
121246: IFFALSE 121429
121248: GO 121250
121250: DISABLE
121251: LD_INT 0
121253: PPUSH
121254: PPUSH
121255: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
121256: LD_ADDR_VAR 0 2
121260: PUSH
121261: LD_INT 22
121263: PUSH
121264: LD_OWVAR 2
121268: PUSH
121269: EMPTY
121270: LIST
121271: LIST
121272: PUSH
121273: LD_INT 33
121275: PUSH
121276: LD_INT 3
121278: PUSH
121279: EMPTY
121280: LIST
121281: LIST
121282: PUSH
121283: EMPTY
121284: LIST
121285: LIST
121286: PPUSH
121287: CALL_OW 69
121291: ST_TO_ADDR
// if not tmp then
121292: LD_VAR 0 2
121296: NOT
121297: IFFALSE 121301
// exit ;
121299: GO 121429
// side := 0 ;
121301: LD_ADDR_VAR 0 3
121305: PUSH
121306: LD_INT 0
121308: ST_TO_ADDR
// for i := 1 to 8 do
121309: LD_ADDR_VAR 0 1
121313: PUSH
121314: DOUBLE
121315: LD_INT 1
121317: DEC
121318: ST_TO_ADDR
121319: LD_INT 8
121321: PUSH
121322: FOR_TO
121323: IFFALSE 121373
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
121325: LD_OWVAR 2
121329: PUSH
121330: LD_VAR 0 1
121334: NONEQUAL
121335: IFFALSE 121357
121337: PUSH
121338: LD_OWVAR 2
121342: PPUSH
121343: LD_VAR 0 1
121347: PPUSH
121348: CALL_OW 81
121352: PUSH
121353: LD_INT 2
121355: EQUAL
121356: AND
121357: IFFALSE 121371
// begin side := i ;
121359: LD_ADDR_VAR 0 3
121363: PUSH
121364: LD_VAR 0 1
121368: ST_TO_ADDR
// break ;
121369: GO 121373
// end ;
121371: GO 121322
121373: POP
121374: POP
// if not side then
121375: LD_VAR 0 3
121379: NOT
121380: IFFALSE 121384
// exit ;
121382: GO 121429
// for i := 1 to tmp do
121384: LD_ADDR_VAR 0 1
121388: PUSH
121389: DOUBLE
121390: LD_INT 1
121392: DEC
121393: ST_TO_ADDR
121394: LD_VAR 0 2
121398: PUSH
121399: FOR_TO
121400: IFFALSE 121427
// if Prob ( 60 ) then
121402: LD_INT 60
121404: PPUSH
121405: CALL_OW 13
121409: IFFALSE 121425
// SetSide ( i , side ) ;
121411: LD_VAR 0 1
121415: PPUSH
121416: LD_VAR 0 3
121420: PPUSH
121421: CALL_OW 235
121425: GO 121399
121427: POP
121428: POP
// end ;
121429: PPOPN 3
121431: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
121432: LD_EXP 148
121436: IFFALSE 121444
121438: PUSH
121439: LD_EXP 161
121443: AND
121444: IFFALSE 121563
121446: GO 121448
121448: DISABLE
121449: LD_INT 0
121451: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
121452: LD_ADDR_VAR 0 1
121456: PUSH
121457: LD_INT 22
121459: PUSH
121460: LD_OWVAR 2
121464: PUSH
121465: EMPTY
121466: LIST
121467: LIST
121468: PUSH
121469: LD_INT 21
121471: PUSH
121472: LD_INT 1
121474: PUSH
121475: EMPTY
121476: LIST
121477: LIST
121478: PUSH
121479: LD_INT 3
121481: PUSH
121482: LD_INT 23
121484: PUSH
121485: LD_INT 0
121487: PUSH
121488: EMPTY
121489: LIST
121490: LIST
121491: PUSH
121492: EMPTY
121493: LIST
121494: LIST
121495: PUSH
121496: EMPTY
121497: LIST
121498: LIST
121499: LIST
121500: PPUSH
121501: CALL_OW 69
121505: PUSH
121506: FOR_IN
121507: IFFALSE 121561
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
121509: LD_VAR 0 1
121513: PPUSH
121514: CALL_OW 257
121518: PUSH
121519: LD_INT 1
121521: PUSH
121522: LD_INT 2
121524: PUSH
121525: LD_INT 3
121527: PUSH
121528: LD_INT 4
121530: PUSH
121531: EMPTY
121532: LIST
121533: LIST
121534: LIST
121535: LIST
121536: IN
121537: IFFALSE 121559
// SetClass ( un , rand ( 1 , 4 ) ) ;
121539: LD_VAR 0 1
121543: PPUSH
121544: LD_INT 1
121546: PPUSH
121547: LD_INT 4
121549: PPUSH
121550: CALL_OW 12
121554: PPUSH
121555: CALL_OW 336
121559: GO 121506
121561: POP
121562: POP
// end ;
121563: PPOPN 1
121565: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
121566: LD_EXP 148
121570: IFFALSE 121578
121572: PUSH
121573: LD_EXP 160
121577: AND
121578: IFFALSE 121657
121580: GO 121582
121582: DISABLE
121583: LD_INT 0
121585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121586: LD_ADDR_VAR 0 1
121590: PUSH
121591: LD_INT 22
121593: PUSH
121594: LD_OWVAR 2
121598: PUSH
121599: EMPTY
121600: LIST
121601: LIST
121602: PUSH
121603: LD_INT 21
121605: PUSH
121606: LD_INT 3
121608: PUSH
121609: EMPTY
121610: LIST
121611: LIST
121612: PUSH
121613: EMPTY
121614: LIST
121615: LIST
121616: PPUSH
121617: CALL_OW 69
121621: ST_TO_ADDR
// if not tmp then
121622: LD_VAR 0 1
121626: NOT
121627: IFFALSE 121631
// exit ;
121629: GO 121657
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
121631: LD_VAR 0 1
121635: PUSH
121636: LD_INT 1
121638: PPUSH
121639: LD_VAR 0 1
121643: PPUSH
121644: CALL_OW 12
121648: ARRAY
121649: PPUSH
121650: LD_INT 100
121652: PPUSH
121653: CALL_OW 234
// end ;
121657: PPOPN 1
121659: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
121660: LD_EXP 148
121664: IFFALSE 121672
121666: PUSH
121667: LD_EXP 162
121671: AND
121672: IFFALSE 121770
121674: GO 121676
121676: DISABLE
121677: LD_INT 0
121679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121680: LD_ADDR_VAR 0 1
121684: PUSH
121685: LD_INT 22
121687: PUSH
121688: LD_OWVAR 2
121692: PUSH
121693: EMPTY
121694: LIST
121695: LIST
121696: PUSH
121697: LD_INT 21
121699: PUSH
121700: LD_INT 1
121702: PUSH
121703: EMPTY
121704: LIST
121705: LIST
121706: PUSH
121707: EMPTY
121708: LIST
121709: LIST
121710: PPUSH
121711: CALL_OW 69
121715: ST_TO_ADDR
// if not tmp then
121716: LD_VAR 0 1
121720: NOT
121721: IFFALSE 121725
// exit ;
121723: GO 121770
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
121725: LD_VAR 0 1
121729: PUSH
121730: LD_INT 1
121732: PPUSH
121733: LD_VAR 0 1
121737: PPUSH
121738: CALL_OW 12
121742: ARRAY
121743: PPUSH
121744: LD_INT 1
121746: PPUSH
121747: LD_INT 4
121749: PPUSH
121750: CALL_OW 12
121754: PPUSH
121755: LD_INT 3000
121757: PPUSH
121758: LD_INT 9000
121760: PPUSH
121761: CALL_OW 12
121765: PPUSH
121766: CALL_OW 492
// end ;
121770: PPOPN 1
121772: END
// every 0 0$1 trigger StreamModeActive and sDepot do
121773: LD_EXP 148
121777: IFFALSE 121785
121779: PUSH
121780: LD_EXP 163
121784: AND
121785: IFFALSE 121805
121787: GO 121789
121789: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
121790: LD_INT 1
121792: PPUSH
121793: LD_OWVAR 2
121797: PPUSH
121798: LD_INT 0
121800: PPUSH
121801: CALL_OW 324
121805: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
121806: LD_EXP 148
121810: IFFALSE 121818
121812: PUSH
121813: LD_EXP 164
121817: AND
121818: IFFALSE 121901
121820: GO 121822
121822: DISABLE
121823: LD_INT 0
121825: PPUSH
121826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121827: LD_ADDR_VAR 0 2
121831: PUSH
121832: LD_INT 22
121834: PUSH
121835: LD_OWVAR 2
121839: PUSH
121840: EMPTY
121841: LIST
121842: LIST
121843: PUSH
121844: LD_INT 21
121846: PUSH
121847: LD_INT 3
121849: PUSH
121850: EMPTY
121851: LIST
121852: LIST
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: PPUSH
121858: CALL_OW 69
121862: ST_TO_ADDR
// if not tmp then
121863: LD_VAR 0 2
121867: NOT
121868: IFFALSE 121872
// exit ;
121870: GO 121901
// for i in tmp do
121872: LD_ADDR_VAR 0 1
121876: PUSH
121877: LD_VAR 0 2
121881: PUSH
121882: FOR_IN
121883: IFFALSE 121899
// SetBLevel ( i , 10 ) ;
121885: LD_VAR 0 1
121889: PPUSH
121890: LD_INT 10
121892: PPUSH
121893: CALL_OW 241
121897: GO 121882
121899: POP
121900: POP
// end ;
121901: PPOPN 2
121903: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
121904: LD_EXP 148
121908: IFFALSE 121916
121910: PUSH
121911: LD_EXP 165
121915: AND
121916: IFFALSE 122027
121918: GO 121920
121920: DISABLE
121921: LD_INT 0
121923: PPUSH
121924: PPUSH
121925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121926: LD_ADDR_VAR 0 3
121930: PUSH
121931: LD_INT 22
121933: PUSH
121934: LD_OWVAR 2
121938: PUSH
121939: EMPTY
121940: LIST
121941: LIST
121942: PUSH
121943: LD_INT 25
121945: PUSH
121946: LD_INT 1
121948: PUSH
121949: EMPTY
121950: LIST
121951: LIST
121952: PUSH
121953: EMPTY
121954: LIST
121955: LIST
121956: PPUSH
121957: CALL_OW 69
121961: ST_TO_ADDR
// if not tmp then
121962: LD_VAR 0 3
121966: NOT
121967: IFFALSE 121971
// exit ;
121969: GO 122027
// un := tmp [ rand ( 1 , tmp ) ] ;
121971: LD_ADDR_VAR 0 2
121975: PUSH
121976: LD_VAR 0 3
121980: PUSH
121981: LD_INT 1
121983: PPUSH
121984: LD_VAR 0 3
121988: PPUSH
121989: CALL_OW 12
121993: ARRAY
121994: ST_TO_ADDR
// if Crawls ( un ) then
121995: LD_VAR 0 2
121999: PPUSH
122000: CALL_OW 318
122004: IFFALSE 122015
// ComWalk ( un ) ;
122006: LD_VAR 0 2
122010: PPUSH
122011: CALL_OW 138
// SetClass ( un , class_sniper ) ;
122015: LD_VAR 0 2
122019: PPUSH
122020: LD_INT 5
122022: PPUSH
122023: CALL_OW 336
// end ;
122027: PPOPN 3
122029: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
122030: LD_EXP 148
122034: IFFALSE 122042
122036: PUSH
122037: LD_EXP 166
122041: AND
122042: IFFALSE 122054
122044: PUSH
122045: LD_OWVAR 67
122049: PUSH
122050: LD_INT 4
122052: LESS
122053: AND
122054: IFFALSE 122073
122056: GO 122058
122058: DISABLE
// begin Difficulty := Difficulty + 1 ;
122059: LD_ADDR_OWVAR 67
122063: PUSH
122064: LD_OWVAR 67
122068: PUSH
122069: LD_INT 1
122071: PLUS
122072: ST_TO_ADDR
// end ;
122073: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
122074: LD_EXP 148
122078: IFFALSE 122086
122080: PUSH
122081: LD_EXP 167
122085: AND
122086: IFFALSE 122189
122088: GO 122090
122090: DISABLE
122091: LD_INT 0
122093: PPUSH
// begin for i := 1 to 5 do
122094: LD_ADDR_VAR 0 1
122098: PUSH
122099: DOUBLE
122100: LD_INT 1
122102: DEC
122103: ST_TO_ADDR
122104: LD_INT 5
122106: PUSH
122107: FOR_TO
122108: IFFALSE 122187
// begin uc_nation := nation_nature ;
122110: LD_ADDR_OWVAR 21
122114: PUSH
122115: LD_INT 0
122117: ST_TO_ADDR
// uc_side := 0 ;
122118: LD_ADDR_OWVAR 20
122122: PUSH
122123: LD_INT 0
122125: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122126: LD_ADDR_OWVAR 29
122130: PUSH
122131: LD_INT 12
122133: PUSH
122134: LD_INT 12
122136: PUSH
122137: EMPTY
122138: LIST
122139: LIST
122140: ST_TO_ADDR
// hc_agressivity := 20 ;
122141: LD_ADDR_OWVAR 35
122145: PUSH
122146: LD_INT 20
122148: ST_TO_ADDR
// hc_class := class_tiger ;
122149: LD_ADDR_OWVAR 28
122153: PUSH
122154: LD_INT 14
122156: ST_TO_ADDR
// hc_gallery :=  ;
122157: LD_ADDR_OWVAR 33
122161: PUSH
122162: LD_STRING 
122164: ST_TO_ADDR
// hc_name :=  ;
122165: LD_ADDR_OWVAR 26
122169: PUSH
122170: LD_STRING 
122172: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
122173: CALL_OW 44
122177: PPUSH
122178: LD_INT 0
122180: PPUSH
122181: CALL_OW 51
// end ;
122185: GO 122107
122187: POP
122188: POP
// end ;
122189: PPOPN 1
122191: END
// every 0 0$1 trigger StreamModeActive and sBomb do
122192: LD_EXP 148
122196: IFFALSE 122204
122198: PUSH
122199: LD_EXP 168
122203: AND
122204: IFFALSE 122213
122206: GO 122208
122208: DISABLE
// StreamSibBomb ;
122209: CALL 122214 0 0
122213: END
// export function StreamSibBomb ; var i , x , y ; begin
122214: LD_INT 0
122216: PPUSH
122217: PPUSH
122218: PPUSH
122219: PPUSH
// result := false ;
122220: LD_ADDR_VAR 0 1
122224: PUSH
122225: LD_INT 0
122227: ST_TO_ADDR
// for i := 1 to 16 do
122228: LD_ADDR_VAR 0 2
122232: PUSH
122233: DOUBLE
122234: LD_INT 1
122236: DEC
122237: ST_TO_ADDR
122238: LD_INT 16
122240: PUSH
122241: FOR_TO
122242: IFFALSE 122441
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122244: LD_ADDR_VAR 0 3
122248: PUSH
122249: LD_INT 10
122251: PUSH
122252: LD_INT 20
122254: PUSH
122255: LD_INT 30
122257: PUSH
122258: LD_INT 40
122260: PUSH
122261: LD_INT 50
122263: PUSH
122264: LD_INT 60
122266: PUSH
122267: LD_INT 70
122269: PUSH
122270: LD_INT 80
122272: PUSH
122273: LD_INT 90
122275: PUSH
122276: LD_INT 100
122278: PUSH
122279: LD_INT 110
122281: PUSH
122282: LD_INT 120
122284: PUSH
122285: LD_INT 130
122287: PUSH
122288: LD_INT 140
122290: PUSH
122291: LD_INT 150
122293: PUSH
122294: EMPTY
122295: LIST
122296: LIST
122297: LIST
122298: LIST
122299: LIST
122300: LIST
122301: LIST
122302: LIST
122303: LIST
122304: LIST
122305: LIST
122306: LIST
122307: LIST
122308: LIST
122309: LIST
122310: PUSH
122311: LD_INT 1
122313: PPUSH
122314: LD_INT 15
122316: PPUSH
122317: CALL_OW 12
122321: ARRAY
122322: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122323: LD_ADDR_VAR 0 4
122327: PUSH
122328: LD_INT 10
122330: PUSH
122331: LD_INT 20
122333: PUSH
122334: LD_INT 30
122336: PUSH
122337: LD_INT 40
122339: PUSH
122340: LD_INT 50
122342: PUSH
122343: LD_INT 60
122345: PUSH
122346: LD_INT 70
122348: PUSH
122349: LD_INT 80
122351: PUSH
122352: LD_INT 90
122354: PUSH
122355: LD_INT 100
122357: PUSH
122358: LD_INT 110
122360: PUSH
122361: LD_INT 120
122363: PUSH
122364: LD_INT 130
122366: PUSH
122367: LD_INT 140
122369: PUSH
122370: LD_INT 150
122372: PUSH
122373: EMPTY
122374: LIST
122375: LIST
122376: LIST
122377: LIST
122378: LIST
122379: LIST
122380: LIST
122381: LIST
122382: LIST
122383: LIST
122384: LIST
122385: LIST
122386: LIST
122387: LIST
122388: LIST
122389: PUSH
122390: LD_INT 1
122392: PPUSH
122393: LD_INT 15
122395: PPUSH
122396: CALL_OW 12
122400: ARRAY
122401: ST_TO_ADDR
// if ValidHex ( x , y ) then
122402: LD_VAR 0 3
122406: PPUSH
122407: LD_VAR 0 4
122411: PPUSH
122412: CALL_OW 488
122416: IFFALSE 122439
// begin result := [ x , y ] ;
122418: LD_ADDR_VAR 0 1
122422: PUSH
122423: LD_VAR 0 3
122427: PUSH
122428: LD_VAR 0 4
122432: PUSH
122433: EMPTY
122434: LIST
122435: LIST
122436: ST_TO_ADDR
// break ;
122437: GO 122441
// end ; end ;
122439: GO 122241
122441: POP
122442: POP
// if result then
122443: LD_VAR 0 1
122447: IFFALSE 122507
// begin ToLua ( playSibBomb() ) ;
122449: LD_STRING playSibBomb()
122451: PPUSH
122452: CALL_OW 559
// wait ( 0 0$14 ) ;
122456: LD_INT 490
122458: PPUSH
122459: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
122463: LD_VAR 0 1
122467: PUSH
122468: LD_INT 1
122470: ARRAY
122471: PPUSH
122472: LD_VAR 0 1
122476: PUSH
122477: LD_INT 2
122479: ARRAY
122480: PPUSH
122481: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
122485: LD_VAR 0 1
122489: PUSH
122490: LD_INT 1
122492: ARRAY
122493: PPUSH
122494: LD_VAR 0 1
122498: PUSH
122499: LD_INT 2
122501: ARRAY
122502: PPUSH
122503: CALL_OW 429
// end ; end ;
122507: LD_VAR 0 1
122511: RET
// every 0 0$1 trigger StreamModeActive and sReset do
122512: LD_EXP 148
122516: IFFALSE 122524
122518: PUSH
122519: LD_EXP 170
122523: AND
122524: IFFALSE 122536
122526: GO 122528
122528: DISABLE
// YouLost (  ) ;
122529: LD_STRING 
122531: PPUSH
122532: CALL_OW 104
122536: END
// every 0 0$1 trigger StreamModeActive and sFog do
122537: LD_EXP 148
122541: IFFALSE 122549
122543: PUSH
122544: LD_EXP 169
122548: AND
122549: IFFALSE 122563
122551: GO 122553
122553: DISABLE
// FogOff ( your_side ) ;
122554: LD_OWVAR 2
122558: PPUSH
122559: CALL_OW 344
122563: END
// every 0 0$1 trigger StreamModeActive and sSun do
122564: LD_EXP 148
122568: IFFALSE 122576
122570: PUSH
122571: LD_EXP 171
122575: AND
122576: IFFALSE 122604
122578: GO 122580
122580: DISABLE
// begin solar_recharge_percent := 0 ;
122581: LD_ADDR_OWVAR 79
122585: PUSH
122586: LD_INT 0
122588: ST_TO_ADDR
// wait ( 5 5$00 ) ;
122589: LD_INT 10500
122591: PPUSH
122592: CALL_OW 67
// solar_recharge_percent := 100 ;
122596: LD_ADDR_OWVAR 79
122600: PUSH
122601: LD_INT 100
122603: ST_TO_ADDR
// end ;
122604: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
122605: LD_EXP 148
122609: IFFALSE 122617
122611: PUSH
122612: LD_EXP 172
122616: AND
122617: IFFALSE 122856
122619: GO 122621
122621: DISABLE
122622: LD_INT 0
122624: PPUSH
122625: PPUSH
122626: PPUSH
// begin tmp := [ ] ;
122627: LD_ADDR_VAR 0 3
122631: PUSH
122632: EMPTY
122633: ST_TO_ADDR
// for i := 1 to 6 do
122634: LD_ADDR_VAR 0 1
122638: PUSH
122639: DOUBLE
122640: LD_INT 1
122642: DEC
122643: ST_TO_ADDR
122644: LD_INT 6
122646: PUSH
122647: FOR_TO
122648: IFFALSE 122753
// begin uc_nation := nation_nature ;
122650: LD_ADDR_OWVAR 21
122654: PUSH
122655: LD_INT 0
122657: ST_TO_ADDR
// uc_side := 0 ;
122658: LD_ADDR_OWVAR 20
122662: PUSH
122663: LD_INT 0
122665: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122666: LD_ADDR_OWVAR 29
122670: PUSH
122671: LD_INT 12
122673: PUSH
122674: LD_INT 12
122676: PUSH
122677: EMPTY
122678: LIST
122679: LIST
122680: ST_TO_ADDR
// hc_agressivity := 20 ;
122681: LD_ADDR_OWVAR 35
122685: PUSH
122686: LD_INT 20
122688: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
122689: LD_ADDR_OWVAR 28
122693: PUSH
122694: LD_INT 17
122696: ST_TO_ADDR
// hc_gallery :=  ;
122697: LD_ADDR_OWVAR 33
122701: PUSH
122702: LD_STRING 
122704: ST_TO_ADDR
// hc_name :=  ;
122705: LD_ADDR_OWVAR 26
122709: PUSH
122710: LD_STRING 
122712: ST_TO_ADDR
// un := CreateHuman ;
122713: LD_ADDR_VAR 0 2
122717: PUSH
122718: CALL_OW 44
122722: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
122723: LD_VAR 0 2
122727: PPUSH
122728: LD_INT 1
122730: PPUSH
122731: CALL_OW 51
// tmp := tmp ^ un ;
122735: LD_ADDR_VAR 0 3
122739: PUSH
122740: LD_VAR 0 3
122744: PUSH
122745: LD_VAR 0 2
122749: ADD
122750: ST_TO_ADDR
// end ;
122751: GO 122647
122753: POP
122754: POP
// repeat wait ( 0 0$1 ) ;
122755: LD_INT 35
122757: PPUSH
122758: CALL_OW 67
// for un in tmp do
122762: LD_ADDR_VAR 0 2
122766: PUSH
122767: LD_VAR 0 3
122771: PUSH
122772: FOR_IN
122773: IFFALSE 122847
// begin if IsDead ( un ) then
122775: LD_VAR 0 2
122779: PPUSH
122780: CALL_OW 301
122784: IFFALSE 122804
// begin tmp := tmp diff un ;
122786: LD_ADDR_VAR 0 3
122790: PUSH
122791: LD_VAR 0 3
122795: PUSH
122796: LD_VAR 0 2
122800: DIFF
122801: ST_TO_ADDR
// continue ;
122802: GO 122772
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
122804: LD_VAR 0 2
122808: PPUSH
122809: LD_INT 3
122811: PUSH
122812: LD_INT 22
122814: PUSH
122815: LD_INT 0
122817: PUSH
122818: EMPTY
122819: LIST
122820: LIST
122821: PUSH
122822: EMPTY
122823: LIST
122824: LIST
122825: PPUSH
122826: CALL_OW 69
122830: PPUSH
122831: LD_VAR 0 2
122835: PPUSH
122836: CALL_OW 74
122840: PPUSH
122841: CALL_OW 115
// end ;
122845: GO 122772
122847: POP
122848: POP
// until not tmp ;
122849: LD_VAR 0 3
122853: NOT
122854: IFFALSE 122755
// end ;
122856: PPOPN 3
122858: END
// every 0 0$1 trigger StreamModeActive and sTroll do
122859: LD_EXP 148
122863: IFFALSE 122871
122865: PUSH
122866: LD_EXP 173
122870: AND
122871: IFFALSE 122925
122873: GO 122875
122875: DISABLE
// begin ToLua ( displayTroll(); ) ;
122876: LD_STRING displayTroll();
122878: PPUSH
122879: CALL_OW 559
// wait ( 3 3$00 ) ;
122883: LD_INT 6300
122885: PPUSH
122886: CALL_OW 67
// ToLua ( hideTroll(); ) ;
122890: LD_STRING hideTroll();
122892: PPUSH
122893: CALL_OW 559
// wait ( 1 1$00 ) ;
122897: LD_INT 2100
122899: PPUSH
122900: CALL_OW 67
// ToLua ( displayTroll(); ) ;
122904: LD_STRING displayTroll();
122906: PPUSH
122907: CALL_OW 559
// wait ( 1 1$00 ) ;
122911: LD_INT 2100
122913: PPUSH
122914: CALL_OW 67
// ToLua ( hideTroll(); ) ;
122918: LD_STRING hideTroll();
122920: PPUSH
122921: CALL_OW 559
// end ;
122925: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
122926: LD_EXP 148
122930: IFFALSE 122938
122932: PUSH
122933: LD_EXP 174
122937: AND
122938: IFFALSE 123001
122940: GO 122942
122942: DISABLE
122943: LD_INT 0
122945: PPUSH
// begin p := 0 ;
122946: LD_ADDR_VAR 0 1
122950: PUSH
122951: LD_INT 0
122953: ST_TO_ADDR
// repeat game_speed := 1 ;
122954: LD_ADDR_OWVAR 65
122958: PUSH
122959: LD_INT 1
122961: ST_TO_ADDR
// wait ( 0 0$1 ) ;
122962: LD_INT 35
122964: PPUSH
122965: CALL_OW 67
// p := p + 1 ;
122969: LD_ADDR_VAR 0 1
122973: PUSH
122974: LD_VAR 0 1
122978: PUSH
122979: LD_INT 1
122981: PLUS
122982: ST_TO_ADDR
// until p >= 60 ;
122983: LD_VAR 0 1
122987: PUSH
122988: LD_INT 60
122990: GREATEREQUAL
122991: IFFALSE 122954
// game_speed := 4 ;
122993: LD_ADDR_OWVAR 65
122997: PUSH
122998: LD_INT 4
123000: ST_TO_ADDR
// end ;
123001: PPOPN 1
123003: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
123004: LD_EXP 148
123008: IFFALSE 123016
123010: PUSH
123011: LD_EXP 175
123015: AND
123016: IFFALSE 123162
123018: GO 123020
123020: DISABLE
123021: LD_INT 0
123023: PPUSH
123024: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123025: LD_ADDR_VAR 0 1
123029: PUSH
123030: LD_INT 22
123032: PUSH
123033: LD_OWVAR 2
123037: PUSH
123038: EMPTY
123039: LIST
123040: LIST
123041: PUSH
123042: LD_INT 2
123044: PUSH
123045: LD_INT 30
123047: PUSH
123048: LD_INT 0
123050: PUSH
123051: EMPTY
123052: LIST
123053: LIST
123054: PUSH
123055: LD_INT 30
123057: PUSH
123058: LD_INT 1
123060: PUSH
123061: EMPTY
123062: LIST
123063: LIST
123064: PUSH
123065: EMPTY
123066: LIST
123067: LIST
123068: LIST
123069: PUSH
123070: EMPTY
123071: LIST
123072: LIST
123073: PPUSH
123074: CALL_OW 69
123078: ST_TO_ADDR
// if not depot then
123079: LD_VAR 0 1
123083: NOT
123084: IFFALSE 123088
// exit ;
123086: GO 123162
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
123088: LD_ADDR_VAR 0 2
123092: PUSH
123093: LD_VAR 0 1
123097: PUSH
123098: LD_INT 1
123100: PPUSH
123101: LD_VAR 0 1
123105: PPUSH
123106: CALL_OW 12
123110: ARRAY
123111: PPUSH
123112: CALL_OW 274
123116: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
123117: LD_VAR 0 2
123121: PPUSH
123122: LD_INT 1
123124: PPUSH
123125: LD_INT 0
123127: PPUSH
123128: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
123132: LD_VAR 0 2
123136: PPUSH
123137: LD_INT 2
123139: PPUSH
123140: LD_INT 0
123142: PPUSH
123143: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
123147: LD_VAR 0 2
123151: PPUSH
123152: LD_INT 3
123154: PPUSH
123155: LD_INT 0
123157: PPUSH
123158: CALL_OW 277
// end ;
123162: PPOPN 2
123164: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
123165: LD_EXP 148
123169: IFFALSE 123177
123171: PUSH
123172: LD_EXP 176
123176: AND
123177: IFFALSE 123274
123179: GO 123181
123181: DISABLE
123182: LD_INT 0
123184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123185: LD_ADDR_VAR 0 1
123189: PUSH
123190: LD_INT 22
123192: PUSH
123193: LD_OWVAR 2
123197: PUSH
123198: EMPTY
123199: LIST
123200: LIST
123201: PUSH
123202: LD_INT 21
123204: PUSH
123205: LD_INT 1
123207: PUSH
123208: EMPTY
123209: LIST
123210: LIST
123211: PUSH
123212: LD_INT 3
123214: PUSH
123215: LD_INT 23
123217: PUSH
123218: LD_INT 0
123220: PUSH
123221: EMPTY
123222: LIST
123223: LIST
123224: PUSH
123225: EMPTY
123226: LIST
123227: LIST
123228: PUSH
123229: EMPTY
123230: LIST
123231: LIST
123232: LIST
123233: PPUSH
123234: CALL_OW 69
123238: ST_TO_ADDR
// if not tmp then
123239: LD_VAR 0 1
123243: NOT
123244: IFFALSE 123248
// exit ;
123246: GO 123274
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
123248: LD_VAR 0 1
123252: PUSH
123253: LD_INT 1
123255: PPUSH
123256: LD_VAR 0 1
123260: PPUSH
123261: CALL_OW 12
123265: ARRAY
123266: PPUSH
123267: LD_INT 200
123269: PPUSH
123270: CALL_OW 234
// end ;
123274: PPOPN 1
123276: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
123277: LD_EXP 148
123281: IFFALSE 123289
123283: PUSH
123284: LD_EXP 177
123288: AND
123289: IFFALSE 123368
123291: GO 123293
123293: DISABLE
123294: LD_INT 0
123296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
123297: LD_ADDR_VAR 0 1
123301: PUSH
123302: LD_INT 22
123304: PUSH
123305: LD_OWVAR 2
123309: PUSH
123310: EMPTY
123311: LIST
123312: LIST
123313: PUSH
123314: LD_INT 21
123316: PUSH
123317: LD_INT 2
123319: PUSH
123320: EMPTY
123321: LIST
123322: LIST
123323: PUSH
123324: EMPTY
123325: LIST
123326: LIST
123327: PPUSH
123328: CALL_OW 69
123332: ST_TO_ADDR
// if not tmp then
123333: LD_VAR 0 1
123337: NOT
123338: IFFALSE 123342
// exit ;
123340: GO 123368
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
123342: LD_VAR 0 1
123346: PUSH
123347: LD_INT 1
123349: PPUSH
123350: LD_VAR 0 1
123354: PPUSH
123355: CALL_OW 12
123359: ARRAY
123360: PPUSH
123361: LD_INT 60
123363: PPUSH
123364: CALL_OW 234
// end ;
123368: PPOPN 1
123370: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
123371: LD_EXP 148
123375: IFFALSE 123383
123377: PUSH
123378: LD_EXP 178
123382: AND
123383: IFFALSE 123482
123385: GO 123387
123387: DISABLE
123388: LD_INT 0
123390: PPUSH
123391: PPUSH
// begin enable ;
123392: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
123393: LD_ADDR_VAR 0 1
123397: PUSH
123398: LD_INT 22
123400: PUSH
123401: LD_OWVAR 2
123405: PUSH
123406: EMPTY
123407: LIST
123408: LIST
123409: PUSH
123410: LD_INT 61
123412: PUSH
123413: EMPTY
123414: LIST
123415: PUSH
123416: LD_INT 33
123418: PUSH
123419: LD_INT 2
123421: PUSH
123422: EMPTY
123423: LIST
123424: LIST
123425: PUSH
123426: EMPTY
123427: LIST
123428: LIST
123429: LIST
123430: PPUSH
123431: CALL_OW 69
123435: ST_TO_ADDR
// if not tmp then
123436: LD_VAR 0 1
123440: NOT
123441: IFFALSE 123445
// exit ;
123443: GO 123482
// for i in tmp do
123445: LD_ADDR_VAR 0 2
123449: PUSH
123450: LD_VAR 0 1
123454: PUSH
123455: FOR_IN
123456: IFFALSE 123480
// if IsControledBy ( i ) then
123458: LD_VAR 0 2
123462: PPUSH
123463: CALL_OW 312
123467: IFFALSE 123478
// ComUnlink ( i ) ;
123469: LD_VAR 0 2
123473: PPUSH
123474: CALL_OW 136
123478: GO 123455
123480: POP
123481: POP
// end ;
123482: PPOPN 2
123484: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
123485: LD_EXP 148
123489: IFFALSE 123497
123491: PUSH
123492: LD_EXP 179
123496: AND
123497: IFFALSE 123637
123499: GO 123501
123501: DISABLE
123502: LD_INT 0
123504: PPUSH
123505: PPUSH
// begin ToLua ( displayPowell(); ) ;
123506: LD_STRING displayPowell();
123508: PPUSH
123509: CALL_OW 559
// uc_side := 0 ;
123513: LD_ADDR_OWVAR 20
123517: PUSH
123518: LD_INT 0
123520: ST_TO_ADDR
// uc_nation := 2 ;
123521: LD_ADDR_OWVAR 21
123525: PUSH
123526: LD_INT 2
123528: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
123529: LD_ADDR_OWVAR 37
123533: PUSH
123534: LD_INT 14
123536: ST_TO_ADDR
// vc_engine := engine_siberite ;
123537: LD_ADDR_OWVAR 39
123541: PUSH
123542: LD_INT 3
123544: ST_TO_ADDR
// vc_control := control_apeman ;
123545: LD_ADDR_OWVAR 38
123549: PUSH
123550: LD_INT 5
123552: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
123553: LD_ADDR_OWVAR 40
123557: PUSH
123558: LD_INT 29
123560: ST_TO_ADDR
// un := CreateVehicle ;
123561: LD_ADDR_VAR 0 2
123565: PUSH
123566: CALL_OW 45
123570: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123571: LD_VAR 0 2
123575: PPUSH
123576: LD_INT 1
123578: PPUSH
123579: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123583: LD_INT 35
123585: PPUSH
123586: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123590: LD_VAR 0 2
123594: PPUSH
123595: LD_INT 22
123597: PUSH
123598: LD_OWVAR 2
123602: PUSH
123603: EMPTY
123604: LIST
123605: LIST
123606: PPUSH
123607: CALL_OW 69
123611: PPUSH
123612: LD_VAR 0 2
123616: PPUSH
123617: CALL_OW 74
123621: PPUSH
123622: CALL_OW 115
// until IsDead ( un ) ;
123626: LD_VAR 0 2
123630: PPUSH
123631: CALL_OW 301
123635: IFFALSE 123583
// end ;
123637: PPOPN 2
123639: END
// every 0 0$1 trigger StreamModeActive and sStu do
123640: LD_EXP 148
123644: IFFALSE 123652
123646: PUSH
123647: LD_EXP 187
123651: AND
123652: IFFALSE 123668
123654: GO 123656
123656: DISABLE
// begin ToLua ( displayStucuk(); ) ;
123657: LD_STRING displayStucuk();
123659: PPUSH
123660: CALL_OW 559
// ResetFog ;
123664: CALL_OW 335
// end ;
123668: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
123669: LD_EXP 148
123673: IFFALSE 123681
123675: PUSH
123676: LD_EXP 180
123680: AND
123681: IFFALSE 123822
123683: GO 123685
123685: DISABLE
123686: LD_INT 0
123688: PPUSH
123689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
123690: LD_ADDR_VAR 0 2
123694: PUSH
123695: LD_INT 22
123697: PUSH
123698: LD_OWVAR 2
123702: PUSH
123703: EMPTY
123704: LIST
123705: LIST
123706: PUSH
123707: LD_INT 21
123709: PUSH
123710: LD_INT 1
123712: PUSH
123713: EMPTY
123714: LIST
123715: LIST
123716: PUSH
123717: EMPTY
123718: LIST
123719: LIST
123720: PPUSH
123721: CALL_OW 69
123725: ST_TO_ADDR
// if not tmp then
123726: LD_VAR 0 2
123730: NOT
123731: IFFALSE 123735
// exit ;
123733: GO 123822
// un := tmp [ rand ( 1 , tmp ) ] ;
123735: LD_ADDR_VAR 0 1
123739: PUSH
123740: LD_VAR 0 2
123744: PUSH
123745: LD_INT 1
123747: PPUSH
123748: LD_VAR 0 2
123752: PPUSH
123753: CALL_OW 12
123757: ARRAY
123758: ST_TO_ADDR
// SetSide ( un , 0 ) ;
123759: LD_VAR 0 1
123763: PPUSH
123764: LD_INT 0
123766: PPUSH
123767: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
123771: LD_VAR 0 1
123775: PPUSH
123776: LD_OWVAR 3
123780: PUSH
123781: LD_VAR 0 1
123785: DIFF
123786: PPUSH
123787: LD_VAR 0 1
123791: PPUSH
123792: CALL_OW 74
123796: PPUSH
123797: CALL_OW 115
// wait ( 0 0$20 ) ;
123801: LD_INT 700
123803: PPUSH
123804: CALL_OW 67
// SetSide ( un , your_side ) ;
123808: LD_VAR 0 1
123812: PPUSH
123813: LD_OWVAR 2
123817: PPUSH
123818: CALL_OW 235
// end ;
123822: PPOPN 2
123824: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
123825: LD_EXP 148
123829: IFFALSE 123837
123831: PUSH
123832: LD_EXP 181
123836: AND
123837: IFFALSE 123943
123839: GO 123841
123841: DISABLE
123842: LD_INT 0
123844: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123845: LD_ADDR_VAR 0 1
123849: PUSH
123850: LD_INT 22
123852: PUSH
123853: LD_OWVAR 2
123857: PUSH
123858: EMPTY
123859: LIST
123860: LIST
123861: PUSH
123862: LD_INT 2
123864: PUSH
123865: LD_INT 30
123867: PUSH
123868: LD_INT 0
123870: PUSH
123871: EMPTY
123872: LIST
123873: LIST
123874: PUSH
123875: LD_INT 30
123877: PUSH
123878: LD_INT 1
123880: PUSH
123881: EMPTY
123882: LIST
123883: LIST
123884: PUSH
123885: EMPTY
123886: LIST
123887: LIST
123888: LIST
123889: PUSH
123890: EMPTY
123891: LIST
123892: LIST
123893: PPUSH
123894: CALL_OW 69
123898: ST_TO_ADDR
// if not depot then
123899: LD_VAR 0 1
123903: NOT
123904: IFFALSE 123908
// exit ;
123906: GO 123943
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
123908: LD_VAR 0 1
123912: PUSH
123913: LD_INT 1
123915: ARRAY
123916: PPUSH
123917: CALL_OW 250
123921: PPUSH
123922: LD_VAR 0 1
123926: PUSH
123927: LD_INT 1
123929: ARRAY
123930: PPUSH
123931: CALL_OW 251
123935: PPUSH
123936: LD_INT 70
123938: PPUSH
123939: CALL_OW 495
// end ;
123943: PPOPN 1
123945: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
123946: LD_EXP 148
123950: IFFALSE 123958
123952: PUSH
123953: LD_EXP 182
123957: AND
123958: IFFALSE 124169
123960: GO 123962
123962: DISABLE
123963: LD_INT 0
123965: PPUSH
123966: PPUSH
123967: PPUSH
123968: PPUSH
123969: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
123970: LD_ADDR_VAR 0 5
123974: PUSH
123975: LD_INT 22
123977: PUSH
123978: LD_OWVAR 2
123982: PUSH
123983: EMPTY
123984: LIST
123985: LIST
123986: PUSH
123987: LD_INT 21
123989: PUSH
123990: LD_INT 1
123992: PUSH
123993: EMPTY
123994: LIST
123995: LIST
123996: PUSH
123997: EMPTY
123998: LIST
123999: LIST
124000: PPUSH
124001: CALL_OW 69
124005: ST_TO_ADDR
// if not tmp then
124006: LD_VAR 0 5
124010: NOT
124011: IFFALSE 124015
// exit ;
124013: GO 124169
// for i in tmp do
124015: LD_ADDR_VAR 0 1
124019: PUSH
124020: LD_VAR 0 5
124024: PUSH
124025: FOR_IN
124026: IFFALSE 124167
// begin d := rand ( 0 , 5 ) ;
124028: LD_ADDR_VAR 0 4
124032: PUSH
124033: LD_INT 0
124035: PPUSH
124036: LD_INT 5
124038: PPUSH
124039: CALL_OW 12
124043: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
124044: LD_ADDR_VAR 0 2
124048: PUSH
124049: LD_VAR 0 1
124053: PPUSH
124054: CALL_OW 250
124058: PPUSH
124059: LD_VAR 0 4
124063: PPUSH
124064: LD_INT 3
124066: PPUSH
124067: LD_INT 12
124069: PPUSH
124070: CALL_OW 12
124074: PPUSH
124075: CALL_OW 272
124079: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
124080: LD_ADDR_VAR 0 3
124084: PUSH
124085: LD_VAR 0 1
124089: PPUSH
124090: CALL_OW 251
124094: PPUSH
124095: LD_VAR 0 4
124099: PPUSH
124100: LD_INT 3
124102: PPUSH
124103: LD_INT 12
124105: PPUSH
124106: CALL_OW 12
124110: PPUSH
124111: CALL_OW 273
124115: ST_TO_ADDR
// if ValidHex ( x , y ) then
124116: LD_VAR 0 2
124120: PPUSH
124121: LD_VAR 0 3
124125: PPUSH
124126: CALL_OW 488
124130: IFFALSE 124165
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
124132: LD_VAR 0 1
124136: PPUSH
124137: LD_VAR 0 2
124141: PPUSH
124142: LD_VAR 0 3
124146: PPUSH
124147: LD_INT 3
124149: PPUSH
124150: LD_INT 6
124152: PPUSH
124153: CALL_OW 12
124157: PPUSH
124158: LD_INT 1
124160: PPUSH
124161: CALL_OW 483
// end ;
124165: GO 124025
124167: POP
124168: POP
// end ;
124169: PPOPN 5
124171: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
124172: LD_EXP 148
124176: IFFALSE 124184
124178: PUSH
124179: LD_EXP 183
124183: AND
124184: IFFALSE 124278
124186: GO 124188
124188: DISABLE
124189: LD_INT 0
124191: PPUSH
124192: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
124193: LD_ADDR_VAR 0 2
124197: PUSH
124198: LD_INT 22
124200: PUSH
124201: LD_OWVAR 2
124205: PUSH
124206: EMPTY
124207: LIST
124208: LIST
124209: PUSH
124210: LD_INT 32
124212: PUSH
124213: LD_INT 1
124215: PUSH
124216: EMPTY
124217: LIST
124218: LIST
124219: PUSH
124220: LD_INT 21
124222: PUSH
124223: LD_INT 2
124225: PUSH
124226: EMPTY
124227: LIST
124228: LIST
124229: PUSH
124230: EMPTY
124231: LIST
124232: LIST
124233: LIST
124234: PPUSH
124235: CALL_OW 69
124239: ST_TO_ADDR
// if not tmp then
124240: LD_VAR 0 2
124244: NOT
124245: IFFALSE 124249
// exit ;
124247: GO 124278
// for i in tmp do
124249: LD_ADDR_VAR 0 1
124253: PUSH
124254: LD_VAR 0 2
124258: PUSH
124259: FOR_IN
124260: IFFALSE 124276
// SetFuel ( i , 0 ) ;
124262: LD_VAR 0 1
124266: PPUSH
124267: LD_INT 0
124269: PPUSH
124270: CALL_OW 240
124274: GO 124259
124276: POP
124277: POP
// end ;
124278: PPOPN 2
124280: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
124281: LD_EXP 148
124285: IFFALSE 124293
124287: PUSH
124288: LD_EXP 184
124292: AND
124293: IFFALSE 124359
124295: GO 124297
124297: DISABLE
124298: LD_INT 0
124300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124301: LD_ADDR_VAR 0 1
124305: PUSH
124306: LD_INT 22
124308: PUSH
124309: LD_OWVAR 2
124313: PUSH
124314: EMPTY
124315: LIST
124316: LIST
124317: PUSH
124318: LD_INT 30
124320: PUSH
124321: LD_INT 29
124323: PUSH
124324: EMPTY
124325: LIST
124326: LIST
124327: PUSH
124328: EMPTY
124329: LIST
124330: LIST
124331: PPUSH
124332: CALL_OW 69
124336: ST_TO_ADDR
// if not tmp then
124337: LD_VAR 0 1
124341: NOT
124342: IFFALSE 124346
// exit ;
124344: GO 124359
// DestroyUnit ( tmp [ 1 ] ) ;
124346: LD_VAR 0 1
124350: PUSH
124351: LD_INT 1
124353: ARRAY
124354: PPUSH
124355: CALL_OW 65
// end ;
124359: PPOPN 1
124361: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
124362: LD_EXP 148
124366: IFFALSE 124374
124368: PUSH
124369: LD_EXP 186
124373: AND
124374: IFFALSE 124503
124376: GO 124378
124378: DISABLE
124379: LD_INT 0
124381: PPUSH
// begin uc_side := 0 ;
124382: LD_ADDR_OWVAR 20
124386: PUSH
124387: LD_INT 0
124389: ST_TO_ADDR
// uc_nation := nation_arabian ;
124390: LD_ADDR_OWVAR 21
124394: PUSH
124395: LD_INT 2
124397: ST_TO_ADDR
// hc_gallery :=  ;
124398: LD_ADDR_OWVAR 33
124402: PUSH
124403: LD_STRING 
124405: ST_TO_ADDR
// hc_name :=  ;
124406: LD_ADDR_OWVAR 26
124410: PUSH
124411: LD_STRING 
124413: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
124414: LD_INT 1
124416: PPUSH
124417: LD_INT 11
124419: PPUSH
124420: LD_INT 10
124422: PPUSH
124423: CALL_OW 380
// un := CreateHuman ;
124427: LD_ADDR_VAR 0 1
124431: PUSH
124432: CALL_OW 44
124436: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124437: LD_VAR 0 1
124441: PPUSH
124442: LD_INT 1
124444: PPUSH
124445: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
124449: LD_INT 35
124451: PPUSH
124452: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
124456: LD_VAR 0 1
124460: PPUSH
124461: LD_INT 22
124463: PUSH
124464: LD_OWVAR 2
124468: PUSH
124469: EMPTY
124470: LIST
124471: LIST
124472: PPUSH
124473: CALL_OW 69
124477: PPUSH
124478: LD_VAR 0 1
124482: PPUSH
124483: CALL_OW 74
124487: PPUSH
124488: CALL_OW 115
// until IsDead ( un ) ;
124492: LD_VAR 0 1
124496: PPUSH
124497: CALL_OW 301
124501: IFFALSE 124449
// end ;
124503: PPOPN 1
124505: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
124506: LD_EXP 148
124510: IFFALSE 124518
124512: PUSH
124513: LD_EXP 188
124517: AND
124518: IFFALSE 124530
124520: GO 124522
124522: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
124523: LD_STRING earthquake(getX(game), 0, 32)
124525: PPUSH
124526: CALL_OW 559
124530: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
124531: LD_EXP 148
124535: IFFALSE 124543
124537: PUSH
124538: LD_EXP 189
124542: AND
124543: IFFALSE 124634
124545: GO 124547
124547: DISABLE
124548: LD_INT 0
124550: PPUSH
// begin enable ;
124551: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
124552: LD_ADDR_VAR 0 1
124556: PUSH
124557: LD_INT 22
124559: PUSH
124560: LD_OWVAR 2
124564: PUSH
124565: EMPTY
124566: LIST
124567: LIST
124568: PUSH
124569: LD_INT 21
124571: PUSH
124572: LD_INT 2
124574: PUSH
124575: EMPTY
124576: LIST
124577: LIST
124578: PUSH
124579: LD_INT 33
124581: PUSH
124582: LD_INT 3
124584: PUSH
124585: EMPTY
124586: LIST
124587: LIST
124588: PUSH
124589: EMPTY
124590: LIST
124591: LIST
124592: LIST
124593: PPUSH
124594: CALL_OW 69
124598: ST_TO_ADDR
// if not tmp then
124599: LD_VAR 0 1
124603: NOT
124604: IFFALSE 124608
// exit ;
124606: GO 124634
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124608: LD_VAR 0 1
124612: PUSH
124613: LD_INT 1
124615: PPUSH
124616: LD_VAR 0 1
124620: PPUSH
124621: CALL_OW 12
124625: ARRAY
124626: PPUSH
124627: LD_INT 1
124629: PPUSH
124630: CALL_OW 234
// end ;
124634: PPOPN 1
124636: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
124637: LD_EXP 148
124641: IFFALSE 124649
124643: PUSH
124644: LD_EXP 190
124648: AND
124649: IFFALSE 124790
124651: GO 124653
124653: DISABLE
124654: LD_INT 0
124656: PPUSH
124657: PPUSH
124658: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124659: LD_ADDR_VAR 0 3
124663: PUSH
124664: LD_INT 22
124666: PUSH
124667: LD_OWVAR 2
124671: PUSH
124672: EMPTY
124673: LIST
124674: LIST
124675: PUSH
124676: LD_INT 25
124678: PUSH
124679: LD_INT 1
124681: PUSH
124682: EMPTY
124683: LIST
124684: LIST
124685: PUSH
124686: EMPTY
124687: LIST
124688: LIST
124689: PPUSH
124690: CALL_OW 69
124694: ST_TO_ADDR
// if not tmp then
124695: LD_VAR 0 3
124699: NOT
124700: IFFALSE 124704
// exit ;
124702: GO 124790
// un := tmp [ rand ( 1 , tmp ) ] ;
124704: LD_ADDR_VAR 0 2
124708: PUSH
124709: LD_VAR 0 3
124713: PUSH
124714: LD_INT 1
124716: PPUSH
124717: LD_VAR 0 3
124721: PPUSH
124722: CALL_OW 12
124726: ARRAY
124727: ST_TO_ADDR
// if Crawls ( un ) then
124728: LD_VAR 0 2
124732: PPUSH
124733: CALL_OW 318
124737: IFFALSE 124748
// ComWalk ( un ) ;
124739: LD_VAR 0 2
124743: PPUSH
124744: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
124748: LD_VAR 0 2
124752: PPUSH
124753: LD_INT 9
124755: PPUSH
124756: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
124760: LD_INT 28
124762: PPUSH
124763: LD_OWVAR 2
124767: PPUSH
124768: LD_INT 2
124770: PPUSH
124771: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
124775: LD_INT 29
124777: PPUSH
124778: LD_OWVAR 2
124782: PPUSH
124783: LD_INT 2
124785: PPUSH
124786: CALL_OW 322
// end ;
124790: PPOPN 3
124792: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
124793: LD_EXP 148
124797: IFFALSE 124805
124799: PUSH
124800: LD_EXP 191
124804: AND
124805: IFFALSE 124916
124807: GO 124809
124809: DISABLE
124810: LD_INT 0
124812: PPUSH
124813: PPUSH
124814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124815: LD_ADDR_VAR 0 3
124819: PUSH
124820: LD_INT 22
124822: PUSH
124823: LD_OWVAR 2
124827: PUSH
124828: EMPTY
124829: LIST
124830: LIST
124831: PUSH
124832: LD_INT 25
124834: PUSH
124835: LD_INT 1
124837: PUSH
124838: EMPTY
124839: LIST
124840: LIST
124841: PUSH
124842: EMPTY
124843: LIST
124844: LIST
124845: PPUSH
124846: CALL_OW 69
124850: ST_TO_ADDR
// if not tmp then
124851: LD_VAR 0 3
124855: NOT
124856: IFFALSE 124860
// exit ;
124858: GO 124916
// un := tmp [ rand ( 1 , tmp ) ] ;
124860: LD_ADDR_VAR 0 2
124864: PUSH
124865: LD_VAR 0 3
124869: PUSH
124870: LD_INT 1
124872: PPUSH
124873: LD_VAR 0 3
124877: PPUSH
124878: CALL_OW 12
124882: ARRAY
124883: ST_TO_ADDR
// if Crawls ( un ) then
124884: LD_VAR 0 2
124888: PPUSH
124889: CALL_OW 318
124893: IFFALSE 124904
// ComWalk ( un ) ;
124895: LD_VAR 0 2
124899: PPUSH
124900: CALL_OW 138
// SetClass ( un , class_mortar ) ;
124904: LD_VAR 0 2
124908: PPUSH
124909: LD_INT 8
124911: PPUSH
124912: CALL_OW 336
// end ;
124916: PPOPN 3
124918: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
124919: LD_EXP 148
124923: IFFALSE 124931
124925: PUSH
124926: LD_EXP 192
124930: AND
124931: IFFALSE 125075
124933: GO 124935
124935: DISABLE
124936: LD_INT 0
124938: PPUSH
124939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
124940: LD_ADDR_VAR 0 2
124944: PUSH
124945: LD_INT 22
124947: PUSH
124948: LD_OWVAR 2
124952: PUSH
124953: EMPTY
124954: LIST
124955: LIST
124956: PUSH
124957: LD_INT 21
124959: PUSH
124960: LD_INT 2
124962: PUSH
124963: EMPTY
124964: LIST
124965: LIST
124966: PUSH
124967: LD_INT 2
124969: PUSH
124970: LD_INT 34
124972: PUSH
124973: LD_INT 12
124975: PUSH
124976: EMPTY
124977: LIST
124978: LIST
124979: PUSH
124980: LD_INT 34
124982: PUSH
124983: LD_INT 51
124985: PUSH
124986: EMPTY
124987: LIST
124988: LIST
124989: PUSH
124990: LD_INT 34
124992: PUSH
124993: LD_INT 32
124995: PUSH
124996: EMPTY
124997: LIST
124998: LIST
124999: PUSH
125000: EMPTY
125001: LIST
125002: LIST
125003: LIST
125004: LIST
125005: PUSH
125006: EMPTY
125007: LIST
125008: LIST
125009: LIST
125010: PPUSH
125011: CALL_OW 69
125015: ST_TO_ADDR
// if not tmp then
125016: LD_VAR 0 2
125020: NOT
125021: IFFALSE 125025
// exit ;
125023: GO 125075
// for i in tmp do
125025: LD_ADDR_VAR 0 1
125029: PUSH
125030: LD_VAR 0 2
125034: PUSH
125035: FOR_IN
125036: IFFALSE 125073
// if GetCargo ( i , mat_artifact ) = 0 then
125038: LD_VAR 0 1
125042: PPUSH
125043: LD_INT 4
125045: PPUSH
125046: CALL_OW 289
125050: PUSH
125051: LD_INT 0
125053: EQUAL
125054: IFFALSE 125071
// SetCargo ( i , mat_siberit , 100 ) ;
125056: LD_VAR 0 1
125060: PPUSH
125061: LD_INT 3
125063: PPUSH
125064: LD_INT 100
125066: PPUSH
125067: CALL_OW 290
125071: GO 125035
125073: POP
125074: POP
// end ;
125075: PPOPN 2
125077: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
125078: LD_EXP 148
125082: IFFALSE 125090
125084: PUSH
125085: LD_EXP 193
125089: AND
125090: IFFALSE 125273
125092: GO 125094
125094: DISABLE
125095: LD_INT 0
125097: PPUSH
125098: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125099: LD_ADDR_VAR 0 2
125103: PUSH
125104: LD_INT 22
125106: PUSH
125107: LD_OWVAR 2
125111: PUSH
125112: EMPTY
125113: LIST
125114: LIST
125115: PPUSH
125116: CALL_OW 69
125120: ST_TO_ADDR
// if not tmp then
125121: LD_VAR 0 2
125125: NOT
125126: IFFALSE 125130
// exit ;
125128: GO 125273
// for i := 1 to 2 do
125130: LD_ADDR_VAR 0 1
125134: PUSH
125135: DOUBLE
125136: LD_INT 1
125138: DEC
125139: ST_TO_ADDR
125140: LD_INT 2
125142: PUSH
125143: FOR_TO
125144: IFFALSE 125271
// begin uc_side := your_side ;
125146: LD_ADDR_OWVAR 20
125150: PUSH
125151: LD_OWVAR 2
125155: ST_TO_ADDR
// uc_nation := nation_american ;
125156: LD_ADDR_OWVAR 21
125160: PUSH
125161: LD_INT 1
125163: ST_TO_ADDR
// vc_chassis := us_morphling ;
125164: LD_ADDR_OWVAR 37
125168: PUSH
125169: LD_INT 5
125171: ST_TO_ADDR
// vc_engine := engine_siberite ;
125172: LD_ADDR_OWVAR 39
125176: PUSH
125177: LD_INT 3
125179: ST_TO_ADDR
// vc_control := control_computer ;
125180: LD_ADDR_OWVAR 38
125184: PUSH
125185: LD_INT 3
125187: ST_TO_ADDR
// vc_weapon := us_double_laser ;
125188: LD_ADDR_OWVAR 40
125192: PUSH
125193: LD_INT 10
125195: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
125196: LD_VAR 0 2
125200: PUSH
125201: LD_INT 1
125203: ARRAY
125204: PPUSH
125205: CALL_OW 310
125209: NOT
125210: IFFALSE 125257
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
125212: CALL_OW 45
125216: PPUSH
125217: LD_VAR 0 2
125221: PUSH
125222: LD_INT 1
125224: ARRAY
125225: PPUSH
125226: CALL_OW 250
125230: PPUSH
125231: LD_VAR 0 2
125235: PUSH
125236: LD_INT 1
125238: ARRAY
125239: PPUSH
125240: CALL_OW 251
125244: PPUSH
125245: LD_INT 12
125247: PPUSH
125248: LD_INT 1
125250: PPUSH
125251: CALL_OW 50
125255: GO 125269
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
125257: CALL_OW 45
125261: PPUSH
125262: LD_INT 1
125264: PPUSH
125265: CALL_OW 51
// end ;
125269: GO 125143
125271: POP
125272: POP
// end ;
125273: PPOPN 2
125275: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
125276: LD_EXP 148
125280: IFFALSE 125288
125282: PUSH
125283: LD_EXP 194
125287: AND
125288: IFFALSE 125510
125290: GO 125292
125292: DISABLE
125293: LD_INT 0
125295: PPUSH
125296: PPUSH
125297: PPUSH
125298: PPUSH
125299: PPUSH
125300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
125301: LD_ADDR_VAR 0 6
125305: PUSH
125306: LD_INT 22
125308: PUSH
125309: LD_OWVAR 2
125313: PUSH
125314: EMPTY
125315: LIST
125316: LIST
125317: PUSH
125318: LD_INT 21
125320: PUSH
125321: LD_INT 1
125323: PUSH
125324: EMPTY
125325: LIST
125326: LIST
125327: PUSH
125328: LD_INT 3
125330: PUSH
125331: LD_INT 23
125333: PUSH
125334: LD_INT 0
125336: PUSH
125337: EMPTY
125338: LIST
125339: LIST
125340: PUSH
125341: EMPTY
125342: LIST
125343: LIST
125344: PUSH
125345: EMPTY
125346: LIST
125347: LIST
125348: LIST
125349: PPUSH
125350: CALL_OW 69
125354: ST_TO_ADDR
// if not tmp then
125355: LD_VAR 0 6
125359: NOT
125360: IFFALSE 125364
// exit ;
125362: GO 125510
// s1 := rand ( 1 , 4 ) ;
125364: LD_ADDR_VAR 0 2
125368: PUSH
125369: LD_INT 1
125371: PPUSH
125372: LD_INT 4
125374: PPUSH
125375: CALL_OW 12
125379: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
125380: LD_ADDR_VAR 0 4
125384: PUSH
125385: LD_VAR 0 6
125389: PUSH
125390: LD_INT 1
125392: ARRAY
125393: PPUSH
125394: LD_VAR 0 2
125398: PPUSH
125399: CALL_OW 259
125403: ST_TO_ADDR
// if s1 = 1 then
125404: LD_VAR 0 2
125408: PUSH
125409: LD_INT 1
125411: EQUAL
125412: IFFALSE 125432
// s2 := rand ( 2 , 4 ) else
125414: LD_ADDR_VAR 0 3
125418: PUSH
125419: LD_INT 2
125421: PPUSH
125422: LD_INT 4
125424: PPUSH
125425: CALL_OW 12
125429: ST_TO_ADDR
125430: GO 125440
// s2 := 1 ;
125432: LD_ADDR_VAR 0 3
125436: PUSH
125437: LD_INT 1
125439: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
125440: LD_ADDR_VAR 0 5
125444: PUSH
125445: LD_VAR 0 6
125449: PUSH
125450: LD_INT 1
125452: ARRAY
125453: PPUSH
125454: LD_VAR 0 3
125458: PPUSH
125459: CALL_OW 259
125463: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
125464: LD_VAR 0 6
125468: PUSH
125469: LD_INT 1
125471: ARRAY
125472: PPUSH
125473: LD_VAR 0 2
125477: PPUSH
125478: LD_VAR 0 5
125482: PPUSH
125483: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
125487: LD_VAR 0 6
125491: PUSH
125492: LD_INT 1
125494: ARRAY
125495: PPUSH
125496: LD_VAR 0 3
125500: PPUSH
125501: LD_VAR 0 4
125505: PPUSH
125506: CALL_OW 237
// end ;
125510: PPOPN 6
125512: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
125513: LD_EXP 148
125517: IFFALSE 125525
125519: PUSH
125520: LD_EXP 195
125524: AND
125525: IFFALSE 125604
125527: GO 125529
125529: DISABLE
125530: LD_INT 0
125532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
125533: LD_ADDR_VAR 0 1
125537: PUSH
125538: LD_INT 22
125540: PUSH
125541: LD_OWVAR 2
125545: PUSH
125546: EMPTY
125547: LIST
125548: LIST
125549: PUSH
125550: LD_INT 30
125552: PUSH
125553: LD_INT 3
125555: PUSH
125556: EMPTY
125557: LIST
125558: LIST
125559: PUSH
125560: EMPTY
125561: LIST
125562: LIST
125563: PPUSH
125564: CALL_OW 69
125568: ST_TO_ADDR
// if not tmp then
125569: LD_VAR 0 1
125573: NOT
125574: IFFALSE 125578
// exit ;
125576: GO 125604
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
125578: LD_VAR 0 1
125582: PUSH
125583: LD_INT 1
125585: PPUSH
125586: LD_VAR 0 1
125590: PPUSH
125591: CALL_OW 12
125595: ARRAY
125596: PPUSH
125597: LD_INT 1
125599: PPUSH
125600: CALL_OW 234
// end ;
125604: PPOPN 1
125606: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
125607: LD_EXP 148
125611: IFFALSE 125619
125613: PUSH
125614: LD_EXP 196
125618: AND
125619: IFFALSE 125731
125621: GO 125623
125623: DISABLE
125624: LD_INT 0
125626: PPUSH
125627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
125628: LD_ADDR_VAR 0 2
125632: PUSH
125633: LD_INT 22
125635: PUSH
125636: LD_OWVAR 2
125640: PUSH
125641: EMPTY
125642: LIST
125643: LIST
125644: PUSH
125645: LD_INT 2
125647: PUSH
125648: LD_INT 30
125650: PUSH
125651: LD_INT 27
125653: PUSH
125654: EMPTY
125655: LIST
125656: LIST
125657: PUSH
125658: LD_INT 30
125660: PUSH
125661: LD_INT 26
125663: PUSH
125664: EMPTY
125665: LIST
125666: LIST
125667: PUSH
125668: LD_INT 30
125670: PUSH
125671: LD_INT 28
125673: PUSH
125674: EMPTY
125675: LIST
125676: LIST
125677: PUSH
125678: EMPTY
125679: LIST
125680: LIST
125681: LIST
125682: LIST
125683: PUSH
125684: EMPTY
125685: LIST
125686: LIST
125687: PPUSH
125688: CALL_OW 69
125692: ST_TO_ADDR
// if not tmp then
125693: LD_VAR 0 2
125697: NOT
125698: IFFALSE 125702
// exit ;
125700: GO 125731
// for i in tmp do
125702: LD_ADDR_VAR 0 1
125706: PUSH
125707: LD_VAR 0 2
125711: PUSH
125712: FOR_IN
125713: IFFALSE 125729
// SetLives ( i , 1 ) ;
125715: LD_VAR 0 1
125719: PPUSH
125720: LD_INT 1
125722: PPUSH
125723: CALL_OW 234
125727: GO 125712
125729: POP
125730: POP
// end ;
125731: PPOPN 2
125733: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
125734: LD_EXP 148
125738: IFFALSE 125746
125740: PUSH
125741: LD_EXP 197
125745: AND
125746: IFFALSE 126033
125748: GO 125750
125750: DISABLE
125751: LD_INT 0
125753: PPUSH
125754: PPUSH
125755: PPUSH
// begin i := rand ( 1 , 7 ) ;
125756: LD_ADDR_VAR 0 1
125760: PUSH
125761: LD_INT 1
125763: PPUSH
125764: LD_INT 7
125766: PPUSH
125767: CALL_OW 12
125771: ST_TO_ADDR
// case i of 1 :
125772: LD_VAR 0 1
125776: PUSH
125777: LD_INT 1
125779: DOUBLE
125780: EQUAL
125781: IFTRUE 125785
125783: GO 125795
125785: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
125786: LD_STRING earthquake(getX(game), 0, 32)
125788: PPUSH
125789: CALL_OW 559
125793: GO 126033
125795: LD_INT 2
125797: DOUBLE
125798: EQUAL
125799: IFTRUE 125803
125801: GO 125817
125803: POP
// begin ToLua ( displayStucuk(); ) ;
125804: LD_STRING displayStucuk();
125806: PPUSH
125807: CALL_OW 559
// ResetFog ;
125811: CALL_OW 335
// end ; 3 :
125815: GO 126033
125817: LD_INT 3
125819: DOUBLE
125820: EQUAL
125821: IFTRUE 125825
125823: GO 125929
125825: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
125826: LD_ADDR_VAR 0 2
125830: PUSH
125831: LD_INT 22
125833: PUSH
125834: LD_OWVAR 2
125838: PUSH
125839: EMPTY
125840: LIST
125841: LIST
125842: PUSH
125843: LD_INT 25
125845: PUSH
125846: LD_INT 1
125848: PUSH
125849: EMPTY
125850: LIST
125851: LIST
125852: PUSH
125853: EMPTY
125854: LIST
125855: LIST
125856: PPUSH
125857: CALL_OW 69
125861: ST_TO_ADDR
// if not tmp then
125862: LD_VAR 0 2
125866: NOT
125867: IFFALSE 125871
// exit ;
125869: GO 126033
// un := tmp [ rand ( 1 , tmp ) ] ;
125871: LD_ADDR_VAR 0 3
125875: PUSH
125876: LD_VAR 0 2
125880: PUSH
125881: LD_INT 1
125883: PPUSH
125884: LD_VAR 0 2
125888: PPUSH
125889: CALL_OW 12
125893: ARRAY
125894: ST_TO_ADDR
// if Crawls ( un ) then
125895: LD_VAR 0 3
125899: PPUSH
125900: CALL_OW 318
125904: IFFALSE 125915
// ComWalk ( un ) ;
125906: LD_VAR 0 3
125910: PPUSH
125911: CALL_OW 138
// SetClass ( un , class_mortar ) ;
125915: LD_VAR 0 3
125919: PPUSH
125920: LD_INT 8
125922: PPUSH
125923: CALL_OW 336
// end ; 4 :
125927: GO 126033
125929: LD_INT 4
125931: DOUBLE
125932: EQUAL
125933: IFTRUE 125937
125935: GO 126011
125937: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
125938: LD_ADDR_VAR 0 2
125942: PUSH
125943: LD_INT 22
125945: PUSH
125946: LD_OWVAR 2
125950: PUSH
125951: EMPTY
125952: LIST
125953: LIST
125954: PUSH
125955: LD_INT 30
125957: PUSH
125958: LD_INT 29
125960: PUSH
125961: EMPTY
125962: LIST
125963: LIST
125964: PUSH
125965: EMPTY
125966: LIST
125967: LIST
125968: PPUSH
125969: CALL_OW 69
125973: ST_TO_ADDR
// if not tmp then
125974: LD_VAR 0 2
125978: NOT
125979: IFFALSE 125983
// exit ;
125981: GO 126033
// CenterNowOnUnits ( tmp [ 1 ] ) ;
125983: LD_VAR 0 2
125987: PUSH
125988: LD_INT 1
125990: ARRAY
125991: PPUSH
125992: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
125996: LD_VAR 0 2
126000: PUSH
126001: LD_INT 1
126003: ARRAY
126004: PPUSH
126005: CALL_OW 65
// end ; 5 .. 7 :
126009: GO 126033
126011: LD_INT 5
126013: DOUBLE
126014: GREATEREQUAL
126015: IFFALSE 126023
126017: LD_INT 7
126019: DOUBLE
126020: LESSEQUAL
126021: IFTRUE 126025
126023: GO 126032
126025: POP
// StreamSibBomb ; end ;
126026: CALL 122214 0 0
126030: GO 126033
126032: POP
// end ;
126033: PPOPN 3
126035: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
126036: LD_EXP 148
126040: IFFALSE 126048
126042: PUSH
126043: LD_EXP 198
126047: AND
126048: IFFALSE 126204
126050: GO 126052
126052: DISABLE
126053: LD_INT 0
126055: PPUSH
126056: PPUSH
126057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
126058: LD_ADDR_VAR 0 2
126062: PUSH
126063: LD_INT 81
126065: PUSH
126066: LD_OWVAR 2
126070: PUSH
126071: EMPTY
126072: LIST
126073: LIST
126074: PUSH
126075: LD_INT 2
126077: PUSH
126078: LD_INT 21
126080: PUSH
126081: LD_INT 1
126083: PUSH
126084: EMPTY
126085: LIST
126086: LIST
126087: PUSH
126088: LD_INT 21
126090: PUSH
126091: LD_INT 2
126093: PUSH
126094: EMPTY
126095: LIST
126096: LIST
126097: PUSH
126098: EMPTY
126099: LIST
126100: LIST
126101: LIST
126102: PUSH
126103: EMPTY
126104: LIST
126105: LIST
126106: PPUSH
126107: CALL_OW 69
126111: ST_TO_ADDR
// if not tmp then
126112: LD_VAR 0 2
126116: NOT
126117: IFFALSE 126121
// exit ;
126119: GO 126204
// p := 0 ;
126121: LD_ADDR_VAR 0 3
126125: PUSH
126126: LD_INT 0
126128: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126129: LD_INT 35
126131: PPUSH
126132: CALL_OW 67
// p := p + 1 ;
126136: LD_ADDR_VAR 0 3
126140: PUSH
126141: LD_VAR 0 3
126145: PUSH
126146: LD_INT 1
126148: PLUS
126149: ST_TO_ADDR
// for i in tmp do
126150: LD_ADDR_VAR 0 1
126154: PUSH
126155: LD_VAR 0 2
126159: PUSH
126160: FOR_IN
126161: IFFALSE 126192
// if GetLives ( i ) < 1000 then
126163: LD_VAR 0 1
126167: PPUSH
126168: CALL_OW 256
126172: PUSH
126173: LD_INT 1000
126175: LESS
126176: IFFALSE 126190
// SetLives ( i , 1000 ) ;
126178: LD_VAR 0 1
126182: PPUSH
126183: LD_INT 1000
126185: PPUSH
126186: CALL_OW 234
126190: GO 126160
126192: POP
126193: POP
// until p > 20 ;
126194: LD_VAR 0 3
126198: PUSH
126199: LD_INT 20
126201: GREATER
126202: IFFALSE 126129
// end ;
126204: PPOPN 3
126206: END
// every 0 0$1 trigger StreamModeActive and sTime do
126207: LD_EXP 148
126211: IFFALSE 126219
126213: PUSH
126214: LD_EXP 199
126218: AND
126219: IFFALSE 126254
126221: GO 126223
126223: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
126224: LD_INT 28
126226: PPUSH
126227: LD_OWVAR 2
126231: PPUSH
126232: LD_INT 2
126234: PPUSH
126235: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
126239: LD_INT 30
126241: PPUSH
126242: LD_OWVAR 2
126246: PPUSH
126247: LD_INT 2
126249: PPUSH
126250: CALL_OW 322
// end ;
126254: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
126255: LD_EXP 148
126259: IFFALSE 126267
126261: PUSH
126262: LD_EXP 200
126266: AND
126267: IFFALSE 126388
126269: GO 126271
126271: DISABLE
126272: LD_INT 0
126274: PPUSH
126275: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
126276: LD_ADDR_VAR 0 2
126280: PUSH
126281: LD_INT 22
126283: PUSH
126284: LD_OWVAR 2
126288: PUSH
126289: EMPTY
126290: LIST
126291: LIST
126292: PUSH
126293: LD_INT 21
126295: PUSH
126296: LD_INT 1
126298: PUSH
126299: EMPTY
126300: LIST
126301: LIST
126302: PUSH
126303: LD_INT 3
126305: PUSH
126306: LD_INT 23
126308: PUSH
126309: LD_INT 0
126311: PUSH
126312: EMPTY
126313: LIST
126314: LIST
126315: PUSH
126316: EMPTY
126317: LIST
126318: LIST
126319: PUSH
126320: EMPTY
126321: LIST
126322: LIST
126323: LIST
126324: PPUSH
126325: CALL_OW 69
126329: ST_TO_ADDR
// if not tmp then
126330: LD_VAR 0 2
126334: NOT
126335: IFFALSE 126339
// exit ;
126337: GO 126388
// for i in tmp do
126339: LD_ADDR_VAR 0 1
126343: PUSH
126344: LD_VAR 0 2
126348: PUSH
126349: FOR_IN
126350: IFFALSE 126386
// begin if Crawls ( i ) then
126352: LD_VAR 0 1
126356: PPUSH
126357: CALL_OW 318
126361: IFFALSE 126372
// ComWalk ( i ) ;
126363: LD_VAR 0 1
126367: PPUSH
126368: CALL_OW 138
// SetClass ( i , 2 ) ;
126372: LD_VAR 0 1
126376: PPUSH
126377: LD_INT 2
126379: PPUSH
126380: CALL_OW 336
// end ;
126384: GO 126349
126386: POP
126387: POP
// end ;
126388: PPOPN 2
126390: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
126391: LD_EXP 148
126395: IFFALSE 126403
126397: PUSH
126398: LD_EXP 201
126402: AND
126403: IFFALSE 126693
126405: GO 126407
126407: DISABLE
126408: LD_INT 0
126410: PPUSH
126411: PPUSH
126412: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
126413: LD_OWVAR 2
126417: PPUSH
126418: LD_INT 9
126420: PPUSH
126421: LD_INT 1
126423: PPUSH
126424: LD_INT 1
126426: PPUSH
126427: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
126431: LD_INT 9
126433: PPUSH
126434: LD_OWVAR 2
126438: PPUSH
126439: CALL_OW 343
// uc_side := 9 ;
126443: LD_ADDR_OWVAR 20
126447: PUSH
126448: LD_INT 9
126450: ST_TO_ADDR
// uc_nation := 2 ;
126451: LD_ADDR_OWVAR 21
126455: PUSH
126456: LD_INT 2
126458: ST_TO_ADDR
// hc_name := Dark Warrior ;
126459: LD_ADDR_OWVAR 26
126463: PUSH
126464: LD_STRING Dark Warrior
126466: ST_TO_ADDR
// hc_gallery :=  ;
126467: LD_ADDR_OWVAR 33
126471: PUSH
126472: LD_STRING 
126474: ST_TO_ADDR
// hc_noskilllimit := true ;
126475: LD_ADDR_OWVAR 76
126479: PUSH
126480: LD_INT 1
126482: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
126483: LD_ADDR_OWVAR 31
126487: PUSH
126488: LD_INT 30
126490: PUSH
126491: LD_INT 30
126493: PUSH
126494: LD_INT 30
126496: PUSH
126497: LD_INT 30
126499: PUSH
126500: EMPTY
126501: LIST
126502: LIST
126503: LIST
126504: LIST
126505: ST_TO_ADDR
// un := CreateHuman ;
126506: LD_ADDR_VAR 0 3
126510: PUSH
126511: CALL_OW 44
126515: ST_TO_ADDR
// hc_noskilllimit := false ;
126516: LD_ADDR_OWVAR 76
126520: PUSH
126521: LD_INT 0
126523: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
126524: LD_VAR 0 3
126528: PPUSH
126529: LD_INT 1
126531: PPUSH
126532: CALL_OW 51
// ToLua ( playRanger() ) ;
126536: LD_STRING playRanger()
126538: PPUSH
126539: CALL_OW 559
// p := 0 ;
126543: LD_ADDR_VAR 0 2
126547: PUSH
126548: LD_INT 0
126550: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126551: LD_INT 35
126553: PPUSH
126554: CALL_OW 67
// p := p + 1 ;
126558: LD_ADDR_VAR 0 2
126562: PUSH
126563: LD_VAR 0 2
126567: PUSH
126568: LD_INT 1
126570: PLUS
126571: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
126572: LD_VAR 0 3
126576: PPUSH
126577: CALL_OW 256
126581: PUSH
126582: LD_INT 1000
126584: LESS
126585: IFFALSE 126599
// SetLives ( un , 1000 ) ;
126587: LD_VAR 0 3
126591: PPUSH
126592: LD_INT 1000
126594: PPUSH
126595: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
126599: LD_VAR 0 3
126603: PPUSH
126604: LD_INT 81
126606: PUSH
126607: LD_OWVAR 2
126611: PUSH
126612: EMPTY
126613: LIST
126614: LIST
126615: PUSH
126616: LD_INT 91
126618: PUSH
126619: LD_VAR 0 3
126623: PUSH
126624: LD_INT 30
126626: PUSH
126627: EMPTY
126628: LIST
126629: LIST
126630: LIST
126631: PUSH
126632: EMPTY
126633: LIST
126634: LIST
126635: PPUSH
126636: CALL_OW 69
126640: PPUSH
126641: LD_VAR 0 3
126645: PPUSH
126646: CALL_OW 74
126650: PPUSH
126651: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
126655: LD_VAR 0 2
126659: PUSH
126660: LD_INT 80
126662: GREATER
126663: IFTRUE 126676
126665: PUSH
126666: LD_VAR 0 3
126670: PPUSH
126671: CALL_OW 301
126675: OR
126676: IFFALSE 126551
// if un then
126678: LD_VAR 0 3
126682: IFFALSE 126693
// RemoveUnit ( un ) ;
126684: LD_VAR 0 3
126688: PPUSH
126689: CALL_OW 64
// end ;
126693: PPOPN 3
126695: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
126696: LD_EXP 202
126700: IFFALSE 126816
126702: GO 126704
126704: DISABLE
126705: LD_INT 0
126707: PPUSH
126708: PPUSH
126709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
126710: LD_ADDR_VAR 0 2
126714: PUSH
126715: LD_INT 81
126717: PUSH
126718: LD_OWVAR 2
126722: PUSH
126723: EMPTY
126724: LIST
126725: LIST
126726: PUSH
126727: LD_INT 21
126729: PUSH
126730: LD_INT 1
126732: PUSH
126733: EMPTY
126734: LIST
126735: LIST
126736: PUSH
126737: EMPTY
126738: LIST
126739: LIST
126740: PPUSH
126741: CALL_OW 69
126745: ST_TO_ADDR
// ToLua ( playComputer() ) ;
126746: LD_STRING playComputer()
126748: PPUSH
126749: CALL_OW 559
// if not tmp then
126753: LD_VAR 0 2
126757: NOT
126758: IFFALSE 126762
// exit ;
126760: GO 126816
// for i in tmp do
126762: LD_ADDR_VAR 0 1
126766: PUSH
126767: LD_VAR 0 2
126771: PUSH
126772: FOR_IN
126773: IFFALSE 126814
// for j := 1 to 4 do
126775: LD_ADDR_VAR 0 3
126779: PUSH
126780: DOUBLE
126781: LD_INT 1
126783: DEC
126784: ST_TO_ADDR
126785: LD_INT 4
126787: PUSH
126788: FOR_TO
126789: IFFALSE 126810
// SetSkill ( i , j , 10 ) ;
126791: LD_VAR 0 1
126795: PPUSH
126796: LD_VAR 0 3
126800: PPUSH
126801: LD_INT 10
126803: PPUSH
126804: CALL_OW 237
126808: GO 126788
126810: POP
126811: POP
126812: GO 126772
126814: POP
126815: POP
// end ;
126816: PPOPN 3
126818: END
// every 0 0$1 trigger s30 do var i , tmp ;
126819: LD_EXP 203
126823: IFFALSE 126892
126825: GO 126827
126827: DISABLE
126828: LD_INT 0
126830: PPUSH
126831: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
126832: LD_ADDR_VAR 0 2
126836: PUSH
126837: LD_INT 22
126839: PUSH
126840: LD_OWVAR 2
126844: PUSH
126845: EMPTY
126846: LIST
126847: LIST
126848: PPUSH
126849: CALL_OW 69
126853: ST_TO_ADDR
// if not tmp then
126854: LD_VAR 0 2
126858: NOT
126859: IFFALSE 126863
// exit ;
126861: GO 126892
// for i in tmp do
126863: LD_ADDR_VAR 0 1
126867: PUSH
126868: LD_VAR 0 2
126872: PUSH
126873: FOR_IN
126874: IFFALSE 126890
// SetLives ( i , 300 ) ;
126876: LD_VAR 0 1
126880: PPUSH
126881: LD_INT 300
126883: PPUSH
126884: CALL_OW 234
126888: GO 126873
126890: POP
126891: POP
// end ;
126892: PPOPN 2
126894: END
// every 0 0$1 trigger s60 do var i , tmp ;
126895: LD_EXP 204
126899: IFFALSE 126968
126901: GO 126903
126903: DISABLE
126904: LD_INT 0
126906: PPUSH
126907: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
126908: LD_ADDR_VAR 0 2
126912: PUSH
126913: LD_INT 22
126915: PUSH
126916: LD_OWVAR 2
126920: PUSH
126921: EMPTY
126922: LIST
126923: LIST
126924: PPUSH
126925: CALL_OW 69
126929: ST_TO_ADDR
// if not tmp then
126930: LD_VAR 0 2
126934: NOT
126935: IFFALSE 126939
// exit ;
126937: GO 126968
// for i in tmp do
126939: LD_ADDR_VAR 0 1
126943: PUSH
126944: LD_VAR 0 2
126948: PUSH
126949: FOR_IN
126950: IFFALSE 126966
// SetLives ( i , 600 ) ;
126952: LD_VAR 0 1
126956: PPUSH
126957: LD_INT 600
126959: PPUSH
126960: CALL_OW 234
126964: GO 126949
126966: POP
126967: POP
// end ;
126968: PPOPN 2
126970: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
126971: LD_INT 0
126973: PPUSH
// case cmd of 301 :
126974: LD_VAR 0 1
126978: PUSH
126979: LD_INT 301
126981: DOUBLE
126982: EQUAL
126983: IFTRUE 126987
126985: GO 127019
126987: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
126988: LD_VAR 0 6
126992: PPUSH
126993: LD_VAR 0 7
126997: PPUSH
126998: LD_VAR 0 8
127002: PPUSH
127003: LD_VAR 0 4
127007: PPUSH
127008: LD_VAR 0 5
127012: PPUSH
127013: CALL 128232 0 5
127017: GO 127140
127019: LD_INT 302
127021: DOUBLE
127022: EQUAL
127023: IFTRUE 127027
127025: GO 127064
127027: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
127028: LD_VAR 0 6
127032: PPUSH
127033: LD_VAR 0 7
127037: PPUSH
127038: LD_VAR 0 8
127042: PPUSH
127043: LD_VAR 0 9
127047: PPUSH
127048: LD_VAR 0 4
127052: PPUSH
127053: LD_VAR 0 5
127057: PPUSH
127058: CALL 128323 0 6
127062: GO 127140
127064: LD_INT 303
127066: DOUBLE
127067: EQUAL
127068: IFTRUE 127072
127070: GO 127109
127072: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
127073: LD_VAR 0 6
127077: PPUSH
127078: LD_VAR 0 7
127082: PPUSH
127083: LD_VAR 0 8
127087: PPUSH
127088: LD_VAR 0 9
127092: PPUSH
127093: LD_VAR 0 4
127097: PPUSH
127098: LD_VAR 0 5
127102: PPUSH
127103: CALL 127145 0 6
127107: GO 127140
127109: LD_INT 304
127111: DOUBLE
127112: EQUAL
127113: IFTRUE 127117
127115: GO 127139
127117: POP
// hHackTeleport ( unit , x , y ) ; end ;
127118: LD_VAR 0 2
127122: PPUSH
127123: LD_VAR 0 4
127127: PPUSH
127128: LD_VAR 0 5
127132: PPUSH
127133: CALL 128916 0 3
127137: GO 127140
127139: POP
// end ;
127140: LD_VAR 0 12
127144: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
127145: LD_INT 0
127147: PPUSH
127148: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
127149: LD_VAR 0 1
127153: PUSH
127154: LD_INT 1
127156: LESS
127157: IFTRUE 127169
127159: PUSH
127160: LD_VAR 0 1
127164: PUSH
127165: LD_INT 3
127167: GREATER
127168: OR
127169: IFTRUE 127187
127171: PUSH
127172: LD_VAR 0 5
127176: PPUSH
127177: LD_VAR 0 6
127181: PPUSH
127182: CALL_OW 428
127186: OR
127187: IFFALSE 127191
// exit ;
127189: GO 127919
// uc_side := your_side ;
127191: LD_ADDR_OWVAR 20
127195: PUSH
127196: LD_OWVAR 2
127200: ST_TO_ADDR
// uc_nation := nation ;
127201: LD_ADDR_OWVAR 21
127205: PUSH
127206: LD_VAR 0 1
127210: ST_TO_ADDR
// bc_level = 1 ;
127211: LD_ADDR_OWVAR 43
127215: PUSH
127216: LD_INT 1
127218: ST_TO_ADDR
// case btype of 1 :
127219: LD_VAR 0 2
127223: PUSH
127224: LD_INT 1
127226: DOUBLE
127227: EQUAL
127228: IFTRUE 127232
127230: GO 127243
127232: POP
// bc_type := b_depot ; 2 :
127233: LD_ADDR_OWVAR 42
127237: PUSH
127238: LD_INT 0
127240: ST_TO_ADDR
127241: GO 127863
127243: LD_INT 2
127245: DOUBLE
127246: EQUAL
127247: IFTRUE 127251
127249: GO 127262
127251: POP
// bc_type := b_warehouse ; 3 :
127252: LD_ADDR_OWVAR 42
127256: PUSH
127257: LD_INT 1
127259: ST_TO_ADDR
127260: GO 127863
127262: LD_INT 3
127264: DOUBLE
127265: EQUAL
127266: IFTRUE 127270
127268: GO 127281
127270: POP
// bc_type := b_lab ; 4 .. 9 :
127271: LD_ADDR_OWVAR 42
127275: PUSH
127276: LD_INT 6
127278: ST_TO_ADDR
127279: GO 127863
127281: LD_INT 4
127283: DOUBLE
127284: GREATEREQUAL
127285: IFFALSE 127293
127287: LD_INT 9
127289: DOUBLE
127290: LESSEQUAL
127291: IFTRUE 127295
127293: GO 127355
127295: POP
// begin bc_type := b_lab_half ;
127296: LD_ADDR_OWVAR 42
127300: PUSH
127301: LD_INT 7
127303: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
127304: LD_ADDR_OWVAR 44
127308: PUSH
127309: LD_INT 10
127311: PUSH
127312: LD_INT 11
127314: PUSH
127315: LD_INT 12
127317: PUSH
127318: LD_INT 15
127320: PUSH
127321: LD_INT 14
127323: PUSH
127324: LD_INT 13
127326: PUSH
127327: EMPTY
127328: LIST
127329: LIST
127330: LIST
127331: LIST
127332: LIST
127333: LIST
127334: PUSH
127335: LD_VAR 0 2
127339: PUSH
127340: LD_INT 3
127342: MINUS
127343: ARRAY
127344: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
127345: LD_ADDR_OWVAR 45
127349: PUSH
127350: LD_INT 9
127352: ST_TO_ADDR
// end ; 10 .. 13 :
127353: GO 127863
127355: LD_INT 10
127357: DOUBLE
127358: GREATEREQUAL
127359: IFFALSE 127367
127361: LD_INT 13
127363: DOUBLE
127364: LESSEQUAL
127365: IFTRUE 127369
127367: GO 127446
127369: POP
// begin bc_type := b_lab_full ;
127370: LD_ADDR_OWVAR 42
127374: PUSH
127375: LD_INT 8
127377: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
127378: LD_ADDR_OWVAR 44
127382: PUSH
127383: LD_INT 10
127385: PUSH
127386: LD_INT 12
127388: PUSH
127389: LD_INT 14
127391: PUSH
127392: LD_INT 13
127394: PUSH
127395: EMPTY
127396: LIST
127397: LIST
127398: LIST
127399: LIST
127400: PUSH
127401: LD_VAR 0 2
127405: PUSH
127406: LD_INT 9
127408: MINUS
127409: ARRAY
127410: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
127411: LD_ADDR_OWVAR 45
127415: PUSH
127416: LD_INT 11
127418: PUSH
127419: LD_INT 15
127421: PUSH
127422: LD_INT 12
127424: PUSH
127425: LD_INT 15
127427: PUSH
127428: EMPTY
127429: LIST
127430: LIST
127431: LIST
127432: LIST
127433: PUSH
127434: LD_VAR 0 2
127438: PUSH
127439: LD_INT 9
127441: MINUS
127442: ARRAY
127443: ST_TO_ADDR
// end ; 14 :
127444: GO 127863
127446: LD_INT 14
127448: DOUBLE
127449: EQUAL
127450: IFTRUE 127454
127452: GO 127465
127454: POP
// bc_type := b_workshop ; 15 :
127455: LD_ADDR_OWVAR 42
127459: PUSH
127460: LD_INT 2
127462: ST_TO_ADDR
127463: GO 127863
127465: LD_INT 15
127467: DOUBLE
127468: EQUAL
127469: IFTRUE 127473
127471: GO 127484
127473: POP
// bc_type := b_factory ; 16 :
127474: LD_ADDR_OWVAR 42
127478: PUSH
127479: LD_INT 3
127481: ST_TO_ADDR
127482: GO 127863
127484: LD_INT 16
127486: DOUBLE
127487: EQUAL
127488: IFTRUE 127492
127490: GO 127503
127492: POP
// bc_type := b_ext_gun ; 17 :
127493: LD_ADDR_OWVAR 42
127497: PUSH
127498: LD_INT 17
127500: ST_TO_ADDR
127501: GO 127863
127503: LD_INT 17
127505: DOUBLE
127506: EQUAL
127507: IFTRUE 127511
127509: GO 127539
127511: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
127512: LD_ADDR_OWVAR 42
127516: PUSH
127517: LD_INT 19
127519: PUSH
127520: LD_INT 23
127522: PUSH
127523: LD_INT 19
127525: PUSH
127526: EMPTY
127527: LIST
127528: LIST
127529: LIST
127530: PUSH
127531: LD_VAR 0 1
127535: ARRAY
127536: ST_TO_ADDR
127537: GO 127863
127539: LD_INT 18
127541: DOUBLE
127542: EQUAL
127543: IFTRUE 127547
127545: GO 127558
127547: POP
// bc_type := b_ext_radar ; 19 :
127548: LD_ADDR_OWVAR 42
127552: PUSH
127553: LD_INT 20
127555: ST_TO_ADDR
127556: GO 127863
127558: LD_INT 19
127560: DOUBLE
127561: EQUAL
127562: IFTRUE 127566
127564: GO 127577
127566: POP
// bc_type := b_ext_radio ; 20 :
127567: LD_ADDR_OWVAR 42
127571: PUSH
127572: LD_INT 22
127574: ST_TO_ADDR
127575: GO 127863
127577: LD_INT 20
127579: DOUBLE
127580: EQUAL
127581: IFTRUE 127585
127583: GO 127596
127585: POP
// bc_type := b_ext_siberium ; 21 :
127586: LD_ADDR_OWVAR 42
127590: PUSH
127591: LD_INT 21
127593: ST_TO_ADDR
127594: GO 127863
127596: LD_INT 21
127598: DOUBLE
127599: EQUAL
127600: IFTRUE 127604
127602: GO 127615
127604: POP
// bc_type := b_ext_computer ; 22 :
127605: LD_ADDR_OWVAR 42
127609: PUSH
127610: LD_INT 24
127612: ST_TO_ADDR
127613: GO 127863
127615: LD_INT 22
127617: DOUBLE
127618: EQUAL
127619: IFTRUE 127623
127621: GO 127634
127623: POP
// bc_type := b_ext_track ; 23 :
127624: LD_ADDR_OWVAR 42
127628: PUSH
127629: LD_INT 16
127631: ST_TO_ADDR
127632: GO 127863
127634: LD_INT 23
127636: DOUBLE
127637: EQUAL
127638: IFTRUE 127642
127640: GO 127653
127642: POP
// bc_type := b_ext_laser ; 24 :
127643: LD_ADDR_OWVAR 42
127647: PUSH
127648: LD_INT 25
127650: ST_TO_ADDR
127651: GO 127863
127653: LD_INT 24
127655: DOUBLE
127656: EQUAL
127657: IFTRUE 127661
127659: GO 127672
127661: POP
// bc_type := b_control_tower ; 25 :
127662: LD_ADDR_OWVAR 42
127666: PUSH
127667: LD_INT 36
127669: ST_TO_ADDR
127670: GO 127863
127672: LD_INT 25
127674: DOUBLE
127675: EQUAL
127676: IFTRUE 127680
127678: GO 127691
127680: POP
// bc_type := b_breastwork ; 26 :
127681: LD_ADDR_OWVAR 42
127685: PUSH
127686: LD_INT 31
127688: ST_TO_ADDR
127689: GO 127863
127691: LD_INT 26
127693: DOUBLE
127694: EQUAL
127695: IFTRUE 127699
127697: GO 127710
127699: POP
// bc_type := b_bunker ; 27 :
127700: LD_ADDR_OWVAR 42
127704: PUSH
127705: LD_INT 32
127707: ST_TO_ADDR
127708: GO 127863
127710: LD_INT 27
127712: DOUBLE
127713: EQUAL
127714: IFTRUE 127718
127716: GO 127729
127718: POP
// bc_type := b_turret ; 28 :
127719: LD_ADDR_OWVAR 42
127723: PUSH
127724: LD_INT 33
127726: ST_TO_ADDR
127727: GO 127863
127729: LD_INT 28
127731: DOUBLE
127732: EQUAL
127733: IFTRUE 127737
127735: GO 127748
127737: POP
// bc_type := b_armoury ; 29 :
127738: LD_ADDR_OWVAR 42
127742: PUSH
127743: LD_INT 4
127745: ST_TO_ADDR
127746: GO 127863
127748: LD_INT 29
127750: DOUBLE
127751: EQUAL
127752: IFTRUE 127756
127754: GO 127767
127756: POP
// bc_type := b_barracks ; 30 :
127757: LD_ADDR_OWVAR 42
127761: PUSH
127762: LD_INT 5
127764: ST_TO_ADDR
127765: GO 127863
127767: LD_INT 30
127769: DOUBLE
127770: EQUAL
127771: IFTRUE 127775
127773: GO 127786
127775: POP
// bc_type := b_solar_power ; 31 :
127776: LD_ADDR_OWVAR 42
127780: PUSH
127781: LD_INT 27
127783: ST_TO_ADDR
127784: GO 127863
127786: LD_INT 31
127788: DOUBLE
127789: EQUAL
127790: IFTRUE 127794
127792: GO 127805
127794: POP
// bc_type := b_oil_power ; 32 :
127795: LD_ADDR_OWVAR 42
127799: PUSH
127800: LD_INT 26
127802: ST_TO_ADDR
127803: GO 127863
127805: LD_INT 32
127807: DOUBLE
127808: EQUAL
127809: IFTRUE 127813
127811: GO 127824
127813: POP
// bc_type := b_siberite_power ; 33 :
127814: LD_ADDR_OWVAR 42
127818: PUSH
127819: LD_INT 28
127821: ST_TO_ADDR
127822: GO 127863
127824: LD_INT 33
127826: DOUBLE
127827: EQUAL
127828: IFTRUE 127832
127830: GO 127843
127832: POP
// bc_type := b_oil_mine ; 34 :
127833: LD_ADDR_OWVAR 42
127837: PUSH
127838: LD_INT 29
127840: ST_TO_ADDR
127841: GO 127863
127843: LD_INT 34
127845: DOUBLE
127846: EQUAL
127847: IFTRUE 127851
127849: GO 127862
127851: POP
// bc_type := b_siberite_mine ; end ;
127852: LD_ADDR_OWVAR 42
127856: PUSH
127857: LD_INT 30
127859: ST_TO_ADDR
127860: GO 127863
127862: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
127863: LD_ADDR_VAR 0 8
127867: PUSH
127868: LD_VAR 0 5
127872: PPUSH
127873: LD_VAR 0 6
127877: PPUSH
127878: LD_VAR 0 3
127882: PPUSH
127883: CALL_OW 47
127887: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
127888: LD_OWVAR 42
127892: PUSH
127893: LD_INT 32
127895: PUSH
127896: LD_INT 33
127898: PUSH
127899: EMPTY
127900: LIST
127901: LIST
127902: IN
127903: IFFALSE 127919
// PlaceWeaponTurret ( b , weapon ) ;
127905: LD_VAR 0 8
127909: PPUSH
127910: LD_VAR 0 4
127914: PPUSH
127915: CALL_OW 431
// end ;
127919: LD_VAR 0 7
127923: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
127924: LD_INT 0
127926: PPUSH
127927: PPUSH
127928: PPUSH
127929: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
127930: LD_ADDR_VAR 0 4
127934: PUSH
127935: LD_INT 22
127937: PUSH
127938: LD_OWVAR 2
127942: PUSH
127943: EMPTY
127944: LIST
127945: LIST
127946: PUSH
127947: LD_INT 2
127949: PUSH
127950: LD_INT 30
127952: PUSH
127953: LD_INT 0
127955: PUSH
127956: EMPTY
127957: LIST
127958: LIST
127959: PUSH
127960: LD_INT 30
127962: PUSH
127963: LD_INT 1
127965: PUSH
127966: EMPTY
127967: LIST
127968: LIST
127969: PUSH
127970: EMPTY
127971: LIST
127972: LIST
127973: LIST
127974: PUSH
127975: EMPTY
127976: LIST
127977: LIST
127978: PPUSH
127979: CALL_OW 69
127983: ST_TO_ADDR
// if not tmp then
127984: LD_VAR 0 4
127988: NOT
127989: IFFALSE 127993
// exit ;
127991: GO 128052
// for i in tmp do
127993: LD_ADDR_VAR 0 2
127997: PUSH
127998: LD_VAR 0 4
128002: PUSH
128003: FOR_IN
128004: IFFALSE 128050
// for j = 1 to 3 do
128006: LD_ADDR_VAR 0 3
128010: PUSH
128011: DOUBLE
128012: LD_INT 1
128014: DEC
128015: ST_TO_ADDR
128016: LD_INT 3
128018: PUSH
128019: FOR_TO
128020: IFFALSE 128046
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
128022: LD_VAR 0 2
128026: PPUSH
128027: CALL_OW 274
128031: PPUSH
128032: LD_VAR 0 3
128036: PPUSH
128037: LD_INT 99999
128039: PPUSH
128040: CALL_OW 277
128044: GO 128019
128046: POP
128047: POP
128048: GO 128003
128050: POP
128051: POP
// end ;
128052: LD_VAR 0 1
128056: RET
// export function hHackSetLevel10 ; var i , j ; begin
128057: LD_INT 0
128059: PPUSH
128060: PPUSH
128061: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128062: LD_ADDR_VAR 0 2
128066: PUSH
128067: LD_INT 21
128069: PUSH
128070: LD_INT 1
128072: PUSH
128073: EMPTY
128074: LIST
128075: LIST
128076: PPUSH
128077: CALL_OW 69
128081: PUSH
128082: FOR_IN
128083: IFFALSE 128135
// if IsSelected ( i ) then
128085: LD_VAR 0 2
128089: PPUSH
128090: CALL_OW 306
128094: IFFALSE 128133
// begin for j := 1 to 4 do
128096: LD_ADDR_VAR 0 3
128100: PUSH
128101: DOUBLE
128102: LD_INT 1
128104: DEC
128105: ST_TO_ADDR
128106: LD_INT 4
128108: PUSH
128109: FOR_TO
128110: IFFALSE 128131
// SetSkill ( i , j , 10 ) ;
128112: LD_VAR 0 2
128116: PPUSH
128117: LD_VAR 0 3
128121: PPUSH
128122: LD_INT 10
128124: PPUSH
128125: CALL_OW 237
128129: GO 128109
128131: POP
128132: POP
// end ;
128133: GO 128082
128135: POP
128136: POP
// end ;
128137: LD_VAR 0 1
128141: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
128142: LD_INT 0
128144: PPUSH
128145: PPUSH
128146: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
128147: LD_ADDR_VAR 0 2
128151: PUSH
128152: LD_INT 22
128154: PUSH
128155: LD_OWVAR 2
128159: PUSH
128160: EMPTY
128161: LIST
128162: LIST
128163: PUSH
128164: LD_INT 21
128166: PUSH
128167: LD_INT 1
128169: PUSH
128170: EMPTY
128171: LIST
128172: LIST
128173: PUSH
128174: EMPTY
128175: LIST
128176: LIST
128177: PPUSH
128178: CALL_OW 69
128182: PUSH
128183: FOR_IN
128184: IFFALSE 128225
// begin for j := 1 to 4 do
128186: LD_ADDR_VAR 0 3
128190: PUSH
128191: DOUBLE
128192: LD_INT 1
128194: DEC
128195: ST_TO_ADDR
128196: LD_INT 4
128198: PUSH
128199: FOR_TO
128200: IFFALSE 128221
// SetSkill ( i , j , 10 ) ;
128202: LD_VAR 0 2
128206: PPUSH
128207: LD_VAR 0 3
128211: PPUSH
128212: LD_INT 10
128214: PPUSH
128215: CALL_OW 237
128219: GO 128199
128221: POP
128222: POP
// end ;
128223: GO 128183
128225: POP
128226: POP
// end ;
128227: LD_VAR 0 1
128231: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
128232: LD_INT 0
128234: PPUSH
// uc_side := your_side ;
128235: LD_ADDR_OWVAR 20
128239: PUSH
128240: LD_OWVAR 2
128244: ST_TO_ADDR
// uc_nation := nation ;
128245: LD_ADDR_OWVAR 21
128249: PUSH
128250: LD_VAR 0 1
128254: ST_TO_ADDR
// InitHc ;
128255: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
128259: LD_INT 0
128261: PPUSH
128262: LD_VAR 0 2
128266: PPUSH
128267: LD_VAR 0 3
128271: PPUSH
128272: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
128276: LD_VAR 0 4
128280: PPUSH
128281: LD_VAR 0 5
128285: PPUSH
128286: CALL_OW 428
128290: PUSH
128291: LD_INT 0
128293: EQUAL
128294: IFFALSE 128318
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
128296: CALL_OW 44
128300: PPUSH
128301: LD_VAR 0 4
128305: PPUSH
128306: LD_VAR 0 5
128310: PPUSH
128311: LD_INT 1
128313: PPUSH
128314: CALL_OW 48
// end ;
128318: LD_VAR 0 6
128322: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
128323: LD_INT 0
128325: PPUSH
128326: PPUSH
// uc_side := your_side ;
128327: LD_ADDR_OWVAR 20
128331: PUSH
128332: LD_OWVAR 2
128336: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
128337: LD_VAR 0 1
128341: PUSH
128342: LD_INT 1
128344: PUSH
128345: LD_INT 2
128347: PUSH
128348: LD_INT 3
128350: PUSH
128351: LD_INT 4
128353: PUSH
128354: LD_INT 5
128356: PUSH
128357: EMPTY
128358: LIST
128359: LIST
128360: LIST
128361: LIST
128362: LIST
128363: IN
128364: IFFALSE 128376
// uc_nation := nation_american else
128366: LD_ADDR_OWVAR 21
128370: PUSH
128371: LD_INT 1
128373: ST_TO_ADDR
128374: GO 128419
// if chassis in [ 11 , 12 , 13 , 14 ] then
128376: LD_VAR 0 1
128380: PUSH
128381: LD_INT 11
128383: PUSH
128384: LD_INT 12
128386: PUSH
128387: LD_INT 13
128389: PUSH
128390: LD_INT 14
128392: PUSH
128393: EMPTY
128394: LIST
128395: LIST
128396: LIST
128397: LIST
128398: IN
128399: IFFALSE 128411
// uc_nation := nation_arabian else
128401: LD_ADDR_OWVAR 21
128405: PUSH
128406: LD_INT 2
128408: ST_TO_ADDR
128409: GO 128419
// uc_nation := nation_russian ;
128411: LD_ADDR_OWVAR 21
128415: PUSH
128416: LD_INT 3
128418: ST_TO_ADDR
// vc_chassis := chassis ;
128419: LD_ADDR_OWVAR 37
128423: PUSH
128424: LD_VAR 0 1
128428: ST_TO_ADDR
// vc_engine := engine ;
128429: LD_ADDR_OWVAR 39
128433: PUSH
128434: LD_VAR 0 2
128438: ST_TO_ADDR
// vc_control := control ;
128439: LD_ADDR_OWVAR 38
128443: PUSH
128444: LD_VAR 0 3
128448: ST_TO_ADDR
// vc_weapon := weapon ;
128449: LD_ADDR_OWVAR 40
128453: PUSH
128454: LD_VAR 0 4
128458: ST_TO_ADDR
// un := CreateVehicle ;
128459: LD_ADDR_VAR 0 8
128463: PUSH
128464: CALL_OW 45
128468: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
128469: LD_VAR 0 8
128473: PPUSH
128474: LD_INT 0
128476: PPUSH
128477: LD_INT 5
128479: PPUSH
128480: CALL_OW 12
128484: PPUSH
128485: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
128489: LD_VAR 0 8
128493: PPUSH
128494: LD_VAR 0 5
128498: PPUSH
128499: LD_VAR 0 6
128503: PPUSH
128504: LD_INT 1
128506: PPUSH
128507: CALL_OW 48
// end ;
128511: LD_VAR 0 7
128515: RET
// export hInvincible ; every 1 do
128516: GO 128518
128518: DISABLE
// hInvincible := [ ] ;
128519: LD_ADDR_EXP 205
128523: PUSH
128524: EMPTY
128525: ST_TO_ADDR
128526: END
// every 10 do var i ;
128527: GO 128529
128529: DISABLE
128530: LD_INT 0
128532: PPUSH
// begin enable ;
128533: ENABLE
// if not hInvincible then
128534: LD_EXP 205
128538: NOT
128539: IFFALSE 128543
// exit ;
128541: GO 128587
// for i in hInvincible do
128543: LD_ADDR_VAR 0 1
128547: PUSH
128548: LD_EXP 205
128552: PUSH
128553: FOR_IN
128554: IFFALSE 128585
// if GetLives ( i ) < 1000 then
128556: LD_VAR 0 1
128560: PPUSH
128561: CALL_OW 256
128565: PUSH
128566: LD_INT 1000
128568: LESS
128569: IFFALSE 128583
// SetLives ( i , 1000 ) ;
128571: LD_VAR 0 1
128575: PPUSH
128576: LD_INT 1000
128578: PPUSH
128579: CALL_OW 234
128583: GO 128553
128585: POP
128586: POP
// end ;
128587: PPOPN 1
128589: END
// export function hHackInvincible ; var i ; begin
128590: LD_INT 0
128592: PPUSH
128593: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
128594: LD_ADDR_VAR 0 2
128598: PUSH
128599: LD_INT 2
128601: PUSH
128602: LD_INT 21
128604: PUSH
128605: LD_INT 1
128607: PUSH
128608: EMPTY
128609: LIST
128610: LIST
128611: PUSH
128612: LD_INT 21
128614: PUSH
128615: LD_INT 2
128617: PUSH
128618: EMPTY
128619: LIST
128620: LIST
128621: PUSH
128622: EMPTY
128623: LIST
128624: LIST
128625: LIST
128626: PPUSH
128627: CALL_OW 69
128631: PUSH
128632: FOR_IN
128633: IFFALSE 128694
// if IsSelected ( i ) then
128635: LD_VAR 0 2
128639: PPUSH
128640: CALL_OW 306
128644: IFFALSE 128692
// begin if i in hInvincible then
128646: LD_VAR 0 2
128650: PUSH
128651: LD_EXP 205
128655: IN
128656: IFFALSE 128676
// hInvincible := hInvincible diff i else
128658: LD_ADDR_EXP 205
128662: PUSH
128663: LD_EXP 205
128667: PUSH
128668: LD_VAR 0 2
128672: DIFF
128673: ST_TO_ADDR
128674: GO 128692
// hInvincible := hInvincible union i ;
128676: LD_ADDR_EXP 205
128680: PUSH
128681: LD_EXP 205
128685: PUSH
128686: LD_VAR 0 2
128690: UNION
128691: ST_TO_ADDR
// end ;
128692: GO 128632
128694: POP
128695: POP
// end ;
128696: LD_VAR 0 1
128700: RET
// export function hHackInvisible ; var i , j ; begin
128701: LD_INT 0
128703: PPUSH
128704: PPUSH
128705: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128706: LD_ADDR_VAR 0 2
128710: PUSH
128711: LD_INT 21
128713: PUSH
128714: LD_INT 1
128716: PUSH
128717: EMPTY
128718: LIST
128719: LIST
128720: PPUSH
128721: CALL_OW 69
128725: PUSH
128726: FOR_IN
128727: IFFALSE 128751
// if IsSelected ( i ) then
128729: LD_VAR 0 2
128733: PPUSH
128734: CALL_OW 306
128738: IFFALSE 128749
// ComForceInvisible ( i ) ;
128740: LD_VAR 0 2
128744: PPUSH
128745: CALL_OW 496
128749: GO 128726
128751: POP
128752: POP
// end ;
128753: LD_VAR 0 1
128757: RET
// export function hHackChangeYourSide ; begin
128758: LD_INT 0
128760: PPUSH
// if your_side = 8 then
128761: LD_OWVAR 2
128765: PUSH
128766: LD_INT 8
128768: EQUAL
128769: IFFALSE 128781
// your_side := 0 else
128771: LD_ADDR_OWVAR 2
128775: PUSH
128776: LD_INT 0
128778: ST_TO_ADDR
128779: GO 128795
// your_side := your_side + 1 ;
128781: LD_ADDR_OWVAR 2
128785: PUSH
128786: LD_OWVAR 2
128790: PUSH
128791: LD_INT 1
128793: PLUS
128794: ST_TO_ADDR
// end ;
128795: LD_VAR 0 1
128799: RET
// export function hHackChangeUnitSide ; var i , j ; begin
128800: LD_INT 0
128802: PPUSH
128803: PPUSH
128804: PPUSH
// for i in all_units do
128805: LD_ADDR_VAR 0 2
128809: PUSH
128810: LD_OWVAR 3
128814: PUSH
128815: FOR_IN
128816: IFFALSE 128894
// if IsSelected ( i ) then
128818: LD_VAR 0 2
128822: PPUSH
128823: CALL_OW 306
128827: IFFALSE 128892
// begin j := GetSide ( i ) ;
128829: LD_ADDR_VAR 0 3
128833: PUSH
128834: LD_VAR 0 2
128838: PPUSH
128839: CALL_OW 255
128843: ST_TO_ADDR
// if j = 8 then
128844: LD_VAR 0 3
128848: PUSH
128849: LD_INT 8
128851: EQUAL
128852: IFFALSE 128864
// j := 0 else
128854: LD_ADDR_VAR 0 3
128858: PUSH
128859: LD_INT 0
128861: ST_TO_ADDR
128862: GO 128878
// j := j + 1 ;
128864: LD_ADDR_VAR 0 3
128868: PUSH
128869: LD_VAR 0 3
128873: PUSH
128874: LD_INT 1
128876: PLUS
128877: ST_TO_ADDR
// SetSide ( i , j ) ;
128878: LD_VAR 0 2
128882: PPUSH
128883: LD_VAR 0 3
128887: PPUSH
128888: CALL_OW 235
// end ;
128892: GO 128815
128894: POP
128895: POP
// end ;
128896: LD_VAR 0 1
128900: RET
// export function hHackFog ; begin
128901: LD_INT 0
128903: PPUSH
// FogOff ( true ) ;
128904: LD_INT 1
128906: PPUSH
128907: CALL_OW 344
// end ;
128911: LD_VAR 0 1
128915: RET
// export function hHackTeleport ( unit , x , y ) ; begin
128916: LD_INT 0
128918: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
128919: LD_VAR 0 1
128923: PPUSH
128924: LD_VAR 0 2
128928: PPUSH
128929: LD_VAR 0 3
128933: PPUSH
128934: LD_INT 1
128936: PPUSH
128937: LD_INT 1
128939: PPUSH
128940: CALL_OW 483
// CenterOnXY ( x , y ) ;
128944: LD_VAR 0 2
128948: PPUSH
128949: LD_VAR 0 3
128953: PPUSH
128954: CALL_OW 84
// end ;
128958: LD_VAR 0 4
128962: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
128963: LD_INT 0
128965: PPUSH
128966: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
128967: LD_VAR 0 1
128971: NOT
128972: IFTRUE 128991
128974: PUSH
128975: LD_VAR 0 2
128979: PPUSH
128980: LD_VAR 0 3
128984: PPUSH
128985: CALL_OW 488
128989: NOT
128990: OR
128991: IFTRUE 129026
128993: PUSH
128994: LD_VAR 0 1
128998: PPUSH
128999: CALL_OW 266
129003: PUSH
129004: LD_INT 3
129006: NONEQUAL
129007: IFFALSE 129025
129009: PUSH
129010: LD_VAR 0 1
129014: PPUSH
129015: CALL_OW 247
129019: PUSH
129020: LD_INT 1
129022: EQUAL
129023: NOT
129024: AND
129025: OR
129026: IFFALSE 129030
// exit ;
129028: GO 129312
// if GetType ( factory ) = unit_human then
129030: LD_VAR 0 1
129034: PPUSH
129035: CALL_OW 247
129039: PUSH
129040: LD_INT 1
129042: EQUAL
129043: IFFALSE 129060
// factory := IsInUnit ( factory ) ;
129045: LD_ADDR_VAR 0 1
129049: PUSH
129050: LD_VAR 0 1
129054: PPUSH
129055: CALL_OW 310
129059: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
129060: LD_VAR 0 1
129064: PPUSH
129065: CALL_OW 266
129069: PUSH
129070: LD_INT 3
129072: NONEQUAL
129073: IFFALSE 129077
// exit ;
129075: GO 129312
// for i := 1 to Count ( factoryWaypoints ) do
129077: LD_ADDR_VAR 0 5
129081: PUSH
129082: DOUBLE
129083: LD_INT 1
129085: DEC
129086: ST_TO_ADDR
129087: LD_EXP 206
129091: PPUSH
129092: CALL 73139 0 1
129096: PUSH
129097: FOR_TO
129098: IFFALSE 129260
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
129100: LD_VAR 0 2
129104: PPUSH
129105: LD_VAR 0 3
129109: PPUSH
129110: CALL_OW 428
129114: PUSH
129115: LD_EXP 206
129119: PUSH
129120: LD_VAR 0 5
129124: ARRAY
129125: PUSH
129126: LD_INT 2
129128: ARRAY
129129: EQUAL
129130: IFFALSE 129162
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129132: LD_ADDR_EXP 206
129136: PUSH
129137: LD_EXP 206
129141: PPUSH
129142: LD_VAR 0 5
129146: PPUSH
129147: CALL_OW 3
129151: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129152: CALL 129317 0 0
// exit ;
129156: POP
129157: POP
129158: GO 129312
// end else
129160: GO 129258
// if factory = factoryWaypoints [ i ] [ 2 ] then
129162: LD_VAR 0 1
129166: PUSH
129167: LD_EXP 206
129171: PUSH
129172: LD_VAR 0 5
129176: ARRAY
129177: PUSH
129178: LD_INT 2
129180: ARRAY
129181: EQUAL
129182: IFFALSE 129258
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129184: LD_ADDR_EXP 206
129188: PUSH
129189: LD_EXP 206
129193: PPUSH
129194: LD_VAR 0 5
129198: PPUSH
129199: CALL_OW 3
129203: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129204: LD_ADDR_EXP 206
129208: PUSH
129209: LD_EXP 206
129213: PPUSH
129214: LD_VAR 0 1
129218: PPUSH
129219: CALL_OW 255
129223: PUSH
129224: LD_VAR 0 1
129228: PUSH
129229: LD_VAR 0 2
129233: PUSH
129234: LD_VAR 0 3
129238: PUSH
129239: EMPTY
129240: LIST
129241: LIST
129242: LIST
129243: LIST
129244: PPUSH
129245: CALL 109071 0 2
129249: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129250: CALL 129317 0 0
// exit ;
129254: POP
129255: POP
129256: GO 129312
// end ; end ;
129258: GO 129097
129260: POP
129261: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129262: LD_ADDR_EXP 206
129266: PUSH
129267: LD_EXP 206
129271: PPUSH
129272: LD_VAR 0 1
129276: PPUSH
129277: CALL_OW 255
129281: PUSH
129282: LD_VAR 0 1
129286: PUSH
129287: LD_VAR 0 2
129291: PUSH
129292: LD_VAR 0 3
129296: PUSH
129297: EMPTY
129298: LIST
129299: LIST
129300: LIST
129301: LIST
129302: PPUSH
129303: CALL 109071 0 2
129307: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129308: CALL 129317 0 0
// end ;
129312: LD_VAR 0 4
129316: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
129317: LD_INT 0
129319: PPUSH
129320: PPUSH
129321: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
129322: LD_STRING resetFactoryWaypoint();
129324: PPUSH
129325: CALL_OW 559
// if factoryWaypoints then
129329: LD_EXP 206
129333: IFFALSE 129454
// begin list := factoryWaypoints ;
129335: LD_ADDR_VAR 0 3
129339: PUSH
129340: LD_EXP 206
129344: ST_TO_ADDR
// for i := 1 to list do
129345: LD_ADDR_VAR 0 2
129349: PUSH
129350: DOUBLE
129351: LD_INT 1
129353: DEC
129354: ST_TO_ADDR
129355: LD_VAR 0 3
129359: PUSH
129360: FOR_TO
129361: IFFALSE 129452
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129363: LD_STRING setFactoryWaypointXY(
129365: PUSH
129366: LD_VAR 0 3
129370: PUSH
129371: LD_VAR 0 2
129375: ARRAY
129376: PUSH
129377: LD_INT 1
129379: ARRAY
129380: STR
129381: PUSH
129382: LD_STRING ,
129384: STR
129385: PUSH
129386: LD_VAR 0 3
129390: PUSH
129391: LD_VAR 0 2
129395: ARRAY
129396: PUSH
129397: LD_INT 2
129399: ARRAY
129400: STR
129401: PUSH
129402: LD_STRING ,
129404: STR
129405: PUSH
129406: LD_VAR 0 3
129410: PUSH
129411: LD_VAR 0 2
129415: ARRAY
129416: PUSH
129417: LD_INT 3
129419: ARRAY
129420: STR
129421: PUSH
129422: LD_STRING ,
129424: STR
129425: PUSH
129426: LD_VAR 0 3
129430: PUSH
129431: LD_VAR 0 2
129435: ARRAY
129436: PUSH
129437: LD_INT 4
129439: ARRAY
129440: STR
129441: PUSH
129442: LD_STRING )
129444: STR
129445: PPUSH
129446: CALL_OW 559
129450: GO 129360
129452: POP
129453: POP
// end ; end ;
129454: LD_VAR 0 1
129458: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
129459: LD_INT 0
129461: PPUSH
// if HexInfo ( x , y ) = warehouse then
129462: LD_VAR 0 2
129466: PPUSH
129467: LD_VAR 0 3
129471: PPUSH
129472: CALL_OW 428
129476: PUSH
129477: LD_VAR 0 1
129481: EQUAL
129482: IFFALSE 129509
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
129484: LD_ADDR_EXP 208
129488: PUSH
129489: LD_EXP 208
129493: PPUSH
129494: LD_VAR 0 1
129498: PPUSH
129499: LD_INT 0
129501: PPUSH
129502: CALL_OW 1
129506: ST_TO_ADDR
129507: GO 129560
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
129509: LD_ADDR_EXP 208
129513: PUSH
129514: LD_EXP 208
129518: PPUSH
129519: LD_VAR 0 1
129523: PPUSH
129524: LD_VAR 0 1
129528: PPUSH
129529: CALL_OW 255
129533: PUSH
129534: LD_VAR 0 1
129538: PUSH
129539: LD_VAR 0 2
129543: PUSH
129544: LD_VAR 0 3
129548: PUSH
129549: EMPTY
129550: LIST
129551: LIST
129552: LIST
129553: LIST
129554: PPUSH
129555: CALL_OW 1
129559: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
129560: CALL 129569 0 0
// end ;
129564: LD_VAR 0 4
129568: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
129569: LD_INT 0
129571: PPUSH
129572: PPUSH
129573: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
129574: LD_STRING resetWarehouseGatheringPoints();
129576: PPUSH
129577: CALL_OW 559
// if warehouseGatheringPoints then
129581: LD_EXP 208
129585: IFFALSE 129711
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
129587: LD_ADDR_VAR 0 3
129591: PUSH
129592: LD_EXP 208
129596: PPUSH
129597: CALL 113005 0 1
129601: ST_TO_ADDR
// for i := 1 to list do
129602: LD_ADDR_VAR 0 2
129606: PUSH
129607: DOUBLE
129608: LD_INT 1
129610: DEC
129611: ST_TO_ADDR
129612: LD_VAR 0 3
129616: PUSH
129617: FOR_TO
129618: IFFALSE 129709
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129620: LD_STRING setWarehouseGatheringPointXY(
129622: PUSH
129623: LD_VAR 0 3
129627: PUSH
129628: LD_VAR 0 2
129632: ARRAY
129633: PUSH
129634: LD_INT 1
129636: ARRAY
129637: STR
129638: PUSH
129639: LD_STRING ,
129641: STR
129642: PUSH
129643: LD_VAR 0 3
129647: PUSH
129648: LD_VAR 0 2
129652: ARRAY
129653: PUSH
129654: LD_INT 2
129656: ARRAY
129657: STR
129658: PUSH
129659: LD_STRING ,
129661: STR
129662: PUSH
129663: LD_VAR 0 3
129667: PUSH
129668: LD_VAR 0 2
129672: ARRAY
129673: PUSH
129674: LD_INT 3
129676: ARRAY
129677: STR
129678: PUSH
129679: LD_STRING ,
129681: STR
129682: PUSH
129683: LD_VAR 0 3
129687: PUSH
129688: LD_VAR 0 2
129692: ARRAY
129693: PUSH
129694: LD_INT 4
129696: ARRAY
129697: STR
129698: PUSH
129699: LD_STRING )
129701: STR
129702: PPUSH
129703: CALL_OW 559
129707: GO 129617
129709: POP
129710: POP
// end ; end ;
129711: LD_VAR 0 1
129715: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
129716: LD_EXP 208
129720: IFFALSE 130415
129722: GO 129724
129724: DISABLE
129725: LD_INT 0
129727: PPUSH
129728: PPUSH
129729: PPUSH
129730: PPUSH
129731: PPUSH
129732: PPUSH
129733: PPUSH
129734: PPUSH
129735: PPUSH
// begin enable ;
129736: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
129737: LD_ADDR_VAR 0 3
129741: PUSH
129742: LD_EXP 208
129746: PPUSH
129747: CALL 113005 0 1
129751: ST_TO_ADDR
// if not list then
129752: LD_VAR 0 3
129756: NOT
129757: IFFALSE 129761
// exit ;
129759: GO 130415
// for i := 1 to list do
129761: LD_ADDR_VAR 0 1
129765: PUSH
129766: DOUBLE
129767: LD_INT 1
129769: DEC
129770: ST_TO_ADDR
129771: LD_VAR 0 3
129775: PUSH
129776: FOR_TO
129777: IFFALSE 130413
// begin depot := list [ i ] [ 2 ] ;
129779: LD_ADDR_VAR 0 8
129783: PUSH
129784: LD_VAR 0 3
129788: PUSH
129789: LD_VAR 0 1
129793: ARRAY
129794: PUSH
129795: LD_INT 2
129797: ARRAY
129798: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
129799: LD_ADDR_VAR 0 5
129803: PUSH
129804: LD_VAR 0 3
129808: PUSH
129809: LD_VAR 0 1
129813: ARRAY
129814: PUSH
129815: LD_INT 1
129817: ARRAY
129818: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
129819: LD_VAR 0 8
129823: PPUSH
129824: CALL_OW 301
129828: IFTRUE 129847
129830: PUSH
129831: LD_VAR 0 5
129835: PUSH
129836: LD_VAR 0 8
129840: PPUSH
129841: CALL_OW 255
129845: NONEQUAL
129846: OR
129847: IFFALSE 129876
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
129849: LD_ADDR_EXP 208
129853: PUSH
129854: LD_EXP 208
129858: PPUSH
129859: LD_VAR 0 8
129863: PPUSH
129864: LD_INT 0
129866: PPUSH
129867: CALL_OW 1
129871: ST_TO_ADDR
// exit ;
129872: POP
129873: POP
129874: GO 130415
// end ; x := list [ i ] [ 3 ] ;
129876: LD_ADDR_VAR 0 6
129880: PUSH
129881: LD_VAR 0 3
129885: PUSH
129886: LD_VAR 0 1
129890: ARRAY
129891: PUSH
129892: LD_INT 3
129894: ARRAY
129895: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
129896: LD_ADDR_VAR 0 7
129900: PUSH
129901: LD_VAR 0 3
129905: PUSH
129906: LD_VAR 0 1
129910: ARRAY
129911: PUSH
129912: LD_INT 4
129914: ARRAY
129915: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
129916: LD_ADDR_VAR 0 9
129920: PUSH
129921: LD_VAR 0 6
129925: PPUSH
129926: LD_VAR 0 7
129930: PPUSH
129931: LD_INT 16
129933: PPUSH
129934: CALL 111579 0 3
129938: ST_TO_ADDR
// if not cratesNearbyPoint then
129939: LD_VAR 0 9
129943: NOT
129944: IFFALSE 129950
// exit ;
129946: POP
129947: POP
129948: GO 130415
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
129950: LD_ADDR_VAR 0 4
129954: PUSH
129955: LD_INT 22
129957: PUSH
129958: LD_VAR 0 5
129962: PUSH
129963: EMPTY
129964: LIST
129965: LIST
129966: PUSH
129967: LD_INT 3
129969: PUSH
129970: LD_INT 60
129972: PUSH
129973: EMPTY
129974: LIST
129975: PUSH
129976: EMPTY
129977: LIST
129978: LIST
129979: PUSH
129980: LD_INT 91
129982: PUSH
129983: LD_VAR 0 8
129987: PUSH
129988: LD_INT 6
129990: PUSH
129991: EMPTY
129992: LIST
129993: LIST
129994: LIST
129995: PUSH
129996: LD_INT 2
129998: PUSH
129999: LD_INT 25
130001: PUSH
130002: LD_INT 2
130004: PUSH
130005: EMPTY
130006: LIST
130007: LIST
130008: PUSH
130009: LD_INT 25
130011: PUSH
130012: LD_INT 16
130014: PUSH
130015: EMPTY
130016: LIST
130017: LIST
130018: PUSH
130019: EMPTY
130020: LIST
130021: LIST
130022: LIST
130023: PUSH
130024: EMPTY
130025: LIST
130026: LIST
130027: LIST
130028: LIST
130029: PPUSH
130030: CALL_OW 69
130034: PUSH
130035: LD_VAR 0 8
130039: PPUSH
130040: CALL_OW 313
130044: PPUSH
130045: LD_INT 3
130047: PUSH
130048: LD_INT 60
130050: PUSH
130051: EMPTY
130052: LIST
130053: PUSH
130054: EMPTY
130055: LIST
130056: LIST
130057: PUSH
130058: LD_INT 2
130060: PUSH
130061: LD_INT 25
130063: PUSH
130064: LD_INT 2
130066: PUSH
130067: EMPTY
130068: LIST
130069: LIST
130070: PUSH
130071: LD_INT 25
130073: PUSH
130074: LD_INT 16
130076: PUSH
130077: EMPTY
130078: LIST
130079: LIST
130080: PUSH
130081: EMPTY
130082: LIST
130083: LIST
130084: LIST
130085: PUSH
130086: EMPTY
130087: LIST
130088: LIST
130089: PPUSH
130090: CALL_OW 72
130094: UNION
130095: ST_TO_ADDR
// if tmp then
130096: LD_VAR 0 4
130100: IFFALSE 130180
// begin tmp := ShrinkArray ( tmp , 3 ) ;
130102: LD_ADDR_VAR 0 4
130106: PUSH
130107: LD_VAR 0 4
130111: PPUSH
130112: LD_INT 3
130114: PPUSH
130115: CALL 109386 0 2
130119: ST_TO_ADDR
// for j in tmp do
130120: LD_ADDR_VAR 0 2
130124: PUSH
130125: LD_VAR 0 4
130129: PUSH
130130: FOR_IN
130131: IFFALSE 130174
// begin if IsInUnit ( j ) then
130133: LD_VAR 0 2
130137: PPUSH
130138: CALL_OW 310
130142: IFFALSE 130153
// ComExit ( j ) ;
130144: LD_VAR 0 2
130148: PPUSH
130149: CALL 109469 0 1
// AddComCollect ( j , x , y ) ;
130153: LD_VAR 0 2
130157: PPUSH
130158: LD_VAR 0 6
130162: PPUSH
130163: LD_VAR 0 7
130167: PPUSH
130168: CALL_OW 177
// end ;
130172: GO 130130
130174: POP
130175: POP
// exit ;
130176: POP
130177: POP
130178: GO 130415
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
130180: LD_ADDR_VAR 0 4
130184: PUSH
130185: LD_INT 22
130187: PUSH
130188: LD_VAR 0 5
130192: PUSH
130193: EMPTY
130194: LIST
130195: LIST
130196: PUSH
130197: LD_INT 91
130199: PUSH
130200: LD_VAR 0 8
130204: PUSH
130205: LD_INT 8
130207: PUSH
130208: EMPTY
130209: LIST
130210: LIST
130211: LIST
130212: PUSH
130213: LD_INT 2
130215: PUSH
130216: LD_INT 34
130218: PUSH
130219: LD_INT 12
130221: PUSH
130222: EMPTY
130223: LIST
130224: LIST
130225: PUSH
130226: LD_INT 34
130228: PUSH
130229: LD_INT 51
130231: PUSH
130232: EMPTY
130233: LIST
130234: LIST
130235: PUSH
130236: LD_INT 34
130238: PUSH
130239: LD_INT 32
130241: PUSH
130242: EMPTY
130243: LIST
130244: LIST
130245: PUSH
130246: LD_INT 34
130248: PUSH
130249: LD_INT 89
130251: PUSH
130252: EMPTY
130253: LIST
130254: LIST
130255: PUSH
130256: EMPTY
130257: LIST
130258: LIST
130259: LIST
130260: LIST
130261: LIST
130262: PUSH
130263: EMPTY
130264: LIST
130265: LIST
130266: LIST
130267: PPUSH
130268: CALL_OW 69
130272: ST_TO_ADDR
// if tmp then
130273: LD_VAR 0 4
130277: IFFALSE 130411
// begin for j in tmp do
130279: LD_ADDR_VAR 0 2
130283: PUSH
130284: LD_VAR 0 4
130288: PUSH
130289: FOR_IN
130290: IFFALSE 130409
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
130292: LD_VAR 0 2
130296: PPUSH
130297: CALL_OW 262
130301: PUSH
130302: LD_INT 3
130304: EQUAL
130305: IFTRUE 130322
130307: PUSH
130308: LD_VAR 0 2
130312: PPUSH
130313: CALL_OW 261
130317: PUSH
130318: LD_INT 20
130320: GREATER
130321: OR
130322: IFFALSE 130336
130324: PUSH
130325: LD_VAR 0 2
130329: PPUSH
130330: CALL_OW 314
130334: NOT
130335: AND
130336: IFFALSE 130366
130338: PUSH
130339: LD_VAR 0 2
130343: PPUSH
130344: CALL_OW 263
130348: PUSH
130349: LD_INT 1
130351: NONEQUAL
130352: IFTRUE 130365
130354: PUSH
130355: LD_VAR 0 2
130359: PPUSH
130360: CALL_OW 311
130364: OR
130365: AND
130366: IFFALSE 130407
// begin ComCollect ( j , x , y ) ;
130368: LD_VAR 0 2
130372: PPUSH
130373: LD_VAR 0 6
130377: PPUSH
130378: LD_VAR 0 7
130382: PPUSH
130383: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
130387: LD_VAR 0 2
130391: PPUSH
130392: LD_VAR 0 8
130396: PPUSH
130397: CALL_OW 172
// exit ;
130401: POP
130402: POP
130403: POP
130404: POP
130405: GO 130415
// end ;
130407: GO 130289
130409: POP
130410: POP
// end ; end ;
130411: GO 129776
130413: POP
130414: POP
// end ; end_of_file
130415: PPOPN 9
130417: END
// export function SOS_UnitDestroyed ( un ) ; begin
130418: LD_INT 0
130420: PPUSH
// ComRadiation ( un ) ;
130421: LD_VAR 0 1
130425: PPUSH
130426: CALL 131507 0 1
// end ;
130430: LD_VAR 0 2
130434: RET
// export function SOS_UnitKamikazed ( un ) ; begin
130435: LD_INT 0
130437: PPUSH
// ComRadiation ( un ) ;
130438: LD_VAR 0 1
130442: PPUSH
130443: CALL 131507 0 1
// end ;
130447: LD_VAR 0 2
130451: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
130452: LD_INT 0
130454: PPUSH
// end ;
130455: LD_VAR 0 4
130459: RET
// export function SOS_Command ( cmd ) ; begin
130460: LD_INT 0
130462: PPUSH
// end ;
130463: LD_VAR 0 2
130467: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
130468: LD_INT 0
130470: PPUSH
// end ;
130471: LD_VAR 0 6
130475: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
130476: LD_INT 0
130478: PPUSH
130479: PPUSH
130480: PPUSH
130481: PPUSH
// if not vehicle or not factory then
130482: LD_VAR 0 1
130486: NOT
130487: IFTRUE 130496
130489: PUSH
130490: LD_VAR 0 2
130494: NOT
130495: OR
130496: IFFALSE 130500
// exit ;
130498: GO 131082
// if not factoryWaypoints then
130500: LD_EXP 206
130504: NOT
130505: IFFALSE 130509
// exit ;
130507: GO 131082
// for i := 1 to Count ( factoryWaypoints ) do
130509: LD_ADDR_VAR 0 4
130513: PUSH
130514: DOUBLE
130515: LD_INT 1
130517: DEC
130518: ST_TO_ADDR
130519: LD_EXP 206
130523: PPUSH
130524: CALL 73139 0 1
130528: PUSH
130529: FOR_TO
130530: IFFALSE 131080
// if factoryWaypoints [ i ] [ 2 ] = factory then
130532: LD_EXP 206
130536: PUSH
130537: LD_VAR 0 4
130541: ARRAY
130542: PUSH
130543: LD_INT 2
130545: ARRAY
130546: PUSH
130547: LD_VAR 0 2
130551: EQUAL
130552: IFFALSE 131078
// begin if GetControl ( vehicle ) = control_manual then
130554: LD_VAR 0 1
130558: PPUSH
130559: CALL_OW 263
130563: PUSH
130564: LD_INT 1
130566: EQUAL
130567: IFFALSE 130931
// begin driver := IsDrivenBy ( vehicle ) ;
130569: LD_ADDR_VAR 0 5
130573: PUSH
130574: LD_VAR 0 1
130578: PPUSH
130579: CALL_OW 311
130583: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
130584: LD_VAR 0 5
130588: PUSH
130589: LD_EXP 207
130593: IN
130594: IFTRUE 130608
130596: PUSH
130597: LD_VAR 0 1
130601: PUSH
130602: LD_EXP 207
130606: IN
130607: OR
130608: IFFALSE 130614
// exit ;
130610: POP
130611: POP
130612: GO 131082
// if not HasTask ( driver ) then
130614: LD_VAR 0 5
130618: PPUSH
130619: CALL_OW 314
130623: NOT
130624: IFFALSE 130929
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
130626: LD_ADDR_EXP 207
130630: PUSH
130631: LD_EXP 207
130635: PPUSH
130636: LD_VAR 0 5
130640: PPUSH
130641: CALL 109071 0 2
130645: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
130646: LD_ADDR_EXP 207
130650: PUSH
130651: LD_EXP 207
130655: PPUSH
130656: LD_VAR 0 1
130660: PPUSH
130661: CALL 109071 0 2
130665: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130666: LD_ADDR_VAR 0 6
130670: PUSH
130671: LD_EXP 206
130675: PUSH
130676: LD_VAR 0 4
130680: ARRAY
130681: PUSH
130682: LD_INT 3
130684: ARRAY
130685: PPUSH
130686: LD_EXP 206
130690: PUSH
130691: LD_VAR 0 4
130695: ARRAY
130696: PUSH
130697: LD_INT 4
130699: ARRAY
130700: PPUSH
130701: CALL_OW 428
130705: ST_TO_ADDR
// if hex then
130706: LD_VAR 0 6
130710: IFFALSE 130728
// ComMoveUnit ( driver , hex ) else
130712: LD_VAR 0 5
130716: PPUSH
130717: LD_VAR 0 6
130721: PPUSH
130722: CALL_OW 112
130726: GO 130812
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
130728: LD_VAR 0 1
130732: PPUSH
130733: LD_EXP 206
130737: PUSH
130738: LD_VAR 0 4
130742: ARRAY
130743: PUSH
130744: LD_INT 3
130746: ARRAY
130747: PPUSH
130748: LD_EXP 206
130752: PUSH
130753: LD_VAR 0 4
130757: ARRAY
130758: PUSH
130759: LD_INT 4
130761: ARRAY
130762: PPUSH
130763: CALL_OW 297
130767: PUSH
130768: LD_INT 0
130770: GREATER
130771: IFFALSE 130812
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130773: LD_VAR 0 5
130777: PPUSH
130778: LD_EXP 206
130782: PUSH
130783: LD_VAR 0 4
130787: ARRAY
130788: PUSH
130789: LD_INT 3
130791: ARRAY
130792: PPUSH
130793: LD_EXP 206
130797: PUSH
130798: LD_VAR 0 4
130802: ARRAY
130803: PUSH
130804: LD_INT 4
130806: ARRAY
130807: PPUSH
130808: CALL_OW 111
// AddComExitVehicle ( driver ) ;
130812: LD_VAR 0 5
130816: PPUSH
130817: CALL_OW 181
// if Multiplayer then
130821: LD_OWVAR 4
130825: IFFALSE 130874
// begin repeat wait ( 10 ) ;
130827: LD_INT 10
130829: PPUSH
130830: CALL_OW 67
// until not IsInUnit ( driver ) ;
130834: LD_VAR 0 5
130838: PPUSH
130839: CALL_OW 310
130843: NOT
130844: IFFALSE 130827
// if not HasTask ( driver ) then
130846: LD_VAR 0 5
130850: PPUSH
130851: CALL_OW 314
130855: NOT
130856: IFFALSE 130872
// ComEnterUnit ( driver , factory ) ;
130858: LD_VAR 0 5
130862: PPUSH
130863: LD_VAR 0 2
130867: PPUSH
130868: CALL_OW 120
// end else
130872: GO 130888
// AddComEnterUnit ( driver , factory ) ;
130874: LD_VAR 0 5
130878: PPUSH
130879: LD_VAR 0 2
130883: PPUSH
130884: CALL_OW 180
// wait ( 0 0$1 ) ;
130888: LD_INT 35
130890: PPUSH
130891: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
130895: LD_ADDR_EXP 207
130899: PUSH
130900: LD_EXP 207
130904: PUSH
130905: LD_VAR 0 5
130909: DIFF
130910: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
130911: LD_ADDR_EXP 207
130915: PUSH
130916: LD_EXP 207
130920: PUSH
130921: LD_VAR 0 1
130925: DIFF
130926: ST_TO_ADDR
// break ;
130927: GO 131080
// end ; end else
130929: GO 131078
// if GetControl ( vehicle ) = control_remote then
130931: LD_VAR 0 1
130935: PPUSH
130936: CALL_OW 263
130940: PUSH
130941: LD_INT 2
130943: EQUAL
130944: IFFALSE 131030
// begin wait ( 0 0$2 ) ;
130946: LD_INT 70
130948: PPUSH
130949: CALL_OW 67
// repeat wait ( 10 ) ;
130953: LD_INT 10
130955: PPUSH
130956: CALL_OW 67
// Connect ( vehicle ) ;
130960: LD_VAR 0 1
130964: PPUSH
130965: CALL 79383 0 1
// until IsControledBy ( vehicle ) ;
130969: LD_VAR 0 1
130973: PPUSH
130974: CALL_OW 312
130978: IFFALSE 130953
// wait ( 10 ) ;
130980: LD_INT 10
130982: PPUSH
130983: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130987: LD_VAR 0 1
130991: PPUSH
130992: LD_EXP 206
130996: PUSH
130997: LD_VAR 0 4
131001: ARRAY
131002: PUSH
131003: LD_INT 3
131005: ARRAY
131006: PPUSH
131007: LD_EXP 206
131011: PUSH
131012: LD_VAR 0 4
131016: ARRAY
131017: PUSH
131018: LD_INT 4
131020: ARRAY
131021: PPUSH
131022: CALL_OW 111
// break ;
131026: GO 131080
// end else
131028: GO 131078
// begin wait ( 0 0$3 ) ;
131030: LD_INT 105
131032: PPUSH
131033: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131037: LD_VAR 0 1
131041: PPUSH
131042: LD_EXP 206
131046: PUSH
131047: LD_VAR 0 4
131051: ARRAY
131052: PUSH
131053: LD_INT 3
131055: ARRAY
131056: PPUSH
131057: LD_EXP 206
131061: PUSH
131062: LD_VAR 0 4
131066: ARRAY
131067: PUSH
131068: LD_INT 4
131070: ARRAY
131071: PPUSH
131072: CALL_OW 111
// break ;
131076: GO 131080
// end ; end ;
131078: GO 130529
131080: POP
131081: POP
// end ;
131082: LD_VAR 0 3
131086: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
131087: LD_INT 0
131089: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
131090: LD_VAR 0 1
131094: PUSH
131095: LD_INT 250
131097: EQUAL
131098: IFFALSE 131115
131100: PUSH
131101: LD_VAR 0 2
131105: PPUSH
131106: CALL_OW 264
131110: PUSH
131111: LD_INT 81
131113: EQUAL
131114: AND
131115: IFFALSE 131136
// MinerPlaceMine ( unit , x , y ) ;
131117: LD_VAR 0 2
131121: PPUSH
131122: LD_VAR 0 4
131126: PPUSH
131127: LD_VAR 0 5
131131: PPUSH
131132: CALL 134268 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
131136: LD_VAR 0 1
131140: PUSH
131141: LD_INT 251
131143: EQUAL
131144: IFFALSE 131161
131146: PUSH
131147: LD_VAR 0 2
131151: PPUSH
131152: CALL_OW 264
131156: PUSH
131157: LD_INT 81
131159: EQUAL
131160: AND
131161: IFFALSE 131182
// MinerDetonateMine ( unit , x , y ) ;
131163: LD_VAR 0 2
131167: PPUSH
131168: LD_VAR 0 4
131172: PPUSH
131173: LD_VAR 0 5
131177: PPUSH
131178: CALL 134547 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
131182: LD_VAR 0 1
131186: PUSH
131187: LD_INT 252
131189: EQUAL
131190: IFFALSE 131207
131192: PUSH
131193: LD_VAR 0 2
131197: PPUSH
131198: CALL_OW 264
131202: PUSH
131203: LD_INT 81
131205: EQUAL
131206: AND
131207: IFFALSE 131228
// MinerCreateMinefield ( unit , x , y ) ;
131209: LD_VAR 0 2
131213: PPUSH
131214: LD_VAR 0 4
131218: PPUSH
131219: LD_VAR 0 5
131223: PPUSH
131224: CALL 134966 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
131228: LD_VAR 0 1
131232: PUSH
131233: LD_INT 253
131235: EQUAL
131236: IFFALSE 131253
131238: PUSH
131239: LD_VAR 0 2
131243: PPUSH
131244: CALL_OW 257
131248: PUSH
131249: LD_INT 5
131251: EQUAL
131252: AND
131253: IFFALSE 131274
// ComBinocular ( unit , x , y ) ;
131255: LD_VAR 0 2
131259: PPUSH
131260: LD_VAR 0 4
131264: PPUSH
131265: LD_VAR 0 5
131269: PPUSH
131270: CALL 135341 0 3
// if selectedUnit then
131274: LD_VAR 0 3
131278: IFFALSE 131338
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
131280: LD_VAR 0 1
131284: PUSH
131285: LD_INT 254
131287: EQUAL
131288: IFFALSE 131305
131290: PUSH
131291: LD_VAR 0 2
131295: PPUSH
131296: CALL_OW 264
131300: PUSH
131301: LD_INT 99
131303: EQUAL
131304: AND
131305: IFFALSE 131322
131307: PUSH
131308: LD_VAR 0 3
131312: PPUSH
131313: CALL_OW 263
131317: PUSH
131318: LD_INT 3
131320: EQUAL
131321: AND
131322: IFFALSE 131338
// HackDestroyVehicle ( unit , selectedUnit ) ;
131324: LD_VAR 0 2
131328: PPUSH
131329: LD_VAR 0 3
131333: PPUSH
131334: CALL 133628 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
131338: LD_VAR 0 1
131342: PUSH
131343: LD_INT 255
131345: EQUAL
131346: IFFALSE 131370
131348: PUSH
131349: LD_VAR 0 2
131353: PPUSH
131354: CALL_OW 264
131358: PUSH
131359: LD_INT 14
131361: PUSH
131362: LD_INT 53
131364: PUSH
131365: EMPTY
131366: LIST
131367: LIST
131368: IN
131369: AND
131370: IFFALSE 131388
131372: PUSH
131373: LD_VAR 0 4
131377: PPUSH
131378: LD_VAR 0 5
131382: PPUSH
131383: CALL_OW 488
131387: AND
131388: IFFALSE 131412
// CutTreeXYR ( unit , x , y , 12 ) ;
131390: LD_VAR 0 2
131394: PPUSH
131395: LD_VAR 0 4
131399: PPUSH
131400: LD_VAR 0 5
131404: PPUSH
131405: LD_INT 12
131407: PPUSH
131408: CALL 131603 0 4
// if cmd = 256 then
131412: LD_VAR 0 1
131416: PUSH
131417: LD_INT 256
131419: EQUAL
131420: IFFALSE 131441
// SetFactoryWaypoint ( unit , x , y ) ;
131422: LD_VAR 0 2
131426: PPUSH
131427: LD_VAR 0 4
131431: PPUSH
131432: LD_VAR 0 5
131436: PPUSH
131437: CALL 128963 0 3
// if cmd = 257 then
131441: LD_VAR 0 1
131445: PUSH
131446: LD_INT 257
131448: EQUAL
131449: IFFALSE 131470
// SetWarehouseGatheringPoint ( unit , x , y ) ;
131451: LD_VAR 0 2
131455: PPUSH
131456: LD_VAR 0 4
131460: PPUSH
131461: LD_VAR 0 5
131465: PPUSH
131466: CALL 129459 0 3
// if cmd = 258 then
131470: LD_VAR 0 1
131474: PUSH
131475: LD_INT 258
131477: EQUAL
131478: IFFALSE 131502
// BurnTreeXYR ( unit , x , y , 8 ) ;
131480: LD_VAR 0 2
131484: PPUSH
131485: LD_VAR 0 4
131489: PPUSH
131490: LD_VAR 0 5
131494: PPUSH
131495: LD_INT 8
131497: PPUSH
131498: CALL 132003 0 4
// end ;
131502: LD_VAR 0 6
131506: RET
// export function ComRadiation ( un ) ; var eff ; begin
131507: LD_INT 0
131509: PPUSH
131510: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
131511: LD_VAR 0 1
131515: PPUSH
131516: CALL_OW 264
131520: PUSH
131521: LD_INT 91
131523: NONEQUAL
131524: IFFALSE 131528
// exit ;
131526: GO 131598
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
131528: LD_INT 68
131530: PPUSH
131531: LD_VAR 0 1
131535: PPUSH
131536: CALL_OW 255
131540: PPUSH
131541: CALL_OW 321
131545: PUSH
131546: LD_INT 2
131548: EQUAL
131549: IFFALSE 131561
// eff := 50 else
131551: LD_ADDR_VAR 0 3
131555: PUSH
131556: LD_INT 50
131558: ST_TO_ADDR
131559: GO 131569
// eff := 25 ;
131561: LD_ADDR_VAR 0 3
131565: PUSH
131566: LD_INT 25
131568: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
131569: LD_VAR 0 1
131573: PPUSH
131574: CALL_OW 250
131578: PPUSH
131579: LD_VAR 0 1
131583: PPUSH
131584: CALL_OW 251
131588: PPUSH
131589: LD_VAR 0 3
131593: PPUSH
131594: CALL_OW 495
// end ;
131598: LD_VAR 0 2
131602: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
131603: LD_INT 0
131605: PPUSH
131606: PPUSH
131607: PPUSH
131608: PPUSH
131609: PPUSH
131610: PPUSH
131611: PPUSH
131612: PPUSH
131613: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
131614: LD_VAR 0 1
131618: PPUSH
131619: CALL_OW 302
131623: NOT
131624: IFTRUE 131643
131626: PUSH
131627: LD_VAR 0 2
131631: PPUSH
131632: LD_VAR 0 3
131636: PPUSH
131637: CALL_OW 488
131641: NOT
131642: OR
131643: IFTRUE 131652
131645: PUSH
131646: LD_VAR 0 4
131650: NOT
131651: OR
131652: IFFALSE 131656
// exit ;
131654: GO 131998
// list := [ ] ;
131656: LD_ADDR_VAR 0 13
131660: PUSH
131661: EMPTY
131662: ST_TO_ADDR
// if x - r < 0 then
131663: LD_VAR 0 2
131667: PUSH
131668: LD_VAR 0 4
131672: MINUS
131673: PUSH
131674: LD_INT 0
131676: LESS
131677: IFFALSE 131689
// min_x := 0 else
131679: LD_ADDR_VAR 0 7
131683: PUSH
131684: LD_INT 0
131686: ST_TO_ADDR
131687: GO 131705
// min_x := x - r ;
131689: LD_ADDR_VAR 0 7
131693: PUSH
131694: LD_VAR 0 2
131698: PUSH
131699: LD_VAR 0 4
131703: MINUS
131704: ST_TO_ADDR
// if y - r < 0 then
131705: LD_VAR 0 3
131709: PUSH
131710: LD_VAR 0 4
131714: MINUS
131715: PUSH
131716: LD_INT 0
131718: LESS
131719: IFFALSE 131731
// min_y := 0 else
131721: LD_ADDR_VAR 0 8
131725: PUSH
131726: LD_INT 0
131728: ST_TO_ADDR
131729: GO 131747
// min_y := y - r ;
131731: LD_ADDR_VAR 0 8
131735: PUSH
131736: LD_VAR 0 3
131740: PUSH
131741: LD_VAR 0 4
131745: MINUS
131746: ST_TO_ADDR
// max_x := x + r ;
131747: LD_ADDR_VAR 0 9
131751: PUSH
131752: LD_VAR 0 2
131756: PUSH
131757: LD_VAR 0 4
131761: PLUS
131762: ST_TO_ADDR
// max_y := y + r ;
131763: LD_ADDR_VAR 0 10
131767: PUSH
131768: LD_VAR 0 3
131772: PUSH
131773: LD_VAR 0 4
131777: PLUS
131778: ST_TO_ADDR
// for _x = min_x to max_x do
131779: LD_ADDR_VAR 0 11
131783: PUSH
131784: DOUBLE
131785: LD_VAR 0 7
131789: DEC
131790: ST_TO_ADDR
131791: LD_VAR 0 9
131795: PUSH
131796: FOR_TO
131797: IFFALSE 131916
// for _y = min_y to max_y do
131799: LD_ADDR_VAR 0 12
131803: PUSH
131804: DOUBLE
131805: LD_VAR 0 8
131809: DEC
131810: ST_TO_ADDR
131811: LD_VAR 0 10
131815: PUSH
131816: FOR_TO
131817: IFFALSE 131912
// begin if not ValidHex ( _x , _y ) then
131819: LD_VAR 0 11
131823: PPUSH
131824: LD_VAR 0 12
131828: PPUSH
131829: CALL_OW 488
131833: NOT
131834: IFFALSE 131838
// continue ;
131836: GO 131816
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
131838: LD_VAR 0 11
131842: PPUSH
131843: LD_VAR 0 12
131847: PPUSH
131848: CALL_OW 351
131852: IFFALSE 131870
131854: PUSH
131855: LD_VAR 0 11
131859: PPUSH
131860: LD_VAR 0 12
131864: PPUSH
131865: CALL_OW 554
131869: AND
131870: IFFALSE 131910
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
131872: LD_ADDR_VAR 0 13
131876: PUSH
131877: LD_VAR 0 13
131881: PPUSH
131882: LD_VAR 0 13
131886: PUSH
131887: LD_INT 1
131889: PLUS
131890: PPUSH
131891: LD_VAR 0 11
131895: PUSH
131896: LD_VAR 0 12
131900: PUSH
131901: EMPTY
131902: LIST
131903: LIST
131904: PPUSH
131905: CALL_OW 2
131909: ST_TO_ADDR
// end ;
131910: GO 131816
131912: POP
131913: POP
131914: GO 131796
131916: POP
131917: POP
// if not list then
131918: LD_VAR 0 13
131922: NOT
131923: IFFALSE 131927
// exit ;
131925: GO 131998
// for i in list do
131927: LD_ADDR_VAR 0 6
131931: PUSH
131932: LD_VAR 0 13
131936: PUSH
131937: FOR_IN
131938: IFFALSE 131996
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
131940: LD_VAR 0 1
131944: PPUSH
131945: LD_STRING M
131947: PUSH
131948: LD_VAR 0 6
131952: PUSH
131953: LD_INT 1
131955: ARRAY
131956: PUSH
131957: LD_VAR 0 6
131961: PUSH
131962: LD_INT 2
131964: ARRAY
131965: PUSH
131966: LD_INT 0
131968: PUSH
131969: LD_INT 0
131971: PUSH
131972: LD_INT 0
131974: PUSH
131975: LD_INT 0
131977: PUSH
131978: EMPTY
131979: LIST
131980: LIST
131981: LIST
131982: LIST
131983: LIST
131984: LIST
131985: LIST
131986: PUSH
131987: EMPTY
131988: LIST
131989: PPUSH
131990: CALL_OW 447
131994: GO 131937
131996: POP
131997: POP
// end ;
131998: LD_VAR 0 5
132002: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
132003: LD_INT 0
132005: PPUSH
132006: PPUSH
132007: PPUSH
132008: PPUSH
132009: PPUSH
132010: PPUSH
132011: PPUSH
132012: PPUSH
132013: PPUSH
132014: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
132015: LD_VAR 0 1
132019: PPUSH
132020: CALL_OW 302
132024: NOT
132025: IFTRUE 132044
132027: PUSH
132028: LD_VAR 0 2
132032: PPUSH
132033: LD_VAR 0 3
132037: PPUSH
132038: CALL_OW 488
132042: NOT
132043: OR
132044: IFTRUE 132053
132046: PUSH
132047: LD_VAR 0 4
132051: NOT
132052: OR
132053: IFFALSE 132057
// exit ;
132055: GO 132574
// list := [ ] ;
132057: LD_ADDR_VAR 0 13
132061: PUSH
132062: EMPTY
132063: ST_TO_ADDR
// if x - r < 0 then
132064: LD_VAR 0 2
132068: PUSH
132069: LD_VAR 0 4
132073: MINUS
132074: PUSH
132075: LD_INT 0
132077: LESS
132078: IFFALSE 132090
// min_x := 0 else
132080: LD_ADDR_VAR 0 7
132084: PUSH
132085: LD_INT 0
132087: ST_TO_ADDR
132088: GO 132106
// min_x := x - r ;
132090: LD_ADDR_VAR 0 7
132094: PUSH
132095: LD_VAR 0 2
132099: PUSH
132100: LD_VAR 0 4
132104: MINUS
132105: ST_TO_ADDR
// if y - r < 0 then
132106: LD_VAR 0 3
132110: PUSH
132111: LD_VAR 0 4
132115: MINUS
132116: PUSH
132117: LD_INT 0
132119: LESS
132120: IFFALSE 132132
// min_y := 0 else
132122: LD_ADDR_VAR 0 8
132126: PUSH
132127: LD_INT 0
132129: ST_TO_ADDR
132130: GO 132148
// min_y := y - r ;
132132: LD_ADDR_VAR 0 8
132136: PUSH
132137: LD_VAR 0 3
132141: PUSH
132142: LD_VAR 0 4
132146: MINUS
132147: ST_TO_ADDR
// max_x := x + r ;
132148: LD_ADDR_VAR 0 9
132152: PUSH
132153: LD_VAR 0 2
132157: PUSH
132158: LD_VAR 0 4
132162: PLUS
132163: ST_TO_ADDR
// max_y := y + r ;
132164: LD_ADDR_VAR 0 10
132168: PUSH
132169: LD_VAR 0 3
132173: PUSH
132174: LD_VAR 0 4
132178: PLUS
132179: ST_TO_ADDR
// for _x = min_x to max_x do
132180: LD_ADDR_VAR 0 11
132184: PUSH
132185: DOUBLE
132186: LD_VAR 0 7
132190: DEC
132191: ST_TO_ADDR
132192: LD_VAR 0 9
132196: PUSH
132197: FOR_TO
132198: IFFALSE 132317
// for _y = min_y to max_y do
132200: LD_ADDR_VAR 0 12
132204: PUSH
132205: DOUBLE
132206: LD_VAR 0 8
132210: DEC
132211: ST_TO_ADDR
132212: LD_VAR 0 10
132216: PUSH
132217: FOR_TO
132218: IFFALSE 132313
// begin if not ValidHex ( _x , _y ) then
132220: LD_VAR 0 11
132224: PPUSH
132225: LD_VAR 0 12
132229: PPUSH
132230: CALL_OW 488
132234: NOT
132235: IFFALSE 132239
// continue ;
132237: GO 132217
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
132239: LD_VAR 0 11
132243: PPUSH
132244: LD_VAR 0 12
132248: PPUSH
132249: CALL_OW 351
132253: IFFALSE 132271
132255: PUSH
132256: LD_VAR 0 11
132260: PPUSH
132261: LD_VAR 0 12
132265: PPUSH
132266: CALL_OW 554
132270: AND
132271: IFFALSE 132311
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
132273: LD_ADDR_VAR 0 13
132277: PUSH
132278: LD_VAR 0 13
132282: PPUSH
132283: LD_VAR 0 13
132287: PUSH
132288: LD_INT 1
132290: PLUS
132291: PPUSH
132292: LD_VAR 0 11
132296: PUSH
132297: LD_VAR 0 12
132301: PUSH
132302: EMPTY
132303: LIST
132304: LIST
132305: PPUSH
132306: CALL_OW 2
132310: ST_TO_ADDR
// end ;
132311: GO 132217
132313: POP
132314: POP
132315: GO 132197
132317: POP
132318: POP
// if not list then
132319: LD_VAR 0 13
132323: NOT
132324: IFFALSE 132328
// exit ;
132326: GO 132574
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
132328: LD_ADDR_VAR 0 13
132332: PUSH
132333: LD_VAR 0 1
132337: PPUSH
132338: LD_VAR 0 13
132342: PPUSH
132343: LD_INT 1
132345: PPUSH
132346: LD_INT 1
132348: PPUSH
132349: CALL 76511 0 4
132353: ST_TO_ADDR
// ComStop ( flame ) ;
132354: LD_VAR 0 1
132358: PPUSH
132359: CALL_OW 141
// for i in list do
132363: LD_ADDR_VAR 0 6
132367: PUSH
132368: LD_VAR 0 13
132372: PUSH
132373: FOR_IN
132374: IFFALSE 132405
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
132376: LD_VAR 0 1
132380: PPUSH
132381: LD_VAR 0 6
132385: PUSH
132386: LD_INT 1
132388: ARRAY
132389: PPUSH
132390: LD_VAR 0 6
132394: PUSH
132395: LD_INT 2
132397: ARRAY
132398: PPUSH
132399: CALL_OW 176
132403: GO 132373
132405: POP
132406: POP
// repeat wait ( 0 0$1 ) ;
132407: LD_INT 35
132409: PPUSH
132410: CALL_OW 67
// task := GetTaskList ( flame ) ;
132414: LD_ADDR_VAR 0 14
132418: PUSH
132419: LD_VAR 0 1
132423: PPUSH
132424: CALL_OW 437
132428: ST_TO_ADDR
// if not task then
132429: LD_VAR 0 14
132433: NOT
132434: IFFALSE 132438
// exit ;
132436: GO 132574
// if task [ 1 ] [ 1 ] <> | then
132438: LD_VAR 0 14
132442: PUSH
132443: LD_INT 1
132445: ARRAY
132446: PUSH
132447: LD_INT 1
132449: ARRAY
132450: PUSH
132451: LD_STRING |
132453: NONEQUAL
132454: IFFALSE 132458
// exit ;
132456: GO 132574
// _x := task [ 1 ] [ 2 ] ;
132458: LD_ADDR_VAR 0 11
132462: PUSH
132463: LD_VAR 0 14
132467: PUSH
132468: LD_INT 1
132470: ARRAY
132471: PUSH
132472: LD_INT 2
132474: ARRAY
132475: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
132476: LD_ADDR_VAR 0 12
132480: PUSH
132481: LD_VAR 0 14
132485: PUSH
132486: LD_INT 1
132488: ARRAY
132489: PUSH
132490: LD_INT 3
132492: ARRAY
132493: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
132494: LD_VAR 0 11
132498: PPUSH
132499: LD_VAR 0 12
132503: PPUSH
132504: CALL_OW 351
132508: NOT
132509: IFTRUE 132528
132511: PUSH
132512: LD_VAR 0 11
132516: PPUSH
132517: LD_VAR 0 12
132521: PPUSH
132522: CALL_OW 554
132526: NOT
132527: OR
132528: IFFALSE 132562
// begin task := Delete ( task , 1 ) ;
132530: LD_ADDR_VAR 0 14
132534: PUSH
132535: LD_VAR 0 14
132539: PPUSH
132540: LD_INT 1
132542: PPUSH
132543: CALL_OW 3
132547: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
132548: LD_VAR 0 1
132552: PPUSH
132553: LD_VAR 0 14
132557: PPUSH
132558: CALL_OW 446
// end ; until not HasTask ( flame ) ;
132562: LD_VAR 0 1
132566: PPUSH
132567: CALL_OW 314
132571: NOT
132572: IFFALSE 132407
// end ;
132574: LD_VAR 0 5
132578: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
132579: LD_EXP 210
132583: NOT
132584: IFFALSE 132634
132586: GO 132588
132588: DISABLE
// begin initHack := true ;
132589: LD_ADDR_EXP 210
132593: PUSH
132594: LD_INT 1
132596: ST_TO_ADDR
// hackTanks := [ ] ;
132597: LD_ADDR_EXP 211
132601: PUSH
132602: EMPTY
132603: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
132604: LD_ADDR_EXP 212
132608: PUSH
132609: EMPTY
132610: ST_TO_ADDR
// hackLimit := 3 ;
132611: LD_ADDR_EXP 213
132615: PUSH
132616: LD_INT 3
132618: ST_TO_ADDR
// hackDist := 12 ;
132619: LD_ADDR_EXP 214
132623: PUSH
132624: LD_INT 12
132626: ST_TO_ADDR
// hackCounter := [ ] ;
132627: LD_ADDR_EXP 215
132631: PUSH
132632: EMPTY
132633: ST_TO_ADDR
// end ;
132634: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
132635: LD_EXP 210
132639: IFFALSE 132657
132641: PUSH
132642: LD_INT 34
132644: PUSH
132645: LD_INT 99
132647: PUSH
132648: EMPTY
132649: LIST
132650: LIST
132651: PPUSH
132652: CALL_OW 69
132656: AND
132657: IFFALSE 132910
132659: GO 132661
132661: DISABLE
132662: LD_INT 0
132664: PPUSH
132665: PPUSH
// begin enable ;
132666: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
132667: LD_ADDR_VAR 0 1
132671: PUSH
132672: LD_INT 34
132674: PUSH
132675: LD_INT 99
132677: PUSH
132678: EMPTY
132679: LIST
132680: LIST
132681: PPUSH
132682: CALL_OW 69
132686: PUSH
132687: FOR_IN
132688: IFFALSE 132908
// begin if not i in hackTanks then
132690: LD_VAR 0 1
132694: PUSH
132695: LD_EXP 211
132699: IN
132700: NOT
132701: IFFALSE 132784
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
132703: LD_ADDR_EXP 211
132707: PUSH
132708: LD_EXP 211
132712: PPUSH
132713: LD_EXP 211
132717: PUSH
132718: LD_INT 1
132720: PLUS
132721: PPUSH
132722: LD_VAR 0 1
132726: PPUSH
132727: CALL_OW 1
132731: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
132732: LD_ADDR_EXP 212
132736: PUSH
132737: LD_EXP 212
132741: PPUSH
132742: LD_EXP 212
132746: PUSH
132747: LD_INT 1
132749: PLUS
132750: PPUSH
132751: EMPTY
132752: PPUSH
132753: CALL_OW 1
132757: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
132758: LD_ADDR_EXP 215
132762: PUSH
132763: LD_EXP 215
132767: PPUSH
132768: LD_EXP 215
132772: PUSH
132773: LD_INT 1
132775: PLUS
132776: PPUSH
132777: EMPTY
132778: PPUSH
132779: CALL_OW 1
132783: ST_TO_ADDR
// end ; if not IsOk ( i ) then
132784: LD_VAR 0 1
132788: PPUSH
132789: CALL_OW 302
132793: NOT
132794: IFFALSE 132807
// begin HackUnlinkAll ( i ) ;
132796: LD_VAR 0 1
132800: PPUSH
132801: CALL 132913 0 1
// continue ;
132805: GO 132687
// end ; HackCheckCapturedStatus ( i ) ;
132807: LD_VAR 0 1
132811: PPUSH
132812: CALL 133358 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
132816: LD_ADDR_VAR 0 2
132820: PUSH
132821: LD_INT 81
132823: PUSH
132824: LD_VAR 0 1
132828: PPUSH
132829: CALL_OW 255
132833: PUSH
132834: EMPTY
132835: LIST
132836: LIST
132837: PUSH
132838: LD_INT 33
132840: PUSH
132841: LD_INT 3
132843: PUSH
132844: EMPTY
132845: LIST
132846: LIST
132847: PUSH
132848: LD_INT 91
132850: PUSH
132851: LD_VAR 0 1
132855: PUSH
132856: LD_EXP 214
132860: PUSH
132861: EMPTY
132862: LIST
132863: LIST
132864: LIST
132865: PUSH
132866: LD_INT 50
132868: PUSH
132869: EMPTY
132870: LIST
132871: PUSH
132872: EMPTY
132873: LIST
132874: LIST
132875: LIST
132876: LIST
132877: PPUSH
132878: CALL_OW 69
132882: ST_TO_ADDR
// if not tmp then
132883: LD_VAR 0 2
132887: NOT
132888: IFFALSE 132892
// continue ;
132890: GO 132687
// HackLink ( i , tmp ) ;
132892: LD_VAR 0 1
132896: PPUSH
132897: LD_VAR 0 2
132901: PPUSH
132902: CALL 133049 0 2
// end ;
132906: GO 132687
132908: POP
132909: POP
// end ;
132910: PPOPN 2
132912: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
132913: LD_INT 0
132915: PPUSH
132916: PPUSH
132917: PPUSH
// if not hack in hackTanks then
132918: LD_VAR 0 1
132922: PUSH
132923: LD_EXP 211
132927: IN
132928: NOT
132929: IFFALSE 132933
// exit ;
132931: GO 133044
// index := GetElementIndex ( hackTanks , hack ) ;
132933: LD_ADDR_VAR 0 4
132937: PUSH
132938: LD_EXP 211
132942: PPUSH
132943: LD_VAR 0 1
132947: PPUSH
132948: CALL 75806 0 2
132952: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
132953: LD_EXP 212
132957: PUSH
132958: LD_VAR 0 4
132962: ARRAY
132963: IFFALSE 133044
// begin for i in hackTanksCaptured [ index ] do
132965: LD_ADDR_VAR 0 3
132969: PUSH
132970: LD_EXP 212
132974: PUSH
132975: LD_VAR 0 4
132979: ARRAY
132980: PUSH
132981: FOR_IN
132982: IFFALSE 133008
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
132984: LD_VAR 0 3
132988: PUSH
132989: LD_INT 1
132991: ARRAY
132992: PPUSH
132993: LD_VAR 0 3
132997: PUSH
132998: LD_INT 2
133000: ARRAY
133001: PPUSH
133002: CALL_OW 235
133006: GO 132981
133008: POP
133009: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
133010: LD_ADDR_EXP 212
133014: PUSH
133015: LD_EXP 212
133019: PPUSH
133020: LD_VAR 0 4
133024: PPUSH
133025: EMPTY
133026: PPUSH
133027: CALL_OW 1
133031: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
133032: LD_VAR 0 1
133036: PPUSH
133037: LD_INT 0
133039: PPUSH
133040: CALL_OW 505
// end ; end ;
133044: LD_VAR 0 2
133048: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
133049: LD_INT 0
133051: PPUSH
133052: PPUSH
133053: PPUSH
// if not hack in hackTanks or not vehicles then
133054: LD_VAR 0 1
133058: PUSH
133059: LD_EXP 211
133063: IN
133064: NOT
133065: IFTRUE 133074
133067: PUSH
133068: LD_VAR 0 2
133072: NOT
133073: OR
133074: IFFALSE 133078
// exit ;
133076: GO 133353
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
133078: LD_ADDR_VAR 0 2
133082: PUSH
133083: LD_VAR 0 1
133087: PPUSH
133088: LD_VAR 0 2
133092: PPUSH
133093: LD_INT 1
133095: PPUSH
133096: LD_INT 1
133098: PPUSH
133099: CALL 76458 0 4
133103: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
133104: LD_ADDR_VAR 0 5
133108: PUSH
133109: LD_EXP 211
133113: PPUSH
133114: LD_VAR 0 1
133118: PPUSH
133119: CALL 75806 0 2
133123: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
133124: LD_EXP 212
133128: PUSH
133129: LD_VAR 0 5
133133: ARRAY
133134: PUSH
133135: LD_EXP 213
133139: LESS
133140: IFFALSE 133329
// begin for i := 1 to vehicles do
133142: LD_ADDR_VAR 0 4
133146: PUSH
133147: DOUBLE
133148: LD_INT 1
133150: DEC
133151: ST_TO_ADDR
133152: LD_VAR 0 2
133156: PUSH
133157: FOR_TO
133158: IFFALSE 133327
// begin if hackTanksCaptured [ index ] = hackLimit then
133160: LD_EXP 212
133164: PUSH
133165: LD_VAR 0 5
133169: ARRAY
133170: PUSH
133171: LD_EXP 213
133175: EQUAL
133176: IFFALSE 133180
// break ;
133178: GO 133327
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
133180: LD_ADDR_EXP 215
133184: PUSH
133185: LD_EXP 215
133189: PPUSH
133190: LD_VAR 0 5
133194: PPUSH
133195: LD_EXP 215
133199: PUSH
133200: LD_VAR 0 5
133204: ARRAY
133205: PUSH
133206: LD_INT 1
133208: PLUS
133209: PPUSH
133210: CALL_OW 1
133214: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
133215: LD_ADDR_EXP 212
133219: PUSH
133220: LD_EXP 212
133224: PPUSH
133225: LD_VAR 0 5
133229: PUSH
133230: LD_EXP 212
133234: PUSH
133235: LD_VAR 0 5
133239: ARRAY
133240: PUSH
133241: LD_INT 1
133243: PLUS
133244: PUSH
133245: EMPTY
133246: LIST
133247: LIST
133248: PPUSH
133249: LD_VAR 0 2
133253: PUSH
133254: LD_VAR 0 4
133258: ARRAY
133259: PUSH
133260: LD_VAR 0 2
133264: PUSH
133265: LD_VAR 0 4
133269: ARRAY
133270: PPUSH
133271: CALL_OW 255
133275: PUSH
133276: EMPTY
133277: LIST
133278: LIST
133279: PPUSH
133280: CALL 76023 0 3
133284: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
133285: LD_VAR 0 2
133289: PUSH
133290: LD_VAR 0 4
133294: ARRAY
133295: PPUSH
133296: LD_VAR 0 1
133300: PPUSH
133301: CALL_OW 255
133305: PPUSH
133306: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
133310: LD_VAR 0 2
133314: PUSH
133315: LD_VAR 0 4
133319: ARRAY
133320: PPUSH
133321: CALL_OW 141
// end ;
133325: GO 133157
133327: POP
133328: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133329: LD_VAR 0 1
133333: PPUSH
133334: LD_EXP 212
133338: PUSH
133339: LD_VAR 0 5
133343: ARRAY
133344: PUSH
133345: LD_INT 0
133347: PLUS
133348: PPUSH
133349: CALL_OW 505
// end ;
133353: LD_VAR 0 3
133357: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
133358: LD_INT 0
133360: PPUSH
133361: PPUSH
133362: PPUSH
133363: PPUSH
// if not hack in hackTanks then
133364: LD_VAR 0 1
133368: PUSH
133369: LD_EXP 211
133373: IN
133374: NOT
133375: IFFALSE 133379
// exit ;
133377: GO 133623
// index := GetElementIndex ( hackTanks , hack ) ;
133379: LD_ADDR_VAR 0 4
133383: PUSH
133384: LD_EXP 211
133388: PPUSH
133389: LD_VAR 0 1
133393: PPUSH
133394: CALL 75806 0 2
133398: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
133399: LD_ADDR_VAR 0 3
133403: PUSH
133404: DOUBLE
133405: LD_EXP 212
133409: PUSH
133410: LD_VAR 0 4
133414: ARRAY
133415: INC
133416: ST_TO_ADDR
133417: LD_INT 1
133419: PUSH
133420: FOR_DOWNTO
133421: IFFALSE 133597
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
133423: LD_ADDR_VAR 0 5
133427: PUSH
133428: LD_EXP 212
133432: PUSH
133433: LD_VAR 0 4
133437: ARRAY
133438: PUSH
133439: LD_VAR 0 3
133443: ARRAY
133444: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
133445: LD_VAR 0 5
133449: PUSH
133450: LD_INT 1
133452: ARRAY
133453: PPUSH
133454: CALL_OW 302
133458: NOT
133459: IFTRUE 133487
133461: PUSH
133462: LD_VAR 0 5
133466: PUSH
133467: LD_INT 1
133469: ARRAY
133470: PPUSH
133471: CALL_OW 255
133475: PUSH
133476: LD_VAR 0 1
133480: PPUSH
133481: CALL_OW 255
133485: NONEQUAL
133486: OR
133487: IFFALSE 133595
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
133489: LD_VAR 0 5
133493: PUSH
133494: LD_INT 1
133496: ARRAY
133497: PPUSH
133498: CALL_OW 305
133502: IFFALSE 133530
133504: PUSH
133505: LD_VAR 0 5
133509: PUSH
133510: LD_INT 1
133512: ARRAY
133513: PPUSH
133514: CALL_OW 255
133518: PUSH
133519: LD_VAR 0 1
133523: PPUSH
133524: CALL_OW 255
133528: EQUAL
133529: AND
133530: IFFALSE 133554
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
133532: LD_VAR 0 5
133536: PUSH
133537: LD_INT 1
133539: ARRAY
133540: PPUSH
133541: LD_VAR 0 5
133545: PUSH
133546: LD_INT 2
133548: ARRAY
133549: PPUSH
133550: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
133554: LD_ADDR_EXP 212
133558: PUSH
133559: LD_EXP 212
133563: PPUSH
133564: LD_VAR 0 4
133568: PPUSH
133569: LD_EXP 212
133573: PUSH
133574: LD_VAR 0 4
133578: ARRAY
133579: PPUSH
133580: LD_VAR 0 3
133584: PPUSH
133585: CALL_OW 3
133589: PPUSH
133590: CALL_OW 1
133594: ST_TO_ADDR
// end ; end ;
133595: GO 133420
133597: POP
133598: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133599: LD_VAR 0 1
133603: PPUSH
133604: LD_EXP 212
133608: PUSH
133609: LD_VAR 0 4
133613: ARRAY
133614: PUSH
133615: LD_INT 0
133617: PLUS
133618: PPUSH
133619: CALL_OW 505
// end ;
133623: LD_VAR 0 2
133627: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
133628: LD_INT 0
133630: PPUSH
133631: PPUSH
133632: PPUSH
133633: PPUSH
// if not hack in hackTanks then
133634: LD_VAR 0 1
133638: PUSH
133639: LD_EXP 211
133643: IN
133644: NOT
133645: IFFALSE 133649
// exit ;
133647: GO 133734
// index := GetElementIndex ( hackTanks , hack ) ;
133649: LD_ADDR_VAR 0 5
133653: PUSH
133654: LD_EXP 211
133658: PPUSH
133659: LD_VAR 0 1
133663: PPUSH
133664: CALL 75806 0 2
133668: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
133669: LD_ADDR_VAR 0 4
133673: PUSH
133674: DOUBLE
133675: LD_INT 1
133677: DEC
133678: ST_TO_ADDR
133679: LD_EXP 212
133683: PUSH
133684: LD_VAR 0 5
133688: ARRAY
133689: PUSH
133690: FOR_TO
133691: IFFALSE 133732
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
133693: LD_EXP 212
133697: PUSH
133698: LD_VAR 0 5
133702: ARRAY
133703: PUSH
133704: LD_VAR 0 4
133708: ARRAY
133709: PUSH
133710: LD_INT 1
133712: ARRAY
133713: PUSH
133714: LD_VAR 0 2
133718: EQUAL
133719: IFFALSE 133730
// KillUnit ( vehicle ) ;
133721: LD_VAR 0 2
133725: PPUSH
133726: CALL_OW 66
133730: GO 133690
133732: POP
133733: POP
// end ;
133734: LD_VAR 0 3
133738: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
133739: LD_EXP 216
133743: NOT
133744: IFFALSE 133779
133746: GO 133748
133748: DISABLE
// begin initMiner := true ;
133749: LD_ADDR_EXP 216
133753: PUSH
133754: LD_INT 1
133756: ST_TO_ADDR
// minersList := [ ] ;
133757: LD_ADDR_EXP 217
133761: PUSH
133762: EMPTY
133763: ST_TO_ADDR
// minerMinesList := [ ] ;
133764: LD_ADDR_EXP 218
133768: PUSH
133769: EMPTY
133770: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
133771: LD_ADDR_EXP 219
133775: PUSH
133776: LD_INT 5
133778: ST_TO_ADDR
// end ;
133779: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
133780: LD_EXP 216
133784: IFFALSE 133802
133786: PUSH
133787: LD_INT 34
133789: PUSH
133790: LD_INT 81
133792: PUSH
133793: EMPTY
133794: LIST
133795: LIST
133796: PPUSH
133797: CALL_OW 69
133801: AND
133802: IFFALSE 134265
133804: GO 133806
133806: DISABLE
133807: LD_INT 0
133809: PPUSH
133810: PPUSH
133811: PPUSH
133812: PPUSH
// begin enable ;
133813: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
133814: LD_ADDR_VAR 0 1
133818: PUSH
133819: LD_INT 34
133821: PUSH
133822: LD_INT 81
133824: PUSH
133825: EMPTY
133826: LIST
133827: LIST
133828: PPUSH
133829: CALL_OW 69
133833: PUSH
133834: FOR_IN
133835: IFFALSE 133907
// begin if not i in minersList then
133837: LD_VAR 0 1
133841: PUSH
133842: LD_EXP 217
133846: IN
133847: NOT
133848: IFFALSE 133905
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
133850: LD_ADDR_EXP 217
133854: PUSH
133855: LD_EXP 217
133859: PPUSH
133860: LD_EXP 217
133864: PUSH
133865: LD_INT 1
133867: PLUS
133868: PPUSH
133869: LD_VAR 0 1
133873: PPUSH
133874: CALL_OW 1
133878: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
133879: LD_ADDR_EXP 218
133883: PUSH
133884: LD_EXP 218
133888: PPUSH
133889: LD_EXP 218
133893: PUSH
133894: LD_INT 1
133896: PLUS
133897: PPUSH
133898: EMPTY
133899: PPUSH
133900: CALL_OW 1
133904: ST_TO_ADDR
// end end ;
133905: GO 133834
133907: POP
133908: POP
// for i := minerMinesList downto 1 do
133909: LD_ADDR_VAR 0 1
133913: PUSH
133914: DOUBLE
133915: LD_EXP 218
133919: INC
133920: ST_TO_ADDR
133921: LD_INT 1
133923: PUSH
133924: FOR_DOWNTO
133925: IFFALSE 134263
// begin if IsLive ( minersList [ i ] ) then
133927: LD_EXP 217
133931: PUSH
133932: LD_VAR 0 1
133936: ARRAY
133937: PPUSH
133938: CALL_OW 300
133942: IFFALSE 133970
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
133944: LD_EXP 217
133948: PUSH
133949: LD_VAR 0 1
133953: ARRAY
133954: PPUSH
133955: LD_EXP 218
133959: PUSH
133960: LD_VAR 0 1
133964: ARRAY
133965: PPUSH
133966: CALL_OW 505
// if not minerMinesList [ i ] then
133970: LD_EXP 218
133974: PUSH
133975: LD_VAR 0 1
133979: ARRAY
133980: NOT
133981: IFFALSE 133985
// continue ;
133983: GO 133924
// for j := minerMinesList [ i ] downto 1 do
133985: LD_ADDR_VAR 0 2
133989: PUSH
133990: DOUBLE
133991: LD_EXP 218
133995: PUSH
133996: LD_VAR 0 1
134000: ARRAY
134001: INC
134002: ST_TO_ADDR
134003: LD_INT 1
134005: PUSH
134006: FOR_DOWNTO
134007: IFFALSE 134259
// begin side := GetSide ( minersList [ i ] ) ;
134009: LD_ADDR_VAR 0 3
134013: PUSH
134014: LD_EXP 217
134018: PUSH
134019: LD_VAR 0 1
134023: ARRAY
134024: PPUSH
134025: CALL_OW 255
134029: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
134030: LD_ADDR_VAR 0 4
134034: PUSH
134035: LD_EXP 218
134039: PUSH
134040: LD_VAR 0 1
134044: ARRAY
134045: PUSH
134046: LD_VAR 0 2
134050: ARRAY
134051: PUSH
134052: LD_INT 1
134054: ARRAY
134055: PPUSH
134056: LD_EXP 218
134060: PUSH
134061: LD_VAR 0 1
134065: ARRAY
134066: PUSH
134067: LD_VAR 0 2
134071: ARRAY
134072: PUSH
134073: LD_INT 2
134075: ARRAY
134076: PPUSH
134077: CALL_OW 428
134081: ST_TO_ADDR
// if not tmp then
134082: LD_VAR 0 4
134086: NOT
134087: IFFALSE 134091
// continue ;
134089: GO 134006
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
134091: LD_VAR 0 4
134095: PUSH
134096: LD_INT 81
134098: PUSH
134099: LD_VAR 0 3
134103: PUSH
134104: EMPTY
134105: LIST
134106: LIST
134107: PPUSH
134108: CALL_OW 69
134112: IN
134113: IFFALSE 134163
134115: PUSH
134116: LD_EXP 218
134120: PUSH
134121: LD_VAR 0 1
134125: ARRAY
134126: PUSH
134127: LD_VAR 0 2
134131: ARRAY
134132: PUSH
134133: LD_INT 1
134135: ARRAY
134136: PPUSH
134137: LD_EXP 218
134141: PUSH
134142: LD_VAR 0 1
134146: ARRAY
134147: PUSH
134148: LD_VAR 0 2
134152: ARRAY
134153: PUSH
134154: LD_INT 2
134156: ARRAY
134157: PPUSH
134158: CALL_OW 458
134162: AND
134163: IFFALSE 134257
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
134165: LD_EXP 218
134169: PUSH
134170: LD_VAR 0 1
134174: ARRAY
134175: PUSH
134176: LD_VAR 0 2
134180: ARRAY
134181: PUSH
134182: LD_INT 1
134184: ARRAY
134185: PPUSH
134186: LD_EXP 218
134190: PUSH
134191: LD_VAR 0 1
134195: ARRAY
134196: PUSH
134197: LD_VAR 0 2
134201: ARRAY
134202: PUSH
134203: LD_INT 2
134205: ARRAY
134206: PPUSH
134207: LD_VAR 0 3
134211: PPUSH
134212: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
134216: LD_ADDR_EXP 218
134220: PUSH
134221: LD_EXP 218
134225: PPUSH
134226: LD_VAR 0 1
134230: PPUSH
134231: LD_EXP 218
134235: PUSH
134236: LD_VAR 0 1
134240: ARRAY
134241: PPUSH
134242: LD_VAR 0 2
134246: PPUSH
134247: CALL_OW 3
134251: PPUSH
134252: CALL_OW 1
134256: ST_TO_ADDR
// end ; end ;
134257: GO 134006
134259: POP
134260: POP
// end ;
134261: GO 133924
134263: POP
134264: POP
// end ;
134265: PPOPN 4
134267: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
134268: LD_INT 0
134270: PPUSH
134271: PPUSH
// result := false ;
134272: LD_ADDR_VAR 0 4
134276: PUSH
134277: LD_INT 0
134279: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
134280: LD_VAR 0 1
134284: PPUSH
134285: CALL_OW 264
134289: PUSH
134290: LD_INT 81
134292: EQUAL
134293: NOT
134294: IFFALSE 134298
// exit ;
134296: GO 134542
// index := GetElementIndex ( minersList , unit ) ;
134298: LD_ADDR_VAR 0 5
134302: PUSH
134303: LD_EXP 217
134307: PPUSH
134308: LD_VAR 0 1
134312: PPUSH
134313: CALL 75806 0 2
134317: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
134318: LD_EXP 218
134322: PUSH
134323: LD_VAR 0 5
134327: ARRAY
134328: PUSH
134329: LD_EXP 219
134333: GREATEREQUAL
134334: IFFALSE 134338
// exit ;
134336: GO 134542
// ComMoveXY ( unit , x , y ) ;
134338: LD_VAR 0 1
134342: PPUSH
134343: LD_VAR 0 2
134347: PPUSH
134348: LD_VAR 0 3
134352: PPUSH
134353: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
134357: LD_INT 35
134359: PPUSH
134360: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
134364: LD_VAR 0 1
134368: PPUSH
134369: LD_VAR 0 2
134373: PPUSH
134374: LD_VAR 0 3
134378: PPUSH
134379: CALL 107852 0 3
134383: NOT
134384: IFFALSE 134397
134386: PUSH
134387: LD_VAR 0 1
134391: PPUSH
134392: CALL_OW 314
134396: AND
134397: IFFALSE 134401
// exit ;
134399: GO 134542
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
134401: LD_VAR 0 2
134405: PPUSH
134406: LD_VAR 0 3
134410: PPUSH
134411: CALL_OW 428
134415: PUSH
134416: LD_VAR 0 1
134420: EQUAL
134421: IFFALSE 134435
134423: PUSH
134424: LD_VAR 0 1
134428: PPUSH
134429: CALL_OW 314
134433: NOT
134434: AND
134435: IFFALSE 134357
// PlaySoundXY ( x , y , PlantMine ) ;
134437: LD_VAR 0 2
134441: PPUSH
134442: LD_VAR 0 3
134446: PPUSH
134447: LD_STRING PlantMine
134449: PPUSH
134450: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
134454: LD_VAR 0 2
134458: PPUSH
134459: LD_VAR 0 3
134463: PPUSH
134464: LD_VAR 0 1
134468: PPUSH
134469: CALL_OW 255
134473: PPUSH
134474: LD_INT 0
134476: PPUSH
134477: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
134481: LD_ADDR_EXP 218
134485: PUSH
134486: LD_EXP 218
134490: PPUSH
134491: LD_VAR 0 5
134495: PUSH
134496: LD_EXP 218
134500: PUSH
134501: LD_VAR 0 5
134505: ARRAY
134506: PUSH
134507: LD_INT 1
134509: PLUS
134510: PUSH
134511: EMPTY
134512: LIST
134513: LIST
134514: PPUSH
134515: LD_VAR 0 2
134519: PUSH
134520: LD_VAR 0 3
134524: PUSH
134525: EMPTY
134526: LIST
134527: LIST
134528: PPUSH
134529: CALL 76023 0 3
134533: ST_TO_ADDR
// result := true ;
134534: LD_ADDR_VAR 0 4
134538: PUSH
134539: LD_INT 1
134541: ST_TO_ADDR
// end ;
134542: LD_VAR 0 4
134546: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
134547: LD_INT 0
134549: PPUSH
134550: PPUSH
134551: PPUSH
// if not unit in minersList then
134552: LD_VAR 0 1
134556: PUSH
134557: LD_EXP 217
134561: IN
134562: NOT
134563: IFFALSE 134567
// exit ;
134565: GO 134961
// index := GetElementIndex ( minersList , unit ) ;
134567: LD_ADDR_VAR 0 6
134571: PUSH
134572: LD_EXP 217
134576: PPUSH
134577: LD_VAR 0 1
134581: PPUSH
134582: CALL 75806 0 2
134586: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
134587: LD_ADDR_VAR 0 5
134591: PUSH
134592: DOUBLE
134593: LD_EXP 218
134597: PUSH
134598: LD_VAR 0 6
134602: ARRAY
134603: INC
134604: ST_TO_ADDR
134605: LD_INT 1
134607: PUSH
134608: FOR_DOWNTO
134609: IFFALSE 134772
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
134611: LD_EXP 218
134615: PUSH
134616: LD_VAR 0 6
134620: ARRAY
134621: PUSH
134622: LD_VAR 0 5
134626: ARRAY
134627: PUSH
134628: LD_INT 1
134630: ARRAY
134631: PUSH
134632: LD_VAR 0 2
134636: EQUAL
134637: IFFALSE 134667
134639: PUSH
134640: LD_EXP 218
134644: PUSH
134645: LD_VAR 0 6
134649: ARRAY
134650: PUSH
134651: LD_VAR 0 5
134655: ARRAY
134656: PUSH
134657: LD_INT 2
134659: ARRAY
134660: PUSH
134661: LD_VAR 0 3
134665: EQUAL
134666: AND
134667: IFFALSE 134770
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
134669: LD_EXP 218
134673: PUSH
134674: LD_VAR 0 6
134678: ARRAY
134679: PUSH
134680: LD_VAR 0 5
134684: ARRAY
134685: PUSH
134686: LD_INT 1
134688: ARRAY
134689: PPUSH
134690: LD_EXP 218
134694: PUSH
134695: LD_VAR 0 6
134699: ARRAY
134700: PUSH
134701: LD_VAR 0 5
134705: ARRAY
134706: PUSH
134707: LD_INT 2
134709: ARRAY
134710: PPUSH
134711: LD_VAR 0 1
134715: PPUSH
134716: CALL_OW 255
134720: PPUSH
134721: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
134725: LD_ADDR_EXP 218
134729: PUSH
134730: LD_EXP 218
134734: PPUSH
134735: LD_VAR 0 6
134739: PPUSH
134740: LD_EXP 218
134744: PUSH
134745: LD_VAR 0 6
134749: ARRAY
134750: PPUSH
134751: LD_VAR 0 5
134755: PPUSH
134756: CALL_OW 3
134760: PPUSH
134761: CALL_OW 1
134765: ST_TO_ADDR
// exit ;
134766: POP
134767: POP
134768: GO 134961
// end ; end ;
134770: GO 134608
134772: POP
134773: POP
// for i := minerMinesList [ index ] downto 1 do
134774: LD_ADDR_VAR 0 5
134778: PUSH
134779: DOUBLE
134780: LD_EXP 218
134784: PUSH
134785: LD_VAR 0 6
134789: ARRAY
134790: INC
134791: ST_TO_ADDR
134792: LD_INT 1
134794: PUSH
134795: FOR_DOWNTO
134796: IFFALSE 134959
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
134798: LD_EXP 218
134802: PUSH
134803: LD_VAR 0 6
134807: ARRAY
134808: PUSH
134809: LD_VAR 0 5
134813: ARRAY
134814: PUSH
134815: LD_INT 1
134817: ARRAY
134818: PPUSH
134819: LD_EXP 218
134823: PUSH
134824: LD_VAR 0 6
134828: ARRAY
134829: PUSH
134830: LD_VAR 0 5
134834: ARRAY
134835: PUSH
134836: LD_INT 2
134838: ARRAY
134839: PPUSH
134840: LD_VAR 0 2
134844: PPUSH
134845: LD_VAR 0 3
134849: PPUSH
134850: CALL_OW 298
134854: PUSH
134855: LD_INT 6
134857: LESS
134858: IFFALSE 134957
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
134860: LD_EXP 218
134864: PUSH
134865: LD_VAR 0 6
134869: ARRAY
134870: PUSH
134871: LD_VAR 0 5
134875: ARRAY
134876: PUSH
134877: LD_INT 1
134879: ARRAY
134880: PPUSH
134881: LD_EXP 218
134885: PUSH
134886: LD_VAR 0 6
134890: ARRAY
134891: PUSH
134892: LD_VAR 0 5
134896: ARRAY
134897: PUSH
134898: LD_INT 2
134900: ARRAY
134901: PPUSH
134902: LD_VAR 0 1
134906: PPUSH
134907: CALL_OW 255
134911: PPUSH
134912: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
134916: LD_ADDR_EXP 218
134920: PUSH
134921: LD_EXP 218
134925: PPUSH
134926: LD_VAR 0 6
134930: PPUSH
134931: LD_EXP 218
134935: PUSH
134936: LD_VAR 0 6
134940: ARRAY
134941: PPUSH
134942: LD_VAR 0 5
134946: PPUSH
134947: CALL_OW 3
134951: PPUSH
134952: CALL_OW 1
134956: ST_TO_ADDR
// end ; end ;
134957: GO 134795
134959: POP
134960: POP
// end ;
134961: LD_VAR 0 4
134965: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
134966: LD_INT 0
134968: PPUSH
134969: PPUSH
134970: PPUSH
134971: PPUSH
134972: PPUSH
134973: PPUSH
134974: PPUSH
134975: PPUSH
134976: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
134977: LD_VAR 0 1
134981: PPUSH
134982: CALL_OW 264
134986: PUSH
134987: LD_INT 81
134989: EQUAL
134990: NOT
134991: IFTRUE 135006
134993: PUSH
134994: LD_VAR 0 1
134998: PUSH
134999: LD_EXP 217
135003: IN
135004: NOT
135005: OR
135006: IFFALSE 135010
// exit ;
135008: GO 135336
// index := GetElementIndex ( minersList , unit ) ;
135010: LD_ADDR_VAR 0 6
135014: PUSH
135015: LD_EXP 217
135019: PPUSH
135020: LD_VAR 0 1
135024: PPUSH
135025: CALL 75806 0 2
135029: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
135030: LD_ADDR_VAR 0 8
135034: PUSH
135035: LD_EXP 219
135039: PUSH
135040: LD_EXP 218
135044: PUSH
135045: LD_VAR 0 6
135049: ARRAY
135050: MINUS
135051: ST_TO_ADDR
// if not minesFreeAmount then
135052: LD_VAR 0 8
135056: NOT
135057: IFFALSE 135061
// exit ;
135059: GO 135336
// tmp := [ ] ;
135061: LD_ADDR_VAR 0 7
135065: PUSH
135066: EMPTY
135067: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
135068: LD_ADDR_VAR 0 5
135072: PUSH
135073: DOUBLE
135074: LD_INT 1
135076: DEC
135077: ST_TO_ADDR
135078: LD_VAR 0 8
135082: PUSH
135083: FOR_TO
135084: IFFALSE 135283
// begin _d := rand ( 0 , 5 ) ;
135086: LD_ADDR_VAR 0 11
135090: PUSH
135091: LD_INT 0
135093: PPUSH
135094: LD_INT 5
135096: PPUSH
135097: CALL_OW 12
135101: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
135102: LD_ADDR_VAR 0 12
135106: PUSH
135107: LD_INT 2
135109: PPUSH
135110: LD_INT 6
135112: PPUSH
135113: CALL_OW 12
135117: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
135118: LD_ADDR_VAR 0 9
135122: PUSH
135123: LD_VAR 0 2
135127: PPUSH
135128: LD_VAR 0 11
135132: PPUSH
135133: LD_VAR 0 12
135137: PPUSH
135138: CALL_OW 272
135142: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
135143: LD_ADDR_VAR 0 10
135147: PUSH
135148: LD_VAR 0 3
135152: PPUSH
135153: LD_VAR 0 11
135157: PPUSH
135158: LD_VAR 0 12
135162: PPUSH
135163: CALL_OW 273
135167: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
135168: LD_VAR 0 9
135172: PPUSH
135173: LD_VAR 0 10
135177: PPUSH
135178: CALL_OW 488
135182: IFFALSE 135206
135184: PUSH
135185: LD_VAR 0 9
135189: PUSH
135190: LD_VAR 0 10
135194: PUSH
135195: EMPTY
135196: LIST
135197: LIST
135198: PUSH
135199: LD_VAR 0 7
135203: IN
135204: NOT
135205: AND
135206: IFFALSE 135225
135208: PUSH
135209: LD_VAR 0 9
135213: PPUSH
135214: LD_VAR 0 10
135218: PPUSH
135219: CALL_OW 458
135223: NOT
135224: AND
135225: IFFALSE 135267
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
135227: LD_ADDR_VAR 0 7
135231: PUSH
135232: LD_VAR 0 7
135236: PPUSH
135237: LD_VAR 0 7
135241: PUSH
135242: LD_INT 1
135244: PLUS
135245: PPUSH
135246: LD_VAR 0 9
135250: PUSH
135251: LD_VAR 0 10
135255: PUSH
135256: EMPTY
135257: LIST
135258: LIST
135259: PPUSH
135260: CALL_OW 1
135264: ST_TO_ADDR
135265: GO 135281
// i := i - 1 ;
135267: LD_ADDR_VAR 0 5
135271: PUSH
135272: LD_VAR 0 5
135276: PUSH
135277: LD_INT 1
135279: MINUS
135280: ST_TO_ADDR
// end ;
135281: GO 135083
135283: POP
135284: POP
// for i in tmp do
135285: LD_ADDR_VAR 0 5
135289: PUSH
135290: LD_VAR 0 7
135294: PUSH
135295: FOR_IN
135296: IFFALSE 135334
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
135298: LD_VAR 0 1
135302: PPUSH
135303: LD_VAR 0 5
135307: PUSH
135308: LD_INT 1
135310: ARRAY
135311: PPUSH
135312: LD_VAR 0 5
135316: PUSH
135317: LD_INT 2
135319: ARRAY
135320: PPUSH
135321: CALL 134268 0 3
135325: NOT
135326: IFFALSE 135332
// exit ;
135328: POP
135329: POP
135330: GO 135336
135332: GO 135295
135334: POP
135335: POP
// end ;
135336: LD_VAR 0 4
135340: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
135341: LD_INT 0
135343: PPUSH
135344: PPUSH
135345: PPUSH
135346: PPUSH
135347: PPUSH
135348: PPUSH
135349: PPUSH
135350: PPUSH
135351: PPUSH
// if GetClass ( unit ) <> class_sniper then
135352: LD_VAR 0 1
135356: PPUSH
135357: CALL_OW 257
135361: PUSH
135362: LD_INT 5
135364: NONEQUAL
135365: IFFALSE 135369
// exit ;
135367: GO 135839
// dist := 8 ;
135369: LD_ADDR_VAR 0 5
135373: PUSH
135374: LD_INT 8
135376: ST_TO_ADDR
// viewRange := 12 ;
135377: LD_ADDR_VAR 0 8
135381: PUSH
135382: LD_INT 12
135384: ST_TO_ADDR
// side := GetSide ( unit ) ;
135385: LD_ADDR_VAR 0 6
135389: PUSH
135390: LD_VAR 0 1
135394: PPUSH
135395: CALL_OW 255
135399: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
135400: LD_INT 61
135402: PPUSH
135403: LD_VAR 0 6
135407: PPUSH
135408: CALL_OW 321
135412: PUSH
135413: LD_INT 2
135415: EQUAL
135416: IFFALSE 135426
// viewRange := 16 ;
135418: LD_ADDR_VAR 0 8
135422: PUSH
135423: LD_INT 16
135425: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
135426: LD_VAR 0 1
135430: PPUSH
135431: LD_VAR 0 2
135435: PPUSH
135436: LD_VAR 0 3
135440: PPUSH
135441: CALL_OW 297
135445: PUSH
135446: LD_VAR 0 5
135450: GREATER
135451: IFFALSE 135530
// begin ComMoveXY ( unit , x , y ) ;
135453: LD_VAR 0 1
135457: PPUSH
135458: LD_VAR 0 2
135462: PPUSH
135463: LD_VAR 0 3
135467: PPUSH
135468: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
135472: LD_INT 35
135474: PPUSH
135475: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
135479: LD_VAR 0 1
135483: PPUSH
135484: LD_VAR 0 2
135488: PPUSH
135489: LD_VAR 0 3
135493: PPUSH
135494: CALL 107852 0 3
135498: NOT
135499: IFFALSE 135503
// exit ;
135501: GO 135839
// until GetDistUnitXY ( unit , x , y ) < dist ;
135503: LD_VAR 0 1
135507: PPUSH
135508: LD_VAR 0 2
135512: PPUSH
135513: LD_VAR 0 3
135517: PPUSH
135518: CALL_OW 297
135522: PUSH
135523: LD_VAR 0 5
135527: LESS
135528: IFFALSE 135472
// end ; ComTurnXY ( unit , x , y ) ;
135530: LD_VAR 0 1
135534: PPUSH
135535: LD_VAR 0 2
135539: PPUSH
135540: LD_VAR 0 3
135544: PPUSH
135545: CALL_OW 118
// repeat if Multiplayer then
135549: LD_OWVAR 4
135553: IFFALSE 135564
// wait ( 35 ) else
135555: LD_INT 35
135557: PPUSH
135558: CALL_OW 67
135562: GO 135571
// wait ( 5 ) ;
135564: LD_INT 5
135566: PPUSH
135567: CALL_OW 67
// _d := GetDir ( unit ) ;
135571: LD_ADDR_VAR 0 11
135575: PUSH
135576: LD_VAR 0 1
135580: PPUSH
135581: CALL_OW 254
135585: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
135586: LD_ADDR_VAR 0 7
135590: PUSH
135591: LD_VAR 0 1
135595: PPUSH
135596: CALL_OW 250
135600: PPUSH
135601: LD_VAR 0 1
135605: PPUSH
135606: CALL_OW 251
135610: PPUSH
135611: LD_VAR 0 2
135615: PPUSH
135616: LD_VAR 0 3
135620: PPUSH
135621: CALL 110488 0 4
135625: ST_TO_ADDR
// until dir = _d ;
135626: LD_VAR 0 7
135630: PUSH
135631: LD_VAR 0 11
135635: EQUAL
135636: IFFALSE 135549
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
135638: LD_ADDR_VAR 0 9
135642: PUSH
135643: LD_VAR 0 1
135647: PPUSH
135648: CALL_OW 250
135652: PPUSH
135653: LD_VAR 0 7
135657: PPUSH
135658: LD_VAR 0 5
135662: PPUSH
135663: CALL_OW 272
135667: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
135668: LD_ADDR_VAR 0 10
135672: PUSH
135673: LD_VAR 0 1
135677: PPUSH
135678: CALL_OW 251
135682: PPUSH
135683: LD_VAR 0 7
135687: PPUSH
135688: LD_VAR 0 5
135692: PPUSH
135693: CALL_OW 273
135697: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
135698: LD_VAR 0 9
135702: PPUSH
135703: LD_VAR 0 10
135707: PPUSH
135708: CALL_OW 488
135712: NOT
135713: IFFALSE 135717
// exit ;
135715: GO 135839
// ComAnimCustom ( unit , 1 ) ;
135717: LD_VAR 0 1
135721: PPUSH
135722: LD_INT 1
135724: PPUSH
135725: CALL_OW 592
// p := 0 ;
135729: LD_ADDR_VAR 0 12
135733: PUSH
135734: LD_INT 0
135736: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
135737: LD_VAR 0 9
135741: PPUSH
135742: LD_VAR 0 10
135746: PPUSH
135747: LD_VAR 0 6
135751: PPUSH
135752: LD_VAR 0 8
135756: PPUSH
135757: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
135761: LD_INT 35
135763: PPUSH
135764: CALL_OW 67
// p := Inc ( p ) ;
135768: LD_ADDR_VAR 0 12
135772: PUSH
135773: LD_VAR 0 12
135777: PPUSH
135778: CALL 110444 0 1
135782: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
135783: LD_VAR 0 12
135787: PUSH
135788: LD_INT 3
135790: EQUAL
135791: IFTRUE 135805
135793: PUSH
135794: LD_VAR 0 1
135798: PPUSH
135799: CALL_OW 302
135803: NOT
135804: OR
135805: IFTRUE 135818
135807: PUSH
135808: LD_VAR 0 1
135812: PPUSH
135813: CALL_OW 301
135817: OR
135818: IFFALSE 135761
// RemoveSeeing ( _x , _y , side ) ;
135820: LD_VAR 0 9
135824: PPUSH
135825: LD_VAR 0 10
135829: PPUSH
135830: LD_VAR 0 6
135834: PPUSH
135835: CALL_OW 331
// end ; end_of_file
135839: LD_VAR 0 4
135843: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
135844: LD_INT 0
135846: PPUSH
135847: PPUSH
135848: PPUSH
135849: PPUSH
135850: PPUSH
135851: PPUSH
135852: PPUSH
135853: PPUSH
135854: PPUSH
135855: PPUSH
135856: PPUSH
135857: PPUSH
135858: PPUSH
135859: PPUSH
135860: PPUSH
135861: PPUSH
135862: PPUSH
135863: PPUSH
135864: PPUSH
135865: PPUSH
135866: PPUSH
135867: PPUSH
135868: PPUSH
135869: PPUSH
135870: PPUSH
135871: PPUSH
135872: PPUSH
135873: PPUSH
135874: PPUSH
135875: PPUSH
135876: PPUSH
135877: PPUSH
135878: PPUSH
135879: PPUSH
// if not list then
135880: LD_VAR 0 1
135884: NOT
135885: IFFALSE 135889
// exit ;
135887: GO 140608
// base := list [ 1 ] ;
135889: LD_ADDR_VAR 0 3
135893: PUSH
135894: LD_VAR 0 1
135898: PUSH
135899: LD_INT 1
135901: ARRAY
135902: ST_TO_ADDR
// group := list [ 2 ] ;
135903: LD_ADDR_VAR 0 4
135907: PUSH
135908: LD_VAR 0 1
135912: PUSH
135913: LD_INT 2
135915: ARRAY
135916: ST_TO_ADDR
// path := list [ 3 ] ;
135917: LD_ADDR_VAR 0 5
135921: PUSH
135922: LD_VAR 0 1
135926: PUSH
135927: LD_INT 3
135929: ARRAY
135930: ST_TO_ADDR
// flags := list [ 4 ] ;
135931: LD_ADDR_VAR 0 6
135935: PUSH
135936: LD_VAR 0 1
135940: PUSH
135941: LD_INT 4
135943: ARRAY
135944: ST_TO_ADDR
// mined := [ ] ;
135945: LD_ADDR_VAR 0 27
135949: PUSH
135950: EMPTY
135951: ST_TO_ADDR
// bombed := [ ] ;
135952: LD_ADDR_VAR 0 28
135956: PUSH
135957: EMPTY
135958: ST_TO_ADDR
// healers := [ ] ;
135959: LD_ADDR_VAR 0 31
135963: PUSH
135964: EMPTY
135965: ST_TO_ADDR
// to_heal := [ ] ;
135966: LD_ADDR_VAR 0 30
135970: PUSH
135971: EMPTY
135972: ST_TO_ADDR
// repairs := [ ] ;
135973: LD_ADDR_VAR 0 33
135977: PUSH
135978: EMPTY
135979: ST_TO_ADDR
// to_repair := [ ] ;
135980: LD_ADDR_VAR 0 32
135984: PUSH
135985: EMPTY
135986: ST_TO_ADDR
// if not group or not path then
135987: LD_VAR 0 4
135991: NOT
135992: IFTRUE 136001
135994: PUSH
135995: LD_VAR 0 5
135999: NOT
136000: OR
136001: IFFALSE 136005
// exit ;
136003: GO 140608
// side := GetSide ( group [ 1 ] ) ;
136005: LD_ADDR_VAR 0 35
136009: PUSH
136010: LD_VAR 0 4
136014: PUSH
136015: LD_INT 1
136017: ARRAY
136018: PPUSH
136019: CALL_OW 255
136023: ST_TO_ADDR
// if flags then
136024: LD_VAR 0 6
136028: IFFALSE 136172
// begin f_ignore_area := flags [ 1 ] ;
136030: LD_ADDR_VAR 0 17
136034: PUSH
136035: LD_VAR 0 6
136039: PUSH
136040: LD_INT 1
136042: ARRAY
136043: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
136044: LD_ADDR_VAR 0 18
136048: PUSH
136049: LD_VAR 0 6
136053: PUSH
136054: LD_INT 2
136056: ARRAY
136057: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
136058: LD_ADDR_VAR 0 19
136062: PUSH
136063: LD_VAR 0 6
136067: PUSH
136068: LD_INT 3
136070: ARRAY
136071: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
136072: LD_ADDR_VAR 0 20
136076: PUSH
136077: LD_VAR 0 6
136081: PUSH
136082: LD_INT 4
136084: ARRAY
136085: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
136086: LD_ADDR_VAR 0 21
136090: PUSH
136091: LD_VAR 0 6
136095: PUSH
136096: LD_INT 5
136098: ARRAY
136099: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
136100: LD_ADDR_VAR 0 22
136104: PUSH
136105: LD_VAR 0 6
136109: PUSH
136110: LD_INT 6
136112: ARRAY
136113: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
136114: LD_ADDR_VAR 0 23
136118: PUSH
136119: LD_VAR 0 6
136123: PUSH
136124: LD_INT 7
136126: ARRAY
136127: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
136128: LD_ADDR_VAR 0 24
136132: PUSH
136133: LD_VAR 0 6
136137: PUSH
136138: LD_INT 8
136140: ARRAY
136141: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
136142: LD_ADDR_VAR 0 25
136146: PUSH
136147: LD_VAR 0 6
136151: PUSH
136152: LD_INT 9
136154: ARRAY
136155: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
136156: LD_ADDR_VAR 0 26
136160: PUSH
136161: LD_VAR 0 6
136165: PUSH
136166: LD_INT 10
136168: ARRAY
136169: ST_TO_ADDR
// end else
136170: GO 136252
// begin f_ignore_area := false ;
136172: LD_ADDR_VAR 0 17
136176: PUSH
136177: LD_INT 0
136179: ST_TO_ADDR
// f_capture := false ;
136180: LD_ADDR_VAR 0 18
136184: PUSH
136185: LD_INT 0
136187: ST_TO_ADDR
// f_ignore_civ := false ;
136188: LD_ADDR_VAR 0 19
136192: PUSH
136193: LD_INT 0
136195: ST_TO_ADDR
// f_murder := false ;
136196: LD_ADDR_VAR 0 20
136200: PUSH
136201: LD_INT 0
136203: ST_TO_ADDR
// f_mines := false ;
136204: LD_ADDR_VAR 0 21
136208: PUSH
136209: LD_INT 0
136211: ST_TO_ADDR
// f_repair := false ;
136212: LD_ADDR_VAR 0 22
136216: PUSH
136217: LD_INT 0
136219: ST_TO_ADDR
// f_heal := false ;
136220: LD_ADDR_VAR 0 23
136224: PUSH
136225: LD_INT 0
136227: ST_TO_ADDR
// f_spacetime := false ;
136228: LD_ADDR_VAR 0 24
136232: PUSH
136233: LD_INT 0
136235: ST_TO_ADDR
// f_attack_depot := false ;
136236: LD_ADDR_VAR 0 25
136240: PUSH
136241: LD_INT 0
136243: ST_TO_ADDR
// f_crawl := false ;
136244: LD_ADDR_VAR 0 26
136248: PUSH
136249: LD_INT 0
136251: ST_TO_ADDR
// end ; if f_heal then
136252: LD_VAR 0 23
136256: IFFALSE 136283
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
136258: LD_ADDR_VAR 0 31
136262: PUSH
136263: LD_VAR 0 4
136267: PPUSH
136268: LD_INT 25
136270: PUSH
136271: LD_INT 4
136273: PUSH
136274: EMPTY
136275: LIST
136276: LIST
136277: PPUSH
136278: CALL_OW 72
136282: ST_TO_ADDR
// if f_repair then
136283: LD_VAR 0 22
136287: IFFALSE 136314
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
136289: LD_ADDR_VAR 0 33
136293: PUSH
136294: LD_VAR 0 4
136298: PPUSH
136299: LD_INT 25
136301: PUSH
136302: LD_INT 3
136304: PUSH
136305: EMPTY
136306: LIST
136307: LIST
136308: PPUSH
136309: CALL_OW 72
136313: ST_TO_ADDR
// units_path := [ ] ;
136314: LD_ADDR_VAR 0 16
136318: PUSH
136319: EMPTY
136320: ST_TO_ADDR
// for i = 1 to group do
136321: LD_ADDR_VAR 0 7
136325: PUSH
136326: DOUBLE
136327: LD_INT 1
136329: DEC
136330: ST_TO_ADDR
136331: LD_VAR 0 4
136335: PUSH
136336: FOR_TO
136337: IFFALSE 136366
// units_path := Replace ( units_path , i , path ) ;
136339: LD_ADDR_VAR 0 16
136343: PUSH
136344: LD_VAR 0 16
136348: PPUSH
136349: LD_VAR 0 7
136353: PPUSH
136354: LD_VAR 0 5
136358: PPUSH
136359: CALL_OW 1
136363: ST_TO_ADDR
136364: GO 136336
136366: POP
136367: POP
// repeat for i = group downto 1 do
136368: LD_ADDR_VAR 0 7
136372: PUSH
136373: DOUBLE
136374: LD_VAR 0 4
136378: INC
136379: ST_TO_ADDR
136380: LD_INT 1
136382: PUSH
136383: FOR_DOWNTO
136384: IFFALSE 140560
// begin wait ( 5 ) ;
136386: LD_INT 5
136388: PPUSH
136389: CALL_OW 67
// tmp := [ ] ;
136393: LD_ADDR_VAR 0 14
136397: PUSH
136398: EMPTY
136399: ST_TO_ADDR
// attacking := false ;
136400: LD_ADDR_VAR 0 29
136404: PUSH
136405: LD_INT 0
136407: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
136408: LD_VAR 0 4
136412: PUSH
136413: LD_VAR 0 7
136417: ARRAY
136418: PPUSH
136419: CALL_OW 301
136423: IFTRUE 136438
136425: PUSH
136426: LD_VAR 0 4
136430: PUSH
136431: LD_VAR 0 7
136435: ARRAY
136436: NOT
136437: OR
136438: IFFALSE 136547
// begin if GetType ( group [ i ] ) = unit_human then
136440: LD_VAR 0 4
136444: PUSH
136445: LD_VAR 0 7
136449: ARRAY
136450: PPUSH
136451: CALL_OW 247
136455: PUSH
136456: LD_INT 1
136458: EQUAL
136459: IFFALSE 136505
// begin to_heal := to_heal diff group [ i ] ;
136461: LD_ADDR_VAR 0 30
136465: PUSH
136466: LD_VAR 0 30
136470: PUSH
136471: LD_VAR 0 4
136475: PUSH
136476: LD_VAR 0 7
136480: ARRAY
136481: DIFF
136482: ST_TO_ADDR
// healers := healers diff group [ i ] ;
136483: LD_ADDR_VAR 0 31
136487: PUSH
136488: LD_VAR 0 31
136492: PUSH
136493: LD_VAR 0 4
136497: PUSH
136498: LD_VAR 0 7
136502: ARRAY
136503: DIFF
136504: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
136505: LD_ADDR_VAR 0 4
136509: PUSH
136510: LD_VAR 0 4
136514: PPUSH
136515: LD_VAR 0 7
136519: PPUSH
136520: CALL_OW 3
136524: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
136525: LD_ADDR_VAR 0 16
136529: PUSH
136530: LD_VAR 0 16
136534: PPUSH
136535: LD_VAR 0 7
136539: PPUSH
136540: CALL_OW 3
136544: ST_TO_ADDR
// continue ;
136545: GO 136383
// end ; if f_repair then
136547: LD_VAR 0 22
136551: IFFALSE 137048
// begin if GetType ( group [ i ] ) = unit_vehicle then
136553: LD_VAR 0 4
136557: PUSH
136558: LD_VAR 0 7
136562: ARRAY
136563: PPUSH
136564: CALL_OW 247
136568: PUSH
136569: LD_INT 2
136571: EQUAL
136572: IFFALSE 136766
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
136574: LD_VAR 0 4
136578: PUSH
136579: LD_VAR 0 7
136583: ARRAY
136584: PPUSH
136585: CALL_OW 256
136589: PUSH
136590: LD_INT 700
136592: LESS
136593: IFFALSE 136614
136595: PUSH
136596: LD_VAR 0 4
136600: PUSH
136601: LD_VAR 0 7
136605: ARRAY
136606: PUSH
136607: LD_VAR 0 32
136611: IN
136612: NOT
136613: AND
136614: IFFALSE 136638
// to_repair := to_repair union group [ i ] ;
136616: LD_ADDR_VAR 0 32
136620: PUSH
136621: LD_VAR 0 32
136625: PUSH
136626: LD_VAR 0 4
136630: PUSH
136631: LD_VAR 0 7
136635: ARRAY
136636: UNION
136637: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
136638: LD_VAR 0 4
136642: PUSH
136643: LD_VAR 0 7
136647: ARRAY
136648: PPUSH
136649: CALL_OW 256
136653: PUSH
136654: LD_INT 1000
136656: EQUAL
136657: IFFALSE 136677
136659: PUSH
136660: LD_VAR 0 4
136664: PUSH
136665: LD_VAR 0 7
136669: ARRAY
136670: PUSH
136671: LD_VAR 0 32
136675: IN
136676: AND
136677: IFFALSE 136701
// to_repair := to_repair diff group [ i ] ;
136679: LD_ADDR_VAR 0 32
136683: PUSH
136684: LD_VAR 0 32
136688: PUSH
136689: LD_VAR 0 4
136693: PUSH
136694: LD_VAR 0 7
136698: ARRAY
136699: DIFF
136700: ST_TO_ADDR
// if group [ i ] in to_repair then
136701: LD_VAR 0 4
136705: PUSH
136706: LD_VAR 0 7
136710: ARRAY
136711: PUSH
136712: LD_VAR 0 32
136716: IN
136717: IFFALSE 136764
// begin if not IsInArea ( group [ i ] , f_repair ) then
136719: LD_VAR 0 4
136723: PUSH
136724: LD_VAR 0 7
136728: ARRAY
136729: PPUSH
136730: LD_VAR 0 22
136734: PPUSH
136735: CALL_OW 308
136739: NOT
136740: IFFALSE 136762
// ComMoveToArea ( group [ i ] , f_repair ) ;
136742: LD_VAR 0 4
136746: PUSH
136747: LD_VAR 0 7
136751: ARRAY
136752: PPUSH
136753: LD_VAR 0 22
136757: PPUSH
136758: CALL_OW 113
// continue ;
136762: GO 136383
// end ; end else
136764: GO 137048
// if group [ i ] in repairs then
136766: LD_VAR 0 4
136770: PUSH
136771: LD_VAR 0 7
136775: ARRAY
136776: PUSH
136777: LD_VAR 0 33
136781: IN
136782: IFFALSE 137048
// begin if IsInUnit ( group [ i ] ) then
136784: LD_VAR 0 4
136788: PUSH
136789: LD_VAR 0 7
136793: ARRAY
136794: PPUSH
136795: CALL_OW 310
136799: IFFALSE 136869
// begin z := IsInUnit ( group [ i ] ) ;
136801: LD_ADDR_VAR 0 13
136805: PUSH
136806: LD_VAR 0 4
136810: PUSH
136811: LD_VAR 0 7
136815: ARRAY
136816: PPUSH
136817: CALL_OW 310
136821: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
136822: LD_VAR 0 13
136826: PUSH
136827: LD_VAR 0 32
136831: IN
136832: IFFALSE 136850
136834: PUSH
136835: LD_VAR 0 13
136839: PPUSH
136840: LD_VAR 0 22
136844: PPUSH
136845: CALL_OW 308
136849: AND
136850: IFFALSE 136867
// ComExitVehicle ( group [ i ] ) ;
136852: LD_VAR 0 4
136856: PUSH
136857: LD_VAR 0 7
136861: ARRAY
136862: PPUSH
136863: CALL_OW 121
// end else
136867: GO 137048
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
136869: LD_ADDR_VAR 0 13
136873: PUSH
136874: LD_VAR 0 4
136878: PPUSH
136879: LD_INT 95
136881: PUSH
136882: LD_VAR 0 22
136886: PUSH
136887: EMPTY
136888: LIST
136889: LIST
136890: PUSH
136891: LD_INT 58
136893: PUSH
136894: EMPTY
136895: LIST
136896: PUSH
136897: EMPTY
136898: LIST
136899: LIST
136900: PPUSH
136901: CALL_OW 72
136905: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
136906: LD_VAR 0 4
136910: PUSH
136911: LD_VAR 0 7
136915: ARRAY
136916: PPUSH
136917: CALL_OW 314
136921: NOT
136922: IFFALSE 137046
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
136924: LD_ADDR_VAR 0 10
136928: PUSH
136929: LD_VAR 0 13
136933: PPUSH
136934: LD_VAR 0 4
136938: PUSH
136939: LD_VAR 0 7
136943: ARRAY
136944: PPUSH
136945: CALL_OW 74
136949: ST_TO_ADDR
// if not x then
136950: LD_VAR 0 10
136954: NOT
136955: IFFALSE 136959
// continue ;
136957: GO 136383
// if GetLives ( x ) < 1000 then
136959: LD_VAR 0 10
136963: PPUSH
136964: CALL_OW 256
136968: PUSH
136969: LD_INT 1000
136971: LESS
136972: IFFALSE 136996
// ComRepairVehicle ( group [ i ] , x ) else
136974: LD_VAR 0 4
136978: PUSH
136979: LD_VAR 0 7
136983: ARRAY
136984: PPUSH
136985: LD_VAR 0 10
136989: PPUSH
136990: CALL_OW 129
136994: GO 137046
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
136996: LD_VAR 0 23
137000: IFFALSE 137023
137002: PUSH
137003: LD_VAR 0 4
137007: PUSH
137008: LD_VAR 0 7
137012: ARRAY
137013: PPUSH
137014: CALL_OW 256
137018: PUSH
137019: LD_INT 1000
137021: LESS
137022: AND
137023: NOT
137024: IFFALSE 137046
// ComEnterUnit ( group [ i ] , x ) ;
137026: LD_VAR 0 4
137030: PUSH
137031: LD_VAR 0 7
137035: ARRAY
137036: PPUSH
137037: LD_VAR 0 10
137041: PPUSH
137042: CALL_OW 120
// end ; continue ;
137046: GO 136383
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
137048: LD_VAR 0 23
137052: IFFALSE 137075
137054: PUSH
137055: LD_VAR 0 4
137059: PUSH
137060: LD_VAR 0 7
137064: ARRAY
137065: PPUSH
137066: CALL_OW 247
137070: PUSH
137071: LD_INT 1
137073: EQUAL
137074: AND
137075: IFFALSE 137559
// begin if group [ i ] in healers then
137077: LD_VAR 0 4
137081: PUSH
137082: LD_VAR 0 7
137086: ARRAY
137087: PUSH
137088: LD_VAR 0 31
137092: IN
137093: IFFALSE 137370
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
137095: LD_VAR 0 4
137099: PUSH
137100: LD_VAR 0 7
137104: ARRAY
137105: PPUSH
137106: LD_VAR 0 23
137110: PPUSH
137111: CALL_OW 308
137115: NOT
137116: IFFALSE 137136
137118: PUSH
137119: LD_VAR 0 4
137123: PUSH
137124: LD_VAR 0 7
137128: ARRAY
137129: PPUSH
137130: CALL_OW 314
137134: NOT
137135: AND
137136: IFFALSE 137160
// ComMoveToArea ( group [ i ] , f_heal ) else
137138: LD_VAR 0 4
137142: PUSH
137143: LD_VAR 0 7
137147: ARRAY
137148: PPUSH
137149: LD_VAR 0 23
137153: PPUSH
137154: CALL_OW 113
137158: GO 137368
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
137160: LD_VAR 0 4
137164: PUSH
137165: LD_VAR 0 7
137169: ARRAY
137170: PPUSH
137171: CALL 106427 0 1
137175: PPUSH
137176: CALL_OW 256
137180: PUSH
137181: LD_INT 1000
137183: EQUAL
137184: IFFALSE 137203
// ComStop ( group [ i ] ) else
137186: LD_VAR 0 4
137190: PUSH
137191: LD_VAR 0 7
137195: ARRAY
137196: PPUSH
137197: CALL_OW 141
137201: GO 137368
// if not HasTask ( group [ i ] ) and to_heal then
137203: LD_VAR 0 4
137207: PUSH
137208: LD_VAR 0 7
137212: ARRAY
137213: PPUSH
137214: CALL_OW 314
137218: NOT
137219: IFFALSE 137227
137221: PUSH
137222: LD_VAR 0 30
137226: AND
137227: IFFALSE 137368
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
137229: LD_ADDR_VAR 0 13
137233: PUSH
137234: LD_VAR 0 30
137238: PPUSH
137239: LD_INT 3
137241: PUSH
137242: LD_INT 54
137244: PUSH
137245: EMPTY
137246: LIST
137247: PUSH
137248: EMPTY
137249: LIST
137250: LIST
137251: PPUSH
137252: CALL_OW 72
137256: PPUSH
137257: LD_VAR 0 4
137261: PUSH
137262: LD_VAR 0 7
137266: ARRAY
137267: PPUSH
137268: CALL_OW 74
137272: ST_TO_ADDR
// if z then
137273: LD_VAR 0 13
137277: IFFALSE 137368
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
137279: LD_INT 91
137281: PUSH
137282: LD_VAR 0 13
137286: PUSH
137287: LD_INT 10
137289: PUSH
137290: EMPTY
137291: LIST
137292: LIST
137293: LIST
137294: PUSH
137295: LD_INT 81
137297: PUSH
137298: LD_VAR 0 13
137302: PPUSH
137303: CALL_OW 255
137307: PUSH
137308: EMPTY
137309: LIST
137310: LIST
137311: PUSH
137312: EMPTY
137313: LIST
137314: LIST
137315: PPUSH
137316: CALL_OW 69
137320: PUSH
137321: LD_INT 0
137323: EQUAL
137324: IFFALSE 137348
// ComHeal ( group [ i ] , z ) else
137326: LD_VAR 0 4
137330: PUSH
137331: LD_VAR 0 7
137335: ARRAY
137336: PPUSH
137337: LD_VAR 0 13
137341: PPUSH
137342: CALL_OW 128
137346: GO 137368
// ComMoveToArea ( group [ i ] , f_heal ) ;
137348: LD_VAR 0 4
137352: PUSH
137353: LD_VAR 0 7
137357: ARRAY
137358: PPUSH
137359: LD_VAR 0 23
137363: PPUSH
137364: CALL_OW 113
// end ; continue ;
137368: GO 136383
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
137370: LD_VAR 0 4
137374: PUSH
137375: LD_VAR 0 7
137379: ARRAY
137380: PPUSH
137381: CALL_OW 256
137385: PUSH
137386: LD_INT 700
137388: LESS
137389: IFFALSE 137410
137391: PUSH
137392: LD_VAR 0 4
137396: PUSH
137397: LD_VAR 0 7
137401: ARRAY
137402: PUSH
137403: LD_VAR 0 30
137407: IN
137408: NOT
137409: AND
137410: IFFALSE 137434
// to_heal := to_heal union group [ i ] ;
137412: LD_ADDR_VAR 0 30
137416: PUSH
137417: LD_VAR 0 30
137421: PUSH
137422: LD_VAR 0 4
137426: PUSH
137427: LD_VAR 0 7
137431: ARRAY
137432: UNION
137433: ST_TO_ADDR
// if group [ i ] in to_heal then
137434: LD_VAR 0 4
137438: PUSH
137439: LD_VAR 0 7
137443: ARRAY
137444: PUSH
137445: LD_VAR 0 30
137449: IN
137450: IFFALSE 137559
// begin if GetLives ( group [ i ] ) = 1000 then
137452: LD_VAR 0 4
137456: PUSH
137457: LD_VAR 0 7
137461: ARRAY
137462: PPUSH
137463: CALL_OW 256
137467: PUSH
137468: LD_INT 1000
137470: EQUAL
137471: IFFALSE 137497
// to_heal := to_heal diff group [ i ] else
137473: LD_ADDR_VAR 0 30
137477: PUSH
137478: LD_VAR 0 30
137482: PUSH
137483: LD_VAR 0 4
137487: PUSH
137488: LD_VAR 0 7
137492: ARRAY
137493: DIFF
137494: ST_TO_ADDR
137495: GO 137559
// begin if not IsInArea ( group [ i ] , to_heal ) then
137497: LD_VAR 0 4
137501: PUSH
137502: LD_VAR 0 7
137506: ARRAY
137507: PPUSH
137508: LD_VAR 0 30
137512: PPUSH
137513: CALL_OW 308
137517: NOT
137518: IFFALSE 137542
// ComMoveToArea ( group [ i ] , f_heal ) else
137520: LD_VAR 0 4
137524: PUSH
137525: LD_VAR 0 7
137529: ARRAY
137530: PPUSH
137531: LD_VAR 0 23
137535: PPUSH
137536: CALL_OW 113
137540: GO 137557
// ComHold ( group [ i ] ) ;
137542: LD_VAR 0 4
137546: PUSH
137547: LD_VAR 0 7
137551: ARRAY
137552: PPUSH
137553: CALL_OW 140
// continue ;
137557: GO 136383
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
137559: LD_VAR 0 4
137563: PUSH
137564: LD_VAR 0 7
137568: ARRAY
137569: PPUSH
137570: LD_INT 10
137572: PPUSH
137573: CALL 104036 0 2
137577: NOT
137578: IFFALSE 137596
137580: PUSH
137581: LD_VAR 0 16
137585: PUSH
137586: LD_VAR 0 7
137590: ARRAY
137591: PUSH
137592: EMPTY
137593: EQUAL
137594: NOT
137595: AND
137596: IFFALSE 137862
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
137598: LD_VAR 0 4
137602: PUSH
137603: LD_VAR 0 7
137607: ARRAY
137608: PPUSH
137609: CALL_OW 262
137613: PUSH
137614: LD_INT 1
137616: PUSH
137617: LD_INT 2
137619: PUSH
137620: EMPTY
137621: LIST
137622: LIST
137623: IN
137624: IFFALSE 137665
// if GetFuel ( group [ i ] ) < 10 then
137626: LD_VAR 0 4
137630: PUSH
137631: LD_VAR 0 7
137635: ARRAY
137636: PPUSH
137637: CALL_OW 261
137641: PUSH
137642: LD_INT 10
137644: LESS
137645: IFFALSE 137665
// SetFuel ( group [ i ] , 12 ) ;
137647: LD_VAR 0 4
137651: PUSH
137652: LD_VAR 0 7
137656: ARRAY
137657: PPUSH
137658: LD_INT 12
137660: PPUSH
137661: CALL_OW 240
// if units_path [ i ] then
137665: LD_VAR 0 16
137669: PUSH
137670: LD_VAR 0 7
137674: ARRAY
137675: IFFALSE 137860
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
137677: LD_VAR 0 4
137681: PUSH
137682: LD_VAR 0 7
137686: ARRAY
137687: PPUSH
137688: LD_VAR 0 16
137692: PUSH
137693: LD_VAR 0 7
137697: ARRAY
137698: PUSH
137699: LD_INT 1
137701: ARRAY
137702: PUSH
137703: LD_INT 1
137705: ARRAY
137706: PPUSH
137707: LD_VAR 0 16
137711: PUSH
137712: LD_VAR 0 7
137716: ARRAY
137717: PUSH
137718: LD_INT 1
137720: ARRAY
137721: PUSH
137722: LD_INT 2
137724: ARRAY
137725: PPUSH
137726: CALL_OW 297
137730: PUSH
137731: LD_INT 6
137733: GREATER
137734: IFFALSE 137809
// begin if not HasTask ( group [ i ] ) then
137736: LD_VAR 0 4
137740: PUSH
137741: LD_VAR 0 7
137745: ARRAY
137746: PPUSH
137747: CALL_OW 314
137751: NOT
137752: IFFALSE 137807
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
137754: LD_VAR 0 4
137758: PUSH
137759: LD_VAR 0 7
137763: ARRAY
137764: PPUSH
137765: LD_VAR 0 16
137769: PUSH
137770: LD_VAR 0 7
137774: ARRAY
137775: PUSH
137776: LD_INT 1
137778: ARRAY
137779: PUSH
137780: LD_INT 1
137782: ARRAY
137783: PPUSH
137784: LD_VAR 0 16
137788: PUSH
137789: LD_VAR 0 7
137793: ARRAY
137794: PUSH
137795: LD_INT 1
137797: ARRAY
137798: PUSH
137799: LD_INT 2
137801: ARRAY
137802: PPUSH
137803: CALL_OW 114
// end else
137807: GO 137860
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
137809: LD_ADDR_VAR 0 15
137813: PUSH
137814: LD_VAR 0 16
137818: PUSH
137819: LD_VAR 0 7
137823: ARRAY
137824: PPUSH
137825: LD_INT 1
137827: PPUSH
137828: CALL_OW 3
137832: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
137833: LD_ADDR_VAR 0 16
137837: PUSH
137838: LD_VAR 0 16
137842: PPUSH
137843: LD_VAR 0 7
137847: PPUSH
137848: LD_VAR 0 15
137852: PPUSH
137853: CALL_OW 1
137857: ST_TO_ADDR
// continue ;
137858: GO 136383
// end ; end ; end else
137860: GO 140558
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
137862: LD_ADDR_VAR 0 14
137866: PUSH
137867: LD_INT 81
137869: PUSH
137870: LD_VAR 0 4
137874: PUSH
137875: LD_VAR 0 7
137879: ARRAY
137880: PPUSH
137881: CALL_OW 255
137885: PUSH
137886: EMPTY
137887: LIST
137888: LIST
137889: PPUSH
137890: CALL_OW 69
137894: ST_TO_ADDR
// if not tmp then
137895: LD_VAR 0 14
137899: NOT
137900: IFFALSE 137904
// continue ;
137902: GO 136383
// if f_ignore_area then
137904: LD_VAR 0 17
137908: IFFALSE 137996
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
137910: LD_ADDR_VAR 0 15
137914: PUSH
137915: LD_VAR 0 14
137919: PPUSH
137920: LD_INT 3
137922: PUSH
137923: LD_INT 92
137925: PUSH
137926: LD_VAR 0 17
137930: PUSH
137931: LD_INT 1
137933: ARRAY
137934: PUSH
137935: LD_VAR 0 17
137939: PUSH
137940: LD_INT 2
137942: ARRAY
137943: PUSH
137944: LD_VAR 0 17
137948: PUSH
137949: LD_INT 3
137951: ARRAY
137952: PUSH
137953: EMPTY
137954: LIST
137955: LIST
137956: LIST
137957: LIST
137958: PUSH
137959: EMPTY
137960: LIST
137961: LIST
137962: PPUSH
137963: CALL_OW 72
137967: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
137968: LD_VAR 0 14
137972: PUSH
137973: LD_VAR 0 15
137977: DIFF
137978: IFFALSE 137996
// tmp := tmp diff tmp2 ;
137980: LD_ADDR_VAR 0 14
137984: PUSH
137985: LD_VAR 0 14
137989: PUSH
137990: LD_VAR 0 15
137994: DIFF
137995: ST_TO_ADDR
// end ; if not f_murder then
137996: LD_VAR 0 20
138000: NOT
138001: IFFALSE 138059
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
138003: LD_ADDR_VAR 0 15
138007: PUSH
138008: LD_VAR 0 14
138012: PPUSH
138013: LD_INT 3
138015: PUSH
138016: LD_INT 50
138018: PUSH
138019: EMPTY
138020: LIST
138021: PUSH
138022: EMPTY
138023: LIST
138024: LIST
138025: PPUSH
138026: CALL_OW 72
138030: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
138031: LD_VAR 0 14
138035: PUSH
138036: LD_VAR 0 15
138040: DIFF
138041: IFFALSE 138059
// tmp := tmp diff tmp2 ;
138043: LD_ADDR_VAR 0 14
138047: PUSH
138048: LD_VAR 0 14
138052: PUSH
138053: LD_VAR 0 15
138057: DIFF
138058: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
138059: LD_ADDR_VAR 0 14
138063: PUSH
138064: LD_VAR 0 4
138068: PUSH
138069: LD_VAR 0 7
138073: ARRAY
138074: PPUSH
138075: LD_VAR 0 14
138079: PPUSH
138080: LD_INT 1
138082: PPUSH
138083: LD_INT 1
138085: PPUSH
138086: CALL 76458 0 4
138090: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
138091: LD_VAR 0 4
138095: PUSH
138096: LD_VAR 0 7
138100: ARRAY
138101: PPUSH
138102: CALL_OW 257
138106: PUSH
138107: LD_INT 1
138109: EQUAL
138110: IFFALSE 138570
// begin if WantPlant ( group [ i ] ) then
138112: LD_VAR 0 4
138116: PUSH
138117: LD_VAR 0 7
138121: ARRAY
138122: PPUSH
138123: CALL 75959 0 1
138127: IFFALSE 138131
// continue ;
138129: GO 136383
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
138131: LD_VAR 0 18
138135: IFFALSE 138155
138137: PUSH
138138: LD_VAR 0 4
138142: PUSH
138143: LD_VAR 0 7
138147: ARRAY
138148: PPUSH
138149: CALL_OW 310
138153: NOT
138154: AND
138155: IFFALSE 138198
138157: PUSH
138158: LD_VAR 0 14
138162: PUSH
138163: LD_INT 1
138165: ARRAY
138166: PUSH
138167: LD_VAR 0 14
138171: PPUSH
138172: LD_INT 21
138174: PUSH
138175: LD_INT 2
138177: PUSH
138178: EMPTY
138179: LIST
138180: LIST
138181: PUSH
138182: LD_INT 58
138184: PUSH
138185: EMPTY
138186: LIST
138187: PUSH
138188: EMPTY
138189: LIST
138190: LIST
138191: PPUSH
138192: CALL_OW 72
138196: IN
138197: AND
138198: IFFALSE 138234
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
138200: LD_VAR 0 4
138204: PUSH
138205: LD_VAR 0 7
138209: ARRAY
138210: PPUSH
138211: LD_VAR 0 14
138215: PUSH
138216: LD_INT 1
138218: ARRAY
138219: PPUSH
138220: CALL_OW 120
// attacking := true ;
138224: LD_ADDR_VAR 0 29
138228: PUSH
138229: LD_INT 1
138231: ST_TO_ADDR
// continue ;
138232: GO 136383
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
138234: LD_VAR 0 26
138238: IFFALSE 138261
138240: PUSH
138241: LD_VAR 0 4
138245: PUSH
138246: LD_VAR 0 7
138250: ARRAY
138251: PPUSH
138252: CALL_OW 257
138256: PUSH
138257: LD_INT 1
138259: EQUAL
138260: AND
138261: IFFALSE 138284
138263: PUSH
138264: LD_VAR 0 4
138268: PUSH
138269: LD_VAR 0 7
138273: ARRAY
138274: PPUSH
138275: CALL_OW 256
138279: PUSH
138280: LD_INT 800
138282: LESS
138283: AND
138284: IFFALSE 138304
138286: PUSH
138287: LD_VAR 0 4
138291: PUSH
138292: LD_VAR 0 7
138296: ARRAY
138297: PPUSH
138298: CALL_OW 318
138302: NOT
138303: AND
138304: IFFALSE 138321
// ComCrawl ( group [ i ] ) ;
138306: LD_VAR 0 4
138310: PUSH
138311: LD_VAR 0 7
138315: ARRAY
138316: PPUSH
138317: CALL_OW 137
// if f_mines then
138321: LD_VAR 0 21
138325: IFFALSE 138570
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
138327: LD_VAR 0 14
138331: PUSH
138332: LD_INT 1
138334: ARRAY
138335: PPUSH
138336: CALL_OW 247
138340: PUSH
138341: LD_INT 3
138343: EQUAL
138344: IFFALSE 138363
138346: PUSH
138347: LD_VAR 0 14
138351: PUSH
138352: LD_INT 1
138354: ARRAY
138355: PUSH
138356: LD_VAR 0 27
138360: IN
138361: NOT
138362: AND
138363: IFFALSE 138570
// begin x := GetX ( tmp [ 1 ] ) ;
138365: LD_ADDR_VAR 0 10
138369: PUSH
138370: LD_VAR 0 14
138374: PUSH
138375: LD_INT 1
138377: ARRAY
138378: PPUSH
138379: CALL_OW 250
138383: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
138384: LD_ADDR_VAR 0 11
138388: PUSH
138389: LD_VAR 0 14
138393: PUSH
138394: LD_INT 1
138396: ARRAY
138397: PPUSH
138398: CALL_OW 251
138402: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
138403: LD_ADDR_VAR 0 12
138407: PUSH
138408: LD_VAR 0 4
138412: PUSH
138413: LD_VAR 0 7
138417: ARRAY
138418: PPUSH
138419: CALL 104121 0 1
138423: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
138424: LD_VAR 0 4
138428: PUSH
138429: LD_VAR 0 7
138433: ARRAY
138434: PPUSH
138435: LD_VAR 0 10
138439: PPUSH
138440: LD_VAR 0 11
138444: PPUSH
138445: LD_VAR 0 14
138449: PUSH
138450: LD_INT 1
138452: ARRAY
138453: PPUSH
138454: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
138458: LD_VAR 0 4
138462: PUSH
138463: LD_VAR 0 7
138467: ARRAY
138468: PPUSH
138469: LD_VAR 0 10
138473: PPUSH
138474: LD_VAR 0 12
138478: PPUSH
138479: LD_INT 7
138481: PPUSH
138482: CALL_OW 272
138486: PPUSH
138487: LD_VAR 0 11
138491: PPUSH
138492: LD_VAR 0 12
138496: PPUSH
138497: LD_INT 7
138499: PPUSH
138500: CALL_OW 273
138504: PPUSH
138505: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
138509: LD_VAR 0 4
138513: PUSH
138514: LD_VAR 0 7
138518: ARRAY
138519: PPUSH
138520: LD_INT 71
138522: PPUSH
138523: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
138527: LD_ADDR_VAR 0 27
138531: PUSH
138532: LD_VAR 0 27
138536: PPUSH
138537: LD_VAR 0 27
138541: PUSH
138542: LD_INT 1
138544: PLUS
138545: PPUSH
138546: LD_VAR 0 14
138550: PUSH
138551: LD_INT 1
138553: ARRAY
138554: PPUSH
138555: CALL_OW 1
138559: ST_TO_ADDR
// attacking := true ;
138560: LD_ADDR_VAR 0 29
138564: PUSH
138565: LD_INT 1
138567: ST_TO_ADDR
// continue ;
138568: GO 136383
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
138570: LD_VAR 0 4
138574: PUSH
138575: LD_VAR 0 7
138579: ARRAY
138580: PPUSH
138581: CALL_OW 257
138585: PUSH
138586: LD_INT 17
138588: EQUAL
138589: IFFALSE 138613
138591: PUSH
138592: LD_VAR 0 4
138596: PUSH
138597: LD_VAR 0 7
138601: ARRAY
138602: PPUSH
138603: CALL_OW 110
138607: PUSH
138608: LD_INT 71
138610: EQUAL
138611: NOT
138612: AND
138613: IFFALSE 138759
// begin attacking := false ;
138615: LD_ADDR_VAR 0 29
138619: PUSH
138620: LD_INT 0
138622: ST_TO_ADDR
// k := 5 ;
138623: LD_ADDR_VAR 0 9
138627: PUSH
138628: LD_INT 5
138630: ST_TO_ADDR
// if tmp < k then
138631: LD_VAR 0 14
138635: PUSH
138636: LD_VAR 0 9
138640: LESS
138641: IFFALSE 138653
// k := tmp ;
138643: LD_ADDR_VAR 0 9
138647: PUSH
138648: LD_VAR 0 14
138652: ST_TO_ADDR
// for j = 1 to k do
138653: LD_ADDR_VAR 0 8
138657: PUSH
138658: DOUBLE
138659: LD_INT 1
138661: DEC
138662: ST_TO_ADDR
138663: LD_VAR 0 9
138667: PUSH
138668: FOR_TO
138669: IFFALSE 138757
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
138671: LD_VAR 0 14
138675: PUSH
138676: LD_VAR 0 8
138680: ARRAY
138681: PUSH
138682: LD_VAR 0 14
138686: PPUSH
138687: LD_INT 58
138689: PUSH
138690: EMPTY
138691: LIST
138692: PPUSH
138693: CALL_OW 72
138697: IN
138698: NOT
138699: IFFALSE 138755
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
138701: LD_VAR 0 4
138705: PUSH
138706: LD_VAR 0 7
138710: ARRAY
138711: PPUSH
138712: LD_VAR 0 14
138716: PUSH
138717: LD_VAR 0 8
138721: ARRAY
138722: PPUSH
138723: CALL_OW 115
// attacking := true ;
138727: LD_ADDR_VAR 0 29
138731: PUSH
138732: LD_INT 1
138734: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
138735: LD_VAR 0 4
138739: PUSH
138740: LD_VAR 0 7
138744: ARRAY
138745: PPUSH
138746: LD_INT 71
138748: PPUSH
138749: CALL_OW 109
// continue ;
138753: GO 138668
// end ; end ;
138755: GO 138668
138757: POP
138758: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
138759: LD_VAR 0 4
138763: PUSH
138764: LD_VAR 0 7
138768: ARRAY
138769: PPUSH
138770: CALL_OW 257
138774: PUSH
138775: LD_INT 8
138777: EQUAL
138778: IFTRUE 138816
138780: PUSH
138781: LD_VAR 0 4
138785: PUSH
138786: LD_VAR 0 7
138790: ARRAY
138791: PPUSH
138792: CALL_OW 264
138796: PUSH
138797: LD_INT 28
138799: PUSH
138800: LD_INT 45
138802: PUSH
138803: LD_INT 7
138805: PUSH
138806: LD_INT 47
138808: PUSH
138809: EMPTY
138810: LIST
138811: LIST
138812: LIST
138813: LIST
138814: IN
138815: OR
138816: IFFALSE 139072
// begin attacking := false ;
138818: LD_ADDR_VAR 0 29
138822: PUSH
138823: LD_INT 0
138825: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
138826: LD_VAR 0 14
138830: PUSH
138831: LD_INT 1
138833: ARRAY
138834: PPUSH
138835: CALL_OW 266
138839: PUSH
138840: LD_INT 32
138842: PUSH
138843: LD_INT 31
138845: PUSH
138846: LD_INT 33
138848: PUSH
138849: LD_INT 4
138851: PUSH
138852: LD_INT 5
138854: PUSH
138855: EMPTY
138856: LIST
138857: LIST
138858: LIST
138859: LIST
138860: LIST
138861: IN
138862: IFFALSE 139048
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
138864: LD_ADDR_VAR 0 9
138868: PUSH
138869: LD_VAR 0 14
138873: PUSH
138874: LD_INT 1
138876: ARRAY
138877: PPUSH
138878: CALL_OW 266
138882: PPUSH
138883: LD_VAR 0 14
138887: PUSH
138888: LD_INT 1
138890: ARRAY
138891: PPUSH
138892: CALL_OW 250
138896: PPUSH
138897: LD_VAR 0 14
138901: PUSH
138902: LD_INT 1
138904: ARRAY
138905: PPUSH
138906: CALL_OW 251
138910: PPUSH
138911: LD_VAR 0 14
138915: PUSH
138916: LD_INT 1
138918: ARRAY
138919: PPUSH
138920: CALL_OW 254
138924: PPUSH
138925: LD_VAR 0 14
138929: PUSH
138930: LD_INT 1
138932: ARRAY
138933: PPUSH
138934: CALL_OW 248
138938: PPUSH
138939: LD_INT 0
138941: PPUSH
138942: CALL 85479 0 6
138946: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
138947: LD_ADDR_VAR 0 8
138951: PUSH
138952: LD_VAR 0 4
138956: PUSH
138957: LD_VAR 0 7
138961: ARRAY
138962: PPUSH
138963: LD_VAR 0 9
138967: PPUSH
138968: CALL 104234 0 2
138972: ST_TO_ADDR
// if j then
138973: LD_VAR 0 8
138977: IFFALSE 139046
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
138979: LD_VAR 0 8
138983: PUSH
138984: LD_INT 1
138986: ARRAY
138987: PPUSH
138988: LD_VAR 0 8
138992: PUSH
138993: LD_INT 2
138995: ARRAY
138996: PPUSH
138997: CALL_OW 488
139001: IFFALSE 139046
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
139003: LD_VAR 0 4
139007: PUSH
139008: LD_VAR 0 7
139012: ARRAY
139013: PPUSH
139014: LD_VAR 0 8
139018: PUSH
139019: LD_INT 1
139021: ARRAY
139022: PPUSH
139023: LD_VAR 0 8
139027: PUSH
139028: LD_INT 2
139030: ARRAY
139031: PPUSH
139032: CALL_OW 116
// attacking := true ;
139036: LD_ADDR_VAR 0 29
139040: PUSH
139041: LD_INT 1
139043: ST_TO_ADDR
// continue ;
139044: GO 136383
// end ; end else
139046: GO 139072
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139048: LD_VAR 0 4
139052: PUSH
139053: LD_VAR 0 7
139057: ARRAY
139058: PPUSH
139059: LD_VAR 0 14
139063: PUSH
139064: LD_INT 1
139066: ARRAY
139067: PPUSH
139068: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
139072: LD_VAR 0 4
139076: PUSH
139077: LD_VAR 0 7
139081: ARRAY
139082: PPUSH
139083: CALL_OW 265
139087: PUSH
139088: LD_INT 11
139090: EQUAL
139091: IFFALSE 139369
// begin k := 10 ;
139093: LD_ADDR_VAR 0 9
139097: PUSH
139098: LD_INT 10
139100: ST_TO_ADDR
// x := 0 ;
139101: LD_ADDR_VAR 0 10
139105: PUSH
139106: LD_INT 0
139108: ST_TO_ADDR
// if tmp < k then
139109: LD_VAR 0 14
139113: PUSH
139114: LD_VAR 0 9
139118: LESS
139119: IFFALSE 139131
// k := tmp ;
139121: LD_ADDR_VAR 0 9
139125: PUSH
139126: LD_VAR 0 14
139130: ST_TO_ADDR
// for j = k downto 1 do
139131: LD_ADDR_VAR 0 8
139135: PUSH
139136: DOUBLE
139137: LD_VAR 0 9
139141: INC
139142: ST_TO_ADDR
139143: LD_INT 1
139145: PUSH
139146: FOR_DOWNTO
139147: IFFALSE 139222
// begin if GetType ( tmp [ j ] ) = unit_human then
139149: LD_VAR 0 14
139153: PUSH
139154: LD_VAR 0 8
139158: ARRAY
139159: PPUSH
139160: CALL_OW 247
139164: PUSH
139165: LD_INT 1
139167: EQUAL
139168: IFFALSE 139220
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
139170: LD_VAR 0 4
139174: PUSH
139175: LD_VAR 0 7
139179: ARRAY
139180: PPUSH
139181: LD_VAR 0 14
139185: PUSH
139186: LD_VAR 0 8
139190: ARRAY
139191: PPUSH
139192: CALL 104492 0 2
// x := tmp [ j ] ;
139196: LD_ADDR_VAR 0 10
139200: PUSH
139201: LD_VAR 0 14
139205: PUSH
139206: LD_VAR 0 8
139210: ARRAY
139211: ST_TO_ADDR
// attacking := true ;
139212: LD_ADDR_VAR 0 29
139216: PUSH
139217: LD_INT 1
139219: ST_TO_ADDR
// end ; end ;
139220: GO 139146
139222: POP
139223: POP
// if not x then
139224: LD_VAR 0 10
139228: NOT
139229: IFFALSE 139369
// begin attacking := true ;
139231: LD_ADDR_VAR 0 29
139235: PUSH
139236: LD_INT 1
139238: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
139239: LD_VAR 0 4
139243: PUSH
139244: LD_VAR 0 7
139248: ARRAY
139249: PPUSH
139250: CALL_OW 250
139254: PPUSH
139255: LD_VAR 0 4
139259: PUSH
139260: LD_VAR 0 7
139264: ARRAY
139265: PPUSH
139266: CALL_OW 251
139270: PPUSH
139271: CALL_OW 546
139275: PUSH
139276: LD_INT 2
139278: ARRAY
139279: PUSH
139280: LD_VAR 0 14
139284: PUSH
139285: LD_INT 1
139287: ARRAY
139288: PPUSH
139289: CALL_OW 250
139293: PPUSH
139294: LD_VAR 0 14
139298: PUSH
139299: LD_INT 1
139301: ARRAY
139302: PPUSH
139303: CALL_OW 251
139307: PPUSH
139308: CALL_OW 546
139312: PUSH
139313: LD_INT 2
139315: ARRAY
139316: EQUAL
139317: IFFALSE 139345
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
139319: LD_VAR 0 4
139323: PUSH
139324: LD_VAR 0 7
139328: ARRAY
139329: PPUSH
139330: LD_VAR 0 14
139334: PUSH
139335: LD_INT 1
139337: ARRAY
139338: PPUSH
139339: CALL 104492 0 2
139343: GO 139369
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139345: LD_VAR 0 4
139349: PUSH
139350: LD_VAR 0 7
139354: ARRAY
139355: PPUSH
139356: LD_VAR 0 14
139360: PUSH
139361: LD_INT 1
139363: ARRAY
139364: PPUSH
139365: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
139369: LD_VAR 0 4
139373: PUSH
139374: LD_VAR 0 7
139378: ARRAY
139379: PPUSH
139380: CALL_OW 264
139384: PUSH
139385: LD_INT 29
139387: EQUAL
139388: IFFALSE 139758
// begin if WantsToAttack ( group [ i ] ) in bombed then
139390: LD_VAR 0 4
139394: PUSH
139395: LD_VAR 0 7
139399: ARRAY
139400: PPUSH
139401: CALL_OW 319
139405: PUSH
139406: LD_VAR 0 28
139410: IN
139411: IFFALSE 139415
// continue ;
139413: GO 136383
// k := 8 ;
139415: LD_ADDR_VAR 0 9
139419: PUSH
139420: LD_INT 8
139422: ST_TO_ADDR
// x := 0 ;
139423: LD_ADDR_VAR 0 10
139427: PUSH
139428: LD_INT 0
139430: ST_TO_ADDR
// if tmp < k then
139431: LD_VAR 0 14
139435: PUSH
139436: LD_VAR 0 9
139440: LESS
139441: IFFALSE 139453
// k := tmp ;
139443: LD_ADDR_VAR 0 9
139447: PUSH
139448: LD_VAR 0 14
139452: ST_TO_ADDR
// for j = 1 to k do
139453: LD_ADDR_VAR 0 8
139457: PUSH
139458: DOUBLE
139459: LD_INT 1
139461: DEC
139462: ST_TO_ADDR
139463: LD_VAR 0 9
139467: PUSH
139468: FOR_TO
139469: IFFALSE 139603
// begin if GetType ( tmp [ j ] ) = unit_building then
139471: LD_VAR 0 14
139475: PUSH
139476: LD_VAR 0 8
139480: ARRAY
139481: PPUSH
139482: CALL_OW 247
139486: PUSH
139487: LD_INT 3
139489: EQUAL
139490: IFFALSE 139601
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
139492: LD_VAR 0 14
139496: PUSH
139497: LD_VAR 0 8
139501: ARRAY
139502: PUSH
139503: LD_VAR 0 28
139507: IN
139508: NOT
139509: IFFALSE 139528
139511: PUSH
139512: LD_VAR 0 14
139516: PUSH
139517: LD_VAR 0 8
139521: ARRAY
139522: PPUSH
139523: CALL_OW 313
139527: AND
139528: IFFALSE 139601
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
139530: LD_VAR 0 4
139534: PUSH
139535: LD_VAR 0 7
139539: ARRAY
139540: PPUSH
139541: LD_VAR 0 14
139545: PUSH
139546: LD_VAR 0 8
139550: ARRAY
139551: PPUSH
139552: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
139556: LD_ADDR_VAR 0 28
139560: PUSH
139561: LD_VAR 0 28
139565: PPUSH
139566: LD_VAR 0 28
139570: PUSH
139571: LD_INT 1
139573: PLUS
139574: PPUSH
139575: LD_VAR 0 14
139579: PUSH
139580: LD_VAR 0 8
139584: ARRAY
139585: PPUSH
139586: CALL_OW 1
139590: ST_TO_ADDR
// attacking := true ;
139591: LD_ADDR_VAR 0 29
139595: PUSH
139596: LD_INT 1
139598: ST_TO_ADDR
// break ;
139599: GO 139603
// end ; end ;
139601: GO 139468
139603: POP
139604: POP
// if not attacking and f_attack_depot then
139605: LD_VAR 0 29
139609: NOT
139610: IFFALSE 139618
139612: PUSH
139613: LD_VAR 0 25
139617: AND
139618: IFFALSE 139713
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
139620: LD_ADDR_VAR 0 13
139624: PUSH
139625: LD_VAR 0 14
139629: PPUSH
139630: LD_INT 2
139632: PUSH
139633: LD_INT 30
139635: PUSH
139636: LD_INT 0
139638: PUSH
139639: EMPTY
139640: LIST
139641: LIST
139642: PUSH
139643: LD_INT 30
139645: PUSH
139646: LD_INT 1
139648: PUSH
139649: EMPTY
139650: LIST
139651: LIST
139652: PUSH
139653: EMPTY
139654: LIST
139655: LIST
139656: LIST
139657: PPUSH
139658: CALL_OW 72
139662: ST_TO_ADDR
// if z then
139663: LD_VAR 0 13
139667: IFFALSE 139713
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
139669: LD_VAR 0 4
139673: PUSH
139674: LD_VAR 0 7
139678: ARRAY
139679: PPUSH
139680: LD_VAR 0 13
139684: PPUSH
139685: LD_VAR 0 4
139689: PUSH
139690: LD_VAR 0 7
139694: ARRAY
139695: PPUSH
139696: CALL_OW 74
139700: PPUSH
139701: CALL_OW 115
// attacking := true ;
139705: LD_ADDR_VAR 0 29
139709: PUSH
139710: LD_INT 1
139712: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
139713: LD_VAR 0 4
139717: PUSH
139718: LD_VAR 0 7
139722: ARRAY
139723: PPUSH
139724: CALL_OW 256
139728: PUSH
139729: LD_INT 500
139731: LESS
139732: IFFALSE 139758
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
139734: LD_VAR 0 4
139738: PUSH
139739: LD_VAR 0 7
139743: ARRAY
139744: PPUSH
139745: LD_VAR 0 14
139749: PUSH
139750: LD_INT 1
139752: ARRAY
139753: PPUSH
139754: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
139758: LD_VAR 0 4
139762: PUSH
139763: LD_VAR 0 7
139767: ARRAY
139768: PPUSH
139769: CALL_OW 264
139773: PUSH
139774: LD_INT 49
139776: EQUAL
139777: IFFALSE 139898
// begin if not HasTask ( group [ i ] ) then
139779: LD_VAR 0 4
139783: PUSH
139784: LD_VAR 0 7
139788: ARRAY
139789: PPUSH
139790: CALL_OW 314
139794: NOT
139795: IFFALSE 139898
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
139797: LD_ADDR_VAR 0 9
139801: PUSH
139802: LD_INT 81
139804: PUSH
139805: LD_VAR 0 4
139809: PUSH
139810: LD_VAR 0 7
139814: ARRAY
139815: PPUSH
139816: CALL_OW 255
139820: PUSH
139821: EMPTY
139822: LIST
139823: LIST
139824: PPUSH
139825: CALL_OW 69
139829: PPUSH
139830: LD_VAR 0 4
139834: PUSH
139835: LD_VAR 0 7
139839: ARRAY
139840: PPUSH
139841: CALL_OW 74
139845: ST_TO_ADDR
// if k then
139846: LD_VAR 0 9
139850: IFFALSE 139898
// if GetDistUnits ( group [ i ] , k ) > 10 then
139852: LD_VAR 0 4
139856: PUSH
139857: LD_VAR 0 7
139861: ARRAY
139862: PPUSH
139863: LD_VAR 0 9
139867: PPUSH
139868: CALL_OW 296
139872: PUSH
139873: LD_INT 10
139875: GREATER
139876: IFFALSE 139898
// ComMoveUnit ( group [ i ] , k ) ;
139878: LD_VAR 0 4
139882: PUSH
139883: LD_VAR 0 7
139887: ARRAY
139888: PPUSH
139889: LD_VAR 0 9
139893: PPUSH
139894: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
139898: LD_VAR 0 4
139902: PUSH
139903: LD_VAR 0 7
139907: ARRAY
139908: PPUSH
139909: CALL_OW 256
139913: PUSH
139914: LD_INT 250
139916: LESS
139917: IFFALSE 139961
139919: PUSH
139920: LD_VAR 0 4
139924: PUSH
139925: LD_VAR 0 7
139929: ARRAY
139930: PUSH
139931: LD_INT 21
139933: PUSH
139934: LD_INT 2
139936: PUSH
139937: EMPTY
139938: LIST
139939: LIST
139940: PUSH
139941: LD_INT 23
139943: PUSH
139944: LD_INT 2
139946: PUSH
139947: EMPTY
139948: LIST
139949: LIST
139950: PUSH
139951: EMPTY
139952: LIST
139953: LIST
139954: PPUSH
139955: CALL_OW 69
139959: IN
139960: AND
139961: IFFALSE 140088
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
139963: LD_ADDR_VAR 0 9
139967: PUSH
139968: LD_OWVAR 3
139972: PUSH
139973: LD_VAR 0 4
139977: PUSH
139978: LD_VAR 0 7
139982: ARRAY
139983: DIFF
139984: PPUSH
139985: LD_VAR 0 4
139989: PUSH
139990: LD_VAR 0 7
139994: ARRAY
139995: PPUSH
139996: CALL_OW 74
140000: ST_TO_ADDR
// if not k then
140001: LD_VAR 0 9
140005: NOT
140006: IFFALSE 140010
// continue ;
140008: GO 136383
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
140010: LD_VAR 0 9
140014: PUSH
140015: LD_INT 81
140017: PUSH
140018: LD_VAR 0 4
140022: PUSH
140023: LD_VAR 0 7
140027: ARRAY
140028: PPUSH
140029: CALL_OW 255
140033: PUSH
140034: EMPTY
140035: LIST
140036: LIST
140037: PPUSH
140038: CALL_OW 69
140042: IN
140043: IFFALSE 140071
140045: PUSH
140046: LD_VAR 0 9
140050: PPUSH
140051: LD_VAR 0 4
140055: PUSH
140056: LD_VAR 0 7
140060: ARRAY
140061: PPUSH
140062: CALL_OW 296
140066: PUSH
140067: LD_INT 5
140069: LESS
140070: AND
140071: IFFALSE 140088
// ComAutodestruct ( group [ i ] ) ;
140073: LD_VAR 0 4
140077: PUSH
140078: LD_VAR 0 7
140082: ARRAY
140083: PPUSH
140084: CALL 104388 0 1
// end ; if f_attack_depot then
140088: LD_VAR 0 25
140092: IFFALSE 140204
// begin k := 6 ;
140094: LD_ADDR_VAR 0 9
140098: PUSH
140099: LD_INT 6
140101: ST_TO_ADDR
// if tmp < k then
140102: LD_VAR 0 14
140106: PUSH
140107: LD_VAR 0 9
140111: LESS
140112: IFFALSE 140124
// k := tmp ;
140114: LD_ADDR_VAR 0 9
140118: PUSH
140119: LD_VAR 0 14
140123: ST_TO_ADDR
// for j = 1 to k do
140124: LD_ADDR_VAR 0 8
140128: PUSH
140129: DOUBLE
140130: LD_INT 1
140132: DEC
140133: ST_TO_ADDR
140134: LD_VAR 0 9
140138: PUSH
140139: FOR_TO
140140: IFFALSE 140202
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
140142: LD_VAR 0 8
140146: PPUSH
140147: CALL_OW 266
140151: PUSH
140152: LD_INT 0
140154: PUSH
140155: LD_INT 1
140157: PUSH
140158: EMPTY
140159: LIST
140160: LIST
140161: IN
140162: IFFALSE 140200
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
140164: LD_VAR 0 4
140168: PUSH
140169: LD_VAR 0 7
140173: ARRAY
140174: PPUSH
140175: LD_VAR 0 14
140179: PUSH
140180: LD_VAR 0 8
140184: ARRAY
140185: PPUSH
140186: CALL_OW 115
// attacking := true ;
140190: LD_ADDR_VAR 0 29
140194: PUSH
140195: LD_INT 1
140197: ST_TO_ADDR
// break ;
140198: GO 140202
// end ;
140200: GO 140139
140202: POP
140203: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
140204: LD_VAR 0 4
140208: PUSH
140209: LD_VAR 0 7
140213: ARRAY
140214: PPUSH
140215: CALL_OW 302
140219: IFFALSE 140228
140221: PUSH
140222: LD_VAR 0 29
140226: NOT
140227: AND
140228: IFFALSE 140558
// begin if GetTag ( group [ i ] ) = 71 then
140230: LD_VAR 0 4
140234: PUSH
140235: LD_VAR 0 7
140239: ARRAY
140240: PPUSH
140241: CALL_OW 110
140245: PUSH
140246: LD_INT 71
140248: EQUAL
140249: IFFALSE 140290
// begin if HasTask ( group [ i ] ) then
140251: LD_VAR 0 4
140255: PUSH
140256: LD_VAR 0 7
140260: ARRAY
140261: PPUSH
140262: CALL_OW 314
140266: IFFALSE 140272
// continue else
140268: GO 136383
140270: GO 140290
// SetTag ( group [ i ] , 0 ) ;
140272: LD_VAR 0 4
140276: PUSH
140277: LD_VAR 0 7
140281: ARRAY
140282: PPUSH
140283: LD_INT 0
140285: PPUSH
140286: CALL_OW 109
// end ; k := 8 ;
140290: LD_ADDR_VAR 0 9
140294: PUSH
140295: LD_INT 8
140297: ST_TO_ADDR
// x := 0 ;
140298: LD_ADDR_VAR 0 10
140302: PUSH
140303: LD_INT 0
140305: ST_TO_ADDR
// if tmp < k then
140306: LD_VAR 0 14
140310: PUSH
140311: LD_VAR 0 9
140315: LESS
140316: IFFALSE 140328
// k := tmp ;
140318: LD_ADDR_VAR 0 9
140322: PUSH
140323: LD_VAR 0 14
140327: ST_TO_ADDR
// for j = 1 to k do
140328: LD_ADDR_VAR 0 8
140332: PUSH
140333: DOUBLE
140334: LD_INT 1
140336: DEC
140337: ST_TO_ADDR
140338: LD_VAR 0 9
140342: PUSH
140343: FOR_TO
140344: IFFALSE 140450
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
140346: LD_VAR 0 14
140350: PUSH
140351: LD_VAR 0 8
140355: ARRAY
140356: PPUSH
140357: CALL_OW 247
140361: PUSH
140362: LD_INT 1
140364: EQUAL
140365: IFFALSE 140428
140367: PUSH
140368: LD_VAR 0 14
140372: PUSH
140373: LD_VAR 0 8
140377: ARRAY
140378: PPUSH
140379: CALL_OW 256
140383: PUSH
140384: LD_INT 250
140386: LESS
140387: IFFALSE 140395
140389: PUSH
140390: LD_VAR 0 20
140394: AND
140395: IFTRUE 140427
140397: PUSH
140398: LD_VAR 0 20
140402: NOT
140403: IFFALSE 140426
140405: PUSH
140406: LD_VAR 0 14
140410: PUSH
140411: LD_VAR 0 8
140415: ARRAY
140416: PPUSH
140417: CALL_OW 256
140421: PUSH
140422: LD_INT 250
140424: GREATEREQUAL
140425: AND
140426: OR
140427: AND
140428: IFFALSE 140448
// begin x := tmp [ j ] ;
140430: LD_ADDR_VAR 0 10
140434: PUSH
140435: LD_VAR 0 14
140439: PUSH
140440: LD_VAR 0 8
140444: ARRAY
140445: ST_TO_ADDR
// break ;
140446: GO 140450
// end ;
140448: GO 140343
140450: POP
140451: POP
// if x then
140452: LD_VAR 0 10
140456: IFFALSE 140480
// ComAttackUnit ( group [ i ] , x ) else
140458: LD_VAR 0 4
140462: PUSH
140463: LD_VAR 0 7
140467: ARRAY
140468: PPUSH
140469: LD_VAR 0 10
140473: PPUSH
140474: CALL_OW 115
140478: GO 140504
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140480: LD_VAR 0 4
140484: PUSH
140485: LD_VAR 0 7
140489: ARRAY
140490: PPUSH
140491: LD_VAR 0 14
140495: PUSH
140496: LD_INT 1
140498: ARRAY
140499: PPUSH
140500: CALL_OW 115
// if not HasTask ( group [ i ] ) then
140504: LD_VAR 0 4
140508: PUSH
140509: LD_VAR 0 7
140513: ARRAY
140514: PPUSH
140515: CALL_OW 314
140519: NOT
140520: IFFALSE 140558
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
140522: LD_VAR 0 4
140526: PUSH
140527: LD_VAR 0 7
140531: ARRAY
140532: PPUSH
140533: LD_VAR 0 14
140537: PPUSH
140538: LD_VAR 0 4
140542: PUSH
140543: LD_VAR 0 7
140547: ARRAY
140548: PPUSH
140549: CALL_OW 74
140553: PPUSH
140554: CALL_OW 115
// end ; end ; end ;
140558: GO 136383
140560: POP
140561: POP
// wait ( 0 0$2 ) ;
140562: LD_INT 70
140564: PPUSH
140565: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
140569: LD_VAR 0 4
140573: NOT
140574: IFTRUE 140585
140576: PUSH
140577: LD_VAR 0 4
140581: PUSH
140582: EMPTY
140583: EQUAL
140584: OR
140585: IFTRUE 140606
140587: PUSH
140588: LD_INT 81
140590: PUSH
140591: LD_VAR 0 35
140595: PUSH
140596: EMPTY
140597: LIST
140598: LIST
140599: PPUSH
140600: CALL_OW 69
140604: NOT
140605: OR
140606: IFFALSE 136368
// end ;
140608: LD_VAR 0 2
140612: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
140613: LD_INT 0
140615: PPUSH
140616: PPUSH
140617: PPUSH
140618: PPUSH
140619: PPUSH
140620: PPUSH
// if not base or not mc_bases [ base ] or not solds then
140621: LD_VAR 0 1
140625: NOT
140626: IFTRUE 140641
140628: PUSH
140629: LD_EXP 102
140633: PUSH
140634: LD_VAR 0 1
140638: ARRAY
140639: NOT
140640: OR
140641: IFTRUE 140650
140643: PUSH
140644: LD_VAR 0 2
140648: NOT
140649: OR
140650: IFFALSE 140654
// exit ;
140652: GO 141212
// side := mc_sides [ base ] ;
140654: LD_ADDR_VAR 0 6
140658: PUSH
140659: LD_EXP 128
140663: PUSH
140664: LD_VAR 0 1
140668: ARRAY
140669: ST_TO_ADDR
// if not side then
140670: LD_VAR 0 6
140674: NOT
140675: IFFALSE 140679
// exit ;
140677: GO 141212
// for i in solds do
140679: LD_ADDR_VAR 0 7
140683: PUSH
140684: LD_VAR 0 2
140688: PUSH
140689: FOR_IN
140690: IFFALSE 140751
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
140692: LD_VAR 0 7
140696: PPUSH
140697: CALL_OW 310
140701: PPUSH
140702: CALL_OW 266
140706: PUSH
140707: LD_INT 32
140709: PUSH
140710: LD_INT 31
140712: PUSH
140713: EMPTY
140714: LIST
140715: LIST
140716: IN
140717: IFFALSE 140737
// solds := solds diff i else
140719: LD_ADDR_VAR 0 2
140723: PUSH
140724: LD_VAR 0 2
140728: PUSH
140729: LD_VAR 0 7
140733: DIFF
140734: ST_TO_ADDR
140735: GO 140749
// SetTag ( i , 18 ) ;
140737: LD_VAR 0 7
140741: PPUSH
140742: LD_INT 18
140744: PPUSH
140745: CALL_OW 109
140749: GO 140689
140751: POP
140752: POP
// if not solds then
140753: LD_VAR 0 2
140757: NOT
140758: IFFALSE 140762
// exit ;
140760: GO 141212
// repeat wait ( 0 0$2 ) ;
140762: LD_INT 70
140764: PPUSH
140765: CALL_OW 67
// enemy := mc_scan [ base ] ;
140769: LD_ADDR_VAR 0 4
140773: PUSH
140774: LD_EXP 125
140778: PUSH
140779: LD_VAR 0 1
140783: ARRAY
140784: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
140785: LD_EXP 102
140789: PUSH
140790: LD_VAR 0 1
140794: ARRAY
140795: NOT
140796: IFTRUE 140813
140798: PUSH
140799: LD_EXP 102
140803: PUSH
140804: LD_VAR 0 1
140808: ARRAY
140809: PUSH
140810: EMPTY
140811: EQUAL
140812: OR
140813: IFFALSE 140850
// begin for i in solds do
140815: LD_ADDR_VAR 0 7
140819: PUSH
140820: LD_VAR 0 2
140824: PUSH
140825: FOR_IN
140826: IFFALSE 140839
// ComStop ( i ) ;
140828: LD_VAR 0 7
140832: PPUSH
140833: CALL_OW 141
140837: GO 140825
140839: POP
140840: POP
// solds := [ ] ;
140841: LD_ADDR_VAR 0 2
140845: PUSH
140846: EMPTY
140847: ST_TO_ADDR
// exit ;
140848: GO 141212
// end ; for i in solds do
140850: LD_ADDR_VAR 0 7
140854: PUSH
140855: LD_VAR 0 2
140859: PUSH
140860: FOR_IN
140861: IFFALSE 141182
// begin if IsInUnit ( i ) then
140863: LD_VAR 0 7
140867: PPUSH
140868: CALL_OW 310
140872: IFFALSE 140883
// ComExitBuilding ( i ) ;
140874: LD_VAR 0 7
140878: PPUSH
140879: CALL_OW 122
// if GetLives ( i ) > 500 then
140883: LD_VAR 0 7
140887: PPUSH
140888: CALL_OW 256
140892: PUSH
140893: LD_INT 500
140895: GREATER
140896: IFFALSE 140949
// begin e := NearestUnitToUnit ( enemy , i ) ;
140898: LD_ADDR_VAR 0 5
140902: PUSH
140903: LD_VAR 0 4
140907: PPUSH
140908: LD_VAR 0 7
140912: PPUSH
140913: CALL_OW 74
140917: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
140918: LD_VAR 0 7
140922: PPUSH
140923: LD_VAR 0 5
140927: PPUSH
140928: CALL_OW 250
140932: PPUSH
140933: LD_VAR 0 5
140937: PPUSH
140938: CALL_OW 251
140942: PPUSH
140943: CALL_OW 114
// end else
140947: GO 141180
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
140949: LD_VAR 0 7
140953: PPUSH
140954: LD_EXP 102
140958: PUSH
140959: LD_VAR 0 1
140963: ARRAY
140964: PPUSH
140965: LD_INT 2
140967: PUSH
140968: LD_INT 30
140970: PUSH
140971: LD_INT 0
140973: PUSH
140974: EMPTY
140975: LIST
140976: LIST
140977: PUSH
140978: LD_INT 30
140980: PUSH
140981: LD_INT 1
140983: PUSH
140984: EMPTY
140985: LIST
140986: LIST
140987: PUSH
140988: LD_INT 30
140990: PUSH
140991: LD_INT 6
140993: PUSH
140994: EMPTY
140995: LIST
140996: LIST
140997: PUSH
140998: EMPTY
140999: LIST
141000: LIST
141001: LIST
141002: LIST
141003: PPUSH
141004: CALL_OW 72
141008: PPUSH
141009: LD_VAR 0 7
141013: PPUSH
141014: CALL_OW 74
141018: PPUSH
141019: CALL_OW 296
141023: PUSH
141024: LD_INT 10
141026: GREATER
141027: IFFALSE 141180
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
141029: LD_ADDR_VAR 0 8
141033: PUSH
141034: LD_EXP 102
141038: PUSH
141039: LD_VAR 0 1
141043: ARRAY
141044: PPUSH
141045: LD_INT 2
141047: PUSH
141048: LD_INT 30
141050: PUSH
141051: LD_INT 0
141053: PUSH
141054: EMPTY
141055: LIST
141056: LIST
141057: PUSH
141058: LD_INT 30
141060: PUSH
141061: LD_INT 1
141063: PUSH
141064: EMPTY
141065: LIST
141066: LIST
141067: PUSH
141068: LD_INT 30
141070: PUSH
141071: LD_INT 6
141073: PUSH
141074: EMPTY
141075: LIST
141076: LIST
141077: PUSH
141078: EMPTY
141079: LIST
141080: LIST
141081: LIST
141082: LIST
141083: PPUSH
141084: CALL_OW 72
141088: PPUSH
141089: LD_VAR 0 7
141093: PPUSH
141094: CALL_OW 74
141098: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
141099: LD_VAR 0 7
141103: PPUSH
141104: LD_VAR 0 8
141108: PPUSH
141109: CALL_OW 250
141113: PPUSH
141114: LD_INT 3
141116: PPUSH
141117: LD_INT 5
141119: PPUSH
141120: CALL_OW 272
141124: PPUSH
141125: LD_VAR 0 8
141129: PPUSH
141130: CALL_OW 251
141134: PPUSH
141135: LD_INT 3
141137: PPUSH
141138: LD_INT 5
141140: PPUSH
141141: CALL_OW 273
141145: PPUSH
141146: CALL_OW 111
// SetTag ( i , 0 ) ;
141150: LD_VAR 0 7
141154: PPUSH
141155: LD_INT 0
141157: PPUSH
141158: CALL_OW 109
// solds := solds diff i ;
141162: LD_ADDR_VAR 0 2
141166: PUSH
141167: LD_VAR 0 2
141171: PUSH
141172: LD_VAR 0 7
141176: DIFF
141177: ST_TO_ADDR
// continue ;
141178: GO 140860
// end ; end ;
141180: GO 140860
141182: POP
141183: POP
// until not solds or not enemy ;
141184: LD_VAR 0 2
141188: NOT
141189: IFTRUE 141198
141191: PUSH
141192: LD_VAR 0 4
141196: NOT
141197: OR
141198: IFFALSE 140762
// MC_Reset ( base , 18 ) ;
141200: LD_VAR 0 1
141204: PPUSH
141205: LD_INT 18
141207: PPUSH
141208: CALL 44046 0 2
// end ;
141212: LD_VAR 0 3
141216: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
141217: LD_INT 0
141219: PPUSH
141220: PPUSH
141221: PPUSH
141222: PPUSH
141223: PPUSH
141224: PPUSH
141225: PPUSH
141226: PPUSH
141227: PPUSH
141228: PPUSH
141229: PPUSH
141230: PPUSH
141231: PPUSH
141232: PPUSH
141233: PPUSH
141234: PPUSH
141235: PPUSH
141236: PPUSH
141237: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
141238: LD_ADDR_VAR 0 12
141242: PUSH
141243: LD_EXP 102
141247: PUSH
141248: LD_VAR 0 1
141252: ARRAY
141253: PPUSH
141254: LD_INT 25
141256: PUSH
141257: LD_INT 3
141259: PUSH
141260: EMPTY
141261: LIST
141262: LIST
141263: PPUSH
141264: CALL_OW 72
141268: ST_TO_ADDR
// if mc_remote_driver [ base ] then
141269: LD_EXP 142
141273: PUSH
141274: LD_VAR 0 1
141278: ARRAY
141279: IFFALSE 141303
// mechs := mechs diff mc_remote_driver [ base ] ;
141281: LD_ADDR_VAR 0 12
141285: PUSH
141286: LD_VAR 0 12
141290: PUSH
141291: LD_EXP 142
141295: PUSH
141296: LD_VAR 0 1
141300: ARRAY
141301: DIFF
141302: ST_TO_ADDR
// for i in mechs do
141303: LD_ADDR_VAR 0 4
141307: PUSH
141308: LD_VAR 0 12
141312: PUSH
141313: FOR_IN
141314: IFFALSE 141349
// if GetTag ( i ) > 0 then
141316: LD_VAR 0 4
141320: PPUSH
141321: CALL_OW 110
141325: PUSH
141326: LD_INT 0
141328: GREATER
141329: IFFALSE 141347
// mechs := mechs diff i ;
141331: LD_ADDR_VAR 0 12
141335: PUSH
141336: LD_VAR 0 12
141340: PUSH
141341: LD_VAR 0 4
141345: DIFF
141346: ST_TO_ADDR
141347: GO 141313
141349: POP
141350: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
141351: LD_ADDR_VAR 0 8
141355: PUSH
141356: LD_EXP 102
141360: PUSH
141361: LD_VAR 0 1
141365: ARRAY
141366: PPUSH
141367: LD_INT 2
141369: PUSH
141370: LD_INT 25
141372: PUSH
141373: LD_INT 1
141375: PUSH
141376: EMPTY
141377: LIST
141378: LIST
141379: PUSH
141380: LD_INT 25
141382: PUSH
141383: LD_INT 5
141385: PUSH
141386: EMPTY
141387: LIST
141388: LIST
141389: PUSH
141390: LD_INT 25
141392: PUSH
141393: LD_INT 8
141395: PUSH
141396: EMPTY
141397: LIST
141398: LIST
141399: PUSH
141400: LD_INT 25
141402: PUSH
141403: LD_INT 9
141405: PUSH
141406: EMPTY
141407: LIST
141408: LIST
141409: PUSH
141410: EMPTY
141411: LIST
141412: LIST
141413: LIST
141414: LIST
141415: LIST
141416: PPUSH
141417: CALL_OW 72
141421: ST_TO_ADDR
// if not defenders and not solds then
141422: LD_VAR 0 2
141426: NOT
141427: IFFALSE 141436
141429: PUSH
141430: LD_VAR 0 8
141434: NOT
141435: AND
141436: IFFALSE 141440
// exit ;
141438: GO 143262
// depot_under_attack := false ;
141440: LD_ADDR_VAR 0 16
141444: PUSH
141445: LD_INT 0
141447: ST_TO_ADDR
// sold_defenders := [ ] ;
141448: LD_ADDR_VAR 0 17
141452: PUSH
141453: EMPTY
141454: ST_TO_ADDR
// if mechs then
141455: LD_VAR 0 12
141459: IFFALSE 141614
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
141461: LD_ADDR_VAR 0 4
141465: PUSH
141466: LD_VAR 0 2
141470: PPUSH
141471: LD_INT 21
141473: PUSH
141474: LD_INT 2
141476: PUSH
141477: EMPTY
141478: LIST
141479: LIST
141480: PPUSH
141481: CALL_OW 72
141485: PUSH
141486: FOR_IN
141487: IFFALSE 141612
// begin if GetTag ( i ) <> 20 then
141489: LD_VAR 0 4
141493: PPUSH
141494: CALL_OW 110
141498: PUSH
141499: LD_INT 20
141501: NONEQUAL
141502: IFFALSE 141516
// SetTag ( i , 20 ) ;
141504: LD_VAR 0 4
141508: PPUSH
141509: LD_INT 20
141511: PPUSH
141512: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
141516: LD_VAR 0 4
141520: PPUSH
141521: CALL_OW 263
141525: PUSH
141526: LD_INT 1
141528: EQUAL
141529: IFFALSE 141543
141531: PUSH
141532: LD_VAR 0 4
141536: PPUSH
141537: CALL_OW 311
141541: NOT
141542: AND
141543: IFFALSE 141610
// begin un := mechs [ 1 ] ;
141545: LD_ADDR_VAR 0 10
141549: PUSH
141550: LD_VAR 0 12
141554: PUSH
141555: LD_INT 1
141557: ARRAY
141558: ST_TO_ADDR
// ComExit ( un ) ;
141559: LD_VAR 0 10
141563: PPUSH
141564: CALL 109469 0 1
// AddComEnterUnit ( un , i ) ;
141568: LD_VAR 0 10
141572: PPUSH
141573: LD_VAR 0 4
141577: PPUSH
141578: CALL_OW 180
// SetTag ( un , 19 ) ;
141582: LD_VAR 0 10
141586: PPUSH
141587: LD_INT 19
141589: PPUSH
141590: CALL_OW 109
// mechs := mechs diff un ;
141594: LD_ADDR_VAR 0 12
141598: PUSH
141599: LD_VAR 0 12
141603: PUSH
141604: LD_VAR 0 10
141608: DIFF
141609: ST_TO_ADDR
// end ; end ;
141610: GO 141486
141612: POP
141613: POP
// if solds then
141614: LD_VAR 0 8
141618: IFFALSE 141677
// for i in solds do
141620: LD_ADDR_VAR 0 4
141624: PUSH
141625: LD_VAR 0 8
141629: PUSH
141630: FOR_IN
141631: IFFALSE 141675
// if not GetTag ( i ) then
141633: LD_VAR 0 4
141637: PPUSH
141638: CALL_OW 110
141642: NOT
141643: IFFALSE 141673
// begin defenders := defenders union i ;
141645: LD_ADDR_VAR 0 2
141649: PUSH
141650: LD_VAR 0 2
141654: PUSH
141655: LD_VAR 0 4
141659: UNION
141660: ST_TO_ADDR
// SetTag ( i , 18 ) ;
141661: LD_VAR 0 4
141665: PPUSH
141666: LD_INT 18
141668: PPUSH
141669: CALL_OW 109
// end ;
141673: GO 141630
141675: POP
141676: POP
// repeat wait ( 0 0$2 ) ;
141677: LD_INT 70
141679: PPUSH
141680: CALL_OW 67
// enemy := mc_scan [ base ] ;
141684: LD_ADDR_VAR 0 21
141688: PUSH
141689: LD_EXP 125
141693: PUSH
141694: LD_VAR 0 1
141698: ARRAY
141699: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141700: LD_EXP 102
141704: PUSH
141705: LD_VAR 0 1
141709: ARRAY
141710: NOT
141711: IFTRUE 141728
141713: PUSH
141714: LD_EXP 102
141718: PUSH
141719: LD_VAR 0 1
141723: ARRAY
141724: PUSH
141725: EMPTY
141726: EQUAL
141727: OR
141728: IFFALSE 141765
// begin for i in defenders do
141730: LD_ADDR_VAR 0 4
141734: PUSH
141735: LD_VAR 0 2
141739: PUSH
141740: FOR_IN
141741: IFFALSE 141754
// ComStop ( i ) ;
141743: LD_VAR 0 4
141747: PPUSH
141748: CALL_OW 141
141752: GO 141740
141754: POP
141755: POP
// defenders := [ ] ;
141756: LD_ADDR_VAR 0 2
141760: PUSH
141761: EMPTY
141762: ST_TO_ADDR
// exit ;
141763: GO 143262
// end ; for i in defenders do
141765: LD_ADDR_VAR 0 4
141769: PUSH
141770: LD_VAR 0 2
141774: PUSH
141775: FOR_IN
141776: IFFALSE 142710
// begin e := NearestUnitToUnit ( enemy , i ) ;
141778: LD_ADDR_VAR 0 13
141782: PUSH
141783: LD_VAR 0 21
141787: PPUSH
141788: LD_VAR 0 4
141792: PPUSH
141793: CALL_OW 74
141797: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
141798: LD_ADDR_VAR 0 7
141802: PUSH
141803: LD_EXP 102
141807: PUSH
141808: LD_VAR 0 1
141812: ARRAY
141813: PPUSH
141814: LD_INT 2
141816: PUSH
141817: LD_INT 30
141819: PUSH
141820: LD_INT 0
141822: PUSH
141823: EMPTY
141824: LIST
141825: LIST
141826: PUSH
141827: LD_INT 30
141829: PUSH
141830: LD_INT 1
141832: PUSH
141833: EMPTY
141834: LIST
141835: LIST
141836: PUSH
141837: EMPTY
141838: LIST
141839: LIST
141840: LIST
141841: PPUSH
141842: CALL_OW 72
141846: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
141847: LD_ADDR_VAR 0 16
141851: PUSH
141852: LD_VAR 0 7
141856: NOT
141857: IFTRUE 141887
141859: PUSH
141860: LD_VAR 0 7
141864: PPUSH
141865: LD_INT 3
141867: PUSH
141868: LD_INT 24
141870: PUSH
141871: LD_INT 600
141873: PUSH
141874: EMPTY
141875: LIST
141876: LIST
141877: PUSH
141878: EMPTY
141879: LIST
141880: LIST
141881: PPUSH
141882: CALL_OW 72
141886: OR
141887: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
141888: LD_VAR 0 4
141892: PPUSH
141893: CALL_OW 247
141897: PUSH
141898: LD_INT 2
141900: DOUBLE
141901: EQUAL
141902: IFTRUE 141906
141904: GO 142322
141906: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
141907: LD_VAR 0 4
141911: PPUSH
141912: CALL_OW 256
141916: PUSH
141917: LD_INT 1000
141919: EQUAL
141920: IFFALSE 141966
141922: PUSH
141923: LD_VAR 0 4
141927: PPUSH
141928: LD_VAR 0 13
141932: PPUSH
141933: CALL_OW 296
141937: PUSH
141938: LD_INT 40
141940: LESS
141941: IFTRUE 141965
141943: PUSH
141944: LD_VAR 0 13
141948: PPUSH
141949: LD_EXP 127
141953: PUSH
141954: LD_VAR 0 1
141958: ARRAY
141959: PPUSH
141960: CALL_OW 308
141964: OR
141965: AND
141966: IFFALSE 142092
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
141968: LD_VAR 0 4
141972: PPUSH
141973: CALL_OW 262
141977: PUSH
141978: LD_INT 1
141980: EQUAL
141981: IFFALSE 141998
141983: PUSH
141984: LD_VAR 0 4
141988: PPUSH
141989: CALL_OW 261
141993: PUSH
141994: LD_INT 30
141996: LESS
141997: AND
141998: IFFALSE 142006
142000: PUSH
142001: LD_VAR 0 7
142005: AND
142006: IFFALSE 142076
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
142008: LD_VAR 0 4
142012: PPUSH
142013: LD_VAR 0 7
142017: PPUSH
142018: LD_VAR 0 4
142022: PPUSH
142023: CALL_OW 74
142027: PPUSH
142028: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
142032: LD_VAR 0 4
142036: PPUSH
142037: LD_VAR 0 7
142041: PPUSH
142042: LD_VAR 0 4
142046: PPUSH
142047: CALL_OW 74
142051: PPUSH
142052: CALL_OW 296
142056: PUSH
142057: LD_INT 6
142059: LESS
142060: IFFALSE 142074
// SetFuel ( i , 100 ) ;
142062: LD_VAR 0 4
142066: PPUSH
142067: LD_INT 100
142069: PPUSH
142070: CALL_OW 240
// end else
142074: GO 142090
// ComAttackUnit ( i , e ) ;
142076: LD_VAR 0 4
142080: PPUSH
142081: LD_VAR 0 13
142085: PPUSH
142086: CALL_OW 115
// end else
142090: GO 142199
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
142092: LD_VAR 0 13
142096: PPUSH
142097: LD_EXP 127
142101: PUSH
142102: LD_VAR 0 1
142106: ARRAY
142107: PPUSH
142108: CALL_OW 308
142112: NOT
142113: IFFALSE 142135
142115: PUSH
142116: LD_VAR 0 4
142120: PPUSH
142121: LD_VAR 0 13
142125: PPUSH
142126: CALL_OW 296
142130: PUSH
142131: LD_INT 40
142133: GREATEREQUAL
142134: AND
142135: IFTRUE 142152
142137: PUSH
142138: LD_VAR 0 4
142142: PPUSH
142143: CALL_OW 256
142147: PUSH
142148: LD_INT 650
142150: LESSEQUAL
142151: OR
142152: IFFALSE 142177
142154: PUSH
142155: LD_VAR 0 4
142159: PPUSH
142160: LD_EXP 126
142164: PUSH
142165: LD_VAR 0 1
142169: ARRAY
142170: PPUSH
142171: CALL_OW 308
142175: NOT
142176: AND
142177: IFFALSE 142199
// ComMoveToArea ( i , mc_parking [ base ] ) ;
142179: LD_VAR 0 4
142183: PPUSH
142184: LD_EXP 126
142188: PUSH
142189: LD_VAR 0 1
142193: ARRAY
142194: PPUSH
142195: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
142199: LD_VAR 0 4
142203: PPUSH
142204: CALL_OW 256
142208: PUSH
142209: LD_INT 1000
142211: LESS
142212: IFFALSE 142229
142214: PUSH
142215: LD_VAR 0 4
142219: PPUSH
142220: CALL_OW 263
142224: PUSH
142225: LD_INT 1
142227: EQUAL
142228: AND
142229: IFFALSE 142242
142231: PUSH
142232: LD_VAR 0 4
142236: PPUSH
142237: CALL_OW 311
142241: AND
142242: IFFALSE 142266
142244: PUSH
142245: LD_VAR 0 4
142249: PPUSH
142250: LD_EXP 126
142254: PUSH
142255: LD_VAR 0 1
142259: ARRAY
142260: PPUSH
142261: CALL_OW 308
142265: AND
142266: IFFALSE 142320
// begin mech := IsDrivenBy ( i ) ;
142268: LD_ADDR_VAR 0 9
142272: PUSH
142273: LD_VAR 0 4
142277: PPUSH
142278: CALL_OW 311
142282: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
142283: LD_VAR 0 9
142287: PPUSH
142288: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
142292: LD_VAR 0 9
142296: PPUSH
142297: LD_VAR 0 4
142301: PPUSH
142302: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
142306: LD_VAR 0 9
142310: PPUSH
142311: LD_VAR 0 4
142315: PPUSH
142316: CALL_OW 180
// end ; end ; unit_human :
142320: GO 142681
142322: LD_INT 1
142324: DOUBLE
142325: EQUAL
142326: IFTRUE 142330
142328: GO 142680
142330: POP
// begin b := IsInUnit ( i ) ;
142331: LD_ADDR_VAR 0 18
142335: PUSH
142336: LD_VAR 0 4
142340: PPUSH
142341: CALL_OW 310
142345: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
142346: LD_ADDR_VAR 0 19
142350: PUSH
142351: LD_VAR 0 18
142355: NOT
142356: IFTRUE 142380
142358: PUSH
142359: LD_VAR 0 18
142363: PPUSH
142364: CALL_OW 266
142368: PUSH
142369: LD_INT 32
142371: PUSH
142372: LD_INT 31
142374: PUSH
142375: EMPTY
142376: LIST
142377: LIST
142378: IN
142379: OR
142380: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
142381: LD_VAR 0 18
142385: PPUSH
142386: CALL_OW 266
142390: PUSH
142391: LD_INT 5
142393: EQUAL
142394: IFFALSE 142426
142396: PUSH
142397: LD_VAR 0 4
142401: PPUSH
142402: CALL_OW 257
142406: PUSH
142407: LD_INT 1
142409: PUSH
142410: LD_INT 2
142412: PUSH
142413: LD_INT 3
142415: PUSH
142416: LD_INT 4
142418: PUSH
142419: EMPTY
142420: LIST
142421: LIST
142422: LIST
142423: LIST
142424: IN
142425: AND
142426: IFFALSE 142463
// begin class := AllowSpecClass ( i ) ;
142428: LD_ADDR_VAR 0 20
142432: PUSH
142433: LD_VAR 0 4
142437: PPUSH
142438: CALL 72823 0 1
142442: ST_TO_ADDR
// if class then
142443: LD_VAR 0 20
142447: IFFALSE 142463
// ComChangeProfession ( i , class ) ;
142449: LD_VAR 0 4
142453: PPUSH
142454: LD_VAR 0 20
142458: PPUSH
142459: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
142463: LD_VAR 0 16
142467: IFTRUE 142494
142469: PUSH
142470: LD_VAR 0 2
142474: PPUSH
142475: LD_INT 21
142477: PUSH
142478: LD_INT 2
142480: PUSH
142481: EMPTY
142482: LIST
142483: LIST
142484: PPUSH
142485: CALL_OW 72
142489: PUSH
142490: LD_INT 1
142492: LESSEQUAL
142493: OR
142494: IFFALSE 142502
142496: PUSH
142497: LD_VAR 0 19
142501: AND
142502: IFFALSE 142517
142504: PUSH
142505: LD_VAR 0 4
142509: PUSH
142510: LD_VAR 0 17
142514: IN
142515: NOT
142516: AND
142517: IFFALSE 142612
// begin if b then
142519: LD_VAR 0 18
142523: IFFALSE 142574
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
142525: LD_VAR 0 18
142529: PPUSH
142530: LD_VAR 0 21
142534: PPUSH
142535: LD_VAR 0 18
142539: PPUSH
142540: CALL_OW 74
142544: PPUSH
142545: CALL_OW 296
142549: PUSH
142550: LD_INT 10
142552: LESS
142553: IFFALSE 142570
142555: PUSH
142556: LD_VAR 0 18
142560: PPUSH
142561: CALL_OW 461
142565: PUSH
142566: LD_INT 7
142568: NONEQUAL
142569: AND
142570: IFFALSE 142574
// continue ;
142572: GO 141775
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
142574: LD_ADDR_VAR 0 17
142578: PUSH
142579: LD_VAR 0 17
142583: PPUSH
142584: LD_VAR 0 17
142588: PUSH
142589: LD_INT 1
142591: PLUS
142592: PPUSH
142593: LD_VAR 0 4
142597: PPUSH
142598: CALL_OW 1
142602: ST_TO_ADDR
// ComExitBuilding ( i ) ;
142603: LD_VAR 0 4
142607: PPUSH
142608: CALL_OW 122
// end ; if sold_defenders then
142612: LD_VAR 0 17
142616: IFFALSE 142678
// if i in sold_defenders then
142618: LD_VAR 0 4
142622: PUSH
142623: LD_VAR 0 17
142627: IN
142628: IFFALSE 142678
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
142630: LD_VAR 0 4
142634: PPUSH
142635: CALL_OW 314
142639: NOT
142640: IFFALSE 142662
142642: PUSH
142643: LD_VAR 0 4
142647: PPUSH
142648: LD_VAR 0 13
142652: PPUSH
142653: CALL_OW 296
142657: PUSH
142658: LD_INT 30
142660: LESS
142661: AND
142662: IFFALSE 142678
// ComAttackUnit ( i , e ) ;
142664: LD_VAR 0 4
142668: PPUSH
142669: LD_VAR 0 13
142673: PPUSH
142674: CALL_OW 115
// end ; end ; end ;
142678: GO 142681
142680: POP
// if IsDead ( i ) then
142681: LD_VAR 0 4
142685: PPUSH
142686: CALL_OW 301
142690: IFFALSE 142708
// defenders := defenders diff i ;
142692: LD_ADDR_VAR 0 2
142696: PUSH
142697: LD_VAR 0 2
142701: PUSH
142702: LD_VAR 0 4
142706: DIFF
142707: ST_TO_ADDR
// end ;
142708: GO 141775
142710: POP
142711: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
142712: LD_VAR 0 21
142716: NOT
142717: IFTRUE 142726
142719: PUSH
142720: LD_VAR 0 2
142724: NOT
142725: OR
142726: IFTRUE 142741
142728: PUSH
142729: LD_EXP 102
142733: PUSH
142734: LD_VAR 0 1
142738: ARRAY
142739: NOT
142740: OR
142741: IFFALSE 141677
// MC_Reset ( base , 18 ) ;
142743: LD_VAR 0 1
142747: PPUSH
142748: LD_INT 18
142750: PPUSH
142751: CALL 44046 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
142755: LD_ADDR_VAR 0 2
142759: PUSH
142760: LD_VAR 0 2
142764: PUSH
142765: LD_VAR 0 2
142769: PPUSH
142770: LD_INT 2
142772: PUSH
142773: LD_INT 25
142775: PUSH
142776: LD_INT 1
142778: PUSH
142779: EMPTY
142780: LIST
142781: LIST
142782: PUSH
142783: LD_INT 25
142785: PUSH
142786: LD_INT 5
142788: PUSH
142789: EMPTY
142790: LIST
142791: LIST
142792: PUSH
142793: LD_INT 25
142795: PUSH
142796: LD_INT 8
142798: PUSH
142799: EMPTY
142800: LIST
142801: LIST
142802: PUSH
142803: LD_INT 25
142805: PUSH
142806: LD_INT 9
142808: PUSH
142809: EMPTY
142810: LIST
142811: LIST
142812: PUSH
142813: EMPTY
142814: LIST
142815: LIST
142816: LIST
142817: LIST
142818: LIST
142819: PPUSH
142820: CALL_OW 72
142824: DIFF
142825: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
142826: LD_VAR 0 21
142830: NOT
142831: IFFALSE 142854
142833: PUSH
142834: LD_VAR 0 2
142838: PPUSH
142839: LD_INT 21
142841: PUSH
142842: LD_INT 2
142844: PUSH
142845: EMPTY
142846: LIST
142847: LIST
142848: PPUSH
142849: CALL_OW 72
142853: AND
142854: IFFALSE 143198
// begin tmp := FilterByTag ( defenders , 19 ) ;
142856: LD_ADDR_VAR 0 11
142860: PUSH
142861: LD_VAR 0 2
142865: PPUSH
142866: LD_INT 19
142868: PPUSH
142869: CALL 106616 0 2
142873: ST_TO_ADDR
// if tmp then
142874: LD_VAR 0 11
142878: IFFALSE 142948
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
142880: LD_ADDR_VAR 0 11
142884: PUSH
142885: LD_VAR 0 11
142889: PPUSH
142890: LD_INT 25
142892: PUSH
142893: LD_INT 3
142895: PUSH
142896: EMPTY
142897: LIST
142898: LIST
142899: PPUSH
142900: CALL_OW 72
142904: ST_TO_ADDR
// if tmp then
142905: LD_VAR 0 11
142909: IFFALSE 142948
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
142911: LD_ADDR_EXP 114
142915: PUSH
142916: LD_EXP 114
142920: PPUSH
142921: LD_VAR 0 1
142925: PPUSH
142926: LD_EXP 114
142930: PUSH
142931: LD_VAR 0 1
142935: ARRAY
142936: PUSH
142937: LD_VAR 0 11
142941: UNION
142942: PPUSH
142943: CALL_OW 1
142947: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
142948: LD_VAR 0 1
142952: PPUSH
142953: LD_INT 19
142955: PPUSH
142956: CALL 44046 0 2
// repeat wait ( 0 0$1 ) ;
142960: LD_INT 35
142962: PPUSH
142963: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
142967: LD_EXP 102
142971: PUSH
142972: LD_VAR 0 1
142976: ARRAY
142977: NOT
142978: IFTRUE 142995
142980: PUSH
142981: LD_EXP 102
142985: PUSH
142986: LD_VAR 0 1
142990: ARRAY
142991: PUSH
142992: EMPTY
142993: EQUAL
142994: OR
142995: IFFALSE 143032
// begin for i in defenders do
142997: LD_ADDR_VAR 0 4
143001: PUSH
143002: LD_VAR 0 2
143006: PUSH
143007: FOR_IN
143008: IFFALSE 143021
// ComStop ( i ) ;
143010: LD_VAR 0 4
143014: PPUSH
143015: CALL_OW 141
143019: GO 143007
143021: POP
143022: POP
// defenders := [ ] ;
143023: LD_ADDR_VAR 0 2
143027: PUSH
143028: EMPTY
143029: ST_TO_ADDR
// exit ;
143030: GO 143262
// end ; for i in defenders do
143032: LD_ADDR_VAR 0 4
143036: PUSH
143037: LD_VAR 0 2
143041: PUSH
143042: FOR_IN
143043: IFFALSE 143132
// begin if not IsInArea ( i , mc_parking [ base ] ) then
143045: LD_VAR 0 4
143049: PPUSH
143050: LD_EXP 126
143054: PUSH
143055: LD_VAR 0 1
143059: ARRAY
143060: PPUSH
143061: CALL_OW 308
143065: NOT
143066: IFFALSE 143090
// ComMoveToArea ( i , mc_parking [ base ] ) else
143068: LD_VAR 0 4
143072: PPUSH
143073: LD_EXP 126
143077: PUSH
143078: LD_VAR 0 1
143082: ARRAY
143083: PPUSH
143084: CALL_OW 113
143088: GO 143130
// if GetControl ( i ) = control_manual then
143090: LD_VAR 0 4
143094: PPUSH
143095: CALL_OW 263
143099: PUSH
143100: LD_INT 1
143102: EQUAL
143103: IFFALSE 143130
// if IsDrivenBy ( i ) then
143105: LD_VAR 0 4
143109: PPUSH
143110: CALL_OW 311
143114: IFFALSE 143130
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
143116: LD_VAR 0 4
143120: PPUSH
143121: CALL_OW 311
143125: PPUSH
143126: CALL_OW 121
// end ;
143130: GO 143042
143132: POP
143133: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
143134: LD_VAR 0 2
143138: PPUSH
143139: LD_INT 95
143141: PUSH
143142: LD_EXP 126
143146: PUSH
143147: LD_VAR 0 1
143151: ARRAY
143152: PUSH
143153: EMPTY
143154: LIST
143155: LIST
143156: PPUSH
143157: CALL_OW 72
143161: PUSH
143162: LD_VAR 0 2
143166: EQUAL
143167: IFTRUE 143181
143169: PUSH
143170: LD_EXP 125
143174: PUSH
143175: LD_VAR 0 1
143179: ARRAY
143180: OR
143181: IFTRUE 143196
143183: PUSH
143184: LD_EXP 102
143188: PUSH
143189: LD_VAR 0 1
143193: ARRAY
143194: NOT
143195: OR
143196: IFFALSE 142960
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
143198: LD_ADDR_EXP 124
143202: PUSH
143203: LD_EXP 124
143207: PPUSH
143208: LD_VAR 0 1
143212: PPUSH
143213: LD_VAR 0 2
143217: PPUSH
143218: LD_INT 21
143220: PUSH
143221: LD_INT 2
143223: PUSH
143224: EMPTY
143225: LIST
143226: LIST
143227: PPUSH
143228: CALL_OW 72
143232: PPUSH
143233: CALL_OW 1
143237: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
143238: LD_VAR 0 1
143242: PPUSH
143243: LD_INT 19
143245: PPUSH
143246: CALL 44046 0 2
// MC_Reset ( base , 20 ) ;
143250: LD_VAR 0 1
143254: PPUSH
143255: LD_INT 20
143257: PPUSH
143258: CALL 44046 0 2
// end ; end_of_file
143262: LD_VAR 0 3
143266: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
143267: LD_VAR 0 1
143271: PUSH
143272: LD_INT 200
143274: DOUBLE
143275: GREATEREQUAL
143276: IFFALSE 143284
143278: LD_INT 299
143280: DOUBLE
143281: LESSEQUAL
143282: IFTRUE 143286
143284: GO 143318
143286: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
143287: LD_VAR 0 1
143291: PPUSH
143292: LD_VAR 0 2
143296: PPUSH
143297: LD_VAR 0 3
143301: PPUSH
143302: LD_VAR 0 4
143306: PPUSH
143307: LD_VAR 0 5
143311: PPUSH
143312: CALL 131087 0 5
143316: GO 143395
143318: LD_INT 300
143320: DOUBLE
143321: GREATEREQUAL
143322: IFFALSE 143330
143324: LD_INT 399
143326: DOUBLE
143327: LESSEQUAL
143328: IFTRUE 143332
143330: GO 143394
143332: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
143333: LD_VAR 0 1
143337: PPUSH
143338: LD_VAR 0 2
143342: PPUSH
143343: LD_VAR 0 3
143347: PPUSH
143348: LD_VAR 0 4
143352: PPUSH
143353: LD_VAR 0 5
143357: PPUSH
143358: LD_VAR 0 6
143362: PPUSH
143363: LD_VAR 0 7
143367: PPUSH
143368: LD_VAR 0 8
143372: PPUSH
143373: LD_VAR 0 9
143377: PPUSH
143378: LD_VAR 0 10
143382: PPUSH
143383: LD_VAR 0 11
143387: PPUSH
143388: CALL 126971 0 11
143392: GO 143395
143394: POP
// end ;
143395: PPOPN 11
143397: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
143398: LD_VAR 0 1
143402: PPUSH
143403: LD_VAR 0 2
143407: PPUSH
143408: LD_VAR 0 3
143412: PPUSH
143413: LD_VAR 0 4
143417: PPUSH
143418: LD_VAR 0 5
143422: PPUSH
143423: CALL 130468 0 5
// end ; end_of_file
143427: PPOPN 5
143429: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
143430: LD_VAR 0 1
143434: PPUSH
143435: LD_VAR 0 2
143439: PPUSH
143440: LD_VAR 0 3
143444: PPUSH
143445: LD_VAR 0 4
143449: PPUSH
143450: LD_VAR 0 5
143454: PPUSH
143455: LD_VAR 0 6
143459: PPUSH
143460: CALL 114511 0 6
// end ;
143464: PPOPN 6
143466: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
143467: LD_INT 0
143469: PPUSH
// begin if not units then
143470: LD_VAR 0 1
143474: NOT
143475: IFFALSE 143479
// exit ;
143477: GO 143479
// end ;
143479: PPOPN 7
143481: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
143482: CALL 114398 0 0
// end ;
143486: PPOPN 1
143488: END
